Project Path: arc_LibreHardwareMonitor_LibreHardwareMonitor_83rsqzns

Source Tree:

```txt
arc_LibreHardwareMonitor_LibreHardwareMonitor_83rsqzns
├── Aga.Controls
│   ├── Aga.Controls.csproj
│   ├── Aga.Controls.sln
│   ├── BitmapHelper.cs
│   ├── GifDecoder.cs
│   ├── NumericTextBox.cs
│   ├── PerformanceAnalyzer.cs
│   ├── Properties
│   │   ├── Resources.Designer.cs
│   │   └── Resources.resx
│   ├── ResourceHelper.cs
│   ├── Resources
│   │   ├── DVSplit.cur
│   │   ├── Folder.bmp
│   │   ├── FolderClosed.bmp
│   │   ├── Leaf.bmp
│   │   ├── check.bmp
│   │   ├── loading_icon
│   │   ├── minus.bmp
│   │   ├── plus.bmp
│   │   ├── uncheck.bmp
│   │   └── unknown.bmp
│   ├── StringCollectionEditor.cs
│   ├── TextHelper.cs
│   ├── Threading
│   │   ├── AbortableThreadPool.cs
│   │   ├── WorkItem.cs
│   │   └── WorkItemStatus.cs
│   ├── TimeCounter.cs
│   ├── Tree
│   │   ├── AutoRowHeightLayout.cs
│   │   ├── ClassDiagram.cd
│   │   ├── ColumnCollection.cs
│   │   ├── DrawContext.cs
│   │   ├── DropNodeValidatingEventArgs.cs
│   │   ├── DropPosition.cs
│   │   ├── EditorContext.cs
│   │   ├── Enums.cs
│   │   ├── FixedRowHeightLayout.cs
│   │   ├── IRowLayout.cs
│   │   ├── IToolTipProvider.cs
│   │   ├── ITreeModel.cs
│   │   ├── IncrementalSearch.cs
│   │   ├── Input
│   │   │   ├── ClickColumnState.cs
│   │   │   ├── ColumnState.cs
│   │   │   ├── InputState.cs
│   │   │   ├── InputWithControl.cs
│   │   │   ├── InputWithShift.cs
│   │   │   ├── NormalInputState.cs
│   │   │   ├── ReorderColumnState.cs
│   │   │   └── ResizeColumnState.cs
│   │   ├── ListModel.cs
│   │   ├── NativeMethods.cs
│   │   ├── Node.cs
│   │   ├── NodeControlInfo.cs
│   │   ├── NodeControls
│   │   │   ├── BaseTextControl.cs
│   │   │   ├── BindableControl.cs
│   │   │   ├── ClassDiagram.cd
│   │   │   ├── DrawEventArgs.cs
│   │   │   ├── EditEventArgs.cs
│   │   │   ├── EditableControl.cs
│   │   │   ├── ExpandingIcon.cs
│   │   │   ├── InteractiveControl.cs
│   │   │   ├── LabelEventArgs.cs
│   │   │   ├── NodeCheckBox.cs
│   │   │   ├── NodeComboBox.cs
│   │   │   ├── NodeControl.cs
│   │   │   ├── NodeControlValueEventArgs.cs
│   │   │   ├── NodeControlsCollection.cs
│   │   │   ├── NodeDecimalTextBox.cs
│   │   │   ├── NodeEventArgs.cs
│   │   │   ├── NodeIcon.cs
│   │   │   ├── NodeIntegerTextBox.cs
│   │   │   ├── NodeNumericUpDown.cs
│   │   │   ├── NodePlusMinus.cs
│   │   │   ├── NodeStateIcon.cs
│   │   │   └── NodeTextBox.cs
│   │   ├── SortedTreeModel.cs
│   │   ├── TreeColumn.cs
│   │   ├── TreeColumnCollection.cs
│   │   ├── TreeColumnEventArgs.cs
│   │   ├── TreeListAdapter.cs
│   │   ├── TreeModel.cs
│   │   ├── TreeModelBase.cs
│   │   ├── TreeModelEventArgs.cs
│   │   ├── TreeNodeAdv.cs
│   │   ├── TreeNodeAdvMouseEventArgs.cs
│   │   ├── TreePath.cs
│   │   ├── TreePathEventArgs.cs
│   │   ├── TreeViewAdv.Designer.cs
│   │   ├── TreeViewAdv.Draw.cs
│   │   ├── TreeViewAdv.Editor.cs
│   │   ├── TreeViewAdv.Input.cs
│   │   ├── TreeViewAdv.Properties.cs
│   │   ├── TreeViewAdv.cs
│   │   ├── TreeViewAdv.resx
│   │   ├── TreeViewAdvCancelEventArgs.cs
│   │   ├── TreeViewAdvEventArgs.cs
│   │   └── TreeViewRowDrawEventArgs.cs
│   └── license.txt
├── Directory.Build.props
├── LICENSE
├── LibreHardwareMonitor
│   ├── LibreHardwareMonitor.csproj
│   ├── Program.cs
│   ├── Resources
│   │   ├── PawnIO_setup.exe
│   │   ├── Web
│   │   │   ├── css
│   │   │   │   ├── custom-theme
│   │   │   │   │   ├── images
│   │   │   │   │   │   ├── ui-bg_flat_0_aaaaaa_40x100.png
│   │   │   │   │   │   ├── ui-bg_glass_55_fbf9ee_1x400.png
│   │   │   │   │   │   ├── ui-bg_glass_65_ffffff_1x400.png
│   │   │   │   │   │   ├── ui-bg_glass_75_dadada_1x400.png
│   │   │   │   │   │   ├── ui-bg_glass_75_e6e6e6_1x400.png
│   │   │   │   │   │   ├── ui-bg_glass_75_ffffff_1x400.png
│   │   │   │   │   │   ├── ui-bg_highlight-soft_75_cccccc_1x100.png
│   │   │   │   │   │   ├── ui-bg_inset-soft_95_fef1ec_1x100.png
│   │   │   │   │   │   ├── ui-icons_222222_256x240.png
│   │   │   │   │   │   ├── ui-icons_2e83ff_256x240.png
│   │   │   │   │   │   ├── ui-icons_454545_256x240.png
│   │   │   │   │   │   ├── ui-icons_888888_256x240.png
│   │   │   │   │   │   └── ui-icons_cd0a0a_256x240.png
│   │   │   │   │   └── jquery-ui-1.8.16.custom.css
│   │   │   │   ├── jquery.treeTable.css
│   │   │   │   └── ohm_web.css
│   │   │   ├── favicon.ico
│   │   │   ├── images
│   │   │   │   ├── toggle-collapse-dark.png
│   │   │   │   ├── toggle-collapse-light.png
│   │   │   │   ├── toggle-expand-dark.png
│   │   │   │   ├── toggle-expand-light.png
│   │   │   │   └── transparent.png
│   │   │   ├── index.html
│   │   │   └── js
│   │   │       ├── jquery-1.7.2.js
│   │   │       ├── jquery-1.7.2.min.js
│   │   │       ├── jquery-ui-1.8.16.custom.min.js
│   │   │       ├── jquery.tmpl.js
│   │   │       ├── jquery.tmpl.min.js
│   │   │       ├── jquery.treeTable.min.js
│   │   │       ├── knockout-2.1.0.js
│   │   │       ├── knockout-2.1.0.min.js
│   │   │       ├── knockout.mapping-latest.js
│   │   │       ├── knockout.mapping-latest.min.js
│   │   │       └── ohm_web.js
│   │   ├── amd.png
│   │   ├── app.manifest
│   │   ├── ati.png
│   │   ├── barback.png
│   │   ├── barblue.png
│   │   ├── battery.png
│   │   ├── chip.png
│   │   ├── clock.png
│   │   ├── computer.png
│   │   ├── control.png
│   │   ├── cpu.png
│   │   ├── current.png
│   │   ├── data.png
│   │   ├── factor.png
│   │   ├── fan.png
│   │   ├── flow.png
│   │   ├── gadget.png
│   │   ├── gadget.xcf
│   │   ├── hdd.png
│   │   ├── humidity.png
│   │   ├── icon.ico
│   │   ├── icon.xcf
│   │   ├── intel.png
│   │   ├── level.png
│   │   ├── load.png
│   │   ├── loudspeaker.png
│   │   ├── mainboard.png
│   │   ├── nic.png
│   │   ├── nvidia.png
│   │   ├── power-supply.png
│   │   ├── power.png
│   │   ├── powermonitor.png
│   │   ├── ram.png
│   │   ├── smallicon.ico
│   │   ├── temperature.png
│   │   ├── throughput.png
│   │   ├── time.png
│   │   └── voltage.png
│   ├── TestScripts
│   │   ├── LiquidCool.py
│   │   ├── basicrest.py
│   │   └── basicwmi.py
│   ├── UI
│   │   ├── AboutBox.Designer.cs
│   │   ├── AboutBox.cs
│   │   ├── AboutBox.resx
│   │   ├── AuthForm.Designer.cs
│   │   ├── AuthForm.cs
│   │   ├── AuthForm.resx
│   │   ├── Gadget.cs
│   │   ├── GadgetWindow.cs
│   │   ├── HardwareNode.cs
│   │   ├── HardwareTypeImage.cs
│   │   ├── IExpandPersistNode.cs
│   │   ├── InterfacePortForm.Designer.cs
│   │   ├── InterfacePortForm.cs
│   │   ├── InterfacePortForm.resx
│   │   ├── MainForm.Designer.cs
│   │   ├── MainForm.cs
│   │   ├── MainForm.resx
│   │   ├── Node.cs
│   │   ├── NodeToolTipProvider.cs
│   │   ├── NotifyIconAdv.cs
│   │   ├── ParameterForm.Designer.cs
│   │   ├── ParameterForm.cs
│   │   ├── ParameterForm.resx
│   │   ├── PlotPanel.cs
│   │   ├── ScaledPlotModel.cs
│   │   ├── SensorGadget.cs
│   │   ├── SensorNode.cs
│   │   ├── SensorNotifyIcon.cs
│   │   ├── ShowDesktop.cs
│   │   ├── SplitContainerAdv.cs
│   │   ├── StartupManager.cs
│   │   ├── SystemTray.cs
│   │   ├── Theme.cs
│   │   ├── Themes
│   │   │   ├── BlackTheme.cs
│   │   │   ├── DarkTheme.cs
│   │   │   ├── LightTheme.cs
│   │   │   ├── ThemedHScrollIndicator.cs
│   │   │   ├── ThemedToolStripRenderer.cs
│   │   │   └── ThemedVScrollIndicator.cs
│   │   ├── ToolStripRadioButtonMenuItem.cs
│   │   ├── TreeModel.cs
│   │   ├── TypeNode.cs
│   │   ├── UnitManager.cs
│   │   ├── UpdateVisitor.cs
│   │   ├── UserOption.cs
│   │   └── UserRadioGroup.cs
│   └── Utilities
│       ├── EmbeddedResources.cs
│       ├── HttpServer.cs
│       ├── IconFactory.cs
│       ├── Logger.cs
│       ├── LoggerFileRotation.cs
│       └── PersistentSettings.cs
├── LibreHardwareMonitor.sln
├── LibreHardwareMonitorLib
│   ├── Hardware
│   │   ├── Battery
│   │   │   ├── Battery.cs
│   │   │   ├── BatteryChemistry.cs
│   │   │   └── BatteryGroup.cs
│   │   ├── CompositeSensor.cs
│   │   ├── Computer.cs
│   │   ├── Control.cs
│   │   ├── Controller
│   │   │   ├── AeroCool
│   │   │   │   ├── AeroCoolGroup.cs
│   │   │   │   └── P7-H1.cs
│   │   │   ├── AquaComputer
│   │   │   │   ├── AquaComputerGroup.cs
│   │   │   │   ├── AquastreamUltimate.cs
│   │   │   │   ├── AquastreamXT.cs
│   │   │   │   ├── D5Next.cs
│   │   │   │   ├── Farbwerk.cs
│   │   │   │   ├── Farbwerk360.cs
│   │   │   │   ├── HighFlowNext.cs
│   │   │   │   ├── MPS.cs
│   │   │   │   ├── Octo.cs
│   │   │   │   └── Quadro.cs
│   │   │   ├── Arctic
│   │   │   │   ├── ArcticFanController.cs
│   │   │   │   ├── ArcticGroup.cs
│   │   │   │   └── README.MD
│   │   │   ├── Heatmaster
│   │   │   │   ├── Heatmaster.cs
│   │   │   │   └── HeatmasterGroup.cs
│   │   │   ├── MSI
│   │   │   │   ├── MsiConstants.cs
│   │   │   │   ├── MsiCoreLiquidController.cs
│   │   │   │   ├── MsiDevice.cs
│   │   │   │   ├── MsiFan.cs
│   │   │   │   ├── MsiFanControl.cs
│   │   │   │   ├── MsiFanMode.cs
│   │   │   │   ├── MsiGroup.cs
│   │   │   │   └── MsiSensor.cs
│   │   │   ├── Nzxt
│   │   │   │   ├── GridV3.cs
│   │   │   │   ├── KrakenV2.cs
│   │   │   │   ├── KrakenV3.cs
│   │   │   │   └── NzxtGroup.cs
│   │   │   ├── Razer
│   │   │   │   ├── RazerFanController.cs
│   │   │   │   └── RazerGroup.cs
│   │   │   └── TBalancer
│   │   │       ├── TBalancer.cs
│   │   │       └── TBalancerGroup.cs
│   │   ├── CoreType.cs
│   │   ├── Cpu
│   │   │   ├── Amd0FCpu.cs
│   │   │   ├── Amd10Cpu.cs
│   │   │   ├── Amd17Cpu.cs
│   │   │   ├── AmdCpu.cs
│   │   │   ├── CpuGroup.cs
│   │   │   ├── CpuId.cs
│   │   │   ├── CpuLoad.cs
│   │   │   ├── GenericCpu.cs
│   │   │   └── IntelCpu.cs
│   │   ├── D3DDisplayDevice.cs
│   │   ├── FirmwareTable.cs
│   │   ├── Gpu
│   │   │   ├── AmdGpu.cs
│   │   │   ├── AmdGpuGroup.cs
│   │   │   ├── GenericGpu.cs
│   │   │   ├── IntelDiscreteGpu.cs
│   │   │   ├── IntelGpuGroup.cs
│   │   │   ├── IntelIntegratedGpu.cs
│   │   │   ├── NvidiaGpu.cs
│   │   │   └── NvidiaGroup.cs
│   │   ├── GroupAffinity.cs
│   │   ├── Hardware.cs
│   │   ├── HardwareType.cs
│   │   ├── IComputer.cs
│   │   ├── IControl.cs
│   │   ├── IElement.cs
│   │   ├── IGroup.cs
│   │   ├── IHardware.cs
│   │   ├── IHardwareChanged.cs
│   │   ├── IParameter.cs
│   │   ├── ISensor.cs
│   │   ├── ISensorLimits.cs
│   │   ├── ISettings.cs
│   │   ├── IVisitor.cs
│   │   ├── Identifier.cs
│   │   ├── Memory
│   │   │   ├── DimmMemory.cs
│   │   │   ├── MemoryGroup.cs
│   │   │   ├── MemoryLinux.cs
│   │   │   ├── MemoryWindows.cs
│   │   │   ├── Sensors
│   │   │   │   └── SpdThermalSensor.cs
│   │   │   ├── TotalMemory.cs
│   │   │   └── VirtualMemory.cs
│   │   ├── Motherboard
│   │   │   ├── Control.cs
│   │   │   ├── Fan.cs
│   │   │   ├── Identification.cs
│   │   │   ├── Lpc
│   │   │   │   ├── Chip.cs
│   │   │   │   ├── EC
│   │   │   │   │   ├── ChromeOSEmbeddedController.cs
│   │   │   │   │   ├── ChromeOSEmbeddedControllerIO.cs
│   │   │   │   │   ├── EmbeddedController.cs
│   │   │   │   │   ├── EmbeddedControllerReader.cs
│   │   │   │   │   ├── EmbeddedControllerSource.cs
│   │   │   │   │   ├── IEmbeddedControllerIO.cs
│   │   │   │   │   ├── WindowsEmbeddedController.cs
│   │   │   │   │   └── WindowsEmbeddedControllerIO.cs
│   │   │   │   ├── EcioPortGigabyteController.cs
│   │   │   │   ├── F718XX.cs
│   │   │   │   ├── IGigabyteController.cs
│   │   │   │   ├── ISuperIO.cs
│   │   │   │   ├── IT879xEcioPort.cs
│   │   │   │   ├── IT87XX.cs
│   │   │   │   ├── Ipmi.cs
│   │   │   │   ├── IsaBridgeGigabyteController.cs
│   │   │   │   ├── LMSensors.cs
│   │   │   │   ├── LpcIO.cs
│   │   │   │   ├── LpcPort.cs
│   │   │   │   ├── Nct677X.cs
│   │   │   │   └── W836XX.cs
│   │   │   ├── Manufacturer.cs
│   │   │   ├── Model.cs
│   │   │   ├── Motherboard.cs
│   │   │   ├── MotherboardGroup.cs
│   │   │   ├── SuperIOHardware.cs
│   │   │   ├── Temperature.cs
│   │   │   └── Voltage.cs
│   │   ├── Mutexes.cs
│   │   ├── Network
│   │   │   ├── Network.cs
│   │   │   └── NetworkGroup.cs
│   │   ├── OpCode.cs
│   │   ├── Parameter.cs
│   │   ├── ParameterDescription.cs
│   │   ├── PowerMonitor
│   │   │   ├── IPowerMonitor.cs
│   │   │   ├── PowerMonitorGroup.cs
│   │   │   ├── SharedSerialPort.cs
│   │   │   ├── WireViewPro2.cs
│   │   │   └── WireViewPro2Sensor.cs
│   │   ├── Psu
│   │   │   ├── Corsair
│   │   │   │   ├── CorsairPsu.cs
│   │   │   │   ├── CorsairPsuGroup.cs
│   │   │   │   └── UsbApi.cs
│   │   │   ├── Msi
│   │   │   │   ├── MsiPsu.cs
│   │   │   │   ├── MsiPsuGroup.cs
│   │   │   │   └── UsbApi.cs
│   │   │   └── ProtocolError.cs
│   │   ├── RyzenSMU.cs
│   │   ├── SMBios.cs
│   │   ├── Sensor.cs
│   │   ├── SensorVisitor.cs
│   │   ├── Storage
│   │   │   ├── ISmart.cs
│   │   │   ├── SmartAttribute.cs
│   │   │   ├── SmartAttributeTranslator.cs
│   │   │   ├── StorageDevice.cs
│   │   │   ├── StorageDeviceSensor.cs
│   │   │   └── StorageGroup.cs
│   │   └── ThreadAffinity.cs
│   ├── Interop
│   │   ├── AtiAdlxx.cs
│   │   ├── ByteExtensions.cs
│   │   ├── Ftd2xx.cs
│   │   ├── IntelGcl.cs
│   │   ├── Ipmi.cs
│   │   ├── LibC.cs
│   │   ├── NvApi.cs
│   │   ├── NvidiaML.cs
│   │   └── PowerMonitor
│   │       ├── DeviceData.cs
│   │       ├── Stm32PortFinder.cs
│   │       ├── StructureConversion.cs
│   │       ├── WireViewPro2Enums.cs
│   │       └── WireViewPro2Structures.cs
│   ├── LibreHardwareMonitorLib.csproj
│   ├── NativeMethods.txt
│   ├── PawnIo
│   │   ├── AmdFamily0F.cs
│   │   ├── AmdFamily10.cs
│   │   ├── AmdFamily17.cs
│   │   ├── IntelMsr.cs
│   │   ├── IsaBridgeEc.cs
│   │   ├── LpcACPIEC.cs
│   │   ├── LpcCrOS.cs
│   │   ├── LpcIO.cs
│   │   ├── PawnIo.cs
│   │   └── RyzenSmu.cs
│   ├── RAMSPDToolkitDriver.cs
│   ├── Resources
│   │   ├── PawnIo
│   │   │   ├── AMDFamily0F.bin
│   │   │   ├── AMDFamily10.bin
│   │   │   ├── AMDFamily17.bin
│   │   │   ├── COPYING
│   │   │   ├── IntelMSR.bin
│   │   │   ├── IsaBridgeEC.bin
│   │   │   ├── LpcACPIEC.bin
│   │   │   ├── LpcCrOSEC.bin
│   │   │   ├── LpcIO.bin
│   │   │   ├── README
│   │   │   ├── RyzenSMU.bin
│   │   │   ├── SmbusI801.bin
│   │   │   ├── SmbusNCT6793.bin
│   │   │   └── SmbusPIIX4.bin
│   │   └── packageicon.png
│   ├── Software
│   │   └── OperatingSystem.cs
│   └── main.nuget.target
├── README.md
└── THIRD-PARTY-NOTICES.txt

```

`Aga.Controls/Aga.Controls.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <GenerateResourceUsePreserializedResources>true</GenerateResourceUsePreserializedResources>
    <Platforms>x64;x86;ARM64</Platforms>
  </PropertyGroup>
  <PropertyGroup>
    <ProductVersion>9.0.30729</ProductVersion>
    <TargetFramework>net472</TargetFramework>
    <AssemblyTitle>Aga.Controls</AssemblyTitle>
    <Description>http://sourceforge.net/projects/treeviewadv/</Description>
    <Copyright>Copyright © Andrey Gliznetsov 2006 - 2009</Copyright>
    <AssemblyVersion>1.7.0.0</AssemblyVersion>
    <FileVersion>1.7.0.0</FileVersion>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <OutputPath>..\bin\$(Configuration)\</OutputPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebugType>full</DebugType>
    <DefineConstants>TRACE;DEBUG;PERF_TEST</DefineConstants>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebugType>pdbonly</DebugType>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System.Design" />
    <Reference Include="System.Windows.Forms" />
  </ItemGroup>
  <ItemGroup>
    <Compile Update="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <Compile Update="Tree\NodeControls\NodeIntegerTextBox.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\NodeControls\NodeDecimalTextBox.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="NumericTextBox.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\NodeControls\ExpandingIcon.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\NodeControls\InteractiveControl.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\TreeViewAdv.Draw.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\TreeViewAdv.Editor.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\TreeViewAdv.Input.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\NodeControls\NodeNumericUpDown.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\TreeViewAdv.Properties.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\NodeControls\BaseTextControl.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\NodeControls\EditableControl.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\NodeControls\NodeComboBox.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\TreeColumn.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\NodeControls\NodeControl.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\NodeControls\BindableControl.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\NodeControls\NodeCheckBox.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\NodeControls\NodeIcon.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\NodeControls\NodePlusMinus.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\NodeControls\NodeTextBox.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\NodeControls\NodeStateIcon.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\TreeViewAdv.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="Tree\TreeViewAdv.Designer.cs">
      <DependentUpon>TreeViewAdv.cs</DependentUpon>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <Content Include="Resources\**" />
  </ItemGroup>
  <ItemGroup>
    <EmbeddedResource Update="Properties\Resources.resx">
      <SubType>Designer</SubType>
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
    <EmbeddedResource Update="Tree\TreeViewAdv.resx">
      <DependentUpon>TreeViewAdv.cs</DependentUpon>
    </EmbeddedResource>
  </ItemGroup>
  <ItemGroup>
    <None Include="Tree\ClassDiagram.cd" />
    <None Include="Tree\NodeControls\ClassDiagram.cd" />
  </ItemGroup>
  <ItemGroup>
    <Compile Remove="Tree\ColumnCollection.cs" />
    <Compile Remove="Tree\NativeMethods.cs" />
  </ItemGroup>
  <ItemGroup>
    <PackageReference Include="System.Resources.Extensions" Version="10.0.3" />
  </ItemGroup>
</Project>

```

`Aga.Controls/Aga.Controls.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 11.00
# Visual Studio 2010
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Aga.Controls", "Aga.Controls.csproj", "{E73BB233-D88B-44A7-A98F-D71EE158381D}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{E73BB233-D88B-44A7-A98F-D71EE158381D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{E73BB233-D88B-44A7-A98F-D71EE158381D}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{E73BB233-D88B-44A7-A98F-D71EE158381D}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{E73BB233-D88B-44A7-A98F-D71EE158381D}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`Aga.Controls/BitmapHelper.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Drawing.Imaging;

namespace Aga.Controls
{
	public static class BitmapHelper
	{
		[StructLayout(LayoutKind.Sequential)]
		private struct PixelData
		{
			public byte B;
			public byte G;
			public byte R;
			public byte A;
		}

		public static void SetAlphaChanelValue(Bitmap image, byte value)
		{
			if (image == null)
				throw new ArgumentNullException("image");
			if (image.PixelFormat != PixelFormat.Format32bppArgb)
				throw new ArgumentException("Wrong PixelFormat");

			BitmapData bitmapData = image.LockBits(new Rectangle(0, 0, image.Width, image.Height),
									 ImageLockMode.ReadWrite, PixelFormat.Format32bppArgb);
			unsafe
			{
				PixelData* pPixel = (PixelData*)bitmapData.Scan0;
				for (int i = 0; i < bitmapData.Height; i++)
				{
					for (int j = 0; j < bitmapData.Width; j++)
					{
						pPixel->A = value;
						pPixel++;
					}
					pPixel += bitmapData.Stride - (bitmapData.Width * 4);
				}
			}
			image.UnlockBits(bitmapData);
		}
	}
}

```

`Aga.Controls/GifDecoder.cs`:

```cs
#pragma warning disable 675 // Bitwise-or operator used on a sign-extended operand

#region Java Info
/**
 * Class GifDecoder - Decodes a GIF file into one or more frames.
 * <br><pre>
 * Example:
 *    GifDecoder d = new GifDecoder();
 *    d.read("sample.gif");
 *    int n = d.getFrameCount();
 *    for (int i = 0; i < n; i++) {
 *       BufferedImage frame = d.getFrame(i);  // frame i
 *       int t = d.getDelay(i);  // display duration of frame in milliseconds
 *       // do something with frame
 *    }
 * </pre>
 * No copyright asserted on the source code of this class.  May be used for
 * any purpose, however, refer to the Unisys LZW patent for any additional
 * restrictions.  Please forward any corrections to kweiner@fmsware.com.
 *
 * @author Kevin Weiner, FM Software; LZW decoder adapted from John Cristy's ImageMagick.
 * @version 1.03 November 2003
 *
 */
#endregion

using System;
using System.Collections;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;

namespace Aga.Controls
{
	public class GifFrame
	{
		private Image _image;
		public Image Image
		{
			get { return _image; }
		}

		private int _delay;
		public int Delay
		{
			get { return _delay; }
		}

		public GifFrame(Image im, int del)
		{
			_image = im;
			_delay = del;
		}
	}

	public class GifDecoder 
	{
		public const int StatusOK = 0;//File read status: No errors.
		public const int StatusFormatError = 1; //File read status: Error decoding file (may be partially decoded)
		public const int StatusOpenError = 2; //Unable to open source.

		private Stream inStream;
		private int status;

		private int width; // full image width
		private int height; // full image height
		private bool gctFlag; // global color table used
		private int gctSize; // size of global color table
		private int loopCount = 1; // iterations; 0 = repeat forever

		private int[] gct; // global color table
		private int[] lct; // local color table
		private int[] act; // active color table

		private int bgIndex; // background color index
		private int bgColor; // background color
		private int lastBgColor; // previous bg color
		private int pixelAspect; // pixel aspect ratio

		private bool lctFlag; // local color table flag
		private bool interlace; // interlace flag
		private int lctSize; // local color table size

		private int ix, iy, iw, ih; // current image rectangle
		private Rectangle lastRect; // last image rect
		private Image image; // current frame
		private Bitmap bitmap;
		private Image lastImage; // previous frame

		private byte[] block = new byte[256]; // current data block
		private int blockSize = 0; // block size

		// last graphic control extension info
		private int dispose = 0;
		// 0=no action; 1=leave in place; 2=restore to bg; 3=restore to prev
		private int lastDispose = 0;
		private bool transparency = false; // use transparent color
		private int delay = 0; // delay in milliseconds
		private int transIndex; // transparent color index

		private const int MaxStackSize = 4096;
		// max decoder pixel stack size

		// LZW decoder working arrays
		private short[] prefix;
		private byte[] suffix;
		private byte[] pixelStack;
		private byte[] pixels;

		private ArrayList frames; // frames read from current file
		private int frameCount;
		private bool _makeTransparent;

		/**
		 * Gets the number of frames read from file.
		 * @return frame count
		 */
		public int FrameCount
		{
			get
			{
				return frameCount;
			}
		}

		/**
		 * Gets the first (or only) image read.
		 *
		 * @return BufferedImage containing first frame, or null if none.
		 */
		public Image Image
		{
			get
			{
				return GetFrame(0).Image;
			}
		}

		/**
		 * Gets the "Netscape" iteration count, if any.
		 * A count of 0 means repeat indefinitiely.
		 *
		 * @return iteration count if one was specified, else 1.
		 */
		public int LoopCount
		{
			get
			{
				return loopCount;
			}
		}

		public GifDecoder(Stream stream, bool makeTransparent)
		{
			_makeTransparent = makeTransparent;
			if (Read(stream) != 0)
				throw new InvalidOperationException();
		}

		/**
		 * Creates new frame image from current data (and previous
		 * frames as specified by their disposition codes).
		 */
		private int[] GetPixels(Bitmap bitmap)
		{
			int [] pixels = new int [ 3 * image.Width * image.Height ];
			int count = 0;
			for (int th = 0; th < image.Height; th++)
			{
				for (int tw = 0; tw < image.Width; tw++)
				{
					Color color = bitmap.GetPixel(tw, th);
					pixels[count] = color.R;
					count++;
					pixels[count] = color.G;
					count++;
					pixels[count] = color.B;
					count++;
				}
			}
			return pixels;
		}

		private void SetPixels(int[] pixels)
		{
			int count = 0;
			for (int th = 0; th < image.Height; th++)
			{
				for (int tw = 0; tw < image.Width; tw++)
				{
					Color color = Color.FromArgb( pixels[count++] );
					bitmap.SetPixel( tw, th, color );
				}
			}
			if (_makeTransparent)
				bitmap.MakeTransparent(bitmap.GetPixel(0, 0));
		}

		private void SetPixels() 
		{
			// expose destination image's pixels as int array
			//		int[] dest =
			//			(( int ) image.getRaster().getDataBuffer()).getData();
			int[] dest = GetPixels( bitmap );

			// fill in starting image contents based on last image's dispose code
			if (lastDispose > 0) 
			{
				if (lastDispose == 3) 
				{
					// use image before last
					int n = frameCount - 2;
					if (n > 0) 
					{
						lastImage = GetFrame(n - 1).Image;
					} 
					else 
					{
						lastImage = null;
					}
				}

				if (lastImage != null) 
				{
					//				int[] prev =
					//					((DataBufferInt) lastImage.getRaster().getDataBuffer()).getData();
					int[] prev = GetPixels( new Bitmap( lastImage ) );
					Array.Copy(prev, 0, dest, 0, width * height);
					// copy pixels

					if (lastDispose == 2) 
					{
						// fill last image rect area with background color
						Graphics g = Graphics.FromImage( image );
						Color c = Color.Empty;
						if (transparency) 
						{
							c = Color.FromArgb( 0, 0, 0, 0 ); 	// assume background is transparent
						} 
						else 
						{
							c = Color.FromArgb( lastBgColor ) ;
							//						c = new Color(lastBgColor); // use given background color
						}
						Brush brush = new SolidBrush( c );
						g.FillRectangle( brush, lastRect );
						brush.Dispose();
						g.Dispose();
					}
				}
			}

			// copy each source line to the appropriate place in the destination
			int pass = 1;
			int inc = 8;
			int iline = 0;
			for (int i = 0; i < ih; i++) 
			{
				int line = i;
				if (interlace) 
				{
					if (iline >= ih) 
					{
						pass++;
						switch (pass) 
						{
							case 2 :
								iline = 4;
								break;
							case 3 :
								iline = 2;
								inc = 4;
								break;
							case 4 :
								iline = 1;
								inc = 2;
								break;
						}
					}
					line = iline;
					iline += inc;
				}
				line += iy;
				if (line < height) 
				{
					int k = line * width;
					int dx = k + ix; // start of line in dest
					int dlim = dx + iw; // end of dest line
					if ((k + width) < dlim) 
					{
						dlim = k + width; // past dest edge
					}
					int sx = i * iw; // start of line in source
					while (dx < dlim) 
					{
						// map color and insert in destination
						int index = ((int) pixels[sx++]) & 0xff;
						int c = act[index];
						if (c != 0) 
						{
							dest[dx] = c;
						}
						dx++;
					}
				}
			}
			SetPixels( dest );
		}

		/**
		 * Gets the image contents of frame n.
		 *
		 * @return BufferedImage representation of frame.
		 */
		public GifFrame GetFrame(int n) 
		{
			if ((n >= 0) && (n < frameCount))
				return (GifFrame)frames[n];
			else
				throw new ArgumentOutOfRangeException();
		}

		/**
		 * Gets image size.
		 *
		 * @return GIF image dimensions
		 */
		public Size FrameSize
		{
			get
			{
				return new Size(width, height);
			}
		}

		/**
		 * Reads GIF image from stream
		 *
		 * @param BufferedInputStream containing GIF file.
		 * @return read status code (0 = no errors)
		 */
		private int Read( Stream inStream ) 
		{
			Init();
			if ( inStream != null) 
			{
				this.inStream = inStream;
				ReadHeader();
				if (!Error()) 
				{
					ReadContents();
					if (frameCount < 0) 
					{
						status = StatusFormatError;
					}
				}
				inStream.Close();
			} 
			else 
			{
				status = StatusOpenError;
			}
			return status;
		}


		/**
		 * Decodes LZW image data into pixel array.
		 * Adapted from John Cristy's ImageMagick.
		 */
		private void DecodeImageData() 
		{
			int NullCode = -1;
			int npix = iw * ih;
			int available, 
				clear,
				code_mask,
				code_size,
				end_of_information,
				in_code,
				old_code,
				bits,
				code,
				count,
				i,
				datum,
				data_size,
				first,
				top,
				bi,
				pi;

			if ((pixels == null) || (pixels.Length < npix)) 
			{
				pixels = new byte[npix]; // allocate new pixel array
			}
			if (prefix == null) prefix = new short[MaxStackSize];
			if (suffix == null) suffix = new byte[MaxStackSize];
			if (pixelStack == null) pixelStack = new byte[MaxStackSize + 1];

			//  Initialize GIF data stream decoder.

			data_size = Read();
			clear = 1 << data_size;
			end_of_information = clear + 1;
			available = clear + 2;
			old_code = NullCode;
			code_size = data_size + 1;
			code_mask = (1 << code_size) - 1;
			for (code = 0; code < clear; code++) 
			{
				prefix[code] = 0;
				suffix[code] = (byte) code;
			}

			//  Decode GIF pixel stream.

			datum = bits = count = first = top = pi = bi = 0;

			for (i = 0; i < npix;) 
			{
				if (top == 0) 
				{
					if (bits < code_size) 
					{
						//  Load bytes until there are enough bits for a code.
						if (count == 0) 
						{
							// Read a new data block.
							count = ReadBlock();
							if (count <= 0)
								break;
							bi = 0;
						}
						datum += (((int) block[bi]) & 0xff) << bits;
						bits += 8;
						bi++;
						count--;
						continue;
					}

					//  Get the next code.

					code = datum & code_mask;
					datum >>= code_size;
					bits -= code_size;

					//  Interpret the code

					if ((code > available) || (code == end_of_information))
						break;
					if (code == clear) 
					{
						//  Reset decoder.
						code_size = data_size + 1;
						code_mask = (1 << code_size) - 1;
						available = clear + 2;
						old_code = NullCode;
						continue;
					}
					if (old_code == NullCode) 
					{
						pixelStack[top++] = suffix[code];
						old_code = code;
						first = code;
						continue;
					}
					in_code = code;
					if (code == available) 
					{
						pixelStack[top++] = (byte) first;
						code = old_code;
					}
					while (code > clear) 
					{
						pixelStack[top++] = suffix[code];
						code = prefix[code];
					}
					first = ((int) suffix[code]) & 0xff;

					//  Add a new string to the string table,

					if (available >= MaxStackSize)
						break;
					pixelStack[top++] = (byte) first;
					prefix[available] = (short) old_code;
					suffix[available] = (byte) first;
					available++;
					if (((available & code_mask) == 0)
						&& (available < MaxStackSize)) 
					{
						code_size++;
						code_mask += available;
					}
					old_code = in_code;
				}

				//  Pop a pixel off the pixel stack.

				top--;
				pixels[pi++] = pixelStack[top];
				i++;
			}

			for (i = pi; i < npix; i++) 
			{
				pixels[i] = 0; // clear missing pixels
			}

		}

		/**
		 * Returns true if an error was encountered during reading/decoding
		 */
		private bool Error() 
		{
			return status != StatusOK;
		}

		/**
		 * Initializes or re-initializes reader
		 */
		private void Init() 
		{
			status = StatusOK;
			frameCount = 0;
			frames = new ArrayList();
			gct = null;
			lct = null;
		}

		/**
		 * Reads a single byte from the input stream.
		 */
		private int Read() 
		{
			int curByte = 0;
			try 
			{
				curByte = inStream.ReadByte();
			} 
			catch (IOException) 
			{
				status = StatusFormatError;
			}
			return curByte;
		}

		/**
		 * Reads next variable length block from input.
		 *
		 * @return number of bytes stored in "buffer"
		 */
		private int ReadBlock() 
		{
			blockSize = Read();
			int n = 0;
			if (blockSize > 0) 
			{
				try 
				{
					int count = 0;
					while (n < blockSize) 
					{
						count = inStream.Read(block, n, blockSize - n);
						if (count == -1) 
							break;
						n += count;
					}
				} 
				catch (IOException) 
				{
				}

				if (n < blockSize) 
				{
					status = StatusFormatError;
				}
			}
			return n;
		}

		/**
		 * Reads color table as 256 RGB integer values
		 *
		 * @param ncolors int number of colors to read
		 * @return int array containing 256 colors (packed ARGB with full alpha)
		 */
		private int[] ReadColorTable(int ncolors) 
		{
			int nbytes = 3 * ncolors;
			int[] tab = null;
			byte[] c = new byte[nbytes];
			int n = 0;
			try 
			{
				n = inStream.Read(c, 0, c.Length );
			} 
			catch (IOException) 
			{
			}
			if (n < nbytes) 
			{
				status = StatusFormatError;
			} 
			else 
			{
				tab = new int[256]; // max size to avoid bounds checks
				int i = 0;
				int j = 0;
				while (i < ncolors) 
				{
					int r = ((int) c[j++]) & 0xff;
					int g = ((int) c[j++]) & 0xff;
					int b = ((int) c[j++]) & 0xff;
					tab[i++] = ( int ) ( 0xff000000 | (r << 16) | (g << 8) | b );
				}
			}
			return tab;
		}

		/**
		 * Main file parser.  Reads GIF content blocks.
		 */
		private void ReadContents() 
		{
			// read GIF file content blocks
			bool done = false;
			while (!(done || Error())) 
			{
				int code = Read();
				switch (code) 
				{

					case 0x2C : // image separator
						ReadImage();
						break;

					case 0x21 : // extension
						code = Read();
					switch (code) 
					{
						case 0xf9 : // graphics control extension
							ReadGraphicControlExt();
							break;

						case 0xff : // application extension
							ReadBlock();
							String app = "";
							for (int i = 0; i < 11; i++) 
							{
								app += (char) block[i];
							}
							if (app.Equals("NETSCAPE2.0")) 
							{
								ReadNetscapeExt();
							}
							else
								Skip(); // don't care
							break;

						default : // uninteresting extension
							Skip();
							break;
					}
						break;

					case 0x3b : // terminator
						done = true;
						break;

					case 0x00 : // bad byte, but keep going and see what happens
						break;

					default :
						status = StatusFormatError;
						break;
				}
			}
		}

		/**
		 * Reads Graphics Control Extension values
		 */
		private void ReadGraphicControlExt() 
		{
			Read(); // block size
			int packed = Read(); // packed fields
			dispose = (packed & 0x1c) >> 2; // disposal method
			if (dispose == 0) 
			{
				dispose = 1; // elect to keep old image if discretionary
			}
			transparency = (packed & 1) != 0;
			delay = ReadShort() * 10; // delay in milliseconds
			transIndex = Read(); // transparent color index
			Read(); // block terminator
		}

		/**
		 * Reads GIF file header information.
		 */
		private void ReadHeader() 
		{
			String id = "";
			for (int i = 0; i < 6; i++) 
			{
				id += (char) Read();
			}
			if (!id.StartsWith("GIF")) 
			{
				status = StatusFormatError;
				return;
			}

			ReadLSD();
			if (gctFlag && !Error()) 
			{
				gct = ReadColorTable(gctSize);
				bgColor = gct[bgIndex];
			}
		}

		/**
		 * Reads next frame image
		 */
		private void ReadImage() 
		{
			ix = ReadShort(); // (sub)image position & size
			iy = ReadShort();
			iw = ReadShort();
			ih = ReadShort();

			int packed = Read();
			lctFlag = (packed & 0x80) != 0; // 1 - local color table flag
			interlace = (packed & 0x40) != 0; // 2 - interlace flag
			// 3 - sort flag
			// 4-5 - reserved
			lctSize = 2 << (packed & 7); // 6-8 - local color table size

			if (lctFlag) 
			{
				lct = ReadColorTable(lctSize); // read table
				act = lct; // make local table active
			} 
			else 
			{
				act = gct; // make global table active
				if (bgIndex == transIndex)
					bgColor = 0;
			}
			int save = 0;
			if (transparency) 
			{
				save = act[transIndex];
				act[transIndex] = 0; // set transparent color if specified
			}

			if (act == null) 
			{
				status = StatusFormatError; // no color table defined
			}

			if (Error()) return;

			DecodeImageData(); // decode pixel data
			Skip();

			if (Error()) return;

			frameCount++;

			// create new image to receive frame data
			//		image =
			//			new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB_PRE);

			bitmap = new Bitmap( width, height );
			image = bitmap;
			SetPixels(); // transfer pixel data to image

			frames.Add(new GifFrame(bitmap, delay)); // add image to frame list

			if (transparency) 
			{
				act[transIndex] = save;
			}
			ResetFrame();

		}

		/**
		 * Reads Logical Screen Descriptor
		 */
		private void ReadLSD() 
		{

			// logical screen size
			width = ReadShort();
			height = ReadShort();

			// packed fields
			int packed = Read();
			gctFlag = (packed & 0x80) != 0; // 1   : global color table flag
			// 2-4 : color resolution
			// 5   : gct sort flag
			gctSize = 2 << (packed & 7); // 6-8 : gct size

			bgIndex = Read(); // background color index
			pixelAspect = Read(); // pixel aspect ratio
		}

		/**
		 * Reads Netscape extenstion to obtain iteration count
		 */
		private void ReadNetscapeExt() 
		{
			do 
			{
				ReadBlock();
				if (block[0] == 1) 
				{
					// loop count sub-block
					int b1 = ((int) block[1]) & 0xff;
					int b2 = ((int) block[2]) & 0xff;
					loopCount = (b2 << 8) | b1;
				}
			} while ((blockSize > 0) && !Error());
		}

		/**
		 * Reads next 16-bit value, LSB first
		 */
		private int ReadShort() 
		{
			// read 16-bit value, LSB first
			return Read() | (Read() << 8);
		}

		/**
		 * Resets frame state for reading next image.
		 */
		private void ResetFrame() 
		{
			lastDispose = dispose;
			lastRect = new Rectangle(ix, iy, iw, ih);
			lastImage = image;
			lastBgColor = bgColor;
			//		int dispose = 0;
			lct = null;
		}

		/**
		 * Skips variable length blocks up to and including
		 * next zero length block.
		 */
		private void Skip() 
		{
			do 
			{
				ReadBlock();
			} while ((blockSize > 0) && !Error());
		}
	}
}

```

`Aga.Controls/NumericTextBox.cs`:

```cs
using System;
using System.ComponentModel;
using System.Windows.Forms;
using System.Globalization;


namespace Aga.Controls
{
	/// <summary>
	/// Restricts the entry of characters to digits, the negative sign,
	/// the decimal point, and editing keystrokes (backspace).
	/// It does not handle the AltGr key so any keys that can be created in any
	/// combination with AltGr these are not filtered
	/// </summary>
	public class NumericTextBox : TextBox
	{
		private const int WM_PASTE = 0x302;
		private NumberStyles numberStyle = NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign;

		/// <summary>
		/// Restricts the entry of characters to digits, the negative sign,
		/// the decimal point, and editing keystrokes (backspace).
		/// It does not handle the AltGr key
		/// </summary>
		/// <param name="e"></param>
		protected override void OnKeyPress(KeyPressEventArgs e)
		{
			base.OnKeyPress(e);

			e.Handled = invalidNumeric(e.KeyChar);
		}


		/// <summary>
		/// Main method for verifying allowed keypresses.
		/// This does not catch cut paste copy ... operations.
		/// </summary>
		/// <param name="key"></param>
		/// <returns></returns>
		private bool invalidNumeric(char key)
		{
			bool handled = false;

			NumberFormatInfo numberFormatInfo = CultureInfo.CurrentCulture.NumberFormat;
			string decimalSeparator = numberFormatInfo.NumberDecimalSeparator;
			string negativeSign = numberFormatInfo.NegativeSign;

			string keyString = key.ToString();

			if (Char.IsDigit(key))
			{
				// Digits are OK
			}
			else if (AllowDecimalSeparator && keyString.Equals(decimalSeparator))
			{
				if (Text.IndexOf(decimalSeparator) >= 0)
				{
					handled = true;
				}
			}
			else if (AllowNegativeSign && keyString.Equals(negativeSign))
			{
				if (Text.IndexOf(negativeSign) >= 0)
				{
					handled = true;
				}
			}
			else if (key == '\b')
			{
				// Backspace key is OK
			}
			else if ((ModifierKeys & (Keys.Control)) != 0)
			{
				// Let the edit control handle control and alt key combinations
			}
			else
			{
				// Swallow this invalid key and beep
				handled = true;
			}
			return handled;
		}


		/// <summary>
		/// Method invoked when Windows sends a message.
		/// </summary>
		/// <param name="m">Message from Windows.</param>
		/// <remarks>
		/// This is over-ridden so that the user can not use
		/// cut or paste operations to bypass the TextChanging event.
		/// This catches ContextMenu Paste, Shift+Insert, Ctrl+V,
		/// While it is generally frowned upon to override WndProc, no
		/// other simple mechanism was apparent to simultaneously and
		/// transparently intercept so many different operations.
		/// </remarks>
		protected override void WndProc(ref Message m)
		{
			// Switch to handle message...
			switch (m.Msg)
			{
				case WM_PASTE:
					{
						// Get clipboard object to paste
						IDataObject clipboardData = Clipboard.GetDataObject();

						// Get text from clipboard data
						string pasteText = (string)clipboardData.GetData(
								DataFormats.UnicodeText);

						// Get the number of characters to replace
						int selectionLength = SelectionLength;

						// If no replacement or insertion, we are done
						if (pasteText.Length == 0)
						{
							break;
						}
						else if (selectionLength != 0)
						{
							base.Text = base.Text.Remove(SelectionStart, selectionLength);
						}

						bool containsInvalidChars = false;
						foreach (char c in pasteText)
						{
							if (containsInvalidChars)
							{
								break;
							}
							else if (invalidNumeric(c))
							{
								containsInvalidChars = true;
							}
						}

						if (!containsInvalidChars)
						{
							base.Text = base.Text.Insert(SelectionStart, pasteText);
						}

						return;
					}

			}
			base.WndProc(ref m);
		}


		public int IntValue
		{
			get
			{
				int intValue;
				Int32.TryParse(this.Text, numberStyle, CultureInfo.CurrentCulture.NumberFormat, out intValue);
				return intValue;
			}
		}

		public decimal DecimalValue
		{
			get
			{
				decimal decimalValue;
				Decimal.TryParse(this.Text, numberStyle, CultureInfo.CurrentCulture.NumberFormat, out decimalValue);
				return decimalValue;
			}
		}


		private bool allowNegativeSign;
		[DefaultValue(true)]
		public bool AllowNegativeSign
		{
			get { return allowNegativeSign; }
			set { allowNegativeSign = value; }
		}

		private bool allowDecimalSeparator;
		[DefaultValue(true)]
		public bool AllowDecimalSeparator
		{
			get { return allowDecimalSeparator; }
			set { allowDecimalSeparator = value; }
		}

	}

}

```

`Aga.Controls/PerformanceAnalyzer.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Diagnostics;

namespace Aga.Controls
{
	/// <summary>
	/// Is used to analyze code performance
	/// </summary>
	public static class PerformanceAnalyzer
	{
		public class PerformanceInfo
		{
			private string _name;
			public string Name
			{
				get { return _name; }
			}

			private int _count = 0;
			public int Count
			{
				get { return _count; }
				set { _count = value; }
			}

			private double _totalTime = 0;
			public double TotalTime
			{
				get { return _totalTime; }
				set { _totalTime = value; }
			}

			private Int64 _start;
			public Int64 Start
			{
				get { return _start; }
				set { _start = value; }
			}

			public PerformanceInfo(string name)
			{
				_name = name;
			}
		}

		private static Dictionary<string, PerformanceInfo> _performances = new Dictionary<string, PerformanceInfo>();

		public static IEnumerable<PerformanceInfo> Performances
		{
			get
			{
				return _performances.Values;
			}
		}

		[Conditional("DEBUG")]
		public static void Start(string pieceOfCode)
		{
			PerformanceInfo info = null;
			lock(_performances)
			{
				if (_performances.ContainsKey(pieceOfCode))
					info = _performances[pieceOfCode];
				else
				{
					info = new PerformanceInfo(pieceOfCode);
					_performances.Add(pieceOfCode, info);
				}

				info.Count++;
				info.Start = TimeCounter.GetStartValue();
			}
		}

		[Conditional("DEBUG")]
		public static void Finish(string pieceOfCode)
		{
			lock (_performances)
			{
				if (_performances.ContainsKey(pieceOfCode))
				{
					PerformanceInfo info = _performances[pieceOfCode];
					info.Count++;
					info.TotalTime += TimeCounter.Finish(info.Start);
				}
			}
		}

		public static void Reset()
		{
			_performances.Clear();
		}

		public static string GenerateReport()
		{
			return GenerateReport(0);
		}

		public static string GenerateReport(string mainPieceOfCode)
		{
			if (_performances.ContainsKey(mainPieceOfCode))
				return GenerateReport(_performances[mainPieceOfCode].TotalTime);
			else
				return GenerateReport(0);
		}

		public static string GenerateReport(double totalTime)
		{
			StringBuilder sb = new StringBuilder();
			int len = 0;
			foreach (PerformanceInfo info in Performances)
				len = Math.Max(info.Name.Length, len);

			sb.AppendLine("Name".PadRight(len) + " Count              Total Time, ms    Avg. Time, ms       Percentage, %");
			sb.AppendLine("----------------------------------------------------------------------------------------------");
			foreach (PerformanceInfo info in Performances)
			{
				sb.Append(info.Name.PadRight(len));
				double p = 0;
				double avgt = 0;
				if (totalTime != 0)
					p = info.TotalTime / totalTime;
				if (info.Count > 0)
					avgt = info.TotalTime * 1000 / info.Count;
				string c = info.Count.ToString("0,0").PadRight(20);
				string tt = (info.TotalTime * 1000).ToString("0,0.00").PadRight(20);
				string t = avgt.ToString("0.0000").PadRight(20);
				string sp = (p * 100).ToString("###").PadRight(20);
				sb.AppendFormat(" " + c + tt + t + sp + "\n");
			}
			return sb.ToString();
		}
	}
}

```

`Aga.Controls/Properties/Resources.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.235
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Aga.Controls.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Aga.Controls.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        internal static System.Drawing.Bitmap check {
            get {
                object obj = ResourceManager.GetObject("check", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        internal static byte[] DVSplit {
            get {
                object obj = ResourceManager.GetObject("DVSplit", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        internal static System.Drawing.Bitmap Folder {
            get {
                object obj = ResourceManager.GetObject("Folder", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        internal static System.Drawing.Bitmap FolderClosed {
            get {
                object obj = ResourceManager.GetObject("FolderClosed", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        internal static System.Drawing.Bitmap Leaf {
            get {
                object obj = ResourceManager.GetObject("Leaf", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        internal static byte[] loading_icon {
            get {
                object obj = ResourceManager.GetObject("loading_icon", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        internal static System.Drawing.Bitmap minus {
            get {
                object obj = ResourceManager.GetObject("minus", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        internal static System.Drawing.Bitmap plus {
            get {
                object obj = ResourceManager.GetObject("plus", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        internal static System.Drawing.Bitmap uncheck {
            get {
                object obj = ResourceManager.GetObject("uncheck", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        internal static System.Drawing.Bitmap unknown {
            get {
                object obj = ResourceManager.GetObject("unknown", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
    }
}

```

`Aga.Controls/Properties/Resources.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="check" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\check.bmp;System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="DVSplit" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\DVSplit.cur;System.Byte[], mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="Folder" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Folder.bmp;System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="FolderClosed" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\FolderClosed.bmp;System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="Leaf" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Leaf.bmp;System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="loading_icon" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\loading_icon;System.Byte[], mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="minus" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\minus.bmp;System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="plus" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\plus.bmp;System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="uncheck" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\uncheck.bmp;System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="unknown" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\unknown.bmp;System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
</root>
```

`Aga.Controls/ResourceHelper.cs`:

```cs
using System;
using System.IO;
using System.Reflection;
using System.Windows.Forms;
using System.Collections.Generic;
using System.Text;

namespace Aga.Controls
{
    public static class ResourceHelper
    {
        // VSpilt Cursor with Innerline (symbolisize hidden column)
        private static Cursor _dVSplitCursor = GetCursor(Properties.Resources.DVSplit);
        public static Cursor DVSplitCursor
        {
            get { return _dVSplitCursor; }
        }

		private static GifDecoder _loadingIcon = GetGifDecoder(Properties.Resources.loading_icon);
		public static GifDecoder LoadingIcon
		{
			get { return _loadingIcon; }
		}

        /// <summary>
        /// Help function to convert byte[] from resource into Cursor Type 
        /// </summary>
        /// <param name="data"></param>
        /// <returns></returns>
        private static Cursor GetCursor(byte[] data)
        {
            using (MemoryStream s = new MemoryStream(data))
                return new Cursor(s);
        }

		/// <summary>
		/// Help function to convert byte[] from resource into GifDecoder Type 
		/// </summary>
		/// <param name="data"></param>
		/// <returns></returns>
		private static GifDecoder GetGifDecoder(byte[] data)
		{
			using(MemoryStream ms = new MemoryStream(data))
				return new GifDecoder(ms, true);
		}

    }
}

```

`Aga.Controls/StringCollectionEditor.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.ComponentModel.Design;

namespace Aga.Controls
{
	public class StringCollectionEditor : CollectionEditor
	{
		public StringCollectionEditor(Type type): base(type)
		{
		}

		protected override Type CreateCollectionItemType()
		{
			return typeof(string);
		}

		protected override object CreateInstance(Type itemType)
		{
			return "";
		}
	}
}

```

`Aga.Controls/TextHelper.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;
using System.Drawing;

namespace Aga.Controls
{
	public static class TextHelper
	{
		public static StringAlignment TranslateAligment(HorizontalAlignment alignment)
		{
			if (alignment == HorizontalAlignment.Left)
				return StringAlignment.Near;
			else if (alignment == HorizontalAlignment.Right)
				return StringAlignment.Far;
			else
				return StringAlignment.Center;
		}

        public static TextFormatFlags TranslateAligmentToFlag(HorizontalAlignment alignment)
        {
            if (alignment == HorizontalAlignment.Left)
                return TextFormatFlags.Left;
            else if (alignment == HorizontalAlignment.Right)
                return TextFormatFlags.Right;
            else
                return TextFormatFlags.HorizontalCenter;
        }

		public static TextFormatFlags TranslateTrimmingToFlag(StringTrimming trimming)
		{
			if (trimming == StringTrimming.EllipsisCharacter)
				return TextFormatFlags.EndEllipsis;
			else if (trimming == StringTrimming.EllipsisPath)
				return TextFormatFlags.PathEllipsis;
			if (trimming == StringTrimming.EllipsisWord)
				return TextFormatFlags.WordEllipsis;
			if (trimming == StringTrimming.Word)
				return TextFormatFlags.WordBreak;
			else
				return TextFormatFlags.Default;
		}
	}
}

```

`Aga.Controls/Threading/AbortableThreadPool.cs`:

```cs
// Stephen Toub
// stoub@microsoft.com

using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;

namespace Aga.Controls.Threading
{
	public class AbortableThreadPool
	{
		private LinkedList<WorkItem> _callbacks = new LinkedList<WorkItem>();
		private Dictionary<WorkItem, Thread> _threads = new Dictionary<WorkItem, Thread>();

		public WorkItem QueueUserWorkItem(WaitCallback callback)
		{
			return QueueUserWorkItem(callback, null);
		}

		public WorkItem QueueUserWorkItem(WaitCallback callback, object state)
		{
			if (callback == null) throw new ArgumentNullException("callback");

			WorkItem item = new WorkItem(callback, state, ExecutionContext.Capture());
			lock (_callbacks)
			{
				_callbacks.AddLast(item);
			}
			ThreadPool.QueueUserWorkItem(new WaitCallback(HandleItem));
			return item;
		}

		private void HandleItem(object ignored)
		{
			WorkItem item = null;
			try
			{
				lock (_callbacks)
				{
					if (_callbacks.Count > 0)
					{
						item = _callbacks.First.Value;
						_callbacks.RemoveFirst();
					}
					if (item == null)
						return;
					_threads.Add(item, Thread.CurrentThread);

				}
				ExecutionContext.Run(item.Context,
					delegate { item.Callback(item.State); }, null);
			}
			finally
			{
				lock (_callbacks)
				{
					if (item != null)
						_threads.Remove(item);
				}
			}
		}

		public bool IsMyThread(Thread thread)
		{
			lock (_callbacks)
			{
				foreach (Thread t in _threads.Values)
				{
					if (t == thread)
						return true;
				}
				return false;
			}
		}

		public WorkItemStatus Cancel(WorkItem item, bool allowAbort)
		{
			if (item == null)
				throw new ArgumentNullException("item");
			lock (_callbacks)
			{
				LinkedListNode<WorkItem> node = _callbacks.Find(item);
				if (node != null)
				{
					_callbacks.Remove(node);
					return WorkItemStatus.Queued;
				}
				else if (_threads.ContainsKey(item))
				{
					if (allowAbort)
					{
						_threads[item].Abort();
						_threads.Remove(item);
						return WorkItemStatus.Aborted;
					}
					else
						return WorkItemStatus.Executing;
				}
				else
					return WorkItemStatus.Completed;
			}
		}

		public void CancelAll(bool allowAbort)
		{
			lock (_callbacks)
			{
				_callbacks.Clear();
				if (allowAbort)
				{
					foreach (Thread t in _threads.Values)
						t.Abort();
				}
			}
		}
	}
}

```

`Aga.Controls/Threading/WorkItem.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;

namespace Aga.Controls.Threading
{
	public sealed class WorkItem
	{
		private WaitCallback _callback;
		private object _state;
		private ExecutionContext _ctx;

		internal WorkItem(WaitCallback wc, object state, ExecutionContext ctx)
		{
			_callback = wc; 
			_state = state; 
			_ctx = ctx;
		}

		internal WaitCallback Callback
		{
			get
			{
				return _callback;
			}
		}

		internal object State
		{
			get
			{
				return _state;
			}
		}

		internal ExecutionContext Context
		{
			get
			{
				return _ctx;
			}
		}
	}
}

```

`Aga.Controls/Threading/WorkItemStatus.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace Aga.Controls.Threading
{
	public enum WorkItemStatus 
	{ 
		Completed, 
		Queued, 
		Executing, 
		Aborted 
	}
}

```

`Aga.Controls/TimeCounter.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Runtime.InteropServices;
using System.Diagnostics.CodeAnalysis;

namespace Aga.Controls
{
	/// <summary>
	/// High resolution timer, used to test performance
	/// </summary>
	public static class TimeCounter
	{
		private static Int64 _start;

		/// <summary>
		/// Start time counting
		/// </summary>
		public static void Start()
		{
			_start = 0;
			QueryPerformanceCounter(ref _start);
		}

		public static Int64 GetStartValue()
		{
			Int64 t = 0;
			QueryPerformanceCounter(ref t);
			return t;
		}

		/// <summary>
		/// Finish time counting
		/// </summary>
		/// <returns>time in seconds elapsed from Start till Finish	</returns>
		public static double Finish()
		{
			return Finish(_start);
		}

		public static double Finish(Int64 start)
		{
			Int64 finish = 0;
			QueryPerformanceCounter(ref finish);

			Int64 freq = 0;
			QueryPerformanceFrequency(ref freq);
			return (finish - start) / (double)freq;
		}

		[DllImport("Kernel32.dll")]
		[return: MarshalAs(UnmanagedType.Bool)]
		static extern bool QueryPerformanceCounter(ref Int64 performanceCount);

		[DllImport("Kernel32.dll")]
		[return: MarshalAs(UnmanagedType.Bool)]
		static extern bool QueryPerformanceFrequency(ref Int64 frequency);
	}
}

```

`Aga.Controls/Tree/AutoRowHeightLayout.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using Aga.Controls.Tree.NodeControls;

namespace Aga.Controls.Tree
{
	public class AutoRowHeightLayout: IRowLayout
	{
		private DrawContext _measureContext;
		private TreeViewAdv _treeView;
		private List<Rectangle> _rowCache;

		public AutoRowHeightLayout(TreeViewAdv treeView, int rowHeight)
		{
			_rowCache = new List<Rectangle>();
			_treeView = treeView;
			PreferredRowHeight = rowHeight;
			_measureContext = new DrawContext();
			_measureContext.Graphics = Graphics.FromImage(new Bitmap(1, 1));
		}

		private int _rowHeight;
		public int PreferredRowHeight
		{
			get { return _rowHeight; }
			set { _rowHeight = value; }
		}


		public int PageRowCount
		{
			get 
			{
				if (_treeView.RowCount == 0)
					return 0;
				else
				{
					int pageHeight = _treeView.DisplayRectangle.Height - _treeView.ColumnHeaderHeight;
					int y = 0;
					for (int i = _treeView.RowCount - 1; i >= 0; i--)
					{
						y += GetRowHeight(i);
						if (y > pageHeight)
							return Math.Max(0, _treeView.RowCount - 1 - i);
					}
					return _treeView.RowCount;
				}
			}
		}

		public int CurrentPageSize
		{
			get
			{
				if (_treeView.RowCount == 0)
					return 0;
				else
				{
					int pageHeight = _treeView.DisplayRectangle.Height - _treeView.ColumnHeaderHeight;
					int y = 0;
					for (int i = _treeView.FirstVisibleRow; i < _treeView.RowCount; i++)
					{
						y += GetRowHeight(i);
						if (y > pageHeight)
							return Math.Max(0, i - _treeView.FirstVisibleRow);
					}
					return Math.Max(0, _treeView.RowCount - _treeView.FirstVisibleRow);
				}
			}
		}

		public Rectangle GetRowBounds(int rowNo)
		{
			if (rowNo >= _rowCache.Count)
			{
				int count = _rowCache.Count;
				int y = count > 0 ? _rowCache[count - 1].Bottom : 0;
				for (int i = count; i <= rowNo; i++)
				{
					int height = GetRowHeight(i);
					_rowCache.Add(new Rectangle(0, y, 0, height));
					y += height;
				}
				if (rowNo < _rowCache.Count - 1)
					return Rectangle.Empty;
			}
			if (rowNo >= 0 && rowNo < _rowCache.Count)
				return _rowCache[rowNo];
			else
				return Rectangle.Empty;
		}

		private int GetRowHeight(int rowNo)
		{
			if (rowNo < _treeView.RowMap.Count)
			{
				TreeNodeAdv node = _treeView.RowMap[rowNo];
				if (node.Height == null)
				{
					int res = 0;
					_measureContext.Font = _treeView.Font;
					foreach (NodeControl nc in _treeView.NodeControls)
					{
						int h = nc.GetActualSize(node, _measureContext).Height;
						if (h > res)
							res = h;
					}
					node.Height = res;
				}
				return node.Height.Value;
			}
			else
				return 0;
		}

		public int GetRowAt(Point point)
		{
			int py = point.Y - _treeView.ColumnHeaderHeight;
			int y = 0;
			for (int i = _treeView.FirstVisibleRow; i < _treeView.RowCount; i++)
			{
				int h = GetRowHeight(i);
				if (py >= y && py < y + h)
					return i;
				else
					y += h;
			}
			return -1;
		}

		public int GetFirstRow(int lastPageRow)
		{
			int pageHeight = _treeView.DisplayRectangle.Height - _treeView.ColumnHeaderHeight;
			int y = 0;
			for (int i = lastPageRow; i >= 0; i--)
			{
				y += GetRowHeight(i);
				if (y > pageHeight)
					return Math.Max(0, i + 1);
			}
			return 0;
		}

		public void ClearCache()
		{
			_rowCache.Clear();
		}
	}
}

```

`Aga.Controls/Tree/ClassDiagram.cd`:

```cd
<?xml version="1.0" encoding="utf-8"?>
<ClassDiagram MajorVersion="1" MinorVersion="1" MembersFormat="FullSignature">
  <Font Name="Microsoft Sans Serif" Size="8.25" />
  <Class Name="Aga.Controls.Tree.TreeModel" BaseTypeListCollapsed="true">
    <Position X="0.5" Y="7" Width="3.75" />
    <TypeIdentifier>
      <FileName>Tree\TreeModel.cs</FileName>
      <HashCode>AAAkgAAAAAAQAGQAAAAAEAAAEAACQAAAUAAAAAAAAQE=</HashCode>
    </TypeIdentifier>
    <Members>
      <Field Name="_root" Hidden="true" />
    </Members>
    <Compartments>
      <Compartment Name="Fields" Collapsed="true" />
    </Compartments>
    <Lollipop Position="0.2" />
  </Class>
  <Class Name="Aga.Controls.Tree.TreePath">
    <Position X="4.5" Y="4.25" Width="2" />
    <TypeIdentifier>
      <FileName>Tree\TreePath.cs</FileName>
      <HashCode>GABAAAAAAAACAAAAAAIAAAAAAAAACAAAAAAAAAAAAAA=</HashCode>
    </TypeIdentifier>
    <Members>
      <Field Name="_path" Hidden="true" />
      <Field Name="Empty" Hidden="true" />
      <Method Name="TreePath" Hidden="true" />
    </Members>
    <Compartments>
      <Compartment Name="Fields" Collapsed="true" />
    </Compartments>
  </Class>
  <Class Name="Aga.Controls.Tree.Node">
    <Position X="4.75" Y="7" Width="2.5" />
    <TypeIdentifier>
      <FileName>Tree\Node.cs</FileName>
      <HashCode>AAAgABAAgCAAAAAAAgAEVAAQAAAQAAAIAAsgCAAAAAA=</HashCode>
    </TypeIdentifier>
    <Members>
      <Field Name="_checkState" Hidden="true" />
      <Field Name="_model" Hidden="true" />
      <Field Name="_nodes" Hidden="true" />
      <Field Name="_parent" Hidden="true" />
      <Field Name="_text" Hidden="true" />
    </Members>
    <Compartments>
      <Compartment Name="Fields" Collapsed="true" />
    </Compartments>
    <NestedTypes>
      <Class Name="Aga.Controls.Tree.Node.NodeCollection" Collapsed="true">
        <TypeIdentifier>
          <NewMemberFileName>Tree\Node.cs</NewMemberFileName>
        </TypeIdentifier>
      </Class>
    </NestedTypes>
  </Class>
  <Class Name="Aga.Controls.Tree.NodeControls.NodeControl">
    <Position X="0.5" Y="0.5" Width="3.75" />
    <TypeIdentifier>
      <FileName>Tree\NodeControls\NodeControl.cs</FileName>
      <HashCode>AAAAAAAAgAAAgsIAAAhAQAAwAAAAEAAAAEAIAAAAAAA=</HashCode>
    </TypeIdentifier>
    <Members>
      <Field Name="_column" Hidden="true" />
      <Field Name="_parent" Hidden="true" />
      <Field Name="_toolTipProvider" Hidden="true" />
      <Method Name="AssignParent" Hidden="true" />
    </Members>
  </Class>
  <Interface Name="Aga.Controls.Tree.ITreeModel">
    <Position X="0.5" Y="4.25" Width="3.5" />
    <TypeIdentifier>
      <FileName>Tree\ITreeModel.cs</FileName>
      <HashCode>AAAEAAAAAAAAAEQAAAAAEAAAEAAAQAAAAAAAAAAAAAA=</HashCode>
    </TypeIdentifier>
  </Interface>
  <Interface Name="Aga.Controls.Tree.IToolTipProvider">
    <Position X="4.5" Y="0.5" Width="2.75" />
    <TypeIdentifier>
      <FileName>Tree\IToolTipProvider.cs</FileName>
      <HashCode>AAAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAA=</HashCode>
    </TypeIdentifier>
  </Interface>
</ClassDiagram>
```

`Aga.Controls/Tree/ColumnCollection.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Collections.ObjectModel;

namespace Aga.Controls.Tree
{
	/*internal class ColumnCollection: Collection<Column>
	{
		public int TotalWidth
		{
			get
			{
				int res = 0;
				foreach (Column c in Items)
					res += c.Width;
				return res;
			}
		}
	}*/
}

```

`Aga.Controls/Tree/DrawContext.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using Aga.Controls.Tree.NodeControls;

namespace Aga.Controls.Tree
{
	public struct DrawContext
	{
		private Graphics _graphics;
		public Graphics Graphics
		{
			get { return _graphics; }
			set { _graphics = value; }
		}

		private Rectangle _bounds;
		public Rectangle Bounds
		{
			get { return _bounds; }
			set { _bounds = value; }
		}

		private Font _font;
		public Font Font
		{
			get { return _font; }
			set { _font = value; }
		}

		private DrawSelectionMode _drawSelection;
		public DrawSelectionMode DrawSelection
		{
			get { return _drawSelection; }
			set { _drawSelection = value; }
		}

		private bool _drawFocus;
		public bool DrawFocus
		{
			get { return _drawFocus; }
			set { _drawFocus = value; }
		}

		private NodeControl _currentEditorOwner;
		public NodeControl CurrentEditorOwner
		{
			get { return _currentEditorOwner; }
			set { _currentEditorOwner = value; }
		}

		private bool _enabled;
		public bool Enabled
		{
			get { return _enabled; }
			set { _enabled = value; }
		}
	}
}

```

`Aga.Controls/Tree/DropNodeValidatingEventArgs.cs`:

```cs
using System;
using System.Drawing;

namespace Aga.Controls.Tree
{
	public class DropNodeValidatingEventArgs: EventArgs
	{
		Point _point;
		TreeNodeAdv _node;

		public DropNodeValidatingEventArgs(Point point, TreeNodeAdv node)
		{
			_point = point;
			_node = node;
		}

		public Point Point
		{
			get { return _point; }
		}

		public TreeNodeAdv Node
		{
			get { return _node; }
			set { _node = value; }
		}
	}
}

```

`Aga.Controls/Tree/DropPosition.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace Aga.Controls.Tree
{
	public struct DropPosition
	{
		private TreeNodeAdv _node;
		public TreeNodeAdv Node
		{
			get { return _node; }
			set { _node = value; }
		}

		private NodePosition _position;
		public NodePosition Position
		{
			get { return _position; }
			set { _position = value; }
		}
	}
}

```

`Aga.Controls/Tree/EditorContext.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;
using System.Drawing;
using Aga.Controls.Tree.NodeControls;

namespace Aga.Controls.Tree
{
	public struct EditorContext
	{
		private TreeNodeAdv _currentNode;
		public TreeNodeAdv CurrentNode
		{
			get { return _currentNode; }
			set { _currentNode = value; }
		}

		private Control _editor;
		public Control Editor
		{
			get { return _editor; }
			set { _editor = value; }
		}

		private NodeControl _owner;
		public NodeControl Owner
		{
			get { return _owner; }
			set { _owner = value; }
		}

		private Rectangle _bounds;
		public Rectangle Bounds
		{
			get { return _bounds; }
			set { _bounds = value; }
		}

		private DrawContext _drawContext;
		public DrawContext DrawContext
		{
			get { return _drawContext; }
			set { _drawContext = value; }
		}
	}
}

```

`Aga.Controls/Tree/Enums.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace Aga.Controls.Tree
{
	public enum DrawSelectionMode
	{
		None, Active, Inactive, FullRowSelect
	}

	public enum TreeSelectionMode
	{
		Single, Multi, MultiSameParent
	}

	public enum NodePosition
	{
		Inside, Before, After
	}

	public enum VerticalAlignment
	{
		Top, Bottom, Center
	}

	public enum IncrementalSearchMode
	{
		None, Standard, Continuous
	}

	[Flags]
    public enum GridLineStyle
    {
		None = 0, 
		Horizontal = 1, 
		Vertical = 2, 
		HorizontalAndVertical = 3
    }

	public enum ImageScaleMode
	{
		/// <summary>
		/// Don't scale
		/// </summary>
		Clip,
		/// <summary>
		/// Scales image to fit the display rectangle, aspect ratio is not fixed.
		/// </summary>
		Fit,
		/// <summary>
		/// Scales image down if it is larger than display rectangle, taking aspect ratio into account
		/// </summary>
		ScaleDown,
		/// <summary>
		/// Scales image up if it is smaller than display rectangle, taking aspect ratio into account
		/// </summary>
		ScaleUp,
		/// <summary>
		/// Scales image to match the display rectangle, taking aspect ratio into account
		/// </summary>
		AlwaysScale,

	}
}

```

`Aga.Controls/Tree/FixedRowHeightLayout.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;

namespace Aga.Controls.Tree
{
	internal class FixedRowHeightLayout : IRowLayout
	{
		private TreeViewAdv _treeView;

		public FixedRowHeightLayout(TreeViewAdv treeView, int rowHeight)
		{
			_treeView = treeView;
			PreferredRowHeight = rowHeight;
		}

		private int _rowHeight;
		public int PreferredRowHeight
		{
			get { return _rowHeight; }
			set { _rowHeight = value; }
		}

		public Rectangle GetRowBounds(int rowNo)
		{
			return new Rectangle(0, rowNo * _rowHeight, 0, _rowHeight);
		}

		public int PageRowCount
		{
			get
			{
				return Math.Max((_treeView.DisplayRectangle.Height - _treeView.ColumnHeaderHeight) / _rowHeight, 0);
			}
		}

		public int CurrentPageSize
		{
			get
			{
				return PageRowCount;
			}
		}

		public int GetRowAt(Point point)
		{
			point = new Point(point.X, point.Y + (_treeView.FirstVisibleRow * _rowHeight) - _treeView.ColumnHeaderHeight);
			return point.Y / _rowHeight;
		}

		public int GetFirstRow(int lastPageRow)
		{
			return Math.Max(0, lastPageRow - PageRowCount + 1);
		}

		public void ClearCache()
		{
		}
	}
}

```

`Aga.Controls/Tree/IRowLayout.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;

namespace Aga.Controls.Tree
{
	internal interface IRowLayout
	{
		int PreferredRowHeight
		{
			get;
			set;
		}

		int PageRowCount
		{
			get;
		}

		int CurrentPageSize
		{
			get;
		}

		Rectangle GetRowBounds(int rowNo);

		int GetRowAt(Point point);

		int GetFirstRow(int lastPageRow);

		void ClearCache();
	}
}

```

`Aga.Controls/Tree/IToolTipProvider.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using Aga.Controls.Tree.NodeControls;

namespace Aga.Controls.Tree
{
	public interface IToolTipProvider
	{
		string GetToolTip(TreeNodeAdv node, NodeControl nodeControl);
	}
}

```

`Aga.Controls/Tree/ITreeModel.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Collections;

namespace Aga.Controls.Tree
{
	public interface ITreeModel
	{
		IEnumerable GetChildren(TreePath treePath);
		bool IsLeaf(TreePath treePath);

		event EventHandler<TreeModelEventArgs> NodesChanged; 
		event EventHandler<TreeModelEventArgs> NodesInserted;
		event EventHandler<TreeModelEventArgs> NodesRemoved; 
		event EventHandler<TreePathEventArgs> StructureChanged;
	}
}

```

`Aga.Controls/Tree/IncrementalSearch.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using Aga.Controls.Tree.NodeControls;
using System.ComponentModel;
using System.Drawing;
using System.Windows.Forms;

namespace Aga.Controls.Tree
{
	internal class IncrementalSearch
	{
		private const int SearchTimeout = 300; //end of incremental search timeot in msec

		private TreeViewAdv _tree;
		private TreeNodeAdv _currentNode;
		private string _searchString = "";
		private DateTime _lastKeyPressed = DateTime.Now;

		public IncrementalSearch(TreeViewAdv tree)
		{
			_tree = tree;
		}

		public void Search(Char value)
		{
			if (!Char.IsControl(value))
			{
				Char ch = Char.ToLowerInvariant(value);
				DateTime dt = DateTime.Now;
				TimeSpan ts = dt - _lastKeyPressed;
				_lastKeyPressed = dt;
				if (ts.TotalMilliseconds < SearchTimeout)
				{
					if (_searchString == value.ToString())
						FirstCharSearch(ch);
					else
						ContinuousSearch(ch);
				}
				else
				{
					FirstCharSearch(ch);
				}
			}
		}

		private void ContinuousSearch(Char value)
		{
			if (value == ' ' && String.IsNullOrEmpty(_searchString))
				return; //Ingnore leading space

			_searchString += value;
			DoContinuousSearch();
		}

		private void FirstCharSearch(Char value)
		{
			if (value == ' ')
				return;

			_searchString = value.ToString();
			TreeNodeAdv node = null;
			if (_tree.SelectedNode != null)
				node = _tree.SelectedNode.NextVisibleNode;
			if (node == null)
				node = _tree.Root.NextVisibleNode;

			if (node != null)
				foreach (string label in IterateNodeLabels(node))
				{
					if (label.StartsWith(_searchString))
					{
						_tree.SelectedNode = _currentNode;
						return;
					}
				}
		}

		public virtual void EndSearch()
		{
			_currentNode = null;
			_searchString = "";
		}

		protected IEnumerable<string> IterateNodeLabels(TreeNodeAdv start)
		{
			_currentNode = start;
			while(_currentNode != null)
			{
				foreach (string label in GetNodeLabels(_currentNode))
					yield return label;

				_currentNode = _currentNode.NextVisibleNode;
				if (_currentNode == null)
					_currentNode = _tree.Root;

				if (start == _currentNode)
					break;
			} 
		}

		private IEnumerable<string> GetNodeLabels(TreeNodeAdv node)
		{
			foreach (NodeControl nc in _tree.NodeControls)
			{
				BindableControl bc = nc as BindableControl;
				if (bc != null && bc.IncrementalSearchEnabled)
				{
					object obj = bc.GetValue(node);
					if (obj != null)
						yield return obj.ToString().ToLowerInvariant();
				}
			}
		}

		private bool DoContinuousSearch()
		{
			bool found = false;
			if (!String.IsNullOrEmpty(_searchString))
			{
				TreeNodeAdv node = null;
				if (_tree.SelectedNode != null)
					node = _tree.SelectedNode;
				if (node == null)
					node = _tree.Root.NextVisibleNode;

				if (!String.IsNullOrEmpty(_searchString))
				{
					foreach (string label in IterateNodeLabels(node))
					{
						if (label.StartsWith(_searchString))
						{
							found = true;
							_tree.SelectedNode = _currentNode;
							break;
						}
					}
				}
			}
			return found;
		}

	}
}

```

`Aga.Controls/Tree/Input/ClickColumnState.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;
using System.Drawing;

namespace Aga.Controls.Tree
{
	internal class ClickColumnState : ColumnState
	{
		private Point _location;

		public ClickColumnState(TreeViewAdv tree, TreeColumn column, Point location)
			: base(tree, column)
		{
			_location = location;
		}

		public override void KeyDown(KeyEventArgs args)
		{
		}

		public override void MouseDown(TreeNodeAdvMouseEventArgs args)
		{
		}

		public override bool MouseMove(MouseEventArgs args)
		{
			if (TreeViewAdv.Dist(_location, args.Location) > TreeViewAdv.ItemDragSensivity
				&& Tree.AllowColumnReorder)
			{
				Tree.Input = new ReorderColumnState(Tree, Column, args.Location);
				Tree.UpdateView();
			}
			return true;
		}

		public override void MouseUp(TreeNodeAdvMouseEventArgs args)
		{
			Tree.ChangeInput();
			Tree.UpdateView();
			Tree.OnColumnClicked(Column);
		}
	}
}

```

`Aga.Controls/Tree/Input/ColumnState.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace Aga.Controls.Tree
{
	internal abstract class ColumnState : InputState
	{
		private TreeColumn _column;
		public TreeColumn Column 
		{
			get { return _column; } 
		}

		public ColumnState(TreeViewAdv tree, TreeColumn column)
			: base(tree)
		{
			_column = column;
		}
	}
}

```

`Aga.Controls/Tree/Input/InputState.cs`:

```cs
using System;
using System.Windows.Forms;
namespace Aga.Controls.Tree
{
	internal abstract class InputState
	{
		private TreeViewAdv _tree;

		public TreeViewAdv Tree
		{
			get { return _tree; }
		}

		public InputState(TreeViewAdv tree)
		{
			_tree = tree;
		}

		public abstract void KeyDown(System.Windows.Forms.KeyEventArgs args);
		public abstract void MouseDown(TreeNodeAdvMouseEventArgs args);
		public abstract void MouseUp(TreeNodeAdvMouseEventArgs args);

		/// <summary>
		/// handle OnMouseMove event
		/// </summary>
		/// <param name="args"></param>
		/// <returns>true if event was handled and should be dispatched</returns>
		public virtual bool MouseMove(MouseEventArgs args)
		{
			return false;
		}

		public virtual void MouseDoubleClick(TreeNodeAdvMouseEventArgs args)
		{
		}
	}
}

```

`Aga.Controls/Tree/Input/InputWithControl.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace Aga.Controls.Tree
{
	internal class InputWithControl: NormalInputState
	{
		public InputWithControl(TreeViewAdv tree): base(tree)
		{
		}

		protected override void DoMouseOperation(TreeNodeAdvMouseEventArgs args)
		{
			if (Tree.SelectionMode == TreeSelectionMode.Single)
			{
				base.DoMouseOperation(args);
			}
			else if (CanSelect(args.Node))
			{
				args.Node.IsSelected = !args.Node.IsSelected;
				Tree.SelectionStart = args.Node;
			}
		}

		protected override void MouseDownAtEmptySpace(TreeNodeAdvMouseEventArgs args)
		{
		}
	}
}

```

`Aga.Controls/Tree/Input/InputWithShift.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace Aga.Controls.Tree
{
	internal class InputWithShift: NormalInputState
	{
		public InputWithShift(TreeViewAdv tree): base(tree)
		{
		}

		protected override void FocusRow(TreeNodeAdv node)
		{
			Tree.SuspendSelectionEvent = true;
			try
			{
				if (Tree.SelectionMode == TreeSelectionMode.Single || Tree.SelectionStart == null)
					base.FocusRow(node);
				else if (CanSelect(node))
				{
					SelectAllFromStart(node);
					Tree.CurrentNode = node;
					Tree.ScrollTo(node);
				}
			}
			finally
			{
				Tree.SuspendSelectionEvent = false;
			}
		}

		protected override void DoMouseOperation(TreeNodeAdvMouseEventArgs args)
		{
			if (Tree.SelectionMode == TreeSelectionMode.Single || Tree.SelectionStart == null)
			{
				base.DoMouseOperation(args);
			}
			else if (CanSelect(args.Node))
			{
				Tree.SuspendSelectionEvent = true;
				try
				{
					SelectAllFromStart(args.Node);
				}
				finally
				{
					Tree.SuspendSelectionEvent = false;
				}
			}
		}

		protected override void MouseDownAtEmptySpace(TreeNodeAdvMouseEventArgs args)
		{
		}

		private void SelectAllFromStart(TreeNodeAdv node)
		{
			Tree.ClearSelectionInternal();
			int a = node.Row;
			int b = Tree.SelectionStart.Row;
			for (int i = Math.Min(a, b); i <= Math.Max(a, b); i++)
			{
				if (Tree.SelectionMode == TreeSelectionMode.Multi || Tree.RowMap[i].Parent == node.Parent)
					Tree.RowMap[i].IsSelected = true;
			}
		}
	}
}

```

`Aga.Controls/Tree/Input/NormalInputState.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;

namespace Aga.Controls.Tree
{
	internal class NormalInputState : InputState
	{
		private bool _mouseDownFlag = false;

		public NormalInputState(TreeViewAdv tree) : base(tree)
		{
		}

		public override void KeyDown(KeyEventArgs args)
		{
			if (Tree.CurrentNode == null && Tree.Root.Nodes.Count > 0)
				Tree.CurrentNode = Tree.Root.Nodes[0];

			if (Tree.CurrentNode != null)
			{
				switch (args.KeyCode)
				{
					case Keys.Right:
						if (!Tree.CurrentNode.IsExpanded)
							Tree.CurrentNode.IsExpanded = true;
						else if (Tree.CurrentNode.Nodes.Count > 0)
							Tree.SelectedNode = Tree.CurrentNode.Nodes[0];
						args.Handled = true;
						break;
					case Keys.Left:
						if (Tree.CurrentNode.IsExpanded)
							Tree.CurrentNode.IsExpanded = false;
						else if (Tree.CurrentNode.Parent != Tree.Root)
							Tree.SelectedNode = Tree.CurrentNode.Parent;
						args.Handled = true;
						break;
					case Keys.Down:
						NavigateForward(1);
						args.Handled = true;
						break;
					case Keys.Up:
						NavigateBackward(1);
						args.Handled = true;
						break;
					case Keys.PageDown:
						NavigateForward(Math.Max(1, Tree.CurrentPageSize - 1));
						args.Handled = true;
						break;
					case Keys.PageUp:
						NavigateBackward(Math.Max(1, Tree.CurrentPageSize - 1));
						args.Handled = true;
						break;
					case Keys.Home:
						if (Tree.RowMap.Count > 0)
							FocusRow(Tree.RowMap[0]);
						args.Handled = true;
						break;
					case Keys.End:
						if (Tree.RowMap.Count > 0)
							FocusRow(Tree.RowMap[Tree.RowMap.Count-1]);
						args.Handled = true;
						break;
					case Keys.Subtract:
						Tree.CurrentNode.Collapse();
						args.Handled = true;
						args.SuppressKeyPress = true;
						break;
					case Keys.Add:
						Tree.CurrentNode.Expand();
						args.Handled = true;
						args.SuppressKeyPress = true;
						break;
					case Keys.Multiply:
						Tree.CurrentNode.ExpandAll();
						args.Handled = true;
						args.SuppressKeyPress = true;
						break;
					case Keys.A:
						if (args.Modifiers == Keys.Control)
							Tree.SelectAllNodes();
						break;
				}
			}
		}

		public override void MouseDown(TreeNodeAdvMouseEventArgs args)
		{
			if (args.Node != null)
			{
				Tree.ItemDragMode = true;
				Tree.ItemDragStart = args.Location;

				if (args.Button == MouseButtons.Left || args.Button == MouseButtons.Right)
				{
					Tree.BeginUpdate();
					try
					{
						Tree.CurrentNode = args.Node;
						if (args.Node.IsSelected)
							_mouseDownFlag = true;
						else
						{
							_mouseDownFlag = false;
							DoMouseOperation(args);
						}
					}
					finally
					{
						Tree.EndUpdate();
					}
				}

			}
			else
			{
				Tree.ItemDragMode = false;
				MouseDownAtEmptySpace(args);
			}
		}

		public override void MouseUp(TreeNodeAdvMouseEventArgs args)
		{
			Tree.ItemDragMode = false;
			if (_mouseDownFlag && args.Node != null)
			{
				if (args.Button == MouseButtons.Left)
					DoMouseOperation(args);
				else if (args.Button == MouseButtons.Right)
					Tree.CurrentNode = args.Node;
			}
			_mouseDownFlag = false;
		}


		private void NavigateBackward(int n)
		{
			int row = Math.Max(Tree.CurrentNode.Row - n, 0);
			if (row != Tree.CurrentNode.Row)
				FocusRow(Tree.RowMap[row]);
		}

		private void NavigateForward(int n)
		{
			int row = Math.Min(Tree.CurrentNode.Row + n, Tree.RowCount - 1);
			if (row != Tree.CurrentNode.Row)
				FocusRow(Tree.RowMap[row]);
		}

		protected virtual void MouseDownAtEmptySpace(TreeNodeAdvMouseEventArgs args)
		{
			Tree.ClearSelection();
		}

		protected virtual void FocusRow(TreeNodeAdv node)
		{
			Tree.SuspendSelectionEvent = true;
			try
			{
				Tree.ClearSelectionInternal();
				Tree.CurrentNode = node;
				Tree.SelectionStart = node;
				node.IsSelected = true;
				Tree.ScrollTo(node);
			}
			finally
			{
				Tree.SuspendSelectionEvent = false;
			}
		}

		protected bool CanSelect(TreeNodeAdv node)
		{
			if (Tree.SelectionMode == TreeSelectionMode.MultiSameParent)
			{
				return (Tree.SelectionStart == null || node.Parent == Tree.SelectionStart.Parent);
			}
			else
				return true;
		}

		protected virtual void DoMouseOperation(TreeNodeAdvMouseEventArgs args)
		{
			if (Tree.SelectedNodes.Count == 1 && args.Node != null && args.Node.IsSelected)
				return;

			Tree.SuspendSelectionEvent = true;
			try
			{
				Tree.ClearSelectionInternal();
				if (args.Node != null)
					args.Node.IsSelected = true;
				Tree.SelectionStart = args.Node;
			}
			finally
			{
				Tree.SuspendSelectionEvent = false;
			}
		}
	}
}

```

`Aga.Controls/Tree/Input/ReorderColumnState.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Windows.Forms;

namespace Aga.Controls.Tree
{
	internal class ReorderColumnState : ColumnState
	{
		#region Properties

		private Point _location;
		public Point Location
		{
			get { return _location; }
		}

		private Bitmap _ghostImage;
		public Bitmap GhostImage
		{
			get { return _ghostImage; }
		}

		private TreeColumn _dropColumn;
		public TreeColumn DropColumn
		{
			get { return _dropColumn; }
		}

		private int _dragOffset;
		public int DragOffset
		{
			get { return _dragOffset; }
		}

		#endregion

		public ReorderColumnState(TreeViewAdv tree, TreeColumn column, Point initialMouseLocation)
			: base(tree, column)
		{
			_location = new Point(initialMouseLocation.X + Tree.OffsetX, 0);
			_dragOffset = tree.GetColumnX(column) - initialMouseLocation.X;
			_ghostImage = column.CreateGhostImage(new Rectangle(0, 0, column.Width, tree.ColumnHeaderHeight), tree.Font);
		}

		public override void KeyDown(KeyEventArgs args)
		{
			args.Handled = true;
			if (args.KeyCode == Keys.Escape)
				FinishResize();
		}

		public override void MouseDown(TreeNodeAdvMouseEventArgs args)
		{
		}

		public override void MouseUp(TreeNodeAdvMouseEventArgs args)
		{
			FinishResize();
		}

		public override bool MouseMove(MouseEventArgs args)
		{
			_dropColumn = null;
			_location = new Point(args.X + Tree.OffsetX, 0);
			int x = 0;
			foreach (TreeColumn c in Tree.Columns)
			{
				if (c.IsVisible)
				{
					if (_location.X < x + c.Width / 2)
					{
						_dropColumn = c;
						break;
					}
					x += c.Width;
				}
			}
			Tree.UpdateHeaders();
			return true;
		}

		private void FinishResize()
		{
			Tree.ChangeInput();
			if (Column == DropColumn)
				Tree.UpdateView();
			else
			{
				Tree.Columns.Remove(Column);
				if (DropColumn == null)
					Tree.Columns.Add(Column);
				else
					Tree.Columns.Insert(Tree.Columns.IndexOf(DropColumn), Column);

				Tree.OnColumnReordered(Column);
			}
		}
	}
}
```

`Aga.Controls/Tree/Input/ResizeColumnState.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;
using System.Security.Permissions;
using System.Drawing;

namespace Aga.Controls.Tree
{
	internal class ResizeColumnState: ColumnState
	{
		private Point _initLocation;
		private int _initWidth;

		public ResizeColumnState(TreeViewAdv tree, TreeColumn column, Point p)
			: base(tree, column)
		{
			_initLocation = p;
			_initWidth = column.Width;
		}

		public override void KeyDown(KeyEventArgs args)
		{
			args.Handled = true;
			if (args.KeyCode == Keys.Escape)
				FinishResize();
		}

		public override void MouseDown(TreeNodeAdvMouseEventArgs args)
		{
		}

		public override void MouseUp(TreeNodeAdvMouseEventArgs args)
		{
			FinishResize();
		}

		private void FinishResize()
		{
			Tree.ChangeInput();
			Tree.FullUpdate();
			Tree.OnColumnWidthChanged(Column);
		}

        public override bool MouseMove(MouseEventArgs args)
        {
			Column.Width = _initWidth + args.Location.X - _initLocation.X;
            Tree.UpdateView();
            return true;
        }

		public override void MouseDoubleClick(TreeNodeAdvMouseEventArgs args)
		{
			Tree.AutoSizeColumn(Column);
		}
	}
}

```

`Aga.Controls/Tree/ListModel.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Collections;

namespace Aga.Controls.Tree
{
	public class ListModel : TreeModelBase
	{
		private IList _list;

		public int Count
		{
			get { return _list.Count; }
		}

		public ListModel()
		{
			_list = new List<object>();
		}

		public ListModel(IList list)
		{
			_list = list;
		}

		public override IEnumerable GetChildren(TreePath treePath)
		{
			return _list;
		}

		public override bool IsLeaf(TreePath treePath)
		{
			return true;
		}

		public void AddRange(IEnumerable items)
		{
			foreach (object obj in items)
				_list.Add(obj);
			OnStructureChanged(new TreePathEventArgs(TreePath.Empty));
		}

		public void Add(object item)
		{
			_list.Add(item);
			OnNodesInserted(new TreeModelEventArgs(TreePath.Empty, new int[] { _list.Count - 1 }, new object[] { item }));
		}

		public void Clear()
		{
			_list.Clear();
			OnStructureChanged(new TreePathEventArgs(TreePath.Empty));
		}
	}
}

```

`Aga.Controls/Tree/NativeMethods.cs`:

```cs
using System;
using System.Drawing;
using System.Runtime.InteropServices;


namespace Aga.Controls.Tree
{
    internal static class NativeMethods
    {
        public const int DCX_WINDOW = 0x01;
        public const int DCX_CACHE = 0x02;
        public const int DCX_NORESETATTRS = 0x04;
        public const int DCX_CLIPCHILDREN = 0x08;
        public const int DCX_CLIPSIBLINGS = 0x10;
        public const int DCX_PARENTCLIP = 0x20;
        public const int DCX_EXCLUDERGN = 0x40;
        public const int DCX_INTERSECTRGN = 0x80;
        public const int DCX_EXCLUDEUPDATE = 0x100;
        public const int DCX_INTERSECTUPDATE = 0x200;
        public const int DCX_LOCKWINDOWUPDATE = 0x400;
        public const int DCX_VALIDATE = 0x200000;

        public const int WM_THEMECHANGED = 0x031A;
        public const int WM_NCPAINT = 0x85;
        public const int WM_NCCALCSIZE = 0x83;

        public const int WS_BORDER = 0x800000;
        public const int WS_EX_CLIENTEDGE = 0x200;

        public const int WVR_HREDRAW = 0x100;
        public const int WVR_VREDRAW = 0x200;
        public const int WVR_REDRAW = (WVR_HREDRAW | WVR_VREDRAW);

        [StructLayout(LayoutKind.Sequential)]
        public struct NCCALCSIZE_PARAMS
        {
            public RECT rgrc0, rgrc1, rgrc2;
            public IntPtr lppos;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct RECT
        {
            public int Left;
            public int Top;
            public int Right;
            public int Bottom;

            public static RECT FromRectangle(Rectangle rectangle)
            {
                RECT result = new RECT();
                result.Left = rectangle.Left;
                result.Top = rectangle.Top;
                result.Right = rectangle.Right;
                result.Bottom = rectangle.Bottom;
                return result;
            }

            public Rectangle ToRectangle()
            {
                return new Rectangle(Left, Top, Right - Left, Bottom - Top);
            }
        }

        [DllImport("user32.dll", SetLastError = true)]
        public static extern IntPtr GetDCEx(IntPtr hWnd, IntPtr hrgnClip, int flags);

        [DllImport("user32.dll")]
        public static extern int ReleaseDC(IntPtr hWnd, IntPtr hDC);

        [DllImport("user32.dll")]
        public static extern bool GetWindowRect(IntPtr hWnd, out RECT lpRect);
    }
}

```

`Aga.Controls/Tree/Node.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Collections.ObjectModel;
using System.Windows.Forms;
using System.Drawing;

namespace Aga.Controls.Tree
{
	public class Node
	{
		#region NodeCollection

		private class NodeCollection : Collection<Node>
		{
			private Node _owner;

			public NodeCollection(Node owner)
			{
				_owner = owner;
			}

			protected override void ClearItems()
			{
				while (this.Count != 0)
					this.RemoveAt(this.Count - 1);
			}

			protected override void InsertItem(int index, Node item)
			{
				if (item == null)
					throw new ArgumentNullException("item");

				if (item.Parent != _owner)
				{
					if (item.Parent != null)
						item.Parent.Nodes.Remove(item);
					item._parent = _owner;
					item._index = index;
					for (int i = index; i < Count; i++)
						this[i]._index++;
					base.InsertItem(index, item);

					TreeModel model = _owner.FindModel();
					if (model != null)
						model.OnNodeInserted(_owner, index, item);
				}
			}

			protected override void RemoveItem(int index)
			{
				Node item = this[index];
				item._parent = null;
				item._index = -1;
				for (int i = index + 1; i < Count; i++)
					this[i]._index--;
				base.RemoveItem(index);

				TreeModel model = _owner.FindModel();
				if (model != null)
					model.OnNodeRemoved(_owner, index, item);
			}

			protected override void SetItem(int index, Node item)
			{
				if (item == null)
					throw new ArgumentNullException("item");

				RemoveAt(index);
				InsertItem(index, item);
			}
		}

		#endregion

		#region Properties

		private TreeModel _model;
		internal TreeModel Model
		{
			get { return _model; }
			set { _model = value; }
		}

		private NodeCollection _nodes;
		public Collection<Node> Nodes
		{
			get { return _nodes; }
		}

		private Node _parent;
		public Node Parent
		{
			get { return _parent; }
			set 
			{
				if (value != _parent)
				{
					if (_parent != null)
						_parent.Nodes.Remove(this);

					if (value != null)
						value.Nodes.Add(this);
				}
			}
		}

		private int _index = -1;
		public int Index
		{
			get
			{
				return _index;
			}
		}

		public Node PreviousNode
		{
			get
			{
				int index = Index;
				if (index > 0)
					return _parent.Nodes[index - 1];
				else
					return null;
			}
		}

		public Node NextNode
		{
			get
			{
				int index = Index;
				if (index >= 0 && index < _parent.Nodes.Count - 1)
					return _parent.Nodes[index + 1];
				else
					return null;
			}
		}

		private string _text;
		public virtual string Text
		{
			get { return _text; }
			set 
			{
				if (_text != value)
				{
					_text = value;
					NotifyModel();
				}
			}
		}

		private CheckState _checkState;
		public virtual CheckState CheckState
		{
			get { return _checkState; }
			set 
			{
				if (_checkState != value)
				{
					_checkState = value;
					NotifyModel();
				}
			}
		}

		private Image _image;
		public Image Image
		{
			get { return _image; }
			set 
			{
				if (_image != value)
				{
					_image = value;
					NotifyModel();
				}
			}
		}

		private object _tag;
		public object Tag
		{
			get { return _tag; }
			set { _tag = value; }
		}

		public bool IsChecked
		{
			get 
			{ 
				return CheckState != CheckState.Unchecked;
			}
			set 
			{
				if (value)
					CheckState = CheckState.Checked;
				else
					CheckState = CheckState.Unchecked;
			}
		}

		public virtual bool IsLeaf
		{
			get
			{
				return false;
			}
		}

		#endregion

		public Node()
			: this(string.Empty)
		{
		}

		public Node(string text)
		{
			_text = text;
			_nodes = new NodeCollection(this);
		}

		public override string ToString()
		{
			return Text;
		}

		private TreeModel FindModel()
		{
			Node node = this;
			while (node != null)
			{
				if (node.Model != null)
					return node.Model;
				node = node.Parent;
			}
			return null;
		}

		protected void NotifyModel()
		{
			TreeModel model = FindModel();
			if (model != null && Parent != null)
			{
				TreePath path = model.GetPath(Parent);
				if (path != null)
				{
					TreeModelEventArgs args = new TreeModelEventArgs(path, new int[] { Index }, new object[] { this });
					model.OnNodesChanged(args);
				}
			}
		}
	}
}

```

`Aga.Controls/Tree/NodeControlInfo.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using Aga.Controls.Tree.NodeControls;
using System.Drawing;

namespace Aga.Controls.Tree
{
	public struct NodeControlInfo
	{
		public static readonly NodeControlInfo Empty = new NodeControlInfo(null, Rectangle.Empty, null);

		private NodeControl _control;
		public NodeControl Control
		{
			get { return _control; }
		}

		private Rectangle _bounds;
		public Rectangle Bounds
		{
			get { return _bounds; }
		}

		private TreeNodeAdv _node;
		public TreeNodeAdv Node
		{
			get { return _node; }
		}

		public NodeControlInfo(NodeControl control, Rectangle bounds, TreeNodeAdv node)
		{
			_control = control;
			_bounds = bounds;
			_node = node;
		}
	}
}

```

`Aga.Controls/Tree/NodeControls/BaseTextControl.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Windows.Forms;
using System.Reflection;
using System.ComponentModel;

namespace Aga.Controls.Tree.NodeControls
{
	public abstract class BaseTextControl : EditableControl
	{
		private TextFormatFlags _baseFormatFlags;
        private TextFormatFlags _formatFlags;
        private Pen _focusPen;
		private StringFormat _format;

		#region Properties

		private Font _font = null;
		public Font Font
		{
			get
			{
				if (_font == null)
					return Control.DefaultFont;
				else
					return _font;
			}
			set
			{
				if (value == Control.DefaultFont)
					_font = null;
				else
					_font = value;
			}
		}

		protected bool ShouldSerializeFont()
		{
			return (_font != null);
		}

		private HorizontalAlignment _textAlign = HorizontalAlignment.Left;
		[DefaultValue(HorizontalAlignment.Left)]
		public HorizontalAlignment TextAlign
		{
			get { return _textAlign; }
			set 
			{ 
				_textAlign = value;
				SetFormatFlags();
			}
		}

		private StringTrimming _trimming = StringTrimming.None;
		[DefaultValue(StringTrimming.None)]
		public StringTrimming Trimming
		{
			get { return _trimming; }
			set 
			{ 
				_trimming = value;
				SetFormatFlags();
			}
		}

		private bool _displayHiddenContentInToolTip = true;
		[DefaultValue(true)]
		public bool DisplayHiddenContentInToolTip
		{
			get { return _displayHiddenContentInToolTip; }
			set { _displayHiddenContentInToolTip = value; }
		}

		private bool _useCompatibleTextRendering = false;
		[DefaultValue(false)]
		public bool UseCompatibleTextRendering
		{
			get { return _useCompatibleTextRendering; }
			set { _useCompatibleTextRendering = value; }
		}

		[DefaultValue(false)]
		public bool TrimMultiLine
		{
			get;
			set;
		}

		#endregion

		protected BaseTextControl()
		{
			IncrementalSearchEnabled = true;
			_focusPen = new Pen(Color.Black);
			_focusPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;

			_format = new StringFormat(StringFormatFlags.LineLimit | StringFormatFlags.NoClip | StringFormatFlags.FitBlackBox | StringFormatFlags.MeasureTrailingSpaces);
			_baseFormatFlags = TextFormatFlags.PreserveGraphicsClipping |
						   TextFormatFlags.PreserveGraphicsTranslateTransform;
			SetFormatFlags();
			LeftMargin = 3;
		}

		private void SetFormatFlags()
		{
			_format.Alignment = TextHelper.TranslateAligment(TextAlign);
			_format.Trimming = Trimming;

			_formatFlags = _baseFormatFlags | TextHelper.TranslateAligmentToFlag(TextAlign)
				| TextHelper.TranslateTrimmingToFlag(Trimming);
		}

		public override Size MeasureSize(TreeNodeAdv node, DrawContext context)
		{
			return GetLabelSize(node, context);
		}

		protected Size GetLabelSize(TreeNodeAdv node, DrawContext context)
		{
			return GetLabelSize(node, context, GetLabel(node));
		}

		protected Size GetLabelSize(TreeNodeAdv node, DrawContext context, string label)
		{
			PerformanceAnalyzer.Start("GetLabelSize");
			CheckThread();
			Font font = GetDrawingFont(node, context, label);
			Size s = Size.Empty;
			if (UseCompatibleTextRendering)
				s = TextRenderer.MeasureText(label, font);
			else
			{
				SizeF sf = context.Graphics.MeasureString(label, font);
				s = new Size((int)Math.Ceiling(sf.Width), (int)Math.Ceiling(sf.Height));
			}
			PerformanceAnalyzer.Finish("GetLabelSize");

			if (!s.IsEmpty)
				return s;
			else
				return new Size(10, Font.Height);
		}

		protected Font GetDrawingFont(TreeNodeAdv node, DrawContext context, string label)
		{
			Font font = context.Font;
			if (DrawTextMustBeFired(node))
			{
				DrawEventArgs args = new DrawEventArgs(node, this, context, label);
				args.Font = context.Font;
				OnDrawText(args);
				font = args.Font;
			}
			return font;
		}

		protected void SetEditControlProperties(Control control, TreeNodeAdv node)
		{
			string label = GetLabel(node);
			DrawContext context = new DrawContext();
			context.Font = control.Font;
			control.Font = GetDrawingFont(node, context, label);
		}

		public override void Draw(TreeNodeAdv node, DrawContext context)
		{
			if (context.CurrentEditorOwner == this && node == Parent.CurrentNode)
				return;

			PerformanceAnalyzer.Start("BaseTextControl.Draw");
			string label = GetLabel(node);
			Rectangle bounds = GetBounds(node, context);
			Rectangle focusRect = new Rectangle(bounds.X, context.Bounds.Y,	
				bounds.Width, context.Bounds.Height);

			Brush backgroundBrush;
			Color textColor;
			Font font;
			CreateBrushes(node, context, label, out backgroundBrush, out textColor, out font, ref label);

			if (backgroundBrush != null)
				context.Graphics.FillRectangle(backgroundBrush, focusRect);
			if (context.DrawFocus)
			{
				focusRect.Width--;
				focusRect.Height--;
				if (context.DrawSelection == DrawSelectionMode.None)
					_focusPen.Color = SystemColors.ControlText;
				else
					_focusPen.Color = SystemColors.InactiveCaption;
				context.Graphics.DrawRectangle(_focusPen, focusRect);
			}
			
			PerformanceAnalyzer.Start("BaseTextControl.DrawText");
			if (UseCompatibleTextRendering)
				TextRenderer.DrawText(context.Graphics, label, font, bounds, textColor, _formatFlags);
			else
				context.Graphics.DrawString(label, font, GetFrush(textColor), bounds, _format);
			PerformanceAnalyzer.Finish("BaseTextControl.DrawText");

			PerformanceAnalyzer.Finish("BaseTextControl.Draw");
		}

		private static Dictionary<Color, Brush> _brushes = new Dictionary<Color,Brush>();
		private static Brush GetFrush(Color color)
		{
			Brush br;
			if (_brushes.ContainsKey(color))
				br = _brushes[color];
			else
			{
				br = new SolidBrush(color);
				_brushes.Add(color, br);
			}
			return br;
		}

		private void CreateBrushes(TreeNodeAdv node, DrawContext context, string text, out Brush backgroundBrush, out Color textColor, out Font font, ref string label)
		{
			textColor = Parent.ForeColor;
			backgroundBrush = null;
			font = context.Font;
			if (context.DrawSelection == DrawSelectionMode.Active)
			{
				textColor = SystemColors.HighlightText;
                backgroundBrush = SystemBrushes.Highlight;
			}
			else if (context.DrawSelection == DrawSelectionMode.Inactive)
			{
				textColor = Parent.ForeColor;
                backgroundBrush = SystemBrushes.InactiveBorder;
			}
			else if (context.DrawSelection == DrawSelectionMode.FullRowSelect)
				textColor = Parent.ForeColor;

			if (!context.Enabled)
				textColor = SystemColors.GrayText;

			if (DrawTextMustBeFired(node))
			{
				DrawEventArgs args = new DrawEventArgs(node, this, context, text);
				args.Text = label;
				args.TextColor = textColor;
				args.BackgroundBrush = backgroundBrush;
				args.Font = font;

				OnDrawText(args);

				textColor = args.TextColor;
				backgroundBrush = args.BackgroundBrush;
				font = args.Font;
				label = args.Text;
			}
		}

		public string GetLabel(TreeNodeAdv node)
		{
			if (node != null && node.Tag != null)
			{
				object obj = GetValue(node);
				if (obj != null)
					return FormatLabel(obj);
			}
			return string.Empty;
		}

		protected virtual string FormatLabel(object obj)
		{
			var res = obj.ToString();
			if (TrimMultiLine && res != null)
			{
				string[] parts = res.Split('\n');
				if (parts.Length > 1)
					return parts[0] + "...";
			}
			return res;
		}

		public void SetLabel(TreeNodeAdv node, string value)
		{
			SetValue(node, value);
		}

		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
			if (disposing)
			{
				_focusPen.Dispose();
				_format.Dispose();
			}
		}

		/// <summary>
		/// Fires when control is going to draw a text. Can be used to change text or back color
		/// </summary>
		public event EventHandler<DrawEventArgs> DrawText;
		protected virtual void OnDrawText(DrawEventArgs args)
		{
			TreeViewAdv tree = args.Node.Tree;
			if (tree != null)
				tree.FireDrawControl(args);
			if (DrawText != null)
				DrawText(this, args);
		}

		protected virtual bool DrawTextMustBeFired(TreeNodeAdv node)
		{
			return DrawText != null || (node.Tree != null && node.Tree.DrawControlMustBeFired());
		}
	}
}

```

`Aga.Controls/Tree/NodeControls/BindableControl.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using System.ComponentModel;

namespace Aga.Controls.Tree.NodeControls
{
	public abstract class BindableControl : NodeControl
	{
		private struct MemberAdapter
		{
			private object _obj;
			private PropertyInfo _pi;
			private FieldInfo _fi;

			public static readonly MemberAdapter Empty = new MemberAdapter();

			public Type MemberType
			{
				get
				{
					if (_pi != null)
						return _pi.PropertyType;
					else if (_fi != null)
						return _fi.FieldType;
					else
						return null;
				}
			}

			public object Value
			{
				get
				{
					if (_pi != null && _pi.CanRead)
						return _pi.GetValue(_obj, null);
					else if (_fi != null)
						return _fi.GetValue(_obj);
					else
						return null;
				}
				set
				{
					if (_pi != null && _pi.CanWrite)
						_pi.SetValue(_obj, value, null);
					else if (_fi != null)
						_fi.SetValue(_obj, value);
				}
			}

			public MemberAdapter(object obj, PropertyInfo pi)
			{
				_obj = obj;
				_pi = pi;
				_fi = null;
			}

			public MemberAdapter(object obj, FieldInfo fi)
			{
				_obj = obj;
				_fi = fi;
				_pi = null;
			}
		}

		#region Properties

		private bool _virtualMode = false;
		[DefaultValue(false), Category("Data")]
		public bool VirtualMode
		{
			get { return _virtualMode; }
			set { _virtualMode = value; }
		}

		private string _propertyName = "";
		[DefaultValue(""), Category("Data")]
		public string DataPropertyName
		{
			get { return _propertyName; }
			set 
			{
				if (_propertyName == null)
					_propertyName = string.Empty;
				_propertyName = value; 
			}
		}

		private bool _incrementalSearchEnabled = false;
		[DefaultValue(false)]
		public bool IncrementalSearchEnabled
		{
			get { return _incrementalSearchEnabled; }
			set { _incrementalSearchEnabled = value; }
		}

		#endregion

		public virtual object GetValue(TreeNodeAdv node)
		{
			if (VirtualMode)
			{
				NodeControlValueEventArgs args = new NodeControlValueEventArgs(node);
				OnValueNeeded(args);
				return args.Value;
			}
			else
			{
				try
				{
					return GetMemberAdapter(node).Value;
				}
				catch (TargetInvocationException ex)
				{
					if (ex.InnerException != null)
						throw new ArgumentException(ex.InnerException.Message, ex.InnerException);
					else
						throw new ArgumentException(ex.Message);
				}
			}
		}

		public virtual void SetValue(TreeNodeAdv node, object value)
		{
			if (VirtualMode)
			{
				NodeControlValueEventArgs args = new NodeControlValueEventArgs(node);
				args.Value = value;
				OnValuePushed(args);
			}
			else
			{
				try
				{
					MemberAdapter ma = GetMemberAdapter(node);
					ma.Value = value;
				}
				catch (TargetInvocationException ex)
				{
					if (ex.InnerException != null)
						throw new ArgumentException(ex.InnerException.Message, ex.InnerException);
					else
						throw new ArgumentException(ex.Message);
				}
			}
		}

		public Type GetPropertyType(TreeNodeAdv node)
		{
			return GetMemberAdapter(node).MemberType;
		}

		private MemberAdapter GetMemberAdapter(TreeNodeAdv node)
		{
			if (node.Tag != null && !string.IsNullOrEmpty(DataPropertyName))
			{
				Type type = node.Tag.GetType();
				PropertyInfo pi = type.GetProperty(DataPropertyName);
				if (pi != null)
					return new MemberAdapter(node.Tag, pi);
				else
				{
					FieldInfo fi = type.GetField(DataPropertyName, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
					if (fi != null)
						return new MemberAdapter(node.Tag, fi);
				}
			}
			return MemberAdapter.Empty;
		}

		public override string ToString()
		{
			if (string.IsNullOrEmpty(DataPropertyName))
				return GetType().Name;
			else
				return string.Format("{0} ({1})", GetType().Name, DataPropertyName);
		}

		public event EventHandler<NodeControlValueEventArgs> ValueNeeded;
		private void OnValueNeeded(NodeControlValueEventArgs args)
		{
			if (ValueNeeded != null)
				ValueNeeded(this, args);
		}

		public event EventHandler<NodeControlValueEventArgs> ValuePushed;
		private void OnValuePushed(NodeControlValueEventArgs args)
		{
			if (ValuePushed != null)
				ValuePushed(this, args);
		}
	}
}

```

`Aga.Controls/Tree/NodeControls/ClassDiagram.cd`:

```cd
<?xml version="1.0" encoding="utf-8"?>
<ClassDiagram MajorVersion="1" MinorVersion="1">
  <Font Name="Microsoft Sans Serif" Size="8.25" />
  <Class Name="Aga.Controls.Tree.NodeControls.NodeStateIcon" Collapsed="true">
    <Position X="0.5" Y="4" Width="1.5" />
    <TypeIdentifier>
      <FileName>Tree\NodeControls\NodeStateIcon.cs</FileName>
      <HashCode>ABAAAAAAAAQAQAAAAAAAAAAAAAAAAAAAQIAAAAAAAAA=</HashCode>
    </TypeIdentifier>
  </Class>
  <Class Name="Aga.Controls.Tree.NodeControls.BindableControl" Collapsed="true">
    <Position X="2.75" Y="1.5" Width="1.5" />
    <TypeIdentifier>
      <FileName>Tree\NodeControls\BindableControl.cs</FileName>
      <HashCode>FAAAAAAQIBAQCgAEAAAAIAAAAAAAAAEMAAACAAAAAAE=</HashCode>
    </TypeIdentifier>
  </Class>
  <Class Name="Aga.Controls.Tree.NodeControls.NodeCheckBox" Collapsed="true">
    <Position X="5" Y="4" Width="1.5" />
    <TypeIdentifier>
      <FileName>Tree\NodeControls\NodeCheckBox.cs</FileName>
      <HashCode>AAEAAAAAAAACgkQCAAAAAAigAgAAEGABAAAIAAAAAAA=</HashCode>
    </TypeIdentifier>
  </Class>
  <Class Name="Aga.Controls.Tree.NodeControls.NodeControl" Collapsed="true">
    <Position X="1.5" Y="0.5" Width="1.5" />
    <TypeIdentifier>
      <FileName>Tree\NodeControls\NodeControl.cs</FileName>
      <HashCode>AAAAAJAAgIgBkkoQAAgAQAAwAAABEIQAAEBIAAAAAAA=</HashCode>
    </TypeIdentifier>
    <Compartments>
      <Compartment Name="Fields" Collapsed="true" />
    </Compartments>
  </Class>
  <Class Name="Aga.Controls.Tree.NodeControls.NodeIcon" Collapsed="true">
    <Position X="0.5" Y="2.75" Width="1.5" />
    <TypeIdentifier>
      <FileName>Tree\NodeControls\NodeIcon.cs</FileName>
      <HashCode>ABAAAAAAAAAAAgAAAAAAAAAgAAAAAAAAAAAAAAAAAAA=</HashCode>
    </TypeIdentifier>
  </Class>
  <Class Name="Aga.Controls.Tree.NodeControls.NodePlusMinus" Collapsed="true">
    <Position X="0.5" Y="1.5" Width="1.5" />
    <TypeIdentifier>
      <FileName>Tree\NodeControls\NodePlusMinus.cs</FileName>
      <HashCode>AAAAAAAAAAAAAgAAAAAAAEAgAAAAMCAAAAAIACAAAAA=</HashCode>
    </TypeIdentifier>
  </Class>
  <Class Name="Aga.Controls.Tree.NodeControls.BaseTextControl" Collapsed="true">
    <Position X="3" Y="5" Width="1.5" />
    <TypeIdentifier>
      <FileName>Tree\NodeControls\BaseTextControl.cs</FileName>
      <HashCode>AAAAICBQACAAIgACBCAEAQA8AgmFoAAwAAAAACACAMA=</HashCode>
    </TypeIdentifier>
  </Class>
  <Class Name="Aga.Controls.Tree.NodeControls.NodeTextBox" Collapsed="true">
    <Position X="1" Y="6" Width="1.5" />
    <TypeIdentifier>
      <FileName>Tree\NodeControls\NodeTextBox.cs</FileName>
      <HashCode>QQQAhAAAADAMgAAAABAAAAAAAgEAIAAAAAAAAIAAAAA=</HashCode>
    </TypeIdentifier>
  </Class>
  <Class Name="Aga.Controls.Tree.NodeControls.EditableControl" Collapsed="true">
    <Position X="3" Y="4" Width="1.5" />
    <TypeIdentifier>
      <FileName>Tree\NodeControls\EditableControl.cs</FileName>
      <HashCode>QQAgAAAACGgkAMAABAEEkADAEAAUEAAABAGoAAAAAQA=</HashCode>
    </TypeIdentifier>
  </Class>
  <Class Name="Aga.Controls.Tree.NodeControls.NodeComboBox" Collapsed="true">
    <Position X="3" Y="6" Width="1.5" />
    <TypeIdentifier>
      <FileName>Tree\NodeControls\NodeComboBox.cs</FileName>
      <HashCode>wQACAAAAAAAMAEBAAAAAAABAAAAAAAABAAAAAAAAAAA=</HashCode>
    </TypeIdentifier>
  </Class>
  <Class Name="Aga.Controls.Tree.NodeControls.NodeNumericUpDown" Collapsed="true">
    <Position X="5" Y="6" Width="1.75" />
    <TypeIdentifier>
      <FileName>Tree\NodeControls\NodeNumericUpDown.cs</FileName>
      <HashCode>wQAAAACAAAAEAABAIAAQIAAAAAAAAAABAAAIAAAAAII=</HashCode>
    </TypeIdentifier>
  </Class>
  <Class Name="Aga.Controls.Tree.NodeControls.InteractiveControl" Collapsed="true">
    <Position X="4" Y="2.75" Width="1.5" />
    <TypeIdentifier>
      <FileName>Tree\NodeControls\InteractiveControl.cs</FileName>
      <HashCode>AAAABAAAAAAAAAAACAAAAAAAABAAAQAAAAAAAAIAAAA=</HashCode>
    </TypeIdentifier>
  </Class>
  <Class Name="Aga.Controls.Tree.NodeControls.NodeDecimalTextBox" Collapsed="true">
    <Position X="2.5" Y="7" Width="1.75" />
    <TypeIdentifier>
      <FileName>Tree\NodeControls\NodeDecimalTextBox.cs</FileName>
      <HashCode>AQAAAAAAAACAAAACAAAAAAQAAAAAIAAAAAgAAAAAAAA=</HashCode>
    </TypeIdentifier>
  </Class>
  <Class Name="Aga.Controls.Tree.NodeControls.NodeIntegerTextBox" Collapsed="true">
    <Position X="0.5" Y="7" Width="1.75" />
    <TypeIdentifier>
      <FileName>Tree\NodeControls\NodeIntegerTextBox.cs</FileName>
      <HashCode>AQAAAAAAAAAAAAACAAAAAAQAAAAAIAAAAAAAAAAAAAA=</HashCode>
    </TypeIdentifier>
  </Class>
</ClassDiagram>
```

`Aga.Controls/Tree/NodeControls/DrawEventArgs.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;

namespace Aga.Controls.Tree.NodeControls
{
	public class DrawEventArgs : NodeEventArgs
	{
		private DrawContext _context;
		public DrawContext Context
		{
			get { return _context; }
		}

		private Brush _textBrush;
		[Obsolete("Use TextColor")]
		public Brush TextBrush
		{
			get { return _textBrush; }
			set { _textBrush = value; }
		}

		private Brush _backgroundBrush;
		public Brush BackgroundBrush
		{
            get { return _backgroundBrush; }
			set { _backgroundBrush = value; }
		}

		private Font _font;
		public Font Font
		{
			get { return _font; }
			set { _font = value; }
		}

		private Color _textColor;
		public Color TextColor
		{
			get { return _textColor; }
			set { _textColor = value; }
		}

		private string _text;
		public string Text
		{
			get { return _text; }
			set { _text = value; }
		}


		private EditableControl _control;
		public EditableControl Control
		{
			get { return _control; }
		}

		public DrawEventArgs(TreeNodeAdv node, EditableControl control, DrawContext context, string text)
			: base(node)
		{
			_control = control;
			_context = context;
			_text = text;
		}
	}
}

```

`Aga.Controls/Tree/NodeControls/EditEventArgs.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;

namespace Aga.Controls.Tree.NodeControls
{
	public class EditEventArgs : NodeEventArgs
	{
		private Control _control;
		public Control Control
		{
			get { return _control; }
		}

		public EditEventArgs(TreeNodeAdv node, Control control)
			: base(node)
		{
			_control = control;
		}
	}
}

```

`Aga.Controls/Tree/NodeControls/EditableControl.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;
using System.Drawing;
using System.ComponentModel;

namespace Aga.Controls.Tree.NodeControls
{
	public abstract class EditableControl : InteractiveControl
	{
		private Timer _timer;
		private bool _editFlag;

		#region Properties

		private bool _editOnClick = false;
		[DefaultValue(false)]
		public bool EditOnClick
		{
			get { return _editOnClick; }
			set { _editOnClick = value; }
		}

		#endregion

		protected EditableControl()
		{
			_timer = new Timer();
			_timer.Interval = 500;
			_timer.Tick += new EventHandler(TimerTick);
		}

		private void TimerTick(object sender, EventArgs e)
		{
			_timer.Stop();
			if (_editFlag)
				BeginEdit();
			_editFlag = false;
		}

		public void SetEditorBounds(EditorContext context)
		{
			Size size = CalculateEditorSize(context);
			context.Editor.Bounds = new Rectangle(context.Bounds.X, context.Bounds.Y,
				Math.Min(size.Width, context.Bounds.Width),
				Math.Min(size.Height, Parent.ClientSize.Height - context.Bounds.Y)
			);
		}

		protected abstract Size CalculateEditorSize(EditorContext context);

		protected virtual bool CanEdit(TreeNodeAdv node)
		{
			return (node.Tag != null) && IsEditEnabled(node);
		}

		public void BeginEdit()
		{
			if (Parent != null && Parent.CurrentNode != null && CanEdit(Parent.CurrentNode))
			{
				CancelEventArgs args = new CancelEventArgs();
				OnEditorShowing(args);
				if (!args.Cancel)
				{
					var editor = CreateEditor(Parent.CurrentNode);
					Parent.DisplayEditor(editor, this);
				}
			}
		}

		public void EndEdit(bool applyChanges)
		{
			if (Parent != null)
				if (Parent.HideEditor(applyChanges))
					OnEditorHided();
		}

		public virtual void UpdateEditor(Control control)
		{
		}

		internal void ApplyChanges(TreeNodeAdv node, Control editor)
		{
			DoApplyChanges(node, editor);
			OnChangesApplied();
		}

		internal void DoDisposeEditor(Control editor)
		{
			DisposeEditor(editor);
		}

		protected abstract void DoApplyChanges(TreeNodeAdv node, Control editor);

		protected abstract Control CreateEditor(TreeNodeAdv node);

		protected abstract void DisposeEditor(Control editor);

		public virtual void Cut(Control control)
		{
		}

		public virtual void Copy(Control control)
		{
		}

		public virtual void Paste(Control control)
		{
		}

		public virtual void Delete(Control control)
		{
		}

		public override void MouseDown(TreeNodeAdvMouseEventArgs args)
		{
			_editFlag = (!EditOnClick && args.Button == MouseButtons.Left
				&& args.ModifierKeys == Keys.None && args.Node.IsSelected);
		}

		public override void MouseUp(TreeNodeAdvMouseEventArgs args)
		{
			if (args.Node.IsSelected)
			{
				if (EditOnClick && args.Button == MouseButtons.Left && args.ModifierKeys == Keys.None)
				{
					Parent.ItemDragMode = false;
					BeginEdit();
					args.Handled = true;
				}
				else if (_editFlag)// && args.Node.IsSelected)
					_timer.Start();
			}
		}

		public override void MouseDoubleClick(TreeNodeAdvMouseEventArgs args)
		{
			_editFlag = false;
			_timer.Stop();
		}

		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
			if (disposing)
				_timer.Dispose();
		}

		#region Events

		public event CancelEventHandler EditorShowing;
		protected void OnEditorShowing(CancelEventArgs args)
		{
			if (EditorShowing != null)
				EditorShowing(this, args);
		}

		public event EventHandler EditorHided;
		protected void OnEditorHided()
		{
			if (EditorHided != null)
				EditorHided(this, EventArgs.Empty);
		}

		public event EventHandler ChangesApplied;
		protected void OnChangesApplied()
		{
			if (ChangesApplied != null)
				ChangesApplied(this, EventArgs.Empty);
		}

		#endregion
	}
}

```

`Aga.Controls/Tree/NodeControls/ExpandingIcon.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Threading;
using System.Windows.Forms;

namespace Aga.Controls.Tree.NodeControls
{
	/// <summary>
	/// Displays an animated icon for those nodes, who are in expanding state. 
	/// Parent TreeView must have AsyncExpanding property set to true.
	/// </summary>
	public class ExpandingIcon: NodeControl
	{
		private static GifDecoder _gif = ResourceHelper.LoadingIcon;
		private static int _index = 0;
		private static volatile Thread _animatingThread;
        private static object _lock = new object();

		public override Size MeasureSize(TreeNodeAdv node, DrawContext context)
		{
			return ResourceHelper.LoadingIcon.FrameSize;
		}

		protected override void OnIsVisibleValueNeeded(NodeControlValueEventArgs args)
		{
			args.Value = args.Node.IsExpandingNow;
			base.OnIsVisibleValueNeeded(args);
		}

		public override void Draw(TreeNodeAdv node, DrawContext context)
		{
			Rectangle rect = GetBounds(node, context);
			Image img = _gif.GetFrame(_index).Image;
			context.Graphics.DrawImage(img, rect.Location);
		}

		public static void Start()
		{
            lock (_lock)
            {
                if (_animatingThread == null)
                {
                    _index = 0;
                    _animatingThread = new Thread(new ThreadStart(IterateIcons));
                    _animatingThread.IsBackground = true;
                    _animatingThread.Priority = ThreadPriority.Lowest;
                    _animatingThread.Start();
                }
            }
		}

        public static void Stop()
        {
            lock (_lock)
            {
                _index = 0;
                _animatingThread = null;
            }
        }

		private static void IterateIcons()
		{
            while (_animatingThread != null)
			{
				if (_index < _gif.FrameCount - 1)
					_index++;
				else
					_index = 0;

				if (IconChanged != null)
					IconChanged(null, EventArgs.Empty);

				int delay = _gif.GetFrame(_index).Delay;
				Thread.Sleep(delay);
			}
            System.Diagnostics.Debug.WriteLine("IterateIcons Stopped");
		}

		public static event EventHandler IconChanged;
	}
}

```

`Aga.Controls/Tree/NodeControls/InteractiveControl.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.ComponentModel;

namespace Aga.Controls.Tree.NodeControls
{
	public abstract class InteractiveControl : BindableControl
	{
		private bool _editEnabled = false;
		[DefaultValue(false)]
		public bool EditEnabled
		{
			get { return _editEnabled; }
			set { _editEnabled = value; }
		}

		protected bool IsEditEnabled(TreeNodeAdv node)
		{
			if (EditEnabled)
			{
				NodeControlValueEventArgs args = new NodeControlValueEventArgs(node);
				args.Value = true;
				OnIsEditEnabledValueNeeded(args);
				return Convert.ToBoolean(args.Value);
			}
			else
				return false;
		}

		public event EventHandler<NodeControlValueEventArgs> IsEditEnabledValueNeeded;
		private void OnIsEditEnabledValueNeeded(NodeControlValueEventArgs args)
		{
			if (IsEditEnabledValueNeeded != null)
				IsEditEnabledValueNeeded(this, args);
		}
	}
}

```

`Aga.Controls/Tree/NodeControls/LabelEventArgs.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace Aga.Controls.Tree.NodeControls
{
	public class LabelEventArgs : EventArgs
	{
		private object _subject;
		public object Subject
		{
			get { return _subject; }
		}

		private string _oldLabel;
		public string OldLabel
		{
			get { return _oldLabel; }
		}

		private string _newLabel;
		public string NewLabel
		{
			get { return _newLabel; }
		}

		public LabelEventArgs(object subject, string oldLabel, string newLabel)
		{
			_subject = subject;
			_oldLabel = oldLabel;
			_newLabel = newLabel;
		}
	}
}

```

`Aga.Controls/Tree/NodeControls/NodeCheckBox.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using Aga.Controls.Properties;
using System.Reflection;
using System.Windows.Forms;
using System.Windows.Forms.VisualStyles;
using System.ComponentModel;

namespace Aga.Controls.Tree.NodeControls
{
	public class NodeCheckBox : InteractiveControl
	{
		public const int ImageSize = 13;

		private Bitmap _check;
		private Bitmap _uncheck;
		private Bitmap _unknown;

		#region Properties

		private bool _threeState;
		[DefaultValue(false)]
		public bool ThreeState
		{
			get { return _threeState; }
			set { _threeState = value; }
		}

		#endregion

		public NodeCheckBox()
			: this(string.Empty)
		{
		}

		public NodeCheckBox(string propertyName)
		{
			_check = Resources.check;
			_uncheck = Resources.uncheck;
			_unknown = Resources.unknown;
			DataPropertyName = propertyName;
			LeftMargin = 0;
		}

		public override Size MeasureSize(TreeNodeAdv node, DrawContext context)
		{
			int scaledX = node.Tree.GetScaledSize(ImageSize, false);
			int scaledY = node.Tree.GetScaledSize(ImageSize);
			return new Size(scaledX, scaledY);
		}

		public override void Draw(TreeNodeAdv node, DrawContext context)
		{
			Rectangle bounds = GetBounds(node, context);
			CheckState state = GetCheckState(node);
            if (TreeViewAdv.CustomCheckRenderFunc != null)
            {
                TreeViewAdv.CustomCheckRenderFunc(context.Graphics, bounds, state == CheckState.Checked);
            }
            else if (Application.RenderWithVisualStyles)
			{
				VisualStyleRenderer renderer;
				int scaledX = node.Tree.GetScaledSize(ImageSize, false);
				int scaledY = node.Tree.GetScaledSize(ImageSize);
				if (state == CheckState.Indeterminate)
					renderer = new VisualStyleRenderer(VisualStyleElement.Button.CheckBox.MixedNormal);
				else if (state == CheckState.Checked)
					renderer = new VisualStyleRenderer(VisualStyleElement.Button.CheckBox.CheckedNormal);
				else
					renderer = new VisualStyleRenderer(VisualStyleElement.Button.CheckBox.UncheckedNormal);
				renderer.DrawBackground(context.Graphics, new Rectangle(bounds.X, bounds.Y, scaledX, scaledY));
			}
			else
			{
				Image img;
				if (state == CheckState.Indeterminate)
					img = _unknown;
				else if (state == CheckState.Checked)
					img = _check;
				else
					img = _uncheck;
				context.Graphics.DrawImage(img, bounds.Location);
			}
		}

		protected virtual CheckState GetCheckState(TreeNodeAdv node)
		{
			object obj = GetValue(node);
			if (obj is CheckState)
				return (CheckState)obj;
			else if (obj is bool)
				return (bool)obj ? CheckState.Checked : CheckState.Unchecked;
			else
				return CheckState.Unchecked;
		}

		protected virtual void SetCheckState(TreeNodeAdv node, CheckState value)
		{
			if (VirtualMode)
			{
				SetValue(node, value);
				OnCheckStateChanged(node);
			}
			else
			{
				Type type = GetPropertyType(node);
				if (type == typeof(CheckState))
				{
					SetValue(node, value);
					OnCheckStateChanged(node);
				}
				else if (type == typeof(bool))
				{
					SetValue(node, value != CheckState.Unchecked);
					OnCheckStateChanged(node);
				}
			}
		}

		public override void MouseDown(TreeNodeAdvMouseEventArgs args)
		{
			if (args.Button == MouseButtons.Left && IsEditEnabled(args.Node))
			{
				DrawContext context = new DrawContext();
				context.Bounds = args.ControlBounds;
				Rectangle rect = GetBounds(args.Node, context);
				if (rect.Contains(args.ViewLocation))
				{
					CheckState state = GetCheckState(args.Node);
					state = GetNewState(state);
					SetCheckState(args.Node, state);
					Parent.UpdateView();
					args.Handled = true;
				}
			}
		}

		public override void MouseDoubleClick(TreeNodeAdvMouseEventArgs args)
		{
			args.Handled = true;
		}

		private CheckState GetNewState(CheckState state)
		{
			if (state == CheckState.Indeterminate)
				return CheckState.Unchecked;
			else if(state == CheckState.Unchecked)
				return CheckState.Checked;
			else 
				return ThreeState ? CheckState.Indeterminate : CheckState.Unchecked;
		}

		public override void KeyDown(KeyEventArgs args)
		{
			if (args.KeyCode == Keys.Space && EditEnabled)
			{
				Parent.BeginUpdate();
				try
				{
					if (Parent.CurrentNode != null)
					{
						CheckState value = GetNewState(GetCheckState(Parent.CurrentNode));
						foreach (TreeNodeAdv node in Parent.Selection)
							if (IsEditEnabled(node))
								SetCheckState(node, value);
					}
				}
				finally
				{
					Parent.EndUpdate();
				}
				args.Handled = true;
			}
		}

		public event EventHandler<TreePathEventArgs> CheckStateChanged;
		protected void OnCheckStateChanged(TreePathEventArgs args)
		{
			if (CheckStateChanged != null)
				CheckStateChanged(this, args);
		}

		protected void OnCheckStateChanged(TreeNodeAdv node)
		{
			TreePath path = this.Parent.GetPath(node);
			OnCheckStateChanged(new TreePathEventArgs(path));
		}

	}
}

```

`Aga.Controls/Tree/NodeControls/NodeComboBox.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Windows.Forms;
using System.Reflection;
using System.ComponentModel;
using System.Drawing.Design;

namespace Aga.Controls.Tree.NodeControls
{
	public class NodeComboBox : BaseTextControl
	{
		#region Properties

		private int _editorWidth = 100;
		[DefaultValue(100)]
		public int EditorWidth
		{
			get { return _editorWidth; }
			set { _editorWidth = value; }
		}

		private int _editorHeight = 100;
		[DefaultValue(100)]
		public int EditorHeight
		{
			get { return _editorHeight; }
			set { _editorHeight = value; }
		}

		private List<object> _dropDownItems;
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
		[Editor(typeof(StringCollectionEditor), typeof(UITypeEditor)), DesignerSerializationVisibility(DesignerSerializationVisibility.Content)]
		public List<object> DropDownItems
		{
			get { return _dropDownItems; }
		}

		#endregion

		public event EventHandler<EditEventArgs> CreatingEditor;

		public NodeComboBox()
		{
			_dropDownItems = new List<object>();
		}

		protected override Size CalculateEditorSize(EditorContext context)
		{
			if (Parent.UseColumns)
			{
				if (context.Editor is CheckedListBox)
					return new Size(context.Bounds.Size.Width, EditorHeight);
				else
					return context.Bounds.Size;
			}
			else
			{
				if (context.Editor is CheckedListBox)
					return new Size(EditorWidth, EditorHeight);
				else
					return new Size(EditorWidth, context.Bounds.Height);
			}
		}

		protected override Control CreateEditor(TreeNodeAdv node)
		{
			Control c;
			object value = GetValue(node);
			if (IsCheckedListBoxRequired(node))
				c = CreateCheckedListBox(node);
			else
				c = CreateCombo(node);
			OnCreatingEditor(new EditEventArgs(node, c));
			return c;
		}

		protected override void DisposeEditor(Control editor)
		{
		}

		protected virtual void OnCreatingEditor(EditEventArgs args)
		{
			if (CreatingEditor != null)
				CreatingEditor(this, args);
		}

		protected virtual bool IsCheckedListBoxRequired(TreeNodeAdv node)
		{
			object value = GetValue(node);
			if (value != null)
			{
				Type t = value.GetType();
				object[] arr = t.GetCustomAttributes(typeof(FlagsAttribute), false);
				return (t.IsEnum && arr.Length == 1);
			}
			return false;
		}

		private Control CreateCombo(TreeNodeAdv node)
		{
			ComboBox comboBox = new ComboBox();
			if (DropDownItems != null)
				comboBox.Items.AddRange(DropDownItems.ToArray());
			comboBox.SelectedItem = GetValue(node);
			comboBox.DropDownStyle = ComboBoxStyle.DropDownList;
			comboBox.DropDownClosed += new EventHandler(EditorDropDownClosed);
			SetEditControlProperties(comboBox, node);
			return comboBox;
		}

		private Control CreateCheckedListBox(TreeNodeAdv node)
		{
			CheckedListBox listBox = new CheckedListBox();
			listBox.CheckOnClick = true;

			object value = GetValue(node);
			Type enumType = GetEnumType(node);
			foreach (object obj in Enum.GetValues(enumType))
			{
				object[] attributes = enumType.GetField(obj.ToString()).GetCustomAttributes(typeof(BrowsableAttribute), false);
				if (attributes.Length == 0 || ((BrowsableAttribute)attributes[0]).Browsable)
					listBox.Items.Add(obj, IsContain(value, obj));
			}

			SetEditControlProperties(listBox, node);
			if (CreatingEditor != null)
				CreatingEditor(this, new EditEventArgs(node, listBox));
			return listBox;
		}

		protected virtual Type GetEnumType(TreeNodeAdv node)
		{
			object value = GetValue(node);
			return value.GetType();
		}

		private bool IsContain(object value, object enumElement)
		{
			if (value == null || enumElement == null)
				return false;
			if (value.GetType().IsEnum)
			{
				int i1 = (int)value;
				int i2 = (int)enumElement;
				return (i1 & i2) == i2;
			}
			else
			{
				var arr = value as object[];
				foreach (object obj in arr)
					if ((int)obj == (int)enumElement)
						return true;
				return false;
			}
		}

		protected override string FormatLabel(object obj)
		{
			var arr = obj as object[];
			if (arr != null)
			{
				StringBuilder sb = new StringBuilder();
				foreach (object t in arr)
				{
					if (sb.Length > 0)
						sb.Append(", ");
					sb.Append(t);
				}
				return sb.ToString();
			}
			else
				return base.FormatLabel(obj);
		}

		void EditorDropDownClosed(object sender, EventArgs e)
		{
			EndEdit(true);
		}

		public override void UpdateEditor(Control control)
		{
			if (control is ComboBox)
				(control as ComboBox).DroppedDown = true;
		}

		protected override void DoApplyChanges(TreeNodeAdv node, Control editor)
		{
			var combo = editor as ComboBox;
			if (combo != null)
			{
				if (combo.DropDownStyle == ComboBoxStyle.DropDown)
					SetValue(node, combo.Text);
				else
					SetValue(node, combo.SelectedItem);
			}
			else
			{
				var listBox = editor as CheckedListBox;
				Type type = GetEnumType(node);
				if (IsFlags(type))
				{
					int res = 0;
					foreach (object obj in listBox.CheckedItems)
						res |= (int)obj;
					object val = Enum.ToObject(type, res);
					SetValue(node, val);
				}
				else
				{
					List<object> list = new List<object>();
					foreach (object obj in listBox.CheckedItems)
						list.Add(obj);
					SetValue(node, list.ToArray());
				}
			}
		}

		private bool IsFlags(Type type)
		{
			object[] atr = type.GetCustomAttributes(typeof(FlagsAttribute), false);
			return atr.Length == 1;
		}

		public override void MouseUp(TreeNodeAdvMouseEventArgs args)
		{
			if (args.Node != null && args.Node.IsSelected) //Workaround of specific ComboBox control behavior
				base.MouseUp(args);
		}
	}
}

```

`Aga.Controls/Tree/NodeControls/NodeControl.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;
using System.Drawing;
using System.ComponentModel;

namespace Aga.Controls.Tree.NodeControls
{
	[DesignTimeVisible(false), ToolboxItem(false)]
	public abstract class NodeControl : Component
	{
		#region Properties

		private TreeViewAdv _parent;
		[Browsable(false)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public TreeViewAdv Parent
		{
			get { return _parent; }
			set 
			{
				if (value != _parent)
				{
					if (_parent != null)
						_parent.NodeControls.Remove(this);

					if (value != null)
						value.NodeControls.Add(this);
				}
			}
		}

		private IToolTipProvider _toolTipProvider;
		[Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public IToolTipProvider ToolTipProvider
		{
			get { return _toolTipProvider; }
			set { _toolTipProvider = value; }
		}

		private TreeColumn _parentColumn;
		public TreeColumn ParentColumn
		{
			get { return _parentColumn; }
			set 
			{ 
				_parentColumn = value; 
				if (_parent != null)
					_parent.FullUpdate();
			}
		}

		private VerticalAlignment _verticalAlign = VerticalAlignment.Center;
		[DefaultValue(VerticalAlignment.Center)]
		public VerticalAlignment VerticalAlign
		{
			get { return _verticalAlign; }
			set 
			{ 
				_verticalAlign = value;
				if (_parent != null)
					_parent.FullUpdate();
			}
		}

		private int _leftMargin = 0;
		public int LeftMargin
		{
			get { return _leftMargin; }
			set 
			{
				if (value < 0)
					throw new ArgumentOutOfRangeException();

				_leftMargin = value;
				if (_parent != null)
					_parent.FullUpdate();
			}
		}
		#endregion

		internal virtual void AssignParent(TreeViewAdv parent)
		{
			_parent = parent;
		}

		protected virtual Rectangle GetBounds(TreeNodeAdv node, DrawContext context)
		{
			Rectangle r = context.Bounds;
			Size s = GetActualSize(node, context);
			Size bs = new Size(r.Width - LeftMargin, Math.Min(r.Height, s.Height));
			switch (VerticalAlign)
			{
				case VerticalAlignment.Top:
					return new Rectangle(new Point(r.X + LeftMargin, r.Y), bs);
				case VerticalAlignment.Bottom:
					return new Rectangle(new Point(r.X + LeftMargin, r.Bottom - s.Height), bs);
				default:
					return new Rectangle(new Point(r.X + LeftMargin, r.Y + (r.Height - s.Height) / 2), bs);
			}
		}

		protected void CheckThread()
		{
			if (Parent != null && Control.CheckForIllegalCrossThreadCalls)
				if (Parent.InvokeRequired)
					throw new InvalidOperationException("Cross-thread calls are not allowed");
		}

		public bool IsVisible(TreeNodeAdv node)
		{
			NodeControlValueEventArgs args = new NodeControlValueEventArgs(node);
			args.Value = true;
			OnIsVisibleValueNeeded(args);
			return Convert.ToBoolean(args.Value);
		}

		internal Size GetActualSize(TreeNodeAdv node, DrawContext context)
		{
			if (IsVisible(node))
			{
				Size s = MeasureSize(node, context);
				return new Size(s.Width + LeftMargin, s.Height);
			}
			else
				return Size.Empty;
		}

		public abstract Size MeasureSize(TreeNodeAdv node, DrawContext context);

		public abstract void Draw(TreeNodeAdv node, DrawContext context);

		public virtual string GetToolTip(TreeNodeAdv node)
		{
			if (ToolTipProvider != null)
				return ToolTipProvider.GetToolTip(node, this);
			else
				return string.Empty;
		}

		public virtual void MouseDown(TreeNodeAdvMouseEventArgs args)
		{
		}

		public virtual void MouseUp(TreeNodeAdvMouseEventArgs args)
		{
		}

		public virtual void MouseDoubleClick(TreeNodeAdvMouseEventArgs args)
		{
		}

		public virtual void KeyDown(KeyEventArgs args)
		{
		}

		public virtual void KeyUp(KeyEventArgs args)
		{
		}

		public event EventHandler<NodeControlValueEventArgs> IsVisibleValueNeeded;
		protected virtual void OnIsVisibleValueNeeded(NodeControlValueEventArgs args)
		{
			if (IsVisibleValueNeeded != null)
				IsVisibleValueNeeded(this, args);
		}
	}
}

```

`Aga.Controls/Tree/NodeControls/NodeControlValueEventArgs.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace Aga.Controls.Tree.NodeControls
{
	public class NodeControlValueEventArgs : NodeEventArgs
	{
		private object _value;
		public object Value
		{
			get { return _value; }
			set { _value = value; }
		}

		public NodeControlValueEventArgs(TreeNodeAdv node)
			:base(node)
		{
		}
	}
}

```

`Aga.Controls/Tree/NodeControls/NodeControlsCollection.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.ComponentModel.Design;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Drawing.Design;

namespace Aga.Controls.Tree.NodeControls
{
	internal class NodeControlsCollection : Collection<NodeControl>
	{
		private TreeViewAdv _tree;

		public NodeControlsCollection(TreeViewAdv tree)
		{
			_tree = tree;
		}

		protected override void ClearItems()
		{
			_tree.BeginUpdate();
			try
			{
				while (this.Count != 0)
					this.RemoveAt(this.Count - 1);
			}
			finally
			{
				_tree.EndUpdate();
			}
		}

		protected override void InsertItem(int index, NodeControl item)
		{
			if (item == null)
				throw new ArgumentNullException("item");

			if (item.Parent != _tree)
			{
				if (item.Parent != null)
				{
					item.Parent.NodeControls.Remove(item);
				}
				base.InsertItem(index, item);
				item.AssignParent(_tree);
				_tree.FullUpdate();
			}
		}

		protected override void RemoveItem(int index)
		{
			NodeControl value = this[index];
			value.AssignParent(null);
			base.RemoveItem(index);
			_tree.FullUpdate();
		}

		protected override void SetItem(int index, NodeControl item)
		{
			if (item == null)
				throw new ArgumentNullException("item");

			_tree.BeginUpdate();
			try
			{
				RemoveAt(index);
				InsertItem(index, item);
			}
			finally
			{
				_tree.EndUpdate();
			}
		}
	}

	internal class NodeControlCollectionEditor : CollectionEditor
	{
		private Type[] _types;

		public NodeControlCollectionEditor(Type type)
			: base(type)
		{
			_types = new Type[] { typeof(NodeTextBox), typeof(NodeIntegerTextBox), typeof(NodeDecimalTextBox), 
				typeof(NodeComboBox), typeof(NodeCheckBox),
				typeof(NodeStateIcon), typeof(NodeIcon), typeof(NodeNumericUpDown), typeof(ExpandingIcon)  };
		}

		protected override System.Type[] CreateNewItemTypes()
		{
			return _types;
		}
	}
}

```

`Aga.Controls/Tree/NodeControls/NodeDecimalTextBox.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Windows.Forms;
using System.Reflection;
using System.ComponentModel; 
 
namespace Aga.Controls.Tree.NodeControls
{
	public class NodeDecimalTextBox : NodeTextBox
	{
		private bool _allowDecimalSeparator = true;
		[DefaultValue(true)]
		public bool AllowDecimalSeparator
		{
			get { return _allowDecimalSeparator; }
			set { _allowDecimalSeparator = value; }
		}

		private bool _allowNegativeSign = true;
		[DefaultValue(true)]
		public bool AllowNegativeSign
		{
			get { return _allowNegativeSign; }
			set { _allowNegativeSign = value; }
		}

		protected NodeDecimalTextBox()
		{
		}

		protected override TextBox CreateTextBox()
		{
			NumericTextBox textBox = new NumericTextBox();
			textBox.AllowDecimalSeparator = AllowDecimalSeparator;
			textBox.AllowNegativeSign = AllowNegativeSign;
			return textBox;
		}

		protected override void DoApplyChanges(TreeNodeAdv node, Control editor)
		{
			SetValue(node, (editor as NumericTextBox).DecimalValue);
		}
	}
}

```

`Aga.Controls/Tree/NodeControls/NodeEventArgs.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace Aga.Controls.Tree.NodeControls
{
	public class NodeEventArgs : EventArgs
	{
		private TreeNodeAdv _node;
		public TreeNodeAdv Node
		{
			get { return _node; }
		}

		public NodeEventArgs(TreeNodeAdv node)
		{
			_node = node;
		}
	}
}

```

`Aga.Controls/Tree/NodeControls/NodeIcon.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Windows.Forms;
using Aga.Controls.Properties;
using System.ComponentModel;

namespace Aga.Controls.Tree.NodeControls
{
	public class NodeIcon : BindableControl
	{
		public NodeIcon()
		{
			LeftMargin = 1;
		}

		public override Size MeasureSize(TreeNodeAdv node, DrawContext context)
		{
			Image image = GetIcon(node);
			if (image != null)
			{
				int scaledX = node.Tree.GetScaledSize(image.Size.Width, false);
				int scaledY = node.Tree.GetScaledSize(image.Size.Height);
				return new Size(scaledX, scaledY); ;
			}
			else
			{
				return Size.Empty;
			}
		}


		public override void Draw(TreeNodeAdv node, DrawContext context)
		{
			Image image = GetIcon(node);
			if (image != null)
			{
				Rectangle r = GetBounds(node, context);
				if ( image.Width > 0 && image.Height > 0 )
				{
					switch (_scaleMode)
					{
						case ImageScaleMode.Fit:
							context.Graphics.DrawImage(image, r);
							break;
						case ImageScaleMode.ScaleDown:
							{
								float factor = Math.Min((float)r.Width / (float)image.Width, (float)r.Height / (float)image.Height);
								if (factor < 1)
									context.Graphics.DrawImage(image, r.X, r.Y, image.Width * factor, image.Height * factor);
								else
									context.Graphics.DrawImage(image, r.X, r.Y, image.Width, image.Height);
							} break;
						case ImageScaleMode.ScaleUp:
							{
								float factor = Math.Max((float)r.Width / (float)image.Width, (float)r.Height / (float)image.Height);
								if (factor > 1)
									context.Graphics.DrawImage(image, r.X, r.Y, image.Width * factor, image.Height * factor);
								else
									context.Graphics.DrawImage(image, r.X, r.Y, image.Width, image.Height);
							} break;
						case ImageScaleMode.AlwaysScale:
							{
								float fx = (float)r.Width / (float)image.Width;
								float fy = (float)r.Height / (float)image.Height;
								if (Math.Min(fx, fy) < 1)
								{ //scale down
									float factor = Math.Min(fx, fy);
									context.Graphics.DrawImage(image, r.X, r.Y, image.Width * factor, image.Height * factor);
								}
								else if (Math.Max(fx, fy) > 1)
								{
									float factor = Math.Max(fx, fy);
									context.Graphics.DrawImage(image, r.X, r.Y, image.Width * factor, image.Height * factor);
								}
								else
									context.Graphics.DrawImage(image, r.X, r.Y, image.Width, image.Height);
							} break;
						case ImageScaleMode.Clip:
						default: 
							context.Graphics.DrawImage(image, r.X, r.Y, image.Width, image.Height);
							break;
					}
				}

			}
		}

		protected virtual Image GetIcon(TreeNodeAdv node)
		{
			return GetValue(node) as Image;
		}

        private ImageScaleMode _scaleMode = ImageScaleMode.Clip;
        [DefaultValue("Clip"), Category("Appearance")]
        public ImageScaleMode ScaleMode
        {
            get { return _scaleMode; }
            set { _scaleMode = value; }
        }


	}
}

```

`Aga.Controls/Tree/NodeControls/NodeIntegerTextBox.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.ComponentModel;
using System.Windows.Forms;

namespace Aga.Controls.Tree.NodeControls
{

	public class NodeIntegerTextBox : NodeTextBox
	{
		private bool _allowNegativeSign = true;
		[DefaultValue(true)]
		public bool AllowNegativeSign
		{
			get { return _allowNegativeSign; }
			set { _allowNegativeSign = value; }
		}

		public NodeIntegerTextBox()
		{
		}

		protected override TextBox CreateTextBox()
		{
			NumericTextBox textBox = new NumericTextBox();
			textBox.AllowDecimalSeparator = false;
			textBox.AllowNegativeSign = AllowNegativeSign;
			return textBox;
		}

		protected override void DoApplyChanges(TreeNodeAdv node, Control editor)
		{
			SetValue(node, (editor as NumericTextBox).IntValue);
		}
	}
}

```

`Aga.Controls/Tree/NodeControls/NodeNumericUpDown.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Windows.Forms;
using System.Reflection;
using System.ComponentModel;
using System.Drawing.Design;

namespace Aga.Controls.Tree.NodeControls
{
	public class NodeNumericUpDown : BaseTextControl
	{
		#region Properties

		private int _editorWidth = 100;
		[DefaultValue(100)]
		public int EditorWidth
		{
			get { return _editorWidth; }
			set { _editorWidth = value; }
		}

		private int _decimalPlaces = 0;
		[Category("Data"), DefaultValue(0)]
		public int DecimalPlaces
		{
			get
			{
				return this._decimalPlaces;
			}
			set
			{
				this._decimalPlaces = value;
			}
		}

		private decimal _increment = 1;
		[Category("Data"), DefaultValue(1)]
		public decimal Increment
		{
			get
			{
				return this._increment;
			}
			set
			{
				this._increment = value;
			}
		}

		private decimal _minimum = 0;
		[Category("Data"), DefaultValue(0)]
		public decimal Minimum
		{
			get
			{
				return _minimum;
			}
			set
			{
				_minimum = value;
			}
		}

		private decimal _maximum = 100;
		[Category("Data"), DefaultValue(100)]
		public decimal Maximum
		{
			get
			{
				return this._maximum;
			}
			set
			{
				this._maximum = value;
			}
		}

		#endregion

		public NodeNumericUpDown()
		{
		}

		protected override Size CalculateEditorSize(EditorContext context)
		{
			if (Parent.UseColumns)
				return context.Bounds.Size;
			else
				return new Size(EditorWidth, context.Bounds.Height);
		}

		protected override Control CreateEditor(TreeNodeAdv node)
		{
			NumericUpDown num = new NumericUpDown();
			num.Increment = Increment;
			num.DecimalPlaces = DecimalPlaces;
			num.Minimum = Minimum;
			num.Maximum = Maximum;
			num.Value = (decimal)GetValue(node);
			SetEditControlProperties(num, node);
			return num;
		}

		protected override void DisposeEditor(Control editor)
		{
		}

		protected override void DoApplyChanges(TreeNodeAdv node, Control editor)
		{
			SetValue(node, (editor as NumericUpDown).Value);
		}
	}
}

```

`Aga.Controls/Tree/NodeControls/NodePlusMinus.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using Aga.Controls.Properties;
using System.Windows.Forms;
using System.Windows.Forms.VisualStyles;

namespace Aga.Controls.Tree.NodeControls
{
	internal class NodePlusMinus : NodeControl
	{
		public const int ImageSize = 9;
		public const int Width = 16;
		private Bitmap _plus;
		private Bitmap _minus;

		private VisualStyleRenderer _openedRenderer;
		private VisualStyleRenderer OpenedRenderer
		{
			get
			{
				if (_openedRenderer == null)
					_openedRenderer = new VisualStyleRenderer(VisualStyleElement.TreeView.Glyph.Opened);
				return _openedRenderer;

			}
		}

		private VisualStyleRenderer _closedRenderer;
		private VisualStyleRenderer ClosedRenderer
		{
			get
			{
				if (_closedRenderer == null)
					_closedRenderer = new VisualStyleRenderer(VisualStyleElement.TreeView.Glyph.Closed);
				return _closedRenderer;
			}
		}

		public NodePlusMinus()
		{
			_plus = Resources.plus;
			_minus = Resources.minus;
		}

		public override Size MeasureSize(TreeNodeAdv node, DrawContext context)
		{
			int scaledX = node.Tree.GetScaledSize(Width, false);
			int scaledY = node.Tree.GetScaledSize(Width);
			return new Size(scaledX, scaledY);
		}

		public override void Draw(TreeNodeAdv node, DrawContext context)
		{
			if (node.CanExpand)
			{
				Rectangle r = context.Bounds;
				int scaledX = node.Tree.GetScaledSize(ImageSize, false);
				int scaledY = node.Tree.GetScaledSize(ImageSize);
				int dy = (int)Math.Round((float)(r.Height - scaledY) / 2);
                if (TreeViewAdv.CustomPlusMinusRenderFunc != null)
                {
                    TreeViewAdv.CustomPlusMinusRenderFunc(context.Graphics, r, node.IsExpanded);
                    return;
                }
                else if (Application.RenderWithVisualStyles)
				{
					VisualStyleRenderer renderer;
					if (node.IsExpanded)
						renderer = OpenedRenderer;
					else
						renderer = ClosedRenderer;
					renderer.DrawBackground(context.Graphics, new Rectangle(r.X, r.Y + dy, scaledX, scaledY));
				}
				else
				{
					Image img;
					if (node.IsExpanded)
						img = _minus;
					else
						img = _plus;
					context.Graphics.DrawImageUnscaled(img, new Point(r.X, r.Y + dy));
				}
			}
		}

		public override void MouseDown(TreeNodeAdvMouseEventArgs args)
		{
			if (args.Button == MouseButtons.Left)
			{
				args.Handled = true;
				if (args.Node.CanExpand)
					args.Node.IsExpanded = !args.Node.IsExpanded;
			}
		}

		public override void MouseDoubleClick(TreeNodeAdvMouseEventArgs args)
		{
			args.Handled = true; // Supress expand/collapse when double click on plus/minus
		}
	}
}

```

`Aga.Controls/Tree/NodeControls/NodeStateIcon.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using Aga.Controls.Properties;

namespace Aga.Controls.Tree.NodeControls
{
	public class NodeStateIcon: NodeIcon
	{
		private Image _leaf;
		private Image _opened;
		private Image _closed;

		public NodeStateIcon()
		{
			_leaf = MakeTransparent(Resources.Leaf);
			_opened = MakeTransparent(Resources.Folder);
			_closed = MakeTransparent(Resources.FolderClosed);
		}

		private static Image MakeTransparent(Bitmap bitmap)
		{
			bitmap.MakeTransparent(bitmap.GetPixel(0,0));
			return bitmap;
		}

		protected override Image GetIcon(TreeNodeAdv node)
		{
			Image icon = base.GetIcon(node);
			if (icon != null)
				return icon;
			else if (node.IsLeaf)
				return _leaf;
			else if (node.CanExpand && node.IsExpanded)
				return _opened;
			else
				return _closed;
		}
	}
}

```

`Aga.Controls/Tree/NodeControls/NodeTextBox.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Windows.Forms;
using System.Reflection;
using System.ComponentModel;

namespace Aga.Controls.Tree.NodeControls
{
	public class NodeTextBox : BaseTextControl
	{
		private const int MinTextBoxWidth = 30;

		public NodeTextBox()
		{
		}

		protected override Size CalculateEditorSize(EditorContext context)
		{
			if (Parent.UseColumns)
				return context.Bounds.Size;
			else
			{
				Size size = GetLabelSize(context.CurrentNode, context.DrawContext, _label);
				int width = Math.Max(size.Width + Font.Height, MinTextBoxWidth); // reserve a place for new typed character
				return new Size(width, size.Height);
			}
		}

		public override void KeyDown(KeyEventArgs args)
		{
			if (args.KeyCode == Keys.F2 && Parent.CurrentNode != null && EditEnabled)
			{
				args.Handled = true;
				BeginEdit();
			}
		}

		protected override Control CreateEditor(TreeNodeAdv node)
		{
			TextBox textBox = CreateTextBox();
			textBox.TextAlign = TextAlign;
			textBox.Text = GetLabel(node);
			textBox.BorderStyle = BorderStyle.FixedSingle;
			textBox.TextChanged += EditorTextChanged;
			textBox.KeyDown += EditorKeyDown;
			_label = textBox.Text;
			SetEditControlProperties(textBox, node);
			return textBox;
		}

		protected virtual TextBox CreateTextBox()
		{
			return new TextBox();
		}

		protected override void DisposeEditor(Control editor)
		{
			var textBox = editor as TextBox;
			textBox.TextChanged -= EditorTextChanged;
			textBox.KeyDown -= EditorKeyDown;
		}

		private void EditorKeyDown(object sender, KeyEventArgs e)
		{
			if (e.KeyCode == Keys.Escape)
				EndEdit(false);
			else if (e.KeyCode == Keys.Enter)
				EndEdit(true);
		}

		private string _label;
		private void EditorTextChanged(object sender, EventArgs e)
		{
			var textBox = sender as TextBox;
			_label = textBox.Text;
			Parent.UpdateEditorBounds();
		}

		protected override void DoApplyChanges(TreeNodeAdv node, Control editor)
		{
			var label = (editor as TextBox).Text;
			string oldLabel = GetLabel(node);
			if (oldLabel != label)
			{
				SetLabel(node, label);
				OnLabelChanged(node.Tag, oldLabel, label);
			}
		}

		public override void Cut(Control control)
		{
			(control as TextBox).Cut();
		}

		public override void Copy(Control control)
		{
			(control as TextBox).Copy();
		}

		public override void Paste(Control control)
		{
			(control as TextBox).Paste();
		}

		public override void Delete(Control control)
		{
			var textBox = control as TextBox;
			int len = Math.Max(textBox.SelectionLength, 1);
			if (textBox.SelectionStart < textBox.Text.Length)
			{
				int start = textBox.SelectionStart;
				textBox.Text = textBox.Text.Remove(textBox.SelectionStart, len);
				textBox.SelectionStart = start;
			}
		}

		public event EventHandler<LabelEventArgs> LabelChanged;
		protected void OnLabelChanged(object subject, string oldLabel, string newLabel)
		{
			if (LabelChanged != null)
				LabelChanged(this, new LabelEventArgs(subject, oldLabel, newLabel));
		}
	}
}

```

`Aga.Controls/Tree/SortedTreeModel.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Collections;

namespace Aga.Controls.Tree
{
	public class SortedTreeModel: TreeModelBase
	{
		private ITreeModel _innerModel;
		public ITreeModel InnerModel
		{
			get { return _innerModel; }
		}

		private IComparer _comparer;
		public IComparer Comparer
		{
			get { return _comparer; }
			set 
			{ 
				_comparer = value;
				OnStructureChanged(new TreePathEventArgs(TreePath.Empty));
			}
		}

		public SortedTreeModel(ITreeModel innerModel)
		{
			_innerModel = innerModel;
			_innerModel.NodesChanged += new EventHandler<TreeModelEventArgs>(_innerModel_NodesChanged);
			_innerModel.NodesInserted += new EventHandler<TreeModelEventArgs>(_innerModel_NodesInserted);
			_innerModel.NodesRemoved += new EventHandler<TreeModelEventArgs>(_innerModel_NodesRemoved);
			_innerModel.StructureChanged += new EventHandler<TreePathEventArgs>(_innerModel_StructureChanged);
		}

		void _innerModel_StructureChanged(object sender, TreePathEventArgs e)
		{
			OnStructureChanged(e);
		}

		void _innerModel_NodesRemoved(object sender, TreeModelEventArgs e)
		{
			OnStructureChanged(new TreePathEventArgs(e.Path));
		}

		void _innerModel_NodesInserted(object sender, TreeModelEventArgs e)
		{
			OnStructureChanged(new TreePathEventArgs(e.Path));
		}

		void _innerModel_NodesChanged(object sender, TreeModelEventArgs e)
		{
			OnStructureChanged(new TreePathEventArgs(e.Path));
		}

		public override IEnumerable GetChildren(TreePath treePath)
		{
			if (Comparer != null)
			{
				ArrayList list = new ArrayList();
				IEnumerable res = InnerModel.GetChildren(treePath);
				if (res != null)
				{
					foreach (object obj in res)
						list.Add(obj);
					list.Sort(Comparer);
					return list;
				}
				else
					return null;
			}
			else
				return InnerModel.GetChildren(treePath);
		}

		public override bool IsLeaf(TreePath treePath)
		{
			return InnerModel.IsLeaf(treePath);
		}
	}
}

```

`Aga.Controls/Tree/TreeColumn.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.ComponentModel;
using System.Windows.Forms;
using System.Drawing;
using System.Windows.Forms.VisualStyles;
using System.Drawing.Imaging;

namespace Aga.Controls.Tree
{
	[TypeConverter(typeof(TreeColumn.TreeColumnConverter)), DesignTimeVisible(false), ToolboxItem(false)]
	public class TreeColumn : Component
	{
		private class TreeColumnConverter : ComponentConverter
		{
			public TreeColumnConverter()
				: base(typeof(TreeColumn))
			{
			}

			public override bool GetPropertiesSupported(ITypeDescriptorContext context)
			{
				return false;
			}
		}

		private const int HeaderLeftMargin = 5;
        private const int HeaderRightMargin = 5;   
		private const int SortOrderMarkMargin = 8;

        private TextFormatFlags _headerFlags;
        private TextFormatFlags _baseHeaderFlags = TextFormatFlags.NoPadding | 
                                                   TextFormatFlags.EndEllipsis |
                                                   TextFormatFlags.VerticalCenter |
												TextFormatFlags.PreserveGraphicsTranslateTransform;

		#region Properties

        private TreeColumnCollection _owner;
		internal TreeColumnCollection Owner
		{
			get { return _owner; }
			set { _owner = value; }
		}

		[Browsable(false)]
		public int Index
		{
			get 
			{
				if (Owner != null)
					return Owner.IndexOf(this);
				else
					return -1;
			}
		}

		private string _header;
		[Localizable(true)]
		public string Header
		{
			get { return _header; }
			set 
			{ 
				_header = value;
				OnHeaderChanged();
			}
		}

		private string _tooltipText;
		[Localizable(true)]
		public string TooltipText
		{
			get { return _tooltipText; }
			set { _tooltipText = value; }
		}

		private int _width;
		[DefaultValue(50), Localizable(true)]
		public int Width
		{
			get
            {
                return _width;
            }
			set 
			{
				if (_width != value)
				{
                    _width = Math.Max(MinColumnWidth, value);
                    if (_maxColumnWidth > 0)
                    {
                        _width = Math.Min(_width, MaxColumnWidth);
                    }
					OnWidthChanged();
				}
			}
		}

        private int _minColumnWidth;
        [DefaultValue(0)]
        public int MinColumnWidth
        {
            get { return _minColumnWidth; }
            set
            {
				if (value < 0)
					throw new ArgumentOutOfRangeException("value");

				_minColumnWidth = value;
                Width = Math.Max(value, Width);
            }
        }

        private int _maxColumnWidth;
        [DefaultValue(0)]
        public int MaxColumnWidth
        {
            get { return _maxColumnWidth; }
            set
            {
				if (value < 0)
					throw new ArgumentOutOfRangeException("value");

				_maxColumnWidth = value;
				if (value > 0)
					Width = Math.Min(value, _width);
            }
        }

		private bool _visible = true;
		[DefaultValue(true)]
		public bool IsVisible
		{
			get { return _visible; }
			set 
			{ 
				_visible = value;
				OnIsVisibleChanged();
			}
		}

		private HorizontalAlignment _textAlign = HorizontalAlignment.Left;
		[DefaultValue(HorizontalAlignment.Left)]
		public HorizontalAlignment TextAlign
		{
			get { return _textAlign; }
			set 
			{
				if (value != _textAlign)
				{
					_textAlign = value;
                    _headerFlags = _baseHeaderFlags | TextHelper.TranslateAligmentToFlag(value);
					OnHeaderChanged();
				}
			}
		}

        private bool _sortable = false;
        [DefaultValue(false)]
        public bool Sortable
        {
            get { return _sortable; }
            set { _sortable = value; }
        }

		private SortOrder _sort_order = SortOrder.None;
		public SortOrder SortOrder
		{
			get { return _sort_order; }
			set
			{
				if (value == _sort_order)
					return;
				_sort_order = value;
				OnSortOrderChanged();
			}
		}

		public Size SortMarkSize
		{
			get
			{
				if (Application.RenderWithVisualStyles)
					return new Size(9, 5);
				else
					return new Size(7, 4);
			}
		}
		#endregion

		public TreeColumn(): 
			this(string.Empty, 50)
		{
		}

        public TreeColumn(string header, int width)
		{
			_header = header;
			_width = width;
            _headerFlags = _baseHeaderFlags | TextFormatFlags.Left;
		}

		public override string ToString()
		{
			if (string.IsNullOrEmpty(Header))
				return GetType().Name;
			else
				return Header;
		}

		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
		}

		#region Draw

		private static VisualStyleRenderer _normalRenderer;
		private static VisualStyleRenderer _pressedRenderer;
		private static VisualStyleRenderer _hotRenderer;

		private static void CreateRenderers()
		{
			if (Application.RenderWithVisualStyles && _normalRenderer == null)
			{
				_normalRenderer = new VisualStyleRenderer(VisualStyleElement.Header.Item.Normal);
				_pressedRenderer = new VisualStyleRenderer(VisualStyleElement.Header.Item.Pressed);
				_hotRenderer = new VisualStyleRenderer(VisualStyleElement.Header.Item.Hot);
			}
		}

		internal Bitmap CreateGhostImage(Rectangle bounds, Font font)
		{
			Bitmap b = new Bitmap(bounds.Width, bounds.Height, PixelFormat.Format32bppArgb);
			Graphics gr = Graphics.FromImage(b);
			gr.FillRectangle(SystemBrushes.ControlDark, bounds);
			DrawContent(gr, bounds, font);
			BitmapHelper.SetAlphaChanelValue(b, 150);
			return b;
		}

		internal void Draw(Graphics gr, Rectangle bounds, Font font, bool pressed, bool hot)
		{
			DrawBackground(gr, bounds, pressed, hot);
			DrawContent(gr, bounds, font);
		}

        private void DrawContent(Graphics gr, Rectangle bounds, Font font)
        {
            if (TreeViewAdv.CustomColumnTextRenderFunc != null)
            {
                TreeViewAdv.CustomColumnTextRenderFunc(gr, bounds, font, Header);
            }
            else
            {
                Rectangle innerBounds = new Rectangle(bounds.X + HeaderLeftMargin, bounds.Y,
                                       bounds.Width - HeaderLeftMargin - HeaderRightMargin,
                                       bounds.Height);

                if (SortOrder != SortOrder.None)
                    innerBounds.Width -= (SortMarkSize.Width + SortOrderMarkMargin);

                Size maxTextSize = TextRenderer.MeasureText(gr, Header, font, innerBounds.Size, TextFormatFlags.NoPadding);
                Size textSize = TextRenderer.MeasureText(gr, Header, font, innerBounds.Size, _baseHeaderFlags);

                if (SortOrder != SortOrder.None)
                {
                    int tw = Math.Min(textSize.Width, innerBounds.Size.Width);

                    int x = 0;
                    if (TextAlign == HorizontalAlignment.Left)
                        x = innerBounds.X + tw + SortOrderMarkMargin;
                    else if (TextAlign == HorizontalAlignment.Right)
                        x = innerBounds.Right + SortOrderMarkMargin;
                    else
                        x = innerBounds.X + tw + (innerBounds.Width - tw) / 2 + SortOrderMarkMargin;
                    DrawSortMark(gr, bounds, x);
                }

                if (textSize.Width < maxTextSize.Width)
                    TextRenderer.DrawText(gr, Header, font, innerBounds, SystemColors.ControlText, _baseHeaderFlags | TextFormatFlags.Left);
                else
                    TextRenderer.DrawText(gr, Header, font, innerBounds, SystemColors.ControlText, _headerFlags);
            }
        }

		private void DrawSortMark(Graphics gr, Rectangle bounds, int x)
		{
			int y = bounds.Y + bounds.Height / 2 - 2;
			x = Math.Max(x, bounds.X + SortOrderMarkMargin);

            int w2 = SortMarkSize.Width / 2;
            if (SortOrder == SortOrder.Ascending)
            {
                Point[] points = new Point[] { new Point(x, y), new Point(x + SortMarkSize.Width, y), new Point(x + w2, y + SortMarkSize.Height) };
                gr.FillPolygon(SystemBrushes.ControlDark, points);
            }
            else if (SortOrder == SortOrder.Descending)
            {
                Point[] points = new Point[] { new Point(x - 1, y + SortMarkSize.Height), new Point(x + SortMarkSize.Width, y + SortMarkSize.Height), new Point(x + w2, y - 1) };
                gr.FillPolygon(SystemBrushes.ControlDark, points);
            }
		}

		internal static void DrawDropMark(Graphics gr, Rectangle rect)
		{
			gr.FillRectangle(SystemBrushes.HotTrack, rect.X-1, rect.Y, 2, rect.Height);
		}

		internal static void DrawBackground(Graphics gr, Rectangle bounds, bool pressed, bool hot)
		{
            if (TreeViewAdv.CustomColumnBackgroundRenderFunc != null)
            {
                TreeViewAdv.CustomColumnBackgroundRenderFunc(gr, bounds, pressed, hot);
            }
            else
            {
                if (Application.RenderWithVisualStyles)
                {
                    CreateRenderers();
                    if (pressed)
                        _pressedRenderer.DrawBackground(gr, bounds);
                    else if (hot)
                        _hotRenderer.DrawBackground(gr, bounds);
                    else
                        _normalRenderer.DrawBackground(gr, bounds);
                }
                else
                {
                    gr.FillRectangle(SystemBrushes.Control, bounds);
                    Pen p1 = SystemPens.ControlLightLight;
                    Pen p2 = SystemPens.ControlDark;
                    Pen p3 = SystemPens.ControlDarkDark;
                    if (pressed)
                        gr.DrawRectangle(p2, bounds.X, bounds.Y, bounds.Width, bounds.Height);
                    else
                    {
                        gr.DrawLine(p1, bounds.X, bounds.Y, bounds.Right, bounds.Y);
                        gr.DrawLine(p3, bounds.X, bounds.Bottom, bounds.Right, bounds.Bottom);
                        gr.DrawLine(p3, bounds.Right - 1, bounds.Y, bounds.Right - 1, bounds.Bottom - 1);
                        gr.DrawLine(p1, bounds.Left, bounds.Y + 1, bounds.Left, bounds.Bottom - 2);
                        gr.DrawLine(p2, bounds.Right - 2, bounds.Y + 1, bounds.Right - 2, bounds.Bottom - 2);
                        gr.DrawLine(p2, bounds.X, bounds.Bottom - 1, bounds.Right - 2, bounds.Bottom - 1);
                    }
                }
            }
		}

		#endregion

		#region Events

		public event EventHandler HeaderChanged;
		private void OnHeaderChanged()
		{
			if (HeaderChanged != null)
				HeaderChanged(this, EventArgs.Empty);
		}

		public event EventHandler SortOrderChanged;
		private void OnSortOrderChanged()
		{
			if (SortOrderChanged != null)
				SortOrderChanged(this, EventArgs.Empty);
		}

		public event EventHandler IsVisibleChanged;
		private void OnIsVisibleChanged()
		{
			if (IsVisibleChanged != null)
				IsVisibleChanged(this, EventArgs.Empty);
		}

		public event EventHandler WidthChanged;
		private void OnWidthChanged()
		{
			if (WidthChanged != null)
				WidthChanged(this, EventArgs.Empty);
		}

		#endregion
	}
}

```

`Aga.Controls/Tree/TreeColumnCollection.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Windows.Forms;

namespace Aga.Controls.Tree
{
	internal class TreeColumnCollection : Collection<TreeColumn>
	{
		private TreeViewAdv _treeView;

		public TreeColumnCollection(TreeViewAdv treeView)
		{
			_treeView = treeView;
		}

		protected override void InsertItem(int index, TreeColumn item)
		{
			base.InsertItem(index, item);
			BindEvents(item);
			_treeView.UpdateColumns();
		}

		protected override void RemoveItem(int index)
		{
			UnbindEvents(this[index]);
			base.RemoveItem(index);
			_treeView.UpdateColumns();
		}

		protected override void SetItem(int index, TreeColumn item)
		{
			UnbindEvents(this[index]);
			base.SetItem(index, item);
			item.Owner = this;
			BindEvents(item);
			_treeView.UpdateColumns();
		}

		protected override void ClearItems()
		{
			foreach (TreeColumn c in Items)
				UnbindEvents(c);
			Items.Clear();
			_treeView.UpdateColumns();
		}

		private void BindEvents(TreeColumn item)
		{
			item.Owner = this;
			item.HeaderChanged += HeaderChanged;
			item.IsVisibleChanged += IsVisibleChanged;
			item.WidthChanged += WidthChanged;
			item.SortOrderChanged += SortOrderChanged;
		}

		private void UnbindEvents(TreeColumn item)
		{
			item.Owner = null;
			item.HeaderChanged -= HeaderChanged;
			item.IsVisibleChanged -= IsVisibleChanged;
			item.WidthChanged -= WidthChanged;
			item.SortOrderChanged -= SortOrderChanged;
		}

		void SortOrderChanged(object sender, EventArgs e)
		{
			TreeColumn changed = sender as TreeColumn;
			//Only one column at a time can have a sort property set
			if (changed.SortOrder != SortOrder.None)
			{
				foreach (TreeColumn col in this)
				{
					if (col != changed)
						col.SortOrder = SortOrder.None;
				}
			}
			_treeView.UpdateHeaders();
		}

		void WidthChanged(object sender, EventArgs e)
		{
			_treeView.ChangeColumnWidth(sender as TreeColumn);
		}

		void IsVisibleChanged(object sender, EventArgs e)
		{
			_treeView.FullUpdate();
		}

		void HeaderChanged(object sender, EventArgs e)
		{
			_treeView.UpdateView();
		}
	}
}

```

`Aga.Controls/Tree/TreeColumnEventArgs.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace Aga.Controls.Tree
{
	public class TreeColumnEventArgs: EventArgs
	{
		private TreeColumn _column;
		public TreeColumn Column
		{
			get { return _column; }
		}

		public TreeColumnEventArgs(TreeColumn column)
		{
			_column = column;
		}
	}
}

```

`Aga.Controls/Tree/TreeListAdapter.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace Aga.Controls.Tree
{
	/// <summary>
	/// Converts IEnumerable interface to ITreeModel. 
	/// Allows to display a plain list in the TreeView
	/// </summary>
	public class TreeListAdapter : ITreeModel
	{
		private System.Collections.IEnumerable _list;

		public TreeListAdapter(System.Collections.IEnumerable list)
		{
			_list = list;
		}

		#region ITreeModel Members

		public System.Collections.IEnumerable GetChildren(TreePath treePath)
		{
			if (treePath.IsEmpty())
				return _list;
			else
				return null;
		}

		public bool IsLeaf(TreePath treePath)
		{
			return true;
		}

		public event EventHandler<TreeModelEventArgs> NodesChanged;
		public void OnNodesChanged(TreeModelEventArgs args)
		{
			if (NodesChanged != null)
				NodesChanged(this, args);
		}

		public event EventHandler<TreePathEventArgs> StructureChanged;
		public void OnStructureChanged(TreePathEventArgs args)
		{
			if (StructureChanged != null)
				StructureChanged(this, args);
		}

		public event EventHandler<TreeModelEventArgs> NodesInserted;
		public void OnNodeInserted(TreeModelEventArgs args)
		{
			if (NodesInserted != null)
				NodesInserted(this, args);
		}

		public event EventHandler<TreeModelEventArgs> NodesRemoved;
		public void OnNodeRemoved(TreeModelEventArgs args)
		{
			if (NodesRemoved != null)
				NodesRemoved(this, args);
		}

		#endregion
	}
}

```

`Aga.Controls/Tree/TreeModel.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Collections.ObjectModel;

namespace Aga.Controls.Tree
{
	/// <summary>
	/// Provides a simple ready to use implementation of <see cref="ITreeModel"/>. Warning: this class is not optimized 
	/// to work with big amount of data. In this case create you own implementation of <c>ITreeModel</c>, and pay attention
	/// on GetChildren and IsLeaf methods.
	/// </summary>
	public class TreeModel : ITreeModel
	{
		private Node _root;
		public Node Root
		{
			get { return _root; }
		}

		public Collection<Node> Nodes
		{
			get { return _root.Nodes; }
		}

		public TreeModel()
		{
			_root = new Node();
			_root.Model = this;
		}

		public TreePath GetPath(Node node)
		{
			if (node == _root)
				return TreePath.Empty;
			else
			{
				Stack<object> stack = new Stack<object>();
				while (node != _root)
				{
					stack.Push(node);
					node = node.Parent;
				}
				return new TreePath(stack.ToArray());
			}
		}

		public Node FindNode(TreePath path)
		{
			if (path.IsEmpty())
				return _root;
			else
				return FindNode(_root, path, 0);
		}

		private Node FindNode(Node root, TreePath path, int level)
		{
			foreach (Node node in root.Nodes)
				if (node == path.FullPath[level])
				{
					if (level == path.FullPath.Length - 1)
						return node;
					else
						return FindNode(node, path, level + 1);
				}
			return null;
		}

		#region ITreeModel Members

		public System.Collections.IEnumerable GetChildren(TreePath treePath)
		{
			Node node = FindNode(treePath);
			if (node != null)
				foreach (Node n in node.Nodes)
					yield return n;
			else
				yield break;
		}

		public bool IsLeaf(TreePath treePath)
		{
			Node node = FindNode(treePath);
			if (node != null)
				return node.IsLeaf;
			else
				throw new ArgumentException("treePath");
		}

		public event EventHandler<TreeModelEventArgs> NodesChanged;
		internal void OnNodesChanged(TreeModelEventArgs args)
		{
			if (NodesChanged != null)
				NodesChanged(this, args);
		}

		public event EventHandler<TreePathEventArgs> StructureChanged;
		public void OnStructureChanged(TreePathEventArgs args)
		{
			if (StructureChanged != null)
				StructureChanged(this, args);
		}

		public event EventHandler<TreeModelEventArgs> NodesInserted;
		internal void OnNodeInserted(Node parent, int index, Node node)
		{
			if (NodesInserted != null)
			{
				TreeModelEventArgs args = new TreeModelEventArgs(GetPath(parent), new int[] { index }, new object[] { node });
				NodesInserted(this, args);
			}

		}

		public event EventHandler<TreeModelEventArgs> NodesRemoved;
		internal void OnNodeRemoved(Node parent, int index, Node node)
		{
			if (NodesRemoved != null)
			{
				TreeModelEventArgs args = new TreeModelEventArgs(GetPath(parent), new int[] { index }, new object[] { node });
				NodesRemoved(this, args);
			}
		}

		#endregion
	}
}

```

`Aga.Controls/Tree/TreeModelBase.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace Aga.Controls.Tree
{
	public abstract class TreeModelBase: ITreeModel
	{
		public abstract System.Collections.IEnumerable GetChildren(TreePath treePath);
		public abstract bool IsLeaf(TreePath treePath);


		public event EventHandler<TreeModelEventArgs> NodesChanged;
		protected void OnNodesChanged(TreeModelEventArgs args)
		{
			if (NodesChanged != null)
				NodesChanged(this, args);
		}

		public event EventHandler<TreePathEventArgs> StructureChanged;
		protected void OnStructureChanged(TreePathEventArgs args)
		{
			if (StructureChanged != null)
				StructureChanged(this, args);
		}

		public event EventHandler<TreeModelEventArgs> NodesInserted;
		protected void OnNodesInserted(TreeModelEventArgs args)
		{
			if (NodesInserted != null)
				NodesInserted(this, args);
		}

		public event EventHandler<TreeModelEventArgs> NodesRemoved;
		protected void OnNodesRemoved(TreeModelEventArgs args)
		{
			if (NodesRemoved != null)
				NodesRemoved(this, args);
		}

		public virtual void Refresh()
		{
			OnStructureChanged(new TreePathEventArgs(TreePath.Empty));
		}
	}
}

```

`Aga.Controls/Tree/TreeModelEventArgs.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace Aga.Controls.Tree
{
	public class TreeModelEventArgs: TreePathEventArgs
	{
		private object[] _children;
		public object[] Children
		{
			get { return _children; }
		}

		private int[] _indices;
		public int[] Indices
		{
			get { return _indices; }
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="parent">Path to a parent node</param>
		/// <param name="children">Child nodes</param>
		public TreeModelEventArgs(TreePath parent, object[] children)
			: this(parent, null, children)
		{
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="parent">Path to a parent node</param>
		/// <param name="indices">Indices of children in parent nodes collection</param>
		/// <param name="children">Child nodes</param>
		public TreeModelEventArgs(TreePath parent, int[] indices, object[] children)
			: base(parent)
		{
			if (children == null)
				throw new ArgumentNullException();

			if (indices != null && indices.Length != children.Length)
				throw new ArgumentException("indices and children arrays must have the same length");

			_indices = indices;
			_children = children;
		}
	}
}

```

`Aga.Controls/Tree/TreeNodeAdv.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using System.Security.Permissions;

namespace Aga.Controls.Tree
{
	[Serializable]
	public sealed class TreeNodeAdv : ISerializable
	{
		#region NodeCollection
		private class NodeCollection : Collection<TreeNodeAdv>
		{
			private TreeNodeAdv _owner;

			public NodeCollection(TreeNodeAdv owner)
			{
				_owner = owner;
			}

			protected override void ClearItems()
			{
				while (this.Count != 0)
					this.RemoveAt(this.Count - 1);
			}

			protected override void InsertItem(int index, TreeNodeAdv item)
			{
				if (item == null)
					throw new ArgumentNullException("item");

				if (item.Parent != _owner)
				{
					if (item.Parent != null)
						item.Parent.Nodes.Remove(item);
					item._parent = _owner;
					item._index = index;
					for (int i = index; i < Count; i++)
						this[i]._index++;
					base.InsertItem(index, item);
				}

				if (_owner.Tree != null && _owner.Tree.Model == null)
				{
					_owner.Tree.SmartFullUpdate();
				}
			}

			protected override void RemoveItem(int index)
			{
				TreeNodeAdv item = this[index];
				item._parent = null;
				item._index = -1;
				for (int i = index + 1; i < Count; i++)
					this[i]._index--;
				base.RemoveItem(index);

				if (_owner.Tree != null && _owner.Tree.Model == null)
				{
					_owner.Tree.UpdateSelection();
					_owner.Tree.SmartFullUpdate();
				}
			}

			protected override void SetItem(int index, TreeNodeAdv item)
			{
				if (item == null)
					throw new ArgumentNullException("item");
				RemoveAt(index);
				InsertItem(index, item);
			}
		}
		#endregion

		#region Events

		public event EventHandler<TreeViewAdvEventArgs> Collapsing;
		internal void OnCollapsing()
		{
			if (Collapsing != null)
				Collapsing(this, new TreeViewAdvEventArgs(this));
		}

		public event EventHandler<TreeViewAdvEventArgs> Collapsed;
		internal void OnCollapsed()
		{
			if (Collapsed != null)
				Collapsed(this, new TreeViewAdvEventArgs(this));
		}

		public event EventHandler<TreeViewAdvEventArgs> Expanding;
		internal void OnExpanding()
		{
			if (Expanding != null)
				Expanding(this, new TreeViewAdvEventArgs(this));
		}

		public event EventHandler<TreeViewAdvEventArgs> Expanded;
		internal void OnExpanded()
		{
			if (Expanded != null)
				Expanded(this, new TreeViewAdvEventArgs(this));
		}

		#endregion

		#region Properties

		private TreeViewAdv _tree;
		public TreeViewAdv Tree
		{
			get { return _tree; }
		}

		private int _row;
		public int Row
		{
			get { return _row; }
			internal set { _row = value; }
		}

		private int _index = -1;
		public int Index
		{
			get
			{
				return _index;
			}
		}

		private bool _isSelected;
		public bool IsSelected
		{
			get { return _isSelected; }
			set
			{
				if (_isSelected != value)
				{
					if (Tree.IsMyNode(this))
					{
						//_tree.OnSelectionChanging
						if (value)
						{
							if (!_tree.Selection.Contains(this))
								_tree.Selection.Add(this);

							if (_tree.Selection.Count == 1)
								_tree.CurrentNode = this;
						}
						else
							_tree.Selection.Remove(this);
						_tree.UpdateView();
						_tree.OnSelectionChanged();
					}
					_isSelected = value;
				}
			}
		}

		/// <summary>
		/// Returns true if all parent nodes of this node are expanded.
		/// </summary>
		internal bool IsVisible
		{
			get
			{
				TreeNodeAdv node = _parent;
				while (node != null)
				{
					if (!node.IsExpanded)
						return false;
					node = node.Parent;
				}
				return true;
			}
		}

		private bool _isLeaf;
		public bool IsLeaf
		{
			get { return _isLeaf; }
			internal set { _isLeaf = value; }
		}

		private bool _isExpandedOnce;
		public bool IsExpandedOnce
		{
			get { return _isExpandedOnce; }
			internal set { _isExpandedOnce = value; }
		}

		private bool _isExpanded;
		public bool IsExpanded
		{
			get { return _isExpanded; }
			set
			{
				if (value)
					Expand();
				else
					Collapse();
			}
		}

		internal void AssignIsExpanded(bool value)
		{
			_isExpanded = value;
		}

		private TreeNodeAdv _parent;
		public TreeNodeAdv Parent
		{
			get { return _parent; }
		}

		public int Level
		{
			get
			{
				if (_parent == null)
					return 0;
				else
					return _parent.Level + 1;
			}
		}

		public TreeNodeAdv PreviousNode
		{
			get
			{
				if (_parent != null)
				{
					int index = Index;
					if (index > 0)
						return _parent.Nodes[index - 1];
				}
				return null;
			}
		}

		public TreeNodeAdv NextNode
		{
			get
			{
				if (_parent != null)
				{
					int index = Index;
					if (index < _parent.Nodes.Count - 1)
						return _parent.Nodes[index + 1];
				}
				return null;
			}
		}

		internal TreeNodeAdv BottomNode
		{
			get
			{
				TreeNodeAdv parent = this.Parent;
				if (parent != null)
				{
					if (parent.NextNode != null)
						return parent.NextNode;
					else
						return parent.BottomNode;
				}
				return null;
			}
		}

		internal TreeNodeAdv NextVisibleNode
		{
			get
			{
				if (IsExpanded && Nodes.Count > 0)
					return Nodes[0];
				else
				{
					TreeNodeAdv nn = NextNode;
					if (nn != null)
						return nn;
					else
						return BottomNode;
				}
			}
		}

		public bool CanExpand
		{
			get
			{
				return (Nodes.Count > 0 || (!IsExpandedOnce && !IsLeaf));
			}
		}

		private object _tag;
		public object Tag
		{
			get { return _tag; }
		}

		private Collection<TreeNodeAdv> _nodes;
		internal Collection<TreeNodeAdv> Nodes
		{
			get { return _nodes; }
		}

		private ReadOnlyCollection<TreeNodeAdv> _children;
		public ReadOnlyCollection<TreeNodeAdv> Children
		{
			get
			{
				return _children;
			}
		}

		private int? _rightBounds;
		internal int? RightBounds
		{
			get { return _rightBounds; }
			set { _rightBounds = value; }
		}

		private int? _height;
		internal int? Height
		{
			get { return _height; }
			set { _height = value; }
		}

		private bool _isExpandingNow;
		internal bool IsExpandingNow
		{
			get { return _isExpandingNow; }
			set { _isExpandingNow = value; }
		}

		private bool _autoExpandOnStructureChanged = true;
		public bool AutoExpandOnStructureChanged
		{
			get { return _autoExpandOnStructureChanged; }
			set { _autoExpandOnStructureChanged = value; }
		}

		#endregion

		public TreeNodeAdv(object tag)
			: this(null, tag)
		{
		}

		internal TreeNodeAdv(TreeViewAdv tree, object tag)
		{
			_row = -1;
			_tree = tree;
			_nodes = new NodeCollection(this);
			_children = new ReadOnlyCollection<TreeNodeAdv>(_nodes);
			_tag = tag;
		}

		public override string ToString()
		{
			if (Tag != null)
				return Tag.ToString();
			else
				return base.ToString();
		}

		public void Collapse()
		{
			if (_isExpanded)
				Collapse(true);
		}

		public void CollapseAll()
		{
			Collapse(false);
		}

		public void Collapse(bool ignoreChildren)
		{
			SetIsExpanded(false, ignoreChildren);
		}

		public void Expand()
		{
			if (!_isExpanded)
				Expand(true);
		}

		public void ExpandAll()
		{
			Expand(false);
		}

		public void Expand(bool ignoreChildren)
		{
			SetIsExpanded(true, ignoreChildren);
		}

		private void SetIsExpanded(bool value, bool ignoreChildren)
		{
			if (Tree == null)
				_isExpanded = value;
			else
				Tree.SetIsExpanded(this, value, ignoreChildren);
		}

		#region ISerializable Members

		private TreeNodeAdv(SerializationInfo info, StreamingContext context)
			: this(null, null)
		{
			int nodesCount = 0;
			nodesCount = info.GetInt32("NodesCount");
			_isExpanded = info.GetBoolean("IsExpanded");
			_tag = info.GetValue("Tag", typeof(object));

			for (int i = 0; i < nodesCount; i++)
			{
				TreeNodeAdv child = (TreeNodeAdv)info.GetValue("Child" + i, typeof(TreeNodeAdv));
				Nodes.Add(child);
			}

		}

		[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
		public void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			info.AddValue("IsExpanded", IsExpanded);
			info.AddValue("NodesCount", Nodes.Count);
			if ((Tag != null) && Tag.GetType().IsSerializable)
				info.AddValue("Tag", Tag, Tag.GetType());

			for (int i = 0; i < Nodes.Count; i++)
				info.AddValue("Child" + i, Nodes[i], typeof(TreeNodeAdv));

		}

		#endregion
	}
}

```

`Aga.Controls/Tree/TreeNodeAdvMouseEventArgs.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;
using System.Drawing;
using Aga.Controls.Tree.NodeControls;

namespace Aga.Controls.Tree
{
	public class TreeNodeAdvMouseEventArgs : MouseEventArgs
	{
		private TreeNodeAdv _node;
		public TreeNodeAdv Node
		{
			get { return _node; }
			internal set { _node = value; }
		}

		private NodeControl _control;
		public NodeControl Control
		{
			get { return _control; }
			internal set { _control = value; }
		}

		private Point _viewLocation;
		public Point ViewLocation
		{
			get { return _viewLocation; }
			internal set { _viewLocation = value; }
		}

		private Keys _modifierKeys;
		public Keys ModifierKeys
		{
			get { return _modifierKeys; }
			internal set { _modifierKeys = value; }
		}

		private bool _handled;
		public bool Handled
		{
			get { return _handled; }
			set { _handled = value; }
		}

		private Rectangle _controlBounds;
		public Rectangle ControlBounds
		{
			get { return _controlBounds; }
			internal set { _controlBounds = value; }
		}

		public TreeNodeAdvMouseEventArgs(MouseEventArgs args)
			: base(args.Button, args.Clicks, args.X, args.Y, args.Delta)
		{
		}
	}
}

```

`Aga.Controls/Tree/TreePath.cs`:

```cs
using System;
using System.Text;
using System.Collections.ObjectModel;

namespace Aga.Controls.Tree
{
	public class TreePath
	{
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes")]
		public static readonly TreePath Empty = new TreePath();

		private object[] _path;
		public object[] FullPath
		{
			get { return _path; }
		}

		public object LastNode
		{
			get
			{
				if (_path.Length > 0)
					return _path[_path.Length - 1];
				else
					return null;
			}
		}

		public object FirstNode
		{
			get
			{
				if (_path.Length > 0)
					return _path[0];
				else
					return null;
			}
		}

		public TreePath()
		{
			_path = new object[0];
		}

		public TreePath(object node)
		{
			_path = new object[] { node };
		}

		public TreePath(object[] path)
		{
			_path = path;
		}

		public TreePath(TreePath parent, object node)
		{
			_path = new object[parent.FullPath.Length + 1];
			for (int i = 0; i < _path.Length - 1; i++)
				_path[i] = parent.FullPath[i];
			_path[_path.Length - 1] = node;
		}

		public bool IsEmpty()
		{
			return (_path.Length == 0);
		}
	}
}

```

`Aga.Controls/Tree/TreePathEventArgs.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace Aga.Controls.Tree
{
	public class TreePathEventArgs : EventArgs
	{
		private TreePath _path;
		public TreePath Path
		{
			get { return _path; }
		}

		public TreePathEventArgs()
		{
			_path = new TreePath();
		}

		public TreePathEventArgs(TreePath path)
		{
			if (path == null)
				throw new ArgumentNullException();

			_path = path;
		}
	}
}

```

`Aga.Controls/Tree/TreeViewAdv.Designer.cs`:

```cs
using System.Windows.Forms;

namespace Aga.Controls.Tree
{
	partial class TreeViewAdv
	{
		private System.ComponentModel.IContainer components = null;

		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
				if (_dragBitmap != null) _dragBitmap.Dispose();
				if (_dragTimer != null) _dragTimer.Dispose();
				if (_linePen != null) _linePen.Dispose();
				if (_markPen != null) _markPen.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Component Designer generated code
		private void InitializeComponent()
		{
			this.components = new System.ComponentModel.Container();
			this._vScrollBar = new System.Windows.Forms.VScrollBar();
			this._hScrollBar = new System.Windows.Forms.HScrollBar();
			this._errorProvider = new System.Windows.Forms.ErrorProvider(this.components);
			((System.ComponentModel.ISupportInitialize)(this._errorProvider)).BeginInit();
			this.SuspendLayout();
			// 
			// _vScrollBar
			// 
			this._vScrollBar.LargeChange = 1;
			this._vScrollBar.Location = new System.Drawing.Point(0, 0);
			this._vScrollBar.Maximum = 0;
			this._vScrollBar.Name = "_vScrollBar";
			this._vScrollBar.Size = new System.Drawing.Size(13, 80);
			this._vScrollBar.TabIndex = 1;
			this._vScrollBar.ValueChanged += new System.EventHandler(this._vScrollBar_ValueChanged);
			this._vScrollBar.Scroll += new System.Windows.Forms.ScrollEventHandler(this._vScrollBar_Scroll);
			// 
			// _hScrollBar
			// 
			this._hScrollBar.LargeChange = 1;
			this._hScrollBar.Location = new System.Drawing.Point(0, 0);
			this._hScrollBar.Maximum = 0;
			this._hScrollBar.Name = "_hScrollBar";
			this._hScrollBar.Size = new System.Drawing.Size(80, 13);
			this._hScrollBar.TabIndex = 2;
			this._hScrollBar.ValueChanged += new System.EventHandler(this._hScrollBar_ValueChanged);
			this._hScrollBar.Scroll += new System.Windows.Forms.ScrollEventHandler(this._hScrollBar_Scroll);
			// 
			// TreeViewAdv
			// 
			this.BackColor = System.Drawing.SystemColors.Window;
			this.Controls.Add(this._vScrollBar);
			this.Controls.Add(this._hScrollBar);
			((System.ComponentModel.ISupportInitialize)(this._errorProvider)).EndInit();
			this.ResumeLayout(false);

		}
		#endregion

		private VScrollBar _vScrollBar;
		private HScrollBar _hScrollBar;
		private ErrorProvider _errorProvider;
	}
}

```

`Aga.Controls/Tree/TreeViewAdv.Draw.cs`:

```cs
using System;
using System.Drawing;
using System.Diagnostics;
using System.Drawing.Drawing2D;
using System.Windows.Forms;
using Aga.Controls.Tree.NodeControls;

namespace Aga.Controls.Tree
{
	public partial class TreeViewAdv
	{
		public void AutoSizeColumn(TreeColumn column)
		{
			if (!Columns.Contains(column))
				throw new ArgumentException("column");

			DrawContext context = new DrawContext();
			context.Graphics = Graphics.FromImage(new Bitmap(1, 1));
			context.Font = this.Font;
			int res = 0;
			for (int row = 0; row < RowCount; row++)
			{
				if (row < RowMap.Count)
				{
					int w = 0;
					TreeNodeAdv node = RowMap[row];
					foreach (NodeControl nc in NodeControls)
					{
						if (nc.ParentColumn == column)
							w += nc.GetActualSize(node, _measureContext).Width;
					}
					res = Math.Max(res, w);
				}
			}

			if (res > 0)
				column.Width = res;
		}

		private void CreatePens()
		{
			CreateLinePen();
			CreateMarkPen();
		}

		private void CreateMarkPen()
		{
			GraphicsPath path = new GraphicsPath();
			path.AddLines(new Point[] { new Point(0, 0), new Point(1, 1), new Point(-1, 1), new Point(0, 0) });
			CustomLineCap cap = new CustomLineCap(null, path);
			cap.WidthScale = 1.0f;

			_markPen = new Pen(_dragDropMarkColor, _dragDropMarkWidth);
			_markPen.CustomStartCap = cap;
			_markPen.CustomEndCap = cap;
		}

		private void CreateLinePen()
		{
			_linePen = new Pen(_lineColor);
			_linePen.DashStyle = DashStyle.Dot;
		}

        protected override void OnPaint(PaintEventArgs e)
        {
            BeginPerformanceCount();
			PerformanceAnalyzer.Start("OnPaint");

            DrawContext context = new DrawContext();
            context.Graphics = e.Graphics;
            context.Font = this.Font;
            context.Enabled = Enabled;

            int y = 0;
            int gridHeight = 0;

            if (UseColumns)
            {
				DrawColumnHeaders(e.Graphics);
				y += ColumnHeaderHeight;
                if (Columns.Count == 0 || e.ClipRectangle.Height <= y)
                    return;
            }

			int firstRowY = _rowLayout.GetRowBounds(FirstVisibleRow).Y;
            y -= firstRowY;

            e.Graphics.ResetTransform();
            e.Graphics.TranslateTransform(-OffsetX, y);
            Rectangle displayRect = DisplayRectangle;
            for (int row = FirstVisibleRow; row < RowCount; row++)
            {
                Rectangle rowRect = _rowLayout.GetRowBounds(row);
                gridHeight += rowRect.Height;
                if (rowRect.Y + y > displayRect.Bottom)
                    break;
                else
                    DrawRow(e, ref context, row, rowRect);
            }

			if ((GridLineStyle & GridLineStyle.Vertical) == GridLineStyle.Vertical && UseColumns)
				DrawVerticalGridLines(e.Graphics, firstRowY);

			if (_dropPosition.Node != null && DragMode && HighlightDropPosition)
                DrawDropMark(e.Graphics);

            e.Graphics.ResetTransform();
            DrawScrollBarsBox(e.Graphics);

            if (DragMode && _dragBitmap != null)
                e.Graphics.DrawImage(_dragBitmap, PointToClient(MousePosition));

			PerformanceAnalyzer.Finish("OnPaint");
			EndPerformanceCount(e);
        }

		private void DrawRow(PaintEventArgs e, ref DrawContext context, int row, Rectangle rowRect)
		{
			TreeNodeAdv node = RowMap[row];
			context.DrawSelection = DrawSelectionMode.None;
			context.CurrentEditorOwner = CurrentEditorOwner;
			if (DragMode)
			{
				if ((_dropPosition.Node == node) && _dropPosition.Position == NodePosition.Inside && HighlightDropPosition)
					context.DrawSelection = DrawSelectionMode.Active;
			}
			else
			{
				if (node.IsSelected && Focused)
					context.DrawSelection = DrawSelectionMode.Active;
				else if (node.IsSelected && !Focused && !HideSelection)
					context.DrawSelection = DrawSelectionMode.Inactive;
			}
			context.DrawFocus = Focused && CurrentNode == node;
			
			OnRowDraw(e, node, context, row, rowRect);

			if ((GridLineStyle & GridLineStyle.Horizontal) == GridLineStyle.Horizontal) {
				e.Graphics.DrawLine(CustomHorizontalLinePen, 0, rowRect.Bottom, e.Graphics.ClipBounds.Right, rowRect.Bottom);
      }

			if (FullRowSelect)
			{
				context.DrawFocus = false;
				if (context.DrawSelection == DrawSelectionMode.Active || context.DrawSelection == DrawSelectionMode.Inactive)
				{
					Rectangle focusRect = new Rectangle(OffsetX, rowRect.Y, ClientRectangle.Width, rowRect.Height);
					if (context.DrawSelection == DrawSelectionMode.Active)
					{
						e.Graphics.FillRectangle(CustomSelectedRowBrush, focusRect);
						context.DrawSelection = DrawSelectionMode.FullRowSelect;
					}
					else
					{
						e.Graphics.FillRectangle(CustomSelectedRowBrush, focusRect);
						context.DrawSelection = DrawSelectionMode.None;
					}
				}
			}

			if (ShowLines)
				DrawLines(e.Graphics, node, rowRect);

			DrawNode(node, context);
		}

		private void DrawVerticalGridLines(Graphics gr, int y)
		{
			int x = 0;
			foreach (TreeColumn c in Columns)
			{
				if (c.IsVisible)
				{
					x += c.Width;
					gr.DrawLine(SystemPens.InactiveBorder, x - 1, y, x - 1, gr.ClipBounds.Bottom);
				}
			}
		}

		private void DrawColumnHeaders(Graphics gr)
		{
			PerformanceAnalyzer.Start("DrawColumnHeaders");
			ReorderColumnState reorder = Input as ReorderColumnState;
			int x = 0;
			TreeColumn.DrawBackground(gr, new Rectangle(0, 0, ClientRectangle.Width + 2, ColumnHeaderHeight - 1), false, false);
			gr.TranslateTransform(-OffsetX, 0);
			foreach (TreeColumn c in Columns)
			{
				if (c.IsVisible)
				{
					if (x >= OffsetX && x - OffsetX < this.Bounds.Width)// skip invisible columns
					{
						Rectangle rect = new Rectangle(x, 0, c.Width, ColumnHeaderHeight - 1);
						gr.SetClip(rect);
						bool pressed = ((Input is ClickColumnState || reorder != null) && ((Input as ColumnState).Column == c));
						c.Draw(gr, rect, Font, pressed, _hotColumn == c);
						gr.ResetClip();

						if (reorder != null && reorder.DropColumn == c)
							TreeColumn.DrawDropMark(gr, rect);
					}
					x += c.Width;
				}
			}

			if (reorder != null)
			{
				if (reorder.DropColumn == null)
					TreeColumn.DrawDropMark(gr, new Rectangle(x, 0, 0, ColumnHeaderHeight));
				gr.DrawImage(reorder.GhostImage, new Point(reorder.Location.X +  + reorder.DragOffset, reorder.Location.Y));
			}
			PerformanceAnalyzer.Finish("DrawColumnHeaders");
		}

		public void DrawNode(TreeNodeAdv node, DrawContext context)
		{
			foreach (NodeControlInfo item in GetNodeControls(node))
			{
				if (item.Bounds.Right >= OffsetX && item.Bounds.X - OffsetX < this.Bounds.Width)// skip invisible nodes
				{
					context.Bounds = item.Bounds;
					context.Graphics.SetClip(context.Bounds);
					item.Control.Draw(node, context);
					context.Graphics.ResetClip();
				}
			}
		}

		private void DrawScrollBarsBox(Graphics gr)
		{
			Rectangle r1 = DisplayRectangle;
			Rectangle r2 = ClientRectangle;
			gr.FillRectangle(SystemBrushes.Control,
				new Rectangle(r1.Right, r1.Bottom, r2.Width - r1.Width, r2.Height - r1.Height));
		}

		private void DrawDropMark(Graphics gr)
		{
			if (_dropPosition.Position == NodePosition.Inside)
				return;

			Rectangle rect = GetNodeBounds(_dropPosition.Node);
			int right = DisplayRectangle.Right - LeftMargin + OffsetX;
			int y = rect.Y;
			if (_dropPosition.Position == NodePosition.After)
				y = rect.Bottom;
			gr.DrawLine(_markPen, rect.X, y, right, y);
		}

		private void DrawLines(Graphics gr, TreeNodeAdv node, Rectangle rowRect)
		{
			if (UseColumns && Columns.Count > 0)
				gr.SetClip(new Rectangle(0, rowRect.Y, Columns[0].Width, rowRect.Bottom));

			TreeNodeAdv curNode = node;
			while (curNode != _root && curNode != null)
			{
				int level = curNode.Level;
				int scaledIndent = node.Tree.GetScaledSize(_indent, false);
				int x = (level - 1) * scaledIndent + NodePlusMinus.ImageSize / 2 + LeftMargin;
				int width = node.Tree.GetScaledSize(NodePlusMinus.Width - NodePlusMinus.ImageSize / 2, false);
				int y = rowRect.Y;
				int y2 = y + rowRect.Height;

				if (curNode == node)
				{
					int midy = y + rowRect.Height / 2;
					gr.DrawLine(_linePen, x, midy, x + width, midy);
					if (curNode.NextNode == null)
						y2 = y + rowRect.Height / 2;
				}

				if (node.Row == 0)
					y = rowRect.Height / 2;
				if (curNode.NextNode != null || curNode == node)
					gr.DrawLine(_linePen, x, y, x, y2);

				curNode = curNode.Parent;
			}

			gr.ResetClip();
		}

		#region Performance

		private double _totalTime;
		private int _paintCount;

		[Conditional("PERF_TEST")]
		private void BeginPerformanceCount()
		{
			_paintCount++;
			TimeCounter.Start();
		}

		[Conditional("PERF_TEST")]
		private void EndPerformanceCount(PaintEventArgs e)
		{
			double time = TimeCounter.Finish();
			_totalTime += time;
			string debugText = string.Format("FPS {0:0.0}; Avg. FPS {1:0.0}",
				1 / time, 1 / (_totalTime / _paintCount));
			e.Graphics.FillRectangle(Brushes.White, new Rectangle(DisplayRectangle.Width - 150, DisplayRectangle.Height - 20, 150, 20));
			e.Graphics.DrawString(debugText, Control.DefaultFont, Brushes.Gray,
				new PointF(DisplayRectangle.Width - 150, DisplayRectangle.Height - 20));
		}
		#endregion

	}
}

```

`Aga.Controls/Tree/TreeViewAdv.Editor.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;
using Aga.Controls.Tree.NodeControls;
using System.Drawing;

namespace Aga.Controls.Tree
{
	partial class TreeViewAdv
	{
		private TreeNodeAdv _editingNode;

		public EditableControl CurrentEditorOwner { get; private set; }
		public Control CurrentEditor { get; private set; }

		public void HideEditor()
		{
			if (CurrentEditorOwner != null)
				CurrentEditorOwner.EndEdit(false);
		}

		internal void DisplayEditor(Control editor, EditableControl owner)
		{
			if (editor == null || owner == null || CurrentNode == null)
				throw new ArgumentNullException();

			HideEditor(false);

			CurrentEditor = editor;
			CurrentEditorOwner = owner;
			_editingNode = CurrentNode;

			editor.Validating += EditorValidating;
			UpdateEditorBounds();
			UpdateView();
			editor.Parent = this;
			editor.Focus();
			owner.UpdateEditor(editor);
		}

		internal bool HideEditor(bool applyChanges)
		{
			if (CurrentEditor != null)
			{
				if (applyChanges)
				{
					if (!ApplyChanges())
						return false;
				}

				//Check once more if editor was closed in ApplyChanges
				if (CurrentEditor != null)
				{
					CurrentEditor.Validating -= EditorValidating;
					CurrentEditorOwner.DoDisposeEditor(CurrentEditor);

					CurrentEditor.Parent = null;
					CurrentEditor.Dispose();

					CurrentEditor = null;
					CurrentEditorOwner = null;
					_editingNode = null;
				}
			}
			return true;
		}

		private bool ApplyChanges()
		{
			try
			{
				CurrentEditorOwner.ApplyChanges(_editingNode, CurrentEditor);
				_errorProvider.Clear();
				return true;
			}
			catch (ArgumentException ex)
			{
				_errorProvider.SetError(CurrentEditor, ex.Message);
				/*CurrentEditor.Validating -= EditorValidating;
				MessageBox.Show(this, ex.Message, "Value is not valid", MessageBoxButtons.OK, MessageBoxIcon.Warning);
				CurrentEditor.Focus();
				CurrentEditor.Validating += EditorValidating;*/
				return false;
			}
		}

		void EditorValidating(object sender, System.ComponentModel.CancelEventArgs e)
		{
			e.Cancel = !ApplyChanges();
		}

		public void UpdateEditorBounds()
		{
			if (CurrentEditor != null)
			{
				EditorContext context = new EditorContext();
				context.Owner = CurrentEditorOwner;
				context.CurrentNode = CurrentNode;
				context.Editor = CurrentEditor;
				context.DrawContext = _measureContext;
				SetEditorBounds(context);
			}
		}

		private void SetEditorBounds(EditorContext context)
		{
			foreach (NodeControlInfo info in GetNodeControls(context.CurrentNode))
			{
				if (context.Owner == info.Control && info.Control is EditableControl)
				{
					Point p = info.Bounds.Location;
					p.X += info.Control.LeftMargin;
					p.X -= OffsetX;
					p.Y -= (_rowLayout.GetRowBounds(FirstVisibleRow).Y - ColumnHeaderHeight);
					int width = DisplayRectangle.Width - p.X;
					if (UseColumns && info.Control.ParentColumn != null && Columns.Contains(info.Control.ParentColumn))
					{
						Rectangle rect = GetColumnBounds(info.Control.ParentColumn.Index);
						width = rect.Right - OffsetX - p.X;
					}
					context.Bounds = new Rectangle(p.X, p.Y, width, info.Bounds.Height);
					((EditableControl)info.Control).SetEditorBounds(context);
					return;
				}
			}
		}

		private Rectangle GetColumnBounds(int column)
		{
			int x = 0;
			for (int i = 0; i < Columns.Count; i++)
			{
				if (Columns[i].IsVisible)
				{
					if (i < column)
						x += Columns[i].Width;
					else
						return new Rectangle(x, 0, Columns[i].Width, 0);
				}
			}
			return Rectangle.Empty;
		}
	}
}

```

`Aga.Controls/Tree/TreeViewAdv.Input.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;
using System.Drawing;
using Aga.Controls.Tree.NodeControls;
using System.Drawing.Imaging;
using System.Threading;

namespace Aga.Controls.Tree
{
	public partial class TreeViewAdv
	{
		#region Keys

		protected override bool IsInputChar(char charCode)
		{
			return true;
		}

		protected override bool IsInputKey(Keys keyData)
		{
			if (((keyData & Keys.Up) == Keys.Up)
				|| ((keyData & Keys.Down) == Keys.Down)
				|| ((keyData & Keys.Left) == Keys.Left)
				|| ((keyData & Keys.Right) == Keys.Right))
				return true;
			else
				return base.IsInputKey(keyData);
		}

		internal void ChangeInput()
		{
			if ((ModifierKeys & Keys.Shift) == Keys.Shift)
			{
				if (!(Input is InputWithShift))
					Input = new InputWithShift(this);
			}
			else if ((ModifierKeys & Keys.Control) == Keys.Control)
			{
				if (!(Input is InputWithControl))
					Input = new InputWithControl(this);
			}
			else
			{
				if (!(Input.GetType() == typeof(NormalInputState)))
					Input = new NormalInputState(this);
			}
		}

		protected override void OnKeyDown(KeyEventArgs e)
		{
			base.OnKeyDown(e);
			if (!e.Handled)
			{
				if (e.KeyCode == Keys.ShiftKey || e.KeyCode == Keys.ControlKey)
					ChangeInput();
				Input.KeyDown(e);
				if (!e.Handled)
				{
					foreach (NodeControlInfo item in GetNodeControls(CurrentNode))
					{
						item.Control.KeyDown(e);
						if (e.Handled)
							break;
					}
				}
			}
		}

		protected override void OnKeyUp(KeyEventArgs e)
		{
			base.OnKeyUp(e);
			if (!e.Handled)
			{
				if (e.KeyCode == Keys.ShiftKey || e.KeyCode == Keys.ControlKey)
					ChangeInput();
				if (!e.Handled)
				{
					foreach (NodeControlInfo item in GetNodeControls(CurrentNode))
					{
						item.Control.KeyUp(e);
						if (e.Handled)
							return;
					}
				}
			}
		}

		protected override void OnKeyPress(KeyPressEventArgs e)
		{
			base.OnKeyPress(e);
			if (!e.Handled)
				_search.Search(e.KeyChar);
		}

		#endregion

		#region Mouse

		private TreeNodeAdvMouseEventArgs CreateMouseArgs(MouseEventArgs e)
		{
			TreeNodeAdvMouseEventArgs args = new TreeNodeAdvMouseEventArgs(e);
			args.ViewLocation = new Point(e.X + OffsetX,
				e.Y + _rowLayout.GetRowBounds(FirstVisibleRow).Y - ColumnHeaderHeight);
			args.ModifierKeys = ModifierKeys;
			args.Node = GetNodeAt(e.Location);
			NodeControlInfo info = GetNodeControlInfoAt(args.Node, e.Location);
			args.ControlBounds = info.Bounds;
			args.Control = info.Control;
			return args;
		}

		protected override void OnMouseWheel(MouseEventArgs e)
		{
			_search.EndSearch();
			if (SystemInformation.MouseWheelScrollLines > 0)
			{
				int lines = e.Delta / 120 * SystemInformation.MouseWheelScrollLines;
				int newValue = _vScrollBar.Value - lines;
				newValue = Math.Min(_vScrollBar.Maximum - _vScrollBar.LargeChange + 1, newValue);
				newValue = Math.Min(_vScrollBar.Maximum, newValue);
				_vScrollBar.Value = Math.Max(_vScrollBar.Minimum, newValue);
			}
			base.OnMouseWheel(e);
		}

		protected override void OnMouseDown(MouseEventArgs e)
		{
			if (CurrentEditorOwner != null)
			{
				CurrentEditorOwner.EndEdit(true);
				return;
			}

			if (!Focused)
				Focus();

			_search.EndSearch();
			if (e.Button == MouseButtons.Left)
			{
				TreeColumn c;
				c = GetColumnDividerAt(e.Location);
				if (c != null)
				{
					Input = new ResizeColumnState(this, c, e.Location);
					return;
				}
				c = GetColumnAt(e.Location);
				if (c != null)
				{
					Input = new ClickColumnState(this, c, e.Location);
					UpdateView();
					return;
				}
			}

			ChangeInput();
			TreeNodeAdvMouseEventArgs args = CreateMouseArgs(e);

			if (args.Node != null && args.Control != null)
				args.Control.MouseDown(args);

			if (!args.Handled)
				Input.MouseDown(args);

			base.OnMouseDown(e);
		}

		protected override void OnMouseClick(MouseEventArgs e)
		{
			//TODO: Disable when click on plusminus icon
			TreeNodeAdvMouseEventArgs args = CreateMouseArgs(e);
			if (args.Node != null)
				OnNodeMouseClick(args);

			base.OnMouseClick(e);
		}

		protected override void OnMouseDoubleClick(MouseEventArgs e)
		{
			TreeNodeAdvMouseEventArgs args = CreateMouseArgs(e);

			if (args.Node != null && args.Control != null)
				args.Control.MouseDoubleClick(args);

			if (!args.Handled)
			{
				if (args.Node != null)
					OnNodeMouseDoubleClick(args);
				else
					Input.MouseDoubleClick(args);

				if (!args.Handled)
				{
					if (args.Node != null && args.Button == MouseButtons.Left)
						args.Node.IsExpanded = !args.Node.IsExpanded;
				}
			}

			base.OnMouseDoubleClick(e);
		}

		protected override void OnMouseUp(MouseEventArgs e)
		{
			TreeNodeAdvMouseEventArgs args = CreateMouseArgs(e);
			if (Input is ResizeColumnState)
				Input.MouseUp(args);
			else
			{
				if (args.Node != null && args.Control != null)
					args.Control.MouseUp(args);
				if (!args.Handled)
					Input.MouseUp(args);

				base.OnMouseUp(e);
			}
		}

		protected override void OnMouseMove(MouseEventArgs e)
		{
			if (Input.MouseMove(e))
				return;

			base.OnMouseMove(e);
			SetCursor(e);
			UpdateToolTip(e);
			if (ItemDragMode && Dist(e.Location, ItemDragStart) > ItemDragSensivity
				&& CurrentNode != null && CurrentNode.IsSelected)
			{
				ItemDragMode = false;
				_toolTip.Active = false;
				OnItemDrag(e.Button, Selection.ToArray());
			}
		}

		protected override void OnMouseLeave(EventArgs e)
		{
			_hotColumn = null;
			UpdateHeaders();
			base.OnMouseLeave(e);
		}

		private void SetCursor(MouseEventArgs e)
		{
			TreeColumn col;
			col = GetColumnDividerAt(e.Location);
			if (col == null)
				_innerCursor = null;
			else
			{
				if (col.Width == 0)
					_innerCursor = ResourceHelper.DVSplitCursor;
				else
					_innerCursor = Cursors.VSplit;
			}

			col = GetColumnAt(e.Location);
			if (col != _hotColumn)
			{
				_hotColumn = col;
				UpdateHeaders();
			}
		}

		internal TreeColumn GetColumnAt(Point p)
		{
			if (p.Y > ColumnHeaderHeight)
				return null;

			int x = -OffsetX;
			foreach (TreeColumn col in Columns)
			{
				if (col.IsVisible)
				{
					Rectangle rect = new Rectangle(x, 0, col.Width, ColumnHeaderHeight);
					x += col.Width;
					if (rect.Contains(p))
						return col;
				}
			}
			return null;
		}

		internal int GetColumnX(TreeColumn column)
		{
			int x = -OffsetX;
			foreach (TreeColumn col in Columns)
			{
				if (col.IsVisible)
				{
					if (column == col)
						return x;
					else
						x += col.Width;
				}
			}
			return x;
		}

		internal TreeColumn GetColumnDividerAt(Point p)
		{
			if (p.Y > ColumnHeaderHeight)
				return null;

			int x = -OffsetX;
			TreeColumn prevCol = null;
			Rectangle left, right;
			foreach (TreeColumn col in Columns)
			{
				if (col.IsVisible)
				{
					if (col.Width > 0)
					{
						left = new Rectangle(x, 0, DividerWidth / 2, ColumnHeaderHeight);
						right = new Rectangle(x + col.Width - (DividerWidth / 2), 0, DividerWidth / 2, ColumnHeaderHeight);
						if (left.Contains(p) && prevCol != null)
							return prevCol;
						else if (right.Contains(p))
							return col;
					}
					prevCol = col;
					x += col.Width;
				}
			}

			left = new Rectangle(x, 0, DividerWidth / 2, ColumnHeaderHeight);
			if (left.Contains(p) && prevCol != null)
				return prevCol;

			return null;
		}

		TreeColumn _tooltipColumn;
		private void UpdateToolTip(MouseEventArgs e)
		{
			TreeColumn col = GetColumnAt(e.Location);
			if (col != null)
			{
				if (col != _tooltipColumn)
					SetTooltip(col.TooltipText);
			}
			else
				DisplayNodesTooltip(e);
			_tooltipColumn = col;
		}

		TreeNodeAdv _hotNode;
		NodeControl _hotControl;
		private void DisplayNodesTooltip(MouseEventArgs e)
		{
			if (ShowNodeToolTips)
			{
				TreeNodeAdvMouseEventArgs args = CreateMouseArgs(e);
				if (args.Node != null && args.Control != null)
				{
					if (args.Node != _hotNode || args.Control != _hotControl)
						SetTooltip(GetNodeToolTip(args));
				}
				else
					_toolTip.SetToolTip(this, null);

				_hotControl = args.Control;
				_hotNode = args.Node;
			}
			else
				_toolTip.SetToolTip(this, null);
		}

		private void SetTooltip(string text)
		{
			if (!String.IsNullOrEmpty(text))
			{
				_toolTip.Active = false;
				_toolTip.SetToolTip(this, text);
				_toolTip.Active = true;
			}
			else
				_toolTip.SetToolTip(this, null);
		}

		private string GetNodeToolTip(TreeNodeAdvMouseEventArgs args)
		{
			string msg = args.Control.GetToolTip(args.Node);

			BaseTextControl btc = args.Control as BaseTextControl;
			if (btc != null && btc.DisplayHiddenContentInToolTip && String.IsNullOrEmpty(msg))
			{
				Size ms = btc.GetActualSize(args.Node, _measureContext);
				if (ms.Width > args.ControlBounds.Size.Width || ms.Height > args.ControlBounds.Size.Height
					|| args.ControlBounds.Right - OffsetX > DisplayRectangle.Width)
					msg = btc.GetLabel(args.Node);
			}

			if (String.IsNullOrEmpty(msg) && DefaultToolTipProvider != null)
				msg = DefaultToolTipProvider.GetToolTip(args.Node, args.Control);

			return msg;
		}

		#endregion

		#region DragDrop

		private bool _dragAutoScrollFlag = false;
		private Bitmap _dragBitmap = null;
		private System.Threading.Timer _dragTimer;

		private void StartDragTimer()
		{
			if (_dragTimer == null)
				_dragTimer = new System.Threading.Timer(new TimerCallback(DragTimerTick), null, 0, 100);
		}

		private void StopDragTimer()
		{
			if (_dragTimer != null)
			{
				_dragTimer.Dispose();
				_dragTimer = null;
			}
		}

		private void SetDropPosition(Point pt)
		{
			TreeNodeAdv node = GetNodeAt(pt);
			OnDropNodeValidating(pt, ref node);
			_dropPosition.Node = node;
			if (node != null)
			{
				Rectangle first = _rowLayout.GetRowBounds(FirstVisibleRow);
				Rectangle bounds = _rowLayout.GetRowBounds(node.Row);
				float pos = (pt.Y + first.Y - ColumnHeaderHeight - bounds.Y) / (float)bounds.Height;
				if (pos < TopEdgeSensivity)
					_dropPosition.Position = NodePosition.Before;
				else if (pos > (1 - BottomEdgeSensivity))
					_dropPosition.Position = NodePosition.After;
				else
					_dropPosition.Position = NodePosition.Inside;
			}
		}

		private void DragTimerTick(object state)
		{
			_dragAutoScrollFlag = true;
		}

		private void DragAutoScroll()
		{
			_dragAutoScrollFlag = false;
			Point pt = PointToClient(MousePosition);
			if (pt.Y < 20 && _vScrollBar.Value > 0)
				_vScrollBar.Value--;
			else if (pt.Y > Height - 20 && _vScrollBar.Value <= _vScrollBar.Maximum - _vScrollBar.LargeChange)
				_vScrollBar.Value++;
		}

		public void DoDragDropSelectedNodes(DragDropEffects allowedEffects)
		{
			if (SelectedNodes.Count > 0)
			{
				TreeNodeAdv[] nodes = new TreeNodeAdv[SelectedNodes.Count];
				SelectedNodes.CopyTo(nodes, 0);
				DoDragDrop(nodes, allowedEffects);
			}
		}

		private void CreateDragBitmap(IDataObject data)
		{
			if (UseColumns || !DisplayDraggingNodes)
				return;

			TreeNodeAdv[] nodes = data.GetData(typeof(TreeNodeAdv[])) as TreeNodeAdv[];
			if (nodes != null && nodes.Length > 0)
			{
				Rectangle rect = DisplayRectangle;
				Bitmap bitmap = new Bitmap(rect.Width, rect.Height);
				using (Graphics gr = Graphics.FromImage(bitmap))
				{
					gr.Clear(BackColor);
					DrawContext context = new DrawContext();
					context.Graphics = gr;
					context.Font = Font;
					context.Enabled = true;
					int y = 0;
					int maxWidth = 0;
					foreach (TreeNodeAdv node in nodes)
					{
						if (node.Tree == this)
						{
							int x = 0;
							int height = _rowLayout.GetRowBounds(node.Row).Height;
							foreach (NodeControl c in NodeControls)
							{
								Size s = c.GetActualSize(node, context);
								if (!s.IsEmpty)
								{
									int width = s.Width;
									rect = new Rectangle(x, y, width, height);
									x += (width + 1);
									context.Bounds = rect;
									c.Draw(node, context);
								}
							}
							y += height;
							maxWidth = Math.Max(maxWidth, x);
						}
					}

					if (maxWidth > 0 && y > 0)
					{
						_dragBitmap = new Bitmap(maxWidth, y, PixelFormat.Format32bppArgb);
						using (Graphics tgr = Graphics.FromImage(_dragBitmap))
							tgr.DrawImage(bitmap, Point.Empty);
						BitmapHelper.SetAlphaChanelValue(_dragBitmap, 150);
					}
					else
						_dragBitmap = null;
				}
			}
		}

		protected override void OnDragOver(DragEventArgs drgevent)
		{
			ItemDragMode = false;
			Point pt = PointToClient(new Point(drgevent.X, drgevent.Y));
			if (_dragAutoScrollFlag)
				DragAutoScroll();
			SetDropPosition(pt);
			UpdateView();
			base.OnDragOver(drgevent);
		}

		protected override void OnDragEnter(DragEventArgs drgevent)
		{
			_search.EndSearch();
			DragMode = true;
			CreateDragBitmap(drgevent.Data);
			base.OnDragEnter(drgevent);
		}

		protected override void OnDragLeave(EventArgs e)
		{
			DragMode = false;
			UpdateView();
			base.OnDragLeave(e);
		}

		protected override void OnDragDrop(DragEventArgs drgevent)
		{
			DragMode = false;
			UpdateView();
			base.OnDragDrop(drgevent);
		}

		#endregion
	}
}

```

`Aga.Controls/Tree/TreeViewAdv.Properties.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Drawing;
using System.Drawing.Design;
using System.Windows.Forms;

using Aga.Controls.Tree.NodeControls;

namespace Aga.Controls.Tree
{
	public partial class TreeViewAdv
	{
		private Cursor _innerCursor = null;

		public override Cursor Cursor
		{
			get
			{
                if (_innerCursor != null)
                    return _innerCursor;
                else
					return base.Cursor;
			}
			set
			{
				base.Cursor = value;
			}
		}

		#region Internal Properties

		private IRowLayout _rowLayout;

		private bool _dragMode;
		private bool DragMode
		{
			get { return _dragMode; }
			set
			{
				_dragMode = value;
				if (!value)
				{
					StopDragTimer();
					if (_dragBitmap != null)
						_dragBitmap.Dispose();
					_dragBitmap = null;
				}
				else
					StartDragTimer();
			}
		}

		internal int ColumnHeaderHeight
		{
			get
			{
				if (UseColumns)
					return _columnHeaderHeight;
				else
					return 0;
			}
		}

		/// <summary>
		/// returns all nodes, which parent is expanded
		/// </summary>
		private IEnumerable<TreeNodeAdv> VisibleNodes
		{
			get
			{
				TreeNodeAdv node = Root;
				while (node != null)
				{
					node = node.NextVisibleNode;
					if (node != null)
						yield return node;
				}
			}
		}

		private bool _suspendSelectionEvent;
		internal bool SuspendSelectionEvent
		{
			get { return _suspendSelectionEvent; }
			set
			{
				if (value != _suspendSelectionEvent)
				{
					_suspendSelectionEvent = value;
					if (!_suspendSelectionEvent && _fireSelectionEvent)
						OnSelectionChanged();
				}
			}
		}

		private List<TreeNodeAdv> _rowMap;
		internal List<TreeNodeAdv> RowMap
		{
			get { return _rowMap; }
		}

		private TreeNodeAdv _selectionStart;
		internal TreeNodeAdv SelectionStart
		{
			get { return _selectionStart; }
			set { _selectionStart = value; }
		}

		private InputState _input;
		internal InputState Input
		{
			get { return _input; }
			set
			{
				_input = value;
			}
		}

		private bool _itemDragMode;
		internal bool ItemDragMode
		{
			get { return _itemDragMode; }
			set { _itemDragMode = value; }
		}

		private Point _itemDragStart;
		internal Point ItemDragStart
		{
			get { return _itemDragStart; }
			set { _itemDragStart = value; }
		}


		/// <summary>
		/// Number of rows fits to the current page
		/// </summary>
		internal int CurrentPageSize
		{
			get
			{
				return _rowLayout.CurrentPageSize;
			}
		}

		/// <summary>
		/// Number of all visible nodes (which parent is expanded)
		/// </summary>
		internal int RowCount
		{
			get
			{
				return RowMap.Count;
			}
		}

		private int _contentWidth = 0;
		private int ContentWidth
		{
			get
			{
				return _contentWidth;
			}
		}

		private int _firstVisibleRow;
		internal int FirstVisibleRow
		{
			get { return _firstVisibleRow; }
			set
			{
				HideEditor();
				_firstVisibleRow = value;
				UpdateView();
			}
		}

		private int _offsetX;
		public int OffsetX
		{
			get { return _offsetX; }
			private set
			{
				HideEditor();
				_offsetX = value;
				UpdateView();
			}
		}

		public override Rectangle DisplayRectangle
		{
			get
			{
				Rectangle r = ClientRectangle;
				//r.Y += ColumnHeaderHeight;
				//r.Height -= ColumnHeaderHeight;
				int w = _vScrollBar.Visible ? _vScrollBar.Width : 0;
				int h = _hScrollBar.Visible ? _hScrollBar.Height : 0;
				return new Rectangle(r.X, r.Y, r.Width - w, r.Height - h);
			}
		}

		private List<TreeNodeAdv> _selection;
		internal List<TreeNodeAdv> Selection
		{
			get { return _selection; }
		}

		#endregion

		#region Public Properties

		#region DesignTime

		private bool _shiftFirstNode;
		[DefaultValue(false), Category("Behavior")]
		public bool ShiftFirstNode
		{
			get { return _shiftFirstNode; }
			set { _shiftFirstNode = value; }
		}

		private bool _displayDraggingNodes;
		[DefaultValue(false), Category("Behavior")]
		public bool DisplayDraggingNodes
		{
			get { return _displayDraggingNodes; }
			set { _displayDraggingNodes = value; }
		}

		private bool _fullRowSelect;
		[DefaultValue(false), Category("Behavior")]
		public bool FullRowSelect
		{
			get { return _fullRowSelect; }
			set
			{
				_fullRowSelect = value;
				UpdateView();
			}
		}

		private bool _useColumns;
		[DefaultValue(false), Category("Behavior")]
		public bool UseColumns
		{
			get { return _useColumns; }
			set
			{
				_useColumns = value;
				FullUpdate();
			}
		}

		private bool _allowColumnReorder;
		[DefaultValue(false), Category("Behavior")]
		public bool AllowColumnReorder
		{
			get { return _allowColumnReorder; }
			set { _allowColumnReorder = value; }
		}

		private bool _showLines = true;
		[DefaultValue(true), Category("Behavior")]
		public bool ShowLines
		{
			get { return _showLines; }
			set
			{
				_showLines = value;
				UpdateView();
			}
		}

		private bool _showPlusMinus = true;
		[DefaultValue(true), Category("Behavior")]
		public bool ShowPlusMinus
		{
			get { return _showPlusMinus; }
			set
			{
				_showPlusMinus = value;
				FullUpdate();
			}
		}

		private bool _showNodeToolTips = false;
		[DefaultValue(false), Category("Behavior")]
		public bool ShowNodeToolTips
		{
			get { return _showNodeToolTips; }
			set { _showNodeToolTips = value; }
		}

		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "value"), System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic"), DefaultValue(true), Category("Behavior"), Obsolete("No longer used")]
		public bool KeepNodesExpanded
		{
			get { return true; }
			set {}
		}

		private ITreeModel _model;
        /// <Summary>
        /// The model associated with this <see cref="TreeViewAdv"/>.
        /// </Summary>
        /// <seealso cref="ITreeModel"/>
        /// <seealso cref="TreeModel"/>
        [Browsable(false)]
		public ITreeModel Model
		{
			get { return _model; }
			set
			{
				if (_model != value)
				{
					AbortBackgroundExpandingThreads();
					if (_model != null)
						UnbindModelEvents();
					_model = value;
					CreateNodes();
					FullUpdate();
					if (_model != null)
						BindModelEvents();
				}
			}
		}

        private static Font _font = SystemFonts.MessageBoxFont; 
        /// <summary>
        /// The font to render <see cref="TreeViewAdv"/> content in.
        /// </summary>
        [Category("Appearance"), Description("The font to render TreeViewAdv content in.")]
        public override Font Font
        {
            get
            {
                return (base.Font);
            }
            set
            {
                if (value == null)
                    base.Font = _font;
                else
                {
                    if (value == DefaultFont)
                        base.Font = _font;
                    else
                        base.Font = value;
                }
            }
        }
        public override void ResetFont()
        {
            Font = null;
        }
        private bool ShouldSerializeFont()
        {
            return (!Font.Equals(_font));
        }
        // End font property

		private BorderStyle _borderStyle = BorderStyle.Fixed3D;
		[DefaultValue(BorderStyle.Fixed3D), Category("Appearance")]
		public BorderStyle BorderStyle
		{
			get
			{
				return this._borderStyle;
			}
			set
			{
				if (_borderStyle != value)
				{
					_borderStyle = value;
					base.UpdateStyles();
				}
			}
		}

		private bool _autoRowHeight = false;
		/// <summary>
		/// Set to true to expand each row's height to fit the text of it's largest column.
		/// </summary>
		[DefaultValue(false), Category("Appearance"), Description("Expand each row's height to fit the text of it's largest column.")]
		public bool AutoRowHeight
		{
			get
			{
				return _autoRowHeight;
			}
			set
			{
				_autoRowHeight = value;
				if (value)
					_rowLayout = new AutoRowHeightLayout(this, RowHeight);
				else
					_rowLayout = new FixedRowHeightLayout(this, RowHeight);
				FullUpdate();
			}
		}

        private GridLineStyle _gridLineStyle = GridLineStyle.None;
        [DefaultValue(GridLineStyle.None), Category("Appearance")]
        public GridLineStyle GridLineStyle
        {
            get
            {
                return _gridLineStyle;
            }
            set
            {
				if (value != _gridLineStyle)
				{
					_gridLineStyle = value;
					UpdateView();
					OnGridLineStyleChanged();
				}
            }
        }

		private int _rowHeight = 16;
		[DefaultValue(16), Category("Appearance")]
		public int RowHeight
		{
			get
			{
				return _rowHeight;
			}
			set
			{
				if (value <= 0)
					throw new ArgumentOutOfRangeException("value");

				_rowHeight = value;
				_rowLayout.PreferredRowHeight = value;
				FullUpdate();
			}
		}

		private TreeSelectionMode _selectionMode = TreeSelectionMode.Single;
		[DefaultValue(TreeSelectionMode.Single), Category("Behavior")]
		public TreeSelectionMode SelectionMode
		{
			get { return _selectionMode; }
			set { _selectionMode = value; }
		}

		private bool _hideSelection;
		[DefaultValue(false), Category("Behavior")]
		public bool HideSelection
		{
			get { return _hideSelection; }
			set
			{
				_hideSelection = value;
				UpdateView();
			}
		}

		private float _topEdgeSensivity = 0.3f;
		[DefaultValue(0.3f), Category("Behavior")]
		public float TopEdgeSensivity
		{
			get { return _topEdgeSensivity; }
			set
			{
				if (value < 0 || value > 1)
					throw new ArgumentOutOfRangeException();
				_topEdgeSensivity = value;
			}
		}

		private float _bottomEdgeSensivity = 0.3f;
		[DefaultValue(0.3f), Category("Behavior")]
		public float BottomEdgeSensivity
		{
			get { return _bottomEdgeSensivity; }
			set
			{
				if (value < 0 || value > 1)
					throw new ArgumentOutOfRangeException("value should be from 0 to 1");
				_bottomEdgeSensivity = value;
			}
		}

		private bool _loadOnDemand;
		[DefaultValue(false), Category("Behavior")]
		public bool LoadOnDemand
		{
			get { return _loadOnDemand; }
			set { _loadOnDemand = value; }
		}

		private bool _unloadCollapsedOnReload = false;
		[DefaultValue(false), Category("Behavior")]
		public bool UnloadCollapsedOnReload
		{
			get { return _unloadCollapsedOnReload; }
			set { _unloadCollapsedOnReload = value; }
		}

		private int _indent = 19;
		[DefaultValue(19), Category("Behavior")]
		public int Indent
		{
			get { return _indent; }
			set
			{
				_indent = value;
				UpdateView();
			}
		}

		private Color _lineColor = SystemColors.ControlDark;
		[Category("Behavior")]
		public Color LineColor
		{
			get { return _lineColor; }
			set
			{
				_lineColor = value;
				CreateLinePen();
				UpdateView();
			}
		}

		private Color _dragDropMarkColor = Color.Black;
		[Category("Behavior")]
		public Color DragDropMarkColor
		{
			get { return _dragDropMarkColor; }
			set
			{
				_dragDropMarkColor = value;
				CreateMarkPen();
			}
		}

		private float _dragDropMarkWidth = 3.0f;
		[DefaultValue(3.0f), Category("Behavior")]
		public float DragDropMarkWidth
		{
			get { return _dragDropMarkWidth; }
			set
			{
				_dragDropMarkWidth = value;
				CreateMarkPen();
			}
		}

		private bool _highlightDropPosition = true;
		[DefaultValue(true), Category("Behavior")]
		public bool HighlightDropPosition
		{
			get { return _highlightDropPosition; }
			set { _highlightDropPosition = value; }
		}

		private TreeColumnCollection _columns;
		[Category("Behavior"), DesignerSerializationVisibility(DesignerSerializationVisibility.Content)]
		public Collection<TreeColumn> Columns
		{
			get { return _columns; }
		}

		private NodeControlsCollection _controls;
		[Category("Behavior"), DesignerSerializationVisibility(DesignerSerializationVisibility.Content)]
		[Editor(typeof(NodeControlCollectionEditor), typeof(UITypeEditor))]
		public Collection<NodeControl> NodeControls
		{
			get
			{
				return _controls;
			}
		}

		private bool _asyncExpanding;
		/// <summary>
		/// When set to true, node contents will be read in background thread.
		/// </summary>
		[Category("Behavior"), DefaultValue(false), Description("Read children in a background thread when expanding.")]
		public bool AsyncExpanding
		{
			get { return _asyncExpanding; }
			set { _asyncExpanding = value; }
		}

		#endregion

		#region RunTime

		private IToolTipProvider _defaultToolTipProvider = null;
		[Browsable(false)]
		public IToolTipProvider DefaultToolTipProvider
		{
			get { return _defaultToolTipProvider; }
			set { _defaultToolTipProvider = value; }
		}

		[Browsable(false)]
		public IEnumerable<TreeNodeAdv> AllNodes
		{
			get
			{
				if (_root.Nodes.Count > 0)
				{
					TreeNodeAdv node = _root.Nodes[0];
					while (node != null)
					{
						yield return node;
						if (node.Nodes.Count > 0)
							node = node.Nodes[0];
						else if (node.NextNode != null)
							node = node.NextNode;
						else
							node = node.BottomNode;
					}
				}
			}
		}

		private DropPosition _dropPosition;
		[Browsable(false)]
		public DropPosition DropPosition
		{
			get { return _dropPosition; }
			set { _dropPosition = value; }
		}

		private TreeNodeAdv _root;
		[Browsable(false)]
		public TreeNodeAdv Root
		{
			get { return _root; }
		}

		private ReadOnlyCollection<TreeNodeAdv> _readonlySelection;
		[Browsable(false)]
		public ReadOnlyCollection<TreeNodeAdv> SelectedNodes
		{
			get
			{
				return _readonlySelection;
			}
		}

		[Browsable(false)]
		public TreeNodeAdv SelectedNode
		{
			get
			{
				if (Selection.Count > 0)
				{
					if (CurrentNode != null && CurrentNode.IsSelected)
						return CurrentNode;
					else
						return Selection[0];
				}
				else
					return null;
			}
			set
			{
				if (SelectedNode == value)
					return;

				BeginUpdate();
				try
				{
					if (value == null)
					{
						ClearSelectionInternal();
					}
					else
					{
						if (!IsMyNode(value))
							throw new ArgumentException();

						ClearSelectionInternal();
						value.IsSelected = true;
						CurrentNode = value;
						EnsureVisible(value);
					}
				}
				finally
				{
					EndUpdate();
				}
			}
		}

		private TreeNodeAdv _currentNode;
		[Browsable(false)]
		public TreeNodeAdv CurrentNode
		{
			get { return _currentNode; }
			internal set { _currentNode = value; }
		}

        [Browsable(false)]
        public int ItemCount
        {
            get { return RowMap.Count; }
        }

		/// <summary>
		/// Indicates the distance the content is scrolled to the left
		/// </summary>
		[Browsable(false)]
		public int HorizontalScrollPosition
		{
			get
			{
				if (_hScrollBar.Visible)
					return _hScrollBar.Value;
				else
					return 0;
			}
		}

		#endregion

		#endregion

	}
}

```

`Aga.Controls/Tree/TreeViewAdv.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Drawing;
using System.Security.Permissions;
using System.Threading;
using System.Windows.Forms;
using System.Collections;

using Aga.Controls.Tree.NodeControls;
using Aga.Controls.Threading;


namespace Aga.Controls.Tree
{
	/// <summary>
	/// Extensible advanced <see cref="TreeView"/> implemented in 100% managed C# code.
	/// Features: Model/View architecture. Multiple column per node. Ability to select
	/// multiple tree nodes. Different types of controls for each node column: 
	/// <see cref="CheckBox"/>, Icon, Label... Drag and Drop highlighting. Load on
	/// demand of nodes. Incremental search of nodes.
	/// </summary>
	public partial class TreeViewAdv : Control
	{
        public static Action<Graphics, Rectangle, bool> CustomCheckRenderFunc;
        public static Action<Graphics, Rectangle, bool, bool> CustomColumnBackgroundRenderFunc;
        public static Action<Graphics, Rectangle, Font, string> CustomColumnTextRenderFunc;
        public static Color CustomSelectedTextColor = SystemColors.ControlText;
        public static Pen CustomHorizontalLinePen = new Pen(Color.FromArgb(247, 247, 247));
        public static Action<Graphics, Rectangle, bool> CustomPlusMinusRenderFunc;
        public static Brush CustomSelectedRowBrush = new SolidBrush(Color.FromArgb(240, 240, 240));

        private const int LeftMargin = 7;
		internal const int ItemDragSensivity = 4;
		private readonly int _columnHeaderHeight;
		private const int DividerWidth = 9;
		private const int DividerCorrectionGap = -2;

		private Pen _linePen;
		private Pen _markPen;
		private bool _suspendUpdate;
		private bool _needFullUpdate;
		private bool _fireSelectionEvent;
		private NodePlusMinus _plusMinus;
		private ToolTip _toolTip;
		private DrawContext _measureContext;
		private TreeColumn _hotColumn;
		private IncrementalSearch _search;
		private List<TreeNodeAdv> _expandingNodes = new List<TreeNodeAdv>();
		private AbortableThreadPool _threadPool = new AbortableThreadPool();

		private float dpiX;
		private float dpiY;
		private float dpiXscale = 1;
		private float dpiYscale = 1;

		#region Public Events

		[Category("Action")]
		public event ItemDragEventHandler ItemDrag;
		private void OnItemDrag(MouseButtons buttons, object item)
		{
			if (ItemDrag != null)
				ItemDrag(this, new ItemDragEventArgs(buttons, item));
		}

		[Category("Behavior")]
		public event EventHandler<TreeNodeAdvMouseEventArgs> NodeMouseClick;
		private void OnNodeMouseClick(TreeNodeAdvMouseEventArgs args)
		{
			if (NodeMouseClick != null)
				NodeMouseClick(this, args);
		}

		[Category("Behavior")]
		public event EventHandler<TreeNodeAdvMouseEventArgs> NodeMouseDoubleClick;
		private void OnNodeMouseDoubleClick(TreeNodeAdvMouseEventArgs args)
		{
			if (NodeMouseDoubleClick != null)
				NodeMouseDoubleClick(this, args);
		}

		[Category("Behavior")]
		public event EventHandler<TreeColumnEventArgs> ColumnWidthChanged;
		internal void OnColumnWidthChanged(TreeColumn column)
		{
			if (ColumnWidthChanged != null)
				ColumnWidthChanged(this, new TreeColumnEventArgs(column));
		}

		[Category("Behavior")]
		public event EventHandler<TreeColumnEventArgs> ColumnReordered;
		internal void OnColumnReordered(TreeColumn column)
		{
			if (ColumnReordered != null)
				ColumnReordered(this, new TreeColumnEventArgs(column));
		}

		[Category("Behavior")]
		public event EventHandler<TreeColumnEventArgs> ColumnClicked;
		internal void OnColumnClicked(TreeColumn column)
		{
			if (ColumnClicked != null)
				ColumnClicked(this, new TreeColumnEventArgs(column));
		}

		[Category("Behavior")]
		public event EventHandler SelectionChanged;
		internal void OnSelectionChanged()
		{
			if (SuspendSelectionEvent)
				_fireSelectionEvent = true;
			else
			{
				_fireSelectionEvent = false;
				if (SelectionChanged != null)
					SelectionChanged(this, EventArgs.Empty);
			}
		}

		[Category("Behavior")]
		public event EventHandler<TreeViewAdvEventArgs> Collapsing;
		private void OnCollapsing(TreeNodeAdv node)
		{
			if (Collapsing != null)
				Collapsing(this, new TreeViewAdvEventArgs(node));
		}

		[Category("Behavior")]
		public event EventHandler<TreeViewAdvEventArgs> Collapsed;
		private void OnCollapsed(TreeNodeAdv node)
		{
			if (Collapsed != null)
				Collapsed(this, new TreeViewAdvEventArgs(node));
		}

		[Category("Behavior")]
		public event EventHandler<TreeViewAdvEventArgs> Expanding;
		private void OnExpanding(TreeNodeAdv node)
		{
			if (Expanding != null)
				Expanding(this, new TreeViewAdvEventArgs(node));
		}

		[Category("Behavior")]
		public event EventHandler<TreeViewAdvEventArgs> Expanded;
		private void OnExpanded(TreeNodeAdv node)
		{
			if (Expanded != null)
				Expanded(this, new TreeViewAdvEventArgs(node));
		}

		[Category("Behavior")]
		public event EventHandler GridLineStyleChanged;
		private void OnGridLineStyleChanged()
		{
			if (GridLineStyleChanged != null)
				GridLineStyleChanged(this, EventArgs.Empty);
		}

		[Category("Behavior")]
		public event ScrollEventHandler Scroll;
		protected virtual void OnScroll(ScrollEventArgs e)
		{
			if (Scroll != null)
				Scroll(this, e);
		}

		[Category("Behavior")]
		public event EventHandler<TreeViewRowDrawEventArgs> RowDraw;
		protected virtual void OnRowDraw(PaintEventArgs e, TreeNodeAdv node, DrawContext context, int row, Rectangle rowRect)
		{
			if (RowDraw != null)
			{
				TreeViewRowDrawEventArgs args = new TreeViewRowDrawEventArgs(e.Graphics, e.ClipRectangle, node, context, row, rowRect);
				RowDraw(this, args);
			}
		}

		/// <summary>
		/// Fires when control is going to draw. Can be used to change text or back color
		/// </summary>
		[Category("Behavior")]
		public event EventHandler<DrawEventArgs> DrawControl;

		internal bool DrawControlMustBeFired()
		{
			return DrawControl != null;
		}

		internal void FireDrawControl(DrawEventArgs args)
		{
			OnDrawControl(args);
		}

		protected virtual void OnDrawControl(DrawEventArgs args)
		{
			if (DrawControl != null)
				DrawControl(this, args);
		}


		[Category("Drag Drop")]
		public event EventHandler<DropNodeValidatingEventArgs> DropNodeValidating;
		protected virtual void OnDropNodeValidating(Point point, ref TreeNodeAdv node)
		{
			if (DropNodeValidating != null)
			{
				DropNodeValidatingEventArgs args = new DropNodeValidatingEventArgs(point, node);
				DropNodeValidating(this, args);
				node = args.Node;
			}
		}
		#endregion

		public TreeViewAdv()
		{
			InitializeComponent();
			SetDPI();
			SetStyle(ControlStyles.AllPaintingInWmPaint
				| ControlStyles.UserPaint
				| ControlStyles.OptimizedDoubleBuffer
				| ControlStyles.ResizeRedraw
				| ControlStyles.Selectable
				, true);


			if (Application.RenderWithVisualStyles)
				_columnHeaderHeight = 20;
			else
				_columnHeaderHeight = 17;
			_columnHeaderHeight = GetScaledSize(_columnHeaderHeight);

			//BorderStyle = BorderStyle.Fixed3D;
			_hScrollBar.Height = SystemInformation.HorizontalScrollBarHeight;
			_vScrollBar.Width = SystemInformation.VerticalScrollBarWidth;
			_rowLayout = new FixedRowHeightLayout(this, RowHeight);
			_rowMap = new List<TreeNodeAdv>();
			_selection = new List<TreeNodeAdv>();
			_readonlySelection = new ReadOnlyCollection<TreeNodeAdv>(_selection);
			_columns = new TreeColumnCollection(this);
			_toolTip = new ToolTip();

			_measureContext = new DrawContext();
			_measureContext.Font = Font;
			_measureContext.Graphics = Graphics.FromImage(new Bitmap(1, 1));

			Input = new NormalInputState(this);
			_search = new IncrementalSearch(this);
			CreateNodes();
			CreatePens();

			ArrangeControls();

			_plusMinus = new NodePlusMinus();
			_controls = new NodeControlsCollection(this);

			Font = _font;
			ExpandingIcon.IconChanged += ExpandingIconChanged;

            BackColor = Color.Black;
		}

		public void SetDPI()
		{
			// https://msdn.microsoft.com/en-us/library/windows/desktop/dn469266(v=vs.85).aspx
			const int _default_dpi = 96;
			Graphics g = this.CreateGraphics();

			try
			{
				this.dpiX = g.DpiX;
				this.dpiY = g.DpiY;
			}
			finally
			{
				g.Dispose();
			}
			if (dpiX > 0)
			{
				this.dpiXscale = dpiX / _default_dpi;
			}
			if (dpiY > 0)
			{
				this.dpiYscale = dpiY / _default_dpi;
			}
		}

		public int GetScaledSize(int size, bool useY = true)
		{
			int scaledsize = size;

			if (useY && this.dpiYscale > 1)
			{
				scaledsize = (int)(this.dpiYscale * size);
			}
			else if (this.dpiXscale > 1)
			{
				scaledsize = (int)(this.dpiXscale * size);
			}
			return scaledsize;
		}

		void ExpandingIconChanged(object sender, EventArgs e)
		{
			if (IsHandleCreated && !IsDisposed)
				BeginInvoke(new MethodInvoker(DrawIcons));
		}

		private void DrawIcons()
		{
			using (Graphics gr = Graphics.FromHwnd(this.Handle))
			{
				//Apply the same Graphics Transform logic as used in OnPaint.
				int y = 0;
				if (UseColumns)
				{
					y += ColumnHeaderHeight;
					if (Columns.Count == 0)
						return;
				}
				int firstRowY = _rowLayout.GetRowBounds(FirstVisibleRow).Y;
				y -= firstRowY;
				gr.ResetTransform();
				gr.TranslateTransform(-OffsetX, y);

				DrawContext context = new DrawContext();
				context.Graphics = gr;
				for (int i = 0; i < _expandingNodes.Count; i++)
				{
					foreach (NodeControlInfo item in GetNodeControls(_expandingNodes[i]))
					{
						if (item.Control is ExpandingIcon)
						{
							Rectangle bounds = item.Bounds;
							if (item.Node.Parent == null && UseColumns)
								bounds.Location = Point.Empty; // display root expanding icon at 0,0

							context.Bounds = bounds;
							item.Control.Draw(item.Node, context);
						}
					}
				}
			}
		}

		#region Public Methods

		public TreePath GetPath(TreeNodeAdv node)
		{
			if (node == _root)
				return TreePath.Empty;
			else
			{
				Stack<object> stack = new Stack<object>();
				while (node != _root && node != null)
				{
					stack.Push(node.Tag);
					node = node.Parent;
				}
				return new TreePath(stack.ToArray());
			}
		}

		public TreeNodeAdv GetNodeAt(Point point)
		{
			NodeControlInfo info = GetNodeControlInfoAt(point);
			return info.Node;
		}

		public NodeControlInfo GetNodeControlInfoAt(Point point)
		{
			if (point.X < 0 || point.Y < 0)
				return NodeControlInfo.Empty;

			int row = _rowLayout.GetRowAt(point);
			if (row < RowCount && row >= 0)
				return GetNodeControlInfoAt(RowMap[row], point);
			else
				return NodeControlInfo.Empty;
		}

		private NodeControlInfo GetNodeControlInfoAt(TreeNodeAdv node, Point point)
		{
			Rectangle rect = _rowLayout.GetRowBounds(FirstVisibleRow);
			point.Y += (rect.Y - ColumnHeaderHeight);
			point.X += OffsetX;
			foreach (NodeControlInfo info in GetNodeControls(node))
				if (info.Bounds.Contains(point))
					return info;

			if (FullRowSelect)
				return new NodeControlInfo(null, Rectangle.Empty, node);
			else
				return NodeControlInfo.Empty;
		}

		public void BeginUpdate()
		{
			_suspendUpdate = true;
			SuspendSelectionEvent = true;
		}

		public void EndUpdate()
		{
			_suspendUpdate = false;
			if (_needFullUpdate)
				FullUpdate();
			else
				UpdateView();
			SuspendSelectionEvent = false;
		}

		public void ExpandAll()
		{
			_root.ExpandAll();
		}

		public void CollapseAll()
		{
			_root.CollapseAll();
		}

		/// <summary>
		/// Expand all parent nodes, and scroll to the specified node
		/// </summary>
		public void EnsureVisible(TreeNodeAdv node)
		{
			if (node == null)
				throw new ArgumentNullException("node");

			if (!IsMyNode(node))
				throw new ArgumentException();

			TreeNodeAdv parent = node.Parent;
			while (parent != _root)
			{
				parent.IsExpanded = true;
				parent = parent.Parent;
			}
			ScrollTo(node);
		}

		/// <summary>
		/// Make node visible, scroll if needed. All parent nodes of the specified node must be expanded
		/// </summary>
		/// <param name="node"></param>
		public void ScrollTo(TreeNodeAdv node)
		{
			if (node == null)
				throw new ArgumentNullException("node");

			if (!IsMyNode(node))
				throw new ArgumentException();

			if (node.Row < 0)
				CreateRowMap();

			int row = -1;

			if (node.Row < FirstVisibleRow)
				row = node.Row;
			else
			{
				int pageStart = _rowLayout.GetRowBounds(FirstVisibleRow).Top;
				int rowBottom = _rowLayout.GetRowBounds(node.Row).Bottom;
				if (rowBottom > pageStart + DisplayRectangle.Height - ColumnHeaderHeight)
					row = _rowLayout.GetFirstRow(node.Row);
			}

			if (row >= _vScrollBar.Minimum && row <= _vScrollBar.Maximum)
				_vScrollBar.Value = row;
		}

		public void ClearSelection()
		{
			BeginUpdate();
			try
			{
				ClearSelectionInternal();
			}
			finally
			{
				EndUpdate();
			}
		}

		internal void ClearSelectionInternal()
		{
			while (Selection.Count > 0)
			{
				var t = Selection[0];
				t.IsSelected = false;
				Selection.Remove(t); //hack
			}
		}

		#endregion

		protected override void OnSizeChanged(EventArgs e)
		{
			ArrangeControls();
			SafeUpdateScrollBars();
			base.OnSizeChanged(e);
		}

		private void ArrangeControls()
		{
			int hBarSize = _hScrollBar.Height;
			int vBarSize = _vScrollBar.Width;
			Rectangle clientRect = ClientRectangle;

			_hScrollBar.SetBounds(clientRect.X, clientRect.Bottom - hBarSize,
				clientRect.Width - vBarSize, hBarSize);

			_vScrollBar.SetBounds(clientRect.Right - vBarSize, clientRect.Y,
				vBarSize, clientRect.Height - hBarSize);
		}

		private void SafeUpdateScrollBars()
		{
			if (InvokeRequired)
				BeginInvoke(new MethodInvoker(UpdateScrollBars));
			else
				UpdateScrollBars();
		}

		private void UpdateScrollBars()
		{
			UpdateVScrollBar();
			UpdateHScrollBar();
			UpdateVScrollBar();
			UpdateHScrollBar();
			_hScrollBar.Width = DisplayRectangle.Width;
			_vScrollBar.Height = DisplayRectangle.Height;
		}

		private void UpdateHScrollBar()
		{
			_hScrollBar.Maximum = ContentWidth;
			_hScrollBar.LargeChange = Math.Max(DisplayRectangle.Width, 0);
			_hScrollBar.SmallChange = 5;
			_hScrollBar.Visible = _hScrollBar.LargeChange < _hScrollBar.Maximum;
			_hScrollBar.Value = Math.Min(_hScrollBar.Value, _hScrollBar.Maximum - _hScrollBar.LargeChange + 1);
		}

		private void UpdateVScrollBar()
		{
			_vScrollBar.Maximum = Math.Max(RowCount - 1, 0);
			_vScrollBar.LargeChange = _rowLayout.PageRowCount;
			_vScrollBar.Visible = (RowCount > 0) && (_vScrollBar.LargeChange <= _vScrollBar.Maximum);
			_vScrollBar.Value = Math.Min(_vScrollBar.Value, _vScrollBar.Maximum - _vScrollBar.LargeChange + 1);
		}

		protected override CreateParams CreateParams
		{
			[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
			get
			{
				CreateParams res = base.CreateParams;
				switch (BorderStyle)
				{
					case BorderStyle.FixedSingle:
						res.Style |= 0x800000;
						break;
					case BorderStyle.Fixed3D:
						res.ExStyle |= 0x200;
						break;
				}
				return res;
			}
		}

		protected override void OnGotFocus(EventArgs e)
		{
			UpdateView();
			ChangeInput();
			base.OnGotFocus(e);
		}

		protected override void OnFontChanged(EventArgs e)
		{
			base.OnFontChanged(e);
			_measureContext.Font = Font;
			FullUpdate();
		}

		internal IEnumerable<NodeControlInfo> GetNodeControls(TreeNodeAdv node)
		{
			if (node == null)
				yield break;
			Rectangle rowRect = _rowLayout.GetRowBounds(node.Row);
			foreach (NodeControlInfo n in GetNodeControls(node, rowRect))
				yield return n;
		}

		internal IEnumerable<NodeControlInfo> GetNodeControls(TreeNodeAdv node, Rectangle rowRect)
		{
			if (node == null)
				yield break;

			int scaledIndent = node.Tree.GetScaledSize(_indent, false);
			int y = rowRect.Y;
			int x = (node.Level - 1) * scaledIndent + LeftMargin;
			int width = 0;
			if (node.Row == 0 && ShiftFirstNode)
				x -= scaledIndent;
			Rectangle rect = Rectangle.Empty;

			if (ShowPlusMinus)
			{
				width = _plusMinus.GetActualSize(node, _measureContext).Width;
				rect = new Rectangle(x, y, width, rowRect.Height);
				if (UseColumns && Columns.Count > 0 && Columns[0].Width < rect.Right)
					rect.Width = Columns[0].Width - x;

				yield return new NodeControlInfo(_plusMinus, rect, node);
				x += width;
			}

			if (!UseColumns)
			{
				foreach (NodeControl c in NodeControls)
				{
					Size s = c.GetActualSize(node, _measureContext);
					if (!s.IsEmpty)
					{
						width = s.Width;
						rect = new Rectangle(x, y, width, rowRect.Height);
						x += rect.Width;
						yield return new NodeControlInfo(c, rect, node);
					}
				}
			}
			else
			{
				int right = 0;
				foreach (TreeColumn col in Columns)
				{
					if (col.IsVisible && col.Width > 0)
					{
						right += col.Width;
						for (int i = 0; i < NodeControls.Count; i++)
						{
							NodeControl nc = NodeControls[i];
							if (nc.ParentColumn == col)
							{
								Size s = nc.GetActualSize(node, _measureContext);
								if (!s.IsEmpty)
								{
									bool isLastControl = true;
									for (int k = i + 1; k < NodeControls.Count; k++)
										if (NodeControls[k].ParentColumn == col)
										{
											isLastControl = false;
											break;
										}

									width = right - x;
									if (!isLastControl)
										width = s.Width;
									int maxWidth = Math.Max(0, right - x);
									rect = new Rectangle(x, y, Math.Min(maxWidth, width), rowRect.Height);
									x += width;
									yield return new NodeControlInfo(nc, rect, node);
								}
							}
						}
						x = right;
					}
				}
			}
		}

		internal static double Dist(Point p1, Point p2)
		{
			return Math.Sqrt(Math.Pow(p1.X - p2.X, 2) + Math.Pow(p1.Y - p2.Y, 2));
		}

		public void FullUpdate()
		{
			HideEditor();
			if (InvokeRequired)
				BeginInvoke(new MethodInvoker(UnsafeFullUpdate));
			else
				UnsafeFullUpdate();
		}

		private void UnsafeFullUpdate()
		{
			_rowLayout.ClearCache();
			CreateRowMap();
			SafeUpdateScrollBars();
			UpdateView();
			_needFullUpdate = false;
		}

		internal void UpdateView()
		{
			if (!_suspendUpdate)
				Invalidate(false);
		}

		internal void UpdateHeaders()
		{
			Invalidate(new Rectangle(0, 0, Width, ColumnHeaderHeight));
		}

		internal void UpdateColumns()
		{
			FullUpdate();
		}

		private void CreateNodes()
		{
			Selection.Clear();
			SelectionStart = null;
			_root = new TreeNodeAdv(this, null);
			_root.IsExpanded = true;
			if (_root.Nodes.Count > 0)
				CurrentNode = _root.Nodes[0];
			else
				CurrentNode = null;
		}

		internal void ReadChilds(TreeNodeAdv parentNode)
		{
			ReadChilds(parentNode, false);
		}

		internal void ReadChilds(TreeNodeAdv parentNode, bool performFullUpdate)
		{
			if (!parentNode.IsLeaf)
			{
				parentNode.IsExpandedOnce = true;
				parentNode.Nodes.Clear();

				if (Model != null)
				{
					IEnumerable items = Model.GetChildren(GetPath(parentNode));
					if (items != null)
						foreach (object obj in items)
						{
							AddNewNode(parentNode, obj, -1);
							if (performFullUpdate)
								FullUpdate();
						}
				}

				if (parentNode.AutoExpandOnStructureChanged)
					parentNode.ExpandAll();
			}
		}

		private void AddNewNode(TreeNodeAdv parent, object tag, int index)
		{
			TreeNodeAdv node = new TreeNodeAdv(this, tag);
			AddNode(parent, index, node);
		}

		private void AddNode(TreeNodeAdv parent, int index, TreeNodeAdv node)
		{
			if (index >= 0 && index < parent.Nodes.Count)
				parent.Nodes.Insert(index, node);
			else
				parent.Nodes.Add(node);

			node.IsLeaf = Model.IsLeaf(GetPath(node));
			if (node.IsLeaf)
				node.Nodes.Clear();
			if (!LoadOnDemand || node.IsExpandedOnce)
				ReadChilds(node);
		}

		private struct ExpandArgs
		{
			public TreeNodeAdv Node;
			public bool Value;
			public bool IgnoreChildren;
		}

		public void AbortBackgroundExpandingThreads()
		{
			_threadPool.CancelAll(true);
			for (int i = 0; i < _expandingNodes.Count; i++)
				_expandingNodes[i].IsExpandingNow = false;
			_expandingNodes.Clear();
			Invalidate();
		}

		internal void SetIsExpanded(TreeNodeAdv node, bool value, bool ignoreChildren)
		{
			ExpandArgs eargs = new ExpandArgs();
			eargs.Node = node;
			eargs.Value = value;
			eargs.IgnoreChildren = ignoreChildren;

			if (AsyncExpanding && LoadOnDemand && !_threadPool.IsMyThread(Thread.CurrentThread))
			{
				WaitCallback wc = delegate(object argument) { SetIsExpanded((ExpandArgs)argument); };
				_threadPool.QueueUserWorkItem(wc, eargs);
			}
			else
				SetIsExpanded(eargs);
		}

		private void SetIsExpanded(ExpandArgs eargs)
		{
			bool update = !eargs.IgnoreChildren && !AsyncExpanding;
			if (update)
				BeginUpdate();
			try
			{
				if (IsMyNode(eargs.Node) && eargs.Node.IsExpanded != eargs.Value)
					SetIsExpanded(eargs.Node, eargs.Value);

				if (!eargs.IgnoreChildren)
					SetIsExpandedRecursive(eargs.Node, eargs.Value);
			}
			finally
			{
				if (update)
					EndUpdate();
			}
		}

		internal void SetIsExpanded(TreeNodeAdv node, bool value)
		{
			if (Root == node && !value)
				return; //Can't collapse root node

			if (value)
			{
				OnExpanding(node);
				node.OnExpanding();
			}
			else
			{
				OnCollapsing(node);
				node.OnCollapsing();
			}

			if (value && !node.IsExpandedOnce)
			{
				if (AsyncExpanding && LoadOnDemand)
				{
					AddExpandingNode(node);
					node.AssignIsExpanded(true);
					Invalidate();
				}
				ReadChilds(node, AsyncExpanding);
				RemoveExpandingNode(node);
			}
			node.AssignIsExpanded(value);
			SmartFullUpdate();

			if (value)
			{
				OnExpanded(node);
				node.OnExpanded();
			}
			else
			{
				OnCollapsed(node);
				node.OnCollapsed();
			}
		}

		private void RemoveExpandingNode(TreeNodeAdv node)
		{
			node.IsExpandingNow = false;
			_expandingNodes.Remove(node);
			if (_expandingNodes.Count <= 0)
				ExpandingIcon.Stop();
		}

		private void AddExpandingNode(TreeNodeAdv node)
		{
			node.IsExpandingNow = true;
			_expandingNodes.Add(node);
			ExpandingIcon.Start();
		}

		internal void SetIsExpandedRecursive(TreeNodeAdv root, bool value)
		{
			for (int i = 0; i < root.Nodes.Count; i++)
			{
				TreeNodeAdv node = root.Nodes[i];
				node.IsExpanded = value;
				SetIsExpandedRecursive(node, value);
			}
		}

		private void CreateRowMap()
		{
			RowMap.Clear();
			int row = 0;
			_contentWidth = 0;
			foreach (TreeNodeAdv node in VisibleNodes)
			{
				node.Row = row;
				RowMap.Add(node);
				if (!UseColumns)
				{
					_contentWidth = Math.Max(_contentWidth, GetNodeWidth(node));
				}
				row++;
			}
			if (UseColumns)
			{
				_contentWidth = 0;
				foreach (TreeColumn col in _columns)
					if (col.IsVisible)
						_contentWidth += col.Width;
			}
		}

		private int GetNodeWidth(TreeNodeAdv node)
		{
			if (node.RightBounds == null)
			{
				Rectangle res = GetNodeBounds(GetNodeControls(node, Rectangle.Empty));
				node.RightBounds = res.Right;
			}
			return node.RightBounds.Value;
		}

		internal Rectangle GetNodeBounds(TreeNodeAdv node)
		{
			return GetNodeBounds(GetNodeControls(node));
		}

		private Rectangle GetNodeBounds(IEnumerable<NodeControlInfo> nodeControls)
		{
			Rectangle res = Rectangle.Empty;
			foreach (NodeControlInfo info in nodeControls)
			{
				if (res == Rectangle.Empty)
					res = info.Bounds;
				else
					res = Rectangle.Union(res, info.Bounds);
			}
			return res;
		}

		private void _vScrollBar_ValueChanged(object sender, EventArgs e)
		{
			FirstVisibleRow = _vScrollBar.Value;
		}

		private void _hScrollBar_ValueChanged(object sender, EventArgs e)
		{
			OffsetX = _hScrollBar.Value;
		}

		private void _vScrollBar_Scroll(object sender, ScrollEventArgs e)
		{
			OnScroll(e);
		}

		private void _hScrollBar_Scroll(object sender, ScrollEventArgs e)
		{
			OnScroll(e);
		}

		internal void SmartFullUpdate()
		{
			if (_suspendUpdate)
				_needFullUpdate = true;
			else
				FullUpdate();
		}

		internal bool IsMyNode(TreeNodeAdv node)
		{
			if (node == null)
				return false;

			if (node.Tree != this)
				return false;

			while (node.Parent != null)
				node = node.Parent;

			return node == _root;
		}

		internal void UpdateSelection()
		{
			bool flag = false;

			if (!IsMyNode(CurrentNode))
				CurrentNode = null;
			if (!IsMyNode(_selectionStart))
				_selectionStart = null;

			for (int i = Selection.Count - 1; i >= 0; i--)
				if (!IsMyNode(Selection[i]))
				{
					flag = true;
					Selection.RemoveAt(i);
				}

			if (flag)
				OnSelectionChanged();
		}

		internal void ChangeColumnWidth(TreeColumn column)
		{
			if (!(_input is ResizeColumnState))
			{
				FullUpdate();
				OnColumnWidthChanged(column);
			}
		}

		public TreeNodeAdv FindNode(TreePath path)
		{
			return FindNode(path, false);
		}

		public TreeNodeAdv FindNode(TreePath path, bool readChilds)
		{
			if (path.IsEmpty())
				return _root;
			else
				return FindNode(_root, path, 0, readChilds);
		}

		private TreeNodeAdv FindNode(TreeNodeAdv root, TreePath path, int level, bool readChilds)
		{
			if (!root.IsExpandedOnce && readChilds)
				ReadChilds(root);

			for (int i = 0; i < root.Nodes.Count; i++)
			{
				TreeNodeAdv node = root.Nodes[i];
				if (node.Tag == path.FullPath[level])
				{
					if (level == path.FullPath.Length - 1)
						return node;
					else
						return FindNode(node, path, level + 1, readChilds);
				}
			}
			return null;
		}

		public TreeNodeAdv FindNodeByTag(object tag)
		{
			return FindNodeByTag(_root, tag);
		}

		private TreeNodeAdv FindNodeByTag(TreeNodeAdv root, object tag)
		{
			foreach (TreeNodeAdv node in root.Nodes)
			{
				if (node.Tag == tag)
					return node;
				TreeNodeAdv res = FindNodeByTag(node, tag);
				if (res != null)
					return res;
			}
			return null;
		}

		public void SelectAllNodes()
		{
			SuspendSelectionEvent = true;
			try
			{
				if (SelectionMode == TreeSelectionMode.MultiSameParent)
				{
					if (CurrentNode != null)
					{
						foreach (TreeNodeAdv n in CurrentNode.Parent.Nodes)
							n.IsSelected = true;
					}
				}
				else if (SelectionMode == TreeSelectionMode.Multi)
				{
					SelectNodes(Root.Nodes);
				}
			}
			finally
			{
				SuspendSelectionEvent = false;
			}
		}

		private void SelectNodes(Collection<TreeNodeAdv> nodes)
		{
			foreach (TreeNodeAdv n in nodes)
			{
				n.IsSelected = true;
				if (n.IsExpanded)
					SelectNodes(n.Nodes);
			}
		}

		#region ModelEvents
		private void BindModelEvents()
		{
			_model.NodesChanged += new EventHandler<TreeModelEventArgs>(_model_NodesChanged);
			_model.NodesInserted += new EventHandler<TreeModelEventArgs>(_model_NodesInserted);
			_model.NodesRemoved += new EventHandler<TreeModelEventArgs>(_model_NodesRemoved);
			_model.StructureChanged += new EventHandler<TreePathEventArgs>(_model_StructureChanged);
		}

		private void UnbindModelEvents()
		{
			_model.NodesChanged -= new EventHandler<TreeModelEventArgs>(_model_NodesChanged);
			_model.NodesInserted -= new EventHandler<TreeModelEventArgs>(_model_NodesInserted);
			_model.NodesRemoved -= new EventHandler<TreeModelEventArgs>(_model_NodesRemoved);
			_model.StructureChanged -= new EventHandler<TreePathEventArgs>(_model_StructureChanged);
		}

		private void _model_StructureChanged(object sender, TreePathEventArgs e)
		{
			if (e.Path == null)
				throw new ArgumentNullException();

			TreeNodeAdv node = FindNode(e.Path);
			if (node != null)
			{
				if (node != Root)
					node.IsLeaf = Model.IsLeaf(GetPath(node));

				var list = new Dictionary<object, object>();
				SaveExpandedNodes(node, list);
				ReadChilds(node);
				RestoreExpandedNodes(node, list);

				UpdateSelection();
				SmartFullUpdate();
			}
			//else 
			//	throw new ArgumentException("Path not found");
		}

		private void RestoreExpandedNodes(TreeNodeAdv node, Dictionary<object, object> list)
		{
			if (node.Tag != null && list.ContainsKey(node.Tag))
			{
				node.IsExpanded = true;
				foreach (var child in node.Children)
					RestoreExpandedNodes(child, list);
			}
		}

		private void SaveExpandedNodes(TreeNodeAdv node, Dictionary<object, object> list)
		{
			if (node.IsExpanded && node.Tag != null)
			{
				list.Add(node.Tag, null);
				foreach (var child in node.Children)
					SaveExpandedNodes(child, list);
			}
		}

		private void _model_NodesRemoved(object sender, TreeModelEventArgs e)
		{
			TreeNodeAdv parent = FindNode(e.Path);
			if (parent != null)
			{
				if (e.Indices != null)
				{
					List<int> list = new List<int>(e.Indices);
					list.Sort();
					for (int n = list.Count - 1; n >= 0; n--)
					{
						int index = list[n];
						if (index >= 0 && index <= parent.Nodes.Count)
							parent.Nodes.RemoveAt(index);
						else
							throw new ArgumentOutOfRangeException("Index out of range");
					}
				}
				else
				{
					for (int i = parent.Nodes.Count - 1; i >= 0; i--)
					{
						for (int n = 0; n < e.Children.Length; n++)
							if (parent.Nodes[i].Tag == e.Children[n])
							{
								parent.Nodes.RemoveAt(i);
								break;
							}
					}
				}
			}
			UpdateSelection();
			SmartFullUpdate();
		}

		private void _model_NodesInserted(object sender, TreeModelEventArgs e)
		{
			if (e.Indices == null)
				throw new ArgumentNullException("Indices");

			TreeNodeAdv parent = FindNode(e.Path);
			if (parent != null)
			{
				for (int i = 0; i < e.Children.Length; i++)
					AddNewNode(parent, e.Children[i], e.Indices[i]);
			}
			SmartFullUpdate();
		}

		private void _model_NodesChanged(object sender, TreeModelEventArgs e)
		{
			TreeNodeAdv parent = FindNode(e.Path);
			if (parent != null && parent.IsVisible && parent.IsExpanded)
			{
				if (InvokeRequired)
					BeginInvoke(new UpdateContentWidthDelegate(ClearNodesSize), e, parent);
				else
					ClearNodesSize(e, parent);
				SmartFullUpdate();
			}
		}

		private delegate void UpdateContentWidthDelegate(TreeModelEventArgs e, TreeNodeAdv parent);
		private void ClearNodesSize(TreeModelEventArgs e, TreeNodeAdv parent)
		{
			if (e.Indices != null)
			{
				foreach (int index in e.Indices)
				{
					if (index >= 0 && index < parent.Nodes.Count)
					{
						TreeNodeAdv node = parent.Nodes[index];
						node.Height = node.RightBounds = null;
					}
					else
						throw new ArgumentOutOfRangeException("Index out of range");
				}
			}
			else
			{
				foreach (TreeNodeAdv node in parent.Nodes)
				{
					foreach (object obj in e.Children)
						if (node.Tag == obj)
						{
							node.Height = node.RightBounds = null;
						}
				}
			}
		}
		#endregion
	}
}

```

`Aga.Controls/Tree/TreeViewAdv.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="_vScrollBar.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>127, 17</value>
  </metadata>
  <metadata name="_hScrollBar.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
  <metadata name="_errorProvider.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>236, 17</value>
  </metadata>
  <metadata name="$this.TrayLargeIcon" type="System.Boolean, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>False</value>
  </metadata>
</root>
```

`Aga.Controls/Tree/TreeViewAdvCancelEventArgs.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace Aga.Controls.Tree
{
	public class TreeViewAdvCancelEventArgs : TreeViewAdvEventArgs
	{
		private bool _cancel;

		public bool Cancel
		{
			get { return _cancel; }
			set { _cancel = value; }
		}

		public TreeViewAdvCancelEventArgs(TreeNodeAdv node)
			: base(node)
		{
		}

	}
}

```

`Aga.Controls/Tree/TreeViewAdvEventArgs.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace Aga.Controls.Tree
{
	public class TreeViewAdvEventArgs : EventArgs
	{
		private TreeNodeAdv _node;

		public TreeNodeAdv Node
		{
			get { return _node; }
		}

		public TreeViewAdvEventArgs(TreeNodeAdv node)
		{
			_node = node;
		}
	}
}

```

`Aga.Controls/Tree/TreeViewRowDrawEventArgs.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;
using System.Drawing;

namespace Aga.Controls.Tree
{
	public class TreeViewRowDrawEventArgs: PaintEventArgs
	{
		TreeNodeAdv _node;
		DrawContext _context;
		int _row;
		Rectangle _rowRect;

		public TreeViewRowDrawEventArgs(Graphics graphics, Rectangle clipRectangle, TreeNodeAdv node, DrawContext context, int row, Rectangle rowRect)
			: base(graphics, clipRectangle)
		{
			_node = node;
			_context = context;
			_row = row;
			_rowRect = rowRect;
		}

		public TreeNodeAdv Node
		{
			get { return _node; }
		}

		public DrawContext Context
		{
			get { return _context; }
		}

		public int Row
		{
			get { return _row; }
		}

		public Rectangle RowRect
		{
			get { return _rowRect; }
		}
	}

}

```

`Aga.Controls/license.txt`:

```txt
The BSD License

Copyright (c) 2009, Andrey Gliznetsov (a.gliznetsov@gmail.com)

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided 
that the following conditions are met

- Redistributions of source code must retain the above copyright notice, this list of conditions 
and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright notice, this list of conditions 
and the following disclaimer in the documentation andor other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
```

`Directory.Build.props`:

```props
<Project>
  <PropertyGroup>
    <Version>0.9.6</Version>
    <Copyright>LibreHardwareMonitor</Copyright>
  </PropertyGroup>
</Project>

```

`LICENSE`:

```
Mozilla Public License Version 2.0
==================================

1. Definitions
--------------

1.1. "Contributor"
    means each individual or legal entity that creates, contributes to
    the creation of, or owns Covered Software.

1.2. "Contributor Version"
    means the combination of the Contributions of others (if any) used
    by a Contributor and that particular Contributor's Contribution.

1.3. "Contribution"
    means Covered Software of a particular Contributor.

1.4. "Covered Software"
    means Source Code Form to which the initial Contributor has attached
    the notice in Exhibit A, the Executable Form of such Source Code
    Form, and Modifications of such Source Code Form, in each case
    including portions thereof.

1.5. "Incompatible With Secondary Licenses"
    means

    (a) that the initial Contributor has attached the notice described
        in Exhibit B to the Covered Software; or

    (b) that the Covered Software was made available under the terms of
        version 1.1 or earlier of the License, but not also under the
        terms of a Secondary License.

1.6. "Executable Form"
    means any form of the work other than Source Code Form.

1.7. "Larger Work"
    means a work that combines Covered Software with other material, in
    a separate file or files, that is not Covered Software.

1.8. "License"
    means this document.

1.9. "Licensable"
    means having the right to grant, to the maximum extent possible,
    whether at the time of the initial grant or subsequently, any and
    all of the rights conveyed by this License.

1.10. "Modifications"
    means any of the following:

    (a) any file in Source Code Form that results from an addition to,
        deletion from, or modification of the contents of Covered
        Software; or

    (b) any new file in Source Code Form that contains any Covered
        Software.

1.11. "Patent Claims" of a Contributor
    means any patent claim(s), including without limitation, method,
    process, and apparatus claims, in any patent Licensable by such
    Contributor that would be infringed, but for the grant of the
    License, by the making, using, selling, offering for sale, having
    made, import, or transfer of either its Contributions or its
    Contributor Version.

1.12. "Secondary License"
    means either the GNU General Public License, Version 2.0, the GNU
    Lesser General Public License, Version 2.1, the GNU Affero General
    Public License, Version 3.0, or any later versions of those
    licenses.

1.13. "Source Code Form"
    means the form of the work preferred for making modifications.

1.14. "You" (or "Your")
    means an individual or a legal entity exercising rights under this
    License. For legal entities, "You" includes any entity that
    controls, is controlled by, or is under common control with You. For
    purposes of this definition, "control" means (a) the power, direct
    or indirect, to cause the direction or management of such entity,
    whether by contract or otherwise, or (b) ownership of more than
    fifty percent (50%) of the outstanding shares or beneficial
    ownership of such entity.

2. License Grants and Conditions
--------------------------------

2.1. Grants

Each Contributor hereby grants You a world-wide, royalty-free,
non-exclusive license:

(a) under intellectual property rights (other than patent or trademark)
    Licensable by such Contributor to use, reproduce, make available,
    modify, display, perform, distribute, and otherwise exploit its
    Contributions, either on an unmodified basis, with Modifications, or
    as part of a Larger Work; and

(b) under Patent Claims of such Contributor to make, use, sell, offer
    for sale, have made, import, and otherwise transfer either its
    Contributions or its Contributor Version.

2.2. Effective Date

The licenses granted in Section 2.1 with respect to any Contribution
become effective for each Contribution on the date the Contributor first
distributes such Contribution.

2.3. Limitations on Grant Scope

The licenses granted in this Section 2 are the only rights granted under
this License. No additional rights or licenses will be implied from the
distribution or licensing of Covered Software under this License.
Notwithstanding Section 2.1(b) above, no patent license is granted by a
Contributor:

(a) for any code that a Contributor has removed from Covered Software;
    or

(b) for infringements caused by: (i) Your and any other third party's
    modifications of Covered Software, or (ii) the combination of its
    Contributions with other software (except as part of its Contributor
    Version); or

(c) under Patent Claims infringed by Covered Software in the absence of
    its Contributions.

This License does not grant any rights in the trademarks, service marks,
or logos of any Contributor (except as may be necessary to comply with
the notice requirements in Section 3.4).

2.4. Subsequent Licenses

No Contributor makes additional grants as a result of Your choice to
distribute the Covered Software under a subsequent version of this
License (see Section 10.2) or under the terms of a Secondary License (if
permitted under the terms of Section 3.3).

2.5. Representation

Each Contributor represents that the Contributor believes its
Contributions are its original creation(s) or it has sufficient rights
to grant the rights to its Contributions conveyed by this License.

2.6. Fair Use

This License is not intended to limit any rights You have under
applicable copyright doctrines of fair use, fair dealing, or other
equivalents.

2.7. Conditions

Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted
in Section 2.1.

3. Responsibilities
-------------------

3.1. Distribution of Source Form

All distribution of Covered Software in Source Code Form, including any
Modifications that You create or to which You contribute, must be under
the terms of this License. You must inform recipients that the Source
Code Form of the Covered Software is governed by the terms of this
License, and how they can obtain a copy of this License. You may not
attempt to alter or restrict the recipients' rights in the Source Code
Form.

3.2. Distribution of Executable Form

If You distribute Covered Software in Executable Form then:

(a) such Covered Software must also be made available in Source Code
    Form, as described in Section 3.1, and You must inform recipients of
    the Executable Form how they can obtain a copy of such Source Code
    Form by reasonable means in a timely manner, at a charge no more
    than the cost of distribution to the recipient; and

(b) You may distribute such Executable Form under the terms of this
    License, or sublicense it under different terms, provided that the
    license for the Executable Form does not attempt to limit or alter
    the recipients' rights in the Source Code Form under this License.

3.3. Distribution of a Larger Work

You may create and distribute a Larger Work under terms of Your choice,
provided that You also comply with the requirements of this License for
the Covered Software. If the Larger Work is a combination of Covered
Software with a work governed by one or more Secondary Licenses, and the
Covered Software is not Incompatible With Secondary Licenses, this
License permits You to additionally distribute such Covered Software
under the terms of such Secondary License(s), so that the recipient of
the Larger Work may, at their option, further distribute the Covered
Software under the terms of either this License or such Secondary
License(s).

3.4. Notices

You may not remove or alter the substance of any license notices
(including copyright notices, patent notices, disclaimers of warranty,
or limitations of liability) contained within the Source Code Form of
the Covered Software, except that You may alter any license notices to
the extent required to remedy known factual inaccuracies.

3.5. Application of Additional Terms

You may choose to offer, and to charge a fee for, warranty, support,
indemnity or liability obligations to one or more recipients of Covered
Software. However, You may do so only on Your own behalf, and not on
behalf of any Contributor. You must make it absolutely clear that any
such warranty, support, indemnity, or liability obligation is offered by
You alone, and You hereby agree to indemnify every Contributor for any
liability incurred by such Contributor as a result of warranty, support,
indemnity or liability terms You offer. You may include additional
disclaimers of warranty and limitations of liability specific to any
jurisdiction.

4. Inability to Comply Due to Statute or Regulation
---------------------------------------------------

If it is impossible for You to comply with any of the terms of this
License with respect to some or all of the Covered Software due to
statute, judicial order, or regulation then You must: (a) comply with
the terms of this License to the maximum extent possible; and (b)
describe the limitations and the code they affect. Such description must
be placed in a text file included with all distributions of the Covered
Software under this License. Except to the extent prohibited by statute
or regulation, such description must be sufficiently detailed for a
recipient of ordinary skill to be able to understand it.

5. Termination
--------------

5.1. The rights granted under this License will terminate automatically
if You fail to comply with any of its terms. However, if You become
compliant, then the rights granted under this License from a particular
Contributor are reinstated (a) provisionally, unless and until such
Contributor explicitly and finally terminates Your grants, and (b) on an
ongoing basis, if such Contributor fails to notify You of the
non-compliance by some reasonable means prior to 60 days after You have
come back into compliance. Moreover, Your grants from a particular
Contributor are reinstated on an ongoing basis if such Contributor
notifies You of the non-compliance by some reasonable means, this is the
first time You have received notice of non-compliance with this License
from such Contributor, and You become compliant prior to 30 days after
Your receipt of the notice.

5.2. If You initiate litigation against any entity by asserting a patent
infringement claim (excluding declaratory judgment actions,
counter-claims, and cross-claims) alleging that a Contributor Version
directly or indirectly infringes any patent, then the rights granted to
You by any and all Contributors for the Covered Software under Section
2.1 of this License shall terminate.

5.3. In the event of termination under Sections 5.1 or 5.2 above, all
end user license agreements (excluding distributors and resellers) which
have been validly granted by You or Your distributors under this License
prior to termination shall survive termination.

************************************************************************
*                                                                      *
*  6. Disclaimer of Warranty                                           *
*  -------------------------                                           *
*                                                                      *
*  Covered Software is provided under this License on an "as is"       *
*  basis, without warranty of any kind, either expressed, implied, or  *
*  statutory, including, without limitation, warranties that the       *
*  Covered Software is free of defects, merchantable, fit for a        *
*  particular purpose or non-infringing. The entire risk as to the     *
*  quality and performance of the Covered Software is with You.        *
*  Should any Covered Software prove defective in any respect, You     *
*  (not any Contributor) assume the cost of any necessary servicing,   *
*  repair, or correction. This disclaimer of warranty constitutes an   *
*  essential part of this License. No use of any Covered Software is   *
*  authorized under this License except under this disclaimer.         *
*                                                                      *
************************************************************************

************************************************************************
*                                                                      *
*  7. Limitation of Liability                                          *
*  --------------------------                                          *
*                                                                      *
*  Under no circumstances and under no legal theory, whether tort      *
*  (including negligence), contract, or otherwise, shall any           *
*  Contributor, or anyone who distributes Covered Software as          *
*  permitted above, be liable to You for any direct, indirect,         *
*  special, incidental, or consequential damages of any character      *
*  including, without limitation, damages for lost profits, loss of    *
*  goodwill, work stoppage, computer failure or malfunction, or any    *
*  and all other commercial damages or losses, even if such party      *
*  shall have been informed of the possibility of such damages. This   *
*  limitation of liability shall not apply to liability for death or   *
*  personal injury resulting from such party's negligence to the       *
*  extent applicable law prohibits such limitation. Some               *
*  jurisdictions do not allow the exclusion or limitation of           *
*  incidental or consequential damages, so this exclusion and          *
*  limitation may not apply to You.                                    *
*                                                                      *
************************************************************************

8. Litigation
-------------

Any litigation relating to this License may be brought only in the
courts of a jurisdiction where the defendant maintains its principal
place of business and such litigation shall be governed by laws of that
jurisdiction, without reference to its conflict-of-law provisions.
Nothing in this Section shall prevent a party's ability to bring
cross-claims or counter-claims.

9. Miscellaneous
----------------

This License represents the complete agreement concerning the subject
matter hereof. If any provision of this License is held to be
unenforceable, such provision shall be reformed only to the extent
necessary to make it enforceable. Any law or regulation which provides
that the language of a contract shall be construed against the drafter
shall not be used to construe this License against a Contributor.

10. Versions of the License
---------------------------

10.1. New Versions

Mozilla Foundation is the license steward. Except as provided in Section
10.3, no one other than the license steward has the right to modify or
publish new versions of this License. Each version will be given a
distinguishing version number.

10.2. Effect of New Versions

You may distribute the Covered Software under the terms of the version
of the License under which You originally received the Covered Software,
or under the terms of any subsequent version published by the license
steward.

10.3. Modified Versions

If you create software not governed by this License, and you want to
create a new license for such software, you may create and use a
modified version of this License if you rename the license and remove
any references to the name of the license steward (except to note that
such modified license differs from this License).

10.4. Distributing Source Code Form that is Incompatible With Secondary
Licenses

If You choose to distribute Source Code Form that is Incompatible With
Secondary Licenses under the terms of this version of the License, the
notice described in Exhibit B of this License must be attached.

Exhibit A - Source Code Form License Notice
-------------------------------------------

  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, You can obtain one at http://mozilla.org/MPL/2.0/.

If it is not possible or desirable to put the notice in a particular
file, then You may include the notice in a location (such as a LICENSE
file in a relevant directory) where a recipient would be likely to look
for such a notice.

You may add additional accurate notices of copyright ownership.

Exhibit B - "Incompatible With Secondary Licenses" Notice
---------------------------------------------------------

  This Source Code Form is "Incompatible With Secondary Licenses", as
  defined by the Mozilla Public License, v. 2.0.

```

`LibreHardwareMonitor.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 18
VisualStudioVersion = 18.0.11018.127
MinimumVisualStudioVersion = 10.0.40219.1
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "LibreHardwareMonitorLib", "LibreHardwareMonitorLib\LibreHardwareMonitorLib.csproj", "{B0397530-545A-471D-BB74-027AE456DF1A}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "LibreHardwareMonitor", "LibreHardwareMonitor\LibreHardwareMonitor.csproj", "{F5E0C1F7-9E9B-46F2-AC88-8C9C1C923880}"
	ProjectSection(ProjectDependencies) = postProject
		{B0397530-545A-471D-BB74-027AE456DF1A} = {B0397530-545A-471D-BB74-027AE456DF1A}
	EndProjectSection
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Aga.Controls", "Aga.Controls\Aga.Controls.csproj", "{E73BB233-D88B-44A7-A98F-D71EE158381D}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Controls", "Controls", "{23F54DBD-8998-4E22-A4E4-60F4F77F9B65}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{BAEC1DFE-5D1E-4CDB-8264-6C85B229D812}"
	ProjectSection(SolutionItems) = preProject
		.editorconfig = .editorconfig
		Directory.Build.props = Directory.Build.props
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{B0397530-545A-471D-BB74-027AE456DF1A}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{B0397530-545A-471D-BB74-027AE456DF1A}.Debug|ARM64.Build.0 = Debug|ARM64
		{B0397530-545A-471D-BB74-027AE456DF1A}.Debug|x64.ActiveCfg = Debug|x64
		{B0397530-545A-471D-BB74-027AE456DF1A}.Debug|x64.Build.0 = Debug|x64
		{B0397530-545A-471D-BB74-027AE456DF1A}.Debug|x86.ActiveCfg = Debug|x86
		{B0397530-545A-471D-BB74-027AE456DF1A}.Debug|x86.Build.0 = Debug|x86
		{B0397530-545A-471D-BB74-027AE456DF1A}.Release|ARM64.ActiveCfg = Release|ARM64
		{B0397530-545A-471D-BB74-027AE456DF1A}.Release|ARM64.Build.0 = Release|ARM64
		{B0397530-545A-471D-BB74-027AE456DF1A}.Release|x64.ActiveCfg = Release|x64
		{B0397530-545A-471D-BB74-027AE456DF1A}.Release|x64.Build.0 = Release|x64
		{B0397530-545A-471D-BB74-027AE456DF1A}.Release|x86.ActiveCfg = Release|x86
		{B0397530-545A-471D-BB74-027AE456DF1A}.Release|x86.Build.0 = Release|x86
		{F5E0C1F7-9E9B-46F2-AC88-8C9C1C923880}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{F5E0C1F7-9E9B-46F2-AC88-8C9C1C923880}.Debug|ARM64.Build.0 = Debug|ARM64
		{F5E0C1F7-9E9B-46F2-AC88-8C9C1C923880}.Debug|x64.ActiveCfg = Debug|x64
		{F5E0C1F7-9E9B-46F2-AC88-8C9C1C923880}.Debug|x64.Build.0 = Debug|x64
		{F5E0C1F7-9E9B-46F2-AC88-8C9C1C923880}.Debug|x86.ActiveCfg = Debug|x86
		{F5E0C1F7-9E9B-46F2-AC88-8C9C1C923880}.Debug|x86.Build.0 = Debug|x86
		{F5E0C1F7-9E9B-46F2-AC88-8C9C1C923880}.Release|ARM64.ActiveCfg = Release|ARM64
		{F5E0C1F7-9E9B-46F2-AC88-8C9C1C923880}.Release|ARM64.Build.0 = Release|ARM64
		{F5E0C1F7-9E9B-46F2-AC88-8C9C1C923880}.Release|x64.ActiveCfg = Release|x64
		{F5E0C1F7-9E9B-46F2-AC88-8C9C1C923880}.Release|x64.Build.0 = Release|x64
		{F5E0C1F7-9E9B-46F2-AC88-8C9C1C923880}.Release|x86.ActiveCfg = Release|x86
		{F5E0C1F7-9E9B-46F2-AC88-8C9C1C923880}.Release|x86.Build.0 = Release|x86
		{E73BB233-D88B-44A7-A98F-D71EE158381D}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{E73BB233-D88B-44A7-A98F-D71EE158381D}.Debug|ARM64.Build.0 = Debug|ARM64
		{E73BB233-D88B-44A7-A98F-D71EE158381D}.Debug|x64.ActiveCfg = Debug|x64
		{E73BB233-D88B-44A7-A98F-D71EE158381D}.Debug|x64.Build.0 = Debug|x64
		{E73BB233-D88B-44A7-A98F-D71EE158381D}.Debug|x86.ActiveCfg = Debug|x86
		{E73BB233-D88B-44A7-A98F-D71EE158381D}.Debug|x86.Build.0 = Debug|x86
		{E73BB233-D88B-44A7-A98F-D71EE158381D}.Release|ARM64.ActiveCfg = Release|ARM64
		{E73BB233-D88B-44A7-A98F-D71EE158381D}.Release|ARM64.Build.0 = Release|ARM64
		{E73BB233-D88B-44A7-A98F-D71EE158381D}.Release|x64.ActiveCfg = Release|x64
		{E73BB233-D88B-44A7-A98F-D71EE158381D}.Release|x64.Build.0 = Release|x64
		{E73BB233-D88B-44A7-A98F-D71EE158381D}.Release|x86.ActiveCfg = Release|x86
		{E73BB233-D88B-44A7-A98F-D71EE158381D}.Release|x86.Build.0 = Release|x86
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{E73BB233-D88B-44A7-A98F-D71EE158381D} = {23F54DBD-8998-4E22-A4E4-60F4F77F9B65}
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {6A8EF661-2BD7-498F-8FB9-28182B3B0BE5}
	EndGlobalSection
EndGlobal

```

`LibreHardwareMonitor/LibreHardwareMonitor.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk.WindowsDesktop">
  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFrameworks>net472;net10.0-windows</TargetFrameworks>
    <Platforms>x64;x86;ARM64</Platforms>
    <RuntimeIdentifiers>win-x64;win-x86;win-arm64</RuntimeIdentifiers>
    <AssemblyName>LibreHardwareMonitor</AssemblyName>
    <AssemblyTitle>Libre Hardware Monitor</AssemblyTitle>
    <Copyright>LibreHardwareMonitor</Copyright>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <ApplicationIcon>Resources\icon.ico</ApplicationIcon>
    <ApplicationManifest>Resources\app.manifest</ApplicationManifest>
    <StartupObject>LibreHardwareMonitor.Program</StartupObject>
    <UseWindowsForms>true</UseWindowsForms>
    <OutputPath>..\bin\$(Configuration)\</OutputPath>
	  <LangVersion>latest</LangVersion>
    <GenerateResourceUsePreserializedResources>true</GenerateResourceUsePreserializedResources>
    <NoWarn>$(NoWarn);WFO1000</NoWarn>
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebugType>full</DebugType>
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebugType>none</DebugType>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="OxyPlot.Core" Version="2.2.0" />
    <PackageReference Include="OxyPlot.WindowsForms" Version="2.2.0" />
    <PackageReference Include="System.Management" Version="10.0.3" />
    <PackageReference Include="System.Resources.Extensions" Version="10.0.3" />
    <PackageReference Include="System.Text.Json" Version="10.0.3" />
    <PackageReference Include="TaskScheduler" Version="2.12.2" />
  </ItemGroup>

  <ItemGroup>
    <Reference Include="System.Configuration.Install" />
    <Reference Include="System.Web" />
  </ItemGroup>

  <ItemGroup>
    <Compile Update="UI\AboutBox.Designer.cs">
      <DependentUpon>AboutBox.cs</DependentUpon>
    </Compile>
    <Compile Update="UI\AuthForm.Designer.cs">
      <DependentUpon>AuthForm.cs</DependentUpon>
    </Compile>
    <Compile Update="UI\MainForm.Designer.cs">
      <DependentUpon>MainForm.cs</DependentUpon>
    </Compile>
    <Compile Update="UI\ParameterForm.Designer.cs">
      <DependentUpon>ParameterForm.cs</DependentUpon>
    </Compile>
    <Compile Update="UI\InterfacePortForm.Designer.cs">
      <DependentUpon>InterfacePortForm.cs</DependentUpon>
    </Compile>
  </ItemGroup>

  <ItemGroup>
    <EmbeddedResource Update="UI\AboutBox.resx">
      <DependentUpon>AboutBox.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Update="UI\AuthForm.resx">
      <DependentUpon>AuthForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Update="UI\MainForm.resx">
      <DependentUpon>MainForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Update="UI\ParameterForm.resx">
      <DependentUpon>ParameterForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Update="UI\InterfacePortForm.resx">
      <DependentUpon>InterfacePortForm.cs</DependentUpon>
    </EmbeddedResource>
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\Aga.Controls\Aga.Controls.csproj" />
    <ProjectReference Include="..\LibreHardwareMonitorLib\LibreHardwareMonitorLib.csproj" />
  </ItemGroup>

  <ItemGroup>
    <EmbeddedResource Include="Resources\**" />
    <None Include="Resources\app.manifest" />
    <None Include="Resources\icon.ico" />
  </ItemGroup>
</Project>

```

`LibreHardwareMonitor/Program.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.IO;
using System.Windows.Forms;
using LibreHardwareMonitor.UI;

namespace LibreHardwareMonitor;

public static class Program
{
    [STAThread]
    public static void Main()
    {
        if (!AllRequiredFilesAvailable())
            Environment.Exit(0);

        Application.EnableVisualStyles();
        Application.SetCompatibleTextRenderingDefault(false);
        using (MainForm form = new MainForm())
        {
            form.FormClosed += delegate
            {
                Application.Exit();
            };
            Application.Run();
        }
    }

    private static bool IsFileAvailable(string fileName)
    {
        string path = Path.GetDirectoryName(Application.ExecutablePath) + Path.DirectorySeparatorChar;
        if (!File.Exists(path + fileName))
        {
            MessageBox.Show("The following file could not be found: " + fileName +
                            "\nPlease extract all files from the archive.", "Error",
                            MessageBoxButtons.OK, MessageBoxIcon.Error);
            return false;
        }
        return true;
    }

    private static bool AllRequiredFilesAvailable()
    {
        if (!IsFileAvailable("Aga.Controls.dll"))
            return false;

        if (!IsFileAvailable("LibreHardwareMonitorLib.dll"))
            return false;

        if (!IsFileAvailable("OxyPlot.dll"))
            return false;

        if (!IsFileAvailable("OxyPlot.WindowsForms.dll"))
            return false;

        return true;
    }
}

```

`LibreHardwareMonitor/Resources/Web/css/custom-theme/jquery-ui-1.8.16.custom.css`:

```css
/*
 * jQuery UI CSS Framework 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Theming/API
 */

/* Layout helpers
----------------------------------*/
.ui-helper-hidden { display: none; }
.ui-helper-hidden-accessible { position: absolute !important; clip: rect(1px 1px 1px 1px); clip: rect(1px,1px,1px,1px); }
.ui-helper-reset { margin: 0; padding: 0; border: 0; outline: 0; line-height: 1.3; text-decoration: none; font-size: 100%; list-style: none; }
.ui-helper-clearfix:after { content: "."; display: block; height: 0; clear: both; visibility: hidden; }
.ui-helper-clearfix { display: inline-block; }
/* required comment for clearfix to work in Opera \*/
* html .ui-helper-clearfix { height:1%; }
.ui-helper-clearfix { display:block; }
/* end clearfix */
.ui-helper-zfix { width: 100%; height: 100%; top: 0; left: 0; position: absolute; opacity: 0; filter:Alpha(Opacity=0); }


/* Interaction Cues
----------------------------------*/
.ui-state-disabled { cursor: default !important; }


/* Icons
----------------------------------*/

/* states and images */
.ui-icon { display: block; text-indent: -99999px; overflow: hidden; background-repeat: no-repeat; }


/* Misc visuals
----------------------------------*/

/* Overlays */
.ui-widget-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }


/*
 * jQuery UI CSS Framework 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Theming/API
 *
 * To view and modify this theme, visit http://jqueryui.com/themeroller/?ctl=themeroller
 */


/* Component containers
----------------------------------*/
.ui-widget { font-family: Verdana,Arial,sans-serif; font-size: 1.1em; }
.ui-widget .ui-widget { font-size: 1em; }
.ui-widget input, .ui-widget select, .ui-widget textarea, .ui-widget button { font-family: Verdana,Arial,sans-serif; font-size: 1em; }
.ui-widget-content { border: 1px solid #aaaaaa; background: #ffffff url(images/ui-bg_glass_75_ffffff_1x400.png) 50% 50% repeat-x; color: #222222; }
.ui-widget-content a { color: #222222; }
.ui-widget-header { border: 1px solid #aaaaaa; background: #cccccc url(images/ui-bg_highlight-soft_75_cccccc_1x100.png) 50% 50% repeat-x; color: #222222; font-weight: bold; }
.ui-widget-header a { color: #222222; }

/* Interaction states
----------------------------------*/
.ui-state-default, .ui-widget-content .ui-state-default, .ui-widget-header .ui-state-default { border: 1px solid #d3d3d3; background: #e6e6e6 url(images/ui-bg_glass_75_e6e6e6_1x400.png) 50% 50% repeat-x; font-weight: normal; color: #555555; }
.ui-state-default a, .ui-state-default a:link, .ui-state-default a:visited { color: #555555; text-decoration: none; }
.ui-state-hover, .ui-widget-content .ui-state-hover, .ui-widget-header .ui-state-hover, .ui-state-focus, .ui-widget-content .ui-state-focus, .ui-widget-header .ui-state-focus { border: 1px solid #999999; background: #dadada url(images/ui-bg_glass_75_dadada_1x400.png) 50% 50% repeat-x; font-weight: normal; color: #212121; }
.ui-state-hover a, .ui-state-hover a:hover { color: #212121; text-decoration: none; }
.ui-state-active, .ui-widget-content .ui-state-active, .ui-widget-header .ui-state-active { border: 1px solid #aaaaaa; background: #ffffff url(images/ui-bg_glass_65_ffffff_1x400.png) 50% 50% repeat-x; font-weight: normal; color: #212121; }
.ui-state-active a, .ui-state-active a:link, .ui-state-active a:visited { color: #212121; text-decoration: none; }
.ui-widget :active { outline: none; }

/* Interaction Cues
----------------------------------*/
.ui-state-highlight, .ui-widget-content .ui-state-highlight, .ui-widget-header .ui-state-highlight  {border: 1px solid #fcefa1; background: #fbf9ee url(images/ui-bg_glass_55_fbf9ee_1x400.png) 50% 50% repeat-x; color: #363636; }
.ui-state-highlight a, .ui-widget-content .ui-state-highlight a,.ui-widget-header .ui-state-highlight a { color: #363636; }
.ui-state-error, .ui-widget-content .ui-state-error, .ui-widget-header .ui-state-error {border: 1px solid #cd0a0a; background: #fef1ec url(images/ui-bg_inset-soft_95_fef1ec_1x100.png) 50% bottom repeat-x; color: #cd0a0a; }
.ui-state-error a, .ui-widget-content .ui-state-error a, .ui-widget-header .ui-state-error a { color: #cd0a0a; }
.ui-state-error-text, .ui-widget-content .ui-state-error-text, .ui-widget-header .ui-state-error-text { color: #cd0a0a; }
.ui-priority-primary, .ui-widget-content .ui-priority-primary, .ui-widget-header .ui-priority-primary { font-weight: bold; }
.ui-priority-secondary, .ui-widget-content .ui-priority-secondary,  .ui-widget-header .ui-priority-secondary { opacity: .7; filter:Alpha(Opacity=70); font-weight: normal; }
.ui-state-disabled, .ui-widget-content .ui-state-disabled, .ui-widget-header .ui-state-disabled { opacity: .35; filter:Alpha(Opacity=35); background-image: none; }

/* Icons
----------------------------------*/

/* states and images */
.ui-icon { width: 16px; height: 16px; background-image: url(images/ui-icons_222222_256x240.png); }
.ui-widget-content .ui-icon {background-image: url(images/ui-icons_222222_256x240.png); }
.ui-widget-header .ui-icon {background-image: url(images/ui-icons_222222_256x240.png); }
.ui-state-default .ui-icon { background-image: url(images/ui-icons_888888_256x240.png); }
.ui-state-hover .ui-icon, .ui-state-focus .ui-icon {background-image: url(images/ui-icons_454545_256x240.png); }
.ui-state-active .ui-icon {background-image: url(images/ui-icons_454545_256x240.png); }
.ui-state-highlight .ui-icon {background-image: url(images/ui-icons_2e83ff_256x240.png); }
.ui-state-error .ui-icon, .ui-state-error-text .ui-icon {background-image: url(images/ui-icons_cd0a0a_256x240.png); }

/* positioning */
.ui-icon-carat-1-n { background-position: 0 0; }
.ui-icon-carat-1-ne { background-position: -16px 0; }
.ui-icon-carat-1-e { background-position: -32px 0; }
.ui-icon-carat-1-se { background-position: -48px 0; }
.ui-icon-carat-1-s { background-position: -64px 0; }
.ui-icon-carat-1-sw { background-position: -80px 0; }
.ui-icon-carat-1-w { background-position: -96px 0; }
.ui-icon-carat-1-nw { background-position: -112px 0; }
.ui-icon-carat-2-n-s { background-position: -128px 0; }
.ui-icon-carat-2-e-w { background-position: -144px 0; }
.ui-icon-triangle-1-n { background-position: 0 -16px; }
.ui-icon-triangle-1-ne { background-position: -16px -16px; }
.ui-icon-triangle-1-e { background-position: -32px -16px; }
.ui-icon-triangle-1-se { background-position: -48px -16px; }
.ui-icon-triangle-1-s { background-position: -64px -16px; }
.ui-icon-triangle-1-sw { background-position: -80px -16px; }
.ui-icon-triangle-1-w { background-position: -96px -16px; }
.ui-icon-triangle-1-nw { background-position: -112px -16px; }
.ui-icon-triangle-2-n-s { background-position: -128px -16px; }
.ui-icon-triangle-2-e-w { background-position: -144px -16px; }
.ui-icon-arrow-1-n { background-position: 0 -32px; }
.ui-icon-arrow-1-ne { background-position: -16px -32px; }
.ui-icon-arrow-1-e { background-position: -32px -32px; }
.ui-icon-arrow-1-se { background-position: -48px -32px; }
.ui-icon-arrow-1-s { background-position: -64px -32px; }
.ui-icon-arrow-1-sw { background-position: -80px -32px; }
.ui-icon-arrow-1-w { background-position: -96px -32px; }
.ui-icon-arrow-1-nw { background-position: -112px -32px; }
.ui-icon-arrow-2-n-s { background-position: -128px -32px; }
.ui-icon-arrow-2-ne-sw { background-position: -144px -32px; }
.ui-icon-arrow-2-e-w { background-position: -160px -32px; }
.ui-icon-arrow-2-se-nw { background-position: -176px -32px; }
.ui-icon-arrowstop-1-n { background-position: -192px -32px; }
.ui-icon-arrowstop-1-e { background-position: -208px -32px; }
.ui-icon-arrowstop-1-s { background-position: -224px -32px; }
.ui-icon-arrowstop-1-w { background-position: -240px -32px; }
.ui-icon-arrowthick-1-n { background-position: 0 -48px; }
.ui-icon-arrowthick-1-ne { background-position: -16px -48px; }
.ui-icon-arrowthick-1-e { background-position: -32px -48px; }
.ui-icon-arrowthick-1-se { background-position: -48px -48px; }
.ui-icon-arrowthick-1-s { background-position: -64px -48px; }
.ui-icon-arrowthick-1-sw { background-position: -80px -48px; }
.ui-icon-arrowthick-1-w { background-position: -96px -48px; }
.ui-icon-arrowthick-1-nw { background-position: -112px -48px; }
.ui-icon-arrowthick-2-n-s { background-position: -128px -48px; }
.ui-icon-arrowthick-2-ne-sw { background-position: -144px -48px; }
.ui-icon-arrowthick-2-e-w { background-position: -160px -48px; }
.ui-icon-arrowthick-2-se-nw { background-position: -176px -48px; }
.ui-icon-arrowthickstop-1-n { background-position: -192px -48px; }
.ui-icon-arrowthickstop-1-e { background-position: -208px -48px; }
.ui-icon-arrowthickstop-1-s { background-position: -224px -48px; }
.ui-icon-arrowthickstop-1-w { background-position: -240px -48px; }
.ui-icon-arrowreturnthick-1-w { background-position: 0 -64px; }
.ui-icon-arrowreturnthick-1-n { background-position: -16px -64px; }
.ui-icon-arrowreturnthick-1-e { background-position: -32px -64px; }
.ui-icon-arrowreturnthick-1-s { background-position: -48px -64px; }
.ui-icon-arrowreturn-1-w { background-position: -64px -64px; }
.ui-icon-arrowreturn-1-n { background-position: -80px -64px; }
.ui-icon-arrowreturn-1-e { background-position: -96px -64px; }
.ui-icon-arrowreturn-1-s { background-position: -112px -64px; }
.ui-icon-arrowrefresh-1-w { background-position: -128px -64px; }
.ui-icon-arrowrefresh-1-n { background-position: -144px -64px; }
.ui-icon-arrowrefresh-1-e { background-position: -160px -64px; }
.ui-icon-arrowrefresh-1-s { background-position: -176px -64px; }
.ui-icon-arrow-4 { background-position: 0 -80px; }
.ui-icon-arrow-4-diag { background-position: -16px -80px; }
.ui-icon-extlink { background-position: -32px -80px; }
.ui-icon-newwin { background-position: -48px -80px; }
.ui-icon-refresh { background-position: -64px -80px; }
.ui-icon-shuffle { background-position: -80px -80px; }
.ui-icon-transfer-e-w { background-position: -96px -80px; }
.ui-icon-transferthick-e-w { background-position: -112px -80px; }
.ui-icon-folder-collapsed { background-position: 0 -96px; }
.ui-icon-folder-open { background-position: -16px -96px; }
.ui-icon-document { background-position: -32px -96px; }
.ui-icon-document-b { background-position: -48px -96px; }
.ui-icon-note { background-position: -64px -96px; }
.ui-icon-mail-closed { background-position: -80px -96px; }
.ui-icon-mail-open { background-position: -96px -96px; }
.ui-icon-suitcase { background-position: -112px -96px; }
.ui-icon-comment { background-position: -128px -96px; }
.ui-icon-person { background-position: -144px -96px; }
.ui-icon-print { background-position: -160px -96px; }
.ui-icon-trash { background-position: -176px -96px; }
.ui-icon-locked { background-position: -192px -96px; }
.ui-icon-unlocked { background-position: -208px -96px; }
.ui-icon-bookmark { background-position: -224px -96px; }
.ui-icon-tag { background-position: -240px -96px; }
.ui-icon-home { background-position: 0 -112px; }
.ui-icon-flag { background-position: -16px -112px; }
.ui-icon-calendar { background-position: -32px -112px; }
.ui-icon-cart { background-position: -48px -112px; }
.ui-icon-pencil { background-position: -64px -112px; }
.ui-icon-clock { background-position: -80px -112px; }
.ui-icon-disk { background-position: -96px -112px; }
.ui-icon-calculator { background-position: -112px -112px; }
.ui-icon-zoomin { background-position: -128px -112px; }
.ui-icon-zoomout { background-position: -144px -112px; }
.ui-icon-search { background-position: -160px -112px; }
.ui-icon-wrench { background-position: -176px -112px; }
.ui-icon-gear { background-position: -192px -112px; }
.ui-icon-heart { background-position: -208px -112px; }
.ui-icon-star { background-position: -224px -112px; }
.ui-icon-link { background-position: -240px -112px; }
.ui-icon-cancel { background-position: 0 -128px; }
.ui-icon-plus { background-position: -16px -128px; }
.ui-icon-plusthick { background-position: -32px -128px; }
.ui-icon-minus { background-position: -48px -128px; }
.ui-icon-minusthick { background-position: -64px -128px; }
.ui-icon-close { background-position: -80px -128px; }
.ui-icon-closethick { background-position: -96px -128px; }
.ui-icon-key { background-position: -112px -128px; }
.ui-icon-lightbulb { background-position: -128px -128px; }
.ui-icon-scissors { background-position: -144px -128px; }
.ui-icon-clipboard { background-position: -160px -128px; }
.ui-icon-copy { background-position: -176px -128px; }
.ui-icon-contact { background-position: -192px -128px; }
.ui-icon-image { background-position: -208px -128px; }
.ui-icon-video { background-position: -224px -128px; }
.ui-icon-script { background-position: -240px -128px; }
.ui-icon-alert { background-position: 0 -144px; }
.ui-icon-info { background-position: -16px -144px; }
.ui-icon-notice { background-position: -32px -144px; }
.ui-icon-help { background-position: -48px -144px; }
.ui-icon-check { background-position: -64px -144px; }
.ui-icon-bullet { background-position: -80px -144px; }
.ui-icon-radio-off { background-position: -96px -144px; }
.ui-icon-radio-on { background-position: -112px -144px; }
.ui-icon-pin-w { background-position: -128px -144px; }
.ui-icon-pin-s { background-position: -144px -144px; }
.ui-icon-play { background-position: 0 -160px; }
.ui-icon-pause { background-position: -16px -160px; }
.ui-icon-seek-next { background-position: -32px -160px; }
.ui-icon-seek-prev { background-position: -48px -160px; }
.ui-icon-seek-end { background-position: -64px -160px; }
.ui-icon-seek-start { background-position: -80px -160px; }
/* ui-icon-seek-first is deprecated, use ui-icon-seek-start instead */
.ui-icon-seek-first { background-position: -80px -160px; }
.ui-icon-stop { background-position: -96px -160px; }
.ui-icon-eject { background-position: -112px -160px; }
.ui-icon-volume-off { background-position: -128px -160px; }
.ui-icon-volume-on { background-position: -144px -160px; }
.ui-icon-power { background-position: 0 -176px; }
.ui-icon-signal-diag { background-position: -16px -176px; }
.ui-icon-signal { background-position: -32px -176px; }
.ui-icon-battery-0 { background-position: -48px -176px; }
.ui-icon-battery-1 { background-position: -64px -176px; }
.ui-icon-battery-2 { background-position: -80px -176px; }
.ui-icon-battery-3 { background-position: -96px -176px; }
.ui-icon-circle-plus { background-position: 0 -192px; }
.ui-icon-circle-minus { background-position: -16px -192px; }
.ui-icon-circle-close { background-position: -32px -192px; }
.ui-icon-circle-triangle-e { background-position: -48px -192px; }
.ui-icon-circle-triangle-s { background-position: -64px -192px; }
.ui-icon-circle-triangle-w { background-position: -80px -192px; }
.ui-icon-circle-triangle-n { background-position: -96px -192px; }
.ui-icon-circle-arrow-e { background-position: -112px -192px; }
.ui-icon-circle-arrow-s { background-position: -128px -192px; }
.ui-icon-circle-arrow-w { background-position: -144px -192px; }
.ui-icon-circle-arrow-n { background-position: -160px -192px; }
.ui-icon-circle-zoomin { background-position: -176px -192px; }
.ui-icon-circle-zoomout { background-position: -192px -192px; }
.ui-icon-circle-check { background-position: -208px -192px; }
.ui-icon-circlesmall-plus { background-position: 0 -208px; }
.ui-icon-circlesmall-minus { background-position: -16px -208px; }
.ui-icon-circlesmall-close { background-position: -32px -208px; }
.ui-icon-squaresmall-plus { background-position: -48px -208px; }
.ui-icon-squaresmall-minus { background-position: -64px -208px; }
.ui-icon-squaresmall-close { background-position: -80px -208px; }
.ui-icon-grip-dotted-vertical { background-position: 0 -224px; }
.ui-icon-grip-dotted-horizontal { background-position: -16px -224px; }
.ui-icon-grip-solid-vertical { background-position: -32px -224px; }
.ui-icon-grip-solid-horizontal { background-position: -48px -224px; }
.ui-icon-gripsmall-diagonal-se { background-position: -64px -224px; }
.ui-icon-grip-diagonal-se { background-position: -80px -224px; }


/* Misc visuals
----------------------------------*/

/* Corner radius */
.ui-corner-all, .ui-corner-top, .ui-corner-left, .ui-corner-tl { -moz-border-radius-topleft: 4px; -webkit-border-top-left-radius: 4px; -khtml-border-top-left-radius: 4px; border-top-left-radius: 4px; }
.ui-corner-all, .ui-corner-top, .ui-corner-right, .ui-corner-tr { -moz-border-radius-topright: 4px; -webkit-border-top-right-radius: 4px; -khtml-border-top-right-radius: 4px; border-top-right-radius: 4px; }
.ui-corner-all, .ui-corner-bottom, .ui-corner-left, .ui-corner-bl { -moz-border-radius-bottomleft: 4px; -webkit-border-bottom-left-radius: 4px; -khtml-border-bottom-left-radius: 4px; border-bottom-left-radius: 4px; }
.ui-corner-all, .ui-corner-bottom, .ui-corner-right, .ui-corner-br { -moz-border-radius-bottomright: 4px; -webkit-border-bottom-right-radius: 4px; -khtml-border-bottom-right-radius: 4px; border-bottom-right-radius: 4px; }

/* Overlays */
.ui-widget-overlay { background: #aaaaaa url(images/ui-bg_flat_0_aaaaaa_40x100.png) 50% 50% repeat-x; opacity: .30;filter:Alpha(Opacity=30); }
.ui-widget-shadow { margin: -8px 0 0 -8px; padding: 8px; background: #aaaaaa url(images/ui-bg_flat_0_aaaaaa_40x100.png) 50% 50% repeat-x; opacity: .30;filter:Alpha(Opacity=30); -moz-border-radius: 8px; -khtml-border-radius: 8px; -webkit-border-radius: 8px; border-radius: 8px; }/*
 * jQuery UI Button 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Button#theming
 */
.ui-button { display: inline-block; position: relative; padding: 0; margin-right: .1em; text-decoration: none !important; cursor: pointer; text-align: center; zoom: 1; overflow: visible; } /* the overflow property removes extra width in IE */
.ui-button-icon-only { width: 2.2em; } /* to make room for the icon, a width needs to be set here */
button.ui-button-icon-only { width: 2.4em; } /* button elements seem to need a little more width */
.ui-button-icons-only { width: 3.4em; } 
button.ui-button-icons-only { width: 3.7em; } 

/*button text element */
.ui-button .ui-button-text { display: block; line-height: 1.4;  }
.ui-button-text-only .ui-button-text { padding: .4em 1em; }
.ui-button-icon-only .ui-button-text, .ui-button-icons-only .ui-button-text { padding: .4em; text-indent: -9999999px; }
.ui-button-text-icon-primary .ui-button-text, .ui-button-text-icons .ui-button-text { padding: .4em 1em .4em 2.1em; }
.ui-button-text-icon-secondary .ui-button-text, .ui-button-text-icons .ui-button-text { padding: .4em 2.1em .4em 1em; }
.ui-button-text-icons .ui-button-text { padding-left: 2.1em; padding-right: 2.1em; }
/* no icon support for input elements, provide padding by default */
input.ui-button { padding: .4em 1em; }

/*button icon element(s) */
.ui-button-icon-only .ui-icon, .ui-button-text-icon-primary .ui-icon, .ui-button-text-icon-secondary .ui-icon, .ui-button-text-icons .ui-icon, .ui-button-icons-only .ui-icon { position: absolute; top: 50%; margin-top: -8px; }
.ui-button-icon-only .ui-icon { left: 50%; margin-left: -8px; }
.ui-button-text-icon-primary .ui-button-icon-primary, .ui-button-text-icons .ui-button-icon-primary, .ui-button-icons-only .ui-button-icon-primary { left: .5em; }
.ui-button-text-icon-secondary .ui-button-icon-secondary, .ui-button-text-icons .ui-button-icon-secondary, .ui-button-icons-only .ui-button-icon-secondary { right: .5em; }
.ui-button-text-icons .ui-button-icon-secondary, .ui-button-icons-only .ui-button-icon-secondary { right: .5em; }

/*button sets*/
.ui-buttonset { margin-right: 7px; }
.ui-buttonset .ui-button { margin-left: 0; margin-right: -.3em; }

/* workarounds */
button.ui-button::-moz-focus-inner { border: 0; padding: 0; } /* reset extra padding in Firefox */
/*
 * jQuery UI Slider 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Slider#theming
 */
.ui-slider { position: relative; text-align: left; }
.ui-slider .ui-slider-handle { position: absolute; z-index: 2; width: 1.2em; height: 1.2em; cursor: default; }
.ui-slider .ui-slider-range { position: absolute; z-index: 1; font-size: .7em; display: block; border: 0; background-position: 0 0; }

.ui-slider-horizontal { height: .8em; }
.ui-slider-horizontal .ui-slider-handle { top: -.3em; margin-left: -.6em; }
.ui-slider-horizontal .ui-slider-range { top: 0; height: 100%; }
.ui-slider-horizontal .ui-slider-range-min { left: 0; }
.ui-slider-horizontal .ui-slider-range-max { right: 0; }

.ui-slider-vertical { width: .8em; height: 100px; }
.ui-slider-vertical .ui-slider-handle { left: -.3em; margin-left: 0; margin-bottom: -.6em; }
.ui-slider-vertical .ui-slider-range { left: 0; width: 100%; }
.ui-slider-vertical .ui-slider-range-min { bottom: 0; }
.ui-slider-vertical .ui-slider-range-max { top: 0; }
```

`LibreHardwareMonitor/Resources/Web/css/jquery.treeTable.css`:

```css
/* jQuery treeTable stylesheet
 *
 * This file contains styles that are used to display the tree table. Each tree
 * table is assigned the +treeTable+ class.
 * ========================================================================= */

/* jquery.treeTable.collapsible
 * ------------------------------------------------------------------------- */
.treeTable tr td .expander {
  background-position: left center;
  background-repeat: no-repeat;
  cursor: pointer;
  padding: 0;
  zoom: 1; /* IE7 Hack */
}

.treeTable tr.collapsed td .expander {
  background-image: url(../images/toggle-expand-dark.png);
}

.treeTable tr.expanded td .expander {
  background-image: url(../images/toggle-collapse-dark.png);
}

/* jquery.treeTable.sortable
 * ------------------------------------------------------------------------- */
.treeTable tr.selected, .treeTable tr.accept {
  background-color: #3875d7;
  color: #fff;
}

.treeTable tr.collapsed.selected td .expander, .treeTable tr.collapsed.accept td .expander {
  background-image: url(../images/toggle-expand-light.png);
}

.treeTable tr.expanded.selected td .expander, .treeTable tr.expanded.accept td .expander {
  background-image: url(../images/toggle-collapse-light.png);
}

.treeTable .ui-draggable-dragging {
  color: #000;
  z-index: 1;
}

/* Layout helper taken from jQuery UI. This way I don't have to require the
 * full jQuery UI CSS to be loaded. */
.ui-helper-hidden { display: none; }

```

`LibreHardwareMonitor/Resources/Web/css/ohm_web.css`:

```css
body {
	font-size: 62.5%;
}

table
{
  border-collapse:collapse;
}

table, tr
{
 border: 1px solid #F0F0F0;
}

td
{
 padding-right:10px;
}

/* Site
   -------------------------------- */

body {
	font-family: "Trebuchet MS", "Helvetica", "Arial",  "Verdana", "sans-serif";
}

div.header {
	padding:12px;
	font-family: "Trebuchet MS", "Arial", "Helvetica", "Verdana", "sans-serif";
}

div.main {
	clear:both;
	padding:12px;
	font-family: "Trebuchet MS", "Arial", "Helvetica", "Verdana", "sans-serif";
	/*font-size: 1.3em;*/
	/*line-height: 1.4em;*/
}


```

`LibreHardwareMonitor/Resources/Web/index.html`:

```html
<!-- This Source Code Form is subject to the terms of the Mozilla Public
   - License, v. 2.0. If a copy of the MPL was not distributed with this
   - file, You can obtain one at http://mozilla.org/MPL/2.0/.  
	 
	 - Copyright (C) 2012 Prince Samuel <prince.samuel@gmail.com>  -->

<html>
<head>
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
    <title>Libre Hardware Monitor - Web Version</title>
    <script type='text/javascript' src='js/jquery-1.7.2.min.js'></script>
    <script type='text/javascript' src='js/jquery.tmpl.min.js'></script>
    <script type='text/javascript' src='js/knockout-2.1.0.min.js'></script>
    <script type='text/javascript' src='js/knockout.mapping-latest.min.js'></script>

    <link href="css/jquery.treeTable.css" rel="stylesheet" type="text/css" />
    <script type='text/javascript' src='js/jquery.treeTable.min.js'></script>

    <link href="css/custom-theme/jquery-ui-1.8.16.custom.css" rel="stylesheet" type="text/css" />
    <link href="css/ohm_web.css" rel="stylesheet" type="text/css" />
    <script type='text/javascript' src='js/jquery-ui-1.8.16.custom.min.js'></script>
    <style>
        #toolbar {
            padding: 10px 10px;
        }

        #slider {
            display: inline-block;
            width: 100px;
        }
    </style>


    <script type='text/javascript' src='js/ohm_web.js'></script>

</head>

  <body>

    <div class="header">

      <span id="toolbar" class="ui-widget-header ui-corner-all">
        <button id="refresh" data-bind="click: update">Refresh</button>
        <input type="checkbox" id="auto_refresh" data-bind="checked: auto_refresh"/><label for="auto_refresh">Auto Refresh</label>
        &nbsp;<div id="slider"></div>&nbsp;&nbsp;&nbsp;&nbsp;<span for="auto_refresh" id="lbl"></span>
      </span>
    </div>

    <div class="main">
      <table data-bind="treeTable: flattened, treeOptions: { initialState: 'expanded', clickableNodeNames: true } ">
        <thead><td>Sensor</td><td>Min</td><td>Value</td><td>Max</td>
          <tbody data-bind="foreach: flattened">
            <tr data-bind="attr: { 'id': 'node-' + id(), 'class': parent.id()?'child-of-node-' + parent.id():'' }">
              <td data-bind="html: '<img src=' + ImageURL() + ' />&nbsp; ' + Text()"></td>
              <td data-bind="text: Min"></td>
              <td data-bind="text: Value"></td>
              <td data-bind="text: Max"></td>
            </tr>
          </tbody>
        </table>
      </div>
    </body>
  </html>

```

`LibreHardwareMonitor/Resources/Web/js/jquery-1.7.2.js`:

```js
/*!
 * jQuery JavaScript Library v1.7.2
 * http://jquery.com/
 *
 * Copyright 2011, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2011, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Wed Mar 21 12:46:34 2012 -0700
 */
(function( window, undefined ) {

// Use the correct document accordingly with window argument (sandbox)
var document = window.document,
	navigator = window.navigator,
	location = window.location;
var jQuery = (function() {

// Define a local copy of jQuery
var jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		return new jQuery.fn.init( selector, context, rootjQuery );
	},

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$,

	// A central reference to the root jQuery(document)
	rootjQuery,

	// A simple way to check for HTML strings or ID strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	quickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

	// Check if a string has a non-whitespace character in it
	rnotwhite = /\S/,

	// Used for trimming whitespace
	trimLeft = /^\s+/,
	trimRight = /\s+$/,

	// Match a standalone tag
	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,

	// JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/,
	rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,

	// Useragent RegExp
	rwebkit = /(webkit)[ \/]([\w.]+)/,
	ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
	rmsie = /(msie) ([\w.]+)/,
	rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,

	// Matches dashed string for camelizing
	rdashAlpha = /-([a-z]|[0-9])/ig,
	rmsPrefix = /^-ms-/,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return ( letter + "" ).toUpperCase();
	},

	// Keep a UserAgent string for use with jQuery.browser
	userAgent = navigator.userAgent,

	// For matching the engine and version of the browser
	browserMatch,

	// The deferred used on DOM ready
	readyList,

	// The ready event handler
	DOMContentLoaded,

	// Save a reference to some core methods
	toString = Object.prototype.toString,
	hasOwn = Object.prototype.hasOwnProperty,
	push = Array.prototype.push,
	slice = Array.prototype.slice,
	trim = String.prototype.trim,
	indexOf = Array.prototype.indexOf,

	// [[Class]] -> type pairs
	class2type = {};

jQuery.fn = jQuery.prototype = {
	constructor: jQuery,
	init: function( selector, context, rootjQuery ) {
		var match, elem, ret, doc;

		// Handle $(""), $(null), or $(undefined)
		if ( !selector ) {
			return this;
		}

		// Handle $(DOMElement)
		if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;
		}

		// The body element only exists once, optimize finding it
		if ( selector === "body" && !context && document.body ) {
			this.context = document;
			this[0] = document.body;
			this.selector = selector;
			this.length = 1;
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			// Are we dealing with HTML string or an ID?
			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = quickExpr.exec( selector );
			}

			// Verify a match, and that no context was specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;
					doc = ( context ? context.ownerDocument || context : document );

					// If a single string is passed in and it's a single tag
					// just do a createElement and skip the rest
					ret = rsingleTag.exec( selector );

					if ( ret ) {
						if ( jQuery.isPlainObject( context ) ) {
							selector = [ document.createElement( ret[1] ) ];
							jQuery.fn.attr.call( selector, context, true );

						} else {
							selector = [ doc.createElement( ret[1] ) ];
						}

					} else {
						ret = jQuery.buildFragment( [ match[1] ], [ doc ] );
						selector = ( ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment ).childNodes;
					}

					return jQuery.merge( this, selector );

				// HANDLE: $("#id")
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}

						// Otherwise, we inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return rootjQuery.ready( selector );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	},

	// Start with an empty selector
	selector: "",

	// The current version of jQuery being used
	jquery: "1.7.2",

	// The default length of a jQuery object is 0
	length: 0,

	// The number of elements contained in the matched element set
	size: function() {
		return this.length;
	},

	toArray: function() {
		return slice.call( this, 0 );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num == null ?

			// Return a 'clean' array
			this.toArray() :

			// Return just the object
			( num < 0 ? this[ this.length + num ] : this[ num ] );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems, name, selector ) {
		// Build a new jQuery matched element set
		var ret = this.constructor();

		if ( jQuery.isArray( elems ) ) {
			push.apply( ret, elems );

		} else {
			jQuery.merge( ret, elems );
		}

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		ret.context = this.context;

		if ( name === "find" ) {
			ret.selector = this.selector + ( this.selector ? " " : "" ) + selector;
		} else if ( name ) {
			ret.selector = this.selector + "." + name + "(" + selector + ")";
		}

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	ready: function( fn ) {
		// Attach the listeners
		jQuery.bindReady();

		// Add the callback
		readyList.add( fn );

		return this;
	},

	eq: function( i ) {
		i = +i;
		return i === -1 ?
			this.slice( i ) :
			this.slice( i, i + 1 );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ),
			"slice", slice.call(arguments).join(",") );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: [].sort,
	splice: [].splice
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( length === i ) {
		target = this;
		--i;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	noConflict: function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	},

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {
		// Either a released hold or an DOMready/load event and not yet ready
		if ( (wait === true && !--jQuery.readyWait) || (wait !== true && !jQuery.isReady) ) {
			// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
			if ( !document.body ) {
				return setTimeout( jQuery.ready, 1 );
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.fireWith( document, [ jQuery ] );

			// Trigger any bound ready events
			if ( jQuery.fn.trigger ) {
				jQuery( document ).trigger( "ready" ).off( "ready" );
			}
		}
	},

	bindReady: function() {
		if ( readyList ) {
			return;
		}

		readyList = jQuery.Callbacks( "once memory" );

		// Catch cases where $(document).ready() is called after the
		// browser event has already occurred.
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			return setTimeout( jQuery.ready, 1 );
		}

		// Mozilla, Opera and webkit nightlies currently support this event
		if ( document.addEventListener ) {
			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", jQuery.ready, false );

		// If IE event model is used
		} else if ( document.attachEvent ) {
			// ensure firing before onload,
			// maybe late but safe also for iframes
			document.attachEvent( "onreadystatechange", DOMContentLoaded );

			// A fallback to window.onload, that will always work
			window.attachEvent( "onload", jQuery.ready );

			// If IE and not a frame
			// continually check to see if the document is ready
			var toplevel = false;

			try {
				toplevel = window.frameElement == null;
			} catch(e) {}

			if ( document.documentElement.doScroll && toplevel ) {
				doScrollCheck();
			}
		}
	},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

	isWindow: function( obj ) {
		return obj != null && obj == obj.window;
	},

	isNumeric: function( obj ) {
		return !isNaN( parseFloat(obj) ) && isFinite( obj );
	},

	type: function( obj ) {
		return obj == null ?
			String( obj ) :
			class2type[ toString.call(obj) ] || "object";
	},

	isPlainObject: function( obj ) {
		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		try {
			// Not own constructor property must be Object
			if ( obj.constructor &&
				!hasOwn.call(obj, "constructor") &&
				!hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
				return false;
			}
		} catch ( e ) {
			// IE8,9 Will throw exceptions on certain host objects #9897
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.

		var key;
		for ( key in obj ) {}

		return key === undefined || hasOwn.call( obj, key );
	},

	isEmptyObject: function( obj ) {
		for ( var name in obj ) {
			return false;
		}
		return true;
	},

	error: function( msg ) {
		throw new Error( msg );
	},

	parseJSON: function( data ) {
		if ( typeof data !== "string" || !data ) {
			return null;
		}

		// Make sure leading/trailing whitespace is removed (IE can't handle it)
		data = jQuery.trim( data );

		// Attempt to parse using the native JSON parser first
		if ( window.JSON && window.JSON.parse ) {
			return window.JSON.parse( data );
		}

		// Make sure the incoming data is actual JSON
		// Logic borrowed from http://json.org/json2.js
		if ( rvalidchars.test( data.replace( rvalidescape, "@" )
			.replace( rvalidtokens, "]" )
			.replace( rvalidbraces, "")) ) {

			return ( new Function( "return " + data ) )();

		}
		jQuery.error( "Invalid JSON: " + data );
	},

	// Cross-browser xml parsing
	parseXML: function( data ) {
		if ( typeof data !== "string" || !data ) {
			return null;
		}
		var xml, tmp;
		try {
			if ( window.DOMParser ) { // Standard
				tmp = new DOMParser();
				xml = tmp.parseFromString( data , "text/xml" );
			} else { // IE
				xml = new ActiveXObject( "Microsoft.XMLDOM" );
				xml.async = "false";
				xml.loadXML( data );
			}
		} catch( e ) {
			xml = undefined;
		}
		if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	},

	noop: function() {},

	// Evaluates a script in a global context
	// Workarounds based on findings by Jim Driscoll
	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
	globalEval: function( data ) {
		if ( data && rnotwhite.test( data ) ) {
			// We use execScript on Internet Explorer
			// We use an anonymous function so that context is window
			// rather than jQuery in Firefox
			( window.execScript || function( data ) {
				window[ "eval" ].call( window, data );
			} )( data );
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
	},

	// args is for internal usage only
	each: function( object, callback, args ) {
		var name, i = 0,
			length = object.length,
			isObj = length === undefined || jQuery.isFunction( object );

		if ( args ) {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.apply( object[ name ], args ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.apply( object[ i++ ], args ) === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.call( object[ name ], name, object[ name ] ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {
						break;
					}
				}
			}
		}

		return object;
	},

	// Use native String.trim function wherever possible
	trim: trim ?
		function( text ) {
			return text == null ?
				"" :
				trim.call( text );
		} :

		// Otherwise use our own trimming functionality
		function( text ) {
			return text == null ?
				"" :
				text.toString().replace( trimLeft, "" ).replace( trimRight, "" );
		},

	// results is for internal usage only
	makeArray: function( array, results ) {
		var ret = results || [];

		if ( array != null ) {
			// The window, strings (and functions) also have 'length'
			// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
			var type = jQuery.type( array );

			if ( array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( array ) ) {
				push.call( ret, array );
			} else {
				jQuery.merge( ret, array );
			}
		}

		return ret;
	},

	inArray: function( elem, array, i ) {
		var len;

		if ( array ) {
			if ( indexOf ) {
				return indexOf.call( array, elem, i );
			}

			len = array.length;
			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

			for ( ; i < len; i++ ) {
				// Skip accessing in sparse arrays
				if ( i in array && array[ i ] === elem ) {
					return i;
				}
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var i = first.length,
			j = 0;

		if ( typeof second.length === "number" ) {
			for ( var l = second.length; j < l; j++ ) {
				first[ i++ ] = second[ j ];
			}

		} else {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, inv ) {
		var ret = [], retVal;
		inv = !!inv;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( var i = 0, length = elems.length; i < length; i++ ) {
			retVal = !!callback( elems[ i ], i );
			if ( inv !== retVal ) {
				ret.push( elems[ i ] );
			}
		}

		return ret;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value, key, ret = [],
			i = 0,
			length = elems.length,
			// jquery objects are treated as arrays
			isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;

		// Go through the array, translating each of the items to their
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}

		// Go through every key on the object,
		} else {
			for ( key in elems ) {
				value = callback( elems[ key ], key, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}
		}

		// Flatten any nested arrays
		return ret.concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		if ( typeof context === "string" ) {
			var tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		var args = slice.call( arguments, 2 ),
			proxy = function() {
				return fn.apply( context, args.concat( slice.call( arguments ) ) );
			};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;

		return proxy;
	},

	// Mutifunctional method to get and set values to a collection
	// The value/s can optionally be executed if it's a function
	access: function( elems, fn, key, value, chainable, emptyGet, pass ) {
		var exec,
			bulk = key == null,
			i = 0,
			length = elems.length;

		// Sets many values
		if ( key && typeof key === "object" ) {
			for ( i in key ) {
				jQuery.access( elems, fn, i, key[i], 1, emptyGet, value );
			}
			chainable = 1;

		// Sets one value
		} else if ( value !== undefined ) {
			// Optionally, function values get executed if exec is true
			exec = pass === undefined && jQuery.isFunction( value );

			if ( bulk ) {
				// Bulk operations only iterate when executing function values
				if ( exec ) {
					exec = fn;
					fn = function( elem, key, value ) {
						return exec.call( jQuery( elem ), value );
					};

				// Otherwise they run against the entire set
				} else {
					fn.call( elems, value );
					fn = null;
				}
			}

			if ( fn ) {
				for (; i < length; i++ ) {
					fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
				}
			}

			chainable = 1;
		}

		return chainable ?
			elems :

			// Gets
			bulk ?
				fn.call( elems ) :
				length ? fn( elems[0], key ) : emptyGet;
	},

	now: function() {
		return ( new Date() ).getTime();
	},

	// Use of jQuery.browser is frowned upon.
	// More details: http://docs.jquery.com/Utilities/jQuery.browser
	uaMatch: function( ua ) {
		ua = ua.toLowerCase();

		var match = rwebkit.exec( ua ) ||
			ropera.exec( ua ) ||
			rmsie.exec( ua ) ||
			ua.indexOf("compatible") < 0 && rmozilla.exec( ua ) ||
			[];

		return { browser: match[1] || "", version: match[2] || "0" };
	},

	sub: function() {
		function jQuerySub( selector, context ) {
			return new jQuerySub.fn.init( selector, context );
		}
		jQuery.extend( true, jQuerySub, this );
		jQuerySub.superclass = this;
		jQuerySub.fn = jQuerySub.prototype = this();
		jQuerySub.fn.constructor = jQuerySub;
		jQuerySub.sub = this.sub;
		jQuerySub.fn.init = function init( selector, context ) {
			if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
				context = jQuerySub( context );
			}

			return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
		};
		jQuerySub.fn.init.prototype = jQuerySub.fn;
		var rootjQuerySub = jQuerySub(document);
		return jQuerySub;
	},

	browser: {}
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

browserMatch = jQuery.uaMatch( userAgent );
if ( browserMatch.browser ) {
	jQuery.browser[ browserMatch.browser ] = true;
	jQuery.browser.version = browserMatch.version;
}

// Deprecated, use jQuery.browser.webkit instead
if ( jQuery.browser.webkit ) {
	jQuery.browser.safari = true;
}

// IE doesn't match non-breaking spaces with \s
if ( rnotwhite.test( "\xA0" ) ) {
	trimLeft = /^[\s\xA0]+/;
	trimRight = /[\s\xA0]+$/;
}

// All jQuery objects should point back to these
rootjQuery = jQuery(document);

// Cleanup functions for the document ready method
if ( document.addEventListener ) {
	DOMContentLoaded = function() {
		document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
		jQuery.ready();
	};

} else if ( document.attachEvent ) {
	DOMContentLoaded = function() {
		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
		if ( document.readyState === "complete" ) {
			document.detachEvent( "onreadystatechange", DOMContentLoaded );
			jQuery.ready();
		}
	};
}

// The DOM ready check for Internet Explorer
function doScrollCheck() {
	if ( jQuery.isReady ) {
		return;
	}

	try {
		// If IE is used, use the trick by Diego Perini
		// http://javascript.nwbox.com/IEContentLoaded/
		document.documentElement.doScroll("left");
	} catch(e) {
		setTimeout( doScrollCheck, 1 );
		return;
	}

	// and execute any waiting functions
	jQuery.ready();
}

return jQuery;

})();


// String to Object flags format cache
var flagsCache = {};

// Convert String-formatted flags into Object-formatted ones and store in cache
function createFlags( flags ) {
	var object = flagsCache[ flags ] = {},
		i, length;
	flags = flags.split( /\s+/ );
	for ( i = 0, length = flags.length; i < length; i++ ) {
		object[ flags[i] ] = true;
	}
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	flags:	an optional list of space-separated flags that will change how
 *			the callback list behaves
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible flags:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( flags ) {

	// Convert flags from String-formatted to Object-formatted
	// (we check in cache first)
	flags = flags ? ( flagsCache[ flags ] || createFlags( flags ) ) : {};

	var // Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = [],
		// Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Add one or several callbacks to the list
		add = function( args ) {
			var i,
				length,
				elem,
				type,
				actual;
			for ( i = 0, length = args.length; i < length; i++ ) {
				elem = args[ i ];
				type = jQuery.type( elem );
				if ( type === "array" ) {
					// Inspect recursively
					add( elem );
				} else if ( type === "function" ) {
					// Add if not in unique mode and callback is not in
					if ( !flags.unique || !self.has( elem ) ) {
						list.push( elem );
					}
				}
			}
		},
		// Fire callbacks
		fire = function( context, args ) {
			args = args || [];
			memory = !flags.memory || [ context, args ];
			fired = true;
			firing = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( context, args ) === false && flags.stopOnFalse ) {
					memory = true; // Mark as halted
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( !flags.once ) {
					if ( stack && stack.length ) {
						memory = stack.shift();
						self.fireWith( memory[ 0 ], memory[ 1 ] );
					}
				} else if ( memory === true ) {
					self.disable();
				} else {
					list = [];
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					var length = list.length;
					add( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away, unless previous
					// firing was halted (stopOnFalse)
					} else if ( memory && memory !== true ) {
						firingStart = length;
						fire( memory[ 0 ], memory[ 1 ] );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					var args = arguments,
						argIndex = 0,
						argLength = args.length;
					for ( ; argIndex < argLength ; argIndex++ ) {
						for ( var i = 0; i < list.length; i++ ) {
							if ( args[ argIndex ] === list[ i ] ) {
								// Handle firingIndex and firingLength
								if ( firing ) {
									if ( i <= firingLength ) {
										firingLength--;
										if ( i <= firingIndex ) {
											firingIndex--;
										}
									}
								}
								// Remove the element
								list.splice( i--, 1 );
								// If we have some unicity property then
								// we only need to do this once
								if ( flags.unique ) {
									break;
								}
							}
						}
					}
				}
				return this;
			},
			// Control if a given callback is in the list
			has: function( fn ) {
				if ( list ) {
					var i = 0,
						length = list.length;
					for ( ; i < length; i++ ) {
						if ( fn === list[ i ] ) {
							return true;
						}
					}
				}
				return false;
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory || memory === true ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( stack ) {
					if ( firing ) {
						if ( !flags.once ) {
							stack.push( [ context, args ] );
						}
					} else if ( !( flags.once && memory ) ) {
						fire( context, args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};




var // Static reference to slice
	sliceDeferred = [].slice;

jQuery.extend({

	Deferred: function( func ) {
		var doneList = jQuery.Callbacks( "once memory" ),
			failList = jQuery.Callbacks( "once memory" ),
			progressList = jQuery.Callbacks( "memory" ),
			state = "pending",
			lists = {
				resolve: doneList,
				reject: failList,
				notify: progressList
			},
			promise = {
				done: doneList.add,
				fail: failList.add,
				progress: progressList.add,

				state: function() {
					return state;
				},

				// Deprecated
				isResolved: doneList.fired,
				isRejected: failList.fired,

				then: function( doneCallbacks, failCallbacks, progressCallbacks ) {
					deferred.done( doneCallbacks ).fail( failCallbacks ).progress( progressCallbacks );
					return this;
				},
				always: function() {
					deferred.done.apply( deferred, arguments ).fail.apply( deferred, arguments );
					return this;
				},
				pipe: function( fnDone, fnFail, fnProgress ) {
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( {
							done: [ fnDone, "resolve" ],
							fail: [ fnFail, "reject" ],
							progress: [ fnProgress, "notify" ]
						}, function( handler, data ) {
							var fn = data[ 0 ],
								action = data[ 1 ],
								returned;
							if ( jQuery.isFunction( fn ) ) {
								deferred[ handler ](function() {
									returned = fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise().then( newDefer.resolve, newDefer.reject, newDefer.notify );
									} else {
										newDefer[ action + "With" ]( this === deferred ? newDefer : this, [ returned ] );
									}
								});
							} else {
								deferred[ handler ]( newDefer[ action ] );
							}
						});
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					if ( obj == null ) {
						obj = promise;
					} else {
						for ( var key in promise ) {
							obj[ key ] = promise[ key ];
						}
					}
					return obj;
				}
			},
			deferred = promise.promise({}),
			key;

		for ( key in lists ) {
			deferred[ key ] = lists[ key ].fire;
			deferred[ key + "With" ] = lists[ key ].fireWith;
		}

		// Handle state
		deferred.done( function() {
			state = "resolved";
		}, failList.disable, progressList.lock ).fail( function() {
			state = "rejected";
		}, doneList.disable, progressList.lock );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( firstParam ) {
		var args = sliceDeferred.call( arguments, 0 ),
			i = 0,
			length = args.length,
			pValues = new Array( length ),
			count = length,
			pCount = length,
			deferred = length <= 1 && firstParam && jQuery.isFunction( firstParam.promise ) ?
				firstParam :
				jQuery.Deferred(),
			promise = deferred.promise();
		function resolveFunc( i ) {
			return function( value ) {
				args[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
				if ( !( --count ) ) {
					deferred.resolveWith( deferred, args );
				}
			};
		}
		function progressFunc( i ) {
			return function( value ) {
				pValues[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
				deferred.notifyWith( promise, pValues );
			};
		}
		if ( length > 1 ) {
			for ( ; i < length; i++ ) {
				if ( args[ i ] && args[ i ].promise && jQuery.isFunction( args[ i ].promise ) ) {
					args[ i ].promise().then( resolveFunc(i), deferred.reject, progressFunc(i) );
				} else {
					--count;
				}
			}
			if ( !count ) {
				deferred.resolveWith( deferred, args );
			}
		} else if ( deferred !== firstParam ) {
			deferred.resolveWith( deferred, length ? [ firstParam ] : [] );
		}
		return promise;
	}
});




jQuery.support = (function() {

	var support,
		all,
		a,
		select,
		opt,
		input,
		fragment,
		tds,
		events,
		eventName,
		i,
		isSupported,
		div = document.createElement( "div" ),
		documentElement = document.documentElement;

	// Preliminary tests
	div.setAttribute("className", "t");
	div.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";

	all = div.getElementsByTagName( "*" );
	a = div.getElementsByTagName( "a" )[ 0 ];

	// Can't get basic test support
	if ( !all || !all.length || !a ) {
		return {};
	}

	// First batch of supports tests
	select = document.createElement( "select" );
	opt = select.appendChild( document.createElement("option") );
	input = div.getElementsByTagName( "input" )[ 0 ];

	support = {
		// IE strips leading whitespace when .innerHTML is used
		leadingWhitespace: ( div.firstChild.nodeType === 3 ),

		// Make sure that tbody elements aren't automatically inserted
		// IE will insert them into empty tables
		tbody: !div.getElementsByTagName("tbody").length,

		// Make sure that link elements get serialized correctly by innerHTML
		// This requires a wrapper element in IE
		htmlSerialize: !!div.getElementsByTagName("link").length,

		// Get the style information from getAttribute
		// (IE uses .cssText instead)
		style: /top/.test( a.getAttribute("style") ),

		// Make sure that URLs aren't manipulated
		// (IE normalizes it by default)
		hrefNormalized: ( a.getAttribute("href") === "/a" ),

		// Make sure that element opacity exists
		// (IE uses filter instead)
		// Use a regex to work around a WebKit issue. See #5145
		opacity: /^0.55/.test( a.style.opacity ),

		// Verify style float existence
		// (IE uses styleFloat instead of cssFloat)
		cssFloat: !!a.style.cssFloat,

		// Make sure that if no value is specified for a checkbox
		// that it defaults to "on".
		// (WebKit defaults to "" instead)
		checkOn: ( input.value === "on" ),

		// Make sure that a selected-by-default option has a working selected property.
		// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
		optSelected: opt.selected,

		// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
		getSetAttribute: div.className !== "t",

		// Tests for enctype support on a form(#6743)
		enctype: !!document.createElement("form").enctype,

		// Makes sure cloning an html5 element does not cause problems
		// Where outerHTML is undefined, this still works
		html5Clone: document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>",

		// Will be defined later
		submitBubbles: true,
		changeBubbles: true,
		focusinBubbles: false,
		deleteExpando: true,
		noCloneEvent: true,
		inlineBlockNeedsLayout: false,
		shrinkWrapBlocks: false,
		reliableMarginRight: true,
		pixelMargin: true
	};

	// jQuery.boxModel DEPRECATED in 1.3, use jQuery.support.boxModel instead
	jQuery.boxModel = support.boxModel = (document.compatMode === "CSS1Compat");

	// Make sure checked status is properly cloned
	input.checked = true;
	support.noCloneChecked = input.cloneNode( true ).checked;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Test to see if it's possible to delete an expando from an element
	// Fails in Internet Explorer
	try {
		delete div.test;
	} catch( e ) {
		support.deleteExpando = false;
	}

	if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {
		div.attachEvent( "onclick", function() {
			// Cloning a node shouldn't copy over any
			// bound event handlers (IE does this)
			support.noCloneEvent = false;
		});
		div.cloneNode( true ).fireEvent( "onclick" );
	}

	// Check if a radio maintains its value
	// after being appended to the DOM
	input = document.createElement("input");
	input.value = "t";
	input.setAttribute("type", "radio");
	support.radioValue = input.value === "t";

	input.setAttribute("checked", "checked");

	// #11217 - WebKit loses check when the name is after the checked attribute
	input.setAttribute( "name", "t" );

	div.appendChild( input );
	fragment = document.createDocumentFragment();
	fragment.appendChild( div.lastChild );

	// WebKit doesn't clone checked state correctly in fragments
	support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Check if a disconnected checkbox will retain its checked
	// value of true after appended to the DOM (IE6/7)
	support.appendChecked = input.checked;

	fragment.removeChild( input );
	fragment.appendChild( div );

	// Technique from Juriy Zaytsev
	// http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
	// We only care about the case where non-standard event systems
	// are used, namely in IE. Short-circuiting here helps us to
	// avoid an eval call (in setAttribute) which can cause CSP
	// to go haywire. See: https://developer.mozilla.org/en/Security/CSP
	if ( div.attachEvent ) {
		for ( i in {
			submit: 1,
			change: 1,
			focusin: 1
		}) {
			eventName = "on" + i;
			isSupported = ( eventName in div );
			if ( !isSupported ) {
				div.setAttribute( eventName, "return;" );
				isSupported = ( typeof div[ eventName ] === "function" );
			}
			support[ i + "Bubbles" ] = isSupported;
		}
	}

	fragment.removeChild( div );

	// Null elements to avoid leaks in IE
	fragment = select = opt = div = input = null;

	// Run tests that need a body at doc ready
	jQuery(function() {
		var container, outer, inner, table, td, offsetSupport,
			marginDiv, conMarginTop, style, html, positionTopLeftWidthHeight,
			paddingMarginBorderVisibility, paddingMarginBorder,
			body = document.getElementsByTagName("body")[0];

		if ( !body ) {
			// Return for frameset docs that don't have a body
			return;
		}

		conMarginTop = 1;
		paddingMarginBorder = "padding:0;margin:0;border:";
		positionTopLeftWidthHeight = "position:absolute;top:0;left:0;width:1px;height:1px;";
		paddingMarginBorderVisibility = paddingMarginBorder + "0;visibility:hidden;";
		style = "style='" + positionTopLeftWidthHeight + paddingMarginBorder + "5px solid #000;";
		html = "<div " + style + "display:block;'><div style='" + paddingMarginBorder + "0;display:block;overflow:hidden;'></div></div>" +
			"<table " + style + "' cellpadding='0' cellspacing='0'>" +
			"<tr><td></td></tr></table>";

		container = document.createElement("div");
		container.style.cssText = paddingMarginBorderVisibility + "width:0;height:0;position:static;top:0;margin-top:" + conMarginTop + "px";
		body.insertBefore( container, body.firstChild );

		// Construct the test element
		div = document.createElement("div");
		container.appendChild( div );

		// Check if table cells still have offsetWidth/Height when they are set
		// to display:none and there are still other visible table cells in a
		// table row; if so, offsetWidth/Height are not reliable for use when
		// determining if an element has been hidden directly using
		// display:none (it is still safe to use offsets if a parent element is
		// hidden; don safety goggles and see bug #4512 for more information).
		// (only IE 8 fails this test)
		div.innerHTML = "<table><tr><td style='" + paddingMarginBorder + "0;display:none'></td><td>t</td></tr></table>";
		tds = div.getElementsByTagName( "td" );
		isSupported = ( tds[ 0 ].offsetHeight === 0 );

		tds[ 0 ].style.display = "";
		tds[ 1 ].style.display = "none";

		// Check if empty table cells still have offsetWidth/Height
		// (IE <= 8 fail this test)
		support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );

		// Check if div with explicit width and no margin-right incorrectly
		// gets computed margin-right based on width of container. For more
		// info see bug #3333
		// Fails in WebKit before Feb 2011 nightlies
		// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
		if ( window.getComputedStyle ) {
			div.innerHTML = "";
			marginDiv = document.createElement( "div" );
			marginDiv.style.width = "0";
			marginDiv.style.marginRight = "0";
			div.style.width = "2px";
			div.appendChild( marginDiv );
			support.reliableMarginRight =
				( parseInt( ( window.getComputedStyle( marginDiv, null ) || { marginRight: 0 } ).marginRight, 10 ) || 0 ) === 0;
		}

		if ( typeof div.style.zoom !== "undefined" ) {
			// Check if natively block-level elements act like inline-block
			// elements when setting their display to 'inline' and giving
			// them layout
			// (IE < 8 does this)
			div.innerHTML = "";
			div.style.width = div.style.padding = "1px";
			div.style.border = 0;
			div.style.overflow = "hidden";
			div.style.display = "inline";
			div.style.zoom = 1;
			support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );

			// Check if elements with layout shrink-wrap their children
			// (IE 6 does this)
			div.style.display = "block";
			div.style.overflow = "visible";
			div.innerHTML = "<div style='width:5px;'></div>";
			support.shrinkWrapBlocks = ( div.offsetWidth !== 3 );
		}

		div.style.cssText = positionTopLeftWidthHeight + paddingMarginBorderVisibility;
		div.innerHTML = html;

		outer = div.firstChild;
		inner = outer.firstChild;
		td = outer.nextSibling.firstChild.firstChild;

		offsetSupport = {
			doesNotAddBorder: ( inner.offsetTop !== 5 ),
			doesAddBorderForTableAndCells: ( td.offsetTop === 5 )
		};

		inner.style.position = "fixed";
		inner.style.top = "20px";

		// safari subtracts parent border width here which is 5px
		offsetSupport.fixedPosition = ( inner.offsetTop === 20 || inner.offsetTop === 15 );
		inner.style.position = inner.style.top = "";

		outer.style.overflow = "hidden";
		outer.style.position = "relative";

		offsetSupport.subtractsBorderForOverflowNotVisible = ( inner.offsetTop === -5 );
		offsetSupport.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== conMarginTop );

		if ( window.getComputedStyle ) {
			div.style.marginTop = "1%";
			support.pixelMargin = ( window.getComputedStyle( div, null ) || { marginTop: 0 } ).marginTop !== "1%";
		}

		if ( typeof container.style.zoom !== "undefined" ) {
			container.style.zoom = 1;
		}

		body.removeChild( container );
		marginDiv = div = container = null;

		jQuery.extend( support, offsetSupport );
	});

	return support;
})();




var rbrace = /^(?:\{.*\}|\[.*\])$/,
	rmultiDash = /([A-Z])/g;

jQuery.extend({
	cache: {},

	// Please use with caution
	uuid: 0,

	// Unique for each copy of jQuery on the page
	// Non-digits removed to match rinlinejQuery
	expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),

	// The following elements throw uncatchable exceptions if you
	// attempt to add expando properties to them.
	noData: {
		"embed": true,
		// Ban all objects except for Flash (which handle expandos)
		"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
		"applet": true
	},

	hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
		return !!elem && !isEmptyDataObject( elem );
	},

	data: function( elem, name, data, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var privateCache, thisCache, ret,
			internalKey = jQuery.expando,
			getByName = typeof name === "string",

			// We have to handle DOM nodes and JS objects differently because IE6-7
			// can't GC object references properly across the DOM-JS boundary
			isNode = elem.nodeType,

			// Only DOM nodes need the global jQuery cache; JS object data is
			// attached directly to the object so GC can occur automatically
			cache = isNode ? jQuery.cache : elem,

			// Only defining an ID for JS objects if its cache already exists allows
			// the code to shortcut on the same path as a DOM node with no cache
			id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey,
			isEvents = name === "events";

		// Avoid doing any more work than we need to when trying to get data on an
		// object that has no data at all
		if ( (!id || !cache[id] || (!isEvents && !pvt && !cache[id].data)) && getByName && data === undefined ) {
			return;
		}

		if ( !id ) {
			// Only DOM nodes need a new unique ID for each element since their data
			// ends up in the global cache
			if ( isNode ) {
				elem[ internalKey ] = id = ++jQuery.uuid;
			} else {
				id = internalKey;
			}
		}

		if ( !cache[ id ] ) {
			cache[ id ] = {};

			// Avoids exposing jQuery metadata on plain JS objects when the object
			// is serialized using JSON.stringify
			if ( !isNode ) {
				cache[ id ].toJSON = jQuery.noop;
			}
		}

		// An object can be passed to jQuery.data instead of a key/value pair; this gets
		// shallow copied over onto the existing cache
		if ( typeof name === "object" || typeof name === "function" ) {
			if ( pvt ) {
				cache[ id ] = jQuery.extend( cache[ id ], name );
			} else {
				cache[ id ].data = jQuery.extend( cache[ id ].data, name );
			}
		}

		privateCache = thisCache = cache[ id ];

		// jQuery data() is stored in a separate object inside the object's internal data
		// cache in order to avoid key collisions between internal data and user-defined
		// data.
		if ( !pvt ) {
			if ( !thisCache.data ) {
				thisCache.data = {};
			}

			thisCache = thisCache.data;
		}

		if ( data !== undefined ) {
			thisCache[ jQuery.camelCase( name ) ] = data;
		}

		// Users should not attempt to inspect the internal events object using jQuery.data,
		// it is undocumented and subject to change. But does anyone listen? No.
		if ( isEvents && !thisCache[ name ] ) {
			return privateCache.events;
		}

		// Check for both converted-to-camel and non-converted data property names
		// If a data property was specified
		if ( getByName ) {

			// First Try to find as-is property data
			ret = thisCache[ name ];

			// Test for null|undefined property data
			if ( ret == null ) {

				// Try to find the camelCased property
				ret = thisCache[ jQuery.camelCase( name ) ];
			}
		} else {
			ret = thisCache;
		}

		return ret;
	},

	removeData: function( elem, name, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var thisCache, i, l,

			// Reference to internal data cache key
			internalKey = jQuery.expando,

			isNode = elem.nodeType,

			// See jQuery.data for more information
			cache = isNode ? jQuery.cache : elem,

			// See jQuery.data for more information
			id = isNode ? elem[ internalKey ] : internalKey;

		// If there is already no cache entry for this object, there is no
		// purpose in continuing
		if ( !cache[ id ] ) {
			return;
		}

		if ( name ) {

			thisCache = pvt ? cache[ id ] : cache[ id ].data;

			if ( thisCache ) {

				// Support array or space separated string names for data keys
				if ( !jQuery.isArray( name ) ) {

					// try the string as a key before any manipulation
					if ( name in thisCache ) {
						name = [ name ];
					} else {

						// split the camel cased version by spaces unless a key with the spaces exists
						name = jQuery.camelCase( name );
						if ( name in thisCache ) {
							name = [ name ];
						} else {
							name = name.split( " " );
						}
					}
				}

				for ( i = 0, l = name.length; i < l; i++ ) {
					delete thisCache[ name[i] ];
				}

				// If there is no data left in the cache, we want to continue
				// and let the cache object itself get destroyed
				if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
					return;
				}
			}
		}

		// See jQuery.data for more information
		if ( !pvt ) {
			delete cache[ id ].data;

			// Don't destroy the parent cache unless the internal data object
			// had been the only thing left in it
			if ( !isEmptyDataObject(cache[ id ]) ) {
				return;
			}
		}

		// Browsers that fail expando deletion also refuse to delete expandos on
		// the window, but it will allow it on all other JS objects; other browsers
		// don't care
		// Ensure that `cache` is not a window object #10080
		if ( jQuery.support.deleteExpando || !cache.setInterval ) {
			delete cache[ id ];
		} else {
			cache[ id ] = null;
		}

		// We destroyed the cache and need to eliminate the expando on the node to avoid
		// false lookups in the cache for entries that no longer exist
		if ( isNode ) {
			// IE does not allow us to delete expando properties from nodes,
			// nor does it have a removeAttribute function on Document nodes;
			// we must handle all of these cases
			if ( jQuery.support.deleteExpando ) {
				delete elem[ internalKey ];
			} else if ( elem.removeAttribute ) {
				elem.removeAttribute( internalKey );
			} else {
				elem[ internalKey ] = null;
			}
		}
	},

	// For internal use only.
	_data: function( elem, name, data ) {
		return jQuery.data( elem, name, data, true );
	},

	// A method for determining if a DOM node can handle the data expando
	acceptData: function( elem ) {
		if ( elem.nodeName ) {
			var match = jQuery.noData[ elem.nodeName.toLowerCase() ];

			if ( match ) {
				return !(match === true || elem.getAttribute("classid") !== match);
			}
		}

		return true;
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var parts, part, attr, name, l,
			elem = this[0],
			i = 0,
			data = null;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = jQuery.data( elem );

				if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
					attr = elem.attributes;
					for ( l = attr.length; i < l; i++ ) {
						name = attr[i].name;

						if ( name.indexOf( "data-" ) === 0 ) {
							name = jQuery.camelCase( name.substring(5) );

							dataAttr( elem, name, data[ name ] );
						}
					}
					jQuery._data( elem, "parsedAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		parts = key.split( ".", 2 );
		parts[1] = parts[1] ? "." + parts[1] : "";
		part = parts[1] + "!";

		return jQuery.access( this, function( value ) {

			if ( value === undefined ) {
				data = this.triggerHandler( "getData" + part, [ parts[0] ] );

				// Try to fetch any internally stored data first
				if ( data === undefined && elem ) {
					data = jQuery.data( elem, key );
					data = dataAttr( elem, key, data );
				}

				return data === undefined && parts[1] ?
					this.data( parts[0] ) :
					data;
			}

			parts[1] = value;
			this.each(function() {
				var self = jQuery( this );

				self.triggerHandler( "setData" + part, parts );
				jQuery.data( this, key, value );
				self.triggerHandler( "changeData" + part, parts );
			});
		}, null, value, arguments.length > 1, null, false );
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});

function dataAttr( elem, key, data ) {
	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {

		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
				data === "false" ? false :
				data === "null" ? null :
				jQuery.isNumeric( data ) ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
	for ( var name in obj ) {

		// if the public data object is empty, the private is still empty
		if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
			continue;
		}
		if ( name !== "toJSON" ) {
			return false;
		}
	}

	return true;
}




function handleQueueMarkDefer( elem, type, src ) {
	var deferDataKey = type + "defer",
		queueDataKey = type + "queue",
		markDataKey = type + "mark",
		defer = jQuery._data( elem, deferDataKey );
	if ( defer &&
		( src === "queue" || !jQuery._data(elem, queueDataKey) ) &&
		( src === "mark" || !jQuery._data(elem, markDataKey) ) ) {
		// Give room for hard-coded callbacks to fire first
		// and eventually mark/queue something else on the element
		setTimeout( function() {
			if ( !jQuery._data( elem, queueDataKey ) &&
				!jQuery._data( elem, markDataKey ) ) {
				jQuery.removeData( elem, deferDataKey, true );
				defer.fire();
			}
		}, 0 );
	}
}

jQuery.extend({

	_mark: function( elem, type ) {
		if ( elem ) {
			type = ( type || "fx" ) + "mark";
			jQuery._data( elem, type, (jQuery._data( elem, type ) || 0) + 1 );
		}
	},

	_unmark: function( force, elem, type ) {
		if ( force !== true ) {
			type = elem;
			elem = force;
			force = false;
		}
		if ( elem ) {
			type = type || "fx";
			var key = type + "mark",
				count = force ? 0 : ( (jQuery._data( elem, key ) || 1) - 1 );
			if ( count ) {
				jQuery._data( elem, key, count );
			} else {
				jQuery.removeData( elem, key, true );
				handleQueueMarkDefer( elem, type, "mark" );
			}
		}
	},

	queue: function( elem, type, data ) {
		var q;
		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			q = jQuery._data( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !q || jQuery.isArray(data) ) {
					q = jQuery._data( elem, type, jQuery.makeArray(data) );
				} else {
					q.push( data );
				}
			}
			return q || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			fn = queue.shift(),
			hooks = {};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
		}

		if ( fn ) {
			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			jQuery._data( elem, type + ".run", hooks );
			fn.call( elem, function() {
				jQuery.dequeue( elem, type );
			}, hooks );
		}

		if ( !queue.length ) {
			jQuery.removeData( elem, type + "queue " + type + ".run", true );
			handleQueueMarkDefer( elem, type, "queue" );
		}
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	delay: function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = setTimeout( next, time );
			hooks.stop = function() {
				clearTimeout( timeout );
			};
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, object ) {
		if ( typeof type !== "string" ) {
			object = type;
			type = undefined;
		}
		type = type || "fx";
		var defer = jQuery.Deferred(),
			elements = this,
			i = elements.length,
			count = 1,
			deferDataKey = type + "defer",
			queueDataKey = type + "queue",
			markDataKey = type + "mark",
			tmp;
		function resolve() {
			if ( !( --count ) ) {
				defer.resolveWith( elements, [ elements ] );
			}
		}
		while( i-- ) {
			if (( tmp = jQuery.data( elements[ i ], deferDataKey, undefined, true ) ||
					( jQuery.data( elements[ i ], queueDataKey, undefined, true ) ||
						jQuery.data( elements[ i ], markDataKey, undefined, true ) ) &&
					jQuery.data( elements[ i ], deferDataKey, jQuery.Callbacks( "once memory" ), true ) )) {
				count++;
				tmp.add( resolve );
			}
		}
		resolve();
		return defer.promise( object );
	}
});




var rclass = /[\n\t\r]/g,
	rspace = /\s+/,
	rreturn = /\r/g,
	rtype = /^(?:button|input)$/i,
	rfocusable = /^(?:button|input|object|select|textarea)$/i,
	rclickable = /^a(?:rea)?$/i,
	rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
	getSetAttribute = jQuery.support.getSetAttribute,
	nodeHook, boolHook, fixSpecified;

jQuery.fn.extend({
	attr: function( name, value ) {
		return jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	},

	prop: function( name, value ) {
		return jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each(function() {
			// try/catch handles cases where IE balks (such as removing a property on window)
			try {
				this[ name ] = undefined;
				delete this[ name ];
			} catch( e ) {}
		});
	},

	addClass: function( value ) {
		var classNames, i, l, elem,
			setClass, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call(this, j, this.className) );
			});
		}

		if ( value && typeof value === "string" ) {
			classNames = value.split( rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 ) {
					if ( !elem.className && classNames.length === 1 ) {
						elem.className = value;

					} else {
						setClass = " " + elem.className + " ";

						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							if ( !~setClass.indexOf( " " + classNames[ c ] + " " ) ) {
								setClass += classNames[ c ] + " ";
							}
						}
						elem.className = jQuery.trim( setClass );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classNames, i, l, elem, className, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call(this, j, this.className) );
			});
		}

		if ( (value && typeof value === "string") || value === undefined ) {
			classNames = ( value || "" ).split( rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 && elem.className ) {
					if ( value ) {
						className = (" " + elem.className + " ").replace( rclass, " " );
						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							className = className.replace(" " + classNames[ c ] + " ", " ");
						}
						elem.className = jQuery.trim( className );

					} else {
						elem.className = "";
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isBool = typeof stateVal === "boolean";

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					state = stateVal,
					classNames = value.split( rspace );

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space seperated list
					state = isBool ? state : !self.hasClass( className );
					self[ state ? "addClass" : "removeClass" ]( className );
				}

			} else if ( type === "undefined" || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					jQuery._data( this, "__className__", this.className );
				}

				// toggle whole className
				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	},

	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var self = jQuery(this), val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, self.val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map(val, function ( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				// attributes.value is undefined in Blackberry 4.7 but
				// uses .value. See #6932
				var val = elem.attributes.value;
				return !val || val.specified ? elem.value : elem.text;
			}
		},
		select: {
			get: function( elem ) {
				var value, i, max, option,
					index = elem.selectedIndex,
					values = [],
					options = elem.options,
					one = elem.type === "select-one";

				// Nothing was selected
				if ( index < 0 ) {
					return null;
				}

				// Loop through all the selected options
				i = one ? index : 0;
				max = one ? index + 1 : options.length;
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Don't return options that are disabled or in a disabled optgroup
					if ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
							(!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" )) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				// Fixes Bug #2551 -- select.val() broken in IE after form.reset()
				if ( one && !values.length && options.length ) {
					return jQuery( options[ index ] ).val();
				}

				return values;
			},

			set: function( elem, value ) {
				var values = jQuery.makeArray( value );

				jQuery(elem).find("option").each(function() {
					this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
				});

				if ( !values.length ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	},

	attrFn: {
		val: true,
		css: true,
		html: true,
		text: true,
		data: true,
		width: true,
		height: true,
		offset: true
	},

	attr: function( elem, name, value, pass ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( pass && name in jQuery.attrFn ) {
			return jQuery( elem )[ name ]( value );
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( notxml ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;

			} else if ( hooks && "set" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, "" + value );
				return value;
			}

		} else if ( hooks && "get" in hooks && notxml && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {

			ret = elem.getAttribute( name );

			// Non-existent attributes return null, we normalize to undefined
			return ret === null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var propName, attrNames, name, l, isBool,
			i = 0;

		if ( value && elem.nodeType === 1 ) {
			attrNames = value.toLowerCase().split( rspace );
			l = attrNames.length;

			for ( ; i < l; i++ ) {
				name = attrNames[ i ];

				if ( name ) {
					propName = jQuery.propFix[ name ] || name;
					isBool = rboolean.test( name );

					// See #9699 for explanation of this approach (setting first, then removal)
					// Do not do this for boolean attributes (see #10870)
					if ( !isBool ) {
						jQuery.attr( elem, name, "" );
					}
					elem.removeAttribute( getSetAttribute ? name : propName );

					// Set corresponding property to false for boolean attributes
					if ( isBool && propName in elem ) {
						elem[ propName ] = false;
					}
				}
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				// We can't allow the type property to be changed (since it causes problems in IE)
				if ( rtype.test( elem.nodeName ) && elem.parentNode ) {
					jQuery.error( "type property can't be changed" );
				} else if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to it's default in case type is set after value
					// This is for element creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		},
		// Use the value property for back compat
		// Use the nodeHook for button elements in IE6/7 (#1954)
		value: {
			get: function( elem, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.get( elem, name );
				}
				return name in elem ?
					elem.value :
					null;
			},
			set: function( elem, value, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.set( elem, value, name );
				}
				// Does not return so that setAttribute is also used
				elem.value = value;
			}
		}
	},

	propFix: {
		tabindex: "tabIndex",
		readonly: "readOnly",
		"for": "htmlFor",
		"class": "className",
		maxlength: "maxLength",
		cellspacing: "cellSpacing",
		cellpadding: "cellPadding",
		rowspan: "rowSpan",
		colspan: "colSpan",
		usemap: "useMap",
		frameborder: "frameBorder",
		contenteditable: "contentEditable"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				return ( elem[ name ] = value );
			}

		} else {
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
				return ret;

			} else {
				return elem[ name ];
			}
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				var attributeNode = elem.getAttributeNode("tabindex");

				return attributeNode && attributeNode.specified ?
					parseInt( attributeNode.value, 10 ) :
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
						0 :
						undefined;
			}
		}
	}
});

// Add the tabIndex propHook to attrHooks for back-compat (different case is intentional)
jQuery.attrHooks.tabindex = jQuery.propHooks.tabIndex;

// Hook for boolean attributes
boolHook = {
	get: function( elem, name ) {
		// Align boolean attributes with corresponding properties
		// Fall back to attribute presence where some booleans are not supported
		var attrNode,
			property = jQuery.prop( elem, name );
		return property === true || typeof property !== "boolean" && ( attrNode = elem.getAttributeNode(name) ) && attrNode.nodeValue !== false ?
			name.toLowerCase() :
			undefined;
	},
	set: function( elem, value, name ) {
		var propName;
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			// value is true since we know at this point it's type boolean and not false
			// Set boolean attributes to the same name and set the DOM property
			propName = jQuery.propFix[ name ] || name;
			if ( propName in elem ) {
				// Only set the IDL specifically if it already exists on the element
				elem[ propName ] = true;
			}

			elem.setAttribute( name, name.toLowerCase() );
		}
		return name;
	}
};

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

	fixSpecified = {
		name: true,
		id: true,
		coords: true
	};

	// Use this for any attribute in IE6/7
	// This fixes almost every IE6/7 issue
	nodeHook = jQuery.valHooks.button = {
		get: function( elem, name ) {
			var ret;
			ret = elem.getAttributeNode( name );
			return ret && ( fixSpecified[ name ] ? ret.nodeValue !== "" : ret.specified ) ?
				ret.nodeValue :
				undefined;
		},
		set: function( elem, value, name ) {
			// Set the existing or create a new attribute node
			var ret = elem.getAttributeNode( name );
			if ( !ret ) {
				ret = document.createAttribute( name );
				elem.setAttributeNode( ret );
			}
			return ( ret.nodeValue = value + "" );
		}
	};

	// Apply the nodeHook to tabindex
	jQuery.attrHooks.tabindex.set = nodeHook.set;

	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
	// This is for removals
	jQuery.each([ "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			set: function( elem, value ) {
				if ( value === "" ) {
					elem.setAttribute( name, "auto" );
					return value;
				}
			}
		});
	});

	// Set contenteditable to false on removals(#10429)
	// Setting to empty string throws an error as an invalid value
	jQuery.attrHooks.contenteditable = {
		get: nodeHook.get,
		set: function( elem, value, name ) {
			if ( value === "" ) {
				value = "false";
			}
			nodeHook.set( elem, value, name );
		}
	};
}


// Some attributes require a special call on IE
if ( !jQuery.support.hrefNormalized ) {
	jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			get: function( elem ) {
				var ret = elem.getAttribute( name, 2 );
				return ret === null ? undefined : ret;
			}
		});
	});
}

if ( !jQuery.support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {
			// Return undefined in the case of empty string
			// Normalize to lowercase since IE uppercases css property names
			return elem.style.cssText.toLowerCase() || undefined;
		},
		set: function( elem, value ) {
			return ( elem.style.cssText = "" + value );
		}
	};
}

// Safari mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !jQuery.support.optSelected ) {
	jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
		get: function( elem ) {
			var parent = elem.parentNode;

			if ( parent ) {
				parent.selectedIndex;

				// Make sure that it also works with optgroups, see #5701
				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
			return null;
		}
	});
}

// IE6/7 call enctype encoding
if ( !jQuery.support.enctype ) {
	jQuery.propFix.enctype = "encoding";
}

// Radios and checkboxes getter/setter
if ( !jQuery.support.checkOn ) {
	jQuery.each([ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			get: function( elem ) {
				// Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
				return elem.getAttribute("value") === null ? "on" : elem.value;
			}
		};
	});
}
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	});
});




var rformElems = /^(?:textarea|input|select)$/i,
	rtypenamespace = /^([^\.]*)?(?:\.(.+))?$/,
	rhoverHack = /(?:^|\s)hover(\.\S+)?\b/,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rquickIs = /^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,
	quickParse = function( selector ) {
		var quick = rquickIs.exec( selector );
		if ( quick ) {
			//   0  1    2   3
			// [ _, tag, id, class ]
			quick[1] = ( quick[1] || "" ).toLowerCase();
			quick[3] = quick[3] && new RegExp( "(?:^|\\s)" + quick[3] + "(?:\\s|$)" );
		}
		return quick;
	},
	quickIs = function( elem, m ) {
		var attrs = elem.attributes || {};
		return (
			(!m[1] || elem.nodeName.toLowerCase() === m[1]) &&
			(!m[2] || (attrs.id || {}).value === m[2]) &&
			(!m[3] || m[3].test( (attrs[ "class" ] || {}).value ))
		);
	},
	hoverHack = function( events ) {
		return jQuery.event.special.hover ? events : events.replace( rhoverHack, "mouseenter$1 mouseleave$1" );
	};

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	add: function( elem, types, handler, data, selector ) {

		var elemData, eventHandle, events,
			t, tns, type, namespaces, handleObj,
			handleObjIn, quick, handlers, special;

		// Don't attach events to noData or text/comment nodes (allow plain objects tho)
		if ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		events = elemData.events;
		if ( !events ) {
			elemData.events = events = {};
		}
		eventHandle = elemData.handle;
		if ( !eventHandle ) {
			elemData.handle = eventHandle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
					undefined;
			};
			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
			eventHandle.elem = elem;
		}

		// Handle multiple events separated by a space
		// jQuery(...).bind("mouseover mouseout", fn);
		types = jQuery.trim( hoverHack(types) ).split( " " );
		for ( t = 0; t < types.length; t++ ) {

			tns = rtypenamespace.exec( types[t] ) || [];
			type = tns[1];
			namespaces = ( tns[2] || "" ).split( "." ).sort();

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: tns[1],
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				quick: selector && quickParse( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			handlers = events[ type ];
			if ( !handlers ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener/attachEvent if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					// Bind the global event handler to the element
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	global: {},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var elemData = jQuery.hasData( elem ) && jQuery._data( elem ),
			t, tns, type, origType, namespaces, origCount,
			j, events, special, handle, eventType, handleObj;

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = jQuery.trim( hoverHack( types || "" ) ).split(" ");
		for ( t = 0; t < types.length; t++ ) {
			tns = rtypenamespace.exec( types[t] ) || [];
			type = origType = tns[1];
			namespaces = tns[2];

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector? special.delegateType : special.bindType ) || type;
			eventType = events[ type ] || [];
			origCount = eventType.length;
			namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.)?") + "(\\.|$)") : null;

			// Remove matching events
			for ( j = 0; j < eventType.length; j++ ) {
				handleObj = eventType[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					 ( !handler || handler.guid === handleObj.guid ) &&
					 ( !namespaces || namespaces.test( handleObj.namespace ) ) &&
					 ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					eventType.splice( j--, 1 );

					if ( handleObj.selector ) {
						eventType.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( eventType.length === 0 && origCount !== eventType.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			handle = elemData.handle;
			if ( handle ) {
				handle.elem = null;
			}

			// removeData also checks for emptiness and clears the expando if empty
			// so use it instead of delete
			jQuery.removeData( elem, [ "events", "handle" ], true );
		}
	},

	// Events that are safe to short-circuit if no handlers are attached.
	// Native DOM events should not be added, they may have inline handlers.
	customEvent: {
		"getData": true,
		"setData": true,
		"changeData": true
	},

	trigger: function( event, data, elem, onlyHandlers ) {
		// Don't do events on text and comment nodes
		if ( elem && (elem.nodeType === 3 || elem.nodeType === 8) ) {
			return;
		}

		// Event object or event type
		var type = event.type || event,
			namespaces = [],
			cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType;

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "!" ) >= 0 ) {
			// Exclusive events trigger only for the exact event (no namespaces)
			type = type.slice(0, -1);
			exclusive = true;
		}

		if ( type.indexOf( "." ) >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}

		if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
			// No jQuery handlers for this event type, and it can't have inline handlers
			return;
		}

		// Caller can pass in an Event, Object, or just an event type string
		event = typeof event === "object" ?
			// jQuery.Event object
			event[ jQuery.expando ] ? event :
			// Object literal
			new jQuery.Event( type, event ) :
			// Just the event type (string)
			new jQuery.Event( type );

		event.type = type;
		event.isTrigger = true;
		event.exclusive = exclusive;
		event.namespace = namespaces.join( "." );
		event.namespace_re = event.namespace? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.)?") + "(\\.|$)") : null;
		ontype = type.indexOf( ":" ) < 0 ? "on" + type : "";

		// Handle a global trigger
		if ( !elem ) {

			// TODO: Stop taunting the data cache; remove global events and always attach to document
			cache = jQuery.cache;
			for ( i in cache ) {
				if ( cache[ i ].events && cache[ i ].events[ type ] ) {
					jQuery.event.trigger( event, data, cache[ i ].handle.elem, true );
				}
			}
			return;
		}

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data != null ? jQuery.makeArray( data ) : [];
		data.unshift( event );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		eventPath = [[ elem, special.bindType || type ]];
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			cur = rfocusMorph.test( bubbleType + type ) ? elem : elem.parentNode;
			old = null;
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push([ cur, bubbleType ]);
				old = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( old && old === elem.ownerDocument ) {
				eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);
			}
		}

		// Fire handlers on the event path
		for ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {

			cur = eventPath[i][0];
			event.type = eventPath[i][1];

			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}
			// Note that this is a bare JS function and not a jQuery handler
			handle = ontype && cur[ ontype ];
			if ( handle && jQuery.acceptData( cur ) && handle.apply( cur, data ) === false ) {
				event.preventDefault();
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
				!(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Can't use an .isFunction() check here because IE6/7 fails that test.
				// Don't do default actions on window, that's where global variables be (#6170)
				// IE<9 dies on focus/blur to hidden element (#1486)
				if ( ontype && elem[ type ] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					old = elem[ ontype ];

					if ( old ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( old ) {
						elem[ ontype ] = old;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event || window.event );

		var handlers = ( (jQuery._data( this, "events" ) || {} )[ event.type ] || []),
			delegateCount = handlers.delegateCount,
			args = [].slice.call( arguments, 0 ),
			run_all = !event.exclusive && !event.namespace,
			special = jQuery.event.special[ event.type ] || {},
			handlerQueue = [],
			i, j, cur, jqcur, ret, selMatch, matched, matches, handleObj, sel, related;

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers that should run if there are delegated events
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && !(event.button && event.type === "click") ) {

			// Pregenerate a single jQuery object for reuse with .is()
			jqcur = jQuery(this);
			jqcur.context = this.ownerDocument || this;

			for ( cur = event.target; cur != this; cur = cur.parentNode || this ) {

				// Don't process events on disabled elements (#6911, #8165)
				if ( cur.disabled !== true ) {
					selMatch = {};
					matches = [];
					jqcur[0] = cur;
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];
						sel = handleObj.selector;

						if ( selMatch[ sel ] === undefined ) {
							selMatch[ sel ] = (
								handleObj.quick ? quickIs( cur, handleObj.quick ) : jqcur.is( sel )
							);
						}
						if ( selMatch[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, matches: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( handlers.length > delegateCount ) {
			handlerQueue.push({ elem: this, matches: handlers.slice( delegateCount ) });
		}

		// Run delegates first; they may want to stop propagation beneath us
		for ( i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++ ) {
			matched = handlerQueue[ i ];
			event.currentTarget = matched.elem;

			for ( j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++ ) {
				handleObj = matched.matches[ j ];

				// Triggered event must either 1) be non-exclusive and have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test( handleObj.namespace ) ) {

					event.data = handleObj.data;
					event.handleObj = handleObj;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						event.result = ret;
						if ( ret === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	// *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
	props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button,
				fromElement = original.fromElement;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add relatedTarget, if necessary
			if ( !event.relatedTarget && fromElement ) {
				event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop,
			originalEvent = event,
			fixHook = jQuery.event.fixHooks[ event.type ] || {},
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = jQuery.Event( originalEvent );

		for ( i = copy.length; i; ) {
			prop = copy[ --i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)
		if ( !event.target ) {
			event.target = originalEvent.srcElement || document;
		}

		// Target should not be a text node (#504, Safari)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// For mouse/key events; add metaKey if it's not there (#3368, IE6/7/8)
		if ( event.metaKey === undefined ) {
			event.metaKey = event.ctrlKey;
		}

		return fixHook.filter? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		ready: {
			// Make sure the ready event is setup
			setup: jQuery.bindReady
		},

		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},

		focus: {
			delegateType: "focusin"
		},
		blur: {
			delegateType: "focusout"
		},

		beforeunload: {
			setup: function( data, namespaces, eventHandle ) {
				// We only want to do this special case on windows
				if ( jQuery.isWindow( this ) ) {
					this.onbeforeunload = eventHandle;
				}
			},

			teardown: function( namespaces, eventHandle ) {
				if ( this.onbeforeunload === eventHandle ) {
					this.onbeforeunload = null;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{ type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

// Some plugins are using, but it's undocumented/deprecated and will be removed.
// The 1.7 special event interface should provide all the hooks needed now.
jQuery.event.handle = jQuery.event.dispatch;

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		if ( elem.detachEvent ) {
			elem.detachEvent( "on" + type, handle );
		}
	};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
			src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

function returnFalse() {
	return false;
}
function returnTrue() {
	return true;
}

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	preventDefault: function() {
		this.isDefaultPrevented = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}

		// if preventDefault exists run it on the original event
		if ( e.preventDefault ) {
			e.preventDefault();

		// otherwise set the returnValue property of the original event to false (IE)
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		this.isPropagationStopped = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}
		// if stopPropagation exists run it on the original event
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}
		// otherwise set the cancelBubble property of the original event to true (IE)
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	},
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj,
				selector = handleObj.selector,
				ret;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// IE submit delegation
if ( !jQuery.support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Lazy-add a submit handler when a descendant form may potentially be submitted
			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
				// Node name check avoids a VML-related crash in IE (#9807)
				var elem = e.target,
					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
				if ( form && !form._submit_attached ) {
					jQuery.event.add( form, "submit._submit", function( event ) {
						event._submit_bubble = true;
					});
					form._submit_attached = true;
				}
			});
			// return undefined since we don't need an event listener
		},
		
		postDispatch: function( event ) {
			// If form was submitted by the user, bubble the event up the tree
			if ( event._submit_bubble ) {
				delete event._submit_bubble;
				if ( this.parentNode && !event.isTrigger ) {
					jQuery.event.simulate( "submit", this.parentNode, event, true );
				}
			}
		},

		teardown: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
			jQuery.event.remove( this, "._submit" );
		}
	};
}

// IE change delegation and checkbox/radio fix
if ( !jQuery.support.changeBubbles ) {

	jQuery.event.special.change = {

		setup: function() {

			if ( rformElems.test( this.nodeName ) ) {
				// IE doesn't fire change on a check/radio until blur; trigger it on click
				// after a propertychange. Eat the blur-change in special.change.handle.
				// This still fires onchange a second time for check/radio after blur.
				if ( this.type === "checkbox" || this.type === "radio" ) {
					jQuery.event.add( this, "propertychange._change", function( event ) {
						if ( event.originalEvent.propertyName === "checked" ) {
							this._just_changed = true;
						}
					});
					jQuery.event.add( this, "click._change", function( event ) {
						if ( this._just_changed && !event.isTrigger ) {
							this._just_changed = false;
							jQuery.event.simulate( "change", this, event, true );
						}
					});
				}
				return false;
			}
			// Delegated event; lazy-add a change handler on descendant inputs
			jQuery.event.add( this, "beforeactivate._change", function( e ) {
				var elem = e.target;

				if ( rformElems.test( elem.nodeName ) && !elem._change_attached ) {
					jQuery.event.add( elem, "change._change", function( event ) {
						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
							jQuery.event.simulate( "change", this.parentNode, event, true );
						}
					});
					elem._change_attached = true;
				}
			});
		},

		handle: function( event ) {
			var elem = event.target;

			// Swallow native change events from checkbox/radio, we already triggered them above
			if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
				return event.handleObj.handler.apply( this, arguments );
			}
		},

		teardown: function() {
			jQuery.event.remove( this, "._change" );

			return rformElems.test( this.nodeName );
		}
	};
}

// Create "bubbling" focus and blur events
if ( !jQuery.support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler while someone wants focusin/focusout
		var attaches = 0,
			handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				if ( attaches++ === 0 ) {
					document.addEventListener( orig, handler, true );
				}
			},
			teardown: function() {
				if ( --attaches === 0 ) {
					document.removeEventListener( orig, handler, true );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) { // && selector != null
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			var handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( var type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	live: function( types, data, fn ) {
		jQuery( this.context ).on( types, this.selector, data, fn );
		return this;
	},
	die: function( types, fn ) {
		jQuery( this.context ).off( types, this.selector || "**", fn );
		return this;
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length == 1? this.off( selector, "**" ) : this.off( types, selector, fn );
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		if ( this[0] ) {
			return jQuery.event.trigger( type, data, this[0], true );
		}
	},

	toggle: function( fn ) {
		// Save reference to arguments for access in closure
		var args = arguments,
			guid = fn.guid || jQuery.guid++,
			i = 0,
			toggler = function( event ) {
				// Figure out which function to execute
				var lastToggle = ( jQuery._data( this, "lastToggle" + fn.guid ) || 0 ) % i;
				jQuery._data( this, "lastToggle" + fn.guid, lastToggle + 1 );

				// Make sure that clicks stop
				event.preventDefault();

				// and execute the function
				return args[ lastToggle ].apply( this, arguments ) || false;
			};

		// link all the functions, so any of them can unbind this click handler
		toggler.guid = guid;
		while ( i < args.length ) {
			args[ i++ ].guid = guid;
		}

		return this.click( toggler );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
});

jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		if ( fn == null ) {
			fn = data;
			data = null;
		}

		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};

	if ( jQuery.attrFn ) {
		jQuery.attrFn[ name ] = true;
	}

	if ( rkeyEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;
	}

	if ( rmouseEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;
	}
});



/*!
 * Sizzle CSS Selector Engine
 *  Copyright 2011, The Dojo Foundation
 *  Released under the MIT, BSD, and GPL Licenses.
 *  More information: http://sizzlejs.com/
 */
(function(){

var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
	expando = "sizcache" + (Math.random() + '').replace('.', ''),
	done = 0,
	toString = Object.prototype.toString,
	hasDuplicate = false,
	baseHasDuplicate = true,
	rBackslash = /\\/g,
	rReturn = /\r\n/g,
	rNonWord = /\W/;

// Here we check if the JavaScript engine is using some sort of
// optimization where it does not always call our comparision
// function. If that is the case, discard the hasDuplicate value.
//   Thus far that includes Google Chrome.
[0, 0].sort(function() {
	baseHasDuplicate = false;
	return 0;
});

var Sizzle = function( selector, context, results, seed ) {
	results = results || [];
	context = context || document;

	var origContext = context;

	if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
		return [];
	}

	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	var m, set, checkSet, extra, ret, cur, pop, i,
		prune = true,
		contextXML = Sizzle.isXML( context ),
		parts = [],
		soFar = selector;

	// Reset the position of the chunker regexp (start from head)
	do {
		chunker.exec( "" );
		m = chunker.exec( soFar );

		if ( m ) {
			soFar = m[3];

			parts.push( m[1] );

			if ( m[2] ) {
				extra = m[3];
				break;
			}
		}
	} while ( m );

	if ( parts.length > 1 && origPOS.exec( selector ) ) {

		if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
			set = posProcess( parts[0] + parts[1], context, seed );

		} else {
			set = Expr.relative[ parts[0] ] ?
				[ context ] :
				Sizzle( parts.shift(), context );

			while ( parts.length ) {
				selector = parts.shift();

				if ( Expr.relative[ selector ] ) {
					selector += parts.shift();
				}

				set = posProcess( selector, set, seed );
			}
		}

	} else {
		// Take a shortcut and set the context if the root selector is an ID
		// (but not if it'll be faster if the inner selector is an ID)
		if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
				Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {

			ret = Sizzle.find( parts.shift(), context, contextXML );
			context = ret.expr ?
				Sizzle.filter( ret.expr, ret.set )[0] :
				ret.set[0];
		}

		if ( context ) {
			ret = seed ?
				{ expr: parts.pop(), set: makeArray(seed) } :
				Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );

			set = ret.expr ?
				Sizzle.filter( ret.expr, ret.set ) :
				ret.set;

			if ( parts.length > 0 ) {
				checkSet = makeArray( set );

			} else {
				prune = false;
			}

			while ( parts.length ) {
				cur = parts.pop();
				pop = cur;

				if ( !Expr.relative[ cur ] ) {
					cur = "";
				} else {
					pop = parts.pop();
				}

				if ( pop == null ) {
					pop = context;
				}

				Expr.relative[ cur ]( checkSet, pop, contextXML );
			}

		} else {
			checkSet = parts = [];
		}
	}

	if ( !checkSet ) {
		checkSet = set;
	}

	if ( !checkSet ) {
		Sizzle.error( cur || selector );
	}

	if ( toString.call(checkSet) === "[object Array]" ) {
		if ( !prune ) {
			results.push.apply( results, checkSet );

		} else if ( context && context.nodeType === 1 ) {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {
					results.push( set[i] );
				}
			}

		} else {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
					results.push( set[i] );
				}
			}
		}

	} else {
		makeArray( checkSet, results );
	}

	if ( extra ) {
		Sizzle( extra, origContext, results, seed );
		Sizzle.uniqueSort( results );
	}

	return results;
};

Sizzle.uniqueSort = function( results ) {
	if ( sortOrder ) {
		hasDuplicate = baseHasDuplicate;
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			for ( var i = 1; i < results.length; i++ ) {
				if ( results[i] === results[ i - 1 ] ) {
					results.splice( i--, 1 );
				}
			}
		}
	}

	return results;
};

Sizzle.matches = function( expr, set ) {
	return Sizzle( expr, null, null, set );
};

Sizzle.matchesSelector = function( node, expr ) {
	return Sizzle( expr, null, null, [node] ).length > 0;
};

Sizzle.find = function( expr, context, isXML ) {
	var set, i, len, match, type, left;

	if ( !expr ) {
		return [];
	}

	for ( i = 0, len = Expr.order.length; i < len; i++ ) {
		type = Expr.order[i];

		if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
			left = match[1];
			match.splice( 1, 1 );

			if ( left.substr( left.length - 1 ) !== "\\" ) {
				match[1] = (match[1] || "").replace( rBackslash, "" );
				set = Expr.find[ type ]( match, context, isXML );

				if ( set != null ) {
					expr = expr.replace( Expr.match[ type ], "" );
					break;
				}
			}
		}
	}

	if ( !set ) {
		set = typeof context.getElementsByTagName !== "undefined" ?
			context.getElementsByTagName( "*" ) :
			[];
	}

	return { set: set, expr: expr };
};

Sizzle.filter = function( expr, set, inplace, not ) {
	var match, anyFound,
		type, found, item, filter, left,
		i, pass,
		old = expr,
		result = [],
		curLoop = set,
		isXMLFilter = set && set[0] && Sizzle.isXML( set[0] );

	while ( expr && set.length ) {
		for ( type in Expr.filter ) {
			if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {
				filter = Expr.filter[ type ];
				left = match[1];

				anyFound = false;

				match.splice(1,1);

				if ( left.substr( left.length - 1 ) === "\\" ) {
					continue;
				}

				if ( curLoop === result ) {
					result = [];
				}

				if ( Expr.preFilter[ type ] ) {
					match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );

					if ( !match ) {
						anyFound = found = true;

					} else if ( match === true ) {
						continue;
					}
				}

				if ( match ) {
					for ( i = 0; (item = curLoop[i]) != null; i++ ) {
						if ( item ) {
							found = filter( item, match, i, curLoop );
							pass = not ^ found;

							if ( inplace && found != null ) {
								if ( pass ) {
									anyFound = true;

								} else {
									curLoop[i] = false;
								}

							} else if ( pass ) {
								result.push( item );
								anyFound = true;
							}
						}
					}
				}

				if ( found !== undefined ) {
					if ( !inplace ) {
						curLoop = result;
					}

					expr = expr.replace( Expr.match[ type ], "" );

					if ( !anyFound ) {
						return [];
					}

					break;
				}
			}
		}

		// Improper expression
		if ( expr === old ) {
			if ( anyFound == null ) {
				Sizzle.error( expr );

			} else {
				break;
			}
		}

		old = expr;
	}

	return curLoop;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Utility function for retreiving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
var getText = Sizzle.getText = function( elem ) {
    var i, node,
		nodeType = elem.nodeType,
		ret = "";

	if ( nodeType ) {
		if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent || innerText for elements
			if ( typeof elem.textContent === 'string' ) {
				return elem.textContent;
			} else if ( typeof elem.innerText === 'string' ) {
				// Replace IE's carriage returns
				return elem.innerText.replace( rReturn, '' );
			} else {
				// Traverse it's children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
	} else {

		// If no nodeType, this is expected to be an array
		for ( i = 0; (node = elem[i]); i++ ) {
			// Do not traverse comment nodes
			if ( node.nodeType !== 8 ) {
				ret += getText( node );
			}
		}
	}
	return ret;
};

var Expr = Sizzle.selectors = {
	order: [ "ID", "NAME", "TAG" ],

	match: {
		ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
		ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
		TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
		CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
		POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
		PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
	},

	leftMatch: {},

	attrMap: {
		"class": "className",
		"for": "htmlFor"
	},

	attrHandle: {
		href: function( elem ) {
			return elem.getAttribute( "href" );
		},
		type: function( elem ) {
			return elem.getAttribute( "type" );
		}
	},

	relative: {
		"+": function(checkSet, part){
			var isPartStr = typeof part === "string",
				isTag = isPartStr && !rNonWord.test( part ),
				isPartStrNotTag = isPartStr && !isTag;

			if ( isTag ) {
				part = part.toLowerCase();
			}

			for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
				if ( (elem = checkSet[i]) ) {
					while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}

					checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
						elem || false :
						elem === part;
				}
			}

			if ( isPartStrNotTag ) {
				Sizzle.filter( part, checkSet, true );
			}
		},

		">": function( checkSet, part ) {
			var elem,
				isPartStr = typeof part === "string",
				i = 0,
				l = checkSet.length;

			if ( isPartStr && !rNonWord.test( part ) ) {
				part = part.toLowerCase();

				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						var parent = elem.parentNode;
						checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
					}
				}

			} else {
				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						checkSet[i] = isPartStr ?
							elem.parentNode :
							elem.parentNode === part;
					}
				}

				if ( isPartStr ) {
					Sizzle.filter( part, checkSet, true );
				}
			}
		},

		"": function(checkSet, part, isXML){
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "parentNode", part, doneName, checkSet, nodeCheck, isXML );
		},

		"~": function( checkSet, part, isXML ) {
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "previousSibling", part, doneName, checkSet, nodeCheck, isXML );
		}
	},

	find: {
		ID: function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [m] : [];
			}
		},

		NAME: function( match, context ) {
			if ( typeof context.getElementsByName !== "undefined" ) {
				var ret = [],
					results = context.getElementsByName( match[1] );

				for ( var i = 0, l = results.length; i < l; i++ ) {
					if ( results[i].getAttribute("name") === match[1] ) {
						ret.push( results[i] );
					}
				}

				return ret.length === 0 ? null : ret;
			}
		},

		TAG: function( match, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( match[1] );
			}
		}
	},
	preFilter: {
		CLASS: function( match, curLoop, inplace, result, not, isXML ) {
			match = " " + match[1].replace( rBackslash, "" ) + " ";

			if ( isXML ) {
				return match;
			}

			for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
				if ( elem ) {
					if ( not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0) ) {
						if ( !inplace ) {
							result.push( elem );
						}

					} else if ( inplace ) {
						curLoop[i] = false;
					}
				}
			}

			return false;
		},

		ID: function( match ) {
			return match[1].replace( rBackslash, "" );
		},

		TAG: function( match, curLoop ) {
			return match[1].replace( rBackslash, "" ).toLowerCase();
		},

		CHILD: function( match ) {
			if ( match[1] === "nth" ) {
				if ( !match[2] ) {
					Sizzle.error( match[0] );
				}

				match[2] = match[2].replace(/^\+|\s*/g, '');

				// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
				var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
					match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
					!/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);

				// calculate the numbers (first)n+(last) including if they are negative
				match[2] = (test[1] + (test[2] || 1)) - 0;
				match[3] = test[3] - 0;
			}
			else if ( match[2] ) {
				Sizzle.error( match[0] );
			}

			// TODO: Move to normal caching system
			match[0] = done++;

			return match;
		},

		ATTR: function( match, curLoop, inplace, result, not, isXML ) {
			var name = match[1] = match[1].replace( rBackslash, "" );

			if ( !isXML && Expr.attrMap[name] ) {
				match[1] = Expr.attrMap[name];
			}

			// Handle if an un-quoted value was used
			match[4] = ( match[4] || match[5] || "" ).replace( rBackslash, "" );

			if ( match[2] === "~=" ) {
				match[4] = " " + match[4] + " ";
			}

			return match;
		},

		PSEUDO: function( match, curLoop, inplace, result, not ) {
			if ( match[1] === "not" ) {
				// If we're dealing with a complex expression, or a simple one
				if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
					match[3] = Sizzle(match[3], null, null, curLoop);

				} else {
					var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);

					if ( !inplace ) {
						result.push.apply( result, ret );
					}

					return false;
				}

			} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
				return true;
			}

			return match;
		},

		POS: function( match ) {
			match.unshift( true );

			return match;
		}
	},

	filters: {
		enabled: function( elem ) {
			return elem.disabled === false && elem.type !== "hidden";
		},

		disabled: function( elem ) {
			return elem.disabled === true;
		},

		checked: function( elem ) {
			return elem.checked === true;
		},

		selected: function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		parent: function( elem ) {
			return !!elem.firstChild;
		},

		empty: function( elem ) {
			return !elem.firstChild;
		},

		has: function( elem, i, match ) {
			return !!Sizzle( match[3], elem ).length;
		},

		header: function( elem ) {
			return (/h\d/i).test( elem.nodeName );
		},

		text: function( elem ) {
			var attr = elem.getAttribute( "type" ), type = elem.type;
			// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
			// use getAttribute instead to test this case
			return elem.nodeName.toLowerCase() === "input" && "text" === type && ( attr === type || attr === null );
		},

		radio: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "radio" === elem.type;
		},

		checkbox: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "checkbox" === elem.type;
		},

		file: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "file" === elem.type;
		},

		password: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "password" === elem.type;
		},

		submit: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && "submit" === elem.type;
		},

		image: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "image" === elem.type;
		},

		reset: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && "reset" === elem.type;
		},

		button: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && "button" === elem.type || name === "button";
		},

		input: function( elem ) {
			return (/input|select|textarea|button/i).test( elem.nodeName );
		},

		focus: function( elem ) {
			return elem === elem.ownerDocument.activeElement;
		}
	},
	setFilters: {
		first: function( elem, i ) {
			return i === 0;
		},

		last: function( elem, i, match, array ) {
			return i === array.length - 1;
		},

		even: function( elem, i ) {
			return i % 2 === 0;
		},

		odd: function( elem, i ) {
			return i % 2 === 1;
		},

		lt: function( elem, i, match ) {
			return i < match[3] - 0;
		},

		gt: function( elem, i, match ) {
			return i > match[3] - 0;
		},

		nth: function( elem, i, match ) {
			return match[3] - 0 === i;
		},

		eq: function( elem, i, match ) {
			return match[3] - 0 === i;
		}
	},
	filter: {
		PSEUDO: function( elem, match, i, array ) {
			var name = match[1],
				filter = Expr.filters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );

			} else if ( name === "contains" ) {
				return (elem.textContent || elem.innerText || getText([ elem ]) || "").indexOf(match[3]) >= 0;

			} else if ( name === "not" ) {
				var not = match[3];

				for ( var j = 0, l = not.length; j < l; j++ ) {
					if ( not[j] === elem ) {
						return false;
					}
				}

				return true;

			} else {
				Sizzle.error( name );
			}
		},

		CHILD: function( elem, match ) {
			var first, last,
				doneName, parent, cache,
				count, diff,
				type = match[1],
				node = elem;

			switch ( type ) {
				case "only":
				case "first":
					while ( (node = node.previousSibling) ) {
						if ( node.nodeType === 1 ) {
							return false;
						}
					}

					if ( type === "first" ) {
						return true;
					}

					node = elem;

					/* falls through */
				case "last":
					while ( (node = node.nextSibling) ) {
						if ( node.nodeType === 1 ) {
							return false;
						}
					}

					return true;

				case "nth":
					first = match[2];
					last = match[3];

					if ( first === 1 && last === 0 ) {
						return true;
					}

					doneName = match[0];
					parent = elem.parentNode;

					if ( parent && (parent[ expando ] !== doneName || !elem.nodeIndex) ) {
						count = 0;

						for ( node = parent.firstChild; node; node = node.nextSibling ) {
							if ( node.nodeType === 1 ) {
								node.nodeIndex = ++count;
							}
						}

						parent[ expando ] = doneName;
					}

					diff = elem.nodeIndex - last;

					if ( first === 0 ) {
						return diff === 0;

					} else {
						return ( diff % first === 0 && diff / first >= 0 );
					}
			}
		},

		ID: function( elem, match ) {
			return elem.nodeType === 1 && elem.getAttribute("id") === match;
		},

		TAG: function( elem, match ) {
			return (match === "*" && elem.nodeType === 1) || !!elem.nodeName && elem.nodeName.toLowerCase() === match;
		},

		CLASS: function( elem, match ) {
			return (" " + (elem.className || elem.getAttribute("class")) + " ")
				.indexOf( match ) > -1;
		},

		ATTR: function( elem, match ) {
			var name = match[1],
				result = Sizzle.attr ?
					Sizzle.attr( elem, name ) :
					Expr.attrHandle[ name ] ?
					Expr.attrHandle[ name ]( elem ) :
					elem[ name ] != null ?
						elem[ name ] :
						elem.getAttribute( name ),
				value = result + "",
				type = match[2],
				check = match[4];

			return result == null ?
				type === "!=" :
				!type && Sizzle.attr ?
				result != null :
				type === "=" ?
				value === check :
				type === "*=" ?
				value.indexOf(check) >= 0 :
				type === "~=" ?
				(" " + value + " ").indexOf(check) >= 0 :
				!check ?
				value && result !== false :
				type === "!=" ?
				value !== check :
				type === "^=" ?
				value.indexOf(check) === 0 :
				type === "$=" ?
				value.substr(value.length - check.length) === check :
				type === "|=" ?
				value === check || value.substr(0, check.length + 1) === check + "-" :
				false;
		},

		POS: function( elem, match, i, array ) {
			var name = match[2],
				filter = Expr.setFilters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );
			}
		}
	}
};

var origPOS = Expr.match.POS,
	fescape = function(all, num){
		return "\\" + (num - 0 + 1);
	};

for ( var type in Expr.match ) {
	Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );
	Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );
}
// Expose origPOS
// "global" as in regardless of relation to brackets/parens
Expr.match.globalPOS = origPOS;

var makeArray = function( array, results ) {
	array = Array.prototype.slice.call( array, 0 );

	if ( results ) {
		results.push.apply( results, array );
		return results;
	}

	return array;
};

// Perform a simple check to determine if the browser is capable of
// converting a NodeList to an array using builtin methods.
// Also verifies that the returned array holds DOM nodes
// (which is not the case in the Blackberry browser)
try {
	Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;

// Provide a fallback method if it does not work
} catch( e ) {
	makeArray = function( array, results ) {
		var i = 0,
			ret = results || [];

		if ( toString.call(array) === "[object Array]" ) {
			Array.prototype.push.apply( ret, array );

		} else {
			if ( typeof array.length === "number" ) {
				for ( var l = array.length; i < l; i++ ) {
					ret.push( array[i] );
				}

			} else {
				for ( ; array[i]; i++ ) {
					ret.push( array[i] );
				}
			}
		}

		return ret;
	};
}

var sortOrder, siblingCheck;

if ( document.documentElement.compareDocumentPosition ) {
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
			return a.compareDocumentPosition ? -1 : 1;
		}

		return a.compareDocumentPosition(b) & 4 ? -1 : 1;
	};

} else {
	sortOrder = function( a, b ) {
		// The nodes are identical, we can exit early
		if ( a === b ) {
			hasDuplicate = true;
			return 0;

		// Fallback to using sourceIndex (in IE) if it's available on both nodes
		} else if ( a.sourceIndex && b.sourceIndex ) {
			return a.sourceIndex - b.sourceIndex;
		}

		var al, bl,
			ap = [],
			bp = [],
			aup = a.parentNode,
			bup = b.parentNode,
			cur = aup;

		// If the nodes are siblings (or identical) we can do a quick check
		if ( aup === bup ) {
			return siblingCheck( a, b );

		// If no parents were found then the nodes are disconnected
		} else if ( !aup ) {
			return -1;

		} else if ( !bup ) {
			return 1;
		}

		// Otherwise they're somewhere else in the tree so we need
		// to build up a full list of the parentNodes for comparison
		while ( cur ) {
			ap.unshift( cur );
			cur = cur.parentNode;
		}

		cur = bup;

		while ( cur ) {
			bp.unshift( cur );
			cur = cur.parentNode;
		}

		al = ap.length;
		bl = bp.length;

		// Start walking down the tree looking for a discrepancy
		for ( var i = 0; i < al && i < bl; i++ ) {
			if ( ap[i] !== bp[i] ) {
				return siblingCheck( ap[i], bp[i] );
			}
		}

		// We ended someplace up the tree so do a sibling check
		return i === al ?
			siblingCheck( a, bp[i], -1 ) :
			siblingCheck( ap[i], b, 1 );
	};

	siblingCheck = function( a, b, ret ) {
		if ( a === b ) {
			return ret;
		}

		var cur = a.nextSibling;

		while ( cur ) {
			if ( cur === b ) {
				return -1;
			}

			cur = cur.nextSibling;
		}

		return 1;
	};
}

// Check to see if the browser returns elements by name when
// querying by getElementById (and provide a workaround)
(function(){
	// We're going to inject a fake input element with a specified name
	var form = document.createElement("div"),
		id = "script" + (new Date()).getTime(),
		root = document.documentElement;

	form.innerHTML = "<a name='" + id + "'/>";

	// Inject it into the root element, check its status, and remove it quickly
	root.insertBefore( form, root.firstChild );

	// The workaround has to do additional checks after a getElementById
	// Which slows things down for other browsers (hence the branching)
	if ( document.getElementById( id ) ) {
		Expr.find.ID = function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);

				return m ?
					m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ?
						[m] :
						undefined :
					[];
			}
		};

		Expr.filter.ID = function( elem, match ) {
			var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");

			return elem.nodeType === 1 && node && node.nodeValue === match;
		};
	}

	root.removeChild( form );

	// release memory in IE
	root = form = null;
})();

(function(){
	// Check to see if the browser returns only elements
	// when doing getElementsByTagName("*")

	// Create a fake element
	var div = document.createElement("div");
	div.appendChild( document.createComment("") );

	// Make sure no comments are found
	if ( div.getElementsByTagName("*").length > 0 ) {
		Expr.find.TAG = function( match, context ) {
			var results = context.getElementsByTagName( match[1] );

			// Filter out possible comments
			if ( match[1] === "*" ) {
				var tmp = [];

				for ( var i = 0; results[i]; i++ ) {
					if ( results[i].nodeType === 1 ) {
						tmp.push( results[i] );
					}
				}

				results = tmp;
			}

			return results;
		};
	}

	// Check to see if an attribute returns normalized href attributes
	div.innerHTML = "<a href='#'></a>";

	if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
			div.firstChild.getAttribute("href") !== "#" ) {

		Expr.attrHandle.href = function( elem ) {
			return elem.getAttribute( "href", 2 );
		};
	}

	// release memory in IE
	div = null;
})();

if ( document.querySelectorAll ) {
	(function(){
		var oldSizzle = Sizzle,
			div = document.createElement("div"),
			id = "__sizzle__";

		div.innerHTML = "<p class='TEST'></p>";

		// Safari can't handle uppercase or unicode characters when
		// in quirks mode.
		if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
			return;
		}

		Sizzle = function( query, context, extra, seed ) {
			context = context || document;

			// Only use querySelectorAll on non-XML documents
			// (ID selectors don't work in non-HTML documents)
			if ( !seed && !Sizzle.isXML(context) ) {
				// See if we find a selector to speed up
				var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec( query );

				if ( match && (context.nodeType === 1 || context.nodeType === 9) ) {
					// Speed-up: Sizzle("TAG")
					if ( match[1] ) {
						return makeArray( context.getElementsByTagName( query ), extra );

					// Speed-up: Sizzle(".CLASS")
					} else if ( match[2] && Expr.find.CLASS && context.getElementsByClassName ) {
						return makeArray( context.getElementsByClassName( match[2] ), extra );
					}
				}

				if ( context.nodeType === 9 ) {
					// Speed-up: Sizzle("body")
					// The body element only exists once, optimize finding it
					if ( query === "body" && context.body ) {
						return makeArray( [ context.body ], extra );

					// Speed-up: Sizzle("#ID")
					} else if ( match && match[3] ) {
						var elem = context.getElementById( match[3] );

						// Check parentNode to catch when Blackberry 4.6 returns
						// nodes that are no longer in the document #6963
						if ( elem && elem.parentNode ) {
							// Handle the case where IE and Opera return items
							// by name instead of ID
							if ( elem.id === match[3] ) {
								return makeArray( [ elem ], extra );
							}

						} else {
							return makeArray( [], extra );
						}
					}

					try {
						return makeArray( context.querySelectorAll(query), extra );
					} catch(qsaError) {}

				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn't work on object elements
				} else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					var oldContext = context,
						old = context.getAttribute( "id" ),
						nid = old || id,
						hasParent = context.parentNode,
						relativeHierarchySelector = /^\s*[+~]/.test( query );

					if ( !old ) {
						context.setAttribute( "id", nid );
					} else {
						nid = nid.replace( /'/g, "\\$&" );
					}
					if ( relativeHierarchySelector && hasParent ) {
						context = context.parentNode;
					}

					try {
						if ( !relativeHierarchySelector || hasParent ) {
							return makeArray( context.querySelectorAll( "[id='" + nid + "'] " + query ), extra );
						}

					} catch(pseudoError) {
					} finally {
						if ( !old ) {
							oldContext.removeAttribute( "id" );
						}
					}
				}
			}

			return oldSizzle(query, context, extra, seed);
		};

		for ( var prop in oldSizzle ) {
			Sizzle[ prop ] = oldSizzle[ prop ];
		}

		// release memory in IE
		div = null;
	})();
}

(function(){
	var html = document.documentElement,
		matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;

	if ( matches ) {
		// Check to see if it's possible to do matchesSelector
		// on a disconnected node (IE 9 fails this)
		var disconnectedMatch = !matches.call( document.createElement( "div" ), "div" ),
			pseudoWorks = false;

		try {
			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( document.documentElement, "[test!='']:sizzle" );

		} catch( pseudoError ) {
			pseudoWorks = true;
		}

		Sizzle.matchesSelector = function( node, expr ) {
			// Make sure that attribute selectors are quoted
			expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");

			if ( !Sizzle.isXML( node ) ) {
				try {
					if ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) && !/!=/.test( expr ) ) {
						var ret = matches.call( node, expr );

						// IE 9's matchesSelector returns false on disconnected nodes
						if ( ret || !disconnectedMatch ||
								// As well, disconnected nodes are said to be in a document
								// fragment in IE 9, so check for that
								node.document && node.document.nodeType !== 11 ) {
							return ret;
						}
					}
				} catch(e) {}
			}

			return Sizzle(expr, null, null, [node]).length > 0;
		};
	}
})();

(function(){
	var div = document.createElement("div");

	div.innerHTML = "<div class='test e'></div><div class='test'></div>";

	// Opera can't find a second classname (in 9.6)
	// Also, make sure that getElementsByClassName actually exists
	if ( !div.getElementsByClassName || div.getElementsByClassName("e").length === 0 ) {
		return;
	}

	// Safari caches class attributes, doesn't catch changes (in 3.2)
	div.lastChild.className = "e";

	if ( div.getElementsByClassName("e").length === 1 ) {
		return;
	}

	Expr.order.splice(1, 0, "CLASS");
	Expr.find.CLASS = function( match, context, isXML ) {
		if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
			return context.getElementsByClassName(match[1]);
		}
	};

	// release memory in IE
	div = null;
})();

function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;

			elem = elem[dir];

			while ( elem ) {
				if ( elem[ expando ] === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 && !isXML ){
					elem[ expando ] = doneName;
					elem.sizset = i;
				}

				if ( elem.nodeName.toLowerCase() === cur ) {
					match = elem;
					break;
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;

			elem = elem[dir];

			while ( elem ) {
				if ( elem[ expando ] === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 ) {
					if ( !isXML ) {
						elem[ expando ] = doneName;
						elem.sizset = i;
					}

					if ( typeof cur !== "string" ) {
						if ( elem === cur ) {
							match = true;
							break;
						}

					} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
						match = elem;
						break;
					}
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

if ( document.documentElement.contains ) {
	Sizzle.contains = function( a, b ) {
		return a !== b && (a.contains ? a.contains(b) : true);
	};

} else if ( document.documentElement.compareDocumentPosition ) {
	Sizzle.contains = function( a, b ) {
		return !!(a.compareDocumentPosition(b) & 16);
	};

} else {
	Sizzle.contains = function() {
		return false;
	};
}

Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;

	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

var posProcess = function( selector, context, seed ) {
	var match,
		tmpSet = [],
		later = "",
		root = context.nodeType ? [context] : context;

	// Position selectors must be done after the filter
	// And so must :not(positional) so we move all PSEUDOs to the end
	while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
		later += match[0];
		selector = selector.replace( Expr.match.PSEUDO, "" );
	}

	selector = Expr.relative[selector] ? selector + "*" : selector;

	for ( var i = 0, l = root.length; i < l; i++ ) {
		Sizzle( selector, root[i], tmpSet, seed );
	}

	return Sizzle.filter( later, tmpSet );
};

// EXPOSE
// Override sizzle attribute retrieval
Sizzle.attr = jQuery.attr;
Sizzle.selectors.attrMap = {};
jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.filters;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;


})();


var runtil = /Until$/,
	rparentsprev = /^(?:parents|prevUntil|prevAll)/,
	// Note: This RegExp should be improved, or likely pulled from Sizzle
	rmultiselector = /,/,
	isSimple = /^.[^:#\[\.,]*$/,
	slice = Array.prototype.slice,
	POS = jQuery.expr.match.globalPOS,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend({
	find: function( selector ) {
		var self = this,
			i, l;

		if ( typeof selector !== "string" ) {
			return jQuery( selector ).filter(function() {
				for ( i = 0, l = self.length; i < l; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			});
		}

		var ret = this.pushStack( "", "find", selector ),
			length, n, r;

		for ( i = 0, l = this.length; i < l; i++ ) {
			length = ret.length;
			jQuery.find( selector, this[i], ret );

			if ( i > 0 ) {
				// Make sure that the results are unique
				for ( n = length; n < ret.length; n++ ) {
					for ( r = 0; r < length; r++ ) {
						if ( ret[r] === ret[n] ) {
							ret.splice(n--, 1);
							break;
						}
					}
				}
			}
		}

		return ret;
	},

	has: function( target ) {
		var targets = jQuery( target );
		return this.filter(function() {
			for ( var i = 0, l = targets.length; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	not: function( selector ) {
		return this.pushStack( winnow(this, selector, false), "not", selector);
	},

	filter: function( selector ) {
		return this.pushStack( winnow(this, selector, true), "filter", selector );
	},

	is: function( selector ) {
		return !!selector && (
			typeof selector === "string" ?
				// If this is a positional selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				POS.test( selector ) ?
					jQuery( selector, this.context ).index( this[0] ) >= 0 :
					jQuery.filter( selector, this ).length > 0 :
				this.filter( selector ).length > 0 );
	},

	closest: function( selectors, context ) {
		var ret = [], i, l, cur = this[0];

		// Array (deprecated as of jQuery 1.7)
		if ( jQuery.isArray( selectors ) ) {
			var level = 1;

			while ( cur && cur.ownerDocument && cur !== context ) {
				for ( i = 0; i < selectors.length; i++ ) {

					if ( jQuery( cur ).is( selectors[ i ] ) ) {
						ret.push({ selector: selectors[ i ], elem: cur, level: level });
					}
				}

				cur = cur.parentNode;
				level++;
			}

			return ret;
		}

		// String
		var pos = POS.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( i = 0, l = this.length; i < l; i++ ) {
			cur = this[i];

			while ( cur ) {
				if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
					ret.push( cur );
					break;

				} else {
					cur = cur.parentNode;
					if ( !cur || !cur.ownerDocument || cur === context || cur.nodeType === 11 ) {
						break;
					}
				}
			}
		}

		ret = ret.length > 1 ? jQuery.unique( ret ) : ret;

		return this.pushStack( ret, "closest", selectors );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[0] && this[0].parentNode ) ? this.prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return jQuery.inArray( this[0], jQuery( elem ) );
		}

		// Locate the position of the desired element
		return jQuery.inArray(
			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		var set = typeof selector === "string" ?
				jQuery( selector, context ) :
				jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
			all = jQuery.merge( this.get(), set );

		return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
			all :
			jQuery.unique( all ) );
	},

	andSelf: function() {
		return this.add( this.prevObject );
	}
});

// A painfully simple check to see if an element is disconnected
// from a document (should be improved, where feasible).
function isDisconnected( node ) {
	return !node || !node.parentNode || node.parentNode.nodeType === 11;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return jQuery.nth( elem, 2, "nextSibling" );
	},
	prev: function( elem ) {
		return jQuery.nth( elem, 2, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.makeArray( elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until );

		if ( !runtil.test( name ) ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;

		if ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {
			ret = ret.reverse();
		}

		return this.pushStack( ret, name, slice.call( arguments ).join(",") );
	};
});

jQuery.extend({
	filter: function( expr, elems, not ) {
		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 ?
			jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
			jQuery.find.matches(expr, elems);
	},

	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];

		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	nth: function( cur, result, dir, elem ) {
		result = result || 1;
		var num = 0;

		for ( ; cur; cur = cur[dir] ) {
			if ( cur.nodeType === 1 && ++num === result ) {
				break;
			}
		}

		return cur;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, keep ) {

	// Can't pass null or undefined to indexOf in Firefox 4
	// Set to 0 to skip string check
	qualifier = qualifier || 0;

	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep(elements, function( elem, i ) {
			var retVal = !!qualifier.call( elem, i, elem );
			return retVal === keep;
		});

	} else if ( qualifier.nodeType ) {
		return jQuery.grep(elements, function( elem, i ) {
			return ( elem === qualifier ) === keep;
		});

	} else if ( typeof qualifier === "string" ) {
		var filtered = jQuery.grep(elements, function( elem ) {
			return elem.nodeType === 1;
		});

		if ( isSimple.test( qualifier ) ) {
			return jQuery.filter(qualifier, filtered, !keep);
		} else {
			qualifier = jQuery.filter( qualifier, filtered );
		}
	}

	return jQuery.grep(elements, function( elem, i ) {
		return ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;
	});
}




function createSafeFragment( document ) {
	var list = nodeNames.split( "|" ),
	safeFrag = document.createDocumentFragment();

	if ( safeFrag.createElement ) {
		while ( list.length ) {
			safeFrag.createElement(
				list.pop()
			);
		}
	}
	return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style)/i,
	rnocache = /<(?:script|object|embed|option|style)/i,
	rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /\/(java|ecma)script/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)/,
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		area: [ 1, "<map>", "</map>" ],
		_default: [ 0, "", "" ]
	},
	safeFragment = createSafeFragment( document );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// IE can't serialize <link> and <script> tags normally
if ( !jQuery.support.htmlSerialize ) {
	wrapMap._default = [ 1, "div<div>", "</div>" ];
}

jQuery.fn.extend({
	text: function( value ) {
		return jQuery.access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
		}, null, value, arguments.length );
	},

	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
			// The elements to wrap the target around
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function(i) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	},

	append: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.insertBefore( elem, this.firstChild );
			}
		});
	},

	before: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this );
			});
		} else if ( arguments.length ) {
			var set = jQuery.clean( arguments );
			set.push.apply( set, this.toArray() );
			return this.pushStack( set, "before", arguments );
		}
	},

	after: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			});
		} else if ( arguments.length ) {
			var set = this.pushStack( this, "after", arguments );
			set.push.apply( set, jQuery.clean(arguments) );
			return set;
		}
	},

	// keepData is for internal use only--do not document
	remove: function( selector, keepData ) {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
				if ( !keepData && elem.nodeType === 1 ) {
					jQuery.cleanData( elem.getElementsByTagName("*") );
					jQuery.cleanData( [ elem ] );
				}

				if ( elem.parentNode ) {
					elem.parentNode.removeChild( elem );
				}
			}
		}

		return this;
	},

	empty: function() {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( elem.getElementsByTagName("*") );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function () {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return jQuery.access( this, function( value ) {
			var elem = this[0] || {},
				i = 0,
				l = this.length;

			if ( value === undefined ) {
				return elem.nodeType === 1 ?
					elem.innerHTML.replace( rinlinejQuery, "" ) :
					null;
			}


			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
				!wrapMap[ ( rtagName.exec( value ) || ["", ""] )[1].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for (; i < l; i++ ) {
						// Remove element nodes and prevent memory leaks
						elem = this[i] || {};
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( elem.getElementsByTagName( "*" ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch(e) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function( value ) {
		if ( this[0] && this[0].parentNode ) {
			// Make sure that the elements are removed from the DOM before they are inserted
			// this can help fix replacing a parent with child elements
			if ( jQuery.isFunction( value ) ) {
				return this.each(function(i) {
					var self = jQuery(this), old = self.html();
					self.replaceWith( value.call( this, i, old ) );
				});
			}

			if ( typeof value !== "string" ) {
				value = jQuery( value ).detach();
			}

			return this.each(function() {
				var next = this.nextSibling,
					parent = this.parentNode;

				jQuery( this ).remove();

				if ( next ) {
					jQuery(next).before( value );
				} else {
					jQuery(parent).append( value );
				}
			});
		} else {
			return this.length ?
				this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value ) :
				this;
		}
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, table, callback ) {
		var results, first, fragment, parent,
			value = args[0],
			scripts = [];

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( !jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test( value ) ) {
			return this.each(function() {
				jQuery(this).domManip( args, table, callback, true );
			});
		}

		if ( jQuery.isFunction(value) ) {
			return this.each(function(i) {
				var self = jQuery(this);
				args[0] = value.call(this, i, table ? self.html() : undefined);
				self.domManip( args, table, callback );
			});
		}

		if ( this[0] ) {
			parent = value && value.parentNode;

			// If we're in a fragment, just use that instead of building a new one
			if ( jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length ) {
				results = { fragment: parent };

			} else {
				results = jQuery.buildFragment( args, this, scripts );
			}

			fragment = results.fragment;

			if ( fragment.childNodes.length === 1 ) {
				first = fragment = fragment.firstChild;
			} else {
				first = fragment.firstChild;
			}

			if ( first ) {
				table = table && jQuery.nodeName( first, "tr" );

				for ( var i = 0, l = this.length, lastIndex = l - 1; i < l; i++ ) {
					callback.call(
						table ?
							root(this[i], first) :
							this[i],
						// Make sure that we do not leak memory by inadvertently discarding
						// the original fragment (which might have attached data) instead of
						// using it; in addition, use the original fragment object for the last
						// item instead of first because it can end up being emptied incorrectly
						// in certain situations (Bug #8070).
						// Fragments from the fragment cache must always be cloned and never used
						// in place.
						results.cacheable || ( l > 1 && i < lastIndex ) ?
							jQuery.clone( fragment, true, true ) :
							fragment
					);
				}
			}

			if ( scripts.length ) {
				jQuery.each( scripts, function( i, elem ) {
					if ( elem.src ) {
						jQuery.ajax({
							type: "GET",
							global: false,
							url: elem.src,
							async: false,
							dataType: "script"
						});
					} else {
						jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || "" ).replace( rcleanScript, "/*$0*/" ) );
					}

					if ( elem.parentNode ) {
						elem.parentNode.removeChild( elem );
					}
				});
			}
		}

		return this;
	}
});

function root( elem, cur ) {
	return jQuery.nodeName(elem, "table") ?
		(elem.getElementsByTagName("tbody")[0] ||
		elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
		elem;
}

function cloneCopyEvent( src, dest ) {

	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}

	var type, i, l,
		oldData = jQuery._data( src ),
		curData = jQuery._data( dest, oldData ),
		events = oldData.events;

	if ( events ) {
		delete curData.handle;
		curData.events = {};

		for ( type in events ) {
			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
				jQuery.event.add( dest, type, events[ type ][ i ] );
			}
		}
	}

	// make the cloned public data object a copy from the original
	if ( curData.data ) {
		curData.data = jQuery.extend( {}, curData.data );
	}
}

function cloneFixAttributes( src, dest ) {
	var nodeName;

	// We do not need to do anything for non-Elements
	if ( dest.nodeType !== 1 ) {
		return;
	}

	// clearAttributes removes the attributes, which we don't want,
	// but also removes the attachEvent events, which we *do* want
	if ( dest.clearAttributes ) {
		dest.clearAttributes();
	}

	// mergeAttributes, in contrast, only merges back on the
	// original attributes, not the events
	if ( dest.mergeAttributes ) {
		dest.mergeAttributes( src );
	}

	nodeName = dest.nodeName.toLowerCase();

	// IE6-8 fail to clone children inside object elements that use
	// the proprietary classid attribute value (rather than the type
	// attribute) to identify the type of content to display
	if ( nodeName === "object" ) {
		dest.outerHTML = src.outerHTML;

	} else if ( nodeName === "input" && (src.type === "checkbox" || src.type === "radio") ) {
		// IE6-8 fails to persist the checked state of a cloned checkbox
		// or radio button. Worse, IE6-7 fail to give the cloned element
		// a checked appearance if the defaultChecked value isn't also set
		if ( src.checked ) {
			dest.defaultChecked = dest.checked = src.checked;
		}

		// IE6-7 get confused and end up setting the value of a cloned
		// checkbox/radio button to an empty string instead of "on"
		if ( dest.value !== src.value ) {
			dest.value = src.value;
		}

	// IE6-8 fails to return the selected option to the default selected
	// state when cloning options
	} else if ( nodeName === "option" ) {
		dest.selected = src.defaultSelected;

	// IE6-8 fails to set the defaultValue to the correct value when
	// cloning other types of input fields
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;

	// IE blanks contents when cloning scripts
	} else if ( nodeName === "script" && dest.text !== src.text ) {
		dest.text = src.text;
	}

	// Event data gets referenced instead of copied if the expando
	// gets copied too
	dest.removeAttribute( jQuery.expando );

	// Clear flags for bubbling special change/submit events, they must
	// be reattached when the newly cloned events are first activated
	dest.removeAttribute( "_submit_attached" );
	dest.removeAttribute( "_change_attached" );
}

jQuery.buildFragment = function( args, nodes, scripts ) {
	var fragment, cacheable, cacheresults, doc,
	first = args[ 0 ];

	// nodes may contain either an explicit document object,
	// a jQuery collection or context object.
	// If nodes[0] contains a valid object to assign to doc
	if ( nodes && nodes[0] ) {
		doc = nodes[0].ownerDocument || nodes[0];
	}

	// Ensure that an attr object doesn't incorrectly stand in as a document object
	// Chrome and Firefox seem to allow this to occur and will throw exception
	// Fixes #8950
	if ( !doc.createDocumentFragment ) {
		doc = document;
	}

	// Only cache "small" (1/2 KB) HTML strings that are associated with the main document
	// Cloning options loses the selected state, so don't cache them
	// IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
	// Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
	// Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
	if ( args.length === 1 && typeof first === "string" && first.length < 512 && doc === document &&
		first.charAt(0) === "<" && !rnocache.test( first ) &&
		(jQuery.support.checkClone || !rchecked.test( first )) &&
		(jQuery.support.html5Clone || !rnoshimcache.test( first )) ) {

		cacheable = true;

		cacheresults = jQuery.fragments[ first ];
		if ( cacheresults && cacheresults !== 1 ) {
			fragment = cacheresults;
		}
	}

	if ( !fragment ) {
		fragment = doc.createDocumentFragment();
		jQuery.clean( args, doc, fragment, scripts );
	}

	if ( cacheable ) {
		jQuery.fragments[ first ] = cacheresults ? fragment : 1;
	}

	return { fragment: fragment, cacheable: cacheable };
};

jQuery.fragments = {};

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var ret = [],
			insert = jQuery( selector ),
			parent = this.length === 1 && this[0].parentNode;

		if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
			insert[ original ]( this[0] );
			return this;

		} else {
			for ( var i = 0, l = insert.length; i < l; i++ ) {
				var elems = ( i > 0 ? this.clone(true) : this ).get();
				jQuery( insert[i] )[ original ]( elems );
				ret = ret.concat( elems );
			}

			return this.pushStack( ret, name, insert.selector );
		}
	};
});

function getAll( elem ) {
	if ( typeof elem.getElementsByTagName !== "undefined" ) {
		return elem.getElementsByTagName( "*" );

	} else if ( typeof elem.querySelectorAll !== "undefined" ) {
		return elem.querySelectorAll( "*" );

	} else {
		return [];
	}
}

// Used in clean, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
	if ( elem.type === "checkbox" || elem.type === "radio" ) {
		elem.defaultChecked = elem.checked;
	}
}
// Finds all inputs and passes them to fixDefaultChecked
function findInputs( elem ) {
	var nodeName = ( elem.nodeName || "" ).toLowerCase();
	if ( nodeName === "input" ) {
		fixDefaultChecked( elem );
	// Skip scripts, get other children
	} else if ( nodeName !== "script" && typeof elem.getElementsByTagName !== "undefined" ) {
		jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );
	}
}

// Derived From: http://www.iecss.com/shimprove/javascript/shimprove.1-0-1.js
function shimCloneNode( elem ) {
	var div = document.createElement( "div" );
	safeFragment.appendChild( div );

	div.innerHTML = elem.outerHTML;
	return div.firstChild;
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var srcElements,
			destElements,
			i,
			// IE<=8 does not properly clone detached, unknown element nodes
			clone = jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ?
				elem.cloneNode( true ) :
				shimCloneNode( elem );

		if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
			// IE copies events bound via attachEvent when using cloneNode.
			// Calling detachEvent on the clone will also remove the events
			// from the original. In order to get around this, we use some
			// proprietary methods to clear the events. Thanks to MooTools
			// guys for this hotness.

			cloneFixAttributes( elem, clone );

			// Using Sizzle here is crazy slow, so we use getElementsByTagName instead
			srcElements = getAll( elem );
			destElements = getAll( clone );

			// Weird iteration because IE will replace the length property
			// with an element if you are cloning the body and one of the
			// elements on the page has a name or id of "length"
			for ( i = 0; srcElements[i]; ++i ) {
				// Ensure that the destination node is not null; Fixes #9587
				if ( destElements[i] ) {
					cloneFixAttributes( srcElements[i], destElements[i] );
				}
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			cloneCopyEvent( elem, clone );

			if ( deepDataAndEvents ) {
				srcElements = getAll( elem );
				destElements = getAll( clone );

				for ( i = 0; srcElements[i]; ++i ) {
					cloneCopyEvent( srcElements[i], destElements[i] );
				}
			}
		}

		srcElements = destElements = null;

		// Return the cloned set
		return clone;
	},

	clean: function( elems, context, fragment, scripts ) {
		var checkScriptType, script, j,
				ret = [];

		context = context || document;

		// !context.createElement fails in IE with an error but returns typeof 'object'
		if ( typeof context.createElement === "undefined" ) {
			context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
		}

		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( typeof elem === "number" ) {
				elem += "";
			}

			if ( !elem ) {
				continue;
			}

			// Convert html string into DOM nodes
			if ( typeof elem === "string" ) {
				if ( !rhtml.test( elem ) ) {
					elem = context.createTextNode( elem );
				} else {
					// Fix "XHTML"-style tags in all browsers
					elem = elem.replace(rxhtmlTag, "<$1></$2>");

					// Trim whitespace, otherwise indexOf won't work as expected
					var tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase(),
						wrap = wrapMap[ tag ] || wrapMap._default,
						depth = wrap[0],
						div = context.createElement("div"),
						safeChildNodes = safeFragment.childNodes,
						remove;

					// Append wrapper element to unknown element safe doc fragment
					if ( context === document ) {
						// Use the fragment we've already created for this document
						safeFragment.appendChild( div );
					} else {
						// Use a fragment created with the owner document
						createSafeFragment( context ).appendChild( div );
					}

					// Go to html and back, then peel off extra wrappers
					div.innerHTML = wrap[1] + elem + wrap[2];

					// Move to the right depth
					while ( depth-- ) {
						div = div.lastChild;
					}

					// Remove IE's autoinserted <tbody> from table fragments
					if ( !jQuery.support.tbody ) {

						// String was a <table>, *may* have spurious <tbody>
						var hasBody = rtbody.test(elem),
							tbody = tag === "table" && !hasBody ?
								div.firstChild && div.firstChild.childNodes :

								// String was a bare <thead> or <tfoot>
								wrap[1] === "<table>" && !hasBody ?
									div.childNodes :
									[];

						for ( j = tbody.length - 1; j >= 0 ; --j ) {
							if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
								tbody[ j ].parentNode.removeChild( tbody[ j ] );
							}
						}
					}

					// IE completely kills leading whitespace when innerHTML is used
					if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
						div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
					}

					elem = div.childNodes;

					// Clear elements from DocumentFragment (safeFragment or otherwise)
					// to avoid hoarding elements. Fixes #11356
					if ( div ) {
						div.parentNode.removeChild( div );

						// Guard against -1 index exceptions in FF3.6
						if ( safeChildNodes.length > 0 ) {
							remove = safeChildNodes[ safeChildNodes.length - 1 ];

							if ( remove && remove.parentNode ) {
								remove.parentNode.removeChild( remove );
							}
						}
					}
				}
			}

			// Resets defaultChecked for any radios and checkboxes
			// about to be appended to the DOM in IE 6/7 (#8060)
			var len;
			if ( !jQuery.support.appendChecked ) {
				if ( elem[0] && typeof (len = elem.length) === "number" ) {
					for ( j = 0; j < len; j++ ) {
						findInputs( elem[j] );
					}
				} else {
					findInputs( elem );
				}
			}

			if ( elem.nodeType ) {
				ret.push( elem );
			} else {
				ret = jQuery.merge( ret, elem );
			}
		}

		if ( fragment ) {
			checkScriptType = function( elem ) {
				return !elem.type || rscriptType.test( elem.type );
			};
			for ( i = 0; ret[i]; i++ ) {
				script = ret[i];
				if ( scripts && jQuery.nodeName( script, "script" ) && (!script.type || rscriptType.test( script.type )) ) {
					scripts.push( script.parentNode ? script.parentNode.removeChild( script ) : script );

				} else {
					if ( script.nodeType === 1 ) {
						var jsTags = jQuery.grep( script.getElementsByTagName( "script" ), checkScriptType );

						ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
					}
					fragment.appendChild( script );
				}
			}
		}

		return ret;
	},

	cleanData: function( elems ) {
		var data, id,
			cache = jQuery.cache,
			special = jQuery.event.special,
			deleteExpando = jQuery.support.deleteExpando;

		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {
				continue;
			}

			id = elem[ jQuery.expando ];

			if ( id ) {
				data = cache[ id ];

				if ( data && data.events ) {
					for ( var type in data.events ) {
						if ( special[ type ] ) {
							jQuery.event.remove( elem, type );

						// This is a shortcut to avoid jQuery.event.remove's overhead
						} else {
							jQuery.removeEvent( elem, type, data.handle );
						}
					}

					// Null the DOM reference to avoid IE6/7/8 leak (#7054)
					if ( data.handle ) {
						data.handle.elem = null;
					}
				}

				if ( deleteExpando ) {
					delete elem[ jQuery.expando ];

				} else if ( elem.removeAttribute ) {
					elem.removeAttribute( jQuery.expando );
				}

				delete cache[ id ];
			}
		}
	}
});




var ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity=([^)]*)/,
	// fixed for IE9, see #8346
	rupper = /([A-Z]|^ms)/g,
	rnum = /^[\-+]?(?:\d*\.)?\d+$/i,
	rnumnonpx = /^-?(?:\d*\.)?\d+(?!px)[^\d\s]+$/i,
	rrelNum = /^([\-+])=([\-+.\de]+)/,
	rmargin = /^margin/,

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },

	// order is important!
	cssExpand = [ "Top", "Right", "Bottom", "Left" ],

	curCSS,

	getComputedStyle,
	currentStyle;

jQuery.fn.css = function( name, value ) {
	return jQuery.access( this, function( elem, name, value ) {
		return value !== undefined ?
			jQuery.style( elem, name, value ) :
			jQuery.css( elem, name );
	}, name, value, arguments.length > 1 );
};

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;

				} else {
					return elem.style.opacity;
				}
			}
		}
	},

	// Exclude the following css properties to add px
	cssNumber: {
		"fillOpacity": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, origName = jQuery.camelCase( name ),
			style = elem.style, hooks = jQuery.cssHooks[ origName ];

		name = jQuery.cssProps[ origName ] || origName;

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( +( ret[1] + 1) * +ret[2] ) + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that NaN and null values aren't set. See: #7116
			if ( value == null || type === "number" && isNaN( value ) ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value )) !== undefined ) {
				// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
				// Fixes bug #5509
				try {
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra ) {
		var ret, hooks;

		// Make sure that we're working with the right name
		name = jQuery.camelCase( name );
		hooks = jQuery.cssHooks[ name ];
		name = jQuery.cssProps[ name ] || name;

		// cssFloat needs a special treatment
		if ( name === "cssFloat" ) {
			name = "float";
		}

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks && (ret = hooks.get( elem, true, extra )) !== undefined ) {
			return ret;

		// Otherwise, if a way to get the computed value exists, use that
		} else if ( curCSS ) {
			return curCSS( elem, name );
		}
	},

	// A method for quickly swapping in/out CSS properties to get correct calculations
	swap: function( elem, options, callback ) {
		var old = {},
			ret, name;

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.call( elem );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	}
});

// DEPRECATED in 1.3, Use jQuery.css() instead
jQuery.curCSS = jQuery.css;

if ( document.defaultView && document.defaultView.getComputedStyle ) {
	getComputedStyle = function( elem, name ) {
		var ret, defaultView, computedStyle, width,
			style = elem.style;

		name = name.replace( rupper, "-$1" ).toLowerCase();

		if ( (defaultView = elem.ownerDocument.defaultView) &&
				(computedStyle = defaultView.getComputedStyle( elem, null )) ) {

			ret = computedStyle.getPropertyValue( name );
			if ( ret === "" && !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
				ret = jQuery.style( elem, name );
			}
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// WebKit uses "computed value (percentage if specified)" instead of "used value" for margins
		// which is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
		if ( !jQuery.support.pixelMargin && computedStyle && rmargin.test( name ) && rnumnonpx.test( ret ) ) {
			width = style.width;
			style.width = ret;
			ret = computedStyle.width;
			style.width = width;
		}

		return ret;
	};
}

if ( document.documentElement.currentStyle ) {
	currentStyle = function( elem, name ) {
		var left, rsLeft, uncomputed,
			ret = elem.currentStyle && elem.currentStyle[ name ],
			style = elem.style;

		// Avoid setting ret to empty string here
		// so we don't default to auto
		if ( ret == null && style && (uncomputed = style[ name ]) ) {
			ret = uncomputed;
		}

		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		// If we're not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		if ( rnumnonpx.test( ret ) ) {

			// Remember the original values
			left = style.left;
			rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;

			// Put in the new values to get a computed value out
			if ( rsLeft ) {
				elem.runtimeStyle.left = elem.currentStyle.left;
			}
			style.left = name === "fontSize" ? "1em" : ret;
			ret = style.pixelLeft + "px";

			// Revert the changed values
			style.left = left;
			if ( rsLeft ) {
				elem.runtimeStyle.left = rsLeft;
			}
		}

		return ret === "" ? "auto" : ret;
	};
}

curCSS = getComputedStyle || currentStyle;

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property
	var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		i = name === "width" ? 1 : 0,
		len = 4;

	if ( val > 0 ) {
		if ( extra !== "border" ) {
			for ( ; i < len; i += 2 ) {
				if ( !extra ) {
					val -= parseFloat( jQuery.css( elem, "padding" + cssExpand[ i ] ) ) || 0;
				}
				if ( extra === "margin" ) {
					val += parseFloat( jQuery.css( elem, extra + cssExpand[ i ] ) ) || 0;
				} else {
					val -= parseFloat( jQuery.css( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
				}
			}
		}

		return val + "px";
	}

	// Fall back to computed then uncomputed css if necessary
	val = curCSS( elem, name );
	if ( val < 0 || val == null ) {
		val = elem.style[ name ];
	}

	// Computed unit is not pixels. Stop here and return.
	if ( rnumnonpx.test(val) ) {
		return val;
	}

	// Normalize "", auto, and prepare for extra
	val = parseFloat( val ) || 0;

	// Add padding, border, margin
	if ( extra ) {
		for ( ; i < len; i += 2 ) {
			val += parseFloat( jQuery.css( elem, "padding" + cssExpand[ i ] ) ) || 0;
			if ( extra !== "padding" ) {
				val += parseFloat( jQuery.css( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
			}
			if ( extra === "margin" ) {
				val += parseFloat( jQuery.css( elem, extra + cssExpand[ i ]) ) || 0;
			}
		}
	}

	return val + "px";
}

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {
				if ( elem.offsetWidth !== 0 ) {
					return getWidthOrHeight( elem, name, extra );
				} else {
					return jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					});
				}
			}
		},

		set: function( elem, value ) {
			return rnum.test( value ) ?
				value + "px" :
				value;
		}
	};
});

if ( !jQuery.support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			// IE uses filters for opacity
			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
				( parseFloat( RegExp.$1 ) / 100 ) + "" :
				computed ? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
				filter = currentStyle && currentStyle.filter || style.filter || "";

			// IE has trouble with opacity if it does not have layout
			// Force it by setting the zoom level
			style.zoom = 1;

			// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
			if ( value >= 1 && jQuery.trim( filter.replace( ralpha, "" ) ) === "" ) {

				// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
				// if "filter:" is present at all, clearType is disabled, we want to avoid this
				// style.removeAttribute is IE Only, but so apparently is this code path...
				style.removeAttribute( "filter" );

				// if there there is no filter style applied in a css rule, we are done
				if ( currentStyle && !currentStyle.filter ) {
					return;
				}
			}

			// otherwise, set new filter values
			style.filter = ralpha.test( filter ) ?
				filter.replace( ralpha, opacity ) :
				filter + " " + opacity;
		}
	};
}

jQuery(function() {
	// This hook cannot be added until DOM ready because the support test
	// for it is not run until after DOM ready
	if ( !jQuery.support.reliableMarginRight ) {
		jQuery.cssHooks.marginRight = {
			get: function( elem, computed ) {
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// Work around by temporarily setting element display to inline-block
				return jQuery.swap( elem, { "display": "inline-block" }, function() {
					if ( computed ) {
						return curCSS( elem, "margin-right" );
					} else {
						return elem.style.marginRight;
					}
				});
			}
		};
	}
});

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.hidden = function( elem ) {
		var width = elem.offsetWidth,
			height = elem.offsetHeight;

		return ( width === 0 && height === 0 ) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
	};

	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};
}

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {

	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i,

				// assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ],
				expanded = {};

			for ( i = 0; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};
});




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rhash = /#.*$/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rquery = /\?/,
	rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
	rselectTextarea = /^(?:select|textarea)/i,
	rspacesAjax = /\s+/,
	rts = /([?&])_=[^&]*/,
	rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,

	// Keep a copy of the old load method
	_load = jQuery.fn.load,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Document location
	ajaxLocation,

	// Document location segments
	ajaxLocParts,

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = ["*/"] + ["*"];

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		if ( jQuery.isFunction( func ) ) {
			var dataTypes = dataTypeExpression.toLowerCase().split( rspacesAjax ),
				i = 0,
				length = dataTypes.length,
				dataType,
				list,
				placeBefore;

			// For each dataType in the dataTypeExpression
			for ( ; i < length; i++ ) {
				dataType = dataTypes[ i ];
				// We control if we're asked to add before
				// any existing element
				placeBefore = /^\+/.test( dataType );
				if ( placeBefore ) {
					dataType = dataType.substr( 1 ) || "*";
				}
				list = structure[ dataType ] = structure[ dataType ] || [];
				// then we add to the structure accordingly
				list[ placeBefore ? "unshift" : "push" ]( func );
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
		dataType /* internal */, inspected /* internal */ ) {

	dataType = dataType || options.dataTypes[ 0 ];
	inspected = inspected || {};

	inspected[ dataType ] = true;

	var list = structure[ dataType ],
		i = 0,
		length = list ? list.length : 0,
		executeOnly = ( structure === prefilters ),
		selection;

	for ( ; i < length && ( executeOnly || !selection ); i++ ) {
		selection = list[ i ]( options, originalOptions, jqXHR );
		// If we got redirected to another dataType
		// we try there if executing only and not done already
		if ( typeof selection === "string" ) {
			if ( !executeOnly || inspected[ selection ] ) {
				selection = undefined;
			} else {
				options.dataTypes.unshift( selection );
				selection = inspectPrefiltersOrTransports(
						structure, options, originalOptions, jqXHR, selection, inspected );
			}
		}
	}
	// If we're only executing or nothing was selected
	// we try the catchall dataType if not done already
	if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
		selection = inspectPrefiltersOrTransports(
				structure, options, originalOptions, jqXHR, "*", inspected );
	}
	// unnecessary when only executing (prefilters)
	// but it'll be ignored by the caller in that case
	return selection;
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};
	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}
}

jQuery.fn.extend({
	load: function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );

		// Don't do a request if no elements are being requested
		} else if ( !this.length ) {
			return this;
		}

		var off = url.indexOf( " " );
		if ( off >= 0 ) {
			var selector = url.slice( off, url.length );
			url = url.slice( 0, off );
		}

		// Default to a GET request
		var type = "GET";

		// If the second parameter was provided
		if ( params ) {
			// If it's a function
			if ( jQuery.isFunction( params ) ) {
				// We assume that it's the callback
				callback = params;
				params = undefined;

			// Otherwise, build a param string
			} else if ( typeof params === "object" ) {
				params = jQuery.param( params, jQuery.ajaxSettings.traditional );
				type = "POST";
			}
		}

		var self = this;

		// Request the remote document
		jQuery.ajax({
			url: url,
			type: type,
			dataType: "html",
			data: params,
			// Complete callback (responseText is used internally)
			complete: function( jqXHR, status, responseText ) {
				// Store the response as specified by the jqXHR object
				responseText = jqXHR.responseText;
				// If successful, inject the HTML into all the matched elements
				if ( jqXHR.isResolved() ) {
					// #4825: Get the actual response in case
					// a dataFilter is present in ajaxSettings
					jqXHR.done(function( r ) {
						responseText = r;
					});
					// See if a selector was specified
					self.html( selector ?
						// Create a dummy div to hold the results
						jQuery("<div>")
							// inject the contents of the document in, removing the scripts
							// to avoid any 'Permission Denied' errors in IE
							.append(responseText.replace(rscript, ""))

							// Locate the specified elements
							.find(selector) :

						// If not, just inject the full result
						responseText );
				}

				if ( callback ) {
					self.each( callback, [ responseText, status, jqXHR ] );
				}
			}
		});

		return this;
	},

	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},

	serializeArray: function() {
		return this.map(function(){
			return this.elements ? jQuery.makeArray( this.elements ) : this;
		})
		.filter(function(){
			return this.name && !this.disabled &&
				( this.checked || rselectTextarea.test( this.nodeName ) ||
					rinput.test( this.type ) );
		})
		.map(function( i, elem ){
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val, i ){
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});

// Attach a bunch of functions for handling common AJAX events
jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
	jQuery.fn[ o ] = function( f ){
		return this.on( o, f );
	};
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			type: method,
			url: url,
			data: data,
			success: callback,
			dataType: type
		});
	};
});

jQuery.extend({

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		if ( settings ) {
			// Building a settings object
			ajaxExtend( target, jQuery.ajaxSettings );
		} else {
			// Extending ajaxSettings
			settings = target;
			target = jQuery.ajaxSettings;
		}
		ajaxExtend( target, settings );
		return target;
	},

	ajaxSettings: {
		url: ajaxLocation,
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		type: "GET",
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		processData: true,
		async: true,
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		traditional: false,
		headers: {},
		*/

		accepts: {
			xml: "application/xml, text/xml",
			html: "text/html",
			text: "text/plain",
			json: "application/json, text/javascript",
			"*": allTypes
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText"
		},

		// List of data converters
		// 1) key format is "source_type destination_type" (a single space in-between)
		// 2) the catchall symbol "*" can be used for source_type
		converters: {

			// Convert anything to text
			"* text": window.String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			context: true,
			url: true
		}
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var // Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events
			// It's the callbackContext if one was provided in the options
			// and if it's a DOM node or a jQuery collection
			globalEventContext = callbackContext !== s &&
				( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
						jQuery( callbackContext ) : jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// ifModified key
			ifModifiedKey,
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// Response headers
			responseHeadersString,
			responseHeaders,
			// transport
			transport,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// The jqXHR state
			state = 0,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Fake xhr
			jqXHR = {

				readyState: 0,

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( !state ) {
						var lname = name.toLowerCase();
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match === undefined ? null : match;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					statusText = statusText || "abort";
					if ( transport ) {
						transport.abort( statusText );
					}
					done( 0, statusText );
					return this;
				}
			};

		// Callback for when everything is done
		// It is defined here because jslint complains if it is declared
		// at the end of the function (which would be more logical and readable)
		function done( status, nativeStatusText, responses, headers ) {

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			var isSuccess,
				success,
				error,
				statusText = nativeStatusText,
				response = responses ? ajaxHandleResponses( s, jqXHR, responses ) : undefined,
				lastModified,
				etag;

			// If successful, handle type chaining
			if ( status >= 200 && status < 300 || status === 304 ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {

					if ( ( lastModified = jqXHR.getResponseHeader( "Last-Modified" ) ) ) {
						jQuery.lastModified[ ifModifiedKey ] = lastModified;
					}
					if ( ( etag = jqXHR.getResponseHeader( "Etag" ) ) ) {
						jQuery.etag[ ifModifiedKey ] = etag;
					}
				}

				// If not modified
				if ( status === 304 ) {

					statusText = "notmodified";
					isSuccess = true;

				// If we have data
				} else {

					try {
						success = ajaxConvert( s, response );
						statusText = "success";
						isSuccess = true;
					} catch(e) {
						// We have a parsererror
						statusText = "parsererror";
						error = e;
					}
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( !statusText || status ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = "" + ( nativeStatusText || statusText );

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
						[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		// Attach deferreds
		deferred.promise( jqXHR );
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;
		jqXHR.complete = completeDeferred.add;

		// Status-dependent callbacks
		jqXHR.statusCode = function( map ) {
			if ( map ) {
				var tmp;
				if ( state < 2 ) {
					for ( tmp in map ) {
						statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
					}
				} else {
					tmp = map[ jqXHR.status ];
					jqXHR.then( tmp, tmp );
				}
			}
			return this;
		};

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
		// We also use the url parameter if available
		s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( rspacesAjax );

		// Determine if a cross-domain request is in order
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] != ajaxLocParts[ 1 ] || parts[ 2 ] != ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return false;
		}

		// We can fire global events as of now if asked to
		fireGlobals = s.global;

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Get ifModifiedKey before adding the anti-cache parameter
			ifModifiedKey = s.url;

			// Add anti-cache in url if needed
			if ( s.cache === false ) {

				var ts = jQuery.now(),
					// try replacing _= if it is there
					ret = s.url.replace( rts, "$1_=" + ts );

				// if nothing was replaced, add timestamp to the end
				s.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			ifModifiedKey = ifModifiedKey || s.url;
			if ( jQuery.lastModified[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
			}
			if ( jQuery.etag[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
			}
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
				// Abort if not done already
				jqXHR.abort();
				return false;

		}

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;
			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout( function(){
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch (e) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		return jqXHR;
	},

	// Serialize an array of form elements or a set of
	// key/values into a query string
	param: function( a, traditional ) {
		var s = [],
			add = function( key, value ) {
				// If value is a function, invoke it and return its value
				value = jQuery.isFunction( value ) ? value() : value;
				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
			};

		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings.traditional;
		}

		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			});

		} else {
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( var prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" ).replace( r20, "+" );
	}
});

function buildParams( prefix, obj, traditional, add ) {
	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// If array item is non-scalar (array or object), encode its
				// numeric index to resolve deserialization ambiguity issues.
				// Note that rack (as of 1.0.0) can't currently deserialize
				// nested arrays properly, and attempting to do so may cause
				// a server error. Possible fixes are to modify rack's
				// deserialization algorithm or to provide an option or flag
				// to force array serialization to be shallow.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( var name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// This is still on the jQuery object... for now
// Want to move this to jQuery.ajax some day
jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {}

});

/* Handles responses to an ajax request:
 * - sets all responseXXX fields accordingly
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var contents = s.contents,
		dataTypes = s.dataTypes,
		responseFields = s.responseFields,
		ct,
		type,
		finalDataType,
		firstDataType;

	// Fill responseXXX fields
	for ( type in responseFields ) {
		if ( type in responses ) {
			jqXHR[ responseFields[type] ] = responses[ type ];
		}
	}

	// Remove auto dataType and get content-type in the process
	while( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

// Chain conversions given the request and the original response
function ajaxConvert( s, response ) {

	// Apply the dataFilter if provided
	if ( s.dataFilter ) {
		response = s.dataFilter( response, s.dataType );
	}

	var dataTypes = s.dataTypes,
		converters = {},
		i,
		key,
		length = dataTypes.length,
		tmp,
		// Current and previous dataTypes
		current = dataTypes[ 0 ],
		prev,
		// Conversion expression
		conversion,
		// Conversion function
		conv,
		// Conversion functions (transitive conversion)
		conv1,
		conv2;

	// For each dataType in the chain
	for ( i = 1; i < length; i++ ) {

		// Create converters map
		// with lowercased keys
		if ( i === 1 ) {
			for ( key in s.converters ) {
				if ( typeof key === "string" ) {
					converters[ key.toLowerCase() ] = s.converters[ key ];
				}
			}
		}

		// Get the dataTypes
		prev = current;
		current = dataTypes[ i ];

		// If current is auto dataType, update it to prev
		if ( current === "*" ) {
			current = prev;
		// If no auto and dataTypes are actually different
		} else if ( prev !== "*" && prev !== current ) {

			// Get the converter
			conversion = prev + " " + current;
			conv = converters[ conversion ] || converters[ "* " + current ];

			// If there is no direct converter, search transitively
			if ( !conv ) {
				conv2 = undefined;
				for ( conv1 in converters ) {
					tmp = conv1.split( " " );
					if ( tmp[ 0 ] === prev || tmp[ 0 ] === "*" ) {
						conv2 = converters[ tmp[1] + " " + current ];
						if ( conv2 ) {
							conv1 = converters[ conv1 ];
							if ( conv1 === true ) {
								conv = conv2;
							} else if ( conv2 === true ) {
								conv = conv1;
							}
							break;
						}
					}
				}
			}
			// If we found no converter, dispatch an error
			if ( !( conv || conv2 ) ) {
				jQuery.error( "No conversion from " + conversion.replace(" "," to ") );
			}
			// If found converter is not an equivalence
			if ( conv !== true ) {
				// Convert with 1 or 2 converters accordingly
				response = conv ? conv( response ) : conv2( conv1(response) );
			}
		}
	}
	return response;
}




var jsc = jQuery.now(),
	jsre = /(\=)\?(&|$)|\?\?/i;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		return jQuery.expando + "_" + ( jsc++ );
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var inspectData = ( typeof s.data === "string" ) && /^application\/x\-www\-form\-urlencoded/.test( s.contentType );

	if ( s.dataTypes[ 0 ] === "jsonp" ||
		s.jsonp !== false && ( jsre.test( s.url ) ||
				inspectData && jsre.test( s.data ) ) ) {

		var responseContainer,
			jsonpCallback = s.jsonpCallback =
				jQuery.isFunction( s.jsonpCallback ) ? s.jsonpCallback() : s.jsonpCallback,
			previous = window[ jsonpCallback ],
			url = s.url,
			data = s.data,
			replace = "$1" + jsonpCallback + "$2";

		if ( s.jsonp !== false ) {
			url = url.replace( jsre, replace );
			if ( s.url === url ) {
				if ( inspectData ) {
					data = data.replace( jsre, replace );
				}
				if ( s.data === data ) {
					// Add callback manually
					url += (/\?/.test( url ) ? "&" : "?") + s.jsonp + "=" + jsonpCallback;
				}
			}
		}

		s.url = url;
		s.data = data;

		// Install callback
		window[ jsonpCallback ] = function( response ) {
			responseContainer = [ response ];
		};

		// Clean-up function
		jqXHR.always(function() {
			// Set callback back to previous value
			window[ jsonpCallback ] = previous;
			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( previous ) ) {
				window[ jsonpCallback ]( responseContainer[ 0 ] );
			}
		});

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( jsonpCallback + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Delegate to script
		return "script";
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /javascript|ecmascript/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
		s.global = false;
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {

		var script,
			head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;

		return {

			send: function( _, callback ) {

				script = document.createElement( "script" );

				script.async = "async";

				if ( s.scriptCharset ) {
					script.charset = s.scriptCharset;
				}

				script.src = s.url;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function( _, isAbort ) {

					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;

						// Remove the script
						if ( head && script.parentNode ) {
							head.removeChild( script );
						}

						// Dereference the script
						script = undefined;

						// Callback if not abort
						if ( !isAbort ) {
							callback( 200, "success" );
						}
					}
				};
				// Use insertBefore instead of appendChild  to circumvent an IE6 bug.
				// This arises when a base node is used (#2709 and #4378).
				head.insertBefore( script, head.firstChild );
			},

			abort: function() {
				if ( script ) {
					script.onload( 0, 1 );
				}
			}
		};
	}
});




var // #5280: Internet Explorer will keep connections alive if we don't abort on unload
	xhrOnUnloadAbort = window.ActiveXObject ? function() {
		// Abort all pending requests
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]( 0, 1 );
		}
	} : false,
	xhrId = 0,
	xhrCallbacks;

// Functions to create xhrs
function createStandardXHR() {
	try {
		return new window.XMLHttpRequest();
	} catch( e ) {}
}

function createActiveXHR() {
	try {
		return new window.ActiveXObject( "Microsoft.XMLHTTP" );
	} catch( e ) {}
}

// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject ?
	/* Microsoft failed to properly
	 * implement the XMLHttpRequest in IE7 (can't request local files),
	 * so we use the ActiveXObject when it is available
	 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
	 * we need a fallback.
	 */
	function() {
		return !this.isLocal && createStandardXHR() || createActiveXHR();
	} :
	// For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

// Determine support properties
(function( xhr ) {
	jQuery.extend( jQuery.support, {
		ajax: !!xhr,
		cors: !!xhr && ( "withCredentials" in xhr )
	});
})( jQuery.ajaxSettings.xhr() );

// Create transport if the browser can provide an xhr
if ( jQuery.support.ajax ) {

	jQuery.ajaxTransport(function( s ) {
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( !s.crossDomain || jQuery.support.cors ) {

			var callback;

			return {
				send: function( headers, complete ) {

					// Get a new xhr
					var xhr = s.xhr(),
						handle,
						i;

					// Open the socket
					// Passing null username, generates a login popup on Opera (#2865)
					if ( s.username ) {
						xhr.open( s.type, s.url, s.async, s.username, s.password );
					} else {
						xhr.open( s.type, s.url, s.async );
					}

					// Apply custom fields if provided
					if ( s.xhrFields ) {
						for ( i in s.xhrFields ) {
							xhr[ i ] = s.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( s.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( s.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !s.crossDomain && !headers["X-Requested-With"] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Need an extra try/catch for cross domain requests in Firefox 3
					try {
						for ( i in headers ) {
							xhr.setRequestHeader( i, headers[ i ] );
						}
					} catch( _ ) {}

					// Do send the request
					// This may raise an exception which is actually
					// handled in jQuery.ajax (so no try/catch here)
					xhr.send( ( s.hasContent && s.data ) || null );

					// Listener
					callback = function( _, isAbort ) {

						var status,
							statusText,
							responseHeaders,
							responses,
							xml;

						// Firefox throws exceptions when accessing properties
						// of an xhr when a network error occured
						// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
						try {

							// Was never called and is aborted or complete
							if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

								// Only called once
								callback = undefined;

								// Do not keep as active anymore
								if ( handle ) {
									xhr.onreadystatechange = jQuery.noop;
									if ( xhrOnUnloadAbort ) {
										delete xhrCallbacks[ handle ];
									}
								}

								// If it's an abort
								if ( isAbort ) {
									// Abort it manually if needed
									if ( xhr.readyState !== 4 ) {
										xhr.abort();
									}
								} else {
									status = xhr.status;
									responseHeaders = xhr.getAllResponseHeaders();
									responses = {};
									xml = xhr.responseXML;

									// Construct response list
									if ( xml && xml.documentElement /* #4958 */ ) {
										responses.xml = xml;
									}

									// When requesting binary data, IE6-9 will throw an exception
									// on any attempt to access responseText (#11426)
									try {
										responses.text = xhr.responseText;
									} catch( _ ) {
									}

									// Firefox throws an exception when accessing
									// statusText for faulty cross-domain requests
									try {
										statusText = xhr.statusText;
									} catch( e ) {
										// We normalize with Webkit giving an empty statusText
										statusText = "";
									}

									// Filter status for non standard behaviors

									// If the request is local and we have data: assume a success
									// (success with no data won't get notified, that's the best we
									// can do given current implementations)
									if ( !status && s.isLocal && !s.crossDomain ) {
										status = responses.text ? 200 : 404;
									// IE - #1450: sometimes returns 1223 when it should be 204
									} else if ( status === 1223 ) {
										status = 204;
									}
								}
							}
						} catch( firefoxAccessException ) {
							if ( !isAbort ) {
								complete( -1, firefoxAccessException );
							}
						}

						// Call complete if needed
						if ( responses ) {
							complete( status, statusText, responses, responseHeaders );
						}
					};

					// if we're in sync mode or it's in cache
					// and has been retrieved directly (IE6 & IE7)
					// we need to manually fire the callback
					if ( !s.async || xhr.readyState === 4 ) {
						callback();
					} else {
						handle = ++xhrId;
						if ( xhrOnUnloadAbort ) {
							// Create the active xhrs callbacks list if needed
							// and attach the unload handler
							if ( !xhrCallbacks ) {
								xhrCallbacks = {};
								jQuery( window ).unload( xhrOnUnloadAbort );
							}
							// Add to list of active xhrs callbacks
							xhrCallbacks[ handle ] = callback;
						}
						xhr.onreadystatechange = callback;
					}
				},

				abort: function() {
					if ( callback ) {
						callback(0,1);
					}
				}
			};
		}
	});
}




var elemdisplay = {},
	iframe, iframeDoc,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,
	timerId,
	fxAttrs = [
		// height animations
		[ "height", "marginTop", "marginBottom", "paddingTop", "paddingBottom" ],
		// width animations
		[ "width", "marginLeft", "marginRight", "paddingLeft", "paddingRight" ],
		// opacity animations
		[ "opacity" ]
	],
	fxNow;

jQuery.fn.extend({
	show: function( speed, easing, callback ) {
		var elem, display;

		if ( speed || speed === 0 ) {
			return this.animate( genFx("show", 3), speed, easing, callback );

		} else {
			for ( var i = 0, j = this.length; i < j; i++ ) {
				elem = this[ i ];

				if ( elem.style ) {
					display = elem.style.display;

					// Reset the inline display of this element to learn if it is
					// being hidden by cascaded rules or not
					if ( !jQuery._data(elem, "olddisplay") && display === "none" ) {
						display = elem.style.display = "";
					}

					// Set elements which have been overridden with display: none
					// in a stylesheet to whatever the default browser style is
					// for such an element
					if ( (display === "" && jQuery.css(elem, "display") === "none") ||
						!jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
						jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
					}
				}
			}

			// Set the display of most of the elements in a second loop
			// to avoid the constant reflow
			for ( i = 0; i < j; i++ ) {
				elem = this[ i ];

				if ( elem.style ) {
					display = elem.style.display;

					if ( display === "" || display === "none" ) {
						elem.style.display = jQuery._data( elem, "olddisplay" ) || "";
					}
				}
			}

			return this;
		}
	},

	hide: function( speed, easing, callback ) {
		if ( speed || speed === 0 ) {
			return this.animate( genFx("hide", 3), speed, easing, callback);

		} else {
			var elem, display,
				i = 0,
				j = this.length;

			for ( ; i < j; i++ ) {
				elem = this[i];
				if ( elem.style ) {
					display = jQuery.css( elem, "display" );

					if ( display !== "none" && !jQuery._data( elem, "olddisplay" ) ) {
						jQuery._data( elem, "olddisplay", display );
					}
				}
			}

			// Set the display of the elements in a second loop
			// to avoid the constant reflow
			for ( i = 0; i < j; i++ ) {
				if ( this[i].style ) {
					this[i].style.display = "none";
				}
			}

			return this;
		}
	},

	// Save the old toggle function
	_toggle: jQuery.fn.toggle,

	toggle: function( fn, fn2, callback ) {
		var bool = typeof fn === "boolean";

		if ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {
			this._toggle.apply( this, arguments );

		} else if ( fn == null || bool ) {
			this.each(function() {
				var state = bool ? fn : jQuery(this).is(":hidden");
				jQuery(this)[ state ? "show" : "hide" ]();
			});

		} else {
			this.animate(genFx("toggle", 3), fn, fn2, callback);
		}

		return this;
	},

	fadeTo: function( speed, to, easing, callback ) {
		return this.filter(":hidden").css("opacity", 0).show().end()
					.animate({opacity: to}, speed, easing, callback);
	},

	animate: function( prop, speed, easing, callback ) {
		var optall = jQuery.speed( speed, easing, callback );

		if ( jQuery.isEmptyObject( prop ) ) {
			return this.each( optall.complete, [ false ] );
		}

		// Do not change referenced properties as per-property easing will be lost
		prop = jQuery.extend( {}, prop );

		function doAnimation() {
			// XXX 'this' does not always have a nodeName when running the
			// test suite

			if ( optall.queue === false ) {
				jQuery._mark( this );
			}

			var opt = jQuery.extend( {}, optall ),
				isElement = this.nodeType === 1,
				hidden = isElement && jQuery(this).is(":hidden"),
				name, val, p, e, hooks, replace,
				parts, start, end, unit,
				method;

			// will store per property easing and be used to determine when an animation is complete
			opt.animatedProperties = {};

			// first pass over propertys to expand / normalize
			for ( p in prop ) {
				name = jQuery.camelCase( p );
				if ( p !== name ) {
					prop[ name ] = prop[ p ];
					delete prop[ p ];
				}

				if ( ( hooks = jQuery.cssHooks[ name ] ) && "expand" in hooks ) {
					replace = hooks.expand( prop[ name ] );
					delete prop[ name ];

					// not quite $.extend, this wont overwrite keys already present.
					// also - reusing 'p' from above because we have the correct "name"
					for ( p in replace ) {
						if ( ! ( p in prop ) ) {
							prop[ p ] = replace[ p ];
						}
					}
				}
			}

			for ( name in prop ) {
				val = prop[ name ];
				// easing resolution: per property > opt.specialEasing > opt.easing > 'swing' (default)
				if ( jQuery.isArray( val ) ) {
					opt.animatedProperties[ name ] = val[ 1 ];
					val = prop[ name ] = val[ 0 ];
				} else {
					opt.animatedProperties[ name ] = opt.specialEasing && opt.specialEasing[ name ] || opt.easing || 'swing';
				}

				if ( val === "hide" && hidden || val === "show" && !hidden ) {
					return opt.complete.call( this );
				}

				if ( isElement && ( name === "height" || name === "width" ) ) {
					// Make sure that nothing sneaks out
					// Record all 3 overflow attributes because IE does not
					// change the overflow attribute when overflowX and
					// overflowY are set to the same value
					opt.overflow = [ this.style.overflow, this.style.overflowX, this.style.overflowY ];

					// Set display property to inline-block for height/width
					// animations on inline elements that are having width/height animated
					if ( jQuery.css( this, "display" ) === "inline" &&
							jQuery.css( this, "float" ) === "none" ) {

						// inline-level elements accept inline-block;
						// block-level elements need to be inline with layout
						if ( !jQuery.support.inlineBlockNeedsLayout || defaultDisplay( this.nodeName ) === "inline" ) {
							this.style.display = "inline-block";

						} else {
							this.style.zoom = 1;
						}
					}
				}
			}

			if ( opt.overflow != null ) {
				this.style.overflow = "hidden";
			}

			for ( p in prop ) {
				e = new jQuery.fx( this, opt, p );
				val = prop[ p ];

				if ( rfxtypes.test( val ) ) {

					// Tracks whether to show or hide based on private
					// data attached to the element
					method = jQuery._data( this, "toggle" + p ) || ( val === "toggle" ? hidden ? "show" : "hide" : 0 );
					if ( method ) {
						jQuery._data( this, "toggle" + p, method === "show" ? "hide" : "show" );
						e[ method ]();
					} else {
						e[ val ]();
					}

				} else {
					parts = rfxnum.exec( val );
					start = e.cur();

					if ( parts ) {
						end = parseFloat( parts[2] );
						unit = parts[3] || ( jQuery.cssNumber[ p ] ? "" : "px" );

						// We need to compute starting value
						if ( unit !== "px" ) {
							jQuery.style( this, p, (end || 1) + unit);
							start = ( (end || 1) / e.cur() ) * start;
							jQuery.style( this, p, start + unit);
						}

						// If a +=/-= token was provided, we're doing a relative animation
						if ( parts[1] ) {
							end = ( (parts[ 1 ] === "-=" ? -1 : 1) * end ) + start;
						}

						e.custom( start, end, unit );

					} else {
						e.custom( start, val, "" );
					}
				}
			}

			// For JS strict compliance
			return true;
		}

		return optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},

	stop: function( type, clearQueue, gotoEnd ) {
		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var index,
				hadTimers = false,
				timers = jQuery.timers,
				data = jQuery._data( this );

			// clear marker counters if we know they won't be
			if ( !gotoEnd ) {
				jQuery._unmark( true, this );
			}

			function stopQueue( elem, data, index ) {
				var hooks = data[ index ];
				jQuery.removeData( elem, index, true );
				hooks.stop( gotoEnd );
			}

			if ( type == null ) {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && index.indexOf(".run") === index.length - 4 ) {
						stopQueue( this, data, index );
					}
				}
			} else if ( data[ index = type + ".run" ] && data[ index ].stop ){
				stopQueue( this, data, index );
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					if ( gotoEnd ) {

						// force the next step to be the last
						timers[ index ]( true );
					} else {
						timers[ index ].saveState();
					}
					hadTimers = true;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( !( gotoEnd && hadTimers ) ) {
				jQuery.dequeue( this, type );
			}
		});
	}

});

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout( clearFxNow, 0 );
	return ( fxNow = jQuery.now() );
}

function clearFxNow() {
	fxNow = undefined;
}

// Generate parameters to create a standard animation
function genFx( type, num ) {
	var obj = {};

	jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice( 0, num )), function() {
		obj[ this ] = type;
	});

	return obj;
}

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx( "show", 1 ),
	slideUp: genFx( "hide", 1 ),
	slideToggle: genFx( "toggle", 1 ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.extend({
	speed: function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

		// normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function( noUnmark ) {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			} else if ( noUnmark !== false ) {
				jQuery._unmark( this );
			}
		};

		return opt;
	},

	easing: {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return ( -Math.cos( p*Math.PI ) / 2 ) + 0.5;
		}
	},

	timers: [],

	fx: function( elem, options, prop ) {
		this.options = options;
		this.elem = elem;
		this.prop = prop;

		options.orig = options.orig || {};
	}

});

jQuery.fx.prototype = {
	// Simple function for setting a style value
	update: function() {
		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		( jQuery.fx.step[ this.prop ] || jQuery.fx.step._default )( this );
	},

	// Get the current size
	cur: function() {
		if ( this.elem[ this.prop ] != null && (!this.elem.style || this.elem.style[ this.prop ] == null) ) {
			return this.elem[ this.prop ];
		}

		var parsed,
			r = jQuery.css( this.elem, this.prop );
		// Empty strings, null, undefined and "auto" are converted to 0,
		// complex values such as "rotate(1rad)" are returned as is,
		// simple values such as "10px" are parsed to Float.
		return isNaN( parsed = parseFloat( r ) ) ? !r || r === "auto" ? 0 : r : parsed;
	},

	// Start an animation from one number to another
	custom: function( from, to, unit ) {
		var self = this,
			fx = jQuery.fx;

		this.startTime = fxNow || createFxNow();
		this.end = to;
		this.now = this.start = from;
		this.pos = this.state = 0;
		this.unit = unit || this.unit || ( jQuery.cssNumber[ this.prop ] ? "" : "px" );

		function t( gotoEnd ) {
			return self.step( gotoEnd );
		}

		t.queue = this.options.queue;
		t.elem = this.elem;
		t.saveState = function() {
			if ( jQuery._data( self.elem, "fxshow" + self.prop ) === undefined ) {
				if ( self.options.hide ) {
					jQuery._data( self.elem, "fxshow" + self.prop, self.start );
				} else if ( self.options.show ) {
					jQuery._data( self.elem, "fxshow" + self.prop, self.end );
				}
			}
		};

		if ( t() && jQuery.timers.push(t) && !timerId ) {
			timerId = setInterval( fx.tick, fx.interval );
		}
	},

	// Simple 'show' function
	show: function() {
		var dataShow = jQuery._data( this.elem, "fxshow" + this.prop );

		// Remember where we started, so that we can go back to it later
		this.options.orig[ this.prop ] = dataShow || jQuery.style( this.elem, this.prop );
		this.options.show = true;

		// Begin the animation
		// Make sure that we start at a small width/height to avoid any flash of content
		if ( dataShow !== undefined ) {
			// This show is picking up where a previous hide or show left off
			this.custom( this.cur(), dataShow );
		} else {
			this.custom( this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur() );
		}

		// Start by showing the element
		jQuery( this.elem ).show();
	},

	// Simple 'hide' function
	hide: function() {
		// Remember where we started, so that we can go back to it later
		this.options.orig[ this.prop ] = jQuery._data( this.elem, "fxshow" + this.prop ) || jQuery.style( this.elem, this.prop );
		this.options.hide = true;

		// Begin the animation
		this.custom( this.cur(), 0 );
	},

	// Each step of an animation
	step: function( gotoEnd ) {
		var p, n, complete,
			t = fxNow || createFxNow(),
			done = true,
			elem = this.elem,
			options = this.options;

		if ( gotoEnd || t >= options.duration + this.startTime ) {
			this.now = this.end;
			this.pos = this.state = 1;
			this.update();

			options.animatedProperties[ this.prop ] = true;

			for ( p in options.animatedProperties ) {
				if ( options.animatedProperties[ p ] !== true ) {
					done = false;
				}
			}

			if ( done ) {
				// Reset the overflow
				if ( options.overflow != null && !jQuery.support.shrinkWrapBlocks ) {

					jQuery.each( [ "", "X", "Y" ], function( index, value ) {
						elem.style[ "overflow" + value ] = options.overflow[ index ];
					});
				}

				// Hide the element if the "hide" operation was done
				if ( options.hide ) {
					jQuery( elem ).hide();
				}

				// Reset the properties, if the item has been hidden or shown
				if ( options.hide || options.show ) {
					for ( p in options.animatedProperties ) {
						jQuery.style( elem, p, options.orig[ p ] );
						jQuery.removeData( elem, "fxshow" + p, true );
						// Toggle data is no longer needed
						jQuery.removeData( elem, "toggle" + p, true );
					}
				}

				// Execute the complete function
				// in the event that the complete function throws an exception
				// we must ensure it won't be called twice. #5684

				complete = options.complete;
				if ( complete ) {

					options.complete = false;
					complete.call( elem );
				}
			}

			return false;

		} else {
			// classical easing cannot be used with an Infinity duration
			if ( options.duration == Infinity ) {
				this.now = t;
			} else {
				n = t - this.startTime;
				this.state = n / options.duration;

				// Perform the easing function, defaults to swing
				this.pos = jQuery.easing[ options.animatedProperties[this.prop] ]( this.state, n, 0, 1, options.duration );
				this.now = this.start + ( (this.end - this.start) * this.pos );
			}
			// Perform the next step of the animation
			this.update();
		}

		return true;
	}
};

jQuery.extend( jQuery.fx, {
	tick: function() {
		var timer,
			timers = jQuery.timers,
			i = 0;

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];
			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
	},

	interval: 13,

	stop: function() {
		clearInterval( timerId );
		timerId = null;
	},

	speeds: {
		slow: 600,
		fast: 200,
		// Default speed
		_default: 400
	},

	step: {
		opacity: function( fx ) {
			jQuery.style( fx.elem, "opacity", fx.now );
		},

		_default: function( fx ) {
			if ( fx.elem.style && fx.elem.style[ fx.prop ] != null ) {
				fx.elem.style[ fx.prop ] = fx.now + fx.unit;
			} else {
				fx.elem[ fx.prop ] = fx.now;
			}
		}
	}
});

// Ensure props that can't be negative don't go there on undershoot easing
jQuery.each( fxAttrs.concat.apply( [], fxAttrs ), function( i, prop ) {
	// exclude marginTop, marginLeft, marginBottom and marginRight from this list
	if ( prop.indexOf( "margin" ) ) {
		jQuery.fx.step[ prop ] = function( fx ) {
			jQuery.style( fx.elem, prop, Math.max(0, fx.now) + fx.unit );
		};
	}
});

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};
}

// Try to restore the default display value of an element
function defaultDisplay( nodeName ) {

	if ( !elemdisplay[ nodeName ] ) {

		var body = document.body,
			elem = jQuery( "<" + nodeName + ">" ).appendTo( body ),
			display = elem.css( "display" );
		elem.remove();

		// If the simple way fails,
		// get element's real default display by attaching it to a temp iframe
		if ( display === "none" || display === "" ) {
			// No iframe to use yet, so create it
			if ( !iframe ) {
				iframe = document.createElement( "iframe" );
				iframe.frameBorder = iframe.width = iframe.height = 0;
			}

			body.appendChild( iframe );

			// Create a cacheable copy of the iframe document on first call.
			// IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
			// document to it; WebKit & Firefox won't allow reusing the iframe document.
			if ( !iframeDoc || !iframe.createElement ) {
				iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
				iframeDoc.write( ( jQuery.support.boxModel ? "<!doctype html>" : "" ) + "<html><body>" );
				iframeDoc.close();
			}

			elem = iframeDoc.createElement( nodeName );

			iframeDoc.body.appendChild( elem );

			display = jQuery.css( elem, "display" );
			body.removeChild( iframe );
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return elemdisplay[ nodeName ];
}




var getOffset,
	rtable = /^t(?:able|d|h)$/i,
	rroot = /^(?:body|html)$/i;

if ( "getBoundingClientRect" in document.documentElement ) {
	getOffset = function( elem, doc, docElem, box ) {
		try {
			box = elem.getBoundingClientRect();
		} catch(e) {}

		// Make sure we're not dealing with a disconnected DOM node
		if ( !box || !jQuery.contains( docElem, elem ) ) {
			return box ? { top: box.top, left: box.left } : { top: 0, left: 0 };
		}

		var body = doc.body,
			win = getWindow( doc ),
			clientTop  = docElem.clientTop  || body.clientTop  || 0,
			clientLeft = docElem.clientLeft || body.clientLeft || 0,
			scrollTop  = win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop  || body.scrollTop,
			scrollLeft = win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft,
			top  = box.top  + scrollTop  - clientTop,
			left = box.left + scrollLeft - clientLeft;

		return { top: top, left: left };
	};

} else {
	getOffset = function( elem, doc, docElem ) {
		var computedStyle,
			offsetParent = elem.offsetParent,
			prevOffsetParent = elem,
			body = doc.body,
			defaultView = doc.defaultView,
			prevComputedStyle = defaultView ? defaultView.getComputedStyle( elem, null ) : elem.currentStyle,
			top = elem.offsetTop,
			left = elem.offsetLeft;

		while ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) {
			if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
				break;
			}

			computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
			top  -= elem.scrollTop;
			left -= elem.scrollLeft;

			if ( elem === offsetParent ) {
				top  += elem.offsetTop;
				left += elem.offsetLeft;

				if ( jQuery.support.doesNotAddBorder && !(jQuery.support.doesAddBorderForTableAndCells && rtable.test(elem.nodeName)) ) {
					top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
					left += parseFloat( computedStyle.borderLeftWidth ) || 0;
				}

				prevOffsetParent = offsetParent;
				offsetParent = elem.offsetParent;
			}

			if ( jQuery.support.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible" ) {
				top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
				left += parseFloat( computedStyle.borderLeftWidth ) || 0;
			}

			prevComputedStyle = computedStyle;
		}

		if ( prevComputedStyle.position === "relative" || prevComputedStyle.position === "static" ) {
			top  += body.offsetTop;
			left += body.offsetLeft;
		}

		if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
			top  += Math.max( docElem.scrollTop, body.scrollTop );
			left += Math.max( docElem.scrollLeft, body.scrollLeft );
		}

		return { top: top, left: left };
	};
}

jQuery.fn.offset = function( options ) {
	if ( arguments.length ) {
		return options === undefined ?
			this :
			this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
	}

	var elem = this[0],
		doc = elem && elem.ownerDocument;

	if ( !doc ) {
		return null;
	}

	if ( elem === doc.body ) {
		return jQuery.offset.bodyOffset( elem );
	}

	return getOffset( elem, doc, doc.documentElement );
};

jQuery.offset = {

	bodyOffset: function( body ) {
		var top = body.offsetTop,
			left = body.offsetLeft;

		if ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {
			top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
			left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
		}

		return { top: top, left: left };
	},

	setOffset: function( elem, options, i ) {
		var position = jQuery.css( elem, "position" );

		// set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		var curElem = jQuery( elem ),
			curOffset = curElem.offset(),
			curCSSTop = jQuery.css( elem, "top" ),
			curCSSLeft = jQuery.css( elem, "left" ),
			calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
			props = {}, curPosition = {}, curTop, curLeft;

		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};


jQuery.fn.extend({

	position: function() {
		if ( !this[0] ) {
			return null;
		}

		var elem = this[0],

		// Get *real* offsetParent
		offsetParent = this.offsetParent(),

		// Get correct offsets
		offset       = this.offset(),
		parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

		// Subtract element margins
		// note: when an element has margin: auto the offsetLeft and marginLeft
		// are the same in Safari causing offset.left to incorrectly be 0
		offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
		offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;

		// Add offsetParent borders
		parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
		parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;

		// Subtract the two offsets
		return {
			top:  offset.top  - parentOffset.top,
			left: offset.left - parentOffset.left
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || document.body;
			while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent;
		});
	}
});


// Create scrollLeft and scrollTop methods
jQuery.each( {scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function( method, prop ) {
	var top = /Y/.test( prop );

	jQuery.fn[ method ] = function( val ) {
		return jQuery.access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? (prop in win) ? win[ prop ] :
					jQuery.support.boxModel && win.document.documentElement[ method ] ||
						win.document.body[ method ] :
					elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : jQuery( win ).scrollLeft(),
					 top ? val : jQuery( win ).scrollTop()
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}




// Create width, height, innerHeight, innerWidth, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	var clientProp = "client" + name,
		scrollProp = "scroll" + name,
		offsetProp = "offset" + name;

	// innerHeight and innerWidth
	jQuery.fn[ "inner" + name ] = function() {
		var elem = this[0];
		return elem ?
			elem.style ?
			parseFloat( jQuery.css( elem, type, "padding" ) ) :
			this[ type ]() :
			null;
	};

	// outerHeight and outerWidth
	jQuery.fn[ "outer" + name ] = function( margin ) {
		var elem = this[0];
		return elem ?
			elem.style ?
			parseFloat( jQuery.css( elem, type, margin ? "margin" : "border" ) ) :
			this[ type ]() :
			null;
	};

	jQuery.fn[ type ] = function( value ) {
		return jQuery.access( this, function( elem, type, value ) {
			var doc, docElemProp, orig, ret;

			if ( jQuery.isWindow( elem ) ) {
				// 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat
				doc = elem.document;
				docElemProp = doc.documentElement[ clientProp ];
				return jQuery.support.boxModel && docElemProp ||
					doc.body && doc.body[ clientProp ] || docElemProp;
			}

			// Get document width or height
			if ( elem.nodeType === 9 ) {
				// Either scroll[Width/Height] or offset[Width/Height], whichever is greater
				doc = elem.documentElement;

				// when a window > document, IE6 reports a offset[Width/Height] > client[Width/Height]
				// so we can't use max, as it'll choose the incorrect offset[Width/Height]
				// instead we use the correct client[Width/Height]
				// support:IE6
				if ( doc[ clientProp ] >= doc[ scrollProp ] ) {
					return doc[ clientProp ];
				}

				return Math.max(
					elem.body[ scrollProp ], doc[ scrollProp ],
					elem.body[ offsetProp ], doc[ offsetProp ]
				);
			}

			// Get width or height on the element
			if ( value === undefined ) {
				orig = jQuery.css( elem, type );
				ret = parseFloat( orig );
				return jQuery.isNumeric( ret ) ? ret : orig;
			}

			// Set the width or height on the element
			jQuery( elem ).css( type, value );
		}, type, value, arguments.length, null );
	};
});




// Expose jQuery to the global object
window.jQuery = window.$ = jQuery;

// Expose jQuery as an AMD module, but only for AMD loaders that
// understand the issues with loading multiple versions of jQuery
// in a page that all might call define(). The loader will indicate
// they have special allowances for multiple jQuery versions by
// specifying define.amd.jQuery = true. Register as a named module,
// since jQuery can be concatenated with other files that may use define,
// but not use a proper concatenation script that understands anonymous
// AMD modules. A named AMD is safest and most robust way to register.
// Lowercase jquery is used because AMD module names are derived from
// file names, and jQuery is normally delivered in a lowercase file name.
// Do this after creating the global so that if an AMD module wants to call
// noConflict to hide this version of jQuery, it will work.
if ( typeof define === "function" && define.amd && define.amd.jQuery ) {
	define( "jquery", [], function () { return jQuery; } );
}



})( window );

```

`LibreHardwareMonitor/Resources/Web/js/jquery-1.7.2.min.js`:

```js
/*! jQuery v1.7.2 jquery.com | jquery.org/license */
(function(a,b){function cy(a){return f.isWindow(a)?a:a.nodeType===9?a.defaultView||a.parentWindow:!1}function cu(a){if(!cj[a]){var b=c.body,d=f("<"+a+">").appendTo(b),e=d.css("display");d.remove();if(e==="none"||e===""){ck||(ck=c.createElement("iframe"),ck.frameBorder=ck.width=ck.height=0),b.appendChild(ck);if(!cl||!ck.createElement)cl=(ck.contentWindow||ck.contentDocument).document,cl.write((f.support.boxModel?"<!doctype html>":"")+"<html><body>"),cl.close();d=cl.createElement(a),cl.body.appendChild(d),e=f.css(d,"display"),b.removeChild(ck)}cj[a]=e}return cj[a]}function ct(a,b){var c={};f.each(cp.concat.apply([],cp.slice(0,b)),function(){c[this]=a});return c}function cs(){cq=b}function cr(){setTimeout(cs,0);return cq=f.now()}function ci(){try{return new a.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}}function ch(){try{return new a.XMLHttpRequest}catch(b){}}function cb(a,c){a.dataFilter&&(c=a.dataFilter(c,a.dataType));var d=a.dataTypes,e={},g,h,i=d.length,j,k=d[0],l,m,n,o,p;for(g=1;g<i;g++){if(g===1)for(h in a.converters)typeof h=="string"&&(e[h.toLowerCase()]=a.converters[h]);l=k,k=d[g];if(k==="*")k=l;else if(l!=="*"&&l!==k){m=l+" "+k,n=e[m]||e["* "+k];if(!n){p=b;for(o in e){j=o.split(" ");if(j[0]===l||j[0]==="*"){p=e[j[1]+" "+k];if(p){o=e[o],o===!0?n=p:p===!0&&(n=o);break}}}}!n&&!p&&f.error("No conversion from "+m.replace(" "," to ")),n!==!0&&(c=n?n(c):p(o(c)))}}return c}function ca(a,c,d){var e=a.contents,f=a.dataTypes,g=a.responseFields,h,i,j,k;for(i in g)i in d&&(c[g[i]]=d[i]);while(f[0]==="*")f.shift(),h===b&&(h=a.mimeType||c.getResponseHeader("content-type"));if(h)for(i in e)if(e[i]&&e[i].test(h)){f.unshift(i);break}if(f[0]in d)j=f[0];else{for(i in d){if(!f[0]||a.converters[i+" "+f[0]]){j=i;break}k||(k=i)}j=j||k}if(j){j!==f[0]&&f.unshift(j);return d[j]}}function b_(a,b,c,d){if(f.isArray(b))f.each(b,function(b,e){c||bD.test(a)?d(a,e):b_(a+"["+(typeof e=="object"?b:"")+"]",e,c,d)});else if(!c&&f.type(b)==="object")for(var e in b)b_(a+"["+e+"]",b[e],c,d);else d(a,b)}function b$(a,c){var d,e,g=f.ajaxSettings.flatOptions||{};for(d in c)c[d]!==b&&((g[d]?a:e||(e={}))[d]=c[d]);e&&f.extend(!0,a,e)}function bZ(a,c,d,e,f,g){f=f||c.dataTypes[0],g=g||{},g[f]=!0;var h=a[f],i=0,j=h?h.length:0,k=a===bS,l;for(;i<j&&(k||!l);i++)l=h[i](c,d,e),typeof l=="string"&&(!k||g[l]?l=b:(c.dataTypes.unshift(l),l=bZ(a,c,d,e,l,g)));(k||!l)&&!g["*"]&&(l=bZ(a,c,d,e,"*",g));return l}function bY(a){return function(b,c){typeof b!="string"&&(c=b,b="*");if(f.isFunction(c)){var d=b.toLowerCase().split(bO),e=0,g=d.length,h,i,j;for(;e<g;e++)h=d[e],j=/^\+/.test(h),j&&(h=h.substr(1)||"*"),i=a[h]=a[h]||[],i[j?"unshift":"push"](c)}}}function bB(a,b,c){var d=b==="width"?a.offsetWidth:a.offsetHeight,e=b==="width"?1:0,g=4;if(d>0){if(c!=="border")for(;e<g;e+=2)c||(d-=parseFloat(f.css(a,"padding"+bx[e]))||0),c==="margin"?d+=parseFloat(f.css(a,c+bx[e]))||0:d-=parseFloat(f.css(a,"border"+bx[e]+"Width"))||0;return d+"px"}d=by(a,b);if(d<0||d==null)d=a.style[b];if(bt.test(d))return d;d=parseFloat(d)||0;if(c)for(;e<g;e+=2)d+=parseFloat(f.css(a,"padding"+bx[e]))||0,c!=="padding"&&(d+=parseFloat(f.css(a,"border"+bx[e]+"Width"))||0),c==="margin"&&(d+=parseFloat(f.css(a,c+bx[e]))||0);return d+"px"}function bo(a){var b=c.createElement("div");bh.appendChild(b),b.innerHTML=a.outerHTML;return b.firstChild}function bn(a){var b=(a.nodeName||"").toLowerCase();b==="input"?bm(a):b!=="script"&&typeof a.getElementsByTagName!="undefined"&&f.grep(a.getElementsByTagName("input"),bm)}function bm(a){if(a.type==="checkbox"||a.type==="radio")a.defaultChecked=a.checked}function bl(a){return typeof a.getElementsByTagName!="undefined"?a.getElementsByTagName("*"):typeof a.querySelectorAll!="undefined"?a.querySelectorAll("*"):[]}function bk(a,b){var c;b.nodeType===1&&(b.clearAttributes&&b.clearAttributes(),b.mergeAttributes&&b.mergeAttributes(a),c=b.nodeName.toLowerCase(),c==="object"?b.outerHTML=a.outerHTML:c!=="input"||a.type!=="checkbox"&&a.type!=="radio"?c==="option"?b.selected=a.defaultSelected:c==="input"||c==="textarea"?b.defaultValue=a.defaultValue:c==="script"&&b.text!==a.text&&(b.text=a.text):(a.checked&&(b.defaultChecked=b.checked=a.checked),b.value!==a.value&&(b.value=a.value)),b.removeAttribute(f.expando),b.removeAttribute("_submit_attached"),b.removeAttribute("_change_attached"))}function bj(a,b){if(b.nodeType===1&&!!f.hasData(a)){var c,d,e,g=f._data(a),h=f._data(b,g),i=g.events;if(i){delete h.handle,h.events={};for(c in i)for(d=0,e=i[c].length;d<e;d++)f.event.add(b,c,i[c][d])}h.data&&(h.data=f.extend({},h.data))}}function bi(a,b){return f.nodeName(a,"table")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function U(a){var b=V.split("|"),c=a.createDocumentFragment();if(c.createElement)while(b.length)c.createElement(b.pop());return c}function T(a,b,c){b=b||0;if(f.isFunction(b))return f.grep(a,function(a,d){var e=!!b.call(a,d,a);return e===c});if(b.nodeType)return f.grep(a,function(a,d){return a===b===c});if(typeof b=="string"){var d=f.grep(a,function(a){return a.nodeType===1});if(O.test(b))return f.filter(b,d,!c);b=f.filter(b,d)}return f.grep(a,function(a,d){return f.inArray(a,b)>=0===c})}function S(a){return!a||!a.parentNode||a.parentNode.nodeType===11}function K(){return!0}function J(){return!1}function n(a,b,c){var d=b+"defer",e=b+"queue",g=b+"mark",h=f._data(a,d);h&&(c==="queue"||!f._data(a,e))&&(c==="mark"||!f._data(a,g))&&setTimeout(function(){!f._data(a,e)&&!f._data(a,g)&&(f.removeData(a,d,!0),h.fire())},0)}function m(a){for(var b in a){if(b==="data"&&f.isEmptyObject(a[b]))continue;if(b!=="toJSON")return!1}return!0}function l(a,c,d){if(d===b&&a.nodeType===1){var e="data-"+c.replace(k,"-$1").toLowerCase();d=a.getAttribute(e);if(typeof d=="string"){try{d=d==="true"?!0:d==="false"?!1:d==="null"?null:f.isNumeric(d)?+d:j.test(d)?f.parseJSON(d):d}catch(g){}f.data(a,c,d)}else d=b}return d}function h(a){var b=g[a]={},c,d;a=a.split(/\s+/);for(c=0,d=a.length;c<d;c++)b[a[c]]=!0;return b}var c=a.document,d=a.navigator,e=a.location,f=function(){function J(){if(!e.isReady){try{c.documentElement.doScroll("left")}catch(a){setTimeout(J,1);return}e.ready()}}var e=function(a,b){return new e.fn.init(a,b,h)},f=a.jQuery,g=a.$,h,i=/^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,j=/\S/,k=/^\s+/,l=/\s+$/,m=/^<(\w+)\s*\/?>(?:<\/\1>)?$/,n=/^[\],:{}\s]*$/,o=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,p=/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,q=/(?:^|:|,)(?:\s*\[)+/g,r=/(webkit)[ \/]([\w.]+)/,s=/(opera)(?:.*version)?[ \/]([\w.]+)/,t=/(msie) ([\w.]+)/,u=/(mozilla)(?:.*? rv:([\w.]+))?/,v=/-([a-z]|[0-9])/ig,w=/^-ms-/,x=function(a,b){return(b+"").toUpperCase()},y=d.userAgent,z,A,B,C=Object.prototype.toString,D=Object.prototype.hasOwnProperty,E=Array.prototype.push,F=Array.prototype.slice,G=String.prototype.trim,H=Array.prototype.indexOf,I={};e.fn=e.prototype={constructor:e,init:function(a,d,f){var g,h,j,k;if(!a)return this;if(a.nodeType){this.context=this[0]=a,this.length=1;return this}if(a==="body"&&!d&&c.body){this.context=c,this[0]=c.body,this.selector=a,this.length=1;return this}if(typeof a=="string"){a.charAt(0)!=="<"||a.charAt(a.length-1)!==">"||a.length<3?g=i.exec(a):g=[null,a,null];if(g&&(g[1]||!d)){if(g[1]){d=d instanceof e?d[0]:d,k=d?d.ownerDocument||d:c,j=m.exec(a),j?e.isPlainObject(d)?(a=[c.createElement(j[1])],e.fn.attr.call(a,d,!0)):a=[k.createElement(j[1])]:(j=e.buildFragment([g[1]],[k]),a=(j.cacheable?e.clone(j.fragment):j.fragment).childNodes);return e.merge(this,a)}h=c.getElementById(g[2]);if(h&&h.parentNode){if(h.id!==g[2])return f.find(a);this.length=1,this[0]=h}this.context=c,this.selector=a;return this}return!d||d.jquery?(d||f).find(a):this.constructor(d).find(a)}if(e.isFunction(a))return f.ready(a);a.selector!==b&&(this.selector=a.selector,this.context=a.context);return e.makeArray(a,this)},selector:"",jquery:"1.7.2",length:0,size:function(){return this.length},toArray:function(){return F.call(this,0)},get:function(a){return a==null?this.toArray():a<0?this[this.length+a]:this[a]},pushStack:function(a,b,c){var d=this.constructor();e.isArray(a)?E.apply(d,a):e.merge(d,a),d.prevObject=this,d.context=this.context,b==="find"?d.selector=this.selector+(this.selector?" ":"")+c:b&&(d.selector=this.selector+"."+b+"("+c+")");return d},each:function(a,b){return e.each(this,a,b)},ready:function(a){e.bindReady(),A.add(a);return this},eq:function(a){a=+a;return a===-1?this.slice(a):this.slice(a,a+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(F.apply(this,arguments),"slice",F.call(arguments).join(","))},map:function(a){return this.pushStack(e.map(this,function(b,c){return a.call(b,c,b)}))},end:function(){return this.prevObject||this.constructor(null)},push:E,sort:[].sort,splice:[].splice},e.fn.init.prototype=e.fn,e.extend=e.fn.extend=function(){var a,c,d,f,g,h,i=arguments[0]||{},j=1,k=arguments.length,l=!1;typeof i=="boolean"&&(l=i,i=arguments[1]||{},j=2),typeof i!="object"&&!e.isFunction(i)&&(i={}),k===j&&(i=this,--j);for(;j<k;j++)if((a=arguments[j])!=null)for(c in a){d=i[c],f=a[c];if(i===f)continue;l&&f&&(e.isPlainObject(f)||(g=e.isArray(f)))?(g?(g=!1,h=d&&e.isArray(d)?d:[]):h=d&&e.isPlainObject(d)?d:{},i[c]=e.extend(l,h,f)):f!==b&&(i[c]=f)}return i},e.extend({noConflict:function(b){a.$===e&&(a.$=g),b&&a.jQuery===e&&(a.jQuery=f);return e},isReady:!1,readyWait:1,holdReady:function(a){a?e.readyWait++:e.ready(!0)},ready:function(a){if(a===!0&&!--e.readyWait||a!==!0&&!e.isReady){if(!c.body)return setTimeout(e.ready,1);e.isReady=!0;if(a!==!0&&--e.readyWait>0)return;A.fireWith(c,[e]),e.fn.trigger&&e(c).trigger("ready").off("ready")}},bindReady:function(){if(!A){A=e.Callbacks("once memory");if(c.readyState==="complete")return setTimeout(e.ready,1);if(c.addEventListener)c.addEventListener("DOMContentLoaded",B,!1),a.addEventListener("load",e.ready,!1);else if(c.attachEvent){c.attachEvent("onreadystatechange",B),a.attachEvent("onload",e.ready);var b=!1;try{b=a.frameElement==null}catch(d){}c.documentElement.doScroll&&b&&J()}}},isFunction:function(a){return e.type(a)==="function"},isArray:Array.isArray||function(a){return e.type(a)==="array"},isWindow:function(a){return a!=null&&a==a.window},isNumeric:function(a){return!isNaN(parseFloat(a))&&isFinite(a)},type:function(a){return a==null?String(a):I[C.call(a)]||"object"},isPlainObject:function(a){if(!a||e.type(a)!=="object"||a.nodeType||e.isWindow(a))return!1;try{if(a.constructor&&!D.call(a,"constructor")&&!D.call(a.constructor.prototype,"isPrototypeOf"))return!1}catch(c){return!1}var d;for(d in a);return d===b||D.call(a,d)},isEmptyObject:function(a){for(var b in a)return!1;return!0},error:function(a){throw new Error(a)},parseJSON:function(b){if(typeof b!="string"||!b)return null;b=e.trim(b);if(a.JSON&&a.JSON.parse)return a.JSON.parse(b);if(n.test(b.replace(o,"@").replace(p,"]").replace(q,"")))return(new Function("return "+b))();e.error("Invalid JSON: "+b)},parseXML:function(c){if(typeof c!="string"||!c)return null;var d,f;try{a.DOMParser?(f=new DOMParser,d=f.parseFromString(c,"text/xml")):(d=new ActiveXObject("Microsoft.XMLDOM"),d.async="false",d.loadXML(c))}catch(g){d=b}(!d||!d.documentElement||d.getElementsByTagName("parsererror").length)&&e.error("Invalid XML: "+c);return d},noop:function(){},globalEval:function(b){b&&j.test(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(w,"ms-").replace(v,x)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toUpperCase()===b.toUpperCase()},each:function(a,c,d){var f,g=0,h=a.length,i=h===b||e.isFunction(a);if(d){if(i){for(f in a)if(c.apply(a[f],d)===!1)break}else for(;g<h;)if(c.apply(a[g++],d)===!1)break}else if(i){for(f in a)if(c.call(a[f],f,a[f])===!1)break}else for(;g<h;)if(c.call(a[g],g,a[g++])===!1)break;return a},trim:G?function(a){return a==null?"":G.call(a)}:function(a){return a==null?"":(a+"").replace(k,"").replace(l,"")},makeArray:function(a,b){var c=b||[];if(a!=null){var d=e.type(a);a.length==null||d==="string"||d==="function"||d==="regexp"||e.isWindow(a)?E.call(c,a):e.merge(c,a)}return c},inArray:function(a,b,c){var d;if(b){if(H)return H.call(b,a,c);d=b.length,c=c?c<0?Math.max(0,d+c):c:0;for(;c<d;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,c){var d=a.length,e=0;if(typeof c.length=="number")for(var f=c.length;e<f;e++)a[d++]=c[e];else while(c[e]!==b)a[d++]=c[e++];a.length=d;return a},grep:function(a,b,c){var d=[],e;c=!!c;for(var f=0,g=a.length;f<g;f++)e=!!b(a[f],f),c!==e&&d.push(a[f]);return d},map:function(a,c,d){var f,g,h=[],i=0,j=a.length,k=a instanceof e||j!==b&&typeof j=="number"&&(j>0&&a[0]&&a[j-1]||j===0||e.isArray(a));if(k)for(;i<j;i++)f=c(a[i],i,d),f!=null&&(h[h.length]=f);else for(g in a)f=c(a[g],g,d),f!=null&&(h[h.length]=f);return h.concat.apply([],h)},guid:1,proxy:function(a,c){if(typeof c=="string"){var d=a[c];c=a,a=d}if(!e.isFunction(a))return b;var f=F.call(arguments,2),g=function(){return a.apply(c,f.concat(F.call(arguments)))};g.guid=a.guid=a.guid||g.guid||e.guid++;return g},access:function(a,c,d,f,g,h,i){var j,k=d==null,l=0,m=a.length;if(d&&typeof d=="object"){for(l in d)e.access(a,c,l,d[l],1,h,f);g=1}else if(f!==b){j=i===b&&e.isFunction(f),k&&(j?(j=c,c=function(a,b,c){return j.call(e(a),c)}):(c.call(a,f),c=null));if(c)for(;l<m;l++)c(a[l],d,j?f.call(a[l],l,c(a[l],d)):f,i);g=1}return g?a:k?c.call(a):m?c(a[0],d):h},now:function(){return(new Date).getTime()},uaMatch:function(a){a=a.toLowerCase();var b=r.exec(a)||s.exec(a)||t.exec(a)||a.indexOf("compatible")<0&&u.exec(a)||[];return{browser:b[1]||"",version:b[2]||"0"}},sub:function(){function a(b,c){return new a.fn.init(b,c)}e.extend(!0,a,this),a.superclass=this,a.fn=a.prototype=this(),a.fn.constructor=a,a.sub=this.sub,a.fn.init=function(d,f){f&&f instanceof e&&!(f instanceof a)&&(f=a(f));return e.fn.init.call(this,d,f,b)},a.fn.init.prototype=a.fn;var b=a(c);return a},browser:{}}),e.each("Boolean Number String Function Array Date RegExp Object".split(" "),function(a,b){I["[object "+b+"]"]=b.toLowerCase()}),z=e.uaMatch(y),z.browser&&(e.browser[z.browser]=!0,e.browser.version=z.version),e.browser.webkit&&(e.browser.safari=!0),j.test(" ")&&(k=/^[\s\xA0]+/,l=/[\s\xA0]+$/),h=e(c),c.addEventListener?B=function(){c.removeEventListener("DOMContentLoaded",B,!1),e.ready()}:c.attachEvent&&(B=function(){c.readyState==="complete"&&(c.detachEvent("onreadystatechange",B),e.ready())});return e}(),g={};f.Callbacks=function(a){a=a?g[a]||h(a):{};var c=[],d=[],e,i,j,k,l,m,n=function(b){var d,e,g,h,i;for(d=0,e=b.length;d<e;d++)g=b[d],h=f.type(g),h==="array"?n(g):h==="function"&&(!a.unique||!p.has(g))&&c.push(g)},o=function(b,f){f=f||[],e=!a.memory||[b,f],i=!0,j=!0,m=k||0,k=0,l=c.length;for(;c&&m<l;m++)if(c[m].apply(b,f)===!1&&a.stopOnFalse){e=!0;break}j=!1,c&&(a.once?e===!0?p.disable():c=[]:d&&d.length&&(e=d.shift(),p.fireWith(e[0],e[1])))},p={add:function(){if(c){var a=c.length;n(arguments),j?l=c.length:e&&e!==!0&&(k=a,o(e[0],e[1]))}return this},remove:function(){if(c){var b=arguments,d=0,e=b.length;for(;d<e;d++)for(var f=0;f<c.length;f++)if(b[d]===c[f]){j&&f<=l&&(l--,f<=m&&m--),c.splice(f--,1);if(a.unique)break}}return this},has:function(a){if(c){var b=0,d=c.length;for(;b<d;b++)if(a===c[b])return!0}return!1},empty:function(){c=[];return this},disable:function(){c=d=e=b;return this},disabled:function(){return!c},lock:function(){d=b,(!e||e===!0)&&p.disable();return this},locked:function(){return!d},fireWith:function(b,c){d&&(j?a.once||d.push([b,c]):(!a.once||!e)&&o(b,c));return this},fire:function(){p.fireWith(this,arguments);return this},fired:function(){return!!i}};return p};var i=[].slice;f.extend({Deferred:function(a){var b=f.Callbacks("once memory"),c=f.Callbacks("once memory"),d=f.Callbacks("memory"),e="pending",g={resolve:b,reject:c,notify:d},h={done:b.add,fail:c.add,progress:d.add,state:function(){return e},isResolved:b.fired,isRejected:c.fired,then:function(a,b,c){i.done(a).fail(b).progress(c);return this},always:function(){i.done.apply(i,arguments).fail.apply(i,arguments);return this},pipe:function(a,b,c){return f.Deferred(function(d){f.each({done:[a,"resolve"],fail:[b,"reject"],progress:[c,"notify"]},function(a,b){var c=b[0],e=b[1],g;f.isFunction(c)?i[a](function(){g=c.apply(this,arguments),g&&f.isFunction(g.promise)?g.promise().then(d.resolve,d.reject,d.notify):d[e+"With"](this===i?d:this,[g])}):i[a](d[e])})}).promise()},promise:function(a){if(a==null)a=h;else for(var b in h)a[b]=h[b];return a}},i=h.promise({}),j;for(j in g)i[j]=g[j].fire,i[j+"With"]=g[j].fireWith;i.done(function(){e="resolved"},c.disable,d.lock).fail(function(){e="rejected"},b.disable,d.lock),a&&a.call(i,i);return i},when:function(a){function m(a){return function(b){e[a]=arguments.length>1?i.call(arguments,0):b,j.notifyWith(k,e)}}function l(a){return function(c){b[a]=arguments.length>1?i.call(arguments,0):c,--g||j.resolveWith(j,b)}}var b=i.call(arguments,0),c=0,d=b.length,e=Array(d),g=d,h=d,j=d<=1&&a&&f.isFunction(a.promise)?a:f.Deferred(),k=j.promise();if(d>1){for(;c<d;c++)b[c]&&b[c].promise&&f.isFunction(b[c].promise)?b[c].promise().then(l(c),j.reject,m(c)):--g;g||j.resolveWith(j,b)}else j!==a&&j.resolveWith(j,d?[a]:[]);return k}}),f.support=function(){var b,d,e,g,h,i,j,k,l,m,n,o,p=c.createElement("div"),q=c.documentElement;p.setAttribute("className","t"),p.innerHTML="   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>",d=p.getElementsByTagName("*"),e=p.getElementsByTagName("a")[0];if(!d||!d.length||!e)return{};g=c.createElement("select"),h=g.appendChild(c.createElement("option")),i=p.getElementsByTagName("input")[0],b={leadingWhitespace:p.firstChild.nodeType===3,tbody:!p.getElementsByTagName("tbody").length,htmlSerialize:!!p.getElementsByTagName("link").length,style:/top/.test(e.getAttribute("style")),hrefNormalized:e.getAttribute("href")==="/a",opacity:/^0.55/.test(e.style.opacity),cssFloat:!!e.style.cssFloat,checkOn:i.value==="on",optSelected:h.selected,getSetAttribute:p.className!=="t",enctype:!!c.createElement("form").enctype,html5Clone:c.createElement("nav").cloneNode(!0).outerHTML!=="<:nav></:nav>",submitBubbles:!0,changeBubbles:!0,focusinBubbles:!1,deleteExpando:!0,noCloneEvent:!0,inlineBlockNeedsLayout:!1,shrinkWrapBlocks:!1,reliableMarginRight:!0,pixelMargin:!0},f.boxModel=b.boxModel=c.compatMode==="CSS1Compat",i.checked=!0,b.noCloneChecked=i.cloneNode(!0).checked,g.disabled=!0,b.optDisabled=!h.disabled;try{delete p.test}catch(r){b.deleteExpando=!1}!p.addEventListener&&p.attachEvent&&p.fireEvent&&(p.attachEvent("onclick",function(){b.noCloneEvent=!1}),p.cloneNode(!0).fireEvent("onclick")),i=c.createElement("input"),i.value="t",i.setAttribute("type","radio"),b.radioValue=i.value==="t",i.setAttribute("checked","checked"),i.setAttribute("name","t"),p.appendChild(i),j=c.createDocumentFragment(),j.appendChild(p.lastChild),b.checkClone=j.cloneNode(!0).cloneNode(!0).lastChild.checked,b.appendChecked=i.checked,j.removeChild(i),j.appendChild(p);if(p.attachEvent)for(n in{submit:1,change:1,focusin:1})m="on"+n,o=m in p,o||(p.setAttribute(m,"return;"),o=typeof p[m]=="function"),b[n+"Bubbles"]=o;j.removeChild(p),j=g=h=p=i=null,f(function(){var d,e,g,h,i,j,l,m,n,q,r,s,t,u=c.getElementsByTagName("body")[0];!u||(m=1,t="padding:0;margin:0;border:",r="position:absolute;top:0;left:0;width:1px;height:1px;",s=t+"0;visibility:hidden;",n="style='"+r+t+"5px solid #000;",q="<div "+n+"display:block;'><div style='"+t+"0;display:block;overflow:hidden;'></div></div>"+"<table "+n+"' cellpadding='0' cellspacing='0'>"+"<tr><td></td></tr></table>",d=c.createElement("div"),d.style.cssText=s+"width:0;height:0;position:static;top:0;margin-top:"+m+"px",u.insertBefore(d,u.firstChild),p=c.createElement("div"),d.appendChild(p),p.innerHTML="<table><tr><td style='"+t+"0;display:none'></td><td>t</td></tr></table>",k=p.getElementsByTagName("td"),o=k[0].offsetHeight===0,k[0].style.display="",k[1].style.display="none",b.reliableHiddenOffsets=o&&k[0].offsetHeight===0,a.getComputedStyle&&(p.innerHTML="",l=c.createElement("div"),l.style.width="0",l.style.marginRight="0",p.style.width="2px",p.appendChild(l),b.reliableMarginRight=(parseInt((a.getComputedStyle(l,null)||{marginRight:0}).marginRight,10)||0)===0),typeof p.style.zoom!="undefined"&&(p.innerHTML="",p.style.width=p.style.padding="1px",p.style.border=0,p.style.overflow="hidden",p.style.display="inline",p.style.zoom=1,b.inlineBlockNeedsLayout=p.offsetWidth===3,p.style.display="block",p.style.overflow="visible",p.innerHTML="<div style='width:5px;'></div>",b.shrinkWrapBlocks=p.offsetWidth!==3),p.style.cssText=r+s,p.innerHTML=q,e=p.firstChild,g=e.firstChild,i=e.nextSibling.firstChild.firstChild,j={doesNotAddBorder:g.offsetTop!==5,doesAddBorderForTableAndCells:i.offsetTop===5},g.style.position="fixed",g.style.top="20px",j.fixedPosition=g.offsetTop===20||g.offsetTop===15,g.style.position=g.style.top="",e.style.overflow="hidden",e.style.position="relative",j.subtractsBorderForOverflowNotVisible=g.offsetTop===-5,j.doesNotIncludeMarginInBodyOffset=u.offsetTop!==m,a.getComputedStyle&&(p.style.marginTop="1%",b.pixelMargin=(a.getComputedStyle(p,null)||{marginTop:0}).marginTop!=="1%"),typeof d.style.zoom!="undefined"&&(d.style.zoom=1),u.removeChild(d),l=p=d=null,f.extend(b,j))});return b}();var j=/^(?:\{.*\}|\[.*\])$/,k=/([A-Z])/g;f.extend({cache:{},uuid:0,expando:"jQuery"+(f.fn.jquery+Math.random()).replace(/\D/g,""),noData:{embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:!0},hasData:function(a){a=a.nodeType?f.cache[a[f.expando]]:a[f.expando];return!!a&&!m(a)},data:function(a,c,d,e){if(!!f.acceptData(a)){var g,h,i,j=f.expando,k=typeof c=="string",l=a.nodeType,m=l?f.cache:a,n=l?a[j]:a[j]&&j,o=c==="events";if((!n||!m[n]||!o&&!e&&!m[n].data)&&k&&d===b)return;n||(l?a[j]=n=++f.uuid:n=j),m[n]||(m[n]={},l||(m[n].toJSON=f.noop));if(typeof c=="object"||typeof c=="function")e?m[n]=f.extend(m[n],c):m[n].data=f.extend(m[n].data,c);g=h=m[n],e||(h.data||(h.data={}),h=h.data),d!==b&&(h[f.camelCase(c)]=d);if(o&&!h[c])return g.events;k?(i=h[c],i==null&&(i=h[f.camelCase(c)])):i=h;return i}},removeData:function(a,b,c){if(!!f.acceptData(a)){var d,e,g,h=f.expando,i=a.nodeType,j=i?f.cache:a,k=i?a[h]:h;if(!j[k])return;if(b){d=c?j[k]:j[k].data;if(d){f.isArray(b)||(b in d?b=[b]:(b=f.camelCase(b),b in d?b=[b]:b=b.split(" ")));for(e=0,g=b.length;e<g;e++)delete d[b[e]];if(!(c?m:f.isEmptyObject)(d))return}}if(!c){delete j[k].data;if(!m(j[k]))return}f.support.deleteExpando||!j.setInterval?delete j[k]:j[k]=null,i&&(f.support.deleteExpando?delete a[h]:a.removeAttribute?a.removeAttribute(h):a[h]=null)}},_data:function(a,b,c){return f.data(a,b,c,!0)},acceptData:function(a){if(a.nodeName){var b=f.noData[a.nodeName.toLowerCase()];if(b)return b!==!0&&a.getAttribute("classid")===b}return!0}}),f.fn.extend({data:function(a,c){var d,e,g,h,i,j=this[0],k=0,m=null;if(a===b){if(this.length){m=f.data(j);if(j.nodeType===1&&!f._data(j,"parsedAttrs")){g=j.attributes;for(i=g.length;k<i;k++)h=g[k].name,h.indexOf("data-")===0&&(h=f.camelCase(h.substring(5)),l(j,h,m[h]));f._data(j,"parsedAttrs",!0)}}return m}if(typeof a=="object")return this.each(function(){f.data(this,a)});d=a.split(".",2),d[1]=d[1]?"."+d[1]:"",e=d[1]+"!";return f.access(this,function(c){if(c===b){m=this.triggerHandler("getData"+e,[d[0]]),m===b&&j&&(m=f.data(j,a),m=l(j,a,m));return m===b&&d[1]?this.data(d[0]):m}d[1]=c,this.each(function(){var b=f(this);b.triggerHandler("setData"+e,d),f.data(this,a,c),b.triggerHandler("changeData"+e,d)})},null,c,arguments.length>1,null,!1)},removeData:function(a){return this.each(function(){f.removeData(this,a)})}}),f.extend({_mark:function(a,b){a&&(b=(b||"fx")+"mark",f._data(a,b,(f._data(a,b)||0)+1))},_unmark:function(a,b,c){a!==!0&&(c=b,b=a,a=!1);if(b){c=c||"fx";var d=c+"mark",e=a?0:(f._data(b,d)||1)-1;e?f._data(b,d,e):(f.removeData(b,d,!0),n(b,c,"mark"))}},queue:function(a,b,c){var d;if(a){b=(b||"fx")+"queue",d=f._data(a,b),c&&(!d||f.isArray(c)?d=f._data(a,b,f.makeArray(c)):d.push(c));return d||[]}},dequeue:function(a,b){b=b||"fx";var c=f.queue(a,b),d=c.shift(),e={};d==="inprogress"&&(d=c.shift()),d&&(b==="fx"&&c.unshift("inprogress"),f._data(a,b+".run",e),d.call(a,function(){f.dequeue(a,b)},e)),c.length||(f.removeData(a,b+"queue "+b+".run",!0),n(a,b,"queue"))}}),f.fn.extend({queue:function(a,c){var d=2;typeof a!="string"&&(c=a,a="fx",d--);if(arguments.length<d)return f.queue(this[0],a);return c===b?this:this.each(function(){var b=f.queue(this,a,c);a==="fx"&&b[0]!=="inprogress"&&f.dequeue(this,a)})},dequeue:function(a){return this.each(function(){f.dequeue(this,a)})},delay:function(a,b){a=f.fx?f.fx.speeds[a]||a:a,b=b||"fx";return this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,c){function m(){--h||d.resolveWith(e,[e])}typeof a!="string"&&(c=a,a=b),a=a||"fx";var d=f.Deferred(),e=this,g=e.length,h=1,i=a+"defer",j=a+"queue",k=a+"mark",l;while(g--)if(l=f.data(e[g],i,b,!0)||(f.data(e[g],j,b,!0)||f.data(e[g],k,b,!0))&&f.data(e[g],i,f.Callbacks("once memory"),!0))h++,l.add(m);m();return d.promise(c)}});var o=/[\n\t\r]/g,p=/\s+/,q=/\r/g,r=/^(?:button|input)$/i,s=/^(?:button|input|object|select|textarea)$/i,t=/^a(?:rea)?$/i,u=/^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,v=f.support.getSetAttribute,w,x,y;f.fn.extend({attr:function(a,b){return f.access(this,f.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){f.removeAttr(this,a)})},prop:function(a,b){return f.access(this,f.prop,a,b,arguments.length>1)},removeProp:function(a){a=f.propFix[a]||a;return this.each(function(){try{this[a]=b,delete this[a]}catch(c){}})},addClass:function(a){var b,c,d,e,g,h,i;if(f.isFunction(a))return this.each(function(b){f(this).addClass(a.call(this,b,this.className))});if(a&&typeof a=="string"){b=a.split(p);for(c=0,d=this.length;c<d;c++){e=this[c];if(e.nodeType===1)if(!e.className&&b.length===1)e.className=a;else{g=" "+e.className+" ";for(h=0,i=b.length;h<i;h++)~g.indexOf(" "+b[h]+" ")||(g+=b[h]+" ");e.className=f.trim(g)}}}return this},removeClass:function(a){var c,d,e,g,h,i,j;if(f.isFunction(a))return this.each(function(b){f(this).removeClass(a.call(this,b,this.className))});if(a&&typeof a=="string"||a===b){c=(a||"").split(p);for(d=0,e=this.length;d<e;d++){g=this[d];if(g.nodeType===1&&g.className)if(a){h=(" "+g.className+" ").replace(o," ");for(i=0,j=c.length;i<j;i++)h=h.replace(" "+c[i]+" "," ");g.className=f.trim(h)}else g.className=""}}return this},toggleClass:function(a,b){var c=typeof a,d=typeof b=="boolean";if(f.isFunction(a))return this.each(function(c){f(this).toggleClass(a.call(this,c,this.className,b),b)});return this.each(function(){if(c==="string"){var e,g=0,h=f(this),i=b,j=a.split(p);while(e=j[g++])i=d?i:!h.hasClass(e),h[i?"addClass":"removeClass"](e)}else if(c==="undefined"||c==="boolean")this.className&&f._data(this,"__className__",this.className),this.className=this.className||a===!1?"":f._data(this,"__className__")||""})},hasClass:function(a){var b=" "+a+" ",c=0,d=this.length;for(;c<d;c++)if(this[c].nodeType===1&&(" "+this[c].className+" ").replace(o," ").indexOf(b)>-1)return!0;return!1},val:function(a){var c,d,e,g=this[0];{if(!!arguments.length){e=f.isFunction(a);return this.each(function(d){var g=f(this),h;if(this.nodeType===1){e?h=a.call(this,d,g.val()):h=a,h==null?h="":typeof h=="number"?h+="":f.isArray(h)&&(h=f.map(h,function(a){return a==null?"":a+""})),c=f.valHooks[this.type]||f.valHooks[this.nodeName.toLowerCase()];if(!c||!("set"in c)||c.set(this,h,"value")===b)this.value=h}})}if(g){c=f.valHooks[g.type]||f.valHooks[g.nodeName.toLowerCase()];if(c&&"get"in c&&(d=c.get(g,"value"))!==b)return d;d=g.value;return typeof d=="string"?d.replace(q,""):d==null?"":d}}}}),f.extend({valHooks:{option:{get:function(a){var b=a.attributes.value;return!b||b.specified?a.value:a.text}},select:{get:function(a){var b,c,d,e,g=a.selectedIndex,h=[],i=a.options,j=a.type==="select-one";if(g<0)return null;c=j?g:0,d=j?g+1:i.length;for(;c<d;c++){e=i[c];if(e.selected&&(f.support.optDisabled?!e.disabled:e.getAttribute("disabled")===null)&&(!e.parentNode.disabled||!f.nodeName(e.parentNode,"optgroup"))){b=f(e).val();if(j)return b;h.push(b)}}if(j&&!h.length&&i.length)return f(i[g]).val();return h},set:function(a,b){var c=f.makeArray(b);f(a).find("option").each(function(){this.selected=f.inArray(f(this).val(),c)>=0}),c.length||(a.selectedIndex=-1);return c}}},attrFn:{val:!0,css:!0,html:!0,text:!0,data:!0,width:!0,height:!0,offset:!0},attr:function(a,c,d,e){var g,h,i,j=a.nodeType;if(!!a&&j!==3&&j!==8&&j!==2){if(e&&c in f.attrFn)return f(a)[c](d);if(typeof a.getAttribute=="undefined")return f.prop(a,c,d);i=j!==1||!f.isXMLDoc(a),i&&(c=c.toLowerCase(),h=f.attrHooks[c]||(u.test(c)?x:w));if(d!==b){if(d===null){f.removeAttr(a,c);return}if(h&&"set"in h&&i&&(g=h.set(a,d,c))!==b)return g;a.setAttribute(c,""+d);return d}if(h&&"get"in h&&i&&(g=h.get(a,c))!==null)return g;g=a.getAttribute(c);return g===null?b:g}},removeAttr:function(a,b){var c,d,e,g,h,i=0;if(b&&a.nodeType===1){d=b.toLowerCase().split(p),g=d.length;for(;i<g;i++)e=d[i],e&&(c=f.propFix[e]||e,h=u.test(e),h||f.attr(a,e,""),a.removeAttribute(v?e:c),h&&c in a&&(a[c]=!1))}},attrHooks:{type:{set:function(a,b){if(r.test(a.nodeName)&&a.parentNode)f.error("type property can't be changed");else if(!f.support.radioValue&&b==="radio"&&f.nodeName(a,"input")){var c=a.value;a.setAttribute("type",b),c&&(a.value=c);return b}}},value:{get:function(a,b){if(w&&f.nodeName(a,"button"))return w.get(a,b);return b in a?a.value:null},set:function(a,b,c){if(w&&f.nodeName(a,"button"))return w.set(a,b,c);a.value=b}}},propFix:{tabindex:"tabIndex",readonly:"readOnly","for":"htmlFor","class":"className",maxlength:"maxLength",cellspacing:"cellSpacing",cellpadding:"cellPadding",rowspan:"rowSpan",colspan:"colSpan",usemap:"useMap",frameborder:"frameBorder",contenteditable:"contentEditable"},prop:function(a,c,d){var e,g,h,i=a.nodeType;if(!!a&&i!==3&&i!==8&&i!==2){h=i!==1||!f.isXMLDoc(a),h&&(c=f.propFix[c]||c,g=f.propHooks[c]);return d!==b?g&&"set"in g&&(e=g.set(a,d,c))!==b?e:a[c]=d:g&&"get"in g&&(e=g.get(a,c))!==null?e:a[c]}},propHooks:{tabIndex:{get:function(a){var c=a.getAttributeNode("tabindex");return c&&c.specified?parseInt(c.value,10):s.test(a.nodeName)||t.test(a.nodeName)&&a.href?0:b}}}}),f.attrHooks.tabindex=f.propHooks.tabIndex,x={get:function(a,c){var d,e=f.prop(a,c);return e===!0||typeof e!="boolean"&&(d=a.getAttributeNode(c))&&d.nodeValue!==!1?c.toLowerCase():b},set:function(a,b,c){var d;b===!1?f.removeAttr(a,c):(d=f.propFix[c]||c,d in a&&(a[d]=!0),a.setAttribute(c,c.toLowerCase()));return c}},v||(y={name:!0,id:!0,coords:!0},w=f.valHooks.button={get:function(a,c){var d;d=a.getAttributeNode(c);return d&&(y[c]?d.nodeValue!=="":d.specified)?d.nodeValue:b},set:function(a,b,d){var e=a.getAttributeNode(d);e||(e=c.createAttribute(d),a.setAttributeNode(e));return e.nodeValue=b+""}},f.attrHooks.tabindex.set=w.set,f.each(["width","height"],function(a,b){f.attrHooks[b]=f.extend(f.attrHooks[b],{set:function(a,c){if(c===""){a.setAttribute(b,"auto");return c}}})}),f.attrHooks.contenteditable={get:w.get,set:function(a,b,c){b===""&&(b="false"),w.set(a,b,c)}}),f.support.hrefNormalized||f.each(["href","src","width","height"],function(a,c){f.attrHooks[c]=f.extend(f.attrHooks[c],{get:function(a){var d=a.getAttribute(c,2);return d===null?b:d}})}),f.support.style||(f.attrHooks.style={get:function(a){return a.style.cssText.toLowerCase()||b},set:function(a,b){return a.style.cssText=""+b}}),f.support.optSelected||(f.propHooks.selected=f.extend(f.propHooks.selected,{get:function(a){var b=a.parentNode;b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex);return null}})),f.support.enctype||(f.propFix.enctype="encoding"),f.support.checkOn||f.each(["radio","checkbox"],function(){f.valHooks[this]={get:function(a){return a.getAttribute("value")===null?"on":a.value}}}),f.each(["radio","checkbox"],function(){f.valHooks[this]=f.extend(f.valHooks[this],{set:function(a,b){if(f.isArray(b))return a.checked=f.inArray(f(a).val(),b)>=0}})});var z=/^(?:textarea|input|select)$/i,A=/^([^\.]*)?(?:\.(.+))?$/,B=/(?:^|\s)hover(\.\S+)?\b/,C=/^key/,D=/^(?:mouse|contextmenu)|click/,E=/^(?:focusinfocus|focusoutblur)$/,F=/^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,G=function(
a){var b=F.exec(a);b&&(b[1]=(b[1]||"").toLowerCase(),b[3]=b[3]&&new RegExp("(?:^|\\s)"+b[3]+"(?:\\s|$)"));return b},H=function(a,b){var c=a.attributes||{};return(!b[1]||a.nodeName.toLowerCase()===b[1])&&(!b[2]||(c.id||{}).value===b[2])&&(!b[3]||b[3].test((c["class"]||{}).value))},I=function(a){return f.event.special.hover?a:a.replace(B,"mouseenter$1 mouseleave$1")};f.event={add:function(a,c,d,e,g){var h,i,j,k,l,m,n,o,p,q,r,s;if(!(a.nodeType===3||a.nodeType===8||!c||!d||!(h=f._data(a)))){d.handler&&(p=d,d=p.handler,g=p.selector),d.guid||(d.guid=f.guid++),j=h.events,j||(h.events=j={}),i=h.handle,i||(h.handle=i=function(a){return typeof f!="undefined"&&(!a||f.event.triggered!==a.type)?f.event.dispatch.apply(i.elem,arguments):b},i.elem=a),c=f.trim(I(c)).split(" ");for(k=0;k<c.length;k++){l=A.exec(c[k])||[],m=l[1],n=(l[2]||"").split(".").sort(),s=f.event.special[m]||{},m=(g?s.delegateType:s.bindType)||m,s=f.event.special[m]||{},o=f.extend({type:m,origType:l[1],data:e,handler:d,guid:d.guid,selector:g,quick:g&&G(g),namespace:n.join(".")},p),r=j[m];if(!r){r=j[m]=[],r.delegateCount=0;if(!s.setup||s.setup.call(a,e,n,i)===!1)a.addEventListener?a.addEventListener(m,i,!1):a.attachEvent&&a.attachEvent("on"+m,i)}s.add&&(s.add.call(a,o),o.handler.guid||(o.handler.guid=d.guid)),g?r.splice(r.delegateCount++,0,o):r.push(o),f.event.global[m]=!0}a=null}},global:{},remove:function(a,b,c,d,e){var g=f.hasData(a)&&f._data(a),h,i,j,k,l,m,n,o,p,q,r,s;if(!!g&&!!(o=g.events)){b=f.trim(I(b||"")).split(" ");for(h=0;h<b.length;h++){i=A.exec(b[h])||[],j=k=i[1],l=i[2];if(!j){for(j in o)f.event.remove(a,j+b[h],c,d,!0);continue}p=f.event.special[j]||{},j=(d?p.delegateType:p.bindType)||j,r=o[j]||[],m=r.length,l=l?new RegExp("(^|\\.)"+l.split(".").sort().join("\\.(?:.*\\.)?")+"(\\.|$)"):null;for(n=0;n<r.length;n++)s=r[n],(e||k===s.origType)&&(!c||c.guid===s.guid)&&(!l||l.test(s.namespace))&&(!d||d===s.selector||d==="**"&&s.selector)&&(r.splice(n--,1),s.selector&&r.delegateCount--,p.remove&&p.remove.call(a,s));r.length===0&&m!==r.length&&((!p.teardown||p.teardown.call(a,l)===!1)&&f.removeEvent(a,j,g.handle),delete o[j])}f.isEmptyObject(o)&&(q=g.handle,q&&(q.elem=null),f.removeData(a,["events","handle"],!0))}},customEvent:{getData:!0,setData:!0,changeData:!0},trigger:function(c,d,e,g){if(!e||e.nodeType!==3&&e.nodeType!==8){var h=c.type||c,i=[],j,k,l,m,n,o,p,q,r,s;if(E.test(h+f.event.triggered))return;h.indexOf("!")>=0&&(h=h.slice(0,-1),k=!0),h.indexOf(".")>=0&&(i=h.split("."),h=i.shift(),i.sort());if((!e||f.event.customEvent[h])&&!f.event.global[h])return;c=typeof c=="object"?c[f.expando]?c:new f.Event(h,c):new f.Event(h),c.type=h,c.isTrigger=!0,c.exclusive=k,c.namespace=i.join("."),c.namespace_re=c.namespace?new RegExp("(^|\\.)"+i.join("\\.(?:.*\\.)?")+"(\\.|$)"):null,o=h.indexOf(":")<0?"on"+h:"";if(!e){j=f.cache;for(l in j)j[l].events&&j[l].events[h]&&f.event.trigger(c,d,j[l].handle.elem,!0);return}c.result=b,c.target||(c.target=e),d=d!=null?f.makeArray(d):[],d.unshift(c),p=f.event.special[h]||{};if(p.trigger&&p.trigger.apply(e,d)===!1)return;r=[[e,p.bindType||h]];if(!g&&!p.noBubble&&!f.isWindow(e)){s=p.delegateType||h,m=E.test(s+h)?e:e.parentNode,n=null;for(;m;m=m.parentNode)r.push([m,s]),n=m;n&&n===e.ownerDocument&&r.push([n.defaultView||n.parentWindow||a,s])}for(l=0;l<r.length&&!c.isPropagationStopped();l++)m=r[l][0],c.type=r[l][1],q=(f._data(m,"events")||{})[c.type]&&f._data(m,"handle"),q&&q.apply(m,d),q=o&&m[o],q&&f.acceptData(m)&&q.apply(m,d)===!1&&c.preventDefault();c.type=h,!g&&!c.isDefaultPrevented()&&(!p._default||p._default.apply(e.ownerDocument,d)===!1)&&(h!=="click"||!f.nodeName(e,"a"))&&f.acceptData(e)&&o&&e[h]&&(h!=="focus"&&h!=="blur"||c.target.offsetWidth!==0)&&!f.isWindow(e)&&(n=e[o],n&&(e[o]=null),f.event.triggered=h,e[h](),f.event.triggered=b,n&&(e[o]=n));return c.result}},dispatch:function(c){c=f.event.fix(c||a.event);var d=(f._data(this,"events")||{})[c.type]||[],e=d.delegateCount,g=[].slice.call(arguments,0),h=!c.exclusive&&!c.namespace,i=f.event.special[c.type]||{},j=[],k,l,m,n,o,p,q,r,s,t,u;g[0]=c,c.delegateTarget=this;if(!i.preDispatch||i.preDispatch.call(this,c)!==!1){if(e&&(!c.button||c.type!=="click")){n=f(this),n.context=this.ownerDocument||this;for(m=c.target;m!=this;m=m.parentNode||this)if(m.disabled!==!0){p={},r=[],n[0]=m;for(k=0;k<e;k++)s=d[k],t=s.selector,p[t]===b&&(p[t]=s.quick?H(m,s.quick):n.is(t)),p[t]&&r.push(s);r.length&&j.push({elem:m,matches:r})}}d.length>e&&j.push({elem:this,matches:d.slice(e)});for(k=0;k<j.length&&!c.isPropagationStopped();k++){q=j[k],c.currentTarget=q.elem;for(l=0;l<q.matches.length&&!c.isImmediatePropagationStopped();l++){s=q.matches[l];if(h||!c.namespace&&!s.namespace||c.namespace_re&&c.namespace_re.test(s.namespace))c.data=s.data,c.handleObj=s,o=((f.event.special[s.origType]||{}).handle||s.handler).apply(q.elem,g),o!==b&&(c.result=o,o===!1&&(c.preventDefault(),c.stopPropagation()))}}i.postDispatch&&i.postDispatch.call(this,c);return c.result}},props:"attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){a.which==null&&(a.which=b.charCode!=null?b.charCode:b.keyCode);return a}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,d){var e,f,g,h=d.button,i=d.fromElement;a.pageX==null&&d.clientX!=null&&(e=a.target.ownerDocument||c,f=e.documentElement,g=e.body,a.pageX=d.clientX+(f&&f.scrollLeft||g&&g.scrollLeft||0)-(f&&f.clientLeft||g&&g.clientLeft||0),a.pageY=d.clientY+(f&&f.scrollTop||g&&g.scrollTop||0)-(f&&f.clientTop||g&&g.clientTop||0)),!a.relatedTarget&&i&&(a.relatedTarget=i===a.target?d.toElement:i),!a.which&&h!==b&&(a.which=h&1?1:h&2?3:h&4?2:0);return a}},fix:function(a){if(a[f.expando])return a;var d,e,g=a,h=f.event.fixHooks[a.type]||{},i=h.props?this.props.concat(h.props):this.props;a=f.Event(g);for(d=i.length;d;)e=i[--d],a[e]=g[e];a.target||(a.target=g.srcElement||c),a.target.nodeType===3&&(a.target=a.target.parentNode),a.metaKey===b&&(a.metaKey=a.ctrlKey);return h.filter?h.filter(a,g):a},special:{ready:{setup:f.bindReady},load:{noBubble:!0},focus:{delegateType:"focusin"},blur:{delegateType:"focusout"},beforeunload:{setup:function(a,b,c){f.isWindow(this)&&(this.onbeforeunload=c)},teardown:function(a,b){this.onbeforeunload===b&&(this.onbeforeunload=null)}}},simulate:function(a,b,c,d){var e=f.extend(new f.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?f.event.trigger(e,null,b):f.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},f.event.handle=f.event.dispatch,f.removeEvent=c.removeEventListener?function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)}:function(a,b,c){a.detachEvent&&a.detachEvent("on"+b,c)},f.Event=function(a,b){if(!(this instanceof f.Event))return new f.Event(a,b);a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||a.returnValue===!1||a.getPreventDefault&&a.getPreventDefault()?K:J):this.type=a,b&&f.extend(this,b),this.timeStamp=a&&a.timeStamp||f.now(),this[f.expando]=!0},f.Event.prototype={preventDefault:function(){this.isDefaultPrevented=K;var a=this.originalEvent;!a||(a.preventDefault?a.preventDefault():a.returnValue=!1)},stopPropagation:function(){this.isPropagationStopped=K;var a=this.originalEvent;!a||(a.stopPropagation&&a.stopPropagation(),a.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=K,this.stopPropagation()},isDefaultPrevented:J,isPropagationStopped:J,isImmediatePropagationStopped:J},f.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(a,b){f.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c=this,d=a.relatedTarget,e=a.handleObj,g=e.selector,h;if(!d||d!==c&&!f.contains(c,d))a.type=e.origType,h=e.handler.apply(this,arguments),a.type=b;return h}}}),f.support.submitBubbles||(f.event.special.submit={setup:function(){if(f.nodeName(this,"form"))return!1;f.event.add(this,"click._submit keypress._submit",function(a){var c=a.target,d=f.nodeName(c,"input")||f.nodeName(c,"button")?c.form:b;d&&!d._submit_attached&&(f.event.add(d,"submit._submit",function(a){a._submit_bubble=!0}),d._submit_attached=!0)})},postDispatch:function(a){a._submit_bubble&&(delete a._submit_bubble,this.parentNode&&!a.isTrigger&&f.event.simulate("submit",this.parentNode,a,!0))},teardown:function(){if(f.nodeName(this,"form"))return!1;f.event.remove(this,"._submit")}}),f.support.changeBubbles||(f.event.special.change={setup:function(){if(z.test(this.nodeName)){if(this.type==="checkbox"||this.type==="radio")f.event.add(this,"propertychange._change",function(a){a.originalEvent.propertyName==="checked"&&(this._just_changed=!0)}),f.event.add(this,"click._change",function(a){this._just_changed&&!a.isTrigger&&(this._just_changed=!1,f.event.simulate("change",this,a,!0))});return!1}f.event.add(this,"beforeactivate._change",function(a){var b=a.target;z.test(b.nodeName)&&!b._change_attached&&(f.event.add(b,"change._change",function(a){this.parentNode&&!a.isSimulated&&!a.isTrigger&&f.event.simulate("change",this.parentNode,a,!0)}),b._change_attached=!0)})},handle:function(a){var b=a.target;if(this!==b||a.isSimulated||a.isTrigger||b.type!=="radio"&&b.type!=="checkbox")return a.handleObj.handler.apply(this,arguments)},teardown:function(){f.event.remove(this,"._change");return z.test(this.nodeName)}}),f.support.focusinBubbles||f.each({focus:"focusin",blur:"focusout"},function(a,b){var d=0,e=function(a){f.event.simulate(b,a.target,f.event.fix(a),!0)};f.event.special[b]={setup:function(){d++===0&&c.addEventListener(a,e,!0)},teardown:function(){--d===0&&c.removeEventListener(a,e,!0)}}}),f.fn.extend({on:function(a,c,d,e,g){var h,i;if(typeof a=="object"){typeof c!="string"&&(d=d||c,c=b);for(i in a)this.on(i,c,d,a[i],g);return this}d==null&&e==null?(e=c,d=c=b):e==null&&(typeof c=="string"?(e=d,d=b):(e=d,d=c,c=b));if(e===!1)e=J;else if(!e)return this;g===1&&(h=e,e=function(a){f().off(a);return h.apply(this,arguments)},e.guid=h.guid||(h.guid=f.guid++));return this.each(function(){f.event.add(this,a,e,d,c)})},one:function(a,b,c,d){return this.on(a,b,c,d,1)},off:function(a,c,d){if(a&&a.preventDefault&&a.handleObj){var e=a.handleObj;f(a.delegateTarget).off(e.namespace?e.origType+"."+e.namespace:e.origType,e.selector,e.handler);return this}if(typeof a=="object"){for(var g in a)this.off(g,c,a[g]);return this}if(c===!1||typeof c=="function")d=c,c=b;d===!1&&(d=J);return this.each(function(){f.event.remove(this,a,d,c)})},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},live:function(a,b,c){f(this.context).on(a,this.selector,b,c);return this},die:function(a,b){f(this.context).off(a,this.selector||"**",b);return this},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return arguments.length==1?this.off(a,"**"):this.off(b,a,c)},trigger:function(a,b){return this.each(function(){f.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0])return f.event.trigger(a,b,this[0],!0)},toggle:function(a){var b=arguments,c=a.guid||f.guid++,d=0,e=function(c){var e=(f._data(this,"lastToggle"+a.guid)||0)%d;f._data(this,"lastToggle"+a.guid,e+1),c.preventDefault();return b[e].apply(this,arguments)||!1};e.guid=c;while(d<b.length)b[d++].guid=c;return this.click(e)},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}}),f.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){f.fn[b]=function(a,c){c==null&&(c=a,a=null);return arguments.length>0?this.on(b,null,a,c):this.trigger(b)},f.attrFn&&(f.attrFn[b]=!0),C.test(b)&&(f.event.fixHooks[b]=f.event.keyHooks),D.test(b)&&(f.event.fixHooks[b]=f.event.mouseHooks)}),function(){function x(a,b,c,e,f,g){for(var h=0,i=e.length;h<i;h++){var j=e[h];if(j){var k=!1;j=j[a];while(j){if(j[d]===c){k=e[j.sizset];break}if(j.nodeType===1){g||(j[d]=c,j.sizset=h);if(typeof b!="string"){if(j===b){k=!0;break}}else if(m.filter(b,[j]).length>0){k=j;break}}j=j[a]}e[h]=k}}}function w(a,b,c,e,f,g){for(var h=0,i=e.length;h<i;h++){var j=e[h];if(j){var k=!1;j=j[a];while(j){if(j[d]===c){k=e[j.sizset];break}j.nodeType===1&&!g&&(j[d]=c,j.sizset=h);if(j.nodeName.toLowerCase()===b){k=j;break}j=j[a]}e[h]=k}}}var a=/((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,d="sizcache"+(Math.random()+"").replace(".",""),e=0,g=Object.prototype.toString,h=!1,i=!0,j=/\\/g,k=/\r\n/g,l=/\W/;[0,0].sort(function(){i=!1;return 0});var m=function(b,d,e,f){e=e||[],d=d||c;var h=d;if(d.nodeType!==1&&d.nodeType!==9)return[];if(!b||typeof b!="string")return e;var i,j,k,l,n,q,r,t,u=!0,v=m.isXML(d),w=[],x=b;do{a.exec(""),i=a.exec(x);if(i){x=i[3],w.push(i[1]);if(i[2]){l=i[3];break}}}while(i);if(w.length>1&&p.exec(b))if(w.length===2&&o.relative[w[0]])j=y(w[0]+w[1],d,f);else{j=o.relative[w[0]]?[d]:m(w.shift(),d);while(w.length)b=w.shift(),o.relative[b]&&(b+=w.shift()),j=y(b,j,f)}else{!f&&w.length>1&&d.nodeType===9&&!v&&o.match.ID.test(w[0])&&!o.match.ID.test(w[w.length-1])&&(n=m.find(w.shift(),d,v),d=n.expr?m.filter(n.expr,n.set)[0]:n.set[0]);if(d){n=f?{expr:w.pop(),set:s(f)}:m.find(w.pop(),w.length===1&&(w[0]==="~"||w[0]==="+")&&d.parentNode?d.parentNode:d,v),j=n.expr?m.filter(n.expr,n.set):n.set,w.length>0?k=s(j):u=!1;while(w.length)q=w.pop(),r=q,o.relative[q]?r=w.pop():q="",r==null&&(r=d),o.relative[q](k,r,v)}else k=w=[]}k||(k=j),k||m.error(q||b);if(g.call(k)==="[object Array]")if(!u)e.push.apply(e,k);else if(d&&d.nodeType===1)for(t=0;k[t]!=null;t++)k[t]&&(k[t]===!0||k[t].nodeType===1&&m.contains(d,k[t]))&&e.push(j[t]);else for(t=0;k[t]!=null;t++)k[t]&&k[t].nodeType===1&&e.push(j[t]);else s(k,e);l&&(m(l,h,e,f),m.uniqueSort(e));return e};m.uniqueSort=function(a){if(u){h=i,a.sort(u);if(h)for(var b=1;b<a.length;b++)a[b]===a[b-1]&&a.splice(b--,1)}return a},m.matches=function(a,b){return m(a,null,null,b)},m.matchesSelector=function(a,b){return m(b,null,null,[a]).length>0},m.find=function(a,b,c){var d,e,f,g,h,i;if(!a)return[];for(e=0,f=o.order.length;e<f;e++){h=o.order[e];if(g=o.leftMatch[h].exec(a)){i=g[1],g.splice(1,1);if(i.substr(i.length-1)!=="\\"){g[1]=(g[1]||"").replace(j,""),d=o.find[h](g,b,c);if(d!=null){a=a.replace(o.match[h],"");break}}}}d||(d=typeof b.getElementsByTagName!="undefined"?b.getElementsByTagName("*"):[]);return{set:d,expr:a}},m.filter=function(a,c,d,e){var f,g,h,i,j,k,l,n,p,q=a,r=[],s=c,t=c&&c[0]&&m.isXML(c[0]);while(a&&c.length){for(h in o.filter)if((f=o.leftMatch[h].exec(a))!=null&&f[2]){k=o.filter[h],l=f[1],g=!1,f.splice(1,1);if(l.substr(l.length-1)==="\\")continue;s===r&&(r=[]);if(o.preFilter[h]){f=o.preFilter[h](f,s,d,r,e,t);if(!f)g=i=!0;else if(f===!0)continue}if(f)for(n=0;(j=s[n])!=null;n++)j&&(i=k(j,f,n,s),p=e^i,d&&i!=null?p?g=!0:s[n]=!1:p&&(r.push(j),g=!0));if(i!==b){d||(s=r),a=a.replace(o.match[h],"");if(!g)return[];break}}if(a===q)if(g==null)m.error(a);else break;q=a}return s},m.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)};var n=m.getText=function(a){var b,c,d=a.nodeType,e="";if(d){if(d===1||d===9||d===11){if(typeof a.textContent=="string")return a.textContent;if(typeof a.innerText=="string")return a.innerText.replace(k,"");for(a=a.firstChild;a;a=a.nextSibling)e+=n(a)}else if(d===3||d===4)return a.nodeValue}else for(b=0;c=a[b];b++)c.nodeType!==8&&(e+=n(c));return e},o=m.selectors={order:["ID","NAME","TAG"],match:{ID:/#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,CLASS:/\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,NAME:/\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,ATTR:/\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,TAG:/^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,CHILD:/:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,POS:/:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,PSEUDO:/:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/},leftMatch:{},attrMap:{"class":"className","for":"htmlFor"},attrHandle:{href:function(a){return a.getAttribute("href")},type:function(a){return a.getAttribute("type")}},relative:{"+":function(a,b){var c=typeof b=="string",d=c&&!l.test(b),e=c&&!d;d&&(b=b.toLowerCase());for(var f=0,g=a.length,h;f<g;f++)if(h=a[f]){while((h=h.previousSibling)&&h.nodeType!==1);a[f]=e||h&&h.nodeName.toLowerCase()===b?h||!1:h===b}e&&m.filter(b,a,!0)},">":function(a,b){var c,d=typeof b=="string",e=0,f=a.length;if(d&&!l.test(b)){b=b.toLowerCase();for(;e<f;e++){c=a[e];if(c){var g=c.parentNode;a[e]=g.nodeName.toLowerCase()===b?g:!1}}}else{for(;e<f;e++)c=a[e],c&&(a[e]=d?c.parentNode:c.parentNode===b);d&&m.filter(b,a,!0)}},"":function(a,b,c){var d,f=e++,g=x;typeof b=="string"&&!l.test(b)&&(b=b.toLowerCase(),d=b,g=w),g("parentNode",b,f,a,d,c)},"~":function(a,b,c){var d,f=e++,g=x;typeof b=="string"&&!l.test(b)&&(b=b.toLowerCase(),d=b,g=w),g("previousSibling",b,f,a,d,c)}},find:{ID:function(a,b,c){if(typeof b.getElementById!="undefined"&&!c){var d=b.getElementById(a[1]);return d&&d.parentNode?[d]:[]}},NAME:function(a,b){if(typeof b.getElementsByName!="undefined"){var c=[],d=b.getElementsByName(a[1]);for(var e=0,f=d.length;e<f;e++)d[e].getAttribute("name")===a[1]&&c.push(d[e]);return c.length===0?null:c}},TAG:function(a,b){if(typeof b.getElementsByTagName!="undefined")return b.getElementsByTagName(a[1])}},preFilter:{CLASS:function(a,b,c,d,e,f){a=" "+a[1].replace(j,"")+" ";if(f)return a;for(var g=0,h;(h=b[g])!=null;g++)h&&(e^(h.className&&(" "+h.className+" ").replace(/[\t\n\r]/g," ").indexOf(a)>=0)?c||d.push(h):c&&(b[g]=!1));return!1},ID:function(a){return a[1].replace(j,"")},TAG:function(a,b){return a[1].replace(j,"").toLowerCase()},CHILD:function(a){if(a[1]==="nth"){a[2]||m.error(a[0]),a[2]=a[2].replace(/^\+|\s*/g,"");var b=/(-?)(\d*)(?:n([+\-]?\d*))?/.exec(a[2]==="even"&&"2n"||a[2]==="odd"&&"2n+1"||!/\D/.test(a[2])&&"0n+"+a[2]||a[2]);a[2]=b[1]+(b[2]||1)-0,a[3]=b[3]-0}else a[2]&&m.error(a[0]);a[0]=e++;return a},ATTR:function(a,b,c,d,e,f){var g=a[1]=a[1].replace(j,"");!f&&o.attrMap[g]&&(a[1]=o.attrMap[g]),a[4]=(a[4]||a[5]||"").replace(j,""),a[2]==="~="&&(a[4]=" "+a[4]+" ");return a},PSEUDO:function(b,c,d,e,f){if(b[1]==="not")if((a.exec(b[3])||"").length>1||/^\w/.test(b[3]))b[3]=m(b[3],null,null,c);else{var g=m.filter(b[3],c,d,!0^f);d||e.push.apply(e,g);return!1}else if(o.match.POS.test(b[0])||o.match.CHILD.test(b[0]))return!0;return b},POS:function(a){a.unshift(!0);return a}},filters:{enabled:function(a){return a.disabled===!1&&a.type!=="hidden"},disabled:function(a){return a.disabled===!0},checked:function(a){return a.checked===!0},selected:function(a){a.parentNode&&a.parentNode.selectedIndex;return a.selected===!0},parent:function(a){return!!a.firstChild},empty:function(a){return!a.firstChild},has:function(a,b,c){return!!m(c[3],a).length},header:function(a){return/h\d/i.test(a.nodeName)},text:function(a){var b=a.getAttribute("type"),c=a.type;return a.nodeName.toLowerCase()==="input"&&"text"===c&&(b===c||b===null)},radio:function(a){return a.nodeName.toLowerCase()==="input"&&"radio"===a.type},checkbox:function(a){return a.nodeName.toLowerCase()==="input"&&"checkbox"===a.type},file:function(a){return a.nodeName.toLowerCase()==="input"&&"file"===a.type},password:function(a){return a.nodeName.toLowerCase()==="input"&&"password"===a.type},submit:function(a){var b=a.nodeName.toLowerCase();return(b==="input"||b==="button")&&"submit"===a.type},image:function(a){return a.nodeName.toLowerCase()==="input"&&"image"===a.type},reset:function(a){var b=a.nodeName.toLowerCase();return(b==="input"||b==="button")&&"reset"===a.type},button:function(a){var b=a.nodeName.toLowerCase();return b==="input"&&"button"===a.type||b==="button"},input:function(a){return/input|select|textarea|button/i.test(a.nodeName)},focus:function(a){return a===a.ownerDocument.activeElement}},setFilters:{first:function(a,b){return b===0},last:function(a,b,c,d){return b===d.length-1},even:function(a,b){return b%2===0},odd:function(a,b){return b%2===1},lt:function(a,b,c){return b<c[3]-0},gt:function(a,b,c){return b>c[3]-0},nth:function(a,b,c){return c[3]-0===b},eq:function(a,b,c){return c[3]-0===b}},filter:{PSEUDO:function(a,b,c,d){var e=b[1],f=o.filters[e];if(f)return f(a,c,b,d);if(e==="contains")return(a.textContent||a.innerText||n([a])||"").indexOf(b[3])>=0;if(e==="not"){var g=b[3];for(var h=0,i=g.length;h<i;h++)if(g[h]===a)return!1;return!0}m.error(e)},CHILD:function(a,b){var c,e,f,g,h,i,j,k=b[1],l=a;switch(k){case"only":case"first":while(l=l.previousSibling)if(l.nodeType===1)return!1;if(k==="first")return!0;l=a;case"last":while(l=l.nextSibling)if(l.nodeType===1)return!1;return!0;case"nth":c=b[2],e=b[3];if(c===1&&e===0)return!0;f=b[0],g=a.parentNode;if(g&&(g[d]!==f||!a.nodeIndex)){i=0;for(l=g.firstChild;l;l=l.nextSibling)l.nodeType===1&&(l.nodeIndex=++i);g[d]=f}j=a.nodeIndex-e;return c===0?j===0:j%c===0&&j/c>=0}},ID:function(a,b){return a.nodeType===1&&a.getAttribute("id")===b},TAG:function(a,b){return b==="*"&&a.nodeType===1||!!a.nodeName&&a.nodeName.toLowerCase()===b},CLASS:function(a,b){return(" "+(a.className||a.getAttribute("class"))+" ").indexOf(b)>-1},ATTR:function(a,b){var c=b[1],d=m.attr?m.attr(a,c):o.attrHandle[c]?o.attrHandle[c](a):a[c]!=null?a[c]:a.getAttribute(c),e=d+"",f=b[2],g=b[4];return d==null?f==="!=":!f&&m.attr?d!=null:f==="="?e===g:f==="*="?e.indexOf(g)>=0:f==="~="?(" "+e+" ").indexOf(g)>=0:g?f==="!="?e!==g:f==="^="?e.indexOf(g)===0:f==="$="?e.substr(e.length-g.length)===g:f==="|="?e===g||e.substr(0,g.length+1)===g+"-":!1:e&&d!==!1},POS:function(a,b,c,d){var e=b[2],f=o.setFilters[e];if(f)return f(a,c,b,d)}}},p=o.match.POS,q=function(a,b){return"\\"+(b-0+1)};for(var r in o.match)o.match[r]=new RegExp(o.match[r].source+/(?![^\[]*\])(?![^\(]*\))/.source),o.leftMatch[r]=new RegExp(/(^(?:.|\r|\n)*?)/.source+o.match[r].source.replace(/\\(\d+)/g,q));o.match.globalPOS=p;var s=function(a,b){a=Array.prototype.slice.call(a,0);if(b){b.push.apply(b,a);return b}return a};try{Array.prototype.slice.call(c.documentElement.childNodes,0)[0].nodeType}catch(t){s=function(a,b){var c=0,d=b||[];if(g.call(a)==="[object Array]")Array.prototype.push.apply(d,a);else if(typeof a.length=="number")for(var e=a.length;c<e;c++)d.push(a[c]);else for(;a[c];c++)d.push(a[c]);return d}}var u,v;c.documentElement.compareDocumentPosition?u=function(a,b){if(a===b){h=!0;return 0}if(!a.compareDocumentPosition||!b.compareDocumentPosition)return a.compareDocumentPosition?-1:1;return a.compareDocumentPosition(b)&4?-1:1}:(u=function(a,b){if(a===b){h=!0;return 0}if(a.sourceIndex&&b.sourceIndex)return a.sourceIndex-b.sourceIndex;var c,d,e=[],f=[],g=a.parentNode,i=b.parentNode,j=g;if(g===i)return v(a,b);if(!g)return-1;if(!i)return 1;while(j)e.unshift(j),j=j.parentNode;j=i;while(j)f.unshift(j),j=j.parentNode;c=e.length,d=f.length;for(var k=0;k<c&&k<d;k++)if(e[k]!==f[k])return v(e[k],f[k]);return k===c?v(a,f[k],-1):v(e[k],b,1)},v=function(a,b,c){if(a===b)return c;var d=a.nextSibling;while(d){if(d===b)return-1;d=d.nextSibling}return 1}),function(){var a=c.createElement("div"),d="script"+(new Date).getTime(),e=c.documentElement;a.innerHTML="<a name='"+d+"'/>",e.insertBefore(a,e.firstChild),c.getElementById(d)&&(o.find.ID=function(a,c,d){if(typeof c.getElementById!="undefined"&&!d){var e=c.getElementById(a[1]);return e?e.id===a[1]||typeof e.getAttributeNode!="undefined"&&e.getAttributeNode("id").nodeValue===a[1]?[e]:b:[]}},o.filter.ID=function(a,b){var c=typeof a.getAttributeNode!="undefined"&&a.getAttributeNode("id");return a.nodeType===1&&c&&c.nodeValue===b}),e.removeChild(a),e=a=null}(),function(){var a=c.createElement("div");a.appendChild(c.createComment("")),a.getElementsByTagName("*").length>0&&(o.find.TAG=function(a,b){var c=b.getElementsByTagName(a[1]);if(a[1]==="*"){var d=[];for(var e=0;c[e];e++)c[e].nodeType===1&&d.push(c[e]);c=d}return c}),a.innerHTML="<a href='#'></a>",a.firstChild&&typeof a.firstChild.getAttribute!="undefined"&&a.firstChild.getAttribute("href")!=="#"&&(o.attrHandle.href=function(a){return a.getAttribute("href",2)}),a=null}(),c.querySelectorAll&&function(){var a=m,b=c.createElement("div"),d="__sizzle__";b.innerHTML="<p class='TEST'></p>";if(!b.querySelectorAll||b.querySelectorAll(".TEST").length!==0){m=function(b,e,f,g){e=e||c;if(!g&&!m.isXML(e)){var h=/^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec(b);if(h&&(e.nodeType===1||e.nodeType===9)){if(h[1])return s(e.getElementsByTagName(b),f);if(h[2]&&o.find.CLASS&&e.getElementsByClassName)return s(e.getElementsByClassName(h[2]),f)}if(e.nodeType===9){if(b==="body"&&e.body)return s([e.body],f);if(h&&h[3]){var i=e.getElementById(h[3]);if(!i||!i.parentNode)return s([],f);if(i.id===h[3])return s([i],f)}try{return s(e.querySelectorAll(b),f)}catch(j){}}else if(e.nodeType===1&&e.nodeName.toLowerCase()!=="object"){var k=e,l=e.getAttribute("id"),n=l||d,p=e.parentNode,q=/^\s*[+~]/.test(b);l?n=n.replace(/'/g,"\\$&"):e.setAttribute("id",n),q&&p&&(e=e.parentNode);try{if(!q||p)return s(e.querySelectorAll("[id='"+n+"'] "+b),f)}catch(r){}finally{l||k.removeAttribute("id")}}}return a(b,e,f,g)};for(var e in a)m[e]=a[e];b=null}}(),function(){var a=c.documentElement,b=a.matchesSelector||a.mozMatchesSelector||a.webkitMatchesSelector||a.msMatchesSelector;if(b){var d=!b.call(c.createElement("div"),"div"),e=!1;try{b.call(c.documentElement,"[test!='']:sizzle")}catch(f){e=!0}m.matchesSelector=function(a,c){c=c.replace(/\=\s*([^'"\]]*)\s*\]/g,"='$1']");if(!m.isXML(a))try{if(e||!o.match.PSEUDO.test(c)&&!/!=/.test(c)){var f=b.call(a,c);if(f||!d||a.document&&a.document.nodeType!==11)return f}}catch(g){}return m(c,null,null,[a]).length>0}}}(),function(){var a=c.createElement("div");a.innerHTML="<div class='test e'></div><div class='test'></div>";if(!!a.getElementsByClassName&&a.getElementsByClassName("e").length!==0){a.lastChild.className="e";if(a.getElementsByClassName("e").length===1)return;o.order.splice(1,0,"CLASS"),o.find.CLASS=function(a,b,c){if(typeof b.getElementsByClassName!="undefined"&&!c)return b.getElementsByClassName(a[1])},a=null}}(),c.documentElement.contains?m.contains=function(a,b){return a!==b&&(a.contains?a.contains(b):!0)}:c.documentElement.compareDocumentPosition?m.contains=function(a,b){return!!(a.compareDocumentPosition(b)&16)}:m.contains=function(){return!1},m.isXML=function(a){var b=(a?a.ownerDocument||a:0).documentElement;return b?b.nodeName!=="HTML":!1};var y=function(a,b,c){var d,e=[],f="",g=b.nodeType?[b]:b;while(d=o.match.PSEUDO.exec(a))f+=d[0],a=a.replace(o.match.PSEUDO,"");a=o.relative[a]?a+"*":a;for(var h=0,i=g.length;h<i;h++)m(a,g[h],e,c);return m.filter(f,e)};m.attr=f.attr,m.selectors.attrMap={},f.find=m,f.expr=m.selectors,f.expr[":"]=f.expr.filters,f.unique=m.uniqueSort,f.text=m.getText,f.isXMLDoc=m.isXML,f.contains=m.contains}();var L=/Until$/,M=/^(?:parents|prevUntil|prevAll)/,N=/,/,O=/^.[^:#\[\.,]*$/,P=Array.prototype.slice,Q=f.expr.match.globalPOS,R={children:!0,contents:!0,next:!0,prev:!0};f.fn.extend({find:function(a){var b=this,c,d;if(typeof a!="string")return f(a).filter(function(){for(c=0,d=b.length;c<d;c++)if(f.contains(b[c],this))return!0});var e=this.pushStack("","find",a),g,h,i;for(c=0,d=this.length;c<d;c++){g=e.length,f.find(a,this[c],e);if(c>0)for(h=g;h<e.length;h++)for(i=0;i<g;i++)if(e[i]===e[h]){e.splice(h--,1);break}}return e},has:function(a){var b=f(a);return this.filter(function(){for(var a=0,c=b.length;a<c;a++)if(f.contains(this,b[a]))return!0})},not:function(a){return this.pushStack(T(this,a,!1),"not",a)},filter:function(a){return this.pushStack(T(this,a,!0),"filter",a)},is:function(a){return!!a&&(typeof a=="string"?Q.test(a)?f(a,this.context).index(this[0])>=0:f.filter(a,this).length>0:this.filter(a).length>0)},closest:function(a,b){var c=[],d,e,g=this[0];if(f.isArray(a)){var h=1;while(g&&g.ownerDocument&&g!==b){for(d=0;d<a.length;d++)f(g).is(a[d])&&c.push({selector:a[d],elem:g,level:h});g=g.parentNode,h++}return c}var i=Q.test(a)||typeof a!="string"?f(a,b||this.context):0;for(d=0,e=this.length;d<e;d++){g=this[d];while(g){if(i?i.index(g)>-1:f.find.matchesSelector(g,a)){c.push(g);break}g=g.parentNode;if(!g||!g.ownerDocument||g===b||g.nodeType===11)break}}c=c.length>1?f.unique(c):c;return this.pushStack(c,"closest",a)},index:function(a){if(!a)return this[0]&&this[0].parentNode?this.prevAll().length:-1;if(typeof a=="string")return f.inArray(this[0],f(a));return f.inArray(a.jquery?a[0]:a,this)},add:function(a,b){var c=typeof a=="string"?f(a,b):f.makeArray(a&&a.nodeType?[a]:a),d=f.merge(this.get(),c);return this.pushStack(S(c[0])||S(d[0])?d:f.unique(d))},andSelf:function(){return this.add(this.prevObject)}}),f.each({parent:function(a){var b=a.parentNode;return b&&b.nodeType!==11?b:null},parents:function(a){return f.dir(a,"parentNode")},parentsUntil:function(a,b,c){return f.dir(a,"parentNode",c)},next:function(a){return f.nth(a,2,"nextSibling")},prev:function(a){return f.nth(a,2,"previousSibling")},nextAll:function(a){return f.dir(a,"nextSibling")},prevAll:function(a){return f.dir(a,"previousSibling")},nextUntil:function(a,b,c){return f.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return f.dir(a,"previousSibling",c)},siblings:function(a){return f.sibling((a.parentNode||{}).firstChild,a)},children:function(a){return f.sibling(a.firstChild)},contents:function(a){return f.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:f.makeArray(a.childNodes)}},function(a,b){f.fn[a]=function(c,d){var e=f.map(this,b,c);L.test(a)||(d=c),d&&typeof d=="string"&&(e=f.filter(d,e)),e=this.length>1&&!R[a]?f.unique(e):e,(this.length>1||N.test(d))&&M.test(a)&&(e=e.reverse());return this.pushStack(e,a,P.call(arguments).join(","))}}),f.extend({filter:function(a,b,c){c&&(a=":not("+a+")");return b.length===1?f.find.matchesSelector(b[0],a)?[b[0]]:[]:f.find.matches(a,b)},dir:function(a,c,d){var e=[],g=a[c];while(g&&g.nodeType!==9&&(d===b||g.nodeType!==1||!f(g).is(d)))g.nodeType===1&&e.push(g),g=g[c];return e},nth:function(a,b,c,d){b=b||1;var e=0;for(;a;a=a[c])if(a.nodeType===1&&++e===b)break;return a},sibling:function(a,b){var c=[];for(;a;a=a.nextSibling)a.nodeType===1&&a!==b&&c.push(a);return c}});var V="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",W=/ jQuery\d+="(?:\d+|null)"/g,X=/^\s+/,Y=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,Z=/<([\w:]+)/,$=/<tbody/i,_=/<|&#?\w+;/,ba=/<(?:script|style)/i,bb=/<(?:script|object|embed|option|style)/i,bc=new RegExp("<(?:"+V+")[\\s/>]","i"),bd=/checked\s*(?:[^=]|=\s*.checked.)/i,be=/\/(java|ecma)script/i,bf=/^\s*<!(?:\[CDATA\[|\-\-)/,bg={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]},bh=U(c);bg.optgroup=bg.option,bg.tbody=bg.tfoot=bg.colgroup=bg.caption=bg.thead,bg.th=bg.td,f.support.htmlSerialize||(bg._default=[1,"div<div>","</div>"]),f.fn.extend({text:function(a){return f.access(this,function(a){return a===b?f.text(this):this.empty().append((this[0]&&this[0].ownerDocument||c).createTextNode(a))},null,a,arguments.length)},wrapAll:function(a){if(f.isFunction(a))return this.each(function(b){f(this).wrapAll(a.call(this,b))});if(this[0]){var b=f(a,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstChild&&a.firstChild.nodeType===1)a=a.firstChild;return a}).append(this)}return this},wrapInner:function(a){if(f.isFunction(a))return this.each(function(b){f(this).wrapInner(a.call(this,b))});return this.each(function(){var b=f(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=f.isFunction(a);return this.each(function(c){f(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){f.nodeName(this,"body")||f(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,!0,function(a){this.nodeType===1&&this.appendChild(a)})},prepend:function(){return this.domManip(arguments,!0,function(a){this.nodeType===1&&this.insertBefore(a,this.firstChild)})},before:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this)});if(arguments.length){var a=f
.clean(arguments);a.push.apply(a,this.toArray());return this.pushStack(a,"before",arguments)}},after:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this.nextSibling)});if(arguments.length){var a=this.pushStack(this,"after",arguments);a.push.apply(a,f.clean(arguments));return a}},remove:function(a,b){for(var c=0,d;(d=this[c])!=null;c++)if(!a||f.filter(a,[d]).length)!b&&d.nodeType===1&&(f.cleanData(d.getElementsByTagName("*")),f.cleanData([d])),d.parentNode&&d.parentNode.removeChild(d);return this},empty:function(){for(var a=0,b;(b=this[a])!=null;a++){b.nodeType===1&&f.cleanData(b.getElementsByTagName("*"));while(b.firstChild)b.removeChild(b.firstChild)}return this},clone:function(a,b){a=a==null?!1:a,b=b==null?a:b;return this.map(function(){return f.clone(this,a,b)})},html:function(a){return f.access(this,function(a){var c=this[0]||{},d=0,e=this.length;if(a===b)return c.nodeType===1?c.innerHTML.replace(W,""):null;if(typeof a=="string"&&!ba.test(a)&&(f.support.leadingWhitespace||!X.test(a))&&!bg[(Z.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(Y,"<$1></$2>");try{for(;d<e;d++)c=this[d]||{},c.nodeType===1&&(f.cleanData(c.getElementsByTagName("*")),c.innerHTML=a);c=0}catch(g){}}c&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(a){if(this[0]&&this[0].parentNode){if(f.isFunction(a))return this.each(function(b){var c=f(this),d=c.html();c.replaceWith(a.call(this,b,d))});typeof a!="string"&&(a=f(a).detach());return this.each(function(){var b=this.nextSibling,c=this.parentNode;f(this).remove(),b?f(b).before(a):f(c).append(a)})}return this.length?this.pushStack(f(f.isFunction(a)?a():a),"replaceWith",a):this},detach:function(a){return this.remove(a,!0)},domManip:function(a,c,d){var e,g,h,i,j=a[0],k=[];if(!f.support.checkClone&&arguments.length===3&&typeof j=="string"&&bd.test(j))return this.each(function(){f(this).domManip(a,c,d,!0)});if(f.isFunction(j))return this.each(function(e){var g=f(this);a[0]=j.call(this,e,c?g.html():b),g.domManip(a,c,d)});if(this[0]){i=j&&j.parentNode,f.support.parentNode&&i&&i.nodeType===11&&i.childNodes.length===this.length?e={fragment:i}:e=f.buildFragment(a,this,k),h=e.fragment,h.childNodes.length===1?g=h=h.firstChild:g=h.firstChild;if(g){c=c&&f.nodeName(g,"tr");for(var l=0,m=this.length,n=m-1;l<m;l++)d.call(c?bi(this[l],g):this[l],e.cacheable||m>1&&l<n?f.clone(h,!0,!0):h)}k.length&&f.each(k,function(a,b){b.src?f.ajax({type:"GET",global:!1,url:b.src,async:!1,dataType:"script"}):f.globalEval((b.text||b.textContent||b.innerHTML||"").replace(bf,"/*$0*/")),b.parentNode&&b.parentNode.removeChild(b)})}return this}}),f.buildFragment=function(a,b,d){var e,g,h,i,j=a[0];b&&b[0]&&(i=b[0].ownerDocument||b[0]),i.createDocumentFragment||(i=c),a.length===1&&typeof j=="string"&&j.length<512&&i===c&&j.charAt(0)==="<"&&!bb.test(j)&&(f.support.checkClone||!bd.test(j))&&(f.support.html5Clone||!bc.test(j))&&(g=!0,h=f.fragments[j],h&&h!==1&&(e=h)),e||(e=i.createDocumentFragment(),f.clean(a,i,e,d)),g&&(f.fragments[j]=h?e:1);return{fragment:e,cacheable:g}},f.fragments={},f.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){f.fn[a]=function(c){var d=[],e=f(c),g=this.length===1&&this[0].parentNode;if(g&&g.nodeType===11&&g.childNodes.length===1&&e.length===1){e[b](this[0]);return this}for(var h=0,i=e.length;h<i;h++){var j=(h>0?this.clone(!0):this).get();f(e[h])[b](j),d=d.concat(j)}return this.pushStack(d,a,e.selector)}}),f.extend({clone:function(a,b,c){var d,e,g,h=f.support.html5Clone||f.isXMLDoc(a)||!bc.test("<"+a.nodeName+">")?a.cloneNode(!0):bo(a);if((!f.support.noCloneEvent||!f.support.noCloneChecked)&&(a.nodeType===1||a.nodeType===11)&&!f.isXMLDoc(a)){bk(a,h),d=bl(a),e=bl(h);for(g=0;d[g];++g)e[g]&&bk(d[g],e[g])}if(b){bj(a,h);if(c){d=bl(a),e=bl(h);for(g=0;d[g];++g)bj(d[g],e[g])}}d=e=null;return h},clean:function(a,b,d,e){var g,h,i,j=[];b=b||c,typeof b.createElement=="undefined"&&(b=b.ownerDocument||b[0]&&b[0].ownerDocument||c);for(var k=0,l;(l=a[k])!=null;k++){typeof l=="number"&&(l+="");if(!l)continue;if(typeof l=="string")if(!_.test(l))l=b.createTextNode(l);else{l=l.replace(Y,"<$1></$2>");var m=(Z.exec(l)||["",""])[1].toLowerCase(),n=bg[m]||bg._default,o=n[0],p=b.createElement("div"),q=bh.childNodes,r;b===c?bh.appendChild(p):U(b).appendChild(p),p.innerHTML=n[1]+l+n[2];while(o--)p=p.lastChild;if(!f.support.tbody){var s=$.test(l),t=m==="table"&&!s?p.firstChild&&p.firstChild.childNodes:n[1]==="<table>"&&!s?p.childNodes:[];for(i=t.length-1;i>=0;--i)f.nodeName(t[i],"tbody")&&!t[i].childNodes.length&&t[i].parentNode.removeChild(t[i])}!f.support.leadingWhitespace&&X.test(l)&&p.insertBefore(b.createTextNode(X.exec(l)[0]),p.firstChild),l=p.childNodes,p&&(p.parentNode.removeChild(p),q.length>0&&(r=q[q.length-1],r&&r.parentNode&&r.parentNode.removeChild(r)))}var u;if(!f.support.appendChecked)if(l[0]&&typeof (u=l.length)=="number")for(i=0;i<u;i++)bn(l[i]);else bn(l);l.nodeType?j.push(l):j=f.merge(j,l)}if(d){g=function(a){return!a.type||be.test(a.type)};for(k=0;j[k];k++){h=j[k];if(e&&f.nodeName(h,"script")&&(!h.type||be.test(h.type)))e.push(h.parentNode?h.parentNode.removeChild(h):h);else{if(h.nodeType===1){var v=f.grep(h.getElementsByTagName("script"),g);j.splice.apply(j,[k+1,0].concat(v))}d.appendChild(h)}}}return j},cleanData:function(a){var b,c,d=f.cache,e=f.event.special,g=f.support.deleteExpando;for(var h=0,i;(i=a[h])!=null;h++){if(i.nodeName&&f.noData[i.nodeName.toLowerCase()])continue;c=i[f.expando];if(c){b=d[c];if(b&&b.events){for(var j in b.events)e[j]?f.event.remove(i,j):f.removeEvent(i,j,b.handle);b.handle&&(b.handle.elem=null)}g?delete i[f.expando]:i.removeAttribute&&i.removeAttribute(f.expando),delete d[c]}}}});var bp=/alpha\([^)]*\)/i,bq=/opacity=([^)]*)/,br=/([A-Z]|^ms)/g,bs=/^[\-+]?(?:\d*\.)?\d+$/i,bt=/^-?(?:\d*\.)?\d+(?!px)[^\d\s]+$/i,bu=/^([\-+])=([\-+.\de]+)/,bv=/^margin/,bw={position:"absolute",visibility:"hidden",display:"block"},bx=["Top","Right","Bottom","Left"],by,bz,bA;f.fn.css=function(a,c){return f.access(this,function(a,c,d){return d!==b?f.style(a,c,d):f.css(a,c)},a,c,arguments.length>1)},f.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=by(a,"opacity");return c===""?"1":c}return a.style.opacity}}},cssNumber:{fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":f.support.cssFloat?"cssFloat":"styleFloat"},style:function(a,c,d,e){if(!!a&&a.nodeType!==3&&a.nodeType!==8&&!!a.style){var g,h,i=f.camelCase(c),j=a.style,k=f.cssHooks[i];c=f.cssProps[i]||i;if(d===b){if(k&&"get"in k&&(g=k.get(a,!1,e))!==b)return g;return j[c]}h=typeof d,h==="string"&&(g=bu.exec(d))&&(d=+(g[1]+1)*+g[2]+parseFloat(f.css(a,c)),h="number");if(d==null||h==="number"&&isNaN(d))return;h==="number"&&!f.cssNumber[i]&&(d+="px");if(!k||!("set"in k)||(d=k.set(a,d))!==b)try{j[c]=d}catch(l){}}},css:function(a,c,d){var e,g;c=f.camelCase(c),g=f.cssHooks[c],c=f.cssProps[c]||c,c==="cssFloat"&&(c="float");if(g&&"get"in g&&(e=g.get(a,!0,d))!==b)return e;if(by)return by(a,c)},swap:function(a,b,c){var d={},e,f;for(f in b)d[f]=a.style[f],a.style[f]=b[f];e=c.call(a);for(f in b)a.style[f]=d[f];return e}}),f.curCSS=f.css,c.defaultView&&c.defaultView.getComputedStyle&&(bz=function(a,b){var c,d,e,g,h=a.style;b=b.replace(br,"-$1").toLowerCase(),(d=a.ownerDocument.defaultView)&&(e=d.getComputedStyle(a,null))&&(c=e.getPropertyValue(b),c===""&&!f.contains(a.ownerDocument.documentElement,a)&&(c=f.style(a,b))),!f.support.pixelMargin&&e&&bv.test(b)&&bt.test(c)&&(g=h.width,h.width=c,c=e.width,h.width=g);return c}),c.documentElement.currentStyle&&(bA=function(a,b){var c,d,e,f=a.currentStyle&&a.currentStyle[b],g=a.style;f==null&&g&&(e=g[b])&&(f=e),bt.test(f)&&(c=g.left,d=a.runtimeStyle&&a.runtimeStyle.left,d&&(a.runtimeStyle.left=a.currentStyle.left),g.left=b==="fontSize"?"1em":f,f=g.pixelLeft+"px",g.left=c,d&&(a.runtimeStyle.left=d));return f===""?"auto":f}),by=bz||bA,f.each(["height","width"],function(a,b){f.cssHooks[b]={get:function(a,c,d){if(c)return a.offsetWidth!==0?bB(a,b,d):f.swap(a,bw,function(){return bB(a,b,d)})},set:function(a,b){return bs.test(b)?b+"px":b}}}),f.support.opacity||(f.cssHooks.opacity={get:function(a,b){return bq.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?parseFloat(RegExp.$1)/100+"":b?"1":""},set:function(a,b){var c=a.style,d=a.currentStyle,e=f.isNumeric(b)?"alpha(opacity="+b*100+")":"",g=d&&d.filter||c.filter||"";c.zoom=1;if(b>=1&&f.trim(g.replace(bp,""))===""){c.removeAttribute("filter");if(d&&!d.filter)return}c.filter=bp.test(g)?g.replace(bp,e):g+" "+e}}),f(function(){f.support.reliableMarginRight||(f.cssHooks.marginRight={get:function(a,b){return f.swap(a,{display:"inline-block"},function(){return b?by(a,"margin-right"):a.style.marginRight})}})}),f.expr&&f.expr.filters&&(f.expr.filters.hidden=function(a){var b=a.offsetWidth,c=a.offsetHeight;return b===0&&c===0||!f.support.reliableHiddenOffsets&&(a.style&&a.style.display||f.css(a,"display"))==="none"},f.expr.filters.visible=function(a){return!f.expr.filters.hidden(a)}),f.each({margin:"",padding:"",border:"Width"},function(a,b){f.cssHooks[a+b]={expand:function(c){var d,e=typeof c=="string"?c.split(" "):[c],f={};for(d=0;d<4;d++)f[a+bx[d]+b]=e[d]||e[d-2]||e[0];return f}}});var bC=/%20/g,bD=/\[\]$/,bE=/\r?\n/g,bF=/#.*$/,bG=/^(.*?):[ \t]*([^\r\n]*)\r?$/mg,bH=/^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,bI=/^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,bJ=/^(?:GET|HEAD)$/,bK=/^\/\//,bL=/\?/,bM=/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,bN=/^(?:select|textarea)/i,bO=/\s+/,bP=/([?&])_=[^&]*/,bQ=/^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,bR=f.fn.load,bS={},bT={},bU,bV,bW=["*/"]+["*"];try{bU=e.href}catch(bX){bU=c.createElement("a"),bU.href="",bU=bU.href}bV=bQ.exec(bU.toLowerCase())||[],f.fn.extend({load:function(a,c,d){if(typeof a!="string"&&bR)return bR.apply(this,arguments);if(!this.length)return this;var e=a.indexOf(" ");if(e>=0){var g=a.slice(e,a.length);a=a.slice(0,e)}var h="GET";c&&(f.isFunction(c)?(d=c,c=b):typeof c=="object"&&(c=f.param(c,f.ajaxSettings.traditional),h="POST"));var i=this;f.ajax({url:a,type:h,dataType:"html",data:c,complete:function(a,b,c){c=a.responseText,a.isResolved()&&(a.done(function(a){c=a}),i.html(g?f("<div>").append(c.replace(bM,"")).find(g):c)),d&&i.each(d,[c,b,a])}});return this},serialize:function(){return f.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?f.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||bN.test(this.nodeName)||bH.test(this.type))}).map(function(a,b){var c=f(this).val();return c==null?null:f.isArray(c)?f.map(c,function(a,c){return{name:b.name,value:a.replace(bE,"\r\n")}}):{name:b.name,value:c.replace(bE,"\r\n")}}).get()}}),f.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "),function(a,b){f.fn[b]=function(a){return this.on(b,a)}}),f.each(["get","post"],function(a,c){f[c]=function(a,d,e,g){f.isFunction(d)&&(g=g||e,e=d,d=b);return f.ajax({type:c,url:a,data:d,success:e,dataType:g})}}),f.extend({getScript:function(a,c){return f.get(a,b,c,"script")},getJSON:function(a,b,c){return f.get(a,b,c,"json")},ajaxSetup:function(a,b){b?b$(a,f.ajaxSettings):(b=a,a=f.ajaxSettings),b$(a,b);return a},ajaxSettings:{url:bU,isLocal:bI.test(bV[1]),global:!0,type:"GET",contentType:"application/x-www-form-urlencoded; charset=UTF-8",processData:!0,async:!0,accepts:{xml:"application/xml, text/xml",html:"text/html",text:"text/plain",json:"application/json, text/javascript","*":bW},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText"},converters:{"* text":a.String,"text html":!0,"text json":f.parseJSON,"text xml":f.parseXML},flatOptions:{context:!0,url:!0}},ajaxPrefilter:bY(bS),ajaxTransport:bY(bT),ajax:function(a,c){function w(a,c,l,m){if(s!==2){s=2,q&&clearTimeout(q),p=b,n=m||"",v.readyState=a>0?4:0;var o,r,u,w=c,x=l?ca(d,v,l):b,y,z;if(a>=200&&a<300||a===304){if(d.ifModified){if(y=v.getResponseHeader("Last-Modified"))f.lastModified[k]=y;if(z=v.getResponseHeader("Etag"))f.etag[k]=z}if(a===304)w="notmodified",o=!0;else try{r=cb(d,x),w="success",o=!0}catch(A){w="parsererror",u=A}}else{u=w;if(!w||a)w="error",a<0&&(a=0)}v.status=a,v.statusText=""+(c||w),o?h.resolveWith(e,[r,w,v]):h.rejectWith(e,[v,w,u]),v.statusCode(j),j=b,t&&g.trigger("ajax"+(o?"Success":"Error"),[v,d,o?r:u]),i.fireWith(e,[v,w]),t&&(g.trigger("ajaxComplete",[v,d]),--f.active||f.event.trigger("ajaxStop"))}}typeof a=="object"&&(c=a,a=b),c=c||{};var d=f.ajaxSetup({},c),e=d.context||d,g=e!==d&&(e.nodeType||e instanceof f)?f(e):f.event,h=f.Deferred(),i=f.Callbacks("once memory"),j=d.statusCode||{},k,l={},m={},n,o,p,q,r,s=0,t,u,v={readyState:0,setRequestHeader:function(a,b){if(!s){var c=a.toLowerCase();a=m[c]=m[c]||a,l[a]=b}return this},getAllResponseHeaders:function(){return s===2?n:null},getResponseHeader:function(a){var c;if(s===2){if(!o){o={};while(c=bG.exec(n))o[c[1].toLowerCase()]=c[2]}c=o[a.toLowerCase()]}return c===b?null:c},overrideMimeType:function(a){s||(d.mimeType=a);return this},abort:function(a){a=a||"abort",p&&p.abort(a),w(0,a);return this}};h.promise(v),v.success=v.done,v.error=v.fail,v.complete=i.add,v.statusCode=function(a){if(a){var b;if(s<2)for(b in a)j[b]=[j[b],a[b]];else b=a[v.status],v.then(b,b)}return this},d.url=((a||d.url)+"").replace(bF,"").replace(bK,bV[1]+"//"),d.dataTypes=f.trim(d.dataType||"*").toLowerCase().split(bO),d.crossDomain==null&&(r=bQ.exec(d.url.toLowerCase()),d.crossDomain=!(!r||r[1]==bV[1]&&r[2]==bV[2]&&(r[3]||(r[1]==="http:"?80:443))==(bV[3]||(bV[1]==="http:"?80:443)))),d.data&&d.processData&&typeof d.data!="string"&&(d.data=f.param(d.data,d.traditional)),bZ(bS,d,c,v);if(s===2)return!1;t=d.global,d.type=d.type.toUpperCase(),d.hasContent=!bJ.test(d.type),t&&f.active++===0&&f.event.trigger("ajaxStart");if(!d.hasContent){d.data&&(d.url+=(bL.test(d.url)?"&":"?")+d.data,delete d.data),k=d.url;if(d.cache===!1){var x=f.now(),y=d.url.replace(bP,"$1_="+x);d.url=y+(y===d.url?(bL.test(d.url)?"&":"?")+"_="+x:"")}}(d.data&&d.hasContent&&d.contentType!==!1||c.contentType)&&v.setRequestHeader("Content-Type",d.contentType),d.ifModified&&(k=k||d.url,f.lastModified[k]&&v.setRequestHeader("If-Modified-Since",f.lastModified[k]),f.etag[k]&&v.setRequestHeader("If-None-Match",f.etag[k])),v.setRequestHeader("Accept",d.dataTypes[0]&&d.accepts[d.dataTypes[0]]?d.accepts[d.dataTypes[0]]+(d.dataTypes[0]!=="*"?", "+bW+"; q=0.01":""):d.accepts["*"]);for(u in d.headers)v.setRequestHeader(u,d.headers[u]);if(d.beforeSend&&(d.beforeSend.call(e,v,d)===!1||s===2)){v.abort();return!1}for(u in{success:1,error:1,complete:1})v[u](d[u]);p=bZ(bT,d,c,v);if(!p)w(-1,"No Transport");else{v.readyState=1,t&&g.trigger("ajaxSend",[v,d]),d.async&&d.timeout>0&&(q=setTimeout(function(){v.abort("timeout")},d.timeout));try{s=1,p.send(l,w)}catch(z){if(s<2)w(-1,z);else throw z}}return v},param:function(a,c){var d=[],e=function(a,b){b=f.isFunction(b)?b():b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};c===b&&(c=f.ajaxSettings.traditional);if(f.isArray(a)||a.jquery&&!f.isPlainObject(a))f.each(a,function(){e(this.name,this.value)});else for(var g in a)b_(g,a[g],c,e);return d.join("&").replace(bC,"+")}}),f.extend({active:0,lastModified:{},etag:{}});var cc=f.now(),cd=/(\=)\?(&|$)|\?\?/i;f.ajaxSetup({jsonp:"callback",jsonpCallback:function(){return f.expando+"_"+cc++}}),f.ajaxPrefilter("json jsonp",function(b,c,d){var e=typeof b.data=="string"&&/^application\/x\-www\-form\-urlencoded/.test(b.contentType);if(b.dataTypes[0]==="jsonp"||b.jsonp!==!1&&(cd.test(b.url)||e&&cd.test(b.data))){var g,h=b.jsonpCallback=f.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,i=a[h],j=b.url,k=b.data,l="$1"+h+"$2";b.jsonp!==!1&&(j=j.replace(cd,l),b.url===j&&(e&&(k=k.replace(cd,l)),b.data===k&&(j+=(/\?/.test(j)?"&":"?")+b.jsonp+"="+h))),b.url=j,b.data=k,a[h]=function(a){g=[a]},d.always(function(){a[h]=i,g&&f.isFunction(i)&&a[h](g[0])}),b.converters["script json"]=function(){g||f.error(h+" was not called");return g[0]},b.dataTypes[0]="json";return"script"}}),f.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/javascript|ecmascript/},converters:{"text script":function(a){f.globalEval(a);return a}}}),f.ajaxPrefilter("script",function(a){a.cache===b&&(a.cache=!1),a.crossDomain&&(a.type="GET",a.global=!1)}),f.ajaxTransport("script",function(a){if(a.crossDomain){var d,e=c.head||c.getElementsByTagName("head")[0]||c.documentElement;return{send:function(f,g){d=c.createElement("script"),d.async="async",a.scriptCharset&&(d.charset=a.scriptCharset),d.src=a.url,d.onload=d.onreadystatechange=function(a,c){if(c||!d.readyState||/loaded|complete/.test(d.readyState))d.onload=d.onreadystatechange=null,e&&d.parentNode&&e.removeChild(d),d=b,c||g(200,"success")},e.insertBefore(d,e.firstChild)},abort:function(){d&&d.onload(0,1)}}}});var ce=a.ActiveXObject?function(){for(var a in cg)cg[a](0,1)}:!1,cf=0,cg;f.ajaxSettings.xhr=a.ActiveXObject?function(){return!this.isLocal&&ch()||ci()}:ch,function(a){f.extend(f.support,{ajax:!!a,cors:!!a&&"withCredentials"in a})}(f.ajaxSettings.xhr()),f.support.ajax&&f.ajaxTransport(function(c){if(!c.crossDomain||f.support.cors){var d;return{send:function(e,g){var h=c.xhr(),i,j;c.username?h.open(c.type,c.url,c.async,c.username,c.password):h.open(c.type,c.url,c.async);if(c.xhrFields)for(j in c.xhrFields)h[j]=c.xhrFields[j];c.mimeType&&h.overrideMimeType&&h.overrideMimeType(c.mimeType),!c.crossDomain&&!e["X-Requested-With"]&&(e["X-Requested-With"]="XMLHttpRequest");try{for(j in e)h.setRequestHeader(j,e[j])}catch(k){}h.send(c.hasContent&&c.data||null),d=function(a,e){var j,k,l,m,n;try{if(d&&(e||h.readyState===4)){d=b,i&&(h.onreadystatechange=f.noop,ce&&delete cg[i]);if(e)h.readyState!==4&&h.abort();else{j=h.status,l=h.getAllResponseHeaders(),m={},n=h.responseXML,n&&n.documentElement&&(m.xml=n);try{m.text=h.responseText}catch(a){}try{k=h.statusText}catch(o){k=""}!j&&c.isLocal&&!c.crossDomain?j=m.text?200:404:j===1223&&(j=204)}}}catch(p){e||g(-1,p)}m&&g(j,k,m,l)},!c.async||h.readyState===4?d():(i=++cf,ce&&(cg||(cg={},f(a).unload(ce)),cg[i]=d),h.onreadystatechange=d)},abort:function(){d&&d(0,1)}}}});var cj={},ck,cl,cm=/^(?:toggle|show|hide)$/,cn=/^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,co,cp=[["height","marginTop","marginBottom","paddingTop","paddingBottom"],["width","marginLeft","marginRight","paddingLeft","paddingRight"],["opacity"]],cq;f.fn.extend({show:function(a,b,c){var d,e;if(a||a===0)return this.animate(ct("show",3),a,b,c);for(var g=0,h=this.length;g<h;g++)d=this[g],d.style&&(e=d.style.display,!f._data(d,"olddisplay")&&e==="none"&&(e=d.style.display=""),(e===""&&f.css(d,"display")==="none"||!f.contains(d.ownerDocument.documentElement,d))&&f._data(d,"olddisplay",cu(d.nodeName)));for(g=0;g<h;g++){d=this[g];if(d.style){e=d.style.display;if(e===""||e==="none")d.style.display=f._data(d,"olddisplay")||""}}return this},hide:function(a,b,c){if(a||a===0)return this.animate(ct("hide",3),a,b,c);var d,e,g=0,h=this.length;for(;g<h;g++)d=this[g],d.style&&(e=f.css(d,"display"),e!=="none"&&!f._data(d,"olddisplay")&&f._data(d,"olddisplay",e));for(g=0;g<h;g++)this[g].style&&(this[g].style.display="none");return this},_toggle:f.fn.toggle,toggle:function(a,b,c){var d=typeof a=="boolean";f.isFunction(a)&&f.isFunction(b)?this._toggle.apply(this,arguments):a==null||d?this.each(function(){var b=d?a:f(this).is(":hidden");f(this)[b?"show":"hide"]()}):this.animate(ct("toggle",3),a,b,c);return this},fadeTo:function(a,b,c,d){return this.filter(":hidden").css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){function g(){e.queue===!1&&f._mark(this);var b=f.extend({},e),c=this.nodeType===1,d=c&&f(this).is(":hidden"),g,h,i,j,k,l,m,n,o,p,q;b.animatedProperties={};for(i in a){g=f.camelCase(i),i!==g&&(a[g]=a[i],delete a[i]);if((k=f.cssHooks[g])&&"expand"in k){l=k.expand(a[g]),delete a[g];for(i in l)i in a||(a[i]=l[i])}}for(g in a){h=a[g],f.isArray(h)?(b.animatedProperties[g]=h[1],h=a[g]=h[0]):b.animatedProperties[g]=b.specialEasing&&b.specialEasing[g]||b.easing||"swing";if(h==="hide"&&d||h==="show"&&!d)return b.complete.call(this);c&&(g==="height"||g==="width")&&(b.overflow=[this.style.overflow,this.style.overflowX,this.style.overflowY],f.css(this,"display")==="inline"&&f.css(this,"float")==="none"&&(!f.support.inlineBlockNeedsLayout||cu(this.nodeName)==="inline"?this.style.display="inline-block":this.style.zoom=1))}b.overflow!=null&&(this.style.overflow="hidden");for(i in a)j=new f.fx(this,b,i),h=a[i],cm.test(h)?(q=f._data(this,"toggle"+i)||(h==="toggle"?d?"show":"hide":0),q?(f._data(this,"toggle"+i,q==="show"?"hide":"show"),j[q]()):j[h]()):(m=cn.exec(h),n=j.cur(),m?(o=parseFloat(m[2]),p=m[3]||(f.cssNumber[i]?"":"px"),p!=="px"&&(f.style(this,i,(o||1)+p),n=(o||1)/j.cur()*n,f.style(this,i,n+p)),m[1]&&(o=(m[1]==="-="?-1:1)*o+n),j.custom(n,o,p)):j.custom(n,h,""));return!0}var e=f.speed(b,c,d);if(f.isEmptyObject(a))return this.each(e.complete,[!1]);a=f.extend({},a);return e.queue===!1?this.each(g):this.queue(e.queue,g)},stop:function(a,c,d){typeof a!="string"&&(d=c,c=a,a=b),c&&a!==!1&&this.queue(a||"fx",[]);return this.each(function(){function h(a,b,c){var e=b[c];f.removeData(a,c,!0),e.stop(d)}var b,c=!1,e=f.timers,g=f._data(this);d||f._unmark(!0,this);if(a==null)for(b in g)g[b]&&g[b].stop&&b.indexOf(".run")===b.length-4&&h(this,g,b);else g[b=a+".run"]&&g[b].stop&&h(this,g,b);for(b=e.length;b--;)e[b].elem===this&&(a==null||e[b].queue===a)&&(d?e[b](!0):e[b].saveState(),c=!0,e.splice(b,1));(!d||!c)&&f.dequeue(this,a)})}}),f.each({slideDown:ct("show",1),slideUp:ct("hide",1),slideToggle:ct("toggle",1),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){f.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),f.extend({speed:function(a,b,c){var d=a&&typeof a=="object"?f.extend({},a):{complete:c||!c&&b||f.isFunction(a)&&a,duration:a,easing:c&&b||b&&!f.isFunction(b)&&b};d.duration=f.fx.off?0:typeof d.duration=="number"?d.duration:d.duration in f.fx.speeds?f.fx.speeds[d.duration]:f.fx.speeds._default;if(d.queue==null||d.queue===!0)d.queue="fx";d.old=d.complete,d.complete=function(a){f.isFunction(d.old)&&d.old.call(this),d.queue?f.dequeue(this,d.queue):a!==!1&&f._unmark(this)};return d},easing:{linear:function(a){return a},swing:function(a){return-Math.cos(a*Math.PI)/2+.5}},timers:[],fx:function(a,b,c){this.options=b,this.elem=a,this.prop=c,b.orig=b.orig||{}}}),f.fx.prototype={update:function(){this.options.step&&this.options.step.call(this.elem,this.now,this),(f.fx.step[this.prop]||f.fx.step._default)(this)},cur:function(){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null))return this.elem[this.prop];var a,b=f.css(this.elem,this.prop);return isNaN(a=parseFloat(b))?!b||b==="auto"?0:b:a},custom:function(a,c,d){function h(a){return e.step(a)}var e=this,g=f.fx;this.startTime=cq||cr(),this.end=c,this.now=this.start=a,this.pos=this.state=0,this.unit=d||this.unit||(f.cssNumber[this.prop]?"":"px"),h.queue=this.options.queue,h.elem=this.elem,h.saveState=function(){f._data(e.elem,"fxshow"+e.prop)===b&&(e.options.hide?f._data(e.elem,"fxshow"+e.prop,e.start):e.options.show&&f._data(e.elem,"fxshow"+e.prop,e.end))},h()&&f.timers.push(h)&&!co&&(co=setInterval(g.tick,g.interval))},show:function(){var a=f._data(this.elem,"fxshow"+this.prop);this.options.orig[this.prop]=a||f.style(this.elem,this.prop),this.options.show=!0,a!==b?this.custom(this.cur(),a):this.custom(this.prop==="width"||this.prop==="height"?1:0,this.cur()),f(this.elem).show()},hide:function(){this.options.orig[this.prop]=f._data(this.elem,"fxshow"+this.prop)||f.style(this.elem,this.prop),this.options.hide=!0,this.custom(this.cur(),0)},step:function(a){var b,c,d,e=cq||cr(),g=!0,h=this.elem,i=this.options;if(a||e>=i.duration+this.startTime){this.now=this.end,this.pos=this.state=1,this.update(),i.animatedProperties[this.prop]=!0;for(b in i.animatedProperties)i.animatedProperties[b]!==!0&&(g=!1);if(g){i.overflow!=null&&!f.support.shrinkWrapBlocks&&f.each(["","X","Y"],function(a,b){h.style["overflow"+b]=i.overflow[a]}),i.hide&&f(h).hide();if(i.hide||i.show)for(b in i.animatedProperties)f.style(h,b,i.orig[b]),f.removeData(h,"fxshow"+b,!0),f.removeData(h,"toggle"+b,!0);d=i.complete,d&&(i.complete=!1,d.call(h))}return!1}i.duration==Infinity?this.now=e:(c=e-this.startTime,this.state=c/i.duration,this.pos=f.easing[i.animatedProperties[this.prop]](this.state,c,0,1,i.duration),this.now=this.start+(this.end-this.start)*this.pos),this.update();return!0}},f.extend(f.fx,{tick:function(){var a,b=f.timers,c=0;for(;c<b.length;c++)a=b[c],!a()&&b[c]===a&&b.splice(c--,1);b.length||f.fx.stop()},interval:13,stop:function(){clearInterval(co),co=null},speeds:{slow:600,fast:200,_default:400},step:{opacity:function(a){f.style(a.elem,"opacity",a.now)},_default:function(a){a.elem.style&&a.elem.style[a.prop]!=null?a.elem.style[a.prop]=a.now+a.unit:a.elem[a.prop]=a.now}}}),f.each(cp.concat.apply([],cp),function(a,b){b.indexOf("margin")&&(f.fx.step[b]=function(a){f.style(a.elem,b,Math.max(0,a.now)+a.unit)})}),f.expr&&f.expr.filters&&(f.expr.filters.animated=function(a){return f.grep(f.timers,function(b){return a===b.elem}).length});var cv,cw=/^t(?:able|d|h)$/i,cx=/^(?:body|html)$/i;"getBoundingClientRect"in c.documentElement?cv=function(a,b,c,d){try{d=a.getBoundingClientRect()}catch(e){}if(!d||!f.contains(c,a))return d?{top:d.top,left:d.left}:{top:0,left:0};var g=b.body,h=cy(b),i=c.clientTop||g.clientTop||0,j=c.clientLeft||g.clientLeft||0,k=h.pageYOffset||f.support.boxModel&&c.scrollTop||g.scrollTop,l=h.pageXOffset||f.support.boxModel&&c.scrollLeft||g.scrollLeft,m=d.top+k-i,n=d.left+l-j;return{top:m,left:n}}:cv=function(a,b,c){var d,e=a.offsetParent,g=a,h=b.body,i=b.defaultView,j=i?i.getComputedStyle(a,null):a.currentStyle,k=a.offsetTop,l=a.offsetLeft;while((a=a.parentNode)&&a!==h&&a!==c){if(f.support.fixedPosition&&j.position==="fixed")break;d=i?i.getComputedStyle(a,null):a.currentStyle,k-=a.scrollTop,l-=a.scrollLeft,a===e&&(k+=a.offsetTop,l+=a.offsetLeft,f.support.doesNotAddBorder&&(!f.support.doesAddBorderForTableAndCells||!cw.test(a.nodeName))&&(k+=parseFloat(d.borderTopWidth)||0,l+=parseFloat(d.borderLeftWidth)||0),g=e,e=a.offsetParent),f.support.subtractsBorderForOverflowNotVisible&&d.overflow!=="visible"&&(k+=parseFloat(d.borderTopWidth)||0,l+=parseFloat(d.borderLeftWidth)||0),j=d}if(j.position==="relative"||j.position==="static")k+=h.offsetTop,l+=h.offsetLeft;f.support.fixedPosition&&j.position==="fixed"&&(k+=Math.max(c.scrollTop,h.scrollTop),l+=Math.max(c.scrollLeft,h.scrollLeft));return{top:k,left:l}},f.fn.offset=function(a){if(arguments.length)return a===b?this:this.each(function(b){f.offset.setOffset(this,a,b)});var c=this[0],d=c&&c.ownerDocument;if(!d)return null;if(c===d.body)return f.offset.bodyOffset(c);return cv(c,d,d.documentElement)},f.offset={bodyOffset:function(a){var b=a.offsetTop,c=a.offsetLeft;f.support.doesNotIncludeMarginInBodyOffset&&(b+=parseFloat(f.css(a,"marginTop"))||0,c+=parseFloat(f.css(a,"marginLeft"))||0);return{top:b,left:c}},setOffset:function(a,b,c){var d=f.css(a,"position");d==="static"&&(a.style.position="relative");var e=f(a),g=e.offset(),h=f.css(a,"top"),i=f.css(a,"left"),j=(d==="absolute"||d==="fixed")&&f.inArray("auto",[h,i])>-1,k={},l={},m,n;j?(l=e.position(),m=l.top,n=l.left):(m=parseFloat(h)||0,n=parseFloat(i)||0),f.isFunction(b)&&(b=b.call(a,c,g)),b.top!=null&&(k.top=b.top-g.top+m),b.left!=null&&(k.left=b.left-g.left+n),"using"in b?b.using.call(a,k):e.css(k)}},f.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),c=this.offset(),d=cx.test(b[0].nodeName)?{top:0,left:0}:b.offset();c.top-=parseFloat(f.css(a,"marginTop"))||0,c.left-=parseFloat(f.css(a,"marginLeft"))||0,d.top+=parseFloat(f.css(b[0],"borderTopWidth"))||0,d.left+=parseFloat(f.css(b[0],"borderLeftWidth"))||0;return{top:c.top-d.top,left:c.left-d.left}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||c.body;while(a&&!cx.test(a.nodeName)&&f.css(a,"position")==="static")a=a.offsetParent;return a})}}),f.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(a,c){var d=/Y/.test(c);f.fn[a]=function(e){return f.access(this,function(a,e,g){var h=cy(a);if(g===b)return h?c in h?h[c]:f.support.boxModel&&h.document.documentElement[e]||h.document.body[e]:a[e];h?h.scrollTo(d?f(h).scrollLeft():g,d?g:f(h).scrollTop()):a[e]=g},a,e,arguments.length,null)}}),f.each({Height:"height",Width:"width"},function(a,c){var d="client"+a,e="scroll"+a,g="offset"+a;f.fn["inner"+a]=function(){var a=this[0];return a?a.style?parseFloat(f.css(a,c,"padding")):this[c]():null},f.fn["outer"+a]=function(a){var b=this[0];return b?b.style?parseFloat(f.css(b,c,a?"margin":"border")):this[c]():null},f.fn[c]=function(a){return f.access(this,function(a,c,h){var i,j,k,l;if(f.isWindow(a)){i=a.document,j=i.documentElement[d];return f.support.boxModel&&j||i.body&&i.body[d]||j}if(a.nodeType===9){i=a.documentElement;if(i[d]>=i[e])return i[d];return Math.max(a.body[e],i[e],a.body[g],i[g])}if(h===b){k=f.css(a,c),l=parseFloat(k);return f.isNumeric(l)?l:k}f(a).css(c,h)},c,a,arguments.length,null)}}),a.jQuery=a.$=f,typeof define=="function"&&define.amd&&define.amd.jQuery&&define("jquery",[],function(){return f})})(window);
```

`LibreHardwareMonitor/Resources/Web/js/jquery-ui-1.8.16.custom.min.js`:

```js
/*!
 * jQuery UI 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI
 */
(function(c,j){function k(a,b){var d=a.nodeName.toLowerCase();if("area"===d){b=a.parentNode;d=b.name;if(!a.href||!d||b.nodeName.toLowerCase()!=="map")return false;a=c("img[usemap=#"+d+"]")[0];return!!a&&l(a)}return(/input|select|textarea|button|object/.test(d)?!a.disabled:"a"==d?a.href||b:b)&&l(a)}function l(a){return!c(a).parents().andSelf().filter(function(){return c.curCSS(this,"visibility")==="hidden"||c.expr.filters.hidden(this)}).length}c.ui=c.ui||{};if(!c.ui.version){c.extend(c.ui,{version:"1.8.16",
keyCode:{ALT:18,BACKSPACE:8,CAPS_LOCK:20,COMMA:188,COMMAND:91,COMMAND_LEFT:91,COMMAND_RIGHT:93,CONTROL:17,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,INSERT:45,LEFT:37,MENU:93,NUMPAD_ADD:107,NUMPAD_DECIMAL:110,NUMPAD_DIVIDE:111,NUMPAD_ENTER:108,NUMPAD_MULTIPLY:106,NUMPAD_SUBTRACT:109,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SHIFT:16,SPACE:32,TAB:9,UP:38,WINDOWS:91}});c.fn.extend({propAttr:c.fn.prop||c.fn.attr,_focus:c.fn.focus,focus:function(a,b){return typeof a==="number"?this.each(function(){var d=
this;setTimeout(function(){c(d).focus();b&&b.call(d)},a)}):this._focus.apply(this,arguments)},scrollParent:function(){var a;a=c.browser.msie&&/(static|relative)/.test(this.css("position"))||/absolute/.test(this.css("position"))?this.parents().filter(function(){return/(relative|absolute|fixed)/.test(c.curCSS(this,"position",1))&&/(auto|scroll)/.test(c.curCSS(this,"overflow",1)+c.curCSS(this,"overflow-y",1)+c.curCSS(this,"overflow-x",1))}).eq(0):this.parents().filter(function(){return/(auto|scroll)/.test(c.curCSS(this,
"overflow",1)+c.curCSS(this,"overflow-y",1)+c.curCSS(this,"overflow-x",1))}).eq(0);return/fixed/.test(this.css("position"))||!a.length?c(document):a},zIndex:function(a){if(a!==j)return this.css("zIndex",a);if(this.length){a=c(this[0]);for(var b;a.length&&a[0]!==document;){b=a.css("position");if(b==="absolute"||b==="relative"||b==="fixed"){b=parseInt(a.css("zIndex"),10);if(!isNaN(b)&&b!==0)return b}a=a.parent()}}return 0},disableSelection:function(){return this.bind((c.support.selectstart?"selectstart":
"mousedown")+".ui-disableSelection",function(a){a.preventDefault()})},enableSelection:function(){return this.unbind(".ui-disableSelection")}});c.each(["Width","Height"],function(a,b){function d(f,g,m,n){c.each(e,function(){g-=parseFloat(c.curCSS(f,"padding"+this,true))||0;if(m)g-=parseFloat(c.curCSS(f,"border"+this+"Width",true))||0;if(n)g-=parseFloat(c.curCSS(f,"margin"+this,true))||0});return g}var e=b==="Width"?["Left","Right"]:["Top","Bottom"],h=b.toLowerCase(),i={innerWidth:c.fn.innerWidth,innerHeight:c.fn.innerHeight,
outerWidth:c.fn.outerWidth,outerHeight:c.fn.outerHeight};c.fn["inner"+b]=function(f){if(f===j)return i["inner"+b].call(this);return this.each(function(){c(this).css(h,d(this,f)+"px")})};c.fn["outer"+b]=function(f,g){if(typeof f!=="number")return i["outer"+b].call(this,f);return this.each(function(){c(this).css(h,d(this,f,true,g)+"px")})}});c.extend(c.expr[":"],{data:function(a,b,d){return!!c.data(a,d[3])},focusable:function(a){return k(a,!isNaN(c.attr(a,"tabindex")))},tabbable:function(a){var b=c.attr(a,
"tabindex"),d=isNaN(b);return(d||b>=0)&&k(a,!d)}});c(function(){var a=document.body,b=a.appendChild(b=document.createElement("div"));c.extend(b.style,{minHeight:"100px",height:"auto",padding:0,borderWidth:0});c.support.minHeight=b.offsetHeight===100;c.support.selectstart="onselectstart"in b;a.removeChild(b).style.display="none"});c.extend(c.ui,{plugin:{add:function(a,b,d){a=c.ui[a].prototype;for(var e in d){a.plugins[e]=a.plugins[e]||[];a.plugins[e].push([b,d[e]])}},call:function(a,b,d){if((b=a.plugins[b])&&
a.element[0].parentNode)for(var e=0;e<b.length;e++)a.options[b[e][0]]&&b[e][1].apply(a.element,d)}},contains:function(a,b){return document.compareDocumentPosition?a.compareDocumentPosition(b)&16:a!==b&&a.contains(b)},hasScroll:function(a,b){if(c(a).css("overflow")==="hidden")return false;b=b&&b==="left"?"scrollLeft":"scrollTop";var d=false;if(a[b]>0)return true;a[b]=1;d=a[b]>0;a[b]=0;return d},isOverAxis:function(a,b,d){return a>b&&a<b+d},isOver:function(a,b,d,e,h,i){return c.ui.isOverAxis(a,d,h)&&
c.ui.isOverAxis(b,e,i)}})}})(jQuery);
;/*!
 * jQuery UI Widget 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Widget
 */
(function(b,j){if(b.cleanData){var k=b.cleanData;b.cleanData=function(a){for(var c=0,d;(d=a[c])!=null;c++)try{b(d).triggerHandler("remove")}catch(e){}k(a)}}else{var l=b.fn.remove;b.fn.remove=function(a,c){return this.each(function(){if(!c)if(!a||b.filter(a,[this]).length)b("*",this).add([this]).each(function(){try{b(this).triggerHandler("remove")}catch(d){}});return l.call(b(this),a,c)})}}b.widget=function(a,c,d){var e=a.split(".")[0],f;a=a.split(".")[1];f=e+"-"+a;if(!d){d=c;c=b.Widget}b.expr[":"][f]=
function(h){return!!b.data(h,a)};b[e]=b[e]||{};b[e][a]=function(h,g){arguments.length&&this._createWidget(h,g)};c=new c;c.options=b.extend(true,{},c.options);b[e][a].prototype=b.extend(true,c,{namespace:e,widgetName:a,widgetEventPrefix:b[e][a].prototype.widgetEventPrefix||a,widgetBaseClass:f},d);b.widget.bridge(a,b[e][a])};b.widget.bridge=function(a,c){b.fn[a]=function(d){var e=typeof d==="string",f=Array.prototype.slice.call(arguments,1),h=this;d=!e&&f.length?b.extend.apply(null,[true,d].concat(f)):
d;if(e&&d.charAt(0)==="_")return h;e?this.each(function(){var g=b.data(this,a),i=g&&b.isFunction(g[d])?g[d].apply(g,f):g;if(i!==g&&i!==j){h=i;return false}}):this.each(function(){var g=b.data(this,a);g?g.option(d||{})._init():b.data(this,a,new c(d,this))});return h}};b.Widget=function(a,c){arguments.length&&this._createWidget(a,c)};b.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",options:{disabled:false},_createWidget:function(a,c){b.data(c,this.widgetName,this);this.element=b(c);this.options=
b.extend(true,{},this.options,this._getCreateOptions(),a);var d=this;this.element.bind("remove."+this.widgetName,function(){d.destroy()});this._create();this._trigger("create");this._init()},_getCreateOptions:function(){return b.metadata&&b.metadata.get(this.element[0])[this.widgetName]},_create:function(){},_init:function(){},destroy:function(){this.element.unbind("."+this.widgetName).removeData(this.widgetName);this.widget().unbind("."+this.widgetName).removeAttr("aria-disabled").removeClass(this.widgetBaseClass+
"-disabled ui-state-disabled")},widget:function(){return this.element},option:function(a,c){var d=a;if(arguments.length===0)return b.extend({},this.options);if(typeof a==="string"){if(c===j)return this.options[a];d={};d[a]=c}this._setOptions(d);return this},_setOptions:function(a){var c=this;b.each(a,function(d,e){c._setOption(d,e)});return this},_setOption:function(a,c){this.options[a]=c;if(a==="disabled")this.widget()[c?"addClass":"removeClass"](this.widgetBaseClass+"-disabled ui-state-disabled").attr("aria-disabled",
c);return this},enable:function(){return this._setOption("disabled",false)},disable:function(){return this._setOption("disabled",true)},_trigger:function(a,c,d){var e=this.options[a];c=b.Event(c);c.type=(a===this.widgetEventPrefix?a:this.widgetEventPrefix+a).toLowerCase();d=d||{};if(c.originalEvent){a=b.event.props.length;for(var f;a;){f=b.event.props[--a];c[f]=c.originalEvent[f]}}this.element.trigger(c,d);return!(b.isFunction(e)&&e.call(this.element[0],c,d)===false||c.isDefaultPrevented())}}})(jQuery);
;/*!
 * jQuery UI Mouse 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Mouse
 *
 * Depends:
 *	jquery.ui.widget.js
 */
(function(b){var d=false;b(document).mouseup(function(){d=false});b.widget("ui.mouse",{options:{cancel:":input,option",distance:1,delay:0},_mouseInit:function(){var a=this;this.element.bind("mousedown."+this.widgetName,function(c){return a._mouseDown(c)}).bind("click."+this.widgetName,function(c){if(true===b.data(c.target,a.widgetName+".preventClickEvent")){b.removeData(c.target,a.widgetName+".preventClickEvent");c.stopImmediatePropagation();return false}});this.started=false},_mouseDestroy:function(){this.element.unbind("."+
this.widgetName)},_mouseDown:function(a){if(!d){this._mouseStarted&&this._mouseUp(a);this._mouseDownEvent=a;var c=this,f=a.which==1,g=typeof this.options.cancel=="string"&&a.target.nodeName?b(a.target).closest(this.options.cancel).length:false;if(!f||g||!this._mouseCapture(a))return true;this.mouseDelayMet=!this.options.delay;if(!this.mouseDelayMet)this._mouseDelayTimer=setTimeout(function(){c.mouseDelayMet=true},this.options.delay);if(this._mouseDistanceMet(a)&&this._mouseDelayMet(a)){this._mouseStarted=
this._mouseStart(a)!==false;if(!this._mouseStarted){a.preventDefault();return true}}true===b.data(a.target,this.widgetName+".preventClickEvent")&&b.removeData(a.target,this.widgetName+".preventClickEvent");this._mouseMoveDelegate=function(e){return c._mouseMove(e)};this._mouseUpDelegate=function(e){return c._mouseUp(e)};b(document).bind("mousemove."+this.widgetName,this._mouseMoveDelegate).bind("mouseup."+this.widgetName,this._mouseUpDelegate);a.preventDefault();return d=true}},_mouseMove:function(a){if(b.browser.msie&&
!(document.documentMode>=9)&&!a.button)return this._mouseUp(a);if(this._mouseStarted){this._mouseDrag(a);return a.preventDefault()}if(this._mouseDistanceMet(a)&&this._mouseDelayMet(a))(this._mouseStarted=this._mouseStart(this._mouseDownEvent,a)!==false)?this._mouseDrag(a):this._mouseUp(a);return!this._mouseStarted},_mouseUp:function(a){b(document).unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate);if(this._mouseStarted){this._mouseStarted=
false;a.target==this._mouseDownEvent.target&&b.data(a.target,this.widgetName+".preventClickEvent",true);this._mouseStop(a)}return false},_mouseDistanceMet:function(a){return Math.max(Math.abs(this._mouseDownEvent.pageX-a.pageX),Math.abs(this._mouseDownEvent.pageY-a.pageY))>=this.options.distance},_mouseDelayMet:function(){return this.mouseDelayMet},_mouseStart:function(){},_mouseDrag:function(){},_mouseStop:function(){},_mouseCapture:function(){return true}})})(jQuery);
;/*
 * jQuery UI Button 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Button
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 */
(function(b){var h,i,j,g,l=function(){var a=b(this).find(":ui-button");setTimeout(function(){a.button("refresh")},1)},k=function(a){var c=a.name,e=a.form,f=b([]);if(c)f=e?b(e).find("[name='"+c+"']"):b("[name='"+c+"']",a.ownerDocument).filter(function(){return!this.form});return f};b.widget("ui.button",{options:{disabled:null,text:true,label:null,icons:{primary:null,secondary:null}},_create:function(){this.element.closest("form").unbind("reset.button").bind("reset.button",l);if(typeof this.options.disabled!==
"boolean")this.options.disabled=this.element.propAttr("disabled");this._determineButtonType();this.hasTitle=!!this.buttonElement.attr("title");var a=this,c=this.options,e=this.type==="checkbox"||this.type==="radio",f="ui-state-hover"+(!e?" ui-state-active":"");if(c.label===null)c.label=this.buttonElement.html();if(this.element.is(":disabled"))c.disabled=true;this.buttonElement.addClass("ui-button ui-widget ui-state-default ui-corner-all").attr("role","button").bind("mouseenter.button",function(){if(!c.disabled){b(this).addClass("ui-state-hover");
this===h&&b(this).addClass("ui-state-active")}}).bind("mouseleave.button",function(){c.disabled||b(this).removeClass(f)}).bind("click.button",function(d){if(c.disabled){d.preventDefault();d.stopImmediatePropagation()}});this.element.bind("focus.button",function(){a.buttonElement.addClass("ui-state-focus")}).bind("blur.button",function(){a.buttonElement.removeClass("ui-state-focus")});if(e){this.element.bind("change.button",function(){g||a.refresh()});this.buttonElement.bind("mousedown.button",function(d){if(!c.disabled){g=
false;i=d.pageX;j=d.pageY}}).bind("mouseup.button",function(d){if(!c.disabled)if(i!==d.pageX||j!==d.pageY)g=true})}if(this.type==="checkbox")this.buttonElement.bind("click.button",function(){if(c.disabled||g)return false;b(this).toggleClass("ui-state-active");a.buttonElement.attr("aria-pressed",a.element[0].checked)});else if(this.type==="radio")this.buttonElement.bind("click.button",function(){if(c.disabled||g)return false;b(this).addClass("ui-state-active");a.buttonElement.attr("aria-pressed","true");
var d=a.element[0];k(d).not(d).map(function(){return b(this).button("widget")[0]}).removeClass("ui-state-active").attr("aria-pressed","false")});else{this.buttonElement.bind("mousedown.button",function(){if(c.disabled)return false;b(this).addClass("ui-state-active");h=this;b(document).one("mouseup",function(){h=null})}).bind("mouseup.button",function(){if(c.disabled)return false;b(this).removeClass("ui-state-active")}).bind("keydown.button",function(d){if(c.disabled)return false;if(d.keyCode==b.ui.keyCode.SPACE||
d.keyCode==b.ui.keyCode.ENTER)b(this).addClass("ui-state-active")}).bind("keyup.button",function(){b(this).removeClass("ui-state-active")});this.buttonElement.is("a")&&this.buttonElement.keyup(function(d){d.keyCode===b.ui.keyCode.SPACE&&b(this).click()})}this._setOption("disabled",c.disabled);this._resetButton()},_determineButtonType:function(){this.type=this.element.is(":checkbox")?"checkbox":this.element.is(":radio")?"radio":this.element.is("input")?"input":"button";if(this.type==="checkbox"||this.type===
"radio"){var a=this.element.parents().filter(":last"),c="label[for='"+this.element.attr("id")+"']";this.buttonElement=a.find(c);if(!this.buttonElement.length){a=a.length?a.siblings():this.element.siblings();this.buttonElement=a.filter(c);if(!this.buttonElement.length)this.buttonElement=a.find(c)}this.element.addClass("ui-helper-hidden-accessible");(a=this.element.is(":checked"))&&this.buttonElement.addClass("ui-state-active");this.buttonElement.attr("aria-pressed",a)}else this.buttonElement=this.element},
widget:function(){return this.buttonElement},destroy:function(){this.element.removeClass("ui-helper-hidden-accessible");this.buttonElement.removeClass("ui-button ui-widget ui-state-default ui-corner-all ui-state-hover ui-state-active  ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only").removeAttr("role").removeAttr("aria-pressed").html(this.buttonElement.find(".ui-button-text").html());this.hasTitle||this.buttonElement.removeAttr("title");
b.Widget.prototype.destroy.call(this)},_setOption:function(a,c){b.Widget.prototype._setOption.apply(this,arguments);if(a==="disabled")c?this.element.propAttr("disabled",true):this.element.propAttr("disabled",false);else this._resetButton()},refresh:function(){var a=this.element.is(":disabled");a!==this.options.disabled&&this._setOption("disabled",a);if(this.type==="radio")k(this.element[0]).each(function(){b(this).is(":checked")?b(this).button("widget").addClass("ui-state-active").attr("aria-pressed",
"true"):b(this).button("widget").removeClass("ui-state-active").attr("aria-pressed","false")});else if(this.type==="checkbox")this.element.is(":checked")?this.buttonElement.addClass("ui-state-active").attr("aria-pressed","true"):this.buttonElement.removeClass("ui-state-active").attr("aria-pressed","false")},_resetButton:function(){if(this.type==="input")this.options.label&&this.element.val(this.options.label);else{var a=this.buttonElement.removeClass("ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only"),
c=b("<span></span>").addClass("ui-button-text").html(this.options.label).appendTo(a.empty()).text(),e=this.options.icons,f=e.primary&&e.secondary,d=[];if(e.primary||e.secondary){if(this.options.text)d.push("ui-button-text-icon"+(f?"s":e.primary?"-primary":"-secondary"));e.primary&&a.prepend("<span class='ui-button-icon-primary ui-icon "+e.primary+"'></span>");e.secondary&&a.append("<span class='ui-button-icon-secondary ui-icon "+e.secondary+"'></span>");if(!this.options.text){d.push(f?"ui-button-icons-only":
"ui-button-icon-only");this.hasTitle||a.attr("title",c)}}else d.push("ui-button-text-only");a.addClass(d.join(" "))}}});b.widget("ui.buttonset",{options:{items:":button, :submit, :reset, :checkbox, :radio, a, :data(button)"},_create:function(){this.element.addClass("ui-buttonset")},_init:function(){this.refresh()},_setOption:function(a,c){a==="disabled"&&this.buttons.button("option",a,c);b.Widget.prototype._setOption.apply(this,arguments)},refresh:function(){var a=this.element.css("direction")===
"ltr";this.buttons=this.element.find(this.options.items).filter(":ui-button").button("refresh").end().not(":ui-button").button().end().map(function(){return b(this).button("widget")[0]}).removeClass("ui-corner-all ui-corner-left ui-corner-right").filter(":first").addClass(a?"ui-corner-left":"ui-corner-right").end().filter(":last").addClass(a?"ui-corner-right":"ui-corner-left").end().end()},destroy:function(){this.element.removeClass("ui-buttonset");this.buttons.map(function(){return b(this).button("widget")[0]}).removeClass("ui-corner-left ui-corner-right").end().button("destroy");
b.Widget.prototype.destroy.call(this)}})})(jQuery);
;/*
 * jQuery UI Slider 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Slider
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function(d){d.widget("ui.slider",d.ui.mouse,{widgetEventPrefix:"slide",options:{animate:false,distance:0,max:100,min:0,orientation:"horizontal",range:false,step:1,value:0,values:null},_create:function(){var a=this,b=this.options,c=this.element.find(".ui-slider-handle").addClass("ui-state-default ui-corner-all"),f=b.values&&b.values.length||1,e=[];this._mouseSliding=this._keySliding=false;this._animateOff=true;this._handleIndex=null;this._detectOrientation();this._mouseInit();this.element.addClass("ui-slider ui-slider-"+
this.orientation+" ui-widget ui-widget-content ui-corner-all"+(b.disabled?" ui-slider-disabled ui-disabled":""));this.range=d([]);if(b.range){if(b.range===true){if(!b.values)b.values=[this._valueMin(),this._valueMin()];if(b.values.length&&b.values.length!==2)b.values=[b.values[0],b.values[0]]}this.range=d("<div></div>").appendTo(this.element).addClass("ui-slider-range ui-widget-header"+(b.range==="min"||b.range==="max"?" ui-slider-range-"+b.range:""))}for(var j=c.length;j<f;j+=1)e.push("<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>");
this.handles=c.add(d(e.join("")).appendTo(a.element));this.handle=this.handles.eq(0);this.handles.add(this.range).filter("a").click(function(g){g.preventDefault()}).hover(function(){b.disabled||d(this).addClass("ui-state-hover")},function(){d(this).removeClass("ui-state-hover")}).focus(function(){if(b.disabled)d(this).blur();else{d(".ui-slider .ui-state-focus").removeClass("ui-state-focus");d(this).addClass("ui-state-focus")}}).blur(function(){d(this).removeClass("ui-state-focus")});this.handles.each(function(g){d(this).data("index.ui-slider-handle",
g)});this.handles.keydown(function(g){var k=true,l=d(this).data("index.ui-slider-handle"),i,h,m;if(!a.options.disabled){switch(g.keyCode){case d.ui.keyCode.HOME:case d.ui.keyCode.END:case d.ui.keyCode.PAGE_UP:case d.ui.keyCode.PAGE_DOWN:case d.ui.keyCode.UP:case d.ui.keyCode.RIGHT:case d.ui.keyCode.DOWN:case d.ui.keyCode.LEFT:k=false;if(!a._keySliding){a._keySliding=true;d(this).addClass("ui-state-active");i=a._start(g,l);if(i===false)return}break}m=a.options.step;i=a.options.values&&a.options.values.length?
(h=a.values(l)):(h=a.value());switch(g.keyCode){case d.ui.keyCode.HOME:h=a._valueMin();break;case d.ui.keyCode.END:h=a._valueMax();break;case d.ui.keyCode.PAGE_UP:h=a._trimAlignValue(i+(a._valueMax()-a._valueMin())/5);break;case d.ui.keyCode.PAGE_DOWN:h=a._trimAlignValue(i-(a._valueMax()-a._valueMin())/5);break;case d.ui.keyCode.UP:case d.ui.keyCode.RIGHT:if(i===a._valueMax())return;h=a._trimAlignValue(i+m);break;case d.ui.keyCode.DOWN:case d.ui.keyCode.LEFT:if(i===a._valueMin())return;h=a._trimAlignValue(i-
m);break}a._slide(g,l,h);return k}}).keyup(function(g){var k=d(this).data("index.ui-slider-handle");if(a._keySliding){a._keySliding=false;a._stop(g,k);a._change(g,k);d(this).removeClass("ui-state-active")}});this._refreshValue();this._animateOff=false},destroy:function(){this.handles.remove();this.range.remove();this.element.removeClass("ui-slider ui-slider-horizontal ui-slider-vertical ui-slider-disabled ui-widget ui-widget-content ui-corner-all").removeData("slider").unbind(".slider");this._mouseDestroy();
return this},_mouseCapture:function(a){var b=this.options,c,f,e,j,g;if(b.disabled)return false;this.elementSize={width:this.element.outerWidth(),height:this.element.outerHeight()};this.elementOffset=this.element.offset();c=this._normValueFromMouse({x:a.pageX,y:a.pageY});f=this._valueMax()-this._valueMin()+1;j=this;this.handles.each(function(k){var l=Math.abs(c-j.values(k));if(f>l){f=l;e=d(this);g=k}});if(b.range===true&&this.values(1)===b.min){g+=1;e=d(this.handles[g])}if(this._start(a,g)===false)return false;
this._mouseSliding=true;j._handleIndex=g;e.addClass("ui-state-active").focus();b=e.offset();this._clickOffset=!d(a.target).parents().andSelf().is(".ui-slider-handle")?{left:0,top:0}:{left:a.pageX-b.left-e.width()/2,top:a.pageY-b.top-e.height()/2-(parseInt(e.css("borderTopWidth"),10)||0)-(parseInt(e.css("borderBottomWidth"),10)||0)+(parseInt(e.css("marginTop"),10)||0)};this.handles.hasClass("ui-state-hover")||this._slide(a,g,c);return this._animateOff=true},_mouseStart:function(){return true},_mouseDrag:function(a){var b=
this._normValueFromMouse({x:a.pageX,y:a.pageY});this._slide(a,this._handleIndex,b);return false},_mouseStop:function(a){this.handles.removeClass("ui-state-active");this._mouseSliding=false;this._stop(a,this._handleIndex);this._change(a,this._handleIndex);this._clickOffset=this._handleIndex=null;return this._animateOff=false},_detectOrientation:function(){this.orientation=this.options.orientation==="vertical"?"vertical":"horizontal"},_normValueFromMouse:function(a){var b;if(this.orientation==="horizontal"){b=
this.elementSize.width;a=a.x-this.elementOffset.left-(this._clickOffset?this._clickOffset.left:0)}else{b=this.elementSize.height;a=a.y-this.elementOffset.top-(this._clickOffset?this._clickOffset.top:0)}b=a/b;if(b>1)b=1;if(b<0)b=0;if(this.orientation==="vertical")b=1-b;a=this._valueMax()-this._valueMin();return this._trimAlignValue(this._valueMin()+b*a)},_start:function(a,b){var c={handle:this.handles[b],value:this.value()};if(this.options.values&&this.options.values.length){c.value=this.values(b);
c.values=this.values()}return this._trigger("start",a,c)},_slide:function(a,b,c){var f;if(this.options.values&&this.options.values.length){f=this.values(b?0:1);if(this.options.values.length===2&&this.options.range===true&&(b===0&&c>f||b===1&&c<f))c=f;if(c!==this.values(b)){f=this.values();f[b]=c;a=this._trigger("slide",a,{handle:this.handles[b],value:c,values:f});this.values(b?0:1);a!==false&&this.values(b,c,true)}}else if(c!==this.value()){a=this._trigger("slide",a,{handle:this.handles[b],value:c});
a!==false&&this.value(c)}},_stop:function(a,b){var c={handle:this.handles[b],value:this.value()};if(this.options.values&&this.options.values.length){c.value=this.values(b);c.values=this.values()}this._trigger("stop",a,c)},_change:function(a,b){if(!this._keySliding&&!this._mouseSliding){var c={handle:this.handles[b],value:this.value()};if(this.options.values&&this.options.values.length){c.value=this.values(b);c.values=this.values()}this._trigger("change",a,c)}},value:function(a){if(arguments.length){this.options.value=
this._trimAlignValue(a);this._refreshValue();this._change(null,0)}else return this._value()},values:function(a,b){var c,f,e;if(arguments.length>1){this.options.values[a]=this._trimAlignValue(b);this._refreshValue();this._change(null,a)}else if(arguments.length)if(d.isArray(arguments[0])){c=this.options.values;f=arguments[0];for(e=0;e<c.length;e+=1){c[e]=this._trimAlignValue(f[e]);this._change(null,e)}this._refreshValue()}else return this.options.values&&this.options.values.length?this._values(a):
this.value();else return this._values()},_setOption:function(a,b){var c,f=0;if(d.isArray(this.options.values))f=this.options.values.length;d.Widget.prototype._setOption.apply(this,arguments);switch(a){case "disabled":if(b){this.handles.filter(".ui-state-focus").blur();this.handles.removeClass("ui-state-hover");this.handles.propAttr("disabled",true);this.element.addClass("ui-disabled")}else{this.handles.propAttr("disabled",false);this.element.removeClass("ui-disabled")}break;case "orientation":this._detectOrientation();
this.element.removeClass("ui-slider-horizontal ui-slider-vertical").addClass("ui-slider-"+this.orientation);this._refreshValue();break;case "value":this._animateOff=true;this._refreshValue();this._change(null,0);this._animateOff=false;break;case "values":this._animateOff=true;this._refreshValue();for(c=0;c<f;c+=1)this._change(null,c);this._animateOff=false;break}},_value:function(){var a=this.options.value;return a=this._trimAlignValue(a)},_values:function(a){var b,c;if(arguments.length){b=this.options.values[a];
return b=this._trimAlignValue(b)}else{b=this.options.values.slice();for(c=0;c<b.length;c+=1)b[c]=this._trimAlignValue(b[c]);return b}},_trimAlignValue:function(a){if(a<=this._valueMin())return this._valueMin();if(a>=this._valueMax())return this._valueMax();var b=this.options.step>0?this.options.step:1,c=(a-this._valueMin())%b;a=a-c;if(Math.abs(c)*2>=b)a+=c>0?b:-b;return parseFloat(a.toFixed(5))},_valueMin:function(){return this.options.min},_valueMax:function(){return this.options.max},_refreshValue:function(){var a=
this.options.range,b=this.options,c=this,f=!this._animateOff?b.animate:false,e,j={},g,k,l,i;if(this.options.values&&this.options.values.length)this.handles.each(function(h){e=(c.values(h)-c._valueMin())/(c._valueMax()-c._valueMin())*100;j[c.orientation==="horizontal"?"left":"bottom"]=e+"%";d(this).stop(1,1)[f?"animate":"css"](j,b.animate);if(c.options.range===true)if(c.orientation==="horizontal"){if(h===0)c.range.stop(1,1)[f?"animate":"css"]({left:e+"%"},b.animate);if(h===1)c.range[f?"animate":"css"]({width:e-
g+"%"},{queue:false,duration:b.animate})}else{if(h===0)c.range.stop(1,1)[f?"animate":"css"]({bottom:e+"%"},b.animate);if(h===1)c.range[f?"animate":"css"]({height:e-g+"%"},{queue:false,duration:b.animate})}g=e});else{k=this.value();l=this._valueMin();i=this._valueMax();e=i!==l?(k-l)/(i-l)*100:0;j[c.orientation==="horizontal"?"left":"bottom"]=e+"%";this.handle.stop(1,1)[f?"animate":"css"](j,b.animate);if(a==="min"&&this.orientation==="horizontal")this.range.stop(1,1)[f?"animate":"css"]({width:e+"%"},
b.animate);if(a==="max"&&this.orientation==="horizontal")this.range[f?"animate":"css"]({width:100-e+"%"},{queue:false,duration:b.animate});if(a==="min"&&this.orientation==="vertical")this.range.stop(1,1)[f?"animate":"css"]({height:e+"%"},b.animate);if(a==="max"&&this.orientation==="vertical")this.range[f?"animate":"css"]({height:100-e+"%"},{queue:false,duration:b.animate})}}});d.extend(d.ui.slider,{version:"1.8.16"})})(jQuery);
;
```

`LibreHardwareMonitor/Resources/Web/js/jquery.tmpl.js`:

```js
/*!
 * jQuery Templates Plugin 1.0.0pre
 * http://github.com/jquery/jquery-tmpl
 * Requires jQuery 1.4.2
 *
 * Copyright 2011, Software Freedom Conservancy, Inc.
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 */
(function( jQuery, undefined ){
	var oldManip = jQuery.fn.domManip, tmplItmAtt = "_tmplitem", htmlExpr = /^[^<]*(<[\w\W]+>)[^>]*$|\{\{\! /,
		newTmplItems = {}, wrappedItems = {}, appendToTmplItems, topTmplItem = { key: 0, data: {} }, itemKey = 0, cloneIndex = 0, stack = [];

	function newTmplItem( options, parentItem, fn, data ) {
		// Returns a template item data structure for a new rendered instance of a template (a 'template item').
		// The content field is a hierarchical array of strings and nested items (to be
		// removed and replaced by nodes field of dom elements, once inserted in DOM).
		var newItem = {
			data: data || (data === 0 || data === false) ? data : (parentItem ? parentItem.data : {}),
			_wrap: parentItem ? parentItem._wrap : null,
			tmpl: null,
			parent: parentItem || null,
			nodes: [],
			calls: tiCalls,
			nest: tiNest,
			wrap: tiWrap,
			html: tiHtml,
			update: tiUpdate
		};
		if ( options ) {
			jQuery.extend( newItem, options, { nodes: [], parent: parentItem });
		}
		if ( fn ) {
			// Build the hierarchical content to be used during insertion into DOM
			newItem.tmpl = fn;
			newItem._ctnt = newItem._ctnt || newItem.tmpl( jQuery, newItem );
			newItem.key = ++itemKey;
			// Keep track of new template item, until it is stored as jQuery Data on DOM element
			(stack.length ? wrappedItems : newTmplItems)[itemKey] = newItem;
		}
		return newItem;
	}

	// Override appendTo etc., in order to provide support for targeting multiple elements. (This code would disappear if integrated in jquery core).
	jQuery.each({
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var ret = [], insert = jQuery( selector ), elems, i, l, tmplItems,
				parent = this.length === 1 && this[0].parentNode;

			appendToTmplItems = newTmplItems || {};
			if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
				insert[ original ]( this[0] );
				ret = this;
			} else {
				for ( i = 0, l = insert.length; i < l; i++ ) {
					cloneIndex = i;
					elems = (i > 0 ? this.clone(true) : this).get();
					jQuery( insert[i] )[ original ]( elems );
					ret = ret.concat( elems );
				}
				cloneIndex = 0;
				ret = this.pushStack( ret, name, insert.selector );
			}
			tmplItems = appendToTmplItems;
			appendToTmplItems = null;
			jQuery.tmpl.complete( tmplItems );
			return ret;
		};
	});

	jQuery.fn.extend({
		// Use first wrapped element as template markup.
		// Return wrapped set of template items, obtained by rendering template against data.
		tmpl: function( data, options, parentItem ) {
			return jQuery.tmpl( this[0], data, options, parentItem );
		},

		// Find which rendered template item the first wrapped DOM element belongs to
		tmplItem: function() {
			return jQuery.tmplItem( this[0] );
		},

		// Consider the first wrapped element as a template declaration, and get the compiled template or store it as a named template.
		template: function( name ) {
			return jQuery.template( name, this[0] );
		},

		domManip: function( args, table, callback, options ) {
			if ( args[0] && jQuery.isArray( args[0] )) {
				var dmArgs = jQuery.makeArray( arguments ), elems = args[0], elemsLength = elems.length, i = 0, tmplItem;
				while ( i < elemsLength && !(tmplItem = jQuery.data( elems[i++], "tmplItem" ))) {}
				if ( tmplItem && cloneIndex ) {
					dmArgs[2] = function( fragClone ) {
						// Handler called by oldManip when rendered template has been inserted into DOM.
						jQuery.tmpl.afterManip( this, fragClone, callback );
					};
				}
				oldManip.apply( this, dmArgs );
			} else {
				oldManip.apply( this, arguments );
			}
			cloneIndex = 0;
			if ( !appendToTmplItems ) {
				jQuery.tmpl.complete( newTmplItems );
			}
			return this;
		}
	});

	jQuery.extend({
		// Return wrapped set of template items, obtained by rendering template against data.
		tmpl: function( tmpl, data, options, parentItem ) {
			var ret, topLevel = !parentItem;
			if ( topLevel ) {
				// This is a top-level tmpl call (not from a nested template using {{tmpl}})
				parentItem = topTmplItem;
				tmpl = jQuery.template[tmpl] || jQuery.template( null, tmpl );
				wrappedItems = {}; // Any wrapped items will be rebuilt, since this is top level
			} else if ( !tmpl ) {
				// The template item is already associated with DOM - this is a refresh.
				// Re-evaluate rendered template for the parentItem
				tmpl = parentItem.tmpl;
				newTmplItems[parentItem.key] = parentItem;
				parentItem.nodes = [];
				if ( parentItem.wrapped ) {
					updateWrapped( parentItem, parentItem.wrapped );
				}
				// Rebuild, without creating a new template item
				return jQuery( build( parentItem, null, parentItem.tmpl( jQuery, parentItem ) ));
			}
			if ( !tmpl ) {
				return []; // Could throw...
			}
			if ( typeof data === "function" ) {
				data = data.call( parentItem || {} );
			}
			if ( options && options.wrapped ) {
				updateWrapped( options, options.wrapped );
			}
			ret = jQuery.isArray( data ) ?
				jQuery.map( data, function( dataItem ) {
					return dataItem ? newTmplItem( options, parentItem, tmpl, dataItem ) : null;
				}) :
				[ newTmplItem( options, parentItem, tmpl, data ) ];
			return topLevel ? jQuery( build( parentItem, null, ret ) ) : ret;
		},

		// Return rendered template item for an element.
		tmplItem: function( elem ) {
			var tmplItem;
			if ( elem instanceof jQuery ) {
				elem = elem[0];
			}
			while ( elem && elem.nodeType === 1 && !(tmplItem = jQuery.data( elem, "tmplItem" )) && (elem = elem.parentNode) ) {}
			return tmplItem || topTmplItem;
		},

		// Set:
		// Use $.template( name, tmpl ) to cache a named template,
		// where tmpl is a template string, a script element or a jQuery instance wrapping a script element, etc.
		// Use $( "selector" ).template( name ) to provide access by name to a script block template declaration.

		// Get:
		// Use $.template( name ) to access a cached template.
		// Also $( selectorToScriptBlock ).template(), or $.template( null, templateString )
		// will return the compiled template, without adding a name reference.
		// If templateString includes at least one HTML tag, $.template( templateString ) is equivalent
		// to $.template( null, templateString )
		template: function( name, tmpl ) {
			if (tmpl) {
				// Compile template and associate with name
				if ( typeof tmpl === "string" ) {
					// This is an HTML string being passed directly in.
					tmpl = buildTmplFn( tmpl );
				} else if ( tmpl instanceof jQuery ) {
					tmpl = tmpl[0] || {};
				}
				if ( tmpl.nodeType ) {
					// If this is a template block, use cached copy, or generate tmpl function and cache.
					tmpl = jQuery.data( tmpl, "tmpl" ) || jQuery.data( tmpl, "tmpl", buildTmplFn( tmpl.innerHTML ));
					// Issue: In IE, if the container element is not a script block, the innerHTML will remove quotes from attribute values whenever the value does not include white space.
					// This means that foo="${x}" will not work if the value of x includes white space: foo="${x}" -> foo=value of x.
					// To correct this, include space in tag: foo="${ x }" -> foo="value of x"
				}
				return typeof name === "string" ? (jQuery.template[name] = tmpl) : tmpl;
			}
			// Return named compiled template
			return name ? (typeof name !== "string" ? jQuery.template( null, name ):
				(jQuery.template[name] ||
					// If not in map, and not containing at least on HTML tag, treat as a selector.
					// (If integrated with core, use quickExpr.exec)
					jQuery.template( null, htmlExpr.test( name ) ? name : jQuery( name )))) : null;
		},

		encode: function( text ) {
			// Do HTML encoding replacing < > & and ' and " by corresponding entities.
			return ("" + text).split("<").join("&lt;").split(">").join("&gt;").split('"').join("&#34;").split("'").join("&#39;");
		}
	});

	jQuery.extend( jQuery.tmpl, {
		tag: {
			"tmpl": {
				_default: { $2: "null" },
				open: "if($notnull_1){__=__.concat($item.nest($1,$2));}"
				// tmpl target parameter can be of type function, so use $1, not $1a (so not auto detection of functions)
				// This means that {{tmpl foo}} treats foo as a template (which IS a function).
				// Explicit parens can be used if foo is a function that returns a template: {{tmpl foo()}}.
			},
			"wrap": {
				_default: { $2: "null" },
				open: "$item.calls(__,$1,$2);__=[];",
				close: "call=$item.calls();__=call._.concat($item.wrap(call,__));"
			},
			"each": {
				_default: { $2: "$index, $value" },
				open: "if($notnull_1){$.each($1a,function($2){with(this){",
				close: "}});}"
			},
			"if": {
				open: "if(($notnull_1) && $1a){",
				close: "}"
			},
			"else": {
				_default: { $1: "true" },
				open: "}else if(($notnull_1) && $1a){"
			},
			"html": {
				// Unecoded expression evaluation.
				open: "if($notnull_1){__.push($1a);}"
			},
			"=": {
				// Encoded expression evaluation. Abbreviated form is ${}.
				_default: { $1: "$data" },
				open: "if($notnull_1){__.push($.encode($1a));}"
			},
			"!": {
				// Comment tag. Skipped by parser
				open: ""
			}
		},

		// This stub can be overridden, e.g. in jquery.tmplPlus for providing rendered events
		complete: function( items ) {
			newTmplItems = {};
		},

		// Call this from code which overrides domManip, or equivalent
		// Manage cloning/storing template items etc.
		afterManip: function afterManip( elem, fragClone, callback ) {
			// Provides cloned fragment ready for fixup prior to and after insertion into DOM
			var content = fragClone.nodeType === 11 ?
				jQuery.makeArray(fragClone.childNodes) :
				fragClone.nodeType === 1 ? [fragClone] : [];

			// Return fragment to original caller (e.g. append) for DOM insertion
			callback.call( elem, fragClone );

			// Fragment has been inserted:- Add inserted nodes to tmplItem data structure. Replace inserted element annotations by jQuery.data.
			storeTmplItems( content );
			cloneIndex++;
		}
	});

	//========================== Private helper functions, used by code above ==========================

	function build( tmplItem, nested, content ) {
		// Convert hierarchical content into flat string array
		// and finally return array of fragments ready for DOM insertion
		var frag, ret = content ? jQuery.map( content, function( item ) {
			return (typeof item === "string") ?
				// Insert template item annotations, to be converted to jQuery.data( "tmplItem" ) when elems are inserted into DOM.
				(tmplItem.key ? item.replace( /(<\w+)(?=[\s>])(?![^>]*_tmplitem)([^>]*)/g, "$1 " + tmplItmAtt + "=\"" + tmplItem.key + "\" $2" ) : item) :
				// This is a child template item. Build nested template.
				build( item, tmplItem, item._ctnt );
		}) :
		// If content is not defined, insert tmplItem directly. Not a template item. May be a string, or a string array, e.g. from {{html $item.html()}}.
		tmplItem;
		if ( nested ) {
			return ret;
		}

		// top-level template
		ret = ret.join("");

		// Support templates which have initial or final text nodes, or consist only of text
		// Also support HTML entities within the HTML markup.
		ret.replace( /^\s*([^<\s][^<]*)?(<[\w\W]+>)([^>]*[^>\s])?\s*$/, function( all, before, middle, after) {
			frag = jQuery( middle ).get();

			storeTmplItems( frag );
			if ( before ) {
				frag = unencode( before ).concat(frag);
			}
			if ( after ) {
				frag = frag.concat(unencode( after ));
			}
		});
		return frag ? frag : unencode( ret );
	}

	function unencode( text ) {
		// Use createElement, since createTextNode will not render HTML entities correctly
		var el = document.createElement( "div" );
		el.innerHTML = text;
		return jQuery.makeArray(el.childNodes);
	}

	// Generate a reusable function that will serve to render a template against data
	function buildTmplFn( markup ) {
		return new Function("jQuery","$item",
			// Use the variable __ to hold a string array while building the compiled template. (See https://github.com/jquery/jquery-tmpl/issues#issue/10).
			"var $=jQuery,call,__=[],$data=$item.data;" +

			// Introduce the data as local variables using with(){}
			"with($data){__.push('" +

			// Convert the template into pure JavaScript
			jQuery.trim(markup)
				.replace( /([\\'])/g, "\\$1" )
				.replace( /[\r\t\n]/g, " " )
				.replace( /\$\{([^\}]*)\}/g, "{{= $1}}" )
				.replace( /\{\{(\/?)(\w+|.)(?:\(((?:[^\}]|\}(?!\}))*?)?\))?(?:\s+(.*?)?)?(\(((?:[^\}]|\}(?!\}))*?)\))?\s*\}\}/g,
				function( all, slash, type, fnargs, target, parens, args ) {
					var tag = jQuery.tmpl.tag[ type ], def, expr, exprAutoFnDetect;
					if ( !tag ) {
						throw "Unknown template tag: " + type;
					}
					def = tag._default || [];
					if ( parens && !/\w$/.test(target)) {
						target += parens;
						parens = "";
					}
					if ( target ) {
						target = unescape( target );
						args = args ? ("," + unescape( args ) + ")") : (parens ? ")" : "");
						// Support for target being things like a.toLowerCase();
						// In that case don't call with template item as 'this' pointer. Just evaluate...
						expr = parens ? (target.indexOf(".") > -1 ? target + unescape( parens ) : ("(" + target + ").call($item" + args)) : target;
						exprAutoFnDetect = parens ? expr : "(typeof(" + target + ")==='function'?(" + target + ").call($item):(" + target + "))";
					} else {
						exprAutoFnDetect = expr = def.$1 || "null";
					}
					fnargs = unescape( fnargs );
					return "');" +
						tag[ slash ? "close" : "open" ]
							.split( "$notnull_1" ).join( target ? "typeof(" + target + ")!=='undefined' && (" + target + ")!=null" : "true" )
							.split( "$1a" ).join( exprAutoFnDetect )
							.split( "$1" ).join( expr )
							.split( "$2" ).join( fnargs || def.$2 || "" ) +
						"__.push('";
				}) +
			"');}return __;"
		);
	}
	function updateWrapped( options, wrapped ) {
		// Build the wrapped content.
		options._wrap = build( options, true,
			// Suport imperative scenario in which options.wrapped can be set to a selector or an HTML string.
			jQuery.isArray( wrapped ) ? wrapped : [htmlExpr.test( wrapped ) ? wrapped : jQuery( wrapped ).html()]
		).join("");
	}

	function unescape( args ) {
		return args ? args.replace( /\\'/g, "'").replace(/\\\\/g, "\\" ) : null;
	}
	function outerHtml( elem ) {
		var div = document.createElement("div");
		div.appendChild( elem.cloneNode(true) );
		return div.innerHTML;
	}

	// Store template items in jQuery.data(), ensuring a unique tmplItem data data structure for each rendered template instance.
	function storeTmplItems( content ) {
		var keySuffix = "_" + cloneIndex, elem, elems, newClonedItems = {}, i, l, m;
		for ( i = 0, l = content.length; i < l; i++ ) {
			if ( (elem = content[i]).nodeType !== 1 ) {
				continue;
			}
			elems = elem.getElementsByTagName("*");
			for ( m = elems.length - 1; m >= 0; m-- ) {
				processItemKey( elems[m] );
			}
			processItemKey( elem );
		}
		function processItemKey( el ) {
			var pntKey, pntNode = el, pntItem, tmplItem, key;
			// Ensure that each rendered template inserted into the DOM has its own template item,
			if ( (key = el.getAttribute( tmplItmAtt ))) {
				while ( pntNode.parentNode && (pntNode = pntNode.parentNode).nodeType === 1 && !(pntKey = pntNode.getAttribute( tmplItmAtt ))) { }
				if ( pntKey !== key ) {
					// The next ancestor with a _tmplitem expando is on a different key than this one.
					// So this is a top-level element within this template item
					// Set pntNode to the key of the parentNode, or to 0 if pntNode.parentNode is null, or pntNode is a fragment.
					pntNode = pntNode.parentNode ? (pntNode.nodeType === 11 ? 0 : (pntNode.getAttribute( tmplItmAtt ) || 0)) : 0;
					if ( !(tmplItem = newTmplItems[key]) ) {
						// The item is for wrapped content, and was copied from the temporary parent wrappedItem.
						tmplItem = wrappedItems[key];
						tmplItem = newTmplItem( tmplItem, newTmplItems[pntNode]||wrappedItems[pntNode] );
						tmplItem.key = ++itemKey;
						newTmplItems[itemKey] = tmplItem;
					}
					if ( cloneIndex ) {
						cloneTmplItem( key );
					}
				}
				el.removeAttribute( tmplItmAtt );
			} else if ( cloneIndex && (tmplItem = jQuery.data( el, "tmplItem" )) ) {
				// This was a rendered element, cloned during append or appendTo etc.
				// TmplItem stored in jQuery data has already been cloned in cloneCopyEvent. We must replace it with a fresh cloned tmplItem.
				cloneTmplItem( tmplItem.key );
				newTmplItems[tmplItem.key] = tmplItem;
				pntNode = jQuery.data( el.parentNode, "tmplItem" );
				pntNode = pntNode ? pntNode.key : 0;
			}
			if ( tmplItem ) {
				pntItem = tmplItem;
				// Find the template item of the parent element.
				// (Using !=, not !==, since pntItem.key is number, and pntNode may be a string)
				while ( pntItem && pntItem.key != pntNode ) {
					// Add this element as a top-level node for this rendered template item, as well as for any
					// ancestor items between this item and the item of its parent element
					pntItem.nodes.push( el );
					pntItem = pntItem.parent;
				}
				// Delete content built during rendering - reduce API surface area and memory use, and avoid exposing of stale data after rendering...
				delete tmplItem._ctnt;
				delete tmplItem._wrap;
				// Store template item as jQuery data on the element
				jQuery.data( el, "tmplItem", tmplItem );
			}
			function cloneTmplItem( key ) {
				key = key + keySuffix;
				tmplItem = newClonedItems[key] =
					(newClonedItems[key] || newTmplItem( tmplItem, newTmplItems[tmplItem.parent.key + keySuffix] || tmplItem.parent ));
			}
		}
	}

	//---- Helper functions for template item ----

	function tiCalls( content, tmpl, data, options ) {
		if ( !content ) {
			return stack.pop();
		}
		stack.push({ _: content, tmpl: tmpl, item:this, data: data, options: options });
	}

	function tiNest( tmpl, data, options ) {
		// nested template, using {{tmpl}} tag
		return jQuery.tmpl( jQuery.template( tmpl ), data, options, this );
	}

	function tiWrap( call, wrapped ) {
		// nested template, using {{wrap}} tag
		var options = call.options || {};
		options.wrapped = wrapped;
		// Apply the template, which may incorporate wrapped content,
		return jQuery.tmpl( jQuery.template( call.tmpl ), call.data, options, call.item );
	}

	function tiHtml( filter, textOnly ) {
		var wrapped = this._wrap;
		return jQuery.map(
			jQuery( jQuery.isArray( wrapped ) ? wrapped.join("") : wrapped ).filter( filter || "*" ),
			function(e) {
				return textOnly ?
					e.innerText || e.textContent :
					e.outerHTML || outerHtml(e);
			});
	}

	function tiUpdate() {
		var coll = this.nodes;
		jQuery.tmpl( null, null, null, this).insertBefore( coll[0] );
		jQuery( coll ).remove();
	}
})( jQuery );

```

`LibreHardwareMonitor/Resources/Web/js/jquery.tmpl.min.js`:

```js
/*
 * jQuery Templates Plugin 1.0.0pre
 * http://github.com/jquery/jquery-tmpl
 * Requires jQuery 1.4.2
 *
 * Copyright 2011, Software Freedom Conservancy, Inc.
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 */
(function(a){var r=a.fn.domManip,d="_tmplitem",q=/^[^<]*(<[\w\W]+>)[^>]*$|\{\{\! /,b={},f={},e,p={key:0,data:{}},i=0,c=0,l=[];function g(g,d,h,e){var c={data:e||(e===0||e===false)?e:d?d.data:{},_wrap:d?d._wrap:null,tmpl:null,parent:d||null,nodes:[],calls:u,nest:w,wrap:x,html:v,update:t};g&&a.extend(c,g,{nodes:[],parent:d});if(h){c.tmpl=h;c._ctnt=c._ctnt||c.tmpl(a,c);c.key=++i;(l.length?f:b)[i]=c}return c}a.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(f,d){a.fn[f]=function(n){var g=[],i=a(n),k,h,m,l,j=this.length===1&&this[0].parentNode;e=b||{};if(j&&j.nodeType===11&&j.childNodes.length===1&&i.length===1){i[d](this[0]);g=this}else{for(h=0,m=i.length;h<m;h++){c=h;k=(h>0?this.clone(true):this).get();a(i[h])[d](k);g=g.concat(k)}c=0;g=this.pushStack(g,f,i.selector)}l=e;e=null;a.tmpl.complete(l);return g}});a.fn.extend({tmpl:function(d,c,b){return a.tmpl(this[0],d,c,b)},tmplItem:function(){return a.tmplItem(this[0])},template:function(b){return a.template(b,this[0])},domManip:function(d,m,k){if(d[0]&&a.isArray(d[0])){var g=a.makeArray(arguments),h=d[0],j=h.length,i=0,f;while(i<j&&!(f=a.data(h[i++],"tmplItem")));if(f&&c)g[2]=function(b){a.tmpl.afterManip(this,b,k)};r.apply(this,g)}else r.apply(this,arguments);c=0;!e&&a.tmpl.complete(b);return this}});a.extend({tmpl:function(d,h,e,c){var i,k=!c;if(k){c=p;d=a.template[d]||a.template(null,d);f={}}else if(!d){d=c.tmpl;b[c.key]=c;c.nodes=[];c.wrapped&&n(c,c.wrapped);return a(j(c,null,c.tmpl(a,c)))}if(!d)return[];if(typeof h==="function")h=h.call(c||{});e&&e.wrapped&&n(e,e.wrapped);i=a.isArray(h)?a.map(h,function(a){return a?g(e,c,d,a):null}):[g(e,c,d,h)];return k?a(j(c,null,i)):i},tmplItem:function(b){var c;if(b instanceof a)b=b[0];while(b&&b.nodeType===1&&!(c=a.data(b,"tmplItem"))&&(b=b.parentNode));return c||p},template:function(c,b){if(b){if(typeof b==="string")b=o(b);else if(b instanceof a)b=b[0]||{};if(b.nodeType)b=a.data(b,"tmpl")||a.data(b,"tmpl",o(b.innerHTML));return typeof c==="string"?(a.template[c]=b):b}return c?typeof c!=="string"?a.template(null,c):a.template[c]||a.template(null,q.test(c)?c:a(c)):null},encode:function(a){return(""+a).split("<").join("&lt;").split(">").join("&gt;").split('"').join("&#34;").split("'").join("&#39;")}});a.extend(a.tmpl,{tag:{tmpl:{_default:{$2:"null"},open:"if($notnull_1){__=__.concat($item.nest($1,$2));}"},wrap:{_default:{$2:"null"},open:"$item.calls(__,$1,$2);__=[];",close:"call=$item.calls();__=call._.concat($item.wrap(call,__));"},each:{_default:{$2:"$index, $value"},open:"if($notnull_1){$.each($1a,function($2){with(this){",close:"}});}"},"if":{open:"if(($notnull_1) && $1a){",close:"}"},"else":{_default:{$1:"true"},open:"}else if(($notnull_1) && $1a){"},html:{open:"if($notnull_1){__.push($1a);}"},"=":{_default:{$1:"$data"},open:"if($notnull_1){__.push($.encode($1a));}"},"!":{open:""}},complete:function(){b={}},afterManip:function(f,b,d){var e=b.nodeType===11?a.makeArray(b.childNodes):b.nodeType===1?[b]:[];d.call(f,b);m(e);c++}});function j(e,g,f){var b,c=f?a.map(f,function(a){return typeof a==="string"?e.key?a.replace(/(<\w+)(?=[\s>])(?![^>]*_tmplitem)([^>]*)/g,"$1 "+d+'="'+e.key+'" $2'):a:j(a,e,a._ctnt)}):e;if(g)return c;c=c.join("");c.replace(/^\s*([^<\s][^<]*)?(<[\w\W]+>)([^>]*[^>\s])?\s*$/,function(f,c,e,d){b=a(e).get();m(b);if(c)b=k(c).concat(b);if(d)b=b.concat(k(d))});return b?b:k(c)}function k(c){var b=document.createElement("div");b.innerHTML=c;return a.makeArray(b.childNodes)}function o(b){return new Function("jQuery","$item","var $=jQuery,call,__=[],$data=$item.data;with($data){__.push('"+a.trim(b).replace(/([\\'])/g,"\\$1").replace(/[\r\t\n]/g," ").replace(/\$\{([^\}]*)\}/g,"{{= $1}}").replace(/\{\{(\/?)(\w+|.)(?:\(((?:[^\}]|\}(?!\}))*?)?\))?(?:\s+(.*?)?)?(\(((?:[^\}]|\}(?!\}))*?)\))?\s*\}\}/g,function(m,l,k,g,b,c,d){var j=a.tmpl.tag[k],i,e,f;if(!j)throw"Unknown template tag: "+k;i=j._default||[];if(c&&!/\w$/.test(b)){b+=c;c=""}if(b){b=h(b);d=d?","+h(d)+")":c?")":"";e=c?b.indexOf(".")>-1?b+h(c):"("+b+").call($item"+d:b;f=c?e:"(typeof("+b+")==='function'?("+b+").call($item):("+b+"))"}else f=e=i.$1||"null";g=h(g);return"');"+j[l?"close":"open"].split("$notnull_1").join(b?"typeof("+b+")!=='undefined' && ("+b+")!=null":"true").split("$1a").join(f).split("$1").join(e).split("$2").join(g||i.$2||"")+"__.push('"})+"');}return __;")}function n(c,b){c._wrap=j(c,true,a.isArray(b)?b:[q.test(b)?b:a(b).html()]).join("")}function h(a){return a?a.replace(/\\'/g,"'").replace(/\\\\/g,"\\"):null}function s(b){var a=document.createElement("div");a.appendChild(b.cloneNode(true));return a.innerHTML}function m(o){var n="_"+c,k,j,l={},e,p,h;for(e=0,p=o.length;e<p;e++){if((k=o[e]).nodeType!==1)continue;j=k.getElementsByTagName("*");for(h=j.length-1;h>=0;h--)m(j[h]);m(k)}function m(j){var p,h=j,k,e,m;if(m=j.getAttribute(d)){while(h.parentNode&&(h=h.parentNode).nodeType===1&&!(p=h.getAttribute(d)));if(p!==m){h=h.parentNode?h.nodeType===11?0:h.getAttribute(d)||0:0;if(!(e=b[m])){e=f[m];e=g(e,b[h]||f[h]);e.key=++i;b[i]=e}c&&o(m)}j.removeAttribute(d)}else if(c&&(e=a.data(j,"tmplItem"))){o(e.key);b[e.key]=e;h=a.data(j.parentNode,"tmplItem");h=h?h.key:0}if(e){k=e;while(k&&k.key!=h){k.nodes.push(j);k=k.parent}delete e._ctnt;delete e._wrap;a.data(j,"tmplItem",e)}function o(a){a=a+n;e=l[a]=l[a]||g(e,b[e.parent.key+n]||e.parent)}}}function u(a,d,c,b){if(!a)return l.pop();l.push({_:a,tmpl:d,item:this,data:c,options:b})}function w(d,c,b){return a.tmpl(a.template(d),c,b,this)}function x(b,d){var c=b.options||{};c.wrapped=d;return a.tmpl(a.template(b.tmpl),b.data,c,b.item)}function v(d,c){var b=this._wrap;return a.map(a(a.isArray(b)?b.join(""):b).filter(d||"*"),function(a){return c?a.innerText||a.textContent:a.outerHTML||s(a)})}function t(){var b=this.nodes;a.tmpl(null,null,null,this).insertBefore(b[0]);a(b).remove()}})(jQuery);
```

`LibreHardwareMonitor/Resources/Web/js/jquery.treeTable.min.js`:

```js
/*
 * jQuery treeTable Plugin VERSION
 * http://ludo.cubicphuse.nl/jquery-plugins/treeTable/doc/
 *
 * Copyright 2011, Ludo van den Boom
 * Dual licensed under the MIT or GPL Version 2 licenses.
 */
(function(a){function j(c){var d=c[0].className.split(" ");for(var e=0;e<d.length;e++)if(d[e].match(b.childPrefix))return a(c).siblings("#"+d[e].substring(b.childPrefix.length));return null}function i(b,c){b.insertAfter(c),e(b).reverse().each(function(){i(a(this),b[0])})}function h(c){if(!c.hasClass("initialized")){c.addClass("initialized");var d=e(c);!c.hasClass("parent")&&d.length>0&&c.addClass("parent");if(c.hasClass("parent")){var g=a(c.children("td")[b.treeColumn]),h=f(g)+b.indent;d.each(function(){a(this).children("td")[b.treeColumn].style.paddingLeft=h+"px"});if(b.expandable){g.prepend('<span style="margin-left: -'+b.indent+"px; padding-left: "+b.indent+'px" class="expander"></span>'),a(g[0].firstChild).click(function(){c.toggleBranch()}),b.clickableNodeNames&&(g[0].style.cursor="pointer",a(g).click(function(a){a.target.className!="expander"&&c.toggleBranch()}));if(b.persist){var i=b.persistCookiePrefix+c.attr("id");a.cookie(i)=="true"&&c.addClass("expanded")}!c.hasClass("expanded")&&!c.hasClass("collapsed")&&c.addClass(b.initialState),c.hasClass("expanded")&&c.expand()}}}}function g(c,d){var h=a(c.children("td")[b.treeColumn]);h[0].style.paddingLeft=f(h)+d+"px",e(c).each(function(){g(a(this),d)})}function f(a){var b=parseInt(a[0].style.paddingLeft,10);return isNaN(b)?c:b}function e(c){return a(c).siblings("tr."+b.childPrefix+c[0].id)}function d(a){var b=[];while(a=j(a))b[b.length]=a[0];return b}var b,c;a.fn.treeTable=function(d){b=a.extend({},a.fn.treeTable.defaults,d);return this.each(function(){a(this).addClass("treeTable").find("tbody tr").each(function(){if(!a(this).hasClass("initialized")){var d=a(this)[0].className.search(b.childPrefix)==-1;d&&isNaN(c)&&(c=parseInt(a(a(this).children("td")[b.treeColumn]).css("padding-left"),10)),!d&&b.expandable&&b.initialState=="collapsed"&&a(this).addClass("ui-helper-hidden"),(!b.expandable||d)&&h(a(this))}})})},a.fn.treeTable.defaults={childPrefix:"child-of-",clickableNodeNames:!1,expandable:!0,indent:19,initialState:"collapsed",onNodeShow:null,treeColumn:0,persist:!1,persistCookiePrefix:"treeTable_"},a.fn.collapse=function(){a(this).addClass("collapsed"),e(a(this)).each(function(){a(this).hasClass("collapsed")||a(this).collapse(),a(this).addClass("ui-helper-hidden")});return this},a.fn.expand=function(){a(this).removeClass("collapsed").addClass("expanded"),e(a(this)).each(function(){h(a(this)),a(this).is(".expanded.parent")&&a(this).expand(),a(this).removeClass("ui-helper-hidden"),a.isFunction(b.onNodeShow)&&b.onNodeShow.call()});return this},a.fn.reveal=function(){a(d(a(this)).reverse()).each(function(){h(a(this)),a(this).expand().show()});return this},a.fn.appendBranchTo=function(c){var e=a(this),f=j(e),h=a.map(d(a(c)),function(a){return a.id});a.inArray(e[0].id,h)==-1&&(!f||c.id!=f[0].id)&&c.id!=e[0].id&&(g(e,d(e).length*b.indent*-1),f&&e.removeClass(b.childPrefix+f[0].id),e.addClass(b.childPrefix+c.id),i(e,c),g(e,d(e).length*b.indent));return this},a.fn.reverse=function(){return this.pushStack(this.get().reverse(),arguments)},a.fn.toggleBranch=function(){a(this).hasClass("collapsed")?a(this).expand():a(this).removeClass("expanded").collapse();if(b.persist){var c=b.persistCookiePrefix+a(this).attr("id");a.cookie(c,a(this).hasClass("expanded")?"true":null)}return this}})(jQuery)

```

`LibreHardwareMonitor/Resources/Web/js/knockout-2.1.0.js`:

```js
// Knockout JavaScript library v2.1.0
// (c) Steven Sanderson - http://knockoutjs.com/
// License: MIT (http://www.opensource.org/licenses/mit-license.php)

(function(window,document,navigator,undefined){
var DEBUG=true;
!function(factory) {
    // Support three module loading scenarios
    if (typeof require === 'function' && typeof exports === 'object' && typeof module === 'object') {
        // [1] CommonJS/Node.js
        var target = module['exports'] || exports; // module.exports is for Node.js
        factory(target);
    } else if (typeof define === 'function' && define['amd']) {
        // [2] AMD anonymous module
        define(['exports'], factory);
    } else {
        // [3] No module loader (plain <script> tag) - put directly in global namespace
        factory(window['ko'] = {});
    }
}(function(koExports){
// Internally, all KO objects are attached to koExports (even the non-exported ones whose names will be minified by the closure compiler).
// In the future, the following "ko" variable may be made distinct from "koExports" so that private objects are not externally reachable.
var ko = typeof koExports !== 'undefined' ? koExports : {};
// Google Closure Compiler helpers (used only to make the minified file smaller)
ko.exportSymbol = function(koPath, object) {
	var tokens = koPath.split(".");

	// In the future, "ko" may become distinct from "koExports" (so that non-exported objects are not reachable)
	// At that point, "target" would be set to: (typeof koExports !== "undefined" ? koExports : ko)
	var target = ko;

	for (var i = 0; i < tokens.length - 1; i++)
		target = target[tokens[i]];
	target[tokens[tokens.length - 1]] = object;
};
ko.exportProperty = function(owner, publicName, object) {
  owner[publicName] = object;
};
ko.version = "2.1.0";

ko.exportSymbol('version', ko.version);
ko.utils = new (function () {
    var stringTrimRegex = /^(\s|\u00A0)+|(\s|\u00A0)+$/g;

    // Represent the known event types in a compact way, then at runtime transform it into a hash with event name as key (for fast lookup)
    var knownEvents = {}, knownEventTypesByEventName = {};
    var keyEventTypeName = /Firefox\/2/i.test(navigator.userAgent) ? 'KeyboardEvent' : 'UIEvents';
    knownEvents[keyEventTypeName] = ['keyup', 'keydown', 'keypress'];
    knownEvents['MouseEvents'] = ['click', 'dblclick', 'mousedown', 'mouseup', 'mousemove', 'mouseover', 'mouseout', 'mouseenter', 'mouseleave'];
    for (var eventType in knownEvents) {
        var knownEventsForType = knownEvents[eventType];
        if (knownEventsForType.length) {
            for (var i = 0, j = knownEventsForType.length; i < j; i++)
                knownEventTypesByEventName[knownEventsForType[i]] = eventType;
        }
    }
    var eventsThatMustBeRegisteredUsingAttachEvent = { 'propertychange': true }; // Workaround for an IE9 issue - https://github.com/SteveSanderson/knockout/issues/406

    // Detect IE versions for bug workarounds (uses IE conditionals, not UA string, for robustness)
    var ieVersion = (function() {
        var version = 3, div = document.createElement('div'), iElems = div.getElementsByTagName('i');

        // Keep constructing conditional HTML blocks until we hit one that resolves to an empty fragment
        while (
            div.innerHTML = '<!--[if gt IE ' + (++version) + ']><i></i><![endif]-->',
            iElems[0]
        );
        return version > 4 ? version : undefined;
    }());
    var isIe6 = ieVersion === 6,
        isIe7 = ieVersion === 7;

    function isClickOnCheckableElement(element, eventType) {
        if ((ko.utils.tagNameLower(element) !== "input") || !element.type) return false;
        if (eventType.toLowerCase() != "click") return false;
        var inputType = element.type;
        return (inputType == "checkbox") || (inputType == "radio");
    }

    return {
        fieldsIncludedWithJsonPost: ['authenticity_token', /^__RequestVerificationToken(_.*)?$/],

        arrayForEach: function (array, action) {
            for (var i = 0, j = array.length; i < j; i++)
                action(array[i]);
        },

        arrayIndexOf: function (array, item) {
            if (typeof Array.prototype.indexOf == "function")
                return Array.prototype.indexOf.call(array, item);
            for (var i = 0, j = array.length; i < j; i++)
                if (array[i] === item)
                    return i;
            return -1;
        },

        arrayFirst: function (array, predicate, predicateOwner) {
            for (var i = 0, j = array.length; i < j; i++)
                if (predicate.call(predicateOwner, array[i]))
                    return array[i];
            return null;
        },

        arrayRemoveItem: function (array, itemToRemove) {
            var index = ko.utils.arrayIndexOf(array, itemToRemove);
            if (index >= 0)
                array.splice(index, 1);
        },

        arrayGetDistinctValues: function (array) {
            array = array || [];
            var result = [];
            for (var i = 0, j = array.length; i < j; i++) {
                if (ko.utils.arrayIndexOf(result, array[i]) < 0)
                    result.push(array[i]);
            }
            return result;
        },

        arrayMap: function (array, mapping) {
            array = array || [];
            var result = [];
            for (var i = 0, j = array.length; i < j; i++)
                result.push(mapping(array[i]));
            return result;
        },

        arrayFilter: function (array, predicate) {
            array = array || [];
            var result = [];
            for (var i = 0, j = array.length; i < j; i++)
                if (predicate(array[i]))
                    result.push(array[i]);
            return result;
        },

        arrayPushAll: function (array, valuesToPush) {
            if (valuesToPush instanceof Array)
                array.push.apply(array, valuesToPush);
            else
                for (var i = 0, j = valuesToPush.length; i < j; i++)
                    array.push(valuesToPush[i]);
            return array;
        },

        extend: function (target, source) {
            if (source) {
                for(var prop in source) {
                    if(source.hasOwnProperty(prop)) {
                        target[prop] = source[prop];
                    }
                }
            }
            return target;
        },

        emptyDomNode: function (domNode) {
            while (domNode.firstChild) {
                ko.removeNode(domNode.firstChild);
            }
        },

        moveCleanedNodesToContainerElement: function(nodes) {
            // Ensure it's a real array, as we're about to reparent the nodes and
            // we don't want the underlying collection to change while we're doing that.
            var nodesArray = ko.utils.makeArray(nodes);

            var container = document.createElement('div');
            for (var i = 0, j = nodesArray.length; i < j; i++) {
                ko.cleanNode(nodesArray[i]);
                container.appendChild(nodesArray[i]);
            }
            return container;
        },

        setDomNodeChildren: function (domNode, childNodes) {
            ko.utils.emptyDomNode(domNode);
            if (childNodes) {
                for (var i = 0, j = childNodes.length; i < j; i++)
                    domNode.appendChild(childNodes[i]);
            }
        },

        replaceDomNodes: function (nodeToReplaceOrNodeArray, newNodesArray) {
            var nodesToReplaceArray = nodeToReplaceOrNodeArray.nodeType ? [nodeToReplaceOrNodeArray] : nodeToReplaceOrNodeArray;
            if (nodesToReplaceArray.length > 0) {
                var insertionPoint = nodesToReplaceArray[0];
                var parent = insertionPoint.parentNode;
                for (var i = 0, j = newNodesArray.length; i < j; i++)
                    parent.insertBefore(newNodesArray[i], insertionPoint);
                for (var i = 0, j = nodesToReplaceArray.length; i < j; i++) {
                    ko.removeNode(nodesToReplaceArray[i]);
                }
            }
        },

        setOptionNodeSelectionState: function (optionNode, isSelected) {
            // IE6 sometimes throws "unknown error" if you try to write to .selected directly, whereas Firefox struggles with setAttribute. Pick one based on browser.
            if (navigator.userAgent.indexOf("MSIE 6") >= 0)
                optionNode.setAttribute("selected", isSelected);
            else
                optionNode.selected = isSelected;
        },

        stringTrim: function (string) {
            return (string || "").replace(stringTrimRegex, "");
        },

        stringTokenize: function (string, delimiter) {
            var result = [];
            var tokens = (string || "").split(delimiter);
            for (var i = 0, j = tokens.length; i < j; i++) {
                var trimmed = ko.utils.stringTrim(tokens[i]);
                if (trimmed !== "")
                    result.push(trimmed);
            }
            return result;
        },

        stringStartsWith: function (string, startsWith) {
            string = string || "";
            if (startsWith.length > string.length)
                return false;
            return string.substring(0, startsWith.length) === startsWith;
        },

        buildEvalWithinScopeFunction: function (expression, scopeLevels) {
            // Build the source for a function that evaluates "expression"
            // For each scope variable, add an extra level of "with" nesting
            // Example result: with(sc[1]) { with(sc[0]) { return (expression) } }
            var functionBody = "return (" + expression + ")";
            for (var i = 0; i < scopeLevels; i++) {
                functionBody = "with(sc[" + i + "]) { " + functionBody + " } ";
            }
            return new Function("sc", functionBody);
        },

        domNodeIsContainedBy: function (node, containedByNode) {
            if (containedByNode.compareDocumentPosition)
                return (containedByNode.compareDocumentPosition(node) & 16) == 16;
            while (node != null) {
                if (node == containedByNode)
                    return true;
                node = node.parentNode;
            }
            return false;
        },

        domNodeIsAttachedToDocument: function (node) {
            return ko.utils.domNodeIsContainedBy(node, node.ownerDocument);
        },

        tagNameLower: function(element) {
            // For HTML elements, tagName will always be upper case; for XHTML elements, it'll be lower case.
            // Possible future optimization: If we know it's an element from an XHTML document (not HTML),
            // we don't need to do the .toLowerCase() as it will always be lower case anyway.
            return element && element.tagName && element.tagName.toLowerCase();
        },

        registerEventHandler: function (element, eventType, handler) {
            var mustUseAttachEvent = ieVersion && eventsThatMustBeRegisteredUsingAttachEvent[eventType];
            if (!mustUseAttachEvent && typeof jQuery != "undefined") {
                if (isClickOnCheckableElement(element, eventType)) {
                    // For click events on checkboxes, jQuery interferes with the event handling in an awkward way:
                    // it toggles the element checked state *after* the click event handlers run, whereas native
                    // click events toggle the checked state *before* the event handler.
                    // Fix this by intecepting the handler and applying the correct checkedness before it runs.
                    var originalHandler = handler;
                    handler = function(event, eventData) {
                        var jQuerySuppliedCheckedState = this.checked;
                        if (eventData)
                            this.checked = eventData.checkedStateBeforeEvent !== true;
                        originalHandler.call(this, event);
                        this.checked = jQuerySuppliedCheckedState; // Restore the state jQuery applied
                    };
                }
                jQuery(element)['bind'](eventType, handler);
            } else if (!mustUseAttachEvent && typeof element.addEventListener == "function")
                element.addEventListener(eventType, handler, false);
            else if (typeof element.attachEvent != "undefined")
                element.attachEvent("on" + eventType, function (event) {
                    handler.call(element, event);
                });
            else
                throw new Error("Browser doesn't support addEventListener or attachEvent");
        },

        triggerEvent: function (element, eventType) {
            if (!(element && element.nodeType))
                throw new Error("element must be a DOM node when calling triggerEvent");

            if (typeof jQuery != "undefined") {
                var eventData = [];
                if (isClickOnCheckableElement(element, eventType)) {
                    // Work around the jQuery "click events on checkboxes" issue described above by storing the original checked state before triggering the handler
                    eventData.push({ checkedStateBeforeEvent: element.checked });
                }
                jQuery(element)['trigger'](eventType, eventData);
            } else if (typeof document.createEvent == "function") {
                if (typeof element.dispatchEvent == "function") {
                    var eventCategory = knownEventTypesByEventName[eventType] || "HTMLEvents";
                    var event = document.createEvent(eventCategory);
                    event.initEvent(eventType, true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, element);
                    element.dispatchEvent(event);
                }
                else
                    throw new Error("The supplied element doesn't support dispatchEvent");
            } else if (typeof element.fireEvent != "undefined") {
                // Unlike other browsers, IE doesn't change the checked state of checkboxes/radiobuttons when you trigger their "click" event
                // so to make it consistent, we'll do it manually here
                if (isClickOnCheckableElement(element, eventType))
                    element.checked = element.checked !== true;
                element.fireEvent("on" + eventType);
            }
            else
                throw new Error("Browser doesn't support triggering events");
        },

        unwrapObservable: function (value) {
            return ko.isObservable(value) ? value() : value;
        },

        toggleDomNodeCssClass: function (node, className, shouldHaveClass) {
            var currentClassNames = (node.className || "").split(/\s+/);
            var hasClass = ko.utils.arrayIndexOf(currentClassNames, className) >= 0;

            if (shouldHaveClass && !hasClass) {
                node.className += (currentClassNames[0] ? " " : "") + className;
            } else if (hasClass && !shouldHaveClass) {
                var newClassName = "";
                for (var i = 0; i < currentClassNames.length; i++)
                    if (currentClassNames[i] != className)
                        newClassName += currentClassNames[i] + " ";
                node.className = ko.utils.stringTrim(newClassName);
            }
        },

        setTextContent: function(element, textContent) {
            var value = ko.utils.unwrapObservable(textContent);
            if ((value === null) || (value === undefined))
                value = "";

            'innerText' in element ? element.innerText = value
                                   : element.textContent = value;

            if (ieVersion >= 9) {
                // Believe it or not, this actually fixes an IE9 rendering bug
                // (See https://github.com/SteveSanderson/knockout/issues/209)
                element.style.display = element.style.display;
            }
        },

        ensureSelectElementIsRenderedCorrectly: function(selectElement) {
            // Workaround for IE9 rendering bug - it doesn't reliably display all the text in dynamically-added select boxes unless you force it to re-render by updating the width.
            // (See https://github.com/SteveSanderson/knockout/issues/312, http://stackoverflow.com/questions/5908494/select-only-shows-first-char-of-selected-option)
            if (ieVersion >= 9) {
                var originalWidth = selectElement.style.width;
                selectElement.style.width = 0;
                selectElement.style.width = originalWidth;
            }
        },

        range: function (min, max) {
            min = ko.utils.unwrapObservable(min);
            max = ko.utils.unwrapObservable(max);
            var result = [];
            for (var i = min; i <= max; i++)
                result.push(i);
            return result;
        },

        makeArray: function(arrayLikeObject) {
            var result = [];
            for (var i = 0, j = arrayLikeObject.length; i < j; i++) {
                result.push(arrayLikeObject[i]);
            };
            return result;
        },

        isIe6 : isIe6,
        isIe7 : isIe7,
        ieVersion : ieVersion,

        getFormFields: function(form, fieldName) {
            var fields = ko.utils.makeArray(form.getElementsByTagName("input")).concat(ko.utils.makeArray(form.getElementsByTagName("textarea")));
            var isMatchingField = (typeof fieldName == 'string')
                ? function(field) { return field.name === fieldName }
                : function(field) { return fieldName.test(field.name) }; // Treat fieldName as regex or object containing predicate
            var matches = [];
            for (var i = fields.length - 1; i >= 0; i--) {
                if (isMatchingField(fields[i]))
                    matches.push(fields[i]);
            };
            return matches;
        },

        parseJson: function (jsonString) {
            if (typeof jsonString == "string") {
                jsonString = ko.utils.stringTrim(jsonString);
                if (jsonString) {
                    if (window.JSON && window.JSON.parse) // Use native parsing where available
                        return window.JSON.parse(jsonString);
                    return (new Function("return " + jsonString))(); // Fallback on less safe parsing for older browsers
                }
            }
            return null;
        },

        stringifyJson: function (data, replacer, space) {   // replacer and space are optional
            if ((typeof JSON == "undefined") || (typeof JSON.stringify == "undefined"))
                throw new Error("Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js");
            return JSON.stringify(ko.utils.unwrapObservable(data), replacer, space);
        },

        postJson: function (urlOrForm, data, options) {
            options = options || {};
            var params = options['params'] || {};
            var includeFields = options['includeFields'] || this.fieldsIncludedWithJsonPost;
            var url = urlOrForm;

            // If we were given a form, use its 'action' URL and pick out any requested field values
            if((typeof urlOrForm == 'object') && (ko.utils.tagNameLower(urlOrForm) === "form")) {
                var originalForm = urlOrForm;
                url = originalForm.action;
                for (var i = includeFields.length - 1; i >= 0; i--) {
                    var fields = ko.utils.getFormFields(originalForm, includeFields[i]);
                    for (var j = fields.length - 1; j >= 0; j--)
                        params[fields[j].name] = fields[j].value;
                }
            }

            data = ko.utils.unwrapObservable(data);
            var form = document.createElement("form");
            form.style.display = "none";
            form.action = url;
            form.method = "post";
            for (var key in data) {
                var input = document.createElement("input");
                input.name = key;
                input.value = ko.utils.stringifyJson(ko.utils.unwrapObservable(data[key]));
                form.appendChild(input);
            }
            for (var key in params) {
                var input = document.createElement("input");
                input.name = key;
                input.value = params[key];
                form.appendChild(input);
            }
            document.body.appendChild(form);
            options['submitter'] ? options['submitter'](form) : form.submit();
            setTimeout(function () { form.parentNode.removeChild(form); }, 0);
        }
    }
})();

ko.exportSymbol('utils', ko.utils);
ko.exportSymbol('utils.arrayForEach', ko.utils.arrayForEach);
ko.exportSymbol('utils.arrayFirst', ko.utils.arrayFirst);
ko.exportSymbol('utils.arrayFilter', ko.utils.arrayFilter);
ko.exportSymbol('utils.arrayGetDistinctValues', ko.utils.arrayGetDistinctValues);
ko.exportSymbol('utils.arrayIndexOf', ko.utils.arrayIndexOf);
ko.exportSymbol('utils.arrayMap', ko.utils.arrayMap);
ko.exportSymbol('utils.arrayPushAll', ko.utils.arrayPushAll);
ko.exportSymbol('utils.arrayRemoveItem', ko.utils.arrayRemoveItem);
ko.exportSymbol('utils.extend', ko.utils.extend);
ko.exportSymbol('utils.fieldsIncludedWithJsonPost', ko.utils.fieldsIncludedWithJsonPost);
ko.exportSymbol('utils.getFormFields', ko.utils.getFormFields);
ko.exportSymbol('utils.postJson', ko.utils.postJson);
ko.exportSymbol('utils.parseJson', ko.utils.parseJson);
ko.exportSymbol('utils.registerEventHandler', ko.utils.registerEventHandler);
ko.exportSymbol('utils.stringifyJson', ko.utils.stringifyJson);
ko.exportSymbol('utils.range', ko.utils.range);
ko.exportSymbol('utils.toggleDomNodeCssClass', ko.utils.toggleDomNodeCssClass);
ko.exportSymbol('utils.triggerEvent', ko.utils.triggerEvent);
ko.exportSymbol('utils.unwrapObservable', ko.utils.unwrapObservable);

if (!Function.prototype['bind']) {
    // Function.prototype.bind is a standard part of ECMAScript 5th Edition (December 2009, http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf)
    // In case the browser doesn't implement it natively, provide a JavaScript implementation. This implementation is based on the one in prototype.js
    Function.prototype['bind'] = function (object) {
        var originalFunction = this, args = Array.prototype.slice.call(arguments), object = args.shift();
        return function () {
            return originalFunction.apply(object, args.concat(Array.prototype.slice.call(arguments)));
        };
    };
}

ko.utils.domData = new (function () {
    var uniqueId = 0;
    var dataStoreKeyExpandoPropertyName = "__ko__" + (new Date).getTime();
    var dataStore = {};
    return {
        get: function (node, key) {
            var allDataForNode = ko.utils.domData.getAll(node, false);
            return allDataForNode === undefined ? undefined : allDataForNode[key];
        },
        set: function (node, key, value) {
            if (value === undefined) {
                // Make sure we don't actually create a new domData key if we are actually deleting a value
                if (ko.utils.domData.getAll(node, false) === undefined)
                    return;
            }
            var allDataForNode = ko.utils.domData.getAll(node, true);
            allDataForNode[key] = value;
        },
        getAll: function (node, createIfNotFound) {
            var dataStoreKey = node[dataStoreKeyExpandoPropertyName];
            var hasExistingDataStore = dataStoreKey && (dataStoreKey !== "null");
            if (!hasExistingDataStore) {
                if (!createIfNotFound)
                    return undefined;
                dataStoreKey = node[dataStoreKeyExpandoPropertyName] = "ko" + uniqueId++;
                dataStore[dataStoreKey] = {};
            }
            return dataStore[dataStoreKey];
        },
        clear: function (node) {
            var dataStoreKey = node[dataStoreKeyExpandoPropertyName];
            if (dataStoreKey) {
                delete dataStore[dataStoreKey];
                node[dataStoreKeyExpandoPropertyName] = null;
            }
        }
    }
})();

ko.exportSymbol('utils.domData', ko.utils.domData);
ko.exportSymbol('utils.domData.clear', ko.utils.domData.clear); // Exporting only so specs can clear up after themselves fully

ko.utils.domNodeDisposal = new (function () {
    var domDataKey = "__ko_domNodeDisposal__" + (new Date).getTime();
    var cleanableNodeTypes = { 1: true, 8: true, 9: true };       // Element, Comment, Document
    var cleanableNodeTypesWithDescendants = { 1: true, 9: true }; // Element, Document

    function getDisposeCallbacksCollection(node, createIfNotFound) {
        var allDisposeCallbacks = ko.utils.domData.get(node, domDataKey);
        if ((allDisposeCallbacks === undefined) && createIfNotFound) {
            allDisposeCallbacks = [];
            ko.utils.domData.set(node, domDataKey, allDisposeCallbacks);
        }
        return allDisposeCallbacks;
    }
    function destroyCallbacksCollection(node) {
        ko.utils.domData.set(node, domDataKey, undefined);
    }

    function cleanSingleNode(node) {
        // Run all the dispose callbacks
        var callbacks = getDisposeCallbacksCollection(node, false);
        if (callbacks) {
            callbacks = callbacks.slice(0); // Clone, as the array may be modified during iteration (typically, callbacks will remove themselves)
            for (var i = 0; i < callbacks.length; i++)
                callbacks[i](node);
        }

        // Also erase the DOM data
        ko.utils.domData.clear(node);

        // Special support for jQuery here because it's so commonly used.
        // Many jQuery plugins (including jquery.tmpl) store data using jQuery's equivalent of domData
        // so notify it to tear down any resources associated with the node & descendants here.
        if ((typeof jQuery == "function") && (typeof jQuery['cleanData'] == "function"))
            jQuery['cleanData']([node]);

        // Also clear any immediate-child comment nodes, as these wouldn't have been found by
        // node.getElementsByTagName("*") in cleanNode() (comment nodes aren't elements)
        if (cleanableNodeTypesWithDescendants[node.nodeType])
            cleanImmediateCommentTypeChildren(node);
    }

    function cleanImmediateCommentTypeChildren(nodeWithChildren) {
        var child, nextChild = nodeWithChildren.firstChild;
        while (child = nextChild) {
            nextChild = child.nextSibling;
            if (child.nodeType === 8)
                cleanSingleNode(child);
        }
    }

    return {
        addDisposeCallback : function(node, callback) {
            if (typeof callback != "function")
                throw new Error("Callback must be a function");
            getDisposeCallbacksCollection(node, true).push(callback);
        },

        removeDisposeCallback : function(node, callback) {
            var callbacksCollection = getDisposeCallbacksCollection(node, false);
            if (callbacksCollection) {
                ko.utils.arrayRemoveItem(callbacksCollection, callback);
                if (callbacksCollection.length == 0)
                    destroyCallbacksCollection(node);
            }
        },

        cleanNode : function(node) {
            // First clean this node, where applicable
            if (cleanableNodeTypes[node.nodeType]) {
                cleanSingleNode(node);

                // ... then its descendants, where applicable
                if (cleanableNodeTypesWithDescendants[node.nodeType]) {
                    // Clone the descendants list in case it changes during iteration
                    var descendants = [];
                    ko.utils.arrayPushAll(descendants, node.getElementsByTagName("*"));
                    for (var i = 0, j = descendants.length; i < j; i++)
                        cleanSingleNode(descendants[i]);
                }
            }
        },

        removeNode : function(node) {
            ko.cleanNode(node);
            if (node.parentNode)
                node.parentNode.removeChild(node);
        }
    }
})();
ko.cleanNode = ko.utils.domNodeDisposal.cleanNode; // Shorthand name for convenience
ko.removeNode = ko.utils.domNodeDisposal.removeNode; // Shorthand name for convenience
ko.exportSymbol('cleanNode', ko.cleanNode);
ko.exportSymbol('removeNode', ko.removeNode);
ko.exportSymbol('utils.domNodeDisposal', ko.utils.domNodeDisposal);
ko.exportSymbol('utils.domNodeDisposal.addDisposeCallback', ko.utils.domNodeDisposal.addDisposeCallback);
ko.exportSymbol('utils.domNodeDisposal.removeDisposeCallback', ko.utils.domNodeDisposal.removeDisposeCallback);
(function () {
    var leadingCommentRegex = /^(\s*)<!--(.*?)-->/;

    function simpleHtmlParse(html) {
        // Based on jQuery's "clean" function, but only accounting for table-related elements.
        // If you have referenced jQuery, this won't be used anyway - KO will use jQuery's "clean" function directly

        // Note that there's still an issue in IE < 9 whereby it will discard comment nodes that are the first child of
        // a descendant node. For example: "<div><!-- mycomment -->abc</div>" will get parsed as "<div>abc</div>"
        // This won't affect anyone who has referenced jQuery, and there's always the workaround of inserting a dummy node
        // (possibly a text node) in front of the comment. So, KO does not attempt to workaround this IE issue automatically at present.

        // Trim whitespace, otherwise indexOf won't work as expected
        var tags = ko.utils.stringTrim(html).toLowerCase(), div = document.createElement("div");

        // Finds the first match from the left column, and returns the corresponding "wrap" data from the right column
        var wrap = tags.match(/^<(thead|tbody|tfoot)/)              && [1, "<table>", "</table>"] ||
                   !tags.indexOf("<tr")                             && [2, "<table><tbody>", "</tbody></table>"] ||
                   (!tags.indexOf("<td") || !tags.indexOf("<th"))   && [3, "<table><tbody><tr>", "</tr></tbody></table>"] ||
                   /* anything else */                                 [0, "", ""];

        // Go to html and back, then peel off extra wrappers
        // Note that we always prefix with some dummy text, because otherwise, IE<9 will strip out leading comment nodes in descendants. Total madness.
        var markup = "ignored<div>" + wrap[1] + html + wrap[2] + "</div>";
        if (typeof window['innerShiv'] == "function") {
            div.appendChild(window['innerShiv'](markup));
        } else {
            div.innerHTML = markup;
        }

        // Move to the right depth
        while (wrap[0]--)
            div = div.lastChild;

        return ko.utils.makeArray(div.lastChild.childNodes);
    }

    function jQueryHtmlParse(html) {
        var elems = jQuery['clean']([html]);

        // As of jQuery 1.7.1, jQuery parses the HTML by appending it to some dummy parent nodes held in an in-memory document fragment.
        // Unfortunately, it never clears the dummy parent nodes from the document fragment, so it leaks memory over time.
        // Fix this by finding the top-most dummy parent element, and detaching it from its owner fragment.
        if (elems && elems[0]) {
            // Find the top-most parent element that's a direct child of a document fragment
            var elem = elems[0];
            while (elem.parentNode && elem.parentNode.nodeType !== 11 /* i.e., DocumentFragment */)
                elem = elem.parentNode;
            // ... then detach it
            if (elem.parentNode)
                elem.parentNode.removeChild(elem);
        }

        return elems;
    }

    ko.utils.parseHtmlFragment = function(html) {
        return typeof jQuery != 'undefined' ? jQueryHtmlParse(html)   // As below, benefit from jQuery's optimisations where possible
                                            : simpleHtmlParse(html);  // ... otherwise, this simple logic will do in most common cases.
    };

    ko.utils.setHtml = function(node, html) {
        ko.utils.emptyDomNode(node);

        if ((html !== null) && (html !== undefined)) {
            if (typeof html != 'string')
                html = html.toString();

            // jQuery contains a lot of sophisticated code to parse arbitrary HTML fragments,
            // for example <tr> elements which are not normally allowed to exist on their own.
            // If you've referenced jQuery we'll use that rather than duplicating its code.
            if (typeof jQuery != 'undefined') {
                jQuery(node)['html'](html);
            } else {
                // ... otherwise, use KO's own parsing logic.
                var parsedNodes = ko.utils.parseHtmlFragment(html);
                for (var i = 0; i < parsedNodes.length; i++)
                    node.appendChild(parsedNodes[i]);
            }
        }
    };
})();

ko.exportSymbol('utils.parseHtmlFragment', ko.utils.parseHtmlFragment);
ko.exportSymbol('utils.setHtml', ko.utils.setHtml);

ko.memoization = (function () {
    var memos = {};

    function randomMax8HexChars() {
        return (((1 + Math.random()) * 0x100000000) | 0).toString(16).substring(1);
    }
    function generateRandomId() {
        return randomMax8HexChars() + randomMax8HexChars();
    }
    function findMemoNodes(rootNode, appendToArray) {
        if (!rootNode)
            return;
        if (rootNode.nodeType == 8) {
            var memoId = ko.memoization.parseMemoText(rootNode.nodeValue);
            if (memoId != null)
                appendToArray.push({ domNode: rootNode, memoId: memoId });
        } else if (rootNode.nodeType == 1) {
            for (var i = 0, childNodes = rootNode.childNodes, j = childNodes.length; i < j; i++)
                findMemoNodes(childNodes[i], appendToArray);
        }
    }

    return {
        memoize: function (callback) {
            if (typeof callback != "function")
                throw new Error("You can only pass a function to ko.memoization.memoize()");
            var memoId = generateRandomId();
            memos[memoId] = callback;
            return "<!--[ko_memo:" + memoId + "]-->";
        },

        unmemoize: function (memoId, callbackParams) {
            var callback = memos[memoId];
            if (callback === undefined)
                throw new Error("Couldn't find any memo with ID " + memoId + ". Perhaps it's already been unmemoized.");
            try {
                callback.apply(null, callbackParams || []);
                return true;
            }
            finally { delete memos[memoId]; }
        },

        unmemoizeDomNodeAndDescendants: function (domNode, extraCallbackParamsArray) {
            var memos = [];
            findMemoNodes(domNode, memos);
            for (var i = 0, j = memos.length; i < j; i++) {
                var node = memos[i].domNode;
                var combinedParams = [node];
                if (extraCallbackParamsArray)
                    ko.utils.arrayPushAll(combinedParams, extraCallbackParamsArray);
                ko.memoization.unmemoize(memos[i].memoId, combinedParams);
                node.nodeValue = ""; // Neuter this node so we don't try to unmemoize it again
                if (node.parentNode)
                    node.parentNode.removeChild(node); // If possible, erase it totally (not always possible - someone else might just hold a reference to it then call unmemoizeDomNodeAndDescendants again)
            }
        },

        parseMemoText: function (memoText) {
            var match = memoText.match(/^\[ko_memo\:(.*?)\]$/);
            return match ? match[1] : null;
        }
    };
})();

ko.exportSymbol('memoization', ko.memoization);
ko.exportSymbol('memoization.memoize', ko.memoization.memoize);
ko.exportSymbol('memoization.unmemoize', ko.memoization.unmemoize);
ko.exportSymbol('memoization.parseMemoText', ko.memoization.parseMemoText);
ko.exportSymbol('memoization.unmemoizeDomNodeAndDescendants', ko.memoization.unmemoizeDomNodeAndDescendants);
ko.extenders = {
    'throttle': function(target, timeout) {
        // Throttling means two things:

        // (1) For dependent observables, we throttle *evaluations* so that, no matter how fast its dependencies
        //     notify updates, the target doesn't re-evaluate (and hence doesn't notify) faster than a certain rate
        target['throttleEvaluation'] = timeout;

        // (2) For writable targets (observables, or writable dependent observables), we throttle *writes*
        //     so the target cannot change value synchronously or faster than a certain rate
        var writeTimeoutInstance = null;
        return ko.dependentObservable({
            'read': target,
            'write': function(value) {
                clearTimeout(writeTimeoutInstance);
                writeTimeoutInstance = setTimeout(function() {
                    target(value);
                }, timeout);
            }
        });
    },

    'notify': function(target, notifyWhen) {
        target["equalityComparer"] = notifyWhen == "always"
            ? function() { return false } // Treat all values as not equal
            : ko.observable["fn"]["equalityComparer"];
        return target;
    }
};

function applyExtenders(requestedExtenders) {
    var target = this;
    if (requestedExtenders) {
        for (var key in requestedExtenders) {
            var extenderHandler = ko.extenders[key];
            if (typeof extenderHandler == 'function') {
                target = extenderHandler(target, requestedExtenders[key]);
            }
        }
    }
    return target;
}

ko.exportSymbol('extenders', ko.extenders);

ko.subscription = function (target, callback, disposeCallback) {
    this.target = target;
    this.callback = callback;
    this.disposeCallback = disposeCallback;
    ko.exportProperty(this, 'dispose', this.dispose);
};
ko.subscription.prototype.dispose = function () {
    this.isDisposed = true;
    this.disposeCallback();
};

ko.subscribable = function () {
    this._subscriptions = {};

    ko.utils.extend(this, ko.subscribable['fn']);
    ko.exportProperty(this, 'subscribe', this.subscribe);
    ko.exportProperty(this, 'extend', this.extend);
    ko.exportProperty(this, 'getSubscriptionsCount', this.getSubscriptionsCount);
}

var defaultEvent = "change";

ko.subscribable['fn'] = {
    subscribe: function (callback, callbackTarget, event) {
        event = event || defaultEvent;
        var boundCallback = callbackTarget ? callback.bind(callbackTarget) : callback;

        var subscription = new ko.subscription(this, boundCallback, function () {
            ko.utils.arrayRemoveItem(this._subscriptions[event], subscription);
        }.bind(this));

        if (!this._subscriptions[event])
            this._subscriptions[event] = [];
        this._subscriptions[event].push(subscription);
        return subscription;
    },

    "notifySubscribers": function (valueToNotify, event) {
        event = event || defaultEvent;
        if (this._subscriptions[event]) {
            ko.utils.arrayForEach(this._subscriptions[event].slice(0), function (subscription) {
                // In case a subscription was disposed during the arrayForEach cycle, check
                // for isDisposed on each subscription before invoking its callback
                if (subscription && (subscription.isDisposed !== true))
                    subscription.callback(valueToNotify);
            });
        }
    },

    getSubscriptionsCount: function () {
        var total = 0;
        for (var eventName in this._subscriptions) {
            if (this._subscriptions.hasOwnProperty(eventName))
                total += this._subscriptions[eventName].length;
        }
        return total;
    },

    extend: applyExtenders
};


ko.isSubscribable = function (instance) {
    return typeof instance.subscribe == "function" && typeof instance["notifySubscribers"] == "function";
};

ko.exportSymbol('subscribable', ko.subscribable);
ko.exportSymbol('isSubscribable', ko.isSubscribable);

ko.dependencyDetection = (function () {
    var _frames = [];

    return {
        begin: function (callback) {
            _frames.push({ callback: callback, distinctDependencies:[] });
        },

        end: function () {
            _frames.pop();
        },

        registerDependency: function (subscribable) {
            if (!ko.isSubscribable(subscribable))
                throw new Error("Only subscribable things can act as dependencies");
            if (_frames.length > 0) {
                var topFrame = _frames[_frames.length - 1];
                if (ko.utils.arrayIndexOf(topFrame.distinctDependencies, subscribable) >= 0)
                    return;
                topFrame.distinctDependencies.push(subscribable);
                topFrame.callback(subscribable);
            }
        }
    };
})();
var primitiveTypes = { 'undefined':true, 'boolean':true, 'number':true, 'string':true };

ko.observable = function (initialValue) {
    var _latestValue = initialValue;

    function observable() {
        if (arguments.length > 0) {
            // Write

            // Ignore writes if the value hasn't changed
            if ((!observable['equalityComparer']) || !observable['equalityComparer'](_latestValue, arguments[0])) {
                observable.valueWillMutate();
                _latestValue = arguments[0];
                if (DEBUG) observable._latestValue = _latestValue;
                observable.valueHasMutated();
            }
            return this; // Permits chained assignments
        }
        else {
            // Read
            ko.dependencyDetection.registerDependency(observable); // The caller only needs to be notified of changes if they did a "read" operation
            return _latestValue;
        }
    }
    if (DEBUG) observable._latestValue = _latestValue;
    ko.subscribable.call(observable);
    observable.valueHasMutated = function () { observable["notifySubscribers"](_latestValue); }
    observable.valueWillMutate = function () { observable["notifySubscribers"](_latestValue, "beforeChange"); }
    ko.utils.extend(observable, ko.observable['fn']);

    ko.exportProperty(observable, "valueHasMutated", observable.valueHasMutated);
    ko.exportProperty(observable, "valueWillMutate", observable.valueWillMutate);

    return observable;
}

ko.observable['fn'] = {
    "equalityComparer": function valuesArePrimitiveAndEqual(a, b) {
        var oldValueIsPrimitive = (a === null) || (typeof(a) in primitiveTypes);
        return oldValueIsPrimitive ? (a === b) : false;
    }
};

var protoProperty = ko.observable.protoProperty = "__ko_proto__";
ko.observable['fn'][protoProperty] = ko.observable;

ko.hasPrototype = function(instance, prototype) {
    if ((instance === null) || (instance === undefined) || (instance[protoProperty] === undefined)) return false;
    if (instance[protoProperty] === prototype) return true;
    return ko.hasPrototype(instance[protoProperty], prototype); // Walk the prototype chain
};

ko.isObservable = function (instance) {
    return ko.hasPrototype(instance, ko.observable);
}
ko.isWriteableObservable = function (instance) {
    // Observable
    if ((typeof instance == "function") && instance[protoProperty] === ko.observable)
        return true;
    // Writeable dependent observable
    if ((typeof instance == "function") && (instance[protoProperty] === ko.dependentObservable) && (instance.hasWriteFunction))
        return true;
    // Anything else
    return false;
}


ko.exportSymbol('observable', ko.observable);
ko.exportSymbol('isObservable', ko.isObservable);
ko.exportSymbol('isWriteableObservable', ko.isWriteableObservable);
ko.observableArray = function (initialValues) {
    if (arguments.length == 0) {
        // Zero-parameter constructor initializes to empty array
        initialValues = [];
    }
    if ((initialValues !== null) && (initialValues !== undefined) && !('length' in initialValues))
        throw new Error("The argument passed when initializing an observable array must be an array, or null, or undefined.");

    var result = ko.observable(initialValues);
    ko.utils.extend(result, ko.observableArray['fn']);
    return result;
}

ko.observableArray['fn'] = {
    'remove': function (valueOrPredicate) {
        var underlyingArray = this();
        var removedValues = [];
        var predicate = typeof valueOrPredicate == "function" ? valueOrPredicate : function (value) { return value === valueOrPredicate; };
        for (var i = 0; i < underlyingArray.length; i++) {
            var value = underlyingArray[i];
            if (predicate(value)) {
                if (removedValues.length === 0) {
                    this.valueWillMutate();
                }
                removedValues.push(value);
                underlyingArray.splice(i, 1);
                i--;
            }
        }
        if (removedValues.length) {
            this.valueHasMutated();
        }
        return removedValues;
    },

    'removeAll': function (arrayOfValues) {
        // If you passed zero args, we remove everything
        if (arrayOfValues === undefined) {
            var underlyingArray = this();
            var allValues = underlyingArray.slice(0);
            this.valueWillMutate();
            underlyingArray.splice(0, underlyingArray.length);
            this.valueHasMutated();
            return allValues;
        }
        // If you passed an arg, we interpret it as an array of entries to remove
        if (!arrayOfValues)
            return [];
        return this['remove'](function (value) {
            return ko.utils.arrayIndexOf(arrayOfValues, value) >= 0;
        });
    },

    'destroy': function (valueOrPredicate) {
        var underlyingArray = this();
        var predicate = typeof valueOrPredicate == "function" ? valueOrPredicate : function (value) { return value === valueOrPredicate; };
        this.valueWillMutate();
        for (var i = underlyingArray.length - 1; i >= 0; i--) {
            var value = underlyingArray[i];
            if (predicate(value))
                underlyingArray[i]["_destroy"] = true;
        }
        this.valueHasMutated();
    },

    'destroyAll': function (arrayOfValues) {
        // If you passed zero args, we destroy everything
        if (arrayOfValues === undefined)
            return this['destroy'](function() { return true });

        // If you passed an arg, we interpret it as an array of entries to destroy
        if (!arrayOfValues)
            return [];
        return this['destroy'](function (value) {
            return ko.utils.arrayIndexOf(arrayOfValues, value) >= 0;
        });
    },

    'indexOf': function (item) {
        var underlyingArray = this();
        return ko.utils.arrayIndexOf(underlyingArray, item);
    },

    'replace': function(oldItem, newItem) {
        var index = this['indexOf'](oldItem);
        if (index >= 0) {
            this.valueWillMutate();
            this()[index] = newItem;
            this.valueHasMutated();
        }
    }
}

// Populate ko.observableArray.fn with read/write functions from native arrays
ko.utils.arrayForEach(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function (methodName) {
    ko.observableArray['fn'][methodName] = function () {
        var underlyingArray = this();
        this.valueWillMutate();
        var methodCallResult = underlyingArray[methodName].apply(underlyingArray, arguments);
        this.valueHasMutated();
        return methodCallResult;
    };
});

// Populate ko.observableArray.fn with read-only functions from native arrays
ko.utils.arrayForEach(["slice"], function (methodName) {
    ko.observableArray['fn'][methodName] = function () {
        var underlyingArray = this();
        return underlyingArray[methodName].apply(underlyingArray, arguments);
    };
});

ko.exportSymbol('observableArray', ko.observableArray);
ko.dependentObservable = function (evaluatorFunctionOrOptions, evaluatorFunctionTarget, options) {
    var _latestValue,
        _hasBeenEvaluated = false,
        _isBeingEvaluated = false,
        readFunction = evaluatorFunctionOrOptions;

    if (readFunction && typeof readFunction == "object") {
        // Single-parameter syntax - everything is on this "options" param
        options = readFunction;
        readFunction = options["read"];
    } else {
        // Multi-parameter syntax - construct the options according to the params passed
        options = options || {};
        if (!readFunction)
            readFunction = options["read"];
    }
    // By here, "options" is always non-null
    if (typeof readFunction != "function")
        throw new Error("Pass a function that returns the value of the ko.computed");

    var writeFunction = options["write"];
    if (!evaluatorFunctionTarget)
        evaluatorFunctionTarget = options["owner"];

    var _subscriptionsToDependencies = [];
    function disposeAllSubscriptionsToDependencies() {
        ko.utils.arrayForEach(_subscriptionsToDependencies, function (subscription) {
            subscription.dispose();
        });
        _subscriptionsToDependencies = [];
    }
    var dispose = disposeAllSubscriptionsToDependencies;

    // Build "disposeWhenNodeIsRemoved" and "disposeWhenNodeIsRemovedCallback" option values
    // (Note: "disposeWhenNodeIsRemoved" option both proactively disposes as soon as the node is removed using ko.removeNode(),
    // plus adds a "disposeWhen" callback that, on each evaluation, disposes if the node was removed by some other means.)
    var disposeWhenNodeIsRemoved = (typeof options["disposeWhenNodeIsRemoved"] == "object") ? options["disposeWhenNodeIsRemoved"] : null;
    var disposeWhen = options["disposeWhen"] || function() { return false; };
    if (disposeWhenNodeIsRemoved) {
        dispose = function() {
            ko.utils.domNodeDisposal.removeDisposeCallback(disposeWhenNodeIsRemoved, arguments.callee);
            disposeAllSubscriptionsToDependencies();
        };
        ko.utils.domNodeDisposal.addDisposeCallback(disposeWhenNodeIsRemoved, dispose);
        var existingDisposeWhenFunction = disposeWhen;
        disposeWhen = function () {
            return !ko.utils.domNodeIsAttachedToDocument(disposeWhenNodeIsRemoved) || existingDisposeWhenFunction();
        }
    }

    var evaluationTimeoutInstance = null;
    function evaluatePossiblyAsync() {
        var throttleEvaluationTimeout = dependentObservable['throttleEvaluation'];
        if (throttleEvaluationTimeout && throttleEvaluationTimeout >= 0) {
            clearTimeout(evaluationTimeoutInstance);
            evaluationTimeoutInstance = setTimeout(evaluateImmediate, throttleEvaluationTimeout);
        } else
            evaluateImmediate();
    }

    function evaluateImmediate() {
        if (_isBeingEvaluated) {
            // If the evaluation of a ko.computed causes side effects, it's possible that it will trigger its own re-evaluation.
            // This is not desirable (it's hard for a developer to realise a chain of dependencies might cause this, and they almost
            // certainly didn't intend infinite re-evaluations). So, for predictability, we simply prevent ko.computeds from causing
            // their own re-evaluation. Further discussion at https://github.com/SteveSanderson/knockout/pull/387
            return;
        }

        // Don't dispose on first evaluation, because the "disposeWhen" callback might
        // e.g., dispose when the associated DOM element isn't in the doc, and it's not
        // going to be in the doc until *after* the first evaluation
        if (_hasBeenEvaluated && disposeWhen()) {
            dispose();
            return;
        }

        _isBeingEvaluated = true;
        try {
            // Initially, we assume that none of the subscriptions are still being used (i.e., all are candidates for disposal).
            // Then, during evaluation, we cross off any that are in fact still being used.
            var disposalCandidates = ko.utils.arrayMap(_subscriptionsToDependencies, function(item) {return item.target;});

            ko.dependencyDetection.begin(function(subscribable) {
                var inOld;
                if ((inOld = ko.utils.arrayIndexOf(disposalCandidates, subscribable)) >= 0)
                    disposalCandidates[inOld] = undefined; // Don't want to dispose this subscription, as it's still being used
                else
                    _subscriptionsToDependencies.push(subscribable.subscribe(evaluatePossiblyAsync)); // Brand new subscription - add it
            });

            var newValue = readFunction.call(evaluatorFunctionTarget);

            // For each subscription no longer being used, remove it from the active subscriptions list and dispose it
            for (var i = disposalCandidates.length - 1; i >= 0; i--) {
                if (disposalCandidates[i])
                    _subscriptionsToDependencies.splice(i, 1)[0].dispose();
            }
            _hasBeenEvaluated = true;

            dependentObservable["notifySubscribers"](_latestValue, "beforeChange");
            _latestValue = newValue;
            if (DEBUG) dependentObservable._latestValue = _latestValue;
        } finally {
            ko.dependencyDetection.end();
        }

        dependentObservable["notifySubscribers"](_latestValue);
        _isBeingEvaluated = false;

    }

    function dependentObservable() {
        if (arguments.length > 0) {
            set.apply(dependentObservable, arguments);
        } else {
            return get();
        }
    }

    function set() {
        if (typeof writeFunction === "function") {
            // Writing a value
            writeFunction.apply(evaluatorFunctionTarget, arguments);
        } else {
            throw new Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.");
        }
    }

    function get() {
        // Reading the value
        if (!_hasBeenEvaluated)
            evaluateImmediate();
        ko.dependencyDetection.registerDependency(dependentObservable);
        return _latestValue;
    }

    dependentObservable.getDependenciesCount = function () { return _subscriptionsToDependencies.length; };
    dependentObservable.hasWriteFunction = typeof options["write"] === "function";
    dependentObservable.dispose = function () { dispose(); };

    ko.subscribable.call(dependentObservable);
    ko.utils.extend(dependentObservable, ko.dependentObservable['fn']);

    if (options['deferEvaluation'] !== true)
        evaluateImmediate();

    ko.exportProperty(dependentObservable, 'dispose', dependentObservable.dispose);
    ko.exportProperty(dependentObservable, 'getDependenciesCount', dependentObservable.getDependenciesCount);

    return dependentObservable;
};

ko.isComputed = function(instance) {
    return ko.hasPrototype(instance, ko.dependentObservable);
};

var protoProp = ko.observable.protoProperty; // == "__ko_proto__"
ko.dependentObservable[protoProp] = ko.observable;

ko.dependentObservable['fn'] = {};
ko.dependentObservable['fn'][protoProp] = ko.dependentObservable;

ko.exportSymbol('dependentObservable', ko.dependentObservable);
ko.exportSymbol('computed', ko.dependentObservable); // Make "ko.computed" an alias for "ko.dependentObservable"
ko.exportSymbol('isComputed', ko.isComputed);

(function() {
    var maxNestedObservableDepth = 10; // Escape the (unlikely) pathalogical case where an observable's current value is itself (or similar reference cycle)

    ko.toJS = function(rootObject) {
        if (arguments.length == 0)
            throw new Error("When calling ko.toJS, pass the object you want to convert.");

        // We just unwrap everything at every level in the object graph
        return mapJsObjectGraph(rootObject, function(valueToMap) {
            // Loop because an observable's value might in turn be another observable wrapper
            for (var i = 0; ko.isObservable(valueToMap) && (i < maxNestedObservableDepth); i++)
                valueToMap = valueToMap();
            return valueToMap;
        });
    };

    ko.toJSON = function(rootObject, replacer, space) {     // replacer and space are optional
        var plainJavaScriptObject = ko.toJS(rootObject);
        return ko.utils.stringifyJson(plainJavaScriptObject, replacer, space);
    };

    function mapJsObjectGraph(rootObject, mapInputCallback, visitedObjects) {
        visitedObjects = visitedObjects || new objectLookup();

        rootObject = mapInputCallback(rootObject);
        var canHaveProperties = (typeof rootObject == "object") && (rootObject !== null) && (rootObject !== undefined) && (!(rootObject instanceof Date));
        if (!canHaveProperties)
            return rootObject;

        var outputProperties = rootObject instanceof Array ? [] : {};
        visitedObjects.save(rootObject, outputProperties);

        visitPropertiesOrArrayEntries(rootObject, function(indexer) {
            var propertyValue = mapInputCallback(rootObject[indexer]);

            switch (typeof propertyValue) {
                case "boolean":
                case "number":
                case "string":
                case "function":
                    outputProperties[indexer] = propertyValue;
                    break;
                case "object":
                case "undefined":
                    var previouslyMappedValue = visitedObjects.get(propertyValue);
                    outputProperties[indexer] = (previouslyMappedValue !== undefined)
                        ? previouslyMappedValue
                        : mapJsObjectGraph(propertyValue, mapInputCallback, visitedObjects);
                    break;
            }
        });

        return outputProperties;
    }

    function visitPropertiesOrArrayEntries(rootObject, visitorCallback) {
        if (rootObject instanceof Array) {
            for (var i = 0; i < rootObject.length; i++)
                visitorCallback(i);

            // For arrays, also respect toJSON property for custom mappings (fixes #278)
            if (typeof rootObject['toJSON'] == 'function')
                visitorCallback('toJSON');
        } else {
            for (var propertyName in rootObject)
                visitorCallback(propertyName);
        }
    };

    function objectLookup() {
        var keys = [];
        var values = [];
        this.save = function(key, value) {
            var existingIndex = ko.utils.arrayIndexOf(keys, key);
            if (existingIndex >= 0)
                values[existingIndex] = value;
            else {
                keys.push(key);
                values.push(value);
            }
        };
        this.get = function(key) {
            var existingIndex = ko.utils.arrayIndexOf(keys, key);
            return (existingIndex >= 0) ? values[existingIndex] : undefined;
        };
    };
})();

ko.exportSymbol('toJS', ko.toJS);
ko.exportSymbol('toJSON', ko.toJSON);
(function () {
    var hasDomDataExpandoProperty = '__ko__hasDomDataOptionValue__';

    // Normally, SELECT elements and their OPTIONs can only take value of type 'string' (because the values
    // are stored on DOM attributes). ko.selectExtensions provides a way for SELECTs/OPTIONs to have values
    // that are arbitrary objects. This is very convenient when implementing things like cascading dropdowns.
    ko.selectExtensions = {
        readValue : function(element) {
            switch (ko.utils.tagNameLower(element)) {
                case 'option':
                    if (element[hasDomDataExpandoProperty] === true)
                        return ko.utils.domData.get(element, ko.bindingHandlers.options.optionValueDomDataKey);
                    return element.getAttribute("value");
                case 'select':
                    return element.selectedIndex >= 0 ? ko.selectExtensions.readValue(element.options[element.selectedIndex]) : undefined;
                default:
                    return element.value;
            }
        },

        writeValue: function(element, value) {
            switch (ko.utils.tagNameLower(element)) {
                case 'option':
                    switch(typeof value) {
                        case "string":
                            ko.utils.domData.set(element, ko.bindingHandlers.options.optionValueDomDataKey, undefined);
                            if (hasDomDataExpandoProperty in element) { // IE <= 8 throws errors if you delete non-existent properties from a DOM node
                                delete element[hasDomDataExpandoProperty];
                            }
                            element.value = value;
                            break;
                        default:
                            // Store arbitrary object using DomData
                            ko.utils.domData.set(element, ko.bindingHandlers.options.optionValueDomDataKey, value);
                            element[hasDomDataExpandoProperty] = true;

                            // Special treatment of numbers is just for backward compatibility. KO 1.2.1 wrote numerical values to element.value.
                            element.value = typeof value === "number" ? value : "";
                            break;
                    }
                    break;
                case 'select':
                    for (var i = element.options.length - 1; i >= 0; i--) {
                        if (ko.selectExtensions.readValue(element.options[i]) == value) {
                            element.selectedIndex = i;
                            break;
                        }
                    }
                    break;
                default:
                    if ((value === null) || (value === undefined))
                        value = "";
                    element.value = value;
                    break;
            }
        }
    };
})();

ko.exportSymbol('selectExtensions', ko.selectExtensions);
ko.exportSymbol('selectExtensions.readValue', ko.selectExtensions.readValue);
ko.exportSymbol('selectExtensions.writeValue', ko.selectExtensions.writeValue);

ko.jsonExpressionRewriting = (function () {
    var restoreCapturedTokensRegex = /\@ko_token_(\d+)\@/g;
    var javaScriptAssignmentTarget = /^[\_$a-z][\_$a-z0-9]*(\[.*?\])*(\.[\_$a-z][\_$a-z0-9]*(\[.*?\])*)*$/i;
    var javaScriptReservedWords = ["true", "false"];

    function restoreTokens(string, tokens) {
        var prevValue = null;
        while (string != prevValue) { // Keep restoring tokens until it no longer makes a difference (they may be nested)
            prevValue = string;
            string = string.replace(restoreCapturedTokensRegex, function (match, tokenIndex) {
                return tokens[tokenIndex];
            });
        }
        return string;
    }

    function isWriteableValue(expression) {
        if (ko.utils.arrayIndexOf(javaScriptReservedWords, ko.utils.stringTrim(expression).toLowerCase()) >= 0)
            return false;
        return expression.match(javaScriptAssignmentTarget) !== null;
    }

    function ensureQuoted(key) {
        var trimmedKey = ko.utils.stringTrim(key);
        switch (trimmedKey.length && trimmedKey.charAt(0)) {
            case "'":
            case '"':
                return key;
            default:
                return "'" + trimmedKey + "'";
        }
    }

    return {
        bindingRewriteValidators: [],

        parseObjectLiteral: function(objectLiteralString) {
            // A full tokeniser+lexer would add too much weight to this library, so here's a simple parser
            // that is sufficient just to split an object literal string into a set of top-level key-value pairs

            var str = ko.utils.stringTrim(objectLiteralString);
            if (str.length < 3)
                return [];
            if (str.charAt(0) === "{")// Ignore any braces surrounding the whole object literal
                str = str.substring(1, str.length - 1);

            // Pull out any string literals and regex literals
            var tokens = [];
            var tokenStart = null, tokenEndChar;
            for (var position = 0; position < str.length; position++) {
                var c = str.charAt(position);
                if (tokenStart === null) {
                    switch (c) {
                        case '"':
                        case "'":
                        case "/":
                            tokenStart = position;
                            tokenEndChar = c;
                            break;
                    }
                } else if ((c == tokenEndChar) && (str.charAt(position - 1) !== "\\")) {
                    var token = str.substring(tokenStart, position + 1);
                    tokens.push(token);
                    var replacement = "@ko_token_" + (tokens.length - 1) + "@";
                    str = str.substring(0, tokenStart) + replacement + str.substring(position + 1);
                    position -= (token.length - replacement.length);
                    tokenStart = null;
                }
            }

            // Next pull out balanced paren, brace, and bracket blocks
            tokenStart = null;
            tokenEndChar = null;
            var tokenDepth = 0, tokenStartChar = null;
            for (var position = 0; position < str.length; position++) {
                var c = str.charAt(position);
                if (tokenStart === null) {
                    switch (c) {
                        case "{": tokenStart = position; tokenStartChar = c;
                                  tokenEndChar = "}";
                                  break;
                        case "(": tokenStart = position; tokenStartChar = c;
                                  tokenEndChar = ")";
                                  break;
                        case "[": tokenStart = position; tokenStartChar = c;
                                  tokenEndChar = "]";
                                  break;
                    }
                }

                if (c === tokenStartChar)
                    tokenDepth++;
                else if (c === tokenEndChar) {
                    tokenDepth--;
                    if (tokenDepth === 0) {
                        var token = str.substring(tokenStart, position + 1);
                        tokens.push(token);
                        var replacement = "@ko_token_" + (tokens.length - 1) + "@";
                        str = str.substring(0, tokenStart) + replacement + str.substring(position + 1);
                        position -= (token.length - replacement.length);
                        tokenStart = null;
                    }
                }
            }

            // Now we can safely split on commas to get the key/value pairs
            var result = [];
            var keyValuePairs = str.split(",");
            for (var i = 0, j = keyValuePairs.length; i < j; i++) {
                var pair = keyValuePairs[i];
                var colonPos = pair.indexOf(":");
                if ((colonPos > 0) && (colonPos < pair.length - 1)) {
                    var key = pair.substring(0, colonPos);
                    var value = pair.substring(colonPos + 1);
                    result.push({ 'key': restoreTokens(key, tokens), 'value': restoreTokens(value, tokens) });
                } else {
                    result.push({ 'unknown': restoreTokens(pair, tokens) });
                }
            }
            return result;
        },

        insertPropertyAccessorsIntoJson: function (objectLiteralStringOrKeyValueArray) {
            var keyValueArray = typeof objectLiteralStringOrKeyValueArray === "string"
                ? ko.jsonExpressionRewriting.parseObjectLiteral(objectLiteralStringOrKeyValueArray)
                : objectLiteralStringOrKeyValueArray;
            var resultStrings = [], propertyAccessorResultStrings = [];

            var keyValueEntry;
            for (var i = 0; keyValueEntry = keyValueArray[i]; i++) {
                if (resultStrings.length > 0)
                    resultStrings.push(",");

                if (keyValueEntry['key']) {
                    var quotedKey = ensureQuoted(keyValueEntry['key']), val = keyValueEntry['value'];
                    resultStrings.push(quotedKey);
                    resultStrings.push(":");
                    resultStrings.push(val);

                    if (isWriteableValue(ko.utils.stringTrim(val))) {
                        if (propertyAccessorResultStrings.length > 0)
                            propertyAccessorResultStrings.push(", ");
                        propertyAccessorResultStrings.push(quotedKey + " : function(__ko_value) { " + val + " = __ko_value; }");
                    }
                } else if (keyValueEntry['unknown']) {
                    resultStrings.push(keyValueEntry['unknown']);
                }
            }

            var combinedResult = resultStrings.join("");
            if (propertyAccessorResultStrings.length > 0) {
                var allPropertyAccessors = propertyAccessorResultStrings.join("");
                combinedResult = combinedResult + ", '_ko_property_writers' : { " + allPropertyAccessors + " } ";
            }

            return combinedResult;
        },

        keyValueArrayContainsKey: function(keyValueArray, key) {
            for (var i = 0; i < keyValueArray.length; i++)
                if (ko.utils.stringTrim(keyValueArray[i]['key']) == key)
                    return true;
            return false;
        },

        // Internal, private KO utility for updating model properties from within bindings
        // property:            If the property being updated is (or might be) an observable, pass it here
        //                      If it turns out to be a writable observable, it will be written to directly
        // allBindingsAccessor: All bindings in the current execution context.
        //                      This will be searched for a '_ko_property_writers' property in case you're writing to a non-observable
        // key:                 The key identifying the property to be written. Example: for { hasFocus: myValue }, write to 'myValue' by specifying the key 'hasFocus'
        // value:               The value to be written
        // checkIfDifferent:    If true, and if the property being written is a writable observable, the value will only be written if
        //                      it is !== existing value on that writable observable
        writeValueToProperty: function(property, allBindingsAccessor, key, value, checkIfDifferent) {
            if (!property || !ko.isWriteableObservable(property)) {
                var propWriters = allBindingsAccessor()['_ko_property_writers'];
                if (propWriters && propWriters[key])
                    propWriters[key](value);
            } else if (!checkIfDifferent || property() !== value) {
                property(value);
            }
        }
    };
})();

ko.exportSymbol('jsonExpressionRewriting', ko.jsonExpressionRewriting);
ko.exportSymbol('jsonExpressionRewriting.bindingRewriteValidators', ko.jsonExpressionRewriting.bindingRewriteValidators);
ko.exportSymbol('jsonExpressionRewriting.parseObjectLiteral', ko.jsonExpressionRewriting.parseObjectLiteral);
ko.exportSymbol('jsonExpressionRewriting.insertPropertyAccessorsIntoJson', ko.jsonExpressionRewriting.insertPropertyAccessorsIntoJson);
(function() {
    // "Virtual elements" is an abstraction on top of the usual DOM API which understands the notion that comment nodes
    // may be used to represent hierarchy (in addition to the DOM's natural hierarchy).
    // If you call the DOM-manipulating functions on ko.virtualElements, you will be able to read and write the state
    // of that virtual hierarchy
    //
    // The point of all this is to support containerless templates (e.g., <!-- ko foreach:someCollection -->blah<!-- /ko -->)
    // without having to scatter special cases all over the binding and templating code.

    // IE 9 cannot reliably read the "nodeValue" property of a comment node (see https://github.com/SteveSanderson/knockout/issues/186)
    // but it does give them a nonstandard alternative property called "text" that it can read reliably. Other browsers don't have that property.
    // So, use node.text where available, and node.nodeValue elsewhere
    var commentNodesHaveTextProperty = document.createComment("test").text === "<!--test-->";

    var startCommentRegex = commentNodesHaveTextProperty ? /^<!--\s*ko\s+(.*\:.*)\s*-->$/ : /^\s*ko\s+(.*\:.*)\s*$/;
    var endCommentRegex =   commentNodesHaveTextProperty ? /^<!--\s*\/ko\s*-->$/ : /^\s*\/ko\s*$/;
    var htmlTagsWithOptionallyClosingChildren = { 'ul': true, 'ol': true };

    function isStartComment(node) {
        return (node.nodeType == 8) && (commentNodesHaveTextProperty ? node.text : node.nodeValue).match(startCommentRegex);
    }

    function isEndComment(node) {
        return (node.nodeType == 8) && (commentNodesHaveTextProperty ? node.text : node.nodeValue).match(endCommentRegex);
    }

    function getVirtualChildren(startComment, allowUnbalanced) {
        var currentNode = startComment;
        var depth = 1;
        var children = [];
        while (currentNode = currentNode.nextSibling) {
            if (isEndComment(currentNode)) {
                depth--;
                if (depth === 0)
                    return children;
            }

            children.push(currentNode);

            if (isStartComment(currentNode))
                depth++;
        }
        if (!allowUnbalanced)
            throw new Error("Cannot find closing comment tag to match: " + startComment.nodeValue);
        return null;
    }

    function getMatchingEndComment(startComment, allowUnbalanced) {
        var allVirtualChildren = getVirtualChildren(startComment, allowUnbalanced);
        if (allVirtualChildren) {
            if (allVirtualChildren.length > 0)
                return allVirtualChildren[allVirtualChildren.length - 1].nextSibling;
            return startComment.nextSibling;
        } else
            return null; // Must have no matching end comment, and allowUnbalanced is true
    }

    function getUnbalancedChildTags(node) {
        // e.g., from <div>OK</div><!-- ko blah --><span>Another</span>, returns: <!-- ko blah --><span>Another</span>
        //       from <div>OK</div><!-- /ko --><!-- /ko -->,             returns: <!-- /ko --><!-- /ko -->
        var childNode = node.firstChild, captureRemaining = null;
        if (childNode) {
            do {
                if (captureRemaining)                   // We already hit an unbalanced node and are now just scooping up all subsequent nodes
                    captureRemaining.push(childNode);
                else if (isStartComment(childNode)) {
                    var matchingEndComment = getMatchingEndComment(childNode, /* allowUnbalanced: */ true);
                    if (matchingEndComment)             // It's a balanced tag, so skip immediately to the end of this virtual set
                        childNode = matchingEndComment;
                    else
                        captureRemaining = [childNode]; // It's unbalanced, so start capturing from this point
                } else if (isEndComment(childNode)) {
                    captureRemaining = [childNode];     // It's unbalanced (if it wasn't, we'd have skipped over it already), so start capturing
                }
            } while (childNode = childNode.nextSibling);
        }
        return captureRemaining;
    }

    ko.virtualElements = {
        allowedBindings: {},

        childNodes: function(node) {
            return isStartComment(node) ? getVirtualChildren(node) : node.childNodes;
        },

        emptyNode: function(node) {
            if (!isStartComment(node))
                ko.utils.emptyDomNode(node);
            else {
                var virtualChildren = ko.virtualElements.childNodes(node);
                for (var i = 0, j = virtualChildren.length; i < j; i++)
                    ko.removeNode(virtualChildren[i]);
            }
        },

        setDomNodeChildren: function(node, childNodes) {
            if (!isStartComment(node))
                ko.utils.setDomNodeChildren(node, childNodes);
            else {
                ko.virtualElements.emptyNode(node);
                var endCommentNode = node.nextSibling; // Must be the next sibling, as we just emptied the children
                for (var i = 0, j = childNodes.length; i < j; i++)
                    endCommentNode.parentNode.insertBefore(childNodes[i], endCommentNode);
            }
        },

        prepend: function(containerNode, nodeToPrepend) {
            if (!isStartComment(containerNode)) {
                if (containerNode.firstChild)
                    containerNode.insertBefore(nodeToPrepend, containerNode.firstChild);
                else
                    containerNode.appendChild(nodeToPrepend);
            } else {
                // Start comments must always have a parent and at least one following sibling (the end comment)
                containerNode.parentNode.insertBefore(nodeToPrepend, containerNode.nextSibling);
            }
        },

        insertAfter: function(containerNode, nodeToInsert, insertAfterNode) {
            if (!isStartComment(containerNode)) {
                // Insert after insertion point
                if (insertAfterNode.nextSibling)
                    containerNode.insertBefore(nodeToInsert, insertAfterNode.nextSibling);
                else
                    containerNode.appendChild(nodeToInsert);
            } else {
                // Children of start comments must always have a parent and at least one following sibling (the end comment)
                containerNode.parentNode.insertBefore(nodeToInsert, insertAfterNode.nextSibling);
            }
        },

        firstChild: function(node) {
            if (!isStartComment(node))
                return node.firstChild;
            if (!node.nextSibling || isEndComment(node.nextSibling))
                return null;
            return node.nextSibling;
        },

        nextSibling: function(node) {
            if (isStartComment(node))
                node = getMatchingEndComment(node);
            if (node.nextSibling && isEndComment(node.nextSibling))
                return null;
            return node.nextSibling;
        },

        virtualNodeBindingValue: function(node) {
            var regexMatch = isStartComment(node);
            return regexMatch ? regexMatch[1] : null;
        },

        normaliseVirtualElementDomStructure: function(elementVerified) {
            // Workaround for https://github.com/SteveSanderson/knockout/issues/155
            // (IE <= 8 or IE 9 quirks mode parses your HTML weirdly, treating closing </li> tags as if they don't exist, thereby moving comment nodes
            // that are direct descendants of <ul> into the preceding <li>)
            if (!htmlTagsWithOptionallyClosingChildren[ko.utils.tagNameLower(elementVerified)])
                return;

            // Scan immediate children to see if they contain unbalanced comment tags. If they do, those comment tags
            // must be intended to appear *after* that child, so move them there.
            var childNode = elementVerified.firstChild;
            if (childNode) {
                do {
                    if (childNode.nodeType === 1) {
                        var unbalancedTags = getUnbalancedChildTags(childNode);
                        if (unbalancedTags) {
                            // Fix up the DOM by moving the unbalanced tags to where they most likely were intended to be placed - *after* the child
                            var nodeToInsertBefore = childNode.nextSibling;
                            for (var i = 0; i < unbalancedTags.length; i++) {
                                if (nodeToInsertBefore)
                                    elementVerified.insertBefore(unbalancedTags[i], nodeToInsertBefore);
                                else
                                    elementVerified.appendChild(unbalancedTags[i]);
                            }
                        }
                    }
                } while (childNode = childNode.nextSibling);
            }
        }
    };
})();
ko.exportSymbol('virtualElements', ko.virtualElements);
ko.exportSymbol('virtualElements.allowedBindings', ko.virtualElements.allowedBindings);
ko.exportSymbol('virtualElements.emptyNode', ko.virtualElements.emptyNode);
//ko.exportSymbol('virtualElements.firstChild', ko.virtualElements.firstChild);     // firstChild is not minified
ko.exportSymbol('virtualElements.insertAfter', ko.virtualElements.insertAfter);
//ko.exportSymbol('virtualElements.nextSibling', ko.virtualElements.nextSibling);   // nextSibling is not minified
ko.exportSymbol('virtualElements.prepend', ko.virtualElements.prepend);
ko.exportSymbol('virtualElements.setDomNodeChildren', ko.virtualElements.setDomNodeChildren);
(function() {
    var defaultBindingAttributeName = "data-bind";

    ko.bindingProvider = function() {
        this.bindingCache = {};
    };

    ko.utils.extend(ko.bindingProvider.prototype, {
        'nodeHasBindings': function(node) {
            switch (node.nodeType) {
                case 1: return node.getAttribute(defaultBindingAttributeName) != null;   // Element
                case 8: return ko.virtualElements.virtualNodeBindingValue(node) != null; // Comment node
                default: return false;
            }
        },

        'getBindings': function(node, bindingContext) {
            var bindingsString = this['getBindingsString'](node, bindingContext);
            return bindingsString ? this['parseBindingsString'](bindingsString, bindingContext) : null;
        },

        // The following function is only used internally by this default provider.
        // It's not part of the interface definition for a general binding provider.
        'getBindingsString': function(node, bindingContext) {
            switch (node.nodeType) {
                case 1: return node.getAttribute(defaultBindingAttributeName);   // Element
                case 8: return ko.virtualElements.virtualNodeBindingValue(node); // Comment node
                default: return null;
            }
        },

        // The following function is only used internally by this default provider.
        // It's not part of the interface definition for a general binding provider.
        'parseBindingsString': function(bindingsString, bindingContext) {
            try {
                var viewModel = bindingContext['$data'],
                    scopes = (typeof viewModel == 'object' && viewModel != null) ? [viewModel, bindingContext] : [bindingContext],
                    bindingFunction = createBindingsStringEvaluatorViaCache(bindingsString, scopes.length, this.bindingCache);
                return bindingFunction(scopes);
            } catch (ex) {
                throw new Error("Unable to parse bindings.\nMessage: " + ex + ";\nBindings value: " + bindingsString);
            }
        }
    });

    ko.bindingProvider['instance'] = new ko.bindingProvider();

    function createBindingsStringEvaluatorViaCache(bindingsString, scopesCount, cache) {
        var cacheKey = scopesCount + '_' + bindingsString;
        return cache[cacheKey]
            || (cache[cacheKey] = createBindingsStringEvaluator(bindingsString, scopesCount));
    }

    function createBindingsStringEvaluator(bindingsString, scopesCount) {
        var rewrittenBindings = " { " + ko.jsonExpressionRewriting.insertPropertyAccessorsIntoJson(bindingsString) + " } ";
        return ko.utils.buildEvalWithinScopeFunction(rewrittenBindings, scopesCount);
    }
})();

ko.exportSymbol('bindingProvider', ko.bindingProvider);
(function () {
    ko.bindingHandlers = {};

    ko.bindingContext = function(dataItem, parentBindingContext) {
        if (parentBindingContext) {
            ko.utils.extend(this, parentBindingContext); // Inherit $root and any custom properties
            this['$parentContext'] = parentBindingContext;
            this['$parent'] = parentBindingContext['$data'];
            this['$parents'] = (parentBindingContext['$parents'] || []).slice(0);
            this['$parents'].unshift(this['$parent']);
        } else {
            this['$parents'] = [];
            this['$root'] = dataItem;
        }
        this['$data'] = dataItem;
    }
    ko.bindingContext.prototype['createChildContext'] = function (dataItem) {
        return new ko.bindingContext(dataItem, this);
    };
    ko.bindingContext.prototype['extend'] = function(properties) {
        var clone = ko.utils.extend(new ko.bindingContext(), this);
        return ko.utils.extend(clone, properties);
    };

    function validateThatBindingIsAllowedForVirtualElements(bindingName) {
        var validator = ko.virtualElements.allowedBindings[bindingName];
        if (!validator)
            throw new Error("The binding '" + bindingName + "' cannot be used with virtual elements")
    }

    function applyBindingsToDescendantsInternal (viewModel, elementOrVirtualElement, bindingContextsMayDifferFromDomParentElement) {
        var currentChild, nextInQueue = ko.virtualElements.firstChild(elementOrVirtualElement);
        while (currentChild = nextInQueue) {
            // Keep a record of the next child *before* applying bindings, in case the binding removes the current child from its position
            nextInQueue = ko.virtualElements.nextSibling(currentChild);
            applyBindingsToNodeAndDescendantsInternal(viewModel, currentChild, bindingContextsMayDifferFromDomParentElement);
        }
    }

    function applyBindingsToNodeAndDescendantsInternal (viewModel, nodeVerified, bindingContextMayDifferFromDomParentElement) {
        var shouldBindDescendants = true;

        // Perf optimisation: Apply bindings only if...
        // (1) We need to store the binding context on this node (because it may differ from the DOM parent node's binding context)
        //     Note that we can't store binding contexts on non-elements (e.g., text nodes), as IE doesn't allow expando properties for those
        // (2) It might have bindings (e.g., it has a data-bind attribute, or it's a marker for a containerless template)
        var isElement = (nodeVerified.nodeType === 1);
        if (isElement) // Workaround IE <= 8 HTML parsing weirdness
            ko.virtualElements.normaliseVirtualElementDomStructure(nodeVerified);

        var shouldApplyBindings = (isElement && bindingContextMayDifferFromDomParentElement)             // Case (1)
                               || ko.bindingProvider['instance']['nodeHasBindings'](nodeVerified);       // Case (2)
        if (shouldApplyBindings)
            shouldBindDescendants = applyBindingsToNodeInternal(nodeVerified, null, viewModel, bindingContextMayDifferFromDomParentElement).shouldBindDescendants;

        if (shouldBindDescendants) {
            // We're recursing automatically into (real or virtual) child nodes without changing binding contexts. So,
            //  * For children of a *real* element, the binding context is certainly the same as on their DOM .parentNode,
            //    hence bindingContextsMayDifferFromDomParentElement is false
            //  * For children of a *virtual* element, we can't be sure. Evaluating .parentNode on those children may
            //    skip over any number of intermediate virtual elements, any of which might define a custom binding context,
            //    hence bindingContextsMayDifferFromDomParentElement is true
            applyBindingsToDescendantsInternal(viewModel, nodeVerified, /* bindingContextsMayDifferFromDomParentElement: */ !isElement);
        }
    }

    function applyBindingsToNodeInternal (node, bindings, viewModelOrBindingContext, bindingContextMayDifferFromDomParentElement) {
        // Need to be sure that inits are only run once, and updates never run until all the inits have been run
        var initPhase = 0; // 0 = before all inits, 1 = during inits, 2 = after all inits

        // Each time the dependentObservable is evaluated (after data changes),
        // the binding attribute is reparsed so that it can pick out the correct
        // model properties in the context of the changed data.
        // DOM event callbacks need to be able to access this changed data,
        // so we need a single parsedBindings variable (shared by all callbacks
        // associated with this node's bindings) that all the closures can access.
        var parsedBindings;
        function makeValueAccessor(bindingKey) {
            return function () { return parsedBindings[bindingKey] }
        }
        function parsedBindingsAccessor() {
            return parsedBindings;
        }

        var bindingHandlerThatControlsDescendantBindings;
        ko.dependentObservable(
            function () {
                // Ensure we have a nonnull binding context to work with
                var bindingContextInstance = viewModelOrBindingContext && (viewModelOrBindingContext instanceof ko.bindingContext)
                    ? viewModelOrBindingContext
                    : new ko.bindingContext(ko.utils.unwrapObservable(viewModelOrBindingContext));
                var viewModel = bindingContextInstance['$data'];

                // Optimization: Don't store the binding context on this node if it's definitely the same as on node.parentNode, because
                // we can easily recover it just by scanning up the node's ancestors in the DOM
                // (note: here, parent node means "real DOM parent" not "virtual parent", as there's no O(1) way to find the virtual parent)
                if (bindingContextMayDifferFromDomParentElement)
                    ko.storedBindingContextForNode(node, bindingContextInstance);

                // Use evaluatedBindings if given, otherwise fall back on asking the bindings provider to give us some bindings
                var evaluatedBindings = (typeof bindings == "function") ? bindings() : bindings;
                parsedBindings = evaluatedBindings || ko.bindingProvider['instance']['getBindings'](node, bindingContextInstance);

                if (parsedBindings) {
                    // First run all the inits, so bindings can register for notification on changes
                    if (initPhase === 0) {
                        initPhase = 1;
                        for (var bindingKey in parsedBindings) {
                            var binding = ko.bindingHandlers[bindingKey];
                            if (binding && node.nodeType === 8)
                                validateThatBindingIsAllowedForVirtualElements(bindingKey);

                            if (binding && typeof binding["init"] == "function") {
                                var handlerInitFn = binding["init"];
                                var initResult = handlerInitFn(node, makeValueAccessor(bindingKey), parsedBindingsAccessor, viewModel, bindingContextInstance);

                                // If this binding handler claims to control descendant bindings, make a note of this
                                if (initResult && initResult['controlsDescendantBindings']) {
                                    if (bindingHandlerThatControlsDescendantBindings !== undefined)
                                        throw new Error("Multiple bindings (" + bindingHandlerThatControlsDescendantBindings + " and " + bindingKey + ") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.");
                                    bindingHandlerThatControlsDescendantBindings = bindingKey;
                                }
                            }
                        }
                        initPhase = 2;
                    }

                    // ... then run all the updates, which might trigger changes even on the first evaluation
                    if (initPhase === 2) {
                        for (var bindingKey in parsedBindings) {
                            var binding = ko.bindingHandlers[bindingKey];
                            if (binding && typeof binding["update"] == "function") {
                                var handlerUpdateFn = binding["update"];
                                handlerUpdateFn(node, makeValueAccessor(bindingKey), parsedBindingsAccessor, viewModel, bindingContextInstance);
                            }
                        }
                    }
                }
            },
            null,
            { 'disposeWhenNodeIsRemoved' : node }
        );

        return {
            shouldBindDescendants: bindingHandlerThatControlsDescendantBindings === undefined
        };
    };

    var storedBindingContextDomDataKey = "__ko_bindingContext__";
    ko.storedBindingContextForNode = function (node, bindingContext) {
        if (arguments.length == 2)
            ko.utils.domData.set(node, storedBindingContextDomDataKey, bindingContext);
        else
            return ko.utils.domData.get(node, storedBindingContextDomDataKey);
    }

    ko.applyBindingsToNode = function (node, bindings, viewModel) {
        if (node.nodeType === 1) // If it's an element, workaround IE <= 8 HTML parsing weirdness
            ko.virtualElements.normaliseVirtualElementDomStructure(node);
        return applyBindingsToNodeInternal(node, bindings, viewModel, true);
    };

    ko.applyBindingsToDescendants = function(viewModel, rootNode) {
        if (rootNode.nodeType === 1 || rootNode.nodeType === 8)
            applyBindingsToDescendantsInternal(viewModel, rootNode, true);
    };

    ko.applyBindings = function (viewModel, rootNode) {
        if (rootNode && (rootNode.nodeType !== 1) && (rootNode.nodeType !== 8))
            throw new Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node");
        rootNode = rootNode || window.document.body; // Make "rootNode" parameter optional

        applyBindingsToNodeAndDescendantsInternal(viewModel, rootNode, true);
    };

    // Retrieving binding context from arbitrary nodes
    ko.contextFor = function(node) {
        // We can only do something meaningful for elements and comment nodes (in particular, not text nodes, as IE can't store domdata for them)
        switch (node.nodeType) {
            case 1:
            case 8:
                var context = ko.storedBindingContextForNode(node);
                if (context) return context;
                if (node.parentNode) return ko.contextFor(node.parentNode);
                break;
        }
        return undefined;
    };
    ko.dataFor = function(node) {
        var context = ko.contextFor(node);
        return context ? context['$data'] : undefined;
    };

    ko.exportSymbol('bindingHandlers', ko.bindingHandlers);
    ko.exportSymbol('applyBindings', ko.applyBindings);
    ko.exportSymbol('applyBindingsToDescendants', ko.applyBindingsToDescendants);
    ko.exportSymbol('applyBindingsToNode', ko.applyBindingsToNode);
    ko.exportSymbol('contextFor', ko.contextFor);
    ko.exportSymbol('dataFor', ko.dataFor);
})();
// For certain common events (currently just 'click'), allow a simplified data-binding syntax
// e.g. click:handler instead of the usual full-length event:{click:handler}
var eventHandlersWithShortcuts = ['click'];
ko.utils.arrayForEach(eventHandlersWithShortcuts, function(eventName) {
    ko.bindingHandlers[eventName] = {
        'init': function(element, valueAccessor, allBindingsAccessor, viewModel) {
            var newValueAccessor = function () {
                var result = {};
                result[eventName] = valueAccessor();
                return result;
            };
            return ko.bindingHandlers['event']['init'].call(this, element, newValueAccessor, allBindingsAccessor, viewModel);
        }
    }
});


ko.bindingHandlers['event'] = {
    'init' : function (element, valueAccessor, allBindingsAccessor, viewModel) {
        var eventsToHandle = valueAccessor() || {};
        for(var eventNameOutsideClosure in eventsToHandle) {
            (function() {
                var eventName = eventNameOutsideClosure; // Separate variable to be captured by event handler closure
                if (typeof eventName == "string") {
                    ko.utils.registerEventHandler(element, eventName, function (event) {
                        var handlerReturnValue;
                        var handlerFunction = valueAccessor()[eventName];
                        if (!handlerFunction)
                            return;
                        var allBindings = allBindingsAccessor();

                        try {
                            // Take all the event args, and prefix with the viewmodel
                            var argsForHandler = ko.utils.makeArray(arguments);
                            argsForHandler.unshift(viewModel);
                            handlerReturnValue = handlerFunction.apply(viewModel, argsForHandler);
                        } finally {
                            if (handlerReturnValue !== true) { // Normally we want to prevent default action. Developer can override this be explicitly returning true.
                                if (event.preventDefault)
                                    event.preventDefault();
                                else
                                    event.returnValue = false;
                            }
                        }

                        var bubble = allBindings[eventName + 'Bubble'] !== false;
                        if (!bubble) {
                            event.cancelBubble = true;
                            if (event.stopPropagation)
                                event.stopPropagation();
                        }
                    });
                }
            })();
        }
    }
};

ko.bindingHandlers['submit'] = {
    'init': function (element, valueAccessor, allBindingsAccessor, viewModel) {
        if (typeof valueAccessor() != "function")
            throw new Error("The value for a submit binding must be a function");
        ko.utils.registerEventHandler(element, "submit", function (event) {
            var handlerReturnValue;
            var value = valueAccessor();
            try { handlerReturnValue = value.call(viewModel, element); }
            finally {
                if (handlerReturnValue !== true) { // Normally we want to prevent default action. Developer can override this be explicitly returning true.
                    if (event.preventDefault)
                        event.preventDefault();
                    else
                        event.returnValue = false;
                }
            }
        });
    }
};

ko.bindingHandlers['visible'] = {
    'update': function (element, valueAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor());
        var isCurrentlyVisible = !(element.style.display == "none");
        if (value && !isCurrentlyVisible)
            element.style.display = "";
        else if ((!value) && isCurrentlyVisible)
            element.style.display = "none";
    }
}

ko.bindingHandlers['enable'] = {
    'update': function (element, valueAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor());
        if (value && element.disabled)
            element.removeAttribute("disabled");
        else if ((!value) && (!element.disabled))
            element.disabled = true;
    }
};

ko.bindingHandlers['disable'] = {
    'update': function (element, valueAccessor) {
        ko.bindingHandlers['enable']['update'](element, function() { return !ko.utils.unwrapObservable(valueAccessor()) });
    }
};

function ensureDropdownSelectionIsConsistentWithModelValue(element, modelValue, preferModelValue) {
    if (preferModelValue) {
        if (modelValue !== ko.selectExtensions.readValue(element))
            ko.selectExtensions.writeValue(element, modelValue);
    }

    // No matter which direction we're syncing in, we want the end result to be equality between dropdown value and model value.
    // If they aren't equal, either we prefer the dropdown value, or the model value couldn't be represented, so either way,
    // change the model value to match the dropdown.
    if (modelValue !== ko.selectExtensions.readValue(element))
        ko.utils.triggerEvent(element, "change");
};

ko.bindingHandlers['value'] = {
    'init': function (element, valueAccessor, allBindingsAccessor) {
        // Always catch "change" event; possibly other events too if asked
        var eventsToCatch = ["change"];
        var requestedEventsToCatch = allBindingsAccessor()["valueUpdate"];
        if (requestedEventsToCatch) {
            if (typeof requestedEventsToCatch == "string") // Allow both individual event names, and arrays of event names
                requestedEventsToCatch = [requestedEventsToCatch];
            ko.utils.arrayPushAll(eventsToCatch, requestedEventsToCatch);
            eventsToCatch = ko.utils.arrayGetDistinctValues(eventsToCatch);
        }

        var valueUpdateHandler = function() {
            var modelValue = valueAccessor();
            var elementValue = ko.selectExtensions.readValue(element);
            ko.jsonExpressionRewriting.writeValueToProperty(modelValue, allBindingsAccessor, 'value', elementValue, /* checkIfDifferent: */ true);
        }

        // Workaround for https://github.com/SteveSanderson/knockout/issues/122
        // IE doesn't fire "change" events on textboxes if the user selects a value from its autocomplete list
        var ieAutoCompleteHackNeeded = ko.utils.ieVersion && element.tagName.toLowerCase() == "input" && element.type == "text"
                                       && element.autocomplete != "off" && (!element.form || element.form.autocomplete != "off");
        if (ieAutoCompleteHackNeeded && ko.utils.arrayIndexOf(eventsToCatch, "propertychange") == -1) {
            var propertyChangedFired = false;
            ko.utils.registerEventHandler(element, "propertychange", function () { propertyChangedFired = true });
            ko.utils.registerEventHandler(element, "blur", function() {
                if (propertyChangedFired) {
                    propertyChangedFired = false;
                    valueUpdateHandler();
                }
            });
        }

        ko.utils.arrayForEach(eventsToCatch, function(eventName) {
            // The syntax "after<eventname>" means "run the handler asynchronously after the event"
            // This is useful, for example, to catch "keydown" events after the browser has updated the control
            // (otherwise, ko.selectExtensions.readValue(this) will receive the control's value *before* the key event)
            var handler = valueUpdateHandler;
            if (ko.utils.stringStartsWith(eventName, "after")) {
                handler = function() { setTimeout(valueUpdateHandler, 0) };
                eventName = eventName.substring("after".length);
            }
            ko.utils.registerEventHandler(element, eventName, handler);
        });
    },
    'update': function (element, valueAccessor) {
        var valueIsSelectOption = ko.utils.tagNameLower(element) === "select";
        var newValue = ko.utils.unwrapObservable(valueAccessor());
        var elementValue = ko.selectExtensions.readValue(element);
        var valueHasChanged = (newValue != elementValue);

        // JavaScript's 0 == "" behavious is unfortunate here as it prevents writing 0 to an empty text box (loose equality suggests the values are the same).
        // We don't want to do a strict equality comparison as that is more confusing for developers in certain cases, so we specifically special case 0 != "" here.
        if ((newValue === 0) && (elementValue !== 0) && (elementValue !== "0"))
            valueHasChanged = true;

        if (valueHasChanged) {
            var applyValueAction = function () { ko.selectExtensions.writeValue(element, newValue); };
            applyValueAction();

            // Workaround for IE6 bug: It won't reliably apply values to SELECT nodes during the same execution thread
            // right after you've changed the set of OPTION nodes on it. So for that node type, we'll schedule a second thread
            // to apply the value as well.
            var alsoApplyAsynchronously = valueIsSelectOption;
            if (alsoApplyAsynchronously)
                setTimeout(applyValueAction, 0);
        }

        // If you try to set a model value that can't be represented in an already-populated dropdown, reject that change,
        // because you're not allowed to have a model value that disagrees with a visible UI selection.
        if (valueIsSelectOption && (element.length > 0))
            ensureDropdownSelectionIsConsistentWithModelValue(element, newValue, /* preferModelValue */ false);
    }
};

ko.bindingHandlers['options'] = {
    'update': function (element, valueAccessor, allBindingsAccessor) {
        if (ko.utils.tagNameLower(element) !== "select")
            throw new Error("options binding applies only to SELECT elements");

        var selectWasPreviouslyEmpty = element.length == 0;
        var previousSelectedValues = ko.utils.arrayMap(ko.utils.arrayFilter(element.childNodes, function (node) {
            return node.tagName && (ko.utils.tagNameLower(node) === "option") && node.selected;
        }), function (node) {
            return ko.selectExtensions.readValue(node) || node.innerText || node.textContent;
        });
        var previousScrollTop = element.scrollTop;

        var value = ko.utils.unwrapObservable(valueAccessor());
        var selectedValue = element.value;

        // Remove all existing <option>s.
        // Need to use .remove() rather than .removeChild() for <option>s otherwise IE behaves oddly (https://github.com/SteveSanderson/knockout/issues/134)
        while (element.length > 0) {
            ko.cleanNode(element.options[0]);
            element.remove(0);
        }

        if (value) {
            var allBindings = allBindingsAccessor();
            if (typeof value.length != "number")
                value = [value];
            if (allBindings['optionsCaption']) {
                var option = document.createElement("option");
                ko.utils.setHtml(option, allBindings['optionsCaption']);
                ko.selectExtensions.writeValue(option, undefined);
                element.appendChild(option);
            }
            for (var i = 0, j = value.length; i < j; i++) {
                var option = document.createElement("option");

                // Apply a value to the option element
                var optionValue = typeof allBindings['optionsValue'] == "string" ? value[i][allBindings['optionsValue']] : value[i];
                optionValue = ko.utils.unwrapObservable(optionValue);
                ko.selectExtensions.writeValue(option, optionValue);

                // Apply some text to the option element
                var optionsTextValue = allBindings['optionsText'];
                var optionText;
                if (typeof optionsTextValue == "function")
                    optionText = optionsTextValue(value[i]); // Given a function; run it against the data value
                else if (typeof optionsTextValue == "string")
                    optionText = value[i][optionsTextValue]; // Given a string; treat it as a property name on the data value
                else
                    optionText = optionValue;				 // Given no optionsText arg; use the data value itself
                if ((optionText === null) || (optionText === undefined))
                    optionText = "";

                ko.utils.setTextContent(option, optionText);

                element.appendChild(option);
            }

            // IE6 doesn't like us to assign selection to OPTION nodes before they're added to the document.
            // That's why we first added them without selection. Now it's time to set the selection.
            var newOptions = element.getElementsByTagName("option");
            var countSelectionsRetained = 0;
            for (var i = 0, j = newOptions.length; i < j; i++) {
                if (ko.utils.arrayIndexOf(previousSelectedValues, ko.selectExtensions.readValue(newOptions[i])) >= 0) {
                    ko.utils.setOptionNodeSelectionState(newOptions[i], true);
                    countSelectionsRetained++;
                }
            }

            element.scrollTop = previousScrollTop;

            if (selectWasPreviouslyEmpty && ('value' in allBindings)) {
                // Ensure consistency between model value and selected option.
                // If the dropdown is being populated for the first time here (or was otherwise previously empty),
                // the dropdown selection state is meaningless, so we preserve the model value.
                ensureDropdownSelectionIsConsistentWithModelValue(element, ko.utils.unwrapObservable(allBindings['value']), /* preferModelValue */ true);
            }

            // Workaround for IE9 bug
            ko.utils.ensureSelectElementIsRenderedCorrectly(element);
        }
    }
};
ko.bindingHandlers['options'].optionValueDomDataKey = '__ko.optionValueDomData__';

ko.bindingHandlers['selectedOptions'] = {
    getSelectedValuesFromSelectNode: function (selectNode) {
        var result = [];
        var nodes = selectNode.childNodes;
        for (var i = 0, j = nodes.length; i < j; i++) {
            var node = nodes[i], tagName = ko.utils.tagNameLower(node);
            if (tagName == "option" && node.selected)
                result.push(ko.selectExtensions.readValue(node));
            else if (tagName == "optgroup") {
                var selectedValuesFromOptGroup = ko.bindingHandlers['selectedOptions'].getSelectedValuesFromSelectNode(node);
                Array.prototype.splice.apply(result, [result.length, 0].concat(selectedValuesFromOptGroup)); // Add new entries to existing 'result' instance
            }
        }
        return result;
    },
    'init': function (element, valueAccessor, allBindingsAccessor) {
        ko.utils.registerEventHandler(element, "change", function () {
            var value = valueAccessor();
            var valueToWrite = ko.bindingHandlers['selectedOptions'].getSelectedValuesFromSelectNode(this);
            ko.jsonExpressionRewriting.writeValueToProperty(value, allBindingsAccessor, 'value', valueToWrite);
        });
    },
    'update': function (element, valueAccessor) {
        if (ko.utils.tagNameLower(element) != "select")
            throw new Error("values binding applies only to SELECT elements");

        var newValue = ko.utils.unwrapObservable(valueAccessor());
        if (newValue && typeof newValue.length == "number") {
            var nodes = element.childNodes;
            for (var i = 0, j = nodes.length; i < j; i++) {
                var node = nodes[i];
                if (ko.utils.tagNameLower(node) === "option")
                    ko.utils.setOptionNodeSelectionState(node, ko.utils.arrayIndexOf(newValue, ko.selectExtensions.readValue(node)) >= 0);
            }
        }
    }
};

ko.bindingHandlers['text'] = {
    'update': function (element, valueAccessor) {
        ko.utils.setTextContent(element, valueAccessor());
    }
};

ko.bindingHandlers['html'] = {
    'init': function() {
        // Prevent binding on the dynamically-injected HTML (as developers are unlikely to expect that, and it has security implications)
        return { 'controlsDescendantBindings': true };
    },
    'update': function (element, valueAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor());
        ko.utils.setHtml(element, value);
    }
};

ko.bindingHandlers['css'] = {
    'update': function (element, valueAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor() || {});
        for (var className in value) {
            if (typeof className == "string") {
                var shouldHaveClass = ko.utils.unwrapObservable(value[className]);
                ko.utils.toggleDomNodeCssClass(element, className, shouldHaveClass);
            }
        }
    }
};

ko.bindingHandlers['style'] = {
    'update': function (element, valueAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor() || {});
        for (var styleName in value) {
            if (typeof styleName == "string") {
                var styleValue = ko.utils.unwrapObservable(value[styleName]);
                element.style[styleName] = styleValue || ""; // Empty string removes the value, whereas null/undefined have no effect
            }
        }
    }
};

ko.bindingHandlers['uniqueName'] = {
    'init': function (element, valueAccessor) {
        if (valueAccessor()) {
            element.name = "ko_unique_" + (++ko.bindingHandlers['uniqueName'].currentIndex);

            // Workaround IE 6/7 issue
            // - https://github.com/SteveSanderson/knockout/issues/197
            // - http://www.matts411.com/post/setting_the_name_attribute_in_ie_dom/
            if (ko.utils.isIe6 || ko.utils.isIe7)
                element.mergeAttributes(document.createElement("<input name='" + element.name + "'/>"), false);
        }
    }
};
ko.bindingHandlers['uniqueName'].currentIndex = 0;

ko.bindingHandlers['checked'] = {
    'init': function (element, valueAccessor, allBindingsAccessor) {
        var updateHandler = function() {
            var valueToWrite;
            if (element.type == "checkbox") {
                valueToWrite = element.checked;
            } else if ((element.type == "radio") && (element.checked)) {
                valueToWrite = element.value;
            } else {
                return; // "checked" binding only responds to checkboxes and selected radio buttons
            }

            var modelValue = valueAccessor();
            if ((element.type == "checkbox") && (ko.utils.unwrapObservable(modelValue) instanceof Array)) {
                // For checkboxes bound to an array, we add/remove the checkbox value to that array
                // This works for both observable and non-observable arrays
                var existingEntryIndex = ko.utils.arrayIndexOf(ko.utils.unwrapObservable(modelValue), element.value);
                if (element.checked && (existingEntryIndex < 0))
                    modelValue.push(element.value);
                else if ((!element.checked) && (existingEntryIndex >= 0))
                    modelValue.splice(existingEntryIndex, 1);
            } else {
                ko.jsonExpressionRewriting.writeValueToProperty(modelValue, allBindingsAccessor, 'checked', valueToWrite, true);
            }
        };
        ko.utils.registerEventHandler(element, "click", updateHandler);

        // IE 6 won't allow radio buttons to be selected unless they have a name
        if ((element.type == "radio") && !element.name)
            ko.bindingHandlers['uniqueName']['init'](element, function() { return true });
    },
    'update': function (element, valueAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor());

        if (element.type == "checkbox") {
            if (value instanceof Array) {
                // When bound to an array, the checkbox being checked represents its value being present in that array
                element.checked = ko.utils.arrayIndexOf(value, element.value) >= 0;
            } else {
                // When bound to anything other value (not an array), the checkbox being checked represents the value being trueish
                element.checked = value;
            }
        } else if (element.type == "radio") {
            element.checked = (element.value == value);
        }
    }
};

var attrHtmlToJavascriptMap = { 'class': 'className', 'for': 'htmlFor' };
ko.bindingHandlers['attr'] = {
    'update': function(element, valueAccessor, allBindingsAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor()) || {};
        for (var attrName in value) {
            if (typeof attrName == "string") {
                var attrValue = ko.utils.unwrapObservable(value[attrName]);

                // To cover cases like "attr: { checked:someProp }", we want to remove the attribute entirely
                // when someProp is a "no value"-like value (strictly null, false, or undefined)
                // (because the absence of the "checked" attr is how to mark an element as not checked, etc.)
                var toRemove = (attrValue === false) || (attrValue === null) || (attrValue === undefined);
                if (toRemove)
                    element.removeAttribute(attrName);

                // In IE <= 7 and IE8 Quirks Mode, you have to use the Javascript property name instead of the
                // HTML attribute name for certain attributes. IE8 Standards Mode supports the correct behavior,
                // but instead of figuring out the mode, we'll just set the attribute through the Javascript
                // property for IE <= 8.
                if (ko.utils.ieVersion <= 8 && attrName in attrHtmlToJavascriptMap) {
                    attrName = attrHtmlToJavascriptMap[attrName];
                    if (toRemove)
                        element.removeAttribute(attrName);
                    else
                        element[attrName] = attrValue;
                } else if (!toRemove) {
                    element.setAttribute(attrName, attrValue.toString());
                }
            }
        }
    }
};

ko.bindingHandlers['hasfocus'] = {
    'init': function(element, valueAccessor, allBindingsAccessor) {
        var writeValue = function(valueToWrite) {
            var modelValue = valueAccessor();
            ko.jsonExpressionRewriting.writeValueToProperty(modelValue, allBindingsAccessor, 'hasfocus', valueToWrite, true);
        };
        ko.utils.registerEventHandler(element, "focus", function() { writeValue(true) });
        ko.utils.registerEventHandler(element, "focusin", function() { writeValue(true) }); // For IE
        ko.utils.registerEventHandler(element, "blur",  function() { writeValue(false) });
        ko.utils.registerEventHandler(element, "focusout",  function() { writeValue(false) }); // For IE
    },
    'update': function(element, valueAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor());
        value ? element.focus() : element.blur();
        ko.utils.triggerEvent(element, value ? "focusin" : "focusout"); // For IE, which doesn't reliably fire "focus" or "blur" events synchronously
    }
};

// "with: someExpression" is equivalent to "template: { if: someExpression, data: someExpression }"
ko.bindingHandlers['with'] = {
    makeTemplateValueAccessor: function(valueAccessor) {
        return function() { var value = valueAccessor(); return { 'if': value, 'data': value, 'templateEngine': ko.nativeTemplateEngine.instance } };
    },
    'init': function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
        return ko.bindingHandlers['template']['init'](element, ko.bindingHandlers['with'].makeTemplateValueAccessor(valueAccessor));
    },
    'update': function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
        return ko.bindingHandlers['template']['update'](element, ko.bindingHandlers['with'].makeTemplateValueAccessor(valueAccessor), allBindingsAccessor, viewModel, bindingContext);
    }
};
ko.jsonExpressionRewriting.bindingRewriteValidators['with'] = false; // Can't rewrite control flow bindings
ko.virtualElements.allowedBindings['with'] = true;

// "if: someExpression" is equivalent to "template: { if: someExpression }"
ko.bindingHandlers['if'] = {
    makeTemplateValueAccessor: function(valueAccessor) {
        return function() { return { 'if': valueAccessor(), 'templateEngine': ko.nativeTemplateEngine.instance } };
    },
    'init': function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
        return ko.bindingHandlers['template']['init'](element, ko.bindingHandlers['if'].makeTemplateValueAccessor(valueAccessor));
    },
    'update': function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
        return ko.bindingHandlers['template']['update'](element, ko.bindingHandlers['if'].makeTemplateValueAccessor(valueAccessor), allBindingsAccessor, viewModel, bindingContext);
    }
};
ko.jsonExpressionRewriting.bindingRewriteValidators['if'] = false; // Can't rewrite control flow bindings
ko.virtualElements.allowedBindings['if'] = true;

// "ifnot: someExpression" is equivalent to "template: { ifnot: someExpression }"
ko.bindingHandlers['ifnot'] = {
    makeTemplateValueAccessor: function(valueAccessor) {
        return function() { return { 'ifnot': valueAccessor(), 'templateEngine': ko.nativeTemplateEngine.instance } };
    },
    'init': function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
        return ko.bindingHandlers['template']['init'](element, ko.bindingHandlers['ifnot'].makeTemplateValueAccessor(valueAccessor));
    },
    'update': function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
        return ko.bindingHandlers['template']['update'](element, ko.bindingHandlers['ifnot'].makeTemplateValueAccessor(valueAccessor), allBindingsAccessor, viewModel, bindingContext);
    }
};
ko.jsonExpressionRewriting.bindingRewriteValidators['ifnot'] = false; // Can't rewrite control flow bindings
ko.virtualElements.allowedBindings['ifnot'] = true;

// "foreach: someExpression" is equivalent to "template: { foreach: someExpression }"
// "foreach: { data: someExpression, afterAdd: myfn }" is equivalent to "template: { foreach: someExpression, afterAdd: myfn }"
ko.bindingHandlers['foreach'] = {
    makeTemplateValueAccessor: function(valueAccessor) {
        return function() {
            var bindingValue = ko.utils.unwrapObservable(valueAccessor());

            // If bindingValue is the array, just pass it on its own
            if ((!bindingValue) || typeof bindingValue.length == "number")
                return { 'foreach': bindingValue, 'templateEngine': ko.nativeTemplateEngine.instance };

            // If bindingValue.data is the array, preserve all relevant options
            return {
                'foreach': bindingValue['data'],
                'includeDestroyed': bindingValue['includeDestroyed'],
                'afterAdd': bindingValue['afterAdd'],
                'beforeRemove': bindingValue['beforeRemove'],
                'afterRender': bindingValue['afterRender'],
                'templateEngine': ko.nativeTemplateEngine.instance
            };
        };
    },
    'init': function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
        return ko.bindingHandlers['template']['init'](element, ko.bindingHandlers['foreach'].makeTemplateValueAccessor(valueAccessor));
    },
    'update': function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
        return ko.bindingHandlers['template']['update'](element, ko.bindingHandlers['foreach'].makeTemplateValueAccessor(valueAccessor), allBindingsAccessor, viewModel, bindingContext);
    }
};
ko.jsonExpressionRewriting.bindingRewriteValidators['foreach'] = false; // Can't rewrite control flow bindings
ko.virtualElements.allowedBindings['foreach'] = true;
// If you want to make a custom template engine,
//
// [1] Inherit from this class (like ko.nativeTemplateEngine does)
// [2] Override 'renderTemplateSource', supplying a function with this signature:
//
//        function (templateSource, bindingContext, options) {
//            // - templateSource.text() is the text of the template you should render
//            // - bindingContext.$data is the data you should pass into the template
//            //   - you might also want to make bindingContext.$parent, bindingContext.$parents,
//            //     and bindingContext.$root available in the template too
//            // - options gives you access to any other properties set on "data-bind: { template: options }"
//            //
//            // Return value: an array of DOM nodes
//        }
//
// [3] Override 'createJavaScriptEvaluatorBlock', supplying a function with this signature:
//
//        function (script) {
//            // Return value: Whatever syntax means "Evaluate the JavaScript statement 'script' and output the result"
//            //               For example, the jquery.tmpl template engine converts 'someScript' to '${ someScript }'
//        }
//
//     This is only necessary if you want to allow data-bind attributes to reference arbitrary template variables.
//     If you don't want to allow that, you can set the property 'allowTemplateRewriting' to false (like ko.nativeTemplateEngine does)
//     and then you don't need to override 'createJavaScriptEvaluatorBlock'.

ko.templateEngine = function () { };

ko.templateEngine.prototype['renderTemplateSource'] = function (templateSource, bindingContext, options) {
    throw new Error("Override renderTemplateSource");
};

ko.templateEngine.prototype['createJavaScriptEvaluatorBlock'] = function (script) {
    throw new Error("Override createJavaScriptEvaluatorBlock");
};

ko.templateEngine.prototype['makeTemplateSource'] = function(template, templateDocument) {
    // Named template
    if (typeof template == "string") {
        templateDocument = templateDocument || document;
        var elem = templateDocument.getElementById(template);
        if (!elem)
            throw new Error("Cannot find template with ID " + template);
        return new ko.templateSources.domElement(elem);
    } else if ((template.nodeType == 1) || (template.nodeType == 8)) {
        // Anonymous template
        return new ko.templateSources.anonymousTemplate(template);
    } else
        throw new Error("Unknown template type: " + template);
};

ko.templateEngine.prototype['renderTemplate'] = function (template, bindingContext, options, templateDocument) {
    var templateSource = this['makeTemplateSource'](template, templateDocument);
    return this['renderTemplateSource'](templateSource, bindingContext, options);
};

ko.templateEngine.prototype['isTemplateRewritten'] = function (template, templateDocument) {
    // Skip rewriting if requested
    if (this['allowTemplateRewriting'] === false)
        return true;

    // Perf optimisation - see below
    var templateIsInExternalDocument = templateDocument && templateDocument != document;
    if (!templateIsInExternalDocument && this.knownRewrittenTemplates && this.knownRewrittenTemplates[template])
        return true;

    return this['makeTemplateSource'](template, templateDocument)['data']("isRewritten");
};

ko.templateEngine.prototype['rewriteTemplate'] = function (template, rewriterCallback, templateDocument) {
    var templateSource = this['makeTemplateSource'](template, templateDocument);
    var rewritten = rewriterCallback(templateSource['text']());
    templateSource['text'](rewritten);
    templateSource['data']("isRewritten", true);

    // Perf optimisation - for named templates, track which ones have been rewritten so we can
    // answer 'isTemplateRewritten' *without* having to use getElementById (which is slow on IE < 8)
    //
    // Note that we only cache the status for templates in the main document, because caching on a per-doc
    // basis complicates the implementation excessively. In a future version of KO, we will likely remove
    // this 'isRewritten' cache entirely anyway, because the benefit is extremely minor and only applies
    // to rewritable templates, which are pretty much deprecated since KO 2.0.
    var templateIsInExternalDocument = templateDocument && templateDocument != document;
    if (!templateIsInExternalDocument && typeof template == "string") {
        this.knownRewrittenTemplates = this.knownRewrittenTemplates || {};
        this.knownRewrittenTemplates[template] = true;
    }
};

ko.exportSymbol('templateEngine', ko.templateEngine);

ko.templateRewriting = (function () {
    var memoizeDataBindingAttributeSyntaxRegex = /(<[a-z]+\d*(\s+(?!data-bind=)[a-z0-9\-]+(=(\"[^\"]*\"|\'[^\']*\'))?)*\s+)data-bind=(["'])([\s\S]*?)\5/gi;
    var memoizeVirtualContainerBindingSyntaxRegex = /<!--\s*ko\b\s*([\s\S]*?)\s*-->/g;

    function validateDataBindValuesForRewriting(keyValueArray) {
        var allValidators = ko.jsonExpressionRewriting.bindingRewriteValidators;
        for (var i = 0; i < keyValueArray.length; i++) {
            var key = keyValueArray[i]['key'];
            if (allValidators.hasOwnProperty(key)) {
                var validator = allValidators[key];

                if (typeof validator === "function") {
                    var possibleErrorMessage = validator(keyValueArray[i]['value']);
                    if (possibleErrorMessage)
                        throw new Error(possibleErrorMessage);
                } else if (!validator) {
                    throw new Error("This template engine does not support the '" + key + "' binding within its templates");
                }
            }
        }
    }

    function constructMemoizedTagReplacement(dataBindAttributeValue, tagToRetain, templateEngine) {
        var dataBindKeyValueArray = ko.jsonExpressionRewriting.parseObjectLiteral(dataBindAttributeValue);
        validateDataBindValuesForRewriting(dataBindKeyValueArray);
        var rewrittenDataBindAttributeValue = ko.jsonExpressionRewriting.insertPropertyAccessorsIntoJson(dataBindKeyValueArray);

        // For no obvious reason, Opera fails to evaluate rewrittenDataBindAttributeValue unless it's wrapped in an additional
        // anonymous function, even though Opera's built-in debugger can evaluate it anyway. No other browser requires this
        // extra indirection.
        var applyBindingsToNextSiblingScript = "ko.templateRewriting.applyMemoizedBindingsToNextSibling(function() { \
            return (function() { return { " + rewrittenDataBindAttributeValue + " } })() \
        })";
        return templateEngine['createJavaScriptEvaluatorBlock'](applyBindingsToNextSiblingScript) + tagToRetain;
    }

    return {
        ensureTemplateIsRewritten: function (template, templateEngine, templateDocument) {
            if (!templateEngine['isTemplateRewritten'](template, templateDocument))
                templateEngine['rewriteTemplate'](template, function (htmlString) {
                    return ko.templateRewriting.memoizeBindingAttributeSyntax(htmlString, templateEngine);
                }, templateDocument);
        },

        memoizeBindingAttributeSyntax: function (htmlString, templateEngine) {
            return htmlString.replace(memoizeDataBindingAttributeSyntaxRegex, function () {
                return constructMemoizedTagReplacement(/* dataBindAttributeValue: */ arguments[6], /* tagToRetain: */ arguments[1], templateEngine);
            }).replace(memoizeVirtualContainerBindingSyntaxRegex, function() {
                return constructMemoizedTagReplacement(/* dataBindAttributeValue: */ arguments[1], /* tagToRetain: */ "<!-- ko -->", templateEngine);
            });
        },

        applyMemoizedBindingsToNextSibling: function (bindings) {
            return ko.memoization.memoize(function (domNode, bindingContext) {
                if (domNode.nextSibling)
                    ko.applyBindingsToNode(domNode.nextSibling, bindings, bindingContext);
            });
        }
    }
})();

ko.exportSymbol('templateRewriting', ko.templateRewriting);
ko.exportSymbol('templateRewriting.applyMemoizedBindingsToNextSibling', ko.templateRewriting.applyMemoizedBindingsToNextSibling); // Exported only because it has to be referenced by string lookup from within rewritten template
(function() {
    // A template source represents a read/write way of accessing a template. This is to eliminate the need for template loading/saving
    // logic to be duplicated in every template engine (and means they can all work with anonymous templates, etc.)
    //
    // Two are provided by default:
    //  1. ko.templateSources.domElement       - reads/writes the text content of an arbitrary DOM element
    //  2. ko.templateSources.anonymousElement - uses ko.utils.domData to read/write text *associated* with the DOM element, but
    //                                           without reading/writing the actual element text content, since it will be overwritten
    //                                           with the rendered template output.
    // You can implement your own template source if you want to fetch/store templates somewhere other than in DOM elements.
    // Template sources need to have the following functions:
    //   text() 			- returns the template text from your storage location
    //   text(value)		- writes the supplied template text to your storage location
    //   data(key)			- reads values stored using data(key, value) - see below
    //   data(key, value)	- associates "value" with this template and the key "key". Is used to store information like "isRewritten".
    //
    // Optionally, template sources can also have the following functions:
    //   nodes()            - returns a DOM element containing the nodes of this template, where available
    //   nodes(value)       - writes the given DOM element to your storage location
    // If a DOM element is available for a given template source, template engines are encouraged to use it in preference over text()
    // for improved speed. However, all templateSources must supply text() even if they don't supply nodes().
    //
    // Once you've implemented a templateSource, make your template engine use it by subclassing whatever template engine you were
    // using and overriding "makeTemplateSource" to return an instance of your custom template source.

    ko.templateSources = {};

    // ---- ko.templateSources.domElement -----

    ko.templateSources.domElement = function(element) {
        this.domElement = element;
    }

    ko.templateSources.domElement.prototype['text'] = function(/* valueToWrite */) {
        var tagNameLower = ko.utils.tagNameLower(this.domElement),
            elemContentsProperty = tagNameLower === "script" ? "text"
                                 : tagNameLower === "textarea" ? "value"
                                 : "innerHTML";

        if (arguments.length == 0) {
            return this.domElement[elemContentsProperty];
        } else {
            var valueToWrite = arguments[0];
            if (elemContentsProperty === "innerHTML")
                ko.utils.setHtml(this.domElement, valueToWrite);
            else
                this.domElement[elemContentsProperty] = valueToWrite;
        }
    };

    ko.templateSources.domElement.prototype['data'] = function(key /*, valueToWrite */) {
        if (arguments.length === 1) {
            return ko.utils.domData.get(this.domElement, "templateSourceData_" + key);
        } else {
            ko.utils.domData.set(this.domElement, "templateSourceData_" + key, arguments[1]);
        }
    };

    // ---- ko.templateSources.anonymousTemplate -----
    // Anonymous templates are normally saved/retrieved as DOM nodes through "nodes".
    // For compatibility, you can also read "text"; it will be serialized from the nodes on demand.
    // Writing to "text" is still supported, but then the template data will not be available as DOM nodes.

    var anonymousTemplatesDomDataKey = "__ko_anon_template__";
    ko.templateSources.anonymousTemplate = function(element) {
        this.domElement = element;
    }
    ko.templateSources.anonymousTemplate.prototype = new ko.templateSources.domElement();
    ko.templateSources.anonymousTemplate.prototype['text'] = function(/* valueToWrite */) {
        if (arguments.length == 0) {
            var templateData = ko.utils.domData.get(this.domElement, anonymousTemplatesDomDataKey) || {};
            if (templateData.textData === undefined && templateData.containerData)
                templateData.textData = templateData.containerData.innerHTML;
            return templateData.textData;
        } else {
            var valueToWrite = arguments[0];
            ko.utils.domData.set(this.domElement, anonymousTemplatesDomDataKey, {textData: valueToWrite});
        }
    };
    ko.templateSources.domElement.prototype['nodes'] = function(/* valueToWrite */) {
        if (arguments.length == 0) {
            var templateData = ko.utils.domData.get(this.domElement, anonymousTemplatesDomDataKey) || {};
            return templateData.containerData;
        } else {
            var valueToWrite = arguments[0];
            ko.utils.domData.set(this.domElement, anonymousTemplatesDomDataKey, {containerData: valueToWrite});
        }
    };

    ko.exportSymbol('templateSources', ko.templateSources);
    ko.exportSymbol('templateSources.domElement', ko.templateSources.domElement);
    ko.exportSymbol('templateSources.anonymousTemplate', ko.templateSources.anonymousTemplate);
})();
(function () {
    var _templateEngine;
    ko.setTemplateEngine = function (templateEngine) {
        if ((templateEngine != undefined) && !(templateEngine instanceof ko.templateEngine))
            throw new Error("templateEngine must inherit from ko.templateEngine");
        _templateEngine = templateEngine;
    }

    function invokeForEachNodeOrCommentInContinuousRange(firstNode, lastNode, action) {
        var node, nextInQueue = firstNode, firstOutOfRangeNode = ko.virtualElements.nextSibling(lastNode);
        while (nextInQueue && ((node = nextInQueue) !== firstOutOfRangeNode)) {
            nextInQueue = ko.virtualElements.nextSibling(node);
            if (node.nodeType === 1 || node.nodeType === 8)
                action(node);
        }
    }

    function activateBindingsOnContinuousNodeArray(continuousNodeArray, bindingContext) {
        // To be used on any nodes that have been rendered by a template and have been inserted into some parent element
        // Walks through continuousNodeArray (which *must* be continuous, i.e., an uninterrupted sequence of sibling nodes, because
        // the algorithm for walking them relies on this), and for each top-level item in the virtual-element sense,
        // (1) Does a regular "applyBindings" to associate bindingContext with this node and to activate any non-memoized bindings
        // (2) Unmemoizes any memos in the DOM subtree (e.g., to activate bindings that had been memoized during template rewriting)

        if (continuousNodeArray.length) {
            var firstNode = continuousNodeArray[0], lastNode = continuousNodeArray[continuousNodeArray.length - 1];

            // Need to applyBindings *before* unmemoziation, because unmemoization might introduce extra nodes (that we don't want to re-bind)
            // whereas a regular applyBindings won't introduce new memoized nodes
            invokeForEachNodeOrCommentInContinuousRange(firstNode, lastNode, function(node) {
                ko.applyBindings(bindingContext, node);
            });
            invokeForEachNodeOrCommentInContinuousRange(firstNode, lastNode, function(node) {
                ko.memoization.unmemoizeDomNodeAndDescendants(node, [bindingContext]);
            });
        }
    }

    function getFirstNodeFromPossibleArray(nodeOrNodeArray) {
        return nodeOrNodeArray.nodeType ? nodeOrNodeArray
                                        : nodeOrNodeArray.length > 0 ? nodeOrNodeArray[0]
                                        : null;
    }

    function executeTemplate(targetNodeOrNodeArray, renderMode, template, bindingContext, options) {
        options = options || {};
        var firstTargetNode = targetNodeOrNodeArray && getFirstNodeFromPossibleArray(targetNodeOrNodeArray);
        var templateDocument = firstTargetNode && firstTargetNode.ownerDocument;
        var templateEngineToUse = (options['templateEngine'] || _templateEngine);
        ko.templateRewriting.ensureTemplateIsRewritten(template, templateEngineToUse, templateDocument);
        var renderedNodesArray = templateEngineToUse['renderTemplate'](template, bindingContext, options, templateDocument);

        // Loosely check result is an array of DOM nodes
        if ((typeof renderedNodesArray.length != "number") || (renderedNodesArray.length > 0 && typeof renderedNodesArray[0].nodeType != "number"))
            throw new Error("Template engine must return an array of DOM nodes");

        var haveAddedNodesToParent = false;
        switch (renderMode) {
            case "replaceChildren":
                ko.virtualElements.setDomNodeChildren(targetNodeOrNodeArray, renderedNodesArray);
                haveAddedNodesToParent = true;
                break;
            case "replaceNode":
                ko.utils.replaceDomNodes(targetNodeOrNodeArray, renderedNodesArray);
                haveAddedNodesToParent = true;
                break;
            case "ignoreTargetNode": break;
            default:
                throw new Error("Unknown renderMode: " + renderMode);
        }

        if (haveAddedNodesToParent) {
            activateBindingsOnContinuousNodeArray(renderedNodesArray, bindingContext);
            if (options['afterRender'])
                options['afterRender'](renderedNodesArray, bindingContext['$data']);
        }

        return renderedNodesArray;
    }

    ko.renderTemplate = function (template, dataOrBindingContext, options, targetNodeOrNodeArray, renderMode) {
        options = options || {};
        if ((options['templateEngine'] || _templateEngine) == undefined)
            throw new Error("Set a template engine before calling renderTemplate");
        renderMode = renderMode || "replaceChildren";

        if (targetNodeOrNodeArray) {
            var firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);

            var whenToDispose = function () { return (!firstTargetNode) || !ko.utils.domNodeIsAttachedToDocument(firstTargetNode); }; // Passive disposal (on next evaluation)
            var activelyDisposeWhenNodeIsRemoved = (firstTargetNode && renderMode == "replaceNode") ? firstTargetNode.parentNode : firstTargetNode;

            return ko.dependentObservable( // So the DOM is automatically updated when any dependency changes
                function () {
                    // Ensure we've got a proper binding context to work with
                    var bindingContext = (dataOrBindingContext && (dataOrBindingContext instanceof ko.bindingContext))
                        ? dataOrBindingContext
                        : new ko.bindingContext(ko.utils.unwrapObservable(dataOrBindingContext));

                    // Support selecting template as a function of the data being rendered
                    var templateName = typeof(template) == 'function' ? template(bindingContext['$data']) : template;

                    var renderedNodesArray = executeTemplate(targetNodeOrNodeArray, renderMode, templateName, bindingContext, options);
                    if (renderMode == "replaceNode") {
                        targetNodeOrNodeArray = renderedNodesArray;
                        firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);
                    }
                },
                null,
                { 'disposeWhen': whenToDispose, 'disposeWhenNodeIsRemoved': activelyDisposeWhenNodeIsRemoved }
            );
        } else {
            // We don't yet have a DOM node to evaluate, so use a memo and render the template later when there is a DOM node
            return ko.memoization.memoize(function (domNode) {
                ko.renderTemplate(template, dataOrBindingContext, options, domNode, "replaceNode");
            });
        }
    };

    ko.renderTemplateForEach = function (template, arrayOrObservableArray, options, targetNode, parentBindingContext) {
        // Since setDomNodeChildrenFromArrayMapping always calls executeTemplateForArrayItem and then
        // activateBindingsCallback for added items, we can store the binding context in the former to use in the latter.
        var arrayItemContext;

        // This will be called by setDomNodeChildrenFromArrayMapping to get the nodes to add to targetNode
        var executeTemplateForArrayItem = function (arrayValue, index) {
            // Support selecting template as a function of the data being rendered
            var templateName = typeof(template) == 'function' ? template(arrayValue) : template;
            arrayItemContext = parentBindingContext['createChildContext'](ko.utils.unwrapObservable(arrayValue));
            arrayItemContext['$index'] = index;
            return executeTemplate(null, "ignoreTargetNode", templateName, arrayItemContext, options);
        }

        // This will be called whenever setDomNodeChildrenFromArrayMapping has added nodes to targetNode
        var activateBindingsCallback = function(arrayValue, addedNodesArray, index) {
            activateBindingsOnContinuousNodeArray(addedNodesArray, arrayItemContext);
            if (options['afterRender'])
                options['afterRender'](addedNodesArray, arrayValue);
        };

        return ko.dependentObservable(function () {
            var unwrappedArray = ko.utils.unwrapObservable(arrayOrObservableArray) || [];
            if (typeof unwrappedArray.length == "undefined") // Coerce single value into array
                unwrappedArray = [unwrappedArray];

            // Filter out any entries marked as destroyed
            var filteredArray = ko.utils.arrayFilter(unwrappedArray, function(item) {
                return options['includeDestroyed'] || item === undefined || item === null || !ko.utils.unwrapObservable(item['_destroy']);
            });

            ko.utils.setDomNodeChildrenFromArrayMapping(targetNode, filteredArray, executeTemplateForArrayItem, options, activateBindingsCallback);

        }, null, { 'disposeWhenNodeIsRemoved': targetNode });
    };

    var templateSubscriptionDomDataKey = '__ko__templateSubscriptionDomDataKey__';
    function disposeOldSubscriptionAndStoreNewOne(element, newSubscription) {
        var oldSubscription = ko.utils.domData.get(element, templateSubscriptionDomDataKey);
        if (oldSubscription && (typeof(oldSubscription.dispose) == 'function'))
            oldSubscription.dispose();
        ko.utils.domData.set(element, templateSubscriptionDomDataKey, newSubscription);
    }

    ko.bindingHandlers['template'] = {
        'init': function(element, valueAccessor) {
            // Support anonymous templates
            var bindingValue = ko.utils.unwrapObservable(valueAccessor());
            if ((typeof bindingValue != "string") && (!bindingValue['name']) && (element.nodeType == 1 || element.nodeType == 8)) {
                // It's an anonymous template - store the element contents, then clear the element
                var templateNodes = element.nodeType == 1 ? element.childNodes : ko.virtualElements.childNodes(element),
                    container = ko.utils.moveCleanedNodesToContainerElement(templateNodes); // This also removes the nodes from their current parent
                new ko.templateSources.anonymousTemplate(element)['nodes'](container);
            }
            return { 'controlsDescendantBindings': true };
        },
        'update': function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
            var bindingValue = ko.utils.unwrapObservable(valueAccessor());
            var templateName;
            var shouldDisplay = true;

            if (typeof bindingValue == "string") {
                templateName = bindingValue;
            } else {
                templateName = bindingValue['name'];

                // Support "if"/"ifnot" conditions
                if ('if' in bindingValue)
                    shouldDisplay = shouldDisplay && ko.utils.unwrapObservable(bindingValue['if']);
                if ('ifnot' in bindingValue)
                    shouldDisplay = shouldDisplay && !ko.utils.unwrapObservable(bindingValue['ifnot']);
            }

            var templateSubscription = null;

            if ((typeof bindingValue === 'object') && ('foreach' in bindingValue)) { // Note: can't use 'in' operator on strings
                // Render once for each data point (treating data set as empty if shouldDisplay==false)
                var dataArray = (shouldDisplay && bindingValue['foreach']) || [];
                templateSubscription = ko.renderTemplateForEach(templateName || element, dataArray, /* options: */ bindingValue, element, bindingContext);
            } else {
                if (shouldDisplay) {
                    // Render once for this single data point (or use the viewModel if no data was provided)
                    var innerBindingContext = (typeof bindingValue == 'object') && ('data' in bindingValue)
                        ? bindingContext['createChildContext'](ko.utils.unwrapObservable(bindingValue['data'])) // Given an explitit 'data' value, we create a child binding context for it
                        : bindingContext;                                                                       // Given no explicit 'data' value, we retain the same binding context
                    templateSubscription = ko.renderTemplate(templateName || element, innerBindingContext, /* options: */ bindingValue, element);
                } else
                    ko.virtualElements.emptyNode(element);
            }

            // It only makes sense to have a single template subscription per element (otherwise which one should have its output displayed?)
            disposeOldSubscriptionAndStoreNewOne(element, templateSubscription);
        }
    };

    // Anonymous templates can't be rewritten. Give a nice error message if you try to do it.
    ko.jsonExpressionRewriting.bindingRewriteValidators['template'] = function(bindingValue) {
        var parsedBindingValue = ko.jsonExpressionRewriting.parseObjectLiteral(bindingValue);

        if ((parsedBindingValue.length == 1) && parsedBindingValue[0]['unknown'])
            return null; // It looks like a string literal, not an object literal, so treat it as a named template (which is allowed for rewriting)

        if (ko.jsonExpressionRewriting.keyValueArrayContainsKey(parsedBindingValue, "name"))
            return null; // Named templates can be rewritten, so return "no error"
        return "This template engine does not support anonymous templates nested within its templates";
    };

    ko.virtualElements.allowedBindings['template'] = true;
})();

ko.exportSymbol('setTemplateEngine', ko.setTemplateEngine);
ko.exportSymbol('renderTemplate', ko.renderTemplate);

(function () {
    // Simple calculation based on Levenshtein distance.
    function calculateEditDistanceMatrix(oldArray, newArray, maxAllowedDistance) {
        var distances = [];
        for (var i = 0; i <= newArray.length; i++)
            distances[i] = [];

        // Top row - transform old array into empty array via deletions
        for (var i = 0, j = Math.min(oldArray.length, maxAllowedDistance); i <= j; i++)
            distances[0][i] = i;

        // Left row - transform empty array into new array via additions
        for (var i = 1, j = Math.min(newArray.length, maxAllowedDistance); i <= j; i++) {
            distances[i][0] = i;
        }

        // Fill out the body of the array
        var oldIndex, oldIndexMax = oldArray.length, newIndex, newIndexMax = newArray.length;
        var distanceViaAddition, distanceViaDeletion;
        for (oldIndex = 1; oldIndex <= oldIndexMax; oldIndex++) {
            var newIndexMinForRow = Math.max(1, oldIndex - maxAllowedDistance);
            var newIndexMaxForRow = Math.min(newIndexMax, oldIndex + maxAllowedDistance);
            for (newIndex = newIndexMinForRow; newIndex <= newIndexMaxForRow; newIndex++) {
                if (oldArray[oldIndex - 1] === newArray[newIndex - 1])
                    distances[newIndex][oldIndex] = distances[newIndex - 1][oldIndex - 1];
                else {
                    var northDistance = distances[newIndex - 1][oldIndex] === undefined ? Number.MAX_VALUE : distances[newIndex - 1][oldIndex] + 1;
                    var westDistance = distances[newIndex][oldIndex - 1] === undefined ? Number.MAX_VALUE : distances[newIndex][oldIndex - 1] + 1;
                    distances[newIndex][oldIndex] = Math.min(northDistance, westDistance);
                }
            }
        }

        return distances;
    }

    function findEditScriptFromEditDistanceMatrix(editDistanceMatrix, oldArray, newArray) {
        var oldIndex = oldArray.length;
        var newIndex = newArray.length;
        var editScript = [];
        var maxDistance = editDistanceMatrix[newIndex][oldIndex];
        if (maxDistance === undefined)
            return null; // maxAllowedDistance must be too small
        while ((oldIndex > 0) || (newIndex > 0)) {
            var me = editDistanceMatrix[newIndex][oldIndex];
            var distanceViaAdd = (newIndex > 0) ? editDistanceMatrix[newIndex - 1][oldIndex] : maxDistance + 1;
            var distanceViaDelete = (oldIndex > 0) ? editDistanceMatrix[newIndex][oldIndex - 1] : maxDistance + 1;
            var distanceViaRetain = (newIndex > 0) && (oldIndex > 0) ? editDistanceMatrix[newIndex - 1][oldIndex - 1] : maxDistance + 1;
            if ((distanceViaAdd === undefined) || (distanceViaAdd < me - 1)) distanceViaAdd = maxDistance + 1;
            if ((distanceViaDelete === undefined) || (distanceViaDelete < me - 1)) distanceViaDelete = maxDistance + 1;
            if (distanceViaRetain < me - 1) distanceViaRetain = maxDistance + 1;

            if ((distanceViaAdd <= distanceViaDelete) && (distanceViaAdd < distanceViaRetain)) {
                editScript.push({ status: "added", value: newArray[newIndex - 1] });
                newIndex--;
            } else if ((distanceViaDelete < distanceViaAdd) && (distanceViaDelete < distanceViaRetain)) {
                editScript.push({ status: "deleted", value: oldArray[oldIndex - 1] });
                oldIndex--;
            } else {
                editScript.push({ status: "retained", value: oldArray[oldIndex - 1] });
                newIndex--;
                oldIndex--;
            }
        }
        return editScript.reverse();
    }

    ko.utils.compareArrays = function (oldArray, newArray, maxEditsToConsider) {
        if (maxEditsToConsider === undefined) {
            return ko.utils.compareArrays(oldArray, newArray, 1)                 // First consider likely case where there is at most one edit (very fast)
                || ko.utils.compareArrays(oldArray, newArray, 10)                // If that fails, account for a fair number of changes while still being fast
                || ko.utils.compareArrays(oldArray, newArray, Number.MAX_VALUE); // Ultimately give the right answer, even though it may take a long time
        } else {
            oldArray = oldArray || [];
            newArray = newArray || [];
            var editDistanceMatrix = calculateEditDistanceMatrix(oldArray, newArray, maxEditsToConsider);
            return findEditScriptFromEditDistanceMatrix(editDistanceMatrix, oldArray, newArray);
        }
    };
})();

ko.exportSymbol('utils.compareArrays', ko.utils.compareArrays);

(function () {
    // Objective:
    // * Given an input array, a container DOM node, and a function from array elements to arrays of DOM nodes,
    //   map the array elements to arrays of DOM nodes, concatenate together all these arrays, and use them to populate the container DOM node
    // * Next time we're given the same combination of things (with the array possibly having mutated), update the container DOM node
    //   so that its children is again the concatenation of the mappings of the array elements, but don't re-map any array elements that we
    //   previously mapped - retain those nodes, and just insert/delete other ones

    // "callbackAfterAddingNodes" will be invoked after any "mapping"-generated nodes are inserted into the container node
    // You can use this, for example, to activate bindings on those nodes.

    function fixUpVirtualElements(contiguousNodeArray) {
        // Ensures that contiguousNodeArray really *is* an array of contiguous siblings, even if some of the interior
        // ones have changed since your array was first built (e.g., because your array contains virtual elements, and
        // their virtual children changed when binding was applied to them).
        // This is needed so that we can reliably remove or update the nodes corresponding to a given array item

        if (contiguousNodeArray.length > 2) {
            // Build up the actual new contiguous node set
            var current = contiguousNodeArray[0], last = contiguousNodeArray[contiguousNodeArray.length - 1], newContiguousSet = [current];
            while (current !== last) {
                current = current.nextSibling;
                if (!current) // Won't happen, except if the developer has manually removed some DOM elements (then we're in an undefined scenario)
                    return;
                newContiguousSet.push(current);
            }

            // ... then mutate the input array to match this.
            // (The following line replaces the contents of contiguousNodeArray with newContiguousSet)
            Array.prototype.splice.apply(contiguousNodeArray, [0, contiguousNodeArray.length].concat(newContiguousSet));
        }
    }

    function mapNodeAndRefreshWhenChanged(containerNode, mapping, valueToMap, callbackAfterAddingNodes, index) {
        // Map this array value inside a dependentObservable so we re-map when any dependency changes
        var mappedNodes = [];
        var dependentObservable = ko.dependentObservable(function() {
            var newMappedNodes = mapping(valueToMap, index) || [];

            // On subsequent evaluations, just replace the previously-inserted DOM nodes
            if (mappedNodes.length > 0) {
                fixUpVirtualElements(mappedNodes);
                ko.utils.replaceDomNodes(mappedNodes, newMappedNodes);
                if (callbackAfterAddingNodes)
                    callbackAfterAddingNodes(valueToMap, newMappedNodes);
            }

            // Replace the contents of the mappedNodes array, thereby updating the record
            // of which nodes would be deleted if valueToMap was itself later removed
            mappedNodes.splice(0, mappedNodes.length);
            ko.utils.arrayPushAll(mappedNodes, newMappedNodes);
        }, null, { 'disposeWhenNodeIsRemoved': containerNode, 'disposeWhen': function() { return (mappedNodes.length == 0) || !ko.utils.domNodeIsAttachedToDocument(mappedNodes[0]) } });
        return { mappedNodes : mappedNodes, dependentObservable : dependentObservable };
    }

    var lastMappingResultDomDataKey = "setDomNodeChildrenFromArrayMapping_lastMappingResult";

    ko.utils.setDomNodeChildrenFromArrayMapping = function (domNode, array, mapping, options, callbackAfterAddingNodes) {
        // Compare the provided array against the previous one
        array = array || [];
        options = options || {};
        var isFirstExecution = ko.utils.domData.get(domNode, lastMappingResultDomDataKey) === undefined;
        var lastMappingResult = ko.utils.domData.get(domNode, lastMappingResultDomDataKey) || [];
        var lastArray = ko.utils.arrayMap(lastMappingResult, function (x) { return x.arrayEntry; });
        var editScript = ko.utils.compareArrays(lastArray, array);

        // Build the new mapping result
        var newMappingResult = [];
        var lastMappingResultIndex = 0;
        var nodesToDelete = [];
        var newMappingResultIndex = 0;
        var nodesAdded = [];
        var insertAfterNode = null;
        for (var i = 0, j = editScript.length; i < j; i++) {
            switch (editScript[i].status) {
                case "retained":
                    // Just keep the information - don't touch the nodes
                    var dataToRetain = lastMappingResult[lastMappingResultIndex];
                    dataToRetain.indexObservable(newMappingResultIndex);
                    newMappingResultIndex = newMappingResult.push(dataToRetain);
                    if (dataToRetain.domNodes.length > 0)
                        insertAfterNode = dataToRetain.domNodes[dataToRetain.domNodes.length - 1];
                    lastMappingResultIndex++;
                    break;

                case "deleted":
                    // Stop tracking changes to the mapping for these nodes
                    lastMappingResult[lastMappingResultIndex].dependentObservable.dispose();

                    // Queue these nodes for later removal
                    fixUpVirtualElements(lastMappingResult[lastMappingResultIndex].domNodes);
                    ko.utils.arrayForEach(lastMappingResult[lastMappingResultIndex].domNodes, function (node) {
                        nodesToDelete.push({
                          element: node,
                          index: i,
                          value: editScript[i].value
                        });
                        insertAfterNode = node;
                    });
                    lastMappingResultIndex++;
                    break;

                case "added":
                    var valueToMap = editScript[i].value;
                    var indexObservable = ko.observable(newMappingResultIndex);
                    var mapData = mapNodeAndRefreshWhenChanged(domNode, mapping, valueToMap, callbackAfterAddingNodes, indexObservable);
                    var mappedNodes = mapData.mappedNodes;

                    // On the first evaluation, insert the nodes at the current insertion point
                    newMappingResultIndex = newMappingResult.push({
                        arrayEntry: editScript[i].value,
                        domNodes: mappedNodes,
                        dependentObservable: mapData.dependentObservable,
                        indexObservable: indexObservable
                    });
                    for (var nodeIndex = 0, nodeIndexMax = mappedNodes.length; nodeIndex < nodeIndexMax; nodeIndex++) {
                        var node = mappedNodes[nodeIndex];
                        nodesAdded.push({
                          element: node,
                          index: i,
                          value: editScript[i].value
                        });
                        if (insertAfterNode == null) {
                            // Insert "node" (the newly-created node) as domNode's first child
                            ko.virtualElements.prepend(domNode, node);
                        } else {
                            // Insert "node" into "domNode" immediately after "insertAfterNode"
                            ko.virtualElements.insertAfter(domNode, node, insertAfterNode);
                        }
                        insertAfterNode = node;
                    }
                    if (callbackAfterAddingNodes)
                        callbackAfterAddingNodes(valueToMap, mappedNodes, indexObservable);
                    break;
            }
        }

        ko.utils.arrayForEach(nodesToDelete, function (node) { ko.cleanNode(node.element) });

        var invokedBeforeRemoveCallback = false;
        if (!isFirstExecution) {
            if (options['afterAdd']) {
                for (var i = 0; i < nodesAdded.length; i++)
                    options['afterAdd'](nodesAdded[i].element, nodesAdded[i].index, nodesAdded[i].value);
            }
            if (options['beforeRemove']) {
                for (var i = 0; i < nodesToDelete.length; i++)
                    options['beforeRemove'](nodesToDelete[i].element, nodesToDelete[i].index, nodesToDelete[i].value);
                invokedBeforeRemoveCallback = true;
            }
        }
        if (!invokedBeforeRemoveCallback && nodesToDelete.length) {
            for (var i = 0; i < nodesToDelete.length; i++) {
                var element = nodesToDelete[i].element;
                if (element.parentNode)
                    element.parentNode.removeChild(element);
            }
        }

        // Store a copy of the array items we just considered so we can difference it next time
        ko.utils.domData.set(domNode, lastMappingResultDomDataKey, newMappingResult);
    }
})();

ko.exportSymbol('utils.setDomNodeChildrenFromArrayMapping', ko.utils.setDomNodeChildrenFromArrayMapping);
ko.nativeTemplateEngine = function () {
    this['allowTemplateRewriting'] = false;
}

ko.nativeTemplateEngine.prototype = new ko.templateEngine();
ko.nativeTemplateEngine.prototype['renderTemplateSource'] = function (templateSource, bindingContext, options) {
    var useNodesIfAvailable = !(ko.utils.ieVersion < 9), // IE<9 cloneNode doesn't work properly
        templateNodesFunc = useNodesIfAvailable ? templateSource['nodes'] : null,
        templateNodes = templateNodesFunc ? templateSource['nodes']() : null;

    if (templateNodes) {
        return ko.utils.makeArray(templateNodes.cloneNode(true).childNodes);
    } else {
        var templateText = templateSource['text']();
        return ko.utils.parseHtmlFragment(templateText);
    }
};

ko.nativeTemplateEngine.instance = new ko.nativeTemplateEngine();
ko.setTemplateEngine(ko.nativeTemplateEngine.instance);

ko.exportSymbol('nativeTemplateEngine', ko.nativeTemplateEngine);
(function() {
    ko.jqueryTmplTemplateEngine = function () {
        // Detect which version of jquery-tmpl you're using. Unfortunately jquery-tmpl
        // doesn't expose a version number, so we have to infer it.
        // Note that as of Knockout 1.3, we only support jQuery.tmpl 1.0.0pre and later,
        // which KO internally refers to as version "2", so older versions are no longer detected.
        var jQueryTmplVersion = this.jQueryTmplVersion = (function() {
            if ((typeof(jQuery) == "undefined") || !(jQuery['tmpl']))
                return 0;
            // Since it exposes no official version number, we use our own numbering system. To be updated as jquery-tmpl evolves.
            try {
                if (jQuery['tmpl']['tag']['tmpl']['open'].toString().indexOf('__') >= 0) {
                    // Since 1.0.0pre, custom tags should append markup to an array called "__"
                    return 2; // Final version of jquery.tmpl
                }
            } catch(ex) { /* Apparently not the version we were looking for */ }

            return 1; // Any older version that we don't support
        })();

        function ensureHasReferencedJQueryTemplates() {
            if (jQueryTmplVersion < 2)
                throw new Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.");
        }

        function executeTemplate(compiledTemplate, data, jQueryTemplateOptions) {
            return jQuery['tmpl'](compiledTemplate, data, jQueryTemplateOptions);
        }

        this['renderTemplateSource'] = function(templateSource, bindingContext, options) {
            options = options || {};
            ensureHasReferencedJQueryTemplates();

            // Ensure we have stored a precompiled version of this template (don't want to reparse on every render)
            var precompiled = templateSource['data']('precompiled');
            if (!precompiled) {
                var templateText = templateSource['text']() || "";
                // Wrap in "with($whatever.koBindingContext) { ... }"
                templateText = "{{ko_with $item.koBindingContext}}" + templateText + "{{/ko_with}}";

                precompiled = jQuery['template'](null, templateText);
                templateSource['data']('precompiled', precompiled);
            }

            var data = [bindingContext['$data']]; // Prewrap the data in an array to stop jquery.tmpl from trying to unwrap any arrays
            var jQueryTemplateOptions = jQuery['extend']({ 'koBindingContext': bindingContext }, options['templateOptions']);

            var resultNodes = executeTemplate(precompiled, data, jQueryTemplateOptions);
            resultNodes['appendTo'](document.createElement("div")); // Using "appendTo" forces jQuery/jQuery.tmpl to perform necessary cleanup work

            jQuery['fragments'] = {}; // Clear jQuery's fragment cache to avoid a memory leak after a large number of template renders
            return resultNodes;
        };

        this['createJavaScriptEvaluatorBlock'] = function(script) {
            return "{{ko_code ((function() { return " + script + " })()) }}";
        };

        this['addTemplate'] = function(templateName, templateMarkup) {
            document.write("<script type='text/html' id='" + templateName + "'>" + templateMarkup + "</script>");
        };

        if (jQueryTmplVersion > 0) {
            jQuery['tmpl']['tag']['ko_code'] = {
                open: "__.push($1 || '');"
            };
            jQuery['tmpl']['tag']['ko_with'] = {
                open: "with($1) {",
                close: "} "
            };
        }
    };

    ko.jqueryTmplTemplateEngine.prototype = new ko.templateEngine();

    // Use this one by default *only if jquery.tmpl is referenced*
    var jqueryTmplTemplateEngineInstance = new ko.jqueryTmplTemplateEngine();
    if (jqueryTmplTemplateEngineInstance.jQueryTmplVersion > 0)
        ko.setTemplateEngine(jqueryTmplTemplateEngineInstance);

    ko.exportSymbol('jqueryTmplTemplateEngine', ko.jqueryTmplTemplateEngine);
})();
});
})(window,document,navigator);

```

`LibreHardwareMonitor/Resources/Web/js/knockout-2.1.0.min.js`:

```js
// Knockout JavaScript library v2.1.0
// (c) Steven Sanderson - http://knockoutjs.com/
// License: MIT (http://www.opensource.org/licenses/mit-license.php)

(function(window,document,navigator,undefined){
function m(w){throw w;}var n=void 0,p=!0,s=null,t=!1;function A(w){return function(){return w}};function E(w){function B(b,c,d){d&&c!==a.k.r(b)&&a.k.S(b,c);c!==a.k.r(b)&&a.a.va(b,"change")}var a="undefined"!==typeof w?w:{};a.b=function(b,c){for(var d=b.split("."),f=a,g=0;g<d.length-1;g++)f=f[d[g]];f[d[d.length-1]]=c};a.B=function(a,c,d){a[c]=d};a.version="2.1.0";a.b("version",a.version);a.a=new function(){function b(b,c){if("input"!==a.a.o(b)||!b.type||"click"!=c.toLowerCase())return t;var e=b.type;return"checkbox"==e||"radio"==e}var c=/^(\s|\u00A0)+|(\s|\u00A0)+$/g,d={},f={};d[/Firefox\/2/i.test(navigator.userAgent)?
"KeyboardEvent":"UIEvents"]=["keyup","keydown","keypress"];d.MouseEvents="click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave".split(" ");for(var g in d){var e=d[g];if(e.length)for(var h=0,j=e.length;h<j;h++)f[e[h]]=g}var k={propertychange:p},i=function(){for(var a=3,b=document.createElement("div"),c=b.getElementsByTagName("i");b.innerHTML="<\!--[if gt IE "+ ++a+"]><i></i><![endif]--\>",c[0];);return 4<a?a:n}();return{Ca:["authenticity_token",/^__RequestVerificationToken(_.*)?$/],
v:function(a,b){for(var c=0,e=a.length;c<e;c++)b(a[c])},j:function(a,b){if("function"==typeof Array.prototype.indexOf)return Array.prototype.indexOf.call(a,b);for(var c=0,e=a.length;c<e;c++)if(a[c]===b)return c;return-1},ab:function(a,b,c){for(var e=0,f=a.length;e<f;e++)if(b.call(c,a[e]))return a[e];return s},ba:function(b,c){var e=a.a.j(b,c);0<=e&&b.splice(e,1)},za:function(b){for(var b=b||[],c=[],e=0,f=b.length;e<f;e++)0>a.a.j(c,b[e])&&c.push(b[e]);return c},T:function(a,b){for(var a=a||[],c=[],
e=0,f=a.length;e<f;e++)c.push(b(a[e]));return c},aa:function(a,b){for(var a=a||[],c=[],e=0,f=a.length;e<f;e++)b(a[e])&&c.push(a[e]);return c},N:function(a,b){if(b instanceof Array)a.push.apply(a,b);else for(var c=0,e=b.length;c<e;c++)a.push(b[c]);return a},extend:function(a,b){if(b)for(var c in b)b.hasOwnProperty(c)&&(a[c]=b[c]);return a},ga:function(b){for(;b.firstChild;)a.removeNode(b.firstChild)},Ab:function(b){for(var b=a.a.L(b),c=document.createElement("div"),e=0,f=b.length;e<f;e++)a.F(b[e]),
c.appendChild(b[e]);return c},X:function(b,c){a.a.ga(b);if(c)for(var e=0,f=c.length;e<f;e++)b.appendChild(c[e])},Na:function(b,c){var e=b.nodeType?[b]:b;if(0<e.length){for(var f=e[0],d=f.parentNode,g=0,h=c.length;g<h;g++)d.insertBefore(c[g],f);g=0;for(h=e.length;g<h;g++)a.removeNode(e[g])}},Pa:function(a,b){0<=navigator.userAgent.indexOf("MSIE 6")?a.setAttribute("selected",b):a.selected=b},w:function(a){return(a||"").replace(c,"")},Ib:function(b,c){for(var e=[],f=(b||"").split(c),g=0,d=f.length;g<
d;g++){var h=a.a.w(f[g]);""!==h&&e.push(h)}return e},Hb:function(a,b){a=a||"";return b.length>a.length?t:a.substring(0,b.length)===b},eb:function(a,b){for(var c="return ("+a+")",e=0;e<b;e++)c="with(sc["+e+"]) { "+c+" } ";return new Function("sc",c)},kb:function(a,b){if(b.compareDocumentPosition)return 16==(b.compareDocumentPosition(a)&16);for(;a!=s;){if(a==b)return p;a=a.parentNode}return t},fa:function(b){return a.a.kb(b,b.ownerDocument)},o:function(a){return a&&a.tagName&&a.tagName.toLowerCase()},
n:function(a,c,e){var f=i&&k[c];if(!f&&"undefined"!=typeof jQuery){if(b(a,c))var g=e,e=function(a,b){var c=this.checked;b&&(this.checked=b.fb!==p);g.call(this,a);this.checked=c};jQuery(a).bind(c,e)}else!f&&"function"==typeof a.addEventListener?a.addEventListener(c,e,t):"undefined"!=typeof a.attachEvent?a.attachEvent("on"+c,function(b){e.call(a,b)}):m(Error("Browser doesn't support addEventListener or attachEvent"))},va:function(a,c){(!a||!a.nodeType)&&m(Error("element must be a DOM node when calling triggerEvent"));
if("undefined"!=typeof jQuery){var e=[];b(a,c)&&e.push({fb:a.checked});jQuery(a).trigger(c,e)}else"function"==typeof document.createEvent?"function"==typeof a.dispatchEvent?(e=document.createEvent(f[c]||"HTMLEvents"),e.initEvent(c,p,p,window,0,0,0,0,0,t,t,t,t,0,a),a.dispatchEvent(e)):m(Error("The supplied element doesn't support dispatchEvent")):"undefined"!=typeof a.fireEvent?(b(a,c)&&(a.checked=a.checked!==p),a.fireEvent("on"+c)):m(Error("Browser doesn't support triggering events"))},d:function(b){return a.la(b)?
b():b},Ua:function(b,c,e){var f=(b.className||"").split(/\s+/),g=0<=a.a.j(f,c);if(e&&!g)b.className+=(f[0]?" ":"")+c;else if(g&&!e){e="";for(g=0;g<f.length;g++)f[g]!=c&&(e+=f[g]+" ");b.className=a.a.w(e)}},Qa:function(b,c){var e=a.a.d(c);if(e===s||e===n)e="";"innerText"in b?b.innerText=e:b.textContent=e;9<=i&&(b.style.display=b.style.display)},lb:function(a){if(9<=i){var b=a.style.width;a.style.width=0;a.style.width=b}},Eb:function(b,e){for(var b=a.a.d(b),e=a.a.d(e),c=[],f=b;f<=e;f++)c.push(f);return c},
L:function(a){for(var b=[],e=0,c=a.length;e<c;e++)b.push(a[e]);return b},tb:6===i,ub:7===i,ja:i,Da:function(b,e){for(var c=a.a.L(b.getElementsByTagName("input")).concat(a.a.L(b.getElementsByTagName("textarea"))),f="string"==typeof e?function(a){return a.name===e}:function(a){return e.test(a.name)},g=[],d=c.length-1;0<=d;d--)f(c[d])&&g.push(c[d]);return g},Bb:function(b){return"string"==typeof b&&(b=a.a.w(b))?window.JSON&&window.JSON.parse?window.JSON.parse(b):(new Function("return "+b))():s},sa:function(b,
e,c){("undefined"==typeof JSON||"undefined"==typeof JSON.stringify)&&m(Error("Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js"));return JSON.stringify(a.a.d(b),e,c)},Cb:function(b,e,c){var c=c||{},f=c.params||{},g=c.includeFields||this.Ca,d=b;if("object"==typeof b&&"form"===a.a.o(b))for(var d=b.action,h=g.length-1;0<=h;h--)for(var k=a.a.Da(b,g[h]),
j=k.length-1;0<=j;j--)f[k[j].name]=k[j].value;var e=a.a.d(e),i=document.createElement("form");i.style.display="none";i.action=d;i.method="post";for(var z in e)b=document.createElement("input"),b.name=z,b.value=a.a.sa(a.a.d(e[z])),i.appendChild(b);for(z in f)b=document.createElement("input"),b.name=z,b.value=f[z],i.appendChild(b);document.body.appendChild(i);c.submitter?c.submitter(i):i.submit();setTimeout(function(){i.parentNode.removeChild(i)},0)}}};a.b("utils",a.a);a.b("utils.arrayForEach",a.a.v);
a.b("utils.arrayFirst",a.a.ab);a.b("utils.arrayFilter",a.a.aa);a.b("utils.arrayGetDistinctValues",a.a.za);a.b("utils.arrayIndexOf",a.a.j);a.b("utils.arrayMap",a.a.T);a.b("utils.arrayPushAll",a.a.N);a.b("utils.arrayRemoveItem",a.a.ba);a.b("utils.extend",a.a.extend);a.b("utils.fieldsIncludedWithJsonPost",a.a.Ca);a.b("utils.getFormFields",a.a.Da);a.b("utils.postJson",a.a.Cb);a.b("utils.parseJson",a.a.Bb);a.b("utils.registerEventHandler",a.a.n);a.b("utils.stringifyJson",a.a.sa);a.b("utils.range",a.a.Eb);
a.b("utils.toggleDomNodeCssClass",a.a.Ua);a.b("utils.triggerEvent",a.a.va);a.b("utils.unwrapObservable",a.a.d);Function.prototype.bind||(Function.prototype.bind=function(a){var c=this,d=Array.prototype.slice.call(arguments),a=d.shift();return function(){return c.apply(a,d.concat(Array.prototype.slice.call(arguments)))}});a.a.f=new function(){var b=0,c="__ko__"+(new Date).getTime(),d={};return{get:function(b,c){var e=a.a.f.getAll(b,t);return e===n?n:e[c]},set:function(b,c,e){e===n&&a.a.f.getAll(b,
t)===n||(a.a.f.getAll(b,p)[c]=e)},getAll:function(a,g){var e=a[c];if(!(e&&"null"!==e)){if(!g)return;e=a[c]="ko"+b++;d[e]={}}return d[e]},clear:function(a){var b=a[c];b&&(delete d[b],a[c]=s)}}};a.b("utils.domData",a.a.f);a.b("utils.domData.clear",a.a.f.clear);a.a.G=new function(){function b(b,c){var f=a.a.f.get(b,d);f===n&&c&&(f=[],a.a.f.set(b,d,f));return f}function c(e){var f=b(e,t);if(f)for(var f=f.slice(0),d=0;d<f.length;d++)f[d](e);a.a.f.clear(e);"function"==typeof jQuery&&"function"==typeof jQuery.cleanData&&
jQuery.cleanData([e]);if(g[e.nodeType])for(f=e.firstChild;e=f;)f=e.nextSibling,8===e.nodeType&&c(e)}var d="__ko_domNodeDisposal__"+(new Date).getTime(),f={1:p,8:p,9:p},g={1:p,9:p};return{wa:function(a,c){"function"!=typeof c&&m(Error("Callback must be a function"));b(a,p).push(c)},Ma:function(c,f){var g=b(c,t);g&&(a.a.ba(g,f),0==g.length&&a.a.f.set(c,d,n))},F:function(b){if(f[b.nodeType]&&(c(b),g[b.nodeType])){var d=[];a.a.N(d,b.getElementsByTagName("*"));for(var b=0,j=d.length;b<j;b++)c(d[b])}},
removeNode:function(b){a.F(b);b.parentNode&&b.parentNode.removeChild(b)}}};a.F=a.a.G.F;a.removeNode=a.a.G.removeNode;a.b("cleanNode",a.F);a.b("removeNode",a.removeNode);a.b("utils.domNodeDisposal",a.a.G);a.b("utils.domNodeDisposal.addDisposeCallback",a.a.G.wa);a.b("utils.domNodeDisposal.removeDisposeCallback",a.a.G.Ma);(function(){a.a.pa=function(b){var c;if("undefined"!=typeof jQuery){if((c=jQuery.clean([b]))&&c[0]){for(b=c[0];b.parentNode&&11!==b.parentNode.nodeType;)b=b.parentNode;b.parentNode&&
b.parentNode.removeChild(b)}}else{var d=a.a.w(b).toLowerCase();c=document.createElement("div");d=d.match(/^<(thead|tbody|tfoot)/)&&[1,"<table>","</table>"]||!d.indexOf("<tr")&&[2,"<table><tbody>","</tbody></table>"]||(!d.indexOf("<td")||!d.indexOf("<th"))&&[3,"<table><tbody><tr>","</tr></tbody></table>"]||[0,"",""];b="ignored<div>"+d[1]+b+d[2]+"</div>";for("function"==typeof window.innerShiv?c.appendChild(window.innerShiv(b)):c.innerHTML=b;d[0]--;)c=c.lastChild;c=a.a.L(c.lastChild.childNodes)}return c};
a.a.Y=function(b,c){a.a.ga(b);if(c!==s&&c!==n)if("string"!=typeof c&&(c=c.toString()),"undefined"!=typeof jQuery)jQuery(b).html(c);else for(var d=a.a.pa(c),f=0;f<d.length;f++)b.appendChild(d[f])}})();a.b("utils.parseHtmlFragment",a.a.pa);a.b("utils.setHtml",a.a.Y);a.s=function(){function b(){return(4294967296*(1+Math.random())|0).toString(16).substring(1)}function c(b,g){if(b)if(8==b.nodeType){var e=a.s.Ja(b.nodeValue);e!=s&&g.push({jb:b,yb:e})}else if(1==b.nodeType)for(var e=0,d=b.childNodes,j=d.length;e<
j;e++)c(d[e],g)}var d={};return{na:function(a){"function"!=typeof a&&m(Error("You can only pass a function to ko.memoization.memoize()"));var c=b()+b();d[c]=a;return"<\!--[ko_memo:"+c+"]--\>"},Va:function(a,b){var c=d[a];c===n&&m(Error("Couldn't find any memo with ID "+a+". Perhaps it's already been unmemoized."));try{return c.apply(s,b||[]),p}finally{delete d[a]}},Wa:function(b,d){var e=[];c(b,e);for(var h=0,j=e.length;h<j;h++){var k=e[h].jb,i=[k];d&&a.a.N(i,d);a.s.Va(e[h].yb,i);k.nodeValue="";k.parentNode&&
k.parentNode.removeChild(k)}},Ja:function(a){return(a=a.match(/^\[ko_memo\:(.*?)\]$/))?a[1]:s}}}();a.b("memoization",a.s);a.b("memoization.memoize",a.s.na);a.b("memoization.unmemoize",a.s.Va);a.b("memoization.parseMemoText",a.s.Ja);a.b("memoization.unmemoizeDomNodeAndDescendants",a.s.Wa);a.Ba={throttle:function(b,c){b.throttleEvaluation=c;var d=s;return a.h({read:b,write:function(a){clearTimeout(d);d=setTimeout(function(){b(a)},c)}})},notify:function(b,c){b.equalityComparer="always"==c?A(t):a.m.fn.equalityComparer;
return b}};a.b("extenders",a.Ba);a.Sa=function(b,c,d){this.target=b;this.ca=c;this.ib=d;a.B(this,"dispose",this.A)};a.Sa.prototype.A=function(){this.sb=p;this.ib()};a.R=function(){this.u={};a.a.extend(this,a.R.fn);a.B(this,"subscribe",this.ta);a.B(this,"extend",this.extend);a.B(this,"getSubscriptionsCount",this.ob)};a.R.fn={ta:function(b,c,d){var d=d||"change",b=c?b.bind(c):b,f=new a.Sa(this,b,function(){a.a.ba(this.u[d],f)}.bind(this));this.u[d]||(this.u[d]=[]);this.u[d].push(f);return f},notifySubscribers:function(b,
c){c=c||"change";this.u[c]&&a.a.v(this.u[c].slice(0),function(a){a&&a.sb!==p&&a.ca(b)})},ob:function(){var a=0,c;for(c in this.u)this.u.hasOwnProperty(c)&&(a+=this.u[c].length);return a},extend:function(b){var c=this;if(b)for(var d in b){var f=a.Ba[d];"function"==typeof f&&(c=f(c,b[d]))}return c}};a.Ga=function(a){return"function"==typeof a.ta&&"function"==typeof a.notifySubscribers};a.b("subscribable",a.R);a.b("isSubscribable",a.Ga);a.U=function(){var b=[];return{bb:function(a){b.push({ca:a,Aa:[]})},
end:function(){b.pop()},La:function(c){a.Ga(c)||m(Error("Only subscribable things can act as dependencies"));if(0<b.length){var d=b[b.length-1];0<=a.a.j(d.Aa,c)||(d.Aa.push(c),d.ca(c))}}}}();var G={undefined:p,"boolean":p,number:p,string:p};a.m=function(b){function c(){if(0<arguments.length){if(!c.equalityComparer||!c.equalityComparer(d,arguments[0]))c.I(),d=arguments[0],c.H();return this}a.U.La(c);return d}var d=b;a.R.call(c);c.H=function(){c.notifySubscribers(d)};c.I=function(){c.notifySubscribers(d,
"beforeChange")};a.a.extend(c,a.m.fn);a.B(c,"valueHasMutated",c.H);a.B(c,"valueWillMutate",c.I);return c};a.m.fn={equalityComparer:function(a,c){return a===s||typeof a in G?a===c:t}};var x=a.m.Db="__ko_proto__";a.m.fn[x]=a.m;a.ia=function(b,c){return b===s||b===n||b[x]===n?t:b[x]===c?p:a.ia(b[x],c)};a.la=function(b){return a.ia(b,a.m)};a.Ha=function(b){return"function"==typeof b&&b[x]===a.m||"function"==typeof b&&b[x]===a.h&&b.pb?p:t};a.b("observable",a.m);a.b("isObservable",a.la);a.b("isWriteableObservable",
a.Ha);a.Q=function(b){0==arguments.length&&(b=[]);b!==s&&(b!==n&&!("length"in b))&&m(Error("The argument passed when initializing an observable array must be an array, or null, or undefined."));var c=a.m(b);a.a.extend(c,a.Q.fn);return c};a.Q.fn={remove:function(a){for(var c=this(),d=[],f="function"==typeof a?a:function(c){return c===a},g=0;g<c.length;g++){var e=c[g];f(e)&&(0===d.length&&this.I(),d.push(e),c.splice(g,1),g--)}d.length&&this.H();return d},removeAll:function(b){if(b===n){var c=this(),
d=c.slice(0);this.I();c.splice(0,c.length);this.H();return d}return!b?[]:this.remove(function(c){return 0<=a.a.j(b,c)})},destroy:function(a){var c=this(),d="function"==typeof a?a:function(c){return c===a};this.I();for(var f=c.length-1;0<=f;f--)d(c[f])&&(c[f]._destroy=p);this.H()},destroyAll:function(b){return b===n?this.destroy(A(p)):!b?[]:this.destroy(function(c){return 0<=a.a.j(b,c)})},indexOf:function(b){var c=this();return a.a.j(c,b)},replace:function(a,c){var d=this.indexOf(a);0<=d&&(this.I(),
this()[d]=c,this.H())}};a.a.v("pop push reverse shift sort splice unshift".split(" "),function(b){a.Q.fn[b]=function(){var a=this();this.I();a=a[b].apply(a,arguments);this.H();return a}});a.a.v(["slice"],function(b){a.Q.fn[b]=function(){var a=this();return a[b].apply(a,arguments)}});a.b("observableArray",a.Q);a.h=function(b,c,d){function f(){a.a.v(v,function(a){a.A()});v=[]}function g(){var a=h.throttleEvaluation;a&&0<=a?(clearTimeout(x),x=setTimeout(e,a)):e()}function e(){if(!l)if(i&&w())u();else{l=
p;try{var b=a.a.T(v,function(a){return a.target});a.U.bb(function(c){var e;0<=(e=a.a.j(b,c))?b[e]=n:v.push(c.ta(g))});for(var e=q.call(c),f=b.length-1;0<=f;f--)b[f]&&v.splice(f,1)[0].A();i=p;h.notifySubscribers(k,"beforeChange");k=e}finally{a.U.end()}h.notifySubscribers(k);l=t}}function h(){if(0<arguments.length)j.apply(h,arguments);else return i||e(),a.U.La(h),k}function j(){"function"===typeof o?o.apply(c,arguments):m(Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters."))}
var k,i=t,l=t,q=b;q&&"object"==typeof q?(d=q,q=d.read):(d=d||{},q||(q=d.read));"function"!=typeof q&&m(Error("Pass a function that returns the value of the ko.computed"));var o=d.write;c||(c=d.owner);var v=[],u=f,r="object"==typeof d.disposeWhenNodeIsRemoved?d.disposeWhenNodeIsRemoved:s,w=d.disposeWhen||A(t);if(r){u=function(){a.a.G.Ma(r,arguments.callee);f()};a.a.G.wa(r,u);var y=w,w=function(){return!a.a.fa(r)||y()}}var x=s;h.nb=function(){return v.length};h.pb="function"===typeof d.write;h.A=function(){u()};
a.R.call(h);a.a.extend(h,a.h.fn);d.deferEvaluation!==p&&e();a.B(h,"dispose",h.A);a.B(h,"getDependenciesCount",h.nb);return h};a.rb=function(b){return a.ia(b,a.h)};w=a.m.Db;a.h[w]=a.m;a.h.fn={};a.h.fn[w]=a.h;a.b("dependentObservable",a.h);a.b("computed",a.h);a.b("isComputed",a.rb);(function(){function b(a,g,e){e=e||new d;a=g(a);if(!("object"==typeof a&&a!==s&&a!==n&&!(a instanceof Date)))return a;var h=a instanceof Array?[]:{};e.save(a,h);c(a,function(c){var d=g(a[c]);switch(typeof d){case "boolean":case "number":case "string":case "function":h[c]=
d;break;case "object":case "undefined":var i=e.get(d);h[c]=i!==n?i:b(d,g,e)}});return h}function c(a,b){if(a instanceof Array){for(var c=0;c<a.length;c++)b(c);"function"==typeof a.toJSON&&b("toJSON")}else for(c in a)b(c)}function d(){var b=[],c=[];this.save=function(e,d){var j=a.a.j(b,e);0<=j?c[j]=d:(b.push(e),c.push(d))};this.get=function(e){e=a.a.j(b,e);return 0<=e?c[e]:n}}a.Ta=function(c){0==arguments.length&&m(Error("When calling ko.toJS, pass the object you want to convert."));return b(c,function(b){for(var c=
0;a.la(b)&&10>c;c++)b=b();return b})};a.toJSON=function(b,c,e){b=a.Ta(b);return a.a.sa(b,c,e)}})();a.b("toJS",a.Ta);a.b("toJSON",a.toJSON);(function(){a.k={r:function(b){switch(a.a.o(b)){case "option":return b.__ko__hasDomDataOptionValue__===p?a.a.f.get(b,a.c.options.oa):b.getAttribute("value");case "select":return 0<=b.selectedIndex?a.k.r(b.options[b.selectedIndex]):n;default:return b.value}},S:function(b,c){switch(a.a.o(b)){case "option":switch(typeof c){case "string":a.a.f.set(b,a.c.options.oa,
n);"__ko__hasDomDataOptionValue__"in b&&delete b.__ko__hasDomDataOptionValue__;b.value=c;break;default:a.a.f.set(b,a.c.options.oa,c),b.__ko__hasDomDataOptionValue__=p,b.value="number"===typeof c?c:""}break;case "select":for(var d=b.options.length-1;0<=d;d--)if(a.k.r(b.options[d])==c){b.selectedIndex=d;break}break;default:if(c===s||c===n)c="";b.value=c}}}})();a.b("selectExtensions",a.k);a.b("selectExtensions.readValue",a.k.r);a.b("selectExtensions.writeValue",a.k.S);a.g=function(){function b(a,b){for(var d=
s;a!=d;)d=a,a=a.replace(c,function(a,c){return b[c]});return a}var c=/\@ko_token_(\d+)\@/g,d=/^[\_$a-z][\_$a-z0-9]*(\[.*?\])*(\.[\_$a-z][\_$a-z0-9]*(\[.*?\])*)*$/i,f=["true","false"];return{D:[],W:function(c){var e=a.a.w(c);if(3>e.length)return[];"{"===e.charAt(0)&&(e=e.substring(1,e.length-1));for(var c=[],d=s,f,k=0;k<e.length;k++){var i=e.charAt(k);if(d===s)switch(i){case '"':case "'":case "/":d=k,f=i}else if(i==f&&"\\"!==e.charAt(k-1)){i=e.substring(d,k+1);c.push(i);var l="@ko_token_"+(c.length-
1)+"@",e=e.substring(0,d)+l+e.substring(k+1),k=k-(i.length-l.length),d=s}}f=d=s;for(var q=0,o=s,k=0;k<e.length;k++){i=e.charAt(k);if(d===s)switch(i){case "{":d=k;o=i;f="}";break;case "(":d=k;o=i;f=")";break;case "[":d=k,o=i,f="]"}i===o?q++:i===f&&(q--,0===q&&(i=e.substring(d,k+1),c.push(i),l="@ko_token_"+(c.length-1)+"@",e=e.substring(0,d)+l+e.substring(k+1),k-=i.length-l.length,d=s))}f=[];e=e.split(",");d=0;for(k=e.length;d<k;d++)q=e[d],o=q.indexOf(":"),0<o&&o<q.length-1?(i=q.substring(o+1),f.push({key:b(q.substring(0,
o),c),value:b(i,c)})):f.push({unknown:b(q,c)});return f},ka:function(b){for(var c="string"===typeof b?a.g.W(b):b,h=[],b=[],j,k=0;j=c[k];k++)if(0<h.length&&h.push(","),j.key){var i;a:{i=j.key;var l=a.a.w(i);switch(l.length&&l.charAt(0)){case "'":case '"':break a;default:i="'"+l+"'"}}j=j.value;h.push(i);h.push(":");h.push(j);l=a.a.w(j);if(0<=a.a.j(f,a.a.w(l).toLowerCase())?0:l.match(d)!==s)0<b.length&&b.push(", "),b.push(i+" : function(__ko_value) { "+j+" = __ko_value; }")}else j.unknown&&h.push(j.unknown);
c=h.join("");0<b.length&&(c=c+", '_ko_property_writers' : { "+b.join("")+" } ");return c},wb:function(b,c){for(var d=0;d<b.length;d++)if(a.a.w(b[d].key)==c)return p;return t},$:function(b,c,d,f,k){if(!b||!a.Ha(b)){if((b=c()._ko_property_writers)&&b[d])b[d](f)}else(!k||b()!==f)&&b(f)}}}();a.b("jsonExpressionRewriting",a.g);a.b("jsonExpressionRewriting.bindingRewriteValidators",a.g.D);a.b("jsonExpressionRewriting.parseObjectLiteral",a.g.W);a.b("jsonExpressionRewriting.insertPropertyAccessorsIntoJson",
a.g.ka);(function(){function b(a){return 8==a.nodeType&&(g?a.text:a.nodeValue).match(e)}function c(a){return 8==a.nodeType&&(g?a.text:a.nodeValue).match(h)}function d(a,e){for(var d=a,f=1,g=[];d=d.nextSibling;){if(c(d)&&(f--,0===f))return g;g.push(d);b(d)&&f++}e||m(Error("Cannot find closing comment tag to match: "+a.nodeValue));return s}function f(a,b){var c=d(a,b);return c?0<c.length?c[c.length-1].nextSibling:a.nextSibling:s}var g="<\!--test--\>"===document.createComment("test").text,e=g?/^<\!--\s*ko\s+(.*\:.*)\s*--\>$/:
/^\s*ko\s+(.*\:.*)\s*$/,h=g?/^<\!--\s*\/ko\s*--\>$/:/^\s*\/ko\s*$/,j={ul:p,ol:p};a.e={C:{},childNodes:function(a){return b(a)?d(a):a.childNodes},ha:function(c){if(b(c))for(var c=a.e.childNodes(c),e=0,d=c.length;e<d;e++)a.removeNode(c[e]);else a.a.ga(c)},X:function(c,e){if(b(c)){a.e.ha(c);for(var d=c.nextSibling,f=0,g=e.length;f<g;f++)d.parentNode.insertBefore(e[f],d)}else a.a.X(c,e)},Ka:function(a,c){b(a)?a.parentNode.insertBefore(c,a.nextSibling):a.firstChild?a.insertBefore(c,a.firstChild):a.appendChild(c)},
Fa:function(a,c,e){b(a)?a.parentNode.insertBefore(c,e.nextSibling):e.nextSibling?a.insertBefore(c,e.nextSibling):a.appendChild(c)},firstChild:function(a){return!b(a)?a.firstChild:!a.nextSibling||c(a.nextSibling)?s:a.nextSibling},nextSibling:function(a){b(a)&&(a=f(a));return a.nextSibling&&c(a.nextSibling)?s:a.nextSibling},Xa:function(a){return(a=b(a))?a[1]:s},Ia:function(e){if(j[a.a.o(e)]){var d=e.firstChild;if(d){do if(1===d.nodeType){var g;g=d.firstChild;var h=s;if(g){do if(h)h.push(g);else if(b(g)){var o=
f(g,p);o?g=o:h=[g]}else c(g)&&(h=[g]);while(g=g.nextSibling)}if(g=h){h=d.nextSibling;for(o=0;o<g.length;o++)h?e.insertBefore(g[o],h):e.appendChild(g[o])}}while(d=d.nextSibling)}}}}})();a.b("virtualElements",a.e);a.b("virtualElements.allowedBindings",a.e.C);a.b("virtualElements.emptyNode",a.e.ha);a.b("virtualElements.insertAfter",a.e.Fa);a.b("virtualElements.prepend",a.e.Ka);a.b("virtualElements.setDomNodeChildren",a.e.X);(function(){a.J=function(){this.cb={}};a.a.extend(a.J.prototype,{nodeHasBindings:function(b){switch(b.nodeType){case 1:return b.getAttribute("data-bind")!=
s;case 8:return a.e.Xa(b)!=s;default:return t}},getBindings:function(a,c){var d=this.getBindingsString(a,c);return d?this.parseBindingsString(d,c):s},getBindingsString:function(b){switch(b.nodeType){case 1:return b.getAttribute("data-bind");case 8:return a.e.Xa(b);default:return s}},parseBindingsString:function(b,c){try{var d=c.$data,d="object"==typeof d&&d!=s?[d,c]:[c],f=d.length,g=this.cb,e=f+"_"+b,h;if(!(h=g[e])){var j=" { "+a.g.ka(b)+" } ";h=g[e]=a.a.eb(j,f)}return h(d)}catch(k){m(Error("Unable to parse bindings.\nMessage: "+
k+";\nBindings value: "+b))}}});a.J.instance=new a.J})();a.b("bindingProvider",a.J);(function(){function b(b,d,e){for(var h=a.e.firstChild(d);d=h;)h=a.e.nextSibling(d),c(b,d,e)}function c(c,g,e){var h=p,j=1===g.nodeType;j&&a.e.Ia(g);if(j&&e||a.J.instance.nodeHasBindings(g))h=d(g,s,c,e).Gb;h&&b(c,g,!j)}function d(b,c,e,d){function j(a){return function(){return l[a]}}function k(){return l}var i=0,l,q;a.h(function(){var o=e&&e instanceof a.z?e:new a.z(a.a.d(e)),v=o.$data;d&&a.Ra(b,o);if(l=("function"==
typeof c?c():c)||a.J.instance.getBindings(b,o)){if(0===i){i=1;for(var u in l){var r=a.c[u];r&&8===b.nodeType&&!a.e.C[u]&&m(Error("The binding '"+u+"' cannot be used with virtual elements"));if(r&&"function"==typeof r.init&&(r=(0,r.init)(b,j(u),k,v,o))&&r.controlsDescendantBindings)q!==n&&m(Error("Multiple bindings ("+q+" and "+u+") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.")),q=u}i=2}if(2===i)for(u in l)(r=a.c[u])&&"function"==
typeof r.update&&(0,r.update)(b,j(u),k,v,o)}},s,{disposeWhenNodeIsRemoved:b});return{Gb:q===n}}a.c={};a.z=function(b,c){c?(a.a.extend(this,c),this.$parentContext=c,this.$parent=c.$data,this.$parents=(c.$parents||[]).slice(0),this.$parents.unshift(this.$parent)):(this.$parents=[],this.$root=b);this.$data=b};a.z.prototype.createChildContext=function(b){return new a.z(b,this)};a.z.prototype.extend=function(b){var c=a.a.extend(new a.z,this);return a.a.extend(c,b)};a.Ra=function(b,c){if(2==arguments.length)a.a.f.set(b,
"__ko_bindingContext__",c);else return a.a.f.get(b,"__ko_bindingContext__")};a.ya=function(b,c,e){1===b.nodeType&&a.e.Ia(b);return d(b,c,e,p)};a.Ya=function(a,c){(1===c.nodeType||8===c.nodeType)&&b(a,c,p)};a.xa=function(a,b){b&&(1!==b.nodeType&&8!==b.nodeType)&&m(Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node"));b=b||window.document.body;c(a,b,p)};a.ea=function(b){switch(b.nodeType){case 1:case 8:var c=a.Ra(b);if(c)return c;if(b.parentNode)return a.ea(b.parentNode)}};
a.hb=function(b){return(b=a.ea(b))?b.$data:n};a.b("bindingHandlers",a.c);a.b("applyBindings",a.xa);a.b("applyBindingsToDescendants",a.Ya);a.b("applyBindingsToNode",a.ya);a.b("contextFor",a.ea);a.b("dataFor",a.hb)})();a.a.v(["click"],function(b){a.c[b]={init:function(c,d,f,g){return a.c.event.init.call(this,c,function(){var a={};a[b]=d();return a},f,g)}}});a.c.event={init:function(b,c,d,f){var g=c()||{},e;for(e in g)(function(){var g=e;"string"==typeof g&&a.a.n(b,g,function(b){var e,i=c()[g];if(i){var l=
d();try{var q=a.a.L(arguments);q.unshift(f);e=i.apply(f,q)}finally{e!==p&&(b.preventDefault?b.preventDefault():b.returnValue=t)}l[g+"Bubble"]===t&&(b.cancelBubble=p,b.stopPropagation&&b.stopPropagation())}})})()}};a.c.submit={init:function(b,c,d,f){"function"!=typeof c()&&m(Error("The value for a submit binding must be a function"));a.a.n(b,"submit",function(a){var e,d=c();try{e=d.call(f,b)}finally{e!==p&&(a.preventDefault?a.preventDefault():a.returnValue=t)}})}};a.c.visible={update:function(b,c){var d=
a.a.d(c()),f="none"!=b.style.display;d&&!f?b.style.display="":!d&&f&&(b.style.display="none")}};a.c.enable={update:function(b,c){var d=a.a.d(c());d&&b.disabled?b.removeAttribute("disabled"):!d&&!b.disabled&&(b.disabled=p)}};a.c.disable={update:function(b,c){a.c.enable.update(b,function(){return!a.a.d(c())})}};a.c.value={init:function(b,c,d){function f(){var e=c(),f=a.k.r(b);a.g.$(e,d,"value",f,p)}var g=["change"],e=d().valueUpdate;e&&("string"==typeof e&&(e=[e]),a.a.N(g,e),g=a.a.za(g));if(a.a.ja&&
("input"==b.tagName.toLowerCase()&&"text"==b.type&&"off"!=b.autocomplete&&(!b.form||"off"!=b.form.autocomplete))&&-1==a.a.j(g,"propertychange")){var h=t;a.a.n(b,"propertychange",function(){h=p});a.a.n(b,"blur",function(){if(h){h=t;f()}})}a.a.v(g,function(c){var e=f;if(a.a.Hb(c,"after")){e=function(){setTimeout(f,0)};c=c.substring(5)}a.a.n(b,c,e)})},update:function(b,c){var d="select"===a.a.o(b),f=a.a.d(c()),g=a.k.r(b),e=f!=g;0===f&&(0!==g&&"0"!==g)&&(e=p);e&&(g=function(){a.k.S(b,f)},g(),d&&setTimeout(g,
0));d&&0<b.length&&B(b,f,t)}};a.c.options={update:function(b,c,d){"select"!==a.a.o(b)&&m(Error("options binding applies only to SELECT elements"));for(var f=0==b.length,g=a.a.T(a.a.aa(b.childNodes,function(b){return b.tagName&&"option"===a.a.o(b)&&b.selected}),function(b){return a.k.r(b)||b.innerText||b.textContent}),e=b.scrollTop,h=a.a.d(c());0<b.length;)a.F(b.options[0]),b.remove(0);if(h){d=d();"number"!=typeof h.length&&(h=[h]);if(d.optionsCaption){var j=document.createElement("option");a.a.Y(j,
d.optionsCaption);a.k.S(j,n);b.appendChild(j)}for(var c=0,k=h.length;c<k;c++){var j=document.createElement("option"),i="string"==typeof d.optionsValue?h[c][d.optionsValue]:h[c],i=a.a.d(i);a.k.S(j,i);var l=d.optionsText,i="function"==typeof l?l(h[c]):"string"==typeof l?h[c][l]:i;if(i===s||i===n)i="";a.a.Qa(j,i);b.appendChild(j)}h=b.getElementsByTagName("option");c=j=0;for(k=h.length;c<k;c++)0<=a.a.j(g,a.k.r(h[c]))&&(a.a.Pa(h[c],p),j++);b.scrollTop=e;f&&"value"in d&&B(b,a.a.d(d.value),p);a.a.lb(b)}}};
a.c.options.oa="__ko.optionValueDomData__";a.c.selectedOptions={Ea:function(b){for(var c=[],b=b.childNodes,d=0,f=b.length;d<f;d++){var g=b[d],e=a.a.o(g);"option"==e&&g.selected?c.push(a.k.r(g)):"optgroup"==e&&(g=a.c.selectedOptions.Ea(g),Array.prototype.splice.apply(c,[c.length,0].concat(g)))}return c},init:function(b,c,d){a.a.n(b,"change",function(){var b=c(),g=a.c.selectedOptions.Ea(this);a.g.$(b,d,"value",g)})},update:function(b,c){"select"!=a.a.o(b)&&m(Error("values binding applies only to SELECT elements"));
var d=a.a.d(c());if(d&&"number"==typeof d.length)for(var f=b.childNodes,g=0,e=f.length;g<e;g++){var h=f[g];"option"===a.a.o(h)&&a.a.Pa(h,0<=a.a.j(d,a.k.r(h)))}}};a.c.text={update:function(b,c){a.a.Qa(b,c())}};a.c.html={init:function(){return{controlsDescendantBindings:p}},update:function(b,c){var d=a.a.d(c());a.a.Y(b,d)}};a.c.css={update:function(b,c){var d=a.a.d(c()||{}),f;for(f in d)if("string"==typeof f){var g=a.a.d(d[f]);a.a.Ua(b,f,g)}}};a.c.style={update:function(b,c){var d=a.a.d(c()||{}),f;
for(f in d)if("string"==typeof f){var g=a.a.d(d[f]);b.style[f]=g||""}}};a.c.uniqueName={init:function(b,c){c()&&(b.name="ko_unique_"+ ++a.c.uniqueName.gb,(a.a.tb||a.a.ub)&&b.mergeAttributes(document.createElement("<input name='"+b.name+"'/>"),t))}};a.c.uniqueName.gb=0;a.c.checked={init:function(b,c,d){a.a.n(b,"click",function(){var f;if("checkbox"==b.type)f=b.checked;else if("radio"==b.type&&b.checked)f=b.value;else return;var g=c();"checkbox"==b.type&&a.a.d(g)instanceof Array?(f=a.a.j(a.a.d(g),b.value),
b.checked&&0>f?g.push(b.value):!b.checked&&0<=f&&g.splice(f,1)):a.g.$(g,d,"checked",f,p)});"radio"==b.type&&!b.name&&a.c.uniqueName.init(b,A(p))},update:function(b,c){var d=a.a.d(c());"checkbox"==b.type?b.checked=d instanceof Array?0<=a.a.j(d,b.value):d:"radio"==b.type&&(b.checked=b.value==d)}};var F={"class":"className","for":"htmlFor"};a.c.attr={update:function(b,c){var d=a.a.d(c())||{},f;for(f in d)if("string"==typeof f){var g=a.a.d(d[f]),e=g===t||g===s||g===n;e&&b.removeAttribute(f);8>=a.a.ja&&
f in F?(f=F[f],e?b.removeAttribute(f):b[f]=g):e||b.setAttribute(f,g.toString())}}};a.c.hasfocus={init:function(b,c,d){function f(b){var e=c();a.g.$(e,d,"hasfocus",b,p)}a.a.n(b,"focus",function(){f(p)});a.a.n(b,"focusin",function(){f(p)});a.a.n(b,"blur",function(){f(t)});a.a.n(b,"focusout",function(){f(t)})},update:function(b,c){var d=a.a.d(c());d?b.focus():b.blur();a.a.va(b,d?"focusin":"focusout")}};a.c["with"]={p:function(b){return function(){var c=b();return{"if":c,data:c,templateEngine:a.q.K}}},
init:function(b,c){return a.c.template.init(b,a.c["with"].p(c))},update:function(b,c,d,f,g){return a.c.template.update(b,a.c["with"].p(c),d,f,g)}};a.g.D["with"]=t;a.e.C["with"]=p;a.c["if"]={p:function(b){return function(){return{"if":b(),templateEngine:a.q.K}}},init:function(b,c){return a.c.template.init(b,a.c["if"].p(c))},update:function(b,c,d,f,g){return a.c.template.update(b,a.c["if"].p(c),d,f,g)}};a.g.D["if"]=t;a.e.C["if"]=p;a.c.ifnot={p:function(b){return function(){return{ifnot:b(),templateEngine:a.q.K}}},
init:function(b,c){return a.c.template.init(b,a.c.ifnot.p(c))},update:function(b,c,d,f,g){return a.c.template.update(b,a.c.ifnot.p(c),d,f,g)}};a.g.D.ifnot=t;a.e.C.ifnot=p;a.c.foreach={p:function(b){return function(){var c=a.a.d(b());return!c||"number"==typeof c.length?{foreach:c,templateEngine:a.q.K}:{foreach:c.data,includeDestroyed:c.includeDestroyed,afterAdd:c.afterAdd,beforeRemove:c.beforeRemove,afterRender:c.afterRender,templateEngine:a.q.K}}},init:function(b,c){return a.c.template.init(b,a.c.foreach.p(c))},
update:function(b,c,d,f,g){return a.c.template.update(b,a.c.foreach.p(c),d,f,g)}};a.g.D.foreach=t;a.e.C.foreach=p;a.t=function(){};a.t.prototype.renderTemplateSource=function(){m(Error("Override renderTemplateSource"))};a.t.prototype.createJavaScriptEvaluatorBlock=function(){m(Error("Override createJavaScriptEvaluatorBlock"))};a.t.prototype.makeTemplateSource=function(b,c){if("string"==typeof b){var c=c||document,d=c.getElementById(b);d||m(Error("Cannot find template with ID "+b));return new a.l.i(d)}if(1==
b.nodeType||8==b.nodeType)return new a.l.M(b);m(Error("Unknown template type: "+b))};a.t.prototype.renderTemplate=function(a,c,d,f){return this.renderTemplateSource(this.makeTemplateSource(a,f),c,d)};a.t.prototype.isTemplateRewritten=function(a,c){return this.allowTemplateRewriting===t||!(c&&c!=document)&&this.V&&this.V[a]?p:this.makeTemplateSource(a,c).data("isRewritten")};a.t.prototype.rewriteTemplate=function(a,c,d){var f=this.makeTemplateSource(a,d),c=c(f.text());f.text(c);f.data("isRewritten",
p);!(d&&d!=document)&&"string"==typeof a&&(this.V=this.V||{},this.V[a]=p)};a.b("templateEngine",a.t);a.Z=function(){function b(b,c,e){for(var b=a.g.W(b),d=a.g.D,j=0;j<b.length;j++){var k=b[j].key;if(d.hasOwnProperty(k)){var i=d[k];"function"===typeof i?(k=i(b[j].value))&&m(Error(k)):i||m(Error("This template engine does not support the '"+k+"' binding within its templates"))}}b="ko.templateRewriting.applyMemoizedBindingsToNextSibling(function() {             return (function() { return { "+a.g.ka(b)+
" } })()         })";return e.createJavaScriptEvaluatorBlock(b)+c}var c=/(<[a-z]+\d*(\s+(?!data-bind=)[a-z0-9\-]+(=(\"[^\"]*\"|\'[^\']*\'))?)*\s+)data-bind=(["'])([\s\S]*?)\5/gi,d=/<\!--\s*ko\b\s*([\s\S]*?)\s*--\>/g;return{mb:function(b,c,e){c.isTemplateRewritten(b,e)||c.rewriteTemplate(b,function(b){return a.Z.zb(b,c)},e)},zb:function(a,g){return a.replace(c,function(a,c,d,f,i,l,q){return b(q,c,g)}).replace(d,function(a,c){return b(c,"<\!-- ko --\>",g)})},Za:function(b){return a.s.na(function(c,
e){c.nextSibling&&a.ya(c.nextSibling,b,e)})}}}();a.b("templateRewriting",a.Z);a.b("templateRewriting.applyMemoizedBindingsToNextSibling",a.Z.Za);(function(){a.l={};a.l.i=function(a){this.i=a};a.l.i.prototype.text=function(){var b=a.a.o(this.i),b="script"===b?"text":"textarea"===b?"value":"innerHTML";if(0==arguments.length)return this.i[b];var c=arguments[0];"innerHTML"===b?a.a.Y(this.i,c):this.i[b]=c};a.l.i.prototype.data=function(b){if(1===arguments.length)return a.a.f.get(this.i,"templateSourceData_"+
b);a.a.f.set(this.i,"templateSourceData_"+b,arguments[1])};a.l.M=function(a){this.i=a};a.l.M.prototype=new a.l.i;a.l.M.prototype.text=function(){if(0==arguments.length){var b=a.a.f.get(this.i,"__ko_anon_template__")||{};b.ua===n&&b.da&&(b.ua=b.da.innerHTML);return b.ua}a.a.f.set(this.i,"__ko_anon_template__",{ua:arguments[0]})};a.l.i.prototype.nodes=function(){if(0==arguments.length)return(a.a.f.get(this.i,"__ko_anon_template__")||{}).da;a.a.f.set(this.i,"__ko_anon_template__",{da:arguments[0]})};
a.b("templateSources",a.l);a.b("templateSources.domElement",a.l.i);a.b("templateSources.anonymousTemplate",a.l.M)})();(function(){function b(b,c,d){for(var f,c=a.e.nextSibling(c);b&&(f=b)!==c;)b=a.e.nextSibling(f),(1===f.nodeType||8===f.nodeType)&&d(f)}function c(c,d){if(c.length){var f=c[0],g=c[c.length-1];b(f,g,function(b){a.xa(d,b)});b(f,g,function(b){a.s.Wa(b,[d])})}}function d(a){return a.nodeType?a:0<a.length?a[0]:s}function f(b,f,j,k,i){var i=i||{},l=b&&d(b),l=l&&l.ownerDocument,q=i.templateEngine||
g;a.Z.mb(j,q,l);j=q.renderTemplate(j,k,i,l);("number"!=typeof j.length||0<j.length&&"number"!=typeof j[0].nodeType)&&m(Error("Template engine must return an array of DOM nodes"));l=t;switch(f){case "replaceChildren":a.e.X(b,j);l=p;break;case "replaceNode":a.a.Na(b,j);l=p;break;case "ignoreTargetNode":break;default:m(Error("Unknown renderMode: "+f))}l&&(c(j,k),i.afterRender&&i.afterRender(j,k.$data));return j}var g;a.ra=function(b){b!=n&&!(b instanceof a.t)&&m(Error("templateEngine must inherit from ko.templateEngine"));
g=b};a.qa=function(b,c,j,k,i){j=j||{};(j.templateEngine||g)==n&&m(Error("Set a template engine before calling renderTemplate"));i=i||"replaceChildren";if(k){var l=d(k);return a.h(function(){var g=c&&c instanceof a.z?c:new a.z(a.a.d(c)),o="function"==typeof b?b(g.$data):b,g=f(k,i,o,g,j);"replaceNode"==i&&(k=g,l=d(k))},s,{disposeWhen:function(){return!l||!a.a.fa(l)},disposeWhenNodeIsRemoved:l&&"replaceNode"==i?l.parentNode:l})}return a.s.na(function(d){a.qa(b,c,j,d,"replaceNode")})};a.Fb=function(b,
d,g,k,i){function l(a,b){c(b,o);g.afterRender&&g.afterRender(b,a)}function q(c,d){var h="function"==typeof b?b(c):b;o=i.createChildContext(a.a.d(c));o.$index=d;return f(s,"ignoreTargetNode",h,o,g)}var o;return a.h(function(){var b=a.a.d(d)||[];"undefined"==typeof b.length&&(b=[b]);b=a.a.aa(b,function(b){return g.includeDestroyed||b===n||b===s||!a.a.d(b._destroy)});a.a.Oa(k,b,q,g,l)},s,{disposeWhenNodeIsRemoved:k})};a.c.template={init:function(b,c){var d=a.a.d(c());if("string"!=typeof d&&!d.name&&
(1==b.nodeType||8==b.nodeType))d=1==b.nodeType?b.childNodes:a.e.childNodes(b),d=a.a.Ab(d),(new a.l.M(b)).nodes(d);return{controlsDescendantBindings:p}},update:function(b,c,d,f,g){c=a.a.d(c());f=p;"string"==typeof c?d=c:(d=c.name,"if"in c&&(f=f&&a.a.d(c["if"])),"ifnot"in c&&(f=f&&!a.a.d(c.ifnot)));var l=s;"object"===typeof c&&"foreach"in c?l=a.Fb(d||b,f&&c.foreach||[],c,b,g):f?(g="object"==typeof c&&"data"in c?g.createChildContext(a.a.d(c.data)):g,l=a.qa(d||b,g,c,b)):a.e.ha(b);g=l;(c=a.a.f.get(b,"__ko__templateSubscriptionDomDataKey__"))&&
"function"==typeof c.A&&c.A();a.a.f.set(b,"__ko__templateSubscriptionDomDataKey__",g)}};a.g.D.template=function(b){b=a.g.W(b);return 1==b.length&&b[0].unknown||a.g.wb(b,"name")?s:"This template engine does not support anonymous templates nested within its templates"};a.e.C.template=p})();a.b("setTemplateEngine",a.ra);a.b("renderTemplate",a.qa);(function(){a.a.O=function(b,c,d){if(d===n)return a.a.O(b,c,1)||a.a.O(b,c,10)||a.a.O(b,c,Number.MAX_VALUE);for(var b=b||[],c=c||[],f=b,g=c,e=[],h=0;h<=g.length;h++)e[h]=
[];for(var h=0,j=Math.min(f.length,d);h<=j;h++)e[0][h]=h;h=1;for(j=Math.min(g.length,d);h<=j;h++)e[h][0]=h;for(var j=f.length,k,i=g.length,h=1;h<=j;h++){k=Math.max(1,h-d);for(var l=Math.min(i,h+d);k<=l;k++)e[k][h]=f[h-1]===g[k-1]?e[k-1][h-1]:Math.min(e[k-1][h]===n?Number.MAX_VALUE:e[k-1][h]+1,e[k][h-1]===n?Number.MAX_VALUE:e[k][h-1]+1)}d=b.length;f=c.length;g=[];h=e[f][d];if(h===n)e=s;else{for(;0<d||0<f;){j=e[f][d];i=0<f?e[f-1][d]:h+1;l=0<d?e[f][d-1]:h+1;k=0<f&&0<d?e[f-1][d-1]:h+1;if(i===n||i<j-1)i=
h+1;if(l===n||l<j-1)l=h+1;k<j-1&&(k=h+1);i<=l&&i<k?(g.push({status:"added",value:c[f-1]}),f--):(l<i&&l<k?g.push({status:"deleted",value:b[d-1]}):(g.push({status:"retained",value:b[d-1]}),f--),d--)}e=g.reverse()}return e}})();a.b("utils.compareArrays",a.a.O);(function(){function b(a){if(2<a.length){for(var b=a[0],c=a[a.length-1],e=[b];b!==c;){b=b.nextSibling;if(!b)return;e.push(b)}Array.prototype.splice.apply(a,[0,a.length].concat(e))}}function c(c,f,g,e,h){var j=[],c=a.h(function(){var c=f(g,h)||
[];0<j.length&&(b(j),a.a.Na(j,c),e&&e(g,c));j.splice(0,j.length);a.a.N(j,c)},s,{disposeWhenNodeIsRemoved:c,disposeWhen:function(){return 0==j.length||!a.a.fa(j[0])}});return{xb:j,h:c}}a.a.Oa=function(d,f,g,e,h){for(var f=f||[],e=e||{},j=a.a.f.get(d,"setDomNodeChildrenFromArrayMapping_lastMappingResult")===n,k=a.a.f.get(d,"setDomNodeChildrenFromArrayMapping_lastMappingResult")||[],i=a.a.T(k,function(a){return a.$a}),l=a.a.O(i,f),f=[],q=0,o=[],v=0,i=[],u=s,r=0,w=l.length;r<w;r++)switch(l[r].status){case "retained":var y=
k[q];y.qb(v);v=f.push(y);0<y.P.length&&(u=y.P[y.P.length-1]);q++;break;case "deleted":k[q].h.A();b(k[q].P);a.a.v(k[q].P,function(a){o.push({element:a,index:r,value:l[r].value});u=a});q++;break;case "added":for(var y=l[r].value,x=a.m(v),v=c(d,g,y,h,x),C=v.xb,v=f.push({$a:l[r].value,P:C,h:v.h,qb:x}),z=0,B=C.length;z<B;z++){var D=C[z];i.push({element:D,index:r,value:l[r].value});u==s?a.e.Ka(d,D):a.e.Fa(d,D,u);u=D}h&&h(y,C,x)}a.a.v(o,function(b){a.F(b.element)});g=t;if(!j){if(e.afterAdd)for(r=0;r<i.length;r++)e.afterAdd(i[r].element,
i[r].index,i[r].value);if(e.beforeRemove){for(r=0;r<o.length;r++)e.beforeRemove(o[r].element,o[r].index,o[r].value);g=p}}if(!g&&o.length)for(r=0;r<o.length;r++)e=o[r].element,e.parentNode&&e.parentNode.removeChild(e);a.a.f.set(d,"setDomNodeChildrenFromArrayMapping_lastMappingResult",f)}})();a.b("utils.setDomNodeChildrenFromArrayMapping",a.a.Oa);a.q=function(){this.allowTemplateRewriting=t};a.q.prototype=new a.t;a.q.prototype.renderTemplateSource=function(b){var c=!(9>a.a.ja)&&b.nodes?b.nodes():s;
if(c)return a.a.L(c.cloneNode(p).childNodes);b=b.text();return a.a.pa(b)};a.q.K=new a.q;a.ra(a.q.K);a.b("nativeTemplateEngine",a.q);(function(){a.ma=function(){var a=this.vb=function(){if("undefined"==typeof jQuery||!jQuery.tmpl)return 0;try{if(0<=jQuery.tmpl.tag.tmpl.open.toString().indexOf("__"))return 2}catch(a){}return 1}();this.renderTemplateSource=function(b,f,g){g=g||{};2>a&&m(Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later."));var e=b.data("precompiled");
e||(e=b.text()||"",e=jQuery.template(s,"{{ko_with $item.koBindingContext}}"+e+"{{/ko_with}}"),b.data("precompiled",e));b=[f.$data];f=jQuery.extend({koBindingContext:f},g.templateOptions);f=jQuery.tmpl(e,b,f);f.appendTo(document.createElement("div"));jQuery.fragments={};return f};this.createJavaScriptEvaluatorBlock=function(a){return"{{ko_code ((function() { return "+a+" })()) }}"};this.addTemplate=function(a,b){document.write("<script type='text/html' id='"+a+"'>"+b+"<\/script>")};0<a&&(jQuery.tmpl.tag.ko_code=
{open:"__.push($1 || '');"},jQuery.tmpl.tag.ko_with={open:"with($1) {",close:"} "})};a.ma.prototype=new a.t;var b=new a.ma;0<b.vb&&a.ra(b);a.b("jqueryTmplTemplateEngine",a.ma)})()}"function"===typeof require&&"object"===typeof exports&&"object"===typeof module?E(module.exports||exports):"function"===typeof define&&define.amd?define(["exports"],E):E(window.ko={});p;
})(window,document,navigator);

```

`LibreHardwareMonitor/Resources/Web/js/knockout.mapping-latest.js`:

```js
// Knockout Mapping plugin v2.1.2
// (c) 2012 Steven Sanderson, Roy Jacobs - http://knockoutjs.com/
// License: MIT (http://www.opensource.org/licenses/mit-license.php)

(function (factory) {
	// Module systems magic dance.

	if (typeof require === "function" && typeof exports === "object" && typeof module === "object") {
		// CommonJS or Node: hard-coded dependency on "knockout"
		factory(require("knockout"), exports);
	} else if (typeof define === "function" && define["amd"]) {
		// AMD anonymous module with hard-coded dependency on "knockout"
		define(["knockout", "exports"], factory);
	} else {
		// <script> tag: use the global `ko` object, attaching a `mapping` property
		factory(ko, ko.mapping = {});
	}
}(function (ko, exports) {
	var DEBUG=true;
	var mappingProperty = "__ko_mapping__";
	var realKoDependentObservable = ko.dependentObservable;
	var mappingNesting = 0;
	var dependentObservables;
	var visitedObjects;

	var _defaultOptions = {
		include: ["_destroy"],
		ignore: [],
		copy: []
	};
	var defaultOptions = _defaultOptions;

	exports.isMapped = function (viewModel) {
		var unwrapped = ko.utils.unwrapObservable(viewModel);
		return unwrapped && unwrapped[mappingProperty];
	}

	exports.fromJS = function (jsObject /*, inputOptions, target*/ ) {
		if (arguments.length == 0) throw new Error("When calling ko.fromJS, pass the object you want to convert.");

		// When mapping is completed, even with an exception, reset the nesting level
		window.setTimeout(function () {
			mappingNesting = 0;
		}, 0);

		if (!mappingNesting++) {
			dependentObservables = [];
			visitedObjects = new objectLookup();
		}

		var options;
		var target;

		if (arguments.length == 2) {
			if (arguments[1][mappingProperty]) {
				target = arguments[1];
			} else {
				options = arguments[1];
			}
		}
		if (arguments.length == 3) {
			options = arguments[1];
			target = arguments[2];
		}

		if (target) {
			options = mergeOptions(target[mappingProperty], options);
		} else {
			options = mergeOptions(options);
		}
		options.mappedProperties = options.mappedProperties || {};

		var result = updateViewModel(target, jsObject, options);
		if (target) {
			result = target;
		}

		// Evaluate any dependent observables that were proxied.
		// Do this in a timeout to defer execution. Basically, any user code that explicitly looks up the DO will perform the first evaluation. Otherwise,
		// it will be done by this code.
		if (!--mappingNesting) {
			window.setTimeout(function () {
				while (dependentObservables.length) {
					var DO = dependentObservables.pop();
					if (DO) DO();
				}
			}, 0);
		}

		// Save any new mapping options in the view model, so that updateFromJS can use them later.
		result[mappingProperty] = mergeOptions(result[mappingProperty], options);

		return result;
	};

	exports.fromJSON = function (jsonString /*, options, target*/ ) {
		var parsed = ko.utils.parseJson(jsonString);
		arguments[0] = parsed;
		return exports.fromJS.apply(this, arguments);
	};

	exports.updateFromJS = function (viewModel) {
		throw new Error("ko.mapping.updateFromJS, use ko.mapping.fromJS instead. Please note that the order of parameters is different!");
	};

	exports.updateFromJSON = function (viewModel) {
		throw new Error("ko.mapping.updateFromJSON, use ko.mapping.fromJSON instead. Please note that the order of parameters is different!");
	};

	exports.toJS = function (rootObject, options) {
		if (arguments.length == 0) throw new Error("When calling ko.mapping.toJS, pass the object you want to convert.");
		// Merge in the options used in fromJS
		options = mergeOptions(rootObject[mappingProperty], options);

		// We just unwrap everything at every level in the object graph
		return visitModel(rootObject, function (x) {
			return ko.utils.unwrapObservable(x)
		}, options);
	};

	exports.toJSON = function (rootObject, options) {
		var plainJavaScriptObject = exports.toJS(rootObject, options);
		return ko.utils.stringifyJson(plainJavaScriptObject);
	};

	exports.visitModel = function (rootObject, callback, options) {
		if (arguments.length == 0) throw new Error("When calling ko.mapping.visitModel, pass the object you want to visit.");
		// Merge in the options used in fromJS
		options = mergeOptions(rootObject[mappingProperty], options);

		return visitModel(rootObject, callback, options);
	};

	exports.defaultOptions = function () {
		if (arguments.length > 0) {
			defaultOptions = arguments[0];
		} else {
			return defaultOptions;
		}
	};

	exports.resetDefaultOptions = function () {
		defaultOptions = {
			include: _defaultOptions.include.slice(0),
			ignore: _defaultOptions.ignore.slice(0),
			copy: _defaultOptions.copy.slice(0)
		};
	};

	exports.getType = function(x) {
		if ((x) && (typeof (x) === "object")) {
			if (x.constructor == (new Date).constructor) return "date";
			if (x.constructor == (new Array).constructor) return "array";
		}
		return typeof x;
	}

	function extendOptionsArray(distArray, sourceArray) {
		return ko.utils.arrayGetDistinctValues(
			ko.utils.arrayPushAll(distArray, sourceArray)
		);
	}

	function extendOptionsObject(target, options) {
		var type = exports.getType,
			name, special = { "include": true, "ignore": true, "copy": true },
			t, o, i = 1, l = arguments.length;
		if (type(target) !== "object") {
			target = {};
		}
		for (; i < l; i++) {
			options = arguments[i];
			if (type(options) !== "object") {
				options = {};
			}
			for (name in options) {
				t = target[name]; o = options[name];
				if (name !== "constructor" && special[name] && type(o) !== "array") {
					if (type(o) !== "string") {
						throw new Error("ko.mapping.defaultOptions()." + name + " should be an array or string.");
					}
					o = [o];
				}
				switch (type(o)) {
				case "object": // Recurse
					t = type(t) === "object" ? t : {};
					target[name] = extendOptionsObject(t, o);
					break;
				case "array":
					t = type(t) === "array" ? t : [];
					target[name] = extendOptionsArray(t, o);
					break;
				default:
					target[name] = o;
				}
			}
		}
		return target;
	}

	function mergeOptions() {
		var options = ko.utils.arrayPushAll([{}, defaultOptions], arguments); // Always use empty object as target to avoid changing default options
		options = extendOptionsObject.apply(this, options);
		return options;
	}

	// When using a 'create' callback, we proxy the dependent observable so that it doesn't immediately evaluate on creation.
	// The reason is that the dependent observables in the user-specified callback may contain references to properties that have not been mapped yet.
	function withProxyDependentObservable(dependentObservables, callback) {
		var localDO = ko.dependentObservable;
		ko.dependentObservable = function (read, owner, options) {
			options = options || {};

			if (read && typeof read == "object") { // mirrors condition in knockout implementation of DO's
				options = read;
			}

			var realDeferEvaluation = options.deferEvaluation;

			var isRemoved = false;

			// We wrap the original dependent observable so that we can remove it from the 'dependentObservables' list we need to evaluate after mapping has
			// completed if the user already evaluated the DO themselves in the meantime.
			var wrap = function (DO) {
				var wrapped = realKoDependentObservable({
					read: function () {
						if (!isRemoved) {
							ko.utils.arrayRemoveItem(dependentObservables, DO);
							isRemoved = true;
						}
						return DO.apply(DO, arguments);
					},
					write: function (val) {
						return DO(val);
					},
					deferEvaluation: true
				});
				if(DEBUG) wrapped._wrapper = true;
				return wrapped;
			};
			
			options.deferEvaluation = true; // will either set for just options, or both read/options.
			var realDependentObservable = new realKoDependentObservable(read, owner, options);

			if (!realDeferEvaluation) {
				realDependentObservable = wrap(realDependentObservable);
				dependentObservables.push(realDependentObservable);
			}

			return realDependentObservable;
		}
		ko.dependentObservable.fn = realKoDependentObservable.fn;
		ko.computed = ko.dependentObservable;
		var result = callback();
		ko.dependentObservable = localDO;
		ko.computed = ko.dependentObservable;
		return result;
	}

	function updateViewModel(mappedRootObject, rootObject, options, parentName, parent, parentPropertyName) {
		var isArray = ko.utils.unwrapObservable(rootObject) instanceof Array;

		// If nested object was already mapped previously, take the options from it
		if (parentName !== undefined && exports.isMapped(mappedRootObject)) {
			options = ko.utils.unwrapObservable(mappedRootObject)[mappingProperty];
			parentName = "";
			parentPropertyName = "";
		}

		parentName = parentName || "";
		parentPropertyName = parentPropertyName || "";

		var callbackParams = {
			data: rootObject,
			parent: parent
		};

		var getCallback = function (name) {
			var callback;
			if (parentName === "") {
				callback = options[name];
			} else if (callback = options[parentName]) {
				callback = callback[name]
			}
			return callback;
		};

		var hasCreateCallback = function () {
			return getCallback("create") instanceof Function;
		};

		var createCallback = function (data) {
			return withProxyDependentObservable(dependentObservables, function () {
				return getCallback("create")({
					data: data || callbackParams.data,
					parent: callbackParams.parent
				});
			});
		};

		var hasUpdateCallback = function () {
			return getCallback("update") instanceof Function;
		};

		var updateCallback = function (obj, data) {
			var params = {
				data: data || callbackParams.data,
				parent: callbackParams.parent,
				target: ko.utils.unwrapObservable(obj)
			};

			if (ko.isWriteableObservable(obj)) {
				params.observable = obj;
			}

			return getCallback("update")(params);
		}

		var alreadyMapped = visitedObjects.get(rootObject);
		if (alreadyMapped) {
			return alreadyMapped;
		}

		if (!isArray) {
			// For atomic types, do a direct update on the observable
			if (!canHaveProperties(rootObject)) {
				switch (exports.getType(rootObject)) {
				case "function":
					if (hasUpdateCallback()) {
						if (ko.isWriteableObservable(rootObject)) {
							rootObject(updateCallback(rootObject));
							mappedRootObject = rootObject;
						} else {
							mappedRootObject = updateCallback(rootObject);
						}
					} else {
						mappedRootObject = rootObject;
					}
					break;
				default:
					if (ko.isWriteableObservable(mappedRootObject)) {
						if (hasUpdateCallback()) {
							mappedRootObject(updateCallback(mappedRootObject));
						} else {
							mappedRootObject(ko.utils.unwrapObservable(rootObject));
						}
					} else {
						if (hasCreateCallback()) {
							mappedRootObject = createCallback();
						} else {
							mappedRootObject = ko.observable(ko.utils.unwrapObservable(rootObject));
						}

						if (hasUpdateCallback()) {
							mappedRootObject(updateCallback(mappedRootObject));
						}
					}
					break;
				}

			} else {
				mappedRootObject = ko.utils.unwrapObservable(mappedRootObject);
				if (!mappedRootObject) {
					if (hasCreateCallback()) {
						var result = createCallback();

						if (hasUpdateCallback()) {
							result = updateCallback(result);
						}

						return result;
					} else {
						if (hasUpdateCallback()) {
							return updateCallback(result);
						}

						mappedRootObject = {};
					}
				}

				if (hasUpdateCallback()) {
					mappedRootObject = updateCallback(mappedRootObject);
				}

				visitedObjects.save(rootObject, mappedRootObject);

				// For non-atomic types, visit all properties and update recursively
				visitPropertiesOrArrayEntries(rootObject, function (indexer) {
					var fullPropertyName = getPropertyName(parentPropertyName, rootObject, indexer);

					if (ko.utils.arrayIndexOf(options.ignore, fullPropertyName) != -1) {
						return;
					}

					if (ko.utils.arrayIndexOf(options.copy, fullPropertyName) != -1) {
						mappedRootObject[indexer] = rootObject[indexer];
						return;
					}

					// In case we are adding an already mapped property, fill it with the previously mapped property value to prevent recursion.
					// If this is a property that was generated by fromJS, we should use the options specified there
					var prevMappedProperty = visitedObjects.get(rootObject[indexer]);
					var value = prevMappedProperty || updateViewModel(mappedRootObject[indexer], rootObject[indexer], options, indexer, mappedRootObject, fullPropertyName);

					if (ko.isWriteableObservable(mappedRootObject[indexer])) {
						mappedRootObject[indexer](ko.utils.unwrapObservable(value));
					} else {
						mappedRootObject[indexer] = value;
					}

					options.mappedProperties[fullPropertyName] = true;
				});
			}
		} else {
			var changes = [];

			var hasKeyCallback = getCallback("key") instanceof Function;
			var keyCallback = hasKeyCallback ? getCallback("key") : function (x) {
				return x;
			};
			if (!ko.isObservable(mappedRootObject)) {
				// When creating the new observable array, also add a bunch of utility functions that take the 'key' of the array items into account.
				mappedRootObject = ko.observableArray([]);

				mappedRootObject.mappedRemove = function (valueOrPredicate) {
					var predicate = typeof valueOrPredicate == "function" ? valueOrPredicate : function (value) {
							return value === keyCallback(valueOrPredicate);
						};
					return mappedRootObject.remove(function (item) {
						return predicate(keyCallback(item));
					});
				}

				mappedRootObject.mappedRemoveAll = function (arrayOfValues) {
					var arrayOfKeys = filterArrayByKey(arrayOfValues, keyCallback);
					return mappedRootObject.remove(function (item) {
						return ko.utils.arrayIndexOf(arrayOfKeys, keyCallback(item)) != -1;
					});
				}

				mappedRootObject.mappedDestroy = function (valueOrPredicate) {
					var predicate = typeof valueOrPredicate == "function" ? valueOrPredicate : function (value) {
							return value === keyCallback(valueOrPredicate);
						};
					return mappedRootObject.destroy(function (item) {
						return predicate(keyCallback(item));
					});
				}

				mappedRootObject.mappedDestroyAll = function (arrayOfValues) {
					var arrayOfKeys = filterArrayByKey(arrayOfValues, keyCallback);
					return mappedRootObject.destroy(function (item) {
						return ko.utils.arrayIndexOf(arrayOfKeys, keyCallback(item)) != -1;
					});
				}

				mappedRootObject.mappedIndexOf = function (item) {
					var keys = filterArrayByKey(mappedRootObject(), keyCallback);
					var key = keyCallback(item);
					return ko.utils.arrayIndexOf(keys, key);
				}

				mappedRootObject.mappedCreate = function (value) {
					if (mappedRootObject.mappedIndexOf(value) !== -1) {
						throw new Error("There already is an object with the key that you specified.");
					}

					var item = hasCreateCallback() ? createCallback(value) : value;
					if (hasUpdateCallback()) {
						var newValue = updateCallback(item, value);
						if (ko.isWriteableObservable(item)) {
							item(newValue);
						} else {
							item = newValue;
						}
					}
					mappedRootObject.push(item);
					return item;
				}
			}

			var currentArrayKeys = filterArrayByKey(ko.utils.unwrapObservable(mappedRootObject), keyCallback).sort();
			var newArrayKeys = filterArrayByKey(rootObject, keyCallback);
			if (hasKeyCallback) newArrayKeys.sort();
			var editScript = ko.utils.compareArrays(currentArrayKeys, newArrayKeys);

			var ignoreIndexOf = {};

			var newContents = [];
			for (var i = 0, j = editScript.length; i < j; i++) {
				var key = editScript[i];
				var mappedItem;
				var fullPropertyName = getPropertyName(parentPropertyName, rootObject, i);
				switch (key.status) {
				case "added":
					var item = getItemByKey(ko.utils.unwrapObservable(rootObject), key.value, keyCallback);
					mappedItem = updateViewModel(undefined, item, options, parentName, mappedRootObject, fullPropertyName);
					if(!hasCreateCallback()) {
						mappedItem = ko.utils.unwrapObservable(mappedItem);
					}

					var index = ignorableIndexOf(ko.utils.unwrapObservable(rootObject), item, ignoreIndexOf);
					newContents[index] = mappedItem;
					ignoreIndexOf[index] = true;
					break;
				case "retained":
					var item = getItemByKey(ko.utils.unwrapObservable(rootObject), key.value, keyCallback);
					mappedItem = getItemByKey(mappedRootObject, key.value, keyCallback);
					updateViewModel(mappedItem, item, options, parentName, mappedRootObject, fullPropertyName);

					var index = ignorableIndexOf(ko.utils.unwrapObservable(rootObject), item, ignoreIndexOf);
					newContents[index] = mappedItem;
					ignoreIndexOf[index] = true;
					break;
				case "deleted":
					mappedItem = getItemByKey(mappedRootObject, key.value, keyCallback);
					break;
				}

				changes.push({
					event: key.status,
					item: mappedItem
				});
			}

			mappedRootObject(newContents);

			var arrayChangedCallback = getCallback("arrayChanged");
			if (arrayChangedCallback instanceof Function) {
				ko.utils.arrayForEach(changes, function (change) {
					arrayChangedCallback(change.event, change.item);
				});
			}
		}

		return mappedRootObject;
	}

	function ignorableIndexOf(array, item, ignoreIndices) {
		for (var i = 0, j = array.length; i < j; i++) {
			if (ignoreIndices[i] === true) continue;
			if (array[i] === item) return i;
		}
		return null;
	}

	function mapKey(item, callback) {
		var mappedItem;
		if (callback) mappedItem = callback(item);
		if (exports.getType(mappedItem) === "undefined") mappedItem = item;

		return ko.utils.unwrapObservable(mappedItem);
	}

	function getItemByKey(array, key, callback) {
		var filtered = ko.utils.arrayFilter(ko.utils.unwrapObservable(array), function (item) {
			return mapKey(item, callback) === key;
		});

		if (filtered.length == 0) throw new Error("When calling ko.update*, the key '" + key + "' was not found!");
		if ((filtered.length > 1) && (canHaveProperties(filtered[0]))) throw new Error("When calling ko.update*, the key '" + key + "' was not unique!");

		return filtered[0];
	}

	function filterArrayByKey(array, callback) {
		return ko.utils.arrayMap(ko.utils.unwrapObservable(array), function (item) {
			if (callback) {
				return mapKey(item, callback);
			} else {
				return item;
			}
		});
	}

	function visitPropertiesOrArrayEntries(rootObject, visitorCallback) {
		if (rootObject instanceof Array) {
			for (var i = 0; i < rootObject.length; i++)
			visitorCallback(i);
		} else {
			for (var propertyName in rootObject)
			visitorCallback(propertyName);
		}
	};

	function canHaveProperties(object) {
		var type = exports.getType(object);
		return (type === "object" || type === "array") && (object !== null) && (type !== "undefined");
	}

	// Based on the parentName, this creates a fully classified name of a property

	function getPropertyName(parentName, parent, indexer) {
		var propertyName = parentName || "";
		if (parent instanceof Array) {
			if (parentName) {
				propertyName += "[" + indexer + "]";
			}
		} else {
			if (parentName) {
				propertyName += ".";
			}
			propertyName += indexer;
		}
		return propertyName;
	}

	function visitModel(rootObject, callback, options, parentName, fullParentName) {
		// If nested object was already mapped previously, take the options from it
		if (parentName !== undefined && exports.isMapped(rootObject)) {
			//options = ko.utils.unwrapObservable(rootObject)[mappingProperty];
			options = mergeOptions(ko.utils.unwrapObservable(rootObject)[mappingProperty], options);
			parentName = "";
		}

		if (parentName === undefined) { // the first call
			visitedObjects = new objectLookup();
		}

		parentName = parentName || "";

		var mappedRootObject;
		var unwrappedRootObject = ko.utils.unwrapObservable(rootObject);
		if (!canHaveProperties(unwrappedRootObject)) {
			return callback(rootObject, fullParentName);
		} else {
			// Only do a callback, but ignore the results
			callback(rootObject, fullParentName);
			mappedRootObject = unwrappedRootObject instanceof Array ? [] : {};
		}

		visitedObjects.save(rootObject, mappedRootObject);

		var origFullParentName = fullParentName;
		visitPropertiesOrArrayEntries(unwrappedRootObject, function (indexer) {
			if (options.ignore && ko.utils.arrayIndexOf(options.ignore, indexer) != -1) return;

			var propertyValue = unwrappedRootObject[indexer];
			var fullPropertyName = getPropertyName(parentName, unwrappedRootObject, indexer);
			
			// If we don't want to explicitly copy the unmapped property...
			if (ko.utils.arrayIndexOf(options.copy, indexer) === -1) {
				// ...find out if it's a property we want to explicitly include
				if (ko.utils.arrayIndexOf(options.include, indexer) === -1) {
					// Options contains all the properties that were part of the original object.
					// If a property does not exist, and it is not because it is part of an array (e.g. "myProp[3]"), then it should not be unmapped.
					if (options.mappedProperties && !options.mappedProperties[fullPropertyName] && !(unwrappedRootObject instanceof Array)) {
						return;
					}
				}
			}

			fullParentName = getPropertyName(origFullParentName, unwrappedRootObject, indexer);
			
			var propertyType = exports.getType(ko.utils.unwrapObservable(propertyValue));
			switch (propertyType) {
			case "object":
			case "array":
			case "undefined":
				var previouslyMappedValue = visitedObjects.get(propertyValue);
				mappedRootObject[indexer] = (exports.getType(previouslyMappedValue) !== "undefined") ? previouslyMappedValue : visitModel(propertyValue, callback, options, fullPropertyName, fullParentName);
				break;
			default:
				mappedRootObject[indexer] = callback(propertyValue, fullParentName);
			}
		});

		return mappedRootObject;
	}

	function objectLookup() {
		var keys = [];
		var values = [];
		this.save = function (key, value) {
			var existingIndex = ko.utils.arrayIndexOf(keys, key);
			if (existingIndex >= 0) values[existingIndex] = value;
			else {
				keys.push(key);
				values.push(value);
			}
		};
		this.get = function (key) {
			var existingIndex = ko.utils.arrayIndexOf(keys, key);
			return (existingIndex >= 0) ? values[existingIndex] : undefined;
		};
	};
}));
```

`LibreHardwareMonitor/Resources/Web/js/knockout.mapping-latest.min.js`:

```js
// Knockout Mapping plugin v2.1.2
// (c) 2012 Steven Sanderson, Roy Jacobs - http://knockoutjs.com/
// License: MIT (http://www.opensource.org/licenses/mit-license.php)

(function(e){"function"===typeof require&&"object"===typeof exports&&"object"===typeof module?e(require("knockout"),exports):"function"===typeof define&&define.amd?define(["knockout","exports"],e):e(ko,ko.mapping={})})(function(e,f){function J(a,b){var c=f.getType,d,l={include:!0,ignore:!0,copy:!0},h,g,k=1,p=arguments.length;for("object"!==c(a)&&(a={});k<p;k++)for(d in b=arguments[k],"object"!==c(b)&&(b={}),b){h=a[d];g=b[d];if("constructor"!==d&&l[d]&&"array"!==c(g)){if("string"!==c(g))throw Error("ko.mapping.defaultOptions()."+
d+" should be an array or string.");g=[g]}switch(c(g)){case "object":h="object"===c(h)?h:{};a[d]=J(h,g);break;case "array":h="array"===c(h)?h:[];a[d]=e.utils.arrayGetDistinctValues(e.utils.arrayPushAll(h,g));break;default:a[d]=g}}return a}function i(){var a=e.utils.arrayPushAll([{},q],arguments);return a=J.apply(this,a)}function O(a,b){var c=e.dependentObservable;e.dependentObservable=function(b,c,d){d=d||{};b&&"object"==typeof b&&(d=b);var f=d.deferEvaluation,p=!1,z=function(b){return w({read:function(){p||
(e.utils.arrayRemoveItem(a,b),p=!0);return b.apply(b,arguments)},write:function(a){return b(a)},deferEvaluation:!0})};d.deferEvaluation=!0;b=new w(b,c,d);f||(b=z(b),a.push(b));return b};e.dependentObservable.fn=w.fn;e.computed=e.dependentObservable;var d=b();e.dependentObservable=c;e.computed=e.dependentObservable;return d}function C(a,b,c,d,l,h){var g=e.utils.unwrapObservable(b)instanceof Array;void 0!==d&&f.isMapped(a)&&(c=e.utils.unwrapObservable(a)[r],h=d="");var d=d||"",h=h||"",k=function(a){var b;
if(d==="")b=c[a];else if(b=c[d])b=b[a];return b},p=function(){return k("create")instanceof Function},z=function(a){return O(D,function(){return k("create")({data:a||b,parent:l})})},o=function(){return k("update")instanceof Function},m=function(a,c){var d={data:c||b,parent:l,target:e.utils.unwrapObservable(a)};if(e.isWriteableObservable(a))d.observable=a;return k("update")(d)},v=u.get(b);if(v)return v;if(g){var g=[],j=(v=k("key")instanceof Function)?k("key"):function(a){return a};e.isObservable(a)||
(a=e.observableArray([]),a.mappedRemove=function(b){var c=typeof b=="function"?b:function(a){return a===j(b)};return a.remove(function(a){return c(j(a))})},a.mappedRemoveAll=function(b){var c=A(b,j);return a.remove(function(a){return e.utils.arrayIndexOf(c,j(a))!=-1})},a.mappedDestroy=function(b){var c=typeof b=="function"?b:function(a){return a===j(b)};return a.destroy(function(a){return c(j(a))})},a.mappedDestroyAll=function(b){var c=A(b,j);return a.destroy(function(a){return e.utils.arrayIndexOf(c,
j(a))!=-1})},a.mappedIndexOf=function(b){var c=A(a(),j),b=j(b);return e.utils.arrayIndexOf(c,b)},a.mappedCreate=function(b){if(a.mappedIndexOf(b)!==-1)throw Error("There already is an object with the key that you specified.");var c=p()?z(b):b;if(o()){b=m(c,b);e.isWriteableObservable(c)?c(b):c=b}a.push(c);return c});var n=A(e.utils.unwrapObservable(a),j).sort(),i=A(b,j);v&&i.sort();for(var v=e.utils.compareArrays(n,i),n={},i=[],q=0,y=v.length;q<y;q++){var x=v[q],s,t=E(h,b,q);switch(x.status){case "added":var B=
F(e.utils.unwrapObservable(b),x.value,j);s=C(void 0,B,c,d,a,t);p()||(s=e.utils.unwrapObservable(s));t=K(e.utils.unwrapObservable(b),B,n);i[t]=s;n[t]=!0;break;case "retained":B=F(e.utils.unwrapObservable(b),x.value,j);s=F(a,x.value,j);C(s,B,c,d,a,t);t=K(e.utils.unwrapObservable(b),B,n);i[t]=s;n[t]=!0;break;case "deleted":s=F(a,x.value,j)}g.push({event:x.status,item:s})}a(i);var w=k("arrayChanged");w instanceof Function&&e.utils.arrayForEach(g,function(a){w(a.event,a.item)})}else if(G(b)){a=e.utils.unwrapObservable(a);
if(!a){if(p())return n=z(),o()&&(n=m(n)),n;if(o())return m(n);a={}}o()&&(a=m(a));u.save(b,a);L(b,function(d){var f=E(h,b,d);if(e.utils.arrayIndexOf(c.ignore,f)==-1)if(e.utils.arrayIndexOf(c.copy,f)!=-1)a[d]=b[d];else{var g=u.get(b[d])||C(a[d],b[d],c,d,a,f);if(e.isWriteableObservable(a[d]))a[d](e.utils.unwrapObservable(g));else a[d]=g;c.mappedProperties[f]=true}})}else switch(f.getType(b)){case "function":o()?e.isWriteableObservable(b)?(b(m(b)),a=b):a=m(b):a=b;break;default:e.isWriteableObservable(a)?
o()?a(m(a)):a(e.utils.unwrapObservable(b)):(a=p()?z():e.observable(e.utils.unwrapObservable(b)),o()&&a(m(a)))}return a}function K(a,b,c){for(var d=0,e=a.length;d<e;d++)if(!0!==c[d]&&a[d]===b)return d;return null}function M(a,b){var c;b&&(c=b(a));"undefined"===f.getType(c)&&(c=a);return e.utils.unwrapObservable(c)}function F(a,b,c){a=e.utils.arrayFilter(e.utils.unwrapObservable(a),function(a){return M(a,c)===b});if(0==a.length)throw Error("When calling ko.update*, the key '"+b+"' was not found!");
if(1<a.length&&G(a[0]))throw Error("When calling ko.update*, the key '"+b+"' was not unique!");return a[0]}function A(a,b){return e.utils.arrayMap(e.utils.unwrapObservable(a),function(a){return b?M(a,b):a})}function L(a,b){if(a instanceof Array)for(var c=0;c<a.length;c++)b(c);else for(c in a)b(c)}function G(a){var b=f.getType(a);return("object"===b||"array"===b)&&null!==a&&"undefined"!==b}function E(a,b,c){var d=a||"";b instanceof Array?a&&(d+="["+c+"]"):(a&&(d+="."),d+=c);return d}function H(a,b,
c,d,l){void 0!==d&&f.isMapped(a)&&(c=i(e.utils.unwrapObservable(a)[r],c),d="");void 0===d&&(u=new N);var d=d||"",h,g=e.utils.unwrapObservable(a);if(!G(g))return b(a,l);b(a,l);h=g instanceof Array?[]:{};u.save(a,h);var k=l;L(g,function(a){if(!(c.ignore&&e.utils.arrayIndexOf(c.ignore,a)!=-1)){var i=g[a],o=E(d,g,a);if(!(e.utils.arrayIndexOf(c.copy,a)===-1&&e.utils.arrayIndexOf(c.include,a)===-1&&c.mappedProperties&&!c.mappedProperties[o]&&!(g instanceof Array))){l=E(k,g,a);switch(f.getType(e.utils.unwrapObservable(i))){case "object":case "array":case "undefined":var m=
u.get(i);h[a]=f.getType(m)!=="undefined"?m:H(i,b,c,o,l);break;default:h[a]=b(i,l)}}}});return h}function N(){var a=[],b=[];this.save=function(c,d){var f=e.utils.arrayIndexOf(a,c);0<=f?b[f]=d:(a.push(c),b.push(d))};this.get=function(c){c=e.utils.arrayIndexOf(a,c);return 0<=c?b[c]:void 0}}var r="__ko_mapping__",w=e.dependentObservable,I=0,D,u,y={include:["_destroy"],ignore:[],copy:[]},q=y;f.isMapped=function(a){return(a=e.utils.unwrapObservable(a))&&a[r]};f.fromJS=function(a){if(0==arguments.length)throw Error("When calling ko.fromJS, pass the object you want to convert.");
window.setTimeout(function(){I=0},0);I++||(D=[],u=new N);var b,c;2==arguments.length&&(arguments[1][r]?c=arguments[1]:b=arguments[1]);3==arguments.length&&(b=arguments[1],c=arguments[2]);b=c?i(c[r],b):i(b);b.mappedProperties=b.mappedProperties||{};var d=C(c,a,b);c&&(d=c);--I||window.setTimeout(function(){for(;D.length;){var a=D.pop();a&&a()}},0);d[r]=i(d[r],b);return d};f.fromJSON=function(a){var b=e.utils.parseJson(a);arguments[0]=b;return f.fromJS.apply(this,arguments)};f.updateFromJS=function(){throw Error("ko.mapping.updateFromJS, use ko.mapping.fromJS instead. Please note that the order of parameters is different!");
};f.updateFromJSON=function(){throw Error("ko.mapping.updateFromJSON, use ko.mapping.fromJSON instead. Please note that the order of parameters is different!");};f.toJS=function(a,b){if(0==arguments.length)throw Error("When calling ko.mapping.toJS, pass the object you want to convert.");b=i(a[r],b);return H(a,function(a){return e.utils.unwrapObservable(a)},b)};f.toJSON=function(a,b){var c=f.toJS(a,b);return e.utils.stringifyJson(c)};f.visitModel=function(a,b,c){if(0==arguments.length)throw Error("When calling ko.mapping.visitModel, pass the object you want to visit.");
c=i(a[r],c);return H(a,b,c)};f.defaultOptions=function(){if(0<arguments.length)q=arguments[0];else return q};f.resetDefaultOptions=function(){q={include:y.include.slice(0),ignore:y.ignore.slice(0),copy:y.copy.slice(0)}};f.getType=function(a){if(a&&"object"===typeof a){if(a.constructor==(new Date).constructor)return"date";if(a.constructor==[].constructor)return"array"}return typeof a}});

```

`LibreHardwareMonitor/Resources/Web/js/ohm_web.js`:

```js
/*
 
  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
	Copyright (C) 2012 Prince Samuel <prince.samuel@gmail.com>

*/

ko.bindingHandlers.treeTable = {
  update: function(element, valueAccessor, allBindingsAccessor) {
    var dependency = ko.utils.unwrapObservable(valueAccessor()),
    options = ko.toJS(allBindingsAccessor().treeOptions || {});

    setTimeout(function() { $(element).treeTable(options); }, 0);
  } 
};

var node = function(config, parent) {
  this.parent = parent;
  var _this = this;

  var mappingOptions = {
    Children : {
      create: function(args) {
        return new node(args.data, _this);
      }
      ,
      key: function(data) {
        return ko.utils.unwrapObservable(data.id);
      }
    }
  };

  ko.mapping.fromJS(config, mappingOptions, this);
}

$(function(){
  $.getJSON('data.json', function(data) {
    viewModel = new node(data, undefined);

    (function() {
      function flattenChildren(children, result) {
        ko.utils.arrayForEach(children(), function(child) {
          result.push(child);
          if (child.Children) {
            flattenChildren(child.Children, result);
          }
        });
      }

      viewModel.flattened = ko.dependentObservable(function() {
        var result = []; //root node

        if (viewModel.Children) {
          flattenChildren(viewModel.Children, result);   
        }

        return result;
      });

      viewModel.update = function() {
        $.getJSON('data.json', function(data) {
          ko.mapping.fromJS(data, {}, viewModel);
        });
      }

      viewModel.rate = 3000; //milliseconds
      viewModel.timer = {};

      viewModel.startAuto = function (){
        viewModel.timer = setInterval(viewModel.update, viewModel.rate);
      }

      viewModel.stopAuto = function (){
        clearInterval(viewModel.timer);
      }

      viewModel.auto_refresh = ko.observable(false);
      viewModel.toggleAuto = ko.dependentObservable(function() {
        if (viewModel.auto_refresh())
          viewModel.startAuto();
        else
          viewModel.stopAuto();
      }, viewModel);

    })();

    ko.applyBindings(viewModel);
    $("#tree").treeTable({
      initialState: "expanded",
      clickableNodeNames: true
    });
  });
  $( "#refresh" ).button();
  $( "#auto_refresh" ).button();
  $( "#slider" ).slider({
    value:3,
    min: 1,
    max: 10,
    slide: function( event, ui ) {
      viewModel.rate = ui.value * 1000;
      if (viewModel.auto_refresh()) {
        //reset the timer
        viewModel.stopAuto();
        viewModel.startAuto();
      }
      $( "#lbl" ).text( ui.value + "s");
    }
  });
  $( "#lbl" ).text( $( "#slider" ).slider( "value" ) + "s");

});



```

`LibreHardwareMonitor/Resources/app.manifest`:

```manifest
<?xml version="1.0" encoding="utf-8"?>
<asmv1:assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1" 
  xmlns:asmv1="urn:schemas-microsoft-com:asm.v1" 
  xmlns:asmv2="urn:schemas-microsoft-com:asm.v2"
  xmlns:asmv3="urn:schemas-microsoft-com:asm.v3"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v2">
    <security>
      <requestedPrivileges xmlns="urn:schemas-microsoft-com:asm.v3">
        <requestedExecutionLevel level="requireAdministrator" uiAccess="false" />
      </requestedPrivileges>
    </security>
  </trustInfo>
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- Windows 10 -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
      <!-- Windows 8.1 -->
      <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
      <!-- Windows Vista -->
      <supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}"/>
      <!-- Windows 7 -->
      <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
      <!-- Windows 8 -->
      <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
    </application>
  </compatibility>
  <asmv3:application>
    <asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">
      <dpiAware>true</dpiAware>
    </asmv3:windowsSettings>
  </asmv3:application>
</asmv1:assembly>

```

`LibreHardwareMonitor/TestScripts/LiquidCool.py`:

```py
################################################################
# Install:
# * python -m pip install colorama
# * python -m pip install requests
#
# Usage:
# * MAKE SURE YOU READ THE WARNING
# * python LiquidCool.py
#
# Description:
# This script implements a simple load based control of two fans
# It first saves the original Fan settings, then starts 
# monitoring the CPU and GPU load. It integrates those values
# to dampen the value changes somewhat. It then uses the maximum
# of the two values to set the fan speeds.
#
# Warning: This script is written as an example and may or may 
# not kill your PC! Use at your own risk!
################################################################

import colorama
import json, requests
import time
import math

url = 'http://127.0.0.1:8085'

params = dict()

pos = lambda x, y: '\x1b[%d;%dH' % (y, x)
clear = lambda : "\033[2J\033[1;1f"

def getValue(sensorId):
	params=dict(id=sensorId, action="Get")
	resp = requests.post(url=url + "/Sensor", params = params, timeout=10);
	result = json.loads(resp.text);

	if result["result"] != "ok":
		raise Exception("Server returned error:\n " + result["message"].replace("\\n", "\n").replace("\\r", ""))
	if result["value"] == None:
		return None;
	else:
		return float(result["value"])

def setValue(sensorId, sensorValue):
	if sensorValue == None:
		sensorValue = "null"
	params=dict(id=sensorId, action="Set", value=sensorValue)
	resp = requests.post(url=url + "/Sensor", params = params, timeout=10);
	result = json.loads(resp.text)
	if result["result"] != "ok":
		raise Exception("Server returned error:\n " + result["message"].replace("\\n", "\n").replace("\\r", ""))

def draw_progressbar(x, y, description, progress):
	p = '#'*math.floor(progress/5)
	p1 = '-'*math.ceil((100-progress)/5)
	print('{0}{1}[{2}{3}] {4}%   '.format(pos(x,y), description, p, p1, math.floor(progress*100)/100), end='')

def integrate(oldval, newval):
	return float(oldval)*0.8 + float(newval) * 0.2

def main():
	colorama.init()

	print(clear())

	try:
		integratedCPU = getValue("/intelcpu/0/load/0");
		integratedGPU = getValue("/nvidiagpu/0/load/0");
		orgFan1 = getValue("/lpc/it8620e/control/0")
		orgFan2 = getValue("/lpc/it8620e/control/1")

		while 1:
			cpuLoad = getValue("/intelcpu/0/load/0");
			gpuLoad = getValue("/nvidiagpu/0/load/0");

			integratedCPU = integrate(integratedCPU, cpuLoad)
			integratedGPU = integrate(integratedGPU, gpuLoad)
			fanVal = max(integratedCPU, integratedGPU)
			fanVal = math.floor(fanVal*0.75)

			draw_progressbar(1, 1, "CPU:  ", cpuLoad)
			draw_progressbar(1, 2, "GPU:  ", gpuLoad)

			draw_progressbar(1, 3, "IGPU: ", integratedCPU)
			draw_progressbar(1, 4, "IGPU: ", integratedGPU)

			draw_progressbar(1, 5, "Fans: ", fanVal)

			setValue("/lpc/it8620e/control/0", fanVal);
			setValue("/lpc/it8620e/control/1", fanVal);
			
			print(pos(1, 1))
			time.sleep(1)
	except:
		print(clear())
		setValue("/lpc/it8620e/control/0", orgFan1);
		setValue("/lpc/it8620e/control/1", orgFan2);
		raise



if __name__ == '__main__':
    main()
```

`LibreHardwareMonitor/TestScripts/basicrest.py`:

```py
################################################################
# Install:
# * python -m pip install requests
#
# Usage:
# * python basicrest.py
#
# Description:
# A simple test of the REST Like API
################################################################

import json, requests
import time

url = 'http://127.0.0.1:8085'

def findSensors(node):
	sensors = {}

	if len(node["Children"]) > 0:
		for child in node["Children"]:
			sensors.update(findSensors(child))
	else:
		if "Type" in node:
			sensors[node["SensorId"]] = node

	return sensors

def getValue(sensorId):
	params=dict(id=sensorId, action="Get")
	resp = requests.post(url=url + "/Sensor", params = params, timeout=10);
	result = json.loads(resp.text);

	if result["result"] != "ok":
		raise Exception("Server returned error:\n " + result["message"].replace("\\n", "\n").replace("\\r", ""))
	if result["value"] == None:
		return None;
	else:
		return float(result["value"])

def setValue(sensorId, sensorValue):
	if sensorValue == None:
		sensorValue = "null"
	params=dict(id=sensorId, action="Set", value=sensorValue)
	resp = requests.post(url=url + "/Sensor", params = params, timeout=10);
	result = json.loads(resp.text)
	if result["result"] != "ok":
		raise Exception("Server returned error:\n " + result["message"].replace("\\n", "\n").replace("\\r", ""))

def main():
	params = dict()

	print("Fetching all sensor ids:")
	resp = requests.get(url=url + "/data.json", params=params, timeout=10)
	data = json.loads(resp.text)
	sensors = findSensors(data)

	for key, value in sensors.items():
		v = getValue(key)
		print(key, ":", v);

	# Change the id to one of yours 
	print("Setting GPU Fan to full speed!")
	setValue("/nvidiagpu/0/control/0", "100.0")
	time.sleep(10);
	print("Returning GPU Fan speed to default")
	setValue("/nvidiagpu/0/control/0", None)


if __name__ == '__main__':
    main()
```

`LibreHardwareMonitor/TestScripts/basicwmi.py`:

```py
################################################################
# Install:
# * python.exe -m pip install pypiwin32
# * python.exe -m pip install wmi
#
# Usage:
# * !! Make sure librehardwaremonitor is running !!
# * python basicwmi.py
################################################################

import wmi

hwmon = wmi.WMI(namespace="root\LibreHardwareMonitor")
sensors = hwmon.Sensor(SensorType="Control")

for s in sensors:
	print s

```

`LibreHardwareMonitor/UI/AboutBox.Designer.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.UI
{
    sealed partial class AboutBox
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(AboutBox));
            this.okButton = new System.Windows.Forms.Button();
            this.pictureBox1 = new System.Windows.Forms.PictureBox();
            this.label1 = new System.Windows.Forms.Label();
            this.label2 = new System.Windows.Forms.Label();
            this.label3 = new System.Windows.Forms.Label();
            this.projectLinkLabel = new System.Windows.Forms.LinkLabel();
            this.flowLayoutPanel1 = new System.Windows.Forms.FlowLayoutPanel();
            this.licenseLinkLabel = new System.Windows.Forms.LinkLabel();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).BeginInit();
            this.SuspendLayout();
            //
            // okButton
            //
            this.okButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.okButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.okButton.Location = new System.Drawing.Point(269, 79);
            this.okButton.Name = "okButton";
            this.okButton.Size = new System.Drawing.Size(75, 23);
            this.okButton.TabIndex = 0;
            this.okButton.Text = "OK";
            this.okButton.UseVisualStyleBackColor = true;
            //
            // pictureBox1
            //
            this.pictureBox1.Image = ((System.Drawing.Image)(resources.GetObject("pictureBox1.Image")));
            this.pictureBox1.Location = new System.Drawing.Point(10, 11);
            this.pictureBox1.Name = "pictureBox1";
            this.pictureBox1.Size = new System.Drawing.Size(48, 48);
            this.pictureBox1.SizeMode = System.Windows.Forms.PictureBoxSizeMode.CenterImage;
            this.pictureBox1.TabIndex = 1;
            this.pictureBox1.TabStop = false;
            //
            // label1
            //
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(74, 12);
            this.label1.Margin = new System.Windows.Forms.Padding(10, 0, 10, 0);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(117, 13);
            this.label1.TabIndex = 2;
            this.label1.Text = "Libre Hardware Monitor";
            //
            // label2
            //
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(74, 46);
            this.label2.Margin = new System.Windows.Forms.Padding(10, 0, 10, 0);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(250, 13);
            this.label2.TabIndex = 3;
            this.label2.Text = "Copyright © LibreHardwareMonitor and Contributors";
            //
            // label3
            //
            this.label3.AutoSize = true;
            this.label3.Location = new System.Drawing.Point(74, 29);
            this.label3.Margin = new System.Windows.Forms.Padding(10, 0, 10, 0);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(127, 13);
            this.label3.TabIndex = 4;
            this.label3.Text = "Version 9.0.30729.1 Beta";
            //
            // projectLinkLabel
            //
            this.projectLinkLabel.AutoSize = true;
            this.projectLinkLabel.Location = new System.Drawing.Point(164, 80);
            this.projectLinkLabel.Margin = new System.Windows.Forms.Padding(0);
            this.projectLinkLabel.Name = "projectLinkLabel";
            this.projectLinkLabel.Size = new System.Drawing.Size(82, 13);
            this.projectLinkLabel.TabIndex = 6;
            this.projectLinkLabel.TabStop = true;
            this.projectLinkLabel.Text = "Project Website";
            this.projectLinkLabel.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.LinkLabel_LinkClicked);
            //
            // flowLayoutPanel1
            //
            this.flowLayoutPanel1.AutoSize = true;
            this.flowLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            this.flowLayoutPanel1.Location = new System.Drawing.Point(10, 100);
            this.flowLayoutPanel1.Margin = new System.Windows.Forms.Padding(10, 0, 10, 0);
            this.flowLayoutPanel1.Name = "flowLayoutPanel1";
            this.flowLayoutPanel1.Size = new System.Drawing.Size(0, 0);
            this.flowLayoutPanel1.TabIndex = 8;
            //
            // licenseLinkLabel
            //
            this.licenseLinkLabel.AutoSize = true;
            this.licenseLinkLabel.Location = new System.Drawing.Point(25, 80);
            this.licenseLinkLabel.Margin = new System.Windows.Forms.Padding(0);
            this.licenseLinkLabel.Name = "licenseLinkLabel";
            this.licenseLinkLabel.Size = new System.Drawing.Size(107, 13);
            this.licenseLinkLabel.TabIndex = 9;
            this.licenseLinkLabel.TabStop = true;
            this.licenseLinkLabel.Text = "Licensing Information";
            this.licenseLinkLabel.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.LinkLabel_LinkClicked);
            //
            // AboutBox
            //
            this.AcceptButton = this.okButton;
            this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
            this.AutoSize = true;
            this.ClientSize = new System.Drawing.Size(359, 115);
            this.Controls.Add(this.licenseLinkLabel);
            this.Controls.Add(this.flowLayoutPanel1);
            this.Controls.Add(this.projectLinkLabel);
            this.Controls.Add(this.label3);
            this.Controls.Add(this.label2);
            this.Controls.Add(this.label1);
            this.Controls.Add(this.pictureBox1);
            this.Controls.Add(this.okButton);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "AboutBox";
            this.ShowInTaskbar = false;
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
            this.Text = "About";
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).EndInit();
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.Button okButton;
        private System.Windows.Forms.PictureBox pictureBox1;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.Label label3;
        private System.Windows.Forms.LinkLabel projectLinkLabel;
        private System.Windows.Forms.FlowLayoutPanel flowLayoutPanel1;
        private System.Windows.Forms.LinkLabel licenseLinkLabel;
    }
}

```

`LibreHardwareMonitor/UI/AboutBox.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Diagnostics;
using System.Drawing;
using System.Windows.Forms;
using LibreHardwareMonitor.UI.Themes;

namespace LibreHardwareMonitor.UI;

public sealed partial class AboutBox : Form
{
    public AboutBox()
    {
        InitializeComponent();
        Font = SystemFonts.MessageBoxFont;
        label3.Text = "Version " + Application.ProductVersion;
        projectLinkLabel.Links.Remove(projectLinkLabel.Links[0]);
        projectLinkLabel.Links.Add(0, projectLinkLabel.Text.Length, "https://github.com/LibreHardwareMonitor/LibreHardwareMonitor");
        licenseLinkLabel.Links.Remove(licenseLinkLabel.Links[0]);
        licenseLinkLabel.Links.Add(0, licenseLinkLabel.Text.Length, "https://www.mozilla.org/en-US/MPL/2.0/");
        Theme.Current.Apply(this);
    }

    private void LinkLabel_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
    {
        try
        {
            Process.Start(new ProcessStartInfo(e.Link.LinkData.ToString()));
        }
        catch { }
    }
}

```

`LibreHardwareMonitor/UI/AboutBox.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Drawing" name="System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
  <data name="pictureBox1.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vAAADrwBlbxySQAADUJJREFUaEPtWelTVHcWzcyXVBJjkkoqCbJDd9PdNCICouyiuAAKhB3BFZhMLOO+
        ILIoKq6AIIsYMSK474q4BEzUiRInJho1FZNUjeZL/os799zfe90NMpPumi/WVF7VrddU093n3Hvu8rvv
        lT+vP68/r//Dq6WllZqamtmaqKGxgXbv3k3bt2+nrXV1tGXLFqrdtImqa6ppw4ZKKi9fT2vWrKFVq1bR
        ihUraOmyZbR48WL6+OOPqbSslBaVLKIFCxbQvLlzqaioiPLz8yknO4c++iiLMjIyaNasWZSamkozZsyg
        KVOn0OTJkykhIYFi42Jp0qRJNGHCBBo/fjyFhYURQ/uLZv/9AvCcnGy2HLlnZWXxD35EmZmZlJ6eTrNn
        z5YfTktL4x9PoZkzU9lmCojp06ZRcnIyTZmig0mk+Ph4iouPo9jYWIqOjhZgEydOFHDhEeEUxgDHjRtH
        oaGhNHbsWAoJCRGzWILJZLKQwRgk7zG00Wyj2F5l+yvbyFdzczPl5eWxtwoojz2G17m5uUJIEcl4gUhK
        iiIxffp0msYkpiZPpaSkJErUPBrPFhcHEjFCQghERVFkRASFh4ezl8MoVCMREjKWbLYQMjOBE/UfkpEJ
        gNDrr78+/o033rC99tprYxgmSIx8gQDAFxYWUkFBgYQ9l0lkMwFEA5HISNdJaJHQCCAKQmAqCDhFISGe
        4p0IIApRE6MoIjLSTkCPAgi01HxA5qAQjkAwGQ1mCg4OJgaf9+abb6aBBMNEJEaWEyQE8HPmzJF7PpOQ
        KOTkUnZ2NmVyFEBgaARSaMZMlpAeASHAEUhMVBGAjJhATEyMQ0IcgQh7BBwystlCKdg6loLMIRIBU5CZ
        LGYLjRo1qmT06NF5b7311niGCTmNTKCxoZHBF1NRcbGQsEeBZZSVzRFgAvD+LCaQmpaqwIv+p1PyVNY/
        A09iz48EPloDH8X6j7R7XyVp6LhQLQKhEoEgs43BW8jIeRAUFAQCZUyggAmEM8z/TKC+vp6K5hbRXFQO
        PQrIBRDIAvjZlMKVA94e6mkGyokKoLEAOyxhIyMiKSJceRyAdY/DkLxyD0UScw6w5s3WYGrdyERMZpaS
        yXUCu3btouLiuYpAkR4FLn9MALLJzculo0ePUk9PD3V3d1NXVxd9/vnn9Nlnn1F7ezshhxoa6qX0btm8
        hWpqamhDRYWU2+UrltOSJUuorOxvtHDhQv6dYnEQSNlCbBTiXIWsKgIGUxAZDAbXCezcuZPmzpsntRs/
        AAJIaug/n3MB12+//UY//PADfffdd/TNN9/QnTv/oJtffUU3Bm7Q1atXqbe3l86dO0enTp+iY0eOCMnO
        A520b98+2tu8lxobGwm/s3XrVtq4cSP3lA0soTCysddtNptUIatTBAICAlwnAM/Nnz+f5jEJREERyJfG
        c/z4cfr999/pyZMnTOChELh37x59/fXXdPPmTRoYGBACly5dEgInT52iIxytrq5DdODAAXuE6rUIbd68
        mWqqq6mCI5TKuWQ2q4oDEiBgtVhZ/xby9fV1ncC2bdteIJCXly9JC+k8e/aMnv70lB4/fkzff/89ffvt
        t3Tn7l26desW3bgxQNeuXVMROH+OTnMEjh4DAY5ApxaBvZBYA+3YscMuscrKKqlepiCTgLYGK7NYLELK
        x8fbdQJ1dVuGEmCNIoFRLo+wHJ49f0Y///yzROHBgwdCYJAJ3L59mwncoOvXr1Pv5V46f/48EzhNx44d
        o8OHDzsR2OsgwKOJEKiqlGKAZAVgALdaHQS8vLxcJ4CwDieAEoqZBYn7/Plz+uWXX+jJj0zg4QO6fx8E
        BoXAl18ygWvX6XLvZTuBo0ygaxiBRiGwkwlsFQJVVVVcyRK46xq5fCoCFicCnp6e7hCotRNANUKVwBiB
        bqsIqAg8dorAXURAJHSDrl1XEhoaAWcJ6REAAT0CVTIrodqg5g8hwI1sjIeH6wQ28bSJKgTvF3MZLShU
        FShlZooQ+Bdy4OlP9EjPgX9yDty5IzkwwFXIngOcxJIDksRdnMSd1M4EmkeSUGWl9AxDYKAioEeBLYjt
        ww8+dJ0AvhDgYRiB0YkxA2HWQd3/9ddfWT4/0sOHI1Whfrp65Yq9Cp3SqtChQ85VqInQLO1ViEdzSAjN
        zhCoIqDngW7vv/++6wSquayh/ksPQAJzCcUUqhN4+vQpPXr0yF6BBgdVAvf397P2lXQAHNLplvqvgMPa
        2trknLGbCWzbvo1qa2sJv4cIYC4K1CLgTACv3333XWLgrhGAHuH5ojnwPicwNy9MoJh3ICG9+ty/f5+b
        mO79W9THngfwo8dZMlrSQjr4zMGDB2l/x35qbW2hxj17aBcfkuq4XEOu8D4aGSZSRcBRiSAls8VM77zz
        jusE8GWFTjNQbm6ONDHMPogApAPwkA60f/v2La4+X0oDO3/hgpa4xwU4Roz9+/dTW2sbdegJPKwLw/to
        ZJiNQAClFJXILN5XEXj77bddJ1BRsZ4KWffQPsboHE7g9Ix0aTRdh7rU+HCPx4e7AH+bvuIRYqB/gC5f
        vkxnz56lkydP2BNXrzwtLS0CHkdV6N85geGw9eXrFIEARQCVxwoSYkEA7zqB8vJyNX3iDGCfQBUBSAHg
        IRt4XoHvl8pz8eJFh/Z7uh3eZ91jfID2G/c0yhkb3V7pv4oq1q+ndevWyYkMM48REdDyAPcgJsPAXSew
        bu06AQ6TAwzrH1PoVJ71MXEC/C2uOJBNP1cd1P2+vj6pOpiV0K0RKVQdZ++rKbXhBfkA/Jq1a2ScDgzw
        l2ZmAgEGDvAg4RYBfJk60A/dHmD27+jokHKJmeeLL76ga6z7PpYOvA/tAzya1kGWTod4v5WaMLyxbHbX
        71be5/JZW7tZqg+0j99btXq1EPD3BwGDygMGbuJRGvORWwRW85dlc91X518cHdNlDsKsAjlg4oRk+q70
        ScO6wImrmtYZOnXiJNd9NT5L5dESGPLBBIruK97ftJGrD9Yy5bKSWblypYqAf6B0YyEA8HyHuUUAXwjZ
        ZGY41ijYOoAA5HCFy2UvzzrwOmo+EhfeP3FCyeewBl4/4OiVBwclh/Z176+VfRIslE9jiAAIIA8AHHej
        0U0C8AaA65bG8kETm5w4WTx56ZJqVucY+JkzZ7jqnBTt9/Q4PC/g97Uz4b20h+u+vhxD5dG1r3t/2bJl
        QgDHSj+dAPKAgQM8XrtFYPny5eL1dDZ964AmhnMvTlJnRS6n5bAC4HK85P5wiA8tzp5HtJoYvF42IR29
        caHy6EfMpUuXagQ4B/z8pRcYNRK4G9wlgPUggDuvTNDEEuITBIzuccw43d094nWUzM7OA6J5JZsW8Tz+
        fyeDr6urs0sHdX8tSweRBnidAHLAz99PCBgMRomEbm4RWPLpp5TGsz9WJjgDQD7oAVhQ7dq5S7SPA4oD
        eKd4fV/HPklYaH4P13sBzyVTB19TrZoWyuaqVatFOgCPe2lpqTQy9AFFQAPPw12gIdA9AosXLxGvw/Rt
        W3LyNJEQEnlwcFCi0Mly0cGjvKJCCXjOE9R7JO2OHdtoa91WRUDruiCwkrUPqcLzAD87fbaUTSHAgAEe
        RMS4MrlF4JNP/s6SwZYNu072PssnmXsA1oQ4dGD/U1lRSSi38B620aUlpXwAmi/zUy73D1QxyA/SU5+L
        l1Ui1ifwtBhLBvewcWEKPCfwUO8HMqFAqUxuEcBqPDl5BrXXGihpCoNPni7bZixqsaSNiY6R2R3LKdkm
        22yyx8EmARsFi9UxBuvjABqSSkqlbXgZcw88HhCoyYblogPXve/P7/v5+blHoKysjKUyjc63eVDzRiN7
        cBqbY9OMNWF0jNowR04Yuh6ER5GMMJDT1+UgFqwdETEegJDBYGKwJgZqZDJsfA8IMChj2fj5M3hff1mp
        uEUAmkxk0Odax9DpvZ7UXGOguPgkSWJUIuw6nXf9UVFRNCFywpBFrU4GMtHJ6FGyMpl5OX5UnOVLxdls
        WX5UxK+LMpXNyfShORkwb/L18WUSbhIoKSmh2LgkOtsyhk42eQmJpmoDxcQmMngmEAcC2rLWaf8ZFaUW
        tsOJ6Ht/kMDO02q18ayP1bmVZWVhOSF5zSwXE8vFSD6+BvLyCSQv7wDy9vYVEm4RWLRoEXt8Ml1sH8NR
        8JRIXGgbQ62bAlg+atOMCLxIgCPBueEggCXueBoX5pAVdp8LcgNoXra/mETBKQLieY5AIXu/IN2L//Yi
        H3cJLFi4UKpGTGwCaz1RbFI0v45m7bMJcM4BJPNwApEgMGxtHqY9vICh22L7HIwomNXa0GgySz4gB/xZ
        /9C+j48fecO8/dwngK0xzsQoiXkYqbWnMhgvsBtCabQ/A2NJIRqTJkWLfABagIpUrDKQobqgFPr4+JCX
        pyd5eHjQe++9p59zBdwfGf7PZQJ84Y3R2jOpPL6XsJU5G1Yc/6sBkDvGn3HtCQ1feGMUnkXhmRQ+BOYv
        gbn2jEy7XmVPe+CfwZgt/CUw155Saheew+KfwBThelnsj58TD7sQppfNtOuVV/4NcZaFCnU4CO8AAAAA
        SUVORK5CYII=
</value>
  </data>
</root>
```

`LibreHardwareMonitor/UI/AuthForm.Designer.cs`:

```cs
namespace LibreHardwareMonitor.UI
{
    partial class AuthForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(AuthForm));
            this.enableHTTPAuthCheckBox = new System.Windows.Forms.CheckBox();
            this.httpAuthUsernameTextBox = new System.Windows.Forms.TextBox();
            this.httpAuthPasswordTextBox = new System.Windows.Forms.TextBox();
            this.httpUsernameLabel = new System.Windows.Forms.Label();
            this.httpPasswordLabel = new System.Windows.Forms.Label();
            this.credentialsGroupBox = new System.Windows.Forms.GroupBox();
            this.httpAuthCancelButton = new System.Windows.Forms.Button();
            this.httpAuthOkButton = new System.Windows.Forms.Button();
            this.label1 = new System.Windows.Forms.Label();
            this.label2 = new System.Windows.Forms.Label();
            this.credentialsGroupBox.SuspendLayout();
            this.SuspendLayout();
            // 
            // enableHTTPAuthCheckBox
            // 
            this.enableHTTPAuthCheckBox.AutoSize = true;
            this.enableHTTPAuthCheckBox.Location = new System.Drawing.Point(12, 12);
            this.enableHTTPAuthCheckBox.Name = "enableHTTPAuthCheckBox";
            this.enableHTTPAuthCheckBox.Size = new System.Drawing.Size(191, 17);
            this.enableHTTPAuthCheckBox.TabIndex = 0;
            this.enableHTTPAuthCheckBox.Text = "Enable HTTP Basic Authentication";
            this.enableHTTPAuthCheckBox.UseVisualStyleBackColor = true;
            this.enableHTTPAuthCheckBox.CheckedChanged += new System.EventHandler(this.EnableHTTPAuthCheckBox_CheckedChanged);
            // 
            // httpAuthUsernameTextBox
            // 
            this.httpAuthUsernameTextBox.Location = new System.Drawing.Point(102, 23);
            this.httpAuthUsernameTextBox.MaxLength = 255;
            this.httpAuthUsernameTextBox.Name = "httpAuthUsernameTextBox";
            this.httpAuthUsernameTextBox.Size = new System.Drawing.Size(171, 20);
            this.httpAuthUsernameTextBox.TabIndex = 1;
            // 
            // httpAuthPasswordTextBox
            // 
            this.httpAuthPasswordTextBox.Location = new System.Drawing.Point(102, 60);
            this.httpAuthPasswordTextBox.MaxLength = 255;
            this.httpAuthPasswordTextBox.Name = "httpAuthPasswordTextBox";
            this.httpAuthPasswordTextBox.PasswordChar = '*';
            this.httpAuthPasswordTextBox.Size = new System.Drawing.Size(171, 20);
            this.httpAuthPasswordTextBox.TabIndex = 2;
            this.httpAuthPasswordTextBox.UseSystemPasswordChar = true;
            // 
            // httpUsernameLabel
            // 
            this.httpUsernameLabel.AutoSize = true;
            this.httpUsernameLabel.Location = new System.Drawing.Point(6, 26);
            this.httpUsernameLabel.Name = "httpUsernameLabel";
            this.httpUsernameLabel.Size = new System.Drawing.Size(90, 13);
            this.httpUsernameLabel.TabIndex = 6;
            this.httpUsernameLabel.Text = "HTTP UserName:";
            // 
            // httpPasswordLabel
            // 
            this.httpPasswordLabel.AutoSize = true;
            this.httpPasswordLabel.Location = new System.Drawing.Point(6, 63);
            this.httpPasswordLabel.Name = "httpPasswordLabel";
            this.httpPasswordLabel.Size = new System.Drawing.Size(88, 13);
            this.httpPasswordLabel.TabIndex = 7;
            this.httpPasswordLabel.Text = "HTTP Password:";
            // 
            // credentialsGroupBox
            // 
            this.credentialsGroupBox.Controls.Add(this.httpAuthUsernameTextBox);
            this.credentialsGroupBox.Controls.Add(this.httpPasswordLabel);
            this.credentialsGroupBox.Controls.Add(this.httpAuthPasswordTextBox);
            this.credentialsGroupBox.Controls.Add(this.httpUsernameLabel);
            this.credentialsGroupBox.Location = new System.Drawing.Point(12, 35);
            this.credentialsGroupBox.Name = "credentialsGroupBox";
            this.credentialsGroupBox.Size = new System.Drawing.Size(279, 100);
            this.credentialsGroupBox.TabIndex = 5;
            this.credentialsGroupBox.TabStop = false;
            this.credentialsGroupBox.Text = "Credentials";
            // 
            // httpAuthCancelButton
            // 
            this.httpAuthCancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.httpAuthCancelButton.Location = new System.Drawing.Point(76, 206);
            this.httpAuthCancelButton.Name = "httpAuthCancelButton";
            this.httpAuthCancelButton.Size = new System.Drawing.Size(75, 23);
            this.httpAuthCancelButton.TabIndex = 3;
            this.httpAuthCancelButton.Text = "Cancel";
            this.httpAuthCancelButton.UseVisualStyleBackColor = true;
            this.httpAuthCancelButton.Click += new System.EventHandler(this.HttpAuthCancelButton_Click);
            // 
            // httpAuthOkButton
            // 
            this.httpAuthOkButton.Location = new System.Drawing.Point(157, 206);
            this.httpAuthOkButton.Name = "httpAuthOkButton";
            this.httpAuthOkButton.Size = new System.Drawing.Size(75, 23);
            this.httpAuthOkButton.TabIndex = 4;
            this.httpAuthOkButton.Text = "OK";
            this.httpAuthOkButton.UseVisualStyleBackColor = true;
            this.httpAuthOkButton.Click += new System.EventHandler(this.HttpAuthOkButton_Click);
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(12, 138);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(269, 26);
            this.label1.TabIndex = 8;
            this.label1.Text = "Password is stored hashed, if you forget it you will need \r\nto set a new one.";
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(12, 174);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(284, 26);
            this.label2.TabIndex = 9;
            this.label2.Text = "If the web server is running then it will need to be restarted \r\nfor the change t" +
    "o take effect.";
            // 
            // AuthForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.CancelButton = this.httpAuthCancelButton;
            this.ClientSize = new System.Drawing.Size(305, 241);
            this.Controls.Add(this.label2);
            this.Controls.Add(this.label1);
            this.Controls.Add(this.httpAuthOkButton);
            this.Controls.Add(this.httpAuthCancelButton);
            this.Controls.Add(this.credentialsGroupBox);
            this.Controls.Add(this.enableHTTPAuthCheckBox);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "AuthForm";
            this.SizeGripStyle = System.Windows.Forms.SizeGripStyle.Hide;
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
            this.Text = "Set HTTP Credentials";
            this.Load += new System.EventHandler(this.AuthForm_Load);
            this.credentialsGroupBox.ResumeLayout(false);
            this.credentialsGroupBox.PerformLayout();
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.CheckBox enableHTTPAuthCheckBox;
        private System.Windows.Forms.TextBox httpAuthUsernameTextBox;
        private System.Windows.Forms.TextBox httpAuthPasswordTextBox;
        private System.Windows.Forms.Label httpUsernameLabel;
        private System.Windows.Forms.Label httpPasswordLabel;
        private System.Windows.Forms.GroupBox credentialsGroupBox;
        private System.Windows.Forms.Button httpAuthCancelButton;
        private System.Windows.Forms.Button httpAuthOkButton;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Label label2;
    }
}
```

`LibreHardwareMonitor/UI/AuthForm.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Windows.Forms;

namespace LibreHardwareMonitor.UI;

public partial class AuthForm : Form
{
    private readonly MainForm _parent;

    public AuthForm(MainForm m)
    {
        InitializeComponent();
        _parent = m;
    }

    private void AuthForm_Load(object sender, EventArgs e)
    {
        httpAuthUsernameTextBox.Enabled = httpAuthPasswordTextBox.Enabled = enableHTTPAuthCheckBox.Checked = _parent.Server.AuthEnabled;
        httpAuthUsernameTextBox.Text = _parent.Server.UserName;
    }

    private void HttpAuthCancelButton_Click(object sender, EventArgs e)
    {
        Close();
    }

    private void HttpAuthOkButton_Click(object sender, EventArgs e)
    {
        _parent.Server.UserName = httpAuthUsernameTextBox.Text;
        _parent.Server.Password = httpAuthPasswordTextBox.Text;
        _parent.Server.AuthEnabled = enableHTTPAuthCheckBox.Checked;
        _parent.AuthWebServerMenuItemChecked = _parent.Server.AuthEnabled;
        Close();
    }

    private void EnableHTTPAuthCheckBox_CheckedChanged(object sender, EventArgs e)
    {
        httpAuthUsernameTextBox.Enabled = httpAuthPasswordTextBox.Enabled = enableHTTPAuthCheckBox.Checked;
    }
}
```

`LibreHardwareMonitor/UI/AuthForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Drawing" name="System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
  <data name="$this.Icon" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        AAABAAMAEBAAAAEAIABoBAAANgAAACAgAAABACAAqBAAAJ4EAAAwMAAAAQAgAKglAABGFQAAKAAAABAA
        AAAgAAAAAQAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEU8OykuDgdIIxQSURwdHU8ZGhpPFhYWTxQU
        FE8SEhJPDxAPTw0KCk8KBQRPCAQDTwcDAU8HAQBPBgQEUQUFBTxLVVb/L215/zdXXP89Ozv/ODc3/zM0
        M/8vLy//Kioq/yYlJf8iJif/Gycp/xggI/8UHiD/Eh4g/w4SE/8GBARRQWRr/xGXtP8yUln/NDIx/y4u
        Lf8qKir/KSgo/ycnJ/8lJCP/Iikq/xs4Pf8aOD7/GzpB/xo4Pf8SGhv/BwMDT01aXP46Ulj+Pzc0/kdH
        R/5MTU3+Q0ND/jw8PP43Nzf+Ly8v/igoKP4lKCn+Iico/hwiI/4cHyD/FBMU/wYHBk9XVVX+Rj8+/klJ
        Sf6ioqL+rq+u/p+fn/6YmJj+j4+P/oSEhP56enr+dXJy/mNgYP4iHx7+Gxka/xUVFf8HBwdPW1pa/kVF
        RP5YWFj+rq6u/r6+vv6wsK/+qamp/qCgoP6UlJT+iYmJ/oGBgf5xcXH+JCQk/hsbG/8WFhb/BwcHT15e
        Xv5ISEj+Wlpa/rW1tf7Gxsb+tra2/qysq/6hoaL+lpaW/oyMjP6EhIT+cnJy/iQkJP4cHBz/GBgY/wcH
        B09jY2P+TUxM/l5eXv7AwMD+0dHR/r6+vv6vr6/+o6Ok/pmYmf6Rk5P+iouK/nd4d/4lJSX+HR0d/xkZ
        Gf8HBwdPZ2dn/lBQUP5iYmL+ysrK/tzc3P7Hxsf+tbS1/qmpqf6fn5/+mJiY/o6Pj/57e3z+JSUm/h4e
        Hv8aGhr/CAgIT2tra/5TU1P+ZGRk/tLS0v7j5eP+zMzM/ry8vP6wsLD+pqam/pubm/6TkZH+f39//igo
        KP4fHx7/HBwc/wkJCk9ubm7+VlVW/mZlZv7X1tf+6Ojo/tPS0/7Hx8f+urq6/qurq/6dnp7+lJSU/oGB
        gP4sLCz+Hx4e/x4dHP8LCwtPb29v/lZWVv5nZ2j+4eHh/vLx8v7Z2dn+zc3N/sDAwP6wsrL+pKOk/pmZ
        mf6Ghob+MDAw/h8gH/8eHx//DQsNT29vb/5YWFj+WVpa/sHBwf7V1dX+wMC//rW1tP6pqan+m5ub/o6P
        jv6FhYX+cXFx/i4qKv4gLC7/Hiot/w4JB09vb3D+Wlla/lJSUf5VVVX+YGBg/ltbWv5VVVP+Tk5O/kdH
        R/5BQUH+Ozs6/jAvL/4oKCj+Izk9/x8tL/8QCQhRbm5u/lVVVf5SUlL+S0tL/kRERP5BQUH+PT09/jk5
        Of41NTX+MzIy/i8vLv4sKSj+Jy4v/h9DTP8iLjH/Ew0KSHp7ev5qamr+ZWVl/mFhYv5cXFz+WFhY/lNS
        U/5NTU3+R0ZH/kJCQv49PDz+NzU1/jAxMf4qMTL/Jigp/x4cHCn//wAAAAEAAAABAAAAAQAAAAEAAAAB
        AAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAKAAAACAAAABAAAAAAQAgAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAwMBBwcHAwYGBgQGBgYEBgYGBAYG
        BgQGBgYEBgYGBAYGBgQGBgYEBgYGBAYGBgQGBgYEBgYGBAYGBgQGBgYEBgYGBAYGBgQGBgYEBgYGBAYG
        BgQGBgYEBgYGBAYGBgQGBgYEBwcHAwUFBQIAAAAAAAAAAAAAAAAAAAAAAAAAAAoKCgkMDAwgDQ0NKg0N
        DSoNDQ0qDQ0NKg0NDSoNDQ0qDQ0NKg0NDSoNDQ0qDQ0NKg0NDSoNDQ0qDQ0NKg0NDSoNDQ0qDQ0NKg0N
        DSoNDQ0qDQ0NKg0NDSoNDQ0qDQ0NKg0NDSoMDAwlCgoKEQUFBQIAAAAAAAAAAAAAAAAAAAAACAgIFAoK
        CkcMDAxbDAwMXAwMDFwMDAxcDAwMXAwNDFwNDQ1cDQ0NXA0NDVwNDQ1cDQ0NXA0NDVwNDQ5cDg4OXA4O
        DlwODg5cDg4OXA4ODlwODg5cDg4OXA4ODlwODg5cDg4OWw0NDVIMDAwlBwcHAwAAAAAAAAAAAAAAAGFh
        YY9ZWFjFUVBP0kpJSdhIR0fYQkJC2D0+Ptg5OTnZODc22TMyM9kuLi/ZKysr2SYmJtkjIyPZICAf2Rsb
        G9kXFxjZExMT2Q8ODtkNDAzZDQwM2A0MDNgNDAzYDQ0N2A0NDdgODQ27Dg4OWw0NDSoGBgYEAAAAAAAA
        AAAAAAAAYmFhvzxCQ/82Uln/NlJZ/zdPVP89PDz/PDw8/zo6Ov85OTn/ODg4/zY2Nv80NDT/NDQ0/zIy
        Mv8xMTD/Ly4w/yw1OP8qNjj/JzQ1/yYyNP8kMDL/Ii4w/x8sLv8fKy3/HyIi/w0NDdgODg5cDQ0NKgYG
        BgQAAAAAAAAAAAAAAABjY2K/OFRa/xqXsv8bk6v/M11l/z49Pf89PT3/Ozs7/zo6Of83Nzj/NTY1/zQ0
        NP8zMzP/MTEw/y8vL/8uLi7/KzQ2/yk1Nv8nMjT/JjAz/yQvMf8jLjD/ISwu/x8rLf8fISL/DQ0N2A4O
        DlwNDQ0qBgYGBAAAAAAAAAAAAAAAAGZkZL86V13/GpKs/zJkbv9BPz//Pj8+/zw8PP85OTn/Njc2/zQ0
        Nf8zMjP/MjIy/zAwMP8vLy//Li4u/y0sLP8qKSn/I0hQ/yJHUP8hRk//IEZO/yBGTv8fRU3/HztB/yAf
        H/8NDQ3YDg4OXA0NDSoGBgYEAAAAAAAAAAAAAAAAaWdovz5WW/83YWr/RkND/0FAQP89PT3/ODc3/zIy
        Mf8uLi7/LCws/ysrK/8pKSn/Kioq/ygoKP8nJyf/JSUl/yUkJP8kIyP/IyEh/yMiIv8kIiL/JCMj/yQj
        I/8iISH/ISAg/w0NDdgODg5cDQ0NKgYGBgQAAAAAAAAAAAAAAABqamq/SUhI/0hHR/9GRkb/QUFB/0ZH
        Rv9/f4D/gICA/3h4eP9xcXH/a2tr/2RkZP9dXV7/V1dX/09PT/9ISEj/Q0NC/0BAQP9AQED/Ozs7/yYm
        Jv8jIyP/JCQk/yMjI/8jIyH/DQ0N2A4ODlwNDQ0qBgYGBAAAAAAAAAAAAAAAAG5ubr9LS0v/SkpL/0hI
        SP9BQUH/i4uL/6ysrP+hoqH/n5+e/52bnf+YmJj/lJSU/5CQj/+Li4v/hYaF/4CAgP97e3r/dXR1/3Fx
        cf9ra2v/Ozs7/yEhIv8kJCT/JCQk/yQkI/8NDQ3YDg4OXA0NDSoGBgYEAAAAAAAAAAAAAAAAcHBwv01N
        Tf9MTU3/SUpK/0BAP/+Wlpj/q6ur/6inp/+kpKT/oKGg/52cnP+YmJj/k5OT/46Ojv+IiYj/g4OC/319
        ff93d3f/cXFx/3Fxcf8/Pz//ISEh/yQkJP8lJSX/JSQk/w0NDdkODg5cDQ0NKgYGBgQAAAAAAAAAAAAA
        AABycnO/T05P/05PT/9MTEz/QUFB/5ubmv+ysrL/rq6u/6urq/+np6f/oqKi/52dnf+ZmZn/k5OT/42O
        jv+IiIf/gYGB/3x7fP90dXT/cXFx/z8/P/8hISH/JCQl/yUlJf8lJib/DQ0N2Q4ODlwNDQ0qBgYGBAAA
        AAAAAAAAAAAAAHR1db9RUVH/UFBQ/01NTf9CQkL/np6e/7i4uP+0s7T/sbGx/62trf+oqKj/o6Oj/52d
        nf+Yl5f/kZKR/4yMi/+FhYX/fn9//3h4eP9zc3P/Pz8//yIiIv8lJSX/JiYm/yYmJv8NDQ3ZDg4OXA0N
        DSoGBgYEAAAAAAAAAAAAAAAAdnZ2v1RUVP9TU1P/T09P/0VFRf+kpKT/v7+//7u7u/+2trb/sbGx/6mp
        qf+jo6P/nZ2d/5eXl/+QkZH/jo2N/4mJif+CgoL/fHx8/3d3d/9AQED/IiIi/yYmJv8nJyf/Jycn/w0N
        DdkODg5cDQ0NKgYGBgQAAAAAAAAAAAAAAAB4eHi/V1dW/1VVVf9QUFD/RkZG/6moqf/Gxsb/wcHB/7y8
        vP+2trb/q6ys/6Wlpf+fn5//mZiY/5WUlf+RkpL/jI2M/4WFhf9/fn//enp6/0FBQf8iIiP/JiYm/ygn
        KP8oJyf/DQ0N2Q4ODlwNDQ0qBgYGBAAAAAAAAAAAAAAAAHp6er9YWVn/V1dX/1JSU/9ISEj/ra2t/8zM
        zP/Gxsb/wcHB/7u7u/+wsLD/qamp/6Ojo/+cnZ3/lpaW/5OTk/+Pj47/iIiI/4CBgP98fH3/QkJC/yMj
        I/8nJyf/KCgo/ygoKP8ODg7ZDg4OXA0NDSoGBgYEAAAAAAAAAAAAAAAAfXx9v1tbW/9ZWVn/VFVV/0hJ
        Sf+xsbH/0tLS/8vLy//FxcX/v7++/7Ozs/+qqqr/pKWk/6Cfn/+ampr/mpia/5GRkf+Li4r/goOD/35+
        fv9CQ0P/IyQk/ycnJ/8pKSn/KSkp/xAQENkODg5cDQ0NKgYGBgQAAAAAAAAAAAAAAAB+fn6/XV1d/1tb
        W/9WVlb/S0lJ/7Oysv/W1tb/z8/P/8nJyf/CwsL/tbW1/66trf+np6f/oqKi/5ycnP+ZmJn/k5OT/4yM
        jP+FhYX/f39//0ZFRv8kJCT/KCgo/ykpKf8pKSn/EhIS2Q4ODlwNDQ0qBgYGBAAAAAAAAAAAAAAAAIGB
        gb9eXl7/XFxc/1dYV/9KSkr/tLS0/9rb2v/S0tL/zczM/8XFxf+/v7//uLi4/7Gxsf+rq6r/o6Oj/5yc
        nP+UlZT/jY2N/4aFhv+AgID/SUlI/yMjI/8oKCj/KSkp/ykpKf8UFBTZDg4OXA0NDSoGBgYEAAAAAAAA
        AAAAAAAAg4ODv19fX/9eXl7/WVhZ/0tLS/+0tLT/3d3d/9TU1P/Ozs7/x8bH/8DAwP+5ubn/srKy/6ur
        q/+kpKT/nJyc/5WVlv+Ojo7/h4eH/4GBgf9NTU3/IyQk/ygpKP8qKSn/KSkp/xgYGNkODg5cDQ0NKgYG
        BgQAAAAAAAAAAAAAAACFhYW/YGBf/15eXv9aWln/TU1N/7a2tv/e3t7/1dXV/87Pz//Hx8f/wcHB/7m5
        uv+ysrP/rKyr/6SkpP+dnZ3/lZWW/46Ojv+Hh4f/gYGB/1BQUP8kJCT/KSkp/ykpKf8oKCj/GhkZ2Q4O
        DlwNDQ0qBgYGBAAAAAAAAAAAAAAAAIiGhr9gYGD/Xl5e/1paWv9PT0//t7e3/93d3f/U1NT/zs7O/8fH
        x//AwMD/ubm5/7Kysv+rq6v/o6Ok/5ycnP+VlZX/jo6N/4aGhv+BgYH/U1NT/yYmJv8qKir/Kisq/ygo
        Kf8bHBzYDg4OXA0NDSoGBgYEAAAAAAAAAAAAAAAAioqKv19fX/9eXl7/Wlta/1FRUf+srKz/4uLi/9LS
        0v/Mzcz/xcXG/7+/v/+4ubj/srKx/6urq/+kpKT/nZ2d/5WVlf+Njo7/h4aH/4GBgf9TUlL/KSkp/yws
        LP8qLzH/Jy4v/x4eHtgNDQ1cDQ0NKgYGBgQAAAAAAAAAAAAAAACMi4y/Xl5e/11dXf9aWlr/VVVV/1xc
        XP+qqqr/sbGx/66urv+qqqr/pKSj/52dnf+VlZX/jo6O/4eHh/+Af3//d3l3/3BwcP9paWn/XFxc/zMz
        M/8sLCz/LS0t/yswMf8nLS7/ICAg2A0NDVwNDQ0qBgYGBAAAAAAAAAAAAAAAAI6Ojr9cXFz/XFxc/1pa
        Wv9WV1f/UFFQ/0xMS/9HR0f/RERE/0BBQP8+Pj7/PDw8/zo7Ov84ODj/ODg4/zU1Nf8zMzP/MTEx/zAw
        MP8uLi//Li4u/y4tL/8qPUD/KDk+/yU4O/8jIiLYDQ0NXA0NDSoGBgYEAAAAAAAAAAAAAAAAkZGRv1pb
        W/9bW1r/WFlY/1ZWVv9UVFT/UFBQ/05OTv9MTEz/SklK/0dHR/9FRUX/QkJC/0BAQP8+Pj7/PDw8/zo6
        Ov83ODf/NTU1/zIyMv8xMTH/Ly4u/yk7P/8oO0D/JTpA/yUkJNgNDQ1bDQ0NKgcHBwQAAAAAAAAAAAAA
        AACTk5O/WFhY/1lZWf9YV1j/VVVV/1JSUv9QUFD/Tk5O/01MTf9KSkr/SEhI/0ZGRv9DQkP/QEFA/z8/
        P/89PT3/Ozs6/zg4OP82NTX/MzMz/zExMf8vLi3/IVtn/yovMf8nLi//KCgo0gwMDEcMDAwgBwcHAwAA
        AAAAAAAAAAAAAJKTkr9VVFX/VFVV/1RUVP9SUVH/T09P/01NTv9MS0z/SkpK/0hJSP9HR0f/REVE/0FB
        Qf8/Pz//Pj4+/zs7PP85Ojn/Nzc3/zQ0NP8xMTH/LzAw/y4uLv8tLCz/KS8w/yUtLv8tLS3FCgoKFAoK
        CgkDAwMBAAAAAAAAAAAAAAAAl5aXj5KSkr+QkJC/jYuLv4eHh7+EhIS/gICAv3x8fL93d3e/dHR0v3Bw
        cL9samy/ZmZmv2NjY79fX1+/W1tbv1VVVb9SUlK/Tk5Ov0pKSr9ERES/QUFBvz09Pb85OTm/MzMzvzEx
        MY8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD////////////////gAAAH4AAAB+AA
        AAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AA
        AAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB////////////////ygAAAAwAAAAYAAAAAEA
        IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAA
        AAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAA
        AAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAACCAgIBwkJCQwICAgOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcH
        Bw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcH
        Bw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOCAgIDgkJCQwICAgHAAAAAgAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAICAgHCwsLGQ0NDSwNDQ0yDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0N
        DTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0N
        DTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMg0NDSwLCwsaCAgIBwAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJCQkMDQ0NLA0NDUwODg5XDg4OWQ4ODlkODg5ZDg4OWQ4O
        DlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4O
        DlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OVw0N
        DUwNDQ0sCQkJDAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEFBQUOCgoKMgsLC1cLCwtkCwsLZgsL
        C2YLCwtmCwsLZgwMDGYMDAxmDAwMZgwMDGYMDAxmDAwMZgwMDGYMDAxmDAwMZg0NDWYNDQ1mDQ0NZg0N
        DWYNDQ1mDQ0NZg0NDWYNDQ1mDg4OZg4ODmYODg5mDg4OZg4ODmYODg5mDg4OZg4ODmYODg5mDg4OZg4O
        DmYODg5mDg4OZA4ODlcNDQ0yCAgIDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAGJiYv9cXFz/Wlpa/1VV
        V/9TU1L/UVFR/05OTv9LSkv/R0dH/0NDQ/9BQUH/Pz4//zw8PP86OTn/NTU1/zIyMv8wMDD/LS0u/yoq
        Kv8mJib/JCMk/yEhIf8eHh7/Gxsc/xkZGf8UFBT/ERER/w8PD/8ODg7/Dg4O/w4ODv8ODg7/Dg4O/w4O
        Dv8ODg7/Dg4O/w4ODv8PDw//Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAGJi
        Yf8+PDz/Pzw7/0A7Ov9AOzr/Pzo5/z06Ov89Ojr/Ozs7/zo7Ov87Ojv/Ojo6/zk5Of84ODj/Nzc3/zY2
        Nf81NTT/MzMz/zIyMv8xMTH/MTIx/zAwMP8wMDD/Ly4u/y4tLf8sKiv/Kigo/yknJ/8oJiX/JiQk/yUj
        I/8kIiH/IiEg/yAeHv8gHh3/IB0d/x8eHv8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAGNjY/9BPj3/Gpiz/xuWsP8alrD/Gpey/yKClv8+PT3/PT09/zw8PP87Ozv/Ojo6/zk5
        Of84ODj/Nzc3/zY2Nv80NDT/MzMz/zMyMv8yMTH/MDEw/y8vL/8vLy//Li4t/yJWYf8hVF//IVRf/x9T
        Xf8gU13/H1Nc/x9RXP8eUFv/HlFb/x1QWv8cT1n/HFBb/x8eHv8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAGRkZP9CPTz/GpWv/xySq/8blK3/JH+S/0A8O/8/Pj7/Pj0+/z08
        PP87Ozv/Ojo6/zk5Of84ODj/Njc3/zU1Nf80NDT/MzMz/zIyMv8xMTH/MDAv/y8vL/8uLi7/LS0s/ywq
        Kv8tKSj/KiYm/yklJf8nJCP/KCIi/yYiIf8lICD/JB8e/yMeHP8iHRz/Hx0d/x8eH/8ODg7/Dg4OZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAGVlZf9GQUD/Gpaw/xuUrf8kgJP/Qj49/0A/
        P/8/Pj//Pj4+/zw8PP86Ojr/OTk5/zc3N/82NTb/NDQ0/zMzM/8yMjL/MTEx/zAwMP8vLzD/Ly8v/y4u
        Lv8tLS3/LCws/ysrKv8gVV//H1Nd/x9UXf8gU13/H1Nc/x9RXP8fUVz/HlFb/x5QW/8dUFv/Hx4f/x8f
        IP8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAGZmZv9GQkL/GZex/yWB
        k/9GQUH/QkFB/0FBQP8/Pz//PT09/zo7Ov84ODj/NTY1/zMzM/8yMjL/MTEx/zAwMP8vLy//Ly8v/y4u
        Lv8uLi7/LS0t/ysrK/8qKiv/KSkp/ygnJ/8nJib/JiQk/yYjJP8lIyP/JSIj/yUjI/8kIiL/JCIi/yMh
        Iv8iISD/IR8g/x8fH/8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAGho
        aP9IRUX/JIOY/0dDQv9HRUX/Q0ND/0FBQP8/Pz7/Ozo7/zY2Nv8xMTH/Li4u/ywsLf8tLS3/LCws/ysr
        K/8pKin/KSkp/ygoKP8oKCj/Jycn/ycmJv8lJSX/JSQl/yQkJP8jJCP/IyIj/yIiIv8iIyL/IyMj/yQj
        JP8kJCT/IyMk/yMjI/8jIyP/IiIh/yAgIP8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAGlqav9IR0f/SUdH/0lHR/9HR0b/RERF/0FBQf88PDz/Pj8//317ff91dXX/cHBw/2tr
        a/9lZGX/YF9f/1paWv9VVVb/UVFR/0xMTP9HR0f/QUFB/z48PP83ODf/MzMz/zAwMP8wMDD/Ly8w/zAw
        MP8xMDH/Jycn/yEhIv8jIyP/JCQk/yQkJP8jIyT/IyIi/yEhIf8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAG1ra/9KSkr/SkpK/0lJSf9ISEj/RkVF/0BAQP9CQkL/ycnJ/6ur
        q/+fn57/np6e/5ycnP+ampr/l5eX/5SUlP+SkpH/j4+P/4yMjP+Iior/hoeG/4ODg/+AgID/fHx8/3h4
        eP90dHP/cXFx/3Jycv9lZWX/Tk9O/ycnJ/8iIiL/IyQj/yQkJP8jIyP/IyMj/yMhI/8ODg7/Dg4OZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAG5ubf9LS0z/S0xL/0tLS/9JSUn/RkZG/0A/
        P/+Mi4z/s7Oz/6Ojo/+ioqL/oKCg/56env+cnJz/mZqZ/5eWl/+UlJT/kJGR/46Ojv+Li4v/h4eH/4OD
        g/+Af4D/fHx8/3h4eP91dHT/cHBw/29vb/9wcHD/ZWVl/zAwMP8iIiL/IyMj/yQkJP8kJCT/JCMk/yMk
        I/8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHBwb/9NTU3/TU1N/0xM
        TP9KSkr/R0dH/z8+P/+Ojo7/q6ur/6mpqf+np6b/paSk/6Kiov+goKD/nZ6e/5ubm/+YmJj/lZSU/5GR
        kf+Ojo7/ioqL/4eHh/+Dg4P/f39//3x8fP93d3f/c3Nz/29vb/9vb2//cnJy/y8vL/8gISD/IyMj/yUk
        JP8kJCT/JCQk/yQkJP8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHFx
        cf9OTk7/Tk5P/01NTf9MTEz/SEhI/0BAQP+QkJD/sLCv/62trf+srKv/qamp/6enp/+kpKX/oaKh/5+f
        n/+cnJz/mJiY/5WVlf+RkZL/jo6O/4qKiv+Ghob/goKC/35+fv96env/dnZ2/3Fycf9vb2//cnJy/y8u
        Lv8hICH/IyMj/yQkJf8lJSX/JCQl/yUlJP8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAHNzc/9PT0//T09P/09PT/9NTUz/SUlJ/0FAQf+SkpL/tbS0/7Gxsf+vr7D/rq6u/6ur
        q/+pqan/pqWl/6Kiov+fn5//nJyc/5iZmP+UlZX/kZGR/42Njf+JiYn/hYWF/4GBgf99fX3/eXl5/3R0
        dP9wcHD/cnJy/y4uLv8hISD/JCQk/yUlJf8mJSb/JiUl/yUlJf8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAHR0dP9RUVH/UVBR/09PT/9OTk7/S0pK/0JCQv+VlZX/uLi4/7a1
        tf+zs7P/sbGx/6+vr/+tra3/qaqq/6ampv+ioqP/n5+f/5ycnP+YmJj/lJSU/5CQj/+MjIz/iIiI/4OD
        g/9/f3//e3t7/3d3dv9ycnL/cnJy/y4vL/8hISH/JCQk/yYmJf8mJib/JiYl/yYlJf8ODg7/Dg4OZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHV1df9TU1T/U1NT/1BRUf9PTk7/TExM/0JC
        Qv+Xl5f/vr6+/7q6uv+3uLf/tbW1/7Kysv+wsLD/rq2t/6uqrP+mp6b/oqKi/5+fn/+bm5v/l5aX/5KS
        kv+Oj47/i4qK/4aGhv+BgoH/fX5+/3l5ef90dHT/c3Nz/y8vL/8jISP/JCQk/yYmJv8nJif/JiYm/yYm
        Jv8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHZ3dv9VVVX/VVVV/1NS
        Uv9QUFD/TU1N/0RERP+ampr/wsLC/76/v/+8vLz/ubm6/7a2t/+zs7P/ra2t/6ampv+io6P/np6f/5ub
        mv+Wl5f/k5OS/46Ojv+Njo3/jY2N/4mJiP+Eg4P/f39//3t7e/92d3b/dXV0/y8vL/8hISH/JCUl/yYm
        Jv8nJyf/JyYm/yYnJv8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHh3
        eP9WVlb/VlZW/1RUVP9RUVH/Tk5O/0VERP+cnJz/xsbG/8LCw//AwMD/vb69/7q7uv+3t7f/sLCw/6mp
        qf+mpqb/oqGi/52dnf+ZmZn/lZWV/5SUlP+Tk5P/j4+P/4uLi/+Ghob/gYGB/319ff94eHj/dnd2/y8v
        L/8hIiP/JSUl/ycnJv8oJyj/KCcn/ycnJ/8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAHl5ef9YWFj/V1dX/1ZWVv9SU1P/T09P/0ZGRv+fn5//ysvK/8bGxv/DxMT/wcHB/729
        vv+6urr/s7Oz/6ysrP+oqKj/pKWk/6CgoP+bm5v/l5eX/5OTk/+SkpL/kJGQ/42Njf+IiIj/g4OD/35/
        f/96env/eHh4/zAwL/8iIiL/JiYl/ycnJ/8oKCj/Jycn/ygnJ/8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAHp7e/9ZWVr/WVlZ/1dXV/9UVFX/T1BP/0ZGRv+ioaL/z8/P/8rL
        yv/HyMf/xMTE/8HBwf++vb7/tra2/6+vr/+qq6v/p6en/6Kiov+enp7/mZmZ/5WVlf+UlJT/k5KS/46O
        jv+Kior/hYWF/4CAgP98fHz/eHl6/zAwMP8jIiP/JiYm/ygnKP8oKCr/KCgo/ycoKP8PDw//Dg4OZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHx8fP9bW1r/Wlpa/1hYWP9VVlb/UFBQ/0dH
        R/+kpKT/0tLS/87Ozv/Ly8v/x8fH/8PExP/AwMD/ubm5/7Kysf+tra3/qaio/6Wlpf+goKD/m5ub/5eW
        l/+ZmZr/lJSU/5CQj/+Li4v/hoaG/4GBgf99fX3/e3t7/zAwMP8jIyP/JiYm/ygoJ/8pKSj/KSgo/ygo
        KP8QEBD/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAH5+ff9cXFz/XFtc/1pZ
        Wf9XV1b/UVFR/0hISP+lpaX/1tbW/9HR0f/Ozs7/y8rK/8bGxv/DwsL/uLi3/6ysrP+nqaf/o6Oi/56e
        nv+ioqL/paWl/5+fn/+bmpv/lZaW/5GRkP+NjYz/iIiH/4KCgv9+fn7/fHx8/zEyMv8jIyP/Jicn/ygo
        KP8pKSn/KCgp/ygpKP8RERH/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAH9/
        f/9dXV3/XV1d/1paW/9YWFf/UlJS/0lJSf+kpKT/2tra/9TU1P/Q0ND/zc3N/8jJyf/ExMT/vb29/7W1
        tv+xsbH/rKys/6ioqP+ioqT/nZ2e/5iYmP+YmJj/l5eX/5KSkv+Ojo3/iImI/4ODg/9/f3//fX19/zQ0
        NP8jIyP/Jycn/ygoKP8pKSn/KSkp/ygoKP8TExP/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAICAgP9eXl7/Xl5e/1xcXP9ZWVn/U1NT/0lJSf+kpKT/3d3d/9fX1v/S0tL/z8/P/8vL
        y//Gxsb/wsLC/72+vv+4uLn/tLS0/7CwsP+srKz/p6em/6Ghof+dnZ3/mJiY/5KTk/+Ojo7/iYmJ/4SE
        hP9/gID/fn5+/zY2Nv8kIyT/Jycn/ygoKP8pKSn/KSkp/ykpKf8WFhb/DQ0NZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAIKCgv9fX17/Xl5e/11cXf9ZWln/VFRU/0pJSv+lpaX/4eHg/9na
        2v/V1dT/0NDQ/83Mzf/Hx8f/w8PD/7++vv+6urr/tbW1/7CwsP+sra3/p6en/6Kiov+enZ3/mZmY/5SU
        k/+Pj4//ioqK/4WFhf+AgID/fX19/zk5Of8jIyT/Jycn/ygoKf8pKSn/KSkp/ykpJ/8YFxj/DQ0NZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAIOEhP9gYGD/X19f/15dXf9aWlr/VVVV/0tK
        S/+lpaX/4eLi/9vb2//W1tX/0dHR/83Nzf/IyMj/w8PE/7+/v/+6u7r/tbW1/7Gxsf+tra3/qKio/6Kj
        o/+enp7/mZmZ/5SUlP+Pj4//i4qK/4WFhf+AgID/fn59/zw8PP8kJCT/Jycn/ykpKf8qKin/KSkp/ygn
        KP8ZGRr/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAISEhP9gYGD/X19f/15e
        Xv9aWlv/VlZW/0tLS/+lpaX/4uLi/9zc3P/W19b/0dLR/83Ozv/JyMn/xMTE/7/AwP+7urv/trW2/7Gx
        sf+tra3/qKin/6Ojov+enp7/mZmZ/5SUlP+Pj5D/i4qK/4aFhf+AgID/fn5+/z9AQP8lJSX/KCgn/ykp
        Kf8qKin/KSkp/ygoKP8bGxv/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAIWH
        h/9gYGD/X19f/15eXv9aWlv/VlZX/0xMTP+mpqb/4eLh/9vb2//W1tb/0dHR/83Nzf/IyMn/xMTE/7+/
        v/+7u7v/tba1/7Gxsf+tra3/qKio/6Ojo/+enp7/mZmZ/5SUlP+Pj4//ioqK/4WFhf+AgID/fX59/0JC
        Qv8mJib/KCgo/ykpKf8qKir/KSkp/ygoKP8cHBz/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAIiIiP9gYGD/X19f/15eXv9bW1v/WFdX/05OTf+np6f/4eHh/9rZ2v/V1dX/0NDQ/83N
        zf/IyMf/w8PD/76/v/+6urr/tbW1/7CxsP+sra3/p6in/6Kiov+enp7/mZmZ/5OUlP+Pj4//ioqK/4WE
        hf+AgID/fn19/0ZGRv8mJyb/Kikq/yorKv8qKyr/KSkp/ygoKP8dHh7/DQ0NZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAImJif9gYGD/X19f/15eXv9bW1v/WFhY/1BQUP+pqan/6Ojo/9bW
        1v/S09P/z8/P/8vLy//Gxsb/wsLC/76+vv+5ubn/tLS0/7CwsP+srKv/p6em/6Giov+dnZ3/mJiY/5OT
        k/+Oj47/iYmJ/4SEhP9/f4D/e3t7/0pKS/8oKCj/Kysr/ywsLP8rKir/Kikq/yknJ/8fHx//DQ0NZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAIuLi/9fX17/Xl5f/11dXf9bW1v/WVhY/1RU
        VP9XV1j//////+Pj4//T09P/z8/P/8rKyv/Fx8f/wcHC/7++v/+5ubn/tbW1/7CwsP+sraz/pqao/6Ki
        ov+enZ7/mZmZ/5STlP+QkJD/i4uL/4aGhv+BgYH/fHx8/zEwL/8rKiz/LCws/y0sLP8rKir/F4GW/ygm
        J/8iIiL/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAIyMjP9eXV3/Xl5e/11c
        XP9bW1v/WFlZ/1ZWVf9OTk7/VldW/6enp/+lpaX/pKSk/6Kiov+goKD/nJyc/5iYmP+Tk5P/jo+P/4mJ
        if+FhIX/gICA/3t7fP92dnb/cXJx/21tbf9nZmb/YmJi/11dXf9aWlr/MzMz/ywtLP8uLi3/LS0t/y0t
        Lf8sKin/KScm/ycmJP8kJCT/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAI6O
        jv9cXlz/Xl5e/1tbXP9aWlr/WFhY/1ZWV/9SU1P/Tk9P/0tLSv9HR0f/RERE/0JCQv9AQED/Pj8//zw8
        Pf87Ozv/Ozs8/zo6Ov85OTn/ODg4/zY2Nv81NDX/NDM0/zMzM/8xMTH/MDAw/y8vL/8vLy//Li4u/y8v
        L/8uLy7/Li0t/y0tLP8rKij/F4GW/ygmJ/8mJib/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAJCPkP9dW1v/XV1c/1tbW/9ZWVn/WFhY/1ZWVv9TVFP/UlJR/09PT/9OTk3/S0xL/0pK
        Sv9ISEj/R0ZH/0VERf9CQkP/QUFC/0BAQP8/Pz//Pj4+/z09Pf87Ozv/OTk6/zg4OP82Njf/NTU1/zMz
        M/8yMjL/MTEx/y8wL/8vLy//Ly0t/xeAlf8sKCf/KScm/ykmJf8nJyf/DQ0NZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAJKSkv9aWlr/W1tb/1paWv9ZWVj/V1dX/1ZVVv9UVFT/UlJR/1BP
        UP9OTk7/TU1N/0xMTP9KSkr/SElI/0dHR/9GRkb/RERE/0JCQv9AQED/Pz8//z4+Pv89PT3/Ozs7/zk5
        Of84ODj/Nzc2/zQ0NP8zMzP/MjIy/zAwMP8vLy//Lyws/y4qK/8tKCf/GI6q/ygnJv8pKCn/DQ0NZA4O
        DlcNDQ0yCAgIDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAJOTk/9ZWFj/Wlpa/1lZWf9YWFj/V1dW/1VV
        VP9TU1P/UVFR/1BPUP9PT0//TU5O/0xMTP9LSkv/SUlJ/0hISP9GRkb/RERE/0NCQv9BQUH/QD8//z4/
        Pv89PT7/Ozw8/zo6Ov85OTn/Nzg3/zU1NP8zMzP/MTIy/zAwMP8vLy//Li0t/xeAlf8tJyj/KyYm/ygk
        Jf8rKyv/DQ0NVw0NDUwNDQ0sCQkJDAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAJOTk/9XV1f/WVhY/1hY
        V/9XV1f/VlZW/1VVVf9SUlL/UFFR/09PT/9OTk7/TU1N/0xMTP9LSkr/SUlJ/0dHR/9GRkb/REVE/0JC
        Qv9BQUD/Pz8//z8/Pv89PT3/Ozw8/zo6Ov84ODj/Nzc2/zQ0Nf8zMzP/MTIy/zAwL/8vLy//Li0t/y0s
        LP8rKSj/GI6q/yclJf8tLS3/DAwMMg0NDSwLCwsaCAgIBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJKS
        kv9UVVX/VVVV/1RVVf9TU1P/UlJS/1FRUf9PT0//Tk5O/01NTf9MTEz/SktL/0tJSf9JSUn/SEhI/0ZG
        R/9FRUX/Q0ND/0FBQf9APz//Pj4+/z0+Pf88PDz/Ojo6/zk5Of84ODj/NjY2/zM0M/8yMjH/MDAw/y8v
        L/8uLi7/LS0t/y0tLf8rKSn/KSYm/yclJP8vLy//BwcHDgkJCQwICAgHAAAAAgAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAJaVlf+TkpL/kpKS/4+Qj/+NjY3/iYmJ/4eHhv+FhYX/goKD/3+Af/99fHz/enl5/3Z2
        dv90dHT/cnJy/3Bwb/9ra2v/aGho/2VmZf9jZGP/YWFh/15eX/9cXFz/WFhY/1VUVf9TUlL/UFBQ/01N
        Tf9LS0v/SEhI/0NEQ/9BQUH/Pz8//zw9PP85OTn/NjY2/zIyMv8xMTH/AAAAAQAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAD///////8AAP///////wAA////////AAD///////8AAP///////wAA+AAAAAAfAAD4AAAAAB8AAPgA
        AAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAf
        AAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgA
        AAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAf
        AAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgA
        AAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAP///////wAA////////
        AAD///////8AAP///////wAA////////AAA=
</value>
  </data>
</root>
```

`LibreHardwareMonitor/UI/Gadget.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Drawing;
using System.Windows.Forms;

namespace LibreHardwareMonitor.UI;

public abstract class Gadget : IDisposable
{
    private readonly GadgetWindow _window;

    public event EventHandler VisibleChanged;

    protected Gadget()
    {
        _window = new GadgetWindow();
        _window.Paint += delegate (object sender, PaintEventArgs e)
        {
            OnPaint(e);
        };
    }

    public virtual void Dispose()
    {
        _window.Dispose();
    }

    public Point Location
    {
        get
        {
            return _window.Location;
        }
        set
        {
            _window.Location = value;
        }
    }

    public event EventHandler LocationChanged
    {
        add
        {
            _window.LocationChanged += value;
        }
        remove
        {
            _window.LocationChanged -= value;
        }
    }

    public virtual Size Size
    {
        get
        {
            return _window.Size;
        }
        set
        {
            _window.Size = value;
        }
    }

    public event EventHandler SizeChanged
    {
        add
        {
            _window.SizeChanged += value;
        }
        remove
        {
            _window.SizeChanged -= value;
        }
    }

    public byte Opacity
    {
        get
        {
            return _window.Opacity;
        }
        set
        {
            _window.Opacity = value;
        }
    }

    public bool LockPositionAndSize
    {
        get
        {
            return _window.LockPositionAndSize;
        }
        set
        {
            _window.LockPositionAndSize = value;
        }
    }

    public bool AlwaysOnTop
    {
        get
        {
            return _window.AlwaysOnTop;
        }
        set
        {
            _window.AlwaysOnTop = value;
        }
    }

    public ContextMenuStrip ContextMenuStrip
    {
        get
        {
            return _window.ContextMenuStrip;
        }
        set
        {
            _window.ContextMenuStrip = value;
        }
    }

    public event HitTestEventHandler HitTest
    {
        add
        {
            _window.HitTest += value;
        }
        remove
        {
            _window.HitTest -= value;
        }
    }

    public event MouseEventHandler MouseDoubleClick
    {
        add
        {
            _window.MouseDoubleClick += value;
        }
        remove
        {
            _window.MouseDoubleClick -= value;
        }
    }

    public bool Visible
    {
        get
        {
            return _window.Visible;
        }
        set
        {
            if (value != _window.Visible)
            {
                _window.Visible = value;
                VisibleChanged?.Invoke(this, EventArgs.Empty);

                if (value)
                    Redraw();
            }
        }
    }

    public void Redraw()
    {
        _window.Redraw();
    }

    protected abstract void OnPaint(PaintEventArgs e);
}

```

`LibreHardwareMonitor/UI/GadgetWindow.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Drawing.Text;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Windows.Forms;

namespace LibreHardwareMonitor.UI;

public sealed class GadgetWindow : NativeWindow, IDisposable
{
    private bool _visible;
    private bool _alwaysOnTop;
    private byte _opacity = 255;
    private Point _location = new Point(100, 100);
    private Size _size = new Size(130, 84);
    private readonly MethodInfo _commandDispatch;
    private IntPtr _handleBitmapDC;
    private Size _bufferSize;
    private Graphics _graphics;

    public event EventHandler SizeChanged;
    public event EventHandler LocationChanged;
    public event HitTestEventHandler HitTest;
    public event MouseEventHandler MouseDoubleClick;

    public GadgetWindow()
    {
        Type commandType = typeof(Form).Assembly.GetType("System.Windows.Forms.Command");
        _commandDispatch = commandType.GetMethod("DispatchID",
                                                 BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Public,
                                                 null, new[] { typeof(int) }, null);

        CreateHandle(CreateParams);

        // move window to the bottom
        MoveToBottom(Handle);

        // prevent window from fading to a glass sheet when peek is invoked
        try
        {
            bool value = true;
            NativeMethods.DwmSetWindowAttribute(Handle, WindowAttribute.DWMWA_EXCLUDED_FROM_PEEK, ref value, Marshal.SizeOf(true));
        }
        catch (DllNotFoundException) { }
        catch (EntryPointNotFoundException) { }

        CreateBuffer();
    }

    private void ShowDesktopChanged(bool showDesktop)
    {
        if (showDesktop)
            MoveToTopMost(Handle);
        else
            MoveToBottom(Handle);
    }

    private void MoveToBottom(IntPtr handle)
    {
        NativeMethods.SetWindowPos(handle, HWND_BOTTOM, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOSENDCHANGING);
    }

    private void MoveToTopMost(IntPtr handle)
    {
        NativeMethods.SetWindowPos(handle, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOSENDCHANGING);
    }

    private CreateParams CreateParams
    {
        get
        {
            CreateParams cp = new CreateParams
            {
                Width = 4096,
                Height = 4096,
                X = _location.X,
                Y = _location.Y,
                ExStyle = WS_EX_LAYERED | WS_EX_TOOLWINDOW
            };

            return cp;
        }
    }

    protected override void WndProc(ref Message message)
    {
        switch (message.Msg)
        {
            case WM_COMMAND:
                {
                    // need to dispatch the message for the context menu
                    if (message.LParam == IntPtr.Zero)
                        _commandDispatch.Invoke(null, new object[] {message.WParam.ToInt32() & 0xFFFF });
                }
                break;
            case WM_NCHITTEST:
                {
                    message.Result = (IntPtr)HitResult.Caption;
                    if (HitTest != null)
                    {
                        Point p = new Point(
                                            Macros.GET_X_LPARAM(message.LParam) - _location.X,
                                            Macros.GET_Y_LPARAM(message.LParam) - _location.Y
                                           );
                        HitTestEventArgs e = new HitTestEventArgs(p, HitResult.Caption);
                        HitTest(this, e);
                        message.Result = (IntPtr)e.HitResult;
                    }
                }
                break;
            case WM_NCLBUTTONDBLCLK:
                {
                    MouseDoubleClick?.Invoke(this, new MouseEventArgs(MouseButtons.Left, 2, Macros.GET_X_LPARAM(message.LParam) - _location.X, Macros.GET_Y_LPARAM(message.LParam) - _location.Y, 0));
                    message.Result = IntPtr.Zero;
                }
                break;
            case WM_NCRBUTTONDOWN:
                {
                    message.Result = IntPtr.Zero;
                }
                break;
            case WM_NCRBUTTONUP:
                {
                    ContextMenuStrip?.Show(new Point(Macros.GET_X_LPARAM(message.LParam), Macros.GET_Y_LPARAM(message.LParam)));
                    message.Result = IntPtr.Zero;
                }
                break;
            case WM_WINDOWPOSCHANGING:
                {
                    WINDOWPOS wp = (WINDOWPOS)Marshal.PtrToStructure(message.LParam, typeof(WINDOWPOS));
                    if (!LockPositionAndSize)
                    {
                        // prevent the window from leaving the screen
                        if ((wp.flags & SWP_NOMOVE) == 0)
                        {
                            Rectangle rect = Screen.GetWorkingArea(new Rectangle(wp.x, wp.y, wp.cx, wp.cy));
                            const int margin = 16;
                            wp.x = Math.Max(wp.x, rect.Left - wp.cx + margin);
                            wp.x = Math.Min(wp.x, rect.Right - margin);
                            wp.y = Math.Max(wp.y, rect.Top - wp.cy + margin);
                            wp.y = Math.Min(wp.y, rect.Bottom - margin);
                        }

                        // update location and fire event
                        if ((wp.flags & SWP_NOMOVE) == 0)
                        {
                            if (_location.X != wp.x || _location.Y != wp.y)
                            {
                                _location = new Point(wp.x, wp.y);
                                LocationChanged?.Invoke(this, EventArgs.Empty);
                            }
                        }

                        // update size and fire event
                        if ((wp.flags & SWP_NOSIZE) == 0)
                        {
                            if (_size.Width != wp.cx || _size.Height != wp.cy)
                            {
                                _size = new Size(wp.cx, wp.cy);
                                SizeChanged?.Invoke(this, EventArgs.Empty);
                            }
                        }

                        // update the size of the layered window
                        if ((wp.flags & SWP_NOSIZE) == 0)
                            NativeMethods.UpdateLayeredWindow(Handle, IntPtr.Zero, IntPtr.Zero, ref _size, IntPtr.Zero, IntPtr.Zero, 0, IntPtr.Zero, 0);

                        // update the position of the layered window
                        if ((wp.flags & SWP_NOMOVE) == 0)
                            NativeMethods.SetWindowPos(Handle, IntPtr.Zero, _location.X, _location.Y, 0, 0, SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSENDCHANGING);
                    }

                    // do not forward any move or size messages
                    wp.flags |= SWP_NOSIZE | SWP_NOMOVE;

                    // suppress any frame changed events
                    wp.flags &= ~SWP_FRAMECHANGED;

                    Marshal.StructureToPtr(wp, message.LParam, false);
                    message.Result = IntPtr.Zero;
                }
                break;
            default:
                {
                    base.WndProc(ref message);
                }
                break;
        }
    }

    private BlendFunction CreateBlendFunction()
    {
        return new BlendFunction { BlendOp = AC_SRC_OVER, BlendFlags = 0, SourceConstantAlpha = _opacity, AlphaFormat = AC_SRC_ALPHA };
    }

    private void CreateBuffer()
    {
        IntPtr handleScreenDC = NativeMethods.GetDC(IntPtr.Zero);
        _handleBitmapDC = NativeMethods.CreateCompatibleDC(handleScreenDC);
        NativeMethods.ReleaseDC(IntPtr.Zero, handleScreenDC);
        _bufferSize = _size;

        BITMAPINFO info = new BITMAPINFO();
        info.Size = Marshal.SizeOf(info);
        info.Width = _size.Width;
        info.Height = -_size.Height;
        info.BitCount = 32;
        info.Planes = 1;

        IntPtr hBmp = NativeMethods.CreateDIBSection(_handleBitmapDC, ref info, 0, out IntPtr _, IntPtr.Zero, 0);
        IntPtr hBmpOld = NativeMethods.SelectObject(_handleBitmapDC, hBmp);
        NativeMethods.DeleteObject(hBmpOld);

        _graphics = Graphics.FromHdc(_handleBitmapDC);

        if (Environment.OSVersion.Version.Major > 5)
        {
            _graphics.TextRenderingHint = TextRenderingHint.SystemDefault;
            _graphics.SmoothingMode = SmoothingMode.HighQuality;
        }
    }

    private void DisposeBuffer()
    {
        _graphics.Dispose();
        NativeMethods.DeleteDC(_handleBitmapDC);
    }

    public void Dispose()
    {
        DisposeBuffer();
    }

    public PaintEventHandler Paint;

    public void Redraw()
    {
        if (!_visible || Paint == null)
            return;

        if (_size != _bufferSize)
        {
            DisposeBuffer();
            CreateBuffer();
        }

        Paint(this, new PaintEventArgs(_graphics, new Rectangle(Point.Empty, _size)));
        Point pointSource = Point.Empty;
        BlendFunction blend = CreateBlendFunction();
        NativeMethods.UpdateLayeredWindow(Handle, IntPtr.Zero, IntPtr.Zero, ref _size, _handleBitmapDC, ref pointSource, 0, ref blend, ULW_ALPHA);
        // make sure the window is at the right location
        NativeMethods.SetWindowPos(Handle, IntPtr.Zero, _location.X, _location.Y, 0, 0, SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSENDCHANGING);
    }

    public byte Opacity
    {
        get
        {
            return _opacity;
        }
        set
        {
            if (_opacity != value)
            {
                _opacity = value;
                BlendFunction blend = CreateBlendFunction();
                NativeMethods.UpdateLayeredWindow(Handle, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, 0, ref blend, ULW_ALPHA);
            }
        }
    }

    public bool Visible
    {
        get
        {
            return _visible;
        }
        set
        {
            if (_visible != value)
            {
                _visible = value;
                NativeMethods.SetWindowPos(Handle, IntPtr.Zero, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER | (value ? SWP_SHOWWINDOW : SWP_HIDEWINDOW));

                if (value)
                {
                    if (!_alwaysOnTop)
                        ShowDesktop.Instance.ShowDesktopChanged += ShowDesktopChanged;
                }
                else
                {
                    if (!_alwaysOnTop)
                        ShowDesktop.Instance.ShowDesktopChanged -= ShowDesktopChanged;
                }
            }
        }
    }

    // if locked, the window can not be moved or resized
    public bool LockPositionAndSize { get; set; }

    public bool AlwaysOnTop
    {
        get
        {
            return _alwaysOnTop;
        }
        set
        {
            if (value != _alwaysOnTop)
            {
                _alwaysOnTop = value;

                if (_alwaysOnTop)
                {
                    if (_visible)
                        ShowDesktop.Instance.ShowDesktopChanged -= ShowDesktopChanged;

                    MoveToTopMost(Handle);
                }
                else
                {
                    MoveToBottom(Handle);

                    if (_visible)
                        ShowDesktop.Instance.ShowDesktopChanged += ShowDesktopChanged;
                }
            }
        }
    }

    public Size Size
    {
        get
        {
            return _size;
        }
        set
        {
            if (_size != value)
            {
                _size = value;
                NativeMethods.UpdateLayeredWindow(Handle, IntPtr.Zero, IntPtr.Zero, ref _size, IntPtr.Zero, IntPtr.Zero, 0, IntPtr.Zero, 0);
                SizeChanged?.Invoke(this, EventArgs.Empty);
            }
        }
    }

    public Point Location
    {
        get
        {
            return _location;
        }
        set
        {
            if (_location != value)
            {
                _location = value;
                NativeMethods.SetWindowPos(Handle, IntPtr.Zero, _location.X, _location.Y, 0, 0, SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSENDCHANGING);
                LocationChanged?.Invoke(this, EventArgs.Empty);
            }
        }
    }

    public ContextMenuStrip ContextMenuStrip { get; set; }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    private struct BlendFunction
    {
        public byte BlendOp;
        public byte BlendFlags;
        public byte SourceConstantAlpha;
        public byte AlphaFormat;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    private struct WINDOWPOS
    {
        public readonly IntPtr hwnd;
        public readonly IntPtr hwndInsertAfter;
        public int x;
        public int y;
        public readonly int cx;
        public readonly int cy;
        public uint flags;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct BITMAPINFO
    {
        public int Size;
        public int Width;
        public int Height;
        public short Planes;
        public short BitCount;
        public int Compression;
        public int SizeImage;
        public int XPelsPerMeter;
        public int YPelsPerMeter;
        public int ClrUsed;
        public int ClrImportant;
        public int Colors;
    }

    public static readonly IntPtr HWND_BOTTOM = (IntPtr)1;
    public static readonly IntPtr HWND_TOPMOST = (IntPtr)(-1);

    public const int WS_EX_LAYERED = 0x00080000;
    public const int WS_EX_TOOLWINDOW = 0x00000080;

    public const uint SWP_NOSIZE = 0x0001;
    public const uint SWP_NOMOVE = 0x0002;
    public const uint SWP_NOACTIVATE = 0x0010;
    public const uint SWP_FRAMECHANGED = 0x0020;
    public const uint SWP_HIDEWINDOW = 0x0080;
    public const uint SWP_SHOWWINDOW = 0x0040;
    public const uint SWP_NOZORDER = 0x0004;
    public const uint SWP_NOSENDCHANGING = 0x0400;

    public const int ULW_COLORKEY = 0x00000001;
    public const int ULW_ALPHA = 0x00000002;
    public const int ULW_OPAQUE = 0x00000004;

    public const byte AC_SRC_OVER = 0x00;
    public const byte AC_SRC_ALPHA = 0x01;

    public const int WM_NCHITTEST = 0x0084;
    public const int WM_NCLBUTTONDBLCLK = 0x00A3;
    public const int WM_NCLBUTTONDOWN = 0x00A1;
    public const int WM_NCLBUTTONUP = 0x00A2;
    public const int WM_NCRBUTTONDOWN = 0x00A4;
    public const int WM_NCRBUTTONUP = 0x00A5;
    public const int WM_WINDOWPOSCHANGING = 0x0046;
    public const int WM_COMMAND = 0x0111;

    public const int TPM_RIGHTBUTTON = 0x0002;
    public const int TPM_VERTICAL = 0x0040;

    private enum WindowAttribute : int
    {
        DWMWA_NCRENDERING_ENABLED = 1,
        DWMWA_NCRENDERING_POLICY,
        DWMWA_TRANSITIONS_FORCEDISABLED,
        DWMWA_ALLOW_NCPAINT,
        DWMWA_CAPTION_BUTTON_BOUNDS,
        DWMWA_NONCLIENT_RTL_LAYOUT,
        DWMWA_FORCE_ICONIC_REPRESENTATION,
        DWMWA_FLIP3D_POLICY,
        DWMWA_EXTENDED_FRAME_BOUNDS,
        DWMWA_HAS_ICONIC_BITMAP,
        DWMWA_DISALLOW_PEEK,
        DWMWA_EXCLUDED_FROM_PEEK,
        DWMWA_LAST
    }

    /// <summary>
    /// Some macros imported and converted from the Windows SDK
    /// </summary>
    private static class Macros
    {
        public static ushort LOWORD(IntPtr l)
        {
            return (ushort)((ulong)l & 0xFFFF);
        }

        public static ushort HIWORD(IntPtr l)
        {
            return (ushort)(((ulong)l >> 16) & 0xFFFF);
        }

        public static int GET_X_LPARAM(IntPtr lp)
        {
            return (short)LOWORD(lp);
        }

        public static int GET_Y_LPARAM(IntPtr lp)
        {
            return (short)HIWORD(lp);
        }
    }

    /// <summary>
    /// Imported native methods
    /// </summary>
    private static class NativeMethods
    {
        private const string USER = "user32.dll";
        private const string GDI = "gdi32.dll";
        private const string DWMAPI = "dwmapi.dll";

        [DllImport(USER, CallingConvention = CallingConvention.Winapi)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool UpdateLayeredWindow(IntPtr hwnd, IntPtr hdcDst, IntPtr pptDst, ref Size psize, IntPtr hdcSrc, IntPtr pprSrc, int crKey, IntPtr pblend, int dwFlags);

        [DllImport(USER, CallingConvention = CallingConvention.Winapi)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool UpdateLayeredWindow(IntPtr hwnd, IntPtr hdcDst, IntPtr pptDst, ref Size psize, IntPtr hdcSrc, ref Point pprSrc, int crKey, ref BlendFunction pblend, int dwFlags);

        [DllImport(USER, CallingConvention = CallingConvention.Winapi)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool UpdateLayeredWindow(IntPtr hwnd, IntPtr hdcDst, IntPtr pptDst, IntPtr psize, IntPtr hdcSrc, IntPtr pprSrc, int crKey, ref BlendFunction pblend, int dwFlags);

        [DllImport(USER, CallingConvention = CallingConvention.Winapi)]
        public static extern IntPtr GetDC(IntPtr hWnd);

        [DllImport(USER, CallingConvention = CallingConvention.Winapi)]
        public static extern int ReleaseDC(IntPtr hWnd, IntPtr hDC);

        [DllImport(USER, CallingConvention = CallingConvention.Winapi)]
        public static extern bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int X, int Y, int cx, int cy, uint uFlags);

        [DllImport(USER, CallingConvention = CallingConvention.Winapi)]
        public static extern bool TrackPopupMenuEx(IntPtr hMenu, uint uFlags, int x, int y, IntPtr hWnd, IntPtr tpmParams);

        [DllImport(GDI, CallingConvention = CallingConvention.Winapi)]
        public static extern IntPtr CreateCompatibleDC(IntPtr hDC);

        [DllImport(GDI, CallingConvention = CallingConvention.Winapi)]
        public static extern IntPtr CreateDIBSection(IntPtr hdc, [In] ref BITMAPINFO pbmi, uint pila, out IntPtr ppvBits, IntPtr hSection, uint dwOffset);

        [DllImport(GDI, CallingConvention = CallingConvention.Winapi)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool DeleteDC(IntPtr hdc);

        [DllImport(GDI, CallingConvention = CallingConvention.Winapi)]
        public static extern IntPtr SelectObject(IntPtr hDC, IntPtr hObject);

        [DllImport(GDI, CallingConvention = CallingConvention.Winapi)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool DeleteObject(IntPtr hObject);

        [DllImport(DWMAPI, CallingConvention = CallingConvention.Winapi)]
        public static extern int DwmSetWindowAttribute(IntPtr hwnd, WindowAttribute dwAttribute, ref bool pvAttribute, int cbAttribute);
    }
}

public delegate void HitTestEventHandler(object sender, HitTestEventArgs e);

public enum HitResult
{
    Transparent = -1,
    Nowhere = 0,
    Client = 1,
    Caption = 2,
    Left = 10,
    Right = 11,
    Top = 12,
    TopLeft = 13,
    TopRight = 14,
    Bottom = 15,
    BottomLeft = 16,
    BottomRight = 17,
    Border = 18
}

public class HitTestEventArgs : EventArgs
{
    public HitTestEventArgs(Point location, HitResult hitResult)
    {
        Location = location;
        HitResult = hitResult;
    }
    public Point Location { get; }
    public HitResult HitResult { get; set; }
}
```

`LibreHardwareMonitor/UI/HardwareNode.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using LibreHardwareMonitor.Hardware;
using LibreHardwareMonitor.Utilities;
using System;
using System.Collections.Generic;
using System.Text;

namespace LibreHardwareMonitor.UI;

public class HardwareNode : Node, IExpandPersistNode
{
    private readonly PersistentSettings _settings;
    private readonly UnitManager _unitManager;
    private readonly List<TypeNode> _typeNodes = new List<TypeNode>();
    private readonly string _expandedIdentifier;
    private bool _expanded;

    public event EventHandler PlotSelectionChanged;

    public HardwareNode(IHardware hardware, PersistentSettings settings, UnitManager unitManager)
    {
        _settings = settings;
        _unitManager = unitManager;
        _expandedIdentifier = new Identifier(hardware.Identifier, "expanded").ToString();
        Hardware = hardware;
        Image = HardwareTypeImage.Instance.GetImage(hardware.HardwareType);

        foreach (SensorType sensorType in Enum.GetValues(typeof(SensorType)))
            _typeNodes.Add(new TypeNode(sensorType, hardware.Identifier, _settings));

        foreach (ISensor sensor in hardware.Sensors)
            SensorAdded(sensor);

        hardware.SensorAdded += SensorAdded;
        hardware.SensorRemoved += SensorRemoved;

        _expanded = settings.GetValue(_expandedIdentifier, true);
    }


    public override string Text
    {
        get { return Hardware.Name; }
        set { Hardware.Name = value; }
    }

    public override string ToolTip
    {
        get
        {
            IDictionary<string, string> properties = Hardware.Properties;

            if (properties.Count > 0)
            {
                StringBuilder stringBuilder = new();
                stringBuilder.AppendLine("Hardware properties:");
                    
                foreach (KeyValuePair<string, string> property in properties)
                    stringBuilder.AppendFormat(" • {0}: {1}\n", property.Key, property.Value);

                return stringBuilder.ToString();
            }

            return null;
        }
    }

    public IHardware Hardware { get; }

    public bool Expanded
    {
        get => _expanded;
        set
        {
            _expanded = value;
            _settings.SetValue(_expandedIdentifier, _expanded);
        }
    }

    private void UpdateNode(TypeNode node)
    {
        if (node.Nodes.Count > 0)
        {
            if (!Nodes.Contains(node))
            {
                int i = 0;
                while (i < Nodes.Count && ((TypeNode)Nodes[i]).SensorType < node.SensorType)
                    i++;

                Nodes.Insert(i, node);
            }
        }
        else
        {
            if (Nodes.Contains(node))
                Nodes.Remove(node);
        }
    }

    private void SensorRemoved(ISensor sensor)
    {
        foreach (TypeNode typeNode in _typeNodes)
        {
            if (typeNode.SensorType == sensor.SensorType)
            {
                SensorNode sensorNode = null;
                foreach (Node node in typeNode.Nodes)
                {
                    if (node is SensorNode n && n.Sensor == sensor)
                        sensorNode = n;
                }
                if (sensorNode != null)
                {
                    sensorNode.PlotSelectionChanged -= SensorPlotSelectionChanged;
                    typeNode.Nodes.Remove(sensorNode);
                    UpdateNode(typeNode);
                }
            }
        }
        PlotSelectionChanged?.Invoke(this, null);
    }

    private void InsertSorted(Node node, ISensor sensor)
    {
        int i = 0;
        while (i < node.Nodes.Count && ((SensorNode)node.Nodes[i]).Sensor.Index < sensor.Index)
            i++;

        SensorNode sensorNode = new SensorNode(sensor, _settings, _unitManager);
        sensorNode.PlotSelectionChanged += SensorPlotSelectionChanged;
        node.Nodes.Insert(i, sensorNode);
    }

    private void SensorPlotSelectionChanged(object sender, EventArgs e)
    {
        PlotSelectionChanged?.Invoke(this, null);
    }

    private void SensorAdded(ISensor sensor)
    {
        foreach (TypeNode typeNode in _typeNodes)
        {
            if (typeNode.SensorType == sensor.SensorType)
            {
                InsertSorted(typeNode, sensor);
                UpdateNode(typeNode);
            }
        }

        PlotSelectionChanged?.Invoke(this, null);
    }
}
```

`LibreHardwareMonitor/UI/HardwareTypeImage.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Drawing;
using System.Collections.Generic;
using LibreHardwareMonitor.Hardware;

namespace LibreHardwareMonitor.UI;

public class HardwareTypeImage
{
    private readonly IDictionary<HardwareType, Image> _images = new Dictionary<HardwareType, Image>();

    private HardwareTypeImage() { }

    public static HardwareTypeImage Instance { get; } = new HardwareTypeImage();

    public Image GetImage(HardwareType hardwareType)
    {
        if (_images.TryGetValue(hardwareType, out Image image))
            return image;


        switch (hardwareType)
        {
            case HardwareType.Cpu:
                image = Utilities.EmbeddedResources.GetImage("cpu.png");
                break;
            case HardwareType.GpuNvidia:
                image = Utilities.EmbeddedResources.GetImage("nvidia.png");
                break;
            case HardwareType.GpuAmd:
                image = Utilities.EmbeddedResources.GetImage("amd.png");
                break;
            case HardwareType.GpuIntel:
                image = Utilities.EmbeddedResources.GetImage("intel.png");
                break;
            case HardwareType.Storage:
                image = Utilities.EmbeddedResources.GetImage("hdd.png");
                break;
            case HardwareType.Motherboard:
                image = Utilities.EmbeddedResources.GetImage("mainboard.png");
                break;
            case HardwareType.SuperIO:
            case HardwareType.EmbeddedController:
                image = Utilities.EmbeddedResources.GetImage("chip.png");
                break;
            case HardwareType.Memory:
                image = Utilities.EmbeddedResources.GetImage("ram.png");
                break;
            case HardwareType.Network:
                image = Utilities.EmbeddedResources.GetImage("nic.png");
                break;
            case HardwareType.Cooler:
                image = Utilities.EmbeddedResources.GetImage("fan.png");
                break;
            case HardwareType.Psu:
                image = Utilities.EmbeddedResources.GetImage("power-supply.png");
                break;
            case HardwareType.Battery:
                image = Utilities.EmbeddedResources.GetImage("battery.png");
                break;
            case HardwareType.PowerMonitor:
                image = Utilities.EmbeddedResources.GetImage("powermonitor.png");
                break;
            default:
                image = new Bitmap(1, 1);
                break;
        }
        _images.Add(hardwareType, image);
        return image;
    }
}

```

`LibreHardwareMonitor/UI/IExpandPersistNode.cs`:

```cs
namespace LibreHardwareMonitor.UI;

public interface IExpandPersistNode
{
    bool Expanded { get; set; }
}
```

`LibreHardwareMonitor/UI/InterfacePortForm.Designer.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.UI
{
    partial class InterfacePortForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(InterfacePortForm));
            this.portOKButton = new System.Windows.Forms.Button();
            this.portCancelButton = new System.Windows.Forms.Button();
            this.label1 = new System.Windows.Forms.Label();
            this.label2 = new System.Windows.Forms.Label();
            this.label3 = new System.Windows.Forms.Label();
            this.label4 = new System.Windows.Forms.Label();
            this.webServerLinkLabel = new System.Windows.Forms.LinkLabel();
            this.portNumericUpDn = new System.Windows.Forms.NumericUpDown();
            this.label5 = new System.Windows.Forms.Label();
            this.interfaceLabel = new System.Windows.Forms.Label();
            this.interfaceComboBox = new System.Windows.Forms.ComboBox();
            ((System.ComponentModel.ISupportInitialize)(this.portNumericUpDn)).BeginInit();
            this.SuspendLayout();
            // 
            // portOKButton
            // 
            this.portOKButton.Location = new System.Drawing.Point(244, 162);
            this.portOKButton.Name = "portOKButton";
            this.portOKButton.Size = new System.Drawing.Size(75, 23);
            this.portOKButton.TabIndex = 0;
            this.portOKButton.Text = "OK";
            this.portOKButton.UseVisualStyleBackColor = true;
            this.portOKButton.Click += new System.EventHandler(this.PortOKButton_Click);
            // 
            // portCancelButton
            // 
            this.portCancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.portCancelButton.Location = new System.Drawing.Point(162, 162);
            this.portCancelButton.Name = "portCancelButton";
            this.portCancelButton.Size = new System.Drawing.Size(75, 23);
            this.portCancelButton.TabIndex = 1;
            this.portCancelButton.Text = "Cancel";
            this.portCancelButton.UseVisualStyleBackColor = true;
            this.portCancelButton.Click += new System.EventHandler(this.PortCancelButton_Click);
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(13, 131);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(377, 13);
            this.label1.TabIndex = 3;
            this.label1.Text = "Note: You will need to open the port in firewall settings of the operating system" +
    ".";
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(13, 34);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(190, 13);
            this.label2.TabIndex = 4;
            this.label2.Text = "Port number for the remote web server:";
            // 
            // label3
            // 
            this.label3.AutoSize = true;
            this.label3.Location = new System.Drawing.Point(13, 64);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(443, 13);
            this.label3.TabIndex = 5;
            this.label3.Text = "If the web server is running then it will need to be restarted for the port chang" +
    "e to take effect.";
            // 
            // label4
            // 
            this.label4.AutoSize = true;
            this.label4.Location = new System.Drawing.Point(13, 86);
            this.label4.Name = "label4";
            this.label4.Size = new System.Drawing.Size(262, 13);
            this.label4.TabIndex = 6;
            this.label4.Text = "The web server will be accessible from the browser at ";
            // 
            // webServerLinkLabel
            // 
            this.webServerLinkLabel.AutoSize = true;
            this.webServerLinkLabel.Location = new System.Drawing.Point(269, 86);
            this.webServerLinkLabel.Name = "webServerLinkLabel";
            this.webServerLinkLabel.Size = new System.Drawing.Size(55, 13);
            this.webServerLinkLabel.TabIndex = 7;
            this.webServerLinkLabel.TabStop = true;
            this.webServerLinkLabel.Text = "linkLabel1";
            this.webServerLinkLabel.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.WebServerLinkLabel_LinkClicked);
            // 
            // portNumericUpDn
            // 
            this.portNumericUpDn.Location = new System.Drawing.Point(208, 32);
            this.portNumericUpDn.Maximum = new decimal(new int[] {
            20000,
            0,
            0,
            0});
            this.portNumericUpDn.Minimum = new decimal(new int[] {
            8080,
            0,
            0,
            0});
            this.portNumericUpDn.Name = "portNumericUpDn";
            this.portNumericUpDn.Size = new System.Drawing.Size(75, 20);
            this.portNumericUpDn.TabIndex = 8;
            this.portNumericUpDn.Value = new decimal(new int[] {
            8080,
            0,
            0,
            0});
            this.portNumericUpDn.ValueChanged += new System.EventHandler(this.PortNumericUpDn_ValueChanged);
            this.portNumericUpDn.KeyUp += new System.Windows.Forms.KeyEventHandler(this.PortNumericUpDn_KeyUp);
            // 
            // label5
            // 
            this.label5.AutoSize = true;
            this.label5.Location = new System.Drawing.Point(13, 109);
            this.label5.Name = "label5";
            this.label5.Size = new System.Drawing.Size(304, 13);
            this.label5.TabIndex = 9;
            this.label5.Text = "You will have to start the server by clicking Run from the menu.";
            // 
            // interfaceLabel
            // 
            this.interfaceLabel.AutoSize = true;
            this.interfaceLabel.Location = new System.Drawing.Point(14, 8);
            this.interfaceLabel.Name = "interfaceLabel";
            this.interfaceLabel.Size = new System.Drawing.Size(217, 13);
            this.interfaceLabel.TabIndex = 10;
            this.interfaceLabel.Text = "Network interface for the remote web server:";
            // 
            // interfaceComboBox
            // 
            this.interfaceComboBox.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            this.interfaceComboBox.FormattingEnabled = true;
            this.interfaceComboBox.Location = new System.Drawing.Point(233, 6);
            this.interfaceComboBox.Margin = new System.Windows.Forms.Padding(2);
            this.interfaceComboBox.Name = "interfaceComboBox";
            this.interfaceComboBox.Size = new System.Drawing.Size(221, 21);
            this.interfaceComboBox.TabIndex = 11;
            this.interfaceComboBox.SelectedIndexChanged += new System.EventHandler(this.interfaceComboBox_SelectedIndexChanged);
            // 
            // InterfacePortForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.CancelButton = this.portCancelButton;
            this.ClientSize = new System.Drawing.Size(466, 202);
            this.Controls.Add(this.interfaceComboBox);
            this.Controls.Add(this.interfaceLabel);
            this.Controls.Add(this.label5);
            this.Controls.Add(this.portNumericUpDn);
            this.Controls.Add(this.webServerLinkLabel);
            this.Controls.Add(this.label4);
            this.Controls.Add(this.label3);
            this.Controls.Add(this.label2);
            this.Controls.Add(this.label1);
            this.Controls.Add(this.portCancelButton);
            this.Controls.Add(this.portOKButton);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "InterfacePortForm";
            this.SizeGripStyle = System.Windows.Forms.SizeGripStyle.Hide;
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
            this.Text = "Set Port";
            this.Load += new System.EventHandler(this.PortForm_Load);
            ((System.ComponentModel.ISupportInitialize)(this.portNumericUpDn)).EndInit();
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.Button portOKButton;
        private System.Windows.Forms.Button portCancelButton;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.Label label3;
        private System.Windows.Forms.Label label4;
        private System.Windows.Forms.LinkLabel webServerLinkLabel;
        private System.Windows.Forms.NumericUpDown portNumericUpDn;
        private System.Windows.Forms.Label label5;
        private System.Windows.Forms.Label interfaceLabel;
        private System.Windows.Forms.ComboBox interfaceComboBox;
    }
}

```

`LibreHardwareMonitor/UI/InterfacePortForm.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Windows.Forms;
using System.Net;
using System.Net.Sockets;
using System.Diagnostics;
using static System.Windows.Forms.VisualStyles.VisualStyleElement;
using System.Net.NetworkInformation;

namespace LibreHardwareMonitor.UI;

public partial class InterfacePortForm : Form
{
    private readonly MainForm _parent;
    private string _localIP;
    
    public InterfacePortForm(MainForm m)
    {
        InitializeComponent();
        _parent = m;
        _localIP = LoadNetworkInterfaces(_parent.Server.ListenerIp);
    }

    private string LoadNetworkInterfaces(string selectedListenerIp)
    {
        IPHostEntry host;
        interfaceComboBox.Items.Clear();
        host = Dns.GetHostEntry(Dns.GetHostName());
        foreach (IPAddress ip in host.AddressList)
        {
            if (ip.AddressFamily == AddressFamily.InterNetwork)
                interfaceComboBox.Items.Add(ip.ToString());
        }

        interfaceComboBox.Items.Add("0.0.0.0");

        // select the last one by default to match the existing behavior
        if (interfaceComboBox.Items.Count > 0)
        {
            interfaceComboBox.SelectedIndex = interfaceComboBox.Items.Count - 1;
        }

        // check to see if the selected listener IP is in our list.
        if (interfaceComboBox.Items.Contains(selectedListenerIp))
        {
            // default it to the previously selected IP.
            interfaceComboBox.SelectedItem = selectedListenerIp;
        }
        return interfaceComboBox.SelectedItem as string;
    }

    private void PortNumericUpDn_ValueChanged(object sender, EventArgs e)
    {
        string url = "http://" + _localIP + ":" + portNumericUpDn.Value + "/";
        webServerLinkLabel.Text = url;
        webServerLinkLabel.Links.Remove(webServerLinkLabel.Links[0]);
        webServerLinkLabel.Links.Add(0, webServerLinkLabel.Text.Length, url);
    }

    private void PortOKButton_Click(object sender, EventArgs e)
    {
        _parent.Server.ListenerPort = (int)portNumericUpDn.Value;
        _parent.Server.ListenerIp = _localIP;
        Close();
    }

    private void PortCancelButton_Click(object sender, EventArgs e)
    {
        Close();
    }

    private void PortForm_Load(object sender, EventArgs e)
    {
        interfaceComboBox.SelectedValue = _parent.Server.ListenerIp;
        portNumericUpDn.Value = _parent.Server.ListenerPort;
        PortNumericUpDn_ValueChanged(null, null);
    }

    private void WebServerLinkLabel_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
    {
        try
        {
            Process.Start(new ProcessStartInfo(e.Link.LinkData.ToString()));
        }
        catch { }
    }

    private void PortNumericUpDn_KeyUp(object sender, KeyEventArgs e)
    {
        PortNumericUpDn_ValueChanged(null, null);
    }

    private void interfaceComboBox_SelectedIndexChanged(object sender, EventArgs e)
    {

        _localIP = interfaceComboBox.SelectedItem as string;
        PortNumericUpDn_ValueChanged(null, null);
    }
}

```

`LibreHardwareMonitor/UI/InterfacePortForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Drawing" name="System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
  <data name="$this.Icon" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        AAABAAMAEBAAAAEAIABoBAAANgAAACAgAAABACAAqBAAAJ4EAAAwMAAAAQAgAKglAABGFQAAKAAAABAA
        AAAgAAAAAQAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEU8OykuDgdIIxQSURwdHU8ZGhpPFhYWTxQU
        FE8SEhJPDxAPTw0KCk8KBQRPCAQDTwcDAU8HAQBPBgQEUQUFBTxLVVb/L215/zdXXP89Ozv/ODc3/zM0
        M/8vLy//Kioq/yYlJf8iJif/Gycp/xggI/8UHiD/Eh4g/w4SE/8GBARRQWRr/xGXtP8yUln/NDIx/y4u
        Lf8qKir/KSgo/ycnJ/8lJCP/Iikq/xs4Pf8aOD7/GzpB/xo4Pf8SGhv/BwMDT01aXP46Ulj+Pzc0/kdH
        R/5MTU3+Q0ND/jw8PP43Nzf+Ly8v/igoKP4lKCn+Iico/hwiI/4cHyD/FBMU/wYHBk9XVVX+Rj8+/klJ
        Sf6ioqL+rq+u/p+fn/6YmJj+j4+P/oSEhP56enr+dXJy/mNgYP4iHx7+Gxka/xUVFf8HBwdPW1pa/kVF
        RP5YWFj+rq6u/r6+vv6wsK/+qamp/qCgoP6UlJT+iYmJ/oGBgf5xcXH+JCQk/hsbG/8WFhb/BwcHT15e
        Xv5ISEj+Wlpa/rW1tf7Gxsb+tra2/qysq/6hoaL+lpaW/oyMjP6EhIT+cnJy/iQkJP4cHBz/GBgY/wcH
        B09jY2P+TUxM/l5eXv7AwMD+0dHR/r6+vv6vr6/+o6Ok/pmYmf6Rk5P+iouK/nd4d/4lJSX+HR0d/xkZ
        Gf8HBwdPZ2dn/lBQUP5iYmL+ysrK/tzc3P7Hxsf+tbS1/qmpqf6fn5/+mJiY/o6Pj/57e3z+JSUm/h4e
        Hv8aGhr/CAgIT2tra/5TU1P+ZGRk/tLS0v7j5eP+zMzM/ry8vP6wsLD+pqam/pubm/6TkZH+f39//igo
        KP4fHx7/HBwc/wkJCk9ubm7+VlVW/mZlZv7X1tf+6Ojo/tPS0/7Hx8f+urq6/qurq/6dnp7+lJSU/oGB
        gP4sLCz+Hx4e/x4dHP8LCwtPb29v/lZWVv5nZ2j+4eHh/vLx8v7Z2dn+zc3N/sDAwP6wsrL+pKOk/pmZ
        mf6Ghob+MDAw/h8gH/8eHx//DQsNT29vb/5YWFj+WVpa/sHBwf7V1dX+wMC//rW1tP6pqan+m5ub/o6P
        jv6FhYX+cXFx/i4qKv4gLC7/Hiot/w4JB09vb3D+Wlla/lJSUf5VVVX+YGBg/ltbWv5VVVP+Tk5O/kdH
        R/5BQUH+Ozs6/jAvL/4oKCj+Izk9/x8tL/8QCQhRbm5u/lVVVf5SUlL+S0tL/kRERP5BQUH+PT09/jk5
        Of41NTX+MzIy/i8vLv4sKSj+Jy4v/h9DTP8iLjH/Ew0KSHp7ev5qamr+ZWVl/mFhYv5cXFz+WFhY/lNS
        U/5NTU3+R0ZH/kJCQv49PDz+NzU1/jAxMf4qMTL/Jigp/x4cHCn//wAAAAEAAAABAAAAAQAAAAEAAAAB
        AAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAKAAAACAAAABAAAAAAQAgAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAwMBBwcHAwYGBgQGBgYEBgYGBAYG
        BgQGBgYEBgYGBAYGBgQGBgYEBgYGBAYGBgQGBgYEBgYGBAYGBgQGBgYEBgYGBAYGBgQGBgYEBgYGBAYG
        BgQGBgYEBgYGBAYGBgQGBgYEBwcHAwUFBQIAAAAAAAAAAAAAAAAAAAAAAAAAAAoKCgkMDAwgDQ0NKg0N
        DSoNDQ0qDQ0NKg0NDSoNDQ0qDQ0NKg0NDSoNDQ0qDQ0NKg0NDSoNDQ0qDQ0NKg0NDSoNDQ0qDQ0NKg0N
        DSoNDQ0qDQ0NKg0NDSoNDQ0qDQ0NKg0NDSoMDAwlCgoKEQUFBQIAAAAAAAAAAAAAAAAAAAAACAgIFAoK
        CkcMDAxbDAwMXAwMDFwMDAxcDAwMXAwNDFwNDQ1cDQ0NXA0NDVwNDQ1cDQ0NXA0NDVwNDQ5cDg4OXA4O
        DlwODg5cDg4OXA4ODlwODg5cDg4OXA4ODlwODg5cDg4OWw0NDVIMDAwlBwcHAwAAAAAAAAAAAAAAAGFh
        YY9ZWFjFUVBP0kpJSdhIR0fYQkJC2D0+Ptg5OTnZODc22TMyM9kuLi/ZKysr2SYmJtkjIyPZICAf2Rsb
        G9kXFxjZExMT2Q8ODtkNDAzZDQwM2A0MDNgNDAzYDQ0N2A0NDdgODQ27Dg4OWw0NDSoGBgYEAAAAAAAA
        AAAAAAAAYmFhvzxCQ/82Uln/NlJZ/zdPVP89PDz/PDw8/zo6Ov85OTn/ODg4/zY2Nv80NDT/NDQ0/zIy
        Mv8xMTD/Ly4w/yw1OP8qNjj/JzQ1/yYyNP8kMDL/Ii4w/x8sLv8fKy3/HyIi/w0NDdgODg5cDQ0NKgYG
        BgQAAAAAAAAAAAAAAABjY2K/OFRa/xqXsv8bk6v/M11l/z49Pf89PT3/Ozs7/zo6Of83Nzj/NTY1/zQ0
        NP8zMzP/MTEw/y8vL/8uLi7/KzQ2/yk1Nv8nMjT/JjAz/yQvMf8jLjD/ISwu/x8rLf8fISL/DQ0N2A4O
        DlwNDQ0qBgYGBAAAAAAAAAAAAAAAAGZkZL86V13/GpKs/zJkbv9BPz//Pj8+/zw8PP85OTn/Njc2/zQ0
        Nf8zMjP/MjIy/zAwMP8vLy//Li4u/y0sLP8qKSn/I0hQ/yJHUP8hRk//IEZO/yBGTv8fRU3/HztB/yAf
        H/8NDQ3YDg4OXA0NDSoGBgYEAAAAAAAAAAAAAAAAaWdovz5WW/83YWr/RkND/0FAQP89PT3/ODc3/zIy
        Mf8uLi7/LCws/ysrK/8pKSn/Kioq/ygoKP8nJyf/JSUl/yUkJP8kIyP/IyEh/yMiIv8kIiL/JCMj/yQj
        I/8iISH/ISAg/w0NDdgODg5cDQ0NKgYGBgQAAAAAAAAAAAAAAABqamq/SUhI/0hHR/9GRkb/QUFB/0ZH
        Rv9/f4D/gICA/3h4eP9xcXH/a2tr/2RkZP9dXV7/V1dX/09PT/9ISEj/Q0NC/0BAQP9AQED/Ozs7/yYm
        Jv8jIyP/JCQk/yMjI/8jIyH/DQ0N2A4ODlwNDQ0qBgYGBAAAAAAAAAAAAAAAAG5ubr9LS0v/SkpL/0hI
        SP9BQUH/i4uL/6ysrP+hoqH/n5+e/52bnf+YmJj/lJSU/5CQj/+Li4v/hYaF/4CAgP97e3r/dXR1/3Fx
        cf9ra2v/Ozs7/yEhIv8kJCT/JCQk/yQkI/8NDQ3YDg4OXA0NDSoGBgYEAAAAAAAAAAAAAAAAcHBwv01N
        Tf9MTU3/SUpK/0BAP/+Wlpj/q6ur/6inp/+kpKT/oKGg/52cnP+YmJj/k5OT/46Ojv+IiYj/g4OC/319
        ff93d3f/cXFx/3Fxcf8/Pz//ISEh/yQkJP8lJSX/JSQk/w0NDdkODg5cDQ0NKgYGBgQAAAAAAAAAAAAA
        AABycnO/T05P/05PT/9MTEz/QUFB/5ubmv+ysrL/rq6u/6urq/+np6f/oqKi/52dnf+ZmZn/k5OT/42O
        jv+IiIf/gYGB/3x7fP90dXT/cXFx/z8/P/8hISH/JCQl/yUlJf8lJib/DQ0N2Q4ODlwNDQ0qBgYGBAAA
        AAAAAAAAAAAAAHR1db9RUVH/UFBQ/01NTf9CQkL/np6e/7i4uP+0s7T/sbGx/62trf+oqKj/o6Oj/52d
        nf+Yl5f/kZKR/4yMi/+FhYX/fn9//3h4eP9zc3P/Pz8//yIiIv8lJSX/JiYm/yYmJv8NDQ3ZDg4OXA0N
        DSoGBgYEAAAAAAAAAAAAAAAAdnZ2v1RUVP9TU1P/T09P/0VFRf+kpKT/v7+//7u7u/+2trb/sbGx/6mp
        qf+jo6P/nZ2d/5eXl/+QkZH/jo2N/4mJif+CgoL/fHx8/3d3d/9AQED/IiIi/yYmJv8nJyf/Jycn/w0N
        DdkODg5cDQ0NKgYGBgQAAAAAAAAAAAAAAAB4eHi/V1dW/1VVVf9QUFD/RkZG/6moqf/Gxsb/wcHB/7y8
        vP+2trb/q6ys/6Wlpf+fn5//mZiY/5WUlf+RkpL/jI2M/4WFhf9/fn//enp6/0FBQf8iIiP/JiYm/ygn
        KP8oJyf/DQ0N2Q4ODlwNDQ0qBgYGBAAAAAAAAAAAAAAAAHp6er9YWVn/V1dX/1JSU/9ISEj/ra2t/8zM
        zP/Gxsb/wcHB/7u7u/+wsLD/qamp/6Ojo/+cnZ3/lpaW/5OTk/+Pj47/iIiI/4CBgP98fH3/QkJC/yMj
        I/8nJyf/KCgo/ygoKP8ODg7ZDg4OXA0NDSoGBgYEAAAAAAAAAAAAAAAAfXx9v1tbW/9ZWVn/VFVV/0hJ
        Sf+xsbH/0tLS/8vLy//FxcX/v7++/7Ozs/+qqqr/pKWk/6Cfn/+ampr/mpia/5GRkf+Li4r/goOD/35+
        fv9CQ0P/IyQk/ycnJ/8pKSn/KSkp/xAQENkODg5cDQ0NKgYGBgQAAAAAAAAAAAAAAAB+fn6/XV1d/1tb
        W/9WVlb/S0lJ/7Oysv/W1tb/z8/P/8nJyf/CwsL/tbW1/66trf+np6f/oqKi/5ycnP+ZmJn/k5OT/4yM
        jP+FhYX/f39//0ZFRv8kJCT/KCgo/ykpKf8pKSn/EhIS2Q4ODlwNDQ0qBgYGBAAAAAAAAAAAAAAAAIGB
        gb9eXl7/XFxc/1dYV/9KSkr/tLS0/9rb2v/S0tL/zczM/8XFxf+/v7//uLi4/7Gxsf+rq6r/o6Oj/5yc
        nP+UlZT/jY2N/4aFhv+AgID/SUlI/yMjI/8oKCj/KSkp/ykpKf8UFBTZDg4OXA0NDSoGBgYEAAAAAAAA
        AAAAAAAAg4ODv19fX/9eXl7/WVhZ/0tLS/+0tLT/3d3d/9TU1P/Ozs7/x8bH/8DAwP+5ubn/srKy/6ur
        q/+kpKT/nJyc/5WVlv+Ojo7/h4eH/4GBgf9NTU3/IyQk/ygpKP8qKSn/KSkp/xgYGNkODg5cDQ0NKgYG
        BgQAAAAAAAAAAAAAAACFhYW/YGBf/15eXv9aWln/TU1N/7a2tv/e3t7/1dXV/87Pz//Hx8f/wcHB/7m5
        uv+ysrP/rKyr/6SkpP+dnZ3/lZWW/46Ojv+Hh4f/gYGB/1BQUP8kJCT/KSkp/ykpKf8oKCj/GhkZ2Q4O
        DlwNDQ0qBgYGBAAAAAAAAAAAAAAAAIiGhr9gYGD/Xl5e/1paWv9PT0//t7e3/93d3f/U1NT/zs7O/8fH
        x//AwMD/ubm5/7Kysv+rq6v/o6Ok/5ycnP+VlZX/jo6N/4aGhv+BgYH/U1NT/yYmJv8qKir/Kisq/ygo
        Kf8bHBzYDg4OXA0NDSoGBgYEAAAAAAAAAAAAAAAAioqKv19fX/9eXl7/Wlta/1FRUf+srKz/4uLi/9LS
        0v/Mzcz/xcXG/7+/v/+4ubj/srKx/6urq/+kpKT/nZ2d/5WVlf+Njo7/h4aH/4GBgf9TUlL/KSkp/yws
        LP8qLzH/Jy4v/x4eHtgNDQ1cDQ0NKgYGBgQAAAAAAAAAAAAAAACMi4y/Xl5e/11dXf9aWlr/VVVV/1xc
        XP+qqqr/sbGx/66urv+qqqr/pKSj/52dnf+VlZX/jo6O/4eHh/+Af3//d3l3/3BwcP9paWn/XFxc/zMz
        M/8sLCz/LS0t/yswMf8nLS7/ICAg2A0NDVwNDQ0qBgYGBAAAAAAAAAAAAAAAAI6Ojr9cXFz/XFxc/1pa
        Wv9WV1f/UFFQ/0xMS/9HR0f/RERE/0BBQP8+Pj7/PDw8/zo7Ov84ODj/ODg4/zU1Nf8zMzP/MTEx/zAw
        MP8uLi//Li4u/y4tL/8qPUD/KDk+/yU4O/8jIiLYDQ0NXA0NDSoGBgYEAAAAAAAAAAAAAAAAkZGRv1pb
        W/9bW1r/WFlY/1ZWVv9UVFT/UFBQ/05OTv9MTEz/SklK/0dHR/9FRUX/QkJC/0BAQP8+Pj7/PDw8/zo6
        Ov83ODf/NTU1/zIyMv8xMTH/Ly4u/yk7P/8oO0D/JTpA/yUkJNgNDQ1bDQ0NKgcHBwQAAAAAAAAAAAAA
        AACTk5O/WFhY/1lZWf9YV1j/VVVV/1JSUv9QUFD/Tk5O/01MTf9KSkr/SEhI/0ZGRv9DQkP/QEFA/z8/
        P/89PT3/Ozs6/zg4OP82NTX/MzMz/zExMf8vLi3/IVtn/yovMf8nLi//KCgo0gwMDEcMDAwgBwcHAwAA
        AAAAAAAAAAAAAJKTkr9VVFX/VFVV/1RUVP9SUVH/T09P/01NTv9MS0z/SkpK/0hJSP9HR0f/REVE/0FB
        Qf8/Pz//Pj4+/zs7PP85Ojn/Nzc3/zQ0NP8xMTH/LzAw/y4uLv8tLCz/KS8w/yUtLv8tLS3FCgoKFAoK
        CgkDAwMBAAAAAAAAAAAAAAAAl5aXj5KSkr+QkJC/jYuLv4eHh7+EhIS/gICAv3x8fL93d3e/dHR0v3Bw
        cL9samy/ZmZmv2NjY79fX1+/W1tbv1VVVb9SUlK/Tk5Ov0pKSr9ERES/QUFBvz09Pb85OTm/MzMzvzEx
        MY8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD////////////////gAAAH4AAAB+AA
        AAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AA
        AAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB////////////////ygAAAAwAAAAYAAAAAEA
        IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAA
        AAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAA
        AAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAACCAgIBwkJCQwICAgOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcH
        Bw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcH
        Bw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOCAgIDgkJCQwICAgHAAAAAgAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAICAgHCwsLGQ0NDSwNDQ0yDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0N
        DTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0N
        DTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMg0NDSwLCwsaCAgIBwAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJCQkMDQ0NLA0NDUwODg5XDg4OWQ4ODlkODg5ZDg4OWQ4O
        DlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4O
        DlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OVw0N
        DUwNDQ0sCQkJDAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEFBQUOCgoKMgsLC1cLCwtkCwsLZgsL
        C2YLCwtmCwsLZgwMDGYMDAxmDAwMZgwMDGYMDAxmDAwMZgwMDGYMDAxmDAwMZg0NDWYNDQ1mDQ0NZg0N
        DWYNDQ1mDQ0NZg0NDWYNDQ1mDg4OZg4ODmYODg5mDg4OZg4ODmYODg5mDg4OZg4ODmYODg5mDg4OZg4O
        DmYODg5mDg4OZA4ODlcNDQ0yCAgIDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAGJiYv9cXFz/Wlpa/1VV
        V/9TU1L/UVFR/05OTv9LSkv/R0dH/0NDQ/9BQUH/Pz4//zw8PP86OTn/NTU1/zIyMv8wMDD/LS0u/yoq
        Kv8mJib/JCMk/yEhIf8eHh7/Gxsc/xkZGf8UFBT/ERER/w8PD/8ODg7/Dg4O/w4ODv8ODg7/Dg4O/w4O
        Dv8ODg7/Dg4O/w4ODv8PDw//Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAGJi
        Yf8+PDz/Pzw7/0A7Ov9AOzr/Pzo5/z06Ov89Ojr/Ozs7/zo7Ov87Ojv/Ojo6/zk5Of84ODj/Nzc3/zY2
        Nf81NTT/MzMz/zIyMv8xMTH/MTIx/zAwMP8wMDD/Ly4u/y4tLf8sKiv/Kigo/yknJ/8oJiX/JiQk/yUj
        I/8kIiH/IiEg/yAeHv8gHh3/IB0d/x8eHv8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAGNjY/9BPj3/Gpiz/xuWsP8alrD/Gpey/yKClv8+PT3/PT09/zw8PP87Ozv/Ojo6/zk5
        Of84ODj/Nzc3/zY2Nv80NDT/MzMz/zMyMv8yMTH/MDEw/y8vL/8vLy//Li4t/yJWYf8hVF//IVRf/x9T
        Xf8gU13/H1Nc/x9RXP8eUFv/HlFb/x1QWv8cT1n/HFBb/x8eHv8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAGRkZP9CPTz/GpWv/xySq/8blK3/JH+S/0A8O/8/Pj7/Pj0+/z08
        PP87Ozv/Ojo6/zk5Of84ODj/Njc3/zU1Nf80NDT/MzMz/zIyMv8xMTH/MDAv/y8vL/8uLi7/LS0s/ywq
        Kv8tKSj/KiYm/yklJf8nJCP/KCIi/yYiIf8lICD/JB8e/yMeHP8iHRz/Hx0d/x8eH/8ODg7/Dg4OZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAGVlZf9GQUD/Gpaw/xuUrf8kgJP/Qj49/0A/
        P/8/Pj//Pj4+/zw8PP86Ojr/OTk5/zc3N/82NTb/NDQ0/zMzM/8yMjL/MTEx/zAwMP8vLzD/Ly8v/y4u
        Lv8tLS3/LCws/ysrKv8gVV//H1Nd/x9UXf8gU13/H1Nc/x9RXP8fUVz/HlFb/x5QW/8dUFv/Hx4f/x8f
        IP8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAGZmZv9GQkL/GZex/yWB
        k/9GQUH/QkFB/0FBQP8/Pz//PT09/zo7Ov84ODj/NTY1/zMzM/8yMjL/MTEx/zAwMP8vLy//Ly8v/y4u
        Lv8uLi7/LS0t/ysrK/8qKiv/KSkp/ygnJ/8nJib/JiQk/yYjJP8lIyP/JSIj/yUjI/8kIiL/JCIi/yMh
        Iv8iISD/IR8g/x8fH/8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAGho
        aP9IRUX/JIOY/0dDQv9HRUX/Q0ND/0FBQP8/Pz7/Ozo7/zY2Nv8xMTH/Li4u/ywsLf8tLS3/LCws/ysr
        K/8pKin/KSkp/ygoKP8oKCj/Jycn/ycmJv8lJSX/JSQl/yQkJP8jJCP/IyIj/yIiIv8iIyL/IyMj/yQj
        JP8kJCT/IyMk/yMjI/8jIyP/IiIh/yAgIP8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAGlqav9IR0f/SUdH/0lHR/9HR0b/RERF/0FBQf88PDz/Pj8//317ff91dXX/cHBw/2tr
        a/9lZGX/YF9f/1paWv9VVVb/UVFR/0xMTP9HR0f/QUFB/z48PP83ODf/MzMz/zAwMP8wMDD/Ly8w/zAw
        MP8xMDH/Jycn/yEhIv8jIyP/JCQk/yQkJP8jIyT/IyIi/yEhIf8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAG1ra/9KSkr/SkpK/0lJSf9ISEj/RkVF/0BAQP9CQkL/ycnJ/6ur
        q/+fn57/np6e/5ycnP+ampr/l5eX/5SUlP+SkpH/j4+P/4yMjP+Iior/hoeG/4ODg/+AgID/fHx8/3h4
        eP90dHP/cXFx/3Jycv9lZWX/Tk9O/ycnJ/8iIiL/IyQj/yQkJP8jIyP/IyMj/yMhI/8ODg7/Dg4OZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAG5ubf9LS0z/S0xL/0tLS/9JSUn/RkZG/0A/
        P/+Mi4z/s7Oz/6Ojo/+ioqL/oKCg/56env+cnJz/mZqZ/5eWl/+UlJT/kJGR/46Ojv+Li4v/h4eH/4OD
        g/+Af4D/fHx8/3h4eP91dHT/cHBw/29vb/9wcHD/ZWVl/zAwMP8iIiL/IyMj/yQkJP8kJCT/JCMk/yMk
        I/8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHBwb/9NTU3/TU1N/0xM
        TP9KSkr/R0dH/z8+P/+Ojo7/q6ur/6mpqf+np6b/paSk/6Kiov+goKD/nZ6e/5ubm/+YmJj/lZSU/5GR
        kf+Ojo7/ioqL/4eHh/+Dg4P/f39//3x8fP93d3f/c3Nz/29vb/9vb2//cnJy/y8vL/8gISD/IyMj/yUk
        JP8kJCT/JCQk/yQkJP8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHFx
        cf9OTk7/Tk5P/01NTf9MTEz/SEhI/0BAQP+QkJD/sLCv/62trf+srKv/qamp/6enp/+kpKX/oaKh/5+f
        n/+cnJz/mJiY/5WVlf+RkZL/jo6O/4qKiv+Ghob/goKC/35+fv96env/dnZ2/3Fycf9vb2//cnJy/y8u
        Lv8hICH/IyMj/yQkJf8lJSX/JCQl/yUlJP8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAHNzc/9PT0//T09P/09PT/9NTUz/SUlJ/0FAQf+SkpL/tbS0/7Gxsf+vr7D/rq6u/6ur
        q/+pqan/pqWl/6Kiov+fn5//nJyc/5iZmP+UlZX/kZGR/42Njf+JiYn/hYWF/4GBgf99fX3/eXl5/3R0
        dP9wcHD/cnJy/y4uLv8hISD/JCQk/yUlJf8mJSb/JiUl/yUlJf8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAHR0dP9RUVH/UVBR/09PT/9OTk7/S0pK/0JCQv+VlZX/uLi4/7a1
        tf+zs7P/sbGx/6+vr/+tra3/qaqq/6ampv+ioqP/n5+f/5ycnP+YmJj/lJSU/5CQj/+MjIz/iIiI/4OD
        g/9/f3//e3t7/3d3dv9ycnL/cnJy/y4vL/8hISH/JCQk/yYmJf8mJib/JiYl/yYlJf8ODg7/Dg4OZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHV1df9TU1T/U1NT/1BRUf9PTk7/TExM/0JC
        Qv+Xl5f/vr6+/7q6uv+3uLf/tbW1/7Kysv+wsLD/rq2t/6uqrP+mp6b/oqKi/5+fn/+bm5v/l5aX/5KS
        kv+Oj47/i4qK/4aGhv+BgoH/fX5+/3l5ef90dHT/c3Nz/y8vL/8jISP/JCQk/yYmJv8nJif/JiYm/yYm
        Jv8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHZ3dv9VVVX/VVVV/1NS
        Uv9QUFD/TU1N/0RERP+ampr/wsLC/76/v/+8vLz/ubm6/7a2t/+zs7P/ra2t/6ampv+io6P/np6f/5ub
        mv+Wl5f/k5OS/46Ojv+Njo3/jY2N/4mJiP+Eg4P/f39//3t7e/92d3b/dXV0/y8vL/8hISH/JCUl/yYm
        Jv8nJyf/JyYm/yYnJv8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHh3
        eP9WVlb/VlZW/1RUVP9RUVH/Tk5O/0VERP+cnJz/xsbG/8LCw//AwMD/vb69/7q7uv+3t7f/sLCw/6mp
        qf+mpqb/oqGi/52dnf+ZmZn/lZWV/5SUlP+Tk5P/j4+P/4uLi/+Ghob/gYGB/319ff94eHj/dnd2/y8v
        L/8hIiP/JSUl/ycnJv8oJyj/KCcn/ycnJ/8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAHl5ef9YWFj/V1dX/1ZWVv9SU1P/T09P/0ZGRv+fn5//ysvK/8bGxv/DxMT/wcHB/729
        vv+6urr/s7Oz/6ysrP+oqKj/pKWk/6CgoP+bm5v/l5eX/5OTk/+SkpL/kJGQ/42Njf+IiIj/g4OD/35/
        f/96env/eHh4/zAwL/8iIiL/JiYl/ycnJ/8oKCj/Jycn/ygnJ/8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAHp7e/9ZWVr/WVlZ/1dXV/9UVFX/T1BP/0ZGRv+ioaL/z8/P/8rL
        yv/HyMf/xMTE/8HBwf++vb7/tra2/6+vr/+qq6v/p6en/6Kiov+enp7/mZmZ/5WVlf+UlJT/k5KS/46O
        jv+Kior/hYWF/4CAgP98fHz/eHl6/zAwMP8jIiP/JiYm/ygnKP8oKCr/KCgo/ycoKP8PDw//Dg4OZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHx8fP9bW1r/Wlpa/1hYWP9VVlb/UFBQ/0dH
        R/+kpKT/0tLS/87Ozv/Ly8v/x8fH/8PExP/AwMD/ubm5/7Kysf+tra3/qaio/6Wlpf+goKD/m5ub/5eW
        l/+ZmZr/lJSU/5CQj/+Li4v/hoaG/4GBgf99fX3/e3t7/zAwMP8jIyP/JiYm/ygoJ/8pKSj/KSgo/ygo
        KP8QEBD/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAH5+ff9cXFz/XFtc/1pZ
        Wf9XV1b/UVFR/0hISP+lpaX/1tbW/9HR0f/Ozs7/y8rK/8bGxv/DwsL/uLi3/6ysrP+nqaf/o6Oi/56e
        nv+ioqL/paWl/5+fn/+bmpv/lZaW/5GRkP+NjYz/iIiH/4KCgv9+fn7/fHx8/zEyMv8jIyP/Jicn/ygo
        KP8pKSn/KCgp/ygpKP8RERH/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAH9/
        f/9dXV3/XV1d/1paW/9YWFf/UlJS/0lJSf+kpKT/2tra/9TU1P/Q0ND/zc3N/8jJyf/ExMT/vb29/7W1
        tv+xsbH/rKys/6ioqP+ioqT/nZ2e/5iYmP+YmJj/l5eX/5KSkv+Ojo3/iImI/4ODg/9/f3//fX19/zQ0
        NP8jIyP/Jycn/ygoKP8pKSn/KSkp/ygoKP8TExP/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAICAgP9eXl7/Xl5e/1xcXP9ZWVn/U1NT/0lJSf+kpKT/3d3d/9fX1v/S0tL/z8/P/8vL
        y//Gxsb/wsLC/72+vv+4uLn/tLS0/7CwsP+srKz/p6em/6Ghof+dnZ3/mJiY/5KTk/+Ojo7/iYmJ/4SE
        hP9/gID/fn5+/zY2Nv8kIyT/Jycn/ygoKP8pKSn/KSkp/ykpKf8WFhb/DQ0NZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAIKCgv9fX17/Xl5e/11cXf9ZWln/VFRU/0pJSv+lpaX/4eHg/9na
        2v/V1dT/0NDQ/83Mzf/Hx8f/w8PD/7++vv+6urr/tbW1/7CwsP+sra3/p6en/6Kiov+enZ3/mZmY/5SU
        k/+Pj4//ioqK/4WFhf+AgID/fX19/zk5Of8jIyT/Jycn/ygoKf8pKSn/KSkp/ykpJ/8YFxj/DQ0NZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAIOEhP9gYGD/X19f/15dXf9aWlr/VVVV/0tK
        S/+lpaX/4eLi/9vb2//W1tX/0dHR/83Nzf/IyMj/w8PE/7+/v/+6u7r/tbW1/7Gxsf+tra3/qKio/6Kj
        o/+enp7/mZmZ/5SUlP+Pj4//i4qK/4WFhf+AgID/fn59/zw8PP8kJCT/Jycn/ykpKf8qKin/KSkp/ygn
        KP8ZGRr/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAISEhP9gYGD/X19f/15e
        Xv9aWlv/VlZW/0tLS/+lpaX/4uLi/9zc3P/W19b/0dLR/83Ozv/JyMn/xMTE/7/AwP+7urv/trW2/7Gx
        sf+tra3/qKin/6Ojov+enp7/mZmZ/5SUlP+Pj5D/i4qK/4aFhf+AgID/fn5+/z9AQP8lJSX/KCgn/ykp
        Kf8qKin/KSkp/ygoKP8bGxv/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAIWH
        h/9gYGD/X19f/15eXv9aWlv/VlZX/0xMTP+mpqb/4eLh/9vb2//W1tb/0dHR/83Nzf/IyMn/xMTE/7+/
        v/+7u7v/tba1/7Gxsf+tra3/qKio/6Ojo/+enp7/mZmZ/5SUlP+Pj4//ioqK/4WFhf+AgID/fX59/0JC
        Qv8mJib/KCgo/ykpKf8qKir/KSkp/ygoKP8cHBz/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAIiIiP9gYGD/X19f/15eXv9bW1v/WFdX/05OTf+np6f/4eHh/9rZ2v/V1dX/0NDQ/83N
        zf/IyMf/w8PD/76/v/+6urr/tbW1/7CxsP+sra3/p6in/6Kiov+enp7/mZmZ/5OUlP+Pj4//ioqK/4WE
        hf+AgID/fn19/0ZGRv8mJyb/Kikq/yorKv8qKyr/KSkp/ygoKP8dHh7/DQ0NZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAImJif9gYGD/X19f/15eXv9bW1v/WFhY/1BQUP+pqan/6Ojo/9bW
        1v/S09P/z8/P/8vLy//Gxsb/wsLC/76+vv+5ubn/tLS0/7CwsP+srKv/p6em/6Giov+dnZ3/mJiY/5OT
        k/+Oj47/iYmJ/4SEhP9/f4D/e3t7/0pKS/8oKCj/Kysr/ywsLP8rKir/Kikq/yknJ/8fHx//DQ0NZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAIuLi/9fX17/Xl5f/11dXf9bW1v/WVhY/1RU
        VP9XV1j//////+Pj4//T09P/z8/P/8rKyv/Fx8f/wcHC/7++v/+5ubn/tbW1/7CwsP+sraz/pqao/6Ki
        ov+enZ7/mZmZ/5STlP+QkJD/i4uL/4aGhv+BgYH/fHx8/zEwL/8rKiz/LCws/y0sLP8rKir/F4GW/ygm
        J/8iIiL/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAIyMjP9eXV3/Xl5e/11c
        XP9bW1v/WFlZ/1ZWVf9OTk7/VldW/6enp/+lpaX/pKSk/6Kiov+goKD/nJyc/5iYmP+Tk5P/jo+P/4mJ
        if+FhIX/gICA/3t7fP92dnb/cXJx/21tbf9nZmb/YmJi/11dXf9aWlr/MzMz/ywtLP8uLi3/LS0t/y0t
        Lf8sKin/KScm/ycmJP8kJCT/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAI6O
        jv9cXlz/Xl5e/1tbXP9aWlr/WFhY/1ZWV/9SU1P/Tk9P/0tLSv9HR0f/RERE/0JCQv9AQED/Pj8//zw8
        Pf87Ozv/Ozs8/zo6Ov85OTn/ODg4/zY2Nv81NDX/NDM0/zMzM/8xMTH/MDAw/y8vL/8vLy//Li4u/y8v
        L/8uLy7/Li0t/y0tLP8rKij/F4GW/ygmJ/8mJib/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAJCPkP9dW1v/XV1c/1tbW/9ZWVn/WFhY/1ZWVv9TVFP/UlJR/09PT/9OTk3/S0xL/0pK
        Sv9ISEj/R0ZH/0VERf9CQkP/QUFC/0BAQP8/Pz//Pj4+/z09Pf87Ozv/OTk6/zg4OP82Njf/NTU1/zMz
        M/8yMjL/MTEx/y8wL/8vLy//Ly0t/xeAlf8sKCf/KScm/ykmJf8nJyf/DQ0NZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAJKSkv9aWlr/W1tb/1paWv9ZWVj/V1dX/1ZVVv9UVFT/UlJR/1BP
        UP9OTk7/TU1N/0xMTP9KSkr/SElI/0dHR/9GRkb/RERE/0JCQv9AQED/Pz8//z4+Pv89PT3/Ozs7/zk5
        Of84ODj/Nzc2/zQ0NP8zMzP/MjIy/zAwMP8vLy//Lyws/y4qK/8tKCf/GI6q/ygnJv8pKCn/DQ0NZA4O
        DlcNDQ0yCAgIDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAJOTk/9ZWFj/Wlpa/1lZWf9YWFj/V1dW/1VV
        VP9TU1P/UVFR/1BPUP9PT0//TU5O/0xMTP9LSkv/SUlJ/0hISP9GRkb/RERE/0NCQv9BQUH/QD8//z4/
        Pv89PT7/Ozw8/zo6Ov85OTn/Nzg3/zU1NP8zMzP/MTIy/zAwMP8vLy//Li0t/xeAlf8tJyj/KyYm/ygk
        Jf8rKyv/DQ0NVw0NDUwNDQ0sCQkJDAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAJOTk/9XV1f/WVhY/1hY
        V/9XV1f/VlZW/1VVVf9SUlL/UFFR/09PT/9OTk7/TU1N/0xMTP9LSkr/SUlJ/0dHR/9GRkb/REVE/0JC
        Qv9BQUD/Pz8//z8/Pv89PT3/Ozw8/zo6Ov84ODj/Nzc2/zQ0Nf8zMzP/MTIy/zAwL/8vLy//Li0t/y0s
        LP8rKSj/GI6q/yclJf8tLS3/DAwMMg0NDSwLCwsaCAgIBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJKS
        kv9UVVX/VVVV/1RVVf9TU1P/UlJS/1FRUf9PT0//Tk5O/01NTf9MTEz/SktL/0tJSf9JSUn/SEhI/0ZG
        R/9FRUX/Q0ND/0FBQf9APz//Pj4+/z0+Pf88PDz/Ojo6/zk5Of84ODj/NjY2/zM0M/8yMjH/MDAw/y8v
        L/8uLi7/LS0t/y0tLf8rKSn/KSYm/yclJP8vLy//BwcHDgkJCQwICAgHAAAAAgAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAJaVlf+TkpL/kpKS/4+Qj/+NjY3/iYmJ/4eHhv+FhYX/goKD/3+Af/99fHz/enl5/3Z2
        dv90dHT/cnJy/3Bwb/9ra2v/aGho/2VmZf9jZGP/YWFh/15eX/9cXFz/WFhY/1VUVf9TUlL/UFBQ/01N
        Tf9LS0v/SEhI/0NEQ/9BQUH/Pz8//zw9PP85OTn/NjY2/zIyMv8xMTH/AAAAAQAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAD///////8AAP///////wAA////////AAD///////8AAP///////wAA+AAAAAAfAAD4AAAAAB8AAPgA
        AAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAf
        AAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgA
        AAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAf
        AAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgA
        AAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAP///////wAA////////
        AAD///////8AAP///////wAA////////AAA=
</value>
  </data>
</root>
```

`LibreHardwareMonitor/UI/MainForm.Designer.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.UI
{
    sealed partial class MainForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MainForm));
            this.sensor = new Aga.Controls.Tree.TreeColumn();
            this.value = new Aga.Controls.Tree.TreeColumn();
            this.min = new Aga.Controls.Tree.TreeColumn();
            this.max = new Aga.Controls.Tree.TreeColumn();
            this.nodeImage = new Aga.Controls.Tree.NodeControls.NodeIcon();
            this.nodeCheckBox = new Aga.Controls.Tree.NodeControls.NodeCheckBox();
            this.nodeTextBoxText = new Aga.Controls.Tree.NodeControls.NodeTextBox();
            this.nodeTextBoxValue = new Aga.Controls.Tree.NodeControls.NodeTextBox();
            this.nodeTextBoxMin = new Aga.Controls.Tree.NodeControls.NodeTextBox();
            this.nodeTextBoxMax = new Aga.Controls.Tree.NodeControls.NodeTextBox();
            this.mainMenu = new System.Windows.Forms.MenuStrip();
            this.fileMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.saveReportMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.MenuItem2 = new System.Windows.Forms.ToolStripSeparator();
            this.resetMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.menuItemFileHardware = new System.Windows.Forms.ToolStripMenuItem();
            this.mainboardMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.cpuMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.ramMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.gpuMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.powerMonitorMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.fanControllerMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.hddMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.nicMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.psuMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.menuItem6 = new System.Windows.Forms.ToolStripSeparator();
            this.exitMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.viewMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.resetMinMaxMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.expandAllNodesMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.collpaseAllNodesMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.resetPlotMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.MenuItem3 = new System.Windows.Forms.ToolStripSeparator();
            this.hiddenMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.plotMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.gadgetMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.MenuItem1 = new System.Windows.Forms.ToolStripSeparator();
            this.columnsMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.valueMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.minMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.maxMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.optionsMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.startMinMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.minTrayMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.minCloseMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.startupMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.separatorMenuItem = new System.Windows.Forms.ToolStripSeparator();
            this.temperatureUnitsMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.celsiusMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.fahrenheitMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.plotLocationMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.plotWindowMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.plotBottomMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.plotRightMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.themeMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.strokeThicknessMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.strokeThickness1ptMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.strokeThickness2ptMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.strokeThickness3ptMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.strokeThickness4ptMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.splitPlotPanelScalingMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.splitPanelPercentageScalingMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.splitPanelFixedPlotScalingMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.splitPanelFixedSensorScalingMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.logSeparatorMenuItem = new System.Windows.Forms.ToolStripSeparator();
            this.logSensorsMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.fileRotationMethod = new System.Windows.Forms.ToolStripMenuItem();
            this.perSessionFileRotationMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.dailyFileRotationMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.loggingIntervalMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.log1sMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.log2sMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.log5sMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.log10sMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.log30sMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.log1minMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.log2minMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.log5minMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.log10minMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.log30minMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.log1hMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.log2hMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.log6hMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.updateIntervalMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.updateInterval250msMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.updateInterval500msMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.updateInterval1sMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.updateInterval2sMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.updateInterval5sMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.updateInterval10sMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.throttleAtaUpdateMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.sensorValuesTimeWindowMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.timeWindow30sMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.timeWindow1minMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.timeWindow2minMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.timeWindow5minMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.timeWindow10minMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.timeWindow30minMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.timeWindow1hMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.timeWindow2hMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.timeWindow6hMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.timeWindow12hMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.timeWindow24hMenuItem = new LibreHardwareMonitor.UI.ToolStripRadioButtonMenuItem();
            this.webMenuItemSeparator = new System.Windows.Forms.ToolStripSeparator();
            this.webMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.runWebServerMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.serverInterfacePortMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.authWebServerMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.helpMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.aboutMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.treeContextMenu = new System.Windows.Forms.ContextMenuStrip(this.components);
            this.saveFileDialog = new System.Windows.Forms.SaveFileDialog();
            this.timer = new System.Windows.Forms.Timer(this.components);
            this.splitContainer = new LibreHardwareMonitor.UI.SplitContainerAdv();
            this.treeView = new Aga.Controls.Tree.TreeViewAdv();
            this.batteryMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.backgroundUpdater = new System.ComponentModel.BackgroundWorker();
            this.mainMenu.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.splitContainer)).BeginInit();
            this.splitContainer.Panel1.SuspendLayout();
            this.splitContainer.SuspendLayout();
            this.SuspendLayout();
            //
            // sensor
            //
            this.sensor.Header = "Sensor";
            this.sensor.SortOrder = System.Windows.Forms.SortOrder.None;
            this.sensor.TooltipText = null;
            this.sensor.Width = 250;
            this.sensor.WidthChanged += delegate { TreeView_ColumnWidthChanged(this.sensor); };
            //
            // value
            //
            this.value.Header = "Value";
            this.value.SortOrder = System.Windows.Forms.SortOrder.None;
            this.value.TooltipText = null;
            this.value.Width = 100;
            this.value.WidthChanged += delegate { TreeView_ColumnWidthChanged(this.value); };
            //
            // min
            //
            this.min.Header = "Min";
            this.min.SortOrder = System.Windows.Forms.SortOrder.None;
            this.min.TooltipText = null;
            this.min.Width = 100;
            this.min.WidthChanged += delegate { TreeView_ColumnWidthChanged(this.min); };
            //
            // max
            //
            this.max.Header = "Max";
            this.max.SortOrder = System.Windows.Forms.SortOrder.None;
            this.max.TooltipText = null;
            this.max.Width = 100;
            this.max.WidthChanged += delegate { TreeView_ColumnWidthChanged(this.max); };
            //
            // nodeImage
            //
            this.nodeImage.DataPropertyName = "Image";
            this.nodeImage.LeftMargin = 1;
            this.nodeImage.ParentColumn = this.sensor;
            this.nodeImage.ScaleMode = Aga.Controls.Tree.ImageScaleMode.Fit;
            //
            // nodeCheckBox
            //
            this.nodeCheckBox.DataPropertyName = "Plot";
            this.nodeCheckBox.EditEnabled = true;
            this.nodeCheckBox.LeftMargin = 3;
            this.nodeCheckBox.ParentColumn = this.sensor;
            //
            // nodeTextBoxText
            //
            this.nodeTextBoxText.DataPropertyName = "Text";
            this.nodeTextBoxText.EditEnabled = true;
            this.nodeTextBoxText.IncrementalSearchEnabled = true;
            this.nodeTextBoxText.LeftMargin = 3;
            this.nodeTextBoxText.ParentColumn = this.sensor;
            this.nodeTextBoxText.Trimming = System.Drawing.StringTrimming.EllipsisCharacter;
            this.nodeTextBoxText.UseCompatibleTextRendering = true;
            //
            // nodeTextBoxValue
            //
            this.nodeTextBoxValue.DataPropertyName = "Value";
            this.nodeTextBoxValue.IncrementalSearchEnabled = true;
            this.nodeTextBoxValue.LeftMargin = 3;
            this.nodeTextBoxValue.ParentColumn = this.value;
            this.nodeTextBoxValue.Trimming = System.Drawing.StringTrimming.EllipsisCharacter;
            this.nodeTextBoxValue.UseCompatibleTextRendering = true;
            //
            // nodeTextBoxMin
            //
            this.nodeTextBoxMin.DataPropertyName = "Min";
            this.nodeTextBoxMin.IncrementalSearchEnabled = true;
            this.nodeTextBoxMin.LeftMargin = 3;
            this.nodeTextBoxMin.ParentColumn = this.min;
            this.nodeTextBoxMin.Trimming = System.Drawing.StringTrimming.EllipsisCharacter;
            this.nodeTextBoxMin.UseCompatibleTextRendering = true;
            //
            // nodeTextBoxMax
            //
            this.nodeTextBoxMax.DataPropertyName = "Max";
            this.nodeTextBoxMax.IncrementalSearchEnabled = true;
            this.nodeTextBoxMax.LeftMargin = 3;
            this.nodeTextBoxMax.ParentColumn = this.max;
            this.nodeTextBoxMax.Trimming = System.Drawing.StringTrimming.EllipsisCharacter;
            this.nodeTextBoxMax.UseCompatibleTextRendering = true;
            //
            // mainMenu
            //
            this.mainMenu.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.fileMenuItem,
            this.viewMenuItem,
            this.optionsMenuItem,
            this.helpMenuItem});
            this.mainMenu.Location = new System.Drawing.Point(0, 0);
            this.mainMenu.Name = "mainMenu";
            this.mainMenu.Size = new System.Drawing.Size(418, 24);
            this.mainMenu.TabIndex = 1;
            //
            // fileMenuItem
            //
            this.fileMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.saveReportMenuItem,
            this.MenuItem2,
            this.resetMenuItem,
            this.menuItemFileHardware,
            this.menuItem6,
            this.exitMenuItem});
            this.fileMenuItem.Name = "fileMenuItem";
            this.fileMenuItem.Size = new System.Drawing.Size(37, 20);
            this.fileMenuItem.Text = "File";
            //
            // saveReportMenuItem
            //
            this.saveReportMenuItem.Name = "saveReportMenuItem";
            this.saveReportMenuItem.Size = new System.Drawing.Size(180, 22);
            this.saveReportMenuItem.Text = "Save Report...";
            this.saveReportMenuItem.Click += new System.EventHandler(this.SaveReportMenuItem_Click);
            //
            // MenuItem2
            //
            this.MenuItem2.Name = "MenuItem2";
            this.MenuItem2.Size = new System.Drawing.Size(177, 6);
            //
            // resetMenuItem
            //
            this.resetMenuItem.Name = "resetMenuItem";
            this.resetMenuItem.Size = new System.Drawing.Size(180, 22);
            this.resetMenuItem.Text = "Reset";
            this.resetMenuItem.Click += new System.EventHandler(this.ResetClick);
            //
            // menuItem5
            //
            this.menuItemFileHardware.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.mainboardMenuItem,
            this.cpuMenuItem,
            this.ramMenuItem,
            this.gpuMenuItem,
            this.powerMonitorMenuItem,
            this.fanControllerMenuItem,
            this.hddMenuItem,
            this.nicMenuItem,
            this.psuMenuItem,
            this.batteryMenuItem});
            this.menuItemFileHardware.Name = "menuItem5";
            this.menuItemFileHardware.Size = new System.Drawing.Size(180, 22);
            this.menuItemFileHardware.Text = "Hardware";
            //
            // mainboardMenuItem
            //
            this.mainboardMenuItem.Name = "mainboardMenuItem";
            this.mainboardMenuItem.Size = new System.Drawing.Size(180, 22);
            this.mainboardMenuItem.Text = "Motherboard";
            //
            // cpuMenuItem
            //
            this.cpuMenuItem.Name = "cpuMenuItem";
            this.cpuMenuItem.Size = new System.Drawing.Size(180, 22);
            this.cpuMenuItem.Text = "CPU";
            //
            // ramMenuItem
            //
            this.ramMenuItem.Name = "ramMenuItem";
            this.ramMenuItem.Size = new System.Drawing.Size(180, 22);
            this.ramMenuItem.Text = "RAM";
            //
            // gpuMenuItem
            //
            this.gpuMenuItem.Name = "gpuMenuItem";
            this.gpuMenuItem.Size = new System.Drawing.Size(180, 22);
            this.gpuMenuItem.Text = "GPU";
            //
            // powerMonitorMenuItem
            //
            this.powerMonitorMenuItem.Name = "powerMonitorMenuItem";
            this.powerMonitorMenuItem.Size = new System.Drawing.Size(180, 22);
            this.powerMonitorMenuItem.Text = "Power Monitors";
            //
            // fanControllerMenuItem
            //
            this.fanControllerMenuItem.Name = "fanControllerMenuItem";
            this.fanControllerMenuItem.Size = new System.Drawing.Size(180, 22);
            this.fanControllerMenuItem.Text = "Fan Controllers";
            //
            // hddMenuItem
            //
            this.hddMenuItem.Name = "hddMenuItem";
            this.hddMenuItem.Size = new System.Drawing.Size(180, 22);
            this.hddMenuItem.Text = "Storage Devices";
            //
            // nicMenuItem
            //
            this.nicMenuItem.Name = "nicMenuItem";
            this.nicMenuItem.Size = new System.Drawing.Size(180, 22);
            this.nicMenuItem.Text = "Network";
            //
            // psuMenuItem
            //
            this.psuMenuItem.Name = "psuMenuItem";
            this.psuMenuItem.Size = new System.Drawing.Size(180, 22);
            this.psuMenuItem.Text = "Power supplies";
            //
            // menuItem6
            //
            this.menuItem6.Name = "menuItem6";
            this.menuItem6.Size = new System.Drawing.Size(177, 6);
            //
            // exitMenuItem
            //
            this.exitMenuItem.Name = "exitMenuItem";
            this.exitMenuItem.Size = new System.Drawing.Size(180, 22);
            this.exitMenuItem.Text = "Exit";
            this.exitMenuItem.Click += new System.EventHandler(this.ExitClick);
            //
            // viewMenuItem
            //
            this.viewMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.resetMinMaxMenuItem,
            this.expandAllNodesMenuItem,
            this.collpaseAllNodesMenuItem,
            this.resetPlotMenuItem,
            this.MenuItem3,
            this.hiddenMenuItem,
            this.plotMenuItem,
            this.gadgetMenuItem,
            this.MenuItem1,
            this.columnsMenuItem});
            this.viewMenuItem.Name = "viewMenuItem";
            this.viewMenuItem.Size = new System.Drawing.Size(44, 20);
            this.viewMenuItem.Text = "View";
            //
            // resetMinMaxMenuItem
            //
            this.resetMinMaxMenuItem.Name = "resetMinMaxMenuItem";
            this.resetMinMaxMenuItem.Size = new System.Drawing.Size(188, 22);
            this.resetMinMaxMenuItem.Text = "Reset Min/Max";
            this.resetMinMaxMenuItem.Click += new System.EventHandler(this.ResetMinMaxMenuItem_Click);
            //
            // expandAllNodesMenuItem
            //
            this.expandAllNodesMenuItem.Name = "expandAllNodesMenuItem";
            this.expandAllNodesMenuItem.Size = new System.Drawing.Size(188, 22);
            this.expandAllNodesMenuItem.Text = "Expand All Nodes";
            this.expandAllNodesMenuItem.Click += new System.EventHandler(this.ExpandAllNodes_Click);
            //
            // collpaseAllNodesMenuItem
            //
            this.collpaseAllNodesMenuItem.Name = "collpaseAllNodesMenuItem";
            this.collpaseAllNodesMenuItem.Size = new System.Drawing.Size(188, 22);
            this.collpaseAllNodesMenuItem.Text = "Collapse All Nodes";
            this.collpaseAllNodesMenuItem.Click += new System.EventHandler(this.CollapseAllNodes_Click);
            //
            // resetPlotMenuItem
            //
            this.resetPlotMenuItem.Name = "resetPlotMenuItem";
            this.resetPlotMenuItem.Size = new System.Drawing.Size(188, 22);
            this.resetPlotMenuItem.Text = "Reset Plot";
            this.resetPlotMenuItem.Click += new System.EventHandler(this.resetPlotMenuItem_Click);
            //
            // MenuItem3
            //
            this.MenuItem3.Name = "MenuItem3";
            this.MenuItem3.Size = new System.Drawing.Size(185, 6);
            //
            // hiddenMenuItem
            //
            this.hiddenMenuItem.Name = "hiddenMenuItem";
            this.hiddenMenuItem.Size = new System.Drawing.Size(188, 22);
            this.hiddenMenuItem.Text = "Show Hidden Sensors";
            //
            // plotMenuItem
            //
            this.plotMenuItem.Name = "plotMenuItem";
            this.plotMenuItem.Size = new System.Drawing.Size(188, 22);
            this.plotMenuItem.Text = "Show Plot";
            //
            // gadgetMenuItem
            //
            this.gadgetMenuItem.Name = "gadgetMenuItem";
            this.gadgetMenuItem.Size = new System.Drawing.Size(188, 22);
            this.gadgetMenuItem.Text = "Show Gadget";
            //
            // MenuItem1
            //
            this.MenuItem1.Name = "MenuItem1";
            this.MenuItem1.Size = new System.Drawing.Size(185, 6);
            //
            // columnsMenuItem
            //
            this.columnsMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.valueMenuItem,
            this.minMenuItem,
            this.maxMenuItem});
            this.columnsMenuItem.Name = "columnsMenuItem";
            this.columnsMenuItem.Size = new System.Drawing.Size(188, 22);
            this.columnsMenuItem.Text = "Columns";
            //
            // valueMenuItem
            //
            this.valueMenuItem.Name = "valueMenuItem";
            this.valueMenuItem.Size = new System.Drawing.Size(180, 22);
            this.valueMenuItem.Text = "Value";
            //
            // minMenuItem
            //
            this.minMenuItem.Name = "minMenuItem";
            this.minMenuItem.Size = new System.Drawing.Size(180, 22);
            this.minMenuItem.Text = "Min";
            //
            // maxMenuItem
            //
            this.maxMenuItem.Name = "maxMenuItem";
            this.maxMenuItem.Size = new System.Drawing.Size(180, 22);
            this.maxMenuItem.Text = "Max";
            //
            // optionsMenuItem
            //
            this.optionsMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.startMinMenuItem,
            this.minTrayMenuItem,
            this.minCloseMenuItem,
            this.startupMenuItem,
            this.separatorMenuItem,
            this.temperatureUnitsMenuItem,
            this.plotLocationMenuItem,
            this.strokeThicknessMenuItem,
            this.themeMenuItem,
            this.splitPlotPanelScalingMenuItem,
            this.logSeparatorMenuItem,
            this.logSensorsMenuItem,
            this.loggingIntervalMenuItem,
            this.updateIntervalMenuItem,
            this.fileRotationMethod,
            this.sensorValuesTimeWindowMenuItem,
            this.webMenuItemSeparator,
            this.webMenuItem});
            this.optionsMenuItem.Name = "optionsMenuItem";
            this.optionsMenuItem.Size = new System.Drawing.Size(61, 20);
            this.optionsMenuItem.Text = "Options";
            //
            // startMinMenuItem
            //
            this.startMinMenuItem.Name = "startMinMenuItem";
            this.startMinMenuItem.Size = new System.Drawing.Size(221, 22);
            this.startMinMenuItem.Text = "Start Minimized";
            //
            // minTrayMenuItem
            //
            this.minTrayMenuItem.Name = "minTrayMenuItem";
            this.minTrayMenuItem.Size = new System.Drawing.Size(221, 22);
            this.minTrayMenuItem.Text = "Minimize To Tray";
            //
            // minCloseMenuItem
            //
            this.minCloseMenuItem.Name = "minCloseMenuItem";
            this.minCloseMenuItem.Size = new System.Drawing.Size(221, 22);
            this.minCloseMenuItem.Text = "Minimize On Close";
            //
            // startupMenuItem
            //
            this.startupMenuItem.Name = "startupMenuItem";
            this.startupMenuItem.Size = new System.Drawing.Size(221, 22);
            this.startupMenuItem.Text = "Run On Windows Startup";
            //
            // separatorMenuItem
            //
            this.separatorMenuItem.Name = "separatorMenuItem";
            this.separatorMenuItem.Size = new System.Drawing.Size(218, 6);
            //
            // temperatureUnitsMenuItem
            //
            this.temperatureUnitsMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.celsiusMenuItem,
            this.fahrenheitMenuItem});
            this.temperatureUnitsMenuItem.Name = "temperatureUnitsMenuItem";
            this.temperatureUnitsMenuItem.Size = new System.Drawing.Size(221, 22);
            this.temperatureUnitsMenuItem.Text = "Temperature Unit";
            //
            // celsiusMenuItem
            //
            this.celsiusMenuItem.CheckOnClick = true;
            this.celsiusMenuItem.Name = "celsiusMenuItem";
            this.celsiusMenuItem.Size = new System.Drawing.Size(130, 22);
            this.celsiusMenuItem.Text = "Celsius";
            this.celsiusMenuItem.Click += new System.EventHandler(this.CelsiusMenuItem_Click);
            //
            // fahrenheitMenuItem
            //
            this.fahrenheitMenuItem.CheckOnClick = true;
            this.fahrenheitMenuItem.Name = "fahrenheitMenuItem";
            this.fahrenheitMenuItem.Size = new System.Drawing.Size(130, 22);
            this.fahrenheitMenuItem.Text = "Fahrenheit";
            this.fahrenheitMenuItem.Click += new System.EventHandler(this.FahrenheitMenuItem_Click);
            //
            // plotLocationMenuItem
            //
            this.plotLocationMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.plotWindowMenuItem,
            this.plotBottomMenuItem,
            this.plotRightMenuItem});
            this.plotLocationMenuItem.Name = "plotLocationMenuItem";
            this.plotLocationMenuItem.Size = new System.Drawing.Size(221, 22);
            this.plotLocationMenuItem.Text = "Plot Location";
            //
            // plotWindowMenuItem
            //
            this.plotWindowMenuItem.CheckOnClick = true;
            this.plotWindowMenuItem.Name = "plotWindowMenuItem";
            this.plotWindowMenuItem.Size = new System.Drawing.Size(118, 22);
            this.plotWindowMenuItem.Text = "Window";
            //
            // plotBottomMenuItem
            //
            this.plotBottomMenuItem.CheckOnClick = true;
            this.plotBottomMenuItem.Name = "plotBottomMenuItem";
            this.plotBottomMenuItem.Size = new System.Drawing.Size(118, 22);
            this.plotBottomMenuItem.Text = "Bottom";
            //
            // plotRightMenuItem
            //
            this.plotRightMenuItem.CheckOnClick = true;
            this.plotRightMenuItem.Name = "plotRightMenuItem";
            this.plotRightMenuItem.Size = new System.Drawing.Size(118, 22);
            this.plotRightMenuItem.Text = "Right";
            //
            // themeMenuItem
            //
            this.themeMenuItem.Name = "themeMenuItem";
            this.themeMenuItem.Size = new System.Drawing.Size(278, 22);
            this.themeMenuItem.Text = "Theme";
            //
            // strokeThicknessMenuItem
            //
            this.strokeThicknessMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.strokeThickness1ptMenuItem,
            this.strokeThickness2ptMenuItem,
            this.strokeThickness3ptMenuItem,
            this.strokeThickness4ptMenuItem});
            this.strokeThicknessMenuItem.Name = "strokeThicknessMenuItem";
            this.strokeThicknessMenuItem.Size = new System.Drawing.Size(278, 22);
            this.strokeThicknessMenuItem.Text = "Stroke Thickness";
            //
            // strokeThickness1ptMenuItem
            //
            this.strokeThickness1ptMenuItem.CheckOnClick = true;
            this.strokeThickness1ptMenuItem.Name = "strokeThickness1ptMenuItem";
            this.strokeThickness1ptMenuItem.Size = new System.Drawing.Size(224, 22);
            this.strokeThickness1ptMenuItem.Text = "1pt";
            //
            // strokeThickness2ptMenuItem
            //
            this.strokeThickness2ptMenuItem.CheckOnClick = true;
            this.strokeThickness2ptMenuItem.Name = "strokeThickness2ptMenuItem";
            this.strokeThickness2ptMenuItem.Size = new System.Drawing.Size(224, 22);
            this.strokeThickness2ptMenuItem.Text = "2pt";
            //
            // strokeThickness3ptMenuItem
            //
            this.strokeThickness3ptMenuItem.CheckOnClick = true;
            this.strokeThickness3ptMenuItem.Name = "strokeThickness3ptMenuItem";
            this.strokeThickness3ptMenuItem.Size = new System.Drawing.Size(224, 22);
            this.strokeThickness3ptMenuItem.Text = "3pt";
            //
            // strokeThickness4ptMenuItem
            //
            this.strokeThickness4ptMenuItem.CheckOnClick = true;
            this.strokeThickness4ptMenuItem.Name = "strokeThickness4ptMenuItem";
            this.strokeThickness4ptMenuItem.Size = new System.Drawing.Size(224, 26);
            this.strokeThickness4ptMenuItem.Text = "4pt";
            //
            // attachedPlotPanelScalingMenuItem
            //
            this.splitPlotPanelScalingMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.splitPanelPercentageScalingMenuItem,
            this.splitPanelFixedPlotScalingMenuItem,
            this.splitPanelFixedSensorScalingMenuItem});
            this.splitPlotPanelScalingMenuItem.Name = "attachedPlotPanelScalingMenuItem";
            this.splitPlotPanelScalingMenuItem.Size = new System.Drawing.Size(221, 22);
            this.splitPlotPanelScalingMenuItem.Text = "Split Panel Scaling Mode";
            //
            // attachedPanelPercentageScalingMenuItem
            //
            this.splitPanelPercentageScalingMenuItem.CheckOnClick = true;
            this.splitPanelPercentageScalingMenuItem.Name = "attachedPlotPanelPercentageScalingMenuItem";
            this.splitPanelPercentageScalingMenuItem.Size = new System.Drawing.Size(118, 22);
            this.splitPanelPercentageScalingMenuItem.Text = "Percentage Scaling";
            //
            // attachedPanelFixedWidthPlotPanelScalingMenuItem
            //
            this.splitPanelFixedPlotScalingMenuItem.CheckOnClick = true;
            this.splitPanelFixedPlotScalingMenuItem.Name = "attachedBottomMenuItem";
            this.splitPanelFixedPlotScalingMenuItem.Size = new System.Drawing.Size(118, 22);
            this.splitPanelFixedPlotScalingMenuItem.Text = "Fixed Size Plot Panel";
            //
            // attachedPanelFixedWidthSensorPanelScalingMenuItem
            //
            this.splitPanelFixedSensorScalingMenuItem.CheckOnClick = true;
            this.splitPanelFixedSensorScalingMenuItem.Name = "attachedRightMenuItem";
            this.splitPanelFixedSensorScalingMenuItem.Size = new System.Drawing.Size(118, 22);
            this.splitPanelFixedSensorScalingMenuItem.Text = "Fixed Size Sensor Panel";
            //
            // logSeparatorMenuItem
            //
            this.logSeparatorMenuItem.Name = "logSeparatorMenuItem";
            this.logSeparatorMenuItem.Size = new System.Drawing.Size(218, 6);
            //
            // logSensorsMenuItem
            //
            this.logSensorsMenuItem.Name = "logSensorsMenuItem";
            this.logSensorsMenuItem.Size = new System.Drawing.Size(221, 22);
            this.logSensorsMenuItem.Text = "Log Sensors";
            //
            // fileRotationMethod
            //
            this.fileRotationMethod.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.perSessionFileRotationMenuItem,
            this.dailyFileRotationMenuItem});
            this.fileRotationMethod.Name = "fileRotationMethod";
            this.fileRotationMethod.Size = new System.Drawing.Size(246, 24);
            this.fileRotationMethod.Text = "File rotation method";
            this.fileRotationMethod.ToolTipText = "Determine how the log file should rotate.";
            //
            // perSessionFileRotationMenuItem
            //
            this.perSessionFileRotationMenuItem.CheckOnClick = true;
            this.perSessionFileRotationMenuItem.Name = "perSessionFileRotationMenuItem";
            this.perSessionFileRotationMenuItem.Size = new System.Drawing.Size(198, 24);
            this.perSessionFileRotationMenuItem.Text = "Per session";
            this.perSessionFileRotationMenuItem.ToolTipText = "Create a new log file for each logging session";
            this.perSessionFileRotationMenuItem.Click += new System.EventHandler(this.perSessionFileRotationMenuItem_Click);
            //
            // dailyFileRotationMenuItem
            //
            this.dailyFileRotationMenuItem.CheckOnClick = true;
            this.dailyFileRotationMenuItem.Name = "dailyFileRotationMenuItem";
            this.dailyFileRotationMenuItem.Size = new System.Drawing.Size(198, 24);
            this.dailyFileRotationMenuItem.Text = "Daily";
            this.dailyFileRotationMenuItem.ToolTipText = "Create a new log file every day.\n If a file already exists for the current day, new data will be appended at the end.";
            this.dailyFileRotationMenuItem.Click += new System.EventHandler(this.dailyFileRotationMenuItem_Click);
            //
            // loggingIntervalMenuItem
            //
            this.loggingIntervalMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.log1sMenuItem,
            this.log2sMenuItem,
            this.log5sMenuItem,
            this.log10sMenuItem,
            this.log30sMenuItem,
            this.log1minMenuItem,
            this.log2minMenuItem,
            this.log5minMenuItem,
            this.log10minMenuItem,
            this.log30minMenuItem,
            this.log1hMenuItem,
            this.log2hMenuItem,
            this.log6hMenuItem});
            this.loggingIntervalMenuItem.Name = "loggingIntervalMenuItem";
            this.loggingIntervalMenuItem.Size = new System.Drawing.Size(221, 22);
            this.loggingIntervalMenuItem.Text = "Logging Interval";
            //
            // log1sMenuItem
            //
            this.log1sMenuItem.CheckOnClick = true;
            this.log1sMenuItem.Name = "log1sMenuItem";
            this.log1sMenuItem.Size = new System.Drawing.Size(107, 22);
            this.log1sMenuItem.Text = "1s";
            //
            // log2sMenuItem
            //
            this.log2sMenuItem.CheckOnClick = true;
            this.log2sMenuItem.Name = "log2sMenuItem";
            this.log2sMenuItem.Size = new System.Drawing.Size(107, 22);
            this.log2sMenuItem.Text = "2s";
            //
            // log5sMenuItem
            //
            this.log5sMenuItem.CheckOnClick = true;
            this.log5sMenuItem.Name = "log5sMenuItem";
            this.log5sMenuItem.Size = new System.Drawing.Size(107, 22);
            this.log5sMenuItem.Text = "5s";
            //
            // log10sMenuItem
            //
            this.log10sMenuItem.CheckOnClick = true;
            this.log10sMenuItem.Name = "log10sMenuItem";
            this.log10sMenuItem.Size = new System.Drawing.Size(107, 22);
            this.log10sMenuItem.Text = "10s";
            //
            // log30sMenuItem
            //
            this.log30sMenuItem.CheckOnClick = true;
            this.log30sMenuItem.Name = "log30sMenuItem";
            this.log30sMenuItem.Size = new System.Drawing.Size(107, 22);
            this.log30sMenuItem.Text = "30s";
            //
            // log1minMenuItem
            //
            this.log1minMenuItem.CheckOnClick = true;
            this.log1minMenuItem.Name = "log1minMenuItem";
            this.log1minMenuItem.Size = new System.Drawing.Size(107, 22);
            this.log1minMenuItem.Text = "1min";
            //
            // log2minMenuItem
            //
            this.log2minMenuItem.CheckOnClick = true;
            this.log2minMenuItem.Name = "log2minMenuItem";
            this.log2minMenuItem.Size = new System.Drawing.Size(107, 22);
            this.log2minMenuItem.Text = "2min";
            //
            // log5minMenuItem
            //
            this.log5minMenuItem.CheckOnClick = true;
            this.log5minMenuItem.Name = "log5minMenuItem";
            this.log5minMenuItem.Size = new System.Drawing.Size(107, 22);
            this.log5minMenuItem.Text = "5min";
            //
            // log10minMenuItem
            //
            this.log10minMenuItem.CheckOnClick = true;
            this.log10minMenuItem.Name = "log10minMenuItem";
            this.log10minMenuItem.Size = new System.Drawing.Size(107, 22);
            this.log10minMenuItem.Text = "10min";
            //
            // log30minMenuItem
            //
            this.log30minMenuItem.CheckOnClick = true;
            this.log30minMenuItem.Name = "log30minMenuItem";
            this.log30minMenuItem.Size = new System.Drawing.Size(107, 22);
            this.log30minMenuItem.Text = "30min";
            //
            // log1hMenuItem
            //
            this.log1hMenuItem.CheckOnClick = true;
            this.log1hMenuItem.Name = "log1hMenuItem";
            this.log1hMenuItem.Size = new System.Drawing.Size(107, 22);
            this.log1hMenuItem.Text = "1h";
            //
            // log2hMenuItem
            //
            this.log2hMenuItem.CheckOnClick = true;
            this.log2hMenuItem.Name = "log2hMenuItem";
            this.log2hMenuItem.Size = new System.Drawing.Size(107, 22);
            this.log2hMenuItem.Text = "2h";
            //
            // log6hMenuItem
            //
            this.log6hMenuItem.CheckOnClick = true;
            this.log6hMenuItem.Name = "log6hMenuItem";
            this.log6hMenuItem.Size = new System.Drawing.Size(107, 22);
            this.log6hMenuItem.Text = "6h";
            //
            // updateIntervalMenuItem
            //
            this.updateIntervalMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.updateInterval250msMenuItem,
            this.updateInterval500msMenuItem,
            this.updateInterval1sMenuItem,
            this.updateInterval2sMenuItem,
            this.updateInterval5sMenuItem,
            this.updateInterval10sMenuItem,
            this.throttleAtaUpdateMenuItem});
            this.updateIntervalMenuItem.Name = "updateIntervalMenuItem";
            this.updateIntervalMenuItem.Size = new System.Drawing.Size(221, 22);
            this.updateIntervalMenuItem.Text = "Update Interval";
            //
            // updateInterval250msMenuItem
            //
            this.updateInterval250msMenuItem.CheckOnClick = true;
            this.updateInterval250msMenuItem.Name = "updateInterval250msMenuItem";
            this.updateInterval250msMenuItem.Size = new System.Drawing.Size(107, 22);
            this.updateInterval250msMenuItem.Text = "250ms";
            //
            // updateInterval500msMenuItem
            //
            this.updateInterval500msMenuItem.CheckOnClick = true;
            this.updateInterval500msMenuItem.Name = "updateInterval500msMenuItem";
            this.updateInterval500msMenuItem.Size = new System.Drawing.Size(107, 22);
            this.updateInterval500msMenuItem.Text = "500ms";
            //
            // updateInterval1sMenuItem
            //
            this.updateInterval1sMenuItem.CheckOnClick = true;
            this.updateInterval1sMenuItem.Name = "updateInterval1sMenuItem";
            this.updateInterval1sMenuItem.Size = new System.Drawing.Size(107, 22);
            this.updateInterval1sMenuItem.Text = "1s";
            //
            // updateInterval2sMenuItem
            //
            this.updateInterval2sMenuItem.CheckOnClick = true;
            this.updateInterval2sMenuItem.Name = "updateInterval2sMenuItem";
            this.updateInterval2sMenuItem.Size = new System.Drawing.Size(107, 22);
            this.updateInterval2sMenuItem.Text = "2s";
            //
            // updateInterval5sMenuItem
            //
            this.updateInterval5sMenuItem.CheckOnClick = true;
            this.updateInterval5sMenuItem.Name = "updateInterval5sMenuItem";
            this.updateInterval5sMenuItem.Size = new System.Drawing.Size(107, 22);
            this.updateInterval5sMenuItem.Text = "5s";
            //
            // updateInterval10sMenuItem
            //
            this.updateInterval10sMenuItem.CheckOnClick = true;
            this.updateInterval10sMenuItem.Name = "updateInterval10sMenuItem";
            this.updateInterval10sMenuItem.Size = new System.Drawing.Size(107, 22);
            this.updateInterval10sMenuItem.Text = "10s";
            //
            // throttleATAUpdateMenuItem
            //
            this.throttleAtaUpdateMenuItem.CheckOnClick = true;
            this.throttleAtaUpdateMenuItem.Name = "throttleATAUpdateMenuItem";
            this.throttleAtaUpdateMenuItem.Size = new System.Drawing.Size(107, 22);
            this.throttleAtaUpdateMenuItem.Text = "Throttle ATA Storage";
            //
            // sensorValuesTimeWindowMenuItem
            //
            this.sensorValuesTimeWindowMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.timeWindow30sMenuItem,
            this.timeWindow1minMenuItem,
            this.timeWindow2minMenuItem,
            this.timeWindow5minMenuItem,
            this.timeWindow10minMenuItem,
            this.timeWindow30minMenuItem,
            this.timeWindow1hMenuItem,
            this.timeWindow2hMenuItem,
            this.timeWindow6hMenuItem,
            this.timeWindow12hMenuItem,
            this.timeWindow24hMenuItem});
            this.sensorValuesTimeWindowMenuItem.Name = "sensorValuesTimeWindowMenuItem";
            this.sensorValuesTimeWindowMenuItem.Size = new System.Drawing.Size(221, 22);
            this.sensorValuesTimeWindowMenuItem.Text = "Sensor Values Time Window";
            //
            // timeWindow30sMenuItem
            //
            this.timeWindow30sMenuItem.CheckOnClick = true;
            this.timeWindow30sMenuItem.Name = "timeWindow30sMenuItem";
            this.timeWindow30sMenuItem.Size = new System.Drawing.Size(107, 22);
            this.timeWindow30sMenuItem.Text = "30s";
            //
            // timeWindow1minMenuItem
            //
            this.timeWindow1minMenuItem.CheckOnClick = true;
            this.timeWindow1minMenuItem.Name = "timeWindow1minMenuItem";
            this.timeWindow1minMenuItem.Size = new System.Drawing.Size(107, 22);
            this.timeWindow1minMenuItem.Text = "1min";
            //
            // timeWindow2minMenuItem
            //
            this.timeWindow2minMenuItem.CheckOnClick = true;
            this.timeWindow2minMenuItem.Name = "timeWindow2minMenuItem";
            this.timeWindow2minMenuItem.Size = new System.Drawing.Size(107, 22);
            this.timeWindow2minMenuItem.Text = "2min";
            //
            // timeWindow5minMenuItem
            //
            this.timeWindow5minMenuItem.CheckOnClick = true;
            this.timeWindow5minMenuItem.Name = "timeWindow5minMenuItem";
            this.timeWindow5minMenuItem.Size = new System.Drawing.Size(107, 22);
            this.timeWindow5minMenuItem.Text = "5min";
            //
            // timeWindow10minMenuItem
            //
            this.timeWindow10minMenuItem.CheckOnClick = true;
            this.timeWindow10minMenuItem.Name = "timeWindow10minMenuItem";
            this.timeWindow10minMenuItem.Size = new System.Drawing.Size(107, 22);
            this.timeWindow10minMenuItem.Text = "10min";
            //
            // timeWindow30minMenuItem
            //
            this.timeWindow30minMenuItem.CheckOnClick = true;
            this.timeWindow30minMenuItem.Name = "timeWindow30minMenuItem";
            this.timeWindow30minMenuItem.Size = new System.Drawing.Size(107, 22);
            this.timeWindow30minMenuItem.Text = "30min";
            //
            // timeWindow1hMenuItem
            //
            this.timeWindow1hMenuItem.CheckOnClick = true;
            this.timeWindow1hMenuItem.Name = "timeWindow1hMenuItem";
            this.timeWindow1hMenuItem.Size = new System.Drawing.Size(107, 22);
            this.timeWindow1hMenuItem.Text = "1h";
            //
            // timeWindow2hMenuItem
            //
            this.timeWindow2hMenuItem.CheckOnClick = true;
            this.timeWindow2hMenuItem.Name = "timeWindow2hMenuItem";
            this.timeWindow2hMenuItem.Size = new System.Drawing.Size(107, 22);
            this.timeWindow2hMenuItem.Text = "2h";
            //
            // timeWindow6hMenuItem
            //
            this.timeWindow6hMenuItem.CheckOnClick = true;
            this.timeWindow6hMenuItem.Name = "timeWindow6hMenuItem";
            this.timeWindow6hMenuItem.Size = new System.Drawing.Size(107, 22);
            this.timeWindow6hMenuItem.Text = "6h";
            //
            // timeWindow12hMenuItem
            //
            this.timeWindow12hMenuItem.CheckOnClick = true;
            this.timeWindow12hMenuItem.Name = "timeWindow12hMenuItem";
            this.timeWindow12hMenuItem.Size = new System.Drawing.Size(107, 22);
            this.timeWindow12hMenuItem.Text = "12h";
            //
            // timeWindow24hMenuItem
            //
            this.timeWindow24hMenuItem.CheckOnClick = true;
            this.timeWindow24hMenuItem.Name = "timeWindow24hMenuItem";
            this.timeWindow24hMenuItem.Size = new System.Drawing.Size(107, 22);
            this.timeWindow24hMenuItem.Text = "24h";
            //
            // webMenuItemSeparator
            //
            this.webMenuItemSeparator.Name = "webMenuItemSeparator";
            this.webMenuItemSeparator.Size = new System.Drawing.Size(218, 6);
            //
            // webMenuItem
            //
            this.webMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.runWebServerMenuItem,
            this.serverInterfacePortMenuItem,
            this.authWebServerMenuItem});
            this.webMenuItem.Name = "webMenuItem";
            this.webMenuItem.Size = new System.Drawing.Size(221, 22);
            this.webMenuItem.Text = "Remote Web Server";
            //
            // runWebServerMenuItem
            //
            this.runWebServerMenuItem.Name = "runWebServerMenuItem";
            this.runWebServerMenuItem.Size = new System.Drawing.Size(153, 22);
            this.runWebServerMenuItem.Text = "Run";
            //
            // serverPortMenuItem
            //
            this.serverInterfacePortMenuItem.Name = "serverInterfacePortMenuItem";
            this.serverInterfacePortMenuItem.Size = new System.Drawing.Size(153, 22);
            this.serverInterfacePortMenuItem.Text = "Interface / Port";
            this.serverInterfacePortMenuItem.Click += new System.EventHandler(this.ServerInterfacePortMenuItem_Click);
            //
            // authWebServerMenuItem
            //
            this.authWebServerMenuItem.Name = "authWebServerMenuItem";
            this.authWebServerMenuItem.Size = new System.Drawing.Size(153, 22);
            this.authWebServerMenuItem.Text = "Authentication";
            this.authWebServerMenuItem.Click += new System.EventHandler(this.AuthWebServerMenuItem_Click);
            //
            // helpMenuItem
            //
            this.helpMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.aboutMenuItem});
            this.helpMenuItem.Name = "helpMenuItem";
            this.helpMenuItem.Size = new System.Drawing.Size(44, 20);
            this.helpMenuItem.Text = "Help";
            //
            // aboutMenuItem
            //
            this.aboutMenuItem.Name = "aboutMenuItem";
            this.aboutMenuItem.Size = new System.Drawing.Size(107, 22);
            this.aboutMenuItem.Text = "About";
            this.aboutMenuItem.Click += new System.EventHandler(this.AboutMenuItem_Click);
            //
            // treeContextMenu
            //
            this.treeContextMenu.Name = "treeContextMenu";
            this.treeContextMenu.Size = new System.Drawing.Size(61, 4);
            //
            // saveFileDialog
            //
            this.saveFileDialog.DefaultExt = "txt";
            this.saveFileDialog.FileName = "LibreHardwareMonitor.Report.txt";
            this.saveFileDialog.Filter = "Text Documents|*.txt|All Files|*.*";
            this.saveFileDialog.RestoreDirectory = true;
            this.saveFileDialog.Title = "Save Report As";
            //
            // timer
            //
            this.timer.Interval = 1000;
            this.timer.Tick += new System.EventHandler(this.Timer_Tick);
            //
            // splitContainer
            //
            this.splitContainer.Cursor = System.Windows.Forms.Cursors.Default;
            this.splitContainer.Location = new System.Drawing.Point(12, 12);
            this.splitContainer.Name = "splitContainer";
            this.splitContainer.Orientation = System.Windows.Forms.Orientation.Horizontal;
            //
            // splitContainer.Panel1
            //
            this.splitContainer.Panel1.Controls.Add(this.treeView);
            //
            // splitContainer.Panel2
            //
            this.splitContainer.Panel2.Cursor = System.Windows.Forms.Cursors.Default;
            this.splitContainer.Size = new System.Drawing.Size(386, 483);
            this.splitContainer.SplitterDistance = 354;
            this.splitContainer.SplitterWidth = 5;
            this.splitContainer.TabIndex = 3;
            //
            // treeView
            //
            this.treeView.BackColor = System.Drawing.SystemColors.Window;
            this.treeView.BorderStyle = System.Windows.Forms.BorderStyle.None;
            this.treeView.Columns.Add(this.sensor);
            this.treeView.Columns.Add(this.value);
            this.treeView.Columns.Add(this.min);
            this.treeView.Columns.Add(this.max);
            this.treeView.DefaultToolTipProvider = null;
            this.treeView.Dock = System.Windows.Forms.DockStyle.Fill;
            this.treeView.DragDropMarkColor = System.Drawing.Color.Black;
            this.treeView.FullRowSelect = true;
            this.treeView.GridLineStyle = Aga.Controls.Tree.GridLineStyle.Horizontal;
            this.treeView.LineColor = System.Drawing.SystemColors.ControlDark;
            this.treeView.Location = new System.Drawing.Point(0, 0);
            this.treeView.Model = null;
            this.treeView.Name = "treeView";
            this.treeView.NodeControls.Add(this.nodeImage);
            this.treeView.NodeControls.Add(this.nodeCheckBox);
            this.treeView.NodeControls.Add(this.nodeTextBoxText);
            this.treeView.NodeControls.Add(this.nodeTextBoxValue);
            this.treeView.NodeControls.Add(this.nodeTextBoxMin);
            this.treeView.NodeControls.Add(this.nodeTextBoxMax);
            this.treeView.SelectedNode = null;
            this.treeView.Size = new System.Drawing.Size(386, 354);
            this.treeView.TabIndex = 0;
            this.treeView.Text = "treeView";
            this.treeView.UseColumns = true;
            this.treeView.NodeMouseDoubleClick += new System.EventHandler<Aga.Controls.Tree.TreeNodeAdvMouseEventArgs>(this.TreeView_NodeMouseDoubleClick);
            this.treeView.Click += new System.EventHandler(this.TreeView_Click);
            this.treeView.MouseDown += new System.Windows.Forms.MouseEventHandler(this.TreeView_MouseDown);
            this.treeView.MouseMove += new System.Windows.Forms.MouseEventHandler(this.TreeView_MouseMove);
            this.treeView.MouseUp += new System.Windows.Forms.MouseEventHandler(this.TreeView_MouseUp);
            this.treeView.SizeChanged += new System.EventHandler(this.TreeView_SizeChanged);
            this.treeView.KeyDown += new System.Windows.Forms.KeyEventHandler(this.TreeView_KeyDown);
            //
            // batteryMenuItem
            //
            this.batteryMenuItem.Name = "batteryMenuItem";
            this.batteryMenuItem.Size = new System.Drawing.Size(180, 22);
            this.batteryMenuItem.Text = "Batteries";
            //
            // MainForm
            //
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(418, 533);
            this.Controls.Add(this.splitContainer);
            this.Controls.Add(this.mainMenu);
            this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
            this.MainMenuStrip = this.mainMenu;
            this.Name = "MainForm";
            this.StartPosition = System.Windows.Forms.FormStartPosition.Manual;
            this.Text = "Libre Hardware Monitor";
            this.Load += new System.EventHandler(this.MainForm_Load);
            this.ResizeEnd += new System.EventHandler(this.MainForm_MoveOrResize);
            this.Move += new System.EventHandler(this.MainForm_MoveOrResize);
            this.mainMenu.ResumeLayout(false);
            this.mainMenu.PerformLayout();
            this.splitContainer.Panel1.ResumeLayout(false);
            ((System.ComponentModel.ISupportInitialize)(this.splitContainer)).EndInit();
            this.splitContainer.ResumeLayout(false);
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private Aga.Controls.Tree.TreeViewAdv treeView;
        private System.Windows.Forms.MenuStrip mainMenu;
        private System.Windows.Forms.ToolStripMenuItem fileMenuItem;
        private System.Windows.Forms.ToolStripMenuItem exitMenuItem;
        private Aga.Controls.Tree.TreeColumn sensor;
        private Aga.Controls.Tree.TreeColumn value;
        private Aga.Controls.Tree.TreeColumn min;
        private Aga.Controls.Tree.TreeColumn max;
        private Aga.Controls.Tree.NodeControls.NodeIcon nodeImage;
        private Aga.Controls.Tree.NodeControls.NodeTextBox nodeTextBoxText;
        private Aga.Controls.Tree.NodeControls.NodeTextBox nodeTextBoxValue;
        private Aga.Controls.Tree.NodeControls.NodeTextBox nodeTextBoxMin;
        private Aga.Controls.Tree.NodeControls.NodeTextBox nodeTextBoxMax;
        private SplitContainerAdv splitContainer;
        private System.Windows.Forms.ToolStripMenuItem viewMenuItem;
        private System.Windows.Forms.ToolStripMenuItem plotMenuItem;
        private Aga.Controls.Tree.NodeControls.NodeCheckBox nodeCheckBox;
        private System.Windows.Forms.ToolStripMenuItem helpMenuItem;
        private System.Windows.Forms.ToolStripMenuItem aboutMenuItem;
        private System.Windows.Forms.ToolStripMenuItem saveReportMenuItem;
        private System.Windows.Forms.ToolStripMenuItem optionsMenuItem;
        private System.Windows.Forms.ToolStripMenuItem hddMenuItem;
        private System.Windows.Forms.ToolStripMenuItem minTrayMenuItem;
        private System.Windows.Forms.ToolStripSeparator separatorMenuItem;
        private System.Windows.Forms.ContextMenuStrip treeContextMenu;
        private System.Windows.Forms.ToolStripMenuItem startMinMenuItem;
        private System.Windows.Forms.ToolStripMenuItem startupMenuItem;
        private System.Windows.Forms.SaveFileDialog saveFileDialog;
        private System.Windows.Forms.Timer timer;
        private System.Windows.Forms.ToolStripMenuItem hiddenMenuItem;
        private System.Windows.Forms.ToolStripSeparator MenuItem1;
        private System.Windows.Forms.ToolStripMenuItem columnsMenuItem;
        private System.Windows.Forms.ToolStripMenuItem valueMenuItem;
        private System.Windows.Forms.ToolStripMenuItem minMenuItem;
        private System.Windows.Forms.ToolStripMenuItem maxMenuItem;
        private System.Windows.Forms.ToolStripMenuItem temperatureUnitsMenuItem;
        private System.Windows.Forms.ToolStripSeparator webMenuItemSeparator;
        private ToolStripRadioButtonMenuItem celsiusMenuItem;
        private ToolStripRadioButtonMenuItem fahrenheitMenuItem;
        private System.Windows.Forms.ToolStripSeparator MenuItem2;
        private System.Windows.Forms.ToolStripMenuItem resetMinMaxMenuItem;
        private System.Windows.Forms.ToolStripMenuItem expandAllNodesMenuItem;
        private System.Windows.Forms.ToolStripMenuItem collpaseAllNodesMenuItem;
        private System.Windows.Forms.ToolStripMenuItem resetPlotMenuItem;
        private System.Windows.Forms.ToolStripSeparator MenuItem3;
        private System.Windows.Forms.ToolStripMenuItem gadgetMenuItem;
        private System.Windows.Forms.ToolStripMenuItem minCloseMenuItem;
        private System.Windows.Forms.ToolStripMenuItem resetMenuItem;
        private System.Windows.Forms.ToolStripSeparator menuItem6;
        private System.Windows.Forms.ToolStripMenuItem plotLocationMenuItem;
        private ToolStripRadioButtonMenuItem plotWindowMenuItem;
        private ToolStripRadioButtonMenuItem plotBottomMenuItem;
        private ToolStripRadioButtonMenuItem plotRightMenuItem;
        private System.Windows.Forms.ToolStripMenuItem splitPlotPanelScalingMenuItem;
        private ToolStripRadioButtonMenuItem splitPanelPercentageScalingMenuItem;
        private ToolStripRadioButtonMenuItem splitPanelFixedPlotScalingMenuItem;
        private ToolStripRadioButtonMenuItem splitPanelFixedSensorScalingMenuItem;
        private System.Windows.Forms.ToolStripMenuItem webMenuItem;
        private System.Windows.Forms.ToolStripMenuItem runWebServerMenuItem;
        private System.Windows.Forms.ToolStripMenuItem serverInterfacePortMenuItem;
        private System.Windows.Forms.ToolStripMenuItem menuItemFileHardware;
        private System.Windows.Forms.ToolStripMenuItem mainboardMenuItem;
        private System.Windows.Forms.ToolStripMenuItem cpuMenuItem;
        private System.Windows.Forms.ToolStripMenuItem gpuMenuItem;
        private System.Windows.Forms.ToolStripMenuItem powerMonitorMenuItem;
        private System.Windows.Forms.ToolStripMenuItem fanControllerMenuItem;
        private System.Windows.Forms.ToolStripMenuItem ramMenuItem;
        private System.Windows.Forms.ToolStripMenuItem logSensorsMenuItem;
        private System.Windows.Forms.ToolStripSeparator logSeparatorMenuItem;
        private System.Windows.Forms.ToolStripMenuItem loggingIntervalMenuItem;
        private ToolStripRadioButtonMenuItem log1sMenuItem;
        private ToolStripRadioButtonMenuItem log2sMenuItem;
        private ToolStripRadioButtonMenuItem log5sMenuItem;
        private ToolStripRadioButtonMenuItem log10sMenuItem;
        private ToolStripRadioButtonMenuItem log30sMenuItem;
        private ToolStripRadioButtonMenuItem log1minMenuItem;
        private ToolStripRadioButtonMenuItem log2minMenuItem;
        private ToolStripRadioButtonMenuItem log5minMenuItem;
        private ToolStripRadioButtonMenuItem log10minMenuItem;
        private ToolStripRadioButtonMenuItem log30minMenuItem;
        private ToolStripRadioButtonMenuItem log1hMenuItem;
        private ToolStripRadioButtonMenuItem log2hMenuItem;
        private ToolStripRadioButtonMenuItem log6hMenuItem;
        private System.Windows.Forms.ToolStripMenuItem updateIntervalMenuItem;
        private ToolStripRadioButtonMenuItem updateInterval250msMenuItem;
        private ToolStripRadioButtonMenuItem updateInterval500msMenuItem;
        private ToolStripRadioButtonMenuItem updateInterval1sMenuItem;
        private ToolStripRadioButtonMenuItem updateInterval2sMenuItem;
        private ToolStripRadioButtonMenuItem updateInterval5sMenuItem;
        private ToolStripRadioButtonMenuItem updateInterval10sMenuItem;
        private System.Windows.Forms.ToolStripMenuItem throttleAtaUpdateMenuItem;
        private System.Windows.Forms.ToolStripMenuItem nicMenuItem;
        private System.Windows.Forms.ToolStripMenuItem sensorValuesTimeWindowMenuItem;
        private ToolStripRadioButtonMenuItem timeWindow30sMenuItem;
        private ToolStripRadioButtonMenuItem timeWindow1minMenuItem;
        private ToolStripRadioButtonMenuItem timeWindow2minMenuItem;
        private ToolStripRadioButtonMenuItem timeWindow5minMenuItem;
        private ToolStripRadioButtonMenuItem timeWindow10minMenuItem;
        private ToolStripRadioButtonMenuItem timeWindow30minMenuItem;
        private ToolStripRadioButtonMenuItem timeWindow1hMenuItem;
        private ToolStripRadioButtonMenuItem timeWindow2hMenuItem;
        private ToolStripRadioButtonMenuItem timeWindow6hMenuItem;
        private ToolStripRadioButtonMenuItem timeWindow12hMenuItem;
        private ToolStripRadioButtonMenuItem timeWindow24hMenuItem;
        private System.Windows.Forms.ToolStripMenuItem authWebServerMenuItem;
        private System.Windows.Forms.ToolStripMenuItem psuMenuItem;
        private System.Windows.Forms.ToolStripMenuItem batteryMenuItem;
        private System.ComponentModel.BackgroundWorker backgroundUpdater;
        private System.Windows.Forms.ToolStripMenuItem fileRotationMethod;
        private ToolStripRadioButtonMenuItem perSessionFileRotationMenuItem;
        private ToolStripRadioButtonMenuItem dailyFileRotationMenuItem;
        private System.Windows.Forms.ToolStripMenuItem themeMenuItem;
        private System.Windows.Forms.ToolStripMenuItem strokeThicknessMenuItem;
        private ToolStripRadioButtonMenuItem strokeThickness4ptMenuItem;
        private ToolStripRadioButtonMenuItem strokeThickness1ptMenuItem;
        private ToolStripRadioButtonMenuItem strokeThickness2ptMenuItem;
        private ToolStripRadioButtonMenuItem strokeThickness3ptMenuItem;
    }
}


```

`LibreHardwareMonitor/UI/MainForm.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using Aga.Controls.Tree;
using Aga.Controls.Tree.NodeControls;
using LibreHardwareMonitor.Hardware;
using LibreHardwareMonitor.Hardware.Storage;
using LibreHardwareMonitor.UI.Themes;
using LibreHardwareMonitor.Utilities;

namespace LibreHardwareMonitor.UI;

public sealed partial class MainForm : Form
{
    private ToolStripMenuItem _autoThemeMenuItem;
    private readonly UserOption _autoStart;
    private readonly Computer _computer;
    private readonly SensorGadget _gadget;
    private readonly Logger _logger;
    private readonly UserRadioGroup _loggingInterval;
    private readonly UserRadioGroup _updateInterval;
    private readonly UserOption _throttleAtaUpdate;
    private readonly UserOption _logSensors;
    private readonly UserOption _minimizeOnClose;
    private readonly UserOption _minimizeToTray;
    private readonly PlotPanel _plotPanel;
    private readonly UserOption _readBatterySensors;
    private readonly UserOption _readCpuSensors;
    private readonly UserOption _readFanControllersSensors;
    private readonly UserOption _readGpuSensors;
    private readonly UserOption _readPowerMonitorSensors;
    private readonly UserOption _readHddSensors;
    private readonly UserOption _readMainboardSensors;
    private readonly UserOption _readNicSensors;
    private readonly UserOption _readPsuSensors;
    private readonly UserOption _readRamSensors;
    private readonly Node _root;
    private readonly UserOption _runWebServer;
    private readonly UserRadioGroup _sensorValuesTimeWindow;
    private readonly PersistentSettings _settings;
    private readonly UserOption _showGadget;
    private readonly StartupManager _startupManager = new();
    private readonly SystemTray _systemTray;
    private readonly UnitManager _unitManager;
    private readonly UpdateVisitor _updateVisitor = new();

    private int _delayCount;
    private Form _plotForm;
    private UserRadioGroup _plotLocation;
    private UserRadioGroup _splitPanelScalingSetting;
    private bool _selectionDragging;
    private IDictionary<ISensor, Color> _sensorPlotColors = new Dictionary<ISensor, Color>();
    private UserOption _showPlot;
    private UserRadioGroup _strokeThickness;
    private double _plotStrokeThickness = 2;

    public MainForm()
    {
        InitializeComponent();

        _settings = new PersistentSettings();
        _settings.Load(Path.ChangeExtension(Application.ExecutablePath, ".config"));

        _unitManager = new UnitManager(_settings);

        // make sure the buffers used for double buffering are not disposed
        // after each draw call
        BufferedGraphicsManager.Current.MaximumBuffer = Screen.PrimaryScreen.Bounds.Size;

        // set the DockStyle here, to avoid conflicts with the MainMenu
        splitContainer.Dock = DockStyle.Fill;

        Font = SystemFonts.MessageBoxFont;
        treeView.Font = SystemFonts.MessageBoxFont;

        // Set the bounds immediately, so that our child components can be
        // properly placed.
        Bounds = new Rectangle
        {
            X = _settings.GetValue("mainForm.Location.X", Location.X),
            Y = _settings.GetValue("mainForm.Location.Y", Location.Y),
            Width = _settings.GetValue("mainForm.Width", 470),
            Height = _settings.GetValue("mainForm.Height", 640)
        };

        Theme setTheme = Theme.All.FirstOrDefault(theme => _settings.GetValue("theme", "auto") == theme.Id);
        if (setTheme != null)
        {
            Theme.Current = setTheme;
        }
        else
        {
            Theme.SetAutoTheme();
        }

        _plotPanel = new PlotPanel(_settings, _unitManager) { Font = SystemFonts.MessageBoxFont, Dock = DockStyle.Fill };

        nodeCheckBox.IsVisibleValueNeeded += NodeCheckBox_IsVisibleValueNeeded;
        nodeTextBoxText.DrawText += NodeTextBoxText_DrawText;
        nodeTextBoxValue.DrawText += NodeTextBoxText_DrawText;
        nodeTextBoxMin.DrawText += NodeTextBoxText_DrawText;
        nodeTextBoxMax.DrawText += NodeTextBoxText_DrawText;
        nodeTextBoxText.EditorShowing += NodeTextBoxText_EditorShowing;

        for (int i = 1; i < treeView.Columns.Count; i++)
        {
            TreeColumn column = treeView.Columns[i];
            column.Width = Math.Max(20, Math.Min(400, _settings.GetValue("treeView.Columns." + column.Header + ".Width", column.Width)));
        }

        TreeModel treeModel = new();
        _root = new Node(Environment.MachineName) { Image = EmbeddedResources.GetImage("computer.png") };

        treeModel.Nodes.Add(_root);
        treeView.Model = treeModel;

        _computer = new Computer(_settings);

        _systemTray = new SystemTray(_computer, _settings, _unitManager);
        _systemTray.HideShowCommand += HideShowClick;
        _systemTray.ExitCommand += ExitClick;

        if (Software.OperatingSystem.IsUnix)
        {
            // Unix
            treeView.RowHeight = Math.Max(treeView.RowHeight, 18);
            splitContainer.BorderStyle = BorderStyle.None;
            splitContainer.SplitterWidth = 4;
            treeView.BorderStyle = BorderStyle.Fixed3D;
            _plotPanel.BorderStyle = BorderStyle.Fixed3D;
            gadgetMenuItem.Visible = false;
            minCloseMenuItem.Visible = false;
            minTrayMenuItem.Visible = false;
            startMinMenuItem.Visible = false;
        }
        else
        {
            // Windows
            treeView.RowHeight = Math.Max(treeView.Font.Height + 1, 18);
            _gadget = new SensorGadget(_computer, _settings, _unitManager);
            _gadget.HideShowCommand += HideShowClick;
        }

        treeView.ShowNodeToolTips = true;
        NodeToolTipProvider tooltipProvider = new();
        nodeTextBoxText.ToolTipProvider = tooltipProvider;
        nodeTextBoxValue.ToolTipProvider = tooltipProvider;
        _logger = new Logger(_computer);
        var saved = _settings.GetValue("logger.fileRotation", 0); // 0 = PerSession, 1 = Daily.
        _logger.FileRotationMethod = (LoggerFileRotation)Math.Max(0, Math.Min(saved, 1));
        perSessionFileRotationMenuItem.Checked = _logger.FileRotationMethod == LoggerFileRotation.PerSession;
        dailyFileRotationMenuItem.Checked = _logger.FileRotationMethod == LoggerFileRotation.Daily;

        _computer.HardwareAdded += HardwareAdded;
        _computer.HardwareRemoved += HardwareRemoved;

        if (PawnIo.PawnIo.IsInstalled)
        {
            if (PawnIo.PawnIo.Version < new Version(2, 0, 0, 0))
            {
                DialogResult result = MessageBox.Show("PawnIO is outdated, do you want to update it?", nameof(LibreHardwareMonitor), MessageBoxButtons.OKCancel);
                if (result == DialogResult.OK)
                    InstallPawnIO();
            }
        }
        else
        {
            DialogResult result = MessageBox.Show("PawnIO is not installed, do you want to install it?", nameof(LibreHardwareMonitor), MessageBoxButtons.OKCancel);
            if (result == DialogResult.OK)
                InstallPawnIO();
        }

        _computer.Open();

        static void InstallPawnIO()
        {
            string path = ExtractPawnIO();
            if (!string.IsNullOrEmpty(path))
            {
                var process = Process.Start(new ProcessStartInfo(path, "-install"));
                process?.WaitForExit();

                File.Delete(path);
            }
        }

        static string ExtractPawnIO()
        {
            string destination = Path.Combine(Directory.GetCurrentDirectory(), "PawnIO_setup.exe");

            try
            {

                using Stream resourceStream = typeof(MainForm).Assembly.GetManifestResourceStream("LibreHardwareMonitor.Resources.PawnIO_setup.exe");
                using FileStream fileStream = new(destination, FileMode.Create, FileAccess.Write);
                resourceStream.CopyTo(fileStream);

                return destination;
            }
            catch
            {
                return null;
            }
        }

        backgroundUpdater.DoWork += BackgroundUpdater_DoWork;
        timer.Enabled = true;

        UserOption showHiddenSensors = new("hiddenMenuItem", false, hiddenMenuItem, _settings);
        showHiddenSensors.Changed += delegate { treeModel.ForceVisible = showHiddenSensors.Value; };

        UserOption showValue = new("valueMenuItem", true, valueMenuItem, _settings);
        showValue.Changed += delegate { treeView.Columns[1].IsVisible = showValue.Value; };

        UserOption showMin = new("minMenuItem", false, minMenuItem, _settings);
        showMin.Changed += delegate { treeView.Columns[2].IsVisible = showMin.Value; };

        UserOption showMax = new("maxMenuItem", true, maxMenuItem, _settings);
        showMax.Changed += delegate { treeView.Columns[3].IsVisible = showMax.Value; };

        _ = new UserOption("startMinMenuItem", false, startMinMenuItem, _settings);
        _minimizeToTray = new UserOption("minTrayMenuItem", true, minTrayMenuItem, _settings);
        _minimizeToTray.Changed += delegate { _systemTray.IsMainIconEnabled = _minimizeToTray.Value; };

        _minimizeOnClose = new UserOption("minCloseMenuItem", false, minCloseMenuItem, _settings);

        _autoStart = new UserOption(null, _startupManager.Startup, startupMenuItem, _settings);
        _autoStart.Changed += delegate
        {
            try
            {
                _startupManager.Startup = _autoStart.Value;
            }
            catch (InvalidOperationException)
            {
                MessageBox.Show("Updating the auto-startup option failed.",
                                "Error",
                                MessageBoxButtons.OK,
                                MessageBoxIcon.Error);

                _autoStart.Value = _startupManager.Startup;
            }
        };

        _readMainboardSensors = new UserOption("mainboardMenuItem", true, mainboardMenuItem, _settings);
        _readMainboardSensors.Changed += delegate { _computer.IsMotherboardEnabled = _readMainboardSensors.Value; };

        _readCpuSensors = new UserOption("cpuMenuItem", true, cpuMenuItem, _settings);
        _readCpuSensors.Changed += delegate { _computer.IsCpuEnabled = _readCpuSensors.Value; };

        _readRamSensors = new UserOption("ramMenuItem", true, ramMenuItem, _settings);
        _readRamSensors.Changed += delegate { _computer.IsMemoryEnabled = _readRamSensors.Value; };

        _readGpuSensors = new UserOption("gpuMenuItem", true, gpuMenuItem, _settings);
        _readGpuSensors.Changed += delegate { _computer.IsGpuEnabled = _readGpuSensors.Value; };

        _readPowerMonitorSensors = new UserOption("powerMonitorMenuItem", true, powerMonitorMenuItem, _settings);
        _readPowerMonitorSensors.Changed += delegate { _computer.IsPowerMonitorEnabled = _readPowerMonitorSensors.Value; };

        _readFanControllersSensors = new UserOption("fanControllerMenuItem", true, fanControllerMenuItem, _settings);
        _readFanControllersSensors.Changed += delegate { _computer.IsControllerEnabled = _readFanControllersSensors.Value; };

        _readHddSensors = new UserOption("hddMenuItem", true, hddMenuItem, _settings);
        _readHddSensors.Changed += delegate { _computer.IsStorageEnabled = _readHddSensors.Value; };

        _readNicSensors = new UserOption("nicMenuItem", true, nicMenuItem, _settings);
        _readNicSensors.Changed += delegate { _computer.IsNetworkEnabled = _readNicSensors.Value; };

        _readPsuSensors = new UserOption("psuMenuItem", true, psuMenuItem, _settings);
        _readPsuSensors.Changed += delegate { _computer.IsPsuEnabled = _readPsuSensors.Value; };

        _readBatterySensors = new UserOption("batteryMenuItem", true, batteryMenuItem, _settings);
        _readBatterySensors.Changed += delegate { _computer.IsBatteryEnabled = _readBatterySensors.Value; };

        _showGadget = new UserOption("gadgetMenuItem", false, gadgetMenuItem, _settings);

        // Prevent Menu From Closing When UnClicking Hardware Items
        menuItemFileHardware.DropDown.Closing += StopFileHardwareMenuFromClosing;


        _showGadget.Changed += delegate
        {
            if (_gadget != null)
                _gadget.Visible = _showGadget.Value;
        };

        celsiusMenuItem.Checked = _unitManager.TemperatureUnit == TemperatureUnit.Celsius;
        fahrenheitMenuItem.Checked = !celsiusMenuItem.Checked;

        Server = new HttpServer(_root,
                                _computer,
                                _settings.GetValue("listenerIp", "?"),
                                _settings.GetValue("listenerPort", 8085),
                                _settings.GetValue("authenticationEnabled", false),
                                _settings.GetValue("authenticationUserName", ""),
                                _settings.GetValue("authenticationPassword", ""));

        if (Server.PlatformNotSupported)
        {
            webMenuItemSeparator.Visible = false;
            webMenuItem.Visible = false;
        }

        _runWebServer = new UserOption("runWebServerMenuItem", false, runWebServerMenuItem, _settings);
        _runWebServer.Changed += delegate
        {
            if (_runWebServer.Value)
                Server.StartHttpListener();
            else
                Server.StopHttpListener();
        };

        authWebServerMenuItem.Checked = _settings.GetValue("authenticationEnabled", false);

        _logSensors = new UserOption("logSensorsMenuItem", false, logSensorsMenuItem, _settings);

        _loggingInterval = new UserRadioGroup("loggingInterval",
                                              0,
                                              new[]
                                              {
                                                  log1sMenuItem,
                                                  log2sMenuItem,
                                                  log5sMenuItem,
                                                  log10sMenuItem,
                                                  log30sMenuItem,
                                                  log1minMenuItem,
                                                  log2minMenuItem,
                                                  log5minMenuItem,
                                                  log10minMenuItem,
                                                  log30minMenuItem,
                                                  log1hMenuItem,
                                                  log2hMenuItem,
                                                  log6hMenuItem
                                              },
                                              _settings);

        _loggingInterval.Changed += (sender, e) =>
        {
            switch (_loggingInterval.Value)
            {
                case 0:
                    _logger.LoggingInterval = new TimeSpan(0, 0, 1);
                    break;
                case 1:
                    _logger.LoggingInterval = new TimeSpan(0, 0, 2);
                    break;
                case 2:
                    _logger.LoggingInterval = new TimeSpan(0, 0, 5);
                    break;
                case 3:
                    _logger.LoggingInterval = new TimeSpan(0, 0, 10);
                    break;
                case 4:
                    _logger.LoggingInterval = new TimeSpan(0, 0, 30);
                    break;
                case 5:
                    _logger.LoggingInterval = new TimeSpan(0, 1, 0);
                    break;
                case 6:
                    _logger.LoggingInterval = new TimeSpan(0, 2, 0);
                    break;
                case 7:
                    _logger.LoggingInterval = new TimeSpan(0, 5, 0);
                    break;
                case 8:
                    _logger.LoggingInterval = new TimeSpan(0, 10, 0);
                    break;
                case 9:
                    _logger.LoggingInterval = new TimeSpan(0, 30, 0);
                    break;
                case 10:
                    _logger.LoggingInterval = new TimeSpan(1, 0, 0);
                    break;
                case 11:
                    _logger.LoggingInterval = new TimeSpan(2, 0, 0);
                    break;
                case 12:
                    _logger.LoggingInterval = new TimeSpan(6, 0, 0);
                    break;
            }
        };

        _updateInterval = new UserRadioGroup("updateIntervalMenuItem",
                                             2,
                                             new[]
                                             {
                                                 updateInterval250msMenuItem,
                                                 updateInterval500msMenuItem,
                                                 updateInterval1sMenuItem,
                                                 updateInterval2sMenuItem,
                                                 updateInterval5sMenuItem,
                                                 updateInterval10sMenuItem
                                             },
                                             _settings);

        _updateInterval.Changed += (sender, e) =>
        {
            switch (_updateInterval.Value)
            {
                case 0:
                    timer.Interval = 250;
                    break;
                case 1:
                    timer.Interval = 500;
                    break;
                case 2:
                    timer.Interval = 1000;
                    break;
                case 3:
                    timer.Interval = 2000;
                    break;
                case 4:
                    timer.Interval = 5000;
                    break;
                case 5:
                    timer.Interval = 10000;
                    break;
            }
        };

        _throttleAtaUpdate = new UserOption("throttleAtaUpdateMenuItem", false, throttleAtaUpdateMenuItem, _settings);
        _throttleAtaUpdate.Changed += (sender, e) =>
        {
            switch (_throttleAtaUpdate.Value)
            {
                case true:
                    StorageDevice.ThrottleInterval = TimeSpan.FromSeconds(30);
                    break;

                case false:
                    StorageDevice.ThrottleInterval = TimeSpan.Zero;
                    break;
            }
        };

        _sensorValuesTimeWindow = new UserRadioGroup("sensorValuesTimeWindow",
                                                     10,
                                                     new[]
                                                     {
                                                         timeWindow30sMenuItem,
                                                         timeWindow1minMenuItem,
                                                         timeWindow2minMenuItem,
                                                         timeWindow5minMenuItem,
                                                         timeWindow10minMenuItem,
                                                         timeWindow30minMenuItem,
                                                         timeWindow1hMenuItem,
                                                         timeWindow2hMenuItem,
                                                         timeWindow6hMenuItem,
                                                         timeWindow12hMenuItem,
                                                         timeWindow24hMenuItem
                                                     },
                                                     _settings);

        perSessionFileRotationMenuItem.Checked = _logger.FileRotationMethod == LoggerFileRotation.PerSession;
        dailyFileRotationMenuItem.Checked = _logger.FileRotationMethod == LoggerFileRotation.Daily;

        _sensorValuesTimeWindow.Changed += (sender, e) =>
        {
            TimeSpan timeWindow = TimeSpan.Zero;
            switch (_sensorValuesTimeWindow.Value)
            {
                case 0:
                    timeWindow = new TimeSpan(0, 0, 30);
                    break;
                case 1:
                    timeWindow = new TimeSpan(0, 1, 0);
                    break;
                case 2:
                    timeWindow = new TimeSpan(0, 2, 0);
                    break;
                case 3:
                    timeWindow = new TimeSpan(0, 5, 0);
                    break;
                case 4:
                    timeWindow = new TimeSpan(0, 10, 0);
                    break;
                case 5:
                    timeWindow = new TimeSpan(0, 30, 0);
                    break;
                case 6:
                    timeWindow = new TimeSpan(1, 0, 0);
                    break;
                case 7:
                    timeWindow = new TimeSpan(2, 0, 0);
                    break;
                case 8:
                    timeWindow = new TimeSpan(6, 0, 0);
                    break;
                case 9:
                    timeWindow = new TimeSpan(12, 0, 0);
                    break;
                case 10:
                    timeWindow = new TimeSpan(24, 0, 0);
                    break;
            }

            _computer.Accept(new SensorVisitor(delegate(ISensor sensor) { sensor.ValuesTimeWindow = timeWindow; }));
        };

        InitializeTheme();
        InitializePlotForm();
        InitializeSplitter();

        startupMenuItem.Visible = _startupManager.IsAvailable;

        if (startMinMenuItem.Checked)
        {
            if (!minTrayMenuItem.Checked)
            {
                WindowState = FormWindowState.Minimized;
                Show();
            }
        }
        else
        {
            Show();
        }

        // Create a handle, otherwise calling Close() does not fire FormClosed

        // Make sure the settings are saved when the user logs off
        Microsoft.Win32.SystemEvents.SessionEnded += delegate
        {
            _computer.Close();
            SaveConfiguration();
            if (_runWebServer.Value)
                Server.Quit();
        };

        Microsoft.Win32.SystemEvents.PowerModeChanged += PowerModeChanged;
    }

    private void StopFileHardwareMenuFromClosing(object sender, ToolStripDropDownClosingEventArgs e)
    {
        if (e.CloseReason == ToolStripDropDownCloseReason.ItemClicked)
        {
            e.Cancel = true;
        }
    }

    public bool AuthWebServerMenuItemChecked
    {
        get { return authWebServerMenuItem.Checked; }
        set { authWebServerMenuItem.Checked = value; }
    }

    public HttpServer Server { get; }

    private void BackgroundUpdater_DoWork(object sender, DoWorkEventArgs e)
    {
        _computer.Accept(_updateVisitor);

        if (_logSensors != null && _logSensors.Value && _delayCount >= 4)
            _logger.Log();

        if (_delayCount < 4)
            _delayCount++;

        _plotPanel.InvalidatePlot();
    }

    private void PowerModeChanged(object sender, Microsoft.Win32.PowerModeChangedEventArgs eventArgs)
    {
        if (eventArgs.Mode == Microsoft.Win32.PowerModes.Resume)
        {
            _computer.Reset();
        }
    }

    private void InitializeTheme()
    {
        mainMenu.Renderer = new ThemedToolStripRenderer();
        treeContextMenu.Renderer = new ThemedToolStripRenderer();
        ThemedVScrollIndicator.AddToControl(treeView);
        ThemedHScrollIndicator.AddToControl(treeView);

        string themeSetting = _settings.GetValue("theme", "auto");
        bool themeSelected = false;

        void ClearThemeMenu()
        {
            foreach (ToolStripItem x in themeMenuItem.DropDownItems)
            {
                if (x is ToolStripMenuItem tmi)
                {
                    tmi.Checked = false;
                }
            }
        }

        if (Theme.SupportsAutoThemeSwitching())
        {
            _autoThemeMenuItem = new ToolStripMenuItem();
            _autoThemeMenuItem.Text = "Auto";
            _autoThemeMenuItem.Click += (o, e) =>
            {
                ClearThemeMenu();
                _autoThemeMenuItem.Checked = true;
                Theme.SetAutoTheme();
                _settings.SetValue("theme", "auto");
                PlotSelectionChanged(o, e);
            };
            themeMenuItem.DropDownItems.Add(_autoThemeMenuItem);
        }

        foreach (Theme theme in Theme.All)
        {
            ToolStripMenuItem item = new ToolStripMenuItem();
            item.Text = theme.DisplayName;
            item.Click += (o, e) =>
            {
                ClearThemeMenu();
                item.Checked = true;
                Theme.Current = theme;
                _settings.SetValue("theme", theme.Id);
                PlotSelectionChanged(o, e);
            };
            themeMenuItem.DropDownItems.Add(item);

            if (themeSetting == theme.Id)
            {
                item.PerformClick();
                themeSelected = true;
            }
        }

        if (!themeSelected)
        {
            themeMenuItem.DropDownItems[0].PerformClick();
        }

        Theme.Current.Apply(this);
    }

    private void InitializeSplitter()
    {
        splitContainer.SplitterDistance = _settings.GetValue("splitContainer.SplitterDistance", 400);
        splitContainer.SplitterMoved += delegate { _settings.SetValue("splitContainer.SplitterDistance", splitContainer.SplitterDistance); };
    }

    private void InitializePlotForm()
    {
        _plotForm = new Form { FormBorderStyle = FormBorderStyle.SizableToolWindow, ShowInTaskbar = false, StartPosition = FormStartPosition.Manual };
        AddOwnedForm(_plotForm);
        _plotForm.Bounds = new Rectangle
        {
            X = _settings.GetValue("plotForm.Location.X", -100000),
            Y = _settings.GetValue("plotForm.Location.Y", 100),
            Width = _settings.GetValue("plotForm.Width", 600),
            Height = _settings.GetValue("plotForm.Height", 400)
        };

        _showPlot = new UserOption("plotMenuItem", false, plotMenuItem, _settings);
        _plotLocation = new UserRadioGroup("plotLocation", 0, new[] { plotWindowMenuItem, plotBottomMenuItem, plotRightMenuItem }, _settings);
        _splitPanelScalingSetting = new UserRadioGroup("splitPanelScalingSetting", 0, new[] { splitPanelPercentageScalingMenuItem, splitPanelFixedPlotScalingMenuItem, splitPanelFixedSensorScalingMenuItem }, _settings);

        _showPlot.Changed += delegate
        {
            if (_plotLocation.Value == 0)
            {
                if (_showPlot.Value && Visible)
                {
                    Theme.Current.Apply(_plotForm);
                    _plotForm.Show();
                }
                else
                    _plotForm.Hide();
            }
            else
            {
                splitContainer.Panel2Collapsed = !_showPlot.Value;
            }

            treeView.Invalidate();
        };

        _strokeThickness = new UserRadioGroup("plotStroke", 1, new[] { strokeThickness1ptMenuItem, strokeThickness2ptMenuItem, strokeThickness3ptMenuItem, strokeThickness4ptMenuItem }, _settings);

        _strokeThickness.Changed += (sender, e) =>
        {
            _plotStrokeThickness = (_strokeThickness.Value >= 0 && _strokeThickness.Value <= 3)
                                                   ? _strokeThickness.Value + 1
                                                   : 4;
            _plotPanel.UpdateStrokeThickness(_plotStrokeThickness);
        };

        _plotLocation.Changed += delegate
        {
            switch (_plotLocation.Value)
            {
                case 0:
                    splitContainer.Panel2.Controls.Clear();
                    splitContainer.Panel2Collapsed = true;
                    _plotForm.Controls.Add(_plotPanel);
                    if (_showPlot.Value && Visible)
                        _plotForm.Show();
                    break;
                case 1:
                    _plotForm.Controls.Clear();
                    _plotForm.Hide();
                    splitContainer.Orientation = Orientation.Horizontal;
                    splitContainer.Panel2.Controls.Add(_plotPanel);
                    splitContainer.Panel2Collapsed = !_showPlot.Value;
                    break;
                case 2:
                    _plotForm.Controls.Clear();
                    _plotForm.Hide();
                    splitContainer.Orientation = Orientation.Vertical;
                    splitContainer.Panel2.Controls.Add(_plotPanel);
                    splitContainer.Panel2Collapsed = !_showPlot.Value;
                    break;
            }
        };

        _splitPanelScalingSetting.Changed += delegate
        {
            switch (_splitPanelScalingSetting.Value)
            {
                case 0:
                    splitContainer.FixedPanel = FixedPanel.None;
                    break;
                case 1:
                    splitContainer.FixedPanel = FixedPanel.Panel2;
                    break;
                case 2:
                    splitContainer.FixedPanel = FixedPanel.Panel1;
                    break;
            }
        };

        _plotForm.FormClosing += delegate(object sender, FormClosingEventArgs e)
        {
            if (e.CloseReason == CloseReason.UserClosing)
            {
                // just switch off the plotting when the user closes the form
                if (_plotLocation.Value == 0)
                {
                    _showPlot.Value = false;
                }

                e.Cancel = true;
            }
        };

        void MoveOrResizePlotForm(object sender, EventArgs e)
        {
            if (_plotForm.WindowState != FormWindowState.Minimized)
            {
                _settings.SetValue("plotForm.Location.X", _plotForm.Bounds.X);
                _settings.SetValue("plotForm.Location.Y", _plotForm.Bounds.Y);
                _settings.SetValue("plotForm.Width", _plotForm.Bounds.Width);
                _settings.SetValue("plotForm.Height", _plotForm.Bounds.Height);
            }
        }

        _plotForm.Move += MoveOrResizePlotForm;
        _plotForm.Resize += MoveOrResizePlotForm;

        _plotForm.VisibleChanged += delegate
        {
            Rectangle bounds = new(_plotForm.Location, _plotForm.Size);
            Screen screen = Screen.FromRectangle(bounds);
            Rectangle intersection = Rectangle.Intersect(screen.WorkingArea, bounds);
            if (intersection.Width < Math.Min(16, bounds.Width) ||
                intersection.Height < Math.Min(16, bounds.Height))
            {
                _plotForm.Location = new Point(screen.WorkingArea.Width / 2 - bounds.Width / 2,
                                               screen.WorkingArea.Height / 2 - bounds.Height / 2);
            }
        };

        VisibleChanged += delegate
        {
            if (Visible && _showPlot.Value && _plotLocation.Value == 0)
                _plotForm.Show();
            else
                _plotForm.Hide();
        };

        Theme.Current.Apply(_plotForm);
    }

    private void InsertSorted(IList<Node> nodes, HardwareNode node)
    {
        int i = 0;
        while (i < nodes.Count && nodes[i] is HardwareNode && ((HardwareNode)nodes[i]).Hardware.HardwareType <= node.Hardware.HardwareType)
            i++;

        nodes.Insert(i, node);
    }

    private void SubHardwareAdded(IHardware hardware, Node node)
    {
        HardwareNode hardwareNode = new(hardware, _settings, _unitManager);
        hardwareNode.PlotSelectionChanged += PlotSelectionChanged;
        InsertSorted(node.Nodes, hardwareNode);
        foreach (IHardware subHardware in hardware.SubHardware)
            SubHardwareAdded(subHardware, hardwareNode);
    }

    private void HardwareAdded(IHardware hardware)
    {
        SubHardwareAdded(hardware, _root);
        PlotSelectionChanged(this, null);
    }

    private void HardwareRemoved(IHardware hardware)
    {
        List<HardwareNode> nodesToRemove = new();
        foreach (Node node in _root.Nodes)
        {
            if (node is HardwareNode hardwareNode && hardwareNode.Hardware == hardware)
                nodesToRemove.Add(hardwareNode);
        }

        foreach (HardwareNode hardwareNode in nodesToRemove)
        {
            _root.Nodes.Remove(hardwareNode);
            hardwareNode.PlotSelectionChanged -= PlotSelectionChanged;
        }

        PlotSelectionChanged(this, null);
    }

    private void NodeTextBoxText_DrawText(object sender, DrawEventArgs e)
    {
        if (e.Node.Tag is Node node)
        {
            if (node.IsVisible)
            {
                if (plotMenuItem.Checked && node is SensorNode sensorNode && _sensorPlotColors.TryGetValue(sensorNode.Sensor, out Color color))
                    e.TextColor = color;
            }
            else
                e.TextColor = Color.DarkGray;
        }
    }

    private void PlotSelectionChanged(object sender, EventArgs e)
    {
        List<ISensor> selected = new();
        IDictionary<ISensor, Color> colors = new Dictionary<ISensor, Color>();
        int colorIndex = 0;

        foreach (TreeNodeAdv node in treeView.AllNodes)
        {
            if (node.Tag is SensorNode sensorNode)
            {
                if (sensorNode.Plot)
                {
                    if (!sensorNode.PenColor.HasValue)
                    {
                        colors.Add(sensorNode.Sensor,
                                   Theme.Current.PlotColorPalette[colorIndex % Theme.Current.PlotColorPalette.Length]);
                    }

                    selected.Add(sensorNode.Sensor);
                }

                colorIndex++;
            }
        }

        // if a sensor is assigned a color that's already being used by another
        // sensor, try to assign it a new color. This is done only after the
        // previous loop sets an unchanging default color for all sensors, so that
        // colors jump around as little as possible as sensors get added/removed
        // from the plot
        var usedColors = new List<Color>();
        foreach (ISensor curSelectedSensor in selected)
        {
            if (!colors.ContainsKey(curSelectedSensor))
                continue;

            Color curColor = colors[curSelectedSensor];
            if (usedColors.Contains(curColor))
            {
                foreach (Color potentialNewColor in Theme.Current.PlotColorPalette)
                {
                    if (!colors.Values.Contains(potentialNewColor))
                    {
                        colors[curSelectedSensor] = potentialNewColor;
                        usedColors.Add(potentialNewColor);
                        break;
                    }
                }
            }
            else
            {
                usedColors.Add(curColor);
            }
        }

        foreach (TreeNodeAdv node in treeView.AllNodes)
        {
            if (node.Tag is SensorNode sensorNode && sensorNode.Plot && sensorNode.PenColor.HasValue)
                colors.Add(sensorNode.Sensor, sensorNode.PenColor.Value);
        }

        _sensorPlotColors = colors;
        _plotPanel.SetSensors(selected, colors, _plotStrokeThickness);
    }

    private void NodeTextBoxText_EditorShowing(object sender, CancelEventArgs e)
    {
        e.Cancel = !(treeView.CurrentNode != null && (treeView.CurrentNode.Tag is SensorNode || treeView.CurrentNode.Tag is HardwareNode));
    }

    private void NodeCheckBox_IsVisibleValueNeeded(object sender, NodeControlValueEventArgs e)
    {
        e.Value = e.Node.Tag is SensorNode && plotMenuItem.Checked;
    }

    private void ExitClick(object sender, EventArgs e)
    {
        CloseApplication();
    }

    private void Timer_Tick(object sender, EventArgs e)
    {
        treeView.Invalidate();
        _systemTray.Redraw();
        _gadget?.Redraw();

        if (!backgroundUpdater.IsBusy)
            backgroundUpdater.RunWorkerAsync();
    }

    private void SaveConfiguration()
    {
        if (_plotPanel == null || _settings == null)
            return;

        _plotPanel.SetCurrentSettings();

        foreach (TreeColumn column in treeView.Columns)
            _settings.SetValue("treeView.Columns." + column.Header + ".Width", column.Width);

        _settings.SetValue("listenerIp", Server.ListenerIp);
        _settings.SetValue("listenerPort", Server.ListenerPort);
        _settings.SetValue("authenticationEnabled", Server.AuthEnabled);
        _settings.SetValue("authenticationUserName", Server.UserName);
        _settings.SetValue("authenticationPassword", Server.Password);

        string fileName = Path.ChangeExtension(Application.ExecutablePath, ".config");

        try
        {
            _settings.Save(fileName);
        }
        catch (UnauthorizedAccessException)
        {
            MessageBox.Show("Access to the path '" +
                            fileName +
                            "' is denied. " +
                            "The current settings could not be saved.",
                            "Error",
                            MessageBoxButtons.OK,
                            MessageBoxIcon.Error);
        }
        catch (IOException)
        {
            MessageBox.Show("The path '" +
                            fileName +
                            "' is not writeable. " +
                            "The current settings could not be saved.",
                            "Error",
                            MessageBoxButtons.OK,
                            MessageBoxIcon.Error);
        }
    }

    private void MainForm_Load(object sender, EventArgs e)
    {
        Rectangle newBounds = new()
        {
            X = _settings.GetValue("mainForm.Location.X", Location.X),
            Y = _settings.GetValue("mainForm.Location.Y", Location.Y),
            Width = _settings.GetValue("mainForm.Width", 470),
            Height = _settings.GetValue("mainForm.Height", 640)
        };

        Rectangle fullWorkingArea = new(int.MaxValue, int.MaxValue, int.MinValue, int.MinValue);

        foreach (Screen screen in Screen.AllScreens)
            fullWorkingArea = Rectangle.Union(fullWorkingArea, screen.Bounds);

        Rectangle intersection = Rectangle.Intersect(fullWorkingArea, newBounds);
        if (intersection.Width < 20 || intersection.Height < 20 || !_settings.Contains("mainForm.Location.X"))
        {
            newBounds.X = (Screen.PrimaryScreen.WorkingArea.Width / 2) - (newBounds.Width / 2);
            newBounds.Y = (Screen.PrimaryScreen.WorkingArea.Height / 2) - (newBounds.Height / 2);
        }

        Bounds = newBounds;

        RestoreCollapsedNodeState(treeView);

        FormClosed += MainForm_FormClosed;
    }

    private void RestoreCollapsedNodeState(TreeViewAdv treeViewAdv)
    {
        var collapsedHwNodes = treeViewAdv.AllNodes
                                          .Where(n => n.IsExpanded && n.Tag is IExpandPersistNode expandPersistNode && !expandPersistNode.Expanded)
                                          .OrderByDescending(n => n.Level)
                                          .ToList();

        foreach (TreeNodeAdv node in collapsedHwNodes)
        {
            node.IsExpanded = false;
        }
    }

    private void CloseApplication()
    {
        FormClosed -= MainForm_FormClosed;

        Visible = false;
        _systemTray.IsMainIconEnabled = false;
        timer.Enabled = false;
        _computer.Close();
        SaveConfiguration();
        if (_runWebServer.Value)
            Server.Quit();

        _systemTray.Dispose();
        timer.Dispose();
        backgroundUpdater.Dispose();

        Application.Exit();
    }

    private void MainForm_FormClosed(object sender, FormClosedEventArgs e)
    {
        CloseApplication();
    }

    private void AboutMenuItem_Click(object sender, EventArgs e)
    {
        _ = new AboutBox().ShowDialog();
    }

    private void TreeView_Click(object sender, EventArgs e)
    {
        if (!(e is MouseEventArgs m) || (m.Button != MouseButtons.Left && m.Button != MouseButtons.Right))
            return;

        NodeControlInfo info = treeView.GetNodeControlInfoAt(new Point(m.X, m.Y));
        if (m.Button == MouseButtons.Left && info.Node != null)
        {
            if (info.Node.Tag is IExpandPersistNode expandPersistNode)
            {
                expandPersistNode.Expanded = info.Node.IsExpanded;
            }
            return;
        }

        treeView.SelectedNode = info.Node;
        if (info.Node != null)
        {
            if (info.Node.Tag is SensorNode node && node.Sensor != null)
            {
                treeContextMenu.Items.Clear();
                if (node.Sensor.Parameters.Count > 0)
                {
                    ToolStripItem item = new ToolStripMenuItem("Parameters...");
                    item.Click += delegate { ShowParameterForm(node.Sensor); };
                    treeContextMenu.Items.Add(item);
                }

                if (nodeTextBoxText.EditEnabled)
                {
                    ToolStripItem item = new ToolStripMenuItem("Rename");
                    item.Click += delegate { nodeTextBoxText.BeginEdit(); };
                    treeContextMenu.Items.Add(item);
                }

                if (node.IsVisible)
                {
                    ToolStripItem item = new ToolStripMenuItem("Hide");
                    item.Click += delegate { node.IsVisible = false; };
                    treeContextMenu.Items.Add(item);
                }
                else
                {
                    ToolStripItem item = new ToolStripMenuItem("Unhide");
                    item.Click += delegate { node.IsVisible = true; };
                    treeContextMenu.Items.Add(item);
                }

                treeContextMenu.Items.Add(new ToolStripSeparator());
                {
                    ToolStripItem item = new ToolStripMenuItem("Pen Color...");
                    item.Click += delegate
                    {
                        ColorDialog dialog = new() { Color = node.PenColor.GetValueOrDefault() };
                        if (dialog.ShowDialog() == DialogResult.OK)
                            node.PenColor = dialog.Color;
                    };

                    treeContextMenu.Items.Add(item);
                }

                {
                    ToolStripItem item = new ToolStripMenuItem("Reset Pen Color");
                    item.Click += delegate { node.PenColor = null; };
                    treeContextMenu.Items.Add(item);
                }

                treeContextMenu.Items.Add(new ToolStripSeparator());
                {
                    ToolStripMenuItem item = new("Show in Tray") { Checked = _systemTray.Contains(node.Sensor) };
                    item.Click += delegate
                    {
                        if (item.Checked)
                            _systemTray.Remove(node.Sensor);
                        else
                            _systemTray.Add(node.Sensor, true);
                    };

                    treeContextMenu.Items.Add(item);
                }

                if (_gadget != null)
                {
                    ToolStripMenuItem item = new("Show in Gadget") { Checked = _gadget.Contains(node.Sensor) };
                    item.Click += delegate
                    {
                        if (item.Checked)
                        {
                            _gadget.Remove(node.Sensor);
                        }
                        else
                        {
                            _gadget.Add(node.Sensor);
                        }
                    };

                    treeContextMenu.Items.Add(item);
                }

                if (node.Sensor.Control != null)
                {
                    treeContextMenu.Items.Add(new ToolStripSeparator());
                    IControl control = node.Sensor.Control;
                    ToolStripMenuItem controlItem = new("Control");
                    ToolStripItem defaultItem = new ToolStripMenuItem("Default") { Checked = control.ControlMode == ControlMode.Default };
                    controlItem.DropDownItems.Add(defaultItem);
                    defaultItem.Click += delegate { control.SetDefault(); };
                    ToolStripMenuItem manualItem = new("Manual");
                    controlItem.DropDownItems.Add(manualItem);
                    manualItem.Checked = control.ControlMode == ControlMode.Software;
                    for (int i = 0; i <= 100; i += 5)
                    {
                        if (i <= control.MaxSoftwareValue &&
                            i >= control.MinSoftwareValue)
                        {
                            ToolStripMenuItem item = new ToolStripRadioButtonMenuItem(i + " %");
                            manualItem.DropDownItems.Add(item);
                            item.Checked = control.ControlMode == ControlMode.Software && Math.Round(control.SoftwareValue) == i;
                            int softwareValue = i;
                            item.Click += delegate { control.SetSoftware(softwareValue); };
                        }
                    }

                    treeContextMenu.Items.Add(controlItem);
                }

                treeContextMenu.Show(treeView, new Point(m.X, m.Y));
            }

            if (info.Node.Tag is HardwareNode hardwareNode && hardwareNode.Hardware != null)
            {
                treeContextMenu.Items.Clear();

                if (nodeTextBoxText.EditEnabled)
                {
                    ToolStripItem item = new ToolStripMenuItem("Rename");
                    item.Click += delegate { nodeTextBoxText.BeginEdit(); };
                    treeContextMenu.Items.Add(item);
                }

                treeContextMenu.Show(treeView, new Point(m.X, m.Y));
            }
        }
    }

    private void SaveReportMenuItem_Click(object sender, EventArgs e)
    {
        string report = _computer.GetReport();
        if (saveFileDialog.ShowDialog() == DialogResult.OK)
        {
            using (TextWriter w = new StreamWriter(saveFileDialog.FileName))
            {
                w.Write(report);
            }
        }
    }

    private void SysTrayHideShow()
    {
        Visible = !Visible;
        if (Visible)
            Activate();
    }

    protected override void WndProc(ref Message m)
    {
        const int WM_SYSCOMMAND = 0x112;
        const int WM_WININICHANGE = 0x001A;
        const int SC_MINIMIZE = 0xF020;
        const int SC_CLOSE = 0xF060;

        if (_minimizeToTray.Value && m.Msg == WM_SYSCOMMAND && m.WParam.ToInt64() == SC_MINIMIZE)
        {
            SysTrayHideShow();
        }
        else if (m.Msg == WM_WININICHANGE && Marshal.PtrToStringUni(m.LParam) == "ImmersiveColorSet" && _autoThemeMenuItem?.Checked == true)
        {
            Theme.SetAutoTheme();
        }
        else if (_minimizeOnClose.Value && m.Msg == WM_SYSCOMMAND && m.WParam.ToInt64() == SC_CLOSE)
        {
            //Apparently the user wants to minimize rather than close
            //Now we still need to check if we're going to the tray or not
            //Note: the correct way to do this would be to send out SC_MINIMIZE,
            //but since the code here is so simple,
            //that would just be a waste of time.
            if (_minimizeToTray.Value)
                SysTrayHideShow();
            else
                WindowState = FormWindowState.Minimized;
        }
        else
        {
            base.WndProc(ref m);
        }
    }

    private void HideShowClick(object sender, EventArgs e)
    {
        SysTrayHideShow();
    }

    private void ShowParameterForm(ISensor sensorForm)
    {
        ParameterForm form = new() { Parameters = sensorForm.Parameters, captionLabel = { Text = sensorForm.Name } };
        form.ShowDialog();
    }

    private void TreeView_NodeMouseDoubleClick(object sender, TreeNodeAdvMouseEventArgs e)
    {
        if (e.Node.Tag is SensorNode node && node.Sensor != null && node.Sensor.Parameters.Count > 0)
            ShowParameterForm(node.Sensor);
    }

    private void CelsiusMenuItem_Click(object sender, EventArgs e)
    {
        celsiusMenuItem.Checked = true;
        fahrenheitMenuItem.Checked = false;
        _unitManager.TemperatureUnit = TemperatureUnit.Celsius;
    }

    private void FahrenheitMenuItem_Click(object sender, EventArgs e)
    {
        celsiusMenuItem.Checked = false;
        fahrenheitMenuItem.Checked = true;
        _unitManager.TemperatureUnit = TemperatureUnit.Fahrenheit;
    }

    private void ResetMinMaxMenuItem_Click(object sender, EventArgs e)
    {
        _computer.Accept(new SensorVisitor(delegate(ISensor sensorClick)
        {
            sensorClick.ResetMin();
            sensorClick.ResetMax();
        }));
    }

    private void ExpandAllNodes_Click(object sender, EventArgs e)
    {
        treeView.ExpandAll();

        foreach (var node in treeView.AllNodes)
        {
            if (node.Tag is IExpandPersistNode expandPersistNode)
            {
                expandPersistNode.Expanded = true;
            }
        }
    }

    private void CollapseAllNodes_Click(object sender, EventArgs e)
    {
        treeView.CollapseAll();

        foreach (var node in treeView.AllNodes)
        {
            if (node.Tag is IExpandPersistNode expandPersistNode)
            {
                expandPersistNode.Expanded = false;
            }
        }
    }

    private void resetPlotMenuItem_Click(object sender, EventArgs e)
    {
        _computer.Accept(new SensorVisitor(delegate (ISensor sensorClick)
        {
            sensorClick.ClearValues();
        }));
    }

    private void MainForm_MoveOrResize(object sender, EventArgs e)
    {
        if (WindowState != FormWindowState.Minimized)
        {
            _settings.SetValue("mainForm.Location.X", Bounds.X);
            _settings.SetValue("mainForm.Location.Y", Bounds.Y);
            _settings.SetValue("mainForm.Width", Bounds.Width);
            _settings.SetValue("mainForm.Height", Bounds.Height);
        }
    }

    private void ResetClick(object sender, EventArgs e)
    {
        // disable the fallback MainIcon during reset, otherwise icon visibility
        // might be lost
        _systemTray.IsMainIconEnabled = false;
        _computer.Reset();
        // restore the MainIcon setting
        _systemTray.IsMainIconEnabled = _minimizeToTray.Value;
    }

    private void TreeView_MouseMove(object sender, MouseEventArgs e)
    {
        _selectionDragging &= (e.Button & (MouseButtons.Left | MouseButtons.Right)) > 0;
        if (_selectionDragging)
            treeView.SelectedNode = treeView.GetNodeAt(e.Location);
    }

    private void TreeView_MouseDown(object sender, MouseEventArgs e)
    {
        _selectionDragging = true;
    }

    private void TreeView_MouseUp(object sender, MouseEventArgs e)
    {
        _selectionDragging = false;
    }

    private void TreeView_SizeChanged(object sender, EventArgs e)
    {
        int newWidth = treeView.Width;
        for (int i = 1; i < treeView.Columns.Count; i++)
        {
            if (treeView.Columns[i].IsVisible)
                newWidth -= treeView.Columns[i].Width;
        }
        treeView.Columns[0].Width = newWidth;
    }

    private void TreeView_KeyDown(object sender, KeyEventArgs e)
    {
        if (treeView.SelectedNode != null)
        {
            switch (e.KeyCode)
            {
                case Keys.Right:
                    if (treeView.SelectedNode.Tag is IExpandPersistNode expandPersistNodeR)
                    {
                        expandPersistNodeR.Expanded = true;
                    }
                    return;
                case Keys.Left:
                    if (treeView.SelectedNode.Tag is IExpandPersistNode expandPersistNodeL)
                    {
                        expandPersistNodeL.Expanded = false;
                    }
                    return;
            }
        }
    }

    private void TreeView_ColumnWidthChanged(TreeColumn column)
    {
        int index = treeView.Columns.IndexOf(column);
        int columnsWidth = 0;
        foreach (TreeColumn treeColumn in treeView.Columns)
        {
            if (treeColumn.IsVisible)
                columnsWidth += treeColumn.Width;
        }

        int nextColumnIndex = index + 1;
        while (nextColumnIndex < treeView.Columns.Count && treeView.Columns[nextColumnIndex].IsVisible == false)
            nextColumnIndex++;

        if (nextColumnIndex < treeView.Columns.Count) {
            int diff = treeView.Width - columnsWidth;
            treeView.Columns[nextColumnIndex].Width = Math.Max(20, treeView.Columns[nextColumnIndex].Width + diff);
        }
    }

    private void ServerInterfacePortMenuItem_Click(object sender, EventArgs e)
    {
        new InterfacePortForm(this).ShowDialog();
    }

    private void AuthWebServerMenuItem_Click(object sender, EventArgs e)
    {
        new AuthForm(this).ShowDialog();
    }

    private void perSessionFileRotationMenuItem_Click(object sender, EventArgs e)
    {
        dailyFileRotationMenuItem.Checked = false;
        perSessionFileRotationMenuItem.Checked = true;
        _logger.FileRotationMethod = LoggerFileRotation.PerSession;
        _settings.SetValue("logger.fileRotation", (int)LoggerFileRotation.PerSession);
    }

    private void dailyFileRotationMenuItem_Click(object sender, EventArgs e)
    {
        dailyFileRotationMenuItem.Checked = true;
        perSessionFileRotationMenuItem.Checked = false;
        _logger.FileRotationMethod = LoggerFileRotation.Daily;
        _settings.SetValue("logger.fileRotation", (int)LoggerFileRotation.Daily);
    }
}

```

`LibreHardwareMonitor/UI/MainForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="treeContextMenu.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
  <metadata name="saveFileDialog.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>164, 17</value>
  </metadata>
  <metadata name="timer.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>293, 17</value>
  </metadata>
  <metadata name="backgroundWorker1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>483, 17</value>
  </metadata>
  <assembly alias="System.Drawing" name="System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
  <data name="$this.Icon" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        AAABAAMAEBAAAAEAIABoBAAANgAAACAgAAABACAAqBAAAJ4EAAAwMAAAAQAgAKglAABGFQAAKAAAABAA
        AAAgAAAAAQAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEU8OykuDgdIIxQSURwdHU8ZGhpPFhYWTxQU
        FE8SEhJPDxAPTw0KCk8KBQRPCAQDTwcDAU8HAQBPBgQEUQUFBTxLVVb/L215/zdXXP89Ozv/ODc3/zM0
        M/8vLy//Kioq/yYlJf8iJif/Gycp/xggI/8UHiD/Eh4g/w4SE/8GBARRQWRr/xGXtP8yUln/NDIx/y4u
        Lf8qKir/KSgo/ycnJ/8lJCP/Iikq/xs4Pf8aOD7/GzpB/xo4Pf8SGhv/BwMDT01aXP46Ulj+Pzc0/kdH
        R/5MTU3+Q0ND/jw8PP43Nzf+Ly8v/igoKP4lKCn+Iico/hwiI/4cHyD/FBMU/wYHBk9XVVX+Rj8+/klJ
        Sf6ioqL+rq+u/p+fn/6YmJj+j4+P/oSEhP56enr+dXJy/mNgYP4iHx7+Gxka/xUVFf8HBwdPW1pa/kVF
        RP5YWFj+rq6u/r6+vv6wsK/+qamp/qCgoP6UlJT+iYmJ/oGBgf5xcXH+JCQk/hsbG/8WFhb/BwcHT15e
        Xv5ISEj+Wlpa/rW1tf7Gxsb+tra2/qysq/6hoaL+lpaW/oyMjP6EhIT+cnJy/iQkJP4cHBz/GBgY/wcH
        B09jY2P+TUxM/l5eXv7AwMD+0dHR/r6+vv6vr6/+o6Ok/pmYmf6Rk5P+iouK/nd4d/4lJSX+HR0d/xkZ
        Gf8HBwdPZ2dn/lBQUP5iYmL+ysrK/tzc3P7Hxsf+tbS1/qmpqf6fn5/+mJiY/o6Pj/57e3z+JSUm/h4e
        Hv8aGhr/CAgIT2tra/5TU1P+ZGRk/tLS0v7j5eP+zMzM/ry8vP6wsLD+pqam/pubm/6TkZH+f39//igo
        KP4fHx7/HBwc/wkJCk9ubm7+VlVW/mZlZv7X1tf+6Ojo/tPS0/7Hx8f+urq6/qurq/6dnp7+lJSU/oGB
        gP4sLCz+Hx4e/x4dHP8LCwtPb29v/lZWVv5nZ2j+4eHh/vLx8v7Z2dn+zc3N/sDAwP6wsrL+pKOk/pmZ
        mf6Ghob+MDAw/h8gH/8eHx//DQsNT29vb/5YWFj+WVpa/sHBwf7V1dX+wMC//rW1tP6pqan+m5ub/o6P
        jv6FhYX+cXFx/i4qKv4gLC7/Hiot/w4JB09vb3D+Wlla/lJSUf5VVVX+YGBg/ltbWv5VVVP+Tk5O/kdH
        R/5BQUH+Ozs6/jAvL/4oKCj+Izk9/x8tL/8QCQhRbm5u/lVVVf5SUlL+S0tL/kRERP5BQUH+PT09/jk5
        Of41NTX+MzIy/i8vLv4sKSj+Jy4v/h9DTP8iLjH/Ew0KSHp7ev5qamr+ZWVl/mFhYv5cXFz+WFhY/lNS
        U/5NTU3+R0ZH/kJCQv49PDz+NzU1/jAxMf4qMTL/Jigp/x4cHCn//wAAAAEAAAABAAAAAQAAAAEAAAAB
        AAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAKAAAACAAAABAAAAAAQAgAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAwMBBwcHAwYGBgQGBgYEBgYGBAYG
        BgQGBgYEBgYGBAYGBgQGBgYEBgYGBAYGBgQGBgYEBgYGBAYGBgQGBgYEBgYGBAYGBgQGBgYEBgYGBAYG
        BgQGBgYEBgYGBAYGBgQGBgYEBwcHAwUFBQIAAAAAAAAAAAAAAAAAAAAAAAAAAAoKCgkMDAwgDQ0NKg0N
        DSoNDQ0qDQ0NKg0NDSoNDQ0qDQ0NKg0NDSoNDQ0qDQ0NKg0NDSoNDQ0qDQ0NKg0NDSoNDQ0qDQ0NKg0N
        DSoNDQ0qDQ0NKg0NDSoNDQ0qDQ0NKg0NDSoMDAwlCgoKEQUFBQIAAAAAAAAAAAAAAAAAAAAACAgIFAoK
        CkcMDAxbDAwMXAwMDFwMDAxcDAwMXAwNDFwNDQ1cDQ0NXA0NDVwNDQ1cDQ0NXA0NDVwNDQ5cDg4OXA4O
        DlwODg5cDg4OXA4ODlwODg5cDg4OXA4ODlwODg5cDg4OWw0NDVIMDAwlBwcHAwAAAAAAAAAAAAAAAGFh
        YY9ZWFjFUVBP0kpJSdhIR0fYQkJC2D0+Ptg5OTnZODc22TMyM9kuLi/ZKysr2SYmJtkjIyPZICAf2Rsb
        G9kXFxjZExMT2Q8ODtkNDAzZDQwM2A0MDNgNDAzYDQ0N2A0NDdgODQ27Dg4OWw0NDSoGBgYEAAAAAAAA
        AAAAAAAAYmFhvzxCQ/82Uln/NlJZ/zdPVP89PDz/PDw8/zo6Ov85OTn/ODg4/zY2Nv80NDT/NDQ0/zIy
        Mv8xMTD/Ly4w/yw1OP8qNjj/JzQ1/yYyNP8kMDL/Ii4w/x8sLv8fKy3/HyIi/w0NDdgODg5cDQ0NKgYG
        BgQAAAAAAAAAAAAAAABjY2K/OFRa/xqXsv8bk6v/M11l/z49Pf89PT3/Ozs7/zo6Of83Nzj/NTY1/zQ0
        NP8zMzP/MTEw/y8vL/8uLi7/KzQ2/yk1Nv8nMjT/JjAz/yQvMf8jLjD/ISwu/x8rLf8fISL/DQ0N2A4O
        DlwNDQ0qBgYGBAAAAAAAAAAAAAAAAGZkZL86V13/GpKs/zJkbv9BPz//Pj8+/zw8PP85OTn/Njc2/zQ0
        Nf8zMjP/MjIy/zAwMP8vLy//Li4u/y0sLP8qKSn/I0hQ/yJHUP8hRk//IEZO/yBGTv8fRU3/HztB/yAf
        H/8NDQ3YDg4OXA0NDSoGBgYEAAAAAAAAAAAAAAAAaWdovz5WW/83YWr/RkND/0FAQP89PT3/ODc3/zIy
        Mf8uLi7/LCws/ysrK/8pKSn/Kioq/ygoKP8nJyf/JSUl/yUkJP8kIyP/IyEh/yMiIv8kIiL/JCMj/yQj
        I/8iISH/ISAg/w0NDdgODg5cDQ0NKgYGBgQAAAAAAAAAAAAAAABqamq/SUhI/0hHR/9GRkb/QUFB/0ZH
        Rv9/f4D/gICA/3h4eP9xcXH/a2tr/2RkZP9dXV7/V1dX/09PT/9ISEj/Q0NC/0BAQP9AQED/Ozs7/yYm
        Jv8jIyP/JCQk/yMjI/8jIyH/DQ0N2A4ODlwNDQ0qBgYGBAAAAAAAAAAAAAAAAG5ubr9LS0v/SkpL/0hI
        SP9BQUH/i4uL/6ysrP+hoqH/n5+e/52bnf+YmJj/lJSU/5CQj/+Li4v/hYaF/4CAgP97e3r/dXR1/3Fx
        cf9ra2v/Ozs7/yEhIv8kJCT/JCQk/yQkI/8NDQ3YDg4OXA0NDSoGBgYEAAAAAAAAAAAAAAAAcHBwv01N
        Tf9MTU3/SUpK/0BAP/+Wlpj/q6ur/6inp/+kpKT/oKGg/52cnP+YmJj/k5OT/46Ojv+IiYj/g4OC/319
        ff93d3f/cXFx/3Fxcf8/Pz//ISEh/yQkJP8lJSX/JSQk/w0NDdkODg5cDQ0NKgYGBgQAAAAAAAAAAAAA
        AABycnO/T05P/05PT/9MTEz/QUFB/5ubmv+ysrL/rq6u/6urq/+np6f/oqKi/52dnf+ZmZn/k5OT/42O
        jv+IiIf/gYGB/3x7fP90dXT/cXFx/z8/P/8hISH/JCQl/yUlJf8lJib/DQ0N2Q4ODlwNDQ0qBgYGBAAA
        AAAAAAAAAAAAAHR1db9RUVH/UFBQ/01NTf9CQkL/np6e/7i4uP+0s7T/sbGx/62trf+oqKj/o6Oj/52d
        nf+Yl5f/kZKR/4yMi/+FhYX/fn9//3h4eP9zc3P/Pz8//yIiIv8lJSX/JiYm/yYmJv8NDQ3ZDg4OXA0N
        DSoGBgYEAAAAAAAAAAAAAAAAdnZ2v1RUVP9TU1P/T09P/0VFRf+kpKT/v7+//7u7u/+2trb/sbGx/6mp
        qf+jo6P/nZ2d/5eXl/+QkZH/jo2N/4mJif+CgoL/fHx8/3d3d/9AQED/IiIi/yYmJv8nJyf/Jycn/w0N
        DdkODg5cDQ0NKgYGBgQAAAAAAAAAAAAAAAB4eHi/V1dW/1VVVf9QUFD/RkZG/6moqf/Gxsb/wcHB/7y8
        vP+2trb/q6ys/6Wlpf+fn5//mZiY/5WUlf+RkpL/jI2M/4WFhf9/fn//enp6/0FBQf8iIiP/JiYm/ygn
        KP8oJyf/DQ0N2Q4ODlwNDQ0qBgYGBAAAAAAAAAAAAAAAAHp6er9YWVn/V1dX/1JSU/9ISEj/ra2t/8zM
        zP/Gxsb/wcHB/7u7u/+wsLD/qamp/6Ojo/+cnZ3/lpaW/5OTk/+Pj47/iIiI/4CBgP98fH3/QkJC/yMj
        I/8nJyf/KCgo/ygoKP8ODg7ZDg4OXA0NDSoGBgYEAAAAAAAAAAAAAAAAfXx9v1tbW/9ZWVn/VFVV/0hJ
        Sf+xsbH/0tLS/8vLy//FxcX/v7++/7Ozs/+qqqr/pKWk/6Cfn/+ampr/mpia/5GRkf+Li4r/goOD/35+
        fv9CQ0P/IyQk/ycnJ/8pKSn/KSkp/xAQENkODg5cDQ0NKgYGBgQAAAAAAAAAAAAAAAB+fn6/XV1d/1tb
        W/9WVlb/S0lJ/7Oysv/W1tb/z8/P/8nJyf/CwsL/tbW1/66trf+np6f/oqKi/5ycnP+ZmJn/k5OT/4yM
        jP+FhYX/f39//0ZFRv8kJCT/KCgo/ykpKf8pKSn/EhIS2Q4ODlwNDQ0qBgYGBAAAAAAAAAAAAAAAAIGB
        gb9eXl7/XFxc/1dYV/9KSkr/tLS0/9rb2v/S0tL/zczM/8XFxf+/v7//uLi4/7Gxsf+rq6r/o6Oj/5yc
        nP+UlZT/jY2N/4aFhv+AgID/SUlI/yMjI/8oKCj/KSkp/ykpKf8UFBTZDg4OXA0NDSoGBgYEAAAAAAAA
        AAAAAAAAg4ODv19fX/9eXl7/WVhZ/0tLS/+0tLT/3d3d/9TU1P/Ozs7/x8bH/8DAwP+5ubn/srKy/6ur
        q/+kpKT/nJyc/5WVlv+Ojo7/h4eH/4GBgf9NTU3/IyQk/ygpKP8qKSn/KSkp/xgYGNkODg5cDQ0NKgYG
        BgQAAAAAAAAAAAAAAACFhYW/YGBf/15eXv9aWln/TU1N/7a2tv/e3t7/1dXV/87Pz//Hx8f/wcHB/7m5
        uv+ysrP/rKyr/6SkpP+dnZ3/lZWW/46Ojv+Hh4f/gYGB/1BQUP8kJCT/KSkp/ykpKf8oKCj/GhkZ2Q4O
        DlwNDQ0qBgYGBAAAAAAAAAAAAAAAAIiGhr9gYGD/Xl5e/1paWv9PT0//t7e3/93d3f/U1NT/zs7O/8fH
        x//AwMD/ubm5/7Kysv+rq6v/o6Ok/5ycnP+VlZX/jo6N/4aGhv+BgYH/U1NT/yYmJv8qKir/Kisq/ygo
        Kf8bHBzYDg4OXA0NDSoGBgYEAAAAAAAAAAAAAAAAioqKv19fX/9eXl7/Wlta/1FRUf+srKz/4uLi/9LS
        0v/Mzcz/xcXG/7+/v/+4ubj/srKx/6urq/+kpKT/nZ2d/5WVlf+Njo7/h4aH/4GBgf9TUlL/KSkp/yws
        LP8qLzH/Jy4v/x4eHtgNDQ1cDQ0NKgYGBgQAAAAAAAAAAAAAAACMi4y/Xl5e/11dXf9aWlr/VVVV/1xc
        XP+qqqr/sbGx/66urv+qqqr/pKSj/52dnf+VlZX/jo6O/4eHh/+Af3//d3l3/3BwcP9paWn/XFxc/zMz
        M/8sLCz/LS0t/yswMf8nLS7/ICAg2A0NDVwNDQ0qBgYGBAAAAAAAAAAAAAAAAI6Ojr9cXFz/XFxc/1pa
        Wv9WV1f/UFFQ/0xMS/9HR0f/RERE/0BBQP8+Pj7/PDw8/zo7Ov84ODj/ODg4/zU1Nf8zMzP/MTEx/zAw
        MP8uLi//Li4u/y4tL/8qPUD/KDk+/yU4O/8jIiLYDQ0NXA0NDSoGBgYEAAAAAAAAAAAAAAAAkZGRv1pb
        W/9bW1r/WFlY/1ZWVv9UVFT/UFBQ/05OTv9MTEz/SklK/0dHR/9FRUX/QkJC/0BAQP8+Pj7/PDw8/zo6
        Ov83ODf/NTU1/zIyMv8xMTH/Ly4u/yk7P/8oO0D/JTpA/yUkJNgNDQ1bDQ0NKgcHBwQAAAAAAAAAAAAA
        AACTk5O/WFhY/1lZWf9YV1j/VVVV/1JSUv9QUFD/Tk5O/01MTf9KSkr/SEhI/0ZGRv9DQkP/QEFA/z8/
        P/89PT3/Ozs6/zg4OP82NTX/MzMz/zExMf8vLi3/IVtn/yovMf8nLi//KCgo0gwMDEcMDAwgBwcHAwAA
        AAAAAAAAAAAAAJKTkr9VVFX/VFVV/1RUVP9SUVH/T09P/01NTv9MS0z/SkpK/0hJSP9HR0f/REVE/0FB
        Qf8/Pz//Pj4+/zs7PP85Ojn/Nzc3/zQ0NP8xMTH/LzAw/y4uLv8tLCz/KS8w/yUtLv8tLS3FCgoKFAoK
        CgkDAwMBAAAAAAAAAAAAAAAAl5aXj5KSkr+QkJC/jYuLv4eHh7+EhIS/gICAv3x8fL93d3e/dHR0v3Bw
        cL9samy/ZmZmv2NjY79fX1+/W1tbv1VVVb9SUlK/Tk5Ov0pKSr9ERES/QUFBvz09Pb85OTm/MzMzvzEx
        MY8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD////////////////gAAAH4AAAB+AA
        AAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AA
        AAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB////////////////ygAAAAwAAAAYAAAAAEA
        IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAA
        AAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAA
        AAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAACCAgIBwkJCQwICAgOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcH
        Bw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcH
        Bw4HBwcOBwcHDgcHBw4HBwcOBwcHDgcHBw4HBwcOCAgIDgkJCQwICAgHAAAAAgAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAICAgHCwsLGQ0NDSwNDQ0yDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0N
        DTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0N
        DTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMw0NDTMNDQ0zDQ0NMg0NDSwLCwsaCAgIBwAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJCQkMDQ0NLA0NDUwODg5XDg4OWQ4ODlkODg5ZDg4OWQ4O
        DlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4O
        DlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OWQ4ODlkODg5ZDg4OVw0N
        DUwNDQ0sCQkJDAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEFBQUOCgoKMgsLC1cLCwtkCwsLZgsL
        C2YLCwtmCwsLZgwMDGYMDAxmDAwMZgwMDGYMDAxmDAwMZgwMDGYMDAxmDAwMZg0NDWYNDQ1mDQ0NZg0N
        DWYNDQ1mDQ0NZg0NDWYNDQ1mDg4OZg4ODmYODg5mDg4OZg4ODmYODg5mDg4OZg4ODmYODg5mDg4OZg4O
        DmYODg5mDg4OZA4ODlcNDQ0yCAgIDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAGJiYv9cXFz/Wlpa/1VV
        V/9TU1L/UVFR/05OTv9LSkv/R0dH/0NDQ/9BQUH/Pz4//zw8PP86OTn/NTU1/zIyMv8wMDD/LS0u/yoq
        Kv8mJib/JCMk/yEhIf8eHh7/Gxsc/xkZGf8UFBT/ERER/w8PD/8ODg7/Dg4O/w4ODv8ODg7/Dg4O/w4O
        Dv8ODg7/Dg4O/w4ODv8PDw//Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAGJi
        Yf8+PDz/Pzw7/0A7Ov9AOzr/Pzo5/z06Ov89Ojr/Ozs7/zo7Ov87Ojv/Ojo6/zk5Of84ODj/Nzc3/zY2
        Nf81NTT/MzMz/zIyMv8xMTH/MTIx/zAwMP8wMDD/Ly4u/y4tLf8sKiv/Kigo/yknJ/8oJiX/JiQk/yUj
        I/8kIiH/IiEg/yAeHv8gHh3/IB0d/x8eHv8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAGNjY/9BPj3/Gpiz/xuWsP8alrD/Gpey/yKClv8+PT3/PT09/zw8PP87Ozv/Ojo6/zk5
        Of84ODj/Nzc3/zY2Nv80NDT/MzMz/zMyMv8yMTH/MDEw/y8vL/8vLy//Li4t/yJWYf8hVF//IVRf/x9T
        Xf8gU13/H1Nc/x9RXP8eUFv/HlFb/x1QWv8cT1n/HFBb/x8eHv8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAGRkZP9CPTz/GpWv/xySq/8blK3/JH+S/0A8O/8/Pj7/Pj0+/z08
        PP87Ozv/Ojo6/zk5Of84ODj/Njc3/zU1Nf80NDT/MzMz/zIyMv8xMTH/MDAv/y8vL/8uLi7/LS0s/ywq
        Kv8tKSj/KiYm/yklJf8nJCP/KCIi/yYiIf8lICD/JB8e/yMeHP8iHRz/Hx0d/x8eH/8ODg7/Dg4OZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAGVlZf9GQUD/Gpaw/xuUrf8kgJP/Qj49/0A/
        P/8/Pj//Pj4+/zw8PP86Ojr/OTk5/zc3N/82NTb/NDQ0/zMzM/8yMjL/MTEx/zAwMP8vLzD/Ly8v/y4u
        Lv8tLS3/LCws/ysrKv8gVV//H1Nd/x9UXf8gU13/H1Nc/x9RXP8fUVz/HlFb/x5QW/8dUFv/Hx4f/x8f
        IP8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAGZmZv9GQkL/GZex/yWB
        k/9GQUH/QkFB/0FBQP8/Pz//PT09/zo7Ov84ODj/NTY1/zMzM/8yMjL/MTEx/zAwMP8vLy//Ly8v/y4u
        Lv8uLi7/LS0t/ysrK/8qKiv/KSkp/ygnJ/8nJib/JiQk/yYjJP8lIyP/JSIj/yUjI/8kIiL/JCIi/yMh
        Iv8iISD/IR8g/x8fH/8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAGho
        aP9IRUX/JIOY/0dDQv9HRUX/Q0ND/0FBQP8/Pz7/Ozo7/zY2Nv8xMTH/Li4u/ywsLf8tLS3/LCws/ysr
        K/8pKin/KSkp/ygoKP8oKCj/Jycn/ycmJv8lJSX/JSQl/yQkJP8jJCP/IyIj/yIiIv8iIyL/IyMj/yQj
        JP8kJCT/IyMk/yMjI/8jIyP/IiIh/yAgIP8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAGlqav9IR0f/SUdH/0lHR/9HR0b/RERF/0FBQf88PDz/Pj8//317ff91dXX/cHBw/2tr
        a/9lZGX/YF9f/1paWv9VVVb/UVFR/0xMTP9HR0f/QUFB/z48PP83ODf/MzMz/zAwMP8wMDD/Ly8w/zAw
        MP8xMDH/Jycn/yEhIv8jIyP/JCQk/yQkJP8jIyT/IyIi/yEhIf8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAG1ra/9KSkr/SkpK/0lJSf9ISEj/RkVF/0BAQP9CQkL/ycnJ/6ur
        q/+fn57/np6e/5ycnP+ampr/l5eX/5SUlP+SkpH/j4+P/4yMjP+Iior/hoeG/4ODg/+AgID/fHx8/3h4
        eP90dHP/cXFx/3Jycv9lZWX/Tk9O/ycnJ/8iIiL/IyQj/yQkJP8jIyP/IyMj/yMhI/8ODg7/Dg4OZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAG5ubf9LS0z/S0xL/0tLS/9JSUn/RkZG/0A/
        P/+Mi4z/s7Oz/6Ojo/+ioqL/oKCg/56env+cnJz/mZqZ/5eWl/+UlJT/kJGR/46Ojv+Li4v/h4eH/4OD
        g/+Af4D/fHx8/3h4eP91dHT/cHBw/29vb/9wcHD/ZWVl/zAwMP8iIiL/IyMj/yQkJP8kJCT/JCMk/yMk
        I/8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHBwb/9NTU3/TU1N/0xM
        TP9KSkr/R0dH/z8+P/+Ojo7/q6ur/6mpqf+np6b/paSk/6Kiov+goKD/nZ6e/5ubm/+YmJj/lZSU/5GR
        kf+Ojo7/ioqL/4eHh/+Dg4P/f39//3x8fP93d3f/c3Nz/29vb/9vb2//cnJy/y8vL/8gISD/IyMj/yUk
        JP8kJCT/JCQk/yQkJP8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHFx
        cf9OTk7/Tk5P/01NTf9MTEz/SEhI/0BAQP+QkJD/sLCv/62trf+srKv/qamp/6enp/+kpKX/oaKh/5+f
        n/+cnJz/mJiY/5WVlf+RkZL/jo6O/4qKiv+Ghob/goKC/35+fv96env/dnZ2/3Fycf9vb2//cnJy/y8u
        Lv8hICH/IyMj/yQkJf8lJSX/JCQl/yUlJP8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAHNzc/9PT0//T09P/09PT/9NTUz/SUlJ/0FAQf+SkpL/tbS0/7Gxsf+vr7D/rq6u/6ur
        q/+pqan/pqWl/6Kiov+fn5//nJyc/5iZmP+UlZX/kZGR/42Njf+JiYn/hYWF/4GBgf99fX3/eXl5/3R0
        dP9wcHD/cnJy/y4uLv8hISD/JCQk/yUlJf8mJSb/JiUl/yUlJf8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAHR0dP9RUVH/UVBR/09PT/9OTk7/S0pK/0JCQv+VlZX/uLi4/7a1
        tf+zs7P/sbGx/6+vr/+tra3/qaqq/6ampv+ioqP/n5+f/5ycnP+YmJj/lJSU/5CQj/+MjIz/iIiI/4OD
        g/9/f3//e3t7/3d3dv9ycnL/cnJy/y4vL/8hISH/JCQk/yYmJf8mJib/JiYl/yYlJf8ODg7/Dg4OZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHV1df9TU1T/U1NT/1BRUf9PTk7/TExM/0JC
        Qv+Xl5f/vr6+/7q6uv+3uLf/tbW1/7Kysv+wsLD/rq2t/6uqrP+mp6b/oqKi/5+fn/+bm5v/l5aX/5KS
        kv+Oj47/i4qK/4aGhv+BgoH/fX5+/3l5ef90dHT/c3Nz/y8vL/8jISP/JCQk/yYmJv8nJif/JiYm/yYm
        Jv8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHZ3dv9VVVX/VVVV/1NS
        Uv9QUFD/TU1N/0RERP+ampr/wsLC/76/v/+8vLz/ubm6/7a2t/+zs7P/ra2t/6ampv+io6P/np6f/5ub
        mv+Wl5f/k5OS/46Ojv+Njo3/jY2N/4mJiP+Eg4P/f39//3t7e/92d3b/dXV0/y8vL/8hISH/JCUl/yYm
        Jv8nJyf/JyYm/yYnJv8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHh3
        eP9WVlb/VlZW/1RUVP9RUVH/Tk5O/0VERP+cnJz/xsbG/8LCw//AwMD/vb69/7q7uv+3t7f/sLCw/6mp
        qf+mpqb/oqGi/52dnf+ZmZn/lZWV/5SUlP+Tk5P/j4+P/4uLi/+Ghob/gYGB/319ff94eHj/dnd2/y8v
        L/8hIiP/JSUl/ycnJv8oJyj/KCcn/ycnJ/8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAHl5ef9YWFj/V1dX/1ZWVv9SU1P/T09P/0ZGRv+fn5//ysvK/8bGxv/DxMT/wcHB/729
        vv+6urr/s7Oz/6ysrP+oqKj/pKWk/6CgoP+bm5v/l5eX/5OTk/+SkpL/kJGQ/42Njf+IiIj/g4OD/35/
        f/96env/eHh4/zAwL/8iIiL/JiYl/ycnJ/8oKCj/Jycn/ygnJ/8ODg7/Dg4OZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAHp7e/9ZWVr/WVlZ/1dXV/9UVFX/T1BP/0ZGRv+ioaL/z8/P/8rL
        yv/HyMf/xMTE/8HBwf++vb7/tra2/6+vr/+qq6v/p6en/6Kiov+enp7/mZmZ/5WVlf+UlJT/k5KS/46O
        jv+Kior/hYWF/4CAgP98fHz/eHl6/zAwMP8jIiP/JiYm/ygnKP8oKCr/KCgo/ycoKP8PDw//Dg4OZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAHx8fP9bW1r/Wlpa/1hYWP9VVlb/UFBQ/0dH
        R/+kpKT/0tLS/87Ozv/Ly8v/x8fH/8PExP/AwMD/ubm5/7Kysf+tra3/qaio/6Wlpf+goKD/m5ub/5eW
        l/+ZmZr/lJSU/5CQj/+Li4v/hoaG/4GBgf99fX3/e3t7/zAwMP8jIyP/JiYm/ygoJ/8pKSj/KSgo/ygo
        KP8QEBD/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAH5+ff9cXFz/XFtc/1pZ
        Wf9XV1b/UVFR/0hISP+lpaX/1tbW/9HR0f/Ozs7/y8rK/8bGxv/DwsL/uLi3/6ysrP+nqaf/o6Oi/56e
        nv+ioqL/paWl/5+fn/+bmpv/lZaW/5GRkP+NjYz/iIiH/4KCgv9+fn7/fHx8/zEyMv8jIyP/Jicn/ygo
        KP8pKSn/KCgp/ygpKP8RERH/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAH9/
        f/9dXV3/XV1d/1paW/9YWFf/UlJS/0lJSf+kpKT/2tra/9TU1P/Q0ND/zc3N/8jJyf/ExMT/vb29/7W1
        tv+xsbH/rKys/6ioqP+ioqT/nZ2e/5iYmP+YmJj/l5eX/5KSkv+Ojo3/iImI/4ODg/9/f3//fX19/zQ0
        NP8jIyP/Jycn/ygoKP8pKSn/KSkp/ygoKP8TExP/Dg4OZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAICAgP9eXl7/Xl5e/1xcXP9ZWVn/U1NT/0lJSf+kpKT/3d3d/9fX1v/S0tL/z8/P/8vL
        y//Gxsb/wsLC/72+vv+4uLn/tLS0/7CwsP+srKz/p6em/6Ghof+dnZ3/mJiY/5KTk/+Ojo7/iYmJ/4SE
        hP9/gID/fn5+/zY2Nv8kIyT/Jycn/ygoKP8pKSn/KSkp/ykpKf8WFhb/DQ0NZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAIKCgv9fX17/Xl5e/11cXf9ZWln/VFRU/0pJSv+lpaX/4eHg/9na
        2v/V1dT/0NDQ/83Mzf/Hx8f/w8PD/7++vv+6urr/tbW1/7CwsP+sra3/p6en/6Kiov+enZ3/mZmY/5SU
        k/+Pj4//ioqK/4WFhf+AgID/fX19/zk5Of8jIyT/Jycn/ygoKf8pKSn/KSkp/ykpJ/8YFxj/DQ0NZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAIOEhP9gYGD/X19f/15dXf9aWlr/VVVV/0tK
        S/+lpaX/4eLi/9vb2//W1tX/0dHR/83Nzf/IyMj/w8PE/7+/v/+6u7r/tbW1/7Gxsf+tra3/qKio/6Kj
        o/+enp7/mZmZ/5SUlP+Pj4//i4qK/4WFhf+AgID/fn59/zw8PP8kJCT/Jycn/ykpKf8qKin/KSkp/ygn
        KP8ZGRr/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAISEhP9gYGD/X19f/15e
        Xv9aWlv/VlZW/0tLS/+lpaX/4uLi/9zc3P/W19b/0dLR/83Ozv/JyMn/xMTE/7/AwP+7urv/trW2/7Gx
        sf+tra3/qKin/6Ojov+enp7/mZmZ/5SUlP+Pj5D/i4qK/4aFhf+AgID/fn5+/z9AQP8lJSX/KCgn/ykp
        Kf8qKin/KSkp/ygoKP8bGxv/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAIWH
        h/9gYGD/X19f/15eXv9aWlv/VlZX/0xMTP+mpqb/4eLh/9vb2//W1tb/0dHR/83Nzf/IyMn/xMTE/7+/
        v/+7u7v/tba1/7Gxsf+tra3/qKio/6Ojo/+enp7/mZmZ/5SUlP+Pj4//ioqK/4WFhf+AgID/fX59/0JC
        Qv8mJib/KCgo/ykpKf8qKir/KSkp/ygoKP8cHBz/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAIiIiP9gYGD/X19f/15eXv9bW1v/WFdX/05OTf+np6f/4eHh/9rZ2v/V1dX/0NDQ/83N
        zf/IyMf/w8PD/76/v/+6urr/tbW1/7CxsP+sra3/p6in/6Kiov+enp7/mZmZ/5OUlP+Pj4//ioqK/4WE
        hf+AgID/fn19/0ZGRv8mJyb/Kikq/yorKv8qKyr/KSkp/ygoKP8dHh7/DQ0NZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAImJif9gYGD/X19f/15eXv9bW1v/WFhY/1BQUP+pqan/6Ojo/9bW
        1v/S09P/z8/P/8vLy//Gxsb/wsLC/76+vv+5ubn/tLS0/7CwsP+srKv/p6em/6Giov+dnZ3/mJiY/5OT
        k/+Oj47/iYmJ/4SEhP9/f4D/e3t7/0pKS/8oKCj/Kysr/ywsLP8rKir/Kikq/yknJ/8fHx//DQ0NZg4O
        DlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAIuLi/9fX17/Xl5f/11dXf9bW1v/WVhY/1RU
        VP9XV1j//////+Pj4//T09P/z8/P/8rKyv/Fx8f/wcHC/7++v/+5ubn/tbW1/7CwsP+sraz/pqao/6Ki
        ov+enZ7/mZmZ/5STlP+QkJD/i4uL/4aGhv+BgYH/fHx8/zEwL/8rKiz/LCws/y0sLP8rKir/F4GW/ygm
        J/8iIiL/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAIyMjP9eXV3/Xl5e/11c
        XP9bW1v/WFlZ/1ZWVf9OTk7/VldW/6enp/+lpaX/pKSk/6Kiov+goKD/nJyc/5iYmP+Tk5P/jo+P/4mJ
        if+FhIX/gICA/3t7fP92dnb/cXJx/21tbf9nZmb/YmJi/11dXf9aWlr/MzMz/ywtLP8uLi3/LS0t/y0t
        Lf8sKin/KScm/ycmJP8kJCT/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAI6O
        jv9cXlz/Xl5e/1tbXP9aWlr/WFhY/1ZWV/9SU1P/Tk9P/0tLSv9HR0f/RERE/0JCQv9AQED/Pj8//zw8
        Pf87Ozv/Ozs8/zo6Ov85OTn/ODg4/zY2Nv81NDX/NDM0/zMzM/8xMTH/MDAw/y8vL/8vLy//Li4u/y8v
        L/8uLy7/Li0t/y0tLP8rKij/F4GW/ygmJ/8mJib/DQ0NZg4ODlkNDQ0zBwcHDgAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAJCPkP9dW1v/XV1c/1tbW/9ZWVn/WFhY/1ZWVv9TVFP/UlJR/09PT/9OTk3/S0xL/0pK
        Sv9ISEj/R0ZH/0VERf9CQkP/QUFC/0BAQP8/Pz//Pj4+/z09Pf87Ozv/OTk6/zg4OP82Njf/NTU1/zMz
        M/8yMjL/MTEx/y8wL/8vLy//Ly0t/xeAlf8sKCf/KScm/ykmJf8nJyf/DQ0NZg4ODlkNDQ0zBwcHDgAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAJKSkv9aWlr/W1tb/1paWv9ZWVj/V1dX/1ZVVv9UVFT/UlJR/1BP
        UP9OTk7/TU1N/0xMTP9KSkr/SElI/0dHR/9GRkb/RERE/0JCQv9AQED/Pz8//z4+Pv89PT3/Ozs7/zk5
        Of84ODj/Nzc2/zQ0NP8zMzP/MjIy/zAwMP8vLy//Lyws/y4qK/8tKCf/GI6q/ygnJv8pKCn/DQ0NZA4O
        DlcNDQ0yCAgIDgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAJOTk/9ZWFj/Wlpa/1lZWf9YWFj/V1dW/1VV
        VP9TU1P/UVFR/1BPUP9PT0//TU5O/0xMTP9LSkv/SUlJ/0hISP9GRkb/RERE/0NCQv9BQUH/QD8//z4/
        Pv89PT7/Ozw8/zo6Ov85OTn/Nzg3/zU1NP8zMzP/MTIy/zAwMP8vLy//Li0t/xeAlf8tJyj/KyYm/ygk
        Jf8rKyv/DQ0NVw0NDUwNDQ0sCQkJDAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAJOTk/9XV1f/WVhY/1hY
        V/9XV1f/VlZW/1VVVf9SUlL/UFFR/09PT/9OTk7/TU1N/0xMTP9LSkr/SUlJ/0dHR/9GRkb/REVE/0JC
        Qv9BQUD/Pz8//z8/Pv89PT3/Ozw8/zo6Ov84ODj/Nzc2/zQ0Nf8zMzP/MTIy/zAwL/8vLy//Li0t/y0s
        LP8rKSj/GI6q/yclJf8tLS3/DAwMMg0NDSwLCwsaCAgIBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJKS
        kv9UVVX/VVVV/1RVVf9TU1P/UlJS/1FRUf9PT0//Tk5O/01NTf9MTEz/SktL/0tJSf9JSUn/SEhI/0ZG
        R/9FRUX/Q0ND/0FBQf9APz//Pj4+/z0+Pf88PDz/Ojo6/zk5Of84ODj/NjY2/zM0M/8yMjH/MDAw/y8v
        L/8uLi7/LS0t/y0tLf8rKSn/KSYm/yclJP8vLy//BwcHDgkJCQwICAgHAAAAAgAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAJaVlf+TkpL/kpKS/4+Qj/+NjY3/iYmJ/4eHhv+FhYX/goKD/3+Af/99fHz/enl5/3Z2
        dv90dHT/cnJy/3Bwb/9ra2v/aGho/2VmZf9jZGP/YWFh/15eX/9cXFz/WFhY/1VUVf9TUlL/UFBQ/01N
        Tf9LS0v/SEhI/0NEQ/9BQUH/Pz8//zw9PP85OTn/NjY2/zIyMv8xMTH/AAAAAQAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAD///////8AAP///////wAA////////AAD///////8AAP///////wAA+AAAAAAfAAD4AAAAAB8AAPgA
        AAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAf
        AAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgA
        AAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAf
        AAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgA
        AAAAHwAA+AAAAAAfAAD4AAAAAB8AAPgAAAAAHwAA+AAAAAAfAAD4AAAAAB8AAP///////wAA////////
        AAD///////8AAP///////wAA////////AAA=
</value>
  </data>
</root>
```

`LibreHardwareMonitor/UI/Node.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.ObjectModel;
using System.Drawing;

namespace LibreHardwareMonitor.UI;

public class Node
{
    private Node _parent;
    private readonly NodeCollection _nodes;
    private string _text;
    private bool _visible;

    public delegate void NodeEventHandler(Node node);
    public event NodeEventHandler IsVisibleChanged;
    public event NodeEventHandler NodeAdded;
    public event NodeEventHandler NodeRemoved;

    private TreeModel RootTreeModel()
    {
        Node node = this;
        while (node != null)
        {
            if (node.Model != null)
                return node.Model;
            node = node._parent;
        }
        return null;
    }

    public Node() : this(string.Empty) { }

    public Node(string text)
    {
        _text = text;
        _nodes = new NodeCollection(this);
        _visible = true;
    }

    public TreeModel Model { get; set; }

    public Node Parent
    {
        get { return _parent; }
        set
        {
            if (value != _parent)
            {
                _parent?._nodes.Remove(this);
                value?._nodes.Add(this);
            }
        }
    }

    public Collection<Node> Nodes
    {
        get { return _nodes; }
    }

    public virtual string Text
    {
        get { return _text; }
        set
        {
            _text = value;
        }
    }

    public virtual string ToolTip { get; }

    public Image Image { get; set; }

    public virtual bool IsVisible
    {
        get { return _visible; }
        set
        {
            if (value != _visible)
            {
                _visible = value;
                TreeModel model = RootTreeModel();
                if (model != null && _parent != null)
                {
                    int index = 0;
                    for (int i = 0; i < _parent._nodes.Count; i++)
                    {
                        Node node = _parent._nodes[i];
                        if (node == this)
                            break;
                        if (node.IsVisible || model.ForceVisible)
                            index++;
                    }
                    if (model.ForceVisible)
                    {
                        model.OnNodeChanged(_parent, index, this);
                    }
                    else
                    {
                        if (value)
                            model.OnNodeInserted(_parent, index, this);
                        else
                            model.OnNodeRemoved(_parent, index, this);
                    }
                }
                IsVisibleChanged?.Invoke(this);
            }
        }
    }

    private class NodeCollection : Collection<Node>
    {
        private readonly Node _owner;

        public NodeCollection(Node owner)
        {
            _owner = owner;
        }

        protected override void ClearItems()
        {
            while (Count != 0)
                RemoveAt(Count - 1);
        }

        protected override void InsertItem(int index, Node item)
        {
            if (item == null)
                throw new ArgumentNullException(nameof(item));

            if (item._parent != _owner)
            {
                item._parent?._nodes.Remove(item);
                item._parent = _owner;
                base.InsertItem(index, item);

                TreeModel model = _owner.RootTreeModel();
                model?.OnStructureChanged(_owner);
                _owner.NodeAdded?.Invoke(item);
            }
        }

        protected override void RemoveItem(int index)
        {
            Node item = this[index];
            item._parent = null;
            base.RemoveItem(index);

            TreeModel model = _owner.RootTreeModel();
            model?.OnStructureChanged(_owner);
            _owner.NodeRemoved?.Invoke(item);
        }

        protected override void SetItem(int index, Node item)
        {
            if (item == null)
                throw new ArgumentNullException(nameof(item));

            RemoveAt(index);
            InsertItem(index, item);
        }
    }
}
```

`LibreHardwareMonitor/UI/NodeToolTipProvider.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using Aga.Controls.Tree;
using Aga.Controls.Tree.NodeControls;

namespace LibreHardwareMonitor.UI;

internal class NodeToolTipProvider : IToolTipProvider
{
    public string GetToolTip(TreeNodeAdv node, NodeControl nodeControl) => (node.Tag as Node)?.ToolTip;
}
```

`LibreHardwareMonitor/UI/NotifyIconAdv.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.ComponentModel;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Windows.Forms;

namespace LibreHardwareMonitor.UI;

public class NotifyIconAdv : IDisposable
{
    private readonly NotifyIcon _genericNotifyIcon;
    private readonly NotifyIconWindowsImplementation _windowsNotifyIcon;

    public NotifyIconAdv()
    {
        if (Environment.OSVersion.Platform == PlatformID.MacOSX || Environment.OSVersion.Platform == PlatformID.Unix)
            _genericNotifyIcon = new NotifyIcon();
        else
            _windowsNotifyIcon = new NotifyIconWindowsImplementation();
    }

    public event EventHandler BalloonTipClicked
    {
        add
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.BalloonTipClicked += value;
            else
                _windowsNotifyIcon.BalloonTipClicked += value;
        }
        remove
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.BalloonTipClicked -= value;
            else
                _windowsNotifyIcon.BalloonTipClicked -= value;
        }
    }

    public event EventHandler BalloonTipClosed
    {
        add
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.BalloonTipClosed += value;
            else
                _windowsNotifyIcon.BalloonTipClosed += value;
        }
        remove
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.BalloonTipClosed -= value;
            else
                _windowsNotifyIcon.BalloonTipClosed -= value;
        }
    }

    public event EventHandler BalloonTipShown
    {
        add
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.BalloonTipShown += value;
            else
                _windowsNotifyIcon.BalloonTipShown += value;
        }
        remove
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.BalloonTipShown -= value;
            else
                _windowsNotifyIcon.BalloonTipShown -= value;
        }
    }

    public event EventHandler Click
    {
        add
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.Click += value;
            else
                _windowsNotifyIcon.Click += value;
        }
        remove
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.Click -= value;
            else
                _windowsNotifyIcon.Click -= value;
        }
    }

    public event EventHandler DoubleClick
    {
        add
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.DoubleClick += value;
            else
                _windowsNotifyIcon.DoubleClick += value;
        }
        remove
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.DoubleClick -= value;
            else
                _windowsNotifyIcon.DoubleClick -= value;
        }
    }

    public event MouseEventHandler MouseClick
    {
        add
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.MouseClick += value;
            else
                _windowsNotifyIcon.MouseClick += value;
        }
        remove
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.MouseClick -= value;
            else
                _windowsNotifyIcon.MouseClick -= value;
        }
    }

    public event MouseEventHandler MouseDoubleClick
    {
        add
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.MouseDoubleClick += value;
            else
                _windowsNotifyIcon.MouseDoubleClick += value;
        }
        remove
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.MouseDoubleClick -= value;
            else
                _windowsNotifyIcon.MouseDoubleClick -= value;
        }
    }

    public event MouseEventHandler MouseDown
    {
        add
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.MouseDown += value;
            else
                _windowsNotifyIcon.MouseDown += value;
        }
        remove
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.MouseDown -= value;
            else
                _windowsNotifyIcon.MouseDown -= value;
        }
    }

    public event MouseEventHandler MouseMove
    {
        add
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.MouseMove += value;
            else
                _windowsNotifyIcon.MouseMove += value;
        }
        remove
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.MouseMove -= value;
            else
                _windowsNotifyIcon.MouseMove -= value;
        }
    }

    public event MouseEventHandler MouseUp
    {
        add
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.MouseUp += value;
            else
                _windowsNotifyIcon.MouseUp += value;
        }
        remove
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.MouseUp -= value;
            else
                _windowsNotifyIcon.MouseUp -= value;
        }
    }

    public string BalloonTipText
    {
        get
        {
            if (_genericNotifyIcon != null)
                return _genericNotifyIcon.BalloonTipText;


            return _windowsNotifyIcon.BalloonTipText;
        }
        set
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.BalloonTipText = value;
            else
                _windowsNotifyIcon.BalloonTipText = value;
        }
    }

    public ToolTipIcon BalloonTipIcon
    {
        get
        {
            if (_genericNotifyIcon != null)
                return _genericNotifyIcon.BalloonTipIcon;


            return _windowsNotifyIcon.BalloonTipIcon;
        }
        set
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.BalloonTipIcon = value;
            else
                _windowsNotifyIcon.BalloonTipIcon = value;
        }
    }

    public string BalloonTipTitle
    {
        get
        {
            if (_genericNotifyIcon != null)
                return _genericNotifyIcon.BalloonTipTitle;


            return _windowsNotifyIcon.BalloonTipTitle;
        }
        set
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.BalloonTipTitle = value;
            else
                _windowsNotifyIcon.BalloonTipTitle = value;
        }
    }

    public ContextMenuStrip ContextMenuStrip
    {
        get
        {
            if (_genericNotifyIcon != null)
                return _genericNotifyIcon.ContextMenuStrip;


            return _windowsNotifyIcon.ContextMenuStrip;
        }
        set
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.ContextMenuStrip = value;
            else
                _windowsNotifyIcon.ContextMenuStrip = value;
        }
    }

    public object Tag { get; set; }

    public Icon Icon
    {
        get
        {
            if (_genericNotifyIcon != null)
                return _genericNotifyIcon.Icon;


            return _windowsNotifyIcon.Icon;
        }
        set
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.Icon = value;
            else
                _windowsNotifyIcon.Icon = value;
        }
    }

    public string Text
    {
        get
        {
            if (_genericNotifyIcon != null)
                return _genericNotifyIcon.Text;


            return _windowsNotifyIcon.Text;
        }
        set
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.Text = value;
            else
                _windowsNotifyIcon.Text = value;
        }
    }

    public bool Visible
    {
        get
        {
            if (_genericNotifyIcon != null)
                return _genericNotifyIcon.Visible;


            return _windowsNotifyIcon.Visible;
        }
        set
        {
            if (_genericNotifyIcon != null)
                _genericNotifyIcon.Visible = value;
            else
                _windowsNotifyIcon.Visible = value;
        }
    }

    public void Dispose()
    {
        if (_genericNotifyIcon != null)
            _genericNotifyIcon.Dispose();
        else
            _windowsNotifyIcon.Dispose();
    }

    public void ShowBalloonTip(int timeout)
    {
        ShowBalloonTip(timeout, BalloonTipTitle, BalloonTipText, BalloonTipIcon);
    }

    public void ShowBalloonTip(int timeout, string tipTitle, string tipText,
        ToolTipIcon tipIcon)
    {
        if (_genericNotifyIcon != null)
            _genericNotifyIcon.ShowBalloonTip(timeout, tipTitle, tipText, tipIcon);
        else
            _windowsNotifyIcon.ShowBalloonTip(timeout, tipTitle, tipText, tipIcon);
    }

    private class NotifyIconWindowsImplementation : Component
    {

        private static int _nextId;
        private readonly object _syncObj = new object();
        private Icon _icon;
        private string _text = "";
        private readonly int _id;
        private bool _created;
        private NotifyIconNativeWindow _window;
        private bool _doubleClickDown;
        private bool _visible;
        private readonly MethodInfo _commandDispatch;

        public event EventHandler BalloonTipClicked;
        public event EventHandler BalloonTipClosed;
        public event EventHandler BalloonTipShown;
        public event EventHandler Click;
        public event EventHandler DoubleClick;
        public event MouseEventHandler MouseClick;
        public event MouseEventHandler MouseDoubleClick;
        public event MouseEventHandler MouseDown;
        public event MouseEventHandler MouseMove;
        public event MouseEventHandler MouseUp;

        public string BalloonTipText { get; set; }
        public ToolTipIcon BalloonTipIcon { get; set; }
        public string BalloonTipTitle { get; set; }
        public ContextMenuStrip ContextMenuStrip { get; set; }

        public Icon Icon
        {
            get
            {
                return _icon;
            }
            set
            {
                if (_icon != value)
                {
                    _icon = value;
                    UpdateNotifyIcon(_visible);
                }
            }
        }

        public string Text
        {
            get
            {
                return _text;
            }
            set
            {
                if (value == null)
                    value = "";

                if (value.Length > 63)
                    throw new ArgumentOutOfRangeException();

                if (!value.Equals(_text))
                {
                    _text = value;
                    if (_visible)
                        UpdateNotifyIcon(_visible);
                }
            }
        }

        public bool Visible
        {
            get
            {
                return _visible;
            }
            set
            {
                if (_visible != value)
                {
                    _visible = value;
                    UpdateNotifyIcon(_visible);
                }
            }
        }

        public NotifyIconWindowsImplementation()
        {
            BalloonTipText = "";
            BalloonTipTitle = "";

            _commandDispatch = typeof(Form).Assembly.
                                            GetType("System.Windows.Forms.Command").GetMethod("DispatchID",
                                                                                              BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Public,
                                                                                              null, new[] { typeof(int) }, null);

            _id = ++_nextId;
            _window = new NotifyIconNativeWindow(this);
            UpdateNotifyIcon(_visible);
        }

        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (_window != null)
                {
                    _icon = null;
                    _text = "";
                    UpdateNotifyIcon(false);
                    _window.DestroyHandle();
                    _window = null;
                    ContextMenuStrip = null;
                }
            }
            else
            {
                if (_window != null && _window.Handle != IntPtr.Zero)
                {
                    NativeMethods.PostMessage(new HandleRef(_window, _window.Handle), WM_CLOSE, 0, 0);
                    _window.ReleaseHandle();
                }
            }
            base.Dispose(disposing);
        }

        public void ShowBalloonTip(int timeout)
        {
            ShowBalloonTip(timeout, BalloonTipTitle, BalloonTipText, BalloonTipIcon);
        }

        public void ShowBalloonTip(int timeout, string tipTitle, string tipText, ToolTipIcon tipIcon)
        {
            if (timeout < 0)
                throw new ArgumentOutOfRangeException(nameof(timeout));

            if (string.IsNullOrEmpty(tipText))
                throw new ArgumentException("tipText");

            if (DesignMode)
                return;

            if (_created)
            {
                NativeMethods.NotifyIconData data = new NativeMethods.NotifyIconData();
                if (_window.Handle == IntPtr.Zero)
                    _window.CreateHandle(new CreateParams());

                data.Window = _window.Handle;
                data.ID = _id;
                data.Flags = NativeMethods.NotifyIconDataFlags.Info;
                data.TimeoutOrVersion = timeout;
                data.InfoTitle = tipTitle;
                data.Info = tipText;
                data.InfoFlags = (int)tipIcon;

                NativeMethods.Shell_NotifyIcon(NativeMethods.NotifyIconMessage.Modify, data);
            }
        }

        private void ShowContextMenu()
        {
            if (ContextMenuStrip == null)
                return;

            NativeMethods.Point p = new NativeMethods.Point();
            NativeMethods.GetCursorPos(ref p);
            NativeMethods.SetForegroundWindow(new HandleRef(_window, _window.Handle));

            ContextMenuStrip?.GetType().InvokeMember("ShowInTaskbar",
                                                     BindingFlags.NonPublic | BindingFlags.InvokeMethod |
                                                     BindingFlags.Instance, null, ContextMenuStrip, new object[] { p.X, p.Y });
        }

        private void UpdateNotifyIcon(bool showNotifyIcon)
        {
            if (DesignMode)
                return;

            lock (_syncObj)
            {
                _window.LockReference(showNotifyIcon);

                NativeMethods.NotifyIconData data = new NativeMethods.NotifyIconData { CallbackMessage = WM_TRAYMOUSEMESSAGE, Flags = NativeMethods.NotifyIconDataFlags.Message };

                if (showNotifyIcon && _window.Handle == IntPtr.Zero)
                    _window.CreateHandle(new CreateParams());

                data.Window = _window.Handle;
                data.ID = _id;

                if (_icon != null)
                {
                    data.Flags |= NativeMethods.NotifyIconDataFlags.Icon;
                    data.Icon = _icon.Handle;
                }

                data.Flags |= NativeMethods.NotifyIconDataFlags.Tip;
                data.Tip = _text;

                if (showNotifyIcon && _icon != null)
                {
                    if (!_created)
                    {
                        if (NativeMethods.Shell_NotifyIcon(NativeMethods.NotifyIconMessage.Modify, data))
                        {
                            _created = true;
                        }
                        else
                        {
                            int i = 0;
                            do
                            {
                                _created = NativeMethods.Shell_NotifyIcon(NativeMethods.NotifyIconMessage.Add, data);
                                if (!_created)
                                {
                                    System.Threading.Thread.Sleep(200);
                                    i++;
                                }
                            } while (!_created && i < 40);
                        }
                    }
                    else
                    {
                        NativeMethods.Shell_NotifyIcon(NativeMethods.NotifyIconMessage.Modify, data);
                    }
                }
                else
                {
                    if (_created)
                    {
                        int i = 0;
                        bool deleted;
                        do
                        {
                            deleted = NativeMethods.Shell_NotifyIcon(NativeMethods.NotifyIconMessage.Delete, data);
                            if (!deleted)
                            {
                                System.Threading.Thread.Sleep(200);
                                i++;
                            }
                        } while (!deleted && i < 40);
                        _created = false;
                    }
                }
            }
        }

        private void ProcessMouseDown(MouseButtons button, bool doubleClick)
        {
            if (doubleClick)
            {
                DoubleClick?.Invoke(this, new MouseEventArgs(button, 2, 0, 0, 0));
                MouseDoubleClick?.Invoke(this, new MouseEventArgs(button, 2, 0, 0, 0));

                _doubleClickDown = true;
            }

            MouseDown?.Invoke(this, new MouseEventArgs(button, doubleClick ? 2 : 1, 0, 0, 0));
        }

        private void ProcessMouseUp(MouseButtons button)
        {
            MouseUp?.Invoke(this, new MouseEventArgs(button, 0, 0, 0, 0));

            if (!_doubleClickDown)
            {
                Click?.Invoke(this, new MouseEventArgs(button, 0, 0, 0, 0));
                MouseClick?.Invoke(this, new MouseEventArgs(button, 0, 0, 0, 0));
            }
            _doubleClickDown = false;
        }

        private void ProcessInitMenuPopup(ref Message message)
        {
            _window.DefWndProc(ref message);
        }

        private void WndProc(ref Message message)
        {
            switch (message.Msg)
            {
                case WM_DESTROY:
                    UpdateNotifyIcon(false);
                    return;
                case WM_COMMAND:
                    if (message.LParam != IntPtr.Zero)
                    {
                        _window.DefWndProc(ref message);
                        return;
                    }
                    _commandDispatch.Invoke(null, new object[] { message.WParam.ToInt32() & 0xFFFF });
                    return;
                case WM_INITMENUPOPUP:
                    ProcessInitMenuPopup(ref message);
                    return;
                case WM_TRAYMOUSEMESSAGE:
                    switch ((int)message.LParam)
                    {
                        case WM_MOUSEMOVE:
                            MouseMove?.Invoke(this,
                                              new MouseEventArgs(Control.MouseButtons, 0, 0, 0, 0));
                            return;
                        case WM_LBUTTONDOWN:
                            ProcessMouseDown(MouseButtons.Left, false);
                            return;
                        case WM_LBUTTONUP:
                            ProcessMouseUp(MouseButtons.Left);
                            return;
                        case WM_LBUTTONDBLCLK:
                            ProcessMouseDown(MouseButtons.Left, true);
                            return;
                        case WM_RBUTTONDOWN:
                            ProcessMouseDown(MouseButtons.Right, false);
                            return;
                        case WM_RBUTTONUP:
                            if (ContextMenuStrip != null)
                                ShowContextMenu();
                            ProcessMouseUp(MouseButtons.Right);
                            return;
                        case WM_RBUTTONDBLCLK:
                            ProcessMouseDown(MouseButtons.Right, true);
                            return;
                        case WM_MBUTTONDOWN:
                            ProcessMouseDown(MouseButtons.Middle, false);
                            return;
                        case WM_MBUTTONUP:
                            ProcessMouseUp(MouseButtons.Middle);
                            return;
                        case WM_MBUTTONDBLCLK:
                            ProcessMouseDown(MouseButtons.Middle, true);
                            return;
                        case NIN_BALLOONSHOW:
                            BalloonTipShown?.Invoke(this, EventArgs.Empty);
                            return;
                        case NIN_BALLOONHIDE:
                        case NIN_BALLOONTIMEOUT:
                            BalloonTipClosed?.Invoke(this, EventArgs.Empty);
                            return;
                        case NIN_BALLOONUSERCLICK:
                            BalloonTipClicked?.Invoke(this, EventArgs.Empty);
                            return;
                        default:
                            return;
                    }
            }

            if (message.Msg == _wmTaskBarCreated)
            {
                lock (_syncObj)
                {
                    _created = false;
                }
                UpdateNotifyIcon(_visible);
            }

            _window.DefWndProc(ref message);
        }

        private class NotifyIconNativeWindow : NativeWindow
        {
            private readonly NotifyIconWindowsImplementation _reference;
            private GCHandle _referenceHandle;

            internal NotifyIconNativeWindow(NotifyIconWindowsImplementation component)
            {
                _reference = component;
            }

            ~NotifyIconNativeWindow()
            {
                if (Handle != IntPtr.Zero)
                    NativeMethods.PostMessage(new HandleRef(this, Handle), WM_CLOSE, 0, 0);
            }

            public void LockReference(bool locked)
            {
                if (locked)
                {
                    if (!_referenceHandle.IsAllocated)
                    {
                        _referenceHandle = GCHandle.Alloc(_reference, GCHandleType.Normal);
                    }
                }
                else
                {
                    if (_referenceHandle.IsAllocated)
                        _referenceHandle.Free();
                }
            }

            protected override void OnThreadException(Exception e)
            {
                Application.OnThreadException(e);
            }

            protected override void WndProc(ref Message m)
            {
                _reference.WndProc(ref m);
            }
        }

        private const int WM_NULL = 0x00;
        private const int WM_DESTROY = 0x02;
        private const int WM_CLOSE = 0x10;
        private const int WM_COMMAND = 0x111;
        private const int WM_INITMENUPOPUP = 0x117;
        private const int WM_MOUSEMOVE = 0x200;
        private const int WM_LBUTTONDOWN = 0x201;
        private const int WM_LBUTTONUP = 0x202;
        private const int WM_LBUTTONDBLCLK = 0x203;
        private const int WM_RBUTTONDOWN = 0x204;
        private const int WM_RBUTTONUP = 0x205;
        private const int WM_RBUTTONDBLCLK = 0x206;
        private const int WM_MBUTTONDOWN = 0x207;
        private const int WM_MBUTTONUP = 0x208;
        private const int WM_MBUTTONDBLCLK = 0x209;
        private const int WM_TRAYMOUSEMESSAGE = 0x800;

        private const int NIN_BALLOONSHOW = 0x402;
        private const int NIN_BALLOONHIDE = 0x403;
        private const int NIN_BALLOONTIMEOUT = 0x404;
        private const int NIN_BALLOONUSERCLICK = 0x405;

        private static readonly int _wmTaskBarCreated = NativeMethods.RegisterWindowMessage("TaskbarCreated");

        private static class NativeMethods
        {
            private const string DllNameUser32 = "user32.dll";
            private const string DllNameShell32 = "shell32.dll";

            [DllImport(DllNameUser32, CharSet = CharSet.Auto)]
            public static extern IntPtr PostMessage(HandleRef hwnd, int msg, int wparam, int lparam);

            [DllImport(DllNameUser32, CharSet = CharSet.Auto)]
            public static extern int RegisterWindowMessage(string msg);

            [Flags]
            public enum NotifyIconDataFlags : int
            {
                Message = 0x1,
                Icon = 0x2,
                Tip = 0x4,
                State = 0x8,
                Info = 0x10
            }

            [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
            public class NotifyIconData
            {
                private int _size = Marshal.SizeOf(typeof(NotifyIconData));
                public IntPtr Window;
                public int ID;
                public NotifyIconDataFlags Flags;
                public int CallbackMessage;
                public IntPtr Icon;
                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
                public string Tip;
                public int State;
                public int StateMask;
                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
                public string Info;
                public int TimeoutOrVersion;
                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 64)]
                public string InfoTitle;
                public int InfoFlags;
            }

            public enum NotifyIconMessage : int
            {
                Add = 0x0,
                Modify = 0x1,
                Delete = 0x2
            }

            [DllImport(DllNameShell32, CharSet = CharSet.Auto)]
            [return: MarshalAs(UnmanagedType.Bool)]
            public static extern bool Shell_NotifyIcon(NotifyIconMessage message, NotifyIconData pnid);

            [DllImport(DllNameUser32, CharSet = CharSet.Auto, ExactSpelling = true)]
            public static extern bool TrackPopupMenuEx(HandleRef hmenu, int fuFlags, int x, int y, HandleRef hwnd, IntPtr tpm);

            [StructLayout(LayoutKind.Sequential)]
            public struct Point
            {
                public readonly int X;
                public readonly int Y;
            }

            [DllImport(DllNameUser32, CharSet = CharSet.Auto, ExactSpelling = true)]
            public static extern bool GetCursorPos(ref Point point);

            [DllImport(DllNameUser32, CharSet = CharSet.Auto, ExactSpelling = true)]
            public static extern bool SetForegroundWindow(HandleRef hWnd);
        }
    }
}
```

`LibreHardwareMonitor/UI/ParameterForm.Designer.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.UI
{
    partial class ParameterForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle2 = new System.Windows.Forms.DataGridViewCellStyle();
            this.okButton = new System.Windows.Forms.Button();
            this.cancelButton = new System.Windows.Forms.Button();
            this.captionLabel = new System.Windows.Forms.Label();
            this.dataGridView = new System.Windows.Forms.DataGridView();
            this.NameColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.Default = new System.Windows.Forms.DataGridViewCheckBoxColumn();
            this.ValueColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.bindingSource = new System.Windows.Forms.BindingSource(this.components);
            this.descriptionLabel = new System.Windows.Forms.Label();
            ((System.ComponentModel.ISupportInitialize)(this.dataGridView)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.bindingSource)).BeginInit();
            this.SuspendLayout();
            //
            // okButton
            //
            this.okButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.okButton.DialogResult = System.Windows.Forms.DialogResult.OK;
            this.okButton.Location = new System.Drawing.Point(186, 213);
            this.okButton.Name = "okButton";
            this.okButton.Size = new System.Drawing.Size(75, 23);
            this.okButton.TabIndex = 2;
            this.okButton.Text = "OK";
            this.okButton.UseVisualStyleBackColor = true;
            this.okButton.Click += new System.EventHandler(this.OkButton_Click);
            //
            // cancelButton
            //
            this.cancelButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.cancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.cancelButton.Location = new System.Drawing.Point(267, 213);
            this.cancelButton.Name = "cancelButton";
            this.cancelButton.Size = new System.Drawing.Size(75, 23);
            this.cancelButton.TabIndex = 3;
            this.cancelButton.Text = "Cancel";
            this.cancelButton.UseVisualStyleBackColor = true;
            //
            // captionLabel
            //
            this.captionLabel.AutoSize = true;
            this.captionLabel.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.captionLabel.Location = new System.Drawing.Point(12, 9);
            this.captionLabel.Name = "captionLabel";
            this.captionLabel.Size = new System.Drawing.Size(80, 13);
            this.captionLabel.TabIndex = 4;
            this.captionLabel.Text = "captionLabel";
            //
            // dataGridView
            //
            this.dataGridView.AllowUserToAddRows = false;
            this.dataGridView.AllowUserToDeleteRows = false;
            this.dataGridView.AllowUserToResizeRows = false;
            this.dataGridView.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
            | System.Windows.Forms.AnchorStyles.Left)
            | System.Windows.Forms.AnchorStyles.Right)));
            this.dataGridView.AutoGenerateColumns = false;
            this.dataGridView.AutoSizeColumnsMode = System.Windows.Forms.DataGridViewAutoSizeColumnsMode.Fill;
            this.dataGridView.BackgroundColor = System.Drawing.SystemColors.Window;
            this.dataGridView.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
            this.dataGridView.ColumnHeadersHeightSizeMode = System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode.AutoSize;
            this.dataGridView.Columns.AddRange(new System.Windows.Forms.DataGridViewColumn[] {
            this.NameColumn,
            this.Default,
            this.ValueColumn});
            this.dataGridView.DataSource = this.bindingSource;
            dataGridViewCellStyle2.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleLeft;
            dataGridViewCellStyle2.BackColor = System.Drawing.SystemColors.Window;
            dataGridViewCellStyle2.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            dataGridViewCellStyle2.ForeColor = System.Drawing.SystemColors.ControlText;
            dataGridViewCellStyle2.SelectionBackColor = System.Drawing.Color.FromArgb(((int)(((byte)(240)))), ((int)(((byte)(240)))), ((int)(((byte)(240)))));
            dataGridViewCellStyle2.SelectionForeColor = System.Drawing.SystemColors.ControlText;
            dataGridViewCellStyle2.WrapMode = System.Windows.Forms.DataGridViewTriState.False;
            this.dataGridView.DefaultCellStyle = dataGridViewCellStyle2;
            this.dataGridView.Location = new System.Drawing.Point(15, 30);
            this.dataGridView.MultiSelect = false;
            this.dataGridView.Name = "dataGridView";
            this.dataGridView.RowHeadersVisible = false;
            this.dataGridView.SelectionMode = System.Windows.Forms.DataGridViewSelectionMode.FullRowSelect;
            this.dataGridView.ShowRowErrors = false;
            this.dataGridView.Size = new System.Drawing.Size(327, 121);
            this.dataGridView.TabIndex = 0;
            this.dataGridView.CellEndEdit += new System.Windows.Forms.DataGridViewCellEventHandler(this.DataGridView_CellEndEdit);
            this.dataGridView.CellValidating += new System.Windows.Forms.DataGridViewCellValidatingEventHandler(this.DataGridView_CellValidating);
            this.dataGridView.CurrentCellDirtyStateChanged += new System.EventHandler(this.DataGridView_CurrentCellDirtyStateChanged);
            this.dataGridView.RowEnter += new System.Windows.Forms.DataGridViewCellEventHandler(this.DataGridView_RowEnter);
            //
            // NameColumn
            //
            this.NameColumn.DataPropertyName = "Name";
            this.NameColumn.HeaderText = "Name";
            this.NameColumn.Name = "NameColumn";
            this.NameColumn.ReadOnly = true;
            this.NameColumn.SortMode = System.Windows.Forms.DataGridViewColumnSortMode.NotSortable;
            //
            // Default
            //
            this.Default.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.ColumnHeader;
            this.Default.DataPropertyName = "Default";
            this.Default.HeaderText = "Default";
            this.Default.Name = "Default";
            this.Default.Width = 47;
            //
            // ValueColumn
            //
            this.ValueColumn.DataPropertyName = "Value";
            this.ValueColumn.HeaderText = "Value";
            this.ValueColumn.Name = "ValueColumn";
            this.ValueColumn.SortMode = System.Windows.Forms.DataGridViewColumnSortMode.NotSortable;
            //
            // bindingSource
            //
            this.bindingSource.AllowNew = false;
            //
            // descriptionLabel
            //
            this.descriptionLabel.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)
            | System.Windows.Forms.AnchorStyles.Right)));
            this.descriptionLabel.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
            this.descriptionLabel.Location = new System.Drawing.Point(15, 154);
            this.descriptionLabel.Name = "descriptionLabel";
            this.descriptionLabel.Padding = new System.Windows.Forms.Padding(2);
            this.descriptionLabel.Size = new System.Drawing.Size(327, 50);
            this.descriptionLabel.TabIndex = 6;
            this.descriptionLabel.Text = "descriptionLabel";
            //
            // ParameterForm
            //
            this.AcceptButton = this.okButton;
            this.AccessibleName = "";
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(354, 248);
            this.Controls.Add(this.descriptionLabel);
            this.Controls.Add(this.dataGridView);
            this.Controls.Add(this.captionLabel);
            this.Controls.Add(this.cancelButton);
            this.Controls.Add(this.okButton);
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "ParameterForm";
            this.ShowIcon = false;
            this.ShowInTaskbar = false;
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
            this.Text = "Parameters";
            ((System.ComponentModel.ISupportInitialize)(this.dataGridView)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.bindingSource)).EndInit();
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.Button okButton;
        private System.Windows.Forms.Button cancelButton;
        public System.Windows.Forms.Label captionLabel;
        private System.Windows.Forms.DataGridView dataGridView;
        private System.Windows.Forms.Label descriptionLabel;
        private System.Windows.Forms.BindingSource bindingSource;
        private System.Windows.Forms.DataGridViewTextBoxColumn NameColumn;
        private System.Windows.Forms.DataGridViewCheckBoxColumn Default;
        private System.Windows.Forms.DataGridViewTextBoxColumn ValueColumn;

    }
}

```

`LibreHardwareMonitor/UI/ParameterForm.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Windows.Forms;
using LibreHardwareMonitor.Hardware;

namespace LibreHardwareMonitor.UI;

public partial class ParameterForm : Form
{
    private IReadOnlyList<IParameter> _parameters;
    private BindingList<ParameterRow> _parameterRows;

    public ParameterForm()
    {
        InitializeComponent();
    }

    public IReadOnlyList<IParameter> Parameters
    {
        get
        {
            return _parameters;
        }
        set
        {
            _parameters = value;
            _parameterRows = new BindingList<ParameterRow>();

            foreach (IParameter parameter in _parameters)
            {
                _parameterRows.Add(new ParameterRow(parameter));
            }

            bindingSource.DataSource = _parameterRows;
        }
    }

    private class ParameterRow : INotifyPropertyChanged
    {
        public readonly IParameter Parameter;
        private float _value = float.NaN;
        private bool _default = true;

        public event PropertyChangedEventHandler PropertyChanged;

        private void NotifyPropertyChanged(String propertyName)
        {
            if (PropertyChanged != null)
                PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
        }

        public ParameterRow(IParameter parameter)
        {
            Parameter = parameter;
            Value = parameter.Value;
            Default = parameter.IsDefault;
        }

        public string Name
        {
            get { return Parameter.Name; }
        }

        public float Value
        {
            get { return _value; }
            set
            {
                _default = false;
                _value = value;
                NotifyPropertyChanged(nameof(Default));
                NotifyPropertyChanged(nameof(Value));
            }
        }

        public bool Default
        {
            get { return _default; }
            set
            {
                _default = value;
                if (_default)
                    _value = Parameter.DefaultValue;
                NotifyPropertyChanged(nameof(Default));
                NotifyPropertyChanged(nameof(Value));
            }
        }
    }

    private void DataGridView_RowEnter(object sender, DataGridViewCellEventArgs e)
    {
        if (e.RowIndex >= 0 && e.RowIndex < _parameters.Count)
            descriptionLabel.Text = _parameters[e.RowIndex].Description;
        else
            descriptionLabel.Text = string.Empty;
    }

    private void DataGridView_CellValidating(object sender, DataGridViewCellValidatingEventArgs e)
    {
        if (e.ColumnIndex == 2 && !float.TryParse(e.FormattedValue.ToString(), out float _))
        {
            dataGridView.Rows[e.RowIndex].Cells[0].ErrorText = "Invalid value";
            e.Cancel = true;
        }
    }

    private void DataGridView_CellEndEdit(object sender, DataGridViewCellEventArgs e)
    {
        dataGridView.Rows[e.RowIndex].Cells[0].ErrorText = string.Empty;
    }

    private void OkButton_Click(object sender, EventArgs e)
    {
        foreach (ParameterRow row in _parameterRows)
        {
            if (row.Default)
                row.Parameter.IsDefault = true;
            else
                row.Parameter.Value = row.Value;
        }
    }

    private void DataGridView_CurrentCellDirtyStateChanged(object sender, EventArgs e)
    {
        if (dataGridView.CurrentCell is DataGridViewCheckBoxCell || dataGridView.CurrentCell is DataGridViewComboBoxCell)
            dataGridView.CommitEdit(DataGridViewDataErrorContexts.Commit);
    }
}
```

`LibreHardwareMonitor/UI/ParameterForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="NameColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="Default.UserAddedColumn" type="System.Boolean, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="ValueColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="bindingSource.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
</root>
```

`LibreHardwareMonitor/UI/PlotPanel.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;
using LibreHardwareMonitor.Hardware;
using LibreHardwareMonitor.Utilities;
using OxyPlot;
using OxyPlot.Annotations;
using OxyPlot.Axes;
using OxyPlot.WindowsForms;
using OxyPlot.Series;
using LibreHardwareMonitor.UI.Themes;

namespace LibreHardwareMonitor.UI;

public class PlotPanel : UserControl
{
    private readonly PersistentSettings _settings;
    private readonly UnitManager _unitManager;
    private readonly PlotView _plot;
    private readonly PlotModel _model;
    private readonly TimeSpanAxis _timeAxis = new TimeSpanAxis();
    private readonly SortedDictionary<SensorType, LinearAxis> _axes = new SortedDictionary<SensorType, LinearAxis>();
    private readonly Dictionary<SensorType, LineAnnotation> _annotations = new Dictionary<SensorType, LineAnnotation>();
    private UserOption _stackedAxes;
    private UserOption _showAxesLabels;
    private UserOption _timeAxisEnableZoom;
    private UserOption _yAxesEnableZoom;
    private DateTime _now;
    private float _dpiX;
    private float _dpiY;
    private double _dpiXScale = 1;
    private double _dpiYScale = 1;
    private Point _rightClickEnter;
    private bool _cancelContextMenu = false;

    public PlotPanel(PersistentSettings settings, UnitManager unitManager)
    {
        _settings = settings;
        _unitManager = unitManager;

        SetDpi();
        _model = CreatePlotModel();

        _plot = new PlotView { Dock = DockStyle.Fill, Model = _model, BackColor = Color.Black, ContextMenuStrip = CreateMenu() };
        _plot.MouseDown += (sender, e) =>
        {
            if (e.Button == MouseButtons.Right)
            {
                _rightClickEnter = e.Location;
            }
        };
        _plot.MouseMove += (sender, e) =>
        {
            if (e.Button == MouseButtons.Right)
            {
                if (!_cancelContextMenu && e.Location.DistanceTo(_rightClickEnter) > 10.0f)
                {
                    _cancelContextMenu = true;
                }
            }
        };

        UpdateAxesPosition();

        SuspendLayout();
        Controls.Add(_plot);
        ResumeLayout(true);
        _plot.ShowTracker(new TrackerHitResult());
        _plot.HideTracker();
        foreach (Control plotControl in _plot.Controls)
        {
            plotControl.BackColor = Theme.Current.PlotBackgroundColor;
            plotControl.ForeColor = Theme.Current.PlotTextColor;
        }
        ApplyTheme();
    }

    public void ApplyTheme()
    {
        _model.Background = Theme.Current.PlotBackgroundColor.ToOxyColor();
        _model.PlotAreaBorderColor = Theme.Current.PlotBorderColor.ToOxyColor();
        foreach (Axis axis in _model.Axes)
        {
            axis.AxislineColor = Theme.Current.PlotBorderColor.ToOxyColor();
            axis.MajorGridlineColor = Theme.Current.PlotGridMajorColor.ToOxyColor();
            axis.MinorGridlineColor = Theme.Current.PlotGridMinorColor.ToOxyColor();
            axis.TextColor = Theme.Current.PlotTextColor.ToOxyColor();
            axis.TitleColor = Theme.Current.PlotTextColor.ToOxyColor();
            axis.MinorTicklineColor = Theme.Current.PlotBorderColor.ToOxyColor();
            axis.TicklineColor = Theme.Current.PlotBorderColor.ToOxyColor();
        }
        foreach (LineAnnotation annotation in _model.Annotations.Select(x => x as LineAnnotation).Where(x => x != null))
        {
            annotation.Color = Theme.Current.PlotBorderColor.ToOxyColor();
        }
    }

    public void SetCurrentSettings()
    {
        foreach (LinearAxis axis in _axes.Values)
        {
            _settings.SetValue("plotPanel.Min" + axis.Key, (float)axis.ActualMinimum);
            _settings.SetValue("plotPanel.Max" + axis.Key, (float)axis.ActualMaximum);
        }
        _settings.SetValue("plotPanel.MinTimeSpan", (float)_timeAxis.ActualMinimum);
        _settings.SetValue("plotPanel.MaxTimeSpan", (float)_timeAxis.ActualMaximum);
    }

    private ContextMenuStrip CreateMenu()
    {
        ContextMenuStrip menu = new ContextMenuStrip();
        menu.Renderer = new ThemedToolStripRenderer();
        menu.Opening += (sender, e) =>
        {
            if (_cancelContextMenu)
            {
                e.Cancel = true;
                _cancelContextMenu = false;
            }
        };

        ToolStripMenuItem stackedAxesMenuItem = new ToolStripMenuItem("Stacked Axes");
        _stackedAxes = new UserOption("stackedAxes", true, stackedAxesMenuItem, _settings);
        _stackedAxes.Changed += (sender, e) =>
        {
            UpdateAxesPosition();
            InvalidatePlot();
        };
        menu.Items.Add(stackedAxesMenuItem);

        ToolStripMenuItem showAxesLabelsMenuItem = new ToolStripMenuItem("Show Axes Labels");
        _showAxesLabels = new UserOption("showAxesLabels", true, showAxesLabelsMenuItem, _settings);
        _showAxesLabels.Changed += (sender, e) =>
        {
            if (_showAxesLabels.Value)
                _model.PlotMargins = new OxyThickness(double.NaN);
            else
                _model.PlotMargins = new OxyThickness(0);
        };
        menu.Items.Add(showAxesLabelsMenuItem);

        ToolStripMenuItem timeAxisMenuItem = new ToolStripMenuItem("Time Axis");
        ToolStripMenuItem[] timeAxisMenuItems =
        { new ToolStripMenuItem("Enable Zoom"),
            new ToolStripMenuItem("Auto", null, (s, e) => { TimeAxisZoom(0, double.NaN); }),
            new ToolStripMenuItem("5 min", null, (s, e) => { TimeAxisZoom(0, 5 * 60); }),
            new ToolStripMenuItem("10 min", null, (s, e) => { TimeAxisZoom(0, 10 * 60); }),
            new ToolStripMenuItem("20 min", null, (s, e) => { TimeAxisZoom(0, 20 * 60); }),
            new ToolStripMenuItem("30 min", null, (s, e) => { TimeAxisZoom(0, 30 * 60); }),
            new ToolStripMenuItem("45 min", null, (s, e) => { TimeAxisZoom(0, 45 * 60); }),
            new ToolStripMenuItem("1 h", null, (s, e) => { TimeAxisZoom(0, 60 * 60); }),
            new ToolStripMenuItem("1.5 h", null, (s, e) => { TimeAxisZoom(0, 1.5 * 60 * 60); }),
            new ToolStripMenuItem("2 h", null, (s, e) => { TimeAxisZoom(0, 2 * 60 * 60); }),
            new ToolStripMenuItem("3 h", null, (s, e) => { TimeAxisZoom(0, 3 * 60 * 60); }),
            new ToolStripMenuItem("6 h", null, (s, e) => { TimeAxisZoom(0, 6 * 60 * 60); }),
            new ToolStripMenuItem("12 h", null, (s, e) => { TimeAxisZoom(0, 12 * 60 * 60); }),
            new ToolStripMenuItem("24 h", null, (s, e) => { TimeAxisZoom(0, 24 * 60 * 60); }) };

        foreach (ToolStripItem mi in timeAxisMenuItems)
            timeAxisMenuItem.DropDownItems.Add(mi);
        menu.Items.Add(timeAxisMenuItem);

        _timeAxisEnableZoom = new UserOption("timeAxisEnableZoom", true, timeAxisMenuItems[0], _settings);
        _timeAxisEnableZoom.Changed += (sender, e) =>
        {
            _timeAxis.IsZoomEnabled = _timeAxisEnableZoom.Value;
        };

        ToolStripMenuItem yAxesMenuItem = new ToolStripMenuItem("Value Axes");
        ToolStripMenuItem[] yAxesMenuItems =
        { new ToolStripMenuItem("Enable Zoom"),
            new ToolStripMenuItem("Autoscale All", null, (s, e) => { AutoscaleAllYAxes(); }) };

        foreach (ToolStripItem mi in yAxesMenuItems)
            yAxesMenuItem.DropDownItems.Add(mi);
        menu.Items.Add(yAxesMenuItem);

        _yAxesEnableZoom = new UserOption("yAxesEnableZoom", true, yAxesMenuItems[0], _settings);
        _yAxesEnableZoom.Changed += (sender, e) =>
        {
            foreach (LinearAxis axis in _axes.Values)
                axis.IsZoomEnabled = _yAxesEnableZoom.Value;
        };

        return menu;
    }

    private PlotModel CreatePlotModel()
    {
        _timeAxis.Position = AxisPosition.Bottom;
        _timeAxis.MajorGridlineStyle = LineStyle.Solid;
        _timeAxis.MajorGridlineThickness = 1;
        _timeAxis.MajorGridlineColor = OxyColor.FromRgb(192, 192, 192);
        _timeAxis.MinorGridlineStyle = LineStyle.Solid;
        _timeAxis.MinorGridlineThickness = 1;
        _timeAxis.MinorGridlineColor = OxyColor.FromRgb(232, 232, 232);
        _timeAxis.StartPosition = 1;
        _timeAxis.EndPosition = 0;
        _timeAxis.MinimumPadding = 0;
        _timeAxis.MaximumPadding = 0;
        _timeAxis.AbsoluteMinimum = 0;
        _timeAxis.Minimum = 0;
        _timeAxis.AbsoluteMaximum = 24 * 60 * 60;
        _timeAxis.Zoom(
                       _settings.GetValue("plotPanel.MinTimeSpan", 0.0f),
                       _settings.GetValue("plotPanel.MaxTimeSpan", 10.0f * 60));
        _timeAxis.StringFormat = "h:mm";

        var units = new Dictionary<SensorType, string>
        {
            { SensorType.Voltage, "V" },
            { SensorType.Current, "A" },
            { SensorType.Clock, "MHz" },
            { SensorType.Temperature, "°C" },
            { SensorType.Load, "%" },
            { SensorType.Fan, "RPM" },
            { SensorType.Flow, "L/h" },
            { SensorType.Control, "%" },
            { SensorType.Level, "%" },
            { SensorType.Factor, "1" },
            { SensorType.Power, "W" },
            { SensorType.Data, "GB" },
            { SensorType.Frequency, "Hz" },
            { SensorType.Energy, "mWh" },
            { SensorType.Noise, "dBA" },
            { SensorType.Conductivity, "µS/cm" },
            { SensorType.Humidity, "%" }
        };

        foreach (SensorType type in Enum.GetValues(typeof(SensorType)))
        {
            string typeName = type.ToString();
            var axis = new LinearAxis
            {
                Position = AxisPosition.Left,
                MajorGridlineStyle = LineStyle.Solid,
                MajorGridlineThickness = 1,
                MajorGridlineColor = _timeAxis.MajorGridlineColor,
                MinorGridlineStyle = LineStyle.Solid,
                MinorGridlineThickness = 1,
                MinorGridlineColor = _timeAxis.MinorGridlineColor,
                AxislineStyle = LineStyle.Solid,
                Title = typeName,
                Key = typeName,
            };

            var annotation = new LineAnnotation
            {
                Type = LineAnnotationType.Horizontal,
                ClipByXAxis = false,
                ClipByYAxis = false,
                LineStyle = LineStyle.Solid,
                Color = Theme.Current.PlotBorderColor.ToOxyColor(),
                YAxisKey = typeName,
                StrokeThickness = 2,
            };

#pragma warning disable CS0618 //obsolete warning

            axis.AxisChanged += (sender, args) => annotation.Y = axis.ActualMinimum;
            axis.TransformChanged += (sender, args) => annotation.Y = axis.ActualMinimum;

#pragma warning restore CS0618 //obsolete warning

            axis.Zoom(_settings.GetValue("plotPanel.Min" + axis.Key, float.NaN), _settings.GetValue("plotPanel.Max" + axis.Key, float.NaN));

            if (units.ContainsKey(type))
                axis.Unit = units[type];

            _axes.Add(type, axis);
            _annotations.Add(type, annotation);
        }

        var model = new ScaledPlotModel(_dpiXScale, _dpiYScale);
        model.Axes.Add(_timeAxis);
        foreach (LinearAxis axis in _axes.Values)
            model.Axes.Add(axis);
        model.IsLegendVisible = false;

        return model;
    }

    private void SetDpi()
    {
        // https://msdn.microsoft.com/en-us/library/windows/desktop/dn469266(v=vs.85).aspx
        const int defaultDpi = 96;
        Graphics g = CreateGraphics();

        try
        {
            _dpiX = g.DpiX;
            _dpiY = g.DpiY;
        }
        finally
        {
            g.Dispose();
        }

        if (_dpiX > 0)
            _dpiXScale = _dpiX / defaultDpi;
        if (_dpiY > 0)
            _dpiYScale = _dpiY / defaultDpi;
    }

    public void SetSensors(List<ISensor> sensors, IDictionary<ISensor, Color> colors, double strokeThickness)
    {
        _model.Series.Clear();
        var types = new HashSet<SensorType>();


        DataPoint CreateDataPoint(SensorType type, SensorValue value)
        {
            float displayedValue;

            if (type == SensorType.Temperature && _unitManager.TemperatureUnit == TemperatureUnit.Fahrenheit)
            {
                displayedValue = UnitManager.CelsiusToFahrenheit(value.Value).Value;
            }
            else
            {
                displayedValue = value.Value;
            }

            return new DataPoint((_now - value.Time).TotalSeconds, displayedValue);
        }


        foreach (ISensor sensor in sensors)
        {
            var series = new LineSeries
            {
                ItemsSource = sensor.Values.Select(value => CreateDataPoint(sensor.SensorType, value)),
                Color = colors[sensor].ToOxyColor(),
                StrokeThickness = strokeThickness,
                YAxisKey = _axes[sensor.SensorType].Key,
                Title = sensor.Hardware.Name + " " + sensor.Name
            };

            _model.Series.Add(series);

            types.Add(sensor.SensorType);
        }

        foreach (KeyValuePair<SensorType, LinearAxis> pair in _axes.Reverse())
        {
            LinearAxis axis = pair.Value;
            SensorType type = pair.Key;
            axis.IsAxisVisible = types.Contains(type);
        }

        UpdateAxesPosition();
        InvalidatePlot();
    }

    public void UpdateStrokeThickness(double strokeThickness)
    {
        foreach (LineSeries series in _model.Series)
        {
            series.StrokeThickness = strokeThickness;
        }
        InvalidatePlot();
    }

    private void UpdateAxesPosition()
    {
        if (_stackedAxes.Value)
        {
            int count = _axes.Values.Count(axis => axis.IsAxisVisible);
            double start = 0.0;
            foreach (KeyValuePair<SensorType, LinearAxis> pair in _axes.Reverse())
            {
                LinearAxis axis = pair.Value;
                axis.StartPosition = start;
                double delta = axis.IsAxisVisible ? 1.0 / count : 0;
                start += delta;
                axis.EndPosition = start;
                axis.PositionTier = 0;
                axis.MajorGridlineStyle = LineStyle.Solid;
                axis.MinorGridlineStyle = LineStyle.Solid;
                LineAnnotation annotation = _annotations[pair.Key];
                annotation.Y = axis.ActualMinimum;
                if (!_model.Annotations.Contains(annotation)) 
                    _model.Annotations.Add(annotation);
            }
        }
        else
        {
            int tier = 0;

            foreach (KeyValuePair<SensorType, LinearAxis> pair in _axes.Reverse())
            {
                LinearAxis axis = pair.Value;

                if (axis.IsAxisVisible)
                {
                    axis.StartPosition = 0;
                    axis.EndPosition = 1;
                    axis.PositionTier = tier;
                    tier++;
                }
                else
                {
                    axis.StartPosition = 0;
                    axis.EndPosition = 0;
                    axis.PositionTier = 0;
                }
                axis.MajorGridlineStyle = LineStyle.None;
                axis.MinorGridlineStyle = LineStyle.None;
                LineAnnotation annotation = _annotations[pair.Key];
                if (_model.Annotations.Contains(annotation)) 
                    _model.Annotations.Remove(_annotations[pair.Key]);
            }
        }
    }

    public void InvalidatePlot()
    {
        _now = DateTime.UtcNow;

        if (_axes != null)
        {
            foreach (KeyValuePair<SensorType, LinearAxis> pair in _axes)
            {
                LinearAxis axis = pair.Value;
                SensorType type = pair.Key;
                if (type == SensorType.Temperature)
                    axis.Unit = _unitManager.TemperatureUnit == TemperatureUnit.Celsius ? "°C" : "°F";
                    
                if (!_stackedAxes.Value) 
                    continue;

                var annotation = _annotations[pair.Key];
                annotation.Y = axis.ActualMaximum;
            }
        }

        _plot?.InvalidatePlot(true);
    }

    public void TimeAxisZoom(double min, double max)
    {
        bool timeAxisIsZoomEnabled = _timeAxis.IsZoomEnabled;

        _timeAxis.IsZoomEnabled = true;
        _timeAxis.Zoom(min, max);
        InvalidatePlot();
        _timeAxis.IsZoomEnabled = timeAxisIsZoomEnabled;
    }

    public void AutoscaleAllYAxes()
    {
        foreach (LinearAxis axis in _axes.Values)
            axis.Zoom(double.NaN, double.NaN);
    }
}

```

`LibreHardwareMonitor/UI/ScaledPlotModel.cs`:

```cs
using OxyPlot;
using OxyPlot.Legends;

namespace LibreHardwareMonitor.UI;

class ScaledPlotModel : PlotModel
{
    public ScaledPlotModel(double dpiXscale, double dpiYscale)
    {
        PlotMargins = new OxyThickness(PlotMargins.Left * dpiXscale,
                                       PlotMargins.Top * dpiYscale,
                                       PlotMargins.Right * dpiXscale,
                                       PlotMargins.Bottom * dpiYscale);

        Padding = new OxyThickness(Padding.Left * dpiXscale,
                                   Padding.Top * dpiYscale,
                                   Padding.Right * dpiXscale,
                                   Padding.Bottom * dpiYscale);

        TitlePadding *= dpiXscale;

        Legend legend = new();

        legend.LegendSymbolLength *= dpiXscale;
        legend.LegendSymbolMargin *= dpiXscale;
        legend.LegendPadding *= dpiXscale;
        legend.LegendColumnSpacing *= dpiXscale;
        legend.LegendItemSpacing *= dpiXscale;
        legend.LegendMargin *= dpiXscale;

        Legends.Add(legend);
    }
}
```

`LibreHardwareMonitor/UI/SensorGadget.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;
using System.Windows.Forms;
using System.IO;
using System.Linq;
using LibreHardwareMonitor.Hardware;
using LibreHardwareMonitor.Utilities;

namespace LibreHardwareMonitor.UI;

public class SensorGadget : Gadget
{
    private const int TopBorder = 6;
    private const int BottomBorder = 7;
    private const int LeftBorder = 6;
    private const int RightBorder = 7;

    private readonly UnitManager _unitManager;
    private Image _back = Utilities.EmbeddedResources.GetImage("gadget.png");
    private Image _image;
    private Image _fore;
    private Image _barBack = Utilities.EmbeddedResources.GetImage("barback.png");
    private Image _barFore = Utilities.EmbeddedResources.GetImage("barblue.png");
    private Image _background = new Bitmap(1, 1);
    private readonly float _scale;
    private float _fontSize;
    private int _iconSize;
    private int _hardwareLineHeight;
    private int _sensorLineHeight;
    private int _rightMargin;
    private int _leftMargin;
    private int _topMargin;
    private int _bottomMargin;
    private int _progressWidth;

    private readonly IDictionary<IHardware, IList<ISensor>> _sensors = new SortedDictionary<IHardware, IList<ISensor>>(new HardwareComparer());
    private readonly PersistentSettings _settings;
    private readonly UserOption _hardwareNames;

    private Font _largeFont;
    private Font _smallFont;
    private Brush _textBrush;
    private StringFormat _stringFormat;
    private StringFormat _trimStringFormat;
    private StringFormat _alignRightStringFormat;

    public SensorGadget(IComputer computer, PersistentSettings settings, UnitManager unitManager)
    {
        _unitManager = unitManager;
        _settings = settings;
        computer.HardwareAdded += HardwareAdded;
        computer.HardwareRemoved += HardwareRemoved;

        _stringFormat = new StringFormat { FormatFlags = StringFormatFlags.NoWrap };
        _trimStringFormat = new StringFormat { Trimming = StringTrimming.EllipsisCharacter, FormatFlags = StringFormatFlags.NoWrap };
        _alignRightStringFormat = new StringFormat { Alignment = StringAlignment.Far, FormatFlags = StringFormatFlags.NoWrap };

        if (File.Exists("gadget_background.png"))
        {
            try
            {
                Image newBack = new Bitmap("gadget_background.png");
                _back.Dispose();
                _back = newBack;
            }
            catch { }
        }

        if (File.Exists("gadget_image.png"))
        {
            try
            {
                _image = new Bitmap("gadget_image.png");
            }
            catch { }
        }

        if (File.Exists("gadget_foreground.png"))
        {
            try
            {
                _fore = new Bitmap("gadget_foreground.png");
            }
            catch { }
        }

        if (File.Exists("gadget_bar_background.png"))
        {
            try
            {
                Image newBarBack = new Bitmap("gadget_bar_background.png");
                _barBack.Dispose();
                _barBack = newBarBack;
            }
            catch { }
        }

        if (File.Exists("gadget_bar_foreground.png"))
        {
            try
            {
                Image newBarColor = new Bitmap("gadget_bar_foreground.png");
                _barFore.Dispose();
                _barFore = newBarColor;
            }
            catch { }
        }

        Location = new Point(settings.GetValue("sensorGadget.Location.X", 100), settings.GetValue("sensorGadget.Location.Y", 100));
        LocationChanged += delegate
        {
            settings.SetValue("sensorGadget.Location.X", Location.X);
            settings.SetValue("sensorGadget.Location.Y", Location.Y);
        };

        // get the custom to default dpi ratio
        using (Bitmap b = new Bitmap(1, 1))
        {
            _scale = b.HorizontalResolution / 96.0f;
        }

        SetFontSize(settings.GetValue("sensorGadget.FontSize", 7.5f));
        Resize(settings.GetValue("sensorGadget.Width", Size.Width));

        ContextMenuStrip contextMenuStrip = new ContextMenuStrip();
        ToolStripMenuItem hardwareNamesItem = new ToolStripMenuItem("Hardware Names");
        contextMenuStrip.Items.Add(hardwareNamesItem);
        ToolStripMenuItem fontSizeMenu = new ToolStripMenuItem("Font Size");
        for (int i = 0; i < 5; i++)
        {
            float size;
            string name;
            switch (i)
            {
                case 0: size = 6.5f; name = "Small"; break;
                case 1: size = 7.5f; name = "Medium"; break;
                case 2: size = 9f; name = "Large"; break;
                case 3: size = 11f; name = "Very Large"; break;
                case 4: size = 22f; name = "Extremely Large"; break;
                default: throw new NotImplementedException();
            }

            ToolStripItem item = new ToolStripMenuItem(name) { Checked = _fontSize == size };
            item.Click += delegate
            {
                SetFontSize(size);
                settings.SetValue("sensorGadget.FontSize", size);
                foreach (ToolStripMenuItem mi in fontSizeMenu.DropDownItems)
                    mi.Checked = mi == item;
            };
            fontSizeMenu.DropDownItems.Add(item);
        }
        contextMenuStrip.Items.Add(fontSizeMenu);

        Color fontColor = settings.GetValue("sensorGadget.FontColor", Color.White);
        int fontColorArgb = fontColor.ToArgb();

        SetFontColor(fontColor);

        IEnumerable<Color> providedColors = Enum.GetValues(typeof(KnownColor))
                                                .Cast<KnownColor>()
                                                .Select(x => Color.FromKnownColor(x))
                                                .Where(x => !x.IsSystemColor && x.Name.Length < 7);

        ToolStripMenuItem fontColorMenu = new ToolStripMenuItem("Font Color");
        foreach (Color color in providedColors)
        {
            ToolStripItem item = new ToolStripMenuItem(color.Name) { Checked = fontColorArgb == color.ToArgb() };
            item.Click += delegate
            {
                SetFontColor(color);
                settings.SetValue("sensorGadget.FontColor", color);
                foreach (ToolStripMenuItem mi in fontColorMenu.DropDownItems)
                    mi.Checked = mi == item;
            };
            fontColorMenu.DropDownItems.Add(item);
        }
        contextMenuStrip.Items.Add(fontColorMenu);
        contextMenuStrip.Items.Add(new ToolStripSeparator());
        ToolStripMenuItem lockItem = new ToolStripMenuItem("Lock Position and Size");
        contextMenuStrip.Items.Add(lockItem);
        contextMenuStrip.Items.Add(new ToolStripSeparator());
        ToolStripMenuItem alwaysOnTopItem = new ToolStripMenuItem("Always on Top");
        contextMenuStrip.Items.Add(alwaysOnTopItem);
        ToolStripMenuItem opacityMenu = new ToolStripMenuItem("Opacity");
        contextMenuStrip.Items.Add(opacityMenu);
        Opacity = (byte)settings.GetValue("sensorGadget.Opacity", 255);

        for (int i = 0; i < 5; i++)
        {
            ToolStripMenuItem item = new ToolStripMenuItem((20 * (i + 1)).ToString() + " %");
            byte o = (byte)(51 * (i + 1));
            item.Checked = Opacity == o;
            item.Click += delegate
            {
                Opacity = o;
                settings.SetValue("sensorGadget.Opacity", Opacity);
                foreach (ToolStripMenuItem mi in opacityMenu.DropDownItems)
                    mi.Checked = mi == item;
            };
            opacityMenu.DropDownItems.Add(item);
        }

        contextMenuStrip.Items.Add(new ToolStripSeparator());
        ToolStripMenuItem hideShowItem = new ToolStripMenuItem("Hide/Show Main Window");
        contextMenuStrip.Items.Add(hideShowItem);

        ContextMenuStrip = contextMenuStrip;

        _hardwareNames = new UserOption("sensorGadget.Hardwarenames", true, hardwareNamesItem, settings);
        _hardwareNames.Changed += delegate
        {
            Resize();
        };

        UserOption alwaysOnTop = new UserOption("sensorGadget.AlwaysOnTop", false, alwaysOnTopItem, settings);
        alwaysOnTop.Changed += delegate
        {
            AlwaysOnTop = alwaysOnTop.Value;
        };
        UserOption lockPositionAndSize = new UserOption("sensorGadget.LockPositionAndSize", false, lockItem, settings);
        lockPositionAndSize.Changed += delegate
        {
            LockPositionAndSize = lockPositionAndSize.Value;
        };

        hideShowItem.Click += delegate
        {
            SendHideShowCommand();
        };

        HitTest += delegate (object sender, HitTestEventArgs e)
        {
            if (lockPositionAndSize.Value)
                return;

            if (e.Location.X < LeftBorder)
            {
                e.HitResult = HitResult.Left;
                return;
            }
            if (e.Location.X > Size.Width - 1 - RightBorder)
            {
                e.HitResult = HitResult.Right;
            }
        };

        SizeChanged += delegate
        {
            settings.SetValue("sensorGadget.Width", Size.Width);
            Redraw();
        };

        VisibleChanged += delegate
        {
            Rectangle bounds = new Rectangle(Location, Size);
            Screen screen = Screen.FromRectangle(bounds);
            Rectangle intersection = Rectangle.Intersect(screen.WorkingArea, bounds);
            if (intersection.Width < Math.Min(16, bounds.Width) || intersection.Height < Math.Min(16, bounds.Height))
            {
                Location = new Point(screen.WorkingArea.Width / 2 - bounds.Width / 2, screen.WorkingArea.Height / 2 - bounds.Height / 2);
            }
        };

        MouseDoubleClick += delegate
        {
            SendHideShowCommand();
        };
    }

    public override void Dispose()
    {

        _largeFont.Dispose();
        _largeFont = null;

        _smallFont.Dispose();
        _smallFont = null;

        _textBrush.Dispose();
        _textBrush = null;

        _stringFormat.Dispose();
        _stringFormat = null;

        _trimStringFormat.Dispose();
        _trimStringFormat = null;

        _alignRightStringFormat.Dispose();
        _alignRightStringFormat = null;

        _back.Dispose();
        _back = null;

        _barFore.Dispose();
        _barFore = null;

        _barBack.Dispose();
        _barBack = null;

        _background.Dispose();
        _background = null;

        if (_image != null)
        {
            _image.Dispose();
            _image = null;
        }

        if (_fore != null)
        {
            _fore.Dispose();
            _fore = null;
        }

        base.Dispose();
    }

    private void HardwareRemoved(IHardware hardware)
    {
        hardware.SensorAdded -= SensorAdded;
        hardware.SensorRemoved -= SensorRemoved;

        foreach (ISensor sensor in hardware.Sensors)
            SensorRemoved(sensor);

        foreach (IHardware subHardware in hardware.SubHardware)
            HardwareRemoved(subHardware);
    }

    private void HardwareAdded(IHardware hardware)
    {
        foreach (ISensor sensor in hardware.Sensors)
            SensorAdded(sensor);

        hardware.SensorAdded += SensorAdded;
        hardware.SensorRemoved += SensorRemoved;

        foreach (IHardware subHardware in hardware.SubHardware)
            HardwareAdded(subHardware);
    }

    private void SensorAdded(ISensor sensor)
    {
        if (_settings.GetValue(new Identifier(sensor.Identifier, "gadget").ToString(), false))
            Add(sensor);
    }

    private void SensorRemoved(ISensor sensor)
    {
        if (Contains(sensor))
            Remove(sensor, false);
    }

    public bool Contains(ISensor sensor)
    {
        return _sensors.Values.Any(list => list.Contains(sensor));
    }

    public void Add(ISensor sensor)
    {
        if (Contains(sensor))
            return;


        // get the right hardware
        IHardware hardware = sensor.Hardware;
        while (hardware.Parent != null)
            hardware = hardware.Parent;

        // get the sensor list associated with the hardware
        if (!_sensors.TryGetValue(hardware, out IList<ISensor> list))
        {
            list = new List<ISensor>();
            _sensors.Add(hardware, list);
        }

        // insert the sensor at the right position
        int i = 0;
        while (i < list.Count && (list[i].SensorType < sensor.SensorType || (list[i].SensorType == sensor.SensorType && list[i].Index < sensor.Index)))
            i++;

        list.Insert(i, sensor);

        _settings.SetValue(new Identifier(sensor.Identifier, "gadget").ToString(), true);
        Resize();
    }

    public void Remove(ISensor sensor)
    {
        Remove(sensor, true);
    }

    private void Remove(ISensor sensor, bool deleteConfig)
    {
        if (deleteConfig)
            _settings.Remove(new Identifier(sensor.Identifier, "gadget").ToString());

        foreach (KeyValuePair<IHardware, IList<ISensor>> keyValue in _sensors)
        {
            if (keyValue.Value.Contains(sensor))
            {
                keyValue.Value.Remove(sensor);
                if (keyValue.Value.Count == 0)
                {
                    _sensors.Remove(keyValue.Key);
                    break;
                }
            }
        }
        Resize();
    }

    public event EventHandler HideShowCommand;

    public void SendHideShowCommand()
    {
        HideShowCommand?.Invoke(this, null);
    }

    private Font CreateFont(float size, FontStyle style)
    {
        try
        {
            return new Font(SystemFonts.MessageBoxFont.FontFamily, size, style);
        }
        catch (ArgumentException)
        {
            // if the style is not supported, fall back to the original one
            return new Font(SystemFonts.MessageBoxFont.FontFamily, size,
                            SystemFonts.MessageBoxFont.Style);
        }
    }

    private void SetFontSize(float size)
    {
        _fontSize = size;
        _largeFont = CreateFont(_fontSize, FontStyle.Bold);
        _smallFont = CreateFont(_fontSize, FontStyle.Regular);

        double scaledFontSize = _fontSize * _scale;
        _iconSize = (int)Math.Round(1.5 * scaledFontSize);
        _hardwareLineHeight = (int)Math.Round(1.66 * scaledFontSize);
        _sensorLineHeight = (int)Math.Round(1.33 * scaledFontSize);
        _leftMargin = LeftBorder + (int)Math.Round(0.3 * scaledFontSize);
        _rightMargin = RightBorder + (int)Math.Round(0.3 * scaledFontSize);
        _topMargin = TopBorder;
        _bottomMargin = BottomBorder + (int)Math.Round(0.3 * scaledFontSize);
        _progressWidth = (int)Math.Round(5.3 * scaledFontSize);

        Resize((int)Math.Round(17.3 * scaledFontSize));
    }

    private void SetFontColor(Color color)
    {
        _textBrush?.Dispose();
        _textBrush = new SolidBrush(color);
    }

    private void Resize()
    {
        Resize(Size.Width);
    }

    private void Resize(int width)
    {
        int y = _topMargin;

        foreach (KeyValuePair<IHardware, IList<ISensor>> pair in _sensors)
        {
            if (_hardwareNames.Value)
            {
                if (y > _topMargin)
                    y += _hardwareLineHeight - _sensorLineHeight;
                y += _hardwareLineHeight;
            }
            y += pair.Value.Count * _sensorLineHeight;
        }

        if (_sensors.Count == 0)
            y += 4 * _sensorLineHeight + _hardwareLineHeight;

        y += _bottomMargin;
        Size = new Size(width, y);
    }

    private void DrawImageWidthBorder(Graphics g, int width, int height, Image back, int t, int b, int l, int r)
    {
        GraphicsUnit u = GraphicsUnit.Pixel;

        g.DrawImage(back, new Rectangle(0, 0, l, t), new Rectangle(0, 0, l, t), u);
        g.DrawImage(back, new Rectangle(l, 0, width - l - r, t), new Rectangle(l, 0, back.Width - l - r, t), u);
        g.DrawImage(back, new Rectangle(width - r, 0, r, t), new Rectangle(back.Width - r, 0, r, t), u);

        g.DrawImage(back, new Rectangle(0, t, l, height - t - b), new Rectangle(0, t, l, back.Height - t - b), u);
        g.DrawImage(back, new Rectangle(l, t, width - l - r, height - t - b), new Rectangle(l, t, back.Width - l - r, back.Height - t - b), u);
        g.DrawImage(back, new Rectangle(width - r, t, r, height - t - b), new Rectangle(back.Width - r, t, r, back.Height - t - b), u);

        g.DrawImage(back, new Rectangle(0, height - b, l, b), new Rectangle(0, back.Height - b, l, b), u);
        g.DrawImage(back, new Rectangle(l, height - b, width - l - r, b), new Rectangle(l, back.Height - b, back.Width - l - r, b), u);
        g.DrawImage(back, new Rectangle(width - r, height - b, r, b), new Rectangle(back.Width - r, back.Height - b, r, b), u);
    }

    private void DrawBackground(Graphics g)
    {
        int w = Size.Width;
        int h = Size.Height;

        if (w != _background.Width || h != _background.Height)
        {
            _background.Dispose();
            _background = new Bitmap(w, h, PixelFormat.Format32bppPArgb);

            using (Graphics graphics = Graphics.FromImage(_background))
            {
                DrawImageWidthBorder(graphics, w, h, _back, TopBorder, BottomBorder,LeftBorder, RightBorder);

                if (_fore != null)
                    DrawImageWidthBorder(graphics, w, h, _fore, TopBorder, BottomBorder, LeftBorder, RightBorder);

                if (_image != null)
                {
                    int width = w - LeftBorder - RightBorder;
                    int height = h - TopBorder - BottomBorder;
                    float xRatio = width / (float)_image.Width;
                    float yRatio = height / (float)_image.Height;
                    float destWidth, destHeight;
                    float xOffset, yOffset;

                    if (xRatio < yRatio)
                    {
                        destWidth = width;
                        destHeight = _image.Height * xRatio;
                        xOffset = 0;
                        yOffset = 0.5f * (height - destHeight);
                    }
                    else
                    {
                        destWidth = _image.Width * yRatio;
                        destHeight = height;
                        xOffset = 0.5f * (width - destWidth);
                        yOffset = 0;
                    }

                    graphics.DrawImage(_image, new RectangleF(LeftBorder + xOffset, TopBorder + yOffset, destWidth, destHeight));
                }
            }
        }

        g.DrawImageUnscaled(_background, 0, 0);
    }

    private void DrawProgress(Graphics g, float x, float y, float width, float height, float progress)
    {
        g.DrawImage(_barBack,
                    new RectangleF(x + width * progress, y, width * (1 - progress), height),
                    new RectangleF(_barBack.Width * progress, 0, (1 - progress) * _barBack.Width, _barBack.Height),
                    GraphicsUnit.Pixel);
        g.DrawImage(_barFore,
                    new RectangleF(x, y, width * progress, height),
                    new RectangleF(0, 0, progress * _barFore.Width, _barFore.Height), GraphicsUnit.Pixel);
    }

    protected override void OnPaint(PaintEventArgs e)
    {
        try
        {
            Graphics g = e.Graphics;
            int w = Size.Width;
    
            g.Clear(Color.Transparent);
            DrawBackground(g);
    
            int x;
            int y = _topMargin;
    
            if (_sensors.Count == 0)
            {
                x = LeftBorder + 1;
                g.DrawString("Right-click on a sensor in the main window and select " +
                             "\"Show in Gadget\" to show the sensor here.",
                             _smallFont, _textBrush,
                             new Rectangle(x, y - 1, w - RightBorder - x, 0));
            }
    
            foreach (KeyValuePair<IHardware, IList<ISensor>> pair in _sensors)
            {
                if (_hardwareNames.Value)
                {
                    if (y > _topMargin)
                        y += _hardwareLineHeight - _sensorLineHeight;

                    x = LeftBorder + 1;
                    g.DrawImage(HardwareTypeImage.Instance.GetImage(pair.Key.HardwareType), new Rectangle(x, y + 1, _iconSize, _iconSize));
                    x += _iconSize + 1;
                    g.DrawString(pair.Key.Name, _largeFont, _textBrush, new Rectangle(x, y - 1, w - RightBorder - x, 0), _stringFormat);
                    y += _hardwareLineHeight;
                }
    
                foreach (ISensor sensor in pair.Value)
                {
                    int remainingWidth;    
    
                    if ((sensor.SensorType != SensorType.Load &&
                         sensor.SensorType != SensorType.Control &&
                         sensor.SensorType != SensorType.Level &&
                         sensor.SensorType != SensorType.Humidity) || !sensor.Value.HasValue)
                    {
                        string formatted;
    
                        if (sensor.Value.HasValue)
                        {
                            string format = "";
                            switch (sensor.SensorType)
                            {
                                case SensorType.Voltage:
                                    format = "{0:F3} V";
                                    break;
                                case SensorType.Current:
                                    format = "{0:F3} A";
                                    break;
                                case SensorType.Clock:
                                    format = "{0:F0} MHz";
                                    break;
                                case SensorType.Frequency:
                                    format = "{0:F0} Hz";
                                    break;
                                case SensorType.Temperature:
                                    format = "{0:F1} °C";
                                    break;
                                case SensorType.Fan:
                                    format = "{0:F0} RPM";
                                    break;
                                case SensorType.Flow:
                                    format = "{0:F0} L/h";
                                    break;
                                case SensorType.Power:
                                    format = "{0:F1} W";
                                    break;
                                case SensorType.Data:
                                    format = "{0:F1} GB";
                                    break;
                                case SensorType.SmallData:
                                    format = "{0:F0} MB";
                                    break;
                                case SensorType.Factor:
                                    format = "{0:F3}";
                                    break;
                                case SensorType.TimeSpan:
                                    format = "{0:g}";
                                    break;
                                case SensorType.Timing:
                                    format = "{0:F3} ns";
                                    break;
                                case SensorType.Energy:
                                    format = "{0:F0} mWh";
                                    break;
                                case SensorType.Noise:
                                    format = "{0:F0} dBA";
                                    break;
                                case SensorType.Conductivity:
                                    format = "{0:F1} µS/cm";
                                    break;
                            }
    
                            if (sensor.SensorType == SensorType.Temperature && _unitManager.TemperatureUnit == TemperatureUnit.Fahrenheit)
                            {
                                formatted = $"{UnitManager.CelsiusToFahrenheit(sensor.Value):F1} °F";
                            }
                            else if (sensor.SensorType == SensorType.Throughput)
                            {
                                string result;
                                switch (sensor.Name)
                                {
                                    case "Connection Speed":
                                        {
                                            switch (sensor.Value)
                                            {
                                                case 100000000:
                                                    result = "100Mbps";
                                                    break;
                                                case 1000000000:
                                                    result = "1Gbps";
                                                    break;
                                                default:
                                                    {
                                                        if (sensor.Value < 1024)
                                                            result = $"{sensor.Value:F0} bps";
                                                        else if (sensor.Value < 1048576)
                                                            result = $"{sensor.Value / 1024:F1} Kbps";
                                                        else if (sensor.Value < 1073741824)
                                                            result = $"{sensor.Value / 1048576:F1} Mbps";
                                                        else
                                                            result = $"{sensor.Value / 1073741824:F1} Gbps";
                                                    }
                                                    break;
                                            }
                                        }
                                        break;
                                    default:
                                        {
                                            if (sensor.Value < 1048576)
                                                result = $"{sensor.Value / 1024:F1} KB/s";
                                            else
                                                result = $"{sensor.Value / 1048576:F1} MB/s";
                                        }
                                        break;
                                }
                                formatted = result;
                            }
                            else if (sensor.SensorType == SensorType.TimeSpan)
                            {
                                formatted = string.Format(format, TimeSpan.FromSeconds(sensor.Value.Value));
                            }
                            else
                            {
                                formatted = string.Format(format, sensor.Value);
                            }
                        }
                        else
                        {
                            formatted = "-";
                        }
    
                        g.DrawString(formatted, _smallFont, _textBrush, new RectangleF(-1, y - 1, w - _rightMargin + 3, 0), _alignRightStringFormat);
    
                        remainingWidth = w - (int)Math.Floor(g.MeasureString(formatted, _smallFont, w, StringFormat.GenericTypographic).Width) - _rightMargin;
                    }
                    else
                    {
                        DrawProgress(g, w - _progressWidth - _rightMargin, y + 0.35f * _sensorLineHeight, _progressWidth, 0.6f * _sensorLineHeight, 0.01f * sensor.Value.Value);
                        remainingWidth = w - _progressWidth - _rightMargin;
                    }
    
                    remainingWidth -= _leftMargin + 2;
                    if (remainingWidth > 0)
                    {
                        g.DrawString(sensor.Name, _smallFont, _textBrush, new RectangleF(_leftMargin - 1, y - 1, remainingWidth, 0), _trimStringFormat);
                    }
                    y += _sensorLineHeight;
                }
            }
        }
        catch (ArgumentException)
        {
            // #1425.
        }
    }

    private class HardwareComparer : IComparer<IHardware>
    {
        public int Compare(IHardware x, IHardware y)
        {
            switch (x)
            {
                case null when y == null:
                    return 0;
                case null:
                    return -1;
            }

            if (y == null)
                return 1;

            if (x.HardwareType != y.HardwareType)
                return x.HardwareType.CompareTo(y.HardwareType);

            return x.Identifier.CompareTo(y.Identifier);
        }
    }
}

```

`LibreHardwareMonitor/UI/SensorNode.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Drawing;
using System.Globalization;
using System.Text;
using LibreHardwareMonitor.Hardware;
using LibreHardwareMonitor.Utilities;

namespace LibreHardwareMonitor.UI;

public class SensorNode : Node
{
    private readonly PersistentSettings _settings;
    private readonly UnitManager _unitManager;
    private Color? _penColor;
    private bool _plot;

    public SensorNode(ISensor sensor, PersistentSettings settings, UnitManager unitManager)
    {
        Sensor = sensor;
        _settings = settings;
        _unitManager = unitManager;

        switch (sensor.SensorType)
        {
            case SensorType.Voltage:
                Format = "{0:F3} V";
                break;
            case SensorType.Current:
                Format = "{0:F3} A";
                break;
            case SensorType.Clock:
                Format = "{0:F1} MHz";
                break;
            case SensorType.Load:
                Format = "{0:F1} %";
                break;
            case SensorType.Temperature:
                Format = "{0:F1} °C";
                break;
            case SensorType.Fan:
                Format = "{0:F0} RPM";
                break;
            case SensorType.Flow:
                Format = "{0:F1} L/h";
                break;
            case SensorType.Control:
                Format = "{0:F1} %";
                break;
            case SensorType.Level:
                Format = "{0:F1} %";
                break;
            case SensorType.Power:
                Format = "{0:F1} W";
                break;
            case SensorType.Data:
                Format = "{0:F1} GB";
                break;
            case SensorType.SmallData:
                Format = "{0:F1} MB";
                break;
            case SensorType.Factor:
                Format = "{0:F3}";
                break;
            case SensorType.Frequency:
                Format = "{0:F1} Hz";
                break;
            case SensorType.Throughput:
                Format = "{0:F1} B/s";
                break;
            case SensorType.TimeSpan:
                Format = "{0:g}";
                break;
            case SensorType.Timing:
                Format = "{0:F3} ns";
                break;
            case SensorType.Energy:
                Format = "{0:F0} mWh";
                break;
            case SensorType.Noise:
                Format = "{0:F0} dBA";
                break;
            case SensorType.Conductivity:
                Format = "{0:F1} µS/cm";
                break;
            case SensorType.Humidity:
                Format = "{0:F0} %";
                break;
        }

        bool hidden = settings.GetValue(new Identifier(sensor.Identifier, "hidden").ToString(), sensor.IsDefaultHidden);
        base.IsVisible = !hidden;
        Plot = settings.GetValue(new Identifier(sensor.Identifier, "plot").ToString(), false);
        string id = new Identifier(sensor.Identifier, "penColor").ToString();

        if (settings.Contains(id))
            PenColor = settings.GetValue(id, Color.Black);
    }

    public event EventHandler PlotSelectionChanged;

    public string Format { get; set; } = "";

    public override bool IsVisible
    {
        get { return base.IsVisible; }
        set
        {
            base.IsVisible = value;
            _settings.SetValue(new Identifier(Sensor.Identifier, "hidden").ToString(), !value);
        }
    }

    public string Max
    {
        get { return ValueToString(Sensor.Max); }
    }

    public string Min
    {
        get { return ValueToString(Sensor.Min); }
    }

    public Color? PenColor
    {
        get { return _penColor; }
        set
        {
            _penColor = value;

            string id = new Identifier(Sensor.Identifier, "penColor").ToString();
            if (value.HasValue)
                _settings.SetValue(id, value.Value);
            else
                _settings.Remove(id);

            PlotSelectionChanged?.Invoke(this, null);
        }
    }

    public bool Plot
    {
        get { return _plot; }
        set
        {
            _plot = value;
            _settings.SetValue(new Identifier(Sensor.Identifier, "plot").ToString(), value);
            PlotSelectionChanged?.Invoke(this, null);
        }
    }

    public ISensor Sensor { get; }

    public override string Text
    {
        get { return Sensor.Name; }
        set { Sensor.Name = value; }
    }

    public override string ToolTip
    {
        get
        {
            StringBuilder stringBuilder = new();

            if (Sensor is ICriticalSensorLimits criticalSensorLimits)
                OptionallyAppendCriticalRange(stringBuilder, criticalSensorLimits.CriticalLowLimit, criticalSensorLimits.CriticalHighLimit, "critical");

            if (Sensor is ISensorLimits sensorLimits)
                OptionallyAppendCriticalRange(stringBuilder, sensorLimits.LowLimit, sensorLimits.HighLimit, "normal");

            return stringBuilder.ToString();
        }
    }

    public string Value
    {
        get { return ValueToString(Sensor.Value); }
    }

    public string ValueToString(float? value)
    {
        if (value.HasValue)
        {
            switch (Sensor.SensorType)
            {
                case SensorType.Temperature when _unitManager.TemperatureUnit == TemperatureUnit.Fahrenheit:
                    {
                        return $"{value * 1.8 + 32:F1} °F";
                    }
                case SensorType.Throughput:
                    {
                        string result;
                        switch (Sensor.Name)
                        {
                            case "Connection Speed":
                                {
                                    switch (value)
                                    {
                                        case 100000000:
                                            {
                                                result = "100Mbps";
                                                break;
                                            }
                                        case 1000000000:
                                            {
                                                result = "1Gbps";
                                                break;
                                            }
                                        default:
                                            {
                                                if (value < 1024)
                                                    result = $"{value:F0} bps";
                                                else if (value < 1048576)
                                                    result = $"{value / 1024:F1} Kbps";
                                                else if (value < 1073741824)
                                                    result = $"{value / 1048576:F1} Mbps";
                                                else
                                                    result = $"{value / 1073741824:F1} Gbps";
                                            }

                                            break;
                                    }

                                    break;
                                }
                            default:
                                {
                                    const int _1MB = 1048576;

                                    result = value < _1MB ? $"{value / 1024:F1} KB/s" : $"{value / _1MB:F1} MB/s";

                                    break;
                                }
                        }

                        return result;
                    }
                case SensorType.TimeSpan:
                    {
                        return string.Format(Format, TimeSpan.FromSeconds(value.Value));
                    }
                default:
                    {
                        return string.Format(Format, value);
                    }
            }
        }

        return "-";
    }

    private void OptionallyAppendCriticalRange(StringBuilder str, float? min, float? max, string kind)
    {
        if (min.HasValue)
        {
            str.AppendLine(max.HasValue
                               ? $"{CultureInfo.CurrentUICulture.TextInfo.ToTitleCase(kind)} range: {ValueToString(min)} to {ValueToString(max)}."
                               : $"Minimal {kind} value: {ValueToString(min)}.");
        }
        else if (max.HasValue)
        {
            str.AppendLine($"Maximal {kind} value: {ValueToString(max)}.");
        }
    }

    public override bool Equals(object obj)
    {
        if (obj == null)
            return false;

        if (!(obj is SensorNode s))
            return false;


        return (Sensor == s.Sensor);
    }

    public override int GetHashCode()
    {
        return Sensor.GetHashCode();
    }
}

```

`LibreHardwareMonitor/UI/SensorNotifyIcon.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Drawing.Imaging;
using System.Drawing.Text;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using LibreHardwareMonitor.Hardware;
using LibreHardwareMonitor.Utilities;

namespace LibreHardwareMonitor.UI;

public class SensorNotifyIcon : IDisposable
{
    private readonly UnitManager _unitManager;
    private readonly NotifyIconAdv _notifyIcon;
    private readonly Bitmap _bitmap;
    private readonly Graphics _graphics;
    private Color _color;
    private Color _darkColor;
    private Brush _brush;
    private Brush _darkBrush;
    private readonly Pen _pen;
    private readonly Font _font;
    private readonly Font _smallFont;

    public SensorNotifyIcon(SystemTray sensorSystemTray, ISensor sensor, PersistentSettings settings, UnitManager unitManager)
    {
        _unitManager = unitManager;
        Sensor = sensor;
        _notifyIcon = new NotifyIconAdv();

        Color defaultColor = Color.White;
        if (sensor.SensorType == SensorType.Load || sensor.SensorType == SensorType.Control || sensor.SensorType == SensorType.Level)
            defaultColor = Color.FromArgb(0xff, 0x70, 0x8c, 0xf1);

        Color = settings.GetValue(new Identifier(sensor.Identifier, "traycolor").ToString(), defaultColor);

        _pen = new Pen(Color.FromArgb(96, Color.Black));
        ContextMenuStrip contextMenuStrip = new ContextMenuStrip();
        ToolStripItem hideShowItem = new ToolStripMenuItem("Hide/Show");
        hideShowItem.Click += delegate
        {
            sensorSystemTray.SendHideShowCommand();
        };
        contextMenuStrip.Items.Add(hideShowItem);
        contextMenuStrip.Items.Add(new ToolStripSeparator());
        ToolStripItem removeItem = new ToolStripMenuItem("Remove Sensor");
        removeItem.Click += delegate
        {
            sensorSystemTray.Remove(Sensor);
        };
        contextMenuStrip.Items.Add(removeItem);
        ToolStripItem colorItem = new ToolStripMenuItem("Change Color...");
        colorItem.Click += delegate
        {
            ColorDialog dialog = new ColorDialog { Color = Color };
            if (dialog.ShowDialog() == DialogResult.OK)
            {
                Color = dialog.Color;
                settings.SetValue(new Identifier(sensor.Identifier,
                                                 "traycolor").ToString(), Color);
            }
        };
        contextMenuStrip.Items.Add(colorItem);
        contextMenuStrip.Items.Add(new ToolStripSeparator());
        ToolStripItem exitItem = new ToolStripMenuItem("Exit");
        exitItem.Click += delegate
        {
            sensorSystemTray.SendExitCommand();
        };
        contextMenuStrip.Items.Add(exitItem);
        _notifyIcon.ContextMenuStrip = contextMenuStrip;
        _notifyIcon.DoubleClick += delegate
        {
            sensorSystemTray.SendHideShowCommand();
        };

        // get the default dpi to create an icon with the correct size
        float dpiX, dpiY;
        using (Bitmap b = new Bitmap(1, 1, PixelFormat.Format32bppArgb))
        {
            dpiX = b.HorizontalResolution;
            dpiY = b.VerticalResolution;
        }

        // adjust the size of the icon to current dpi (default is 16x16 at 96 dpi)
        int width = (int)Math.Round(16 * dpiX / 96);
        int height = (int)Math.Round(16 * dpiY / 96);

        // make sure it does never get smaller than 16x16
        width = width < 16 ? 16 : width;
        height = height < 16 ? 16 : height;

        // adjust the font size to the icon size
        FontFamily family = SystemFonts.MessageBoxFont.FontFamily;
        float baseSize;
        switch (family.Name)
        {
            case "Segoe UI": baseSize = 12; break;
            case "Tahoma": baseSize = 11; break;
            default: baseSize = 12; break;
        }

        _font = new Font(family, baseSize * width / 16.0f, GraphicsUnit.Pixel);
        _smallFont = new Font(family, 0.75f * baseSize * width / 16.0f, GraphicsUnit.Pixel);

        _bitmap = new Bitmap(width, height, PixelFormat.Format32bppArgb);
        _graphics = Graphics.FromImage(_bitmap);
        if (Environment.OSVersion.Version.Major > 5)
        {
            _graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;
            _graphics.SmoothingMode = SmoothingMode.HighQuality;
        }
    }

    public ISensor Sensor { get; }

    public Color Color
    {
        get { return _color; }
        set
        {
            _color = value;
            _darkColor = Color.FromArgb(255, _color.R / 3, _color.G / 3, _color.B / 3);
            Brush brush = _brush;
            _brush = new SolidBrush(_color);
            brush?.Dispose();
            Brush darkBrush = _darkBrush;
            _darkBrush = new SolidBrush(_darkColor);
            darkBrush?.Dispose();
        }
    }

    public void Dispose()
    {
        Icon icon = _notifyIcon.Icon;
        _notifyIcon.Icon = null;
        icon?.Destroy();
        _notifyIcon.Dispose();

        _brush?.Dispose();
        _darkBrush?.Dispose();
        _pen.Dispose();
        _graphics.Dispose();
        _bitmap.Dispose();
        _font.Dispose();
        _smallFont.Dispose();
    }

    private string GetString()
    {
        if (!Sensor.Value.HasValue)
            return "-";

        switch (Sensor.SensorType)
        {
            case SensorType.Temperature:
                return _unitManager.TemperatureUnit == TemperatureUnit.Fahrenheit ? $"{UnitManager.CelsiusToFahrenheit(Sensor.Value):F0}" : $"{Sensor.Value:F0}";
            case SensorType.TimeSpan:
                return $"{TimeSpan.FromSeconds(Sensor.Value.Value):g}";
            case SensorType.Timing:
                return $"{Sensor.Value.Value:F3}";
            case SensorType.Clock:
            case SensorType.Fan:
            case SensorType.Flow:
                return $"{1e-3f * Sensor.Value:F1}";
            case SensorType.Voltage:
            case SensorType.Current:
            case SensorType.SmallData:
            case SensorType.Factor:
            case SensorType.Throughput:
            case SensorType.Conductivity:
                return $"{Sensor.Value:F1}";
            case SensorType.Control:
            case SensorType.Frequency:
            case SensorType.Level:
            case SensorType.Power:
            case SensorType.Data:
            case SensorType.Load:
            case SensorType.Energy:
            case SensorType.Noise:
            case SensorType.Humidity:
                return $"{Sensor.Value:F0}";
            default:
                return "-";
        }
    }

    private Icon CreateTransparentIcon()
    {
        string text = GetString();
        int count = 0;
        for (int i = 0; i < text.Length; i++)
            if ((text[i] >= '0' && text[i] <= '9') || text[i] == '-')
                count++;
        bool small = count > 2;

        _graphics.Clear(Color.Black);
        Rectangle bounds = new Rectangle(Point.Empty, _bitmap.Size);
        TextRenderer.DrawText(_graphics, text, small ? _smallFont : _font,
            bounds, Color.White, Color.Black, TextFormatFlags.HorizontalCenter | TextFormatFlags.VerticalCenter);
        
        BitmapData data = _bitmap.LockBits(
            new Rectangle(0, 0, _bitmap.Width, _bitmap.Height),
            ImageLockMode.ReadOnly, PixelFormat.Format32bppArgb);

        IntPtr Scan0 = data.Scan0;

        int numBytes = _bitmap.Width * _bitmap.Height * 4;
        byte[] bytes = new byte[numBytes];
        Marshal.Copy(Scan0, bytes, 0, numBytes);
        _bitmap.UnlockBits(data);

        byte red, green, blue;
        for (int i = 0; i < bytes.Length; i += 4)
        {
            blue = bytes[i];
            green = bytes[i + 1];
            red = bytes[i + 2];

            bytes[i] = _color.B;
            bytes[i + 1] = _color.G;
            bytes[i + 2] = _color.R;
            bytes[i + 3] = (byte)(0.3 * red + 0.59 * green + 0.11 * blue);
        }

        return IconFactory.Create(bytes, _bitmap.Width, _bitmap.Height,
            PixelFormat.Format32bppArgb);
    }

    private Icon CreatePercentageIcon()
    {
        try
        {
            _graphics.Clear(Color.Transparent);
        }
        catch (ArgumentException)
        {
            _graphics.Clear(Color.Black);
        }
        _graphics.FillRectangle(_darkBrush, 0.5f, -0.5f, _bitmap.Width - 2, _bitmap.Height);
        float value = Sensor.Value.GetValueOrDefault();
        float y = (float)(_bitmap.Height * 0.01f) * (100 - value);
        _graphics.FillRectangle(_brush, 0.5f, -0.5f + y, _bitmap.Width - 2, _bitmap.Height - y);
        _graphics.DrawRectangle(_pen, 1, 0, _bitmap.Width - 3, _bitmap.Height - 1);

        return IconFactory.Create(_bitmap);
    }

    public void Update()
    {
        Icon icon = _notifyIcon.Icon;

        switch (Sensor.SensorType)
        {
            case SensorType.Load:
            case SensorType.Control:
            case SensorType.Level:
                _notifyIcon.Icon = CreatePercentageIcon();
                break;
            default:
                _notifyIcon.Icon = CreateTransparentIcon();
                break;
        }

        icon?.Destroy();

        string format = "";
        switch (Sensor.SensorType)
        {
            case SensorType.Voltage: format = "\n{0}: {1:F2} V"; break;
            case SensorType.Current: format = "\n{0}: {1:F2} A"; break;
            case SensorType.Clock: format = "\n{0}: {1:F0} MHz"; break;
            case SensorType.Load: format = "\n{0}: {1:F1} %"; break;
            case SensorType.Temperature: format = "\n{0}: {1:F1} °C"; break;
            case SensorType.Fan: format = "\n{0}: {1:F0} RPM"; break;
            case SensorType.Flow: format = "\n{0}: {1:F0} L/h"; break;
            case SensorType.Control: format = "\n{0}: {1:F1} %"; break;
            case SensorType.Level: format = "\n{0}: {1:F1} %"; break;
            case SensorType.Power: format = "\n{0}: {1:F0} W"; break;
            case SensorType.Data: format = "\n{0}: {1:F0} GB"; break;
            case SensorType.Factor: format = "\n{0}: {1:F3} GB"; break;
            case SensorType.Energy: format = "\n{0}: {0:F0} mWh"; break;
            case SensorType.Noise: format = "\n{0}: {0:F0} dBA"; break;
            case SensorType.Conductivity: format = "\n{0}: {0:F1} µS/cm"; break;
            case SensorType.Humidity: format = "\n{0}: {0:F0} %"; break;
            case SensorType.Timing: format = "\n{0}: {0:F3} ns"; break;
        }

        string formattedValue = string.Format(format, Sensor.Name, Sensor.Value);

        if (Sensor.SensorType == SensorType.Temperature && _unitManager.TemperatureUnit == TemperatureUnit.Fahrenheit)
        {
            format = "\n{0}: {1:F1} °F";
            formattedValue = string.Format(format, Sensor.Name, UnitManager.CelsiusToFahrenheit(Sensor.Value));
        }

        string hardwareName = Sensor.Hardware.Name;
        hardwareName = hardwareName.Substring(0, Math.Min(63 - formattedValue.Length, hardwareName.Length));
        string text = hardwareName + formattedValue;
        if (text.Length > 63)
            text = null;

        _notifyIcon.Text = text;
        _notifyIcon.Visible = true;
    }
}

```

`LibreHardwareMonitor/UI/ShowDesktop.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Runtime.InteropServices;
using System.Windows.Forms;

namespace LibreHardwareMonitor.UI;

public class ShowDesktop : IDisposable
{
    private readonly NativeWindow _referenceWindow;
    private readonly string _referenceWindowCaption = "LibreHardwareMonitorShowDesktopReferenceWindow";
    private readonly System.Threading.Timer _timer;
    private bool _showDesktop;

    /// <summary>
    /// Prevents a default instance of the <see cref="ShowDesktop" /> class from being created.
    /// </summary>
    private ShowDesktop()
    {
        // Create a reference window to detect show desktop
        _referenceWindow = new NativeWindow();

        CreateParams cp = new CreateParams { ExStyle = GadgetWindow.WS_EX_TOOLWINDOW, Caption = _referenceWindowCaption };
        _referenceWindow.CreateHandle(cp);
        NativeMethods.SetWindowPos(_referenceWindow.Handle,
                                   GadgetWindow.HWND_BOTTOM,
                                   0,
                                   0,
                                   0,
                                   0,
                                   GadgetWindow.SWP_NOMOVE |
                                   GadgetWindow.SWP_NOSIZE |
                                   GadgetWindow.SWP_NOACTIVATE |
                                   GadgetWindow.SWP_NOSENDCHANGING);

        // start a repeated timer to detect "Show Desktop" events
        _timer = new System.Threading.Timer(OnTimer, null, System.Threading.Timeout.Infinite, System.Threading.Timeout.Infinite);
    }

    public delegate void ShowDesktopChangedEventHandler(bool showDesktop);

    private event ShowDesktopChangedEventHandler ShowDesktopChangedEvent;

    // notify when the "show desktop" mode is changed
    public event ShowDesktopChangedEventHandler ShowDesktopChanged
    {
        add
        {
            // start the monitor timer when someone is listening
            if (ShowDesktopChangedEvent == null)
                StartTimer();

            ShowDesktopChangedEvent += value;
        }
        remove
        {
            ShowDesktopChangedEvent -= value;
            // stop the monitor timer if nobody is interested
            if (ShowDesktopChangedEvent == null)
                StopTimer();
        }
    }

    public static ShowDesktop Instance { get; } = new ShowDesktop();

    /// <inheritdoc />
    public void Dispose()
    {
        _timer?.Dispose();
        _referenceWindow.ReleaseHandle();
    }

    private void StartTimer()
    {
        _timer.Change(0, 200);
    }

    private void StopTimer()
    {
        _timer.Change(System.Threading.Timeout.Infinite, System.Threading.Timeout.Infinite);
    }

    // the desktop worker window (if available) can hide the reference window
    private IntPtr GetDesktopWorkerWindow()
    {
        IntPtr shellWindow = NativeMethods.GetShellWindow();
        if (shellWindow == IntPtr.Zero)
            return IntPtr.Zero;


        NativeMethods.GetWindowThreadProcessId(shellWindow, out int shellId);

        IntPtr workerWindow = IntPtr.Zero;
        while ((workerWindow = NativeMethods.FindWindowEx(IntPtr.Zero, workerWindow, "WorkerW", null)) != IntPtr.Zero)
        {
            NativeMethods.GetWindowThreadProcessId(workerWindow, out int workerId);
            if (workerId == shellId)
            {
                IntPtr window = NativeMethods.FindWindowEx(workerWindow, IntPtr.Zero, "SHELLDLL_DefView", null);
                if (window != IntPtr.Zero)
                {
                    IntPtr desktopWindow = NativeMethods.FindWindowEx(window, IntPtr.Zero, "SysListView32", null);
                    if (desktopWindow != IntPtr.Zero)
                        return workerWindow;
                }
            }
        }

        return IntPtr.Zero;
    }

    private void OnTimer(object state)
    {
        bool showDesktopDetected;

        IntPtr workerWindow = GetDesktopWorkerWindow();
        if (workerWindow != IntPtr.Zero)
        {
            // search if the reference window is behind the worker window
            IntPtr reference = NativeMethods.FindWindowEx(IntPtr.Zero, workerWindow, null, _referenceWindowCaption);
            showDesktopDetected = reference != IntPtr.Zero;
        }
        else
        {
            // if there is no worker window, then nothing can hide the reference
            showDesktopDetected = false;
        }

        if (_showDesktop != showDesktopDetected)
        {
            _showDesktop = showDesktopDetected;
            ShowDesktopChangedEvent?.Invoke(_showDesktop);
        }
    }

    private static class NativeMethods
    {
        private const string USER = "user32.dll";

        [DllImport(USER, CallingConvention = CallingConvention.Winapi)]
        public static extern bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int X, int Y, int cx, int cy, uint uFlags);

        [DllImport(USER, CallingConvention = CallingConvention.Winapi)]
        public static extern IntPtr FindWindowEx(IntPtr hwndParent, IntPtr hwndChildAfter, string lpszClass, string lpszWindow);

        [DllImport(USER, CallingConvention = CallingConvention.Winapi)]
        public static extern IntPtr GetShellWindow();

        [DllImport(USER, CallingConvention = CallingConvention.Winapi)]
        public static extern int GetWindowThreadProcessId(IntPtr hWnd, out int processId);
    }
}
```

`LibreHardwareMonitor/UI/SplitContainerAdv.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Drawing;
using System.Windows.Forms;
using LibreHardwareMonitor.UI.Themes;

namespace LibreHardwareMonitor.UI;

public class SplitContainerAdv : SplitContainer
{
    private int _delta;
    private bool _mouseOver;

    public SplitContainerAdv()
    {
        SetStyle(ControlStyles.ResizeRedraw, true);
        SetStyle(ControlStyles.AllPaintingInWmPaint, true);
        SetStyle(ControlStyles.UserPaint, true);
        SetStyle(ControlStyles.OptimizedDoubleBuffer, true);
        SetStyle(ControlStyles.ContainerControl, true);
        UpdateStyles();
    }

    protected override void OnPaint(PaintEventArgs e)
    {
        base.OnPaint(e);
        Graphics g = e.Graphics;
        Rectangle r = SplitterRectangle;

        using (SolidBrush brush = new SolidBrush(_mouseOver ? Theme.Current.SplitterHoverColor : Theme.Current.SplitterColor))
            g.FillRectangle(brush, r);
    }

    protected override void OnKeyDown(KeyEventArgs e)
    {
        if (!IsSplitterFixed)
        {
            switch (e.KeyData)
            {
                case Keys.Right:
                case Keys.Down:
                    SplitterDistance += SplitterIncrement;
                    break;
                case Keys.Left:
                case Keys.Up:
                    SplitterDistance -= SplitterIncrement;
                    break;
            }

            Invalidate();
        }
    }

    protected override void OnMouseDown(MouseEventArgs e)
    {
        if (Orientation == Orientation.Vertical)
        {
            _delta = SplitterDistance - e.X;
            Cursor.Current = Cursors.VSplit;
        }
        else
        {
            _delta = SplitterDistance - e.Y;
            Cursor.Current = Cursors.HSplit;
        }
        IsSplitterFixed = true;
    }

    protected override void OnMouseEnter(EventArgs e)
    {
        base.OnMouseEnter(e);
        _mouseOver = true;
        Invalidate();
    }

    protected override void OnMouseMove(MouseEventArgs e)
    {
        if (IsSplitterFixed)
        {
            if (e.Button == MouseButtons.Left)
            {
                if (Orientation == Orientation.Vertical)
                {
                    if (e.X > 0 && e.X < Width)
                        SplitterDistance = e.X + _delta < 0 ? 0 : e.X + _delta;
                }
                else
                {
                    if (e.Y > 0 && e.Y < Height)
                        SplitterDistance = e.Y + _delta < 0 ? 0 : e.Y + _delta;
                }
            }
            else
            {
                IsSplitterFixed = false;
            }
            Invalidate();
        }
        else
        {
            if (SplitterRectangle.Contains(e.Location))
                Cursor = Orientation == Orientation.Vertical ? Cursors.VSplit : Cursors.HSplit;
        }
    }

    protected override void OnMouseLeave(EventArgs e)
    {
        base.OnMouseLeave(e);
        Cursor = Cursors.Default;
        _mouseOver = false;
        Invalidate();
    }

    protected override void OnMouseUp(MouseEventArgs e)
    {
        _delta = 0;
        IsSplitterFixed = false;
        Cursor.Current = Cursors.Default;
    }
}

```

`LibreHardwareMonitor/UI/StartupManager.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.IO;
using System.Linq;
using System.Security;
using System.Security.Principal;
using System.Windows.Forms;
using Microsoft.Win32;
using Microsoft.Win32.TaskScheduler;
using Action = Microsoft.Win32.TaskScheduler.Action;

namespace LibreHardwareMonitor.UI;

public class StartupManager
{
    private const string RegistryPath = @"Software\Microsoft\Windows\CurrentVersion\Run";
    private bool _startup;

    public StartupManager()
    {
        if (Environment.OSVersion.Platform >= PlatformID.Unix)
        {
            IsAvailable = false;
            return;
        }

        if (IsAdministrator() && TaskService.Instance.Connected)
        {
            IsAvailable = true;

            Task task = GetTask();
            if (task != null)
            {
                foreach (Action action in task.Definition.Actions)
                {
                    if (action.ActionType == TaskActionType.Execute && action is ExecAction execAction)
                    {
                        if (execAction.Path.Equals(Application.ExecutablePath, StringComparison.OrdinalIgnoreCase))
                            _startup = true;
                    }
                }
            }
        }
        else
        {
            try
            {
                using (RegistryKey registryKey = Registry.CurrentUser.OpenSubKey(RegistryPath))
                {
                    string value = (string)registryKey?.GetValue(nameof(LibreHardwareMonitor));

                    if (value != null)
                        _startup = value == Application.ExecutablePath;
                }

                IsAvailable = true;
            }
            catch (SecurityException)
            {
                IsAvailable = false;
            }
        }
    }

    public bool IsAvailable { get; }

    public bool Startup
    {
        get { return _startup; }
        set
        {
            if (_startup != value)
            {
                if (IsAvailable)
                {
                    if (TaskService.Instance.Connected)
                    {
                        if (value)
                            CreateTask();
                        else
                            DeleteTask();

                        _startup = value;
                    }
                    else
                    {
                        try
                        {
                            if (value)
                                CreateRegistryKey();
                            else
                                DeleteRegistryKey();

                            _startup = value;
                        }
                        catch (UnauthorizedAccessException)
                        {
                            throw new InvalidOperationException();
                        }
                    }
                }
                else
                {
                    throw new InvalidOperationException();
                }
            }
        }
    }

    private static bool IsAdministrator()
    {
        try
        {
            WindowsIdentity identity = WindowsIdentity.GetCurrent();
            WindowsPrincipal principal = new WindowsPrincipal(identity);

            return principal.IsInRole(WindowsBuiltInRole.Administrator);
        }
        catch
        {
            return false;
        }
    }

    private static Task GetTask()
    {
        try
        {
            return TaskService.Instance.AllTasks.FirstOrDefault(x => x.Name.Equals(nameof(LibreHardwareMonitor), StringComparison.OrdinalIgnoreCase));
        }
        catch
        {
            return null;
        }
    }

    private void CreateTask()
    {
        TaskDefinition taskDefinition = TaskService.Instance.NewTask();
        taskDefinition.RegistrationInfo.Description = "Starts LibreHardwareMonitor on Windows startup.";

        taskDefinition.Triggers.Add(new LogonTrigger());

        taskDefinition.Settings.StartWhenAvailable = true;
        taskDefinition.Settings.DisallowStartIfOnBatteries = false;
        taskDefinition.Settings.StopIfGoingOnBatteries = false;
        taskDefinition.Settings.ExecutionTimeLimit = TimeSpan.Zero;
        taskDefinition.Settings.AllowHardTerminate = false;

        taskDefinition.Principal.RunLevel = TaskRunLevel.Highest;
        taskDefinition.Principal.LogonType = TaskLogonType.InteractiveToken;

        taskDefinition.Actions.Add(new ExecAction(Application.ExecutablePath, "", Path.GetDirectoryName(Application.ExecutablePath)));

        TaskService.Instance.RootFolder.RegisterTaskDefinition(nameof(LibreHardwareMonitor), taskDefinition);
    }

    private static void DeleteTask()
    {
        Task task = GetTask();
        task?.Folder.DeleteTask(task.Name, false);
    }

    private static void CreateRegistryKey()
    {
        RegistryKey registryKey = Registry.CurrentUser.CreateSubKey(RegistryPath);
        registryKey?.SetValue(nameof(LibreHardwareMonitor), Application.ExecutablePath);
    }

    private static void DeleteRegistryKey()
    {
        RegistryKey registryKey = Registry.CurrentUser.CreateSubKey(RegistryPath);
        registryKey?.DeleteValue(nameof(LibreHardwareMonitor));
    }
}
```

`LibreHardwareMonitor/UI/SystemTray.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Windows.Forms;
using LibreHardwareMonitor.Hardware;
using LibreHardwareMonitor.Utilities;

namespace LibreHardwareMonitor.UI;

public class SystemTray : IDisposable
{
    private IComputer _computer;
    private readonly PersistentSettings _settings;
    private readonly UnitManager _unitManager;
    private readonly List<SensorNotifyIcon> _sensorList = new List<SensorNotifyIcon>();
    private bool _mainIconEnabled;
    private readonly NotifyIconAdv _mainIcon;

    public SystemTray(IComputer computer, PersistentSettings settings, UnitManager unitManager)
    {
        _computer = computer;
        _settings = settings;
        _unitManager = unitManager;
        computer.HardwareAdded += HardwareAdded;
        computer.HardwareRemoved += HardwareRemoved;

        _mainIcon = new NotifyIconAdv();

        ContextMenuStrip contextMenuStrip = new ContextMenuStrip();
        ToolStripItem hideShowItem = new ToolStripMenuItem("Hide/Show");
        hideShowItem.Click += delegate
        {
            SendHideShowCommand();
        };
        contextMenuStrip.Items.Add(hideShowItem);
        contextMenuStrip.Items.Add(new ToolStripSeparator());
        ToolStripItem exitItem = new ToolStripMenuItem("Exit");
        exitItem.Click += delegate
        {
            SendExitCommand();
        };
        contextMenuStrip.Items.Add(exitItem);
        _mainIcon.ContextMenuStrip = contextMenuStrip;
        _mainIcon.DoubleClick += delegate
        {
            SendHideShowCommand();
        };
        _mainIcon.Icon = EmbeddedResources.GetIcon("smallicon.ico");
        _mainIcon.Text = "Libre Hardware Monitor";
    }

    private void HardwareRemoved(IHardware hardware)
    {
        hardware.SensorAdded -= SensorAdded;
        hardware.SensorRemoved -= SensorRemoved;

        foreach (ISensor sensor in hardware.Sensors)
            SensorRemoved(sensor);

        foreach (IHardware subHardware in hardware.SubHardware)
            HardwareRemoved(subHardware);
    }

    private void HardwareAdded(IHardware hardware)
    {
        foreach (ISensor sensor in hardware.Sensors)
            SensorAdded(sensor);

        hardware.SensorAdded += SensorAdded;
        hardware.SensorRemoved += SensorRemoved;

        foreach (IHardware subHardware in hardware.SubHardware)
            HardwareAdded(subHardware);
    }

    private void SensorAdded(ISensor sensor)
    {
        if (_settings.GetValue(new Identifier(sensor.Identifier, "tray").ToString(), false))
            Add(sensor, false);
    }

    private void SensorRemoved(ISensor sensor)
    {
        if (Contains(sensor))
            Remove(sensor, false);
    }

    public void Dispose()
    {
        foreach (SensorNotifyIcon icon in _sensorList)
            icon.Dispose();
        _mainIcon.Dispose();
    }

    public void Redraw()
    {
        foreach (SensorNotifyIcon icon in _sensorList)
            icon.Update();
    }

    public bool Contains(ISensor sensor)
    {
        foreach (SensorNotifyIcon icon in _sensorList)
            if (icon.Sensor == sensor)
                return true;
        return false;
    }

    public void Add(ISensor sensor, bool balloonTip)
    {
        if (Contains(sensor))
            return;


        _sensorList.Add(new SensorNotifyIcon(this, sensor, _settings, _unitManager));
        UpdateMainIconVisibility();
        _settings.SetValue(new Identifier(sensor.Identifier, "tray").ToString(), true);
    }

    public void Remove(ISensor sensor)
    {
        Remove(sensor, true);
    }

    private void Remove(ISensor sensor, bool deleteConfig)
    {
        if (deleteConfig)
        {
            _settings.Remove(new Identifier(sensor.Identifier, "tray").ToString());
            _settings.Remove(new Identifier(sensor.Identifier, "traycolor").ToString());
        }
        SensorNotifyIcon instance = null;
        foreach (SensorNotifyIcon icon in _sensorList)
        {
            if (icon.Sensor == sensor)
                instance = icon;
        }
        if (instance != null)
        {
            _sensorList.Remove(instance);
            UpdateMainIconVisibility();
            instance.Dispose();
        }
    }

    public event EventHandler HideShowCommand;

    public void SendHideShowCommand()
    {
        HideShowCommand?.Invoke(this, null);
    }

    public event EventHandler ExitCommand;

    public void SendExitCommand()
    {
        ExitCommand?.Invoke(this, null);
    }

    private void UpdateMainIconVisibility()
    {
        if (_mainIconEnabled)
            _mainIcon.Visible = _sensorList.Count == 0;
        else
            _mainIcon.Visible = false;
    }

    public bool IsMainIconEnabled
    {
        get { return _mainIconEnabled; }
        set
        {
            if (_mainIconEnabled != value)
            {
                _mainIconEnabled = value;
                UpdateMainIconVisibility();
            }
        }
    }
}
```

`LibreHardwareMonitor/UI/Theme.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using Aga.Controls.Tree;
using Microsoft.Win32;

namespace LibreHardwareMonitor.UI.Themes
{
    public abstract class Theme
    {
        private static Theme _current = new LightTheme();
        public static Theme Current
        {
            get { return _current; }
            set
            {
                _current = value;
                foreach (Form form in Application.OpenForms)
                {
                    _current.Apply(form);
                }

                Init();
            }
        }

        private static void Init()
        {
            TreeViewAdv.CustomPlusMinusRenderFunc = (g, rect, isExpanded) =>
            {
                int x = rect.Left;
                int y = rect.Top + 5;
                int size = 8;
                using (Brush brush = new SolidBrush(Current.BackgroundColor))
                {
                    g.FillRectangle(brush, x - 1, y - 1, size + 4, size + 4);
                }
                using (Pen pen = new Pen(Current.TreeOutlineColor))
                {

                    g.DrawRectangle(pen, x, y, size, size);
                    g.DrawLine(pen, x + 2, y + (size / 2), x + size - 2, y + (size / 2));
                    if (!isExpanded)
                    {
                        g.DrawLine(pen, x + (size / 2), y + 2, x + (size / 2), y + size - 2);
                    }
                }
            };

            TreeViewAdv.CustomCheckRenderFunc = (g, rect, isChecked) =>
            {
                int x = rect.Left;
                int y = rect.Top + 1;
                int size = 12;
                using (Brush brush = new SolidBrush(Current.BackgroundColor))
                {
                    g.FillRectangle(brush, x - 1, y - 1, 12, 12);
                }
                using (Pen pen = new Pen(Current.TreeOutlineColor))
                {
                    g.DrawRectangle(pen, x, y, size, size);
                    if (isChecked)
                    {
                        x += 3;
                        y += 3;
                        g.DrawLine(pen, x, y + 3, x + 2, y + 5);
                        g.DrawLine(pen, x + 2, y + 5, x + 6, y + 1);
                        g.DrawLine(pen, x, y + 4, x + 2, y + 6);
                        g.DrawLine(pen, x + 2, y + 6, x + 6, y + 2);
                    }
                }
            };

            TreeViewAdv.CustomColumnBackgroundRenderFunc = (g, rect, isPressed, isHot) =>
            {
                using (Brush brush = new SolidBrush(Current.TreeBackgroundColor))
                {
                    g.FillRectangle(brush, rect);
                }
                using (Pen pen = new Pen(Current.TreeRowSepearatorColor))
                {
                    g.DrawLine(pen, rect.Left, rect.Top, rect.Right, rect.Top);
                    g.DrawLine(pen, rect.Left, rect.Top + 1, rect.Right, rect.Top + 1);
                }
            };

            TreeViewAdv.CustomColumnTextRenderFunc = (g, rect, font, text) =>
            {
                TextRenderer.DrawText(g, text, font, rect, Current.TreeTextColor, TextFormatFlags.Left);
            };

            TreeViewAdv.CustomHorizontalLinePen = new Pen(Current.TreeRowSepearatorColor);
            TreeViewAdv.CustomSelectedRowBrush = new SolidBrush(Current.TreeSelectedBackgroundColor);
            TreeViewAdv.CustomSelectedTextColor = Current.TreeSelectedTextColor;
        }

        private static List<Theme> _all;
        public static List<Theme> All
        {
            get
            {
                if (_all == null)
                {
                    _all = new List<Theme>();
                    foreach (Type type in typeof(Theme).Assembly.GetTypes())
                    {
                        if (type != typeof(Theme) && typeof(Theme).IsAssignableFrom(type))
                        {
                            _all.Add((Theme)type.GetConstructor(new Type[] { }).Invoke(new object[] { }));
                        }
                    }
                }
                return _all.OrderBy(x => x.DisplayName).ToList();
            }
        }

        public static bool SupportsAutoThemeSwitching()
        {
            if (Software.OperatingSystem.IsUnix)
            {
                return false;
            }

            if (Registry.GetValue(@"HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Themes\Personalize", "AppsUseLightTheme", -1) is int useLightTheme)
            {
                return useLightTheme != -1;
            }
            return false;
        }

        public static void SetAutoTheme()
        {
            if (Software.OperatingSystem.IsUnix)
            {
                return;
            }

            if (Registry.GetValue(@"HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Themes\Personalize", "AppsUseLightTheme", 1) is int useLightTheme)
            {
                if (useLightTheme > 0)
                {
                    Current = new LightTheme();
                }
                else
                {
                    Current = new DarkTheme();
                }
            }
            else
            {
                // Fallback incase registry fails
                Current = new LightTheme();
            }
        }

        public Theme(string id, string displayName)
        {
            Id = id;
            DisplayName = displayName;
        }

        public string Id { get; }
        public string DisplayName { get; }
        public abstract Color BackgroundColor { get; }
        public abstract Color ForegroundColor { get; }
        public abstract Color HyperlinkColor { get; }
        public abstract Color LineColor { get; }
        public abstract Color StrongLineColor { get; }
        public abstract Color SelectedBackgroundColor { get; }
        public abstract Color SelectedForegroundColor { get; }

        // button
        public virtual Color ButtonBackgroundColor => BackgroundColor;
        public virtual Color ButtonBorderColor => ForegroundColor;
        public virtual Color ButtonHoverBackgroundColor => SelectedBackgroundColor;
        public virtual Color ButtonPressedBackgroundColor => LineColor;
        public virtual Color ButtonTextColor => ForegroundColor;

        // menu
        public virtual Color MenuBackgroundColor => BackgroundColor;
        public virtual Color MenuBorderColor => StrongLineColor;
        public virtual Color MenuForegroundColor => ForegroundColor;
        public virtual Color MenuSelectedBackgroundColor => SelectedBackgroundColor;
        public virtual Color MenuSelectedForegroundColor => SelectedForegroundColor;

        // plot
        public virtual Color PlotBackgroundColor => BackgroundColor;
        public virtual Color PlotBorderColor => ForegroundColor;
        public abstract Color[] PlotColorPalette { get; }
        public abstract Color PlotGridMajorColor { get; }
        public abstract Color PlotGridMinorColor { get; }
        public virtual Color PlotTextColor => ForegroundColor;

        // scrollbar
        public virtual Color ScrollbarBackground => BackgroundColor;
        public virtual Color ScrollbarTrack => StrongLineColor;

        // splitter
        public virtual Color SplitterColor => BackgroundColor;
        public virtual Color SplitterHoverColor => SelectedBackgroundColor;

        // tree
        public virtual Color TreeBackgroundColor => BackgroundColor;
        public virtual Color TreeOutlineColor => ForegroundColor;
        public virtual Color TreeSelectedBackgroundColor => SelectedBackgroundColor;
        public virtual Color TreeTextColor => ForegroundColor;
        public virtual Color TreeSelectedTextColor => SelectedForegroundColor;
        public virtual Color TreeRowSepearatorColor => LineColor;

        // window
        public virtual Color WindowTitlebarBackgroundColor => BackgroundColor;
        public abstract bool WindowTitlebarFallbackToImmersiveDarkMode { get; }
        public virtual Color WindowTitlebarForegroundColor => ForegroundColor;

        public void Apply(Form form)
        {
            if (IsWindows10OrGreater(22000))
            {
                // Windows 11, Set the titlebar color based on theme
                int color = ColorTranslator.ToWin32(WindowTitlebarBackgroundColor);
                DwmSetWindowAttribute(form.Handle, DWMWA_CAPTION_COLOR, ref color, sizeof(int));
                color = ColorTranslator.ToWin32(WindowTitlebarForegroundColor);
                DwmSetWindowAttribute(form.Handle, DWMWA_TEXT_COLOR, ref color, sizeof(int));
            }
            else if (IsWindows10OrGreater(17763))
            {
                // Windows 10, fallback to using "Immersive Dark Mode" instead
                var attribute = DWMWA_USE_IMMERSIVE_DARK_MODE_BEFORE_20H1;
                if (IsWindows10OrGreater(18985))
                {
                    // Windows 10 20H1 or later
                    attribute = DWMWA_USE_IMMERSIVE_DARK_MODE;
                }
                int useImmersiveDarkMode = WindowTitlebarFallbackToImmersiveDarkMode ? 1 : 0;
                DwmSetWindowAttribute(form.Handle, (int)attribute, ref useImmersiveDarkMode, sizeof(int));
            }
            form.BackColor = BackgroundColor;
            foreach (Control control in form.Controls)
            {
                Apply(control);
            }
        }

        public void Apply(Control control)
        {
            if (control is Button button)
            {
                button.ForeColor = ButtonTextColor;
                button.FlatStyle = FlatStyle.Flat;
                button.FlatAppearance.BorderColor = ButtonBorderColor;
                button.FlatAppearance.MouseOverBackColor = ButtonHoverBackgroundColor;
                button.FlatAppearance.MouseDownBackColor = ButtonPressedBackgroundColor;
            }
            else if (control is LinkLabel linkLabel)
            {
                linkLabel.LinkColor = HyperlinkColor;
            }
            else if (control is PlotPanel plotPanel)
            {
                plotPanel.ApplyTheme();
            }
            else if (control is TreeViewAdv treeView)
            {
                treeView.BackColor = TreeBackgroundColor;
                treeView.ForeColor = TreeTextColor;
                treeView.LineColor = TreeOutlineColor;
            }
            else
            {
                control.BackColor = BackgroundColor;
                control.ForeColor = ForegroundColor;
            }

            foreach (Control child in control.Controls)
            {
                Apply(child);
            }
        }

        [DllImport("dwmapi.dll")]
        private static extern int DwmSetWindowAttribute(IntPtr hwnd, int attr, ref int attrValue, int attrSize);

        private const int DWMWA_USE_IMMERSIVE_DARK_MODE_BEFORE_20H1 = 19;
        private const int DWMWA_USE_IMMERSIVE_DARK_MODE = 20;
        private const int DWMWA_BORDER_COLOR = 34;
        private const int DWMWA_CAPTION_COLOR = 35;
        private const int DWMWA_TEXT_COLOR = 36;

        private static bool IsWindows10OrGreater(int build = -1)
        {
            return !Software.OperatingSystem.IsUnix && Environment.OSVersion.Version.Major >= 10 && Environment.OSVersion.Version.Build >= build;
        }
    }
}

```

`LibreHardwareMonitor/UI/Themes/BlackTheme.cs`:

```cs
using System.Drawing;
using System.Linq;

namespace LibreHardwareMonitor.UI.Themes
{
    public class BlackTheme : LightTheme
    {
        private readonly Color[] _plotColorPalette;
        public override Color ForegroundColor => Color.FromArgb(218, 218, 218);
        public override Color BackgroundColor => Color.FromArgb(0, 0, 0);
        public override Color HyperlinkColor => Color.FromArgb(144, 220, 232);
        public override Color SelectedForegroundColor => ForegroundColor;
        public override Color SelectedBackgroundColor => ColorTranslator.FromHtml("#090A17");
        public override Color LineColor => ColorTranslator.FromHtml("#070A12");
        public override Color StrongLineColor => ColorTranslator.FromHtml("#091217");
        public override Color[] PlotColorPalette => _plotColorPalette;
        public override Color PlotGridMajorColor => Color.FromArgb(73, 73, 73);
        public override Color PlotGridMinorColor => Color.FromArgb(33, 33, 33);
        public override bool WindowTitlebarFallbackToImmersiveDarkMode => true;

        public BlackTheme() : base("black", "Black")
        {
            string[] colors = {
                "#FF2525",
                "#1200FF",
                "#00FF5B",
                "#FFE53B",
                "#00FFFF",
                "#FF0A6C",
                "#2D27FF",
                "#FF2CDF",
                "#00E1FD",
                "#0A5057"
            };

            _plotColorPalette = colors.Select(color => ColorTranslator.FromHtml(color)).ToArray();
        }
    }
}

```

`LibreHardwareMonitor/UI/Themes/DarkTheme.cs`:

```cs
using System.Drawing;
using System.Linq;

namespace LibreHardwareMonitor.UI.Themes
{
    public class DarkTheme : LightTheme
    {
        private readonly Color[] _plotColorPalette;
        public override Color ForegroundColor => Color.FromArgb(233, 233, 233);
        public override Color BackgroundColor => Color.FromArgb(30, 30, 30);
        public override Color HyperlinkColor => Color.FromArgb(144, 220, 232);
        public override Color SelectedForegroundColor => ForegroundColor;
        public override Color SelectedBackgroundColor => Color.FromArgb(45, 45, 45);
        public override Color LineColor => Color.FromArgb(38, 38, 38);
        public override Color StrongLineColor => Color.FromArgb(53, 53, 53);
        public override Color[] PlotColorPalette => _plotColorPalette;
        public override Color PlotGridMajorColor => Color.FromArgb(93, 93, 93);
        public override Color PlotGridMinorColor => Color.FromArgb(53, 53, 53);
        public override bool WindowTitlebarFallbackToImmersiveDarkMode => true;

        public DarkTheme() : base("dark", "Dark")
        {
            string[] colors = {
                "#F07178",
                "#82AAFF",
                "#C3E88D",
                "#FFCB6B",
                "#009688",
                "#89DDF3",
                "#FFE082",
                "#7986CB",
                "#C792EA",
                "#FF5370",
                "#73d1c8",
                "#F78C6A"
            };

            _plotColorPalette = colors.Select(color => ColorTranslator.FromHtml(color)).ToArray();
        }
    }
}

```

`LibreHardwareMonitor/UI/Themes/LightTheme.cs`:

```cs
using System.Drawing;

namespace LibreHardwareMonitor.UI.Themes
{
    public class LightTheme : Theme
    {
        private readonly Color[] _plotColorPalette = new Color[] {
            Color.Blue,
            Color.OrangeRed,
            Color.Green,
            Color.LightSeaGreen,
            Color.Goldenrod,
            Color.DarkViolet,
            Color.YellowGreen,
            Color.SaddleBrown,
            Color.RoyalBlue,
            Color.DeepPink,
            Color.MediumSeaGreen,
            Color.Olive,
            Color.Firebrick
        };

        public LightTheme(string id, string displayName) : base(id, displayName) { }
        public override Color ForegroundColor => Color.FromArgb(0, 0, 0);
        public override Color BackgroundColor => Color.FromArgb(255, 255, 255);
        public override Color HyperlinkColor => Color.FromArgb(0, 0, 255);
        public override Color SelectedForegroundColor => ForegroundColor;
        public override Color SelectedBackgroundColor => Color.FromArgb(240, 240, 240);
        public override Color LineColor => Color.FromArgb(247, 247, 247);
        public override Color StrongLineColor => Color.FromArgb(209, 209, 209);
        public override Color[] PlotColorPalette => _plotColorPalette;
        public override Color PlotGridMajorColor => Color.FromArgb(192, 192, 192);
        public override Color PlotGridMinorColor => Color.FromArgb(232, 232, 232);
        public override bool WindowTitlebarFallbackToImmersiveDarkMode => false;

        public LightTheme() : base("light", "Light") { }
    }
}

```

`LibreHardwareMonitor/UI/Themes/ThemedHScrollIndicator.cs`:

```cs
using System.Drawing;
using System.Windows.Forms;

namespace LibreHardwareMonitor.UI.Themes
{
    public class ThemedHScrollIndicator : Control
    {
        private readonly HScrollBar _scrollbar;
        private int _startValue = 0;
        private int _startPos = 0;
        private bool _isScrolling = false;

        public static void AddToControl(Control control)
        {
            foreach (Control child in control.Controls)
            {
                if (child is HScrollBar scrollbar)
                {
                    control.Controls.Add(new ThemedHScrollIndicator(scrollbar));
                    return;
                }
            }
        }

        public ThemedHScrollIndicator(HScrollBar scrollBar)
        {
            _scrollbar = scrollBar;

            Height = 8;
            SetStyle(ControlStyles.ResizeRedraw, true);
            SetStyle(ControlStyles.AllPaintingInWmPaint, true);
            SetStyle(ControlStyles.UserPaint, true);
            SetStyle(ControlStyles.OptimizedDoubleBuffer, true);
            Left = 0;
            Top = scrollBar.Parent.Height - Height;
            Size = new Size(scrollBar.Parent.Width, Height);
            Anchor = AnchorStyles.Right | AnchorStyles.Left | AnchorStyles.Bottom;
            Visible = scrollBar.Visible;

            scrollBar.VisibleChanged += (s, e) => Visible = (s as ScrollBar).Visible;
            scrollBar.Scroll += (s, e) => Invalidate();
            scrollBar.ValueChanged += (s, e) => Invalidate();

            scrollBar.Height = 0;
            this.MouseDown += OnMouseDown;
        }

        private void OnMouseDown(object sender, MouseEventArgs e)
        {
            if (_isScrolling)
                return;

            _isScrolling = true;

            //note: this.Capture is true when the control is clicked, no need to handle this

            _startPos = e.X;
            _startValue = _scrollbar.Value;

            this.MouseUp += OnMouseUp;
            this.MouseMove += OnMouseMove;
        }

        private void OnMouseUp(object sender, MouseEventArgs e)
        {
            _isScrolling = false;
            this.MouseUp -= OnMouseUp;
            this.MouseMove -= OnMouseMove;
        }

        private void OnMouseMove(object sender, MouseEventArgs e)
        {
            if (!_isScrolling)
                return;

            //pixel to range scaling:
            double totalRange = _scrollbar.Maximum - _scrollbar.Minimum;

            if (totalRange <= 0)
                return;

            double scaleToPercent = totalRange / Bounds.Width;
            double scrollValue = _startValue + (e.X - _startPos) * scaleToPercent;

            if (scrollValue < _scrollbar.Minimum)
                scrollValue = _scrollbar.Minimum;

            if (scrollValue > (_scrollbar.Maximum - _scrollbar.LargeChange))
                scrollValue = _scrollbar.Maximum - _scrollbar.LargeChange;

            _scrollbar.Value = (int)scrollValue;
            Refresh();
        }

        protected override void OnPaint(PaintEventArgs e)
        {
            Graphics g = e.Graphics;

            using (SolidBrush brush = new SolidBrush(Theme.Current.ScrollbarBackground))
                g.FillRectangle(brush, new Rectangle(0, 0, Bounds.Width, Bounds.Height));

            int width = Bounds.Width;
            int range = _scrollbar.Maximum - _scrollbar.Minimum;

            if (range > 0)
            {
                int start = width * (_scrollbar.Value - _scrollbar.Minimum) / range;
                int end = width * (_scrollbar.Value - _scrollbar.Minimum + _scrollbar.LargeChange) / range;
                using (SolidBrush brush = new SolidBrush(Theme.Current.ScrollbarTrack))
                    g.FillRectangle(brush, new Rectangle(start, 2, end - start, Bounds.Height - 4));
            }
        }
    }
}

```

`LibreHardwareMonitor/UI/Themes/ThemedToolStripRenderer.cs`:

```cs
using System.Drawing;
using System.Windows.Forms;

namespace LibreHardwareMonitor.UI.Themes
{
    public class ThemedToolStripRenderer : ToolStripRenderer
    {
        protected override void OnRenderSeparator(ToolStripSeparatorRenderEventArgs e)
        {
            if (e.Item is not ToolStripSeparator)
            {
                base.OnRenderSeparator(e);
                return;
            }

            Rectangle bounds = new(Point.Empty, e.Item.Size);
            using (Brush brush = new SolidBrush(Theme.Current.MenuBackgroundColor))
                e.Graphics.FillRectangle(brush, bounds);
        }

        protected override void OnRenderArrow(ToolStripArrowRenderEventArgs e)
        {
            e.ArrowColor = e.Item.Selected ? Theme.Current.MenuSelectedForegroundColor : Theme.Current.MenuForegroundColor;
            base.OnRenderArrow(e);
        }

        protected override void OnRenderItemCheck(ToolStripItemImageRenderEventArgs e)
        {
            using (Pen pen = new Pen(e.Item.Selected ? Theme.Current.MenuSelectedForegroundColor : Theme.Current.MenuForegroundColor))
            {
                int x = 10;
                int y = 6;
                e.Graphics.DrawLine(pen, x, y + 3, x + 2, y + 5);
                e.Graphics.DrawLine(pen, x + 2, y + 5, x + 6, y + 1);
                e.Graphics.DrawLine(pen, x, y + 4, x + 2, y + 6);
                e.Graphics.DrawLine(pen, x + 2, y + 6, x + 6, y + 2);
            }
        }

        protected override void OnRenderItemText(ToolStripItemTextRenderEventArgs e)
        {
            e.TextColor = e.Item.Selected ? Theme.Current.MenuSelectedForegroundColor : Theme.Current.MenuForegroundColor;
            base.OnRenderItemText(e);
        }

        protected override void OnRenderToolStripBorder(ToolStripRenderEventArgs e)
        {
            if (e.ToolStrip.Parent is not Form)
            {
                Rectangle bounds = new(Point.Empty, new Size(e.ToolStrip.Width - 1, e.ToolStrip.Height - 1));
                using (Pen pen = new Pen(Theme.Current.MenuBorderColor))
                    e.Graphics.DrawRectangle(pen, bounds);
            }
        }

        protected override void OnRenderToolStripBackground(ToolStripRenderEventArgs e)
        {
            Rectangle bounds = new(Point.Empty, e.ToolStrip.Size);
            using (Brush brush = new SolidBrush(Theme.Current.MenuBackgroundColor))
                e.Graphics.FillRectangle(brush, bounds);
        }

        protected override void OnRenderMenuItemBackground(ToolStripItemRenderEventArgs e)
        {
            Rectangle bounds = new(Point.Empty, e.Item.Size);

            using (Brush brush = new SolidBrush(e.Item.Selected ? Theme.Current.MenuSelectedBackgroundColor : Theme.Current.MenuBackgroundColor))
                e.Graphics.FillRectangle(brush, bounds);
        }
    }
}

```

`LibreHardwareMonitor/UI/Themes/ThemedVScrollIndicator.cs`:

```cs
using System.Drawing;
using System.Windows.Forms;

namespace LibreHardwareMonitor.UI.Themes
{
    public class ThemedVScrollIndicator : Control
    {
        private readonly VScrollBar _scrollbar;
        private int _startValue = 0;
        private int _startPos = 0;
        private bool _isScrolling = false;

        public static void AddToControl(Control control)
        {
            foreach (Control child in control.Controls)
            {
                if (child is VScrollBar scrollbar)
                {
                    control.Controls.Add(new ThemedVScrollIndicator(scrollbar));
                    return;
                }
            }
        }

        public ThemedVScrollIndicator(VScrollBar scrollBar)
        {
            _scrollbar = scrollBar;

            Width = 8;
            SetStyle(ControlStyles.ResizeRedraw, true);
            SetStyle(ControlStyles.AllPaintingInWmPaint, true);
            SetStyle(ControlStyles.UserPaint, true);
            SetStyle(ControlStyles.OptimizedDoubleBuffer, true);
            Left = scrollBar.Parent.Width - Width;
            Top = 0;
            Size = new Size(Width, scrollBar.Parent.Height);
            Anchor = AnchorStyles.Right | AnchorStyles.Top | AnchorStyles.Bottom;
            Visible = scrollBar.Visible;

            scrollBar.VisibleChanged += (s, e) => Visible = (s as ScrollBar).Visible;
            scrollBar.Scroll += (s, e) => Invalidate();
            scrollBar.ValueChanged += (s, e) => Invalidate();

            scrollBar.Width = 0;
            this.MouseDown += OnMouseDown;
        }

        private void OnMouseDown(object sender, MouseEventArgs e)
        {
            if (_isScrolling)
                return;

            _isScrolling = true;

            //note: this.Capture is true when the control is clicked, no need to handle this

            _startPos = e.Y;
            _startValue = _scrollbar.Value;

            this.MouseUp += OnMouseUp;
            this.MouseMove += OnMouseMove;
        }

        private void OnMouseUp(object sender, MouseEventArgs e)
        {
            _isScrolling = false;
            this.MouseUp -= OnMouseUp;
            this.MouseMove -= OnMouseMove;
        }

        private void OnMouseMove(object sender, MouseEventArgs e)
        {
            if (!_isScrolling)
                return;

            //pixel to range scaling:
            double totalRange = _scrollbar.Maximum - _scrollbar.Minimum;

            if (totalRange <= 0)
                return;

            double scaleToPercent = totalRange / Bounds.Height;
            double scrollValue = _startValue + (e.Y - _startPos) * scaleToPercent;

            if (scrollValue < _scrollbar.Minimum)
                scrollValue = _scrollbar.Minimum;

            if (scrollValue > (_scrollbar.Maximum - _scrollbar.LargeChange))
                scrollValue = _scrollbar.Maximum - _scrollbar.LargeChange;

            _scrollbar.Value = (int)scrollValue;
            Refresh();
        }

        protected override void OnPaint(PaintEventArgs e)
        {
            Graphics g = e.Graphics;

            using (SolidBrush brush = new SolidBrush(Theme.Current.ScrollbarBackground))
                g.FillRectangle(brush, new Rectangle(0, 0, Bounds.Width, Bounds.Height));

            int height = Bounds.Height;
            int range = _scrollbar.Maximum - _scrollbar.Minimum;

            if (range > 0)
            {
                int start = height * (_scrollbar.Value - _scrollbar.Minimum) / range;
                int end = height * (_scrollbar.Value - _scrollbar.Minimum + _scrollbar.LargeChange) / range;
                using (SolidBrush brush = new SolidBrush(Theme.Current.ScrollbarTrack))
                    g.FillRectangle(brush, new Rectangle(2, start, Bounds.Width - 4, end - start));
            }
        }
    }
}

```

`LibreHardwareMonitor/UI/ToolStripRadioButtonMenuItem.cs`:

```cs
using System;
using System.Drawing;
using System.Windows.Forms;
using System.Windows.Forms.VisualStyles;

namespace LibreHardwareMonitor.UI;

/// <summary>
/// https://docs.microsoft.com/en-us/dotnet/desktop/winforms/controls/how-to-display-option-buttons-in-a-menustrip-windows-forms
/// </summary>
public class ToolStripRadioButtonMenuItem : ToolStripMenuItem
{
    public ToolStripRadioButtonMenuItem()
        : base()
    {
        Initialize();
    }

    public ToolStripRadioButtonMenuItem(string text)
        : base(text, null, (EventHandler)null)
    {
        Initialize();
    }

    public ToolStripRadioButtonMenuItem(Image image)
        : base(null, image, (EventHandler)null)
    {
        Initialize();
    }

    public ToolStripRadioButtonMenuItem(string text, Image image)
        : base(text, image, (EventHandler)null)
    {
        Initialize();
    }

    public ToolStripRadioButtonMenuItem(string text, Image image,
        EventHandler onClick)
        : base(text, image, onClick)
    {
        Initialize();
    }

    public ToolStripRadioButtonMenuItem(string text, Image image,
        EventHandler onClick, string name)
        : base(text, image, onClick, name)
    {
        Initialize();
    }

    public ToolStripRadioButtonMenuItem(string text, Image image,
        params ToolStripItem[] dropDownItems)
        : base(text, image, dropDownItems)
    {
        Initialize();
    }

    public ToolStripRadioButtonMenuItem(string text, Image image,
        EventHandler onClick, Keys shortcutKeys)
        : base(text, image, onClick)
    {
        Initialize();
        ShortcutKeys = shortcutKeys;
    }

    // Called by all constructors to initialize CheckOnClick.
    private void Initialize()
    {
        CheckOnClick = true;
    }

    protected override void OnCheckedChanged(EventArgs e)
    {
        base.OnCheckedChanged(e);

        // If this item is no longer in the checked state or if its
        // parent has not yet been initialized, do nothing.
        if (!Checked || Parent == null) return;

        // Clear the checked state for all siblings.
        foreach (ToolStripItem item in Parent.Items)
        {
            if (item is ToolStripRadioButtonMenuItem radioItem
             && radioItem != this
             && radioItem.Checked)
            {
                radioItem.Checked = false;

                // Only one item can be selected at a time,
                // so there is no need to continue.
                return;
            }
        }
    }

    protected override void OnClick(EventArgs e)
    {
        // If the item is already in the checked state, do not call
        // the base method, which would toggle the value.
        if (Checked) return;

        base.OnClick(e);
    }

    // Let the item paint itself, and then paint the RadioButton
    // where the check mark is normally displayed.
    protected override void OnPaint(PaintEventArgs e)
    {
        if (Image != null)
        {
            // If the client sets the Image property, the selection behavior
            // remains unchanged, but the RadioButton is not displayed and the
            // selection is indicated only by the selection rectangle.
            base.OnPaint(e);
            return;
        }
        else
        {
            // If the Image property is not set, call the base OnPaint method
            // with the CheckState property temporarily cleared to prevent
            // the check mark from being painted.
            CheckState currentState = CheckState;
            CheckState = CheckState.Unchecked;
            base.OnPaint(e);
            CheckState = currentState;
        }

        // Determine the correct state of the RadioButton.
        RadioButtonState buttonState = RadioButtonState.UncheckedNormal;
        if (Enabled)
        {
            if (mouseDownState)
            {
                if (Checked)
                    buttonState = RadioButtonState.CheckedPressed;
                else
                    buttonState = RadioButtonState.UncheckedPressed;
            }
            else if (mouseHoverState)
            {
                if (Checked) 
                    buttonState = RadioButtonState.CheckedHot;
                else
                    buttonState = RadioButtonState.UncheckedHot;
            }
            else
            {
                if (Checked)
                    buttonState = RadioButtonState.CheckedNormal;
            }
        }
        else
        {
            if (Checked)
                buttonState = RadioButtonState.CheckedDisabled;
            else 
                buttonState = RadioButtonState.UncheckedDisabled;
        }

        // Calculate the position at which to display the RadioButton.
        int offset = (ContentRectangle.Height -
                      RadioButtonRenderer.GetGlyphSize(
                                                       e.Graphics, buttonState).Height) / 2;

        Point imageLocation = new Point(
                                        ContentRectangle.Location.X + 4,
                                        ContentRectangle.Location.Y + offset);

        // Paint the RadioButton.
        RadioButtonRenderer.DrawRadioButton(e.Graphics, imageLocation, buttonState);
    }

    private bool mouseHoverState;

    protected override void OnMouseEnter(EventArgs e)
    {
        mouseHoverState = true;

        // Force the item to repaint with the new RadioButton state.
        Invalidate();

        base.OnMouseEnter(e);
    }

    protected override void OnMouseLeave(EventArgs e)
    {
        mouseHoverState = false;
        base.OnMouseLeave(e);
    }

    private bool mouseDownState;

    protected override void OnMouseDown(MouseEventArgs e)
    {
        mouseDownState = true;

        // Force the item to repaint with the new RadioButton state.
        Invalidate();

        base.OnMouseDown(e);
    }

    protected override void OnMouseUp(MouseEventArgs e)
    {
        mouseDownState = false;
        base.OnMouseUp(e);
    }

    // Enable the item only if its parent item is in the checked state
    // and its Enabled property has not been explicitly set to false.
    public override bool Enabled
    {
        get
        {
            // Use the base value in design mode to prevent the designer
            // from setting the base value to the calculated value.
            if (!DesignMode
             && OwnerItem is ToolStripMenuItem ownerMenuItem
             && ownerMenuItem.CheckOnClick)
            {
                return base.Enabled && ownerMenuItem.Checked;
            }
            else
            {
                return base.Enabled;
            }
        }
        set
        {
            base.Enabled = value;
        }
    }

    // When OwnerItem becomes available, if it is a ToolStripMenuItem
    // with a CheckOnClick property value of true, subscribe to its
    // CheckedChanged event.
    protected override void OnOwnerChanged(EventArgs e)
    {
        if (OwnerItem is ToolStripMenuItem ownerMenuItem
         && ownerMenuItem.CheckOnClick)
        {
            ownerMenuItem.CheckedChanged +=
                new EventHandler(OwnerMenuItem_CheckedChanged);
        }
        base.OnOwnerChanged(e);
    }

    // When the checked state of the parent item changes,
    // repaint the item so that the new Enabled state is displayed.
    private void OwnerMenuItem_CheckedChanged(object sender, EventArgs e)
    {
        Invalidate();
    }
}
```

`LibreHardwareMonitor/UI/TreeModel.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using Aga.Controls.Tree;

namespace LibreHardwareMonitor.UI;

public class TreeModel : ITreeModel
{
    private readonly Node _root;
    private bool _forceVisible;

    public TreeModel()
    {
        _root = new Node { Model = this };
    }

    public TreePath GetPath(Node node)
    {
        if (node == _root)
            return TreePath.Empty;


        Stack<object> stack = new Stack<object>();
        while (node != _root)
        {
            stack.Push(node);
            node = node.Parent;
        }
        return new TreePath(stack.ToArray());
    }

    public Collection<Node> Nodes
    {
        get { return _root.Nodes; }
    }

    private Node GetNode(TreePath treePath)
    {
        Node parent = _root;
        foreach (object obj in treePath.FullPath)
        {
            if (!(obj is Node node) || node.Parent != parent)
                return null;
            parent = node;
        }
        return parent;
    }

    public IEnumerable GetChildren(TreePath treePath)
    {
        Node node = GetNode(treePath);
        if (node != null)
        {
            return node.Nodes.Where(n => _forceVisible || n.IsVisible).ToList();
        }

        return Enumerable.Empty<Node>();
    }

    public bool IsLeaf(TreePath treePath)
    {
        return false;
    }

    public bool ForceVisible
    {
        get
        {
            return _forceVisible;
        }
        set
        {
            if (value != _forceVisible)
            {
                _forceVisible = value;
                OnStructureChanged(_root);
            }
        }
    }

#pragma warning disable 67
    public event EventHandler<TreeModelEventArgs> NodesChanged;
    public event EventHandler<TreePathEventArgs> StructureChanged;
    public event EventHandler<TreeModelEventArgs> NodesInserted;
    public event EventHandler<TreeModelEventArgs> NodesRemoved;
#pragma warning restore 67

    public void OnNodeChanged(Node parent, int index, Node node)
    {
        if (parent != null)
        {
            TreePath path = GetPath(parent);
            if (path != null)
                NodesChanged?.Invoke(this, new TreeModelEventArgs(path, new[] { index }, new object[] { node }));
        }
    }

    public void OnStructureChanged(Node node)
    {
        StructureChanged?.Invoke(this, new TreeModelEventArgs(GetPath(node), new object[0]));
    }

    public void OnNodeInserted(Node parent, int index, Node node)
    {
        TreeModelEventArgs args = new TreeModelEventArgs(GetPath(parent), new[] { index }, new object[] { node });
        NodesInserted?.Invoke(this, args);
    }

    public void OnNodeRemoved(Node parent, int index, Node node)
    {
        TreeModelEventArgs args = new TreeModelEventArgs(GetPath(parent), new[] { index }, new object[] { node });
        NodesRemoved?.Invoke(this, args);
    }

}

```

`LibreHardwareMonitor/UI/TypeNode.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using LibreHardwareMonitor.Hardware;
using LibreHardwareMonitor.Utilities;

namespace LibreHardwareMonitor.UI;

public sealed class TypeNode : Node, IExpandPersistNode
{
    private readonly PersistentSettings _settings;
    private readonly string _expandedIdentifier;
    private bool _expanded;

    public TypeNode(SensorType sensorType, Identifier parentId, PersistentSettings settings)
    {
        SensorType = sensorType;
        _expandedIdentifier = new Identifier(parentId, SensorType.ToString(), ".expanded").ToString();
        _settings = settings;

        switch (sensorType)
        {
            case SensorType.Voltage:
                Image = Utilities.EmbeddedResources.GetImage("voltage.png");
                Text = "Voltages";
                break;
            case SensorType.Current:
                Image = Utilities.EmbeddedResources.GetImage("voltage.png");
                Text = "Currents";
                break;
            case SensorType.Energy:
                Image = Utilities.EmbeddedResources.GetImage("battery.png");
                Text = "Capacities";
                break;
            case SensorType.Clock:
                Image = Utilities.EmbeddedResources.GetImage("clock.png");
                Text = "Clocks";
                break;
            case SensorType.Load:
                Image = Utilities.EmbeddedResources.GetImage("load.png");
                Text = "Load";
                break;
            case SensorType.Temperature:
                Image = Utilities.EmbeddedResources.GetImage("temperature.png");
                Text = "Temperatures";
                break;
            case SensorType.Fan:
                Image = Utilities.EmbeddedResources.GetImage("fan.png");
                Text = "Fans";
                break;
            case SensorType.Flow:
                Image = Utilities.EmbeddedResources.GetImage("flow.png");
                Text = "Flows";
                break;
            case SensorType.Control:
                Image = Utilities.EmbeddedResources.GetImage("control.png");
                Text = "Controls";
                break;
            case SensorType.Level:
                Image = Utilities.EmbeddedResources.GetImage("level.png");
                Text = "Levels";
                break;
            case SensorType.Power:
                Image = Utilities.EmbeddedResources.GetImage("power.png");
                Text = "Powers";
                break;
            case SensorType.Data:
                Image = Utilities.EmbeddedResources.GetImage("data.png");
                Text = "Data";
                break;
            case SensorType.SmallData:
                Image = Utilities.EmbeddedResources.GetImage("data.png");
                Text = "Data";
                break;
            case SensorType.Factor:
                Image = Utilities.EmbeddedResources.GetImage("factor.png");
                Text = "Factors";
                break;
            case SensorType.Frequency:
                Image = Utilities.EmbeddedResources.GetImage("clock.png");
                Text = "Frequencies";
                break;
            case SensorType.Throughput:
                Image = Utilities.EmbeddedResources.GetImage("throughput.png");
                Text = "Throughput";
                break;
            case SensorType.TimeSpan:
                Image = Utilities.EmbeddedResources.GetImage("time.png");
                Text = "Times";
                break;
            case SensorType.Timing:
                Image = Utilities.EmbeddedResources.GetImage("time.png");
                Text = "Timings";
                break;
            case SensorType.Noise:
                Image = Utilities.EmbeddedResources.GetImage("loudspeaker.png");
                Text = "Noise Levels";
                break;
            case SensorType.Conductivity:
                Image = Utilities.EmbeddedResources.GetImage("voltage.png");
                Text = "Conductivities";
                break;
            case SensorType.Humidity:
                Image = Utilities.EmbeddedResources.GetImage("humidity.png");
                Text = "Humidity Levels";
                break;
        }

        NodeAdded += TypeNode_NodeAdded;
        NodeRemoved += TypeNode_NodeRemoved;
        _expanded = settings.GetValue(_expandedIdentifier, true);
    }

    private void TypeNode_NodeRemoved(Node node)
    {
        node.IsVisibleChanged -= Node_IsVisibleChanged;
        Node_IsVisibleChanged(null);
    }

    private void TypeNode_NodeAdded(Node node)
    {
        node.IsVisibleChanged += Node_IsVisibleChanged;
        Node_IsVisibleChanged(null);
    }

    private void Node_IsVisibleChanged(Node node)
    {
        foreach (Node n in Nodes)
        {
            if (n.IsVisible)
            {
                IsVisible = true;
                return;
            }
        }
        IsVisible = false;
    }

    public SensorType SensorType { get; }

    public bool Expanded
    {
        get => _expanded;
        set
        {
            _expanded = value;
            _settings.SetValue(_expandedIdentifier, _expanded);
        }
    }
}

```

`LibreHardwareMonitor/UI/UnitManager.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using LibreHardwareMonitor.Utilities;

namespace LibreHardwareMonitor.UI;

public enum TemperatureUnit
{
    Celsius = 0,
    Fahrenheit = 1
}

public class UnitManager
{

    private readonly PersistentSettings _settings;
    private TemperatureUnit _temperatureUnit;

    public UnitManager(PersistentSettings settings)
    {
        _settings = settings;
        _temperatureUnit = (TemperatureUnit)settings.GetValue("TemperatureUnit", (int)TemperatureUnit.Celsius);
    }

    public TemperatureUnit TemperatureUnit
    {
        get { return _temperatureUnit; }
        set
        {
            _temperatureUnit = value;
            _settings.SetValue("TemperatureUnit", (int)_temperatureUnit);
        }
    }

    public static float? CelsiusToFahrenheit(float? valueInCelsius)
    {
        return valueInCelsius * 1.8f + 32;
    }
}
```

`LibreHardwareMonitor/UI/UpdateVisitor.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using LibreHardwareMonitor.Hardware;

namespace LibreHardwareMonitor.UI;

public class UpdateVisitor : IVisitor
{
    public void VisitComputer(IComputer computer)
    {
        computer.Traverse(this);
    }

    public void VisitHardware(IHardware hardware)
    {
        hardware.Update();
        foreach (IHardware subHardware in hardware.SubHardware)
            subHardware.Accept(this);
    }

    public void VisitSensor(ISensor sensor) { }

    public void VisitParameter(IParameter parameter) { }
}
```

`LibreHardwareMonitor/UI/UserOption.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Windows.Forms;
using LibreHardwareMonitor.Utilities;

namespace LibreHardwareMonitor.UI;

public class UserOption
{
    private readonly string _name;
    private bool _value;
    private readonly ToolStripMenuItem _menuItem;
    private event EventHandler _changed;
    private readonly PersistentSettings _settings;

    public UserOption(string name, bool value, ToolStripMenuItem menuItem, PersistentSettings settings)
    {
        _settings = settings;
        _name = name;
        _value = name != null ? settings.GetValue(name, value) : value;
        _menuItem = menuItem;
        _menuItem.Checked = _value;
        _menuItem.Click += MenuItem_Click;
    }

    private void MenuItem_Click(object sender, EventArgs e)
    {
        Value = !Value;
    }

    public bool Value
    {
        get { return _value; }
        set
        {
            if (_value != value)
            {
                _value = value;
                if (_name != null)
                    _settings.SetValue(_name, value);
                _menuItem.Checked = value;
                _changed?.Invoke(this, null);
            }
        }
    }

    public event EventHandler Changed
    {
        add
        {
            _changed += value;
            _changed?.Invoke(this, null);
        }
        remove
        {
            _changed -= value;
        }
    }
}
```

`LibreHardwareMonitor/UI/UserRadioGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Windows.Forms;
using LibreHardwareMonitor.Utilities;

namespace LibreHardwareMonitor.UI;

public class UserRadioGroup
{
    private readonly string _name;
    private int _value;
    private readonly ToolStripMenuItem[] _menuItems;
    private event EventHandler _changed;
    private readonly PersistentSettings _settings;

    public UserRadioGroup(string name, int value, ToolStripMenuItem[] menuItems, PersistentSettings settings)
    {
        _settings = settings;
        _name = name;
        _value = name != null ? settings.GetValue(name, value) : value;
        _menuItems = menuItems;
        _value = Math.Max(Math.Min(_value, menuItems.Length - 1), 0);

        for (int i = 0; i < _menuItems.Length; i++)
        {
            _menuItems[i].Checked = i == _value;
            int index = i;
            _menuItems[i].Click += delegate
            {
                Value = index;
            };
        }
    }

    public int Value
    {
        get { return _value; }
        set
        {
            if (_value != value)
            {
                _value = value;
                if (_name != null)
                    _settings.SetValue(_name, value);
                for (int i = 0; i < _menuItems.Length; i++)
                    _menuItems[i].Checked = i == value;
                _changed?.Invoke(this, null);
            }
        }
    }

    public event EventHandler Changed
    {
        add
        {
            _changed += value;
            _changed?.Invoke(this, null);
        }
        remove
        {
            _changed -= value;
        }
    }
}
```

`LibreHardwareMonitor/Utilities/EmbeddedResources.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Drawing;
using System.IO;
using System.Reflection;

namespace LibreHardwareMonitor.Utilities;

public class EmbeddedResources
{
    public static Image GetImage(string name)
    {
        name = "LibreHardwareMonitor.Resources." + name;
        string[] names = Assembly.GetExecutingAssembly().GetManifestResourceNames();

        for (int i = 0; i < names.Length; i++)
        {
            if (names[i].Replace('\\', '.') == name)
            {
                using (Stream stream = Assembly.GetExecutingAssembly().GetManifestResourceStream(names[i]))
                {
                    // "You must keep the stream open for the lifetime of the Image."
                    Image image = Image.FromStream(stream);

                    // so we just create a copy of the image
                    Bitmap bitmap = new Bitmap(image);

                    // and dispose it right here
                    image.Dispose();

                    return bitmap;
                }
            }
        }
        return new Bitmap(1, 1);
    }

    public static Icon GetIcon(string name)
    {
        name = "LibreHardwareMonitor.Resources." + name;
        string[] names = Assembly.GetExecutingAssembly().GetManifestResourceNames();
        for (int i = 0; i < names.Length; i++)
        {
            if (names[i].Replace('\\', '.') == name)
            {
                using (Stream stream = Assembly.GetExecutingAssembly().GetManifestResourceStream(names[i]))
                {
                    return new Icon(stream);
                }
            }
        }
        return null;
    }

}
```

`LibreHardwareMonitor/Utilities/HttpServer.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Drawing;
using System.Drawing.Imaging;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Net;
using System.Reflection;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Web;
using LibreHardwareMonitor.Hardware;
using LibreHardwareMonitor.UI;

namespace LibreHardwareMonitor.Utilities;

public class HttpServer
{
    private readonly HttpListener _listener;
    private readonly Node _root;
    private readonly IElement _rootElement;
    private Task _listenerTask;
    private CancellationTokenSource _cts;

    public HttpServer(Node node, IElement rootElement, string ip, int port, bool authEnabled = false, string userName = "", string password = "")
    {
        _root = node;
        _rootElement = rootElement;
        ListenerIp = ip;
        ListenerPort = port;
        AuthEnabled = authEnabled;
        UserName = userName;
        Password = password;

        try
        {
            _listener = new HttpListener { IgnoreWriteExceptions = true };
        }
        catch (PlatformNotSupportedException)
        {
            _listener = null;
        }
    }

    ~HttpServer()
    {
        if (PlatformNotSupported)
            return;

        StopHttpListener();
        try
        {
            _listener?.Abort();
        }
        catch { }
    }

    public bool AuthEnabled { get; set; }

    public string ListenerIp { get; set; }

    public int ListenerPort { get; set; }

    public string Password
    {
        get { return PasswordSHA256; }
        set { PasswordSHA256 = ComputeSHA256(value); }
    }

    public bool PlatformNotSupported
    {
        get { return _listener == null; }
    }

    public string UserName { get; set; }

    private string PasswordSHA256 { get; set; }

    public bool StartHttpListener()
    {
        if (PlatformNotSupported)
            return false;

        try
        {
            if (_listener.IsListening)
                return true;

            // validate that the selected IP exists (it could have been previously selected before switching networks)
            IPHostEntry host = Dns.GetHostEntry(Dns.GetHostName());
            bool ipFound = false;
            foreach (IPAddress ip in host.AddressList)
            {
                if (ListenerIp == ip.ToString())
                {
                    ipFound = true;
                    break;
                }
            }

            if (!ipFound)
            {
                // default to behavior of previous version if we don't know what interface to use.
                ListenerIp = "+";
            }

            string prefix = "http://" + ListenerIp + ":" + ListenerPort + "/";

            _listener.Prefixes.Clear();
            _listener.Prefixes.Add(prefix);
            _listener.Realm = "Libre Hardware Monitor";
            _listener.AuthenticationSchemes = AuthEnabled ? AuthenticationSchemes.Basic : AuthenticationSchemes.Anonymous;
            _listener.Start();

            _cts = new CancellationTokenSource();
            _listenerTask = Task.Run(() => ProcessRequestsAsync(_cts.Token));
        }
        catch (Exception)
        {
            return false;
        }

        return true;
    }

    public bool StopHttpListener()
    {
        if (PlatformNotSupported)
            return false;

        try
        {
            _cts?.Cancel();
            _listenerTask?.Wait(TimeSpan.FromSeconds(5)); // Graceful wait
            _listener?.Stop();
            _cts?.Dispose();
        }
        catch (HttpListenerException)
        { }
        catch (OperationCanceledException)
        { }
        catch (NullReferenceException)
        { }
        catch (Exception)
        { }

        return true;
    }

    private async Task ProcessRequestsAsync(CancellationToken cancellationToken)
    {
        while (_listener.IsListening && !cancellationToken.IsCancellationRequested)
        {
            try
            {
                var context = await _listener.GetContextAsync();
                _ = Task.Run(() => HandleContextAsync(context), cancellationToken);
            }
            catch (HttpListenerException ex) when (ex.ErrorCode == 50)
            {
                // Handle Windows update bug (e.g., 2025-10 Cumulative Update): retry after delay
                System.Diagnostics.Debug.WriteLine($"HttpListener error (code {ex.ErrorCode}): {ex.Message}. Retrying in 5 seconds.");
                await Task.Delay(5000, cancellationToken);
            }
            catch (ObjectDisposedException)
            {
                break; // Listener stopped
            }
            catch (OperationCanceledException)
            {
                break;
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Unexpected HttpListener error: {ex.Message}");
            }
        }
    }

    public static IDictionary<string, string> ToDictionary(NameValueCollection col)
    {
        IDictionary<string, string> dict = new Dictionary<string, string>();
        foreach (string k in col.AllKeys)
        {
            dict.Add(k, col[k]);
        }

        return dict;
    }

    public SensorNode FindSensor(Node node, string id)
    {
        if (node is SensorNode sNode)
        {
            if (sNode.Sensor.Identifier.ToString() == id)
                return sNode;
        }

        foreach (Node child in node.Nodes)
        {
            SensorNode s = FindSensor(child, id);
            if (s != null)
            {
                return s;
            }
        }

        return null;
    }
    public void SetSensorControlValue(SensorNode sNode, string value)
    {
        if (sNode.Sensor.Control == null)
        {
            throw new ArgumentException("Specified sensor '" + sNode.Sensor.Identifier + "' can not be set");
        }

        if (value == "null")
        {
            sNode.Sensor.Control.SetDefault();
        }
        else
        {
            sNode.Sensor.Control.SetSoftware(float.Parse(value, CultureInfo.InvariantCulture));
        }
    }

    //Handles "/Sensor" requests.
    //Parameters are taken from the query part of the URL.
    //Get:
    //http://localhost:8085/Sensor?action=Get&id=/some/node/path/0
    //The output is either:
    //{"result":"fail","message":"Some error message"}
    //or:
    //{"result":"ok","value":42.0, "format":"{0:F2} RPM"}
    //
    //Set:
    //http://localhost:8085/Sensor?action=Set&id=/some/node/path/0&value=42.0
    //http://localhost:8085/Sensor?action=Set&id=/some/node/path/0&value=null
    //The output is either:
    //{"result":"fail","message":"Some error message"}
    //or:
    //{"result":"ok"}
    private void HandleSensorRequest(HttpListenerRequest request, Dictionary<string, object> result)
    {
        IDictionary<string, string> dict = ToDictionary(HttpUtility.ParseQueryString(request.Url.Query));

        if (dict.ContainsKey("action"))
        {
            if (dict.ContainsKey("id"))
            {
                SensorNode sNode = FindSensor(_root, dict["id"]);

                if (sNode == null)
                {
                    throw new ArgumentException("Unknown id " + dict["id"] + " specified");
                }

                if (dict["action"] == "ResetMinMax")
                {
                    // Reset Min/Max, then return Sensor values...
                    sNode.Sensor.ResetMin();
                    sNode.Sensor.ResetMax();
                    dict["action"] = "Get";
                }

                switch (dict["action"])
                {
                    case "Set" when dict.ContainsKey("value"):
                        SetSensorControlValue(sNode, dict["value"]);
                        break;
                    case "Set":
                        throw new ArgumentNullException("No value provided");
                    case "Get":
                        result["value"] = sNode.Sensor.Value;
                        result["min"] = sNode.Sensor.Min;
                        result["max"] = sNode.Sensor.Max;
                        result["format"] = sNode.Format;
                        break;
                    default:
                        throw new ArgumentException("Unknown action type " + dict["action"]);
                }
            }
            else
            {
                throw new ArgumentNullException("No id provided");
            }
        }
        else
        {
            throw new ArgumentNullException("No action provided");
        }
    }

    //Handles http POST requests in a REST like manner.
    //Currently the only supported base URL is http://localhost:8085/Sensor.
    private string HandlePostRequest(HttpListenerRequest request)
    {
        var result = new Dictionary<string, object> { ["result"] = "ok" };

        try
        {
            if (request.Url.Segments.Length == 2)
            {
                if (request.Url.Segments[1] == "Sensor")
                {
                    HandleSensorRequest(request, result);
                }
                else
                {
                    throw new ArgumentException("Invalid URL ('" + request.Url.Segments[1] + "'), possible values: ['Sensor']");
                }
            }
            else
                throw new ArgumentException("Empty URL, possible values: ['Sensor']");
        }
        catch (Exception e)
        {
            result["result"] = "fail";
            result["message"] = e.ToString();
        }
        return System.Text.Json.JsonSerializer.Serialize(result);
    }

    private async Task HandleContextAsync(HttpListenerContext context)
    {
        HttpListenerRequest request = context.Request;
        bool authenticated = true;

        if (AuthEnabled)
        {
            try
            {
                HttpListenerBasicIdentity identity = (HttpListenerBasicIdentity)context.User.Identity;
                authenticated = (identity.Name == UserName) && (ComputeSHA256(identity.Password) == PasswordSHA256);
            }
            catch
            {
                authenticated = false;
            }
        }

        if (authenticated)
        {
            switch (request.HttpMethod)
            {
                case "POST":
                    {
                        string postResult = HandlePostRequest(request);
                        await SendResponseAsync(context.Response, postResult, "application/json");
                        break;
                    }
                case "GET":
                    {
                        string requestedFile = request.RawUrl.Substring(1);

                        if (requestedFile == "data.json")
                        {
                            await SendJsonAsync(context.Response, request);
                            return;
                        }

                        if (requestedFile.Contains("images_icon"))
                        {
                            await ServeResourceImageAsync(context.Response, requestedFile.Replace("images_icon/", string.Empty));
                            return;
                        }

                        if (requestedFile.StartsWith("metrics?") || requestedFile == "metrics")
                        {
                            await SendPrometheusAsync(context.Response, request);
                            return;
                        }

                        if (requestedFile.Contains("Sensor"))
                        {
                            var sensorResult = new Dictionary<string, object>();
                            HandleSensorRequest(request, sensorResult);
                            await SendJsonSensorAsync(context.Response, sensorResult);
                            return;
                        }

                        if (requestedFile.Contains("ResetAllMinMax"))
                        {
                            _rootElement.Accept(new SensorVisitor(delegate (ISensor sensor)
                            {
                                sensor.ResetMin();
                                sensor.ResetMax();
                            }));
                            await SendJsonAsync(context.Response, request);
                            return;
                        }

                        // default file to be served
                        if (string.IsNullOrEmpty(requestedFile))
                            requestedFile = "index.html";

                        string[] splits = requestedFile.Split('.');
                        string ext = splits[splits.Length - 1];
                        await ServeResourceFileAsync(context.Response, "Web." + requestedFile.Replace('/', '.'), ext);
                        break;
                    }
                default:
                    {
                        context.Response.StatusCode = 404;
                        break;
                    }
            }
        }
        else
        {
            context.Response.StatusCode = 401;
        }

        if (context.Response.StatusCode == 401)
        {
            const string responseString = @"<HTML><HEAD><TITLE>401 Unauthorized</TITLE></HEAD>
  <BODY><H4>401 Unauthorized</H4>
  Authorization required.</BODY></HTML> ";

            await SendResponseAsync(context.Response, responseString, "text/html");
        }

        try
        {
            context.Response.Close();
        }
        catch
        {
            // client closed connection before the content was sent
        }
    }
    private async Task ServeResourceFileAsync(HttpListenerResponse response, string name, string ext)
    {
        // resource names do not support the hyphen
        name = "LibreHardwareMonitor.Resources." +
               name.Replace("custom-theme", "custom_theme");

        string[] names = Assembly.GetExecutingAssembly().GetManifestResourceNames();

        for (int i = 0; i < names.Length; i++)
        {
            if (names[i].Replace('\\', '.') == name)
            {
                using Stream stream = Assembly.GetExecutingAssembly().GetManifestResourceStream(names[i]);

                response.ContentType = GetContentType("." + ext);
                response.ContentLength64 = stream.Length;
                byte[] buffer = new byte[512 * 1024];
                try
                {
                    int len;
                    while ((len = await stream.ReadAsync(buffer, 0, buffer.Length)) > 0)
                    {
                        await response.OutputStream.WriteAsync(buffer, 0, len);
                    }

                    await response.OutputStream.FlushAsync();
                    response.OutputStream.Close();
                    response.Close();
                }
                catch (HttpListenerException)
                { }
                catch (InvalidOperationException)
                { }

                return;
            }
        }

        response.StatusCode = 404;
        response.Close();
    }

    private async Task ServeResourceImageAsync(HttpListenerResponse response, string name)
    {
        name = "LibreHardwareMonitor.Resources." + name;

        string[] names = Assembly.GetExecutingAssembly().GetManifestResourceNames();

        for (int i = 0; i < names.Length; i++)
        {
            if (names[i].Replace('\\', '.') == name)
            {
                using Stream stream = Assembly.GetExecutingAssembly().GetManifestResourceStream(names[i]);

                using Image image = Image.FromStream(stream);
                response.ContentType = "image/png";
                try
                {
                    using var ms = new MemoryStream();
                    image.Save(ms, ImageFormat.Png);
                    byte[] buffer = ms.ToArray();
                    await response.OutputStream.WriteAsync(buffer, 0, buffer.Length);
                    response.OutputStream.Close();
                }
                catch (HttpListenerException)
                { }

                response.Close();
                return;
            }
        }

        response.StatusCode = 404;
        response.Close();
    }

    private async Task SendJsonAsync(HttpListenerResponse response, HttpListenerRequest request = null)
    {
        Dictionary<string, object> json = new();

        int nodeIndex = 0;

        json["id"] = nodeIndex++;
        json["Text"] = "Sensor";
        json["Min"] = "Min";
        json["Value"] = "Value";
        json["Max"] = "Max";
        json["ImageURL"] = string.Empty;

        json["Children"] = new List<object> { GenerateJsonForNode(_root, ref nodeIndex) };

        byte[] buffer = Encoding.UTF8.GetBytes(System.Text.Json.JsonSerializer.Serialize(json));

        bool acceptGzip;
        try
        {
            acceptGzip = (request != null) && (request.Headers["Accept-Encoding"].IndexOf("gzip", StringComparison.OrdinalIgnoreCase) >= 0);
        }
        catch
        {
            acceptGzip = false;
        }

        response.AddHeader("Cache-Control", "no-cache");
        response.AddHeader("Access-Control-Allow-Origin", "*");
        response.ContentType = "application/json";

        try
        {
            if (acceptGzip)
            {
                response.AddHeader("Content-Encoding", "gzip");
                using var ms = new MemoryStream();
                using (var zip = new GZipStream(ms, CompressionMode.Compress, true))
                    await zip.WriteAsync(buffer, 0, buffer.Length);

                buffer = ms.ToArray();
            }

            response.ContentLength64 = buffer.Length;
            await response.OutputStream.WriteAsync(buffer, 0, buffer.Length);
            response.OutputStream.Close();
        }
        catch (HttpListenerException)
        { }

        response.Close();
    }

    private string GeneratePrometheusResponse(Node node, Dictionary<string, int> prometheusSettings)
    {
        string responseStr = "";
        string lastTagName = "";

        /// Dictionary to convert all data to base units for OpenMetrics
        /// SensorType, Item1 suffix, Item2 factor
        var units = new Dictionary<SensorType, (string, double)>
        {
           { SensorType.Clock, ("hertz", 1000000)},                           //originally megahertz
           { SensorType.Conductivity, ("seconds_per_centimeter", 0.000001) }, //originally microseconds per centimeter
           { SensorType.Control, ("percent", 1) },
           { SensorType.Current, ("amperes", 1) },
           { SensorType.Data, ("bytes", 1000000000) },                        //originally GB
           { SensorType.Energy, ("watthour", 0.001) },
           { SensorType.Factor, ("", 1) },
           { SensorType.Fan, ("rpm", 1) },
           { SensorType.Flow, ("liters_per_hour", 1) },
           { SensorType.Frequency, ("hertz", 1) },
           { SensorType.Humidity, ("percent", 1) },
           { SensorType.Level, ("percent", 1) },
           { SensorType.Load, ("percent", 1) },
           { SensorType.Noise, ("decibels", 1) },
           { SensorType.Power, ("watts", 1) },
           { SensorType.SmallData, ("bytes", 1024*1024) },                    //originally MiB
           { SensorType.Temperature, ("celsius", 1) },
           { SensorType.Throughput, ("bytes_per_second", 1) },
           { SensorType.TimeSpan, ("seconds", 1) },
           { SensorType.Timing, ("seconds", 0.000000001 ) },                  //originally nanoseconds
           { SensorType.Voltage, ("volts", 1) },
        };

        for (int i = 0; i < node.Nodes.Count; i++)
        {
            if (node.Nodes[i].GetType().Name == "HardwareNode")
            {
                responseStr += GeneratePrometheusResponse(node.Nodes[i], prometheusSettings);
            }

            if (node.Nodes[i].GetType().Name == "TypeNode")
            {
                string tagHardware = "";
                string valueHardwareName = "";
                string valueHardwareId = ((HardwareNode)node).Hardware.Identifier.ToString();

                if (((HardwareNode)node).Hardware.Parent != null)
                {
                    tagHardware = ((HardwareNode)node).Hardware.Parent.HardwareType.ToString();
                    valueHardwareName = ((HardwareNode)node).Hardware.Parent.Name;
                }
                else
                {
                    tagHardware = ((HardwareNode)node).Hardware.HardwareType.ToString();
                    valueHardwareName = node.Text;
                }

                string valueHardwareAlias = $"{valueHardwareName} ({valueHardwareId})";

                foreach (SensorNode sensor in node.Nodes[i].Nodes)
                {
                    string valueSensorName = sensor.Text.Replace("#", String.Empty);

                    // Variables needed in dictionary lookup and error message
                    string tagSensorType = sensor.Sensor.SensorType.ToString();

                    double factor = 1;
                    string tagSensorUnits = "";

                    // Get factor and unit suffix from dictionary ...
                    if (units.ContainsKey(sensor.Sensor.SensorType))
                    {
                        factor = units[sensor.Sensor.SensorType].Item2;
                        tagSensorUnits = (units[sensor.Sensor.SensorType].Item1.Length == 0 ? String.Empty : "_" + units[sensor.Sensor.SensorType].Item1);
                    }
                    // ... or print an error message
                    else
                    {
                        responseStr += $"# HELP {tagHardware}_{tagSensorType}:{valueSensorName} This Sensor type is not defined in the prometheus adapter [{sensor.Sensor.SensorType}]\n";
                    }

                    // Creating the tag name for prometheus
                    string tagName = $"lhm_{tagHardware}_{tagSensorType}{tagSensorUnits}";
                    tagName = tagName.ToLower();

                    // Preparing the labels for all data and uniqueness
                    string valueSensorId = sensor.Sensor.Identifier.ToString().Substring(valueHardwareId.Length);
                    string valueSensorAlias = $"{valueSensorName} ({valueSensorId})";
                    string valueHost = _root.Text;

                    // Creates the tag with labels
                    string tagLine = $$"""{{tagName}} {"sensorName"="{{valueSensorName}}", "sensorAlias"="{{valueSensorAlias}}", "hardwareName"="{{valueHardwareName}}", "hardwareAlias"="{{valueHardwareAlias}}", "sensorId"="{{valueSensorId}}", "hardwareId"="{{valueHardwareId}}", "host"="{{valueHost}}"}""";

                    if (lastTagName != tagName)
                    {
                        responseStr += $"# TYPE {tagName} gauge\n";
                        lastTagName = tagName;
                    }

                    int counter = 0;
                    foreach (SensorValue val in sensor.Sensor.Values.Reverse())
                    {
                        if (counter++ > prometheusSettings["archivelength"])
                            break;

                        if (float.IsNaN(val.Value))
                        {
                            // Print a help line saying what tag had an invalid value
                            responseStr += $"# HELP {tagLine} has an invalid value and was skipped.\n";
                        }
                        else
                        {
                            if (counter == 1 && prometheusSettings["lastvalue"] == 0)
                                continue; // skip the first value in the list

                            if (prometheusSettings["timestamps"] == 1)
                            {
                                responseStr += $"{tagLine} {(val.Value * factor).ToString(CultureInfo.InvariantCulture)} {((DateTimeOffset)val.Time).ToUnixTimeMilliseconds()}\n";
                            }
                            else
                            {
                                responseStr += $"{tagLine} {(val.Value * factor).ToString(CultureInfo.InvariantCulture)}\n";
                            }
                        }
                    }
                }
            }
        }
        return responseStr;
    }

    private async Task SendPrometheusAsync(HttpListenerResponse response, HttpListenerRequest request = null)
    {
        Dictionary<string, int> prometheusSettings = new Dictionary<string, int>();
        //Default values: archivelength=0, timestamps=0, lastvalue=1
        prometheusSettings["archivelength"] = 0;
        prometheusSettings["timestamps"] = 0;
        prometheusSettings["lastvalue"] = 1;

        if (request != null && request.QueryString != null && request.QueryString.Count > 0)
        {
            int archive = 0, timestamps = 0, lastvalue = 1;
            
            foreach (string key in request.QueryString.AllKeys)
            {
                switch (key)
                {
                    case "timestamps":
                        int.TryParse(request.QueryString[key], out timestamps);     

                        if (timestamps < 0 || timestamps > 1)
                            timestamps = 0;     // Enforce boolean range 0 to 1

                        if (archive > 0)
                            timestamps = 1;     // If archive is requested, timestamps must be enabled

                        break;
                    case "archivelength":
                        int.TryParse(request.QueryString[key], out archive);
                        archive = Math.Min(10, archive); // Enforce max 10
                        archive = Math.Max(0, archive); // Enforce min 0

                        if (archive == 0 && lastvalue == 0)
                            archive = 1; // If lastvalue was not requested then return at least 1 archived value

                        if (archive > 0)
                            timestamps = 1; // If archive is requested, timestamps must be enabled

                        break;
                    case "lastvalue":
                        int.TryParse(request.QueryString[key], out lastvalue);

                        if (lastvalue < 0 || lastvalue > 1)
                            lastvalue = 1; // Enforce boolean range 0 to 1

                        if (lastvalue == 0 && archive  == 0)
                        {
                            archive = 1;
                            timestamps = 1;
                        }

                        break;
                    default:
                        break;
                }
            }

            prometheusSettings["archivelength"] = archive;
            prometheusSettings["timestamps"] = timestamps;
            prometheusSettings["lastvalue"] = lastvalue;
        }

        string responseContent = GeneratePrometheusResponse(_root, prometheusSettings);
        response.AddHeader("Cache-Control", "no-cache");
        response.AddHeader("Access-Control-Allow-Origin", "*");

        // Add custom headers to inform the user what settings are in effect
        response.AddHeader("X-archivelength", prometheusSettings["archivelength"].ToString());
        response.AddHeader("X-timestamps", prometheusSettings["timestamps"].ToString());
        response.AddHeader("X-lastvalue", prometheusSettings["lastvalue"].ToString());

        await SendResponseAsync(response, responseContent, "text/plain");
    }

    private async Task SendJsonSensorAsync(HttpListenerResponse response, Dictionary<string, object> sensorData)
    {
        // Convert the JObject to a JSON string
        string responseContent = System.Text.Json.JsonSerializer.Serialize(sensorData);
        response.AddHeader("Cache-Control", "no-cache");
        response.AddHeader("Access-Control-Allow-Origin", "*");
        await SendResponseAsync(response, responseContent, "application/json");
    }
        
    private Dictionary<string, object> GenerateJsonForNode(Node n, ref int nodeIndex)
    {
        Dictionary<string, object> jsonNode = new()
        {
            ["id"] = nodeIndex++,
            ["Text"] = n.Text,
            ["Min"] = string.Empty,
            ["Value"] = string.Empty,
            ["Max"] = string.Empty
        };

        switch (n)
        {
            case SensorNode sensorNode:
                jsonNode["SensorId"] = sensorNode.Sensor.Identifier.ToString();
                jsonNode["Type"] = sensorNode.Sensor.SensorType.ToString();

                // Formatted values, e.g. Throughput will be measured in KB/s or MB/s depending on the value
                jsonNode["Min"] = sensorNode.Min;
                jsonNode["Value"] = sensorNode.Value;
                jsonNode["Max"] = sensorNode.Max;

                // Unformatted values for external systems to have consistent readings, e.g. Throughput will always be measured in B/s
                jsonNode["RawMin"] = string.Format(sensorNode.Format, sensorNode.Sensor.Min);
                jsonNode["RawValue"] = string.Format(sensorNode.Format, sensorNode.Sensor.Value);
                jsonNode["RawMax"] = string.Format(sensorNode.Format, sensorNode.Sensor.Max);

                jsonNode["ImageURL"] = "images/transparent.png";
                break;
            case HardwareNode hardwareNode:
                jsonNode["HardwareId"] = hardwareNode.Hardware.Identifier.ToString();
                jsonNode["ImageURL"] = "images_icon/" + GetHardwareImageFile(hardwareNode);
                break;
            case TypeNode typeNode:
                jsonNode["ImageURL"] = "images_icon/" + GetTypeImageFile(typeNode);
                break;
            default:
                jsonNode["ImageURL"] = "images_icon/computer.png";
                break;
        }

        List<object> children = new();
        foreach (Node child in n.Nodes)
        {
            children.Add(GenerateJsonForNode(child, ref nodeIndex));
        }

        jsonNode["Children"] = children;

        return jsonNode;
    }

    private static string GetContentType(string extension)
    {
        switch (extension)
        {
            case ".avi": return "video/x-msvideo";
            case ".css": return "text/css";
            case ".doc": return "application/msword";
            case ".gif": return "image/gif";
            case ".htm":
            case ".html": return "text/html";
            case ".jpg":
            case ".jpeg": return "image/jpeg";
            case ".js": return "application/x-javascript";
            case ".mp3": return "audio/mpeg";
            case ".png": return "image/png";
            case ".pdf": return "application/pdf";
            case ".ppt": return "application/vnd.ms-powerpoint";
            case ".zip": return "application/zip";
            case ".txt": return "text/plain";
            default: return "application/octet-stream";
        }
    }
    private static string GetHardwareImageFile(HardwareNode hn)
    {
        switch (hn.Hardware.HardwareType)
        {
            case HardwareType.Cpu:
                return "cpu.png";
            case HardwareType.GpuNvidia:
                return "nvidia.png";
            case HardwareType.GpuAmd:
                return "ati.png";
            case HardwareType.GpuIntel:
                return "intel.png";
            case HardwareType.Storage:
                return "hdd.png";
            case HardwareType.Motherboard:
                return "mainboard.png";
            case HardwareType.SuperIO:
                return "chip.png";
            case HardwareType.Memory:
                return "ram.png";
            case HardwareType.Cooler:
                return "fan.png";
            case HardwareType.Network:
                return "nic.png";
            case HardwareType.Psu:
                return "power-supply.png";
            case HardwareType.Battery:
                return "battery.png";
            case HardwareType.PowerMonitor:
                return "powermonitor.png";
            default:
                return "cpu.png";
        }
    }

    private static string GetTypeImageFile(TypeNode tn)
    {
        switch (tn.SensorType)
        {
            case SensorType.Voltage:
            case SensorType.Current:
                return "voltage.png";
            case SensorType.Clock:
            case SensorType.Timing:
                return "clock.png";
            case SensorType.Load:
                return "load.png";
            case SensorType.Temperature:
                return "temperature.png";
            case SensorType.Fan:
                return "fan.png";
            case SensorType.Flow:
                return "flow.png";
            case SensorType.Control:
                return "control.png";
            case SensorType.Level:
                return "level.png";
            case SensorType.Power:
                return "power.png";
            case SensorType.Noise:
                return "loudspeaker.png";
            case SensorType.Conductivity:
                return "voltage.png";
            case SensorType.Throughput:
                return "throughput.png";
            case SensorType.Humidity:
                return "flow.png";
            default:
                return "power.png";
        }
    }

    private string ComputeSHA256(string text)
    {
        using SHA256 hash = SHA256.Create();
        return string.Concat(hash
                            .ComputeHash(Encoding.UTF8.GetBytes(text))
                            .Select(item => item.ToString("x2")));
    }

    public void Quit()
    {
        if (PlatformNotSupported)
            return;

        StopHttpListener();
        try
        {
            _listener?.Abort();
        }
        catch { }
    }

    private static async Task SendResponseAsync(HttpListenerResponse response, string content, string contentType)
    {
        byte[] buffer = Encoding.UTF8.GetBytes(content);
        response.ContentType = contentType;
        response.ContentLength64 = buffer.Length;

        try
        {
            await response.OutputStream.WriteAsync(buffer, 0, buffer.Length);
            response.OutputStream.Close();
        }
        catch (HttpListenerException)
        { }
    }

}

```

`LibreHardwareMonitor/Utilities/IconFactory.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Runtime.InteropServices;

namespace LibreHardwareMonitor.Utilities;

public static class IconFactory
{
    private struct BITMAPINFOHEADER
    {
        public readonly uint Size;
        public readonly int Width;
        public readonly int Height;
        public readonly ushort Planes;
        public readonly ushort BitCount;
        public readonly uint Compression;
        public readonly uint SizeImage;
        public readonly int XPelsPerMeter;
        public readonly int YPelsPerMeter;
        public readonly uint ClrUsed;
        public readonly uint ClrImportant;

        public BITMAPINFOHEADER(int width, int height, int bitCount)
        {
            Size = 40;
            Width = width;
            Height = height;
            Planes = 1;
            BitCount = (ushort)bitCount;
            Compression = 0;
            SizeImage = 0;
            XPelsPerMeter = 0;
            YPelsPerMeter = 0;
            ClrUsed = 0;
            ClrImportant = 0;
        }

        public void Write(BinaryWriter bw)
        {
            bw.Write(Size);
            bw.Write(Width);
            bw.Write(Height);
            bw.Write(Planes);
            bw.Write(BitCount);
            bw.Write(Compression);
            bw.Write(SizeImage);
            bw.Write(XPelsPerMeter);
            bw.Write(YPelsPerMeter);
            bw.Write(ClrUsed);
            bw.Write(ClrImportant);
        }
    }

    private struct ICONIMAGE
    {
        public BITMAPINFOHEADER Header;
        public readonly byte[] Colors;
        public readonly int MaskSize;

        public ICONIMAGE(int width, int height, byte[] colors)
        {
            Header = new BITMAPINFOHEADER(width, height << 1, (8 * colors.Length) / (width * height));
            Colors = colors;
            MaskSize = (width * height) >> 3;
        }

        public void Write(BinaryWriter bw)
        {
            Header.Write(bw);
            int stride = Header.Width << 2;
            for (int i = (Header.Height >> 1) - 1; i >= 0; i--)
                bw.Write(Colors, i * stride, stride);
            for (int i = 0; i < 2 * MaskSize; i++)
                bw.Write((byte)0);
        }
    }

    private struct ICONDIRENTRY
    {
        public readonly byte Width;
        public readonly byte Height;
        public readonly byte ColorCount;
        public readonly byte Reserved;
        public readonly ushort Planes;
        public readonly ushort BitCount;
        public readonly uint BytesInRes;
        public uint ImageOffset;

        public ICONDIRENTRY(ICONIMAGE image, int imageOffset)
        {
            Width = (byte)image.Header.Width;
            Height = (byte)(image.Header.Height >> 1);
            ColorCount = 0;
            Reserved = 0;
            Planes = image.Header.Planes;
            BitCount = image.Header.BitCount;
            BytesInRes = (uint)(image.Header.Size + image.Colors.Length + image.MaskSize + image.MaskSize);
            ImageOffset = (uint)imageOffset;
        }

        public void Write(BinaryWriter bw)
        {
            bw.Write(Width);
            bw.Write(Height);
            bw.Write(ColorCount);
            bw.Write(Reserved);
            bw.Write(Planes);
            bw.Write(BitCount);
            bw.Write(BytesInRes);
            bw.Write(ImageOffset);
        }

        public uint Size
        {
            get { return 16; }
        }
    }

    private struct ICONDIR
    {
        public readonly ushort Reserved;
        public readonly ushort Type;
        public readonly ushort Count;
        public readonly ICONDIRENTRY[] Entries;

        public ICONDIR(ICONDIRENTRY[] entries)
        {
            Reserved = 0;
            Type = 1;
            Count = (ushort)entries.Length;
            Entries = entries;
        }

        public void Write(BinaryWriter bw)
        {
            bw.Write(Reserved);
            bw.Write(Type);
            bw.Write(Count);
            for (int i = 0; i < Entries.Length; i++)
                Entries[i].Write(bw);
        }

        public uint Size
        {
            get
            {
                return (uint)(6 + Entries.Length * (Entries.Length > 0 ? Entries[0].Size : 0));
            }
        }
    }

    private static readonly BinaryWriter BinaryWriter = new BinaryWriter(new MemoryStream());

    public static Icon Create(byte[] colors, int width, int height, PixelFormat format)
    {
        if (format != PixelFormat.Format32bppArgb)
            throw new NotImplementedException();

        ICONIMAGE image = new ICONIMAGE(width, height, colors);
        ICONDIR dir = new ICONDIR(new[] { new ICONDIRENTRY(image, 0) });
        dir.Entries[0].ImageOffset = dir.Size;

        BinaryWriter.BaseStream.Position = 0;
        dir.Write(BinaryWriter);
        image.Write(BinaryWriter);

        BinaryWriter.BaseStream.Position = 0;
        Icon icon = new Icon(BinaryWriter.BaseStream);

        return icon;
    }

    [DllImport("user32", SetLastError = true)]
    static extern bool DestroyIcon(IntPtr handle);

    public static Icon Create(Bitmap bitmap)
    {
        IntPtr hIcon = bitmap.GetHicon();
        Icon icon = Icon.FromHandle(hIcon);

        return icon;
    }

    public static void Destroy(this Icon icon)
    {
        DestroyIcon(icon.Handle);
        icon.Dispose();
    }
}
```

`LibreHardwareMonitor/Utilities/Logger.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using LibreHardwareMonitor.Hardware;

namespace LibreHardwareMonitor.Utilities;

public class Logger
{
    private const string FileNameFormat = "LibreHardwareMonitorLog-{0:yyyy-MM-dd}{1}.csv";

    private readonly IComputer _computer;

    private DateTime _day = DateTime.MinValue;
    private string _fileName;
    private string[] _identifiers;
    private ISensor[] _sensors;
    private DateTime _lastLoggedTime = DateTime.MinValue;

    public LoggerFileRotation FileRotationMethod = LoggerFileRotation.PerSession;

    public Logger(IComputer computer)
    {
        _computer = computer;
        _computer.HardwareAdded += HardwareAdded;
        _computer.HardwareRemoved += HardwareRemoved;
    }

    private void HardwareRemoved(IHardware hardware)
    {
        hardware.SensorAdded -= SensorAdded;
        hardware.SensorRemoved -= SensorRemoved;

        foreach (ISensor sensor in hardware.Sensors)
            SensorRemoved(sensor);

        foreach (IHardware subHardware in hardware.SubHardware)
            HardwareRemoved(subHardware);
    }

    private void HardwareAdded(IHardware hardware)
    {
        foreach (ISensor sensor in hardware.Sensors)
            SensorAdded(sensor);

        hardware.SensorAdded += SensorAdded;
        hardware.SensorRemoved += SensorRemoved;

        foreach (IHardware subHardware in hardware.SubHardware)
            HardwareAdded(subHardware);
    }

    private void SensorAdded(ISensor sensor)
    {
        if (_sensors == null)
            return;

        for (int i = 0; i < _sensors.Length; i++)
        {
            if (sensor.Identifier.ToString() == _identifiers[i])
                _sensors[i] = sensor;
        }
    }

    private void SensorRemoved(ISensor sensor)
    {
        if (_sensors == null)
            return;

        for (int i = 0; i < _sensors.Length; i++)
        {
            if (sensor == _sensors[i])
                _sensors[i] = null;
        }
    }

    private static string GetFileName(DateTime date, uint sessionNumber = 0)
    {
        return AppDomain.CurrentDomain.BaseDirectory + Path.DirectorySeparatorChar
            + string.Format(FileNameFormat, date, sessionNumber == 0 ? "" : "-" + sessionNumber);
    }

    private bool OpenExistingLogFile()
    {
        if (!File.Exists(_fileName))
            return false;

        try
        {
            string line;
            using (StreamReader reader = new StreamReader(_fileName))
                line = reader.ReadLine();

            if (string.IsNullOrEmpty(line))
                return false;

            _identifiers = line.Split(',').Skip(1).ToArray();
        }
        catch
        {
            _identifiers = null;
            return false;
        }

        if (_identifiers.Length == 0)
        {
            _identifiers = null;
            return false;
        }

        _sensors = new ISensor[_identifiers.Length];
        SensorVisitor visitor = new SensorVisitor(sensor =>
        {
            for (int i = 0; i < _identifiers.Length; i++)
                if (sensor.Identifier.ToString() == _identifiers[i])
                    _sensors[i] = sensor;
        });
        visitor.VisitComputer(_computer);
        return true;
    }

    private void CreateNewLogFile()
    {
        IList<ISensor> list = new List<ISensor>();
        SensorVisitor visitor = new SensorVisitor(sensor =>
        {
            list.Add(sensor);
        });
        visitor.VisitComputer(_computer);
        _sensors = list.ToArray();
        _identifiers = _sensors.Select(s => s.Identifier.ToString()).ToArray();

        using (StreamWriter writer = new StreamWriter(_fileName, false))
        {
            writer.Write(",");
            for (int i = 0; i < _sensors.Length; i++)
            {
                writer.Write(_sensors[i].Identifier);
                if (i < _sensors.Length - 1)
                    writer.Write(",");
                else
                    writer.WriteLine();
            }

            writer.Write("Time,");
            for (int i = 0; i < _sensors.Length; i++)
            {
                writer.Write('"');
                writer.Write(_sensors[i].Name);
                writer.Write('"');
                if (i < _sensors.Length - 1)
                    writer.Write(",");
                else
                    writer.WriteLine();
            }
        }
    }

    public TimeSpan LoggingInterval { get; set; }

    public void Log()
    {
        DateTime now = DateTime.Now;

        if (_lastLoggedTime + LoggingInterval - new TimeSpan(5000000) > now)
            return;

        switch (FileRotationMethod)
        {
            case LoggerFileRotation.PerSession:
                // Create file if it does not exist or the logging interval has passed (+ some margin)
                if (!File.Exists(_fileName) || now - _lastLoggedTime > (LoggingInterval + TimeSpan.FromMilliseconds(100)))
                {
                    uint sessionNumber = 1;
                    do {
                        _fileName = GetFileName(DateTime.Now, sessionNumber);
                        sessionNumber++;
                    } while (File.Exists(_fileName));
                    CreateNewLogFile();
                }
                break;
            case LoggerFileRotation.Daily:
                // Create a new file if the day has changed or the file does not exist
                if (_day != now.Date || !File.Exists(_fileName))
                {
                    _day = now.Date;
                    _fileName = GetFileName(_day);
                    if (!OpenExistingLogFile())
                        CreateNewLogFile();
                }
                break;
        }

        try
        {
            using (StreamWriter writer = new StreamWriter(new FileStream(_fileName, FileMode.Append, FileAccess.Write, FileShare.ReadWrite)))
            {
                writer.Write(now.ToString("G", CultureInfo.InvariantCulture));
                writer.Write(",");
                for (int i = 0; i < _sensors.Length; i++)
                {
                    if (_sensors[i] != null)
                    {
                        float? value = _sensors[i].Value;
                        if (value.HasValue)
                            writer.Write(value.Value.ToString("R", CultureInfo.InvariantCulture));
                    }
                    if (i < _sensors.Length - 1)
                        writer.Write(",");
                    else
                        writer.WriteLine();
                }
            }
        }
        catch (IOException) { }

        _lastLoggedTime = now;
    }
}
```

`LibreHardwareMonitor/Utilities/LoggerFileRotation.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace LibreHardwareMonitor.Utilities
{
    public enum LoggerFileRotation
    {
        // Keep the same file for the entire record session
        PerSession = 0,

        // Create a new file every day
        Daily,
    }
}

```

`LibreHardwareMonitor/Utilities/PersistentSettings.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Collections.Generic;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Text;
using System.Xml;
using LibreHardwareMonitor.Hardware;

namespace LibreHardwareMonitor.Utilities;

public class PersistentSettings : ISettings
{
    private readonly IDictionary<string, string> _settings = new Dictionary<string, string>();

    public void Load(string fileName)
    {
        XmlDocument doc = new XmlDocument();
        try
        {
            doc.Load(fileName);
        }
        catch
        {
            try
            {
                File.Delete(fileName);
            }
            catch { }

            string backupFileName = fileName + ".backup";
            try
            {
                doc.Load(backupFileName);
            }
            catch
            {
                try
                {
                    File.Delete(backupFileName);
                }
                catch { }

                return;
            }
        }

        XmlNodeList list = doc.GetElementsByTagName("appSettings");
        foreach (XmlNode node in list)
        {
            XmlNode parent = node.ParentNode;
            if (parent != null && parent.Name == "configuration" && parent.ParentNode is XmlDocument)
            {
                foreach (XmlNode child in node.ChildNodes)
                {
                    if (child.Name == "add")
                    {
                        XmlAttributeCollection attributes = child.Attributes;
                        XmlAttribute keyAttribute = attributes["key"];
                        XmlAttribute valueAttribute = attributes["value"];
                        if (keyAttribute != null && valueAttribute != null && keyAttribute.Value != null)
                        {
                            _settings.Add(keyAttribute.Value, valueAttribute.Value);
                        }
                    }
                }
            }
        }
    }

    public void Save(string fileName)
    {
        XmlDocument doc = new XmlDocument();
        doc.AppendChild(doc.CreateXmlDeclaration("1.0", "utf-8", null));
        XmlElement configuration = doc.CreateElement("configuration");
        doc.AppendChild(configuration);
        XmlElement appSettings = doc.CreateElement("appSettings");
        configuration.AppendChild(appSettings);
        foreach (KeyValuePair<string, string> keyValuePair in _settings)
        {
            XmlElement add = doc.CreateElement("add");
            add.SetAttribute("key", keyValuePair.Key);
            add.SetAttribute("value", keyValuePair.Value);
            appSettings.AppendChild(add);
        }

        byte[] file;
        using (var memory = new MemoryStream())
        {
            using (var writer = new StreamWriter(memory, Encoding.UTF8))
            {
                doc.Save(writer);
            }
            file = memory.ToArray();
        }

        string backupFileName = fileName + ".backup";
        if (File.Exists(fileName))
        {
            try
            {
                File.Delete(backupFileName);
            }
            catch { }
            try
            {
                File.Move(fileName, backupFileName);
            }
            catch { }
        }

        using (var stream = new FileStream(fileName, FileMode.Create, FileAccess.Write))
        {
            stream.Write(file, 0, file.Length);
        }

        try
        {
            File.Delete(backupFileName);
        }
        catch { }
    }

    public bool Contains(string name)
    {
        return _settings.ContainsKey(name);
    }

    public void SetValue(string name, string value)
    {
        _settings[name] = value;
    }

    public string GetValue(string name, string value)
    {
        if (_settings.TryGetValue(name, out string result))
            return result;


        return value;
    }

    public void Remove(string name)
    {
        _settings.Remove(name);
    }

    public void SetValue(string name, int value)
    {
        _settings[name] = value.ToString();
    }

    public int GetValue(string name, int value)
    {
        if (_settings.TryGetValue(name, out string str))
        {
            if (int.TryParse(str, out int parsedValue))
                return parsedValue;


            return value;
        }

        return value;
    }

    public void SetValue(string name, float value)
    {
        _settings[name] = value.ToString(CultureInfo.InvariantCulture);
    }

    public float GetValue(string name, float value)
    {
        if (_settings.TryGetValue(name, out string str))
        {
            if (float.TryParse(str, NumberStyles.Float, CultureInfo.InvariantCulture, out float parsedValue))
                return parsedValue;
        }

        return value;

    }

    public double GetValue(string name, double value)
    {
        if (_settings.TryGetValue(name, out string str))
        {
            if (double.TryParse(str, NumberStyles.Float, CultureInfo.InvariantCulture, out double parsedValue))
                return parsedValue;
        }

        return value;
    }
        
    public void SetValue(string name, bool value)
    {
        _settings[name] = value ? "true" : "false";
    }

    public bool GetValue(string name, bool value)
    {
        if (_settings.TryGetValue(name, out string str))
        {
            return str == "true";
        }

        return value;
    }

    public void SetValue(string name, Color color)
    {
        _settings[name] = color.ToArgb().ToString("X8");
    }

    public Color GetValue(string name, Color value)
    {
        if (_settings.TryGetValue(name, out string str))
        {
            if (int.TryParse(str, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out int parsedValue))
                return Color.FromArgb(parsedValue);
        }

        return value;
    }
}
```

`LibreHardwareMonitorLib/Hardware/Battery/Battery.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using Windows.Win32;
using Windows.Win32.Foundation;
using Windows.Win32.System.Power;
using LibreHardwareMonitor.Interop;
using Microsoft.Win32.SafeHandles;

namespace LibreHardwareMonitor.Hardware.Battery;

internal sealed class Battery : Hardware
{
    private readonly SafeFileHandle _batteryHandle;
    private readonly uint _batteryTag;
    private readonly Sensor _chargeDischargeCurrent;
    private readonly Sensor _chargeDischargeRate;
    private readonly Sensor _chargeLevel;
    private readonly Sensor _degradationLevel;
    private readonly Sensor _designedCapacity;
    private readonly Sensor _fullChargedCapacity;
    private readonly Sensor _remainingCapacity;
    private readonly Sensor _remainingTime;
    private readonly Sensor _temperature;
    private readonly Sensor _voltage;

    public Battery
    (
        string name,
        string manufacturer,
        SafeFileHandle batteryHandle,
        BATTERY_INFORMATION batteryInfo,
        uint batteryTag,
        ISettings settings) :
        base(name, new Identifier("battery", $"{name.Replace(' ', '-')}_{batteryTag}"), settings)
    {
        Manufacturer = manufacturer;

        _batteryTag = batteryTag;
        _batteryHandle = batteryHandle;

        byte[] chemistry = batteryInfo.Chemistry.ToArray();

        if ("PbAc"u8.SequenceEqual(chemistry))
        {
            Chemistry = BatteryChemistry.LeadAcid;
        }
        else if ("LION"u8.SequenceEqual(chemistry) || "Li-I"u8.SequenceEqual(chemistry))
        {
            Chemistry = BatteryChemistry.LithiumIon;
        }
        else if ("NiCd"u8.SequenceEqual(chemistry))
        {
            Chemistry = BatteryChemistry.NickelCadmium;
        }
        else if ("NiMH"u8.SequenceEqual(chemistry))
        {
            Chemistry = BatteryChemistry.NickelMetalHydride;
        }
        else if ("NiZn"u8.SequenceEqual(chemistry))
        {
            Chemistry = BatteryChemistry.NickelZinc;
        }
        else if ("RAM"u8.SequenceEqual(chemistry))
        {
            Chemistry = BatteryChemistry.AlkalineManganese;
        }
        else
        {
            Chemistry = BatteryChemistry.Unknown;
        }

        _designedCapacity = new Sensor("Designed Capacity", 0, SensorType.Energy, this, settings);
        _fullChargedCapacity = new Sensor("Fully-Charged Capacity", 1, SensorType.Energy, this, settings);
        _degradationLevel = new Sensor("Degradation Level", 1, SensorType.Level, this, settings);
        _chargeLevel = new Sensor("Charge Level", 0, SensorType.Level, this, settings);
        _voltage = new Sensor("Voltage", 0, SensorType.Voltage, this, settings);
        _remainingCapacity = new Sensor("Remaining Capacity", 2, SensorType.Energy, this, settings);
        _chargeDischargeCurrent = new Sensor("Charge/Discharge Current", 0, SensorType.Current, this, settings);
        _chargeDischargeRate = new Sensor("Charge/Discharge Rate", 0, SensorType.Power, this, settings);
        _remainingTime = new Sensor("Remaining Time (Estimated)", 0, SensorType.TimeSpan, this, settings);
        _temperature = new Sensor("Battery Temperature", 0, SensorType.Temperature, this, settings);

        if (batteryInfo.FullChargedCapacity is not PInvoke.BATTERY_UNKNOWN_CAPACITY &&
            batteryInfo.DesignedCapacity is not PInvoke.BATTERY_UNKNOWN_CAPACITY)
        {
            _designedCapacity.Value = batteryInfo.DesignedCapacity;
            _fullChargedCapacity.Value = batteryInfo.FullChargedCapacity;
            _degradationLevel.Value = 100f - (batteryInfo.FullChargedCapacity * 100f / batteryInfo.DesignedCapacity);
            DesignedCapacity = batteryInfo.DesignedCapacity;
            FullChargedCapacity = batteryInfo.FullChargedCapacity;

            ActivateSensor(_designedCapacity);
            ActivateSensor(_fullChargedCapacity);
            ActivateSensor(_degradationLevel);
        }
    }

    public float? ChargeDischargeCurrent { get; private set; }

    public float? ChargeDischargeRate { get; private set; }

    public float? ChargeLevel => _chargeLevel.Value;

    public BatteryChemistry Chemistry { get; }

    public float? DegradationLevel => _degradationLevel.Value;

    public float? DesignedCapacity { get; }

    public float? FullChargedCapacity { get; }

    public override HardwareType HardwareType => HardwareType.Battery;

    public string Manufacturer { get; }

    public float? RemainingCapacity => _remainingCapacity.Value;

    public float? RemainingTime => _remainingTime.Value;

    public float? Temperature => _temperature.Value;

    public float? Voltage => _voltage.Value;

    private void ActivateSensorIfValueNotNull(ISensor sensor)
    {
        if (sensor.Value != null)
            ActivateSensor(sensor);
        else
            DeactivateSensor(sensor);
    }

    public override unsafe void Update()
    {
        BATTERY_WAIT_STATUS bws = default;
        bws.BatteryTag = _batteryTag;
        BATTERY_STATUS batteryStatus = default;
        if (PInvoke.DeviceIoControl((HANDLE)_batteryHandle.DangerousGetHandle(),
                                    PInvoke.IOCTL_BATTERY_QUERY_STATUS,
                                    &bws,
                                    (uint)sizeof(BATTERY_WAIT_STATUS),
                                    &batteryStatus,
                                    (uint)sizeof(BATTERY_STATUS),
                                    null,
                                    null))
        {
            if (batteryStatus.Capacity != PInvoke.BATTERY_UNKNOWN_CAPACITY)
                _remainingCapacity.Value = batteryStatus.Capacity;
            else
                _remainingCapacity.Value = null;

            _chargeLevel.Value = _remainingCapacity.Value * 100f / _fullChargedCapacity.Value;

            if (batteryStatus.Voltage is not PInvoke.BATTERY_UNKNOWN_VOLTAGE)
                _voltage.Value = batteryStatus.Voltage / 1000f;
            else
                _voltage.Value = null;

            if ((uint)batteryStatus.Rate is PInvoke.BATTERY_UNKNOWN_RATE)
            {
                ChargeDischargeCurrent = null;
                _chargeDischargeCurrent.Value = null;

                ChargeDischargeRate = null;
                _chargeDischargeRate.Value = null;
            }
            else
            {
                float rateWatts = batteryStatus.Rate / 1000f;
                ChargeDischargeRate = rateWatts;
                _chargeDischargeRate.Value = Math.Abs(rateWatts);

                float? current = rateWatts / _voltage.Value;
                ChargeDischargeCurrent = current;
                if (current is not null)
                    _chargeDischargeCurrent.Value = Math.Abs(current.Value);
                else
                    _chargeDischargeCurrent.Value = null;

                if (rateWatts > 0)
                {
                    _chargeDischargeRate.Name = "Charge Rate";
                    _chargeDischargeCurrent.Name = "Charge Current";
                }
                else if (rateWatts < 0)
                {
                    _chargeDischargeRate.Name = "Discharge Rate";
                    _chargeDischargeCurrent.Name = "Discharge Current";
                }
                else
                {
                    _chargeDischargeRate.Name = "Charge/Discharge Rate";
                    _chargeDischargeCurrent.Name = "Charge/Discharge Current";
                }
            }
        }

        uint estimatedRunTime = 0;
        BATTERY_QUERY_INFORMATION bqi = default;
        bqi.BatteryTag = _batteryTag;
        bqi.InformationLevel = BATTERY_QUERY_INFORMATION_LEVEL.BatteryEstimatedTime;
        if (PInvoke.DeviceIoControl((HANDLE)_batteryHandle.DangerousGetHandle(),
                                     PInvoke.IOCTL_BATTERY_QUERY_INFORMATION,
                                     &bqi,
                                     (uint)sizeof(BATTERY_QUERY_INFORMATION),
                                     &estimatedRunTime,
                                     sizeof(uint),
                                     null,
                                     null))
        {
            if (estimatedRunTime != PInvoke.BATTERY_UNKNOWN_TIME)
                _remainingTime.Value = estimatedRunTime;
            else
                _remainingTime.Value = null;
        }
        else
        {
            _remainingTime.Value = null;
        }

        uint temperature = 0;
        bqi.InformationLevel = BATTERY_QUERY_INFORMATION_LEVEL.BatteryTemperature;
        if (PInvoke.DeviceIoControl((HANDLE)_batteryHandle.DangerousGetHandle(),
                                    PInvoke.IOCTL_BATTERY_QUERY_INFORMATION,
                                    &bqi,
                                    (uint)sizeof(BATTERY_QUERY_INFORMATION),
                                    &temperature,
                                    sizeof(uint),
                                    null,
                                    null))
        {
            _temperature.Value = (temperature / 10f) - 273.15f;
        }
        else
        {
            _temperature.Value = null;
        }

        ActivateSensorIfValueNotNull(_remainingCapacity);
        ActivateSensorIfValueNotNull(_chargeLevel);
        ActivateSensorIfValueNotNull(_voltage);
        ActivateSensorIfValueNotNull(_chargeDischargeCurrent);
        ActivateSensorIfValueNotNull(_chargeDischargeRate);
        ActivateSensorIfValueNotNull(_remainingTime);
        ActivateSensorIfValueNotNull(_temperature);
    }

    public override void Close()
    {
        base.Close();
        _batteryHandle.Close();
    }
}

```

`LibreHardwareMonitorLib/Hardware/Battery/BatteryChemistry.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware.Battery;

internal enum BatteryChemistry
{
    Unknown,
    LeadAcid,
    NickelCadmium,
    NickelMetalHydride,
    LithiumIon,
    NickelZinc,
    AlkalineManganese
}

```

`LibreHardwareMonitorLib/Hardware/Battery/BatteryGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using Windows.Win32;
using Windows.Win32.Devices.DeviceAndDriverInstallation;
using Windows.Win32.Foundation;
using Windows.Win32.Storage.FileSystem;
using Windows.Win32.System.Power;
using LibreHardwareMonitor.Interop;
using Microsoft.Win32.SafeHandles;

namespace LibreHardwareMonitor.Hardware.Battery;

internal class BatteryGroup : IGroup
{
    private readonly List<Battery> _hardware = [];

    public unsafe BatteryGroup(ISettings settings)
    {
        // No implementation for battery information on Unix systems
        if (Software.OperatingSystem.IsUnix)
            return;

        SetupDiDestroyDeviceInfoListSafeHandle hdev = PInvoke.SetupDiGetClassDevs(PInvoke.GUID_DEVICE_BATTERY,
                                                                                  null,
                                                                                  HWND.Null,
                                                                                  SETUP_DI_GET_CLASS_DEVS_FLAGS.DIGCF_PRESENT | SETUP_DI_GET_CLASS_DEVS_FLAGS.DIGCF_DEVICEINTERFACE);

        if (!hdev.IsInvalid)
        {
            for (uint i = 0;; i++)
            {
                SP_DEVICE_INTERFACE_DATA data = default;
                data.cbSize = (uint)sizeof(SP_DEVICE_INTERFACE_DATA);

                if (!PInvoke.SetupDiEnumDeviceInterfaces(hdev,
                                                         null,
                                                         PInvoke.GUID_DEVICE_BATTERY,
                                                         i,
                                                         ref data))
                {
                    if (Marshal.GetLastWin32Error() == (int)WIN32_ERROR.ERROR_NO_MORE_ITEMS)
                        break;
                }
                else
                {
                    uint cbRequired = 0;

                    PInvoke.SetupDiGetDeviceInterfaceDetail((HDEVINFO)hdev.DangerousGetHandle(),
                                                            &data,
                                                            null,
                                                            0,
                                                            &cbRequired,
                                                            null);

                    if (Marshal.GetLastWin32Error() == (int)WIN32_ERROR.ERROR_INSUFFICIENT_BUFFER)
                    {
                        IntPtr buffer = Marshal.AllocHGlobal((int)cbRequired);
                        SP_DEVICE_INTERFACE_DETAIL_DATA_W* pDetailData = (SP_DEVICE_INTERFACE_DETAIL_DATA_W*)buffer;
                        pDetailData->cbSize = (uint)sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_W);

                        if (PInvoke.SetupDiGetDeviceInterfaceDetail((HDEVINFO)hdev.DangerousGetHandle(),
                                                                    &data,
                                                                    pDetailData,
                                                                    cbRequired,
                                                                    &cbRequired,
                                                                    null))
                        {
                            string devicePath;

                            fixed (void* pDevicePath = &pDetailData->DevicePath.e0)
                                devicePath = new string((char*)pDevicePath);

                            SafeFileHandle battery = PInvoke.CreateFile(devicePath, (uint)FileAccess.ReadWrite, FILE_SHARE_MODE.FILE_SHARE_READ | FILE_SHARE_MODE.FILE_SHARE_WRITE, null, FILE_CREATION_DISPOSITION.OPEN_EXISTING, FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_NORMAL, null);
                            if (!battery.IsInvalid)
                            {
                                BATTERY_QUERY_INFORMATION bqi = default;

                                uint dwWait = 0;
                                uint bytesReturned = 0;
                                if (PInvoke.DeviceIoControl((HANDLE)battery.DangerousGetHandle(),
                                                            PInvoke.IOCTL_BATTERY_QUERY_TAG,
                                                            &dwWait,
                                                            sizeof(uint),
                                                            &bqi.BatteryTag,
                                                            sizeof(uint),
                                                            &bytesReturned,
                                                            null))
                                {
                                    BATTERY_INFORMATION bi = default;
                                    bqi.InformationLevel = BATTERY_QUERY_INFORMATION_LEVEL.BatteryInformation;

                                    if (PInvoke.DeviceIoControl((HANDLE)battery.DangerousGetHandle(),
                                                                PInvoke.IOCTL_BATTERY_QUERY_INFORMATION,
                                                                &bqi,
                                                                (uint)sizeof(BATTERY_QUERY_INFORMATION),
                                                                &bi,
                                                                (uint)sizeof(BATTERY_INFORMATION),
                                                                &bytesReturned,
                                                                null))
                                    {
                                        // Only batteries count.

                                        if ((bi.Capabilities & PInvoke.BATTERY_SYSTEM_BATTERY) == PInvoke.BATTERY_SYSTEM_BATTERY)
                                        {
                                            bqi.InformationLevel = BATTERY_QUERY_INFORMATION_LEVEL.BatteryDeviceName;
                                            QueryStringFromBatteryInfo(battery, bqi, out string batteryName);
                                            bqi.InformationLevel = BATTERY_QUERY_INFORMATION_LEVEL.BatteryManufactureName;
                                            QueryStringFromBatteryInfo(battery, bqi, out string manufacturer);

                                            _hardware.Add(new Battery(batteryName, manufacturer, battery, bi, bqi.BatteryTag, settings));
                                        }
                                    }
                                }
                            }
                        }

                        Marshal.FreeHGlobal(buffer);
                    }
                }
            }

            hdev.Dispose();
        }
    }

    /// <inheritdoc />
    public IReadOnlyList<IHardware> Hardware => _hardware;

    private static unsafe bool QueryStringFromBatteryInfo(SafeFileHandle battery, BATTERY_QUERY_INFORMATION bqi, out string value)
    {
        value = null;
        bool result = false;

        Span<char> span = stackalloc char[100];

        fixed (char* pSpan = span)
        {
            uint returnBytes = 0;

            if (PInvoke.DeviceIoControl((HANDLE)battery.DangerousGetHandle(),
                                        PInvoke.IOCTL_BATTERY_QUERY_INFORMATION,
                                        &bqi,
                                        (uint)sizeof(BATTERY_QUERY_INFORMATION),
                                        pSpan,
                                        200,
                                        &returnBytes,
                                        null))
            {
                value = new string(pSpan);
                result = true;
            }
        }

        return result;
    }

    /// <inheritdoc />
    public void Close()
    {
        foreach (Battery battery in _hardware)
            battery.Close();
    }

    /// <inheritdoc />
    public string GetReport()
    {
        StringBuilder reportBuilder = new();

        uint count = 1;

        foreach (Battery bat in _hardware)
        {
            string chemistry = bat.Chemistry switch
            {
                BatteryChemistry.LeadAcid => "Lead Acid",
                BatteryChemistry.NickelCadmium => "Nickel-Cadmium",
                BatteryChemistry.NickelMetalHydride => "Nickel-Metal Hydride",
                BatteryChemistry.LithiumIon => "Lithium Ion",
                BatteryChemistry.NickelZinc => "Nickel-Zinc",
                BatteryChemistry.AlkalineManganese => "Rechargeable Alkaline-Manganese",
                _ => "Unknown"
            };

            reportBuilder.Append("Battery #").Append(count).AppendLine(":")
                         .Append(" Name: ").AppendLine(bat.Name)
                         .Append(" Manufacturer: ").AppendLine(bat.Manufacturer)
                         .Append(" Chemistry: ").AppendLine(chemistry);

            if (bat.DegradationLevel.HasValue)
                reportBuilder.Append(" Degradation Level: ").AppendFormat("{0:F2}", bat.DegradationLevel).AppendLine(" %");

            if (bat.DesignedCapacity.HasValue)
                reportBuilder.Append(" Designed Capacity: ").Append(bat.DesignedCapacity).AppendLine(" mWh");

            if (bat.FullChargedCapacity.HasValue)
                reportBuilder.Append(" Fully-Charged Capacity: ").Append(bat.FullChargedCapacity).AppendLine(" mWh");

            if (bat.RemainingCapacity.HasValue)
                reportBuilder.Append(" Remaining Capacity: ").Append(bat.RemainingCapacity).AppendLine(" mWh");

            if (bat.ChargeLevel.HasValue)
                reportBuilder.Append(" Charge Level: ").AppendFormat("{0:F2}", bat.ChargeLevel).AppendLine(" %");

            if (bat.Voltage.HasValue)
                reportBuilder.Append(" Voltage: ").AppendFormat("{0:F3}", bat.Voltage).AppendLine(" V");

            if (bat.Temperature.HasValue)
                reportBuilder.Append(" Temperature: ").AppendFormat("{0:F3}", bat.Temperature).AppendLine(" ºC");

            if (bat.RemainingTime.HasValue)
                reportBuilder.Append(" Remaining Time (Estimated): ").AppendFormat("{0:g}", TimeSpan.FromSeconds(bat.RemainingTime.Value)).AppendLine();

            string cdRateSensorName;
            string cdCurrentSensorName;
            if (bat.ChargeDischargeRate > 0)
            {
                cdRateSensorName = " Charge Rate: ";
                cdCurrentSensorName = " Charge Current: ";
            }
            else if (bat.ChargeDischargeRate < 0)
            {
                cdRateSensorName = " Discharge Rate: ";
                cdCurrentSensorName = " Discharge Current: ";
            }
            else
            {
                cdRateSensorName = " Charge/Discharge Rate: ";
                cdCurrentSensorName = " Charge/Discharge Current: ";
            }

            if (bat.ChargeDischargeRate.HasValue)
                reportBuilder.Append(cdRateSensorName).AppendFormat("{0:F1}", Math.Abs(bat.ChargeDischargeRate.Value)).AppendLine(" W");

            if (bat.ChargeDischargeCurrent.HasValue)
                reportBuilder.Append(cdCurrentSensorName).AppendFormat("{0:F3}", Math.Abs(bat.ChargeDischargeCurrent.Value)).AppendLine(" A");

            reportBuilder.AppendLine();
            count++;
        }

        return reportBuilder.ToString();
    }
}

```

`LibreHardwareMonitorLib/Hardware/CompositeSensor.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Linq;

namespace LibreHardwareMonitor.Hardware;

internal class CompositeSensor : Sensor
{
    private readonly ISensor[] _components;
    private readonly Func<float, ISensor, float> _reducer;
    private readonly float _seedValue;

    public CompositeSensor
    (
        string name,
        int index,
        SensorType sensorType,
        Hardware hardware,
        ISettings settings,
        ISensor[] components,
        Func<float, ISensor, float> reducer,
        float seedValue = .0f)
        : base(name, index, sensorType, hardware, settings)
    {
        _components = components;
        _reducer = reducer;
        _seedValue = seedValue;
    }

    public override float? Value
    {
        get { return _components.Aggregate(_seedValue, _reducer); }
        set => throw new NotImplementedException();
    }
}
```

`LibreHardwareMonitorLib/Hardware/Computer.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using LibreHardwareMonitor.Hardware.Battery;
using LibreHardwareMonitor.Hardware.Controller.AeroCool;
using LibreHardwareMonitor.Hardware.Controller.AquaComputer;
using LibreHardwareMonitor.Hardware.Controller.Arctic;
using LibreHardwareMonitor.Hardware.Controller.Heatmaster;
using LibreHardwareMonitor.Hardware.Controller.MSI;
using LibreHardwareMonitor.Hardware.Controller.Nzxt;
using LibreHardwareMonitor.Hardware.Controller.Razer;
using LibreHardwareMonitor.Hardware.Controller.TBalancer;
using LibreHardwareMonitor.Hardware.Cpu;
using LibreHardwareMonitor.Hardware.Gpu;
using LibreHardwareMonitor.Hardware.Memory;
using LibreHardwareMonitor.Hardware.Motherboard;
using LibreHardwareMonitor.Hardware.Network;
using LibreHardwareMonitor.Hardware.PowerMonitor;
using LibreHardwareMonitor.Hardware.Psu.Corsair;
using LibreHardwareMonitor.Hardware.Psu.Msi;
using LibreHardwareMonitor.Hardware.Storage;

namespace LibreHardwareMonitor.Hardware;

/// <summary>
/// Stores all hardware groups and decides which devices should be enabled and updated.
/// </summary>
public class Computer : IComputer
{
    private readonly List<IGroup> _groups = new();
    private readonly object _lock = new();
    private readonly ISettings _settings;

    private bool _batteryEnabled;
    private bool _controllerEnabled;
    private bool _cpuEnabled;
    private bool _gpuEnabled;
    private bool _powerMonitorEnabled;
    private bool _memoryEnabled;
    private bool _motherboardEnabled;
    private bool _networkEnabled;
    private bool _open;
    private bool _psuEnabled;
    private SMBios _smbios;
    private bool _storageEnabled;

    /// <summary>
    /// Creates a new <see cref="IComputer" /> instance with basic initial <see cref="Settings" />.
    /// </summary>
    public Computer()
    {
        _settings = new Settings();
    }

    /// <summary>
    /// Creates a new <see cref="IComputer" /> instance with additional <see cref="ISettings" />.
    /// </summary>
    /// <param name="settings">Computer settings that will be transferred to each <see cref="IHardware" />.</param>
    public Computer(ISettings settings)
    {
        _settings = settings ?? new Settings();
    }

    /// <inheritdoc />
    public event HardwareEventHandler HardwareAdded;

    /// <inheritdoc />
    public event HardwareEventHandler HardwareRemoved;

    /// <inheritdoc />
    public IList<IHardware> Hardware
    {
        get
        {
            lock (_lock)
            {
                List<IHardware> list = new();

                foreach (IGroup group in _groups)
                    list.AddRange(group.Hardware);

                return list;
            }
        }
    }

    /// <inheritdoc />
    public bool IsBatteryEnabled
    {
        get { return _batteryEnabled; }
        set
        {
            if (_open && value != _batteryEnabled)
            {
                if (value)
                {
                    Add(new BatteryGroup(_settings));
                }
                else
                {
                    RemoveType<BatteryGroup>();
                }
            }

            _batteryEnabled = value;
        }
    }

    /// <inheritdoc />
    public bool IsControllerEnabled
    {
        get { return _controllerEnabled; }
        set
        {
            if (_open && value != _controllerEnabled)
            {
                if (value)
                {
                    Add(new TBalancerGroup(_settings));
                    Add(new HeatmasterGroup(_settings));
                    Add(new AquaComputerGroup(_settings));
                    Add(new AeroCoolGroup(_settings));
                    Add(new NzxtGroup(_settings));
                    Add(new RazerGroup(_settings));
                    Add(new ArcticGroup(_settings));
                    Add(new MsiGroup(_settings));
                }
                else
                {
                    RemoveType<TBalancerGroup>();
                    RemoveType<HeatmasterGroup>();
                    RemoveType<AquaComputerGroup>();
                    RemoveType<AeroCoolGroup>();
                    RemoveType<NzxtGroup>();
                    RemoveType<RazerGroup>();
                    RemoveType<ArcticGroup>();
                    RemoveType<MsiGroup>();
                }
            }

            _controllerEnabled = value;
        }
    }

    /// <inheritdoc />
    public bool IsCpuEnabled
    {
        get { return _cpuEnabled; }
        set
        {
            if (_open && value != _cpuEnabled)
            {
                if (value)
                    Add(new CpuGroup(_settings));
                else
                    RemoveType<CpuGroup>();
            }

            _cpuEnabled = value;
        }
    }

    /// <inheritdoc />
    public bool IsGpuEnabled
    {
        get { return _gpuEnabled; }
        set
        {
            if (_open && value != _gpuEnabled)
            {
                if (value)
                {
                    Add(new AmdGpuGroup(_settings));
                    Add(new NvidiaGroup(_settings));

                    if (_cpuEnabled)
                        Add(new IntelGpuGroup(GetIntelCpus(), _settings));
                }
                else
                {
                    RemoveType<AmdGpuGroup>();
                    RemoveType<NvidiaGroup>();
                    RemoveType<IntelGpuGroup>();
                }
            }

            _gpuEnabled = value;
        }
    }

    /// <inheritdoc />
    public bool IsPowerMonitorEnabled
    {
        get { return _powerMonitorEnabled; }
        set
        {
            if (_open && value != _powerMonitorEnabled)
            {
                if (value)
                    Add(new PowerMonitorGroup(_settings));
                else
                    RemoveType<PowerMonitorGroup>();
            }

            _powerMonitorEnabled = value;
        }
    }

    /// <inheritdoc />
    public bool IsMemoryEnabled
    {
        get { return _memoryEnabled; }
        set
        {
            if (_open && value != _memoryEnabled)
            {
                if (value)
                    Add(new MemoryGroup(_settings));
                else
                    RemoveType<MemoryGroup>();
            }

            _memoryEnabled = value;
        }
    }

    /// <inheritdoc />
    public bool IsMotherboardEnabled
    {
        get { return _motherboardEnabled; }
        set
        {
            if (_open && value != _motherboardEnabled)
            {
                if (value)
                    Add(new MotherboardGroup(_smbios, _settings));
                else
                    RemoveType<MotherboardGroup>();
            }

            _motherboardEnabled = value;
        }
    }

    /// <inheritdoc />
    public bool IsNetworkEnabled
    {
        get { return _networkEnabled; }
        set
        {
            if (_open && value != _networkEnabled)
            {
                if (value)
                    Add(new NetworkGroup(_settings));
                else
                    RemoveType<NetworkGroup>();
            }

            _networkEnabled = value;
        }
    }

    /// <inheritdoc />
    public bool IsPsuEnabled
    {
        get { return _psuEnabled; }
        set
        {
            if (_open && value != _psuEnabled)
            {
                if (value)
                {
                    Add(new CorsairPsuGroup(_settings));
                    Add(new MsiPsuGroup(_settings));
                }
                else
                {
                    RemoveType<CorsairPsuGroup>();
                    RemoveType<MsiPsuGroup>();
                }
            }

            _psuEnabled = value;
        }
    }

    /// <inheritdoc />
    public bool IsStorageEnabled
    {
        get { return _storageEnabled; }
        set
        {
            if (_open && value != _storageEnabled)
            {
                if (value)
                    Add(new StorageGroup(_settings));
                else
                    RemoveType<StorageGroup>();
            }

            _storageEnabled = value;
        }
    }

    /// <summary>
    /// Contains computer information table read in accordance with <see href="https://www.dmtf.org/standards/smbios">System Management BIOS (SMBIOS) Reference Specification</see>.
    /// </summary>
    public SMBios SMBios
    {
        get
        {
            if (!_open)
                throw new InvalidOperationException("SMBIOS cannot be accessed before opening.");

            return _smbios;
        }
    }

    //// <inheritdoc />
    public string GetReport()
    {
        lock (_lock)
        {
            using StringWriter w = new(CultureInfo.InvariantCulture);

            w.WriteLine();
            w.WriteLine(nameof(LibreHardwareMonitor) + " Report");
            w.WriteLine();

            Version version = typeof(Computer).Assembly.GetName().Version;

            NewSection(w);
            w.Write("Version: ");
            w.WriteLine(version.ToString());
            w.WriteLine();

            NewSection(w);
            w.Write("Common Language Runtime: ");
            w.WriteLine(Environment.Version.ToString());
            w.Write("Operating System: ");
            w.WriteLine(Environment.OSVersion.ToString());
            w.Write("Process Type: ");
            w.WriteLine(IntPtr.Size == 4 ? "32-Bit" : "64-Bit");
            w.WriteLine();

            NewSection(w);
            w.WriteLine("Sensors");
            w.WriteLine();

            foreach (IGroup group in _groups)
            {
                foreach (IHardware hardware in group.Hardware)
                    ReportHardwareSensorTree(hardware, w, string.Empty);
            }

            w.WriteLine();

            NewSection(w);
            w.WriteLine("Parameters");
            w.WriteLine();

            foreach (IGroup group in _groups)
            {
                foreach (IHardware hardware in group.Hardware)
                    ReportHardwareParameterTree(hardware, w, string.Empty);
            }

            w.WriteLine();

            foreach (IGroup group in _groups)
            {
                string report = group.GetReport();
                if (!string.IsNullOrEmpty(report))
                {
                    NewSection(w);
                    w.Write(report);
                }

                foreach (IHardware hardware in group.Hardware)
                    ReportHardware(hardware, w);
            }

            return w.ToString();
        }
    }

    /// <summary>
    /// Triggers the <see cref="IVisitor.VisitComputer" /> method for the given observer.
    /// </summary>
    /// <param name="visitor">Observer who call to devices.</param>
    public void Accept(IVisitor visitor)
    {
        if (visitor == null)
            throw new ArgumentNullException(nameof(visitor));

        visitor.VisitComputer(this);
    }

    /// <summary>
    /// Triggers the <see cref="IElement.Accept" /> method with the given visitor for each device in each group.
    /// </summary>
    /// <param name="visitor">Observer who call to devices.</param>
    public void Traverse(IVisitor visitor)
    {
        lock (_lock)
        {
            // Use a for-loop instead of foreach to avoid a collection modified exception after sleep, even though everything is under a lock.
            for (int i = 0; i < _groups.Count; i++)
            {
                IGroup group = _groups[i];

                for (int j = 0; j < group.Hardware.Count; j++)
                    group.Hardware[j].Accept(visitor);
            }
        }
    }

    private void HardwareAddedEvent(IHardware hardware)
    {
        HardwareAdded?.Invoke(hardware);
    }

    private void HardwareRemovedEvent(IHardware hardware)
    {
        HardwareRemoved?.Invoke(hardware);
    }

    private void Add(IGroup group)
    {
        if (group == null)
            return;

        lock (_lock)
        {
            if (_groups.Contains(group))
                return;

            _groups.Add(group);

            if (group is IHardwareChanged hardwareChanged)
            {
                hardwareChanged.HardwareAdded += HardwareAddedEvent;
                hardwareChanged.HardwareRemoved += HardwareRemovedEvent;
            }
        }

        if (HardwareAdded != null)
        {
            foreach (IHardware hardware in group.Hardware)
                HardwareAdded(hardware);
        }
    }

    private void Remove(IGroup group)
    {
        lock (_lock)
        {
            if (!_groups.Contains(group))
                return;

            _groups.Remove(group);

            if (group is IHardwareChanged hardwareChanged)
            {
                hardwareChanged.HardwareAdded -= HardwareAddedEvent;
                hardwareChanged.HardwareRemoved -= HardwareRemovedEvent;
            }
        }

        if (HardwareRemoved != null)
        {
            foreach (IHardware hardware in group.Hardware)
                HardwareRemoved(hardware);
        }

        group.Close();
    }

    private void RemoveType<T>() where T : IGroup
    {
        List<T> list = [];

        lock (_lock)
        {
            foreach (IGroup group in _groups)
            {
                if (group is T t)
                    list.Add(t);
            }
        }

        foreach (T group in list)
            Remove(group);
    }

    /// <summary>
    /// If hasn't been opened before, opens <see cref="SMBios" />, <see cref="OpCode" /> and triggers the private <see cref="AddGroups" /> method depending on which categories are
    /// enabled.
    /// </summary>
    public void Open()
    {
        if (_open)
            return;

        _smbios = new SMBios();

        Mutexes.Open();
        OpCode.Open();

        AddGroups();

        _open = true;
    }

    private void AddGroups()
    {
        if (_motherboardEnabled)
            Add(new MotherboardGroup(_smbios, _settings));

        if (_cpuEnabled)
            Add(new CpuGroup(_settings));

        if (_memoryEnabled)
            Add(new MemoryGroup(_settings));

        if (_gpuEnabled)
        {
            Add(new AmdGpuGroup(_settings));
            Add(new NvidiaGroup(_settings));

            if (_cpuEnabled)
                Add(new IntelGpuGroup(GetIntelCpus(), _settings));
        }

        if (_powerMonitorEnabled)
            Add(new PowerMonitorGroup(_settings));

        if (_controllerEnabled)
        {
            Add(new TBalancerGroup(_settings));
            Add(new HeatmasterGroup(_settings));
            Add(new AquaComputerGroup(_settings));
            Add(new AeroCoolGroup(_settings));
            Add(new NzxtGroup(_settings));
            Add(new RazerGroup(_settings));
            Add(new ArcticGroup(_settings));
            Add(new MsiGroup(_settings));
        }

        if (_storageEnabled)
            Add(new StorageGroup(_settings));

        if (_networkEnabled)
            Add(new NetworkGroup(_settings));

        if (_psuEnabled)
        {
            Add(new CorsairPsuGroup(_settings));
            Add(new MsiPsuGroup(_settings));
        }

        if (_batteryEnabled)
            Add(new BatteryGroup(_settings));
    }

    private static void NewSection(TextWriter writer)
    {
        for (int i = 0; i < 8; i++)
            writer.Write("----------");

        writer.WriteLine();
        writer.WriteLine();
    }

    private static int CompareSensor(ISensor a, ISensor b)
    {
        int c = a.SensorType.CompareTo(b.SensorType);
        if (c == 0)
            return a.Index.CompareTo(b.Index);

        return c;
    }

    private static void ReportHardwareSensorTree(IHardware hardware, TextWriter w, string space)
    {
        w.WriteLine("{0}|", space);
        w.WriteLine("{0}+- {1} ({2})", space, hardware.Name, hardware.Identifier);

        ISensor[] sensors = hardware.Sensors;
        Array.Sort(sensors, CompareSensor);

        foreach (ISensor sensor in sensors)
            w.WriteLine("{0}|  +- {1,-14} : {2,8:G6} {3,8:G6} {4,8:G6} ({5})", space, sensor.Name, sensor.Value, sensor.Min, sensor.Max, sensor.Identifier);

        foreach (IHardware subHardware in hardware.SubHardware)
            ReportHardwareSensorTree(subHardware, w, "|  ");
    }

    private static void ReportHardwareParameterTree(IHardware hardware, TextWriter w, string space)
    {
        w.WriteLine("{0}|", space);
        w.WriteLine("{0}+- {1} ({2})", space, hardware.Name, hardware.Identifier);

        ISensor[] sensors = hardware.Sensors;
        Array.Sort(sensors, CompareSensor);

        foreach (ISensor sensor in sensors)
        {
            string innerSpace = space + "|  ";
            if (sensor.Parameters.Count > 0)
            {
                w.WriteLine("{0}|", innerSpace);
                w.WriteLine("{0}+- {1} ({2})", innerSpace, sensor.Name, sensor.Identifier);

                foreach (IParameter parameter in sensor.Parameters)
                {
                    string innerInnerSpace = innerSpace + "|  ";
                    w.WriteLine("{0}+- {1} : {2}", innerInnerSpace, parameter.Name, string.Format(CultureInfo.InvariantCulture, "{0} : {1}", parameter.DefaultValue, parameter.Value));
                }
            }
        }

        foreach (IHardware subHardware in hardware.SubHardware)
            ReportHardwareParameterTree(subHardware, w, "|  ");
    }

    private static void ReportHardware(IHardware hardware, TextWriter w)
    {
        string hardwareReport = hardware.GetReport();
        if (!string.IsNullOrEmpty(hardwareReport))
        {
            NewSection(w);
            w.Write(hardwareReport);
        }

        foreach (IHardware subHardware in hardware.SubHardware)
            ReportHardware(subHardware, w);
    }

    /// <summary>
    /// If opened before, removes all <see cref="IGroup" /> and triggers <see cref="OpCode.Close" />.
    /// </summary>
    public void Close()
    {
        if (!_open)
            return;

        lock (_lock)
        {
            while (_groups.Count > 0)
            {
                IGroup group = _groups[_groups.Count - 1];
                Remove(group);
            }
        }

        OpCode.Close();
        Mutexes.Close();

        _smbios = null;
        _open = false;
    }

    /// <summary>
    /// If opened before, removes all <see cref="IGroup" /> and recreates it.
    /// </summary>
    public void Reset()
    {
        if (!_open)
            return;

        RemoveGroups();
        AddGroups();
    }

    private void RemoveGroups()
    {
        lock (_lock)
        {
            while (_groups.Count > 0)
            {
                IGroup group = _groups[_groups.Count - 1];
                Remove(group);
            }
        }
    }

    private List<IntelCpu> GetIntelCpus()
    {
        // Create a temporary cpu group if one has not been added.
        lock (_lock)
        {
            IGroup cpuGroup = _groups.Find(x => x is CpuGroup) ?? new CpuGroup(_settings);
            return cpuGroup.Hardware.Select(x => x as IntelCpu).ToList();
        }
    }

    /// <summary>
    /// <see cref="Computer" /> specific additional settings passed to its <see cref="IHardware" />.
    /// </summary>
    private class Settings : ISettings
    {
        public bool Contains(string name)
        {
            return false;
        }

        public void SetValue(string name, string value)
        { }

        public string GetValue(string name, string value)
        {
            return value;
        }

        public void Remove(string name)
        { }
    }
}

```

`LibreHardwareMonitorLib/Hardware/Control.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Globalization;

namespace LibreHardwareMonitor.Hardware;

internal delegate void ControlEventHandler(Control control);

internal class Control : IControl
{
    private readonly ISettings _settings;
    private ControlMode _mode;
    private float _softwareValue;

    public Control
    (
        ISensor sensor,
        ISettings settings,
        float minSoftwareValue,
        float maxSoftwareValue)
    {
        _settings = settings;

        Identifier = new Identifier(sensor.Identifier, "control");
        Sensor = sensor;
        MinSoftwareValue = minSoftwareValue;
        MaxSoftwareValue = maxSoftwareValue;

        if (!float.TryParse(settings.GetValue(new Identifier(Identifier, "value").ToString(), "0"), NumberStyles.Float, CultureInfo.InvariantCulture, out _softwareValue))
            _softwareValue = 0;

        if (!int.TryParse(settings.GetValue(new Identifier(Identifier, "mode").ToString(), ((int)ControlMode.Undefined).ToString(CultureInfo.InvariantCulture)),
                          NumberStyles.Integer,
                          CultureInfo.InvariantCulture,
                          out int mode))
        {
            _mode = ControlMode.Undefined;
        }
        else
            _mode = (ControlMode)mode;
    }

    internal event ControlEventHandler ControlModeChanged;

    internal event ControlEventHandler SoftwareControlValueChanged;

    public ControlMode ControlMode
    {
        get { return _mode; }
        private set
        {
            if (_mode != value)
            {
                _mode = value;
                ControlModeChanged?.Invoke(this);
                _settings.SetValue(new Identifier(Identifier, "mode").ToString(), ((int)_mode).ToString(CultureInfo.InvariantCulture));
            }
        }
    }

    public Identifier Identifier { get; }

    public float MaxSoftwareValue { get; }

    public float MinSoftwareValue { get; }

    public ISensor Sensor { get; }

    public float SoftwareValue
    {
        get { return _softwareValue; }
        private set
        {
            if (_softwareValue != value)
            {
                _softwareValue = value;
                SoftwareControlValueChanged?.Invoke(this);
                _settings.SetValue(new Identifier(Identifier, "value").ToString(), value.ToString(CultureInfo.InvariantCulture));
            }
        }
    }

    public void SetDefault()
    {
        ControlMode = ControlMode.Default;
    }

    public void SetSoftware(float value)
    {
        ControlMode = ControlMode.Software;
        SoftwareValue = value;
    }
}

```

`LibreHardwareMonitorLib/Hardware/Controller/AeroCool/AeroCoolGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System.Collections.Generic;
using System.Text;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Controller.AeroCool;

public class AeroCoolGroup : IGroup
{
    private readonly List<IHardware> _hardware = new();
    private readonly StringBuilder _report = new();

    public AeroCoolGroup(ISettings settings)
    {
        _report.AppendLine("AeroCool Hardware");
        _report.AppendLine();

        foreach (HidDevice dev in DeviceList.Local.GetHidDevices(0x2E97))
        {
            int hubno = dev.ProductID - 0x1000;
            if (dev.DevicePath.Contains("mi_02") && hubno is >= 1 and <= 8)
            {
                var device = new P7H1(dev, settings);
                _report.AppendLine($"Device name: {device.Name}");
                _report.AppendLine($"HUB number: {device.HubNumber}");
                _report.AppendLine();
                _hardware.Add(device);
            }
        }

        if (_hardware.Count == 0)
        {
            _report.AppendLine("No AeroCool Hardware found.");
            _report.AppendLine();
        }
    }

    public IReadOnlyList<IHardware> Hardware => _hardware;

    public void Close()
    {
        foreach (IHardware iHardware in _hardware)
        {
            if (iHardware is Hardware hardware)
                hardware.Close();
        }
    }

    public string GetReport()
    {
        return _report.ToString();
    }
}
```

`LibreHardwareMonitorLib/Hardware/Controller/AeroCool/P7-H1.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Threading.Tasks;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Controller.AeroCool;

internal sealed class P7H1 : Hardware
{
    private const byte REPORT_ID = 0x0;
    private readonly HidDevice _device;

    private readonly Sensor[] _rpm = new Sensor[5];
    private readonly float[] _speeds = new float[5];
    private readonly HidStream _stream;
    private bool _running;

    public P7H1(HidDevice dev, ISettings settings) : base("AeroCool P7-H1", new Identifier(dev), settings)
    {
        _device = dev;
        HubNumber = _device.ProductID - 0x1000;
        Name = $"AeroCool P7-H1 #{HubNumber}";

        if (_device.TryOpen(out _stream))
        {
            _running = true;

            Task.Run(ReadStream);

            for (int i = 0; i < 5; i++)
            {
                _rpm[i] = new Sensor($"Fan #{i + 1}", i, SensorType.Fan, this, settings);
                ActivateSensor(_rpm[i]);
            }
        }
    }

    public override HardwareType HardwareType
    {
        get { return HardwareType.Cooler; }
    }

    public int HubNumber { get; }

    private void ReadStream()
    {
        byte[] inputReportBuffer = new byte[_device.GetMaxInputReportLength()];

        while (_running)
        {
            IAsyncResult ar = null;

            while (_running)
            {
                ar ??= _stream.BeginRead(inputReportBuffer, 0, inputReportBuffer.Length, null, null);

                if (ar.IsCompleted)
                {
                    int byteCount = _stream.EndRead(ar);
                    ar = null;

                    if (byteCount == 16 && inputReportBuffer[0] == REPORT_ID)
                    {
                        for (int i = 0; i < 5; i++)
                        {
                            _speeds[i] = (inputReportBuffer[(i * 3) + 2] * 256) + inputReportBuffer[(i * 3) + 3];
                        }
                    }
                }
                else
                {
                    ar.AsyncWaitHandle.WaitOne(1000);
                }
            }
        }
    }

    public override void Close()
    {
        _running = false;
        _stream.Close();
        base.Close();
    }

    public override void Update()
    {
        for (int i = 0; i < 5; i++)
        {
            _rpm[i].Value = _speeds[i];
        }
    }
}

```

`LibreHardwareMonitorLib/Hardware/Controller/AquaComputer/AquaComputerGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System.Collections.Generic;
using System.Text;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Controller.AquaComputer;

public class AquaComputerGroup : IGroup
{
    private readonly List<IHardware> _hardware = new();
    private readonly StringBuilder _report = new();

    public AquaComputerGroup(ISettings settings)
    {
        _report.AppendLine("AquaComputer Hardware");
        _report.AppendLine();

        foreach (HidDevice dev in DeviceList.Local.GetHidDevices(0x0c70))
        {
            string productName = dev.GetProductName();
            productName = productName.Substring(0, 1).ToUpper() + productName.Substring(1);

            switch (dev.ProductID)
            {
                case 0xF00E:
                    var d5Next = new D5Next(dev, settings);
                    _report.AppendLine($"Device name: {productName}");
                    _report.AppendLine($"Firmware version: {d5Next.FirmwareVersion}");
                    _report.AppendLine();
                    _hardware.Add(d5Next);
                    break;

                case 0xf0b6:
                    var aquastreamXt = new AquastreamXT(dev, settings);
                    _report.AppendLine($"Device name: {productName}");
                    _report.AppendLine($"Device variant: {aquastreamXt.Variant}");
                    _report.AppendLine($"Firmware version: {aquastreamXt.FirmwareVersion}");
                    _report.AppendLine($"{aquastreamXt.Status}");
                    _report.AppendLine();
                    _hardware.Add(aquastreamXt);
                    break;

                case 0xf003:
                    var mps = new MPS(dev, settings);
                    _report.AppendLine($"Device name: {productName}");
                    _report.AppendLine($"Firmware version: {mps.FirmwareVersion}");
                    _report.AppendLine($"{mps.Status}");
                    _report.AppendLine();
                    _hardware.Add(mps);
                    break;
                    
                case 0xF00D:
                    var quadro = new Quadro(dev, settings);
                    _report.AppendLine($"Device name: {productName}");
                    _report.AppendLine($"Firmware version: {quadro.FirmwareVersion}");
                    _report.AppendLine();
                    _hardware.Add(quadro);
                    break;
                    
                case 0xF00B:
                    var aquastreamUltimate = new AquastreamUltimate(dev, settings);
                    _report.AppendLine($"Device name: {productName}");
                    _report.AppendLine($"Firmware version: {aquastreamUltimate.FirmwareVersion}");
                    _report.AppendLine();
                    _hardware.Add(aquastreamUltimate);
                    break;
                    
                case 0xF011:
                    var octo = new Octo(dev, settings);
                    _report.AppendLine($"Device name: {productName}");
                    _report.AppendLine($"Firmware version: {octo.FirmwareVersion}");
                    _report.AppendLine();
                    _hardware.Add(octo);
                    break;

                case 0xF00A:
                    var farbwerk = new Farbwerk(dev, settings);
                    _report.AppendLine($"Device name: {productName}");
                    _report.AppendLine($"Firmware version: {farbwerk.FirmwareVersion}");
                    _report.AppendLine($"{farbwerk.Status}");
                    _report.AppendLine();
                    _hardware.Add(farbwerk);
                    break;
                
                case 0xF010:
                    var farbwerk360 = new Farbwerk360(dev, settings);
                    _report.AppendLine($"Device name: {productName}");
                    _report.AppendLine($"Firmware version: {farbwerk360.FirmwareVersion}");
                    _report.AppendLine($"{farbwerk360.Status}");
                    _report.AppendLine();
                    _hardware.Add(farbwerk360);
                    break;

                case 0xF012:
                    var highflownext = new HighFlowNext(dev, settings);
                    _report.AppendLine($"Device name: {productName}");
                    _report.AppendLine($"Firmware version: {highflownext.FirmwareVersion}");
                    _report.AppendLine();
                    _hardware.Add(highflownext);
                    break;

                default:
                    _report.AppendLine($"Unknown Hardware PID: {dev.ProductID} Name: {productName}");
                    _report.AppendLine();
                    break;
            }
        }

        if (_hardware.Count == 0)
        {
            _report.AppendLine("No AquaComputer Hardware found.");
            _report.AppendLine();
        }
    }

    public IReadOnlyList<IHardware> Hardware => _hardware;

    public void Close()
    {
        foreach (IHardware iHardware in _hardware)
        {
            if (iHardware is Hardware hardware)
                hardware.Close();
        }
    }

    public string GetReport()
    {
        return _report.ToString();
    }
}

```

`LibreHardwareMonitorLib/Hardware/Controller/AquaComputer/AquastreamUltimate.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Controller.AquaComputer;

internal sealed class AquastreamUltimate : Hardware
{
    private readonly byte[] _rawData = new byte[104];
    private readonly HidStream _stream;

    private readonly Sensor[] _rpmSensors = new Sensor[2];
    private readonly Sensor[] _temperatures = new Sensor[2];
    private readonly Sensor[] _voltages = new Sensor[2];
    private readonly Sensor[] _currents = new Sensor[2];
    private readonly Sensor[] _powers = new Sensor[2];
    private readonly Sensor[] _flows = new Sensor[2];

    public AquastreamUltimate(HidDevice dev, ISettings settings) : base("AquastreamUltimate", new Identifier(dev), settings)
    {
        if (dev.TryOpen(out _stream))
        {
            // Reading output report instead of feature report, as the measurements are in the output report.
            _stream.Read(_rawData);

            FirmwareVersion = GetConvertedValue(0xD).GetValueOrDefault(0);

            Name = "Aquastream ULTIMATE";

            _temperatures[0] = new Sensor("Coolant", 0, SensorType.Temperature, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_temperatures[0]);

            _temperatures[1] = new Sensor("External Sensor", 1, SensorType.Temperature, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_temperatures[1]);

            _rpmSensors[0] = new Sensor("Pump", 0, SensorType.Fan, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_rpmSensors[0]);

            _voltages[0] = new Sensor("Pump", 0, SensorType.Voltage, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_voltages[0]);

            _currents[0] = new Sensor("Pump", 0, SensorType.Current, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_currents[0]);

            _powers[0] = new Sensor("Pump", 0, SensorType.Power, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_powers[0]);

            // Initialize the flow sensor
            _flows[0] = new Sensor("Pump", 0, SensorType.Flow, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_flows[0]);

            _flows[1] = new Sensor("Pressure (mBar)", 1, SensorType.Factor, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_flows[1]);

            _rpmSensors[1] = new Sensor("Fan", 1, SensorType.Fan, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_rpmSensors[1]);

            _voltages[1] = new Sensor("Fan", 1, SensorType.Voltage, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_voltages[1]);

            _currents[1] = new Sensor("Fan", 1, SensorType.Current, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_currents[1]);

            _powers[1] = new Sensor("Fan", 1, SensorType.Power, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_powers[1]);
        }
    }

    public ushort FirmwareVersion { get; }

    public override HardwareType HardwareType
    {
        get { return HardwareType.Cooler; }
    }

    public override void Close()
    {
        _stream.Close();
        base.Close();
    }

    public override void Update()
    {
        // Reading output report instead of feature report, as the measurements are in the output report
        _stream.Read(_rawData);

        _rpmSensors[0].Value = GetConvertedValue(0x51); // Pump speed.
        _rpmSensors[1].Value = GetConvertedValue(0x41 + 0x06); // Fan speed.

        _temperatures[0].Value = GetConvertedValue(0x2D) / 100f; // Water temp.
        _temperatures[1].Value = GetConvertedValue(0x2F) / 100f; // Ext sensor temp.

        _voltages[0].Value = GetConvertedValue(0x3D) / 100f; // Pump input voltage.
        _voltages[1].Value = GetConvertedValue(0x41 + 0x02) / 100f; // Fan output voltage.

        _currents[0].Value = GetConvertedValue(0x53) / 1000f; // Pump current.
        _currents[1].Value = GetConvertedValue(0x41 + 0x00) / 1000f; // Fan current.

        _powers[0].Value = GetConvertedValue(0x55) / 100f; // Pump power.
        _powers[1].Value = GetConvertedValue(0x41 + 0x04) / 100f; // Fan power.

        _flows[0].Value = GetConvertedValue(0x37); // Flow.
        _flows[1].Value = GetConvertedValue(0x57) / 1000f; // Pressure.
    }

    private ushort? GetConvertedValue(int index)
    {
        if (_rawData[index] == sbyte.MaxValue)
            return null;

        return Convert.ToUInt16(_rawData[index + 1] | (_rawData[index] << 8));
    }
}

```

`LibreHardwareMonitorLib/Hardware/Controller/AquaComputer/AquastreamXT.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Controller.AquaComputer;
//TODO:
//Check tested and fix unknown variables in Update()
//Check if property "Variant" is valid interpreted
//Implement Fan Control in SetControl()

internal sealed class AquastreamXT : Hardware
{
    private readonly Sensor _fanControl;
    private readonly Sensor[] _frequencies = new Sensor[2];
    private readonly Sensor _pumpFlow;
    private readonly Sensor _pumpPower;
    private readonly byte[] _rawData = new byte[64];
    private readonly Sensor[] _rpmSensors = new Sensor[2];
    private readonly HidStream _stream;
    private readonly Sensor[] _temperatures = new Sensor[3];
    private readonly Sensor[] _voltages = new Sensor[2];

    public AquastreamXT(HidDevice dev, ISettings settings) : base("Aquastream XT", new Identifier(dev), settings)
    {
        if (dev.TryOpen(out _stream))
        {
            do
            {
                _rawData[0] = 0x4;
                _stream.GetFeature(_rawData);
            }
            while (_rawData[0] != 0x4);

            Name = $"Aquastream XT {Variant}";
            FirmwareVersion = BitConverter.ToUInt16(_rawData, 50);

            _temperatures[0] = new Sensor("External Fan VRM", 0, SensorType.Temperature, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_temperatures[0]);
            _temperatures[1] = new Sensor("External", 1, SensorType.Temperature, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_temperatures[1]);
            _temperatures[2] = new Sensor("Internal Water", 2, SensorType.Temperature, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_temperatures[2]);

            _voltages[0] = new Sensor("External Fan", 1, SensorType.Voltage, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_voltages[0]);
            _voltages[1] = new Sensor("Pump", 2, SensorType.Voltage, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_voltages[1]);

            _pumpPower = new Sensor("Pump", 0, SensorType.Power, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_pumpPower);

            _pumpFlow = new Sensor("Pump", 0, SensorType.Flow, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_pumpFlow);

            _rpmSensors[0] = new Sensor("External Fan", 0, SensorType.Fan, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_rpmSensors[0]);
            _rpmSensors[1] = new Sensor("Pump", 1, SensorType.Fan, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_rpmSensors[1]);

            _fanControl = new Sensor("External Fan", 0, SensorType.Control, this, Array.Empty<ParameterDescription>(), settings);
            _fanControl.Control = new Control(_fanControl, settings, 0, 100);

            ActivateSensor(_fanControl);
            _frequencies[0] = new Sensor("Pump Frequency", 0, SensorType.Frequency, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_frequencies[0]);
            _frequencies[1] = new Sensor("Pump MaxFrequency", 1, SensorType.Frequency, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_frequencies[1]);
        }
    }

    public ushort FirmwareVersion { get; private set; }

    public override HardwareType HardwareType
    {
        get { return HardwareType.Cooler; }
    }

    public string Status
    {
        get
        {
            FirmwareVersion = BitConverter.ToUInt16(_rawData, 50);
            return FirmwareVersion < 1008 ? $"Status: Untested Firmware Version {FirmwareVersion}! Please consider Updating to Version 1018" : "Status: OK";
        }
    }

    //TODO: Check if valid
    public string Variant
    {
        get
        {
            MODE mode = (MODE)_rawData[33];

            if (mode.HasFlag(MODE.MODE_PUMP_ADV))
                return "Ultra + Internal Flow Sensor";

            if (mode.HasFlag(MODE.MODE_FAN_CONTROLLER))
                return "Ultra";

            if (mode.HasFlag(MODE.MODE_FAN_AMP))
                return "Advanced";

            return "Standard";
        }
    }

    public override void Close()
    {
        _stream.Close();

        base.Close();
    }

    //TODO: Check tested and fix unknown variables
    public override void Update()
    {
        try
        {
            _rawData[0] = 0x4;
            _stream.GetFeature(_rawData);
        }
        catch (IOException)
        {
            return;
        }


        if (_rawData[0] != 0x4)
            return;

        //var rawSensorsFan = BitConverter.ToUInt16(rawData, 1);                        //unknown - redundant?
        //var rawSensorsExt = BitConverter.ToUInt16(rawData, 3);                        //unknown - redundant?
        //var rawSensorsWater = BitConverter.ToUInt16(rawData, 5);                      //unknown - redundant?

        _voltages[0].Value = BitConverter.ToUInt16(_rawData, 7) / 61f; //External Fan Voltage: tested - OK
        _voltages[1].Value = BitConverter.ToUInt16(_rawData, 9) / 61f; //Pump Voltage: tested - OK
        _pumpPower.Value = _voltages[1].Value * BitConverter.ToInt16(_rawData, 11) / 625f; //Pump Voltage * Pump Current: tested - OK

        _temperatures[0].Value = BitConverter.ToUInt16(_rawData, 13) / 100f; //External Fan VRM Temperature: untested
        _temperatures[1].Value = BitConverter.ToUInt16(_rawData, 15) / 100f; //External Temperature Sensor: untested
        _temperatures[2].Value = BitConverter.ToUInt16(_rawData, 17) / 100f; //Internal Water Temperature Sensor: tested - OK

        _frequencies[0].Value = (1f / BitConverter.ToInt16(_rawData, 19)) * 750000; //Pump Frequency: tested - OK
        _rpmSensors[1].Value = _frequencies[0].Value * 60f; //Pump RPM: tested - OK
        _frequencies[1].Value = (1f / BitConverter.ToUInt16(_rawData, 21)) * 750000; //Pump Max Frequency: tested - OK

        _pumpFlow.Value = BitConverter.ToUInt32(_rawData, 23); //Internal Pump Flow Sensor: unknown

        _rpmSensors[0].Value = BitConverter.ToUInt32(_rawData, 27); //External Fan RPM: untested

        _fanControl.Value = 100f / byte.MaxValue * _rawData[31]; //External Fan Control: tested, External Fan Voltage scales by this value - OK
    }

    [Flags]
    [SuppressMessage("ReSharper", "InconsistentNaming")]
    private enum MODE : byte
    {
        MODE_PUMP_ADV = 1,
        MODE_FAN_AMP = 2,
        MODE_FAN_CONTROLLER = 4
    }
}

```

`LibreHardwareMonitorLib/Hardware/Controller/AquaComputer/D5Next.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Controller.AquaComputer;

internal sealed class D5Next : Hardware
{
    //Available Reports, found them by looking at the below methods
    //var test = dev.GetRawReportDescriptor();
    //var test2 = dev.GetReportDescriptor();

    // ID 1; Length 158; INPUT
    // ID 2; Length 11; OUTPUT
    // ID 3; Length 1025; <-- works FEATURE
    // ID 8; Length 1025; <-- works FEATURE
    // ID 12; Length 1025; <-- 0xC FEATURE

    private readonly byte[] _rawData = new byte[1025];
    private readonly Sensor[] _rpmSensors = new Sensor[2];
    private readonly HidStream _stream;
    private readonly Sensor[] _temperatures = new Sensor[1];
    private readonly Sensor[] _voltages = new Sensor[4];
    private readonly Sensor[] _powers = new Sensor[2];
    private readonly Sensor[] _flows = new Sensor[1];
    private readonly Sensor[] _fanControl = new Sensor[2];

    public D5Next(HidDevice dev, ISettings settings) : base("D5Next", new Identifier(dev), settings)
    {
        if (dev.TryOpen(out _stream))
        {
            //Reading output report instead of feature report, as the measurements are in the output report
            _stream.Read(_rawData);

            Name = "D5Next";
            FirmwareVersion = Convert.ToUInt16(_rawData[14] | (_rawData[13] << 8));
            _temperatures[0] = new Sensor("Water Temperature", 0, SensorType.Temperature, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_temperatures[0]);

            _rpmSensors[0] = new Sensor("Pump", 0, SensorType.Fan, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_rpmSensors[0]);

            _rpmSensors[1] = new Sensor("Fan", 1, SensorType.Fan, this, settings);
            ActivateSensor(_rpmSensors[1]);

            _voltages[0] = new Sensor("Fan Voltage", 0, SensorType.Voltage, this, settings);
            ActivateSensor(_voltages[0]);

            _voltages[1] = new Sensor("Pump Voltage", 1, SensorType.Voltage, this, settings);
            ActivateSensor(_voltages[1]);

            _voltages[2] = new Sensor("+5V Voltage", 2, SensorType.Voltage, this, settings);
            ActivateSensor(_voltages[2]);

            _voltages[3] = new Sensor("+12V Voltage", 3, SensorType.Voltage, this, settings);
            ActivateSensor(_voltages[3]);
           
            _powers[0] = new Sensor("Fan Power", 0, SensorType.Power, this, settings);
            ActivateSensor(_powers[0]);

            _powers[1] = new Sensor("Pump Power", 1, SensorType.Power, this, settings);
            ActivateSensor(_powers[1]);

            _flows[0] = new Sensor("Viritual Flow", 0, SensorType.Flow, this, settings);
            ActivateSensor(_flows[0]);

            _fanControl[0] = new Sensor("Fan Control", 0, SensorType.Control, this, settings);
            ActivateSensor(_fanControl[0]);

            _fanControl[1] = new Sensor("Pump Control", 1, SensorType.Control, this, settings);
            ActivateSensor(_fanControl[1]);
        }
    }

    public ushort FirmwareVersion { get; }

    public override HardwareType HardwareType
    {
        get { return HardwareType.Cooler; }
    }

    public override void Close()
    {
        _stream.Close();
        base.Close();
    }

    public override void Update()
    {
        //Reading output report instead of feature report, as the measurements are in the output report
        _stream.Read(_rawData);
        _temperatures[0].Value = (_rawData[88] | (_rawData[87] << 8)) / 100f; //Water Temp
        _rpmSensors[0].Value = _rawData[117] | (_rawData[116] << 8); //Pump RPM
        _rpmSensors[1].Value = ReadUInt16BE(_rawData, 103); //Fan RPM
        _voltages[0].Value = ReadUInt16BE(_rawData, 97) / 100f; //Fan Voltage
        _voltages[1].Value = ReadUInt16BE(_rawData, 110) / 100f; //Pump Voltage
        _voltages[2].Value = ReadUInt16BE(_rawData, 57) / 100f; //+5V Voltage
        _voltages[3].Value = ReadUInt16BE(_rawData, 55) / 100f; //+12V Voltage
        _powers[0].Value = ReadUInt16BE(_rawData, 101) / 100f; //Fan Power Consumption
        _powers[1].Value = ReadUInt16BE(_rawData, 114) / 100f; //Pump Power Consumption
        _flows[0].Value = ReadUInt16BE(_rawData, 89) / 10f; // Viritual Flow
        _fanControl[0].Value = ReadUInt16BE(_rawData, 95) / 100f; // Fan Control in % (0-100)
        _fanControl[1].Value = ReadUInt16BE(_rawData, 108) / 100f; // Pump Control in % (0-100)
    }

    private ushort ReadUInt16BE(byte[] value, int startIndex)
    {
        return (ushort)(value[startIndex + 1] | (value[startIndex] << 8));
    }
}

```

`LibreHardwareMonitorLib/Hardware/Controller/AquaComputer/Farbwerk.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Controller.AquaComputer;
//TODO:
//Implement set RGB Controls

internal sealed class Farbwerk : Hardware
{
    private const int FEATURE_ID = 3;

    private const int HEADER_SIZE = 27;
    private const int SENSOR_OFFSET = 20;
    private const int COLORS_OFFSET = 40;

    private const int TEMPERATURE_COUNT = 4;
    private const int TEMP_SENSOR_DISCONNECTED = 32767;
    private const int COLOR_COUNT = 4;
    private const int COLOR_VALUE_COUNT = COLOR_COUNT * 3;
    private readonly HidDevice _device;
    private readonly byte[] _rawData = new byte[140];
    
    private readonly Sensor[] _temperatures = new Sensor[TEMPERATURE_COUNT];
    private readonly Sensor[] _colors = new Sensor[COLOR_VALUE_COUNT];

    public Farbwerk(HidDevice dev, ISettings settings) : base("Farbwerk", new Identifier(dev), settings)
    {
        _device = dev;

        for (int i = 0; i < _temperatures.Length; i++)
        {
            _temperatures[i] = new Sensor($"Temperature #{i + 1}", i, SensorType.Temperature, this, settings);
            ActivateSensor(_temperatures[i]);
        }

        for (int i = 0; i < _colors.Length; i++)
        {
            int control = (i / 3) + 1;
            string color = (i % 3) switch
            {
                0 => "Red",
                1 => "Green",
                2 => "Blue",
                _ => "Invalid"
            };
            _colors[i] = new Sensor($"Controller {control} {color}", COLOR_COUNT + i, SensorType.Level, this, settings);
            ActivateSensor(_colors[i]);
        }

        Update();
    }

    public ushort FirmwareVersion { get; private set; }

    public override HardwareType HardwareType
    {
        get { return HardwareType.EmbeddedController; }
    }

    public string Status
    {
        get
        {
            if (_rawData[0] != 0x1)
            {
                return $"Status: Invalid header {_rawData[0]}";
            }

            if (FirmwareVersion < 1009)
            {
                return $"Status: Untested Firmware Version {FirmwareVersion}! Please consider Updating to Version 1009";
            }

            return "Status: OK";
        }
    }

    public override void Close()
    {
        base.Close();
    }

    public override void Update()
    {
        if (_device.TryOpen(out HidStream stream)) {
            int length = stream.Read(_rawData);

            if (length != _rawData.Length || _rawData[0] != 0x1)
            {
                return;
            }

            FirmwareVersion = Convert.ToUInt16(_rawData[21] << 8 | _rawData[22]);

            int offset = HEADER_SIZE + SENSOR_OFFSET;
            foreach (Sensor temp in _temperatures)
            {
                temp.Value = (_rawData[offset] << 8 | _rawData[offset + 1]) / 100.0f;

                if (temp.Value == (TEMP_SENSOR_DISCONNECTED / 100.0f)) {
                    DeactivateSensor(temp);
                }
                
                offset += 2;
            }

            offset = HEADER_SIZE + COLORS_OFFSET;
            foreach (Sensor color in _colors)
            {
                color.Value = (_rawData[offset] << 8 | _rawData[offset + 1]) / 81.90f;
                offset += 2;
            }
        }
        
    }
}

```

`LibreHardwareMonitorLib/Hardware/Controller/AquaComputer/Farbwerk360.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Controller.AquaComputer;
//TODO:
//Implement set RGB Controls

internal sealed class Farbwerk360 : Hardware
{
    private const int FEATURE_ID = 3;

    private const int HEADER_SIZE = 30;
    private const int SENSOR_OFFSET = 20;
    private const int COLORS_OFFSET = 43;

    private const int TEMPERATURE_COUNT = 4;
    private const int TEMP_SENSOR_DISCONNECTED = 32767;
    private const int COLOR_COUNT = 4;
    private const int COLOR_VALUE_COUNT = COLOR_COUNT * 3;
    private readonly HidDevice _device;
    private readonly byte[] _rawData = new byte[140];
    private readonly Sensor[] _temperatures = new Sensor[TEMPERATURE_COUNT];
    private readonly Sensor[] _colors = new Sensor[COLOR_VALUE_COUNT];

    public Farbwerk360(HidDevice dev, ISettings settings) : base("Farbwerk 360", new Identifier(dev), settings)
    {
        _device = dev;

        for (int i = 0; i < _temperatures.Length; i++)
        {
            _temperatures[i] = new Sensor($"Temperature #{i + 1}", i, SensorType.Temperature, this, settings);
            ActivateSensor(_temperatures[i]);
        }

        for (int i = 0; i < _colors.Length; i++)
        {
            int control = (i / 3) + 1;
            string color = (i % 3) switch
            {
                0 => "Red",
                1 => "Green",
                2 => "Blue",
                _ => "Invalid"
            };
            _colors[i] = new Sensor($"Controller {control} {color}", COLOR_COUNT + i, SensorType.Level, this, settings);
            ActivateSensor(_colors[i]);
        }

        Update();
    }

    public ushort FirmwareVersion { get; private set; }

    public override HardwareType HardwareType
    {
        get { return HardwareType.EmbeddedController; }
    }

    public string Status
    {
        get
        {
            if (_rawData[0] != 0x1)
            {
                return $"Status: Invalid header {_rawData[0]}";
            }

            if (FirmwareVersion < 1009)
            {
                return $"Status: Untested Firmware Version {FirmwareVersion}! Please consider Updating to Version 1009";
            }

            return "Status: OK";
        }
    }

    public override void Close()
    {
        base.Close();
    }

    public override void Update()
    {
        if (_device.TryOpen(out HidStream stream)) {
            int length = stream.Read(_rawData);

            if (length != _rawData.Length || _rawData[0] != 0x1)
            {
                return;
            }

            FirmwareVersion = Convert.ToUInt16(_rawData[21] << 8 | _rawData[22]);

            int offset = HEADER_SIZE + SENSOR_OFFSET;
            foreach (Sensor temp in _temperatures)
            {
                temp.Value = (_rawData[offset] << 8 | _rawData[offset + 1]) / 100.0f;

                if (temp.Value == (TEMP_SENSOR_DISCONNECTED / 100.0f)) {
                    DeactivateSensor(temp);
                }
                
                offset += 2;
            }

            offset = HEADER_SIZE + COLORS_OFFSET;
            foreach (Sensor color in _colors)
            {
                color.Value = (_rawData[offset] << 8 | _rawData[offset + 1]) / 81.90f;
                offset += 2;
            }
        }
        
    }
}

```

`LibreHardwareMonitorLib/Hardware/Controller/AquaComputer/HighFlowNext.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Controller.AquaComputer;

internal sealed class HighFlowNext : Hardware
{
    private readonly byte[] _rawData = new byte[1025];
    private readonly HidStream _stream;
    private readonly Sensor[] _temperatures = new Sensor[2];
    private readonly Sensor[] _flows = new Sensor[1];
    private readonly Sensor[] _levels = new Sensor[1];
    private readonly Sensor[] _powers = new Sensor[1];
    private readonly Sensor[] _conductivities = new Sensor[1];
    private readonly Sensor[] _voltages = new Sensor[2];
    private readonly Sensor[] _alarms = new Sensor[4];

    public HighFlowNext(HidDevice dev, ISettings settings) : base("high flow NEXT", new Identifier(dev), settings)
    {
        if (dev.TryOpen(out _stream))
        {
            // Reading output report instead of feature report, as the measurements are in the output report.
            _stream.Read(_rawData);

            FirmwareVersion = ReadUInt16BE(_rawData, 13);

            _temperatures[0] = new Sensor("Water Temperature", 0, SensorType.Temperature, this, settings);
            ActivateSensor(_temperatures[0]);

            _temperatures[1] = new Sensor("External Temperature", 1, SensorType.Temperature, this, settings);
            ActivateSensor(_temperatures[1]);

            _flows[0] = new Sensor("Flow", 0, SensorType.Flow, this, settings);
            ActivateSensor(_flows[0]);

            _levels[0] = new Sensor("Water Quality", 0, SensorType.Level, this, settings);
            ActivateSensor(_levels[0]);

            _powers[0] = new Sensor("Dissipated Power", 0, SensorType.Power, this, settings);
            ActivateSensor(_powers[0]);

            _conductivities[0] = new Sensor("Conductivity", 0, SensorType.Conductivity, this, settings);
            ActivateSensor(_conductivities[0]);

            _voltages[0] = new Sensor("VCC", 0, SensorType.Voltage, this, settings);
            ActivateSensor(_voltages[0]);

            _voltages[1] = new Sensor("VCC USB", 1, SensorType.Voltage, this, settings);
            ActivateSensor(_voltages[1]);

            _alarms[0] = new Sensor("Flow Alarm", 0, true, SensorType.Factor, this, null, settings);
            ActivateSensor(_alarms[0]);

            _alarms[1] = new Sensor("Water Temperature Alarm", 1, true, SensorType.Factor, this, null, settings);
            ActivateSensor(_alarms[0]);

            _alarms[2] = new Sensor("External Temperature Alarm", 2, true, SensorType.Factor, this, null, settings);
            ActivateSensor(_alarms[0]);

            _alarms[3] = new Sensor("Water Quality Alarm", 3, true, SensorType.Factor, this, null, settings);
            ActivateSensor(_alarms[0]);
        }
    }

    public ushort FirmwareVersion { get; }

    public override HardwareType HardwareType
    {
        get { return HardwareType.Cooler; }
    }

    public override void Close()
    {
        _stream.Close();
        base.Close();
    }

    public override void Update()
    {
        // Reading output report instead of feature report, as the measurements are in the output report.
        _stream.Read(_rawData);

        _temperatures[0].Value = ReadUInt16BE(_rawData, 85) / 100f; // Water Temperature

        // External Temperature.
        ushort rawExtTempValue = ReadUInt16BE(_rawData, 87);
        bool externalTempSensorConnected = rawExtTempValue != short.MaxValue;

        if (externalTempSensorConnected)
        {
            _temperatures[1].Value = rawExtTempValue / 100f;
        }
        else
        {
            // No external temp sensor connected.
            _temperatures[1].Value = null;
        }

        _flows[0].Value = ReadUInt16BE(_rawData, 81) / 10f; // Flow


        _levels[0].Value = ReadUInt16BE(_rawData, 89) / 100f; // Water Quality

        // Dissipated Power.
        if (externalTempSensorConnected)
        {
            _powers[0].Value = ReadUInt16BE(_rawData, 91);
        }
        else
        {
            // Power calculation requires the external temp sensor to be connected.
            _powers[0].Value = null;
        }

        _conductivities[0].Value = ReadUInt16BE(_rawData, 95) / 10f; // Conductivity

        _voltages[0].Value = ReadUInt16BE(_rawData, 97) / 100f; // VCC
        _voltages[1].Value = ReadUInt16BE(_rawData, 99) / 100f; // VCC USB

        _alarms[0].Value = (_rawData[116] & 0x02) >> 1; // Flow alarm
        _alarms[1].Value = (_rawData[116] & 0x04) >> 2; // Water temperature alarm
        _alarms[2].Value = (_rawData[116] & 0x08) >> 3; // External temperature alarm
        _alarms[3].Value = (_rawData[116] & 0x10) >> 4; // Water quality alarm

        // Unused:
        // _rawData[101..104] -> Total pumped volume liters
        // _rawData[105..109] -> Internal impulse counter from flow meter
    }

    private ushort ReadUInt16BE(byte[] value, int startIndex)
    {
        return (ushort)(value[startIndex + 1] | (value[startIndex] << 8));
    }
}

```

`LibreHardwareMonitorLib/Hardware/Controller/AquaComputer/MPS.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.IO;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Controller.AquaComputer;

internal sealed class MPS : Hardware
{
    public const int ExternalTemperature = 43;
    public const int InternalWaterTemperature = 45;
    public const int PumpFlow = 35;
    private const byte MPS_REPORT_ID = 0x2;

    private readonly Sensor _pumpFlow;
    private readonly byte[] _rawData = new byte[64];
    private readonly HidStream _stream;
    private readonly Sensor[] _temperatures = new Sensor[2];

    private ushort _externalTemperature;

    public MPS(HidDevice dev, ISettings settings) : base("MPS", new Identifier(dev), settings)
    {
        if (dev.TryOpen(out _stream))
        {
            do
            {
                _rawData[0] = MPS_REPORT_ID;
                _stream.GetFeature(_rawData);
            }
            while (_rawData[0] != MPS_REPORT_ID);

            Name = "MPS";
            FirmwareVersion = ExtractFirmwareVersion();

            _temperatures[0] = new Sensor("External", 0, SensorType.Temperature, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_temperatures[0]);
            _temperatures[1] = new Sensor("Internal Water", 1, SensorType.Temperature, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_temperatures[1]);

            _pumpFlow = new Sensor("Pump", 0, SensorType.Flow, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_pumpFlow);
        }
    }

    public ushort FirmwareVersion { get; private set; }

    public override HardwareType HardwareType
    {
        get { return HardwareType.Cooler; }
    }

    public string Status
    {
        get
        {
            FirmwareVersion = ExtractFirmwareVersion();
            if (FirmwareVersion < 1012)
            {
                return $"Status: Untested Firmware Version {FirmwareVersion}! Please consider Updating to Version 1012";
            }

            return "Status: OK";
        }
    }

    public override void Close()
    {
        _stream.Close();

        base.Close();
    }

    public override void Update()
    {
        try
        {
            _rawData[0] = MPS_REPORT_ID;
            _stream.GetFeature(_rawData);
        }
        catch (IOException)
        {
            return;
        }

        if (_rawData[0] != MPS_REPORT_ID)
            return;

        _pumpFlow.Value = BitConverter.ToUInt16(_rawData, PumpFlow) / 10f;

        _externalTemperature = BitConverter.ToUInt16(_rawData, ExternalTemperature);
        //sensor reading returns Int16.MaxValue (32767), when not connected
        if (_externalTemperature != short.MaxValue)
        {
            _temperatures[0].Value = _externalTemperature / 100f;
        }
        else
        {
            _temperatures[0].Value = null;
        }

        _temperatures[1].Value = BitConverter.ToUInt16(_rawData, InternalWaterTemperature) / 100f;

    }

    private ushort ExtractFirmwareVersion()
    {
        return BitConverter.ToUInt16(_rawData, 3);
    }
}

```

`LibreHardwareMonitorLib/Hardware/Controller/AquaComputer/Octo.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Controller.AquaComputer;

internal sealed class Octo : Hardware
{
    private readonly byte[] _rawData = new byte[1025];
    private readonly Sensor[] _rpmSensors = new Sensor[8];
    private readonly HidStream _stream;
    private readonly Sensor[] _temperatures = new Sensor[4];
    private readonly Sensor[] _voltages = new Sensor[9];
    private readonly Sensor[] _currents = new Sensor[8];
    private readonly Sensor[] _powers = new Sensor[8];

    public Octo(HidDevice dev, ISettings settings) : base("Octo", new Identifier(dev), settings)
    {
        if (dev.TryOpen(out _stream))
        {
            //Reading output report instead of feature report, as the measurements are in the output report
            _stream.Read(_rawData);

            Name = "OCTO";
            FirmwareVersion = GetConvertedValue(OctoDataIndexes.FIRMWARE_VERSION).GetValueOrDefault(0);

            // Initialize the 4 temperature sensors
            for (int i = 0; i < 4; i++)
            {
                _temperatures[i] = new Sensor($"Temperature #{i + 1}", i, SensorType.Temperature, this, Array.Empty<ParameterDescription>(), settings);
                ActivateSensor(_temperatures[i]);
            }

            // Initialize the 8 fan speed sensors
            for (int i = 0; i < 8; i++)
            {
                _rpmSensors[i] = new Sensor($"Fan #{i + 1}", i, SensorType.Fan, this, Array.Empty<ParameterDescription>(), settings);
                ActivateSensor(_rpmSensors[i]);
            }

            // Initialize the input voltage sensor
            _voltages[0] = new Sensor("Input", 0, SensorType.Voltage, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_voltages[0]);

            // Initialize the 8 fan voltage sensors
            for (int i = 1; i < 9; i++)
            {
                _voltages[i] = new Sensor($"Fan #{i}", i, SensorType.Voltage, this, Array.Empty<ParameterDescription>(), settings);
                ActivateSensor(_voltages[i]);
            }

            // Initialize the 8 fan current sensors
            for (int i = 0; i < 8; i++)
            {
                _currents[i] = new Sensor($"Fan #{i + 1}", i, SensorType.Current, this, Array.Empty<ParameterDescription>(), settings);
                ActivateSensor(_currents[i]);
            }

            // Initialize the 8 fan power sensors
            for (int i = 0; i < 8; i++)
            {
                _powers[i] = new Sensor($"Fan #{i + 1}", i, SensorType.Power, this, Array.Empty<ParameterDescription>(), settings);
                ActivateSensor(_powers[i]);
            }
        }
    }

    public ushort FirmwareVersion { get; }

    public override HardwareType HardwareType
    {
        get { return HardwareType.Cooler; }
    }

    public override void Close()
    {
        _stream.Close();
        base.Close();
    }

    public override void Update()
    {
        //Reading output report instead of feature report, as the measurements are in the output report
        _stream.Read(_rawData);

        _temperatures[0].Value = GetConvertedValue(OctoDataIndexes.TEMP_1) / 100f; // Temp 1
        _temperatures[1].Value = GetConvertedValue(OctoDataIndexes.TEMP_2) / 100f; // Temp 2
        _temperatures[2].Value = GetConvertedValue(OctoDataIndexes.TEMP_3) / 100f; // Temp 3
        _temperatures[3].Value = GetConvertedValue(OctoDataIndexes.TEMP_4) / 100f; // Temp 4

        _rpmSensors[0].Value = GetConvertedValue(OctoDataIndexes.FAN_SPEED_1); // Fan 1 speed
        _rpmSensors[1].Value = GetConvertedValue(OctoDataIndexes.FAN_SPEED_2); // Fan 2 speed
        _rpmSensors[2].Value = GetConvertedValue(OctoDataIndexes.FAN_SPEED_3); // Fan 3 speed
        _rpmSensors[3].Value = GetConvertedValue(OctoDataIndexes.FAN_SPEED_4); // Fan 4 speed
        _rpmSensors[4].Value = GetConvertedValue(OctoDataIndexes.FAN_SPEED_5); // Fan 5 speed
        _rpmSensors[5].Value = GetConvertedValue(OctoDataIndexes.FAN_SPEED_6); // Fan 6 speed
        _rpmSensors[6].Value = GetConvertedValue(OctoDataIndexes.FAN_SPEED_7); // Fan 7 speed
        _rpmSensors[7].Value = GetConvertedValue(OctoDataIndexes.FAN_SPEED_8); // Fan 8 speed

        _voltages[0].Value = GetConvertedValue(OctoDataIndexes.VOLTAGE) / 100f; // Input voltage
        _voltages[1].Value = GetConvertedValue(OctoDataIndexes.FAN_VOLTAGE_1) / 100f; // Fan 1 voltage
        _voltages[2].Value = GetConvertedValue(OctoDataIndexes.FAN_VOLTAGE_2) / 100f; // Fan 2 voltage
        _voltages[3].Value = GetConvertedValue(OctoDataIndexes.FAN_VOLTAGE_3) / 100f; // Fan 3 voltage
        _voltages[4].Value = GetConvertedValue(OctoDataIndexes.FAN_VOLTAGE_4) / 100f; // Fan 4 voltage
        _voltages[5].Value = GetConvertedValue(OctoDataIndexes.FAN_VOLTAGE_5) / 100f; // Fan 5 voltage
        _voltages[6].Value = GetConvertedValue(OctoDataIndexes.FAN_VOLTAGE_6) / 100f; // Fan 6 voltage
        _voltages[7].Value = GetConvertedValue(OctoDataIndexes.FAN_VOLTAGE_7) / 100f; // Fan 7 voltage
        _voltages[8].Value = GetConvertedValue(OctoDataIndexes.FAN_VOLTAGE_8) / 100f; // Fan 8 voltage

        _currents[0].Value = GetConvertedValue(OctoDataIndexes.FAN_CURRENT_1) / 1000f; // Fan 1 current
        _currents[1].Value = GetConvertedValue(OctoDataIndexes.FAN_CURRENT_2) / 1000f; // Fan 2 current
        _currents[2].Value = GetConvertedValue(OctoDataIndexes.FAN_CURRENT_3) / 1000f; // Fan 3 current
        _currents[3].Value = GetConvertedValue(OctoDataIndexes.FAN_CURRENT_4) / 1000f; // Fan 4 current
        _currents[4].Value = GetConvertedValue(OctoDataIndexes.FAN_CURRENT_5) / 1000f; // Fan 5 current
        _currents[5].Value = GetConvertedValue(OctoDataIndexes.FAN_CURRENT_6) / 1000f; // Fan 6 current
        _currents[6].Value = GetConvertedValue(OctoDataIndexes.FAN_CURRENT_7) / 1000f; // Fan 7 current
        _currents[7].Value = GetConvertedValue(OctoDataIndexes.FAN_CURRENT_8) / 1000f; // Fan 8 current

        _powers[0].Value = GetConvertedValue(OctoDataIndexes.FAN_POWER_1) / 100f; // Fan 1 power
        _powers[1].Value = GetConvertedValue(OctoDataIndexes.FAN_POWER_2) / 100f; // Fan 2 power
        _powers[2].Value = GetConvertedValue(OctoDataIndexes.FAN_POWER_3) / 100f; // Fan 3 power
        _powers[3].Value = GetConvertedValue(OctoDataIndexes.FAN_POWER_4) / 100f; // Fan 4 power
        _powers[4].Value = GetConvertedValue(OctoDataIndexes.FAN_POWER_5) / 100f; // Fan 5 power
        _powers[5].Value = GetConvertedValue(OctoDataIndexes.FAN_POWER_6) / 100f; // Fan 6 power
        _powers[6].Value = GetConvertedValue(OctoDataIndexes.FAN_POWER_7) / 100f; // Fan 7 power
        _powers[7].Value = GetConvertedValue(OctoDataIndexes.FAN_POWER_8) / 100f; // Fan 8 power
    }

    private sealed class OctoDataIndexes
    {
        public const int FIRMWARE_VERSION = 13;

        public const int TEMP_1 = 61;
        public const int TEMP_2 = 63;
        public const int TEMP_3 = 65;
        public const int TEMP_4 = 67;

        public const int FAN_SPEED_1 = 133;
        public const int FAN_SPEED_2 = 146;
        public const int FAN_SPEED_3 = 159;
        public const int FAN_SPEED_4 = 172;
        public const int FAN_SPEED_5 = 185;
        public const int FAN_SPEED_6 = 198;
        public const int FAN_SPEED_7 = 211;
        public const int FAN_SPEED_8 = 224;

        public const int FAN_POWER_1 = 131;
        public const int FAN_POWER_2 = 144;
        public const int FAN_POWER_3 = 157;
        public const int FAN_POWER_4 = 170;
        public const int FAN_POWER_5 = 183;
        public const int FAN_POWER_6 = 196;
        public const int FAN_POWER_7 = 209;
        public const int FAN_POWER_8 = 222;

        public const int VOLTAGE = 117;
        public const int FAN_VOLTAGE_1 = 127;
        public const int FAN_VOLTAGE_2 = 140;
        public const int FAN_VOLTAGE_3 = 153;
        public const int FAN_VOLTAGE_4 = 166;
        public const int FAN_VOLTAGE_5 = 179;
        public const int FAN_VOLTAGE_6 = 192;
        public const int FAN_VOLTAGE_7 = 205;
        public const int FAN_VOLTAGE_8 = 218;

        public const int FAN_CURRENT_1 = 129;
        public const int FAN_CURRENT_2 = 142;
        public const int FAN_CURRENT_3 = 155;
        public const int FAN_CURRENT_4 = 168;
        public const int FAN_CURRENT_5 = 181;
        public const int FAN_CURRENT_6 = 194;
        public const int FAN_CURRENT_7 = 207;
        public const int FAN_CURRENT_8 = 220;
    }

    private ushort? GetConvertedValue(int index)
    {
        if (_rawData[index] == sbyte.MaxValue)
            return null;

        return Convert.ToUInt16(_rawData[index + 1] | (_rawData[index] << 8));
    }
}

```

`LibreHardwareMonitorLib/Hardware/Controller/AquaComputer/Quadro.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Controller.AquaComputer;

internal sealed class Quadro : Hardware
{
    private readonly byte[] _rawData = new byte[210];
    private readonly HidStream _stream;

    private readonly Sensor[] _rpmSensors = new Sensor[4];
    private readonly Sensor[] _temperatures = new Sensor[4];
    private readonly Sensor[] _voltages = new Sensor[5];
    private readonly Sensor[] _currents = new Sensor[4];
    private readonly Sensor[] _powers = new Sensor[4];
    private readonly Sensor[] _flows = new Sensor[1];

    public Quadro(HidDevice dev, ISettings settings) : base("Quadro", new Identifier(dev), settings)
    {
        if (dev.TryOpen(out _stream))
        {
            //Reading output report instead of feature report, as the measurements are in the output report
            _stream.Read(_rawData);

            Name = "QUADRO";
            FirmwareVersion = GetConvertedValue(QuadroDataIndexes.FIRMWARE_VERSION).GetValueOrDefault(0);

            // Initialize the 4 temperature sensors
            for (int i = 0; i < 4; i++)
            {
                _temperatures[i] = new Sensor($"Temperature #{i + 1}", i, SensorType.Temperature, this, Array.Empty<ParameterDescription>(), settings);
                ActivateSensor(_temperatures[i]);
            }

            // Initialize the input voltage sensor
            _voltages[0] = new Sensor("Input", 0, SensorType.Voltage, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_voltages[0]);

            // Initialize the flow sensor
            _flows[0] = new Sensor("Flow", 0, SensorType.Flow, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_flows[0]);

            // Initialize the 4 fan voltage sensors
            for (int i = 1; i < 5; i++)
            {
                _voltages[i] = new Sensor($"Fan #{i}", i, SensorType.Voltage, this, Array.Empty<ParameterDescription>(), settings);
                ActivateSensor(_voltages[i]);
            }

            // Initialize the 4 fan current sensors
            for (int i = 0; i < 4; i++)
            {
                _currents[i] = new Sensor($"Fan #{i + 1}", i, SensorType.Current, this, Array.Empty<ParameterDescription>(), settings);
                ActivateSensor(_currents[i]);
            }

            // Initialize the 4 fan power sensors
            for (int i = 0; i < 4; i++)
            {
                _powers[i] = new Sensor($"Fan #{i + 1}", i, SensorType.Power, this, Array.Empty<ParameterDescription>(), settings);
                ActivateSensor(_powers[i]);
            }

            // Initialize the 4 fan speed sensors
            for (int i = 0; i < 4; i++)
            {
                _rpmSensors[i] = new Sensor($"Fan #{i + 1}", i, SensorType.Fan, this, Array.Empty<ParameterDescription>(), settings);
                ActivateSensor(_rpmSensors[i]);
            }

        }
    }

    public ushort FirmwareVersion { get; }

    public override HardwareType HardwareType
    {
        get { return HardwareType.Cooler; }
    }

    public override void Close()
    {
        _stream.Close();
        base.Close();
    }

    public override void Update()
    {
        //Reading output report instead of feature report, as the measurements are in the output report
        _stream.Read(_rawData);

        _temperatures[0].Value = GetConvertedValue(QuadroDataIndexes.TEMP_1) / 100f; // Temp 1
        _temperatures[1].Value = GetConvertedValue(QuadroDataIndexes.TEMP_2) / 100f; // Temp 2
        _temperatures[2].Value = GetConvertedValue(QuadroDataIndexes.TEMP_3) / 100f; // Temp 3
        _temperatures[3].Value = GetConvertedValue(QuadroDataIndexes.TEMP_4) / 100f; // Temp 4

        _voltages[0].Value = GetConvertedValue(QuadroDataIndexes.VOLTAGE) / 100f; // Input voltage

        _flows[0].Value = GetConvertedValue(QuadroDataIndexes.FLOW) / 10f; // Flow

        _voltages[1].Value = GetConvertedValue(QuadroDataIndexes.FAN_VOLTAGE_1) / 100f; // Fan 1 voltage
        _voltages[2].Value = GetConvertedValue(QuadroDataIndexes.FAN_VOLTAGE_2) / 100f; // Fan 2 voltage
        _voltages[3].Value = GetConvertedValue(QuadroDataIndexes.FAN_VOLTAGE_3) / 100f; // Fan 3 voltage
        _voltages[4].Value = GetConvertedValue(QuadroDataIndexes.FAN_VOLTAGE_4) / 100f; // Fan 4 voltage

        _currents[0].Value = GetConvertedValue(QuadroDataIndexes.FAN_CURRENT_1) / 1000f; // Fan 1 current
        _currents[1].Value = GetConvertedValue(QuadroDataIndexes.FAN_CURRENT_2) / 1000f; // Fan 2 current
        _currents[2].Value = GetConvertedValue(QuadroDataIndexes.FAN_CURRENT_3) / 1000f; // Fan 3 current
        _currents[3].Value = GetConvertedValue(QuadroDataIndexes.FAN_CURRENT_4) / 1000f; // Fan 4 current

        _powers[0].Value = GetConvertedValue(QuadroDataIndexes.FAN_POWER_1) / 100f; // Fan 1 power
        _powers[1].Value = GetConvertedValue(QuadroDataIndexes.FAN_POWER_2) / 100f; // Fan 2 power
        _powers[2].Value = GetConvertedValue(QuadroDataIndexes.FAN_POWER_3) / 100f; // Fan 3 power
        _powers[3].Value = GetConvertedValue(QuadroDataIndexes.FAN_POWER_4) / 100f; // Fan 4 power

        _rpmSensors[0].Value = GetConvertedValue(QuadroDataIndexes.FAN_SPEED_1); // Fan 1 speed
        _rpmSensors[1].Value = GetConvertedValue(QuadroDataIndexes.FAN_SPEED_2); // Fan 2 speed
        _rpmSensors[2].Value = GetConvertedValue(QuadroDataIndexes.FAN_SPEED_3); // Fan 3 speed
        _rpmSensors[3].Value = GetConvertedValue(QuadroDataIndexes.FAN_SPEED_4); // Fan 4 speed

    }

    private sealed class QuadroDataIndexes
    {
        public const int FIRMWARE_VERSION = 13;

        public const int TEMP_1 = 52;
        public const int TEMP_2 = 54;
        public const int TEMP_3 = 56;
        public const int TEMP_4 = 58;

        public const int VOLTAGE = 108;

        public const int FLOW = 110;

        public const int FAN_VOLTAGE_1 = 114;
        public const int FAN_VOLTAGE_2 = 127;
        public const int FAN_VOLTAGE_3 = 140;
        public const int FAN_VOLTAGE_4 = 153;

        public const int FAN_CURRENT_1 = 116;
        public const int FAN_CURRENT_2 = 129;
        public const int FAN_CURRENT_3 = 142;
        public const int FAN_CURRENT_4 = 155;

        public const int FAN_POWER_1 = 118;
        public const int FAN_POWER_2 = 131;
        public const int FAN_POWER_3 = 144;
        public const int FAN_POWER_4 = 157;

        public const int FAN_SPEED_1 = 120;
        public const int FAN_SPEED_2 = 133;
        public const int FAN_SPEED_3 = 146;
        public const int FAN_SPEED_4 = 159;

    }

    private ushort? GetConvertedValue(int index)
    {
        if (_rawData[index] == sbyte.MaxValue)
            return null;

        return Convert.ToUInt16(_rawData[index + 1] | (_rawData[index] << 8));
    }
}

```

`LibreHardwareMonitorLib/Hardware/Controller/Arctic/ArcticFanController.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Linq;
using System.Threading;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Controller.Arctic;

internal class ArcticFanController : Hardware
{
    private const int CHANNEL_COUNT = 10;
    private const int PACKET_SIZE = 32;
    private const int CONTROL_VALUE_MIN = 0;
    private const int CONTROL_VALUE_MAX = 100;
    private const int CONTROL_RESET_VALUE = 30;
    private const int TIMEOUT_MS = 1000;

    private HidStream _hidStream;
    private readonly object _hidLock = new();
    private readonly object _controlLock = new();
    private readonly Thread _thread;
    private readonly float[] _requestedFanSpeedsPercent = new float[CHANNEL_COUNT];
    private readonly float[] _currentFanRpms = new float[CHANNEL_COUNT];
    private readonly float[] _currentDevicePwmValues = new float[CHANNEL_COUNT]; // Current PWM values from device
    private bool _sendPwmRequested;
    private bool _pwmValuesInitialized = false; // Track if we've read initial PWM values from device
    private readonly System.Collections.Generic.List<Sensor> _rpmSensors = new();
    private readonly System.Collections.Generic.List<Sensor> _controlSensors = new();

    public ArcticFanController(HidDevice dev, ISettings settings) : base("ARCTIC Fan Controller", new Identifier(dev), settings)
    {
        if (dev.TryOpen(out HidStream hidStream))
        {
            // Create fan sensors (RPM monitoring) - all 10 fans have RPM feedback
            for (int i = 1; i <= CHANNEL_COUNT; i++)
            {
                var fanSensor = new Sensor($"Fan #{i}", i, SensorType.Fan, this, settings);
                ActivateSensor(fanSensor);
                _rpmSensors.Add(fanSensor);
            }

            // Create control sensors - all 10 fans can be controlled
            for (int i = 1; i <= CHANNEL_COUNT; i++)
            {
                var controlSensor = new Sensor($"Control #{i}", i, SensorType.Control, this, settings);
                Control control = new(controlSensor, settings, CONTROL_VALUE_MIN, CONTROL_VALUE_MAX);
                control.ControlModeChanged += Control_ControlModeChanged;
                control.SoftwareControlValueChanged += Control_SoftwareControlValueChanged;

                controlSensor.Control = control;
                ActivateSensor(controlSensor); // Activate the control sensor so it appears in the UI
                _controlSensors.Add(controlSensor);
            }

            _hidStream = hidStream;
            _hidStream.ReadTimeout = TIMEOUT_MS;
            _hidStream.WriteTimeout = TIMEOUT_MS;

            // create thread
            _thread = new Thread(ThreadHidLoop);
            _thread.IsBackground = true; // Allow app to close even if thread is running
            _thread.Start(); // Start the thread to read RPM data
        }
    }

    private void ThreadHidLoop()
    {
        while (_hidStream != null)
        {
            lock (_hidLock)
            {
                if (_hidStream == null) return;

                UpdateRpmAndPwmValues();
                SendPWMUpdateIfRequired();
            }

            Thread.Sleep(500);
        }
    }

    private void Control_SoftwareControlValueChanged(Control control)
    {
        // need PWM update
        lock (_controlLock)
        {
            var value = control.ControlMode switch
            {
                ControlMode.Software => Math.Max(Math.Min(control.SoftwareValue, CONTROL_VALUE_MAX), CONTROL_VALUE_MIN),
                _ => CONTROL_RESET_VALUE,
            };

            _requestedFanSpeedsPercent[control.Sensor.Index - 1] = value;
            _sendPwmRequested = true;
        }

        // update the sensor value
        (control.Sensor as Sensor)?.Value = control.ControlMode == ControlMode.Software ? control.SoftwareValue : null;
    }

    private void Control_ControlModeChanged(Control control)
    {
        Control_SoftwareControlValueChanged(control);
    }

    public override HardwareType HardwareType { get; } = HardwareType.Cooler;

    public override void Update()
    {
        lock (_hidLock)
        {
            foreach (Sensor sensor in _rpmSensors)
            {
                sensor.Value = GetRPM(sensor.Index);
            }

            // Update control sensor values to reflect current device PWM values
            // This ensures the UI shows the actual current values from the device quickly
            foreach (Sensor sensor in _controlSensors)
            {
                int idx = sensor.Index - 1;
                if (idx >= 0 && idx < CHANNEL_COUNT &&
                    // Only update if sensor doesn't have a manual value set (to avoid overwriting user input)
                    sensor.Control?.ControlMode != ControlMode.Software)
                {
                    // Use current device PWM values for immediate display, fallback to requested if not initialized yet
                    float displayValue = _pwmValuesInitialized ? _currentDevicePwmValues[idx] : _requestedFanSpeedsPercent[idx];
                    sensor.Value = displayValue;
                }

            }
        }
    }

    public override void Close()
    {
        lock (_hidLock)
        {
            try
            {
                lock (_controlLock)
                {
                    // Set all fans to 30% before closing (like JS does)
                    for (int i = 0; i < CHANNEL_COUNT; i++)
                    {
                        _requestedFanSpeedsPercent[i] = CONTROL_RESET_VALUE;
                    }

                    _sendPwmRequested = true;
                }

                SendPWMUpdateIfRequired();

            }
            catch { }

            try
            {
                _hidStream?.Close();
                _hidStream?.Dispose();

            }
            catch { }
            // make sure stream is null so the thread can exit
            finally
            {
                _hidStream = null;
            }
        }

        // wait for thread to finish
        _thread?.Join(1000);

        base.Close();
    }

    private void UpdateRpmAndPwmValues()
    {
        if (_hidStream is null)
        {
            return;
        }

        if (_hidStream is null)
        {
            return;
        }

        try
        {
            // Try to read available data (device sends periodically)
            byte[] response = null;
            int attempts = 0;
            const int maxAttempts = 3;

            while (attempts < maxAttempts)
            {
                try
                {
                    // Set short timeout to check if data is available
                    var originalTimeout = _hidStream.ReadTimeout;
                    _hidStream.ReadTimeout = 200;

                    response = new byte[PACKET_SIZE];
                    int bytesRead = _hidStream.Read(response, 0, PACKET_SIZE);

                    _hidStream.ReadTimeout = originalTimeout;

                    if (bytesRead >= PACKET_SIZE && response[0] == 0x01)
                    {
                        // Valid response with Report ID 0x01
                        break;
                    }
                }
                catch (TimeoutException)
                {
                    // No data available yet, continue trying
                }
                catch
                {
                    // Retry on other errors
                }

                attempts++;
                if (attempts < maxAttempts) Thread.Sleep(50);
            }

            ProcessResponse(response);
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"RPM update failed: {ex.Message}");
        }
    }

    private void ProcessResponse(byte[] response)
    {
        if (response == null || response.Length < PACKET_SIZE || response[0] != 0x01)
        {
            return;
        }

        // Parse current PWM values from bytes 1-10 (sent by device)
        // Format: [Report ID=0x01, PWM[1-10] (bytes 1-10), RPM[1-10] (bytes 11-30, 2 bytes each), padding]
        for (int i = 0; i < CHANNEL_COUNT; i++)
        {
            if (1 + i < response.Length)
            {
                _currentDevicePwmValues[i] = response[1 + i];
            }
        }

        // Initialize requested PWM values with current device values on first read
        // This prevents other fans from resetting to 0% when one fan is set to manual
        if (!_pwmValuesInitialized)
        {
            lock (_controlLock)
            {
                for (int i = 0; i < CHANNEL_COUNT; i++)
                {
                    _requestedFanSpeedsPercent[i] = _currentDevicePwmValues[i];
                }
                _pwmValuesInitialized = true;
            }
        }

        // Parse RPM values from bytes 11-30 (10 RPM values as uint16 little-endian)
        for (int i = 0; i < CHANNEL_COUNT; i++)
        {
            int rpmIndex = 11 + i * 2;
            if (rpmIndex + 1 < response.Length)
            {
                int rpmLow = response[rpmIndex];
                int rpmHigh = response[rpmIndex + 1];
                _currentFanRpms[i] = rpmLow | (rpmHigh << 8);
            }
        }
    }

    private void SendPWMUpdateIfRequired()
    {
        float[] values = null;
        lock (_controlLock)
        {
            if (!_sendPwmRequested)
            {
                return;
            }

            _sendPwmRequested = false;
            values = _requestedFanSpeedsPercent.ToArray();
        }

        try
        {
            // New format: [Report ID=0x01, PWM[0-9] (10 bytes), padding (21 bytes)]
            byte[] pwmPacket = new byte[PACKET_SIZE];
            pwmPacket[0] = 0x01; // Report ID

            // Set all fan speeds (bytes 1-10)
            for (int i = 0; i < CHANNEL_COUNT; i++)
            {
                pwmPacket[1 + i] = (byte)Math.Round(values[i]);
            }
            // Rest are zeros (already initialized)

            _hidStream.Write(pwmPacket);
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"PWM update failed: {ex.Message}");
        }
    }

    private float GetRPM(int fanIndex)
    {
        if (fanIndex < 1 || fanIndex > CHANNEL_COUNT)
        {
            return 0;
        }

        return _currentFanRpms[fanIndex - 1];
    }
}

```

`LibreHardwareMonitorLib/Hardware/Controller/Arctic/ArcticGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Controller.Arctic;

internal class ArcticGroup : IGroup
{
    private readonly List<IHardware> _hardware = new();
    private readonly StringBuilder _report = new();

    private const int VendorId = 0x3904;
    private const int ProductId = 0xF001;

    public ArcticGroup(ISettings settings)
    {
        _report.AppendLine("ARCTIC Hardware");
        _report.AppendLine();
        try
        {
            var devices = DeviceList.Local.GetHidDevices(VendorId, ProductId);
            var hidDevice = devices.FirstOrDefault();

            if (hidDevice != null)
            {
                _hardware.Add(new ArcticFanController(hidDevice, settings));
                _report.AppendLine("ARCTIC Fan Controller initialized successfully");
            }
        }
        catch (Exception ex)
        {
            _report.AppendLine($"ARCTIC Fan Controller Plugin initialization failed: {ex.Message}");
        }
    }

    public IReadOnlyList<IHardware> Hardware => _hardware;

    public void Close()
    {
        foreach (IHardware iHardware in _hardware)
        {
            if (iHardware is Hardware hardware)
            {
                hardware.Close();
            }
        }
    }

    public string GetReport()
    {
        return _report.ToString();
    }
}

```

`LibreHardwareMonitorLib/Hardware/Controller/Arctic/README.MD`:

```MD
# Fan Controller Device Integration Guide

Arctic Fan Controller USB Custom HID device that accepts 10 PWM commands (0–100%) via OUT reports and returns current PWM values plus 10 RPM sensor readings (0–65535) via IN reports every ~1 second, using 32-byte reports.

## Protocol

**Interface:** USB Custom HID  
**Vendor ID (VID):** 0x3904 (14596 decimal)  
**Product ID (PID):** 0xF001 (61441 decimal)  
**Report Size:** 32 bytes  
**Report ID:** 0x01 (byte 0)

------------------------------------------------

## PWM Control (OUT Report)

**Format:**
- Byte 0: Report ID = `0x01`
- Bytes 1-10: PWM duty cycle for channels 1-10 (0-100)
- Bytes 11-31: Ignored

**Specifications:**
- 10 channels (1-10)
- Range: 0-100 (percentage)

**Example:** Set channel 1 to 50%, channel 2 to 75%
```
[0x01, 50, 75, ...]
```

------------------------------------------------

## RPM Reading (IN Report)

**Format:**
- Byte 0: Report ID = `0x01`
- Bytes 1-10: Current PWM values
- Bytes 11-30: RPM values for sensors 1-10 (uint16, little-endian)
  - Sensor 1: bytes 11-12
  - Sensor 2: bytes 13-14
  - ... (2 bytes per sensor)
- Byte 31: Padding

**Specifications:**
- 10 sensors (1-10)
- Range: 0-65535 RPM
- Update rate: ~1 second

**Example:** Read sensor 1 RPM
```
RPM = buffer[11] + (buffer[12] << 8)
```

------------------------------------------------

## Notes

- Report ID `0x01` required in all reports
- RPM updates every ~1 second
- PWM values take effect immediately
- All multi-byte values are little-endian



# Complete Transaction Examples 

### OUT Transaction (PC → Device)

Setting PWM: Channel 1 = 50%, Channels 2-10 = 75%

```
Byte:  0     1     2     3     4     5     6     7     8     9    10    11    12    13    14    15    16    17    18    19    20    21    22    23    24    25    26    27    28    29    30    31
Hex:   0x01  0x32  0x4B  0x4B  0x4B  0x4B  0x4B  0x4B  0x4B  0x4B  0x4B  0x00  0x00  0x00  0x00  0x00  0x00  0x00  0x00  0x00  0x00  0x00  0x00  0x00  0x00  0x00  0x00  0x00  0x00  0x00  0x00
Dec:   1     50    75    75    75    75    75    75    75    75    75    0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
       └─┘   └────────────────────────────────────────────────────────┘  └────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
       ID    PWM Channels 1-10 (duty cycle %)                             Ignored
```

**Explanation:**
- Byte 0: Report ID = 1 (0x01)
- Bytes 1-10: PWM duty cycles = 50%, 75%, 75%, 75%, 75%, 75%, 75%, 75%, 75%, 75%
- Bytes 11-31: Ignored (all zeros)

---

### IN Transaction (Device → PC)

Reading current PWM and RPM values

```
Byte:  0     1     2     3     4     5     6     7     8     9    10    11    12    13    14    15    16    17    18    19    20    21    22    23    24    25    26    27    28    29    30    31
Hex:   0x01  0x32  0x4B  0x4B  0x4B  0x4B  0x4B  0x4B  0x4B  0x4B  0x4B  0xDC  0x05  0xD0  0x07  0xD0  0x07  0xD0  0x07  0xD0  0x07  0xD0  0x07  0xD0  0x07  0xD0  0x07  0xD0  0x07  0xD0  0x07  0x00
Dec:   1     50    75    75    75    75    75    75    75    75    75    220   5     208   7     208   7     208   7     208   7     208   7     208   7     208   7     208   7     208   7     0
       └─┘   └────────────────────────────────────────────────────────┘  └──────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘   └┘
       ID    Current PWM values (Channels 1-10)                         RPM values (Sensors 1-10, uint16 little-endian)                                                                       Padding
```

**Explanation:**
- Byte 0: Report ID = 1 (0x01)
- Bytes 1-10: Current PWM values = 50%, 75%, 75%, 75%, 75%, 75%, 75%, 75%, 75%, 75%
- Bytes 11-12: Sensor 1 RPM = 0x05DC = 1500 RPM (220 + 5×256)
- Bytes 13-14: Sensor 2 RPM = 0x07D0 = 2000 RPM (208 + 7×256)
- Bytes 15-16: Sensor 3 RPM = 0x07D0 = 2000 RPM (208 + 7×256)
- Bytes 17-18: Sensor 4 RPM = 0x07D0 = 2000 RPM (208 + 7×256)
- Bytes 19-20: Sensor 5 RPM = 0x07D0 = 2000 RPM (208 + 7×256)
- Bytes 21-22: Sensor 6 RPM = 0x07D0 = 2000 RPM (208 + 7×256)
- Bytes 23-24: Sensor 7 RPM = 0x07D0 = 2000 RPM (208 + 7×256)
- Bytes 25-26: Sensor 8 RPM = 0x07D0 = 2000 RPM (208 + 7×256)
- Bytes 27-28: Sensor 9 RPM = 0x07D0 = 2000 RPM (208 + 7×256)
- Bytes 29-30: Sensor 10 RPM = 0x07D0 = 2000 RPM (208 + 7×256)
- Byte 31: Padding = 0

```

`LibreHardwareMonitorLib/Hardware/Controller/Heatmaster/Heatmaster.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Globalization;
using System.IO;
using System.IO.Ports;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;

namespace LibreHardwareMonitor.Hardware.Controller.Heatmaster;

internal sealed class Heatmaster : Hardware, IDisposable
{
    private readonly bool _available;
    private readonly StringBuilder _buffer = new();
    private readonly Sensor[] _controls;
    private readonly Sensor[] _fans;
    private readonly int _firmwareCrc;
    private readonly int _firmwareRevision;
    private readonly Sensor[] _flows;
    private readonly int _hardwareRevision;
    private readonly string _portName;
    private readonly Sensor[] _relays;
    private readonly Sensor[] _temperatures;
    private SerialPort _serialPort;

    public Heatmaster(string portName, ISettings settings) : base("Heatmaster", new Identifier("heatmaster", portName.TrimStart('/').ToLowerInvariant()), settings)
    {
        _portName = portName;
        try
        {
            _serialPort = new SerialPort(portName, 38400, Parity.None, 8, StopBits.One);
            _serialPort.Open();
            _serialPort.NewLine = ((char)0x0D).ToString();

            _hardwareRevision = ReadInteger(0, 'H');
            _firmwareRevision = ReadInteger(0, 'V');
            _firmwareCrc = ReadInteger(0, 'C');

            int fanCount = Math.Min(ReadInteger(32, '?'), 4);
            int temperatureCount = Math.Min(ReadInteger(48, '?'), 6);
            int flowCount = Math.Min(ReadInteger(64, '?'), 1);
            int relayCount = Math.Min(ReadInteger(80, '?'), 1);

            _fans = new Sensor[fanCount];
            _controls = new Sensor[fanCount];
            for (int i = 0; i < fanCount; i++)
            {
                int device = 33 + i;
                string name = ReadString(device, 'C');
                _fans[i] = new Sensor(name, device, SensorType.Fan, this, settings) { Value = ReadInteger(device, 'R') };
                ActivateSensor(_fans[i]);
                _controls[i] = new Sensor(name, device, SensorType.Control, this, settings) { Value = (100 / 255.0f) * ReadInteger(device, 'P') };
                ActivateSensor(_controls[i]);
            }

            _temperatures = new Sensor[temperatureCount];
            for (int i = 0; i < temperatureCount; i++)
            {
                int device = 49 + i;
                string name = ReadString(device, 'C');
                _temperatures[i] = new Sensor(name, device, SensorType.Temperature, this, settings);
                int value = ReadInteger(device, 'T');
                _temperatures[i].Value = 0.1f * value;
                if (value != -32768)
                    ActivateSensor(_temperatures[i]);
            }

            _flows = new Sensor[flowCount];
            for (int i = 0; i < flowCount; i++)
            {
                int device = 65 + i;
                string name = ReadString(device, 'C');
                _flows[i] = new Sensor(name, device, SensorType.Flow, this, settings) { Value = 0.1f * ReadInteger(device, 'L') };
                ActivateSensor(_flows[i]);
            }

            _relays = new Sensor[relayCount];
            for (int i = 0; i < relayCount; i++)
            {
                int device = 81 + i;
                string name = ReadString(device, 'C');
                _relays[i] = new Sensor(name, device, SensorType.Control, this, settings)
                {
                    Value = 100 * ReadInteger(device, 'S')
                };
                ActivateSensor(_relays[i]);
            }

            // set the update rate to 2 Hz
            WriteInteger(0, 'L', 2);
            _available = true;
        }
        catch (IOException)
        { }
        catch (TimeoutException)
        { }
    }

    public override HardwareType HardwareType
    {
        get { return HardwareType.Cooler; }
    }

    public void Dispose()
    {
        if (_serialPort != null)
        {
            _serialPort.Dispose();
            _serialPort = null;
        }
    }

    private string ReadLine(int timeout)
    {
        int i = 0;
        StringBuilder builder = new();
        while (i <= timeout)
        {
            while (_serialPort.BytesToRead > 0)
            {
                byte b = (byte)_serialPort.ReadByte();
                switch (b)
                {
                    case 0xAA: return ((char)b).ToString();
                    case 0x0D: return builder.ToString();
                    default:
                        builder.Append((char)b);
                        break;
                }
            }

            i++;
            Thread.Sleep(1);
        }

        throw new TimeoutException();
    }

    private string ReadField(int device, char field)
    {
        _serialPort.WriteLine("[0:" + device + "]R" + field);
        for (int i = 0; i < 5; i++)
        {
            string s = ReadLine(200);
            Match match = Regex.Match(s, @"-\[0:" + device.ToString(CultureInfo.InvariantCulture) + @"\]R" + Regex.Escape(field.ToString(CultureInfo.InvariantCulture)) + ":(.*)");
            if (match.Success)
                return match.Groups[1].Value;
        }

        return null;
    }

    private string ReadString(int device, char field)
    {
        string s = ReadField(device, field);
        if (s?[0] == '"' && s[s.Length - 1] == '"')
            return s.Substring(1, s.Length - 2);

        return null;
    }

    private int ReadInteger(int device, char field)
    {
        string s = ReadField(device, field);
        if (int.TryParse(s, out int i))
            return i;

        return 0;
    }

    private void WriteField(int device, char field, string value)
    {
        _serialPort.WriteLine("[0:" + device + "]W" + field + ":" + value);
        for (int i = 0; i < 5; i++)
        {
            string s = ReadLine(200);
            Match match = Regex.Match(s, @"-\[0:" + device.ToString(CultureInfo.InvariantCulture) + @"\]W" + Regex.Escape(field.ToString(CultureInfo.InvariantCulture)) + ":" + value);
            if (match.Success)
                return;
        }
    }

    private void WriteInteger(int device, char field, int value)
    {
        WriteField(device, field, value.ToString(CultureInfo.InvariantCulture));
    }

    private void ProcessUpdateLine(string line)
    {
        Match match = Regex.Match(line, @">\[0:(\d+)\]([0-9:\|-]+)");
        if (match.Success && int.TryParse(match.Groups[1].Value, out int device))
        {
            foreach (string s in match.Groups[2].Value.Split('|'))
            {
                string[] strings = s.Split(':');
                int[] ints = new int[strings.Length];
                bool valid = true;
                for (int i = 0; i < ints.Length; i++)
                {
                    if (!int.TryParse(strings[i], out ints[i]))
                    {
                        valid = false;
                        break;
                    }
                }

                if (!valid)
                    continue;

                switch (device)
                {
                    case 32:
                        if (ints.Length == 3 && ints[0] <= _fans.Length)
                        {
                            _fans[ints[0] - 1].Value = ints[1];
                            _controls[ints[0] - 1].Value = (100 / 255.0f) * ints[2];
                        }

                        break;
                    case 48:
                        if (ints.Length == 2 && ints[0] <= _temperatures.Length)
                            _temperatures[ints[0] - 1].Value = 0.1f * ints[1];

                        break;
                    case 64:
                        if (ints.Length == 3 && ints[0] <= _flows.Length)
                            _flows[ints[0] - 1].Value = 0.1f * ints[1];

                        break;
                    case 80:
                        if (ints.Length == 2 && ints[0] <= _relays.Length)
                            _relays[ints[0] - 1].Value = 100 * ints[1];

                        break;
                }
            }
        }
    }

    public override void Update()
    {
        if (!_available)
            return;

        while (_serialPort.IsOpen && _serialPort.BytesToRead > 0)
        {
            byte b = (byte)_serialPort.ReadByte();
            if (b == 0x0D)
            {
                ProcessUpdateLine(_buffer.ToString());
                _buffer.Length = 0;
            }
            else
            {
                _buffer.Append((char)b);
            }
        }
    }

    public override string GetReport()
    {
        StringBuilder r = new();
        r.AppendLine("Heatmaster");
        r.AppendLine();
        r.Append("Port: ");
        r.AppendLine(_portName);
        r.Append("Hardware Revision: ");
        r.AppendLine(_hardwareRevision.ToString(CultureInfo.InvariantCulture));
        r.Append("Firmware Revision: ");
        r.AppendLine(_firmwareRevision.ToString(CultureInfo.InvariantCulture));
        r.Append("Firmware CRC: ");
        r.AppendLine(_firmwareCrc.ToString(CultureInfo.InvariantCulture));
        r.AppendLine();
        return r.ToString();
    }

    public override void Close()
    {
        _serialPort.Close();
        _serialPort.Dispose();
        _serialPort = null;
        base.Close();
    }
}

```

`LibreHardwareMonitorLib/Hardware/Controller/Heatmaster/HeatmasterGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO.Ports;
using System.Security;
using System.Text;
using System.Threading;
using Microsoft.Win32;

namespace LibreHardwareMonitor.Hardware.Controller.Heatmaster;

internal class HeatmasterGroup : IGroup
{
    private readonly List<Heatmaster> _hardware = new();
    private readonly StringBuilder _report = new();

    public HeatmasterGroup(ISettings settings)
    {
        // No implementation for Heatmaster on Unix systems
        if (Software.OperatingSystem.IsUnix)
            return;

        string[] portNames = GetRegistryPortNames();
        for (int i = 0; i < portNames.Length; i++)
        {
            bool isValid = false;
            try
            {
                using SerialPort serialPort = new(portNames[i], 38400, Parity.None, 8, StopBits.One);
                serialPort.NewLine = ((char)0x0D).ToString();
                _report.Append("Port Name: ");
                _report.AppendLine(portNames[i]);
                try
                {
                    serialPort.Open();
                }
                catch (UnauthorizedAccessException)
                {
                    _report.AppendLine("Exception: Access Denied");
                }

                if (serialPort.IsOpen)
                {
                    serialPort.DiscardInBuffer();
                    serialPort.DiscardOutBuffer();
                    serialPort.Write(new byte[] { 0xAA }, 0, 1);

                    int j = 0;
                    while (serialPort.BytesToRead == 0 && j < 10)
                    {
                        Thread.Sleep(20);
                        j++;
                    }

                    if (serialPort.BytesToRead > 0)
                    {
                        bool flag = false;
                        while (serialPort.BytesToRead > 0 && !flag)
                        {
                            flag |= serialPort.ReadByte() == 0xAA;
                        }

                        if (flag)
                        {
                            serialPort.WriteLine("[0:0]RH");
                            try
                            {
                                int k = 0;
                                int revision = 0;
                                while (k < 5)
                                {
                                    string line = ReadLine(serialPort, 100);
                                    if (line.StartsWith("-[0:0]RH:", StringComparison.Ordinal))
                                    {
                                        revision = int.Parse(line.Substring(9), CultureInfo.InvariantCulture);
                                        break;
                                    }

                                    k++;
                                }

                                isValid = revision == 770;
                                if (!isValid)
                                {
                                    _report.Append("Status: Wrong Hardware Revision " + revision.ToString(CultureInfo.InvariantCulture));
                                }
                            }
                            catch (TimeoutException)
                            {
                                _report.AppendLine("Status: Timeout Reading Revision");
                            }
                        }
                        else
                        {
                            _report.AppendLine("Status: Wrong Startflag");
                        }
                    }
                    else
                    {
                        _report.AppendLine("Status: No Response");
                    }

                    serialPort.DiscardInBuffer();
                }
                else
                {
                    _report.AppendLine("Status: Port not Open");
                }
            }
            catch (Exception e)
            {
                _report.AppendLine(e.ToString());
            }

            if (isValid)
            {
                _report.AppendLine("Status: OK");
                _hardware.Add(new Heatmaster(portNames[i], settings));
            }

            _report.AppendLine();
        }
    }

    public IReadOnlyList<IHardware> Hardware => _hardware;

    public string GetReport()
    {
        if (_report.Length > 0)
        {
            StringBuilder r = new();
            r.AppendLine("Serial Port Heatmaster");
            r.AppendLine();
            r.Append(_report);
            r.AppendLine();
            return r.ToString();
        }

        return null;
    }

    public void Close()
    {
        foreach (Heatmaster heatmaster in _hardware)
            heatmaster.Close();
    }

    private static string ReadLine(SerialPort port, int timeout)
    {
        int i = 0;
        StringBuilder builder = new();
        while (i < timeout)
        {
            while (port.BytesToRead > 0)
            {
                byte b = (byte)port.ReadByte();
                switch (b)
                {
                    case 0xAA: return ((char)b).ToString();
                    case 0x0D: return builder.ToString();
                    default:
                        builder.Append((char)b);
                        break;
                }
            }

            i++;
            Thread.Sleep(1);
        }

        throw new TimeoutException();
    }

    private static string[] GetRegistryPortNames()
    {
        List<string> result = new();
        string[] paths = { string.Empty, "&MI_00" };
        try
        {
            foreach (string path in paths)
            {
                RegistryKey key = Registry.LocalMachine.OpenSubKey(@"SYSTEM\CurrentControlSet\Enum\USB\VID_10C4&PID_EA60" + path);
                if (key != null)
                {
                    foreach (string subKeyName in key.GetSubKeyNames())
                    {
                        RegistryKey subKey = key.OpenSubKey(subKeyName + "\\" + "Device Parameters");
                        if (subKey?.GetValue("PortName") is string name && !result.Contains(name))
                            result.Add(name);
                    }
                }
            }
        }
        catch (SecurityException)
        { }

        return result.ToArray();
    }
}

```

`LibreHardwareMonitorLib/Hardware/Controller/MSI/MsiConstants.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) Florian K. (Blacktempel)
// All Rights Reserved.

using System.Collections.Generic;

namespace LibreHardwareMonitor.Hardware.Controller.MSI;

internal static class MsiConstants
{
    public static readonly IReadOnlyList<MsiDevice> SupportedDevices = new List<MsiDevice>
    {
        new MsiDevice(MsiDeviceType.S280, 0x0DB0, 0x75B6, 0x6A04),
        new MsiDevice(MsiDeviceType.S360, 0x0DB0, 0x9BA6, 0x6A05),
        new MsiDevice(MsiDeviceType.S360MEG, 0x1462, 0x9BA6, 0x6A05),
        new MsiDevice(MsiDeviceType.X360, 0x0DB0, 0x5259, 0x6A11),
        new MsiDevice(MsiDeviceType.X240, 0x0DB0, 0xC7B2, 0x6A10),
        new MsiDevice(MsiDeviceType.D360, 0x0DB0, 0x8DBF, 0x6A15),
        new MsiDevice(MsiDeviceType.D240, 0x0DB0, 0xD085, 0x6A16),
    };
}

```

`LibreHardwareMonitorLib/Hardware/Controller/MSI/MsiCoreLiquidController.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) Florian K. (Blacktempel)
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Controller.MSI;

internal class MsiCoreLiquidController : Hardware
{
    private const int MutexTimeout = 500;
    private const int DataLength = 64;

    private readonly MsiDevice _msiDevice;
    private readonly HidDevice _hidDevice;

    private readonly List<MsiSensor> _sensors = [];

    private Sensor _fan1;
    private Sensor _fan2;
    private Sensor _fan3;
    private Sensor _fan4;
    private Sensor _fan5;

    public MsiCoreLiquidController(MsiDevice msiDevice, HidDevice hidDevice, ISettings settings)
        : base(msiDevice.Name, new(hidDevice), settings)
    {
        _msiDevice = msiDevice;
        _hidDevice = hidDevice;

        CreateSensors();
    }

    public MsiDevice MsiDevice => _msiDevice;

    public override HardwareType HardwareType => HardwareType.Cooler;

    public override void Update()
    {
        var msi = new MsiFanControl();

        if (GetCoolerStatus(msi) && GetFanConfigure(msi) && GetFanTemperatureConfigure(msi))
        {
            _sensors.ForEach(s => s.Update(msi));
        }
    }

    public override string GetReport()
    {
        var sb = new StringBuilder();

        sb.AppendLine($"{MsiDevice.Name} - ({MsiDevice.VendorId:X4}:{MsiDevice.ProductIdController:X4})");

        foreach (var sensor in _sensors)
        {
            sb.AppendLine($"{sensor.Name}: {sensor.Value?.ToString() ?? "No value"}");
        }

        return sb.ToString();
    }

    private void CreateSensors()
    {
        if (MsiDevice.DeviceType == MsiDeviceType.S360)
        {
            _fan1 = AddSensor("Radiator Fan", 10, SensorType.Fan, m => m.Fan1.Speed);
            _fan4 = AddSensor("Pump Fan", 13, SensorType.Fan, m => m.Fan4.Speed);
            _fan5 = AddSensor("Pump", 14, SensorType.Fan, m => m.Fan5.Speed);
        }
        else //May need other mapping for different devices
        {
            _fan1 = AddSensor("Fan 1", 10, SensorType.Fan, m => m.Fan1.Speed);
            _fan2 = AddSensor("Fan 2", 11, SensorType.Fan, m => m.Fan2.Speed);
            _fan3 = AddSensor("Fan 3", 12, SensorType.Fan, m => m.Fan3.Speed);
            _fan4 = AddSensor("Fan 4", 13, SensorType.Fan, m => m.Fan4.Speed);
            _fan5 = AddSensor("Fan 5", 14, SensorType.Fan, m => m.Fan5.Speed);
        }

        AddSensor("Inlet Temperature", 0, SensorType.Temperature, m => m.TemperatureInlet);
        AddSensor("Liquid Temperature", 1, SensorType.Temperature, m => m.TemperatureOutlet); //Msi: "Liquid_Temp"
        AddSensor("Temperature Sensor 1", 2, SensorType.Temperature, m => m.TemperatureSensor1 == 125 ? -100 : m.TemperatureSensor1);
        AddSensor("Temperature Sensor 2", 3, SensorType.Temperature, m => m.TemperatureSensor2 == 125 ? -100 : m.TemperatureSensor2);

        void TryAddFanControl(Sensor fan)
        {
            if (fan != null)
            {
                var ctrl = new Control(fan, _settings, 0, 100);
                fan.Control = ctrl;
                ctrl.ControlModeChanged += OnFanControlModeChanged;
                ctrl.SoftwareControlValueChanged += OnSoftwareControlValueChanged;

                MsiSensor fanControl = null;

                switch (fan)
                {
                    case var f when f == _fan1:
                        fanControl = AddSensor($"{fan.Name} Control", 50, SensorType.Control, m => m.Fan1.ConfigureDuty.Item0);
                        break;
                    case var f when f == _fan2:
                        fanControl = AddSensor($"{fan.Name} Control", 51, SensorType.Control, m => m.Fan2.ConfigureDuty.Item0);
                        break;
                    case var f when f == _fan3:
                        fanControl = AddSensor($"{fan.Name} Control", 52, SensorType.Control, m => m.Fan3.ConfigureDuty.Item0);
                        break;
                    case var f when f == _fan4:
                        fanControl = AddSensor($"{fan.Name} Control", 53, SensorType.Control, m => m.Fan4.ConfigureDuty.Item0);
                        break;
                    case var f when f == _fan5:
                        fanControl = AddSensor($"{fan.Name} Control", 54, SensorType.Control, m => m.Fan5.ConfigureDuty.Item0);
                        break;
                }

                if (fanControl != null)
                {
                    fanControl.Control = ctrl;

                    _sensors.Add(fanControl);

                    ActivateSensor(fanControl);
                }
            }
        }

        //Fan Controls
        TryAddFanControl(_fan1);
        TryAddFanControl(_fan2);
        TryAddFanControl(_fan3);
        TryAddFanControl(_fan4);
        TryAddFanControl(_fan5);
    }

    private MsiSensor AddSensor(string name, int index, SensorType sensorType, GetMsiSensorValue getValue)
    {
        var sensor = new MsiSensor(name, index, sensorType, this, _settings, getValue);

        _sensors.Add(sensor);

        ActivateSensor(sensor);

        return sensor;
    }

    private void OnFanControlModeChanged(Control control)
    {
        var msi = new MsiFanControl();

        if (GetFanConfigure(msi) && GetFanTemperatureConfigure(msi))
        {
            var fan = GetFanFromControl(msi, control);

            if (fan == null)
            {
                return;
            }

            switch (control.ControlMode)
            {
                case ControlMode.Software:
                    fan.ConfigureDuty.Mode = MsiFanMode.Custom;
                    break;
                case ControlMode.Default:
                    fan.ConfigureDuty.Mode = MsiFanMode.Bios;
                    break;
                default:
                    return;
            }

            SetFanConfigure(msi);
        }
    }

    private void OnSoftwareControlValueChanged(Control control)
    {
        var msi = new MsiFanControl();

        if (GetFanConfigure(msi) && GetFanTemperatureConfigure(msi))
        {
            var fan = GetFanFromControl(msi, control);

            if (fan == null)
            {
                return;
            }

            byte value = (byte)control.SoftwareValue;

            if (value < 0)
            {
                value = 0;
            }
            else if (value > 100)
            {
                value = 100;
            }

            //Set requested speed in % and CPU temperature in degrees Celsius
            fan.ConfigureDuty.Item0 = value;
            fan.ConfigureTemp.Item0 = 0; //Set temperature to 0 to use fixed duty instead of temperature curve

            fan.ConfigureDuty.Item1 = value;
            fan.ConfigureTemp.Item1 = 90;

            //Add failsafe to prevent fan from stopping at high temperatures if user sets low duty
            fan.ConfigureDuty.Item2 = 100; //Max fan
            fan.ConfigureTemp.Item2 = 91;

            fan.ConfigureDuty.Item3 = 100; //Max fan
            fan.ConfigureTemp.Item3 = 95;

            SetFanConfigure(msi);
            SetFanTemperatureConfigure(msi);
        }
    }

    private MsiFan GetFanFromControl(MsiFanControl msi, Control control)
    {
        MsiFan fan = null;

        if (control.Sensor == _fan1)
            fan = msi.Fan1;
        else if (control.Sensor == _fan2)
            fan = msi.Fan2;
        else if (control.Sensor == _fan3)
            fan = msi.Fan3;
        else if (control.Sensor == _fan4)
            fan = msi.Fan4;
        else if (control.Sensor == _fan5)
            fan = msi.Fan5;

        return fan;
    }

    private bool GetCoolerStatus(MsiFanControl msi)
    {
        var buffer = GetBuffer();
        buffer[0] = 0xD0;
        buffer[1] = 0x31;

        var data = GetData(buffer);

        if (data == null || data[1] != buffer[1])
        {
            return false;
        }

        msi.Fan1.Speed = GetInt16(data, 2);
        msi.Fan2.Speed = GetInt16(data, 4);
        msi.Fan3.Speed = GetInt16(data, 6);
        msi.Fan4.Speed = GetInt16(data, 8);
        msi.Fan5.Speed = GetInt16(data, 10);

        msi.TemperatureInlet = data[12];
        msi.TemperatureOutlet = data[14];
        msi.TemperatureSensor1 = GetInt16(data, 16);
        msi.TemperatureSensor2 = GetInt16(data, 18);

        msi.Fan1.Duty = GetInt16(data, 22);
        msi.Fan2.Duty = GetInt16(data, 24);
        msi.Fan3.Duty = GetInt16(data, 26);
        msi.Fan4.Duty = GetInt16(data, 28);
        msi.Fan5.Duty = GetInt16(data, 30);

        return true;
    }

    private bool GetFanConfigure(MsiFanControl msi)
    {
        var buffer = GetBuffer();
        buffer[0] = 0xD0;
        buffer[1] = 0x32;

        var data = GetData(buffer);

        if (data == null || data[1] != buffer[1])
        {
            return false;
        }

        int startIndex = 2;

        msi.Fan1.ConfigureDuty = BytesToStruct<MsiFanConfigure>(data, startIndex);
        msi.Fan2.ConfigureDuty = BytesToStruct<MsiFanConfigure>(data, startIndex += Marshal.SizeOf<MsiFanConfigure>());
        msi.Fan3.ConfigureDuty = BytesToStruct<MsiFanConfigure>(data, startIndex += Marshal.SizeOf<MsiFanConfigure>());
        msi.Fan4.ConfigureDuty = BytesToStruct<MsiFanConfigure>(data, startIndex += Marshal.SizeOf<MsiFanConfigure>());
        msi.Fan5.ConfigureDuty = BytesToStruct<MsiFanConfigure>(data, startIndex += Marshal.SizeOf<MsiFanConfigure>());

        return true;
    }

    private bool GetFanTemperatureConfigure(MsiFanControl msi)
    {
        var buffer = GetBuffer();
        buffer[0] = 0xD0;
        buffer[1] = 0x33;

        var data = GetData(buffer);

        if (data == null || (data[1] != buffer[1] && data[1] != 0x32))
        {
            return false;
        }

        int startIndex = 2;

        msi.Fan1.ConfigureTemp = BytesToStruct<MsiFanConfigure>(data, startIndex);
        msi.Fan2.ConfigureTemp = BytesToStruct<MsiFanConfigure>(data, startIndex += Marshal.SizeOf<MsiFanConfigure>());
        msi.Fan3.ConfigureTemp = BytesToStruct<MsiFanConfigure>(data, startIndex += Marshal.SizeOf<MsiFanConfigure>());
        msi.Fan4.ConfigureTemp = BytesToStruct<MsiFanConfigure>(data, startIndex += Marshal.SizeOf<MsiFanConfigure>());
        msi.Fan5.ConfigureTemp = BytesToStruct<MsiFanConfigure>(data, startIndex += Marshal.SizeOf<MsiFanConfigure>());

        return true;
    }

    private void SetFanConfigure(MsiFanControl msi)
    {
        var buffer = GetBuffer();
        buffer[0] = 0xD0;
        buffer[1] = 0x40;

        int startIndex = 2;

        StructToBytes(msi.Fan1.ConfigureDuty, buffer, startIndex);
        StructToBytes(msi.Fan2.ConfigureDuty, buffer, startIndex += Marshal.SizeOf<MsiFanConfigure>());
        StructToBytes(msi.Fan3.ConfigureDuty, buffer, startIndex += Marshal.SizeOf<MsiFanConfigure>());
        StructToBytes(msi.Fan4.ConfigureDuty, buffer, startIndex += Marshal.SizeOf<MsiFanConfigure>());
        StructToBytes(msi.Fan5.ConfigureDuty, buffer, startIndex += Marshal.SizeOf<MsiFanConfigure>());

        SetData(buffer);
    }

    private void SetFanTemperatureConfigure(MsiFanControl msi)
    {
        var buffer = GetBuffer();
        buffer[0] = 0xD0;
        buffer[1] = 0x41;

        int startIndex = 2;

        StructToBytes(msi.Fan1.ConfigureTemp, buffer, startIndex);
        StructToBytes(msi.Fan2.ConfigureTemp, buffer, startIndex += Marshal.SizeOf<MsiFanConfigure>());
        StructToBytes(msi.Fan3.ConfigureTemp, buffer, startIndex += Marshal.SizeOf<MsiFanConfigure>());
        StructToBytes(msi.Fan4.ConfigureTemp, buffer, startIndex += Marshal.SizeOf<MsiFanConfigure>());
        StructToBytes(msi.Fan5.ConfigureTemp, buffer, startIndex += Marshal.SizeOf<MsiFanConfigure>());

        SetData(buffer);
    }

    private static T BytesToStruct<T>(byte[] data, int startIndex) where T : struct
    {
        int size = Marshal.SizeOf<T>();

        if (startIndex < 0 || startIndex + size > data.Length)
        {
            throw new ArgumentOutOfRangeException(nameof(startIndex));
        }

        var handle = GCHandle.Alloc(data, GCHandleType.Pinned);
        try
        {
            IntPtr ptr = handle.AddrOfPinnedObject() + startIndex;
            return Marshal.PtrToStructure<T>(ptr);
        }
        finally
        {
            handle.Free();
        }
    }

    private static void StructToBytes<T>(in T value, byte[] buffer, int startIndex) where T : struct
    {
        int size = Marshal.SizeOf<T>();

        if (startIndex < 0 || startIndex + size > buffer.Length)
        {
            throw new ArgumentOutOfRangeException(nameof(startIndex));
        }

        var handle = GCHandle.Alloc(buffer, GCHandleType.Pinned);
        try
        {
            IntPtr ptr = handle.AddrOfPinnedObject() + startIndex;
            Marshal.StructureToPtr(value, ptr, false);
        }
        finally
        {
            handle.Free();
        }
    }

    private byte[] GetData(byte[] inbuf)
    {
        HidStream stream = null;

        if (!Mutexes.WaitUsbSensors(MutexTimeout))
        {
            return null;
        }

        try
        {
            var outBuf = new byte[DataLength];

            if (!_hidDevice.TryOpen(out stream))
            {
                return null;
            }

            stream.Write(inbuf);
            Thread.Sleep(10); //Msi is using that interval
            var readResult = stream.Read(outBuf);

            if (readResult <= 0)
            {
                return null;
            }

            return outBuf;
        }
        finally
        {
            stream?.Close();
            stream?.Dispose();

            Mutexes.ReleaseUsbSensors();
        }
    }

    private void SetData(byte[] buf)
    {
        HidStream stream = null;

        if (!Mutexes.WaitUsbSensors(MutexTimeout))
        {
            return;
        }

        try
        {
            if (!_hidDevice.TryOpen(out stream))
            {
                return;
            }

            stream.Write(buf);
        }
        finally
        {
            stream?.Close();
            stream?.Dispose();

            Mutexes.ReleaseUsbSensors();
        }
    }

    private byte[] GetBuffer()
    {
        return new byte[DataLength];
    }

    private static int GetInt16(byte[] buffer, int offset)
    {
        return buffer[offset] + (buffer[offset + 1] << 8);
    }
}

```

`LibreHardwareMonitorLib/Hardware/Controller/MSI/MsiDevice.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) Florian K. (Blacktempel)
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware.Controller.MSI;

public enum MsiDeviceType
{
    S280,
    S360,
    S360MEG,
    X360,
    X240,
    D360,
    D240,
}

public class MsiDevice
{
    public MsiDevice(MsiDeviceType msiDeviceType, int vendorId, int productId, int productIdController)
    {
        DeviceType = msiDeviceType;
        VendorId = vendorId;
        ProductId = productId;
        ProductIdController = productIdController;
    }

    public MsiDeviceType DeviceType { get; }
    public int VendorId { get; }
    public int ProductId { get; }
    public int ProductIdController { get; }

    public string Name
    {
        get
        {
            switch (DeviceType)
            {
                case MsiDeviceType.S280:
                    return "MSI CoreLiquid S280";
                case MsiDeviceType.S360:
                    return "MSI CoreLiquid S360";
                case MsiDeviceType.S360MEG:
                    return "MSI CoreLiquid S360 MEG";
                case MsiDeviceType.X360:
                    return "MSI CoreLiquid X360";
                case MsiDeviceType.X240:
                    return "MSI CoreLiquid X240";
                case MsiDeviceType.D360:
                    return "MSI CoreLiquid D360";
                case MsiDeviceType.D240:
                    return "MSI CoreLiquid D240";
                default:
                    return "Other";
            }
        }
    }

    //Relevant for further HWMonitoring later
    public bool SupportsHWMonitorIndex13and14(uint firmwareVersion)
    {
        switch (DeviceType)
        {
            case MsiDeviceType.S280:
            case MsiDeviceType.S360:
                return (firmwareVersion & byte.MaxValue) >= 10;
            case MsiDeviceType.S360MEG:
                return (firmwareVersion & byte.MaxValue) >= 7;
            case MsiDeviceType.X360:
            case MsiDeviceType.X240:
                return (firmwareVersion & byte.MaxValue) >= 3;
            case MsiDeviceType.D360:
            case MsiDeviceType.D240:
                return true;
        }

        return false;
    }
}

```

`LibreHardwareMonitorLib/Hardware/Controller/MSI/MsiFan.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) Florian K. (Blacktempel)
// All Rights Reserved.

using System;
using System.Runtime.InteropServices;

namespace LibreHardwareMonitor.Hardware.Controller.MSI;

public class MsiFan
{
    /// <summary>
    /// Speed of Fan in RPM.
    /// </summary>
    public int Speed { get; set; }
    public int Duty { get; set; }

    /// <summary>
    /// Speed of Fan in percentage 0-100. This can e.g. be used to set fan curve when <see cref="MsiFanConfigure.Mode"/> is <see cref="MsiFanMode.Custom"/>.
    /// </summary>
    public MsiFanConfigure ConfigureDuty;

    /// <summary>
    /// Temperature of Fan in degrees Celsius. This can e.g. be used to set fan curve when <see cref="MsiFanConfigure.Mode"/> is <see cref="MsiFanMode.Custom"/>.
    /// </summary>
    public MsiFanConfigure ConfigureTemp;
}

public struct MsiFanConfigure
{
    public MsiFanConfigure()
    {
        if (Marshal.SizeOf<MsiFanConfigure>() != 8)
        {
            throw new InvalidOperationException($"{nameof(MsiFanConfigure)} struct size is invalid.");
        }
    }

    public MsiFanMode Mode = MsiFanMode.Unknown;
    public byte Item0;
    public byte Item1;
    public byte Item2;
    public byte Item3;
    public byte Item4;
    public byte Item5;
    public byte Item6;
}

```

`LibreHardwareMonitorLib/Hardware/Controller/MSI/MsiFanControl.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) Florian K. (Blacktempel)
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware.Controller.MSI;

public class MsiFanControl
{
    public MsiFan Fan1 { get; set; } = new();
    public MsiFan Fan2 { get; set; } = new();
    public MsiFan Fan3 { get; set; } = new();
    public MsiFan Fan4 { get; set; } = new();
    public MsiFan Fan5 { get; set; } = new();

    public int TemperatureInlet { get; set; }
    public int TemperatureOutlet { get; set; }

    public int TemperatureSensor1 { get; set; }
    public int TemperatureSensor2 { get; set; }
}

```

`LibreHardwareMonitorLib/Hardware/Controller/MSI/MsiFanMode.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) Florian K. (Blacktempel)
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware.Controller.MSI;

public enum MsiFanMode : byte
{
    Silent = 0,
    Bios = 1,
    Game = 2,
    Custom = 3,
    Unknown = 4,
    Smart = 5,
}

```

`LibreHardwareMonitorLib/Hardware/Controller/MSI/MsiGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) Florian K. (Blacktempel)
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Controller.MSI;

internal class MsiGroup : IGroup
{
    private readonly List<IHardware> _hardware = new();
    private readonly StringBuilder _report = new();

    public MsiGroup(ISettings settings)
    {
        _report.AppendLine("MSI Hardware:");
        _report.AppendLine();

        //Get all HID devices
        var hidDevices = DeviceList.Local.GetHidDevices();

        foreach (var hidDevice in hidDevices)
        {
            //Check if the device is in the supported devices list
            var found = MsiConstants.SupportedDevices.FirstOrDefault(md => md.VendorId == hidDevice.VendorID && md.ProductIdController == hidDevice.ProductID);

            if (found == null)
            {
                continue;
            }

            try
            {
                var coreLiquidController = new MsiCoreLiquidController(found, hidDevice, settings);

                _hardware.Add(coreLiquidController);
                _report.AppendLine($"MSI Controller for '{hidDevice.GetProductName()}' ({hidDevice.VendorID:X4}:{hidDevice.ProductID:X4}) initialized successfully");
            }
            catch (Exception e)
            {
                _report.AppendLine($"Msi Controller Plugin initialization failed: {e.Message}");
            }
        }
    }

    public IReadOnlyList<IHardware> Hardware => _hardware;

    public void Close()
    {
        foreach (Hardware hw in _hardware.OfType<Hardware>())
        {
            hw.Close();
        }
    }

    public string GetReport()
    {
        var sb = new StringBuilder();
        sb.AppendLine(_report.ToString());

        _hardware.ForEach(hw => sb.AppendLine(hw.GetReport()));

        return sb.ToString();
    }
}

```

`LibreHardwareMonitorLib/Hardware/Controller/MSI/MsiSensor.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) Florian K. (Blacktempel)
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware.Controller.MSI;

internal delegate float GetMsiSensorValue(MsiFanControl msi);

internal class MsiSensor : Sensor
{
    private readonly GetMsiSensorValue _getValue;

    public MsiSensor(string name, int index, SensorType sensorType, Hardware hardware, ISettings settings, GetMsiSensorValue getValue)
        : base(name, index, sensorType, hardware, settings)
    {
        _getValue = getValue;
    }

    internal void Update(MsiFanControl msi)
    {
        float value = _getValue(msi);

        Value = value;
    }
}

```

`LibreHardwareMonitorLib/Hardware/Controller/Nzxt/GridV3.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Threading;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Controller.Nzxt;

/// <summary>
/// Support for the NZXT GRID+ V3 devices.
/// </summary>
internal sealed class GridV3 : Hardware
{
    private const int FANS_COUNT = 6;

    // Some initialization messages to send to the controller. No visible effects but NZXT CAM send them.
    private static readonly byte[] _initialize1 = { 0x01, 0x5c };
    private static readonly byte[] _initialize2 = { 0x01, 0x5d };
    private static readonly byte[] _initialize3 = { 0x01, 0x59 };

    private readonly Sensor[] _currents = new Sensor[FANS_COUNT];
    private readonly Control[] _fanControls = new Control[FANS_COUNT];
    private readonly Sensor _noise;
    private readonly Sensor[] _powers = new Sensor[FANS_COUNT];
    private readonly Sensor[] _pwmControls = new Sensor[FANS_COUNT];
    private readonly Dictionary<int, byte[]> _rawData = new();
    private readonly Sensor[] _rpmSensors = new Sensor[FANS_COUNT];
    private readonly byte[] _setFanSpeedMsg;
    private readonly HidStream _stream;
    private readonly Sensor[] _voltages = new Sensor[FANS_COUNT];

    public GridV3(HidDevice dev, ISettings settings) : base("NZXT GRID+ V3", new Identifier(dev), settings)
    {
        if (dev.TryOpen(out _stream))
        {
            for (int fanId = 0; fanId < FANS_COUNT; fanId++)
                _rawData[fanId] = new byte[21];

            _setFanSpeedMsg = new byte[65];
            _setFanSpeedMsg[0] = 0x02;
            _setFanSpeedMsg[1] = 0x4d;
            _setFanSpeedMsg[3] = 0x00;

            _stream.Write(_initialize1);
            _stream.Write(_initialize2);
            _stream.Write(_initialize3);

            do
            {
                _stream.Read(_rawData[0]);
                if (_rawData[0][0] == 0x04)
                {
                    FirmwareVersion = $"{_rawData[0][11]}.{_rawData[0][14]}";
                }
            }
            while (FirmwareVersion == null);

            Name = "NZXT GRID+ V3";

            // Initialize all sensors and controls for all fans
            for (int i = 0; i < FANS_COUNT; i++)
            {
                _rpmSensors[i] = new Sensor($"GRID Fan #{i + 1}", i, SensorType.Fan, this, Array.Empty<ParameterDescription>(), settings);
                _voltages[i] = new Sensor($"GRID Fan #{i + 1}", i, SensorType.Voltage, this, Array.Empty<ParameterDescription>(), settings);
                _currents[i] = new Sensor($"GRID Fan #{i + 1}", i, SensorType.Current, this, Array.Empty<ParameterDescription>(), settings);
                _powers[i] = new Sensor($"GRID Fan #{i + 1}", i, SensorType.Power, this, Array.Empty<ParameterDescription>(), settings);
                _pwmControls[i] = new Sensor($"GRID Fan #{i + 1}", i, SensorType.Control, this, Array.Empty<ParameterDescription>(), settings);

                _fanControls[i] = new Control(_pwmControls[i], settings, 0, 100);

                _pwmControls[i].Control = _fanControls[i];
                _fanControls[i].ControlModeChanged += SoftwareControlValueChanged;
                _fanControls[i].SoftwareControlValueChanged += SoftwareControlValueChanged;
                SoftwareControlValueChanged(_fanControls[i]);

                ActivateSensor(_rpmSensors[i]);
                ActivateSensor(_voltages[i]);
                ActivateSensor(_currents[i]);
                ActivateSensor(_powers[i]);
                ActivateSensor(_pwmControls[i]);

                // NZXT GRID does not report current PWM value. So we need to initialize it with some value to keep GUI and device values in sync.
                _fanControls[i].SetDefault();
            }

            _noise = new Sensor("GRID Noise", 0, SensorType.Noise, this, Array.Empty<ParameterDescription>(), settings);
            ActivateSensor(_noise);

            Thread readGridReports = new(ContinuousRead) { IsBackground = true };
            readGridReports.Start(_rawData);

            IsValid = true;
        }
    }

    public string FirmwareVersion { get; }

    public override HardwareType HardwareType => HardwareType.Cooler;

    public bool IsValid { get; }

    private void SoftwareControlValueChanged(Control control)
    {
        switch (control.ControlMode)
        {
            case ControlMode.Software:
                float value = control.SoftwareValue;
                byte fanSpeed = (byte)(value > 100 ? 100 : value < 0 ? 0 : value); // Clamp the value, anything out of range will fail

                //_controlling = true;
                _setFanSpeedMsg[2] = (byte)control.Sensor.Index;
                _setFanSpeedMsg[4] = fanSpeed;

                _stream.Write(_setFanSpeedMsg);

                _pwmControls[control.Sensor.Index].Value = value;
                break;
            case ControlMode.Default:
                // There isn't a "default" mode, but let's say a safe setting is 40%
                _setFanSpeedMsg[2] = (byte)control.Sensor.Index;
                _setFanSpeedMsg[4] = 40;

                _stream.Write(_setFanSpeedMsg);

                _pwmControls[control.Sensor.Index].Value = 40;
                break;
        }
    }

    public override void Close()
    {
        _stream?.Close();
        base.Close();
    }

    private void ContinuousRead(object state)
    {
        byte[] buffer = new byte[_rawData[0].Length];
        while (_stream.CanRead)
        {
            try
            {
                _stream.Read(buffer); // This is a blocking call, will wait for bytes to become available
                if (buffer[0] == 0x04)
                {
                    lock (_rawData)
                    {
                        int fanId = (buffer[15] >> 4) & 0x0f;
                        Array.Copy(buffer, _rawData[fanId], buffer.Length);
                    }
                }
            }
            catch (TimeoutException)
            {
                // Don't care, just make sure the stream is still open
                Thread.Sleep(500);
            }
            catch (ObjectDisposedException)
            {
                // Could be unplugged, or the app is stopping...
                return;
            }
        }
    }

    public override void Update()
    {
        // The NZXT GRID+ V3 series sends updates periodically. We have to read it in a separate thread, this call just reads that data.
        lock (_rawData)
        {
            for (int fanId = 0; fanId < FANS_COUNT; fanId++)
            {
                _rpmSensors[fanId].Value = (_rawData[fanId][3] << 8) | _rawData[fanId][4];
                _voltages[fanId].Value = _rawData[fanId][7] + _rawData[fanId][8] / 100.0f;
                _currents[fanId].Value = _rawData[fanId][9] + _rawData[fanId][10] / 100.0f;
                _powers[fanId].Value = _currents[fanId].Value * _voltages[fanId].Value;
            }

            _noise.Value = _rawData[2][1];
        }
    }
}

```

`LibreHardwareMonitorLib/Hardware/Controller/Nzxt/KrakenV2.cs`:

```cs
using System;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Controller.Nzxt;

/// <summary>
/// Support for the Kraken X (X42, X52, X62 or X72) devices.
/// </summary>
internal sealed class KrakenV2 : Hardware
{
    private static readonly byte[] _getFirmwareInfo = [0x10, 0x01];

    private readonly HidDevice _device;
    private readonly Sensor _fan;
    private readonly byte _fanChannel;
    private readonly bool _fanControl;
    private readonly Sensor _fanRpm;
    private readonly TimeSpan _interval = TimeSpan.FromMilliseconds(5000);
    private readonly Sensor _liquidTemperature;
    private readonly Sensor _pump;
    private readonly byte _pumpChannel;
    private readonly Sensor _pumpRpm;
    private readonly byte[] _rawData = new byte[64];
    private readonly string _supportedFirmware;

    private DateTime _lastUpdate = DateTime.MinValue;

    public KrakenV2(HidDevice dev, ISettings settings) : base("Nzxt Kraken X", new Identifier(dev), settings)
    {
        _device = dev;

        switch (dev.ProductID)
        {
            case 0x170e:
            default:
                Name = "NZXT Kraken X";

                _fanControl = true;

                _fanChannel = 0x00;
                _pumpChannel = 0x40;

                _supportedFirmware = "6.2.0";
                break;
        }

        try
        {
            using HidStream stream = dev.Open();

            stream.Write(_getFirmwareInfo);

            int tries = 0;

            while (FirmwareVersion == null && tries++ < 10)
            {
                stream.Read(_rawData);

                if (_rawData[0] == 0x11 && _rawData[1] == 0x01)
                    FirmwareVersion = $"{_rawData[0x11]}.{_rawData[0x12]}.{_rawData[0x13]}";
            }

            if (FirmwareVersion == null)
                return;

            // Liquid temperature
            _liquidTemperature = new Sensor("Liquid", 0, SensorType.Temperature, this, [], settings);
            ActivateSensor(_liquidTemperature);

            // Pump Control
            _pump = new Sensor("Pump Control", 0, SensorType.Control, this, [], settings);
            Control pumpControl = new(_pump, settings, 60, 100);
            _pump.Control = pumpControl;
            pumpControl.ControlModeChanged += c => ControlValueChanged(_pump, c);
            pumpControl.SoftwareControlValueChanged += c => ControlValueChanged(_pump, c);
            ControlValueChanged(_pump, pumpControl);
            ActivateSensor(_pump);

            // Pump RPM
            _pumpRpm = new Sensor("Pump", 0, SensorType.Fan, this, [], settings);
            ActivateSensor(_pumpRpm);

            if (_fanControl)
            {
                // Fan Control
                _fan = new Sensor("Fans Control", 1, SensorType.Control, this, [], settings);
                Control fanControl = new(_fan, settings, 0, 100);
                _fan.Control = fanControl;
                fanControl.ControlModeChanged += c => ControlValueChanged(_fan, c);
                fanControl.SoftwareControlValueChanged += c => ControlValueChanged(_fan, c);
                ControlValueChanged(_fan, fanControl);
                ActivateSensor(_fan);

                // Fan RPM
                _fanRpm = new Sensor("Fans", 1, SensorType.Fan, this, [], settings);
                ActivateSensor(_fanRpm);
            }

            IsValid = true;
        }
        catch
        { }
    }

    public string FirmwareVersion { get; }

    public override HardwareType HardwareType => HardwareType.Cooler;

    public bool IsValid { get; }

    public string Status => FirmwareVersion != _supportedFirmware ? $"Status: Untested firmware version {FirmwareVersion}! Please consider updating to version {_supportedFirmware}" : "Status: OK";

    private void ControlValueChanged(Sensor sensor, IControl control)
    {
        try
        {
            if (control.ControlMode == ControlMode.Software)
            {
                //value will be updated at next Update()
                sensor.Value = control.SoftwareValue;
                _lastUpdate = DateTime.MinValue;
                Update();
            }
            else
            {
                //will let the device handle the value
                sensor.Value = null;
            }
        }
        catch (ObjectDisposedException)
        {
            // Could be unplugged, or the app is stopping...
        }
    }

    public override void Update()
    {
        try
        {
            using HidStream stream = _device.Open();

            stream.Read(_rawData);

            // if not 0x04, it is not temperature data
            if (_rawData[0] != 0x04)
                return;

            // some packet may have 0 as temperature, don't know why just ignore it
            if (_rawData[1] == 0x00)
                return;

            _liquidTemperature.Value = _rawData[1] + (_rawData[2] / 10.0f);
            _fanRpm.Value = (_rawData[3] << 8) | _rawData[4];
            _pumpRpm.Value = (_rawData[5] << 8) | _rawData[6];

            // if we don't have control over the fan or pump, we don't need to update
            if (!_pump.Value.HasValue && (!_fanControl || !_fan.Value.HasValue))
                return;

            //control value need to be updated every 5 seconds or it falls back to default
            if (DateTime.Now - _lastUpdate < _interval)
                return;

            if (_fanControl && _fan.Value.HasValue)
                SetDuty(stream, _fanChannel, (byte)_fan.Value);

            if (_fanControl && _pump.Value.HasValue)
                SetDuty(stream, _pumpChannel, (byte)_pump.Value);
        }
        catch (ObjectDisposedException)
        {
            // Could be unplugged, or the app is stopping...
        }
    }

    private void SetDuty(HidStream stream, byte channel, byte duty)
    {
        SetDuty(stream, channel, 0, duty);
    }

    private void SetDuty(HidStream stream, byte channel, byte temperature, byte duty)
    {
        stream.Write([0x2, 0x4d, channel, temperature, duty]);
        _lastUpdate = DateTime.Now;
    }
}

```

`LibreHardwareMonitorLib/Hardware/Controller/Nzxt/KrakenV3.cs`:

```cs
using System;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Controller.Nzxt;

/// <summary>
/// Support for the KrakenZ devices.
/// </summary>
internal sealed class KrakenV3 : Hardware
{
    private static readonly byte[] _getFirmwareInfo = [0x10, 0x01];
    private static readonly byte[] _setFanTarget = new byte[64];
    private static readonly byte[] _setPumpTarget = new byte[64];
    private static readonly byte[] _statusRequest = [0x74, 0x01];

    private readonly Sensor _fan;
    private readonly bool _fanControl;
    private readonly Sensor _fanRpm;
    private readonly Sensor _pump;
    private readonly Sensor _pumpRpm;
    private readonly byte[] _rawData = new byte[64];
    private readonly HidStream _stream;
    private readonly string _supportedFirmware;
    private readonly Sensor _temperature;
    private volatile bool _controllingFans;
    private volatile bool _controllingPump;

    public KrakenV3(HidDevice dev, ISettings settings) : base("Nzxt Kraken Z", new Identifier(dev), settings)
    {
        switch (dev.ProductID)
        {
            case 0x3008:
                Name = "NZXT Kraken Z3";
                _fanControl = true;
                _supportedFirmware = "5.7.0";
                Array.Copy(new byte[] { 0x72, 0x01, 0x00, 0x00 }, 0, _setPumpTarget, 0, 4);
                Array.Copy(new byte[] { 0x72, 0x02, 0x00, 0x00 }, 0, _setFanTarget, 0, 4);
                break;
            case 0x300C:
                Name = "NZXT Kraken Elite";
                _fanControl = true;
                _supportedFirmware = "1.2.4";
                Array.Copy(new byte[] { 0x72, 0x01, 0x01, 0x00 }, 0, _setPumpTarget, 0, 4);
                Array.Copy(new byte[] { 0x72, 0x02, 0x01, 0x01 }, 0, _setFanTarget, 0, 4);
                break;
            case 0x3012:
                Name = "NZXT Kraken Elite v2";
                _fanControl = true;
                _supportedFirmware = "1.2.1";
                Array.Copy(new byte[] { 0x72, 0x01, 0x01, 0x00 }, 0, _setPumpTarget, 0, 4);
                Array.Copy(new byte[] { 0x72, 0x02, 0x01, 0x01 }, 0, _setFanTarget, 0, 4);
                break;
            case 0x300E:
                Name = "NZXT Kraken";
                _fanControl = true;
                _supportedFirmware = "1.2.4"; // Firmware version to be confirmed
                Array.Copy(new byte[] { 0x72, 0x01, 0x01, 0x00 }, 0, _setPumpTarget, 0, 4);
                Array.Copy(new byte[] { 0x72, 0x02, 0x01, 0x01 }, 0, _setFanTarget, 0, 4);
                break;
            default:
                Name = "NZXT Kraken X3";
                _fanControl = false;
                _supportedFirmware = "2.1.0";
                Array.Copy(new byte[] { 0x72, 0x01, 0x00, 0x00 }, 0, _setPumpTarget, 0, 4);
                break;
        }

        FillTargetArray(_setPumpTarget, 60);
        FillTargetArray(_setFanTarget, 40);

        if (dev.TryOpen(out _stream))
        {
            _stream.ReadTimeout = 5000;

            _stream.Write(_getFirmwareInfo);

            int tries = 0;

            while (FirmwareVersion == null && tries++ < 10)
            {
                _stream.Read(_rawData);

                if (_rawData[0] == 0x11 && _rawData[1] == 0x01)
                    FirmwareVersion = $"{_rawData[0x11]}.{_rawData[0x12]}.{_rawData[0x13]}";
            }

            if (FirmwareVersion == null)
                return;

            // Liquid temperature
            _temperature = new Sensor("Liquid", 0, SensorType.Temperature, this, [], settings);
            ActivateSensor(_temperature);

            // Pump Control
            _pump = new Sensor("Pump Control", 0, SensorType.Control, this, [], settings);
            Control pumpControl = new(_pump, settings, 20, 100);
            _pump.Control = pumpControl;
            pumpControl.ControlModeChanged += PumpSoftwareControlValueChanged;
            pumpControl.SoftwareControlValueChanged += PumpSoftwareControlValueChanged;
            PumpSoftwareControlValueChanged(pumpControl);
            ActivateSensor(_pump);

            // Pump RPM
            _pumpRpm = new Sensor("Pump", 0, SensorType.Fan, this, [], settings);
            ActivateSensor(_pumpRpm);

            if (_fanControl)
            {
                // Fan Control
                _fan = new Sensor("Fans Control", 1, SensorType.Control, this, [], settings);
                Control fanControl = new(_fan, settings, 20, 100);
                _fan.Control = fanControl;
                fanControl.ControlModeChanged += FanSoftwareControlValueChanged;
                fanControl.SoftwareControlValueChanged += FanSoftwareControlValueChanged;
                FanSoftwareControlValueChanged(fanControl);
                ActivateSensor(_fan);

                // Fan RPM
                _fanRpm = new Sensor("Fans", 1, SensorType.Fan, this, [], settings);
                ActivateSensor(_fanRpm);
            }

            IsValid = true;
        }
    }

    public string FirmwareVersion { get; }

    public override HardwareType HardwareType => HardwareType.Cooler;

    public bool IsValid { get; }

    public string Status => FirmwareVersion != _supportedFirmware ? $"Status: Untested firmware version {FirmwareVersion}! Please consider updating to version {_supportedFirmware}" : "Status: OK";

    private static void FillTargetArray(byte[] targetArray, byte value)
    {
        for (byte i = 4; i < targetArray.Length; i++)
            targetArray[i] = value;
    }

    private void PumpSoftwareControlValueChanged(Control control)
    {
        try
        {
            switch (control.ControlMode)
            {
                case ControlMode.Software:
                    float value = control.SoftwareValue;

                    FillTargetArray(_setPumpTarget, (byte)(value > 100 ? 100 : value < 0 ? 0 : value));

                    _controllingPump = true;
                    _stream.Write(_setPumpTarget);
                    _pump.Value = value;
                    break;
                case ControlMode.Default:
                    // There isn't a "default" mode with this pump, but a safe setting is 60%
                    FillTargetArray(_setPumpTarget, 60);
                    _stream.Write(_setPumpTarget);
                    break;
            }
        }
        catch (ObjectDisposedException)
        {
            // Could be unplugged, or the app is stopping...
        }
    }

    private void FanSoftwareControlValueChanged(Control control)
    {
        try
        {
            switch (control.ControlMode)
            {
                case ControlMode.Software:
                    float value = control.SoftwareValue;
                    FillTargetArray(_setFanTarget, (byte)(value > 100 ? 100 : value < 0 ? 0 : value));

                    _controllingFans = true;
                    _stream.Write(_setFanTarget);
                    _fan.Value = value;
                    break;
                case ControlMode.Default:
                    // There isn't a "default" mode with this fan, but a safe setting is 40%
                    FillTargetArray(_setFanTarget, 40);
                    _stream.Write(_setFanTarget);
                    break;
            }
        }
        catch (ObjectDisposedException)
        {
            // Could be unplugged, or the app is stopping...
        }
    }

    public override void Close()
    {
        base.Close();
        _stream?.Close();
    }

    public override void Update()
    {
        try
        {
            _stream.Write(_statusRequest);

            do
            {
                _stream.Read(_rawData);
            }
            while (_rawData[0] != 0x75 || _rawData[1] != 0x1);

            _temperature.Value = _rawData[15] + (_rawData[16] / 10.0f);
            _pumpRpm.Value = (_rawData[18] << 8) | _rawData[17];

            // The following logic makes sure the pump is set to the controlling value. This pump sometimes sets itself to 0% when instructed to a value.
            if (!_controllingPump)
            {
                _pump.Value = _rawData[19];
            }
            else if (_pump.Value != _rawData[19])
            {
                float value = _pump.Value.GetValueOrDefault();
                FillTargetArray(_setPumpTarget, (byte)value);
                _stream.Write(_setPumpTarget);
            }
            else
            {
                _controllingPump = false;
            }

            if (_fanControl)
            {
                _fanRpm.Value = (_rawData[24] << 8) | _rawData[23];
                if (!_controllingFans)
                {
                    _fan.Value = _rawData[25];
                }
                else if (_fan.Value != _rawData[25])
                {
                    float value = _fan.Value.GetValueOrDefault();
                    FillTargetArray(_setFanTarget, (byte)value);
                    _stream.Write(_setFanTarget);
                }
                else
                {
                    _controllingFans = false;
                }
            }
        }
        catch (ObjectDisposedException)
        {
            // Could be unplugged, or the app is stopping...
        }
    }
}

```

`LibreHardwareMonitorLib/Hardware/Controller/Nzxt/NzxtGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System.Collections.Generic;
using System.Text;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Controller.Nzxt;

internal class NzxtGroup : IGroup
{
    private readonly List<IHardware> _hardware = new();
    private readonly StringBuilder _report = new();

    public NzxtGroup(ISettings settings)
    {
        _report.AppendLine("Nzxt Hardware");
        _report.AppendLine();

        foreach (HidDevice dev in DeviceList.Local.GetHidDevices(0x1e71))
        {
            string productName = dev.GetProductName();

            switch (dev.ProductID)
            {
                case 0x170E: // NZXT Kraken X (X42, X52, X62 or X72)
                    var krakenV2 = new KrakenV2(dev, settings);
                    _report.AppendLine($"Device name: {productName}");
                    _report.AppendLine($"Firmware version: {krakenV2.FirmwareVersion}");
                    _report.AppendLine($"{krakenV2.Status}");
                    _report.AppendLine();

                    if (krakenV2.IsValid)
                        _hardware.Add(krakenV2);

                    break;
                case 0x2007: // Kraken X3 original pid
                case 0x2014: // Kraken X3 new pid
                case 0x3008: // Kraken Z3
                case 0x300C: // Kraken 2023 elite
                case 0x300E: // Kraken 2023 standard
                case 0x3012: // Kraken elite v2
                    // NZXT KrakenV3 Devices
                    var krakenV3 = new KrakenV3(dev, settings);
                    _report.AppendLine($"Device name: {productName}");
                    _report.AppendLine($"Firmware version: {krakenV3.FirmwareVersion}");
                    _report.AppendLine($"{krakenV3.Status}");
                    _report.AppendLine();

                    if (krakenV3.IsValid)
                        _hardware.Add(krakenV3);

                    break;
                case 0x1711:
                    var gridv3 = new GridV3(dev, settings);
                    _report.AppendLine($"Device name: {productName}");
                    _report.AppendLine($"Firmware version: {gridv3.FirmwareVersion}");
                    _report.AppendLine();

                    if (gridv3.IsValid)
                        _hardware.Add(gridv3);

                    break;
                default:
                    _report.AppendLine($"Unknown Hardware PID: {dev.ProductID} Name: {productName}");
                    _report.AppendLine();
                    break;
            }
        }

        if (_hardware.Count == 0)
        {
            _report.AppendLine("No Nzxt Hardware found.");
            _report.AppendLine();
        }
    }

    public IReadOnlyList<IHardware> Hardware => _hardware;

    public void Close()
    {
        foreach (IHardware iHardware in _hardware)
        {
            if (iHardware is Hardware hardware)
                hardware.Close();
        }
    }

    public string GetReport()
    {
        return _report.ToString();
    }
}

```

`LibreHardwareMonitorLib/Hardware/Controller/Razer/RazerFanController.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Diagnostics;
using System.IO;
using System.Threading;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Controller.Razer;

internal sealed class RazerFanController : Hardware
{
    private const int DEFAULT_SPEED_CHANNEL_POWER = 50;
    private const byte PERCENT_MIN = 0;
    private const byte PERCENT_MAX = 100;
    private const int DEVICE_READ_DELAY_MS = 5;
    private const int DEVICE_READ_TIMEOUT_MS = 500;
    private const int CHANNEL_COUNT = 8;
    //private const int FORCE_WRITE_SPEEDS_INTERVAL_MS = 2500; // TODO: Add timer

    private HidStream _stream;
    private readonly HidDevice _device;
    private readonly SequenceCounter _sequenceCounter = new();

    private readonly float?[] _pwm = new float?[CHANNEL_COUNT];
    private readonly Sensor[] _pwmControls = new Sensor[CHANNEL_COUNT];
    private readonly Sensor[] _rpmSensors = new Sensor[CHANNEL_COUNT];

    public RazerFanController(HidDevice dev, ISettings settings) : base("Razer PWM PC Fan Controller", new Identifier(dev), settings)
    {
        _device = dev;

        if (_device.TryOpen(out _stream))
        {
            _stream.ReadTimeout = 5000;

            Packet packet = new Packet
            {
                SequenceNumber = _sequenceCounter.Next(),
                DataLength = 0,
                CommandClass = CommandClass.Info,
                Command = 0x87,
            };

            if (Mutexes.WaitRazer(250))
            {
                while (FirmwareVersion == null)
                {
                    Thread.Sleep(DEVICE_READ_DELAY_MS);

                    try
                    {
                        Packet response = TryWriteAndRead(packet);
                        FirmwareVersion = $"{response.Data[0]:D}.{response.Data[1]:D2}.{response.Data[2]:D2}";
                    }
                    catch { }
                }

                Mutexes.ReleaseRazer();
            }

            Name = "Razer PWM PC Fan Controller";

            for (int i = 0; i < CHANNEL_COUNT; i++)
            {
                // Fan Control
                _pwmControls[i] = new Sensor("Fan Control #" + (i + 1), i, SensorType.Control, this, Array.Empty<ParameterDescription>(), settings);
                Control fanControl = new(_pwmControls[i], settings, PERCENT_MIN, PERCENT_MAX);
                _pwmControls[i].Control = fanControl;
                fanControl.ControlModeChanged += FanSoftwareControlValueChanged;
                fanControl.SoftwareControlValueChanged += FanSoftwareControlValueChanged;
                //fanControl.SetDefault();
                FanSoftwareControlValueChanged(fanControl);
                ActivateSensor(_pwmControls[i]);

                // Fan RPM
                _rpmSensors[i] = new Sensor("Fan #" + (i + 1), i, SensorType.Fan, this, Array.Empty<ParameterDescription>(), settings);
                ActivateSensor(_rpmSensors[i]);
            }
        }
    }

    public string FirmwareVersion { get; }

    public override HardwareType HardwareType => HardwareType.Cooler;

    public string Status => FirmwareVersion != "1.01.00" ? $"Status: Untested Firmware Version {FirmwareVersion}! Please consider Updating to Version 1.01.00" : "Status: OK";

    private void FanSoftwareControlValueChanged(Control control) // TODO: Add timer here
    {
        if (control.ControlMode == ControlMode.Undefined || !Mutexes.WaitRazer(250))
            return;

        if (control.ControlMode == ControlMode.Software)
        {
            SetChannelModeToManual(control.Sensor.Index);

            float value = control.SoftwareValue;
            byte fanSpeed = (byte)(value > 100 ? 100 : value < 0 ? 0 : value);

            var packet = new Packet
            {
                SequenceNumber = _sequenceCounter.Next(),
                DataLength = 3,
                CommandClass = CommandClass.Pwm,
                Command = PwmCommand.SetChannelPercent,
            };

            packet.Data[0] = 0x01;
            packet.Data[1] = (byte)(0x05 + control.Sensor.Index);
            packet.Data[2] = fanSpeed;

            TryWriteAndRead(packet);

            _pwm[control.Sensor.Index] = value;
        }
        else if (control.ControlMode == ControlMode.Default)
        {
            SetChannelModeToManual(control.Sensor.Index); // TODO: switch to auto mode here if it enabled before

            var packet = new Packet
            {
                SequenceNumber = _sequenceCounter.Next(),
                DataLength = 3,
                CommandClass = CommandClass.Pwm,
                Command = PwmCommand.SetChannelPercent,
            };

            packet.Data[0] = 0x01;
            packet.Data[1] = (byte)(0x05 + control.Sensor.Index);
            packet.Data[2] = DEFAULT_SPEED_CHANNEL_POWER;

            TryWriteAndRead(packet);

            _pwm[control.Sensor.Index] = DEFAULT_SPEED_CHANNEL_POWER;
        }

        Mutexes.ReleaseRazer();
    }

    private int GetChannelSpeed(int channel)
    {
        Packet packet = new Packet
        {
            SequenceNumber = _sequenceCounter.Next(),
            DataLength = 6,
            CommandClass = CommandClass.Pwm,
            Command = PwmCommand.GetChannelSpeed,
        };

        packet.Data[0] = 0x01;
        packet.Data[1] = (byte)(0x05 + channel);

        Packet response = TryWriteAndRead(packet);
        return (response.Data[4] << 8) | response.Data[5];
    }

    private void SetChannelModeToManual(int channel)
    {
        Packet packet = new Packet
        {
            SequenceNumber = _sequenceCounter.Next(),
            DataLength = 3,
            CommandClass = CommandClass.Pwm,
            Command = PwmCommand.SetChannelMode,
        };

        packet.Data[0] = 0x01;
        packet.Data[1] = (byte)(0x05 + channel);
        packet.Data[2] = 0x04;

        TryWriteAndRead(packet);
    }

    private void ThrowIfNotReady()
    {
        bool @throw;
        try
        {
            @throw = _stream is null;
        }
        catch (ObjectDisposedException)
        {
            @throw = true;
        }

        if (@throw)
        {
            throw new InvalidOperationException("The device is not ready.");
        }
    }

    private Packet TryWriteAndRead(Packet packet)
    {
        Packet readPacket = null;
        int devTimeout = 400;
        int devReconnectTimeout = 3000;

        do
        {
            try
            {
                byte[] response = Packet.CreateBuffer();
                byte[] buffer = packet.ToBuffer();

                ThrowIfNotReady();
                _stream?.SetFeature(buffer, 0, buffer.Length);
                Thread.Sleep(DEVICE_READ_DELAY_MS);
                ThrowIfNotReady();
                _stream?.GetFeature(response, 0, response.Length);
                readPacket = Packet.FromBuffer(response);

                if (readPacket.Status == DeviceStatus.Busy)
                {
                    var stopwatch = new Stopwatch();
                    stopwatch.Start();

                    while (stopwatch.ElapsedMilliseconds < DEVICE_READ_TIMEOUT_MS && readPacket.Status == DeviceStatus.Busy)
                    {
                        Thread.Sleep(DEVICE_READ_DELAY_MS);
                        ThrowIfNotReady();
                        _stream?.GetFeature(response, 0, response.Length);
                        readPacket = Packet.FromBuffer(response);
                    }
                }
            }
            catch (IOException) // Unexpected device disconnect or fan plug/unplug
            {
                if (devTimeout <= 0)
                {
                    while (devReconnectTimeout > 0)
                    {
                        _stream?.Close();
                        if (_device.TryOpen(out _stream))
                            break;

                        Thread.Sleep(1000);
                        devReconnectTimeout -= 500;
                    }

                    if (devReconnectTimeout <= 0) // Device disconnected
                    {
                        for (int i = 0; i < CHANNEL_COUNT; i++)
                        {
                            _pwmControls[i].Control = null;
                            _pwmControls[i].Value = null;
                            _rpmSensors[i].Value = null;
                            _pwm[i] = null;

                            DeactivateSensor(_pwmControls[i]);
                            DeactivateSensor(_rpmSensors[i]);
                        }

                        Close();

                        Packet ret = new Packet();
                        for (int i = 0; i < 80; i++)
                            ret.Data[i] = 0;
                        return ret;
                    }

                    devTimeout = 400;
                }

                Thread.Sleep(DEVICE_READ_DELAY_MS);
                devTimeout -= DEVICE_READ_DELAY_MS;
            }
        } while (readPacket == null);

        return readPacket;
    }

    public override void Close()
    {
        base.Close();
        _stream?.Close();
    }

    public override void Update()
    {
        if (!Mutexes.WaitRazer(250))
            return;

        for (int i = 0; i < CHANNEL_COUNT; i++)
        {
            _rpmSensors[i].Value = GetChannelSpeed(i);
            _pwmControls[i].Value = _pwm[i];
        }

        Mutexes.ReleaseRazer();
    }

    private enum DeviceStatus : byte
    {
        Default = 0x00,
        Busy = 0x01,
        Success = 0x02,
        Error = 0x03,
        Timeout = 0x04,
        Invalid = 0x05,
    }

    private enum ProtocolType : byte
    {
        Default = 0x00,
    }

    private static class CommandClass
    {
        public static readonly byte Info = 0x00;
        public static readonly byte Pwm = 0x0d;
    }

    private static class PwmCommand
    {
        public static readonly byte SetChannelPercent = 0x0d;
        public static readonly byte SetChannelMode = 0x02;
        public static readonly byte GetChannelSpeed = 0x81;
    }

    private sealed class Packet
    {
        public byte ReportId { get; set; }
        public DeviceStatus Status { get; set; }
        public byte SequenceNumber { get; set; }
        public short RemainingCount { get; set; }
        public ProtocolType ProtocolType { get; set; }
        public byte DataLength { get; set; }
        public byte CommandClass { get; set; }
        public byte Command { get; set; }
        public byte[] Data { get; } = new byte[80];
        public byte CRC { get; set; }
        public byte Reserved { get; set; }

        public byte[] ToBuffer()
        {
            byte[] buffer = CreateBuffer();
            buffer[0] = ReportId;
            buffer[1] = (byte)Status;
            buffer[2] = SequenceNumber;
            buffer[3] = (byte)((RemainingCount >> 8) & 0xff);
            buffer[4] = (byte)(RemainingCount & 0xff);
            buffer[5] = (byte)ProtocolType;
            buffer[6] = DataLength;
            buffer[7] = CommandClass;
            buffer[8] = Command;

            for (int i = 0; i < Data.Length; i++)
                buffer[9 + i] = Data[i];

            buffer[89] = GenerateChecksum(buffer);
            buffer[90] = Reserved;
            return buffer;
        }

        public static Packet FromBuffer(byte[] buffer)
        {
            var packet = new Packet
            {
                ReportId = buffer[0],
                Status = (DeviceStatus)buffer[1],
                SequenceNumber = buffer[2],
                RemainingCount = (short)((buffer[3] << 8) | buffer[4]),
                ProtocolType = (ProtocolType)buffer[5],
                DataLength = buffer[6],
                CommandClass = buffer[7],
                Command = buffer[8],
                CRC = buffer[89],
                Reserved = buffer[90]
            };

            for (int i = 0; i < packet.Data.Length; i++)
                packet.Data[i] = buffer[9 + i];

            return packet;
        }

        public static byte[] CreateBuffer() => new byte[91];

        internal static byte GenerateChecksum(byte[] buffer)
        {
            byte result = 0;
            for (int i = 3; i < 89; i++)
            {
                result = (byte)(result ^ buffer[i]);
            }
            return result;
        }
    }

    private sealed class SequenceCounter
    {
        private byte _sequenceId = 0x00;

        public byte Next()
        {
            while (_sequenceId == 0x00)
            {
                _sequenceId += 0x08;
            }

            return _sequenceId;
        }
    }
}

```

`LibreHardwareMonitorLib/Hardware/Controller/Razer/RazerGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Controller.Razer;

internal class RazerGroup : IGroup
{
    private readonly List<IHardware> _hardware = new();
    private readonly StringBuilder _report = new();

    public RazerGroup(ISettings settings)
    {
        _report.AppendLine("Razer Hardware");
        _report.AppendLine();

        foreach (HidDevice dev in DeviceList.Local.GetHidDevices(0x1532))
        {
            try
            {
                string productName = dev.GetProductName();

                switch (dev.ProductID)
                {
                    case 0x0F3C: // Razer PWM PC fan controller
                        if (dev.GetMaxFeatureReportLength() <= 0)
                            break;

                        var device = new RazerFanController(dev, settings);
                        _report.AppendLine($"Device name: {productName}");
                        _report.AppendLine($"Firmware version: {device.FirmwareVersion}");
                        _report.AppendLine($"{device.Status}");
                        _report.AppendLine();
                        _hardware.Add(device);
                        break;

                    default:
                        _report.AppendLine($"Unknown Hardware PID: {dev.ProductID} Name: {productName}");
                        _report.AppendLine();
                        break;
                }
            }
            catch (Exception e)
            {
                _report.AppendLine($"Failed to get information for USB device with id {dev.ProductID}: {e.Message} ");
            }
        }

        if (_hardware.Count == 0)
        {
            _report.AppendLine("No Razer Hardware found.");
            _report.AppendLine();
        }
    }

    public IReadOnlyList<IHardware> Hardware => _hardware;

    public void Close()
    {
        foreach (IHardware iHardware in _hardware)
        {
            if (iHardware is Hardware hardware)
                hardware.Close();
        }
    }

    public string GetReport()
    {
        return _report.ToString();
    }
}

```

`LibreHardwareMonitorLib/Hardware/Controller/TBalancer/TBalancer.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using LibreHardwareMonitor.Interop;

// ReSharper disable InconsistentNaming

namespace LibreHardwareMonitor.Hardware.Controller.TBalancer;

internal class TBalancer : Hardware
{
    internal const byte EndFlag = 254;
    internal const byte StartFlag = 100;

    private readonly MethodDelegate _alternativeRequest;
    private readonly Sensor[] _analogTemperatures = new Sensor[4];
    private readonly Sensor[] _controls = new Sensor[4];
    private readonly List<ISensor> _deactivating = new();
    private readonly Sensor[] _digitalTemperatures = new Sensor[8];
    private readonly Sensor[] _fans = new Sensor[4];
    private readonly Sensor[] _miniNgControls = new Sensor[4];
    private readonly Sensor[] _miniNgFans = new Sensor[4];
    private readonly Sensor[] _miniNgTemperatures = new Sensor[4];
    private readonly int _portIndex;
    private readonly byte _protocolVersion;
    private readonly Sensor[] _sensorHubFlows = new Sensor[2];
    private readonly Sensor[] _sensorHubTemperatures = new Sensor[6];
    private byte[] _alternativeData = Array.Empty<byte>();
    private readonly byte[] _data = new byte[285];
    private Ftd2xx.FT_HANDLE _handle;
    private byte[] _primaryData = Array.Empty<byte>();

    public TBalancer(int portIndex, byte protocolVersion, ISettings settings) :
        base("T-Balancer bigNG", new Identifier("bigng", portIndex.ToString(CultureInfo.InvariantCulture)), settings)
    {
        _portIndex = portIndex;
        _protocolVersion = protocolVersion;

        ParameterDescription[] parameter = { new("Offset [°C]", "Temperature offset.", 0) };
        int offset = 0;
        for (int i = 0; i < _digitalTemperatures.Length; i++)
            _digitalTemperatures[i] = new Sensor("Digital Sensor " + i, offset + i, SensorType.Temperature, this, parameter, settings);

        offset += _digitalTemperatures.Length;

        for (int i = 0; i < _analogTemperatures.Length; i++)
            _analogTemperatures[i] = new Sensor("Analog Sensor " + (i + 1), offset + i, SensorType.Temperature, this, parameter, settings);

        offset += _analogTemperatures.Length;

        for (int i = 0; i < _sensorHubTemperatures.Length; i++)
            _sensorHubTemperatures[i] = new Sensor("Sensorhub Sensor " + i, offset + i, SensorType.Temperature, this, parameter, settings);

        offset += _sensorHubTemperatures.Length;

        for (int i = 0; i < _miniNgTemperatures.Length; i++)
            _miniNgTemperatures[i] = new Sensor("miniNG #" + ((i / 2) + 1) + " Sensor " + ((i % 2) + 1), offset + i, SensorType.Temperature, this, parameter, settings);

        for (int i = 0; i < _sensorHubFlows.Length; i++)
        {
            _sensorHubFlows[i] = new Sensor("Flowmeter " + (i + 1),
                                            i,
                                            SensorType.Flow,
                                            this,
                                            new[] { new ParameterDescription("Impulse Rate", "The impulse rate of the flowmeter in pulses/L", 509) },
                                            settings);
        }

        for (int i = 0; i < _controls.Length; i++)
        {
            _controls[i] = new Sensor("Fan Channel " + i, i, SensorType.Control, this, settings);
        }

        for (int i = 0; i < _miniNgControls.Length; i++)
        {
            _miniNgControls[i] = new Sensor("miniNG #" + ((i / 2) + 1) + " Fan Channel " + ((i % 2) + 1), 4 + i, SensorType.Control, this, settings);
        }

        _alternativeRequest = DelayedAlternativeRequest;

        Open();
        Update();
    }

    public override HardwareType HardwareType
    {
        get { return HardwareType.Cooler; }
    }

    protected override void ActivateSensor(ISensor sensor)
    {
        _deactivating.Remove(sensor);
        base.ActivateSensor(sensor);
    }

    protected override void DeactivateSensor(ISensor sensor)
    {
        if (_deactivating.Contains(sensor))
        {
            _deactivating.Remove(sensor);
            base.DeactivateSensor(sensor);
        }
        else if (_active.Contains(sensor))
        {
            _deactivating.Add(sensor);
        }
    }

    private void ReadMiniNg(int number)
    {
        int offset = 1 + (number * 65);

        if (_data[offset + 61] != EndFlag)
            return;

        for (int i = 0; i < 2; i++)
        {
            Sensor sensor = _miniNgTemperatures[(number * 2) + i];
            if (_data[offset + 7 + i] > 0)
            {
                sensor.Value = (0.5f * _data[offset + 7 + i]) +
                               sensor.Parameters[0].Value;

                ActivateSensor(sensor);
            }
            else
            {
                DeactivateSensor(sensor);
            }
        }

        for (int i = 0; i < 2; i++)
        {
            _miniNgFans[(number * 2) + i] ??= new Sensor("miniNG #" + (number + 1) + " Fan Channel " + (i + 1), 4 + (number * 2) + i, SensorType.Fan, this, _settings);

            Sensor sensor = _miniNgFans[(number * 2) + i];
            sensor.Value = 20.0f * _data[offset + 43 + (2 * i)];
            ActivateSensor(sensor);
        }

        for (int i = 0; i < 2; i++)
        {
            Sensor sensor = _miniNgControls[(number * 2) + i];
            sensor.Value = _data[offset + 15 + i];
            ActivateSensor(sensor);
        }
    }

    private void ReadData()
    {
        Ftd2xx.Read(_handle, _data);
        if (_data[0] != StartFlag)
        {
            Ftd2xx.FT_Purge(_handle, Ftd2xx.FT_PURGE.FT_PURGE_RX);
            return;
        }

        if (_data[1] is 255 or 88)
        {
            // bigNG

            if (_data[274] != _protocolVersion)
                return;

            if (_primaryData.Length == 0)
                _primaryData = new byte[_data.Length];

            _data.CopyTo(_primaryData, 0);

            for (int i = 0; i < _digitalTemperatures.Length; i++)
            {
                if (_data[238 + i] > 0)
                {
                    _digitalTemperatures[i].Value = (0.5f * _data[238 + i]) + _digitalTemperatures[i].Parameters[0].Value;
                    ActivateSensor(_digitalTemperatures[i]);
                }
                else
                {
                    DeactivateSensor(_digitalTemperatures[i]);
                }
            }

            for (int i = 0; i < _analogTemperatures.Length; i++)
            {
                if (_data[260 + i] > 0)
                {
                    _analogTemperatures[i].Value = (0.5f * _data[260 + i]) + _analogTemperatures[i].Parameters[0].Value;
                    ActivateSensor(_analogTemperatures[i]);
                }
                else
                {
                    DeactivateSensor(_analogTemperatures[i]);
                }
            }

            for (int i = 0; i < _sensorHubTemperatures.Length; i++)
            {
                if (_data[246 + i] > 0)
                {
                    _sensorHubTemperatures[i].Value = (0.5f * _data[246 + i]) + _sensorHubTemperatures[i].Parameters[0].Value;
                    ActivateSensor(_sensorHubTemperatures[i]);
                }
                else
                {
                    DeactivateSensor(_sensorHubTemperatures[i]);
                }
            }

            for (int i = 0; i < _sensorHubFlows.Length; i++)
            {
                if (_data[231 + i] > 0 && _data[234] > 0)
                {
                    float pulsesPerSecond = (_data[231 + i] * 4.0f) / _data[234];
                    float pulsesPerLiter = _sensorHubFlows[i].Parameters[0].Value;
                    _sensorHubFlows[i].Value = pulsesPerSecond * 3600 / pulsesPerLiter;
                    ActivateSensor(_sensorHubFlows[i]);
                }
                else
                {
                    DeactivateSensor(_sensorHubFlows[i]);
                }
            }

            for (int i = 0; i < _fans.Length; i++)
            {
                float maxRpm = 11.5f * ((_data[149 + (2 * i)] << 8) | _data[148 + (2 * i)]);

                _fans[i] ??= new Sensor("Fan Channel " + i,
                                        i,
                                        SensorType.Fan,
                                        this,
                                        new[]
                                        {
                                            new ParameterDescription("MaxRPM",
                                                                     "Maximum revolutions per minute (RPM) of the fan.",
                                                                     maxRpm)
                                        },
                                        _settings);

                float value;
                if ((_data[136] & (1 << i)) == 0) // pwm mode
                    value = 0.02f * _data[137 + i];
                else // analog mode
                    value = 0.01f * _data[141 + i];

                _fans[i].Value = _fans[i].Parameters[0].Value * value;
                ActivateSensor(_fans[i]);

                _controls[i].Value = 100 * value;
                ActivateSensor(_controls[i]);
            }
        }
        else if (_data[1] == 253)
        {
            // miniNG #1
            if (_alternativeData.Length == 0)
                _alternativeData = new byte[_data.Length];

            _data.CopyTo(_alternativeData, 0);

            ReadMiniNg(0);
            if (_data[66] == 253) // miniNG #2
                ReadMiniNg(1);
        }
    }

    public override string GetReport()
    {
        StringBuilder r = new();

        r.AppendLine("T-Balancer bigNG");
        r.AppendLine();
        r.Append("Port Index: ");
        r.AppendLine(_portIndex.ToString(CultureInfo.InvariantCulture));
        r.AppendLine();

        r.AppendLine("Primary System Information Answer");
        r.AppendLine();
        r.AppendLine("       00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F");
        r.AppendLine();
        for (int i = 0; i <= 0x11; i++)
        {
            r.Append(" ");
            r.Append((i << 4).ToString("X3", CultureInfo.InvariantCulture));
            r.Append("  ");
            for (int j = 0; j <= 0xF; j++)
            {
                int index = (i << 4) | j;
                if (index < _primaryData.Length)
                {
                    r.Append(" ");
                    r.Append(_primaryData[index].ToString("X2", CultureInfo.InvariantCulture));
                }
            }

            r.AppendLine();
        }

        r.AppendLine();

        if (_alternativeData.Length > 0)
        {
            r.AppendLine("Alternative System Information Answer");
            r.AppendLine();
            r.AppendLine("       00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F");
            r.AppendLine();
            for (int i = 0; i <= 0x11; i++)
            {
                r.Append(" ");
                r.Append((i << 4).ToString("X3", CultureInfo.InvariantCulture));
                r.Append("  ");
                for (int j = 0; j <= 0xF; j++)
                {
                    int index = (i << 4) | j;
                    if (index < _alternativeData.Length)
                    {
                        r.Append(" ");
                        r.Append(_alternativeData[index].ToString("X2", CultureInfo.InvariantCulture));
                    }
                }

                r.AppendLine();
            }

            r.AppendLine();
        }

        return r.ToString();
    }

    private void DelayedAlternativeRequest()
    {
        System.Threading.Thread.Sleep(500);
        Ftd2xx.Write(_handle, new byte[] { 0x37 });
    }

    public void Open()
    {
        Ftd2xx.FT_Open(_portIndex, out _handle);
        Ftd2xx.FT_SetBaudRate(_handle, 19200);
        Ftd2xx.FT_SetDataCharacteristics(_handle, 8, 1, 0);
        Ftd2xx.FT_SetFlowControl(_handle, Ftd2xx.FT_FLOW_CONTROL.FT_FLOW_RTS_CTS, 0x11, 0x13);
        Ftd2xx.FT_SetTimeouts(_handle, 1000, 1000);
        Ftd2xx.FT_Purge(_handle, Ftd2xx.FT_PURGE.FT_PURGE_ALL);
    }

    public sealed override void Update()
    {
        while (Ftd2xx.BytesToRead(_handle) >= 285)
            ReadData();

        if (Ftd2xx.BytesToRead(_handle) == 1)
            Ftd2xx.ReadByte(_handle);

        Ftd2xx.Write(_handle, new byte[] { 0x38 });
        _alternativeRequest.BeginInvoke(null, null);
    }

    public override void Close()
    {
        Ftd2xx.FT_Close(_handle);
        base.Close();
    }

    private delegate void MethodDelegate();
}

```

`LibreHardwareMonitorLib/Hardware/Controller/TBalancer/TBalancerGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using System.Threading;
using LibreHardwareMonitor.Interop;

// ReSharper disable InconsistentNaming

namespace LibreHardwareMonitor.Hardware.Controller.TBalancer;

internal class TBalancerGroup : IGroup
{
    private readonly List<TBalancer> _hardware = new();
    private readonly StringBuilder _report = new();

    public TBalancerGroup(ISettings settings)
    {
        uint numDevices;

        try
        {
            if (!Ftd2xx.DllExists())
            {
                _report.AppendLine("Status: missing DLL");
                return;
            }

            if (Ftd2xx.FT_CreateDeviceInfoList(out numDevices) != Ftd2xx.FT_STATUS.FT_OK)
            {
                _report.AppendLine("Status: FT_CreateDeviceInfoList failed");
                return;
            }
        }
        catch (Exception e) when (e is DllNotFoundException or ArgumentNullException or EntryPointNotFoundException or BadImageFormatException)
        {
            return;
        }

        Ftd2xx.FT_DEVICE_INFO_NODE[] info = new Ftd2xx.FT_DEVICE_INFO_NODE[numDevices];
        if (Ftd2xx.FT_GetDeviceInfoList(info, ref numDevices) != Ftd2xx.FT_STATUS.FT_OK)
        {
            _report.AppendLine("Status: FT_GetDeviceInfoList failed");
            return;
        }

        // make sure numDevices is not larger than the info array
        if (numDevices > info.Length)
            numDevices = (uint)info.Length;

        for (int i = 0; i < numDevices; i++)
        {
            _report.Append("Device Index: ");
            _report.AppendLine(i.ToString(CultureInfo.InvariantCulture));
            _report.Append("Device Type: ");
            _report.AppendLine(info[i].Type.ToString());

            // the T-Balancer always uses an FT232BM
            if (info[i].Type != Ftd2xx.FT_DEVICE.FT_DEVICE_232BM)
            {
                _report.AppendLine("Status: Wrong device type");
                continue;
            }

            Ftd2xx.FT_STATUS status = Ftd2xx.FT_Open(i, out Ftd2xx.FT_HANDLE handle);
            if (status != Ftd2xx.FT_STATUS.FT_OK)
            {
                _report.AppendLine("Open Status: " + status);
                continue;
            }

            Ftd2xx.FT_SetBaudRate(handle, 19200);
            Ftd2xx.FT_SetDataCharacteristics(handle, 8, 1, 0);
            Ftd2xx.FT_SetFlowControl(handle, Ftd2xx.FT_FLOW_CONTROL.FT_FLOW_RTS_CTS, 0x11, 0x13);
            Ftd2xx.FT_SetTimeouts(handle, 1000, 1000);
            Ftd2xx.FT_Purge(handle, Ftd2xx.FT_PURGE.FT_PURGE_ALL);

            status = Ftd2xx.Write(handle, new byte[] { 0x38 });
            if (status != Ftd2xx.FT_STATUS.FT_OK)
            {
                _report.AppendLine("Write Status: " + status);
                Ftd2xx.FT_Close(handle);
                continue;
            }

            bool isValid = false;
            byte protocolVersion = 0;

            int j = 0;
            while (Ftd2xx.BytesToRead(handle) == 0 && j < 2)
            {
                Thread.Sleep(100);
                j++;
            }

            if (Ftd2xx.BytesToRead(handle) > 0)
            {
                if (Ftd2xx.ReadByte(handle) == TBalancer.StartFlag)
                {
                    while (Ftd2xx.BytesToRead(handle) < 284 && j < 5)
                    {
                        Thread.Sleep(100);
                        j++;
                    }

                    int length = Ftd2xx.BytesToRead(handle);
                    if (length >= 284)
                    {
                        byte[] data = new byte[285];
                        data[0] = TBalancer.StartFlag;
                        for (int k = 1; k < data.Length; k++)
                            data[k] = Ftd2xx.ReadByte(handle);

                        // check protocol version 2X (protocols seen: 2C, 2A, 28)
                        isValid = (data[274] & 0xF0) == 0x20;
                        protocolVersion = data[274];
                        if (!isValid)
                        {
                            _report.Append("Status: Wrong Protocol Version: 0x");
                            _report.AppendLine(protocolVersion.ToString("X", CultureInfo.InvariantCulture));
                        }
                    }
                    else
                    {
                        _report.AppendLine("Status: Wrong Message Length: " + length);
                    }
                }
                else
                {
                    _report.AppendLine("Status: Wrong Startflag");
                }
            }
            else
            {
                _report.AppendLine("Status: No Response");
            }

            Ftd2xx.FT_Purge(handle, Ftd2xx.FT_PURGE.FT_PURGE_ALL);
            Ftd2xx.FT_Close(handle);

            if (isValid)
            {
                _report.AppendLine("Status: OK");
                _hardware.Add(new TBalancer(i, protocolVersion, settings));
            }

            if (i < numDevices - 1)
                _report.AppendLine();
        }
    }

    public IReadOnlyList<IHardware> Hardware => _hardware;

    public string GetReport()
    {
        if (_report.Length > 0)
        {
            StringBuilder r = new();
            r.AppendLine("FTD2XX");
            r.AppendLine();
            r.Append(_report);
            r.AppendLine();
            return r.ToString();
        }

        return null;
    }

    public void Close()
    {
        foreach (TBalancer balancer in _hardware)
            balancer.Close();
    }
}
```

`LibreHardwareMonitorLib/Hardware/CoreType.cs`:

```cs
namespace LibreHardwareMonitor.Hardware;

public enum CoreType
{
    Unknown = 0,
    Performance = 0x40,
    Efficient = 0x20
}

```

`LibreHardwareMonitorLib/Hardware/Cpu/Amd0FCpu.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Threading;
using LibreHardwareMonitor.PawnIo;

namespace LibreHardwareMonitor.Hardware.Cpu;

internal sealed class Amd0FCpu : AmdCpu
{
    private readonly Sensor _busClock;
    private readonly Sensor[] _coreClocks;
    private readonly Sensor[] _coreTemperatures;

    private readonly AmdFamily0F _pawnModule;

    /// <inheritdoc />
    public override void Close()
    {
        base.Close();
        _pawnModule.Close();
    }

    public Amd0FCpu(int processorIndex, CpuId[][] cpuId, ISettings settings) : base(processorIndex, cpuId, settings)
    {
        _pawnModule = new AmdFamily0F();

        float offset = -49.0f;

        // AM2+ 65nm +21 offset
        uint model = cpuId[0][0].Model;
        if (model is >= 0x69 and not 0xc1 and not 0x6c and not 0x7c)
            offset += 21;

        // check if processor supports a digital thermal sensor
        if (cpuId[0][0].ExtData.GetLength(0) > 7 && (cpuId[0][0].ExtData[7, 3] & 1) != 0)
        {
            _coreTemperatures = new Sensor[_coreCount];
            for (int i = 0; i < _coreCount; i++)
            {
                _coreTemperatures[i] = new Sensor("Core #" + (i + 1),
                                                  i,
                                                  SensorType.Temperature,
                                                  this,
                                                  [new ParameterDescription("Offset [°C]", "Temperature offset of the thermal sensor.\nTemperature = Value + Offset.", offset)],
                                                  settings);
            }
        }
        else
        {
            _coreTemperatures = [];
        }

        _busClock = new Sensor("Bus Speed", 0, SensorType.Clock, this, settings);
        _coreClocks = new Sensor[_coreCount];
        for (int i = 0; i < _coreClocks.Length; i++)
        {
            _coreClocks[i] = new Sensor(CoreString(i), i + 1, SensorType.Clock, this, settings);
            if (HasTimeStampCounter)
                ActivateSensor(_coreClocks[i]);
        }

        Update();
    }

    public override void Update()
    {
        base.Update();

        if (Mutexes.WaitPciBus(10))
        {
            for (uint i = 0; i < _coreTemperatures.Length; i++)
            {
                uint value;

                try
                {
                    value = _pawnModule.GetThermtrip(Index, i);
                }
                catch
                {
                    DeactivateSensor(_coreTemperatures[i]);
                    continue;
                }

                _coreTemperatures[i].Value = ((value >> 16) & 0xFF) + _coreTemperatures[i].Parameters[0].Value;
                ActivateSensor(_coreTemperatures[i]);
            }

            Mutexes.ReleasePciBus();
        }

        if (HasTimeStampCounter)
        {
            double newBusClock = 0;

            for (int i = 0; i < _coreClocks.Length; i++)
            {
                Thread.Sleep(1);

                if (_pawnModule.ReadMsr(FIDVID_STATUS, out uint eax, out uint _, _cpuId[i][0].Affinity))
                {
                    // CurrFID can be found in eax bits 0-5, MaxFID in 16-21
                    // 8-13 hold StartFID, we don't use that here.
                    double curMp = 0.5 * ((eax & 0x3F) + 8);
                    double maxMp = 0.5 * ((eax >> 16 & 0x3F) + 8);
                    _coreClocks[i].Value = (float)(curMp * TimeStampCounterFrequency / maxMp);
                    newBusClock = (float)(TimeStampCounterFrequency / maxMp);
                }
                else
                {
                    // Fail-safe value - if the code above fails, we'll use this instead
                    _coreClocks[i].Value = (float)TimeStampCounterFrequency;
                }
            }

            if (newBusClock > 0)
            {
                _busClock.Value = (float)newBusClock;
                ActivateSensor(_busClock);
            }
        }
    }

    // ReSharper disable InconsistentNaming
    private const uint FIDVID_STATUS = 0xC0010042;
    // ReSharper restore InconsistentNaming
}

```

`LibreHardwareMonitorLib/Hardware/Cpu/Amd10Cpu.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Text;
using System.Threading;
using LibreHardwareMonitor.PawnIo;

namespace LibreHardwareMonitor.Hardware.Cpu;

internal sealed class Amd10Cpu : AmdCpu
{
    private readonly Sensor _busClock;
    private readonly Sensor[] _coreClocks;
    private readonly Sensor _coreTemperature;
    private readonly Sensor _coreVoltage;
    private readonly Sensor[] _cStatesResidency;
    private readonly bool _hasSmuTemperatureRegister;
    private readonly bool _isSvi2;
    private readonly Sensor _northbridgeVoltage;
    private readonly FileStream _temperatureStream;
    private readonly double _timeStampCounterMultiplier;

    private readonly AmdFamily10 _pawnModule;

    public Amd10Cpu(int processorIndex, CpuId[][] cpuId, ISettings settings) : base(processorIndex, cpuId, settings)
    {
        _pawnModule = new AmdFamily10();

        // AMD family 1Xh processors support only one temperature sensor
        _coreTemperature = new Sensor("CPU Cores", 0, SensorType.Temperature, this, new[] { new ParameterDescription("Offset [°C]", "Temperature offset.", 0) }, settings);
        _coreVoltage = new Sensor("CPU Cores", 0, SensorType.Voltage, this, settings);
        ActivateSensor(_coreVoltage);
        _northbridgeVoltage = new Sensor("Northbridge", 0, SensorType.Voltage, this, settings);
        ActivateSensor(_northbridgeVoltage);

        _isSvi2 = (_family == 0x15 && _model >= 0x10) || _family == 0x16;

        if (_family == 0x15)
        {
                switch (_model & 0xF0)
                {
                    case 0x60:
                    case 0x70:
                        _hasSmuTemperatureRegister = true;
                        break;
                }
        }

        // get the pci address for the Miscellaneous Control registers
        _busClock = new Sensor("Bus Speed", 0, SensorType.Clock, this, settings);
        _coreClocks = new Sensor[_coreCount];
        for (int i = 0; i < _coreClocks.Length; i++)
        {
            _coreClocks[i] = new Sensor(CoreString(i), i + 1, SensorType.Clock, this, settings);
            if (HasTimeStampCounter)
                ActivateSensor(_coreClocks[i]);
        }

        // set affinity to the first thread for all frequency estimations
        GroupAffinity previousAffinity = ThreadAffinity.Set(cpuId[0][0].Affinity);

        _timeStampCounterMultiplier = MeasureTimeStampCounterMultiplier();

        // restore the thread affinity.
        ThreadAffinity.Set(previousAffinity);

        // the file reader for lm-sensors support on Linux
        _temperatureStream = null;

        if (Software.OperatingSystem.IsUnix)
        {
            foreach (string path in Directory.GetDirectories("/sys/class/hwmon/"))
            {
                string name = null;
                try
                {
                    using StreamReader reader = new(path + "/device/name");

                    name = reader.ReadLine();
                }
                catch (IOException)
                { }

                _temperatureStream = name switch
                {
                    "k10temp" => new FileStream(path + "/device/temp1_input", FileMode.Open, FileAccess.Read, FileShare.ReadWrite),
                    _ => _temperatureStream
                };
            }
        }

        if (_pawnModule.HaveCstateResidencyInfo())
        {
            _cStatesResidency = new[] { new Sensor("CPU Package C2", 0, SensorType.Level, this, settings), new Sensor("CPU Package C3", 1, SensorType.Level, this, settings) };
            ActivateSensor(_cStatesResidency[0]);
            ActivateSensor(_cStatesResidency[1]);
        }

        Update();
    }

    private double MeasureTimeStampCounterMultiplier()
    {
        _pawnModule.MeasureTscMultiplier(out var ctrPerTick, out var cofVid);

        double coreMultiplier = GetCoreMultiplier((uint)cofVid);

        double coreFrequency = 1e-6 * ((double)ctrPerTick * Stopwatch.Frequency);
        double busFrequency = coreFrequency / coreMultiplier;
        return 0.25 * Math.Round(4 * TimeStampCounterFrequency / busFrequency);
    }

    public override string GetReport()
    {
        StringBuilder r = new();
        r.Append(base.GetReport());
        r.Append("Time Stamp Counter Multiplier: ");
        r.AppendLine(_timeStampCounterMultiplier.ToString(CultureInfo.InvariantCulture));
        if (_family == 0x14)
        {
            uint value = _pawnModule.ReadMiscCtl(Index, CLOCK_POWER_TIMING_CONTROL_0_REGISTER);
            r.Append("PCI Register D18F3xD4: ");
            r.AppendLine(value.ToString("X8", CultureInfo.InvariantCulture));
        }

        r.AppendLine();
        return r.ToString();
    }

    private double GetCoreMultiplier(uint cofVidEax)
    {
        uint cpuDid;
        uint cpuFid;

        switch (_family)
        {
            case 0x10:
            case 0x11:
            case 0x15:
            case 0x16:
                // 8:6 CpuDid: current core divisor ID
                // 5:0 CpuFid: current core frequency ID
                cpuDid = (cofVidEax >> 6) & 7;
                cpuFid = cofVidEax & 0x1F;
                return 0.5 * (cpuFid + 0x10) / (1 << (int)cpuDid);

            case 0x12:
                // 8:4 CpuFid: current CPU core frequency ID
                // 3:0 CpuDid: current CPU core divisor ID
                cpuFid = (cofVidEax >> 4) & 0x1F;
                cpuDid = cofVidEax & 0xF;
                double divisor = cpuDid switch
                {
                    0 => 1,
                    1 => 1.5,
                    2 => 2,
                    3 => 3,
                    4 => 4,
                    5 => 6,
                    6 => 8,
                    7 => 12,
                    8 => 16,
                    _ => 1
                };
                return (cpuFid + 0x10) / divisor;

            case 0x14:
                // 8:4: current CPU core divisor ID most significant digit
                // 3:0: current CPU core divisor ID least significant digit
                uint divisorIdMsd = (cofVidEax >> 4) & 0x1F;
                uint divisorIdLsd = cofVidEax & 0xF;
                uint value = _pawnModule.ReadMiscCtl(Index, CLOCK_POWER_TIMING_CONTROL_0_REGISTER);
                uint frequencyId = value & 0x1F;
                return (frequencyId + 0x10) / (divisorIdMsd + (divisorIdLsd * 0.25) + 1);

            default:
                return 1;
        }
    }

    private static string ReadFirstLine(Stream stream)
    {
        StringBuilder stringBuilder = new();

        try
        {
            stream.Seek(0, SeekOrigin.Begin);
            int b = stream.ReadByte();
            while (b is not -1 and not 10)
            {
                stringBuilder.Append((char)b);
                b = stream.ReadByte();
            }
        }
        catch
        { }

        return stringBuilder.ToString();
    }

    public override void Update()
    {
        base.Update();

        if (_temperatureStream == null)
        {
            bool isValueValid = true;
            uint value = 0;
            try
            {
                if (_hasSmuTemperatureRegister)
                    ReadSmuRegister(SMU_REPORTED_TEMP_CTRL_OFFSET, out value);
                else
                    value = _pawnModule.ReadMiscCtl(Index, REPORTED_TEMPERATURE_CONTROL_REGISTER);
            }
            catch
            {
                isValueValid = false;
            }

            if (isValueValid)
            {
                if ((_family == 0x15 || _family == 0x16) && (value & 0x30000) == 0x3000)
                {
                    if (_family == 0x15 && (_model & 0xF0) == 0x00)
                    {
                        _coreTemperature.Value = (((value >> 21) & 0x7FC) / 8.0f) + _coreTemperature.Parameters[0].Value - 49;
                    }
                    else
                    {
                        _coreTemperature.Value = (((value >> 21) & 0x7FF) / 8.0f) + _coreTemperature.Parameters[0].Value - 49;
                    }
                }
                else
                {
                    _coreTemperature.Value = (((value >> 21) & 0x7FF) / 8.0f) + _coreTemperature.Parameters[0].Value;
                }

                ActivateSensor(_coreTemperature);
            }
            else
            {
                DeactivateSensor(_coreTemperature);
            }
        }
        else
        {
            string s = ReadFirstLine(_temperatureStream);
            try
            {
                _coreTemperature.Value = 0.001f * long.Parse(s, CultureInfo.InvariantCulture);
                ActivateSensor(_coreTemperature);
            }
            catch
            {
                DeactivateSensor(_coreTemperature);
            }
        }

        if (HasTimeStampCounter)
        {
            double newBusClock = 0;
            float maxCoreVoltage = 0, maxNbVoltage = 0;

            for (int i = 0; i < _coreClocks.Length; i++)
            {
                Thread.Sleep(1);

                if (_pawnModule.ReadMsr(COFVID_STATUS, out uint curEax, out uint _, _cpuId[i][0].Affinity))
                {
                    double multiplier = GetCoreMultiplier(curEax);

                    _coreClocks[i].Value = (float)(multiplier * TimeStampCounterFrequency / _timeStampCounterMultiplier);
                    newBusClock = (float)(TimeStampCounterFrequency / _timeStampCounterMultiplier);
                }
                else
                {
                    _coreClocks[i].Value = (float)TimeStampCounterFrequency;
                }

                float SVI2Volt(uint vid) => vid < 0b1111_1000 ? 1.5500f - (0.00625f * vid) : 0;

                float SVI1Volt(uint vid) => vid < 0x7C ? 1.550f - (0.0125f * vid) : 0;

                float newCoreVoltage, newNbVoltage;
                uint coreVid60 = (curEax >> 9) & 0x7F;
                if (_isSvi2)
                {
                    newCoreVoltage = SVI2Volt((curEax >> 13 & 0x80) | coreVid60);
                    newNbVoltage = SVI2Volt(curEax >> 24);
                }
                else
                {
                    newCoreVoltage = SVI1Volt(coreVid60);
                    newNbVoltage = SVI1Volt(curEax >> 25);
                }

                if (newCoreVoltage > maxCoreVoltage)
                    maxCoreVoltage = newCoreVoltage;

                if (newNbVoltage > maxNbVoltage)
                    maxNbVoltage = newNbVoltage;
            }

            _coreVoltage.Value = maxCoreVoltage;
            _northbridgeVoltage.Value = maxNbVoltage;

            if (newBusClock > 0)
            {
                _busClock.Value = (float)newBusClock;
                ActivateSensor(_busClock);
            }
        }

        if (_cStatesResidency != null)
        {
            var results = _pawnModule.ReadCstateResidency();
            for (int i = 0; i < _cStatesResidency.Length; i++)
            {
                _cStatesResidency[i].Value = results[i] / 256f * 100;
            }
        }
    }

    private bool ReadSmuRegister(uint address, out uint value)
    {
        value = 0;
        if (!Mutexes.WaitPciBus(10))
            return false;

        try
        {
            value = _pawnModule.ReadSmu(address);
            return true;
        }
        catch
        {
            return false;
        }
        finally
        {
            Mutexes.ReleasePciBus();
        }
    }

    public override void Close()
    {
        base.Close();
        _temperatureStream?.Close();
        _pawnModule.Close();
    }

    // ReSharper disable InconsistentNaming
    private const uint CLOCK_POWER_TIMING_CONTROL_0_REGISTER = 0xD4;
    private const uint REPORTED_TEMPERATURE_CONTROL_REGISTER = 0xA4;
    private const uint COFVID_STATUS = 0xC0010071;
    private const uint SMU_REPORTED_TEMP_CTRL_OFFSET = 0xD8200CA4;
    // ReSharper restore InconsistentNaming
}

```

`LibreHardwareMonitorLib/Hardware/Cpu/Amd17Cpu.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using LibreHardwareMonitor.PawnIo;

namespace LibreHardwareMonitor.Hardware.Cpu;

internal sealed class Amd17Cpu : AmdCpu
{
    private readonly Processor _processor;
    private readonly Dictionary<SensorType, int> _sensorTypeIndex;
    private readonly RyzenSMU _smu;
    private readonly AmdFamily17 _pawnModule;

    public Amd17Cpu(int processorIndex, CpuId[][] cpuId, ISettings settings) : base(processorIndex, cpuId, settings)
    {
        _pawnModule = new AmdFamily17();

        _sensorTypeIndex = new Dictionary<SensorType, int>();
        foreach (SensorType type in Enum.GetValues(typeof(SensorType)))
        {
            _sensorTypeIndex.Add(type, 0);
        }

        _sensorTypeIndex[SensorType.Load] = _active.Count(x => x.SensorType == SensorType.Load);

        _smu = new RyzenSMU();

        // Add all numa nodes.
        // Register ..1E_2, [10:8] + 1
        _processor = new Processor(this);

        // Add all numa nodes.
        int coreId = 0;
        int lastCoreId = -1; // Invalid id.

        // Ryzen 3000's skip some core ids.
        // So start at 1 and count upwards when the read core changes.
        foreach (CpuId[] cpu in cpuId.OrderBy(x => x[0].ExtData[0x1e, 1] & 0xFF))
        {
            CpuId thread = cpu[0];

            // CPUID_Fn8000001E_EBX, Register ..1E_1, [7:0]
            // threads per core =  CPUID_Fn8000001E_EBX[15:8] + 1
            // CoreId: core ID =  CPUID_Fn8000001E_EBX[7:0]
            int coreIdRead = (int)(thread.ExtData[0x1e, 1] & 0xff);

            // CPUID_Fn8000001E_ECX, Node Identifiers, Register ..1E_2
            // NodesPerProcessor =  CPUID_Fn8000001E_ECX[10:8]
            // nodeID =  CPUID_Fn8000001E_ECX[7:0]
            int nodeId = (int)(thread.ExtData[0x1e, 2] & 0xff);

            if (coreIdRead != lastCoreId)
            {
                coreId++;
            }

            lastCoreId = coreIdRead;

            _processor.AppendThread(thread, nodeId, coreId);
        }

        Update();
    }

    public override string GetReport()
    {
        StringBuilder r = new();
        r.Append(base.GetReport());
        r.Append(_smu.GetReport());
        return r.ToString();
    }

    /// <inheritdoc />
    public override void Close()
    {
        base.Close();
        _pawnModule.Close();
        _smu.Close();
    }

    public override void Update()
    {
        base.Update();

        _processor.UpdateSensors();

        foreach (NumaNode node in _processor.Nodes)
        {
            NumaNode.UpdateSensors();

            foreach (Core c in node.Cores)
            {
                c.UpdateSensors();
            }
        }

        _processor.UpdateVirtualSensor();
    }

    private class Processor
    {
        private readonly Sensor _busClock;
        private readonly Sensor _avgClock;
        private readonly Sensor _avgClockEffcetive;

        private readonly Sensor[] _ccdTemperatures;
        private readonly Sensor _coreTemperatureTctl;
        private readonly Sensor _coreTemperatureTctlTdie;
        private readonly Sensor _coreTemperatureTdie;
        private readonly Sensor _coreVoltage;
        private readonly Amd17Cpu _cpu;
        private readonly Sensor _packagePower;
        private readonly Dictionary<KeyValuePair<uint, RyzenSMU.SmuSensorType>, Sensor> _smuSensors = new();
        private readonly Sensor _socVoltage;

        private Sensor _ccdsAverageTemperature;
        private Sensor _ccdsMaxTemperature;
        private DateTime _lastSampleTime = new(0);
        private uint _lastPwrValue;

        public Processor(Hardware hardware)
        {
            _cpu = (Amd17Cpu)hardware;

            _packagePower = new Sensor("Package", _cpu._sensorTypeIndex[SensorType.Power]++, SensorType.Power, _cpu, _cpu._settings);
            _coreTemperatureTctl = new Sensor("Core (Tctl)", _cpu._sensorTypeIndex[SensorType.Temperature]++, SensorType.Temperature, _cpu, _cpu._settings);
            _coreTemperatureTdie = new Sensor("Core (Tdie)", _cpu._sensorTypeIndex[SensorType.Temperature]++, SensorType.Temperature, _cpu, _cpu._settings);
            _coreTemperatureTctlTdie = new Sensor("Core (Tctl/Tdie)", _cpu._sensorTypeIndex[SensorType.Temperature]++, SensorType.Temperature, _cpu, _cpu._settings);
            _ccdTemperatures = new Sensor[8]; // Hardcoded until there's a way to get max CCDs.
            _coreVoltage = new Sensor("Core (SVI2 TFN)", _cpu._sensorTypeIndex[SensorType.Voltage]++, SensorType.Voltage, _cpu, _cpu._settings);
            _socVoltage = new Sensor("SoC (SVI2 TFN)", _cpu._sensorTypeIndex[SensorType.Voltage]++, SensorType.Voltage, _cpu, _cpu._settings);
            _busClock = new Sensor("Bus Speed", _cpu._sensorTypeIndex[SensorType.Clock]++, SensorType.Clock, _cpu, _cpu._settings);
            _avgClock = new Sensor("Cores (Average)", _cpu._sensorTypeIndex[SensorType.Clock]++, SensorType.Clock, _cpu, _cpu._settings);
            _avgClockEffcetive = new Sensor("Cores (Average Effective)", _cpu._sensorTypeIndex[SensorType.Clock]++, SensorType.Clock, _cpu, _cpu._settings);

            _cpu.ActivateSensor(_packagePower);
            _cpu.ActivateSensor(_avgClock);
            _cpu.ActivateSensor(_avgClockEffcetive);

            foreach (KeyValuePair<uint, RyzenSMU.SmuSensorType> sensor in _cpu._smu.GetPmTableStructure())
            {
                _smuSensors.Add(sensor, new Sensor(sensor.Value.Name, _cpu._sensorTypeIndex[sensor.Value.Type]++, sensor.Value.Type, _cpu, _cpu._settings));
            }
        }

        public List<NumaNode> Nodes { get; } = new();

        public void UpdateSensors()
        {
            NumaNode node = Nodes[0];
            Core core = node?.Cores[0];
            CpuId cpuId = core?.Threads.FirstOrDefault()?.Cpu;

            if (cpuId == null)
                return;

            GroupAffinity previousAffinity = ThreadAffinity.Set(cpuId.Affinity);

            // MSRC001_0299
            // TU [19:16]
            // ESU [12:8] -> Unit 15.3 micro Joule per increment (default), 1/2^ESU micro Joule
            // PU [3:0]
            _cpu._pawnModule.ReadMsr(MSR_PWR_UNIT, out uint eax, out uint _);
            int esu = (int)((eax >> 8) & 0x1F);
            double energyBaseUnit = Math.Pow(0.5,esu);


            // MSRC001_029B
            // total_energy [31:0]
            DateTime sampleTime = DateTime.UtcNow;
            _cpu._pawnModule.ReadMsr(MSR_PKG_ENERGY_STAT, out eax, out _);

            uint totalEnergy = eax;

            uint smuSvi0Tfn = 0;
            uint smuSvi0TelPlane0 = 0;
            uint smuSvi0TelPlane1 = 0;

            if (Mutexes.WaitPciBus(10))
            {
                // THM_TCON_CUR_TMP
                // CUR_TEMP [31:21]
                uint temperature = _cpu._pawnModule.ReadSmn(F17H_M01H_THM_TCON_CUR_TMP);

                // SVI0_TFN_PLANE0 [0]
                // SVI0_TFN_PLANE1 [1]
                smuSvi0Tfn = _cpu._pawnModule.ReadSmn(F17H_M01H_SVI + 0x8);

                bool supportsPerCcdTemperatures = false;

                // TODO: find a better way because these will probably keep changing in the future.

                uint sviPlane0Offset;
                uint sviPlane1Offset;
                switch (cpuId.Model)
                {
                    case 0x31: // Threadripper 3000.
                        sviPlane0Offset = F17H_M01H_SVI + 0x14;
                        sviPlane1Offset = F17H_M01H_SVI + 0x10;
                        supportsPerCcdTemperatures = true;
                        break;

                    case 0x71: // Zen 2.
                    case 0x21: // Zen 3.
                        sviPlane0Offset = F17H_M01H_SVI + 0x10;
                        sviPlane1Offset = F17H_M01H_SVI + 0xC;
                        supportsPerCcdTemperatures = true;
                        break;

                    case 0x61: //Zen 4
                    case 0x44: //Zen 5
                        sviPlane0Offset = F17H_M01H_SVI + 0x10;
                        sviPlane1Offset = F17H_M01H_SVI + 0xC;
                        supportsPerCcdTemperatures = true;
                        break;

                    default: // Zen and Zen+.
                        sviPlane0Offset = F17H_M01H_SVI + 0xC;
                        sviPlane1Offset = F17H_M01H_SVI + 0x10;
                        break;
                }

                // SVI0_PLANE0_VDDCOR [24:16]
                // SVI0_PLANE0_IDDCOR [7:0]
                smuSvi0TelPlane0 = _cpu._pawnModule.ReadSmn(sviPlane0Offset);

                // SVI0_PLANE1_VDDCOR [24:16]
                // SVI0_PLANE1_IDDCOR [7:0]
                smuSvi0TelPlane1 = _cpu._pawnModule.ReadSmn(sviPlane1Offset);

                ThreadAffinity.Set(previousAffinity);

                TimeSpan deltaTime = sampleTime - _lastSampleTime;
                if (_lastSampleTime.Ticks == 0)
                {
                    deltaTime = new(0);
                    _lastSampleTime = sampleTime;
                    _lastPwrValue = totalEnergy;
                }

                _lastSampleTime = sampleTime;

                // ticks diff
                // power consumption
                // power.Value = (float) ((double)pu * 0.125);
                // energyBaseUnit = micro Joule per increment, from [ESU]

                long pwr;
                if (_lastPwrValue <= totalEnergy)
                    pwr = totalEnergy - _lastPwrValue;
                else
                    pwr = (0xffffffff - _lastPwrValue) + totalEnergy;

                // update for next sample
                _lastPwrValue = totalEnergy;

                if (deltaTime.Ticks > 0)
                {
                    double energy = energyBaseUnit * pwr;
                    energy /= deltaTime.TotalSeconds;

                    if (!double.IsNaN(energy))
                        _packagePower.Value = (float)energy;
                }

                // current temp Bit [31:21]
                // If bit 19 of the Temperature Control register is set, there is an additional offset of 49 degrees C.
                bool tempOffsetFlag = (temperature & F17H_TEMP_OFFSET_FLAG) != 0;
                temperature = (temperature >> 21) * 125;

                float offset = 0.0f;

                // Offset table: https://github.com/torvalds/linux/blob/master/drivers/hwmon/k10temp.c#L78
                if (string.IsNullOrWhiteSpace(cpuId.Name))
                    offset = 0;
                else if (cpuId.Name.Contains("1600X") || cpuId.Name.Contains("1700X") || cpuId.Name.Contains("1800X"))
                    offset = -20.0f;
                else if (cpuId.Name.Contains("Threadripper 19") || cpuId.Name.Contains("Threadripper 29"))
                    offset = -27.0f;
                else if (cpuId.Name.Contains("2700X"))
                    offset = -10.0f;

                float t = temperature * 0.001f;
                if (tempOffsetFlag)
                    t += -49.0f;

                if (offset < 0)
                {
                    _coreTemperatureTctl.Value = t;
                    _coreTemperatureTdie.Value = t + offset;

                    _cpu.ActivateSensor(_coreTemperatureTctl);
                    _cpu.ActivateSensor(_coreTemperatureTdie);
                }
                else
                {
                    // Zen 2 doesn't have an offset so Tdie and Tctl are the same.
                    _coreTemperatureTctlTdie.Value = t;
                    _cpu.ActivateSensor(_coreTemperatureTctlTdie);
                }

                // Tested only on R5 3600 & Threadripper 3960X, 5900X, 7900X
                if (supportsPerCcdTemperatures)
                {
                    for (uint i = 0; i < _ccdTemperatures.Length; i++)
                    {
                        uint ccd1Offset = 0;
                        if (cpuId.Model is 0x61 or 0x44) // Raphael or GraniteRidge
                            ccd1Offset = F17H_M61H_CCD1_TEMP + i * 0x4;
                        else
                            ccd1Offset = F17H_M70H_CCD1_TEMP + i * 0x4;
                        uint ccdRawTemp = _cpu._pawnModule.ReadSmn(ccd1Offset);

                        ccdRawTemp &= 0xFFF;
                        float ccdTemp = ((ccdRawTemp * 125) - 305000) * 0.001f;
                        if (ccdRawTemp > 0 && ccdTemp < 125) // Zen 2 reports 95 degrees C max, but it might exceed that.
                        {
                            if (_ccdTemperatures[i] == null)
                            {
                                _cpu.ActivateSensor(_ccdTemperatures[i] = new Sensor($"CCD{i + 1} (Tdie)",
                                                                                     _cpu._sensorTypeIndex[SensorType.Temperature]++,
                                                                                     SensorType.Temperature,
                                                                                     _cpu,
                                                                                     _cpu._settings));
                            }

                            _ccdTemperatures[i].Value = ccdTemp;
                        }
                    }

                    Sensor[] activeCcds = _ccdTemperatures.Where(x => x != null).ToArray();
                    if (activeCcds.Length > 1)
                    {
                        // No need to get the max / average ccds temp if there is only one CCD.

                        if (_ccdsMaxTemperature == null)
                        {
                            _cpu.ActivateSensor(_ccdsMaxTemperature = new Sensor("CCDs Max (Tdie)",
                                                                                 _cpu._sensorTypeIndex[SensorType.Temperature]++,
                                                                                 SensorType.Temperature,
                                                                                 _cpu,
                                                                                 _cpu._settings));
                        }

                        if (_ccdsAverageTemperature == null)
                        {
                            _cpu.ActivateSensor(_ccdsAverageTemperature = new Sensor("CCDs Average (Tdie)",
                                                                                     _cpu._sensorTypeIndex[SensorType.Temperature]++,
                                                                                     SensorType.Temperature,
                                                                                     _cpu,
                                                                                     _cpu._settings));
                        }

                        _ccdsMaxTemperature.Value = activeCcds.Max(x => x.Value);
                        _ccdsAverageTemperature.Value = activeCcds.Average(x => x.Value);
                    }
                }

                Mutexes.ReleasePciBus();
            }

            // voltage
            const double vidStep = 0.00625;
            double vcc;
            uint svi0PlaneXVddCor;

            if (cpuId.Model is 0x61 or 0x44) // Readout not working for Ryzen 7000/9000.
                smuSvi0Tfn |= 0x01 | 0x02;

            // Core (0x01).
            if ((smuSvi0Tfn & 0x01) == 0)
            {
                svi0PlaneXVddCor = (smuSvi0TelPlane0 >> 16) & 0xff;
                vcc = 1.550 - (vidStep * svi0PlaneXVddCor);
                _coreVoltage.Value = (float)vcc;

                _cpu.ActivateSensor(_coreVoltage);
            }

            // SoC (0x02), not every Zen cpu has this voltage.
            if (cpuId.Model is 0x11 or 0x21 or 0x71 or 0x31 || (smuSvi0Tfn & 0x02) == 0)
            {
                svi0PlaneXVddCor = (smuSvi0TelPlane1 >> 16) & 0xff;
                vcc = 1.550 - (vidStep * svi0PlaneXVddCor);
                _socVoltage.Value = (float)vcc;

                _cpu.ActivateSensor(_socVoltage);
            }

            double timeStampCounterMultiplier = GetTimeStampCounterMultiplier();
            if (timeStampCounterMultiplier > 0)
            {
                _busClock.Value = (float)(_cpu.TimeStampCounterFrequency / timeStampCounterMultiplier);
                _cpu.ActivateSensor(_busClock);
            }

            if (_cpu._smu.IsPmTableLayoutDefined())
            {
                float[] smuData = _cpu._smu.GetPmTable();

                foreach (KeyValuePair<KeyValuePair<uint, RyzenSMU.SmuSensorType>, Sensor> sensor in _smuSensors)
                {
                    if (smuData.Length > sensor.Key.Key)
                    {
                        sensor.Value.Value = smuData[sensor.Key.Key] * sensor.Key.Value.Scale;
                        if (sensor.Value.Value != 0)
                            _cpu.ActivateSensor(sensor.Value);
                    }
                }
            }
        }

        public void UpdateVirtualSensor()
        {
            if (Nodes == null || Nodes.Count == 0)
                return;

            double clock = Nodes.Average(x => x.CoreClock);
            _avgClock.Value = (float)Math.Round(clock, 0);

            clock = Nodes.Average(x => x.EffectiveClock);
            _avgClockEffcetive.Value = (float)Math.Round(clock, 0);
        }

        private double GetTimeStampCounterMultiplier()
        {
            _cpu._pawnModule.ReadMsr(MSR_PSTATE_0, out uint eax, out _);

            if (_cpu._family == 0x1a)
            {
                //zen 5
                uint cpuFid = eax & 0xfff;
                return (cpuFid * 5) / 100.0;
            }
            else
            {
                uint cpuDfsId = (eax >> 8) & 0x3f;
                uint cpuFid = eax & 0xff;
                return 2.0 * cpuFid / cpuDfsId;
            }
        }

        public void AppendThread(CpuId thread, int numaId, int coreId)
        {
            NumaNode node = null;
            foreach (NumaNode n in Nodes)
            {
                if (n.NodeId == numaId)
                {
                    node = n;
                    break;
                }
            }

            if (node == null)
            {
                node = new NumaNode(_cpu, numaId);
                Nodes.Add(node);
            }

            if (thread != null)
                node.AppendThread(thread, coreId);
        }
    }

    private class NumaNode
    {
        private readonly Amd17Cpu _cpu;

        public NumaNode(Amd17Cpu cpu, int id)
        {
            Cores = new List<Core>();
            NodeId = id;
            _cpu = cpu;
        }

        public List<Core> Cores { get; }

        public int NodeId { get; }

        public double CoreClock
        {
            get
            {
                if(Cores == null)
                    return 0;

                return Cores.Average(x => x.CoreClock);
            }
        }

        public double EffectiveClock
        {
            get
            {
                if (Cores == null)
                    return 0;

                return Cores.Average(x => x.EffectiveClock);
            }
        }


        public void AppendThread(CpuId thread, int coreId)
        {
            Core core = null;
            foreach (Core c in Cores)
            {
                if (c.CoreId == coreId)
                    core = c;
            }

            if (core == null)
            {
                core = new Core(_cpu, coreId);
                Cores.Add(core);
            }

            if (thread != null)
                core.AppedThread(thread);
        }

        public static void UpdateSensors()
        { }
    }

    private class CpuThread
    {
        private DateTime _sampleTime = new(0);
        private DateTime _lastSampleTime = new(0);
        private ulong _mperf = 0;
        private ulong _aperf = 0;
        private ulong _mperfLast = 0;
        private ulong _aperfLast = 0;
        private ulong _mperfDelta = 0;
        private ulong _aperfDelta = 0;

        private CpuId _cpuId;
        private Amd17Cpu _cpu;
        public CpuId Cpu { get { return _cpuId; } }

        public TimeSpan SampleDuration { get; private set; }= TimeSpan.Zero;
        public double EffectiveClock { get; private set; } = 0;

        public ulong MperfDelta { get {  return _mperfDelta; } }
        public ulong AperfDelta { get { return _aperfDelta; } }

        public CpuThread(Amd17Cpu cpu, CpuId cpuId)
        {
            _cpu = cpu;
            _cpuId = cpuId;
        }

        public void ReadPerformanceCounter()
        {
            ThreadAffinity.Set(Cpu.Affinity);

            _sampleTime = DateTime.UtcNow;

            // performance counter
            // MSRC000_00E7, P0 state counter
            _cpu._pawnModule.ReadMsr(MSR_MPERF_RO, out ulong edxeax);
            _mperf = edxeax;
            // MSRC000_00E8, C0 state counter
            _cpu._pawnModule.ReadMsr(MSR_APERF_RO, out edxeax);
            _aperf = edxeax;
        }

        public void UpdateMeasurements()
        {
            if (_mperf < _mperfLast || _aperf < _aperfLast)
            {
                // current measurment is invalid when _mperf or _aperf overflow
                _lastSampleTime = new(0);
            }

            if (_lastSampleTime.Ticks == 0)
            {
                _lastSampleTime = _sampleTime;
                _mperfLast = _mperf;
                _aperfLast = _aperf;

                _mperfDelta = 0;
                _aperfDelta = 0;
                return;
            }

            SampleDuration = _sampleTime - _lastSampleTime;
            _lastSampleTime = _sampleTime;

            _mperfDelta = _mperf - _mperfLast;
            _aperfDelta = _aperf - _aperfLast;
            _mperfLast = _mperf;
            _aperfLast = _aperf;

            if (_mperfDelta > 20000e6)
                _mperfDelta = 0;
            if (_aperfDelta > 20000e6)
                _aperfDelta = 0;

            if(_aperfDelta == 0 || _mperfDelta == 0)
            {
                //overflow possible, numbers are > 20 GHz
                _lastSampleTime = new(0);
                return;
            }

            //effective clock
            double freq = (double)_aperfDelta / (SampleDuration.TotalMilliseconds * 1000.0);
            EffectiveClock = Math.Round(freq);
        }

        public bool HasValidCounters()
        {
            return _mperfDelta > 0 && _aperfDelta > 0 && SampleDuration.Ticks > 0;
        }
    }

    private class Core
    {
        private readonly Sensor _clock;
        private readonly Sensor _clockEffective;
        private readonly Amd17Cpu _cpu;
        private readonly Sensor _multiplier;
        private readonly Sensor _power;
        private readonly Sensor _vcore;
        private ISensor _busSpeed;
        private DateTime _lastSampleTime = new(0);
        private uint _lastPwrValue = 0;

        public double CoreClock { get; set; } = 0;
        public double EffectiveClock { get; set; } = 0;

        public Core(Amd17Cpu cpu, int id)
        {
            _cpu = cpu;
            CoreId = id;
            _clock = new Sensor("Core #" + CoreId, _cpu._sensorTypeIndex[SensorType.Clock]++, SensorType.Clock, cpu, cpu._settings);
            _clockEffective = new Sensor("Core #" + CoreId + " (Effective)", _cpu._sensorTypeIndex[SensorType.Clock]++, SensorType.Clock, cpu, cpu._settings);
            _multiplier = new Sensor("Core #" + CoreId, cpu._sensorTypeIndex[SensorType.Factor]++, SensorType.Factor, cpu, cpu._settings);
            _power = new Sensor("Core #" + CoreId + " (SMU)", cpu._sensorTypeIndex[SensorType.Power]++, SensorType.Power, cpu, cpu._settings);
            _vcore = new Sensor("Core #" + CoreId + " VID", cpu._sensorTypeIndex[SensorType.Voltage]++, SensorType.Voltage, cpu, cpu._settings);

            cpu.ActivateSensor(_clock);
            cpu.ActivateSensor(_clockEffective);
            cpu.ActivateSensor(_multiplier);
            cpu.ActivateSensor(_power);
            cpu.ActivateSensor(_vcore);
        }

        public int CoreId { get; }

        public List<CpuThread> Threads { get; } = new List<CpuThread>();

        public void AppedThread(CpuId cpuId)
        {
            CpuThread t = new CpuThread(_cpu, cpuId);
            Threads.Add(t);
        }

        public void UpdateSensors()
        {
            if (Threads.Count == 0)
                return;

            CpuThread thread = Threads[0];
            GroupAffinity previousAffinity = ThreadAffinity.Set(thread.Cpu.Affinity);

            // MSRC001_0299
            // TU [19:16]
            // ESU [12:8] -> Unit 15.3 micro Joule per increment (default), 1/2^ESU micro Joule
            // PU [3:0]
            _cpu._pawnModule.ReadMsr(MSR_PWR_UNIT, out uint eax, out uint _);
            int esu = (int)((eax >> 8) & 0x1F);
            double energyBaseUnit = Math.Pow(0.5, esu);

            // MSRC001_029A
            // total_energy [31:0]
            DateTime sampleTime = DateTime.UtcNow;
            _cpu._pawnModule.ReadMsr(MSR_CORE_ENERGY_STAT, out eax, out _);
            uint totalEnergy = eax;

            // MSRC001_0293
            // CurHwPstate [24:22]
            // CurCpuVid [21:14]
            // CurCpuDfsId [13:8]
            // CurCpuFid [7:0] zen1..4
            // CurCpuFid [11:0] zen5
            _cpu._pawnModule.ReadMsr(MSR_HARDWARE_PSTATE_STATUS, out eax, out _);
            uint msrPstate = eax;
            int curCpuVid = (int)((eax >> 14) & 0xff);

            foreach(var t in Threads)
            {
                t.ReadPerformanceCounter();
            }

            // MSRC001_0063[P - state Status](PStateStat)
            // Ring0.ReadMsr(MSR_PSTATE_STATUS, out eax, out _);
            // int curPstateStaus = (int)(eax & 0x7);

            // MSRC001_0064 + x
            // PstateEn[63], 1 == enabled
            // IddDiv [31:30]
            // IddValue [29:22]
            // CpuVid [21:14]
            // CpuDfsId [13:8]
            // CpuFid [7:0] zen1..4
            // CpuFid [11:0] zen5
            // Ring0.ReadMsr(MSR_PSTATE_0 + curPstateStaus, out eax, out uint edx);
            // uint curPstate = eax;
            // int PstateEn = (int)(edx >> 31);

            ThreadAffinity.Set(previousAffinity);

            // Update clock counter and cffective clock calculation
            Threads.ForEach(t => t.UpdateMeasurements());
            EffectiveClock = Threads.Average(x => x.EffectiveClock);
            _clockEffective.Value = (float)EffectiveClock;

            if (thread.HasValidCounters())
            {
                double coreClock = 0;
                double busClock = 100.0; //bus speed in MHz
                _busSpeed ??= _cpu.Sensors.FirstOrDefault(x => x.Name == "Bus Speed");
                if (_busSpeed?.Value.HasValue == true && _busSpeed.Value > 0)
                    busClock = (double)_busSpeed.Value;

                if (thread.Cpu.Family == 0x1A)
                {
                    // zen5 (0x1A)
                    // 57896-B0-PUB_3.00.pdf, CoreCOF
                    // CoreCOF is Core current operating frequency in MHz.CoreCOF = Core::X86::Msr::PStateDef[CpuFid[11:0]] * 5MHz
                    // CpuFid[11:0]: core frequency ID.Read - write.Reset: XXXh.Specifies the core frequency multiplier.The core
                    // COF is a function of CpuFid and CpuDid, and defined by CoreCOF.
                    int curCpuFid = (int)(msrPstate & 0xfff);
                    coreClock = curCpuFid * 5;

                    // multiplier, clock speed with 100Mhz as Multiplier Reference
                    _multiplier.Value = (float)((curCpuFid * 5) / busClock);
                }
                else
                {
                    // clock zen 0x17 and 0x19
                    // 55570-B1-3.16_PUB_NRV.pdf, CoreCOF
                    // CoreCOF is (Core::X86::Msr::PStateDef[CpuFid[7:0]] / Core::X86::Msr::PStateDef[CpuDfsId]) * 200
                    // CpuFid[7:0]: core frequency ID.Read - write.Reset: XXh.Specifies the core frequency multiplier.The core
                    // COF is a function of CpuFid and CpuDid, and defined by CoreCOF.
                    int curCpuDfsId = (int)((msrPstate >> 8) & 0x3f);
                    int curCpuFid = (int)(msrPstate & 0xff);

                    coreClock = (curCpuFid / (double)curCpuDfsId * (busClock * 2));

                    // multiplier
                    _multiplier.Value = (float)(curCpuFid / (double)curCpuDfsId * 2.0);
                }

                //clock values valid when AperfDelta < MperfDelta (ratio is < 1.0)
                if (thread.AperfDelta < thread.MperfDelta)
                    coreClock = ((double)thread.AperfDelta / (double)thread.MperfDelta) * coreClock;

                CoreClock = Math.Round(coreClock);
                _clock.Value = (float)CoreClock;
            }

            // Vcore voltage
            const double vidStep = 0.00625;
            double vcc = 1.550 - (vidStep * curCpuVid);
            _vcore.Value = (float)vcc;

            // core power consumption
            //current delta time
            TimeSpan deltaTime = sampleTime - _lastSampleTime;
            if (_lastSampleTime.Ticks == 0)
            {
                deltaTime = new(0);
                _lastSampleTime = sampleTime;
                _lastPwrValue = totalEnergy;
            }
            _lastSampleTime = sampleTime;

            if (deltaTime.Ticks > 0)
            {
                // power.Value = (float) ((double)pu * 0.125);
                // energyBaseUnit = micro Joule per increment, from [ESU]
                // ticks diff
                long pwr;
                if (_lastPwrValue <= totalEnergy)
                    pwr = totalEnergy - _lastPwrValue;
                else
                    pwr = (0xffffffff - _lastPwrValue) + totalEnergy;

                // update for next sample
                _lastPwrValue = totalEnergy;

                double energy = energyBaseUnit * pwr;
                energy /= deltaTime.TotalSeconds;

                if (!double.IsNaN(energy))
                    _power.Value = (float)energy;
            }
        }
    }

    // ReSharper disable InconsistentNaming
    private const uint COFVID_STATUS = 0xC0010071;
    private const uint F17H_M01H_SVI = 0x0005A000;
    private const uint F17H_M01H_THM_TCON_CUR_TMP = 0x00059800;
    private const uint F17H_M70H_CCD1_TEMP = 0x00059954;
    private const uint F17H_M61H_CCD1_TEMP = 0x00059b08;
    private const uint F17H_TEMP_OFFSET_FLAG = 0x80000;
    private const uint FAMILY_17H_PCI_CONTROL_REGISTER = 0x60;
    private const uint HWCR = 0xC0010015;
    private const uint MSR_CORE_ENERGY_STAT = 0xC001029A;
    private const uint MSR_HARDWARE_PSTATE_STATUS = 0xC0010293;
    private const uint MSR_PKG_ENERGY_STAT = 0xC001029B;
    private const uint MSR_PSTATE_STATUS = 0xC0010063;
    private const uint MSR_PSTATE_0 = 0xC0010064;
    private const uint MSR_PWR_UNIT = 0xC0010299;
    private const uint MSR_MPERF_RO = 0xC000_00E7;
    private const uint MSR_APERF_RO = 0xC000_00E8;
    private const uint PERF_CTL_0 = 0xC0010000;
    private const uint PERF_CTR_0 = 0xC0010004;
    // ReSharper restore InconsistentNaming
}

```

`LibreHardwareMonitorLib/Hardware/Cpu/AmdCpu.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware.Cpu;

internal abstract class AmdCpu(int processorIndex, CpuId[][] cpuId, ISettings settings)
    : GenericCpu(processorIndex, cpuId, settings);

```

`LibreHardwareMonitorLib/Hardware/Cpu/CpuGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;

namespace LibreHardwareMonitor.Hardware.Cpu;

internal class CpuGroup : IGroup
{
    private readonly List<GenericCpu> _hardware = new();
    private readonly CpuId[][][] _threads;

    public CpuGroup(ISettings settings)
    {
        CpuId[][] processorThreads = GetProcessorThreads();
        _threads = new CpuId[processorThreads.Length][][];

        int index = 0;
        foreach (CpuId[] threads in processorThreads)
        {
            if (threads.Length == 0)
                continue;

            CpuId[][] coreThreads = GroupThreadsByCore(threads);
            _threads[index] = coreThreads;

            switch (threads[0].Vendor)
            {
                case Vendor.Intel:
                    _hardware.Add(new IntelCpu(index, coreThreads, settings));
                    break;
                case Vendor.AMD:
                    switch (threads[0].Family)
                    {
                        case 0x0F:
                            _hardware.Add(new Amd0FCpu(index, coreThreads, settings));
                            break;
                        case 0x10:
                        case 0x11:
                        case 0x12:
                        case 0x14:
                        case 0x15:
                        case 0x16:
                            // TODO: https://github.com/namazso/PawnIO.Modules/issues/32
                            //_hardware.Add(new Amd10Cpu(index, coreThreads, settings));
                            break;
                        case 0x17:
                        case 0x19:
                        case 0x1A:
                            _hardware.Add(new Amd17Cpu(index, coreThreads, settings));
                            break;
                        default:
                            _hardware.Add(new GenericCpu(index, coreThreads, settings));
                            break;
                    }

                    break;
                default:
                    _hardware.Add(new GenericCpu(index, coreThreads, settings));
                    break;
            }

            index++;
        }
    }

    public IReadOnlyList<IHardware> Hardware => _hardware;

    public string GetReport()
    {
        if (_threads == null)
            return null;

        StringBuilder r = new();
        r.AppendLine("CPUID");
        r.AppendLine();
        for (int i = 0; i < _threads.Length; i++)
        {
            r.AppendLine("Processor " + i);
            r.AppendLine();
            r.AppendFormat("Processor Vendor: {0}{1}", _threads[i][0][0].Vendor, Environment.NewLine);
            r.AppendFormat("Processor Brand: {0}{1}", _threads[i][0][0].BrandString, Environment.NewLine);
            r.AppendFormat("Family: 0x{0}{1}", _threads[i][0][0].Family.ToString("X", CultureInfo.InvariantCulture), Environment.NewLine);
            r.AppendFormat("Model: 0x{0}{1}", _threads[i][0][0].Model.ToString("X", CultureInfo.InvariantCulture), Environment.NewLine);
            r.AppendFormat("Stepping: 0x{0}{1}", _threads[i][0][0].Stepping.ToString("X", CultureInfo.InvariantCulture), Environment.NewLine);
            r.AppendLine();

            r.AppendLine("CPUID Return Values");
            r.AppendLine();
            for (int j = 0; j < _threads[i].Length; j++)
            {
                for (int k = 0; k < _threads[i][j].Length; k++)
                {
                    r.AppendLine(" CPU Group: " + _threads[i][j][k].Group);
                    r.AppendLine(" CPU Thread: " + _threads[i][j][k].Thread);
                    r.AppendLine(" APIC ID: " + _threads[i][j][k].ApicId);
                    r.AppendLine(" Processor ID: " + _threads[i][j][k].ProcessorId);
                    r.AppendLine(" Core ID: " + _threads[i][j][k].CoreId);
                    r.AppendLine(" Thread ID: " + _threads[i][j][k].ThreadId);
                    r.AppendLine();
                    r.AppendLine(" Function  EAX       EBX       ECX       EDX");
                    AppendCpuidData(r, _threads[i][j][k].Data, CpuId.CPUID_0);
                    AppendCpuidData(r, _threads[i][j][k].ExtData, CpuId.CPUID_EXT);
                    r.AppendLine();
                }
            }
        }

        return r.ToString();
    }

    public void Close()
    {
        foreach (GenericCpu cpu in _hardware)
        {
            cpu.Close();
        }
    }

    private static CpuId[][] GetProcessorThreads()
    {
        List<CpuId> threads = new();

        for (int i = 0; i < ThreadAffinity.ProcessorGroupCount; i++)
        {
            for (int j = 0; j < 192; j++)
            {
                try
                {
                    var cpuid = CpuId.Get(i, j);
                    if (cpuid != null)
                        threads.Add(cpuid);
                }
                catch (ArgumentOutOfRangeException)
                {
                    // Continue...
                }
            }
        }

        SortedDictionary<uint, List<CpuId>> processors = new();
        foreach (CpuId thread in threads)
        {
            processors.TryGetValue(thread.ProcessorId, out List<CpuId> list);
            if (list == null)
            {
                list = new List<CpuId>();
                processors.Add(thread.ProcessorId, list);
            }

            list.Add(thread);
        }

        CpuId[][] processorThreads = new CpuId[processors.Count][];
        int index = 0;
        foreach (List<CpuId> list in processors.Values)
        {
            processorThreads[index] = list.ToArray();
            index++;
        }

        return processorThreads;
    }

    private static CpuId[][] GroupThreadsByCore(IEnumerable<CpuId> threads)
    {
        SortedDictionary<uint, List<CpuId>> cores = new();
        foreach (CpuId thread in threads)
        {
            cores.TryGetValue(thread.CoreId, out List<CpuId> coreList);
            if (coreList == null)
            {
                coreList = new List<CpuId>();
                cores.Add(thread.CoreId, coreList);
            }

            coreList.Add(thread);
        }

        CpuId[][] coreThreads = new CpuId[cores.Count][];
        int index = 0;
        foreach (List<CpuId> list in cores.Values)
        {
            coreThreads[index] = list.ToArray();
            index++;
        }

        return coreThreads;
    }

    private static void AppendCpuidData(StringBuilder r, uint[,] data, uint offset)
    {
        for (int i = 0; i < data.GetLength(0); i++)
        {
            r.Append(" ");
            r.Append((i + offset).ToString("X8", CultureInfo.InvariantCulture));
            for (int j = 0; j < 4; j++)
            {
                r.Append("  ");
                r.Append(data[i, j].ToString("X8", CultureInfo.InvariantCulture));
            }

            r.AppendLine();
        }
    }
}

```

`LibreHardwareMonitorLib/Hardware/Cpu/CpuId.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Text;

namespace LibreHardwareMonitor.Hardware.Cpu;

public enum Vendor
{
    Unknown,
    Intel,
    AMD
}

public class CpuId
{
    /// <summary>
    /// Initializes a new instance of the <see cref="CpuId" /> class.
    /// </summary>
    /// <param name="group">The group.</param>
    /// <param name="thread">The thread.</param>
    /// <param name="affinity">The affinity.</param>
    private CpuId(int group, int thread, GroupAffinity affinity)
    {
        Thread = thread;
        Group = group;
        Affinity = affinity;

        uint threadMaskWith;
        uint coreMaskWith;
        uint maxCpuidExt;

        if (thread >= 64)
            throw new ArgumentOutOfRangeException(nameof(thread));

        uint maxCpuid;
        if (OpCode.CpuId(CPUID_0, 0, out uint eax, out uint ebx, out uint ecx, out uint edx))
        {
            if (eax > 0)
                maxCpuid = eax;
            else
                return;

            StringBuilder vendorBuilder = new();
            AppendRegister(vendorBuilder, ebx);
            AppendRegister(vendorBuilder, edx);
            AppendRegister(vendorBuilder, ecx);

            Vendor = vendorBuilder.ToString() switch
            {
                "GenuineIntel" => Vendor.Intel,
                "AuthenticAMD" => Vendor.AMD,
                _ => Vendor.Unknown
            };

            if (OpCode.CpuId(CPUID_EXT, 0, out eax, out _, out _, out _))
            {
                if (eax > CPUID_EXT)
                    maxCpuidExt = eax - CPUID_EXT;
                else
                    return;
            }
            else
            {
                throw new ArgumentOutOfRangeException(nameof(thread));
            }
        }
        else
        {
            throw new ArgumentOutOfRangeException(nameof(thread));
        }

        maxCpuid = Math.Min(maxCpuid, 1024);
        maxCpuidExt = Math.Min(maxCpuidExt, 1024);

        Data = new uint[maxCpuid + 1, 4];
        for (uint i = 0; i < maxCpuid + 1; i++)
        {
            OpCode.CpuId(CPUID_0 + i, 0, out Data[i, 0], out Data[i, 1], out Data[i, 2], out Data[i, 3]);
        }

        if (Vendor == Vendor.Intel && maxCpuid >= 0x1A)
        {
            // Leaf 0x1A, SubLeaf 0, EAX Bits 31:24 = Core Type ID
            uint coreType = (Data[0x1A, 0] >> 24) & 0xFF;

            CoreType = coreType switch
            {
                // 0x40 = Core (P-Core), 0x20 = Atom (E-Core)
                0x40 => CoreType.Performance,
                0x20 => CoreType.Efficient,
                _ => CoreType.Unknown
            };
        }
        else
        {
            CoreType = CoreType.Unknown;
        }

        ExtData = new uint[maxCpuidExt + 1, 4];
        for (uint i = 0; i < maxCpuidExt + 1; i++)
        {
            OpCode.CpuId(CPUID_EXT + i, 0, out ExtData[i, 0], out ExtData[i, 1], out ExtData[i, 2], out ExtData[i, 3]);
        }

        StringBuilder nameBuilder = new();
        for (uint i = 2; i <= 4; i++)
        {
            if (OpCode.CpuId(CPUID_EXT + i, 0, out eax, out ebx, out ecx, out edx))
            {
                AppendRegister(nameBuilder, eax);
                AppendRegister(nameBuilder, ebx);
                AppendRegister(nameBuilder, ecx);
                AppendRegister(nameBuilder, edx);
            }
        }

        nameBuilder.Replace('\0', ' ');
        BrandString = nameBuilder.ToString().Trim();
        nameBuilder.Replace("(R)", string.Empty);
        nameBuilder.Replace("(TM)", string.Empty);
        nameBuilder.Replace("(tm)", string.Empty);
        nameBuilder.Replace("CPU", string.Empty);
        nameBuilder.Replace("Dual-Core Processor", string.Empty);
        nameBuilder.Replace("Triple-Core Processor", string.Empty);
        nameBuilder.Replace("Quad-Core Processor", string.Empty);
        nameBuilder.Replace("Six-Core Processor", string.Empty);
        nameBuilder.Replace("Eight-Core Processor", string.Empty);
        nameBuilder.Replace("64-Core Processor", string.Empty);
        nameBuilder.Replace("32-Core Processor", string.Empty);
        nameBuilder.Replace("24-Core Processor", string.Empty);
        nameBuilder.Replace("16-Core Processor", string.Empty);
        nameBuilder.Replace("12-Core Processor", string.Empty);
        nameBuilder.Replace("8-Core Processor", string.Empty);
        nameBuilder.Replace("6-Core Processor", string.Empty);

        for (int i = 0; i < 10; i++)
            nameBuilder.Replace("  ", " ");

        Name = nameBuilder.ToString();
        if (Name.Contains("@"))
            Name = Name.Remove(Name.LastIndexOf('@'));

        Name = Name.Trim();
        Family = ((Data[1, 0] & 0x0FF00000) >> 20) + ((Data[1, 0] & 0x0F00) >> 8);
        Model = ((Data[1, 0] & 0x0F0000) >> 12) + ((Data[1, 0] & 0xF0) >> 4);
        Stepping = Data[1, 0] & 0x0F;
        ApicId = (Data[1, 1] >> 24) & 0xFF;
        PkgType = (ExtData[1, 1] >> 28) & 0xFF;

        switch (Vendor)
        {
            case Vendor.Intel:
                uint maxCoreAndThreadIdPerPackage = (Data[1, 1] >> 16) & 0xFF;
                uint maxCoreIdPerPackage;
                if (maxCpuid >= 4)
                    maxCoreIdPerPackage = ((Data[4, 0] >> 26) & 0x3F) + 1;
                else
                    maxCoreIdPerPackage = 1;

                threadMaskWith = NextLog2(maxCoreAndThreadIdPerPackage / maxCoreIdPerPackage);
                coreMaskWith = NextLog2(maxCoreIdPerPackage);
                break;
            case Vendor.AMD:
                uint corePerPackage;
                if (maxCpuidExt >= 8)
                    corePerPackage = (ExtData[8, 2] & 0xFF) + 1;
                else
                    corePerPackage = 1;

                threadMaskWith = 0;
                coreMaskWith = NextLog2(corePerPackage);

                if (Family is 0x17 or 0x19)
                {
                    // ApicIdCoreIdSize: APIC ID size.
                    // cores per DIE
                    // we need this for Ryzen 5 (4 cores, 8 threads) ans Ryzen 6 (6 cores, 12 threads)
                    // Ryzen 5: [core0][core1][dummy][dummy][core2][core3] (Core0 EBX = 00080800, Core2 EBX = 08080800)
                    coreMaskWith = ((ExtData[8, 2] >> 12) & 0xF) switch
                    {
                        0x04 => NextLog2(16), // Ryzen
                        0x05 => NextLog2(32), // Threadripper
                        0x06 => NextLog2(64), // Epic
                        _ => coreMaskWith
                    };
                }

                break;
            default:
                threadMaskWith = 0;
                coreMaskWith = 0;
                break;
        }

        ProcessorId = ApicId >> (int)(coreMaskWith + threadMaskWith);
        CoreId = (ApicId >> (int)threadMaskWith) - (ProcessorId << (int)coreMaskWith);
        ThreadId = ApicId - (ProcessorId << (int)(coreMaskWith + threadMaskWith)) - (CoreId << (int)threadMaskWith);
    }

    public GroupAffinity Affinity { get; }

    public uint ApicId { get; }

    public string BrandString { get; } = string.Empty;

    public uint CoreId { get; }
    public CoreType CoreType { get; } = CoreType.Unknown;

    public uint[,] Data { get; } = new uint[0, 0];

    public uint[,] ExtData { get; } = new uint[0, 0];

    public uint Family { get; }

    public int Group { get; }

    public uint Model { get; }

    public string Name { get; } = string.Empty;

    public uint PkgType { get; }

    public uint ProcessorId { get; }

    public uint Stepping { get; }

    public int Thread { get; }

    public uint ThreadId { get; }

    public Vendor Vendor { get; } = Vendor.Unknown;

    /// <summary>
    /// Gets the specified <see cref="CpuId" />.
    /// </summary>
    /// <param name="group">The group.</param>
    /// <param name="thread">The thread.</param>
    /// <returns><see cref="CpuId" />.</returns>
    public static CpuId Get(int group, int thread)
    {
        if (thread >= 64)
            return null;

        var affinity = GroupAffinity.Single((ushort)group, thread);

        GroupAffinity previousAffinity = ThreadAffinity.Set(affinity);
        if (previousAffinity == GroupAffinity.Undefined)
            return null;

        try
        {
            return new CpuId(group, thread, affinity);
        }
        finally
        {
            ThreadAffinity.Set(previousAffinity);
        }
    }

    private static void AppendRegister(StringBuilder b, uint value)
    {
        b.Append((char)(value & 0xff));
        b.Append((char)((value >> 8) & 0xff));
        b.Append((char)((value >> 16) & 0xff));
        b.Append((char)((value >> 24) & 0xff));
    }

    private static uint NextLog2(long x)
    {
        if (x <= 0)
            return 0;

        x--;
        uint count = 0;
        while (x > 0)
        {
            x >>= 1;
            count++;
        }

        return count;
    }

    // ReSharper disable InconsistentNaming
    public const uint CPUID_0 = 0;
    public const uint CPUID_EXT = 0x80000000;
    // ReSharper restore InconsistentNaming
}

```

`LibreHardwareMonitorLib/Hardware/Cpu/CpuLoad.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using Windows.Wdk;
using Windows.Wdk.System.SystemInformation;
using Windows.Win32.Foundation;
using Windows.Win32.System.WindowsProgramming;

namespace LibreHardwareMonitor.Hardware.Cpu;

internal class CpuLoad
{
    private readonly double[] _threadLoads;
    private long[] _idleTimes;
    private double _totalLoad;
    private long[] _totalTimes;

    public CpuLoad(CpuId[][] cpuid)
    {
        _threadLoads = new double[cpuid.Sum(x => x.Length)];
        _totalLoad = 0;

        try
        {
            GetTimes(out _idleTimes, out _totalTimes);
        }
        catch (Exception)
        {
            _idleTimes = null;
            _totalTimes = null;
        }

        if (_idleTimes != null)
            IsAvailable = true;
    }

    public bool IsAvailable { get; }

    private static bool GetTimes(out long[] idle, out long[] total)
    {
        return !Software.OperatingSystem.IsUnix ? GetWindowsTimes(out idle, out total) : GetUnixTimes(out idle, out total);
    }

    private static unsafe bool GetWindowsTimes(out long[] idle, out long[] total)
    {
        idle = null;
        total = null;

        int size = sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION) * 64;
        uint returnSize = 0;
        IntPtr handle = Marshal.AllocHGlobal(size);
        SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION[] perfInformation;

        while (true)
        {
            //Query processor performance information
            NTSTATUS status = PInvoke.NtQuerySystemInformation(SYSTEM_INFORMATION_CLASS.SystemProcessorPerformanceInformation, (void*)handle, (uint)size, &returnSize);
            if (status == NTSTATUS.STATUS_INFO_LENGTH_MISMATCH)
            {
                size = (int)returnSize;
                handle = Marshal.ReAllocHGlobal(handle, new IntPtr(size));
            }
            else
            {
                if (status != NTSTATUS.STATUS_SUCCESS)
                {
                    Marshal.FreeHGlobal(handle);
                    return false;
                }

                SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION* perfInformationPtr = (SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION*)handle;

                int perfItemsCount = (int)(returnSize / sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION));
                perfInformation = new SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION[perfItemsCount];
                for (int i = 0; i < perfItemsCount; i++)
                {
                    perfInformation[i] = perfInformationPtr[i];
                }

                Marshal.FreeHGlobal(handle);
                break;
            }
        }

        idle = new long[perfInformation.Length];
        total = new long[perfInformation.Length];
        for (int i = 0; i < total.Length; i++)
        {
            idle[i] = perfInformation[i].IdleTime;
            total[i] = perfInformation[i].KernelTime + perfInformation[i].UserTime;
        }

        return true;
    }

    private static bool GetUnixTimes(out long[] idle, out long[] total)
    {
        idle = null;
        total = null;

        List<long> idleList = [];
        List<long> totalList = [];

        if (!File.Exists("/proc/stat"))
            return false;

        string[] cpuInfos = File.ReadAllLines("/proc/stat");

        // currently parse the OverAll CPU info
        // cpu   1583083 737    452845   36226266 723316   63685 31896     0       0       0
        // cpu0  397468  189    109728   9040007  191429   16939 14954     0       0       0
        // 0=cpu 1=user  2=nice 3=system 4=idle   5=iowait 6=irq 7=softirq 8=steal 9=guest 10=guest_nice
        foreach (string cpuInfo in cpuInfos.Where(s => s.StartsWith("cpu") && s.Length > 3 && s[3] != ' '))
        {
            string[] overall = cpuInfo.Split([' '], StringSplitOptions.RemoveEmptyEntries);

            try
            {
                // Parse idle information.
                idleList.Add(long.Parse(overall[4]));
            }
            catch
            {
                // Ignored.
            }

            // Parse total information = user + nice + system + idle + iowait + irq + softirq + steal + guest + guest_nice.
            long currentTotal = 0;
            foreach (string item in overall.Skip(1))
            {
                try
                {
                    currentTotal += long.Parse(item);
                }
                catch
                {
                    // Ignored.
                }
            }

            totalList.Add(currentTotal);
        }

        idle = idleList.ToArray();
        total = totalList.ToArray();
        return true;
    }

    public double GetTotalLoad()
    {
        return _totalLoad;
    }

    public double GetThreadLoad(int thread)
    {
        return _threadLoads[thread];
    }

    public void Update()
    {
        if (_idleTimes == null || !GetTimes(out long[] newIdleTimes, out long[] newTotalTimes))
            return;

        int minDiff = Software.OperatingSystem.IsUnix ? 100 : 100000;
        for (int i = 0; i < Math.Min(newTotalTimes.Length, _totalTimes.Length); i++)
        {
            if (newTotalTimes[i] - _totalTimes[i] < minDiff)
                return;
        }

        if (newIdleTimes == null)
            return;

        double total = 0;
        int count = 0;
        for (int i = 0; i < _threadLoads.Length && i < _idleTimes.Length && i < newIdleTimes.Length; i++)
        {
            double idle = (newIdleTimes[i] - _idleTimes[i]) / (double)(newTotalTimes[i] - _totalTimes[i]);
            idle = idle < 0.0 ? 0.0 : idle;
            idle = idle > 1.0 ? 1.0 : idle;

            double load = 100.0 * (1.0 - Math.Min(idle, 1.0));
            _threadLoads[i] = Math.Round(load, 2);
            total += idle;
            count++;
        }

        if (count > 0)
        {
            total = 1.0 - (total / count);
            total = total < 0.0 ? 0.0 : total;
            total = total > 1.0 ? 1.0 : total;
        }
        else
        {
            total = 0;
        }

        _totalLoad = Math.Round(total * 100.0, 2);
        _totalTimes = newTotalTimes;
        _idleTimes = newIdleTimes;
    }
}

```

`LibreHardwareMonitorLib/Hardware/Cpu/GenericCpu.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Text;

namespace LibreHardwareMonitor.Hardware.Cpu;

public class GenericCpu : Hardware
{
    protected readonly int _coreCount;
    protected readonly CpuId[][] _cpuId;
    protected readonly uint _family;
    protected readonly uint _model;
    protected readonly uint _packageType;
    protected readonly uint _stepping;
    protected readonly int _threadCount;

    private readonly CpuLoad _cpuLoad;
    private readonly double _estimatedTimeStampCounterFrequency;
    private readonly double _estimatedTimeStampCounterFrequencyError;
    private readonly bool _isInvariantTimeStampCounter;
    private readonly Sensor[] _threadLoads;

    private readonly Sensor _totalLoad;
    private readonly Sensor _maxLoad;
    private readonly Vendor _vendor;
    private long _lastTime;
    private ulong _lastTimeStampCount;

    public GenericCpu(int processorIndex, CpuId[][] cpuId, ISettings settings) : base(cpuId[0][0].Name, CreateIdentifier(cpuId[0][0].Vendor, processorIndex), settings)
    {
        _cpuId = cpuId;
        _vendor = cpuId[0][0].Vendor;
        _family = cpuId[0][0].Family;
        _model = cpuId[0][0].Model;
        _stepping = cpuId[0][0].Stepping;
        _packageType = cpuId[0][0].PkgType;

        Index = processorIndex;
        _coreCount = cpuId.Length;
        _threadCount = cpuId.Sum(x => x.Length);

        // Check if processor has MSRs.
        HasModelSpecificRegisters = cpuId[0][0].Data.GetLength(0) > 1 && (cpuId[0][0].Data[1, 3] & 0x20) != 0;

        // Check if processor has a TSC.
        HasTimeStampCounter = cpuId[0][0].Data.GetLength(0) > 1 && (cpuId[0][0].Data[1, 3] & 0x10) != 0;

        // Check if processor supports an invariant TSC.
        _isInvariantTimeStampCounter = cpuId[0][0].ExtData.GetLength(0) > 7 && (cpuId[0][0].ExtData[7, 3] & 0x100) != 0;

        _totalLoad = _coreCount > 1 ? new Sensor("CPU Total", 0, SensorType.Load, this, settings) : null;
        _maxLoad = _coreCount > 1 ? new Sensor("CPU Core Max", 1, SensorType.Load, this, settings) : null;

        _cpuLoad = new CpuLoad(cpuId);
        if (_cpuLoad.IsAvailable)
        {
            _threadLoads = new Sensor[_threadCount];
            for (int coreIdx = 0; coreIdx < cpuId.Length; coreIdx++)
            {
                for (int threadIdx = 0; threadIdx < cpuId[coreIdx].Length; threadIdx++)
                {
                    int thread = cpuId[coreIdx][threadIdx].Thread;
                    if (thread < _threadLoads.Length)
                    {
                        // Some cores may have 2 threads while others have only one (e.g. P-cores vs E-cores on Intel 12th gen).
                        string sensorName = CoreString(coreIdx) + (cpuId[coreIdx].Length > 1 ? $" Thread #{threadIdx + 1}" : string.Empty);
                        _threadLoads[thread] = new Sensor(sensorName, thread + 2, SensorType.Load, this, settings);

                        ActivateSensor(_threadLoads[thread]);
                    }
                }
            }

            if (_totalLoad != null)
            {
                ActivateSensor(_totalLoad);
            }

            if (_maxLoad != null)
            {
                ActivateSensor(_maxLoad);
            }
        }

        if (HasTimeStampCounter)
        {
            GroupAffinity previousAffinity = ThreadAffinity.Set(cpuId[0][0].Affinity);
            EstimateTimeStampCounterFrequency(out _estimatedTimeStampCounterFrequency, out _estimatedTimeStampCounterFrequencyError);
            ThreadAffinity.Set(previousAffinity);
        }
        else
        {
            _estimatedTimeStampCounterFrequency = 0;
        }

        TimeStampCounterFrequency = _estimatedTimeStampCounterFrequency;
    }

    /// <summary>
    /// Gets the CPUID.
    /// </summary>
    public CpuId[][] CpuId => _cpuId;

    public override HardwareType HardwareType => HardwareType.Cpu;

    public bool HasModelSpecificRegisters { get; }

    public bool HasTimeStampCounter { get; }

    /// <summary>
    /// Gets the CPU index.
    /// </summary>
    public int Index { get; }

    public double TimeStampCounterFrequency { get; private set; }

    protected string CoreString(int i)
    {
        if (_coreCount == 1)
            return "CPU Core";

        return "CPU Core #" + (i + 1);
    }

    private static Identifier CreateIdentifier(Vendor vendor, int processorIndex)
    {
        string s = vendor switch
        {
            Vendor.AMD => "amdcpu",
            Vendor.Intel => "intelcpu",
            _ => "genericcpu"
        };

        return new Identifier(s, processorIndex.ToString(CultureInfo.InvariantCulture));
    }

    private static void EstimateTimeStampCounterFrequency(out double frequency, out double error)
    {
        // preload the function
        EstimateTimeStampCounterFrequency(0, out double f, out double e);
        EstimateTimeStampCounterFrequency(0, out f, out e);

        // estimate the frequency
        error = double.MaxValue;
        frequency = 0;
        for (int i = 0; i < 5; i++)
        {
            EstimateTimeStampCounterFrequency(0.025, out f, out e);
            if (e < error)
            {
                error = e;
                frequency = f;
            }

            if (error < 1e-4)
                break;
        }
    }

    private static void EstimateTimeStampCounterFrequency(double timeWindow, out double frequency, out double error)
    {
        long ticks = (long)(timeWindow * Stopwatch.Frequency);

        long timeBegin = Stopwatch.GetTimestamp() + (long)Math.Ceiling(0.001 * ticks);
        long timeEnd = timeBegin + ticks;

        while (Stopwatch.GetTimestamp() < timeBegin)
        { }

        ulong countBegin = OpCode.Rdtsc();
        long afterBegin = Stopwatch.GetTimestamp();

        while (Stopwatch.GetTimestamp() < timeEnd)
        { }

        ulong countEnd = OpCode.Rdtsc();
        long afterEnd = Stopwatch.GetTimestamp();

        double delta = timeEnd - timeBegin;
        frequency = 1e-6 * ((double)(countEnd - countBegin) * Stopwatch.Frequency) / delta;

        double beginError = (afterBegin - timeBegin) / delta;
        double endError = (afterEnd - timeEnd) / delta;
        error = beginError + endError;
    }


    public override string GetReport()
    {
        StringBuilder r = new();

        switch (_vendor)
        {
            case Vendor.AMD:
                r.AppendLine("AMD CPU");
                break;
            case Vendor.Intel:
                r.AppendLine("Intel CPU");
                break;
            default:
                r.AppendLine("Generic CPU");
                break;
        }

        r.AppendLine();
        r.AppendFormat("Name: {0}{1}", _name, Environment.NewLine);
        r.AppendFormat("Number of Cores: {0}{1}", _coreCount, Environment.NewLine);
        r.AppendFormat("Threads per Core: {0}{1}", _cpuId[0].Length, Environment.NewLine);
        r.AppendLine(string.Format(CultureInfo.InvariantCulture, "Timer Frequency: {0} MHz", Stopwatch.Frequency * 1e-6));
        r.AppendLine("Time Stamp Counter: " + (HasTimeStampCounter ? _isInvariantTimeStampCounter ? "Invariant" : "Not Invariant" : "None"));
        r.AppendLine(string.Format(CultureInfo.InvariantCulture, "Estimated Time Stamp Counter Frequency: {0} MHz", Math.Round(_estimatedTimeStampCounterFrequency * 100) * 0.01));
        r.AppendLine(string.Format(CultureInfo.InvariantCulture,
                                   "Estimated Time Stamp Counter Frequency Error: {0} Mhz",
                                   Math.Round(_estimatedTimeStampCounterFrequency * _estimatedTimeStampCounterFrequencyError * 1e5) * 1e-5));

        r.AppendLine(string.Format(CultureInfo.InvariantCulture, "Time Stamp Counter Frequency: {0} MHz", Math.Round(TimeStampCounterFrequency * 100) * 0.01));
        r.AppendLine();

        return r.ToString();
    }

    public override void Update()
    {
        if (HasTimeStampCounter && _isInvariantTimeStampCounter)
        {
            // make sure always the same thread is used
            GroupAffinity previousAffinity = ThreadAffinity.Set(_cpuId[0][0].Affinity);

            // read time before and after getting the TSC to estimate the error
            long firstTime = Stopwatch.GetTimestamp();
            ulong timeStampCount = OpCode.Rdtsc();
            long time = Stopwatch.GetTimestamp();

            // restore the thread affinity mask
            ThreadAffinity.Set(previousAffinity);

            double delta = (double)(time - _lastTime) / Stopwatch.Frequency;
            double error = (double)(time - firstTime) / Stopwatch.Frequency;

            // only use data if they are measured accurate enough (max 0.1ms delay)
            if (error < 0.0001)
            {
                // ignore the first reading because there are no initial values
                // ignore readings with too large or too small time window
                if (_lastTime != 0 && delta is > 0.5 and < 2)
                {
                    // update the TSC frequency with the new value
                    TimeStampCounterFrequency = (timeStampCount - _lastTimeStampCount) / (1e6 * delta);
                }

                _lastTimeStampCount = timeStampCount;
                _lastTime = time;
            }
        }

        if (_cpuLoad.IsAvailable)
        {
            _cpuLoad.Update();

            float maxLoad = 0;
            if (_threadLoads != null)
            {
                for (int i = 0; i < _threadLoads.Length; i++)
                {
                    if (_threadLoads[i] != null)
                    {
                        _threadLoads[i].Value = (float)_cpuLoad.GetThreadLoad(i);
                        maxLoad = Math.Max(maxLoad, _threadLoads[i].Value ?? 0);
                    }
                }
            }

            if (_totalLoad != null)
                _totalLoad.Value = (float)_cpuLoad.GetTotalLoad();

            if (_maxLoad != null)
                _maxLoad.Value = maxLoad;
        }
    }
}

```

`LibreHardwareMonitorLib/Hardware/Cpu/IntelCpu.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Text;
using LibreHardwareMonitor.PawnIo;

namespace LibreHardwareMonitor.Hardware.Cpu;

internal sealed class IntelCpu : GenericCpu
{
    private readonly Sensor _busClock;
    private readonly Sensor _coreAvg;
    private readonly Sensor[] _coreClocks;
    private readonly Sensor _coreMax;
    private readonly Sensor[] _coreTemperatures;
    private readonly Sensor[] _coreVIDs;
    private readonly Sensor _coreVoltage;
    private readonly Sensor[] _distToTjMaxTemperatures;

    private readonly string[] _coreNames;

    private readonly uint[] _energyStatusMsrs = { MSR_PKG_ENERGY_STATUS, MSR_PP0_ENERGY_STATUS, MSR_PP1_ENERGY_STATUS, MSR_DRAM_ENERGY_STATUS, MSR_PLATFORM_ENERGY_STATUS };
    private readonly uint[] _lastEnergyConsumed;
    private readonly DateTime[] _lastEnergyTime;

    private readonly MicroArchitecture _microArchitecture;
    private readonly Sensor _packageTemperature;
    private readonly Sensor[] _powerSensors;
    private readonly double _timeStampCounterMultiplier;

    private readonly IntelMsr _pawnModule;

    public IntelCpu(int processorIndex, CpuId[][] cpuId, ISettings settings) : base(processorIndex, cpuId, settings)
    {
        _pawnModule = new IntelMsr();

        uint eax;

        // set tjMax
        float[] tjMax;
        switch (_family)
        {
            case 0x06:
                {
                    switch (_model)
                    {
                        case 0x0F: // Intel Core 2 (65nm)
                            _microArchitecture = MicroArchitecture.Core;
                            tjMax = _stepping switch
                            {
                                // B2
                                0x06 => _coreCount switch
                                {
                                    2 => Floats(80 + 10),
                                    4 => Floats(90 + 10),
                                    _ => Floats(85 + 10)
                                },
                                // G0
                                0x0B => Floats(90 + 10),
                                // M0
                                0x0D => Floats(85 + 10),
                                _ => Floats(85 + 10)
                            };
                            break;

                        case 0x17: // Intel Core 2 (45nm)
                            _microArchitecture = MicroArchitecture.Core;
                            tjMax = Floats(100);
                            break;

                        case 0x1C: // Intel Atom (45nm)
                            _microArchitecture = MicroArchitecture.Atom;
                            tjMax = _stepping switch
                            {
                                // C0
                                0x02 => Floats(90),
                                // A0, B0
                                0x0A => Floats(100),
                                _ => Floats(90)
                            };
                            break;

                        case 0x1A: // Intel Core i7 LGA1366 (45nm)
                        case 0x1E: // Intel Core i5, i7 LGA1156 (45nm)
                        case 0x1F: // Intel Core i5, i7
                        case 0x25: // Intel Core i3, i5, i7 LGA1156 (32nm)
                        case 0x2C: // Intel Core i7 LGA1366 (32nm) 6 Core
                        case 0x2E: // Intel Xeon Processor 7500 series (45nm)
                        case 0x2F: // Intel Xeon Processor (32nm)
                            _microArchitecture = MicroArchitecture.Nehalem;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0x2A: // Intel Core i5, i7 2xxx LGA1155 (32nm)
                        case 0x2D: // Next Generation Intel Xeon, i7 3xxx LGA2011 (32nm)
                            _microArchitecture = MicroArchitecture.SandyBridge;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0x3A: // Intel Core i5, i7 3xxx LGA1155 (22nm)
                        case 0x3E: // Intel Core i7 4xxx LGA2011 (22nm)
                            _microArchitecture = MicroArchitecture.IvyBridge;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0x3C: // Intel Core i5, i7 4xxx LGA1150 (22nm)
                        case 0x3F: // Intel Xeon E5-2600/1600 v3, Core i7-59xx
                        // LGA2011-v3, Haswell-E (22nm)
                        case 0x45: // Intel Core i5, i7 4xxxU (22nm)
                        case 0x46:
                            _microArchitecture = MicroArchitecture.Haswell;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0x3D: // Intel Core M-5xxx (14nm)
                        case 0x47: // Intel i5, i7 5xxx, Xeon E3-1200 v4 (14nm)
                        case 0x4F: // Intel Xeon E5-26xx v4
                        case 0x56: // Intel Xeon D-15xx
                            _microArchitecture = MicroArchitecture.Broadwell;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0x36: // Intel Atom S1xxx, D2xxx, N2xxx (32nm)
                            _microArchitecture = MicroArchitecture.Atom;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0x37: // Intel Atom E3xxx, Z3xxx (22nm)
                        case 0x4A:
                        case 0x4D: // Intel Atom C2xxx (22nm)
                        case 0x5A:
                        case 0x5D:
                            _microArchitecture = MicroArchitecture.Silvermont;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0x4E:
                        case 0x5E: // Intel Core i5, i7 6xxxx LGA1151 (14nm)
                        case 0x55: // Intel Core X i7, i9 7xxx LGA2066 (14nm)
                            _microArchitecture = MicroArchitecture.Skylake;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0x4C: // Intel Airmont (Cherry Trail, Braswell)
                            _microArchitecture = MicroArchitecture.Airmont;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0x8E: // Intel Core i5, i7 7xxxx (14nm) (Kaby Lake) and 8xxxx (14nm++) (Coffee Lake)
                        case 0x9E:
                            _microArchitecture = MicroArchitecture.KabyLake;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0x5C: // Goldmont (Apollo Lake)
                        case 0x5F: // (Denverton)
                            _microArchitecture = MicroArchitecture.Goldmont;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0x7A: // Goldmont plus (Gemini Lake)
                            _microArchitecture = MicroArchitecture.GoldmontPlus;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0x66: // Intel Core i3 8xxx (10nm) (Cannon Lake)
                            _microArchitecture = MicroArchitecture.CannonLake;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0x7D: // Intel Core i3, i5, i7 10xxx (10nm) (Ice Lake)
                        case 0x7E:
                        case 0x6A: // Ice Lake server
                        case 0x6C:
                            _microArchitecture = MicroArchitecture.IceLake;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0xA5:
                        case 0xA6: // Intel Core i3, i5, i7 10xxxU (14nm)
                            _microArchitecture = MicroArchitecture.CometLake;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0x86: // Tremont (10nm) (Elkhart Lake, Skyhawk Lake)
                            _microArchitecture = MicroArchitecture.Tremont;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0x8C: // Tiger Lake (Intel 10 nm SuperFin, Gen. 11)
                        case 0x8D:
                            _microArchitecture = MicroArchitecture.TigerLake;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0x97: // Alder Lake (Intel 7 (10ESF), Gen. 12)
                        case 0x9A: // Alder Lake-L (Intel 7 (10ESF), Gen. 12)
                        case 0xBE: // Alder Lake-N (Intel 7 (10ESF), Gen. 12)
                            _microArchitecture = MicroArchitecture.AlderLake;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0xB7: // Raptor Lake (Intel 7 (10ESF), Gen. 13)
                        case 0xBA: // Raptor Lake-P (Intel 7 (10ESF), Gen. 13)
                        case 0xBF: // Raptor Lake-N (Intel 7 (10ESF), Gen. 13)
                            _microArchitecture = MicroArchitecture.RaptorLake;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0xAC: // Meteor Lake (Intel 4, TSMC N5/N6, Gen. 14)
                        case 0xAA: // Meteor Lake-L (Intel 4, TSMC N5/N6, Gen. 14)
                            _microArchitecture = MicroArchitecture.MeteorLake;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0x9C: // Jasper Lake (10nm)
                            _microArchitecture = MicroArchitecture.JasperLake;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0xA7: // Intel Core i5, i6, i7 11xxx (14nm) (Rocket Lake)
                            _microArchitecture = MicroArchitecture.RocketLake;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0xC5: // Intel Core Ultra 9 200 Series ArrowLake
                        case 0xC6: // Intel Core Ultra 7 200 Series ArrowLake
                            _microArchitecture = MicroArchitecture.ArrowLake;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        case 0xBD: // Intel Core Ultra 5/7 200 Series LunarLake
                            _microArchitecture = MicroArchitecture.LunarLake;
                            tjMax = GetTjMaxFromMsr();
                            break;
                        case 0x8F: // Intel Xeon W5-3435X // SapphireRapids 
                            _microArchitecture = MicroArchitecture.SapphireRapids;
                            tjMax = GetTjMaxFromMsr();
                            break;
                        case 0x96: // Intel Celeron ElkhartLake 
                            _microArchitecture = MicroArchitecture.ElkhartLake;
                            tjMax = GetTjMaxFromMsr();
                            break;

                        default:
                            _microArchitecture = MicroArchitecture.Unknown;
                            tjMax = Floats(100);
                            break;
                    }
                }

                break;
            case 0x0F:
                switch (_model)
                {
                    case 0x00: // Pentium 4 (180nm)
                    case 0x01: // Pentium 4 (130nm)
                    case 0x02: // Pentium 4 (130nm)
                    case 0x03: // Pentium 4, Celeron D (90nm)
                    case 0x04: // Pentium 4, Pentium D, Celeron D (90nm)
                    case 0x06: // Pentium 4, Pentium D, Celeron D (65nm)
                        _microArchitecture = MicroArchitecture.NetBurst;
                        tjMax = Floats(100);
                        break;

                    default:
                        _microArchitecture = MicroArchitecture.Unknown;
                        tjMax = Floats(100);
                        break;
                }

                break;
            default:
                _microArchitecture = MicroArchitecture.Unknown;
                tjMax = Floats(100);
                break;
        }

        // set timeStampCounterMultiplier
        switch (_microArchitecture)
        {
            case MicroArchitecture.Atom:
            case MicroArchitecture.Core:
            case MicroArchitecture.NetBurst:
                if (_pawnModule.ReadMsr(IA32_PERF_STATUS, out uint _, out uint edx))
                    _timeStampCounterMultiplier = ((edx >> 8) & 0x1f) + (0.5 * ((edx >> 14) & 1));

                break;
            case MicroArchitecture.Airmont:
            case MicroArchitecture.AlderLake:
            case MicroArchitecture.ArrowLake:
            case MicroArchitecture.Broadwell:
            case MicroArchitecture.CannonLake:
            case MicroArchitecture.CometLake:
            case MicroArchitecture.Goldmont:
            case MicroArchitecture.GoldmontPlus:
            case MicroArchitecture.Haswell:
            case MicroArchitecture.IceLake:
            case MicroArchitecture.IvyBridge:
            case MicroArchitecture.JasperLake:
            case MicroArchitecture.KabyLake:
            case MicroArchitecture.LunarLake:
            case MicroArchitecture.Nehalem:
            case MicroArchitecture.MeteorLake:
            case MicroArchitecture.RaptorLake:
            case MicroArchitecture.RocketLake:
            case MicroArchitecture.SandyBridge:
            case MicroArchitecture.Silvermont:
            case MicroArchitecture.Skylake:
            case MicroArchitecture.TigerLake:
            case MicroArchitecture.SapphireRapids:
            case MicroArchitecture.ElkhartLake:
            case MicroArchitecture.Tremont:
                if (_pawnModule.ReadMsr(MSR_PLATFORM_INFO, out eax, out uint _))
                    _timeStampCounterMultiplier = (eax >> 8) & 0xff;

                break;
            default:
                _timeStampCounterMultiplier = 0;
                break;
        }

        // Initialize core names
        _coreNames = new string[_coreCount];
        int pCoreIndex = 1;
        int eCoreIndex = 1;

        for (int i = 0; i < _coreCount; i++)
        {
            if (_cpuId.Length > i && _cpuId[i].Length > 0)
            {
                CoreType coreType = _cpuId[i][0].CoreType;

                _coreNames[i] = coreType switch
                {
                    CoreType.Performance => $"P-Core #{pCoreIndex++}",
                    CoreType.Efficient => $"E-Core #{eCoreIndex++}",
                    _ => CoreString(i)
                };
            }
            else
            {
                _coreNames[i] = CoreString(i);
            }
        }

        int coreSensorId = 0;

        //core temp avg and max value
        //is only available when the cpu has more than 1 core
        if (cpuId[0][0].Data.GetLength(0) > 6 && (cpuId[0][0].Data[6, 0] & 0x40) != 0 && _microArchitecture != MicroArchitecture.Unknown && _coreCount > 1)
        {
            _coreMax = new Sensor("Core Max", coreSensorId, SensorType.Temperature, this, settings);
            ActivateSensor(_coreMax);
            coreSensorId++;

            _coreAvg = new Sensor("Core Average", coreSensorId, SensorType.Temperature, this, settings);
            ActivateSensor(_coreAvg);
            coreSensorId++;
        }
        else
        {
            _coreMax = null;
            _coreAvg = null;
        }

        // check if processor supports a digital thermal sensor at core level
        if (cpuId[0][0].Data.GetLength(0) > 6 && (cpuId[0][0].Data[6, 0] & 1) != 0 && _microArchitecture != MicroArchitecture.Unknown)
        {
            _coreTemperatures = new Sensor[_coreCount];
            for (int i = 0; i < _coreTemperatures.Length; i++)
            {
                _coreTemperatures[i] = new Sensor(_coreNames[i],
                    coreSensorId,
                    SensorType.Temperature,
                    this,
                    [
                        new ParameterDescription("TjMax [°C]", "TjMax temperature of the core sensor.\n" + "Temperature = TjMax - TSlope * Value.", tjMax[i]),
                        new ParameterDescription("TSlope [°C]", "Temperature slope of the digital thermal sensor.\n" + "Temperature = TjMax - TSlope * Value.", 1)
                    ],
                    settings);

                ActivateSensor(_coreTemperatures[i]);
                coreSensorId++;
            }
        }
        else
        {
            _coreTemperatures = [];
        }

        // check if processor supports a digital thermal sensor at package level
        if (cpuId[0][0].Data.GetLength(0) > 6 && (cpuId[0][0].Data[6, 0] & 0x40) != 0 && _microArchitecture != MicroArchitecture.Unknown)
        {
            _packageTemperature = new Sensor("CPU Package",
                                             coreSensorId,
                                             SensorType.Temperature,
                                             this,
                                             [
                                                 new ParameterDescription("TjMax [°C]", "TjMax temperature of the package sensor.\n" + "Temperature = TjMax - TSlope * Value.", tjMax[0]),
                                                 new ParameterDescription("TSlope [°C]", "Temperature slope of the digital thermal sensor.\n" + "Temperature = TjMax - TSlope * Value.", 1)
                                             ],
                                             settings);

            ActivateSensor(_packageTemperature);
            coreSensorId++;
        }

        // dist to tjmax sensor
        if (cpuId[0][0].Data.GetLength(0) > 6 && (cpuId[0][0].Data[6, 0] & 1) != 0 && _microArchitecture != MicroArchitecture.Unknown)
        {
            _distToTjMaxTemperatures = new Sensor[_coreCount];
            for (int i = 0; i < _distToTjMaxTemperatures.Length; i++)
            {
                _distToTjMaxTemperatures[i] = new Sensor(_coreNames[i] + " Distance to TjMax", coreSensorId, SensorType.Temperature, this, settings);
                ActivateSensor(_distToTjMaxTemperatures[i]);
                coreSensorId++;
            }
        }
        else
        {
            _distToTjMaxTemperatures = [];
        }

        _busClock = new Sensor("Bus Speed", 0, SensorType.Clock, this, settings);
        _coreClocks = new Sensor[_coreCount];
        for (int i = 0; i < _coreClocks.Length; i++)
        {
            _coreClocks[i] = new Sensor(_coreNames[i], i + 1, SensorType.Clock, this, settings);
            if (HasTimeStampCounter && _microArchitecture != MicroArchitecture.Unknown)
                ActivateSensor(_coreClocks[i]);
        }

        if (_microArchitecture is MicroArchitecture.Airmont or
            MicroArchitecture.AlderLake or
            MicroArchitecture.ArrowLake or
            MicroArchitecture.Broadwell or
            MicroArchitecture.CannonLake or
            MicroArchitecture.CometLake or
            MicroArchitecture.Goldmont or
            MicroArchitecture.GoldmontPlus or
            MicroArchitecture.Haswell or
            MicroArchitecture.IceLake or
            MicroArchitecture.IvyBridge or
            MicroArchitecture.JasperLake or
            MicroArchitecture.KabyLake or
            MicroArchitecture.LunarLake or
            MicroArchitecture.MeteorLake or
            MicroArchitecture.RaptorLake or
            MicroArchitecture.RocketLake or
            MicroArchitecture.SandyBridge or
            MicroArchitecture.Silvermont or
            MicroArchitecture.Skylake or
            MicroArchitecture.TigerLake or
            MicroArchitecture.SapphireRapids or
            MicroArchitecture.ElkhartLake or
            MicroArchitecture.Tremont)
        {
            _powerSensors = new Sensor[_energyStatusMsrs.Length];
            _lastEnergyTime = new DateTime[_energyStatusMsrs.Length];
            _lastEnergyConsumed = new uint[_energyStatusMsrs.Length];

            if (_pawnModule.ReadMsr(MSR_RAPL_POWER_UNIT, out eax, out uint _))
            {
                EnergyUnitsMultiplier = _microArchitecture switch
                {
                    MicroArchitecture.Silvermont or MicroArchitecture.Airmont => 1.0e-6f * (1 << (int)((eax >> 8) & 0x1F)),
                    _ => 1.0f / (1 << (int)((eax >> 8) & 0x1F))
                };
            }

            if (EnergyUnitsMultiplier != 0)
            {
                string[] powerSensorLabels = ["CPU Package", "CPU Cores", "CPU Graphics", "CPU Memory", "CPU Platform"];

                for (int i = 0; i < _energyStatusMsrs.Length; i++)
                {
                    if (!_pawnModule.ReadMsr(_energyStatusMsrs[i], out eax, out uint _))
                        continue;

                    // Don't show the "GPU Graphics" sensor on windows, it will show up under the GPU instead.
                    if (i == 2 && !Software.OperatingSystem.IsUnix)
                        continue;

                    _lastEnergyTime[i] = DateTime.UtcNow;
                    _lastEnergyConsumed[i] = eax;
                    _powerSensors[i] = new Sensor(powerSensorLabels[i],
                                                  i,
                                                  SensorType.Power,
                                                  this,
                                                  settings);

                    ActivateSensor(_powerSensors[i]);
                }
            }
        }

        if (_pawnModule.ReadMsr(IA32_PERF_STATUS, out eax, out uint _) && ((eax >> 32) & 0xFFFF) > 0)
        {
            _coreVoltage = new Sensor("CPU Core", 0, SensorType.Voltage, this, settings);
            ActivateSensor(_coreVoltage);
        }

        _coreVIDs = new Sensor[_coreCount];
        for (int i = 0; i < _coreVIDs.Length; i++)
        {
            _coreVIDs[i] = new Sensor(_coreNames[i], i + 1, SensorType.Voltage, this, settings);
            ActivateSensor(_coreVIDs[i]);
        }

        Update();
    }

    public float EnergyUnitsMultiplier { get; }

    private float[] Floats(float f)
    {
        float[] result = new float[_coreCount];
        for (int i = 0; i < _coreCount; i++)
            result[i] = f;

        return result;
    }

    private float[] GetTjMaxFromMsr()
    {
        float[] result = new float[_coreCount];
        for (int i = 0; i < _coreCount; i++)
        {
            if (_pawnModule.ReadMsr(IA32_TEMPERATURE_TARGET, out uint eax, out uint _, _cpuId[i][0].Affinity))
                result[i] = (eax >> 16) & 0xFF;
            else
                result[i] = 100;
        }

        return result;
    }

    public override string GetReport()
    {
        StringBuilder r = new();
        r.Append(base.GetReport());
        r.Append("MicroArchitecture: ");
        r.AppendLine(_microArchitecture.ToString());
        r.Append("Time Stamp Counter Multiplier: ");
        r.AppendLine(_timeStampCounterMultiplier.ToString(CultureInfo.InvariantCulture));
        r.AppendLine();
        return r.ToString();
    }

    /// <inheritdoc />
    public override void Close()
    {
        base.Close();
        _pawnModule.Close();
    }

    public override void Update()
    {
        base.Update();

        float coreMax = float.MinValue;
        float coreAvg = 0;
        uint eax;

        for (int i = 0; i < _coreTemperatures.Length; i++)
        {
            // if reading is valid
            if (_pawnModule.ReadMsr(IA32_THERM_STATUS_MSR, out eax, out _, _cpuId[i][0].Affinity) && (eax & 0x80000000) != 0)
            {
                // get the dist from tjMax from bits 22:16
                float deltaT = (eax & 0x007F0000) >> 16;
                float tjMax = _coreTemperatures[i].Parameters[0].Value;
                float tSlope = _coreTemperatures[i].Parameters[1].Value;
                _coreTemperatures[i].Value = tjMax - (tSlope * deltaT);

                coreAvg += (float)_coreTemperatures[i].Value;
                if (coreMax < _coreTemperatures[i].Value)
                    coreMax = (float)_coreTemperatures[i].Value;

                _distToTjMaxTemperatures[i].Value = deltaT;
            }
            else
            {
                _coreTemperatures[i].Value = null;
                _distToTjMaxTemperatures[i].Value = null;
            }
        }

        //calculate average cpu temperature over all cores
        if (_coreMax != null && coreMax != float.MinValue)
        {
            _coreMax.Value = coreMax;
            coreAvg /= _coreTemperatures.Length;
            _coreAvg.Value = coreAvg;
        }

        if (_packageTemperature != null)
        {
            // if reading is valid
            if (_pawnModule.ReadMsr(IA32_PACKAGE_THERM_STATUS, out eax, out _, _cpuId[0][0].Affinity) && (eax & 0x80000000) != 0)
            {
                // get the dist from tjMax from bits 22:16
                float deltaT = (eax & 0x007F0000) >> 16;
                float tjMax = _packageTemperature.Parameters[0].Value;
                float tSlope = _packageTemperature.Parameters[1].Value;
                _packageTemperature.Value = tjMax - (tSlope * deltaT);
            }
            else
            {
                _packageTemperature.Value = null;
            }
        }

        if (HasTimeStampCounter && _timeStampCounterMultiplier > 0)
        {
            double newBusClock = 0;
            for (int i = 0; i < _coreClocks.Length; i++)
            {
                System.Threading.Thread.Sleep(1);
                if (_pawnModule.ReadMsr(IA32_PERF_STATUS, out eax, out _, _cpuId[i][0].Affinity))
                {
                    newBusClock = TimeStampCounterFrequency / _timeStampCounterMultiplier;
                    switch (_microArchitecture)
                    {
                        case MicroArchitecture.Nehalem:
                            _coreClocks[i].Value = (float)((eax & 0xff) * newBusClock);
                            break;
                        case MicroArchitecture.Airmont:
                        case MicroArchitecture.AlderLake:
                        case MicroArchitecture.ArrowLake:
                        case MicroArchitecture.Broadwell:
                        case MicroArchitecture.CannonLake:
                        case MicroArchitecture.CometLake:
                        case MicroArchitecture.Goldmont:
                        case MicroArchitecture.GoldmontPlus:
                        case MicroArchitecture.Haswell:
                        case MicroArchitecture.IceLake:
                        case MicroArchitecture.IvyBridge:
                        case MicroArchitecture.JasperLake:
                        case MicroArchitecture.KabyLake:
                        case MicroArchitecture.LunarLake:
                        case MicroArchitecture.MeteorLake:
                        case MicroArchitecture.RaptorLake:
                        case MicroArchitecture.RocketLake:
                        case MicroArchitecture.SandyBridge:
                        case MicroArchitecture.Silvermont:
                        case MicroArchitecture.Skylake:
                        case MicroArchitecture.TigerLake:
                        case MicroArchitecture.SapphireRapids:
                        case MicroArchitecture.ElkhartLake:
                        case MicroArchitecture.Tremont:
                            _coreClocks[i].Value = (float)(((eax >> 8) & 0xff) * newBusClock);
                            break;
                        default:
                            _coreClocks[i].Value = (float)((((eax >> 8) & 0x1f) + (0.5 * ((eax >> 14) & 1))) * newBusClock);
                            break;
                    }
                }
                else
                {
                    // if IA32_PERF_STATUS is not available, assume TSC frequency
                    _coreClocks[i].Value = (float)TimeStampCounterFrequency;
                }
            }

            if (newBusClock > 0)
            {
                _busClock.Value = (float)newBusClock;
                ActivateSensor(_busClock);
            }
        }

        if (_powerSensors != null)
        {
            foreach (Sensor sensor in _powerSensors)
            {
                if (sensor == null)
                    continue;

                if (!_pawnModule.ReadMsr(_energyStatusMsrs[sensor.Index], out eax, out _))
                    continue;

                DateTime time = DateTime.UtcNow;
                uint energyConsumed = eax;
                float deltaTime = (float)(time - _lastEnergyTime[sensor.Index]).TotalSeconds;
                if (deltaTime < 0.01)
                    continue;

                sensor.Value = EnergyUnitsMultiplier * unchecked(energyConsumed - _lastEnergyConsumed[sensor.Index]) / deltaTime;
                _lastEnergyTime[sensor.Index] = time;
                _lastEnergyConsumed[sensor.Index] = energyConsumed;
            }
        }

        if (_coreVoltage != null && _pawnModule.ReadMsr(IA32_PERF_STATUS, out _, out uint edx))
        {
            _coreVoltage.Value = ((edx >> 32) & 0xFFFF) / (float)(1 << 13);
        }

        for (int i = 0; i < _coreVIDs.Length; i++)
        {
            if (_pawnModule.ReadMsr(IA32_PERF_STATUS, out _, out edx, _cpuId[i][0].Affinity) && ((edx >> 32) & 0xFFFF) > 0)
            {
                _coreVIDs[i].Value = ((edx >> 32) & 0xFFFF) / (float)(1 << 13);
                ActivateSensor(_coreVIDs[i]);
            }
            else
            {
                DeactivateSensor(_coreVIDs[i]);
            }
        }
    }

    [SuppressMessage("ReSharper", "IdentifierTypo")]
    private enum MicroArchitecture
    {
        Airmont,
        AlderLake,
        Atom,
        ArrowLake, // Gen. 15 (0xC6, -H = 0xC5)
        Broadwell,
        CannonLake,
        CometLake,
        Core,
        Goldmont,
        GoldmontPlus,
        Haswell,
        IceLake,
        IvyBridge,
        JasperLake,
        KabyLake,
        LunarLake,
        Nehalem,
        NetBurst,
        MeteorLake,
        RocketLake,
        SandyBridge,
        Silvermont,
        Skylake,
        TigerLake,
        Tremont,
        RaptorLake,
        SapphireRapids,
        ElkhartLake,
        Unknown
    }

    // ReSharper disable InconsistentNaming
    private const uint IA32_PACKAGE_THERM_STATUS = 0x1B1;
    private const uint IA32_PERF_STATUS = 0x0198;
    private const uint IA32_TEMPERATURE_TARGET = 0x01A2;
    private const uint IA32_THERM_STATUS_MSR = 0x019C;

    private const uint MSR_DRAM_ENERGY_STATUS = 0x619;
    private const uint MSR_PKG_ENERGY_STATUS = 0x611;
    private const uint MSR_PLATFORM_INFO = 0xCE;
    private const uint MSR_PP0_ENERGY_STATUS = 0x639;
    private const uint MSR_PP1_ENERGY_STATUS = 0x641;
    private const uint MSR_PLATFORM_ENERGY_STATUS = 0x64D;

    private const uint MSR_RAPL_POWER_UNIT = 0x606;
    // ReSharper restore InconsistentNaming
}

```

`LibreHardwareMonitorLib/Hardware/D3DDisplayDevice.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.
// Ported from: https://github.com/processhacker/processhacker/blob/master/plugins/ExtendedTools/gpumon.c

using System;
using System.Linq;
using System.Runtime.InteropServices;
using Windows.Wdk.Graphics.Direct3D;
using Windows.Win32.Devices.DeviceAndDriverInstallation;
using Windows.Win32.Foundation;
using PInvoke = Windows.Win32.PInvoke;

namespace LibreHardwareMonitor.Hardware;

internal static class D3DDisplayDevice
{
    public static unsafe string[] GetDeviceIdentifiers()
    {
        if (PInvoke.CM_Get_Device_Interface_List_Size(out uint size, PInvoke.GUID_DISPLAY_DEVICE_ARRIVAL, null, CM_GET_DEVICE_INTERFACE_LIST_FLAGS.CM_GET_DEVICE_INTERFACE_LIST_PRESENT) !=
            CONFIGRET.CR_SUCCESS)
            return null;

        char[] data = new char[size];
        fixed (char* pData = data)
        {
            if (PInvoke.CM_Get_Device_Interface_List(PInvoke.GUID_DISPLAY_DEVICE_ARRIVAL, null, pData, (uint)data.Length, CM_GET_DEVICE_INTERFACE_LIST_FLAGS.CM_GET_DEVICE_INTERFACE_LIST_PRESENT) ==
                CONFIGRET.CR_SUCCESS)
            {
                return new string(data).Split('\0').Where(m => !string.IsNullOrEmpty(m)).ToArray();
            }
        }

        return null;
    }

    public static string GetActualDeviceIdentifier(string deviceIdentifier)
    {
        if (string.IsNullOrEmpty(deviceIdentifier))
            return deviceIdentifier;

        // For example:
        // \\?\ROOT#BasicRender#0000#{1ca05180-a699-450a-9a0c-de4fbe3ddd89}  -->  ROOT\BasicRender\0000
        // \\?\PCI#VEN_1002&DEV_731F&SUBSYS_57051682&REV_C4#6&e539058&0&00000019#{1ca05180-a699-450a-9a0c-de4fbe3ddd89}  -->  PCI\VEN_1002&DEV_731F&SUBSYS_57051682&REV_C4\6&e539058&0&00000019

        if (deviceIdentifier.StartsWith(@"\\?\"))
            deviceIdentifier = deviceIdentifier.Substring(4);

        if (deviceIdentifier.Length > 0 && deviceIdentifier[deviceIdentifier.Length - 1] == '}')
        {
            int lastIndex = deviceIdentifier.LastIndexOf('{');
            if (lastIndex > 0)
                deviceIdentifier = deviceIdentifier.Substring(0, lastIndex - 1);
        }

        return deviceIdentifier.Replace('#', '\\');
    }

    public static bool GetDeviceInfoByIdentifier(string deviceIdentifier, out D3DDeviceInfo deviceInfo)
    {
        deviceInfo = new D3DDeviceInfo();

        OpenAdapterFromDeviceName(out NTSTATUS status, deviceIdentifier, out D3DKMT_OPENADAPTERFROMDEVICENAME adapter);
        if (status != NTSTATUS.STATUS_SUCCESS)
            return false;

        GetAdapterType(out status, adapter, out D3DKMT_ADAPTERTYPE adapterType);
        if (status != NTSTATUS.STATUS_SUCCESS)
            return false;

        if (adapterType.Anonymous.Anonymous.SoftwareDevice)
            return false;

        deviceInfo.Integrated = adapterType.Anonymous.Anonymous.HybridIntegrated;

        GetQueryStatisticsAdapterInformation(out status, adapter, out D3DKMT_QUERYSTATISTICS_ADAPTER_INFORMATION adapterInformation);
        if (status != NTSTATUS.STATUS_SUCCESS)
            return false;

        uint segmentCount = adapterInformation.NbSegments;
        uint nodeCount = adapterInformation.NodeCount;

        deviceInfo.Nodes = new D3DDeviceNodeInfo[nodeCount];

        DateTime queryTime = DateTime.Now;

        for (uint nodeId = 0; nodeId < nodeCount; nodeId++)
        {
            GetNodeMetaData(out status, adapter, nodeId, out D3DKMT_NODEMETADATA nodeMetaData);
            if (status != NTSTATUS.STATUS_SUCCESS)
                return false;

            GetQueryStatisticsNode(out status, adapter, nodeId, out D3DKMT_QUERYSTATISTICS_NODE_INFORMATION nodeInformation);
            if (status != NTSTATUS.STATUS_SUCCESS)
                return false;

            deviceInfo.Nodes[nodeId] = new D3DDeviceNodeInfo
            {
                Id = nodeId, 
                Name = GetNodeEngineTypeString(nodeMetaData),
                RunningTime = nodeInformation.GlobalInformation.RunningTime, 
                QueryTime = queryTime
            };
        }

        GetSegmentSize(out status, adapter, out D3DKMT_SEGMENTSIZEINFO segmentSizeInfo);
        if (status != NTSTATUS.STATUS_SUCCESS)
            return false;

        deviceInfo.GpuSharedLimit = segmentSizeInfo.SharedSystemMemorySize;
        deviceInfo.GpuVideoMemoryLimit = segmentSizeInfo.DedicatedVideoMemorySize;
        deviceInfo.GpuDedicatedLimit = segmentSizeInfo.DedicatedSystemMemorySize;

        for (uint segmentId = 0; segmentId < segmentCount; segmentId++)
        {
            GetQueryStatisticsSegment(out status, adapter, segmentId, out D3DKMT_QUERYSTATISTICS_SEGMENT_INFORMATION segmentInformation);
            if (status != NTSTATUS.STATUS_SUCCESS)
                return false;

            ulong bytesResident = segmentInformation.BytesResident;
            ulong bytesCommitted = segmentInformation.BytesCommitted;

            uint aperture = segmentInformation.Aperture;

            if (aperture == 1)
            {
                deviceInfo.GpuSharedUsed += bytesResident;
                deviceInfo.GpuSharedMax += bytesCommitted;
            }
            else
            {
                deviceInfo.GpuDedicatedUsed += bytesResident;
                deviceInfo.GpuDedicatedMax += bytesCommitted;
            }
        }

        CloseAdapter(out status, adapter);
        return status == NTSTATUS.STATUS_SUCCESS;
    }

    private static string GetNodeEngineTypeString(D3DKMT_NODEMETADATA nodeMetaData)
    {
        return nodeMetaData.NodeData.EngineType switch
        {
            DXGK_ENGINE_TYPE.DXGK_ENGINE_TYPE_OTHER => GetOtherName(),
            DXGK_ENGINE_TYPE.DXGK_ENGINE_TYPE_3D => "D3D 3D",
            DXGK_ENGINE_TYPE.DXGK_ENGINE_TYPE_VIDEO_DECODE => "D3D Video Decode",
            DXGK_ENGINE_TYPE.DXGK_ENGINE_TYPE_VIDEO_ENCODE => "D3D Video Encode",
            DXGK_ENGINE_TYPE.DXGK_ENGINE_TYPE_VIDEO_PROCESSING => "D3D Video Processing",
            DXGK_ENGINE_TYPE.DXGK_ENGINE_TYPE_SCENE_ASSEMBLY => "D3D Scene Assembly",
            DXGK_ENGINE_TYPE.DXGK_ENGINE_TYPE_COPY => "D3D Copy",
            DXGK_ENGINE_TYPE.DXGK_ENGINE_TYPE_OVERLAY => "D3D Overlay",
            DXGK_ENGINE_TYPE.DXGK_ENGINE_TYPE_CRYPTO => "D3D Crypto",
            _ => "D3D Unknown"
        };

        string GetOtherName()
        {
            string friendlyName = (nodeMetaData.NodeData.FriendlyName.Length > 0 ? nodeMetaData.NodeData.FriendlyName : "Other").ToString();

            if (friendlyName.StartsWith("JPEG_Decode_"))
                friendlyName = friendlyName.Replace("JPEG_Decode_", "JPEG Decode ");

            if (friendlyName.StartsWith("OFA_"))
                friendlyName = friendlyName.Replace("OFA_", "Optical Flow Accelerator ");

            return "D3D " + friendlyName;
        }
    }

    private static unsafe void GetSegmentSize
    (
        out NTSTATUS status,
        D3DKMT_OPENADAPTERFROMDEVICENAME adapter,
        out D3DKMT_SEGMENTSIZEINFO sizeInformation)
    {
        IntPtr segmentSizePtr = Marshal.AllocHGlobal(sizeof(D3DKMT_SEGMENTSIZEINFO));

        var queryAdapterInfo = new D3DKMT_QUERYADAPTERINFO
        {
            hAdapter = adapter.hAdapter,
            Type = KMTQUERYADAPTERINFOTYPE.KMTQAITYPE_GETSEGMENTSIZE,
            pPrivateDriverData = (void*)segmentSizePtr,
            PrivateDriverDataSize = (uint)sizeof(D3DKMT_SEGMENTSIZEINFO)
        };

        status = Windows.Wdk.PInvoke.D3DKMTQueryAdapterInfo(ref queryAdapterInfo);
        sizeInformation = *(D3DKMT_SEGMENTSIZEINFO*)segmentSizePtr;
        Marshal.FreeHGlobal(segmentSizePtr);
    }

    private static unsafe void GetNodeMetaData(out NTSTATUS status, D3DKMT_OPENADAPTERFROMDEVICENAME adapter, uint nodeId, out D3DKMT_NODEMETADATA nodeMetaDataResult)
    {
        IntPtr nodeMetaDataPtr = Marshal.AllocHGlobal(sizeof(D3DKMT_NODEMETADATA));

        D3DKMT_NODEMETADATA* pData = (D3DKMT_NODEMETADATA*)nodeMetaDataPtr;
        pData->NodeOrdinalAndAdapterIndex = nodeId;

        var queryAdapterInfo = new D3DKMT_QUERYADAPTERINFO
        {
            hAdapter = adapter.hAdapter,
            Type = KMTQUERYADAPTERINFOTYPE.KMTQAITYPE_NODEMETADATA,
            pPrivateDriverData = (void*)nodeMetaDataPtr,
            PrivateDriverDataSize = (uint)sizeof(D3DKMT_NODEMETADATA)
        };

        status = Windows.Wdk.PInvoke.D3DKMTQueryAdapterInfo(ref queryAdapterInfo);
        nodeMetaDataResult = *(D3DKMT_NODEMETADATA*)nodeMetaDataPtr;
        Marshal.FreeHGlobal(nodeMetaDataPtr);
    }

    private static void GetQueryStatisticsNode(out NTSTATUS status, D3DKMT_OPENADAPTERFROMDEVICENAME adapter, uint nodeId, out D3DKMT_QUERYSTATISTICS_NODE_INFORMATION nodeInformation)
    {
        var queryStatistics = new D3DKMT_QUERYSTATISTICS
        {
            AdapterLuid = adapter.AdapterLuid,
            Type = D3DKMT_QUERYSTATISTICS_TYPE.D3DKMT_QUERYSTATISTICS_NODE,
            Anonymous = new D3DKMT_QUERYSTATISTICS._Anonymous_e__Union { QueryNode = new D3DKMT_QUERYSTATISTICS_QUERY_NODE { NodeId = nodeId } }
        };

        status = Windows.Wdk.PInvoke.D3DKMTQueryStatistics(queryStatistics);
        nodeInformation = queryStatistics.QueryResult.NodeInformation;
    }

    private static void GetQueryStatisticsSegment
    (
        out NTSTATUS status,
        D3DKMT_OPENADAPTERFROMDEVICENAME adapter,
        uint segmentId,
        out D3DKMT_QUERYSTATISTICS_SEGMENT_INFORMATION segmentInformation)
    {
        var queryStatistics = new D3DKMT_QUERYSTATISTICS
        {
            AdapterLuid = adapter.AdapterLuid,
            Type = D3DKMT_QUERYSTATISTICS_TYPE.D3DKMT_QUERYSTATISTICS_SEGMENT,
            Anonymous = new D3DKMT_QUERYSTATISTICS._Anonymous_e__Union { QuerySegment = new D3DKMT_QUERYSTATISTICS_QUERY_SEGMENT { SegmentId = segmentId } }
        };

        status = Windows.Wdk.PInvoke.D3DKMTQueryStatistics(queryStatistics);
        segmentInformation = queryStatistics.QueryResult.SegmentInformation;
    }

    private static void GetQueryStatisticsAdapterInformation
    (
        out NTSTATUS status,
        D3DKMT_OPENADAPTERFROMDEVICENAME adapter,
        out D3DKMT_QUERYSTATISTICS_ADAPTER_INFORMATION adapterInformation)
    {
        var queryStatistics = new D3DKMT_QUERYSTATISTICS { AdapterLuid = adapter.AdapterLuid, Type = D3DKMT_QUERYSTATISTICS_TYPE.D3DKMT_QUERYSTATISTICS_ADAPTER };

        status = Windows.Wdk.PInvoke.D3DKMTQueryStatistics(queryStatistics);

        adapterInformation = queryStatistics.QueryResult.AdapterInformation;
    }

    private static unsafe void GetAdapterType(out NTSTATUS status, D3DKMT_OPENADAPTERFROMDEVICENAME adapter, out D3DKMT_ADAPTERTYPE adapterTypeResult)
    {
        IntPtr adapterTypePtr = Marshal.AllocHGlobal(sizeof(D3DKMT_ADAPTERTYPE));

        var queryAdapterInfo = new D3DKMT_QUERYADAPTERINFO
        {
            hAdapter = adapter.hAdapter, Type = KMTQUERYADAPTERINFOTYPE.KMTQAITYPE_ADAPTERTYPE, pPrivateDriverData = (void*)adapterTypePtr, PrivateDriverDataSize = (uint)sizeof(D3DKMT_ADAPTERTYPE)
        };

        status = Windows.Wdk.PInvoke.D3DKMTQueryAdapterInfo(ref queryAdapterInfo);
        adapterTypeResult = *(D3DKMT_ADAPTERTYPE*)adapterTypePtr;
        Marshal.FreeHGlobal(adapterTypePtr);
    }

    private static unsafe void OpenAdapterFromDeviceName(out NTSTATUS status, string displayDeviceName, out D3DKMT_OPENADAPTERFROMDEVICENAME adapter)
    {
        fixed (char* pDisplayDeviceName = displayDeviceName)
        {
            adapter = new D3DKMT_OPENADAPTERFROMDEVICENAME { pDeviceName = new PCWSTR(pDisplayDeviceName) };
            status = Windows.Wdk.PInvoke.D3DKMTOpenAdapterFromDeviceName(ref adapter);
        }
    }

    private static void CloseAdapter(out NTSTATUS status, D3DKMT_OPENADAPTERFROMDEVICENAME adapter)
    {
        var closeAdapter = new D3DKMT_CLOSEADAPTER { hAdapter = adapter.hAdapter };
        status = Windows.Wdk.PInvoke.D3DKMTCloseAdapter(closeAdapter);
    }

    public struct D3DDeviceNodeInfo
    {
        public ulong Id;
        public string Name;
        public long RunningTime;
        public DateTime QueryTime;
    }

    public struct D3DDeviceInfo
    {
        public ulong GpuSharedLimit;
        public ulong GpuDedicatedLimit;
        public ulong GpuVideoMemoryLimit;

        public ulong GpuSharedUsed;
        public ulong GpuDedicatedUsed;

        public ulong GpuSharedMax;
        public ulong GpuDedicatedMax;

        public D3DDeviceNodeInfo[] Nodes;
        public bool Integrated;
    }
}

```

`LibreHardwareMonitorLib/Hardware/FirmwareTable.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Runtime.InteropServices;
using System.Text;
using Windows.Win32;
using Windows.Win32.System.SystemInformation;

namespace LibreHardwareMonitor.Hardware;

internal static class FirmwareTable
{
    public static byte[] GetTable(FIRMWARE_TABLE_PROVIDER provider, string table)
    {
        uint id = (uint)((table[3] << 24) | (table[2] << 16) | (table[1] << 8) | table[0]);
        return GetTable(provider, id);
    }

    public static byte[] GetTable(FIRMWARE_TABLE_PROVIDER provider, uint table)
    {
        uint size;

        try
        {
            size = PInvoke.GetSystemFirmwareTable(provider, table, null);
        }
        catch (Exception e) when (e is DllNotFoundException or EntryPointNotFoundException)
        {
            return null;
        }

        if (size <= 0)
            return null;

        byte[] buffer = new byte[size];

        PInvoke.GetSystemFirmwareTable(provider, table, buffer.AsSpan());
        if (Marshal.GetLastWin32Error() != 0)
            return null;

        return buffer;
    }

    public static unsafe string[] EnumerateTables(FIRMWARE_TABLE_PROVIDER provider)
    {
        uint size;

        try
        {
            size = PInvoke.EnumSystemFirmwareTables(provider, (byte*)IntPtr.Zero, 0);
        }
        catch (Exception e) when (e is DllNotFoundException or EntryPointNotFoundException)
        {
            return null;
        }

        byte[] buffer = new byte[size];
        PInvoke.EnumSystemFirmwareTables(provider, buffer.AsSpan());

        string[] result = new string[size / 4];

        for (int i = 0; i < result.Length; i++)
            result[i] = Encoding.ASCII.GetString(buffer, 4 * i, 4);

        return result;
    }
}

```

`LibreHardwareMonitorLib/Hardware/Gpu/AmdGpu.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Globalization;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using LibreHardwareMonitor.Interop;

namespace LibreHardwareMonitor.Hardware.Gpu;

internal sealed class AmdGpu : GenericGpu
{
    private readonly AtiAdlxx.ADLAdapterInfo _adapterInfo;
    private readonly AtiAdlxx.ADLPMLogStartOutput _adlPMLogStartOutput;
    private readonly AtiAdlxx.ADLPMLogSupportInfo _adlPMLogSupportInfo;
    private readonly AtiAdlxx.ADLGcnInfo _adlGcnInfo;
    private readonly IntPtr _context = IntPtr.Zero;
    private readonly Sensor _controlSensor;
    private readonly Sensor _coreClock;
    private readonly Sensor _coreLoad;
    private readonly Sensor _coreVoltage;
    private readonly int _currentOverdriveApiLevel;
    private readonly string _d3dDeviceId;
    private readonly uint _device;
    private readonly Sensor _fan;
    private readonly Control _fanControl;
    private readonly bool _frameMetricsStarted;
    private readonly Sensor _fullscreenFps;
    private readonly Sensor _gpuDedicatedMemoryUsage;
    private readonly Sensor _gpuDedicatedMemoryFree;
    private readonly Sensor _gpuDedicatedMemoryTotal;
    private readonly Sensor[] _gpuNodeUsage;
    private readonly DateTime[] _gpuNodeUsagePrevTick;
    private readonly long[] _gpuNodeUsagePrevValue;
    private readonly Sensor _gpuSharedMemoryUsage;
    private readonly Sensor _gpuSharedMemoryFree;
    private readonly Sensor _gpuSharedMemoryTotal;
    private readonly Sensor _memoryClock;
    private readonly Sensor _memoryLoad;
    private readonly Sensor _memoryVoltage;
    private readonly Sensor _memoryTotal;
    private readonly Sensor _memoryUsed;
    private readonly Sensor _memoryFree;
    private readonly bool _overdriveApiSupported;
    private readonly bool _pmLogStarted;
    private readonly Sensor _powerCore;
    private readonly Sensor _powerPpt;
    private readonly Sensor _powerSoC;
    private readonly Sensor _powerTotal;
    private readonly Sensor _socClock;
    private readonly Sensor _socVoltage;
    private readonly Sensor _temperatureCore;
    private readonly Sensor _temperatureHotSpot;
    private readonly Sensor _temperatureLiquid;
    private readonly Sensor _temperatureMemory;
    private readonly Sensor _temperatureMvdd;
    private readonly Sensor _temperaturePlx;
    private readonly Sensor _temperatureSoC;
    private readonly Sensor _temperatureVddc;
    private readonly ushort _pmLogSampleRate = 1000;
    private bool _overdrive8LogExists;

    public AmdGpu(IntPtr amdContext, AtiAdlxx.ADLAdapterInfo adapterInfo, AtiAdlxx.ADLGcnInfo gcnInfo, ISettings settings)
        : base(adapterInfo.AdapterName.Trim(), new Identifier("gpu-amd", adapterInfo.AdapterIndex.ToString(CultureInfo.InvariantCulture)), settings)
    {
        _context = amdContext;
        _adlGcnInfo = gcnInfo;
        _adapterInfo = adapterInfo;
        BusNumber = adapterInfo.BusNumber;
        DeviceNumber = adapterInfo.DeviceNumber;

        _temperatureCore = new Sensor("GPU Core", 0, SensorType.Temperature, this, settings);
        _temperatureMemory = new Sensor("GPU Memory", 1, SensorType.Temperature, this, settings);
        _temperatureVddc = new Sensor("GPU VR VDDC", 2, SensorType.Temperature, this, settings);
        _temperatureMvdd = new Sensor("GPU VR MVDD", 3, SensorType.Temperature, this, settings);
        _temperatureSoC = new Sensor("GPU VR SoC", 4, SensorType.Temperature, this, settings);
        _temperatureLiquid = new Sensor("GPU Liquid", 5, SensorType.Temperature, this, settings);
        _temperaturePlx = new Sensor("GPU PLX", 6, SensorType.Temperature, this, settings);
        _temperatureHotSpot = new Sensor("GPU Hot Spot", 7, SensorType.Temperature, this, settings);

        _coreClock = new Sensor("GPU Core", 0, SensorType.Clock, this, settings);
        _socClock = new Sensor("GPU SoC", 1, SensorType.Clock, this, settings);
        _memoryClock = new Sensor("GPU Memory", 2, SensorType.Clock, this, settings);

        _fan = new Sensor("GPU Fan", 0, SensorType.Fan, this, settings);

        _coreVoltage = new Sensor("GPU Core", 0, SensorType.Voltage, this, settings);
        _memoryVoltage = new Sensor("GPU Memory", 1, SensorType.Voltage, this, settings);
        _socVoltage = new Sensor("GPU SoC", 2, SensorType.Voltage, this, settings);

        _coreLoad = new Sensor("GPU Core", 0, SensorType.Load, this, settings);
        _memoryLoad = new Sensor("GPU Memory", 1, SensorType.Load, this, settings);

        _controlSensor = new Sensor("GPU Fan", 0, SensorType.Control, this, settings);

        _powerCore = new Sensor("GPU Core", 0, SensorType.Power, this, settings);
        _powerPpt = new Sensor("GPU PPT", 1, SensorType.Power, this, settings);
        _powerSoC = new Sensor("GPU SoC", 2, SensorType.Power, this, settings);
        _powerTotal = new Sensor("GPU Package", 3, SensorType.Power, this, settings);

        _fullscreenFps = new Sensor("Fullscreen FPS", 0, SensorType.Factor, this, settings);

        _memoryUsed = new Sensor("GPU Memory Used", 0, SensorType.SmallData, this, settings);
        _memoryFree = new Sensor("GPU Memory Free", 1, SensorType.SmallData, this, settings);
        _memoryTotal = new Sensor("GPU Memory Total", 2, SensorType.SmallData, this, settings);

        if (!Software.OperatingSystem.IsUnix)
        {
            string[] deviceIds = D3DDisplayDevice.GetDeviceIdentifiers();
            if (deviceIds != null)
            {
                foreach (string deviceId in deviceIds)
                {
                    string actualDeviceId = D3DDisplayDevice.GetActualDeviceIdentifier(deviceId);

                    if ((actualDeviceId.IndexOf(adapterInfo.PNPString, StringComparison.OrdinalIgnoreCase) != -1 ||
                         adapterInfo.PNPString.IndexOf(actualDeviceId, StringComparison.OrdinalIgnoreCase) != -1) &&
                        D3DDisplayDevice.GetDeviceInfoByIdentifier(deviceId, out D3DDisplayDevice.D3DDeviceInfo deviceInfo))
                    {
                        _d3dDeviceId = deviceId;

                        int nodeSensorIndex = 2;
                        int memorySensorIndex = 3;

                        _gpuDedicatedMemoryUsage = new Sensor("D3D Dedicated Memory Used", memorySensorIndex++, SensorType.SmallData, this, settings);
                        _gpuDedicatedMemoryFree = new Sensor("D3D Dedicated Memory Free", memorySensorIndex++, SensorType.SmallData, this, settings);
                        _gpuDedicatedMemoryTotal = new Sensor("D3D Dedicated Memory Total", memorySensorIndex++, SensorType.SmallData, this, settings);
                        _gpuSharedMemoryUsage = new Sensor("D3D Shared Memory Used", memorySensorIndex++, SensorType.SmallData, this, settings);
                        _gpuSharedMemoryFree = new Sensor("D3D Shared Memory Free", memorySensorIndex++, SensorType.SmallData, this, settings);
                        _gpuSharedMemoryTotal = new Sensor("D3D Shared Memory Total", memorySensorIndex++, SensorType.SmallData, this, settings);

                        _gpuNodeUsage = new Sensor[deviceInfo.Nodes.Length];
                        _gpuNodeUsagePrevValue = new long[deviceInfo.Nodes.Length];
                        _gpuNodeUsagePrevTick = new DateTime[deviceInfo.Nodes.Length];

                        foreach (D3DDisplayDevice.D3DDeviceNodeInfo node in deviceInfo.Nodes.OrderBy(x => x.Name))
                        {
                            _gpuNodeUsage[node.Id] = new Sensor(node.Name, nodeSensorIndex++, SensorType.Load, this, settings);
                            _gpuNodeUsagePrevValue[node.Id] = node.RunningTime;
                            _gpuNodeUsagePrevTick[node.Id] = node.QueryTime;
                        }

                        break;
                    }
                }
            }
        }

        AtiAdlxx.ADLMemoryInfoX4 memoryInfo = new();
        if (AtiAdlxx.ADL_Method_Exists(nameof(AtiAdlxx.ADL2_Adapter_MemoryInfoX4_Get)) &&
            AtiAdlxx.ADL2_Adapter_MemoryInfoX4_Get(_context, _adapterInfo.AdapterIndex, out memoryInfo) == AtiAdlxx.ADLStatus.ADL_OK)
        {
            _memoryTotal.Value = memoryInfo.iMemorySize / 1024 / 1024;
            ActivateSensor(_memoryTotal);
        }

        int supported = 0;
        int enabled = 0;
        int version = 0;

        if (AtiAdlxx.ADL_Method_Exists(nameof(AtiAdlxx.ADL2_Adapter_FrameMetrics_Caps)) &&
            AtiAdlxx.ADL2_Adapter_FrameMetrics_Caps(_context, _adapterInfo.AdapterIndex, ref supported) == AtiAdlxx.ADLStatus.ADL_OK &&
            supported == AtiAdlxx.ADL_TRUE &&
            AtiAdlxx.ADL2_Adapter_FrameMetrics_Start(_context, _adapterInfo.AdapterIndex, 0) == AtiAdlxx.ADLStatus.ADL_OK)
        {
            _frameMetricsStarted = true;
            _fullscreenFps.Value = -1;
            ActivateSensor(_fullscreenFps);
        }

        if (AtiAdlxx.UsePmLogForFamily(_adlGcnInfo.ASICFamilyId) &&
            AtiAdlxx.ADL_Method_Exists(nameof(AtiAdlxx.ADL2_Adapter_PMLog_Support_Get)) &&
            AtiAdlxx.ADL_Method_Exists(nameof(AtiAdlxx.ADL2_Device_PMLog_Device_Create)) &&
            AtiAdlxx.ADL_Method_Exists(nameof(AtiAdlxx.ADL2_Adapter_PMLog_Start)))
        {
            AtiAdlxx.ADLPMLogStartInput _adlPMLogStartInput = new();
            _adlPMLogSupportInfo = new();
            _adlPMLogStartOutput = new AtiAdlxx.ADLPMLogStartOutput();
            _adlPMLogStartInput.usSensors = new ushort[AtiAdlxx.ADL_PMLOG_MAX_SENSORS];

            if (_device == 0 &&
                AtiAdlxx.ADLStatus.ADL_OK == AtiAdlxx.ADL2_Device_PMLog_Device_Create(_context, _adapterInfo.AdapterIndex, ref _device) &&
                AtiAdlxx.ADLStatus.ADL_OK == AtiAdlxx.ADL2_Adapter_PMLog_Support_Get(_context, _adapterInfo.AdapterIndex, ref _adlPMLogSupportInfo))
            {
                int i = 0;
                while (_adlPMLogSupportInfo.usSensors[i] != (ushort)AtiAdlxx.ADLPMLogSensors.ADL_SENSOR_MAXTYPES)
                {
                    _adlPMLogStartInput.usSensors[i] = _adlPMLogSupportInfo.usSensors[i];
                    i++;
                }

                _adlPMLogStartInput.usSensors[i] = (ushort)AtiAdlxx.ADLPMLogSensors.ADL_SENSOR_MAXTYPES;
                _adlPMLogStartInput.ulSampleRate = _pmLogSampleRate;

                if (AtiAdlxx.ADL2_Adapter_PMLog_Start(_context,
                                                      adapterInfo.AdapterIndex,
                                                      ref _adlPMLogStartInput,
                                                      ref _adlPMLogStartOutput,
                                                      _device) == AtiAdlxx.ADLStatus.ADL_OK)
                {
                    _pmLogStarted = true;
                }
            }
        }

        if (AtiAdlxx.ADL_Method_Exists(nameof(AtiAdlxx.ADL2_Overdrive_Caps)) &&
            AtiAdlxx.ADL2_Overdrive_Caps(_context, _adapterInfo.AdapterIndex, ref supported, ref enabled, ref version) == AtiAdlxx.ADLStatus.ADL_OK)
        {
            _overdriveApiSupported = supported == AtiAdlxx.ADL_TRUE;
            _currentOverdriveApiLevel = version;
        }
        else
        {
            if (AtiAdlxx.ADL_Method_Exists(nameof(AtiAdlxx.ADL2_Overdrive6_Capabilities_Get)))
            {
                AtiAdlxx.ADLOD6Capabilities capabilities = new();
                if (AtiAdlxx.ADL2_Overdrive6_Capabilities_Get(_context, _adapterInfo.AdapterIndex, ref capabilities) == AtiAdlxx.ADLStatus.ADL_OK && capabilities.iCapabilities > 0)
                {
                    _overdriveApiSupported = true;
                    _currentOverdriveApiLevel = 6;
                }
            }

            if (!_overdriveApiSupported)
            {
                if (AtiAdlxx.ADL_Method_Exists(nameof(AtiAdlxx.ADL2_Overdrive5_ODParameters_Get)) &&
                    AtiAdlxx.ADL2_Overdrive5_ODParameters_Get(_context, _adapterInfo.AdapterIndex, out AtiAdlxx.ADLODParameters p) == AtiAdlxx.ADLStatus.ADL_OK &&
                    p.iActivityReportingSupported > 0)
                {
                    _overdriveApiSupported = true;
                    _currentOverdriveApiLevel = 5;
                }
                else
                {
                    _currentOverdriveApiLevel = -1;
                }
            }
        }

        AtiAdlxx.ADLFanSpeedInfo fanSpeedInfo = new();
        if (AtiAdlxx.ADL2_Overdrive5_FanSpeedInfo_Get(_context, _adapterInfo.AdapterIndex, 0, ref fanSpeedInfo) != AtiAdlxx.ADLStatus.ADL_OK)
        {
            fanSpeedInfo.iMaxPercent = 100;
            fanSpeedInfo.iMinPercent = 0;
        }

        _fanControl = new Control(_controlSensor, settings, fanSpeedInfo.iMinPercent, fanSpeedInfo.iMaxPercent);
        _fanControl.ControlModeChanged += ControlModeChanged;
        _fanControl.SoftwareControlValueChanged += SoftwareControlValueChanged;
        ControlModeChanged(_fanControl);
        _controlSensor.Control = _fanControl;

        Update();
    }

    public int BusNumber { get; }

    /// <inheritdoc />
    public override string DeviceId => _adapterInfo.PNPString;

    public int DeviceNumber { get; }

    public override HardwareType HardwareType
    {
        get { return HardwareType.GpuAmd; }
    }

    private void SoftwareControlValueChanged(IControl control)
    {
        if (control.ControlMode == ControlMode.Software)
        {
            AtiAdlxx.ADLFanSpeedValue fanSpeedValue = new()
            {
                iSpeedType = AtiAdlxx.ADL_DL_FANCTRL_SPEED_TYPE_PERCENT,
                iFlags = AtiAdlxx.ADL_DL_FANCTRL_FLAG_USER_DEFINED_SPEED,
                iFanSpeed = (int)control.SoftwareValue
            };

            AtiAdlxx.ADL2_Overdrive5_FanSpeed_Set(_context, _adapterInfo.AdapterIndex, 0, ref fanSpeedValue);
        }
    }

    private void ControlModeChanged(IControl control)
    {
        switch (control.ControlMode)
        {
            case ControlMode.Undefined:
                return;
            case ControlMode.Default:
                SetDefaultFanSpeed();
                break;
            case ControlMode.Software:
                SoftwareControlValueChanged(control);
                break;
            default:
                return;
        }
    }

    /// <summary>
    /// Sets the default fan speed.
    /// </summary>
    private void SetDefaultFanSpeed()
    {
        AtiAdlxx.ADL2_Overdrive5_FanSpeedToDefault_Set(_context, _adapterInfo.AdapterIndex, 0);
    }

    public override void Update()
    {
        if (_d3dDeviceId != null && D3DDisplayDevice.GetDeviceInfoByIdentifier(_d3dDeviceId, out D3DDisplayDevice.D3DDeviceInfo deviceInfo))
        {
            _gpuDedicatedMemoryTotal.Value = 1f * deviceInfo.GpuVideoMemoryLimit / 1024 / 1024;
            _gpuDedicatedMemoryUsage.Value = 1f * deviceInfo.GpuDedicatedUsed / 1024 / 1024;
            _gpuDedicatedMemoryFree.Value = _gpuDedicatedMemoryTotal.Value - _gpuDedicatedMemoryUsage.Value;
            _gpuSharedMemoryUsage.Value = 1f * deviceInfo.GpuSharedUsed / 1024 / 1024;
            _gpuSharedMemoryTotal.Value = 1f * deviceInfo.GpuSharedLimit / 1024 / 1024;
            _gpuSharedMemoryFree.Value = _gpuSharedMemoryTotal.Value - _gpuSharedMemoryUsage.Value;
            ActivateSensor(_gpuDedicatedMemoryTotal);
            ActivateSensor(_gpuDedicatedMemoryFree);
            ActivateSensor(_gpuDedicatedMemoryUsage);
            ActivateSensor(_gpuSharedMemoryUsage);
            ActivateSensor(_gpuSharedMemoryFree);
            ActivateSensor(_gpuSharedMemoryTotal);

            foreach (D3DDisplayDevice.D3DDeviceNodeInfo node in deviceInfo.Nodes)
            {
                long runningTimeDiff = node.RunningTime - _gpuNodeUsagePrevValue[node.Id];
                long timeDiff = node.QueryTime.Ticks - _gpuNodeUsagePrevTick[node.Id].Ticks;

                _gpuNodeUsage[node.Id].Value = 100f * runningTimeDiff / timeDiff;
                _gpuNodeUsagePrevValue[node.Id] = node.RunningTime;
                _gpuNodeUsagePrevTick[node.Id] = node.QueryTime;
                ActivateSensor(_gpuNodeUsage[node.Id]);
            }
        }

        int vramUsed = 0;
        if (AtiAdlxx.ADL_Method_Exists(nameof(AtiAdlxx.ADL2_Adapter_DedicatedVRAMUsage_Get)) &&
            AtiAdlxx.ADL2_Adapter_DedicatedVRAMUsage_Get(_context, _adapterInfo.AdapterIndex, out vramUsed) == AtiAdlxx.ADLStatus.ADL_OK)
        {
            _memoryUsed.Value = vramUsed;
            ActivateSensor(_memoryUsed);
        }

        if (_memoryTotal.Value > 0)
        {
            _memoryFree.Value = _memoryTotal.Value - _memoryUsed.Value;
            ActivateSensor(_memoryFree);
        }

        if (_frameMetricsStarted)
        {
            float framesPerSecond = 0;
            if (AtiAdlxx.ADL2_Adapter_FrameMetrics_Get(_context, _adapterInfo.AdapterIndex, 0, ref framesPerSecond) == AtiAdlxx.ADLStatus.ADL_OK)
            {
                _fullscreenFps.Value = framesPerSecond;
            }
        }

        if (_overdriveApiSupported)
        {
            GetOD5Temperature(_temperatureCore);
            GetOD5FanSpeed(AtiAdlxx.ADL_DL_FANCTRL_SPEED_TYPE_RPM, _fan);
            GetOD5FanSpeed(AtiAdlxx.ADL_DL_FANCTRL_SPEED_TYPE_PERCENT, _controlSensor);
            GetOD5CurrentActivity();

            if (_currentOverdriveApiLevel >= 6)
            {
                GetOD6Power(AtiAdlxx.ADLODNCurrentPowerType.ODN_GPU_TOTAL_POWER, _powerTotal);
                GetOD6Power(AtiAdlxx.ADLODNCurrentPowerType.ODN_GPU_PPT_POWER, _powerPpt);
                GetOD6Power(AtiAdlxx.ADLODNCurrentPowerType.ODN_GPU_SOCKET_POWER, _powerSoC);
                GetOD6Power(AtiAdlxx.ADLODNCurrentPowerType.ODN_GPU_CHIP_POWER, _powerCore);
            }

            if (_currentOverdriveApiLevel >= 7)
            {
                GetODNTemperature(AtiAdlxx.ADLODNTemperatureType.EDGE, _temperatureCore, -256, 0.001, false);
                GetODNTemperature(AtiAdlxx.ADLODNTemperatureType.MEM, _temperatureMemory);
                GetODNTemperature(AtiAdlxx.ADLODNTemperatureType.VRVDDC, _temperatureVddc);
                GetODNTemperature(AtiAdlxx.ADLODNTemperatureType.VRMVDD, _temperatureMvdd);
                GetODNTemperature(AtiAdlxx.ADLODNTemperatureType.LIQUID, _temperatureLiquid);
                GetODNTemperature(AtiAdlxx.ADLODNTemperatureType.PLX, _temperaturePlx);
                GetODNTemperature(AtiAdlxx.ADLODNTemperatureType.HOTSPOT, _temperatureHotSpot);
            }
        }

        if (_currentOverdriveApiLevel >= 8 || !_overdriveApiSupported)
        {
            _overdrive8LogExists = false;
            AtiAdlxx.ADLPMLogDataOutput logDataOutput = new();
            if (AtiAdlxx.ADL_Method_Exists(nameof(AtiAdlxx.ADL2_New_QueryPMLogData_Get)) &&
                AtiAdlxx.ADL2_New_QueryPMLogData_Get(_context, _adapterInfo.AdapterIndex, ref logDataOutput) == AtiAdlxx.ADLStatus.ADL_OK)
            {
                _overdrive8LogExists = true;
            }

            AtiAdlxx.ADLPMLogData adlPMLogData = new();
            if (_pmLogStarted)
            {
                adlPMLogData = (AtiAdlxx.ADLPMLogData)Marshal.PtrToStructure(_adlPMLogStartOutput.pLoggingAddress, typeof(AtiAdlxx.ADLPMLogData));
            }

            GetAdlSensor(adlPMLogData, logDataOutput, AtiAdlxx.ADLPMLogSensors.ADL_PMLOG_CLK_GFXCLK, _coreClock, reset: false);
            GetAdlSensor(adlPMLogData, logDataOutput, AtiAdlxx.ADLPMLogSensors.ADL_PMLOG_CLK_SOCCLK, _socClock);
            GetAdlSensor(adlPMLogData, logDataOutput, AtiAdlxx.ADLPMLogSensors.ADL_PMLOG_CLK_MEMCLK, _memoryClock, reset: false);

            GetAdlSensor(adlPMLogData, logDataOutput, AtiAdlxx.ADLPMLogSensors.ADL_PMLOG_TEMPERATURE_EDGE, _temperatureCore, reset: false);
            GetAdlSensor(adlPMLogData, logDataOutput, AtiAdlxx.ADLPMLogSensors.ADL_PMLOG_TEMPERATURE_MEM, _temperatureMemory, reset: false);
            GetAdlSensor(adlPMLogData, logDataOutput, AtiAdlxx.ADLPMLogSensors.ADL_PMLOG_TEMPERATURE_VRVDDC, _temperatureVddc, reset: false);
            GetAdlSensor(adlPMLogData, logDataOutput, AtiAdlxx.ADLPMLogSensors.ADL_PMLOG_TEMPERATURE_VRMVDD, _temperatureMvdd, reset: false);
            GetAdlSensor(adlPMLogData, logDataOutput, AtiAdlxx.ADLPMLogSensors.ADL_PMLOG_TEMPERATURE_LIQUID, _temperatureLiquid, reset: false);
            GetAdlSensor(adlPMLogData, logDataOutput, AtiAdlxx.ADLPMLogSensors.ADL_PMLOG_TEMPERATURE_PLX, _temperaturePlx, reset: false);
            GetAdlSensor(adlPMLogData, logDataOutput, AtiAdlxx.ADLPMLogSensors.ADL_PMLOG_TEMPERATURE_HOTSPOT, _temperatureHotSpot, reset: false);
            GetAdlSensor(adlPMLogData, logDataOutput, AtiAdlxx.ADLPMLogSensors.ADL_PMLOG_TEMPERATURE_SOC, _temperatureSoC);


            GetAdlSensor(adlPMLogData, logDataOutput, AtiAdlxx.ADLPMLogSensors.ADL_PMLOG_FAN_RPM, _fan, reset: false);
            GetAdlSensor(adlPMLogData, logDataOutput, AtiAdlxx.ADLPMLogSensors.ADL_PMLOG_FAN_PERCENTAGE, _controlSensor, reset: false);

            GetAdlSensor(adlPMLogData, logDataOutput, AtiAdlxx.ADLPMLogSensors.ADL_PMLOG_GFX_VOLTAGE, _coreVoltage, 0.001f, false);
            GetAdlSensor(adlPMLogData, logDataOutput, AtiAdlxx.ADLPMLogSensors.ADL_PMLOG_SOC_VOLTAGE, _socVoltage, 0.001f);
            GetAdlSensor(adlPMLogData, logDataOutput, AtiAdlxx.ADLPMLogSensors.ADL_PMLOG_MEM_VOLTAGE, _memoryVoltage, 0.001f);

            GetAdlSensor(adlPMLogData, logDataOutput, AtiAdlxx.ADLPMLogSensors.ADL_PMLOG_INFO_ACTIVITY_GFX, _coreLoad, reset: false);
            GetAdlSensor(adlPMLogData, logDataOutput, AtiAdlxx.ADLPMLogSensors.ADL_PMLOG_INFO_ACTIVITY_MEM, _memoryLoad);

            if (_adlGcnInfo.ASICFamilyId >= (int)AtiAdlxx.GCNFamilies.FAMILY_NV3 || !GetAdlSensor(adlPMLogData, logDataOutput, AtiAdlxx.ADLPMLogSensors.ADL_PMLOG_ASIC_POWER, _powerTotal, reset: false))
            {
                GetAdlSensor(adlPMLogData, logDataOutput, AtiAdlxx.ADLPMLogSensors.ADL_PMLOG_BOARD_POWER, _powerTotal, reset: false);
            }

            GetAdlSensor(adlPMLogData, logDataOutput, AtiAdlxx.ADLPMLogSensors.ADL_PMLOG_GFX_POWER, _powerCore, reset: false);
            GetAdlSensor(adlPMLogData, logDataOutput, AtiAdlxx.ADLPMLogSensors.ADL_PMLOG_SOC_POWER, _powerSoC, reset: false);
        }
    }

    private bool IsSensorSupportedByPMLog(AtiAdlxx.ADLPMLogSensors sensorType)
    {
        if (!_pmLogStarted || (int)sensorType == 0)
            return false;

        for (int i = 0; i < AtiAdlxx.ADL_PMLOG_MAX_SENSORS; i++)
        {
            if (_adlPMLogSupportInfo.usSensors[i] == (int)sensorType)
            {
                return true;
            }
        }

        return false;
    }

    /// <summary>
    /// Gets a sensor value.
    /// </summary>
    ///
    /// <param name="adlPMLogData">Current pmlog struct, used with pmlog-support/start.</param>
    /// <param name="od8Log">Legacy pmlogdataoutput struct, used with ADL2_New_QueryPMLogData_Get.</param>
    /// <param name="sensorType">Type of the sensor.</param>
    /// <param name="sensor">The sensor.</param>
    /// <param name="factor">The factor.</param>
    /// <param name="reset">If set to <c>true</c>, resets the sensor value to <c>null</c>.</param>
    /// <returns>true if sensor is supported, false otherwise</returns>
    private bool GetAdlSensor(AtiAdlxx.ADLPMLogData adlPMLogData, AtiAdlxx.ADLPMLogDataOutput od8Log,
                              AtiAdlxx.ADLPMLogSensors sensorType, Sensor sensor, float factor = 1.0f, bool reset = true)
    {
        int i = (int)sensorType;
        bool supportedByPMLog = IsSensorSupportedByPMLog(sensorType);
        bool supportedByOD8 = _overdrive8LogExists && i < od8Log.sensors.Length && od8Log.sensors[i].supported != 0;

        if (!supportedByPMLog && !supportedByOD8)
        {
            if (reset)
                sensor.Value = null;

            return false;
        }

        if (_pmLogStarted)
        {
            //check if ulLastUpdated is a valid number, avoid timezone issues with unspecified kind and 48h offset
            DateTime now = new(DateTime.Now.Ticks, DateTimeKind.Unspecified);
            if (adlPMLogData.ulLastUpdated == 0 ||
                adlPMLogData.ulActiveSampleRate < 0 ||
                adlPMLogData.ulActiveSampleRate > 86400000 ||
                now.AddHours(48).ToFileTime() < (long)adlPMLogData.ulLastUpdated ||
                now.AddHours(-48).ToFileTime() > (long)adlPMLogData.ulLastUpdated)
            {
                supportedByPMLog = false;
            }
        }

        if (supportedByPMLog)
        {
            bool found = false;

            if (adlPMLogData.ulValues != null)
            {
                for (int k = 0; k < adlPMLogData.ulValues.Length - 1; k += 2)
                {
                    if (adlPMLogData.ulValues[k] == (ushort)AtiAdlxx.ADLPMLogSensors.ADL_SENSOR_MAXTYPES)
                        break;

                    if (adlPMLogData.ulValues[k] == i)
                    {
                        sensor.Value = adlPMLogData.ulValues[k + 1] * factor;
                        ActivateSensor(sensor);
                        found = true;
                    }
                }
            }

            if (!found && reset)
            {
                sensor.Value = null;
            }
        }
        else if (_overdrive8LogExists)
        {
            if (supportedByOD8)
            {
                sensor.Value = od8Log.sensors[i].value * factor;
                ActivateSensor(sensor);
            }
            else if (reset)
            {
                sensor.Value = null;
            }
        }
        return true;
    }

    private void GetOD5CurrentActivity()
    {
        AtiAdlxx.ADLPMActivity adlpmActivity = new();
        if (AtiAdlxx.ADL2_Overdrive5_CurrentActivity_Get(_context, _adapterInfo.AdapterIndex, ref adlpmActivity) == AtiAdlxx.ADLStatus.ADL_OK)
        {
            if (adlpmActivity.iEngineClock > 0)
            {
                _coreClock.Value = 0.01f * adlpmActivity.iEngineClock;
                ActivateSensor(_coreClock);
            }
            else
            {
                _coreClock.Value = null;
            }

            if (adlpmActivity.iMemoryClock > 0)
            {
                _memoryClock.Value = 0.01f * adlpmActivity.iMemoryClock;
                ActivateSensor(_memoryClock);
            }
            else
            {
                _memoryClock.Value = null;
            }

            if (adlpmActivity.iVddc > 0)
            {
                _coreVoltage.Value = 0.001f * adlpmActivity.iVddc;
                ActivateSensor(_coreVoltage);
            }
            else
            {
                _coreVoltage.Value = null;
            }

            _coreLoad.Value = Math.Min(adlpmActivity.iActivityPercent, 100);
            ActivateSensor(_coreLoad);
        }
        else
        {
            _coreClock.Value = null;
            _memoryClock.Value = null;
            _coreVoltage.Value = null;
            _coreLoad.Value = null;
        }
    }

    private void GetOD5FanSpeed(int speedType, Sensor sensor)
    {
        AtiAdlxx.ADLFanSpeedValue fanSpeedValue = new() { iSpeedType = speedType };
        if (AtiAdlxx.ADL2_Overdrive5_FanSpeed_Get(_context, _adapterInfo.AdapterIndex, 0, ref fanSpeedValue) == AtiAdlxx.ADLStatus.ADL_OK)
        {
            sensor.Value = fanSpeedValue.iFanSpeed;
            ActivateSensor(sensor);
        }
        else
        {
            sensor.Value = null;
        }
    }

    private void GetOD5Temperature(Sensor temperatureCore)
    {
        AtiAdlxx.ADLTemperature temperature = new();
        if (AtiAdlxx.ADL2_Overdrive5_Temperature_Get(_context, _adapterInfo.AdapterIndex, 0, ref temperature) == AtiAdlxx.ADLStatus.ADL_OK)
        {
            temperatureCore.Value = 0.001f * temperature.iTemperature;
            ActivateSensor(temperatureCore);
        }
        else
        {
            temperatureCore.Value = null;
        }
    }

    /// <summary>
    /// Gets the OverdriveN temperature.
    /// </summary>
    /// <param name="type">The type.</param>
    /// <param name="sensor">The sensor.</param>
    /// <param name="minTemperature">The minimum temperature.</param>
    /// <param name="scale">The scale.</param>
    /// <param name="reset">If set to <c>true</c>, resets the sensor value to <c>null</c>.</param>
    private void GetODNTemperature(AtiAdlxx.ADLODNTemperatureType type, Sensor sensor, double minTemperature = -256, double scale = 1, bool reset = true)
    {
        // If a sensor isn't available, some cards report 54000 degrees C.
        // 110C is expected for Navi, so 256C should be enough to use as a maximum.

        int maxTemperature = (int)(256 / scale);
        minTemperature = (int)(minTemperature / scale);

        int temperature = 0;
        if (AtiAdlxx.ADL2_OverdriveN_Temperature_Get(_context, _adapterInfo.AdapterIndex, type, ref temperature) == AtiAdlxx.ADLStatus.ADL_OK &&
            temperature >= minTemperature &&
            temperature <= maxTemperature)
        {
            sensor.Value = (float)(scale * temperature);
            ActivateSensor(sensor);
        }
        else if (reset)
        {
            sensor.Value = null;
        }
    }

    /// <summary>
    /// Gets the Overdrive6 power.
    /// </summary>
    /// <param name="type">The type.</param>
    /// <param name="sensor">The sensor.</param>
    private void GetOD6Power(AtiAdlxx.ADLODNCurrentPowerType type, Sensor sensor)
    {
        int powerOf8 = 0;
        if (AtiAdlxx.ADL2_Overdrive6_CurrentPower_Get(_context, _adapterInfo.AdapterIndex, type, ref powerOf8) == AtiAdlxx.ADLStatus.ADL_OK)
        {
            sensor.Value = powerOf8 >> 8;
            ActivateSensor(sensor);
        }
        else
        {
            sensor.Value = null;
        }
    }

    public override void Close()
    {
        _fanControl.ControlModeChanged -= ControlModeChanged;
        _fanControl.SoftwareControlValueChanged -= SoftwareControlValueChanged;

        if (_fanControl.ControlMode != ControlMode.Undefined)
            SetDefaultFanSpeed();

        if (_frameMetricsStarted)
            AtiAdlxx.ADL2_Adapter_FrameMetrics_Stop(_context, _adapterInfo.AdapterIndex, 0);

        if (_pmLogStarted && _device != 0)
        {
            AtiAdlxx.ADL2_Adapter_PMLog_Stop(_context, _adapterInfo.AdapterIndex, _device);
        }

        if (_device != 0)
        {
            AtiAdlxx.ADL2_Device_PMLog_Device_Destroy(_context, _device);
        }

        base.Close();
    }

    public override string GetReport()
    {
        var r = new StringBuilder();

        r.AppendLine("AMD GPU");
        r.AppendLine();

        r.Append("AdapterIndex: ");
        r.AppendLine(_adapterInfo.AdapterIndex.ToString(CultureInfo.InvariantCulture));
        r.AppendLine();

        r.AppendLine("Overdrive Caps");
        r.AppendLine();

        try
        {
            int supported = 0;
            int enabled = 0;
            int version = 0;
            AtiAdlxx.ADLStatus status = AtiAdlxx.ADL2_Overdrive_Caps(_context, _adapterInfo.AdapterIndex, ref supported, ref enabled, ref version);

            r.Append(" Status: ");
            r.AppendLine(status.ToString());
            r.Append(" Supported: ");
            r.AppendLine(supported.ToString(CultureInfo.InvariantCulture));
            r.Append(" Enabled: ");
            r.AppendLine(enabled.ToString(CultureInfo.InvariantCulture));
            r.Append(" Version: ");
            r.AppendLine(version.ToString(CultureInfo.InvariantCulture));
        }
        catch (Exception e)
        {
            r.AppendLine(" Status: " + e.Message);
        }

        r.AppendLine();

        r.AppendLine("Overdrive5 Parameters");
        r.AppendLine();
        try
        {
            AtiAdlxx.ADLStatus status = AtiAdlxx.ADL2_Overdrive5_ODParameters_Get(_context, _adapterInfo.AdapterIndex, out AtiAdlxx.ADLODParameters p);

            r.Append(" Status: ");
            r.AppendLine(status.ToString());
            r.AppendFormat(" NumberOfPerformanceLevels: {0}{1}", p.iNumberOfPerformanceLevels, Environment.NewLine);
            r.AppendFormat(" ActivityReportingSupported: {0}{1}", p.iActivityReportingSupported, Environment.NewLine);
            r.AppendFormat(" DiscretePerformanceLevels: {0}{1}", p.iDiscretePerformanceLevels, Environment.NewLine);
            r.AppendFormat(" EngineClock.Min: {0}{1}", p.sEngineClock.iMin, Environment.NewLine);
            r.AppendFormat(" EngineClock.Max: {0}{1}", p.sEngineClock.iMax, Environment.NewLine);
            r.AppendFormat(" EngineClock.Step: {0}{1}", p.sEngineClock.iStep, Environment.NewLine);
            r.AppendFormat(" MemoryClock.Min: {0}{1}", p.sMemoryClock.iMin, Environment.NewLine);
            r.AppendFormat(" MemoryClock.Max: {0}{1}", p.sMemoryClock.iMax, Environment.NewLine);
            r.AppendFormat(" MemoryClock.Step: {0}{1}", p.sMemoryClock.iStep, Environment.NewLine);
            r.AppendFormat(" Vddc.Min: {0}{1}", p.sVddc.iMin, Environment.NewLine);
            r.AppendFormat(" Vddc.Max: {0}{1}", p.sVddc.iMax, Environment.NewLine);
            r.AppendFormat(" Vddc.Step: {0}{1}", p.sVddc.iStep, Environment.NewLine);
        }
        catch (Exception e)
        {
            r.AppendLine(" Status: " + e.Message);
        }

        r.AppendLine();

        r.AppendLine("Overdrive5 Temperature");
        r.AppendLine();
        try
        {
            var adlt = new AtiAdlxx.ADLTemperature();
            AtiAdlxx.ADLStatus status = AtiAdlxx.ADL2_Overdrive5_Temperature_Get(_context, _adapterInfo.AdapterIndex, 0, ref adlt);
            r.Append(" Status: ");
            r.AppendLine(status.ToString());
            r.AppendFormat(" Value: {0}{1}", 0.001f * adlt.iTemperature, Environment.NewLine);
        }
        catch (Exception e)
        {
            r.AppendLine(" Status: " + e.Message);
        }

        r.AppendLine();

        r.AppendLine("Overdrive5 FanSpeed");
        r.AppendLine();
        try
        {
            var adlf = new AtiAdlxx.ADLFanSpeedValue { iSpeedType = AtiAdlxx.ADL_DL_FANCTRL_SPEED_TYPE_RPM };
            AtiAdlxx.ADLStatus status = AtiAdlxx.ADL2_Overdrive5_FanSpeed_Get(_context, _adapterInfo.AdapterIndex, 0, ref adlf);
            r.Append(" Status RPM: ");
            r.AppendLine(status.ToString());
            r.AppendFormat(" Value RPM: {0}{1}", adlf.iFanSpeed, Environment.NewLine);

            adlf.iSpeedType = AtiAdlxx.ADL_DL_FANCTRL_SPEED_TYPE_PERCENT;
            status = AtiAdlxx.ADL2_Overdrive5_FanSpeed_Get(_context, _adapterInfo.AdapterIndex, 0, ref adlf);
            r.Append(" Status Percent: ");
            r.AppendLine(status.ToString());
            r.AppendFormat(" Value Percent: {0}{1}", adlf.iFanSpeed, Environment.NewLine);
        }
        catch (Exception e)
        {
            r.AppendLine(" Status: " + e.Message);
        }

        r.AppendLine();

        r.AppendLine("Overdrive5 CurrentActivity");
        r.AppendLine();
        try
        {
            var adlp = new AtiAdlxx.ADLPMActivity();
            AtiAdlxx.ADLStatus status = AtiAdlxx.ADL2_Overdrive5_CurrentActivity_Get(_context, _adapterInfo.AdapterIndex, ref adlp);

            r.Append(" Status: ");
            r.AppendLine(status.ToString());
            r.AppendFormat(" EngineClock: {0}{1}", 0.01f * adlp.iEngineClock, Environment.NewLine);
            r.AppendFormat(" MemoryClock: {0}{1}", 0.01f * adlp.iMemoryClock, Environment.NewLine);
            r.AppendFormat(" Vddc: {0}{1}", 0.001f * adlp.iVddc, Environment.NewLine);
            r.AppendFormat(" ActivityPercent: {0}{1}", adlp.iActivityPercent, Environment.NewLine);
            r.AppendFormat(" CurrentPerformanceLevel: {0}{1}", adlp.iCurrentPerformanceLevel, Environment.NewLine);
            r.AppendFormat(" CurrentBusSpeed: {0}{1}", adlp.iCurrentBusSpeed, Environment.NewLine);
            r.AppendFormat(" CurrentBusLanes: {0}{1}", adlp.iCurrentBusLanes, Environment.NewLine);
            r.AppendFormat(" MaximumBusLanes: {0}{1}", adlp.iMaximumBusLanes, Environment.NewLine);
        }
        catch (Exception e)
        {
            r.AppendLine(" Status: " + e.Message);
        }

        r.AppendLine();

        if (_context != IntPtr.Zero)
        {
            r.AppendLine("Overdrive6 CurrentPower");
            r.AppendLine();

            try
            {
                int power = 0;
                for (int i = 0; i < 4; i++)
                {
                    string pt = ((AtiAdlxx.ADLODNCurrentPowerType)i).ToString();
                    AtiAdlxx.ADLStatus status = AtiAdlxx.ADL2_Overdrive6_CurrentPower_Get(_context, _adapterInfo.AdapterIndex, (AtiAdlxx.ADLODNCurrentPowerType)i, ref power);

                    r.AppendFormat(" Power[{0}].Status: {1}{2}", pt, status.ToString(), Environment.NewLine);
                    r.AppendFormat(" Power[{0}].Value: {1}{2}", pt, power * (1.0f / 0xFF), Environment.NewLine);
                }
            }
            catch (EntryPointNotFoundException)
            {
                r.AppendLine(" Status: Entry point not found");
            }
            catch (Exception e)
            {
                r.AppendLine(" Status: " + e.Message);
            }

            r.AppendLine();
        }

        if (_context != IntPtr.Zero)
        {
            r.AppendLine("OverdriveN Temperature");
            r.AppendLine();
            try
            {
                for (int i = 1; i < 8; i++)
                {
                    int temperature = 0;
                    string tt = ((AtiAdlxx.ADLODNTemperatureType)i).ToString();
                    AtiAdlxx.ADLStatus status = AtiAdlxx.ADL2_OverdriveN_Temperature_Get(_context, _adapterInfo.AdapterIndex, (AtiAdlxx.ADLODNTemperatureType)i, ref temperature);

                    r.AppendFormat(" Temperature[{0}].Status: {1}{2}", tt, status.ToString(), Environment.NewLine);
                    r.AppendFormat(" Temperature[{0}].Value: {1}{2}", tt, 0.001f * temperature, Environment.NewLine);
                }
            }
            catch (EntryPointNotFoundException)
            {
                r.AppendLine(" Status: Entry point not found");
            }
            catch (Exception e)
            {
                r.AppendLine(" Status: " + e.Message);
            }

            r.AppendLine();
        }

        if (_context != IntPtr.Zero)
        {
            r.AppendLine("OverdriveN Performance Status");
            r.AppendLine();
            try
            {
                AtiAdlxx.ADLStatus status = AtiAdlxx.ADL2_OverdriveN_PerformanceStatus_Get(_context, _adapterInfo.AdapterIndex, out AtiAdlxx.ADLODNPerformanceStatus ps);

                r.Append(" Status: ");
                r.AppendLine(status.ToString());
                r.AppendFormat(" CoreClock: {0}{1}", ps.iCoreClock, Environment.NewLine);
                r.AppendFormat(" MemoryClock: {0}{1}", ps.iMemoryClock, Environment.NewLine);
                r.AppendFormat(" DCEFClock: {0}{1}", ps.iDCEFClock, Environment.NewLine);
                r.AppendFormat(" GFXClock: {0}{1}", ps.iGFXClock, Environment.NewLine);
                r.AppendFormat(" UVDClock: {0}{1}", ps.iUVDClock, Environment.NewLine);
                r.AppendFormat(" VCEClock: {0}{1}", ps.iVCEClock, Environment.NewLine);
                r.AppendFormat(" GPUActivityPercent: {0}{1}", ps.iGPUActivityPercent, Environment.NewLine);
                r.AppendFormat(" CurrentCorePerformanceLevel: {0}{1}", ps.iCurrentCorePerformanceLevel, Environment.NewLine);
                r.AppendFormat(" CurrentMemoryPerformanceLevel: {0}{1}", ps.iCurrentMemoryPerformanceLevel, Environment.NewLine);
                r.AppendFormat(" CurrentDCEFPerformanceLevel: {0}{1}", ps.iCurrentDCEFPerformanceLevel, Environment.NewLine);
                r.AppendFormat(" CurrentGFXPerformanceLevel: {0}{1}", ps.iCurrentGFXPerformanceLevel, Environment.NewLine);
                r.AppendFormat(" UVDPerformanceLevel: {0}{1}", ps.iUVDPerformanceLevel, Environment.NewLine);
                r.AppendFormat(" VCEPerformanceLevel: {0}{1}", ps.iVCEPerformanceLevel, Environment.NewLine);
                r.AppendFormat(" CurrentBusSpeed: {0}{1}", ps.iCurrentBusSpeed, Environment.NewLine);
                r.AppendFormat(" CurrentBusLanes: {0}{1}", ps.iCurrentBusLanes, Environment.NewLine);
                r.AppendFormat(" MaximumBusLanes: {0}{1}", ps.iMaximumBusLanes, Environment.NewLine);
                r.AppendFormat(" VDDC: {0}{1}", ps.iVDDC, Environment.NewLine);
                r.AppendFormat(" VDDCI: {0}{1}", ps.iVDDCI, Environment.NewLine);
            }
            catch (EntryPointNotFoundException)
            {
                r.AppendLine(" Status: Entry point not found");
            }
            catch (Exception e)
            {
                r.AppendLine(" Status: " + e.Message);
            }

            r.AppendLine();
        }

        if (_context != IntPtr.Zero)
        {
            r.AppendLine("Performance Metrics");
            r.AppendLine();
            try
            {
                var data = new AtiAdlxx.ADLPMLogDataOutput();
                AtiAdlxx.ADLStatus status = AtiAdlxx.ADL2_New_QueryPMLogData_Get(_context, _adapterInfo.AdapterIndex, ref data);
                AtiAdlxx.ADLPMLogData adlPMLogData = new();
                if (_pmLogStarted)
                {
                    adlPMLogData = (AtiAdlxx.ADLPMLogData)Marshal.PtrToStructure(_adlPMLogStartOutput.pLoggingAddress, typeof(AtiAdlxx.ADLPMLogData));
                }

                foreach (AtiAdlxx.ADLPMLogSensors sensorType in Enum.GetValues(typeof(AtiAdlxx.ADLPMLogSensors)))
                {
                    int i = (int)sensorType;
                    if (i == 0)
                        continue;

                    bool supported = false;

                    string st = ((AtiAdlxx.ADLPMLogSensors)i).ToString();
                    if (IsSensorSupportedByPMLog(sensorType))
                    {
                        for (int k = 0; k < adlPMLogData.ulValues.Length - 1; k += 2)
                        {
                            if (adlPMLogData.ulValues[k] == (ushort)AtiAdlxx.ADLPMLogSensors.ADL_SENSOR_MAXTYPES)
                                break;

                            if (adlPMLogData.ulValues[k] == i)
                            {
                                r.AppendFormat(" Sensor[{0}].Value: {1}{2}", st, adlPMLogData.ulValues[k + 1], Environment.NewLine);
                                supported = true;
                            }
                        }
                    }
                    else if (_overdrive8LogExists && i < data.sensors.Length && data.sensors[i].supported != 0)
                    {
                        r.AppendFormat(" Sensor[{0}].Value: {1}{2}", st, data.sensors[i].value, Environment.NewLine);
                        supported = true;
                    }

                    r.AppendFormat(" Sensor[{0}].Supported: {1}{2}", st, supported, Environment.NewLine);
                }
            }
            catch (EntryPointNotFoundException)
            {
                r.AppendLine(" Status: Entry point not found");
            }
            catch (Exception e)
            {
                r.AppendLine(" Status: " + e.Message);
            }

            r.AppendLine();
        }

        if (_d3dDeviceId != null)
        {
            r.AppendLine("D3D");
            r.AppendLine();
            r.AppendLine(" Id: " + _d3dDeviceId);
        }

        return r.ToString();
    }
}

```

`LibreHardwareMonitorLib/Hardware/Gpu/AmdGpuGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using LibreHardwareMonitor.Interop;

namespace LibreHardwareMonitor.Hardware.Gpu;

internal class AmdGpuGroup : IGroup
{
    private readonly IntPtr _context = IntPtr.Zero;
    private readonly List<AmdGpu> _hardware = new();
    private readonly StringBuilder _report = new();
    private readonly AtiAdlxx.ADLStatus _status;

    public AmdGpuGroup(ISettings settings)
    {
        try
        {
            _status = AtiAdlxx.ADL2_Main_Control_Create(AtiAdlxx.Main_Memory_Alloc, 1, ref _context);

            _report.AppendLine("AMD Display Library");
            _report.AppendLine();
            _report.Append("Status: ");
            _report.AppendLine(_status == AtiAdlxx.ADLStatus.ADL_OK ? "OK" : _status.ToString());
            _report.AppendLine();

            if (_status == AtiAdlxx.ADLStatus.ADL_OK)
            {
                int numberOfAdapters = 0;
                AtiAdlxx.ADL2_Adapter_NumberOfAdapters_Get(_context, ref numberOfAdapters);

                _report.Append("Number of adapters: ");
                _report.AppendLine(numberOfAdapters.ToString(CultureInfo.InvariantCulture));
                _report.AppendLine();

                if (numberOfAdapters > 0)
                {
                    List<AmdGpu> potentialHardware = new();

                    AtiAdlxx.ADLAdapterInfo[] adapterInfo = new AtiAdlxx.ADLAdapterInfo[numberOfAdapters];
                    if (AtiAdlxx.ADL2_Adapter_AdapterInfo_Get(ref _context, adapterInfo) == AtiAdlxx.ADLStatus.ADL_OK)
                    {
                        for (int i = 0; i < numberOfAdapters; i++)
                        {
                            uint device = 0;
                            AtiAdlxx.ADLGcnInfo gcnInfo = new();
                            AtiAdlxx.ADLPMLogSupportInfo pmLogSupportInfo = new();
                            AtiAdlxx.ADL2_Adapter_Active_Get(_context, adapterInfo[i].AdapterIndex, out int isActive);

                            if (AtiAdlxx.ADL_Method_Exists(nameof(AtiAdlxx.ADL2_GcnAsicInfo_Get)))
                            {
                                AtiAdlxx.ADL2_GcnAsicInfo_Get(_context, adapterInfo[i].AdapterIndex, ref gcnInfo);
                            }

                            int adapterId = -1;
                            if (AtiAdlxx.ADL_Method_Exists(nameof(AtiAdlxx.ADL2_Adapter_ID_Get)))
                                AtiAdlxx.ADL2_Adapter_ID_Get(_context, adapterInfo[i].AdapterIndex, out adapterId);

                            _report.Append("AdapterIndex: ");
                            _report.AppendLine(i.ToString(CultureInfo.InvariantCulture));
                            _report.Append("isActive: ");
                            _report.AppendLine(isActive.ToString(CultureInfo.InvariantCulture));
                            _report.Append("AdapterName: ");
                            _report.AppendLine(adapterInfo[i].AdapterName);
                            _report.Append("UDID: ");
                            _report.AppendLine(adapterInfo[i].UDID);
                            _report.Append("PNPString: ");
                            _report.AppendLine(adapterInfo[i].PNPString);
                            _report.Append("Present: ");
                            _report.AppendLine(adapterInfo[i].Present.ToString(CultureInfo.InvariantCulture));
                            _report.Append("VendorID: 0x");
                            _report.AppendLine(adapterInfo[i].VendorID.ToString("X", CultureInfo.InvariantCulture));
                            _report.Append("BusNumber: ");
                            _report.AppendLine(adapterInfo[i].BusNumber.ToString(CultureInfo.InvariantCulture));
                            _report.Append("DeviceNumber: ");
                            _report.AppendLine(adapterInfo[i].DeviceNumber.ToString(CultureInfo.InvariantCulture));
                            _report.Append("FunctionNumber: ");
                            _report.AppendLine(adapterInfo[i].FunctionNumber.ToString(CultureInfo.InvariantCulture));
                            _report.Append("AdapterID: 0x");
                            _report.AppendLine(adapterId.ToString("X", CultureInfo.InvariantCulture));
                            _report.AppendLine("Family: " + gcnInfo.ASICFamilyId);

                            int sensorsSupported = 0;
                            if (AtiAdlxx.UsePmLogForFamily(gcnInfo.ASICFamilyId) &&
                                AtiAdlxx.ADL_Method_Exists(nameof(AtiAdlxx.ADL2_Adapter_PMLog_Support_Get)) &&
                                AtiAdlxx.ADL_Method_Exists(nameof(AtiAdlxx.ADL2_Device_PMLog_Device_Create)))
                            {
                                if (AtiAdlxx.ADLStatus.ADL_OK == AtiAdlxx.ADL2_Device_PMLog_Device_Create(_context, adapterInfo[i].AdapterIndex, ref device) &&
                                    AtiAdlxx.ADLStatus.ADL_OK == AtiAdlxx.ADL2_Adapter_PMLog_Support_Get(_context, adapterInfo[i].AdapterIndex, ref pmLogSupportInfo))
                                {
                                    int k = 0;
                                    while (pmLogSupportInfo.usSensors[k] != (ushort)AtiAdlxx.ADLPMLogSensors.ADL_SENSOR_MAXTYPES)
                                    {
                                        k++;
                                    }
                                    sensorsSupported = k;
                                }
                                _report.AppendLine("Sensors Supported: " + sensorsSupported);

                                if (device != 0)
                                {
                                    AtiAdlxx.ADL2_Device_PMLog_Device_Destroy(_context, device);
                                }
                            }

                            if (!string.IsNullOrEmpty(adapterInfo[i].UDID) && adapterInfo[i].VendorID == AtiAdlxx.ATI_VENDOR_ID &&
                                !IsAlreadyAdded(adapterInfo[i].BusNumber, adapterInfo[i].DeviceNumber))
                            {
                                if (sensorsSupported > 0)
                                {
                                    _hardware.Add(new AmdGpu(_context, adapterInfo[i], gcnInfo, settings));
                                }
                                else
                                {
                                    potentialHardware.Add(new AmdGpu(_context, adapterInfo[i], gcnInfo, settings));
                                }
                            }

                            _report.AppendLine();
                        }
                    }

                    foreach (IGrouping<string, AmdGpu> amdGpus in potentialHardware.GroupBy(x => $"{x.BusNumber}-{x.DeviceNumber}"))
                    {
                        AmdGpu amdGpu = amdGpus.OrderByDescending(x => x.Sensors.Length).FirstOrDefault();
                        if (amdGpu != null && !IsAlreadyAdded(amdGpu.BusNumber, amdGpu.DeviceNumber))
                            _hardware.Add(amdGpu);
                    }
                }
            }
        }
        catch (DllNotFoundException)
        { }
        catch (EntryPointNotFoundException e)
        {
            _report.AppendLine();
            _report.AppendLine(e.ToString());
            _report.AppendLine();
        }
    }

    private bool IsAlreadyAdded(int busNumber, int deviceNumber)
    {
        foreach (AmdGpu g in _hardware)
        {
            if (g.BusNumber == busNumber && g.DeviceNumber == deviceNumber)
            {
                return true;
            }
        }
        return false;
    }

    public IReadOnlyList<IHardware> Hardware => _hardware;

    public string GetReport()
    {
        return _report.ToString();
    }

    public void Close()
    {
        try
        {
            foreach (AmdGpu gpu in _hardware)
                gpu.Close();

            if (_status == AtiAdlxx.ADLStatus.ADL_OK && _context != IntPtr.Zero)
                AtiAdlxx.ADL2_Main_Control_Destroy(_context);
        }
        catch (Exception)
        { }
    }
}

```

`LibreHardwareMonitorLib/Hardware/Gpu/GenericGpu.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware.Gpu;

public abstract class GenericGpu : Hardware
{
    /// <summary>
    /// Initializes a new instance of the <see cref="GenericGpu" /> class.
    /// </summary>
    /// <param name="name">Component name.</param>
    /// <param name="identifier">Identifier that will be assigned to the device. Based on <see cref="Identifier" /></param>
    /// <param name="settings">Additional settings passed by the <see cref="IComputer" />.</param>
    protected GenericGpu(string name, Identifier identifier, ISettings settings) : base(name, identifier, settings)
    {
    }

    /// <summary>
    /// Gets the device identifier.
    /// </summary>
    public abstract string DeviceId { get; }

    public override void Close()
    {
        base.Close();
    }
}

```

`LibreHardwareMonitorLib/Hardware/Gpu/IntelDiscreteGpu.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Runtime.InteropServices;
using LibreHardwareMonitor.Interop;
using Windows.Win32;
using Windows.Win32.Devices.DeviceAndDriverInstallation;
using Windows.Win32.Devices.Properties;
using Windows.Win32.Foundation;

namespace LibreHardwareMonitor.Hardware.Gpu;

internal sealed class IntelDiscreteGpu : GenericGpu
{
    // Constants
    private const double MemoryFrequencyDivisor = 8.0; // Intel GCL returns memory frequency multiplied by 8

    // Clock sensors
    private readonly Sensor _clockCore;
    private readonly Sensor _clockMemory;

    // Fan sensors
    private readonly Sensor[] _fans;

    // Utilization sensors
    private readonly Sensor _loadGlobalActivity;
    private readonly Sensor _loadMedia;
    private readonly Sensor _loadRenderCompute;

    // Power sensors
    private readonly Sensor _powerGpu;
    private readonly Sensor _powerTotal;

    // Temperature sensors
    private readonly Sensor _temperatureGpuCore;
    private readonly Sensor _temperatureMemory;

    // Voltage sensors
    private readonly Sensor _voltageCore;
    private readonly Sensor _voltageMemory;

    // Memory sensors
    private readonly Sensor _memoryFree;
    private readonly Sensor _memoryTotal;
    private readonly Sensor _memoryUsed;
    private readonly Sensor _memoryLoad;

    // Bandwidth sensors
    private readonly Sensor _memoryBandwidthRead;
    private readonly Sensor _memoryBandwidthWrite;

    // Timestamps
    private double _currentTimestamp = double.NaN;
    private string _deviceId;
    private string _d3dDeviceId;

    // Intel GCL properties and data
    private readonly IntelGcl.ctl_device_adapter_handle_t _handle;

    // Power calculation support
    private double _lastEnergyReading = double.NaN;

    // Activity counter calculation support
    private double _lastGlobalActivityCounter = double.NaN;
    private double _lastMediaActivityCounter = double.NaN;
    private double _lastRenderComputeActivityCounter = double.NaN;
    private double _lastTimestamp = double.NaN;
    private double _lastTotalCardEnergyReading = double.NaN;
    private double _lastVramReadBandwidthCounter = double.NaN;
    private double _lastVramWriteBandwidthCounter = double.NaN;
    private IntelGcl.ctl_device_adapter_properties_t _properties;

    // Telemetry data
    private IntelGcl.ctl_power_telemetry_t _telemetry;

    public IntelDiscreteGpu(IntelGcl.ctl_device_adapter_handle_t handle, ISettings settings)
        : base(GetDeviceName(handle), new Identifier("gpu-intel", GetDeviceId(handle)), settings)
    {
        _handle = handle;
        IsValid = false;

        // Initialize device properties
        if (!InitializeDevice())
            return;

        // Try to get D3D device identifier for memory monitoring
        _d3dDeviceId = GetD3DDeviceId();

        // Initialize temperature sensors
        _temperatureGpuCore = new Sensor("GPU Core", 0, SensorType.Temperature, this, settings);
        _temperatureMemory = new Sensor("GPU Memory", 1, SensorType.Temperature, this, settings);

        // Initialize clock sensors
        _clockCore = new Sensor("GPU Core", 0, SensorType.Clock, this, settings);
        _clockMemory = new Sensor("GPU Memory", 1, SensorType.Clock, this, settings);

        // Initialize voltage sensors
        _voltageCore = new Sensor("GPU Core", 0, SensorType.Voltage, this, settings);
        _voltageMemory = new Sensor("GPU Memory", 1, SensorType.Voltage, this, settings);

        // Initialize power sensors
        _powerGpu = new Sensor("GPU Package", 0, SensorType.Power, this, settings);
        _powerTotal = new Sensor("GPU Total", 1, SensorType.Power, this, settings);

        // Initialize utilization sensors
        _loadGlobalActivity = new Sensor("GPU Core", 0, SensorType.Load, this, settings);
        _loadRenderCompute = new Sensor("GPU Render/Compute", 1, SensorType.Load, this, settings);
        _loadMedia = new Sensor("GPU Media", 2, SensorType.Load, this, settings);

        // Initialize memory sensors
        _memoryFree = new Sensor("GPU Memory Free", 0, SensorType.SmallData, this, settings);
        _memoryUsed = new Sensor("GPU Memory Used", 1, SensorType.SmallData, this, settings);
        _memoryTotal = new Sensor("GPU Memory Total", 2, SensorType.SmallData, this, settings);
        _memoryLoad = new Sensor("GPU Memory", 3, SensorType.Load, this, settings);

        // Initialize bandwidth sensors
        _memoryBandwidthRead = new Sensor("GPU Memory Read", 0, SensorType.Throughput, this, settings);
        _memoryBandwidthWrite = new Sensor("GPU Memory Write", 1, SensorType.Throughput, this, settings);

        // Initialize fan sensors based on available fans
        int fanCount = (int)GetFanCount();
        _fans = new Sensor[fanCount];

        for (int i = 0; i < fanCount; i++)
        {
            string fanName = fanCount == 1 ? "GPU Fan" : $"GPU Fan {i + 1}";
            _fans[i] = new Sensor(fanName, i, SensorType.Fan, this, settings);
        }

        Update();
    }

    public override string DeviceId => _deviceId ?? GetDeviceId(_handle);

    public uint DriverVersion { get; private set; }

    public override HardwareType HardwareType => HardwareType.GpuIntel;

    public bool IsValid { get; private set; }

    public uint RevisionId { get; private set; }

    public uint VendorId { get; private set; }

    private static bool TryGetDeviceProperties(IntelGcl.ctl_device_adapter_handle_t handle, out IntelGcl.ctl_device_adapter_properties_t properties)
    {
        properties = new IntelGcl.ctl_device_adapter_properties_t
        {
            Size = (uint)Marshal.SizeOf(typeof(IntelGcl.ctl_device_adapter_properties_t)),
            Version = 2
        };

        int result = IntelGcl.ctlGetDeviceProperties(handle, ref properties);
        return result == (int)IntelGcl.ctl_result_t.CTL_RESULT_SUCCESS &&
               properties.device_type == IntelGcl.ctl_device_type_t.CTL_DEVICE_TYPE_GRAPHICS;
    }

    private static string GetDeviceName(IntelGcl.ctl_device_adapter_handle_t handle)
    {
        if (TryGetDeviceProperties(handle, out IntelGcl.ctl_device_adapter_properties_t properties))
        {
            return properties.name;
        }

        return "Intel GPU";
    }

    private static string GetDeviceId(IntelGcl.ctl_device_adapter_handle_t handle)
    {
        if (TryGetDeviceProperties(handle, out IntelGcl.ctl_device_adapter_properties_t properties))
        {
            return $"0x{properties.pci_device_id:X4}";
        }

        return "0x0000";
    }

    // Device initialization
    private bool InitializeDevice()
    {
        if (TryGetDeviceProperties(_handle, out _properties))
        {
            _deviceId = $"0x{_properties.pci_device_id:X4}";
            VendorId = _properties.pci_vendor_id;
            RevisionId = _properties.rev_id;
            DriverVersion = (uint)_properties.driver_version;
            IsValid = true;
            return true;
        }

        return false;
    }

    private string GetD3DDeviceId()
    {
        // Try to find matching D3D device using PCI device ID
        string[] deviceIdentifiers = D3DDisplayDevice.GetDeviceIdentifiers();
        if (deviceIdentifiers == null || deviceIdentifiers.Length == 0)
            return null;

        // Intel vendor ID is 0x8086
        string vendorPattern = $"VEN_{_properties.pci_vendor_id:X}";
        string devicePattern = $"DEV_{_properties.pci_device_id:X}";

        foreach (string deviceIdentifier in deviceIdentifiers)
        {
            // Check if this device matches Intel vendor and device IDs
            if (deviceIdentifier.IndexOf(vendorPattern, StringComparison.OrdinalIgnoreCase) != -1 &&
                deviceIdentifier.IndexOf(devicePattern, StringComparison.OrdinalIgnoreCase) != -1)
            {
                // Check BDF if available
                if (GetBdfFromDeviceIdentifier(deviceIdentifier, out int bus, out int device, out int function))
                {
                    if (bus == _properties.adapter_bdf.bus && device == _properties.adapter_bdf.device && function == _properties.adapter_bdf.function)
                    {
                        // Verify it's a valid D3D device by trying to get device info
                        if (D3DDisplayDevice.GetDeviceInfoByIdentifier(deviceIdentifier, out D3DDisplayDevice.D3DDeviceInfo deviceInfo))
                        {
                            return deviceIdentifier;
                        }
                    }
                }
                else
                {
                    // Fallback to old behavior if BDF check fails (e.g. P/Invoke error)
                    // Verify it's a valid D3D device by trying to get device info
                    if (D3DDisplayDevice.GetDeviceInfoByIdentifier(deviceIdentifier, out D3DDisplayDevice.D3DDeviceInfo deviceInfo))
                    {
                        return deviceIdentifier;
                    }
                }
            }
        }

        return null;
    }

    public override void Update()
    {
        if (!IsValid)
            return;

        try
        {
            // Update telemetry data from Intel GCL
            if (!UpdateTelemetry())
                return;

            // Update power sensors
            UpdatePowerFromEnergyCounter(_telemetry.gpuEnergyCounter, ref _lastEnergyReading, _powerGpu);
            UpdatePowerFromEnergyCounter(_telemetry.totalCardEnergyCounter, ref _lastTotalCardEnergyReading, _powerTotal);

            // Update temperature sensors
            UpdateSensorFromTelemetry(_telemetry.gpuCurrentTemperature, _temperatureGpuCore);
            UpdateSensorFromTelemetry(_telemetry.vramCurrentTemperature, _temperatureMemory);

            // Update clock sensors
            UpdateSensorFromTelemetry(_telemetry.gpuCurrentClockFrequency, _clockCore);
            UpdateMemoryFrequency(_clockMemory);

            // Update voltage sensors
            UpdateSensorFromTelemetry(_telemetry.gpuVoltage, _voltageCore);
            UpdateSensorFromTelemetry(_telemetry.vramVoltage, _voltageMemory);

            // Update utilization sensors
            UpdateUtilizationFromActivityCounter(_telemetry.globalActivityCounter, ref _lastGlobalActivityCounter, _loadGlobalActivity);
            UpdateUtilizationFromActivityCounter(_telemetry.renderComputeActivityCounter, ref _lastRenderComputeActivityCounter, _loadRenderCompute);
            UpdateUtilizationFromActivityCounter(_telemetry.mediaActivityCounter, ref _lastMediaActivityCounter, _loadMedia);

            // Try to get D3D device ID if we haven't found it yet
            if (string.IsNullOrEmpty(_d3dDeviceId))
            {
                _d3dDeviceId = GetD3DDeviceId();
            }

            // Update VRAM memory sensors (using D3D API)
            UpdateMemorySensors();

            // Update VRAM bandwidth sensors
            UpdateBandwidthFromCounter(_telemetry.vramReadBandwidth, ref _lastVramReadBandwidthCounter, _memoryBandwidthRead);
            UpdateBandwidthFromCounter(_telemetry.vramWriteBandwidth, ref _lastVramWriteBandwidthCounter, _memoryBandwidthWrite);

            // Update fan sensors
            UpdateFanSpeeds(_fans);
        }
        catch (Exception ex)
        {
            // Log error but don't crash the update
            System.Diagnostics.Debug.WriteLine($"Error updating Intel GPU sensors: {ex.Message}");
        }
    }

    private bool UpdateTelemetry()
    {
        if (!IsValid)
            return false;

        var telemetry = new IntelGcl.ctl_power_telemetry_t
        {
            Size = (uint)Marshal.SizeOf(typeof(IntelGcl.ctl_power_telemetry_t)),
            Version = 1,
            psu = new IntelGcl.ctl_psu_info_t[IntelGcl.CTL_PSU_COUNT],
            fanSpeed = new IntelGcl.ctl_oc_telemetry_item_t[IntelGcl.CTL_FAN_COUNT]
        };

        if (IntelGcl.ctlPowerTelemetryGet(_handle, ref telemetry) == (int)IntelGcl.ctl_result_t.CTL_RESULT_SUCCESS)
        {
            _telemetry = telemetry;
            _lastTimestamp = _currentTimestamp;
            _currentTimestamp = _telemetry.timeStamp.bSupported ? GetTelemetryValue(_telemetry.timeStamp) : DateTimeOffset.UtcNow.Ticks;
            return true;
        }

        return false;
    }

    private void UpdateMemoryFrequency(Sensor sensor)
    {
        double frequency = double.NaN;

        uint freqCount = 0;
        int result = IntelGcl.ctlEnumFrequencyDomains(_handle, ref freqCount, null);

        if (result == (int)IntelGcl.ctl_result_t.CTL_RESULT_SUCCESS && freqCount > 0)
        {
            var freqHandles = new IntelGcl.ctl_freq_handle_t[freqCount];
            result = IntelGcl.ctlEnumFrequencyDomains(_handle, ref freqCount, freqHandles);

            if (result == (int)IntelGcl.ctl_result_t.CTL_RESULT_SUCCESS)
            {
                for (int i = 0; i < freqCount; i++)
                {
                    var properties = new IntelGcl.ctl_freq_properties_t
                    {
                        Size = (uint)Marshal.SizeOf(typeof(IntelGcl.ctl_freq_properties_t)),
                        Version = 0
                    };

                    result = IntelGcl.ctlFrequencyGetProperties(freqHandles[i], ref properties);

                    if (result == (int)IntelGcl.ctl_result_t.CTL_RESULT_SUCCESS &&
                        properties.type == IntelGcl.ctl_freq_domain_t.CTL_FREQ_DOMAIN_MEMORY)
                    {
                        var state = new IntelGcl.ctl_freq_state_t
                        {
                            Size = (uint)Marshal.SizeOf(typeof(IntelGcl.ctl_freq_state_t)),
                            Version = 0
                        };

                        result = IntelGcl.ctlFrequencyGetState(freqHandles[i], ref state);

                        if (result == (int)IntelGcl.ctl_result_t.CTL_RESULT_SUCCESS && state.actual >= 0)
                        {
                            frequency = state.actual / MemoryFrequencyDivisor;
                            break;
                        }
                    }
                }
            }
        }

        if (double.IsNaN(frequency) && _telemetry.vramCurrentClockFrequency.bSupported)
        {
            frequency = GetTelemetryValue(_telemetry.vramCurrentClockFrequency);
        }

        if (!double.IsNaN(frequency))
        {
            sensor.Value = (float)frequency;
            ActivateSensor(sensor);
        }
        else
        {
            sensor.Value = null;
        }
    }

    private uint GetFanCount()
    {
        uint fanCount = 0;
        int result = IntelGcl.ctlEnumFans(_handle, ref fanCount, null);

        if (result == (int)IntelGcl.ctl_result_t.CTL_RESULT_SUCCESS)
        {
            return fanCount;
        }

        return 0;
    }

    private void UpdateFanSpeeds(Sensor[] fanSensors)
    {
        uint fanCount = (uint)Math.Min(Math.Max(0, GetFanCount()), fanSensors.Length);
        if (fanCount == 0)
            return;

        var fanHandles = new IntelGcl.ctl_fan_handle_t[fanCount];
        int result = IntelGcl.ctlEnumFans(_handle, ref fanCount, fanHandles);

        if (result == (int)IntelGcl.ctl_result_t.CTL_RESULT_SUCCESS)
        {
            for (int i = 0; i < fanCount; i++)
            {
                int fanSpeed = -1;
                result = IntelGcl.ctlFanGetState(fanHandles[i], IntelGcl.ctl_fan_speed_units_t.CTL_FAN_SPEED_UNITS_RPM, ref fanSpeed);

                if (result == (int)IntelGcl.ctl_result_t.CTL_RESULT_SUCCESS && fanSpeed >= 0)
                {
                    fanSensors[i].Value = fanSpeed;
                    ActivateSensor(fanSensors[i]);
                }
                else
                {
                    fanSensors[i].Value = null;
                }
            }

            for (int i = (int)fanCount; i < fanSensors.Length; i++)
            {
                fanSensors[i].Value = null;
            }
        }
    }

    private void UpdateSensorFromTelemetry(IntelGcl.ctl_oc_telemetry_item_t telemetryItem, Sensor sensor)
    {
        if (telemetryItem.bSupported)
        {
            sensor.Value = (float)GetTelemetryValue(telemetryItem);
            ActivateSensor(sensor);
        }
        else
        {
            sensor.Value = null;
        }
    }

    private double GetTelemetryValue(IntelGcl.ctl_oc_telemetry_item_t item)
    {
        return item.type switch
        {
            IntelGcl.ctl_data_type_t.CTL_DATA_TYPE_FLOAT => item.value.datafloat,
            IntelGcl.ctl_data_type_t.CTL_DATA_TYPE_DOUBLE => item.value.datadouble,
            IntelGcl.ctl_data_type_t.CTL_DATA_TYPE_UINT32 => item.value.datau32,
            IntelGcl.ctl_data_type_t.CTL_DATA_TYPE_INT32 => item.value.data32,
            IntelGcl.ctl_data_type_t.CTL_DATA_TYPE_UINT64 => item.value.datau64,
            IntelGcl.ctl_data_type_t.CTL_DATA_TYPE_INT64 => item.value.data64,
            IntelGcl.ctl_data_type_t.CTL_DATA_TYPE_UINT16 => item.value.datau16,
            IntelGcl.ctl_data_type_t.CTL_DATA_TYPE_INT16 => item.value.data16,
            IntelGcl.ctl_data_type_t.CTL_DATA_TYPE_UINT8 => item.value.datau8,
            IntelGcl.ctl_data_type_t.CTL_DATA_TYPE_INT8 => item.value.data8,
            _ => double.NaN
        };
    }

    private void UpdatePowerFromEnergyCounter(IntelGcl.ctl_oc_telemetry_item_t energyCounter, ref double lastEnergyReading, Sensor powerSensor)
    {
        if (!IsValid || powerSensor == null)
            return;

        double currentEnergy = energyCounter.bSupported ? GetTelemetryValue(energyCounter) : double.NaN;
        double deltaTime = _currentTimestamp - _lastTimestamp;

        if (deltaTime > 0.0 && !double.IsNaN(currentEnergy) && !double.IsNaN(lastEnergyReading))
        {
            double deltaEnergy = currentEnergy - lastEnergyReading;
            double power = deltaEnergy / deltaTime;
            power = power < 0 ? 0 : power;

            powerSensor.Value = (float)power;
            ActivateSensor(powerSensor);
        }
        else
        {
            powerSensor.Value = null;
        }

        lastEnergyReading = currentEnergy;
    }

    private void UpdateUtilizationFromActivityCounter(IntelGcl.ctl_oc_telemetry_item_t activityCounter, ref double lastActivityReading, Sensor activitySensor)
    {
        if (!IsValid || activitySensor == null)
            return;

        double currentActivity = activityCounter.bSupported ? GetTelemetryValue(activityCounter) : double.NaN;
        double deltaTime = _currentTimestamp - _lastTimestamp;

        if (deltaTime > 0 && !double.IsNaN(currentActivity) && !double.IsNaN(lastActivityReading))
        {
            double activeDiff = currentActivity - lastActivityReading;
            if (activeDiff >= 0)
            {
                double activity = (activeDiff / deltaTime) * 100.0;
                activity = Math.Min(Math.Max(activity, 0.0), 100.0);

                activitySensor.Value = (float)activity;
                ActivateSensor(activitySensor);
            }
            else
            {
                activitySensor.Value = null;
            }
        }
        else
        {
            activitySensor.Value = null;
        }

        lastActivityReading = currentActivity;
    }

    private void UpdateMemorySensors()
    {
        if (string.IsNullOrEmpty(_d3dDeviceId))
        {
            // Fallback: Try to find any Intel D3D device
            string[] deviceIdentifiers = D3DDisplayDevice.GetDeviceIdentifiers();
            if (deviceIdentifiers != null)
            {
                foreach (string deviceId in deviceIdentifiers)
                {
                    if (deviceId.IndexOf("VEN_8086", StringComparison.OrdinalIgnoreCase) != -1)
                    {
                        if (D3DDisplayDevice.GetDeviceInfoByIdentifier(deviceId, out D3DDisplayDevice.D3DDeviceInfo testInfo))
                        {
                            if (testInfo.GpuDedicatedLimit > 0 && !testInfo.Integrated)
                            {
                                _d3dDeviceId = deviceId;
                                break;
                            }
                        }
                    }
                }
            }

            if (string.IsNullOrEmpty(_d3dDeviceId))
                return;
        }

        if (D3DDisplayDevice.GetDeviceInfoByIdentifier(_d3dDeviceId, out D3DDisplayDevice.D3DDeviceInfo deviceInfo))
        {
            // Get dedicated video memory (VRAM) usage
            ulong totalBytes = deviceInfo.GpuVideoMemoryLimit;
            ulong usedBytes = deviceInfo.GpuDedicatedUsed;
            ulong freeBytes = totalBytes > usedBytes ? totalBytes - usedBytes : 0;

            if (totalBytes > 0)
            {
                // Convert bytes to MB for display
                _memoryTotal.Value = totalBytes / (1024.0f * 1024.0f);
                ActivateSensor(_memoryTotal);

                _memoryUsed.Value = usedBytes / (1024.0f * 1024.0f);
                ActivateSensor(_memoryUsed);

                _memoryFree.Value = freeBytes / (1024.0f * 1024.0f);
                ActivateSensor(_memoryFree);

                // Calculate load percentage
                _memoryLoad.Value = (float)((double)usedBytes / totalBytes * 100.0);
                ActivateSensor(_memoryLoad);
            }
        }
    }

    private void UpdateBandwidthFromCounter(IntelGcl.ctl_oc_telemetry_item_t bandwidthItem, ref double lastBandwidthReading, Sensor bandwidthSensor)
    {
        if (!IsValid || bandwidthSensor == null)
            return;

        // If the telemetry item directly provides bandwidth value (not a counter)
        if (bandwidthItem.bSupported)
        {
            double bandwidthValue = GetTelemetryValue(bandwidthItem);

            if (!double.IsNaN(bandwidthValue) && bandwidthValue >= 0)
            {
                // Bandwidth is typically in GB/s or MB/s, convert to B/s for Throughput sensor
                // Check the units to determine if conversion is needed
                if (bandwidthItem.units == IntelGcl.ctl_units_t.CTL_UNITS_BANDWIDTH_MBPS)
                {
                    // Convert MB/s to B/s (multiply by 1024*1024)
                    bandwidthValue = bandwidthValue * 1024.0 * 1024.0;
                }
                else if (bandwidthItem.units == IntelGcl.ctl_units_t.CTL_UNITS_MEM_SPEED_GBPS)
                {
                    // Convert GB/s to B/s (multiply by 1024*1024*1024)
                    bandwidthValue = bandwidthValue * 1024.0 * 1024.0 * 1024.0;
                }

                bandwidthSensor.Value = (float)bandwidthValue;
                ActivateSensor(bandwidthSensor);
            }
            else
            {
                bandwidthSensor.Value = null;
            }
        }
        else
        {
            bandwidthSensor.Value = null;
        }
    }

    private unsafe bool GetBdfFromDeviceIdentifier(string deviceIdentifier, out int bus, out int device, out int function)
    {
        bus = -1;
        device = -1;
        function = -1;

        if (string.IsNullOrEmpty(deviceIdentifier))
            return false;

        // deviceIdentifier is like "\\?\PCI#VEN_8086&DEV_56A0&SUBSYS_10208086&REV_08#4&3834663c&0&0008#{5b45201d-f2f2-4f3b-85bb-30ff1f953599}"
        // We need to extract the instance ID from this.
        // The instance ID is "PCI\VEN_8086&DEV_56A0&SUBSYS_10208086&REV_08\4&3834663c&0&0008"

        // Extract the device instance path from the interface path
        // Remove "\\?\" prefix and the GUID suffix
        string instanceId = deviceIdentifier;
        if (instanceId.StartsWith(@"\\?\"))
            instanceId = instanceId.Substring(4);

        int lastHash = instanceId.LastIndexOf('#');
        if (lastHash == -1)
            return false;

        instanceId = instanceId.Substring(0, lastHash);
        // Replace '#' with '\' to match the Instance ID format expected by CM
        instanceId = instanceId.Replace('#', '\\');

        uint devInst;
        fixed (char* pInstanceId = instanceId)
        {
            if (PInvoke.CM_Locate_DevNode(out devInst, (PWSTR)pInstanceId, CM_LOCATE_DEVNODE_FLAGS.CM_LOCATE_DEVNODE_NORMAL) != CONFIGRET.CR_SUCCESS)
            {
                return false;
            }
        }

        DEVPROPTYPE propertyType;
        uint bufferSize = sizeof(uint);
        uint busNum = 0;
        uint address = 0;

        fixed (DEVPROPKEY* pBusKey = &PInvoke.DEVPKEY_Device_BusNumber)
        {
            if (PInvoke.CM_Get_DevNode_Property(devInst, pBusKey, &propertyType, (byte*)&busNum, &bufferSize, 0) == CONFIGRET.CR_SUCCESS && propertyType == DEVPROPTYPE.DEVPROP_TYPE_UINT32)
            {
                bus = (int)busNum;
            }
            else
            {
                return false;
            }
        }

        bufferSize = sizeof(uint);
        propertyType = default;
        fixed (DEVPROPKEY* pAddrKey = &PInvoke.DEVPKEY_Device_Address)
        {
            if (PInvoke.CM_Get_DevNode_Property(devInst, pAddrKey, &propertyType, (byte*)&address, &bufferSize, 0) == CONFIGRET.CR_SUCCESS &&
                propertyType == DEVPROPTYPE.DEVPROP_TYPE_UINT32)
            {
                // Address contains device and function per Windows DEVPKEY_Device_Address spec
                // Bits 16-31: Device number
                // Bits 0-15: Function number
                device = (int)(address >> 16) & 0xFFFF;
                function = (int)address & 0xFFFF;
                return true;
            }
        }

        return false;
    }
}

```

`LibreHardwareMonitorLib/Hardware/Gpu/IntelGpuGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Runtime.InteropServices;
using System.Text;
using LibreHardwareMonitor.Hardware.Cpu;
using LibreHardwareMonitor.Interop;

namespace LibreHardwareMonitor.Hardware.Gpu;

internal class IntelGpuGroup : IGroup
{
    private readonly List<Hardware> _hardware = new();
    private readonly StringBuilder _report = new();

    public IntelGpuGroup(List<IntelCpu> intelCpus, ISettings settings)
    {
        if (!Software.OperatingSystem.IsUnix)
        {
            // Initialize Intel GCL for discrete and integrated GPU telemetry
            bool gclInitialized = false;

            try
            {
                if (IntelGcl.IsAvailable)
                {
                    gclInitialized = IntelGcl.Initialize();
                }
            }
            catch (Exception ex)
            {
                _report.Append("Intel GCL initialization failed: ");
                _report.AppendLine(ex.Message);
            }

            _report.AppendLine("Intel GPU Detection");
            _report.AppendLine();
            _report.Append("Intel GCL Initialized: ");
            _report.AppendLine(gclInitialized.ToString(CultureInfo.InvariantCulture));
            _report.AppendLine();

            // Enumerate discrete GPUs using Intel GCL
            if (gclInitialized)
            {
                try
                {
                    var handles = IntelGcl.GetDeviceHandles();
                    _report.Append("Device handles found: ");
                    _report.AppendLine(handles.Length.ToString(CultureInfo.InvariantCulture));

                    foreach (var handle in handles)
                    {
                        try
                        {
                            // Skip integrated GPUs — they are handled separately by IntelIntegratedGpu
                            // via the D3D enumeration path below. IGCL's ctlEnumerateDevices returns all
                            // Intel graphics devices including the iGPU, which would otherwise cause the
                            // same physical device to appear twice with overlapping sensors.
                            var props = new IntelGcl.ctl_device_adapter_properties_t
                            {
                                Size = (uint)Marshal.SizeOf<IntelGcl.ctl_device_adapter_properties_t>(),
                                Version = 2
                            };

                            if (IntelGcl.ctlGetDeviceProperties(handle, ref props) == (int)IntelGcl.ctl_result_t.CTL_RESULT_SUCCESS &&
                                (props.graphics_adapter_properties & (uint)IntelGcl.ctl_adapter_properties_flag_t.CTL_ADAPTER_PROPERTIES_FLAG_INTEGRATED) != 0)
                            {
                                continue;
                            }

                            var gpu = new IntelDiscreteGpu(handle, settings);
                            if (gpu.IsValid)
                            {
                                _report.Append("Discrete GPU: ");
                                _report.AppendLine(gpu.Name);
                                _report.Append("Device ID: ");
                                _report.AppendLine(gpu.DeviceId);
                                _report.AppendLine();

                                _hardware.Add(gpu);
                                _report.AppendLine("Successfully added discrete GPU to hardware list");
                            }
                            else
                            {
                                _report.AppendLine("Skipped invalid GPU device");
                            }
                        }
                        catch (Exception ex)
                        {
                            _report.Append("Failed to create IntelDiscreteGpu: ");
                            _report.AppendLine(ex.Message);
                            _report.AppendLine(ex.StackTrace);
                        }
                    }
                }
                catch (Exception ex)
                {
                    _report.Append("Failed to enumerate Intel GPU devices: ");
                    _report.AppendLine(ex.Message);
                }
            }

            // Enumerate integrated GPUs using D3D (existing logic)
            if (intelCpus?.Count > 0)
            {
                _report.AppendLine("Intel GPU (D3D - Integrated)");
                _report.AppendLine();

                string[] ids = D3DDisplayDevice.GetDeviceIdentifiers();

                _report.Append("Number of D3D adapters: ");
                _report.AppendLine(ids.Length.ToString(CultureInfo.InvariantCulture));
                _report.AppendLine();

                for (int i = 0; i < ids.Length; i++)
                {
                    string deviceId = ids[i];
                    bool isIntel = deviceId.IndexOf("VEN_8086", StringComparison.Ordinal) != -1;

                    _report.Append("AdapterIndex: ");
                    _report.AppendLine(i.ToString(CultureInfo.InvariantCulture));
                    _report.Append("DeviceId: ");
                    _report.AppendLine(deviceId);
                    _report.Append("IsIntel: ");
                    _report.AppendLine(isIntel.ToString(CultureInfo.InvariantCulture));

                    if (isIntel && D3DDisplayDevice.GetDeviceInfoByIdentifier(deviceId, out D3DDisplayDevice.D3DDeviceInfo deviceInfo))
                    {
                        _report.Append("GpuSharedLimit: ");
                        _report.AppendLine(deviceInfo.GpuSharedLimit.ToString(CultureInfo.InvariantCulture));
                        _report.Append("GpuSharedUsed: ");
                        _report.AppendLine(deviceInfo.GpuSharedUsed.ToString(CultureInfo.InvariantCulture));
                        _report.Append("GpuSharedMax: ");
                        _report.AppendLine(deviceInfo.GpuSharedMax.ToString(CultureInfo.InvariantCulture));
                        _report.Append("GpuDedicatedLimit: ");
                        _report.AppendLine(deviceInfo.GpuDedicatedLimit.ToString(CultureInfo.InvariantCulture));
                        _report.Append("GpuDedicatedUsed: ");
                        _report.AppendLine(deviceInfo.GpuDedicatedUsed.ToString(CultureInfo.InvariantCulture));
                        _report.Append("GpuDedicatedMax: ");
                        _report.AppendLine(deviceInfo.GpuDedicatedMax.ToString(CultureInfo.InvariantCulture));
                        _report.Append("Integrated: ");
                        _report.AppendLine(deviceInfo.Integrated.ToString(CultureInfo.InvariantCulture));

                        if (deviceInfo.Integrated)
                        {
                            // It may seem strange to only use the first cpu here, but in-case we have a multi cpu system with integrated graphics (does that exist?),
                            // we would pick up the multiple device identifiers above and would add one instance for each CPU.
                            _hardware.Add(new IntelIntegratedGpu(intelCpus[0], deviceId, deviceInfo, settings));
                        }
                    }

                    _report.AppendLine();
                }
            }
        }
    }

    public IReadOnlyList<IHardware> Hardware => _hardware;

    public string GetReport()
    {
        return _report.ToString();
    }

    public void Close()
    {
        foreach (Hardware gpu in _hardware)
            gpu.Close();

        // Shutdown Intel GCL
        try
        {
            if (IntelGcl.IsInitialized)
            {
                IntelGcl.Cleanup();
            }
        }
        catch
        {
            // Ignore shutdown errors
        }
    }
}

```

`LibreHardwareMonitorLib/Hardware/Gpu/IntelIntegratedGpu.cs`:

```cs
using System;
using System.Globalization;
using System.Linq;
using System.Runtime.InteropServices;
using LibreHardwareMonitor.Interop;
using LibreHardwareMonitor.PawnIo;
using Microsoft.Win32;

namespace LibreHardwareMonitor.Hardware.Gpu;

internal class IntelIntegratedGpu : GenericGpu
{
    private const uint MSR_PP1_ENERGY_STATUS = 0x641;

    private readonly Sensor _dedicatedMemoryUsage;
    private readonly Sensor _sharedMemoryLimit;
    private readonly Sensor _sharedMemoryFree;
    private readonly string _deviceId;
    private readonly float _energyUnitMultiplier;
    private readonly Sensor[] _nodeUsage;
    private readonly DateTime[] _nodeUsagePrevTick;
    private readonly long[] _nodeUsagePrevValue;
    private readonly Sensor _powerSensor;
    private readonly Sensor _sharedMemoryUsage;
    private readonly Sensor _gtCoresTemperature;
    private readonly Sensor _gpuClockFrequency;
    private readonly Sensor _gpuVoltage;

    private uint _lastEnergyConsumed;
    private DateTime _lastEnergyTime;

    private readonly IntelMsr _pawnModule;

    private readonly IntelGcl.ctl_device_adapter_handle_t? _igclHandle;

    public IntelIntegratedGpu(Cpu.IntelCpu intelCpu, string deviceId, D3DDisplayDevice.D3DDeviceInfo deviceInfo, ISettings settings)
        : base(GetName(deviceId),
               new Identifier("gpu-intel-integrated", deviceId.ToString(CultureInfo.InvariantCulture)),
               settings)
    {
        _pawnModule = new IntelMsr();
        _deviceId = deviceId;

        _igclHandle = FindIgclHandle();

        if (_igclHandle.HasValue && TryReadTelemetry(_igclHandle.Value, out IntelGcl.ctl_power_telemetry_t probeTelemetry))
        {
            if (probeTelemetry.gpuCurrentTemperature.bSupported)
            {
                _gtCoresTemperature = new Sensor("GPU Core", 0, SensorType.Temperature, this, settings);
                ActivateSensor(_gtCoresTemperature);
            }

            if (probeTelemetry.gpuCurrentClockFrequency.bSupported)
            {
                _gpuClockFrequency = new Sensor("GPU Core", 0, SensorType.Clock, this, settings);
                ActivateSensor(_gpuClockFrequency);
            }

            if (probeTelemetry.gpuVoltage.bSupported)
            {
                _gpuVoltage = new Sensor("GPU Core", 0, SensorType.Voltage, this, settings);
                ActivateSensor(_gpuVoltage);
            }
        }

        int memorySensorIndex = 0;

        if (deviceInfo.GpuDedicatedLimit > 0)
        {
            _dedicatedMemoryUsage = new Sensor("D3D Dedicated Memory Used", memorySensorIndex++, SensorType.SmallData, this, settings);
        }

        _sharedMemoryUsage = new Sensor("D3D Shared Memory Used", memorySensorIndex++, SensorType.SmallData, this, settings);

        if (deviceInfo.GpuSharedLimit > 0)
        {
            _sharedMemoryFree = new Sensor("D3D Shared Memory Free", memorySensorIndex++, SensorType.SmallData, this, settings);
            _sharedMemoryLimit = new Sensor("D3D Shared Memory Total", memorySensorIndex++, SensorType.SmallData, this, settings);
        }

        if (_pawnModule.ReadMsr(MSR_PP1_ENERGY_STATUS, out uint eax, out uint _))
        {
            _energyUnitMultiplier = intelCpu.EnergyUnitsMultiplier;
            if (_energyUnitMultiplier != 0)
            {
                _lastEnergyTime = DateTime.UtcNow;
                _lastEnergyConsumed = eax;
                _powerSensor = new Sensor("GPU Power", 0, SensorType.Power, this, settings);
                ActivateSensor(_powerSensor);
            }
        }

        _nodeUsage = new Sensor[deviceInfo.Nodes.Length];
        _nodeUsagePrevValue = new long[deviceInfo.Nodes.Length];
        _nodeUsagePrevTick = new DateTime[deviceInfo.Nodes.Length];

        int nodeSensorIndex = 0;
        foreach (D3DDisplayDevice.D3DDeviceNodeInfo node in deviceInfo.Nodes.OrderBy(x => x.Name))
        {
            _nodeUsage[node.Id] = new Sensor(node.Name, nodeSensorIndex++, SensorType.Load, this, settings);
            _nodeUsagePrevValue[node.Id] = node.RunningTime;
            _nodeUsagePrevTick[node.Id] = node.QueryTime;
        }
    }

    /// <inheritdoc />
    public override string DeviceId => D3DDisplayDevice.GetActualDeviceIdentifier(_deviceId);

    public override HardwareType HardwareType => HardwareType.GpuIntel;

    public override void Update()
    {
        // Update IGCL telemetry (temperature, clock, voltage).
        if (_igclHandle.HasValue && (_gtCoresTemperature != null || _gpuClockFrequency != null || _gpuVoltage != null))
        {
            if (TryReadTelemetry(_igclHandle.Value, out IntelGcl.ctl_power_telemetry_t telemetry))
            {
                UpdateSensorFromTelemetry(telemetry.gpuCurrentTemperature, _gtCoresTemperature);
                UpdateSensorFromTelemetry(telemetry.gpuCurrentClockFrequency, _gpuClockFrequency);
                UpdateSensorFromTelemetry(telemetry.gpuVoltage, _gpuVoltage);
            }
            else
            {
                if (_gtCoresTemperature != null) _gtCoresTemperature.Value = null;
                if (_gpuClockFrequency != null) _gpuClockFrequency.Value = null;
                if (_gpuVoltage != null) _gpuVoltage.Value = null;
            }
        }

        if (D3DDisplayDevice.GetDeviceInfoByIdentifier(_deviceId, out D3DDisplayDevice.D3DDeviceInfo deviceInfo))
        {
            if (_dedicatedMemoryUsage != null)
            {
                _dedicatedMemoryUsage.Value = 1f * deviceInfo.GpuDedicatedUsed / 1024 / 1024;
                ActivateSensor(_dedicatedMemoryUsage);
            }

            if (_sharedMemoryLimit != null)
            {
                _sharedMemoryLimit.Value = 1f * deviceInfo.GpuSharedLimit / 1024 / 1024;
                ActivateSensor(_sharedMemoryLimit);
                if (_sharedMemoryUsage != null)
                {
                    _sharedMemoryFree.Value = _sharedMemoryLimit.Value - _sharedMemoryUsage.Value;
                    ActivateSensor(_sharedMemoryFree);
                }
            }

            _sharedMemoryUsage.Value = 1f * deviceInfo.GpuSharedUsed / 1024 / 1024;
            ActivateSensor(_sharedMemoryUsage);

            if (_powerSensor != null && _pawnModule.ReadMsr(MSR_PP1_ENERGY_STATUS, out uint eax, out uint _))
            {
                DateTime time = DateTime.UtcNow;
                float deltaTime = (float)(time - _lastEnergyTime).TotalSeconds;
                if (deltaTime >= 0.01)
                {
                    _powerSensor.Value = _energyUnitMultiplier * unchecked(eax - _lastEnergyConsumed) / deltaTime;
                    _lastEnergyTime = time;
                    _lastEnergyConsumed = eax;
                }
            }

            if (_nodeUsage.Length == deviceInfo.Nodes.Length)
            {
                foreach (D3DDisplayDevice.D3DDeviceNodeInfo node in deviceInfo.Nodes)
                {
                    long runningTimeDiff = node.RunningTime - _nodeUsagePrevValue[node.Id];
                    long timeDiff = node.QueryTime.Ticks - _nodeUsagePrevTick[node.Id].Ticks;

                    _nodeUsage[node.Id].Value = 100f * runningTimeDiff / timeDiff;
                    _nodeUsagePrevValue[node.Id] = node.RunningTime;
                    _nodeUsagePrevTick[node.Id] = node.QueryTime;
                    ActivateSensor(_nodeUsage[node.Id]);
                }
            }
        }
    }

    /// <inheritdoc />
    public override void Close()
    {
        base.Close();
        _pawnModule.Close();
    }

    private static bool TryReadTelemetry(IntelGcl.ctl_device_adapter_handle_t handle, out IntelGcl.ctl_power_telemetry_t telemetry)
    {
        telemetry = new IntelGcl.ctl_power_telemetry_t
        {
            Size = (uint)Marshal.SizeOf<IntelGcl.ctl_power_telemetry_t>(),
            Version = 1,
            psu = new IntelGcl.ctl_psu_info_t[IntelGcl.CTL_PSU_COUNT],
            fanSpeed = new IntelGcl.ctl_oc_telemetry_item_t[IntelGcl.CTL_FAN_COUNT]
        };

        int result = IntelGcl.ctlPowerTelemetryGet(handle, ref telemetry);
        return result == (int)IntelGcl.ctl_result_t.CTL_RESULT_SUCCESS;
    }

    private static void UpdateSensorFromTelemetry(IntelGcl.ctl_oc_telemetry_item_t telemetryItem, Sensor sensor)
    {
        if (sensor == null)
            return;

        if (telemetryItem.bSupported)
        {
            double value = GetTelemetryValue(telemetryItem);
            sensor.Value = double.IsNaN(value) ? null : (float)value;
        }
        else
        {
            sensor.Value = null;
        }
    }

    private static double GetTelemetryValue(IntelGcl.ctl_oc_telemetry_item_t item)
    {
        return item.type switch
        {
            IntelGcl.ctl_data_type_t.CTL_DATA_TYPE_FLOAT => item.value.datafloat,
            IntelGcl.ctl_data_type_t.CTL_DATA_TYPE_DOUBLE => item.value.datadouble,
            IntelGcl.ctl_data_type_t.CTL_DATA_TYPE_UINT32 => item.value.datau32,
            IntelGcl.ctl_data_type_t.CTL_DATA_TYPE_INT32 => item.value.data32,
            IntelGcl.ctl_data_type_t.CTL_DATA_TYPE_UINT64 => item.value.datau64,
            IntelGcl.ctl_data_type_t.CTL_DATA_TYPE_INT64 => item.value.data64,
            IntelGcl.ctl_data_type_t.CTL_DATA_TYPE_UINT16 => item.value.datau16,
            IntelGcl.ctl_data_type_t.CTL_DATA_TYPE_INT16 => item.value.data16,
            IntelGcl.ctl_data_type_t.CTL_DATA_TYPE_UINT8 => item.value.datau8,
            IntelGcl.ctl_data_type_t.CTL_DATA_TYPE_INT8 => item.value.data8,
            _ => double.NaN
        };
    }

    private static IntelGcl.ctl_device_adapter_handle_t? FindIgclHandle()
    {
        if (!IntelGcl.IsInitialized)
            return null;

        IntelGcl.ctl_device_adapter_handle_t[] handles = IntelGcl.GetDeviceHandles();

        foreach (IntelGcl.ctl_device_adapter_handle_t handle in handles)
        {
            var properties = new IntelGcl.ctl_device_adapter_properties_t
            {
                Size = (uint)Marshal.SizeOf<IntelGcl.ctl_device_adapter_properties_t>(),
                Version = 2
            };

            int result = IntelGcl.ctlGetDeviceProperties(handle, ref properties);

            if (result != (int)IntelGcl.ctl_result_t.CTL_RESULT_SUCCESS)
                continue;

            if (properties.device_type != IntelGcl.ctl_device_type_t.CTL_DEVICE_TYPE_GRAPHICS)
                continue;

            // Use the IGCL integrated-adapter flag — the same method IntelGpuGroup uses
            // to filter iGPUs out of the discrete GPU enumeration path.
            if ((properties.graphics_adapter_properties & (uint)IntelGcl.ctl_adapter_properties_flag_t.CTL_ADAPTER_PROPERTIES_FLAG_INTEGRATED) != 0)
            {
                return handle;
            }
        }

        return null;
    }

    private static string GetName(string deviceId)
    {
        string path = @"HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Enum\" + D3DDisplayDevice.GetActualDeviceIdentifier(deviceId);

        if (Registry.GetValue(path, "DeviceDesc", null) is string deviceDesc)
        {
            return deviceDesc.Split(';').Last();
        }

        return "Intel Integrated Graphics";
    }
}

```

`LibreHardwareMonitorLib/Hardware/Gpu/NvidiaGpu.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using LibreHardwareMonitor.Interop;
using Microsoft.Win32;

namespace LibreHardwareMonitor.Hardware.Gpu;

internal sealed class NvidiaGpu : GenericGpu
{
    private readonly int _adapterIndex;
    private readonly Sensor[] _clocks;
    private readonly int _clockVersion;
    private readonly Sensor[] _controls;
    private readonly string _d3dDeviceId;
    private readonly NvApi.NvDisplayHandle? _displayHandle;
    private readonly Control[] _fanControls;
    private readonly Sensor[] _fans;
    private readonly Sensor _gpuDedicatedMemoryUsage;
    private readonly Sensor[] _gpuNodeUsage;
    private readonly DateTime[] _gpuNodeUsagePrevTick;
    private readonly long[] _gpuNodeUsagePrevValue;
    private readonly Sensor _gpuSharedMemoryUsage;
    private readonly NvApi.NvPhysicalGpuHandle _handle;
    private readonly Sensor _hotSpotTemperature;
    private readonly Sensor[] _loads;
    private readonly Sensor _memoryFree;
    private readonly Sensor _memoryJunctionTemperature;
    private readonly Sensor _memoryTotal;
    private readonly Sensor _memoryUsed;
    private readonly Sensor _memoryLoad;
    private readonly NvidiaML.NvmlDevice? _nvmlDevice;
    private readonly Sensor _pcieThroughputRx;
    private readonly Sensor _pcieThroughputTx;
    private readonly Sensor[] _powers;
    private readonly Sensor _powerUsage;
    private readonly Sensor _coreVoltage;
    private readonly Sensor[] _temperatures;
    private readonly uint _thermalSensorsMask;
    private readonly Sensor[] _12VHPwrPinCurrentSensors;
    private readonly Sensor[] _12VHPwrPinVoltageSensors;
    private readonly Sensor[] _12VHPwrPinPowerSensors;
    private readonly Sensor _12VHPwrConnectorPowerSensor;
    private readonly Sensor _12VHPwrConnectorCurrentSensor;

    // ASUS Astral subsystem IDs for 12VHPwr pin monitoring
    private static readonly uint[] AstralSubSystemIds =
    [
        0x89EA1043, // Astral 5090D OC
        0x8A611043, // Astral 5090 Matrix
        0x89EC1043, // Astral 5090 LC
        0x89E31043, // Astral 5090 OC
        0x89DE1043, // Astral 5080 OC
    ];

    public NvidiaGpu(int adapterIndex, NvApi.NvPhysicalGpuHandle handle, NvApi.NvDisplayHandle? displayHandle, ISettings settings)
        : base(GetName(handle),
               new Identifier("gpu-nvidia", adapterIndex.ToString(CultureInfo.InvariantCulture)),
               settings)
    {
        _adapterIndex = adapterIndex;
        _handle = handle;
        _displayHandle = displayHandle;

        bool hasBusId = NvApi.NvAPI_GPU_GetBusId(handle, out uint busId) == NvApi.NvStatus.OK;

        // Thermal settings.
        NvApi.NvThermalSettings thermalSettings = GetThermalSettings(out NvApi.NvStatus status);
        if (status == NvApi.NvStatus.OK && thermalSettings.Count > 0)
        {
            _temperatures = new Sensor[thermalSettings.Count];

            for (int i = 0; i < thermalSettings.Count; i++)
            {
                NvApi.NvSensor sensor = thermalSettings.Sensor[i];

                string name = sensor.Target switch
                {
                    NvApi.NvThermalTarget.Gpu => "GPU Core",
                    NvApi.NvThermalTarget.Memory => "GPU Memory",
                    NvApi.NvThermalTarget.PowerSupply => "GPU Power Supply",
                    NvApi.NvThermalTarget.Board => "GPU Board",
                    NvApi.NvThermalTarget.VisualComputingBoard => "GPU Visual Computing Board",
                    NvApi.NvThermalTarget.VisualComputingInlet => "GPU Visual Computing Inlet",
                    NvApi.NvThermalTarget.VisualComputingOutlet => "GPU Visual Computing Outlet",
                    _ => "GPU"
                };

                _temperatures[i] = new Sensor(name, i, SensorType.Temperature, this, Array.Empty<ParameterDescription>(), settings);
                ActivateSensor(_temperatures[i]);
            }
        }

        // Thermal sensors.
        _hotSpotTemperature = new Sensor("GPU Hot Spot", (int)thermalSettings.Count + 1, SensorType.Temperature, this, settings);
        _memoryJunctionTemperature = new Sensor("GPU Memory Junction", (int)thermalSettings.Count + 2, SensorType.Temperature, this, settings);
        bool hasAnyThermalSensor = false;

        for (int thermalSensorsMaxBit = 0; thermalSensorsMaxBit < 32; thermalSensorsMaxBit++)
        {
            // Find the maximum thermal sensor mask value.
            _thermalSensorsMask = 1u << thermalSensorsMaxBit;

            GetThermalSensors(_thermalSensorsMask, out NvApi.NvStatus thermalSensorsStatus);
            if (thermalSensorsStatus == NvApi.NvStatus.OK)
            {
                hasAnyThermalSensor = true;
                continue;
            }

            _thermalSensorsMask--;
            break;
        }

        if (!hasAnyThermalSensor)
        {
            _thermalSensorsMask = 0;
        }

        // Clock frequencies.
        for (int clockVersion = 1; clockVersion <= 3; clockVersion++)
        {
            _clockVersion = clockVersion;

            NvApi.NvGpuClockFrequencies clockFrequencies = GetClockFrequencies(out status);
            if (status == NvApi.NvStatus.OK)
            {
                var clocks = new List<Sensor>();
                for (int i = 0; i < clockFrequencies.Clocks.Length; i++)
                {
                    NvApi.NvGpuClockFrequenciesDomain clock = clockFrequencies.Clocks[i];
                    if (clock.IsPresent && Enum.IsDefined(typeof(NvApi.NvGpuPublicClockId), i))
                    {
                        var clockId = (NvApi.NvGpuPublicClockId)i;
                        string name = clockId switch
                        {
                            NvApi.NvGpuPublicClockId.Graphics => "GPU Core",
                            NvApi.NvGpuPublicClockId.Memory => "GPU Memory",
                            NvApi.NvGpuPublicClockId.Processor => "GPU Shader",
                            NvApi.NvGpuPublicClockId.Video => "GPU Video",
                            _ => null
                        };

                        if (name != null)
                            clocks.Add(new Sensor(name, i, SensorType.Clock, this, settings));
                    }
                }

                if (clocks.Count > 0)
                {
                    _clocks = clocks.ToArray();

                    foreach (Sensor sensor in clocks)
                        ActivateSensor(sensor);

                    break;
                }
            }
        }

        // Fans + controllers.
        NvApi.NvFanCoolersStatus fanCoolers = GetFanCoolersStatus(out status);
        if (status == NvApi.NvStatus.OK && fanCoolers.Count > 0)
        {
            _fans = new Sensor[fanCoolers.Count];

            for (int i = 0; i < fanCoolers.Count; i++)
            {
                NvApi.NvFanCoolersStatusItem item = fanCoolers.Items[i];

                string name = "GPU Fan" + (fanCoolers.Count > 1 ? " " + (i + 1) : string.Empty);

                _fans[i] = new Sensor(name, (int)item.CoolerId, SensorType.Fan, this, settings);
                ActivateSensor(_fans[i]);
            }
        }
        else
        {
            GetTachReading(out status);
            if (status == NvApi.NvStatus.OK)
            {
                _fans = new[] { new Sensor("GPU", 1, SensorType.Fan, this, settings) };
                ActivateSensor(_fans[0]);
            }
        }

        NvApi.NvFanCoolerControl fanControllers = GetFanCoolersControllers(out status);
        if (status == NvApi.NvStatus.OK && fanControllers.Count > 0 && fanCoolers.Count > 0)
        {
            _controls = new Sensor[fanControllers.Count];
            _fanControls = new Control[fanControllers.Count];

            for (int i = 0; i < fanControllers.Count; i++)
            {
                NvApi.NvFanCoolerControlItem item = fanControllers.Items[i];

                string name = "GPU Fan" + (fanControllers.Count > 1 ? " " + (i + 1) : string.Empty);

                NvApi.NvFanCoolersStatusItem fanItem = Array.Find(fanCoolers.Items, x => x.CoolerId == item.CoolerId);
                if (!fanItem.Equals(default(NvApi.NvFanCoolersStatusItem)))
                {
                    _controls[i] = new Sensor(name, (int)item.CoolerId, SensorType.Control, this, settings);
                    ActivateSensor(_controls[i]);

                    _fanControls[i] = new Control(_controls[i], settings, fanItem.CurrentMinLevel, fanItem.CurrentMaxLevel);
                    _fanControls[i].ControlModeChanged += ControlModeChanged;
                    _fanControls[i].SoftwareControlValueChanged += SoftwareControlValueChanged;
                    _controls[i].Control = _fanControls[i];

                    ControlModeChanged(_fanControls[i]);
                }
            }
        }
        else
        {
            NvApi.NvCoolerSettings coolerSettings = GetCoolerSettings(out status);
            if (status == NvApi.NvStatus.OK && coolerSettings.Count > 0)
            {
                _controls = new Sensor[coolerSettings.Count];
                _fanControls = new Control[coolerSettings.Count];

                for (int i = 0; i < coolerSettings.Count; i++)
                {
                    NvApi.NvCooler cooler = coolerSettings.Cooler[i];
                    string name = "GPU Fan" + (coolerSettings.Count > 1 ? " " + cooler.Controller : string.Empty);

                    _controls[i] = new Sensor(name, i, SensorType.Control, this, settings);
                    ActivateSensor(_controls[i]);

                    _fanControls[i] = new Control(_controls[i], settings, cooler.DefaultMin, cooler.DefaultMax);
                    _fanControls[i].ControlModeChanged += ControlModeChanged;
                    _fanControls[i].SoftwareControlValueChanged += SoftwareControlValueChanged;
                    _controls[i].Control = _fanControls[i];

                    ControlModeChanged(_fanControls[i]);
                }
            }
        }

        // Load usages.
        NvApi.NvDynamicPStatesInfo pStatesInfo = GetDynamicPstatesInfoEx(out status);
        if (status == NvApi.NvStatus.OK)
        {
            var loads = new List<Sensor>();
            for (int index = 0; index < pStatesInfo.Utilizations.Length; index++)
            {
                NvApi.NvDynamicPState load = pStatesInfo.Utilizations[index];
                if (load.IsPresent && Enum.IsDefined(typeof(NvApi.NvUtilizationDomain), index))
                {
                    var utilizationDomain = (NvApi.NvUtilizationDomain)index;
                    string name = GetUtilizationDomainName(utilizationDomain);

                    if (name != null)
                        loads.Add(new Sensor(name, index, SensorType.Load, this, settings));
                }
            }

            if (loads.Count > 0)
            {
                _loads = loads.ToArray();

                foreach (Sensor sensor in loads)
                    ActivateSensor(sensor);
            }
        }
        else
        {
            NvApi.NvUsages usages = GetUsages(out status);
            if (status == NvApi.NvStatus.OK)
            {
                var loads = new List<Sensor>();
                for (int index = 0; index < usages.Entries.Length; index++)
                {
                    NvApi.NvUsagesEntry load = usages.Entries[index];
                    if (load.IsPresent > 0 && Enum.IsDefined(typeof(NvApi.NvUtilizationDomain), index))
                    {
                        var utilizationDomain = (NvApi.NvUtilizationDomain)index;
                        string name = GetUtilizationDomainName(utilizationDomain);

                        if (name != null)
                            loads.Add(new Sensor(name, index, SensorType.Load, this, settings));
                    }
                }

                if (loads.Count > 0)
                {
                    _loads = loads.ToArray();

                    foreach (Sensor sensor in loads)
                        ActivateSensor(sensor);
                }
            }
        }

        // Power.
        NvApi.NvPowerTopology powerTopology = GetPowerTopology(out NvApi.NvStatus powerStatus);
        if (powerStatus == NvApi.NvStatus.OK && powerTopology.Count > 0)
        {
            _powers = new Sensor[powerTopology.Count];
            for (int i = 0; i < powerTopology.Count; i++)
            {
                NvApi.NvPowerTopologyEntry entry = powerTopology.Entries[i];
                string name = entry.Domain switch
                {
                    NvApi.NvPowerTopologyDomain.Gpu => "GPU Power",
                    NvApi.NvPowerTopologyDomain.Board => "GPU Board Power",
                    _ => null
                };

                if (name != null)
                {
                    _powers[i] = new Sensor(name, i + (_loads?.Length ?? 0), SensorType.Load, this, settings);
                    ActivateSensor(_powers[i]);
                }
            }
        }

        // Voltage
        var voltageSensor = GetVoltRailsStatus(out status);
        if (status == NvApi.NvStatus.OK)
        {
            _coreVoltage = new Sensor("GPU Core Voltage", 0, SensorType.Voltage, this, settings);

            ActivateSensor(_coreVoltage);
        }

        if (NvidiaML.IsAvailable || NvidiaML.Initialize())
        {
            if (hasBusId)
                _nvmlDevice = NvidiaML.NvmlDeviceGetHandleByPciBusId($" 0000:{busId:X2}:00.0") ?? NvidiaML.NvmlDeviceGetHandleByIndex(_adapterIndex);
            else
                _nvmlDevice = NvidiaML.NvmlDeviceGetHandleByIndex(_adapterIndex);

            if (_nvmlDevice.HasValue)
            {
                _powerUsage = new Sensor("GPU Package", 0, SensorType.Power, this, settings);

                _pcieThroughputRx = new Sensor("GPU PCIe Rx", 0, SensorType.Throughput, this, settings);
                _pcieThroughputTx = new Sensor("GPU PCIe Tx", 1, SensorType.Throughput, this, settings);

                if (!Software.OperatingSystem.IsUnix)
                {
                    NvidiaML.NvmlPciInfo? pciInfo = NvidiaML.NvmlDeviceGetPciInfo(_nvmlDevice.Value);

                    if (pciInfo is { } pci)
                    {
                        string[] deviceIds = D3DDisplayDevice.GetDeviceIdentifiers();
                        if (deviceIds != null)
                        {
                            foreach (string deviceId in deviceIds)
                            {
                                if (deviceId.IndexOf("VEN_" + pci.pciVendorId.ToString("X"), StringComparison.OrdinalIgnoreCase) != -1 &&
                                    deviceId.IndexOf("DEV_" + pci.pciDeviceId.ToString("X"), StringComparison.OrdinalIgnoreCase) != -1 &&
                                    deviceId.IndexOf("SUBSYS_" + pci.pciSubSystemId.ToString("X"), StringComparison.OrdinalIgnoreCase) != -1)
                                {
                                    bool isMatch = false;

                                    string actualDeviceId = D3DDisplayDevice.GetActualDeviceIdentifier(deviceId);

                                    try
                                    {
                                        if (Registry.GetValue(@"HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\nvlddmkm\Enum", adapterIndex.ToString(), null) is string adapterPnpId)
                                        {
                                            if (actualDeviceId.IndexOf(adapterPnpId, StringComparison.OrdinalIgnoreCase) != -1 ||
                                                adapterPnpId.IndexOf(actualDeviceId, StringComparison.OrdinalIgnoreCase) != -1)
                                            {
                                                isMatch = true;
                                            }
                                        }
                                    }
                                    catch
                                    {
                                        // Ignored.
                                    }

                                    if (!isMatch)
                                    {
                                        try
                                        {
                                            string path = actualDeviceId;
                                            path = @"HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Enum\" + path;

                                            if (Registry.GetValue(path, "LocationInformation", null) is string locationInformation)
                                            {
                                                // For example:
                                                // @System32\drivers\pci.sys,#65536;PCI bus %1, device %2, function %3;(38,0,0)

                                                int index = locationInformation.IndexOf('(');
                                                if (index != -1)
                                                {
                                                    index++;
                                                    int secondIndex = locationInformation.IndexOf(',', index);
                                                    if (secondIndex != -1)
                                                    {
                                                        string bus = locationInformation.Substring(index, secondIndex - index);

                                                        if (pci.bus.ToString() == bus)
                                                            isMatch = true;
                                                    }
                                                }
                                            }
                                        }
                                        catch
                                        {
                                            // Ignored.
                                        }
                                    }

                                    if (isMatch && D3DDisplayDevice.GetDeviceInfoByIdentifier(deviceId, out D3DDisplayDevice.D3DDeviceInfo deviceInfo))
                                    {
                                        int sensorCount = (_loads?.Length ?? 0) + (_powers?.Length ?? 0);
                                        int loadSensorIndex = sensorCount > 0 ? sensorCount + 1 : 0;
                                        int smallDataSensorIndex = 3; // There are three normal GPU memory sensors.

                                        _d3dDeviceId = deviceId;

                                        _gpuDedicatedMemoryUsage = new Sensor("D3D Dedicated Memory Used", smallDataSensorIndex++, SensorType.SmallData, this, settings);
                                        _gpuSharedMemoryUsage = new Sensor("D3D Shared Memory Used", smallDataSensorIndex, SensorType.SmallData, this, settings);

                                        _gpuNodeUsage = new Sensor[deviceInfo.Nodes.Length];
                                        _gpuNodeUsagePrevValue = new long[deviceInfo.Nodes.Length];
                                        _gpuNodeUsagePrevTick = new DateTime[deviceInfo.Nodes.Length];

                                        foreach (D3DDisplayDevice.D3DDeviceNodeInfo node in deviceInfo.Nodes.OrderBy(x => x.Name))
                                        {
                                            _gpuNodeUsage[node.Id] = new Sensor(node.Name, loadSensorIndex++, SensorType.Load, this, settings);
                                            _gpuNodeUsagePrevValue[node.Id] = node.RunningTime;
                                            _gpuNodeUsagePrevTick[node.Id] = node.QueryTime;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        _memoryFree = new Sensor("GPU Memory Free", 0, SensorType.SmallData, this, settings);
        _memoryUsed = new Sensor("GPU Memory Used", 1, SensorType.SmallData, this, settings);
        _memoryTotal = new Sensor("GPU Memory Total", 2, SensorType.SmallData, this, settings);
        _memoryLoad = new Sensor("GPU Memory", 3, SensorType.Load, this, settings);

        // Pin power sensors for NVIDIA RTX Astral series from ASUS
        if (NvApi.NvAPI_I2CReadEx != null && NvApi.NvAPI_GPU_GetPCIIdentifiers != null)
        {
            NvApi.NvStatus pciIdentifierStatus = NvApi.NvAPI_GPU_GetPCIIdentifiers(_handle, out _, out uint subSystemId, out _, out _);

            if (pciIdentifierStatus == NvApi.NvStatus.OK && AstralSubSystemIds.Contains(subSystemId))
            {
                _12VHPwrPinVoltageSensors =
                [
                    new Sensor("12VHPWR Pin 1", 0, SensorType.Voltage, this, settings),
                    new Sensor("12VHPWR Pin 2", 1, SensorType.Voltage, this, settings),
                    new Sensor("12VHPWR Pin 3", 2, SensorType.Voltage, this, settings),
                    new Sensor("12VHPWR Pin 4", 3, SensorType.Voltage, this, settings),
                    new Sensor("12VHPWR Pin 5", 4, SensorType.Voltage, this, settings),
                    new Sensor("12VHPWR Pin 6", 5, SensorType.Voltage, this, settings),
                ];
                _12VHPwrPinCurrentSensors =
                [
                    new Sensor("12VHPWR Pin 1", 1, SensorType.Current, this, settings),
                    new Sensor("12VHPWR Pin 2", 2, SensorType.Current, this, settings),
                    new Sensor("12VHPWR Pin 3", 3, SensorType.Current, this, settings),
                    new Sensor("12VHPWR Pin 4", 4, SensorType.Current, this, settings),
                    new Sensor("12VHPWR Pin 5", 5, SensorType.Current, this, settings),
                    new Sensor("12VHPWR Pin 6", 6, SensorType.Current, this, settings),
                ];
                _12VHPwrPinPowerSensors =
                [
                    new Sensor("12VHPWR Pin 1", 2, SensorType.Power, this, settings),
                    new Sensor("12VHPWR Pin 2", 3, SensorType.Power, this, settings),
                    new Sensor("12VHPWR Pin 3", 4, SensorType.Power, this, settings),
                    new Sensor("12VHPWR Pin 4", 5, SensorType.Power, this, settings),
                    new Sensor("12VHPWR Pin 5", 6, SensorType.Power, this, settings),
                    new Sensor("12VHPWR Pin 6", 7, SensorType.Power, this, settings),
                ];

                foreach (Sensor sensor in _12VHPwrPinVoltageSensors)
                    ActivateSensor(sensor);

                foreach (Sensor sensor in _12VHPwrPinCurrentSensors)
                    ActivateSensor(sensor);

                foreach (Sensor sensor in _12VHPwrPinPowerSensors)
                    ActivateSensor(sensor);

                _12VHPwrConnectorPowerSensor = new Sensor("12VHPWR Connector", 1, SensorType.Power, this, settings);
                _12VHPwrConnectorCurrentSensor = new Sensor("12VHPWR Connector", 0, SensorType.Current, this, settings);

                ActivateSensor(_12VHPwrConnectorPowerSensor);
                ActivateSensor(_12VHPwrConnectorCurrentSensor);
            }
        }

        Update();
    }

    /// <inheritdoc />
    public override string DeviceId
    {
        get
        {
            return _d3dDeviceId != null ? D3DDisplayDevice.GetActualDeviceIdentifier(_d3dDeviceId) : null;
        }
    }

    public override HardwareType HardwareType
    {
        get { return HardwareType.GpuNvidia; }
    }

    public override void Update()
    {
        if (_d3dDeviceId != null && D3DDisplayDevice.GetDeviceInfoByIdentifier(_d3dDeviceId, out D3DDisplayDevice.D3DDeviceInfo deviceInfo))
        {
            _gpuDedicatedMemoryUsage.Value = 1f * deviceInfo.GpuDedicatedUsed / 1024 / 1024;
            _gpuSharedMemoryUsage.Value = 1f * deviceInfo.GpuSharedUsed / 1024 / 1024;
            ActivateSensor(_gpuDedicatedMemoryUsage);
            ActivateSensor(_gpuSharedMemoryUsage);

            foreach (D3DDisplayDevice.D3DDeviceNodeInfo node in deviceInfo.Nodes)
            {
                long runningTimeDiff = node.RunningTime - _gpuNodeUsagePrevValue[node.Id];
                long timeDiff = node.QueryTime.Ticks - _gpuNodeUsagePrevTick[node.Id].Ticks;

                _gpuNodeUsage[node.Id].Value = 100f * runningTimeDiff / timeDiff;
                _gpuNodeUsagePrevValue[node.Id] = node.RunningTime;
                _gpuNodeUsagePrevTick[node.Id] = node.QueryTime;
                ActivateSensor(_gpuNodeUsage[node.Id]);
            }
        }

        NvApi.NvStatus status;

        if (_temperatures is { Length: > 0 })
        {
            NvApi.NvThermalSettings settings = GetThermalSettings(out status);
            // settings.Count is 0 when no valid data available, this happens when you try to read out this value with a high polling interval.
            if (status == NvApi.NvStatus.OK && settings.Count > 0)
            {
                foreach (Sensor sensor in _temperatures)
                    sensor.Value = settings.Sensor[sensor.Index].CurrentTemp;
            }
        }

        if (_thermalSensorsMask > 0)
        {
            NvApi.NvThermalSensors thermalSensors = GetThermalSensors(_thermalSensorsMask, out status);

            if (status == NvApi.NvStatus.OK)
            {
                // RTX 50xx series
                if (Name.StartsWith("NVIDIA GeForce RTX 50", StringComparison.OrdinalIgnoreCase))
                {
                    _hotSpotTemperature.Value = 0;
                    _temperatures[0].Value = thermalSensors.Temperatures[1] / 256.0f;
                    _memoryJunctionTemperature.Value = thermalSensors.Temperatures[2] / 256.0f;
                }
                // RTX 40xx series
                else if (Name.StartsWith("NVIDIA GeForce RTX 40", StringComparison.OrdinalIgnoreCase))
                {
                    _hotSpotTemperature.Value = thermalSensors.Temperatures[1] / 256.0f;
                    _memoryJunctionTemperature.Value = thermalSensors.Temperatures[7] / 256.0f;
                }
                else
                {
                    _hotSpotTemperature.Value = thermalSensors.Temperatures[1] / 256.0f;
                    _memoryJunctionTemperature.Value = thermalSensors.Temperatures[9] / 256.0f;
                }
            }

            if (_hotSpotTemperature.Value != 0)
                ActivateSensor(_hotSpotTemperature);

            if (_memoryJunctionTemperature.Value != 0)
                ActivateSensor(_memoryJunctionTemperature);
        }
        else
        {
            _hotSpotTemperature.Value = null;
            _memoryJunctionTemperature.Value = null;
        }

        if (_clocks is { Length: > 0 })
        {
            NvApi.NvGpuClockFrequencies clockFrequencies = GetClockFrequencies(out status);
            if (status == NvApi.NvStatus.OK)
            {
                int current = 0;
                for (int i = 0; i < clockFrequencies.Clocks.Length; i++)
                {
                    NvApi.NvGpuClockFrequenciesDomain clock = clockFrequencies.Clocks[i];
                    if (clock.IsPresent && Enum.IsDefined(typeof(NvApi.NvGpuPublicClockId), i))
                        _clocks[current++].Value = clock.Frequency / 1000f;
                }
            }
        }

        if (_fans is { Length: > 0 })
        {
            NvApi.NvFanCoolersStatus fanCoolers = GetFanCoolersStatus(out status);
            if (status == NvApi.NvStatus.OK && fanCoolers.Count > 0)
            {
                for (int i = 0; i < fanCoolers.Count; i++)
                {
                    NvApi.NvFanCoolersStatusItem item = fanCoolers.Items[i];
                    _fans[i].Value = item.CurrentRpm;
                }
            }
            else
            {
                int tachReading = GetTachReading(out status);
                if (status == NvApi.NvStatus.OK)
                    _fans[0].Value = tachReading;
            }
        }

        if (_controls is { Length: > 0 })
        {
            NvApi.NvFanCoolersStatus fanCoolers = GetFanCoolersStatus(out status);
            if (status == NvApi.NvStatus.OK && fanCoolers.Count > 0 && fanCoolers.Count == _controls.Length)
            {
                for (int i = 0; i < fanCoolers.Count; i++)
                {
                    NvApi.NvFanCoolersStatusItem item = fanCoolers.Items[i];

                    if (Array.Find(_controls, c => c.Index == item.CoolerId) is { } control)
                        control.Value = item.CurrentLevel;
                }
            }
            else
            {
                NvApi.NvCoolerSettings coolerSettings = GetCoolerSettings(out status);
                if (status == NvApi.NvStatus.OK && coolerSettings.Count > 0)
                {
                    for (int i = 0; i < coolerSettings.Count; i++)
                    {
                        NvApi.NvCooler cooler = coolerSettings.Cooler[i];
                        _controls[i].Value = cooler.CurrentLevel;
                    }
                }
            }
        }

        if (_loads is { Length: > 0 })
        {
            NvApi.NvDynamicPStatesInfo pStatesInfo = GetDynamicPstatesInfoEx(out status);
            if (status == NvApi.NvStatus.OK)
            {
                for (int index = 0; index < pStatesInfo.Utilizations.Length; index++)
                {
                    NvApi.NvDynamicPState load = pStatesInfo.Utilizations[index];
                    if (load.IsPresent && Enum.IsDefined(typeof(NvApi.NvUtilizationDomain), index))
                        _loads[index].Value = load.Percentage;
                }
            }
            else
            {
                NvApi.NvUsages usages = GetUsages(out status);
                if (status == NvApi.NvStatus.OK)
                {
                    for (int index = 0; index < usages.Entries.Length; index++)
                    {
                        NvApi.NvUsagesEntry load = usages.Entries[index];
                        if (load.IsPresent > 0 && Enum.IsDefined(typeof(NvApi.NvUtilizationDomain), index))
                            _loads[index].Value = load.Percentage;
                    }
                }
            }
        }

        if (_powers is { Length: > 0 })
        {
            NvApi.NvPowerTopology powerTopology = GetPowerTopology(out status);
            if (status == NvApi.NvStatus.OK && powerTopology.Count > 0)
            {
                for (int i = 0; i < powerTopology.Count; i++)
                {
                    NvApi.NvPowerTopologyEntry entry = powerTopology.Entries[i];
                    _powers[i].Value = entry.PowerUsage / 1000f;
                }
            }
        }

        if (_coreVoltage != null)
        {
            var voltageSensor = GetVoltRailsStatus(out status);
            if (status == NvApi.NvStatus.OK)
            {
                var microvolts = ((ulong)voltageSensor.CoreMicrovoltsHigh << 32) | voltageSensor.CoreMicrovolts;

                _coreVoltage.Value = microvolts == 0 ? 0 : microvolts / 1_000_000f;
            }
        }

        if (NvApi.NvAPI_GPU_GetMemoryInfoEx != null || _displayHandle != null)
        {
            uint free = 0;
            uint total = 0;

            //Size in bytes
            NvApi.NvMemoryInfoEx memoryInfoEx = GetMemoryInfoEx(out status);
            if (status == NvApi.NvStatus.OK)
            {
                free = (uint)(memoryInfoEx.CurrentAvailableDedicatedVideoMemory / 1024);
                total = (uint)(memoryInfoEx.DedicatedVideoMemory / 1024);
            }
            else
            {
                //Size in kilobytes, fallback for older drivers
                NvApi.NvMemoryInfo memoryInfo = GetMemoryInfo(out status);
                if (status == NvApi.NvStatus.OK)
                {
                    free = memoryInfo.CurrentAvailableDedicatedVideoMemory;
                    total = memoryInfo.DedicatedVideoMemory;
                }
            }

            if (status == NvApi.NvStatus.OK)
            {
                _memoryTotal.Value = total / 1024;
                ActivateSensor(_memoryTotal);

                _memoryFree.Value = free / 1024;
                ActivateSensor(_memoryFree);

                _memoryUsed.Value = (total - free) / 1024;
                ActivateSensor(_memoryUsed);

                _memoryLoad.Value = ((float)(total - free) / total) * 100;
                ActivateSensor(_memoryLoad);
            }
        }

        if (NvidiaML.IsAvailable && _nvmlDevice.HasValue)
        {
            int? result = NvidiaML.NvmlDeviceGetPowerUsage(_nvmlDevice.Value);
            if (result.HasValue)
            {
                _powerUsage.Value = result.Value / 1000f;
                ActivateSensor(_powerUsage);
            }

            // In MB/s, throughput sensors are passed as in KB/s.
            uint? rx = NvidiaML.NvmlDeviceGetPcieThroughput(_nvmlDevice.Value, NvidiaML.NvmlPcieUtilCounter.RxBytes);
            if (rx.HasValue)
            {
                _pcieThroughputRx.Value = rx * 1024;
                ActivateSensor(_pcieThroughputRx);
            }

            uint? tx = NvidiaML.NvmlDeviceGetPcieThroughput(_nvmlDevice.Value, NvidiaML.NvmlPcieUtilCounter.TxBytes);
            if (tx.HasValue)
            {
                _pcieThroughputTx.Value = tx * 1024;
                ActivateSensor(_pcieThroughputTx);
            }
        }

        // Astral specific
        if (_12VHPwrPinCurrentSensors is { Length: > 0 } && TryReadAstral12VHPwrPinSensors(out ushort[] pinSensorValues))
        {
            float connectorCurrent = 0;
            float connectorPower = 0;
            for (int i = 0; i < 6; i++)
            {
                float current = pinSensorValues[i * 2] / 1000f;
                float voltage = pinSensorValues[i * 2 + 1] / 1000f;
                _12VHPwrPinVoltageSensors[i].Value = voltage;
                _12VHPwrPinCurrentSensors[i].Value = current;
                _12VHPwrPinPowerSensors[i].Value = voltage * current;

                connectorCurrent += current;
                connectorPower += voltage * current;
            }

            _12VHPwrConnectorCurrentSensor.Value = connectorCurrent;
            _12VHPwrConnectorPowerSensor.Value = connectorPower;
        }
    }

    private bool TryReadAstral12VHPwrPinSensors(out ushort[] data)
    {
        data = null;

        if (NvApi.NvAPI_I2CReadEx == null)
            return false;

        byte[] dataBuffer = new byte[24];
        byte[] regAddress = [0x80];

        unsafe
        {
            fixed (byte* pData = dataBuffer)
            fixed (byte* pRegAddr = regAddress)
            {
                NvApi.NvI2CInfo i2cInfo = new()
                {
                    Version = (uint)NvApi.MAKE_NVAPI_VERSION<NvApi.NvI2CInfo>(3),
                    DisplayMask = 0,
                    IsDDCPort = 0,
                    I2CDevAddress = 0x2B << 1,
                    I2CRegAddress = (IntPtr)pRegAddr,
                    RegAddrSize = 1,
                    Data = (IntPtr)pData,
                    Size = 24,
                    I2CSpeed = NvApi.NVAPI_I2C_SPEED_DEPRECATED,
                    I2CSpeedKhz = NvApi.NvI2CSpeed.Speed100Khz,
                    PortId = 0x1,
                    IsPortIdSet = 1
                };

                uint readData = 0;
                if (NvApi.NvAPI_I2CReadEx(_handle, ref i2cInfo, ref readData) != NvApi.NvStatus.OK)
                    return false;
            }
        }

        // Parse 12 x u16 big-endian (as mV and mA) values in reverse order
        data = new ushort[12];
        for (int i = 0; i < 12; i++)
        {
            int pinIndex = 11 - i;
            data[i] = (ushort)((dataBuffer[pinIndex * 2] << 8) | dataBuffer[pinIndex * 2 + 1]);
        }

        return true;
    }

    public override string GetReport()
    {
        StringBuilder r = new();

        r.AppendLine("Nvidia GPU");
        r.AppendLine();
        r.AppendFormat("Name: {0}{1}", _name, Environment.NewLine);
        r.AppendFormat("Index: {0}{1}", _adapterIndex, Environment.NewLine);

        if (_displayHandle.HasValue && NvApi.NvAPI_GetDisplayDriverVersion != null)
        {
            NvApi.NvDisplayDriverVersion driverVersion = new() { Version = (uint)NvApi.MAKE_NVAPI_VERSION<NvApi.NvDisplayDriverVersion>(1) };
            if (NvApi.NvAPI_GetDisplayDriverVersion(_displayHandle.Value, ref driverVersion) == NvApi.NvStatus.OK)
            {
                r.Append("Driver Version: ");
                r.Append(driverVersion.DriverVersion / 100);
                r.Append(".");
                r.Append((driverVersion.DriverVersion % 100).ToString("00", CultureInfo.InvariantCulture));
                r.AppendLine();
                r.Append("Driver Branch: ");
                r.AppendLine(driverVersion.BuildBranch);
            }
        }

        if (NvApi.NvAPI_GPU_GetPCIIdentifiers != null)
        {
            NvApi.NvStatus status = NvApi.NvAPI_GPU_GetPCIIdentifiers(_handle, out uint deviceId, out uint subSystemId, out uint revisionId, out uint extDeviceId);
            if (status == NvApi.NvStatus.OK)
            {
                r.Append("DeviceID: 0x");
                r.AppendLine(deviceId.ToString("X", CultureInfo.InvariantCulture));
                r.Append("SubSystemID: 0x");
                r.AppendLine(subSystemId.ToString("X", CultureInfo.InvariantCulture));
                r.Append("RevisionID: 0x");
                r.AppendLine(revisionId.ToString("X", CultureInfo.InvariantCulture));
                r.Append("ExtDeviceID: 0x");
                r.AppendLine(extDeviceId.ToString("X", CultureInfo.InvariantCulture));
                r.AppendLine();
            }
        }

        if (NvApi.NvAPI_GPU_GetThermalSettings != null)
        {
            NvApi.NvThermalSettings thermalSettings = GetThermalSettings(out NvApi.NvStatus status);

            r.AppendLine("Thermal Settings");
            r.AppendLine();

            if (status == NvApi.NvStatus.OK)
            {
                for (int i = 0; i < thermalSettings.Count; i++)
                {
                    r.AppendFormat(" Sensor[{0}].Controller: {1}{2}", i, thermalSettings.Sensor[i].Controller, Environment.NewLine);
                    r.AppendFormat(" Sensor[{0}].DefaultMinTemp: {1}{2}", i, thermalSettings.Sensor[i].DefaultMinTemp, Environment.NewLine);
                    r.AppendFormat(" Sensor[{0}].DefaultMaxTemp: {1}{2}", i, thermalSettings.Sensor[i].DefaultMaxTemp, Environment.NewLine);
                    r.AppendFormat(" Sensor[{0}].CurrentTemp: {1}{2}", i, thermalSettings.Sensor[i].CurrentTemp, Environment.NewLine);
                    r.AppendFormat(" Sensor[{0}].Target: {1}{2}", i, thermalSettings.Sensor[i].Target, Environment.NewLine);
                }
            }
            else
            {
                r.Append(" Status: ");
                r.AppendLine(status.ToString());
            }

            r.AppendLine();
        }

        if (NvApi.NvAPI_GPU_GetAllClocks != null)
        {
            NvApi.NvGpuClockFrequencies clocks = GetClockFrequencies(out NvApi.NvStatus status);

            r.AppendLine("Clocks");
            r.AppendLine();
            if (status == NvApi.NvStatus.OK)
            {
                for (int i = 0; i < clocks.Clocks.Length; i++)
                {
                    if (clocks.Clocks[i].IsPresent)
                        r.AppendFormat(" Clock[{0}]: {1}{2}", i, clocks.Clocks[i].Frequency, Environment.NewLine);
                }
            }
            else
            {
                r.Append(" Status: ");
                r.AppendLine(status.ToString());
            }

            r.AppendLine();
        }

        if (NvApi.NvAPI_GPU_GetTachReading != null)
        {
            NvApi.NvStatus status = NvApi.NvAPI_GPU_GetTachReading(_handle, out int tachValue);

            r.AppendLine("Tachometer");
            r.AppendLine();
            if (status == NvApi.NvStatus.OK)
            {
                r.AppendFormat(" Value: {0}{1}", tachValue, Environment.NewLine);
            }
            else
            {
                r.Append(" Status: ");
                r.AppendLine(status.ToString());
            }

            r.AppendLine();
        }

        if (NvApi.NvAPI_GPU_GetDynamicPstatesInfoEx != null)
        {
            NvApi.NvDynamicPStatesInfo pStatesInfo = GetDynamicPstatesInfoEx(out NvApi.NvStatus status);

            r.AppendLine("P-States");
            r.AppendLine();
            if (status == NvApi.NvStatus.OK)
            {
                for (int i = 0; i < pStatesInfo.Utilizations.Length; i++)
                {
                    if (pStatesInfo.Utilizations[i].IsPresent)
                        r.AppendFormat(" Percentage[{0}]: {1}{2}", i, pStatesInfo.Utilizations[i].Percentage, Environment.NewLine);
                }
            }
            else
            {
                r.Append(" Status: ");
                r.AppendLine(status.ToString());
            }

            r.AppendLine();
        }

        if (NvApi.NvAPI_GPU_GetUsages != null)
        {
            NvApi.NvUsages usages = GetUsages(out NvApi.NvStatus status);

            r.AppendLine("Usages");
            r.AppendLine();
            if (status == NvApi.NvStatus.OK)
            {
                for (int i = 0; i < usages.Entries.Length; i++)
                {
                    if (usages.Entries[i].IsPresent > 0)
                        r.AppendFormat(" Usage[{0}]: {1}{2}", i, usages.Entries[i].Percentage, Environment.NewLine);
                }
            }
            else
            {
                r.Append(" Status: ");
                r.AppendLine(status.ToString());
            }

            r.AppendLine();
        }

        if (NvApi.NvAPI_GPU_GetCoolerSettings != null)
        {
            NvApi.NvCoolerSettings coolerSettings = GetCoolerSettings(out NvApi.NvStatus status);
            r.AppendLine("Cooler Settings");
            r.AppendLine();
            if (status == NvApi.NvStatus.OK)
            {
                for (int i = 0; i < coolerSettings.Count; i++)
                {
                    r.AppendFormat(" Cooler[{0}].Type: {1}{2}", i, coolerSettings.Cooler[i].Type, Environment.NewLine);
                    r.AppendFormat(" Cooler[{0}].Controller: {1}{2}", i, coolerSettings.Cooler[i].Controller, Environment.NewLine);
                    r.AppendFormat(" Cooler[{0}].DefaultMin: {1}{2}", i, coolerSettings.Cooler[i].DefaultMin, Environment.NewLine);
                    r.AppendFormat(" Cooler[{0}].DefaultMax: {1}{2}", i, coolerSettings.Cooler[i].DefaultMax, Environment.NewLine);
                    r.AppendFormat(" Cooler[{0}].CurrentMin: {1}{2}", i, coolerSettings.Cooler[i].CurrentMin, Environment.NewLine);
                    r.AppendFormat(" Cooler[{0}].CurrentMax: {1}{2}", i, coolerSettings.Cooler[i].CurrentMax, Environment.NewLine);
                    r.AppendFormat(" Cooler[{0}].CurrentLevel: {1}{2}", i, coolerSettings.Cooler[i].CurrentLevel, Environment.NewLine);
                    r.AppendFormat(" Cooler[{0}].DefaultPolicy: {1}{2}", i, coolerSettings.Cooler[i].DefaultPolicy, Environment.NewLine);
                    r.AppendFormat(" Cooler[{0}].CurrentPolicy: {1}{2}", i, coolerSettings.Cooler[i].CurrentPolicy, Environment.NewLine);
                    r.AppendFormat(" Cooler[{0}].Target: {1}{2}", i, coolerSettings.Cooler[i].Target, Environment.NewLine);
                    r.AppendFormat(" Cooler[{0}].ControlType: {1}{2}", i, coolerSettings.Cooler[i].ControlType, Environment.NewLine);
                    r.AppendFormat(" Cooler[{0}].Active: {1}{2}", i, coolerSettings.Cooler[i].Active, Environment.NewLine);
                }
            }
            else
            {
                r.Append(" Status: ");
                r.AppendLine(status.ToString());
            }

            r.AppendLine();
        }

        if (NvApi.NvAPI_GPU_ClientFanCoolersGetStatus != null)
        {
            NvApi.NvFanCoolersStatus coolers = GetFanCoolersStatus(out NvApi.NvStatus status);

            r.AppendLine("Fan Coolers Status");
            r.AppendLine();
            if (status == NvApi.NvStatus.OK)
            {
                for (int i = 0; i < coolers.Count; i++)
                {
                    r.AppendFormat(" Items[{0}].CoolerId: {1}{2}",
                                   i,
                                   coolers.Items[i].CoolerId,
                                   Environment.NewLine);

                    r.AppendFormat(" Items[{0}].CurrentRpm: {1}{2}",
                                   i,
                                   coolers.Items[i].CurrentRpm,
                                   Environment.NewLine);

                    r.AppendFormat(" Items[{0}].CurrentMinLevel: {1}{2}",
                                   i,
                                   coolers.Items[i].CurrentMinLevel,
                                   Environment.NewLine);

                    r.AppendFormat(" Items[{0}].CurrentMaxLevel: {1}{2}",
                                   i,
                                   coolers.Items[i].CurrentMaxLevel,
                                   Environment.NewLine);

                    r.AppendFormat(" Items[{0}].CurrentLevel: {1}{2}",
                                   i,
                                   coolers.Items[i].CurrentLevel,
                                   Environment.NewLine);
                }
            }
            else
            {
                r.Append(" Status: ");
                r.AppendLine(status.ToString());
            }

            r.AppendLine();
        }

        if (NvApi.NvAPI_GPU_ClientPowerTopologyGetStatus != null)
        {
            NvApi.NvPowerTopology powerTopology = GetPowerTopology(out NvApi.NvStatus status);

            r.AppendLine("Power Topology");
            r.AppendLine();

            if (status == NvApi.NvStatus.OK)
            {
                for (int i = 0; i < powerTopology.Count; i++)
                {
                    NvApi.NvPowerTopologyEntry entry = powerTopology.Entries[i];
                    _powers[i].Value = entry.PowerUsage / 1000f;

                    r.AppendFormat(" Entries[{0}].Domain: {1}{2}", i, entry.Domain, Environment.NewLine);
                    r.AppendFormat(" Entries[{0}].PowerUsage: {1}{2}", i, entry.PowerUsage, Environment.NewLine);
                }
            }
            else
            {
                r.Append(" Status: ");
                r.AppendLine(status.ToString());
            }

            r.AppendLine();
        }

        if (NvApi.NvAPI_GPU_GetMemoryInfo != null)
        {
            NvApi.NvMemoryInfo memoryInfo = GetMemoryInfo(out NvApi.NvStatus status);

            r.AppendLine("Memory Info");
            r.AppendLine();
            if (status == NvApi.NvStatus.OK)
            {
                r.AppendFormat(" AvailableDedicatedVideoMemory: {0}{1}", memoryInfo.AvailableDedicatedVideoMemory, Environment.NewLine);
                r.AppendFormat(" DedicatedVideoMemory: {0}{1}", memoryInfo.DedicatedVideoMemory, Environment.NewLine);
                r.AppendFormat(" CurrentAvailableDedicatedVideoMemory: {0}{1}", memoryInfo.CurrentAvailableDedicatedVideoMemory, Environment.NewLine);
                r.AppendFormat(" SharedSystemMemory: {0}{1}", memoryInfo.SharedSystemMemory, Environment.NewLine);
                r.AppendFormat(" SystemVideoMemory: {0}{1}", memoryInfo.SystemVideoMemory, Environment.NewLine);
            }
            else
            {
                r.Append(" Status: ");
                r.AppendLine(status.ToString());
            }

            r.AppendLine();
        }

        if (_d3dDeviceId != null)
        {
            r.AppendLine("D3D");
            r.AppendLine();
            r.AppendLine(" Id: " + _d3dDeviceId);

            r.AppendLine();
        }

        return r.ToString();
    }

    private static string GetName(NvApi.NvPhysicalGpuHandle handle)
    {
        if (NvApi.NvAPI_GPU_GetFullName(handle, out string gpuName) == NvApi.NvStatus.OK)
        {
            string name = gpuName.Trim();
            return name.StartsWith("NVIDIA", StringComparison.OrdinalIgnoreCase) ? name : "NVIDIA " + name;
        }

        return "NVIDIA";
    }

    private NvApi.NvMemoryInfo GetMemoryInfo(out NvApi.NvStatus status)
    {
        if (NvApi.NvAPI_GPU_GetMemoryInfo == null || _displayHandle == null)
        {
            status = NvApi.NvStatus.Error;
            return default;
        }

        NvApi.NvMemoryInfo memoryInfo = new()
        {
            Version = (uint)NvApi.MAKE_NVAPI_VERSION<NvApi.NvMemoryInfo>(2)
        };

        status = NvApi.NvAPI_GPU_GetMemoryInfo(_displayHandle.Value, ref memoryInfo);
        return status == NvApi.NvStatus.OK ? memoryInfo : default;
    }

    private NvApi.NvMemoryInfoEx GetMemoryInfoEx(out NvApi.NvStatus status)
    {
        if (NvApi.NvAPI_GPU_GetMemoryInfoEx == null)
        {
            status = NvApi.NvStatus.Error;
            return default;
        }

        NvApi.NvMemoryInfoEx memoryInfoEx = new()
        {
            Version = (uint)NvApi.MAKE_NVAPI_VERSION<NvApi.NvMemoryInfoEx>(1)
        };

        status = NvApi.NvAPI_GPU_GetMemoryInfoEx(_handle, ref memoryInfoEx);
        return status == NvApi.NvStatus.OK ? memoryInfoEx : default;
    }

    private NvApi.NvGpuClockFrequencies GetClockFrequencies(out NvApi.NvStatus status)
    {
        if (NvApi.NvAPI_GPU_GetAllClockFrequencies == null)
        {
            status = NvApi.NvStatus.Error;
            return default;
        }

        NvApi.NvGpuClockFrequencies clockFrequencies = new()
        {
            Version = (uint)NvApi.MAKE_NVAPI_VERSION<NvApi.NvGpuClockFrequencies>(_clockVersion)
        };

        status = NvApi.NvAPI_GPU_GetAllClockFrequencies(_handle, ref clockFrequencies);
        return status == NvApi.NvStatus.OK ? clockFrequencies : default;
    }

    private NvApi.NvThermalSettings GetThermalSettings(out NvApi.NvStatus status)
    {
        if (NvApi.NvAPI_GPU_GetThermalSettings == null)
        {
            status = NvApi.NvStatus.Error;
            return default;
        }

        NvApi.NvThermalSettings settings = new()
        {
            Version = (uint)NvApi.MAKE_NVAPI_VERSION<NvApi.NvThermalSettings>(2),
            Count = NvApi.MAX_THERMAL_SENSORS_PER_GPU
        };

        status = NvApi.NvAPI_GPU_GetThermalSettings(_handle, (int)NvApi.NvThermalTarget.All, ref settings);
        return status == NvApi.NvStatus.OK ? settings : default;
    }

    private NvApi.NvThermalSensors GetThermalSensors(uint mask, out NvApi.NvStatus status)
    {
        if (NvApi.NvAPI_GPU_GetThermalSensors == null)
        {
            status = NvApi.NvStatus.Error;
            return default;
        }

        var thermalSensors = new NvApi.NvThermalSensors
        {
            Version = (uint)NvApi.MAKE_NVAPI_VERSION<NvApi.NvThermalSensors>(2),
            Mask = mask
        };

        status = NvApi.NvAPI_GPU_GetThermalSensors(_handle, ref thermalSensors);
        return status == NvApi.NvStatus.OK ? thermalSensors : default;
    }

    private NvApi.NvGpuClientVoltRailsStatus GetVoltRailsStatus(out NvApi.NvStatus status)
    {
        if (NvApi.NvAPI_GPU_ClientVoltRailsGetStatus == null)
        {
            status = NvApi.NvStatus.Error;
            return default;
        }

        var voltRails = new NvApi.NvGpuClientVoltRailsStatus
        {
            Version = (uint)NvApi.MAKE_NVAPI_VERSION<NvApi.NvGpuClientVoltRailsStatus>(1),
        };

        status = NvApi.NvAPI_GPU_ClientVoltRailsGetStatus(_handle, ref voltRails);
        return status == NvApi.NvStatus.OK ? voltRails : default;
    }

    private NvApi.NvFanCoolersStatus GetFanCoolersStatus(out NvApi.NvStatus status)
    {
        if (NvApi.NvAPI_GPU_ClientFanCoolersGetStatus == null)
        {
            status = NvApi.NvStatus.Error;
            return default;
        }

        var coolers = new NvApi.NvFanCoolersStatus
        {
            Version = (uint)NvApi.MAKE_NVAPI_VERSION<NvApi.NvFanCoolersStatus>(1),
            Items = new NvApi.NvFanCoolersStatusItem[NvApi.MAX_FAN_COOLERS_STATUS_ITEMS]
        };

        status = NvApi.NvAPI_GPU_ClientFanCoolersGetStatus(_handle, ref coolers);
        return status == NvApi.NvStatus.OK ? coolers : default;
    }

    private NvApi.NvFanCoolerControl GetFanCoolersControllers(out NvApi.NvStatus status)
    {
        if (NvApi.NvAPI_GPU_ClientFanCoolersGetControl == null)
        {
            status = NvApi.NvStatus.Error;
            return default;
        }

        var controllers = new NvApi.NvFanCoolerControl
        {
            Version = (uint)NvApi.MAKE_NVAPI_VERSION<NvApi.NvFanCoolerControl>(1)
        };

        status = NvApi.NvAPI_GPU_ClientFanCoolersGetControl(_handle, ref controllers);
        return status == NvApi.NvStatus.OK ? controllers : default;
    }

    private NvApi.NvCoolerSettings GetCoolerSettings(out NvApi.NvStatus status)
    {
        if (NvApi.NvAPI_GPU_GetCoolerSettings == null)
        {
            status = NvApi.NvStatus.Error;
            return default;
        }

        NvApi.NvCoolerSettings settings = new()
        {
            Version = (uint)NvApi.MAKE_NVAPI_VERSION<NvApi.NvCoolerSettings>(2),
            Cooler = new NvApi.NvCooler[NvApi.MAX_COOLERS_PER_GPU]
        };

        status = NvApi.NvAPI_GPU_GetCoolerSettings(_handle, NvApi.NvCoolerTarget.All, ref settings);
        return status == NvApi.NvStatus.OK ? settings : default;
    }

    private NvApi.NvDynamicPStatesInfo GetDynamicPstatesInfoEx(out NvApi.NvStatus status)
    {
        if (NvApi.NvAPI_GPU_GetDynamicPstatesInfoEx == null)
        {
            status = NvApi.NvStatus.Error;
            return default;
        }

        NvApi.NvDynamicPStatesInfo pStatesInfo = new()
        {
            Version = (uint)NvApi.MAKE_NVAPI_VERSION<NvApi.NvDynamicPStatesInfo>(1),
            Utilizations = new NvApi.NvDynamicPState[NvApi.MAX_GPU_UTILIZATIONS]
        };

        status = NvApi.NvAPI_GPU_GetDynamicPstatesInfoEx(_handle, ref pStatesInfo);
        return status == NvApi.NvStatus.OK ? pStatesInfo : default;
    }

    private NvApi.NvUsages GetUsages(out NvApi.NvStatus status)
    {
        if (NvApi.NvAPI_GPU_GetUsages == null)
        {
            status = NvApi.NvStatus.Error;
            return default;
        }

        NvApi.NvUsages usages = new()
        {
            Version = (uint)NvApi.MAKE_NVAPI_VERSION<NvApi.NvUsages>(1)
        };

        status = NvApi.NvAPI_GPU_GetUsages(_handle, ref usages);
        return status == NvApi.NvStatus.OK ? usages : default;
    }

    private NvApi.NvPowerTopology GetPowerTopology(out NvApi.NvStatus status)
    {
        if (NvApi.NvAPI_GPU_ClientPowerTopologyGetStatus == null)
        {
            status = NvApi.NvStatus.Error;
            return default;
        }

        NvApi.NvPowerTopology powerTopology = new()
        {
            Version = NvApi.MAKE_NVAPI_VERSION<NvApi.NvPowerTopology>(1)
        };

        status = NvApi.NvAPI_GPU_ClientPowerTopologyGetStatus(_handle, ref powerTopology);
        return status == NvApi.NvStatus.OK ? powerTopology : default;
    }

    private int GetTachReading(out NvApi.NvStatus status)
    {
        if (NvApi.NvAPI_GPU_GetTachReading == null)
        {
            status = NvApi.NvStatus.Error;
            return default;
        }

        status = NvApi.NvAPI_GPU_GetTachReading(_handle, out int value);
        return value;
    }

    private static string GetUtilizationDomainName(NvApi.NvUtilizationDomain utilizationDomain) => utilizationDomain switch
    {
        NvApi.NvUtilizationDomain.Gpu => "GPU Core",
        NvApi.NvUtilizationDomain.FrameBuffer => "GPU Memory Controller",
        NvApi.NvUtilizationDomain.VideoEngine => "GPU Video Engine",
        NvApi.NvUtilizationDomain.BusInterface => "GPU Bus",
        _ => null
    };

    private void ControlModeChanged(IControl control)
    {
        switch (control.ControlMode)
        {
            case ControlMode.Default:
                RestoreDefaultFanBehavior(control.Sensor.Index);
                break;
            case ControlMode.Software:
                SoftwareControlValueChanged(control);
                break;
        }
    }

    private void SoftwareControlValueChanged(IControl control)
    {
        int index = control.Sensor?.Index ?? 0;

        NvApi.NvCoolerLevels coolerLevels = new() { Version = (uint)NvApi.MAKE_NVAPI_VERSION<NvApi.NvCoolerLevels>(1), Levels = new NvApi.NvLevel[NvApi.MAX_COOLERS_PER_GPU] };
        coolerLevels.Levels[0].Level = (int)control.SoftwareValue;
        coolerLevels.Levels[0].Policy = NvApi.NvLevelPolicy.Manual;
        if (NvApi.NvAPI_GPU_SetCoolerLevels(_handle, index, ref coolerLevels) == NvApi.NvStatus.OK)
            return;

        NvApi.NvFanCoolerControl fanCoolersControllers = GetFanCoolersControllers(out _);

        for (int i = 0; i < fanCoolersControllers.Count; i++)
        {
            NvApi.NvFanCoolerControlItem nvFanCoolerControlItem = fanCoolersControllers.Items[i];
            if (nvFanCoolerControlItem.CoolerId == index)
            {
                nvFanCoolerControlItem.ControlMode = NvApi.NvFanControlMode.Manual;
                nvFanCoolerControlItem.Level = (uint)control.SoftwareValue;

                fanCoolersControllers.Items[i] = nvFanCoolerControlItem;
            }
        }

        NvApi.NvAPI_GPU_ClientFanCoolersSetControl(_handle, ref fanCoolersControllers);
    }

    private void RestoreDefaultFanBehavior(int index)
    {
        NvApi.NvCoolerLevels coolerLevels = new() { Version = (uint)NvApi.MAKE_NVAPI_VERSION<NvApi.NvCoolerLevels>(1), Levels = new NvApi.NvLevel[NvApi.MAX_COOLERS_PER_GPU] };
        coolerLevels.Levels[0].Policy = NvApi.NvLevelPolicy.Auto;
        if (NvApi.NvAPI_GPU_SetCoolerLevels(_handle, index, ref coolerLevels) == NvApi.NvStatus.OK)
            return;

        NvApi.NvFanCoolerControl fanCoolersControllers = GetFanCoolersControllers(out _);

        for (int i = 0; i < fanCoolersControllers.Count; i++)
        {
            NvApi.NvFanCoolerControlItem nvFanCoolerControlItem = fanCoolersControllers.Items[i];
            if (nvFanCoolerControlItem.CoolerId == index)
            {
                nvFanCoolerControlItem.ControlMode = NvApi.NvFanControlMode.Auto;
                nvFanCoolerControlItem.Level = 0;

                fanCoolersControllers.Items[i] = nvFanCoolerControlItem;
            }
        }

        NvApi.NvAPI_GPU_ClientFanCoolersSetControl(_handle, ref fanCoolersControllers);
    }

    public override void Close()
    {
        if (_fanControls != null)
        {
            for (int i = 0; i < _fanControls.Length; i++)
            {
                _fanControls[i].ControlModeChanged -= ControlModeChanged;
                _fanControls[i].SoftwareControlValueChanged -= SoftwareControlValueChanged;

                if (_fanControls[i].ControlMode != ControlMode.Undefined)
                    RestoreDefaultFanBehavior(i);
            }
        }

        base.Close();
    }
}

```

`LibreHardwareMonitorLib/Hardware/Gpu/NvidiaGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Collections.Generic;
using System.Globalization;
using System.Text;
using LibreHardwareMonitor.Interop;

namespace LibreHardwareMonitor.Hardware.Gpu;

internal class NvidiaGroup : IGroup
{
    private readonly List<Hardware> _hardware = new();
    private readonly StringBuilder _report = new();

    public NvidiaGroup(ISettings settings)
    {
        NvApi.Initialize();

        if (!NvApi.IsAvailable)
            return;

        _report.AppendLine("NvApi");
        _report.AppendLine();

        if (NvApi.NvAPI_GetInterfaceVersionString(out string version) == NvApi.NvStatus.OK)
        {
            _report.Append("Version: ");
            _report.AppendLine(version);
        }

        NvApi.NvPhysicalGpuHandle[] handles = new NvApi.NvPhysicalGpuHandle[NvApi.MAX_PHYSICAL_GPUS];
        if (NvApi.NvAPI_EnumPhysicalGPUs == null)
        {
            _report.AppendLine("Error: NvAPI_EnumPhysicalGPUs not available");
            _report.AppendLine();
            return;
        }

        NvApi.NvStatus status = NvApi.NvAPI_EnumPhysicalGPUs(handles, out int count);
        if (status != NvApi.NvStatus.OK)
        {
            _report.AppendLine("Status: " + status);
            _report.AppendLine();
            return;
        }

        IDictionary<NvApi.NvPhysicalGpuHandle, NvApi.NvDisplayHandle> displayHandles = new Dictionary<NvApi.NvPhysicalGpuHandle, NvApi.NvDisplayHandle>();
        if (NvApi.NvAPI_EnumNvidiaDisplayHandle != null && NvApi.NvAPI_GetPhysicalGPUsFromDisplay != null)
        {
            status = NvApi.NvStatus.OK;
            int i = 0;
            while (status == NvApi.NvStatus.OK)
            {
                NvApi.NvDisplayHandle displayHandle = new();
                status = NvApi.NvAPI_EnumNvidiaDisplayHandle(i, ref displayHandle);
                i++;

                if (status == NvApi.NvStatus.OK)
                {
                    NvApi.NvPhysicalGpuHandle[] handlesFromDisplay = new NvApi.NvPhysicalGpuHandle[NvApi.MAX_PHYSICAL_GPUS];
                    if (NvApi.NvAPI_GetPhysicalGPUsFromDisplay(displayHandle, handlesFromDisplay, out uint countFromDisplay) == NvApi.NvStatus.OK)
                    {
                        for (int j = 0; j < countFromDisplay; j++)
                        {
                            if (!displayHandles.ContainsKey(handlesFromDisplay[j]))
                                displayHandles.Add(handlesFromDisplay[j], displayHandle);
                        }
                    }
                }
            }
        }

        _report.Append("Number of GPUs: ");
        _report.AppendLine(count.ToString(CultureInfo.InvariantCulture));

        for (int i = 0; i < count; i++)
        {
            displayHandles.TryGetValue(handles[i], out NvApi.NvDisplayHandle displayHandle);
            _hardware.Add(new NvidiaGpu(i, handles[i], displayHandle, settings));
        }

        _report.AppendLine();
    }

    public IReadOnlyList<IHardware> Hardware => _hardware;

    public string GetReport()
    {
        return _report.ToString();
    }

    public void Close()
    {
        foreach (Hardware gpu in _hardware)
            gpu.Close();

        NvidiaML.Close();
    }
}

```

`LibreHardwareMonitorLib/Hardware/GroupAffinity.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware;

/// <summary>
/// This structure describes a group-specific affinity.
/// </summary>
public readonly struct GroupAffinity
{
    public static GroupAffinity Undefined = new(ushort.MaxValue, 0);

    /// <summary>
    /// Initializes a new instance of the <see cref="GroupAffinity" /> struct.
    /// </summary>
    /// <param name="group">The group.</param>
    /// <param name="mask">The mask.</param>
    public GroupAffinity(ushort group, ulong mask)
    {
        Group = group;
        Mask = mask;
    }

    /// <summary>
    /// Gets a single group affinity.
    /// </summary>
    /// <param name="group">The group.</param>
    /// <param name="index">The index.</param>
    /// <returns><see cref="GroupAffinity" />.</returns>
    public static GroupAffinity Single(ushort group, int index)
    {
        return new GroupAffinity(group, 1UL << index);
    }

    /// <summary>
    /// Gets the group.
    /// </summary>
    public ushort Group { get; }

    /// <summary>
    /// Gets the mask.
    /// </summary>
    public ulong Mask { get; }

    /// <summary>
    /// Determines whether the specified <see cref="System.Object" /> is equal to this instance.
    /// </summary>
    /// <param name="o">The <see cref="System.Object" /> to compare with this instance.</param>
    /// <returns><c>true</c> if the specified <see cref="System.Object" /> is equal to this instance; otherwise, <c>false</c>.</returns>
    public override bool Equals(object o)
    {
        if (o == null || GetType() != o.GetType())
            return false;

        GroupAffinity a = (GroupAffinity)o;
        return (Group == a.Group) && (Mask == a.Mask);
    }

    /// <summary>
    /// Returns a hash code for this instance.
    /// </summary>
    /// <returns>A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.</returns>
    public override int GetHashCode()
    {
        return Group.GetHashCode() ^ Mask.GetHashCode();
    }

    /// <summary>
    /// Implements the == operator.
    /// </summary>
    /// <param name="a1">The a1.</param>
    /// <param name="a2">The a2.</param>
    /// <returns>The result of the operator.</returns>
    public static bool operator ==(GroupAffinity a1, GroupAffinity a2)
    {
        return (a1.Group == a2.Group) && (a1.Mask == a2.Mask);
    }

    /// <summary>
    /// Implements the != operator.
    /// </summary>
    /// <param name="a1">The a1.</param>
    /// <param name="a2">The a2.</param>
    /// <returns>The result of the operator.</returns>
    public static bool operator !=(GroupAffinity a1, GroupAffinity a2)
    {
        return (a1.Group != a2.Group) || (a1.Mask != a2.Mask);
    }
}
```

`LibreHardwareMonitorLib/Hardware/Hardware.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Linq;

namespace LibreHardwareMonitor.Hardware;

/// <summary>
/// Object representing a component of the computer.
/// <para>
/// Individual information can be read from the <see cref="Sensors"/>.
/// </para>
/// </summary>
public abstract class Hardware : IHardware
{
    protected readonly HashSet<ISensor> _active = new();
    protected readonly string _name;
    protected readonly ISettings _settings;
    private string _customName;

    /// <summary>
    /// Creates a new <see cref="Hardware"/> instance based on the data provided.
    /// </summary>
    /// <param name="name">Component name.</param>
    /// <param name="identifier">Identifier that will be assigned to the device. Based on <see cref="Identifier"/></param>
    /// <param name="settings">Additional settings passed by the <see cref="IComputer"/>.</param>
    protected Hardware(string name, Identifier identifier, ISettings settings)
    {
        _settings = settings;
        _name = name;
        Identifier = identifier;
        _customName = settings.GetValue(new Identifier(Identifier, "name").ToString(), name);
    }

    /// <summary>
    /// Event triggered when <see cref="Hardware"/> is closing.
    /// </summary>
    public event HardwareEventHandler Closing;

    /// <inheritdoc />
    public abstract HardwareType HardwareType { get; }

    /// <inheritdoc />
    public Identifier Identifier { get; }

    /// <inheritdoc />
    public string Name
    {
        get { return _customName; }
        set
        {
            _customName = !string.IsNullOrEmpty(value) ? value : _name;

            _settings.SetValue(new Identifier(Identifier, "name").ToString(), _customName);
        }
    }

    /// <inheritdoc />
    public virtual IHardware Parent
    {
        get { return null; }
    }

    /// <inheritdoc />
    public virtual IDictionary<string, string> Properties => new SortedDictionary<string, string>();

    /// <inheritdoc />
    public virtual ISensor[] Sensors
    {
        get { return _active.ToArray(); }
    }

    /// <inheritdoc />
    public virtual IHardware[] SubHardware
    {
        get { return Array.Empty<IHardware>(); }
    }

    /// <inheritdoc />
    public virtual string GetReport()
    {
        return null;
    }

    /// <inheritdoc />
    public abstract void Update();

    /// <inheritdoc />
    public void Accept(IVisitor visitor)
    {
        if (visitor == null)
            throw new ArgumentNullException(nameof(visitor));

        visitor.VisitHardware(this);
    }

    /// <inheritdoc />
    public virtual void Traverse(IVisitor visitor)
    {
        foreach (ISensor sensor in _active)
            sensor.Accept(visitor);
    }

    /// <inheritdoc />
    protected virtual void ActivateSensor(ISensor sensor)
    {
        if (_active.Add(sensor))
            SensorAdded?.Invoke(sensor);
    }

    /// <inheritdoc />
    protected virtual void DeactivateSensor(ISensor sensor)
    {
        if (_active.Remove(sensor))
            SensorRemoved?.Invoke(sensor);
    }

    /// <inheritdoc />
    public virtual void Close()
    {
        Closing?.Invoke(this);
    }

#pragma warning disable 67
    public event SensorEventHandler SensorAdded;

    public event SensorEventHandler SensorRemoved;
#pragma warning restore 67
}

```

`LibreHardwareMonitorLib/Hardware/HardwareType.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware;

/// <summary>
/// Collection of identifiers representing the purpose of the hardware.
/// </summary>
public enum HardwareType
{
    Motherboard,
    SuperIO,
    Cpu,
    Memory,
    GpuNvidia,
    GpuAmd,
    GpuIntel,
    Storage,
    Network,
    Cooler,
    EmbeddedController,
    Psu,
    Battery,
    PowerMonitor,
}

```

`LibreHardwareMonitorLib/Hardware/IComputer.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Collections.Generic;

namespace LibreHardwareMonitor.Hardware;

/// <summary>
/// Handler that will trigger the actions assigned to it when the event occurs.
/// </summary>
/// <param name="hardware">Component returned to the assigned action(s).</param>
public delegate void HardwareEventHandler(IHardware hardware);

/// <summary>
/// Basic abstract with methods for the class which can store all hardware and decides which devices are to be checked and updated.
/// </summary>
public interface IComputer : IElement
{
    /// <summary>
    /// Triggered when a new <see cref="IHardware" /> is registered.
    /// </summary>
    event HardwareEventHandler HardwareAdded;

    /// <summary>
    /// Triggered when a <see cref="IHardware" /> is removed.
    /// </summary>
    event HardwareEventHandler HardwareRemoved;

    /// <summary>
    /// Gets a list of all known <see cref="IHardware" />.
    /// <para>Can be updated by <see cref="IVisitor" />.</para>
    /// </summary>
    /// <returns>List of all enabled devices.</returns>
    IList<IHardware> Hardware { get; }

    /// <summary>
    /// Gets or sets a value indicating whether collecting information about <see cref="HardwareType.Battery" /> devices should be enabled and updated.
    /// </summary>
    /// <returns><see langword="true" /> if a given category of devices is already enabled.</returns>
    bool IsBatteryEnabled { get; }

    /// <summary>
    /// Gets or sets a value indicating whether collecting information about:
    /// <list>
    ///     <item>
    ///         <see cref="Controller.TBalancer.TBalancerGroup" />
    ///     </item>
    ///     <item>
    ///         <see cref="Controller.Heatmaster.HeatmasterGroup" />
    ///     </item>
    ///     <item>
    ///         <see cref="Controller.AquaComputer.AquaComputerGroup" />
    ///     </item>
    ///     <item>
    ///         <see cref="Controller.AeroCool.AeroCoolGroup" />
    ///     </item>
    ///     <item>
    ///         <see cref="Controller.Nzxt.NzxtGroup" />
    ///     </item>
    /// </list>
    /// devices should be enabled and updated.
    /// </summary>
    /// <returns><see langword="true" /> if a given category of devices is already enabled.</returns>
    bool IsControllerEnabled { get; }

    /// <summary>
    /// Gets or sets a value indicating whether collecting information about <see cref="HardwareType.Cpu" /> devices should be enabled and updated.
    /// </summary>
    /// <returns><see langword="true" /> if a given category of devices is already enabled.</returns>
    bool IsCpuEnabled { get; }

    /// <summary>
    /// Gets or sets a value indicating whether collecting information about <see cref="HardwareType.GpuAmd" /> or <see cref="HardwareType.GpuNvidia" /> devices should be enabled and updated.
    /// </summary>
    /// <returns><see langword="true" /> if a given category of devices is already enabled.</returns>
    bool IsGpuEnabled { get; }

    /// <summary>
    /// Gets or sets a value indicating whether collecting information about <see cref="HardwareType.PowerMonitor"/> devices should be enabled and updated.
    /// </summary>
    /// <returns><see langword="true" /> if a given category of devices is already enabled.</returns>
    bool IsPowerMonitorEnabled { get; }

    /// <summary>
    /// Gets or sets a value indicating whether collecting information about <see cref="HardwareType.Memory" /> devices should be enabled and updated.
    /// </summary>
    /// <returns><see langword="true" /> if a given category of devices is already enabled.</returns>
    bool IsMemoryEnabled { get; }

    /// <summary>
    /// Gets or sets a value indicating whether collecting information about <see cref="HardwareType.Motherboard" /> devices should be enabled and updated.
    /// </summary>
    /// <returns><see langword="true" /> if a given category of devices is already enabled.</returns>
    bool IsMotherboardEnabled { get; }

    /// <summary>
    /// Gets or sets a value indicating whether collecting information about <see cref="HardwareType.Network" /> devices should be enabled and updated.
    /// </summary>
    /// <returns><see langword="true" /> if a given category of devices is already enabled.</returns>
    bool IsNetworkEnabled { get; }

    /// <summary>
    /// Gets or sets a value indicating whether collecting information about <see cref="HardwareType.Psu" /> devices should be enabled and updated.
    /// </summary>
    /// <returns><see langword="true" /> if a given category of devices is already enabled.</returns>
    bool IsPsuEnabled { get; }

    /// <summary>
    /// Gets or sets a value indicating whether collecting information about <see cref="HardwareType.Storage" /> devices should be enabled and updated.
    /// </summary>
    /// <returns><see langword="true" /> if a given category of devices is already enabled.</returns>
    bool IsStorageEnabled { get; }

    /// <summary>
    /// Generates full LibreHardwareMonitor report for devices that have been enabled.
    /// </summary>
    /// <returns>A formatted text string with library, OS and hardware information.</returns>
    string GetReport();
}

```

`LibreHardwareMonitorLib/Hardware/IControl.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware;

public enum ControlMode
{
    Undefined,
    Software,
    Default
}

public interface IControl
{
    ControlMode ControlMode { get; }

    Identifier Identifier { get; }

    float MaxSoftwareValue { get; }

    float MinSoftwareValue { get; }

    ISensor Sensor { get; }

    float SoftwareValue { get; }

    void SetDefault();

    void SetSoftware(float value);
}
```

`LibreHardwareMonitorLib/Hardware/IElement.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware;

/// <summary>
/// Abstract parent with logic for the abstract class that stores data.
/// </summary>
public interface IElement
{
    /// <summary>
    /// Accepts the observer for this instance.
    /// </summary>
    /// <param name="visitor">Computer observer making the calls.</param>
    void Accept(IVisitor visitor);

    /// <summary>
    /// Call the <see cref="Accept"/> method for all child instances <c>(called only from visitors).</c>
    /// </summary>
    /// <param name="visitor">Computer observer making the calls.</param>
    void Traverse(IVisitor visitor);
}
```

`LibreHardwareMonitorLib/Hardware/IGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Collections.Generic;

namespace LibreHardwareMonitor.Hardware;

/// <summary>
/// A group of devices from one category in one list.
/// </summary>
internal interface IGroup
{
    /// <summary>
    /// Gets a list that stores information about <see cref="IHardware"/> in a given group.
    /// </summary>
    IReadOnlyList<IHardware> Hardware { get; }

    /// <summary>
    /// Report containing most of the known information about all <see cref="IHardware"/> in this <see cref="IGroup"/>.
    /// </summary>
    /// <returns>A formatted text string with hardware information.</returns>
    string GetReport();

    /// <summary>
    /// Stop updating this group in the future.
    /// </summary>
    void Close();
}
```

`LibreHardwareMonitorLib/Hardware/IHardware.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Collections.Generic;

namespace LibreHardwareMonitor.Hardware;

/// <summary>
/// Handler that will trigger the actions assigned to it when the event occurs.
/// </summary>
/// <param name="sensor">Component returned to the assigned action(s).</param>
public delegate void SensorEventHandler(ISensor sensor);

/// <summary>
/// Abstract object that stores information about a device. All sensors are available as an array of <see cref="Sensors"/>.
/// <para>
/// Can contain <see cref="SubHardware"/>.
/// Type specified in <see cref="HardwareType"/>.
/// </para>
/// </summary>
public interface IHardware : IElement
{
    /// <summary>
    /// <inheritdoc cref="LibreHardwareMonitor.Hardware.HardwareType"/>
    /// </summary>
    HardwareType HardwareType { get; }

    /// <summary>
    /// Gets a unique hardware ID that represents its location.
    /// </summary>
    Identifier Identifier { get; }

    /// <summary>
    /// Gets or sets device name.
    /// </summary>
    string Name { get; set; }

    /// <summary>
    /// Gets the device that is the parent of the current hardware. For example, the motherboard is the parent of SuperIO.
    /// </summary>
    IHardware Parent { get; }

    /// <summary>
    /// Gets an array of all sensors such as <see cref="SensorType.Temperature"/>, <see cref="SensorType.Clock"/>, <see cref="SensorType.Load"/> etc.
    /// </summary>
    ISensor[] Sensors { get; }

    /// <summary>
    /// Gets child devices, e.g. <see cref="LibreHardwareMonitor.Hardware.Motherboard.Lpc.LpcIO"/> of the <see cref="LibreHardwareMonitor.Hardware.Motherboard.Motherboard"/>.
    /// </summary>
    IHardware[] SubHardware { get; }

    /// <summary>
    /// Report containing most of the known information about the current device.
    /// </summary>
    /// <returns>A formatted text string with hardware information.</returns>
    string GetReport();

    /// <summary>
    /// Refreshes the information stored in <see cref="Sensors"/> array.
    /// </summary>
    void Update();

    /// <summary>
    /// An <see langword="event"/> that will be triggered when a new sensor appears.
    /// </summary>
    event SensorEventHandler SensorAdded;

    /// <summary>
    /// An <see langword="event"/> that will be triggered when one of the sensors is removed.
    /// </summary>
    event SensorEventHandler SensorRemoved;

    /// <summary>
    /// Gets rarely changed hardware properties that can't be represented as sensors.
    /// </summary>
    IDictionary<string, string> Properties { get; }
}
```

`LibreHardwareMonitorLib/Hardware/IHardwareChanged.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware;

internal interface IHardwareChanged
{
    event HardwareEventHandler HardwareAdded;
    event HardwareEventHandler HardwareRemoved;
}
```

`LibreHardwareMonitorLib/Hardware/IParameter.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware;

/// <summary>
/// Abstract object that represents additional parameters included in <see cref="ISensor"/>.
/// </summary>
public interface IParameter : IElement
{
    /// <summary>
    /// Gets a parameter default value defined by library.
    /// </summary>
    float DefaultValue { get; }

    /// <summary>
    /// Gets a parameter description defined by library.
    /// </summary>
    string Description { get; }

    /// <summary>
    /// Gets a unique parameter ID that represents its location.
    /// </summary>
    Identifier Identifier { get; }

    /// <summary>
    /// Gets or sets information whether the given <see cref="IParameter"/> is the default for <see cref="ISensor"/>.
    /// </summary>
    bool IsDefault { get; set; }

    /// <summary>
    /// Gets a parameter name defined by library.
    /// </summary>
    string Name { get; }

    /// <summary>
    /// Gets the sensor that is the data container for the given parameter.
    /// </summary>
    ISensor Sensor { get; }

    /// <summary>
    /// Gets or sets the current value.
    /// </summary>
    float Value { get; set; }
}
```

`LibreHardwareMonitorLib/Hardware/ISensor.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;

namespace LibreHardwareMonitor.Hardware;

/// <summary>
/// Category of what type the selected sensor is.
/// </summary>
public enum SensorType
{
    Voltage, // V
    Current, // A
    Power, // W
    Clock, // MHz
    Temperature, // °C
    Load, // %
    Frequency, // Hz
    Fan, // RPM
    Flow, // L/h
    Control, // %
    Level, // %
    Factor, // 1
    Data, // GB = 2^30 Bytes
    SmallData, // MB = 2^20 Bytes
    Throughput, // B/s
    TimeSpan, // Seconds
    Timing, // ns
    Energy, // milliwatt-hour (mWh)
    Noise, // dBA
    Conductivity, // µS/cm
    Humidity // %
}

/// <summary>
/// Stores the readed value and the time in which it was recorded.
/// </summary>
public struct SensorValue
{
    /// <param name="value"><see cref="Value"/> of the sensor.</param>
    /// <param name="time">The time code during which the <see cref="Value"/> was recorded.</param>
    public SensorValue(float value, DateTime time)
    {
        Value = value;
        Time = time;
    }

    /// <summary>
    /// Gets the value of the sensor
    /// </summary>
    public float Value { get; }

    /// <summary>
    /// Gets the time code during which the <see cref="Value"/> was recorded.
    /// </summary>
    public DateTime Time { get; }
}

/// <summary>
/// Stores information about the readed values and the time in which they were collected.
/// </summary>
public interface ISensor : IElement
{
    IControl Control { get; }

    /// <summary>
    /// <inheritdoc cref="IHardware"/>
    /// </summary>
    IHardware Hardware { get; }

    Identifier Identifier { get; }

    /// <summary>
    /// Gets the unique identifier of this sensor for a given <see cref="IHardware"/>.
    /// </summary>
    int Index { get; }

    bool IsDefaultHidden { get; }

    /// <summary>
    /// Gets a maximum value recorded for the given sensor.
    /// </summary>
    float? Max { get; }

    /// <summary>
    /// Gets a minimum value recorded for the given sensor.
    /// </summary>
    float? Min { get; }

    /// <summary>
    /// Gets or sets a sensor name.
    /// <para>By default determined by the library.</para>
    /// </summary>
    string Name { get; set; }

    IReadOnlyList<IParameter> Parameters { get; }

    /// <summary>
    /// <inheritdoc cref="LibreHardwareMonitor.Hardware.SensorType"/>
    /// </summary>
    SensorType SensorType { get; }

    /// <summary>
    /// Gets the last recorded value for the given sensor.
    /// </summary>
    float? Value { get; }

    /// <summary>
    /// Gets a list of recorded values for the given sensor.
    /// </summary>
    IEnumerable<SensorValue> Values { get; }

    TimeSpan ValuesTimeWindow { get; set; }

    /// <summary>
    /// Resets a value stored in <see cref="Min"/>.
    /// </summary>
    void ResetMin();

    /// <summary>
    /// Resets a value stored in <see cref="Max"/>.
    /// </summary>
    void ResetMax();

    /// <summary>
    /// Clears the values stored in <see cref="Values"/>.
    /// </summary>
    void ClearValues();
}

```

`LibreHardwareMonitorLib/Hardware/ISensorLimits.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware;

/// <summary>
/// Abstract object that stores information about the limits of <see cref="ISensor"/>.
/// </summary>
public interface ISensorLimits
{
    /// <summary>
    /// Upper limit of <see cref="ISensor"/> value.
    /// </summary>
    float? HighLimit { get; }

    /// <summary>
    /// Lower limit of <see cref="ISensor"/> value.
    /// </summary>
    float? LowLimit { get; }
}

/// <summary>
/// Abstract object that stores information about the critical limits of <see cref="ISensor"/>.
/// </summary>
public interface ICriticalSensorLimits
{
    /// <summary>
    /// Critical upper limit of <see cref="ISensor"/> value.
    /// </summary>
    float? CriticalHighLimit { get; }

    /// <summary>
    /// Critical lower limit of <see cref="ISensor"/> value.
    /// </summary>
    float? CriticalLowLimit { get; }
}
```

`LibreHardwareMonitorLib/Hardware/ISettings.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware;

/// <summary>
/// Abstract object that stores settings passed to <see cref="IComputer"/>, <see cref="IHardware"/> and <see cref="ISensor"/>.
/// </summary>
public interface ISettings
{
    /// <summary>
    /// Returns information whether the given collection of settings contains a value assigned to the given key.
    /// </summary>
    /// <param name="name">Key to which the setting value is assigned.</param>
    bool Contains(string name);

    /// <summary>
    /// Assigns a setting option to a given key.
    /// </summary>
    /// <param name="name">Key to which the setting value is assigned.</param>
    /// <param name="value">Text setting value.</param>
    void SetValue(string name, string value);

    /// <summary>
    /// Gets a setting option assigned to the given key.
    /// </summary>
    /// <param name="name">Key to which the setting value is assigned.</param>
    /// <param name="value">Default value.</param>
    string GetValue(string name, string value);

    /// <summary>
    /// Removes a setting with the specified key from the settings collection.
    /// </summary>
    /// <param name="name">Key to which the setting value is assigned.</param>
    void Remove(string name);
}
```

`LibreHardwareMonitorLib/Hardware/IVisitor.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware;

/// <summary>
/// Base interface for creating observers who call to devices.
/// </summary>
public interface IVisitor
{
    /// <summary>
    /// Refreshes the values of all <see cref="ISensor"/> in all <see cref="IHardware"/> on selected <see cref="IComputer"/>.
    /// </summary>
    /// <param name="computer">Instance of the computer to be revisited.</param>
    void VisitComputer(IComputer computer);

    /// <summary>
    /// Refreshes the values of all <see cref="ISensor"/> on selected <see cref="IHardware"/>.
    /// </summary>
    /// <param name="hardware">Instance of the hardware to be revisited.</param>
    void VisitHardware(IHardware hardware);

    /// <summary>
    /// Refreshes the values on selected <see cref="ISensor"/>.
    /// </summary>
    /// <param name="sensor">Instance of the sensor to be revisited.</param>
    void VisitSensor(ISensor sensor);

    /// <summary>
    /// Refreshes the values on selected <see cref="IParameter"/>.
    /// </summary>
    /// <param name="parameter">Instance of the parameter to be revisited.</param>
    void VisitParameter(IParameter parameter);
}
```

`LibreHardwareMonitorLib/Hardware/Identifier.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Text;
using HidSharp;

namespace LibreHardwareMonitor.Hardware;

/// <summary>
/// Represents a unique <see cref="ISensor" />/<see cref="IHardware" /> identifier in text format with a / separator.
/// </summary>
public class Identifier : IComparable<Identifier>
{
    private const char Separator = '/';
    private readonly string _identifier;

    public Identifier(params string[] identifiers)
    {
        CoerceIdentifiers(identifiers);
        StringBuilder s = new();
        for (int i = 0; i < identifiers.Length; i++)
        {
            s.Append(Separator);
            s.Append(identifiers[i]);
        }

        _identifier = s.ToString();
    }

    /// <summary>
    /// Creates a new identifier instance based on the base <see cref="Identifier" /> and additional elements.
    /// </summary>
    /// <param name="identifier">Base identifier being the beginning of the new one.</param>
    /// <param name="extensions">Additional parts by which the base <see cref="Identifier" /> will be extended.</param>
    public Identifier(Identifier identifier, params string[] extensions)
    {
        CoerceIdentifiers(extensions);
        StringBuilder s = new();
        s.Append(identifier);
        for (int i = 0; i < extensions.Length; i++)
        {
            s.Append(Separator);
            s.Append(extensions[i]);
        }

        _identifier = s.ToString();
    }

    /// <summary>
    /// Creates a new identifier instance based on the supplied <see cref="HidDevice" />.
    /// If available the identifier will consist of the vendor-id, product-id and serial number of the HidDevice.
    /// Alternatively a platform dependent identifier based on the usb device-path is generated.
    /// </summary>
    /// <param name="dev">The <see cref="HidDevice" /> this identifier will be created for.</param>
    public Identifier(HidDevice dev)
    {
        string[] identifiers;
        try
        {
            identifiers = ["usbhid", dev.VendorID.ToString("X4"), dev.ProductID.ToString("X4"), dev.GetSerialNumber()];
        }
        catch
        {
            identifiers = ["usbhid", dev.DevicePath];
        }

        CoerceIdentifiers(identifiers);
        StringBuilder s = new();
        for (int i = 0; i < identifiers.Length; i++)
        {
            s.Append(Separator);
            s.Append(identifiers[i]);
        }

        _identifier = s.ToString();
    }

    /// <inheritdoc />
    public int CompareTo(Identifier other)
    {
        if (other == null)
            return 1;

        return string.Compare(_identifier,
                              other._identifier,
                              StringComparison.Ordinal);
    }

    private static void CoerceIdentifiers(string[] identifiers)
    {
        for (int i = 0; i < identifiers.Length; i++)
        {
            string s = identifiers[i];
            identifiers[i] = Uri.EscapeDataString(identifiers[i]);
        }
    }

    /// <inheritdoc />
    public override string ToString()
    {
        return _identifier;
    }

    /// <inheritdoc />
    public override bool Equals(object obj)
    {
        if (obj == null)
            return false;

        Identifier id = obj as Identifier;
        if (id == null)
            return false;

        return _identifier == id._identifier;
    }

    /// <inheritdoc />
    public override int GetHashCode()
    {
        return _identifier.GetHashCode();
    }

    public static bool operator ==(Identifier id1, Identifier id2)
    {
        if (id1 is null && id2 is null)
            return true;

        return id1 is not null && id1.Equals(id2);
    }

    public static bool operator !=(Identifier id1, Identifier id2)
    {
        return !(id1 == id2);
    }

    public static bool operator <(Identifier id1, Identifier id2)
    {
        if (id1 == null)
            return id2 != null;

        return id1.CompareTo(id2) < 0;
    }

    public static bool operator >(Identifier id1, Identifier id2)
    {
        if (id1 == null)
            return false;

        return id1.CompareTo(id2) > 0;
    }
}

```

`LibreHardwareMonitorLib/Hardware/Memory/DimmMemory.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using LibreHardwareMonitor.Hardware.Memory.Sensors;
using RAMSPDToolkit.SPD;
using RAMSPDToolkit.SPD.Interfaces;
using RAMSPDToolkit.SPD.Interop.Shared;

namespace LibreHardwareMonitor.Hardware.Memory;

internal sealed class DimmMemory : Hardware
{
    private readonly SpdThermalSensor _thermalSensor;

    public DimmMemory(SPDAccessor accessor, string name, Identifier identifier, ISettings settings)
        : base(name, identifier, settings)
    {
        //Only add thermal sensor if present
        if (accessor is IThermalSensor ts && ts.HasThermalSensor)
        {
            //Check which kind of RAM we have
            switch (accessor.MemoryType())
            {
                case SPDMemoryType.SPD_DDR4_SDRAM:
                case SPDMemoryType.SPD_DDR4E_SDRAM:
                case SPDMemoryType.SPD_LPDDR4_SDRAM:
                case SPDMemoryType.SPD_LPDDR4X_SDRAM:
                case SPDMemoryType.SPD_DDR5_SDRAM:
                case SPDMemoryType.SPD_LPDDR5_SDRAM:
                    _thermalSensor = new SpdThermalSensor($"DIMM #{accessor.Index}",
                                                          0,
                                                          SensorType.Temperature,
                                                          this,
                                                          settings,
                                                          accessor as IThermalSensor);
                    break;
            }
        }

        bool hasThermalSensor = _thermalSensor != null;

        //Add thermal sensor
        if (hasThermalSensor)
            ActivateSensor(_thermalSensor);

        //Add other sensors
        CreateSensors(accessor, hasThermalSensor);
    }

    public override HardwareType HardwareType => HardwareType.Memory;

    public override void Update()
    {
        _thermalSensor?.UpdateSensor();
    }

    private void CreateSensors(SPDAccessor accessor, bool hasThermalSensor)
    {
        if (accessor is DDR4Accessor ddr4)
        {
            CreateSensorsDDR4(ddr4, hasThermalSensor);
        }
        else if (accessor is DDR5Accessor ddr5)
        {
            CreateSensorsDDR5(ddr5, hasThermalSensor);
        }
    }

    private void CreateSensorsDDR4(DDR4Accessor accessor, bool hasThermalSensor)
    {
        if (hasThermalSensor)
        {
            //Temperature Resolution (fixed value)
            AddSensor("Temperature Sensor Resolution", 1, false, SensorType.Temperature, accessor.TemperatureResolution);
            AddSensor("Thermal Sensor Low Limit", 2, false, SensorType.Temperature, accessor.ThermalSensorLowLimit);
            AddSensor("Thermal Sensor High Limit", 3, false, SensorType.Temperature, accessor.ThermalSensorHighLimit);
            AddSensor("Thermal Sensor Critical Limit", 4, false, SensorType.Temperature, accessor.ThermalSensorCriticalLimit);
        }

        //Timings
        AddSensor("tCKAVGmin (Minimum Cycle Time)", 20, false, SensorType.Timing, (float)accessor.SDRAMTimings.MinimumCycleTime);
        AddSensor("tCKAVGmax (Maximum Cycle Time)", 21, false, SensorType.Timing, (float)accessor.SDRAMTimings.MaximumCycleTime);
        AddSensor("tAA (CAS Latency Time)", 22, false, SensorType.Timing, (float)accessor.SDRAMTimings.MinimumCASLatencyTime);
        AddSensor("tRCD (RAS to CAS Delay Time)", 23, false, SensorType.Timing, (float)accessor.SDRAMTimings.MinimumRASToCASDelayTime);
        AddSensor("tRP (Row Precharge Delay Time)", 24, false, SensorType.Timing, (float)accessor.SDRAMTimings.MinimumRowPrechargeDelayTime);
        AddSensor("tRAS (Active to Precharge Delay Time)", 25, false, SensorType.Timing, (float)accessor.SDRAMTimings.MinimumActiveToPrechargeDelayTime);
        AddSensor("tRC (Active to Active/Refresh Delay Time)", 26, false, SensorType.Timing, (float)accessor.SDRAMTimings.MinimumActiveToActiveRefreshDelayTime);
        AddSensor("tRFC1 (Refresh Recovery Delay Time)", 27, false, SensorType.Timing, (float)accessor.SDRAMTimings.MinimumRefreshRecoveryDelayTime1);
        AddSensor("tRFC2 (Refresh Recovery Delay Time)", 28, false, SensorType.Timing, (float)accessor.SDRAMTimings.MinimumRefreshRecoveryDelayTime2);
        AddSensor("tRFC4 (Refresh Recovery Delay Time)", 29, false, SensorType.Timing, (float)accessor.SDRAMTimings.MinimumRefreshRecoveryDelayTime4);
        AddSensor("tFAW (Four Activate Window Time)", 30, false, SensorType.Timing, (float)accessor.SDRAMTimings.MinimumFourActivateWindowTime);
        AddSensor("tRRD_S (Activate to Activate Delay Time)", 31, false, SensorType.Timing, (float)accessor.SDRAMTimings.MinimumActivateToActivateDelay_DiffGroup);
        AddSensor("tRRD_L (Activate to Activate Delay Time)", 32, false, SensorType.Timing, (float)accessor.SDRAMTimings.MinimumActivateToActivateDelay_SameGroup);
        AddSensor("tCCD_L (CAS to CAS Delay Time)", 33, false, SensorType.Timing, (float)accessor.SDRAMTimings.MinimumCASToCASDelay_SameGroup);
        AddSensor("tWR (Write Recovery Time)", 34, false, SensorType.Timing, (float)accessor.SDRAMTimings.MinimumWriteRecoveryTime);
        AddSensor("tWTR_S (Write to Read Time)", 35, false, SensorType.Timing, (float)accessor.SDRAMTimings.MinimumWriteToReadTime_DiffGroup);
        AddSensor("tWTR_L (Write to Read Time)", 36, false, SensorType.Timing, (float)accessor.SDRAMTimings.MinimumWriteToReadTime_SameGroup);

        //Data
        AddSensor("Capacity", 50, false, SensorType.Data, accessor.GetCapacity());
    }

    private void CreateSensorsDDR5(DDR5Accessor accessor, bool hasThermalSensor)
    {
        if (hasThermalSensor)
        {
            //Temperature Resolution (fixed value)
            AddSensor("Temperature Sensor Resolution", 1, false, SensorType.Temperature, accessor.TemperatureResolution);
            AddSensor("Thermal Sensor Low Limit", 2, false, SensorType.Temperature, accessor.ThermalSensorLowLimit);
            AddSensor("Thermal Sensor High Limit", 3, false, SensorType.Temperature, accessor.ThermalSensorHighLimit);
            AddSensor("Thermal Sensor Critical Low Limit", 4, false, SensorType.Temperature, accessor.ThermalSensorCriticalLowLimit);
            AddSensor("Thermal Sensor Critical High Limit", 5, false, SensorType.Temperature, accessor.ThermalSensorCriticalHighLimit);
        }

        //Timings
        AddSensor("tCKAVGmin (Minimum Cycle Time)", 20, false, SensorType.Timing, (float)accessor.SDRAMTimings.MinimumCycleTime);
        AddSensor("tCKAVGmax (Maximum Cycle Time)", 21, false, SensorType.Timing, (float)accessor.SDRAMTimings.MaximumCycleTime);
        AddSensor("tAA (CAS Latency Time)", 22, false, SensorType.Timing, (float)accessor.SDRAMTimings.MinimumCASLatencyTime);
        AddSensor("tRCD (RAS to CAS Delay Time)", 23, false, SensorType.Timing, (float)accessor.SDRAMTimings.MinimumRASToCASDelayTime);
        AddSensor("tRP (Row Precharge Delay Time)", 24, false, SensorType.Timing, (float)accessor.SDRAMTimings.MinimumRowPrechargeDelayTime);
        AddSensor("tRAS (Active to Precharge Delay Time)", 25, false, SensorType.Timing, (float)accessor.SDRAMTimings.MinimumActiveToPrechargeDelayTime);
        AddSensor("tRC (Active to Active/Refresh Delay Time)", 26, false, SensorType.Timing, (float)accessor.SDRAMTimings.MinimumActiveToActiveRefreshDelayTime);
        AddSensor("tWR (Write Recovery Time)", 27, false, SensorType.Timing, (float)accessor.SDRAMTimings.MinimumWriteRecoveryTime);
        AddSensor("tRFC1 (Normal Refresh Recovery Time)", 28, false, SensorType.Timing, (float)accessor.SDRAMTimings.NormalRefreshRecoveryTime);
        AddSensor("tRFC2 (Fine Granularity Refresh Recovery Time)", 29, false, SensorType.Timing, (float)accessor.SDRAMTimings.FineGranularityRefreshRecoveryTime);
        AddSensor("tRFCsb (Same Bank Refresh Recovery Time)", 30, false, SensorType.Timing, (float)accessor.SDRAMTimings.SameBankRefreshRecoveryTime);
        AddSensor("tRFC1_dlr (Normal Refresh Recovery Time 3DS)", 31, false, SensorType.Timing, (float)accessor.SDRAMTimings.NormalRefreshRecoveryTime_3DSDifferentLogicalRank);
        AddSensor("tRFC2_dlr (Fine Granularity Refresh Recovery Time 3DS)", 32, false, SensorType.Timing, (float)accessor.SDRAMTimings.FineGranularityRefreshRecoveryTime_3DSDifferentLogicalRank);
        AddSensor("tRFCsb_dlr (Same Bank Refresh Recovery Time 3DS)", 33, false, SensorType.Timing, (float)accessor.SDRAMTimings.SameBankRefreshRecoveryTime_3DSDifferentLogicalRank);

        //Data
        AddSensor("Capacity", 50, false, SensorType.Data, accessor.GetCapacity());
    }

    private void AddSensor(string name, int index, bool defaultHidden, SensorType sensorType, float value)
    {
        var sensor = new Sensor(name, index, defaultHidden, sensorType, this, null, _settings)
        {
            Value = value,
        };

        ActivateSensor(sensor);
    }
}

```

`LibreHardwareMonitorLib/Hardware/Memory/MemoryGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using RAMSPDToolkit.I2CSMBus;
using RAMSPDToolkit.SPD;
using RAMSPDToolkit.SPD.Enums;
using RAMSPDToolkit.SPD.Interop.Shared;
using RAMSPDToolkit.Windows.Driver;

namespace LibreHardwareMonitor.Hardware.Memory;

internal class MemoryGroup : IGroup, IHardwareChanged
{
    private static readonly object _lock = new();
    private List<Hardware> _hardware = [];

    private CancellationTokenSource _cancellationTokenSource;
    private Exception _lastException;
    private bool _disposed = false;

    public MemoryGroup(ISettings settings)
    {
        if (DriverManager.Driver is null || !DriverManager.Driver.IsOpen)
        {
            // Assign implementation of IDriver.
            DriverManager.Driver = new RAMSPDToolkitDriver();
            SMBusManager.UseWMI = false;
        }

        _hardware.Add(new VirtualMemory(settings));
        _hardware.Add(new TotalMemory(settings));

        if (DriverManager.Driver == null || !DriverManager.LoadDriver())
        {
            return;
        }

        if (!TryAddDimms(settings))
        {
            StartRetryTask(settings);
        }
    }

#pragma warning disable 67
    public event HardwareEventHandler HardwareAdded;
    public event HardwareEventHandler HardwareRemoved;
#pragma warning restore 67

    public IReadOnlyList<IHardware> Hardware => _hardware;

    public string GetReport()
    {
        StringBuilder report = new();
        report.AppendLine("Memory Report:");
        if (_lastException != null)
        {
            report.AppendLine($"Error while detecting memory: {_lastException.Message}");
        }

        foreach (Hardware hardware in _hardware)
        {
            report.AppendLine($"{hardware.Name} ({hardware.Identifier}):");
            report.AppendLine();
            foreach (ISensor sensor in hardware.Sensors)
            {
                report.AppendLine($"{sensor.Name}: {sensor.Value?.ToString() ?? "No value"}");
            }
        }

        return report.ToString();
    }

    public void Close()
    {
        _cancellationTokenSource?.Cancel();
        _cancellationTokenSource?.Dispose();
        _cancellationTokenSource = null;

        lock (_lock)
        {
            foreach (Hardware ram in _hardware)
                ram.Close();

            _hardware = [];
            _disposed = true;
        }
    }

    private bool TryAddDimms(ISettings settings)
    {
        try
        {
            lock (_lock)
            {
                if (_disposed)
                {
                    return false;
                }

                if (DetectThermalSensors(out List<SPDAccessor> accessors))
                {
                    AddDimms(accessors, settings);
                    return true;
                }
            }
        }
        catch (Exception ex)
        {
            _lastException = ex;
            Debug.Assert(false, "Exception while detecting RAM: " + ex.Message);
        }

        return false;
    }

    private void StartRetryTask(ISettings settings)
    {
        _cancellationTokenSource = new CancellationTokenSource();

        Task.Run(async () =>
        {
            int retryRemaining = 5;

            while (!_cancellationTokenSource.IsCancellationRequested && --retryRemaining > 0)
            {
                await Task.Delay(TimeSpan.FromSeconds(2.5), _cancellationTokenSource.Token).ConfigureAwait(false);

                if (TryAddDimms(settings))
                {
                    break;
                }
            }
        }, _cancellationTokenSource.Token);
    }

    private static bool DetectThermalSensors(out List<SPDAccessor> accessors)
    {
        accessors = [];

        bool ramDetected = false;

        SMBusManager.DetectSMBuses();

        //Go through detected SMBuses
        foreach (SMBusInterface smbus in SMBusManager.RegisteredSMBuses)
        {
            //Go through possible RAM slots
            for (byte i = SPDConstants.SPD_BEGIN; i <= SPDConstants.SPD_END; ++i)
            {
                //Detect type of RAM, if available
                SPDDetector detector = new(smbus, i);

                //RAM available and detected
                if (detector.Accessor != null)
                {
                    //Add all detected modules
                    accessors.Add(detector.Accessor);

                    ramDetected = true;
                }
            }
        }

        return ramDetected;
    }

    private void AddDimms(List<SPDAccessor> accessors, ISettings settings)
    {
        List<Hardware> additions = [];

        foreach (SPDAccessor ram in accessors)
        {
            //Default value
            string name = $"DIMM #{ram.Index}";

            //Check if we can switch to the correct page
            if (ram.ChangePage(PageData.ModulePartNumber))
                name = $"{ram.GetModuleManufacturerString()} - {ram.ModulePartNumber()} (#{ram.Index})";

            DimmMemory memory = new(ram, name, new Identifier("memory", "dimm", $"{ram.Index}"), settings);
            additions.Add(memory);
        }

        _hardware = [.. _hardware, .. additions];
        foreach (Hardware hardware in additions)
            HardwareAdded?.Invoke(hardware);
    }
}

```

`LibreHardwareMonitorLib/Hardware/Memory/MemoryLinux.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.IO;
using System.Linq;

namespace LibreHardwareMonitor.Hardware.Memory;

internal static class MemoryLinux
{
    public static void Update(TotalMemory memory)
    {
        try
        {
            string[] memoryInfo = File.ReadAllLines("/proc/meminfo");

            {
                float totalMemoryGb = GetMemInfoValue(memoryInfo.First(entry => entry.StartsWith("MemTotal:"))) / 1024.0f / 1024.0f;
                float freeMemoryGb = GetMemInfoValue(memoryInfo.First(entry => entry.StartsWith("MemFree:"))) / 1024.0f / 1024.0f;
                float cachedMemoryGb = GetMemInfoValue(memoryInfo.First(entry => entry.StartsWith("Cached:"))) / 1024.0f / 1024.0f;

                float usedMemoryGb = totalMemoryGb - freeMemoryGb - cachedMemoryGb;

                memory.PhysicalMemoryUsed.Value = usedMemoryGb;
                memory.PhysicalMemoryAvailable.Value = totalMemoryGb;
                memory.PhysicalMemoryLoad.Value = 100.0f * (usedMemoryGb / totalMemoryGb);
            }
        }
        catch
        {
            memory.PhysicalMemoryUsed.Value = null;
            memory.PhysicalMemoryAvailable.Value = null;
            memory.PhysicalMemoryLoad.Value = null;
        }
    }

    public static void Update(VirtualMemory memory)
    {
        try
        {
            string[] memoryInfo = File.ReadAllLines("/proc/meminfo");

            {
                float totalSwapMemoryGb = GetMemInfoValue(memoryInfo.First(entry => entry.StartsWith("SwapTotal"))) / 1024.0f / 1024.0f;
                float freeSwapMemoryGb = GetMemInfoValue(memoryInfo.First(entry => entry.StartsWith("SwapFree"))) / 1024.0f / 1024.0f;
                float usedSwapMemoryGb = totalSwapMemoryGb - freeSwapMemoryGb;

                memory.VirtualMemoryUsed.Value = usedSwapMemoryGb;
                memory.VirtualMemoryAvailable.Value = totalSwapMemoryGb;
                memory.VirtualMemoryLoad.Value = 100.0f * (usedSwapMemoryGb / totalSwapMemoryGb);
            }
        }
        catch
        {
            memory.VirtualMemoryUsed.Value = null;
            memory.VirtualMemoryAvailable.Value = null;
            memory.VirtualMemoryLoad.Value = null;
        }
    }

    private static long GetMemInfoValue(string line)
    {
        // Example: "MemTotal:       32849676 kB"

        string valueWithUnit = line.Split(':').Skip(1).First().Trim();
        string valueAsString = valueWithUnit.Split(' ').First();

        return long.Parse(valueAsString);
    }
}

```

`LibreHardwareMonitorLib/Hardware/Memory/MemoryWindows.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using Windows.Win32;
using Windows.Win32.System.SystemInformation;

namespace LibreHardwareMonitor.Hardware.Memory;

internal static unsafe class MemoryWindows
{
    public static void Update(TotalMemory memory)
    {
        MEMORYSTATUSEX status = new() { dwLength = (uint)sizeof(MEMORYSTATUSEX) };

        if (!PInvoke.GlobalMemoryStatusEx(ref status))
            return;

        memory.PhysicalMemoryUsed.Value = (float)(status.ullTotalPhys - status.ullAvailPhys) / (1024 * 1024 * 1024);
        memory.PhysicalMemoryAvailable.Value = (float)status.ullAvailPhys / (1024 * 1024 * 1024);
        memory.PhysicalMemoryLoad.Value = 100.0f - ((100.0f * status.ullAvailPhys) / status.ullTotalPhys);
    }

    public static void Update(VirtualMemory memory)
    {
        MEMORYSTATUSEX status = new() { dwLength = (uint)sizeof(MEMORYSTATUSEX) };

        if (!PInvoke.GlobalMemoryStatusEx(ref status))
            return;

        memory.VirtualMemoryUsed.Value = (float)(status.ullTotalPageFile - status.ullAvailPageFile) / (1024 * 1024 * 1024);
        memory.VirtualMemoryAvailable.Value = (float)status.ullAvailPageFile / (1024 * 1024 * 1024);
        memory.VirtualMemoryLoad.Value = 100.0f - ((100.0f * status.ullAvailPageFile) / status.ullTotalPageFile);
    }
}

```

`LibreHardwareMonitorLib/Hardware/Memory/Sensors/SpdThermalSensor.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using RAMSPDToolkit.SPD.Interfaces;

namespace LibreHardwareMonitor.Hardware.Memory.Sensors;

internal class SpdThermalSensor(string name, int index, SensorType sensorType, Hardware hardware, ISettings settings, IThermalSensor thermalSensor)
    : Sensor(name, index, sensorType, hardware, settings)
{
    public bool UpdateSensor()
    {
        if (!thermalSensor.UpdateTemperature())
            return false;

        Value = thermalSensor.Temperature;

        return true;
    }
}

```

`LibreHardwareMonitorLib/Hardware/Memory/TotalMemory.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware.Memory;

internal sealed class TotalMemory : Hardware
{
    public TotalMemory(ISettings settings)
        : base("Total Memory", new Identifier("ram"), settings)
    {
        PhysicalMemoryUsed = new Sensor("Memory Used", 0, SensorType.Data, this, settings);
        ActivateSensor(PhysicalMemoryUsed);

        PhysicalMemoryAvailable = new Sensor("Memory Available", 1, SensorType.Data, this, settings);
        ActivateSensor(PhysicalMemoryAvailable);

        PhysicalMemoryLoad = new Sensor("Memory", 0, SensorType.Load, this, settings);
        ActivateSensor(PhysicalMemoryLoad);
    }

    public override HardwareType HardwareType => HardwareType.Memory;

    internal Sensor PhysicalMemoryAvailable { get; }

    internal Sensor PhysicalMemoryLoad { get; }

    internal Sensor PhysicalMemoryUsed { get; }

    public override void Update()
    {
        if (Software.OperatingSystem.IsUnix)
        {
            MemoryLinux.Update(this);
        }
        else
        {
            MemoryWindows.Update(this);
        }
    }
}

```

`LibreHardwareMonitorLib/Hardware/Memory/VirtualMemory.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware.Memory;

internal sealed class VirtualMemory : Hardware
{
    public VirtualMemory(ISettings settings)
        : base("Virtual Memory", new Identifier("vram"), settings)
    {
        VirtualMemoryUsed = new Sensor("Memory Used", 2, SensorType.Data, this, settings);
        ActivateSensor(VirtualMemoryUsed);

        VirtualMemoryAvailable = new Sensor("Memory Available", 3, SensorType.Data, this, settings);
        ActivateSensor(VirtualMemoryAvailable);

        VirtualMemoryLoad = new Sensor("Memory", 1, SensorType.Load, this, settings);
        ActivateSensor(VirtualMemoryLoad);
    }

    public override HardwareType HardwareType => HardwareType.Memory;

    internal Sensor VirtualMemoryAvailable { get; }

    internal Sensor VirtualMemoryLoad { get; }

    internal Sensor VirtualMemoryUsed { get; }

    public override void Update()
    {
        if (Software.OperatingSystem.IsUnix)
        {
            MemoryLinux.Update(this);
        }
        else
        {
            MemoryWindows.Update(this);
        }
    }
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/Control.cs`:

```cs
namespace LibreHardwareMonitor.Hardware.Motherboard;

internal class Control
{
    public readonly int Index;
    public readonly string Name;

    public Control(string name, int index)
    {
        Name = name;
        Index = index;
    }
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/Fan.cs`:

```cs
namespace LibreHardwareMonitor.Hardware.Motherboard;

internal class Fan
{
    public readonly int Index;
    public readonly string Name;

    public Fan(string name, int index)
    {
        Name = name;
        Index = index;
    }
}
```

`LibreHardwareMonitorLib/Hardware/Motherboard/Identification.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;

namespace LibreHardwareMonitor.Hardware.Motherboard;

internal class Identification
{
    public static Manufacturer GetManufacturer(string name)
    {
        switch (name)
        {
            case var _ when name.IndexOf("abit.com.tw", StringComparison.OrdinalIgnoreCase) > -1:
                return Manufacturer.Acer;
            case var _ when name.StartsWith("Acer", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Acer;
            case var _ when name.StartsWith("AMD", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.AMD;
            case var _ when name.Equals("Alienware", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Alienware;
            case var _ when name.StartsWith("AOpen", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.AOpen;
            case var _ when name.StartsWith("Apple", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Apple;
            case var _ when name.Equals("ASRock", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.ASRock;
            case var _ when name.StartsWith("ASUSTeK", StringComparison.OrdinalIgnoreCase):
            case var _ when name.StartsWith("ASUS ", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.ASUS;
            case var _ when name.StartsWith("Biostar", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Biostar;
            case var _ when name.StartsWith("Clevo", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Clevo;
            case var _ when name.StartsWith("Dell", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Dell;
            case var _ when name.Equals("DFI", StringComparison.OrdinalIgnoreCase):
            case var _ when name.StartsWith("DFI Inc", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.DFI;
            case var _ when name.Equals("ECS", StringComparison.OrdinalIgnoreCase):
            case var _ when name.StartsWith("ELITEGROUP", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.ECS;
            case var _ when name.Equals("EPoX COMPUTER CO., LTD", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.EPoX;
            case var _ when name.StartsWith("EVGA", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.EVGA;
            case var _ when name.Equals("FIC", StringComparison.OrdinalIgnoreCase):
            case var _ when name.StartsWith("First International Computer", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.FIC;
            case var _ when name.Equals("Foxconn", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Foxconn;
            case var _ when name.StartsWith("Framework", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Framework;
            case var _ when name.StartsWith("Fujitsu", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Fujitsu;
            case var _ when name.StartsWith("Gigabyte", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Gigabyte;
            case var _ when name.StartsWith("Hewlett-Packard", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("HP", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.HP;
            case var _ when name.Equals("IBM", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.IBM;
            case var _ when name.Equals("Intel", StringComparison.OrdinalIgnoreCase):
            case var _ when name.StartsWith("Intel Corp", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Intel;
            case var _ when name.StartsWith("Jetway", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Jetway;
            case var _ when name.StartsWith("Lenovo", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Lenovo;
            case var _ when name.Equals("LattePanda", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.LattePanda;
            case var _ when name.StartsWith("Medion", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Medion;
            case var _ when name.StartsWith("Microsoft", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Microsoft;
            case var _ when name.StartsWith("Micro-Star International", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("MSI", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.MSI;
            case var _ when name.StartsWith("NEC ", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("NEC", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.NEC;
            case var _ when name.StartsWith("Pegatron", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Pegatron;
            case var _ when name.StartsWith("Samsung", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Samsung;
            case var _ when name.StartsWith("Sapphire", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Sapphire;
            case var _ when name.StartsWith("Shuttle", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Shuttle;
            case var _ when name.StartsWith("Sony", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Sony;
            case var _ when name.StartsWith("Supermicro", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Supermicro;
            case var _ when name.StartsWith("Toshiba", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Toshiba;
            case var _ when name.Equals("XFX", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.XFX;
            case var _ when name.StartsWith("Zotac", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Zotac;
            case var _ when name.Equals("To be filled by O.E.M.", StringComparison.OrdinalIgnoreCase):
                return Manufacturer.Unknown;
            default:
                return Manufacturer.Unknown;
        }
    }

    public static Model GetModel(string name)
    {
        switch (name)
        {
            case var _ when name.Equals("TUF GAMING B850M-PLUS II", StringComparison.OrdinalIgnoreCase):
                return Model.TUF_GAMING_B850M_PLUS_II;
            case var _ when name.Equals("MPG Z390 GAMING EDGE AC (MS-7B17)", StringComparison.OrdinalIgnoreCase):
                return Model.Z390_GAMING_EDGE_AC;
            case var _ when name.Equals("X870 AORUS ELITE WIFI7", StringComparison.OrdinalIgnoreCase):
                return Model.X870_AORUS_ELITE_WIFI7;
            case var _ when name.Equals("X870 AORUS ELITE WIFI7 ICE", StringComparison.OrdinalIgnoreCase):
                return Model.X870_AORUS_ELITE_WIFI7_ICE;
            case var _ when name.Equals("880GMH/USB3", StringComparison.OrdinalIgnoreCase):
                return Model._880GMH_USB3;
            case var _ when name.Equals("B85M-DGS", StringComparison.OrdinalIgnoreCase):
                return Model.B85M_DGS;
            case var _ when name.Equals("ASRock AOD790GX/128M", StringComparison.OrdinalIgnoreCase):
                return Model.AOD790GX_128M;
            case var _ when name.Equals("AB350 Pro4", StringComparison.OrdinalIgnoreCase):
                return Model.AB350_Pro4;
            case var _ when name.Equals("AB350M Pro4", StringComparison.OrdinalIgnoreCase):
                return Model.AB350M_Pro4;
            case var _ when name.Equals("AB350M", StringComparison.OrdinalIgnoreCase):
                return Model.AB350M;
            case var _ when name.Equals("B450 Steel Legend", StringComparison.OrdinalIgnoreCase):
                return Model.B450_Steel_Legend;
            case var _ when name.Equals("B450M Steel Legend", StringComparison.OrdinalIgnoreCase):
                return Model.B450M_Steel_Legend;
            case var _ when name.Equals("B450 Pro4", StringComparison.OrdinalIgnoreCase):
                return Model.B450_Pro4;
            case var _ when name.Equals("B450M Pro4", StringComparison.OrdinalIgnoreCase):
                return Model.B450M_Pro4;
            case var _ when name.Equals("B450M Pro4 R2.0", StringComparison.OrdinalIgnoreCase):
                return Model.B450M_Pro4_R2_0;
            case var _ when name.Equals("Fatal1ty AB350 Gaming K4", StringComparison.OrdinalIgnoreCase):
                return Model.Fatal1ty_AB350_Gaming_K4;
            case var _ when name.Equals("AB350M-HDV", StringComparison.OrdinalIgnoreCase):
                return Model.AB350M_HDV;
            case var _ when name.Equals("X399 Phantom Gaming 6", StringComparison.OrdinalIgnoreCase):
                return Model.X399_Phantom_Gaming_6;
            case var _ when name.Equals("A320M-HDV", StringComparison.OrdinalIgnoreCase):
                return Model.A320M_HDV;
            case var _ when name.Equals("P55 Deluxe", StringComparison.OrdinalIgnoreCase):
                return Model.P55_Deluxe;
            case var _ when name.Equals("Crosshair III Formula", StringComparison.OrdinalIgnoreCase):
                return Model.CROSSHAIR_III_FORMULA;
            case var _ when name.Equals("ROG CROSSHAIR VIII HERO", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_CROSSHAIR_VIII_HERO;
            case var _ when name.Equals("ROG CROSSHAIR VIII HERO (WI-FI)", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_CROSSHAIR_VIII_HERO_WIFI;
            case var _ when name.Equals("ROG CROSSHAIR VIII DARK HERO", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_CROSSHAIR_VIII_DARK_HERO;
            case var _ when name.Equals("ROG CROSSHAIR VIII FORMULA", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_CROSSHAIR_VIII_FORMULA;
            case var _ when name.Equals("ROG CROSSHAIR VIII IMPACT", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_CROSSHAIR_VIII_IMPACT;
            case var _ when name.Equals("PRIME B650-PLUS", StringComparison.OrdinalIgnoreCase):
                return Model.PRIME_B650_PLUS;
            case var _ when name.Equals("ROG CROSSHAIR X670E EXTREME", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_CROSSHAIR_X670E_EXTREME;
            case var _ when name.Equals("ROG CROSSHAIR X670E HERO", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_CROSSHAIR_X670E_HERO;
            case var _ when name.Equals("ROG CROSSHAIR X670E GENE", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_CROSSHAIR_X670E_GENE;
            case var _ when name.Equals("PROART X670E-CREATOR WIFI", StringComparison.OrdinalIgnoreCase):
                return Model.PROART_X670E_CREATOR_WIFI;
            case var _ when name.Equals("M2N-SLI DELUXE", StringComparison.OrdinalIgnoreCase):
                return Model.M2N_SLI_Deluxe;
            case var _ when name.Equals("M4A79XTD EVO", StringComparison.OrdinalIgnoreCase):
                return Model.M4A79XTD_EVO;
            case var _ when name.Equals("P5W DH Deluxe", StringComparison.OrdinalIgnoreCase):
                return Model.P5W_DH_Deluxe;
            case var _ when name.Equals("P6T", StringComparison.OrdinalIgnoreCase):
                return Model.P6T;
            case var _ when name.Equals("P6X58D-E", StringComparison.OrdinalIgnoreCase):
                return Model.P6X58D_E;
            case var _ when name.Equals("P8P67", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("P8P67 REV 3.1", StringComparison.OrdinalIgnoreCase):
                return Model.P8P67;
            case var _ when name.Equals("P8P67 EVO", StringComparison.OrdinalIgnoreCase):
                return Model.P8P67_EVO;
            case var _ when name.Equals("P8P67 PRO", StringComparison.OrdinalIgnoreCase):
                return Model.P8P67_PRO;
            case var _ when name.Equals("P8P67-M PRO", StringComparison.OrdinalIgnoreCase):
                return Model.P8P67_M_PRO;
            case var _ when name.Equals("P8Z77-V", StringComparison.OrdinalIgnoreCase):
                return Model.P8Z77_V;
            case var _ when name.Equals("P9X79", StringComparison.OrdinalIgnoreCase):
                return Model.P9X79;
            case var _ when name.Equals("Rampage Extreme", StringComparison.OrdinalIgnoreCase):
                return Model.RAMPAGE_EXTREME;
            case var _ when name.Equals("Rampage II GENE", StringComparison.OrdinalIgnoreCase):
                return Model.RAMPAGE_II_GENE;
            case var _ when name.Equals("LP BI P45-T2RS Elite", StringComparison.OrdinalIgnoreCase):
                return Model.LP_BI_P45_T2RS_Elite;
            case var _ when name.Equals("ROG STRIX B550-F GAMING (WI-FI)", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_STRIX_B550_F_GAMING_WIFI;
            case var _ when name.Equals("ROG STRIX X470-I GAMING", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_STRIX_X470_I;
            case var _ when name.Equals("ROG STRIX B550-E GAMING", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_STRIX_B550_E_GAMING;
            case var _ when name.Equals("ROG STRIX B550-I GAMING", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_STRIX_B550_I_GAMING;
            case var _ when name.Equals("ROG STRIX B760-I GAMING WIFI", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_STRIX_B760_I_GAMING_WIFI;
            case var _ when name.Equals("ROG STRIX X570-E GAMING", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_STRIX_X570_E_GAMING;
            case var _ when name.Equals("ROG STRIX X570-E GAMING WIFI II", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_STRIX_X570_E_GAMING_WIFI_II;
            case var _ when name.Equals("ROG STRIX X570-I GAMING", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_STRIX_X570_I_GAMING;
            case var _ when name.Equals("ROG STRIX X570-F GAMING", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_STRIX_X570_F_GAMING;
            case var _ when name.Equals("LP DK P55-T3eH9", StringComparison.OrdinalIgnoreCase):
                return Model.LP_DK_P55_T3EH9;
            case var _ when name.Equals("A890GXM-A", StringComparison.OrdinalIgnoreCase):
                return Model.A890GXM_A;
            case var _ when name.Equals("X58 SLI Classified", StringComparison.OrdinalIgnoreCase):
                return Model.X58_SLI_Classified;
            case var _ when name.Equals("132-BL-E758", StringComparison.OrdinalIgnoreCase):
                return Model.X58_3X_SLI;
            case var _ when name.Equals("965P-S3", StringComparison.OrdinalIgnoreCase):
                return Model._965P_S3;
            case var _ when name.Equals("EP45-DS3R", StringComparison.OrdinalIgnoreCase):
                return Model.EP45_DS3R;
            case var _ when name.Equals("EP45-UD3R", StringComparison.OrdinalIgnoreCase):
                return Model.EP45_UD3R;
            case var _ when name.Equals("EX58-EXTREME", StringComparison.OrdinalIgnoreCase):
                return Model.EX58_EXTREME;
            case var _ when name.Equals("EX58-UD3R", StringComparison.OrdinalIgnoreCase):
                return Model.EX58_UD3R;
            case var _ when name.Equals("G41M-Combo", StringComparison.OrdinalIgnoreCase):
                return Model.G41M_COMBO;
            case var _ when name.Equals("G41MT-S2", StringComparison.OrdinalIgnoreCase):
                return Model.G41MT_S2;
            case var _ when name.Equals("G41MT-S2P", StringComparison.OrdinalIgnoreCase):
                return Model.G41MT_S2P;
            case var _ when name.Equals("970A-DS3P", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("970A-DS3P FX", StringComparison.OrdinalIgnoreCase):
                return Model._970A_DS3P;
            case var _ when name.Equals("GA-970A-UD3", StringComparison.OrdinalIgnoreCase):
                return Model._970A_UD3;
            case var _ when name.Equals("GA-MA770T-UD3", StringComparison.OrdinalIgnoreCase):
                return Model.MA770T_UD3;
            case var _ when name.Equals("GA-MA770T-UD3P", StringComparison.OrdinalIgnoreCase):
                return Model.MA770T_UD3P;
            case var _ when name.Equals("GA-MA785GM-US2H", StringComparison.OrdinalIgnoreCase):
                return Model.MA785GM_US2H;
            case var _ when name.Equals("GA-MA785GMT-UD2H", StringComparison.OrdinalIgnoreCase):
                return Model.MA785GMT_UD2H;
            case var _ when name.Equals("GA-MA78LM-S2H", StringComparison.OrdinalIgnoreCase):
                return Model.MA78LM_S2H;
            case var _ when name.Equals("GA-MA790X-UD3P", StringComparison.OrdinalIgnoreCase):
                return Model.MA790X_UD3P;
            case var _ when name.Equals("GA-MA790X-DS4", StringComparison.OrdinalIgnoreCase):
                return Model.MA790X_DS4;
            case var _ when name.Equals("H55-USB3", StringComparison.OrdinalIgnoreCase):
                return Model.H55_USB3;
            case var _ when name.Equals("H55N-USB3", StringComparison.OrdinalIgnoreCase):
                return Model.H55N_USB3;
            case var _ when name.Equals("H61M-DGS", StringComparison.OrdinalIgnoreCase):
                return Model.H61M_DGS;
            case var _ when name.Equals("H61M-DS2 REV 1.2", StringComparison.OrdinalIgnoreCase):
                return Model.H61M_DS2_REV_1_2;
            case var _ when name.Equals("H61M-USB3-B3 REV 2.0", StringComparison.OrdinalIgnoreCase):
                return Model.H61M_USB3_B3_REV_2_0;
            case var _ when name.Equals("H67A-UD3H-B3", StringComparison.OrdinalIgnoreCase):
                return Model.H67A_UD3H_B3;
            case var _ when name.Equals("H67A-USB3-B3", StringComparison.OrdinalIgnoreCase):
                return Model.H67A_USB3_B3;
            case var _ when name.Equals("H97-D3H-CF", StringComparison.OrdinalIgnoreCase):
                return Model.H97_D3H;
            case var _ when name.Equals("H81M-HD3", StringComparison.OrdinalIgnoreCase):
                return Model.H81M_HD3;
            case var _ when name.Equals("B75M-D3H", StringComparison.OrdinalIgnoreCase):
                return Model.B75M_D3H;
            case var _ when name.Equals("P35-DS3", StringComparison.OrdinalIgnoreCase):
                return Model.P35_DS3;
            case var _ when name.Equals("P35-DS3L", StringComparison.OrdinalIgnoreCase):
                return Model.P35_DS3L;
            case var _ when name.Equals("P55-UD4", StringComparison.OrdinalIgnoreCase):
                return Model.P55_UD4;
            case var _ when name.Equals("P55A-UD3", StringComparison.OrdinalIgnoreCase):
                return Model.P55A_UD3;
            case var _ when name.Equals("P55M-UD4", StringComparison.OrdinalIgnoreCase):
                return Model.P55M_UD4;
            case var _ when name.Equals("P67A-UD3-B3", StringComparison.OrdinalIgnoreCase):
                return Model.P67A_UD3_B3;
            case var _ when name.Equals("P67A-UD3R-B3", StringComparison.OrdinalIgnoreCase):
                return Model.P67A_UD3R_B3;
            case var _ when name.Equals("P67A-UD4-B3", StringComparison.OrdinalIgnoreCase):
                return Model.P67A_UD4_B3;
            case var _ when name.Equals("P8Z68-V PRO", StringComparison.OrdinalIgnoreCase):
                return Model.P8Z68_V_PRO;
            case var _ when name.Equals("X38-DS5", StringComparison.OrdinalIgnoreCase):
                return Model.X38_DS5;
            case var _ when name.Equals("X58A-UD3R", StringComparison.OrdinalIgnoreCase):
                return Model.X58A_UD3R;
            case var _ when name.Equals("Z270 PC MATE", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("Z270 PC MATE (MS-7A72)", StringComparison.OrdinalIgnoreCase):
                return Model.Z270_PC_MATE;
            case var _ when name.Equals("Z77 MPower", StringComparison.OrdinalIgnoreCase):       // MS-7751 Rev 4.x
            case var _ when name.Equals("Z77 MPower (MS-7751)", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("Z77A-GD65", StringComparison.OrdinalIgnoreCase):        // MS-7751 Rev >1.x
            case var _ when name.Equals("Z77A-GD65 (MS-7751)", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("Z77A-GD65 GAMING", StringComparison.OrdinalIgnoreCase): // MS-7751 Rev 2.x
            case var _ when name.Equals("Z77A-GD65 GAMING (MS-7751)", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("Z77A-GD55", StringComparison.OrdinalIgnoreCase):        // MS-7751 Rev 1.x
            case var _ when name.Equals("Z77A-GD55 (MS-7751)", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("Z77A-GD80", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("Z77A-GD80 (MS-7757)", StringComparison.OrdinalIgnoreCase):
                return Model.Z77_MS7751;
            case var _ when name.Equals("Z68A-GD80", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("Z68A-GD80 (MS-7672)", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("P67A-GD80", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("P67A-GD80 (MS-7672)", StringComparison.OrdinalIgnoreCase):
                return Model.Z68_MS7672;
            case var _ when name.Equals("X79-UD3", StringComparison.OrdinalIgnoreCase):
                return Model.X79_UD3;
            case var _ when name.Equals("Z68A-D3H-B3", StringComparison.OrdinalIgnoreCase):
                return Model.Z68A_D3H_B3;
            case var _ when name.Equals("Z68AP-D3", StringComparison.OrdinalIgnoreCase):
                return Model.Z68AP_D3;
            case var _ when name.Equals("Z68X-UD3H-B3", StringComparison.OrdinalIgnoreCase):
                return Model.Z68X_UD3H_B3;
            case var _ when name.Equals("Z68X-UD7-B3", StringComparison.OrdinalIgnoreCase):
                return Model.Z68X_UD7_B3;
            case var _ when name.Equals("Z68XP-UD3R", StringComparison.OrdinalIgnoreCase):
                return Model.Z68XP_UD3R;
            case var _ when name.Equals("Z170N-WIFI-CF", StringComparison.OrdinalIgnoreCase):
                return Model.Z170N_WIFI;
            case var _ when name.Equals("Z390 M GAMING-CF", StringComparison.OrdinalIgnoreCase):
                return Model.Z390_M_GAMING;
            case var _ when name.Equals("Z390 AORUS ULTRA", StringComparison.OrdinalIgnoreCase):
                return Model.Z390_AORUS_ULTRA;
            case var _ when name.Equals("Z390 AORUS PRO-CF", StringComparison.OrdinalIgnoreCase):
                return Model.Z390_AORUS_PRO;
            case var _ when name.Equals("Z390 UD", StringComparison.OrdinalIgnoreCase):
                return Model.Z390_UD;
            case var _ when name.Equals("Z690 AORUS PRO", StringComparison.OrdinalIgnoreCase):
                return Model.Z690_AORUS_PRO;
            case var _ when name.Equals("Z690 AORUS ULTRA", StringComparison.OrdinalIgnoreCase):
                return Model.Z690_AORUS_ULTRA;
            case var _ when name.Equals("Z690 AORUS MASTER", StringComparison.OrdinalIgnoreCase):
                return Model.Z690_AORUS_MASTER;
            case var _ when name.Equals("Z690 GAMING X DDR4", StringComparison.OrdinalIgnoreCase):
                return Model.Z690_GAMING_X_DDR4;
            case var _ when name.Equals("Z790 AORUS PRO X", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("Z790 AORUS PRO X WIFI7", StringComparison.OrdinalIgnoreCase):
                return Model.Z790_AORUS_PRO_X;
            case var _ when name.Equals("Z790 UD", StringComparison.OrdinalIgnoreCase):
                return Model.Z790_UD;
            case var _ when name.Equals("Z790 UD AC", StringComparison.OrdinalIgnoreCase):
                return Model.Z790_UD_AC;
            case var _ when name.Equals("Z790 GAMING X", StringComparison.OrdinalIgnoreCase):
                return Model.Z790_GAMING_X;
            case var _ when name.Equals("Z790 GAMING X AX", StringComparison.OrdinalIgnoreCase):
                return Model.Z790_GAMING_X_AX;
            case var _ when name.Equals("FH67", StringComparison.OrdinalIgnoreCase):
                return Model.FH67;
            case var _ when name.Equals("AX370-Gaming K7", StringComparison.OrdinalIgnoreCase):
                return Model.AX370_Gaming_K7;
            case var _ when name.Equals("PRIME X370-PRO", StringComparison.OrdinalIgnoreCase):
                return Model.PRIME_X370_PRO;
            case var _ when name.Equals("PRIME X470-PRO", StringComparison.OrdinalIgnoreCase):
                return Model.PRIME_X470_PRO;
            case var _ when name.Equals("PRIME X570-PRO", StringComparison.OrdinalIgnoreCase):
                return Model.PRIME_X570_PRO;
            case var _ when name.Equals("ProArt X570-CREATOR WIFI", StringComparison.OrdinalIgnoreCase):
                return Model.PROART_X570_CREATOR_WIFI;
            case var _ when name.Equals("Pro WS X570-ACE", StringComparison.OrdinalIgnoreCase):
                return Model.PRO_WS_X570_ACE;
            case var _ when name.Equals("ROG MAXIMUS X APEX", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_MAXIMUS_X_APEX;
            case var _ when name.Equals("AB350-Gaming 3-CF", StringComparison.OrdinalIgnoreCase):
                return Model.AB350_Gaming_3;
            case var _ when name.Equals("X399 AORUS Gaming 7", StringComparison.OrdinalIgnoreCase):
                return Model.X399_AORUS_Gaming_7;
            case var _ when name.Equals("ROG ZENITH EXTREME", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_ZENITH_EXTREME;
            case var _ when name.Equals("ROG ZENITH II EXTREME", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_ZENITH_II_EXTREME;
            case var _ when name.Equals("Z170-A", StringComparison.OrdinalIgnoreCase):
                return Model.Z170_A;
            case var _ when name.Equals("Z170 PRO GAMING", StringComparison.OrdinalIgnoreCase):
                return Model.Z170_PRO_GAMING;
            case var _ when name.Equals("B150M-C", StringComparison.OrdinalIgnoreCase):
                return Model.B150M_C;
            case var _ when name.Equals("B150M-C D3", StringComparison.OrdinalIgnoreCase):
                return Model.B150M_C_D3;
            case var _ when name.Equals("Z77 Pro4-M", StringComparison.OrdinalIgnoreCase):
                return Model.Z77Pro4M;
            case var _ when name.Equals("X570 Pro4", StringComparison.OrdinalIgnoreCase):
                return Model.X570_Pro4;
            case var _ when name.Equals("X570 Taichi", StringComparison.OrdinalIgnoreCase):
                return Model.X570_Taichi;
            case var _ when name.Equals("X570 Phantom Gaming-ITX/TB3", StringComparison.OrdinalIgnoreCase):
                return Model.X570_Phantom_Gaming_ITX;
            case var _ when name.Equals("X570 Phantom Gaming 4", StringComparison.OrdinalIgnoreCase):
                return Model.X570_Phantom_Gaming_4;
            case var _ when name.Equals("AX370-Gaming 5", StringComparison.OrdinalIgnoreCase):
                return Model.AX370_Gaming_5;
            case var _ when name.Equals("TUF X470-PLUS GAMING", StringComparison.OrdinalIgnoreCase):
                return Model.TUF_X470_PLUS_GAMING;
            case var _ when name.Equals("TUF GAMING X870-PLUS WIFI", StringComparison.OrdinalIgnoreCase):
                return Model.TUF_GAMING_X870_PLUS_WIFI;
            case var _ when name.Equals("B360M PRO-VDH (MS-7B24)", StringComparison.OrdinalIgnoreCase):
                return Model.B360M_PRO_VDH;
            case var _ when name.Equals("A320M-S2H-CF", StringComparison.OrdinalIgnoreCase):
                return Model.A320M_S2H_CF;
            case var _ when name.Equals("B360M H", StringComparison.OrdinalIgnoreCase):
                return Model.B360M_H;
            case var _ when name.Equals("B550-A PRO (MS-7C56)", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("PRO B550-VC (MS-7C56)", StringComparison.OrdinalIgnoreCase):
                return Model.B550A_PRO;
            case var _ when name.Equals("B450-A PRO (MS-7B86)", StringComparison.OrdinalIgnoreCase):
                return Model.B450A_PRO;
            case var _ when name.Equals("B350 GAMING PLUS (MS-7A34)", StringComparison.OrdinalIgnoreCase):
                return Model.B350_Gaming_Plus;
            case var _ when name.Equals("B450 AORUS PRO", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("B450 AORUS PRO WIFI", StringComparison.OrdinalIgnoreCase):
                return Model.B450_AORUS_PRO;
            case var _ when name.Equals("B450 GAMING X", StringComparison.OrdinalIgnoreCase):
                return Model.B450_GAMING_X;
            case var _ when name.Equals("B450 AORUS ELITE", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("B450 AORUS ELITE V2", StringComparison.OrdinalIgnoreCase):
                return Model.B450_AORUS_ELITE;
            case var _ when name.Equals("B450M AORUS ELITE", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("B450M AORUS ELITE-CF", StringComparison.OrdinalIgnoreCase):
                return Model.B450M_AORUS_ELITE;
            case var _ when name.Equals("B450M GAMING", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("B450M GAMING-CF", StringComparison.OrdinalIgnoreCase):
                return Model.B450M_GAMING;
            case var _ when name.Equals("B450M AORUS M", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("B450M AORUS M-CF", StringComparison.OrdinalIgnoreCase):
                return Model.B450_AORUS_M;
            case var _ when name.Equals("B450M DS3H", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("B450M DS3H WIFI", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("B450M DS3H-CF", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("B450M DS3H WIFI-CF", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("B450M DS3H V2", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("B450M DS3H V2-CF", StringComparison.OrdinalIgnoreCase):
                return Model.B450M_DS3H;
            case var _ when name.Equals("B450M S2H", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("B450M S2H V2", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("B450M S2H-CF", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("B450M S2H V2-CF", StringComparison.OrdinalIgnoreCase):
                return Model.B450M_S2H;
            case var _ when name.Equals("B450M H", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("B450M H-CF", StringComparison.OrdinalIgnoreCase):
                return Model.B450M_H;
            case var _ when name.Equals("B450M K", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("B450M K-CF", StringComparison.OrdinalIgnoreCase):
                return Model.B450M_K;
            case var _ when name.Equals("B450M I AORUS PRO WIFI", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("B450M I AORUS PRO WIFI-CF", StringComparison.OrdinalIgnoreCase):
                return Model.B450_I_AORUS_PRO_WIFI;
            case var _ when name.Equals("X470 AORUS GAMING 7 WIFI-CF", StringComparison.OrdinalIgnoreCase):
                return Model.X470_AORUS_GAMING_7_WIFI;
            case var _ when name.Equals("X570 AORUS MASTER", StringComparison.OrdinalIgnoreCase):
                return Model.X570_AORUS_MASTER;
            case var _ when name.Equals("X570 AORUS PRO", StringComparison.OrdinalIgnoreCase):
                return Model.X570_AORUS_PRO;
            case var _ when name.Equals("X570 AORUS ULTRA", StringComparison.OrdinalIgnoreCase):
                return Model.X570_AORUS_ULTRA;
            case var _ when name.Equals("X570 GAMING X", StringComparison.OrdinalIgnoreCase):
                return Model.X570_GAMING_X;
            case var _ when name.Equals("TUF GAMING X570-PLUS (WI-FI)", StringComparison.OrdinalIgnoreCase):
                return Model.TUF_GAMING_X570_PLUS_WIFI;
            case var _ when name.Equals("TUF GAMING B550M-PLUS (WI-FI)", StringComparison.OrdinalIgnoreCase):
                return Model.TUF_GAMING_B550M_PLUS_WIFI;
            case var _ when name.Equals("TUF GAMING B760M-PLUS WIFI D4", StringComparison.OrdinalIgnoreCase):
                return Model.TUF_GAMING_B760M_PLUS_WIFI_D4;
            case var _ when name.Equals("B360 AORUS GAMING 3 WIFI-CF", StringComparison.OrdinalIgnoreCase):
                return Model.B360_AORUS_GAMING_3_WIFI_CF;
            case var _ when name.Equals("B550I AORUS PRO AX", StringComparison.OrdinalIgnoreCase):
                return Model.B550I_AORUS_PRO_AX;
            case var _ when name.Equals("B550M AORUS PRO", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("B550M AORUS PRO-P", StringComparison.OrdinalIgnoreCase):
                return Model.B550M_AORUS_PRO;
            case var _ when name.Equals("B550M AORUS PRO AX", StringComparison.OrdinalIgnoreCase):
                return Model.B550M_AORUS_PRO_AX;
            case var _ when name.Equals("B550M AORUS ELITE", StringComparison.OrdinalIgnoreCase):
                return Model.B550M_AORUS_ELITE;
            case var _ when name.Equals("B550M GAMING", StringComparison.OrdinalIgnoreCase):
                return Model.B550M_GAMING;
            case var _ when name.Equals("B550M DS3H", StringComparison.OrdinalIgnoreCase):
                return Model.B550M_DS3H;
            case var _ when name.Equals("B550M DS3H AC", StringComparison.OrdinalIgnoreCase):
                return Model.B550M_DS3H_AC;
            case var _ when name.Equals("B550M S2H", StringComparison.OrdinalIgnoreCase):
                return Model.B550M_S2H;
            case var _ when name.Equals("B550M H", StringComparison.OrdinalIgnoreCase):
                return Model.B550M_H;
            case var _ when name.Equals("B550 AORUS MASTER", StringComparison.OrdinalIgnoreCase):
                return Model.B550_AORUS_MASTER;
            case var _ when name.Equals("B550 AORUS PRO", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("B550 AORUS PRO V2", StringComparison.OrdinalIgnoreCase):
                return Model.B550_AORUS_PRO;
            case var _ when name.Equals("B550 AORUS PRO AC", StringComparison.OrdinalIgnoreCase):
                return Model.B550_AORUS_PRO_AC;
            case var _ when name.Equals("B550 AORUS PRO AX", StringComparison.OrdinalIgnoreCase):
                return Model.B550_AORUS_PRO_AX;
            case var _ when name.Equals("B550 VISION D", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("B550 VISION D-P", StringComparison.OrdinalIgnoreCase):
                return Model.B550_VISION_D;
            case var _ when name.Equals("B550 AORUS ELITE", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("B550 AORUS ELITE V2", StringComparison.OrdinalIgnoreCase):
                return Model.B550_AORUS_ELITE;
            case var _ when name.Equals("B550 AORUS ELITE AX", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("B550 AORUS ELITE AX V2", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("B550 AORUS ELITE AX V3", StringComparison.OrdinalIgnoreCase):
                return Model.B550_AORUS_ELITE_AX;
            case var _ when name.Equals("B550 GAMING X", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("B550 GAMING X V2", StringComparison.OrdinalIgnoreCase):
                return Model.B550_GAMING_X;
            case var _ when name.Equals("B550 UD AC", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("B550 UD AC-Y1", StringComparison.OrdinalIgnoreCase):
                return Model.B550_UD_AC;
            case var _ when name.Equals("B560M AORUS ELITE", StringComparison.OrdinalIgnoreCase):
                return Model.B560M_AORUS_ELITE;
            case var _ when name.Equals("B560M AORUS PRO", StringComparison.OrdinalIgnoreCase):
                return Model.B560M_AORUS_PRO;
            case var _ when name.Equals("B560M AORUS PRO AX", StringComparison.OrdinalIgnoreCase):
                return Model.B560M_AORUS_PRO_AX;
            case var _ when name.Equals("B560I AORUS PRO AX", StringComparison.OrdinalIgnoreCase):
                return Model.B560I_AORUS_PRO_AX;
            case var _ when name.Equals("B650 AORUS ELITE", StringComparison.OrdinalIgnoreCase):
                return Model.B650_AORUS_ELITE;
            case var _ when name.Equals("B650 EAGLE AX", StringComparison.OrdinalIgnoreCase):
                return Model.B650_EAGLE_AX;
            case var _ when name.Equals("B650 AORUS ELITE AX", StringComparison.OrdinalIgnoreCase):
                return Model.B650_AORUS_ELITE_AX;
            case var _ when name.Equals("B650 AORUS ELITE V2", StringComparison.OrdinalIgnoreCase):
                return Model.B650_AORUS_ELITE_V2;
            case var _ when name.Equals("B650 AORUS ELITE AX V2", StringComparison.OrdinalIgnoreCase):
                return Model.B650_AORUS_ELITE_AX_V2;
            case var _ when name.Equals("B650 AORUS ELITE AX ICE", StringComparison.OrdinalIgnoreCase):
                return Model.B650_AORUS_ELITE_AX_ICE;
            case var _ when name.Equals("B650 GAMING X AX", StringComparison.OrdinalIgnoreCase):
                return Model.B650_GAMING_X_AX;
            case var _ when name.Equals("B650E AORUS ELITE AX ICE", StringComparison.OrdinalIgnoreCase):
                return Model.B650E_AORUS_ELITE_AX_ICE;
            case var _ when name.Equals("B650M AORUS PRO", StringComparison.OrdinalIgnoreCase):
                return Model.B650M_AORUS_PRO;
            case var _ when name.Equals("B650M AORUS PRO AX", StringComparison.OrdinalIgnoreCase):
                return Model.B650M_AORUS_PRO_AX;
            case var _ when name.Equals("B650M AORUS ELITE", StringComparison.OrdinalIgnoreCase):
                return Model.B650M_AORUS_ELITE;
            case var _ when name.Equals("B650M AORUS ELITE AX", StringComparison.OrdinalIgnoreCase):
                return Model.B650M_AORUS_ELITE_AX;
            case var _ when name.Equals("B650I AX", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("A620I AX", StringComparison.OrdinalIgnoreCase):
                return Model.B650I_AX;
            case var _ when name.Equals("ROG STRIX Z390-E GAMING", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_STRIX_Z390_E_GAMING;
            case var _ when name.Equals("ROG STRIX Z390-F GAMING", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_STRIX_Z390_F_GAMING;
            case var _ when name.Equals("ROG STRIX Z390-I GAMING", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_STRIX_Z390_I_GAMING;
            case var _ when name.Equals("ROG STRIX Z690-A GAMING WIFI D4", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_STRIX_Z690_A_GAMING_WIFI_D4;
            case var _ when name.Equals("ROG STRIX Z690-G GAMING WIFI", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_STRIX_Z690_G_GAMING_WIFI;
            case var _ when name.Equals("ROG MAXIMUS XI FORMULA", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_MAXIMUS_XI_FORMULA;
            case var _ when name.Equals("ROG MAXIMUS XII FORMULA", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_MAXIMUS_XII_Z490_FORMULA;
            case var _ when name.Equals("ROG MAXIMUS X HERO (WI-FI AC)", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_MAXIMUS_X_HERO_WIFI_AC;
            case var _ when name.Equals("ROG MAXIMUS Z690 FORMULA", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_MAXIMUS_Z690_FORMULA;
            case var _ when name.Equals("ROG MAXIMUS Z690 HERO", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_MAXIMUS_Z690_HERO;
            case var _ when name.Equals("ROG MAXIMUS Z690 EXTREME GLACIAL", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_MAXIMUS_Z690_EXTREME_GLACIAL;
            case var _ when name.Equals("ROG STRIX X670E-A GAMING WIFI", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_STRIX_X670E_A_GAMING_WIFI;
            case var _ when name.Equals("ROG STRIX X670E-E GAMING WIFI", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_STRIX_X670E_E_GAMING_WIFI;
            case var _ when name.Equals("ROG STRIX X670E-F GAMING WIFI", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_STRIX_X670E_F_GAMING_WIFI;
            case var _ when name.Equals("ROG STRIX B850-E GAMING WIFI", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_STRIX_B850_E_GAMING_WIFI;
            case var _ when name.Equals("ROG STRIX B850-I GAMING WIFI", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_STRIX_B850_I_GAMING_WIFI;
            case var _ when name.Equals("ROG STRIX X870E-E GAMING WIFI", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_STRIX_X870E_E_GAMING_WIFI;
            case var _ when name.Equals("B660GTN", StringComparison.OrdinalIgnoreCase):
                return Model.B660GTN;
            case var _ when name.Equals("X670E VALKYRIE", StringComparison.OrdinalIgnoreCase):
                return Model.X670E_Valkyrie;
            case var _ when name.Equals("ROG MAXIMUS Z790 HERO", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_MAXIMUS_Z790_HERO;
            case var _ when name.Equals("ROG MAXIMUS Z790 DARK HERO", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_MAXIMUS_Z790_DARK_HERO;
            case var _ when name.Equals("PRIME Z690-A", StringComparison.OrdinalIgnoreCase):
                return Model.PRIME_Z690_A;
            case var _ when name.Equals("Z690 Steel Legend WiFi 6E", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("Z690 Steel Legend", StringComparison.OrdinalIgnoreCase):
                return Model.Z690_Steel_Legend;
            case var _ when name.Equals("Z690 Extreme WiFi 6E", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("Z690 Extreme", StringComparison.OrdinalIgnoreCase):
                return Model.Z690_Extreme;
            case var _ when name.Equals("Z790 Pro RS", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("Z790 Pro RS WiFi", StringComparison.OrdinalIgnoreCase):
                return Model.Z790_Pro_RS;
            case var _ when name.Equals("Z790 Taichi", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("Z790 Taichi Carrara", StringComparison.OrdinalIgnoreCase):
                return Model.Z790_Taichi;
            case var _ when name.Equals("B650M-C", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("B650M-CW", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("B650M-CX", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("B650M-CWX", StringComparison.OrdinalIgnoreCase):
                return Model.B650M_C;
            case var _ when name.Equals("B650M GAMING PLUS WIFI (MS-7E24)", StringComparison.OrdinalIgnoreCase):
                return Model.B650M_Gaming_Plus_Wifi;
            case var _ when name.Equals("B660 DS3H DDR4-Y1", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("B660 DS3H DDR4", StringComparison.OrdinalIgnoreCase):
                return Model.B660_DS3H_DDR4;
            case var _ when name.Equals("B660 DS3H AC DDR4-Y1", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("B660 DS3H AC DDR4", StringComparison.OrdinalIgnoreCase):
                return Model.B660_DS3H_AC_DDR4;
            case var _ when name.Equals("B660M DS3H AX DDR4", StringComparison.OrdinalIgnoreCase):
                return Model.B660M_DS3H_AX_DDR4;
            case var _ when name.Equals("MEG X570 UNIFY", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("MEG X570 UNIFY (MS-7C35)", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("MEG X570 ACE", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("MEG X570 ACE (MS-7C35)", StringComparison.OrdinalIgnoreCase):
                return Model.X570_MS7C35;
            case var _ when name.Equals("ROG STRIX Z790-I GAMING WIFI", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_STRIX_Z790_I_GAMING_WIFI;
            case var _ when name.Equals("ROG STRIX Z790-E GAMING WIFI", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_STRIX_Z790_E_GAMING_WIFI;
            case var _ when name.Equals("ROG STRIX Z790-E GAMING WIFI II", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_STRIX_Z790_E_GAMING_WIFI_II;
            case var _ when name.Equals("MPG X570 GAMING PLUS (MS-7C37)", StringComparison.OrdinalIgnoreCase):
                return Model.X570_Gaming_Plus;
            case var _ when name.Equals("ROG MAXIMUS Z790 FORMULA", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_MAXIMUS_Z790_FORMULA;
            case var _ when name.Equals("Z790 Nova WiFi", StringComparison.OrdinalIgnoreCase):
                return Model.Z790_Nova_WiFi;
            case var _ when name.Equals("ROG MAXIMUS XII HERO (WI-FI)", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_MAXIMUS_XII_HERO_WIFI;
            case var _ when name.Equals("X670E AORUS XTREME", StringComparison.OrdinalIgnoreCase):
                return Model.X670E_AORUS_XTREME;
            case var _ when name.Equals("X870E AORUS PRO", StringComparison.OrdinalIgnoreCase):
                return Model.X870E_AORUS_PRO;
            case var _ when name.Equals("X870E AORUS PRO ICE", StringComparison.OrdinalIgnoreCase):
                return Model.X870E_AORUS_PRO_ICE;
            case var _ when name.Equals("ROG STRIX X870-I GAMING WIFI", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_STRIX_X870_I_GAMING_WIFI;
            case var _ when name.Equals("X870E AORUS XTREME AI TOP", StringComparison.OrdinalIgnoreCase):
                return Model.X870E_AORUS_XTREME_AI_TOP;
            case var _ when name.Equals("PROART X870E-CREATOR WIFI", StringComparison.OrdinalIgnoreCase):
                return Model.PROART_X870E_CREATOR_WIFI;
            case var _ when name.Equals("PRIME X870-P", StringComparison.OrdinalIgnoreCase):
                return Model.PRIME_X870_P;
            case var _ when name.Equals("ROG STRIX X870-I GAMING WIFI", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_STRIX_X870_I_GAMING_WIFI;
            case var _ when name.Equals("ROG CROSSHAIR X870E APEX", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_CROSSHAIR_X870E_APEX;
            case var _ when name.Equals("ROG CROSSHAIR X870E HERO", StringComparison.OrdinalIgnoreCase):
                return Model.ROG_CROSSHAIR_X870E_HERO;
            case var _ when name.Equals("MPG Z890 CARBON WIFI (MS-7E17)", StringComparison.OrdinalIgnoreCase):
                return Model.Z890_CARBON_WIFI;
            case var _ when name.Equals("MAG X870E TOMAHAWK WIFI (MS-7E59)", StringComparison.OrdinalIgnoreCase):
                return Model.X870E_TOMAHAWK_WIFI;
            case var _ when name.Equals("MPG X870E CARBON WIFI (MS-7E49)", StringComparison.OrdinalIgnoreCase):
                return Model.X870E_CARBON_WIFI;
            case var _ when name.Equals("MPG Z890 EDGE TI WIFI (MS-7E19)", StringComparison.OrdinalIgnoreCase):
                return Model.Z890_EDGE_TI_WIFI;
            case var _ when name.Equals("X11SWN-E", StringComparison.OrdinalIgnoreCase):
                return Model.X11SWN_E;
            case var _ when name.Equals("PRO B840-P WIFI (MS-7E57)", StringComparison.OrdinalIgnoreCase):
                return Model.B840P_PRO_WIFI;
            case var _ when name.Equals("B840M GAMING PLUS WIFI6E (MS-7E77)", StringComparison.OrdinalIgnoreCase):
                return Model.B840M_GAMING_PLUS_WIFI6E;
            case var _ when name.Equals("B850 GAMING PLUS WIFI6E (MS-7E80)", StringComparison.OrdinalIgnoreCase):
                return Model.B850_GAMING_PLUS_WIFI6E;
            case var _ when name.Equals("PRO B850-P WIFI (MS-7E56)", StringComparison.OrdinalIgnoreCase):
                return Model.B850P_PRO_WIFI;
            case var _ when name.Equals("PRO B850-S WIFI6E (MS-7E80)", StringComparison.OrdinalIgnoreCase):
                return Model.B850S_PRO_WIFI6E;
            case var _ when name.Equals("PRO B850M-A WIFI (MS-7E66)", StringComparison.OrdinalIgnoreCase):
                return Model.B850MA_PRO_WIFI;
            case var _ when name.Equals("PRO B850M-A WIFI PZ (MS-7E78)", StringComparison.OrdinalIgnoreCase):
                return Model.B850MA_PRO_WIFI_PZ;
            case var _ when name.Equals("PRO B850M-P WIFI (MS-7E71)", StringComparison.OrdinalIgnoreCase):
                return Model.B850MP_PRO_WIFI;
            case var _ when name.Equals("B850 GAMING PLUS WIFI (MS-7E56)", StringComparison.OrdinalIgnoreCase):
                return Model.B850_GAMING_PLUS_WIFI;
            case var _ when name.Equals("B850 GAMING PLUS WIFI PZ (MS-7E75)", StringComparison.OrdinalIgnoreCase):
                return Model.B850_GAMING_PLUS_WIFI_PZ;
            case var _ when name.Equals("B850M GAMING PLUS WIFI (MS-7E66)", StringComparison.OrdinalIgnoreCase):
                return Model.B850M_GAMING_PLUS_WIFI;
            case var _ when name.Equals("B850M GAMING PLUS WIFI6E (MS-7E81)", StringComparison.OrdinalIgnoreCase):
                return Model.B850M_GAMING_PLUS_WIFI6E;
            case var _ when name.Equals("MAG B850M MORTAR (MS-7E61)", StringComparison.OrdinalIgnoreCase):
                return Model.B850M_MORTAR;
            case var _ when name.Equals("MAG B850M MORTAR WIFI (MS-7E61)", StringComparison.OrdinalIgnoreCase):
                return Model.B850M_MORTAR_WIFI;
            case var _ when name.Equals("MAG B850 TOMAHAWK WIFI (MS-7E53)", StringComparison.OrdinalIgnoreCase):
                return Model.B850_TOMAHAWK_WIFI;
            case var _ when name.Equals("MAG B850 TOMAHAWK MAX WIFI (MS-7E62)", StringComparison.OrdinalIgnoreCase):
                return Model.B850_TOMAHAWK_MAX_WIFI;
            case var _ when name.Equals("MPG B850 EDGE TI WIFI (MS-7E62)", StringComparison.OrdinalIgnoreCase):
                return Model.B850_EDGE_TI_WIFI;
            case var _ when name.Equals("MPG B850I EDGE TI WIFI (MS-7E79)", StringComparison.OrdinalIgnoreCase):
                return Model.B850I_EDGE_TI_WIFI;
            case var _ when name.Equals("B850MPOWER (MS-7E83)", StringComparison.OrdinalIgnoreCase):
                return Model.B850MPOWER;
            case var _ when name.Equals("X870 GAMING PLUS WIFI (MS-7E47)", StringComparison.OrdinalIgnoreCase):
                return Model.X870_GAMING_PLUS_WIFI;
            case var _ when name.Equals("X870E GAMING PLUS WIFI (MS-7E70)", StringComparison.OrdinalIgnoreCase):
                return Model.X870E_GAMING_PLUS_WIFI;
            case var _ when name.Equals("MAG X870 TOMAHAWK WIFI (MS-7E51)", StringComparison.OrdinalIgnoreCase):
                return Model.X870_TOMAHAWK_WIFI;
            case var _ when name.Equals("MAG X870E TOMAHAWK WIFI (MS-7E59)", StringComparison.OrdinalIgnoreCase):
                return Model.X870E_TOMAHAWK_WIFI;
            case var _ when name.Equals("MAG X870E TOMAHAWK MAX WIFI PZ (MS-7E84)", StringComparison.OrdinalIgnoreCase):
                return Model.X870E_TOMAHAWK_MAX_WIFI_PZ;
            case var _ when name.Equals("MEG X870E GODLIKE (MS-7E48)", StringComparison.OrdinalIgnoreCase):
                return Model.X870E_GODLIKE;
            case var _ when name.Equals("PRO X870-P WIFI (MS-7E47)", StringComparison.OrdinalIgnoreCase):
                return Model.X870P_PRO_WIFI;
            case var _ when name.Equals("PRO X870E-P WIFI (MS-7E70)", StringComparison.OrdinalIgnoreCase):
                return Model.X870EP_PRO_WIFI;
            case var _ when name.Equals("MPG X870E CARBON WIFI (MS-7E49)", StringComparison.OrdinalIgnoreCase):
                return Model.X870E_CARBON_WIFI;
            case var _ when name.Equals("MPG X870E EDGE TI WIFI (MS-7E59)", StringComparison.OrdinalIgnoreCase):
                return Model.X870E_EDGE_TI_WIFI;
            case var _ when name.Equals("MEG X870E ACE MAX (MS-7E85)", StringComparison.OrdinalIgnoreCase):
                return Model.X870E_ACE_MAX;
            case var _ when name.Equals("MEG Z790 GODLIKE MAX (MS-7D85)", StringComparison.OrdinalIgnoreCase):
                return Model.Z790_GODLIKE_MAX;
            case var _ when name.Equals("MEG Z890 ACE (MS-7E22)", StringComparison.OrdinalIgnoreCase):
                return Model.Z890_ACE;
            case var _ when name.Equals("MEG Z890 UNIFY-X (MS-7E20)", StringComparison.OrdinalIgnoreCase):
                return Model.Z890_UNIFY_X;
            case var _ when name.Equals("MAG Z890 TOMAHAWK WIFI (MS-7E32)", StringComparison.OrdinalIgnoreCase):
                return Model.Z890_TOMAHAWK_WIFI;
            case var _ when name.Equals("MPG Z890 CARBON WIFI (MS-7E17)", StringComparison.OrdinalIgnoreCase):
                return Model.Z890_CARBON_WIFI;
            case var _ when name.Equals("MPG Z890 EDGE TI WIFI (MS-7E19)", StringComparison.OrdinalIgnoreCase):
                return Model.Z890_EDGE_TI_WIFI;
            case var _ when name.Equals("MPG Z890I EDGE TI WIFI (MS-7E33)", StringComparison.OrdinalIgnoreCase):
                return Model.Z890I_EDGE_TI_WIFI;
            case var _ when name.Equals("PRO Z890-P WIFI (MS-7E34)", StringComparison.OrdinalIgnoreCase):
                return Model.Z890P_PRO_WIFI;
            case var _ when name.Equals("PRO Z890-A WIFI (MS-7E32)", StringComparison.OrdinalIgnoreCase):
                return Model.Z890A_PRO_WIFI;
            case var _ when name.Equals("PRO Z890-S WIFI (MS-7E54)", StringComparison.OrdinalIgnoreCase):
                return Model.Z890S_PRO_WIFI;
            case var _ when name.Equals("Z890 GAMING PLUS WIFI (MS-7E34)", StringComparison.OrdinalIgnoreCase):
                return Model.Z890_GAMING_PLUS_WIFI;
            case var _ when name.Equals("PRO Z890-S WIFI PZ (MS-7E58)", StringComparison.OrdinalIgnoreCase):
                return Model.Z890S_PRO_WIFI_PROJECT_ZERO;
            case var _ when name.Equals("B850M Steel Legend WiFi", StringComparison.OrdinalIgnoreCase):
                return Model.B850M_STEEL_LEGEND_WIFI;
            case var _ when name.Equals("X870E Taichi", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("X870E Taichi Lite", StringComparison.OrdinalIgnoreCase):
                return Model.X870E_TAICHI;
            case var _ when name.Equals("X870E Nova WiFi", StringComparison.OrdinalIgnoreCase):
                return Model.X870E_NOVA_WIFI;
            case var _ when name.Equals("X670 AORUS ELITE AX", StringComparison.OrdinalIgnoreCase):
                return Model.X670_AORUS_ELITE_AX;
            case var _ when name.Equals("PROART B760-CREATOR D4", StringComparison.OrdinalIgnoreCase):
                return Model.PROART_B760_CREATOR_D4;
            case var _ when name.Equals("TUF GAMING B450-PLUS II", StringComparison.OrdinalIgnoreCase):
                return Model.TUF_GAMING_B450_PLUS_II;
            case var _ when name.Equals("FRANBMCP03", StringComparison.OrdinalIgnoreCase):
                return Model.FRANBMCP03;
            case var _ when name.Equals("FRANBMCP06", StringComparison.OrdinalIgnoreCase):
                return Model.FRANBMCP06;
            case var _ when name.Equals("FRANBMCP08", StringComparison.OrdinalIgnoreCase):
                return Model.FRANBMCP08;
            case var _ when name.Equals("FRANBMCP0A", StringComparison.OrdinalIgnoreCase):
                return Model.FRANBMCP0A;
            case var _ when name.Equals("FRANBMCP0B", StringComparison.OrdinalIgnoreCase):
                return Model.FRANBMCP0B;
            case var _ when name.Equals("FRANBMCP0C", StringComparison.OrdinalIgnoreCase):
                return Model.FRANBMCP0C;
            case var _ when name.Equals("FRANGACP04", StringComparison.OrdinalIgnoreCase):
                return Model.FRANGACP04;
            case var _ when name.Equals("FRANGACP06", StringComparison.OrdinalIgnoreCase):
                return Model.FRANGACP06;
            case var _ when name.Equals("FRANGACP08", StringComparison.OrdinalIgnoreCase):
                return Model.FRANGACP08;
            case var _ when name.Equals("FRANMACP04", StringComparison.OrdinalIgnoreCase):
                return Model.FRANMACP04;
            case var _ when name.Equals("FRANMACP06", StringComparison.OrdinalIgnoreCase):
                return Model.FRANMACP06;
            case var _ when name.Equals("FRANMACP08", StringComparison.OrdinalIgnoreCase):
                return Model.FRANMACP08;
            case var _ when name.Equals("FRANMCCP04", StringComparison.OrdinalIgnoreCase):
                return Model.FRANMCCP04;
            case var _ when name.Equals("FRANMCCP06", StringComparison.OrdinalIgnoreCase):
                return Model.FRANMCCP06;
            case var _ when name.Equals("FRANMCCP07", StringComparison.OrdinalIgnoreCase):
                return Model.FRANMCCP07;
            case var _ when name.Equals("FRANMDCP05", StringComparison.OrdinalIgnoreCase):
                return Model.FRANMDCP05;
            case var _ when name.Equals("FRANMDCP07", StringComparison.OrdinalIgnoreCase):
                return Model.FRANMDCP07;
            case var _ when name.Equals("FRANMECP02", StringComparison.OrdinalIgnoreCase):
                return Model.FRANMECP02;
            case var _ when name.Equals("FRANMECP05", StringComparison.OrdinalIgnoreCase):
                return Model.FRANMECP05;
            case var _ when name.Equals("FRANMECP06", StringComparison.OrdinalIgnoreCase):
                return Model.FRANMECP06;
            case var _ when name.Equals("FRANMZCP07", StringComparison.OrdinalIgnoreCase):
                return Model.FRANMZCP07;
            case var _ when name.Equals("FRANMZCP09", StringComparison.OrdinalIgnoreCase):
                return Model.FRANMZCP09;
            case var _ when name.Equals("FRANMFCP02", StringComparison.OrdinalIgnoreCase):
                return Model.FRANMFCP02;
            case var _ when name.Equals("FRANMFCP06", StringComparison.OrdinalIgnoreCase):
                return Model.FRANMFCP06;
            case var _ when name.Equals("FRAPMACP03", StringComparison.OrdinalIgnoreCase):
                return Model.FRAPMACP03;
            case var _ when name.Equals("FRAPMACP05", StringComparison.OrdinalIgnoreCase):
                return Model.FRAPMACP05;
            case var _ when name.Equals("FRANMGCP05", StringComparison.OrdinalIgnoreCase):
                return Model.FRANMGCP05;
            case var _ when name.Equals("FRANMGCP07", StringComparison.OrdinalIgnoreCase):
                return Model.FRANMGCP07;
            case var _ when name.Equals("FRANMGCP09", StringComparison.OrdinalIgnoreCase):
                return Model.FRANMGCP09;
            case var _ when name.Equals("Base Board Product Name", StringComparison.OrdinalIgnoreCase):
            case var _ when name.Equals("To be filled by O.E.M.", StringComparison.OrdinalIgnoreCase):
                return Model.Unknown;
            default:
                return Model.Unknown;
        }
    }
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/Chip.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Diagnostics.CodeAnalysis;

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc;

[SuppressMessage("ReSharper", "InconsistentNaming")]
internal enum Chip : ushort
{
    Unknown = 0,

    ATK0110 = 0x0110,

    F71808E = 0x0901,
    F71811 = 0x1007,
    F71858 = 0x0507,
    F71862 = 0x0601,
    F71869 = 0x0814,
    F71869A = 0x1007,
    F71878AD = 0x1106,
    F71882 = 0x0541,
    F71889AD = 0x1005,
    F71889ED = 0x0909,
    F71889F = 0x0723,

    IT8613E = 0x8613,
    IT8620E = 0x8620,
    IT8625E = 0x8625,
    IT8628E = 0x8628,
    IT8631E = 0x8631,
    IT8638E = 0x8638,
    IT8655E = 0x8655,
    IT8665E = 0x8665,
    IT8686E = 0x8686,
    IT8688E = 0x8688,
    IT8689E = 0x8689,
    IT8696E = 0x8696,
    IT8705F = 0x8705,
    IT8712F = 0x8712,
    IT8716F = 0x8716,
    IT8718F = 0x8718,
    IT8720F = 0x8720,
    IT8721F = 0x8721,
    IT8726F = 0x8726,
    IT8728F = 0x8728,
    IT8771E = 0x8771,
    IT8772E = 0x8772,
    IT8790E = 0x8790,
    IT8792E = 0x8733, // Could also be IT8791E, IT8795E
    IT87952E = 0x8695,

    NCT5585D = 0xFFF0, // Chip reports 0xD42A but that's in use
    NCT610XD = 0xC452,
    NCT6771F = 0xB470,
    NCT6776F = 0xC330,
    NCT6779D = 0xC560,
    NCT6791D = 0xC803,
    NCT6792D = 0xC911,
    NCT6792DA = 0xC913,
    NCT6793D = 0xD121,
    NCT6795D = 0xD352,
    NCT6796D = 0xD423,
    NCT6796DR = 0xD42A,
    NCT6796DS = 0xFFF1, // Chip reports 0xD802 but that's in use
    NCT6797D = 0xD451,
    NCT6798D = 0xD42B,
    NCT6686D = 0xD440,
    NCT6687D = 0xD592,
    NCT6687DR = 0xFFFF, // Dummy Entry for MSI AM5/LGA1851 Motherboards
    NCT6683D = 0xC732,
    NCT6799D = 0xD802,
    NCT6701D = 0xD806,

    W83627DHG = 0xA020,
    W83627DHGP = 0xB070,
    W83627EHF = 0x8800,
    W83627HF = 0x5200,
    W83627THF = 0x8280,
    W83667HG = 0xA510,
    W83667HGB = 0xB350,
    W83687THF = 0x8541,

    IPMI = 0x4764,
}

internal class ChipName
{
    public static string GetName(Chip chip)
    {
        switch (chip)
        {
            case Chip.ATK0110: return "Asus ATK0110";

            case Chip.F71858: return "Fintek F71858";
            case Chip.F71862: return "Fintek F71862";
            case Chip.F71869: return "Fintek F71869";
            case Chip.F71878AD: return "Fintek F71878AD";
            case Chip.F71869A: return "Fintek F71869A/F71811";
            case Chip.F71882: return "Fintek F71882";
            case Chip.F71889AD: return "Fintek F71889AD";
            case Chip.F71889ED: return "Fintek F71889ED";
            case Chip.F71889F: return "Fintek F71889F";
            case Chip.F71808E: return "Fintek F71808E";
            case Chip.IT8613E: return "ITE IT8613E";
            case Chip.IT8620E: return "ITE IT8620E";
            case Chip.IT8625E: return "ITE IT8625E";
            case Chip.IT8628E: return "ITE IT8628E";
            case Chip.IT8631E: return "ITE IT8631E";
            case Chip.IT8638E: return "ITE IT8638E";
            case Chip.IT8655E: return "ITE IT8655E";
            case Chip.IT8665E: return "ITE IT8665E";
            case Chip.IT8686E: return "ITE IT8686E";
            case Chip.IT8688E: return "ITE IT8688E";
            case Chip.IT8689E: return "ITE IT8689E";
            case Chip.IT8696E: return "ITE IT8696E";
            case Chip.IT8705F: return "ITE IT8705F";
            case Chip.IT8712F: return "ITE IT8712F";
            case Chip.IT8716F: return "ITE IT8716F";
            case Chip.IT8718F: return "ITE IT8718F";
            case Chip.IT8720F: return "ITE IT8720F";
            case Chip.IT8721F: return "ITE IT8721F";
            case Chip.IT8726F: return "ITE IT8726F";
            case Chip.IT8728F: return "ITE IT8728F";
            case Chip.IT8771E: return "ITE IT8771E";
            case Chip.IT8772E: return "ITE IT8772E";
            case Chip.IT8790E: return "ITE IT8790E";
            case Chip.IT8792E: return "ITE IT8791E/IT8792E/IT8795E";
            case Chip.IT87952E: return "ITE IT87952E";

            case Chip.NCT5585D: return "Nuvoton NCT5585D";
            case Chip.NCT610XD: return "Nuvoton NCT6102D/NCT6104D/NCT6106D";
            case Chip.NCT6771F: return "Nuvoton NCT6771F";
            case Chip.NCT6776F: return "Nuvoton NCT6776F";
            case Chip.NCT6779D: return "Nuvoton NCT6779D";
            case Chip.NCT6791D: return "Nuvoton NCT6791D";
            case Chip.NCT6792D: return "Nuvoton NCT6792D";
            case Chip.NCT6792DA: return "Nuvoton NCT6792D-A";
            case Chip.NCT6793D: return "Nuvoton NCT6793D";
            case Chip.NCT6795D: return "Nuvoton NCT6795D";
            case Chip.NCT6796D: return "Nuvoton NCT6796D";
            case Chip.NCT6796DR: return "Nuvoton NCT6796D-R";
            case Chip.NCT6796DS: return "Nuvoton NCT6796D-S";
            case Chip.NCT6797D: return "Nuvoton NCT6797D";
            case Chip.NCT6798D: return "Nuvoton NCT6798D";
            case Chip.NCT6799D: return "Nuvoton NCT6799D";
            case Chip.NCT6686D: return "Nuvoton NCT6686D";
            case Chip.NCT6687D: return "Nuvoton NCT6687D";
            case Chip.NCT6687DR: return "Nuvoton NCT6687D-R";
            case Chip.NCT6683D: return "Nuvoton NCT6683D";
            case Chip.NCT6701D: return "Nuvoton NCT6701D";

            case Chip.W83627DHG: return "Winbond W83627DHG";
            case Chip.W83627DHGP: return "Winbond W83627DHG-P";
            case Chip.W83627EHF: return "Winbond W83627EHF";
            case Chip.W83627HF: return "Winbond W83627HF";
            case Chip.W83627THF: return "Winbond W83627THF";
            case Chip.W83667HG: return "Winbond W83667HG";
            case Chip.W83667HGB: return "Winbond W83667HG-B";
            case Chip.W83687THF: return "Winbond W83687THF";

            case Chip.IPMI: return "IPMI";

            default: return "Unknown";
        }
    }
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/EC/ChromeOSEmbeddedController.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System.Collections.Generic;

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc.EC;

public class ChromeOSEmbeddedController : EmbeddedController
{
    private const byte EC_FAN_SPEED_ENTRIES = 4;
    private const ushort EC_FAN_SPEED_NOT_PRESENT = 0xffff;
    private const byte EC_MEMMAP_FAN = 0x10;
    private const byte EC_MEMMAP_TEMP_SENSOR = 0x00;
    private const byte EC_MEMMAP_TEMP_SENSOR_B = 0x18;
    private const byte EC_TEMP_SENSOR_B_ENTRIES = 8;
    private const byte EC_TEMP_SENSOR_ENTRIES = 16;
    private const byte EC_TEMP_SENSOR_NOT_PRESENT = 0xff;

    /*
     * The offset of temperature value stored in mapped memory.  This allows
     * reporting a temperature range of 200K to 454K = -73C to 181C.
     */
    private const byte EC_TEMP_SENSOR_OFFSET = 200;

    public ChromeOSEmbeddedController(IEnumerable<EmbeddedControllerSource> sources, ISettings settings) : base(sources, settings)
    { }

    public static ChromeOSEmbeddedController Create(ISettings settings)
    {
        List<EmbeddedControllerSource> sources = [];

        using ChromeOSEmbeddedControllerIO embeddedControllerIO = new();

        // Copy the first 0x20 bytes of the EC memory map
        byte[] data = embeddedControllerIO.ReadMemmap(0x00, 0x20);

        for (int i = 0; i < EC_TEMP_SENSOR_ENTRIES; i++)
        {
            byte temp = data[EC_MEMMAP_TEMP_SENSOR + i];
            if (temp == EC_TEMP_SENSOR_NOT_PRESENT)
            {
                break;
            }

            string sensorName = embeddedControllerIO.TempSensorGetName((byte)i);

            sources.Add(new EmbeddedControllerSource(sensorName,
                                                     SensorType.Temperature,
                                                     (ushort)(EC_MEMMAP_TEMP_SENSOR + i),
                                                     offset: EC_TEMP_SENSOR_OFFSET - 273,
                                                     blank: EC_TEMP_SENSOR_NOT_PRESENT));
        }

        for (int i = 0; i < EC_FAN_SPEED_ENTRIES; i++)
        {
            ushort fan = (ushort)(data[EC_MEMMAP_FAN + i * 2] | (data[EC_MEMMAP_FAN + i * 2 + 1] << 8));
            if (fan == EC_FAN_SPEED_NOT_PRESENT)
            {
                break;
            }

            sources.Add(new EmbeddedControllerSource("Fan " + (i + 1),
                                                     SensorType.Fan,
                                                     (ushort)(EC_MEMMAP_FAN + i * 2),
                                                     2,
                                                     blank: EC_FAN_SPEED_NOT_PRESENT,
                                                     isLittleEndian: true));
        }

        for (int i = 0; i < EC_TEMP_SENSOR_B_ENTRIES; i++)
        {
            byte temp = data[EC_MEMMAP_TEMP_SENSOR_B + i];
            if (temp == EC_TEMP_SENSOR_NOT_PRESENT)
            {
                break;
            }

            string sensorName = embeddedControllerIO.TempSensorGetName((byte)(i + EC_TEMP_SENSOR_ENTRIES));

            sources.Add(new EmbeddedControllerSource(sensorName,
                                                     SensorType.Temperature,
                                                     (ushort)(EC_MEMMAP_TEMP_SENSOR_B + i),
                                                     offset: EC_TEMP_SENSOR_OFFSET - 273,
                                                     blank: EC_TEMP_SENSOR_NOT_PRESENT));
        }

        return new ChromeOSEmbeddedController(sources, settings);
    }

    protected override IEmbeddedControllerIO AcquireIOInterface()
    {
        return new ChromeOSEmbeddedControllerIO();
    }
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/EC/ChromeOSEmbeddedControllerIO.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System.Diagnostics;
using System.Text;
using LibreHardwareMonitor.PawnIo;

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc.EC;

public class ChromeOSEmbeddedControllerIO : IEmbeddedControllerIO
{
    private const short EC_CMD_TEMP_SENSOR_GET_INFO = 0x0070;

    private readonly LpcCrOSEc _pawnModule;
    private bool _disposed;

    public ChromeOSEmbeddedControllerIO()
    {
        _pawnModule = new LpcCrOSEc();

        if (!Mutexes.WaitEc(10))
        {
            throw new BusMutexLockingFailedException();
        }
    }

    public void Read(ushort[] registers, byte[] data)
    {
        Trace.Assert(registers.Length <= data.Length,
                     "data buffer length has to be greater or equal to the registers array length");

        for (int i = 0; i < registers.Length; i++)
        {
            data[i] = ReadMemmap((byte)registers[i], 1)[0];
        }
    }

    public byte[] ReadMemmap(byte offset, byte bytes)
    {
        return _pawnModule.ReadMemmap(offset, bytes);
    }

    public string TempSensorGetName(byte index)
    {
        try
        {
            byte[] resp = _pawnModule.EcCommand(0, EC_CMD_TEMP_SENSOR_GET_INFO, 1, 33, [index]);
            //byte sensorType = resp[33];
            return Encoding.ASCII.GetString(resp, 0, 32).TrimEnd('\0');
        }
        catch (System.Exception)
        {
            return "Temp " + index;
        }
    }

    public void Dispose()
    {
        if (!_disposed)
        {
            _disposed = true;
            Mutexes.ReleaseEc();
        }
    }

    public class BusMutexLockingFailedException : EmbeddedController.IOException
    {
        public BusMutexLockingFailedException()
            : base("could not lock ISA bus mutex")
        { }
    }
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/EC/EmbeddedController.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc.EC;

public abstract class EmbeddedController : Hardware
{
    // If you are updating board information, please consider sharing your changes with the corresponding Linux driver.
    // You can do that at https://github.com/zeule/asus-ec-sensors or contribute directly to Linux HWMON.
    // If you are adding a new board, please share DSDT table for the board at https://github.com/zeule/asus-ec-sensors.
    // https://dortania.github.io/Getting-Started-With-ACPI/Manual/dump.html
    private static readonly BoardInfo[] _boards =
    {
        new (Model.TUF_GAMING_X870_PLUS_WIFI,
            BoardFamily.Amd800,
            ECSensor.TempVrm,
            ECSensor.FanCPUOpt),
        new(Model.PRIME_X470_PRO,
            BoardFamily.Amd400,
            ECSensor.TempChipset,
            ECSensor.TempCPU,
            ECSensor.TempMB,
            ECSensor.TempVrm,
            ECSensor.TempVrm,
            ECSensor.FanCPUOpt,
            ECSensor.CurrCPU,
            ECSensor.VoltageCPU),
        new(Model.PRIME_X570_PRO,
            BoardFamily.Amd500,
            ECSensor.TempChipset,
            ECSensor.TempCPU,
            ECSensor.TempMB,
            ECSensor.TempVrm,
            ECSensor.TempTSensor,
            ECSensor.FanChipset),
        new(Model.PROART_X570_CREATOR_WIFI,
            BoardFamily.Amd500,
            ECSensor.TempChipset,
            ECSensor.TempCPU,
            ECSensor.TempMB,
            ECSensor.TempVrm,
            ECSensor.TempTSensor,
            ECSensor.FanCPUOpt,
            ECSensor.CurrCPU,
            ECSensor.VoltageCPU),
        new(Model.PRO_WS_X570_ACE,
            BoardFamily.Amd500,
            ECSensor.TempChipset,
            ECSensor.TempCPU,
            ECSensor.TempMB,
            ECSensor.TempVrm,
            ECSensor.FanChipset,
            ECSensor.CurrCPU,
            ECSensor.VoltageCPU),
        new(new[] { Model.ROG_CROSSHAIR_VIII_HERO, Model.ROG_CROSSHAIR_VIII_HERO_WIFI, Model.ROG_CROSSHAIR_VIII_FORMULA },
            BoardFamily.Amd500,
            ECSensor.TempChipset,
            ECSensor.TempCPU,
            ECSensor.TempMB,
            ECSensor.TempTSensor,
            ECSensor.TempVrm,
            ECSensor.TempWaterIn,
            ECSensor.TempWaterOut,
            ECSensor.FanCPUOpt,
            ECSensor.FanChipset,
            ECSensor.FanWaterFlow,
            ECSensor.CurrCPU,
            ECSensor.VoltageCPU),
        new(Model.ROG_CROSSHAIR_X670E_EXTREME,
            BoardFamily.Amd600,
            ECSensor.TempWaterIn,
            ECSensor.TempWaterOut,
            ECSensor.FanCPUOpt),
        new(Model.ROG_CROSSHAIR_X670E_HERO,
            BoardFamily.Amd600,
            ECSensor.TempWaterIn,
            ECSensor.TempWaterOut,
            ECSensor.FanCPUOpt),
        new(Model.ROG_CROSSHAIR_X670E_GENE,
            BoardFamily.Amd600,
            ECSensor.TempWaterIn,
            ECSensor.TempWaterOut,
            ECSensor.FanCPUOpt),
        new(Model.ROG_STRIX_X670E_E_GAMING_WIFI,
            BoardFamily.Amd600,
            ECSensor.TempWaterIn,
            ECSensor.TempWaterOut,
            ECSensor.FanCPUOpt),
        new(Model.ROG_STRIX_X670E_F_GAMING_WIFI,
            BoardFamily.Amd600,
            ECSensor.TempWaterIn,
            ECSensor.TempWaterOut,
            ECSensor.FanCPUOpt),
        new(Model.ROG_CROSSHAIR_VIII_DARK_HERO,
            BoardFamily.Amd500,
            ECSensor.TempChipset,
            ECSensor.TempCPU,
            ECSensor.TempMB,
            ECSensor.TempTSensor,
            ECSensor.TempVrm,
            ECSensor.TempWaterIn,
            ECSensor.TempWaterOut,
            ECSensor.FanCPUOpt,
            ECSensor.FanWaterFlow,
            ECSensor.CurrCPU,
            ECSensor.VoltageCPU),
        new(Model.ROG_CROSSHAIR_VIII_IMPACT,
            BoardFamily.Amd500,
            ECSensor.TempChipset,
            ECSensor.TempCPU,
            ECSensor.TempMB,
            ECSensor.TempTSensor,
            ECSensor.TempVrm,
            ECSensor.FanChipset,
            ECSensor.CurrCPU,
            ECSensor.VoltageCPU),
        new(Model.ROG_STRIX_B550_E_GAMING,
            BoardFamily.Amd500,
            ECSensor.TempChipset,
            ECSensor.TempCPU,
            ECSensor.TempMB,
            ECSensor.TempTSensor,
            ECSensor.TempVrm,
            ECSensor.FanCPUOpt),
        new(Model.ROG_STRIX_B550_I_GAMING,
            BoardFamily.Amd500,
            ECSensor.TempChipset,
            ECSensor.TempCPU,
            ECSensor.TempMB,
            ECSensor.TempTSensor,
            ECSensor.TempVrm,
            ECSensor.FanVrmHS,
            ECSensor.CurrCPU,
            ECSensor.VoltageCPU),
        new(Model.ROG_STRIX_X570_E_GAMING,
            BoardFamily.Amd500,
            ECSensor.TempChipset,
            ECSensor.TempCPU,
            ECSensor.TempMB,
            ECSensor.TempTSensor,
            ECSensor.TempVrm,
            ECSensor.FanChipset,
            ECSensor.CurrCPU,
            ECSensor.VoltageCPU),
        new(Model.ROG_STRIX_X570_E_GAMING_WIFI_II,
            BoardFamily.Amd500,
            ECSensor.TempChipset,
            ECSensor.TempCPU,
            ECSensor.TempMB,
            ECSensor.TempTSensor,
            ECSensor.TempVrm),
        new(Model.ROG_STRIX_X570_F_GAMING,
            BoardFamily.Amd500,
            ECSensor.TempChipset,
            ECSensor.TempCPU,
            ECSensor.TempMB,
            ECSensor.TempTSensor,
            ECSensor.FanChipset),
        new(Model.ROG_STRIX_X570_I_GAMING,
            BoardFamily.Amd500,
            ECSensor.TempTSensor,
            ECSensor.FanVrmHS,
            ECSensor.FanChipset,
            ECSensor.CurrCPU,
            ECSensor.VoltageCPU,
            ECSensor.TempChipset,
            ECSensor.TempVrm),
        new(Model.ROG_STRIX_Z390_E_GAMING,
            BoardFamily.Intel300,
            ECSensor.TempVrm,
            ECSensor.TempChipset,
            ECSensor.TempTSensor,
            ECSensor.FanCPUOpt),
        new(Model.ROG_STRIX_Z390_F_GAMING,
            BoardFamily.Intel300,
            ECSensor.TempVrm,
            ECSensor.TempChipset,
            ECSensor.TempTSensor,
            ECSensor.FanCPUOpt),
        new(Model.ROG_STRIX_Z390_I_GAMING,
            BoardFamily.Intel300,
            ECSensor.TempVrm,
            ECSensor.TempChipset,
            ECSensor.TempTSensor),
        new(Model.ROG_MAXIMUS_XI_FORMULA,
            BoardFamily.Intel300,
            ECSensor.TempVrm,
            ECSensor.TempChipset,
            ECSensor.TempWaterIn,
            ECSensor.TempWaterOut,
            ECSensor.TempTSensor,
            ECSensor.FanCPUOpt),
        new(Model.ROG_MAXIMUS_XII_Z490_FORMULA,
            BoardFamily.Intel400,
            ECSensor.TempTSensor,
            ECSensor.TempVrm,
            ECSensor.TempWaterIn,
            ECSensor.TempWaterOut,
            ECSensor.FanWaterFlow),
        new(Model.ROG_STRIX_Z690_A_GAMING_WIFI_D4,
            BoardFamily.Intel600,
            ECSensor.TempTSensor,
            ECSensor.TempVrm),
        new(Model.ROG_STRIX_Z690_G_GAMING_WIFI,
            BoardFamily.Intel600,
            ECSensor.TempTSensor,
            ECSensor.TempVrm),
        new(Model.ROG_MAXIMUS_Z690_HERO,
            BoardFamily.Intel600,
            ECSensor.TempTSensor,
            ECSensor.TempWaterIn,
            ECSensor.TempWaterOut,
            ECSensor.FanWaterFlow),
        new(Model.ROG_MAXIMUS_Z690_FORMULA,
            BoardFamily.Intel600,
            ECSensor.TempTSensor,
            ECSensor.TempVrm,
            ECSensor.TempWaterIn,
            ECSensor.TempWaterOut,
            ECSensor.TempWaterBlockIn,
            ECSensor.FanWaterFlow),
        new(Model.ROG_MAXIMUS_Z690_EXTREME_GLACIAL,
            BoardFamily.Intel600,
            ECSensor.TempVrm,
            ECSensor.TempWaterIn,
            ECSensor.TempWaterOut,
            ECSensor.TempWaterBlockIn,
            ECSensor.FanWaterFlow),
        new(Model.ROG_MAXIMUS_Z790_HERO,
            BoardFamily.Intel700,
            ECSensor.TempVrm,
            ECSensor.TempTSensor,
            ECSensor.TempWaterIn,
            ECSensor.TempWaterOut,
            ECSensor.FanWaterFlow,
            ECSensor.FanCPUOpt),
        new(Model.ROG_MAXIMUS_Z790_DARK_HERO,
            BoardFamily.Intel700,
            ECSensor.TempVrm,
            ECSensor.FanCPUOpt,
            ECSensor.TempTSensor,
            ECSensor.TempWaterIn,
            ECSensor.TempWaterOut,
            ECSensor.FanWaterFlow),
        new(Model.Z170_A,
            BoardFamily.Intel100,
            ECSensor.TempTSensor,
            ECSensor.TempChipset,
            ECSensor.FanWaterPump,
            ECSensor.CurrCPU,
            ECSensor.VoltageCPU),
        new(Model.Z170_PRO_GAMING,
            BoardFamily.Intel100,
            ECSensor.TempChipset,
            ECSensor.TempVrm,
            ECSensor.TempTSensor),
        new(Model.PRIME_Z690_A,
            BoardFamily.Intel600,
            ECSensor.TempTSensor,
            ECSensor.TempVrm),
        new(Model.ROG_STRIX_Z790_I_GAMING_WIFI,
            BoardFamily.Intel700,
            ECSensor.TempTSensor,
            ECSensor.TempTSensor2),
        new(Model.ROG_STRIX_Z790_E_GAMING_WIFI,
            BoardFamily.Intel700,
            ECSensor.TempWaterIn),
        new(Model.ROG_STRIX_Z790_E_GAMING_WIFI_II,
            BoardFamily.Intel700,
            ECSensor.TempTSensor,
            ECSensor.TempVrm,
            ECSensor.FanCPUOpt),
        new(Model.ROG_MAXIMUS_Z790_FORMULA,
            BoardFamily.Intel700,
            ECSensor.TempWaterIn,
            ECSensor.TempWaterOut),
        new(Model.ROG_MAXIMUS_XII_HERO_WIFI,
            BoardFamily.Intel400,
            ECSensor.TempTSensor,
            ECSensor.TempChipset,
            ECSensor.TempVrm,
            ECSensor.TempWaterIn,
            ECSensor.TempWaterOut,
            ECSensor.CurrCPU,
            ECSensor.FanCPUOpt,
            ECSensor.FanWaterFlow),
        new(Model.ROG_STRIX_X870_I_GAMING_WIFI,
            BoardFamily.Amd800,
            ECSensor.TempCPU,
            ECSensor.TempCPUPackage,
            ECSensor.TempMB,
            ECSensor.TempVrm),
        new(Model.FRANMDCP05,
            BoardFamily.CrOS,
            null),
        new(Model.FRANMDCP07,
            BoardFamily.CrOS,
            null),
        new(Model.FRANMECP02,
            BoardFamily.CrOS,
            null),
        new(Model.FRANMECP05,
            BoardFamily.CrOS,
            null),
        new(Model.FRANMECP06,
            BoardFamily.CrOS,
            null),
        new(Model.FRANMZCP07,
            BoardFamily.CrOS,
            null),
        new(Model.FRANMZCP09,
            BoardFamily.CrOS,
            null),
        new(Model.FRANMFCP02,
            BoardFamily.CrOS,
            null),
        new(Model.FRANMFCP06,
            BoardFamily.CrOS,
            null),
        new(Model.FRAPMACP03,
            BoardFamily.CrOS,
            null),
        new(Model.FRAPMACP05,
            BoardFamily.CrOS,
            null),
        new(Model.FRANMGCP05,
            BoardFamily.CrOS,
            null),
        new(Model.FRANMGCP07,
            BoardFamily.CrOS,
            null),
        new(Model.FRANMGCP09,
            BoardFamily.CrOS,
            null)
    };

    private static readonly Dictionary<BoardFamily, Dictionary<ECSensor, EmbeddedControllerSource>> _knownSensors = new()
    {
        {
            BoardFamily.Amd400, new Dictionary<ECSensor, EmbeddedControllerSource>() // no chipset fans in this generation
            {
                { ECSensor.TempChipset, new EmbeddedControllerSource("Chipset", SensorType.Temperature, 0x003a) },
                { ECSensor.TempCPU, new EmbeddedControllerSource("CPU", SensorType.Temperature, 0x003b) },
                { ECSensor.TempMB, new EmbeddedControllerSource("Motherboard", SensorType.Temperature, 0x003c) },
                { ECSensor.TempTSensor, new EmbeddedControllerSource("T Sensor", SensorType.Temperature, 0x003d, blank: -40) },
                { ECSensor.TempVrm, new EmbeddedControllerSource("VRM", SensorType.Temperature, 0x003e) },
                { ECSensor.VoltageCPU, new EmbeddedControllerSource("CPU Core", SensorType.Voltage, 0x00a2, 2, factor: 1e-3f) },
                { ECSensor.FanCPUOpt, new EmbeddedControllerSource("CPU Optional Fan", SensorType.Fan, 0x00bc, 2) },
                { ECSensor.FanVrmHS, new EmbeddedControllerSource("VRM Heat Sink Fan", SensorType.Fan, 0x00b2, 2) },
                { ECSensor.FanWaterFlow, new EmbeddedControllerSource("Water flow", SensorType.Flow, 0x00b4, 2, factor: 1.0f / 42f * 60f) },
                { ECSensor.CurrCPU, new EmbeddedControllerSource("CPU", SensorType.Current, 0x00f4) },
                { ECSensor.TempWaterIn, new EmbeddedControllerSource("Water In", SensorType.Temperature, 0x010d, blank: -40) },
                { ECSensor.TempWaterOut, new EmbeddedControllerSource("Water Out", SensorType.Temperature, 0x010b, blank: -40) }
            }
        },
        {
            BoardFamily.Amd500, new Dictionary<ECSensor, EmbeddedControllerSource>
            {
                { ECSensor.TempChipset, new EmbeddedControllerSource("Chipset", SensorType.Temperature, 0x003a) },
                { ECSensor.TempCPU, new EmbeddedControllerSource("CPU", SensorType.Temperature, 0x003b) },
                { ECSensor.TempMB, new EmbeddedControllerSource("Motherboard", SensorType.Temperature, 0x003c) },
                { ECSensor.TempTSensor, new EmbeddedControllerSource("T Sensor", SensorType.Temperature, 0x003d, blank: -40) },
                { ECSensor.TempVrm, new EmbeddedControllerSource("VRM", SensorType.Temperature, 0x003e) },
                { ECSensor.VoltageCPU, new EmbeddedControllerSource("CPU Core", SensorType.Voltage, 0x00a2, 2, factor: 1e-3f) },
                { ECSensor.FanCPUOpt, new EmbeddedControllerSource("CPU Optional Fan", SensorType.Fan, 0x00b0, 2) },
                { ECSensor.FanVrmHS, new EmbeddedControllerSource("VRM Heat Sink Fan", SensorType.Fan, 0x00b2, 2) },
                { ECSensor.FanChipset, new EmbeddedControllerSource("Chipset Fan", SensorType.Fan, 0x00b4, 2) },
                // TODO: "why 42?" is a silly question, I know, but still, why? On the serious side, it might be 41.6(6)
                { ECSensor.FanWaterFlow, new EmbeddedControllerSource("Water flow", SensorType.Flow, 0x00bc, 2, factor: 1.0f / 42f * 60f) },
                { ECSensor.CurrCPU, new EmbeddedControllerSource("CPU", SensorType.Current, 0x00f4) },
                { ECSensor.TempWaterIn, new EmbeddedControllerSource("Water In", SensorType.Temperature, 0x0100, blank: -40) },
                { ECSensor.TempWaterOut, new EmbeddedControllerSource("Water Out", SensorType.Temperature, 0x0101, blank: -40) }
            }
        },
        {
            BoardFamily.Amd600, new Dictionary<ECSensor, EmbeddedControllerSource>
            {
                { ECSensor.FanCPUOpt, new EmbeddedControllerSource("CPU Optional Fan", SensorType.Fan, 0x00b0, 2) },
                { ECSensor.TempWaterIn, new EmbeddedControllerSource("Water In", SensorType.Temperature, 0x0100, blank: -40) },
                { ECSensor.TempWaterOut, new EmbeddedControllerSource("Water Out", SensorType.Temperature, 0x0101, blank: -40) }
            }
        },
        {
            BoardFamily.Amd800, new Dictionary<ECSensor, EmbeddedControllerSource>
            {
                { ECSensor.TempCPU, new EmbeddedControllerSource("CPU", SensorType.Temperature, 0x0030) },
                { ECSensor.TempCPUPackage, new EmbeddedControllerSource("CPU Package", SensorType.Temperature, 0x0031) },
                { ECSensor.TempMB, new EmbeddedControllerSource("Motherboard", SensorType.Temperature, 0x0032) },
                { ECSensor.TempVrm, new EmbeddedControllerSource("VRM", SensorType.Temperature, 0x0033) },
                { ECSensor.TempTSensor, new EmbeddedControllerSource("T Sensor", SensorType.Temperature, 0x0036, blank: -40) },
                { ECSensor.FanCPUOpt, new EmbeddedControllerSource("CPU Optional Fan", SensorType.Fan, 0x00b0, 2) }
            }
        },
        {
            BoardFamily.Intel100, new Dictionary<ECSensor, EmbeddedControllerSource>
            {
                { ECSensor.TempChipset, new EmbeddedControllerSource("Chipset", SensorType.Temperature, 0x003a) },
                { ECSensor.TempVrm, new EmbeddedControllerSource("VRM", SensorType.Temperature, 0x003e) },
                { ECSensor.TempTSensor, new EmbeddedControllerSource("T Sensor", SensorType.Temperature, 0x003d, blank: -40) },
                { ECSensor.FanWaterPump, new EmbeddedControllerSource("Water Pump", SensorType.Fan, 0x00bc, 2) },
                { ECSensor.CurrCPU, new EmbeddedControllerSource("CPU", SensorType.Current, 0x00f4) },
                { ECSensor.VoltageCPU, new EmbeddedControllerSource("CPU Core", SensorType.Voltage, 0x00a2, 2, factor: 1e-3f) }
            }
        },
        {
            BoardFamily.Intel300, new Dictionary<ECSensor, EmbeddedControllerSource>
            {
                { ECSensor.TempVrm, new EmbeddedControllerSource("VRM", SensorType.Temperature, 0x003e) },
                { ECSensor.TempChipset, new EmbeddedControllerSource("Chipset", SensorType.Temperature, 0x003a) },
                { ECSensor.TempTSensor, new EmbeddedControllerSource("T Sensor", SensorType.Temperature, 0x003d, blank: -40) },
                { ECSensor.TempWaterIn, new EmbeddedControllerSource("Water In", SensorType.Temperature, 0x0100, blank: -40) },
                { ECSensor.TempWaterOut, new EmbeddedControllerSource("Water Out", SensorType.Temperature, 0x0101, blank: -40) },
                { ECSensor.FanCPUOpt, new EmbeddedControllerSource("CPU Optional Fan", SensorType.Fan, 0x00b0, 2) }
            }
        },
        {
            BoardFamily.Intel400, new Dictionary<ECSensor, EmbeddedControllerSource>
            {
                { ECSensor.TempChipset, new EmbeddedControllerSource("Chipset", SensorType.Temperature, 0x003a) },
                { ECSensor.TempTSensor, new EmbeddedControllerSource("T Sensor", SensorType.Temperature, 0x003d, blank: -40) },
                { ECSensor.TempVrm, new EmbeddedControllerSource("VRM", SensorType.Temperature, 0x003e) },
                { ECSensor.FanCPUOpt, new EmbeddedControllerSource("CPU Optional Fan", SensorType.Fan, 0x00b0, 2) },
                { ECSensor.FanWaterFlow, new EmbeddedControllerSource("Water Flow", SensorType.Flow, 0x00be, 2, factor: 1.0f / 42f * 60f) }, // todo: need validation for this calculation
                { ECSensor.CurrCPU, new EmbeddedControllerSource("CPU", SensorType.Current, 0x00f4) },
                { ECSensor.TempWaterIn, new EmbeddedControllerSource("Water In", SensorType.Temperature, 0x0100, blank: -40) },
                { ECSensor.TempWaterOut, new EmbeddedControllerSource("Water Out", SensorType.Temperature, 0x0101, blank: -40) },
            }
        },
        {
            BoardFamily.Intel600, new Dictionary<ECSensor, EmbeddedControllerSource>
            {
                { ECSensor.TempTSensor, new EmbeddedControllerSource("T Sensor", SensorType.Temperature, 0x003d, blank: -40) },
                { ECSensor.TempVrm, new EmbeddedControllerSource("VRM", SensorType.Temperature, 0x003e) },
                { ECSensor.TempWaterIn, new EmbeddedControllerSource("Water In", SensorType.Temperature, 0x0100, blank: -40) },
                { ECSensor.TempWaterOut, new EmbeddedControllerSource("Water Out", SensorType.Temperature, 0x0101, blank: -40) },
                { ECSensor.TempWaterBlockIn, new EmbeddedControllerSource("Water Block In", SensorType.Temperature, 0x0102, blank: -40) },
                { ECSensor.FanWaterFlow, new EmbeddedControllerSource("Water Flow", SensorType.Flow, 0x00be, 2, factor: 1.0f / 42f * 60f) } // todo: need validation for this calculation
            }
        },
        {
            BoardFamily.Intel700, new Dictionary<ECSensor, EmbeddedControllerSource>
            {
                { ECSensor.TempVrm, new EmbeddedControllerSource("VRM", SensorType.Temperature, 0x0033) },
                { ECSensor.FanCPUOpt, new EmbeddedControllerSource("CPU Optional Fan", SensorType.Fan, 0x00b0, 2) },
                { ECSensor.TempTSensor, new EmbeddedControllerSource("T Sensor", SensorType.Temperature, 0x0109, blank: -40) },
                { ECSensor.TempTSensor2, new EmbeddedControllerSource("T Sensor 2", SensorType.Temperature, 0x105, blank: -40) },
                { ECSensor.TempWaterIn, new EmbeddedControllerSource("Water In", SensorType.Temperature, 0x0100, blank: -40) },
                { ECSensor.TempWaterOut, new EmbeddedControllerSource("Water Out", SensorType.Temperature, 0x0101, blank: -40) },
                { ECSensor.FanWaterFlow, new EmbeddedControllerSource("Water Flow", SensorType.Flow, 0x00be, 2, factor: 1.0f / 42f * 60f) } // todo: need validation for this calculation
            }
        }
    };

    private readonly byte[] _data;
    private readonly ushort[] _registers;
    private readonly List<Sensor> _sensors;

    private readonly IReadOnlyList<EmbeddedControllerSource> _sources;

    protected EmbeddedController(IEnumerable<EmbeddedControllerSource> sources, ISettings settings) : base("Embedded Controller", new Identifier("lpc", "ec"), settings)
    {
        // sorting by address, which implies sorting by bank, for optimized EC access
        var sourcesList = sources.ToList();
        sourcesList.Sort((left, right) => left.Register.CompareTo(right.Register));
        _sources = sourcesList;
        var indices = new Dictionary<SensorType, int>();
        foreach (SensorType t in Enum.GetValues(typeof(SensorType)))
        {
            indices.Add(t, 0);
        }

        _sensors = new List<Sensor>();
        List<ushort> registers = new();
        foreach (EmbeddedControllerSource s in _sources)
        {
            int index = indices[s.Type];
            indices[s.Type] = index + 1;
            _sensors.Add(new Sensor(s.Name, index, s.Type, this, settings));
            for (int i = 0; i < s.Size; ++i)
            {
                registers.Add((ushort)(s.Register + i));
            }

            ActivateSensor(_sensors[_sensors.Count - 1]);
        }

        _registers = registers.ToArray();
        _data = new byte[_registers.Length];
    }

    public override HardwareType HardwareType => HardwareType.EmbeddedController;

    internal static EmbeddedController Create(Model model, ISettings settings)
    {
        var boards = _boards.Where(b => b.Models.Contains(model)).ToList();
        switch (boards.Count)
        {
            case 0:
                return null;
            case > 1:
                throw new MultipleBoardRecordsFoundException(model.ToString());
        }

        BoardInfo board = boards[0];

        if (board.Family == BoardFamily.CrOS)
        {
            return ChromeOSEmbeddedController.Create(settings);
        }

        IEnumerable<EmbeddedControllerSource> sources = board.Sensors.Select(ecs => _knownSensors[board.Family][ecs]);

        return Environment.OSVersion.Platform switch
        {
            PlatformID.Win32NT => new WindowsEmbeddedController(sources, settings),
            _ => null
        };
    }

    public override void Update()
    {
        if (!TryUpdateData())
        {
            // just skip this update cycle?
            return;
        }

        int readRegister = 0;
        for (int si = 0; si < _sensors.Count; ++si)
        {
            int littleEndian    = _sources[si].IsLittleEndian ? 1 : 0;
            int bigEndian       = _sources[si].IsLittleEndian ? 0 : 1;

            int val = _sources[si].Size switch
            {
                1 => _sources[si].Type switch { SensorType.Temperature => unchecked((sbyte)_data[readRegister]), _ => _data[readRegister] },
                2 => unchecked((short)((_data[readRegister + littleEndian] << 8) + _data[readRegister + bigEndian])),
                _ => 0
            };

            readRegister += _sources[si].Size;

            _sensors[si].Value = val != _sources[si].Blank ? (val * _sources[si].Factor) + _sources[si].Offset : null;
        }
    }

    public override string GetReport()
    {
        StringBuilder r = new();

        r.AppendLine("EC " + GetType().Name);
        r.AppendLine("Embedded Controller Registers");
        r.AppendLine();
        r.AppendLine("      00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F");
        r.AppendLine();

        try
        {
            using IEmbeddedControllerIO embeddedControllerIO = AcquireIOInterface();
            ushort[] src = new ushort[0x100];
            byte[] data = new byte[0x100];
            for (ushort i = 0; i < src.Length; ++i)
            {
                src[i] = i;
            }

            embeddedControllerIO.Read(src, data);
            for (int i = 0; i <= 0xF; ++i)
            {
                r.Append(" ");
                r.Append((i << 4).ToString("X2", CultureInfo.InvariantCulture));
                r.Append("  ");
                for (int j = 0; j <= 0xF; ++j)
                {
                    byte address = (byte)(i << 4 | j);
                    r.Append(" ");
                    r.Append(data[address].ToString("X2", CultureInfo.InvariantCulture));
                }

                r.AppendLine();
            }
        }
        catch (IOException e)
        {
            r.AppendLine(e.Message);
        }

        return r.ToString();
    }

    protected abstract IEmbeddedControllerIO AcquireIOInterface();

    private bool TryUpdateData()
    {
        try
        {
            using IEmbeddedControllerIO embeddedControllerIO = AcquireIOInterface();
            embeddedControllerIO.Read(_registers, _data);
            return true;
        }
        catch (IOException)
        {
            return false;
        }
    }

    private enum ECSensor
    {
        /// <summary>Chipset temperature [℃]</summary>
        TempChipset,

        /// <summary>CPU temperature [℃]</summary>
        TempCPU,
		
        /// <summary>CPU Package temperature [℃]</summary>
        TempCPUPackage,

        /// <summary>motherboard temperature [℃]</summary>
        TempMB,

        /// <summary>"T_Sensor" temperature sensor reading [℃]</summary>
        TempTSensor,

        /// <summary>"T_Sensor 2" temperature sensor reading [℃]</summary>
        TempTSensor2,

        /// <summary>VRM temperature [℃]</summary>
        TempVrm,

        /// <summary>CPU Core voltage [mV]</summary>
        VoltageCPU,

        /// <summary>CPU_Opt fan [RPM]</summary>
        FanCPUOpt,

        /// <summary>VRM heat sink fan [RPM]</summary>
        FanVrmHS,

        /// <summary>Chipset fan [RPM]</summary>
        FanChipset,

        /// <summary>Water Pump [RPM]</summary>
        FanWaterPump,

        /// <summary>Water flow sensor reading [RPM]</summary>
        FanWaterFlow,

        /// <summary>CPU current [A]</summary>
        CurrCPU,

        /// <summary>"Water_In" temperature sensor reading [℃]</summary>
        TempWaterIn,

        /// <summary>"Water_Out" temperature sensor reading [℃]</summary>
        TempWaterOut,

        /// <summary>Water block temperature sensor reading [℃]</summary>
        TempWaterBlockIn,
        Max
    }

    private enum BoardFamily
    {
        Amd400,
        Amd500,
        Amd600,
		Amd800,
        Intel100,
        Intel300,
        Intel400,
        Intel600,
        Intel700,
        CrOS
    }

    private struct BoardInfo
    {
        public BoardInfo(Model[] models, BoardFamily family, params ECSensor[] sensors)
        {
            Models = models;
            Family = family;
            Sensors = sensors;
        }

        public BoardInfo(Model model, BoardFamily family, params ECSensor[] sensors)
        {
            Models = new[] { model };
            Family = family;
            Sensors = sensors;
        }

        public Model[] Models { get; }

        public BoardFamily Family { get; }

        public ECSensor[] Sensors { get; }
    }

    public class IOException : System.IO.IOException
    {
        public IOException(string message) : base($"ACPI embedded controller I/O error: {message}")
        { }
    }

    public class BadConfigurationException : Exception
    {
        public BadConfigurationException(string message) : base(message)
        { }
    }

    public class MultipleBoardRecordsFoundException : BadConfigurationException
    {
        public MultipleBoardRecordsFoundException(string model) : base($"Multiple board records refer to the same model '{model}'")
        { }
    }
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/EC/EmbeddedControllerReader.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc.EC;

public delegate float EmbeddedControllerReader(IEmbeddedControllerIO ecIO, ushort register);
```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/EC/EmbeddedControllerSource.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc.EC;

public class EmbeddedControllerSource(string name, SensorType type, ushort register, byte size = 1, float factor = 1.0f, float offset = 0.0f, int blank = int.MaxValue, bool isLittleEndian = false)
{
    public int Blank { get; } = blank;

    public float Factor { get; } = factor;

    public bool IsLittleEndian { get; } = isLittleEndian;

    public string Name { get; } = name;

    public float Offset { get; } = offset;

    public ushort Register { get; } = register;

    public byte Size { get; } = size;

    public SensorType Type { get; } = type;
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/EC/IEmbeddedControllerIO.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc.EC;

public interface IEmbeddedControllerIO : IDisposable
{
    void Read(ushort[] registers, byte[] data);
}
```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/EC/WindowsEmbeddedController.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System.Collections.Generic;

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc.EC;

public class WindowsEmbeddedController : EmbeddedController
{
    public WindowsEmbeddedController(IEnumerable<EmbeddedControllerSource> sources, ISettings settings) : base(sources, settings)
    { }

    protected override IEmbeddedControllerIO AcquireIOInterface()
    {
        return new WindowsEmbeddedControllerIO();
    }
}
```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/EC/WindowsEmbeddedControllerIO.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System.Diagnostics;
using System.Threading;
using LibreHardwareMonitor.PawnIo;

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc.EC;

/// <summary>
/// An unsafe but universal implementation for the ACPI Embedded Controller IO interface for Windows
/// </summary>
/// <remarks>
/// It is unsafe because of possible race condition between this application and the PC firmware when
/// writing to the EC registers. For a safe approach ACPI/WMI methods have to be used, but those are
/// different for each motherboard model.
/// </remarks>
public class WindowsEmbeddedControllerIO : IEmbeddedControllerIO
{
    private const int FailuresBeforeSkip = 20;
    private const int MaxRetries = 5;

    // implementation
    private const int WaitSpins = 50;

    private readonly LpcAcpiEc _pawnModule;
    private bool _disposed;

    private int _waitReadFailures;

    public WindowsEmbeddedControllerIO()
    {
        _pawnModule = new LpcAcpiEc();

        if (!Mutexes.WaitEc(10))
        {
            throw new BusMutexLockingFailedException();
        }
    }

    public void Read(ushort[] registers, byte[] data)
    {
        Trace.Assert(registers.Length <= data.Length,
                     "data buffer length has to be greater or equal to the registers array length");

        byte bank = 0;
        byte prevBank = SwitchBank(bank);

        // oops... somebody else is working with the EC too
        Trace.WriteLineIf(prevBank != 0, "Concurrent access to the ACPI EC detected.\nRace condition possible.");

        // read registers minimizing bank switches.
        for (int i = 0; i < registers.Length; i++)
        {
            byte regBank = (byte)(registers[i] >> 8);
            byte regIndex = (byte)(registers[i] & 0xFF);
            // registers are sorted by bank
            if (regBank > bank)
            {
                bank = SwitchBank(regBank);
            }

            data[i] = ReadByte(regIndex);
        }

        SwitchBank(prevBank);
    }

    public void Dispose()
    {
        if (!_disposed)
        {
            _disposed = true;
            Mutexes.ReleaseEc();
            _pawnModule.Close();
        }
    }

    private byte ReadByte(byte register)
    {
        return ReadLoop<byte>(register, ReadByteOp);
    }

    private void WriteByte(byte register, byte value)
    {
        WriteLoop(register, value, WriteByteOp);
    }

    private byte SwitchBank(byte bank)
    {
        byte previous = ReadByte(0xFF);
        WriteByte(0xFF, bank);
        return previous;
    }

    private TResult ReadLoop<TResult>(byte register, ReadOp<TResult> op) where TResult : new()
    {
        TResult result = new();

        for (int i = 0; i < MaxRetries; i++)
        {
            if (op(register, out result))
            {
                return result;
            }
        }

        return result;
    }

    private void WriteLoop<TValue>(byte register, TValue value, WriteOp<TValue> op)
    {
        for (int i = 0; i < MaxRetries; i++)
        {
            if (op(register, value))
            {
                return;
            }
        }
    }

    private bool WaitForStatus(Status status, bool isSet)
    {
        for (int i = 0; i < WaitSpins; i++)
        {
            byte value = ReadIOPort(Port.Command);

            if (((byte)status & (!isSet ? value : (byte)~value)) == 0)
            {
                return true;
            }

            Thread.Sleep(1);
        }

        return false;
    }

    private bool WaitRead()
    {
        if (_waitReadFailures > FailuresBeforeSkip)
        {
            return true;
        }

        // Try OBF with reduced timeout
        for (int i = 0; i < MaxRetries; i++)
        {
            byte status = ReadIOPort(Port.Command);
            if ((status & (byte)Status.OutputBufferFull) != 0)
            {
                _waitReadFailures = 0;
                return true;
            }

            Thread.Sleep(1);
        }

        // ASUS workaround: Wait for IBF to clear instead of OBF
        // Testing on Z170 Pro Gaming shows IBF clears in 1-3ms when data is ready
        for (int i = 0; i < WaitSpins; i++)
        {
            byte status = ReadIOPort(Port.Command);
            if ((status & (byte)Status.InputBufferFull) == 0)
            {
                _waitReadFailures = 0;
                return true;
            }

            Thread.Sleep(1);
        }

        _waitReadFailures++;
        return false;
    }

    private bool WaitWrite()
    {
        return WaitForStatus(Status.InputBufferFull, false);
    }

    private byte ReadIOPort(Port port)
    {
        return _pawnModule.ReadPort((byte)port);
    }

    private void WriteIOPort(Port port, byte datum)
    {
        _pawnModule.WritePort((byte)port, datum);
    }

    protected bool ReadByteOp(byte register, out byte value)
    {
        if (WaitWrite())
        {
            WriteIOPort(Port.Command, (byte)Command.Read);

            if (WaitWrite())
            {
                WriteIOPort(Port.Data, register);

                if (WaitWrite() && WaitRead())
                {
                    value = ReadIOPort(Port.Data);
                    return true;
                }
            }
        }

        value = 0;
        return false;
    }

    protected bool WriteByteOp(byte register, byte value)
    {
        if (WaitWrite())
        {
            WriteIOPort(Port.Command, (byte)Command.Write);
            if (WaitWrite())
            {
                WriteIOPort(Port.Data, register);
                if (WaitWrite())
                {
                    WriteIOPort(Port.Data, value);
                    return true;
                }
            }
        }

        return false;
    }

    public class BusMutexLockingFailedException : EmbeddedController.IOException
    {
        public BusMutexLockingFailedException() : base("could not lock ISA bus mutex")
        { }
    }

    private delegate bool ReadOp<TParam>(byte register, out TParam p);

    private delegate bool WriteOp<in TParam>(byte register, TParam p);

    // see the ACPI specification chapter 12
    private enum Port : byte
    {
        Command = 0x66,
        Data = 0x62
    }

    private enum Command : byte
    {
        Read = 0x80, // RD_EC
        Write = 0x81, // WR_EC
        BurstEnable = 0x82, // BE_EC
        BurstDisable = 0x83, // BD_EC
        Query = 0x84 // QR_EC
    }

    private enum Status : byte
    {
        OutputBufferFull = 0x01, // EC_OBF
        InputBufferFull = 0x02, // EC_IBF
        Command = 0x08, // CMD
        BurstMode = 0x10, // BURST
        SciEventPending = 0x20, // SCI_EVT
        SmiEventPending = 0x40 // SMI_EVT
    }
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/EcioPortGigabyteController.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

//#define ECIO_GIGABYTE_CONTROLLER_DEBUG

using System;
using System.Diagnostics;
using System.Threading;

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc;

internal class EcioPortGigabyteController : IGigabyteController
{
    private const ushort ControllerVersionOffset = 0x00;
    private const ushort ControllerEnableRegister = 0x47;
    private const ushort ControllerFanControlArea = 0x900;

    private readonly IT879xEcioPort _port;

    private bool? _initialState;
    private bool? _current;

    private EcioPortGigabyteController(IT879xEcioPort port)
    {
        _port = port;
    }

    public static EcioPortGigabyteController TryCreate(LpcPort lpcPort)
    {
        IT879xEcioPort port = new(lpcPort);

        // Check compatibility by querying its version.
        if (!port.Read(ControllerFanControlArea + ControllerVersionOffset, out byte majorVersion) || majorVersion != 1)
        {
            return null;
        }

        return new EcioPortGigabyteController(port);
    }

    public bool Enable(bool enabled)
    {
        ushort offset = ControllerFanControlArea + ControllerEnableRegister;

        if (!_current.HasValue)
        {
            if (!_port.Read(offset, out byte bCurrent))
            {
                Log($"ENABLE: Could not read at offset {offset}");
                return false;
            }

            Log($"ENABLE: read value {bCurrent} at offset {offset}");

            _current = Convert.ToBoolean(bCurrent);
            _initialState ??= _current;
        }

        if (_current != enabled)
        {
            if (!_port.Write(offset, Convert.ToByte(enabled)))
            {
                Log($"ENABLE: could not write value {Convert.ToByte(enabled)} at offset {offset}");
                return false;
            }

            Log($"ENABLE: write value {Convert.ToByte(enabled)} at offset {offset}");

            // Allow the system to catch up.
            Thread.Sleep(500);

            _current = enabled;
        }

        return true;
    }

    public void Restore()
    {
        if (_initialState.HasValue)
        {
            Enable(_initialState.Value);
        }
    }

    public void Dispose()
    {
        Restore();
    }

    /// <summary>
    /// Writes a debug message to the output window and appends it to the debug log file when
    /// ECIO_GIGABYTE_CONTROLLER_DEBUG is defined.
    /// </summary>
    /// <remarks>This method only performs logging when the ECIO_GIGABYTE_CONTROLLER_DEBUG compilation symbol
    /// is defined. The log file is named "EcioPortGigabyteController_DebugLog.txt" and is appended to with each call.
    /// Use this method for diagnostic purposes during development or troubleshooting.</remarks>
    /// <param name="message">The message to log. This text is written to both the debug output and the log file.</param>
    [Conditional("DEBUG_LOG"), Conditional("ECIO_GIGABYTE_CONTROLLER_DEBUG")]
    private static void Log(string message)
    {
        Debug.WriteLine(message);
    }
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/F718XX.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Globalization;
using System.Text;

// ReSharper disable once InconsistentNaming

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc;

internal class F718XX : ISuperIO
{
    private readonly LpcPort _port;
    private readonly ushort _address;
    private readonly byte[] _initialFanPwmControl = new byte[4];
    private readonly bool[] _restoreDefaultFanPwmControlRequired = new bool[4];

    public F718XX(LpcPort port, Chip chip, ushort address)
    {
        _port = port;
        _address = address;
        Chip = chip;

        Voltages = new float?[chip == Chip.F71858 ? 3 : 9];
        Temperatures = new float?[chip == Chip.F71808E ? 2 : 3];
        Fans = new float?[chip is Chip.F71882 or Chip.F71858 ? 4 : 3];
        Controls = new float?[chip == Chip.F71878AD || chip == Chip.F71889AD ? 3 : (chip == Chip.F71882 ? 4 : 0)];
    }

    public Chip Chip { get; }

    public float?[] Controls { get; }

    public float?[] Fans { get; }

    public float?[] Temperatures { get; }

    public float?[] Voltages { get; }

    public byte? ReadGpio(int index)
    {
        return null;
    }

    public void WriteGpio(int index, byte value)
    { }

    public void SetControl(int index, byte? value)
    {
        if (index < 0 || index >= Controls.Length)
            throw new ArgumentOutOfRangeException(nameof(index));

        if (!Mutexes.WaitIsaBus(10))
            return;

        if (value.HasValue)
        {
            SaveDefaultFanPwmControl(index);

            WriteByte(FAN_PWM_REG[index], value.Value);
        }
        else
        {
            RestoreDefaultFanPwmControl(index);
        }

        Mutexes.ReleaseIsaBus();
    }

    public string GetReport()
    {
        StringBuilder r = new();

        r.AppendLine("LPC " + GetType().Name);
        r.AppendLine();
        r.Append("Base Address: 0x");
        r.AppendLine(_address.ToString("X4", CultureInfo.InvariantCulture));
        r.AppendLine();

        if (!Mutexes.WaitIsaBus(100))
            return r.ToString();

        r.AppendLine("Hardware Monitor Registers");
        r.AppendLine();
        r.AppendLine("      00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F");
        r.AppendLine();
        for (int i = 0; i <= 0xF; i++)
        {
            r.Append(" ");
            r.Append((i << 4).ToString("X2", CultureInfo.InvariantCulture));
            r.Append("  ");
            for (int j = 0; j <= 0xF; j++)
            {
                r.Append(" ");
                r.Append(ReadByte((byte)((i << 4) | j)).ToString("X2",
                                                                 CultureInfo.InvariantCulture));
            }

            r.AppendLine();
        }

        r.AppendLine();

        Mutexes.ReleaseIsaBus();
        return r.ToString();
    }

    public void Update()
    {
        if (!Mutexes.WaitIsaBus(10))
            return;

        for (int i = 0; i < Voltages.Length; i++)
        {
            if (Chip == Chip.F71808E && i == 6)
            {
                // 0x26 is reserved on F71808E
                Voltages[i] = 0;
            }
            else
            {
                int value = ReadByte((byte)(VOLTAGE_BASE_REG + i));
                Voltages[i] = 0.008f * value;
            }
        }

        for (int i = 0; i < Temperatures.Length; i++)
        {
            switch (Chip)
            {
                case Chip.F71858:
                    {
                        int tableMode = 0x3 & ReadByte(TEMPERATURE_CONFIG_REG);
                        int high = ReadByte((byte)(TEMPERATURE_BASE_REG + (2 * i)));
                        int low = ReadByte((byte)(TEMPERATURE_BASE_REG + (2 * i) + 1));
                        if (high is not 0xbb and not 0xcc)
                        {
                            int bits = 0;
                            switch (tableMode)
                            {
                                case 0:
                                    break;
                                case 1:
                                    bits = 0;
                                    break;
                                case 2:
                                    bits = (high & 0x80) << 8;
                                    break;
                                case 3:
                                    bits = (low & 0x01) << 15;
                                    break;
                            }

                            bits |= high << 7;
                            bits |= (low & 0xe0) >> 1;
                            short value = (short)(bits & 0xfff0);
                            Temperatures[i] = value / 128.0f;
                        }
                        else
                        {
                            Temperatures[i] = null;
                        }
                    }

                    break;
                default:
                    {
                        sbyte value = (sbyte)ReadByte((byte)(TEMPERATURE_BASE_REG + (2 * (i + 1))));
                        if (value is < sbyte.MaxValue and > 0)
                            Temperatures[i] = value;
                        else
                            Temperatures[i] = null;
                    }

                    break;
            }
        }

        for (int i = 0; i < Fans.Length; i++)
        {
            int value = ReadByte(FAN_TACHOMETER_REG[i]) << 8;
            value |= ReadByte((byte)(FAN_TACHOMETER_REG[i] + 1));

            if (value > 0)
                Fans[i] = value < 0x0fff ? 1.5e6f / value : 0;
            else
                Fans[i] = null;
        }

        for (int i = 0; i < Controls.Length; i++)
        {
            if (Chip == Chip.F71882 || Chip == Chip.F71889AD)
            {
                Controls[i] = ReadByte((byte)(FAN_PWM_REG[i])) * 100.0f / 0xFF;
            }
            else
            {
                Controls[i] = ReadByte((byte)(PWM_VALUES_OFFSET + i)) * 100.0f / 0xFF;
            }
        }

        Mutexes.ReleaseIsaBus();
    }

    /// <inheritdoc />
    public void Close()
    {
        _port.Close();
    }

    private void SaveDefaultFanPwmControl(int index)
    {
        if (!_restoreDefaultFanPwmControlRequired[index])
        {
            _initialFanPwmControl[index] = ReadByte(FAN_PWM_REG[index]);
            _restoreDefaultFanPwmControlRequired[index] = true;
        }
    }

    private void RestoreDefaultFanPwmControl(int index)
    {
        if (_restoreDefaultFanPwmControlRequired[index])
        {
            WriteByte(FAN_PWM_REG[index], _initialFanPwmControl[index]);
            _restoreDefaultFanPwmControlRequired[index] = false;
        }
    }

    private byte ReadByte(byte register)
    {
        _port.WriteIoPort((ushort)(_address + ADDRESS_REGISTER_OFFSET), register);
        return _port.ReadIoPort((ushort)(_address + DATA_REGISTER_OFFSET));
    }

    private void WriteByte(byte register, byte value)
    {
        _port.WriteIoPort((ushort)(_address + ADDRESS_REGISTER_OFFSET), register);
        _port.WriteIoPort((ushort)(_address + DATA_REGISTER_OFFSET), value);
    }

    // ReSharper disable InconsistentNaming
#pragma warning disable IDE1006 // Naming Styles

    private const byte ADDRESS_REGISTER_OFFSET = 0x05;
    private const byte DATA_REGISTER_OFFSET = 0x06;
    private const byte PWM_VALUES_OFFSET = 0x2D;
    private const byte TEMPERATURE_BASE_REG = 0x70;
    private const byte TEMPERATURE_CONFIG_REG = 0x69;

    private const byte VOLTAGE_BASE_REG = 0x20;
    private readonly byte[] FAN_PWM_REG = { 0xA3, 0xB3, 0xC3, 0xD3 };
    private readonly byte[] FAN_TACHOMETER_REG = { 0xA0, 0xB0, 0xC0, 0xD0 };

    // ReSharper restore InconsistentNaming
#pragma warning restore IDE1006 // Naming Styles
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/IGigabyteController.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc;

internal interface IGigabyteController: IDisposable
{
    bool Enable(bool enabled);

    void Restore();
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/ISuperIO.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc;

internal interface ISuperIO
{
    Chip Chip { get; }

    float?[] Controls { get; }

    float?[] Fans { get; }

    float?[] Temperatures { get; }

    // get voltage, temperature, fan and control channel values
    float?[] Voltages { get; }

    // set control value, null = auto
    void SetControl(int index, byte? value);

    // read and write GPIO
    byte? ReadGpio(int index);

    void WriteGpio(int index, byte value);

    string GetReport();

    void Update();

    void Close();
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/IT879xEcioPort.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Diagnostics;

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc;

internal class IT879xEcioPort
{
    private const ushort EcioRegisterPort = 0x3F4;
    private const ushort EcioValuePort = 0x3F0;

    public IT879xEcioPort(LpcPort lpcPort)
    {
        _lpcPort = lpcPort;
    }

    public bool Read(ushort offset, out byte value)
    {
        if (!Init(0xB0, offset))
        {
            value = 0;
            return false;
        }

        return ReadFromValue(out value);
    }

    public bool Write(ushort offset, byte value)
    {
        if (!Init(0xB1, offset))
        {
            return false;
        }

        return WriteToValue(value);
    }

    private bool Init(byte command, ushort offset)
    {
        if (!WriteToRegister(command))
        {
            return false;
        }

        if (!WriteToValue((byte)((offset >> 8) & 0xFF)))
        {
            return false;
        }

        if (!WriteToValue((byte)(offset & 0xFF)))
        {
            return false;
        }

        return true;
    }

    private bool WriteToRegister(byte value)
    {
        if (!WaitIBE())
        {
            return false;
        }

        _lpcPort.WriteIoPort(EcioRegisterPort, value);
        return true;
    }

    private bool WriteToValue(byte value)
    {
        if (!WaitIBE())
        {
            return false;
        }

        _lpcPort.WriteIoPort(EcioValuePort, value);
        return true;
    }

    private bool ReadFromValue(out byte value)
    {
        if (!WaitOBF())
        {
            value = 0;
            return false;
        }

        value = _lpcPort.ReadIoPort(EcioValuePort);
        return true;
    }

    private bool WaitIBE()
    {
        Stopwatch stopwatch = Stopwatch.StartNew();

        while ((_lpcPort.ReadIoPort(EcioRegisterPort) & 2) != 0)
        {
            if (stopwatch.ElapsedMilliseconds > WAIT_TIMEOUT)
            {
                return false;
            }
        }

        return true;
    }

    private bool WaitOBF()
    {
        Stopwatch stopwatch = Stopwatch.StartNew();
        while ((_lpcPort.ReadIoPort(EcioRegisterPort) & 1) == 0)
        {
            if (stopwatch.ElapsedMilliseconds > WAIT_TIMEOUT)
            {
                return false;
            }
        }

        return true;
    }

    private const long WAIT_TIMEOUT = 1000L;
    private readonly LpcPort _lpcPort;
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/IT87XX.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Globalization;
using System.Linq;
using System.Text;

// ReSharper disable once InconsistentNaming

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc;

internal class IT87XX : ISuperIO
{
    private const int MaxFanHeaders = 6;
    private readonly ushort _address;
    private readonly ushort _addressReg;
    private readonly int _bankCount;
    private readonly ushort _dataReg;
    private readonly bool[] _fansDisabled = Array.Empty<bool>();
    private readonly ushort _gpioAddress;
    private readonly int _gpioCount;
    private readonly bool _has16BitFanCounter;
    private readonly bool _hasExtReg;
    private readonly bool _hasAlt6thFanReg;
    private readonly bool[] _initialFanOutputModeEnabled = new bool[3]; // Initial Fan Controller Main Control Register value. 
    private readonly byte[] _initialFanPwmControl = new byte[MaxFanHeaders]; // This will also store the 2nd control register value.
    private readonly byte[] _initialFanPwmControlExt = new byte[MaxFanHeaders];
    private readonly bool[] _restoreDefaultFanPwmControlRequired = new bool[MaxFanHeaders];
    private readonly byte _version;
    private readonly float _voltageGain;
    private IGigabyteController _gigabyteController;
    private readonly LpcPort _port;
    private readonly bool _requiresBankSelect;  // Fix #780 Set to true for those chips that need a SelectBank(0) to fix dodgy temps and fan speeds

    private bool SupportsMultipleBanks => _bankCount > 1;

    public IT87XX(LpcPort port, Chip chip, ushort address, ushort gpioAddress, byte version, Motherboard motherboard, IGigabyteController gigabyteController)
    {
        _port = port;
        _address = address;
        _version = version;
        _addressReg = (ushort)(address + ADDRESS_REGISTER_OFFSET);
        _dataReg = (ushort)(address + DATA_REGISTER_OFFSET);
        _gpioAddress = gpioAddress;
        _gigabyteController = gigabyteController;
        _requiresBankSelect = false;

        Chip = chip;

        // Check vendor id
        byte vendorId = ReadByte(VENDOR_ID_REGISTER, out bool valid);
        if (!valid)
            return;

        bool hasMatchingVendorId = false;
        foreach (byte iteVendorId in ITE_VENDOR_IDS)
        {
            if (iteVendorId == vendorId)
            {
                hasMatchingVendorId = true;
                break;
            }
        }

        if (!hasMatchingVendorId)
            return;

        // Bit 0x10 of the configuration register should always be 1
        byte configuration = ReadByte(CONFIGURATION_REGISTER, out valid);
        if (!valid || ((configuration & 0x10) == 0 && chip != Chip.IT8655E && chip != Chip.IT8665E))
            return;

        FAN_PWM_CTRL_REG = chip switch
        {
            Chip.IT8665E or Chip.IT8625E => new byte[] { 0x15, 0x16, 0x17, 0x1e, 0x1f, 0x92 },
            Chip.IT8792E => new byte[] { 0x15, 0x16, 0x17 },
            _ => new byte[] { 0x15, 0x16, 0x17, 0x7f, 0xa7, 0xaf }
        };

        _bankCount = chip switch
        {
            Chip.IT8689E => 4,
            _ => 1
        };

        _hasExtReg = chip is Chip.IT8721F or
            Chip.IT8728F or
            Chip.IT8665E or
            Chip.IT8686E or
            Chip.IT8688E or
            Chip.IT8689E or
            Chip.IT87952E or
            Chip.IT8628E or
            Chip.IT8625E or
            Chip.IT8620E or
            Chip.IT8613E or
            Chip.IT8792E or
            Chip.IT8655E or
            Chip.IT8631E or
            Chip.IT8638E or
            Chip.IT8696E;

        _hasAlt6thFanReg = chip is Chip.IT8665E or Chip.IT8625E;

        switch (chip)
        {
            case Chip.IT8613E:
                Voltages = new float?[10];
                Temperatures = new float?[4];
                Fans = new float?[5];
                Controls = new float?[4];
                break;

            case Chip.IT8625E:
                Voltages = new float?[7];
                Temperatures = new float?[3];
                Fans = new float?[6];
                Controls = new float?[6];
                break;
            case Chip.IT8628E:
                Voltages = new float?[10];
                Temperatures = new float?[6];
                Fans = new float?[6];
                Controls = new float?[6];
                break;

            case Chip.IT8631E:
                Voltages = new float?[9];
                Temperatures = new float?[2];
                Fans = new float?[2];
                Controls = new float?[2];
                break;

            case Chip.IT8638E:
                Voltages = new float?[9];
                Temperatures = new float?[2];
                Fans = new float?[2];
                Controls = new float?[2];
                break;

            case Chip.IT8665E:
                Voltages = new float?[9];
                Temperatures = new float?[6];
                Fans = new float?[6];
                Controls = new float?[6];
                _requiresBankSelect = true;
                break;

            case Chip.IT8686E:
                Voltages = new float?[10];
                Temperatures = new float?[6];
                Fans = new float?[6];
                Controls = new float?[5];
                break;

            case Chip.IT8688E:
                Voltages = new float?[11];
                Temperatures = new float?[6];
                Fans = new float?[6];
                Controls = new float?[5];
                break;

            case Chip.IT8689E:
                Voltages = new float?[10];
                Temperatures = new float?[6];
                Fans = new float?[6];
                Controls = new float?[6];
                break;

            case Chip.IT8696E:
                Voltages = new float?[10];
                Temperatures = new float?[6];
                Fans = new float?[6];
                Controls = new float?[6];
                break;

            case Chip.IT87952E:
                Voltages = new float?[9];
                Temperatures = new float?[3];
                Fans = new float?[3];
                Controls = new float?[3];
                break;

            case Chip.IT8655E:
                Voltages = new float?[9];
                Temperatures = new float?[6];
                Fans = new float?[3];
                Controls = new float?[3];
                _requiresBankSelect = true;
                break;

            case Chip.IT8792E:
                Voltages = new float?[9];
                Temperatures = new float?[3];
                Fans = new float?[3];
                Controls = new float?[3];
                break;

            case Chip.IT8705F:
                Voltages = new float?[9];
                Temperatures = new float?[3];
                Fans = new float?[3];
                Controls = new float?[3];
                break;

            case Chip.IT8620E:
                Voltages = new float?[9];
                Temperatures = new float?[3];
                Fans = new float?[5];
                Controls = new float?[5];
                break;

            default:
                Voltages = new float?[9];
                Temperatures = new float?[3];
                Fans = new float?[5];
                Controls = new float?[3];
                break;
        }

        _fansDisabled = new bool[Fans.Length];

        // Voltage gain varies by model.
        // Conflicting reports on IT8792E: either 0.0109 in linux drivers or 0.011 comparing with Gigabyte board & SIV SW.
        _voltageGain = chip switch
        {
            Chip.IT8613E or Chip.IT8620E or Chip.IT8628E or Chip.IT8631E or Chip.IT8638E or Chip.IT8721F or Chip.IT8728F or Chip.IT8771E or Chip.IT8772E or Chip.IT8686E or Chip.IT8688E or Chip.IT8689E or Chip.IT8696E => 0.012f,
            Chip.IT8625E or Chip.IT8792E or Chip.IT87952E => 0.011f,
            Chip.IT8655E or Chip.IT8665E => 0.0109f,
            _ => 0.016f
        };

        // Older IT8705F and IT8721F revisions do not have 16-bit fan counters.
        _has16BitFanCounter = (chip != Chip.IT8705F || version >= 3) && (chip != Chip.IT8712F || version >= 8);

        // Disable any fans that aren't set with 16-bit fan counters
        if (_has16BitFanCounter)
        {
            int modes = ReadByte(FAN_TACHOMETER_16BIT_REGISTER, out valid);

            if (!valid)
                return;

            if (Fans.Length >= 5)
            {
                _fansDisabled[3] = (modes & (1 << 4)) == 0;
                _fansDisabled[4] = (modes & (1 << 5)) == 0;
            }

            if (Fans.Length >= 6)
            {
                if (chip == Chip.IT8665E)
                {
                    modes = ReadByte(FAN_TACHOMETER_16BIT_REGISTER_ALT, out valid);
                    if (valid)
                        _fansDisabled[5] = (modes & (1 << 3)) == 0;
                }
                else
                    _fansDisabled[5] = (modes & (1 << 2)) == 0;
            }
        }

        // Set the number of GPIO sets
        _gpioCount = chip switch
        {
            Chip.IT8712F or Chip.IT8716F or Chip.IT8718F or Chip.IT8726F => 5,
            Chip.IT8720F or Chip.IT8721F => 8,
            _ => 0
        };
    }

    public Chip Chip { get; }

    public float?[] Controls { get; } = Array.Empty<float?>();

    public float?[] Fans { get; } = Array.Empty<float?>();

    public float?[] Temperatures { get; } = Array.Empty<float?>();

    public float?[] Voltages { get; } = Array.Empty<float?>();

    public byte? ReadGpio(int index)
    {
        if (index >= _gpioCount)
            return null;

        return _port.ReadIoPort((ushort)(_gpioAddress + index));
    }

    public void WriteGpio(int index, byte value)
    {
        if (index >= _gpioCount)
            return;

        _port.WriteIoPort((ushort)(_gpioAddress + index), value);
    }

    public void SetControl(int index, byte? value)
    {
        if (index < 0 || index >= Controls.Length)
            throw new ArgumentOutOfRangeException(nameof(index));

        if (!Mutexes.WaitIsaBus(10))
            return;

        if (value.HasValue)
        {
            SaveDefaultFanPwmControl(index);

            // Disable the controller when setting values to prevent it from overriding them
            if (_gigabyteController != null)
                _gigabyteController.Enable(false);

            if (index < 3 && !_initialFanOutputModeEnabled[index])
                WriteByte(FAN_MAIN_CTRL_REG, (byte)(ReadByte(FAN_MAIN_CTRL_REG, out _) | (1 << index)));

            if (_hasExtReg)
            {
                if (Chip == Chip.IT8689E)
                {
                    WriteByte(FAN_PWM_CTRL_REG[index], 0x7F);
                }
                else
                {
                    WriteByte(FAN_PWM_CTRL_REG[index], (byte)(_initialFanPwmControl[index] & 0x7F));
                }
                WriteByte(FAN_PWM_CTRL_EXT_REG[index], value.Value);
            }
            else
            {
                WriteByte(FAN_PWM_CTRL_REG[index], (byte)(value.Value >> 1));
            }
        }
        else
        {
            RestoreDefaultFanPwmControl(index);
        }

        Mutexes.ReleaseIsaBus();
    }

    public string GetReport()
    {
        StringBuilder r = new();

        r.AppendLine("LPC " + GetType().Name);
        r.AppendLine();
        r.Append("Chip ID: 0x");
        r.AppendLine(Chip.ToString("X"));
        r.Append("Chip Version: 0x");
        r.AppendLine(_version.ToString("X", CultureInfo.InvariantCulture));
        r.Append("Base Address: 0x");
        r.AppendLine(_address.ToString("X4", CultureInfo.InvariantCulture));
        r.Append("GPIO Address: 0x");
        r.AppendLine(_gpioAddress.ToString("X4", CultureInfo.InvariantCulture));
        r.AppendLine();

        if (!Mutexes.WaitIsaBus(100))
            return r.ToString();

        if (_requiresBankSelect)
            SelectBank(0);

        // dump memory of all banks if supported by chip
        for (byte b = 0; b < _bankCount; b++)
        {
            if (SupportsMultipleBanks && b > 0)
            {
                SelectBank(b);
            }
            r.AppendLine($"Environment Controller Registers Bank {b}");
            r.AppendLine();
            r.AppendLine("      00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F");
            r.AppendLine();
            for (int i = 0; i <= 0xA; i++)
            {
                r.Append(" ");
                r.Append((i << 4).ToString("X2", CultureInfo.InvariantCulture));
                r.Append("  ");
                for (int j = 0; j <= 0xF; j++)
                {
                    r.Append(" ");
                    byte value = ReadByte((byte)((i << 4) | j), out bool valid);
                    r.Append(valid ? value.ToString("X2", CultureInfo.InvariantCulture) : "??");
                }

                r.AppendLine();
            }

            r.AppendLine();
        }

        if (SupportsMultipleBanks)
        {
            SelectBank(0);
        }

        r.AppendLine();

        r.AppendLine("GPIO Registers");
        r.AppendLine();
        for (int i = 0; i < _gpioCount; i++)
        {
            r.Append(" ");
            r.Append(ReadGpio(i)?.ToString("X2", CultureInfo.InvariantCulture));
        }

        r.AppendLine();
        r.AppendLine();
        Mutexes.ReleaseIsaBus();
        return r.ToString();
    }

    /// <summary>
    /// Selects another bank. Memory from 0x10-0xAF swaps to data from new bank.
    /// Beware to select the default bank 0 after changing.
    /// Bank selection is reset after power cycle.
    /// </summary>
    /// <param name="bankIndex">New bank index. Can be a value of 0-3.</param>
    private void SelectBank(byte bankIndex)
    {
        if (bankIndex >= _bankCount)
            return; // current chip does not support that many banks

        // hard cap SelectBank to 2 bit values. If we ever have chips with more bank bits rewrite this method.
        bankIndex &= 0x3;

        byte value = ReadByte(BANK_REGISTER, out bool valid);
        if (valid)
        {
            value &= 0x9F;
            value |= (byte)(bankIndex << 5);
            WriteByte(BANK_REGISTER, value);
        }
    }

    public void Update()
    {
        if (!Mutexes.WaitIsaBus(10))
            return;

        // Is this needed on every update?  Yes, until a way to detect resume from sleep/hibernation is added, as that invalidates the bank select.
        if (_requiresBankSelect)
            SelectBank(0);

        for (int i = 0; i < Voltages.Length; i++)
        {
            float value = _voltageGain * ReadByte(IT87_REG_VIN[i], out bool valid);

            if (!valid)
                continue;

            if (value > 0)
                Voltages[i] = value;
            else
                Voltages[i] = null;
        }

        for (int i = 0; i < Temperatures.Length; i++)
        {
            sbyte value = (sbyte)ReadByte((byte)(TEMPERATURE_BASE_REG + i), out bool valid);
            if (!valid)
                continue;

            if (value is < sbyte.MaxValue and > 0)
                Temperatures[i] = value;
            else
                Temperatures[i] = null;
        }

        if (_has16BitFanCounter)
        {
            for (int i = 0; i < Fans.Length; i++)
            {
                if (_fansDisabled[i])
                    continue;

                int value = ReadByte(_hasAlt6thFanReg ? FAN_TACHOMETER_REG_ALT[i] : FAN_TACHOMETER_REG[i], out bool valid);
                if (!valid)
                    continue;

                value |= ReadByte(_hasAlt6thFanReg ? FAN_TACHOMETER_EXT_REG_ALT[i] : FAN_TACHOMETER_EXT_REG[i], out valid) << 8;
                if (!valid)
                    continue;

                if (value > 0x3f)
                    Fans[i] = value < 0xffff ? 1.35e6f / (value * 2) : 0;
                else
                    Fans[i] = null;
            }
        }
        else
        {
            for (int i = 0; i < Fans.Length; i++)
            {
                int value = ReadByte(FAN_TACHOMETER_REG[i], out bool valid);
                if (!valid)
                    continue;

                int divisor = 2;
                if (i < 2)
                {
                    int divisors = ReadByte(FAN_TACHOMETER_DIVISOR_REGISTER, out valid);
                    if (!valid)
                        continue;

                    divisor = 1 << ((divisors >> (3 * i)) & 0x7);
                }

                if (value > 0)
                    Fans[i] = value < 0xff ? 1.35e6f / (value * divisor) : 0;
                else
                    Fans[i] = null;
            }
        }

        for (int i = 0; i < Controls.Length; i++)
        {
            byte value = ReadByte(FAN_PWM_CTRL_REG[i], out bool valid);
            if (!valid)
                continue;

            if ((value & 0x80) > 0)
            {
                // Automatic operation (value can't be read).
                Controls[i] = null;
            }
            else
            {
                // Software operation.
                if (_hasExtReg)
                {
                    value = ReadByte(FAN_PWM_CTRL_EXT_REG[i], out valid);
                    if (valid)
                        Controls[i] = (float)Math.Round(value * 100.0f / 0xFF);
                }
                else
                {
                    Controls[i] = (float)Math.Round((value & 0x7F) * 100.0f / 0x7F);
                }
            }
        }

        Mutexes.ReleaseIsaBus();
    }

    public void Close()
    {
        _gigabyteController?.Dispose();
        _port.Close();
    }

    private byte ReadByte(byte register, out bool valid)
    {
        _port.WriteIoPort(_addressReg, register);
        byte value = _port.ReadIoPort(_dataReg);
        valid = register == _port.ReadIoPort(_addressReg) || Chip == Chip.IT8688E;
        // IT8688E doesn't return the value we wrote to
        // addressReg when we read it back.

        return value;
    }

    private void WriteByte(byte register, byte value)
    {
        _port.WriteIoPort(_addressReg, register);
        _port.WriteIoPort(_dataReg, value);
        _port.ReadIoPort(_addressReg);
    }

    private void SaveDefaultFanPwmControl(int index)
    {
        if (!_restoreDefaultFanPwmControlRequired[index])
        {
            _initialFanPwmControl[index] = ReadByte(FAN_PWM_CTRL_REG[index], out bool _);

            if (index < 3)
                _initialFanOutputModeEnabled[index] = ReadByte(FAN_MAIN_CTRL_REG, out bool _) != 0; // Save default control reg value.

            if (_hasExtReg)
                _initialFanPwmControlExt[index] = ReadByte(FAN_PWM_CTRL_EXT_REG[index], out _);
        }

        _restoreDefaultFanPwmControlRequired[index] = true;
    }

    private void RestoreDefaultFanPwmControl(int index)
    {
        if (_restoreDefaultFanPwmControlRequired[index])
        {
            WriteByte(FAN_PWM_CTRL_REG[index], _initialFanPwmControl[index]);

            if (index < 3)
            {
                byte value = ReadByte(FAN_MAIN_CTRL_REG, out _);

                bool isEnabled = (value & (1 << index)) != 0;
                if (isEnabled != _initialFanOutputModeEnabled[index])
                    WriteByte(FAN_MAIN_CTRL_REG, (byte)(value ^ (1 << index)));
            }

            if (_hasExtReg)
                WriteByte(FAN_PWM_CTRL_EXT_REG[index], _initialFanPwmControlExt[index]);

            _restoreDefaultFanPwmControlRequired[index] = false;

            // restore the GB controller when all fans become restored
            if (_gigabyteController != null && _restoreDefaultFanPwmControlRequired.All(e => e == false))
                _gigabyteController.Restore();
        }
    }

    // ReSharper disable InconsistentNaming
#pragma warning disable IDE1006 // Naming Styles

    private const byte ADDRESS_REGISTER_OFFSET = 0x05;

    private const byte CONFIGURATION_REGISTER = 0x00;
    private const byte DATA_REGISTER_OFFSET = 0x06;
    private const byte BANK_REGISTER = 0x06; // bit 5-6 define selected bank
    private const byte FAN_TACHOMETER_16BIT_REGISTER = 0x0C;
    private const byte FAN_TACHOMETER_16BIT_REGISTER_ALT = 0x0B;
    private const byte FAN_TACHOMETER_DIVISOR_REGISTER = 0x0B;

    private readonly byte[] ITE_VENDOR_IDS = { 0x90, 0x7F };

    private const byte TEMPERATURE_BASE_REG = 0x29;
    private const byte VENDOR_ID_REGISTER = 0x58;

    // https://github.com/torvalds/linux/blob/master/drivers/hwmon/it87.c
    private readonly byte[] IT87_REG_VIN = { 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x2f, 0x2c, 0x2d, 0x2e };

    private readonly byte[] FAN_PWM_CTRL_REG;
    private readonly byte[] FAN_PWM_CTRL_EXT_REG = { 0x63, 0x6b, 0x73, 0x7b, 0xa3, 0xab };
    private readonly byte[] FAN_TACHOMETER_EXT_REG = { 0x18, 0x19, 0x1a, 0x81, 0x83, 0x4d };
    private readonly byte[] FAN_TACHOMETER_REG = { 0x0d, 0x0e, 0x0f, 0x80, 0x82, 0x4c };
    private readonly byte[] FAN_TACHOMETER_EXT_REG_ALT = { 0x18, 0x19, 0x1a, 0x81, 0x83, 0x94 };
    private readonly byte[] FAN_TACHOMETER_REG_ALT = { 0x0d, 0x0e, 0x0f, 0x80, 0x82, 0x93 };

    // Address of the Fan Controller Main Control Register.
    // No need for the 2nd control register (bit 7 of 0x15 0x16 0x17),
    // as PWM value will set it to manual mode when new value is set.
    private const byte FAN_MAIN_CTRL_REG = 0x13;

#pragma warning restore IDE1006 // Naming Styles
    // ReSharper restore InconsistentNaming
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/Ipmi.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Management;
using System.Runtime.InteropServices;
using System.Text;

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc;

internal class Ipmi : ISuperIO
{
    // ReSharper disable InconsistentNaming
    private const byte COMMAND_FAN_LEVEL = 0x70;
    private const byte COMMAND_FAN_MODE = 0x45;
    private const byte COMMAND_GET_SDR = 0x23;
    private const byte COMMAND_GET_SDR_REPOSITORY_INFO = 0x20;
    private const byte COMMAND_GET_SENSOR_READING = 0x2d;

    private const byte FAN_MODE_FULL = 0x01;
    private const byte FAN_MODE_OPTIMAL = 0x02;

    private const byte NETWORK_FUNCTION_SENSOR_EVENT = 0x04;
    private const byte NETWORK_FUNCTION_STORAGE = 0x0a;
    private const byte NETWORK_FUNCTION_SUPERMICRO = 0x30;
    // ReSharper restore InconsistentNaming

    private readonly List<string> _controlNames = new();
    private readonly List<float> _controls = new();
    private readonly List<string> _fanNames = new();
    private readonly List<float> _fans = new();

    private readonly ManagementObject _ipmi;
    private readonly Manufacturer _manufacturer;

    private readonly List<Interop.Ipmi.Sdr> _sdrs = new();
    private readonly List<string> _temperatureNames = new();
    private readonly List<float> _temperatures = new();
    private readonly List<string> _voltageNames = new();
    private readonly List<float> _voltages = new();

    private bool _touchedFans;

    public Ipmi(Manufacturer manufacturer)
    {
        Chip = Chip.IPMI;
        _manufacturer = manufacturer;

        using ManagementClass ipmiClass = new("root\\WMI", "Microsoft_IPMI", null);

        foreach (ManagementBaseObject ipmi in ipmiClass.GetInstances())
        {
            if (ipmi is ManagementObject managementObject)
                _ipmi = managementObject;
        }

        // Fan control is exposed for Supermicro only as it differs between IPMI implementations
        if (_manufacturer == Manufacturer.Supermicro)
        {
            _controlNames.Add("CPU Fan");
            _controlNames.Add("System Fan");
        }

        // Perform an early update to count the number of sensors and get their names
        Update();

        Controls = new float?[_controls.Count];
        Fans = new float?[_fans.Count];
        Temperatures = new float?[_temperatures.Count];
        Voltages = new float?[_voltages.Count];
    }

    public Chip Chip { get; }

    public float?[] Controls { get; }

    public float?[] Fans { get; }

    public float?[] Temperatures { get; }

    public float?[] Voltages { get; }

    public string GetReport()
    {
        StringBuilder sb = new();
        Update(sb);
        return sb.ToString();
    }

    public void SetControl(int index, byte? value)
    {
        if (_manufacturer == Manufacturer.Supermicro)
        {
            if (value != null || _touchedFans)
            {
                _touchedFans = true;

                if (value == null)
                {
                    RunIPMICommand(COMMAND_FAN_MODE, NETWORK_FUNCTION_SUPERMICRO, new byte[] { 0x01 /* Set */, FAN_MODE_OPTIMAL });
                }
                else
                {
                    byte[] fanMode = RunIPMICommand(COMMAND_FAN_MODE, NETWORK_FUNCTION_SUPERMICRO, new byte[] { 0x00 });
                    if (fanMode == null || fanMode.Length < 2 || fanMode[0] != 0 || fanMode[1] != FAN_MODE_FULL)
                        RunIPMICommand(COMMAND_FAN_MODE, NETWORK_FUNCTION_SUPERMICRO, new byte[] { 0x01 /* Set */, FAN_MODE_FULL });

                    float speed = (float)value / 255.0f * 100.0f;
                    RunIPMICommand(COMMAND_FAN_LEVEL, NETWORK_FUNCTION_SUPERMICRO, new byte[] { 0x66, 0x01 /* Set */, (byte)index, (byte)speed });
                }
            }
        }
        else
        {
            throw new NotImplementedException();
        }
    }

    public void Update()
    {
        Update(null);
    }

    /// <inheritdoc />
    public void Close()
    { }

    private unsafe void Update(StringBuilder stringBuilder)
    {
        _fans.Clear();
        _temperatures.Clear();
        _voltages.Clear();
        _controls.Clear();

        if (_sdrs.Count == 0 || stringBuilder != null)
        {
            byte[] sdrInfo = RunIPMICommand(COMMAND_GET_SDR_REPOSITORY_INFO, NETWORK_FUNCTION_STORAGE, new byte[] { });
            if (sdrInfo?[0] == 0)
            {
                int recordCount = (sdrInfo[3] * 256) + sdrInfo[2];

                byte recordLower = 0;
                byte recordUpper = 0;
                for (int i = 0; i < recordCount; ++i)
                {
                    byte[] sdrRaw = RunIPMICommand(COMMAND_GET_SDR, NETWORK_FUNCTION_STORAGE, new byte[] { 0, 0, recordLower, recordUpper, 0, 0xff });
                    if (sdrRaw?.Length >= 3 && sdrRaw[0] == 0)
                    {
                        recordLower = sdrRaw[1];
                        recordUpper = sdrRaw[2];

                        fixed (byte* pSdr = sdrRaw)
                        {
                            Interop.Ipmi.Sdr sdr = (Interop.Ipmi.Sdr)Marshal.PtrToStructure((IntPtr)pSdr + 3, typeof(Interop.Ipmi.Sdr));
                            _sdrs.Add(sdr);
                            stringBuilder?.AppendLine("IPMI sensor " + i + " num: " + sdr.sens_num + " info: " + BitConverter.ToString(sdrRaw).Replace("-", ""));
                        }
                    }
                    else
                    {
                        break;
                    }
                }
            }
        }

        foreach (Interop.Ipmi.Sdr sdr in _sdrs)
        {
            if (sdr.rectype == 1)
            {
                byte[] reading = RunIPMICommand(COMMAND_GET_SENSOR_READING, NETWORK_FUNCTION_SENSOR_EVENT, new[] { sdr.sens_num });
                if (reading?.Length > 1 && reading[0] == 0)
                {
                    switch (sdr.sens_type)
                    {
                        case 1:
                            _temperatures.Add(RawToFloat(reading[1], sdr));
                            if (Temperatures == null || Temperatures.Length == 0)
                                _temperatureNames.Add(sdr.id_string.Replace(" Temp", ""));

                            break;

                        case 2:
                            _voltages.Add(RawToFloat(reading[1], sdr));
                            if (Voltages == null || Voltages.Length == 0)
                                _voltageNames.Add(sdr.id_string);

                            break;

                        case 4:
                            _fans.Add(RawToFloat(reading[1], sdr));
                            if (Fans == null || Fans.Length == 0)
                                _fanNames.Add(sdr.id_string);

                            break;
                    }

                    stringBuilder?.AppendLine("IPMI sensor num: " + sdr.sens_num + " reading: " + BitConverter.ToString(reading).Replace("-", ""));
                }
            }
        }

        if (_manufacturer == Manufacturer.Supermicro)
        {
            for (int i = 0; i < _controlNames.Count; ++i)
            {
                byte[] fanLevel = RunIPMICommand(COMMAND_FAN_LEVEL, NETWORK_FUNCTION_SUPERMICRO, new byte[] { 0x66, 0x00 /* Get */, (byte)i });
                if (fanLevel?.Length >= 2 && fanLevel[0] == 0)
                {
                    _controls.Add(fanLevel[1]);

                    stringBuilder?.AppendLine("IPMI fan " + i + ": " + BitConverter.ToString(fanLevel).Replace("-", ""));
                }
            }
        }

        if (Temperatures != null)
        {
            for (int i = 0; i < Math.Min(_temperatures.Count, Temperatures.Length); ++i)
                Temperatures[i] = _temperatures[i];
        }

        if (Voltages != null)
        {
            for (int i = 0; i < Math.Min(_voltages.Count, Voltages.Length); ++i)
                Voltages[i] = _voltages[i];
        }

        if (Fans != null)
        {
            for (int i = 0; i < Math.Min(_fans.Count, Fans.Length); ++i)
                Fans[i] = _fans[i];
        }

        if (Controls != null)
        {
            for (int i = 0; i < Math.Min(_controls.Count, Controls.Length); ++i)
                Controls[i] = _controls[i];
        }
    }

    public IEnumerable<Temperature> GetTemperatures()
    {
        for (int i = 0; i < _temperatureNames.Count; i++)
            yield return new Temperature(_temperatureNames[i], i);
    }

    public IEnumerable<Fan> GetFans()
    {
        for (int i = 0; i < _fanNames.Count; i++)
            yield return new Fan(_fanNames[i], i);
    }

    public IEnumerable<Voltage> GetVoltages()
    {
        for (int i = 0; i < _voltageNames.Count; i++)
            yield return new Voltage(_voltageNames[i], i);
    }

    public IEnumerable<Control> GetControls()
    {
        for (int i = 0; i < _controlNames.Count; i++)
            yield return new Control(_controlNames[i], i);
    }

    public static bool IsBmcPresent()
    {
        try
        {
            using ManagementObjectSearcher searcher = new("root\\WMI", "SELECT * FROM Microsoft_IPMI WHERE Active='True'");
            return searcher.Get().Count > 0;
        }
        catch
        {
            return false;
        }
    }

    public byte? ReadGpio(int index)
    {
        return null;
    }

    public void WriteGpio(int index, byte value)
    { }

    private byte[] RunIPMICommand(byte command, byte networkFunction, byte[] requestData)
    {
        using ManagementBaseObject inParams = _ipmi.GetMethodParameters("RequestResponse");

        inParams["NetworkFunction"] = networkFunction;
        inParams["Lun"] = 0;
        inParams["ResponderAddress"] = 0x20;
        inParams["Command"] = command;
        inParams["RequestDataSize"] = requestData.Length;
        inParams["RequestData"] = requestData;

        using ManagementBaseObject outParams = _ipmi.InvokeMethod("RequestResponse", inParams, null);
        return (byte[])outParams["ResponseData"];
    }

    // Ported from ipmiutil
    // Bare minimum to read Supermicro X13 IPMI sensors, may need expanding for other boards
    private static float RawToFloat(byte sensorReading, Interop.Ipmi.Sdr sdr)
    {
        double reading = sensorReading;

        int m = sdr.m + ((sdr.m_t & 0xc0) << 2);
        if (Convert.ToBoolean(m & 0x0200))
            m -= 0x0400;

        int b = sdr.b + ((sdr.b_a & 0xc0) << 2);
        if (Convert.ToBoolean(b & 0x0200))
            b -= 0x0400;

        int rx = (sdr.rx_bx & 0xf0) >> 4;
        if (Convert.ToBoolean(rx & 0x08))
            rx -= 0x10;

        int bExp = sdr.rx_bx & 0x0f;
        if (Convert.ToBoolean(bExp & 0x08))
            bExp -= 0x10;

        if ((sdr.sens_units & 0xc0) != 0)
            reading = Convert.ToBoolean(sensorReading & 0x80) ? sensorReading - 0x100 : sensorReading;

        reading *= m;
        reading += b * Math.Pow(10, bExp);
        reading *= Math.Pow(10, rx);

        if (sdr.linear != 0)
            throw new NotImplementedException();

        return (float)reading;
    }
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/IsaBridgeGigabyteController.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Threading;
using LibreHardwareMonitor.PawnIo;

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc;

/// <summary>
/// This is a controller present on some Gigabyte motherboards for both Intel and AMD, that is in custom firmware
/// loaded onto the 2nd ITE EC.
/// It can be accessed by using memory mapped IO, mapping its internal RAM onto main RAM via the ISA Bridge.
/// This class can disable it so that the regular IT87XX code can drive the fans.
/// </summary>
internal class IsaBridgeGigabyteController : IGigabyteController
{
    private readonly IsaBridgeEc _isaBridgeEc;
    private readonly MMIOMapping _mmio;
    private bool? _enabled;
    private bool? _restoreEnabled;
    private const int ControllerEnableRegister = 0x47;
    private const uint ControllerFanControlArea = 0x900;

    private IsaBridgeGigabyteController(IsaBridgeEc isaBridgeEc, MMIOMapping mmio)
    {
        _isaBridgeEc = isaBridgeEc;
        _mmio = mmio;
    }

    public static bool TryCreate(out IsaBridgeGigabyteController isaBridgeGigabyteController)
    {
        isaBridgeGigabyteController = null;
        IsaBridgeEc _isaBridgeEc = new IsaBridgeEc();

        // find
        if (!_isaBridgeEc.FindSuperIoMMIO(out _, out MMIOMapping secondMmio))
        {
            _isaBridgeEc.Close();
            return false;
        }

        if (!_isaBridgeEc.GetOriginalState(out MMIOState originalState))
        {
            _isaBridgeEc.Close();
            return false;
        }

        if (!EnterMmio(_isaBridgeEc, originalState))
        {
            _isaBridgeEc.Close();
            return false;
        }

        // if we get 0xFF, we can't use the IsaBridgeGigabyteController
        if (!_isaBridgeEc.ReadMmio(
            superIoIndex: secondMmio.Index,
            offset: ControllerFanControlArea + ControllerEnableRegister,
            size: 1,
            value: out byte readvaluebyte) ||
            readvaluebyte == 0xFF)
        {
            _isaBridgeEc.Close();
            return false;
        }

        if (!ExitMmio(_isaBridgeEc))
        {
            _isaBridgeEc.Close();
            return false;
        }

        isaBridgeGigabyteController = new IsaBridgeGigabyteController(_isaBridgeEc, secondMmio);

        return true;
    }

    /// <summary>
    /// Enable/Disable Fan Control
    /// </summary>
    /// <param name="enabled"></param>
    /// <returns>true on success</returns>
    public bool Enable(bool enabled)
    {
        bool isEntered = false;

        // use try finally + isEntered to get a safe
        // EnterMmio and ExitMmio pattern
        try
        {
            // get initial state if missing
            if (_enabled is null)
            {
                isEntered = EnterMmio(_isaBridgeEc);
                if (!isEntered)
                {
                    return false;
                }

                if (!_isaBridgeEc.ReadMmio(
                      superIoIndex: _mmio.Index,
                      offset: ControllerFanControlArea + ControllerEnableRegister,
                      size: 1,
                      value: out byte readvaluebyte))
                {
                    return false;
                }

                bool readValue = Convert.ToBoolean(readvaluebyte);
                _restoreEnabled ??= readValue;
                _enabled = Convert.ToBoolean(readvaluebyte);
            }

            // if already enabled, return
            if (_enabled == enabled)
            {
                return true;
            }

            if (!isEntered)
            {
                // we didn't enter in the initial state block, enter now
                isEntered = EnterMmio(_isaBridgeEc);
                if (!isEntered)
                {
                    return false;
                }
            }

            // write the value
            byte writeValue = Convert.ToByte(enabled);
            if (!_isaBridgeEc.WriteMmio(
                superIoIndex: _mmio.Index,
                offset: ControllerFanControlArea + ControllerEnableRegister,
                size: 1,
                value: writeValue))
            {
                return false;
            }

            Thread.Sleep(500);

            _enabled = enabled;

            return true;
        }
        finally
        {
            // safe exit from any return above
            if (isEntered)
            {
                ExitMmio(_isaBridgeEc);
            }
        }
    }

    /// <summary>
    /// Restore settings back to initial values
    /// </summary>
    public void Restore()
    {
        if (_restoreEnabled is null)
        {
            return;
        }

        Enable(_restoreEnabled.Value);
    }

    public void Dispose()
    {
        Restore();
        _isaBridgeEc.Close();
    }

    private static bool EnterMmio(IsaBridgeEc isaBridgeEc, MMIOState? currentState = null)
    {
        if (!isaBridgeEc.Map())
        {
            return false;
        }

        if (currentState is null || (currentState != MMIOState.MMIO_Enabled4E && currentState != MMIOState.MMIO_EnabledBoth))
        {
            if (!isaBridgeEc.TrySetState(MMIOState.MMIO_Enabled4E))
            {
                isaBridgeEc.Unmap();
                return false;
            }
        }

        return true;
    }

    private static bool ExitMmio(IsaBridgeEc isaBridgeEc)
    {
        if (!isaBridgeEc.TrySetState(MMIOState.MMIO_Original))
        {
            return false;
        }

        if (!isaBridgeEc.Unmap())
        {
            return false;
        }

        return true;
    }
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/LMSensors.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text;

// ReSharper disable once InconsistentNaming

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc;

internal class LMSensors
{
    private const string HwMonPath = "/sys/class/hwmon/";
    private readonly List<ISuperIO> _superIOs = [];

    public LMSensors()
    {
        if (!Directory.Exists(HwMonPath))
            return;

        foreach (string basePath in Directory.GetDirectories(HwMonPath))
        {
            foreach (string devicePath in new[] { "/device", string.Empty })
            {
                string path = basePath + devicePath;
                string name = null;

                try
                {
                    using StreamReader reader = new(path + "/name");
                    name = reader.ReadLine();
                }
                catch (IOException)
                { }

                switch (name)
                {
                    case "atk0110":
                        _superIOs.Add(new LMChip(Chip.ATK0110, path));
                        break;

                    case "f71858fg":
                        _superIOs.Add(new LMChip(Chip.F71858, path));
                        break;
                    case "f71862fg":
                        _superIOs.Add(new LMChip(Chip.F71862, path));
                        break;
                    case "f71869":
                        _superIOs.Add(new LMChip(Chip.F71869, path));
                        break;
                    case "f71869a":
                        _superIOs.Add(new LMChip(Chip.F71869A, path));
                        break;
                    case "f71882fg":
                        _superIOs.Add(new LMChip(Chip.F71882, path));
                        break;
                    case "f71889a":
                        _superIOs.Add(new LMChip(Chip.F71889AD, path));
                        break;
                    case "f71878ad":
                        _superIOs.Add(new LMChip(Chip.F71878AD, path));
                        break;
                    case "f71889ed":
                        _superIOs.Add(new LMChip(Chip.F71889ED, path));
                        break;
                    case "f71889fg":
                        _superIOs.Add(new LMChip(Chip.F71889F, path));
                        break;
                    case "f71808e":
                        _superIOs.Add(new LMChip(Chip.F71808E, path));
                        break;

                    case "it8705":
                        _superIOs.Add(new LMChip(Chip.IT8705F, path));
                        break;
                    case "it8712":
                        _superIOs.Add(new LMChip(Chip.IT8712F, path));
                        break;
                    case "it8716":
                        _superIOs.Add(new LMChip(Chip.IT8716F, path));
                        break;
                    case "it8718":
                        _superIOs.Add(new LMChip(Chip.IT8718F, path));
                        break;
                    case "it8720":
                        _superIOs.Add(new LMChip(Chip.IT8720F, path));
                        break;

                    case "nct6775":
                        _superIOs.Add(new LMChip(Chip.NCT6771F, path));
                        break;
                    case "nct6776":
                        _superIOs.Add(new LMChip(Chip.NCT6776F, path));
                        break;
                    case "nct6779":
                        _superIOs.Add(new LMChip(Chip.NCT6779D, path));
                        break;
                    case "nct6791":
                        _superIOs.Add(new LMChip(Chip.NCT6791D, path));
                        break;
                    case "nct6792":
                        _superIOs.Add(new LMChip(Chip.NCT6792D, path));
                        break;
                    case "nct6793":
                        _superIOs.Add(new LMChip(Chip.NCT6793D, path));
                        break;
                    case "nct6795":
                        _superIOs.Add(new LMChip(Chip.NCT6795D, path));
                        break;
                    case "nct6796":
                        _superIOs.Add(new LMChip(Chip.NCT6796D, path));
                        break;
                    case "nct6797":
                        _superIOs.Add(new LMChip(Chip.NCT6797D, path));
                        break;
                    case "nct6798":
                        _superIOs.Add(new LMChip(Chip.NCT6798D, path));
                        break;
                    case "nct6799":
                        _superIOs.Add(new LMChip(Chip.NCT6799D, path));
                        break;

                    case "w83627ehf":
                        _superIOs.Add(new LMChip(Chip.W83627EHF, path));
                        break;
                    case "w83627dhg":
                        _superIOs.Add(new LMChip(Chip.W83627DHG, path));
                        break;
                    case "w83667hg":
                        _superIOs.Add(new LMChip(Chip.W83667HG, path));
                        break;
                    case "w83627hf":
                        _superIOs.Add(new LMChip(Chip.W83627HF, path));
                        break;
                    case "w83627thf":
                        _superIOs.Add(new LMChip(Chip.W83627THF, path));
                        break;
                    case "w83687thf":
                        _superIOs.Add(new LMChip(Chip.W83687THF, path));
                        break;
                }
            }
        }
    }

    public IReadOnlyList<ISuperIO> SuperIO
    {
        get { return _superIOs; }
    }

    public void Close()
    {
        foreach (ISuperIO superIO in _superIOs)
        {
            if (superIO is LMChip lmChip)
                lmChip.Close();
        }
    }

    private class LMChip : ISuperIO
    {
        private readonly FileStream[] _fanStreams;
        private readonly FileStream[] _temperatureStreams;

        private readonly FileStream[] _voltageStreams;
        private string _path;

        public LMChip(Chip chip, string path)
        {
            _path = path;
            Chip = chip;

            string[] voltagePaths = Directory.GetFiles(path, "in*_input");
            Voltages = new float?[voltagePaths.Length];
            _voltageStreams = new FileStream[voltagePaths.Length];
            for (int i = 0; i < voltagePaths.Length; i++)
                _voltageStreams[i] = new FileStream(voltagePaths[i], FileMode.Open, FileAccess.Read, FileShare.ReadWrite);

            string[] temperaturePaths = Directory.GetFiles(path, "temp*_input");
            Temperatures = new float?[temperaturePaths.Length];
            _temperatureStreams = new FileStream[temperaturePaths.Length];
            for (int i = 0; i < temperaturePaths.Length; i++)
                _temperatureStreams[i] = new FileStream(temperaturePaths[i], FileMode.Open, FileAccess.Read, FileShare.ReadWrite);

            string[] fanPaths = Directory.GetFiles(path, "fan*_input");
            Fans = new float?[fanPaths.Length];
            _fanStreams = new FileStream[fanPaths.Length];
            for (int i = 0; i < fanPaths.Length; i++)
                _fanStreams[i] = new FileStream(fanPaths[i], FileMode.Open, FileAccess.Read, FileShare.ReadWrite);

            Controls = Array.Empty<float?>();
        }

        public Chip Chip { get; }

        public float?[] Controls { get; }

        public float?[] Fans { get; }

        public float?[] Temperatures { get; }

        public float?[] Voltages { get; }

        public byte? ReadGpio(int index)
        {
            return null;
        }

        public void WriteGpio(int index, byte value)
        { }

        public string GetReport()
        {
            return null;
        }

        public void SetControl(int index, byte? value)
        { }

        public void Update()
        {
            for (int i = 0; i < Voltages.Length; i++)
            {
                string s = ReadFirstLine(_voltageStreams[i]);
                try
                {
                    Voltages[i] = 0.001f *
                                  long.Parse(s, CultureInfo.InvariantCulture);
                }
                catch
                {
                    Voltages[i] = null;
                }
            }

            for (int i = 0; i < Temperatures.Length; i++)
            {
                string s = ReadFirstLine(_temperatureStreams[i]);
                try
                {
                    Temperatures[i] = 0.001f *
                                      long.Parse(s, CultureInfo.InvariantCulture);
                }
                catch
                {
                    Temperatures[i] = null;
                }
            }

            for (int i = 0; i < Fans.Length; i++)
            {
                string s = ReadFirstLine(_fanStreams[i]);
                try
                {
                    Fans[i] = long.Parse(s, CultureInfo.InvariantCulture);
                }
                catch
                {
                    Fans[i] = null;
                }
            }
        }

        private static string ReadFirstLine(Stream stream)
        {
            StringBuilder sb = new();
            try
            {
                stream.Seek(0, SeekOrigin.Begin);
                int b = stream.ReadByte();
                while (b is not -1 and not 10)
                {
                    sb.Append((char)b);
                    b = stream.ReadByte();
                }
            }
            catch
            { }

            return sb.ToString();
        }

        public void Close()
        {
            foreach (FileStream stream in _voltageStreams)
                stream.Close();

            foreach (FileStream stream in _temperatureStreams)
                stream.Close();

            foreach (FileStream stream in _fanStreams)
                stream.Close();
        }
    }
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/LpcIO.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using System.Threading;
using LibreHardwareMonitor.Hardware.Cpu;

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc;

internal class LpcIO
{
    private readonly StringBuilder _report = new();
    private readonly List<ISuperIO> _superIOs = new();

    public LpcIO(Motherboard motherboard)
    {
        if (!Mutexes.WaitIsaBus(100))
            return;

        Detect(motherboard);

        Mutexes.ReleaseIsaBus();

        if (Ipmi.IsBmcPresent())
            _superIOs.Add(new Ipmi(motherboard.Manufacturer));
    }

    public ISuperIO[] SuperIO => _superIOs.ToArray();

    private void ReportUnknownChip(LpcPort port, string type, int chip)
    {
        _report.Append("Chip ID: Unknown ");
        _report.Append(type);
        _report.Append(" with ID 0x");
        _report.Append(chip.ToString("X", CultureInfo.InvariantCulture));
        _report.Append(" at 0x");
        _report.Append(port.RegisterPort.ToString("X", CultureInfo.InvariantCulture));
        _report.Append("/0x");
        _report.AppendLine(port.ValuePort.ToString("X", CultureInfo.InvariantCulture));
        _report.AppendLine();
    }

    private bool DetectSmsc(LpcPort port)
    {
        port.SmscEnter();

        ushort chipId = port.ReadWord(CHIP_ID_REGISTER);

        if (chipId is not 0 and not 0xffff)
        {
            port.FindBars();
            port.SmscExit();
            ReportUnknownChip(port, "SMSC", chipId);
        }

        return false;
    }

    private void Detect(Motherboard motherboard)
    {
        for (int i = 0; i < REGISTER_PORTS.Length; i++)
        {
            var port = new LpcPort(REGISTER_PORTS[i], VALUE_PORTS[i]);

            if (DetectWinbondFintek(port, motherboard))
                continue;

            if (DetectIT87(port, motherboard))
                continue;

            if (DetectSmsc(port))
                continue;

            port.Close();
        }
    }

    public string GetReport()
    {
        if (_report.Length > 0)
        {
            return "LpcIO" + Environment.NewLine + Environment.NewLine + _report;
        }

        return null;
    }

    public void Close()
    {
        foreach (ISuperIO superIO in _superIOs)
            superIO.Close();
    }

    private bool DetectWinbondFintek(LpcPort port, Motherboard motherboard)
    {
        port.WinbondNuvotonFintekEnter();

        byte logicalDeviceNumber = 0;
        byte id = port.ReadByte(CHIP_ID_REGISTER);
        byte revision = port.ReadByte(CHIP_REVISION_REGISTER);
        Chip chip = Chip.Unknown;

        switch (id)
        {
            case 0x05:
                switch (revision)
                {
                    case 0x07:
                        chip = Chip.F71858;
                        logicalDeviceNumber = F71858_HARDWARE_MONITOR_LDN;
                        break;
                    case 0x41:
                        chip = Chip.F71882;
                        logicalDeviceNumber = FINTEK_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0x06:
                switch (revision)
                {
                    case 0x01:
                        chip = Chip.F71862;
                        logicalDeviceNumber = FINTEK_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0x07:
                switch (revision)
                {
                    case 0x23:
                        chip = Chip.F71889F;
                        logicalDeviceNumber = FINTEK_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0x08:
                switch (revision)
                {
                    case 0x14:
                        chip = Chip.F71869;
                        logicalDeviceNumber = FINTEK_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0x09:
                switch (revision)
                {
                    case 0x01:
                        chip = Chip.F71808E;
                        logicalDeviceNumber = FINTEK_HARDWARE_MONITOR_LDN;
                        break;
                    case 0x09:
                        chip = Chip.F71889ED;
                        logicalDeviceNumber = FINTEK_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0x10:
                switch (revision)
                {
                    case 0x05:
                        chip = Chip.F71889AD;
                        logicalDeviceNumber = FINTEK_HARDWARE_MONITOR_LDN;
                        break;
                    case 0x07:
                        chip = Chip.F71869A;
                        logicalDeviceNumber = FINTEK_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0x11:
                switch (revision)
                {
                    case 0x06:
                        chip = Chip.F71878AD;
                        logicalDeviceNumber = FINTEK_HARDWARE_MONITOR_LDN;
                        break;
                    case 0x18:
                        chip = Chip.F71811;
                        logicalDeviceNumber = FINTEK_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0x52:
                switch (revision)
                {
                    case 0x17:
                    case 0x3A:
                    case 0x41:
                        chip = Chip.W83627HF;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0x82:
                switch (revision & 0xF0)
                {
                    case 0x80:
                        chip = Chip.W83627THF;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0x85:
                switch (revision)
                {
                    case 0x41:
                        chip = Chip.W83687THF;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0x88:
                switch (revision & 0xF0)
                {
                    case 0x50:
                    case 0x60:
                        chip = Chip.W83627EHF;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0xA0:
                switch (revision & 0xF0)
                {
                    case 0x20:
                        chip = Chip.W83627DHG;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0xA5:
                switch (revision & 0xF0)
                {
                    case 0x10:
                        chip = Chip.W83667HG;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0xB0:
                switch (revision & 0xF0)
                {
                    case 0x70:
                        chip = Chip.W83627DHGP;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0xB3:
                switch (revision & 0xF0)
                {
                    case 0x50:
                        chip = Chip.W83667HGB;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0xB4:
                switch (revision & 0xF0)
                {
                    case 0x70:
                        chip = Chip.NCT6771F;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0xC3:
                switch (revision & 0xF0)
                {
                    case 0x30:
                        chip = Chip.NCT6776F;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0xC4:
                switch (revision & 0xF0)
                {
                    case 0x50:
                        chip = Chip.NCT610XD;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0xC5:
                switch (revision & 0xF0)
                {
                    case 0x60:
                        chip = Chip.NCT6779D;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0xC7:
                switch (revision)
                {
                    case 0x32:
                        chip = Chip.NCT6683D;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0xC8:
                switch (revision)
                {
                    case 0x03:
                        chip = Chip.NCT6791D;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0xC9:
                switch (revision)
                {
                    case 0x11:
                        chip = Chip.NCT6792D;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                    case 0x13:
                        chip = Chip.NCT6792DA;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0xD1:
                switch (revision)
                {
                    case 0x21:
                        chip = Chip.NCT6793D;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0xD3:
                switch (revision)
                {
                    case 0x52:
                        chip = Chip.NCT6795D;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0xD4:
                switch (revision)
                {
                    case 0x23:
                        chip = Chip.NCT6796D;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                    case 0x2A:
                        switch (motherboard.Model)
                        {
                            case Model.X870E_NOVA_WIFI:
                                chip = Chip.NCT5585D;
                                break;
                            default:
                                chip = Chip.NCT6796DR;
                                break;
                        }
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                    case 0x51:
                        chip = Chip.NCT6797D;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                    case 0x2B:
                        chip = Chip.NCT6798D;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                    case 0x40:
                    case 0x41:
                        chip = Chip.NCT6686D;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0xD5:
                switch (revision)
                {
                    case 0x92:
                        // MSI AM5/LGA1851 800 Series Motherboard Compatibility (Nuvoton NCT6687DR)
                        if (motherboard.Manufacturer == Manufacturer.MSI && (motherboard.SMBios.Board.ProductName.ToString().Contains("B840", StringComparison.OrdinalIgnoreCase) ||
                            motherboard.SMBios.Board.ProductName.ToString().Contains("B850", StringComparison.OrdinalIgnoreCase) ||
                            motherboard.SMBios.Board.ProductName.ToString().Contains("X870", StringComparison.OrdinalIgnoreCase) ||
                            motherboard.SMBios.Board.ProductName.ToString().Contains("Z890", StringComparison.OrdinalIgnoreCase)))
                        {
                            chip = Chip.NCT6687DR;
                        }
                        else
                        {
                            chip = Chip.NCT6687D; 
                        }

                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
            case 0xD8:
                switch (revision)
                {
                    case 0x02:
                        switch (motherboard.Model)
                        {
                            case Model.X870E_NOVA_WIFI:
                                chip = Chip.NCT6796DS;
                                break;
                            default:
                                chip = Chip.NCT6799D;
                                break;
                        }

                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                    case 0x06:
                        chip = Chip.NCT6701D;
                        logicalDeviceNumber = WINBOND_NUVOTON_HARDWARE_MONITOR_LDN;
                        break;
                }

                break;
        }

        if (chip == Chip.Unknown)
        {
            if (id is not 0 and not 0xff)
            {
                port.WinbondNuvotonFintekExit();
                ReportUnknownChip(port, "Winbond / Nuvoton / Fintek", (id << 8) | revision);
            }
        }
        else
        {
            port.FindBars();
            port.Select(logicalDeviceNumber);
            ushort address = port.ReadWord(BASE_ADDRESS_REGISTER);
            Thread.Sleep(1);
            ushort verify = port.ReadWord(BASE_ADDRESS_REGISTER);

            ushort vendorId = port.ReadWord(FINTEK_VENDOR_ID_REGISTER);

            // disable the hardware monitor i/o space lock on NCT679XD chips
            if (address == verify &&
                chip is Chip.NCT6791D or Chip.NCT6792D or Chip.NCT6792DA or Chip.NCT6793D or Chip.NCT6795D or Chip.NCT6796D or Chip.NCT6796DR or Chip.NCT6796DS or Chip.NCT6798D or Chip.NCT6797D or Chip.NCT6799D or Chip.NCT6701D)
            {
                port.NuvotonDisableIOSpaceLock();
            }

            port.WinbondNuvotonFintekExit();

            if (address != verify)
            {
                _report.Append("Chip ID: 0x");
                _report.AppendLine(chip.ToString("X"));
                _report.Append("Chip revision: 0x");
                _report.AppendLine(revision.ToString("X", CultureInfo.InvariantCulture));
                _report.AppendLine("Error: Address verification failed");
                _report.AppendLine();

                return false;
            }

            // some Fintek chips have address register offset 0x05 added already
            if ((address & 0x07) == 0x05)
                address &= 0xFFF8;

            if (address < 0x100 || (address & 0xF007) != 0)
            {
                _report.Append("Chip ID: 0x");
                _report.AppendLine(chip.ToString("X"));
                _report.Append("Chip revision: 0x");
                _report.AppendLine(revision.ToString("X", CultureInfo.InvariantCulture));
                _report.Append("Error: Invalid address 0x");
                _report.AppendLine(address.ToString("X", CultureInfo.InvariantCulture));
                _report.AppendLine();

                return false;
            }

            switch (chip)
            {
                case Chip.W83627DHG:
                case Chip.W83627DHGP:
                case Chip.W83627EHF:
                case Chip.W83627HF:
                case Chip.W83627THF:
                case Chip.W83667HG:
                case Chip.W83667HGB:
                case Chip.W83687THF:
                    _superIOs.Add(new W836XX(port, chip, revision, address));
                    break;

                case Chip.NCT610XD:
                case Chip.NCT6771F:
                case Chip.NCT6776F:
                case Chip.NCT6779D:
                case Chip.NCT6791D:
                case Chip.NCT6792D:
                case Chip.NCT6792DA:
                case Chip.NCT6793D:
                case Chip.NCT6795D:
                case Chip.NCT6796D:
                case Chip.NCT6796DR:
                case Chip.NCT6796DS:
                case Chip.NCT6797D:
                case Chip.NCT6798D:
                case Chip.NCT6799D:
                case Chip.NCT6686D:
                case Chip.NCT6687D:
                case Chip.NCT6687DR:
                case Chip.NCT6683D:
                case Chip.NCT6701D:
                case Chip.NCT5585D:
                    _superIOs.Add(new Nct677X(port, chip, revision, address));
                    break;

                case Chip.F71858:
                case Chip.F71862:
                case Chip.F71869:
                case Chip.F71878AD:
                case Chip.F71869A:
                case Chip.F71882:
                case Chip.F71889AD:
                case Chip.F71889ED:
                case Chip.F71889F:
                case Chip.F71808E:
                    if (vendorId != FINTEK_VENDOR_ID)
                    {
                        _report.Append("Chip ID: 0x");
                        _report.AppendLine(chip.ToString("X"));
                        _report.Append("Chip revision: 0x");
                        _report.AppendLine(revision.ToString("X", CultureInfo.InvariantCulture));
                        _report.Append("Error: Invalid vendor ID 0x");
                        _report.AppendLine(vendorId.ToString("X", CultureInfo.InvariantCulture));
                        _report.AppendLine();

                        return false;
                    }

                    _superIOs.Add(new F718XX(port, chip, address));
                    break;
            }

            return true;
        }

        return false;
    }

    private bool DetectIT87(LpcPort port, Motherboard motherboard)
    {
        // IT87XX can enter only on port 0x2E
        // IT8792 using 0x4E
        if (port.RegisterPort is not 0x2E and not 0x4E)
            return false;

        // Read the chip ID before entering.
        // If already entered (not 0xFFFF) and the register port is 0x4E, it is most likely bugged and should be left alone.
        // Entering IT8792 in this state will result in IT8792 reporting with chip ID of 0x8883.
        if (port.RegisterPort != 0x4E || !port.TryReadWord(CHIP_ID_REGISTER, out ushort chipId))
        {
            port.IT87Enter();
            chipId = port.ReadWord(CHIP_ID_REGISTER);
        }

        Chip chip = chipId switch
        {
            0x8613 => Chip.IT8613E,
            0x8620 => Chip.IT8620E,
            0x8625 => Chip.IT8625E,
            0x8628 => Chip.IT8628E,
            0x8631 => Chip.IT8631E,
            0x8638 => Chip.IT8638E,
            0x8665 => Chip.IT8665E,
            0x8655 => Chip.IT8655E,
            0x8686 => Chip.IT8686E,
            0x8688 => Chip.IT8688E,
            0x8689 => Chip.IT8689E,
            0x8696 => Chip.IT8696E,
            0x8705 => Chip.IT8705F,
            0x8712 => Chip.IT8712F,
            0x8716 => Chip.IT8716F,
            0x8718 => Chip.IT8718F,
            0x8720 => Chip.IT8720F,
            0x8721 => Chip.IT8721F,
            0x8726 => Chip.IT8726F,
            0x8728 => Chip.IT8728F,
            0x8771 => Chip.IT8771E,
            0x8772 => Chip.IT8772E,
            0x8790 => Chip.IT8790E,
            0x8733 => Chip.IT8792E,
            0x8695 => Chip.IT87952E,
            _ => Chip.Unknown
        };

        if (chip == Chip.Unknown)
        {
            if (chipId is not 0 and not 0xffff)
            {
                port.IT87Exit();

                ReportUnknownChip(port, "ITE", chipId);
            }
        }
        else
        {
            port.FindBars();
            port.Select(IT87_ENVIRONMENT_CONTROLLER_LDN);

            ushort address = port.ReadWord(BASE_ADDRESS_REGISTER);
            Thread.Sleep(1);
            ushort verify = port.ReadWord(BASE_ADDRESS_REGISTER);

            byte version = (byte)(port.ReadByte(IT87_CHIP_VERSION_REGISTER) & 0x0F);

            ushort gpioAddress;
            ushort gpioVerify;

            if (chip == Chip.IT8705F)
            {
                port.Select(IT8705_GPIO_LDN);
                gpioAddress = port.ReadWord(BASE_ADDRESS_REGISTER);
                Thread.Sleep(1);
                gpioVerify = port.ReadWord(BASE_ADDRESS_REGISTER);
            }
            else
            {
                port.Select(IT87XX_GPIO_LDN);
                gpioAddress = port.ReadWord(BASE_ADDRESS_REGISTER + 2);
                Thread.Sleep(1);
                gpioVerify = port.ReadWord(BASE_ADDRESS_REGISTER + 2);
            }

            IGigabyteController gigabyteController = FindGigabyteEC(port, chip, motherboard);
            port.IT87Exit();

            if (address != verify || address < 0x100 || (address & 0xF007) != 0)
            {
                _report.Append("Chip ID: 0x");
                _report.AppendLine(chip.ToString("X"));
                _report.Append("Error: Invalid address 0x");
                _report.AppendLine(address.ToString("X", CultureInfo.InvariantCulture));
                _report.AppendLine();

                gigabyteController?.Dispose();

                return false;
            }

            if (gpioAddress != gpioVerify || gpioAddress < 0x100 || (gpioAddress & 0xF007) != 0)
            {
                _report.Append("Chip ID: 0x");
                _report.AppendLine(chip.ToString("X"));
                _report.Append("Error: Invalid GPIO address 0x");
                _report.AppendLine(gpioAddress.ToString("X", CultureInfo.InvariantCulture));
                _report.AppendLine();

                gigabyteController?.Dispose();

                return false;
            }

            _superIOs.Add(new IT87XX(port, chip, address, gpioAddress, version, motherboard, gigabyteController));

            return true;
        }

        return false;
    }

    private IGigabyteController FindGigabyteEC(LpcPort port, Chip chip, Motherboard motherboard)
    {
        // The controller only affects the 2nd ITE chip if present, and only a few
        // models are known to use this controller.
        // IT8795E likely to need this too, but may use different registers.
        if (motherboard.Manufacturer != Manufacturer.Gigabyte || port.RegisterPort != 0x4E || chip is not (Chip.IT8790E or Chip.IT8792E or Chip.IT87952E))
            return null;

        Vendor vendor = DetectVendor();

        IGigabyteController gigabyteController = FindGigabyteECUsingSmfi(port);
        if (gigabyteController != null)
            return gigabyteController;

        // ECIO is only available on AMD motherboards with IT8791E/IT8792E/IT8795E.
        if (chip == Chip.IT8792E && vendor == Vendor.AMD)
        {
            gigabyteController = EcioPortGigabyteController.TryCreate(port);
            if (gigabyteController != null)
                return gigabyteController;
        }

        return null;

        Vendor DetectVendor()
        {
            string manufacturer = motherboard.SMBios.Processors[0].ManufacturerName;
            if (manufacturer.IndexOf("Intel", StringComparison.OrdinalIgnoreCase) != -1)
                return Vendor.Intel;

            if (manufacturer.IndexOf("Advanced Micro Devices", StringComparison.OrdinalIgnoreCase) != -1 || manufacturer.StartsWith("AMD", StringComparison.OrdinalIgnoreCase))
                return Vendor.AMD;

            return Vendor.Unknown;
        }
    }

    private IGigabyteController FindGigabyteECUsingSmfi(LpcPort port)
    {
        const byte IT87_LD_ACTIVE_REGISTER = 0x30;
        const byte IT87XX_SMFI_LDN = 0x0F;

        port.Select(IT87XX_SMFI_LDN);

        // Check if the SMFI logical device is enabled
        byte enabled = port.ReadByte(IT87_LD_ACTIVE_REGISTER);
        Thread.Sleep(1);
        byte enabledVerify = port.ReadByte(IT87_LD_ACTIVE_REGISTER);

        // The EC has no SMFI or it's RAM access is not enabled, assume the controller is not present
        if (enabled != enabledVerify || enabled == 0)
            return null;

        return IsaBridgeGigabyteController.TryCreate(out IsaBridgeGigabyteController controller) ? controller : null;
    }

    // ReSharper disable InconsistentNaming
    private const byte BASE_ADDRESS_REGISTER = 0x60;
    private const byte CHIP_ID_REGISTER = 0x20;
    private const byte CHIP_REVISION_REGISTER = 0x21;

    private const byte F71858_HARDWARE_MONITOR_LDN = 0x02;
    private const byte FINTEK_HARDWARE_MONITOR_LDN = 0x04;
    private const byte IT87_ENVIRONMENT_CONTROLLER_LDN = 0x04;
    private const byte IT8705_GPIO_LDN = 0x05;
    private const byte IT87XX_GPIO_LDN = 0x07;

    // Shared Memory/Flash Interface
    private const byte WINBOND_NUVOTON_HARDWARE_MONITOR_LDN = 0x0B;

    private const ushort FINTEK_VENDOR_ID = 0x1934;

    private const byte FINTEK_VENDOR_ID_REGISTER = 0x23;
    private const byte IT87_CHIP_VERSION_REGISTER = 0x22;

    private readonly ushort[] REGISTER_PORTS = { 0x2E, 0x4E };

    private readonly ushort[] VALUE_PORTS = { 0x2F, 0x4F };
    // ReSharper restore InconsistentNaming
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/LpcPort.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc;

internal class LpcPort
{
    private PawnIo.LpcIo _pawnModule;

    public LpcPort(ushort registerPort, ushort valuePort)
    {
        RegisterPort = registerPort;
        ValuePort = valuePort;
        _pawnModule = new PawnIo.LpcIo();
        _pawnModule.SelectSlot(registerPort == 0x2e ? 0 : 1);
    }

    public ushort RegisterPort { get; }

    public ushort ValuePort { get; }

    public byte ReadIoPort(ushort port)
    {
        return _pawnModule.ReadPort(port);
    }

    public void WriteIoPort(ushort port, byte value)
    {
        _pawnModule.WritePort(port, value);
    }

    public byte ReadByte(byte register)
    {
        return _pawnModule.ReadByte(register);
    }

    public void WriteByte(byte register, byte value)
    {
        _pawnModule.WriteByte(register, value);
    }

    public ushort ReadWord(byte register)
    {
        return _pawnModule.ReadWord(register);
    }

    public bool TryReadWord(byte register, out ushort value)
    {
        value = ReadWord(register);
        return value != 0xFFFF;
    }

    public void FindBars()
    {
        _pawnModule.FindBars();
    }

    public void Select(byte logicalDeviceNumber)
    {
        WriteByte(DEVICE_SELECT_REGISTER, logicalDeviceNumber);
    }

    public void WinbondNuvotonFintekEnter()
    {
        _pawnModule.WritePort(RegisterPort, 0x87);
        _pawnModule.WritePort(RegisterPort, 0x87);
    }

    public void WinbondNuvotonFintekExit()
    {
        _pawnModule.WritePort(RegisterPort, 0xAA);
    }

    public void NuvotonDisableIOSpaceLock()
    {
        byte options = ReadByte(NUVOTON_HARDWARE_MONITOR_IO_SPACE_LOCK);
        // if the i/o space lock is enabled
        if ((options & 0x10) > 0)
        {
            // disable the i/o space lock
            WriteByte(NUVOTON_HARDWARE_MONITOR_IO_SPACE_LOCK, (byte)(options & ~0x10));
        }
    }

    public void IT87Enter()
    {
        _pawnModule.WritePort(RegisterPort, 0x87);
        _pawnModule.WritePort(RegisterPort, 0x01);
        _pawnModule.WritePort(RegisterPort, 0x55);
        _pawnModule.WritePort(RegisterPort, RegisterPort == 0x4E ? (byte)0xAA : (byte)0x55);
    }

    public void IT87Exit()
    {
        // Do not exit config mode for secondary super IO.
        if (RegisterPort != 0x4E)
        {
            _pawnModule.WritePort(RegisterPort, CONFIGURATION_CONTROL_REGISTER);
            _pawnModule.WritePort(ValuePort, 0x02);
        }
    }

    public void SmscEnter()
    {
        _pawnModule.WritePort(RegisterPort, 0x55);
    }

    public void SmscExit()
    {
        _pawnModule.WritePort(RegisterPort, 0xAA);
    }

    public void Close() => _pawnModule.Close();

    // ReSharper disable InconsistentNaming
    private const byte CONFIGURATION_CONTROL_REGISTER = 0x02;
    private const byte DEVICE_SELECT_REGISTER = 0x07;
    private const byte NUVOTON_HARDWARE_MONITOR_IO_SPACE_LOCK = 0x28;
    // ReSharper restore InconsistentNaming
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/Nct677X.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

//#define NCT677X_DEBUG_LOG

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading;

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc;

internal class Nct677X : ISuperIO
{
    private readonly ushort[] _fanCountRegister;
    private readonly ushort[] _fanRpmRegister;
    private readonly byte[] _initialFanControlMode = new byte[7];
    private readonly byte[] _initialFanPwmCommand = new byte[7];
    private readonly bool _isNuvotonVendor;
    private readonly LpcPort _lpcPort;
    private readonly int _maxFanCount;
    private readonly int _minFanCount;
    private readonly int _minFanRpm;
    private readonly ushort _port;
    private readonly bool[] _restoreDefaultFanControlRequired = new bool[7];
    private readonly byte _revision;
    private readonly TemperatureSourceData[] _temperaturesSource;
    private readonly ushort _vBatMonitorControlRegister;
    private readonly ushort[] _voltageRegisters;
    private readonly ushort _voltageVBatRegister;

    public Nct677X(LpcPort lpcPort, Chip chip, byte revision, ushort port)
    {
        Chip = chip;
        _revision = revision;
        _port = port;
        _lpcPort = lpcPort;

        if (chip == Chip.NCT610XD)
        {
            VENDOR_ID_HIGH_REGISTER = 0x80FE;
            VENDOR_ID_LOW_REGISTER = 0x00FE;

            FAN_PWM_OUT_REG = [0x04A, 0x04B, 0x04C];
            FAN_PWM_COMMAND_REG = [0x119, 0x129, 0x139];
            FAN_CONTROL_MODE_REG = [0x113, 0x123, 0x133];

            _vBatMonitorControlRegister = 0x0318;
        }
        else if (chip is Chip.NCT6683D or Chip.NCT6686D
                 or Chip.NCT6687D) //These work on older NCT6687D boards, but only fans 0, 1 and 3 on newer (X870 and Z890) motherboards. Unsure of controls for "next pack of 8".
        {
            FAN_PWM_OUT_REG = [0x160, 0x161, 0x162, 0x163, 0x164, 0x165, 0x166, 0x167]; // Next 8 fans will be 0xE00, 0xE01, 0xE02, 0xE03, 0xE04, 0xE05, 0xE06, 0xE07
            FAN_PWM_COMMAND_REG = [0xA28, 0xA29, 0xA2A, 0xA2B, 0xA2C, 0xA2D, 0xA2E, 0xA2F]; // Possibly 0X260, 0X261, 0X262, 0X263, 0X264, 0X265, 0X266, 0X267 but can't confirm
            FAN_CONTROL_MODE_REG = [0xA00, 0xA00, 0xA00, 0xA00, 0xA00, 0xA00, 0xA00, 0xA00]; // Not sure of next 8, MSI won't provide info
            FAN_PWM_REQUEST_REG = [0xA01, 0xA01, 0xA01, 0xA01, 0xA01, 0xA01, 0xA01, 0xA01]; // Not sure of next 8, MSI won't provide info
        }
        else if (chip is Chip.NCT6687DR) // MSI AM5/LGA1851 Motherboards
        {
            // Each index in the below arrays represents a fan header
            // ARRAY_KEY = new ushort[] { CPU FAN, PUMP, CHIPSET, EZ-CONNECT FAN, null, null, null, null, null, SYSFAN7, SYSFAN1, SYSFAN2, SYSFAN3, SYSFAN4, SYSFAN5, SYSFAN6 };
            FAN_PWM_OUT_REG = [0x160, 0x161, 0x162, 0x163, 0x164, 0x165, 0x166, 0x167, 0xFFF, 0xC93, 0xE05, 0xE04, 0xE03, 0xE02, 0xE01, 0xE00]; // Duty Cycle Sensors
            FAN_PWM_COMMAND_REG = [0xA28, 0xA29, 0xA2A, 0xA2B, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xBE0, 0xC70, 0xC58, 0xC40, 0xC28, 0xC10, 0xBF8]; // Control Registers for CPU/Pump/EZ-Connect Fan, Initial Fan Curve Registers for System Fans
            FAN_CONTROL_MODE_REG = [0xA00, 0xA00, 0xA00, 0xA00, 0xA00, 0xA00, 0xA00, 0xA00, 0xA00, 0xA00, 0xA00, 0xA00, 0xA00, 0xA00, 0xA00, 0xA00];
            FAN_PWM_REQUEST_REG = [0xA01, 0xA01, 0xA01, 0xA01, 0xA01, 0xA01, 0xA01, 0xA01, 0xA01, 0xA01, 0xA01, 0xA01, 0xA01, 0xA01, 0xA01, 0xA01];
        }
        else
        {
            VENDOR_ID_HIGH_REGISTER = 0x804F;
            VENDOR_ID_LOW_REGISTER = 0x004F;

            FAN_PWM_OUT_REG = chip is Chip.NCT6797D or Chip.NCT6798D or Chip.NCT6799D or Chip.NCT6796DS or Chip.NCT5585D
                ? new ushort[] { 0x001, 0x003, 0x011, 0x013, 0x015, 0xA09, 0xB09 }
                : new ushort[] { 0x001, 0x003, 0x011, 0x013, 0x015, 0x017, 0x029 };

            FAN_PWM_COMMAND_REG = [0x109, 0x209, 0x309, 0x809, 0x909, 0xA09, 0xB09];
            FAN_CONTROL_MODE_REG = [0x102, 0x202, 0x302, 0x802, 0x902, 0xA02, 0xB02];

            _vBatMonitorControlRegister = 0x005D;
        }

        _isNuvotonVendor = IsNuvotonVendor();

        if (!_isNuvotonVendor)
            return;

        switch (chip)
        {
            case Chip.NCT6771F:
            case Chip.NCT6776F:
                if (chip == Chip.NCT6771F)
                {
                    Fans = new float?[4];

                    // min value RPM value with 16-bit fan counter
                    _minFanRpm = (int)(1.35e6 / 0xFFFF);
                }
                else
                {
                    Fans = new float?[5];

                    // min value RPM value with 13-bit fan counter
                    _minFanRpm = (int)(1.35e6 / 0x1FFF);
                }

                _fanRpmRegister = new ushort[5];
                for (int i = 0; i < _fanRpmRegister.Length; i++)
                    _fanRpmRegister[i] = (ushort)(0x656 + (i << 1));

                Controls = new float?[3];

                Voltages = new float?[9];
                _voltageRegisters = [0x020, 0x021, 0x022, 0x023, 0x024, 0x025, 0x026, 0x550, 0x551];
                _voltageVBatRegister = 0x551;
                _temperaturesSource = new TemperatureSourceData[]
                {
                    new(chip == Chip.NCT6771F ? SourceNct6771F.PECI_0 : SourceNct6776F.PECI_0, 0x027, 0, -1, 0x621),
                    new(chip == Chip.NCT6771F ? SourceNct6771F.CPUTIN : SourceNct6776F.CPUTIN, 0x073, 0x074, 7, 0x100),
                    new(chip == Chip.NCT6771F ? SourceNct6771F.AUXTIN : SourceNct6776F.AUXTIN, 0x075, 0x076, 7, 0x200),
                    new(chip == Chip.NCT6771F ? SourceNct6771F.SYSTIN : SourceNct6776F.SYSTIN, 0x077, 0x078, 7, 0x300),
                    new(null, 0x150, 0x151, 7, 0x622),
                    new(null, 0x250, 0x251, 7, 0x623),
                    new(null, 0x62B, 0x62E, 0, 0x624),
                    new(null, 0x62C, 0x62E, 1, 0x625),
                    new(null, 0x62D, 0x62E, 2, 0x626)
                };

                Temperatures = new float?[4];
                break;

            case Chip.NCT6779D: // 15 voltages
            case Chip.NCT6791D: // 15 voltages
            case Chip.NCT6792D:
            case Chip.NCT6792DA:
            case Chip.NCT6793D: // 14 voltages
            case Chip.NCT6795D:
            case Chip.NCT6796D: // 16 voltages
            case Chip.NCT6796DR: // 16 voltages
            case Chip.NCT6796DS:
            case Chip.NCT6797D:
            case Chip.NCT6798D:
            case Chip.NCT6799D:
            case Chip.NCT6701D:
            case Chip.NCT5585D:
                switch (chip)
                {
                    case Chip.NCT6779D:
                        Fans = new float?[5];
                        Controls = new float?[5];
                        break;

                    case Chip.NCT6796DR:
                    case Chip.NCT6796DS:
                    case Chip.NCT6797D:
                    case Chip.NCT6798D:
                    case Chip.NCT6799D:
                    case Chip.NCT6701D:
                    case Chip.NCT5585D:
                        Fans = new float?[7];
                        Controls = new float?[7];
                        break;

                    default:
                        Fans = new float?[6];
                        Controls = new float?[6];
                        break;
                }

                _fanCountRegister = [0x4B0, 0x4B2, 0x4B4, 0x4B6, 0x4B8, 0x4BA, 0x4CC];

                // max value for 13-bit fan counter
                _maxFanCount = 0x1FFF;

                // min value that could be transferred to 16-bit RPM registers
                _minFanCount = 0x15;

                Voltages = new float?[16];
                _voltageRegisters = [0x480, 0x481, 0x482, 0x483, 0x484, 0x485, 0x486, 0x487, 0x488, 0x489, 0x48A, 0x48B, 0x48C, 0x48D, 0x48E, 0x48F];
                _voltageVBatRegister = 0x488;
                var temperaturesSources = new List<TemperatureSourceData>();

                switch (chip)
                {
                    // --- GROUP A: NCT6793D/6795D (Common features, separated from 6796/98 by AUXTIN4/TSENSOR) ---
                    case Chip.NCT6793D:
                    case Chip.NCT6795D:
                    case Chip.NCT6791D: // Assuming 6791/92 use a similar core map but less features than 6795
                    case Chip.NCT6792D:
                    case Chip.NCT6701D: // Defaulting to this group if map is less feature-rich than 6796/98
                        temperaturesSources.AddRange(new TemperatureSourceData[]
                        {
                            // Note: Linux labels start at index 1 (0 is empty).
                            // Indices 1-6 are consistent (SYSTIN, CPUTIN, AUXTIN0-3)
                            new(SourceNct67Xxd.PECI_0, 0x073, 0x074, 7, 0x100),         // Index 0 in your list / PECI_0 is often 0x73 or 0x027
                            new(SourceNct67Xxd.CPUTIN, 0x075, 0x076, 7, 0x200, 0x491),  // Index 2 (CPUTIN)
                            new(SourceNct67Xxd.SYSTIN, 0x077, 0x078, 7, 0x300, 0x490),  // Index 1 (SYSTIN)
                            new(SourceNct67Xxd.AUXTIN0, 0x079, 0x07A, 7, 0x800, 0x492), // Index 3
                            new(SourceNct67Xxd.AUXTIN1, 0x07B, 0x07C, 7, 0x900, 0x493), // Index 4
                            new(SourceNct67Xxd.AUXTIN2, 0x07D, 0x07E, 7, 0xA00, 0x494), // Index 5
                            new(SourceNct67Xxd.AUXTIN3, 0x4A0, 0x49E, 6, 0xB00, 0x495), // Index 6
                
                            // AUXTIN4 (AUXTIN4 is missing or unnamed in 6793/6795 label array)
                            // Keeping AUXTIN4 here with original register mapping for compatibility, but moving down.
                            new(SourceNct67Xxd.AUXTIN4, 0x027, 0, -1, 0x621),

                            // PECI / PCH Group (Indices 16-25 in Linux labels)
                            new(SourceNct67Xxd.PECI_1, 0x672, 0, -1, 0xC27),
                            new(SourceNct67Xxd.PCH_CHIP_CPU_MAX_TEMP, 0x674, 0, -1, 0xC28, 0x400), // Index 18 (0x400 alt reg)
                            new(SourceNct67Xxd.PCH_CHIP_TEMP, 0x676, 0, -1, 0xC29, 0x401),         // Index 19 (0x401 alt reg)
                            new(SourceNct67Xxd.PCH_CPU_TEMP, 0x678, 0, -1, 0xC2A, 0x402),          // Index 20 (0x402 alt reg)
                            new(SourceNct67Xxd.PCH_MCH_TEMP, 0x67A, 0, -1, 0xC2B, 0x404),          // Index 21 (0x404 alt reg)
                            new(SourceNct67Xxd.AGENT0_DIMM0, 0x405, 0, -1),                        // Index 22 (0x405 alt reg)
                            new(SourceNct67Xxd.AGENT0_DIMM1, 0x406, 0, -1),                        // Index 23 (0x406 alt reg)
                            new(SourceNct67Xxd.AGENT1_DIMM0, 0x407, 0, -1),                        // Index 24 (0x407 alt reg)
                            new(SourceNct67Xxd.AGENT1_DIMM1, 0x408, 0, -1),                        // Index 25 (0x408 alt reg)

                            // SMBUS Group (Indices 8-9 are consistent)
                            new(SourceNct67Xxd.SMBUSMASTER0, 0x150, 0x151, 7, 0x622),              // Index 8
                            new(SourceNct67Xxd.SMBUSMASTER1, 0x670, 0, -1, 0xC26),                 // Index 9

                            // BYTE TEMP, CALIBRATION, and VIRTUAL (Indices 26-31)
                            new(SourceNct67Xxd.BYTE_TEMP0, 0x419, 0, -1), // Index 26
                            new(SourceNct67Xxd.BYTE_TEMP1, 0x41A, 0, -1), // Index 27
                            new(SourceNct67Xxd.PECI_0_CAL, 0x4F4, 0, -1), // Index 28
                            new(SourceNct67Xxd.PECI_1_CAL, 0x4F5, 0, -1), // Index 29
                            new(SourceNct67Xxd.VIRTUAL_TEMP, 0),          // Index 31
                            new(SourceNct67Xxd.SPARE_TEMP, 0),
                            new(SourceNct67Xxd.SPARE_TEMP2, 0)
                        });
                        break;

                    // --- GROUP B: NCT6796D/6797D (Introduces AUXTIN4) ---
                    case Chip.NCT6796D:
                    case Chip.NCT6796DR:
                    case Chip.NCT6797D:
                        temperaturesSources.AddRange(new TemperatureSourceData[]
                        {
                            // Indices 1-7 are consistent with 6796 labels (AUXTIN4 is Index 7)
                            new(SourceNct67Xxd.PECI_0, 0x073, 0x074, 7, 0x100),
                            new(SourceNct67Xxd.CPUTIN, 0x075, 0x076, 7, 0x200, 0x491),
                            new(SourceNct67Xxd.SYSTIN, 0x077, 0x078, 7, 0x300, 0x490),
                            new(SourceNct67Xxd.AUXTIN0, 0x079, 0x07A, 7, 0x800, 0x492),
                            new(SourceNct67Xxd.AUXTIN1, 0x07B, 0x07C, 7, 0x900, 0x493),
                            new(SourceNct67Xxd.AUXTIN2, 0x07D, 0x07E, 7, 0xA00, 0x494),
                            new(SourceNct67Xxd.AUXTIN3, 0x4A0, 0x49E, 6, 0xB00, 0x495),
                            new(SourceNct67Xxd.AUXTIN4, 0x027, 0, -1, 0x621), // Index 7

                            // SMBUS Group (Indices 8-9 are consistent)
                            new(SourceNct67Xxd.SMBUSMASTER0, 0x150, 0x151, 7, 0x622),
                            new(SourceNct67Xxd.SMBUSMASTER1, 0x670, 0, -1, 0xC26),

                            // PECI / PCH / DIMM Group (Indices 16-25)
                            new(SourceNct67Xxd.PECI_1, 0x672, 0, -1, 0xC27),
                            new(SourceNct67Xxd.PCH_CHIP_CPU_MAX_TEMP, 0x674, 0, -1, 0xC28, 0x400),
                            new(SourceNct67Xxd.PCH_CHIP_TEMP, 0x676, 0, -1, 0xC29, 0x401),
                            new(SourceNct67Xxd.PCH_CPU_TEMP, 0x678, 0, -1, 0xC2A, 0x402),
                            new(SourceNct67Xxd.PCH_MCH_TEMP, 0x67A, 0, -1, 0xC2B, 0x404),
                            new(SourceNct67Xxd.AGENT0_DIMM0, 0x405, 0, -1),
                            new(SourceNct67Xxd.AGENT0_DIMM1, 0x406, 0, -1),
                            new(SourceNct67Xxd.AGENT1_DIMM0, 0x407, 0, -1),
                            new(SourceNct67Xxd.AGENT1_DIMM1, 0x408, 0, -1),

                            // BYTE TEMP, CALIBRATION, and VIRTUAL (Indices 26-31)
                            new(SourceNct67Xxd.BYTE_TEMP0, 0x419, 0, -1),
                            new(SourceNct67Xxd.BYTE_TEMP1, 0x41A, 0, -1),
                            new(SourceNct67Xxd.PECI_0_CAL, 0x4F4, 0, -1),
                            new(SourceNct67Xxd.PECI_1_CAL, 0x4F5, 0, -1),
                            new(SourceNct67Xxd.VIRTUAL_TEMP, 0),
                            new(SourceNct67Xxd.SPARE_TEMP, 0),
                            new(SourceNct67Xxd.SPARE_TEMP2, 0)
                        });
                        break;

                    // --- GROUP D: NCT6798D/NCT6799D (Introduces AUXTIN5) ---
                    case Chip.NCT6798D:
                    case Chip.NCT6799D:
                        temperaturesSources.AddRange(new TemperatureSourceData[]
                        {
                            // Indices 1-7 are consistent (SYSTIN through AUXTIN4)
                            new(SourceNct67Xxd.PECI_0, 0x073, 0x074, 7, 0x100),
                            new(SourceNct67Xxd.CPUTIN, 0x075, 0x076, 7, 0x200, 0x491),
                            new(SourceNct67Xxd.SYSTIN, 0x077, 0x078, 7, 0x300, 0x490),
                            new(SourceNct67Xxd.AUXTIN0, 0x079, 0x07A, 7, 0x800, 0x492),
                            new(SourceNct67Xxd.AUXTIN1, 0x07B, 0x07C, 7, 0x900, 0x493),
                            new(SourceNct67Xxd.AUXTIN2, 0x07D, 0x07E, 7, 0xA00, 0x494),
                            new(SourceNct67Xxd.AUXTIN3, 0x4A0, 0x49E, 6, 0xB00, 0x495),
                            new(SourceNct67Xxd.AUXTIN4, 0x027, 0, -1, 0x621), // Index 7

                            new(SourceNct67Xxd.TSENSOR, 0x4A2, 0x4A1, 7, 0xC00, 0x496),
            
                            // SMBUS Group (Indices 8-9 are consistent)
                            new(SourceNct67Xxd.SMBUSMASTER0, 0x150, 0x151, 7, 0x622),
                            new(SourceNct67Xxd.SMBUSMASTER1, 0x670, 0, -1, 0xC26),
            
                            // PECI / PCH / DIMM Group (Indices 16-25)
                            new(SourceNct67Xxd.PECI_1, 0x672, 0, -1, 0xC27),
                            new(SourceNct67Xxd.PCH_CHIP_CPU_MAX_TEMP, 0x674, 0, -1, 0xC28, 0x400),
                            new(SourceNct67Xxd.PCH_CHIP_TEMP, 0x676, 0, -1, 0xC29, 0x401),
                            new(SourceNct67Xxd.PCH_CPU_TEMP, 0x678, 0, -1, 0xC2A, 0x402),
                            new(SourceNct67Xxd.PCH_MCH_TEMP, 0x67A, 0, -1, 0xC2B, 0x404),
                            new(SourceNct67Xxd.AGENT0_DIMM0, 0x405, 0, -1),
                            new(SourceNct67Xxd.AGENT0_DIMM1, 0x406, 0, -1),
                            new(SourceNct67Xxd.AGENT1_DIMM0, 0x407, 0, -1),
                            new(SourceNct67Xxd.AGENT1_DIMM1, 0x408, 0, -1),

                            // BYTE TEMP, CALIBRATION, and VIRTUAL (Indices 26-31)
                            new(SourceNct67Xxd.BYTE_TEMP0, 0x419, 0, -1),
                            new(SourceNct67Xxd.BYTE_TEMP1, 0x41A, 0, -1),
                            new(SourceNct67Xxd.PECI_0_CAL, 0x4F4, 0, -1),
                            new(SourceNct67Xxd.PECI_1_CAL, 0x4F5, 0, -1),
                            new(SourceNct67Xxd.VIRTUAL_TEMP, 0),
                            new(SourceNct67Xxd.SPARE_TEMP, 0),
                            new(SourceNct67Xxd.SPARE_TEMP2, 0)
                        });
                        break;

                    case Chip.NCT6796DS:
                        temperaturesSources.AddRange(new TemperatureSourceData[]
                        {
                            //https://github.com/LibreHardwareMonitor/LibreHardwareMonitor/pull/2012
                            new(SourceNct67Xxd.CPUTIN, 0x073, 0x074, 7, 0x100, 0x491),
                            new(SourceNct67Xxd.SYSTIN, 0x075, 0x076, 7, 0x200, 0x490),
                            new(SourceNct67Xxd.AUXTIN0, 0x077, 0x078, 7, 0x300, 0x492),
                            new(SourceNct67Xxd.AUXTIN1, 0x079, 0x07A, 7, 0x800, 0x493),
                            new(SourceNct67Xxd.AUXTIN2, 0x07B, 0x07C, 7, 0x900, 0x494),
                            new(SourceNct67Xxd.AUXTIN3, 0x07D, 0x07E, 7, 0xA00, 0x495),
                            new(SourceNct67Xxd.AUXTIN4, 0x027, 0, 4, 0xC16, 0x496),
                            new(SourceNct67Xxd.AUXTIN5, 0x449, 0, 4, 0x100, 0x4A2),
                            new(SourceNct67Xxd.SMBUSMASTER0, 0x150, 0x151, 7, 0x622),
                            new(SourceNct67Xxd.PECI_0, 0x0720),
                            new(SourceNct67Xxd.VIRTUAL_TEMP, 0)
                        });

                        break;

                    case Chip.NCT5585D:
                        temperaturesSources.AddRange(new TemperatureSourceData[]
                        {
                            new(SourceNct67Xxd.PECI_0, 0x0720, 0, -1, 0x100),
                            new(SourceNct67Xxd.CPUTIN, 0x075, 0x076, 7, 0x000, 0x073),
                            new(SourceNct67Xxd.AUXTIN1, 0x07B, 0x07C, 7, 0x900, 0x493),
                            new(SourceNct67Xxd.AUXTIN3, 0x4A0, 0x49E, 6, 0xB00, 0x495),
                        });

                        break;

                    default:
                        temperaturesSources.AddRange(new TemperatureSourceData[]
                        {
                            new(SourceNct67Xxd.PECI_0, 0x027, 0, -1, 0x621),
                            new(SourceNct67Xxd.CPUTIN, 0x073, 0x074, 7, 0x100, 0x491),
                            new(SourceNct67Xxd.SYSTIN, 0x075, 0x076, 7, 0x200, 0x490),
                            new(SourceNct67Xxd.AUXTIN0, 0x077, 0x078, 7, 0x300, 0x492),
                            new(SourceNct67Xxd.AUXTIN1, 0x079, 0x07A, 7, 0x800, 0x493),
                            new(SourceNct67Xxd.AUXTIN2, 0x07B, 0x07C, 7, 0x900, 0x494),
                            new(SourceNct67Xxd.AUXTIN3, 0x150, 0x151, 7, 0x622, 0x495)
                        });

                        break;
                }

                _temperaturesSource = temperaturesSources.ToArray();
                Temperatures = new float?[_temperaturesSource.Length];
                break;

            case Chip.NCT610XD:
                Fans = new float?[3];
                Controls = new float?[3];

                _fanRpmRegister = new ushort[3];
                for (int i = 0; i < _fanRpmRegister.Length; i++)
                    _fanRpmRegister[i] = (ushort)(0x030 + (i << 1));

                // min value RPM value with 13-bit fan counter
                _minFanRpm = (int)(1.35e6 / 0x1FFF);

                Voltages = new float?[9];
                _voltageRegisters = [0x300, 0x301, 0x302, 0x303, 0x304, 0x305, 0x307, 0x308, 0x309];
                _voltageVBatRegister = 0x308;
                Temperatures = new float?[7];
                _temperaturesSource =
                [
                    new TemperatureSourceData(SourceNct610X.PECI_0, 0x06b, 0, -1, 0x621),
                    new TemperatureSourceData(SourceNct610X.AUXTIN, 0x010, 0x016, 0),
                    new TemperatureSourceData(SourceNct610X.CPUTIN, 0x011, 0x01B, 1),
                    new TemperatureSourceData(SourceNct610X.SYSTIN0, 0x012, 0x01B, 2),
                    new TemperatureSourceData(SourceNct610X.SYSTIN1, 0x013, 0x016, 3),
                    new TemperatureSourceData(SourceNct610X.SYSTIN2, 0x014, 0x01B, 4),
                    new TemperatureSourceData(SourceNct610X.SYSTIN3, 0x015, 0x01B, 5)
                ];

                break;

            case Chip.NCT6683D:
            case Chip.NCT6686D:
            case Chip.NCT6687D:
                Fans = new float?[17];
                Controls = new float?[8];
                Voltages = new float?[14];
                Temperatures = new float?[11];

                // CPU
                // System
                // MOS
                // PCH
                // CPU Socket
                // PCIE_1
                // M2_1
                // PCIE_1
                // PCIE_2
                // M2_1
                // M2_4
                _temperaturesSource =
                [
                    new TemperatureSourceData(null, 0x100),
                    new TemperatureSourceData(null, 0x102),
                    new TemperatureSourceData(null, 0x104),
                    new TemperatureSourceData(null, 0x106),
                    new TemperatureSourceData(null, 0x108),
                    new TemperatureSourceData(null, 0x10A),
                    new TemperatureSourceData(null, 0x10C),
                    new TemperatureSourceData(null, 0x10E),
                    new TemperatureSourceData(null, 0x110),
                    new TemperatureSourceData(null, 0x112),
                    new TemperatureSourceData(null, 0x114)
                ];

                // VIN0 +12V
                // VIN1 +5V
                // VIN2 VCore
                // VIN3 SIO
                // VIN4 DRAM
                // VIN5 CPU IO
                // VIN6 CPU SA
                // VIN7 SIO
                // 3VCC I/O +3.3
                // SIO VTT
                // SIO VREF
                // SIO VSB
                // SIO AVSB
                // SIO VBAT
                _voltageRegisters = [0x120, 0x122, 0x124, 0x126, 0x128, 0x12A, 0x12C, 0x12E, 0x130, 0x13A, 0x13E, 0x136, 0x138, 0x13C];

                // CPU Fan
                // PUMP Fan 1
                // SYS Fan 1 on some older NCT6687Ds, Nil on others
                // SYS Fan 2 on some older NCT6687Ds, EZConn on others
                // SYS Fan 3 on some older NCT6687Ds
                // SYS Fan 4 on some older NCT6687Ds
                // SYS Fan 5 on some older NCT6687Ds
                // SYS Fan 6 on some older NCT6687Ds
                // SYS Fan 6 on newer NCT6687Ds - PUMP Fan 2 on some NCT6687Ds (e.g. Z790 GODLIKE MAX)
                // SYS Fan 5 on newer NCT6687Ds - EZ-Connect Fan 1 (JAF) on some NCT6687Ds (e.g. Z790 GODLIKE MAX)
                // SYS Fan 4 on newer NCT6687Ds
                // SYS Fan 3 on newer NCT6687Ds
                // SYS Fan 2 on newer NCT6687Ds
                // SYS Fan 1 on newer NCT6687Ds
                // SYS Fan 7 on some NCT6687Ds - 0x852 (e.g. Z790 GODLIKE MAX)
                _fanRpmRegister = [0x140, 0x142, 0x144, 0x146, 0x148, 0x14A, 0x14C, 0x14E, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15A, 0x15C, 0x15E, 0x852];

                // On some boards, there will be SYS Fan 7 (e.g. MSI MEG Z790 GODLIKE MAX)
                _fanCountRegister = [0x852];

                // max value for 13-bit fan counter
                _maxFanCount = 0x1FFF;

                // min value that could be transferred to 16-bit RPM registers
                _minFanCount = 0x15;

                _restoreDefaultFanControlRequired = new bool[_fanRpmRegister.Length];
                _initialFanControlMode = new byte[_fanRpmRegister.Length];
                _initialFanPwmCommand = new byte[_fanRpmRegister.Length];

                // initialize
                const ushort initRegister = 0x180;
                byte data = ReadByte(initRegister);
                if ((data & 0x80) == 0)
                {
                    WriteByte(initRegister, (byte)(data | 0x80));
                }

                // enable SIO voltage
                WriteByte(0x1BB, 0x61);
                WriteByte(0x1BC, 0x62);
                WriteByte(0x1BD, 0x63);
                WriteByte(0x1BE, 0x64);
                WriteByte(0x1BF, 0x65);
                break;

            case Chip.NCT6687DR:
                Fans = new float?[16];
                Controls = new float?[16];
                Voltages = new float?[14];
                Temperatures = new float?[7];

                _temperaturesSource =
                [
                    new TemperatureSourceData(null, 0x100), // CPU
                    new TemperatureSourceData(null, 0x102), // System
                    new TemperatureSourceData(null, 0x104), // MOS
                    new TemperatureSourceData(null, 0x106), // PCH
                    new TemperatureSourceData(null, 0x108), // CPU Socket
                    new TemperatureSourceData(null, 0x10A), // PCIE_1
                    new TemperatureSourceData(null, 0x10C)  // M2_1
                ];

                // VIN0 +12V
                // VIN1 +5V
                // VIN2 VCore
                // VIN3 SIO
                // VIN4 DRAM
                // VIN5 CPU IO
                // VIN6 CPU SA
                // VIN7 SIO
                // 3VCC I/O +3.3
                // SIO VTT
                // SIO VREF
                // SIO VSB
                // SIO AVSB
                // SIO VBAT
                _voltageRegisters = [0x120, 0x122, 0x124, 0x126, 0x128, 0x12A, 0x12C, 0x12E, 0x130, 0x13A, 0x13E, 0x136, 0x138, 0x13C];

                // CPU Fan 0x140
                // PUMP Fan 0x142
                // Chipset Fan 0x144
                // EZ-Conn 0x146
                // NOTHING
                // NOTHING
                // NOTHING
                // NOTHING
                // NOTHING
                // SYS Fan 7 0x152
                // SYS Fan 1 0x15E
                // SYS Fan 2 0x15C
                // SYS Fan 3 0x15A
                // SYS Fan 4 0x158
                // SYS Fan 5 0x156
                // SYS Fan 6 0x154
                _fanRpmRegister = [0x140, 0x142, 0x144, 0x146, 0x148, 0x14A, 0x14C, 0x14E, 0x150, 0x152, 0x15E, 0x15C, 0x15A, 0x158, 0x156, 0x154];

                _restoreDefaultFanControlRequired = new bool[_fanRpmRegister.Length];
                _initialFanControlMode = new byte[_fanRpmRegister.Length];
                _initialFanPwmCommand = new byte[_fanRpmRegister.Length];

                // initialize
                const ushort initRegisterNct6687DR = 0x180;
                byte dataNct6687DR = ReadByte(initRegisterNct6687DR);
                if ((dataNct6687DR & 0x80) == 0)
                {
                    WriteByte(initRegisterNct6687DR, (byte)(dataNct6687DR | 0x80));
                }

                // enable SIO voltage -- address, value
                WriteByte(0x1BB, 0x61);
                WriteByte(0x1BC, 0x62);
                WriteByte(0x1BD, 0x63);
                WriteByte(0x1BE, 0x64);
                WriteByte(0x1BF, 0x65);
                break;
        }
    }

    public Chip Chip { get; }

    public float?[] Controls { get; } = Array.Empty<float?>();

    public float?[] Fans { get; } = Array.Empty<float?>();

    public float?[] Temperatures { get; } = Array.Empty<float?>();

    public float?[] Voltages { get; } = Array.Empty<float?>();

    public byte? ReadGpio(int index)
    {
        return null;
    }

    public void WriteGpio(int index, byte value)
    { }

    public void SetControl(int index, byte? value)
    {
        if (!_isNuvotonVendor)
            return;

        if (index < 0 || index >= Controls.Length)
            throw new ArgumentOutOfRangeException(nameof(index));

        if (!Mutexes.WaitIsaBus(10))
            return;

        if (value.HasValue)
        {
            SaveDefaultFanControl(index);

            if (Chip is not Chip.NCT6683D and not Chip.NCT6686D and not Chip.NCT6687D and not Chip.NCT6687DR)
            {
                // set manual mode
                WriteByte(FAN_CONTROL_MODE_REG[index], 0);

                // set output value
                WriteByte(FAN_PWM_COMMAND_REG[index], value.Value);
            }
            else
            {
                // Manual mode, bit(1 : set, 0 : unset)
                // bit 0 : CPU Fan
                // bit 1 : PUMP Fan
                // bit 2 : SYS Fan 1
                // bit 3 : SYS Fan 2
                // bit 4 : SYS Fan 3
                // bit 5 : SYS Fan 4
                // bit 6 : SYS Fan 5
                // bit 7 : SYS Fan 6

                WriteByte(FAN_PWM_REQUEST_REG[index], 0x80);
                Thread.Sleep(50);

                if (Chip is Chip.NCT6687DR) // For MSI AM5/LGA1851 NCT6687D functionality
                {                    
                    if (index < 8) // Control fans traditionally if part of the old control scheme. Applies to CPU/Pump/EZ-Conn
                    {
                        byte mode = ReadByte(FAN_CONTROL_MODE_REG[index]);
                        byte bitMask = (byte)(0x01 << index);
                        mode = (byte)(mode | bitMask);
                        WriteByte(FAN_CONTROL_MODE_REG[index], mode);
                    }

                    Set6687DRControl(index, value.Value);
                }
                else // All other Nuvoton SIO controllers and motherboards that use NCT6683/6686/6687
                {
                    byte mode = ReadByte(FAN_CONTROL_MODE_REG[index]);
                    byte bitMask = (byte)(0x01 << index);
                    mode = (byte)(mode | bitMask);
                    WriteByte(FAN_CONTROL_MODE_REG[index], mode);

                    WriteByte(FAN_PWM_COMMAND_REG[index], value.Value);
                }

                WriteByte(FAN_PWM_REQUEST_REG[index], 0x40);
                Thread.Sleep(50);
            }
        }
        else
        {
            RestoreDefaultFanControl(index);
        }

        Mutexes.ReleaseIsaBus();
    }

    public void Update()
    {
        if (!_isNuvotonVendor)
            return;

        if (!Mutexes.WaitIsaBus(10))
            return;

        DisableIOSpaceLock();

        for (int i = 0; i < Voltages.Length; i++)
        {
            if (Chip is not Chip.NCT6683D and not Chip.NCT6686D and not Chip.NCT6687D and not Chip.NCT6687DR)
            {
                float value = 0.008f * ReadByte(_voltageRegisters[i]);
                bool valid = value > 0;

                // check if battery voltage monitor is enabled
                if (valid && _voltageRegisters[i] == _voltageVBatRegister)
                    valid = (ReadByte(_vBatMonitorControlRegister) & 0x01) > 0;

                Voltages[i] = valid ? value : null;
            }
            else
            {
                float value = 0.001f * ((16 * ReadByte(_voltageRegisters[i])) + (ReadByte((ushort)(_voltageRegisters[i] + 1)) >> 4));

                Voltages[i] = i switch
                {
                    // 12V
                    0 => value * 12.0f,
                    // 5V
                    1 => value * 5.0f,
                    // DRAM
                    4 => value * 2.0f,
                    _ => value
                };
            }
        }

        Log("Updating temperatures.");
        long temperatureSourceMask = 0;
        for (int i = 0; i < _temperaturesSource.Length; i++)
        {
            TemperatureSourceData ts = _temperaturesSource[i];
            int value;
            SourceNct67Xxd source;
            float? temperature;

            switch (Chip)
            {
                case Chip.NCT610XD:
                    value = (sbyte)ReadByte(ts.Register);
                    int half = (ReadByte(ts.HalfRegister) >> ts.HalfBit) & 0x1;
                    temperature = value + (0.5f * half);
                    Temperatures[i] = temperature;
                    break;

                case Chip.NCT6687D:
                case Chip.NCT6687DR:
                case Chip.NCT6686D:
                case Chip.NCT6683D:
                    value = (sbyte)ReadByte(ts.Register);
                    half = (ReadByte((ushort)(ts.Register + 1)) >> 7) & 0x1;
                    Temperatures[i] = value + (0.5f * half);
                    break;

                case Chip.NCT6796D:
                case Chip.NCT6796DR:
                case Chip.NCT6796DS:
                case Chip.NCT6797D:
                case Chip.NCT6798D:
                case Chip.NCT6799D:
                case Chip.NCT5585D:
                    if (_temperaturesSource[i].Register == 0)
                    {
                        Log("Temperature register {0} skipped, address 0.", i);
                        continue;
                    }

                    value = (sbyte)ReadByte(_temperaturesSource[i].Register) << 1;
                    Log("Temperature register {0} at 0x{1:X3} value (integer): {2}/2", i, ts.Register, value);
                    if (_temperaturesSource[i].HalfBit > 0)
                    {
                        value |= (ReadByte(_temperaturesSource[i].HalfRegister) >> ts.HalfBit) & 0x1;
                        Log("Temperature register {0} value updated from 0x{1:X3} (fractional): {2}/2", i, ts.HalfRegister, value);
                    }

                    if (ts.SourceRegister > 0)
                    {
                        source = (SourceNct67Xxd)(ReadByte(ts.SourceRegister) & 0x1F);
                        Log("Temperature register {0} source at 0x{1:X3}: {2:G} ({2:D})", i, ts.SourceRegister, source);
                    }
                    else
                    {
                        source = (SourceNct67Xxd)ts.Source;
                        Log("Temperature register {0} source register is 0, source set to: {1:G} ({1:D})", i, source);
                    }

                    // Skip reading when already filled, because later values are without fractional
                    if ((temperatureSourceMask & (1L << (byte)source)) > 0)
                    {
                        Log("Temperature register {0} discarded, because source seen before.", i);
                        continue;
                    }

                    temperature = 0.5f * value;
                    Log("Temperature register {0} final temperature: {1}.", i, temperature);
                    if (temperature is > 125 or < -55)
                    {
                        temperature = null;
                        Log("Temperature register {0} discarded: Out of range.", i);
                    }
                    else
                    {
                        temperatureSourceMask |= 1L << (byte)source;
                        Log("Temperature register {0} accepted.", i);
                    }

                    for (int j = 0; j < Temperatures.Length; j++)
                    {
                        if ((SourceNct67Xxd)_temperaturesSource[j].Source == source)
                        {
                            Temperatures[j] = temperature;
                            Log("Temperature register {0}, value from source {1:G} ({1:D}), written at position {2}.", i, _temperaturesSource[j].Source, j);
                        }
                    }

                    break;

                default:
                    value = (sbyte)ReadByte(ts.Register) << 1;
                    if (ts.HalfBit > 0)
                    {
                        value |= (ReadByte(ts.HalfRegister) >> ts.HalfBit) & 0x1;
                    }

                    source = (SourceNct67Xxd)ReadByte(ts.SourceRegister);
                    temperatureSourceMask |= 1L << (byte)source;

                    temperature = 0.5f * value;
                    if (temperature is > 125 or < -55)
                        temperature = null;

                    for (int j = 0; j < Temperatures.Length; j++)
                    {
                        if ((SourceNct67Xxd)_temperaturesSource[j].Source == source)
                            Temperatures[j] = temperature;
                    }

                    break;
            }
        }

        for (int i = 0; i < _temperaturesSource.Length; i++)
        {
            TemperatureSourceData ts = _temperaturesSource[i];
            if (!ts.AlternateRegister.HasValue)
            {
                Log("Alternate temperature register for temperature {0}, {1:G} ({1:D}), skipped, because address is null.", i, ts.Source);
                continue;
            }

            if ((temperatureSourceMask & (1L << (byte)(SourceNct67Xxd)ts.Source)) > 0)
            {
                Log("Alternate temperature register for temperature {0}, {1:G} ({1:D}), at 0x{2:X3} skipped, because value already set.", i, ts.Source, ts.AlternateRegister.Value);
                continue;
            }

            float? temperature = (sbyte)ReadByte(ts.AlternateRegister.Value);
            Log("Alternate temperature register for temperature {0}, {1:G} ({1:D}), at 0x{2:X3} final temperature: {3}.", i, ts.Source, ts.AlternateRegister.Value, temperature);

            if (temperature is > 125 or <= 0)
            {
                temperature = null;
                Log("Alternate Temperature register for temperature {0}, {1:G} ({1:D}), discarded: Out of range.", i, ts.Source);
            }

            Temperatures[i] = temperature;
        }

        void Update13BitFan(int i, byte low, byte high)
        {
            // No fan plugged in OR fan is at 0 RPM
            if (Chip is Chip.NCT6687D && high == 0xFF && low == 0xF8)
            {
                Fans[i] = 0;
                return;
            }

            int count = (high << 5) | (low & 0x1F);
            if (count < _maxFanCount)
            {
                if (count >= _minFanCount)
                {
                    Fans[i] = 1.35e6f / count;
                }
                else
                {
                    Fans[i] = null;
                }
            }
            else
            {
                Fans[i] = 0;
            }
        }

        var fcrList = _fanCountRegister?.ToList() ?? new List<ushort>();

        for (int i = 0; i < Fans.Length; i++)
        {
            if (Chip is not Chip.NCT6683D and not Chip.NCT6686D and not Chip.NCT6687D and not Chip.NCT6687DR)
            {
                if (_fanCountRegister != null)
                {
                    byte high = ReadByte(_fanCountRegister[i]);
                    byte low = ReadByte((ushort)(_fanCountRegister[i] + 1));

                    Update13BitFan(i, low, high);
                }
                else
                {
                    byte high = ReadByte(_fanRpmRegister[i]);
                    byte low = ReadByte((ushort)(_fanRpmRegister[i] + 1));
                    int value = (high << 8) | low;

                    Fans[i] = value > _minFanRpm ? value : 0;
                }
            }
            else
            {
                byte high = ReadByte(_fanRpmRegister[i]);
                byte low = ReadByte((ushort)(_fanRpmRegister[i] + 1));

                //13-bit fan ?
                if (fcrList.Contains(_fanRpmRegister[i]))
                {
                    Update13BitFan(i, low, high);
                }
                else
                {
                    Fans[i] = (high << 8) | low;
                }
            }
        }

        for (int i = 0; i < Controls.Length; i++)
        {
            if (Chip is not Chip.NCT6683D and not Chip.NCT6686D and not Chip.NCT6687D and not Chip.NCT6687DR)
            {
                int value = ReadByte(FAN_PWM_OUT_REG[i]);
                Controls[i] = value / 2.55f;
            }
            else
            {
                int value = ReadByte(FAN_PWM_OUT_REG[i]);
                Controls[i] = (float)Math.Round(value / 2.55f);
            }
        }

        Mutexes.ReleaseIsaBus();
    }

    /// <inheritdoc />
    public void Close()
    {
        _lpcPort.Close();
    }

    public string GetReport()
    {
        StringBuilder r = new();

        r.AppendLine("LPC " + GetType().Name);
        r.AppendLine();
        r.Append("Chip Id: 0x");
        r.AppendLine(Chip.ToString("X"));
        r.Append("Chip Revision: 0x");
        r.AppendLine(_revision.ToString("X", CultureInfo.InvariantCulture));
        r.Append("Base Address: 0x");
        r.AppendLine(_port.ToString("X4", CultureInfo.InvariantCulture));
        r.AppendLine();

        if (!Mutexes.WaitIsaBus(100))
            return r.ToString();

        ushort[] addresses =
        {
            0x000,
            0x010,
            0x020,
            0x030,
            0x040,
            0x050,
            0x060,
            0x070,
            0x0F0,
            0x100,
            0x110,
            0x120,
            0x130,
            0x140,
            0x150,
            0x200,
            0x210,
            0x220,
            0x230,
            0x240,
            0x250,
            0x260,
            0x300,
            0x320,
            0x330,
            0x340,
            0x360,
            0x400,
            0x410,
            0x420,
            0x440,
            0x450,
            0x460,
            0x480,
            0x490,
            0x4B0,
            0x4C0,
            0x4F0,
            0x500,
            0x550,
            0x560,
            0x600,
            0x610,
            0x620,
            0x630,
            0x640,
            0x650,
            0x660,
            0x670,
            0x700,
            0x710,
            0x720,
            0x730,
            0x800,
            0x820,
            0x830,
            0x840,
            0x900,
            0x920,
            0x930,
            0x940,
            0x960,
            0xA00,
            0xA10,
            0xA20,
            0xA30,
            0xA40,
            0xA50,
            0xA60,
            0xA70,
            0xB00,
            0xB10,
            0xB20,
            0xB30,
            0xB50,
            0xB60,
            0xB70,
            0xC00,
            0xC10,
            0xC20,
            0xC30,
            0xC50,
            0xC60,
            0xC70,
            0xD00,
            0xD10,
            0xD20,
            0xD30,
            0xD50,
            0xD60,
            0xE00,
            0xE10,
            0xE20,
            0xE30,
            0xF00,
            0xF10,
            0xF20,
            0xF30,
            0x8040,
            0x80F0
        };

        r.AppendLine("Hardware Monitor Registers");
        r.AppendLine();
        r.AppendLine("        00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F");
        r.AppendLine();

        if (Chip is not Chip.NCT6683D and not Chip.NCT6686D and not Chip.NCT6687D and not Chip.NCT6687DR)
        {
            foreach (ushort address in addresses)
            {
                r.Append(" ");
                r.Append(address.ToString("X4", CultureInfo.InvariantCulture));
                r.Append("  ");
                for (ushort j = 0; j <= 0xF; j++)
                {
                    r.Append(" ");
                    r.Append(ReadByte((ushort)(address | j)).ToString("X2", CultureInfo.InvariantCulture));
                }

                r.AppendLine();
            }
        }
        else
        {
            for (int i = 0; i <= 0xFF; i++)
            {
                r.Append(" ");
                r.Append((i << 4).ToString("X4", CultureInfo.InvariantCulture));
                r.Append("  ");
                for (int j = 0; j <= 0xF; j++)
                {
                    ushort address = (ushort)(i << 4 | j);
                    r.Append(" ");
                    r.Append(ReadByte(address).ToString("X2", CultureInfo.InvariantCulture));
                }

                r.AppendLine();
            }
        }

        r.AppendLine();

        Mutexes.ReleaseIsaBus();

        return r.ToString();
    }

    private byte ReadByte(ushort address)
    {
        if (Chip is not Chip.NCT6683D and not Chip.NCT6686D and not Chip.NCT6687D and not Chip.NCT6687DR)
        {
            byte bank = (byte)(address >> 8);
            byte register = (byte)(address & 0xFF);
            _lpcPort.WriteIoPort((ushort)(_port + ADDRESS_REGISTER_OFFSET), BANK_SELECT_REGISTER);
            _lpcPort.WriteIoPort((ushort)(_port + DATA_REGISTER_OFFSET), bank);
            _lpcPort.WriteIoPort((ushort)(_port + ADDRESS_REGISTER_OFFSET), register);
            return _lpcPort.ReadIoPort((ushort)(_port + DATA_REGISTER_OFFSET));
        }

        byte page = (byte)(address >> 8);
        byte index = (byte)(address & 0xFF);

        //wait for access, access == EC_SPACE_PAGE_SELECT
        //timeout: after 500ms, abort and force access
        byte access;

        DateTime timeout = DateTime.UtcNow.AddMilliseconds(500);
        while (true)
        {
            access = _lpcPort.ReadIoPort((ushort)(_port + EC_SPACE_PAGE_REGISTER_OFFSET));
            if (access == EC_SPACE_PAGE_SELECT || DateTime.UtcNow > timeout)
                break;

            Thread.Sleep(1);
        }

        if (access != EC_SPACE_PAGE_SELECT)
        {
            // Failed to gain access: force register access
            _lpcPort.WriteIoPort((ushort)(_port + EC_SPACE_PAGE_REGISTER_OFFSET), EC_SPACE_PAGE_SELECT);
        }

        _lpcPort.WriteIoPort((ushort)(_port + EC_SPACE_PAGE_REGISTER_OFFSET), page);
        _lpcPort.WriteIoPort((ushort)(_port + EC_SPACE_INDEX_REGISTER_OFFSET), index);
        byte result = _lpcPort.ReadIoPort((ushort)(_port + EC_SPACE_DATA_REGISTER_OFFSET));

        //free access for other instances
        _lpcPort.WriteIoPort((ushort)(_port + EC_SPACE_PAGE_REGISTER_OFFSET), EC_SPACE_PAGE_SELECT);

        return result;
    }

    private void WriteByte(ushort address, byte value)
    {
        if (Chip is not Chip.NCT6683D and not Chip.NCT6686D and not Chip.NCT6687D and not Chip.NCT6687DR)
        {
            byte bank = (byte)(address >> 8);
            byte register = (byte)(address & 0xFF);
            _lpcPort.WriteIoPort((ushort)(_port + ADDRESS_REGISTER_OFFSET), BANK_SELECT_REGISTER);
            _lpcPort.WriteIoPort((ushort)(_port + DATA_REGISTER_OFFSET), bank);
            _lpcPort.WriteIoPort((ushort)(_port + ADDRESS_REGISTER_OFFSET), register);
            _lpcPort.WriteIoPort((ushort)(_port + DATA_REGISTER_OFFSET), value);
        }
        else
        {
            byte page = (byte)(address >> 8);
            byte index = (byte)(address & 0xFF);

            //wait for access, access == EC_SPACE_PAGE_SELECT
            //timeout: after 500ms, abort and force access
            byte access;

            DateTime timeout = DateTime.UtcNow.AddMilliseconds(500);
            while (true)
            {
                access = _lpcPort.ReadIoPort((ushort)(_port + EC_SPACE_PAGE_REGISTER_OFFSET));
                if (access == EC_SPACE_PAGE_SELECT || DateTime.UtcNow > timeout)
                    break;

                Thread.Sleep(1);
            }

            if (access != EC_SPACE_PAGE_SELECT)
            {
                // Failed to gain access: force register access
                _lpcPort.WriteIoPort((ushort)(_port + EC_SPACE_PAGE_REGISTER_OFFSET), EC_SPACE_PAGE_SELECT);
            }

            _lpcPort.WriteIoPort((ushort)(_port + EC_SPACE_PAGE_REGISTER_OFFSET), page);
            _lpcPort.WriteIoPort((ushort)(_port + EC_SPACE_INDEX_REGISTER_OFFSET), index);
            _lpcPort.WriteIoPort((ushort)(_port + EC_SPACE_DATA_REGISTER_OFFSET), value);

            //free access for other instances
            _lpcPort.WriteIoPort((ushort)(_port + EC_SPACE_PAGE_REGISTER_OFFSET), EC_SPACE_PAGE_SELECT);
        }
    }

    private bool IsNuvotonVendor()
    {
        return Chip is Chip.NCT6683D or Chip.NCT6686D or Chip.NCT6687D or Chip.NCT6687DR or Chip.NCT6701D ||
               ((ReadByte(VENDOR_ID_HIGH_REGISTER) << 8) | ReadByte(VENDOR_ID_LOW_REGISTER)) == NUVOTON_VENDOR_ID;
    }

    private void Set6687DRControl(int index, byte? value)
    {
        if (index > 8) // Brute Force System Fan Control
        {
            int initFanCurveReg = FAN_PWM_COMMAND_REG[index];       // Initial Register Address for the Fan Curve
            int targetFanCurveAddr = initFanCurveReg;               // Address of the Current Fan Curve Register we're writing to
            ushort targetFanCurveReg;                               // Integer value of the current fan curve register address, not the value within
            byte currentSpeed = ReadByte(FAN_PWM_OUT_REG[index]);   // Current Speed of the target fan

            // If current fan duty cycle matches requested duty cycle, skip re-writing the fan curve
            if (currentSpeed == value.Value)
            {
                return;
            }
            else
            {
                // Write 7-point fan curve
                for (int count = 0; count < 14; count += 2)
                {
                    targetFanCurveAddr = initFanCurveReg+count;
                    targetFanCurveReg = Convert.ToUInt16(targetFanCurveAddr);
                    WriteByte(targetFanCurveReg, value.Value);
                }
            }
        }
        else // Control CPU, Pump, Chipset, or EZ-Connect Fan normally
        {
            WriteByte(FAN_PWM_COMMAND_REG[index], value.Value);
        }
    }

    private void SaveDefaultFanControl(int index)
    {
        if (!_restoreDefaultFanControlRequired[index])
        {
            if (Chip is not Chip.NCT6683D and not Chip.NCT6686D and not Chip.NCT6687D and not Chip.NCT6687DR)
            {
                _initialFanControlMode[index] = ReadByte(FAN_CONTROL_MODE_REG[index]);
            }
            else
            {
                byte mode = ReadByte(FAN_CONTROL_MODE_REG[index]);
                byte bitMask = (byte)(0x01 << index);
                _initialFanControlMode[index] = (byte)(mode & bitMask);
            }

            _initialFanPwmCommand[index] = ReadByte(FAN_PWM_COMMAND_REG[index]);
            _restoreDefaultFanControlRequired[index] = true;
        }
    }

    private void RestoreDefaultFanControl(int index)
    {
        if (_restoreDefaultFanControlRequired[index])
        {
            if (Chip is not Chip.NCT6683D and not Chip.NCT6686D and not Chip.NCT6687D and not Chip.NCT6687DR)
            {
                WriteByte(FAN_CONTROL_MODE_REG[index], _initialFanControlMode[index]);
                WriteByte(FAN_PWM_COMMAND_REG[index], _initialFanPwmCommand[index]);
            }
            else
            {
                byte mode = ReadByte(FAN_CONTROL_MODE_REG[index]);
                mode = (byte)(mode & ~_initialFanControlMode[index]);
                WriteByte(FAN_CONTROL_MODE_REG[index], mode);

                WriteByte(FAN_PWM_REQUEST_REG[index], 0x80);
                Thread.Sleep(50);

                if (Chip is Chip.NCT6687DR)
                {
                    // for MSI AM5/LGA1851 boards using NCT6687D
                    Set6687DRControl(index, _initialFanPwmCommand[index]);
                }
                else
                {
                    // All other motherboards that use NCT6683/6686/6687
                    WriteByte(FAN_PWM_COMMAND_REG[index], _initialFanPwmCommand[index]);
                }

                WriteByte(FAN_PWM_REQUEST_REG[index], 0x40);
                Thread.Sleep(50);
            }

            _restoreDefaultFanControlRequired[index] = false;
        }
    }

    private void DisableIOSpaceLock()
    {
        if (Chip is not Chip.NCT6791D and
            not Chip.NCT6792D and
            not Chip.NCT6792DA and
            not Chip.NCT6793D and
            not Chip.NCT6795D and
            not Chip.NCT6796D and
            not Chip.NCT6796DR and
            not Chip.NCT6796DS and
            not Chip.NCT6797D and
            not Chip.NCT6798D and
            not Chip.NCT6799D and
            not Chip.NCT5585D)
        {
            return;
        }

        // the lock is disabled already if the vendor ID can be read
        if (IsNuvotonVendor())
            return;

        _lpcPort.WinbondNuvotonFintekEnter();
        _lpcPort.NuvotonDisableIOSpaceLock();
        _lpcPort.WinbondNuvotonFintekExit();
    }

    [Conditional("DEBUG_LOG"), Conditional("NCT677X_DEBUG_LOG")]
    private static void Log(string format, params object[] args)
    {
        Debug.WriteLine(string.Format(CultureInfo.InvariantCulture, format, args));
    }

    private readonly struct TemperatureSourceData(Enum source, ushort register, ushort halfRegister = 0, int halfBit = -1, ushort sourceRegister = 0, ushort? alternateRegister = null)
    {
        public readonly Enum Source = source;
        public readonly ushort Register = register;
        public readonly ushort HalfRegister = halfRegister;
        public readonly int HalfBit = halfBit;
        public readonly ushort SourceRegister = sourceRegister;
        public readonly ushort? AlternateRegister = alternateRegister;
    }

    [SuppressMessage("ReSharper", "InconsistentNaming")]
    private enum SourceNct6771F : byte
    {
        SYSTIN = 1,
        CPUTIN = 2,
        AUXTIN = 3,
        PECI_0 = 5
    }

    [SuppressMessage("ReSharper", "InconsistentNaming")]
    private enum SourceNct6776F : byte
    {
        SYSTIN = 1,
        CPUTIN = 2,
        AUXTIN = 3,
        PECI_0 = 12
    }

    [SuppressMessage("ReSharper", "InconsistentNaming")]
    private enum SourceNct67Xxd : byte
    {
        SYSTIN = 1,
        CPUTIN = 2,
        AUXTIN0 = 3,
        AUXTIN1 = 4,
        AUXTIN2 = 5,
        AUXTIN3 = 6,
        AUXTIN4 = 7,
        TSENSOR = 10,
        SMBUSMASTER0 = 8,
        SMBUSMASTER1 = 9,
        RESERVED_1 = 10,
        RESERVED_2 = 11,
        RESERVED_3 = 12,
        RESERVED_4 = 13,
        RESERVED_5 = 14,
        RESERVED_6 = 15,
        PECI_0 = 16,
        PECI_1 = 17,
        PCH_CHIP_CPU_MAX_TEMP = 18,
        PCH_CHIP_TEMP = 19,
        PCH_CPU_TEMP = 20,
        PCH_MCH_TEMP = 21,
        AGENT0_DIMM0 = 22,
        AGENT0_DIMM1 = 23,
        AGENT1_DIMM0 = 24,
        AGENT1_DIMM1 = 25,
        BYTE_TEMP0 = 26,
        BYTE_TEMP1 = 27,
        PECI_0_CAL = 28,
        PECI_1_CAL = 29,
        RESERVED_7 = 30,
        VIRTUAL_TEMP = 31,
        SPARE_TEMP = 32,
        SPARE_TEMP2 = 33,
        AUXTIN5 = 34,
    }

    [SuppressMessage("ReSharper", "InconsistentNaming")]
    private enum SourceNct610X : byte
    {
        CPUTIN = 1,
        AUXTIN = 2,
        SYSTIN0 = 3,
        SYSTIN1 = 4,
        SYSTIN2 = 5,
        SYSTIN3 = 6,
        PECI_0 = 12
    }

    // ReSharper disable InconsistentNaming
    private const ushort ADDRESS_REGISTER_OFFSET = 0x05;
    private const byte BANK_SELECT_REGISTER = 0x4E;
    private const uint DATA_REGISTER_OFFSET = 0x06;

    // NCT668X
    private const uint EC_SPACE_PAGE_REGISTER_OFFSET = 0x04;
    private const uint EC_SPACE_INDEX_REGISTER_OFFSET = 0x05;
    private const uint EC_SPACE_DATA_REGISTER_OFFSET = 0x06;
    private const byte EC_SPACE_PAGE_SELECT = 0xFF;

    private const ushort NUVOTON_VENDOR_ID = 0x5CA3;

    private readonly ushort[] FAN_CONTROL_MODE_REG;
    private readonly ushort[] FAN_PWM_COMMAND_REG;
    private readonly ushort[] FAN_PWM_OUT_REG;
    private readonly ushort[] FAN_PWM_REQUEST_REG;

    private readonly ushort VENDOR_ID_HIGH_REGISTER;
    private readonly ushort VENDOR_ID_LOW_REGISTER;

    // ReSharper restore InconsistentNaming
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/Lpc/W836XX.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Globalization;
using System.Text;

// ReSharper disable once InconsistentNaming

namespace LibreHardwareMonitor.Hardware.Motherboard.Lpc;

internal class W836XX : ISuperIO
{
    private readonly LpcPort _port;
    private readonly ushort _address;
    private readonly byte _revision;
    private readonly bool[] _peciTemperature = Array.Empty<bool>();
    private readonly byte[] _voltageBank = Array.Empty<byte>();
    private readonly float _voltageGain = 0.008f;
    private readonly byte[] _voltageRegister = Array.Empty<byte>();

    // Added to control fans. 
    private readonly byte[] _fanPwmRegister = Array.Empty<byte>();
    private readonly byte[] _fanPrimaryControlModeRegister = Array.Empty<byte>();
    private readonly byte[] _fanPrimaryControlValue = Array.Empty<byte>();
    private readonly byte[] _fanSecondaryControlModeRegister = Array.Empty<byte>();
    private readonly byte[] _fanSecondaryControlValue = Array.Empty<byte>();
    private readonly byte[] _fanTertiaryControlModeRegister = Array.Empty<byte>();
    private readonly byte[] _fanTertiaryControlValue = Array.Empty<byte>();

    private readonly byte[] _initialFanControlValue = Array.Empty<byte>();
    private readonly byte[] _initialFanSecondaryControlValue = Array.Empty<byte>();
    private readonly byte[] _initialFanTertiaryControlValue = Array.Empty<byte>();
    private readonly bool[] _restoreDefaultFanPwmControlRequired = Array.Empty<bool>();

    public W836XX(LpcPort port, Chip chip, byte revision, ushort address)
    {
        _port = port;
        _address = address;
        _revision = revision;
        Chip = chip;

        if (!IsWinbondVendor())
            return;

        Temperatures = new float?[3];
        _peciTemperature = new bool[3];
        switch (chip)
        {
            case Chip.W83667HG:
            case Chip.W83667HGB:
                // note temperature sensor registers that read PECI
                byte flag = ReadByte(0, TEMPERATURE_SOURCE_SELECT_REG);
                _peciTemperature[0] = (flag & 0x04) != 0;
                _peciTemperature[1] = (flag & 0x40) != 0;
                _peciTemperature[2] = false;
                break;

            case Chip.W83627DHG:
            case Chip.W83627DHGP:
                // note temperature sensor registers that read PECI
                byte sel = ReadByte(0, TEMPERATURE_SOURCE_SELECT_REG);
                _peciTemperature[0] = (sel & 0x07) != 0;
                _peciTemperature[1] = (sel & 0x70) != 0;
                _peciTemperature[2] = false;
                break;

            default:
                // no PECI support
                _peciTemperature[0] = false;
                _peciTemperature[1] = false;
                _peciTemperature[2] = false;
                break;
        }

        switch (chip)
        {
            case Chip.W83627EHF:
                Voltages = new float?[10];
                _voltageRegister = new byte[] { 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x50, 0x51, 0x52 };
                _voltageBank = new byte[] { 0, 0, 0, 0, 0, 0, 0, 5, 5, 5 };
                _voltageGain = 0.008f;

                Fans = new float?[5];
                _fanPwmRegister = new byte[] { 0x01, 0x03, 0x11 }; // Fan PWM values.
                _fanPrimaryControlModeRegister = new byte[] { 0x04, 0x04, 0x12 }; // Primary control register.
                _fanPrimaryControlValue = new byte[] { 0b11110011, 0b11001111, 0b11111001 }; // Values to gain control of fans.
                _initialFanControlValue = new byte[3]; // To store primary default value.
                _initialFanSecondaryControlValue = new byte[3]; // To store secondary default value.

                Controls = new float?[3];
                break;

            case Chip.W83627DHG:
            case Chip.W83627DHGP:
                Voltages = new float?[9];
                _voltageRegister = new byte[] { 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x50, 0x51 };
                _voltageBank = new byte[] { 0, 0, 0, 0, 0, 0, 0, 5, 5 };

                _voltageGain = 0.008f;
                Fans = new float?[5];
                _fanPwmRegister = new byte[] { 0x01, 0x03, 0x11 }; // Fan PWM values
                _fanPrimaryControlModeRegister = new byte[] { 0x04, 0x04, 0x12 }; // added. Primary control register
                _fanPrimaryControlValue = new byte[] { 0b11110011, 0b11001111, 0b11111001 }; // Values to gain control of fans
                _initialFanControlValue = new byte[3]; // To store primary default value
                _initialFanSecondaryControlValue = new byte[3]; // To store secondary default value.

                Controls = new float?[3];
                break;

            case Chip.W83667HG:
            case Chip.W83667HGB:
                Voltages = new float?[9];
                _voltageRegister = new byte[] { 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x50, 0x51 };
                _voltageBank = new byte[] { 0, 0, 0, 0, 0, 0, 0, 5, 5 };
                _voltageGain = 0.008f;

                Fans = new float?[5];
                _fanPwmRegister = new byte[] { 0x01, 0x03, 0x11 }; // Fan PWM values.
                _fanPrimaryControlModeRegister = new byte[] { 0x04, 0x04, 0x12 }; // Primary control register.
                _fanPrimaryControlValue = new byte[] { 0b11110011, 0b11001111, 0b11111001 }; // Values to gain control of fans.
                _fanSecondaryControlModeRegister = new byte[] { 0x7c, 0x7c, 0x7c }; // Secondary control register for SmartFan4.
                _fanSecondaryControlValue = new byte[] { 0b11101111, 0b11011111, 0b10111111 }; // Values for secondary register to gain control of fans.
                _fanTertiaryControlModeRegister = new byte[] { 0x62, 0x7c, 0x62 }; // Tertiary control register. 2nd fan doesn't have Tertiary control, same as secondary to avoid change.
                _fanTertiaryControlValue = new byte[] { 0b11101111, 0b11011111, 0b11011111 }; // Values for tertiary register to gain control of fans. 2nd fan doesn't have Tertiary control, same as secondary to avoid change.

                _initialFanControlValue = new byte[3]; // To store primary default value.
                _initialFanSecondaryControlValue = new byte[3]; // To store secondary default value.
                _initialFanTertiaryControlValue = new byte[3]; // To store tertiary default value.
                Controls = new float?[3];
                break;

            case Chip.W83627HF:
                Voltages = new float?[7];
                _voltageRegister = new byte[] { 0x20, 0x21, 0x22, 0x23, 0x24, 0x50, 0x51 };
                _voltageBank = new byte[] { 0, 0, 0, 0, 0, 5, 5 };
                _voltageGain = 0.016f;

                Fans = new float?[3];
                _fanPwmRegister = new byte[] { 0x5A, 0x5B }; // Fan PWM values.

                Controls = new float?[2];
                break;

            case Chip.W83627THF:
                Voltages = new float?[7];
                _voltageRegister = new byte[] { 0x20, 0x21, 0x22, 0x23, 0x24, 0x50, 0x51 };
                _voltageBank = new byte[] { 0, 0, 0, 0, 0, 5, 5 };
                _voltageGain = 0.016f;

                Fans = new float?[3];
                _fanPwmRegister = new byte[] { 0x01, 0x03, 0x11 }; // Fan PWM values.
                _fanPrimaryControlModeRegister = new byte[] { 0x04, 0x04, 0x12 }; // Primary control register.
                _fanPrimaryControlValue = new byte[] { 0b11110011, 0b11001111, 0b11111001 }; // Values to gain control of fans.
                _initialFanControlValue = new byte[3]; // To store primary default value.

                Controls = new float?[3];
                break;

            case Chip.W83687THF:
                Voltages = new float?[7];
                _voltageRegister = new byte[] { 0x20, 0x21, 0x22, 0x23, 0x24, 0x50, 0x51 };
                _voltageBank = new byte[] { 0, 0, 0, 0, 0, 5, 5 };
                _voltageGain = 0.016f;

                Fans = new float?[3];
                break;
        }
    }

    public Chip Chip { get; }

    public float?[] Controls { get; } = Array.Empty<float?>();

    public float?[] Fans { get; } = Array.Empty<float?>();

    public float?[] Temperatures { get; } = Array.Empty<float?>();

    public float?[] Voltages { get; } = Array.Empty<float?>();

    public byte? ReadGpio(int index)
    {
        return null;
    }

    public void WriteGpio(int index, byte value)
    { }

    public void SetControl(int index, byte? value)
    {
        if (index < 0 || index >= Controls.Length)
            throw new ArgumentOutOfRangeException(nameof(index));

        if (!Mutexes.WaitIsaBus(10))
            return;

        if (value.HasValue)
        {
            SaveDefaultFanPwmControl(index);
            if (_fanPrimaryControlModeRegister.Length > 0)
            {
                WriteByte(0, _fanPrimaryControlModeRegister[index], (byte)(_fanPrimaryControlValue[index] & ReadByte(0, _fanPrimaryControlModeRegister[index])));
                if (_fanSecondaryControlModeRegister.Length > 0)
                {
                    if (_fanSecondaryControlModeRegister[index] != _fanPrimaryControlModeRegister[index])
                    {
                        WriteByte(0, _fanSecondaryControlModeRegister[index], (byte)(_fanSecondaryControlValue[index] & ReadByte(0, _fanSecondaryControlModeRegister[index])));
                    }

                    if (_fanTertiaryControlModeRegister.Length > 0 && _fanTertiaryControlModeRegister[index] != _fanSecondaryControlModeRegister[index])
                    {
                        WriteByte(0, _fanTertiaryControlModeRegister[index], (byte)(_fanTertiaryControlValue[index] & ReadByte(0, _fanTertiaryControlModeRegister[index])));
                    }
                }
            }

            // set output value
            WriteByte(0, _fanPwmRegister[index], value.Value);
        }
        else
        {
            RestoreDefaultFanPwmControl(index);
        }

        Mutexes.ReleaseIsaBus();
    }

    private void SaveDefaultFanPwmControl(int index) //added to save initial control values
    {
        if (_fanPrimaryControlModeRegister.Length > 0 &&
            _initialFanControlValue.Length > 0 &&
            _fanPrimaryControlValue.Length > 0 &&
            _restoreDefaultFanPwmControlRequired.Length > 0 &&
            !_restoreDefaultFanPwmControlRequired[index])
        {
            _initialFanControlValue[index] = ReadByte(0, _fanPrimaryControlModeRegister[index]);
            if (_fanSecondaryControlModeRegister.Length > 0 && _initialFanSecondaryControlValue.Length > 0 && _fanSecondaryControlValue.Length > 0)
            {
                if (_fanSecondaryControlModeRegister[index] != _fanPrimaryControlModeRegister[index])
                {
                    _initialFanSecondaryControlValue[index] = ReadByte(0, _fanSecondaryControlModeRegister[index]);
                }

                if (_fanTertiaryControlModeRegister.Length > 0 &&
                    _initialFanTertiaryControlValue.Length > 0 &&
                    _fanTertiaryControlValue.Length > 0 &&
                    _fanTertiaryControlModeRegister[index] != _fanSecondaryControlModeRegister[index])
                {
                    _initialFanTertiaryControlValue[index] = ReadByte(0, _fanTertiaryControlModeRegister[index]);
                }
            }

            _restoreDefaultFanPwmControlRequired[index] = true;
        }
    }

    private void RestoreDefaultFanPwmControl(int index) //added to restore initial control values
    {
        if (_fanPrimaryControlModeRegister.Length > 0 &&
            _initialFanControlValue.Length > 0 &&
            _fanPrimaryControlValue.Length > 0 &&
            _restoreDefaultFanPwmControlRequired.Length > 0 &&
            _restoreDefaultFanPwmControlRequired[index])
        {
            WriteByte(0,
                      _fanPrimaryControlModeRegister[index],
                      (byte)((_initialFanControlValue[index] & ~_fanPrimaryControlValue[index]) |
                             ReadByte(0, _fanPrimaryControlModeRegister[index]))); //bitwise operands to change only desired bits

            if (_fanSecondaryControlModeRegister.Length > 0 && _initialFanSecondaryControlValue.Length > 0 && _fanSecondaryControlValue.Length > 0)
            {
                if (_fanSecondaryControlModeRegister[index] != _fanPrimaryControlModeRegister[index])
                {
                    WriteByte(0,
                              _fanSecondaryControlModeRegister[index],
                              (byte)((_initialFanSecondaryControlValue[index] & ~_fanSecondaryControlValue[index]) |
                                     ReadByte(0, _fanSecondaryControlModeRegister[index]))); //bitwise operands to change only desired bits
                }

                if (_fanTertiaryControlModeRegister.Length > 0 &&
                    _initialFanTertiaryControlValue.Length > 0 &&
                    _fanTertiaryControlValue.Length > 0 &&
                    _fanTertiaryControlModeRegister[index] != _fanSecondaryControlModeRegister[index])
                {
                    WriteByte(0,
                              _fanTertiaryControlModeRegister[index],
                              (byte)((_initialFanTertiaryControlValue[index] & ~_fanTertiaryControlValue[index]) | ReadByte(0, _fanTertiaryControlModeRegister[index]))); //bitwise operands to change only desired bits
                }
            }

            _restoreDefaultFanPwmControlRequired[index] = false;
        }
    }

    public void Update()
    {
        if (!Mutexes.WaitIsaBus(10))
            return;

        for (int i = 0; i < Voltages.Length; i++)
        {
            if (_voltageRegister[i] != VOLTAGE_VBAT_REG)
            {
                // two special VCore measurement modes for W83627THF
                float fValue;
                if ((Chip == Chip.W83627HF || Chip == Chip.W83627THF || Chip == Chip.W83687THF) && i == 0)
                {
                    byte vrmConfiguration = ReadByte(0, 0x18);
                    int value = ReadByte(_voltageBank[i], _voltageRegister[i]);
                    if ((vrmConfiguration & 0x01) == 0)
                        fValue = 0.016f * value; // VRM8 formula
                    else
                        fValue = (0.00488f * value) + 0.69f; // VRM9 formula
                }
                else
                {
                    int value = ReadByte(_voltageBank[i], _voltageRegister[i]);
                    fValue = _voltageGain * value;
                }

                if (fValue > 0)
                    Voltages[i] = fValue;
                else
                    Voltages[i] = null;
            }
            else
            {
                // Battery voltage
                bool valid = (ReadByte(0, 0x5D) & 0x01) > 0;
                if (valid)
                {
                    Voltages[i] = _voltageGain * ReadByte(5, VOLTAGE_VBAT_REG);
                }
                else
                {
                    Voltages[i] = null;
                }
            }
        }

        for (int i = 0; i < Temperatures.Length; i++)
        {
            int value = (sbyte)ReadByte(TEMPERATURE_BANK[i], TEMPERATURE_REG[i]) << 1;
            if (TEMPERATURE_BANK[i] > 0)
                value |= ReadByte(TEMPERATURE_BANK[i], (byte)(TEMPERATURE_REG[i] + 1)) >> 7;

            float temperature = value / 2.0f;
            if (temperature is <= 125 and >= -55 && !_peciTemperature[i])
            {
                Temperatures[i] = temperature;
            }
            else
            {
                Temperatures[i] = null;
            }
        }

        ulong bits = 0;
        foreach (byte t in FAN_BIT_REG)
            bits = (bits << 8) | ReadByte(0, t);

        ulong newBits = bits;
        for (int i = 0; i < Fans.Length; i++)
        {
            int count = ReadByte(FAN_TACHO_BANK[i], FAN_TACHO_REG[i]);

            // assemble fan divisor
            int divisorBits = (int)(
                (((bits >> FAN_DIV_BIT2[i]) & 1) << 2) |
                (((bits >> FAN_DIV_BIT1[i]) & 1) << 1) |
                ((bits >> FAN_DIV_BIT0[i]) & 1));

            int divisor = 1 << divisorBits;

            Fans[i] = count < 0xff ? 1.35e6f / (count * divisor) : 0;

            switch (count)
            {
                // update fan divisor
                case > 192 when divisorBits < 7:
                    divisorBits++;
                    break;
                case < 96 when divisorBits > 0:
                    divisorBits--;
                    break;
            }

            newBits = SetBit(newBits, FAN_DIV_BIT2[i], (divisorBits >> 2) & 1);
            newBits = SetBit(newBits, FAN_DIV_BIT1[i], (divisorBits >> 1) & 1);
            newBits = SetBit(newBits, FAN_DIV_BIT0[i], divisorBits & 1);
        }

        for (int i = 0; i < Controls.Length; i++)
        {
            byte value = ReadByte(0, _fanPwmRegister[i]);
            Controls[i] = (float)Math.Round(value * 100.0f / 0xFF);
        }

        Mutexes.ReleaseIsaBus();
    }

    /// <inheritdoc />
    public void Close()
    {
        _port.Close();
    }

    public string GetReport()
    {
        StringBuilder r = new();

        r.AppendLine("LPC " + GetType().Name);
        r.AppendLine();
        r.Append("Chip Id: 0x");
        r.AppendLine(Chip.ToString("X"));
        r.Append("Chip Revision: 0x");
        r.AppendLine(_revision.ToString("X", CultureInfo.InvariantCulture));
        r.Append("Base Address: 0x");
        r.AppendLine(_address.ToString("X4", CultureInfo.InvariantCulture));
        r.AppendLine();

        if (!Mutexes.WaitIsaBus(100))
            return r.ToString();

        r.AppendLine("Hardware Monitor Registers");
        r.AppendLine();
        r.AppendLine("      00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F");
        r.AppendLine();
        for (int i = 0; i <= 0x7; i++)
        {
            r.Append(" ");
            r.Append((i << 4).ToString("X2", CultureInfo.InvariantCulture));
            r.Append("  ");
            for (int j = 0; j <= 0xF; j++)
            {
                r.Append(" ");
                r.Append(ReadByte(0, (byte)((i << 4) | j)).ToString("X2", CultureInfo.InvariantCulture));
            }

            r.AppendLine();
        }

        for (int k = 1; k <= 15; k++)
        {
            r.AppendLine("Bank " + k);
            for (int i = 0x5; i < 0x6; i++)
            {
                r.Append(" ");
                r.Append((i << 4).ToString("X2", CultureInfo.InvariantCulture));
                r.Append("  ");
                for (int j = 0; j <= 0xF; j++)
                {
                    r.Append(" ");
                    r.Append(ReadByte((byte)k, (byte)((i << 4) | j)).ToString("X2", CultureInfo.InvariantCulture));
                }

                r.AppendLine();
            }
        }

        r.AppendLine();
        Mutexes.ReleaseIsaBus();
        return r.ToString();
    }

    private byte ReadByte(byte bank, byte register)
    {
        _port.WriteIoPort((ushort)(_address + ADDRESS_REGISTER_OFFSET), BANK_SELECT_REGISTER);
        _port.WriteIoPort((ushort)(_address + DATA_REGISTER_OFFSET), bank);
        _port.WriteIoPort((ushort)(_address + ADDRESS_REGISTER_OFFSET), register);
        return _port.ReadIoPort((ushort)(_address + DATA_REGISTER_OFFSET));
    }

    private void WriteByte(byte bank, byte register, byte value)
    {
        _port.WriteIoPort((ushort)(_address + ADDRESS_REGISTER_OFFSET), BANK_SELECT_REGISTER);
        _port.WriteIoPort((ushort)(_address + DATA_REGISTER_OFFSET), bank);
        _port.WriteIoPort((ushort)(_address + ADDRESS_REGISTER_OFFSET), register);
        _port.WriteIoPort((ushort)(_address + DATA_REGISTER_OFFSET), value);
    }

    private bool IsWinbondVendor()
    {
        ushort vendorId = (ushort)((ReadByte(HIGH_BYTE, VENDOR_ID_REGISTER) << 8) | ReadByte(0, VENDOR_ID_REGISTER));
        return vendorId == WINBOND_VENDOR_ID;
    }

    private static ulong SetBit(ulong target, int bit, int value)
    {
        if ((value & 1) != value)
            throw new ArgumentException("Value must be one bit only.");

        if (bit is < 0 or > 63)
            throw new ArgumentException("Bit out of range.");

        ulong mask = (ulong)1 << bit;
        return value > 0 ? target | mask : target & ~mask;
    }
    // ReSharper disable InconsistentNaming

    private const byte ADDRESS_REGISTER_OFFSET = 0x05;
    private const byte BANK_SELECT_REGISTER = 0x4E;
    private const byte DATA_REGISTER_OFFSET = 0x06;
    private const byte HIGH_BYTE = 0x80;
    private const byte TEMPERATURE_SOURCE_SELECT_REG = 0x49;
    private const byte VENDOR_ID_REGISTER = 0x4F;
    private const byte VOLTAGE_VBAT_REG = 0x51;

    private const ushort WINBOND_VENDOR_ID = 0x5CA3;

    private readonly byte[] FAN_BIT_REG = { 0x47, 0x4B, 0x4C, 0x59, 0x5D };
    private readonly byte[] FAN_DIV_BIT0 = { 36, 38, 30, 8, 10 };
    private readonly byte[] FAN_DIV_BIT1 = { 37, 39, 31, 9, 11 };
    private readonly byte[] FAN_DIV_BIT2 = { 5, 6, 7, 23, 15 };
    private readonly byte[] FAN_TACHO_BANK = { 0, 0, 0, 0, 5 };
    private readonly byte[] FAN_TACHO_REG = { 0x28, 0x29, 0x2A, 0x3F, 0x53 };
    private readonly byte[] TEMPERATURE_BANK = { 1, 2, 0 };
    private readonly byte[] TEMPERATURE_REG = { 0x50, 0x50, 0x27 };

    // ReSharper restore InconsistentNaming
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/Manufacturer.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Diagnostics.CodeAnalysis;

namespace LibreHardwareMonitor.Hardware.Motherboard;

[SuppressMessage("ReSharper", "IdentifierTypo")]
[SuppressMessage("ReSharper", "CommentTypo")]
[SuppressMessage("ReSharper", "InconsistentNaming")]
public enum Manufacturer
{
    Abit,
    Acer,
    Alienware,
    AMD,
    AOpen,
    Apple,
    ASRock,
    ASUS,
    Biostar,
    Clevo,
    Dell,
    DFI,
    ECS,
    EPoX,
    EVGA,
    FIC,
    Foxconn,
    Framework,
    Fujitsu,
    Gateway,
    Gigabyte,
    HP,
    IBM,
    Intel,
    Jetway,
    LattePanda,
    Lenovo,
    Medion,
    Microsoft,
    MSI,
    NEC,
    Pegatron,
    Samsung,
    Sapphire,
    Shuttle,
    Sony,
    Supermicro,
    Toshiba,
    XFX,
    Zotac,
    Unknown
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/Model.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

// ReSharper disable InconsistentNaming

using System.Diagnostics.CodeAnalysis;

namespace LibreHardwareMonitor.Hardware.Motherboard;

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
/// <summary>
/// Known motherboard models detected/recognized by LibreHardwareMonitor.
/// </summary>
[SuppressMessage("ReSharper", "IdentifierTypo")]
[SuppressMessage("ReSharper", "CommentTypo")]
public enum Model
{
    // ASRock
    _880GMH_USB3,
    A320M_HDV,
    AB350_Pro4,
    AB350M,
    AB350M_HDV,
    AB350M_Pro4,
    AOD790GX_128M,
    B450_Pro4,
    B450_Steel_Legend,
    B450M_Pro4,
    B450M_Pro4_R2_0,
    B450M_Steel_Legend,
    B85M_DGS,
    Fatal1ty_AB350_Gaming_K4,
    P55_Deluxe,
    X399_Phantom_Gaming_6,
    Z77Pro4M,
    X570_Pro4,
    X570_Taichi,
    X570_Phantom_Gaming_ITX,
    Z690_Extreme,
    Z690_Steel_Legend,
    Z790_Pro_RS,
    X570_Phantom_Gaming_4,
    Z790_Taichi,
    Z790_Nova_WiFi,
    B650M_C,
    H61M_DGS,
    B850M_STEEL_LEGEND_WIFI,
    X870E_TAICHI,
    X870E_NOVA_WIFI,

    // ASUS
    CROSSHAIR_III_FORMULA,
    ROG_CROSSHAIR_VIII_HERO,
    ROG_CROSSHAIR_VIII_HERO_WIFI,
    ROG_CROSSHAIR_VIII_DARK_HERO,
    ROG_CROSSHAIR_VIII_FORMULA,
    ROG_CROSSHAIR_VIII_IMPACT,
    ROG_STRIX_X470_I,
    ROG_CROSSHAIR_X670E_EXTREME,
    ROG_CROSSHAIR_X670E_HERO,
    ROG_CROSSHAIR_X670E_GENE,
    ROG_STRIX_X670E_A_GAMING_WIFI,
    ROG_STRIX_X670E_E_GAMING_WIFI,
    ROG_STRIX_X670E_F_GAMING_WIFI,
    PROART_X670E_CREATOR_WIFI,
    ROG_STRIX_X570_E_GAMING,
    ROG_STRIX_X570_E_GAMING_WIFI_II,
    ROG_STRIX_X570_F_GAMING,
    ROG_STRIX_X570_I_GAMING,
    ROG_STRIX_B550_E_GAMING,
    ROG_STRIX_B550_F_GAMING_WIFI,
    ROG_STRIX_B550_I_GAMING,
    ROG_STRIX_B760_I_GAMING_WIFI,
    ROG_STRIX_Z390_E_GAMING,
    ROG_STRIX_Z390_F_GAMING,
    ROG_STRIX_Z390_I_GAMING,
    ROG_STRIX_Z690_A_GAMING_WIFI_D4,
    ROG_STRIX_Z690_G_GAMING_WIFI,
    ROG_STRIX_B850_E_GAMING_WIFI,
    ROG_STRIX_B850_I_GAMING_WIFI,
    ROG_MAXIMUS_XI_FORMULA,
    ROG_MAXIMUS_XII_Z490_FORMULA,
    ROG_MAXIMUS_X_HERO_WIFI_AC,
    ROG_MAXIMUS_Z690_FORMULA,
    ROG_MAXIMUS_Z690_HERO,
    ROG_MAXIMUS_Z690_EXTREME_GLACIAL,
    ROG_STRIX_Z790_I_GAMING_WIFI,
    ROG_STRIX_Z790_E_GAMING_WIFI,
    ROG_STRIX_Z790_E_GAMING_WIFI_II,
    M2N_SLI_Deluxe,
    M4A79XTD_EVO,
    P5W_DH_Deluxe,
    P6T,
    P6X58D_E,
    P8P67,
    P8P67_EVO,
    P8P67_M_PRO,
    P8P67_PRO,
    P8Z77_V,
    P9X79,
    PRIME_B650_PLUS,
    PRIME_X370_PRO,
    PRIME_X470_PRO,
    PRIME_X570_PRO,
    PROART_X570_CREATOR_WIFI,
    PRO_WS_X570_ACE,
    RAMPAGE_EXTREME,
    RAMPAGE_II_GENE,
    ROG_MAXIMUS_X_APEX,
    ROG_ZENITH_EXTREME,
    ROG_ZENITH_II_EXTREME,
    TUF_X470_PLUS_GAMING,
    TUF_GAMING_X870_PLUS_WIFI,
    Z170_A,
    Z170_PRO_GAMING,
    B150M_C,
    B150M_C_D3,
    TUF_GAMING_X570_PLUS_WIFI,
    TUF_GAMING_B550M_PLUS_WIFI,
    TUF_GAMING_B760M_PLUS_WIFI_D4,
    ROG_MAXIMUS_Z790_HERO,
    ROG_MAXIMUS_Z790_DARK_HERO,
    PRIME_Z690_A,
    ROG_MAXIMUS_Z790_FORMULA,
    ROG_MAXIMUS_XII_HERO_WIFI,
    ROG_STRIX_X870_I_GAMING_WIFI,
    PRIME_X870_P,
    ROG_CROSSHAIR_X870E_APEX,
    ROG_CROSSHAIR_X870E_HERO,
    ROG_STRIX_X870E_E_GAMING_WIFI,
    PROART_X870E_CREATOR_WIFI,
    PROART_B760_CREATOR_D4,
    TUF_GAMING_B450_PLUS_II,
    TUF_GAMING_B850M_PLUS_II,

    //BIOSTAR
    B660GTN,
    X670E_Valkyrie,

    // DFI
    LP_BI_P45_T2RS_Elite,
    LP_DK_P55_T3EH9,

    // ECS
    A890GXM_A,

    // MSI
    B350_Gaming_Plus,
    B360M_PRO_VDH,
    B450A_PRO,
    B550A_PRO,
    B650M_Gaming_Plus_Wifi,
    Z270_PC_MATE,
    Z77_MS7751,
    Z68_MS7672,
    X570_Gaming_Plus,
    X570_MS7C35,
    B850M_MORTAR,
    B850M_MORTAR_WIFI,
    B850_GAMING_PLUS_WIFI,
    B850_GAMING_PLUS_WIFI6E,
    B850_GAMING_PLUS_WIFI_PZ,
    B850M_GAMING_PLUS_WIFI,
    B850M_GAMING_PLUS_WIFI6E,
    B840P_PRO_WIFI,
    B840M_GAMING_PLUS_WIFI6E,
    B850_TOMAHAWK_WIFI,
    B850_TOMAHAWK_MAX_WIFI,
    B650M_PROJECT_ZERO,
    B850P_PRO_WIFI,
    B850MA_PRO_WIFI,
    B850MA_PRO_WIFI_PZ,
    B850MP_PRO_WIFI,
    B850_EDGE_TI_WIFI,
    B850I_EDGE_TI_WIFI,
    B850MPOWER,
    X870_GAMING_PLUS_WIFI,
    X870E_GAMING_PLUS_WIFI,
    X870_TOMAHAWK_WIFI,
    X870E_TOMAHAWK_WIFI,
    X870E_TOMAHAWK_MAX_WIFI_PZ,
    X870E_GODLIKE,
    X870P_PRO_WIFI,
    X870EP_PRO_WIFI,
    X870E_CARBON_WIFI,
    X870E_EDGE_TI_WIFI,
    X870E_ACE_MAX,
    Z790_GODLIKE_MAX,
    Z890_ACE,
    Z890_TOMAHAWK_WIFI,
    Z890_CARBON_WIFI,
    Z890_EDGE_TI_WIFI,
    Z890_UNIFY_X,
    Z890I_EDGE_TI_WIFI,
    Z890P_PRO_WIFI,
    Z890A_PRO_WIFI,
    Z890S_PRO_WIFI,
    Z890_GAMING_PLUS_WIFI,
    Z890S_PRO_WIFI_PROJECT_ZERO,
    B850S_PRO_WIFI6E,
    Z390_GAMING_EDGE_AC,

    // EVGA
    X58_SLI_Classified,
    X58_3X_SLI,

    // Gigabyte
    _965P_S3,
    _970A_DS3P,
    _970A_UD3,
    AB350_Gaming_3,
    AX370_Gaming_5,
    AX370_Gaming_K7,
    A320M_S2H_CF,
    B360M_H,
    B360_AORUS_GAMING_3_WIFI_CF,
    B550_AORUS_MASTER,
    B550_AORUS_PRO,
    B550_AORUS_PRO_AC,
    B550_AORUS_PRO_AX,
    B550_VISION_D,
    B550_AORUS_ELITE,
    B550_AORUS_ELITE_AX,
    B550_GAMING_X,
    B550_UD_AC,
    B550M_AORUS_PRO,
    B550M_AORUS_PRO_AX,
    B550M_AORUS_ELITE,
    B550M_GAMING,
    B550M_DS3H,
    B550M_DS3H_AC,
    B550M_S2H,
    B550M_H,
    B550I_AORUS_PRO_AX,
    B560M_AORUS_ELITE,
    B560M_AORUS_PRO,
    B560M_AORUS_PRO_AX,
    B560I_AORUS_PRO_AX,
    B650_EAGLE_AX,
    B660_DS3H_DDR4,
    B660_DS3H_AC_DDR4,
    B660M_DS3H_AX_DDR4,
    EP45_DS3R,
    EP45_UD3R,
    EX58_EXTREME,
    EX58_UD3R,
    G41M_COMBO,
    G41MT_S2,
    G41MT_S2P,
    H55_USB3,
    H55N_USB3,
    H61M_DS2_REV_1_2,
    H61M_USB3_B3_REV_2_0,
    H67A_UD3H_B3,
    H67A_USB3_B3,
    H97_D3H,
    H81M_HD3,
    B75M_D3H,
    MA770T_UD3,
    MA770T_UD3P,
    MA785GM_US2H,
    MA785GMT_UD2H,
    MA78LM_S2H,
    MA790X_UD3P,
    MA790X_DS4,
    P35_DS3,
    P35_DS3L,
    P55_UD4,
    P55A_UD3,
    P55M_UD4,
    P67A_UD3_B3,
    P67A_UD3R_B3,
    P67A_UD4_B3,
    P8Z68_V_PRO,
    X38_DS5,
    X399_AORUS_Gaming_7,
    X58A_UD3R,
    X79_UD3,
    Z390_AORUS_ULTRA,
    Z390_AORUS_PRO,
    Z390_M_GAMING,
    Z390_UD,
    Z68A_D3H_B3,
    Z68AP_D3,
    Z68X_UD3H_B3,
    Z68X_UD7_B3,
    Z68XP_UD3R,
    Z690_AORUS_PRO,
    Z690_AORUS_ULTRA,
    Z690_AORUS_MASTER,
    Z690_GAMING_X_DDR4,
    Z790_AORUS_PRO_X,
    Z790_UD,
    Z790_UD_AC,
    Z790_GAMING_X,
    Z790_GAMING_X_AX,
    Z170N_WIFI,
    B450_AORUS_M,
    B450_AORUS_PRO,
    B450_GAMING_X,
    B450_AORUS_ELITE,
    B450M_AORUS_ELITE,
    B450M_GAMING,
    B450_I_AORUS_PRO_WIFI,
    B450M_DS3H,
    B450M_S2H,
    B450M_H,
    B450M_K,
    X470_AORUS_GAMING_7_WIFI,
    X570_AORUS_MASTER,
    X570_AORUS_PRO,
    X570_GAMING_X,
    X570_AORUS_ULTRA,
    B650_AORUS_ELITE,
    B650_AORUS_ELITE_AX,
    B650_AORUS_ELITE_V2,
    B650_AORUS_ELITE_AX_V2,
    B650_AORUS_ELITE_AX_ICE,
    B650_GAMING_X_AX,
    B650E_AORUS_ELITE_AX_ICE,
    B650M_AORUS_PRO,
    B650M_AORUS_PRO_AX,
    B650M_AORUS_ELITE,
    B650M_AORUS_ELITE_AX,
    B650I_AX,
    X670E_AORUS_XTREME,
    X870E_AORUS_PRO,
    X870E_AORUS_PRO_ICE,
    X870E_AORUS_XTREME_AI_TOP,
    X870_AORUS_ELITE_WIFI7,
    X870_AORUS_ELITE_WIFI7_ICE,
    X670_AORUS_ELITE_AX,

    // Shuttle
    FH67,

    //Supermicro
    X11SWN_E,

    // Framework
    FRANBMCP03, // Intel Core i5-1135G7
    FRANBMCP06, // Intel Core i7-1165G7
    FRANBMCP08, // Intel Core i7-1185G7
    FRANBMCP0A, // Intel Core i5-1135G7
    FRANBMCP0B, // Intel Core i7-1165G7
    FRANBMCP0C, // Intel Core i7-1185G7
    FRANGACP04, // Intel Core i5-1240P
    FRANGACP06, // Intel Core i7-1260P
    FRANGACP08, // Intel Core i7-1280P
    FRANMACP04, // Intel Core i5-1240P
    FRANMACP06, // Intel Core i7-1260P
    FRANMACP08, // Intel Core i7-1280P
    FRANMCCP04, // Intel Core i5-1340P
    FRANMCCP06, // Intel Core i7-1360P
    FRANMCCP07, // Intel Core i7-1370P
    FRANMDCP05, // FW13 AMD Ryzen 5 7640U
    FRANMDCP07, // FW13 AMD Ryzen 7 7840U
    FRANMECP02, // FW13 Intel Core Ultra 5 125H
    FRANMECP05, // FW13 Intel Core Ultra 7 155H
    FRANMECP06, // FW13 Intel Core Ultra 7 165H
    FRANMZCP07, // FW16 AMD Ryzen 7 7840HS
    FRANMZCP09, // FW16 AMD Ryzen 9 7940HS
    FRANMFCP02, // Desktop AMD RYZEN AI MAX 385
    FRANMFCP06, // Desktop AMD RYZEN AI MAX+ 395
    FRAPMACP03, // FW12 Intel Core i3-1315U
    FRAPMACP05, // FW12 Intel Core i5-1334U
    FRANMGCP05, // FW13 AMD Ryzen AI 5 340
    FRANMGCP07, // FW13 AMD Ryzen AI 7 350
    FRANMGCP09, // FW13 AMD Ryzen AI 9 HX 370

    // Unknown
    Unknown
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/Motherboard.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using LibreHardwareMonitor.Hardware.Motherboard.Lpc;
using LibreHardwareMonitor.Hardware.Motherboard.Lpc.EC;
using OperatingSystem = LibreHardwareMonitor.Software.OperatingSystem;

namespace LibreHardwareMonitor.Hardware.Motherboard;

/// <summary>
/// Represents the motherboard of a computer with its <see cref="LpcIO" /> and <see cref="EmbeddedController" /> as <see cref="SubHardware" />.
/// </summary>
public class Motherboard : IHardware
{
    private readonly LMSensors _lmSensors;
    private readonly LpcIO _lpcIO;
    private readonly string _name;
    private readonly ISettings _settings;
    private string _customName;

    /// <summary>
    /// Creates motherboard instance by retrieving information from <see cref="LibreHardwareMonitor.Hardware.SMBios" /> and creates a new <see cref="SubHardware" /> based on data from <see cref="LpcIO" />
    /// and <see cref="EmbeddedController" />.
    /// </summary>
    /// <param name="smBios"><see cref="LibreHardwareMonitor.Hardware.SMBios" /> table containing motherboard data.</param>
    /// <param name="settings">Additional settings passed by <see cref="IComputer" />.</param>
    public Motherboard(SMBios smBios, ISettings settings)
    {
        IReadOnlyList<ISuperIO> superIO;
        _settings = settings;
        SMBios = smBios;

        Manufacturer = smBios.Board == null ? Manufacturer.Unknown : Identification.GetManufacturer(smBios.Board.ManufacturerName);
        Model = smBios.Board == null ? Model.Unknown : Identification.GetModel(smBios.Board.ProductName);

        if (smBios.Board != null)
        {
            if (!string.IsNullOrEmpty(smBios.Board.ProductName))
            {
                if (Manufacturer == Manufacturer.Unknown)
                    _name = smBios.Board.ProductName;
                else
                    _name = Manufacturer + " " + smBios.Board.ProductName;
            }
            else
            {
                _name = Manufacturer.ToString();
            }
        }
        else
        {
            _name = nameof(Manufacturer.Unknown);
        }

        _customName = settings.GetValue(new Identifier(Identifier, "name").ToString(), _name);

        if (OperatingSystem.IsUnix)
        {
            _lmSensors = new LMSensors();
            superIO = _lmSensors.SuperIO;
        }
        else
        {
            _lpcIO = new LpcIO(this);
            superIO = _lpcIO.SuperIO;
        }


        EmbeddedController embeddedController = EmbeddedController.Create(Model, settings);

        List<IHardware> subHardwareList = new List<IHardware>();

        // there may be more than 1 of the same SuperIO chip
        // group by chip
        foreach (IGrouping<Chip, ISuperIO> group in superIO.GroupBy(x => x.Chip))
        {
            // index by group
            foreach ((ISuperIO superIo, int i) in group.Select((x, i) => (x, i)))
            {
                subHardwareList.Add(new SuperIOHardware(this, superIo, Manufacturer, Model, settings, i));
            }
        }

        if (embeddedController != null)
            subHardwareList.Add(embeddedController);

        SubHardware = subHardwareList.ToArray();
    }

#pragma warning disable 67
    /// <inheritdoc />
    public event SensorEventHandler SensorAdded;

    /// <inheritdoc />
    public event SensorEventHandler SensorRemoved;
#pragma warning restore 67

    /// <inheritdoc />
    public HardwareType HardwareType => HardwareType.Motherboard;

    /// <inheritdoc />
    public Identifier Identifier => new("motherboard");

    /// <summary>
    /// Gets the <see cref="LibreHardwareMonitor.Hardware.Motherboard.Manufacturer" />.
    /// </summary>
    public Manufacturer Manufacturer { get; }

    /// <summary>
    /// Gets the <see cref="LibreHardwareMonitor.Hardware.Motherboard.Model" />.
    /// </summary>
    public Model Model { get; }

    /// <summary>
    /// Gets the name obtained from <see cref="LibreHardwareMonitor.Hardware.SMBios" />.
    /// </summary>
    public string Name
    {
        get { return _customName; }
        set
        {
            _customName = !string.IsNullOrEmpty(value) ? value : _name;

            _settings.SetValue(new Identifier(Identifier, "name").ToString(), _customName);
        }
    }

    /// <inheritdoc />
    /// <returns>Always <see langword="null" /></returns>
    public virtual IHardware Parent
    {
        get { return null; }
    }

    /// <inheritdoc />
    public virtual IDictionary<string, string> Properties => new SortedDictionary<string, string>();

    /// <inheritdoc />
    public ISensor[] Sensors
    {
        get { return Array.Empty<ISensor>(); }
    }

    /// <summary>
    /// Gets the <see cref="LibreHardwareMonitor.Hardware.SMBios" /> information.
    /// </summary>
    public SMBios SMBios { get; }

    /// <inheritdoc />
    public IHardware[] SubHardware { get; }

    /// <inheritdoc />
    public string GetReport()
    {
        StringBuilder r = new();

        r.AppendLine("Motherboard");
        r.AppendLine();
        r.Append(SMBios.GetReport());

        if (_lpcIO != null)
            r.Append(_lpcIO.GetReport());

        return r.ToString();
    }

    /// <summary>
    /// Motherboard itself cannot be updated. Update <see cref="SubHardware" /> instead.
    /// </summary>
    public void Update()
    { }

    /// <inheritdoc />
    public void Accept(IVisitor visitor)
    {
        if (visitor == null)
            throw new ArgumentNullException(nameof(visitor));

        visitor.VisitHardware(this);
    }

    /// <inheritdoc />
    public void Traverse(IVisitor visitor)
    {
        foreach (IHardware hardware in SubHardware)
            hardware.Accept(visitor);
    }

    /// <summary>
    /// Closes <see cref="SubHardware" /> using <see cref="Hardware.Close" />.
    /// </summary>
    public void Close()
    {
        foreach (IHardware iHardware in SubHardware)
        {
            if (iHardware is Hardware hardware)
                hardware.Close();
        }

        _lmSensors?.Close();
        _lpcIO?.Close();
    }
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/MotherboardGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Collections.Generic;

namespace LibreHardwareMonitor.Hardware.Motherboard;

internal class MotherboardGroup : IGroup
{
    private readonly Motherboard[] _motherboards;

    public MotherboardGroup(SMBios smbios, ISettings settings)
    {
        _motherboards = new Motherboard[1];
        _motherboards[0] = new Motherboard(smbios, settings);
    }

    public IReadOnlyList<IHardware> Hardware => _motherboards;

    public void Close()
    {
        foreach (Motherboard mainboard in _motherboards)
            mainboard.Close();
    }

    public string GetReport()
    {
        return null;
    }
}
```

`LibreHardwareMonitorLib/Hardware/Motherboard/SuperIOHardware.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using System.Threading;
using LibreHardwareMonitor.Hardware.Motherboard.Lpc;

namespace LibreHardwareMonitor.Hardware.Motherboard;

internal sealed class SuperIOHardware : Hardware
{
    private readonly List<Sensor> _controls = [];
    private readonly List<Sensor> _fans = [];
    private readonly Motherboard _motherboard;

    private readonly UpdateDelegate _postUpdate;
    private readonly ReadValueDelegate _readControl;
    private readonly ReadValueDelegate _readFan;
    private readonly ReadValueDelegate _readTemperature;
    private readonly ReadValueDelegate _readVoltage;

    private readonly ISuperIO _superIO;
    private readonly List<Sensor> _temperatures = [];
    private readonly List<Sensor> _voltages = [];

    public SuperIOHardware(Motherboard motherboard, ISuperIO superIO, Manufacturer manufacturer, Model model, ISettings settings, int index)
        : base(ChipName.GetName(superIO.Chip), new Identifier("lpc", superIO.Chip.ToString().ToLowerInvariant(), index.ToString()), settings)
    {
        _motherboard = motherboard;
        _superIO = superIO;

        GetBoardSpecificConfiguration(superIO,
                                      manufacturer,
                                      model,
                                      index,
                                      out IList<Voltage> v,
                                      out IList<Temperature> t,
                                      out IList<Fan> f,
                                      out IList<Control> c,
                                      out _readVoltage,
                                      out _readTemperature,
                                      out _readFan,
                                      out _readControl,
                                      out _postUpdate,
                                      out _);

        CreateVoltageSensors(superIO, settings, v);
        CreateTemperatureSensors(superIO, settings, t);
        CreateFanSensors(superIO, settings, f);
        CreateControlSensors(superIO, settings, c);
    }

    public override HardwareType HardwareType
    {
        get { return HardwareType.SuperIO; }
    }

    public override IHardware Parent
    {
        get { return _motherboard; }
    }

    private void CreateControlSensors(ISuperIO superIO, ISettings settings, IList<Control> c)
    {
        foreach (Control ctrl in c)
        {
            int index = ctrl.Index;
            if (index < superIO.Controls.Length)
            {
                Sensor sensor = new(ctrl.Name, index, SensorType.Control, this, settings);
                LibreHardwareMonitor.Hardware.Control control = new(sensor, settings, 0, 100);
                control.ControlModeChanged += cc =>
                {
                    switch (cc.ControlMode)
                    {
                        case ControlMode.Undefined:
                            return;
                        case ControlMode.Default:
                            superIO.SetControl(index, null);
                            break;
                        case ControlMode.Software:
                            superIO.SetControl(index, GetSoftwareValueAsByte(cc));
                            break;
                        default:
                            return;
                    }
                };

                control.SoftwareControlValueChanged += cc =>
                {
                    if (cc.ControlMode == ControlMode.Software)
                        superIO.SetControl(index, GetSoftwareValueAsByte(cc));
                };

                switch (control.ControlMode)
                {
                    case ControlMode.Undefined:
                        break;
                    case ControlMode.Default:
                        superIO.SetControl(index, null);
                        break;
                    case ControlMode.Software:
                        superIO.SetControl(index, GetSoftwareValueAsByte(control));
                        break;
                }

                sensor.Control = control;
                _controls.Add(sensor);
                ActivateSensor(sensor);
            }
        }
    }

    private static byte GetSoftwareValueAsByte(LibreHardwareMonitor.Hardware.Control control)
    {
        const float percentToByteRatio = 2.55f;
        float value = control.SoftwareValue * percentToByteRatio;
        return (byte)value;
    }

    private void CreateFanSensors(ISuperIO superIO, ISettings settings, IList<Fan> f)
    {
        foreach (Fan fan in f)
        {
            if (fan.Index < superIO.Fans.Length)
            {
                Sensor sensor = new(fan.Name, fan.Index, SensorType.Fan, this, settings);
                _fans.Add(sensor);
            }
        }
    }

    private void CreateTemperatureSensors(ISuperIO superIO, ISettings settings, IList<Temperature> t)
    {
        foreach (Temperature temperature in t)
        {
            if (temperature.Index < superIO.Temperatures.Length)
            {
                Sensor sensor = new(temperature.Name,
                                    temperature.Index,
                                    SensorType.Temperature,
                                    this,
                                    [new ParameterDescription("Offset [°C]", "Temperature offset.", 0)],
                                    settings);

                _temperatures.Add(sensor);
            }
        }
    }

    private void CreateVoltageSensors(ISuperIO superIO, ISettings settings, IList<Voltage> v)
    {
        const string formula = "Voltage = value + (value - Vf) * Ri / Rf.";
        foreach (Voltage voltage in v)
        {
            if (voltage.Index < superIO.Voltages.Length)
            {
                Sensor sensor = new(voltage.Name,
                                    voltage.Index,
                                    voltage.Hidden,
                                    SensorType.Voltage,
                                    this,
                                    [
                                        new ParameterDescription("Ri [kΩ]", "Input resistance.\n" + formula, voltage.Ri),
                                        new ParameterDescription("Rf [kΩ]", "Reference resistance.\n" + formula, voltage.Rf),
                                        new ParameterDescription("Vf [V]", "Reference voltage.\n" + formula, voltage.Vf)
                                    ],
                                    settings);

                _voltages.Add(sensor);
            }
        }
    }

    private static void GetBoardSpecificConfiguration
    (
        ISuperIO superIO,
        Manufacturer manufacturer,
        Model model,
        int superIOIndex,
        out IList<Voltage> v,
        out IList<Temperature> t,
        out IList<Fan> f,
        out IList<Control> c,
        out ReadValueDelegate readVoltage,
        out ReadValueDelegate readTemperature,
        out ReadValueDelegate readFan,
        out ReadValueDelegate readControl,
        out UpdateDelegate postUpdate,
        out Mutex mutex)
    {
        readVoltage = index => superIO.Voltages[index];
        readTemperature = index => superIO.Temperatures[index];
        readFan = index => superIO.Fans[index];
        readControl = index => superIO.Controls[index];

        postUpdate = () => { };
        mutex = null;

        v = new List<Voltage>();
        t = new List<Temperature>();
        f = new List<Fan>();
        c = new List<Control>();

        switch (superIO.Chip)
        {
            case Chip.IT8705F:
            case Chip.IT8712F:
            case Chip.IT8716F:
            case Chip.IT8718F:
            case Chip.IT8720F:
            case Chip.IT8726F:
                GetIteConfigurationsA(superIO, manufacturer, model, v, t, f, c, ref readFan, ref postUpdate, ref mutex);
                break;

            case Chip.IT8613E:
            case Chip.IT8620E:
            case Chip.IT8625E:
            case Chip.IT8628E:
            case Chip.IT8631E:
            case Chip.IT8638E:
            case Chip.IT8655E:
            case Chip.IT8665E:
            case Chip.IT8686E:
            case Chip.IT8688E:
            case Chip.IT8689E:
            case Chip.IT8721F:
            case Chip.IT8728F:
            case Chip.IT8771E:
            case Chip.IT8772E:
            case Chip.IT8696E:
                GetIteConfigurationsB(superIO, manufacturer, model, v, t, f, c);
                break;

            case Chip.IT87952E:
            case Chip.IT8792E:
            case Chip.IT8790E:
                GetIteConfigurationsC(superIO, manufacturer, model, v, t, f, c);
                break;

            case Chip.F71858:
                v.Add(new Voltage("VCC3V", 0, 150, 150));
                v.Add(new Voltage("VSB3V", 1, 150, 150));
                v.Add(new Voltage("Battery", 2, 150, 150));

                for (int i = 0; i < superIO.Temperatures.Length; i++)
                    t.Add(new Temperature("Temperature #" + (i + 1), i));

                for (int i = 0; i < superIO.Fans.Length; i++)
                    f.Add(new Fan("Fan #" + (i + 1), i));

                break;

            case Chip.F71808E:
            case Chip.F71862:
            case Chip.F71869:
            case Chip.F71869A:
            case Chip.F71882:
            case Chip.F71889AD:
            case Chip.F71889ED:
            case Chip.F71889F:
                GetFintekConfiguration(superIO, manufacturer, model, v, t, f, c);
                break;

            case Chip.W83627EHF:
                GetWinbondConfigurationEhf(manufacturer, model, v, t, f, c);
                break;

            case Chip.W83627DHG:
            case Chip.W83627DHGP:
            case Chip.W83667HG:
            case Chip.W83667HGB:
                GetWinbondConfigurationHg(manufacturer, model, v, t, f, c);
                break;

            case Chip.W83627HF:
                v.Add(new Voltage("Vcore", 0));
                v.Add(new Voltage("Voltage #2", 1, true));
                v.Add(new Voltage("Voltage #3", 2, true));
                v.Add(new Voltage("AVCC", 3, 34, 51));
                v.Add(new Voltage("Voltage #5", 4, true));
                v.Add(new Voltage("+5VSB", 5, 34, 51));
                v.Add(new Voltage("CMOS Battery", 6));
                t.Add(new Temperature("CPU", 0));
                t.Add(new Temperature("Auxiliary", 1));
                t.Add(new Temperature("System", 2));
                f.Add(new Fan("System Fan", 0));
                f.Add(new Fan("CPU Fan", 1));
                f.Add(new Fan("Auxiliary Fan", 2));
                c.Add(new Control("Fan 1", 0));
                c.Add(new Control("Fan 2", 1));
                break;

            case Chip.W83627THF:
            case Chip.W83687THF:
                v.Add(new Voltage("Vcore", 0));
                v.Add(new Voltage("Voltage #2", 1, true));
                v.Add(new Voltage("Voltage #3", 2, true));
                v.Add(new Voltage("AVCC", 3, 34, 51));
                v.Add(new Voltage("Voltage #5", 4, true));
                v.Add(new Voltage("+5VSB", 5, 34, 51));
                v.Add(new Voltage("CMOS Battery", 6));
                t.Add(new Temperature("CPU", 0));
                t.Add(new Temperature("Auxiliary", 1));
                t.Add(new Temperature("System", 2));
                f.Add(new Fan("System Fan", 0));
                f.Add(new Fan("CPU Fan", 1));
                f.Add(new Fan("Auxiliary Fan", 2));
                c.Add(new Control("System Fan", 0));
                c.Add(new Control("CPU Fan", 1));
                c.Add(new Control("Auxiliary Fan", 2));
                break;

            case Chip.NCT5585D:
                switch (manufacturer)
                {
                    case Manufacturer.ASRock when model == Model.X870E_NOVA_WIFI:
                        // Voltages
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DRAM", 1));
                        v.Add(new Voltage("+3.3V (AVCC)", 2, 34, 34));
                        v.Add(new Voltage("+3.3V (3VCC)", 3, 34, 34));
                        v.Add(new Voltage("VDD Misc", 4));
                        v.Add(new Voltage("3VSB", 7, 34, 34));
                        v.Add(new Voltage("VBat", 8, 34, 34));
                        v.Add(new Voltage("Voltage #2", 12));
                        v.Add(new Voltage("Voltage #3", 13));
                        v.Add(new Voltage("Voltage #7", 14));
                        v.Add(new Voltage("Voltage #9", 15));

                        // Temperatures
                        t.Add(new Temperature("MOS", 1));
                        t.Add(new Temperature("CPU (PECI)", 2));
                        t.Add(new Temperature("Auxiliary 3", 3)); // AUXTIN3

                        // Fans
                        f.Add(new Fan("MOS Fan", 1));

                        // Controls
                        c.Add(new Control("MOS Fan", 1));
                        break;
                }
                break;

            case Chip.NCT6771F:
            case Chip.NCT6776F:
                GetNuvotonConfigurationF(superIO, manufacturer, model, v, t, f, c);
                break;

            case Chip.NCT610XD:
                switch (manufacturer)
                {
                    case Manufacturer.Supermicro when model == Model.X11SWN_E:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+12V", 1, 94, 10.25f));
                        v.Add(new Voltage("AVSB", 2, 34, 34));
                        v.Add(new Voltage("3VCC", 3, 34, 34));
                        v.Add(new Voltage("+5V", 4, 14, 8.2f));
                        v.Add(new Voltage("VDIMM", 5));
                        v.Add(new Voltage("3VSB", 6, 34, 34));
                        v.Add(new Voltage("VBat", 7, 34, 34));
                        t.Add(new Temperature("System", 1));
                        t.Add(new Temperature("Peripheral", 2));
                        t.Add(new Temperature("CPU Core", 4));

                        f.Add(new Fan("Fan #1", 1));

                        c.Add(new Control("Fan #1", 1));

                        break;

                    default:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("Voltage #0", 1, true));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("Voltage #1", 4, true));
                        v.Add(new Voltage("Voltage #2", 5, true));
                        v.Add(new Voltage("Reserved", 6, true));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("Voltage #10", 9, true));
                        t.Add(new Temperature("CPU Core", 0));
                        t.Add(new Temperature("Auxiliary", 1));
                        t.Add(new Temperature("System0", 2));
                        t.Add(new Temperature("System1", 3));
                        t.Add(new Temperature("System2", 4));
                        t.Add(new Temperature("System3", 5));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + (i + 1), i));

                        break;
                }

                break;

            case Chip.NCT6779D:
            case Chip.NCT6791D:
            case Chip.NCT6792D:
            case Chip.NCT6792DA:
            case Chip.NCT6793D:
            case Chip.NCT6795D:
            case Chip.NCT6796D:
            case Chip.NCT6796DR:
            case Chip.NCT6796DS:
            case Chip.NCT6797D:
            case Chip.NCT6798D:
            case Chip.NCT6799D:
            case Chip.NCT6701D:
            case Chip.NCT6683D:
                GetNuvotonConfigurationD(superIO, manufacturer, model, superIOIndex, v, t, f, c);
                break;

            case Chip.NCT6686D:
            case Chip.NCT6687D:
                switch (manufacturer)
                {
                    case Manufacturer.ASRock when model == Model.Z790_Taichi:
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Motherboard", 1));
                        t.Add(new Temperature("MOS", 2));

                        f.Add(new Fan("CPU Fan #1", 0));
                        f.Add(new Fan("Chassis Fan #4", 1));
                        f.Add(new Fan("CPU Fan #2", 2));
                        f.Add(new Fan("Chassis Fan #2", 3));
                        f.Add(new Fan("Chassis Fan #1", 4));
                        f.Add(new Fan("MOS Fan #1", 5));

                        c.Add(new Control("CPU Fan #1", 0));
                        c.Add(new Control("Chassis Fan #4", 1));
                        c.Add(new Control("CPU Fan #2", 2));
                        c.Add(new Control("Chassis Fan #2", 3));
                        c.Add(new Control("Chassis Fan #1", 4));
                        c.Add(new Control("MOS Fan #1", 5));
                        break;
                    case Manufacturer.ASRock when model == Model.X870E_TAICHI:
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("VRM MOS", 2));

                        f.Add(new Fan("Water Pump", 0)); // W_PUMP
                        f.Add(new Fan("Chassis Fan #3", 1)); // CHA_FAN3
                        f.Add(new Fan("Chassis Fan #4", 2)); // CHA_FAN4

                        c.Add(new Control("Water Pump", 0)); // W_PUMP
                        c.Add(new Control("Chassis Fan #3", 1)); // CHA_FAN3
                        c.Add(new Control("Chassis Fan #4", 2)); // CHA_FAN4
                        break;
                    case Manufacturer.MSI when model == Model.B550A_PRO:
                        v.Add(new Voltage("+12V", 0));
                        v.Add(new Voltage("+5V", 1));
                        v.Add(new Voltage("CPU Northbridge/SoC", 2));
                        v.Add(new Voltage("DIMM", 3, 1, 1));
                        v.Add(new Voltage("Vcore", 4, -1, 2));
                        v.Add(new Voltage("Chipset", 5));
                        v.Add(new Voltage("CPU System Agent", 6));
                        v.Add(new Voltage("+3.3V", 8));
                        v.Add(new Voltage("+1.8V", 9));
                        v.Add(new Voltage("CPU VDDP", 10));
                        v.Add(new Voltage("+3V Standby", 11));
                        v.Add(new Voltage("AVSB", 12));

                        t.Add(new Temperature("CPU Core", 0));
                        t.Add(new Temperature("System", 1));
                        t.Add(new Temperature("VRM MOS", 2));
                        t.Add(new Temperature("Chipset", 3));
                        t.Add(new Temperature("CPU Socket", 4));
                        t.Add(new Temperature("PCIe x1", 5));

                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("Pump Fan", 1));
                        f.Add(new Fan("System Fan #1", 2));
                        f.Add(new Fan("System Fan #2", 3));
                        f.Add(new Fan("System Fan #3", 4));
                        f.Add(new Fan("System Fan #4", 5));
                        f.Add(new Fan("System Fan #5", 6));
                        f.Add(new Fan("System Fan #6", 7));

                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("Pump Fan", 1));
                        c.Add(new Control("System Fan #1", 2));
                        c.Add(new Control("System Fan #2", 3));
                        c.Add(new Control("System Fan #3", 4));
                        c.Add(new Control("System Fan #4", 5));
                        c.Add(new Control("System Fan #5", 6));
                        c.Add(new Control("System Fan #6", 7));

                        break;

                    case Manufacturer.MSI when model == Model.B650M_Gaming_Plus_Wifi: // NCT6687D
                        v.Add(new Voltage("+12V", 0));
                        v.Add(new Voltage("+5V", 1));
                        v.Add(new Voltage("CPU Northbridge/SoC", 2));
                        v.Add(new Voltage("CPU VDDIO", 3, 1, 1));
                        v.Add(new Voltage("Vcore", 4, -1, 2));
                        v.Add(new Voltage("+3.3V", 8));
                        v.Add(new Voltage("+3V Standby", 11));
                        v.Add(new Voltage("AVSB", 12));
                        v.Add(new Voltage("CPU Termination", 9));
                        v.Add(new Voltage("CMOS Battery", 13));

                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("System", 1));
                        t.Add(new Temperature("VRM MOS", 2));
                        t.Add(new Temperature("Chipset", 3));
                        t.Add(new Temperature("CPU Socket", 4));

                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("CPU Pump Fan", 1));
                        f.Add(new Fan("System Fan #1", 2));
                        f.Add(new Fan("System Fan #2", 3));
                        f.Add(new Fan("System Fan #3", 4));

                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("CPU Pump Fan", 1));
                        c.Add(new Control("System Fan #1", 2));
                        c.Add(new Control("System Fan #2", 3));
                        c.Add(new Control("System Fan #3", 4));

                        break;

                    case Manufacturer.MSI when model == Model.Z790_GODLIKE_MAX: // NCT6687D
                        v.Add(new Voltage("+12V", 0));
                        v.Add(new Voltage("+5V", 1));
                        v.Add(new Voltage("Vcore", 2));
                        v.Add(new Voltage("Voltage #1", 3));
                        v.Add(new Voltage("DIMM", 4));
                        v.Add(new Voltage("CPU I/O", 5));
                        v.Add(new Voltage("CPU System Agent", 6));
                        v.Add(new Voltage("Voltage #2", 7));
                        v.Add(new Voltage("AVCC3", 8));
                        v.Add(new Voltage("CPU Termination", 9));
                        v.Add(new Voltage("VRef", 10));
                        v.Add(new Voltage("VSB", 11));
                        v.Add(new Voltage("AVSB", 12));
                        v.Add(new Voltage("CMOS Battery", 13));

                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("System", 1));
                        t.Add(new Temperature("VRM MOS", 2));
                        t.Add(new Temperature("PCH", 3));
                        t.Add(new Temperature("CPU Socket", 4));
                        t.Add(new Temperature("Thermistor Sensor 1", 5));
                        t.Add(new Temperature("Thermistor Sensor 2", 6));
                        t.Add(new Temperature("PCIe #1", 7));
                        t.Add(new Temperature("PCIe #2", 8));
                        t.Add(new Temperature("M2 #1", 9));
                        t.Add(new Temperature("M2 #4", 10));

                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("Pump Fan #1", 1));
                        f.Add(new Fan("Pump Fan #2", 8));
                        f.Add(new Fan("System Fan #1", 2));
                        f.Add(new Fan("System Fan #2", 3));
                        f.Add(new Fan("System Fan #3", 4));
                        f.Add(new Fan("System Fan #4", 5));
                        f.Add(new Fan("System Fan #5", 6));
                        f.Add(new Fan("System Fan #6", 7));
                        f.Add(new Fan("System Fan #7", 16));
                        f.Add(new Fan("EZ-Connect Fan", 9));

                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("Pump Fan #1", 1));
                        c.Add(new Control("System Fan #1", 2));
                        c.Add(new Control("System Fan #2", 3));
                        c.Add(new Control("System Fan #3", 4));
                        c.Add(new Control("System Fan #4", 5));
                        c.Add(new Control("System Fan #5", 6));
                        c.Add(new Control("System Fan #6", 7));

                        break;

                    default:
                        v.Add(new Voltage("+12V", 0));
                        v.Add(new Voltage("+5V", 1));
                        v.Add(new Voltage("Vcore", 2));
                        v.Add(new Voltage("Voltage #1", 3));
                        v.Add(new Voltage("DIMM", 4));
                        v.Add(new Voltage("CPU I/O", 5));
                        v.Add(new Voltage("CPU System Agent", 6));
                        v.Add(new Voltage("Voltage #2", 7));
                        v.Add(new Voltage("AVCC3", 8));
                        v.Add(new Voltage("CPU Termination", 9));
                        v.Add(new Voltage("VRef", 10));
                        v.Add(new Voltage("VSB", 11));
                        v.Add(new Voltage("AVSB", 12));
                        v.Add(new Voltage("CMOS Battery", 13));

                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("System", 1));
                        t.Add(new Temperature("VRM MOS", 2));
                        t.Add(new Temperature("PCH", 3));
                        t.Add(new Temperature("CPU Socket", 4));
                        t.Add(new Temperature("PCIe x1", 5));
                        t.Add(new Temperature("M2 #1", 6));

                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("Pump Fan", 1));
                        f.Add(new Fan("System Fan #1", 2));
                        f.Add(new Fan("System Fan #2", 3));
                        f.Add(new Fan("System Fan #3", 4));
                        f.Add(new Fan("System Fan #4", 5));
                        f.Add(new Fan("System Fan #5", 6));
                        f.Add(new Fan("System Fan #6", 7));

                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("Pump Fan", 1));
                        c.Add(new Control("System Fan #1", 2));
                        c.Add(new Control("System Fan #2", 3));
                        c.Add(new Control("System Fan #3", 4));
                        c.Add(new Control("System Fan #4", 5));
                        c.Add(new Control("System Fan #5", 6));
                        c.Add(new Control("System Fan #6", 7));

                        break;
                }

                break;

            case Chip.NCT6687DR:

                // Universal Sensor and Control defaults
                t.Add(new Temperature("CPU Core", 0));
                t.Add(new Temperature("System", 1));
                t.Add(new Temperature("VRM MOS", 2));
                t.Add(new Temperature("Chipset", 3));

                f.Add(new Fan("CPU Fan", 0));
                f.Add(new Fan("Pump Fan #1", 1));
                f.Add(new Fan("Chipset Fan", 2));
                f.Add(new Fan("System Fan #1", 10));
                f.Add(new Fan("System Fan #2", 11));
                f.Add(new Fan("System Fan #3", 12));
                f.Add(new Fan("System Fan #4", 13));
                f.Add(new Fan("System Fan #5", 14));
                f.Add(new Fan("System Fan #6", 15));
                f.Add(new Fan("EZ-Connect Fan", 3));

                c.Add(new Control("CPU Fan", 0));
                c.Add(new Control("Pump Fan", 1));
                c.Add(new Control("Chipset Fan", 2));
                c.Add(new Control("System Fan #1", 10));
                c.Add(new Control("System Fan #2", 11));
                c.Add(new Control("System Fan #3", 12));
                c.Add(new Control("System Fan #4", 13));
                c.Add(new Control("System Fan #5", 14));
                c.Add(new Control("System Fan #6", 15));
                c.Add(new Control("EZ-Connect Fan", 3));

                switch (model)
                {
                    case Model.X870E_TOMAHAWK_WIFI:
                    case Model.X870E_TOMAHAWK_MAX_WIFI_PZ:
                    case Model.X870E_EDGE_TI_WIFI:
                        v.Add(new Voltage("+12V", 0));
                        v.Add(new Voltage("+5V", 1));
                        v.Add(new Voltage("CPU Northbridge/SoC", 2));
                        v.Add(new Voltage("DIMM", 3, 1, 1));
                        v.Add(new Voltage("Vcore", 4, -1, 2));
                        v.Add(new Voltage("Chipset", 5));
                        v.Add(new Voltage("CPU System Agent", 6));
                        //v.Add(new Voltage("Unknown_4", 7)); //"Voltage #2"
                        v.Add(new Voltage("+3.3V", 8));
                        v.Add(new Voltage("VREF", 9));
                        v.Add(new Voltage("+1.8V", 10));
                        v.Add(new Voltage("+3V Standby", 11));
                        v.Add(new Voltage("AVSB", 12));
                        v.Add(new Voltage("CMOS Battery", 13));

                        t.Add(new Temperature("CPU Socket", 4));

                        break;

                    case Model.X870E_ACE_MAX:
                        v.Add(new Voltage("+12V", 0));
                        v.Add(new Voltage("+5V", 1));
                        v.Add(new Voltage("CPU Northbridge/SoC", 2));
                        v.Add(new Voltage("DIMM", 3, 1, 1));
                        v.Add(new Voltage("Vcore", 4, -1, 2));
                        v.Add(new Voltage("Chipset", 5));
                        v.Add(new Voltage("CPU System Agent", 6));
                        //v.Add(new Voltage("Unknown_4", 7)); //"Voltage #2"
                        v.Add(new Voltage("+3.3V", 8));
                        v.Add(new Voltage("VREF", 9));
                        v.Add(new Voltage("+1.8V", 10));
                        v.Add(new Voltage("+3V Standby", 11));
                        v.Add(new Voltage("AVSB", 12));
                        v.Add(new Voltage("CMOS Battery", 13));

                        t.Add(new Temperature("Chipset #2", 5));
                        t.Add(new Temperature("Thermistor Sensor", 6));

                        break;

                    case Model.X870E_CARBON_WIFI:
                    case Model.X870E_GODLIKE:
                        f.Add(new Fan("System Fan #7", 9));
                        c.Add(new Control("System Fan #7", 9));

                        v.Add(new Voltage("+12V", 0));
                        v.Add(new Voltage("+5V", 1));
                        v.Add(new Voltage("CPU Northbridge/SoC", 2));
                        v.Add(new Voltage("DIMM", 3, 1, 1));
                        v.Add(new Voltage("Vcore", 4, -1, 2));
                        v.Add(new Voltage("Chipset", 5));
                        v.Add(new Voltage("CPU System Agent", 6));
                        //v.Add(new Voltage("Unknown_4", 7)); //"Voltage #2"
                        v.Add(new Voltage("+3.3V", 8));
                        v.Add(new Voltage("VREF", 9));
                        v.Add(new Voltage("+1.8V", 10));
                        v.Add(new Voltage("+3V Standby", 11));
                        v.Add(new Voltage("AVSB", 12));
                        v.Add(new Voltage("CMOS Battery", 13));

                        t.Add(new Temperature("PCIe x1", 5));
                        t.Add(new Temperature("Thermistor Sensor", 6));

                        break;

                    case Model.Z890_CARBON_WIFI:
                    case Model.Z890_TOMAHAWK_WIFI:
                    case Model.Z890_ACE:
                    case Model.Z890_UNIFY_X:
                        v.Add(new Voltage("+12V", 0));
                        v.Add(new Voltage("+5V", 1));
                        v.Add(new Voltage("Vcore", 2));
                        v.Add(new Voltage("VIN5", 3));
                        v.Add(new Voltage("VDIMM", 4));
                        v.Add(new Voltage("Chipset", 5));
                        //v.Add(new Voltage("CPU System Agent", 6));
                        v.Add(new Voltage("VIN7", 7));
                        v.Add(new Voltage("+3.3V", 8));
                        v.Add(new Voltage("VTT", 9));
                        v.Add(new Voltage("+1.8V", 10));
                        v.Add(new Voltage("+3V Standby", 11));
                        v.Add(new Voltage("AVSB", 12));
                        v.Add(new Voltage("CMOS Battery", 13));

                        t.Add(new Temperature("CPU Socket", 4));
                        t.Add(new Temperature("PCIe x1", 5));
                        t.Add(new Temperature("M2 #1", 6));

                        break;

                    case Model.Z890_EDGE_TI_WIFI:
                    case Model.Z890I_EDGE_TI_WIFI:
                    case Model.Z890P_PRO_WIFI:
                    case Model.Z890A_PRO_WIFI:
                    case Model.Z890S_PRO_WIFI:
                    case Model.Z890_GAMING_PLUS_WIFI:
                    case Model.Z890S_PRO_WIFI_PROJECT_ZERO:
                        v.Add(new Voltage("+12V", 0));
                        v.Add(new Voltage("+5V", 1));
                        v.Add(new Voltage("Vcore", 2));
                        v.Add(new Voltage("VIN5", 3));
                        v.Add(new Voltage("VDIMM", 4));
                        v.Add(new Voltage("Chipset", 5));
                        //v.Add(new Voltage("CPU System Agent", 6));
                        v.Add(new Voltage("Unknown_3", 7));
                        v.Add(new Voltage("+3.3V", 8));
                        v.Add(new Voltage("VTT", 9));
                        v.Add(new Voltage("+1.8V", 10));
                        v.Add(new Voltage("+3V Standby", 11));
                        v.Add(new Voltage("AVSB", 12));
                        v.Add(new Voltage("CMOS Battery", 13));

                        break;

                    default:
                        v.Add(new Voltage("+12V", 0));
                        v.Add(new Voltage("+5V", 1));
                        v.Add(new Voltage("CPU Northbridge/SoC", 2));
                        v.Add(new Voltage("DIMM", 3, 1, 1));
                        v.Add(new Voltage("Vcore", 4, -1, 2));
                        v.Add(new Voltage("Chipset", 5));
                        v.Add(new Voltage("CPU System Agent", 6));
                        //v.Add(new Voltage("Unknown_4", 7)); //"Voltage #2"
                        v.Add(new Voltage("+3.3V", 8));
                        v.Add(new Voltage("VREF", 9));
                        v.Add(new Voltage("+1.8V", 10));
                        v.Add(new Voltage("+3V Standby", 11));
                        v.Add(new Voltage("AVSB", 12));
                        v.Add(new Voltage("CMOS Battery", 13));

                        break;
                }

                break;

            case Chip.IPMI:
                Ipmi ipmi = (Ipmi)superIO;

                foreach (Temperature temperature in ipmi.GetTemperatures())
                    t.Add(temperature);

                foreach (Fan fan in ipmi.GetFans())
                    f.Add(fan);

                foreach (Voltage voltage in ipmi.GetVoltages())
                    v.Add(voltage);

                foreach (Control control in ipmi.GetControls())
                    c.Add(control);

                break;

            default:
                GetDefaultConfiguration(superIO, v, t, f, c);
                break;
        }
    }

    private static void GetDefaultConfiguration(ISuperIO superIO, ICollection<Voltage> v, ICollection<Temperature> t, ICollection<Fan> f, ICollection<Control> c)
    {
        for (int i = 0; i < superIO.Voltages.Length; i++)
            v.Add(new Voltage("Voltage #" + (i + 1), i, true));

        for (int i = 0; i < superIO.Temperatures.Length; i++)
            t.Add(new Temperature("Temperature #" + (i + 1), i));

        for (int i = 0; i < superIO.Fans.Length; i++)
            f.Add(new Fan("Fan #" + (i + 1), i));

        for (int i = 0; i < superIO.Controls.Length; i++)
            c.Add(new Control("Fan #" + (i + 1), i));
    }

    private static void GetIteConfigurationsA
    (
        ISuperIO superIO,
        Manufacturer manufacturer,
        Model model,
        IList<Voltage> v,
        IList<Temperature> t,
        IList<Fan> f,
        ICollection<Control> c,
        ref ReadValueDelegate readFan,
        ref UpdateDelegate postUpdate,
        ref Mutex mutex)
    {
        switch (manufacturer)
        {
            case Manufacturer.ASUS:
                switch (model)
                {
                    case Model.CROSSHAIR_III_FORMULA: // IT8720F
                        v.Add(new Voltage("CMOS Battery", 8));
                        t.Add(new Temperature("CPU", 0));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        break;

                    case Model.M2N_SLI_Deluxe:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+3.3V", 1));
                        v.Add(new Voltage("+5V", 3, 6.8f, 10));
                        v.Add(new Voltage("+12V", 4, 30, 10));
                        v.Add(new Voltage("+5VSB", 7, 6.8f, 10));
                        v.Add(new Voltage("CMOS Battery", 8));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Motherboard", 1));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("Chassis Fan #1", 1));
                        f.Add(new Fan("Power Fan", 2));

                        break;

                    case Model.M4A79XTD_EVO: // IT8720F
                        v.Add(new Voltage("+5V", 3, 6.8f, 10));
                        v.Add(new Voltage("CMOS Battery", 8));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Motherboard", 1));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("Chassis Fan #1", 1));
                        f.Add(new Fan("Chassis Fan #2", 2));

                        break;

                    default:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("Voltage #3", 2, true));
                        v.Add(new Voltage("Voltage #4", 3, true));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("Voltage #8", 7, true));
                        v.Add(new Voltage("CMOS Battery", 8));

                        for (int i = 0; i < superIO.Temperatures.Length; i++)
                            t.Add(new Temperature("Temperature #" + (i + 1), i));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + (i + 1), i));

                        break;
                }

                break;
            case Manufacturer.ASRock:
                switch (model)
                {
                    case Model.P55_Deluxe: // IT8720F
                        GetASRockConfiguration(superIO,
                                               v,
                                               t,
                                               f,
                                               ref readFan,
                                               ref postUpdate,
                                               out mutex);

                        break;

                    default:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("Voltage #3", 2, true));
                        v.Add(new Voltage("Voltage #4", 3, true));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("Voltage #8", 7, true));
                        v.Add(new Voltage("CMOS Battery", 8));

                        for (int i = 0; i < superIO.Temperatures.Length; i++)
                            t.Add(new Temperature("Temperature #" + (i + 1), i));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        break;
                }

                break;
            case Manufacturer.DFI:
                switch (model)
                {
                    case Model.LP_BI_P45_T2RS_Elite: // IT8718F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("CPU Termination", 1));
                        v.Add(new Voltage("+3.3V", 2));
                        v.Add(new Voltage("+5V", 3, 6.8f, 10));
                        v.Add(new Voltage("+12V", 4, 30, 10));
                        v.Add(new Voltage("Northbridge Core", 5));
                        v.Add(new Voltage("DIMM", 6));
                        v.Add(new Voltage("+5VSB", 7, 6.8f, 10));
                        v.Add(new Voltage("CMOS Battery", 8));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("System", 1));
                        t.Add(new Temperature("Chipset", 2));
                        f.Add(new Fan("Fan #1", 0));
                        f.Add(new Fan("Fan #2", 1));
                        f.Add(new Fan("Fan #3", 2));

                        break;

                    case Model.LP_DK_P55_T3EH9: // IT8720F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("CPU Termination", 1));
                        v.Add(new Voltage("+3.3V", 2));
                        v.Add(new Voltage("+5V", 3, 6.8f, 10));
                        v.Add(new Voltage("+12V", 4, 30, 10));
                        v.Add(new Voltage("Phase Locked Loop", 5));
                        v.Add(new Voltage("DIMM", 6));
                        v.Add(new Voltage("+5VSB", 7, 6.8f, 10));
                        v.Add(new Voltage("CMOS Battery", 8));
                        t.Add(new Temperature("Chipset", 0));
                        t.Add(new Temperature("CPU PWM", 1));
                        t.Add(new Temperature("CPU", 2));
                        f.Add(new Fan("Fan #1", 0));
                        f.Add(new Fan("Fan #2", 1));
                        f.Add(new Fan("Fan #3", 2));

                        break;

                    default:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("CPU Termination", 1, true));
                        v.Add(new Voltage("+3.3V", 2, true));
                        v.Add(new Voltage("+5V", 3, 6.8f, 10, 0, true));
                        v.Add(new Voltage("+12V", 4, 30, 10, 0, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("DIMM", 6, true));
                        v.Add(new Voltage("+5VSB", 7, 6.8f, 10, 0, true));
                        v.Add(new Voltage("CMOS Battery", 8));

                        for (int i = 0; i < superIO.Temperatures.Length; i++)
                            t.Add(new Temperature("Temperature #" + (i + 1), i));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + (i + 1), i));

                        break;
                }

                break;
            case Manufacturer.Gigabyte:
                switch (model)
                {
                    case Model._965P_S3: // IT8718F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DIMM", 1));
                        v.Add(new Voltage("+3.3V", 2));
                        v.Add(new Voltage("+5V", 3, 6.8f, 10));
                        v.Add(new Voltage("+12V", 7, 24.3f, 8.2f));
                        v.Add(new Voltage("CMOS Battery", 8));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 1));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan", 1));

                        break;

                    case Model.EP45_DS3R: // IT8718F
                    case Model.EP45_UD3R:
                    case Model.X38_DS5:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DIMM", 1));
                        v.Add(new Voltage("+3.3V", 2));
                        v.Add(new Voltage("+5V", 3, 6.8f, 10));
                        v.Add(new Voltage("+12V", 7, 24.3f, 8.2f));
                        v.Add(new Voltage("CMOS Battery", 8));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 1));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #2", 1));
                        f.Add(new Fan("Power Fan", 2));
                        f.Add(new Fan("System Fan #1", 3));

                        break;

                    case Model.EX58_EXTREME: // IT8720F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DIMM", 1));
                        v.Add(new Voltage("+5V", 3, 6.8f, 10));
                        v.Add(new Voltage("CMOS Battery", 8));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("Northbridge", 2));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #2", 1));
                        f.Add(new Fan("Power Fan", 2));
                        f.Add(new Fan("System Fan #1", 3));

                        break;

                    case Model.P35_DS3: // IT8718F
                    case Model.P35_DS3L: // IT8718F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DIMM", 1));
                        v.Add(new Voltage("+3.3V", 2));
                        v.Add(new Voltage("+5V", 3, 6.8f, 10));
                        v.Add(new Voltage("+12V", 7, 24.3f, 8.2f));
                        v.Add(new Voltage("CMOS Battery", 8));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 1));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("Power Fan", 3));

                        break;

                    case Model.P55_UD4: // IT8720F
                    case Model.P55A_UD3: // IT8720F
                    case Model.P55M_UD4: // IT8720F
                    case Model.H55_USB3: // IT8720F
                    case Model.EX58_UD3R: // IT8720F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DIMM", 1));
                        v.Add(new Voltage("+3.3V", 2));
                        v.Add(new Voltage("+5V", 3, 6.8f, 10));
                        v.Add(new Voltage("+12V", 5, 24.3f, 8.2f));
                        v.Add(new Voltage("CMOS Battery", 8));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 2));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #2", 1));
                        f.Add(new Fan("Power Fan", 2));
                        f.Add(new Fan("System Fan #1", 3));
                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("System Fan #2", 1));

                        break;

                    case Model.H55N_USB3: // IT8720F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DIMM", 1));
                        v.Add(new Voltage("+3.3V", 2));
                        v.Add(new Voltage("+5V", 3, 6.8f, 10));
                        v.Add(new Voltage("+12V", 5, 24.3f, 8.2f));
                        v.Add(new Voltage("CMOS Battery", 8));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 2));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan", 1));

                        break;

                    case Model.G41M_COMBO: // IT8718F
                    case Model.G41MT_S2: // IT8718F
                    case Model.G41MT_S2P: // IT8718F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DIMM", 1));
                        v.Add(new Voltage("+3.3V", 2));
                        v.Add(new Voltage("+5V", 3, 6.8f, 10));
                        v.Add(new Voltage("+12V", 7, 24.3f, 8.2f));
                        v.Add(new Voltage("CMOS Battery", 8));
                        t.Add(new Temperature("CPU", 2));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan", 1));

                        break;

                    case Model._970A_UD3: // IT8720F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DIMM", 1));
                        v.Add(new Voltage("+3.3V", 2));
                        v.Add(new Voltage("+5V", 3, 6.8f, 10));
                        v.Add(new Voltage("+12V", 4, 24.3f, 8.2f));
                        v.Add(new Voltage("CMOS Battery", 8));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 1));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("Power Fan", 4));
                        c.Add(new Control("PWM #1", 0));
                        c.Add(new Control("PWM #2", 1));
                        c.Add(new Control("PWM #3", 2));

                        break;

                    case Model.MA770T_UD3: // IT8720F
                    case Model.MA770T_UD3P: // IT8720F
                    case Model.MA790X_UD3P: // IT8720F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DIMM", 1));
                        v.Add(new Voltage("+3.3V", 2));
                        v.Add(new Voltage("+5V", 3, 6.8f, 10));
                        v.Add(new Voltage("+12V", 4, 24.3f, 8.2f));
                        v.Add(new Voltage("CMOS Battery", 8));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 1));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("Power Fan", 3));

                        break;

                    case Model.MA78LM_S2H: // IT8718F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DIMM", 1));
                        v.Add(new Voltage("+3.3V", 2));
                        v.Add(new Voltage("+5V", 3, 6.8f, 10));
                        v.Add(new Voltage("+12V", 4, 24.3f, 8.2f));
                        v.Add(new Voltage("CMOS Battery", 8));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("VRM", 2));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("Power Fan", 3));

                        break;

                    case Model.MA790X_DS4: // IT8718F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DIMM", 1));
                        v.Add(new Voltage("+3.3V", 2));
                        v.Add(new Voltage("+5V", 3, 6.8f, 10));
                        v.Add(new Voltage("+12V", 4, 24.3f, 8.2f));
                        v.Add(new Voltage("VBat", 8));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 1));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("Power Fan", 4));
                        //Depending on the active mode of the processor fan (DC or PWM fan), only the corresponding one should be used.
                        //The incorrect one will always read and act as "100%" when it's in his "default" states, but it can be set and reset to "default".
                        //It's possible to control both at the same time, but this will have wierd or no effect.
                        c.Add(new Control("CPU Fan DC Control", 0));
                        c.Add(new Control("CPU Fan PWM Control", 2));

                        c.Add(new Control("System Fan #1 Control", 1));//DC mode only

                        break;

                    case Model.MA785GM_US2H: // IT8718F
                    case Model.MA785GMT_UD2H: // IT8718F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DIMM", 1));
                        v.Add(new Voltage("+3.3V", 2));
                        v.Add(new Voltage("+5V", 3, 6.8f, 10));
                        v.Add(new Voltage("+12V", 4, 24.3f, 8.2f));
                        v.Add(new Voltage("CMOS Battery", 8));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 1));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan", 1));
                        f.Add(new Fan("Northbridge Fan", 2));

                        break;

                    case Model.X58A_UD3R: // IT8720F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DIMM", 1));
                        v.Add(new Voltage("+3.3V", 2));
                        v.Add(new Voltage("+5V", 3, 6.8f, 10));
                        v.Add(new Voltage("+12V", 5, 24.3f, 8.2f));
                        v.Add(new Voltage("CMOS Battery", 8));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("Northbridge", 2));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #2", 1));
                        f.Add(new Fan("Power Fan", 2));
                        f.Add(new Fan("System Fan #1", 3));

                        break;

                    default:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DIMM", 1, true));
                        v.Add(new Voltage("+3.3V", 2, true));
                        v.Add(new Voltage("+5V", 3, 6.8f, 10, 0, true));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("Voltage #8", 7, true));
                        v.Add(new Voltage("CMOS Battery", 8));

                        for (int i = 0; i < superIO.Temperatures.Length; i++)
                            t.Add(new Temperature("Temperature #" + (i + 1), i));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + (i + 1), i));

                        break;
                }

                break;

            default:
                v.Add(new Voltage("Vcore", 0));
                v.Add(new Voltage("Voltage #2", 1, true));
                v.Add(new Voltage("Voltage #3", 2, true));
                v.Add(new Voltage("Voltage #4", 3, true));
                v.Add(new Voltage("Voltage #5", 4, true));
                v.Add(new Voltage("Voltage #6", 5, true));
                v.Add(new Voltage("Voltage #7", 6, true));
                v.Add(new Voltage("Voltage #8", 7, true));
                v.Add(new Voltage("CMOS Battery", 8));

                for (int i = 0; i < superIO.Temperatures.Length; i++)
                    t.Add(new Temperature("Temperature #" + (i + 1), i));

                for (int i = 0; i < superIO.Fans.Length; i++)
                    f.Add(new Fan("Fan #" + (i + 1), i));

                for (int i = 0; i < superIO.Controls.Length; i++)
                    c.Add(new Control("Fan #" + (i + 1), i));

                break;
        }
    }

    private static void GetASRockConfiguration
    (
        ISuperIO superIO,
        IList<Voltage> v,
        IList<Temperature> t,
        IList<Fan> f,
        ref ReadValueDelegate readFan,
        ref UpdateDelegate postUpdate,
        out Mutex mutex)
    {
        v.Add(new Voltage("Vcore", 0));
        v.Add(new Voltage("+3.3V", 2));
        v.Add(new Voltage("+12V", 4, 30, 10));
        v.Add(new Voltage("+5V", 5, 6.8f, 10));
        v.Add(new Voltage("CMOS Battery", 8));
        t.Add(new Temperature("CPU", 0));
        t.Add(new Temperature("Motherboard", 1));
        f.Add(new Fan("CPU Fan", 0));
        f.Add(new Fan("Chassis Fan #1", 1));

        // this mutex is also used by the official ASRock tool
        mutex = new Mutex(false, "ASRockOCMark");

        bool exclusiveAccess = false;
        try
        {
            exclusiveAccess = mutex.WaitOne(10, false);
        }
        catch (AbandonedMutexException)
        { }
        catch (InvalidOperationException)
        { }

        // only read additional fans if we get exclusive access
        if (exclusiveAccess)
        {
            f.Add(new Fan("Chassis Fan #2", 2));
            f.Add(new Fan("Chassis Fan #3", 3));
            f.Add(new Fan("Power Fan", 4));

            readFan = index =>
            {
                if (index < 2)
                {
                    return superIO.Fans[index];
                }

                // get GPIO 80-87
                byte? gpio = superIO.ReadGpio(7);
                if (!gpio.HasValue)
                    return null;

                // read the last 3 fans based on GPIO 83-85
                int[] masks = [0x05, 0x03, 0x06];
                return ((gpio.Value >> 3) & 0x07) == masks[index - 2] ? superIO.Fans[2] : null;
            };

            int fanIndex = 0;

            postUpdate = () =>
            {
                // get GPIO 80-87
                byte? gpio = superIO.ReadGpio(7);
                if (!gpio.HasValue)
                    return;

                // prepare the GPIO 83-85 for the next update
                int[] masks = [0x05, 0x03, 0x06];
                superIO.WriteGpio(7, (byte)((gpio.Value & 0xC7) | (masks[fanIndex] << 3)));
                fanIndex = (fanIndex + 1) % 3;
            };
        }
    }

    private static void GetIteConfigurationsB(ISuperIO superIO, Manufacturer manufacturer, Model model, IList<Voltage> v, IList<Temperature> t, IList<Fan> f, IList<Control> c)
    {
        switch (manufacturer)
        {
            case Manufacturer.ASUS:
                switch (model)
                {
                    case Model.PRIME_X370_PRO: // IT8665E
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("Southbridge 2.5V", 1));
                        v.Add(new Voltage("+12V", 2, 5, 1));
                        v.Add(new Voltage("+5V", 3, 1.5f, 1));
                        v.Add(new Voltage("Voltage #4", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3.3V", 7, 10, 10));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));
                        v.Add(new Voltage("Voltage #10", 9, true));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Motherboard", 1));
                        t.Add(new Temperature("VRM", 2));

                        for (int i = 3; i < superIO.Temperatures.Length; i++)
                            t.Add(new Temperature("Temperature #" + (i + 1), i));

                        // Don't know how to get the Pump Fans readings (bios? DC controller? driver?)
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("Chassis Fan #1", 1));
                        f.Add(new Fan("Chassis Fan #2", 2));
                        f.Add(new Fan("AIO Pump", 3));
                        f.Add(new Fan("CPU Optional Fan", 4));
                        f.Add(new Fan("Water Pump", 5));

                        for (int i = 6; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + (i + 1), i));

                        break;

                    case Model.TUF_X470_PLUS_GAMING: // IT8665E
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("Southbridge 2.5V", 1));
                        v.Add(new Voltage("+12V", 2, 5, 1));
                        v.Add(new Voltage("+5V", 3, 1.5f, 1));
                        v.Add(new Voltage("Voltage #4", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3.3V", 7, 10, 10));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));
                        v.Add(new Voltage("Voltage #10", 9, true));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Motherboard", 1));
                        t.Add(new Temperature("PCH", 2));

                        for (int i = 3; i < superIO.Temperatures.Length; i++)
                            t.Add(new Temperature("Temperature #" + (i + 1), i));

                        f.Add(new Fan("CPU Fan", 0));

                        for (int i = 1; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + (i + 1), i));

                        break;

                    case Model.ROG_ZENITH_EXTREME: // IT8665E
                        v.Add(new Voltage("Vcore", 0, 10, 10));
                        v.Add(new Voltage("DIMM A/B", 1, 10, 10));
                        v.Add(new Voltage("+12V", 2, 5, 1));
                        v.Add(new Voltage("+5V", 3, 1.5f, 1));
                        v.Add(new Voltage("Southbridge 1.05V", 4, 10, 10));
                        v.Add(new Voltage("DIMM C/D", 5, 10, 10));
                        v.Add(new Voltage("Phase Locked Loop", 6, 10, 10));
                        v.Add(new Voltage("+3.3V", 7, 10, 10));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Motherboard", 1));
                        t.Add(new Temperature("CPU Socket", 2));
                        t.Add(new Temperature("Temperature #4", 3));
                        t.Add(new Temperature("Temperature #5", 4));
                        t.Add(new Temperature("VRM", 5));

                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("Chassis Fan #1", 1));
                        f.Add(new Fan("Chassis Fan #2", 2));
                        f.Add(new Fan("High Amp Fan", 3));
                        f.Add(new Fan("Fan 5", 4));
                        f.Add(new Fan("Fan 6", 5));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + (i + 1), i));

                        break;

                    case Model.ROG_STRIX_X470_I: // IT8665E
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("Southbridge 2.5V", 1));
                        v.Add(new Voltage("+12V", 2, 5, 1));
                        v.Add(new Voltage("+5V", 3, 1.5f, 1));
                        v.Add(new Voltage("+3.3V", 7, 10, 10));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Motherboard", 1));
                        t.Add(new Temperature("Thermistor Sensor", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM", 4));
                        t.Add(new Temperature("Temperature #6", 5));

                        f.Add(new Fan("CPU Fan", 0));

                        //Does not work when in AIO pump mode (shows 0). I don't know how to fix it.
                        f.Add(new Fan("Chassis Fan #1", 1));
                        f.Add(new Fan("Chassis Fan #2", 2));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + i, i));

                        break;

                    case Model.TUF_GAMING_B450_PLUS_II: // IT8665E
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("Vccp2", 1));
                        v.Add(new Voltage("+12V", 2, 5, 1));
                        v.Add(new Voltage("+5V", 3, 1.5f, 1));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("3VSB", 7, 10, 10));
                        v.Add(new Voltage("VBat", 8, 10, 10));
                        //v.Add(new Voltage("AVCC3", 15, 10, 10));

                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Motherboard", 1));
                        t.Add(new Temperature("Temperature #3", 2));
                        t.Add(new Temperature("Temperature #4", 3));
                        t.Add(new Temperature("Temperature #5", 4));
                        t.Add(new Temperature("Temperature #6", 5));

                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("Chassis Fan #1", 1));
                        f.Add(new Fan("Chassis Fan #2", 2));
                        f.Add(new Fan("Chassis Fan #3", 3));
                        //f.Add(new Fan("Chassis Fan #4", 4)); //Useless. Not connected to anything.
                        f.Add(new Fan("AIO Pump", 5));

                        c.Add(new Control("CPU Fan Control", 0));
                        c.Add(new Control("Chassis Fan #1 Control", 1));
                        c.Add(new Control("Chassis Fan #2 Control", 2));
                        c.Add(new Control("Chassis Fan #3 Control", 3));
                        //c.Add(new Control("Chassis Fan #4 Control", 4)); //Useless. Not connected to anything.
                        c.Add(new Control("AIO Pump Control", 5));

                        break;


                    default:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("Voltage #3", 2, true));
                        v.Add(new Voltage("Voltage #4", 3, true));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("Voltage #8", 7, true));
                        v.Add(new Voltage("CMOS Battery", 8));

                        for (int i = 0; i < superIO.Temperatures.Length; i++)
                            t.Add(new Temperature("Temperature #" + (i + 1), i));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + (i + 1), i));

                        break;
                }

                break;
            case Manufacturer.ECS:
                switch (model)
                {
                    case Model.A890GXM_A: // IT8721F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DIMM", 1));
                        v.Add(new Voltage("Northbridge", 2));
                        v.Add(new Voltage("AVCC", 3, 10, 10));
                        // v.Add(new Voltage("DIMM", 6, true));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("System", 1));
                        t.Add(new Temperature("Northbridge", 2));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan", 1));
                        f.Add(new Fan("Power Fan", 2));

                        break;

                    default:
                        v.Add(new Voltage("Voltage #1", 0, true));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("Voltage #3", 2, true));
                        v.Add(new Voltage("AVCC", 3, 10, 10, 0, true));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10, 0, true));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));

                        for (int i = 0; i < superIO.Temperatures.Length; i++)
                            t.Add(new Temperature("Temperature #" + (i + 1), i));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + (i + 1), i));

                        break;
                }

                break;
            case Manufacturer.Gigabyte:
                switch (model)
                {
                    case Model.H61M_DS2_REV_1_2: // IT8728F
                    case Model.H61M_USB3_B3_REV_2_0: // IT8728F
                        v.Add(new Voltage("CPU Termination", 0));
                        v.Add(new Voltage("+12V", 2, 30.9f, 10));
                        v.Add(new Voltage("Vcore", 5));
                        v.Add(new Voltage("DIMM", 6));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 2));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan", 1));

                        break;

                    case Model.H67A_UD3H_B3: // IT8728F
                    case Model.H67A_USB3_B3: // IT8728F
                        v.Add(new Voltage("CPU Termination", 0));
                        v.Add(new Voltage("+5V", 1, 15, 10));
                        v.Add(new Voltage("+12V", 2, 30.9f, 10));
                        v.Add(new Voltage("Vcore", 5));
                        v.Add(new Voltage("DIMM", 6));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 2));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("Power Fan", 2));
                        f.Add(new Fan("System Fan #2", 3));

                        break;

                    case Model.B75M_D3H: // IT8728F
                        v.Add(new Voltage("CPU Termination", 0));
                        v.Add(new Voltage("+3.3V", 1, 6.49f, 10));
                        v.Add(new Voltage("+5V", 3, 15, 10));
                        v.Add(new Voltage("+12V", 2, 10, 2));
                        v.Add(new Voltage("iGPU VAXG", 4));
                        v.Add(new Voltage("Vcore", 5));
                        v.Add(new Voltage("DIMM", 6));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 2));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan", 1));
                        c.Add(new Control("CPU Fan", 2));
                        c.Add(new Control("System Fan", 1));

                        break;

                    case Model._970A_DS3P: // IT8620E
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DIMM", 1));
                        v.Add(new Voltage("+12V", 2, 5, 1));
                        v.Add(new Voltage("+5V", 3, 1.5f, 1));
                        v.Add(new Voltage("+3.3V", 4, 6.5f, 10));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU Package", 1));
                        t.Add(new Temperature("CPU Cores", 2));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("Power Fan", 4));
                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("System Fan #1", 1));
                        c.Add(new Control("System Fan #2", 2));

                        break;

                    case Model.H81M_HD3: //IT8620E
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+3.3V", 1, 6.5f, 10));
                        v.Add(new Voltage("+12V", 2, 5, 1));
                        v.Add(new Voltage("+5V", 3, 1.5f, 1));
                        v.Add(new Voltage("iGPU", 4));
                        v.Add(new Voltage("CPU Input Auxiliary", 5));
                        v.Add(new Voltage("DIMM", 6));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("System", 0));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan", 1));
                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("System Fan", 1));

                        break;

                    case Model.H97_D3H: //IT8620E
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+3.3V", 1, 6.5f, 10));
                        v.Add(new Voltage("+12V", 2, 5, 1));
                        v.Add(new Voltage("+5V", 3, 1.5f, 1));
                        v.Add(new Voltage("iGPU", 4));
                        v.Add(new Voltage("CPU Input Auxiliary", 5));
                        v.Add(new Voltage("DIMM", 6));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));

                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("System", 0));

                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("CPU Optional Fan", 1));
                        f.Add(new Fan("System Fan #1", 4));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("System Fan #3", 3));

                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("CPU Optional Fan", 1));
                        c.Add(new Control("System Fan #1", 4));
                        c.Add(new Control("System Fan #2", 2));
                        c.Add(new Control("System Fan #3", 3));

                        break;

                    case Model.Z170N_WIFI: // ITE IT8628E
                        v.Add(new Voltage("Vcore", 0, 0, 1));
                        v.Add(new Voltage("+3.3V", 1, 6.5F, 10));
                        v.Add(new Voltage("+12V", 2, 5, 1));
                        v.Add(new Voltage("+5V", 3, 1.5F, 1));
                        // NO DIMM C/D channels on this motherboard; gives a very tiny voltage reading
                        // v.Add(new Voltage("DIMM C/D", 4, 0, 1));
                        v.Add(new Voltage("iGPU VAXG", 5, 0, 1));
                        v.Add(new Voltage("DIMM A/B", 6, 0, 1));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));
                        v.Add(new Voltage("AVCC3", 9, 54, 10));

                        t.Add(new Temperature("System #1", 0));
                        t.Add(new Temperature("PCH", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM", 4));
                        t.Add(new Temperature("System #2", 5));

                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan", 1));

                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("System Fan", 1));

                        break;

                    case Model.AX370_Gaming_K7: // IT8686E
                    case Model.AX370_Gaming_5:
                    case Model.AB350_Gaming_3: // IT8686E
                        // Note: v3.3, v12, v5, and AVCC3 might be slightly off.
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+3.3V", 1, 0.65f, 1));
                        v.Add(new Voltage("+12V", 2, 5, 1));
                        v.Add(new Voltage("+5V", 3, 1.5f, 1));
                        v.Add(new Voltage("VSOC", 4));
                        v.Add(new Voltage("VDDP", 5));
                        v.Add(new Voltage("DIMM", 6));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));
                        v.Add(new Voltage("AVCC3", 9, 7.53f, 1));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("Chipset", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM MOS", 4));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + (i + 1), i));

                        break;

                    case Model.X399_AORUS_Gaming_7: // ITE IT8686E
                        v.Add(new Voltage("Vcore", 0, 0, 1));
                        v.Add(new Voltage("+3.3V", 1, 6.5F, 10));
                        v.Add(new Voltage("+12V", 2, 5, 1));
                        v.Add(new Voltage("+5V", 3, 1.5F, 1));
                        v.Add(new Voltage("DIMM C/D", 4, 0, 1));
                        v.Add(new Voltage("Vcore SoC", 5, 0, 1));
                        v.Add(new Voltage("DIMM A/B", 6, 0, 1));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));
                        v.Add(new Voltage("AVCC3", 9, 54, 10));
                        t.Add(new Temperature("System #1", 0));
                        t.Add(new Temperature("Chipset", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM", 4));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + (i + 1), i));

                        break;

                    case Model.B450_AORUS_PRO:
                        v.Add(new Voltage("Vcore", 0, 0, 1));
                        v.Add(new Voltage("+3.3V", 1, 6.5F, 10));
                        v.Add(new Voltage("+12V", 2, 5, 1));
                        v.Add(new Voltage("+5V", 3, 1.5F, 1));
                        v.Add(new Voltage("Vcore SoC", 4, 0, 1));
                        v.Add(new Voltage("VDDP", 5, 0, 1));
                        v.Add(new Voltage("DIMM", 6, 0, 1));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("Chipset", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM MOS", 4));
                        t.Add(new Temperature("VSoC MOS", 5));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("System Fan #3", 3));
                        f.Add(new Fan("CPU Optional Fan", 4));
                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("System Fan #1", 1));
                        c.Add(new Control("System Fan #2", 2));
                        c.Add(new Control("System Fan #3", 3));
                        c.Add(new Control("CPU Optional Fan", 4));

                        break;

                    case Model.B450_GAMING_X:
                    case Model.B450_AORUS_ELITE:
                    case Model.B450M_AORUS_ELITE:
                        v.Add(new Voltage("Vcore", 0, 0, 1));
                        v.Add(new Voltage("+3.3V", 1, 6.5F, 10));
                        v.Add(new Voltage("+12V", 2, 5, 1));
                        v.Add(new Voltage("+5V", 3, 1.5F, 1));
                        v.Add(new Voltage("Vcore SoC", 4, 0, 1));
                        v.Add(new Voltage("VDDP", 5, 0, 1));
                        v.Add(new Voltage("DIMM", 6, 0, 1));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("Chipset", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM MOS", 4));
                        t.Add(new Temperature("VSoC MOS", 5));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("System Fan #3", 3));
                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("System Fan #1", 1));
                        c.Add(new Control("System Fan #2", 2));
                        c.Add(new Control("System Fan #3", 3));

                        break;

                    case Model.B450M_GAMING: // ITE IT8686E
                    case Model.B450_AORUS_M:
                        v.Add(new Voltage("Vcore", 0, 0, 1));
                        v.Add(new Voltage("+3.3V", 1, 6.5F, 10));
                        v.Add(new Voltage("+12V", 2, 5, 1));
                        v.Add(new Voltage("+5V", 3, 1.5F, 1));
                        v.Add(new Voltage("Vcore SoC", 4, 0, 1));
                        v.Add(new Voltage("VDDP", 5, 0, 1));
                        v.Add(new Voltage("DIMM", 6, 0, 1));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("Chipset", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("VRM MOS", 4));
                        t.Add(new Temperature("VSoC MOS", 5));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("System Fan #1", 1));
                        c.Add(new Control("System Fan #2", 2));

                        break;

                    case Model.B450_I_AORUS_PRO_WIFI:
                    case Model.B450M_DS3H: // ITE IT8686E
                    case Model.B450M_S2H:
                    case Model.B450M_H:
                    case Model.B450M_K:
                        v.Add(new Voltage("Vcore", 0, 0, 1));
                        v.Add(new Voltage("+3.3V", 1, 6.5F, 10));
                        v.Add(new Voltage("+12V", 2, 5, 1));
                        v.Add(new Voltage("+5V", 3, 1.5F, 1));
                        v.Add(new Voltage("Vcore SoC", 4, 0, 1));
                        v.Add(new Voltage("VDDP", 5, 0, 1));
                        v.Add(new Voltage("DIMM", 6, 0, 1));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("Chipset", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("VRM MOS", 4));
                        t.Add(new Temperature("VSoC MOS", 5));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan", 1));
                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("System Fan", 1));

                        break;

                    case Model.X470_AORUS_GAMING_7_WIFI: // ITE IT8686E
                        v.Add(new Voltage("Vcore", 0, 0, 1));
                        v.Add(new Voltage("+3.3V", 1, 6.5F, 10));
                        v.Add(new Voltage("+12V", 2, 5, 1));
                        v.Add(new Voltage("+5V", 3, 1.5F, 1));
                        v.Add(new Voltage("Vcore SoC", 4, 0, 1));
                        v.Add(new Voltage("VDDP", 5, 0, 1));
                        v.Add(new Voltage("DIMM A/B", 6, 0, 1));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));
                        v.Add(new Voltage("AVCC3", 9, 54, 10));
                        t.Add(new Temperature("System #1", 0));
                        t.Add(new Temperature("Chipset", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM", 4));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + (i + 1), i));

                        break;

                    case Model.B560M_AORUS_ELITE: // IT8689E
                    case Model.B560M_AORUS_PRO:
                    case Model.B560M_AORUS_PRO_AX:
                    case Model.B560I_AORUS_PRO_AX:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+3.3V", 1, 29.4f, 45.3f));
                        v.Add(new Voltage("+12V", 2, 10f, 2f));
                        v.Add(new Voltage("+5V", 3, 15f, 10f));
                        v.Add(new Voltage("iGPU VAGX", 4));
                        v.Add(new Voltage("CPU System Agent", 5));
                        v.Add(new Voltage("DIMM", 6));
                        v.Add(new Voltage("+3V Standby", 7, 10f, 10f));
                        v.Add(new Voltage("CMOS Battery", 8, 10f, 10f));
                        v.Add(new Voltage("AVCC3", 9, 59.9f, 9.8f));
                        t.Add(new Temperature("System #1", 0));
                        t.Add(new Temperature("PCH", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM MOS", 4));
                        t.Add(new Temperature("System #2", 5));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("System Fan #3", 3));
                        f.Add(new Fan("CPU Optional Fan", 4));
                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("System Fan #1", 1));
                        c.Add(new Control("System Fan #2", 2));
                        c.Add(new Control("System Fan #3", 3));
                        c.Add(new Control("CPU Optional Fan", 4));

                        break;

                    case Model.B650_EAGLE_AX: // IT8689E
                    case Model.B650_AORUS_ELITE: // IT8689E
                    case Model.B650_AORUS_ELITE_AX: // IT8689E
                    case Model.B650_AORUS_ELITE_V2: // IT8689E
                    case Model.B650_AORUS_ELITE_AX_V2: // IT8689E
                    case Model.B650_AORUS_ELITE_AX_ICE: // IT8689E
                    case Model.B650_GAMING_X_AX: // IT8689E
                    case Model.B650E_AORUS_ELITE_AX_ICE: // IT8689E
                    case Model.B650M_AORUS_PRO: // IT8689E
                    case Model.B650M_AORUS_PRO_AX:
                    case Model.B650M_AORUS_ELITE:
                    case Model.B650M_AORUS_ELITE_AX:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+3.3V", 1, 29.4f, 45.3f));
                        v.Add(new Voltage("+12V", 2, 10f, 2f));
                        v.Add(new Voltage("+5V", 3, 15f, 10f));
                        v.Add(new Voltage("Vcore SoC", 4));
                        v.Add(new Voltage("Vcore Misc", 5));
                        v.Add(new Voltage("Dual DDR5 5V", 6, 1.5f, 1));
                        v.Add(new Voltage("+3V Standby", 7, 10f, 10f));
                        v.Add(new Voltage("CMOS Battery", 8, 10f, 10f));
                        v.Add(new Voltage("AVCC3", 9, 10f, 10f));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("PCH", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM MOS", 4));
                        t.Add(new Temperature("VSoC MOS", 5));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("System Fan #3", 3));

                        if (model == Model.B650_EAGLE_AX)
                        {
                            f.Add(new Fan("CPU Optional Fan", 4));
                        }
                        else
                        {
                            f.Add(new Fan("System Fan #4 / Pump", 4));
                            f.Add(new Fan("CPU Optional Fan", 5));
                        }

                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("System Fan #1", 1));
                        c.Add(new Control("System Fan #2", 2));
                        c.Add(new Control("System Fan #3", 3));

                        if (model == Model.B650_EAGLE_AX)
                        {
                            c.Add(new Control("CPU Optional Fan", 4));
                        }
                        else
                        {
                            c.Add(new Control("System Fan #4 / Pump", 4));
                            c.Add(new Control("CPU Optional Fan", 5));
                        }

                        break;

                    case Model.B650I_AX: // IT8689E
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+3.3V", 1, 29.4f, 45.3f));
                        v.Add(new Voltage("+12V", 2, 10f, 2f));
                        v.Add(new Voltage("+5V", 3, 15f, 10f));
                        v.Add(new Voltage("Vcore SoC", 4));
                        v.Add(new Voltage("Vcore Misc", 5));

                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("PCH", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("VRM MOS", 4));
                        t.Add(new Temperature("VSoC MOS", 5));

                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));

                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("System Fan #1", 1));
                        c.Add(new Control("System Fan #2", 2));

                        break;

                    case Model.A320M_S2H_CF: // IT8686E
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+3.3V", 1, 29.4f, 45.3f));
                        v.Add(new Voltage("+12V", 2, 10f, 2f));
                        v.Add(new Voltage("+5V", 3, 15f, 10f));
                        v.Add(new Voltage("CPU Vcore SoC", 4));
                        v.Add(new Voltage("CPU VDDP", 5));
                        v.Add(new Voltage("DRAM", 6));
                        v.Add(new Voltage("+3V Standby", 7, 1, 1));
                        v.Add(new Voltage("CMOS Battery", 8, 1, 1));
                        v.Add(new Voltage("AVCC3", 9, 1, 1));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("Chipset", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM MOS", 4));
                        t.Add(new Temperature("VSoC MOS", 5));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan", 1));
                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("System Fan", 1));

                        break;

                    case Model.B360M_H: // IT8686E
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+3.3V", 1, 29.4f, 45.3f));
                        v.Add(new Voltage("+12V", 2, 10f, 2f));
                        v.Add(new Voltage("+5V", 3, 15f, 10f));
                        v.Add(new Voltage("VCCSA", 5));
                        v.Add(new Voltage("DIMM A/B", 6));
                        v.Add(new Voltage("+3V Standby", 7, 1, 1));
                        v.Add(new Voltage("CMOS Battery", 8, 1, 1));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("PCH", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("VRM MOS", 4));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan", 1));
                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("System Fan", 1));

                        break;

                    case Model.B360_AORUS_GAMING_3_WIFI_CF: // IT8688E
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+3.3V", 1, 29.4f, 45.3f));
                        v.Add(new Voltage("+12V", 2, 10f, 2f));
                        v.Add(new Voltage("+5V", 3, 15f, 10f));
                        v.Add(new Voltage("CPU Vcore", 4, 0, 1));
                        v.Add(new Voltage("CPU System Agent", 5, 0, 1));
                        v.Add(new Voltage("DIMM A/B", 6, 0, 1));
                        v.Add(new Voltage("+3V Standby", 7, 1, 1));
                        v.Add(new Voltage("CMOS Battery", 8, 1, 1));
                        t.Add(new Temperature("System #1", 0));
                        t.Add(new Temperature("EC_TEMP1", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM MOS", 4));
                        t.Add(new Temperature("PCH", 5));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("PCH Fan", 3));
                        f.Add(new Fan("CPU Optional Fan", 4));
                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("System Fan #1", 1));
                        c.Add(new Control("System Fan #2", 2));
                        c.Add(new Control("PCH Fan", 3));
                        c.Add(new Control("CPU Optional Fan", 4));

                        break;

                    case Model.X570_AORUS_MASTER: // IT8688E
                    case Model.X570_AORUS_ULTRA:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+3.3V", 1, 29.4f, 45.3f));
                        v.Add(new Voltage("+12V", 2, 10f, 2f));
                        v.Add(new Voltage("+5V", 3, 15f, 10f));
                        v.Add(new Voltage("Vcore SoC", 4));
                        v.Add(new Voltage("VDDP", 5));
                        v.Add(new Voltage("DIMM A/B", 6));
                        v.Add(new Voltage("+3V Standby", 7, 1f, 10f));
                        v.Add(new Voltage("CMOS Battery", 8, 1f, 10f));
                        t.Add(new Temperature("System #1", 0));
                        t.Add(new Temperature("EC_TEMP1", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM MOS", 4));
                        t.Add(new Temperature("PCH", 5));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("PCH Fan", 3));
                        f.Add(new Fan("CPU Optional Fan", 4));
                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("System Fan #1", 1));
                        c.Add(new Control("System Fan #2", 2));
                        c.Add(new Control("PCH Fan", 3));
                        c.Add(new Control("CPU Optional Fan", 4));

                        break;

                    case Model.X570_AORUS_PRO: // IT8688E
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+3.3V", 1, 29.4f, 45.3f));
                        v.Add(new Voltage("+12V", 2, 10f, 2f));
                        v.Add(new Voltage("+5V", 3, 15f, 10f));
                        v.Add(new Voltage("Vcore SoC", 4));
                        v.Add(new Voltage("VDDP", 5));
                        v.Add(new Voltage("DIMM A/B", 6));
                        v.Add(new Voltage("+3V Standby", 7, 10f, 10f));
                        v.Add(new Voltage("CMOS Battery", 8, 10f, 10f));
                        t.Add(new Temperature("System #1", 0));
                        t.Add(new Temperature("External #1", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM MOS", 4));
                        t.Add(new Temperature("PCH", 5));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("PCH Fan", 3));
                        f.Add(new Fan("CPU Optional Fan", 4));
                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("System Fan #1", 1));
                        c.Add(new Control("System Fan #2", 2));
                        c.Add(new Control("PCH Fan", 3));
                        c.Add(new Control("CPU Optional Fan", 4));

                        break;

                    case Model.X570_GAMING_X: // IT8688E
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+3.3V", 1, 29.4f, 45.3f));
                        v.Add(new Voltage("+12V", 2, 10f, 2f));
                        v.Add(new Voltage("+5V", 3, 15f, 10f));
                        v.Add(new Voltage("Vcore SoC", 4));
                        v.Add(new Voltage("VDDP", 5));
                        v.Add(new Voltage("DIMM A/B", 6));
                        t.Add(new Temperature("System #1", 0));
                        t.Add(new Temperature("System #2", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM MOS", 4));
                        t.Add(new Temperature("PCH", 5));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("PCH Fan", 3));
                        f.Add(new Fan("CPU Optional Fan", 4));
                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("System Fan #1", 1));
                        c.Add(new Control("System Fan #2", 2));
                        c.Add(new Control("PCH Fan", 3));
                        c.Add(new Control("CPU Optional Fan", 4));

                        break;

                    case Model.Z390_M_GAMING: // IT8688E
                    case Model.Z390_AORUS_ULTRA:
                    case Model.Z390_UD:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+3.3V", 1, 6.49f, 10));
                        v.Add(new Voltage("+12V", 2, 5f, 1));
                        v.Add(new Voltage("+5V", 3, 1.5f, 1));
                        v.Add(new Voltage("CPU VCCGT", 4));
                        v.Add(new Voltage("CPU System Agent", 5));
                        v.Add(new Voltage("VDDQ", 6));
                        v.Add(new Voltage("DDRVTT", 7));
                        v.Add(new Voltage("PCHCore", 8));
                        v.Add(new Voltage("CPU VCCIO", 9));
                        v.Add(new Voltage("DDRVPP", 10));
                        t.Add(new Temperature("System #1", 0));
                        t.Add(new Temperature("PCH", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM MOS", 4));
                        t.Add(new Temperature("System #2", 5));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("System Fan #3", 3));
                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("System Fan #1", 1));
                        c.Add(new Control("System Fan #2", 2));
                        c.Add(new Control("System Fan #3", 3));

                        break;

                    case Model.Z390_AORUS_PRO:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+3.3V", 1, 6.49f, 10));
                        v.Add(new Voltage("+12V", 2, 5f, 1));
                        v.Add(new Voltage("+5V", 3, 1.5f, 1));
                        v.Add(new Voltage("CPU VCCGT", 4));
                        v.Add(new Voltage("CPU System Agent", 5));
                        v.Add(new Voltage("DDR", 6));
                        v.Add(new Voltage("Voltage #7", 7, true));
                        v.Add(new Voltage("+3V Standby", 8, 1f, 1f, -0.312f));
                        v.Add(new Voltage("CMOS Battery", 9, 6f, 1f, 0.01f));
                        v.Add(new Voltage("AVCC3", 10, 6f, 1f, 0.048f));
                        t.Add(new Temperature("System #1", 0));
                        t.Add(new Temperature("PCH", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM MOS", 4));
                        t.Add(new Temperature("EC_TEMP1/System #2", 5));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("System Fan #3", 3));
                        f.Add(new Fan("CPU Optional Fan", 4));
                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("System Fan #1", 1));
                        c.Add(new Control("System Fan #2", 2));
                        c.Add(new Control("System Fan #3", 3));
                        c.Add(new Control("CPU Optional Fan", 4));

                        break;

                    case Model.Z790_UD: // ITE IT8689E
                    case Model.Z790_UD_AC: // ITE IT8689E
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+3.3V", 1, 6.49f, 10));
                        v.Add(new Voltage("+12V", 2, 5f, 1));
                        v.Add(new Voltage("+5V", 3, 1.5f, 1));
                        v.Add(new Voltage("iGPU", 4));
                        v.Add(new Voltage("CPU Input Auxiliary", 5));
                        v.Add(new Voltage("Dual DDR5 5V", 6, 1.5f, 1));
                        v.Add(new Voltage("+3V Standby", 7, 1, 1));
                        v.Add(new Voltage("CMOS Battery", 8, 1, 1));
                        v.Add(new Voltage("AVCC3", 9, true));
                        t.Add(new Temperature("System #1", 0));
                        t.Add(new Temperature("Chipset", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM MOS", 4));
                        t.Add(new Temperature("System #2", 5));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("System Fan #3 / Pump", 3));
                        f.Add(new Fan("CPU Optional Fan", 4));
                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("System Fan #1", 1));
                        c.Add(new Control("System Fan #2", 2));
                        c.Add(new Control("System Fan #3 / Pump", 3));
                        c.Add(new Control("CPU Optional Fan", 4));
                        break;

                    case Model.Z790_GAMING_X: // ITE IT8689E
                    case Model.Z790_GAMING_X_AX: // ITE IT8689E
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+3.3V", 1, 6.49f, 10));
                        v.Add(new Voltage("+12V", 2, 5f, 1));
                        v.Add(new Voltage("+5V", 3, 1.5f, 1));
                        v.Add(new Voltage("iGPU", 4));
                        v.Add(new Voltage("CPU Input Auxiliary", 5));
                        v.Add(new Voltage("Dual DDR5 5V", 6, 1.5f, 1));
                        v.Add(new Voltage("+3V Standby", 7, 1, 1));
                        v.Add(new Voltage("CMOS Battery", 8, 1, 1));
                        v.Add(new Voltage("AVCC3", 9, true));
                        t.Add(new Temperature("System #1", 0));
                        t.Add(new Temperature("Chipset", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM MOS", 4));
                        t.Add(new Temperature("System #2", 5));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("System Fan #3", 3));
                        f.Add(new Fan("System Fan #4 / Pump", 4));
                        f.Add(new Fan("CPU Optional Fan", 5));
                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("System Fan #1", 1));
                        c.Add(new Control("System Fan #2", 2));
                        c.Add(new Control("System Fan #3", 3));
                        c.Add(new Control("System Fan #4 / Pump", 4));
                        c.Add(new Control("CPU Optional Fan", 5));
                        break;

                    case Model.Z790_AORUS_PRO_X: // ITE IT8689E
                    case Model.Z690_AORUS_PRO:
                    case Model.Z690_AORUS_ULTRA: // ITE IT8689E
                    case Model.Z690_AORUS_MASTER: // ITE IT8689E
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+3.3V", 1, 6.49f, 10));
                        v.Add(new Voltage("+12V", 2, 5f, 1));
                        v.Add(new Voltage("+5V", 3, 1.5f, 1));
                        v.Add(new Voltage("iGPU VAXG", 4));
                        v.Add(new Voltage("CPU Input Auxiliary", 5));
                        v.Add(new Voltage("Dual DDR5 5V", 6, 1.5f, 1));
                        v.Add(new Voltage("+3V Standby", 7, 1f, 1f));
                        v.Add(new Voltage("CMOS Battery", 8, 1f, 1f));
                        v.Add(new Voltage("AVCC3", 9, true));
                        t.Add(new Temperature("System #1", 0));
                        t.Add(new Temperature("PCH", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM MOS", 4));
                        t.Add(new Temperature("External #1", 5));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("System Fan #3 / Pump", 3));
                        f.Add(new Fan("CPU Optional Fan", 4));
                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("System Fan #1", 1));
                        c.Add(new Control("System Fan #2", 2));
                        c.Add(new Control("System Fan #3 / Pump", 3));
                        c.Add(new Control("CPU Optional Fan", 4));
                        break;

                    case Model.X870_AORUS_ELITE_WIFI7: // ITE IT8696E
                    case Model.X870_AORUS_ELITE_WIFI7_ICE: // ITE IT8696E
                        t.Add(new Temperature("System #1", 0));
                        t.Add(new Temperature("PCH", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM MOS", 4));
                        t.Add(new Temperature("EC", 5));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("System Fan #3", 3));
                        f.Add(new Fan("CPU Optional Fan", 4));
                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("System Fan #1", 1));
                        c.Add(new Control("System Fan #2", 2));
                        c.Add(new Control("System Fan #3", 3));
                        c.Add(new Control("CPU Optional Fan", 4));
                        break;

                    case Model.Z690_GAMING_X_DDR4:
                        t.Add(new Temperature("System #1", 0));
                        t.Add(new Temperature("PCH", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM MOS", 4));
                        t.Add(new Temperature("System #2", 5));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("System Fan #3", 3));
                        f.Add(new Fan("CPU Optional Fan", 4));
                        f.Add(new Fan("System Fan #4 / Pump", 5));
                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("System Fan #1", 1));
                        c.Add(new Control("System Fan #2", 2));
                        c.Add(new Control("System Fan #3", 3));
                        c.Add(new Control("CPU Optional Fan", 4));
                        c.Add(new Control("System Fan #4 / Pump", 5));
                        break;

                    case Model.Z68A_D3H_B3: // IT8728F
                        v.Add(new Voltage("CPU Termination", 0));
                        v.Add(new Voltage("+3.3V", 1, 6.49f, 10));
                        v.Add(new Voltage("+12V", 2, 30.9f, 10));
                        v.Add(new Voltage("+5V", 3, 7.15f, 10));
                        v.Add(new Voltage("Vcore", 5));
                        v.Add(new Voltage("DIMM", 6));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 2));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("Power Fan", 2));
                        f.Add(new Fan("System Fan #2", 3));

                        break;

                    case Model.P67A_UD3_B3: // IT8728F
                    case Model.P67A_UD3R_B3: // IT8728F
                    case Model.P67A_UD4_B3: // IT8728F
                    case Model.Z68AP_D3: // IT8728F
                    case Model.Z68X_UD3H_B3: // IT8728F
                    case Model.Z68XP_UD3R: // IT8728F
                        v.Add(new Voltage("CPU Termination", 0));
                        v.Add(new Voltage("+3.3V", 1, 6.49f, 10));
                        v.Add(new Voltage("+12V", 2, 30.9f, 10));
                        v.Add(new Voltage("+5V", 3, 7.15f, 10));
                        v.Add(new Voltage("Vcore", 5));
                        v.Add(new Voltage("DIMM", 6));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 2));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #2", 1));
                        f.Add(new Fan("Power Fan", 2));
                        f.Add(new Fan("System Fan #1", 3));

                        break;

                    case Model.Z68X_UD7_B3: // IT8728F
                        v.Add(new Voltage("CPU Termination", 0));
                        v.Add(new Voltage("+3.3V", 1, 6.49f, 10));
                        v.Add(new Voltage("+12V", 2, 30.9f, 10));
                        v.Add(new Voltage("+5V", 3, 7.15f, 10));
                        v.Add(new Voltage("Vcore", 5));
                        v.Add(new Voltage("DIMM", 6));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("System #3", 2));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("Power Fan", 1));
                        f.Add(new Fan("System Fan #1", 2));
                        f.Add(new Fan("System Fan #2", 3));
                        f.Add(new Fan("System Fan #3", 4));

                        break;

                    case Model.X79_UD3: // IT8728F
                        v.Add(new Voltage("CPU Termination", 0));
                        v.Add(new Voltage("DIMM A/B", 1));
                        v.Add(new Voltage("+12V", 2, 10, 2));
                        v.Add(new Voltage("+5V", 3, 15, 10));
                        v.Add(new Voltage("VIN4", 4));
                        v.Add(new Voltage("VCore", 5));
                        v.Add(new Voltage("DIMM C/D", 6));
                        v.Add(new Voltage("+3V Standby", 7, 1, 1));
                        v.Add(new Voltage("CMOS Battery", 8, 1, 1));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("Northbridge", 2));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("System Fan #3", 3));
                        f.Add(new Fan("System Fan #4", 4));
                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("System Fan #1", 1));
                        c.Add(new Control("System Fan #2", 2));

                        break;

                    case Model.B550_AORUS_MASTER:
                    case Model.B550_AORUS_PRO:
                    case Model.B550_AORUS_PRO_AC:
                    case Model.B550_AORUS_PRO_AX:
                    case Model.B550_VISION_D:
                        v.Add(new Voltage("Vcore", 0, 0, 1));
                        v.Add(new Voltage("+3.3V", 1, 6.5F, 10));
                        v.Add(new Voltage("+12V", 2, 5, 1));
                        v.Add(new Voltage("+5V", 3, 1.5F, 1));
                        v.Add(new Voltage("Vcore SoC", 4, 0, 1));
                        v.Add(new Voltage("VDDP", 5, 0, 1));
                        v.Add(new Voltage("DIMM", 6, 0, 1));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));
                        t.Add(new Temperature("System #1", 0));
                        t.Add(new Temperature("External #1", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM MOS", 4));
                        t.Add(new Temperature("Chipset", 5));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("System Fan #3", 3));
                        f.Add(new Fan("CPU Optional Fan", 4));
                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("System Fan #1", 1));
                        c.Add(new Control("System Fan #2", 2));
                        c.Add(new Control("System Fan #3", 3));
                        c.Add(new Control("CPU Optional Fan", 4));

                        break;

                    case Model.B550_AORUS_ELITE:
                    case Model.B550_AORUS_ELITE_AX:
                    case Model.B550_GAMING_X:
                    case Model.B550_UD_AC:
                    case Model.B550M_AORUS_PRO:
                    case Model.B550M_AORUS_PRO_AX:
                        v.Add(new Voltage("Vcore", 0, 0, 1));
                        v.Add(new Voltage("+3.3V", 1, 6.5F, 10));
                        v.Add(new Voltage("+12V", 2, 5, 1));
                        v.Add(new Voltage("+5V", 3, 1.5F, 1));
                        v.Add(new Voltage("Vcore SoC", 4, 0, 1));
                        v.Add(new Voltage("VDDP", 5, 0, 1));
                        v.Add(new Voltage("DIMM", 6, 0, 1));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));
                        t.Add(new Temperature("System #1", 0));
                        t.Add(new Temperature("System #2", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM MOS", 4));
                        t.Add(new Temperature("Chipset", 5));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("System Fan #3", 3));
                        f.Add(new Fan("CPU Optional Fan", 4));
                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("System Fan #1", 1));
                        c.Add(new Control("System Fan #2", 2));
                        c.Add(new Control("System Fan #3", 3));
                        c.Add(new Control("CPU Optional Fan", 4));

                        break;

                    case Model.B550I_AORUS_PRO_AX:
                    case Model.B550M_AORUS_ELITE:
                    case Model.B550M_GAMING:
                    case Model.B550M_DS3H:
                    case Model.B550M_DS3H_AC:
                    case Model.B550M_S2H:
                    case Model.B550M_H:
                        v.Add(new Voltage("Vcore", 0, 0, 1));
                        v.Add(new Voltage("+3.3V", 1, 6.5F, 10));
                        v.Add(new Voltage("+12V", 2, 5, 1));
                        v.Add(new Voltage("+5V", 3, 1.5F, 1));
                        v.Add(new Voltage("Vcore SoC", 4, 0, 1));
                        v.Add(new Voltage("VDDP", 5, 0, 1));
                        v.Add(new Voltage("DIMM", 6, 0, 1));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("VSoC MOS", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("VRM MOS", 4));
                        t.Add(new Temperature("Chipset", 5));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("System Fan #1", 1));
                        c.Add(new Control("System Fan #2", 2));

                        break;

                    case Model.B660_DS3H_DDR4:
                    case Model.B660_DS3H_AC_DDR4:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+3.3V", 1, 6.5F, 10));
                        v.Add(new Voltage("+12V", 2, 5, 1));
                        v.Add(new Voltage("+5V", 3, 1.5F, 1));
                        v.Add(new Voltage("iGPU", 4));
                        v.Add(new Voltage("CPU Input Auxiliary", 5));
                        v.Add(new Voltage("DIMM", 6));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));
                        t.Add(new Temperature("System #1", 0));
                        t.Add(new Temperature("Chipset", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM MOS", 4));
                        t.Add(new Temperature("System #2", 5));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("System Fan #3 / Pump", 3));
                        f.Add(new Fan("CPU Optional Fan", 4));
                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("System Fan #1", 1));
                        c.Add(new Control("System Fan #2", 2));
                        c.Add(new Control("System Fan #3 / Pump", 3));
                        c.Add(new Control("CPU Optional Fan", 4));

                        break;

                    case Model.B660M_DS3H_AX_DDR4:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("VAXG", 1));
                        v.Add(new Voltage("CPU Input Auxiliary", 2));
                        v.Add(new Voltage("DIMM A/B", 3));
                        v.Add(new Voltage("+12V", 4));
                        v.Add(new Voltage("+3.3V", 5));
                        v.Add(new Voltage("+5V", 6));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("PCH", 1));
                        t.Add(new Temperature("PCIe x16", 2));
                        t.Add(new Temperature("System #1", 3));
                        t.Add(new Temperature("System #2", 4));
                        t.Add(new Temperature("VRAM MOS", 5));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 2));
                        f.Add(new Fan("System Fan #2", 3));
                        f.Add(new Fan("System Fan #3", 4));
                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("System Fan #1", 2));
                        c.Add(new Control("System Fan #2", 3));
                        c.Add(new Control("System Fan #3", 4));

                        break;

                    case Model.X670E_AORUS_XTREME: // IT8689E
                    case Model.X870E_AORUS_PRO: // ITE IT8696E
                    case Model.X870E_AORUS_PRO_ICE: // ITE IT8696E
                    case Model.X870E_AORUS_XTREME_AI_TOP: // ITE IT8696E
                        v.Add(new Voltage("Vcore", 0, 0, 1));
                        v.Add(new Voltage("+3.3V", 1, 6.49F, 10));
                        v.Add(new Voltage("+12V", 2, 5, 1));
                        v.Add(new Voltage("+5V", 3, 1.5F, 1));
                        v.Add(new Voltage("Vcore SoC", 4, 0, 1));
                        v.Add(new Voltage("Vcore Misc", 5, 0, 1));
                        v.Add(new Voltage("CPU VDDIO Memory", 6, 0, 1));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));
                        t.Add(new Temperature("System #1", 0));
                        t.Add(new Temperature("PCH", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM MOS", 4));
                        t.Add(new Temperature("External #1", 5));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("System Fan #3", 3));
                        f.Add(new Fan("CPU Optional Fan", 4));
                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("System Fan #1", 1));
                        c.Add(new Control("System Fan #2", 2));
                        c.Add(new Control("System Fan #3", 3));
                        c.Add(new Control("CPU Optional Fan", 4));

                        break;

                    case Model.X670_AORUS_ELITE_AX:
                        v.Add(new Voltage("Vcore", 0, 0, 1));
                        v.Add(new Voltage("+3.3V", 1, 6.49F, 10));
                        v.Add(new Voltage("+12V", 2, 5, 1));
                        v.Add(new Voltage("+5V", 3, 1.5F, 1));
                        v.Add(new Voltage("Vcore SoC", 4, 0, 1));
                        v.Add(new Voltage("Vcore Misc", 5, 0, 1));
                        v.Add(new Voltage("CPU VDDIO Memory", 6, 0, 1));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10, 0));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));

                        t.Add(new Temperature("System #1", 0));
                        t.Add(new Temperature("PCH", 1));
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("PCIe x16", 3));
                        t.Add(new Temperature("VRM MOS", 4));

                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("System Fan #1", 1));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("System Fan #3", 3));
                        f.Add(new Fan("CPU Optional Fan", 4));

                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("System Fan #1", 1));
                        c.Add(new Control("System Fan #2", 2));
                        c.Add(new Control("System Fan #3", 3));
                        c.Add(new Control("CPU Optional Fan", 4));

                        break;

                    default:
                        v.Add(new Voltage("Voltage #1", 0, true));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("Voltage #3", 2, true));
                        v.Add(new Voltage("Voltage #4", 3, true));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10, 0, true));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));

                        for (int i = 0; i < superIO.Temperatures.Length; i++)
                            t.Add(new Temperature("Temperature #" + (i + 1), i));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + (i + 1), i));

                        break;
                }

                break;
            case Manufacturer.Biostar:
                switch (model)
                {
                    case Model.B660GTN: //IT8613E
                        // This board has some problems with their app controlling fans that I was able to replicate here so I guess is a BIOS problem with the pins.
                        // Biostar is aware so expect changes in the control pins with new bios.
                        // In the meantime, it's possible to control CPUFAN and CPUOPT1m but not SYSFAN1.
                        // The parameters are extracted from the Biostar app config file.
                        v.Add(new Voltage("Vcore", 0, 0, 1));
                        v.Add(new Voltage("DIMM", 1, 0, 1));
                        v.Add(new Voltage("+12V", 2, 5, 1)); // Reads higher than it should.
                        v.Add(new Voltage("+5V", 3, 147, 100)); // Reads higher than it should.
                        // Commented because I don't know if it makes sense.
                        //v.Add(new Voltage("VCC ST", 4)); // Reads 4.2V.
                        //v.Add(new Voltage("CPU Input Auxiliary", 5)); // Reads 2.2V.
                        //v.Add(new Voltage("CPU GT", 6)); // Reads 2.6V.
                        //v.Add(new Voltage("+3V Standby", 7, 10, 10)); // Reads 5.8V ?
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10)); // Reads higher than it should at 3.4V.
                        t.Add(new Temperature("System 1", 0));
                        t.Add(new Temperature("System 2", 1)); // Not sure what sensor is this.
                        t.Add(new Temperature("CPU", 2));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("CPU Optional fan", 2));
                        f.Add(new Fan("System Fan", 4));
                        c.Add(new Control("CPU Fan", 1));
                        c.Add(new Control("CPU Optional Fan", 2));
                        c.Add(new Control("System Fan", 4));

                        break;

                    case Model.X670E_Valkyrie: //IT8625E
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DIMM", 1));
                        v.Add(new Voltage("+12V", 2, 10, 2));
                        // Voltage of unknown use
                        v.Add(new Voltage("Voltage #4", 3, true));
                        // The biostar utility shows CPU MISC Voltage.
                        v.Add(new Voltage("Voltage #5", 4));
                        v.Add(new Voltage("VDDP", 5));
                        v.Add(new Voltage("VSOC", 6));

                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("VRM", 1));
                        t.Add(new Temperature("System", 2));

                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("CPU Optional Fan", 1));
                        for (int i = 2; i < superIO.Fans.Length; i++)
                            f.Add(new Fan($"System Fan #{i - 1}", i));

                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("CPU Optional Fan", 1));
                        for (int i = 2; i < superIO.Controls.Length; i++)
                            c.Add(new Control($"System Fan #{i - 1}", i));

                        break;

                    default:
                        v.Add(new Voltage("Voltage #1", 0, true));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("Voltage #3", 2, true));
                        v.Add(new Voltage("Voltage #4", 3, true));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10, 0, true));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));

                        for (int i = 0; i < superIO.Temperatures.Length; i++)
                            t.Add(new Temperature("Temperature #" + (i + 1), i));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + (i + 1), i));

                        break;
                }

                break;
            case Manufacturer.Shuttle:
                switch (model)
                {
                    case Model.FH67: // IT8772E
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DIMM", 1));
                        v.Add(new Voltage("PCH VCCIO", 2));
                        v.Add(new Voltage("CPU VCCIO", 3));
                        v.Add(new Voltage("Graphics", 4));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));
                        t.Add(new Temperature("System", 0));
                        t.Add(new Temperature("CPU", 1));
                        f.Add(new Fan("Fan #1", 0));
                        f.Add(new Fan("CPU Fan", 1));

                        break;

                    default:
                        v.Add(new Voltage("Voltage #1", 0, true));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("Voltage #3", 2, true));
                        v.Add(new Voltage("Voltage #4", 3, true));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10, 0, true));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));

                        for (int i = 0; i < superIO.Temperatures.Length; i++)
                            t.Add(new Temperature("Temperature #" + (i + 1), i));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + (i + 1), i));

                        break;
                }

                break;

            default:
                v.Add(new Voltage("Voltage #1", 0, true));
                v.Add(new Voltage("Voltage #2", 1, true));
                v.Add(new Voltage("Voltage #3", 2, true));
                v.Add(new Voltage("Voltage #4", 3, true));
                v.Add(new Voltage("Voltage #5", 4, true));
                v.Add(new Voltage("Voltage #6", 5, true));
                v.Add(new Voltage("Voltage #7", 6, true));
                v.Add(new Voltage("+3V Standby", 7, 10, 10, 0, true));
                v.Add(new Voltage("CMOS Battery", 8, 10, 10));

                for (int i = 0; i < superIO.Temperatures.Length; i++)
                    t.Add(new Temperature("Temperature #" + (i + 1), i));

                for (int i = 0; i < superIO.Fans.Length; i++)
                    f.Add(new Fan("Fan #" + (i + 1), i));

                for (int i = 0; i < superIO.Controls.Length; i++)
                    c.Add(new Control("Fan #" + (i + 1), i));

                break;
        }
    }

    private static void GetIteConfigurationsC(ISuperIO superIO, Manufacturer manufacturer, Model model, IList<Voltage> v, IList<Temperature> t, IList<Fan> f, IList<Control> c)
    {
        switch (manufacturer)
        {
            case Manufacturer.Gigabyte:
                switch (model)
                {
                    case Model.X570_AORUS_MASTER: // IT879XE
                    case Model.X570_AORUS_PRO:
                    case Model.X570_AORUS_ULTRA:
                    case Model.B550_AORUS_MASTER:
                    case Model.B550_AORUS_PRO:
                    case Model.B550_AORUS_PRO_AC:
                    case Model.B550_AORUS_PRO_AX:
                    case Model.B550_VISION_D:
                        v.Add(new Voltage("VIN0", 0));
                        v.Add(new Voltage("DDRVTT AB", 1));
                        v.Add(new Voltage("Chipset Core", 2));
                        v.Add(new Voltage("Voltage #4", 3, true));
                        v.Add(new Voltage("CPU VDD18", 4));
                        v.Add(new Voltage("PM_CLDO12", 5));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3V Standby", 7, 1f, 1f));
                        v.Add(new Voltage("CMOS Battery", 8, 1f, 1f));
                        t.Add(new Temperature("PCIe x8", 0));
                        t.Add(new Temperature("External #2", 1));
                        t.Add(new Temperature("System #2", 2));
                        f.Add(new Fan("System Fan #5 / Pump", 0));
                        f.Add(new Fan("System Fan #6 / Pump", 1));
                        f.Add(new Fan("System Fan #4", 2));
                        c.Add(new Control("System Fan #5 / Pump", 0));
                        c.Add(new Control("System Fan #6 / Pump", 1));
                        c.Add(new Control("System Fan #4", 2));

                        break;

                    case Model.X470_AORUS_GAMING_7_WIFI: // ITE IT8792
                        v.Add(new Voltage("VIN0", 0, 0, 1));
                        v.Add(new Voltage("DDR VTT", 1, 0, 1));
                        v.Add(new Voltage("Chipset Core", 2, 0, 1));
                        v.Add(new Voltage("VIN3", 3, 0, 1));
                        v.Add(new Voltage("CPU VDD18", 4, 0, 1));
                        v.Add(new Voltage("Chipset Core +2.5V", 5, 0.5F, 1));
                        v.Add(new Voltage("+3V Standby", 6, 1, 10));
                        v.Add(new Voltage("CMOS Battery", 7, 0.7F, 1));
                        t.Add(new Temperature("PCIe x8", 0));
                        t.Add(new Temperature("System #2", 2));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + (i + 1), i));

                        break;

                    case Model.Z390_AORUS_PRO: // IT879XE
                        v.Add(new Voltage("VCore", 0));
                        v.Add(new Voltage("DDRVTT AB", 1));
                        v.Add(new Voltage("Chipset Core", 2));
                        v.Add(new Voltage("VIN3", 3, true));
                        v.Add(new Voltage("VCCIO", 4));
                        v.Add(new Voltage("Voltage #7", 5, true));
                        v.Add(new Voltage("DDR VPP", 6));
                        v.Add(new Voltage("+3V Standby", 7, 1f, 1f));
                        v.Add(new Voltage("CMOS Battery", 8, 1f, 1f));
                        t.Add(new Temperature("PCIe x8", 0));
                        t.Add(new Temperature("External #2", 1));
                        t.Add(new Temperature("System #2", 2));
                        f.Add(new Fan("System Fan #5 / Pump", 0));
                        f.Add(new Fan("System Fan #6 / Pump", 1));
                        f.Add(new Fan("System Fan #4", 2));
                        c.Add(new Control("System Fan #5 / Pump", 0));
                        c.Add(new Control("System Fan #6 / Pump", 1));
                        c.Add(new Control("System Fan #4", 2));

                        break;

                    case Model.Z790_AORUS_PRO_X: // ITE IT87952E
                    case Model.Z690_AORUS_PRO:
                    case Model.Z690_AORUS_MASTER: // ITE IT87952E
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DIMM I/O", 1));
                        v.Add(new Voltage("Chipset +0.82V", 2));
                        v.Add(new Voltage("Voltage #4", 3, true));
                        v.Add(new Voltage("CPU System Agent", 4));
                        v.Add(new Voltage("Chipset +1.8V", 5));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));
                        t.Add(new Temperature("PCIe x4", 0));
                        t.Add(new Temperature("External #2", 1));
                        t.Add(new Temperature("System #2", 2));
                        f.Add(new Fan("System Fan #5 / Pump", 0));
                        f.Add(new Fan("System Fan #6 / Pump", 1));
                        f.Add(new Fan("System Fan #4", 2));
                        c.Add(new Control("System Fan #5 / Pump", 0));
                        c.Add(new Control("System Fan #6 / Pump", 1));
                        c.Add(new Control("System Fan #4", 2));
                        break;

                    case Model.X870E_AORUS_PRO:
                    case Model.X870E_AORUS_PRO_ICE: // ITE IT87952E
                    case Model.X870E_AORUS_XTREME_AI_TOP: // ITE IT87952E
                        v.Add(new Voltage("VIN0", 0));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("PM_VCC18", 2));
                        v.Add(new Voltage("VIN3", 3));
                        v.Add(new Voltage("CPU VDD18", 4));
                        v.Add(new Voltage("PM_VDD1V", 5));
                        v.Add(new Voltage("VIN6", 6));
                        v.Add(new Voltage("+3V Standby", 7, 1, 1));
                        v.Add(new Voltage("CMOS Battery", 8, 1, 1));
                        t.Add(new Temperature("PCIe x4", 0));
                        t.Add(new Temperature("External #2", 1));
                        t.Add(new Temperature("System #2", 2));
                        f.Add(new Fan("System Fan #5 / Pump", 0));
                        f.Add(new Fan("System Fan #6 / Pump", 1));
                        f.Add(new Fan("System Fan #4 ", 2));
                        c.Add(new Control("System Fan #5 / Pump", 0));
                        c.Add(new Control("System Fan #6 / Pump", 1));
                        c.Add(new Control("System Fan #4", 2));
                        break;

                    case Model.X870_AORUS_ELITE_WIFI7: // ITE IT87952E
                    case Model.X870_AORUS_ELITE_WIFI7_ICE: // ITE IT87952E
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("DIMM I/O", 1));
                        v.Add(new Voltage("Chipset +0.82V", 2));
                        v.Add(new Voltage("Voltage #4", 3, true));
                        v.Add(new Voltage("CPU System Agent", 4));
                        v.Add(new Voltage("Chipset +1.8V", 5));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));
                        t.Add(new Temperature("PCIe x4", 0));
                        t.Add(new Temperature("External #2", 1));
                        t.Add(new Temperature("System #2", 2));
                        f.Add(new Fan("System Fan #5 / Pump", 0));
                        f.Add(new Fan("System Fan #6 / Pump", 1));
                        f.Add(new Fan("System Fan #4", 2));
                        c.Add(new Control("System Fan #5 / Pump", 0));
                        c.Add(new Control("System Fan #6 / Pump", 1));
                        c.Add(new Control("System Fan #4", 2));
                        break;

                    default:
                        v.Add(new Voltage("Voltage #1", 0, true));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("Voltage #3", 2, true));
                        v.Add(new Voltage("Voltage #4", 3, true));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10, 0, true));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));

                        for (int i = 0; i < superIO.Temperatures.Length; i++)
                            t.Add(new Temperature("Temperature #" + (i + 1), i));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + (i + 1), i));

                        break;
                }

                break;

            default:
                v.Add(new Voltage("Voltage #1", 0, true));
                v.Add(new Voltage("Voltage #2", 1, true));
                v.Add(new Voltage("Voltage #3", 2, true));
                v.Add(new Voltage("Voltage #4", 3, true));
                v.Add(new Voltage("Voltage #5", 4, true));
                v.Add(new Voltage("Voltage #6", 5, true));
                v.Add(new Voltage("Voltage #7", 6, true));
                v.Add(new Voltage("+3V Standby", 7, 10, 10, 0, true));
                v.Add(new Voltage("CMOS Battery", 8, 10, 10));

                for (int i = 0; i < superIO.Temperatures.Length; i++)
                    t.Add(new Temperature("Temperature #" + (i + 1), i));

                for (int i = 0; i < superIO.Fans.Length; i++)
                    f.Add(new Fan("Fan #" + (i + 1), i));

                for (int i = 0; i < superIO.Controls.Length; i++)
                    c.Add(new Control("Fan #" + (i + 1), i));

                break;
        }
    }

    private static void GetFintekConfiguration(ISuperIO superIO, Manufacturer manufacturer, Model model, IList<Voltage> v, IList<Temperature> t, IList<Fan> f, IList<Control> c)
    {
        switch (manufacturer)
        {
            case Manufacturer.EVGA:
                switch (model)
                {
                    case Model.X58_SLI_Classified: // F71882
                        v.Add(new Voltage("VCC3V", 0, 150, 150));
                        v.Add(new Voltage("Vcore", 1, 47, 100));
                        v.Add(new Voltage("DIMM", 2, 47, 100));
                        v.Add(new Voltage("CPU Termination", 3, 24, 100));
                        v.Add(new Voltage("IOH Vcore", 4, 24, 100));
                        v.Add(new Voltage("+5V", 5, 51, 12));
                        v.Add(new Voltage("+12V", 6, 56, 6.8f));
                        v.Add(new Voltage("+3V Standby", 7, 150, 150));
                        v.Add(new Voltage("CMOS Battery", 8, 150, 150));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("VREG", 1));
                        t.Add(new Temperature("System", 2));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("Power Fan", 1));
                        f.Add(new Fan("Chassis Fan", 2));

                        break;

                    case Model.X58_3X_SLI: // F71882
                        v.Add(new Voltage("VCC3V", 0, 150, 150));
                        v.Add(new Voltage("Vcore", 1, 47, 100));
                        v.Add(new Voltage("DIMM", 2, 47, 100));
                        v.Add(new Voltage("CPU Termination", 3, 24, 100));
                        v.Add(new Voltage("IOH Vcore", 4, 24, 100));
                        v.Add(new Voltage("+5V", 5, 51, 12));
                        v.Add(new Voltage("+12V", 6, 56, 6.8f));
                        v.Add(new Voltage("+3V Standby", 7, 150, 150));
                        v.Add(new Voltage("CMOS Battery", 8, 150, 150));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("VREG", 1));
                        t.Add(new Temperature("System", 2));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("Power Fan", 1));
                        f.Add(new Fan("Chassis Fan", 2));
                        f.Add(new Fan("Chipset Fan", 3));
                        c.Add(new Control("CPU Fan", 0));
                        c.Add(new Control("Power Fan", 1));
                        c.Add(new Control("Chassis Fan", 2));
                        c.Add(new Control("Chipset Fan", 3));

                        break;

                    default:
                        v.Add(new Voltage("VCC3V", 0, 150, 150));
                        v.Add(new Voltage("Vcore", 1));
                        v.Add(new Voltage("Voltage #3", 2, true));
                        v.Add(new Voltage("Voltage #4", 3, true));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("VSB3V", 7, 150, 150));
                        v.Add(new Voltage("CMOS Battery", 8, 150, 150));

                        for (int i = 0; i < superIO.Temperatures.Length; i++)
                            t.Add(new Temperature("Temperature #" + (i + 1), i));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        break;
                }

                break;
            case Manufacturer.MSI:
                switch (model)
                {
                    case Model.Z77_MS7751: // F71889AD
                    case Model.Z68_MS7672: // F71889AD
                        v.Add(new Voltage("VCC3V", 0, 150, 150));
                        v.Add(new Voltage("Vcore", 1));
                        v.Add(new Voltage("iGPU", 2));
                        v.Add(new Voltage("+5V", 3, 20, 4.7f));
                        v.Add(new Voltage("+12V", 4, 68, 6.8f));
                        v.Add(new Voltage("DIMM", 5, 150, 150));
                        v.Add(new Voltage("CPU I/O", 6));
                        v.Add(new Voltage("+3.3V", 7, 150, 150));
                        v.Add(new Voltage("CMOS Battery", 8, 150, 150));

                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Probe", 1));
                        t.Add(new Temperature("System", 2));

                        f.Add(new Fan("CPU Fan", 0));
                        for (int i = 1; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("System Fan #" + i, i));

                        c.Add(new Control("CPU Fan", 0));
                        for (int i = 1; i < superIO.Controls.Length; i++)
                            c.Add(new Control("System Fan #" + i, i));

                        break;
                    default:
                        v.Add(new Voltage("VCC3V", 0, 150, 150));
                        v.Add(new Voltage("Vcore", 1));
                        v.Add(new Voltage("Voltage #3", 2, true));
                        v.Add(new Voltage("Voltage #4", 3, true));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));

                        if (superIO.Chip != Chip.F71808E)
                            v.Add(new Voltage("Voltage #7", 6, true));

                        v.Add(new Voltage("VSB3V", 7, 150, 150));
                        v.Add(new Voltage("CMOS Battery", 8, 150, 150));

                        for (int i = 0; i < superIO.Temperatures.Length; i++)
                            t.Add(new Temperature("Temperature #" + (i + 1), i));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan Control #" + (i + 1), i));

                        break;
                }

                break;

            default:
                v.Add(new Voltage("VCC3V", 0, 150, 150));
                v.Add(new Voltage("Vcore", 1));
                v.Add(new Voltage("Voltage #3", 2, true));
                v.Add(new Voltage("Voltage #4", 3, true));
                v.Add(new Voltage("Voltage #5", 4, true));
                v.Add(new Voltage("Voltage #6", 5, true));
                if (superIO.Chip != Chip.F71808E)
                    v.Add(new Voltage("Voltage #7", 6, true));

                v.Add(new Voltage("VSB3V", 7, 150, 150));
                v.Add(new Voltage("CMOS Battery", 8, 150, 150));

                for (int i = 0; i < superIO.Temperatures.Length; i++)
                    t.Add(new Temperature("Temperature #" + (i + 1), i));

                for (int i = 0; i < superIO.Fans.Length; i++)
                    f.Add(new Fan("Fan #" + (i + 1), i));

                for (int i = 0; i < superIO.Controls.Length; i++)
                    c.Add(new Control("Fan #" + (i + 1), i));

                break;
        }
    }

    private static void GetNuvotonConfigurationF(ISuperIO superIO, Manufacturer manufacturer, Model model, IList<Voltage> v, IList<Temperature> t, IList<Fan> f, IList<Control> c)
    {
        switch (manufacturer)
        {
            case Manufacturer.ASUS:
                switch (model)
                {
                    case Model.P8P67: // NCT6776F
                    case Model.P8P67_EVO: // NCT6776F
                    case Model.P8P67_PRO: // NCT6776F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+12V", 1, 11, 1));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+5V", 4, 12, 3));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Auxiliary", 2));
                        t.Add(new Temperature("Motherboard", 3));
                        f.Add(new Fan("Chassis Fan #1", 0));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("Power Fan", 2));
                        f.Add(new Fan("Chassis Fan #2", 3));
                        c.Add(new Control("Chassis Fan #2", 0));
                        c.Add(new Control("CPU Fan", 1));
                        c.Add(new Control("Chassis Fan #1", 2));

                        break;

                    case Model.P8P67_M_PRO: // NCT6776F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+12V", 1, 11, 1));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+5V", 4, 12, 3));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Motherboard", 3));
                        f.Add(new Fan("Chassis Fan #1", 0));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("Chassis Fan #2", 2));
                        f.Add(new Fan("Power Fan", 3));
                        f.Add(new Fan("Auxiliary Fan", 4));

                        break;

                    case Model.P8Z68_V_PRO: // NCT6776F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+12V", 1, 11, 1));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+5V", 4, 12, 3));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Auxiliary", 2));
                        t.Add(new Temperature("Motherboard", 3));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + (i + 1), i));

                        break;

                    case Model.P9X79: // NCT6776F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+12V", 1, 11, 1));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+5V", 4, 12, 3));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Motherboard", 3));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + (i + 1), i));

                        break;

                    default:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        t.Add(new Temperature("CPU Core", 0));
                        t.Add(new Temperature("Temperature #1", 1));
                        t.Add(new Temperature("Temperature #2", 2));
                        t.Add(new Temperature("Temperature #3", 3));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + (i + 1), i));

                        break;
                }

                break;
            case Manufacturer.ASRock:
                switch (model)
                {
                    case Model.H61M_DGS: // NCT6776F
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+12V", 1, 28, 5));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("#Voltage #5", 4, 0, 1, 0, true));
                        v.Add(new Voltage("+5V", 5, 2, 1));
                        v.Add(new Voltage("#Voltage #7", 6, 0, 1, 0, true));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        t.Add(new Temperature("CPU", 1));
                        //t.Add(new Temperature("Auxiliary", 2)); // not in bios, duplicate motherboard temp
                        t.Add(new Temperature("Motherboard", 3));
                        f.Add(new Fan("Chassis Fan", 0));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("Power Fan", 2));
                        c.Add(new Control("Chassis Fan", 0));
                        c.Add(new Control("CPU Fan", 1));
                        //c.Add(new Control("Power Fan", 2)); // not in bios, always 100%

                        break;
                    case Model.B85M_DGS:
                        {
                            v.Add(new Voltage("Vcore", 0, 1, 1));
                            v.Add(new Voltage("+12V", 1, 56, 10));
                            v.Add(new Voltage("AVCC", 2, 34, 34));
                            v.Add(new Voltage("+3.3V", 3, 34, 34));
                            v.Add(new Voltage("VIN1", 4, true));
                            v.Add(new Voltage("+5V", 5, 12, 3));
                            v.Add(new Voltage("VIN3", 6, true));
                            v.Add(new Voltage("+3V Standby", 7, 34, 34));
                            t.Add(new Temperature("CPU", 0));
                            t.Add(new Temperature("Auxiliary", 2));
                            t.Add(new Temperature("Motherboard", 3));
                            f.Add(new Fan("Chassis Fan #1", 0));
                            f.Add(new Fan("CPU Fan", 1));
                            f.Add(new Fan("Power Fan", 2));
                            f.Add(new Fan("Chassis Fan #2", 3));
                            c.Add(new Control("Chassis Fan #2", 0));
                            c.Add(new Control("CPU Fan", 1));
                            c.Add(new Control("Chassis Fan #1", 2));
                        }

                        break;
                    case Model.Z77Pro4M: //NCT6776F
                        v.Add(new Voltage("Vcore", 0, 0, 1));
                        v.Add(new Voltage("+12V", 1, 56, 10));
                        v.Add(new Voltage("AVCC", 2, 10, 10));
                        v.Add(new Voltage("+3.3V", 3, 10, 10));
                        //v.Add(new Voltage("#Unused #4", 4, 0, 1, 0, true));
                        v.Add(new Voltage("+5V", 5, 20, 10));
                        //v.Add(new Voltage("#Unused #6", 6, 0, 1, 0, true));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));
                        t.Add(new Temperature("CPU Core", 0));
                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("Auxiliary", 2));
                        t.Add(new Temperature("Motherboard", 3));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + (i + 1), i));

                        break;

                    default:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        t.Add(new Temperature("CPU Core", 0));
                        t.Add(new Temperature("Temperature #1", 1));
                        t.Add(new Temperature("Temperature #2", 2));
                        t.Add(new Temperature("Temperature #3", 3));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + (i + 1), i));

                        break;
                }

                break;

            default:
                v.Add(new Voltage("Vcore", 0));
                v.Add(new Voltage("Voltage #2", 1, true));
                v.Add(new Voltage("AVCC", 2, 34, 34));
                v.Add(new Voltage("+3.3V", 3, 34, 34));
                v.Add(new Voltage("Voltage #5", 4, true));
                v.Add(new Voltage("Voltage #6", 5, true));
                v.Add(new Voltage("Voltage #7", 6, true));
                v.Add(new Voltage("+3V Standby", 7, 34, 34));
                v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                t.Add(new Temperature("CPU Core", 0));
                t.Add(new Temperature("Temperature #1", 1));
                t.Add(new Temperature("Temperature #2", 2));
                t.Add(new Temperature("Temperature #3", 3));

                for (int i = 0; i < superIO.Fans.Length; i++)
                    f.Add(new Fan("Fan #" + (i + 1), i));

                for (int i = 0; i < superIO.Controls.Length; i++)
                    c.Add(new Control("Fan #" + (i + 1), i));

                break;
        }
    }

    private static void GetNuvotonConfigurationD(ISuperIO superIO, Manufacturer manufacturer, Model model, int index, IList<Voltage> v, IList<Temperature> t, IList<Fan> f, IList<Control> c)
    {
        switch (manufacturer)
        {
            case Manufacturer.ASRock:
                switch (model)
                {
                    case Model.A320M_HDV: //NCT6779D
                        v.Add(new Voltage("Vcore", 0, 10, 10));
                        v.Add(new Voltage("Chipset 1.05V", 1, 0, 1));
                        v.Add(new Voltage("AVCC", 2, 10, 10));
                        v.Add(new Voltage("+3.3V", 3, 10, 10));
                        v.Add(new Voltage("+12V", 4, 56, 10));
                        v.Add(new Voltage("VcoreRef", 5, 0, 1));
                        v.Add(new Voltage("DIMM", 6, 0, 1));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));
                        //v.Add(new Voltage("#Unused #9", 9, 0, 1, 0, true));
                        //v.Add(new Voltage("#Unused #10", 10, 0, 1, 0, true));
                        //v.Add(new Voltage("#Unused #11", 11, 34, 34, 0, true));
                        v.Add(new Voltage("+5V", 12, 20, 10));
                        //v.Add(new Voltage("#Unused #13", 13, 10, 10, 0, true));
                        //v.Add(new Voltage("#Unused #14", 14, 0, 1, 0, true));

                        //t.Add(new Temperature("#Unused #0", 0));
                        //t.Add(new Temperature("#Unused #1", 1));
                        t.Add(new Temperature("Motherboard", 2));
                        //t.Add(new Temperature("#Unused #3", 3));
                        //t.Add(new Temperature("#Unused #4", 4));
                        t.Add(new Temperature("Auxiliary", 5));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + (i + 1), i));

                        break;

                    case Model.AB350_Pro4: //NCT6779D
                    case Model.AB350M_Pro4:
                    case Model.AB350M:
                    case Model.Fatal1ty_AB350_Gaming_K4:
                    case Model.AB350M_HDV:
                    case Model.B450_Steel_Legend:
                    case Model.B450M_Steel_Legend:
                    case Model.B450_Pro4:
                    case Model.B450M_Pro4:
                        v.Add(new Voltage("Vcore", 0, 10, 10));
                        //v.Add(new Voltage("#Unused", 1, 0, 1, 0, true));
                        v.Add(new Voltage("AVCC", 2, 10, 10));
                        v.Add(new Voltage("+3.3V", 3, 10, 10));
                        v.Add(new Voltage("+12V", 4, 28, 5));
                        v.Add(new Voltage("Vcore Refin", 5, 0, 1));
                        //v.Add(new Voltage("#Unused #6", 6, 0, 1, 0, true));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        //v.Add(new Voltage("#Unused #9", 9, 0, 1, 0, true));
                        //v.Add(new Voltage("#Unused #10", 10, 0, 1, 0, true));
                        v.Add(new Voltage("Chipset 1.05V", 11, 0, 1));
                        v.Add(new Voltage("+5V", 12, 20, 10));
                        //v.Add(new Voltage("#Unused #13", 13, 0, 1, 0, true));
                        v.Add(new Voltage("+1.8V", 14, 0, 1));
                        t.Add(new Temperature("CPU Core", 0));
                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("Motherboard", 2));
                        t.Add(new Temperature("Auxiliary", 3));
                        t.Add(new Temperature("VRM", 4));
                        t.Add(new Temperature("Auxiliary Index #2", 5));
                        //t.Add(new Temperature("Temperature #6", 6));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + (i + 1), i));

                        break;

                    case Model.B450M_Pro4_R2_0:
                        v.Add(new Voltage("Vcore", 0, 10, 10));
                        //v.Add(new Voltage("#Unused #1", 1, 0, 1, 0, true));
                        v.Add(new Voltage("AVCC", 2, 10, 10));
                        v.Add(new Voltage("+3.3V", 3, 10, 10));
                        v.Add(new Voltage("+12V", 4, 28, 5));
                        v.Add(new Voltage("Vcore Refin", 5, 0, 1));
                        //v.Add(new Voltage("#Unused #6", 6, 0, 1, 0, true));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        //v.Add(new Voltage("#Unused #9", 9, 0, 1, 0, true));
                        //v.Add(new Voltage("#Unused #10", 10, 0, 1, 0, true));
                        v.Add(new Voltage("Chipset 1.05V", 11, 0, 1));
                        v.Add(new Voltage("+5V", 12, 20, 10));
                        //v.Add(new Voltage("#Unused #13", 13, 0, 1, 0, true));
                        v.Add(new Voltage("+1.8V", 14, 0, 1));
                        //t.Add(new Temperature("Temperature #1", 1));
                        t.Add(new Temperature("Motherboard", 2));
                        //t.Add(new Temperature("Temperature #3", 3));
                        //t.Add(new Temperature("Temperature #4", 4));
                        //t.Add(new Temperature("Temperature #5", 5));
                        f.Add(new Fan("Chassis #1", 0));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("Chassis #2", 2));
                        f.Add(new Fan("CPU Pump", 3));
                        f.Add(new Fan("Chassis #3", 4));
                        c.Add(new Control("Chassis #1", 0));
                        c.Add(new Control("CPU Fan", 1));
                        c.Add(new Control("Chassis #2", 2));
                        c.Add(new Control("CPU Pump", 3));
                        c.Add(new Control("Chassis #3", 4));

                        break;

                    case Model.X399_Phantom_Gaming_6: //NCT6779D
                        v.Add(new Voltage("Vcore", 0, 10, 10));
                        v.Add(new Voltage("Chipset 1.05V", 1, 0, 1));
                        v.Add(new Voltage("AVCC", 2, 10, 10));
                        v.Add(new Voltage("+3.3V", 3, 10, 10));
                        v.Add(new Voltage("+12V", 4, 56, 10));
                        v.Add(new Voltage("VDDCR_SOC", 5, 0, 1));
                        v.Add(new Voltage("DIMM", 6, 0, 1));
                        v.Add(new Voltage("+3V Standby", 7, 10, 10));
                        v.Add(new Voltage("CMOS Battery", 8, 10, 10));
                        //v.Add(new Voltage("#Unused", 9, 0, 1, 0, true));
                        //v.Add(new Voltage("#Unused", 10, 0, 1, 0, true));
                        //v.Add(new Voltage("#Unused", 11, 0, 1, 0, true));
                        v.Add(new Voltage("+5V", 12, 20, 10));
                        v.Add(new Voltage("+1.8V", 13, 10, 10));
                        //v.Add(new Voltage("unused", 14, 34, 34, 0, true));
                        t.Add(new Temperature("CPU Core", 0));
                        t.Add(new Temperature("Motherboard", 1));
                        t.Add(new Temperature("Auxiliary", 2));
                        t.Add(new Temperature("Chipset", 3));
                        t.Add(new Temperature("Core VRM", 4));
                        t.Add(new Temperature("Core SoC", 5));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + (i + 1), i));

                        break;

                    case Model.X570_Taichi:
                        v.Add(new Voltage("Vcore", 0, 10, 10));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9));
                        v.Add(new Voltage("Voltage #11", 10, true));
                        v.Add(new Voltage("Voltage #12", 11, true));
                        v.Add(new Voltage("Voltage #13", 12, true));
                        v.Add(new Voltage("Voltage #14", 13, true));
                        v.Add(new Voltage("Voltage #15", 14, true));

                        t.Add(new Temperature("Motherboard", 2));
                        t.Add(new Temperature("CPU", 8));
                        t.Add(new Temperature("Southbridge", 9));

                        f.Add(new Fan("Chassis #3", 0));
                        f.Add(new Fan("CPU #1", 1));
                        f.Add(new Fan("CPU #2", 2));
                        f.Add(new Fan("Chassis #1", 3));
                        f.Add(new Fan("Chassis #2", 4));
                        f.Add(new Fan("Southbridge Fan", 5));
                        f.Add(new Fan("Chassis #4", 6));

                        c.Add(new Control("Chassis #3", 0));
                        c.Add(new Control("CPU #1", 1));
                        c.Add(new Control("CPU #2", 2));
                        c.Add(new Control("Chassis #1", 3));
                        c.Add(new Control("Chassis #2", 4));
                        c.Add(new Control("Southbridge Fan", 5));
                        c.Add(new Control("Chassis #4", 6));

                        break;

                    case Model.X570_Phantom_Gaming_ITX:
                        v.Add(new Voltage("+12V", 0));
                        v.Add(new Voltage("+5V", 1));
                        v.Add(new Voltage("Vcore", 2));
                        v.Add(new Voltage("Voltage #1", 3));
                        v.Add(new Voltage("DIMM", 4));
                        v.Add(new Voltage("CPU I/O", 5));
                        v.Add(new Voltage("CPU System Agent", 6));
                        v.Add(new Voltage("Voltage #2", 7));
                        v.Add(new Voltage("AVCC3", 8));
                        v.Add(new Voltage("CPU Termination", 9));
                        v.Add(new Voltage("VRef", 10));
                        v.Add(new Voltage("VSB", 11));
                        v.Add(new Voltage("AVSB", 12));
                        v.Add(new Voltage("CMOS Battery", 13));

                        t.Add(new Temperature("Motherboard", 0));
                        //t.Add(new Temperature("System", 1)); //Unused
                        t.Add(new Temperature("CPU", 2));
                        t.Add(new Temperature("Southbridge", 3));
                        f.Add(new Fan("CPU Fan #1", 0)); //CPU_FAN1
                        f.Add(new Fan("Chassis Fan #1", 1)); //CHA_FAN1/WP
                        f.Add(new Fan("CPU Fan #2", 2)); //CPU_FAN2 (WP)
                        f.Add(new Fan("Chipset Fan", 3));

                        c.Add(new Control("CPU Fan #1", 0));
                        c.Add(new Control("Chassis Fan", 1));
                        c.Add(new Control("CPU Fan #2", 2));
                        c.Add(new Control("Chipset Fan", 3));
                        break;

                    case Model.Z690_Extreme:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+5V", 1, 20, 10));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 110, 10));
                        v.Add(new Voltage("CPU Input Auxiliary", 5, 1, 1));
                        v.Add(new Voltage("DIMM", 6));
                        v.Add(new Voltage("+3.3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9, 1, 1));
                        v.Add(new Voltage("CPU 1.05V", 10, 1, 1));
                        v.Add(new Voltage("Chipset 0.82V", 11, 1, 1));
                        v.Add(new Voltage("Chipset 1.0V", 12));
                        v.Add(new Voltage("CPU System Agent", 13, 1, 1));
                        v.Add(new Voltage("+5V Standby", 14, 2.35f, 1));

                        f.Add(new Fan("CPU Fan #1", 1));
                        f.Add(new Fan("CPU Fan #2", 2));
                        f.Add(new Fan("Chassis Fan #1", 3));
                        f.Add(new Fan("Chassis Fan #2", 4));
                        f.Add(new Fan("Chassis Fan #3", 0));
                        f.Add(new Fan("Chassis Fan #4", 5));
                        f.Add(new Fan("Chassis Fan #5", 6));

                        c.Add(new Control("CPU Fan #1", 1)); // CPU_FAN1
                        c.Add(new Control("CPU Fan #2", 2)); // CPU_FAN2/WP
                        c.Add(new Control("Chassis Fan #1", 3)); // CHA_FAN1/WP
                        c.Add(new Control("Chassis Fan #2", 4)); // CHA_FAN2/WP
                        c.Add(new Control("Chassis Fan #3", 0)); // CHA_FAN3/WP
                        c.Add(new Control("Chassis Fan #4", 5)); // CHA_FAN4/WP
                        c.Add(new Control("Chassis Fan #5", 6)); // CHA_FAN5/WP

                        t.Add(new Temperature("CPU Core", 0));
                        t.Add(new Temperature("Motherboard", 2));
                        break;

                    case Model.Z690_Steel_Legend:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+5V", 1, 20, 10));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 110, 10));
                        v.Add(new Voltage("CPU Input Auxiliary", 5, 1, 1));
                        v.Add(new Voltage("DRAM", 6));
                        v.Add(new Voltage("+3.3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9, 1, 1));
                        v.Add(new Voltage("CPU 1.05V", 10, 1, 1));
                        v.Add(new Voltage("Chipset 0.82V", 11, 1, 1));
                        v.Add(new Voltage("Chipset 1.0V", 12));
                        v.Add(new Voltage("CPU System Agent", 13, 1, 1));
                        v.Add(new Voltage("+5V Standby", 14, 2.35f, 1));

                        f.Add(new Fan("CPU Fan #1", 1));
                        f.Add(new Fan("CPU Fan #2", 2));
                        f.Add(new Fan("Chassis Fan #1", 3));
                        f.Add(new Fan("Chassis Fan #2", 4));
                        f.Add(new Fan("Chassis Fan #3", 0));
                        f.Add(new Fan("Chassis Fan #4", 5));
                        f.Add(new Fan("Chassis Fan #5", 6));

                        c.Add(new Control("CPU Fan #1", 1)); // CPU_FAN1
                        c.Add(new Control("CPU Fan #2", 2)); // CPU_FAN2/WP
                        c.Add(new Control("Chassis Fan #1", 3)); // CHA_FAN1/WP
                        c.Add(new Control("Chassis Fan #2", 4)); // CHA_FAN2/WP
                        c.Add(new Control("Chassis Fan #3", 0)); // CHA_FAN3/WP
                        c.Add(new Control("Chassis Fan #4", 5)); // CHA_FAN4/WP
                        c.Add(new Control("Chassis Fan #5", 6)); // CHA_FAN5/WP

                        t.Add(new Temperature("CPU Core", 0));
                        t.Add(new Temperature("VRM", 1));
                        t.Add(new Temperature("Motherboard", 2));
                        break;

                    case Model.Z790_Pro_RS:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+5V", 1, 20, 10));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 110, 10));
                        v.Add(new Voltage("CPU Input Auxiliary", 5, 1, 1));
                        v.Add(new Voltage("Integrated Memory Controller", 6));
                        v.Add(new Voltage("+3.3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9, 1, 1));
                        v.Add(new Voltage("CPU 1.05V", 10, 1, 1));
                        v.Add(new Voltage("Chipset 0.82V", 11, 1, 1));
                        v.Add(new Voltage("Chipset 1.0V", 12));
                        v.Add(new Voltage("CPU System Agent", 13, 1, 1));
                        v.Add(new Voltage("+5V Standby", 14, 2.35f, 1));

                        f.Add(new Fan("CPU Fan #1", 1));
                        f.Add(new Fan("CPU Fan #2", 2));
                        f.Add(new Fan("Chassis Fan #1", 3));
                        f.Add(new Fan("Chassis Fan #2", 4));
                        f.Add(new Fan("Chassis Fan #3", 0));
                        f.Add(new Fan("Chassis Fan #4", 5));
                        f.Add(new Fan("Chassis Fan #5", 6));

                        c.Add(new Control("CPU Fan #1", 1)); // CPU_FAN1
                        c.Add(new Control("CPU Fan #2", 2)); // CPU_FAN2/WP
                        c.Add(new Control("Chassis Fan #1", 3)); // CHA_FAN1/WP
                        c.Add(new Control("Chassis Fan #2", 4)); // CHA_FAN2/WP
                        c.Add(new Control("Chassis Fan #3", 0)); // CHA_FAN3/WP
                        c.Add(new Control("Chassis Fan #4", 5)); // CHA_FAN4/WP
                        c.Add(new Control("Chassis Fan #5", 6)); // CHA_FAN5/WP

                        t.Add(new Temperature("CPU Core", 0));
                        t.Add(new Temperature("Motherboard", 2));
                        break;

                    case Model.X570_Phantom_Gaming_4: // NCT6796D (-R?)
                        // internal on NCT6796D have a 1/2 voltage divider (by way of two 34kOhm resistors)
                        // "Six internal signals connected to the power supplies (CPUVCORE, AVSB, VBAT, VTT, 3VSB, 3VCC)"
                        // "All the internal inputs of the ADC, AVSB, VBAT, 3VSB, 3VCC utilize an integrated voltage divider
                        //  with both resistors equal to 34kOhm"
                        // it seems that VTT doesn't actually have the 1/2 divider

                        // external sources can have whatever divider that gets them in the 0V to 2.048V range

                        // assuming Vf = 0, then Ri = R1 and Rf = R2 (from voltage divider equation)

                        v.Add(new Voltage("Vcore", 0, 1, 1));
                        v.Add(new Voltage("+5V", 1, 2, 1));
                        v.Add(new Voltage("AVCC", 2, 1, 1));
                        v.Add(new Voltage("+3.3V", 3, 1, 1));
                        v.Add(new Voltage("+12V", 4, 56, 10));
                        v.Add(new Voltage("CPU SoC", 5));
                        v.Add(new Voltage("DIMM", 6));
                        v.Add(new Voltage("+3V Standby", 7, 1, 1));
                        v.Add(new Voltage("CMOS Battery", 8, 1, 1));
                        v.Add(new Voltage("DIMM Termination", 9));
                        //v.Add(new Voltage("Voltage #11", 10, true)); // unknown. VIN5 pin
                        v.Add(new Voltage("VPPM", 11, 3, 1));
                        v.Add(new Voltage("PREM CPU SoC", 12));
                        v.Add(new Voltage("DIMM Write", 13));
                        v.Add(new Voltage("+1.8V", 14, 1, 1));
                        //v.Add(new Voltage("Voltage #16", 15, true)); // unknown. VIN9 pin

                        t.Add(new Temperature("CPU", 8)); // AKA SMBUSMASTER0
                        t.Add(new Temperature("Chipset", 9)); // AKA SMBUSMASTER1
                        t.Add(new Temperature("Motherboard", 2)); // AKA SYSTIN

                        // no idea what these sources are actually connected to.
                        //t.Add(new Temperature("CPUTIN", 1));
                        //t.Add(new Temperature("Auxiliary Index #0", 3));
                        //t.Add(new Temperature("Auxiliary Index #1", 4));
                        //t.Add(new Temperature("Auxiliary Index #2", 5));
                        //t.Add(new Temperature("Auxiliary Index #3", 6));
                        //t.Add(new Temperature("Auxiliary Index #4", 7));
                        //t.Add(new Temperature("TSENSOR", 8));
                        //t.Add(new Temperature("VIRTUAL_TEMP", 24));

                        // CHA_FAN3 header
                        f.Add(new Fan("Chassis Fan #3", 0));
                        c.Add(new Control("Chassis Fan #3", 0));

                        // CPU_FAN1 header
                        f.Add(new Fan("CPU Fan #1", 1));
                        c.Add(new Control("CPU Fan #1", 1));

                        // CPU_FAN2/WP header
                        f.Add(new Fan("CPU Fan #2", 2));
                        c.Add(new Control("CPU Fan #2", 2));

                        // CHA_FAN1/WP header
                        f.Add(new Fan("Chassis Fan #1", 3));
                        c.Add(new Control("Chassis Fan #1", 3));

                        // CHA_FAN2/WP header
                        f.Add(new Fan("Chassis Fan #2", 4));
                        c.Add(new Control("Chassis Fan #2", 4));

                        // SB_FAN1 header
                        f.Add(new Fan("Chipset Fan", 5));
                        c.Add(new Control("Chipset Fan", 5));

                        // fan/control 6 is not exposed to a header
                        //f.Add(new Fan("Fan #7", 6));
                        //c.Add(new Control("Fan #7", 6));

                        break;

                    case Model.Z790_Taichi:
                        v.Add(new Voltage("+1.8V", 0));
                        v.Add(new Voltage("Chipset 0.82V", 1));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("CPU 1.05V", 4));
                        v.Add(new Voltage("Chipset 1.05V", 12, 5, 100));

                        f.Add(new Fan("Chassis Fan #5", 0));
                        f.Add(new Fan("Chassis Fan #6", 1));
                        f.Add(new Fan("Chassis Fan #3", 6));

                        c.Add(new Control("Chassis Fan #5", 0));
                        c.Add(new Control("Chassis Fan #6", 1));
                        c.Add(new Control("Chassis Fan #3", 6));
                        break;

                    case Model.Z790_Nova_WiFi:
                        if (index != 0)
                        {
                            // second SIO
                            v.Add(new Voltage("1.05V CPU", 0));
                            v.Add(new Voltage("CPU I/O", 1));
                            v.Add(new Voltage("0.82V Chipset", 4));
                            v.Add(new Voltage("1.05V Chipset", 12, 5, 100));

                            f.Add(new Fan("VRM", 0));
                            f.Add(new Fan("MOS", 1));

                            c.Add(new Control("VRM", 0));
                            c.Add(new Control("MOS", 1));
                        }
                        else
                        {
                            v.Add(new Voltage("Vcore", 0));
                            v.Add(new Voltage("+5V", 1, 20, 10));
                            v.Add(new Voltage("+3.3V", 3, 34, 34));
                            v.Add(new Voltage("+12V", 4, 110, 10));
                            v.Add(new Voltage("CPU Input Auxiliary", 5, 1, 1));
                            v.Add(new Voltage("CPU System Agent", 13, 1, 1));
                            v.Add(new Voltage("+5V Standby", 14, 235, 100));

                            f.Add(new Fan("Chassis #3", 0));
                            f.Add(new Fan("CPU #1", 1));
                            f.Add(new Fan("CPU #2", 2));
                            f.Add(new Fan("Chassis #1", 3));
                            f.Add(new Fan("Chassis #2", 4));
                            f.Add(new Fan("Chassis #4", 5));
                            f.Add(new Fan("Chassis #5", 6));

                            c.Add(new Control("Chassis #3", 0));
                            c.Add(new Control("CPU #1", 1));
                            c.Add(new Control("CPU #2", 2));
                            c.Add(new Control("Chassis #1", 3));
                            c.Add(new Control("Chassis #2", 4));
                            c.Add(new Control("Chassis #4", 5));
                            c.Add(new Control("Chassis #5", 6));

                            t.Add(new Temperature("CPU Core", 0));
                            t.Add(new Temperature("Motherboard", 2));
                            t.Add(new Temperature("External #1", 3));
                            t.Add(new Temperature("External #2", 4));
                            t.Add(new Temperature("External #3", 5));
                        }

                        break;

                    case Model.B650M_C: // NCT6799D
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+12V", 1, 56, 10));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+5V", 4, 20, 10));
                        v.Add(new Voltage("+1.05V ALW", 5));
                        v.Add(new Voltage("+3.3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9, 1, 1));
                        v.Add(new Voltage("Vcore SoC", 10, 1, 1));
                        v.Add(new Voltage("Vcore Misc", 11, 1, 1));
                        v.Add(new Voltage("+1.8V", 13, 1, 1));
                        v.Add(new Voltage("DIMM", 14));

                        t.Add(new Temperature("CPU Core", 9));
                        t.Add(new Temperature("Motherboard", 2));

                        f.Add(new Fan("CPU Fan #1", 1)); // CPU_FAN1
                        f.Add(new Fan("CPU Fan #2", 0)); // CPU_FAN2/WP
                        f.Add(new Fan("Chassis Fan #1", 3)); // CHA_FAN1/WP
                        f.Add(new Fan("Chassis Fan #2", 4)); // CHA_FAN2/WP
                        f.Add(new Fan("Chassis Fan #3", 6)); // CHA_FAN3/WP

                        c.Add(new Control("CPU Fan #1", 1)); // CPU_FAN1
                        c.Add(new Control("CPU Fan #2", 0)); // CPU_FAN2/WP
                        c.Add(new Control("Chassis Fan #1", 3)); // CHA_FAN1/WP
                        c.Add(new Control("Chassis Fan #2", 4)); // CHA_FAN2/WP
                        c.Add(new Control("Chassis Fan #3", 6)); // CHA_FAN3/WP
                        break;

                    case Model.B850M_STEEL_LEGEND_WIFI: // NCT6799D
                        v.Add(new Voltage("Vcore", 0, 10, 10));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9));

                        t.Add(new Temperature("CPU Core", 0));
                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("Motherboard", 2));
                        t.Add(new Temperature("PCH TS10", 9));
                        t.Add(new Temperature("Thermistor Sensor", 24));

                        f.Add(new Fan("CPU Fan #1", 1)); // CPU_FAN1
                        f.Add(new Fan("CPU Fan #2 / Pump", 0)); // CPU_FAN2/PUMP
                        f.Add(new Fan("Chassis Fan #1", 3)); // CHA_FAN1
                        f.Add(new Fan("Chassis Fan #2", 4)); // CHA_FAN2
                        f.Add(new Fan("Chassis Fan #3", 6)); // CHA_FAN3

                        c.Add(new Control("CPU Fan #1", 1)); // CPU_FAN1
                        c.Add(new Control("CPU Fan #2 / Pump", 0)); // CPU_FAN2/PUMP
                        c.Add(new Control("Chassis Fan #1", 3)); // CHA_FAN1
                        c.Add(new Control("Chassis Fan #2", 4)); // CHA_FAN2
                        c.Add(new Control("Chassis Fan #3", 6)); // CHA_FAN3
                        break;

                    case Model.X870E_TAICHI: // NCT6799D
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+12V", 1, 56, 10));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+5V", 4, 20, 10));
                        v.Add(new Voltage("+1.05V Always-on", 5));
                        v.Add(new Voltage("+3.3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("Vcore SoC", 10, 1, 1));
                        v.Add(new Voltage("Vcore Misc", 11, 1, 1));
                        v.Add(new Voltage("+1.8V", 13, 1, 1));

                        t.Add(new Temperature("Motherboard", 2));

                        t.Add(new Temperature("Thermistor Sensor #1", 5)); // Thermistor Sensor 1
                        t.Add(new Temperature("Thermistor Sensor #2", 6)); // Thermistor Sensor 2
                        t.Add(new Temperature("Thermistor Sensor #3", 8)); // Thermistor Sensor 3

                        f.Add(new Fan("CPU Fan #1", 1)); // CPU_FAN1
                        f.Add(new Fan("CPU Fan #2", 2)); // CPU_FAN2
                        f.Add(new Fan("AIO Pump", 3)); // AIO_PUMP
                        f.Add(new Fan("Chassis Fan #1", 0)); // CHA_FAN1
                        f.Add(new Fan("Chassis Fan #2", 4)); // CHA_FAN2

                        c.Add(new Control("CPU Fan #1", 1)); // CPU_FAN1
                        c.Add(new Control("CPU Fan #2", 2)); // CPU_FAN2
                        c.Add(new Control("AIO Pump", 3)); // AIO_PUMP
                        c.Add(new Control("Chassis Fan #1", 0)); // CHA_FAN1
                        c.Add(new Control("Chassis Fan #2", 4)); // CHA_FAN2
                        break;

                    case Model.X870E_NOVA_WIFI: //NCT6796D-S
                        // Voltages: (VHIF and VIN10 are monitored in HWiNFO but not identified here yet)
                        v.Add(new Voltage("Vcore", 0)); // CPU Core Voltage
                        v.Add(new Voltage("+12V", 1, 56, 10));  // +12V
                        v.Add(new Voltage("Analog VCC", 2, 34, 34)); // AVCC
                        v.Add(new Voltage("+3.3V", 3, 34, 34)); // +3.3V
                        v.Add(new Voltage("+5V", 4, 20, 10)); // +5V
                        v.Add(new Voltage("+1.05 Standby", 5, 0, 1)); // +1.05V_ALW
                        v.Add(new Voltage("Voltage #4", 6, 0, 1)); // VIN4
                        v.Add(new Voltage("+3V Standby", 7, 34, 34)); // +3VSB
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34)); // VBAT
                        v.Add(new Voltage("CPU Termination", 9, 1, 1)); // VTT
                        v.Add(new Voltage("SoC", 10, 1, 1)); // VDDCR_SOC
                        v.Add(new Voltage("Voltage #6", 11, 34, 34, 0)); // VIN6
                        v.Add(new Voltage("Voltage #2", 12)); // VIN2
                        v.Add(new Voltage("+1.8V", 13, 10, 10, 0)); // +1.8V
                        v.Add(new Voltage("Voltage #7", 14, 0, 1, 0)); // VIN7
                        v.Add(new Voltage("Voltage #9", 15)); // VIN9

                        // Temperatures
                        t.Add(new Temperature("CPU Socket", 0)); // CPUTIN
                        t.Add(new Temperature("Motherboard", 1)); // SYSTIN
                        t.Add(new Temperature("Auxiliary #0", 2)); // AUXTIN0
                        t.Add(new Temperature("Auxiliary #1", 3)); // AUXTIN1
                        t.Add(new Temperature("Thermistor Sensor #1", 4)); // AUXTIN2 (Thermistor Sensor1)
                        t.Add(new Temperature("Thermistor Sensor #2", 5)); // AUXTIN3 (Thermistor Sensor2)
                        t.Add(new Temperature("Auxiliary #4", 6)); // AUXTIN4
                        t.Add(new Temperature("Thermistor Sensor #3", 7)); // AUXTIN5 (Thermistor Sensor3)
                        t.Add(new Temperature("CPU Core", 8)); // SMBUSMASTER0 (CPU Core)
                        t.Add(new Temperature("CPU (PECI)", 9)); // CPU (PECI)
                        t.Add(new Temperature("Virtual", 10)); // VIRTUAL_TEMP

                        // Fans
                        f.Add(new Fan("Chassis Fan #1", 0)); // CHA_FAN1
                        f.Add(new Fan("CPU Fan #1", 1)); // CPU_FAN1
                        f.Add(new Fan("CPU Fan #2", 2)); // CPU_FAN2
                        f.Add(new Fan("AIO Pump", 3)); // AIO_PUMP
                        f.Add(new Fan("Water Pump", 4)); // W_PUMP
                        f.Add(new Fan("Chassis Fan #2", 5)); // CHA_FAN2
                        f.Add(new Fan("Chassis Fan #3", 6)); // CHA_FAN3

                        // Controls
                        c.Add(new Control("Chassis Fan #1", 0)); // CHA_FAN1
                        c.Add(new Control("CPU Fan #1", 1)); // CPU_FAN1
                        c.Add(new Control("CPU Fan #2", 2)); // CPU_FAN2
                        c.Add(new Control("AIO Pump", 3)); // AIO_PUMP
                        c.Add(new Control("Water Pump", 4)); // W_PUMP
                        c.Add(new Control("Chassis Fan #2", 5)); // CHA_FAN2
                        c.Add(new Control("Chassis Fan #3", 6)); // CHA_FAN3
                        break;

                    default:
                        v.Add(new Voltage("Vcore", 0, 10, 10));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9));
                        v.Add(new Voltage("Voltage #11", 10, true));
                        v.Add(new Voltage("Voltage #12", 11, true));
                        v.Add(new Voltage("Voltage #13", 12, true));
                        v.Add(new Voltage("Voltage #14", 13, true));
                        v.Add(new Voltage("Voltage #15", 14, true));
                        t.Add(new Temperature("CPU Core", 0));
                        t.Add(new Temperature("Temperature #1", 1));
                        t.Add(new Temperature("Temperature #2", 2));
                        t.Add(new Temperature("Temperature #3", 3));
                        t.Add(new Temperature("Temperature #4", 4));
                        t.Add(new Temperature("Temperature #5", 5));
                        t.Add(new Temperature("Temperature #6", 6));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + (i + 1), i));

                        break;
                }

                break;
            case Manufacturer.ASUS:
                string[] fanControlNames;
                switch (model)
                {
                    case Model.P8Z77_V: // NCT6779D
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9));
                        v.Add(new Voltage("Voltage #11", 10, true));
                        v.Add(new Voltage("Voltage #12", 11, true));
                        v.Add(new Voltage("Voltage #13", 12, true));
                        v.Add(new Voltage("Voltage #14", 13, true));
                        v.Add(new Voltage("Voltage #15", 14, true));
                        t.Add(new Temperature("CPU Core", 0));
                        t.Add(new Temperature("Auxiliary", 1));
                        t.Add(new Temperature("Motherboard", 2));
                        f.Add(new Fan("Chassis Fan #1", 0));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("Chassis Fan #2", 2));
                        f.Add(new Fan("Chassis Fan #3", 3));
                        c.Add(new Control("Chassis Fan #1", 0));
                        c.Add(new Control("CPU Fan", 1));
                        c.Add(new Control("Chassis Fan #2", 2));
                        c.Add(new Control("Chassis Fan #3", 3));

                        break;

                    case Model.ROG_MAXIMUS_X_APEX: // NCT6793D
                        v.Add(new Voltage("Vcore", 0, 2, 2));
                        v.Add(new Voltage("+5V", 1, 4, 1));
                        v.Add(new Voltage("AVSB", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("CPU Graphics", 6, 2, 2));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9));
                        v.Add(new Voltage("DIMM", 10, 1, 1));
                        v.Add(new Voltage("CPU System Agent", 11));
                        v.Add(new Voltage("PCH Core", 12));
                        v.Add(new Voltage("Phase Locked Loop", 13));
                        v.Add(new Voltage("CPU VCCIO/IMC", 14));
                        t.Add(new Temperature("CPU (PECI)", 0));
                        t.Add(new Temperature("T2", 1));
                        t.Add(new Temperature("T1", 2));
                        t.Add(new Temperature("CPU", 3));
                        t.Add(new Temperature("PCH", 4));
                        t.Add(new Temperature("Temperature #4", 5));
                        t.Add(new Temperature("Temperature #5", 6));
                        f.Add(new Fan("Chassis Fan #1", 0));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("Chassis Fan #2", 2));
                        f.Add(new Fan("Chassis Fan #3", 3));
                        f.Add(new Fan("AIO Pump", 4));
                        c.Add(new Control("Chassis Fan #1", 0));
                        c.Add(new Control("CPU Fan", 1));
                        c.Add(new Control("Chassis Fan #2", 2));
                        c.Add(new Control("Chassis Fan #3", 3));
                        c.Add(new Control("AIO Pump", 4));

                        break;

                    case Model.Z170_A: //NCT6793D
                        v.Add(new Voltage("Vcore", 0, 2, 2));
                        v.Add(new Voltage("+5V", 1, 4, 1));
                        v.Add(new Voltage("AVSB", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1));
                        v.Add(new Voltage("Voltage #6", 5, 0, 1, 0, true));
                        v.Add(new Voltage("CPU Graphics", 6, 2, 2));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9));
                        v.Add(new Voltage("DIMM", 10, 1, 1));
                        v.Add(new Voltage("CPU System Agent", 11));
                        v.Add(new Voltage("PCH Core", 12));
                        v.Add(new Voltage("Phase Locked Loop", 13));
                        v.Add(new Voltage("CPU VCCIO/IMC", 14));
                        t.Add(new Temperature("CPU (PECI)", 0));
                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("Motherboard", 2));
                        t.Add(new Temperature("CPU", 3));
                        t.Add(new Temperature("PCH", 4));
                        t.Add(new Temperature("Temperature #4", 5));
                        t.Add(new Temperature("Temperature #5", 6));

                        // CPU Fan Optional uses the same fancontrol as CPU Fan.
                        // Water Pump speed can only be read from the EC.
                        string[] fanNames = ["Chassis Fan 1", "CPU Fan", "Chassis Fan 2", "Chassis Fan 3", "Chassis Fan 4", "CPU Fan Optional"];
                        fanControlNames = ["Chassis Fan 1", "CPU Fan", "Chassis Fan 2", "Chassis Fan 3", "Chassis Fan 4", "Water Pump"];

                        for (int i = 0; i < fanNames.Length; i++)
                            f.Add(new Fan(fanNames[i], i));

                        for (int i = 0; i < fanControlNames.Length; i++)
                            c.Add(new Control(fanControlNames[i], i));

                        break;

                    case Model.B150M_C: //NCT6791D
                    case Model.B150M_C_D3: //NCT6791D
                        v.Add(new Voltage("Vcore", 0, 2, 2));
                        v.Add(new Voltage("+5V", 1, 4, 1));
                        v.Add(new Voltage("AVSB", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1));
                        //v.Add(new Voltage("Voltage #6", 5, 0, 1, 0, true));
                        //v.Add(new Voltage("CPU Graphics", 6, 2, 2));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("PCH", 9));
                        //v.Add(new Voltage("DIMM", 10, 1, 1));
                        //v.Add(new Voltage("CPU System Agent", 11));
                        //v.Add(new Voltage("PCH Core", 12));
                        //v.Add(new Voltage("Phase Locked Loop", 13));
                        //v.Add(new Voltage("CPU VCCIO/IMC", 14));

                        t.Add(new Temperature("CPU (PECI)", 0));
                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("Motherboard", 2));

                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("Chassis Fan #1", 0));
                        f.Add(new Fan("Chassis Fan #2", 2));

                        c.Add(new Control("CPU Fan", 1));
                        c.Add(new Control("System Fan #1", 0));
                        c.Add(new Control("System Fan #2", 2));

                        break;

                    case Model.TUF_GAMING_X570_PLUS_WIFI: //NCT6798D
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+5V", 1, 4, 1));
                        v.Add(new Voltage("AVSB", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9));

                        t.Add(new Temperature("CPU", 22));
                        t.Add(new Temperature("Motherboard", 2));
                        t.Add(new Temperature("Chipset", 10));

                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("CPU Optional Fan", 6));
                        f.Add(new Fan("Chassis Fan #1", 0));
                        f.Add(new Fan("Chassis Fan #2", 2));
                        f.Add(new Fan("Chassis Fan #3", 3));
                        f.Add(new Fan("Chipset Fan", 4));
                        f.Add(new Fan("AIO Pump", 5));

                        c.Add(new Control("CPU Fan", 1));
                        c.Add(new Control("CPU Optional Fan", 6));
                        c.Add(new Control("Chassis Fan #1", 0));
                        c.Add(new Control("Chassis Fan #2", 2));
                        c.Add(new Control("Chassis Fan #3", 3));
                        c.Add(new Control("Chipset Fan", 4));
                        c.Add(new Control("AIO Pump", 5));

                        break;
                    case Model.TUF_GAMING_B550M_PLUS_WIFI: //NCT6798D
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9));
                        v.Add(new Voltage("Voltage #11", 10, true));
                        v.Add(new Voltage("Voltage #12", 11, true));
                        v.Add(new Voltage("Voltage #13", 12, true));
                        v.Add(new Voltage("Voltage #14", 13, true));
                        v.Add(new Voltage("Voltage #15", 14, true));
                        t.Add(new Temperature("PECI 0", 0));
                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("System", 2));
                        t.Add(new Temperature("AUX 0", 3));
                        t.Add(new Temperature("AUX 1", 4));
                        t.Add(new Temperature("AUX 2", 5));
                        t.Add(new Temperature("AUX 3", 6));
                        t.Add(new Temperature("AUX 4", 7));
                        t.Add(new Temperature("SMBus 0", 8));
                        t.Add(new Temperature("SMBus 1", 9));
                        t.Add(new Temperature("PECI 1", 10));
                        t.Add(new Temperature("PCH Chip CPU Max", 11));
                        t.Add(new Temperature("PCH Chip", 12));
                        t.Add(new Temperature("PCH CPU", 13));
                        t.Add(new Temperature("PCH MCH", 14));
                        t.Add(new Temperature("Agent 0 DIMM 0", 15));
                        t.Add(new Temperature("Agent 0 DIMM 1", 16));
                        t.Add(new Temperature("Agent 1 DIMM 0", 17));
                        t.Add(new Temperature("Agent 1 DIMM 1", 18));
                        t.Add(new Temperature("Device 0", 19));
                        t.Add(new Temperature("Device 1", 20));
                        t.Add(new Temperature("PECI 0 Calibrated", 21));
                        t.Add(new Temperature("PECI 1 Calibrated", 22));
                        t.Add(new Temperature("Virtual", 23));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + (i + 1), i));

                        break;

                    case Model.TUF_GAMING_B760M_PLUS_WIFI_D4: //NCT6798D
                        v.Add(new Voltage("Vcore", 0, 15, 136));
                        v.Add(new Voltage("+5V", 1, 4, 1));
                        v.Add(new Voltage("AVSB", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("VTT", 9, 1, 1));
                        v.Add(new Voltage("DRAM", 10, 1, 1));
                        v.Add(new Voltage("Voltage #12", 11, true));
                        v.Add(new Voltage("Voltage #13", 12, true));
                        v.Add(new Voltage("Voltage #14", 13, true));
                        v.Add(new Voltage("Voltage #15", 14, true));
                        v.Add(new Voltage("Voltage #16", 15, true));
                        v.Add(new Voltage("Voltage #17", 16, true));
                        t.Add(new Temperature("CPU Package", 0));
                        t.Add(new Temperature("Temperature #2", 1));
                        t.Add(new Temperature("Motherboard", 2));
                        t.Add(new Temperature("Temperature #4", 3));
                        t.Add(new Temperature("CPU", 23));

                        fanControlNames = ["Chassis Fan 1", "CPU Fan", "CPU Optional Fan", "Chassis Fan 2", "Chassis Fan 3", "AIO Pump"];
                        System.Diagnostics.Debug.Assert(fanControlNames.Length == superIO.Fans.Length,
                                                        $"Expected {fanControlNames.Length} fan register in the SuperIO chip");

                        System.Diagnostics.Debug.Assert(superIO.Fans.Length == superIO.Controls.Length,
                                                        "Expected counts of cans controls and fan speed registers to be equal");

                        for (int i = 0; i < fanControlNames.Length; i++)
                            f.Add(new Fan(fanControlNames[i], i));

                        for (int i = 0; i < fanControlNames.Length; i++)
                            c.Add(new Control(fanControlNames[i], i));

                        break;

                    case Model.ROG_CROSSHAIR_VIII_HERO: // NCT6798D
                    case Model.ROG_CROSSHAIR_VIII_HERO_WIFI: // NCT6798D
                    case Model.ROG_CROSSHAIR_VIII_DARK_HERO: // NCT6798D
                    case Model.ROG_CROSSHAIR_VIII_FORMULA: // NCT6798D
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("CPU SoC", 6));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9));
                        v.Add(new Voltage("Voltage #11", 10, true));
                        v.Add(new Voltage("Voltage #12", 11, true));
                        v.Add(new Voltage("Voltage #13", 12, true));
                        v.Add(new Voltage("DIMM", 13));
                        v.Add(new Voltage("Voltage #15", 14, true));
                        t.Add(new Temperature("PECI 0", 0));
                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("Motherboard", 2));
                        t.Add(new Temperature("AUX 0", 3));
                        t.Add(new Temperature("AUX 1", 4));
                        t.Add(new Temperature("AUX 2", 5));
                        t.Add(new Temperature("AUX 3", 6));
                        t.Add(new Temperature("AUX 4", 7));
                        t.Add(new Temperature("SMBus 0", 8));
                        t.Add(new Temperature("SMBus 1", 9));
                        t.Add(new Temperature("PECI 1", 10));
                        t.Add(new Temperature("PCH Chip CPU Max", 11));
                        t.Add(new Temperature("PCH Chip", 12));
                        t.Add(new Temperature("PCH CPU", 13));
                        t.Add(new Temperature("PCH MCH", 14));
                        t.Add(new Temperature("Agent 0 DIMM 0", 15));
                        t.Add(new Temperature("Agent 0 DIMM 1", 16));
                        t.Add(new Temperature("Agent 1 DIMM 0", 17));
                        t.Add(new Temperature("Agent 1 DIMM 1", 18));
                        t.Add(new Temperature("Device 0", 19));
                        t.Add(new Temperature("Device 1", 20));
                        t.Add(new Temperature("PECI 0 Calibrated", 21));
                        t.Add(new Temperature("PECI 1 Calibrated", 22));
                        t.Add(new Temperature("Virtual", 23));

                        fanControlNames = ["Chassis Fan 1", "CPU Fan", "Chassis Fan 2", "Chassis Fan 3", "High Amp Fan", "Waterpump", "AIO Pump"];
                        System.Diagnostics.Debug.Assert(fanControlNames.Length == superIO.Fans.Length,
                                                        $"Expected {fanControlNames.Length} fan register in the SuperIO chip");

                        System.Diagnostics.Debug.Assert(superIO.Fans.Length == superIO.Controls.Length,
                                                        "Expected counts of cans controls and fan speed registers to be equal");

                        for (int i = 0; i < fanControlNames.Length; i++)
                            f.Add(new Fan(fanControlNames[i], i));

                        for (int i = 0; i < fanControlNames.Length; i++)
                            c.Add(new Control(fanControlNames[i], i));

                        break;

                    case Model.ROG_MAXIMUS_XI_FORMULA: //NC6798D
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+5V", 1, 4, 1));
                        v.Add(new Voltage("AVSB", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1));
                        v.Add(new Voltage("VIN8", 5));
                        v.Add(new Voltage("CPU Graphics", 6));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9, 1, 1));
                        v.Add(new Voltage("DIMM", 10));
                        v.Add(new Voltage("CPU VCCIO", 11, 1, 1));
                        v.Add(new Voltage("PCH Core", 12));
                        v.Add(new Voltage("Phase Locked Loop", 13));
                        v.Add(new Voltage("CPU System Agent", 14));

                        t.Add(new Temperature("Motherboard", 0));
                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("Motherboard", 2));
                        t.Add(new Temperature("CPU (Weighted)", 6));
                        t.Add(new Temperature("CPU (PECI)", 7));
                        t.Add(new Temperature("CPU", 8));

                        fanControlNames = ["Chassis Fan 1", "CPU Fan", "Chassis Fan 2", "Chassis Fan 3", "High Amp Fan", "Water Pump+", "AIO Pump"];
                        System.Diagnostics.Debug.Assert(fanControlNames.Length == superIO.Fans.Length,
                                                        $"Expected {fanControlNames.Length} fan register in the SuperIO chip");

                        System.Diagnostics.Debug.Assert(superIO.Fans.Length == superIO.Controls.Length,
                                                        "Expected counts of cans controls and fan speed registers to be equal");

                        for (int i = 0; i < fanControlNames.Length; i++)
                            f.Add(new Fan(fanControlNames[i], i));

                        for (int i = 0; i < fanControlNames.Length; i++)
                            c.Add(new Control(fanControlNames[i], i));

                        break;

                    case Model.ROG_MAXIMUS_XII_Z490_FORMULA: //NCT6798D
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+5V", 1, 4, 1));
                        v.Add(new Voltage("AVSB", 2, 34, 34));
                        v.Add(new Voltage("3VCC", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1));
                        v.Add(new Voltage("IVR Atom L2 Cluster #1", 5));
                        v.Add(new Voltage("Voltage #7", 6));
                        v.Add(new Voltage("3VSB", 7, 34, 34));
                        v.Add(new Voltage("VBat", 8, 34, 34));
                        v.Add(new Voltage("VTT", 9, 1, 1));
                        v.Add(new Voltage("Voltage #11", 10));
                        v.Add(new Voltage("IVR Atom L2 Cluster #0", 11, 1, 1));
                        v.Add(new Voltage("PCH", 12));
                        v.Add(new Voltage("Voltage #14", 13));
                        v.Add(new Voltage("Voltage #15", 14));

                        t.Add(new Temperature("Temperature #1", 0));
                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("Motherboard", 2));
                        t.Add(new Temperature("Temperature #4", 4));
                        t.Add(new Temperature("Temperature #5", 5));
                        t.Add(new Temperature("Temperature #6", 6));
                        t.Add(new Temperature("Temperature #7", 7));
                        t.Add(new Temperature("PCH", 12));
                        t.Add(new Temperature("Temperature #9", 21));

                        fanControlNames = ["Chassis Fan 1", "CPU Fan", "Chassis Fan 2", "Chassis Fan 3", "Chassis Fan 4", "Waterpump", "AIO Pump"];

                        System.Diagnostics.Debug.Assert(fanControlNames.Length == superIO.Fans.Length,
                                                        $"Expected {fanControlNames.Length} fan register in the SuperIO chip");

                        System.Diagnostics.Debug.Assert(superIO.Fans.Length == superIO.Controls.Length,
                                                        "Expected counts of cans controls and fan speed registers to be equal");

                        for (int i = 0; i < fanControlNames.Length; i++)
                            f.Add(new Fan(fanControlNames[i], i));

                        for (int i = 0; i < fanControlNames.Length; i++)
                            c.Add(new Control(fanControlNames[i], i));

                        break;

                    case Model.ROG_MAXIMUS_X_HERO_WIFI_AC: //NCT6793D
                        v.Add(new Voltage("Vcore", 0, 2, 2));
                        v.Add(new Voltage("+5V", 1, 4, 1));
                        v.Add(new Voltage("AVSB", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("CPU Graphics", 6, 2, 2));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9));
                        v.Add(new Voltage("DIMM", 10, 1, 1));
                        v.Add(new Voltage("CPU System Agent", 11));
                        v.Add(new Voltage("PCH Core", 12));
                        v.Add(new Voltage("Phase Locked Loop", 13));
                        v.Add(new Voltage("CPU VCCIO/IMC", 14));
                        t.Add(new Temperature("CPU (PECI)", 0));
                        t.Add(new Temperature("T2", 1));
                        t.Add(new Temperature("Motherboard", 2)); //Verified via BIOS and HWinfo. HWinfo had T1 and Motherboard, but thye were the same.
                        t.Add(new Temperature("Temperature #3", 4));
                        t.Add(new Temperature("Temperature #4", 5));
                        t.Add(new Temperature("Temperature #5", 6));

                        // note: CPU_Opt, W_Pump+, EXT_FAN 1 & 2 are on the ASUS EC controller. Together with VRM og PCH temperatures. And additional voltages and power
                        fanControlNames = ["Chassis Fan 1", "CPU Fan", "Chassis Fan 2", "Chassis Fan 3", "AIO Pump", "HAMP"];

                        for (int i = 0; i < fanControlNames.Length; i++)
                            f.Add(new Fan(fanControlNames[i], i));

                        for (int i = 0; i < fanControlNames.Length; i++)
                            c.Add(new Control(fanControlNames[i], i));

                        break;

                    case Model.ROG_MAXIMUS_Z690_FORMULA: //NCT6798D
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+5V", 1, 4, 1));
                        v.Add(new Voltage("AVSB", 2, 34, 34));
                        v.Add(new Voltage("3VCC", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1));
                        v.Add(new Voltage("IVR Atom L2 Cluster #1", 5));
                        v.Add(new Voltage("Voltage #7", 6));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9, 1, 1));
                        v.Add(new Voltage("Voltage #10", 10));
                        v.Add(new Voltage("IVR Atom L2 Cluster #0", 11, 1, 1));
                        v.Add(new Voltage("PCH", 12));
                        v.Add(new Voltage("Voltage #14", 13));
                        v.Add(new Voltage("Voltage #15", 14));

                        t.Add(new Temperature("Temperature #1", 0));
                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("Motherboard", 2));
                        t.Add(new Temperature("Temperature #4", 4));
                        t.Add(new Temperature("Temperature #5", 5));
                        t.Add(new Temperature("Temperature #6", 6));
                        t.Add(new Temperature("Temperature #7", 7));
                        t.Add(new Temperature("PCH", 12));
                        t.Add(new Temperature("Temperature #9", 21));

                        fanControlNames = ["Chassis Fan 1", "CPU Fan", "Chassis Fan 2", "Chassis Fan 3", "Chassis Fan 4", "Waterpump", "AIO Pump"];

                        System.Diagnostics.Debug.Assert(fanControlNames.Length == superIO.Fans.Length,
                                                        $"Expected {fanControlNames.Length} fan register in the SuperIO chip");

                        System.Diagnostics.Debug.Assert(superIO.Fans.Length == superIO.Controls.Length,
                                                        "Expected counts of cans controls and fan speed registers to be equal");

                        for (int i = 0; i < fanControlNames.Length; i++)
                            f.Add(new Fan(fanControlNames[i], i));

                        for (int i = 0; i < fanControlNames.Length; i++)
                            c.Add(new Control(fanControlNames[i], i));

                        break;

                    case Model.ROG_MAXIMUS_Z690_HERO: //NCT6798D
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+5V", 1, 4, 1));
                        v.Add(new Voltage("AVSB", 2, 34, 34));
                        v.Add(new Voltage("3VCC", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1));
                        v.Add(new Voltage("IVR Atom L2 Cluster #1", 5));
                        v.Add(new Voltage("Voltage #7", 6));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9, 1, 1));
                        v.Add(new Voltage("Voltage #11", 10));
                        v.Add(new Voltage("IVR Atom L2 Cluster #0", 11, 1, 1));
                        v.Add(new Voltage("PCH", 12));
                        v.Add(new Voltage("Voltage #14 ", 13));
                        v.Add(new Voltage("Voltage #15", 14));

                        t.Add(new Temperature("CPU Package", 0)); // Matches CPU Package in HWinfo & Armoury Crate.
                        t.Add(new Temperature("CPU (Weighted)", 1)); // Unsure about this one. HWinfo & Armoury Crate doesn't have anything that match my values. Varies from 34 (idle) to 42C (under load). Hwinfo is 31-32C for same.

                        t.Add(new Temperature("Motherboard", 2)); // Matches MB in HWinfo & Armoury Crate.
                        //t.Add(new Temperature("Temperature #4", 4));  // Constant at 15C
                        //t.Add(new Temperature("Temperature #5", 5));  // Varies from 15C to 123C. Probably bogus
                        //t.Add(new Temperature("Temperature #6", 6));  // Constant at 32C
                        //t.Add(new Temperature("Temperature #7", 7));  // Varies from 14C to 124C. Probably bogus
                        t.Add(new Temperature("PCH", 12)); // Chipset. Match HWinfo & Armoury Crate
                        t.Add(new Temperature("CPU", 21)); // Matches CPU in HWinfo & Armoury Crate.

                        // note that CPU Opt Fan is on the ASUS EC controller. Together with VRM, Temperature Sensor, WaterIn, WaterOut and WaterFlow + additional sensors.
                        fanControlNames = ["Chassis Fan 1", "CPU Fan", "Chassis Fan 2", "Chassis Fan 3", "Chassis Fan 4", "Waterpump", "AIO Pump"];

                        System.Diagnostics.Debug.Assert(fanControlNames.Length == superIO.Fans.Length,
                                                        $"Expected {fanControlNames.Length} fan register in the SuperIO chip");

                        System.Diagnostics.Debug.Assert(superIO.Fans.Length == superIO.Controls.Length,
                                                        "Expected counts of cans controls and fan speed registers to be equal");

                        for (int i = 0; i < fanControlNames.Length; i++)
                            f.Add(new Fan(fanControlNames[i], i));

                        for (int i = 0; i < fanControlNames.Length; i++)
                            c.Add(new Control(fanControlNames[i], i));

                        break;

                    case Model.ROG_MAXIMUS_Z690_EXTREME_GLACIAL: //NCT6798D
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+5V", 1, 4, 1));
                        v.Add(new Voltage("AVSB", 2, 34, 34));
                        v.Add(new Voltage("3VCC", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1));
                        v.Add(new Voltage("IVR Atom L2 Cluster #1", 5));
                        v.Add(new Voltage("Voltage #7", 6));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9, 1, 1));
                        v.Add(new Voltage("Voltage #11", 10));
                        v.Add(new Voltage("IVR Atom L2 Cluster #0", 11, 1, 1));
                        v.Add(new Voltage("PCH", 12));
                        v.Add(new Voltage("Voltage #14", 13));
                        v.Add(new Voltage("Voltage #15", 14));

                        t.Add(new Temperature("Temperature #1", 0));
                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("Motherboard", 2));
                        //t.Add(new Temperature("Temperature 03", 3));
                        t.Add(new Temperature("Temperature #4", 4));
                        t.Add(new Temperature("Temperature #5", 5));
                        t.Add(new Temperature("Temperature #6", 6));
                        t.Add(new Temperature("Temperature #7", 7));
                        t.Add(new Temperature("PCH", 12));
                        t.Add(new Temperature("Temperature #9", 21));

                        fanControlNames = ["Chassis Fan 1", "CPU Fan", "Radiator Fan 1", "Radiator Fan 2", "Chassis Fan 2", "Water Pump 1", "Water Pump 2"];
                        System.Diagnostics.Debug.Assert(fanControlNames.Length == superIO.Fans.Length,
                                                        $"Expected {fanControlNames.Length} fan register in the SuperIO chip");

                        System.Diagnostics.Debug.Assert(superIO.Fans.Length == superIO.Controls.Length,
                                                        "Expected counts of fan controls and fan speed registers to be equal");

                        for (int i = 0; i < fanControlNames.Length; i++)
                            f.Add(new Fan(fanControlNames[i], i));

                        for (int i = 0; i < fanControlNames.Length; i++)
                            c.Add(new Control(fanControlNames[i], i));

                        break;

                    case Model.ROG_MAXIMUS_Z790_HERO: //NCT6798D
                        t.Add(new Temperature("CPU Package", 0));
                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("Motherboard", 2));
                        //t.Add(new Temperature("Temperature #3", 3));
                        //t.Add(new Temperature("Temperature #4", 4));
                        //t.Add(new Temperature("Temperature #5", 5));
                        //t.Add(new Temperature("Temperature #6", 6));
                        //t.Add(new Temperature("Temperature #7", 7));
                        t.Add(new Temperature("Temperature #8", 8));
                        t.Add(new Temperature("Temperature #9", 9));
                        t.Add(new Temperature("Temperature #10", 10));
                        t.Add(new Temperature("Temperature #11", 11));
                        t.Add(new Temperature("Temperature #12", 12));
                        t.Add(new Temperature("Chipset", 13));
                        t.Add(new Temperature("Temperature #14", 14));
                        t.Add(new Temperature("Temperature #15", 15));
                        t.Add(new Temperature("Temperature #16", 16));
                        t.Add(new Temperature("Temperature #17", 17));
                        t.Add(new Temperature("Temperature #18", 18));
                        t.Add(new Temperature("Temperature #19", 19));
                        t.Add(new Temperature("Temperature #20", 20));
                        t.Add(new Temperature("Temperature #21", 21));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + (i + 1), i));

                        break;

                    case Model.ROG_MAXIMUS_Z790_DARK_HERO: //NCT6798D
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+5V", 1, 4, 1));
                        v.Add(new Voltage("AVSB", 2, 34, 34));
                        v.Add(new Voltage("3VCC", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1));
                        v.Add(new Voltage("IVR Atom L2 Cluster #1", 5));
                        v.Add(new Voltage("Voltage #6", 6));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9, 1, 1));
                        v.Add(new Voltage("Voltage #11", 10, 1, 1));
                        v.Add(new Voltage("IVR Atom L2 Cluster #0", 11, 1, 1));
                        v.Add(new Voltage("PCH", 12));
                        v.Add(new Voltage("CPU System Agent", 13, 1, 1));
                        v.Add(new Voltage("CPU Input Auxiliary", 14, 1, 1));
                        v.Add(new Voltage("Voltage #15", 15));

                        t.Add(new Temperature("CPU Package", 0));
                        t.Add(new Temperature("Motherboard", 2));
                        t.Add(new Temperature("Chipset", 12));
                        t.Add(new Temperature("PCH", 13));
                        t.Add(new Temperature("CPU", 22));

                        f.Add(new Fan("Chassis Fan #1", 0));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("Chassis Fan #2", 2));
                        f.Add(new Fan("Chassis Fan #3", 3));
                        f.Add(new Fan("Chassis Fan #4", 4));
                        f.Add(new Fan("Water Pump", 5));
                        f.Add(new Fan("AIO Pump", 6));

                        c.Add(new Control("Chassis Fan #1", 0));
                        c.Add(new Control("CPU Fan", 1));
                        c.Add(new Control("Chassis Fan #2", 2));
                        c.Add(new Control("Chassis Fan #3", 3));
                        c.Add(new Control("Chassis Fan #4", 4));
                        c.Add(new Control("Water Pump", 5));
                        c.Add(new Control("AIO Pump", 6));

                        break;

                    case Model.ROG_STRIX_B760_I_GAMING_WIFI: //NCT6798D

                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+5V", 1, 4, 1));
                        v.Add(new Voltage("AVSB", 2, 34, 34));
                        v.Add(new Voltage("3VCC", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9, 1, 1));
                        v.Add(new Voltage("IMC VDD", 10, 1, 1));
                        v.Add(new Voltage("Voltage #12", 11, true));
                        v.Add(new Voltage("Voltage #13", 12, true));
                        v.Add(new Voltage("Voltage #14", 13, true));
                        v.Add(new Voltage("Voltage #15", 14, true));
                        v.Add(new Voltage("Voltage #16", 15, true));

                        t.Add(new Temperature("CPU Package", 0));
                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("Motherboard", 2));
                        t.Add(new Temperature("VRM", 3));
                        t.Add(new Temperature("Thermistor Sensor", 8));
                        t.Add(new Temperature("PCH", 13));
                        t.Add(new Temperature("CPU Calibrated", 22));

                        f.Add(new Fan("Chassis Fan", 0));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("AIO Pump", 5));

                        c.Add(new Control("Chassis Fan", 0));
                        c.Add(new Control("CPU Fan", 1));
                        c.Add(new Control("AIO Pump", 5));

                        break;

                    case Model.ROG_STRIX_Z790_E_GAMING_WIFI_II: //NCT6798D

                        t.Add(new Temperature("CPU Package", 0));
                        t.Add(new Temperature("Motherboard", 2));
                        t.Add(new Temperature("Chipset", 12));
                        t.Add(new Temperature("PCH", 13));
                        t.Add(new Temperature("CPU", 22));

                        f.Add(new Fan("Chassis Fan #1", 0));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("Chassis Fan #2", 2));
                        f.Add(new Fan("Chassis Fan #3", 3));
                        f.Add(new Fan("Chassis Fan #4", 4));
                        f.Add(new Fan("Chassis FAN #5", 5));
                        f.Add(new Fan("AIO Pump", 6));

                        c.Add(new Control("Chassis Fan #1", 0));
                        c.Add(new Control("CPU Fan", 1));
                        c.Add(new Control("Chassis Fan #2", 2));
                        c.Add(new Control("Chassis Fan #3", 3));
                        c.Add(new Control("Chassis Fan #4", 4));
                        c.Add(new Control("Chassis Fan #5", 5));
                        c.Add(new Control("AIO Pump", 6));

                        break;

                    case Model.ROG_STRIX_B550_I_GAMING: //NCT6798D
                        v.Add(new Voltage("Vcore", 0, 10, 10));
                        v.Add(new Voltage("+5V", 1, 4, 1)); //Probably not updating properly
                        v.Add(new Voltage("AVCC", 2, 10, 10));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1)); //Probably not updating properly
                        //v.Add(new Voltage("#Unused #5", 5, 0, 1, 0, true));
                        //v.Add(new Voltage("#Unused #6", 6, 0, 1, 0, true));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9));

                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("Motherboard", 2));
                        t.Add(new Temperature("PCH Chip CPU Max", 11));
                        t.Add(new Temperature("PCH Chip", 12));
                        t.Add(new Temperature("PCH CPU", 13));
                        t.Add(new Temperature("PCH MCH", 14));
                        t.Add(new Temperature("Agent 0 DIMM 0", 15));
                        //t.Add(new Temperature("Agent 0 DIMM 1", 16));
                        t.Add(new Temperature("Agent 1 DIMM 0", 17));
                        //t.Add(new Temperature("Agent 1 DIMM 1", 18));
                        t.Add(new Temperature("Device 0", 19));
                        t.Add(new Temperature("Device 1", 20));
                        t.Add(new Temperature("PECI 0 Calibrated", 21));
                        t.Add(new Temperature("PECI 1 Calibrated", 22));
                        t.Add(new Temperature("Virtual", 23));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                        {
                            switch (i)
                            {
                                case 0:
                                    f.Add(new Fan("Chassis Fan", 0));
                                    break;
                                case 1:
                                    f.Add(new Fan("CPU Fan", 1));
                                    break;
                                case 4:
                                    f.Add(new Fan("AIO Pump", 4));
                                    break;
                            }
                        }

                        for (int i = 0; i < superIO.Controls.Length; i++)
                        {
                            switch (i)
                            {
                                case 0:
                                    c.Add(new Control("Chassis Fan", 0));
                                    break;
                                case 1:
                                    c.Add(new Control("CPU Fan", 1));
                                    break;
                                case 4:
                                    c.Add(new Control("AIO Pump", 4));
                                    break;
                            }
                        }

                        break;

                    case Model.ROG_ZENITH_II_EXTREME: // NCT6798D
                        // Voltage = value + (value - Vf) * Ri / Rf.
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+5V", 1, 4, 1));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 6, 1));
                        v.Add(new Voltage("DIMM C/D", 11, 10, 10));
                        v.Add(new Voltage("DIMM A/B", 13));
                        v.Add(new Voltage("Phase Locked Loop", 14));

                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("Motherboard", 2));
                        t.Add(new Temperature("Temperature #3", 3));
                        t.Add(new Temperature("Temperature #4", 4));
                        t.Add(new Temperature("Temperature #5", 5));
                        t.Add(new Temperature("Temperature #6", 6));
                        t.Add(new Temperature("Temperature #7", 7));
                        t.Add(new Temperature("Temperature #21", 21));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                        {
                            switch (i)
                            {
                                case 0:
                                    f.Add(new Fan("Chassis Fan", 0));
                                    break;
                                case 1:
                                    f.Add(new Fan("CPU Fan", 1));
                                    break;
                                case 2:
                                    f.Add(new Fan("CPU Optional Fan", 2));
                                    break;
                                case 4:
                                    f.Add(new Fan("AIO Pump", 4));
                                    break;
                            }
                        }

                        for (int i = 0; i < superIO.Controls.Length; i++)
                        {
                            switch (i)
                            {
                                case 0:
                                    c.Add(new Control("Chassis Fan", 0));
                                    break;
                                case 1:
                                    c.Add(new Control("CPU Fan", 1));
                                    break;
                                case 2:
                                    c.Add(new Control("CPU Optional Fan", 2));
                                    break;
                                case 4:
                                    c.Add(new Control("AIO Pump", 4));
                                    break;
                            }
                        }

                        break;

                    case Model.ROG_STRIX_X570_I_GAMING: //NCT6798D
                        v.Add(new Voltage("Vcore", 0, 10, 10));
                        v.Add(new Voltage("+5V", 1, 4, 1)); //Probably not updating properly
                        v.Add(new Voltage("AVCC", 2, 10, 10));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1)); //Probably not updating properly
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9));
                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("Motherboard", 2));
                        t.Add(new Temperature("Temperature #3", 3));
                        t.Add(new Temperature("Temperature #4", 4));
                        t.Add(new Temperature("Temperature #5", 5));
                        t.Add(new Temperature("Temperature #6", 6));
                        t.Add(new Temperature("Temperature #7", 7));
                        t.Add(new Temperature("Temperature #21", 21));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                        {
                            switch (i)
                            {
                                case 0:
                                    f.Add(new Fan("Chassis Fan", 0));
                                    break;
                                case 1:
                                    f.Add(new Fan("CPU Fan", 1));
                                    break;
                                case 4:
                                    f.Add(new Fan("AIO Pump", 4));
                                    break;
                            }
                        }

                        for (int i = 0; i < superIO.Controls.Length; i++)
                        {
                            switch (i)
                            {
                                case 0:
                                    c.Add(new Control("Chassis Fan", 0));
                                    break;
                                case 1:
                                    c.Add(new Control("CPU Fan", 1));
                                    break;
                                case 4:
                                    c.Add(new Control("AIO Pump", 4));
                                    break;
                            }
                        }

                        break;

                    case Model.ROG_STRIX_B550_F_GAMING_WIFI: // NCT6798D-R
                        v.Add(new Voltage("Vcore", 0, 2, 2));
                        v.Add(new Voltage("+5V", 1, 4, 1));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9));
                        v.Add(new Voltage("Voltage #11", 10, true));
                        v.Add(new Voltage("Voltage #12", 11, true));
                        v.Add(new Voltage("Voltage #13", 12, true));
                        v.Add(new Voltage("Voltage #14", 13, true));
                        v.Add(new Voltage("Voltage #15", 14, true));
                        t.Add(new Temperature("CPU Core", 0));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + (i + 1), i));

                        break;

                    case Model.PRIME_B650_PLUS: // NCT6799D
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+5V", 1, 4, 1));
                        v.Add(new Voltage("AVSB", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9));
                        v.Add(new Voltage("CPU VDDIO Memory", 10, 1, 1));

                        t.Add(new Temperature("CPU", 22));
                        t.Add(new Temperature("Motherboard", 2));
                        t.Add(new Temperature("CPU Package", 3));

                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("CPU Optional Fan", 4));
                        f.Add(new Fan("Chassis Fan #1", 0));
                        f.Add(new Fan("Chassis Fan #2", 2));
                        f.Add(new Fan("Chassis Fan #3", 3));
                        f.Add(new Fan("AIO Pump", 5));

                        c.Add(new Control("CPU Fan", 1));
                        c.Add(new Control("Chassis Fan #1", 0));
                        c.Add(new Control("Chassis Fan #2", 2));
                        c.Add(new Control("Chassis Fan #3", 3));
                        c.Add(new Control("AIO Pump", 5));

                        break;

                    case Model.ROG_CROSSHAIR_X670E_GENE: // NCT6799D
                    case Model.ROG_CROSSHAIR_X670E_HERO:
                        v.Add(new Voltage("Vcore", 0, 2, 2)); // This is wrong
                        v.Add(new Voltage("+5V", 1, 4, 1));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9)); // This is wrong
                        v.Add(new Voltage("Voltage #11", 10, true));
                        v.Add(new Voltage("Voltage #12", 11, true));
                        v.Add(new Voltage("Voltage #13", 12, true));
                        v.Add(new Voltage("Voltage #14", 13, true));
                        v.Add(new Voltage("Voltage #15", 14, true));
                        t.Add(new Temperature("CPU Core", 0));
                        t.Add(new Temperature("Temperature #1", 1)); // No matching temp value
                        t.Add(new Temperature("Motherboard", 2)); // Matches MB in HWinfo
                        t.Add(new Temperature("Temperature #3", 3)); // No matching temp value
                        t.Add(new Temperature("Temperature #4", 4)); // No matching temp value
                        t.Add(new Temperature("Temperature #5", 5)); // No matching temp value
                        t.Add(new Temperature("Temperature #6", 6)); // No matching temp value
                        t.Add(new Temperature("Temperature #7", 8)); // Matches MB in HWinfo
                        t.Add(new Temperature("CPU", 22)); // Matches MB in HWinfo
                        t.Add(new Temperature("Thermistor Sensor", 24));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + (i + 1), i));

                        break;

                    case Model.ROG_STRIX_X670E_A_GAMING_WIFI: // NCT6799D
                    case Model.ROG_STRIX_X670E_E_GAMING_WIFI: // NCT6799D
                    case Model.ROG_STRIX_X670E_F_GAMING_WIFI: // NCT6799D
                        v.Add(new Voltage("Vcore", 0, 2, 2)); // This is wrong
                        v.Add(new Voltage("+5V", 1, 4, 1));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9)); // This is wrong
                        v.Add(new Voltage("Voltage #11", 10, true));
                        v.Add(new Voltage("Voltage #12", 11, true));
                        v.Add(new Voltage("Voltage #13", 12, true));
                        v.Add(new Voltage("Voltage #14", 13, true));
                        v.Add(new Voltage("Voltage #15", 14, true));
                        t.Add(new Temperature("CPU Core", 0));
                        t.Add(new Temperature("VRM", 1)); // Aligned with BIOS value ROG_STRIX_X670E_E_GAMING_WIFI
                        t.Add(new Temperature("Motherboard", 2)); // Aligned with Armoury Crate ROG_STRIX_X670E_E_GAMING_WIFI
                        t.Add(new Temperature("Temperature #3", 3)); // No matching temp value
                        t.Add(new Temperature("Temperature #4", 4)); // No matching temp value
                        t.Add(new Temperature("Temperature #5", 5)); // No matching temp value
                        t.Add(new Temperature("Temperature #6", 6)); // No matching temp value
                        t.Add(new Temperature("Thermistor Sensor", 24)); // Aligned with Armoury Crate ROG_STRIX_X670E_E_GAMING_WIFI

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + (i + 1), i));

                        break;

                    case Model.ROG_STRIX_X870E_E_GAMING_WIFI: // NCT6701D
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+5V", 1, 4, 1));
                        v.Add(new Voltage("AVSB", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9, true)); // Value does not match any in hwmonnitor
                        v.Add(new Voltage("CPU VDDIO Memory", 10, 1, 1));

                        t.Add(new Temperature("Motherboard", 2));
                        t.Add(new Temperature("CPU", 22));

                        fanControlNames = ["Chassis Fan #1", "CPU Fan", "Chassis Fan #2", "Chassis Fan #3", "Chassis Fan #4", "Chassis Fan #5", "AIO Pump"];

                        System.Diagnostics.Debug.Assert(fanControlNames.Length == superIO.Fans.Length, $"Expected {fanControlNames.Length} fan register in the SuperIO chip");
                        System.Diagnostics.Debug.Assert(superIO.Fans.Length == superIO.Controls.Length, "Expected counts of cans controls and fan speed registers to be equal");

                        for (int i = 0; i < fanControlNames.Length; i++)
                            f.Add(new Fan(fanControlNames[i], i));

                        for (int i = 0; i < fanControlNames.Length; i++)
                            c.Add(new Control(fanControlNames[i], i));

                        break;

                    case Model.PROART_X670E_CREATOR_WIFI: // NCT6799D
                        v.Add(new Voltage("Vcore", 0)); // This is wrong
                        v.Add(new Voltage("+5V", 1, 4, 1));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        //v.Add(new Voltage("CPU Termination", 9)); // This is wrong
                        t.Add(new Temperature("CPU", 22));
                        t.Add(new Temperature("Motherboard", 2));
                        t.Add(new Temperature("Thermistor Sensor", 24)); // Aligned with Armoury Crate
                        t.Add(new Temperature("Temperature #1", 1)); // Unknown, Possibly VRM with 23 offset

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + (i + 1), i));

                        break;

                    case Model.PRIME_X870_P: // NCT6701D
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+5V", 1, 4, 1));
                        v.Add(new Voltage("AVSB", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9, 34, 34));
                        v.Add(new Voltage("CPU VDDIO Memory", 10, 1, 1));
                        v.Add(new Voltage("Voltage #12", 11, true));
                        v.Add(new Voltage("+1.8V Standby", 12, true)); // Uknown values needed for tuning, hidden for now
                        v.Add(new Voltage("Voltage #14", 13, true));
                        v.Add(new Voltage("Voltage #15", 14, true));
                        v.Add(new Voltage("Voltage #16", 15, true));
                        // All voltage channels above 15 cannot be added?

                        t.Add(new Temperature("Motherboard", 2));
                        t.Add(new Temperature("VRM", 7));
                        t.Add(new Temperature("CPU", 22));

                        fanControlNames = ["Chassis Fan #1", "CPU Fan", "Chassis Fan #2", "Chassis Fan #3", "CPU_OPT", "Chassis Fan #4", "AIO Pump"];

                        for (int i = 0; i < fanControlNames.Length; i++)
                            f.Add(new Fan(fanControlNames[i], i));

                        for (int i = 0; i < fanControlNames.Length; i++)
                            c.Add(new Control(fanControlNames[i], i));

                        break;

                    case Model.ROG_STRIX_X870_I_GAMING_WIFI: // NCT6701D
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+5V", 1, 4.02f, 1));
                        v.Add(new Voltage("AVSB", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 10.98f, 1));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("VTT", 9, 34, 34));
                        v.Add(new Voltage("CPU VDDIO Memory", 10, 34, 34));
                        v.Add(new Voltage("VMISC", 11, 34, 34));
                        v.Add(new Voltage("1.8V Standby", 12, 7.66f, 10));

                        t.Add(new Temperature("CPU", 22));
                        t.Add(new Temperature("Motherboard", 2));

                        f.Add(new Fan("Chassis", 0));
                        f.Add(new Fan("CPU", 1));
                        f.Add(new Fan("Chipset / Disk", 5));
                        f.Add(new Fan("AIO Pump", 6));

                        c.Add(new Control("Chassis", 0));
                        c.Add(new Control("CPU", 1));
                        c.Add(new Control("Chipset / Disk", 5));
                        c.Add(new Control("AIO Pump", 6));

                        break;

                    case Model.ROG_CROSSHAIR_X870E_APEX: // NCT6701D
                        {
                            v.Add(new Voltage("Vcore", 0, 15, 136));
                            v.Add(new Voltage("+5V", 1, 4, 1));
                            v.Add(new Voltage("AVSB", 2, 34, 34));
                            v.Add(new Voltage("+3.3V", 3, 34, 34));
                            v.Add(new Voltage("+12V", 4, 11, 1));
                            v.Add(new Voltage("VMISC", 5, 9, 82));
                            v.Add(new Voltage("CPU SOC", 6, 9, 82));
                            v.Add(new Voltage("+3V Standby", 7, 34, 34));
                            v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                            v.Add(new Voltage("VTT", 9, 34, 34));
                            v.Add(new Voltage("Chipset 0 VDD", 10, 1, 1));
                            v.Add(new Voltage("Chipset 1 VDD", 11, 1, 1));
                            v.Add(new Voltage("Chipset Standby", 12));
                            v.Add(new Voltage("CPU VDDIO Memory", 13, 9, 82));
                            v.Add(new Voltage("1.8V PLL", 14, 17, 36));

                            // The following mappings only apply when FanXpert is off in Armoury Crate.
                            t.Add(new Temperature("CPU Package", 0));
                            t.Add(new Temperature("VRM", 1));
                            t.Add(new Temperature("Motherboard", 2));

                            // BIOS 1804 or above moved CPU Temp Sensor to 21
                            t.Add(new Temperature("CPU", 21));

                            // For BIOS 1803 or older
                            t.Add(new Temperature("CPU", 22));

                            // Add all unmapped temperature sensors
                            for (int i = 3; i < superIO.Temperatures.Length; i++)
                            {
                                // 21 and 22 are not used at the same time
                                if (i != 21 && i != 22)
                                {
                                    t.Add(new Temperature($"Temperature #{i}", i));
                                }
                            }

                            fanControlNames = ["Chassis Fan #1", "CPU Fan", "Chassis Fan #2", "Extra Flow Fan", "Unused", "Water Pump", "AIO Pump"];

                            System.Diagnostics.Debug.Assert(fanControlNames.Length == superIO.Fans.Length, $"Expected {fanControlNames.Length} fan register in the SuperIO chip");
                            System.Diagnostics.Debug.Assert(superIO.Fans.Length == superIO.Controls.Length, "Expected counts of fan controls and fan speed registers to be equal");

                            for (int i = 0; i < fanControlNames.Length; i++)
                            {
                                f.Add(new Fan(fanControlNames[i], i));
                            }

                            for (int i = 0; i < fanControlNames.Length; i++)
                            {
                                c.Add(new Control(fanControlNames[i], i));
                            }
                        }

                        break;

                    case Model.ROG_CROSSHAIR_X870E_HERO: // NCT6701D
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+5V", 1, 4, 1));
                        v.Add(new Voltage("AVSB", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9, true)); // Value does not match any in hwmonitor
                        v.Add(new Voltage("CPU VDDIO Memory", 10, 1, 1));

                        t.Add(new Temperature("CPU Package", 0));
                        t.Add(new Temperature("Motherboard", 2));
                        t.Add(new Temperature("CPU", 22));

                        fanControlNames = ["Chassis Fan #1", "CPU Fan", "Chassis Fan #2", "Chassis Fan #3", "Chassis Fan #4", "Water Pump", "AIO Pump"];

                        System.Diagnostics.Debug.Assert(fanControlNames.Length == superIO.Fans.Length, $"Expected {fanControlNames.Length} fan register in the SuperIO chip");
                        System.Diagnostics.Debug.Assert(superIO.Fans.Length == superIO.Controls.Length, "Expected counts of fan controls and fan speed registers to be equal");

                        for (int i = 0; i < fanControlNames.Length; i++)
                            f.Add(new Fan(fanControlNames[i], i));

                        for (int i = 0; i < fanControlNames.Length; i++)
                            c.Add(new Control(fanControlNames[i], i));

                        break;

                    case Model.PROART_X870E_CREATOR_WIFI: // NCT6701D
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9));
                        v.Add(new Voltage("Voltage #11", 10, true));
                        v.Add(new Voltage("Voltage #12", 11, true));
                        v.Add(new Voltage("Voltage #13", 12, true));
                        v.Add(new Voltage("Voltage #14", 13, true));
                        v.Add(new Voltage("Voltage #15", 14, true));

                        t.Add(new Temperature("Motherboard", 2));
                        t.Add(new Temperature("CPU", 22));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + (i + 1), i));

                        break;

                    case Model.PROART_B760_CREATOR_D4: // NCT6798D
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+5V", 1, 4, 1));
                        v.Add(new Voltage("AVSB", 2, 34, 34));
                        v.Add(new Voltage("3VCC", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1));
                        v.Add(new Voltage("IVR Atom L2 Cluster #1", 5));
                        v.Add(new Voltage("Voltage #7", 6));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9, 1, 1));
                        v.Add(new Voltage("Voltage #11", 10));
                        v.Add(new Voltage("IVR Atom L2 Cluster #0", 11, 1, 1));
                        v.Add(new Voltage("PCH", 12));
                        v.Add(new Voltage("Voltage #14", 13));
                        v.Add(new Voltage("Voltage #15", 14));

                        t.Add(new Temperature("CPU Package", 0)); // PECI_0, CPU Package
                        t.Add(new Temperature("CPU", 1)); // CPUTIN, CPU
                        t.Add(new Temperature("Motherboard", 2)); // SYSTIN, MOTHERBOARD
                        t.Add(new Temperature("Thermistor Sensor", 8)); // TSENSOR
                        t.Add(new Temperature("PCH", 13)); // PCH_CHIP_TEMP
                        t.Add(new Temperature("PECI 0 Calibrated", 22)); // PECI_0_CAL, CPU

                        f.Add(new Fan("Chassis Fan #1", 0)); // CHA_FAN_1
                        f.Add(new Fan("CPU Fan", 1)); // CPU_FAN
                        f.Add(new Fan("Chassis Fan #2", 2)); // CHA_FAN_2
                        f.Add(new Fan("Chassis Fan #3", 3)); // CHA_FAN_3
                        f.Add(new Fan("Chassis Fan #4", 4)); // CHA_FAN_4
                        f.Add(new Fan("CPU Optional Fan", 5)); // CPU_OPT
                        f.Add(new Fan("AIO Pump", 6)); // AIO_PUMP

                        c.Add(new Control("Chassis Fan #1", 0)); // CHA_FAN_1
                        c.Add(new Control("CPU Fan", 1)); // CPU_FAN
                        c.Add(new Control("Chassis Fan #2", 2)); // CHA_FAN_2
                        c.Add(new Control("Chassis Fan #3", 3)); // CHA_FAN_3
                        c.Add(new Control("Chassis Fan #4", 4)); // CHA_FAN_4
                        c.Add(new Control("CPU Optional Fan", 5)); // CPU_OPT
                        c.Add(new Control("AIO Pump", 6)); // AIO_PUMP

                        break;

                    case Model.ROG_STRIX_B850_E_GAMING_WIFI: // NCT6701D
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+5V", 1, 4.02f, 1));
                        v.Add(new Voltage("AVSB", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 10.98f, 1));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("VTT", 9, 34, 34));
                        v.Add(new Voltage("CPU VDDIO Memory", 10, 34, 34));
                        v.Add(new Voltage("VMisc", 11, 34, 34));
                        v.Add(new Voltage("1.8V Standby", 12, 7.66f, 10));
                        v.Add(new Voltage("Voltage #14", 13, true));
                        v.Add(new Voltage("Voltage #15", 14, true));
                        v.Add(new Voltage("Voltage #16", 15, true));

                        t.Add(new Temperature("CPU", 21));
                        //t.Add(new Temperature("CPU Package", 7));
                        t.Add(new Temperature("Motherboard", 2));
                        //t.Add(new Temperature("VRM", 1));

                        fanControlNames = ["Chassis Fan #1", "CPU Fan", "Chassis Fan #2", "Chassis Fan #3", "Chassis Fan #4", "Chassis Fan #5", "AIO Pump"];

                        System.Diagnostics.Debug.Assert(fanControlNames.Length == superIO.Fans.Length, $"Expected {fanControlNames.Length} fan register in the SuperIO chip");
                        System.Diagnostics.Debug.Assert(superIO.Fans.Length == superIO.Controls.Length, "Expected counts of cans controls and fan speed registers to be equal");

                        for (int i = 0; i < fanControlNames.Length; i++)
                            f.Add(new Fan(fanControlNames[i], i));

                        for (int i = 0; i < fanControlNames.Length; i++)
                            c.Add(new Control(fanControlNames[i], i));

                        break;

                    case Model.ROG_STRIX_B850_I_GAMING_WIFI: // NCT6701D
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+5V", 1, 4.02f, 1));
                        v.Add(new Voltage("AVSB", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 10.98f, 1));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("VTT", 9, 34, 34));
                        v.Add(new Voltage("CPU VDDIO Memory", 10, 34, 34));
                        v.Add(new Voltage("VMISC", 11, 34, 34));
                        v.Add(new Voltage("1,8V Standby", 12, 7.66f, 10));
                        v.Add(new Voltage("Voltage #14", 13, true));
                        v.Add(new Voltage("Voltage #15", 14, true));
                        v.Add(new Voltage("Voltage #16", 15, true));

                        t.Add(new Temperature("CPU", 22));
                        t.Add(new Temperature("Motherboard", 2));
                        t.Add(new Temperature("T-Sensor", 6));

                        f.Add(new Fan("Chassis Fan", 0));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("Extra Flow Fan", 5));
                        f.Add(new Fan("AIO Pump", 6));

                        c.Add(new Control("Chassis Fan", 0));
                        c.Add(new Control("CPU Fan", 1));
                        c.Add(new Control("Extra Flow Fan", 5));
                        c.Add(new Control("AIO Pump", 6));

                        break;

                    case Model.TUF_GAMING_B850M_PLUS_II: // NCT6701D
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+5V", 1, 4.02f, 1));
                        v.Add(new Voltage("AVSB", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 10.98f, 1));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("VTT", 9, 34, 34));
                        v.Add(new Voltage("CPU VDDIO Memory", 10, 34, 34));
                        v.Add(new Voltage("VMISC", 11, 34, 34));
                        v.Add(new Voltage("1,8V Standby", 12, 7.66f, 10));
                        v.Add(new Voltage("Voltage #14", 13, true));
                        v.Add(new Voltage("Voltage #15", 14, true));
                        v.Add(new Voltage("Voltage #16", 15, true));

                        t.Add(new Temperature("CPU", 22));
                        t.Add(new Temperature("Motherboard", 2));
                        t.Add(new Temperature("T-Sensor", 6));
                        
                        f.Add(new Fan("Chassis Fan #1", 0)); // CHA_FAN_1
                        f.Add(new Fan("CPU Fan", 1)); // CPU_FAN
                        f.Add(new Fan("Chassis Fan #2", 2)); // CHA_FAN_2
                        f.Add(new Fan("Chassis Fan #3", 3)); // CHA_FAN_3
                        f.Add(new Fan("CPU Optional Fan", 4)); // CPU_OPT
                        f.Add(new Fan("AIO Pump", 5)); // AIO_PUMP

                        c.Add(new Control("Chassis Fan #1", 0)); // CHA_FAN_1
                        c.Add(new Control("CPU Fan", 1)); // CPU_FAN
                        c.Add(new Control("Chassis Fan #2", 2)); // CHA_FAN_2
                        c.Add(new Control("Chassis Fan #3", 3)); // CHA_FAN_3
                        c.Add(new Control("CPU Optional Fan", 4)); // CPU_OPT
                        c.Add(new Control("AIO Pump", 5)); // AIO_PUMP
                        break;

                    default:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9));
                        v.Add(new Voltage("Voltage #11", 10, true));
                        v.Add(new Voltage("Voltage #12", 11, true));
                        v.Add(new Voltage("Voltage #13", 12, true));
                        v.Add(new Voltage("Voltage #14", 13, true));
                        v.Add(new Voltage("Voltage #15", 14, true));
                        t.Add(new Temperature("CPU Core", 0));
                        t.Add(new Temperature("Temperature #1", 1));
                        t.Add(new Temperature("Temperature #2", 2));
                        t.Add(new Temperature("Temperature #3", 3));
                        t.Add(new Temperature("Temperature #4", 4));
                        t.Add(new Temperature("Temperature #5", 5));
                        t.Add(new Temperature("Temperature #6", 6));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + (i + 1), i));

                        break;
                }

                break;
            case Manufacturer.MSI:
                switch (model)
                {
                    case Model.B360M_PRO_VDH: // NCT6797D
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+5V", 1, 4, 1));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1));
                        //v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("CPU I/O", 6));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9));
                        v.Add(new Voltage("CPU System Agent", 10));
                        //v.Add(new Voltage("Voltage #12", 11, true));
                        v.Add(new Voltage("Northbridge/SoC", 12));
                        v.Add(new Voltage("DIMM", 13, 1, 1));
                        //v.Add(new Voltage("Voltage #15", 14, true));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Auxiliary", 1));
                        t.Add(new Temperature("Motherboard", 2));
                        t.Add(new Temperature("Temperature #1", 5));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("System Fan #1", 2));
                        f.Add(new Fan("System Fan #2", 3));
                        c.Add(new Control("CPU Fan", 1));
                        c.Add(new Control("System Fan #1", 2));
                        c.Add(new Control("System Fan #2", 3));

                        break;

                    case Model.B450A_PRO: // NCT6797D
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+5V", 1, 4, 1));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1));
                        //v.Add(new Voltage("Voltage #6", 5, false));
                        //v.Add(new Voltage("CPU I/O", 6));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9));
                        v.Add(new Voltage("CPU System Agent", 10));
                        //v.Add(new Voltage("Voltage #12", 11, false));
                        v.Add(new Voltage("Northbridge/SoC", 12));
                        v.Add(new Voltage("DIMM", 13, 1, 1));
                        //v.Add(new Voltage("Voltage #15", 14, false));
                        //t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("CPU", 1));
                        t.Add(new Temperature("System", 2));
                        t.Add(new Temperature("VRM MOS", 3));
                        t.Add(new Temperature("PCH", 5));
                        t.Add(new Temperature("SMBus 0", 8));
                        f.Add(new Fan("Pump Fan", 0));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("System Fan #1", 2));
                        f.Add(new Fan("System Fan #2", 3));
                        f.Add(new Fan("System Fan #3", 4));
                        f.Add(new Fan("System Fan #4", 5));
                        c.Add(new Control("Pump Fan", 0));
                        c.Add(new Control("CPU Fan", 1));
                        c.Add(new Control("System Fan #1", 2));
                        c.Add(new Control("System Fan #2", 3));
                        c.Add(new Control("System Fan #3", 4));
                        c.Add(new Control("System Fan #4", 5));

                        break;

                    case Model.Z270_PC_MATE: // NCT6795D
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+5V", 1, 4, 1));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("CPU I/O", 6));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9));
                        v.Add(new Voltage("CPU System Agent", 10));
                        v.Add(new Voltage("Voltage #12", 11, true));
                        v.Add(new Voltage("PCH", 12));
                        v.Add(new Voltage("DIMM", 13, 1, 1));
                        v.Add(new Voltage("Voltage #15", 14, true));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Auxiliary", 1));
                        t.Add(new Temperature("Motherboard", 2));
                        f.Add(new Fan("Pump Fan", 0));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("System Fan #1", 2));
                        f.Add(new Fan("System Fan #2", 3));
                        f.Add(new Fan("System Fan #3", 4));
                        f.Add(new Fan("System Fan #4", 5));
                        c.Add(new Control("Pump Fan", 0));
                        c.Add(new Control("CPU Fan", 1));
                        c.Add(new Control("System Fan #1", 2));
                        c.Add(new Control("System Fan #2", 3));
                        c.Add(new Control("System Fan #3", 4));
                        c.Add(new Control("System Fan #4", 5));

                        break;

                    case Model.X570_Gaming_Plus:
                        // NCT6797D
                        // NCT771x : PCIe 1, M.2 1, not supported
                        // RF35204 : VRM not supported

                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+5V", 1, 4, 1));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+12V", 4, 11, 1));
                        //v.Add(new Voltage("Voltage #6", 5));
                        v.Add(new Voltage("VIN4", 6));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9));
                        //v.Add(new Voltage("Voltage #11", 10));
                        v.Add(new Voltage("Voltage #11", 11));
                        v.Add(new Voltage("CPU NB/SoC", 12));
                        v.Add(new Voltage("DIMM", 13, 1, 1));
                        v.Add(new Voltage("Voltage #14", 14));

                        //t.Add(new Temperature("Unknown Temperature #1", 1));
                        t.Add(new Temperature("System", 2));
                        t.Add(new Temperature("MOS", 3));
                        t.Add(new Temperature("Chipset", 5));
                        t.Add(new Temperature("CPU", 9));

                        f.Add(new Fan("Pump Fan", 0));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("System Fan #1", 2));
                        f.Add(new Fan("System Fan #2", 3));
                        f.Add(new Fan("System Fan #3", 4));
                        f.Add(new Fan("System Fan #4", 5));
                        f.Add(new Fan("Chipset Fan", 6));

                        c.Add(new Control("Pump Fan", 0));
                        c.Add(new Control("CPU Fan", 1));
                        c.Add(new Control("System Fan #1", 2));
                        c.Add(new Control("System Fan #2", 3));
                        c.Add(new Control("System Fan #3", 4));
                        c.Add(new Control("System Fan #4", 5));
                        c.Add(new Control("Chipset Fan", 6));

                        break;

                    case Model.X570_MS7C35:
                        // NCT6797D
                        // NCT7802Y (on SMBus): SYS_FAN5, CPU 1.8V, Chipset SOC, Chipset CLDO - not supported
                        // Unknown: PCIe 1, PCIe 3, M.2_1

                        v.Add(new Voltage("Vcore", 0));           // CPUVCORE
                        v.Add(new Voltage("+5V", 1, 12, 3));      // VIN1
                        v.Add(new Voltage("AVCC", 2, 34, 34));    // AVSB, +3.3V analog power
                        v.Add(new Voltage("+3.3V", 3, 34, 34));   // 3VCC
                        v.Add(new Voltage("+12V", 4, 220, 20));  // VIN0
                        v.Add(new Voltage("VRM MOS", 6, true)); // VIN4, temperature input
                        v.Add(new Voltage("+3.3V Standby", 7, 34, 34));   // 3VSB, +3.3V digital power
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34, 0)); // VBAT
                        v.Add(new Voltage("CPU 1.8V", 9));        // VTT, CPU_1P8
                        v.Add(new Voltage("CPU VDDP", 10));       // VIN5
                        v.Add(new Voltage("Voltage #6", 11, true));    // VIN6, temperature input
                        v.Add(new Voltage("CPU NB/SoC", 12));     // VIN2, VCCP_NB
                        v.Add(new Voltage("DIMM", 13, 1, 1));     // VIN3
                        v.Add(new Voltage("+5V Standby", 14, 768, 330));  // VIN7, ATX_5VSB

                        t.Add(new Temperature("CPU Socket", 1));  // CPUTIN, 10k at top side of the socket
                        t.Add(new Temperature("System", 2));      // SYSTIN, P-3906
                        t.Add(new Temperature("VRM MOS", 3));     // AUXTIN0, CPUMOSTIN, 10k at left side of cpu vrm
                        t.Add(new Temperature("Chipset", 5));     // AUXTIN2, 10k at back side of the chipset
                        t.Add(new Temperature("CPU", 23));
                        // Add Thermistor Sensors for voltage inputs that are marked ad
                        t.Add(new Temperature("MOS CPU", 24));  // (VIN 4 Voltage) NTC Near MOSFET CPU VRM
                        t.Add(new Temperature("PCH", 25));      // (Voltage #6) X570 Platform Control HUB TEMP (NTC On Bottom of PCB)

                        f.Add(new Fan("Pump Fan", 0));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("System Fan #1", 2));
                        f.Add(new Fan("System Fan #2", 3));
                        f.Add(new Fan("System Fan #3", 4));
                        f.Add(new Fan("System Fan #4", 5));
                        f.Add(new Fan("Chipset Fan", 6));

                        c.Add(new Control("Pump Fan", 0));
                        c.Add(new Control("CPU Fan", 1));
                        c.Add(new Control("System Fan #1", 2));
                        c.Add(new Control("System Fan #2", 3));
                        c.Add(new Control("System Fan #3", 4));
                        c.Add(new Control("System Fan #4", 5));
                        c.Add(new Control("Chipset Fan", 6));

                        break;

                    case Model.Z390_GAMING_EDGE_AC: // NCT6797D
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9));
                        v.Add(new Voltage("+5V", 1, ri: 4, rf: 1));

                        t.Add(new Temperature("System", 2));
                        t.Add(new Temperature("MOS", 1));
                        t.Add(new Temperature("CPU Core", 0));
                        t.Add(new Temperature("M.2", 3));
                        t.Add(new Temperature("PCI-E", 4));
                        t.Add(new Temperature("CPU Socket", 5));

                        c.Add(new Control("Pump Fan", 0));
                        c.Add(new Control("CPU Fan", 1));
                        c.Add(new Control("System Fan #1", 5));
                        c.Add(new Control("System Fan #2", 2));
                        c.Add(new Control("System Fan #3", 4));
                        c.Add(new Control("System Fan #4", 3));
                        c.Add(new Control("System Fan #5", 6));

                        f.Add(new Fan("Pump Fan", 0));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("System Fan #1", 5));
                        f.Add(new Fan("System Fan #2", 2));
                        f.Add(new Fan("System Fan #3", 4));
                        f.Add(new Fan("System Fan #4", 3));
                        f.Add(new Fan("System Fan #5", 6));
                        break;

                    default:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("CPU Termination", 9));
                        v.Add(new Voltage("Voltage #11", 10, true));
                        v.Add(new Voltage("Voltage #12", 11, true));
                        v.Add(new Voltage("Voltage #13", 12, true));
                        v.Add(new Voltage("Voltage #14", 13, true));
                        v.Add(new Voltage("Voltage #15", 14, true));
                        t.Add(new Temperature("CPU Core", 0));
                        t.Add(new Temperature("Temperature #1", 1));
                        t.Add(new Temperature("Temperature #2", 2));
                        t.Add(new Temperature("Temperature #3", 3));
                        t.Add(new Temperature("Temperature #4", 4));
                        t.Add(new Temperature("Temperature #5", 5));
                        t.Add(new Temperature("Temperature #6", 6));

                        for (int i = 0; i < superIO.Fans.Length; i++)
                            f.Add(new Fan("Fan #" + (i + 1), i));

                        for (int i = 0; i < superIO.Controls.Length; i++)
                            c.Add(new Control("Fan #" + (i + 1), i));

                        break;
                }

                break;

            default:
                v.Add(new Voltage("Vcore", 0));
                v.Add(new Voltage("Voltage #2", 1, true));
                v.Add(new Voltage("AVCC", 2, 34, 34));
                v.Add(new Voltage("+3.3V", 3, 34, 34));
                v.Add(new Voltage("Voltage #5", 4, true));
                v.Add(new Voltage("Voltage #6", 5, true));
                v.Add(new Voltage("Voltage #7", 6, true));
                v.Add(new Voltage("+3V Standby", 7, 34, 34));
                v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                v.Add(new Voltage("CPU Termination", 9));
                v.Add(new Voltage("Voltage #11", 10, true));
                v.Add(new Voltage("Voltage #12", 11, true));
                v.Add(new Voltage("Voltage #13", 12, true));
                v.Add(new Voltage("Voltage #14", 13, true));
                v.Add(new Voltage("Voltage #15", 14, true));
                t.Add(new Temperature("CPU Core", 0));
                t.Add(new Temperature("Temperature #1", 1));
                t.Add(new Temperature("Temperature #2", 2));
                t.Add(new Temperature("Temperature #3", 3));
                t.Add(new Temperature("Temperature #4", 4));
                t.Add(new Temperature("Temperature #5", 5));
                t.Add(new Temperature("Temperature #6", 6));

                for (int i = 0; i < superIO.Fans.Length; i++)
                    f.Add(new Fan("Fan #" + (i + 1), i));

                for (int i = 0; i < superIO.Controls.Length; i++)
                    c.Add(new Control("Fan #" + (i + 1), i));

                break;
        }
    }

    private static void GetWinbondConfigurationEhf(Manufacturer manufacturer, Model model, IList<Voltage> v, IList<Temperature> t, IList<Fan> f, IList<Control> c)
    {
        switch (manufacturer)
        {
            case Manufacturer.ASRock:
                switch (model)
                {
                    case Model.AOD790GX_128M: // W83627EHF
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 4, 10, 10));
                        v.Add(new Voltage("+5V", 5, 20, 10));
                        v.Add(new Voltage("+12V", 6, 28, 5));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Motherboard", 2));
                        f.Add(new Fan("CPU Fan", 0));
                        f.Add(new Fan("Chassis Fan", 1));
                        c.Add(new Control("System Fan", 0));
                        c.Add(new Control("CPU Fan", 1));
                        c.Add(new Control("Auxiliary Fan", 2));

                        break;

                    default:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        v.Add(new Voltage("Voltage #10", 9, true));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Auxiliary", 1));
                        t.Add(new Temperature("System", 2));
                        f.Add(new Fan("System Fan", 0));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("Auxiliary Fan", 2));
                        f.Add(new Fan("CPU Fan #2", 3));
                        f.Add(new Fan("Auxiliary Fan #2", 4));
                        c.Add(new Control("System Fan", 0));
                        c.Add(new Control("CPU Fan", 1));
                        c.Add(new Control("Auxiliary Fan", 2));

                        break;
                }

                break;

            default:
                v.Add(new Voltage("Vcore", 0));
                v.Add(new Voltage("Voltage #2", 1, true));
                v.Add(new Voltage("AVCC", 2, 34, 34));
                v.Add(new Voltage("+3.3V", 3, 34, 34));
                v.Add(new Voltage("Voltage #5", 4, true));
                v.Add(new Voltage("Voltage #6", 5, true));
                v.Add(new Voltage("Voltage #7", 6, true));
                v.Add(new Voltage("+3V Standby", 7, 34, 34));
                v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                v.Add(new Voltage("Voltage #10", 9, true));
                t.Add(new Temperature("CPU", 0));
                t.Add(new Temperature("Auxiliary", 1));
                t.Add(new Temperature("System", 2));
                f.Add(new Fan("System Fan", 0));
                f.Add(new Fan("CPU Fan", 1));
                f.Add(new Fan("Auxiliary Fan", 2));
                f.Add(new Fan("CPU Fan #2", 3));
                f.Add(new Fan("Auxiliary Fan #2", 4));
                c.Add(new Control("System Fan", 0));
                c.Add(new Control("CPU Fan", 1));
                c.Add(new Control("Auxiliary Fan", 2));

                break;
        }
    }

    private static void GetWinbondConfigurationHg(Manufacturer manufacturer, Model model, IList<Voltage> v, IList<Temperature> t, IList<Fan> f, IList<Control> c)
    {
        switch (manufacturer)
        {
            case Manufacturer.ASRock:
                switch (model)
                {
                    case Model._880GMH_USB3: // W83627DHG-P
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+5V", 5, 15, 7.5f));
                        v.Add(new Voltage("+12V", 6, 56, 10));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Motherboard", 2));
                        f.Add(new Fan("Chassis Fan", 0));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("Power Fan", 2));
                        c.Add(new Control("System Fan", 0));
                        c.Add(new Control("CPU Fan", 1));
                        c.Add(new Control("Auxiliary Fan", 2));

                        break;

                    default:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Auxiliary", 1));
                        t.Add(new Temperature("System", 2));
                        f.Add(new Fan("System Fan", 0));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("Auxiliary Fan", 2));
                        f.Add(new Fan("CPU Fan #2", 3));
                        f.Add(new Fan("Auxiliary Fan #2", 4));
                        c.Add(new Control("System Fan", 0));
                        c.Add(new Control("CPU Fan", 1));
                        c.Add(new Control("Auxiliary Fan", 2));

                        break;
                }

                break;
            case Manufacturer.ASUS:
                switch (model)
                {
                    case Model.P6T: // W83667HG
                    case Model.P6X58D_E: // W83667HG
                    case Model.RAMPAGE_II_GENE: // W83667HG
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+12V", 1, 11.5f, 1.91f));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+5V", 4, 15, 7.5f));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Motherboard", 2));
                        f.Add(new Fan("Chassis Fan #1", 0));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("Power Fan", 2));
                        f.Add(new Fan("Chassis Fan #2", 3));
                        f.Add(new Fan("Chassis Fan #3", 4));
                        c.Add(new Control("System Fan", 0));
                        c.Add(new Control("CPU Fan", 1));
                        c.Add(new Control("Auxiliary Fan", 2));

                        break;

                    case Model.RAMPAGE_EXTREME: // W83667HG
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("+12V", 1, 12, 2));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("+5V", 4, 15, 7.5f));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Motherboard", 2));
                        f.Add(new Fan("Chassis Fan #1", 0));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("Power Fan", 2));
                        f.Add(new Fan("Chassis Fan #2", 3));
                        f.Add(new Fan("Chassis Fan #3", 4));
                        c.Add(new Control("System Fan", 0));
                        c.Add(new Control("CPU Fan", 1));
                        c.Add(new Control("Auxiliary Fan", 2));

                        break;

                    default:
                        v.Add(new Voltage("Vcore", 0));
                        v.Add(new Voltage("Voltage #2", 1, true));
                        v.Add(new Voltage("AVCC", 2, 34, 34));
                        v.Add(new Voltage("+3.3V", 3, 34, 34));
                        v.Add(new Voltage("Voltage #5", 4, true));
                        v.Add(new Voltage("Voltage #6", 5, true));
                        v.Add(new Voltage("Voltage #7", 6, true));
                        v.Add(new Voltage("+3V Standby", 7, 34, 34));
                        v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                        t.Add(new Temperature("CPU", 0));
                        t.Add(new Temperature("Auxiliary", 1));
                        t.Add(new Temperature("System", 2));
                        f.Add(new Fan("System Fan", 0));
                        f.Add(new Fan("CPU Fan", 1));
                        f.Add(new Fan("Auxiliary Fan", 2));
                        f.Add(new Fan("CPU Fan #2", 3));
                        f.Add(new Fan("Auxiliary Fan #2", 4));
                        c.Add(new Control("System Fan", 0));
                        c.Add(new Control("CPU Fan", 1));
                        c.Add(new Control("Auxiliary Fan", 2));

                        break;
                }

                break;

            default:
                v.Add(new Voltage("Vcore", 0));
                v.Add(new Voltage("Voltage #2", 1, true));
                v.Add(new Voltage("AVCC", 2, 34, 34));
                v.Add(new Voltage("+3.3V", 3, 34, 34));
                v.Add(new Voltage("Voltage #5", 4, true));
                v.Add(new Voltage("Voltage #6", 5, true));
                v.Add(new Voltage("Voltage #7", 6, true));
                v.Add(new Voltage("+3V Standby", 7, 34, 34));
                v.Add(new Voltage("CMOS Battery", 8, 34, 34));
                t.Add(new Temperature("CPU", 0));
                t.Add(new Temperature("Auxiliary", 1));
                t.Add(new Temperature("System", 2));
                f.Add(new Fan("System Fan", 0));
                f.Add(new Fan("CPU Fan", 1));
                f.Add(new Fan("Auxiliary Fan", 2));
                f.Add(new Fan("CPU Fan #2", 3));
                f.Add(new Fan("Auxiliary Fan #2", 4));
                c.Add(new Control("System Fan", 0));
                c.Add(new Control("CPU Fan", 1));
                c.Add(new Control("Auxiliary Fan", 2));

                break;
        }
    }

    public override string GetReport()
    {
        StringBuilder sb = new();
        sb.AppendLine(_superIO.GetReport());
        sb.AppendLine();
        sb.AppendLine("Temperature debug (SuperIO read):");

        try
        {
            // If there are named sensors created, iterate them; otherwise use superIO.Temperatures
            if (_temperatures != null && _temperatures.Count > 0)
            {
                foreach (Sensor s in _temperatures)
                {
                    int idx = s.Index;
                    float? v = _readTemperature != null ? _readTemperature(idx) : null;
                    sb.Append("  Index ").Append(idx).Append(" \"").Append(s.Name).Append("\": ");
                    sb.AppendLine(v.HasValue ? v.Value.ToString("F2", CultureInfo.InvariantCulture) : "null");
                }
            }
            else
            {
                // Fallback: dump raw superIO.Temperatures if available
                var temps = (_superIO?.Temperatures);
                if (temps != null)
                {
                    for (int i = 0; i < temps.Length; i++)
                    {
                        sb.Append("  Raw Index ").Append(i).Append(": ");
                        sb.AppendLine(temps[i].HasValue ? temps[i].Value.ToString("F2", CultureInfo.InvariantCulture) : "null");
                    }
                }
            }
        }
        catch (Exception ex)
        {
            sb.AppendLine("  Exception while reading temperatures: " + ex.Message);
        }

        return sb.ToString();
    }

    public override void Update()
    {
        _superIO.Update();

        foreach (Sensor sensor in _voltages)
        {
            float? value = _readVoltage(sensor.Index);
            if (value.HasValue)
            {
                sensor.Value = value + ((value - sensor.Parameters[2].Value) * sensor.Parameters[0].Value / sensor.Parameters[1].Value);
                ActivateSensor(sensor);
            }
        }

        foreach (Sensor sensor in _temperatures)
        {
            float? value = _readTemperature(sensor.Index);
            if (value.HasValue)
            {
                sensor.Value = value + sensor.Parameters[0].Value;
                ActivateSensor(sensor);
            }
            else
            {
                if (_motherboard.Model == Model.X570_MS7C35) // Add Temp Value for CPU MOS TEMPERATURE & PCH TEMPERATURE
                {
                    float voltage;

                    if (sensor.Index == 24)
                    {
                        voltage = (float)_readVoltage(6);
                    }
                    else if (sensor.Index == 25)
                    {
                        voltage = (float)_readVoltage(11);
                    }
                    else
                    {
                        voltage = 0;
                    }

                    double R = (10000.0 * voltage / (2.048 - 1.0));            //Convert voltage measured to resistance value
                    double T = ((298.15 * 3435.0) / ((298.15 * Math.Log(R / 10000.0)) + 3435.0));  // Use R value in steinhart and hart equation, calculate temperature value in kelvin
                    float Tc = (float)(T - 273.15);                            // Converting kelvin to celsius

                    sensor.Value = Tc + sensor.Parameters[0].Value;
                    ActivateSensor(sensor);
                }
            }
        }

        foreach (Sensor sensor in _fans)
        {
            float? value = _readFan(sensor.Index);
            if (value.HasValue)
            {
                sensor.Value = value;
                ActivateSensor(sensor);
            }
        }

        foreach (Sensor sensor in _controls)
        {
            sensor.Value = _readControl(sensor.Index);
        }

        _postUpdate();
    }

    public override void Close()
    {
        foreach (Sensor sensor in _controls)
        {
            // restore all controls back to default
            _superIO.SetControl(sensor.Index, null);
        }

        base.Close();
    }

    private delegate float? ReadValueDelegate(int index);

    private delegate void UpdateDelegate();
}

```

`LibreHardwareMonitorLib/Hardware/Motherboard/Temperature.cs`:

```cs
namespace LibreHardwareMonitor.Hardware.Motherboard;

internal class Temperature
{
    public readonly int Index;
    public readonly string Name;

    public Temperature(string name, int index)
    {
        Name = name;
        Index = index;
    }
}
```

`LibreHardwareMonitorLib/Hardware/Motherboard/Voltage.cs`:

```cs
namespace LibreHardwareMonitor.Hardware.Motherboard;

internal class Voltage
{
    public readonly bool Hidden;
    public readonly int Index;
    public readonly string Name;
    public readonly float Rf;
    public readonly float Ri;
    public readonly float Vf;

    public Voltage(string name, int index, bool hidden = false) : this(name, index, 0, 1, 0, hidden)
    { }

    public Voltage(string name, int index, float ri, float rf, float vf = 0, bool hidden = false)
    {
        Name = name;
        Index = index;
        Ri = ri;
        Rf = rf;
        Vf = vf;
        Hidden = hidden;
    }
}
```

`LibreHardwareMonitorLib/Hardware/Mutexes.cs`:

```cs
using System;
using System.Security.AccessControl;
using System.Security.Principal;
using System.Threading;

namespace LibreHardwareMonitor.Hardware;

internal static class Mutexes
{
    private static Mutex _ecMutex;
    private static Mutex _isaBusMutex;
    private static Mutex _pciBusMutex;
    private static Mutex _razerMutex;
    private static Mutex _usbSensors;

    /// <summary>
    /// Opens the mutexes.
    /// </summary>
    public static void Open()
    {
        _isaBusMutex = CreateOrOpenExistingMutex("Global\\Access_ISABUS.HTP.Method");
        _pciBusMutex = CreateOrOpenExistingMutex("Global\\Access_PCI");
        _ecMutex = CreateOrOpenExistingMutex("Global\\Access_EC");
        _razerMutex = CreateOrOpenExistingMutex("Global\\RazerReadWriteGuardMutex");
        _usbSensors = CreateOrOpenExistingMutex("Global\\Access_USB_Sensors");

        static Mutex CreateOrOpenExistingMutex(string name)
        {
            try
            {
                var worldRule = new MutexAccessRule(new SecurityIdentifier(WellKnownSidType.WorldSid, null), MutexRights.FullControl, AccessControlType.Allow);
                var mutexSecurity = new MutexSecurity();
                mutexSecurity.AddAccessRule(worldRule);

#if NETFRAMEWORK
                return new Mutex(false, name, out _, mutexSecurity);
#else
                return MutexAcl.Create(false, name, out _, mutexSecurity);
#endif
            }
            catch (UnauthorizedAccessException)
            {
                try
                {
                    return Mutex.OpenExisting(name);
                }
                catch
                {
                    // Ignored.
                }
            }

            return null;
        }
    }

    /// <summary>
    /// Closes the mutexes.
    /// </summary>
    public static void Close()
    {
        _isaBusMutex?.Close();
        _pciBusMutex?.Close();
        _ecMutex?.Close();
        _razerMutex?.Close();
        _usbSensors?.Close();
    }

    public static bool WaitIsaBus(int millisecondsTimeout)
    {
        return WaitMutex(_isaBusMutex, millisecondsTimeout);
    }

    public static void ReleaseIsaBus()
    {
        _isaBusMutex?.ReleaseMutex();
    }

    public static bool WaitPciBus(int millisecondsTimeout)
    {
        return WaitMutex(_pciBusMutex, millisecondsTimeout);
    }

    public static void ReleasePciBus()
    {
        _pciBusMutex?.ReleaseMutex();
    }

    public static bool WaitEc(int millisecondsTimeout)
    {
        return WaitMutex(_ecMutex, millisecondsTimeout);
    }

    public static void ReleaseEc()
    {
        _ecMutex?.ReleaseMutex();
    }

    public static bool WaitRazer(int millisecondsTimeout)
    {
        return WaitMutex(_razerMutex, millisecondsTimeout);
    }

    public static void ReleaseRazer()
    {
        _razerMutex?.ReleaseMutex();
    }

    public static bool WaitUsbSensors(int millisecondsTimeout)
    {
        return WaitMutex(_usbSensors, millisecondsTimeout);
    }

    public static void ReleaseUsbSensors()
    {
        _usbSensors?.ReleaseMutex();
    }

    private static bool WaitMutex(Mutex mutex, int millisecondsTimeout)
    {
        if (mutex == null)
            return true;

        try
        {
            return mutex.WaitOne(millisecondsTimeout, false);
        }
        catch (AbandonedMutexException)
        {
            return true;
        }
        catch (InvalidOperationException)
        {
            return false;
        }
    }
}

```

`LibreHardwareMonitorLib/Hardware/Network/Network.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Diagnostics;
using System.Net.NetworkInformation;

namespace LibreHardwareMonitor.Hardware.Network;

internal sealed class Network : Hardware
{
    private readonly Sensor _dataDownloaded;
    private readonly Sensor _dataUploaded;
    private readonly Sensor _downloadSpeed;
    private readonly Sensor _networkUtilization;
    private readonly Sensor _uploadSpeed;
    private long _bytesDownloaded;
    private long _bytesUploaded;
    private long _lastTick;

    public Network(NetworkInterface networkInterface, ISettings settings)
        : base(networkInterface.Name, new Identifier("nic", networkInterface.Id), settings)
    {
        NetworkInterface = networkInterface;
        _dataUploaded = new Sensor("Data Uploaded", 2, SensorType.Data, this, settings);
        ActivateSensor(_dataUploaded);
        _dataDownloaded = new Sensor("Data Downloaded", 3, SensorType.Data, this, settings);
        ActivateSensor(_dataDownloaded);
        _uploadSpeed = new Sensor("Upload Speed", 7, SensorType.Throughput, this, settings);
        ActivateSensor(_uploadSpeed);
        _downloadSpeed = new Sensor("Download Speed", 8, SensorType.Throughput, this, settings);
        ActivateSensor(_downloadSpeed);
        _networkUtilization = new Sensor("Network Utilization", 1, SensorType.Load, this, settings);
        ActivateSensor(_networkUtilization);
        _bytesUploaded = NetworkInterface.GetIPStatistics().BytesSent;
        _bytesDownloaded = NetworkInterface.GetIPStatistics().BytesReceived;
        _lastTick = Stopwatch.GetTimestamp();
    }

    public override HardwareType HardwareType
    {
        get { return HardwareType.Network; }
    }

    internal NetworkInterface NetworkInterface { get; private set; }

    public override void Update()
    {
        try
        {
            if (NetworkInterface == null)
                return;

            long newTick = Stopwatch.GetTimestamp();
            double dt = new TimeSpan(newTick - _lastTick).TotalSeconds;

            IPv4InterfaceStatistics interfaceStats = NetworkInterface.GetIPv4Statistics();

            // Report out the number of GB (2^30 Bytes) that this interface has up/downloaded. Note
            // that these values can reset back at zero (eg: after waking from sleep).
            _dataUploaded.Value = (float)(interfaceStats.BytesSent / (double)0x40000000);
            _dataDownloaded.Value = (float)(interfaceStats.BytesReceived / (double)0x40000000);

            // Detect a reset in interface stats if the new total is less than what was previously
            // seen. While setting the previous values to zero doesn't encapsulate the value the
            // instant before the reset, it is the best approximation we have.
            if (interfaceStats.BytesSent < _bytesUploaded || interfaceStats.BytesReceived < _bytesDownloaded)
            {
                _bytesUploaded = 0;
                _bytesDownloaded = 0;
            }

            long dBytesUploaded = interfaceStats.BytesSent - _bytesUploaded;
            long dBytesDownloaded = interfaceStats.BytesReceived - _bytesDownloaded;

            // Upload and download speeds are reported as the number of bytes transfered over the
            // time difference since the last report. In this way, the values represent the average
            // number of bytes up/downloaded in a second.
            _uploadSpeed.Value = (float)(dBytesUploaded / dt);
            _downloadSpeed.Value = (float)(dBytesDownloaded / dt);

            // Network speed is in bits per second, so when calculating the load on the NIC we first
            // grab the total number of bits up/downloaded
            long dbits = (dBytesUploaded + dBytesDownloaded) * 8;

            // Converts the ratio of total bits transferred over time over theoretical max bits
            // transfer rate into a percentage load
            double load = (dbits / dt / NetworkInterface.Speed) * 100;

            // Finally clamp the value between 0% and 100% to avoid reporting nonsensical numbers
            _networkUtilization.Value = (float)Math.Min(Math.Max(load, 0), 100);

            // Store the recorded values and time, so they can be used in the next update
            _bytesUploaded = interfaceStats.BytesSent;
            _bytesDownloaded = interfaceStats.BytesReceived;
            _lastTick = newTick;
        }
        catch (NetworkInformationException networkInformationException) when (unchecked(networkInformationException.HResult == (int)0x80004005))
        {
            foreach (NetworkInterface networkInterface in NetworkInterface.GetAllNetworkInterfaces())
            {
                if (networkInterface.Id.Equals(NetworkInterface?.Id))
                {
                    NetworkInterface = networkInterface;
                    break;
                }
            }
        }
    }
}
```

`LibreHardwareMonitorLib/Hardware/Network/NetworkGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.NetworkInformation;
using System.Text;

namespace LibreHardwareMonitor.Hardware.Network;

internal class NetworkGroup : IGroup, IHardwareChanged
{
    public event HardwareEventHandler HardwareAdded;
    public event HardwareEventHandler HardwareRemoved;

    private readonly object _updateLock = new();
    private readonly ISettings _settings;
    private List<Network> _hardware = [];

    public NetworkGroup(ISettings settings)
    {
        _settings = settings;
        UpdateNetworkInterfaces(settings);

        NetworkChange.NetworkAddressChanged += NetworkChange_NetworkAddressChanged;
        NetworkChange.NetworkAvailabilityChanged += NetworkChange_NetworkAddressChanged;
    }

    public IReadOnlyList<IHardware> Hardware => _hardware;

    public string GetReport()
    {
        var report = new StringBuilder();

        foreach (Network network in _hardware)
        {
            report.AppendLine(network.NetworkInterface.Description);
            report.AppendLine(network.NetworkInterface.OperationalStatus.ToString());
            report.AppendLine();

            foreach (ISensor sensor in network.Sensors)
            {
                report.AppendLine(sensor.Name);
                report.AppendLine(sensor.Value.ToString());
                report.AppendLine();
            }
        }

        return report.ToString();
    }

    public void Close()
    {
        NetworkChange.NetworkAddressChanged -= NetworkChange_NetworkAddressChanged;
        NetworkChange.NetworkAvailabilityChanged -= NetworkChange_NetworkAddressChanged;

        foreach (Network network in _hardware)
            network.Close();
    }

    private void UpdateNetworkInterfaces(ISettings settings)
    {
        // When multiple events fire concurrently, we don't want threads interfering
        // with others as they manipulate non-thread safe state.
        lock (_updateLock)
        {
            List<NetworkInterface> networkInterfaces = GetNetworkInterfaces();
            if (networkInterfaces == null)
                return;

            List<Network> removables = [];
            List<Network> additions = [];

            List<Network> hardware = [.. _hardware];

            // Remove network interfaces that no longer exist.
            for (int i = 0; i < hardware.Count; i++)
            {
                Network network = hardware[i];
                if (networkInterfaces.Any(x => x.Id == network.NetworkInterface.Id))
                    continue;

                hardware.RemoveAt(i--);
                removables.Add(network);
            }

            // Add new ones.
            foreach (NetworkInterface networkInterface in networkInterfaces)
            {
                if (hardware.All(x => x.NetworkInterface.Id != networkInterface.Id))
                {
                    Network network = new(networkInterface, settings);
                    hardware.Add(network);
                    additions.Add(network);
                }
            }

            _hardware = hardware;

            foreach (Network removable in removables)
                HardwareRemoved?.Invoke(removable);

            foreach (Network addition in additions)
                HardwareAdded?.Invoke(addition);
        }
    }

    private static List<NetworkInterface> GetNetworkInterfaces()
    {
        int retry = 0;

        while (retry++ < 5)
        {
            try
            {
                return NetworkInterface.GetAllNetworkInterfaces()
                                       .Where(IsDesiredNetworkType)
                                       .OrderBy(static x => x.Name)
                                       .ToList();
            }
            catch (NetworkInformationException)
            {
                // Disabling IPv4 while running can cause a NetworkInformationException: The pipe is being closed.
                // This can be retried.
            }
        }

        return null;
    }

    private void NetworkChange_NetworkAddressChanged(object sender, EventArgs e)
    {
        UpdateNetworkInterfaces(_settings);
    }

    private static bool IsDesiredNetworkType(NetworkInterface nic)
    {
        switch (nic.NetworkInterfaceType)
        {
            case NetworkInterfaceType.Loopback:
            case NetworkInterfaceType.Tunnel:
            case NetworkInterfaceType.Unknown:
                return false;
            default:
                return true;
        }
    }
}

```

`LibreHardwareMonitorLib/Hardware/OpCode.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Reflection;
using System.Runtime.InteropServices;
using Windows.Win32;
using Windows.Win32.System.Memory;

namespace LibreHardwareMonitor.Hardware;

internal static class OpCode
{
    public static CpuidDelegate CpuId;
    public static RdtscDelegate Rdtsc;

    private static IntPtr _codeBuffer;
    private static ulong _size;

    // void __stdcall cpuidex(unsigned int index, unsigned int ecxValue,
    //   unsigned int* eax, unsigned int* ebx, unsigned int* ecx,
    //   unsigned int* edx)
    // {
    //   int info[4];
    //   __cpuidex(info, index, ecxValue);
    //   *eax = info[0];
    //   *ebx = info[1];
    //   *ecx = info[2];
    //   *edx = info[3];
    // }

    private static readonly byte[] CpuId32 =
    [
        0x55, // push ebp
        0x8B,
        0xEC, // mov ebp, esp
        0x83,
        0xEC,
        0x10, // sub esp, 10h
        0x8B,
        0x45,
        0x08, // mov eax, dword ptr [ebp+8]
        0x8B,
        0x4D,
        0x0C, // mov ecx, dword ptr [ebp+0Ch]
        0x53, // push ebx
        0x0F,
        0xA2, // cpuid
        0x56, // push esi
        0x8D,
        0x75,
        0xF0, // lea esi, [info]
        0x89,
        0x06, // mov dword ptr [esi],eax
        0x8B,
        0x45,
        0x10, // mov eax, dword ptr [eax]
        0x89,
        0x5E,
        0x04, // mov dword ptr [esi+4], ebx
        0x89,
        0x4E,
        0x08, // mov dword ptr [esi+8], ecx
        0x89,
        0x56,
        0x0C, // mov dword ptr [esi+0Ch], edx
        0x8B,
        0x4D,
        0xF0, // mov ecx, dword ptr [info]
        0x89,
        0x08, // mov dword ptr [eax], ecx
        0x8B,
        0x45,
        0x14, // mov eax, dword ptr [ebx]
        0x8B,
        0x4D,
        0xF4, // mov ecx, dword ptr [ebp-0Ch]
        0x89,
        0x08, // mov dword ptr [eax], ecx
        0x8B,
        0x45,
        0x18, // mov eax, dword ptr [ecx]
        0x8B,
        0x4D,
        0xF8, // mov ecx, dword ptr [ebp-8]
        0x89,
        0x08, // mov dword ptr [eax], ecx
        0x8B,
        0x45,
        0x1C, // mov eax, dword ptr [edx]
        0x8B,
        0x4D,
        0xFC, // mov ecx, dword ptr [ebp-4]
        0x5E, // pop esi
        0x89,
        0x08, // mov dword ptr [eax], ecx
        0x5B, // pop ebx
        0xC9, // leave
        0xC2,
        0x18,
        0x00 // ret 18h
    ];

    private static readonly byte[] CpuId64Linux =
    [
        0x49,
        0x89,
        0xD2, // mov r10, rdx
        0x49,
        0x89,
        0xCB, // mov r11, rcx
        0x53, // push rbx
        0x89,
        0xF8, // mov eax, edi
        0x89,
        0xF1, // mov ecx, esi
        0x0F,
        0xA2, // cpuid
        0x41,
        0x89,
        0x02, // mov dword ptr [r10], eax
        0x41,
        0x89,
        0x1B, // mov dword ptr [r11], ebx
        0x41,
        0x89,
        0x08, // mov dword ptr [r8], ecx
        0x41,
        0x89,
        0x11, // mov dword ptr [r9], edx
        0x5B, // pop rbx
        0xC3 // ret
    ];

    private static readonly byte[] CpuId64Windows =
    [
        0x48,
        0x89,
        0x5C,
        0x24,
        0x08, // mov qword ptr [rsp+8], rbx
        0x8B,
        0xC1, // mov eax, ecx
        0x8B,
        0xCA, // mov ecx, edx
        0x0F,
        0xA2, // cpuid
        0x41,
        0x89,
        0x00, // mov dword ptr [r8], eax
        0x48,
        0x8B,
        0x44,
        0x24,
        0x28, // mov rax, qword ptr [rsp+28h]
        0x41,
        0x89,
        0x19, // mov dword ptr [r9], ebx
        0x48,
        0x8B,
        0x5C,
        0x24,
        0x08, // mov rbx, qword ptr [rsp+8]
        0x89,
        0x08, // mov dword ptr [rax], ecx
        0x48,
        0x8B,
        0x44,
        0x24,
        0x30, // mov rax, qword ptr [rsp+30h]
        0x89,
        0x10, // mov dword ptr [rax], edx
        0xC3 // ret
    ];

    // unsigned __int64 __stdcall rdtsc() {
    //   return __rdtsc();
    // }

    private static readonly byte[] Rdtsc32 =
    [
        0x0F,
        0x31, // rdtsc
        0xC3 // ret
    ];

    private static readonly byte[] Rdtsc64 =
    [
        0x0F,
        0x31, // rdtsc
        0x48,
        0xC1,
        0xE2,
        0x20, // shl rdx, 20h
        0x48,
        0x0B,
        0xC2, // or rax, rdx
        0xC3 // ret
    ];

    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    public delegate bool CpuidDelegate(uint index, uint ecxValue, out uint eax, out uint ebx, out uint ecx, out uint edx);

    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    public delegate ulong RdtscDelegate();

    public static unsafe void Open()
    {
        byte[] rdTscCode;
        byte[] cpuidCode;
        if (IntPtr.Size == 4)
        {
            rdTscCode = Rdtsc32;
            cpuidCode = CpuId32;
        }
        else
        {
            rdTscCode = Rdtsc64;
            cpuidCode = Software.OperatingSystem.IsUnix ? CpuId64Linux : CpuId64Windows;
        }

        _size = (ulong)(rdTscCode.Length + cpuidCode.Length);

        if (Software.OperatingSystem.IsUnix)
        {
#if NETFRAMEWORK
            Assembly assembly = Assembly.Load("Mono.Posix, Version=2.0.0.0, Culture=neutral, " + "PublicKeyToken=0738eb9f132ed756");
#else
            Assembly assembly = Assembly.Load("Mono.Posix.NETStandard, Version=1.0.0.0, Culture=neutral");
#endif

            Type sysCall = assembly.GetType("Mono.Unix.Native.Syscall");
            MethodInfo mmap = sysCall.GetMethod("mmap");

            Type mmapProts = assembly.GetType("Mono.Unix.Native.MmapProts");
            object mmapProtsParam = Enum.ToObject(mmapProts,
                                                  (int)mmapProts.GetField("PROT_READ").GetValue(null) |
                                                  (int)mmapProts.GetField("PROT_WRITE").GetValue(null) |
                                                  (int)mmapProts.GetField("PROT_EXEC").GetValue(null));

            Type mmapFlags = assembly.GetType("Mono.Unix.Native.MmapFlags");
            object mmapFlagsParam = Enum.ToObject(mmapFlags,
                                                  (int)mmapFlags.GetField("MAP_ANONYMOUS").GetValue(null) |
                                                  (int)mmapFlags.GetField("MAP_PRIVATE").GetValue(null));

            if (mmap != null)
                _codeBuffer = (IntPtr)mmap.Invoke(null, [IntPtr.Zero, _size, mmapProtsParam, mmapFlagsParam, -1, 0]);
        }
        else
        {
            _codeBuffer = (IntPtr)PInvoke.VirtualAlloc(null,
                                                       (UIntPtr)_size,
                                                       VIRTUAL_ALLOCATION_TYPE.MEM_COMMIT | VIRTUAL_ALLOCATION_TYPE.MEM_RESERVE,
                                                       PAGE_PROTECTION_FLAGS.PAGE_EXECUTE_READWRITE);
        }

        Marshal.Copy(rdTscCode, 0, _codeBuffer, rdTscCode.Length);
        Rdtsc = Marshal.GetDelegateForFunctionPointer(_codeBuffer, typeof(RdtscDelegate)) as RdtscDelegate;
        IntPtr cpuidAddress = (IntPtr)((long)_codeBuffer + rdTscCode.Length);
        Marshal.Copy(cpuidCode, 0, cpuidAddress, cpuidCode.Length);
        CpuId = Marshal.GetDelegateForFunctionPointer(cpuidAddress, typeof(CpuidDelegate)) as CpuidDelegate;
    }

    public static unsafe void Close()
    {
        Rdtsc = null;
        CpuId = null;

        if (Software.OperatingSystem.IsUnix)
        {
#if NETFRAMEWORK
            Assembly assembly = Assembly.Load("Mono.Posix, Version=2.0.0.0, Culture=neutral, " + "PublicKeyToken=0738eb9f132ed756");
#else
            Assembly assembly = Assembly.Load("Mono.Posix.NETStandard, Version=1.0.0.0, Culture=neutral");
#endif

            Type sysCall = assembly.GetType("Mono.Unix.Native.Syscall");
            MethodInfo method = sysCall.GetMethod("munmap");
            method?.Invoke(null, [_codeBuffer, _size]);
        }
        else
        {
            PInvoke.VirtualFree((void*)_codeBuffer, UIntPtr.Zero, VIRTUAL_FREE_TYPE.MEM_RELEASE);
        }
    }
}

```

`LibreHardwareMonitorLib/Hardware/Parameter.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Globalization;

namespace LibreHardwareMonitor.Hardware;

internal class Parameter : IParameter
{
    private readonly ISettings _settings;
    private readonly ParameterDescription _description;
    private bool _isDefault;
    private float _value;

    public Parameter(ParameterDescription description, ISensor sensor, ISettings settings)
    {
        Sensor = sensor;
        _description = description;
        _settings = settings;
        _isDefault = !settings.Contains(Identifier.ToString());
        _value = description.DefaultValue;
        if (!_isDefault && !float.TryParse(settings.GetValue(Identifier.ToString(), "0"), NumberStyles.Float, CultureInfo.InvariantCulture, out _value))
        {
            _value = description.DefaultValue;
        }
    }

    public float DefaultValue
    {
        get { return _description.DefaultValue; }
    }

    public string Description
    {
        get { return _description.Description; }
    }

    public Identifier Identifier
    {
        get { return new Identifier(Sensor.Identifier, "parameter", Name.Replace(" ", string.Empty).ToLowerInvariant()); }
    }

    public bool IsDefault
    {
        get { return _isDefault; }
        set
        {
            _isDefault = value;
            if (value)
            {
                _value = _description.DefaultValue;
                _settings.Remove(Identifier.ToString());
            }
        }
    }

    public string Name
    {
        get { return _description.Name; }
    }

    public ISensor Sensor { get; }

    public float Value
    {
        get { return _value; }
        set
        {
            _isDefault = false;
            _value = value;
            _settings.SetValue(Identifier.ToString(), value.ToString(CultureInfo.InvariantCulture));
        }
    }

    public void Accept(IVisitor visitor)
    {
        if (visitor == null)
            throw new ArgumentNullException(nameof(visitor));

        visitor.VisitParameter(this);
    }

    public void Traverse(IVisitor visitor)
    { }
}
```

`LibreHardwareMonitorLib/Hardware/ParameterDescription.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware;

/// <summary>
/// Composite class containing information about the selected <see cref="ISensor"/>.
/// </summary>
public struct ParameterDescription
{
    /// <summary>
    /// Creates a new instance and assigns values.
    /// </summary>
    /// <param name="name">Name of the selected component.</param>
    /// <param name="description">Description of the selected component.</param>
    /// <param name="defaultValue">Default value of the selected component.</param>
    public ParameterDescription(string name, string description, float defaultValue)
    {
        Name = name;
        Description = description;
        DefaultValue = defaultValue;
    }

    /// <summary>
    /// Gets a name of the parent <see cref="ISensor"/>.
    /// </summary>
    public string Name { get; }

    /// <summary>
    /// Gets a description of the parent <see cref="ISensor"/>.
    /// </summary>
    public string Description { get; }

    /// <summary>
    /// Gets a default value of the parent <see cref="ISensor"/>.
    /// </summary>
    public float DefaultValue { get; }
}
```

`LibreHardwareMonitorLib/Hardware/PowerMonitor/IPowerMonitor.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware.PowerMonitor;

internal interface IPowerMonitor
{
    //To be filled
}

```

`LibreHardwareMonitorLib/Hardware/PowerMonitor/PowerMonitorGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) Florian K. (Blacktempel)
// All Rights Reserved.

using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LibreHardwareMonitor.Hardware.PowerMonitor;

internal class PowerMonitorGroup : IGroup
{
    private readonly List<IHardware> _hardware = new();
    private readonly StringBuilder _report = new();

    public PowerMonitorGroup(ISettings settings)
    {
        _report.AppendLine("Power Monitors:");
        _report.AppendLine();

        var devices = WireViewPro2.TryFindDevices(settings);

        devices.ForEach(wvp2 =>
        {
            if (wvp2.IsConnected)
            {
                _report.AppendLine($"Power Monitor for '{wvp2.Name}' initialized successfully");

                _hardware.Add(wvp2);
            }
        });
    }

    public IReadOnlyList<IHardware> Hardware => _hardware;

    public void Close()
    {
        foreach (Hardware hw in _hardware.OfType<Hardware>())
        {
            hw.Close();
        }
    }

    public string GetReport()
    {
        var sb = new StringBuilder();
        sb.AppendLine(_report.ToString());

        _hardware.ForEach(hw => sb.AppendLine(hw.GetReport()));

        return sb.ToString();
    }
}

```

`LibreHardwareMonitorLib/Hardware/PowerMonitor/SharedSerialPort.cs`:

```cs
using System.IO.Ports;

namespace LibreHardwareMonitor.Hardware.PowerMonitor;

internal sealed class SharedSerialPort : SerialPort
{
    private bool _hasMutex;

    public SharedSerialPort()
    { }

    public SharedSerialPort(string portName) : base(portName)
    { }

    public SharedSerialPort(string portName, int baudRate) : base(portName, baudRate)
    { }

    public SharedSerialPort(string portName, int baudRate, Parity parity) : base(portName, baudRate, parity)
    { }

    public SharedSerialPort(string portName, int baudRate, Parity parity, int dataBits)
        : base(portName, baudRate, parity, dataBits)
    { }

    public SharedSerialPort(string portName, int baudRate, Parity parity, int dataBits, StopBits stopBits)
        : base(portName, baudRate, parity, dataBits, stopBits)
    { }

    private int MutexTimeout { get; set; } = 500;

    public new void Open()
    {
        _hasMutex = Mutexes.WaitUsbSensors(MutexTimeout);
        if (_hasMutex)
        {
            base.Open();
        }
    }

    public new void Close()
    {
        if (_hasMutex)
        {
            if (IsOpen)
            {
                BaseStream.Flush();
                BaseStream.Close();
            }

            _hasMutex = false;
            Mutexes.ReleaseUsbSensors();
        }
    }

    public new void Write(byte[] buffer, int offset, int count)
    {
        if (_hasMutex)
        {
            base.Write(buffer, offset, count);
        }
    }

    public new int Read(byte[] buffer, int offset, int count)
    {
        if (_hasMutex)
        {
            return base.Read(buffer, offset, count);
        }

        return 0;
    }

    public new void DiscardInBuffer()
    {
        if (_hasMutex)
        {
            base.DiscardInBuffer();
        }
    }

    public new void DiscardOutBuffer()
    {
        if (_hasMutex)
        {
            base.DiscardOutBuffer();
        }
    }
}

```

`LibreHardwareMonitorLib/Hardware/PowerMonitor/WireViewPro2.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) Florian K. (Blacktempel)
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.IO.Ports;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using LibreHardwareMonitor.Interop.PowerMonitor;

namespace LibreHardwareMonitor.Hardware.PowerMonitor;

/// <summary>
/// Thermal Grizzly WireView Pro II power monitor.
/// </summary>
public sealed class WireViewPro2 : Hardware, IPowerMonitor
{
    public const string WelcomeMessage = "Thermal Grizzly WireView Pro II";

    /// <summary>
    /// Max RPM according to the8auer. This is a custom made fan.
    /// </summary>
    private const int MaxFanRPM = 5000;

    private const byte VendorID = 0xEF;
    private const byte ProductID = 0x05;

    /// <summary>
    /// Time the fan needs to ramp up by 10%.
    /// </summary>
    private static readonly TimeSpan FanRampupTime = TimeSpan.FromSeconds(3.5);

    private double _lastFanSpeedRpm;
    private DateTime _lastFanUpdateTime = DateTime.MinValue;

    private readonly int _baudRate;
    private readonly string _portName;
    private readonly List<WireViewPro2Sensor> _sensors = [];

    private SharedSerialPort _serialPort;

    public WireViewPro2(string portName, ISettings settings, int baud = 115200)
        : base("WireView Pro II", new Identifier("gpu-powermonitor", portName), settings)
    {
        _portName = portName;
        _baudRate = baud;

        Connect();

        if (IsConnected)
        {
            CreateSensors();
        }
    }

    public override HardwareType HardwareType => HardwareType.PowerMonitor;

    public bool IsConnected { get; private set; }

    public string UniqueID { get; private set; }

    public VendorDataStruct? VendorData { get; private set; }

    public int ConfigVersion => VendorData?.FwVersion > 2 ? 1 : 0;

    public static List<WireViewPro2> TryFindDevices(ISettings settings)
    {
        var devices = new List<WireViewPro2>();

        if (!Software.OperatingSystem.IsWindows8OrGreater)
        {
            return devices; //No Linux implementation yet
        }

        List<string> matches = Stm32PortFinder.FindMatchingComPorts(0x0483, 0x5740);

        WireViewPro2 wireViewPro2 = null;

        foreach (string port in matches)
        {
            try
            {
                wireViewPro2 = new WireViewPro2(port, settings);
                if (wireViewPro2.IsConnected)
                {
                    devices.Add(wireViewPro2);
                    continue;
                }

                wireViewPro2.Close();
                wireViewPro2 = null;
            }
            catch
            {
                wireViewPro2?.Close();
                wireViewPro2 = null;
            }
        }

        return devices;
    }

    public override string GetReport()
    {
        var sb = new StringBuilder();
        sb.AppendLine(Name);

        foreach (WireViewPro2Sensor sensor in _sensors)
        {
            sb.AppendLine($"  Sensor: {sensor.Name} = {sensor.Value}");
        }

        if (VendorData.HasValue)
        {
            sb.AppendLine($"  {nameof(VendorData.Value.VendorId)} = {VendorData.Value.VendorId}");
            sb.AppendLine($"  {nameof(VendorData.Value.ProductId)} = {VendorData.Value.ProductId}");
            sb.AppendLine($"  {nameof(VendorData.Value.FwVersion)} = {VendorData.Value.FwVersion}");
        }

        sb.AppendLine($"  {nameof(UniqueID)} = {UniqueID}");

        return sb.ToString();
    }

    public override void Close()
    {
        Disconnect();

        base.Close();
    }

    public override void Update()
    {
        var deviceData = GetDeviceData();

        if (deviceData != null)
        {
            _sensors.ForEach(wvps => wvps.Update(deviceData));
        }
    }

    public DeviceData GetDeviceData()
    {
        SensorStruct? sensorValues = null;
        DeviceConfigStructV2? config = null;

        try
        {
            sensorValues = ReadSensorValues();

            config = ReadConfig();
        }
        catch (IOException)
        {
            //"A device attached to the system is not functioning."
            //Can happen rarely
        }
        catch (InvalidOperationException)
        {
            //Can happen sometimes if the device is disconnecting while reading
        }

        if (sensorValues.HasValue && config.HasValue)
        {
            return MapSensorStructure(sensorValues.Value, config.Value);
        }

        return null;
    }

    public DeviceConfigStructV2? ReadConfig()
    {
        if (!IsConnected)
        {
            return null;
        }

        int size = 0;

        switch (ConfigVersion)
        {
            case 0:
                size = Marshal.SizeOf<DeviceConfigStructV1>();
                break;
            case 1:
                size = Marshal.SizeOf<DeviceConfigStructV2>();
                break;
            default:
                return null;
        }

        var buf = SendCmd(UsbCmd.CMD_READ_CONFIG, size);

        if (buf == null)
        {
            return null;
        }

        switch (ConfigVersion)
        {
            case 0:
                var s = BytesToStructure<DeviceConfigStructV1>(buf);
                return StructureConversion.ConvertConfigV1ToV2(s);
            case 1:
                return BytesToStructure<DeviceConfigStructV2>(buf);
            default:
                return null;
        }
    }

    public void WriteConfig(DeviceConfigStructV2 config)
    {
        if (!IsConnected)
        {
            return;
        }

        byte[] payload = [];

        switch (ConfigVersion)
        {
            case 0:
                var s = StructureConversion.ConvertConfigV2ToV1(config);
                payload = StructureToBytes(s);
                break;
            case 1:
                payload = StructureToBytes(config);
                break;
            default:
                return;
        }

        byte[] frame = new byte[64];
        frame[0] = (byte)UsbCmd.CMD_WRITE_CONFIG;

        try
        {
            _serialPort.Open();
            _serialPort.DiscardInBuffer();

            const int maxPayloadPerFrame = 62;

            for (byte offset = 0; offset < payload.Length; offset += maxPayloadPerFrame)
            {
                int bytesToWrite = Math.Min(maxPayloadPerFrame, payload.Length - offset);

                frame[1] = offset;
                Buffer.BlockCopy(payload, offset, frame, 2, bytesToWrite);

                _serialPort.Write(frame, 0, bytesToWrite + 2);
            }
        }
        finally
        {
            _serialPort.Close();
        }
    }

    public void NonVolatileMemoryCommand(NVM_CMD cmd)
    {
        if (!IsConnected)
        {
            return;
        }

        SendData(
            [
                (byte)UsbCmd.CMD_NVM_CONFIG,
                0x55, //Magic
                0xAA, //Magic
                0x55, //Magic
                0xAA, //Magic
                (byte)cmd
            ]);
    }

    public void ScreenCmd(SCREEN_CMD cmd)
    {
        if (!IsConnected)
        {
            return;
        }

        SendData([(byte)UsbCmd.CMD_SCREEN_CHANGE, (byte)cmd]);
    }

    public void ClearFaults(int faultStatusMask = 0xFFFF, int faultLogMask = 0xFFFF)
    {
        if (!IsConnected)
        {
            return;
        }

        SendData(
            [
                (byte)UsbCmd.CMD_CLEAR_FAULTS,
                (byte)(faultStatusMask & 0xFF),
                (byte)((faultStatusMask >> 8) & 0xFF),
                (byte)(faultLogMask & 0xFF),
                (byte)((faultLogMask >> 8) & 0xFF)
            ]);
    }

    private void CreateSensors()
    {
        //Onboard temperature sensors
        AddSensor("Onboard Temperature In", 0, SensorType.Temperature, dd => (float)dd.OnboardTempInC);
        AddSensor("Onboard Temperature Out", 1, SensorType.Temperature, dd => (float)dd.OnboardTempOutC);

        //External temperature sensors, requires shipped temperature sensors to be connected
        AddSensor("External Temperature 1", 2, SensorType.Temperature, dd => (float)dd.ExternalTemp1C);
        AddSensor("External Temperature 2", 3, SensorType.Temperature, dd => (float)dd.ExternalTemp2C);

        //Pin voltages
        AddSensor("Pin 1 Voltage", 10, SensorType.Voltage, dd => (float)dd.PinVoltage[0]);
        AddSensor("Pin 2 Voltage", 11, SensorType.Voltage, dd => (float)dd.PinVoltage[1]);
        AddSensor("Pin 3 Voltage", 12, SensorType.Voltage, dd => (float)dd.PinVoltage[2]);
        AddSensor("Pin 4 Voltage", 13, SensorType.Voltage, dd => (float)dd.PinVoltage[3]);
        AddSensor("Pin 5 Voltage", 14, SensorType.Voltage, dd => (float)dd.PinVoltage[4]);
        AddSensor("Pin 6 Voltage", 15, SensorType.Voltage, dd => (float)dd.PinVoltage[5]);

        //Pin currents
        AddSensor("Total Current", 20, SensorType.Current, dd => (float)dd.SumCurrentA);
        AddSensor("Pin 1 Current", 21, SensorType.Current, dd => (float)dd.PinCurrent[0]);
        AddSensor("Pin 2 Current", 22, SensorType.Current, dd => (float)dd.PinCurrent[1]);
        AddSensor("Pin 3 Current", 23, SensorType.Current, dd => (float)dd.PinCurrent[2]);
        AddSensor("Pin 4 Current", 24, SensorType.Current, dd => (float)dd.PinCurrent[3]);
        AddSensor("Pin 5 Current", 25, SensorType.Current, dd => (float)dd.PinCurrent[4]);
        AddSensor("Pin 6 Current", 26, SensorType.Current, dd => (float)dd.PinCurrent[5]);

        //Power
        AddSensor("Total Power", 30, SensorType.Power, dd => (float)dd.SumPowerW);

        //Fan
        var fan = AddSensor("Fan", 40, SensorType.Fan, CalculateFanSpeed);
        var ctrl = new Control(fan, _settings, 0, 100);

        fan.Control = ctrl;
        ctrl.ControlModeChanged += OnFanControlModeChanged;
        ctrl.SoftwareControlValueChanged += OnSoftwareControlValueChanged;

        //Control
        var fanControl = AddSensor($"{Name} ({_portName})", 50, SensorType.Control, GetFanSpeedInPercent);
        fanControl.Control = ctrl;
    }

    private WireViewPro2Sensor AddSensor(string name, int index, SensorType sensorType, GetWireViewPro2SensorValue getValue)
    {
        var sensor = new WireViewPro2Sensor(name, index, sensorType, this, _settings, getValue);

        _sensors.Add(sensor);

        ActivateSensor(sensor);

        return sensor;
    }

    private double FromTemp(short temp)
    {
        return temp == 0 ? 0 : temp / 10.0;
    }

    private short ToTemp(double temp)
    {
        return (short)(temp * 10);
    }

    private void OnFanControlModeChanged(Control control)
    {
        var deviceData = GetDeviceData();

        if (deviceData == null)
        {
            return;
        }

        switch (control.ControlMode)
        {
            case ControlMode.Software:
                deviceData.Config.FanConfig.Mode = FanMode.FanModeFixed;
                break;
            case ControlMode.Default:
                //Set default values of TG Software
                deviceData.Config.FanConfig.Mode = FanMode.FanModeCurve;
                deviceData.Config.FanConfig.TempSource = TempSource.TempSourceTmax;

                deviceData.Config.FanConfig.TempMin = ToTemp(50);
                deviceData.Config.FanConfig.TempMax = ToTemp(80);

                deviceData.Config.FanConfig.DutyMin = 0;
                deviceData.Config.FanConfig.DutyMax = 100;
                break;
            default:
                break;
        }

        WriteConfig(deviceData.Config);
    }

    private void OnSoftwareControlValueChanged(Control control)
    {
        var deviceData = GetDeviceData();

        if (deviceData == null)
        {
            return;
        }

        byte value = (byte)control.SoftwareValue;

        if (value < 0)
        {
            value = 0;
        }
        else if (value > 100)
        {
            value = 100;
        }

        deviceData.Config.FanConfig.TempMin = ToTemp(0);
        deviceData.Config.FanConfig.TempMax = ToTemp(80);

        deviceData.Config.FanConfig.DutyMin = value;
        deviceData.Config.FanConfig.DutyMax = value;

        WriteConfig(deviceData.Config);
    }

    private float GetFanSpeedInPercent(DeviceData dd)
    {
        var fanConfig = dd.Config.FanConfig;
        float fanSpeedInPercent;

        switch (fanConfig.Mode)
        {
            case FanMode.FanModeCurve:
                var tempMin = FromTemp(fanConfig.TempMin);
                var tempMax = FromTemp(fanConfig.TempMax);
                var currentTemperature = GetActiveTemperature(dd);

                if (tempMax <= tempMin || currentTemperature <= tempMin)
                {
                    fanSpeedInPercent = fanConfig.DutyMin;
                }
                else if (currentTemperature >= tempMax)
                {
                    fanSpeedInPercent = fanConfig.DutyMax;
                }
                else
                {
                    var temp = (currentTemperature - tempMin) / (tempMax - tempMin);
                    fanSpeedInPercent = (float)(fanConfig.DutyMin + temp * (fanConfig.DutyMax - fanConfig.DutyMin));
                }
                break;
            case FanMode.FanModeFixed:
                fanSpeedInPercent = fanConfig.DutyMin;
                break;
            default:
                return -1;
        }

        return fanSpeedInPercent;
    }

    /// <summary>
    /// Fan speed for this device is an approximation based on the curve configuration and current temperatures.<br/>
    /// The device itself does not report actual fan speed.
    /// </summary>
    private float CalculateFanSpeed(DeviceData dd)
    {
        var fanConfig = dd.Config.FanConfig;
        double targetRpm;

        var fanSpeedInPercent = GetFanSpeedInPercent(dd);

        switch (fanConfig.Mode)
        {
            case FanMode.FanModeCurve:
            case FanMode.FanModeFixed:
                targetRpm = fanSpeedInPercent == 0 ? 0 : fanSpeedInPercent / 100.0f * MaxFanRPM;
                break;
            default:
                return -1;
        }

        return (float)ApplyFanRamp(targetRpm);
    }

    private double ApplyFanRamp(double targetRpm)
    {
        var now = DateTime.UtcNow;

        if (_lastFanUpdateTime == DateTime.MinValue)
        {
            _lastFanSpeedRpm = targetRpm;
            _lastFanUpdateTime = now;
            return targetRpm;
        }

        var elapsed = now - _lastFanUpdateTime;

        if (elapsed <= TimeSpan.Zero)
        {
            return _lastFanSpeedRpm;
        }

        var maxPercentDeltaPerSecond = 0.1 / FanRampupTime.TotalSeconds; //10% per FanRampupTime
        var allowedPercentDelta = elapsed.TotalSeconds * maxPercentDeltaPerSecond;

        var rpmDelta = targetRpm - _lastFanSpeedRpm;
        var percentDelta = rpmDelta / MaxFanRPM;

        if (Math.Abs(percentDelta) > allowedPercentDelta)
        {
            rpmDelta = Math.Sign(percentDelta) * allowedPercentDelta * MaxFanRPM;
        }

        _lastFanSpeedRpm += rpmDelta;
        _lastFanUpdateTime = now;

        return _lastFanSpeedRpm;
    }

    private double GetActiveTemperature(DeviceData dd)
    {
        double temperature = 0;

        switch (dd.Config.FanConfig.TempSource)
        {
            case TempSource.TempSourceTsIn:
                temperature = dd.OnboardTempInC;
                break;
            case TempSource.TempSourceTsOut:
                temperature = dd.OnboardTempOutC;
                break;
            case TempSource.TempSourceTs1:
                temperature = dd.ExternalTemp1C;
                break;
            case TempSource.TempSourceTs2:
                temperature = dd.ExternalTemp2C;
                break;
            case TempSource.TempSourceTmax:
                temperature = Math.Max(
                    Math.Max(dd.OnboardTempInC, dd.OnboardTempOutC),
                    Math.Max(dd.ExternalTemp1C, dd.ExternalTemp2C));
                break;
            default:
                break;
        }

        return temperature;
    }

    private void Connect()
    {
        if (IsConnected)
        {
            return;
        }

        try
        {
            _serialPort = new SharedSerialPort(_portName, _baudRate, Parity.None, 8, StopBits.One);
            _serialPort.ReadTimeout = 1000;
            _serialPort.WriteTimeout = 1000;

            if (!ReadWelcomeMessage())
            {
                IsConnected = false;
                return;
            }

            VendorDataStruct? vendorData = ReadVendorData();

            if (vendorData.HasValue &&
                vendorData.Value.VendorId == VendorID &&
                vendorData.Value.ProductId == ProductID)
            {
                VendorData = vendorData.Value;
                UniqueID = ReadUniqueID();

                IsConnected = true;
            }
        }
        catch
        {
            if (_serialPort != null)
            {
                try
                {
                    if (_serialPort.IsOpen)
                    {
                        _serialPort.Close();
                    }
                }
                catch
                {
                    //Ignore exceptions during cleanup
                }
                finally
                {
                    _serialPort.Dispose();
                    _serialPort = null;
                }
            }

            IsConnected = false;
        }
    }

    private void Disconnect()
    {
        if (!IsConnected)
        {
            return;
        }

        if (_serialPort != null)
        {
            _serialPort.Close();
            _serialPort.Dispose();
            _serialPort = null;
        }

        IsConnected = false;

        VendorData = null;
        UniqueID = null;
    }

    private bool ReadWelcomeMessage(bool sendCmd = false)
    {
        int size = WelcomeMessage.Length + 1;

        var bytes = SendData([(byte)UsbCmd.CMD_WELCOME], size, true);

        return bytes == null ? false : Encoding.ASCII.GetString(bytes, 0, size).TrimEnd('\0').CompareTo(WelcomeMessage) == 0;
    }

    private VendorDataStruct? ReadVendorData()
    {
        var bytes = SendCmd(UsbCmd.CMD_READ_VENDOR_DATA, Marshal.SizeOf<VendorDataStruct>());

        return bytes == null ? null : BytesToStructure<VendorDataStruct>(bytes);
    }

    private string ReadUniqueID()
    {
        const int UIDBytes = 12;

        var bytes = SendCmd(UsbCmd.CMD_READ_UID, UIDBytes);

        return bytes == null ? null : BitConverter.ToString(bytes).Replace("-", string.Empty);
    }

    private SensorStruct? ReadSensorValues()
    {
        if (!IsConnected)
        {
            return null;
        }

        var bytes = SendCmd(UsbCmd.CMD_READ_SENSOR_VALUES, Marshal.SizeOf<SensorStruct>());

        return bytes == null ? null : BytesToStructure<SensorStruct>(bytes);
    }

    private DeviceData MapSensorStructure(SensorStruct sensorStruct, DeviceConfigStructV2 config)
    {
        var deviceData = new DeviceData
        {
            Connected = true,
            HardwareRevision = $"{VendorData?.VendorId}{VendorData?.ProductId}",
            FirmwareVersion = $"{VendorData?.FwVersion}",
            OnboardTempInC = sensorStruct.Ts[(int)SensorTs.SENSOR_TS_IN] / 10.0,
            OnboardTempOutC = sensorStruct.Ts[(int)SensorTs.SENSOR_TS_OUT] / 10.0,
            ExternalTemp1C = sensorStruct.Ts[(int)SensorTs.SENSOR_TS3] / 10.0,
            ExternalTemp2C = sensorStruct.Ts[(int)SensorTs.SENSOR_TS4] / 10.0,
            FaultStatus = sensorStruct.FaultStatus,
            FaultLog = sensorStruct.FaultLog,
            Config = config,
        };

        switch (sensorStruct.HpwrCapability)
        {
            case HpwrCapability.PSU_CAP_600W:
                deviceData.PsuCapabilityW = 600;
                break;
            case HpwrCapability.PSU_CAP_450W:
                deviceData.PsuCapabilityW = 450;
                break;
            case HpwrCapability.PSU_CAP_300W:
                deviceData.PsuCapabilityW = 300;
                break;
            case HpwrCapability.PSU_CAP_150W:
                deviceData.PsuCapabilityW = 150;
                break;
        }

        for (int i = 0; i < 6; ++i)
        {
            deviceData.PinVoltage[i] = sensorStruct.PowerReadings[i].Voltage / 1000.0;
            deviceData.PinCurrent[i] = sensorStruct.PowerReadings[i].Current / 1000.0;
        }

        return deviceData;
    }

    private byte[] SendCmd(UsbCmd cmd, int responseSize = 0, bool rts = false)
    {
        return SendData(new[] { (byte)cmd }, responseSize, rts);
    }

    private byte[] SendData(byte[] data, int responseSize = 0, bool rts = false)
    {
        if (_serialPort == null)
        {
            return null;
        }

        byte[] buf = null;

        try
        {
            lock (_serialPort)
            {
                _serialPort.Open();
                _serialPort.DiscardInBuffer();

                if (rts)
                {
                    _serialPort.RtsEnable = true;
                    Thread.Sleep(10);
                }

                _serialPort.Write(data, 0, data.Length);

                if (responseSize > 0)
                {
                    buf = ReadExact(responseSize);
                }

                if (rts)
                {
                    Thread.Sleep(10);
                    _serialPort.RtsEnable = false;
                }
            }
        }
        finally
        {
            _serialPort.Close();
        }

        return buf;
    }

    private byte[] ReadExact(int size)
    {
        byte[] buffer = new byte[size];

        int offset = 0;

        var sw = Stopwatch.StartNew();

        while (offset < size && sw.ElapsedMilliseconds < _serialPort.ReadTimeout)
        {
            try
            {
                if (_serialPort.BytesToRead > 0)
                {
                    offset += _serialPort.Read(buffer, offset, size - offset);
                }
            }
            catch (TimeoutException)
            {
                //Ignore timeout exceptions and continue reading
            }
        }

        return offset != size ? null : buffer;
    }

    private T BytesToStructure<T>(byte[] bytes) where T : struct
    {
        var handle = GCHandle.Alloc(bytes, GCHandleType.Pinned);

        try
        {
            return Marshal.PtrToStructure<T>(handle.AddrOfPinnedObject());
        }
        finally
        {
            handle.Free();
        }
    }

    private byte[] StructureToBytes<T>(T value) where T : struct
    {
        int size = Marshal.SizeOf<T>();

        byte[] bytes = new byte[size];
        IntPtr ptr = Marshal.AllocHGlobal(size);

        try
        {
            Marshal.StructureToPtr(value, ptr, false);
            Marshal.Copy(ptr, bytes, 0, size);
            return bytes;
        }
        finally
        {
            Marshal.FreeHGlobal(ptr);
        }
    }
}

```

`LibreHardwareMonitorLib/Hardware/PowerMonitor/WireViewPro2Sensor.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using LibreHardwareMonitor.Interop.PowerMonitor;

namespace LibreHardwareMonitor.Hardware.PowerMonitor;

internal delegate float GetWireViewPro2SensorValue(DeviceData wvp);

internal class WireViewPro2Sensor : Sensor
{
    readonly GetWireViewPro2SensorValue _getValue;

    public WireViewPro2Sensor(string name, int index, SensorType sensorType, Hardware hardware, ISettings settings, GetWireViewPro2SensorValue getValue)
        : base(name, index, sensorType, hardware, settings)
    {
        _getValue = getValue;
    }

    internal void Update(DeviceData wvp)
    {
        float value = _getValue(wvp);

        Value = value;
    }
}

```

`LibreHardwareMonitorLib/Hardware/Psu/Corsair/CorsairPsu.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) 2020 Wilken Gottwalt<wilken.gottwalt@posteo.net>
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.
// Implemented after the Linux kernel driver corsair_psu by Wilken Gottwalt and contributers

using System.Collections.Generic;
using System.Globalization;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Psu.Corsair;

internal sealed class CorsairPsu : Hardware
{
    private readonly List<CompositeSensor> _compositeSensors = [];
    private readonly HidDevice _device;
    private readonly List<PsuSensor> _sensors = [];

    public CorsairPsu(HidDevice device, ISettings settings, int index)
        : base("Corsair PSU", new Identifier("psu", "corsair", index.ToString()), settings)
    {
        _device = device;
        using HidStream stream = device.Open();

        UsbApi.Init(stream);
        UsbApi.FirmwareInfo fwInfo = UsbApi.FwInfo(stream);
        Name = $"{CultureInfo.InvariantCulture.TextInfo.ToTitleCase(fwInfo.Vendor.ToLowerInvariant())} {fwInfo.Product}";

        AddSensors(UsbApi.GetOptionalCommands(stream), UsbApi.GetCriticals(stream), settings);
    }

    public override HardwareType HardwareType => HardwareType.Psu;

    public override IDictionary<string, string> Properties
    {
        get
        {
            SortedDictionary<string, string> properties = new();

            using HidStream stream = _device.Open();

            float? mode = UsbApi.GetValue(stream, UsbApi.Command.OCPMODE, 0);
            if (mode.HasValue)
                properties.Add("Over-current protection", mode > 1.0 ? "multi-rail" : "single-rail");

            return properties;
        }
    }

    public override void Update()
    {
        using HidStream stream = _device.Open();
        _sensors.ForEach(s => s.Update(stream));
    }

    private void AddSensors(UsbApi.OptionalCommands optionalCommands, UsbApi.Criticals criticals, ISettings settings)
    {
        int sensorIndex = 0;

        _sensors.Add(new PsuSensorWithLimits("VRM",
                                             sensorIndex++,
                                             SensorType.Temperature,
                                             this,
                                             settings,
                                             UsbApi.Command.TEMP0,
                                             null,
                                             criticals.TempMax[0]));

        _sensors.Add(new PsuSensorWithLimits("Case",
                                             sensorIndex++,
                                             SensorType.Temperature,
                                             this,
                                             settings,
                                             UsbApi.Command.TEMP1,
                                             null,
                                             criticals.TempMax[1]));

        _sensors.Add(new PsuSensor("Case", sensorIndex++, SensorType.Fan, this, settings, UsbApi.Command.FAN_RPM));

        _sensors.Add(new PsuSensor("Input", sensorIndex++, SensorType.Voltage, this, settings, UsbApi.Command.IN_VOLTS));
        _sensors.Add(new PsuSensorWithLimits("+12V",
                                             sensorIndex++,
                                             SensorType.Voltage,
                                             this,
                                             settings,
                                             UsbApi.Command.RAIL_VOLTS,
                                             criticals.VoltageMin[(byte)Rail._12V],
                                             criticals.VoltageMax[(byte)Rail._12V]));

        _sensors.Add(new PsuSensorWithLimits("+5V",
                                             sensorIndex++,
                                             SensorType.Voltage,
                                             this,
                                             settings,
                                             UsbApi.Command.RAIL_VOLTS,
                                             criticals.VoltageMin[(byte)Rail._5V],
                                             criticals.VoltageMax[(byte)Rail._5V],
                                             Rail._5V));

        _sensors.Add(new PsuSensorWithLimits("+3.3V",
                                             sensorIndex++,
                                             SensorType.Voltage,
                                             this,
                                             settings,
                                             UsbApi.Command.RAIL_VOLTS,
                                             criticals.VoltageMin[(byte)Rail._3V],
                                             criticals.VoltageMax[(byte)Rail._3V],
                                             Rail._3V));

        if (optionalCommands.HasFlag(UsbApi.OptionalCommands.InputCurrent))
        {
            _sensors.Add(new PsuSensor("Input", sensorIndex++, SensorType.Current, this, settings, UsbApi.Command.IN_AMPS));
        }

        _sensors.Add(new PsuSensorWithLimits("+12V",
                                             sensorIndex++,
                                             SensorType.Current,
                                             this,
                                             settings,
                                             UsbApi.Command.RAIL_AMPS,
                                             null,
                                             criticals.CurrentMax[(byte)Rail._12V]));

        _sensors.Add(new PsuSensorWithLimits("+5V",
                                             sensorIndex++,
                                             SensorType.Current,
                                             this,
                                             settings,
                                             UsbApi.Command.RAIL_AMPS,
                                             null,
                                             criticals.CurrentMax[(byte)Rail._5V],
                                             Rail._5V));

        _sensors.Add(new PsuSensorWithLimits("+3.3V",
                                             sensorIndex++,
                                             SensorType.Current,
                                             this,
                                             settings,
                                             UsbApi.Command.RAIL_AMPS,
                                             null,
                                             criticals.CurrentMax[(byte)Rail._3V],
                                             Rail._3V));

        PsuSensor[] powerRails =
        [
            new("+12V", sensorIndex++, SensorType.Power, this, settings, UsbApi.Command.RAIL_WATTS),
            new("+5V", sensorIndex++, SensorType.Power, this, settings, UsbApi.Command.RAIL_WATTS, Rail._5V),
            new("+3.3V", sensorIndex++, SensorType.Power, this, settings, UsbApi.Command.RAIL_WATTS, Rail._3V)
        ];

        _sensors.AddRange(powerRails);
        _sensors.Add(new PsuSensor("Total watts", sensorIndex++, SensorType.Power, this, settings, UsbApi.Command.TOTAL_WATTS));
        _compositeSensors.Add(new CompositeSensor("Total Output",
                                                  sensorIndex++,
                                                  SensorType.Power,
                                                  this,
                                                  settings,
                                                  powerRails,
                                                  (acc, sensor) => acc + sensor.Value ?? 0f));

        ActivateSensor(_compositeSensors[_compositeSensors.Count - 1]);

        _sensors.Add(new PsuSensor("Uptime", sensorIndex++, SensorType.TimeSpan, this, settings, UsbApi.Command.UPTIME, Rail._12V, true));
        _sensors.Add(new PsuSensor("Total uptime", sensorIndex, SensorType.TimeSpan, this, settings, UsbApi.Command.TOTAL_UPTIME, Rail._12V, true));
    }

    private class PsuSensor : Sensor
    {
        private readonly UsbApi.Command _cmd;
        private readonly byte _rail;

        public PsuSensor(string name, int index, SensorType type, CorsairPsu hardware, ISettings settings, UsbApi.Command cmd, Rail rail = Rail._12V, bool noHistory = false)
            : base(name, index, false, type, hardware, null, settings, noHistory)
        {
            _cmd = cmd;
            _rail = (byte)rail;

            hardware.ActivateSensor(this);
        }

        public void Update(HidStream stream)
        {
            Value = UsbApi.GetValue(stream, _cmd, _rail);
        }
    }

    private class PsuSensorWithLimits
    (
        string name,
        int index,
        SensorType type,
        CorsairPsu hardware,
        ISettings settings,
        UsbApi.Command cmd,
        float? lowCritical,
        float? highCritical,
        Rail rail = Rail._12V)
        : PsuSensor(name, index, type, hardware, settings, cmd, rail), ICriticalSensorLimits
    {
        public float? CriticalHighLimit { get; } = highCritical;

        public float? CriticalLowLimit { get; } = lowCritical;
    }

    private enum Rail : byte
    {
        _12V = 0,
        _5V = 1,
        _3V = 2
    }
}

```

`LibreHardwareMonitorLib/Hardware/Psu/Corsair/CorsairPsuGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the GNU Public License, v. 2.0.
// Copyright(C) 2020 Wilken Gottwalt<wilken.gottwalt@posteo.net>
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.
// Implemented after the Linuix kernel driver corsair_psu by Wilken Gottwalt and contributers

using System.Collections.Generic;
using System.Linq;
using System.Text;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Psu.Corsair;

public class CorsairPsuGroup : IGroup
{
    private static readonly int[] _productIds =
    {
        0x1c03, // HX550i
        0x1c04, // HX650i
        0x1c05, // HX750i
        0x1c06, // HX850i
        0x1c07, // HX1000i
        0x1c1e, // HX1000i REV2
        0x1c08, // HX1200i
        0x1c1f, // HX1500i

        0x1c09, // RM550i
        0x1c0a, // RM650i
        0x1c0b, // RM750i
        0x1c0c, // RM850i
        0x1c0d, // RM1000i

        // 0x1c11, // AX1600i
    };

    private static readonly ushort _vendorId = 0x1b1c;
    private readonly List<IHardware> _hardware;
    private readonly StringBuilder _report;

    public CorsairPsuGroup(ISettings settings)
    {
        _report = new StringBuilder();
        _report.AppendLine("Corsair HXi/RMi series PSU Hardware");
        _report.AppendLine();

        _hardware = new List<IHardware>();
        foreach (HidDevice dev in DeviceList.Local.GetHidDevices(_vendorId))
        {
            if (_productIds.Contains(dev.ProductID))
            {
                var device = new CorsairPsu(dev, settings, _hardware.Count);
                _hardware.Add(device);
                _report.AppendLine($"Device name: {device.Name}");
                _report.AppendLine();
            }
        }
    }

    public IReadOnlyList<IHardware> Hardware => _hardware;

    public void Close()
    {
        foreach (IHardware iHardware in _hardware)
        {
            if (iHardware is Hardware hardware)
                hardware.Close();
        }
    }

    public string GetReport()
    {
        return _report.ToString();
    }
}

```

`LibreHardwareMonitorLib/Hardware/Psu/Corsair/UsbApi.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Linq;
using System.Text;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Psu.Corsair;

internal static class UsbApi
{
    public enum Command : byte
    {
        SELECT_RAIL = 0x00, /* expects length 2 */
        RAIL_VOLTS_HCRIT = 0x40, /* the rest of the commands expect length 3 */
        RAIL_VOLTS_LCRIT = 0x44,
        RAIL_AMPS_HCRIT = 0x46,
        TEMP_HCRIT = 0x4F,
        IN_VOLTS = 0x88,
        IN_AMPS = 0x89,
        RAIL_VOLTS = 0x8B,
        RAIL_AMPS = 0x8C,
        TEMP0 = 0x8D,
        TEMP1 = 0x8E,
        FAN_RPM = 0x90,
        RAIL_WATTS = 0x96,
        VEND_STR = 0x99,
        PROD_STR = 0x9A,
        TOTAL_UPTIME = 0xD1,
        UPTIME = 0xD2,
        OCPMODE = 0xD8,
        TOTAL_WATTS = 0xEE,
        INIT = 0xFE
    }

    [Flags]
    public enum OptionalCommands
    {
        None = 0x0,
        InputCurrent = 0x1
    }

    public static void Init(HidStream stream)
    {
        /*
         * PSU_CMD_INIT uses swapped length/command and expects 2 parameter bytes, this command
         * actually generates a reply, but we don't need it
         */
        SendCommand(stream, (byte)Command.INIT, (Command)3, 0, out _);
    }

    public static float? GetValue(HidStream stream, Command cmd, byte rail)
    {
        if (!Request(stream, cmd, rail, out byte[] data))
            return null;

        /*
         * the biggest value here comes from the uptime command and to exceed MAXINT total uptime
         * needs to be about 68 years, the rest are u16 values and the biggest value coming out of
         * the LINEAR11 conversion are the watts values which are about 1200 for the strongest psu
         * supported (HX1200i)
         */
        int tmp = BitConverter.ToInt32(data, 0); // ((int)data[3] << 24) + (data[2] << 16) + (data[1] << 8) + data[0];
        return cmd switch
        {
            Command.RAIL_VOLTS_HCRIT or Command.RAIL_VOLTS_LCRIT or Command.RAIL_AMPS_HCRIT or Command.TEMP_HCRIT or Command.IN_VOLTS or Command.IN_AMPS or Command.RAIL_VOLTS or Command.RAIL_AMPS
                or Command.TEMP0 or Command.TEMP1 or Command.FAN_RPM or Command.RAIL_WATTS or Command.TOTAL_WATTS => Linear11ToFloat32((ushort)tmp), // Linear11ToInt((ushort)tmp, 1000000);
            Command.TOTAL_UPTIME or Command.UPTIME or Command.OCPMODE => tmp,
            _ => null
        };
    }

    public static Criticals GetCriticals(HidStream stream)
    {
        Criticals res = new();
        const byte tempCount = 2;
        res.TempMax = new float?[tempCount];

        for (byte rail = 0; rail < tempCount; rail++)
            res.TempMax[rail] = GetValue(stream, Command.TEMP_HCRIT, rail);

        const byte railCount = 3; /* 3v + 5v + 12v */
        res.VoltageMin = new float?[railCount];
        res.VoltageMax = new float?[railCount];
        res.CurrentMax = new float?[railCount];

        for (byte rail = 0; rail < railCount; rail++)
        {
            res.VoltageMax[rail] = GetValue(stream, Command.RAIL_VOLTS_HCRIT, rail);
            res.VoltageMin[rail] = GetValue(stream, Command.RAIL_VOLTS_LCRIT, rail);
            res.CurrentMax[rail] = GetValue(stream, Command.RAIL_AMPS_HCRIT, rail);
        }

        return res;
    }

    public static OptionalCommands GetOptionalCommands(HidStream stream)
    {
        OptionalCommands res = OptionalCommands.None;

        if (GetValue(stream, Command.IN_AMPS, 0).HasValue)
            res |= OptionalCommands.InputCurrent;

        return res;
    }

    public static FirmwareInfo FwInfo(HidStream stream)
    {
        if (!SendCommand(stream, 3, Command.VEND_STR, 0, out byte[] vendorArr))
            throw new ProtocolError(stream.Device, "Can't read vendor string");

        if (!SendCommand(stream, 3, Command.PROD_STR, 0, out byte[] productArr))
            throw new ProtocolError(stream.Device, "Can't read product");

        static string ArrayToString(byte[] ar)
        {
            return Encoding.ASCII.GetString(ar.TakeWhile(x => x != 0).ToArray());
        }

        return new FirmwareInfo { Vendor = ArrayToString(vendorArr), Product = ArrayToString(productArr) };
    }

    private static bool SendCommand(HidStream stream, byte length, Command cmd, byte arg, out byte[] replyData)
    {
        /*
         * Corsair protocol for PSUs
         *
         * message size = 64 bytes (request and response, little endian)
         * request:
         *	[length][command][param0][param1][paramX]...
         * reply:
         *	[echo of length][echo of command][data0][data1][dataX]...
         *
         *	- commands are byte sized opcodes
         *	- length is the sum of all bytes of the commands/params
         *	- the micro-controller of most of these PSUs support concatenation in the request and reply,
         *	  but it is better to not rely on this (it is also hard to parse)
         *	- the driver uses raw events to be accessible from userspace (though this is not really
         *	  supported, it is just there for convenience, may be removed in the future)
         *	- a reply always start with the length and command in the same order the request used it
         *	- length of the reply data is specific to the command used
         *	- some of the commands work on a rail and can be switched to a specific rail (0 = 12v,
         *	  1 = 5v, 2 = 3.3v)
         *	- the format of the init command 0xFE is swapped length/command bytes
         *	- parameter bytes amount and values are specific to the command (rail setting is the only
         *	  for now that uses non-zero values)
         *	- there are much more commands, especially for configuring the device, but they are not
         *	  supported because a wrong command/length can lockup the micro-controller
         *	- the driver supports debugfs for values not fitting into the hwmon class
         *	- not every device class (HXi, RMi or AXi) supports all commands
         *	- it is a pure sensors reading driver (will not support configuring)
         */

        const int cmdBufferSize = 64;
        const int replySize = 16;

        byte[] cmdBuffer = new byte[cmdBufferSize + 1];
        cmdBuffer[0] = 0; // report id
        cmdBuffer[1] = length;
        cmdBuffer[2] = (byte)cmd;
        cmdBuffer[3] = arg;

        stream.Write(cmdBuffer);
        byte[] reply = stream.Read();
        replyData = new byte[replySize];
        Array.Copy(reply, 3, replyData, 0, replySize);

        return reply[1] == cmdBuffer[1] && reply[2] == cmdBuffer[2];
    }

    private static bool Request(HidStream stream, Command cmd, byte rail, out byte[] data)
    {
        switch (cmd)
        {
            case Command.RAIL_VOLTS_HCRIT:
            case Command.RAIL_VOLTS_LCRIT:
            case Command.RAIL_AMPS_HCRIT:
            case Command.RAIL_VOLTS:
            case Command.RAIL_AMPS:
            case Command.RAIL_WATTS:
                if (!SendCommand(stream, 2, Command.SELECT_RAIL, rail, out _))
                {
                    data = null;
                    return false;
                }

                break;
        }

        return SendCommand(stream, 3, cmd, 0, out data);
    }

    private static float Linear11ToFloat32(ushort val)
    {
        int exp = (short)val >> 11;
        int mant = (short)(val & 0x7ff) << 5 >> 5;
        return mant * (float)Math.Pow(2, exp);
    }

    public struct FirmwareInfo
    {
        public string Vendor;
        public string Product;
    }

    public struct Criticals
    {
        public float?[] TempMax;

        public float?[] VoltageMin;
        public float?[] VoltageMax;

        public float?[] CurrentMax;
    }
}

```

`LibreHardwareMonitorLib/Hardware/Psu/Msi/MsiPsu.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) 2024 demorfi<demorfi@gmail.com>
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System.Collections.Generic;
using System.Globalization;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Psu.Msi;

internal sealed class MsiPsu : Hardware
{
    private readonly HidDevice _device;
    private readonly List<PsuSensor> _sensors = [];

    public MsiPsu(HidDevice device, ISettings settings, int index)
        : base("MSI PSU", new Identifier("psu", "msi", index.ToString()), settings)
    {
        _device = device;
        using HidStream stream = device.Open();
        UsbApi.FirmwareInfo fwInfo = UsbApi.FwInfo(stream);
        Name = $"{fwInfo.Vendor} {fwInfo.Product}";

        AddSensors(settings);
    }

    public override HardwareType HardwareType => HardwareType.Psu;

    public override void Update()
    {
        using HidStream stream = _device.Open();
        float[] info = UsbApi.InfoList(stream);
        _sensors.ForEach(s => s.Update(info));
    }

    private void AddSensors(ISettings settings)
    {
        int sensorIndex = 0;
        
        _sensors.Add(new PsuSensor("Case", sensorIndex++, SensorType.Fan, this, settings, UsbApi.IndexInfo.FAN_RPM));
        _sensors.Add(new PsuSensor("Case", sensorIndex++, SensorType.Temperature, this, settings, UsbApi.IndexInfo.TEMP));

        _sensors.Add(new PsuSensor("+12V", sensorIndex++, SensorType.Voltage, this, settings, UsbApi.IndexInfo.VOLTS_12));
        _sensors.Add(new PsuSensor("+12V", sensorIndex++, SensorType.Current, this, settings, UsbApi.IndexInfo.AMPS_12));

        _sensors.Add(new PsuSensor("+5V", sensorIndex++, SensorType.Voltage, this, settings, UsbApi.IndexInfo.VOLTS_5));
        _sensors.Add(new PsuSensor("+5V", sensorIndex++, SensorType.Current, this, settings, UsbApi.IndexInfo.AMPS_5));

        _sensors.Add(new PsuSensor("+3.3V", sensorIndex++, SensorType.Voltage, this, settings, UsbApi.IndexInfo.VOLTS_3V3));
        _sensors.Add(new PsuSensor("+3.3V", sensorIndex++, SensorType.Current, this, settings, UsbApi.IndexInfo.AMPS_3V3));

        _sensors.Add(new PsuSensor("PSU Efficiency", sensorIndex++, SensorType.Level, this, settings, UsbApi.IndexInfo.EFFICIENCY));
        _sensors.Add(new PsuSensor("PSU Out", sensorIndex++, SensorType.Power, this, settings, UsbApi.IndexInfo.PSU_OUT));
        _sensors.Add(new PsuSensor("Total Runtime", sensorIndex++, SensorType.TimeSpan, this, settings, UsbApi.IndexInfo.RUNTIME, true));
    }

    private class PsuSensor : Sensor
    {
        private readonly UsbApi.IndexInfo _indexInfo;

        public PsuSensor(string name, int index, SensorType type, MsiPsu hardware, ISettings settings, UsbApi.IndexInfo indexInfo, bool noHistory = false)
            : base(name, index, false, type, hardware, null, settings, noHistory)
        {
            _indexInfo = indexInfo;
            hardware.ActivateSensor(this);
        }

        public void Update(float[] info)
        {
            Value = info[(int)_indexInfo];
        }
    }
}

```

`LibreHardwareMonitorLib/Hardware/Psu/Msi/MsiPsuGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the GNU Public License, v. 2.0.
// Copyright (C) 2024 demorfi<demorfi@gmail.com>
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System.Collections.Generic;
using System.Linq;
using System.Text;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Psu.Msi;

public class MsiPsuGroup : IGroup
{
    private static readonly int[] _productIds =
    {
        0x56d4, // MEG Ai1300P
    };

    private static readonly ushort _vendorId = 0x0db0;
    private readonly List<IHardware> _hardware;
    private readonly StringBuilder _report;

    public MsiPsuGroup(ISettings settings)
    {
        _report = new StringBuilder();
        _report.AppendLine("MSI Ai series PSU Hardware");
        _report.AppendLine();

        _hardware = new List<IHardware>();
        foreach (HidDevice dev in DeviceList.Local.GetHidDevices(_vendorId))
        {
            if (_productIds.Contains(dev.ProductID))
            {
                var device = new MsiPsu(dev, settings, _hardware.Count);
                _hardware.Add(device);
                _report.AppendLine($"Device name: {device.Name}");
                _report.AppendLine();
            }
        }

        if (_hardware.Count == 0)
        {
            _report.AppendLine("No MSI PSU Hardware found.");
            _report.AppendLine();
        }
    }

    public IReadOnlyList<IHardware> Hardware => _hardware;

    public void Close()
    {
        foreach (IHardware iHardware in _hardware)
        {
            if (iHardware is Hardware hardware)
                hardware.Close();
        }
    }

    public string GetReport()
    {
        return _report.ToString();
    }
}

```

`LibreHardwareMonitorLib/Hardware/Psu/Msi/UsbApi.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) 2024 demorfi<demorfi@gmail.com>
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Linq;
using System.Text;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Psu.Msi;

internal static class UsbApi
{
    public enum IndexInfo : int
    {
        VOLTS_12V1 = 0,
        VOLTS_12V2 = 2,
        VOLTS_12V3 = 4,
        VOLTS_12V4 = 6,
        VOLTS_12V5 = 8,
        VOLTS_12 = 10,
        VOLTS_5 = 12,
        VOLTS_3V3 = 14,
        AMPS_12V1 = 1,
        AMPS_12V2 = 3,
        AMPS_12V3 = 5,
        AMPS_12V4 = 7,
        AMPS_12V5 = 9,
        AMPS_12 = 11,
        AMPS_5 = 13,
        AMPS_3V3 = 15,

        PSU_OUT = 16,
        EFFICIENCY = 17,
        TEMP = 18,
        FAN_RPM = 19,
        RUNTIME = 20
    }

    public static FirmwareInfo FwInfo(HidStream stream)
    {
        if (!Request(stream, new byte[2] { 0xFA, 0x51 }, out byte[] productArr, 1))
            throw new ProtocolError(stream.Device, "Can't read product name");

        static string ArrayToString(byte[] ar)
        {
            return Encoding.ASCII.GetString(ar.TakeWhile(x => x != 0).ToArray());
        }

        return new FirmwareInfo { Vendor = "MSI", Product = ArrayToString(productArr) };
    }

    private static float Linear11ToFloat32(ushort val)
    {
        int exp = (short)val >> 11;
        int mant = ((short)(val & 0x7ff) << 5) >> 5;
        return mant * (float)Math.Pow(2, exp);
    }

    private static bool Request(HidStream stream, byte[] command, out byte[] response, int offset = 0)
    {
        byte[] buffer = new byte[64];
        Array.Copy(command, 0, buffer, 1, 2);
        stream.Write(buffer);

        byte[] reply = stream.Read();
        response = new byte[42];
        Array.Copy(reply, 2 + offset, response, 0, 42);

        return reply[0] == buffer[0] && reply[1] == buffer[1];
    }

    public static float[] InfoList(HidStream stream)
    {
        int length = Enum.GetNames(typeof(IndexInfo)).Length;
        float[] info = new float[length];

        if (!Request(stream, new byte[2] { 0x51, 0xE0 }, out byte[] basic))
            throw new ProtocolError(stream.Device, "Can't read basic info");

        // basic has information only about the first 20 sensors
        for (int i = 0; i < 20; i++)
        {
            byte[] replyData = new byte[4];
            Array.Copy(basic, (i * 2) + 1, replyData, 0, 2);
            info[i] = Linear11ToFloat32((ushort)BitConverter.ToInt32(replyData, 0));
        }

        // runtime info
        Request(stream, new byte[2] { 0x51, 0xD1 }, out byte[] runtime);
        info[(int)IndexInfo.RUNTIME] = BitConverter.ToInt32(runtime, 0) / 100;

        return info;
    }

    public struct FirmwareInfo
    {
        public string Vendor;
        public string Product;
    }
}

```

`LibreHardwareMonitorLib/Hardware/Psu/ProtocolError.cs`:

```cs
using System;
using HidSharp;

namespace LibreHardwareMonitor.Hardware.Psu;

/// <summary>
/// Represents an error that occurs during communication with a PSU controller over USB.
/// </summary>
/// <param name="device">The HID device associated with the communication error. Cannot be null.</param>
/// <param name="message">The error message that describes the nature of the communication failure.</param>
public class ProtocolError(HidDevice device, string message) : ApplicationException($"Error communicating with the PSU controller at {device.DevicePath}: {message}");

```

`LibreHardwareMonitorLib/Hardware/RyzenSMU.cs`:

```cs
// ported from: https://gitlab.com/leogx9r/ryzen_smu
// and: https://github.com/irusanov/SMUDebugTool

using System;
using System.Collections.Generic;
using System.Text;
using LibreHardwareMonitor.PawnIo;

// ReSharper disable InconsistentNaming

namespace LibreHardwareMonitor.Hardware;

internal class RyzenSMU
{
    private readonly CpuCodeName _cpuCodeName;
    private readonly bool _supportedCPU;
    private readonly Exception _unsupportedCPUException;

    private readonly Dictionary<uint, Dictionary<uint, SmuSensorType>> _supportedPmTableVersions = new()
    {
        {
            // Zen Raven Ridge APU.
            0x001E0004, new Dictionary<uint, SmuSensorType>
            {
                { 7, new SmuSensorType { Name = "TDC", Type = SensorType.Current, Scale = 1 } },
                { 11, new SmuSensorType { Name = "EDC", Type = SensorType.Current, Scale = 1 } },
                //{ 61, new SmuSensorType { Name = "Core", Type = SensorType.Voltage } },
                //{ 62, new SmuSensorType { Name = "Core", Type = SensorType.Current, Scale = 1} },
                //{ 63, new SmuSensorType { Name = "Core", Type = SensorType.Power, Scale = 1 } },
                //{ 65, new SmuSensorType { Name = "SoC", Type = SensorType.Voltage } },
                { 66, new SmuSensorType { Name = "SoC", Type = SensorType.Current, Scale = 1 } },
                { 67, new SmuSensorType { Name = "SoC", Type = SensorType.Power, Scale = 1 } },
                //{ 96, new SmuSensorType { Name = "Core #1", Type = SensorType.Power } },
                //{ 97, new SmuSensorType { Name = "Core #2", Type = SensorType.Power } },
                //{ 98, new SmuSensorType { Name = "Core #3", Type = SensorType.Power } },
                //{ 99, new SmuSensorType { Name = "Core #4", Type = SensorType.Power } },
                { 108, new SmuSensorType { Name = "Core #1", Type = SensorType.Temperature, Scale = 1 } },
                { 109, new SmuSensorType { Name = "Core #2", Type = SensorType.Temperature, Scale = 1 } },
                { 110, new SmuSensorType { Name = "Core #3", Type = SensorType.Temperature, Scale = 1 } },
                { 111, new SmuSensorType { Name = "Core #4", Type = SensorType.Temperature, Scale = 1 } },
                { 150, new SmuSensorType { Name = "GFX", Type = SensorType.Voltage, Scale = 1 } },
                { 151, new SmuSensorType { Name = "GFX", Type = SensorType.Temperature, Scale = 1 } },
                { 154, new SmuSensorType { Name = "GFX", Type = SensorType.Clock, Scale = 1 } },
                { 156, new SmuSensorType { Name = "GFX", Type = SensorType.Load, Scale = 1 } },
                { 166, new SmuSensorType { Name = "Fabric", Type = SensorType.Clock, Scale = 1 } },
                { 177, new SmuSensorType { Name = "Uncore", Type = SensorType.Clock, Scale = 1 } },
                { 178, new SmuSensorType { Name = "Memory", Type = SensorType.Clock, Scale = 1 } },
                { 342, new SmuSensorType { Name = "Displays", Type = SensorType.Factor, Scale = 1 } }
            }
        },
        {
            // Zen 2.
            0x00240903, new Dictionary<uint, SmuSensorType>
            {
                { 15, new SmuSensorType { Name = "TDC", Type = SensorType.Current, Scale = 1 } },
                { 21, new SmuSensorType { Name = "EDC", Type = SensorType.Current, Scale = 1 } },
                { 48, new SmuSensorType { Name = "Fabric", Type = SensorType.Clock, Scale = 1 } },
                { 50, new SmuSensorType { Name = "Uncore", Type = SensorType.Clock, Scale = 1 } },
                { 51, new SmuSensorType { Name = "Memory", Type = SensorType.Clock, Scale = 1 } },
                { 115, new SmuSensorType { Name = "SoC", Type = SensorType.Temperature, Scale = 1 } }
                //{ 66, new SmuSensorType { Name = "Bus Speed", Type = SensorType.Clock, Scale = 1 } },
                //{ 188, new SmuSensorType { Name = "Core #1", Type = SensorType.Clock, Scale = 1000 } },
                //{ 189, new SmuSensorType { Name = "Core #2", Type = SensorType.Clock, Scale = 1000 } },
                //{ 190, new SmuSensorType { Name = "Core #3", Type = SensorType.Clock, Scale = 1000 } },
                //{ 191, new SmuSensorType { Name = "Core #4", Type = SensorType.Clock, Scale = 1000 } },
                //{ 192, new SmuSensorType { Name = "Core #5", Type = SensorType.Clock, Scale = 1000 } },
                //{ 193, new SmuSensorType { Name = "Core #6", Type = SensorType.Clock, Scale = 1000 } },
            }
        },
        {
            // Zen 3.
            0x00380805, new Dictionary<uint, SmuSensorType>
            {
                { 3, new SmuSensorType { Name = "TDC", Type = SensorType.Current, Scale = 1 } },
                // TODO: requires some post-processing
                // see: https://gitlab.com/leogx9r/ryzen_smu/-/blob/master/userspace/monitor_cpu.c#L577
                // { 9, new SmuSensorType { Name = "EDC", Type = SensorType.Current, Scale = 1 } },
                { 48, new SmuSensorType { Name = "Fabric", Type = SensorType.Clock, Scale = 1 } },
                { 50, new SmuSensorType { Name = "Uncore", Type = SensorType.Clock, Scale = 1 } },
                { 51, new SmuSensorType { Name = "Memory", Type = SensorType.Clock, Scale = 1 } },
                { 127, new SmuSensorType { Name = "SoC", Type = SensorType.Temperature, Scale = 1 } },

                //Core effective clock is now calculated in Amd17Cpu/Core
                //{ 268, new SmuSensorType { Name = "Core #1 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 269, new SmuSensorType { Name = "Core #2 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 270, new SmuSensorType { Name = "Core #3 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 271, new SmuSensorType { Name = "Core #4 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 272, new SmuSensorType { Name = "Core #5 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 273, new SmuSensorType { Name = "Core #6 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 274, new SmuSensorType { Name = "Core #7 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 275, new SmuSensorType { Name = "Core #8 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 276, new SmuSensorType { Name = "Core #9 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 277, new SmuSensorType { Name = "Core #10 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 278, new SmuSensorType { Name = "Core #11 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 279, new SmuSensorType { Name = "Core #12 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 280, new SmuSensorType { Name = "Core #13 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 281, new SmuSensorType { Name = "Core #14 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 282, new SmuSensorType { Name = "Core #15 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 283, new SmuSensorType { Name = "Core #16 (Effective)", Type = SensorType.Clock, Scale = 1000 } }
            }
        },
        {
            // Zen 4.
            0x00540004, new Dictionary<uint, SmuSensorType>
            {
                { 3, new SmuSensorType { Name = "CPU PPT", Type = SensorType.Power, Scale = 1 } },
                { 11, new SmuSensorType { Name = "Package", Type = SensorType.Temperature, Scale = 1 } },
                { 20, new SmuSensorType { Name = "Core Power", Type = SensorType.Power, Scale = 1 } },
                { 21, new SmuSensorType { Name = "SOC Power", Type = SensorType.Power, Scale = 1 } },
                { 22, new SmuSensorType { Name = "Misc Power", Type = SensorType.Power, Scale = 1 } },
                { 26, new SmuSensorType { Name = "Total Power", Type = SensorType.Power, Scale = 1 } },
                { 47, new SmuSensorType { Name = "VDDCR", Type = SensorType.Voltage, Scale = 1 } },
                { 48, new SmuSensorType { Name = "TDC", Type = SensorType.Current, Scale = 1 } },
                { 49, new SmuSensorType { Name = "EDC", Type = SensorType.Current, Scale = 1 } },
                { 52, new SmuSensorType { Name = "VDDCR SoC", Type = SensorType.Voltage, Scale = 1 } },
                { 57, new SmuSensorType { Name = "VDD Misc", Type = SensorType.Voltage, Scale = 1 } },
                { 70, new SmuSensorType { Name = "Fabric", Type = SensorType.Clock, Scale = 1 } },
                { 74, new SmuSensorType { Name = "Uncore", Type = SensorType.Clock, Scale = 1 } },
                { 78, new SmuSensorType { Name = "Memory", Type = SensorType.Clock, Scale = 1 } },
                { 211, new SmuSensorType { Name = "IOD Hotspot", Type = SensorType.Temperature, Scale = 1 } },
                { 539, new SmuSensorType { Name = "L3 (CCD1)", Type = SensorType.Temperature, Scale = 1 } },
                { 540, new SmuSensorType { Name = "L3 (CCD2)", Type = SensorType.Temperature, Scale = 1 } },
                { 268, new SmuSensorType { Name = "LDO VDD", Type = SensorType.Voltage, Scale = 1 } },

                // This is not working, some cores can be deactivated with the core disabled map.
                // When Core 2 is disabled and Core 3 is enabled, the name of Core 3 == "Core 2".
                //{ 357, new SmuSensorType { Name = "Core #1 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 358, new SmuSensorType { Name = "Core #2 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 359, new SmuSensorType { Name = "Core #3 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 360, new SmuSensorType { Name = "Core #4 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 361, new SmuSensorType { Name = "Core #5 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 362, new SmuSensorType { Name = "Core #6 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 363, new SmuSensorType { Name = "Core #7 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 364, new SmuSensorType { Name = "Core #8 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 365, new SmuSensorType { Name = "Core #9 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 366, new SmuSensorType { Name = "Core #10 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 367, new SmuSensorType { Name = "Core #11 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 368, new SmuSensorType { Name = "Core #12 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 369, new SmuSensorType { Name = "Core #13 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 370, new SmuSensorType { Name = "Core #14 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 371, new SmuSensorType { Name = "Core #15 (Effective)", Type = SensorType.Clock, Scale = 1000 } },
                //{ 372, new SmuSensorType { Name = "Core #16 (Effective)", Type = SensorType.Clock, Scale = 1000 } }
            }
        }
    };

    private uint _pmTableSize;
    private uint _pmTableSizeAlt;
    private uint _pmTableVersion;
    private uint _dramBaseAddr;

    private readonly RyzenSmu _ryzenSmu;

    public RyzenSMU()
    {
        try
        {
            _ryzenSmu = new RyzenSmu();

            _cpuCodeName = (CpuCodeName)_ryzenSmu.GetCodeName();

            _ryzenSmu.ResolvePmTable(out _pmTableVersion, out _dramBaseAddr);

            SetupPmTableSize();

            _supportedCPU = true;
        }
        catch (Exception e)
        {
            _supportedCPU = false;
            _unsupportedCPUException = e;
        }
    }

    public void Close() => _ryzenSmu.Close();

    public string GetReport()
    {
        StringBuilder r = new();

        r.AppendLine("Ryzen SMU");
        r.AppendLine();
        r.AppendLine($" PM table version: 0x{_pmTableVersion:X8}");
        r.AppendLine($" PM table supported: {_supportedCPU}");
        r.AppendLine($" PM table layout defined: {IsPmTableLayoutDefined()}");

        if (_supportedCPU)
        {
            r.AppendLine($" PM table size: 0x{_pmTableSize:X3}");
            r.AppendLine($" PM table start address: 0x{_dramBaseAddr:X8}");
            r.AppendLine();
            r.AppendLine(" PM table dump:");

            try
            {
                float[] pm_values = UpdateAndReadDram();
                r.AppendLine("  Idx    Offset   Value");
                r.AppendLine(" ------------------------");
                for (int i = 0; i < pm_values.Length; i++)
                {
                    r.AppendLine($" {i,4}    0x{i * 4:X3}    {pm_values[i]}");
                }
            }
            catch (Exception e)
            {
                r.AppendLine($" Exception: {e.Message}");
            }
        }
        else
        {
            r.AppendLine($" Initialization exception: {_unsupportedCPUException.Message}");
        }

        return r.ToString();
    }

    public Dictionary<uint, SmuSensorType> GetPmTableStructure()
    {
        if (!IsPmTableLayoutDefined())
            return new Dictionary<uint, SmuSensorType>();

        return _supportedPmTableVersions[_pmTableVersion];
    }

    public bool IsPmTableLayoutDefined()
    {
        return _supportedPmTableVersions.ContainsKey(_pmTableVersion);
    }

    public float[] GetPmTable()
    {
        if (!_supportedCPU)
            return [0];

        float[] table = null;
        for (int tries_left = 2; tries_left != 0; --tries_left)
        {
            table = null;
            try
            {
                table = UpdateAndReadDram();
            }
            catch
            {
                // ignored
            }

            if (table is { Length: > 0 } && table[0] != 0)
            {
                return table;
            }
        }

        return table is { Length: > 0 } ? table : [0];
    }

    private float[] UpdateAndReadDram()
    {
        float[] table = new float[_pmTableSize / 4];

        _ryzenSmu.UpdatePmTable();
        long[] read = _ryzenSmu.ReadPmTable((int)((_pmTableSize + 7) / 8));
        Buffer.BlockCopy(read, 0, table, 0, (int)_pmTableSize);

        return table;
    }

    private void SetupPmTableSize()
    {
        switch (_cpuCodeName)
        {
            case CpuCodeName.Matisse:
                switch (_pmTableVersion)
                {
                    case 0x240902:
                        _pmTableSize = 0x514;
                        break;
                    case 0x240903:
                        _pmTableSize = 0x518;
                        break;
                    case 0x240802:
                        _pmTableSize = 0x7E0;
                        break;
                    case 0x240803:
                        _pmTableSize = 0x7E4;
                        break;
                    default:
                        return;
                }

                break;

            case CpuCodeName.Vermeer:
                switch (_pmTableVersion)
                {
                    case 0x2D0903:
                        _pmTableSize = 0x594;
                        break;
                    case 0x380904:
                        _pmTableSize = 0x5A4;
                        break;
                    case 0x380905:
                        _pmTableSize = 0x5D0;
                        break;
                    case 0x2D0803:
                        _pmTableSize = 0x894;
                        break;
                    case 0x380804:
                        _pmTableSize = 0x8A4;
                        break;
                    case 0x380805:
                        _pmTableSize = 0x8F0;
                        break;
                    default:
                        return;
                }

                break;

            case CpuCodeName.Renoir:
                switch (_pmTableVersion)
                {
                    case 0x370000:
                        _pmTableSize = 0x794;
                        break;
                    case 0x370001:
                        _pmTableSize = 0x884;
                        break;
                    case 0x370002:
                    case 0x370003:
                        _pmTableSize = 0x88C;
                        break;
                    case 0x370004:
                        _pmTableSize = 0x8AC;
                        break;
                    case 0x370005:
                        _pmTableSize = 0x8C8;
                        break;
                    default:
                        return;
                }

                break;

            case CpuCodeName.Cezanne:
                switch (_pmTableVersion)
                {
                    case 0x400005:
                        _pmTableSize = 0x944;
                        break;

                    default:
                        return;
                }

                break;

            case CpuCodeName.Picasso:
            case CpuCodeName.RavenRidge:
            case CpuCodeName.RavenRidge2:
                _pmTableSizeAlt = 0xA4;
                _pmTableSize = 0x608 + _pmTableSizeAlt;
                break;

            case CpuCodeName.Raphael:
            case CpuCodeName.GraniteRidge:
                switch (_pmTableVersion)
                {
                    case 0x00540004:
                        _pmTableSize = 0x948;
                        break;

                    case 0x00540104:
                        _pmTableSize = 0x950;
                        break;

                    default:
                        return;
                }

                break;

            default:
                return;
        }
    }

    public struct SmuSensorType
    {
        public string Name;
        public SensorType Type;
        public float Scale;
    }


    private enum CpuCodeName
    {
        Undefined = -1,
        Colfax,
        Renoir,
        Picasso,
        Matisse,
        Threadripper,
        CastlePeak,
        RavenRidge,
        RavenRidge2,
        SummitRidge,
        PinnacleRidge,
        Rembrandt,
        Vermeer,
        Vangogh,
        Cezanne,
        Milan,
        Dali,
        Raphael,
        GraniteRidge,
        Naples,
        FireFlight,
        Rome,
        Chagall,
        Lucienne,
        Phoenix,
        Phoenix2,
        Mendocino,
        Genoa,
        StormPeak,
        DragonRange,
        Mero,
        HawkPoint,
        StrixPoint,
        StrixHalo,
        KrackanPoint,
        KrackanPoint2,
        Turin,
        TurinD,
        Bergamo,
        ShimadaPeak,
    }
}

```

`LibreHardwareMonitorLib/Hardware/SMBios.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Windows.Win32.System.SystemInformation;
using LibreHardwareMonitor.Interop;

// ReSharper disable CommentTypo
// ReSharper disable IdentifierTypo
// ReSharper disable InconsistentNaming

namespace LibreHardwareMonitor.Hardware;

/// <summary>
/// System enclosure security status based on <see href="https://www.dmtf.org/dsp/DSP0134">DMTF SMBIOS Reference Specification v.3.3.0, Chapter 7.4.3</see>.
/// </summary>
public enum SystemEnclosureSecurityStatus
{
    Other = 1,
    Unknown,
    None,
    ExternalInterfaceLockedOut,
    ExternalInterfaceEnabled
}

/// <summary>
/// System enclosure state based on <see href="https://www.dmtf.org/dsp/DSP0134">DMTF SMBIOS Reference Specification v.3.3.0, Chapter 7.4.2</see>.
/// </summary>
public enum SystemEnclosureState
{
    Other = 1,
    Unknown,
    Safe,
    Warning,
    Critical,
    NonRecoverable
}

/// <summary>
/// System enclosure type based on <see href="https://www.dmtf.org/dsp/DSP0134">DMTF SMBIOS Reference Specification v.3.3.0, Chapter 7.4.1</see>.
/// </summary>
public enum SystemEnclosureType
{
    Other = 1,
    Unknown,
    Desktop,
    LowProfileDesktop,
    PizzaBox,
    MiniTower,
    Tower,
    Portable,
    Laptop,
    Notebook,
    HandHeld,
    DockingStation,
    AllInOne,
    SubNotebook,
    SpaceSaving,
    LunchBox,
    MainServerChassis,
    ExpansionChassis,
    SubChassis,
    BusExpansionChassis,
    PeripheralChassis,
    RaidChassis,
    RackMountChassis,
    SealedCasePc,
    MultiSystemChassis,
    CompactPci,
    AdvancedTca,
    Blade,
    BladeEnclosure,
    Tablet,
    Convertible,
    Detachable,
    IoTGateway,
    EmbeddedPc,
    MiniPc,
    StickPc
}

/// <summary>
/// Processor family based on <see href="https://www.dmtf.org/dsp/DSP0134">DMTF SMBIOS Reference Specification v.3.3.0, Chapter 7.5.2</see>.
/// </summary>
public enum ProcessorFamily
{
    Other = 1,
    Intel8086 = 3,
    Intel80286 = 4,
    Intel386,
    Intel486,
    Intel8087,
    Intel80287,
    Intel80387,
    Intel80487,
    IntelPentium,
    IntelPentiumPro,
    IntelPentiumII,
    IntelPentiumMMX,
    IntelCeleron,
    IntelPentiumIIXeon,
    IntelPentiumIII,
    M1,
    M2,
    IntelCeleronM,
    IntelPentium4HT,
    AmdDuron = 24,
    AmdK5,
    AmdK6,
    AmdK62,
    AmdK63,
    AmdAthlon,
    Amd2900,
    AmdK62Plus,
    PowerPc,
    PowerPc601,
    PowerPc603,
    PowerPc603Plus,
    PowerPc604,
    PowerPc620,
    PowerPcx704,
    PowerPc750,
    IntelCoreDuo,
    IntelCoreDuoMobile,
    IntelCoreSoloMobile,
    IntelAtom,
    IntelCoreM,
    IntelCoreM3,
    IntelCoreM5,
    IntelCoreM7,
    Alpha,
    Alpha21064,
    Alpha21066,
    Alpha21164,
    Alpha21164Pc,
    Alpha21164a,
    Alpha21264,
    Alpha21364,
    AmdTurionIIUltraDualCoreMobileM,
    AmdTurionDualCoreMobileM,
    AmdAthlonIIDualCoreM,
    AmdOpteron6100Series,
    AmdOpteron4100Series,
    AmdOpteron6200Series,
    AmdOpteron4200Series,
    AmdFxSeries,
    Mips,
    MipsR4000,
    MipsR4200,
    MipsR4400,
    MipsR4600,
    MipsR10000,
    AmdCSeries,
    AmdESeries,
    AmdASeries,
    AmdGSeries,
    AmdZSeries,
    AmdRSeries,
    AmdOpteron4300Series,
    AmdOpteron6300Series,
    AmdOpteron3300Series,
    AmdFireProSeries,
    Sparc,
    SuperSparc,
    MicroSparcII,
    MicroSparcIIep,
    UltraSparc,
    UltraSparcII,
    UltraSparcIIi,
    UltraSparcIII,
    UltraSparcIIIi,
    Motorola68040 = 96,
    Motorola68xxx,
    Motorola68000,
    Motorola68010,
    Motorola68020,
    Motorola68030,
    AmdAthlonX4QuadCore,
    AmdOpteronX1000Series,
    AmdOpteronX2000Series,
    AmdOpteronASeries,
    AmdOpteronX3000Series,
    AmdZen,
    Hobbit = 112,
    CrusoeTm5000 = 120,
    CrusoeTm3000,
    EfficeonTm8000,
    Weitek = 128,
    IntelItanium = 130,
    AmdAthlon64,
    AmdOpteron,
    AmdSempron,
    AmdTurio64Mobile,
    AmdOpteronDualCore,
    AmdAthlon64X2DualCore,
    AmdTurion64X2Mobile,
    AmdOpteronQuadCore,
    AmdOpteronThirdGen,
    AmdPhenomFXQuadCore,
    AmdPhenomX4QuadCore,
    AmdPhenomX2DualCore,
    AmdAthlonX2DualCore,
    PaRisc,
    PaRisc8500,
    PaRisc8000,
    PaRisc7300LC,
    PaRisc7200,
    PaRisc7100LC,
    PaRisc7100,
    V30 = 160,
    IntelXeon3200QuadCoreSeries,
    IntelXeon3000DualCoreSeries,
    IntelXeon5300QuadCoreSeries,
    IntelXeon5100DualCoreSeries,
    IntelXeon5000DualCoreSeries,
    IntelXeonLVDualCore,
    IntelXeonULVDualCore,
    IntelXeon7100Series,
    IntelXeon5400Series,
    IntelXeonQuadCore,
    IntelXeon5200DualCoreSeries,
    IntelXeon7200DualCoreSeries,
    IntelXeon7300QuadCoreSeries,
    IntelXeon7400QuadCoreSeries,
    IntelXeon7400MultiCoreSeries,
    IntelPentiumIIIXeon,
    IntelPentiumIIISpeedStep,
    IntelPentium4,
    IntelXeon,
    As400,
    IntelXeonMP,
    AmdAthlonXP,
    AmdAthlonMP,
    IntelItanium2,
    IntelPentiumM,
    IntelCeleronD,
    IntelPentiumD,
    IntelPentiumExtreme,
    IntelCoreSolo,
    IntelCore2Duo = 191,
    IntelCore2Solo,
    IntelCore2Extreme,
    IntelCore2Quad,
    IntelCore2ExtremeMobile,
    IntelCore2DuoMobile,
    IntelCore2SoloMobile,
    IntelCoreI7,
    IntelCeleronDualCore,
    Ibm390,
    PowerPcG4,
    PowerPcG5,
    Esa390G6,
    ZArchitecture,
    IntelCoreI5,
    IntelCoreI3,
    IntelCoreI9,
    ViaC7M = 210,
    ViaC7D,
    ViaC7,
    ViaEden,
    IntelXeonMultiCore,
    IntelXeon3xxxDualCoreSeries,
    IntelXeon3xxxQuadCoreSeries,
    ViaNano,
    IntelXeon5xxxDualCoreSeries,
    IntelXeon5xxxQuadCoreSeries,
    IntelXeon7xxxDualCoreSeries = 221,
    IntelXeon7xxxQuadCoreSeries,
    IntelXeon7xxxMultiCoreSeries,
    IntelXeon3400MultiCoreSeries,
    AmdOpteron3000Series = 228,
    AmdSempronII,
    AmdOpteronQuadCoreEmbedded,
    AmdPhenomTripleCore,
    AmdTurionUltraDualCoreMobile,
    AmdTurionDualCoreMobile,
    AmdTurionDualCore,
    AmdAthlonDualCore,
    AmdSempronSI,
    AmdPhenomII,
    AmdAthlonII,
    AmdOpteronSixCore,
    AmdSempronM,
    IntelI860 = 250,
    IntelI960,
    ArmV7 = 256,
    ArmV8,
    HitachiSh3,
    HitachiSh4,
    Arm,
    StrongArm,
    _686,
    MediaGX,
    MII,
    WinChip,
    Dsp,
    VideoProcessor
}

/// <summary>
/// Processor characteristics based on <see href="https://www.dmtf.org/dsp/DSP0134">DMTF SMBIOS Reference Specification v.3.3.0, Chapter 7.5.9</see>.
/// </summary>
[Flags]
public enum ProcessorCharacteristics
{
    None = 0,
    _64BitCapable = 1,
    MultiCore = 2,
    HardwareThread = 4,
    ExecuteProtection = 8,
    EnhancedVirtualization = 16,
    PowerPerformanceControl = 32,
    _128BitCapable = 64
}

/// <summary>
/// Processor type based on <see href="https://www.dmtf.org/dsp/DSP0134">DMTF SMBIOS Reference Specification v.3.3.0, Chapter 7.5.1</see>.
/// </summary>
public enum ProcessorType
{
    Other = 1,
    Unknown,
    CentralProcessor,
    MathProcessor,
    DspProcessor,
    VideoProcessor
}

/// <summary>
/// Processor socket based on <see href="https://www.dmtf.org/dsp/DSP0134">DMTF SMBIOS Reference Specification v.3.3.0, Chapter 7.5.5</see>.
/// </summary>
public enum ProcessorSocket
{
    Other = 1,
    Unknown,
    DaughterBoard,
    ZifSocket,
    PiggyBack,
    None,
    LifSocket,
    Zif423 = 13,
    A,
    Zif478,
    Zif754,
    Zif940,
    Zif939,
    MPga604,
    Lga771,
    Lga775,
    S1,
    AM2,
    F,
    Lga1366,
    G34,
    AM3,
    C32,
    Lga1156,
    Lga1567,
    Pga988A,
    Bga1288,
    RPga088B,
    Bga1023,
    Bga1224,
    Lga1155,
    Lga1356,
    Lga2011,
    FS1,
    FS2,
    FM1,
    FM2,
    Lga20113,
    Lga13563,
    Lga1150,
    Bga1168,
    Bga1234,
    Bga1364,
    AM4,
    Lga1151,
    Bga1356,
    Bga1440,
    Bga1515,
    Lga36471,
    SP3,
    SP3R2,
    Lga2066,
    Bga1510,
    Bga1528,
    Lga4189
}

/// <summary>
/// System wake-up type based on <see href="https://www.dmtf.org/dsp/DSP0134">DMTF SMBIOS Reference Specification v.3.3.0, Chapter 7.2.2</see>.
/// </summary>
public enum SystemWakeUp
{
    Reserved,
    Other,
    Unknown,
    ApmTimer,
    ModemRing,
    LanRemote,
    PowerSwitch,
    PciPme,
    AcPowerRestored
}

/// <summary>
/// Cache associativity based on <see href="https://www.dmtf.org/dsp/DSP0134">DMTF SMBIOS Reference Specification v.3.3.0, Chapter 7.8.5</see>.
/// </summary>
public enum CacheAssociativity
{
    Other = 1,
    Unknown,
    DirectMapped,
    _2Way,
    _4Way,
    FullyAssociative,
    _8Way,
    _16Way,
    _12Way,
    _24Way,
    _32Way,
    _48Way,
    _64Way,
    _20Way
}

/// <summary>
/// Processor cache level.
/// </summary>
public enum CacheDesignation
{
    Other,
    L1,
    L2,
    L3
}

/// <summary>
/// Memory type.
/// </summary>
public enum MemoryType
{
    Other = 0x01,
    Unknown = 0x02,
    DRAM = 0x03,
    EDRAM = 0x04,
    VRAM = 0x05,
    SRAM = 0x06,
    RAM = 0x07,
    ROM = 0x08,
    FLASH = 0x09,
    EEPROM = 0x0a,
    FEPROM = 0x0b,
    EPROM = 0x0c,
    CDRAM = 0x0d,
    _3DRAM = 0x0e,
    SDRAM = 0x0f,
    SGRAM = 0x10,
    RDRAM = 0x11,
    DDR = 0x12,
    DDR2 = 0x13,
    DDR2_FBDIMM = 0x14,
    DDR3 = 0x18,
    FBD2 = 0x19,
    DDR4 = 0x1a,
    LPDDR = 0x1b,
    LPDDR2 = 0x1c,
    LPDDR3 = 0x1d,
    LPDDR4 = 0x1e,
    LogicalNonVolatileDevice = 0x1f,
    HBM = 0x20,
    HBM2 = 0x21,
    DDR5 = 0x22,
    LPDDR5 = 0x23
}

public class InformationBase
{
    private readonly byte[] _data;
    private readonly IList<string> _strings;

    /// <summary>
    /// Initializes a new instance of the <see cref="InformationBase" /> class.
    /// </summary>
    /// <param name="data">The data.</param>
    /// <param name="strings">The strings.</param>
    protected InformationBase(byte[] data, IList<string> strings)
    {
        _data = data;
        _strings = strings;
    }

    /// <summary>
    /// Gets the byte.
    /// </summary>
    /// <param name="offset">The offset.</param>
    /// <returns><see cref="byte" />.</returns>
    protected byte GetByte(int offset)
    {
        if (offset < _data.Length && offset >= 0)
            return _data[offset];

        return 0;
    }

    /// <summary>
    /// Gets the word.
    /// </summary>
    /// <param name="offset">The offset.</param>
    /// <returns><see cref="ushort" />.</returns>
    protected ushort GetWord(int offset)
    {
        if (offset + 1 < _data.Length && offset >= 0)
        {
            return BitConverter.ToUInt16(_data, offset);
        }

        return 0;
    }

    /// <summary>
    /// Gets the dword.
    /// </summary>
    /// <param name="offset">The offset.</param>
    /// <returns><see cref="ushort" />.</returns>
    protected uint GetDword(int offset)
    {
        if (offset + 3 < _data.Length && offset >= 0)
        {
            return BitConverter.ToUInt32(_data, offset);
        }

        return 0;
    }

    /// <summary>
    /// Gets the qword.
    /// </summary>
    /// <param name="offset">The offset.</param>
    /// <returns><see cref="ulong" />.</returns>
    protected ulong GetQword(int offset)
    {
        if (offset + 7 < _data.Length && offset >= 0)
        {
            return BitConverter.ToUInt64(_data, offset);
        }

        return 0;
    }

    /// <summary>
    /// Gets the string.
    /// </summary>
    /// <param name="offset">The offset.</param>
    /// <returns><see cref="string" />.</returns>
    protected string GetString(int offset)
    {
        if (offset < _data.Length && _data[offset] > 0 && _data[offset] <= _strings.Count)
            return _strings[_data[offset] - 1];

        return string.Empty;
    }
}

/// <summary>
/// Motherboard BIOS information obtained from the SMBIOS table.
/// </summary>
public class BiosInformation : InformationBase
{
    internal BiosInformation(string vendor, string version, string date = null, ulong? size = null) : base(null, null)
    {
        Vendor = vendor;
        Version = version;
        Date = GetDate(date);
        Size = size;
    }

    internal BiosInformation(byte[] data, IList<string> strings) : base(data, strings)
    {
        Vendor = GetString(0x04);
        Version = GetString(0x05);
        Date = GetDate(GetString(0x08));
        Size = GetSize();
    }

    /// <summary>
    /// Gets the BIOS release date.
    /// </summary>
    public DateTime? Date { get; }

    /// <summary>
    /// Gets the size of the physical device containing the BIOS.
    /// </summary>
    public ulong? Size { get; }

    /// <summary>
    /// Gets the string number of the BIOS Vendor’s Name.
    /// </summary>
    public string Vendor { get; }

    /// <summary>
    /// Gets the string number of the BIOS Version. This value is a free-form string that may contain Core and OEM version information.
    /// </summary>
    public string Version { get; }

    /// <summary>
    /// Gets the size.
    /// </summary>
    /// <returns><see cref="Nullable{Int64}" />.</returns>
    private ulong? GetSize()
    {
        int biosRomSize = GetByte(0x09);
        ushort extendedBiosRomSize = GetWord(0x18);

        bool isExtendedBiosRomSize = biosRomSize == 0xFF && extendedBiosRomSize != 0;
        if (!isExtendedBiosRomSize)
            return 65536 * (ulong)(biosRomSize + 1);

        int unit = (extendedBiosRomSize & 0xC000) >> 14;
        ulong extendedSize = (ulong)(extendedBiosRomSize & ~0xC000) * 1024 * 1024;

        switch (unit)
        {
            case 0x00: return extendedSize; // Megabytes
            case 0x01: return extendedSize * 1024; // Gigabytes - might overflow in the future
        }

        return null; // Other patterns not defined in DMI 3.2.0
    }

    /// <summary>
    /// Gets the date.
    /// </summary>
    /// <param name="date">The bios date.</param>
    /// <returns><see cref="Nullable{DateTime}" />.</returns>
    private static DateTime? GetDate(string date)
    {
        string[] parts = (date ?? string.Empty).Split('/');

        if (parts.Length == 3 &&
            int.TryParse(parts[0], out int month) &&
            int.TryParse(parts[1], out int day) &&
            int.TryParse(parts[2], out int year))
        {
            // Check if the SMBIOS specification is followed.
            if (month > 12 || day > 31)
                return null;

            return new DateTime(year < 100 ? 1900 + year : year, month, day);
        }

        return null;
    }
}

/// <summary>
/// System information obtained from the SMBIOS table.
/// </summary>
public class SystemInformation : InformationBase
{
    internal SystemInformation
    (
        string manufacturerName,
        string productName,
        string version,
        string serialNumber,
        string family,
        SystemWakeUp wakeUp = SystemWakeUp.Unknown) : base(null, null)
    {
        ManufacturerName = manufacturerName;
        ProductName = productName;
        Version = version;
        SerialNumber = serialNumber;
        Family = family;
        WakeUp = wakeUp;
    }

    internal SystemInformation(byte[] data, IList<string> strings) : base(data, strings)
    {
        ManufacturerName = GetString(0x04);
        ProductName = GetString(0x05);
        Version = GetString(0x06);
        SerialNumber = GetString(0x07);
        Family = GetString(0x1A);
        WakeUp = (SystemWakeUp)GetByte(0x18);
    }

    /// <summary>
    /// Gets the family associated with system.
    /// <para>
    /// This text string identifies the family to which a particular computer belongs. A family refers to a set of computers that are similar but not identical from a hardware or software point of
    /// view. Typically, a family is composed of different computer models, which have different configurations and pricing points. Computers in the same family often have similar branding and cosmetic
    /// features.
    /// </para>
    /// </summary>
    public string Family { get; }

    /// <summary>
    /// Gets the manufacturer name associated with system.
    /// </summary>
    public string ManufacturerName { get; }

    /// <summary>
    /// Gets the product name associated with system.
    /// </summary>
    public string ProductName { get; }

    /// <summary>
    /// Gets the serial number string associated with system.
    /// </summary>
    public string SerialNumber { get; }

    /// <summary>
    /// Gets the version string associated with system.
    /// </summary>
    public string Version { get; }

    /// <summary>
    /// Gets <inheritdoc cref="SystemWakeUp" />
    /// </summary>
    public SystemWakeUp WakeUp { get; }
}

/// <summary>
/// System enclosure obtained from the SMBIOS table.
/// </summary>
public class SystemEnclosure : InformationBase
{
    internal SystemEnclosure(byte[] data, IList<string> strings) : base(data, strings)
    {
        ManufacturerName = GetString(0x04).Trim();
        Version = GetString(0x06).Trim();
        SerialNumber = GetString(0x07).Trim();
        AssetTag = GetString(0x08).Trim();
        RackHeight = GetByte(0x11);
        PowerCords = GetByte(0x12);
        SKU = GetString(0x15).Trim();
        LockDetected = (GetByte(0x05) & 128) == 128;
        Type = (SystemEnclosureType)(GetByte(0x05) & 127);
        BootUpState = (SystemEnclosureState)GetByte(0x09);
        PowerSupplyState = (SystemEnclosureState)GetByte(0x0A);
        ThermalState = (SystemEnclosureState)GetByte(0x0B);
        SecurityStatus = (SystemEnclosureSecurityStatus)GetByte(0x0C);
    }

    /// <summary>
    /// Gets the asset tag associated with the enclosure or chassis.
    /// </summary>
    public string AssetTag { get; }

    /// <summary>
    /// Gets <inheritdoc cref="SystemEnclosureState" />
    /// </summary>
    public SystemEnclosureState BootUpState { get; }

    /// <summary>
    /// Gets or sets the system enclosure lock.
    /// </summary>
    /// <returns>System enclosure lock is present if <see langword="true" />. Otherwise, either a lock is not present or it is unknown if the enclosure has a lock.</returns>
    public bool LockDetected { get; set; }

    /// <summary>
    /// Gets the string describing the chassis or enclosure manufacturer name.
    /// </summary>
    public string ManufacturerName { get; }

    /// <summary>
    /// Gets the number of power cords associated with the enclosure or chassis.
    /// </summary>
    public byte PowerCords { get; }

    /// <summary>
    /// Gets the state of the enclosure’s power supply (or supplies) when last booted.
    /// </summary>
    public SystemEnclosureState PowerSupplyState { get; }

    /// <summary>
    /// Gets the height of the enclosure, in 'U's. A U is a standard unit of measure for the height of a rack or rack-mountable component and is equal to 1.75 inches or 4.445 cm. A value of <c>0</c>
    /// indicates that the enclosure height is unspecified.
    /// </summary>
    public byte RackHeight { get; }

    /// <summary>
    /// Gets the physical security status of the enclosure when last booted.
    /// </summary>
    public SystemEnclosureSecurityStatus SecurityStatus { get; set; }

    /// <summary>
    /// Gets the string describing the chassis or enclosure serial number.
    /// </summary>
    public string SerialNumber { get; }

    /// <summary>
    /// Gets the string describing the chassis or enclosure SKU number.
    /// </summary>
    public string SKU { get; }

    /// <summary>
    /// Gets the thermal state of the enclosure when last booted.
    /// </summary>
    public SystemEnclosureState ThermalState { get; }

    /// <summary>
    /// Gets <inheritdoc cref="Type" />
    /// </summary>
    public SystemEnclosureType Type { get; }

    /// <summary>
    /// Gets the number of null-terminated string representing the chassis or enclosure version.
    /// </summary>
    public string Version { get; }
}

/// <summary>
/// Motherboard information obtained from the SMBIOS table.
/// </summary>
public class BaseBoardInformation : InformationBase
{
    internal BaseBoardInformation(string manufacturerName, string productName, string version, string serialNumber) : base(null, null)
    {
        ManufacturerName = manufacturerName;
        ProductName = productName;
        Version = version;
        SerialNumber = serialNumber;
    }

    internal BaseBoardInformation(byte[] data, IList<string> strings) : base(data, strings)
    {
        ManufacturerName = GetString(0x04).Trim();
        ProductName = GetString(0x05).Trim();
        Version = GetString(0x06).Trim();
        SerialNumber = GetString(0x07).Trim();
    }

    /// <summary>
    /// Gets the value that represents the manufacturer's name.
    /// </summary>
    public string ManufacturerName { get; }

    /// <summary>
    /// Gets the value that represents the motherboard's name.
    /// </summary>
    public string ProductName { get; }

    /// <summary>
    /// Gets the value that represents the motherboard's serial number.
    /// </summary>
    public string SerialNumber { get; }

    /// <summary>
    /// Gets the value that represents the motherboard's revision number.
    /// </summary>
    public string Version { get; }
}

/// <summary>
/// Processor information obtained from the SMBIOS table.
/// </summary>
public class ProcessorInformation : InformationBase
{
    internal ProcessorInformation(byte[] data, IList<string> strings) : base(data, strings)
    {
        SocketDesignation = GetString(0x04).Trim();
        ManufacturerName = GetString(0x07).Trim();
        Version = GetString(0x10).Trim();
        CoreCount = GetByte(0x23) != 255 ? GetByte(0x23) : GetWord(0x2A);
        CoreEnabled = GetByte(0x24) != 255 ? GetByte(0x24) : GetWord(0x2C);
        ThreadCount = GetByte(0x25) != 255 ? GetByte(0x25) : GetWord(0x2E);
        ExternalClock = GetWord(0x12);
        MaxSpeed = GetWord(0x14);
        CurrentSpeed = GetWord(0x16);
        Serial = GetString(0x20).Trim();
        Id = GetQword(0x08);
        Handle = GetWord(0x02);

        byte characteristics1 = GetByte(0x26);
        byte characteristics2 = GetByte(0x27);

        Characteristics = ProcessorCharacteristics.None;
        if (IsBitSet(characteristics1, 2))
            Characteristics |= ProcessorCharacteristics._64BitCapable;

        if (IsBitSet(characteristics1, 3))
            Characteristics |= ProcessorCharacteristics.MultiCore;

        if (IsBitSet(characteristics1, 4))
            Characteristics |= ProcessorCharacteristics.HardwareThread;

        if (IsBitSet(characteristics1, 5))
            Characteristics |= ProcessorCharacteristics.ExecuteProtection;

        if (IsBitSet(characteristics1, 6))
            Characteristics |= ProcessorCharacteristics.EnhancedVirtualization;

        if (IsBitSet(characteristics1, 7))
            Characteristics |= ProcessorCharacteristics.PowerPerformanceControl;

        if (IsBitSet(characteristics2, 0))
            Characteristics |= ProcessorCharacteristics._128BitCapable;

        ProcessorType = (ProcessorType)GetByte(0x05);
        Socket = (ProcessorSocket)GetByte(0x19);

        int family = GetByte(0x06);
        Family = (ProcessorFamily)(family == 254 ? GetWord(0x28) : family);

        L1CacheHandle = GetWord(0x1A);
        L2CacheHandle = GetWord(0x1C);
        L3CacheHandle = GetWord(0x1E);

        bool IsBitSet(byte b, int pos)
        {
            return (b & (1 << pos)) != 0;
        }
    }

    /// <summary>
    /// Gets the characteristics of the processor.
    /// </summary>
    public ProcessorCharacteristics Characteristics { get; }

    /// <summary>
    /// Gets the value that represents the number of cores per processor socket.
    /// </summary>
    public ushort CoreCount { get; }

    /// <summary>
    /// Gets the value that represents the number of enabled cores per processor socket.
    /// </summary>
    public ushort CoreEnabled { get; }

    /// <summary>
    /// Gets the value that represents the current processor speed (in MHz).
    /// </summary>
    public ushort CurrentSpeed { get; }

    /// <summary>
    /// Gets the external Clock Frequency, in MHz. If the value is unknown, the field is set to 0.
    /// </summary>
    public ushort ExternalClock { get; }

    /// <summary>
    /// Gets <inheritdoc cref="ProcessorFamily" />
    /// </summary>
    public ProcessorFamily Family { get; }

    /// <summary>
    /// Gets the handle.
    /// </summary>
    /// <value>The handle.</value>
    public ushort Handle { get; }

    /// <summary>
    /// Gets the identifier.
    /// </summary>
    public ulong Id { get; }

    /// <summary>
    /// Gets the L1 cache handle.
    /// </summary>
    public ushort L1CacheHandle { get; }

    /// <summary>
    /// Gets the L2 cache handle.
    /// </summary>
    public ushort L2CacheHandle { get; }

    /// <summary>
    /// Gets the L3 cache handle.
    /// </summary>
    public ushort L3CacheHandle { get; }

    /// <summary>
    /// Gets the string number of Processor Manufacturer.
    /// </summary>
    public string ManufacturerName { get; }

    /// <summary>
    /// Gets the value that represents the maximum processor speed (in MHz) supported by the system for this processor socket.
    /// </summary>
    public ushort MaxSpeed { get; }

    /// <summary>
    /// Gets <inheritdoc cref="LibreHardwareMonitor.Hardware.ProcessorType" />
    /// </summary>
    public ProcessorType ProcessorType { get; }

    /// <summary>
    /// Gets the value that represents the string number for the serial number of this processor.
    /// <para>This value is set by the manufacturer and normally not changeable.</para>
    /// </summary>
    public string Serial { get; }

    /// <summary>
    /// Gets <inheritdoc cref="ProcessorSocket" />
    /// </summary>
    public ProcessorSocket Socket { get; }

    /// <summary>
    /// Gets the string number for Reference Designation.
    /// </summary>
    public string SocketDesignation { get; }

    /// <summary>
    /// Gets the value that represents the number of threads per processor socket.
    /// </summary>
    public ushort ThreadCount { get; }

    /// <summary>
    /// Gets the value that represents the string number describing the Processor.
    /// </summary>
    public string Version { get; }
}

/// <summary>
/// Cache information obtained from the SMBIOS table.
/// </summary>
public class CacheInformation : InformationBase
{
    internal CacheInformation(byte[] data, IList<string> strings) : base(data, strings)
    {
        Handle = GetWord(0x02);
        Designation = GetCacheDesignation();
        Associativity = (CacheAssociativity)GetByte(0x12);
        Size = GetWord(0x09);
    }

    /// <summary>
    /// Gets <inheritdoc cref="CacheAssociativity" />
    /// </summary>
    public CacheAssociativity Associativity { get; }

    /// <summary>
    /// Gets <inheritdoc cref="CacheDesignation" />
    /// </summary>
    public CacheDesignation Designation { get; }

    /// <summary>
    /// Gets the handle.
    /// </summary>
    public ushort Handle { get; }

    /// <summary>
    /// Gets the value that represents the installed cache size.
    /// </summary>
    public ushort Size { get; }

    /// <summary>
    /// Gets the cache designation.
    /// </summary>
    /// <returns><see cref="CacheDesignation" />.</returns>
    private CacheDesignation GetCacheDesignation()
    {
        string rawCacheType = GetString(0x04);

        if (rawCacheType.Contains("L1"))
            return CacheDesignation.L1;

        if (rawCacheType.Contains("L2"))
            return CacheDesignation.L2;

        if (rawCacheType.Contains("L3"))
            return CacheDesignation.L3;

        return CacheDesignation.Other;
    }
}

/// <summary>
/// Memory information obtained from the SMBIOS table.
/// </summary>
public class MemoryDevice : InformationBase
{
    internal MemoryDevice(byte[] data, IList<string> strings) : base(data, strings)
    {
        DeviceLocator = GetString(0x10).Trim();
        BankLocator = GetString(0x11).Trim();
        ManufacturerName = GetString(0x17).Trim();
        SerialNumber = GetString(0x18).Trim();
        PartNumber = GetString(0x1A).Trim();
        Speed = GetWord(0x15);
        ConfiguredSpeed = GetWord(0x20);
        ConfiguredVoltage = GetWord(0x26);
        Size = GetWord(0x0C);
        if (Size == 0x7FFF)
            Size = GetDword(0x1C);
        Type = (MemoryType)GetByte(0x12);
    }

    /// <summary>
    /// Gets the string number of the string that identifies the physically labeled bank where the memory device is located.
    /// </summary>
    public string BankLocator { get; }

    /// <summary>
    /// Gets the string number of the string that identifies the physically-labeled socket or board position where the memory device is located.
    /// </summary>
    public string DeviceLocator { get; }

    /// <summary>
    /// Gets the string number for the manufacturer of this memory device.
    /// </summary>
    public string ManufacturerName { get; }

    /// <summary>
    /// Gets the string number for the part number of this memory device.
    /// </summary>
    public string PartNumber { get; }

    /// <summary>
    /// Gets the string number for the serial number of this memory device.
    /// </summary>
    public string SerialNumber { get; }

    /// <summary>
    /// Gets the size of the memory device.
    /// If the value is 0, no memory device is installed in the socket.
    /// If the value is 0xFFFF, the size is unknown.
    /// </summary>
    public uint Size { get; }

    /// <summary>
    /// Gets the value that identifies the maximum capable speed of the device, in mega transfers per second (MT/s).
    /// </summary>
    public ushort Speed { get; }

    /// <summary>
    /// Gets the configured speed of the device, in mega transfers per second (MT/s).
    /// </summary>
    public ushort ConfiguredSpeed { get; }

    /// <summary>
    /// Gets the configured voltage of this memory device, in millivolts (mV).
    /// </summary>
    public ushort ConfiguredVoltage { get; }

    /// <summary>
    /// Gets the type of this memory device.
    /// </summary>
    /// <value>The type.</value>
    public MemoryType Type { get; }
}

/// <summary>
/// Reads and processes information encoded in an SMBIOS table.
/// </summary>
public class SMBios
{
    private readonly byte[] _raw;
    private readonly Version _version;

    /// <summary>
    /// Initializes a new instance of the <see cref="SMBios" /> class.
    /// </summary>
    public SMBios()
    {
        if (Software.OperatingSystem.IsUnix)
        {
            _raw = null;

            string boardVendor = ReadSysFs("/sys/class/dmi/id/board_vendor");
            string boardName = ReadSysFs("/sys/class/dmi/id/board_name");
            string boardVersion = ReadSysFs("/sys/class/dmi/id/board_version");
            Board = new BaseBoardInformation(boardVendor, boardName, boardVersion, null);

            string systemVendor = ReadSysFs("/sys/class/dmi/id/sys_vendor");
            string productName = ReadSysFs("/sys/class/dmi/id/product_name");
            string productVersion = ReadSysFs("/sys/class/dmi/id/product_version");
            System = new SystemInformation(systemVendor, productName, productVersion, null, null);

            string biosVendor = ReadSysFs("/sys/class/dmi/id/bios_vendor");
            string biosVersion = ReadSysFs("/sys/class/dmi/id/bios_version");
            string biosDate = ReadSysFs("/sys/class/dmi/id/bios_date");
            Bios = new BiosInformation(biosVendor, biosVersion, biosDate);

            MemoryDevices = Array.Empty<MemoryDevice>();
            ProcessorCaches = Array.Empty<CacheInformation>();
        }
        else
        {
            List<MemoryDevice> memoryDeviceList = new();
            List<CacheInformation> processorCacheList = new();
            List<ProcessorInformation> processorInformationList = new();

            string[] tables = FirmwareTable.EnumerateTables(FIRMWARE_TABLE_PROVIDER.RSMB);
            if (tables is { Length: > 0 })
            {
                _raw = FirmwareTable.GetTable(FIRMWARE_TABLE_PROVIDER.RSMB, tables[0]);
                if (_raw == null || _raw.Length == 0)
                    return;

                byte majorVersion = _raw[1];
                byte minorVersion = _raw[2];

                if (majorVersion > 0 || minorVersion > 0)
                    _version = new Version(majorVersion, minorVersion);

                if (_raw is { Length: > 0 })
                {
                    int offset = 8;
                    byte type = _raw[offset];

                    while (offset + 4 < _raw.Length && type != 127)
                    {
                        type = _raw[offset];
                        int length = _raw[offset + 1];

                        if (offset + length > _raw.Length)
                            break;

                        byte[] data = new byte[length];
                        Array.Copy(_raw, offset, data, 0, length);
                        offset += length;

                        List<string> strings = new();
                        if (offset < _raw.Length && _raw[offset] == 0)
                            offset++;

                        while (offset < _raw.Length && _raw[offset] != 0)
                        {
                            StringBuilder stringBuilder = new();

                            while (offset < _raw.Length && _raw[offset] != 0)
                            {
                                stringBuilder.Append((char)_raw[offset]);
                                offset++;
                            }

                            offset++;

                            strings.Add(stringBuilder.ToString());
                        }

                        offset++;
                        switch (type)
                        {
                            case 0x00:
                                Bios = new BiosInformation(data, strings);
                                break;
                            case 0x01:
                                System = new SystemInformation(data, strings);
                                break;
                            case 0x02:
                                Board = new BaseBoardInformation(data, strings);
                                break;
                            case 0x03:
                                SystemEnclosure = new SystemEnclosure(data, strings);
                                break;
                            case 0x04:
                                processorInformationList.Add(new ProcessorInformation(data, strings));
                                break;
                            case 0x07:
                                processorCacheList.Add(new CacheInformation(data, strings));
                                break;
                            case 0x11:
                                memoryDeviceList.Add(new MemoryDevice(data, strings));
                                break;
                        }
                    }
                }
            }

            MemoryDevices = memoryDeviceList.ToArray();
            ProcessorCaches = processorCacheList.ToArray();
            Processors = processorInformationList.ToArray();
        }
    }

    /// <summary>
    /// Gets <inheritdoc cref="BiosInformation" />
    /// </summary>
    public BiosInformation Bios { get; }

    /// <summary>
    /// Gets <inheritdoc cref="BaseBoardInformation" />
    /// </summary>
    public BaseBoardInformation Board { get; }

    /// <summary>
    /// Gets <inheritdoc cref="MemoryDevice" />
    /// </summary>
    public MemoryDevice[] MemoryDevices { get; }

    /// <summary>
    /// Gets <inheritdoc cref="CacheInformation" />
    /// </summary>
    public CacheInformation[] ProcessorCaches { get; }

    /// <summary>
    /// Gets <inheritdoc cref="ProcessorInformation" />
    /// </summary>
    public ProcessorInformation[] Processors { get; }

    /// <summary>
    /// Gets <inheritdoc cref="SystemInformation" />
    /// </summary>
    public SystemInformation System { get; }

    /// <summary>
    /// Gets <inheritdoc cref="LibreHardwareMonitor.Hardware.SystemEnclosure" />
    /// </summary>
    public SystemEnclosure SystemEnclosure { get; }

    private static string ReadSysFs(string path)
    {
        try
        {
            if (File.Exists(path))
            {
                using StreamReader reader = new(path);

                return reader.ReadLine();
            }

            return string.Empty;
        }
        catch
        {
            return string.Empty;
        }
    }

    /// <summary>
    /// Report containing most of the information that could be read from the SMBIOS table.
    /// </summary>
    /// <returns>A formatted text string with computer information and the entire SMBIOS table.</returns>
    public string GetReport()
    {
        StringBuilder r = new();

        if (_version != null)
        {
            r.Append("SMBios Version: ");
            r.AppendLine(_version.ToString(2));
            r.AppendLine();
        }

        if (Bios != null)
        {
            r.Append("BIOS Vendor: ");
            r.AppendLine(Bios.Vendor);
            r.Append("BIOS Version: ");
            r.AppendLine(Bios.Version);
            if (Bios.Date != null)
            {
                r.Append("BIOS Date: ");
                r.AppendLine(Bios.Date.Value.ToShortDateString());
            }

            if (Bios.Size != null)
            {
                const int megabyte = 1024 * 1024;
                r.Append("BIOS Size: ");
                if (Bios.Size > megabyte)
                    r.AppendLine((Bios.Size.Value / megabyte) + " MB");
                else
                    r.AppendLine((Bios.Size.Value / 1024) + " KB");
            }

            r.AppendLine();
        }

        if (System != null)
        {
            r.Append("System Manufacturer: ");
            r.AppendLine(System.ManufacturerName);
            r.Append("System Name: ");
            r.AppendLine(System.ProductName);
            r.Append("System Version: ");
            r.AppendLine(System.Version);
            r.Append("System Wakeup: ");
            r.AppendLine(System.WakeUp.ToString());
            r.AppendLine();
        }

        if (Board != null)
        {
            r.Append("Motherboard Manufacturer: ");
            r.AppendLine(Board.ManufacturerName);
            r.Append("Motherboard Name: ");
            r.AppendLine(Board.ProductName);
            r.Append("Motherboard Version: ");
            r.AppendLine(Board.Version);
            r.Append("Motherboard Serial: ");
            r.AppendLine(Board.SerialNumber);
            r.AppendLine();
        }

        if (SystemEnclosure != null)
        {
            r.Append("System Enclosure Type: ");
            r.AppendLine(SystemEnclosure.Type.ToString());
            r.Append("System Enclosure Manufacturer: ");
            r.AppendLine(SystemEnclosure.ManufacturerName);
            r.Append("System Enclosure Version: ");
            r.AppendLine(SystemEnclosure.Version);
            r.Append("System Enclosure Serial: ");
            r.AppendLine(SystemEnclosure.SerialNumber);
            r.Append("System Enclosure Asset Tag: ");
            r.AppendLine(SystemEnclosure.AssetTag);
            if (!string.IsNullOrEmpty(SystemEnclosure.SKU))
            {
                r.Append("System Enclosure SKU: ");
                r.AppendLine(SystemEnclosure.SKU);
            }

            r.Append("System Enclosure Boot Up State: ");
            r.AppendLine(SystemEnclosure.BootUpState.ToString());
            r.Append("System Enclosure Power Supply State: ");
            r.AppendLine(SystemEnclosure.PowerSupplyState.ToString());
            r.Append("System Enclosure Thermal State: ");
            r.AppendLine(SystemEnclosure.ThermalState.ToString());
            r.Append("System Enclosure Power Cords: ");
            r.AppendLine(SystemEnclosure.PowerCords.ToString());
            if (SystemEnclosure.RackHeight > 0)
            {
                r.Append("System Enclosure Rack Height: ");
                r.AppendLine(SystemEnclosure.RackHeight.ToString());
            }

            r.Append("System Enclosure Lock Detected: ");
            r.AppendLine(SystemEnclosure.LockDetected ? "Yes" : "No");
            r.Append("System Enclosure Security Status: ");
            r.AppendLine(SystemEnclosure.SecurityStatus.ToString());
            r.AppendLine();
        }

        if (Processors != null)
        {
            foreach (ProcessorInformation processor in Processors)
            {
                r.Append("Processor Manufacturer: ");
                r.AppendLine(processor.ManufacturerName);
                r.Append("Processor Type: ");
                r.AppendLine(processor.ProcessorType.ToString());
                r.Append("Processor Version: ");
                r.AppendLine(processor.Version);
                r.Append("Processor Serial: ");
                r.AppendLine(processor.Serial);
                r.Append("Processor Socket Designation: ");
                r.AppendLine(processor.SocketDesignation);
                r.Append("Processor Socket: ");
                r.AppendLine(processor.Socket.ToString());
                r.Append("Processor Version: ");
                r.AppendLine(processor.Version);
                r.Append("Processor Family: ");
                r.AppendLine(processor.Family.ToString());
                r.Append("Processor Core Count: ");
                r.AppendLine(processor.CoreCount.ToString());
                r.Append("Processor Core Enabled: ");
                r.AppendLine(processor.CoreEnabled.ToString());
                r.Append("Processor Thread Count: ");
                r.AppendLine(processor.ThreadCount.ToString());
                r.Append("Processor External Clock: ");
                r.Append(processor.ExternalClock);
                r.AppendLine(" Mhz");
                r.Append("Processor Max Speed: ");
                r.Append(processor.MaxSpeed);
                r.AppendLine(" Mhz");
                r.Append("Processor Current Speed: ");
                r.Append(processor.CurrentSpeed);
                r.AppendLine(" Mhz");
                r.AppendLine();
            }
        }

        if (ProcessorCaches != null)
        {
            foreach (CacheInformation processorCaches in ProcessorCaches)
            {
                r.Append("Cache [" + processorCaches.Designation + "] Size: ");
                r.AppendLine(processorCaches.Size.ToString());
                r.Append("Cache [" + processorCaches.Designation + "] Associativity: ");
                r.AppendLine(processorCaches.Associativity.ToString().Replace("_", string.Empty));
                r.AppendLine();
            }
        }

        for (int i = 0; i < MemoryDevices.Length; i++)
        {
            r.Append("Memory Device [" + i + "] Manufacturer: ");
            r.AppendLine(MemoryDevices[i].ManufacturerName);
            r.Append("Memory Device [" + i + "] Part Number: ");
            r.AppendLine(MemoryDevices[i].PartNumber);
            r.Append("Memory Device [" + i + "] Device Locator: ");
            r.AppendLine(MemoryDevices[i].DeviceLocator);
            r.Append("Memory Device [" + i + "] Bank Locator: ");
            r.AppendLine(MemoryDevices[i].BankLocator);
            r.Append("Memory Device [" + i + "] Speed: ");
            r.AppendLine(MemoryDevices[i].Speed.ToString());
            r.Append("Memory Device [" + i + "] Configured Speed: ");
            r.AppendLine(MemoryDevices[i].ConfiguredSpeed.ToString());
            r.Append("Memory Device [" + i + "] Configured Voltage: ");
            r.AppendLine(MemoryDevices[i].ConfiguredVoltage.ToString());
            r.Append("Memory Device [" + i + "] Size: ");
            r.Append(MemoryDevices[i].Size.ToString());
            r.AppendLine(" MB");
            r.AppendLine();
        }

        if (_raw != null)
        {
            string base64 = Convert.ToBase64String(_raw);
            r.AppendLine("SMBios Table");
            r.AppendLine();

            for (int i = 0; i < Math.Ceiling(base64.Length / 64.0); i++)
            {
                r.Append(" ");
                for (int j = 0; j < 0x40; j++)
                {
                    int index = (i << 6) | j;
                    if (index < base64.Length)
                    {
                        r.Append(base64[index]);
                    }
                }

                r.AppendLine();
            }

            r.AppendLine();
        }

        return r.ToString();
    }
}

```

`LibreHardwareMonitorLib/Hardware/Sensor.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.IO.Compression;

namespace LibreHardwareMonitor.Hardware;

internal class Sensor : ISensor
{
    private readonly string _defaultName;
    private readonly Hardware _hardware;
    private readonly ISettings _settings;
    private readonly bool _trackMinMax;
    private readonly List<SensorValue> _values = new();
    private int _count;
    private float? _currentValue;
    private string _name;
    private float _sum;
    private TimeSpan _valuesTimeWindow = TimeSpan.FromDays(1.0);

    public Sensor(string name, int index, SensorType sensorType, Hardware hardware, ISettings settings) :
        this(name, index, sensorType, hardware, null, settings)
    { }

    public Sensor(string name, int index, SensorType sensorType, Hardware hardware, ParameterDescription[] parameterDescriptions, ISettings settings) :
        this(name, index, false, sensorType, hardware, parameterDescriptions, settings)
    { }

    public Sensor
    (
        string name,
        int index,
        bool defaultHidden,
        SensorType sensorType,
        Hardware hardware,
        ParameterDescription[] parameterDescriptions,
        ISettings settings,
        bool disableHistory = false)
    {
        Index = index;
        IsDefaultHidden = defaultHidden;
        SensorType = sensorType;
        _hardware = hardware;

        Parameter[] parameters = new Parameter[parameterDescriptions?.Length ?? 0];
        for (int i = 0; i < parameters.Length; i++)
        {
            if (parameterDescriptions != null)
                parameters[i] = new Parameter(parameterDescriptions[i], this, settings);
        }

        Parameters = parameters;

        _settings = settings;
        _defaultName = name;
        _name = settings.GetValue(new Identifier(Identifier, "name").ToString(), name);
        _trackMinMax = !disableHistory;
        if (disableHistory)
        {
            _valuesTimeWindow = TimeSpan.Zero;
        }

        GetSensorValuesFromSettings();

        hardware.Closing += delegate { SetSensorValuesToSettings(); };
    }

    public IControl Control { get; internal set; }

    public IHardware Hardware
    {
        get { return _hardware; }
    }

    public Identifier Identifier => field ??= new Identifier(_hardware.Identifier, SensorType.ToString().ToLowerInvariant(), Index.ToString(CultureInfo.InvariantCulture));

    public int Index { get; }

    public bool IsDefaultHidden { get; }

    public float? Max { get; private set; }

    public float? Min { get; private set; }

    public string Name
    {
        get { return _name; }
        set
        {
            _name = !string.IsNullOrEmpty(value) ? value : _defaultName;

            _settings.SetValue(new Identifier(Identifier, "name").ToString(), _name);
        }
    }

    public IReadOnlyList<IParameter> Parameters { get; }

    public SensorType SensorType { get; }

    public virtual float? Value
    {
        get { return _currentValue; }
        set
        {
            if (_valuesTimeWindow != TimeSpan.Zero)
            {
                DateTime now = DateTime.UtcNow;
                while (_values.Count > 0 && now - _values[0].Time > _valuesTimeWindow)
                    _values.RemoveAt(0);

                if (value.HasValue)
                {
                    _sum += value.Value;
                    _count++;
                    if (_count == 4)
                    {
                        AppendValue(_sum / _count, now);
                        _sum = 0;
                        _count = 0;
                    }
                }
            }

            _currentValue = value;
            if (_trackMinMax)
            {
                if (value.HasValue && !float.IsNaN(value.Value) && !float.IsInfinity(value.Value))
                {
                    if (!Min.HasValue || Min > value)
                        Min = value;

                    if (!Max.HasValue || Max < value)
                        Max = value;
                }
            }
        }
    }

    public IEnumerable<SensorValue> Values
    {
        get { return _values; }
    }

    public TimeSpan ValuesTimeWindow
    {
        get { return _valuesTimeWindow; }
        set
        {
            _valuesTimeWindow = value;
            if (value == TimeSpan.Zero)
                _values.Clear();
        }
    }

    public void ResetMin()
    {
        Min = null;
    }

    public void ResetMax()
    {
        Max = null;
    }

    public void ClearValues()
    {
        _values.Clear();
    }

    public void Accept(IVisitor visitor)
    {
        if (visitor == null)
            throw new ArgumentNullException(nameof(visitor));

        visitor.VisitSensor(this);
    }

    public void Traverse(IVisitor visitor)
    {
        foreach (IParameter parameter in Parameters)
            parameter.Accept(visitor);
    }

    private void SetSensorValuesToSettings()
    {
        using MemoryStream memoryStream = new();
        using GZipStream gZipStream = new(memoryStream, CompressionMode.Compress);
        using BufferedStream outputStream = new(gZipStream, 65536);
        using (BinaryWriter binaryWriter = new(outputStream))
        {
            long t = 0;

            foreach (SensorValue sensorValue in _values)
            {
                long v = sensorValue.Time.ToBinary();
                binaryWriter.Write(v - t);
                t = v;
                binaryWriter.Write(sensorValue.Value);
            }

            binaryWriter.Flush();
        }

        _settings.SetValue(new Identifier(Identifier, "values").ToString(), Convert.ToBase64String(memoryStream.ToArray()));
    }

    private void GetSensorValuesFromSettings()
    {
        string name = new Identifier(Identifier, "values").ToString();
        string s = _settings.GetValue(name, null);

        if (!string.IsNullOrEmpty(s))
        {
            try
            {
                byte[] array = Convert.FromBase64String(s);
                DateTime now = DateTime.UtcNow;

                using MemoryStream memoryStream = new(array);
                using GZipStream gZipStream = new(memoryStream, CompressionMode.Decompress);
                using MemoryStream destination = new();

                gZipStream.CopyTo(destination);
                destination.Seek(0, SeekOrigin.Begin);

                using BinaryReader reader = new(destination);
                try
                {
                    long t = 0;
                    long readLen = reader.BaseStream.Length - reader.BaseStream.Position;
                    while (readLen > 0)
                    {
                        t += reader.ReadInt64();
                        DateTime time = DateTime.FromBinary(t);
                        if (time > now)
                            break;

                        float value = reader.ReadSingle();
                        AppendValue(value, time);
                        readLen = reader.BaseStream.Length - reader.BaseStream.Position;
                    }
                }
                catch (EndOfStreamException)
                { }
            }
            catch
            {
                // Ignored.
            }
        }

        if (_values.Count > 0)
            AppendValue(float.NaN, DateTime.UtcNow);

        //remove the value string from the settings to reduce memory usage
        _settings.Remove(name);
    }

    private void AppendValue(float value, DateTime time)
    {
        if (_values.Count >= 2 && _values[_values.Count - 1].Value == value && _values[_values.Count - 2].Value == value)
        {
            _values[_values.Count - 1] = new SensorValue(value, time);
            return;
        }

        _values.Add(new SensorValue(value, time));
    }
}

```

`LibreHardwareMonitorLib/Hardware/SensorVisitor.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;

namespace LibreHardwareMonitor.Hardware;

/// <summary>
/// Observer making calls to selected component <see cref="ISensor"/>'s.
/// </summary>
public class SensorVisitor : IVisitor
{
    private readonly SensorEventHandler _handler;

    /// <summary>
    /// Creates a new observer instance.
    /// </summary>
    /// <param name="handler">Instance of the <see cref="SensorEventHandler"/> that triggers events during visiting the <see cref="ISensor"/>.</param>
    public SensorVisitor(SensorEventHandler handler)
    {
        _handler = handler ?? throw new ArgumentNullException(nameof(handler));
    }

    /// <summary>
    /// Goes through all the components of the specified <see cref="IComputer"/> with its <see cref="IElement.Traverse(IVisitor)"/>.
    /// </summary>
    /// <param name="computer">Computer class instance that is derived from the <see cref="IComputer"/> interface.</param>
    public void VisitComputer(IComputer computer)
    {
        if (computer == null)
            throw new ArgumentNullException(nameof(computer));

        computer.Traverse(this);
    }

    /// <summary>
    /// Goes through all the components of the specified <see cref="IHardware"/> with its <see cref="IElement.Traverse(IVisitor)"/>.
    /// </summary>
    /// <param name="hardware">Hardware class instance that is derived from the <see cref="IHardware"/> interface.</param>
    public void VisitHardware(IHardware hardware)
    {
        if (hardware == null)
            throw new ArgumentNullException(nameof(hardware));

        hardware.Traverse(this);
    }

    /// <summary>
    /// Goes through all the components of the specified <see cref="ISensor"/> using <see cref="SensorEventHandler"/>.
    /// </summary>
    /// <param name="sensor">Sensor class instance that is derived from the <see cref="ISensor"/> interface.</param>
    public void VisitSensor(ISensor sensor)
    {
        _handler(sensor);
    }

    /// <summary>
    /// Goes through all the components of the specified <see cref="IParameter"/>.
    /// <para>
    /// <see cref="NotImplementedException"/>
    /// </para>
    /// </summary>
    /// <param name="parameter">Parameter class instance that is derived from the <see cref="IParameter"/> interface.</param>
    public void VisitParameter(IParameter parameter)
    { }
}
```

`LibreHardwareMonitorLib/Hardware/Storage/ISmart.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Collections.Generic;

namespace LibreHardwareMonitor.Hardware.Storage;

public interface ISmart
{
    /// <summary>
    /// Gets all available smart attributes.
    /// </summary>
    IReadOnlyList<SmartAttribute> Attributes { get; }
}

```

`LibreHardwareMonitorLib/Hardware/Storage/SmartAttribute.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware.Storage;

public sealed class SmartAttribute
{
    /// <summary>
    /// Initializes a new instance of the <see cref="SmartAttribute"/> class.
    /// </summary>
    /// <param name="smartAttribute">The SMART attribute.</param>
    /// <param name="sensorType">
    /// Type of the sensor or null if no sensor is to
    /// be created.
    /// </param>
    /// <param name="sensorChannel">
    /// If there exists more than one attribute with
    /// the same sensor channel and type, then a sensor is created only for the
    /// first attribute.
    /// </param>
    /// <param name="sensorName">
    /// The name to be used for the sensor, or null if
    /// no sensor is created.
    /// </param>
    /// <param name="defaultHiddenSensor">True to hide the sensor initially.</param>
    public SmartAttribute(DiskInfoToolkit.SmartAttribute smartAttribute, SensorType? sensorType, int sensorChannel, string sensorName, bool defaultHiddenSensor = false)
    {
        Attribute = smartAttribute;
        SensorType = sensorType;
        SensorChannel = sensorChannel;
        SensorName = sensorName ?? Name;
        IsHiddenByDefault = defaultHiddenSensor;
    }

    public DiskInfoToolkit.SmartAttribute Attribute { get; internal set; }

    public byte Id => Attribute.Info.ID;
    public string Name => Attribute.Info.Name;

    public SensorType? SensorType { get; }
    public int SensorChannel { get; }
    public string SensorName { get; }
    public bool IsHiddenByDefault { get; }

    public float Value => Attribute.Attribute.RawValueULong;
    public byte Threshold => Attribute.Attribute.Threshold;
}

```

`LibreHardwareMonitorLib/Hardware/Storage/SmartAttributeTranslator.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Collections.Generic;
using DiskInfoToolkit.Interop.Enums;

namespace LibreHardwareMonitor.Hardware.Storage;

internal static class SmartAttributeTranslator
{
    const int SensorChannelStartIndex = 100;

    public static List<SmartAttribute> GetAttributesFor(DiskInfoToolkit.Storage storage)
    {
        switch (storage.SmartKey)
        {
            case SmartKey.Smart:
                return GetSmart(storage);
            case SmartKey.SSD:
                return GetSSD(storage);
            case SmartKey.Mtron:
                return GetMtron(storage);
            case SmartKey.Indilinx:
                return GetIndilinx(storage);
            case SmartKey.JMicron60x:
                return GetJMicron60X(storage);
            case SmartKey.Intel:
                return GetIntel(storage);
            case SmartKey.Samsung:
                return GetSamsung(storage);
            case SmartKey.SandForce:
                return GetSandforce(storage);
            case SmartKey.JMicron61x:
                return GetJMicron61X(storage);
            case SmartKey.Micron:
                return GetMicron(storage);
            case SmartKey.MicronMU02:
                return GetMicronMU03(storage);
            case SmartKey.Ocz:
                return GetOcz(storage);
            case SmartKey.Plextor:
                return GetPlextor(storage);
            case SmartKey.SanDisk:
                return GetSandisk(storage);
            case SmartKey.OczVector:
                return GetOczVector(storage);
            case SmartKey.Corsair:
                return GetCorsair(storage);
            case SmartKey.Toshiba:
                return GetToshiba(storage);
            case SmartKey.SanDiskGb:
                return GetSandiskGB(storage);
            case SmartKey.Kingston:
                return GetKingston(storage);
            case SmartKey.NVMe:
                return GetNVME(storage);
            case SmartKey.Realtek:
                return GetRealtek(storage);
            case SmartKey.SKhynix:
                return GetSkhynix(storage);
            case SmartKey.Kioxia:
                return GetKioxia(storage);
            case SmartKey.WDC:
                return GetWdc(storage);
            case SmartKey.KingstonSuv:
                return GetKingstonSUV(storage);
            case SmartKey.KingstonKC600:
                return GetKingstonKC600(storage);
            case SmartKey.KingstonDC500:
                return GetKingstonDC500(storage);
            case SmartKey.KingstonSA400:
                return GetKingstonSA400(storage);
            case SmartKey.Ssstc:
                return GetSSSTC(storage);
            case SmartKey.IntelDc:
                return GetIntelDC(storage);
            case SmartKey.Apacer:
                return GetAPACER(storage);
            case SmartKey.SiliconMotion:
                return GetSiliconMotion(storage);
            case SmartKey.JMicron66x:
                return GetJMicron66X(storage);
            case SmartKey.Phison:
                return GetPhison(storage);
            case SmartKey.Seagate:
                return GetSeagate(storage);
            case SmartKey.SeagateIronWolf:
                return GetSeagateIronWolf(storage);
            case SmartKey.Marvell:
                return GetMarvell(storage);
            case SmartKey.Maxiotek:
                return GetMaxiotek(storage);
            case SmartKey.SeagateBarraCuda:
                return GetSeagateBarraCuda(storage);
            case SmartKey.Ymtc:
                return GetYMTC(storage);
            case SmartKey.Scy:
                return GetSCY(storage);
            case SmartKey.Recadata:
                return GetRecadata(storage);
            case SmartKey.SanDiskHP:
                return GetSandiskHP(storage);
            case SmartKey.SanDiskHPVenus:
                return GetSandiskHPVenus(storage);
            case SmartKey.SanDiskDell:
                return GetSandiskDell(storage);
            case SmartKey.SanDiskLenovo:
                return GetSandiskLenovo(storage);
            case SmartKey.SanDiskLenovoHelenVenus:
                return GetSandiskLenovoHelenVenus(storage);
            case SmartKey.MicronMU03:
                return GetMicronMU03(storage);
            case SmartKey.SanDiskCloud:
                return GetSandiskCloud(storage);
            case SmartKey.SiliconMotionCVC:
                return GetSiliconMotionCVC(storage);
            case SmartKey.AdataIndustrial:
                return GetAdataIndustrial(storage);
            default:
                return new();
        }
    }

    private static List<SmartAttribute> GetSmart(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.ReadErrorRate),
            Get(storage, SmartAttributeType.ThroughputPerformance),
            Get(storage, SmartAttributeType.SpinUpTime),
            Get(storage, SmartAttributeType.StartStopCount),
            Get(storage, SmartAttributeType.ReallocatedSectorsCount),
            Get(storage, SmartAttributeType.ReadChannelMargin),
            Get(storage, SmartAttributeType.SeekErrorRate),
            Get(storage, SmartAttributeType.SeekTimePerformance),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.SpinRetryCount),
            Get(storage, SmartAttributeType.RecalibrationRetries),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.SoftReadErrorRateStab),
            Get(storage, SmartAttributeType.CurrentHeliumLevel),
            Get(storage, SmartAttributeType.EndToEndError),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.CommandTimeout),
            Get(storage, SmartAttributeType.HighFlyWrites),
            Get(storage, SmartAttributeType.AirflowTemperature),
            Get(storage, SmartAttributeType.GSenseErrorRate),
            Get(storage, SmartAttributeType.PowerOffRetractCount),
            Get(storage, SmartAttributeType.LoadUnloadCycleCount),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.HardwareECCRecovered),
            Get(storage, SmartAttributeType.ReallocationEventCount),
            Get(storage, SmartAttributeType.PendingSectorCount),
            Get(storage, SmartAttributeType.UncorrectableSectorCount),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.WriteErrorRate),
            Get(storage, SmartAttributeType.SoftReadErrorRate),
            Get(storage, SmartAttributeType.DataAddressMarkError),
            Get(storage, SmartAttributeType.RunOutCancel),
            Get(storage, SmartAttributeType.SoftECCCorrection),
            Get(storage, SmartAttributeType.ThermalAsperityRate),
            Get(storage, SmartAttributeType.FlyingHeight),
            Get(storage, SmartAttributeType.SpinHighCurrent),
            Get(storage, SmartAttributeType.SpinBuzz),
            Get(storage, SmartAttributeType.OfflineSeekPerformance),
            Get(storage, SmartAttributeType.VibrationDuringWrite),
            Get(storage, SmartAttributeType.ShockDuringWrite),
            Get(storage, SmartAttributeType.DiskShift),
            Get(storage, SmartAttributeType.GSenseErrorRate),
            Get(storage, SmartAttributeType.LoadedHours),
            Get(storage, SmartAttributeType.LoadUnloadCycleCount),
            Get(storage, SmartAttributeType.LoadFriction),
            Get(storage, SmartAttributeType.LoadUnloadCycleCount),
            Get(storage, SmartAttributeType.LoadInTime),
            Get(storage, SmartAttributeType.TorqueAmplificationCount),
            Get(storage, SmartAttributeType.PowerOffRetractCount),
            Get(storage, SmartAttributeType.GMRHeadAmplitude),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.HeadFlyingHours),
            Get(storage, SmartAttributeType.ReadErrorRetryRate),
            Get(storage, SmartAttributeType.FreeFallProtection),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
            Get(storage, SmartAttributeType.HeliumConditionLower),
            Get(storage, SmartAttributeType.HeliumConditionUpper),
            Get(storage, SmartAttributeType.MAMRHealthMonitor),
        ];
    }

    private static List<SmartAttribute> GetSSD(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.ReadErrorRate),
            Get(storage, SmartAttributeType.ThroughputPerformance),
            Get(storage, SmartAttributeType.SpinUpTime),
            Get(storage, SmartAttributeType.StartStopCount),
            Get(storage, SmartAttributeType.ReallocatedSectorsCount),
            Get(storage, SmartAttributeType.ReadChannelMargin),
            Get(storage, SmartAttributeType.SeekErrorRate),
            Get(storage, SmartAttributeType.SeekTimePerformance),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.SpinRetryCount),
            Get(storage, SmartAttributeType.RecalibrationRetries),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.SoftReadErrorRateStab),
            Get(storage, SmartAttributeType.UnsafeShutdownCount),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.ReallocationEventCount),
            Get(storage, SmartAttributeType.PendingSectorCount),
            Get(storage, SmartAttributeType.UncorrectableSectorCount),
            Get(storage, SmartAttributeType.RemainingLife),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
        ];
    }

    private static List<SmartAttribute> GetMtron(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.TotalEraseCount),
        ];
    }

    private static List<SmartAttribute> GetIndilinx(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.ReadErrorRate),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.BadBlockCount),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.ProgramFailureBlockCount),
            Get(storage, SmartAttributeType.EraseFailureBlockCount),
            Get(storage, SmartAttributeType.ReadFailureBlockCount),
            Get(storage, SmartAttributeType.TotalCountReadSectors),
            Get(storage, SmartAttributeType.TotalCountWriteSectors),
            Get(storage, SmartAttributeType.TotalCountReadCommands),
            Get(storage, SmartAttributeType.TotalCountWriteCommands),
            Get(storage, SmartAttributeType.TotalCountErrorBitsFromFlash),
            Get(storage, SmartAttributeType.TotalCountReadSectorsWithCorrectableBitErrors),
            Get(storage, SmartAttributeType.BadBlockFullFlag),
            Get(storage, SmartAttributeType.MaximumPECountSpecification),
            Get(storage, SmartAttributeType.MinimumEraseCount),
            Get(storage, SmartAttributeType.MaximumEraseCount),
            Get(storage, SmartAttributeType.AverageEraseCount),
            Get(storage, SmartAttributeType.RemainingLife),
        ];
    }

    private static List<SmartAttribute> GetIntel(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.SpinUpTime),
            Get(storage, SmartAttributeType.StartStopCount),
            Get(storage, SmartAttributeType.ReallocatedSectorsCount),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.AvailableReservedSpace),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.PowerLossProtectionFailure),
            Get(storage, SmartAttributeType.SATADownshiftCount),
            Get(storage, SmartAttributeType.EndToEndError),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.UnsafeShutdownCount),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.PendingSectorCount),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.TimedWorkloadMediaWear),
            Get(storage, SmartAttributeType.TimedWorkloadHostReadWriteRatio),
            Get(storage, SmartAttributeType.TimedWorkloadTimer),
            Get(storage, SmartAttributeType.AvailableReservedSpace),
            Get(storage, SmartAttributeType.MediaWearoutIndicator),
            Get(storage, SmartAttributeType.ThermalThrottleStatus),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
            Get(storage, SmartAttributeType.NandDataWritten),
            Get(storage, SmartAttributeType.NandDataWritten),
        ];
    }

    private static List<SmartAttribute> GetSamsung(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.ReallocatedSectorsCount),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.WearLevelingCount),
            Get(storage, SmartAttributeType.UsedReservedBlockCount),
            Get(storage, SmartAttributeType.UsedReservedBlockCount),
            Get(storage, SmartAttributeType.UnusedReservedBlockCount),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.RuntimeBadBlock),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.AirflowTemperature),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.ECCErrorRate),
            Get(storage, SmartAttributeType.OfflineUncorrectableErrors),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.SuperCapStatus),
            Get(storage, SmartAttributeType.SSDModeStatus),
            Get(storage, SmartAttributeType.PORRecoveryCount),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
            Get(storage, SmartAttributeType.UnusedReservedBlockCount),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.WearLevelingCount),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.ErrorDetection),
            Get(storage, SmartAttributeType.MediaWearoutIndicator),
        ];
    }

    private static List<SmartAttribute> GetSandforce(DiskInfoToolkit.Storage storage)
    {
        int sensorStart = SensorChannelStartIndex;
        return
        [
            Get(storage, SmartAttributeType.ReadErrorRate),
            Get(storage, SmartAttributeType.RetiredBlockCount),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.SoftReadErrorRate),
            Get(storage, SmartAttributeType.GigabytesErased),
            Get(storage, SmartAttributeType.ReserveBlockCount),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.WearRangeDelta),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.IOErrorDetectionCodeErrors),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.ReallocationEventCount),
            Get(storage, SmartAttributeType.UncorrectableSectorCount),
            Get(storage, SmartAttributeType.SATARErrors),
            Get(storage, SmartAttributeType.SoftReadErrorRate),
            Get(storage, SmartAttributeType.SoftECCCorrection),
            Get(storage, SmartAttributeType.DriveLifeProtectionStatus),
            Get(storage, SmartAttributeType.RemainingLife),
            Get(storage, SmartAttributeType.AvailableReservedSpace),
            Get(storage, SmartAttributeType.NandDataWritten, SensorType.Data, sensorStart++),
            Get(storage, SmartAttributeType.PowerFailBackupHealth),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
        ];
    }

    private static List<SmartAttribute> GetMicron(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.ReadErrorRate),
            Get(storage, SmartAttributeType.ReallocatedNANDBlocks),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.SoftReadErrorRate),
            Get(storage, SmartAttributeType.DeviceCapacity),
            Get(storage, SmartAttributeType.UserCapacity),
            Get(storage, SmartAttributeType.SpareBlocksAvailable),
            Get(storage, SmartAttributeType.RemainingSpareBlocks),
            Get(storage, SmartAttributeType.TotalEraseCount),
            Get(storage, SmartAttributeType.ReserveBlockCount),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.AverageEraseCount),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.UnusedReservedBlockCount),
            Get(storage, SmartAttributeType.UnalignedAccessCount),
            Get(storage, SmartAttributeType.SATADownshiftCount),
            Get(storage, SmartAttributeType.ErrorCorrectionCount),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.CommandTimeout),
            Get(storage, SmartAttributeType.BadBlockCount),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.ECCBitCorrectionCount),
            Get(storage, SmartAttributeType.ReallocationEventCount),
            Get(storage, SmartAttributeType.PendingSectorCount),
            Get(storage, SmartAttributeType.OfflineUncorrectableErrors),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.LifetimeUsed),
            Get(storage, SmartAttributeType.WriteErrorRate),
            Get(storage, SmartAttributeType.SuccessfulRAINRecoveryCount),
            Get(storage, SmartAttributeType.TotalBytesRead),
            Get(storage, SmartAttributeType.WriteProtectProgress),
            Get(storage, SmartAttributeType.ECCBitsCorrected),
            Get(storage, SmartAttributeType.ECCCumulativeThresholdEvents),
            Get(storage, SmartAttributeType.CumulativeProgramNANDPages),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostProgramPageCount),
            Get(storage, SmartAttributeType.BackgroundProgramPageCount),
            Get(storage, SmartAttributeType.TotalRefreshISPCount),
            Get(storage, SmartAttributeType.TotalDoRefCalCount),
            Get(storage, SmartAttributeType.TotalNANDReadPlaneCountLow),
            Get(storage, SmartAttributeType.TotalNANDReadPlaneCountHigh),
            Get(storage, SmartAttributeType.TotalBlockReMapPassCount),
            Get(storage, SmartAttributeType.TotalBackgroundScanOverLimitCount),
            Get(storage, SmartAttributeType.TotalBackgroundScan),
        ];
    }

    private static List<SmartAttribute> GetOcz(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.ReadErrorRate),
            Get(storage, SmartAttributeType.SpinUpTime),
            Get(storage, SmartAttributeType.StartStopCount),
            Get(storage, SmartAttributeType.ReallocatedSectorsCount),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.TotalCountWriteSectors),
            Get(storage, SmartAttributeType.RemainingLife),
            Get(storage, SmartAttributeType.TotalBlocksErased),
            Get(storage, SmartAttributeType.SSDProtectMode),
            Get(storage, SmartAttributeType.SATAPhysicalErrorCount),
            Get(storage, SmartAttributeType.BadBlockCount),
            Get(storage, SmartAttributeType.TotalEraseCount),
            Get(storage, SmartAttributeType.BadBlockCount),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.TotalNumberCorrectedBits),
            Get(storage, SmartAttributeType.MaxRatedPECounts),
            Get(storage, SmartAttributeType.MinimumEraseCount),
            Get(storage, SmartAttributeType.MaximumEraseCount),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.NandReadRetryCount),
            Get(storage, SmartAttributeType.SimpleReadRetryAttempts),
            Get(storage, SmartAttributeType.AdaptiveReadRetryAttempts),
            Get(storage, SmartAttributeType.OfflineUncorrectableErrors),
            Get(storage, SmartAttributeType.RAIDRecoveryCount),
            Get(storage, SmartAttributeType.PowerLossProtectionFailure),
            Get(storage, SmartAttributeType.NandDataRead),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
            Get(storage, SmartAttributeType.NandDataWritten),
        ];
    }

    private static List<SmartAttribute> GetSeagate(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.ReadErrorRate),
            Get(storage, SmartAttributeType.RetiredBlockCount),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.SpareBlocksAvailable),
            Get(storage, SmartAttributeType.RemainingSpareBlocks),
            Get(storage, SmartAttributeType.SATAPhysicalErrorCount),
            Get(storage, SmartAttributeType.BadBlockCount),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.TotalEraseCount),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.WearRangeDelta),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.SoftReadErrorRate),
            Get(storage, SmartAttributeType.SoftECCCorrection),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.RemainingLife),
            Get(storage, SmartAttributeType.ReadFailureBlockCount),
            Get(storage, SmartAttributeType.NandDataWritten),
            Get(storage, SmartAttributeType.NandDataWritten),
            Get(storage, SmartAttributeType.NandDataWritten),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
            Get(storage, SmartAttributeType.NandDataRead),
        ];
    }

    private static List<SmartAttribute> GetWdc(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.ReadErrorRate),
            Get(storage, SmartAttributeType.ReallocatedNANDBlocks),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.TotalNANDEraseCount),
            Get(storage, SmartAttributeType.MinimumPECycles),
            Get(storage, SmartAttributeType.MaximumBadBlocksPerDie),
            Get(storage, SmartAttributeType.MaximumPECycles),
            Get(storage, SmartAttributeType.BadBlockCount),
            Get(storage, SmartAttributeType.GrownBadBlocks),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.AveragePECycles),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.EndToEndErrorsCorrected),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.CommandTimeout),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.SATAPhysicalErrorCount),
            Get(storage, SmartAttributeType.MediaWearoutIndicator),
            Get(storage, SmartAttributeType.AvailableReservedSpace),
            Get(storage, SmartAttributeType.NandDataWritten),
            Get(storage, SmartAttributeType.NandDataWritten),
            Get(storage, SmartAttributeType.MediaWearoutIndicator),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
            Get(storage, SmartAttributeType.NandDataWritten),
            Get(storage, SmartAttributeType.ThermalThrottleStatus),
            Get(storage, SmartAttributeType.NandDataWritten),
        ];
    }

    private static List<SmartAttribute> GetPlextor(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.ReadErrorRate),
            Get(storage, SmartAttributeType.ReallocatedSectorsCount),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.BadBlockCount),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.AverageEraseCount),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.ProgramFailCountWorstCase),
            Get(storage, SmartAttributeType.EraseFailCountWorstCase),
            Get(storage, SmartAttributeType.WearLevelingCount),
            Get(storage, SmartAttributeType.UsedReservedBlockCountWorstCase),
            Get(storage, SmartAttributeType.UsedReservedBlockCount),
            Get(storage, SmartAttributeType.UnusedReservedBlockCount),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.SATADownshiftCount),
            Get(storage, SmartAttributeType.EndToEndErrorsCorrected),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.CommandTimeout),
            Get(storage, SmartAttributeType.UnsafeShutdownCount),
            Get(storage, SmartAttributeType.ECCErrorRate),
            Get(storage, SmartAttributeType.ReallocationEventCount),
            Get(storage, SmartAttributeType.UncorrectableSectorCount),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.AvailableReservedSpace),
            Get(storage, SmartAttributeType.NandDataWritten),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
        ];
    }

    private static List<SmartAttribute> GetSandisk(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.ReallocatedNANDBlocks),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.ReserveBlockCount),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.AverageEraseCount),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.PercentOfTotalEraseCount),
            Get(storage, SmartAttributeType.RemainingSpareBlocks),
            Get(storage, SmartAttributeType.PercentOfTotalEraseCountBCBlocks),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
        ];
    }

    private static List<SmartAttribute> GetOczVector(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.RuntimeBadBlock),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.SpareBlocksAvailable),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.TotalUncorrectableNANDReads),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.TotalReadFailures),
            Get(storage, SmartAttributeType.HostDataRead),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.AverageEraseCount),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.RemainingLife),
            Get(storage, SmartAttributeType.NandDataWritten),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
            Get(storage, SmartAttributeType.TotalBlocksErased),
            Get(storage, SmartAttributeType.BadBlockCount),
            Get(storage, SmartAttributeType.TotalNumberCorrectedBits),
            Get(storage, SmartAttributeType.MaxRatedPECounts),
            Get(storage, SmartAttributeType.MinimumEraseCount),
            Get(storage, SmartAttributeType.MaximumEraseCount),
            Get(storage, SmartAttributeType.NandReadRetryCount),
            Get(storage, SmartAttributeType.SimpleReadRetryAttempts),
            Get(storage, SmartAttributeType.AdaptiveReadRetryAttempts),
            Get(storage, SmartAttributeType.OfflineUncorrectableErrors),
            Get(storage, SmartAttributeType.RAIDRecoveryCount),
            Get(storage, SmartAttributeType.InWarranty),
            Get(storage, SmartAttributeType.DASPolarity),
            Get(storage, SmartAttributeType.PartialPfail),
            Get(storage, SmartAttributeType.WriteThrottlingActivationFlag),
            Get(storage, SmartAttributeType.NandDataWritten),
            Get(storage, SmartAttributeType.NandDataRead),
        ];
    }

    private static List<SmartAttribute> GetToshiba(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.ReadErrorRate),
            Get(storage, SmartAttributeType.ThroughputPerformance),
            Get(storage, SmartAttributeType.SpinUpTime),
            Get(storage, SmartAttributeType.StartStopCount),
            Get(storage, SmartAttributeType.ReallocatedSectorsCount),
            Get(storage, SmartAttributeType.SeekErrorRate),
            Get(storage, SmartAttributeType.SeekTimePerformance),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.SpinRetryCount),
            Get(storage, SmartAttributeType.RecalibrationRetries),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.SSDProtectMode),
            Get(storage, SmartAttributeType.SATAPhysicalErrorCount),
            Get(storage, SmartAttributeType.BadBlockCount),
            Get(storage, SmartAttributeType.TotalEraseCount),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.ReallocationEventCount),
            Get(storage, SmartAttributeType.PendingSectorCount),
            Get(storage, SmartAttributeType.UncorrectableSectorCount),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
        ];
    }

    private static List<SmartAttribute> GetCorsair(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.ReadErrorRate),
            Get(storage, SmartAttributeType.RetiredBlockCount),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.ReserveBlockCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.ReallocationEventCount),
            Get(storage, SmartAttributeType.RemainingLife),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
        ];
    }

    private static List<SmartAttribute> GetKingston(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.ReadErrorRate),
            Get(storage, SmartAttributeType.ThroughputPerformance),
            Get(storage, SmartAttributeType.SpinUpTime),
            Get(storage, SmartAttributeType.ReallocatedSectorsCount),
            Get(storage, SmartAttributeType.SeekErrorRate),
            Get(storage, SmartAttributeType.SeekTimePerformance),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.SpinRetryCount),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.SATAPhysicalErrorCount),
            Get(storage, SmartAttributeType.BadBlockCount),
            Get(storage, SmartAttributeType.TotalEraseCount),
            Get(storage, SmartAttributeType.BadClusterTableCount),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.UnsafeShutdownCount),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.BadBlockCount),
            Get(storage, SmartAttributeType.PendingSectorCount),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.RemainingLife),
            Get(storage, SmartAttributeType.NandDataWritten),
            Get(storage, SmartAttributeType.WriteHead),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
            Get(storage, SmartAttributeType.AverageEraseCount),
            Get(storage, SmartAttributeType.MaximumEraseCount),
            Get(storage, SmartAttributeType.TotalEraseCount),
        ];
    }

    private static List<SmartAttribute> GetMicronMU03(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.ReadErrorRate),
            Get(storage, SmartAttributeType.ReallocatedNANDBlocks),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.AverageEraseCount),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.UnusedSpareNANDBlocks),
            Get(storage, SmartAttributeType.Non4KAlignedAccess),
            Get(storage, SmartAttributeType.SATADownshiftCount),
            Get(storage, SmartAttributeType.ErrorCorrectionCount),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.ReallocationEventCount),
            Get(storage, SmartAttributeType.ErrorCorrectionCount),
            Get(storage, SmartAttributeType.OfflineUncorrectableErrors),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.RemainingLife),
            Get(storage, SmartAttributeType.WriteErrorRate),
            Get(storage, SmartAttributeType.SuccessfulRAINRecoveryCount),
            Get(storage, SmartAttributeType.HostProgramPageCount),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
            Get(storage, SmartAttributeType.HostProgramPageCount),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.CumulativeProgramNANDPages),
            Get(storage, SmartAttributeType.CumulativeProgramNANDPages),
        ];
    }

    private static List<SmartAttribute> GetNVME(DiskInfoToolkit.Storage storage)
    {
        int sensorStart = SensorChannelStartIndex;
        return
        [
            Get(storage, SmartAttributeType.CriticalWarning),
            Get(storage, SmartAttributeType.CompositeTemperature),
            Get(storage, SmartAttributeType.AvailableSpare, SensorType.Level, sensorStart++),
            Get(storage, SmartAttributeType.AvailableSpareThreshold, SensorType.Level, sensorStart++),
            Get(storage, SmartAttributeType.PercentageUsed, SensorType.Level, sensorStart++),
            Get(storage, SmartAttributeType.HostDataRead),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostReadCommands),
            Get(storage, SmartAttributeType.HostWriteCommands),
            Get(storage, SmartAttributeType.ControllerBusyTime),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.UnsafeShutdownCount),
            Get(storage, SmartAttributeType.MediaAndDataIntegrityErrors),
            Get(storage, SmartAttributeType.NumberOfErrorInformationLogEntries),
            Get(storage, SmartAttributeType.WarningCompositeTemperatureTime),
            Get(storage, SmartAttributeType.CriticalCompositeTemperatureTime),
            Get(storage, SmartAttributeType.TemperatureSensor1),
            Get(storage, SmartAttributeType.TemperatureSensor2),
            Get(storage, SmartAttributeType.TemperatureSensor3),
            Get(storage, SmartAttributeType.TemperatureSensor4),
            Get(storage, SmartAttributeType.TemperatureSensor5),
            Get(storage, SmartAttributeType.TemperatureSensor6),
            Get(storage, SmartAttributeType.TemperatureSensor7),
            Get(storage, SmartAttributeType.TemperatureSensor8),
            Get(storage, SmartAttributeType.ThermalManagementTemperature1TransitionCount),
            Get(storage, SmartAttributeType.ThermalManagementTemperature2TransitionCount),
            Get(storage, SmartAttributeType.TotalTimeThermalManagementTemperature1),
            Get(storage, SmartAttributeType.TotalTimeThermalManagementTemperature2),
        ];
    }

    private static List<SmartAttribute> GetRealtek(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.RawDataErrorRate),
            Get(storage, SmartAttributeType.ReallocatedSectorsCount),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.GDN),
            Get(storage, SmartAttributeType.TotalEraseCount),
            Get(storage, SmartAttributeType.MaximumPECycles),
            Get(storage, SmartAttributeType.AverageEraseCount),
            Get(storage, SmartAttributeType.BadBlockCount),
            Get(storage, SmartAttributeType.BadBlockCount),
            Get(storage, SmartAttributeType.SSDProtectMode),
            Get(storage, SmartAttributeType.SATAPhysicalErrorCount),
            Get(storage, SmartAttributeType.RemainingLife),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.ECCFailRecord),
            Get(storage, SmartAttributeType.UnalignedAccessCount),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.ECCBitCorrectionCount),
            Get(storage, SmartAttributeType.ReallocationEventCount),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.MinimumEraseCount),
            Get(storage, SmartAttributeType.MaximumEraseCount),
            Get(storage, SmartAttributeType.RemainingLife),
            Get(storage, SmartAttributeType.AvailableReservedSpace),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
            Get(storage, SmartAttributeType.NandDataWritten),
            Get(storage, SmartAttributeType.NandDataWritten),
        ];
    }

    private static List<SmartAttribute> GetSkhynix(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.ReadErrorRate),
            Get(storage, SmartAttributeType.ReallocatedSectorsCount),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.TotalEraseCount),
            Get(storage, SmartAttributeType.MinimumEraseCount),
            Get(storage, SmartAttributeType.MaximumEraseCount),
            Get(storage, SmartAttributeType.ReserveBlockCount),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.ProgramFailCountWorstCase),
            Get(storage, SmartAttributeType.EraseFailCountWorstCase),
            Get(storage, SmartAttributeType.WearLevelingCount),
            Get(storage, SmartAttributeType.UsedReservedBlockCountWorstCase),
            Get(storage, SmartAttributeType.UsedReservedBlockCount),
            Get(storage, SmartAttributeType.UnusedReservedBlockCount),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.SATADownshiftCount),
            Get(storage, SmartAttributeType.EndToEndError),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.CommandTimeout),
            Get(storage, SmartAttributeType.ShockEventCount),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.ECCErrorRate),
            Get(storage, SmartAttributeType.ReallocationEventCount),
            Get(storage, SmartAttributeType.UncorrectableSectorCount),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.UncorrectableSoftReadErrorRate),
            Get(storage, SmartAttributeType.SoftECCCorrection),
            Get(storage, SmartAttributeType.SATAPhysicalErrorCount),
            Get(storage, SmartAttributeType.RemainingLife),
            Get(storage, SmartAttributeType.RemainingLife),
            Get(storage, SmartAttributeType.NandDataWritten),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
            Get(storage, SmartAttributeType.NandDataRead),
        ];
    }

    private static List<SmartAttribute> GetKioxia(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.SSDProtectMode),
            Get(storage, SmartAttributeType.SATAPhysicalErrorCount),
            Get(storage, SmartAttributeType.BadBlockCount),
            Get(storage, SmartAttributeType.TotalEraseCount),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.HostDataWritten),
        ];
    }

    private static List<SmartAttribute> GetSSSTC(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.ReadErrorRate),
            Get(storage, SmartAttributeType.ReallocatedNANDBlocks),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.AvailableReservedSpace),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.AverageEraseCount),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.ProgramFailCountWorstCase),
            Get(storage, SmartAttributeType.EraseFailCountWorstCase),
            Get(storage, SmartAttributeType.WearLevelingCount),
            Get(storage, SmartAttributeType.UsedReservedBlockCountWorstCase),
            Get(storage, SmartAttributeType.UsedReservedBlockCount),
            Get(storage, SmartAttributeType.UnusedReservedBlockCount),
            Get(storage, SmartAttributeType.SATADownshiftCount),
            Get(storage, SmartAttributeType.EndToEndError),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.CommandTimeout),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.ECCErrorRate),
            Get(storage, SmartAttributeType.OfflineUncorrectableErrors),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.PowerLossProtectionFailure),
            Get(storage, SmartAttributeType.RemainingLife),
            Get(storage, SmartAttributeType.AvailableReservedSpace),
            Get(storage, SmartAttributeType.NandDataWritten),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
            Get(storage, SmartAttributeType.NandDataWritten),
        ];
    }

    private static List<SmartAttribute> GetIntelDC(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.ReadErrorRate),
            Get(storage, SmartAttributeType.ReallocatedNANDBlocks),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.DeviceCapacity),
            Get(storage, SmartAttributeType.UserCapacity),
            Get(storage, SmartAttributeType.SpareBlocksAvailable),
            Get(storage, SmartAttributeType.RemainingSpareBlocks),
            Get(storage, SmartAttributeType.TotalBlockEraseFailure),
            Get(storage, SmartAttributeType.MaximumEraseCount),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.AverageEraseCount),
            Get(storage, SmartAttributeType.PowerLossProtectionFailure),
            Get(storage, SmartAttributeType.ProgramFailureBlockCount),
            Get(storage, SmartAttributeType.EndToEndError),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.PendingSectorCount),
            Get(storage, SmartAttributeType.OfflineUncorrectableErrors),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.LifetimeUsed),
            Get(storage, SmartAttributeType.TimedWorkloadMediaWear),
            Get(storage, SmartAttributeType.TimedWorkloadHostReadWriteRatio),
            Get(storage, SmartAttributeType.TimedWorkloadTimer),
            Get(storage, SmartAttributeType.ThermalThrottleStatus),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.NandDataWritten),
        ];
    }

    private static List<SmartAttribute> GetAPACER(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.MaximumEraseCount),
            Get(storage, SmartAttributeType.AverageEraseCount),
            Get(storage, SmartAttributeType.BadBlockCount),
            Get(storage, SmartAttributeType.SSDProtectMode),
            Get(storage, SmartAttributeType.SATAPhysicalErrorCount),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.BadClusterTableCount),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.RemainingLife),
            Get(storage, SmartAttributeType.HostDataWritten),
        ];
    }

    private static List<SmartAttribute> GetSiliconMotion(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.ReadErrorRate),
            Get(storage, SmartAttributeType.ReallocatedSectorsCount),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.SLCTotalEraseCount),
            Get(storage, SmartAttributeType.SLCMaximumEraseCount),
            Get(storage, SmartAttributeType.SLCMinimumEraseCount),
            Get(storage, SmartAttributeType.SLCAverageEraseCount),
            Get(storage, SmartAttributeType.DRAM1BitErrorCount),
            Get(storage, SmartAttributeType.UncorrectableSectorCount),
            Get(storage, SmartAttributeType.SpareBlocksAvailable),
            Get(storage, SmartAttributeType.NumberOfCacheDataBlock),
            Get(storage, SmartAttributeType.NumberOfInvalidBlocks),
            Get(storage, SmartAttributeType.TotalEraseCount),
            Get(storage, SmartAttributeType.MaximumEraseCount),
            Get(storage, SmartAttributeType.MinimumEraseCount),
            Get(storage, SmartAttributeType.AverageEraseCount),
            Get(storage, SmartAttributeType.MaxEraseCountOfSpec),
            Get(storage, SmartAttributeType.RemainingLife),
            Get(storage, SmartAttributeType.ProgramFailCountInWorstDie),
            Get(storage, SmartAttributeType.EraseFailCountInWorstDie),
            Get(storage, SmartAttributeType.WearLevelingCount),
            Get(storage, SmartAttributeType.RuntimeBadBlock),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.PowerOffRetractCount),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.HardwareECCRecovered),
            Get(storage, SmartAttributeType.ReallocationEventCount),
            Get(storage, SmartAttributeType.PendingSectorCount),
            Get(storage, SmartAttributeType.OfflineUncorrectableErrors),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.AvailableReservedSpace),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
            Get(storage, SmartAttributeType.TotalCountWriteSectors),
        ];
    }

    private static List<SmartAttribute> GetPhison(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.ReadErrorRate),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.SATAPhysicalErrorCount),
            Get(storage, SmartAttributeType.BadBlockCount),
            Get(storage, SmartAttributeType.TotalEraseCount),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.RemainingLife),
            Get(storage, SmartAttributeType.HostDataWritten),
        ];
    }

    private static List<SmartAttribute> GetMarvell(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.BadBlockCount),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.TotalEraseCount),
            Get(storage, SmartAttributeType.MaximumEraseCount),
            Get(storage, SmartAttributeType.MinimumEraseCount),
            Get(storage, SmartAttributeType.AverageEraseCount),
            Get(storage, SmartAttributeType.PowerOffRetractCount),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
        ];
    }

    private static List<SmartAttribute> GetMaxiotek(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.ReallocatedSectorsCount),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.SSDProtectMode),
            Get(storage, SmartAttributeType.SATAPhysicalErrorCount),
            Get(storage, SmartAttributeType.BadBlockCount),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.TotalEraseCount),
            Get(storage, SmartAttributeType.BadClusterTableCount),
            Get(storage, SmartAttributeType.ReadErrorRetryRate),
            Get(storage, SmartAttributeType.SpareBlocksAvailable),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.ReallocationEventCount),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.MinimumEraseCount),
            Get(storage, SmartAttributeType.MaximumEraseCount),
            Get(storage, SmartAttributeType.AverageEraseCount),
            Get(storage, SmartAttributeType.SLCMinimumEraseCount),
            Get(storage, SmartAttributeType.SLCMaximumEraseCount),
            Get(storage, SmartAttributeType.SLCAverageEraseCount),
            Get(storage, SmartAttributeType.RemainingLife),
            Get(storage, SmartAttributeType.NandDataWritten),
            Get(storage, SmartAttributeType.NandDataRead),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
            Get(storage, SmartAttributeType.BitErrorCount),
        ];
    }

    private static List<SmartAttribute> GetYMTC(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.BadBlockCount),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.MaximumBadBlocksPerDie),
            Get(storage, SmartAttributeType.SATAPhysicalErrorCount),
            Get(storage, SmartAttributeType.BadBlockCount),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.TotalEraseCount),
            Get(storage, SmartAttributeType.BadClusterTableCount),
            Get(storage, SmartAttributeType.SATADownshiftCount),
            Get(storage, SmartAttributeType.EndToEndErrorsCorrected),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.ReallocationEventCount),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.MinimumEraseCount),
            Get(storage, SmartAttributeType.MaximumEraseCount),
            Get(storage, SmartAttributeType.AverageEraseCount),
            Get(storage, SmartAttributeType.SLCMinimumEraseCount),
            Get(storage, SmartAttributeType.SLCMaximumEraseCount),
            Get(storage, SmartAttributeType.SLCAverageEraseCount),
            Get(storage, SmartAttributeType.RemainingLife),
            Get(storage, SmartAttributeType.NandDataWritten),
            Get(storage, SmartAttributeType.NandDataRead),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
            Get(storage, SmartAttributeType.NANDTemperature),
            Get(storage, SmartAttributeType.BitErrorCount),
        ];
    }

    private static List<SmartAttribute> GetSCY(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.ReadErrorRate),
            Get(storage, SmartAttributeType.ReallocatedSectorsCount),
            Get(storage, SmartAttributeType.SeekErrorRate),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.AverageEraseCount),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.TotalEraseCount),
            Get(storage, SmartAttributeType.ReadErrorRetryRate),
            Get(storage, SmartAttributeType.SpareBlocksAvailable),
            Get(storage, SmartAttributeType.RuntimeBadBlock),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.ECCBitCorrectionCount),
            Get(storage, SmartAttributeType.ReallocationEventCount),
            Get(storage, SmartAttributeType.PendingSectorCount),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.RemainingLife),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
            Get(storage, SmartAttributeType.NandDataWritten),
        ];
    }

    private static List<SmartAttribute> GetJMicron60X(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.HaltSystemIDFlashID),
            Get(storage, SmartAttributeType.FirmwareVersion),
            Get(storage, SmartAttributeType.ECCFailRecord),
            Get(storage, SmartAttributeType.AverageEraseCountMaxEraseCount),
            Get(storage, SmartAttributeType.GoodBlockCountSystemBlockCount),
        ];
    }

    private static List<SmartAttribute> GetJMicron61X(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.ReadErrorRate),
            Get(storage, SmartAttributeType.ThroughputPerformance),
            Get(storage, SmartAttributeType.SpinUpTime),
            Get(storage, SmartAttributeType.ReallocatedSectorsCount),
            Get(storage, SmartAttributeType.SeekErrorRate),
            Get(storage, SmartAttributeType.SeekTimePerformance),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.SpinRetryCount),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.SATAPhysicalErrorCount),
            Get(storage, SmartAttributeType.ECCFailRecord),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.PendingSectorCount),
            Get(storage, SmartAttributeType.BadBlockCount),
            Get(storage, SmartAttributeType.TotalEraseCount),
        ];
    }

    private static List<SmartAttribute> GetJMicron66X(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.ReadErrorRate),
            Get(storage, SmartAttributeType.ThroughputPerformance),
            Get(storage, SmartAttributeType.SpinUpTime),
            Get(storage, SmartAttributeType.ReallocatedSectorsCount),
            Get(storage, SmartAttributeType.SeekErrorRate),
            Get(storage, SmartAttributeType.SeekTimePerformance),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.SpinRetryCount),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.SSDProtectMode),
            Get(storage, SmartAttributeType.SATAPhysicalErrorCount),
            Get(storage, SmartAttributeType.BadBlockCount),
            Get(storage, SmartAttributeType.TotalEraseCount),
            Get(storage, SmartAttributeType.BadClusterTableCount),
            Get(storage, SmartAttributeType.SpareBlocksAvailable),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.PendingSectorCount),
            Get(storage, SmartAttributeType.RemainingLife),
            Get(storage, SmartAttributeType.NandDataWritten),
            Get(storage, SmartAttributeType.WriteHead),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
        ];
    }

    private static List<SmartAttribute> GetSeagateIronWolf(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.ReadErrorRate),
            Get(storage, SmartAttributeType.ReallocatedSectorsCount),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.GigabytesErased),
            Get(storage, SmartAttributeType.LifetimePS4EntryCount),
            Get(storage, SmartAttributeType.LifetimePS3EntryCount),
            Get(storage, SmartAttributeType.GrownBadBlocks),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.AverageEraseCount),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.WearRangeDelta),
            Get(storage, SmartAttributeType.SATADownshiftCount),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.RAISEECCCorrectableCount),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.DriveLifeProtectionStatus),
            Get(storage, SmartAttributeType.RemainingLife),
            Get(storage, SmartAttributeType.AvailableReservedSpace),
            Get(storage, SmartAttributeType.NandDataWritten),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
            Get(storage, SmartAttributeType.FreeSpace),
        ];
    }

    private static List<SmartAttribute> GetSeagateBarraCuda(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.RetiredBlockCount),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.SpareBlocksAvailable),
            Get(storage, SmartAttributeType.RemainingSpareBlocks),
            Get(storage, SmartAttributeType.SATAPhysicalErrorCount),
            Get(storage, SmartAttributeType.BadBlockCount),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.TotalEraseCount),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.WearRangeDelta),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.SoftReadErrorRate),
            Get(storage, SmartAttributeType.SoftECCCorrection),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.RemainingLife),
            Get(storage, SmartAttributeType.ReadFailureBlockCount),
            Get(storage, SmartAttributeType.NandDataWritten),
            Get(storage, SmartAttributeType.NandDataWritten),
            Get(storage, SmartAttributeType.NandDataWritten),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
            Get(storage, SmartAttributeType.NandDataRead),
        ];
    }

    private static List<SmartAttribute> GetSandiskGB(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.ReadErrorRate),
            Get(storage, SmartAttributeType.ReallocatedNANDBlocks),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.TotalBlocksErased),
            Get(storage, SmartAttributeType.MinimumPECycles),
            Get(storage, SmartAttributeType.MaximumBadBlocksPerDie),
            Get(storage, SmartAttributeType.MaximumPECycles),
            Get(storage, SmartAttributeType.BadBlockCount),
            Get(storage, SmartAttributeType.GrownBadBlocks),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.PECycles),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.EndToEndErrorsCorrected),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.CommandTimeout),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.SATAPhysicalErrorCount),
            Get(storage, SmartAttributeType.MediaWearoutIndicator),
            Get(storage, SmartAttributeType.RemainingLife),
            Get(storage, SmartAttributeType.AvailableReservedSpace),
            Get(storage, SmartAttributeType.NandDataWritten),
            Get(storage, SmartAttributeType.NandDataWritten),
            Get(storage, SmartAttributeType.MediaWearoutIndicator),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
            Get(storage, SmartAttributeType.ThermalThrottleStatus),
            Get(storage, SmartAttributeType.NandDataWritten),
        ];
    }

    private static List<SmartAttribute> GetKingstonSUV(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.ReadErrorRate),
            Get(storage, SmartAttributeType.ReallocatedSectorsCount),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.ReserveBlockCount),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.ProgramFailCountInWorstDie),
            Get(storage, SmartAttributeType.EraseFailCountInWorstDie),
            Get(storage, SmartAttributeType.WearLevelingCount),
            Get(storage, SmartAttributeType.UsedReservedBlockCountWorstDie),
            Get(storage, SmartAttributeType.UnusedReservedBlockCount),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.ECCErrorRate),
            Get(storage, SmartAttributeType.ReallocationEventCount),
            Get(storage, SmartAttributeType.PendingSectorCount),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.SoftECCCorrection),
            Get(storage, SmartAttributeType.RemainingLife),
            Get(storage, SmartAttributeType.NandDataWritten),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
            Get(storage, SmartAttributeType.NandDataRead),
        ];
    }

    private static List<SmartAttribute> GetKingstonKC600(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.ReadErrorRate),
            Get(storage, SmartAttributeType.ReallocatedNANDBlocks),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.Reserved),
            Get(storage, SmartAttributeType.Reserved),
            Get(storage, SmartAttributeType.Reserved),
            Get(storage, SmartAttributeType.SLCAverageEraseCount),
            Get(storage, SmartAttributeType.DRAM1BitErrorCount),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.AvailableReservedSpace),
            Get(storage, SmartAttributeType.Reserved),
            Get(storage, SmartAttributeType.Reserved),
            Get(storage, SmartAttributeType.Reserved),
            Get(storage, SmartAttributeType.AverageEraseCount),
            Get(storage, SmartAttributeType.Reserved),
            Get(storage, SmartAttributeType.RemainingLife),
            Get(storage, SmartAttributeType.Reserved),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.HardwareECCRecovered),
            Get(storage, SmartAttributeType.ReallocationEventCount),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.RemainingLife),
            Get(storage, SmartAttributeType.UnusedReservedBlockCount),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
            Get(storage, SmartAttributeType.HostDataWritten),
        ];
    }

    private static List<SmartAttribute> GetKingstonDC500(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.SSDProtectMode),
            Get(storage, SmartAttributeType.SATAPhysicalErrorCount),
            Get(storage, SmartAttributeType.BadBlockCount),
            Get(storage, SmartAttributeType.BadBlockFullFlag),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.TotalEraseCount),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.BadBlockCount),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.ThermalThrottleStatus),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.RemainingLife),
            Get(storage, SmartAttributeType.TotalReadFailures),
            Get(storage, SmartAttributeType.NandDataWritten),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
            Get(storage, SmartAttributeType.AverageEraseCount),
            Get(storage, SmartAttributeType.MaximumEraseCount),
            Get(storage, SmartAttributeType.TotalEraseCount),
        ];
    }

    private static List<SmartAttribute> GetKingstonSA400(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.VendorUnique),
            Get(storage, SmartAttributeType.VendorUnique),
            Get(storage, SmartAttributeType.VendorUnique),
            Get(storage, SmartAttributeType.SATAPhysicalErrorCount),
            Get(storage, SmartAttributeType.VendorUnique),
            Get(storage, SmartAttributeType.BadBlockCount),
            Get(storage, SmartAttributeType.VendorUnique),
            Get(storage, SmartAttributeType.TotalEraseCount),
            Get(storage, SmartAttributeType.VendorUnique),
            Get(storage, SmartAttributeType.VendorUnique),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.ReallocationEventCount),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.WearLevelingCount),
            Get(storage, SmartAttributeType.NandDataWritten),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
            Get(storage, SmartAttributeType.AverageEraseCount),
            Get(storage, SmartAttributeType.MaximumEraseCount),
            Get(storage, SmartAttributeType.TotalEraseCount),
        ];
    }

    private static List<SmartAttribute> GetRecadata(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.SeekErrorRate),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.AverageEraseCount),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.TotalEraseCount),
            Get(storage, SmartAttributeType.ReadErrorRetryRate),
            Get(storage, SmartAttributeType.SpareBlocksAvailable),
            Get(storage, SmartAttributeType.RuntimeBadBlock),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.ECCBitCorrectionCount),
            Get(storage, SmartAttributeType.ReallocationEventCount),
            Get(storage, SmartAttributeType.PendingSectorCount),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.RemainingLife),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
            Get(storage, SmartAttributeType.NandDataWritten),
        ];
    }

    private static List<SmartAttribute> GetSandiskDell(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.ReallocatedSectorsCount),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.WearLevelingCount),
            Get(storage, SmartAttributeType.UsedReservedBlockCountWorstCase),
            Get(storage, SmartAttributeType.UsedReservedBlockCount),
            Get(storage, SmartAttributeType.ReserveBlockCount),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.ECCErrorRate),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.MediaWearoutIndicator),
            Get(storage, SmartAttributeType.MediaWearoutIndicator),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
        ];
    }

    private static List<SmartAttribute> GetSandiskHP(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.ReadErrorRate),
            Get(storage, SmartAttributeType.ReallocatedSectorsCount),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.ReserveBlockCount),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.WearLevelingCount),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.ReserveBlockCount),
            Get(storage, SmartAttributeType.SATADownshiftCount),
            Get(storage, SmartAttributeType.EndToEndError),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.CommandTimeout),
            Get(storage, SmartAttributeType.AirflowTemperature),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.ReallocationEventCount),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.RemainingLife),
            Get(storage, SmartAttributeType.MediaWearoutIndicator),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
            Get(storage, SmartAttributeType.ThrottleStatistics),
            Get(storage, SmartAttributeType.ThermalThrottleStatus),
            Get(storage, SmartAttributeType.NandDataWritten),
        ];
    }

    private static List<SmartAttribute> GetSandiskHPVenus(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.ReadErrorRate),
            Get(storage, SmartAttributeType.ReallocatedSectorsCount),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.ReserveBlockCount),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.WearLevelingCount),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.ReserveBlockCount),
            Get(storage, SmartAttributeType.SATADownshiftCount),
            Get(storage, SmartAttributeType.EndToEndError),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.CommandTimeout),
            Get(storage, SmartAttributeType.AirflowTemperature),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.ReallocationEventCount),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.RemainingLife),
            Get(storage, SmartAttributeType.MediaWearoutIndicator),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
            Get(storage, SmartAttributeType.NandDataWritten),
            Get(storage, SmartAttributeType.ThermalThrottleStatus),
            Get(storage, SmartAttributeType.NandDataWritten),
        ];
    }

    private static List<SmartAttribute> GetSandiskLenovo(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.ReallocatedSectorsCount),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.MinimumPECycles),
            Get(storage, SmartAttributeType.MaximumBadBlocksPerDie),
            Get(storage, SmartAttributeType.MaximumPECycles),
            Get(storage, SmartAttributeType.BadBlockCount),
            Get(storage, SmartAttributeType.GrownBadBlocks),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.AveragePECycles),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.ReserveBlockCount),
            Get(storage, SmartAttributeType.RemainingSpareBlocks),
            Get(storage, SmartAttributeType.EndToEndErrorsCorrected),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.CommandTimeout),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.SATAPhysicalErrorCount),
            Get(storage, SmartAttributeType.MediaWearoutIndicator),
            Get(storage, SmartAttributeType.AvailableReservedSpace),
            Get(storage, SmartAttributeType.NandDataWritten),
            Get(storage, SmartAttributeType.NandDataWritten),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
            Get(storage, SmartAttributeType.ThrottleStatistics),
            Get(storage, SmartAttributeType.ThermalThrottleStatus),
        ];
    }

    private static List<SmartAttribute> GetSandiskLenovoHelenVenus(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.ReallocatedSectorsCount),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.MinimumPECycles),
            Get(storage, SmartAttributeType.MaximumBadBlocksPerDie),
            Get(storage, SmartAttributeType.MaximumPECycles),
            Get(storage, SmartAttributeType.BadBlockCount),
            Get(storage, SmartAttributeType.GrownBadBlocks),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.AveragePECycles),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.UsedReservedBlockCount),
            Get(storage, SmartAttributeType.ReserveBlockCount),
            Get(storage, SmartAttributeType.EndToEndError),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.CommandTimeout),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.SATAPhysicalErrorCount),
            Get(storage, SmartAttributeType.AvailableReservedSpace),
            Get(storage, SmartAttributeType.MediaWearoutIndicator),
            Get(storage, SmartAttributeType.NandDataWritten),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
            Get(storage, SmartAttributeType.ThrottleStatistics),
            Get(storage, SmartAttributeType.ThermalThrottleStatus),
            Get(storage, SmartAttributeType.NandDataWritten),
        ];
    }

    private static List<SmartAttribute> GetSandiskCloud(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.RetiredBlockCount),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.WriteAmplificationMultipliedBy100),
            Get(storage, SmartAttributeType.WriteAmplificationFactor),
            Get(storage, SmartAttributeType.ReserveBlockCount),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.AverageEraseCount),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.RemainingLife),
            Get(storage, SmartAttributeType.CleanShutdownCount),
            Get(storage, SmartAttributeType.UnsafeShutdownCount),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.ReallocatedNANDBlocks),
            Get(storage, SmartAttributeType.PercentOfTotalEraseCount),
            Get(storage, SmartAttributeType.SpareBlocksAvailable),
            Get(storage, SmartAttributeType.NandDataWritten),
            Get(storage, SmartAttributeType.CapacitorHealth),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
            Get(storage, SmartAttributeType.ThermalThrottleStatus),
            Get(storage, SmartAttributeType.RemainingLife),
            Get(storage, SmartAttributeType.SPITestsRemaining),
        ];
    }

    private static List<SmartAttribute> GetSiliconMotionCVC(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.ReallocatedSectorsCount),
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.SLCCache),
            Get(storage, SmartAttributeType.GrownBadBlocks),
            Get(storage, SmartAttributeType.ProgramFailCount),
            Get(storage, SmartAttributeType.EraseFailCount),
            Get(storage, SmartAttributeType.AverageEraseCount),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.ProgramFailCountWorstCase),
            Get(storage, SmartAttributeType.SATADownshiftCount),
            Get(storage, SmartAttributeType.EndToEndError),
            Get(storage, SmartAttributeType.UncorrectableErrors),
            Get(storage, SmartAttributeType.MaximumEraseCount),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.MinimumEraseCount),
            Get(storage, SmartAttributeType.ReadErrorRate),
            Get(storage, SmartAttributeType.OfflineUncorrectableErrors),
            Get(storage, SmartAttributeType.CRCErrorCount),
            Get(storage, SmartAttributeType.RemainingLife),
            Get(storage, SmartAttributeType.SpareBlocksAvailable),
            Get(storage, SmartAttributeType.NandDataWritten),
            Get(storage, SmartAttributeType.HostDataWritten),
            Get(storage, SmartAttributeType.HostDataRead),
            Get(storage, SmartAttributeType.RAIDEventCount),
            Get(storage, SmartAttributeType.RAIDUncorrectableCount),
            Get(storage, SmartAttributeType.SSDProtectMode),
            Get(storage, SmartAttributeType.ReadErrorRetryRate),
            Get(storage, SmartAttributeType.NandDataWritten),
        ];
    }

    private static List<SmartAttribute> GetAdataIndustrial(DiskInfoToolkit.Storage storage)
    {
        return
        [
            Get(storage, SmartAttributeType.PowerOnHours),
            Get(storage, SmartAttributeType.PowerCycleCount),
            Get(storage, SmartAttributeType.SSDProtectMode),
            Get(storage, SmartAttributeType.SATAPhysicalErrorCount),
            Get(storage, SmartAttributeType.BadBlockCount),
            Get(storage, SmartAttributeType.TotalEraseCount),
            Get(storage, SmartAttributeType.BadClusterTableCount),
            Get(storage, SmartAttributeType.SpareBlocksAvailable),
            Get(storage, SmartAttributeType.UnexpectedPowerLoss),
            Get(storage, SmartAttributeType.Temperature),
            Get(storage, SmartAttributeType.RemainingLife),
            Get(storage, SmartAttributeType.FlashWriteSectorCount),
            Get(storage, SmartAttributeType.FlashReadSectorCount),
            Get(storage, SmartAttributeType.TotalCountWriteSectors),
            Get(storage, SmartAttributeType.TotalCountReadSectors),
        ];
    }

    private static SmartAttribute Get(DiskInfoToolkit.Storage storage, SmartAttributeType smartAttributeType, SensorType? sensorType = null, int sensorChannel = 0, string sensorName = null)
    {
        var attr = storage.Smart.SmartAttributes.Find(sa => sa.Info.Type == smartAttributeType);

        if (attr == null)
        {
            return null;
        }
        else
        {
            return new(attr, sensorType, sensorChannel, sensorName);
        }
    }
}

```

`LibreHardwareMonitorLib/Hardware/Storage/StorageDevice.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using BlackSharp.Core.Converters;
using DiskInfoToolkit.Interop.Enums;
using Windows.Win32;
using Windows.Win32.Foundation;
using Windows.Win32.Storage.FileSystem;
using Windows.Win32.System.Ioctl;

namespace LibreHardwareMonitor.Hardware.Storage;

public sealed class StorageDevice : Hardware, ISmart
{
    private readonly PerformanceValue _perfRead = new();
    private readonly PerformanceValue _perfTotal = new();
    private readonly PerformanceValue _perfWrite = new();
    private readonly DiskInfoToolkit.Storage _storage;

    private long _lastReadCount;
    private long _lastTime;
    private long _lastWriteCount;

    private DateTime _lastUpdate = DateTime.MinValue;

    private readonly List<StorageDeviceSensor> _sensors = new();
    private readonly List<SmartAttribute> _attributes = new();

    private Sensor _sensorDiskReadActivity;
    private Sensor _sensorDiskReadRate;
    private Sensor _sensorDiskTotalActivity;
    private Sensor _sensorDiskWriteActivity;
    private Sensor _sensorDiskWriteRate;
    private Sensor _usageSensor;
    private Sensor _freeSpaceSensor;

    public StorageDevice(DiskInfoToolkit.Storage storage, string id, ISettings settings)
        : base(storage.Model, new Identifier(id, storage.DriveNumber.ToString(CultureInfo.InvariantCulture)), settings)
    {
        _storage = storage;

        CreateAttributes();

        CreateSensors();
    }

    public override HardwareType HardwareType => HardwareType.Storage;

    public DiskInfoToolkit.Storage Storage => _storage;

    public IReadOnlyList<SmartAttribute> Attributes => _attributes;

    public static TimeSpan ThrottleInterval { get; set; }

    public override void Update()
    {
        if (DateTime.UtcNow - _lastUpdate < ThrottleInterval)
        {
            return;
        }

        _lastUpdate = DateTime.UtcNow;

        ToggleSpaceSensors();
        UpdatePerformanceSensors();
        _storage.Update();
        UpdateSpaceSensors();

        // Update attributes
        foreach (var attribute in _storage.Smart.SmartAttributes)
        {
            // Try to find attribute
            var found = _attributes.Find(sa => sa.Id == attribute.Info.ID);

            // Found attribute, update it
            if (found != null)
            {
                found.Attribute = attribute;
            }
        }

        // Update general sensors
        _sensors.ForEach(s => s.Update(_storage));
    }

    public override string GetReport()
    {
        var r = new StringBuilder();
        r.AppendLine("Storage");
        r.AppendLine();
        r.AppendLine($"Drive Name: {_storage.Model}");
        r.AppendLine($"Firmware Version and Revision: {_storage.Firmware}; {_storage.FirmwareRev}");
        r.AppendLine();
        r.AppendLine("Smart Attributes:");
        r.AppendLine("ID, Description, Value, Threshold");

        foreach (var attribute in _attributes)
        {
            r.AppendLine($"{attribute.Id,3}, {attribute.Name,60}, {attribute.Value,18}, {attribute.Threshold,3}");
        }

        r.AppendLine();

        if (!_storage.IsDynamicDisk)
        {
            r.AppendLine("Partitions:");

            foreach (var partition in _storage.Partitions)
            {
                r.AppendLine($"Partition #{partition.PartitionNumber}");

                if (partition.DriveLetter != null)
                {
                    r.AppendLine($"Drive Letter: {partition.DriveLetter}");
                }

                if (partition.AvailableFreeSpace != null)
                {
                    r.AppendLine($"Available Free Space: {partition.AvailableFreeSpace}");
                }
            }

            r.AppendLine();

            if (_storage.TotalFreeSize != null)
            {
                r.AppendLine($"Total Free Size: {_storage.TotalFreeSize}");
            }
        }

        r.AppendLine($"Total Size: {_storage.TotalSize}");

        return r.ToString();
    }

    public override void Traverse(IVisitor visitor)
    {
        foreach (ISensor sensor in Sensors)
            sensor.Accept(visitor);
    }

    private void CreateAttributes()
    {
        _attributes.Clear();

        var attributes = SmartAttributeTranslator.GetAttributesFor(_storage);

        _attributes.AddRange(attributes.Where(a => a != null));
    }

    private void CreateSensors()
    {
        if (_storage.IsNVMe)
        {
            // Different name for NVMe
            AddSensor("Composite Temperature", 0, false, SensorType.Temperature, s => s.Smart.Temperature.GetValueOrDefault());

            TryAddTemperatureSensor(1, false, 1, SmartAttributeType.TemperatureSensor1);
            TryAddTemperatureSensor(2, false, 2, SmartAttributeType.TemperatureSensor2);
            TryAddTemperatureSensor(3, false, 3, SmartAttributeType.TemperatureSensor3);
            TryAddTemperatureSensor(4, false, 4, SmartAttributeType.TemperatureSensor4);
            TryAddTemperatureSensor(5, false, 5, SmartAttributeType.TemperatureSensor5);
            TryAddTemperatureSensor(6, false, 6, SmartAttributeType.TemperatureSensor6);
            TryAddTemperatureSensor(7, false, 7, SmartAttributeType.TemperatureSensor7);
            TryAddTemperatureSensor(8, false, 8, SmartAttributeType.TemperatureSensor8);

            AddSensor("Warning Temperature", 10, false, SensorType.Temperature, s => s.Smart.TemperatureWarning.GetValueOrDefault());
            AddSensor("Critical Temperature", 11, false, SensorType.Temperature, s => s.Smart.TemperatureCritical.GetValueOrDefault());
        }
        else
        {
            AddSensor("Temperature", 0, false, SensorType.Temperature, s => s.Smart.Temperature.GetValueOrDefault());
        }

        if (_storage.Smart.Life.HasValue)
        {
            AddSensor("Life", 20, false, SensorType.Level, s => s.Smart.Life.GetValueOrDefault());
        }

        if (_storage.Smart.HostReads.HasValue)
        {
            AddSensor("Data Read", 21, false, SensorType.Data, s => s.Smart.HostReads.GetValueOrDefault());
        }

        if (_storage.Smart.HostWrites.HasValue)
        {
            AddSensor("Data Written", 22, false, SensorType.Data, s => s.Smart.HostWrites.GetValueOrDefault());
        }

        AddSensor("Power On Count", 23, false, SensorType.Factor, s => s.Smart.PowerOnCount);
        AddSensor("Power On Hours", 24, false, SensorType.Factor, s => Math.Max(s.Smart.MeasuredPowerOnHours, s.Smart.DetectedPowerOnHours));

        _usageSensor = new Sensor("Used Space", 30, SensorType.Load, this, _settings);
        _freeSpaceSensor = new Sensor("Free Space", 31, SensorType.Data, this, _settings);
        ToggleSpaceSensors();

        var totalSpaceSensor = new Sensor("Total Space", 32, SensorType.Data, this, _settings)
        {
            Value = (float)DataStorageSizeConverter.ByteToGigabyte(_storage.TotalSize)
        };
        ActivateSensor(totalSpaceSensor);

        _sensorDiskReadActivity = new Sensor("Read Activity", 51, SensorType.Load, this, _settings);
        ActivateSensor(_sensorDiskReadActivity);

        _sensorDiskWriteActivity = new Sensor("Write Activity", 52, SensorType.Load, this, _settings);
        ActivateSensor(_sensorDiskWriteActivity);

        _sensorDiskTotalActivity = new Sensor("Total Activity", 53, SensorType.Load, this, _settings);
        ActivateSensor(_sensorDiskTotalActivity);

        _sensorDiskReadRate = new Sensor("Read Rate", 54, SensorType.Throughput, this, _settings);
        ActivateSensor(_sensorDiskReadRate);

        _sensorDiskWriteRate = new Sensor("Write Rate", 55, SensorType.Throughput, this, _settings);
        ActivateSensor(_sensorDiskWriteRate);

        AddSmartAttributeSensors();
    }

    private void TryAddTemperatureSensor(int index, bool defaultHidden, int thermalSensorIndex, SmartAttributeType type)
    {
        var attr = GetSmartAttribute(type);
        if (attr != null && attr.Attribute.RawValueULong > 0)
        {
            AddSensor($"Temperature #{thermalSensorIndex}", index, defaultHidden, SensorType.Temperature, s =>
            {
                var a = GetSmartAttribute(type);
                if (a != null)
                {
                    return TemperatureConverter.KelvinToCelsius(a.Attribute.RawValueULong);
                }

                return 0;
            });
        }
    }

    private DiskInfoToolkit.SmartAttribute GetSmartAttribute(SmartAttributeType type)
    {
        return _storage.Smart.SmartAttributes.FirstOrDefault(sa => sa.Info.Type == type);
    }

    private void AddSensor(string name, int index, bool defaultHidden, SensorType sensorType, GetStorageDeviceSensorValue getValue)
    {
        var sensor = new StorageDeviceSensor(name, index, defaultHidden, sensorType, this, _settings, getValue)
        {
            Value = 0
        };

        ActivateSensor(sensor);
        _sensors.Add(sensor);
    }

    private unsafe void UpdatePerformanceSensors()
    {
        DISK_PERFORMANCE diskPerformance = new();

        using var handle = PInvoke.CreateFile(_storage.PhysicalPath,
                                              (uint)FileAccess.ReadWrite,
                                              FILE_SHARE_MODE.FILE_SHARE_READ | FILE_SHARE_MODE.FILE_SHARE_WRITE,
                                              null,
                                              FILE_CREATION_DISPOSITION.OPEN_EXISTING,
                                              FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_NORMAL,
                                              null);

        uint bytesReturned;
        if (!PInvoke.DeviceIoControl((HANDLE)handle.DangerousGetHandle(), PInvoke.IOCTL_DISK_PERFORMANCE, null, 0, &diskPerformance, (uint)sizeof(DISK_PERFORMANCE), &bytesReturned, null))
        {
            return;
        }

        _perfRead.Update(diskPerformance.ReadTime, diskPerformance.QueryTime);
        _sensorDiskReadActivity.Value = (float)_perfRead.Result;

        _perfWrite.Update(diskPerformance.WriteTime, diskPerformance.QueryTime);
        _sensorDiskWriteActivity.Value = (float)_perfWrite.Result;

        _perfTotal.Update(diskPerformance.IdleTime, diskPerformance.QueryTime);
        _sensorDiskTotalActivity.Value = (float)(100 - _perfTotal.Result);

        long readCount = diskPerformance.BytesRead;
        long readDiff = readCount - _lastReadCount;
        _lastReadCount = readCount;

        long writeCount = diskPerformance.BytesWritten;
        long writeDiff = writeCount - _lastWriteCount;
        _lastWriteCount = writeCount;

        long currentTime = Stopwatch.GetTimestamp();
        if (_lastTime != 0)
        {
            double timeDeltaSeconds = TimeSpan.FromTicks(currentTime - _lastTime).TotalSeconds;

            double writeSpeed = writeDiff * (1 / timeDeltaSeconds);
            _sensorDiskWriteRate.Value = (float)writeSpeed;

            double readSpeed = readDiff * (1 / timeDeltaSeconds);
            _sensorDiskReadRate.Value = (float)readSpeed;
        }

        _lastTime = currentTime;
    }

    private void ToggleSpaceSensors()
    {
        if (!_storage.IsDynamicDisk && !_storage.Partitions.Any(p => p.IsOtherOperatingSystemPartition))
        {
            ActivateSensor(_usageSensor);
            ActivateSensor(_freeSpaceSensor);
        }
        else
        {
            DeactivateSensor(_usageSensor);
            DeactivateSensor(_freeSpaceSensor);
        }
    }

    private void UpdateSpaceSensors()
    {
        if (_storage.TotalSize > 0)
        {
            // Set sensor value
            _usageSensor.Value = 100.0f - (100.0f * _storage.TotalFreeSize / _storage.TotalSize);
            _freeSpaceSensor.Value = (float)DataStorageSizeConverter.ByteToGigabyte(_storage.TotalFreeSize.GetValueOrDefault());
        }
        else
        {
            _usageSensor.Value = null;
            _freeSpaceSensor.Value = null;
        }
    }

    private void AddSmartAttributeSensors()
    {
        // Unique attributes by sensor- type and channel
        var attributes = Attributes.Where(sa => sa.SensorType.HasValue)
                                   .GroupBy(sa => new { sa.SensorType.Value, sa.SensorChannel })
                                   .Select(sa => sa.First());

        foreach (var attr in attributes)
        {
            AddSensor(attr.SensorName,
                      attr.SensorChannel,
                      attr.IsHiddenByDefault,
                      attr.SensorType.Value,
                      s => attr.Value);
        }
    }

    /// <summary>
    /// Helper to calculate the disk performance with base timestamps
    /// https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/win32-perfrawdata
    /// </summary>
    private class PerformanceValue
    {
        public double Result { get; private set; }

        private long Time { get; set; }

        private long Value { get; set; }

        public void Update(long val, long valBase)
        {
            long diffValue = val - Value;
            long diffTime = valBase - Time;

            Value = val;
            Time = valBase;
            Result = 100.0 / diffTime * diffValue;

            // sometimes it is possible that diff_value > diff_timebase
            // limit result to 100%, this is because timing issues during read from pcie controller an latency between IO operation
            if (Result > 100)
                Result = 100;
        }
    }
}

```

`LibreHardwareMonitorLib/Hardware/Storage/StorageDeviceSensor.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Hardware.Storage;

internal delegate float GetStorageDeviceSensorValue(DiskInfoToolkit.Storage storage);

internal class StorageDeviceSensor : Sensor
{
    private readonly GetStorageDeviceSensorValue _getValue;

    public StorageDeviceSensor(string name, int index, bool defaultHidden, SensorType sensorType, Hardware hardware, ISettings settings, GetStorageDeviceSensorValue getValue)
        : base(name, index, defaultHidden, sensorType, hardware, null, settings)
    {
        _getValue = getValue;
    }

    public void Update(DiskInfoToolkit.Storage storage)
    {
        var value = _getValue(storage);

        Value = value;
    }
}

```

`LibreHardwareMonitorLib/Hardware/Storage/StorageGroup.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Collections.Generic;
using System.Linq;
using DiskInfoToolkit;
using DiskInfoToolkit.Events;

namespace LibreHardwareMonitor.Hardware.Storage;

internal class StorageGroup : IGroup, IHardwareChanged
{
    private readonly List<StorageDevice> _hardware = new();

    private readonly ISettings _settings;

    public event HardwareEventHandler HardwareAdded;
    public event HardwareEventHandler HardwareRemoved;

    public StorageGroup(ISettings settings)
    {
        if (Software.OperatingSystem.IsUnix)
            return;

        _settings = settings;

        AddHardware(settings);
    }

    public IReadOnlyList<IHardware> Hardware => _hardware;

    private void AddHardware(ISettings settings)
    {
        StorageManager.StoragesChanged -= OnStoragesChanged;

        //Reload storage devices
        StorageManager.ReloadStorages();

        //Transform storage device to hardware
        _hardware.AddRange(StorageManager.Storages.Select(s => new StorageDevice(s, GetID(s), settings)));

        StorageManager.StoragesChanged += OnStoragesChanged;
    }

    private void OnStoragesChanged(StoragesChangedEventArgs e)
    {
        StorageDevice storageDevice = null;

        switch (e.StorageChangeIdentifier)
        {
            case StorageChangeIdentifier.Added:
                storageDevice = new StorageDevice(e.Storage, GetID(e.Storage), _settings);

                _hardware.Add(storageDevice);
                HardwareAdded?.Invoke(storageDevice);
                break;
            case StorageChangeIdentifier.Removed:
                storageDevice = _hardware.Find(sd => sd.Storage == e.Storage);

                if (storageDevice != null)
                {
                    _hardware.Remove(storageDevice);
                    HardwareRemoved?.Invoke(storageDevice);
                }
                break;
        }
    }

    private string GetID(DiskInfoToolkit.Storage storage)
    {
        if (storage.IsNVMe)
            return "nvme";
        else if (storage.IsSSD)
            return "ssd";
        else
            return "hdd";
    }

    public void Close() { }

    public string GetReport() => null;
}

```

`LibreHardwareMonitorLib/Hardware/ThreadAffinity.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using Windows.Win32;
using Windows.Win32.Foundation;
using Windows.Win32.System.SystemInformation;
using LibreHardwareMonitor.Interop;

namespace LibreHardwareMonitor.Hardware;

internal static class ThreadAffinity
{
    /// <summary>
    /// Initializes static members of the <see cref="ThreadAffinity" /> class.
    /// </summary>
    static ThreadAffinity()
    {
        ProcessorGroupCount = Software.OperatingSystem.IsUnix ? 1 : PInvoke.GetActiveProcessorGroupCount();

        if (ProcessorGroupCount < 1)
            ProcessorGroupCount = 1;
    }

    /// <summary>
    /// Gets the processor group count.
    /// </summary>
    public static int ProcessorGroupCount { get; }

    /// <summary>
    /// Sets the processor group affinity for the current thread.
    /// </summary>
    /// <param name="affinity">The processor group affinity.</param>
    /// <returns>The previous processor group affinity.</returns>
    public static unsafe GroupAffinity Set(GroupAffinity affinity)
    {
        if (affinity == GroupAffinity.Undefined)
            return GroupAffinity.Undefined;

        if (Software.OperatingSystem.IsUnix)
        {
            if (affinity.Group > 0)
                throw new ArgumentOutOfRangeException(nameof(affinity));

            ulong result = 0;
            if (LibC.sched_getaffinity(0, (IntPtr)8, ref result) != 0)
                return GroupAffinity.Undefined;

            ulong mask = affinity.Mask;
            return LibC.sched_setaffinity(0, (IntPtr)8, ref mask) != 0
                ? GroupAffinity.Undefined
                : new GroupAffinity(0, result);
        }

        ulong maxValue = IntPtr.Size == 8 ? ulong.MaxValue : uint.MaxValue;
        if (affinity.Mask > maxValue)
            throw new ArgumentOutOfRangeException(nameof(affinity));

        var groupAffinity = new GROUP_AFFINITY { Group = affinity.Group, Mask = (UIntPtr)affinity.Mask };
        GROUP_AFFINITY previousGroupAffinity = new();

        IntPtr currentThread = PInvoke.GetCurrentThread();

        return PInvoke.SetThreadGroupAffinity(new HANDLE(currentThread),
                                              &groupAffinity,
                                              &previousGroupAffinity)
            ? new GroupAffinity(previousGroupAffinity.Group, previousGroupAffinity.Mask)
            : GroupAffinity.Undefined;
    }
}

```

`LibreHardwareMonitorLib/Interop/AtiAdlxx.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Runtime.InteropServices;
using System.Text.RegularExpressions;
using Windows.Win32;

// ReSharper disable InconsistentNaming

namespace LibreHardwareMonitor.Interop;

internal static class AtiAdlxx
{
    public const int ADL_DL_FANCTRL_FLAG_USER_DEFINED_SPEED = 1;

    public const int ADL_DL_FANCTRL_SPEED_TYPE_PERCENT = 1;
    public const int ADL_DL_FANCTRL_SPEED_TYPE_RPM = 2;

    public const int ADL_DL_FANCTRL_SUPPORTS_PERCENT_READ = 1;
    public const int ADL_DL_FANCTRL_SUPPORTS_PERCENT_WRITE = 2;
    public const int ADL_DL_FANCTRL_SUPPORTS_RPM_READ = 4;
    public const int ADL_DL_FANCTRL_SUPPORTS_RPM_WRITE = 8;

    public const int ADL_DRIVER_OK = 0;
    public const int ADL_FALSE = 0;

    public const int ADL_MAX_ADAPTERS = 40;
    public const int ADL_MAX_DEVICENAME = 32;
    public const int ADL_MAX_DISPLAYS = 40;
    public const int ADL_MAX_GLSYNC_PORT_LEDS = 8;
    public const int ADL_MAX_GLSYNC_PORTS = 8;
    public const int ADL_MAX_NUM_DISPLAYMODES = 1024;
    public const int ADL_MAX_PATH = 256;
    public const int ADL_TRUE = 1;

    public const int ATI_VENDOR_ID = 0x1002;

    internal const int ADL_PMLOG_MAX_SENSORS = 256;

    internal const string DllName = "atiadlxx.dll";

    public static Context Context_Alloc = Marshal.AllocHGlobal;

    // create a Main_Memory_Alloc delegate and keep it alive
    public static ADL_Main_Memory_AllocDelegate Main_Memory_Alloc = Marshal.AllocHGlobal;

    public delegate IntPtr ADL_Main_Memory_AllocDelegate(int size);

    public delegate IntPtr Context(int size);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_Overdrive5_ODParameters_Get(IntPtr context, int adapterIndex, out ADLODParameters parameters);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_Overdrive5_CurrentActivity_Get(IntPtr context, int iAdapterIndex, ref ADLPMActivity activity);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_Overdrive5_Temperature_Get(IntPtr context, int adapterIndex, int thermalControllerIndex, ref ADLTemperature temperature);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_OverdriveN_Temperature_Get(IntPtr context, int adapterIndex, ADLODNTemperatureType iTemperatureType, ref int temp);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_Overdrive5_FanSpeed_Get(IntPtr context, int adapterIndex, int thermalControllerIndex, ref ADLFanSpeedValue fanSpeedValue);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_Overdrive5_FanSpeedInfo_Get(IntPtr context, int adapterIndex, int thermalControllerIndex, ref ADLFanSpeedInfo fanSpeedInfo);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_Overdrive5_FanSpeedToDefault_Set(IntPtr context, int adapterIndex, int thermalControllerIndex);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_Overdrive5_FanSpeed_Set(IntPtr context, int adapterIndex, int thermalControllerIndex, ref ADLFanSpeedValue fanSpeedValue);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_OverdriveN_PerformanceStatus_Get(IntPtr context, int adapterIndex, out ADLODNPerformanceStatus performanceStatus);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_Overdrive_Caps(IntPtr context, int adapterIndex, ref int supported, ref int enabled, ref int version);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_Overdrive6_Capabilities_Get(IntPtr context, int adapterIndex, ref ADLOD6Capabilities lpODCapabilities);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_Overdrive6_CurrentPower_Get(IntPtr context, int adapterIndex, ADLODNCurrentPowerType powerType, ref int currentValue);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_Main_Control_Create(ADL_Main_Memory_AllocDelegate callback, int connectedAdapters, ref IntPtr context);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_Main_Control_Destroy(IntPtr context);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_New_QueryPMLogData_Get(IntPtr context, int adapterIndex, ref ADLPMLogDataOutput aDLPMLogDataOutput);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_Adapter_FrameMetrics_Caps(IntPtr context, int adapterIndex, ref int supported);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_Adapter_FrameMetrics_Get(IntPtr context, int adapterIndex, int displayIndex, ref float fps);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_Adapter_FrameMetrics_Start(IntPtr context, int adapterIndex, int displayIndex);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_Adapter_FrameMetrics_Stop(IntPtr context, int adapterIndex, int displayIndex);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_Adapter_PMLog_Support_Get(IntPtr context, int adapterIndex,
                                                                  ref ADLPMLogSupportInfo pPMLogSupportInfo);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_Adapter_PMLog_Start(IntPtr context, int adapterIndex,
                                                            ref ADLPMLogStartInput pPMLogStartInput,
                                                            ref ADLPMLogStartOutput pPMLogStartOutput,
                                                            uint device);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_Adapter_PMLog_Stop(IntPtr context, int adapterIndex, uint device);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_Device_PMLog_Device_Create(IntPtr context, int adapterIndex, ref uint device);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_Device_PMLog_Device_Destroy(IntPtr context, uint device);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_GcnAsicInfo_Get(IntPtr context, int adapterIndex, ref ADLGcnInfo gcnInfo);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_Adapter_NumberOfAdapters_Get(IntPtr context, ref int numAdapters);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_Adapter_AdapterInfo_Get(IntPtr context, IntPtr adapterInfo, int size);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_Adapter_ID_Get(IntPtr context, int adapterIndex, out int adapterId);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_Adapter_Active_Get(IntPtr context, int adapterIndex, out int status);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_Adapter_DedicatedVRAMUsage_Get(IntPtr context, int adapterIndex, out int iVRAMUsageInMB);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern ADLStatus ADL2_Adapter_MemoryInfoX4_Get(IntPtr context, int adapterIndex, out ADLMemoryInfoX4 memoryInfo);

    public static bool ADL_Method_Exists(string ADL_Method)
    {
        FreeLibrarySafeHandle module = PInvoke.LoadLibrary(DllName);
        if (!module.IsInvalid)
        {
            bool result = PInvoke.GetProcAddress(module, ADL_Method) != IntPtr.Zero;
            module.Dispose();
            return result;
        }

        return false;
    }

    public static ADLStatus ADL2_Adapter_AdapterInfo_Get(ref IntPtr context, ADLAdapterInfo[] info)
    {
        int elementSize = Marshal.SizeOf(typeof(ADLAdapterInfo));
        int size = info.Length * elementSize;
        IntPtr ptr = Marshal.AllocHGlobal(size);
        ADLStatus result = ADL2_Adapter_AdapterInfo_Get(context, ptr, size);
        for (int i = 0; i < info.Length; i++)
            info[i] = (ADLAdapterInfo)Marshal.PtrToStructure((IntPtr)((long)ptr + (i * elementSize)), typeof(ADLAdapterInfo));

        Marshal.FreeHGlobal(ptr);

        // the ADLAdapterInfo.VendorID field reported by ADL is wrong on
        // Windows systems (parse error), so we fix this here
        for (int i = 0; i < info.Length; i++)
        {
            // try Windows UDID format
            Match m = Regex.Match(info[i].UDID, "PCI_VEN_([A-Fa-f0-9]{1,4})&.*");
            if (m.Success && m.Groups.Count == 2)
            {
                info[i].VendorID = Convert.ToInt32(m.Groups[1].Value, 16);
                continue;
            }

            // if above failed, try Unix UDID format
            m = Regex.Match(info[i].UDID, "[0-9]+:[0-9]+:([0-9]+):[0-9]+:[0-9]+");
            if (m.Success && m.Groups.Count == 2)
            {
                info[i].VendorID = Convert.ToInt32(m.Groups[1].Value, 10);
            }
        }

        return result;
    }

    public static bool UsePmLogForFamily(int familyId)
    {
        return familyId >= (int)GCNFamilies.FAMILY_AI;
    }

    internal enum ADLStatus
    {
        /// <summary>
        /// All OK, but need to wait.
        /// </summary>
        ADL_OK_WAIT = 4,

        /// <summary>
        /// All OK, but need restart.
        /// </summary>
        ADL_OK_RESTART = 3,

        /// <summary>
        /// All OK but need mode change.
        /// </summary>
        ADL_OK_MODE_CHANGE = 2,

        /// <summary>
        /// All OK, but with warning.
        /// </summary>
        ADL_OK_WARNING = 1,

        /// <summary>
        /// ADL function completed successfully.
        /// </summary>
        ADL_OK = 0,

        /// <summary>
        /// Generic Error. Most likely one or more of the Escape calls to the driver
        /// failed!
        /// </summary>
        ADL_ERR = -1,

        /// <summary>
        /// ADL not initialized.
        /// </summary>
        ADL_ERR_NOT_INIT = -2,

        /// <summary>
        /// One of the parameter passed is invalid.
        /// </summary>
        ADL_ERR_INVALID_PARAM = -3,

        /// <summary>
        /// One of the parameter size is invalid.
        /// </summary>
        ADL_ERR_INVALID_PARAM_SIZE = -4,

        /// <summary>
        /// Invalid ADL index passed.
        /// </summary>
        ADL_ERR_INVALID_ADL_IDX = -5,

        /// <summary>
        /// Invalid controller index passed.
        /// </summary>
        ADL_ERR_INVALID_CONTROLLER_IDX = -6,

        /// <summary>
        /// Invalid display index passed.
        /// </summary>
        ADL_ERR_INVALID_DIPLAY_IDX = -7,

        /// <summary>
        /// Function not supported by the driver.
        /// </summary>
        ADL_ERR_NOT_SUPPORTED = -8,

        /// <summary>
        /// Null Pointer error.
        /// </summary>
        ADL_ERR_NULL_POINTER = -9,

        /// <summary>
        /// Call can't be made due to disabled adapter.
        /// </summary>
        ADL_ERR_DISABLED_ADAPTER = -10,

        /// <summary>
        /// Invalid Callback.
        /// </summary>
        ADL_ERR_INVALID_CALLBACK = -11,

        /// <summary>
        /// Display Resource conflict.
        /// </summary>
        ADL_ERR_RESOURCE_CONFLICT = -12,

        /// <summary>
        /// Failed to update some of the values. Can be returned by set request that
        /// include multiple values if not all values were successfully committed.
        /// </summary>
        ADL_ERR_SET_INCOMPLETE = -20,

        /// <summary>
        /// There's no Linux XDisplay in Linux Console environment.
        /// </summary>
        ADL_ERR_NO_XDISPLAY = -21
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct ADLAdapterInfo
    {
        public int Size;
        public int AdapterIndex;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = ADL_MAX_PATH)]
        public string UDID;

        public int BusNumber;
        public int DeviceNumber;
        public int FunctionNumber;
        public int VendorID;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = ADL_MAX_PATH)]
        public string AdapterName;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = ADL_MAX_PATH)]
        public string DisplayName;

        public int Present;
        public int Exist;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = ADL_MAX_PATH)]
        public string DriverPath;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = ADL_MAX_PATH)]
        public string DriverPathExt;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = ADL_MAX_PATH)]
        public string PNPString;

        public int OSDisplayIndex;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct ADLODParameterRange
    {
        public int iMin;
        public int iMax;
        public int iStep;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct ADLODParameters
    {
        public int iSize;
        public int iNumberOfPerformanceLevels;
        public int iActivityReportingSupported;
        public int iDiscretePerformanceLevels;
        public int iReserved;
        public ADLODParameterRange sEngineClock;
        public ADLODParameterRange sMemoryClock;
        public ADLODParameterRange sVddc;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct ADLOD6Capabilities
    {
        public int iCapabilities;
        public int iSupportedStates;
        public int iNumberOfPerformanceLevels;
        public ADLODParameterRange sEngineClockRange;
        public ADLODParameterRange sMemoryClockRange;
        public int iExtValue;
        public int iExtMask;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct ADLPMActivity
    {
        public int iSize;
        public int iEngineClock;
        public int iMemoryClock;
        public int iVddc;
        public int iActivityPercent;
        public int iCurrentPerformanceLevel;
        public int iCurrentBusSpeed;
        public int iCurrentBusLanes;
        public int iMaximumBusLanes;
        public int iReserved;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct ADLTemperature
    {
        public int iSize;
        public int iTemperature;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct ADLFanSpeedValue
    {
        public int iSize;
        public int iSpeedType;
        public int iFanSpeed;
        public int iFlags;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct ADLFanSpeedInfo
    {
        public int iSize;
        public int iFlags;
        public int iMinPercent;
        public int iMaxPercent;
        public int iMinRPM;
        public int iMaxRPM;
    }

    internal enum ADLODNCurrentPowerType
    {
        ODN_GPU_TOTAL_POWER = 0,
        ODN_GPU_PPT_POWER,
        ODN_GPU_SOCKET_POWER,
        ODN_GPU_CHIP_POWER
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct ADLVersionsInfo
    {
        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
        public string DriverVer;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
        public string CatalystVersion;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
        public string CatalystWebLink;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct ADLODNPerformanceStatus
    {
        public int iCoreClock;
        public int iMemoryClock;
        public int iDCEFClock;
        public int iGFXClock;
        public int iUVDClock;
        public int iVCEClock;
        public int iGPUActivityPercent;
        public int iCurrentCorePerformanceLevel;
        public int iCurrentMemoryPerformanceLevel;
        public int iCurrentDCEFPerformanceLevel;
        public int iCurrentGFXPerformanceLevel;
        public int iUVDPerformanceLevel;
        public int iVCEPerformanceLevel;
        public int iCurrentBusSpeed;
        public int iCurrentBusLanes;
        public int iMaximumBusLanes;
        public int iVDDC;
        public int iVDDCI;
    }

    internal enum ADLODNTemperatureType
    {
        // This typed is named like this in the documentation but for some reason AMD failed to include it...
        // Yet it seems these correspond with ADL_PMLOG_TEMPERATURE_xxx.
        EDGE = 1,
        MEM = 2,
        VRVDDC = 3,
        VRMVDD = 4,
        LIQUID = 5,
        PLX = 6,
        HOTSPOT = 7
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct ADLSingleSensorData
    {
        public int supported;
        public int value;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct ADLPMLogDataOutput
    {
        public int size;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = ADL_PMLOG_MAX_SENSORS)]
        public ADLSingleSensorData[] sensors;
    }

    internal enum ADLPMLogSensors
    {
        ADL_SENSOR_MAXTYPES             = 0,
        ADL_PMLOG_CLK_GFXCLK            = 1,
        ADL_PMLOG_CLK_MEMCLK            = 2,
        ADL_PMLOG_CLK_SOCCLK            = 3,
        ADL_PMLOG_CLK_UVDCLK1           = 4,
        ADL_PMLOG_CLK_UVDCLK2           = 5,
        ADL_PMLOG_CLK_VCECLK            = 6,
        ADL_PMLOG_CLK_VCNCLK            = 7,
        ADL_PMLOG_TEMPERATURE_EDGE      = 8,
        ADL_PMLOG_TEMPERATURE_MEM       = 9,
        ADL_PMLOG_TEMPERATURE_VRVDDC    = 10,
        ADL_PMLOG_TEMPERATURE_VRMVDD    = 11,
        ADL_PMLOG_TEMPERATURE_LIQUID    = 12,
        ADL_PMLOG_TEMPERATURE_PLX       = 13,
        ADL_PMLOG_FAN_RPM               = 14,
        ADL_PMLOG_FAN_PERCENTAGE        = 15,
        ADL_PMLOG_SOC_VOLTAGE           = 16,
        ADL_PMLOG_SOC_POWER             = 17,
        ADL_PMLOG_SOC_CURRENT           = 18,
        ADL_PMLOG_INFO_ACTIVITY_GFX     = 19,
        ADL_PMLOG_INFO_ACTIVITY_MEM     = 20,
        ADL_PMLOG_GFX_VOLTAGE           = 21,
        ADL_PMLOG_MEM_VOLTAGE           = 22,
        ADL_PMLOG_ASIC_POWER            = 23,
        ADL_PMLOG_TEMPERATURE_VRSOC     = 24,
        ADL_PMLOG_TEMPERATURE_VRMVDD0   = 25,
        ADL_PMLOG_TEMPERATURE_VRMVDD1   = 26,
        ADL_PMLOG_TEMPERATURE_HOTSPOT   = 27,
        ADL_PMLOG_TEMPERATURE_GFX       = 28,
        ADL_PMLOG_TEMPERATURE_SOC       = 29,
        ADL_PMLOG_GFX_POWER             = 30,
        ADL_PMLOG_GFX_CURRENT           = 31,
        ADL_PMLOG_TEMPERATURE_CPU       = 32,
        ADL_PMLOG_CPU_POWER             = 33,
        ADL_PMLOG_CLK_CPUCLK            = 34,
        ADL_PMLOG_THROTTLER_STATUS      = 35,   // GFX
        ADL_PMLOG_CLK_VCN1CLK1          = 36,
        ADL_PMLOG_CLK_VCN1CLK2          = 37,
        ADL_PMLOG_SMART_POWERSHIFT_CPU  = 38,
        ADL_PMLOG_SMART_POWERSHIFT_DGPU = 39,
        ADL_PMLOG_BUS_SPEED             = 40,
        ADL_PMLOG_BUS_LANES             = 41,
        ADL_PMLOG_TEMPERATURE_LIQUID0   = 42,
        ADL_PMLOG_TEMPERATURE_LIQUID1   = 43,
        ADL_PMLOG_CLK_FCLK              = 44,
        ADL_PMLOG_THROTTLER_STATUS_CPU  = 45,
        ADL_PMLOG_SSPAIRED_ASICPOWER    = 46, // apuPower
        ADL_PMLOG_SSTOTAL_POWERLIMIT    = 47, // Total Power limit
        ADL_PMLOG_SSAPU_POWERLIMIT      = 48, // APU Power limit
        ADL_PMLOG_SSDGPU_POWERLIMIT     = 49, // DGPU Power limit
        ADL_PMLOG_TEMPERATURE_HOTSPOT_GCD      = 50,
        ADL_PMLOG_TEMPERATURE_HOTSPOT_MCD      = 51,
        ADL_PMLOG_THROTTLER_TEMP_EDGE_PERCENTAGE        = 52,
        ADL_PMLOG_THROTTLER_TEMP_HOTSPOT_PERCENTAGE     = 53,
        ADL_PMLOG_THROTTLER_TEMP_HOTSPOT_GCD_PERCENTAGE = 54,
        ADL_PMLOG_THROTTLER_TEMP_HOTSPOT_MCD_PERCENTAGE = 55,
        ADL_PMLOG_THROTTLER_TEMP_MEM_PERCENTAGE     = 56,
        ADL_PMLOG_THROTTLER_TEMP_VR_GFX_PERCENTAGE  = 57,
        ADL_PMLOG_THROTTLER_TEMP_VR_MEM0_PERCENTAGE = 58,
        ADL_PMLOG_THROTTLER_TEMP_VR_MEM1_PERCENTAGE = 59,
        ADL_PMLOG_THROTTLER_TEMP_VR_SOC_PERCENTAGE  = 60,
        ADL_PMLOG_THROTTLER_TEMP_LIQUID0_PERCENTAGE = 61,
        ADL_PMLOG_THROTTLER_TEMP_LIQUID1_PERCENTAGE = 62,
        ADL_PMLOG_THROTTLER_TEMP_PLX_PERCENTAGE = 63,
        ADL_PMLOG_THROTTLER_TDC_GFX_PERCENTAGE  = 64,
        ADL_PMLOG_THROTTLER_TDC_SOC_PERCENTAGE  = 65,
        ADL_PMLOG_THROTTLER_TDC_USR_PERCENTAGE  = 66,
        ADL_PMLOG_THROTTLER_PPT0_PERCENTAGE     = 67,
        ADL_PMLOG_THROTTLER_PPT1_PERCENTAGE     = 68,
        ADL_PMLOG_THROTTLER_PPT2_PERCENTAGE     = 69,
        ADL_PMLOG_THROTTLER_PPT3_PERCENTAGE     = 70,
        ADL_PMLOG_THROTTLER_FIT_PERCENTAGE           = 71,
        ADL_PMLOG_THROTTLER_GFX_APCC_PLUS_PERCENTAGE = 72,
        ADL_PMLOG_BOARD_POWER                        = 73,
        ADL_PMLOG_MAX_SENSORS_REAL
    }

    internal enum GCNFamilies
    {
        FAMILY_UNKNOWN = 0,
        FAMILY_TN = 105, // Trinity APUs
        FAMILY_SI = 110, // Southern Islands: Tahiti, Pitcairn, CapeVerde, Oland, Hainan
        FAMILY_CI = 120, // Sea Islands: Bonaire, Hawaii
        FAMILY_KV = 125, // Kaveri, Kabini, Mullins
        FAMILY_VI = 130, // Volcanic Islands: Iceland, Tonga, Fiji
        FAMILY_CZ = 135, // Carrizo APUs: Carrizo, Stoney
        FAMILY_AI = 141, // Vega: 10, 20
        FAMILY_RV = 142, // Raven (Vega GCN 5.0)
        FAMILY_NV = 143, // Navi10, Navi2x
        FAMILY_VGH = 144, // Van Gogh (RDNA 2.0)
        FAMILY_NV3 = 145, // Navi: 3x (GC 11.0.0, RDNA 3.0)
        FAMILY_YC = 146, // Rembrandt (Yellow Carp, RDNA 2.0)
        FAMILY_GC_11_0_1 = 148, // Phoenix (GC 11.0.1, RDNA 3.0)
        FAMILY_GC_10_3_6 = 149, // Raphael (GC 10.3.6, RDNA 2.0)
        FAMILY_GC_11_5_0 = 150, // GC 11.5.0
        FAMILY_GC_10_3_7 = 151, // Mendocino (GC 10.3.7, RDNA 2.0)
    }

    //Structure containing information related power management logging.
    [StructLayout(LayoutKind.Sequential)]
    internal struct ADLPMLogSupportInfo
    {
        /// list of sensors defined by ADL_PMLOG_SENSORS
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = ADL_PMLOG_MAX_SENSORS)]
        public ushort[] usSensors;

        /// Reserved
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
        public int[] iReserved;
    }

    //Structure containing information to start power management logging.
    [StructLayout(LayoutKind.Sequential)]
    internal struct ADLPMLogStartInput
    {
        /// list of sensors defined by ADL_PMLOG_SENSORS
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = ADL_PMLOG_MAX_SENSORS)]
        public ushort[] usSensors;

        /// Sample rate in milliseconds
        public uint ulSampleRate;

        /// Reserved
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 15)]
        public int[] iReserved;
    }

    //Structure containing information to start power management logging.
    [StructLayout(LayoutKind.Explicit)]
    internal struct ADLPMLogStartOutput
    {
        /// Pointer to memory address containing logging data
        [FieldOffset(0)] public IntPtr pLoggingAddress;
        [FieldOffset(0)] public ulong ptrLoggingAddress;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct ADLPMLogData
    {
        /// Structure version
        public uint ulVersion;

        /// Current driver sample rate
        public uint ulActiveSampleRate;

        /// Timestamp of last update
        public ulong ulLastUpdated;

        // 2D array of sensor and values -- unsigned int ulValues[ADL_PMLOG_MAX_SUPPORTED_SENSORS][2]
        // the nested array will be accessed like a single dimension array
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = ADL_PMLOG_MAX_SENSORS*2)]
        public uint[] ulValues;

        /// Reserved
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 256)]
        public uint[] ulReserved;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct ADLGcnInfo
    {
        public int CuCount; //Number of compute units on the ASIC.
        public int TexCount; //Number of texture mapping units.
        public int RopCount; //Number of Render backend Units.

        // see GCNFamilies enum, references:
        //        https://gitlab.freedesktop.org/mesa/mesa/-/blob/main/src/amd/addrlib/src/amdgpu_asic_addr.h
        //        https://github.com/torvalds/linux/blob/master/include/uapi/drm/amdgpu_drm.h
        public int ASICFamilyId;
        public int ASICRevisionId;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct ADLMemoryInfoX4
    {
        /// Memory size in bytes.
        public long iMemorySize;
        /// Memory type in string.
        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = ADL_MAX_PATH)]
        public string strMemoryType;
        /// Highest default performance level Memory bandwidth in Mbytes/s
        public long iMemoryBandwidth;
        /// HyperMemory size in bytes.
        public long iHyperMemorySize;
        /// Invisible Memory size in bytes.
        public long iInvisibleMemorySize;
        /// Visible Memory size in bytes.
        public long iVisibleMemorySize;
        /// Vram vendor ID
        public long iVramVendorRevId;
        /// Memory Bandiwidth that is calculated and finalized on the driver side, grab and go.
        public long iMemoryBandwidthX2;
        /// Memory Bit Rate that is calculated and finalized on the driver side, grab and go.
        public long iMemoryBitRateX2;
    }
}

```

`LibreHardwareMonitorLib/Interop/ByteExtensions.cs`:

```cs
using Windows.Win32;

namespace LibreHardwareMonitor.Interop;

#if NET8_0_OR_GREATER

internal static class ByteExtensions
{
    public static byte[] ToArray(this __byte_4 bytes)
    {
        return bytes.AsReadOnlySpan().ToArray();
    }
}

#endif

```

`LibreHardwareMonitorLib/Interop/Ftd2xx.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Runtime.InteropServices;
using Windows.Win32;

// ReSharper disable InconsistentNaming

namespace LibreHardwareMonitor.Interop;

internal static class Ftd2xx
{
    private const string DllName = "Ftd2xx.dll";

    public static bool DllExists()
    {
        FreeLibrarySafeHandle module = PInvoke.LoadLibrary(DllName);
        if (module.IsInvalid)
            return false;

        module.Dispose();
        return true;
    }

    [DllImport(DllName)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern FT_STATUS FT_CreateDeviceInfoList(out uint numDevices);

    [DllImport(DllName)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern FT_STATUS FT_GetDeviceInfoList([Out] FT_DEVICE_INFO_NODE[] deviceInfoNodes, ref uint length);

    [DllImport(DllName)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern FT_STATUS FT_Open(int device, out FT_HANDLE handle);

    [DllImport(DllName)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern FT_STATUS FT_Close(FT_HANDLE handle);

    [DllImport(DllName)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern FT_STATUS FT_SetBaudRate(FT_HANDLE handle, uint baudRate);

    [DllImport(DllName)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern FT_STATUS FT_SetDataCharacteristics(FT_HANDLE handle, byte wordLength, byte stopBits, byte parity);

    [DllImport(DllName)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern FT_STATUS FT_SetFlowControl(FT_HANDLE handle, FT_FLOW_CONTROL flowControl, byte xon, byte xoff);

    [DllImport(DllName)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern FT_STATUS FT_SetTimeouts(FT_HANDLE handle, uint readTimeout, uint writeTimeout);

    [DllImport(DllName)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern FT_STATUS FT_Write(FT_HANDLE handle, byte[] buffer, uint bytesToWrite, out uint bytesWritten);

    [DllImport(DllName)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern FT_STATUS FT_Purge(FT_HANDLE handle, FT_PURGE mask);

    [DllImport(DllName)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern FT_STATUS FT_GetStatus(FT_HANDLE handle, out uint amountInRxQueue, out uint amountInTxQueue, out uint eventStatus);

    [DllImport(DllName)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern FT_STATUS FT_Read(FT_HANDLE handle, [Out] byte[] buffer, uint bytesToRead, out uint bytesReturned);

    [DllImport(DllName)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern FT_STATUS FT_ReadByte(FT_HANDLE handle, out byte buffer, uint bytesToRead, out uint bytesReturned);

    public static FT_STATUS Write(FT_HANDLE handle, byte[] buffer)
    {
        FT_STATUS status = FT_Write(handle, buffer, (uint)buffer.Length, out uint bytesWritten);
        if (bytesWritten != buffer.Length)
            return FT_STATUS.FT_FAILED_TO_WRITE_DEVICE;

        return status;
    }

    public static int BytesToRead(FT_HANDLE handle)
    {
        if (FT_GetStatus(handle, out uint amountInRxQueue, out uint _, out uint _) == FT_STATUS.FT_OK)
            return (int)amountInRxQueue;

        return 0;
    }

    public static byte ReadByte(FT_HANDLE handle)
    {
        FT_STATUS status = FT_ReadByte(handle, out byte buffer, 1, out uint bytesReturned);
        if (status != FT_STATUS.FT_OK || bytesReturned != 1)
            throw new InvalidOperationException();

        return buffer;
    }

    public static void Read(FT_HANDLE handle, byte[] buffer)
    {
        FT_STATUS status = FT_Read(handle, buffer, (uint)buffer.Length, out uint bytesReturned);
        if (status != FT_STATUS.FT_OK || bytesReturned != buffer.Length)
            throw new InvalidOperationException();
    }

    internal enum FT_DEVICE : uint
    {
        FT_DEVICE_232BM,
        FT_DEVICE_232AM,
        FT_DEVICE_100AX,
        FT_DEVICE_UNKNOWN,
        FT_DEVICE_2232C,
        FT_DEVICE_232R,
        FT_DEVICE_2232H,
        FT_DEVICE_4232H
    }

    internal enum FT_STATUS
    {
        FT_OK,
        FT_INVALID_HANDLE,
        FT_DEVICE_NOT_FOUND,
        FT_DEVICE_NOT_OPENED,
        FT_IO_ERROR,
        FT_INSUFFICIENT_RESOURCES,
        FT_INVALID_PARAMETER,
        FT_INVALID_BAUD_RATE,
        FT_DEVICE_NOT_OPENED_FOR_ERASE,
        FT_DEVICE_NOT_OPENED_FOR_WRITE,
        FT_FAILED_TO_WRITE_DEVICE,
        FT_EEPROM_READ_FAILED,
        FT_EEPROM_WRITE_FAILED,
        FT_EEPROM_ERASE_FAILED,
        FT_EEPROM_NOT_PRESENT,
        FT_EEPROM_NOT_PROGRAMMED,
        FT_INVALID_ARGS,
        FT_OTHER_ERROR
    }

    internal enum FT_FLOW_CONTROL : ushort
    {
        FT_FLOW_DTR_DSR = 512,
        FT_FLOW_NONE = 0,
        FT_FLOW_RTS_CTS = 256,
        FT_FLOW_XON_XOFF = 1024
    }

    internal enum FT_PURGE : uint
    {
        FT_PURGE_RX = 1,
        FT_PURGE_TX = 2,
        FT_PURGE_ALL = 3
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct FT_HANDLE
    {
        private readonly IntPtr _handle;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct FT_DEVICE_INFO_NODE
    {
        public uint Flags;
        public FT_DEVICE Type;
        public uint ID;
        public uint LocId;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 16)]
        public string SerialNumber;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 64)]
        public string Description;

        public FT_HANDLE Handle;
    }
}

```

`LibreHardwareMonitorLib/Interop/IntelGcl.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using Windows.Win32;

namespace LibreHardwareMonitor.Interop;

internal static class IntelGcl
{
    public const int CTL_FAN_COUNT = 5;
    public const uint CTL_IMPL_MAJOR_VERSION = 1;
    public const uint CTL_IMPL_MINOR_VERSION = 1;
    public const uint CTL_IMPL_VERSION = (CTL_IMPL_MAJOR_VERSION << 16) | CTL_IMPL_MINOR_VERSION;
    public const int CTL_MAX_DEVICE_NAME_LEN = 100;
    public const int CTL_MAX_RESERVED_SIZE = 112;
    public const int CTL_PSU_COUNT = 5;
    public const int MAX_DEVICES = 64;
    public const int MAX_STRING_LENGTH = 256;

    private const string DllName = "ControlLib.dll";

    static IntelGcl()
    {
        IsAvailable = GclMethodExists(nameof(ctlInit)) && GclMethodExists(nameof(ctlEnumerateDevices));
    }

    public enum ctl_data_type_t
    {
        CTL_DATA_TYPE_INT8 = 0,
        CTL_DATA_TYPE_UINT8 = 1,
        CTL_DATA_TYPE_INT16 = 2,
        CTL_DATA_TYPE_UINT16 = 3,
        CTL_DATA_TYPE_INT32 = 4,
        CTL_DATA_TYPE_UINT32 = 5,
        CTL_DATA_TYPE_INT64 = 6,
        CTL_DATA_TYPE_UINT64 = 7,
        CTL_DATA_TYPE_FLOAT = 8,
        CTL_DATA_TYPE_DOUBLE = 9,
        CTL_DATA_TYPE_STRING_ASCII = 10,
        CTL_DATA_TYPE_STRING_UTF16 = 11,
        CTL_DATA_TYPE_STRING_UTF132 = 12,
        CTL_DATA_TYPE_UNKNOWN = 0x4800FFFF
    }

    public enum ctl_device_type_t
    {
        CTL_DEVICE_TYPE_GRAPHICS = 1,
        CTL_DEVICE_TYPE_SYSTEM = 2,
        CTL_DEVICE_TYPE_MAX
    }

    /// <summary>
    /// Adapter properties flags from ctl_adapter_properties_flags_t.
    /// The graphics_adapter_properties field is a bitmask of these values.
    /// </summary>
    public enum ctl_adapter_properties_flag_t : uint
    {
        CTL_ADAPTER_PROPERTIES_FLAG_INTEGRATED = 1 << 0,
        CTL_ADAPTER_PROPERTIES_FLAG_LDA_PRIMARY = 1 << 1,
        CTL_ADAPTER_PROPERTIES_FLAG_LDA_SECONDARY = 1 << 2,
    }

    public enum ctl_fan_speed_mode_t
    {
        CTL_FAN_SPEED_MODE_DEFAULT = 0,
        CTL_FAN_SPEED_MODE_FIXED = 1,
        CTL_FAN_SPEED_MODE_TABLE = 2,
        CTL_FAN_SPEED_MODE_MAX
    }

    public enum ctl_fan_speed_units_t
    {
        CTL_FAN_SPEED_UNITS_RPM = 0,
        CTL_FAN_SPEED_UNITS_PERCENT = 1,
        CTL_FAN_SPEED_UNITS_MAX
    }

    public enum ctl_freq_domain_t
    {
        CTL_FREQ_DOMAIN_GPU = 0,
        CTL_FREQ_DOMAIN_MEMORY = 1,
        CTL_FREQ_DOMAIN_MEDIA = 2,
        CTL_FREQ_DOMAIN_MAX
    }

    // Initialization flags
    public enum ctl_init_flag_t : uint
    {
        CTL_INIT_FLAG_USE_LEVEL_ZERO = 1 << 0, // CTL_BIT(0) - Required for telemetry
        CTL_INIT_FLAG_MAX = 0x80000000
    }

    public enum ctl_psu_type_t
    {
        CTL_PSU_TYPE_PSU_NONE = 0,
        CTL_PSU_TYPE_PSU_PCIE = 1,
        CTL_PSU_TYPE_PSU_6PIN = 2,
        CTL_PSU_TYPE_PSU_8PIN = 3
    }

    // Enums
    public enum ctl_result_t
    {
        CTL_RESULT_SUCCESS = 0x00000000,
        CTL_RESULT_SUCCESS_STILL_OPEN_BY_ANOTHER_CALLER = 0x00000001,
        CTL_RESULT_ERROR_SUCCESS_END = 0x0000FFFF,
        CTL_RESULT_ERROR_GENERIC_START = 0x40000000,
        CTL_RESULT_ERROR_NOT_INITIALIZED = 0x40000001,
        CTL_RESULT_ERROR_ALREADY_INITIALIZED = 0x40000002,
        CTL_RESULT_ERROR_DEVICE_LOST = 0x40000003,
        CTL_RESULT_ERROR_OUT_OF_HOST_MEMORY = 0x40000004,
        CTL_RESULT_ERROR_OUT_OF_DEVICE_MEMORY = 0x40000005,
        CTL_RESULT_ERROR_INSUFFICIENT_PERMISSIONS = 0x40000006,
        CTL_RESULT_ERROR_NOT_AVAILABLE = 0x40000007,
        CTL_RESULT_ERROR_UNINITIALIZED = 0x40000008,
        CTL_RESULT_ERROR_UNSUPPORTED_VERSION = 0x40000009,
        CTL_RESULT_ERROR_UNSUPPORTED_FEATURE = 0x4000000a,
        CTL_RESULT_ERROR_INVALID_ARGUMENT = 0x4000000b,
        CTL_RESULT_ERROR_INVALID_API_HANDLE = 0x4000000c,
        CTL_RESULT_ERROR_INVALID_NULL_HANDLE = 0x4000000d,
        CTL_RESULT_ERROR_INVALID_NULL_POINTER = 0x4000000e,
        CTL_RESULT_ERROR_INVALID_SIZE = 0x4000000f,
        CTL_RESULT_ERROR_UNSUPPORTED_SIZE = 0x40000010,
        CTL_RESULT_ERROR_UNSUPPORTED_ALIGNMENT = 0x40000011,
        CTL_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT = 0x40000012,
        CTL_RESULT_ERROR_INVALID_ENUMERATION = 0x40000013,
        CTL_RESULT_ERROR_UNSUPPORTED_ENUMERATION = 0x40000014,
        CTL_RESULT_ERROR_UNSUPPORTED_IMAGE_FORMAT = 0x40000015,
        CTL_RESULT_ERROR_INVALID_NATIVE_BINARY = 0x40000016,
        CTL_RESULT_ERROR_INVALID_GLOBAL_NAME = 0x40000017,
        CTL_RESULT_ERROR_INVALID_KERNEL_NAME = 0x40000018,
        CTL_RESULT_ERROR_INVALID_FUNCTION_NAME = 0x40000019,
        CTL_RESULT_ERROR_INVALID_GROUP_SIZE_DIMENSION = 0x4000001a,
        CTL_RESULT_ERROR_INVALID_GLOBAL_WIDTH_DIMENSION = 0x4000001b,
        CTL_RESULT_ERROR_INVALID_KERNEL_ARGUMENT_INDEX = 0x4000001c,
        CTL_RESULT_ERROR_INVALID_KERNEL_ARGUMENT_SIZE = 0x4000001d,
        CTL_RESULT_ERROR_INVALID_KERNEL_ATTRIBUTE_VALUE = 0x4000001e,
        CTL_RESULT_ERROR_INVALID_MODULE_UNLINKED = 0x4000001f,
        CTL_RESULT_ERROR_INVALID_COMMAND_LIST_TYPE = 0x40000020,
        CTL_RESULT_ERROR_OVERLAPPING_REGIONS = 0x40000021,
        CTL_RESULT_ERROR_UNKNOWN = 0x4000FFFF
    }

    public enum ctl_units_t
    {
        CTL_UNITS_FREQUENCY_MHZ = 0,
        CTL_UNITS_OPERATIONS_GTS = 1,
        CTL_UNITS_OPERATIONS_MTS = 2,
        CTL_UNITS_VOLTAGE_VOLTS = 3,
        CTL_UNITS_POWER_WATTS = 4,
        CTL_UNITS_TEMPERATURE_CELSIUS = 5,
        CTL_UNITS_ENERGY_JOULES = 6,
        CTL_UNITS_TIME_SECONDS = 7,
        CTL_UNITS_MEMORY_BYTES = 8,
        CTL_UNITS_ANGULAR_SPEED_RPM = 9,
        CTL_UNITS_POWER_MILLIWATTS = 10,
        CTL_UNITS_PERCENT = 11,
        CTL_UNITS_MEM_SPEED_GBPS = 12,
        CTL_UNITS_VOLTAGE_MILLIVOLTS = 13,
        CTL_UNITS_BANDWIDTH_MBPS = 14,
        CTL_UNITS_UNKNOWN = 0x4800FFFF
    }

    public static ctl_api_handle_t ApiHandle { get; private set; }

    // Public interface
    public static bool IsAvailable { get; private set; }

    public static bool IsInitialized { get; private set; }

    // P/Invoke declarations
    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    private static extern int ctlInit(ref ctl_init_args_t pInitDesc, ref ctl_api_handle_t phAPIHandle);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    private static extern int ctlEnumerateDevices(ctl_api_handle_t hAPIHandle, ref uint pCount, [Out] ctl_device_adapter_handle_t[] phDevices);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern int ctlGetDeviceProperties(ctl_device_adapter_handle_t hDAhandle, ref ctl_device_adapter_properties_t pProperties);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern int ctlPowerTelemetryGet(ctl_device_adapter_handle_t hDeviceHandle, ref ctl_power_telemetry_t pTelemetryInfo);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern int ctlEnumFans(ctl_device_adapter_handle_t hDAhandle, ref uint pCount, [Out] ctl_fan_handle_t[] phFan);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern int ctlFanGetState(ctl_fan_handle_t hFan, ctl_fan_speed_units_t units, ref int pSpeed);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern int ctlFanGetProperties(ctl_fan_handle_t hFan, ref ctl_fan_properties_t pProperties);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern int ctlEnumFrequencyDomains(ctl_device_adapter_handle_t hDAhandle, ref uint pCount, [Out] ctl_freq_handle_t[] phFrequency);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern int ctlFrequencyGetProperties(ctl_freq_handle_t hFrequency, ref ctl_freq_properties_t pProperties);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern int ctlFrequencyGetState(ctl_freq_handle_t hFrequency, ref ctl_freq_state_t pState);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    private static extern int ctlClose(ctl_api_handle_t hAPIHandle);

    private static bool GclMethodExists(string gclMethod)
    {
        using FreeLibrarySafeHandle module = PInvoke.LoadLibrary(DllName);
        if (!module.IsInvalid)
        {
            bool result = PInvoke.GetProcAddress(module, gclMethod) != IntPtr.Zero;
            return result;
        }

        return false;
    }

    public static bool Initialize()
    {
        if (!IsAvailable)
            return false;

        if (IsInitialized)
            return true;

        var initArgs = new ctl_init_args_t();
        initArgs.Size = (uint)Marshal.SizeOf(typeof(ctl_init_args_t));
        initArgs.Version = 0;
        initArgs.AppVersion = CTL_IMPL_VERSION;
        initArgs.flags = (uint)ctl_init_flag_t.CTL_INIT_FLAG_USE_LEVEL_ZERO;

        var apiHandle = new ctl_api_handle_t();
        int result = ctlInit(ref initArgs, ref apiHandle);

        if (result != (int)ctl_result_t.CTL_RESULT_SUCCESS)
            return false;

        ApiHandle = apiHandle;
        IsInitialized = true;
        return true;
    }

    public static ctl_device_adapter_handle_t[] GetDeviceHandles()
    {
        if (!IsInitialized && (!Initialize()))
            return Array.Empty<ctl_device_adapter_handle_t>();

        // First call to get the device count
        uint count = 0;
        int result = ctlEnumerateDevices(ApiHandle, ref count, null);
        count = Math.Min(count, MAX_DEVICES);

        if (result != (int)ctl_result_t.CTL_RESULT_SUCCESS || count == 0)
            return Array.Empty<ctl_device_adapter_handle_t>();

        // Second call to get the actual device handles
        var handles = new ctl_device_adapter_handle_t[count];
        result = ctlEnumerateDevices(ApiHandle, ref count, handles);

        if (result != (int)ctl_result_t.CTL_RESULT_SUCCESS)
            return Array.Empty<ctl_device_adapter_handle_t>();

        return handles;
    }

    public static void Cleanup()
    {
        if (IsInitialized)
        {
            try
            {
                ctlClose(ApiHandle);
            }
            catch
            {
                // Ignore cleanup errors
            }
            finally
            {
                IsInitialized = false;
                ApiHandle = new ctl_api_handle_t();
            }
        }
    }

    // Unions
    [StructLayout(LayoutKind.Explicit)]
    public struct ctl_data_value_t
    {
        [FieldOffset(0)]
        public sbyte data8;

        [FieldOffset(0)]
        public byte datau8;

        [FieldOffset(0)]
        public short data16;

        [FieldOffset(0)]
        public ushort datau16;

        [FieldOffset(0)]
        public int data32;

        [FieldOffset(0)]
        public uint datau32;

        [FieldOffset(0)]
        public long data64;

        [FieldOffset(0)]
        public ulong datau64;

        [FieldOffset(0)]
        public float datafloat;

        [FieldOffset(0)]
        public double datadouble;
    }

    // Structures
    [StructLayout(LayoutKind.Sequential)]
    public struct ctl_api_handle_t
    {
        private IntPtr pNext;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct ctl_application_id_t
    {
        public uint Data1;
        public ushort Data2;
        public ushort Data3;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
        public byte[] Data4;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct ctl_init_args_t
    {
        public uint Size;
        public byte Version;
        public uint AppVersion;
        public uint flags;
        public uint SupportedVersion;
        public ctl_application_id_t ApplicationUID;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct ctl_device_adapter_handle_t
    {
        private IntPtr pNext;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct ctl_fan_handle_t
    {
        private IntPtr pNext;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct ctl_fan_speed_t
    {
        public uint Size;
        public byte Version;
        public int speed;
        public ctl_fan_speed_units_t units;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct ctl_fan_properties_t
    {
        public uint Size;
        public byte Version;
        public bool canControl;
        public uint supportedModes;
        public uint supportedUnits;
        public int maxRPM;
        public int maxPoints;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct ctl_freq_handle_t
    {
        private IntPtr pNext;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct ctl_freq_properties_t
    {
        public uint Size;
        public byte Version;
        public ctl_freq_domain_t type;
        public bool canControl;
        public double min;
        public double max;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct ctl_freq_state_t
    {
        public uint Size;
        public byte Version;
        public double currentVoltage;
        public double request;
        public double tdp;
        public double efficient;
        public double actual;
        public uint throttleReasons;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct ctl_device_adapter_properties_t
    {
        public uint Size;
        public byte Version;
        public IntPtr pDeviceID;
        public uint device_id_size;
        public ctl_device_type_t device_type;
        public uint supported_subfunction_flags;
        public ulong driver_version;
        public ctl_firmware_version_t firmware_version;
        public uint pci_vendor_id;
        public uint pci_device_id;
        public uint rev_id;
        public uint num_eus_per_sub_slice;
        public uint num_sub_slices_per_slice;
        public uint num_slices;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = CTL_MAX_DEVICE_NAME_LEN)]
        public string name;

        public uint graphics_adapter_properties;
        public uint Frequency;
        public ushort pci_subsys_id;
        public ushort pci_subsys_vendor_id;
        public ctl_adapter_bdf_t adapter_bdf;
        public uint num_xe_cores;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = CTL_MAX_RESERVED_SIZE)]
        public byte[] reserved;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct ctl_adapter_bdf_t
    {
        public byte bus;
        public byte device;
        public byte function;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct ctl_firmware_version_t
    {
        public ulong major_version;
        public ulong minor_version;
        public ulong build_number;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct ctl_oc_telemetry_item_t
    {
        public bool bSupported;
        public ctl_units_t units;
        public ctl_data_type_t type;
        public ctl_data_value_t value;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct ctl_psu_info_t
    {
        public bool bSupported;
        public ctl_psu_type_t psuType;
        public ctl_oc_telemetry_item_t energyCounter;
        public ctl_oc_telemetry_item_t voltage;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct ctl_power_telemetry_t
    {
        public uint Size;
        public byte Version;
        public ctl_oc_telemetry_item_t timeStamp;
        public ctl_oc_telemetry_item_t gpuEnergyCounter;
        public ctl_oc_telemetry_item_t gpuVoltage;
        public ctl_oc_telemetry_item_t gpuCurrentClockFrequency;
        public ctl_oc_telemetry_item_t gpuCurrentTemperature;
        public ctl_oc_telemetry_item_t globalActivityCounter;
        public ctl_oc_telemetry_item_t renderComputeActivityCounter;
        public ctl_oc_telemetry_item_t mediaActivityCounter;
        public bool gpuPowerLimited;
        public bool gpuTemperatureLimited;
        public bool gpuCurrentLimited;
        public bool gpuVoltageLimited;
        public bool gpuUtilizationLimited;
        public ctl_oc_telemetry_item_t vramEnergyCounter;
        public ctl_oc_telemetry_item_t vramVoltage;
        public ctl_oc_telemetry_item_t vramCurrentClockFrequency;
        public ctl_oc_telemetry_item_t vramCurrentEffectiveFrequency;
        public ctl_oc_telemetry_item_t vramReadBandwidthCounter;
        public ctl_oc_telemetry_item_t vramWriteBandwidthCounter;
        public ctl_oc_telemetry_item_t vramCurrentTemperature;
        public bool vramPowerLimited;
        public bool vramTemperatureLimited;
        public bool vramCurrentLimited;
        public bool vramVoltageLimited;
        public bool vramUtilizationLimited;
        public ctl_oc_telemetry_item_t totalCardEnergyCounter;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = CTL_PSU_COUNT)]
        public ctl_psu_info_t[] psu;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = CTL_FAN_COUNT)]
        public ctl_oc_telemetry_item_t[] fanSpeed;

        public ctl_oc_telemetry_item_t gpuVrTemp;
        public ctl_oc_telemetry_item_t vramVrTemp;
        public ctl_oc_telemetry_item_t saVrTemp;
        public ctl_oc_telemetry_item_t gpuEffectiveClock;
        public ctl_oc_telemetry_item_t gpuOverVoltagePercent;
        public ctl_oc_telemetry_item_t gpuPowerPercent;
        public ctl_oc_telemetry_item_t gpuTemperaturePercent;
        public ctl_oc_telemetry_item_t vramReadBandwidth;
        public ctl_oc_telemetry_item_t vramWriteBandwidth;
    }
}

```

`LibreHardwareMonitorLib/Interop/Ipmi.cs`:

```cs
using System.Runtime.InteropServices;

namespace LibreHardwareMonitor.Interop;

internal static class Ipmi
{
    // Ported from ipmiutil
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 1)]
    internal struct Sdr
    {
        public ushort recid;

        public byte sdrver;

        public byte rectype;

        public byte reclen;

        public byte sens_ownid;

        public byte sens_ownlun;

        public byte sens_num;

        public byte entity_id;

        public byte entity_inst;

        public byte sens_init;

        public byte sens_capab;

        public byte sens_type;

        public byte ev_type;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 6)]
        public string data1;

        public byte sens_units;

        public byte sens_base;

        public byte sens_mod;

        public byte linear;

        public byte m;

        public byte m_t;

        public byte b;

        public byte b_a;

        public byte a_ax;

        public byte rx_bx;

        public byte flags;

        public byte nom_reading;

        public byte norm_max;

        public byte norm_min;

        public byte sens_max_reading;

        public byte sens_min_reading;

        public byte unr_threshold;

        public byte ucr_threshold;

        public byte unc_threshold;

        public byte lnr_threshold;

        public byte lcr_threshold;

        public byte lnc_threshold;

        public byte pos_hysteresis;

        public byte neg_hysteresis;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 3)]
        public string data3;

        public byte id_strlen;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 16)]
        public string id_string;
    }
}

```

`LibreHardwareMonitorLib/Interop/LibC.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.Runtime.InteropServices;

// ReSharper disable InconsistentNaming

namespace LibreHardwareMonitor.Interop;

internal class LibC
{
    private const string DllName = "libc";

    [DllImport(DllName)]
    internal static extern int sched_getaffinity(int pid, IntPtr maskSize, ref ulong mask);

    [DllImport(DllName)]
    internal static extern int sched_setaffinity(int pid, IntPtr maskSize, ref ulong mask);
}
```

`LibreHardwareMonitorLib/Interop/NvApi.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using System.Text;
using Windows.Win32;

namespace LibreHardwareMonitor.Interop;

internal static class NvApi
{
    public const int MAX_CLOCKS_PER_GPU = 0x120;
    public const int MAX_COOLERS_PER_GPU = 20;
    public const int MAX_FAN_CONTROLLER_ITEMS = 32;
    public const int MAX_FAN_COOLERS_STATUS_ITEMS = 32;
    public const int MAX_GPU_PUBLIC_CLOCKS = 32;
    public const int MAX_GPU_UTILIZATIONS = 8;
    public const int MAX_MEMORY_VALUES_PER_GPU = 5;
    public const int MAX_PHYSICAL_GPUS = 64;
    public const int MAX_POWER_TOPOLOGIES = 4;
    public const int MAX_THERMAL_SENSORS_PER_GPU = 3;
    public const int MAX_USAGES_PER_GPU = 8;

    public const int SHORT_STRING_MAX = 64;
    public const int THERMAL_SENSOR_RESERVED_COUNT = 8;
    public const int THERMAL_SENSOR_TEMPERATURE_COUNT = 32;

    public const uint NVAPI_I2C_SPEED_DEPRECATED = 0xFFFF;

    private const string DllName = "nvapi.dll";
    private const string DllName64 = "nvapi64.dll";

    public static NvAPI_EnumNvidiaDisplayHandleDelegate NvAPI_EnumNvidiaDisplayHandle { get; internal set; }
    public static NvAPI_EnumPhysicalGPUsDelegate NvAPI_EnumPhysicalGPUs { get; internal set; }
    public static NvAPI_GetDisplayDriverVersionDelegate NvAPI_GetDisplayDriverVersion { get; internal set; }
    public static NvAPI_GetPhysicalGPUsFromDisplayDelegate NvAPI_GetPhysicalGPUsFromDisplay { get; internal set; }
    public static NvAPI_GPU_ClientFanCoolersGetControlDelegate NvAPI_GPU_ClientFanCoolersGetControl { get; internal set; }
    public static NvAPI_GPU_ClientFanCoolersGetStatusDelegate NvAPI_GPU_ClientFanCoolersGetStatus { get; internal set; }
    public static NvAPI_GPU_ClientFanCoolersSetControlDelegate NvAPI_GPU_ClientFanCoolersSetControl { get; internal set; }
    public static NvAPI_GPU_ClientPowerTopologyGetStatusDelegate NvAPI_GPU_ClientPowerTopologyGetStatus { get; internal set; }
    public static NvAPI_GPU_GetAllClockFrequenciesDelegate NvAPI_GPU_GetAllClockFrequencies { get; internal set; }
    public static NvAPI_GPU_GetAllClocksDelegate NvAPI_GPU_GetAllClocks { get; internal set; }
    public static NvAPI_GPU_GetBusIdDelegate NvAPI_GPU_GetBusId { get; internal set; }
    public static NvAPI_GPU_GetCoolerSettingsDelegate NvAPI_GPU_GetCoolerSettings { get; internal set; }
    public static NvAPI_GPU_GetDynamicPstatesInfoExDelegate NvAPI_GPU_GetDynamicPstatesInfoEx { get; internal set; }
    public static NvAPI_GPU_GetMemoryInfoDelegate NvAPI_GPU_GetMemoryInfo { get; internal set; }
    public static NvAPI_GPU_GetMemoryInfoExDelegate NvAPI_GPU_GetMemoryInfoEx { get; internal set; }
    public static NvAPI_GPU_GetPCIIdentifiersDelegate NvAPI_GPU_GetPCIIdentifiers { get; internal set; }
    public static NvAPI_GPU_GetTachReadingDelegate NvAPI_GPU_GetTachReading { get; internal set; }
    public static NvAPI_GPU_GetThermalSettingsDelegate NvAPI_GPU_GetThermalSettings { get; internal set; }
    public static NvAPI_GPU_GetUsagesDelegate NvAPI_GPU_GetUsages { get; internal set; }
    public static NvAPI_GPU_SetCoolerLevelsDelegate NvAPI_GPU_SetCoolerLevels { get; internal set; }
    public static NvAPI_GPU_GetThermalSensorsDelegate NvAPI_GPU_GetThermalSensors { get; internal set; }
    public static NvAPI_I2CReadExDelegate NvAPI_I2CReadEx { get; internal set; }
    public static NvAPI_GPU_ClientVoltRailsGetStatusDelegate NvAPI_GPU_ClientVoltRailsGetStatus { get; internal set; }

    private static NvAPI_GetInterfaceVersionStringDelegate _nvAPI_GetInterfaceVersionString;
    private static NvAPI_GPU_GetFullNameDelegate _nvAPI_GPU_GetFullName;

    public static void Initialize()
    {
        NvAPI_InitializeDelegate nvApiInitialize;

        try
        {
            if (!DllExists())
                return;

            nvApiInitialize = GetDelegate<NvAPI_InitializeDelegate>(0x0150E828);
        }
        catch (Exception e) when (e is DllNotFoundException or ArgumentNullException or EntryPointNotFoundException or BadImageFormatException)
        {
            return;
        }

        if (nvApiInitialize() == NvStatus.OK)
        {
            NvAPI_GPU_GetThermalSettings = GetDelegate<NvAPI_GPU_GetThermalSettingsDelegate>(0xE3640A56);
            _nvAPI_GPU_GetFullName = GetDelegate<NvAPI_GPU_GetFullNameDelegate>(0xCEEE8E9F);
            NvAPI_EnumNvidiaDisplayHandle = GetDelegate<NvAPI_EnumNvidiaDisplayHandleDelegate>(0x9ABDD40D);
            NvAPI_GetPhysicalGPUsFromDisplay = GetDelegate<NvAPI_GetPhysicalGPUsFromDisplayDelegate>(0x34EF9506);
            NvAPI_EnumPhysicalGPUs = GetDelegate<NvAPI_EnumPhysicalGPUsDelegate>(0xE5AC921F);
            NvAPI_GPU_GetTachReading = GetDelegate<NvAPI_GPU_GetTachReadingDelegate>(0x5F608315);
            NvAPI_GPU_GetAllClocks = GetDelegate<NvAPI_GPU_GetAllClocksDelegate>(0x1BD69F49);
            NvAPI_GPU_GetDynamicPstatesInfoEx = GetDelegate<NvAPI_GPU_GetDynamicPstatesInfoExDelegate>(0x60DED2ED);
            NvAPI_GPU_GetUsages = GetDelegate<NvAPI_GPU_GetUsagesDelegate>(0x189A1FDF);
            NvAPI_GPU_GetCoolerSettings = GetDelegate<NvAPI_GPU_GetCoolerSettingsDelegate>(0xDA141340);
            NvAPI_GPU_SetCoolerLevels = GetDelegate<NvAPI_GPU_SetCoolerLevelsDelegate>(0x891FA0AE);
            NvAPI_GPU_GetMemoryInfo = GetDelegate<NvAPI_GPU_GetMemoryInfoDelegate>(0x774AA982);
            NvAPI_GPU_GetMemoryInfoEx = GetDelegate<NvAPI_GPU_GetMemoryInfoExDelegate>(0xC0599498);
            NvAPI_GetDisplayDriverVersion = GetDelegate<NvAPI_GetDisplayDriverVersionDelegate>(0xF951A4D1);
            _nvAPI_GetInterfaceVersionString = GetDelegate<NvAPI_GetInterfaceVersionStringDelegate>(0x01053FA5);
            NvAPI_GPU_GetPCIIdentifiers = GetDelegate<NvAPI_GPU_GetPCIIdentifiersDelegate>(0x2DDFB66E);
            NvAPI_GPU_GetBusId = GetDelegate<NvAPI_GPU_GetBusIdDelegate>(0x1BE0B8E5);
            NvAPI_GPU_ClientFanCoolersGetStatus = GetDelegate<NvAPI_GPU_ClientFanCoolersGetStatusDelegate>(0x35AED5E8);
            NvAPI_GPU_GetAllClockFrequencies = GetDelegate<NvAPI_GPU_GetAllClockFrequenciesDelegate>(0xDCB616C3);
            NvAPI_GPU_ClientFanCoolersGetControl = GetDelegate<NvAPI_GPU_ClientFanCoolersGetControlDelegate>(0x814B209F);
            NvAPI_GPU_ClientFanCoolersSetControl = GetDelegate<NvAPI_GPU_ClientFanCoolersSetControlDelegate>(0xA58971A5);
            NvAPI_GPU_ClientPowerTopologyGetStatus = GetDelegate<NvAPI_GPU_ClientPowerTopologyGetStatusDelegate>(0x0EDCF624E);
            NvAPI_GPU_GetThermalSensors = GetDelegate<NvAPI_GPU_GetThermalSensorsDelegate>(0x65FE3AAD);
            NvAPI_I2CReadEx = GetDelegate<NvAPI_I2CReadExDelegate>(0x4D7B0709);
            NvAPI_GPU_ClientVoltRailsGetStatus = GetDelegate<NvAPI_GPU_ClientVoltRailsGetStatusDelegate>(0x465F9BCF);

            IsAvailable = true;
        }
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_EnumNvidiaDisplayHandleDelegate(int thisEnum, ref NvDisplayHandle displayHandle);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_EnumPhysicalGPUsDelegate([Out] NvPhysicalGpuHandle[] gpuHandles, out int gpuCount);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GetDisplayDriverVersionDelegate(NvDisplayHandle displayHandle, [In, Out] ref NvDisplayDriverVersion nvDisplayDriverVersion);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GetInterfaceVersionStringDelegate(StringBuilder version);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GetPhysicalGPUsFromDisplayDelegate(NvDisplayHandle displayHandle, [Out] NvPhysicalGpuHandle[] gpuHandles, out uint gpuCount);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GPU_ClientFanCoolersGetControlDelegate(NvPhysicalGpuHandle gpuHandle, ref NvFanCoolerControl control);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GPU_ClientFanCoolersGetStatusDelegate(NvPhysicalGpuHandle gpuHandle, ref NvFanCoolersStatus fanCoolersStatus);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GPU_ClientFanCoolersSetControlDelegate(NvPhysicalGpuHandle gpuHandle, ref NvFanCoolerControl control);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GPU_ClientPowerTopologyGetStatusDelegate(NvPhysicalGpuHandle gpuHandle, ref NvPowerTopology powerTopology);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GPU_GetAllClockFrequenciesDelegate(NvPhysicalGpuHandle gpuHandle, ref NvGpuClockFrequencies clockFrequencies);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GPU_GetAllClocksDelegate(NvPhysicalGpuHandle gpuHandle, ref NvClocks nvClocks);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GPU_GetBusIdDelegate(NvPhysicalGpuHandle gpuHandle, out uint busId);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GPU_GetCoolerSettingsDelegate(NvPhysicalGpuHandle gpuHandle, NvCoolerTarget coolerTarget, ref NvCoolerSettings NvCoolerSettings);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GPU_GetDynamicPstatesInfoExDelegate(NvPhysicalGpuHandle gpuHandle, ref NvDynamicPStatesInfo nvPStates);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GPU_GetMemoryInfoDelegate(NvDisplayHandle displayHandle, ref NvMemoryInfo nvMemoryInfo);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GPU_GetMemoryInfoExDelegate(NvPhysicalGpuHandle gpuHandle, ref NvMemoryInfoEx nvMemoryInfo);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GPU_GetPCIIdentifiersDelegate(NvPhysicalGpuHandle gpuHandle, out uint deviceId, out uint subSystemId, out uint revisionId, out uint extDeviceId);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GPU_GetTachReadingDelegate(NvPhysicalGpuHandle gpuHandle, out int value);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GPU_GetThermalSensorsDelegate(NvPhysicalGpuHandle gpuHandle, ref NvThermalSensors nvThermalSensors);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GPU_GetThermalSettingsDelegate(NvPhysicalGpuHandle gpuHandle, int sensorIndex, ref NvThermalSettings NvThermalSettings);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GPU_GetUsagesDelegate(NvPhysicalGpuHandle gpuHandle, ref NvUsages nvUsages);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GPU_SetCoolerLevelsDelegate(NvPhysicalGpuHandle gpuHandle, int coolerIndex, ref NvCoolerLevels NvCoolerLevels);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_I2CReadExDelegate(NvPhysicalGpuHandle gpuHandle, ref NvI2CInfo i2cInfo, ref uint readData);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate NvStatus NvAPI_GPU_ClientVoltRailsGetStatusDelegate(NvPhysicalGpuHandle gpuHandle, ref NvGpuClientVoltRailsStatus status);

    public enum NvFanControlMode : uint
    {
        Auto = 0,
        Manual = 1
    }

    public enum NvLevelPolicy : uint
    {
        None = 0,
        Manual = 1,
        Performance = 2,
        TemperatureDiscrete = 4,
        TemperatureContinuous = 8,
        Silent = 16,
        Auto = 32
    }

    public enum NvPowerTopologyDomain : uint
    {
        Gpu = 0,
        Board
    }

    public enum NvUtilizationDomain
    {
        Gpu, // Core
        FrameBuffer, // Memory Controller
        VideoEngine, // Video Engine
        BusInterface // Bus
    }

    public enum NvI2CSpeed : uint
    {
        Default = 0,
        Speed3Khz = 1,
        Speed10Khz = 2,
        Speed33Khz = 3,
        Speed100Khz = 4,
        Speed200Khz = 5,
        Speed400Khz = 6
    }

    public static bool IsAvailable { get; private set; }

    [DllImport(DllName, EntryPoint = "nvapi_QueryInterface", CallingConvention = CallingConvention.Cdecl, PreserveSig = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    private static extern IntPtr NvAPI32_QueryInterface(uint interfaceId);

    [DllImport(DllName64, EntryPoint = "nvapi_QueryInterface", CallingConvention = CallingConvention.Cdecl, PreserveSig = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    private static extern IntPtr NvAPI64_QueryInterface(uint interfaceId);

    public static NvStatus NvAPI_GPU_GetFullName(NvPhysicalGpuHandle gpuHandle, out string name)
    {
        StringBuilder builder = new(SHORT_STRING_MAX);
        NvStatus status = _nvAPI_GPU_GetFullName?.Invoke(gpuHandle, builder) ?? NvStatus.FunctionNotFound;

        name = builder.ToString();
        return status;
    }

    public static NvStatus NvAPI_GetInterfaceVersionString(out string version)
    {
        StringBuilder builder = new(SHORT_STRING_MAX);
        NvStatus status = _nvAPI_GetInterfaceVersionString?.Invoke(builder) ?? NvStatus.FunctionNotFound;

        version = builder.ToString();
        return status;
    }

    private static T GetDelegate<T>(uint id) where T : class
    {
        IntPtr ptr = Environment.Is64BitProcess ? NvAPI64_QueryInterface(id) : NvAPI32_QueryInterface(id);

        if (ptr != IntPtr.Zero)
        {
            return Marshal.GetDelegateForFunctionPointer(ptr, typeof(T)) as T;
        }
        else
        {
            return null;
        }
    }

    public static bool DllExists()
    {
        FreeLibrarySafeHandle module = PInvoke.LoadLibrary(Environment.Is64BitProcess ? DllName64 : DllName);
        if (module.IsInvalid)
            return false;

        module.Dispose();
        return true;
    }

    internal static int MAKE_NVAPI_VERSION<T>(int ver)
    {
        return Marshal.SizeOf<T>() | (ver << 16);
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvFanCoolerControl
    {
        public uint Version;
        private readonly uint _reserved;
        public uint Count;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.U4)]
        private readonly uint[] _reserved2;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_FAN_CONTROLLER_ITEMS)]
        public NvFanCoolerControlItem[] Items;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvFanCoolerControlItem
    {
        public uint CoolerId;
        public uint Level;
        public NvFanControlMode ControlMode;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.U4)]
        private readonly uint[] _reserved;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvPowerTopology
    {
        public int Version;
        public uint Count;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_POWER_TOPOLOGIES, ArraySubType = UnmanagedType.Struct)]
        public NvPowerTopologyEntry[] Entries;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvPowerTopologyEntry
    {
        public NvPowerTopologyDomain Domain;
        private readonly uint _reserved;
        public uint PowerUsage;
        private readonly uint _reserved1;
    }

    internal enum NvStatus
    {
        OK = 0,
        Error = -1,
        LibraryNotFound = -2,
        NoImplementation = -3,
        ApiNotInitialized = -4,
        InvalidArgument = -5,
        NvidiaDeviceNotFound = -6,
        EndEnumeration = -7,
        InvalidHandle = -8,
        IncompatibleStructVersion = -9,
        HandleInvalidated = -10,
        OpenGlContextNotCurrent = -11,
        NoGlExpert = -12,
        InstrumentationDisabled = -13,
        ExpectedLogicalGpuHandle = -100,
        ExpectedPhysicalGpuHandle = -101,
        ExpectedDisplayHandle = -102,
        InvalidCombination = -103,
        NotSupported = -104,
        PortIdNotFound = -105,
        ExpectedUnattachedDisplayHandle = -106,
        InvalidPerfLevel = -107,
        DeviceBusy = -108,
        NvPersistFileNotFound = -109,
        PersistDataNotFound = -110,
        ExpectedTvDisplay = -111,
        ExpectedTvDisplayOnConnector = -112,
        NoActiveSliTopology = -113,
        SliRenderingModeNotAllowed = -114,
        ExpectedDigitalFlatPanel = -115,
        ArgumentExceedMaxSize = -116,
        DeviceSwitchingNotAllowed = -117,
        TestingClocksNotSupported = -118,
        UnknownUnderscanConfig = -119,
        TimeoutReconfiguringGpuTopo = -120,
        DataNotFound = -121,
        ExpectedAnalogDisplay = -122,
        NoVidLink = -123,
        RequiresReboot = -124,
        InvalidHybridMode = -125,
        MixedTargetTypes = -126,
        Syswow64NotSupported = -127,
        ImplicitSetGpuTopologyChangeNotAllowed = -128,
        RequestUserToCloseNonMigratableApps = -129,
        OutOfMemory = -130,
        WasStillDrawing = -131,
        FileNotFound = -132,
        TooManyUniqueStateObjects = -133,
        InvalidCall = -134,
        D3D101LibraryNotFound = -135,
        FunctionNotFound = -136
    }

    internal enum NvThermalController
    {
        None = 0,
        GpuInternal,
        Adm1032,
        Max6649,
        Max1617,
        Lm99,
        Lm89,
        Lm64,
        Adt7473,
        SbMax6649,
        VBiosEvt,
        OS,
        Unknown = -1
    }

    internal enum NvThermalTarget
    {
        None = 0,
        Gpu = 1,
        Memory = 2,
        PowerSupply = 4,
        Board = 8,
        VisualComputingBoard = 9,
        VisualComputingInlet = 10,
        VisualComputingOutlet = 11,
        All = 15,
        Unknown = -1
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvSensor
    {
        public NvThermalController Controller;
        public uint DefaultMinTemp;
        public uint DefaultMaxTemp;
        public uint CurrentTemp;
        public NvThermalTarget Target;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvThermalSettings
    {
        public uint Version;
        public uint Count;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_THERMAL_SENSORS_PER_GPU)]
        public NvSensor[] Sensor;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct NvDisplayHandle
    {
        private readonly IntPtr ptr;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct NvPhysicalGpuHandle
    {
        private readonly IntPtr ptr;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvClocks
    {
        public uint Version;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_CLOCKS_PER_GPU)]
        public uint[] Clock;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvDynamicPStatesInfo
    {
        public uint Version;
        public uint Flags;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_GPU_UTILIZATIONS)]
        public NvDynamicPState[] Utilizations;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvDynamicPState
    {
        public bool IsPresent;
        public int Percentage;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvUsages
    {
        public uint Version;
        private readonly uint _reserved;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
        public NvUsagesEntry[] Entries;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvUsagesEntry
    {
        public uint IsPresent;
        public uint Percentage;
        private readonly uint _reserved1;
        private readonly uint _reserved2;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvCooler
    {
        public int Type;
        public int Controller;
        public int DefaultMin;
        public int DefaultMax;
        public int CurrentMin;
        public int CurrentMax;
        public int CurrentLevel;
        public int DefaultPolicy;
        public int CurrentPolicy;
        public int Target;
        public int ControlType;
        public int Active;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvFanCoolersStatus
    {
        public uint Version;
        public uint Count;

        public ulong Reserved1;
        public ulong Reserved2;
        public ulong Reserved3;
        public ulong Reserved4;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_FAN_COOLERS_STATUS_ITEMS)]
        internal NvFanCoolersStatusItem[] Items;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvFanCoolersStatusItem
    {
        public uint CoolerId;
        public uint CurrentRpm;
        public uint CurrentMinLevel;
        public uint CurrentMaxLevel;
        public uint CurrentLevel;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.U4)]
        private readonly uint[] _reserved;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvCoolerSettings
    {
        public uint Version;
        public uint Count;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_COOLERS_PER_GPU)]
        public NvCooler[] Cooler;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvLevel
    {
        public int Level;
        public NvLevelPolicy Policy;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvCoolerLevels
    {
        public uint Version;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_COOLERS_PER_GPU)]
        public NvLevel[] Levels;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    public struct NvThermalSensors
    {
        internal uint Version;
        internal uint Mask;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = THERMAL_SENSOR_RESERVED_COUNT)]
        internal int[] Reserved;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = THERMAL_SENSOR_TEMPERATURE_COUNT)]
        internal int[] Temperatures;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvMemoryInfo
    {
        public uint Version;

        public uint DedicatedVideoMemory;

        public uint AvailableDedicatedVideoMemory;

        public uint SystemVideoMemory;

        public uint SharedSystemMemory;

        public uint CurrentAvailableDedicatedVideoMemory;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct NvMemoryInfoEx
    {
        public uint Version;
        public ulong DedicatedVideoMemory;
        public ulong AvailableDedicatedVideoMemory;
        public ulong SystemVideoMemory;
        public ulong SharedSystemMemory;

        public ulong CurrentAvailableDedicatedVideoMemory;

        public ulong DedicatedVideoMemoryEvictionsSize;
        public ulong DedicatedVideoMemoryEvictionCount;

        public ulong DedicatedVideoMemoryPromotionsSize;
        public ulong DedicatedVideoMemoryPromotionCount;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvDisplayDriverVersion
    {
        public uint Version;
        public uint DriverVersion;
        public uint BldChangeListNum;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = SHORT_STRING_MAX)]
        public string BuildBranch;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = SHORT_STRING_MAX)]
        public string Adapter;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvGpuClockFrequencies
    {
        public uint Version;
        private readonly uint _reserved;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_GPU_PUBLIC_CLOCKS)]
        public NvGpuClockFrequenciesDomain[] Clocks;
    }

    [StructLayout(LayoutKind.Explicit, Size = 0x4C)]
    internal unsafe struct NvGpuClientVoltRailsStatus
    {
        [FieldOffset(0x00)] public uint Version;

        [FieldOffset(0x04)] public fixed uint _reserved[17]; //Unknown

        [FieldOffset(0x28)] public uint CoreMicrovolts;
        [FieldOffset(0x2C)] public uint CoreMicrovoltsHigh;
    }

    internal enum NvGpuPublicClockId
    {
        Graphics = 0,
        Memory = 4,
        Processor = 7,
        Video = 8,
        Undefined = MAX_CLOCKS_PER_GPU
    }

    internal enum NvGpuClockFrequenciesClockType
    {
        CurrentFrequency,
        BaseClock,
        BoostClock,
        ClockTypeNumber
    }

    internal enum NvCoolerTarget
    {
        None = 0,
        Gpu,
        Memory,
        PowerSupply = 4,
        All = 7 // This cooler cools all of the components related to its target gpu.
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvGpuClockFrequenciesDomain
    {
        private readonly uint _isPresent;
        public uint Frequency;

        public bool IsPresent => (_isPresent & 1) != 0;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    internal struct NvI2CInfo
    {
        public uint Version;
        public uint DisplayMask;
        public byte IsDDCPort;
        public byte I2CDevAddress;
        public IntPtr I2CRegAddress;
        public uint RegAddrSize;
        public IntPtr Data;
        public uint Size;
        public uint I2CSpeed;
        public NvI2CSpeed I2CSpeedKhz;
        public byte PortId;
        public uint IsPortIdSet;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate NvStatus NvAPI_InitializeDelegate();

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate NvStatus NvAPI_GPU_GetFullNameDelegate(NvPhysicalGpuHandle gpuHandle, StringBuilder name);
}

```

`LibreHardwareMonitorLib/Interop/NvidiaML.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// All Rights Reserved.

using System;
using System.IO;
using System.Runtime.InteropServices;
using Windows.Win32;

namespace LibreHardwareMonitor.Interop;

internal static class NvidiaML
{
    private const string LinuxDllName = "nvidia-ml";
    private const string WindowsDllName = "nvml.dll";

    private static readonly object _syncRoot = new();

    private static FreeLibrarySafeHandle _windowsDll;

    private static WindowsNvmlGetHandleDelegate _windowsNvmlDeviceGetHandleByIndex;
    private static WindowsNvmlGetHandleByPciBusIdDelegate _windowsNvmlDeviceGetHandleByPciBusId;
    private static WindowsNvmlDeviceGetPcieThroughputDelegate _windowsNvmlDeviceGetPcieThroughputDelegate;
    private static WindowsNvmlDeviceGetPciInfo _windowsNvmlDeviceGetPciInfo;
    private static WindowsNvmlGetPowerUsageDelegate _windowsNvmlDeviceGetPowerUsage;
    private static WindowsNvmlDelegate _windowsNvmlInit;
    private static WindowsNvmlDelegate _windowsNvmlShutdown;

    public enum NvmlPcieUtilCounter
    {
        TxBytes = 0,
        RxBytes = 1
    }

    public enum NvmlReturn
    {
        /// <summary>
        /// The operation was successful
        /// </summary>
        Success = 0,

        /// <summary>
        /// NvidiaML was not first initialized with nvmlInit()
        /// </summary>
        Uninitialized = 1,

        /// <summary>
        /// A supplied argument is invalid
        /// </summary>
        InvalidArgument = 2,

        /// <summary>
        /// The requested operation is not available on target device
        /// </summary>
        NotSupported = 3,

        /// <summary>
        /// The current user does not have permission for operation
        /// </summary>
        NoPermission = 4,

        /// <summary>
        /// A query to find an object was unsuccessful
        /// </summary>
        NotFound = 6,

        /// <summary>
        /// An input argument is not large enough
        /// </summary>
        InsufficientSize = 7,

        /// <summary>
        /// A device's external power cables are not properly attached
        /// </summary>
        InsufficientPower = 8,

        /// <summary>
        /// NVIDIA driver is not loaded
        /// </summary>
        DriverNotLoaded = 9,

        /// <summary>
        /// User provided timeout passed
        /// </summary>
        TimeOut = 10,

        /// <summary>
        /// NVIDIA Kernel detected an interrupt issue with a GPU
        /// </summary>
        IRQIssue = 11,

        /// <summary>
        /// NvidiaML Shared Library couldn't be found or loaded
        /// </summary>
        LibraryNotFound = 12,

        /// <summary>
        /// Local version of NvidiaML doesn't implement this function
        /// </summary>
        FunctionNotFound = 13,

        /// <summary>
        /// infoROM is corrupted
        /// </summary>
        CorruptedInfoRom = 14,

        /// <summary>
        /// The GPU has fallen off the bus or has otherwise become inaccessible
        /// </summary>
        GpuIsLost = 15,

        /// <summary>
        /// The GPU requires a reset before it can be used again
        /// </summary>
        ResetRequired = 16,

        /// <summary>
        /// The GPU control device has been blocked by the operating system/cgroups
        /// </summary>
        OperatingSystem = 17,

        /// <summary>
        /// RM detects a driver/library version mismatch
        /// </summary>
        LibRmVersionMismatch = 18,

        /// <summary>
        /// An operation cannot be performed because the GPU is currently in use
        /// </summary>
        InUse = 19,

        /// <summary>
        /// An public driver error occurred
        /// </summary>
        Unknown = 999
    }

    public static bool IsAvailable { get; private set; }

    public static bool Initialize()
    {
        lock (_syncRoot)
        {
            if (IsAvailable)
            {
                return true;
            }

            if (Software.OperatingSystem.IsUnix)
            {
                try
                {
                    IsAvailable = nvmlInit() == NvmlReturn.Success;
                }
                catch (DllNotFoundException)
                { }
                catch (EntryPointNotFoundException)
                {
                    try
                    {
                        IsAvailable = nvmlInitLegacy() == NvmlReturn.Success;
                    }
                    catch (EntryPointNotFoundException)
                    { }
                }
            }
            else if (IsNvmlCompatibleWindowsVersion())
            {
                // Attempt to load the Nvidia Management Library from the
                // windows standard search order for applications. This will
                // help installations that either have the library in
                // %windir%/system32 or provide their own library
                _windowsDll = PInvoke.LoadLibrary(WindowsDllName);

                // If there is no dll in the path, then attempt to load it
                // from program files
                if (_windowsDll.IsInvalid)
                {
                    string programFilesDirectory = Environment.ExpandEnvironmentVariables("%ProgramW6432%");
                    string dllPath = Path.Combine(programFilesDirectory, @"NVIDIA Corporation\NVSMI", WindowsDllName);

                    _windowsDll = PInvoke.LoadLibrary(dllPath);
                }

                IsAvailable = !_windowsDll.IsInvalid && InitialiseDelegates() && (_windowsNvmlInit() == NvmlReturn.Success);
            }

            return IsAvailable;
        }
    }

    private static bool IsNvmlCompatibleWindowsVersion()
    {
        return Software.OperatingSystem.Is64Bit && ((Environment.OSVersion.Version.Major > 6) || (Environment.OSVersion.Version.Major == 6 && Environment.OSVersion.Version.Minor >= 1));
    }

    private static bool InitialiseDelegates()
    {
        IntPtr nvmlInit = PInvoke.GetProcAddress(_windowsDll, "nvmlInit_v2");

        if (nvmlInit != IntPtr.Zero)
        {
            _windowsNvmlInit = (WindowsNvmlDelegate)Marshal.GetDelegateForFunctionPointer(nvmlInit, typeof(WindowsNvmlDelegate));
        }
        else
        {
            nvmlInit = PInvoke.GetProcAddress(_windowsDll, "nvmlInit");
            if (nvmlInit != IntPtr.Zero)
                _windowsNvmlInit = (WindowsNvmlDelegate)Marshal.GetDelegateForFunctionPointer(nvmlInit, typeof(WindowsNvmlDelegate));
            else
                return false;
        }

        IntPtr nvmlShutdown = PInvoke.GetProcAddress(_windowsDll, "nvmlShutdown");
        if (nvmlShutdown != IntPtr.Zero)
            _windowsNvmlShutdown = (WindowsNvmlDelegate)Marshal.GetDelegateForFunctionPointer(nvmlShutdown, typeof(WindowsNvmlDelegate));
        else
            return false;

        IntPtr nvmlGetHandle = PInvoke.GetProcAddress(_windowsDll, "nvmlDeviceGetHandleByIndex_v2");
        if (nvmlGetHandle != IntPtr.Zero)
            _windowsNvmlDeviceGetHandleByIndex = (WindowsNvmlGetHandleDelegate)Marshal.GetDelegateForFunctionPointer(nvmlGetHandle, typeof(WindowsNvmlGetHandleDelegate));
        else
        {
            nvmlGetHandle = PInvoke.GetProcAddress(_windowsDll, "nvmlDeviceGetHandleByIndex");
            if (nvmlGetHandle != IntPtr.Zero)
                _windowsNvmlDeviceGetHandleByIndex = (WindowsNvmlGetHandleDelegate)Marshal.GetDelegateForFunctionPointer(nvmlGetHandle, typeof(WindowsNvmlGetHandleDelegate));
            else
                return false;
        }

        IntPtr nvmlGetPowerUsage = PInvoke.GetProcAddress(_windowsDll, "nvmlDeviceGetPowerUsage");
        if (nvmlGetPowerUsage != IntPtr.Zero)
            _windowsNvmlDeviceGetPowerUsage = (WindowsNvmlGetPowerUsageDelegate)Marshal.GetDelegateForFunctionPointer(nvmlGetPowerUsage, typeof(WindowsNvmlGetPowerUsageDelegate));
        else
            return false;

        IntPtr nvmlGetPcieThroughput = PInvoke.GetProcAddress(_windowsDll, "nvmlDeviceGetPcieThroughput");
        if (nvmlGetPcieThroughput != IntPtr.Zero)
            _windowsNvmlDeviceGetPcieThroughputDelegate = (WindowsNvmlDeviceGetPcieThroughputDelegate)Marshal.GetDelegateForFunctionPointer(nvmlGetPcieThroughput, typeof(WindowsNvmlDeviceGetPcieThroughputDelegate));
        else
            return false;

        IntPtr nvmlGetHandlePciBus = PInvoke.GetProcAddress(_windowsDll, "nvmlDeviceGetHandleByPciBusId_v2");
        if (nvmlGetHandlePciBus != IntPtr.Zero)
            _windowsNvmlDeviceGetHandleByPciBusId = (WindowsNvmlGetHandleByPciBusIdDelegate)Marshal.GetDelegateForFunctionPointer(nvmlGetHandlePciBus, typeof(WindowsNvmlGetHandleByPciBusIdDelegate));
        else
            return false;

        IntPtr nvmlDeviceGetPciInfo = PInvoke.GetProcAddress(_windowsDll, "nvmlDeviceGetPciInfo_v2");
        if (nvmlDeviceGetPciInfo != IntPtr.Zero)
            _windowsNvmlDeviceGetPciInfo = (WindowsNvmlDeviceGetPciInfo)Marshal.GetDelegateForFunctionPointer(nvmlDeviceGetPciInfo, typeof(WindowsNvmlDeviceGetPciInfo));
        else
            return false;

        return true;
    }

    public static void Close()
    {
        lock (_syncRoot)
        {
            if (IsAvailable)
            {
                if (Software.OperatingSystem.IsUnix)
                {
                    nvmlShutdown();
                }
                else if (!_windowsDll.IsInvalid)
                {
                    _windowsNvmlShutdown();
                    _windowsDll.Dispose();
                }

                IsAvailable = false;
            }
        }
    }

    public static NvmlDevice? NvmlDeviceGetHandleByIndex(int index)
    {
        if (IsAvailable)
        {
            NvmlDevice nvmlDevice;
            if (Software.OperatingSystem.IsUnix)
            {
                try
                {
                    if (nvmlDeviceGetHandleByIndex(index, out nvmlDevice) == NvmlReturn.Success)
                        return nvmlDevice;
                }
                catch (EntryPointNotFoundException)
                {
                    if (nvmlDeviceGetHandleByIndexLegacy(index, out nvmlDevice) == NvmlReturn.Success)
                        return nvmlDevice;
                }
            }
            else
            {
                try
                {
                    if (_windowsNvmlDeviceGetHandleByIndex(index, out nvmlDevice) == NvmlReturn.Success)
                        return nvmlDevice;
                }
                catch { }
            }
        }

        return null;
    }

    public static NvmlDevice? NvmlDeviceGetHandleByPciBusId(string pciBusId)
    {
        if (IsAvailable)
        {
            NvmlDevice nvmlDevice;
            if (Software.OperatingSystem.IsUnix)
            {
                if (nvmlDeviceGetHandleByPciBusId(pciBusId, out nvmlDevice) == NvmlReturn.Success)
                    return nvmlDevice;
            }
            else
            {
                try
                {
                    if (_windowsNvmlDeviceGetHandleByPciBusId(pciBusId, out nvmlDevice) == NvmlReturn.Success)
                        return nvmlDevice;
                }
                catch { }
            }
        }

        return null;
    }

    public static int? NvmlDeviceGetPowerUsage(NvmlDevice nvmlDevice)
    {
        if (IsAvailable)
        {
            int powerUsage;
            if (Software.OperatingSystem.IsUnix)
            {
                if (nvmlDeviceGetPowerUsage(nvmlDevice, out powerUsage) == NvmlReturn.Success)
                    return powerUsage;
            }
            else
            {
                try
                {
                    if (_windowsNvmlDeviceGetPowerUsage(nvmlDevice, out powerUsage) == NvmlReturn.Success)
                        return powerUsage;
                }
                catch { }
            }
        }

        return null;
    }

    public static uint? NvmlDeviceGetPcieThroughput(NvmlDevice nvmlDevice, NvmlPcieUtilCounter counter)
    {
        if (IsAvailable)
        {
            uint pcieThroughput;
            if (Software.OperatingSystem.IsUnix)
            {
                if (nvmlDeviceGetPcieThroughput(nvmlDevice, counter, out pcieThroughput) == NvmlReturn.Success)
                    return pcieThroughput;
            }
            else
            {
                try
                {
                    if (_windowsNvmlDeviceGetPcieThroughputDelegate(nvmlDevice, counter, out pcieThroughput) == NvmlReturn.Success)
                        return pcieThroughput;
                }
                catch { }
            }
        }

        return null;
    }

    public static NvmlPciInfo? NvmlDeviceGetPciInfo(NvmlDevice nvmlDevice)
    {
        if (IsAvailable)
        {
            var pci = new NvmlPciInfo();

            if (Software.OperatingSystem.IsUnix)
            {
                if (nvmlDeviceGetPciInfo(nvmlDevice, ref pci) == NvmlReturn.Success)
                    return pci;
            }
            else
            {
                try
                {
                    if (_windowsNvmlDeviceGetPciInfo(nvmlDevice, ref pci) == NvmlReturn.Success)
                        return pci;
                }
                catch { }

            }
        }

        return null;
    }

    [DllImport(LinuxDllName, EntryPoint = "nvmlInit_v2", ExactSpelling = true)]
    private static extern NvmlReturn nvmlInit();

    [DllImport(LinuxDllName, EntryPoint = "nvmlInit", ExactSpelling = true)]
    private static extern NvmlReturn nvmlInitLegacy();

    [DllImport(LinuxDllName, EntryPoint = "nvmlShutdown", ExactSpelling = true)]
    private static extern NvmlReturn nvmlShutdown();

    [DllImport(LinuxDllName, EntryPoint = "nvmlDeviceGetHandleByIndex_v2", ExactSpelling = true)]
    private static extern NvmlReturn nvmlDeviceGetHandleByIndex(int index, out NvmlDevice device);

    [DllImport(LinuxDllName, EntryPoint = "nvmlDeviceGetHandleByPciBusId_v2", ExactSpelling = true)]
    private static extern NvmlReturn nvmlDeviceGetHandleByPciBusId([MarshalAs(UnmanagedType.LPStr)] string pciBusId, out NvmlDevice device);

    [DllImport(LinuxDllName, EntryPoint = "nvmlDeviceGetHandleByIndex", ExactSpelling = true)]
    private static extern NvmlReturn nvmlDeviceGetHandleByIndexLegacy(int index, out NvmlDevice device);

    [DllImport(LinuxDllName, EntryPoint = "nvmlDeviceGetPowerUsage", ExactSpelling = true)]
    private static extern NvmlReturn nvmlDeviceGetPowerUsage(NvmlDevice device, out int power);

    [DllImport(LinuxDllName, EntryPoint = "nvmlDeviceGetPcieThroughput", ExactSpelling = true)]
    private static extern NvmlReturn nvmlDeviceGetPcieThroughput(NvmlDevice device, NvmlPcieUtilCounter counter, out uint value);

    [DllImport(LinuxDllName, EntryPoint = "nvmlDeviceGetPciInfo_v2")]
    private static extern NvmlReturn nvmlDeviceGetPciInfo(NvmlDevice device, ref NvmlPciInfo pci);

    private delegate NvmlReturn WindowsNvmlDelegate();

    private delegate NvmlReturn WindowsNvmlGetHandleDelegate(int index, out NvmlDevice device);

    private delegate NvmlReturn WindowsNvmlGetHandleByPciBusIdDelegate([MarshalAs(UnmanagedType.LPStr)] string pciBusId, out NvmlDevice device);

    private delegate NvmlReturn WindowsNvmlGetPowerUsageDelegate(NvmlDevice device, out int power);

    private delegate NvmlReturn WindowsNvmlDeviceGetPcieThroughputDelegate(NvmlDevice device, NvmlPcieUtilCounter counter, out uint value);

    private delegate NvmlReturn WindowsNvmlDeviceGetPciInfo(NvmlDevice device, ref NvmlPciInfo pci);

    [StructLayout(LayoutKind.Sequential)]
    public struct NvmlDevice
    {
        public IntPtr Handle;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct NvmlPciInfo
    {
        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 16)]
        public string busId;

        public uint domain;

        public uint bus;

        public uint device;

        public ushort pciVendorId;

        public ushort pciDeviceId;

        public uint pciSubSystemId;

        public uint reserved0;
        public uint reserved1;
        public uint reserved2;
        public uint reserved3;
    }
}

```

`LibreHardwareMonitorLib/Interop/PowerMonitor/DeviceData.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Linq;

namespace LibreHardwareMonitor.Interop.PowerMonitor;

public sealed class DeviceData
{
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;

    public bool Connected { get; set; }

    public string HardwareRevision { get; set; } = "A0";

    public string FirmwareVersion { get; set; } = "0.0.0";

    public double[] PinVoltage { get; set; } = new double[6];

    public double[] PinCurrent { get; set; } = new double[6];

    public double OnboardTempInC { get; set; }

    public double OnboardTempOutC { get; set; }

    public double ExternalTemp1C { get; set; }

    public double ExternalTemp2C { get; set; }

    public int PsuCapabilityW { get; set; }

    public double SumCurrentA => PinCurrent.Sum();

    public double SumPowerW => PinVoltage.Zip(PinCurrent, (v, i) => v * i).Sum();

    public ushort FaultStatus { get; set; }

    public ushort FaultLog { get; set; }

    public DeviceConfigStructV2 Config;
}

```

`LibreHardwareMonitorLib/Interop/PowerMonitor/Stm32PortFinder.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Text;
using Windows.Win32;
using Windows.Win32.Devices.DeviceAndDriverInstallation;
using Windows.Win32.Foundation;

namespace LibreHardwareMonitor.Interop.PowerMonitor;

/// <summary>
/// Helper class to find STM32 COM ports based on VID and PID.
/// </summary>
public static class Stm32PortFinder
{
    private const int BufferSize = 1024;

    /// <summary>
    /// Finds the names of all available COM ports that match the specified USB vendor ID (VID) and product ID (PID).
    /// </summary>
    /// <param name="vid">The USB vendor ID to match.</param>
    /// <param name="pid">The USB product ID to match.</param>
    /// <returns>
    /// A list of strings containing the names of matching COM ports.<br />
    /// The list is empty if no matching ports are found.
    /// </returns>
    public static List<string> FindMatchingComPorts(uint vid, uint pid)
    {
        return FindMatchingComPorts($"{vid:X4}", $"{pid:X4}");
    }

    /// <summary>
    ///     <inheritdoc cref="FindMatchingComPorts(uint, uint)" />
    /// </summary>
    /// <param name="vid">
    ///     <inheritdoc cref="FindMatchingComPorts(uint, uint)" />
    /// </param>
    /// <param name="pid">
    ///     <inheritdoc cref="FindMatchingComPorts(uint, uint)" />
    /// </param>
    /// <returns>
    ///     <inheritdoc cref="FindMatchingComPorts(uint, uint)" />
    /// </returns>
    public static List<string> FindMatchingComPorts(string vid, string pid)
    {
        var result = new List<string>();

        //Setup
        SetupDiDestroyDeviceInfoListSafeHandle devInfo = PInvoke.SetupDiGetClassDevs(PInvoke.GUID_DEVCLASS_PORTS, null, HWND.Null, SETUP_DI_GET_CLASS_DEVS_FLAGS.DIGCF_PRESENT);

        //Check handle
        if (devInfo.IsInvalid)
        {
            return result;
        }

        try
        {
            SP_DEVINFO_DATA devInfoData = new() { cbSize = (uint)Marshal.SizeOf<SP_DEVINFO_DATA>() };

            uint index = 0;
            while (PInvoke.SetupDiEnumDeviceInfo(devInfo, index++, ref devInfoData))
            {
                //Get hardware ID
                string hwId = GetProperty(devInfo, SETUP_DI_REGISTRY_PROPERTY.SPDRP_HARDWAREID, devInfoData);
                if (string.IsNullOrWhiteSpace(hwId))
                {
                    continue;
                }

                //Check if hardware ID contains VID and PID
                if (!hwId.Contains($"VID_{vid}", StringComparison.OrdinalIgnoreCase) ||
                    !hwId.Contains($"PID_{pid}", StringComparison.OrdinalIgnoreCase))
                {
                    continue;
                }

                //Get friendly name
                string friendlyName = GetProperty(devInfo, SETUP_DI_REGISTRY_PROPERTY.SPDRP_FRIENDLYNAME, devInfoData);

                //Extract COM port from friendly name
                int start = friendlyName.LastIndexOf("(COM", StringComparison.OrdinalIgnoreCase);
                int end = friendlyName.LastIndexOf(')');

                //Check if valid and add to result
                if (start >= 0 && end > start)
                {
                    string com = friendlyName.Substring(start + 1, end - start - 1);
                    result.Add(com);
                }
            }
        }
        finally
        {
            //Cleanup
            devInfo.Dispose();
        }

        return result;

        static string GetProperty(SafeHandle hDevInfo, SETUP_DI_REGISTRY_PROPERTY property, SP_DEVINFO_DATA devInfoData)
        {
            byte[] buffer = new byte[BufferSize];

            if (PInvoke.SetupDiGetDeviceRegistryProperty(hDevInfo, devInfoData, property, buffer))
            {
                //Take first string only, no need for the rest
                return NormalizeString(Encoding.Unicode.GetString(buffer));
            }

            return null;
        }
    }

    private static string NormalizeString(string str)
    {
        int end = str.IndexOf('\0');
        if (end == -1)
        {
            end = 0;
        }

        return str.Substring(0, end);
    }
}

```

`LibreHardwareMonitorLib/Interop/PowerMonitor/StructureConversion.cs`:

```cs
namespace LibreHardwareMonitor.Interop.PowerMonitor;

public static class StructureConversion
{
    public static DeviceConfigStructV1 ConvertConfigV2ToV1(DeviceConfigStructV2 configV2)
    {
        DeviceConfigStructV1 configV1 = new DeviceConfigStructV1
        {
            Crc = configV2.Crc,
            Version = configV2.Version,
            FriendlyName = configV2.FriendlyName,
            FanConfig = configV2.FanConfig,
            BacklightDuty = configV2.BacklightDuty,
            FaultDisplayEnable = configV2.FaultDisplayEnable,
            FaultBuzzerEnable = configV2.FaultBuzzerEnable,
            FaultSoftPowerEnable = configV2.FaultSoftPowerEnable,
            FaultHardPowerEnable = configV2.FaultHardPowerEnable,
            TsFaultThreshold = configV2.TsFaultThreshold,
            OcpFaultThreshold = configV2.OcpFaultThreshold,
            WireOcpFaultThreshold = configV2.WireOcpFaultThreshold,
            OppFaultThreshold = configV2.OppFaultThreshold,
            CurrentImbalanceFaultThreshold = configV2.CurrentImbalanceFaultThreshold,
            CurrentImbalanceFaultMinLoad = configV2.CurrentImbalanceFaultMinLoad,
            ShutdownWaitTime = configV2.ShutdownWaitTime,
            LoggingInterval = configV2.LoggingInterval,
            Ui = configV2.Ui
        };
        return configV1;
    }

    public static DeviceConfigStructV2 ConvertConfigV1ToV2(DeviceConfigStructV1 configV1)
    {
        DeviceConfigStructV2 configV2 = new DeviceConfigStructV2
        {
            Crc = configV1.Crc,
            Version = configV1.Version,
            FriendlyName = configV1.FriendlyName,
            FanConfig = configV1.FanConfig,
            BacklightDuty = configV1.BacklightDuty,
            FaultDisplayEnable = configV1.FaultDisplayEnable,
            FaultBuzzerEnable = configV1.FaultBuzzerEnable,
            FaultSoftPowerEnable = configV1.FaultSoftPowerEnable,
            FaultHardPowerEnable = configV1.FaultHardPowerEnable,
            TsFaultThreshold = configV1.TsFaultThreshold,
            OcpFaultThreshold = configV1.OcpFaultThreshold,
            WireOcpFaultThreshold = configV1.WireOcpFaultThreshold,
            OppFaultThreshold = configV1.OppFaultThreshold,
            CurrentImbalanceFaultThreshold = configV1.CurrentImbalanceFaultThreshold,
            CurrentImbalanceFaultMinLoad = configV1.CurrentImbalanceFaultMinLoad,
            ShutdownWaitTime = configV1.ShutdownWaitTime,
            LoggingInterval = configV1.LoggingInterval,
            Average = AVG.AVG_1417MS, // Default value
            Ui = configV1.Ui
        };
        return configV2;
    }
}

```

`LibreHardwareMonitorLib/Interop/PowerMonitor/WireViewPro2Enums.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

namespace LibreHardwareMonitor.Interop.PowerMonitor;

public enum UsbCmd : byte
{
    CMD_WELCOME,
    CMD_READ_VENDOR_DATA,
    CMD_READ_UID,
    CMD_READ_DEVICE_DATA,
    CMD_READ_SENSOR_VALUES,
    CMD_READ_CONFIG,
    CMD_WRITE_CONFIG,
    CMD_READ_CALIBRATION,
    CMD_WRITE_CALIBRATION,
    CMD_SPI_FLASH_WRITE_PAGE,
    CMD_SPI_FLASH_READ_PAGE,
    CMD_SPI_FLASH_ERASE_SECTOR,
    CMD_SCREEN_CHANGE,
    CMD_READ_BUILD_INFO,
    CMD_CLEAR_FAULTS,
    CMD_RESET = 0xF0,
    CMD_BOOTLOADER = 0xF1,
    CMD_NVM_CONFIG = 0xF2,
    CMD_NOP = 0xFF
}

public enum SensorTs
{
    SENSOR_TS_IN,
    SENSOR_TS_OUT,
    SENSOR_TS3,
    SENSOR_TS4,
}

public enum HpwrCapability : byte
{
    PSU_CAP_600W = 0,
    PSU_CAP_450W = 1,
    PSU_CAP_300W = 2,
    PSU_CAP_150W = 3
}

public enum FanMode : byte
{
    FanModeCurve = 0,
    FanModeFixed = 1
}

public enum TempSource : byte
{
    TempSourceTsIn = 0,
    TempSourceTsOut = 1,
    TempSourceTs1 = 2,
    TempSourceTs2 = 3,
    TempSourceTmax = 4
}

public enum CurrentScale : byte
{
    CurrentScale5A = 0,
    CurrentScale10A = 1,
    CurrentScale15A = 2,
    CurrentScale20A = 3
}

public enum PowerScale : byte
{
    PowerScaleAuto = 0,
    PowerScale300W = 1,
    PowerScale600W = 2
}

public enum Theme : byte
{
    ThemeTg1 = 0,
    ThemeTg2 = 1,
    ThemeTg3 = 2
}

public enum DisplayRotation : byte
{
    DisplayRotation0 = 0,
    DisplayRotation180 = 1
}

public enum TimeoutMode : byte
{
    TimeoutModeStatic = 0,
    TimeoutModeCycle = 1,
    TimeoutModeSleep = 2
}

public enum NVM_CMD : byte
{
    NVM_CMD_NONE,
    NVM_CMD_LOAD,
    NVM_CMD_STORE,
    NVM_CMD_RESET,
    NVM_CMD_LOAD_CAL,
    NVM_CMD_STORE_CAL,
    NVM_CMD_LOAD_CAL_FACTORY,
    NVM_CMD_STORE_CAL_FACTORY,
}

public enum SCREEN_CMD : byte
{
    SCREEN_GOTO_MAIN = 0xE0,
    SCREEN_GOTO_SIMPLE = 0xE1,
    SCREEN_GOTO_CURRENT = 0xE2,
    SCREEN_GOTO_TEMP = 0xE3,
    SCREEN_GOTO_STATUS = 0xE4,
    SCREEN_GOTO_SAME = 0xEF,
    SCREEN_PAUSE_UPDATES = 0xF0,
    SCREEN_RESUME_UPDATES = 0xF1
}

public enum AVG : byte
{
    AVG_22MS,
    AVG_44MS,
    AVG_89MS,
    AVG_177MS,
    AVG_354MS,
    AVG_709MS,
    AVG_1417MS,
    AVG_NUM
}

```

`LibreHardwareMonitorLib/Interop/PowerMonitor/WireViewPro2Structures.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System.Runtime.InteropServices;

namespace LibreHardwareMonitor.Interop.PowerMonitor;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
public struct VendorDataStruct
{
    public byte VendorId;
    public byte ProductId;
    public byte FwVersion;
}

[StructLayout(LayoutKind.Sequential, Pack = 4)]
public struct PowerSensor
{
    public short Voltage;
    public uint Current;
    public uint Power;
}

[StructLayout(LayoutKind.Sequential, Pack = 4)]
public struct SensorStruct
{
    [MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
    public short[] Ts; // 0.1 °C

    public ushort Vdd; // mV
    public byte FanDuty; // %

    [MarshalAs(UnmanagedType.ByValArray, SizeConst = 6)]
    public PowerSensor[] PowerReadings;

    public uint TotalPower; // mW
    public uint TotalCurrent; // mA
    public ushort AvgVoltage; // mV
    public HpwrCapability HpwrCapability; // 8-bit enum
    public ushort FaultStatus;
    public ushort FaultLog;
}

[StructLayout(LayoutKind.Sequential, Pack = 4)]
public struct FanConfigStruct
{
    public FanMode Mode;
    public TempSource TempSource;
    public byte DutyMin;
    public byte DutyMax;
    public short TempMin;
    public short TempMax;
}

[StructLayout(LayoutKind.Sequential, Pack = 4)]
public struct UiConfigStruct
{
    public CurrentScale CurrentScale;
    public PowerScale PowerScale;
    public Theme Theme;
    public DisplayRotation DisplayRotation;
    public TimeoutMode TimeoutMode;
    public byte CycleScreens;
    public byte CycleTime;
    public byte Timeout;
}

[StructLayout(LayoutKind.Sequential, Pack = 4, CharSet = CharSet.Ansi)]
public struct DeviceConfigStructV1
{
    public ushort Crc;
    public byte Version;

    [MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
    public byte[] FriendlyName;

    public FanConfigStruct FanConfig;
    public byte BacklightDuty;

    public ushort FaultDisplayEnable;
    public ushort FaultBuzzerEnable;
    public ushort FaultSoftPowerEnable;
    public ushort FaultHardPowerEnable;
    public short TsFaultThreshold; // 0.1 °C
    public byte OcpFaultThreshold; // A
    public byte WireOcpFaultThreshold; // 0.1A
    public ushort OppFaultThreshold; // W
    public byte CurrentImbalanceFaultThreshold; // %
    public byte CurrentImbalanceFaultMinLoad; // A
    public byte ShutdownWaitTime; // seconds
    public byte LoggingInterval; // seconds
    public UiConfigStruct Ui;
}

[StructLayout(LayoutKind.Sequential, Pack = 4, CharSet = CharSet.Ansi)]
public struct DeviceConfigStructV2
{
    public ushort Crc;
    public byte Version;

    [MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
    public byte[] FriendlyName;

    public FanConfigStruct FanConfig;
    public byte BacklightDuty;

    public ushort FaultDisplayEnable;
    public ushort FaultBuzzerEnable;
    public ushort FaultSoftPowerEnable;
    public ushort FaultHardPowerEnable;
    public short TsFaultThreshold; // 0.1 °C
    public byte OcpFaultThreshold; // A
    public byte WireOcpFaultThreshold; // 0.1A
    public ushort OppFaultThreshold; // W
    public byte CurrentImbalanceFaultThreshold; // %
    public byte CurrentImbalanceFaultMinLoad; // A
    public byte ShutdownWaitTime; // seconds
    public byte LoggingInterval; // seconds
    public AVG Average;
    public UiConfigStruct Ui;
}

```

`LibreHardwareMonitorLib/LibreHardwareMonitorLib.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>net472;netstandard2.0;net8.0;net9.0;net10.0</TargetFrameworks>
    <Platforms>x64;x86;ARM64</Platforms>
    <RuntimeIdentifiers>win-x64;win-x86;win-arm64</RuntimeIdentifiers>
    <AssemblyName>LibreHardwareMonitorLib</AssemblyName>
    <RootNamespace>LibreHardwareMonitor</RootNamespace>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <GeneratePackageOnBuild>true</GeneratePackageOnBuild>
    <PackageRequireLicenseAcceptance>false</PackageRequireLicenseAcceptance>
    <PackageId>$(AssemblyName)</PackageId>
    <Description>Monitor the temperature sensors, fan speeds, voltages, load and clock speeds of your computer.</Description>
    <PackageLicense>https://github.com/LibreHardwareMonitor/LibreHardwareMonitor/blob/master/Licenses/LICENSE</PackageLicense>
    <PackageLicenseExpression>MPL-2.0</PackageLicenseExpression>
    <PackageProjectUrl>https://github.com/LibreHardwareMonitor/LibreHardwareMonitor</PackageProjectUrl>
    <PackageTags>libre open hardware monitor monitoring system logging cpu gpu</PackageTags>
    <PackageVersion>$(Version)</PackageVersion>
    <Pack>true</Pack>
    <RepositoryUrl>https://github.com/LibreHardwareMonitor/LibreHardwareMonitor</RepositoryUrl>
    <LangVersion>latest</LangVersion>
    <PackageIcon>packageicon.png</PackageIcon>
    <GenerateResourceUsePreserializedResources>true</GenerateResourceUsePreserializedResources>
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
    <NoWarn>$(NoWarn);CA1416</NoWarn>
  </PropertyGroup>

  <PropertyGroup Condition="'$(BuildOnlyRefs)'=='true'">
    <Platform>AnyCPU</Platform>
    <ProduceOnlyReferenceAssembly>true</ProduceOnlyReferenceAssembly>
    <GeneratePackageOnBuild>false</GeneratePackageOnBuild>
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)'=='Debug'">
    <OutputPath>..\bin\Debug\$(Platform)\</OutputPath>
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)'=='Release'">
    <OutputPath>..\bin\Release\$(Platform)\</OutputPath>
  </PropertyGroup>

  <ItemGroup>
    <EmbeddedResource Include="Resources\PawnIo\AMDFamily0F.bin" />
    <EmbeddedResource Include="Resources\PawnIo\AMDFamily10.bin" />
    <EmbeddedResource Include="Resources\PawnIo\AMDFamily17.bin" />
    <EmbeddedResource Include="Resources\PawnIo\IntelMSR.bin" />
    <EmbeddedResource Include="Resources\PawnIo\IsaBridgeEC.bin" />
    <EmbeddedResource Include="Resources\PawnIo\LpcACPIEC.bin" />
    <EmbeddedResource Include="Resources\PawnIo\LpcCrOSEC.bin" />
    <EmbeddedResource Include="Resources\PawnIo\LpcIO.bin" />
    <EmbeddedResource Include="Resources\PawnIo\RyzenSMU.bin" />
    <EmbeddedResource Include="Resources\PawnIo\SmbusI801.bin" />
    <EmbeddedResource Include="Resources\PawnIo\SmbusNCT6793.bin" />
    <EmbeddedResource Include="Resources\PawnIo\SmbusPIIX4.bin" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' != 'net472'">
    <PackageReference Include="Microsoft.Win32.Registry" Version="5.0.0" />
    <PackageReference Include="Mono.Posix.NETStandard" Version="1.0.0" />
    <PackageReference Include="System.IO.FileSystem.AccessControl" Version="5.0.0" />
    <PackageReference Include="System.IO.Ports" Version="10.0.3" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="DiskInfoToolkit" Version="1.1.2" />
    <PackageReference Include="HidSharp" Version="2.6.4" />
    <PackageReference Include="Microsoft.Windows.CsWin32" Version="0.3.269">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="RAMSPDToolkit-NDD" Version="1.4.2" />
    <PackageReference Include="System.Management" Version="10.0.2" />
    <PackageReference Include="System.Memory" Version="4.6.3" Condition="'$(TargetFramework)' == 'net472'" />
    <PackageReference Include="System.Threading.AccessControl" Version="10.0.3" />
  </ItemGroup>

  <ItemGroup>
    <None Include="Resources\packageicon.png" PackagePath="">
      <Pack>True</Pack>
    </None>
  </ItemGroup>

  <Import Project="main.nuget.target" Condition="'$(PackMainNuget)' == 'true'" />
</Project>

```

`LibreHardwareMonitorLib/NativeMethods.txt`:

```txt
CM_Get_Device_Interface_List_Size
CM_Get_Device_Interface_List
GUID_DISPLAY_DEVICE_ARRIVAL
NtQuerySystemInformation
SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION
STATUS_INFO_LENGTH_MISMATCH
STATUS_SUCCESS
D3DKMTCloseAdapter
D3DKMTOpenAdapterFromDeviceName
D3DKMTQueryAdapterInfo
D3DKMTQueryStatistics
D3DKMT_ADAPTERTYPE
D3DKMT_SEGMENTSIZEINFO
D3DKMT_NODEMETADATA
D3DKMT_QUERYSTATISTICS_NODE_INFORMATION
SetupDiEnumDeviceInfo
SetupDiGetDeviceRegistryProperty
SetupDiDestroyDeviceInfoList
SetupDiGetDeviceInterfaceDetail
SetupDiEnumDeviceInterfaces
SetupDiGetClassDevs
SP_DEVICE_INTERFACE_DATA
SP_DEVICE_INTERFACE_DETAIL_DATA_W
GUID_DEVCLASS_PORTS
GUID_DEVICE_BATTERY
SETUP_DI_REGISTRY_PROPERTY
WIN32_ERROR
HRESULT_FROM_WIN32
GlobalMemoryStatusEx
GetCurrentThread
GetActiveProcessorGroupCount
GROUP_AFFINITY
SetThreadGroupAffinity
EnumSystemFirmwareTables
GetSystemFirmwareTable
DISK_PERFORMANCE
BATTERY_QUERY_INFORMATION
BATTERY_INFORMATION
BATTERY_SYSTEM_BATTERY
BATTERY_STATUS
BATTERY_WAIT_STATUS
CreateFile
VirtualFree
VirtualAlloc
DeviceIoControl
IOCTL_*
LoadLibrary
FreeLibrary
GetProcAddress
BATTERY_UNKNOWN_*
CM_Locate_DevNode
CM_Get_DevNode_Property
CM_LOCATE_DEVNODE_FLAGS
DEVPKEY_Device_BusNumber
DEVPKEY_Device_Address

```

`LibreHardwareMonitorLib/PawnIo/AmdFamily0F.cs`:

```cs
using LibreHardwareMonitor.Hardware;

namespace LibreHardwareMonitor.PawnIo;

public class AmdFamily0F
{
    private readonly PawnIo _pawnIO = PawnIo.LoadModuleFromResource(typeof(AmdFamily0F).Assembly, $"{nameof(LibreHardwareMonitor)}.Resources.PawnIo.AMDFamily0F.bin");

    public bool ReadMsr(uint index, out uint eax, out uint edx)
    {
        long[] inArray = new long[1];
        inArray[0] = index;
        eax = 0;
        edx = 0;
        try
        {
            long[] outArray = _pawnIO.Execute("ioctl_read_msr", inArray, 1);
            eax = (uint)outArray[0];
            edx = (uint)(outArray[0] >> 32);
        }
        catch
        {
            return false;
        }

        return true;
    }

    public bool ReadMsr(uint index, out uint eax, out uint edx, GroupAffinity affinity)
    {
        GroupAffinity previousAffinity = ThreadAffinity.Set(affinity);
        bool result = ReadMsr(index, out eax, out edx);
        ThreadAffinity.Set(previousAffinity);
        return result;
    }

    public uint GetThermtrip(int cpuIndex, uint coreIndex)
    {
        long[] inArray = new long[2];
        inArray[0] = cpuIndex;
        inArray[1] = coreIndex;
        long[] outArray = _pawnIO.Execute("ioctl_get_thermtrip", inArray, 1);
        return (uint)outArray[0];
    }

    public void Close() => _pawnIO.Close();
}

```

`LibreHardwareMonitorLib/PawnIo/AmdFamily10.cs`:

```cs
using LibreHardwareMonitor.Hardware;

namespace LibreHardwareMonitor.PawnIo;

public class AmdFamily10
{
    private readonly PawnIo _pawnIo = PawnIo.LoadModuleFromResource(typeof(AmdFamily0F).Assembly, $"{nameof(LibreHardwareMonitor)}.Resources.PawnIo.AMDFamily10.bin");

    public void MeasureTscMultiplier(out long ctrPerTick, out long cofVid)
    {
        long[] result = _pawnIo.Execute("ioctl_measure_tsc_multiplier", [], 2);
        ctrPerTick = result[0];
        cofVid = result[1];
    }

    public bool HaveCstateResidencyInfo()
    {
        try
        {
            ReadCstateResidency();
            return true;
        }
        catch
        {
            // ignored
        }

        return false;
    }

    public byte[] ReadCstateResidency()
    {
        long[] result = _pawnIo.Execute("ioctl_read_cstate_residency", [], 2);
        return [(byte)result[0], (byte)result[1]];
    }

    public uint ReadMiscCtl(int cpu, uint offset)
    {
        long[] result = _pawnIo.Execute("ioctl_read_miscctl", [cpu, offset], 1);
        return (uint)result[0];
    }

    public uint ReadSmu(uint offset)
    {
        long[] result = _pawnIo.Execute("ioctl_read_smu", [offset], 1);
        return (uint)result[0];
    }

    public bool ReadMsr(uint index, out uint eax, out uint edx)
    {
        long[] inArray = new long[1];
        inArray[0] = index;
        eax = 0;
        edx = 0;
        try
        {
            long[] outArray = _pawnIo.Execute("ioctl_read_msr", inArray, 1);
            eax = (uint)outArray[0];
            edx = (uint)(outArray[0] >> 32);
        }
        catch
        {
            return false;
        }

        return true;
    }

    public bool ReadMsr(uint index, out uint eax, out uint edx, GroupAffinity affinity)
    {
        GroupAffinity previousAffinity = ThreadAffinity.Set(affinity);
        bool result = ReadMsr(index, out eax, out edx);
        ThreadAffinity.Set(previousAffinity);
        return result;
    }

    public void Close() => _pawnIo.Close();
}

```

`LibreHardwareMonitorLib/PawnIo/AmdFamily17.cs`:

```cs
namespace LibreHardwareMonitor.PawnIo;

public class AmdFamily17
{
    private readonly PawnIo _pawnIo = PawnIo.LoadModuleFromResource(typeof(AmdFamily0F).Assembly, $"{nameof(LibreHardwareMonitor)}.Resources.PawnIo.AMDFamily17.bin");

    public uint ReadSmn(uint offset)
    {
        long[] result = _pawnIo.Execute("ioctl_read_smn", [offset], 1);
        return (uint)result[0];
    }

    public bool ReadMsr(uint index, out uint eax, out uint edx)
    {
        long[] inArray = new long[1];
        inArray[0] = index;
        eax = 0;
        edx = 0;
        try
        {
            long[] outArray = _pawnIo.Execute("ioctl_read_msr", inArray, 1);
            eax = (uint)outArray[0];
            edx = (uint)(outArray[0] >> 32);
        }
        catch
        {
            return false;
        }

        return true;
    }

    public bool ReadMsr(uint index, out ulong eaxedx)
    {
        long[] inArray = new long[1];
        inArray[0] = index;
        eaxedx = 0;
        try
        {
            long[] outArray = _pawnIo.Execute("ioctl_read_msr", inArray, 1);
            eaxedx = (ulong)outArray[0];
        }
        catch
        {
            return false;
        }

        return true;
    }

    public void Close() => _pawnIo.Close();
}

```

`LibreHardwareMonitorLib/PawnIo/IntelMsr.cs`:

```cs
using LibreHardwareMonitor.Hardware;

namespace LibreHardwareMonitor.PawnIo;

public class IntelMsr
{
    private readonly long[] _inArray = new long[1];
    private readonly PawnIo _pawnIO = PawnIo.LoadModuleFromResource(typeof(IntelMsr).Assembly, $"{nameof(LibreHardwareMonitor)}.Resources.PawnIo.IntelMSR.bin");

    public bool ReadMsr(uint index, out ulong value)
    {
        _inArray[0] = index;
        value = 0;
        try
        {
            long[] outArray = _pawnIO.Execute("ioctl_read_msr", _inArray, 1);
            value = (ulong)outArray[0];
        }
        catch
        {
            return false;
        }

        return true;
    }

    public bool ReadMsr(uint index, out uint eax, out uint edx)
    {
        _inArray[0] = index;
        eax = 0;
        edx = 0;
        try
        {
            long[] outArray = _pawnIO.Execute("ioctl_read_msr", _inArray, 1);
            eax = (uint)outArray[0];
            edx = (uint)(outArray[0] >> 32);
        }
        catch
        {
            return false;
        }

        return true;
    }

    public bool ReadMsr(uint index, out uint eax, out uint edx, GroupAffinity affinity)
    {
        GroupAffinity previousAffinity = ThreadAffinity.Set(affinity);
        bool result = ReadMsr(index, out eax, out edx);
        ThreadAffinity.Set(previousAffinity);
        return result;
    }

    public void Close() => _pawnIO.Close();
}

```

`LibreHardwareMonitorLib/PawnIo/IsaBridgeEc.cs`:

```cs
//#define ISA_BRIDGE_EC_DEBUG

using System.Diagnostics;

namespace LibreHardwareMonitor.PawnIo
{
    public enum MMIOState
    {
        Unknown = -999,

        MMIO_Original = -1,
        MMIO_Disabled = 0,
        MMIO_Enabled2E = 1,
        MMIO_Enabled4E = 2,
        MMIO_EnabledBoth = 3
    };

    public struct MMIOMapping
    {
        public int Index;
        public long BaseAddress;
        public long SuperIoSize;
        public long ChipId;
    }

    public class IsaBridgeEc
    {
        private readonly PawnIo _pawnIO = PawnIo.LoadModuleFromResource(typeof(IsaBridgeEc).Assembly, $"{nameof(LibreHardwareMonitor)}.Resources.PawnIo.IsaBridgeEC.bin");

        // ioctl_find_superio_mmio
        public bool FindSuperIoMMIO(out MMIOMapping firstMmio, out MMIOMapping secondMmio)
        {
            long[] outArray = new long[6];
            int ntStatusCode = _pawnIO.ExecuteHr("ioctl_find_superio_mmio", [], 0, outArray, 6, out uint returnSize);

            Log($"FindSuperIoMMIO statusCode: {ntStatusCode}");

            if (ntStatusCode != 0)
            {
                firstMmio = default;
                secondMmio = default;
                return false;
            }

            firstMmio = new MMIOMapping
            {
                Index = 0,
                BaseAddress = outArray[0],
                SuperIoSize = outArray[1],
                ChipId = outArray[2]
            };

            secondMmio = new MMIOMapping
            {
                Index = 1,
                BaseAddress = outArray[3],
                SuperIoSize = outArray[4],
                ChipId = outArray[5]
            };

            Log($"First MMIO - BaseAddress: 0x{firstMmio.BaseAddress:X}, SuperIoSize: 0x{firstMmio.SuperIoSize:X}, ChipId: 0x{firstMmio.ChipId:X}");
            Log($"Second MMIO - BaseAddress: 0x{secondMmio.BaseAddress:X}, SuperIoSize: 0x{secondMmio.SuperIoSize:X}, ChipId: 0x{secondMmio.ChipId:X}");

            return firstMmio.BaseAddress != 0 || secondMmio.BaseAddress != 0;
        }

        //ioctl_access_superio_mmio
        public bool ReadMmio(long superIoIndex, long offset, long size, out byte value)
        {
            long[] inArray = new long[5] {
                superIoIndex, // superio index
                offset, // offset
                size, // size
                0, // is write?
                0 // value (ignored for read)
            };

            long[] outarray = new long[1];

            int ntStatusCode = _pawnIO.ExecuteHr("ioctl_access_superio_mmio", inArray, 5, outarray, 1, out uint returnSize);

            Log($"ReadMmio statusCode: {ntStatusCode}, Read Value: 0x{outarray[0]:X} at SuperIoIndex {superIoIndex}, offset {offset}, size {size}");

            value = (byte)outarray[0];

            return ntStatusCode == 0;
        }

        //ioctl_access_superio_mmio
        public bool WriteMmio(long superIoIndex, long offset, long size, byte value)
        {
            long[] inArray = new long[5] {
                superIoIndex, // superio index
                offset, // offset
                size, // size
                1, // is write?
                value // value
            };

            long[] outarray = new long[1];

            int ntStatusCode = _pawnIO.ExecuteHr("ioctl_access_superio_mmio", inArray, 5, outarray, 1, out uint returnSize);

            Log($"WriteMmio statusCode: {ntStatusCode}, Written Value: 0x{value:X} at SuperIoIndex {superIoIndex}, offset {offset}, size {size}");

            return ntStatusCode == 0;
        }

        // ioctl_map_superio_mmio
        public bool Map()
        {
            int ntStatusCode = _pawnIO.ExecuteHr("ioctl_map_superio_mmio", [], 0, [], 0, out uint returnSize);

            Log($"Map statusCode: {ntStatusCode}");

            return ntStatusCode == 0;
        }

        // ioctl_unmap_superio_mmio
        public bool Unmap()
        {
            int ntStatusCode = _pawnIO.ExecuteHr("ioctl_unmap_superio_mmio", [], 0, [], 0, out uint returnSize);

            Log($"Unmap statusCode: {ntStatusCode}");

            return ntStatusCode == 0;
        }

        // ioctl_access_superio_mmio
        public bool GetOriginalState(out MMIOState state)
        {
            state = MMIOState.Unknown;
            long[] outArray = new long[1];
            int ntStatusCode = _pawnIO.ExecuteHr("ioctl_iomem_mmio_get_org_state", [], 0, outArray, 1, out uint returnSize);

            Log($"GetOriginalState statusCode: {ntStatusCode}");


            if (ntStatusCode != 0)
                return false;

            Log($"Original MMIO State: {(MMIOState)outArray[0]}");

            state = (MMIOState)outArray[0];
            return true;
        }

        public bool TryGetCurrentState(out MMIOState state)
        {
            state = MMIOState.Unknown;
            long[] outArray = new long[1];
            int ntStatusCode = _pawnIO.ExecuteHr("ioctl_iomem_mmio_get_cur_state", [], 0, outArray, 1, out uint returnSize);

            if (ntStatusCode != 0)
                return false;

            state = (MMIOState)outArray[0];
            return true;
        }

        public bool TrySetState(MMIOState state)
        {
            long[] inArray = new long[1];
            inArray[0] = (long)state;
            int ntStatusCode = _pawnIO.ExecuteHr("ioctl_iomem_mmio_set_state", inArray, 1, [], 0, out uint returnSize);

            Log($"TrySetState to {state} statusCode: {ntStatusCode}");

            if (ntStatusCode != 0)
                return false;

            return true;
        }

        public void Close() => _pawnIO.Close();

        /// <summary>
        /// Writes a debug message to both the output window and a log file when ISA_BRIDGE_EC_DEBUG is defined.
        /// </summary>
        /// <remarks>The log entry is timestamped and appended to the file
        /// 'PawnIo_IsaBridgeEc_DebugLog.txt' in the application's working directory. This method only produces output
        /// when compiled with the ISA_BRIDGE_EC_DEBUG symbol defined.</remarks>
        /// <param name="message">The message to log. This should provide relevant information for debugging purposes.</param>
        [Conditional("DEBUG_LOG"), Conditional("ISA_BRIDGE_EC_DEBUG")]
        private static void Log(string message)
        {
            Debug.WriteLine(message);
        }
    }
}

```

`LibreHardwareMonitorLib/PawnIo/LpcACPIEC.cs`:

```cs
namespace LibreHardwareMonitor.PawnIo;

public class LpcAcpiEc
{
    private readonly PawnIo _pawnIO = PawnIo. LoadModuleFromResource(typeof(AmdFamily0F).Assembly, $"{nameof(LibreHardwareMonitor)}.Resources.PawnIo.LpcACPIEC.bin");

    public byte ReadPort(byte port)
    {
        long[] inArray = new long[1];
        inArray[0] = port;
        long[] outArray = _pawnIO.Execute("ioctl_pio_read", inArray, 1);
        return (byte)outArray[0];
    }

    public void WritePort(byte port, byte value)
    {
        long[] inArray = new long[2];
        inArray[0] = port;
        inArray[1] = value;
        _pawnIO.Execute("ioctl_pio_write", inArray, 0);
    }

    public void Close() => _pawnIO.Close();
}

```

`LibreHardwareMonitorLib/PawnIo/LpcCrOS.cs`:

```cs
using System;

namespace LibreHardwareMonitor.PawnIo;

public class LpcCrOSEc
{
    private readonly PawnIo _pawnIO = PawnIo.LoadModuleFromResource(typeof(LpcCrOSEc).Assembly, $"{nameof(LibreHardwareMonitor)}.Resources.PawnIo.LpcCrOSEC.bin");

    public byte[] EcCommand(int version, int command, int outsize, int insize, byte[] data)
    {
        long[] inArray = new long[38];
        inArray[0] = version;
        inArray[1] = command;
        inArray[2] = outsize;
        inArray[3] = insize;

        // Start packing data into inArray at the 4th long (8 bytes)
        Buffer.BlockCopy(data, 0, inArray, 4 * 8, data.Length);

        long[] outArray = _pawnIO.Execute("ioctl_ec_command", inArray, 1 + (int)Math.Ceiling(insize / 8.0));
        if (outArray[0] < 0)
        {
            throw new Exception("EC returned error code " + -outArray[0]);
        }

        byte[] retArray = new byte[insize];
        // Unpack the data skipping the first long
        Buffer.BlockCopy(outArray, 8, retArray, 0, insize);
        return retArray;
    }

    public byte[] ReadMemmap(byte offset, byte bytes)
    {
        long[] inArray = [offset, bytes];
        long[] outArray = _pawnIO.Execute("ioctl_ec_readmem", inArray, (int)Math.Ceiling(bytes / 8.0));
        byte[] retArray = new byte[bytes];
        Buffer.BlockCopy(outArray, 0, retArray, 0, bytes);
        return retArray;
    }

    public void Close() => _pawnIO.Close();
}

```

`LibreHardwareMonitorLib/PawnIo/LpcIO.cs`:

```cs
namespace LibreHardwareMonitor.PawnIo;

internal class LpcIo
{
    private readonly long[] _doubleArgArray = new long[2];
    private readonly PawnIo _pawnIO = PawnIo.LoadModuleFromResource(typeof(LpcIo).Assembly, $"{nameof(LibreHardwareMonitor)}.Resources.PawnIo.LpcIO.bin");
    private readonly long[] _singleArgArray = new long[1];

    public void SelectSlot(int slot)
    {
        _singleArgArray[0] = slot;
        _pawnIO.Execute("ioctl_select_slot", _singleArgArray, 0);
    }

    public void FindBars()
    {
        _pawnIO.Execute("ioctl_find_bars", [], 0);
    }

    public byte ReadPort(ushort port)
    {
        _singleArgArray[0] = port;
        return (byte)_pawnIO.Execute("ioctl_pio_inb", _singleArgArray, 1)[0];
    }

    public void WritePort(ushort port, byte value)
    {
        _doubleArgArray[0] = port;
        _doubleArgArray[1] = value;
        _pawnIO.Execute("ioctl_pio_outb", _doubleArgArray, 0);
    }

    public byte ReadByte(byte register)
    {
        _singleArgArray[0] = register;
        return (byte)_pawnIO.Execute("ioctl_superio_inb", _singleArgArray, 1)[0];
    }

    public ushort ReadWord(byte register)
    {
        _singleArgArray[0] = register;
        return (ushort)_pawnIO.Execute("ioctl_superio_inw", _singleArgArray, 1)[0];
    }

    public void WriteByte(byte register, byte value)
    {
        _doubleArgArray[0] = register;
        _doubleArgArray[1] = value;
        _pawnIO.Execute("ioctl_superio_outb", _doubleArgArray, 0);
    }

    public void Close() => _pawnIO.Close();
}

```

`LibreHardwareMonitorLib/PawnIo/PawnIo.cs`:

```cs
using System;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using Microsoft.Win32;
using Microsoft.Win32.SafeHandles;
using Windows.Win32.Foundation;
using Windows.Win32.Storage.FileSystem;
using PInvoke = Windows.Win32.PInvoke;

namespace LibreHardwareMonitor.PawnIo;

public class PawnIo
{
    private const uint DEVICE_TYPE = 41394u << 16;
    private const int FN_NAME_LENGTH = 32;
    private const uint IOCTL_PIO_EXECUTE_FN = 0x841 << 2;
    private const uint IOCTL_PIO_LOAD_BINARY = 0x821 << 2;

    private readonly SafeFileHandle _handle;

    static PawnIo()
    {
        using RegistryKey subKey = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\PawnIO");

        if (Version.TryParse(subKey?.GetValue("DisplayVersion") as string, out Version version))
        {
            Version = version;
        }
        else
        {
            using RegistryKey registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, RegistryView.Registry64);

            using RegistryKey subKeyWow64 = registryKey.OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\PawnIO");

            if (Version.TryParse(subKeyWow64?.GetValue("DisplayVersion") as string, out version))
            {
                Version = version;
            }
        }
    }

    private PawnIo(SafeFileHandle handle) => _handle = handle;

    /// <summary>
    /// Gets a value indicating whether PawnIO is installed on the system.
    /// </summary>
    public static bool IsInstalled => Version is not null;

    /// <summary>
    /// Retrieves the version information for the installed PawnIO.
    /// </summary>
    public static Version Version { get; }

    /// <summary>
    /// Gets a value indicating whether the underlying handle is currently valid and open.
    /// </summary>
    public bool IsLoaded => _handle is
    {
        IsInvalid: false,
        IsClosed: false
    };

    internal static unsafe PawnIo LoadModuleFromResource(Assembly assembly, string resourceName)
    {
        SafeFileHandle handle = PInvoke.CreateFile(@"\\?\GLOBALROOT\Device\PawnIO",
                                                   (uint)FileAccess.ReadWrite,
                                                   FILE_SHARE_MODE.FILE_SHARE_READ | FILE_SHARE_MODE.FILE_SHARE_WRITE,
                                                   null,
                                                   FILE_CREATION_DISPOSITION.OPEN_EXISTING,
                                                   FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_NORMAL,
                                                   null);

        if (handle.IsInvalid)
            return new PawnIo(null);

        using Stream stream = assembly.GetManifestResourceStream(resourceName);
        using MemoryStream memory = new();
        stream.CopyTo(memory);
        byte[] bin = memory.ToArray();

        fixed (byte* pIn = bin)
        {
            if (PInvoke.DeviceIoControl((HANDLE)handle.DangerousGetHandle(), (uint)ControlCode.LoadBinary, pIn, (uint)bin.Length, null, 0u, null, null))
                return new PawnIo(handle);
        }

        return new PawnIo(null);
    }

    public void Close()
    {
        if (IsLoaded)
            _handle.Close();
    }

    public unsafe long[] Execute(string name, long[] input, int outLength)
    {
        if (IsLoaded)
        {
            byte[] output = new byte[outLength * sizeof(long)];
            byte[] totalInput = new byte[(input.Length * sizeof(long)) + FN_NAME_LENGTH];
            Buffer.BlockCopy(Encoding.ASCII.GetBytes(name), 0, totalInput, 0, Math.Min(FN_NAME_LENGTH - 1, name.Length));
            Buffer.BlockCopy(input, 0, totalInput, FN_NAME_LENGTH, input.Length * sizeof(long));

            uint read = 0;

            fixed (byte* pIn = totalInput, pOut = output)
            {
                if (PInvoke.DeviceIoControl((HANDLE)_handle.DangerousGetHandle(), (uint)ControlCode.Execute, pIn, (uint)totalInput.Length, pOut, (uint)output.Length, &read, null))
                {
                    long[] outp = new long[read / sizeof(long)];
                    Buffer.BlockCopy(output, 0, outp, 0, (int)read);
                    return outp;
                }
            }
        }

        return new long[outLength];
    }

    public unsafe int ExecuteHr(string name, long[] inBuffer, uint inSize, long[] outBuffer, uint outSize, out uint returnSize)
    {
        if (inBuffer.Length < inSize)
            throw new ArgumentOutOfRangeException(nameof(inSize));

        if (outBuffer.Length < outSize)
            throw new ArgumentOutOfRangeException(nameof(outSize));

        if (!IsLoaded)
        {
            returnSize = 0;
            return 0;
        }

        uint read = 0;

        byte[] output = new byte[outSize * sizeof(long)];
        byte[] totalInput = new byte[(inSize * sizeof(long)) + FN_NAME_LENGTH];
        Buffer.BlockCopy(Encoding.ASCII.GetBytes(name), 0, totalInput, 0, Math.Min(FN_NAME_LENGTH - 1, name.Length));
        Buffer.BlockCopy(inBuffer, 0, totalInput, FN_NAME_LENGTH, inBuffer.Length * sizeof(long));

        fixed (byte* pIn = totalInput, pOut = output)
        {
            if (PInvoke.DeviceIoControl((HANDLE)_handle.DangerousGetHandle(), (uint)ControlCode.Execute, pIn, (uint)totalInput.Length, pOut, (uint)output.Length, &read, null))
            {
                Buffer.BlockCopy(output, 0, outBuffer, 0, Math.Min((int)read, outBuffer.Length * sizeof(long)));
                returnSize = read / sizeof(long);
                return 0;
            }
        }

        returnSize = 0;
        return PInvoke.HRESULT_FROM_WIN32((WIN32_ERROR)Marshal.GetLastWin32Error());
    }

    private enum ControlCode : uint
    {
        LoadBinary = DEVICE_TYPE | IOCTL_PIO_LOAD_BINARY,
        Execute = DEVICE_TYPE | IOCTL_PIO_EXECUTE_FN
    }
}

```

`LibreHardwareMonitorLib/PawnIo/RyzenSmu.cs`:

```cs
using System;
using LibreHardwareMonitor.Hardware;

namespace LibreHardwareMonitor.PawnIo;

public class RyzenSmu
{
    private readonly PawnIo _pawnIO = PawnIo.LoadModuleFromResource(typeof(IntelMsr).Assembly, $"{nameof(LibreHardwareMonitor)}.Resources.PawnIo.RyzenSMU.bin");

    public uint GetSmuVersion()
    {
        if (!Mutexes.WaitPciBus(5000))
            throw new TimeoutException("Timeout waiting for PCI bus mutex");

        uint version;

        try
        {
            long[] outArray = _pawnIO.Execute("ioctl_get_smu_version", [], 1);
            version = (uint)outArray[0];
        }
        finally
        {
            Mutexes.ReleasePciBus();
        }

        return version;
    }

    public long GetCodeName()
    {
        long[] outArray = _pawnIO.Execute("ioctl_get_code_name", [], 1);
        return outArray[0];
    }

    public long[] ReadPmTable(int size)
    {
        if (!Mutexes.WaitPciBus(5000))
            throw new TimeoutException("Timeout waiting for PCI bus mutex");

        try
        {
            long[] outArray = _pawnIO.Execute("ioctl_read_pm_table", [], size);
            return outArray;
        }
        finally
        {
            Mutexes.ReleasePciBus();
        }
    }

    public void UpdatePmTable()
    {
        if (!Mutexes.WaitPciBus(5000))
            throw new TimeoutException("Timeout waiting for PCI bus mutex");

        try
        {
            _pawnIO.Execute("ioctl_update_pm_table", [], 0);
        }
        finally
        {
            Mutexes.ReleasePciBus();
        }
    }

    public void ResolvePmTable(out uint version, out uint tableBase)
    {
        if (!Mutexes.WaitPciBus(5000))
            throw new TimeoutException("Timeout waiting for PCI bus mutex");

        try
        {
            long[] outArray = _pawnIO.Execute("ioctl_resolve_pm_table", [], 2);
            version = (uint)outArray[0];
            tableBase = (uint)outArray[1];
        }
        finally
        {
            Mutexes.ReleasePciBus();
        }
    }

    public void Close() => _pawnIO.Close();
}

```

`LibreHardwareMonitorLib/RAMSPDToolkitDriver.cs`:

```cs
using System;
using System.Collections.Generic;
using RAMSPDToolkit.I2CSMBus.Interop.PawnIO;
using RAMSPDToolkit.Windows.Driver.Interfaces;

namespace LibreHardwareMonitor;

internal sealed class RAMSPDToolkitDriver : IPawnIODriver
{
    const string I801ModuleFilename = "SmbusI801.bin";
    const string Nct6793ModuleFilename = "SmbusNCT6793.bin";
    const string Piix4ModuleFilename = "SmbusPIIX4.bin";

    private readonly List<PawnIOModule> _pawnIOModules = new();

    public bool IsOpen => true;

    public bool Load()
    {
        //Not required
        return true;
    }

    public IPawnIOModule LoadModule(PawnIOSMBusIdentifier pawnIOSMBusIdentifier)
    {
        string moduleResourceFilename = pawnIOSMBusIdentifier switch
        {
            PawnIOSMBusIdentifier.I801 => I801ModuleFilename,
            PawnIOSMBusIdentifier.Piix4 => Piix4ModuleFilename,
            PawnIOSMBusIdentifier.NCT6793 => Nct6793ModuleFilename,
            _ => null
        };

        if (moduleResourceFilename == null)
        {
            return null;
        }

        PawnIOModule pawnIOModule = null;

        try
        {
            var pawnIO = PawnIo.PawnIo.LoadModuleFromResource(typeof(RAMSPDToolkitDriver).Assembly, $"{nameof(LibreHardwareMonitor)}.Resources.PawnIo.{moduleResourceFilename}");

            if (pawnIO.IsLoaded)
            {
                pawnIOModule = new PawnIOModule(pawnIO);
            }
        }
        catch
        {
            return null;
        }

        if (pawnIOModule != null)
        {
            _pawnIOModules.Add(pawnIOModule);
            return pawnIOModule;
        }

        return null;
    }

    public void Unload()
    {
        _pawnIOModules.ForEach(p => p.Dispose());
        _pawnIOModules.Clear();
    }

    internal class PawnIOModule : IPawnIOModule, IDisposable
    {
        private PawnIo.PawnIo _pawnIO;

        public PawnIOModule(PawnIo.PawnIo pawnIO)
        {
            _pawnIO = pawnIO;
        }

        public int Execute(string name, long[] inBuffer, uint inSize, long[] outBuffer, uint outSize, out uint returnSize)
            => _pawnIO.ExecuteHr(name, inBuffer, inSize, outBuffer, outSize, out returnSize);

        public void Dispose()
        {
            if (_pawnIO != null)
            {
                _pawnIO.Close();
                _pawnIO = null;
            }
        }
    }
}

```

`LibreHardwareMonitorLib/Resources/PawnIo/COPYING`:

```
                  GNU LESSER GENERAL PUBLIC LICENSE
                       Version 2.1, February 1999

 Copyright (C) 1991, 1999 Free Software Foundation, Inc.
 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

[This is the first released version of the Lesser GPL.  It also counts
 as the successor of the GNU Library Public License, version 2, hence
 the version number 2.1.]

                            Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
Licenses are intended to guarantee your freedom to share and change
free software--to make sure the software is free for all its users.

  This license, the Lesser General Public License, applies to some
specially designated software packages--typically libraries--of the
Free Software Foundation and other authors who decide to use it.  You
can use it too, but we suggest you first think carefully about whether
this license or the ordinary General Public License is the better
strategy to use in any particular case, based on the explanations below.

  When we speak of free software, we are referring to freedom of use,
not price.  Our General Public Licenses are designed to make sure that
you have the freedom to distribute copies of free software (and charge
for this service if you wish); that you receive source code or can get
it if you want it; that you can change the software and use pieces of
it in new free programs; and that you are informed that you can do
these things.

  To protect your rights, we need to make restrictions that forbid
distributors to deny you these rights or to ask you to surrender these
rights.  These restrictions translate to certain responsibilities for
you if you distribute copies of the library or if you modify it.

  For example, if you distribute copies of the library, whether gratis
or for a fee, you must give the recipients all the rights that we gave
you.  You must make sure that they, too, receive or can get the source
code.  If you link other code with the library, you must provide
complete object files to the recipients, so that they can relink them
with the library after making changes to the library and recompiling
it.  And you must show them these terms so they know their rights.

  We protect your rights with a two-step method: (1) we copyright the
library, and (2) we offer you this license, which gives you legal
permission to copy, distribute and/or modify the library.

  To protect each distributor, we want to make it very clear that
there is no warranty for the free library.  Also, if the library is
modified by someone else and passed on, the recipients should know
that what they have is not the original version, so that the original
author's reputation will not be affected by problems that might be
introduced by others.

  Finally, software patents pose a constant threat to the existence of
any free program.  We wish to make sure that a company cannot
effectively restrict the users of a free program by obtaining a
restrictive license from a patent holder.  Therefore, we insist that
any patent license obtained for a version of the library must be
consistent with the full freedom of use specified in this license.

  Most GNU software, including some libraries, is covered by the
ordinary GNU General Public License.  This license, the GNU Lesser
General Public License, applies to certain designated libraries, and
is quite different from the ordinary General Public License.  We use
this license for certain libraries in order to permit linking those
libraries into non-free programs.

  When a program is linked with a library, whether statically or using
a shared library, the combination of the two is legally speaking a
combined work, a derivative of the original library.  The ordinary
General Public License therefore permits such linking only if the
entire combination fits its criteria of freedom.  The Lesser General
Public License permits more lax criteria for linking other code with
the library.

  We call this license the "Lesser" General Public License because it
does Less to protect the user's freedom than the ordinary General
Public License.  It also provides other free software developers Less
of an advantage over competing non-free programs.  These disadvantages
are the reason we use the ordinary General Public License for many
libraries.  However, the Lesser license provides advantages in certain
special circumstances.

  For example, on rare occasions, there may be a special need to
encourage the widest possible use of a certain library, so that it becomes
a de-facto standard.  To achieve this, non-free programs must be
allowed to use the library.  A more frequent case is that a free
library does the same job as widely used non-free libraries.  In this
case, there is little to gain by limiting the free library to free
software only, so we use the Lesser General Public License.

  In other cases, permission to use a particular library in non-free
programs enables a greater number of people to use a large body of
free software.  For example, permission to use the GNU C Library in
non-free programs enables many more people to use the whole GNU
operating system, as well as its variant, the GNU/Linux operating
system.

  Although the Lesser General Public License is Less protective of the
users' freedom, it does ensure that the user of a program that is
linked with the Library has the freedom and the wherewithal to run
that program using a modified version of the Library.

  The precise terms and conditions for copying, distribution and
modification follow.  Pay close attention to the difference between a
"work based on the library" and a "work that uses the library".  The
former contains code derived from the library, whereas the latter must
be combined with the library in order to run.

                  GNU LESSER GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License Agreement applies to any software library or other
program which contains a notice placed by the copyright holder or
other authorized party saying it may be distributed under the terms of
this Lesser General Public License (also called "this License").
Each licensee is addressed as "you".

  A "library" means a collection of software functions and/or data
prepared so as to be conveniently linked with application programs
(which use some of those functions and data) to form executables.

  The "Library", below, refers to any such software library or work
which has been distributed under these terms.  A "work based on the
Library" means either the Library or any derivative work under
copyright law: that is to say, a work containing the Library or a
portion of it, either verbatim or with modifications and/or translated
straightforwardly into another language.  (Hereinafter, translation is
included without limitation in the term "modification".)

  "Source code" for a work means the preferred form of the work for
making modifications to it.  For a library, complete source code means
all the source code for all modules it contains, plus any associated
interface definition files, plus the scripts used to control compilation
and installation of the library.

  Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running a program using the Library is not restricted, and output from
such a program is covered only if its contents constitute a work based
on the Library (independent of the use of the Library in a tool for
writing it).  Whether that is true depends on what the Library does
and what the program that uses the Library does.

  1. You may copy and distribute verbatim copies of the Library's
complete source code as you receive it, in any medium, provided that
you conspicuously and appropriately publish on each copy an
appropriate copyright notice and disclaimer of warranty; keep intact
all the notices that refer to this License and to the absence of any
warranty; and distribute a copy of this License along with the
Library.

  You may charge a fee for the physical act of transferring a copy,
and you may at your option offer warranty protection in exchange for a
fee.

  2. You may modify your copy or copies of the Library or any portion
of it, thus forming a work based on the Library, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) The modified work must itself be a software library.

    b) You must cause the files modified to carry prominent notices
    stating that you changed the files and the date of any change.

    c) You must cause the whole of the work to be licensed at no
    charge to all third parties under the terms of this License.

    d) If a facility in the modified Library refers to a function or a
    table of data to be supplied by an application program that uses
    the facility, other than as an argument passed when the facility
    is invoked, then you must make a good faith effort to ensure that,
    in the event an application does not supply such function or
    table, the facility still operates, and performs whatever part of
    its purpose remains meaningful.

    (For example, a function in a library to compute square roots has
    a purpose that is entirely well-defined independent of the
    application.  Therefore, Subsection 2d requires that any
    application-supplied function or table used by this function must
    be optional: if the application does not supply it, the square
    root function must still compute square roots.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Library,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Library, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote
it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Library.

In addition, mere aggregation of another work not based on the Library
with the Library (or with a work based on the Library) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may opt to apply the terms of the ordinary GNU General Public
License instead of this License to a given copy of the Library.  To do
this, you must alter all the notices that refer to this License, so
that they refer to the ordinary GNU General Public License, version 2,
instead of to this License.  (If a newer version than version 2 of the
ordinary GNU General Public License has appeared, then you can specify
that version instead if you wish.)  Do not make any other change in
these notices.

  Once this change is made in a given copy, it is irreversible for
that copy, so the ordinary GNU General Public License applies to all
subsequent copies and derivative works made from that copy.

  This option is useful when you wish to copy part of the code of
the Library into a program that is not a library.

  4. You may copy and distribute the Library (or a portion or
derivative of it, under Section 2) in object code or executable form
under the terms of Sections 1 and 2 above provided that you accompany
it with the complete corresponding machine-readable source code, which
must be distributed under the terms of Sections 1 and 2 above on a
medium customarily used for software interchange.

  If distribution of object code is made by offering access to copy
from a designated place, then offering equivalent access to copy the
source code from the same place satisfies the requirement to
distribute the source code, even though third parties are not
compelled to copy the source along with the object code.

  5. A program that contains no derivative of any portion of the
Library, but is designed to work with the Library by being compiled or
linked with it, is called a "work that uses the Library".  Such a
work, in isolation, is not a derivative work of the Library, and
therefore falls outside the scope of this License.

  However, linking a "work that uses the Library" with the Library
creates an executable that is a derivative of the Library (because it
contains portions of the Library), rather than a "work that uses the
library".  The executable is therefore covered by this License.
Section 6 states terms for distribution of such executables.

  When a "work that uses the Library" uses material from a header file
that is part of the Library, the object code for the work may be a
derivative work of the Library even though the source code is not.
Whether this is true is especially significant if the work can be
linked without the Library, or if the work is itself a library.  The
threshold for this to be true is not precisely defined by law.

  If such an object file uses only numerical parameters, data
structure layouts and accessors, and small macros and small inline
functions (ten lines or less in length), then the use of the object
file is unrestricted, regardless of whether it is legally a derivative
work.  (Executables containing this object code plus portions of the
Library will still fall under Section 6.)

  Otherwise, if the work is a derivative of the Library, you may
distribute the object code for the work under the terms of Section 6.
Any executables containing that work also fall under Section 6,
whether or not they are linked directly with the Library itself.

  6. As an exception to the Sections above, you may also combine or
link a "work that uses the Library" with the Library to produce a
work containing portions of the Library, and distribute that work
under terms of your choice, provided that the terms permit
modification of the work for the customer's own use and reverse
engineering for debugging such modifications.

  You must give prominent notice with each copy of the work that the
Library is used in it and that the Library and its use are covered by
this License.  You must supply a copy of this License.  If the work
during execution displays copyright notices, you must include the
copyright notice for the Library among them, as well as a reference
directing the user to the copy of this License.  Also, you must do one
of these things:

    a) Accompany the work with the complete corresponding
    machine-readable source code for the Library including whatever
    changes were used in the work (which must be distributed under
    Sections 1 and 2 above); and, if the work is an executable linked
    with the Library, with the complete machine-readable "work that
    uses the Library", as object code and/or source code, so that the
    user can modify the Library and then relink to produce a modified
    executable containing the modified Library.  (It is understood
    that the user who changes the contents of definitions files in the
    Library will not necessarily be able to recompile the application
    to use the modified definitions.)

    b) Use a suitable shared library mechanism for linking with the
    Library.  A suitable mechanism is one that (1) uses at run time a
    copy of the library already present on the user's computer system,
    rather than copying library functions into the executable, and (2)
    will operate properly with a modified version of the library, if
    the user installs one, as long as the modified version is
    interface-compatible with the version that the work was made with.

    c) Accompany the work with a written offer, valid for at
    least three years, to give the same user the materials
    specified in Subsection 6a, above, for a charge no more
    than the cost of performing this distribution.

    d) If distribution of the work is made by offering access to copy
    from a designated place, offer equivalent access to copy the above
    specified materials from the same place.

    e) Verify that the user has already received a copy of these
    materials or that you have already sent this user a copy.

  For an executable, the required form of the "work that uses the
Library" must include any data and utility programs needed for
reproducing the executable from it.  However, as a special exception,
the materials to be distributed need not include anything that is
normally distributed (in either source or binary form) with the major
components (compiler, kernel, and so on) of the operating system on
which the executable runs, unless that component itself accompanies
the executable.

  It may happen that this requirement contradicts the license
restrictions of other proprietary libraries that do not normally
accompany the operating system.  Such a contradiction means you cannot
use both them and the Library together in an executable that you
distribute.

  7. You may place library facilities that are a work based on the
Library side-by-side in a single library together with other library
facilities not covered by this License, and distribute such a combined
library, provided that the separate distribution of the work based on
the Library and of the other library facilities is otherwise
permitted, and provided that you do these two things:

    a) Accompany the combined library with a copy of the same work
    based on the Library, uncombined with any other library
    facilities.  This must be distributed under the terms of the
    Sections above.

    b) Give prominent notice with the combined library of the fact
    that part of it is a work based on the Library, and explaining
    where to find the accompanying uncombined form of the same work.

  8. You may not copy, modify, sublicense, link with, or distribute
the Library except as expressly provided under this License.  Any
attempt otherwise to copy, modify, sublicense, link with, or
distribute the Library is void, and will automatically terminate your
rights under this License.  However, parties who have received copies,
or rights, from you under this License will not have their licenses
terminated so long as such parties remain in full compliance.

  9. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Library or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Library (or any work based on the
Library), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Library or works based on it.

  10. Each time you redistribute the Library (or any work based on the
Library), the recipient automatically receives a license from the
original licensor to copy, distribute, link with or modify the Library
subject to these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties with
this License.

  11. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Library at all.  For example, if a patent
license would not permit royalty-free redistribution of the Library by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Library.

If any portion of this section is held invalid or unenforceable under any
particular circumstance, the balance of the section is intended to apply,
and the section as a whole is intended to apply in other circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  12. If the distribution and/or use of the Library is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Library under this License may add
an explicit geographical distribution limitation excluding those countries,
so that distribution is permitted only in or among countries not thus
excluded.  In such case, this License incorporates the limitation as if
written in the body of this License.

  13. The Free Software Foundation may publish revised and/or new
versions of the Lesser General Public License from time to time.
Such new versions will be similar in spirit to the present version,
but may differ in detail to address new problems or concerns.

Each version is given a distinguishing version number.  If the Library
specifies a version number of this License which applies to it and
"any later version", you have the option of following the terms and
conditions either of that version or of any later version published by
the Free Software Foundation.  If the Library does not specify a
license version number, you may choose any version ever published by
the Free Software Foundation.

  14. If you wish to incorporate parts of the Library into other free
programs whose distribution conditions are incompatible with these,
write to the author to ask for permission.  For software which is
copyrighted by the Free Software Foundation, write to the Free
Software Foundation; we sometimes make exceptions for this.  Our
decision will be guided by the two goals of preserving the free status
of all derivatives of our free software and of promoting the sharing
and reuse of software generally.

                            NO WARRANTY

  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGES.

                     END OF TERMS AND CONDITIONS

           How to Apply These Terms to Your New Libraries

  If you develop a new library, and you want it to be of the greatest
possible use to the public, we recommend making it free software that
everyone can redistribute and change.  You can do so by permitting
redistribution under these terms (or, alternatively, under the terms of the
ordinary General Public License).

  To apply these terms, attach the following notices to the library.  It is
safest to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least the
"copyright" line and a pointer to where the full notice is found.

    <one line to give the library's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

Also add information on how to contact you by electronic and paper mail.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the library, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the
  library `Frob' (a library for tweaking knobs) written by James Random Hacker.

  <signature of Ty Coon>, 1 April 1990
  Ty Coon, President of Vice

That's all there is to it!

```

`LibreHardwareMonitorLib/Resources/PawnIo/README`:

```
Signed PawnIO modules from the official repository, belonging to the 0.1.6 release:

https://github.com/namazso/PawnIO.Modules/releases/tag/0.1.6

```

`LibreHardwareMonitorLib/Software/OperatingSystem.cs`:

```cs
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Copyright (C) LibreHardwareMonitor and Contributors.
// Partial Copyright (C) Michael Möller <mmoeller@openhardwaremonitor.org> and Contributors.
// All Rights Reserved.

using System;

namespace LibreHardwareMonitor.Software;

/// <summary>
/// Contains basic information about the operating system.
/// </summary>
public static class OperatingSystem
{
    /// <summary>
    /// Statically checks if the current system <see cref="Is64Bit"/> and <see cref="IsUnix"/>.
    /// </summary>
    static OperatingSystem()
    {
        // The operating system doesn't change during execution so let's query it just one time.
        PlatformID platform = Environment.OSVersion.Platform;
        Version version = Environment.OSVersion.Version;
        IsUnix = platform is PlatformID.Unix or PlatformID.MacOSX;

        if (Environment.Is64BitOperatingSystem)
            Is64Bit = true;

        IsWindows8OrGreater = !IsUnix && ((version.Major == 6 && version.Minor >= 2) || version.Major > 6);
    }

    /// <summary>
    /// Gets information about whether the current system is 64 bit.
    /// </summary>
    public static bool Is64Bit { get; }

    /// <summary>
    /// Gets information about whether the current system is Unix based.
    /// </summary>
    public static bool IsUnix { get; }

    /// <summary>
    /// Returns true if the current system is Windows 8 or a more recent Windows version
    /// </summary>
    public static bool IsWindows8OrGreater { get; }
}

```

`LibreHardwareMonitorLib/main.nuget.target`:

```target
<!-- For packing the multi-platform nuget after building x64, x86, ARM64 and reference libs -->
<Project>
  <PropertyGroup>
    <IncludeBuildOutput>false</IncludeBuildOutput>
    <NoWarn>$(NoWarn);NU5131</NoWarn>
  </PropertyGroup>
  <ItemGroup>
    <None Include="..\bin\$(Configuration)\x64\**\LibreHardwareMonitorLib.dll" Pack="true">
      <PackagePath>runtimes\win-x64\lib\</PackagePath>
    </None>
    <None Include="..\bin\$(Configuration)\x64\**\LibreHardwareMonitorLib.xml" Pack="true">
      <PackagePath>runtimes\win-x64\lib\</PackagePath>
    </None>
    <None Include="..\bin\$(Configuration)\x86\**\LibreHardwareMonitorLib.dll" Pack="true">
      <PackagePath>runtimes\win-x86\lib\</PackagePath>
    </None>
    <None Include="..\bin\$(Configuration)\x86\**\LibreHardwareMonitorLib.xml" Pack="true">
      <PackagePath>runtimes\win-x86\lib\</PackagePath>
    </None>
    <None Include="..\bin\$(Configuration)\ARM64\**\LibreHardwareMonitorLib.dll" Pack="true">
      <PackagePath>runtimes\win-arm64\lib\</PackagePath>
    </None>
    <None Include="..\bin\$(Configuration)\ARM64\**\LibreHardwareMonitorLib.xml" Pack="true">
      <PackagePath>runtimes\win-arm64\lib\</PackagePath>
    </None>
    <None Include="..\bin\$(Configuration)\AnyCPU\**\LibreHardwareMonitorLib.dll" Pack="true">
      <PackagePath>ref\</PackagePath>
    </None>
    <None Include="..\bin\$(Configuration)\AnyCPU\**\LibreHardwareMonitorLib.xml" Pack="true">
      <PackagePath>ref\</PackagePath>
    </None>
  </ItemGroup>
</Project>
```

`README.md`:

```md
# LibreHardwareMonitor
[![GitHub license](https://img.shields.io/github/license/LibreHardwareMonitor/LibreHardwareMonitor)](https://github.com/LibreHardwareMonitor/LibreHardwareMonitor/blob/master/LICENSE) [![Nuget](https://img.shields.io/nuget/v/LibreHardwareMonitorLib)](https://www.nuget.org/packages/LibreHardwareMonitorLib/) [![Nuget (with prereleases)](https://img.shields.io/nuget/vpre/LibreHardwareMonitorLib?label=nuget-pre)](https://www.nuget.org/packages/LibreHardwareMonitorLib/) [![Nuget](https://img.shields.io/nuget/dt/LibreHardwareMonitorLib?label=nuget-downloads)](https://www.nuget.org/packages/LibreHardwareMonitorLib/)

Libre Hardware Monitor is free software that can monitor the temperature sensors, fan speeds, voltages, load and clock speeds of your computer. 

## What's included?
| Name| .NET | Build Status |
| --- | --- | --- | 
| **LibreHardwareMonitor** <br /> Windows Forms based application that presents all data in a graphical interface | .NET Framework 4.7.2 <br/> .NET 10.0 | [![Build status](https://github.com/LibreHardwareMonitor/LibreHardwareMonitor/actions/workflows/master.yml/badge.svg)](https://github.com/LibreHardwareMonitor/LibreHardwareMonitor/actions) | 
| **LibreHardwareMonitorLib** <br /> Library that allows you to use all features in your own application | .NET Framework 4.7.2 <br/> .NET Standard 2.0 <br/> .NET 8.0, .NET 9.0, and .NET 10.0 | [![Build status](https://github.com/LibreHardwareMonitor/LibreHardwareMonitor/actions/workflows/master.yml/badge.svg)](https://github.com/LibreHardwareMonitor/LibreHardwareMonitor/actions) | 

## What can it do?
You can read information from devices such as:
- Motherboards
- Intel and AMD processors
- NVIDIA, AMD and Intel graphics cards
- HDD, SSD and NVMe hard drives
- Network cards

## Where can I download it?
You can download the latest release [here](https://github.com/LibreHardwareMonitor/LibreHardwareMonitor/releases). You can also install it using WinGet:

```
winget install LibreHardwareMonitor.LibreHardwareMonitor
```

### Nightly builds
If you have a **GitHub** account, you can download nightly builds [here](https://github.com/LibreHardwareMonitor/LibreHardwareMonitor/actions). Otherwise, you can download the *latest* nightly build [here](https://nightly.link/LibreHardwareMonitor/LibreHardwareMonitor/workflows/master/master/LibreHardwareMonitor.zip).

## How can I help improve it?
The LibreHardwareMonitor team welcomes feedback and contributions!<br/>
You can check if it works properly on your motherboard. For many manufacturers, the way of reading data differs a bit, so if you notice any inaccuracies, please send us a pull request. If you have any suggestions or improvements, don't hesitate to create an issue.

## Developer information
**Integrate the library in own application**
1. Add the [LibreHardwareMonitorLib](https://www.nuget.org/packages/LibreHardwareMonitorLib/) NuGet package to your application.
2. Use the sample code below.


**Sample code**
```c#
public class UpdateVisitor : IVisitor
{
    public void VisitComputer(IComputer computer)
    {
        computer.Traverse(this);
    }
    public void VisitHardware(IHardware hardware)
    {
        hardware.Update();
        foreach (IHardware subHardware in hardware.SubHardware) subHardware.Accept(this);
    }
    public void VisitSensor(ISensor sensor) { }
    public void VisitParameter(IParameter parameter) { }
}

public void Monitor()
{
    Computer computer = new Computer
    {
        IsCpuEnabled = true,
        IsGpuEnabled = true,
        IsMemoryEnabled = true,
        IsMotherboardEnabled = true,
        IsControllerEnabled = true,
        IsNetworkEnabled = true,
        IsStorageEnabled = true
    };

    computer.Open();
    computer.Accept(new UpdateVisitor());

    foreach (IHardware hardware in computer.Hardware)
    {
        Console.WriteLine("Hardware: {0}", hardware.Name);
        
        foreach (IHardware subhardware in hardware.SubHardware)
        {
            Console.WriteLine("\tSubhardware: {0}", subhardware.Name);
            
            foreach (ISensor sensor in subhardware.Sensors)
            {
                Console.WriteLine("\t\tSensor: {0}, value: {1}", sensor.Name, sensor.Value);
            }
        }

        foreach (ISensor sensor in hardware.Sensors)
        {
            Console.WriteLine("\tSensor: {0}, value: {1}", sensor.Name, sensor.Value);
        }
    }
    
    computer.Close();
}
```

**Administrator rights**

Some sensors require administrator privileges to access the data. Restart your IDE with admin privileges, or add an [app.manifest](https://learn.microsoft.com/en-us/windows/win32/sbscs/application-manifests) file to your project with requestedExecutionLevel on requireAdministrator.


## License
LibreHardwareMonitor is free and open source software licensed under MPL 2.0. Some parts of LibreHardwareMonitor are licensed under different terms, see [THIRD-PARTY-LICENSES](https://github.com/LibreHardwareMonitor/LibreHardwareMonitor/blob/master/THIRD-PARTY-NOTICES.txt).

```

`THIRD-PARTY-NOTICES.txt`:

```txt
License notice for Aga.Controls
-------------------------------

The BSD License

Copyright (c) 2009, Andrey Gliznetsov (a.gliznetsov@gmail.com)

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided 
that the following conditions are met

- Redistributions of source code must retain the above copyright notice, this list of conditions 
and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright notice, this list of conditions 
and the following disclaimer in the documentation andor other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


License notice for PawnIO.Modules
---------------------------------

                  GNU LESSER GENERAL PUBLIC LICENSE
                       Version 2.1, February 1999

 Copyright (C) 1991, 1999 Free Software Foundation, Inc.
 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

[This is the first released version of the Lesser GPL.  It also counts
 as the successor of the GNU Library Public License, version 2, hence
 the version number 2.1.]

                            Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
Licenses are intended to guarantee your freedom to share and change
free software--to make sure the software is free for all its users.

  This license, the Lesser General Public License, applies to some
specially designated software packages--typically libraries--of the
Free Software Foundation and other authors who decide to use it.  You
can use it too, but we suggest you first think carefully about whether
this license or the ordinary General Public License is the better
strategy to use in any particular case, based on the explanations below.

  When we speak of free software, we are referring to freedom of use,
not price.  Our General Public Licenses are designed to make sure that
you have the freedom to distribute copies of free software (and charge
for this service if you wish); that you receive source code or can get
it if you want it; that you can change the software and use pieces of
it in new free programs; and that you are informed that you can do
these things.

  To protect your rights, we need to make restrictions that forbid
distributors to deny you these rights or to ask you to surrender these
rights.  These restrictions translate to certain responsibilities for
you if you distribute copies of the library or if you modify it.

  For example, if you distribute copies of the library, whether gratis
or for a fee, you must give the recipients all the rights that we gave
you.  You must make sure that they, too, receive or can get the source
code.  If you link other code with the library, you must provide
complete object files to the recipients, so that they can relink them
with the library after making changes to the library and recompiling
it.  And you must show them these terms so they know their rights.

  We protect your rights with a two-step method: (1) we copyright the
library, and (2) we offer you this license, which gives you legal
permission to copy, distribute and/or modify the library.

  To protect each distributor, we want to make it very clear that
there is no warranty for the free library.  Also, if the library is
modified by someone else and passed on, the recipients should know
that what they have is not the original version, so that the original
author's reputation will not be affected by problems that might be
introduced by others.

  Finally, software patents pose a constant threat to the existence of
any free program.  We wish to make sure that a company cannot
effectively restrict the users of a free program by obtaining a
restrictive license from a patent holder.  Therefore, we insist that
any patent license obtained for a version of the library must be
consistent with the full freedom of use specified in this license.

  Most GNU software, including some libraries, is covered by the
ordinary GNU General Public License.  This license, the GNU Lesser
General Public License, applies to certain designated libraries, and
is quite different from the ordinary General Public License.  We use
this license for certain libraries in order to permit linking those
libraries into non-free programs.

  When a program is linked with a library, whether statically or using
a shared library, the combination of the two is legally speaking a
combined work, a derivative of the original library.  The ordinary
General Public License therefore permits such linking only if the
entire combination fits its criteria of freedom.  The Lesser General
Public License permits more lax criteria for linking other code with
the library.

  We call this license the "Lesser" General Public License because it
does Less to protect the user's freedom than the ordinary General
Public License.  It also provides other free software developers Less
of an advantage over competing non-free programs.  These disadvantages
are the reason we use the ordinary General Public License for many
libraries.  However, the Lesser license provides advantages in certain
special circumstances.

  For example, on rare occasions, there may be a special need to
encourage the widest possible use of a certain library, so that it becomes
a de-facto standard.  To achieve this, non-free programs must be
allowed to use the library.  A more frequent case is that a free
library does the same job as widely used non-free libraries.  In this
case, there is little to gain by limiting the free library to free
software only, so we use the Lesser General Public License.

  In other cases, permission to use a particular library in non-free
programs enables a greater number of people to use a large body of
free software.  For example, permission to use the GNU C Library in
non-free programs enables many more people to use the whole GNU
operating system, as well as its variant, the GNU/Linux operating
system.

  Although the Lesser General Public License is Less protective of the
users' freedom, it does ensure that the user of a program that is
linked with the Library has the freedom and the wherewithal to run
that program using a modified version of the Library.

  The precise terms and conditions for copying, distribution and
modification follow.  Pay close attention to the difference between a
"work based on the library" and a "work that uses the library".  The
former contains code derived from the library, whereas the latter must
be combined with the library in order to run.

                  GNU LESSER GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License Agreement applies to any software library or other
program which contains a notice placed by the copyright holder or
other authorized party saying it may be distributed under the terms of
this Lesser General Public License (also called "this License").
Each licensee is addressed as "you".

  A "library" means a collection of software functions and/or data
prepared so as to be conveniently linked with application programs
(which use some of those functions and data) to form executables.

  The "Library", below, refers to any such software library or work
which has been distributed under these terms.  A "work based on the
Library" means either the Library or any derivative work under
copyright law: that is to say, a work containing the Library or a
portion of it, either verbatim or with modifications and/or translated
straightforwardly into another language.  (Hereinafter, translation is
included without limitation in the term "modification".)

  "Source code" for a work means the preferred form of the work for
making modifications to it.  For a library, complete source code means
all the source code for all modules it contains, plus any associated
interface definition files, plus the scripts used to control compilation
and installation of the library.

  Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running a program using the Library is not restricted, and output from
such a program is covered only if its contents constitute a work based
on the Library (independent of the use of the Library in a tool for
writing it).  Whether that is true depends on what the Library does
and what the program that uses the Library does.

  1. You may copy and distribute verbatim copies of the Library's
complete source code as you receive it, in any medium, provided that
you conspicuously and appropriately publish on each copy an
appropriate copyright notice and disclaimer of warranty; keep intact
all the notices that refer to this License and to the absence of any
warranty; and distribute a copy of this License along with the
Library.

  You may charge a fee for the physical act of transferring a copy,
and you may at your option offer warranty protection in exchange for a
fee.

  2. You may modify your copy or copies of the Library or any portion
of it, thus forming a work based on the Library, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) The modified work must itself be a software library.

    b) You must cause the files modified to carry prominent notices
    stating that you changed the files and the date of any change.

    c) You must cause the whole of the work to be licensed at no
    charge to all third parties under the terms of this License.

    d) If a facility in the modified Library refers to a function or a
    table of data to be supplied by an application program that uses
    the facility, other than as an argument passed when the facility
    is invoked, then you must make a good faith effort to ensure that,
    in the event an application does not supply such function or
    table, the facility still operates, and performs whatever part of
    its purpose remains meaningful.

    (For example, a function in a library to compute square roots has
    a purpose that is entirely well-defined independent of the
    application.  Therefore, Subsection 2d requires that any
    application-supplied function or table used by this function must
    be optional: if the application does not supply it, the square
    root function must still compute square roots.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Library,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Library, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote
it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Library.

In addition, mere aggregation of another work not based on the Library
with the Library (or with a work based on the Library) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may opt to apply the terms of the ordinary GNU General Public
License instead of this License to a given copy of the Library.  To do
this, you must alter all the notices that refer to this License, so
that they refer to the ordinary GNU General Public License, version 2,
instead of to this License.  (If a newer version than version 2 of the
ordinary GNU General Public License has appeared, then you can specify
that version instead if you wish.)  Do not make any other change in
these notices.

  Once this change is made in a given copy, it is irreversible for
that copy, so the ordinary GNU General Public License applies to all
subsequent copies and derivative works made from that copy.

  This option is useful when you wish to copy part of the code of
the Library into a program that is not a library.

  4. You may copy and distribute the Library (or a portion or
derivative of it, under Section 2) in object code or executable form
under the terms of Sections 1 and 2 above provided that you accompany
it with the complete corresponding machine-readable source code, which
must be distributed under the terms of Sections 1 and 2 above on a
medium customarily used for software interchange.

  If distribution of object code is made by offering access to copy
from a designated place, then offering equivalent access to copy the
source code from the same place satisfies the requirement to
distribute the source code, even though third parties are not
compelled to copy the source along with the object code.

  5. A program that contains no derivative of any portion of the
Library, but is designed to work with the Library by being compiled or
linked with it, is called a "work that uses the Library".  Such a
work, in isolation, is not a derivative work of the Library, and
therefore falls outside the scope of this License.

  However, linking a "work that uses the Library" with the Library
creates an executable that is a derivative of the Library (because it
contains portions of the Library), rather than a "work that uses the
library".  The executable is therefore covered by this License.
Section 6 states terms for distribution of such executables.

  When a "work that uses the Library" uses material from a header file
that is part of the Library, the object code for the work may be a
derivative work of the Library even though the source code is not.
Whether this is true is especially significant if the work can be
linked without the Library, or if the work is itself a library.  The
threshold for this to be true is not precisely defined by law.

  If such an object file uses only numerical parameters, data
structure layouts and accessors, and small macros and small inline
functions (ten lines or less in length), then the use of the object
file is unrestricted, regardless of whether it is legally a derivative
work.  (Executables containing this object code plus portions of the
Library will still fall under Section 6.)

  Otherwise, if the work is a derivative of the Library, you may
distribute the object code for the work under the terms of Section 6.
Any executables containing that work also fall under Section 6,
whether or not they are linked directly with the Library itself.

  6. As an exception to the Sections above, you may also combine or
link a "work that uses the Library" with the Library to produce a
work containing portions of the Library, and distribute that work
under terms of your choice, provided that the terms permit
modification of the work for the customer's own use and reverse
engineering for debugging such modifications.

  You must give prominent notice with each copy of the work that the
Library is used in it and that the Library and its use are covered by
this License.  You must supply a copy of this License.  If the work
during execution displays copyright notices, you must include the
copyright notice for the Library among them, as well as a reference
directing the user to the copy of this License.  Also, you must do one
of these things:

    a) Accompany the work with the complete corresponding
    machine-readable source code for the Library including whatever
    changes were used in the work (which must be distributed under
    Sections 1 and 2 above); and, if the work is an executable linked
    with the Library, with the complete machine-readable "work that
    uses the Library", as object code and/or source code, so that the
    user can modify the Library and then relink to produce a modified
    executable containing the modified Library.  (It is understood
    that the user who changes the contents of definitions files in the
    Library will not necessarily be able to recompile the application
    to use the modified definitions.)

    b) Use a suitable shared library mechanism for linking with the
    Library.  A suitable mechanism is one that (1) uses at run time a
    copy of the library already present on the user's computer system,
    rather than copying library functions into the executable, and (2)
    will operate properly with a modified version of the library, if
    the user installs one, as long as the modified version is
    interface-compatible with the version that the work was made with.

    c) Accompany the work with a written offer, valid for at
    least three years, to give the same user the materials
    specified in Subsection 6a, above, for a charge no more
    than the cost of performing this distribution.

    d) If distribution of the work is made by offering access to copy
    from a designated place, offer equivalent access to copy the above
    specified materials from the same place.

    e) Verify that the user has already received a copy of these
    materials or that you have already sent this user a copy.

  For an executable, the required form of the "work that uses the
Library" must include any data and utility programs needed for
reproducing the executable from it.  However, as a special exception,
the materials to be distributed need not include anything that is
normally distributed (in either source or binary form) with the major
components (compiler, kernel, and so on) of the operating system on
which the executable runs, unless that component itself accompanies
the executable.

  It may happen that this requirement contradicts the license
restrictions of other proprietary libraries that do not normally
accompany the operating system.  Such a contradiction means you cannot
use both them and the Library together in an executable that you
distribute.

  7. You may place library facilities that are a work based on the
Library side-by-side in a single library together with other library
facilities not covered by this License, and distribute such a combined
library, provided that the separate distribution of the work based on
the Library and of the other library facilities is otherwise
permitted, and provided that you do these two things:

    a) Accompany the combined library with a copy of the same work
    based on the Library, uncombined with any other library
    facilities.  This must be distributed under the terms of the
    Sections above.

    b) Give prominent notice with the combined library of the fact
    that part of it is a work based on the Library, and explaining
    where to find the accompanying uncombined form of the same work.

  8. You may not copy, modify, sublicense, link with, or distribute
the Library except as expressly provided under this License.  Any
attempt otherwise to copy, modify, sublicense, link with, or
distribute the Library is void, and will automatically terminate your
rights under this License.  However, parties who have received copies,
or rights, from you under this License will not have their licenses
terminated so long as such parties remain in full compliance.

  9. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Library or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Library (or any work based on the
Library), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Library or works based on it.

  10. Each time you redistribute the Library (or any work based on the
Library), the recipient automatically receives a license from the
original licensor to copy, distribute, link with or modify the Library
subject to these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties with
this License.

  11. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Library at all.  For example, if a patent
license would not permit royalty-free redistribution of the Library by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Library.

If any portion of this section is held invalid or unenforceable under any
particular circumstance, the balance of the section is intended to apply,
and the section as a whole is intended to apply in other circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  12. If the distribution and/or use of the Library is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Library under this License may add
an explicit geographical distribution limitation excluding those countries,
so that distribution is permitted only in or among countries not thus
excluded.  In such case, this License incorporates the limitation as if
written in the body of this License.

  13. The Free Software Foundation may publish revised and/or new
versions of the Lesser General Public License from time to time.
Such new versions will be similar in spirit to the present version,
but may differ in detail to address new problems or concerns.

Each version is given a distinguishing version number.  If the Library
specifies a version number of this License which applies to it and
"any later version", you have the option of following the terms and
conditions either of that version or of any later version published by
the Free Software Foundation.  If the Library does not specify a
license version number, you may choose any version ever published by
the Free Software Foundation.

  14. If you wish to incorporate parts of the Library into other free
programs whose distribution conditions are incompatible with these,
write to the author to ask for permission.  For software which is
copyrighted by the Free Software Foundation, write to the Free
Software Foundation; we sometimes make exceptions for this.  Our
decision will be guided by the two goals of preserving the free status
of all derivatives of our free software and of promoting the sharing
and reuse of software generally.

                            NO WARRANTY

  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGES.
```