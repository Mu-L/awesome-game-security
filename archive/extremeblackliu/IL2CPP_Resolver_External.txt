Project Path: arc_extremeblackliu_IL2CPP_Resolver_External_ag73xepc

Source Tree:

```txt
arc_extremeblackliu_IL2CPP_Resolver_External_ag73xepc
├── Base
│   └── GameObject.hpp
├── Classes
│   ├── Classes.h
│   ├── IL2CPP
│   │   └── IL2CPPClasses.h
│   └── System
│       ├── CharacterController.h
│       ├── Component.h
│       ├── GameClasses.h
│       ├── GameObject.h
│       ├── Object.h
│       ├── Rigidbody.h
│       ├── String.h
│       └── Transform.h
├── IL2CPP.h
├── IL2CPP_Resolver.h
├── README.md
├── Structs
│   ├── Engine.h
│   └── System_String.h
└── Utils
    └── Memory.hpp

```

`Base/GameObject.hpp`:

```hpp
#pragma once

namespace GameObject
{
    inline GameObjectManager GOM;
    inline GameObjectManager* GOM_Ptr;
    static void RefreshObject()
    {
        um::ReadMemory(GOM_Ptr, &GOM);
    }

    static CGameObject* Find(const char* m_Name)
    {
        RefreshObject();

        LastObjectBase lastTaggedObject;
        um::ReadMemory(GOM.lastTaggedObject, &lastTaggedObject);

        BaseObject TaggedObjects;
        um::ReadMemory(GOM.taggedObjects, &TaggedObjects);

        if ((uintptr_t)GOM.taggedObjects == (uintptr_t)GOM_Ptr)
        {
            return nullptr;
        }

        CGameObject* lastGameObject = lastTaggedObject.lastObject;

        CGameObject gameObject;
        um::ReadMemory(lastGameObject, &gameObject);

        char buf0[255];
        um::ReadMemory(gameObject.m_ObjectName, &buf0);
        if (!strcmp(buf0, m_Name))
        {
            return lastGameObject;
        }

        CGameObject* curGameObject = TaggedObjects.object;

        BaseObject curBaseObject = TaggedObjects;

        while (curGameObject != lastGameObject)
        {
            CGameObject gameObject;
            um::ReadMemory(curBaseObject.object, &gameObject);

            char buf[255];
            um::ReadMemory(gameObject.m_ObjectName, &buf);

            if (!strcmp(buf, m_Name))
            {
                return curGameObject;
            }

            um::ReadMemory(curBaseObject.nextObjectLink, &curBaseObject);
            curGameObject = curBaseObject.object;
        }

    }
    static CGameObject* FindGameObjectOfType(const char* m_TypeName)
    {
        // not implement yet...
    }
    static CGameObject* TaggedObjectIterator(std::function<CGameObject* (void*, CGameObject)> loop_func)
    {
        RefreshObject();
        LastObjectBase lastTaggedObject;
        um::ReadMemory(GOM.lastTaggedObject, &lastTaggedObject);

        BaseObject TaggedObjects;
        um::ReadMemory(GOM.taggedObjects, &TaggedObjects);

        if ((uintptr_t)GOM.taggedObjects == (uintptr_t)GOM_Ptr)
        {
            return nullptr;
        }

        CGameObject* lastGameObject = lastTaggedObject.lastObject;

        CGameObject gameObject;
        um::ReadMemory(lastGameObject, &gameObject);

        if (loop_func(lastGameObject, gameObject))
        {
            return lastGameObject;
        }

        CGameObject* curGameObject = TaggedObjects.object;

        BaseObject curBaseObject = TaggedObjects;

        while (curGameObject != lastGameObject)
        {
            CGameObject gameObject;
            um::ReadMemory(curBaseObject.object, &gameObject);

            if (loop_func(curGameObject, gameObject))
            {
                return curGameObject;
            }

            um::ReadMemory(curBaseObject.nextObjectLink, &curBaseObject);
            curGameObject = curBaseObject.object;
        }

        return nullptr;
    }
    static CGameObject* ActiveObjectIterator(std::function<CGameObject* (void*, CGameObject)> loop_func)
    {
        RefreshObject();
        LastObjectBase activeObject;
        um::ReadMemory(GOM.lastActiveObject, &activeObject);

        BaseObject activeObjects;
        um::ReadMemory(GOM.activeObjects, &activeObjects);

        if ((uintptr_t)GOM.activeObjects == (uintptr_t)GOM_Ptr)
        {
            return nullptr;
        }

        CGameObject* lastGameObject = activeObject.lastObject;

        CGameObject gameObject;
        um::ReadMemory(lastGameObject, &gameObject);

        if (loop_func(lastGameObject, gameObject))
        {
            return lastGameObject;
        }

        CGameObject* curGameObject = activeObjects.object;

        BaseObject curBaseObject = activeObjects;

        while (curGameObject != lastGameObject)
        {
            CGameObject gameObject;
            um::ReadMemory(curBaseObject.object, &gameObject);

            if (loop_func(curGameObject, gameObject))
            {
                return curGameObject;
            }

            um::ReadMemory(curBaseObject.nextObjectLink, &curBaseObject);
            curGameObject = curBaseObject.object;
        }

        return nullptr;
    }
    static CGameObject* UntaggedObjectIterator(std::function<CGameObject* (void*, CGameObject)> loop_func)
    {
        RefreshObject();
        LastObjectBase UntaggedObject;
        um::ReadMemory(GOM.lastUntaggedObject, &UntaggedObject);

        BaseObject UntaggedObjects;
        um::ReadMemory(GOM.UntaggedObjects, &UntaggedObjects);

        if ((uintptr_t)GOM.UntaggedObjects == (uintptr_t)GOM_Ptr)
        {
            return nullptr;
        }

        CGameObject* lastGameObject = UntaggedObject.lastObject;

        CGameObject gameObject;
        um::ReadMemory(lastGameObject, &gameObject);

        if (loop_func(lastGameObject, gameObject))
        {
            return lastGameObject;
        }

        CGameObject* curGameObject = UntaggedObjects.object;

        BaseObject curBaseObject = UntaggedObjects;

        while (curGameObject != lastGameObject)
        {
            CGameObject gameObject;
            um::ReadMemory(curBaseObject.object, &gameObject);

            if (loop_func(curGameObject, gameObject))
            {
                return curGameObject;
            }

            um::ReadMemory(curBaseObject.nextObjectLink, &curBaseObject);
            curGameObject = curBaseObject.object;
        }

        return nullptr;
    }
    static CGameObject* ObjectIterator(std::function<CGameObject* (void*, CGameObject)> loop_func, LoopType loop_type = eLOOPTYPE_All)
    {
        CGameObject* object = nullptr;
        switch (loop_type)
        {
        case eLOOPTYPE_All:
        {
            object = UntaggedObjectIterator(loop_func);
            if (object)
                return object;
            object = TaggedObjectIterator(loop_func);
            if (object)
                return object;
            object = ActiveObjectIterator(loop_func);
            if (object)
                return object;
        }
        break;
        case eLOOPTYPE_Tagged:
        {
            object = TaggedObjectIterator(loop_func);
            if (object)
                return object;
        }
        break;
        case eLOOPTYPE_UnTagged:
        {
            object = UntaggedObjectIterator(loop_func);
            if (object)
                return object;
        }
        break;
        case eLOOPTYPE_Active:
        {
            object = ActiveObjectIterator(loop_func);
            if (object)
                return object;
        }
        break;
        default:
            break;
        }
        return nullptr;
    }
    static std::vector<CGameObject*> ObjectIteratorVector(std::function<CGameObject* (void*, CGameObject)> loop_func)
    {
        RefreshObject();
        std::vector<CGameObject*> objects;

        LastObjectBase lastTaggedObject;
        um::ReadMemory(GOM.lastTaggedObject, &lastTaggedObject);

        BaseObject TaggedObjects;
        um::ReadMemory(GOM.taggedObjects, &TaggedObjects);

        if ((uintptr_t)GOM.taggedObjects == (uintptr_t)GOM_Ptr)
        {
            return objects;
        }

        CGameObject* lastGameObject = lastTaggedObject.lastObject;

        CGameObject gameObject;
        um::ReadMemory(lastGameObject, &gameObject);

        if (loop_func(lastGameObject, gameObject))
        {
            objects.push_back(lastGameObject);
        }

        CGameObject* curGameObject = TaggedObjects.object;

        BaseObject curBaseObject = TaggedObjects;

        while (curGameObject != lastGameObject)
        {
            CGameObject gameObject;
            um::ReadMemory(curBaseObject.object, &gameObject);

            if (loop_func(curGameObject, gameObject))
            {
                objects.push_back(curGameObject);
            }

            um::ReadMemory(curBaseObject.nextObjectLink, &curBaseObject);
            curGameObject = curBaseObject.object;
        }

        return objects;
    }
}
```

`Classes/Classes.h`:

```h
#pragma once

#define IL2CPP_PAD_INSERT(x, y) x ## y
#define IL2CPP_PAD_DEFINE(x, y) IL2CPP_PAD_INSERT(x, y)
#define IL2CPP_PAD(size) char IL2CPP_PAD_DEFINE(padding_, __LINE__)[size]

// include IL2CPP Classes
#include "IL2CPP/IL2CPPClasses.h"

// include Structs
#include "../Structs/Engine.h"
#include "../Structs/System_String.h"

// inlcude System Classes
#include "System/Object.h"
#include "System/GameObject.h"
#include "System/Transform.h"
#include "System/Component.h"
#include "System/String.h"

#include "System/CharacterController.h"
#include "System/Rigidbody.h"

struct ComponentList
{
	Component* m_Component;
	void* unk;
};

struct BaseObject
{
	IL2CPP_PAD(0x8);
	BaseObject* nextObjectLink;
	GameObject* object;
};

struct LastObjectBase
{
	IL2CPP_PAD(0x10);
	GameObject* lastObject;
};

struct GameObjectManager {
	LastObjectBase* lastTaggedObject;
	BaseObject* taggedObjects;
	LastObjectBase* lastActiveObject;
	BaseObject* activeObjects;
	LastObjectBase* lastUntaggedObject;
	BaseObject* UntaggedObjects;
};

```

`Classes/IL2CPP/IL2CPPClasses.h`:

```h
#pragma once

struct il2cppImage
{
	const char* m_pName;
	const char* m_pNameNoExt;
	char m_pad0[0x7];
	int m_iClassStartOffset;
	int m_iClassCount;
};

struct il2cppAssemblyName
{
	const char* m_pName;
	const char* m_pCulture;
	const char* m_pHash;
	const char* m_pPublicKey;
	unsigned int m_uHash;
	int m_iHashLength;
	unsigned int m_uFlags;
	int m_iMajor;
	int m_iMinor;
	int m_iBuild;
	int m_bRevision;
	unsigned char m_uPublicKeyToken[8];
};

struct il2cppAssembly
{
	il2cppImage* m_pImage;
	unsigned int m_uToken;
	int m_ReferencedAssemblyStart;
	int m_ReferencedAssemblyCount;
	il2cppAssemblyName m_aName;
};

struct il2cppClass
{
	void* m_pImage;
	void* m_pGC;
	const char* m_pName;
	const char* m_pNamespace;
	void* m_pValue;					//class
	void* m_pArgs;
	il2cppClass* m_pElementClass;
	il2cppClass* m_pCastClass;
	il2cppClass* m_pDeclareClass;
	il2cppClass* m_pParentClass;
	void* m_pGenericClass;
	void* m_pTypeDefinition;
	void* m_pInteropData;
	void* m_pFields;
	void* m_pEvents;
	void* m_pProperties;
	void** m_pMethods;
	il2cppClass** m_pNestedTypes;
	il2cppClass** m_ImplementedInterfaces;
	void* m_pInterfaceOffsets;
	void* m_pStaticFields;
	void* m_pRGCTX;
};

struct il2cppObject
{
	il2cppClass* m_pClass = nullptr;
	void* m_pMonitor = nullptr;
};
```

`Classes/System/CharacterController.h`:

```h
#pragma once

struct CCharacterController
{
	IL2CPP_PAD(0x38);
	void* unk_0; //0x38
	IL2CPP_PAD(0x8);
	void* unk_1; //0x48
	IL2CPP_PAD(0x1D);
	bool enable_Collider; //0x6D
	bool enable_Collider_dup; //0x6C
	IL2CPP_PAD(0x3);
	void* unk_2; //0x70
};
```

`Classes/System/Component.h`:

```h
#pragma once

struct CComponent : CObject
{
	IL2CPP_PAD(0x18);			// 0x27
	CComponent* m_Component;		// 0x28
	IL2CPP_PAD(0x8);			//
	CTransform* m_Transform;		// 0x38
};
```

`Classes/System/GameClasses.h`:

```h
#pragma once
#include <cstdint>

// define your game struct here

struct ExampleGameClass
{
  bool m_bGodMode;
  bool m_bNoClip;
};

```

`Classes/System/GameObject.h`:

```h
#pragma once

struct CGameObject : CObject
{
	IL2CPP_PAD(0x20);			// 0x28
	void* m_ComponentList;		// 0x30
	IL2CPP_PAD(0x8);
	int m_iComponents;			// 0x40
	IL2CPP_PAD(0x16);
	bool m_active;				// 0x56
	bool m_activeCached;		// 0x57
	IL2CPP_PAD(0x2);
	char* m_ObjectName;			// 0x60

	CTransform* GetTransform()
	{
		CGameObject gameObject;
		um::ReadMemory(this, &gameObject);

		void* buffer = malloc(gameObject.m_iComponents * sizeof(ComponentList));

		if (!buffer)
		{
			return nullptr;
		}

		um::ReadMemory((void*)((uintptr_t)gameObject.m_ComponentList + 8), buffer, gameObject.m_iComponents * sizeof(ComponentList));

		ComponentList* list = (ComponentList*)buffer;

		CComponent component;
		um::ReadMemory(list[0].m_Component, &component);

		free(buffer);

		return component.m_Transform;
	}

	/*
		System Class has differen Offset, make sure which component you are touching.
	*/
	CComponent* GetComponentByIndex(int index, bool system_class = false)
	{
		CGameObject gameObject;
		um::ReadMemory(this, &gameObject);

		void* buffer = malloc(gameObject.m_iComponents * sizeof(ComponentList));
		um::ReadMemory((void*)((uintptr_t)gameObject.m_ComponentList + 8), buffer, gameObject.m_iComponents * sizeof(ComponentList));


		ComponentList* list = (ComponentList*)buffer;

		CComponent component;
		if (system_class)
		{
			CComponent* com = list[index].m_Component;
			free(buffer);
			return com;
		}
		else
		{
			um::ReadMemory(list[index].m_Component, &component);
		}
		free(buffer);

		return component.m_Component;
	}


	/*
		This is not finished yet, if you use it, you need to know the Component if its Unity System Class.
	*/
	CComponent* ComponentIterator(std::function<CComponent* (void*)> loop_func)
	{
		CGameObject gameObject;
		um::ReadMemory(this, &gameObject);

		void* buffer = malloc(gameObject.m_iComponents * sizeof(ComponentList));
		um::ReadMemory((void*)((uintptr_t)gameObject.m_ComponentList + 8), buffer, gameObject.m_iComponents * sizeof(ComponentList));

		for (int i = 0; i < gameObject.m_iComponents; i++)
		{
			ComponentList* list = (ComponentList*)buffer;

			CComponent component;
			um::ReadMemory(list[i].m_Component, &component);

			if (loop_func(component.m_Component))
			{
				free(buffer);
				return component.m_Component;
			}

		}
		free(buffer);
		return nullptr;
	}
};
```

`Classes/System/Object.h`:

```h
#pragma once

struct CObject
{
	void* m_Class;				// 0x0
	int m_pad0;					// 0x4
	int m_InstanceID;			// 0x8
};
```

`Classes/System/Rigidbody.h`:

```h
#pragma once

struct CRigidbody
{
	IL2CPP_PAD(0x98);
	bool isKinematic;	//0x98
	IL2CPP_PAD(0x11);
	bool isKinematic_dup;
};
```

`Classes/System/String.h`:

```h
#pragma once

namespace String
{
    /*
        Convert To String, Unity String
    */
    std::string Make_String(System_String* m_str)
    {
        System_String m_String;

        um::ReadMemory(m_str, &m_String);

        std::wstring str(m_String.m_wString);

        // 65001 CP_UTF8
        int ANSIStringLength = WideCharToMultiByte(65001, 0, str.c_str(), m_String.m_iLength + 1, 0, 0, 0, 0);

        char* m_Buffer = (char*)malloc(ANSIStringLength);

        WideCharToMultiByte(65001, 0, str.c_str(), m_String.m_iLength + 1, m_Buffer, ANSIStringLength, 0, 0);

        std::string nstr(m_Buffer);

        free(m_Buffer);

        return nstr;
    }
}
```

`Classes/System/Transform.h`:

```h
#pragma once

struct CTransform
{
	IL2CPP_PAD(0x90);		// 0x00
	Vector3 m_Position;		// 0x90
	IL2CPP_PAD(0x8);
	Vector3 m_Rotate;		// 0xA4 (express in -1.f to 1.f)

    Vector3 GetPosition()
    {
        CTransform _Transform;
        um::ReadMemory(this, &_Transform);

        return _Transform.m_Position;
    }

    void SetPosition(Vector3 p_Position)
    {
        um::WriteMemory(reinterpret_cast<void*>(reinterpret_cast<uintptr_t>(this) + offsetof(CTransform, m_Position)), &p_Position);
        // Note: The Game maybe has some Physics system that is always writing to y axis, you need find the way to disable it yourself.
    }

    // return in range -180.f to 180.f
    Vector3 GetRotation()
    {
        CTransform _Transform;
        um::ReadMemory(this, &_Transform);
        return Vector3(180.f * _Transform.m_Rotate.x, 180.f * _Transform.m_Rotate.y, 180.f * _Transform.m_Rotate.z);
    }

    void SetRotation(Vector3 p_Rotate)
    {
        um::WriteMemory(reinterpret_cast<void*>(reinterpret_cast<uintptr_t>(this) + offsetof(CTransform, m_Rotate)), &p_Rotate);
    }
};
```

`IL2CPP.h`:

```h
#pragma once

namespace IL2CPPClass
{
    inline void** AssembilesTable;
    inline size_t AssemblyCount;
    inline void* ClassesTable;
    inline void* ClassNamePool;
    inline void* ClassNameSpacePool;

    static void FetchClasses(std::vector<std::pair<il2cppClass*, il2cppClass>>* out, const char* ModuleName)
    {
        out->clear();

        il2cppImage Image = {};
        for (int i = 0; i < AssemblyCount; i++)
        {
            il2cppAssembly assembly;
            um::ReadMemory((void*)AssembilesTable[i], &assembly);

            il2cppImage image;
            um::ReadMemory(assembly.m_pImage, &image);

            char Name[255];
            um::ReadMemory((void*)image.m_pNameNoExt, &Name);

            if (!assembly.m_pImage || strcmp(Name, ModuleName))
            {
                continue;
            }

            //Image = assembly.m_pImage;
            um::ReadMemory(assembly.m_pImage, &Image);

            break;
        }
        ClassNamePool = VirtualAlloc(0x0, Image.m_iClassCount * 255, MEM_COMMIT, PAGE_READWRITE);
        ClassNameSpacePool = VirtualAlloc(0x0, Image.m_iClassCount * 255, MEM_COMMIT, PAGE_READWRITE);
        for (size_t i = 0; i < Image.m_iClassCount; i++)
        {
            DWORD offset = Image.m_iClassStartOffset + i;
            if (offset == -1)
                continue;

            offset *= 8;

            il2cppClass* Class;
            um::ReadMemory((void*)((uintptr_t)ClassesTable + offset), &Class);

            if (!Class)
            {
                continue;
            }

            il2cppClass current;
            um::ReadMemory(Class, &current);

            char* buf = (char*)((uintptr_t)ClassNamePool + i * 255);
            um::ReadMemory((void*)current.m_pName, buf, 255);
            current.m_pName = buf;

            char* buf1 = (char*)((uintptr_t)ClassNameSpacePool + i * 255);
            um::ReadMemory((void*)current.m_pNamespace, buf1, 255);
            current.m_pNamespace = buf1;

            out->push_back(std::make_pair(Class, current));
        }

    }

    static il2cppClass* FilterClass(std::vector<std::pair<il2cppClass*, il2cppClass>>& m_pClasses, const char* m_ClassName, const char* m_ClassNameSpace = nullptr)
    {
        for (auto& i : m_pClasses)
        {
            if (strcmp(i.second.m_pName, m_ClassName))
            {
                continue;
            }
            if (!m_ClassNameSpace)
            {
                return i.first;
            }
            else if (!strcmp(i.second.m_pNamespace, m_ClassNameSpace))
            {
                return i.first;
            }
        }
        return nullptr;
    }

    static il2cppClass* GetClassByComponent(Component* component, bool is_system_class)
    {
        il2cppClass* m_class = nullptr;
        if (is_system_class)
        {
            Component comp;
            um::ReadMemory(component, &comp);
            um::ReadMemory(comp.m_Component, &m_class);
            return m_class;
        }
        um::ReadMemory(component, &m_class);
        return m_class;
    }
}
```

`IL2CPP_Resolver.h`:

```h
#pragma once

#include <functional>
#include <vector>

#include "Utils/Memory.hpp"

// All Unity Classes/Structs
#include "Classes/Classes.h"

// Namespaces
#include "Base/GameObject.hpp"


// namespace IL2CPP
#include "IL2CPP.h"

enum LoopType
{
    eLOOPTYPE_All,
    eLOOPTYPE_Tagged,
    eLOOPTYPE_UnTagged,
    eLOOPTYPE_Active
};

namespace IL2CPP
{
    static inline void* GameAssembly;
    static inline void* UnityPlayer;

    static bool Initialize()
    {
        GameAssembly = um::GetModuleBase(L"GameAssembly.dll");
        UnityPlayer = um::GetModuleBase(L"UnityPlayer.dll");

        // Initalize Unity GameObjectManager
        // xref E8 ? ? ? ? 48 8B D0 83 FB 05 75 (UnityPlayer.dll)
        uintptr_t addr = um::SignatureScan(L"UnityPlayer.dll", "E8 ? ? ? ? 48 8B D0 83 FB 05 75");
        addr = helper::relativeToAbsolute(addr);
        addr = helper::relativeToAbsolute(addr, 3);

        void* GOM = (void*)(addr);
        um::ReadMemory(GOM, &GOM);

        if (!GOM)
        {
            return false;
        }

        GameObject::GOM_Ptr = (GameObjectManager*)GOM;
        um::ReadMemory(GameObject::GOM_Ptr, &GOM);

        // Initialize IL2CPP Classes from il2cpp_domain_get_assemblies
        // xref E8 ? ? ? ? 48 8B 48 08 48 2B 08 48 C1 F9 03 48 89 0B 48 8B 00 48 83 C4 20 5B C3 (GameAssembly.dll)
        addr = um::SignatureScan(L"GameAssembly.dll", "E8 ? ? ? ? 48 8B 48 08 48 2B 08 48 C1 F9 03 48 89 0B 48 8B 00 48 83 C4 20 5B C3");
        addr = helper::relativeToAbsolute(addr);
        addr = helper::relativeToAbsolute(addr, 3);

        void* Assemblies = (void*)(addr);

        void* End = nullptr;
        void* Start = nullptr;

        um::ReadMemory(Assemblies, &Start);
        um::ReadMemory((void*)((uintptr_t)Assemblies + 0x8), &End);

        if (!Start || !End)
        {
            return false;
        }

        IL2CPPClass::AssemblyCount = ((uintptr_t)End - (uintptr_t)Start) / sizeof(void*);

        IL2CPPClass::AssembilesTable = (void**)malloc(IL2CPPClass::AssemblyCount * sizeof(void*));

        um::ReadMemory(Start, IL2CPPClass::AssembilesTable, IL2CPPClass::AssemblyCount * sizeof(void*));
        
        // xref 48 8B 05 ? ? ? ? 48 83 3C 03 00 75 45 48 8D 35 ? ? ? ? 48 89 74 24 38 48 8B CE (GameAssembly.dll)
        // mov rax,[7FFE238F2278]
        addr = um::SignatureScan(L"GameAssembly.dll", "48 8B 05 ? ? ? ? 48 83 3C 03 00 75 45 48 8D 35 ? ? ? ? 48 89 74 24 38 48 8B CE");
        addr = helper::relativeToAbsolute(addr,3);

        IL2CPPClass::ClassesTable = (void*)(addr);
        um::ReadMemory(IL2CPPClass::ClassesTable, &IL2CPPClass::ClassesTable);
        if (!IL2CPPClass::ClassesTable)
        {
            return false;
        }

        return true;
    }
}

```

`README.md`:

```md
## IL2CPP Resolver External
A run-time API resolver for IL2CPP Unity in External.

[Internal version](https://github.com/sneakyevilSK/IL2CPP_Resolver)

# ARCHIVED
External version is impossible, i started this because i need research for my own project.

Soon i realize, some code signature i made cross only few unity versions.

that means if i have to make all unity available, billion signature must be recreate, impossible for me.

code is shit tho dont even try it

thanks everyone

# Initialize
```cpp
#include "IL2CPP_Resolver_External/IL2CPP_Resolver.h"

void main()
{
    IL2CPP::Initialize();
}
```

# Quick Examples
N/A

# WARNING
* This is still working-in-progress.

# Requirements
* C++ 17 or Greater.
* Windows only.

# TODO
* Auto-Detect System Class and Game Class for component looping
* More Unity Version Support
* More Methods
* Fetch Method from Module by giving Method's Name

### Tested on
* VRChat[<= Unity 2019.4.31]
* VRChat[Unity 2022.3.6] (testing...)

```

`Structs/Engine.h`:

```h
#pragma once

struct Quaternion
{
	float x, y, z, w;

	Quaternion() { x = y = z = w = 0.f; }
	Quaternion(float f1, float f2, float f3, float f4) { x = f1; y = f2; z = f3; w = f4; }
};

struct Vector2
{
	float x, y;

	Vector2() { x = y = 0.f; }
	Vector2(float f1, float f2) { x = f1; y = f2; }
};

struct Vector3
{
	float x, y, z;

	Vector3() { x = y = z = 0.f; }
	Vector3(float f1, float f2, float f3) { x = f1; y = f2; z = f3; }
};

struct Vector4
{
	float x, y, z, w;

	Vector4() { x = y = z = w = 0.f; }
	Vector4(float f1, float f2, float f3, float f4) { x = f1; y = f2; z = f3; w = f4; }
};
```

`Structs/System_String.h`:

```h
#pragma once

struct System_String : il2cppObject
{
	int m_iLength;
	wchar_t m_wString[1024];
};
```

`Utils/Memory.hpp`:

```hpp
#pragma once
#include <Windows.h>
#include <TlHelp32.h>

namespace um
{
	inline HANDLE hProcess;
	inline DWORD pid;

	static bool Init(HWND hwnd)
	{
		GetWindowThreadProcessId(hwnd, &pid);
		if (!pid)
		{
			return false;
		}
		hProcess = OpenProcess(PROCESS_ALL_ACCESS, false, pid);
		if (!hProcess)
		{
			return false;
		}

		return true;
	}

	template<typename T>
	static NTSTATUS ReadMemory(void* TargetAddress, T* Buffer)
	{
		return ReadProcessMemory(hProcess, TargetAddress, Buffer, sizeof(T), 0) == false;
	}
	static NTSTATUS ReadMemory(void* TargetAddress, void* Buffer, DWORD size)
	{
		return ReadProcessMemory(hProcess, TargetAddress, Buffer, size, 0) == false;
	}
	template<typename T>
	static NTSTATUS WriteMemory(void* TargetAddress, T* Buffer)
	{
		return WriteProcessMemory(hProcess, TargetAddress, Buffer, sizeof(T), 0) == false;
	}
	static void* GetModuleBase(const wchar_t* pName)
	{
		HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pid);
		void* dwModuleBaseAddress = 0;
		if (hSnapshot != INVALID_HANDLE_VALUE)
		{
			MODULEENTRY32 ModuleEntry32 = { 0 };
			ModuleEntry32.dwSize = sizeof(MODULEENTRY32);
			if (Module32First(hSnapshot, &ModuleEntry32))
			{
				do
				{
					if (wcscmp(ModuleEntry32.szModule, pName) == 0)
					{
						dwModuleBaseAddress = ModuleEntry32.modBaseAddr;
						break;
					}
				} while (Module32Next(hSnapshot, &ModuleEntry32));
			}
			CloseHandle(hSnapshot);
		}
		return dwModuleBaseAddress;
	}
	static size_t GetModuleSize(const wchar_t* pName)
	{
		HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pid);
		size_t szModuleSize = 0;
		if (hSnapshot != INVALID_HANDLE_VALUE)
		{
			MODULEENTRY32 ModuleEntry32 = { 0 };
			ModuleEntry32.dwSize = sizeof(MODULEENTRY32);
			if (Module32First(hSnapshot, &ModuleEntry32))
			{
				do
				{
					if (wcscmp(ModuleEntry32.szModule, pName) == 0)
					{
						szModuleSize = ModuleEntry32.modBaseSize;
						break;
					}
				} while (Module32Next(hSnapshot, &ModuleEntry32));
			}
			CloseHandle(hSnapshot);
		}
		return szModuleSize;
	}
	static uintptr_t SignatureScan(uintptr_t start, unsigned long long size, const char* sig)
	{
		unsigned char* data = (unsigned char*)VirtualAlloc(0x0, size, MEM_COMMIT, PAGE_READWRITE);
		if (!data)
			return 0;

		ReadMemory((void*)start, data, size);

		static auto pattern_to_byte = [](const char* pattern) {
			auto bytes = std::vector<int>{};
			auto start = const_cast<char*>(pattern);
			auto end = const_cast<char*>(pattern) + strlen(pattern);

			for (auto current = start; current < end; ++current) {
				if (*current == '?') {
					++current;
					if (*current == '?')
						++current;
					bytes.push_back(-1);
				}
				else {
					bytes.push_back(strtoul(current, &current, 16));
				}
			}
			return bytes;
		};

		auto patternBytes = pattern_to_byte(sig);
		auto scanBytes = reinterpret_cast<unsigned char*>(data);

		auto s = patternBytes.size();
		auto d = patternBytes.data();

		for (auto i = 0ul; i < size - s; ++i) {
			bool found = true;
			for (auto j = 0ul; j < s; ++j) {
				if (scanBytes[i + j] != d[j] && d[j] != -1) {
					found = false;
					break;
				}
			}
			if (found) {
				VirtualFree(data, size, MEM_DECOMMIT);
				return start + i;
			}
		}

		VirtualFree(data, size, MEM_DECOMMIT);
		return 0;
	}
	static uintptr_t SignatureScan(const wchar_t* ModuleName, const char* sig)
	{
		return SignatureScan((uintptr_t)GetModuleBase(ModuleName), GetModuleSize(ModuleName), sig);
	}
}


namespace helper
{
	static uintptr_t relativeToAbsolute(uintptr_t address, int offset_to_delta = 1)
	{
		if (!address)
			return 0;
		int delta;
		um::ReadMemory((void*)(address + offset_to_delta), &delta);

		return (uintptr_t)(address + offset_to_delta + 4 + delta);
	}
}
```