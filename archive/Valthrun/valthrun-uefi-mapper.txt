Project Path: arc_Valthrun_valthrun-uefi-mapper_ja25kikg

Source Tree:

```txt
arc_Valthrun_valthrun-uefi-mapper_ja25kikg
├── Cargo.lock
├── Cargo.toml
├── README.MD
├── media
│   └── screenshot_mapped_successfully.png
├── resources
│   ├── HashTool.efi
│   └── PreLoader.efi
├── rust-toolchain.toml
├── rustfmt.toml
├── scripts
│   ├── Create-ISO.ps1
│   ├── Create-ISO.sh
│   ├── mkisofs
│   │   ├── cygwin.ini
│   │   ├── cygwin1.dll
│   │   └── mkisofs.exe
│   └── mtools
│       ├── cygwin1.dll
│       └── mtools.exe
└── src
    ├── hook
    │   ├── detour.rs
    │   ├── function.rs
    │   ├── mod.rs
    │   └── statik.rs
    ├── image_info.rs
    ├── main.rs
    ├── signature.rs
    ├── uefi_core
    │   ├── allocator.rs
    │   ├── context.rs
    │   ├── logger.rs
    │   ├── mod.rs
    │   ├── panic.rs
    │   └── system_table.rs
    ├── utils.rs
    ├── wdef.rs
    └── winload.rs

```

`Cargo.lock`:

```lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "anyhow"
version = "1.0.75"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a4668cab20f66d8d020e1fbc0ebe47217433c1b6c8f2040faf858554e394ace6"

[[package]]
name = "bit_field"
version = "0.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc827186963e592360843fb5ba4b973e145841266c1357f7180c43526f2e5b61"

[[package]]
name = "bitflags"
version = "2.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "327762f6e5a765692301e5bb513e0d9fef63be86bbc14528052b1cd3e6f03e07"

[[package]]
name = "dataview"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "50eb3a329e19d78c3a3dfa4ec5a51ecb84fa3a20c06edad04be25356018218f9"

[[package]]
name = "log"
version = "0.4.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b5e6163cb8c49088c2c36f57875e58ccd8c87c7427f7fbd50ea6710b2f3f2e8f"

[[package]]
name = "no-std-compat"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b93853da6d84c2e3c7d730d6473e8817692dd89be387eb01b94d7f108ecb5b8c"

[[package]]
name = "obfstr"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3ba2979b86cc910a6d13837ef97fef0c6b68fa807c5e014d622449db18351dc"

[[package]]
name = "paste"
version = "1.0.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "de3145af08024dea9fa9914f381a17b8fc6034dfb00f3a84013f7ff43f29ed4c"

[[package]]
name = "pelite"
version = "0.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "88dccf4bd32294364aeb7bd55d749604450e9db54605887551f21baea7617685"
dependencies = [
 "dataview",
 "no-std-compat",
 "pelite-macros",
]

[[package]]
name = "pelite-macros"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a7cf3f8ecebb0f4895f4892a8be0a0dc81b498f9d56735cb769dc31bf00815b"

[[package]]
name = "proc-macro2"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "134c189feb4956b20f6f547d2cf727d4c0fe06722b20a0eec87ed445a97f92da"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "ptr_meta"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bcada80daa06c42ed5f48c9a043865edea5dc44cbf9ac009fda3b89526e28607"
dependencies = [
 "ptr_meta_derive",
]

[[package]]
name = "ptr_meta_derive"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bca9224df2e20e7c5548aeb5f110a0f3b77ef05f8585139b7148b59056168ed2"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "quote"
version = "1.0.33"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5267fca4496028628a95160fc423a33e8b2e6af8a5302579e322e4b520293cae"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "syn"
version = "1.0.109"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "syn"
version = "2.0.38"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e96b79aaa137db8f61e26363a0c9b47d8b4ec75da28b7d1d614c2303e232408b"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "ucs2"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bad643914094137d475641b6bab89462505316ec2ce70907ad20102d28a79ab8"
dependencies = [
 "bit_field",
]

[[package]]
name = "uefi"
version = "0.25.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1cb8f384905087f56c2fdf90bb7d94d24c600775b9f40424a4b80882ba399d47"
dependencies = [
 "bitflags",
 "log",
 "ptr_meta",
 "ucs2",
 "uefi-macros",
 "uefi-raw",
 "uguid",
]

[[package]]
name = "uefi-macros"
version = "0.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "023d94ef8e135d068b9a3bd94614ef2610b2b0419ade0a9d8f3501fa9cd08e95"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.38",
]

[[package]]
name = "uefi-raw"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8bbf45ee102da89ef37674dd5186cd766418338457e660e7a3a1bad64d122abf"
dependencies = [
 "bitflags",
 "ptr_meta",
 "uguid",
]

[[package]]
name = "uguid"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1ef516f0806c5f61da6aa95125d0eb2d91cc95b2df426c06bde8be657282aee5"

[[package]]
name = "unicode-ident"
version = "1.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3354b9ac3fae1ff6755cb6db53683adb661634f67557942dea4facebec0fee4b"

[[package]]
name = "valthrun-uefi"
version = "0.1.0"
dependencies = [
 "anyhow",
 "log",
 "obfstr",
 "paste",
 "pelite",
 "uefi",
 "uefi-raw",
]

```

`Cargo.toml`:

```toml
[package]
name = "valthrun-uefi"
version = "0.1.0"
edition = "2021"
publish = false

[dependencies]
anyhow = { version = "1.0.75", default-features = false }
log = { version = "0.4.20", features = ["release_max_level_info"] }
obfstr = "0.4.3"
paste = "1.0.14"
pelite = { version = "0.10.0", default-features = false, features = [
    "unsafe_alignment",
] }
uefi = { version = "0.25.0", default-features = false, features = ["alloc"] }
uefi-raw = "0.4.0"

[profile.dev]
panic = "abort"

[profile.release]
panic = "abort"

```

`README.MD`:

```MD
# Valthrun UEFI mapper

Automatically map the Valthrun driver from the UEFI.  
Doing this has several advantages:

1. The Valthrun driver can be loaded before any other drivers
2. You can create a bootable USB stick containing the latest Valthrun driver

## Build the ISO

```ps1
# Requirements PowerShell 7 or higher.
cargo b --target x86_64-unknown-uefi && .\scripts\Create-ISO.ps1 -Destination ./bootloader.iso
```

## Load the valthrun driver

The valthrun driver should be automatically loaded when booting using the valthrun bootloader.  
To use the bootloader create a bootable USB stick and boot from that.  
On success you should see the following message:  
![image](./media/screenshot_mapped_successfully.png)

```

`rust-toolchain.toml`:

```toml
[toolchain]
targets = ["x86_64-unknown-uefi"]
channel = "nightly-2024-09-25"

```

`rustfmt.toml`:

```toml
group_imports = "StdExternalCrate"
imports_layout = "Vertical"
imports_granularity = "Crate"
reorder_imports = true

```

`scripts/Create-ISO.ps1`:

```ps1
param(
    [Parameter(Mandatory = $false)]
    [string] $Bootloader,

    [Parameter(Mandatory = $true)]
    [string] $Destination
)

$ErrorActionPreference = "Stop"

$mtools = "$PSScriptRoot\mtools\mtools.exe"
$mkisofs = "$PSScriptRoot\mkisofs\mkisofs.exe"

$Resources = "$PSScriptRoot\..\resources"
$IsoRoot = "$PSScriptRoot\__iso"
$BootImage = "$IsoRoot\EFI\BOOT\efibootfs.img"

Write-Host "Creating ISO"
if (Test-Path $Destination) {
    Remove-Item $Destination -Force
}

# If no specific bootloader has been given, just try to get the latest build
if ([string]::IsNullOrEmpty($Bootloader)) {
    $Bootloader = "release", "debug" | `
        ForEach-Object { Get-Item "target\x86_64-unknown-uefi\$_\valthrun-uefi.efi" } | `
        Sort-Object LastWriteTime -Descending | `
        Select-Object -First 1
    
    Write-Host "Using bootloader $Bootloader"
}

# Create the ISO directory
& {
    $BootImageDir = Split-Path $BootImage
    if (Test-Path $BootImageDir) {
        Remove-Item $BootImageDir -Recurse -Force | Out-Null
    }
    New-Item -Path $BootImageDir -ItemType Directory -Force | Out-Null
}

# Generate the FAT32 content for efi
& {
    $BootFiles = @(
        @{
            "Source" = $(Resolve-Path "$Resources\PreLoader.efi" -Relative)
            "Target" = "::EFI/BOOT/bootx64.efi"
        },
        @{
            "Source" = $(Resolve-Path "$Resources\HashTool.efi" -Relative)
            "Target" = "::EFI/BOOT/HashTool.efi"
        },
        @{
            "Source" = $(Resolve-Path "$Bootloader" -Relative)
            "Target" = "::EFI/BOOT/loader.efi"
        }
    )

    $FileAlignment = 0x200
    foreach ($File in $BootFiles) {
        $File.Size = (Get-Item $File.Source).Length
        if (($File.Size -band ($FileAlignment - 1)) -ne 0) {
            $File.SizePadded = ($File.Size -band (-bnot ($FileAlignment - 1))) + $FileAlignment
        }
        else {
            $File.SizePadded = $File.Size
        }
    }

    $SizeTotal = $($BootFiles | measure-object -property SizePadded -Sum).Sum
    $LastError = $null
    foreach ($Padding in 8, 16, 24, 32, 48, 64, 128) {
        Write-Host "Try padding $Padding"
        try {
            $BootImageFile = New-Object System.IO.FileStream $BootImage, Create, ReadWrite
            $BootImageFile.SetLength($SizeTotal + 1024 * $Padding)
            $BootImageFile.Close()
        
            & $mtools -c mformat -i "$BootImage" :: || $(throw "Failed to format disk")
            & $mtools -c mmd -i "$BootImage" "::EFI" || $(throw "Failed to create folder")
            & $mtools -c mmd -i "$BootImage" "::EFI/BOOT" || $(throw "Failed to create folder")
            foreach ($File in $BootFiles) {
                & $mtools -c mcopy -i "$BootImage" "$($File.Source)" "$($File.Target)" || $(throw "Failed to copy $($File.Source) to $($File.Target)")
            }
            # & $mtools -c mdir -i "$BootImage" "::EFI/BOOT"

            Write-Host "Created FAT system with $Padding additional kb"
            $LastError = $null
            break
        }
        catch {
            $LastError = $_
        }
    }
   
    if ($LastError -ne $null) {
        throw $LastError
    }
}

# Create the ISO from root directory
& $mkisofs -o "$Destination" `
    -R -J -d -N `
    -hide-rr-moved `
    -no-emul-boot `
    -eltorito-platform efi `
    -eltorito-boot EFI/BOOT/efibootfs.img `
    "$IsoRoot"

if (-not $?) { 
    throw "Failed to create ISO ($LastExitCode)"
}
Write-Host "ISO created at $Destination"
```

`scripts/Create-ISO.sh`:

```sh
#!/bin/bash

# Usage: ./Create-ISO.sh -v [debug/release] -d [Destination ISO file]

# Check if required tools are installed
command -v mtools >/dev/null 2>&1 || { echo >&2 "mtools is required but it's not installed. Aborting."; exit 1; }
command -v xorriso >/dev/null 2>&1 || { echo >&2 "xorriso is required but it's not installed. Aborting."; exit 1; }
BootloaderVersion="debug"

while getopts v:d: flag
do
    case "${flag}" in
        v) BootloaderVersion=${OPTARG};;
        d) Destination=${OPTARG};;
    esac
done

if [ -z "$Destination" ]; then
    echo "Usage: $0 -v [Version: release/debug] -d [Destination ISO file]"
    exit 1
fi

# Define the path for the bootloader EFI files
if [ "$BootloaderVersion" = "release" ]; then
    Bootloader="../target/x86_64-unknown-uefi/release/valthrun-uefi.efi"
elif [ "$BootloaderVersion" = "debug" ]; then
    Bootloader="../target/x86_64-unknown-uefi/debug/valthrun-uefi.efi"
else
    echo "Invalid value for bootloader version. Please use 'release' or 'debug'."
    exit 1
fi

if [ ! -f "$Bootloader" ]; then
    echo "Bootloader file '$Bootloader' not found. Aborting."
    exit 1
fi

IsoRoot="__iso"
EFI_DIR="$IsoRoot/EFI/BOOT"
EFI_IMG="$EFI_DIR/efibootfs.img"

rm -rf "$IsoRoot"
mkdir -p "$EFI_DIR"

BootloaderSize=$(stat -c%s "$Bootloader")
HashToolSize=$(stat -c%s "../resources/HashTool.efi")
TotalSize=$(($BootloaderSize + $HashToolSize))
Padding=1024
TotalSizeWithPadding=$(($TotalSize + $Padding))

Blocks=$((($TotalSizeWithPadding + 511) / 512))

# Create a FAT image file for EFI boot
dd if=/dev/zero of="$EFI_IMG" bs=512 count=$Blocks
mkfs.vfat "$EFI_IMG"

# Create the required directory structure inside the EFI image
mmd -i "$EFI_IMG" ::EFI
mmd -i "$EFI_IMG" ::EFI/BOOT

# Use mtools to copy the bootloader and other files
MTOOLS_SKIP_CHECK=1 mcopy -i "$EFI_IMG" "$Bootloader" ::/EFI/BOOT/bootx64.efi

MTOOLS_SKIP_CHECK=1 mcopy -i "$EFI_IMG" "../resources/HashTool.efi" ::/EFI/BOOT/HashTool.efi
MTOOLS_SKIP_CHECK=1 mcopy -i "$EFI_IMG" "../resources/PreLoader.efi" ::/EFI/BOOT/loader.efi

# Create the UEFI bootable ISO
xorriso -as mkisofs -o "$Destination" \
    -U -iso-level 3 -full-iso9660-filenames \
    -eltorito-alt-boot \
    -e EFI/BOOT/efibootfs.img \
    -no-emul-boot \
    -isohybrid-gpt-basdat \
    -volid "UEFI_ISO" \
    -no-pad \
    "$IsoRoot"

# Check if ISO creation was successful
if [ $? -ne 0 ]; then
    echo "Failed to create ISO."
    exit 1
else
    echo "ISO created successfully at $Destination"
fi

```

`scripts/mkisofs/cygwin.ini`:

```ini
[CygwinDLL]
UseOwnDLLs=1
CheckForActiveDLL=1

```

`src/hook/detour.rs`:

```rs
use core::marker::PhantomData;

use super::{
    Function,
    Hook,
};

#[rustfmt::skip]
const HOOK_SHELLCODE: [u8; 14] = [
    /* jmp    DWORD PTR ds:0x0 */
    0xFF, 0x25, 0x00, 0x00, 0x00, 0x00, 
    
    /* target address */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];

pub struct TrampolineHook<T> {
    hooked: bool,

    target: T,
    bytes_original: [u8; HOOK_SHELLCODE.len()],

    _dummy: PhantomData<T>,
}

unsafe impl<T> Send for TrampolineHook<T> {}
unsafe impl<T> Sync for TrampolineHook<T> {}

impl<T: Function> TrampolineHook<T> {
    pub fn create(target: T) -> Self {
        let original = [0u8; HOOK_SHELLCODE.len()];
        Self {
            hooked: false,
            target,
            bytes_original: original,

            _dummy: Default::default(),
        }
    }

    unsafe fn bytes_target(&self) -> &'static mut [u8] {
        unsafe {
            core::slice::from_raw_parts_mut(self.target.to_ptr() as *mut u8, HOOK_SHELLCODE.len())
        }
    }
}

impl<T: Function> Hook<T> for TrampolineHook<T> {
    fn is_active(&self) -> bool {
        self.hooked
    }

    fn target(&self) -> T {
        self.target
    }

    unsafe fn enable(&mut self, target: T) -> bool {
        let bytes_target = self.bytes_target();
        if !self.hooked {
            self.hooked = true;

            self.bytes_original.copy_from_slice(&bytes_target);
            bytes_target.copy_from_slice(&HOOK_SHELLCODE);
        }

        bytes_target[6..].copy_from_slice(&target.to_ptr_usize().to_le_bytes());
        true
    }

    unsafe fn disable(&mut self) {
        if !self.hooked {
            return;
        }

        self.hooked = false;
        let bytes_target = self.bytes_target();
        bytes_target.copy_from_slice(&self.bytes_original);
    }
}

```

`src/hook/function.rs`:

```rs
/// Trait representing a function that can be used as a target or detour for
/// detouring.
pub unsafe trait Function: Sized + Copy + Sync + 'static {
    /// The argument types as a tuple.
    type Arguments;

    /// The return type.
    type Output;

    /// Constructs a `Function` from an untyped pointer.
    unsafe fn from_ptr(ptr: *const ()) -> Self;

    /// Constructs a `Function` from an untyped usize pointer.
    unsafe fn from_ptr_usize(ptr: usize) -> Self {
        Self::from_ptr(ptr as *const ())
    }

    /// Returns an untyped pointer for this function.
    fn to_ptr(&self) -> *const ();

    fn to_ptr_usize(&self) -> usize {
        self.to_ptr() as usize
    }
}

macro_rules! impl_function {
    (@recurse () ($($nm:ident : $ty:ident),*)) => {
      impl_function!(@impl_all ($($nm : $ty),*));
    };
    (@recurse
        ($hd_nm:ident : $hd_ty:ident $(, $tl_nm:ident : $tl_ty:ident)*)
        ($($nm:ident : $ty:ident),*)) => {
      impl_function!(@impl_all ($($nm : $ty),*));
      impl_function!(@recurse ($($tl_nm : $tl_ty),*) ($($nm : $ty,)* $hd_nm : $hd_ty));
    };

    (@impl_all ($($nm:ident : $ty:ident),*)) => {
      impl_function!(@impl_pair ($($nm : $ty),*) (                  fn($($ty),*) -> Ret));
      impl_function!(@impl_pair ($($nm : $ty),*) (extern "cdecl"    fn($($ty),*) -> Ret));
      impl_function!(@impl_pair ($($nm : $ty),*) (extern "efiapi"   fn($($ty),*) -> Ret));
      impl_function!(@impl_pair ($($nm : $ty),*) (extern "stdcall"  fn($($ty),*) -> Ret));
      impl_function!(@impl_pair ($($nm : $ty),*) (extern "fastcall" fn($($ty),*) -> Ret));
      impl_function!(@impl_pair ($($nm : $ty),*) (extern "win64"    fn($($ty),*) -> Ret));
      impl_function!(@impl_pair ($($nm : $ty),*) (extern "C"        fn($($ty),*) -> Ret));
      impl_function!(@impl_pair ($($nm : $ty),*) (extern "system"   fn($($ty),*) -> Ret));

      #[cfg_attr(docsrs, doc(cfg(feature = "thiscall-abi")))]
      impl_function!(@impl_pair ($($nm : $ty),*) (extern "thiscall" fn($($ty),*) -> Ret));
    };

    (@impl_pair ($($nm:ident : $ty:ident),*) ($($fn_t:tt)*)) => {
      impl_function!(@impl_fun ($($nm : $ty),*) ($($fn_t)*) (unsafe $($fn_t)*));
    };

    (@impl_fun ($($nm:ident : $ty:ident),*) ($safe_type:ty) ($unsafe_type:ty)) => {
      impl_function!(@impl_core ($($nm : $ty),*) ($safe_type));
      impl_function!(@impl_core ($($nm : $ty),*) ($unsafe_type));
    };

    (@impl_core ($($nm:ident : $ty:ident),*) ($fn_type:ty)) => {
      unsafe impl<Ret: 'static, $($ty: 'static),*> Function for $fn_type {
        type Arguments = ($($ty,)*);
        type Output = Ret;

        unsafe fn from_ptr(ptr: *const ()) -> Self {
          ::core::mem::transmute(ptr)
        }

        fn to_ptr(&self) -> *const () {
          *self as *const ()
        }
      }
    };

    ($($nm:ident : $ty:ident),*) => {
      impl_function!(@recurse ($($nm : $ty),*) ());
    };
  }

impl_function! {
  __arg_0:  A, __arg_1:  B, __arg_2:  C, __arg_3:  D, __arg_4:  E, __arg_5:  F, __arg_6:  G,
  __arg_7:  H, __arg_8:  I, __arg_9:  J, __arg_10: K, __arg_11: L, __arg_12: M, __arg_13: N
}

```

`src/hook/mod.rs`:

```rs
pub trait Hook<T: Function> {
    fn is_active(&self) -> bool;
    fn target(&self) -> T;

    unsafe fn enable(&mut self, target: T) -> bool;
    unsafe fn disable(&mut self);
}

mod detour;
pub use detour::*;

mod statik;
pub use statik::*;

mod function;
pub use function::*;

```

`src/hook/statik.rs`:

```rs
use core::marker::PhantomData;

use super::{
    Function,
    Hook,
    TrampolineHook,
};

pub struct StaticHook<T: Function, H: Hook<T>> {
    inner: Option<H>,
    _dummy: PhantomData<T>,
}

impl<T: Function, H: Hook<T>> StaticHook<T, H> {
    pub const fn new() -> Self {
        Self {
            inner: None,
            _dummy: PhantomData {},
        }
    }

    pub fn initialize(&mut self, hook: H) {
        assert!(self.inner.is_none());
        self.inner = Some(hook);
    }

    pub fn initialized(&self) -> bool {
        self.inner.is_some()
    }

    pub fn target(&self) -> Option<T> {
        self.inner.as_ref().map(Hook::target)
    }

    pub fn is_active(&self) -> bool {
        self.inner.as_ref().map(Hook::is_active).unwrap_or(false)
    }

    pub unsafe fn enable(&mut self, target: T) -> bool {
        match &mut self.inner {
            Some(inner) => inner.enable(target),
            None => false,
        }
    }

    pub unsafe fn disable(&mut self) {
        if let Some(inner) = &mut self.inner {
            inner.disable();
        }
    }
}

impl<T: Function> StaticHook<T, TrampolineHook<T>> {
    pub fn initialize_trampoline(&mut self, target: T) {
        self.initialize(TrampolineHook::create(target))
    }
}

```

`src/image_info.rs`:

```rs
use alloc::format;
use core::slice;

use anyhow::{
    anyhow,
    Context,
};
use obfstr::obfstr;
use uefi::{
    proto::loaded_image::LoadedImage,
    Handle,
};

use crate::{
    signature::{
        Signature,
        SignatureType,
    },
    uefi_core::system_table,
};

pub struct ImageInfo {
    pub image_base: *mut u8,
    pub image_size: usize,
}

impl ImageInfo {
    pub fn from_handle(handle: Handle) -> anyhow::Result<Self> {
        system_table()
            .boot_services()
            .open_protocol_exclusive::<LoadedImage>(handle)
            .map(|image| ImageInfo::from(&*image))
            .map_err(|err| {
                anyhow!(
                    "{}: {}",
                    obfstr!("bootmgr image is missing the LoadedImage protocol"),
                    err
                )
            })
    }

    pub fn image_as_slice(&self) -> &[u8] {
        unsafe { core::slice::from_raw_parts(self.image_base, self.image_size) }
    }

    #[allow(unused)]
    pub fn image_as_slice_mut(&mut self) -> &mut [u8] {
        unsafe { core::slice::from_raw_parts_mut(self.image_base, self.image_size) }
    }

    pub fn resolve_signature(&self, signature: &Signature) -> anyhow::Result<usize> {
        log::trace!(
            "Resolving '{}' in {:X}",
            signature.debug_name,
            self.image_base as usize
        );

        let inst_offset = signature
            .pattern
            .find(self.image_as_slice())
            .with_context(|| {
                format!(
                    "{} {}",
                    obfstr!("failed to find pattern"),
                    signature.debug_name
                )
            })?;

        if matches!(&signature.value_type, SignatureType::Pattern) {
            let address = self.image_base.wrapping_byte_add(inst_offset) as usize;
            log::trace!("  => {:X} ({:X})", address, inst_offset);
            return Ok(address);
        }

        let value = unsafe {
            self.image_base
                .byte_add(inst_offset)
                .byte_add(signature.offset as usize)
                .cast::<u32>()
                .read_unaligned()
        };
        match &signature.value_type {
            SignatureType::Offset => {
                log::trace!("  => {:X} (inst at {:X})", value, inst_offset);
                Ok(value as usize)
            }
            SignatureType::RelativeAddress { inst_length } => {
                let value = unsafe {
                    self.image_base
                        .byte_add(inst_offset)
                        .byte_add(*inst_length)
                        .byte_offset(value as isize) as usize
                };
                log::trace!("  => {:X} ({:X})", value, value - self.image_base as usize);
                Ok(value)
            }
            SignatureType::Pattern => unreachable!(),
        }
    }
}

impl From<&LoadedImage> for ImageInfo {
    fn from(value: &LoadedImage) -> Self {
        let (image_base, image_size) = value.info();
        Self {
            image_base: image_base as *mut u8,
            image_size: image_size as usize,
        }
    }
}

pub struct ImageBuffer {
    pub address: *mut u8,
    pub length: usize,
}

impl ImageBuffer {
    pub fn as_slice_mut(&mut self) -> &mut [u8] {
        unsafe { slice::from_raw_parts_mut(self.address, self.length) }
    }
}

```

`src/main.rs`:

```rs
#![no_main]
#![no_std]
#![feature(sync_unsafe_cell)]
#![allow(static_mut_refs)]

use alloc::{
    boxed::Box,
    string::{
        String,
        ToString,
    },
    vec::Vec,
};
use core::{
    self,
    ptr,
    slice,
};

use anyhow::{
    anyhow,
    Context,
    Error,
};
use hook::{
    Function,
    StaticHook,
    TrampolineHook,
};
use image_info::{
    ImageBuffer,
    ImageInfo,
};
use obfstr::obfstr;
use pelite::{
    PeFile,
    PeView,
    Wrap,
};
use signature::Signature;
use uefi::{
    prelude::*,
    proto::{
        console::text::Color,
        device_path::{
            build::{
                self,
            },
            text::{
                AllowShortcuts,
                DisplayOnly,
            },
            DevicePath,
        },
        media::{
            file::{
                File,
                FileAttribute,
                FileMode,
            },
            fs::SimpleFileSystem,
        },
    },
    table::{
        boot::{
            LoadImageSource,
            OpenProtocolAttributes,
            OpenProtocolParams,
            SearchType,
        },
        SystemTable,
    },
    CStr16,
    Identify,
};
use uefi_core::system_table;
use utils::include_bytes_align_as;
use wdef::{
    BlImgAllocateImageBuffer,
    ImgArchStartBootApplication,
    LoaderParameterBlock,
    OslFwpKernelSetupPhase1,
    BL_MEMORY_TYPE_DRIVER,
    KLDR_DATA_TABLE_ENTRY,
    NT_STATUS,
};

use crate::{
    uefi_core::{
        enter_execution_context,
        ExecutionContext,
    },
    utils::{
        press_enter_to_continue,
        set_exit_boot_services,
        show_select,
    },
};

extern crate alloc;

const WINDOWS_BOOTMGR_PATH: &'static [u16] =
    obfstr::wide!("\\efi\\microsoft\\boot\\bootmgfw.efi\0");

type FnExitBootServices =
    unsafe extern "efiapi" fn(image_handle: uefi_raw::Handle, map_key: usize) -> Status;

#[repr(align(4096))]
struct Align4096;

static TARGET_DRIVER: &'static [u8] =
    include_bytes_align_as!(Align4096, r"../driver/driver_uefi.dll");

type StaticTrampolineHook<H> = StaticHook<H, TrampolineHook<H>>;

pub static mut HOOK_IMG_ARCH_START_BOOT_APPLICATION: StaticTrampolineHook<
    ImgArchStartBootApplication,
> = StaticHook::new();
pub static mut HOOK_BL_IMG_ALLOCATE_IMAGE_BUFFER: StaticTrampolineHook<BlImgAllocateImageBuffer> =
    StaticHook::new();
pub static mut HOOK_OSL_FWP_KERNEL_SETUP_PHASE1: StaticTrampolineHook<OslFwpKernelSetupPhase1> =
    StaticHook::new();

/* Called from the boot manager */
extern "efiapi" fn hooked_img_arch_start_boot_application(
    app_entry: *const (),
    image_base: *mut u8,
    image_size: u32,
    boot_option: u8,
    return_arguments: *mut (),
) -> u32 {
    let _exec_guard = enter_execution_context(ExecutionContext::WINBOOTMGR);

    // TODO: Check what image we're loading
    let original = unsafe {
        HOOK_IMG_ARCH_START_BOOT_APPLICATION.disable();
        HOOK_IMG_ARCH_START_BOOT_APPLICATION
            .target()
            .unwrap_unchecked()
    };

    let winload = ImageInfo {
        image_base,
        image_size: image_size as usize,
    };
    if let Err(err) = setup_hooks_winload(winload) {
        log::error!("{:#}", err);
        utils::press_enter_to_continue();
    }

    log::debug!("Calling ImgArchStartBootApplication");
    let result = original(
        app_entry,
        image_base,
        image_size,
        boot_option,
        return_arguments,
    );

    /* If this returns, we're in some kind of recovery mode... */
    log::debug!("Called original ImgArchStartBootApplication");

    result
}

/* Called in WinLoad context */
extern "efiapi" fn hooked_bl_img_allocate_image_buffer(
    image_buffer: *mut *mut u8,
    image_size: usize,
    memory_type: u32,
    attributes: u32,
    unused: u64,
    flags: u32,
) -> NT_STATUS {
    let _guard = enter_execution_context(ExecutionContext::WINLOAD);
    let original = unsafe {
        HOOK_BL_IMG_ALLOCATE_IMAGE_BUFFER.disable();
        HOOK_BL_IMG_ALLOCATE_IMAGE_BUFFER
            .target()
            .unwrap_unchecked()
    };

    // log::debug!(
    //     "BlMemory size: {:X}, type: {:X}, attr: {:X}, unused: {:X}, flags: {:X}",
    //     image_size,
    //     memory_type,
    //     attributes,
    //     unused,
    //     flags
    // );
    let original_result = original(
        image_buffer,
        image_size,
        memory_type,
        attributes,
        unused,
        flags,
    );

    let image_buffer = unsafe { &mut IMAGE_BUFFER };
    if image_buffer.is_some() {
        /* We already have an image buffer for some reason... */
        return original_result;
    }

    if memory_type != BL_MEMORY_TYPE_DRIVER {
        /* Allocation wasnt a driver, we'll wait untill the bootloader tried to allocate a driver buffer */
        unsafe {
            HOOK_BL_IMG_ALLOCATE_IMAGE_BUFFER.enable(hooked_bl_img_allocate_image_buffer);
        };
        return original_result;
    }

    match allocate_image_buffer(original, memory_type, attributes, unused, flags) {
        Ok(buffer) => {
            *image_buffer = Some(buffer);
        }
        Err(err) => {
            log::error!("{}: {:?}", obfstr!("Failed to allocate image buffer"), err);
        }
    }

    original_result
}

fn allocate_image_buffer(
    bl_allocate: BlImgAllocateImageBuffer,
    memory_type: u32,
    attributes: u32,
    unused: u64,
    flags: u32,
) -> anyhow::Result<ImageBuffer> {
    let pe = PeFile::from_bytes(TARGET_DRIVER)
        .map_err(|err| anyhow!("{}: {}", obfstr!("failed to parse packed driver"), err))?;

    let mut image_buffer = ptr::null_mut();
    let image_size = match pe.optional_header() {
        Wrap::T32(header) => header.SizeOfImage,
        Wrap::T64(header) => header.SizeOfImage,
    } as usize;

    log::debug!("{}: {}", obfstr!("Packed driver image size is"), image_size);
    let status = bl_allocate(
        &mut image_buffer,
        image_size,
        memory_type,
        attributes,
        unused,
        flags,
    );

    if status != 0 {
        anyhow::bail!("NT error {:X}", status)
    }

    log::debug!(
        "Allocated packed driver image buffer at {:X}",
        image_buffer as u64
    );
    Ok(ImageBuffer {
        address: image_buffer,
        length: image_size,
    })
}

extern "efiapi" fn hooked_osl_fwp_kernel_setup_phase1(lpb: *mut LoaderParameterBlock) -> u32 {
    let _exec_guard = enter_execution_context(ExecutionContext::WINLOAD);

    let original = unsafe {
        HOOK_OSL_FWP_KERNEL_SETUP_PHASE1.disable();
        HOOK_OSL_FWP_KERNEL_SETUP_PHASE1.target().unwrap_unchecked()
    };

    unsafe {
        MAPPING_RESULT = Some(handle_osl_lpb(lpb));
    }

    original(lpb)
}

static mut ORIGINAL_EXIT_BOOT_SERVICES: Option<FnExitBootServices> = None;

static mut WINLOAD_IMAGE: Option<ImageInfo> = None;
static mut IMAGE_BUFFER: Option<ImageBuffer> = None;
static mut MAPPING_RESULT: Option<anyhow::Result<()>> = None;

mod hook;
mod image_info;
mod signature;
mod uefi_core;
mod utils;
mod wdef;
mod winload;

fn initialize_output() -> uefi::Result<()> {
    let mut system_table = system_table();
    let stdout = system_table.stdout();

    let output_mode = stdout.modes().reduce(|acc, val| {
        if val.columns() * val.rows() < acc.columns() * acc.rows() {
            acc
        } else {
            val
        }
    });

    if let Some(output_mode) = output_mode {
        stdout.set_mode(output_mode)?;
    } else {
        /* Keep the current output mode as a fallback */
    }

    stdout.set_color(Color::White, Color::Blue)?;
    stdout.clear()?;

    Ok(())
}

#[entry]
fn main(handle: Handle, mut system_table: SystemTable<Boot>) -> Status {
    let _exec_guard = enter_execution_context(ExecutionContext::UEFI);
    uefi_core::initialize(&system_table);

    if let Err(err) = real_main(handle, &mut system_table) {
        log::error!("{}", obfstr!("Valthrun bootstrap error"));
        log::error!("{:#}", err);
        press_enter_to_continue();

        Status::LOAD_ERROR
    } else {
        Status::SUCCESS
    }
}

fn real_main(handle: Handle, system_table: &mut SystemTable<Boot>) -> anyhow::Result<()> {
    initialize_output()
        .map_err(|err| anyhow!("{}: {:#?}", obfstr!("Failed to initialize output"), err))?;

    let bs = system_table.boot_services();
    let windows_bootmgr = find_windows_bootmgr(handle, bs)?
        .with_context(|| obfstr!("Could not find Windows boot manager").to_string())?;

    log::debug!(
        "{} {}",
        obfstr!("Windows boot manager located at"),
        *&windows_bootmgr
            .to_string(bs, DisplayOnly(true), AllowShortcuts(false))
            .map_err(|err| anyhow!("{:#}", err))?
            .ok_or_else(|| anyhow!("{}", obfstr!("expected the path to be non empty")))?
    );

    let bootmgr_handle = bs
        .load_image(
            handle,
            LoadImageSource::FromDevicePath {
                device_path: &windows_bootmgr,
                from_boot_manager: true,
            },
        )
        .map_err(|err| {
            anyhow!(
                "{}: {}",
                obfstr!("failed to load Windows boot manager"),
                err
            )
        })?;

    let bootmgr_image = ImageInfo::from_handle(bootmgr_handle.clone())?;
    setup_hooks_bootmgr(bootmgr_image)?;

    log::info!("Invoking bootmgr");
    if let Err(err) = { bs.start_image(bootmgr_handle) } {
        if let Err(err) = bs.unload_image(bootmgr_handle) {
            log::warn!(
                "{}: {:#}",
                obfstr!("Failed to unload Windows bootmgr image"),
                err
            );
        }

        anyhow::bail!(
            "{}: {}",
            obfstr!("failed to invoke Windows boot manager"),
            err
        )
    }

    log::error!(
        "{}",
        obfstr!("The Windows boot manager exited unexpectedly.")
    );
    Ok(())
}

fn get_device_name_from_variable(device_path_raw: &[u8]) -> Option<String> {
    let variable_keys = system_table()
        .runtime_services()
        .variable_keys()
        .map_err(|e| {
            log::warn!("{}: {:?}", obfstr!("Failed to get variable keys"), e);
        })
        .ok()?;

    variable_keys.iter().find_map(|variable_key| {
        // Check if Boot#### variable
        let cstr_name = variable_key.name().ok().filter(|cstr| {
            cstr.to_string().starts_with(obfstr!("Boot"))
                && cstr.to_string().len() == 8
                && variable_key.vendor == uefi_raw::table::runtime::VariableVendor::GLOBAL_VARIABLE
        })?;

        // Get variable contents
        let (data, _) = system_table()
            .runtime_services()
            .get_variable_boxed(&cstr_name, &variable_key.vendor)
            .ok()?;

        // EFI_LOAD_OPTION
        // Attributes(u32): 4 + FilePathListLenght(u16): 2
        let description_start = 6;

        let file_path_list_length = {
            let len = u16::from_le_bytes([data[4], data[5]]) as usize;
            (len != 0).then_some(len)?
        };

        let description = String::from_utf16(
            &data[description_start..]
                .chunks_exact(2)
                .map(|chunk| u16::from_le_bytes([chunk[0], chunk[1]]))
                .take_while(|&u| u != 0)
                .collect::<Vec<u16>>(),
        )
        .ok()?;

        // Attributes + FilePathListLength + Char16 chars * 2 bytes + null terminator (2 bytes)
        let file_path_list_start = description_start + (description.len() * 2) + 2;

        data.len().checked_sub(file_path_list_start).and_then(|_| {
            let file_path_list =
                &data[file_path_list_start..file_path_list_start + file_path_list_length];

            let mut nodes = Vec::new();
            let mut start = 0;

            let node_entire_end: [u8; 4] = [0x7f, 0xff, 0x04, 0x00];

            // Split the nodes
            for i in 0..(file_path_list.len() - 4 + 1) {
                if &file_path_list[i..i + 4] == &node_entire_end {
                    if start < i {
                        nodes.push(&file_path_list[start..i]);
                    }
                    start = i + 4;
                }
            }

            // Check if device_path starts with node
            nodes.iter().find_map(|node| {
                device_path_raw
                    .starts_with(node)
                    .then(|| description.clone())
            })
        })
    })
}

fn find_windows_bootmgr(
    imnage_handle: Handle,
    boot_services: &BootServices,
) -> anyhow::Result<Option<Box<DevicePath>>> {
    let file_systems = boot_services
        .locate_handle_buffer(SearchType::ByProtocol(&SimpleFileSystem::GUID))
        .map_err(|err| anyhow!("{}: {:#}", obfstr!("locating simple fs"), err))?;

    let mut found_devices = Vec::new();
    let windows_bootmgr_path = CStr16::from_u16_with_nul(WINDOWS_BOOTMGR_PATH).unwrap();

    for handle in file_systems.iter() {
        let device_path = boot_services
            .open_protocol_exclusive::<DevicePath>(*handle)
            .map_err(|err| anyhow!("{}: {:#}", obfstr!("open device path"), err))?;

        let file_system = unsafe {
            boot_services.open_protocol::<SimpleFileSystem>(
                OpenProtocolParams {
                    handle: handle.clone(),
                    agent: imnage_handle,
                    controller: None,
                },
                OpenProtocolAttributes::GetProtocol,
            )
        };
        let file_system = match file_system {
            Ok(fs) => fs,
            Err(err) => {
                log::warn!(
                    "{} 0x{:X}: {}",
                    obfstr!("Failed to open simple fs handle"),
                    handle.as_ptr() as u64,
                    err
                );
                continue;
            }
        };
        let file_system = file_system
            .get_mut()
            .expect(obfstr!("the file system to be present"));

        let mut volume = match file_system.open_volume() {
            Ok(volume) => volume,
            Err(err) => {
                log::warn!(
                    "{} 0x{:X}: {:#?}",
                    obfstr!("Failed to open volume for simple fs handle"),
                    handle.as_ptr() as u64,
                    err
                );
                continue;
            }
        };

        let win_handle = volume.open(
            &windows_bootmgr_path,
            FileMode::Read,
            FileAttribute::READ_ONLY,
        );

        if win_handle.is_ok() {
            /* Windows boot manager has been found */
            let device_path_raw: &[u8] = device_path.as_bytes();
            let device_name = get_device_name_from_variable(device_path_raw)
                .unwrap_or_else(|| "unknown".to_string());

            found_devices.push((device_path, device_name));
        }
    }

    if !found_devices.is_empty() {
        let device_index = if found_devices.len() == 1 {
            0
        } else {
            show_select(found_devices.iter().map(|(_, name)| name.clone()).collect())
        };
        let device_path = &found_devices[device_index].0;
        let device_path = device_path
            .get()
            .expect(obfstr!("device path to be present"))
            .to_boxed();

        let mut buffer = Vec::new();

        let file_device_path = device_path.node_iter().fold(
            build::DevicePathBuilder::with_vec(&mut buffer),
            |acc, entry| acc.push(&entry).unwrap(),
        );

        let file_device_path = file_device_path
            .push(&build::media::FilePath {
                path_name: &windows_bootmgr_path,
            })
            .unwrap()
            .finalize()
            .unwrap();

        return Ok(Some(file_device_path.to_boxed()));
    }

    Ok(None)
}

unsafe extern "efiapi" fn hooked_exit_boot_services(
    image_handle: uefi_raw::Handle,
    map_key: usize,
) -> Status {
    let _exec_guard = enter_execution_context(ExecutionContext::UEFI);
    let original_fn = ORIGINAL_EXIT_BOOT_SERVICES.take().expect(obfstr!(
        "the original ExitBootServices callback to be saved"
    ));
    set_exit_boot_services(original_fn);

    fn finish_setup() -> anyhow::Result<()> {
        if unsafe { WINLOAD_IMAGE.is_none() } {
            anyhow::bail!(
                "{} has never been called.",
                obfstr!("ImgArchStartBootApplication")
            );
        }

        unsafe { MAPPING_RESULT.take() }
            .ok_or_else(|| anyhow!("{}", obfstr!("Mapping callback has never been called")))??;

        let image_buffer = unsafe { IMAGE_BUFFER.as_ref() }.with_context(|| {
            obfstr!("Never allocated the target images image buffer").to_string()
        })?;

        log::info!("ExitBootServices has been called.");
        log::info!("Mapped driver at {:X}", image_buffer.address as usize);

        Ok(())
    }

    if let Err(err) = finish_setup() {
        log::error!("Failed to map the Valthrun driver!");
        log::error!("{:#}", err);
        press_enter_to_continue();
    } else {
        log::info!("{}", obfstr!("Valthrun driver successfully mapped."));
        press_enter_to_continue();
        log::info!("Booting Windows...");
    }

    /*
     * Winload does not exists any more.
     * Technically it exists 'till the original exit boot services function
     * returns success else we're trying the next option (max 4).
     */
    winload::finalize();

    (original_fn)(image_handle, map_key)
}

fn setup_hooks_bootmgr(image: ImageInfo) -> anyhow::Result<()> {
    let func_address = image.resolve_signature(&Signature::pattern("ImgArchStartBootApplication", "48 8B C4 48 89 58 ? 44 89 40 ? 48 89 50 ? 48 89 48 ? 55 56 57 41 54 41 55 41 56 41 57 48 8D 68 ? 48 81 EC C0 00 00 00"))?;

    unsafe {
        HOOK_IMG_ARCH_START_BOOT_APPLICATION
            .initialize_trampoline(ImgArchStartBootApplication::from_ptr_usize(func_address));
        HOOK_IMG_ARCH_START_BOOT_APPLICATION.enable(hooked_img_arch_start_boot_application);
    };

    Ok(())
}

fn setup_hooks_winload(image: ImageInfo) -> anyhow::Result<()> {
    winload::initialize(&image)?;

    let bl_img_allocate_image_buffer = [
        Signature::relative_address(
            obfstr!("BlImgAllocateImageBuffer (2600.1252)"),
            obfstr!("E8 ? ? ? ? 4C 8B 75 D8 8B D8 85 C0 0F"),
            0x01,
            0x05,
        ),
        /* Windows 11 */
        Signature::relative_address(
            obfstr!("BlImgAllocateImageBuffer (11)"),
            obfstr!("E8 ? ? ? ? 4C 8B 7D 50 8B"),
            0x01,
            0x05,
        ),
        /* Windows 10 19045.6093 (efi) */
        Signature::relative_address(
            "BlImgAllocateImageBuffer (19045.6093/efi)",
            "E8 ? ? ? ? 4C 8B 6D 50 8B F8",
            0x01,
            0x05,
        ),
        /* Windows 10 19045.6093 (exe) */
        Signature::relative_address(
            "BlImgAllocateImageBuffer (19045.6093/exe)",
            "E8 ? ? ? ? 4C 8B 6D 50",
            0x01,
            0x05,
        ),
        /* Windows 10 19045.4046 (efi) */
        Signature::relative_address(
            obfstr!("BlImgAllocateImageBuffer (19045.4046/efi)"),
            obfstr!("E8 ? ? ? ? 4C 8B 6D 60"),
            0x01,
            0x05,
        ),
        /* Windows 10 19045.4046 (exe) */
        Signature::relative_address(
            obfstr!("BlImgAllocateImageBuffer (19045.4046/exe)"),
            obfstr!("E8 ? ? ? ? 4C 8B 65 50 8B"),
            0x01,
            0x05,
        ),
    ]
    .into_iter()
    .find_map(|sig| image.resolve_signature(&sig).ok())
    .with_context(|| obfstr!("Failed to locate BlImgAllocateImageBuffer signature").to_string())?;

    let osl_fwp_kernel_setup_phase1 = image.resolve_signature(&Signature::pattern(
        obfstr!("OslFwpKernelSetupPhase1"),
        obfstr!("48 89 4C 24 08 55 53 56 57 41 54 41 55 41 56 41 57 48 8D"),
    ))?;

    unsafe {
        WINLOAD_IMAGE = Some(image);

        HOOK_BL_IMG_ALLOCATE_IMAGE_BUFFER.initialize_trampoline(
            BlImgAllocateImageBuffer::from_ptr_usize(bl_img_allocate_image_buffer),
        );
        HOOK_OSL_FWP_KERNEL_SETUP_PHASE1.initialize_trampoline(
            OslFwpKernelSetupPhase1::from_ptr_usize(osl_fwp_kernel_setup_phase1),
        );

        HOOK_BL_IMG_ALLOCATE_IMAGE_BUFFER.enable(hooked_bl_img_allocate_image_buffer);
        HOOK_OSL_FWP_KERNEL_SETUP_PHASE1.enable(hooked_osl_fwp_kernel_setup_phase1);

        ORIGINAL_EXIT_BOOT_SERVICES = Some(set_exit_boot_services(hooked_exit_boot_services));
    }

    Ok(())
}

trait LoaderParameterBlockEx {
    fn find_module(&self, name: &str) -> anyhow::Result<Option<&KLDR_DATA_TABLE_ENTRY>>;
}

impl LoaderParameterBlockEx for LoaderParameterBlock {
    fn find_module(&self, name: &str) -> anyhow::Result<Option<&KLDR_DATA_TABLE_ENTRY>> {
        let mut current_entry = self.LoadOrderListHead.Flink;

        while current_entry as *const _ != &self.LoadOrderListHead {
            let entry = unsafe {
                current_entry
                    .cast::<KLDR_DATA_TABLE_ENTRY>()
                    .as_ref()
                    .with_context(|| obfstr!("flink not to be null").to_string())?
            };
            current_entry = unsafe { current_entry.as_ref() }
                .with_context(|| obfstr!("flink not to be null").to_string())?
                .Flink;

            let base_image_name = unsafe {
                slice::from_raw_parts(
                    entry.BaseImageName.Buffer,
                    (entry.BaseImageName.Length / 2) as usize,
                )
            };

            let image_name = String::from_utf16_lossy(base_image_name);
            if image_name == name {
                return Ok(Some(entry));
            }
        }

        return Ok(None);
    }
}

fn handle_osl_lpb(lpb: *mut LoaderParameterBlock) -> anyhow::Result<()> {
    log::debug!("handle_osl_lpb called with {:X}", lpb as u64);

    let lpb = unsafe { &*lpb };
    let hijacked_driver = lpb
        .find_module("acpiex.sys")?
        .with_context(|| obfstr!("could not find the windows kernel module").to_string())?;

    {
        let full_image_name = unsafe {
            slice::from_raw_parts(
                hijacked_driver.BaseImageName.Buffer as *mut u16,
                (hijacked_driver.BaseImageName.Length / 2) as usize,
            )
        };

        let hijacked_image_base = hijacked_driver.ImageBase;
        log::debug!(
            "Hijacked driver at {:X} ({})",
            hijacked_image_base as u64,
            String::from_utf16_lossy(full_image_name)
        );
    }

    let hijacked_driver_memory = unsafe {
        slice::from_raw_parts_mut(
            hijacked_driver.ImageBase as *mut u8,
            hijacked_driver.SizeOfImage as usize,
        )
    };

    let image_buffer = unsafe { IMAGE_BUFFER.as_mut() }
        .with_context(|| obfstr!("Expected to have allocated memory").to_string())?;
    let base_address = image_buffer.address as u64;
    map_custom_driver(
        hijacked_driver_memory,
        &TARGET_DRIVER,
        image_buffer.as_slice_mut(),
        base_address,
    )
    .with_context(|| obfstr!("mapping error").to_string())?;

    Ok(())
}

/*
 * Map the specially crafted / designed driver.
 * The driver needs to have the following properties:
 * 1. Do not rely on any external imports.
 *    Imports are not getting resolved.
 * 2. Do not rely on any sections other then .text and .data.
 *    All other sections will not be mapped, including the PE header.
 * 3. SEH is not available.
 */
fn map_custom_driver(
    hijacked_driver: &mut [u8],
    target_driver_file: &[u8],
    memory: &mut [u8],
    base_address: u64,
) -> anyhow::Result<()> {
    /* fill the memory with all zeros */
    memory.fill(0x00);

    let pe = PeFile::from_bytes(target_driver_file).map_err(Error::msg)?;

    /* map the sections */
    log::debug!("Mapping {} sections", pe.section_headers().as_slice().len());
    {
        for section in pe.section_headers() {
            let section_name = String::from_utf8_lossy(section.name_bytes()).to_string();
            let should_map = match section_name.as_str() {
                ".text" => true,
                ".data" => true,
                _ => true,
            };

            if !should_map {
                log::debug!(" Skipping {}", section_name);
                continue;
            }

            if (section.VirtualAddress + section.SizeOfRawData) as usize > memory.len() {
                anyhow::bail!("section {} is longer then the available memory (va: {:X}, size: {:X}, memory: {:X})", section_name, section.VirtualAddress, section.SizeOfRawData, memory.len());
            }

            if (section.PointerToRawData + section.SizeOfRawData) as usize
                > target_driver_file.len()
            {
                anyhow::bail!("section {} references invalid data (raw data: {:X}, size: {:X}, file length: {:X})", section_name, section.VirtualAddress, section.SizeOfRawData, target_driver_file.len());
            }

            let section_memory = &mut memory[section.VirtualAddress as usize
                ..(section.VirtualAddress + section.SizeOfRawData) as usize];
            let section_data = &target_driver_file[section.PointerToRawData as usize
                ..(section.PointerToRawData + section.SizeOfRawData) as usize];
            section_memory.copy_from_slice(section_data);

            log::debug!(" Mapped {}", section_name);
        }
    }

    /* Relocations */
    let relocs = pe.base_relocs().map_err(Error::msg)?;
    for reloc_block in relocs.iter_blocks() {
        for reloc in reloc_block.words() {
            match reloc_block.type_of(reloc) {
                0x00 => {
                    /* IMAGE_REL_BASED_ABSOLUTE */
                    continue;
                }
                0x0A => {
                    /* IMAGE_REL_BASED_DIR64 */
                    let rva = reloc_block.rva_of(reloc) as usize;
                    let value = u64::from_le_bytes(memory[rva..rva + 8].try_into().unwrap());
                    let image_base = match pe.optional_header() {
                        Wrap::T32(header) => header.ImageBase as u64,
                        Wrap::T64(header) => header.ImageBase as u64,
                    };

                    if value < image_base {
                        /*
                         * This can occurr because of two reasons:
                         * 1. The section has not been mapped
                         * 2. The relocation is invalid
                         */
                        continue;
                    }

                    let new_address = base_address + value - image_base;
                    memory[rva..rva + 8].copy_from_slice(&new_address.to_le_bytes());
                }
                reloc_type => {
                    anyhow::bail!("{} {:X}", obfstr!("Unsupported reloc type"), reloc_type)
                }
            }
        }
    }

    /* Hijack the target driver and save original instructions to the mapped driver */
    {
        let rva_hijacked_entry_point = {
            let hijacked_pe = PeView::from_bytes(hijacked_driver)
                .map_err(Error::msg)
                .with_context(|| obfstr!("hijacked driver").to_string())?;

            match hijacked_pe.optional_header() {
                Wrap::T32(header) => header.AddressOfEntryPoint,
                Wrap::T64(header) => header.AddressOfEntryPoint,
            }
        } as usize;

        let rva_driver_entry_point = match pe.optional_header() {
            Wrap::T32(header) => header.AddressOfEntryPoint,
            Wrap::T64(header) => header.AddressOfEntryPoint,
        } as usize;

        let exports = pe.exports().map_err(Error::msg)?.by().map_err(Error::msg)?;
        let rva_original_entry_bytes = exports
            .name_linear("_ENTRY_BYTES")
            .ok()
            .with_context(|| obfstr!("Could not find _ENTRY_BYTES export").to_string())?
            .symbol()
            .with_context(|| obfstr!("Expected the _ENTRY_BYTES to be a symbol").to_string())?
            as usize;

        /* Store the original entry point data */
        const DRIVER_ENTRYPOINT_BUFFER_SIZE: usize = 0x20;
        memory[rva_original_entry_bytes..rva_original_entry_bytes + DRIVER_ENTRYPOINT_BUFFER_SIZE]
            .copy_from_slice(
                &hijacked_driver[rva_hijacked_entry_point
                    ..rva_hijacked_entry_point + DRIVER_ENTRYPOINT_BUFFER_SIZE],
            );

        let mut instructions = Vec::<u8>::with_capacity(DRIVER_ENTRYPOINT_BUFFER_SIZE);

        {
            /* lea r8, [rip-7] */
            instructions.extend(&[0x4C, 0x8D, 0x05, 0xF9, 0xFF, 0xFF, 0xFF]);

            // /* nop */
            // instructions.push(0xCC);

            /* jmp DWORD PTR ds:0x0 */
            instructions.extend(&[0xFF, 0x25, 0x00, 0x00, 0x00, 0x00]);

            /* the target address */
            instructions.extend(&(base_address + rva_driver_entry_point as u64).to_le_bytes());
        }

        if instructions.len() > DRIVER_ENTRYPOINT_BUFFER_SIZE {
            anyhow::bail!(
                "{}",
                obfstr!("shellcode is longer then saved entry point bytes")
            )
        }

        hijacked_driver[rva_hijacked_entry_point..rva_hijacked_entry_point + instructions.len()]
            .copy_from_slice(&instructions);

        log::debug!(
            "Hijacked driver entry point at {:X}. Original bytes at {:X}",
            hijacked_driver.as_ptr() as usize + rva_hijacked_entry_point,
            memory.as_ptr() as usize + rva_original_entry_bytes
        );
    }

    Ok(())
}

```

`src/signature.rs`:

```rs
#![allow(dead_code)]
use alloc::{
    boxed::Box,
    string::String,
    vec::Vec,
};

pub trait SearchPattern: Sync {
    fn length(&self) -> usize;
    fn is_matching(&self, target: &[u8]) -> bool;

    fn find(&self, buffer: &[u8]) -> Option<usize> {
        if self.length() > buffer.len() {
            return None;
        }

        for (index, window) in buffer.windows(self.length()).enumerate() {
            if !self.is_matching(window) {
                continue;
            }

            return Some(index as usize);
        }

        None
    }
}

#[derive(Debug)]
pub enum BytePattern {
    Any,
    Value(u8),
}

impl BytePattern {
    pub fn matches_byte(&self, target: u8) -> bool {
        match self {
            BytePattern::Any => true,
            BytePattern::Value(expected) => target == *expected,
        }
    }

    pub fn parse(pattern: &str) -> Option<BytePattern> {
        if pattern == "?" || pattern == "??" {
            Some(BytePattern::Any)
        } else if let Ok(value) = u8::from_str_radix(pattern, 16) {
            Some(BytePattern::Value(value))
        } else {
            None
        }
    }
}

impl SearchPattern for BytePattern {
    fn length(&self) -> usize {
        1
    }

    fn is_matching(&self, target: &[u8]) -> bool {
        self.matches_byte(target[0])
    }
}

#[derive(Debug)]
pub struct ByteSequencePattern {
    bytes: Vec<BytePattern>,
}

impl ByteSequencePattern {
    pub fn parse(pattern: &str) -> Option<ByteSequencePattern> {
        pattern
            .split(" ")
            .map(BytePattern::parse)
            .collect::<Option<Vec<_>>>()
            .map(|bytes| Self { bytes })
    }
}

impl SearchPattern for ByteSequencePattern {
    fn length(&self) -> usize {
        self.bytes.len()
    }

    fn is_matching(&self, target: &[u8]) -> bool {
        self.bytes
            .iter()
            .zip(target.iter())
            .find(|(pattern, value)| !pattern.matches_byte(**value))
            .is_none()
    }
}

pub enum SignatureType {
    /// The value is an address relative to the current instruction.
    /// When resolved the absolute address the instruction pointed towards will be returned.
    RelativeAddress { inst_length: usize },

    /// The value is an offset within a struct.
    /// (Offsets are assumed to be u32)
    Offset,

    /// Resolve the absolute address of the beginning of the target pattern
    Pattern,
}

/// A signature which leads to an offset or address
/// based on a sequence of instructions.
pub struct Signature {
    pub debug_name: String,
    pub pattern: Box<dyn SearchPattern>,
    pub offset: u64,
    pub value_type: SignatureType,
}

impl Signature {
    /// Create a new relative address signature from a byte sequence pattern.
    /// Note: If the pattern is invalid this will panic!
    pub fn relative_address(
        debug_name: impl Into<String>,
        pattern: &str,
        offset: u64,
        inst_length: usize,
    ) -> Self {
        let pattern = Box::new(ByteSequencePattern::parse(pattern).expect("to be a valid pattern"));

        Self {
            debug_name: debug_name.into(),
            pattern,
            offset,
            value_type: SignatureType::RelativeAddress { inst_length },
        }
    }

    pub fn offset(debug_name: impl Into<String>, pattern: &str, offset: u64) -> Self {
        let pattern = Box::new(ByteSequencePattern::parse(pattern).expect("to be a valid pattern"));

        Self {
            debug_name: debug_name.into(),
            pattern,
            offset,
            value_type: SignatureType::Offset,
        }
    }

    pub fn pattern(debug_name: impl Into<String>, pattern: &str) -> Self {
        let pattern = Box::new(ByteSequencePattern::parse(pattern).expect("to be a valid pattern"));

        Self {
            debug_name: debug_name.into(),
            pattern,
            offset: 0x00,
            value_type: SignatureType::Pattern,
        }
    }
}

```

`src/uefi_core/allocator.rs`:

```rs
use core::alloc::GlobalAlloc;

use uefi::allocator::Allocator as UefiAllocator;

use super::{
    current_execution_context,
    ExecutionContext,
};
use crate::winload::{
    self,
    WinloadContext,
};

/// Allocator which supports
/// allocations within the WINLOAD context.
struct WinUefiAllocator {
    inner: UefiAllocator,
}

unsafe impl GlobalAlloc for WinUefiAllocator {
    unsafe fn alloc(&self, layout: core::alloc::Layout) -> *mut u8 {
        if matches!(current_execution_context(), ExecutionContext::WINLOAD) {
            let _context = winload::enter_context(WinloadContext::FirmwareExecutionContext);
            self.inner.alloc(layout)
        } else {
            self.inner.alloc(layout)
        }
    }

    unsafe fn dealloc(&self, ptr: *mut u8, layout: core::alloc::Layout) {
        if matches!(current_execution_context(), ExecutionContext::WINLOAD) {
            let _context = winload::enter_context(WinloadContext::FirmwareExecutionContext);
            self.inner.dealloc(ptr, layout)
        } else {
            self.inner.dealloc(ptr, layout)
        }
    }
}

#[global_allocator]
static ALLOCATOR: WinUefiAllocator = WinUefiAllocator {
    inner: UefiAllocator {},
};

```

`src/uefi_core/context.rs`:

```rs
#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Clone, Copy)]
pub enum ExecutionContext {
    UNKNOWN,
    UEFI,
    WINBOOTMGR,
    WINLOAD,
}

static mut CURRENT_CONTEXT: ExecutionContext = ExecutionContext::UNKNOWN;

pub fn current_execution_context() -> ExecutionContext {
    unsafe { CURRENT_CONTEXT }
}

#[must_use]
pub fn enter_execution_context(context: ExecutionContext) -> ExecutionContextGuard {
    let guard = ExecutionContextGuard {
        previous: current_execution_context(),
    };
    unsafe { CURRENT_CONTEXT = context };
    guard
}

pub struct ExecutionContextGuard {
    previous: ExecutionContext,
}

impl Drop for ExecutionContextGuard {
    fn drop(&mut self) {
        unsafe {
            CURRENT_CONTEXT = self.previous;
        }
    }
}

```

`src/uefi_core/logger.rs`:

```rs
use alloc::{
    format,
    vec::Vec,
};

use uefi::CStr16;

use super::system_table;
use crate::{
    uefi_core::context::{
        current_execution_context,
        enter_execution_context,
        ExecutionContext,
    },
    winload::{
        self,
        WinloadContext,
    },
};

pub struct KernelLogger;

impl log::Log for KernelLogger {
    fn enabled(&self, metadata: &log::Metadata) -> bool {
        if cfg!(debug_assertions) {
            true
        } else {
            metadata.level() <= log::Level::Debug
        }
    }

    fn log(&self, record: &log::Record) {
        if !self.enabled(record.metadata()) {
            return;
        }

        match current_execution_context() {
            ExecutionContext::UNKNOWN | ExecutionContext::UEFI | ExecutionContext::WINBOOTMGR => {
                /* we're good to go :) */
            }
            ExecutionContext::WINLOAD => {
                let _guard = winload::enter_context(WinloadContext::FirmwareExecutionContext);
                let _context = enter_execution_context(ExecutionContext::UEFI);

                self.log(record);
                return;
            }
        }

        let level_prefix = match record.level() {
            log::Level::Trace => "T",
            log::Level::Debug => "D",
            log::Level::Info => "I",
            log::Level::Warn => "W",
            log::Level::Error => "E",
        };
        let payload = if cfg!(debug_assertions) {
            format!("[{}] {}\r\n\0", level_prefix, record.args())
        } else {
            format!("[{}] {}\r\n\0", level_prefix, record.args())
        };

        let payload = payload.encode_utf16().collect::<Vec<_>>();
        let _ = system_table()
            .stdout()
            .output_string(&unsafe { CStr16::from_u16_with_nul_unchecked(&payload) });
    }

    fn flush(&self) {}
}

pub static APP_LOGGER: KernelLogger = KernelLogger;

```

`src/uefi_core/mod.rs`:

```rs
use uefi::table::{
    Boot,
    SystemTable,
};

mod allocator;
mod context;
mod logger;
mod panic;
mod system_table;

pub use context::*;
pub use system_table::*;

use self::logger::APP_LOGGER;

pub fn initialize(system_table: &SystemTable<Boot>) {
    system_table::setup_system_table(&system_table);
    unsafe { uefi::allocator::init(system_table.boot_services()) };

    let _ = log::set_logger(&APP_LOGGER);
    log::set_max_level(log::STATIC_MAX_LEVEL);
}

```

`src/uefi_core/panic.rs`:

```rs
use alloc::format;
use core::{
    arch::asm,
    sync::atomic::{
        AtomicUsize,
        Ordering,
    },
};

use uefi::CStr16;

use super::{
    current_execution_context,
    enter_execution_context,
    system_table_opt,
    ExecutionContext,
};
use crate::winload::{
    self,
    WinloadContext,
};

static PANIC_COUNT: AtomicUsize = AtomicUsize::new(0);

#[panic_handler]
fn panic_handler(info: &core::panic::PanicInfo) -> ! {
    if PANIC_COUNT.fetch_add(1, Ordering::Relaxed) > 0 {
        /* a panic occurred within a panic... */
        loop {
            unsafe { asm!("int 3") };
        }
    }

    panic_handler_impl(info)
}

fn panic_handler_impl(info: &core::panic::PanicInfo) -> ! {
    if current_execution_context() == ExecutionContext::WINLOAD {
        let _guard = winload::enter_context(WinloadContext::FirmwareExecutionContext);
        let _context = enter_execution_context(ExecutionContext::UEFI);
        panic_handler_impl(info);
    }

    let mut system_table = match system_table_opt() {
        Some(st) => st,
        None => loop {
            unsafe { asm!("int 3") };
        },
    };

    /* Write a panic message without any allocations in case something within the allocator paniced */
    {
        let buffer = obfstr::wide!("PANIC OCCURRED!\n\r\0");
        let message = unsafe { CStr16::from_u16_with_nul(buffer).unwrap_unchecked() };
        let _ = system_table.stdout().output_string(message);
    }

    let message = format!("{}", info);
    for line in message.lines() {
        log::error!("{}", line);
    }

    system_table.boot_services().stall(10_000_000);
    loop {
        unsafe { asm!("int 3") };
    }
}

```

`src/uefi_core/system_table.rs`:

```rs
use core::{
    ffi::c_void,
    sync::atomic::{
        AtomicPtr,
        Ordering,
    },
};

use uefi::table::{
    Boot,
    SystemTable,
};

use crate::uefi_core::{
    current_execution_context,
    ExecutionContext,
};

static SYSTEM_TABLE: AtomicPtr<c_void> = AtomicPtr::new(core::ptr::null_mut());

pub fn setup_system_table(system_table: &SystemTable<Boot>) {
    SYSTEM_TABLE.store(
        unsafe { core::mem::transmute_copy(system_table) },
        Ordering::Release,
    );
}

#[must_use]
pub fn system_table_opt() -> Option<SystemTable<Boot>> {
    let ptr = SYSTEM_TABLE.load(Ordering::Acquire);
    // Safety: the `SYSTEM_TABLE` pointer either be null or a valid system
    // table.
    //
    // Null is the initial value, as well as the value set when exiting boot
    // services. Otherwise, the value is set by the call to `init`, which
    // requires a valid system table reference as input.
    unsafe { SystemTable::from_ptr(ptr) }
}

/// Obtains a pointer to the system table.
///
/// This is meant to be used by higher-level libraries,
/// which want a convenient way to access the system table singleton.
///
/// `init` must have been called first by the UEFI app.
///
/// The returned pointer is only valid until boot services are exited.
#[must_use]
pub fn system_table() -> SystemTable<Boot> {
    assert!(matches!(
        current_execution_context(),
        ExecutionContext::UEFI | ExecutionContext::UNKNOWN | ExecutionContext::WINBOOTMGR
    ));
    system_table_opt().expect("The system table handle is not available")
}

```

`src/utils.rs`:

```rs
use alloc::{
    string::String,
    vec::Vec,
};
use core::mem;

use obfstr::obfstr;
use uefi::proto::console::text::{
    Key,
    ScanCode,
};

use crate::{
    system_table,
    FnExitBootServices,
};

pub fn show_select(devices_name: Vec<String>) -> usize {
    system_table().stdout().enable_cursor(false).ok();

    let mut init = true;
    let mut current_index: usize = 0;

    let enter_key = uefi::Char16::try_from('\r').unwrap();

    while let Ok(event) = system_table().stdin().read_key() {
        if init {
            init = false;
        } else {
            let key = match event {
                Some(key) => key,
                None => continue,
            };

            match key {
                Key::Printable(ch) if ch == enter_key => return current_index,

                Key::Special(ScanCode::DOWN) if current_index < devices_name.len() - 1 => {
                    current_index += 1
                }

                Key::Special(ScanCode::UP) if current_index > 0 => current_index -= 1,

                _ => continue,
            }
        }

        system_table().stdout().clear().ok();

        log::info!(
            "{}",
            obfstr!("\r  Arrow Up/Down: Move cursor\r\n  Enter: Select\n")
        );
        log::info!("{}", obfstr!("\r  Select device:"));

        for (i, device_name) in devices_name.iter().enumerate() {
            log::info!(
                "{} {} {}: ({})",
                if i == current_index { "\r>" } else { "\r " },
                obfstr!("Device"),
                i + 1,
                device_name
            );
        }
    }
    current_index
}

pub fn press_enter_to_continue() {
    log::info!("Press F10 to continue");
    while let Ok(event) = system_table().stdin().read_key() {
        let key = match event {
            Some(key) => key,
            None => continue,
        };

        if matches!(key, Key::Special(ScanCode::FUNCTION_10)) {
            break;
        }
    }
}

pub fn set_exit_boot_services(target: FnExitBootServices) -> FnExitBootServices {
    let raw_bs = unsafe {
        mem::transmute_copy::<_, &mut uefi_raw::table::boot::BootServices>(
            &system_table().boot_services(),
        )
    };

    mem::replace(&mut raw_bs.exit_boot_services, target)
}

#[repr(C)] // guarantee 'bytes' comes after '_align'
pub struct AlignedAs<Align, Bytes: ?Sized> {
    pub _align: [Align; 0],
    pub bytes: Bytes,
}

macro_rules! include_bytes_align_as {
    ($align_ty:ty, $path:literal) => {{
        // const block expression to encapsulate the static
        use $crate::utils::AlignedAs;

        // this assignment is made possible by CoerceUnsized
        static ALIGNED: &AlignedAs<$align_ty, [u8]> = &AlignedAs {
            _align: [],
            bytes: *include_bytes!($path),
        };

        &ALIGNED.bytes
    }};
}
pub(crate) use include_bytes_align_as;

```

`src/wdef.rs`:

```rs
#![allow(unused)]
//! Windows kernel and loader definitions

#[repr(C)]
#[allow(non_snake_case)]
pub struct ListEntry {
    pub Flink: *mut ListEntry,
    pub Blink: *mut ListEntry,
}

#[repr(C)]
#[allow(non_snake_case)]
pub struct LoaderParameterBlock {
    pub OsMajorVersion: u32,
    pub OsMinorVersion: u32,
    pub Size: u32,
    pub OsLoaderSecurityVersion: u32,
    pub LoadOrderListHead: ListEntry,
}

#[repr(C)]
#[allow(non_snake_case, non_camel_case_types)]
pub struct KLDR_DATA_TABLE_ENTRY {
    pub InLoadOrderLinks: ListEntry,
    pub ExceptionTable: *const (),
    pub ExceptionTableSize: u32,
    pub GpValue: *const (),
    pub NonPagedDebugInfo: *const (),
    pub ImageBase: *const (),
    pub EntryPoint: *const (),
    pub SizeOfImage: u32,
    pub FullImageName: UNICODE_STRING,
    pub BaseImageName: UNICODE_STRING,
}

#[repr(C)]
#[allow(non_snake_case, non_camel_case_types)]
pub struct UNICODE_STRING {
    pub Length: u16,
    pub MaximumLength: u16,
    pub Buffer: *mut u16,
}

#[allow(non_camel_case_types)]
pub type NT_STATUS = i32;

pub type ImgArchStartBootApplication = extern "efiapi" fn(
    app_entry: *const (),
    image_base: *mut u8,
    image_size: u32,
    boot_option: u8,
    return_arguments: *mut (),
) -> u32;

pub type BlImgAllocateImageBuffer = extern "efiapi" fn(
    image_buffer: *mut *mut u8,
    image_size: usize,
    memory_type: u32,
    attributes: u32,
    unused: u64,
    flags: u32,
) -> NT_STATUS;

pub type OslFwpKernelSetupPhase1 = extern "efiapi" fn(lpb: *mut LoaderParameterBlock) -> u32;

pub const BL_MEMORY_TYPE_KERNEL: u32 = 0xE0000012; /* ntoskrnl.exe, kdstub.dll, kdcom.dll, hal.dll, mcupdate.dll */
pub const BL_MEMORY_TYPE_DRIVER: u32 = 0xE0000013; /* all other normal drivers */
pub const BL_MEMORY_TYPE_KERNEL_SECURE: u32 = 0xE0000022;
pub const BL_MEMORY_ATTRIBUTE_RWX: u32 = 0x424000; /* Value taken from a dummy bl img allocate buffer call with driver type */

```

`src/winload.rs`:

```rs
use alloc::string::ToString;

use anyhow::Context;
use obfstr::obfstr;

use crate::{
    signature::Signature,
    ImageInfo,
};

type FnBlpArchSwitchContext = unsafe extern "efiapi" fn(ContextId: u32);

static mut CURRENT_EXECUTION_CONTEXT: Option<*mut u32> = None;
static mut BLP_ARCH_SWITCH_CONTEXT: Option<FnBlpArchSwitchContext> = None;

pub fn initialize(image: &ImageInfo) -> anyhow::Result<()> {
    let current_execution_context = [
        Signature::relative_address(
            obfstr!("CurrentExecutionContext (2600.1252)"),
            obfstr!("48 8B 05 ? ? ? ? 48 85 C0 74 57"),
            0x03,
            0x07,
        ),
        Signature::relative_address(
            obfstr!("CurrentExecutionContext"),
            obfstr!("48 8B 05 ? ? ? ? 4C 8D 7D D0"),
            0x03,
            0x07,
        ),
    ]
    .iter()
    .find_map(|sig| image.resolve_signature(sig).ok())
    .map(|v| unsafe { core::mem::transmute(v) })
    .with_context(|| obfstr!("Failed to find CurrentExecutionContext").to_string())?;

    let blp_arch_switch_context = [
        Signature::relative_address(
            obfstr!("BlpArchSwitchContext (2600.1252)"),
            obfstr!("E8 ? ? ? ? 48 8B 15 ? ? ? ? 4C 8B"),
            0x01,
            0x05,
        ),
        Signature::relative_address(
            obfstr!("BlpArchSwitchContext"),
            obfstr!("E8 ? ? ? ? 48 8B 43 08 49"),
            0x01,
            0x05,
        ),
    ]
    .iter()
    .find_map(|sig| image.resolve_signature(sig).ok())
    .map(|v| unsafe { core::mem::transmute(v & 0xFFFFFF) })
    .with_context(|| obfstr!("Failed to find BlpArchSwitchContext").to_string())?;

    unsafe {
        CURRENT_EXECUTION_CONTEXT = Some(current_execution_context);
        BLP_ARCH_SWITCH_CONTEXT = Some(blp_arch_switch_context);
    }

    Ok(())
}

pub fn finalize() {
    unsafe {
        CURRENT_EXECUTION_CONTEXT = None;
        BLP_ARCH_SWITCH_CONTEXT = None;
    }
}

pub struct WinloadContextGuard {
    original_context: Option<u32>,
}

impl WinloadContextGuard {
    fn enter_context(target_context: u32) -> Self {
        let current_context = unsafe {
            CURRENT_EXECUTION_CONTEXT
                .clone()
                .map(|level| level.read_volatile())
                .unwrap_or(target_context)
        };

        if current_context == target_context {
            Self {
                original_context: None,
            }
        } else if let Some(switch_context) = unsafe { BLP_ARCH_SWITCH_CONTEXT } {
            unsafe {
                switch_context(target_context);
            }

            Self {
                original_context: Some(current_context),
            }
        } else {
            /* CURRENT_EXECUTION_CONTEXT is initialized, but BLP_ARCH_SWITCH_CONTEXT isnt... */
            Self {
                original_context: None,
            }
        }
    }
}

impl Drop for WinloadContextGuard {
    fn drop(&mut self) {
        if let Some(original) = self.original_context.take() {
            if let Some(switch_context) = unsafe { BLP_ARCH_SWITCH_CONTEXT } {
                unsafe {
                    (switch_context)(original);
                }
            }
        }
    }
}

#[allow(dead_code)]
pub enum WinloadContext {
    /// Winload context with virtual address space.
    ApplicationExecutionContext,

    /// EFI context, required for all EFI functions
    /// (physical address space)
    FirmwareExecutionContext,
}

impl WinloadContext {
    fn context_id(&self) -> u32 {
        match self {
            Self::ApplicationExecutionContext => 0,
            Self::FirmwareExecutionContext => 1,
        }
    }
}

pub fn enter_context(target_context: WinloadContext) -> WinloadContextGuard {
    WinloadContextGuard::enter_context(target_context.context_id())
}

#[allow(dead_code)]
pub fn assert_context(target_context: WinloadContext) {
    if let Some(context) = unsafe { CURRENT_EXECUTION_CONTEXT.clone() } {
        let current_context = unsafe { context.read_volatile() };
        if current_context != target_context.context_id() {
            let _guard = self::enter_context(WinloadContext::FirmwareExecutionContext);
            panic!(
                "{} {:X} but it is {:X}",
                obfstr!("Expected the winload context to be"),
                target_context.context_id(),
                current_context
            );
        }
    }
}

```