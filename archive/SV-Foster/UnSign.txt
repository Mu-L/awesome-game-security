Project Path: arc_SV-Foster_UnSign_b6m6eklq

Source Tree:

```txt
arc_SV-Foster_UnSign_b6m6eklq
├── Documents
│   ├── file signature before and after.png
│   ├── screenshot 001.png
│   └── screenshot 002.png
├── EULA.txt
├── README.md
├── unsign-exe-IA-32
├── unsign-exe-x86-64
├── unsign-obj-IA-32
├── unsign-obj-x86-64
├── unsign-src
│   ├── CommandLineInterface.c
│   ├── CommandLineInterface.h
│   ├── GlobalOptions.c
│   ├── GlobalOptions.h
│   ├── LanguageRes.c
│   ├── LanguageRes.h
│   ├── Main.c
│   ├── Main.h
│   ├── SharedHeaders.h
│   ├── resource.h
│   ├── resource.rc
│   ├── unsign.vcxproj
│   ├── unsign.vcxproj.filters
│   └── unsign.vcxproj.user
├── unsign-test-scripts
└── unsign.sln

```

`EULA.txt`:

```txt
Copyright SV Foster, 2023-2025.
All rights reserved.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Redistribution and use in source and/or binary forms of the program, without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the disclaimer above.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the disclaimer above in the
   documentation and/or other materials provided with the distribution.
3. Source code, binary form of the program, documentation and/or other
   materials provided with the distribution of the program are used for
   personal, educational and/or non-profit usage.

```

`README.md`:

```md
# Windows executable files unsinging tool

Revolutionary command line tool for Windows that is set to change the way developers work with executable files like .exe, .dll, .sys, .drv and others, both 32 and 64 bit. With the ability to completely strip embedded signatures, including all sections of the signature, this program allows for uncompromised control over the signing process!

![Screenshot](Documents/file%20signature%20before%20and%20after.png)

No longer will developers be limited by pesky digital signatures that are difficult to remove. UnSign tool gives users the power to easily and effectively strip away all traces of a signature, leaving behind a clean and pristine executable file, library or driver.

But that's not all — UnSign tool also offers a solution to the frustrating "optional PE header problem" that has plagued developers for years. This problem often renders an executable file unsingable, leaving developers scratching their heads and searching for a solution. With UnSign tool, this issue becomes a thing of the past, as it provides a comprehensive fix for the problem, ensuring that executable files can be signed again without any hiccups.

Say goodbye to the limitations and frustrations that come with Windows executable files signatures. UnSign tool takes the power back into the hands of developers, allowing for seamless and hassle-free unsinging processes. Whether you're a seasoned developer or just getting started, UnSign tool is a must-have tool for anyone working with PE32/PE32+ format executable files.


## Usage

UnSign is the command line tool. Open command prompt, navigate to UnSign's .exe folder with the `cd` command and start the tool with following parameters:

```
Usage: unsign /<switch 1> /<switch N> <PE32/PE32+ executable file>

<Switches>
  /NoLogo       Don't print copyright logo
  /NoCertPrint  Don't exam and print certificates on the file
  /CRC          Checksum recalculation policy
                  Zero    - forcefully zero out the CRC field in the optional PE header
                  Calc    - always recalculate the valid checksum
                  Default - recalculate the checksum only if it was not 0 (default)
```

WARNING: This program will modify the file inplace on the disk! Please create a backup copy if you want to preserve the original file!

Any version of the tool, 32 or 64 bit, works with both 32 and 64 bit executables (in PE32 and PE32+ format, also called PE/PE+ or PE/COFF).

![Screenshot](Documents/screenshot%20001.png)
![Screenshot](Documents/screenshot%20002.png)


## What's new

### Version 1.2

* Added the CRC of the executable file recalculation feature
* Added the friendly error message if switches were set but no file was provided to process
* Some spelling fixed

### Version 1.1

* Added the check for the number of directories in the PE32/PE32+ optional header, as suggested by documentation


## Building

UnSign tool uses the `Microsoft Visual Studio 2022` for its builds.

To build UnSign tool from source files with Microsoft Visual Studio, you can use either the graphical or the command-line mode. Here are the instructions for both methods:

### Graphical mode
1. Open Microsoft Visual Studio and select `Open a project or solution` from the start page or the `File` menu
2. Browse to the folder where the `unsign.sln` file is located and select it. This will load the project in Microsoft Visual Studio
3. Select the `configuration` and `platform` for the project by using the drop-down menus on the toolbar. For example, you can choose Debug or Release for the configuration, and x86 or x64 for the platform
4. Build the project by clicking on the `Build` menu and selecting `Build Solution`. You can also use the keyboard shortcut `Ctrl+Shift+B`
5. Run the project by clicking on the `Debug` menu and selecting `Start Debugging`. You can also use the keyboard shortcut `F5`

### Command-line mode
1. Open a `Developer Command Prompt` for Microsoft Visual Studio. You can find it in the Start menu under Microsoft Visual Studio Tools
2. Navigate to the folder where the `unsign.sln` file is located by using the `cd` command
3. Invoke the MSBuild tool to build the project. You can specify various options and flags for the tool. For example, the following command builds the project with the Release configuration and the x64 platform:
```
msbuild unsign.sln /p:Configuration=Release /p:Platform=x64
```
4. Run your executable by typing its name and path in the command prompt. For example:
```
unsign-exe-x86-64\unsign /?
```


## Authors

This program was written and is maintained by SV Foster.


## License

This program is available under EULA, see [EULA text file](EULA.txt) for the complete text of the license. This program is free for personal, educational and/or non-profit usage.

```

`unsign-src/CommandLineInterface.c`:

```c
/***

Copyright SV Foster, 2023-2025. All rights reserved.

License:
    This program is free for personal, educational and/or non-profit usage

Revision History:
	Rev 0, DEC 2023
	   First revision

	Rev 1, MAR 2024
	   Code refactoring

	Rev 2, OCT 2025
	   Added support for /CRC parameter
	   Code refactoring

***/

#include "CommandLineInterface.h"

#pragma comment(lib, "Version.lib")

#pragma warning( disable : 6255 ) // suppress the _alloca() warning


VOID CLIWorkModeGet(CONST DWORD argc, LPCTSTR argv[], PGlobalOptions glo)
{
	glo->OperatingMode = OperatingModeHelp;

	if (argc <= 1)
	{
		return;
	}

	for (DWORD i = 1; i < argc; ++i)
	{
		if (_tcsicmp(argv[i], TEXT("/help")) == 0)
		{
			return;
		}

		if (_tcsicmp(argv[i], TEXT("/?")) == 0)
		{
			return;
		}
	}

	glo->OperatingMode = OperatingModeUnsigh;
}

BOOL CLISwitchesGet(CONST DWORD argc, LPCTSTR argv[], PGlobalOptions glo)
{
	BOOL LengthError = FALSE;


	for (DWORD i = 1; i < argc; ++i)
	{
		if (_tcsicmp(argv[i], TEXT("/NoLogo")) == 0)
		{
			glo->NoCopyrightLogo = TRUE;
			continue;
		}

		if (_tcsicmp(argv[i], TEXT("/NoCertPrint")) == 0)
		{
			glo->DontPrintCerificates = TRUE;
			continue;
		}
		
		if (_tcsicmp(argv[i], TEXT("/CRC")) == 0)
			if ((i + 1) < argc)
			{
				if (_tcsicmp(argv[i + 1], TEXT("Default")) == 0)
				{
					glo->CRCPolicy = CRCPolicyDefault;
					++i;
					continue;
				}

				if (_tcsicmp(argv[i + 1], TEXT("Zero")) == 0)
				{
					glo->CRCPolicy = CRCPolicyForceZero;
					++i;
					continue;
				}

				if (_tcsicmp(argv[i + 1], TEXT("Calc")) == 0)
				{
					glo->CRCPolicy = CRCPolicyForceCalc;
					++i;
					continue;
				}

				// wrong params
				CLILogoPrint();
				_tprintf_s(LangGet(UIMSG_127_ERR_INVALID_VALUE), argv[i + 1]);
				return FALSE;
			}
			else
				LengthError = TRUE;


		if (LengthError)
		{
			CLILogoPrint();
			_tprintf_s(LangGet(UIMSG_126_ERR_PARAMS_LENGTH), argv[i]);
			return FALSE;
		}

		if (argv[i][0] == TEXT('/'))
		{
			CLILogoPrint();
			_tprintf_s(LangGet(UIMSG_121_ERR_PARAMS_BAD_SW), argv[i]);
			return FALSE;
		}
	}

	return TRUE;
}

BOOL CLIPathsGet(CONST DWORD argc, LPCTSTR argv[], PGlobalOptions glo)
{
	for (DWORD i = 1; i < argc; ++i)
	{
		if (_tcsicmp(argv[i], TEXT("/CRC")) == 0)
		{
			++i;
			continue;
		}

		if (argv[i][0] == TEXT('/'))
		{
			continue;
		}		

		if (glo->PEFileName == NULL)
		{
			glo->PEFileName = (LPTSTR)argv[i];
			continue;
		}

		CLILogoPrint();
		_tprintf_s(LangGet(UIMSG_119_ERR_PARAMS_TOO_MANY_AGRS), argv[i]);
		return FALSE;
	}

	switch (glo->OperatingMode)
	{
	case OperatingModeUnsigh:
		if (glo->PEFileName != NULL)
			return TRUE;

		CLILogoPrint();
		_tprintf_s(LangGet(UIMSG_128_NO_PE_FILE));
		break;

	default:
		break;
	}

	return FALSE;
}

VOID CLILogoPrint()
{
	TCHAR FileName[MAX_PATH + 1];
	DWORD FileNameSize;
	DWORD Handle;
	DWORD FileVersionInfoSize;
	LPVOID BufferData;
	UINT len;
	LPVOID CopyrightString;
	LPVOID ProductNameString;
	LPVOID versionInfo;
	VS_FIXEDFILEINFO* fileInfo;


	FileNameSize = GetModuleFileName(NULL, (LPTSTR)&FileName, MAX_PATH);
	if (!FileNameSize)
		return;
	if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
		return;
	FileName[FileNameSize] = TEXT('\0');

	FileVersionInfoSize = GetFileVersionInfoSize((LPTSTR)&FileName, &Handle);
	if (!FileVersionInfoSize)
		return;

	BufferData = _alloca(FileVersionInfoSize);

	if (!GetFileVersionInfo((LPTSTR)&FileName, 0, FileVersionInfoSize, BufferData))
		return;

	if (!VerQueryValue(BufferData, TEXT("\\"), &versionInfo, &len))
		return;

	fileInfo = (VS_FIXEDFILEINFO*)versionInfo;
	if (fileInfo->dwSignature != 0xfeef04bd)
		return;

	if (!VerQueryValue(BufferData, TEXT("\\StringFileInfo\\040904B0\\FileDescription"), &ProductNameString, &len))
		return;

	if (!VerQueryValue(BufferData, TEXT("\\StringFileInfo\\040904B0\\LegalCopyright"), &CopyrightString, &len))
		return;

	_tprintf_s(LangGet(UIMSG_118_LOGO_TEXT),
		ProductNameString,
		HIWORD(fileInfo->dwProductVersionMS),
		LOWORD(fileInfo->dwProductVersionMS),
		ArchString,
		CopyrightString
	);
}

VOID CLIHelpPrint()
{
	_tprintf_s(LangGet(UIMSG_117_HELP_TEXT));
}

VOID CLIWriteLN()
{
	_tprintf_s(TEXT("\n"));
}

BOOL CLISetModeUTF16()
{
	if (_setmode(_fileno(stdout), _O_U16TEXT) == -1)
		return FALSE;

	if (_setmode(_fileno(stdin), _O_U16TEXT) == -1)
		return FALSE;

	if (_setmode(_fileno(stderr), _O_U16TEXT) == -1)
		return FALSE;

	return TRUE;
}

```

`unsign-src/CommandLineInterface.h`:

```h
/***

Copyright SV Foster, 2023-2025. All rights reserved.

License:
    This program is free for personal, educational and/or non-profit usage

Revision History:
	See CommandLineInterface.c for details

***/

#pragma once

#include <Windows.h>
#include <stdio.h>
#include <io.h>
#include <fcntl.h>
#include <tchar.h>
#include "SharedHeaders.h"
#include "resource.h"
#include "GlobalOptions.h"
#include "LanguageRes.h"


// File were processed without error
#define ExitCodeOK 0
// No file was found to process
#define ExitCodeErrorNoFiles 1
// File is not signed
#define ExitCodeErrorNotSigned 2
// Initialization error occurred. There is not enough memory or disk space, or you entered 
// an invalid file name or invalid syntax on the command line
#define ExitCodeErrorInit 4
//	File read/write error occurred or file has corrupted or incompatible format
#define ExitCodeErrorIO 5

#if defined(ENV64BIT)
	#define ArchString TEXT("x64 (x86-64)")
#elif defined (ENV32BIT)
	#define ArchString TEXT("x86 (IA-32)")
#else
	#error "Must define either ENV32BIT or ENV64BIT"
#endif


VOID  CLIWorkModeGet(CONST DWORD argc, LPCTSTR argv[], PGlobalOptions glo);
BOOL  CLISwitchesGet(CONST DWORD argc, LPCTSTR argv[], PGlobalOptions glo);
BOOL  CLIPathsGet(CONST DWORD argc, LPCTSTR argv[], PGlobalOptions glo);
VOID  CLILogoPrint();
VOID  CLIHelpPrint();
VOID  CLIWriteLN();
BOOL  CLISetModeUTF16();

```

`unsign-src/GlobalOptions.c`:

```c
/***

Copyright SV Foster, 2023-2025. All rights reserved.

License:
	This program is free for personal, educational and/or non-profit usage

Revision History:
	Rev 0, DEC 2023
	   First revision

	Rev 1, OCT 2025
	   Added support for the CRC recalculation feature
	   GlobalOptions moved from stack of the main() function to the Initialized Data Segment/.data

***/

#include "GlobalOptions.h"


TGlobalOptions GlobalOptions =
{
	OperatingModeHelp,
	NULL,               // PEFileName
	FALSE,              // DontPrintCerificates
	FALSE,              // NoCopyrightLogo
	CRCPolicyDefault
};

```

`unsign-src/GlobalOptions.h`:

```h
/***

Copyright SV Foster, 2023-2025. All rights reserved.

License:
    This program is free for personal, educational and/or non-profit usage

Revision History:
	See GlobalOptions.c for details

***/

#pragma once

#include <Windows.h>
#include "SharedHeaders.h"


typedef enum _OperatingMode
{
	OperatingModeHelp,
	OperatingModeUnsigh
} TOperatingMode;

typedef enum _CRCPolicy
{
	CRCPolicyDefault,
	CRCPolicyForceZero,
	CRCPolicyForceCalc
} TCRCPolicy;

typedef struct _GlobalOptions
{
	TOperatingMode OperatingMode;
	LPTSTR PEFileName;
	BOOL DontPrintCerificates;
	BOOL NoCopyrightLogo;
	TCRCPolicy CRCPolicy;
} TGlobalOptions, *PGlobalOptions;

```

`unsign-src/LanguageRes.c`:

```c
/***

Copyright SV Foster, 2023-2025. All rights reserved.

License:
    This program is free for personal, educational and/or non-profit usage

Revision History:
	Rev 0, DEC 2023
	   First revision

	Rev 1, OCT 2025
	   Code refactoring

***/

#include "LanguageRes.h"


static CONST TCHAR MessageErrorNoString[] = LanguageResErrorNoString;

LPCTSTR LangGet(CONST UINT uID)
{
	LPTSTR Result;
	int Length;


	// cchBufferMax is 0 and LoadStringW() is in use, Result receives a read-only pointer to the string resource itself
	Length = LoadString(GetModuleHandle(NULL), uID, (PVOID)&Result, 0);
	if (Length == 0)
		return (LPCTSTR)&MessageErrorNoString;

	return (LPCTSTR)Result;
}

```

`unsign-src/LanguageRes.h`:

```h
/***

Copyright SV Foster, 2023-2025. All rights reserved.

License:
    This program is free for personal, educational and/or non-profit usage

Revision History:
	See LanguageRes.c for details

***/

#pragma once

#include <Windows.h>


#define LanguageResErrorNoString TEXT("<<I AM ERROR>>")


LPCTSTR LangGet(CONST UINT uID);

```

`unsign-src/Main.c`:

```c
/***

Copyright SV Foster, 2023-2025. All rights reserved.

License:
    This program is free for personal, educational and/or non-profit usage

Revision History:
	Rev 0, DEC 2023
	   First revision

	Rev 1, MAR 2024
	   Added the check for the number of directories in the PE32/PE32+ optional header, as suggested by documentation
	   Code refactoring

	Rev 2, OCT 2025
	   Added the CRC of the PE executable file recalculation feature
	   Code refactoring

***/

#include "Main.h"

#pragma comment(lib, "Imagehlp.lib")
#pragma comment(lib, "Crypt32.lib")

#pragma warning( disable : 6255 ) // suppress the _alloca() warning


DWORD _tmain(DWORD argc, LPCTSTR argv[], LPCTSTR envp[])
{
	extern TGlobalOptions GlobalOptions;


	CLISetModeUTF16();
	SetErrorMode(SEM_FAILCRITICALERRORS); // Don't popup on floppy query and etc.
	CLIWriteLN();

	// set options
	CLIWorkModeGet(argc, argv, &GlobalOptions);
	if (GlobalOptions.OperatingMode == OperatingModeHelp)
		return ModeHelp();
	if (!CLISwitchesGet(argc, argv, &GlobalOptions))
		return ExitCodeErrorInit;
	if (!CLIPathsGet(argc, argv, &GlobalOptions))
		return ExitCodeErrorInit;

	if (!GlobalOptions.NoCopyrightLogo)
		CLILogoPrint();
	_tprintf_s(LangGet(UIMSG_101_PROCESSINGFILE), GlobalOptions.PEFileName);

	return ModeUnsigh();
}

DWORD ModeHelp()
{
	CLILogoPrint();
	CLIHelpPrint();

	return ExitCodeOK;
}

DWORD ModeUnsigh()
{
	DWORD Result = ExitCodeOK;
	HANDLE hFile;
	DWORD CertificateCount;
	PDWORD ArrayIndices = NULL;
	DWORD LastError;
	extern TGlobalOptions GlobalOptions;


	// open the file
	hFile = CreateFile(GlobalOptions.PEFileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		_tprintf_s(LangGet(UIMSG_102_CANT_OPEN_FILE), GetLastError());
		return ExitCodeErrorNoFiles;
	}

	// get all ACEs and check for curruption at the same time
	// ACE = attribute certificate entry
	if (!ACEsFind(hFile, &CertificateCount, &ArrayIndices, &LastError))
		if (LastError == ERROR_INVALID_PARAMETER)
		{
			// PE file is corrupted
			_tprintf_s(LangGet(UIMSG_103_FILE_CORRUPTED));

			// apply fix
			if (!DirectoryEntrySecZero(hFile))
				ExitFunction(ExitCodeErrorIO);

			_tprintf_s(LangGet(UIMSG_104_APP_SUCCESS));
			ExitFunction(ExitCodeOK);
		}
		else
			ExitFunction(ExitCodeErrorIO);

	if (CertificateCount == 0)
	{
		// no sign found
		_tprintf_s(LangGet(UIMSG_105_PE_NOT_SIGNED));
		ExitFunction(ExitCodeErrorNotSigned);
	}
	_tprintf_s(LangGet(UIMSG_116_FOUND_IMAGECERTS_CNT), CertificateCount);

	// print certs to the console
	if (!GlobalOptions.DontPrintCerificates)
		if (!ImageCertificatesPrintAll(hFile, CertificateCount, ArrayIndices))
			_tprintf_s(LangGet(UIMSG_120_ERR_ENUM_CERTS));

	// remove all
	if (!ACEsRemoveAll(hFile, CertificateCount, ArrayIndices))
		ExitFunction(ExitCodeErrorIO);

	// recalculate CRC
	if (!RecalcCRC(hFile))
		ExitFunction(ExitCodeErrorIO);

	// done!
	_tprintf_s(LangGet(UIMSG_104_APP_SUCCESS));


function_end:
	free(ArrayIndices);

	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);

	if (Result != ExitCodeOK)
		_tprintf_s(LangGet(UIMSG_106_APP_ERROR));

	return Result;
}

BOOL ACEsFind(CONST HANDLE hFile, PDWORD PCertificateCount, PDWORD* ArrayIndices, PDWORD LastError)
{
	*LastError = 0;

	if (!ImageEnumerateCertificates(hFile, CERT_SECTION_TYPE_ANY, PCertificateCount, NULL, 0))
	{
		*LastError = GetLastError();
		return FALSE;
	}

	if (*PCertificateCount == 0)
		return TRUE;

	*ArrayIndices = malloc(*PCertificateCount * sizeof(DWORD));
	if (!*ArrayIndices)
		return FALSE;

	if (!ImageEnumerateCertificates(hFile, CERT_SECTION_TYPE_ANY, PCertificateCount, *ArrayIndices, *PCertificateCount))
		return FALSE;

	return TRUE;
}

BOOL ImageCertificatesPrintAll(CONST HANDLE hFile, CONST DWORD CertificateCount, PDWORD ArrayIndices)
{
	DWORD Result = TRUE;
	LPWIN_CERTIFICATE PCertificate = NULL;
	DWORD RequiredLength = 0;
	CRYPT_DATA_BLOB p7Data;


	for (SIZE_T i = 0; i < CertificateCount; ++i)
	{
#pragma warning( push )
#pragma warning( disable : 6387 ) // if the Certificate pointer is NULL, RequiredLength receives the length of the certificate
		ImageGetCertificateData(hFile, ArrayIndices[i], NULL, &RequiredLength);
		if (RequiredLength < sizeof(WIN_CERTIFICATE)) // check the variable has been updated
			ExitFunction(FALSE);
#pragma warning( pop )

		PCertificate = malloc(RequiredLength);
		if (PCertificate == NULL)
			ExitFunction(FALSE);

		if (!ImageGetCertificateData(hFile, ArrayIndices[i], PCertificate, &RequiredLength))
			ExitFunction(FALSE);

		p7Data.cbData = PCertificate->dwLength - sizeof(DWORD) - sizeof(WORD) - sizeof(WORD);
		p7Data.pbData = PCertificate->bCertificate;

		if (!StoreCertificatesPrintAll(ArrayIndices[i], p7Data))
			ExitFunction(FALSE);
	}


function_end:
	free(PCertificate);

	return Result;
}

BOOL StoreCertificatesPrintAll(CONST DWORD Index, CONST CRYPT_DATA_BLOB p7Data)
{
	HCERTSTORE CertStore;
	CHAR signingOID[] = szOID_PKIX_KP_CODE_SIGNING;
	CERT_ENHKEY_USAGE keyUsage;
	keyUsage.cUsageIdentifier = 1;
	keyUsage.rgpszUsageIdentifier = _alloca(sizeof(LPSTR));
	keyUsage.rgpszUsageIdentifier[0] = &signingOID[0];
	PCCERT_CONTEXT certContext = NULL;
	int CertCount = 0;


	_tprintf_s(LangGet(UIMSG_107_EXAM_CERTSTORE), Index);
	CertStore = CertOpenStore(CERT_STORE_PROV_PKCS7, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 0, 0, &p7Data);
	if (CertStore == NULL)
		return FALSE;

	do
	{
		certContext = CertFindCertificateInStore
		(
			CertStore,
			X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
			CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
			CERT_FIND_ENHKEY_USAGE,
			&keyUsage,
			certContext
		);

		if (certContext)
		{			
			CertificatePrintSingle(CertCount, certContext);
			CertCount++;
		}
	} while (certContext);
	// only non-NULL CERT_CONTEXT that CertFindCertificateInStore() returns must be freed by CertFreeCertificateContext()

	if (CertCount == 0)
		_tprintf_s(LangGet(UIMSG_108_NO_CODESIGN));
	CLIWriteLN();
	
	CertCloseStore(CertStore, CERT_CLOSE_STORE_FORCE_FLAG);

	return TRUE;
}

VOID CertificatePrintSingle(CONST DWORD IndexStore, PCCERT_CONTEXT cert)
{
	DWORD CertType = CERT_X500_NAME_STR;
	DWORD StrSubjSize;
	LPTSTR StrSubj;


	_tprintf_s(LangGet(UIMSG_109_CODESIGN_CERTID), IndexStore);

	StrSubjSize = CertGetNameString(cert, CERT_NAME_RDN_TYPE, 0, &CertType, 0, 0);
	if (!StrSubjSize)
		return;

	StrSubj = _alloca(StrSubjSize * sizeof(TCHAR));
	StrSubjSize = CertGetNameString(cert, CERT_NAME_RDN_TYPE, 0, &CertType, StrSubj, StrSubjSize);
	if (StrSubjSize)
		_tprintf_s(TEXT("%s\n"), StrSubj);
}

BOOL ACEsRemoveAll(CONST HANDLE hFile, CONST DWORD CertificateCount, PDWORD ArrayIndices)
{
	_tprintf_s(LangGet(UIMSG_110_REMOVING_ACE));

	for (SIZE_T i = 0; i < CertificateCount; ++i)
	{
		_tprintf_s(LangGet(UIMSG_111_REMOVING_ACE_ID), ArrayIndices[i]);
		if (!ImageRemoveCertificate(hFile, ArrayIndices[i]))
			return FALSE;
	}

	return TRUE;
}

BOOL RecalcCRC(CONST HANDLE hFile)
{
	BOOL Result = TRUE;
	TPEImageMapping PEImage = { 0 };
	BOOL CallResult;


	// map the file into the memory
	CallResult = ImagePEMapToVA(hFile, &PEImage);
	if (!CallResult)
		ExitFunction(FALSE);

	// CRC
	CallResult = ImagePECRCByPolicy(&PEImage);
	if (!CallResult)
		ExitFunction(FALSE);


function_end:
	// Unmap the file and close handles
	ImagePEUnmapFromVA(&PEImage);

	return Result;
}

BOOL DirectoryEntrySecZero(CONST HANDLE hFile)
{
	BOOL Result = TRUE;
	TPEImageMapping PEImage = { 0 };
	BOOL CallResult;


	_tprintf_s(LangGet(UIMSG_112_REMOVING_IDES));

	// map the file into the memory
	CallResult = ImagePEMapToVA(hFile, &PEImage);
	if (!CallResult)
		ExitFunction(FALSE);

	// fix
	switch (PEImage.NThdrOptMagic)
	{
	// PE executable
	case IMAGE_NT_OPTIONAL_HDR32_MAGIC:
		// Note that the number of directories is not fixed. Before looking for a specific directory,
		// check the NumberOfRvaAndSizes field in the optional header
		// https://learn.microsoft.com/en-us/windows/win32/debug/pe-format
		if (PEImage.ntHeader32->OptionalHeader.NumberOfRvaAndSizes < (IMAGE_DIRECTORY_ENTRY_SECURITY + 1))
		{
			_tprintf_s(LangGet(UIMSG_123_PE_BAD_DIRECTORY_COUNT));
			ExitFunction(FALSE);
		}

		_tprintf_s(LangGet(UIMSG_113_IDES_SIZE), PEImage.ntHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size);
		_tprintf_s(LangGet(UIMSG_114_IDES_VA), PEImage.ntHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress);
		PEImage.ntHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size = 0;
		PEImage.ntHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress = 0;
		_tprintf_s(LangGet(UIMSG_115_IDES_ZEROED));

		CallResult = ImagePECRCByPolicy(&PEImage);
		if (!CallResult)
			ExitFunction(FALSE);

		break;

	// PE+ executable
	case IMAGE_NT_OPTIONAL_HDR64_MAGIC:
		// Note that the number of directories is not fixed. Before looking for a specific directory,
		// check the NumberOfRvaAndSizes field in the optional header
		// https://learn.microsoft.com/en-us/windows/win32/debug/pe-format
		if (PEImage.ntHeader64->OptionalHeader.NumberOfRvaAndSizes < (IMAGE_DIRECTORY_ENTRY_SECURITY + 1))
		{
			_tprintf_s(LangGet(UIMSG_123_PE_BAD_DIRECTORY_COUNT));
			ExitFunction(FALSE);
		}

		_tprintf_s(LangGet(UIMSG_113_IDES_SIZE), PEImage.ntHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size);
		_tprintf_s(LangGet(UIMSG_114_IDES_VA), PEImage.ntHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress);
		PEImage.ntHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size = 0;
		PEImage.ntHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress = 0;
		_tprintf_s(LangGet(UIMSG_115_IDES_ZEROED));

		CallResult = ImagePECRCByPolicy(&PEImage);
		if (!CallResult)
			ExitFunction(FALSE);

		break;

	// unknown
	default:
		_tprintf_s(LangGet(UIMSG_122_PE_BAD_HEADERS));
		ExitFunction(FALSE);

		break;
	}	

function_end:
	// Unmap the file and close handles
	ImagePEUnmapFromVA(&PEImage);

	return Result;
}

BOOL ImagePEMapToVA(CONST HANDLE hFile, PPEImageMapping PEImage)
{
	if (PEImage->IsActive)
		return FALSE;

	// Get the file size
	PEImage->fileSize = GetFileSize(hFile, NULL);
	if (!PEImage->fileSize)
		return FALSE;

	// Create a file mapping object
	PEImage->hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, 0, NULL);
	if (PEImage->hFileMapping == NULL)
		return FALSE;

	// Map the file into memory
	PEImage->fileBase = MapViewOfFile(PEImage->hFileMapping, FILE_MAP_ALL_ACCESS, 0, 0, 0);
	if (PEImage->fileBase == NULL)
		return FALSE;

	// check DOS header
	if (PEImage->HeaderDOS->e_magic != IMAGE_DOS_SIGNATURE)
	{
		_tprintf_s(LangGet(UIMSG_122_PE_BAD_HEADERS));
		return FALSE;
	}
	if (PEImage->HeaderDOS->e_lfanew == 0)
	{
		_tprintf_s(LangGet(UIMSG_122_PE_BAD_HEADERS));
		return FALSE;
	}

	// set variables for PE headers
	PEImage->ntHeader = (LPBYTE)(PEImage->fileBase) + PEImage->HeaderDOS->e_lfanew;

	// signatures for PE32 and PE32+ headers are on the same place, single check in enough
	if (PEImage->NThdrSignature != IMAGE_NT_SIGNATURE)
	{
		_tprintf_s(LangGet(UIMSG_122_PE_BAD_HEADERS));
		return FALSE;
	}

	PEImage->IsActive = TRUE;
	return TRUE;
}

VOID ImagePEUnmapFromVA(PPEImageMapping PEImage)
{
	if (PEImage->fileBase != NULL)
		UnmapViewOfFile(PEImage->fileBase);

	if (PEImage->hFileMapping != NULL)
		CloseHandle(PEImage->hFileMapping);

	ZeroMemory(PEImage, sizeof(*PEImage)); // PEImage->IsActive = FALSE;
}

BOOL ImagePECRCByPolicy(PPEImageMapping PEImage)
{
	if (!PEImage->IsActive)
		return FALSE;
	
	extern TGlobalOptions GlobalOptions;


	switch (PEImage->NThdrOptMagic)
	{
	// PE executable
	case IMAGE_NT_OPTIONAL_HDR32_MAGIC:
		switch (GlobalOptions.CRCPolicy)
		{
		case CRCPolicyForceZero:			
			PEImage->ntHeader32->OptionalHeader.CheckSum = 0;
			_tprintf_s(LangGet(UIMSG_125_PE_CRC_UPDATED), 0);
			return TRUE;

		case CRCPolicyForceCalc:
			break;

		default: // CRCPolicyDefault
			if (PEImage->ntHeader32->OptionalHeader.CheckSum == 0)
				return TRUE;
		}

		if (ImagePECRCCalc(PEImage, &(PEImage->ntHeader32->OptionalHeader.CheckSum)))
			return TRUE;

		break;

	// PE+ executable
	case IMAGE_NT_OPTIONAL_HDR64_MAGIC:
		switch (GlobalOptions.CRCPolicy)
		{
		case CRCPolicyForceZero:			
			PEImage->ntHeader64->OptionalHeader.CheckSum = 0;
			_tprintf_s(LangGet(UIMSG_125_PE_CRC_UPDATED), 0);
			return TRUE;

		case CRCPolicyForceCalc:
			break;

		default: // CRCPolicyDefault
			if (PEImage->ntHeader64->OptionalHeader.CheckSum == 0)
				return TRUE;
		}

		if (ImagePECRCCalc(PEImage, &(PEImage->ntHeader64->OptionalHeader.CheckSum)))
			return TRUE;

		break;

	// unknown
	default:
		_tprintf_s(LangGet(UIMSG_122_PE_BAD_HEADERS));
	}

	return FALSE;
}

BOOL ImagePECRCCalc(PPEImageMapping PEImage, PDWORD PCheckSumAddr)
{
	PIMAGE_NT_HEADERS CallResult;
	DWORD BufferCheckSumOld;
	DWORD CheckSumOld = *PCheckSumAddr;


	CallResult = CheckSumMappedFile(PEImage->fileBase, PEImage->fileSize, &BufferCheckSumOld, PCheckSumAddr);
	if (CallResult == NULL)
	{
		_tprintf_s(LangGet(UIMSG_124_PE_CRC_UPDATE_FAILED));
		return FALSE;
	}

	_tprintf_s(LangGet(UIMSG_125_PE_CRC_UPDATED), *PCheckSumAddr);
	return TRUE;
}

```

`unsign-src/Main.h`:

```h
/***

Copyright SV Foster, 2023-2025. All rights reserved.

License:
    This program is free for personal, educational and/or non-profit usage

Revision History:
    See Main.c for details

***/

#pragma once

#include <Windows.h>
#include <ImageHlp.h>
#include <stdio.h>
#include <tchar.h>
#include "SharedHeaders.h"
#include "resource.h"
#include "GlobalOptions.h"
#include "LanguageRes.h"
#include "CommandLineInterface.h"


typedef struct _PEImageMapping
{
    BOOL IsActive;
    DWORD fileSize;
    HANDLE hFileMapping;
    union
    {
        LPVOID fileBase;
        PIMAGE_DOS_HEADER HeaderDOS;
    };
    union
    {
        LPVOID ntHeader;
        PIMAGE_NT_HEADERS32 ntHeader32;
        PIMAGE_NT_HEADERS64 ntHeader64;
    };
#define NThdrSignature ntHeader64->Signature           // signatures for PE32 and PE32+ headers are on the same place
#define NThdrFileHeader ntHeader64->FileHeader         // same
#define NThdrOptMagic ntHeader64->OptionalHeader.Magic // same
} TPEImageMapping, *PPEImageMapping;


DWORD ModeHelp();
DWORD ModeUnsigh();
BOOL  ACEsFind(CONST HANDLE hFile, PDWORD PCertificateCount, PDWORD* ArrayIndices, PDWORD LastError);
BOOL  ImageCertificatesPrintAll(CONST HANDLE hFile, CONST DWORD CertificateCount, PDWORD ArrayIndices);
BOOL  StoreCertificatesPrintAll(CONST DWORD Index, CONST CRYPT_DATA_BLOB p7Data);
VOID  CertificatePrintSingle(CONST DWORD IndexStore, PCCERT_CONTEXT cert);
BOOL  ACEsRemoveAll(CONST HANDLE hFile, CONST DWORD CertificateCount, PDWORD ArrayIndices);
BOOL  RecalcCRC(CONST HANDLE hFile);
BOOL  DirectoryEntrySecZero(CONST HANDLE hFile);
BOOL  ImagePEMapToVA(CONST HANDLE hFile, PPEImageMapping PEImage);
VOID  ImagePEUnmapFromVA(PPEImageMapping PEImage);
BOOL  ImagePECRCByPolicy(PPEImageMapping PEImage);
BOOL  ImagePECRCCalc(PPEImageMapping PEImage, PDWORD PCheckSumAddr);

```

`unsign-src/SharedHeaders.h`:

```h
/***

Copyright SV Foster, 2023. All rights reserved.

License:
    This program is free for personal, educational and/or non-profit usage

Revision History:
	Rev 0, DEC 2023
	   First revision

***/

#pragma once


#if _WIN32 || _WIN64
	#if _WIN64
		#define ENV64BIT
	#else
		#define ENV32BIT
	#endif
#endif

#define ExitFunction(e) {Result = e; goto function_end;}

```

`unsign-src/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by resource.rc
//
#define UIMSG_101_PROCESSINGFILE        101
#define UIMSG_102_CANT_OPEN_FILE        102
#define UIMSG_103_FILE_CORRUPTED        103
#define UIMSG_104_APP_SUCCESS           104
#define UIMSG_105_PE_NOT_SIGNED         105
#define UIMSG_106_APP_ERROR             106
#define UIMSG_107_EXAM_CERTSTORE        107
#define UIMSG_108_NO_CODESIGN           108
#define UIMSG_109_CODESIGN_CERTID       109
#define UIMSG_110_REMOVING_IMG_CERT     110
#define UIMSG_110_REMOVING_ACE          110
#define UIMSG_111_REMOVING_IMG_CERT_ID  111
#define UIMSG_111_REMOVING_ACE_ID       111
#define UIMSG_112_REMOVING_IDES         112
#define UIMSG_113_IDES_SIZE             113
#define UIMSG_114_IDES_VA               114
#define UIMSG_115_IDES_ZEROED           115
#define UIMSG_116_FOUND_IMAGECERTS_CNT  116
#define UIMSG_117_HELP_TEXT             117
#define UIMSG_118_LOGO_TEXT             118
#define UIMSG_119_ERR_PARAMS_TOO_MANY_AGRS 119
#define UIMSG_120_ERR_ENUM_CERTS        120
#define UIMSG_121_ERR_PARAMS_BAD_SW     121
#define UIMSG_122_PE_BAD_HEADERS        122
#define UIMSG_123_PE_BAD_DIRECTORY_COUNT 123
#define UIMSG_124_PE_CRC_UPDATE_FAILED  124
#define UIMSG_125_PE_CRC_UPDATED        125
#define UIMSG_126_ERR_PARAMS_LENGTH     126
#define UIMSG_127_ERR_INVALID_VALUE     127
#define UIMSG_128_NO_PE_FILE            128

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        128
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`unsign-src/resource.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,2,0,0
 PRODUCTVERSION 1,2,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40000L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "SV Foster"
            VALUE "FileDescription", "Windows executable files unsinging tool"
            VALUE "FileVersion", "1.2.0.0"
            VALUE "InternalName", "unsign"
            VALUE "LegalCopyright", "SV Foster, 2023-2025"
            VALUE "OriginalFilename", "unsign.exe"
            VALUE "ProductName", "UnSign"
            VALUE "ProductVersion", "1.2.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// String Table
//

STRINGTABLE
BEGIN
    UIMSG_101_PROCESSINGFILE "Now processing file: %s\n\n"
    UIMSG_102_CANT_OPEN_FILE "Can't open file, error %d\n\n"
    UIMSG_103_FILE_CORRUPTED "File discovered corrupted, applying fix...\n\n"
    UIMSG_104_APP_SUCCESS   "\nOperation completed successfully. This Windows executable file has now been stripped of its digital signature and can be signed again\n\n"
    UIMSG_105_PE_NOT_SIGNED "This Windows executable file is not signed\n"
    UIMSG_106_APP_ERROR     "\nAn error has occurred. File was not processed\n\n"
    UIMSG_107_EXAM_CERTSTORE 
                            "\nExamining certificates store in attribute certificate entry #%d\n"
    UIMSG_108_NO_CODESIGN   "No code signing certificates found\n"
    UIMSG_109_CODESIGN_CERTID "Codesign certificate #%d: "
    UIMSG_110_REMOVING_ACE  "Removing all attribute certificate entries of the executable file\n"
    UIMSG_111_REMOVING_ACE_ID "Removing attribute certificate entry #%d\n"
    UIMSG_112_REMOVING_IDES "Removing values from PE32/PE32+ optional header table entry IMAGE_DIRECTORY_ENTRY_SECURITY\n"
    UIMSG_113_IDES_SIZE     "DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size was 0x%08X\n"
    UIMSG_114_IDES_VA       "DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].VA was 0x%08X\n"
    UIMSG_115_IDES_ZEROED   "Set to zero now\n"
    UIMSG_116_FOUND_IMAGECERTS_CNT 
                            "Total attribute certificate entries in the executable file: %d\n"
    UIMSG_117_HELP_TEXT     "Completely removes the embedded signature (with all sections of the signature) from a Windows executable file\nFixes PE32/PE32+ optional header problem that makes an executable file unsingable\n\nThis program works with both 32 and 64 bit executables, in PE32 and PE32+ headers format, like .exe, .dll, .sys, .drv and others\n\nWARNING: This program will modify the file inplace on the disk! Please create a backup copy if you want to preserve the original file!\n\nUsage: unsign /<switch 1> /<switch N> <PE32/PE32+ executable file>\n\n<Switches>\n  /NoLogo       Don't print copyright logo\n  /NoCertPrint  Don't exam and print certificates on the file\n  /CRC          Checksum recalculation policy\n                  Zero    - forcefully zero out the CRC field in the optional PE header\n                  Calc    - always recalculate the valid checksum\n                  Default - recalculate the checksum only if it was not 0 (default)\n\n"
    UIMSG_118_LOGO_TEXT     "%s %d.%d %s\nCopyright %s. All rights reserved\nThis program is free for personal, educational and/or non-profit usage\n\n"
    UIMSG_119_ERR_PARAMS_TOO_MANY_AGRS "Too many arguments - %s\n\n"
    UIMSG_120_ERR_ENUM_CERTS 
                            "Can't enumerate all certificates, they are damaged or are in an unsupported format\n"
    UIMSG_121_ERR_PARAMS_BAD_SW "Invalid switch - %s\n\n"
    UIMSG_122_PE_BAD_HEADERS 
                            "Invalid PE32/PE32+ executable headers, file is damaged, has unsupported format or it is not an executable\n"
    UIMSG_123_PE_BAD_DIRECTORY_COUNT 
                            "If the NumberOfRvaAndSizes value is too small, there are not enough entries in the DataDirectory array to accommodate the IMAGE_DIRECTORY_ENTRY_SECURITY directory. This error can occur if the file is corrupted or if it was not properly generated during the compilation process\n"
    UIMSG_124_PE_CRC_UPDATE_FAILED "Can't update PE32/PE32+ image CRC\n"
    UIMSG_125_PE_CRC_UPDATED "CRC updated successfully to 0x%08X\n"
    UIMSG_126_ERR_PARAMS_LENGTH "No value was provided for the switch %s\n\n"
    UIMSG_127_ERR_INVALID_VALUE "Invalid parameter - %s\n\n"
    UIMSG_128_NO_PE_FILE    "No file to process specified\n\n"
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED

```

`unsign-src/unsign.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-16"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{c5877396-66ea-456d-a728-35fb1c134ae5}</ProjectGuid>
    <RootNamespace>unsign</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)$(ProjectName)-exe-IA-32\</OutDir>
    <IntDir>$(SolutionDir)$(ProjectName)-obj-IA-32\</IntDir>
    <TargetName>unsign</TargetName>
    <CodeAnalysisRuleSet>NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)$(ProjectName)-exe-IA-32\</OutDir>
    <IntDir>$(SolutionDir)$(ProjectName)-obj-IA-32\</IntDir>
    <TargetName>unsign</TargetName>
    <CodeAnalysisRuleSet>NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)$(ProjectName)-exe-x86-64\</OutDir>
    <IntDir>$(SolutionDir)$(ProjectName)-obj-x86-64\</IntDir>
    <TargetName>unsign</TargetName>
    <CodeAnalysisRuleSet>NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)$(ProjectName)-exe-x86-64\</OutDir>
    <IntDir>$(SolutionDir)$(ProjectName)-obj-x86-64\</IntDir>
    <TargetName>unsign</TargetName>
    <CodeAnalysisRuleSet>NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <ErrorReporting>None</ErrorReporting>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <AdditionalOptions>/emittoolversioninfo:no /pdbaltpath:%_PDB% %(AdditionalOptions)</AdditionalOptions>
      <BaseAddress>0x10000</BaseAddress>
      <SetChecksum>false</SetChecksum>
      <GenerateMapFile>true</GenerateMapFile>
      <MapExports>true</MapExports>
      <StackReserveSize>262144</StackReserveSize>
      <StackCommitSize>8192</StackCommitSize>
      <LinkErrorReporting>NoErrorReport</LinkErrorReporting>
      <HeapReserveSize>1048576</HeapReserveSize>
      <HeapCommitSize>131072</HeapCommitSize>
    </Link>
    <PreBuildEvent>
      <Command>
      </Command>
    </PreBuildEvent>
    <ResourceCompile>
      <NullTerminateStrings>true</NullTerminateStrings>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <ErrorReporting>None</ErrorReporting>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <AdditionalOptions>/emittoolversioninfo:no /pdbaltpath:%_PDB% %(AdditionalOptions)</AdditionalOptions>
      <BaseAddress>0x10000</BaseAddress>
      <SetChecksum>true</SetChecksum>
      <GenerateMapFile>true</GenerateMapFile>
      <MapExports>true</MapExports>
      <StackReserveSize>262144</StackReserveSize>
      <StackCommitSize>8192</StackCommitSize>
      <LinkErrorReporting>NoErrorReport</LinkErrorReporting>
      <HeapReserveSize>1048576</HeapReserveSize>
      <HeapCommitSize>131072</HeapCommitSize>
    </Link>
    <PreBuildEvent>
      <Command>
      </Command>
    </PreBuildEvent>
    <ResourceCompile>
      <NullTerminateStrings>true</NullTerminateStrings>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <ErrorReporting>None</ErrorReporting>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <AdditionalOptions>/emittoolversioninfo:no /pdbaltpath:%_PDB% %(AdditionalOptions)</AdditionalOptions>
      <SetChecksum>false</SetChecksum>
      <GenerateMapFile>true</GenerateMapFile>
      <MapExports>true</MapExports>
      <StackReserveSize>524288</StackReserveSize>
      <StackCommitSize>8192</StackCommitSize>
      <LinkErrorReporting>NoErrorReport</LinkErrorReporting>
      <HeapReserveSize>1048576</HeapReserveSize>
      <HeapCommitSize>131072</HeapCommitSize>
    </Link>
    <PreBuildEvent>
      <Command>
      </Command>
    </PreBuildEvent>
    <ResourceCompile>
      <NullTerminateStrings>true</NullTerminateStrings>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <ErrorReporting>None</ErrorReporting>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <AdditionalOptions>/emittoolversioninfo:no /pdbaltpath:%_PDB% %(AdditionalOptions)</AdditionalOptions>
      <SetChecksum>true</SetChecksum>
      <GenerateMapFile>true</GenerateMapFile>
      <MapExports>true</MapExports>
      <StackReserveSize>524288</StackReserveSize>
      <StackCommitSize>8192</StackCommitSize>
      <LinkErrorReporting>NoErrorReport</LinkErrorReporting>
      <HeapReserveSize>1048576</HeapReserveSize>
      <HeapCommitSize>131072</HeapCommitSize>
    </Link>
    <PreBuildEvent>
      <Command>
      </Command>
    </PreBuildEvent>
    <ResourceCompile>
      <NullTerminateStrings>true</NullTerminateStrings>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="CommandLineInterface.c" />
    <ClCompile Include="GlobalOptions.c" />
    <ClCompile Include="LanguageRes.c" />
    <ClCompile Include="Main.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="CommandLineInterface.h" />
    <ClInclude Include="GlobalOptions.h" />
    <ClInclude Include="LanguageRes.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="Main.h" />
    <ClInclude Include="SharedHeaders.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="resource.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`unsign-src/unsign.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-16"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="LanguageRes.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="CommandLineInterface.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="GlobalOptions.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Main.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="LanguageRes.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="CommandLineInterface.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="GlobalOptions.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="SharedHeaders.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="resource.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`unsign-src/unsign.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-16"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>false</ShowAllFiles>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LocalDebuggerCommandArguments>
    </LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
    <LocalDebuggerWorkingDirectory>$(OutDir)</LocalDebuggerWorkingDirectory>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LocalDebuggerCommandArguments>
    </LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
    <LocalDebuggerWorkingDirectory>$(OutDir)</LocalDebuggerWorkingDirectory>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LocalDebuggerWorkingDirectory>$(OutDir)</LocalDebuggerWorkingDirectory>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
    <LocalDebuggerCommandArguments>
    </LocalDebuggerCommandArguments>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LocalDebuggerWorkingDirectory>$(OutDir)</LocalDebuggerWorkingDirectory>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
    <LocalDebuggerCommandArguments>
    </LocalDebuggerCommandArguments>
  </PropertyGroup>
</Project>
```

`unsign.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.33801.447
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "unsign", "unsign-src\unsign.vcxproj", "{C5877396-66EA-456D-A728-35FB1C134AE5}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{C5877396-66EA-456D-A728-35FB1C134AE5}.Debug|x64.ActiveCfg = Debug|x64
		{C5877396-66EA-456D-A728-35FB1C134AE5}.Debug|x64.Build.0 = Debug|x64
		{C5877396-66EA-456D-A728-35FB1C134AE5}.Debug|x86.ActiveCfg = Debug|Win32
		{C5877396-66EA-456D-A728-35FB1C134AE5}.Debug|x86.Build.0 = Debug|Win32
		{C5877396-66EA-456D-A728-35FB1C134AE5}.Release|x64.ActiveCfg = Release|x64
		{C5877396-66EA-456D-A728-35FB1C134AE5}.Release|x64.Build.0 = Release|x64
		{C5877396-66EA-456D-A728-35FB1C134AE5}.Release|x86.ActiveCfg = Release|Win32
		{C5877396-66EA-456D-A728-35FB1C134AE5}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {5CC75311-A362-4674-8DEA-5B8AEFB89FB8}
	EndGlobalSection
EndGlobal

```