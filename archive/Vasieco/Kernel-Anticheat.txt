Project Path: arc_Vasieco_Kernel-Anticheat_hmtmg8_g

Source Tree:

```txt
arc_Vasieco_Kernel-Anticheat_hmtmg8_g
├── LICENSE
├── README.md
├── anticheat
│   ├── anticheat.inf
│   ├── anticheat.vcxproj
│   ├── anticheat.vcxproj.filters
│   ├── anticheat.vcxproj.user
│   ├── include.h
│   ├── kernel.h
│   ├── main.cpp
│   ├── methods
│   │   ├── drivers
│   │   │   ├── drivers.cpp
│   │   │   └── drivers.h
│   │   ├── handles
│   │   │   ├── handles.cpp
│   │   │   └── handles.h
│   │   ├── hypervisor
│   │   │   ├── hv.cpp
│   │   │   └── hv.h
│   │   ├── memory
│   │   │   ├── pool.cpp
│   │   │   └── pool.h
│   │   ├── other
│   │   │   ├── serial.cpp
│   │   │   ├── serial.h
│   │   │   ├── traces.cpp
│   │   │   └── traces.h
│   │   └── threads
│   │       ├── nmi.cpp
│   │       ├── nmi.h
│   │       ├── threads.cpp
│   │       └── threads.h
│   └── utils
│       └── utils.h
└── anticheat.sln

```

`LICENSE`:

```
MIT License

Copyright (c) 2025 Vasie1337

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`README.md`:

```md
# Kernel-Anticheat

## Project Overview
This project is a kernel driver made for Windows that will scan your pc for cheat behaviour

## Features
- **Drivers**: Checks for invalid/unsigned drivers.
- **Handles**: Checks for usermode physical memory handles.
- **Hypervisor**: Simple hypervisor detection using vm_read.
- **Memory**: Checks bigpool for some traces.
- **Serial**: Check your own serials.
- **Traces**: Will search for Kdmapper traces.
- **NMI**: Scans cores for suspicious activity by firing NMI.
- **Threads**: Checks systemthreads for invalid ones.


## How to Run
1. Build the project:
```
Using Visual Studio 2022 or higher
```
2. Enable Loading of Test Signed Drivers
```
Bcdedit.exe -set TESTSIGNING ON
```
3. Restart local machine
```
shutdown /r
```
4. Setup the driver
```
sc create anticheat_drv type=kernel binpath={PATH_TO_BIN}
```
4. Load the driver
```
sc start anticheat_drv
```

## License
This project is licensed under the MIT License. See the LICENSE file for details.

```

`anticheat.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.3.32922.545
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "anticheat", "anticheat\anticheat.vcxproj", "{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|ARM.ActiveCfg = Debug|ARM
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|ARM.Build.0 = Debug|ARM
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|ARM.Deploy.0 = Debug|ARM
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|ARM64.Build.0 = Debug|ARM64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|x64.ActiveCfg = Debug|x64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|x64.Build.0 = Debug|x64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|x64.Deploy.0 = Debug|x64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|x86.ActiveCfg = Debug|Win32
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|x86.Build.0 = Debug|Win32
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|x86.Deploy.0 = Debug|Win32
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|ARM.ActiveCfg = Release|ARM
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|ARM.Build.0 = Release|ARM
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|ARM.Deploy.0 = Release|ARM
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|ARM64.ActiveCfg = Release|ARM64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|ARM64.Build.0 = Release|ARM64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|ARM64.Deploy.0 = Release|ARM64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|x64.ActiveCfg = Release|x64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|x64.Build.0 = Release|x64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|x64.Deploy.0 = Release|x64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|x86.ActiveCfg = Release|Win32
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|x86.Build.0 = Release|Win32
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {340E45E7-F88E-4806-896E-6B37B6B05EAC}
	EndGlobalSection
EndGlobal

```

`anticheat/anticheat.inf`:

```inf
;
; anticheat.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=sd ; TODO: edit Class
ClassGuid={c498d9b1-b2d0-4149-9434-9444230a43fe} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=anticheat.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages
PnpLockDown=1

[DestinationDirs]
DefaultDestDir = 12
ac_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
anticheat.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%anticheat.DeviceDesc%=ac_Device, Root\ac ; TODO: edit hw-id

[ac_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
anticheat.sys

;-------------- Service installation
[ac_Device.NT.Services]
AddService = ac,%SPSVCINST_ASSOCSERVICE%, ac_Service_Inst

; -------------- ac driver install sections
[ac_Service_Inst]
DisplayName    = %anticheat.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\anticheat.sys

;
;--- ac_Device Coinstaller installation ------
;

[ac_Device.NT.CoInstallers]
AddReg=ac_Device_CoInstaller_AddReg
CopyFiles=ac_Device_CoInstaller_CopyFiles

[ac_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[ac_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[ac_Device.NT.Wdf]
KmdfService =  ac, ac_wdfsect
[ac_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "ac Installation Disk"
anticheat.DeviceDesc = "ac Device"
anticheat.SVCDESC = "ac Service"

```

`anticheat/anticheat.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>TestNMICallback</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
    <TimeStampServer>http://timestamp.globalsign.com/scripts/timstamp.dll</TimeStampServer>
    <OutDir>$(SolutionDir)build\</OutDir>
    <IntDir>$(SolutionDir)build\$(ProjectName)\</IntDir>
    <TargetName>$(ProjectName)</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <OutDir>$(SolutionDir)build\</OutDir>
    <IntDir>$(SolutionDir)build\$(ProjectName)\</IntDir>
    <TargetName>$(ProjectName)</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
    </ClCompile>
    <DriverSign>
      <FileDigestAlgorithm>SHA1</FileDigestAlgorithm>
    </DriverSign>
    <Link>
      <TreatLinkerWarningAsErrors>false</TreatLinkerWarningAsErrors>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>SHA1</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
    <Link>
      <TreatLinkerWarningAsErrors>false</TreatLinkerWarningAsErrors>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="anticheat.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="methods\drivers\drivers.cpp" />
    <ClCompile Include="methods\hypervisor\hv.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="methods\threads\nmi.cpp" />
    <ClCompile Include="methods\handles\handles.cpp" />
    <ClCompile Include="methods\memory\pool.cpp" />
    <ClCompile Include="methods\other\serial.cpp" />
    <ClCompile Include="methods\threads\threads.cpp" />
    <ClCompile Include="methods\other\traces.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="kernel.h" />
    <ClInclude Include="include.h" />
    <ClInclude Include="methods\drivers\drivers.h" />
    <ClInclude Include="methods\handles\handles.h" />
    <ClInclude Include="methods\hypervisor\hv.h" />
    <ClInclude Include="methods\memory\pool.h" />
    <ClInclude Include="methods\other\traces.h" />
    <ClInclude Include="methods\other\serial.h" />
    <ClInclude Include="methods\threads\threads.h" />
    <ClInclude Include="methods\threads\nmi.h" />
    <ClInclude Include="utils\utils.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`anticheat/anticheat.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="methods\hypervisor\hv.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="methods\threads\nmi.cpp" />
    <ClCompile Include="methods\handles\handles.cpp" />
    <ClCompile Include="methods\memory\pool.cpp" />
    <ClCompile Include="methods\other\serial.cpp" />
    <ClCompile Include="methods\threads\threads.cpp" />
    <ClCompile Include="methods\other\traces.cpp" />
    <ClCompile Include="methods\drivers\drivers.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="kernel.h" />
    <ClInclude Include="methods\drivers\drivers.h" />
    <ClInclude Include="include.h" />
    <ClInclude Include="methods\handles\handles.h" />
    <ClInclude Include="methods\hypervisor\hv.h" />
    <ClInclude Include="methods\memory\pool.h" />
    <ClInclude Include="methods\other\serial.h" />
    <ClInclude Include="methods\other\traces.h" />
    <ClInclude Include="methods\threads\nmi.h" />
    <ClInclude Include="methods\threads\threads.h" />
    <ClInclude Include="utils\utils.h" />
  </ItemGroup>
  <ItemGroup>
    <Inf Include="anticheat.inf" />
  </ItemGroup>
</Project>
```

`anticheat/anticheat.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`anticheat/include.h`:

```h
#pragma once

#include <intrin.h>
#include <ntifs.h>
#include <ntstrsafe.h>
#include <windef.h>

#define printf(text, ...) DbgPrintEx(DPFLTR_IHVBUS_ID, 0, text, ##__VA_ARGS__)

#include "kernel.h"

#include "utils/utils.h"

#include "methods/drivers/drivers.h"
#include "methods/handles/handles.h"
#include "methods/hypervisor/hv.h"
#include "methods/memory/pool.h"
#include "methods/other/serial.h"
#include "methods/other/traces.h"
#include "methods/threads/nmi.h"
#include "methods/threads/threads.h"


```

`anticheat/kernel.h`:

```h
#pragma once

#include <intrin.h>
#include <ntifs.h>
#include <ntstrsafe.h>
#include <windef.h>

// Structs + Enums
typedef struct _SYSTEM_HANDLE
{
	ULONG 	uIdProcess;
	UCHAR 	ObjectType;
	UCHAR 	Flags;
	USHORT 	Handle;
	void* 	pObject;
	ACCESS_MASK 	GrantedAccess;
}SYSTEM_HANDLE;

typedef struct _SYSTEM_HANDLE_INFORMATION {
	ULONG			uCount;
	SYSTEM_HANDLE	Handles[ANYSIZE_ARRAY];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

typedef struct _SYSTEM_BIGPOOL_ENTRY {
	union {
		void* VirtualAddress;
		ULONG_PTR NonPaged : 1;
	};
	ULONG_PTR SizeInBytes;
	union {
		UCHAR Tag[4];
		ULONG TagULong;
	};
} SYSTEM_BIGPOOL_ENTRY, * PSYSTEM_BIGPOOL_ENTRY;

typedef struct _SYSTEM_BIGPOOL_INFORMATION {
	ULONG Count;
	SYSTEM_BIGPOOL_ENTRY AllocatedInfo[ANYSIZE_ARRAY];
} SYSTEM_BIGPOOL_INFORMATION, * PSYSTEM_BIGPOOL_INFORMATION;

typedef struct _SYSTEM_BOOT_ENVIRONMENT_INFORMATION {
	struct _GUID BootIdentifier;
	enum _FIRMWARE_TYPE FirmwareType;
	unsigned __int64 BootFlags;
} SYSTEM_BOOT_ENVIRONMENT_INFORMATION, * PSYSTEM_BOOT_ENVIRONMENT_INFORMATION;

typedef struct _KAFFINITY_EX
{
	USHORT Count;
	USHORT Size;
	ULONG Reserved;
	ULONGLONG Bitmap[20];
} KAFFINITY_EX, * PKAFFINITY_EX;

typedef struct _PiDDBCacheEntry
{
	LIST_ENTRY		List;
	UNICODE_STRING	DriverName;
	ULONG			TimeDateStamp;
	NTSTATUS		LoadStatus;
	char			_0x0028[16];
} PiDDBCacheEntry, * PPiDDBCacheEntry;

typedef struct _MM_UNLOADED_DRIVER
{
	UNICODE_STRING 	Name;
	void* 			ModuleStart;
	void* 			ModuleEnd;
	ULONG64 		UnloadTime;
} MM_UNLOADED_DRIVER, * PMM_UNLOADED_DRIVER;

typedef struct _NMI_CONTEXT
{
	INT NumFired;
} NMI_CONTEXT, * PNMI_CONTEXT;

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	void* MappedBase;
	void* ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR  FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation,
	SystemProcessorInformation,
	SystemPerformanceInformation,
	SystemTimeOfDayInformation,
	SystemPathInformation,
	SystemProcessInformation,
	SystemCallCountInformation,
	SystemDeviceInformation,
	SystemProcessorPerformanceInformation,
	SystemFlagsInformation,
	SystemCallTimeInformation,
	SystemModuleInformation,
	SystemLocksInformation,
	SystemStackTraceInformation,
	SystemPagedPoolInformation,
	SystemNonPagedPoolInformation,
	SystemHandleInformation,
	SystemObjectInformation,
	SystemPageFileInformation,
	SystemVdmInstemulInformation,
	SystemVdmBopInformation,
	SystemFileCacheInformation,
	SystemPoolTagInformation,
	SystemInterruptInformation,
	SystemDpcBehaviorInformation,
	SystemFullMemoryInformation,
	SystemLoadGdiDriverInformation,
	SystemUnloadGdiDriverInformation,
	SystemTimeAdjustmentInformation,
	SystemSummaryMemoryInformation,
	SystemNextEventIdInformation,
	SystemEventIdsInformation,
	SystemCrashDumpInformation,
	SystemExceptionInformation,
	SystemCrashDumpStateInformation,
	SystemKernelDebuggerInformation,
	SystemContextSwitchInformation,
	SystemRegistryQuotaInformation,
	SystemExtendServiceTableInformation,
	SystemPrioritySeperation,
	SystemPlugPlayBusInformation,
	SystemDockInformation,
	SystemProcessorSpeedInformation,
	SystemCurrentTimeZoneInformation,
	SystemLookasideInformation
} SYSTEM_INFORMATION_CLASS, * PSYSTEM_INFORMATION_CLASS;

typedef struct _SYSTEM_MODULE_ENTRY
{
	HANDLE Section;
	void* MappedBase;
	void* ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName[256];
} SYSTEM_MODULE_ENTRY, * PSYSTEM_MODULE_ENTRY;

typedef struct _SYSTEM_MODULE_INFORMATION
{
	ULONG Count;
	SYSTEM_MODULE_ENTRY Module[0];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

typedef struct _DIRECTORY_BASIC_INFORMATION {
	UNICODE_STRING ObjectName;
	UNICODE_STRING ObjectTypeName;
} DIRECTORY_BASIC_INFORMATION, * PDIRECTORY_BASIC_INFORMATION;

// Imports
EXTERN_C_START

VOID KeInitializeAffinityEx(PKAFFINITY_EX affinity);
VOID KeAddProcessorAffinityEx(PKAFFINITY_EX affinity, INT num);
VOID HalSendNMI(PKAFFINITY_EX affinity);
NTSTATUS MmCopyVirtualMemory(PEPROCESS SourceProcess, void* SourceAddress, PEPROCESS TargetProcess, void* TargetAddress, SIZE_T BufferSize, KPROCESSOR_MODE PreviousMode, PSIZE_T ReturnSize);
NTSTATUS ZwQuerySystemInformation(ULONG InfoClass, void* Buffer, ULONG Length, PULONG ReturnLength);
NTSTATUS NtQueryInformationThread(HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, void* ThreadInformation, ULONG ThreadInformationLength, PULONG ReturnLength);
__int64 __fastcall PsGetProcessSectionBaseAddress(__int64 a1);

EXTERN_C_END
```

`anticheat/main.cpp`:

```cpp
#include "include.h"

void DriverUnload(PDRIVER_OBJECT drv_obj)
{
	UNREFERENCED_PARAMETER(drv_obj);
	printf("[MAIN] Driver Unloaded\n");
	return;
}

EXTERN_C NTSTATUS DriverEntry(PDRIVER_OBJECT drv_obj, PUNICODE_STRING reg)
{
	drv_obj->DriverUnload = DriverUnload;

	printf("[MAIN] Driver Loaded\n");

	g_drivers.scan();
	g_handles.check_physical_mem_handles();
	g_hv.check_vmread();
	g_pool.scan_big_pool();
	g_serial.print();
	g_traces.check_pid_db_cache_table();
	g_threads.scan_system_threads();

	g_nmi.init();
	g_nmi.fire(4);
	g_nmi.scan();

	return STATUS_SUCCESS;
}
```

`anticheat/methods/drivers/drivers.cpp`:

```cpp
#include "drivers.h"

bool drivers::scan()
{
	return false;
}

```

`anticheat/methods/drivers/drivers.h`:

```h
#pragma once
#include "../../include.h"

class drivers
{
public:
	bool scan();

private:

};

inline drivers g_drivers;
```

`anticheat/methods/handles/handles.cpp`:

```cpp
#include "handles.h"

bool handles::check_physical_mem_handles()
{
	void* object = nullptr;
	HANDLE phys_mem_handle = nullptr;
	UNICODE_STRING phys_mem_str = RTL_CONSTANT_STRING(L"\\Device\\PhysicalMemory");
	OBJECT_ATTRIBUTES oa_attributes = RTL_CONSTANT_OBJECT_ATTRIBUTES(&phys_mem_str, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE);

	NTSTATUS status = ZwOpenSection(&phys_mem_handle, SECTION_ALL_ACCESS, &oa_attributes);
	if (!NT_SUCCESS(status))
		return false;

	status = ObReferenceObjectByHandle(phys_mem_handle, 1, nullptr, KernelMode, &object, nullptr);
	if (!NT_SUCCESS(status))
	{
		ZwClose(phys_mem_handle);
		return false;
	}

	ZwClose(phys_mem_handle);

	PSYSTEM_HANDLE_INFORMATION handles = get_handle_list();
	if (!handles)
	{
		ObDereferenceObject(object);
		return false;
	}

	bool found = false;

	for (ULONG i = 0; i < handles->uCount; i++)
	{
		if (handles->Handles[i].uIdProcess == 4)
			continue;

		if (handles->Handles[i].pObject == object)
		{
			if (!ObIsKernelHandle(reinterpret_cast<HANDLE>(handles->Handles[i].Handle)))
			{
				printf("[HANDLES] Usermode PhysicalMemory handle detected, pid = %d, access = 0x%x.\n",
					handles->Handles[i].uIdProcess, 
					handles->Handles[i].GrantedAccess
				);

				found = true;
			}
		}
	}

	ObDereferenceObject(object);
	ExFreePool(handles);

	if (!found)
		printf("[HANDLES] No usermode PhysicalMemory handles detected.\n");

	return true;
}

PSYSTEM_HANDLE_INFORMATION handles::get_handle_list()
{
	ULONG size = 8 * 1024 * 1024;

	PSYSTEM_HANDLE_INFORMATION list = reinterpret_cast<PSYSTEM_HANDLE_INFORMATION>(ExAllocatePool(NonPagedPool, size));
	if (!list)
		return nullptr;

	NTSTATUS status = ZwQuerySystemInformation(SystemHandleInformation, list, size, 0);
	if (status == STATUS_INFO_LENGTH_MISMATCH)
	{
		ExFreePool(list);
		return nullptr;
	}

	return list;
}
```

`anticheat/methods/handles/handles.h`:

```h
#pragma once
#include "../../include.h"

class handles
{
public:
	/// <summary>
	/// Check for physical memory handles in the handle list.
	/// </summary>
	/// <returns>
	/// Returns true if successful, false otherwise. Result is printed to the debug output.
	/// </returns>
	bool check_physical_mem_handles();

private:
	/// <summary>
	/// Get the handle list.
	/// </summary>
	/// <returns>
	/// Returns the handle list.
	/// </returns>
	PSYSTEM_HANDLE_INFORMATION get_handle_list();
};

inline handles g_handles;
```

`anticheat/methods/hypervisor/hv.cpp`:

```cpp
#include "hv.h"

void hv::check_vmread()
{
	__try {
		__vmx_vmread(0, 0);
		printf("[HV] Hypervisor running\n");
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {
		printf("[HV] Hypervisor not running\n");
	}
}

```

`anticheat/methods/hypervisor/hv.h`:

```h
#pragma once
#include "../../include.h"

class hv
{
public:
	void check_vmread();
private:

};

inline hv g_hv;
```

`anticheat/methods/memory/pool.cpp`:

```cpp
#include "pool.h"

#define TdlS_TAG 'SldT'
#define TdlS_OFFSET 0x184
#define TdlS_TIMESTAMP 0x0B024BC8B48

bool pool::scan_big_pool()
{
	PSYSTEM_BIGPOOL_INFORMATION info = get_big_pool_info();
	if (!info)
		return false;

	bool found = false;

	for (ULONG i = 0; i < info->Count; i++)
	{
		if (info->AllocatedInfo[i].TagULong != TdlS_TAG)
			return false;

		found = true;

		printf("[POOL] Found TdlS tag in big pool\n");

		void* page = MmMapIoSpaceEx(MmGetPhysicalAddress(reinterpret_cast<void*>(info->AllocatedInfo[i].VirtualAddress)), PAGE_SIZE, PAGE_READWRITE);
		if (reinterpret_cast<uintptr_t>(page) + TdlS_OFFSET == TdlS_TIMESTAMP)
		{
			printf("[POOL] TdlS timestamp found in pool\n");
		}

		MmUnmapIoSpace(page, PAGE_SIZE);
	}

	ExFreePool(info);

	if (!found)
		printf("[POOL] Nothing found in bigpool\n");

	return true;
}

PSYSTEM_BIGPOOL_INFORMATION pool::get_big_pool_info()
{
	ULONG size = 4 * 1024 * 1024;
	void* buffer = ExAllocatePool(NonPagedPool, size);
	if (!buffer)
		return nullptr;

	PSYSTEM_BIGPOOL_INFORMATION info = reinterpret_cast<PSYSTEM_BIGPOOL_INFORMATION>(buffer);
	if (!NT_SUCCESS(ZwQuerySystemInformation(0x42, buffer, size, &size))) /* SystemBigPoolInformation */
	{
		ExFreePool(buffer);
		return nullptr;
	}

	return info;
}

```

`anticheat/methods/memory/pool.h`:

```h
#pragma once
#include "../../include.h"

class pool
{
public:
	bool scan_big_pool();
private:
	PSYSTEM_BIGPOOL_INFORMATION get_big_pool_info();
};

inline pool g_pool;
```

`anticheat/methods/other/serial.cpp`:

```cpp
#include "serial.h"

void serial::print()
{
	PrintBootUUID();
	PrintDiskUUID();
	PrintMachineGuid();
	PrintVolumeSerialNumber();
	PrintCpuId();
	PrintBiosSerialNumber();
	PrintBaseboardSerialNumber();
	PrintSystemBiosVersion();
	PrintSystemSerialNumber();
	PrintSystemUuid();
}

void serial::PrintBootUUID()
{
	ULONG size = 8 * 1024 * 1024;

	PSYSTEM_BOOT_ENVIRONMENT_INFORMATION boot_info = reinterpret_cast<PSYSTEM_BOOT_ENVIRONMENT_INFORMATION>(ExAllocatePool(NonPagedPool, size));
	if (!boot_info)
		return;

	if (ZwQuerySystemInformation(0x5a, boot_info, size, nullptr) != STATUS_SUCCESS) /* SystemBootEnvironmentInformation */
	{
		ExFreePool(boot_info);
		return;
	}

	printf("[SERIAL] BootUUID : %08X-%04X-%04X-%02X%02X%02X%02X%02X%02X%02X%02X\n",
		boot_info->BootIdentifier.Data1, 
		boot_info->BootIdentifier.Data2, 
		boot_info->BootIdentifier.Data3, 
		boot_info->BootIdentifier.Data4[0], 
		boot_info->BootIdentifier.Data4[1], 
		boot_info->BootIdentifier.Data4[2], 
		boot_info->BootIdentifier.Data4[3],
		boot_info->BootIdentifier.Data4[4],
		boot_info->BootIdentifier.Data4[5],
		boot_info->BootIdentifier.Data4[6],
		boot_info->BootIdentifier.Data4[7]
	);
}

void serial::PrintDiskUUID()
{
}

void serial::PrintMachineGuid()
{
}

void serial::PrintVolumeSerialNumber()
{
}

void serial::PrintCpuId()
{
}

void serial::PrintBiosSerialNumber()
{
}

void serial::PrintBaseboardSerialNumber()
{
}

void serial::PrintSystemBiosVersion()
{
}

void serial::PrintSystemSerialNumber()
{
}

void serial::PrintSystemUuid()
{
}

```

`anticheat/methods/other/serial.h`:

```h
#pragma once
#include "../../include.h"

class serial
{
public:
	void print();

private:
	void PrintBootUUID();
	void PrintDiskUUID();
	void PrintMachineGuid();
	void PrintVolumeSerialNumber();
	void PrintCpuId();
	void PrintBiosSerialNumber();
	void PrintBaseboardSerialNumber();
	void PrintSystemBiosVersion();
	void PrintSystemSerialNumber();
	void PrintSystemUuid();
};

inline serial g_serial;
```

`anticheat/methods/other/traces.cpp`:

```cpp
#include "traces.h"

void traces::check_pid_db_cache_table()
{
}

```

`anticheat/methods/other/traces.h`:

```h
#pragma once
#include "../../include.h"

class traces
{
public:
	void check_pid_db_cache_table();

private:

};

inline traces g_traces;
```

`anticheat/methods/threads/nmi.cpp`:

```cpp
#include "nmi.h"

void nmi::init()
{
	core_count = KeQueryActiveProcessorCountEx(0);
	context_size = core_count * sizeof(NMI_CONTEXT);

	context = reinterpret_cast<PNMI_CONTEXT>(ExAllocatePool(NonPagedPool, context_size));
	if (!context)
	{
		return;
	}

	mask = reinterpret_cast<PKAFFINITY_EX>(ExAllocatePool(NonPagedPool, sizeof(KAFFINITY_EX)));
	if (!mask)
	{
		ExFreePool(context);
		return;
	}

	results = reinterpret_cast<ULONG64*>(ExAllocatePool(NonPagedPool, PAGE_SIZE));
	if (!results)
	{
		ExFreePool(mask);
		ExFreePool(context);
		return;
	}

	RtlZeroMemory(context, context_size);
	RtlZeroMemory(mask, sizeof(KAFFINITY_EX));
	RtlZeroMemory(results, PAGE_SIZE);

	did_init = true;
}

bool nmi::fire(int count)
{
	if (!did_init)
	{
		printf("[NMI] NMI not initialized\n");
		return false;
	}

	nmi_handle = KeRegisterNmiCallback(callback, nullptr);
	if (!nmi_handle)
	{
		printf("[NMI] Failed to register NMI callback\n");
		return false;
	}

	LARGE_INTEGER delay = { 0 };
	delay.QuadPart = -(100 * 100); // 100ms

	for (int i = 0; i < count; i++)
	{
		for (int j = 0; j < core_count; j++)
		{
			nmi_handled = false;
			fire_nmi(j, mask);

			while (!nmi_handled)
				KeDelayExecutionThread(KernelMode, FALSE, &delay);

			KeDelayExecutionThread(KernelMode, FALSE, &delay); // Extra delay to prevent nmi collisions
		}
	}

	KeDeregisterNmiCallback(nmi_handle);

	return true;
}

void nmi::scan()
{
	bool found = false;

	for (INT i = 0; i < 0x1000 / 0x10; i += 2)
	{
		if (results[i] == 0)
			continue;

		if (MmIsAddressValid(reinterpret_cast<void*>(results[i])) && results[i + 1])
		{
			for (USHORT j = 0; j < results[i + 1]; j++)
			{
				uintptr_t address = (((DWORD64**)results)[i])[j];

				if (address < 0xFFFF000000000000)
					break;

				if (address_outside_modules(address))
				{
					printf("[NMI] Address outside of module list: 0x%llx\n", address);
					found = true;
				}
			}
		}

		ExFreePool(reinterpret_cast<void*>(results[i]));
		results[i] = 0;
		results[i + 1] = 0;
	}

	if (!found)
	{
		printf("[NMI] No addresses outside of module list found\n");
	}
}

void nmi::fire_nmi(int core, PKAFFINITY_EX mask)
{
	KeInitializeAffinityEx(mask);
	KeAddProcessorAffinityEx(mask, core);
	HalSendNMI(mask);
}

void nmi::capture_stack()
{
	void** stack_trace = reinterpret_cast<void**>(ExAllocatePool(NonPagedPool, PAGE_SIZE));
	if (!stack_trace)
	{
		printf("[NMI] Failed to allocate memory for stack trace\n");
		return;
	}

	USHORT frames = RtlCaptureStackBackTrace(0, PAGE_SIZE / 8, stack_trace, 0);
	if (!frames)
	{
		ExFreePool(stack_trace);
		return;
	}

	for (int i = 0; i < 0x1000 / 0x10; i += 2)
	{
		if (results[i] == 0)
		{
			results[i] = reinterpret_cast<ULONG64>(stack_trace);
			results[i + 1] = frames;
			break;
		}
	}

	printf("[NMI] Stack trace captured\n");
}

BOOLEAN nmi::callback(PVOID context, BOOLEAN handled)
{
	printf("[NMI] NMI fired\n");

	capture_stack();
	nmi_handled = true;

	return true;
}

```

`anticheat/methods/threads/nmi.h`:

```h
#pragma once
#include "../../include.h"

class nmi
{
public:
	void init();

	bool fire(int count);
	void scan();

private:
	void fire_nmi(int core, PKAFFINITY_EX mask);
	
	static void capture_stack();
	static BOOLEAN callback(PVOID context, BOOLEAN handled);

	ULONG core_count = 0;
	ULONG context_size = 0;

	PNMI_CONTEXT context = nullptr;
	PKAFFINITY_EX mask = nullptr;
	inline static ULONG64* results = nullptr;
	HANDLE nmi_handle = nullptr;

	bool did_init = false;
	inline static bool nmi_handled = false;
};

inline nmi g_nmi;
```

`anticheat/methods/threads/threads.cpp`:

```cpp
#include "threads.h"

void threads::scan_system_threads()
{
	bool found = false;

	for (ULONG thrd_id = 4; thrd_id < 0x30000; thrd_id += 4)
	{
		PETHREAD thread_obj = nullptr;
		if (!NT_SUCCESS(PsLookupThreadByThreadId(reinterpret_cast<HANDLE>(thrd_id), &thread_obj)))
			continue;

		if (!PsIsSystemThread(thread_obj) || thread_obj == KeGetCurrentThread())
			continue;

		uintptr_t start_addr = get_thread_start_address(thread_obj);
		if (start_addr && address_outside_modules(start_addr))
		{
			printf("[THREADS] Startaddress not valid : %llx\n", start_addr);
			found = true;
		}
	}

	if (!found)
	{
		printf("[THREADS] No addresses outside of module list found\n");
	}
}

uintptr_t threads::get_thread_start_address(PETHREAD thread)
{
	HANDLE thread_handle = nullptr;

	if (!NT_SUCCESS(ObOpenObjectByPointer(thread, OBJ_KERNEL_HANDLE, NULL, GENERIC_READ, *PsThreadType, KernelMode, &thread_handle)))
	{
		return 0;
	}

	uintptr_t start_addr;
	ULONG returned_bytes;
	if (!NT_SUCCESS(NtQueryInformationThread(thread_handle, ThreadQuerySetWin32StartAddress, &start_addr, sizeof(start_addr), &returned_bytes)))
	{
		NtClose(thread_handle);
		return 0;
	}

	if (!MmIsAddressValid((void*)start_addr))
	{
		NtClose(thread_handle);
		return 0;
	}

	NtClose(thread_handle);

	return start_addr;
}
```

`anticheat/methods/threads/threads.h`:

```h
#pragma once
#include "../../include.h"

class threads
{
public:
	void scan_system_threads();

private:
	uintptr_t get_thread_start_address(PETHREAD thread);
};

inline threads g_threads;
```

`anticheat/utils/utils.h`:

```h
#pragma once
#include "../include.h"

inline bool address_outside_modules(uintptr_t address)
{
	BOOLEAN outside_modulelist = TRUE;
	PSYSTEM_MODULE_INFORMATION system_info_buffer = nullptr;
	ULONG system_info_buffer_size = 0;

	ZwQuerySystemInformation(SystemModuleInformation, 0, 0, &system_info_buffer_size);

	system_info_buffer = (PSYSTEM_MODULE_INFORMATION)ExAllocatePool(NonPagedPool, (SIZE_T)system_info_buffer_size * 2);
	if (!system_info_buffer)
	{
		return false;
	}

	memset(system_info_buffer, 0, (SIZE_T)system_info_buffer_size * 2);
	ZwQuerySystemInformation(SystemModuleInformation, system_info_buffer, (SIZE_T)system_info_buffer_size * 2, &system_info_buffer_size);

	for (ULONG i = 0; i < system_info_buffer->Count; i++)
	{
		if (address >= (ULONG64)system_info_buffer->Module[i].ImageBase &&
			address <= (ULONG64)system_info_buffer->Module[i].ImageBase + system_info_buffer->Module[i].ImageSize)
		{
			outside_modulelist = FALSE;
			break;
		}
	}

	ExFreePool(system_info_buffer);

	return outside_modulelist;
}
```