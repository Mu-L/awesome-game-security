Project Path: arc_doomedraven_Tools_8kp1hq3o

Source Tree:

```txt
arc_doomedraven_Tools_8kp1hq3o
├── Databases
│   ├── Mongo.sh
│   └── MongoGetDups.md
├── LICENSE.txt
├── Mac
│   ├── VPN_split.sh
│   └── yara.sh
├── Networking
│   ├── fix_iptables.sh
│   └── visc2ovpn.py
├── README.md
├── Reversing
│   ├── FullColor.idc
│   ├── FullColor.py
│   ├── README.md
│   └── flare-emu-string-deobfuscation.py
├── Virtualization
│   ├── README.md
│   ├── kvm-qemu.sh
│   ├── libguestfs
│   │   └── Dockerfile
│   └── libguestfs.sh
├── Vol3
│   ├── pony.py
│   └── zbotscan.py
└── Windows
    ├── choco.bat
    └── disable_win7noise.bat

```

`Databases/Mongo.sh`:

```sh
#!/bin/bash

#show how to upgrade old mongo to newer on Debian

function update_install {
    sudo apt-get update
    sudo apt-get install -y mongodb-org
}

function wipe_mongo(){
   dpkg -l|grep mongo| cut -f 3 -d " "|xargs dpkg --remove
}

# mongo 3.4 debian 9 - https://docs.mongodb.com/v3.4/tutorial/install-mongodb-on-debian/
# https://blog.m157q.tw/posts/2018/07/24/upgrade-mongodb-from-3-2-to-3-4-on-debian-9/
# http://repo.mongodb.org/apt/debian/dists/jessie/mongodb-org/3.4/main/binary-amd64/
wget http://security.debian.org/debian-security/pool/updates/main/o/openssl/libssl1.0.0_1.0.1t-1+deb8u11_amd64.deb && dpkg -i libssl1.0.0_1.0.1t-1+deb8u11_amd64.deb
wget http://repo.mongodb.org/apt/debian/dists/jessie/mongodb-org/3.4/main/binary-amd64/mongodb-org-server_3.4.18_amd64.deb && dpkg -i mongodb-org-server_3.4.18_amd64.deb
wget http://repo.mongodb.org/apt/debian/dists/jessie/mongodb-org/3.4/main/binary-amd64/mongodb-org-shell_3.4.20_amd64.deb && dpkg -i mongodb-org-shell_3.4.20_amd64.deb
mongo --eval 'db.adminCommand({setFeatureCompatibilityVersion: "3.4"})'

# mongo3.6
wipe_mongo
sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 2930ADAE8CAF5059EE73BB4B58712A2291FA4AD5
echo "deb http://repo.mongodb.org/apt/debian stretch/mongodb-org/3.6 main" | sudo tee /etc/apt/sources.list.d/mongodb-org-3.6.list
update_install
mongo --eval 'db.adminCommand( { getParameter: 1, featureCompatibilityVersion: 1 } )'
mongo --eval 'db.adminCommand({setFeatureCompatibilityVersion: "3.6"})'

# mongo 4
wipe_mongo
rm /etc/apt/sources.list.d/mongodb-org-3.6.list
sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 9DA31620334BD75D9DCB49F368818C72E52529D4
echo "deb http://repo.mongodb.org/apt/debian stretch/mongodb-org/4.0 main" | sudo tee /etc/apt/sources.list.d/mongodb-org-4.0.list
update_install
sudo systemctl unmask mongodb
systemctl start mongo

```

`Databases/MongoGetDups.md`:

```md
# https://www.compose.com/articles/finding-duplicate-documents-in-mongodb/

* get duplicated values
```
use yeti
db.observable.aggregate([  
    {$group: { _id: {value: "$value"}, count: {$sum: 1}}},
    {$match: {count: {"$gt": 1}}},
    {$sort: {count: -1}}],
    {allowDiskUse:true, cursor:{}}
);
```

* remove duplicated
```
var duplicates = [];
db.observable.aggregate([  
    {$group: { _id: {value: "$value"}, count: {$sum: 1}, dups: { "$addToSet": "$_id" },}},
    {$match: {count: {"$gt": 1}}},
    {$sort: {count: -1}}],
    {allowDiskUse:true, cursor:{}}
).forEach(function(doc) {
    doc.dups.shift();      // First element skipped for deleting
    doc.dups.forEach( function(dupId){ 
        duplicates.push(dupId);   // Getting all duplicate ids
        }
    )    
});

db.observable.remove({_id:{$in:duplicates}})
```

```

`LICENSE.txt`:

```txt
Copyright 2018-2019 doomedraven

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

```

`Mac/VPN_split.sh`:

```sh
#!/bin/bash
# replace "yourcomapy.com." with your real root domain
# replace "VPN_IP" with real VPN public ip
# replace dns1 and dns2 with your real dns
# To get real dns, add --dump --verbose to vpn-slice when starts with openconnect

function _check_brew() {
    if [ ! -f /usr/local/bin/brew ]; then
        /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
    fi
}


_check_brew
brew install openconnect git unbound
pip3 install git+https://github.com/dlenski/vpn-slice.git


# how to configure local dns server
# https://calomel.org/unbound_dns.html 
# https://sizeof.cat/post/unbound-on-macos/
# https://nlnetlabs.nl/documentation/unbound/unbound.conf/
#(curl --silent https://raw.githubusercontent.com/StevenBlack/hosts/master/alternates/fakenews-gambling-porn-social/hosts | grep '^0\.0\.0\.0' | sort) | awk '{print "local-zone: \""$2"\" refuse"}' > /usr/local/etc/unbound/zone-block-general.conf
sudo dscl . -create /Groups/_unbound
sudo dscl . -create /Groups/_unbound PrimaryGroupID 444
sudo dscl . -create /Users/_unbound
sudo dscl . -create /Users/_unbound RecordName _unbound unbound
sudo dscl . -create /Users/_unbound RealName "Unbound DNS server"
sudo dscl . -create /Users/_unbound UniqueID 444
sudo dscl . -create /Users/_unbound PrimaryGroupID 444
sudo dscl . -create /Users/_unbound UserShell /usr/bin/false
sudo dscl . -create /Users/_unbound Password '*'
sudo dscl . -create /Groups/_unbound GroupMembership _unbound

sudo /usr/local/opt/unbound/sbin/unbound-anchor -a /usr/local/etc/unbound/root.key
sudo /usr/local/opt/unbound/sbin/unbound-control-setup -d /usr/local/etc/unbound
sudo cp /usr/local/etc/unbound/unbound.conf /usr/local/etc/unbound/unbound.conf_original
sudo curl --silent -o /usr/local/etc/unbound/root.hints https://www.internic.net/domain/named.cache

cat >> /usr/local/etc/unbound/unbound.conf << EOL
server:
    # log verbosity
    verbosity: 3
    # domain-insecure: *
    # logfile: "/tmp/unbound.log"
    # log-queries: yes
    # log-time-ascii: yes
    interface: 127.0.0.1
    access-control: 127.0.0.1/8 allow
    chroot: ""
    username: "_unbound"
    # auto-trust-anchor-file: "/usr/local/etc/unbound/root.key"
    # answer DNS queries on this port
    port: 53
    # enable IPV4
    do-ip4: yes
    # disable IPV6
    do-ip6: no
    # enable UDP
    do-udp: yes
    # enable TCP, you could disable this if not needed, UDP is quicker
    do-tcp: yes
    # which client IPs are allowed to make (recursive) queries to this server
    access-control: 10.0.0.0/8 allow
    access-control: 127.0.0.0/8 allow
    access-control: 192.168.0.0/16 allow
    root-hints: "/usr/local/etc/unbound/root.hints"
    # do not answer id.server and hostname.bind queries
    hide-identity: yes
    # do not answer version.server and version.bind queries
    hide-version: yes
    # will trust glue only if it is within the servers authority
    harden-glue: yes
    # require DNSSEC data for trust-anchored zones, if such data
    # is absent, the zone becomes  bogus
    harden-dnssec-stripped: yes
    # use 0x20-encoded random bits in the query to foil spoof attempts
    use-caps-for-id: yes
    # the time to live (TTL) value lower bound, in seconds
    cache-min-ttl: 3600
    # the time to live (TTL) value cap for RRsets and messages in the cache
    cache-max-ttl: 86400
    # perform prefetching of close to expired message cache entries
    prefetch: yes
    num-threads: 4
    msg-cache-slabs: 8
    rrset-cache-slabs: 8
    infra-cache-slabs: 8
    key-cache-slabs: 8
    rrset-cache-size: 256m
    msg-cache-size: 128m
    so-rcvbuf: 1m
    private-address: 192.168.0.0/16
    private-address: 172.16.0.0/12
    private-address: 10.0.0.0/8
    private-domain: "home.lan"
    unwanted-reply-threshold: 10000
    val-clean-additional: yes
    # additional blocklist (Steven Black hosts file, read above)
    # include: /usr/local/etc/unbound/zone-block-general.conf
    private-domain: "yourcomapy.com."
    local-data: "vpn.yourcomapy.com.  IN A VPN_IP"
remote-control:
    control-enable: yes
    control-interface: 127.0.0.1
    server-key-file: "/usr/local/etc/unbound/unbound_server.key"
    server-cert-file: "/usr/local/etc/unbound/unbound_server.pem"
    control-key-file: "/usr/local/etc/unbound/unbound_control.key"
    control-cert-file: "/usr/local/etc/unbound/unbound_control.pem"

forward-zone:
   name: "yourcomapy.com."
   #forward-ssl-upstream:yes
   forward-addr: dns1
   forward-addr: dns2

forward-zone:
   name: "."
   # forward-ssl-upstream: yes
   forward-addr: 1.1.1.1@53#one.one.one.one
   forward-addr: 8.8.8.8@53#dns.google
   forward-addr: 9.9.9.9@53#dns.quad9.net
   forward-addr: 1.0.0.1@53#one.one.one.one
   forward-addr: 8.8.4.4@53#dns.google
   forward-addr: 149.112.112.112@53#dns.quad9.net
EOL

sudo chown -R _unbound:staff /usr/local/etc/unbound
sudo chmod 640 /usr/local/etc/unbound/*

sudo brew services start unbound

networksetup -setdnsservers Wi-Fi 127.0.0.1
networksetup -getdnsservers Wi-Fi


```

`Mac/yara.sh`:

```sh
#!/bin/bash

if [ ! -f "/usr/local/bin/brew" ]; then
    /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
fi

brew install yara
ARCHFLAGS=-Wno-error=unused-command-line-argument-hard-error-in-future python3 -m pip install yara-python

```

`Networking/fix_iptables.sh`:

```sh
#!/bin/bash
# Fix when docker breaks your iptables
if [ $# -eq 0 ] || [ $# -lt 2 ]; then
    echo "$0 <netowrk range> <vir_iface> <real_iface>"
    echo "    example: $0 192.168.1.0 virbr0 eno0"
    exit 1
fi

echo "[+] Setting iptables"
iptables -t nat -A POSTROUTING -o "$2" -j MASQUERADE
iptables -A FORWARD -i "$2" -o "$2" -m state --state RELATED,ESTABLISHED -j ACCEPT
iptables -A FORWARD -i "$2" -o "$2" -j ACCEPT
iptables -I FORWARD -m physdev --physdev-is-bridged -j ACCEPT
iptables -I FORWARD -o "$2" -d  "$1"/24 -j ACCEPT
iptables -t nat -A POSTROUTING -s "$1"/24 -j MASQUERADE
iptables -A FORWARD -o "$2" -m state --state RELATED,ESTABLISHED -j ACCEPT
iptables -A FORWARD -i "$2" -o "$3" -j ACCEPT
iptables -A FORWARD -i "$2" -o lo -j ACCEPT

echo "[+] Setting network options"
# https://forums.fedoraforum.org/showthread.php?312824-Bridge-broken-after-docker-install&s=ffc1c60cccc19e46c01b9a8e0fcd0c35&p=1804899#post1804899
{
    echo "net.bridge.bridge-nf-call-ip6tables=0";
    echo "net.bridge.bridge-nf-call-iptables=0";
    echo "net.bridge.bridge-nf-call-arptables=0";
    echo "net.ipv4.conf.all.forwarding=1";
    echo "net.ipv4.ip_forward=1";
} >> /etc/sysctl.conf
sysctl -p
echo "iptables -A FORWARD -i $2 -o $2 -j ACCEPT" >> /etc/network/if-pre-up.d/kvm_bridge_iptables

virsh nwfilter-list

```

`Networking/visc2ovpn.py`:

```py
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""Converts viscosity export files into an open vpn package
Usage: viscosity-to-openvpn.py <input> <output>
# source https://gist.github.com/brianbruggeman/f032f5b8e4b7fc1c63c8691071be5946
"""
import io
import os
import sys
import tarfile

import click

if sys.version.startswith('3'):
    unicode = str


# ----------------------------------------------------------------------
# Exceptions
# ----------------------------------------------------------------------
class ConversionError(Exception):
    """Base conversion error"""
    pass


class NoConnectionName(ConversionError):
    """No connection name was available"""
    pass


class NoCertificateData(ConversionError):
    """No certificate data was found within certificate file"""
    pass


class NoCertificateFile(ConversionError):
    """File was not available within archive"""
    pass

# ----------------------------------------------------------------------
# Command-line Interface
# ----------------------------------------------------------------------
@click.command()
@click.argument('input-path', type=click.Path(exists=True))
@click.argument('output', required=False, type=click.Path(), default=None)
def convert(input_path, output=None):
    '''Converts Viscosity package
    Args:
        input (str): path to folder or file input
        output (str): path to folder output  [default: None]
    '''
    if input_path.endswith('.visc'):
        output = input_path if output is None else output
        if output and not os.path.exists(output):
            output = input_path
        files = [os.path.join(input_path, filename) for filename in os.listdir(input_path)]
        for config_fp in files:
            new_config = []
            if config_fp.endswith('.conf'):
                with io.open(config_fp, encoding='utf-8') as stream:
                    connection_name = extract(stream, new_config, input_path=input_path)

                new_config.insert(0, '# OpenVPN Config for {}'.format(connection_name))
                new_config = '\n'.join(new_config) + '\n'
                output_filepath = os.path.join(output, '{}.ovpn'.format(connection_name))
                with io.open(output_filepath, 'w', encoding='utf-8') as out:
                    out.write(unicode(new_config))

                print('Wrote: {}'.format(output_filepath))

    elif input_path.endswith('.visz'):
        if output is None:
            output = os.path.dirname(input_path)

        data = {}
        with tarfile.open(input_path) as zipped:
            for filepath, fileinfo in zip(zipped.getnames(), zipped.getmembers()):
                if not fileinfo.isfile():
                    continue
                filename = filepath.split(os.path.sep)[-1]
                data[filename] = zipped.extractfile(filepath).read()

        for key in data:
            if not key.endswith('.conf') or key.startswith('.'):
                continue

            new_config = []
            lines = data[key].split('\n')
            connection_name = extract(lines, new_config, file_data=data)

            new_config.insert(0, '# OpenVPN Config for {}'.format(connection_name))
            new_config = '\n'.join(new_config) + '\n'
            output_filepath = os.path.join(output, '{}.ovpn'.format(connection_name))
            with io.open(output_filepath, 'w', encoding='utf-8') as out:
                out.write(unicode(new_config))

            print('Wrote: {}'.format(output_filepath))


# ----------------------------------------------------------------------
# CLI Support
# ----------------------------------------------------------------------
def extract(data, new_config, input_path=None, file_data={}):
    certificate_files = ['ca', 'cert', 'key', 'tls-auth']
    connection_name = ''
    for line in data:
        line = line.rstrip()

        if not line.strip():
            continue

        # This was an invalid configuration, for some reason
        elif line == 'compress lzo':
            continue

        elif line.startswith('#'):
            if line.startswith('#viscosity name'):
                connection_name = line.split('#viscosity name ', 1)[-1]
                connection_name = connection_name.strip()
            continue

        try:
            key, value = line.split(' ', 1)
            value = value.strip()
        except ValueError:
            key, value = line, ''

        if key in certificate_files:
            if key == 'tls-auth':
                try:
                    value, direction = value.split(' ', 1)
                    new_config.append('key-direction {}'.format(direction))
                except ValueError:
                    pass

            if input_path:
                cert_filepath = os.path.join(input_path, value)
                with io.open(cert_filepath, encoding='utf-8') as cf:
                    certificate = cf.read()
            else:
                if value not in file_data:
                    raise NoCertificateFile('Could not find certificate file in archive')
                certificate = file_data.get(value)

            if not certificate:
                raise NoCertificateData('Could not find certificate data')

            new_config.append('<%s>' % key)
            new_config.append(certificate)
            new_config.append('</%s>' % key)
            continue

        new_config.append(line)

    if not connection_name.strip():
        raise NoConnectionName('Could not find connection name in file.  Aborting')

    return connection_name


if __name__ == '__main__':
    convert()

```

`README.md`:

```md
# Tools
Combination of different utilities, have fun! 

## License
[![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2Fdoomedraven%2FTools.svg?type=large)](https://app.fossa.io/projects/git%2Bgithub.com%2Fdoomedraven%2FTools?ref=badge_large)

```

`Reversing/FullColor.idc`:

```idc
#include <idc.idc>
static main(void) {
  auto currentEA;
  auto currentMnem;
  auto prevMnem;
  auto currentOp;
  prevMnem = "";
  currentOp;
  currentEA = FirstSeg();
  currentEA = NextHead(currentEA, 0xFFFFFFFF);
  while (currentEA != BADADDR) {
    currentMnem = GetMnem(currentEA);

    //Highlight call functions
    if (currentMnem == "call")
      SetColor(currentEA, CIC_ITEM, 0xc7c7ff);
    //Non-zeroing XORs are often signs of data encoding
    if (currentMnem == "xor") {
      if (GetOpnd(currentEA, 0) != GetOpnd(currentEA, 1)) {
        SetColor(currentEA, CIC_ITEM, 0xFFFF00);
      }
    }
    //Instructions used for Anti-VM, sidt, sgdt, sldt, smsw, str, in, cpuid
    if (currentMnem == "sidt" || currentMnem == "sgdt" || currentMnem == "sldt"
      || currentMnem == "smsw" || currentMnem == "str"
      || currentMnem == "in" || currentMnem == "cpuid")
      SetColor(currentEA, CIC_ITEM, 0xFFFF00);

  //Highlight interrupts in code as an anti-debugging measure
  if (currentMnem == "int" &&
    (GetOpnd(currentEA, 0) == "3" || GetOpnd(currentEA, 0) == "2D")) {
    SetColor(currentEA, CIC_ITEM, 0xFFFF00);
  }

  //Highlight other instructions sometimes used for anti-debugging
  if (currentMnem == "rdtsc" || currentMnem == "icebp") {
    SetColor(currentEA, CIC_ITEM, 0xFFFF00);
  }
  //Highlight push/ret combinations as a shellcode
  if (currentMnem == "ret" && prevMnem == "push")
    SetColor(currentEA, CIC_ITEM, 0xFFFF00);

  currentEA = NextHead(currentEA, 0xFFFFFFFF);
  prevMnem = currentMnem;
  }
}
```

`Reversing/FullColor.py`:

```py
# encoding: utf-8
# http://www.hexblog.com/?p=120
# Default IDA Pro Paths:
# MAC	/Applications/IDA\ Pro\ X/idaq.app/Contents/MacOS/plugins/
# Windows	C:\Program Files (x86)\IDA X\plugins

# to make it autoexec on openfile
# add this to plugins.cfg
# ; Other plugins
#FullColor                        FullColor.py       0       0  SILENT

# thanks @JR0driguezB for help :)

from __future__ import print_function
from idautils import Heads
from idc import get_segm_start, get_segm_end, print_insn_mnem, get_screen_ea, print_operand, set_color, CIC_ITEM
import idaapi

#idaapi.auto_wait()
PLUGIN_TEST = 1

class FullColor_t(idaapi.plugin_t):
    flags = idaapi.PLUGIN_UNL
    comment = "Set colors :)"
    help = "No help needed"
    wanted_name = "FullColor"
    wanted_hotkey = ""

    def init(self):
        #idaapi.msg("init() called!\n")
        #self.run(0)
        return idaapi.PLUGIN_OK

    def run(self, arg=0):
        print("hell2")
        idaapi.msg("run() called with %d!\n" % arg)
        heads = Heads(get_segm_start(get_screen_ea()), get_segm_end(get_screen_ea()))
        funcCalls = []
        xor = []
        antiVM = []
        for i in heads:
            # Color the Calls off-white
            if print_insn_mnem(i) == "call":
                funcCalls.append(i)
            # Color Anti-VM instructions Red and print their location
            elif print_insn_mnem(i) in ("sidt", "sgdt",  "sldt", "smsw", "str", "in", "cpuid"):
                antiVM.append(i)
            # Color non-zeroing out xor instructions Orange
            elif print_insn_mnem(i) == "xor" and (print_operand(i,0) != print_operand(i,1)):
                xor.append(i)

        print("Number of calls: %d" % (len(funcCalls)))
        for i in funcCalls:
            set_color(i, CIC_ITEM, 0xc7fdff)

        print("Number of potential Anti-VM instructions: %d" % (len(antiVM)))
        for i in antiVM:
            print("Anti-VM potential at %x" % i)
            set_color(i, CIC_ITEM, 0x0000ff)

        print("Number of xor: %d" % (len(xor)))
        for i in xor:
            set_color(i, CIC_ITEM, 0x00a5ff)

    def term(self):
        idaapi.msg("term() called!\n")

def PLUGIN_ENTRY():
    return FullColor_t()

if PLUGIN_TEST:
    # Create form
    f = PLUGIN_ENTRY()
    f.init()
    f.run()
    f.term()

```

`Reversing/README.md`:

```md
Reversing related
===================
* __FullColor.(idc|py)__ - Ida highlight Call/Non-zeroing XORs/AntiDebug/Interruptss/etc [script origin](https://practicalmalwareanalysis.com/colorida-idc-2/)

```

`Reversing/flare-emu-string-deobfuscation.py`:

```py
# https://unit42.paloaltonetworks.com/using-idapython-to-make-your-life-easier-part-1/
# https://www.hex-rays.com/products/ida/support/ida74_idapython_no_bc695_porting_guide.shtml
# https://gitlab.com/krabsonsecurity/buer-loader-analysis/blob/master/stringdec.py
# https://hex-rays.com/products/ida/support/idapython_docs/

from __future__ import print_function
from datetime import datetime
import flare_emu

def find_function_arg_key(addr):
  while True:
    addr = idc.prev_head(addr)
    if idc.print_insn_mnem(addr) == "push":
      return idc.get_operand_value(addr, 0)
  return False

def deobfuscate(argv):
    myEH = flare_emu.EmuHelper()
    allocated = myEH.allocEmuMem(1024)
    # we do must disable skip calls due to internal calls
    # stack for x86, first arg is ret addr so 0
    # registers for x64
    myEH.emulateRange(myEH.analysisHelper.getNameAddr("stringDecrypt"), skipCalls=False, stack = [0, argv[0], "useless", allocated])
    return myEH.getEmuString(allocated).decode("latin-1")

if __name__ == '__main__':
    now = datetime.now()
    eh = flare_emu.EmuHelper()
    # you must rename func inside of the IDA
    deobf_func_addr = eh.analysisHelper.getNameAddr("stringDecrypt")
    for x in XrefsTo(deobf_func_addr):
        indexed = find_function_arg_key(x.frm)
        s = deobfuscate([indexed])
        print(f"{hex(x.frm)}: {s}")
        eh.analysisHelper.setComment(x.frm, s, False)
    print(f"It took {datetime.now()-now} seconds")

```

`Virtualization/README.md`:

```md
QEMU/KVM/libvirt related
===================
* [KVM bible](https://doc.opensuse.org/documentation/leap/virtualization/html/book.virt/)
* [Virtualization Best Practices](https://documentation.suse.com/sles/15-SP1/pdf/article-vt-best-practices_color_en.pdf)
* [Comprehensive guide to performance optimizations for gaming on virtual machines with KVM/QEMU and PCI passthrough](https://mathiashueber.com/performance-tweaks-gaming-on-virtual-machines/)
* __kvm-qemu.sh__ - ___PUBLIC VERSION___ -  Deploy they all!

```

`Virtualization/kvm-qemu.sh`:

```sh
#!/bin/bash

# Copyright (C) 2011-2023 DoomedRaven.
# This file is part of Tools - https://github.com/doomedraven/Tools
# See the file 'LICENSE.md' for copying permission.
# https://www.doomedraven.com/2016/05/kvm.html
# https://www.doomedraven.com/2020/04/how-to-create-virtual-machine-with-virt.html
# Use Ubuntu 22.04 LTS
# Update date: 22.02.2023

# Glory to Ukraine!

: '
Huge thanks to:
    * @SamRSA8
    * @http_error_418
    * @2sec4you
    * @seifreed
    * @Fire9
    * @abuse_ch
    * @wmetcalf
    * @ClaudioWayne
    * @CplNathan
'

# ToDo investigate
#https://www.jamescoyle.net/how-to/1810-qcow2-disk-images-and-performance
#when backing storage is attached to virtio_blk (vda, vdb, etc.) storage controller - performance from iSCSI client connecting to the iSCSI target was in my environment ~ 20 IOPS, with throughput (depending on IO size) ~ 2-3 MiB/s. I changed virtual disk controller within virtual machine to SCSI and I'm able to get 1000+ IOPS and throughput 100+ MiB/s from my iSCSI clients.

#https://linux.die.net/man/1/qemu-img
#"cluster_size"
#Changes the qcow2 cluster size (must be between 512 and 2M). Smaller cluster sizes can improve the image file size whereas larger cluster sizes generally provide better performance.

# https://github.com/dylanaraps/pure-bash-bible
# https://www.shellcheck.net/

# ACPI tables related
# https://wiki.archlinux.org/index.php/DSDT
# Dump on linux
#   acpidump > acpidump.out
# Dump on Windows
#   https://acpica.org/downloads/binary-tools
#    acpixtract -a acpi/4/acpi.dump

# acpixtract -a acpidump.out
# iasl -d DSDT.dat
# Decompile: iasl -d dsdt.dat
# Recompile: iasl -tc dsdt.dsl

# if you want all arches support in QEMU, just set QTARGETS to empty
QTARGETS="--target-list=i386-softmmu,x86_64-softmmu,i386-linux-user,x86_64-linux-user"


#https://www.qemu.org/download/#source or https://download.qemu.org/
qemu_version=8.0.0
# libvirt - https://libvirt.org/sources/
# changelog - https://libvirt.org/news.html
libvirt_version=9.2.0
# virt-manager - https://github.com/virt-manager/virt-manager/releases
# autofilled
OS=""
username=$SUDO_USER
MAINTAINER=""
# Skip last octet it will be auto populated
VM_NETWORK_RANGE="192.168.1"
DNS_PRIMARY="8.8.8.8"
DNS_SECONDARY="8.8.4.4"

systemctl mask sleep.target suspend.target hibernate.target hybrid-sleep.target

#replace all occurances of CPU's in qemu with our fake one
cpuid="Intel(R) Core(TM) i3-4130 CPU"
#cpuid="AMD FX(tm)-4300 Quad-Core Processor"

#KVMKVMKVM\\0\\0\\0 replacement
hypervisor_string_replacemnt="GenuineIntel"
#hypervisor_string_replacemnt="AuthenticAMD"

#QEMU HARDDISK
#qemu_hd_replacement="SanDisk SDSSD"
qemu_hd_replacement="SAMSUNG MZ76E120"
#QEMU DVD-ROM
#qemu_dvd_replacement="HL-DT-ST WH1"
#qemu_dvd_replacement="HL-PV-SG WB4"
qemu_dvd_replacement="HL-PQ-SV WB8"

#BOCHSCPU
bochs_cpu_replacement="INTELCPU"
#bochs_cpu_replacement="AMDCPU"

#QEMU\/Bochs
qemu_bochs_cpu='INTEL\/INTEL'
#qemu_bochs_cpu='AMD\/AMD'

#qemu
qemu_space_replacement="intel "
#qemu_space_replacement="amd "

#06\/23\/99
src_misc_bios_table="07\/02\/18"

#04\/01\/2014
src_bios_table_date2="11\/03\/2018"

#01\/01\/2011
src_fw_smbios_date="11\/03\/2018"

# ToDO add to see if cpu supports VTx
# egrep '(vmx|svm)' --color=always /proc/cpuinfo
#* If your CPU is Intel, you need activate in __BIOS__ VT-x
#    * (last letter can change, you can activate [TxT ](https://software.intel.com/en-us/blogs/2012/09/25/how-to-enable-an-intel-trusted-execution-technology-capable-server) too, and any other feature, but VT-* is very important)

# ToDo check if aptitude is installed if no refresh and install
sudo apt update 2>/dev/null
sudo apt install aptitude -y 2>/dev/null

NC='\033[0m'
RED='\033[0;31m'
echo -e "${RED}[!] ONLY for UBUNTU 20.04 and 22.04${NC}"
echo -e "${RED}\t[!] NEVER install packages from APT that installed by this script${NC}"
echo -e "${RED}\t[!] NEVER use 'make install' - it poison system and no easy way to upgrade/uninstall/cleanup, use dpkg-deb${NC}"
echo -e "${RED}\t[!] NEVER run 'python setup.py install' DO USE 'pip intall .' the same as APT poisoning/upgrading${NC}\n"
echo -e "${RED}\t[!] NEVER FORCE system upgrade, it will ignore blacklist and mess with packages installed by APT and this scritp!${NC}\n"

function usage() {
cat << EndOfHelp
    Usage: $0 <func_name> <args> | tee $0.log
    Commands - are case insensitive:
        All - <username_optional> - Execs QEMU/SeaBios/KVM, username is optional
        QEMU - Install QEMU from source,
            DEFAULT support are x86 and x64, set ENV var QEMU_TARGERS=all to install for all arches
        SeaBios - Install SeaBios and repalce QEMU bios file
        Libvirt <username_optional> - install libvirt, username is optional
        Apparmor - Install apparmor parsers
        KVM - <3
        GRUB - add IOMMU to grub command line
        tcp_bbr - Enable TCP BBR congestion control
            * https://www.cyberciti.biz/cloud-computing/increase-your-linux-server-internet-speed-with-tcp-bbr-congestion-control/
        Mosh - mobile shell - https://mosh.org/
        Clone - <VM_NAME> <path_to_hdd> <start_from_number> <#vm_to_create> <path_where_to_store> <network_range_base> <full/linked hdd>
                * Example Win7x64 /VMs/Win7x64.qcow2 0 5 /var/lib/libvirt/images/ 192.168.1 linked
                https://wiki.qemu.org/Documentation/CreateSnapshot
        Libvmi - install LibVMI
        Virtmanager - install virt-manager
        Libguestfs - install libguestfs
        Replace_qemu - only fix antivms in QEMU source
        Replace_seabios <path> - only fix antivms in SeaBios source
        Issues - will give you error - solution list
        noip - Install No-ip deamon and enable on boot
        SysRQ - enable SysRQ - https://sites.google.com/site/syscookbook/rhel/rhel-sysrq-key

    Tips:
        * Latest kernels having some KVM features :)
            * apt search linux-image
        * QCOW2 allocations types performance
            * https://www.jamescoyle.net/how-to/1810-qcow2-disk-images-and-performance
            * https://www.jamescoyle.net/how-to/2060-qcow2-physical-size-with-different-preallocation-settings
EndOfHelp
}

function grub_iommu(){
    # ToDo make a sed with regex which works on all cases
    echo "[+] Updating GRUB for IOMMU support"
    if ! sed -i 's/GRUB_CMDLINE_LINUX=""/GRUB_CMDLINE_LINUX="intel_iommu=on"/g' /etc/default/grub; then
        echo "[-] GRUB patching failed, add intel_iommu=on manually"
        return 1
    fi
    sudo update-grub
    echo "[+] Please reboot"
}

function _sed_aux(){
    # pattern path error_msg
    if [ -f "$2" ] && ! sed -i "$1" "$2"; then
        echo "$3"
    fi
}

function _enable_tcp_bbr() {
    # https://www.cyberciti.biz/cloud-computing/increase-your-linux-server-internet-speed-with-tcp-bbr-congestion-control/
    # grep 'CONFIG_TCP_CONG_BBR' /boot/config-$(uname -r)
    # grep 'CONFIG_NET_SCH_FQ' /boot/config-$(uname -r)
    # egrep 'CONFIG_TCP_CONG_BBR|CONFIG_NET_SCH_FQ' /boot/config-$(uname -r)
    if ! grep -q -E '^net.core.default_qdisc=fq' /etc/sysctl.conf; then
        echo "net.core.default_qdisc=fq" >> /etc/sysctl.conf
        echo "net.ipv4.tcp_congestion_control=bbr" >> /etc/sysctl.conf
    fi

    modprobe br_netfilter
    echo "br_netfilter" >> /etc/modules
    {
        echo "net.bridge.bridge-nf-call-arptables = 1";
        echo "net.bridge.bridge-nf-call-ip6tables = 1";
        echo "net.bridge.bridge-nf-call-iptables = 1";
        echo "net.core.rmem_max = 16777216";
        echo "net.core.wmem_max = 16777216";
        echo "net.ipv4.tcp_rmem = 4096 87380 16777216";
        echo "net.ipv4.tcp_wmem = 4096 65536 16777216";
        echo "net.ipv4.tcp_syncookies = 0" ;
        echo "net.ipv4.tcp_mem = 50576   64768   98152" ;
        echo "net.core.netdev_max_backlog = 2500" ;
        echo "vm.swappiness = 1" ;
        echo "vm.dirty_ratio = 15";
    } >> /etc/sysctl.conf
    sudo sysctl -p

    sudo sysctl --system
}

function install_apparmor() {
    aptitude install -f bison linux-generic-hwe-22.04 -y
    aptitude install -f apparmor apparmor-profiles apparmor-profiles-extra apparmor-utils libapparmor-dev libapparmor1  python3-apparmor python3-libapparmor libapparmor-perl -y
}


function install_libguestfs() {
    # https://libguestfs.org/guestfs-building.1.html
    cd /opt || return
    echo "[+] Check for previous version of LibGuestFS"
    sudo dpkg --purge --force-all "libguestfs-*" 2>/dev/null

    wget -O- https://packages.erlang-solutions.com/ubuntu/erlang_solutions.asc | sudo apt-key add -
    sudo add-apt-repository -y "deb https://packages.erlang-solutions.com/ubuntu $(lsb_release -sc) contrib"
    sudo aptitude install -f parted libyara3 erlang-dev gperf flex bison libaugeas-dev libhivex-dev supermin ocaml-nox libhivex-ocaml genisoimage libhivex-ocaml-dev libmagic-dev libjansson-dev gnulib jq ocaml-findlib -y 2>/dev/null
    sudo apt update
    sudo aptitude install -f erlang -y

    if [ ! -d libguestfs ]; then
        #ToDo move to latest release not latest code
        #_info=$(curl -s https://api.github.com/repos/libguestfs/libguestfs/releases/latest)
        #_version=$(echo $_info |jq .tag_name|sed "s/\"//g")
        #_repo_url=$(echo $_info | jq ".zipball_url" | sed "s/\"//g")
        #wget -q $_repo_url
        #unzip $_version
        git clone --recursive https://github.com/libguestfs/libguestfs
    fi
    cd libguestfs || return
    git submodule update --init
    autoreconf -i
    ./configure CFLAGS=-fPIC
    make -j"$(nproc)"

    # Install virt tools that are in a diff repo since LIBGUESTFS 1.46 split
    # More Info: https://listman.redhat.com/archives/libguestfs/2021-September/msg00153.html
    cd /opt || return
    if [ ! -d guestfs-tools ]; then
      git clone --recursive https://github.com/rwmjones/guestfs-tools.git
    fi
    cd guestfs-tools || return
    # Following tips to compile the guestfs-tools as depicted in https://www.mail-archive.com/libguestfs@redhat.com/msg22408.html
    git submodule update --init --force
    autoreconf -i
    ../libguestfs/run ./configure CFLAGS=-fPIC
    ../libguestfs/run make -j $(getconf _NPROCESSORS_ONLN)

    echo "[+] /opt/libguestfs/run --help"
    echo "[+] /opt/libguestfs/run /opt/guestfs-tools/sparsify/virt-sparsify -h"
}


function install_libvmi() {
    # IMPORTANT:
    # 1) LibVMI will have KVM support if libvirt is available during compile time.
    #
    # 2 )Enable GDB access to your KVM VM. This is done by adding '-s' to the VM creation line or
    #       by modifying the VM XML definition used by libvirt as follows:
    # Change:
    # <domain type='kvm'>
    # to:
    # <domain type='kvm' xmlns:qemu='http://libvirt.org/schemas/domain/qemu/1.0'>
    #
    # Add:
    # <qemu:commandline>
    #   <qemu:arg value='-s'/>
    # </qemu:commandline>
    # under the <domain> level of the XML.

    # The -s switch is a shorthand for -gdb tcp::1234

    # LibVMI
    cd /tmp || return

    if [ ! -d "libvmi" ]; then
        # git clone https://github.com/libvmi/libvmi.git
        wget -q https://github.com/libvmi/libvmi/archive/refs/tags/v0.14.0.zip -O libvmi-v0.14.0.zip
        unzip libvmi-v0.14.0.zip
        echo "[+] Cloned LibVMI repo"
    fi
    mkdir -p /tmp/libvmi_builded/DEBIAN
    echo -e "Package: libvmi\nVersion: 1.0-0\nArchitecture: $ARCH\nMaintainer: $MAINTAINER\nDescription: libvmi" > /tmp/libvmi_builded/DEBIAN/control
    cd "libvmi-v0.14.0" || return

    # install deps
    aptitude install -f -y cmake flex bison libglib2.0-dev libjson-c-dev libyajl-dev doxygen
    # other deps
    aptitude install -f -y pkg-config
    mkdir build
    cd build || return
    cmake -DENABLE_XEN=OFF -DENABLE_KVM=ON -DENABLE_XENSTORE=OFF -DENABLE_BAREFLANK=OFF ..

    make -j"$(nproc)" install DESTDIR=/tmp/libvmi_builded
    dpkg-deb --build --root-owner-group /tmp/libvmi_builded
    apt -y -o Dpkg::Options::="--force-overwrite" install /tmp/libvmi_builded.deb

    /sbin/ldconfig

    # LibVMI Python
    cd /tmp || return

    if [ ! -d "python" ]; then
        # actual
        # https://github.com/libvmi/python/tree/76d9ea85eefa0d77f6ad4d6089e757e844763917
        # git checkout add_vmi_request_page_fault
        # git pull
        #git clone https://github.com/libvmi/python.git libvmi-python
        pip3 install libvmi
        echo "[+] Cloned LibVMI Python repo"
    fi
    cd "libvmi-python" || return

    # install deps
    aptitude install -f -y python3-pkgconfig python3-cffi python3-future
    #pip3 install .
    python3 setup.py build
    pip3 install .

    # Rekall
    cd /tmp || return

    if [ ! -d "rekall" ]; then
        git clone https://github.com/google/rekall.git
        echo "[+] Cloned Rekall repo"
    fi

    virtualenv /tmp/MyEnv
    source /tmp/MyEnv/bin/activate
    pip3 install --upgrade testresources setuptools pip wheel
    pip3 install capstone
    pip3 install --editable rekall/rekall-lib
    # ERROR: rekall-efilter 1.6.0 has requirement future==0.16.0
    pip3 install future==0.16.0
    # TypeError: Set() missing 1 required positional argument: 'value'
    pip3 install pyaff4==0.26.post6
    pip3 install --editable rekall/rekall-core
    pip3 install --editable rekall/rekall-agent
    pip3 install --editable rekall
    pip3 install --upgrade pyasn1
    deactivate
}

# In progress...
#
# Errors: "The selected hypervisor has no events support!" - only Xen supported unfortunately
#
function install_pyvmidbg() {
    # deps
    aptitude install -f python3-docopt python3-lxml cabextract

    # libvmi config entry
    # /etc/libvmi.conf:
    # win10 {
    #    ostype = "Windows";
    #    rekall_profile = "/etc/libvmi/rekall-profile.json";
    # }

    # Make Windows 10 profile
    # Copy from Guest OS file "C:\Windows\System32\ntoskrnl.exe"
    # rekall peinfo -f <path/to/ntoskrnl.exe>
    #
    # Once the PDB filename and GUID is known, creating the Rekall profile is done in two steps:
    # rekall fetch_pdb <PDB filename> <GUID>
    # rekall parse_pdb <PDB filename> > rekall-profile.json
    #
    # In case of Windows 10:
    # rekall fetch_pdb ntkrnlmp <GUID>
    # May cause error like "ERROR:rekall.1:Unrecognized type T_64PUINT4" (not dangerous)
    # rekall parse_pdb ntkrnlmp > rekall-profile.json

    # install rekall profile
    # /etc/libvmi/rekall-profile.json

    # git clone https://github.com/Wenzel/pyvmidbg.git
    # virtualenv -p python3 venv
    # source venv/bin/activate
    # python3 setup.py build
    # pip3 install .

    # sudo python3 -m vmidbg 5000 <vm_name> --address 0.0.0.0 cmd -d

    # git clone https://github.com/radare/radare2.git
    # sys/install.sh
    # r2 -d gdb://127.0.0.1:5000 -b 64
}

function install_libvirt() {
    # http://ask.xmodulo.com/compile-virt-manager-debian-ubuntu.html
    #rm -r /usr/local/lib/python2.7/dist-packages/libvirt*

    if [ ! -f /etc/apt/preferences.d/doomedraven ]; then
    # set to hold to avoid side problems
        cat >> /etc/apt/preferences.d/doomedraven << EOH
Package: libvirt-bin
Pin: release *
Pin-Priority: -1
Package: libvirt0
Pin: release *
Pin-Priority: -1
Package: qemu
Pin: release *
Pin-Priority: -1
Package: qemu
Pin: release *
Pin-Priority: -1
Package: gir1.2-libvirt-glib-1.0
Pin: release *
Pin-Priority: -1
Package: libvirt-glib-1.0-0
Pin: release *
Pin-Priority: -1
Package: libvirt-glib-1.0-data
Pin: release *
Pin-Priority: -1
EOH
    fi

    # preferences.d doesnt work for me with qemu 7.0.0 and Ubuntu 22.04, to be sure, handle via dpkg
    echo "qemu hold" | sudo dpkg --set-selections 2>/dev/null
    echo "[+] Checking/deleting old versions of Libvirt"
    apt purge libvirt0 libvirt-bin libvirt-$libvirt_version 2>/dev/null
    dpkg -l|grep "libvirt-[0-9]\{1,2\}\.[0-9]\{1,2\}\.[0-9]\{1,2\}"|cut -d " " -f 3|sudo xargs dpkg --purge --force-all 2>/dev/null
    sudo apt install mlocate libxml2-utils gnutls-bin  gnutls-dev libxml2-dev bash-completion libreadline-dev numactl libnuma-dev python3-docutils flex -y
    # Remove old links
    updatedb
    temp_libvirt_so_path=$(locate libvirt-qemu.so | head -n1 | awk '{print $1;}')
    libvirt_so_path="${temp_libvirt_so_path%/*}/"

    if [[ -n "$libvirt_so_path" ]]; then
        for so_path in $(ls "${libvirt_so_path}"libvirt*.so.0);  do
            dest_path=/lib/$(uname -m)-linux-gnu/$(basename "$so_path")
            if [ -f "$dest_path" ]; then
                rm "$dest_path"
            fi
        done
    fi

    cd /tmp || return
    if [ -f  libvirt-$libvirt_version.tar.xz ]; then
        rm -r libvirt-$libvirt_version
    else
        wget -q https://libvirt.org/sources/libvirt-$libvirt_version.tar.xz
        wget -q https://libvirt.org/sources/libvirt-$libvirt_version.tar.xz.asc
        gpg --verify "libvirt-$libvirt_version.tar.xz.asc"
    fi
    tar xf libvirt-$libvirt_version.tar.xz
    cd libvirt-$libvirt_version || return
    if [ "$OS" = "Linux" ]; then
        aptitude install -f mlocate iptables python3-dev unzip numad libglib2.0-dev libsdl1.2-dev lvm2 python3-pip ebtables libosinfo-1.0-dev libnl-3-dev libnl-route-3-dev libyajl-dev xsltproc libdevmapper-dev libpciaccess-dev dnsmasq dmidecode librbd-dev libtirpc-dev -y 2>/dev/null

         # see https://github.com/doomedraven/Tools/issues/100
        install_apparmor

        pip3 install ipaddr ninja meson flake8 -U
        # --prefix=/usr --localstatedir=/var --sysconfdir=/etc
        #git init
        #git remote add doomedraven https://github.com/libvirt/libvirt
        # To see whole config sudo meson configure
        # true now is enabled
        cd /tmp/libvirt-$libvirt_version || return
        sudo meson build -D system=true -D driver_remote=enabled -D driver_qemu=enabled -D driver_libvirtd=enabled -D qemu_group=libvirt -D qemu_user=root -D secdriver_apparmor=enabled -D apparmor_profiles=enabled -D bash_completion=auto

        sudo ninja -C build
        sudo ninja -C build install
        if  [ $? -ne 0 ]; then
            echo "${RED}Failed. Read the instalation log for details${NC}"
            exit 1
        fi

        cd ..

        updatedb
        # ToDo fix bad destiny on some systems, example, first arg should be destiny to link not source
        # /usr/lib/x86_64-linux-gnu/libvirt-qemu.so.0 -> /usr/lib64/libvirt-qemu.so
        temp_libvirt_so_path=$(locate libvirt-qemu.so | head -n1 | awk '{print $1;}')
        temp_export_path=$(locate libvirt.pc | head -n1 | awk '{print $1;}')
        libvirt_so_path="${temp_libvirt_so_path%/*}/"
        if [[ $libvirt_so_path == "/usr/lib/x86_64-linux-gnu/" ]]; then
            temp_libvirt_so_path=$(locate libvirt-qemu.so | tail -1 | awk '{print $1;}')
            libvirt_so_path="${temp_libvirt_so_path%/*}/"
        fi
        export_path="${temp_export_path%/*}/"
        export PKG_CONFIG_PATH=$export_path

        if [[ -n "$libvirt_so_path" ]]; then
            # #ln -s /usr/lib64/libvirt-qemu.so /lib/x86_64-linux-gnu/libvirt-qemu.so.0
            for so_path in $(ls "${libvirt_so_path}"libvirt*.so.0); do ln -sf "$so_path" /lib/$(uname -m)-linux-gnu/$(basename "$so_path"); done
            ldconfig
        else
            echo "${RED}[!] Problem to create symlink, unknown libvirt_so_path path${NC}"
            exit 1
        fi
    fi

    # https://wiki.archlinux.org/index.php/Libvirt#Using_polkit
    if [ -f /etc/libvirt/libvirtd.conf ]; then
        path="/etc/libvirt/libvirtd.conf"
    elif [ -f /usr/local/etc/libvirt/libvirtd.conf ]; then
        path="/usr/local/etc/libvirt/libvirtd.conf"
    fi

    sed -i 's/#unix_sock_group/unix_sock_group/g' /etc/libvirt/*.conf
    sed -i 's/#unix_sock_ro_perms = "0777"/unix_sock_ro_perms = "0770"/g' /etc/libvirt/*.conf
    sed -i 's/#unix_sock_rw_perms = "0770"/unix_sock_rw_perms = "0770"/g' /etc/libvirt/*.conf
    sed -i 's/#auth_unix_ro = "none"/auth_unix_ro = "none"/g' /etc/libvirt/*.conf
    sed -i 's/#auth_unix_rw = "none"/auth_unix_rw = "none"/g' /etc/libvirt/*.conf
    sed -i 's/#auth_unix_ro = "polkit"/auth_unix_ro = "none"/g' /etc/libvirt/*.conf
    sed -i 's/#auth_unix_rw = "polkit"/auth_unix_rw = "none"/g' /etc/libvirt/*.conf

    #echo "[+] Setting AppArmor for libvirt/kvm/qemu"
    sed -i 's/#security_driver = "selinux"/security_driver = "apparmor"/g' /etc/libvirt/qemu.conf
    # https://gitlab.com/apparmor/apparmor/wikis/Libvirt
    FILES=(
        /etc/apparmor.d/usr.sbin.libvirtd
        /usr/sbin/libvirtd
        /usr/libexec/virt-aa-helper
    )
    for file in "${FILES[@]}"; do
        if [ -f "$file" ]; then
            sudo aa-complain "$file"
        fi
    done

    cd /tmp || return

    if [ ! -f v$libvirt_version.zip ]; then
        wget -q https://github.com/libvirt/libvirt-python/archive/v$libvirt_version.zip
    fi
    if [ -d "libvirt-python-$libvirt_version" ]; then
        rm -r "libvirt-python-$libvirt_version"
    fi
    unzip v$libvirt_version.zip
    cd "libvirt-python-$libvirt_version" || return
    python3 setup.py build
    pip3 install .
    if [ "$OS" = "Linux" ]; then
        # https://github.com/libvirt/libvirt/commit/e94979e901517af9fdde358d7b7c92cc055dd50c
        groupname=""
        if grep -q -E '^libvirtd:' /etc/group; then
            groupname="libvirtd"
        elif grep -q -E '^libvirt:' /etc/group; then
            groupname="libvirt"
        else
            # create group if missed
            groupname="libvirt"
            groupadd libvirt
        fi
        usermod -G $groupname -a "$(whoami)"
        if [[ -n "$username" ]]; then
            usermod -G $groupname -a "$username"
        fi

        #check links
        # sudo ln -s /usr/lib64/libvirt-qemu.so /lib/x86_64-linux-gnu/libvirt-qemu.so.0
        # sudo ln -s /usr/lib64/libvirt.so.0 /lib/x86_64-linux-gnu/libvirt.so.0
        systemctl enable virtqemud.service virtnetworkd.service virtstoraged.service virtqemud.socket
        echo "[+] You should logout and login "
    fi

}

function install_virt_manager() {
    #  pm-utils
    # from build-dep
    aptitude install -f libgirepository1.0-dev gtk-doc-tools python3 python3-pip gir1.2-govirt-1.0 libgovirt-dev \
    libgovirt-common libgovirt2 gir1.2-rest-0.7 unzip intltool augeas-doc ifupdown wodim cdrkit-doc indicator-application \
    augeas-tools radvd auditd systemtap nfs-common zfsutils python-openssl-doc samba \
    debootstrap sharutils-doc ssh-askpass gnome-keyring\
    sharutils spice-client-glib-usb-acl-helper ubuntu-mono x11-common python3-gi \
    python3-gi-cairo python3-pkg-resources \
    python3-libxml2 libxml2-utils libxrandr2 libxrender1 libxshmfence1 libxtst6 libxv1 libyajl2 msr-tools osinfo-db \
    python3-cairo python3-cffi-backend libxcb-present0 libxcb-render0 libxcb-shm0 libxcb-sync1 \
    libxcb-xfixes0 libxcomposite1 libxcursor1 libxdamage1 libxfixes3 libxft2 libxi6 libxinerama1 \
    libxkbcommon0 libusbredirhost1 libusbredirparser1 libv4l-0 libv4lconvert0 libvisual-0.4-0 libvorbis0a libvorbisenc2 \
    libvte-2.91-0 libvte-2.91-common libwavpack1 libwayland-client0 libwayland-cursor0 libwayland-egl1-mesa libwayland-server0 \
    libx11-xcb1 libxcb-dri2-0 libxcb-dri3-0 libsoup-gnome2.4-1 libsoup2.4-1 libspeex1 libspice-client-glib-2.0-8 \
    libspice-client-gtk-3.0-5 libspice-server1 libtag1v5 libtag1v5-vanilla libthai-data libthai0 libtheora0 libtiff5 \
    libtwolame0 libpython3-dev librados2 libraw1394-11 librbd1 librdmacm1 librest-0.7-0 \
    librsvg2-2 librsvg2-common libsamplerate0 libsdl1.2debian libshout3 libsndfile1 libpango-1.0-0 libpangocairo-1.0-0 \
    libpangoft2-1.0-0 libpangoxft-1.0-0 libpciaccess0 libphodav-2.0-0 libphodav-2.0-common libpixman-1-0 libproxy1v5 \
    libpulse-mainloop-glib0 libpulse0 libgstreamer1.0-0 libgtk-3-0 libgtk-3-bin libgtk-3-common libgtk-vnc-2.0-0 \
    libgudev-1.0-0 libgvnc-1.0-0 libharfbuzz0b libibverbs1 libiec61883-0 libindicator3-7 libiscsi7 libjack-jackd2-0 libjbig0 \
    libjpeg-turbo8 libjpeg8 libjson-glib-1.0-0 libjson-glib-1.0-common liblcms2-2 libmp3lame0 libmpg123-0 libnl-route-3-200 \
    libnspr4 libnss3 libogg0 libopus0 liborc-0.4-0 libosinfo-1.0-0 libcairo-gobject2 libcairo2 libcdparanoia0 libcolord2 \
    libcups2 libdatrie1 libdbusmenu-glib4 libdbusmenu-gtk3-4 libdconf1 libdv4 libegl-mesa0 libegl1 libepoxy0 libfdt1 libflac8 \
    libfontconfig1 libgbm1 libgdk-pixbuf2.0-0 libgdk-pixbuf2.0-bin libgdk-pixbuf2.0-common libglapi-mesa libglvnd0  libgraphite2-3 \
    libgstreamer-plugins-base1.0-0 libgstreamer-plugins-good1.0-0 gtk-update-icon-cache hicolor-icon-theme humanity-icon-theme \
    ibverbs-providers  libaa1 libaio1 libappindicator3-1 libasound2 libasound2-data libasyncns0 libatk-bridge2.0-0 libatk1.0-0 \
    libatk1.0-data libatspi2.0-0 libaugeas0 libavahi-client3 libavahi-common-data libavahi-common3 libavc1394-0 libbluetooth3 \
    libcaca0 libcacard0 gir1.2-atk-1.0 gir1.2-freedesktop gir1.2-gdkpixbuf-2.0 gir1.2-gtk-3.0 gir1.2-gtk-vnc-2.0 \
    gir1.2-libosinfo-1.0  gir1.2-pango-1.0 gir1.2-spiceclientglib-2.0 gir1.2-spiceclientgtk-3.0 gir1.2-vte-2.91 glib-networking \
    glib-networking-common glib-networking-services gsettings-desktop-schemas gstreamer1.0-plugins-base gstreamer1.0-plugins-good \
    gstreamer1.0-x adwaita-icon-theme at-spi2-core augeas-lenses cpu-checker dconf-gsettings-backend dconf-service \
    fontconfig fontconfig-config fonts-dejavu-core genisoimage gir1.2-appindicator3-0.1 gir1.2-secret-1 \
    gobject-introspection intltool pkg-config libxml2-dev libxslt-dev python3-dev gir1.2-gtk-vnc-2.0 gir1.2-spiceclientgtk-3.0 libgtk-3-dev \
    mlocate gir1.2-gtksource-4 libgtksourceview-4-0 libgtksourceview-4-common checkinstall -y
    # should be installed first
    # moved out as some 20.04 doesn't have this libs %)
    aptitude install -f -y python3-ntlm-auth libpython3-stdlib libbrlapi-dev libgirepository1.0-dev python3-testresources
    apt-get -y -o Dpkg::Options::="--force-overwrite" install ovmf
    pip3 install tqdm requests six urllib3 ipaddr ipaddress idna dbus-python certifi lxml cryptography pyOpenSSL chardet asn1crypto pycairo PySocks PyGObject

    # not available in 22.04
    if [ $(lsb_release -sc) != "jammy" ]; then
    	aptitude -f install python-enum34 libxenstore3.0 libnetcf1 libcroco3 -y
    fi

    updatedb

    temp_libvirt_so_path=$(locate libvirt-qemu.so | head -n1 | awk '{print $1;}')
    temp_export_path=$(locate libvirt.pc | head -n1 | awk '{print $1;}')
    libvirt_so_path="${temp_libvirt_so_path%/*}/"
    export_path="${temp_export_path%/*}/"

    export PKG_CONFIG_PATH=$export_path

    cd /tmp || return
    if [ ! -f libvirt-glib-3.0.0.tar.gz ]; then
        wget -q https://libvirt.org/sources/glib/libvirt-glib-3.0.0.tar.gz
        wget -q https://libvirt.org/sources/glib/libvirt-glib-3.0.0.tar.gz.asc
        gpg --verify "libvirt-glib-3.0.0.tar.gz.asc"

    fi
    tar xf libvirt-glib-3.0.0.tar.gz
    cd libvirt-glib-3.0.0 || return
    aclocal && libtoolize --force
    automake --add-missing
    ./configure
    # mkdir -p /tmp/libvirt-glib_builded/DEBIAN
    # echo -e "Package: libvirt-glib-1.0-0\nVersion: 1.0-0\nArchitecture: $ARCH\nMaintainer: $MAINTAINER\nDescription: libvirt-glib-1.0-0" > /tmp/libvirt-glib_builded/DEBIAN/control
    # make -j"$(nproc)" install DESTDIR=/tmp/libvirt-glib_builded
    # dpkg-deb --build --root-owner-group /tmp/libvirt-glib_builded
    # apt -y -o Dpkg::Options::="--force-overwrite" install /tmp/libvirt-glib_builded.deb

    make -j"$(nproc)"
    # ToDo add blacklist
    checkinstall --pkgname=libvirt-glib-1.0-0 --default
    # v4 is meson based
    # sudo meson build -D system=true
    cd /tmp || return
    if [ ! -f gir1.2-libvirt-glib-1.0_1.0.0-1_amd64.deb ]; then
        wget -q http://launchpadlibrarian.net/297448356/gir1.2-libvirt-glib-1.0_1.0.0-1_amd64.deb
    fi
    dpkg --force-confold -i gir1.2-libvirt-glib-1.0_1.0.0-1_amd64.deb

    /sbin/ldconfig

    if [ ! -d "virt-manager" ]; then
        git clone https://github.com/virt-manager/virt-manager.git
        echo "[+] Cloned Virt Manager repo"
    fi
    cd "virt-manager" || return
    # py3
    #pip3 install .
    python3 setup.py build
    python3 setup.py install
    if [ "$SHELL" = "/bin/zsh" ] || [ "$SHELL" = "/usr/bin/zsh" ] ; then
        echo "export LIBVIRT_DEFAULT_URI=qemu:///system" >> "$HOME/.zsh"
    else
        echo "export LIBVIRT_DEFAULT_URI=qemu:///system" >> "$HOME/.bashrc"
    fi
    sudo glib-compile-schemas --strict /usr/share/glib-2.0/schemas/
    systemctl enable virtstoraged.service
    systemctl start virtstoraged.service

    # i440FX-Issue Win7: Unable to complete install: 'XML error: The PCI controller with index='0' must be model='pci-root' for this machine type, but model='pcie-root' was found instead'
    # Workaround: Edit Overiew in XML view and delete all controller entries with type="pci"
    # Example:
    # <controller type="pci" model="pcie-root"/>
    # <controller type="pci" model="pcie-root-port"/>
}

function install_kvm_linux() {
    sed -i 's/# deb-src/deb-src/g' /etc/apt/sources.list
    apt update 2>/dev/null
    aptitude install -f build-essential locate python3-pip gcc pkg-config cpu-checker intltool libtirpc-dev -y 2>/dev/null
    aptitude install -f gtk-update-icon-cache -y 2>/dev/null

    # WSL support
    aptitude install -f gcc make gnutls-bin -y
    # remove old
    apt purge libvirt0 libvirt-bin -y
    apt-mark hold libvirt0 libvirt-bin
    install_libvirt

    systemctl enable libvirtd.service virtlogd.socket
    systemctl restart libvirtd.service virtlogd.socket

    kvm-ok

    if ! grep -q -E '^net.bridge.bridge-nf-call-ip6tables' /etc/sysctl.conf; then
        cat >> /etc/sysctl.conf << EOF
net.bridge.bridge-nf-call-ip6tables = 0
net.bridge.bridge-nf-call-iptables = 0
net.bridge.bridge-nf-call-arptables = 0
EOF
    fi
    # Ubuntu 18.04:
    # /dev/kvm permissions always changed to root after reboot
    # "chown root:libvirt /dev/kvm" doesnt help
    addgroup kvm
    usermod -a -G kvm "$(whoami)"
    if [[ -n "$username" ]]; then
        usermod -a -G kvm "$username"
    fi
    chgrp kvm /dev/kvm
    if [ ! -f /etc/udev/rules.d/50-qemu-kvm.rules ]; then
        echo 'KERNEL=="kvm", GROUP="kvm", MODE="0660"' >> /etc/udev/rules.d/50-qemu-kvm.rules
    fi

    echo 1 > /sys/module/kvm/parameters/ignore_msrs
    echo 0 > /sys/module/kvm/parameters/report_ignored_msrs

    if [ ! -f /etc/modprobe.d/kvm.conf ]; then
        cat >> /etc/modprobe.d/kvm.conf << EOF
options kvm ignore_msrs=Y
options kvm report_ignored_msrs=N
EOF
    fi
}


function replace_qemu_clues_public() {
    echo '[+] Patching QEMU clues'
    _sed_aux "s/QEMU HARDDISK/$qemu_hd_replacement/g" qemu*/hw/ide/core.c 'QEMU HARDDISK was not replaced in core.c'
    _sed_aux "s/QEMU HARDDISK/$qemu_hd_replacement/g" qemu*/hw/scsi/scsi-disk.c 'QEMU HARDDISK was not replaced in scsi-disk.c'
    _sed_aux "s/QEMU DVD-ROM/$qemu_dvd_replacement/g" qemu*/hw/ide/core.c 'QEMU DVD-ROM was not replaced in core.c'
    _sed_aux "s/QEMU DVD-ROM/$qemu_dvd_replacement/g" qemu*/hw/ide/atapi.c 'QEMU DVD-ROM was not replaced in atapi.c'
    _sed_aux "s/QEMU PenPartner tablet/<WOOT> PenPartner tablet/g" qemu*/hw/usb/dev-wacom.c 'QEMU PenPartner tablet'
    _sed_aux 's/s->vendor = g_strdup("QEMU");/s->vendor = g_strdup("<WOOT>");/g' qemu*/hw/scsi/scsi-disk.c 'Vendor string was not replaced in scsi-disk.c'
    _sed_aux "s/QEMU CD-ROM/$qemu_dvd_replacement/g" qemu*/hw/scsi/scsi-disk.c 'Vendor string was not replaced in scsi-disk.c'
    _sed_aux 's/padstr8(buf + 8, 8, "QEMU");/padstr8(buf + 8, 8, "<WOOT>");/g'  qemu*/hw/ide/atapi.c 'padstr was not replaced in atapi.c'
    _sed_aux 's/QEMU MICRODRIVE/<WOOT> MICRODRIVE/g' qemu*/hw/ide/core.c 'QEMU MICRODRIVE was not replaced in core.c'
    _sed_aux "s/KVMKVMKVM\\0\\0\\0/$hypervisor_string_replacemnt/g" qemu*/target/i386/kvm.c 'KVMKVMKVM was not replaced in kvm.c'
    _sed_aux 's/"bochs"/"<WOOT>"/g' qemu*/block/bochs.c 'BOCHS was not replaced in block/bochs.c'
    _sed_aux 's/"BOCHS "/"ALASKA"/g' qemu*/include/hw/acpi/aml-build.h 'BOCHS was not replaced in block/bochs.c'
    _sed_aux 's/Bochs Pseudo/Intel RealTime/g' qemu*/roms/ipxe/src/drivers/net/pnic.c 'Bochs Pseudo was not replaced in roms/ipxe/src/drivers/net/pnic.c'
}

function replace_seabios_clues_public() {
    echo "[+] Generating SeaBios Kconfig"
    echo "[+] Fixing SeaBios antivms"
    _sed_aux 's/Bochs/DELL/g' src/config.h 'Bochs was not replaced in src/config.h'
    _sed_aux "s/BOCHSCPU/$bochs_cpu_replacement/g" src/config.h 'BOCHSCPU was not replaced in src/config.h'
    _sed_aux 's/"BOCHS "/"DELL"/g' src/config.h 'BOCHS was not replaced in src/config.h'
    _sed_aux 's/BXPC/DELL/g' src/config.h 'BXPC was not replaced in src/config.h'
    _sed_aux "s/QEMU\/Bochs/$qemu_bochs_cpu/g" vgasrc/Kconfig 'QEMU\/Bochs was not replaced in vgasrc/Kconfig'
    _sed_aux "s/qemu /$qemu_space_replacement/g" vgasrc/Kconfig 'qemu was not replaced in vgasrc/Kconfig'
    _sed_aux "s/06\/23\/99/$src_misc_bios_table/g" src/misc.c 'change seabios date 1'
    _sed_aux "s/04\/01\/2014/$src_bios_table_date2/g" src/fw/biostables.c 'change seabios date 2'
    _sed_aux "s/01\/01\/2011/$src_fw_smbios_date/g" src/fw/smbios.c 'change seabios date 3'
    _sed_aux 's/"SeaBios"/"AMIBios"/g' src/fw/biostables.c 'change seabios to amibios'

    FILES=(
        src/hw/blockcmd.c
        src/fw/paravirt.c
    )
    for file in "${FILES[@]}"; do
        _sed_aux 's/"QEMU/"<WOOT>/g' "$file" "QEMU was not replaced in $file"
    done

    _sed_aux 's/"QEMU"/"<WOOT>"/g' src/hw/blockcmd.c '"QEMU" was not replaced in  src/hw/blockcmd.c'

    FILES=(
        "src/fw/acpi-dsdt.dsl"
        "src/fw/q35-acpi-dsdt.dsl"
    )
    for file in "${FILES[@]}"; do
        _sed_aux 's/"BXPC"/"<WOOT>"/g' "$file" "BXPC was not replaced in $file"
    done
    _sed_aux 's/"BXPC"/"AMPC"/g' "src/fw/ssdt-pcihp.dsl" 'BXPC was not replaced in src/fw/ssdt-pcihp.dsl'
    _sed_aux 's/"BXDSDT"/"AMDSDT"/g' "src/fw/ssdt-pcihp.dsl" 'BXDSDT was not replaced in src/fw/ssdt-pcihp.dsl'
    _sed_aux 's/"BXPC"/"AMPC"/g' "src/fw/ssdt-proc.dsl" 'BXPC was not replaced in "src/fw/ssdt-proc.dsl"'
    _sed_aux 's/"BXSSDT"/"AMSSDT"/g' "src/fw/ssdt-proc.dsl" 'BXSSDT was not replaced in src/fw/ssdt-proc.dsl'
    _sed_aux 's/"BXPC"/"AMPC"/g' "src/fw/ssdt-misc.dsl" 'BXPC was not replaced in src/fw/ssdt-misc.dsl'
    _sed_aux 's/"BXSSDTSU"/"AMSSDTSU"/g' "src/fw/ssdt-misc.dsl" 'BXDSDT was not replaced in src/fw/ssdt-misc.dsl'
    _sed_aux 's/"BXSSDTSUSP"/"AMSSDTSUSP"/g' src/fw/ssdt-misc.dsl 'BXSSDTSUSP was not replaced in src/fw/ssdt-misc.dsl'
    _sed_aux 's/"BXSSDT"/"AMSSDT"/g' src/fw/ssdt-proc.dsl 'BXSSDT was not replaced in src/fw/ssdt-proc.dsl'
    _sed_aux 's/"BXSSDTPCIHP"/"AMSSDTPCIHP"/g' src/fw/ssdt-pcihp.dsl 'BXPC was not replaced in src/fw/ssdt-pcihp.dsl'

    FILES=(
        src/fw/q35-acpi-dsdt.dsl
        src/fw/acpi-dsdt.dsl
        src/fw/ssdt-misc.dsl
        src/fw/ssdt-proc.dsl
        src/fw/ssdt-pcihp.dsl
        src/config.h
    )
    for file in "${FILES[@]}"; do
        _sed_aux 's/"BXPC"/"A M I"/g' "$file" "BXPC was not replaced in $file"
    done
}

function install_qemu() {
    cd /tmp || return

    echo '[+] Cleaning QEMU old install if exists'
    rm -r /usr/share/qemu >/dev/null 2>&1
    dpkg -r ubuntu-vm-builder python-vm-builder >/dev/null 2>&1
    dpkg -l |grep qemu |cut -d " " -f 3|xargs dpkg --purge --force-all >/dev/null 2>&1

    echo '[+] Downloading QEMU source code'
    if [ ! -f qemu-$qemu_version.tar.xz ]; then
        wget -q "https://download.qemu.org/qemu-$qemu_version.tar.xz"
        wget -q "https://download.qemu.org/qemu-$qemu_version.tar.xz.sig"
        gpg --verify "qemu-$qemu_version.tar.xz.sig"
    fi

    if [ ! -f qemu-$qemu_version.tar.xz ]; then
        echo "[-] Download qemu-$qemu_version failed"
        exit
    fi

    if ! tar xf "qemu-$qemu_version.tar.xz" ; then
        echo "[-] Failed to extract, check if download was correct"
        exit 1
    fi

    if [ "$OS" = "Linux" ]; then
        aptitude install -f software-properties-common -y
        add-apt-repository universe -y
        apt update 2>/dev/null
        aptitude install -f python3-pip openbios-sparc openbios-ppc libssh2-1-dev vde2 liblzo2-dev libghc-gtk3-dev libsnappy-dev libbz2-dev libxml2-dev google-perftools libgoogle-perftools-dev libvde-dev python3-sphinx-rtd-theme -y
        aptitude install -f debhelper libusb-1.0-0-dev libxen-dev uuid-dev xfslibs-dev libjpeg-dev libusbredirparser-dev device-tree-compiler texinfo libbluetooth-dev libbrlapi-dev libcap-ng-dev libcurl4-gnutls-dev libfdt-dev gnutls-dev libiscsi-dev libncurses5-dev libnuma-dev libcacard-dev librados-dev librbd-dev libsasl2-dev libseccomp-dev libspice-server-dev libaio-dev libcap-dev libattr1-dev libpixman-1-dev libgtk2.0-bin  libxml2-utils systemtap-sdt-dev uml-utilities libcapstone-dev -y
        # qemu docs required
        PERL_MM_USE_DEFAULT=1 perl -MCPAN -e install "Perl/perl-podlators"
        pip3 install sphinx ninja
    fi
    # WOOT
    # some checks may be depricated, but keeping them for compatibility with old versions
    #if [ $? -eq 0 ]; then
        if declare -f -F "replace_qemu_clues"; then
            # Private version
            replace_qemu_clues
        else
            # Public version
            replace_qemu_clues_public
        fi
        # ToDo reintroduce it?
        #if [ $fail -eq 0 ]; then
            echo '[+] Starting compile it'
            cd qemu-$qemu_version || return
            # add in future --enable-netmap https://sgros-students.blogspot.com/2016/05/installing-and-testing-netmap.html
            # remove --target-list=i386-softmmu,x86_64-softmmu,i386-linux-user,x86_64-linux-user  if you want all targets
                ./configure $QTARGETS --prefix=/usr --libexecdir=/usr/lib/qemu --localstatedir=/var --bindir=/usr/bin/ --enable-gnutls --enable-docs --enable-gtk --enable-vnc --enable-vnc-sasl --enable-curl --enable-kvm  --enable-linux-aio --enable-cap-ng --enable-vhost-net --enable-vhost-crypto --enable-spice --enable-usb-redir --enable-lzo --enable-snappy --enable-bzip2 --enable-coroutine-pool --enable-replication --enable-tools
                #  --enable-capstone
            if  [ $? -eq 0 ]; then
                echo '[+] Starting Install it'
                if [ -f /usr/share/qemu/qemu_logo_no_text.svg ]; then
                    rm /usr/share/qemu/qemu_logo_no_text.svg
                fi
                mkdir -p /tmp/qemu-"$qemu_version"_builded/DEBIAN
                echo -e "Package: qemu\nVersion: $qemu_version\nArchitecture: $ARCH\nMaintainer: $MAINTAINER\nDescription: Custom antivm qemu" > /tmp/qemu-"$qemu_version"_builded/DEBIAN/control
                make -j"$(nproc)" install DESTDIR=/tmp/qemu-"$qemu_version"_builded
                if [ "$OS" = "Linux" ]; then
                    dpkg-deb --build --root-owner-group /tmp/qemu-"$qemu_version"_builded
                    apt -y -o Dpkg::Options::="--force-overwrite" install /tmp/qemu-"$qemu_version"_builded.deb
                elif [ "$OS" = "Darwin" ]; then
                    make -j"$(nproc)" install
                fi
                # hack for libvirt/virt-manager
                if [ ! -f /usr/bin/qemu-system-x86_64-spice ]; then
                    ln -s /usr/bin/qemu-system-x86_64 /usr/bin/qemu-system-x86_64-spice
                fi
                if [ ! -f /usr/bin/kvm-spice ]; then
                    ln -s /usr/bin/qemu-system-x86_64 /usr/bin/kvm-spice
                fi
                if [ ! -f /usr/bin/kvm ]; then
                    ln -s /usr/bin/qemu-system-x86_64 /usr/bin/kvm
                fi
                if  [ $? -eq 0 ]; then
                    echo '[+] Patched, compiled and installed'
                else
                    echo '[-] Install failed'
                fi
            else
                echo '[-] Compilling failed'
            fi
        #else
        #    echo '[-] Check previous output'
        #    exit
        #fi

    #else
    #    echo '[-] Download QEMU source was not possible'
    #fi
    if [ "$OS" = "linux" ]; then
        dpkg --get-selections | grep "qemu" | xargs apt-mark hold
        dpkg --get-selections | grep "libvirt" | xargs apt-mark hold
        apt-mark unhold qemu libvirt
    fi

}

function install_seabios() {
    cd /tmp || return
    echo '[+] Installing SeaBios dependencies'
    aptitude install -f git acpica-tools -y
    if [ -d seabios ]; then
        rm -r seabios
    fi
    if git clone https://github.com/coreboot/seabios.git; then
        cd seabios || return
        if declare -f -F "replace_seabios_clues"; then
            replace_seabios_clues
        else
            replace_seabios_clues_public
        fi
        # make help
        # make menuconfig -> BIOS tables -> disable Include default ACPI DSDT
        # get rid of this hack
        make -j"$(nproc)" 2>/dev/null
        # Windows 10(latest rev.) is uninstallable without ACPI_DSDT
        # sed -i 's/CONFIG_ACPI_DSDT=y/CONFIG_ACPI_DSDT=n/g' .config
        sed -i 's/CONFIG_XEN=y/CONFIG_XEN=n/g' .config
        sed -i 's/PYTHON=python/PYTHON=python3/g' Makefile
        if make -j "$(nproc)"; then
            echo '[+] Replacing old bios.bin to new out/bios.bin'
            bios=0
            SHA256_BIOS=$(shasum -a 256 out/bios.bin|awk '{print $1}')

            #if [ ! -f /usr/share/qemu/bios.bin_back ]; then
            #    cp /usr/share/qemu/bios.bin /usr/share/qemu/bios.bin_back
            #    cp /usr/share/qemu/bios-256k.bin /usr/share/qemu/bios-256k.bin_back
            #fi

            FILES=(
                "/usr/share/qemu/bios.bin"
                "/usr/share/qemu/bios-256k.bin"
            )
            for file in "${FILES[@]}"; do
                cp -vf out/bios.bin "$file"
                SHA256_BIOS_TMP=$(shasum -a 256 $file|awk '{print $1}')
                if [[ $SHA256_BIOS_TMP != $SHA256_BIOS ]]; then
                    echo "[-] BIOS hashes doesn't match: $SHA256_BIOS - $SHA256_BIOS_TMP"
                    bios=0
                else
                    bios=1
                fi
            done

            if grep -q -E 'prebuild.qemu.org' /usr/share/qemu/bios.bin; then
                echo 'YOUR BIOS /usr/share/qemu/bios.bin is default, you might have max RAM limit inside of the VM, replace with latest compiled'
                bios=0
            fi

            if [ $bios -eq 1 ]; then
                echo '[+] Patched bios.bin placed correctly'
            else
                echo '[-] Bios patching failed'
            fi
        else
            echo '[-] Bios compilation failed'
        fi
        cd - || return
    else
        echo '[-] Check if git installed or network connection is OK'
    fi
}

function enable_sysrq(){
    if ! grep -q -E '^kernel.sysrq=1' /etc/sysctl.conf; then
        echo "kernel.sysrq=1" >> /etc/sysctl.conf
    fi
}

function issues(){
cat << EndOfHelp
### Links:
    * https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/virtualization_deployment_and_administration_guide/sect-troubleshooting-common_libvirt_errors_and_troubleshooting
    * https://wiki.libvirt.org/page/Failed_to_connect_to_the_hypervisor

### Errors and Solutions

    * Error:
        * VM can't use more than 2-3Gb of ram for x64 VM
    * Solution:
        * Ensure that you not using default QEMU bios.bin, use next command to check, it shouldn't find coincidences
            * grep "prebuild.qemu.org" /usr/share/qemu/bios.bin
    * Error:
        * GLib-GIO-ERROR **: 09:05:35.162: Settings schema 'org.virt-manager.virt-manager' is not installed
    * Solution:
        * sudo glib-compile-schemas --strict /usr/share/glib-2.0/schemas/

    * Error:
        * error: internal error: cannot load AppArmor profile
    * Solution:
        * Any apparmor error try to run:  /usr/libexec/virt-aa-helper or journalctl -u libvirtd | cat
        * most of the issues with AppArmor is related to libvirt problems

    * Error:
        * /usr/libexec/virt-aa-helper: error while loading shared libraries: libvirt.so.0: cannot open shared object file: No such file or directory
    * Solution:
        strace -Tfe trace=openat /usr/libexec/virt-aa-helper

    * Error
        /usr/libexec/virt-aa-helper: error while loading shared libraries: libvirt.so.0: cannot open shared object file: Permission denied
    * Solution:
        aa-complain /usr/libexec/virt-aa-helper

    * Error:
        * If you getting an apparmor error
    * Solution
        * sed -i 's/#security_driver = "apparmor"/security_driver = "apparmor"/g' /etc/libvirt/qemu.conf

    * Error:
        required by /usr/lib/libvirt/storage-file/libvirt_storage_file_fs.so
    * Solution:
        systemctl daemon-reload
        systemctl restart libvirtd libvirt-guests.service

    * Error:
        /libvirt.so.0: version LIBVIRT_PRIVATE_x.x.0' not found (required by /usr/sbin/libvirtd)
    * Solutions:
        1. apt purge libvirt0 libvirt-bin
        2. reboot
        3. $0 libvirt

        Can be extra help, but normally solved with first3 steps
        1. ldd /usr/sbin/libvirtd
        2. ls -lah /usr/lib/libvirt*
            * Make sure what all symlinks pointing to last version
    * Error:
        * Libvirt sometimes causes access denied errors with access the locations different from "/var/lib/libvirt/images"
    * Solution:
        * sed -i 's/user = "root"/user = "$(whoami)"/g' /etc/libvirt/qemu.conf
        * sed -i 's/user = "root"/group = "libvirt"/g' /etc/libvirt/qemu.conf

    * Error:
        libvirt: Polkit error : authentication unavailable: no polkit agent available to authenticate action 'org.libvirt.unix.manage'
    * Solutions:
        1.
            sed -i 's/#unix_sock_group/unix_sock_group/g' /etc/libvirt/libvirtd.conf
            sed -i 's/#unix_sock_ro_perms = "0777"/unix_sock_ro_perms = "0770"/g' /etc/libvirt/libvirtd.conf
            sed -i 's/#unix_sock_rw_perms = "0770"/unix_sock_rw_perms = "0770"/g' /etc/libvirt/libvirtd.conf
            sed -i 's/#auth_unix_ro = "none"/auth_unix_ro = "none"/g' /etc/libvirt/libvirtd.conf
            sed -i 's/#auth_unix_rw = "none"/auth_unix_rw = "none"/g' /etc/libvirt/libvirtd.conf
        2. Add ssh key to $HOME/.ssh/authorized_keys
            virt-manager -c "qemu+ssh://user@host/system?socket=/var/run/libvirt/libvirt-sock"

    * Error:
        unable to execute QEMU command 'getfd'
    * Solution:
        Compile without apparmor

    * Slow HDD/Snapshot taking performance?
        Modify
            <driver name='qemu' type='qcow2'/>
        To
            <driver name='qemu' type='qcow2' cache='none' io='native'/>
    * Error:
        error : virPidFileAcquirePath:422 : Failed to acquire pid file '/var/run/libvirtd.pid': Resource temporarily unavailable
    * Solution
        ps aux | grep libvirtd
    * Error:
        Failed to connect socket to '/var/run/libvirt/libvirt-sock': Permission denied
    * Solution:
        * usermod -G libvirt -a username
        * log out and log in

    * Error:
        yara: error while loading shared libraries: libyara.so.3: cannot open shared object file: No such file or directory

    Solution 1:
        aptitude install -f libyara3
    Solution 2:
        sudo echo "/usr/local/lib" >> /etc/ld.so.conf
        sudo ldconfig

    # Fixes from http://ask.xmodulo.com/compile-virt-manager-debian-ubuntu.html
    1. ImportError: No module named libvirt
    $ ./kvm-qemu.sh libvirt

    2. ImportError: No module named libxml2
    $ pip3 install libxml2-python3

    3. ImportError: No module named requests
    $ aptitude install -f python-requests

    4. Error launching details: Namespace GtkVnc not available
    $ ./kvm-qemu.sh libvirt

    5. ValueError: Namespace LibvirtGLib not available
    $ ./kvm-qemu.sh libvirt

    6. ValueError: Namespace Libosinfo not available
    $ aptitude install -f libosinfo-1.0

    7. ImportError: No module named ipaddr
    $ aptitude install -f python-ipaddr

    8. Namespace Gtk not available: Could not open display: localhost:10.0
    8 ValueError: Namespace GtkSource not available
    $ aptitude install -f gir1.2-gtksource-4 libgtksourceview-4-0 libgtksourceview-4-common
    * Error will specify version, example gi.require_version("GtkSource", "4"), if that version is not available for your distro
    * you will need downgrade your virt-manager with $ sudo rm -r /usr/share/virt-manager and install older version

    9. ImportError: cannot import name Vte
    $ aptitude install -f gir1.2-vte-2.90

    10. TypeError: Couldn't find foreign struct converter for 'cairo.Context'
    $ aptitude install -f python3-gi-cairo


EndOfHelp
}


function cloning() {
    if [ $# -lt 6 ]; then
        echo '[-] You must provide <VM_NAME> <path_to_hdd> <start_from_number> <#vm_to_create> <path_where_to_store> <network_base> <full/linked hdd>'
        exit 1
    fi

    which virt-manager
    if [ $? -eq 1 ]; then
        echo "You need to install virt-manager. Run sudo $0 virtmanager"
        exit 1
    fi

    virsh net-list --all|grep hostonly
    if [ $? -eq 1 ]; then
        cat > /tmp/hostonly.xml << EOF
<network xmlns:dnsmasq='http://libvirt.org/schemas/network/dnsmasq/1.0'>
  <name>hostonly</name>
  <uuid>9385b182-075b-429e-a089-4b05374e87c2</uuid>
  <bridge name='virbr1' stp='on' delay='0'/>
  <mac address='12:22:34:44:56:66'/>
  <domain name='hostonly'/>
  <dns>
    <forwarder addr='${DNS_PRIMARY}'/>
    <forwarder addr='${DNS_SECONDARY}'/>
  </dns>
  <ip address='${VM_NETWORK_RANGE}.1' netmask='255.255.255.0'>
    <dhcp>
      <range start='${VM_NETWORK_RANGE}.2' end='${VM_NETWORK_RANGE}.254'/>
    </dhcp>
  </ip>
  <route address='0.0.0.0' prefix='24' gateway='${VM_NETWORK_RANGE}.1'/>
  <dnsmasq:options>
    <!--set netbios-over-TCP/IP nameserver(s) aka WINS server(s)-->
    <dnsmasq:option value='dhcp-option=44,0.0.0.0'/>
    <!--netbios datagram distribution server-->
    <dnsmasq:option value='dhcp-option=45,0.0.0.0'/>
    <!--netbios node type-->
    <dnsmasq:option value='dhcp-option=46,8'/>
    <!--Send an empty WPAD option. This may be REQUIRED to get windows 7 to behave.-->
    <dnsmasq:option value='dhcp-option=252,"\n"'/>
  </dnsmasq:options>
</network>
EOF

    virsh net-define /tmp/hostonly.xml
    virsh net-autostart hostonly
    virsh net-start hostonly
    fi
    for i in $(seq "$3" "$4"); do
        worked=1
        # bad macaddress can be generated
        while [ $worked -eq 1 ]; do
            macaddr=$(hexdump -n 6 -ve '1/1 "%.2x "' /dev/random | awk -v a="2,6,a,e" -v r="$RANDOM" 'BEGIN{srand(r);}NR==1{split(a,b,",");r=int(rand()*4+1);printf "%s%s:%s:%s:%s:%s:%s\n",substr($1,0,1),b[r],$2,$3,$4,$5,$6}') 2>/dev/null
            if virt-clone --print-xml -n "$1_$i" -o "$1" -m "$macaddr" -f "${5}/${1}_${i}.qcow2" |sed "s|<driver name=\"qemu\" type=\"qcow2\" cache=\"none\" io=\"native\"/>|<driver name=\"qemu\" type=\"qcow2\" cache=\"none\" discard=\"unmap\" detect_zeroes=\"on\" io=\"native\"/>|g" > "$5/$1_$i.xml"; then
                if [ ! -f "${5}/${1}_${i}.qcow2" ]; then
                    echo "Creating $5/$1_$i.qcow2"
                    if [ "$7" == "linked" ]; then
                        qemu-img create -f qcow2 -F qcow2 -b "$2" "$5/$1_$i.qcow2"
                    else
                        # full clone
                        cp "$2" "$5/$1_$i.qcow2"
                    fi
                fi
                #2>/dev/null
                virsh net-update hostonly add-last ip-dhcp-host "<host mac='${macaddr}' name='${1}_${i}' ip='${VM_NETWORK_RANGE}.${i}'/>" --live --config
                sed -i "s|<domain type='kvm'>|<domain type='kvm' xmlns:qemu='http://libvirt.org/schemas/domain/qemu/1.0'>|g" "$5/$1_$i.xml"
                virsh define "$5/$1_$i.xml"
                worked=0
            fi
        done
        echo "<host mac='$macaddr' name='$1_$i' ip='$6.$((i+1))'/>"
    done

    echo "[+] Enjoy"
}

# Doesn't work ${$1,,}
COMMAND=$(echo "$1"|tr "[:upper:]" "[:lower:]")

case $COMMAND in
    '-h')
        usage
        exit 0;;
    'issues')
        issues
        exit 0;;
esac

#if ([ "$COMMAND" = "all" ] || [ "$COMMAND" = "libvirt" ]) && [ $# -eq 2 ]; then
#    if [ id -u "$2" ]; then
#        username="$2"
#    else
#        echo "[-] username $2 doesn't exist"
#        exit 1
#    fi
#fi

#check if start with root
if [ "$EUID" -ne 0 ]; then
   echo 'This script must be run as root'
   exit 1
fi

OS="$(uname -s)"
MAINTAINER="$(whoami)"_"$(hostname)"
ARCH="$(dpkg --print-architecture)"
#add-apt-repository universe
#apt update && apt upgrade
#make

case "$COMMAND" in
'issues')
    issues;;
'all')
    aptitude install -f language-pack-UTF-8 -y
    install_qemu
    install_seabios
    install_kvm_linux
    # add check if server or desktop
    # install_virt_manager
    # install_libguestfs
    # check if all features enabled
    virt-host-validate qemu
    systemctl daemon-reload
    systemctl restart libvirtd libvirt-guests.service
    _enable_tcp_bbr
    grub_iommu
    enable_sysrq
    ;;
'apparmor')
    install_apparmor;;
'qemu')
    install_qemu;;
'seabios')
    install_seabios;;
'kvm')
    install_kvm_linux;;
'libguestfs')
    install_libguestfs;;
'tcp_bbr')
    _enable_tcp_bbr;;
'replace_qemu')
    if declare -f -F "replace_qemu_clues"; then
        replace_qemu_clues
    else
        replace_qemu_clues_public
    fi
    ;;
'sysrq')
    enable_sysrq;;
'libvirt')
    install_libvirt;;
'libvmi')
    install_libvmi;;
'virtmanager')
    install_virt_manager;;
'clone')
    cloning "$2" "$3" "$4" "$5" "$6" "$7" "$8";;
'noip')
    if [ "$OS" = "Linux" ]; then
        cd /tmp || return
        if [ ! -f noip-duc-linux.tar.gz ]; then
            wget -q http://www.no-ip.com/client/linux/noip-duc-linux.tar.gz
        fi
        tar xf noip-duc-linux.tar.gz
        rm noip-duc-linux.tar.gz
        cd "noip-*" || return
        make install
        crontab -l | { cat; echo "@reboot sleep 10 && /usr/local/bin/noip2 -c /usr/local/etc/no-ip2.conf"; } | crontab -
    fi
    ;;
'replace_seabios')
    if [ ! -d "$2" ]; then
        echo "[-] Pass the path to SeaBios folder"
        exit 1
    fi
    cd "$2" || exit 1
    if declare -f -F "replace_seabios_clues"; then
        replace_seabios_clues
    else
        replace_seabios_clues_public
    fi
    ;;
'grub')
    grub_iommu;;
'mosh')
    if [ "$OS" = "Linux" ]; then
        sudo aptitude install -f mosh -y
    else
        echo "https://mosh.org/#getting"
    fi
    ;;
*)
    usage;;
esac

```

`Virtualization/libguestfs.sh`:

```sh
# Dead code - keeping just in case a copy
# use docker or another VM for sparsify VMs
function install_libguestfs() {
    # https://libguestfs.org/guestfs-building.1.html
    cd /opt || return
    echo "[+] Check for previous version of LibGuestFS"
    sudo dpkg --purge --force-all "libguestfs-*" 2>/dev/null

    # deprecated
    wget -O- https://packages.erlang-solutions.com/ubuntu/erlang_solutions.asc | sudo apt-key add -
    sudo add-apt-repository -y "deb https://packages.erlang-solutions.com/ubuntu $(lsb_release -sc) contrib"
    sudo aptitude install -f default-jdk parted libyara3 erlang-dev gperf flex bison libaugeas-dev libhivex-dev supermin ocaml-nox libhivex-ocaml genisoimage libhivex-ocaml-dev libmagic-dev libjansson-dev gnulib jq ocaml-findlib opam -y 2>/dev/null
    sudo apt update
    sudo aptitude install -f erlang -y

    if [ ! -d libguestfs ]; then
        # ToDo move to latest release not latest code
        #_info=$(curl -H "Accept: application/vnd.github+json" -s https://api.github.com/repos/libguestfs/libguestfs/tags)
        #_version=$(echo $_info |jq .[0].name|sed "s/\"//g")
        #_repo_url=$(echo $_info |jq ".[0].zipball_url" | sed "s/\"//g")
        #wget -q $_repo_url
        #unzip $_version
        git clone --recursive https://github.com/libguestfs/libguestfs
    fi


    HIVEX_VERSION=1.3.23
    # install hivex
    wget https://github.com/libguestfs/hivex/archive/refs/tags/v${HIVEX_VERSION}.zip
    unzip v${HIVEX_VERSION}
    cd hivex-${HIVEX_VERSION}
    autoreconf -i
    ./generator/generator.ml
    ./configure
    make -j"$(nproc)"
    # make check
    cd .. || return

    cd libguestfs || return
    # cd $(ls | grep "libguestfs-libguestfs*") || return
    git submodule update --init
    autoreconf -i
    eval $(opam env)
    opam init
    opam install augeas -y
    eval $(opam env)
    OCAMLPATH=$HOME/.opam/default/lib/ocaml::/usr/lib/ocaml ./configure CFLAGS=-fPIC --disable-ocaml --disable-perl --disable-python --disable-ruby --disable-haskell --disable-php --disable-erlang --disable-lua --disable-golang --disable-gobject
    OCAMLPATH=$HOME/.opam/default/lib/ocaml::/usr/lib/ocaml:/opt/hivex-{HIVEX_VERSION} make clean -j"$(nproc)"

    # Install virt tools that are in a diff repo since LIBGUESTFS 1.46 split
    # More Info: https://listman.redhat.com/archives/libguestfs/2021-September/msg00153.html
    cd /opt || return
    if [ ! -d guestfs-tools ]; then
      git clone --recursive https://github.com/rwmjones/guestfs-tools.git
    fi
    cd guestfs-tools || return
    # Following tips to compile the guestfs-tools as depicted in https://www.mail-archive.com/libguestfs@redhat.com/msg22408.html
    git config --global --add safe.directory /opt/guestfs-tools
    git submodule update --init --force
    autoreconf -i
    ../libguestfs/run ./configure CFLAGS=-fPIC
    ../libguestfs/run make -j"$(nproc)"

    echo "[+] /opt/libguestfs/run --help"
    echo "[+] /opt/libguestfs/run /opt/guestfs-tools/sparsify/virt-sparsify -h"
}

```

`Virtualization/libguestfs/Dockerfile`:

```
# Based on https://anthony-f-tannous.medium.com/use-docker-and-libguestfs-tools-to-shrink-virtual-machine-disks-vmdks-cae0aae17da6
# https://lucascavalare.github.io/2020-03-15-AppArmor_Docker/

# DO NOT INSTALL Docker from SNAP, it will give problems with permissions on mounting folders, as readonly blablabla
# https://docs.docker.com/engine/install/ubuntu/

# sudo apt-get update
# sudo apt-get install ca-certificates curl
# sudo install -m 0755 -d /etc/apt/keyrings
# sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
# sudo chmod a+r /etc/apt/keyrings/docker.asc

# Add the repository to Apt sources:
# echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
# sudo apt-get update
# sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

# To enable internet
# echo 'DOCKER_OPTS="--dns 8.8.8.8 --dns 8.8.4.4"' >> /etc/default/docker
# sudo docker build --network=host  -t guest-fs-tools .

# Running
# sudo docker run -it --rm --privileged -v /opt/VMs:/mnt/vm-disks guest-fs-tools
# docker exec -it $(docker container ls  | grep 'guest-fs-tools' | awk '{print $1}') sudo /usr/bin/virt-sparsify path_to_vm path_to_out_vm --tmp /mnt/vm-disks
# Might need another volume mount which contains more space
# last command inside docker might require sudo

FROM ubuntu:22.04
RUN echo "deb http://us.archive.ubuntu.com/ubuntu/ jammy universe" >> /etc/apt/sources.list && \
 apt-get update && apt-get install -y --no-install-recommends libguestfs-tools  software-properties-common sudo apt-utils linux-image-generic
RUN useradd -ms /bin/bash -d /home/docker docker && usermod -aG sudo docker && echo "docker ALL=(ALL) NOPASSWD: ALL" >> /etc/sudoers
ENV HOME=/home/docker
USER docker


```

`Vol3/pony.py`:

```py
#!/usr/bin/env python
'''
Created on 23 Oct 2019
Updated on 02 Feb 2021 for Vol3 1.0.1

# Copyright (C) 2011-2021 DoomedRaven.
# This file is part of Tools - https://github.com/doomedraven/Tools
# See the file 'LICENSE.md' for copying permission.

This is demo plugin of volatility3 to show community how to easilly upgrade/make an vol3 plugin
Special huge thanks to @ikelos and @xabiugarte for help/fixes

https://github.com/doomedraven/Tools/Vol3/pony.py
'''
import os
import re
import io
import sys
import json

import logging
from typing import Any, List, Tuple, Dict, Optional, Union, Iterable
from urllib.request import pathname2url
import volatility3.plugins
import volatility3.symbols
from volatility3 import framework
from volatility3.framework import interfaces, renderers, exceptions
from volatility3.framework.configuration import requirements
from volatility3.framework.layers import resources
from volatility3.framework.renderers import format_hints
from volatility3.plugins import yarascan
from volatility3.plugins.windows import pslist, vadyarascan, vadinfo

log = logging.getLogger(__name__)

try:
    import yara
    has_yara=True
except ImportError:
    log.info("Python Yara module not found, plugin (and dependent plugins) not available")
    has_yara=False

def standalone_extractor(data):
    return Pony.get_config(data)

class Pony(interfaces.plugins.PluginInterface):
    """ Extracts Pony config """
    _version=(1, 0, 0)
    _required_framework_version = (2, 0, 0)

    @classmethod
    def get_requirements(cls) -> List[interfaces.configuration.RequirementInterface]:
        return [
            requirements.TranslationLayerRequirement(name='primary',
                                                     description="Memory layer for the kernel",
                                                     architectures=["Intel32", "Intel64"]),
            requirements.SymbolTableRequirement(name="nt_symbols", description="Windows kernel symbols"),
            requirements.IntRequirement(name="max_size",
                                        default=0x40000000,
                                        description="Set the maximum size (default is 1GB)",
                                        optional=True),
            requirements.VersionRequirement(name = 'pslist', component = pslist.PsList, version = (2, 0, 0)),
            requirements.IntRequirement(name='pid',
                                        description="Process ID to include (all other processes are excluded)",
                                        optional=True),
            requirements.URIRequirement(name="yara_file", description="Yara rules (as a file)", optional=True),
            requirements.PluginRequirement(name = 'vadyarascan', plugin = vadyarascan.VadYaraScan, version = (1, 0, 0)),
            requirements.VersionRequirement(name = 'vadinfo', component = vadinfo.VadInfo, version = (2, 0, 0)),
        ]

    @staticmethod
    def get_config(pe):
        # https://github.com/Xyl2k/Pony-gate-extractor/blob/master/PonyExtractor.py
        config = {
            "cncs": [],
            "downloads": [],
        }

        start = pe.find(b"YUIPWDFILE0YUIPKDFILE0YUICRYPTED0YUI1.0")
        if not start:
            return dict()

        pe = pe[start-600:start+500]
        gate_url = re.compile(b".*\.php$")
        exe_url = re.compile(b".*\.exe$")
        dll_url = re.compile(b".*\.dll$")
        output = re.findall(b"(https?:\/\/.[A-Za-z0-9-\.\_\~\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\\=]+(?:\.php|\.exe|\.dll))", pe)
        if not output:
            return config

        for url in output:
            try:
                if b'\x00' not in url:
                    if url is None:
                        continue
                    if gate_url.match(url):
                        config['cncs'].append(url.lower())
                    elif exe_url.match(url):
                        config['downloads'].append(url.lower())
                    elif dll_url.match(url):
                        config['downloads'].append(url.lower())
            except Exception as e:
                print(e)

        config["cncs"] = list(set(config["cncs"]))
        config["downloads"] = list(set(config["downloads"]))
        return config

    def _generator(self):
        if not has_yara:
            log.error("You must install yara")
            return

        config = dict()

        if self.config.get('yara_file', None) is not None:
            RULES = yara.compile(file=resources.ResourceAccessor().open(self.config['yara_file'], "rb"))
        else:
            # https://github.com/Yara-Rules/rules/blob/master/malware/MALW_Pony.yar
            SIGS = {
                'pony': '''

                    rule pony {
                        meta:
                            author = "Brian Wallace @botnet_hunter"
                            author_email = "bwall@ballastsecurity.net"
                            date = "2014-08-16"
                            description = "Identify Pony"
                        strings:
                            $ = "YUIPWDFILE0YUIPKDFILE0YUICRYPTED0YUI1.0"
                        condition:
                            all of them
                }
                '''
            }

            RULES = yara.compile(sources=SIGS)

        #filter_func = pslist.PsList.create_pid_filter([self.config.get('pid', None)])
        filter_func = pslist.PsList.create_pid_filter([self.config.get('pid', None)])

        for task in pslist.PsList.list_processes(
                context=self.context,
                layer_name=self.config['primary'],
                symbol_table=self.config['nt_symbols'],
                filter_func=filter_func):
            try:
                proc_layer_name = task.add_process_layer()
            except exceptions.InvalidAddressException:
                continue

            proc_layer = self.context.layers[proc_layer_name]

            for offset, rule_name, name, value in proc_layer.scan(
                    context=self.context,
                    scanner=yarascan.YaraScanner(rules=RULES),
                    sections=vadyarascan.VadYaraScan.get_vad_maps(task)):
                log.debug("Got a Yara match!")

                vad, vad_start, vad_end = self.get_vad(task, offset)
                if vad is None:
                    log.debug("VAD not found")
                    return

                full_pe = io.BytesIO()
                chunk_size = 1024 * 1024 * 10
                #vadinfo.VadInfo.vad_dump(self.context, task, vad, full_pe)
                offset = vad_start
                while offset < vad_end:
                    to_read = min(chunk_size, vad_end - offset)
                    data = proc_layer.read(offset, to_read, pad = True)
                    if not data:
                        break
                    full_pe.write(data)
                    offset += to_read
                if not full_pe:
                    continue
                config = self.get_config(full_pe.getvalue())
                if not config:
                    log.debug("Config extraction failed")
                    continue

                yield (0, (format_hints.Hex(offset), task.UniqueProcessId, str(config)))

    #replace with list_vads and write correct filter func
    @staticmethod
    def get_vad(task: interfaces.objects.ObjectInterface, address: int):# vad
        """Creates a map of start/end addresses within a virtual address
        descriptor tree.
        Args:
            task: The EPROCESS object of which to traverse the vad tree
        Returns:
            An iterable of tuples containing start and end addresses for each descriptor
        """
        vad_root = task.get_vad_root()
        for vad in vad_root.traverse():
            end = vad.get_end()
            start = vad.get_start()
            if end > address >= start:
                return vad, start, end
        return None, None, None

    def run(self):
        return renderers.TreeGrid([('Offset', format_hints.Hex), ('PID', int), ('Config', str)], self._generator())

if __name__ == '__main__':
    with open(sys.argv[1], 'rb') as f:
        data = f.read()
    config = standalone_extractor(data)
    print(json.dumps(config, indent=4))

```

`Vol3/zbotscan.py`:

```py
# Volatility
#
# Zeus support:
# Michael Hale Ligh <michael.ligh@mnin.org>
#
# Citadel 1.3.4.5 support:
# Santiago Vicente <smvicente@invisson.com>
#
# Generic detection, Citadel 1.3.5.1 and ICE IX support:
# Juan C. Montes <jcmontes@cert.inteco.es>
#
# Port to volatility3 by @doomedraven
# https://github.com/doomedraven
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

import re
import io
import sys
import time
import logging
import binascii
import struct
import hashlib

# VOLATILITY IMPORTS
from typing import Iterable, List, Tuple
from volatility3.framework.objects import utility
from volatility3.framework import interfaces, renderers, exceptions, constants
from volatility3.framework.configuration import requirements
from volatility3.framework.layers import resources
from volatility3.framework.symbols import intermed
from volatility3.framework.renderers import format_hints
from volatility3.plugins import yarascan
from volatility3.plugins.windows import pslist, vadyarascan  # , procdump, dlllist
from volatility3.plugins.windows.vadinfo import VadInfo, winnt_protections


try:
    import pefile
except ImportError:
    print("Missed pefile library -> pip3 install pefile")

try:
    import yara
    has_yara = True
except ImportError:
    has_yara = False

log = logging.getLogger(__name__)

# CONSTANTS
RC4_KEYSIZE = 0x102

ZEUS_STURCTURE = {
    "_ZEUS2_CONFIG": 0x1E6,
    "_CITADEL1345_CONFIG": 0x11C,
    "_CITADEL1351_CONFIG": 0x130,
}

ZEUS_STURCTURE_size = {
    0x1E6: "_ZEUS2_CONFIG",
    0x11C: "_CITADEL1345_CONFIG",
    0x130: "_CITADEL1351_CONFIG",
}

def _parsed_struct_read_str(data, start, length):
    return data[start: start+length].split(b"\x00")[0].decode("utf-8")

def parsed_struct(decoded_config, decoded_magic, zbotversion):
    # https://en.wikipedia.org/wiki/C_data_types
    parsed = dict()
    if zbotversion == "_ZEUS2_CONFIG":
        """
            "struct_size": [0x0, ["unsigned int"]],
            "guid": [0x4, ["array", 0x30, ["unsigned short"]]],
            "guid2": [0x7C, ["array", 0x10, ["unsigned char"]]],
            "rc4key": [0x8C, ["array", 0x100, ["unsigned char"]]],
            "exefile": [0x18E, ["String", dict(length=0x14)]],
            "datfile": [0x1A2, ["String", dict(length=0x14)]],
            "keyname": [0x1B6, ["String", dict(length=0xA)]],
            "value1": [0x1C0, ["String", dict(length=0xA)]],
            "value2": [0x1CA, ["String", dict(length=0xA)]],
            "value3": [0x1D4, ["String", dict(length=0xA)]],
            "guid_xor_key": [0x1DE, ["unsigned int"]],
            "xorkey": [0x1E2, ["unsigned int"]],
        """
        parsed = {
            "struct_size": struct.unpack("=I", decoded_magic[:4])[0],
            "guid": decoded_magic[4:0x40].decode("utf-16le").split("\x00")[0],
            "guid2": decoded_magic[0x7c:0x7c+0x10],
            "rc4key": decoded_magic[0x8C: 0x8C+0x100],
            "exefile": _parsed_struct_read_str(decoded_magic, 0x18E, 0x14),
            "datfile": _parsed_struct_read_str(decoded_magic, 0x1A2, 0x14),
            "keyname": _parsed_struct_read_str(decoded_magic, 0x1B6, 0xa),
            "value1": _parsed_struct_read_str(decoded_magic, 0x1C0, 0xa),
            "value2": _parsed_struct_read_str(decoded_magic, 0x1CA, 0xa),
            "value3": _parsed_struct_read_str(decoded_magic, 0x1D4, 0xa),
            "guid_xor_key": struct.unpack("=I", decoded_magic[0x1de:0x1de+4])[0],
            "xorkey": struct.unpack("=I", decoded_magic[0x1e2:0x1e2+4])[0],
        }

    elif zbotversion in ("_CITADEL1345_CONFIG", "_CITADEL1351_CONFIG"):
        """
            "struct_size": [0x0, ["unsigned int"]],
            "guid": [0x4, ["array", 0x30, ["unsigned short"]]],
            "guid2": [0x7C, ["array", 0x10, ["unsigned char"]]],
            "exefile": [0x9C, ["String", dict(length=0x14)]],
            "datfile": [0xB0, ["String", dict(length=0x14)]],
            "keyname": [0xEC, ["String", dict(length=0xA)]],
            "value1": [0xF6, ["String", dict(length=0xA)]],
            "value2": [0x100, ["String", dict(length=0xA)]],
            "value3": [0x10A, ["String", dict(length=0xA)]],
            "guid_xor_key": [0x114, ["unsigned int"]],
            "xorkey": [0x118, ["unsigned int"]],

            _CITADEL1351_CONFIG has 4 extra fields
                "value4": [0x11C, ["unsigned int"]],
                "value5": [0x120, ["unsigned int"]],
                "value6": [0x124, ["unsigned int"]],
                "value7": [0x128, ["unsigned int"]],
                "value8": [0x12C, ["unsigned int"]],
        """
        parsed = {
            "struct_size": struct.unpack("=I", decoded_magic[:4])[0],
            "guid": decoded_magic[4:0x40].decode("utf-16le").split("\x00")[0],
            "guid2": decoded_magic[0x7c:0x7c+0x10],
            "exefile": _parsed_struct_read_str(decoded_magic, 0x9c, 0x14),
            "datfile": _parsed_struct_read_str(decoded_magic, 0xb0, 0x14),
            "keyname": _parsed_struct_read_str(decoded_magic, 0xec, 0xa),
            "value1": _parsed_struct_read_str(decoded_magic, 0xF6, 0xa),
            "value2": _parsed_struct_read_str(decoded_magic, 0x100, 0xa),
            "value3": _parsed_struct_read_str(decoded_magic, 0x10A, 0xa),
            "guid_xor_key": struct.unpack("=I", decoded_magic[0x114:0x114+4])[0],
            "xorkey": struct.unpack("=I", decoded_magic[0x118:0x118+4])[0],
        }

        if zbotversion == "_CITADEL1351_CONFIG":
            parsed.update({
                "value4": struct.unpack("=I", decoded_magic[0x11c:0x11c+4])[0],
                "value5": struct.unpack("=I", decoded_magic[0x120:0x120+4])[0],
                "value6": struct.unpack("=I", decoded_magic[0x124:0x124+4])[0],
                "value7": struct.unpack("=I", decoded_magic[0x128:0x128+4])[0],
                "value8": struct.unpack("=I", decoded_magic[0x12c:0x12c+4])[0],
            })


    return parsed

class ZBOTScan(interfaces.plugins.PluginInterface):
    _version = (1, 0, 0)
    _required_framework_version = (2, 0, 0)

    """ Locate and Decrypt Configs for: ZeuS v2, Citadel
           * ZeuS 2.0.8.9 (z4 & z5)
           * ZeuS 2.1.0.1 (z3 & z5)
           * Ice IX (ZeuS 2.1.0.1 + mod RC4)
            Citadel 1.3.4.5
           * Citadel 1.3.5.1
    """

    # Internal vars
    signatures = {
        # ZeuS v2
        'namespace01':'rule zeus2_1 {strings: $a = {56 BA ?? ?? 00 00 52 68 ?? ?? ?? ?? 50 E8 ?? ?? ?? ?? 8B 35 ?? ?? ?? ?? 8B 0D ?? ?? ?? ??} condition: $a}',
        'namespace02':'rule zeus2_2 {strings: $a = {55 8B EC 51 A1 ?? ?? ?? ?? 8B 0D ?? ?? ?? ?? 56 8D 34 01 A1 ?? ?? ?? ?? 8B 0D ?? ?? ?? ??} condition: $a}',
        'namespace03':'rule zeus2_3 {strings: $a = {68 02 01 00 00 8D 84 24 ?? ?? ?? ?? 50 8D 44 24 ?? 50 E8 ?? ?? ?? ?? B8 E6 01 00 00 50 68 ?? ?? ?? ??} condition: $a}',
        'namespace04':'rule zeus2_4 {strings: $a = {68 02 01 00 00 8D 85 ?? ?? ?? ?? 50 8D 85 ?? ?? ?? ?? 50 E8 ?? ?? ?? ?? B8 E6 01 00 00 50 68 ?? ?? ?? ??} condition: $a}',
        'namespace05':'rule zeus2_5 {strings: $a = {56 BA ?? ?? 00 00 52 68 ?? ?? ?? ?? 50 E8 ?? ?? ?? ?? 8B 0D ?? ?? ?? ?? 03 0D ?? ?? ?? ??} condition: $a}',
        # Citadel
        'namespace06':'rule citadel_1 {strings: $a = {8B EC 83 EC 0C 8A 82 ?? ?? ?? ?? 88 45 FE 8A 82 01 01 00 00 88 45 FD 8A 82 02 01 00 00 B9 ?? ?? ?? ?? 88 45 FF E8 ?? ?? ?? ??} condition: $a}',
        'namespace07':'rule citadel_2 {strings: $a = {56 BA ?? ?? 00 00 52 68 ?? ?? ?? ?? 50 E8 ?? ?? ?? ?? 8B 0D ?? ?? ?? ?? 03 0D ?? ?? ?? ?? 8B F2 2B C8} condition: $a}',
        'namespace08':'rule citadel_3 {strings: $a = {68 ?? ?? 00 00 8D 85 ?? ?? ?? ?? 50 8D 85 ?? ?? ?? ?? 50 E8 ?? ?? ?? ?? B8 ?? ?? 00 00 50 68 ?? ?? ?? ??} condition: $a}',
    }

    zbot = ""

    @classmethod
    def get_requirements(cls) -> List[interfaces.configuration.RequirementInterface]:
        return [
            requirements.TranslationLayerRequirement(
                name="primary", description="Memory layer for the kernel", architectures=["Intel32", "Intel64"]
            ),
            requirements.SymbolTableRequirement(name="nt_symbols", description="Windows kernel symbols"),
            requirements.IntRequirement(
                name="max_size", default=0x40000000, description="Set the maximum size (default is 1GB)", optional=True
            ),
            requirements.PluginRequirement(name="pslist", plugin=pslist.PsList, version=(2, 0, 1)),
            requirements.IntRequirement(
                name="pid", description="Process ID to include (all other processes are excluded)", optional=True
            ),
            requirements.URIRequirement(name="yara_file", description="Yara rules (as a file)", optional=True),
            requirements.PluginRequirement(name="vadyarascan", plugin=vadyarascan.VadYaraScan, version=(1, 0, 0)),
        ]

    @staticmethod
    def get_vad(task: interfaces.objects.ObjectInterface, address: int):  # vad
        """Creates a map of start/end addresses within a virtual address
        descriptor tree.
        Args:
            task: The EPROCESS object of which to traverse the vad tree
        Returns:
            An iterable of tuples containing start and end addresses for each descriptor
        """
        vad_root = task.get_vad_root()
        for vad in vad_root.traverse():
            end = vad.get_end()
            start = vad.get_start()

            # put a max size as 500mb
            if end - start > 0x500000:
                continue

            if start <= address < end:
                return vad, start, end
        return None, None, None

    @staticmethod
    def carve_data(vad_start, vad_end, proc_layer):
        chunk_size = 1024 * 1024 * 10
        full_vad = io.BytesIO()
        tmp_offset = vad_start
        while tmp_offset < vad_end:
            to_read = min(chunk_size, vad_end - tmp_offset)
            data = proc_layer.read(tmp_offset, to_read, pad=True)
            if not data:
                break
            full_vad.write(data)
            tmp_offset += to_read

        return full_vad.getvalue()

    def injection_filter(self, vad):
        """
        This is a callback that's executed by get_vads()
        when searching for injected code / hidden DLLs.
        This looks for private allocations that are committed,
        memory-resident, non-empty (not all zeros) and with an
        original protection that includes write and execute.
        It is important to note that protections are applied at
        the allocation granularity (page level). Thus the original
        protection might not be the current protection, and it
        also might not apply to all pages in the VAD range.
        @param vad: an MMVAD object.
        @returns: True if the MMVAD looks like it might
        contain injected code.
        """

        protect = vad.get_protection(VadInfo.protect_values(self.context, self.config['primary'], self.config['nt_symbols']), winnt_protections)
        write_exec = "EXECUTE" in protect and "WRITE" in protect

        # The Write/Execute check applies to everything
        if not write_exec:
            return False

        # This is a typical VirtualAlloc'd injection
        try:
            if vad.get_private_memory() == 1 and vad.vad.get_tag() == "VadS":
                return True
        except Exception as e:
            print(e)
        # This is a stuxnet-style injection
        if vad.get_private_memory() == 0 and protect != "PAGE_EXECUTE_WRITECOPY":  # noqa: W504
            return True

        return False

    def check_zbot(self):
        """ Detect the zbot version """

        rules = yara.compile(sources=self.signatures)

        p_round = self.context.config.get("sandbox_round", 1)
        if self.context.config.get('sandbox_pids', None):
            pids = self.context.config.get("sandbox_pids")
        else:
            pids = [self.config.get('pid', None)]

        filter_func = pslist.PsList.create_pid_filter(pids, True if p_round == 2 else False)
        list_tasks = pslist.PsList.list_processes(
            context=self.context,
            layer_name=self.config["primary"],
            symbol_table=self.config["nt_symbols"],
            filter_func = filter_func,
        )

        for task in list_tasks:
            try:
                proc_layer_name = task.add_process_layer()
            except exceptions.InvalidAddressException:
                continue

            proc_layer = self.context.layers[proc_layer_name]

            for vad_start, vad_len in vadyarascan.VadYaraScan.get_vad_maps(task):
                vad, vad_start, vad_end = self.get_vad(task, vad_start)
                if not vad_start or not vad_end:
                    continue

                if vad_end - vad_start == 0xFFFF or vad_end - vad_start >= 1000000000:
                    continue

                data = self.carve_data(vad_start, vad_end, proc_layer)
                if not data.startswith(b"MZ") and not self.injection_filter(vad):
                    continue

                # check for the signature with YARA, both hits must be present
                matches = rules.match(data=data)
                if not matches:
                    continue


                hits = dict((m.rule, m.strings[0][0]) for m in matches)
                log.debug("yara rules")
                log.debug(hits)

                # Rules for CITADEL
                if ('citadel_1' in hits) & ('citadel_2' in hits) & ('citadel_3' in hits):
                    self.zbot = 'CITADEL'
                    log.debug('CITADEL DETECTED')
                    return task

                # Rules for ZEUS2
                if ( (('zeus2_1' in hits) | ('zeus2_2' in hits) | ('zeus2_5' in hits)) &
                        (('zeus2_3' in hits) | ('zeus2_4' in hits)) ):
                    self.zbot = 'ZEUS'
                    log.debug('ZEUS v2 DETECTED')
                    return task

    def run(self):
        return renderers.TreeGrid([("PID", int), ("Config", str)], self._generator())

    def _generator(self):
        """ Check the zbot version and analyze it """

        task = self.check_zbot()
        malware = None

        if self.zbot == 'CITADEL':
            malware = Citadel(self.config, self.context)
        elif self.zbot == 'ZEUS':
            malware = ZeuS2(self.config, self.context)
        elif malware.zbot == 'ICEIX':
            malware = ICEIX(self.config, self.context)

        if malware:
            config = malware.calculate(task)
            # malware.render_text(sys.stdout, data)
            yield (0, (task.UniqueProcessId, str(config)))


class ZbotCommon():
    """ Common functions for all zbot versions """

    params = dict(
        # This contains the C2 URL, RC4 key for decoding
        # local.ds and the magic buffer
        decoded_config = None,
        # This contains the hardware lock info, the user.ds
        # RC4 key, and XOR key
        encoded_magic = None,
        # The decoded version of the magic structure
        decoded_magic = None,
        # The key for decoding the configuration
        config_key = None,
        # The login key (citadel only)
        login_key = None,
        # The AES key (citadel only)
        aes_key = None,

        )

    # Depricated
    def get_hex(self, buf):
        return "\n".join(["{0:#010x}  {1:<48}  {2}".format(o, h, ''.join(c)) for o, h, c in utils.Hexdump(buf)])

    def decode_config(self, encoded_config, last_sec_data):
        """Decode the config with data from the last PE section.

        @param encoded_config: the encoded configuration
        @param last_sec_data: last PE section data.
        """

        return bytes([(last_sec_data[i] ^ encoded_config[i]) for i in range(len(encoded_config))])


    def decode_magic(self, config_key):
        """Decode the magic structure using the configuration key.

        @param config_key: the config RC4 key.
        """

        return self.rc4(config_key, self.params['encoded_magic'])

    def rc4(self, key, encoded, login_key=0):
        """Perform a basic RC4 operation"""
        # Turn the buffers into lists so the elements are mutable
        key_copy = [c for c in key]
        enc_copy = [c for c in encoded]

        # Start with the last two bytes in the key
        var1 = key_copy[0x100]
        var2 = key_copy[0x101]
        var3 = 0
        # ICE IX MOD
        mod1 = 0
        mod2 = 0
        if self.zbot == "ICEIX":
            mod1 = 3
            mod2 = 7

        # Do the RC4 algorithm
        for i in range(0, len(enc_copy)):
            var1 += 1 + mod1
            a = var1 & 0xFF
            b = key_copy[a]
            var2 += b
            var2 &= 0xFF
            key_copy[a] = key_copy[var2]
            key_copy[var2] = b
            enc_copy[i] ^= key_copy[(key_copy[a] + b + mod2) & 0xFF]

            # CITADEL MOD
            if self.zbot == "CITADEL":
                if not login_key:
                    login_key = self.params["login_key"]
                enc_copy[i] ^= login_key[var3]
                var3 += 1
                if var3 == len(login_key):
                    var3 = 0

        # Return the decoded bytes as a string
        decoded = [c for c in enc_copy]
        return bytes(decoded)

    def get_only_hex(self, buf, start=0, length=16):
        """Hexdump formula seen at http://code.activestate.com/recipes/142812-hex-dumper"""
        result = ""
        for i in range(0, len(buf), length):
            s = buf[i : i + length]
            result = result + "".join(["%02x" % x for x in s])
        return result

    def rc4_init(self, data):
        """Initialize the RC4 keystate"""
        # The key starts off as a mutable list
        key = list()
        for i in range(0, 256):
            key.append(i)
        # Add the trailing two bytes
        key.append(0)
        key.append(0)
        # Make a copy of the data so its mutable also
        data_copy = [ord(c) for c in data]
        var1 = 0
        var2 = 0
        for i in range(0, 256):
            a = key[i]
            var2 += data_copy[var1] + a
            var2 &= 0xFF
            var1 += 1
            key[i] = key[var2]
            key[var2] = a
        # Return a copy of the key as a string
        return "".join([chr(c) for c in key])


class ZeuS2(ZbotCommon):
    """ Scanner for ZeuS v2 """

    def __init__(self, config, context):
        self.zbot = "ZEUS"
        self.zbotversion = ""
        self.config = config
        self.context = context

        self.signatures = {
            "namespace1": r"rule z1 {strings: $a = {56 BA ?? ?? 00 00 52 68 ?? ?? ?? ?? 50 E8 ?? ?? ?? ?? 8B 35 ?? ?? ?? ?? 8B 0D ?? ?? ?? ??} condition: $a}",
            "namespace5": r"rule z5 {strings: $a = {56 BA ?? ?? 00 00 52 68 ?? ?? ?? ?? 50 E8 ?? ?? ?? ?? 8B 0D ?? ?? ?? ?? 03 0D ?? ?? ?? ??} condition: $a}",
            "namespace2": r"rule z2 {strings: $a = {55 8B EC 51 A1 ?? ?? ?? ?? 8B 0D ?? ?? ?? ?? 56 8D 34 01 A1 ?? ?? ?? ?? 8B 0D ?? ?? ?? ??} condition: $a}",
            "namespace3": r"rule z3 {strings: $a = {68 02 01 00 00 8D 84 24 ?? ?? ?? ?? 50 8D 44 24 ?? 50 E8 ?? ?? ?? ?? B8 E6 01 00 00 50 68 ?? ?? ?? ??} condition: $a}",
            "namespace4": r"rule z4 {strings: $a = {68 02 01 00 00 8D 85 ?? ?? ?? ?? 50 8D 85 ?? ?? ?? ?? 50 E8 ?? ?? ?? ?? B8 E6 01 00 00 50 68 ?? ?? ?? ??} condition: $a}",
        }

        self.magic_struct = "_ZEUS2_CONFIG"
        self.magic_struct_size = ZEUS_STURCTURE[self.magic_struct]

    def check_matches_zeus2(self, proc_layer, vad_start, matches, last_sec_data):
        """Check the Yara matches and derive the encoded/decoded
        config objects and magic structures.

        @param task_space: the process AS
        @param vad: the containing MMVAD
        @param matches: list of YARA hits
        @param last_sec_data: buffer of the last PE section's data
        """

        hits = dict((m.rule, m.strings[0][0] + vad_start) for m in matches)
        # Check version
        if ("z3" in hits) & ("z5" in hits):
            self.zbotversion = " 2.1.0.1"
        elif ("z4" in hits) & ("z5" in hits):
            self.zbotversion = " 2.0.8.9"

        if "z3" in hits:
            addr = struct.unpack("=I", proc_layer.read(hits["z3"] + 30, 0x4))[0]
            self.params["encoded_magic"] = proc_layer.read(addr, self.magic_struct_size)
        elif "z4" in hits:
            addr = struct.unpack("=I", proc_layer.read(hits["z4"] + 31, 0x4))[0]
            self.params["encoded_magic"] = proc_layer.read(addr, self.magic_struct_size)
        else:
            return False

        if "z1" in hits:
            addr = struct.unpack("=I", proc_layer.read(hits["z1"] + 8, 0x4))[0]
            size = struct.unpack("=I", proc_layer.read(hits["z1"] + 2, 0x4))[0]
            encoded_config = proc_layer.read(addr, size)
            self.params["decoded_config"] = self.decode_config(encoded_config, last_sec_data)
        elif "z2" in hits:
            addr = struct.unpack("=I", proc_layer.read(hits["z2"] + 26, 0x4))[0]
            encoded_config = proc_layer.read(addr, 0x3C8)
            rc4_init = self.rc4_init(encoded_config)
            self.params["decoded_config"] = self.rc4(rc4_init, last_sec_data[2:])
        elif "z5" in hits:
            addr = struct.unpack("=I", proc_layer.read(hits["z5"] + 8, 0x4))[0]
            size = struct.unpack("=I", proc_layer.read(hits["z5"] + 2, 0x4))[0]
            encoded_config = proc_layer.read(addr, size)
            self.params["decoded_config"] = self.decode_config(encoded_config, last_sec_data)
        else:
            return False

        # We found at least one of each category
        return True

    def scan_key_zeus2(self, task_space):
        """Find the offset of the RC4 key and use it to
        decode the magic buffer.

        @param task_space: the process AS
        """

        offset = 0
        found = False

        while offset < len(self.params["decoded_config"]) - RC4_KEYSIZE:
            config_key = self.params["decoded_config"][offset : offset + RC4_KEYSIZE]
            decoded_magic = self.decode_magic(config_key)

            # When the first four bytes of the decoded magic buffer
            # equal the size of the magic buffer, then we've found
            # a winning RC4 key
            (struct_size,) = struct.unpack("=I", decoded_magic[0:4])

            if self.magic_struct_size != struct_size & struct_size < 1500:
                log.debug("size error")
                log.debug(struct_size)
                log.debug(self.magic_struct_size)

            if struct_size == self.magic_struct_size:
                found = True
                self.params["config_key"] = config_key
                self.params["decoded_magic"] = decoded_magic
                break

            offset += 1

        return found

    def calculate(self, task):  # noqa: C901
        """ Analyze zbot process """
        rules = yara.compile(sources=self.signatures)
        config = dict()

        try:
            proc_layer_name = task.add_process_layer()
        except exceptions.InvalidAddressException:
            return

        proc_layer = self.context.layers[proc_layer_name]
        for vad_start, vad_len in vadyarascan.VadYaraScan.get_vad_maps(task):

            vad, vad_start, vad_end = ZBOTScan.get_vad(task, vad_start)
            # check for the signature with YARA, both hits must be present
            if not vad_start or not vad_end:
                log.debug("missed VAD details")
                continue

            if vad_end - vad_start == 0xFFFF or vad_end - vad_start >= 1000000000 :
                log.debug("VAD is too big")
                continue

            data = ZBOTScan.carve_data(vad_start, vad_end, proc_layer)
            # check for the signature with YARA, both hits must be present
            matches = rules.match(data=data)
            if not matches:
                continue

            if not data.startswith(b"MZ"):
                log.debug("NOT MZ")
                continue

            if len(matches) < 2:
                log.debug("don't have 2 matches")
                continue
            try:
                # There must be more than 2 sections
                pe = pefile.PE(data=data, fast_load=True)
                if len(pe.sections) < 2:
                    log.debug("less than 2 sections")
                    continue
            except Exception as e:
                print(e)
                continue

            # Get the last PE section's data
            last_sec = pe.sections[-1]
            last_sec_data = proc_layer.read((last_sec.VirtualAddress + vad_start), last_sec.Misc_VirtualSize)
            if len(last_sec_data) == 0:
                log.debug("empty section")
                continue

            # CITADEL
            if self.zbot == "CITADEL":
                success = self.check_matches_citadel(proc_layer, vad_start, matches, last_sec_data)
                if not success:
                    continue
                success = self.scan_key_citadel(proc_layer)
                if not success:
                    continue
            # ZEUS v2 or ICE IX
            elif self.zbot == "ZEUS":
                success = self.check_matches_zeus2(proc_layer, vad_start, matches, last_sec_data)
                if not success:
                    log.debug("check_matches_zeus2 false")
                    continue
                success = self.scan_key_zeus2(proc_layer)
                if not success:
                    # Check ICEIX
                    if self.zbotversion == " 2.1.0.1":
                        self.zbot = "ICEIX"
                        self.zbotversion = ""
                        log.debug("Checking ICE IX")
                        malware = ICEIX(self.config, self.context)
                        config = malware.calculate(task, vad_start, data, proc_layer)
                    else:
                        continue
                else:
                    # Parse zbotv2 here
                    parsed = parsed_struct(self.params["decoded_config"], self.params["decoded_magic"], self.magic_struct)
                    registry_dict = {
                        "key_path": "HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\%s" % "{0}".format(parsed["keyname"]),
                        # .v() Do the actual reading and decoding of this member
                        "Value1": "{0}".format(parsed["value1"]),
                        "Value2": "{0}".format(parsed["value2"]),
                        "Value3": "{0}".format(parsed["value3"]),
                    }

                    urls = []
                    conf_blob = self.params["decoded_config"]
                    while b"http" in conf_blob:
                        url = conf_blob[conf_blob.find(b"http") :]
                        urls.append(url[:url.find(b"\x00")].decode("utf-8"))
                        conf_blob = url[url.find(b"\x00") :]

                    config_rc4_key_hex = self.params["config_key"]
                    # quitamos el padding de volatility ..:76:a:d9:bf:0:0 -> 76:a:d9:bf
                    if config_rc4_key_hex[-2:] == b"\x00\x00":
                        config_rc4_key_hex = config_rc4_key_hex[:-2]

                    creds_key = self.params["decoded_magic"][0x8C : 0x8C + RC4_KEYSIZE]

                    config = {
                        "urls": urls,
                        "malware_zbot": "ZEUS",
                        "zbot_version": self.zbotversion,
                        "process_name": utility.array_to_string(task.ImageFileName),
                        "process_id": str(task.UniqueProcessId),
                        "process_address": str(vad_start),
                        "computer_identifier": parsed["guid"],
                        "mutant_key": str(parsed["guid_xor_key"]),
                        "xor_key": str(parsed["xorkey"]),
                        "registry": registry_dict,
                        "executable": parsed["exefile"],
                        "data_file": parsed["datfile"],
                        "creds_key": binascii.hexlify(creds_key).decode("utf-8"),
                        "config_rc4_keystream_plaintext": binascii.hexlify(config_rc4_key_hex).decode("utf-8"),
                    }

            return config

    def render_text(self, outfd, config):
        """Render the plugin's default text output"""

        # Check for data
        if config:
            # Get a magic object from the buffer
            outfd.write("*" * 50 + "\n")
            outfd.write("{0:<30} : {1}\n".format("ZBot", self.zbot + self.zbotversion))
            # outfd.write("{0:<30} : {1}\n".format("Process", utility.array_to_string(task.ImageFileName)))
            # outfd.write("{0:<30} : {1}\n".format("Pid", task.UniqueProcessId))
            # outfd.write("{0:<30} : {1}\n".format("Address", vad_start))

            for i, url in enumerate(config["urls"]):
                outfd.write("{0:<30} : {1}\n".format("URL {0}".format(i), url))

            outfd.write("{0:<30} : {1}\n".format("Identifier", config["guid"]))
            outfd.write("{0:<30} : {1}\n".format("Mutant key", config["guid_xor_key"]))
            outfd.write("{0:<30} : {1}\n".format("XOR key", config["xorkey"]))
            outfd.write(
                "{0:<30} : {1}\n".format(
                    "Registry",
                    "HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\{0}".format(config["keyname"]),
                )
            )
            outfd.write("{0:<30} : {1}\n".format(" Value 1", config["value1"]))
            outfd.write("{0:<30} : {1}\n".format(" Value 2", config["value2"]))
            outfd.write("{0:<30} : {1}\n".format(" Value 3", config["value3"]))
            outfd.write("{0:<30} : {1}\n".format("Executable", config["exefile"]))
            outfd.write("{0:<30} : {1}\n".format("Data file", config["datfile"]))
            """
            outfd.write(
                "{0:<30} : \n{1}\n".format(
                    "Config RC4 key",
                    "\n".join(
                        [
                            "{0:#010x}  {1:<48}  {2}".format(vad.Start + o, h, "".join(c))
                            for o, h, c in utils.Hexdump(params["config_key"])
                        ]
                    ),
                )
            )

            outfd.write(
                "{0:<30} : \n{1}\n".format(
                    "Credential RC4 key",
                    "\n".join(
                        ["{0:#010x}  {1:<48}  {2}".format(vad.Start + o, h, "".join(c)) for o, h, c in utils.Hexdump(config["creds_key"])]
                    ),
                )
            )
            """


class Citadel(ZbotCommon):
    """ Scanner for Citadel version """

    def __init__(self, config, context):
        self.zbot = "CITADEL"
        self.zbotversion = " 1.3.5.1"
        self.magic_struct = ""
        self.config = config
        self.context = context

        self.signatures = {
            "namespace1": r"rule z1 {strings: $a = {8B EC 83 EC 0C 8A 82 ?? ?? ?? ?? 88 45 FE 8A 82 01 01 00 00 88 45 FD 8A 82 02 01 00 00 B9 ?? ?? ?? ?? 88 45 FF E8 ?? ?? ?? ??} condition: $a}",
            "namespace2": r"rule z2 {strings: $a = {56 BA ?? ?? 00 00 52 68 ?? ?? ?? ?? 50 E8 ?? ?? ?? ?? 8B 0D ?? ?? ?? ?? 03 0D ?? ?? ?? ?? 8B F2 2B C8} condition: $a}",
            "namespace3": r"rule z3 {strings: $a = {68 ?? ?? 00 00 8D 85 ?? ?? ?? ?? 50 8D 85 ?? ?? ?? ?? 50 E8 ?? ?? ?? ?? B8 ?? ?? 00 00 50 68 ?? ?? ?? ??} condition: $a}",
            "namespace4": r"rule z4 {strings: $a = {68 ?? ?? 00 00 8D 84 24 ?? ?? ?? ?? 50 8D 44 24 ?? 50 E8 ?? ?? ?? ?? B8 ?? ?? 00 00 50 68 ?? ?? ?? ??} condition: $a}",
            "namespace5": r"rule z5 {strings: $a = {81 30 ?? ?? ?? ?? 0F B6 50 03 0F B6 78 02 81 70 04 ?? ?? ?? ?? 81 70 08 ?? ?? ?? ?? 81 70 0c ?? ?? ?? ?? C1 E2 08 0B D7} condition: $a}",
            "namespace6": r"rule z6 {strings: $a = {33 F6 C7 45 ?? ?? ?? ?? ?? 5B 8A 4C 3D ?? 8A D1 80 E2 07 C0 E9 03 47 83 FF 04} condition: $a}",
        }
        """
        botnet offset:
        EB 11                                   jmp     short loc_3C9FDBA
        8D 85 48 FA FF FF                       lea     eax, [ebp+var_5B8]
        E8 FD FD FF FF                          call    XorDecryptionIntoEAX ; No APIs
        8D 8D 64 FD FF FF                       lea     ecx, [ebp+var_29C]
        8B 55 08                                mov     edx, [ebp+arg_0]
        83 C8 FF                                or      eax, 0FFFFFFFFh
        E8 86 16 01 00                          call    CopyUnicodeStringECX2EDX ; No APIs
        """
        self.CITADEL_GET_BOTNET_PATTERNS = [
            re.compile(
                br".*\xeb.\x8d\x85(....)\xe8....\x8d\x8d(....)\x8b.\x08\x83\xc8\xff\xe8.*",
                re.DOTALL,
            )
        ]

    def rc4_init_cit(self, key, magicKey):  # noqa: C901
        """ Initialize the RC4 keystate """

        hash = []
        box = []
        keyLength = len(key)
        magicKeyLen = len(magicKey)

        for i in range(0, 256):
            hash.append(key[i % keyLength])
            box.append(i)

        y = 0
        for i in range(0, 256):
            y = (y + box[i] + hash[i]) % 256
            tmp = box[i]
            box[i] = box[y]
            box[y] = tmp

        y = 0
        for i in range(0, 256):
            magicKeyPart1 = magicKey[y] & 0x07
            magicKeyPart2 = magicKey[y] >> 0x03
            y += 1
            if y == magicKeyLen:
                y = 0

            if magicKeyPart1 == 0:
                box[i] = ~box[i]
            elif magicKeyPart1 == 1:
                box[i] ^= magicKeyPart2
            elif magicKeyPart1 == 2:
                box[i] += magicKeyPart2
            elif magicKeyPart1 == 3:
                box[i] -= magicKeyPart2
            elif magicKeyPart1 == 4:
                box[i] = box[i] >> (magicKeyPart2 % 8) | (box[i] << (8 - (magicKeyPart2 % 8)))
            elif magicKeyPart1 == 5:
                box[i] = box[i] << (magicKeyPart2 % 8) | (box[i] >> (8 - (magicKeyPart2 % 8)))
            elif magicKeyPart1 == 6:
                box[i] += 1
            elif magicKeyPart1 == 7:
                box[i] -= 1

            box[i] = box[i] & 0xFF

        return bytes([c for c in box])

    def get_urls(self, base_config, data):

        urls = []

        """
        8D 84 24 50 01 00 00                    lea     eax, [esp+668h+var_518]
        C6 44 24 12 00                          mov     [esp+668h+var_656], 0
        C6 44 24 13 01                          mov     [esp+668h+var_655], 1
        E8 2D 95 00 00                          call    XorDecryptionIntoEAX ; No APIs
        8B 9C 24 58 05 00 00                    mov     ebx, [esp+668h+var_110]
        8D 84 24 A8 03 00 00                    lea     eax, [esp+668h+var_2C0] ; url1
        89 44 24 38                             mov     [esp+668h+var_630], eax
        C1 EB 0C                                shr     ebx, 0Ch
        8D 84 24 8B 01 00 00                    lea     eax, [esp+668h+var_4DD] ; url2
        83 E3 01                                and     ebx, 1
        89 44 24 3C                             mov     [esp+668h+var_62C], eax
        8D 84 24 CD 05 00 00                    lea     eax, [esp+668h+var_9B] ; url3
        """
        URL_SEARCH_PATTERNS = [
            re.compile(
                br".*\x8d\x84\x24(....)\xc6\x44\x24.\x00\xc6\x44\x24.\x01\xe8....\x8b.\x24....\x8d.\x24(....).{2,10}\x8d\x84\x24(....).{2,10}\x8d\x84\x24(....).*",
                re.DOTALL,
            )
        ]

        for pattern in URL_SEARCH_PATTERNS:
            m = re.match(pattern, data)
            if m:
                base = struct.unpack("I", m.group(1))[0]
                for x in range(2, 5):
                    offset = struct.unpack("I", m.group(x))[0] - base
                    url = self.get_string_from_data(base_config, offset=offset)
                    log.debug("got url: %s" % url)
                    if url != "" and url not in urls:
                        urls.append(url.split("\x00")[0])

        # blunt tool way in case something broke
        while b"http" in base_config:
            url = base_config[base_config.find(b"http") :]
            url_trim = url[: url.find(b"\x00")].decode("utf-8")
            log.debug("found through dumb way: %s" % url_trim)
            if url_trim not in urls:
                urls.append(url_trim)
            base_config = url[url.find(b"\x00") :]

        return list(filter(None, urls))

    def get_string_from_data(self, data, offset=0, widechar=False):

        out = ""
        count = offset
        while count < len(data):
            char = data[count]
            if char == 0:
                break
            out += chr(char)
            if widechar:
                count += 2
            else:
                count += 1

        return out

    def search_botnet(self, base_config, data):

        botnet = ""
        for pattern in self.CITADEL_GET_BOTNET_PATTERNS:
            m = re.match(pattern, data)
            if m:
                offset = struct.unpack("I", m.group(2))[0] - struct.unpack("I", m.group(1))[0]
                log.debug("botnet offset: %x" % offset)
                botnet = ""
                count = 0
                while count < 20:  # BOTNET_MAX_CHARS - 20
                    char = base_config[offset + count]
                    if char == 0:
                        break
                    botnet += chr(char)
                    count += 2  # widechar
                log.debug("found botnet: %s" % botnet)

        return botnet

    def calculate(self, task):  # noqa: C901

        p = task
        rules = yara.compile(sources=self.signatures)

        try:
            proc_layer_name = task.add_process_layer()
        except exceptions.InvalidAddressException:
            return

        proc_layer = self.context.layers[proc_layer_name]

        for vad_start, vad_len in vadyarascan.VadYaraScan.get_vad_maps(task):

            vad, vad_start, vad_end = ZBOTScan.get_vad(task, vad_start)

            start = vad.StartingVpn << 12
            # check for the signature with YARA, both hits must be present
            if not vad_start or not vad_end:
                continue

            if vad_end - vad_start == 0xFFFF or vad_end - vad_start >= 1000000000 :
                continue

            data = ZBOTScan.carve_data(vad_start, vad_end, proc_layer)
            matches = rules.match(data=data)
            if not matches or len(matches) != 5:
                continue

            if not data.startswith(b"MZ"):
                continue


            try:
                # There must be more than 2 sections
                pe = pefile.PE(data=data, fast_load=True)
                if len(pe.sections) < 2:
                    continue
            except Exception as e:
                print(e)
                continue

            last_sec = pe.sections[-1]
            last_sec_data = proc_layer.read((last_sec.VirtualAddress + start), last_sec.Misc_VirtualSize)
            if len(last_sec_data) == 0:
                continue

            # contains C2 URL, RC4 key for decoding local.ds and the magic buffer
            decoded_config = ""
            # contains hw lock info, the user.ds RC4 key, and XOR key
            encoded_magic = ""
            # contains BO_LOGIN_KEY
            # contains de AES XOR key
            aes_xor_key = ""
            # Length of the Zeus Magic Object
            zeus_magic = ""
            # contains Salt RC4 Init key
            salt_rc4_initKey = ""

            for match in matches:
                sigaddr = match.strings[0][0] + start
                log.debug("Found {0} at {1:#x}".format(match.rule, sigaddr))
                if match.rule == "z1":
                    addr = struct.unpack("=I", proc_layer.read(sigaddr+30, 4))[0]
                    loginKey = proc_layer.read(addr, 0x20)
                elif match.rule == "z2":
                    address = struct.unpack("=I", proc_layer.read(sigaddr + 8, 0x4))[0]
                    size = struct.unpack("=I", proc_layer.read(sigaddr + 2, 0x4))[0]
                    encoded_config = proc_layer.read(address, size)
                    decoded_config = self.decode_config(encoded_config, last_sec_data)
                elif match.rule == "z3":
                    zeus_magic = proc_layer.read(sigaddr + 25, 0x4)
                    (zeus_magic,) = struct.unpack("=I", zeus_magic[0:4])
                    addr = struct.unpack("=I", proc_layer.read(sigaddr+31, 4))[0]
                    encoded_magic = proc_layer.read(addr, zeus_magic)
                elif match.rule == "z4":
                    zeus_magic = proc_layer.read(sigaddr + 24, 0x4)
                    (zeus_magic,) = struct.unpack("=I", zeus_magic[0:4])
                    addr = struct.unpack("=I", proc_layer.read(sigaddr+30, 4))[0]
                    encoded_magic = proc_layer.read(sigaddr + 30, zeus_magic,)
                elif match.rule == "z5":
                    aes_xor_key = proc_layer.read(sigaddr + 2, 0x4)
                    aes_xor_key += proc_layer.read(sigaddr + 17, 0x4)
                    aes_xor_key += proc_layer.read(sigaddr + 24, 0x4)
                    aes_xor_key += proc_layer.read(sigaddr + 31, 0x4)
                elif match.rule == "z6":
                    salt_rc4_initKey = proc_layer.read(sigaddr + 5, 0x4)
                    salt_rc4_initKey_hex = self.get_only_hex(salt_rc4_initKey).upper()

            if not decoded_config or not encoded_magic:
                continue

            offset = 0

            decoded_magic = ""
            config_key = ""
            aes_key = ""
            rc4_comKey = ""

            found = False

            while offset < len(decoded_config) - RC4_KEYSIZE:

                config_key = decoded_config[offset : offset + RC4_KEYSIZE]
                decoded_magic = self.rc4(config_key, encoded_magic, loginKey)
                # when the first four bytes of the decoded magic buffer equal the size
                # of the magic buffer, then we've found a winning RC4 key
                (struct_size,) = struct.unpack("=I", decoded_magic[0:4])
                if struct_size in ZEUS_STURCTURE_size and ZEUS_STURCTURE_size[struct_size].startswith("_CITADEL"):
                    if ZEUS_STURCTURE_size[struct_size] == "_CITADEL1345_CONFIG":
                        self.magic_struct = "_CITADEL1345_CONFIG"
                        self.zbotversion = " 1.3.4.5"
                    elif ZEUS_STURCTURE_size[struct_size] == "_CITADEL1351_CONFIG":
                        self.magic_struct = "_CITADEL1351_CONFIG"
                        self.zbotversion = " 1.3.5.1"
                    found = True
                if found:
                    aes_key = self.rc4(config_key, hashlib.md5(loginKey).digest(), loginKey)
                    rc4_comKey = self.rc4_init_cit(aes_key, salt_rc4_initKey)
                    break

                offset += 1

            if not found:
                log.debug("Error, cannot decode magic")
                continue

            # grab the URLs from the decoded buffer
            urls = []
            urls = self.get_urls(decoded_config, data)
            botnet = self.search_botnet(decoded_config, data)
            clean_urls = []
            config_file_paths = []
            for u in urls:
                f_path = ""
                clean_u = u
                if "|" in u:
                    clean_u = u[: u.find("|")]
                    f_path = u[u.find("|") + 1 :]
                clean_urls.append(clean_u)
                config_file_paths.append(f_path)

            parsed = parsed_struct(decoded_config, decoded_magic, self.magic_struct)

            registry_dict = {
                "key_path": "HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\%s" % "{0}".format(parsed["keyname"]),
                # .v() Do the actual reading and decoding of this member
                "Value1": "{0}".format(parsed["value1"]),
                "Value2": "{0}".format(parsed["value2"]),
                "Value3": "{0}".format(parsed["value3"]),
            }
            config = {
                "urls": clean_urls,
                "botnet": botnet,
                "malware_zbot": "CITADEL",
                "zbot_version": self.zbotversion,
                "process_name": utility.array_to_string(task.ImageFileName),
                "process_id": str(p.UniqueProcessId),
                "process_address": str(start),
                "computer_identifier": parsed["guid"],
                "mutant_key": str(parsed["guid_xor_key"]),
                "xor_key": str(parsed["xorkey"]),
                "config_rc4_keystream_plaintext": binascii.hexlify(config_key[:0x100]).decode("utf-8"),
                "comm_rc4_key_plaintext": binascii.hexlify(rc4_comKey).decode("utf-8"),
                "registry": registry_dict,
                "executable": parsed["exefile"],
                "login_key": loginKey.decode("utf-8").upper(),
                "aes_key": binascii.hexlify(aes_key).decode("utf-8").upper(),
                "aes_xor_key": binascii.hexlify(aes_xor_key).decode("utf-8").upper(),
                "config_file_paths": config_file_paths,
                "salt_rc4_initKey_hex": loginKey.decode("utf-8").upper(),
            }

            return config


class ICEIX(ZbotCommon):
    """ Scanner for ICE IX """

    def __init__(self, config, context):
        self.zbot = "ICEIX"
        self.zbotversion = ""
        self.config = config
        self.context = context

        self.signatures = {
            "namespace1": r"rule z1 {strings: $a = {56 BA ?? ?? 00 00 52 68 ?? ?? ?? ?? 50 E8 ?? ?? ?? ?? 8B 35 ?? ?? ?? ?? 8B 0D ?? ?? ?? ??} condition: $a}",
            "namespace5": r"rule z5 {strings: $a = {56 BA ?? ?? 00 00 52 68 ?? ?? ?? ?? 50 E8 ?? ?? ?? ?? 8B 0D ?? ?? ?? ?? 03 0D ?? ?? ?? ??} condition: $a}",
            "namespace2": r"rule z2 {strings: $a = {55 8B EC 51 A1 ?? ?? ?? ?? 8B 0D ?? ?? ?? ?? 56 8D 34 01 A1 ?? ?? ?? ?? 8B 0D ?? ?? ?? ??} condition: $a}",
            "namespace3": r"rule z3 {strings: $a = {68 02 01 00 00 8D 84 24 ?? ?? ?? ?? 50 8D 44 24 ?? 50 E8 ?? ?? ?? ?? B8 E6 01 00 00 50 68 ?? ?? ?? ??} condition: $a}",
            "namespace4": r"rule z4 {strings: $a = {68 02 01 00 00 8D 85 ?? ?? ?? ?? 50 8D 85 ?? ?? ?? ?? 50 E8 ?? ?? ?? ?? B8 E6 01 00 00 50 68 ?? ?? ?? ??} condition: $a}",
        }

        self.magic_struct = "_ZEUS2_CONFIG"
        self.magic_struct_size = ZEUS_STURCTURE[self.magic_struct]

    def rc4(self, key, data, offset1=3, offset2=7):
        """ Perform a basic RC4 operation """
        state = list(range(256))
        x = 0
        y = 0

        for i in list(range(256)):
            state[i] = key[i]

        out = [None] * len(data)

        for i in range(len(data)):
            x = (x + offset1) & 0xFF
            y = (state[x] + y + offset2) & 0xFF
            state[x], state[y] = state[y], state[x]
            out[i] = (data[i] ^ state[(state[x] + state[y]) & 0xFF])

        return bytes(out)

    def calculate(self, p, start, data, ps_ad):  # noqa: C901

        # check for the signature with YARA, both hits must be present
        rules = yara.compile(sources=self.signatures)
        matches = rules.match(data=data)
        try:
            # There must be more than 2 sections
            pe = pefile.PE(data=data, fast_load=True)
        except Exception as e:
            print(e)
            return

        # Get the last PE section's data
        last_sec = pe.sections[-1]
        last_sec_data = ps_ad.read((last_sec.VirtualAddress + start), last_sec.Misc_VirtualSize)
        if len(last_sec_data) == 0:
            log.debug("Last section is empty")
            return

        # contains C2 URL, RC4 key for decoding local.ds and the magic buffer
        decoded_config = ""
        # contains hw lock info, the user.ds RC4 key, and XOR key
        encoded_magic = ""

        for match in matches:
            sigaddr = match.strings[0][0] + start
            log.debug("Found {0} at {1:#x}".format(match.rule, sigaddr))

            if match.rule == "z1":
                address = struct.unpack("=I", ps_ad.read(sigaddr + 8, 0x4))[0]
                size = struct.unpack("=I", ps_ad.read(sigaddr + 2, 0x4))[0]
                encoded_config = ps_ad.read(address, size)
                decoded_config = self.decode_config(encoded_config, last_sec_data)
            elif match.rule == "z2":
                config_ptr = struct.unpack("=I", ps_ad.read(sigaddr + 26, 0x4))[0]
                config_ptr = struct.unpack("=I", ps_ad.read(config_ptr, 0x4))[0]
                encoded_config = ps_ad.read(config_ptr, 0x3C8)
                decoded_config = self.rc4(self.rc4_init(encoded_config), last_sec_data[2:])
            elif match.rule == "z5":
                address = struct.unpack("=I", ps_ad.read(sigaddr + 8, 0x4))[0]
                size = struct.unpack("=I", ps_ad.read(sigaddr + 2, 0x4))[0]
                encoded_config = ps_ad.read(address, size)
                decoded_config = self.decode_config(encoded_config, last_sec_data)
            elif match.rule == "z3":
                address = struct.unpack("=I", ps_ad.read(sigaddr + 30, 0x4))[0]
                encoded_magic = ps_ad.read(address, ZEUS_STURCTURE[self.magic_struct])
            elif match.rule == "z4":
                address = struct.unpack("=I", ps_ad.read(sigaddr + 31, 0x4))[0]
                encoded_magic = ps_ad.read(address, ZEUS_STURCTURE[self.magic_struct])

        if not decoded_config or not encoded_magic:
            log.debug("ICEIX not decoded_config or not encoded_magic")
            return None

        offset = 0

        decoded_magic = ""
        config_key = ""

        found = False
        while offset < len(decoded_config) - RC4_KEYSIZE:

            config_key = decoded_config[offset : offset + RC4_KEYSIZE]
            decoded_magic = self.rc4(config_key, encoded_magic)
            # when the first four bytes of the decoded magic buffer equal the size
            # of the magic buffer, then we've found a winning RC4 key
            (struct_size,) = struct.unpack("=I", decoded_magic[0:4])

            if struct_size == ZEUS_STURCTURE[self.magic_struct]:
                found = True
                break

            offset += 1

        if not found:
            log.debug("Error, cannot decode magic")
            return None

        # grab the URL from the decoded buffer
        url = decoded_config[decoded_config.find(b"http") :]
        url = url[:url.find(b"\x00")].decode("utf-8")

        # use list for url (sames as others families)
        urls = [url]
        creds_key = decoded_magic[0x8C : 0x8C + RC4_KEYSIZE]
        # add parsing here

        parsed = parsed_struct(decoded_config, decoded_magic, self.magic_struct)
        parsed["urls"] = urls
        parsed["guid2"] = binascii.hexlify(parsed["guid2"]).decode("utf-8")
        parsed["rc4key"] = binascii.hexlify(parsed["rc4key"]).decode("utf-8")


        registry_dict = {
            "key_path": "HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\%s" % "{0}".format(parsed["keyname"]),
            # .v() Do the actual reading and decoding of this member
            "Value1": "{0}".format(parsed["value1"]),
            "Value2": "{0}".format(parsed["value2"]),
            "Value3": "{0}".format(parsed["value3"]),
        }

        config = {
            "urls": urls,
            "malware_zbot": self.zbot,
            "zbot_version": self.zbotversion,
            "process_name": utility.array_to_string(p.ImageFileName),
            "process_id": str(p.UniqueProcessId),
            "process_address": str(start),
            "computer_identifier": parsed["guid"],
            "mutant_key": str(parsed["guid_xor_key"]),
            "xor_key": str(parsed["xorkey"]),
            "registry": registry_dict,
            "executable": parsed["exefile"],
            "data_file": parsed["datfile"],
            "urls": urls,
            "config_rc4_keystream_plaintext": binascii.hexlify(config_key[:0x100]).decode("utf-8"),
            "cred_rc4_key_plaintext": binascii.hexlify(creds_key[:0x100]).decode("utf-8"),
        }
        return p, start, config


```

`Windows/choco.bat`:

```bat
rem Chocolatey now requires PowerShell v3 (or higher) and .NET 4.0 (or higher) due to recent upgrades to TLS 1.2. 
rem Please ensure .NET 4+ and PowerShell v3+ are installed prior to attempting FLARE VM installation. 
rem Below are links to download .NET 4.5 and WMF 5.1 (PowerShell 5.1).
rem .NET 4.5 https://www.microsoft.com/en-us/download/details.aspx?id=30653
rem WMF 5.1 https://www.microsoft.com/en-us/download/details.aspx?id=54616


powershell -Command "if ($PSVersionTable.PSVersion.Major -ge 5 -and $PSVersionTable.PSVersion.Minor -ge 1 ){Set-ExecutionPolicy Bypass -Scope Process -Force; iwr https://community.chocolatey.org/install.ps1 -UseBasicParsing | iex } else {Write-Output "'Chocolatey now requires PowerShell v3 (or higher) and .NET 4.0 (or higher) due to recent upgrades to TLS 1.2. Please ensure .NET 4+ and PowerShell v3+ are installed prior to attempting FLARE VM installation. `nBelow are links to download .NET 4.5 and WMF 5.1 (PowerShell 5.1). .NET 4.5 https://www.microsoft.com/en-us/download/details.aspx?id=30653 WMF 5.1 https://www.microsoft.com/en-us/download/details.aspx?id=54616'"}"
choco upgrade chocolatey
choco install -y dotnetfx dotnet4.7.2 dotnet vcredist-all wixtoolset msxml4.sp3 msxml6.sp1

pip3 install pillow pywintrace

```

`Windows/disable_win7noise.bat`:

```bat
REM NTP
reg add "HKLM\SYSTEM\CurrentControlSet\Services\W32Time\Parameters" /v LocalNTP /t REG_DWORD /d 0 /f
REM HELP
REM http://www.windows-commandline.com/start-stop-service-command-line/
REM disable UAC
reg add "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" /v EnableLUA /t REG_DWORD /d 0 /f
REM disable Windows defender
sc config WinDefend start= disabled
REM disable windows update
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update" /v AUOptions /t REG_DWORD /d 1 /f
REM disable aero
net stop uxsms
REM disable the firewall
netsh firewall set opmode mode=DISABLE
REM disable IPv6
netsh interface teredo set state disabled
netsh interface ipv6 6to4 set state state=disabled undoonstop=disabled
netsh interface ipv6 isatap set state state=disabled
REM disable active probing
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\NlaSvc\Parameters\Internet" /v EnableActiveProbing /t REG_DWORD /d 0 /f
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\NetworkConnectivityStatusIndicator" /v EnableActiveProbing /t REG_DWORD /d 0 /f
REM disable passive probing
reg add  "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\NlaSvc\Parameters\Internet" /v PassivePollPeriod /t REG_DWORD /d 0 /f
REM disable SSDP
sc config SSDPSRV start= disabled
net stop SSDPSRV
REM disable computer browsing
sc stop Browser
sc config Browser start= disabled
REM disable WinHTTP Web Proxy Auto-Discovery
reg add "HKLM\SYSTEM\CurrentControlSet\services\WinHttpAutoProxySvc" /v Start /t REG_DWORD /d 4 /f
REM disable Function Discovery Resource Publication service
reg add "HKLM\SYSTEM\CurrentControlSet\services\FDResPup" /v Start /t REG_DWORD /d 4 /f
REM IE blank page
reg add "HKCU\Software\Microsoft\Internet Explorer\Main" /V "Start Page" /D "" /F
REM disable IExplorer Proxy
reg add "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings" /v ProxyEnable /t  REG_DWORD /d 00000000 /f
REM disable netbios in TCP/IP
wmic nicconfig where index=8 call SetTcpipNetbios 2
REM disable netbios service
reg add "HKLM\SYSTEM\CurrentControlSet\services\Lmhosts" /v Start /t REG_DWORD /d 4 /f
REM disable LLMNR
reg add "HKLM\Software\policies\Microsoft\Windows NT\DNSClient" /v "EnableMulticast" /t REG_DWORD /d 0 /f
REMdisable SQM
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\FlexGo\FGNotify\Prechecks"  /v Sqm /t REG_DWORD /d 00000002 /f
REM Disable cert check
reg add "HKLM\SYSTEM\CurrentControlSet\Services\HTTP\Parameters\SslBindingInfo" /v DefaultSslCertCheckMode /t REG_DWORD /d 1 /f
REM disable ClickToRunSvc
sc stop "ClickToRunSvc"
sc config "ClickToRunSvc" start= disabled

REM dr.watson
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AeDebug" /v AUTO /t REG_SZ /d 0 /f
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AeDebug" /v AutoExclusionList /t REG_SZ /d 0 /f

REM curtain
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\PowerShell\ModuleLogging\ModuleNames" /v * /t REG_SZ /d * /f /reg:64
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging" /v EnableScriptBlockLogging /t REG_DWORD /d 00000001 /f /reg:64
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\PowerShell\Transcription" /v EnableTranscripting /t REG_DWORD /d 00000001 /f /reg:64
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\PowerShell\Transcription" /v OutputDirectory /t REG_SZ /d C:\PSTranscipts /f /reg:64
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\PowerShell\Transcription" /v EnableInvocationHeader /t REG_DWORD /d 00000001 /f /reg:64

REM disable windows defender
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender" /v DisableAntiSpyware /t REG_DWORD /d 0 /f

REM https://superuser.com/questions/972501/how-to-stop-microsoft-from-gathering-telemetry-data-from-windows-7-8-and-8-1
sc stop DiagTrack
sc stop dmwappushservice
sc delete DiagTrack
sc delete dmwappushservice
echo "" > C:\ProgramData\Microsoft\Diagnosis\ETLLogs\AutoLogger\AutoLogger-Diagtrack-Listener.etl
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\DataCollection" /v AllowTelemetry /t REG_DWORD /d 0 /f
reg add "HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\WMI\AutoLogger" /v AutoLogger-Diagtrack-Listener /t DWORD /d 0 /f

REM Win10/11 telemetry
sc config DiagTrack start= disabled
sc config dmwappushservice start= disabled

REM schtasks
schtasks.exe /Change /TN "\Microsoft\Office\Office Automatic Updates 2.0" /Disable /ru ""
schtasks.exe /Change /TN "\Microsoft\Office\Office ClickToRun Service Monitor" /Disable /ru ""
schtasks.exe /Change /TN "\Microsoft\Office\Office Feature Updates" /Disable /ru ""
schtasks.exe /Change /TN "\Microsoft\Office\Office Feature Updates Logon" /Disable /ru ""
schtasks.exe /Change /TN "\Microsoft\Office\OfficeTelemetryAgentFallBack2016" /Disable /ru ""
schtasks.exe /Change /TN "\Microsoft\Office\OfficeTelemetryAgentLogOn2016" /Disable /ru ""

schtasks.exe /Change /TN "\Microsoft\Windows\Application Experience\AitAgent" /Disable /ru ""
schtasks.exe /Change /TN "\Microsoft\Windows\Application Experience\Microsoft Compatibility Appraiser" /Disable /ru ""
schtasks.exe /Change /TN "\Microsoft\Windows\Application Experience\ProgramData\Updater" /Disable /ru ""
schtasks.exe /Change /TN "\Microsoft\Windows\Customer Experience Improvement Program\KernelCeipTask" /Disable /ru ""
schtasks.exe /Change /TN "\Microsoft\Windows\Customer Experience Improvement Program\UsbCeip" /Disable /ru ""
schtasks.exe /Change /TN "\Microsoft\Windows\Customer Experience Improvement Program\Consolidator" /Disable /ru ""
schtasks.exe /Change /TN "\Microsoft\Windows\Autochk\Proxy" /Disable /ru ""
schtasks.exe /Change /TN "\Microsoft\Windows\DiskDiagnostic\Microsoft-Windows-DiskDiagnosticDataCollector" /Disable /ru ""
schtasks.exe /Change /TN "\Microsoft\Windows\Windows Media Sharing\UpdateLibrary" /Disable /ru ""

schtasks.exe /Change /TN "\CCleaner Update" /Disable /ru ""
schtasks.exe /Change /TN "\CCleaner UpdateSkipUAC" /Disable /ru ""
schtasks.exe /Change /TN "\Microsoft\Windows\Windows Media Sharing\UpdateLibrary" /Disable /ru ""
schtasks.exe /Change /TN "\Microsoft\Windows\Windows Media Sharing\UpdateLibrary" /Disable /ru ""


REM Uninstall telemetry updates
wusa /uninstall /kb:3065988 /quiet /norestart
wusa /uninstall /kb:3083325 /quiet /norestart
wusa /uninstall /kb:3083324 /quiet /norestart
wusa /uninstall /kb:2976978 /quiet /norestart
wusa /uninstall /kb:3075853 /quiet /norestart
wusa /uninstall /kb:3065987 /quiet /norestart
wusa /uninstall /kb:3050265 /quiet /norestart
wusa /uninstall /kb:3050267 /quiet /norestart
wusa /uninstall /kb:3075851 /quiet /norestart
wusa /uninstall /kb:2902907 /quiet /norestart
wusa /uninstall /kb:3068708 /quiet /norestart
wusa /uninstall /kb:3022345 /quiet /norestart
wusa /uninstall /kb:2952664 /quiet /norestart
wusa /uninstall /kb:2990214 /quiet /norestart
wusa /uninstall /kb:3035583 /quiet /norestart
wusa /uninstall /kb:971033 /quiet /norestart
wusa /uninstall /kb:3021917 /quiet /norestart
wusa /uninstall /kb:3044374 /quiet /norestart
wusa /uninstall /kb:3046480 /quiet /norestart
wusa /uninstall /kb:3075249 /quiet /norestart
wusa /uninstall /kb:3080149 /quiet /norestart
wusa /uninstall /kb:2977759 /quiet /norestart
wusa /uninstall /kb:3083710 /quiet /norestart
wusa /uninstall /kb:3083711 /quiet /norestart
wusa /uninstall /kb:3112336 /quiet /norestart
wusa /uninstall /kb:3123862 /quiet /norestart

REM office 2010
reg add "HKEY_CURRENT_USER\Software\Microsoft\Office\Common\Security" /v DisableAllActiveX /t  REG_DWORD /d 0 /f
reg add "HKEY_CURRENT_USER\Software\Microsoft\Office\Common\Security" /v UFIControls /t  REG_DWORD /d 1 /f
for %%x in (Word Excel PowerPoint Publisher Outlook) do (
    reg add "HKEY_CURRENT_USER\Software\Microsoft\Office\14.0\%%x\Common\General" /v ShownOptIn /t  REG_DWORD /d 1 /f
    reg add "HKEY_CURRENT_USER\Software\Microsoft\Office\14.0\%%x\Security" /v VBAWarnings /t  REG_DWORD /d 1 /f
    reg add "HKEY_CURRENT_USER\Software\Microsoft\Office\14.0\%%x\Security" /v AccessVBOM /t  REG_DWORD /d 1 /f
    reg add "HKEY_CURRENT_USER\Software\Microsoft\Office\14.0\%%x\Security" /v DisableDDEServerLaunch /t  REG_DWORD /d 0 /f
    reg add "HKEY_CURRENT_USER\Software\Microsoft\Office\14.0\%%x\Security" /v ExtensionHardening /t  REG_DWORD /d 0 /f
    reg add "HKEY_CURRENT_USER\Software\Microsoft\Office\14.0\%%x\Security" /v ShownOptIn /t  REG_DWORD /d 1 /f
    reg add "HKEY_CURRENT_USER\Software\Microsoft\Office\14.0\%%x\Security" /v ShownOptIn /t  REG_DWORD /d 1 /f
    reg add "HKEY_CURRENT_USER\Software\Microsoft\Office\14.0\%%x\Security" /v ShownOptIn /t  REG_DWORD /d 1 /f
    reg add "HKEY_CURRENT_USER\Software\Policies\Microsoft\Office\14.0\%%x\Security" /v MarkInternalAsUnsafe /t  REG_DWORD /d 0 /f
    reg add "HKEY_CURRENT_USER\Software\Microsoft\Office\14.0\%%x\Security\ProtectedView" /v DisableAttachmentsInPV /t  REG_DWORD /d 1 /f
    reg add "HKEY_CURRENT_USER\Software\Microsoft\Office\14.0\%%x\Security\ProtectedView" /v DisableInternetFilesInPV /t  REG_DWORD /d 1 /f
    reg add "HKEY_CURRENT_USER\Software\Microsoft\Office\14.0\%%x\Security\ProtectedView" /v DisableUnsafeLocationsInPV /t  REG_DWORD /d 1 /f
    reg add "HKEY_CURRENT_USER\Software\Microsoft\Office\14.0\%%x\Security" /v EnableDEP /t  REG_DWORD /d 1 /f
)

```