Project Path: arc_0xenia_remem_j4b88j3i

Source Tree:

```txt
arc_0xenia_remem_j4b88j3i
├── LICENSE
├── README.md
└── remem.hpp

```

`LICENSE`:

```
MIT License

Copyright (c) 2024 0xenia

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# remem - Memory Manipulation Library

`remem` is a C++20/C++17 header-only library designed for safely reading and writing memory in Windows applications. It includes features like exception handling, pointer validation, and memory manipulation utilities, making it a useful tool for low-level memory operations.

## Features

- **Memory Reading and Writing**: Easily read and write memory at specified addresses with support for multiple offsets.
- **Pointer Validation**: Ensure that pointers are valid before accessing memory, preventing crashes or undefined behavior.
- **Pattern Scanning**: Find byte patterns in memory with support for both IDA-style signatures and code style signatures.
- **Function Calling**: Call functions with different calling conventions, including support for member functions (with `this` pointer).
- **Exception Handling**: (Optional) Safeguard against exceptions during pointer dereferencing by using a vectored exception handler.
- **Logging**: (Optional) Log memory addresses and offsets during read/write operations for debugging purposes.

## Installation

To use `remem` in your project, simply include the `remem.hpp` header file in your code. No additional dependencies are required.

## Usage

### 1. Setup Exception Handler (Optional)

If you want to enable exception handling, you should set up the exception handler at the beginning of your program:

```cpp
remem::SetupExceptionHandler();
```

### 2. Reading Memory

You can read memory using the ReadMemory function template. It supports reading from an address with multiple offsets:

```cpp
uintptr_t baseAddress = remem::GetModuleBaseAddress<uintptr_t>("module_name.exe");
std::vector<DWORD> offsets = {0x10, 0x20, 0x30};
int value = remem::ReadMemory<int>(baseAddress, offsets);
```

If you want to read a string from memory:

```cpp
std::string value = remem::ReadMemory<std::string>(baseAddress, offsets);
```

### 3. Writing Memory

Similarly, you can write to memory using the WriteMemory function template:

```cpp
int newValue = 12345;
remem::WriteMemory<int>(baseAddress, offsets, newValue);
```

### 4. Writing Memory

Before performing any operations on a pointer, you can validate it:

```cpp
void* ptr = reinterpret_cast<void*>(address);
if (remem::IsValidPtr(ptr)) {
    // Safe to use the pointer
}
```

### 5. Function calling

The CallFunction template allows you to call functions with different calling conventions in C++. Here’s how to use it:

#### 1. Determine the Calling Convention

Decide which calling convention your function uses (`thiscall`, `fastcall`, `stdcall`, or `cdecl`).

#### 2. Define the Function Signature

Specify the return type and parameters of the function you want to call.

#### 3. Call the Function

**For thiscall and fastcall conventions, you need to pass a this pointer as the first argument.**

**For stdcall and cdecl conventions, you do not need to pass a this pointer.**

#### Example Usage

**To call a thiscall or fastcall function, provide the address of the function, a this pointer, and the arguments:**

```cpp
auto result = CallFunction<CallingConvention::thiscall_, ReturnType>(funcAddress, thisPointer, arg1, arg2);
```

**To call a stdcall or cdecl function, provide the address of the function and the arguments:**

```cpp
auto result = CallFunction<CallingConvention::cdecl_, ReturnType>(funcAddress, arg1, arg2);
```

In both cases, replace `ReturnType` with the return type of the function and `funcAddress` with the address of the function you are calling.

### 6. Pattern Scanning

The pattern class allows for easy memory pattern scanning with support for both IDA-style signatures and code-style signatures.

`pattern` Class

**Constructor**

**```pattern(std::string _pattern, const char* _module_name = nullptr)```**: Constructs a pattern object by scanning for the specified pattern in the given module (or the current module if nullptr).

**Member Functions**

**```pattern add(uint32_t _value, bool _deref = false)```**: Adds an offset to the current pointer. If _deref is true, it will also dereference the pointer before adding the offset.

**```pattern sub(uint32_t _value)```**: Subtracts an offset from the current pointer.

**```pattern inst(uint32_t _offset)```**: Adds an offset to the current pointer, with the offset value taken from a pointer located at _offset from the current pointer.

**```GetPointer()```**: Returns the current pointer value.

#### Example Usage

For example we are pattern scanning ```mov ecx, [0xDEADBEEF]```

```cpp
auto PatternTest = remem::pattern("8B 0D ?? ?? ?? ??").add(2, true);
```

The add member will deref the pointer if we call ```auto insideofmovecx = PatternTest.GetPointer()``` it will return 0xDEADBEEF.

## Configuration


### Exception Handling

Exception handling can be enabled or disabled by setting the _EXCEPTION_HANDLING macro:

```cpp
#define _EXCEPTION_HANDLING 1  // Enable exception handling
```

### Logging

Logging can be enabled or disabled by setting the _LOGS macro:

```cpp
#define _LOGS 1 
```

## Platform Support

This library is designed specifically for Windows and utilizes Windows-specific APIs.

## License

This library is provided as-is, with no warranties or guarantees. Use it at your own risk.

## Author

Created by 0xenia on 11.08.2024.

```

`remem.hpp`:

```hpp
//
// Created by Xenia on 11.08.2024.
//

#ifndef REMEM_HPP
#define REMEM_HPP

#include <Windows.h>
#include <vector>
#include <iostream>
#include <regex>
#include <map>

#define _EXCEPTION_HANDLING 1

#define _LOGS 1

//Credit to dogmatt on unknowncheats.me for IsValidPtr
//https://www.unknowncheats.me/forum/battlefield-4-a/105265-omg-nub-scrub-crash-fix-codenz-x64.html#post888788
#if _EXCEPTION_HANDLING

#pragma code_seg(push, ".text")

__declspec(allocate(".text"))
#ifdef _X86_
constexpr std::uint8_t __checker[3] = { 0x8B, 0x01, 0xC3 };
#else
constexpr std::uint8_t __checker[4] = { 0x48, 0x8B, 0x01, 0xC3 };
#endif

#pragma code_seg()

#ifdef _X86_
#define BAD ((PVOID)0x1338caf0)
constexpr int ALIGNMENT = 4;
#else
#define BAD ((PVOID)0x1338cafebabef00d)
constexpr int ALIGNMENT = 8;
#endif

#ifdef _X86_
#define _PTR_MAX_VALUE ((PVOID)0xFFE00000)
#else
#define _PTR_MAX_VALUE ((PVOID)0x000F000000000000)
#endif

#endif

enum class CallingConvention
{
	cdecl_,
	stdcall_,
	thiscall_,
	fastcall_
};

#if _LOGS
enum class LogLevel : std::uint8_t
{
	LOG_ERROR,
	INFO,
	WARN,
	DEBUG
};
#endif

namespace remem
{
#pragma region LOGGING
	LogLevel _currentLogLevel = LogLevel::INFO;
	void Log(LogLevel level, const std::string& message)
	{
		if (static_cast<int>(level) >= static_cast<int>(_currentLogLevel))
		{
			switch (level)
			{
			case LogLevel::DEBUG:
				std::cout << "[DEBUG] " << message << std::endl;
				break;
			case LogLevel::INFO:
				std::cout << "[INFO] " << message << std::endl;
				break;
			case LogLevel::WARN:
				std::cerr << "[WARN] " << message << std::endl;
				break;
			case LogLevel::LOG_ERROR:
				std::cerr << "[ERROR] " << message << std::endl;
				break;
			}
		}
	}
#pragma endregion
#pragma region EXCEPTION_HANDLING
#if _EXCEPTION_HANDLING

	using tPointerChecker = void* (*)(void*);

	inline auto AvoidBadPtr = (tPointerChecker)&__checker;

	LONG WINAPI EH(EXCEPTION_POINTERS* ExceptionInfo)
	{
#ifdef _X86_
		if (ExceptionInfo->ContextRecord->Eip != (std::uintptr_t)__checker)
			return EXCEPTION_CONTINUE_SEARCH;
#else
		if (ExceptionInfo->ContextRecord->Rip != (std::uintptr_t)__checker)
			return EXCEPTION_CONTINUE_SEARCH;
#endif

#ifdef _X86_
		ExceptionInfo->ContextRecord->Eip += 2;
		ExceptionInfo->ContextRecord->Eax = (std::uintptr_t)BAD;
#else
		ExceptionInfo->ContextRecord->Rip += 3;
		ExceptionInfo->ContextRecord->Rax = (std::uintptr_t)BAD;
#endif

		return EXCEPTION_CONTINUE_EXECUTION;
	}

	inline bool IsValidPtr(void* Ptr)
	{
		return (Ptr >= (void*)0x10000) && (Ptr < _PTR_MAX_VALUE) && !((std::uintptr_t)Ptr & (ALIGNMENT - 1)) && AvoidBadPtr(Ptr) != BAD;
	}

	void SetupExceptionHandler()
	{
		AddVectoredExceptionHandler(1, EH);
	}

#else

	bool IsValidPtr(void* ptr) {
		size_t size = sizeof(ptr);
		if (ptr == nullptr) {
			return false;
		}

		if (ptr <= (void*)0xFFFFFF || ptr >= (void*)0x7FFFFFFFFFFF) {
			return false;
		}

		MEMORY_BASIC_INFORMATION mbi;
		BYTE* p = (BYTE*)ptr;
		BYTE* maxp = p + size;
		while (p < maxp) {
			if (VirtualQuery(p, &mbi, sizeof(mbi)) == 0) {
				return false;
			}

			if (!(mbi.Protect & (PAGE_READONLY | PAGE_READWRITE | PAGE_WRITECOPY | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY))) {
				return false;
			}

			if (mbi.Protect & (PAGE_GUARD | PAGE_NOACCESS)) {
				return false;
			}

			p += mbi.RegionSize;
		}

		return true;
	}

#endif
#pragma endregion
#pragma region MODULE_BASE
	template <typename T>
	T GetModuleBaseAddress()
	{
		return reinterpret_cast<T>(GetModuleHandleA(NULL));
	}

	template <typename T>
	T GetModuleBaseAddress(const char* _moduleName)
	{
		return reinterpret_cast<T>(GetModuleHandleA(_moduleName));
	}
#pragma endregion
#pragma region READ_MEMORY
	template <typename T>
#if _HAS_CXX20
	T ReadMemory(const auto& _address, const std::vector<DWORD>& _offsets)
#else
	T ReadMemory(uintptr_t _address, const std::vector<DWORD>& _offsets)
#endif
	{
#if _HAS_CXX20
		auto _current = (uintptr_t)_address;
#else
		auto _current = _address;
#endif
#if _LOGS
		remem::Log(LogLevel::DEBUG, "Read Memory Address : " + std::to_string(_current));
#endif

		for (auto iter = _offsets.begin(); iter != _offsets.end(); ++iter)
		{
			DWORD _offset = *iter;

			if (!IsValidPtr(reinterpret_cast<void*>(_current)))
			{
#if _LOGS
				remem::Log(LogLevel::LOG_ERROR, "Error: Null pointer dereferenced at Offset: " + std::to_string(_offset));
#endif
				return T{};
			}

			// for some reason it happened like this
			if (std::next(iter) == _offsets.end())
			{
				if constexpr (std::is_same_v<T, std::string>)
				{
					_current = (_current + _offset);
#if _LOGS
					remem::Log(LogLevel::DEBUG, "Offset: " + std::to_string(_offset) + " | Offset Read Memory: " + std::to_string(_current));
#endif
					return std::string(reinterpret_cast<const char*>(_current));
				}
			}

			_current = *reinterpret_cast<uintptr_t*>(_current + _offset);
#if _LOGS
			remem::Log(LogLevel::DEBUG, "Offset: " + std::to_string(_offset) + " | Offset Read Memory: " + std::to_string(_current));
#endif
		}

		if constexpr (std::is_pointer_v<T>)
		{
			if (!IsValidPtr(reinterpret_cast<void*>(_current)))
			{
#if _LOGS
				remem::Log(LogLevel::LOG_ERROR, "Error: Invalid final memory address: " + std::to_string(_current));
#endif
				return T{};
			}
			return reinterpret_cast<T>(_current);
		}

		if constexpr (std::is_integral_v<T>)
		{
			return static_cast<T>(_current);
		}

		return T{};
	}
#pragma endregion
#pragma region WRITE_MEMORY
	template <typename T>
#if _HAS_CXX20
	void WriteMemory(const auto& _address, const std::vector<DWORD>& _offsets, T _value)
#else
	void WriteMemory(uintptr_t _address, const std::vector<DWORD>& _offsets, T _value)
#endif
	{
#if _HAS_CXX20
		auto _current = (uintptr_t)_address;
#else
		auto _current = _address;
#endif

		for (auto iter = _offsets.begin(); iter != _offsets.end(); ++iter)
		{
			DWORD _offset = *iter;
			if (!IsValidPtr(reinterpret_cast<void*>(_current)))
			{
#if _LOGS
				remem::Log(LogLevel::LOG_ERROR, "Error: Invalid final memory address: " + std::to_string(_current));
#endif
				return;
			}
			if (std::next(iter) == _offsets.end())
			{
				if (!IsValidPtr(reinterpret_cast<void*>(_current)))
				{
#if _LOGS
					remem::Log(LogLevel::LOG_ERROR, "Error: Invalid final memory address: " + std::to_string(_current));
#endif
					return;
				}

				(*reinterpret_cast<T*>(_current + _offset)) = _value;
				return;
			}

			_current = *reinterpret_cast<uintptr_t*>(_current + _offset);
		}
	}
#pragma endregion
#pragma region FUNCTION_CALL
	template <CallingConvention Convention, typename ReturnType, typename... Args>
	struct FunctionType;

	template <typename ReturnType, typename... Args>
	struct FunctionType<CallingConvention::thiscall_, ReturnType, Args...>
	{
		using type = ReturnType(__thiscall*)(void*, Args...);
	};

	template <typename ReturnType, typename... Args>
	struct FunctionType<CallingConvention::fastcall_, ReturnType, Args...>
	{
		using type = ReturnType(__fastcall*)(void*, Args...);
	};

	template <typename ReturnType, typename... Args>
	struct FunctionType<CallingConvention::stdcall_, ReturnType, Args...>
	{
		using type = ReturnType(__stdcall*)(Args...);
	};

	template <typename ReturnType, typename... Args>
	struct FunctionType<CallingConvention::cdecl_, ReturnType, Args...>
	{
		using type = ReturnType(__cdecl*)(Args...);
	};

	template <CallingConvention Convention, typename ReturnType, typename... Args>
#if _HAS_CXX20
	auto CallFunction(const auto& _call_address, void* _this_pointer, Args... _args) -> std::enable_if_t<(Convention == CallingConvention::thiscall_ || Convention == CallingConvention::fastcall_), ReturnType>
#else
	auto CallFunction(uintptr_t _call_address, void* _this_pointer, Args... _args) -> std::enable_if_t<(Convention == CallingConvention::thiscall_ || Convention == CallingConvention::fastcall_), ReturnType>
#endif
	{
		using fn_t = typename FunctionType<Convention, ReturnType, Args...>::type;
		auto fn = reinterpret_cast<fn_t>(_call_address);
		return fn(_this_pointer, _args...);
	}

	template <CallingConvention Convention, typename ReturnType, typename... Args>
#if _HAS_CXX20
	auto CallFunction(const auto& _call_address, Args... _args) -> std::enable_if_t<(Convention != CallingConvention::thiscall_ && Convention != CallingConvention::fastcall_), ReturnType>
#else
	auto CallFunction(uintptr_t _call_address, Args... _args) -> std::enable_if_t<(Convention != CallingConvention::thiscall_ && Convention != CallingConvention::fastcall_), ReturnType>
#endif
	{
		using fn_t = typename FunctionType<Convention, ReturnType, Args...>::type;
		auto fn = reinterpret_cast<fn_t>(_call_address);
		return fn(_args...);
	}

	template <int Index, typename ReturnType, typename... Args>
	auto VirtualCall(const void* _this_pointer, Args... _args)
	{
		using fn_t = ReturnType(__thiscall*)(void*, decltype(_args)...);
		auto fn = (*reinterpret_cast<fn_t**>(_this_pointer))[Index];
		return fn(_this_pointer, _args...);
	}
#pragma endregion
#pragma region PATTERN_SCAN

	std::map<uintptr_t, SIZE_T> _cache;

	uintptr_t GetModuleSize(HMODULE module)
	{
		const auto dos_header = reinterpret_cast<PIMAGE_DOS_HEADER>(module);
		const auto nt_headers = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<std::uint8_t*>(module) + dos_header->e_lfanew);
		return nt_headers->OptionalHeader.SizeOfImage;
	}

	bool CacheMemory(const char* _module)
	{
		MEMORY_BASIC_INFORMATION mbi;
		HMODULE module = (_module) ? GetModuleHandleA(_module) : GetModuleHandleA(NULL);
		uintptr_t _addr = reinterpret_cast<uintptr_t>(module);
		uintptr_t _end = _addr + GetModuleSize(module);

		while (_addr < _end)
		{
			if (VirtualQuery(reinterpret_cast<LPCVOID>(_addr), &mbi, sizeof(mbi)))
			{
				if (mbi.State == MEM_COMMIT && !(mbi.Protect & (PAGE_NOACCESS | PAGE_GUARD)))
				{
					uintptr_t region_end = _addr + mbi.RegionSize;
					if (region_end > _end)
					{
						region_end = _end;
					}
					_cache[_addr] = region_end - _addr;
				}
				_addr += mbi.RegionSize;
			}
			else
			{
				_addr += mbi.RegionSize;
			}
		}
		return true;
	}

	std::uint8_t* find(std::string _pattern, const char* _module_name)
	{
		HMODULE module = (_module_name) ? GetModuleHandleA(_module_name) : GetModuleHandleA(NULL);

		if (!module)
			return nullptr;

		// Handle the conversion of a code style sig to an IDA one if required
		if (strstr(_pattern.c_str(), "\\x")) {
			// Fistly, convert \x to a space
			_pattern = std::regex_replace(_pattern, std::regex("\\\\x"), " ");

			// Remove any masks before converting 00's to a ?
			_pattern = std::regex_replace(_pattern, std::regex("x"), "");
			_pattern = std::regex_replace(_pattern, std::regex("\\?"), "");

			// Convert any 00's to ?
			_pattern = std::regex_replace(_pattern, std::regex("00"), "?");

			// Remove first space if there is one
			if (_pattern[0] == ' ')
				_pattern.erase(0, 1);
		}

		static const auto pattern_to_byte = [](const char* pattern)
			{
				auto bytes = std::vector<int>{};
				const auto start = const_cast<char*>(pattern);
				const auto end = const_cast<char*>(pattern) + std::strlen(pattern);

				for (auto current = start; current < end; ++current)
				{
					if (*current == '?')
					{
						++current;

						if (*current == '?')
							++current;

						bytes.push_back(-1);
					}
					else
					{
						bytes.push_back(std::strtoul(current, &current, 16));
					}
				}
				return bytes;
			};

		const auto pattern_bytes = pattern_to_byte(_pattern.c_str());

		const auto pattern_size = pattern_bytes.size();
		const auto pattern_data = pattern_bytes.data();

		for (const auto& [start_addr, region_size] : _cache)
		{
			for (auto i = 0ul; i < region_size - pattern_size; ++i)
			{
				auto found = true;
				auto address = reinterpret_cast<std::uint8_t*>(start_addr) + i;

				for (auto j = 0ul; j < pattern_size; ++j)
				{
					if (address[j] == pattern_data[j] || pattern_data[j] == -1)
						continue;
					found = false;
					break;
				}

				if (!found)
					continue;

				return address;
			}
		}

		return nullptr;
	}

	class pattern {
	public:
		pattern(std::string _pattern, const char* _module_name = nullptr)
		{
			if (!this->_cached)
			{
				if (CacheMemory(_module_name))
				{
					this->_cached = true;
#ifdef _X86_
					this->_pointer = (uint32_t)find(_pattern, _module_name);
#else
					this->_pointer = (uint64_t)find(_pattern, _module_name);
#endif
				}
			}
			else
			{
#ifdef _X86_
				this->_pointer = (uint32_t)find(_pattern, _module_name);
#else
				this->_pointer = (uint64_t)find(_pattern, _module_name);
#endif
			}
		}

		pattern add(uint32_t _value, bool _deref = false)
		{
			if (!_deref)
			{
				this->_pointer += _value;
			}
			else
			{
				this->_pointer += _value;
				this->_pointer = *reinterpret_cast<decltype(this->_pointer)*>(this->_pointer);
			}
			return *this;
		}

		pattern sub(uint32_t _value)
		{
			this->_pointer -= _value;
			return *this;
		}

		pattern inst(uint32_t _offset)
		{
			this->_pointer = *(int*)(this->_pointer + _offset) + this->_pointer;
			return *this;
		}

#ifdef _X86_
		uint32_t ResolvePtr() const
		{
			return *reinterpret_cast<uint32_t*>(this->_pointer);
		}
		uint32_t GetPointer() const
		{
			return this->_pointer;
		}
#else
		uint64_t ResolvePtr() const
		{
			return *reinterpret_cast<uint64_t*>(this->_pointer);
		}
		uint64_t GetPointer() const
		{
			return this->_pointer;
		}
#endif

	private:
#ifdef _X86_
		uint32_t _pointer = NULL;
#else
		uint64_t _pointer = NULL;
#endif
		bool _cached = false;
	};

#pragma endregion
};

#endif
```