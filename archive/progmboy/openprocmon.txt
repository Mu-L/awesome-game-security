Project Path: arc_progmboy_openprocmon_t5kmr2_e

Source Tree:

```txt
arc_progmboy_openprocmon_t5kmr2_e
├── CMakeLists.txt
├── LICENSE
├── README.md
├── cmake
│   ├── FindWTL.cmake
│   └── FindWdk.cmake
├── gui
│   ├── AboutDlg.h
│   ├── CMakeLists.txt
│   ├── MainFrm.h
│   ├── View.h
│   ├── dataview.cpp
│   ├── dataview.h
│   ├── filter.cpp
│   ├── filter.hpp
│   ├── filterdlg.cpp
│   ├── filterdlg.h
│   ├── filtermgr.cpp
│   ├── filtermgr.h
│   ├── fltprocess.h
│   ├── main.cpp
│   ├── procmon_gui.h
│   ├── procmon_gui.rc
│   ├── procmon_gui.sln
│   ├── procmon_gui.vcxproj
│   ├── procmon_gui.vcxproj.filters
│   ├── procmon_gui.vcxproj.user
│   ├── propdlg.cpp
│   ├── propdlg.h
│   ├── propevent.cpp
│   ├── propevent.h
│   ├── propproc.h
│   ├── propstack.cpp
│   ├── propstack.h
│   ├── res
│   │   ├── Toolbar.bmp
│   │   ├── check.ico
│   │   ├── file.ico
│   │   ├── process.ico
│   │   ├── procmon_gui.ico
│   │   ├── registry.ico
│   │   ├── remove.ico
│   │   └── tool.bmp
│   ├── resource.h
│   ├── stdafx.cpp
│   └── stdafx.h
├── images
│   ├── mian_gui.png
│   ├── prop_event.png
│   ├── prop_proc.png
│   └── prop_stack.png
├── kernel
│   ├── CMakeLists.txt
│   ├── file.c
│   ├── file.h
│   ├── globals.c
│   ├── globals.h
│   ├── log.c
│   ├── log.h
│   ├── logsdk.h
│   ├── ntheader.h
│   ├── process.c
│   ├── process.h
│   ├── procmon.c
│   ├── procmon.inf
│   ├── procmon.rc
│   ├── procmon.vcxproj
│   ├── procmon.vcxproj.filters
│   ├── procmon.vcxproj.user
│   ├── reg.c
│   ├── reg.h
│   ├── utils.c
│   └── utils.h
├── procmon.sln
└── sdk
    ├── example
    │   ├── CMakeLists.txt
    │   ├── example.cpp
    │   ├── example.vcxproj
    │   ├── example.vcxproj.user
    │   └── sdktest.vcxproj.filters
    └── procmonsdk
        ├── CMakeLists.txt
        ├── buffer.cxx
        ├── buffer.hpp
        ├── drvload.cxx
        ├── drvload.hpp
        ├── event.cxx
        ├── event.hpp
        ├── eventfactory.cxx
        ├── eventfactory.hpp
        ├── eventmgr.cxx
        ├── eventmgr.hpp
        ├── eventview.cxx
        ├── eventview.hpp
        ├── fileopt.cxx
        ├── fileopt.hpp
        ├── fltuser.hpp
        ├── kernelsdk.hpp
        ├── logger.cxx
        ├── logger.hpp
        ├── module.cxx
        ├── module.hpp
        ├── monctl.cxx
        ├── monctl.hpp
        ├── pch.cxx
        ├── pch.hpp
        ├── process.cxx
        ├── process.hpp
        ├── procmgr.cxx
        ├── procmgr.hpp
        ├── procmonsdk.vcxproj
        ├── procmonsdk.vcxproj.filters
        ├── procmonsdk.vcxproj.user
        ├── procopt.cxx
        ├── procopt.hpp
        ├── refobject.hpp
        ├── regopt.cxx
        ├── regopt.hpp
        ├── sdk.hpp
        ├── singleton.hpp
        ├── strmaps.cxx
        ├── strmaps.hpp
        ├── thread.cxx
        ├── thread.hpp
        ├── utils.cxx
        ├── utils.hpp
        ├── viewer.cxx
        └── viewer.hpp

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.1)
project(openprocmon)

option(BUILD_EXAMPLE "build sdk example" ON)

##
## set the cmake moudle path
## to find wdk and wtl
##

set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${CMAKE_CURRENT_SOURCE_DIR}/cmake")

SET(LIBRARY_OUTPUT_PATH "${PROJECT_BINARY_DIR}/lib")
set(EXECUTABLE_OUTPUT_PATH "${PROJECT_BINARY_DIR}/bin")

add_subdirectory(kernel)
add_subdirectory(gui)
add_subdirectory(sdk/procmonsdk)

if(BUILD_EXAMPLE)
    add_subdirectory(sdk/example)
endif()
```

`LICENSE`:

```
MIT License

Copyright (c) 2019 progmboy

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# Openprocmon
open source process monitor

## Menu

- [How to use](#how-to-use)
- [How to build](#how-to-build)
    - [Prepare the environment](#prepare-the-environment)
    - [Visual Studio](#visual-studio)
    - [CMake](#cmake)
- [SDK example](#sdk-example)
- [GUI Snapshot](#gui-snapshot)
- [How to show stackframe with symbol](#how-to-show-stackframe-with-symbol)
- [About another branch](#about-another-branch)
- [TODO](#todo)
    - [GUI](#gui)
    

## How to use

1. Use the procmon gui. (build and run procmon_gui.exe)
2. Use the sdk in you project(build and link sdk)
3. Hack the driver to implement your own EDR or something.

You don't have a digital signature yourself? It doesn't matter. You can use the original procmon driver, this sdk is 100% compatible with the original procmon driver.
And of course, The original procmon driver can be replaced with this driver to learn how procmon works.

## How to build

### Prepare the environment

**WDK**

Install the last [WDK](https://docs.microsoft.com/en-us/windows-hardware/drivers/download-the-wdk)

**WTL**

Download the last [WTL library](https://sourceforge.net/projects/wtl/) and put it in folder whatever you like. for example i put it in "D:\source\WTL10_9163"

### Visual Studio

1. Open procmon.sln use visual studio
2. change the addtion include directoy of procmon_gui from "D:\source\WTL10_9163\Include" to yours
3. build.
4. sign the driver or disable driver signature enforcement.
5. run.

### CMake

1. Install CMake.
2. Run cmake to generate the project
```
cmake .. -G "Visual Studio 16 2019" -A X64 -DWTL_ROOT_DIR=D:\source\WTL10_9163 -DWDK_WINVER=0x0A00
```
3. build
```
cmake --build . --config Release
```
4. sign the driver or disable driver signature enforcement.

**!!!Please note that I don't how to use the cmake to sign the driver with test signature. please do it yourself!!**

5. run


## SDK example

```cpp
#include <conio.h>
#include "../../sdk/procmonsdk/sdk.hpp"

class CMyEvent : public IEventCallback
{
public:
	virtual BOOL DoEvent(const CRefPtr<CEventView> pEventView)
	{

		ULONGLONG Time = pEventView->GetStartTime().QuadPart;

		LogMessage(L_INFO, TEXT("%llu Process %s Do 0x%x for %s"),
			Time,
			pEventView->GetProcessName().GetBuffer(),
			pEventView->GetEventOperator(),
			pEventView->GetPath().GetBuffer());
		return TRUE;
	}
};


int main()
{

	CEventMgr& Optmgr = Singleton<CEventMgr>::getInstance();
	CMonitorContoller& Monitormgr = Singleton<CMonitorContoller>::getInstance();
	CDrvLoader& Drvload = Singleton<CDrvLoader>::getInstance();
	
	if(!Drvload.Init(TEXT("PROCMON24"), TEXT("procmon.sys"))){
		return -1;
	}
	Optmgr.RegisterCallback(new CMyEvent);

	//
	// Try to connect to procmon driver
	//
	
	if (!Monitormgr.Connect()){
		LogMessage(L_ERROR, TEXT("Cannot connect to procmon driver"));
		return -1;
	}
	
	//
	// try to start monitor
	//
	
	Monitormgr.SetMonitor(TRUE, TRUE, FALSE);
	if (!Monitormgr.Start()){
		LogMessage(L_ERROR, TEXT("Cannot start the mointor"));
		return -1;
	}

	_getch();
	
	//
	// try to stop the monitor
	//
	
	Monitormgr.Stop();

	LogMessage(L_INFO, TEXT("!!!!!monitor stop press any key to start!!!!"));
	_getch();

	Monitormgr.Start();

	_getch();

	Monitormgr.Stop();
	Monitormgr.Destory();
	return 0;
}

```

It is pertty esay right?

## GUI Snapshot

**The GUI is still in Pre-Alpha state, and many features have yet to be improved. Wellcome PR.**

main window:

![main_window](https://github.com/progmboy/openprocmon/blob/master/images/mian_gui.png)

properties windows

![prop_event](https://github.com/progmboy/openprocmon/blob/master/images/prop_event.png)
![prop_proc](https://github.com/progmboy/openprocmon/blob/master/images/prop_proc.png)
![prop_stack](https://github.com/progmboy/openprocmon/blob/master/images/prop_stack.png)

## How to show stackframe with symbol

1. Go to windbg.exe directory copy the following files to the same directory with "procmon_gui.exe".
```
dbghelp.dll
symsrv.dll
symsrv.yes
```
2. Set the _NT_SYMBOL_PATH environment variable. for example:
```
srv*D:\reverse\symbols*https://msdl.microsoft.com/download/symbols
```

## About another branch
Discover it yourself!!!

## TODO
### GUI

- [x] ~~Filter dialog.~~
- [x] ~~Filter apply processing dialog.~~
- [ ] Save the capture log to file.
- [ ] Load capture log.
- [x] ~~Load Driver.~~
- [x] ~~Sybmol support for call stack view.~~
- [x] ~~Integrity level parse.~~
- [ ] Open registery event capture.
- [ ] Parse detail for File/Registery Event.
- [ ] Filter plugin support.
- [ ] Main menu message.
- [x] ~~Highlight support.~~
- [x] ~~filter mechanism~~

```

`cmake/FindWTL.cmake`:

```cmake
# Module for locating the Windows Template Library (WTL).
#
# Customizable variables:
#   WTL_ROOT_DIR
#     This variable points to the Windows Template Library root directory.
#
# Read-only variables:
#   WTL_FOUND
#     Indicates that the library has been found.
#
#   WTL_INCLUDE_DIRS
#     Points to the Windows Template Library include directory.
#
#
# Copyright (c) 2012 Sergiu Dotenco
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

INCLUDE (FindPackageHandleStandardArgs)

FIND_PACKAGE (WTL NO_MODULE QUIET)

FIND_PATH (WTL_ROOT_DIR
  NAMES include/atlapp.h
  PATHS ENV WTLROOT
  HINTS ${WTL_INCLUDE_DIR}/..
  DOC "WTL root directory")

FIND_PATH (WTL_INCLUDE_DIR
  NAMES atlapp.h
  HINTS ${WTL_ROOT_DIR}
  PATH_SUFFIXES include
  DOC "WTL include directory")

IF (WTL_INCLUDE_DIR)
  SET (_WTL_VERSION_HEADER ${WTL_INCLUDE_DIR}/atlapp.h)

  IF (EXISTS ${_WTL_VERSION_HEADER})
    FILE (STRINGS ${_WTL_VERSION_HEADER} _WTL_VERSION_TMP REGEX
      "WTL version[ \t]+[0-9]+(\\.[0-9]+)?")

    STRING (REGEX REPLACE
      ".*WTL version[ \t]+([0-9]+(\\.[0-9]+)?)" "\\1" _WTL_VERSION_TMP
      ${_WTL_VERSION_TMP})

    STRING (REGEX REPLACE "([0-9]+)(\\.[0-9]+)?" "\\1" WTL_VERSION_MAJOR
      ${_WTL_VERSION_TMP})
    STRING (REGEX REPLACE "[0-9]+(\\.([0-9]+))?" "\\2" WTL_VERSION_MINOR
      ${_WTL_VERSION_TMP})

    IF (${WTL_VERSION_MINOR} STREQUAL "")
      SET (WTL_VERSION ${WTL_VERSION_MAJOR}.0)
    ELSE (${WTL_VERSION_MINOR} STREQUAL "")
      SET (WTL_VERSION ${WTL_VERSION_MAJOR}.${WTL_VERSION_MINOR})
    ENDIF (${WTL_VERSION_MINOR} STREQUAL "")

    SET (WTL_VERSION_COUNT 2)
  ENDIF (EXISTS ${_WTL_VERSION_HEADER})

  SET (WTL_INCLUDE_DIRS ${WTL_INCLUDE_DIR})
ENDIF (WTL_INCLUDE_DIR)

MARK_AS_ADVANCED (WTL_INCLUDE_DIR)

FIND_PACKAGE_HANDLE_STANDARD_ARGS (WTL REQUIRED_VARS WTL_ROOT_DIR
  WTL_INCLUDE_DIR VERSION_VAR WTL_VERSION)

```

`cmake/FindWdk.cmake`:

```cmake
# Redistribution and use is allowed under the OSI-approved 3-clause BSD license.
# Copyright (c) 2018 Sergey Podobry (sergey.podobry at gmail.com). All rights reserved.

#.rst:
# FindWDK
# ----------
#
# This module searches for the installed Windows Development Kit (WDK) and 
# exposes commands for creating kernel drivers and kernel libraries.
#
# Output variables:
# - `WDK_FOUND` -- if false, do not try to use WDK
# - `WDK_ROOT` -- where WDK is installed
# - `WDK_VERSION` -- the version of the selected WDK
# - `WDK_WINVER` -- the WINVER used for kernel drivers and libraries 
#        (default value is `0x0601` and can be changed per target or globally)
#
# Example usage:
#
#   find_package(WDK REQUIRED)
#
#   wdk_add_library(KmdfCppLib STATIC KMDF 1.15
#       KmdfCppLib.h 
#       KmdfCppLib.cpp
#       )
#   target_include_directories(KmdfCppLib INTERFACE .)
#
#   wdk_add_driver(KmdfCppDriver KMDF 1.15
#       Main.cpp
#       )
#   target_link_libraries(KmdfCppDriver KmdfCppLib)
#

if(DEFINED ENV{WDKContentRoot})
    file(GLOB WDK_NTDDK_FILES
        "$ENV{WDKContentRoot}/Include/*/km/ntddk.h"
    )
else()
    file(GLOB WDK_NTDDK_FILES
        "C:/Program Files*/Windows Kits/10/Include/*/km/ntddk.h"
    )
endif()

if(WDK_NTDDK_FILES)
    list(GET WDK_NTDDK_FILES -1 WDK_LATEST_NTDDK_FILE)
endif()

include(FindPackageHandleStandardArgs)
find_package_handle_standard_args(WDK REQUIRED_VARS WDK_LATEST_NTDDK_FILE)

if (NOT WDK_LATEST_NTDDK_FILE)
    return()
endif()

get_filename_component(WDK_ROOT ${WDK_LATEST_NTDDK_FILE} DIRECTORY)
get_filename_component(WDK_ROOT ${WDK_ROOT} DIRECTORY)
get_filename_component(WDK_VERSION ${WDK_ROOT} NAME)
get_filename_component(WDK_ROOT ${WDK_ROOT} DIRECTORY)
get_filename_component(WDK_ROOT ${WDK_ROOT} DIRECTORY)

message(STATUS "WDK_ROOT: " ${WDK_ROOT})
message(STATUS "WDK_VERSION: " ${WDK_VERSION})

set(WDK_WINVER "0x0601" CACHE STRING "Default WINVER for WDK targets")

set(WDK_ADDITIONAL_FLAGS_FILE "${CMAKE_CURRENT_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/wdkflags.h")
file(WRITE ${WDK_ADDITIONAL_FLAGS_FILE} "#pragma runtime_checks(\"suc\", off)")

set(WDK_COMPILE_FLAGS
    "/Zp8" # set struct alignment
    "/GF"  # enable string pooling
    "/GR-" # disable RTTI
    "/Gz" # __stdcall by default
    "/kernel"  # create kernel mode binary
    "/FIwarning.h" # disable warnings in WDK headers
    "/FI${WDK_ADDITIONAL_FLAGS_FILE}" # include file to disable RTC
    )

set(WDK_COMPILE_DEFINITIONS "WINNT=1")
set(WDK_COMPILE_DEFINITIONS_DEBUG "MSC_NOOPT;DEPRECATE_DDK_FUNCTIONS=1;DBG=1")

if(CMAKE_SIZEOF_VOID_P EQUAL 4)
    list(APPEND WDK_COMPILE_DEFINITIONS "_X86_=1;i386=1;STD_CALL")
    set(WDK_PLATFORM "x86")
elseif(CMAKE_SIZEOF_VOID_P EQUAL 8)
    list(APPEND WDK_COMPILE_DEFINITIONS "_WIN64;_AMD64_;AMD64")
    set(WDK_PLATFORM "x64")
else()
    message(FATAL_ERROR "Unsupported architecture")
endif()

string(CONCAT WDK_LINK_FLAGS
    "/MANIFEST:NO " #
    "/DRIVER " #
    "/OPT:REF " #
    "/INCREMENTAL:NO " #
    "/OPT:ICF " #
    "/SUBSYSTEM:NATIVE " #
    "/MERGE:_TEXT=.text;_PAGE=PAGE " #
    "/NODEFAULTLIB " # do not link default CRT
    "/SECTION:INIT,d " #
    "/VERSION:10.0 " #
    )

# Generate imported targets for WDK lib files
file(GLOB WDK_LIBRARIES "${WDK_ROOT}/Lib/${WDK_VERSION}/km/${WDK_PLATFORM}/*.lib")    
foreach(LIBRARY IN LISTS WDK_LIBRARIES)
    get_filename_component(LIBRARY_NAME ${LIBRARY} NAME_WE)
    string(TOUPPER ${LIBRARY_NAME} LIBRARY_NAME)
    add_library(WDK::${LIBRARY_NAME} INTERFACE IMPORTED)
    set_property(TARGET WDK::${LIBRARY_NAME} PROPERTY INTERFACE_LINK_LIBRARIES  ${LIBRARY})
endforeach(LIBRARY)
unset(WDK_LIBRARIES)

function(wdk_add_driver _target)
    cmake_parse_arguments(WDK "" "KMDF;WINVER" "" ${ARGN})

    add_executable(${_target} ${WDK_UNPARSED_ARGUMENTS})

    set_target_properties(${_target} PROPERTIES SUFFIX ".sys")
    set_target_properties(${_target} PROPERTIES COMPILE_OPTIONS "${WDK_COMPILE_FLAGS}")
    set_target_properties(${_target} PROPERTIES COMPILE_DEFINITIONS
        "${WDK_COMPILE_DEFINITIONS};$<$<CONFIG:Debug>:${WDK_COMPILE_DEFINITIONS_DEBUG}>;_WIN32_WINNT=${WDK_WINVER}"
        )
    set_target_properties(${_target} PROPERTIES LINK_FLAGS "${WDK_LINK_FLAGS}")

    target_include_directories(${_target} SYSTEM PRIVATE
        "${WDK_ROOT}/Include/${WDK_VERSION}/shared"
        "${WDK_ROOT}/Include/${WDK_VERSION}/km"
        )

    target_link_libraries(${_target} WDK::NTOSKRNL WDK::HAL WDK::BUFFEROVERFLOWK WDK::WMILIB)

    if(CMAKE_SIZEOF_VOID_P EQUAL 4)
        target_link_libraries(${_target} WDK::MEMCMP)
    endif()

    if(DEFINED WDK_KMDF)
        target_include_directories(${_target} SYSTEM PRIVATE "${WDK_ROOT}/Include/wdf/kmdf/${WDK_KMDF}")
        target_link_libraries(${_target}
            "${WDK_ROOT}/Lib/wdf/kmdf/${WDK_PLATFORM}/${WDK_KMDF}/WdfDriverEntry.lib"
            "${WDK_ROOT}/Lib/wdf/kmdf/${WDK_PLATFORM}/${WDK_KMDF}/WdfLdr.lib"
            )

        if(CMAKE_SIZEOF_VOID_P EQUAL 4)
            set_property(TARGET ${_target} APPEND_STRING PROPERTY LINK_FLAGS "/ENTRY:FxDriverEntry@8")
        elseif(CMAKE_SIZEOF_VOID_P  EQUAL 8)
            set_property(TARGET ${_target} APPEND_STRING PROPERTY LINK_FLAGS "/ENTRY:FxDriverEntry")
        endif()
    else()
        if(CMAKE_SIZEOF_VOID_P EQUAL 4)
            set_property(TARGET ${_target} APPEND_STRING PROPERTY LINK_FLAGS "/ENTRY:GsDriverEntry@8")
        elseif(CMAKE_SIZEOF_VOID_P  EQUAL 8)
            set_property(TARGET ${_target} APPEND_STRING PROPERTY LINK_FLAGS "/ENTRY:GsDriverEntry")
        endif()
    endif()
endfunction()

function(wdk_add_library _target)
    cmake_parse_arguments(WDK "" "KMDF;WINVER" "" ${ARGN})

    add_library(${_target} ${WDK_UNPARSED_ARGUMENTS})

    set_target_properties(${_target} PROPERTIES COMPILE_OPTIONS "${WDK_COMPILE_FLAGS}")
    set_target_properties(${_target} PROPERTIES COMPILE_DEFINITIONS 
        "${WDK_COMPILE_DEFINITIONS};$<$<CONFIG:Debug>:${WDK_COMPILE_DEFINITIONS_DEBUG};_WIN32_WINNT=${WDK_WINVER}>"
        )

    target_include_directories(${_target} SYSTEM PRIVATE
        "${WDK_ROOT}/Include/${WDK_VERSION}/shared"
        "${WDK_ROOT}/Include/${WDK_VERSION}/km"
        )

    if(DEFINED WDK_KMDF)
        target_include_directories(${_target} SYSTEM PRIVATE "${WDK_ROOT}/Include/wdf/kmdf/${WDK_KMDF}")
    endif()
endfunction()
```

`gui/AboutDlg.h`:

```h
// aboutdlg.h : interface of the CAboutDlg class
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

class CAboutDlg : public CDialogImpl<CAboutDlg>
{
public:
	enum { IDD = IDD_ABOUTBOX };

	BEGIN_MSG_MAP(CAboutDlg)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		COMMAND_ID_HANDLER(IDOK, OnCloseCmd)
		COMMAND_ID_HANDLER(IDCANCEL, OnCloseCmd)
	END_MSG_MAP()

// Handler prototypes (uncomment arguments if needed):
//	LRESULT MessageHandler(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
//	LRESULT CommandHandler(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
//	LRESULT NotifyHandler(int /*idCtrl*/, LPNMHDR /*pnmh*/, BOOL& /*bHandled*/)

	LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		CenterWindow(GetParent());
		return TRUE;
	}

	LRESULT OnCloseCmd(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		EndDialog(wID);
		return 0;
	}
};

```

`gui/CMakeLists.txt`:

```txt
project(openprocmingui)

if (CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")
    set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} /MT")
    set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} /MTd")
endif()

add_definitions(-DUNICODE)
add_definitions(-D_UNICODE)

#add inc file search dir
INCLUDE_DIRECTORIES(
    "${OPENPROCMON_SOURCE_DIR}/sdk/procmonsdk"
)

find_package(WTL REQUIRED)
INCLUDE_DIRECTORIES(${WTL_INCLUDE_DIR})

file(GLOB GUI_HEADER *.h)
file(GLOB GUI_SOURCES *.cpp)
file(GLOB GUI_RC_SOURCES *.rc)

add_executable(openprocmingui 
    WIN32
    ${GUI_HEADER} 
    ${GUI_SOURCES} 
    ${GUI_RC_SOURCES}
)

set_target_properties(openprocmingui PROPERTIES LINK_FLAGS "/MANIFESTUAC:\"level='requireAdministrator' uiAccess='false'\"")
target_link_libraries(openprocmingui libprocmon)
```

`gui/MainFrm.h`:

```h
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

#include <vector>
#include <atltypes.h>
#include "filtermgr.h"
#include "dataview.h"

// #ifdef _DEBUG
// #pragma comment(lib, "../x64/Debug/procmonsdk.lib")
// #else
// #pragma comment(lib, "../x64/Release/procmonsdk.lib")
// #endif

#define WM_NEW_OPERATOR (WM_USER+1)
#define WM_CUSTOM_FILTER	(WM_USER+2)

#define ID_MEMU_PROPERTIES	(WM_USER+100)
#define ID_MEMU_STACK		(WM_USER+101)
#define ID_MEMU_BOOKMARK	(WM_USER+102)
#define ID_MEMU_JUMPTO		(WM_USER+103)

#define ID_MEMU_INCLUDE		(WM_USER+105)
#define ID_MEMU_HIGHLIGHT	(WM_USER+106)
#define ID_MEMU_EXCLUDE		(WM_USER+107)

typedef struct _ICONS
{
	HICON hSmall;
	HICON hLarge;
}ICONS, *PICONS;


HICON
UtilGetDefaultIcon(
	BOOL bSmall
)
{
	static ICONS hDefault = { 0 };
	if (!hDefault.hSmall || !hDefault.hLarge) {

		SHFILEINFO psfi = { 0 };

		//
		// small
		//

		DWORD_PTR dwRet = SHGetFileInfo(TEXT(".exe"), FILE_ATTRIBUTE_NORMAL,
			&psfi, sizeof(psfi),
			SHGFI_USEFILEATTRIBUTES | SHGFI_ICON | SHGFI_SMALLICON);

		hDefault.hSmall = psfi.hIcon;

		ZeroMemory(&psfi, sizeof(psfi));

		SHGetFileInfo(TEXT(".exe"), FILE_ATTRIBUTE_NORMAL,
			&psfi, sizeof(psfi),
			SHGFI_USEFILEATTRIBUTES | SHGFI_ICON | SHGFI_LARGEICON);

		hDefault.hLarge = psfi.hIcon;
	}

	if (bSmall){
		return hDefault.hSmall;
	}else{
		return hDefault.hLarge;
	}
}


class CMainFrame : 
	public CFrameWindowImpl<CMainFrame>, 
	public CUpdateUI<CMainFrame>,
	public CMessageFilter, public CIdleHandler,
	public IEventCallback
{
public:
	DECLARE_FRAME_WND_CLASS(NULL, IDR_MAINFRAME)

	CView m_view;
	CCommandBarCtrl m_CmdBar;

	virtual BOOL PreTranslateMessage(MSG* pMsg)
	{
		if(CFrameWindowImpl<CMainFrame>::PreTranslateMessage(pMsg))
			return TRUE;

		return m_view.PreTranslateMessage(pMsg);
	}

	virtual BOOL OnIdle()
	{
		m_view.SetItemCountEx((int)DATAVIEW().GetShowViewCounts(), LVSICF_NOINVALIDATEALL | LVSICF_NOSCROLL);
		if (m_bScrollDown){
			m_view.SendMessage(WM_VSCROLL, SB_BOTTOM, NULL);
		}

		//m_view.SendMessage(WM_VSCROLL, SB_BOTTOM, NULL);
		//m_view.EnsureVisible()
		UIUpdateToolBar();
		return FALSE;
	}

	BEGIN_UPDATE_UI_MAP(CMainFrame)
		UPDATE_ELEMENT(ID_VIEW_TOOLBAR, UPDUI_MENUPOPUP)
		UPDATE_ELEMENT(ID_VIEW_STATUS_BAR, UPDUI_MENUPOPUP)
	END_UPDATE_UI_MAP()

	BEGIN_MSG_MAP(CMainFrame)
		MESSAGE_HANDLER(WM_CREATE, OnCreate)
		MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
		MESSAGE_HANDLER(WM_NEW_OPERATOR, OnNewOperator)
		MESSAGE_HANDLER(WM_CUSTOM_FILTER, OnCustomFilter)
		COMMAND_ID_HANDLER(ID_APP_EXIT, OnFileExit)
		COMMAND_ID_HANDLER(ID_FILE_NEW, OnFileNew)
		COMMAND_ID_HANDLER(ID_VIEW_TOOLBAR, OnViewToolBar)
		COMMAND_ID_HANDLER(ID_VIEW_STATUS_BAR, OnViewStatusBar)
		COMMAND_ID_HANDLER(ID_APP_ABOUT, OnAppAbout)
		COMMAND_ID_HANDLER(ID_BUTTON_ICONS8_SAVE, OnFileSave)
		COMMAND_ID_HANDLER(ID_BUTTON_ICONS8_ERASE, OnEraseShow)
		COMMAND_ID_HANDLER(ID_BUTTON_ICONS8_START, OnMonitorStart)
		COMMAND_ID_HANDLER(ID_BUTTON_ICONS8_STOP, OnMonitorStop)
		COMMAND_ID_HANDLER(ID_BUTTON_ICONS8_OPENEDF, OnFileOpen)
		COMMAND_ID_HANDLER(ID_BUTTON_ICONS8_SCROLLDOWN, OnScrollDownClick)
		COMMAND_ID_HANDLER(ID_BUTTON_ICONS8_SCROLLUP, OnScrollUpClick)
		COMMAND_ID_HANDLER(ID_BUTTON_ICONS8_FILTER, OnFilterClick)
		COMMAND_ID_HANDLER(ID_BUTTON_ICONS8_PROCESS, OnFilterProcessClick)
		COMMAND_ID_HANDLER(ID_BUTTON_ICONS8_FILE, OnFilterFileClick)
		COMMAND_ID_HANDLER(ID_BUTTON_ICONS8_REGISTRY, OnFilterRegClick)

		COMMAND_ID_HANDLER(ID_MEMU_PROPERTIES, OnMenuProperties)
		COMMAND_ID_HANDLER(ID_MEMU_STACK, OnMenuStack)
		COMMAND_ID_HANDLER(ID_MEMU_JUMPTO, OnMenuJumpTo)
		COMMAND_ID_HANDLER(ID_MEMU_INCLUDE, OnMenuInclude)
		COMMAND_ID_HANDLER(ID_MEMU_EXCLUDE, OnMenuExclude)
		COMMAND_ID_HANDLER(ID_MEMU_HIGHLIGHT, OnMenuHighLight)
		
		NOTIFY_HANDLER(IDC_LISTCTRL, NM_RCLICK, NotifyRClickHandler)
		NOTIFY_HANDLER(IDC_LISTCTRL, LVN_GETDISPINFO, NotifyVDisplayHandler)
		NOTIFY_HANDLER(IDC_LISTCTRL, LVN_ITEMCHANGED, NotifyItemChangedHandler)
		NOTIFY_HANDLER(IDC_LISTCTRL, NM_CUSTOMDRAW, NotifyCustomDrawHandler)
		CHAIN_MSG_MAP(CUpdateUI<CMainFrame>)
		CHAIN_MSG_MAP(CFrameWindowImpl<CMainFrame>)
	END_MSG_MAP()

// Handler prototypes (uncomment arguments if needed):
//	LRESULT MessageHandler(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
//	LRESULT CommandHandler(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
//	LRESULT NotifyHandler(int /*idCtrl*/, LPNMHDR /*pnmh*/, BOOL& /*bHandled*/)

	LRESULT OnFileSave(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		MessageBox(TEXT("TODO"));
		return 0;
	}

	LRESULT OnFilterProcessClick(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		BOOL bShow = m_wndToolBar.IsButtonChecked(ID_BUTTON_ICONS8_PROCESS);

		if (bShow){
			DATAVIEW().RemoveFilter(new CFilter(emEventClass, emCMPIs, emRETExclude, StrMapClassEvent(MONITOR_TYPE_PROCESS)));
		}else{
			DATAVIEW().AddFilter(new CFilter(emEventClass, emCMPIs, emRETExclude, StrMapClassEvent(MONITOR_TYPE_PROCESS)));
		}

		CFltProcessDlg Dlg;
		Dlg.DoModal();

		m_view.SetItemCountEx((int)DATAVIEW().GetShowViewCounts(), 0);

		return 0;
	}

	LRESULT OnFilterFileClick(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		BOOL bShow = m_wndToolBar.IsButtonChecked(ID_BUTTON_ICONS8_FILE);

		if (bShow) {
			DATAVIEW().RemoveFilter(new CFilter(emEventClass, emCMPIs, emRETExclude, StrMapClassEvent(MONITOR_TYPE_FILE)));
		}else {
			DATAVIEW().AddFilter(new CFilter(emEventClass, emCMPIs, emRETExclude, StrMapClassEvent(MONITOR_TYPE_FILE)));
		}

		CFltProcessDlg Dlg;
		Dlg.DoModal();

		m_view.SetItemCountEx((int)DATAVIEW().GetShowViewCounts(), 0);

		return 0;
	}

	LRESULT OnFilterRegClick(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		BOOL bShow = m_wndToolBar.IsButtonChecked(ID_BUTTON_ICONS8_REGISTRY);

		if (bShow) {
			DATAVIEW().RemoveFilter(new CFilter(emEventClass, emCMPIs, emRETExclude, StrMapClassEvent(MONITOR_TYPE_REG)));
		}else{
			DATAVIEW().AddFilter(new CFilter(emEventClass, emCMPIs, emRETExclude, StrMapClassEvent(MONITOR_TYPE_REG)));
		}

		CFltProcessDlg Dlg;
		Dlg.DoModal();

		m_view.SetItemCountEx((int)DATAVIEW().GetShowViewCounts(), 0);

		return 0;
	}

	LRESULT OnFileOpen(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		MessageBox(TEXT("TODO"));
		return 0;
	}

	LRESULT OnFilterClick(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		CFilterDlg Dlg;
		Dlg.DoModal();
		return 0;
	}

	LRESULT OnScrollDownClick(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		m_wndToolBar.HideButton(ID_BUTTON_ICONS8_SCROLLUP, FALSE);
		m_wndToolBar.HideButton(ID_BUTTON_ICONS8_SCROLLDOWN, TRUE);

		m_bScrollDown = TRUE;
		return 0;
	}

	LRESULT OnScrollUpClick(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		m_wndToolBar.HideButton(ID_BUTTON_ICONS8_SCROLLUP, TRUE);
		m_wndToolBar.HideButton(ID_BUTTON_ICONS8_SCROLLDOWN, FALSE);

		m_bScrollDown = FALSE;
		return 0;
	}


	LRESULT OnMonitorStart(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		m_wndToolBar.HideButton(ID_BUTTON_ICONS8_START, TRUE);
		m_wndToolBar.HideButton(ID_BUTTON_ICONS8_STOP, FALSE);
		MONITORMGR().Start();
		return 0;
	}

	LRESULT OnMonitorStop(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		m_wndToolBar.HideButton(ID_BUTTON_ICONS8_START, FALSE);
		m_wndToolBar.HideButton(ID_BUTTON_ICONS8_STOP, TRUE);
		MONITORMGR().Stop();
		return 0;
	}


	LRESULT OnEraseShow(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		DATAVIEW().ClearShowViews();
		m_view.SetItemCountEx((int)DATAVIEW().GetShowViewCounts(), 0);
		return 0;
	}

	LRESULT OnMenuProperties(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		CPropertiesDlg ProperiesDlg;
		ProperiesDlg.DoModal();
		return 0;
	}

	LRESULT OnMenuStack(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		CPropertiesDlg ProperiesDlg;
		ProperiesDlg.PreSetCurTab(2);
		ProperiesDlg.DoModal();
		return 0;
	}

	LRESULT OnMenuJumpTo(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		if (m_nListClickItem != -1){

			CString strPath;
			m_view.GetItemText(m_nListClickItem, 5, strPath);

			if (!strPath.IsEmpty()){

				CString strSelect;
				strSelect.Format(TEXT("/select,%s"), strPath.GetBuffer());
				ShellExecute(NULL, TEXT("open"), TEXT("explorer.exe"), strSelect, NULL, SW_SHOWNORMAL);
			}
			
		}
		return 0;
	}
	
	MAP_SOURCE_TYPE MapSubItemToSrcType(int nSubItem)
	{
		MAP_SOURCE_TYPE SrcType;
		switch (m_nListClickSubItem)
		{
		case 1:
			SrcType = emTimeOfDay;
			break;
		case 2:
			SrcType = emProcessName;
			break;
		case 3:
			SrcType = emPID;
			break;
		case 4:
			SrcType = emOperation;
			break;
		case 5:
			SrcType = emPath;
			break;
		case 6:
			SrcType = emResult;
			break;
		case 7:
			SrcType = emDetail;
			break;
		default:
			SrcType = emInvalid;
			break;
		}

		return SrcType;
	}

	LRESULT OnMenuInclude(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		if (m_nListClickItem != -1 && m_nListClickSubItem != -1){

			MAP_SOURCE_TYPE SrcType = MapSubItemToSrcType(m_nListClickSubItem);

			if (SrcType != emInvalid){

				CString strDst;
				m_view.GetItemText(m_nListClickItem, m_nListClickSubItem, strDst);

				if (!strDst.IsEmpty()){
					DATAVIEW().AddFilter(new CFilter(SrcType, emCMPIs, emRETInclude, strDst));

					CFltProcessDlg Dlg;
					Dlg.DoModal();
					
					//
					// Redraw
					//
					
					m_view.SetItemCountEx((int)DATAVIEW().GetShowViewCounts(), 0);
				}
			}
		}
		
		return 0;
	}
		
	LRESULT OnMenuExclude(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		if (m_nListClickItem != -1 && m_nListClickSubItem != -1) {

			MAP_SOURCE_TYPE SrcType = MapSubItemToSrcType(m_nListClickSubItem);
			if (SrcType != emInvalid) {

				CString strDst;
				m_view.GetItemText(m_nListClickItem, m_nListClickSubItem, strDst);

				if (!strDst.IsEmpty()) {
					DATAVIEW().AddFilter(new CFilter(SrcType, emCMPIs, emRETExclude, strDst));
					CFltProcessDlg Dlg;
					Dlg.DoModal();
					
					//
					// Redraw
					//
					
					m_view.SetItemCountEx((int)DATAVIEW().GetShowViewCounts(), 0);
				}
			}
		}
		return 0;
	}

	LRESULT OnMenuHighLight(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		if (m_nListClickItem != -1 && m_nListClickSubItem != -1) {

			MAP_SOURCE_TYPE SrcType = MapSubItemToSrcType(m_nListClickSubItem);
			if (SrcType != emInvalid) {

				CString strDst;
				m_view.GetItemText(m_nListClickItem, m_nListClickSubItem, strDst);

				if (!strDst.IsEmpty()) {
					DATAVIEW().AddHighLightFilter(new CFilter(SrcType, emCMPIs, emRETInclude, strDst));
					
					//
					// Redraw
					//
					
					m_view.SetItemCountEx((int)DATAVIEW().GetShowViewCounts(), 0);
				}
			}
		}
		return 0;
	}

	int GetProcessIconIndex(CRefPtr<CEventView> pEventView)
	{
		DWORD dwProcSeq = pEventView->GetProcessSeq();
		int nImageIndex = -1;
		auto it = m_ImageMap.find(dwProcSeq);
		if (it != m_ImageMap.end()) {
			nImageIndex = it->second;
		}else {

			//
			// get image and add to map
			//

			CBuffer& clsIconBuffer = pEventView->GetProcIcon(TRUE);

			if (!clsIconBuffer.Empty()) {
				
				//
				// Load from memory
				//

				HICON hIcon = CreateIconFromResourceEx(clsIconBuffer.GetBuffer(), 
					clsIconBuffer.GetBufferLen(), TRUE, 0x30000, 16, 16, 0);
				if (hIcon){
					nImageIndex = m_clsImageList.AddIcon(hIcon);
					DestroyIcon(hIcon);

					//
					// insert it
					//

					m_ImageMap.insert(std::make_pair(dwProcSeq, nImageIndex));
				}
			}
			
			if(nImageIndex == -1){
				nImageIndex = m_DefaultAppIcon;
				m_ImageMap.insert(std::make_pair(dwProcSeq, m_DefaultAppIcon));
			}
		}

		return nImageIndex;
	}

	LRESULT NotifyVDisplayHandler(int /*idCtrl*/, LPNMHDR pnmh, BOOL& bHandled)
	{
		NMLVDISPINFO* pDispInfo = reinterpret_cast<NMLVDISPINFO*>(pnmh);
		LVITEM* pItem = &pDispInfo->item;

		int iItem = pItem->iItem;

		CRefPtr<CEventView> pEventView = DATAVIEW().GetView(iItem);
		if (pEventView.IsNull()){
			return 0;
		}

		if (pItem->mask & LVIF_TEXT)
		{
			switch (pItem->iSubItem)
			{
				case 0:
					break;
				case 1: 	
				{
					//
					// Time of day
					//

					CString strTimeOfDay = UtilConvertTimeOfDay(pEventView->GetStartTime());
					StringCchCopy(pItem->pszText, pItem->cchTextMax, strTimeOfDay);
				}

					break;
				case 2: 
				{
					CString strProcessImage = pEventView->GetImagePath();

					if (pItem->mask & LVIF_IMAGE)
					{
						pItem->iImage = GetProcessIconIndex(pEventView);
					}

					StringCchCopy(pItem->pszText, pItem->cchTextMax, pEventView->GetProcessName());
				}
					break;
				case 3:
				{
					CString strPid;
					strPid.Format(TEXT("%d"), pEventView->GetProcessId());
					StringCchCopy(pItem->pszText, pItem->cchTextMax, strPid);
				}
					break;
				case 4:
				{
					DWORD dwClass = pEventView->GetEventClass();
					DWORD dwOperator = pEventView->GetEventOperator();

					CString strOperator;
					LPCTSTR lpOPt = StrMapOperation(pEventView->GetPreEventEntry());
					if (!lpOPt){
						strOperator.Format(TEXT("%d:%d"), dwClass, dwOperator);
					}else{
						strOperator = lpOPt;
					}

					if (pItem->mask & LVIF_IMAGE)
					{
						switch (dwClass)
						{
						case MONITOR_TYPE_FILE:
							pItem->iImage = m_IconFile;
							break;
						case MONITOR_TYPE_PROCESS:
							pItem->iImage = m_IconProcess;
							break;
						case MONITOR_TYPE_REG:
							pItem->iImage = m_IconReg;
							break;
						default:
							break;
						}
					}

					StringCchCopy(pItem->pszText, pItem->cchTextMax, strOperator);
				}
					break;
				case 5:
				{
					StringCchCopy(pItem->pszText, pItem->cchTextMax, pEventView->GetPath());
				}
					break;
				case 6:
				{
					CString strResult;
					LPCTSTR lpDesc = StrMapNtStatus(pEventView->GetResult());

					if (lpDesc){
						strResult = lpDesc;
					}else{
						strResult.Format(TEXT("0x%08x"), pEventView->GetResult());
					}
					
					StringCchCopy(pItem->pszText, pItem->cchTextMax, strResult);
				}
					break;
				case 7:
				{
					StringCchCopy(pItem->pszText, pItem->cchTextMax, pEventView->GetDetail());
				}
					break;
			}
		}
		return 0;
	}

	LRESULT NotifyItemChangedHandler(int /*idCtrl*/, LPNMHDR pnmh, BOOL& bHandled)
	{
		LPNMLISTVIEW pnmv = reinterpret_cast<LPNMLISTVIEW>(pnmh);
		if (pnmv->uNewState & LVIS_SELECTED){
			DATAVIEW().SetSelectIndex(pnmv->iItem);
		}
		return 0;
	}

	LRESULT NotifyCustomDrawHandler(int /*idCtrl*/, LPNMHDR pnmh, BOOL& bHandled)
	{
		LPNMLVCUSTOMDRAW pLVNMCD = reinterpret_cast<LPNMLVCUSTOMDRAW>(pnmh);
		int nResult = CDRF_DODEFAULT;
		if (CDDS_PREPAINT == pLVNMCD->nmcd.dwDrawStage)
		{
			nResult = CDRF_NOTIFYITEMDRAW;
		}
		else if (CDDS_ITEMPREPAINT == pLVNMCD->nmcd.dwDrawStage)
		{
			nResult = CDRF_NOTIFYSUBITEMDRAW;
			size_t dwItem = (size_t)pLVNMCD->nmcd.dwItemSpec;
			BOOL b = DATAVIEW().IsHighlight(dwItem);
			if (b) {
				pLVNMCD->clrTextBk = m_HighlightColor;
			}

		}
		return nResult;
	}

	void SetItemClickInfo(int nItem, int nSubItem)
	{
		m_nListClickItem = nItem;
		m_nListClickSubItem = nSubItem;
	}

	LRESULT NotifyRClickHandler(int /*idCtrl*/, LPNMHDR pnmh, BOOL& bHandled)
	{
		LPNMITEMACTIVATE pNMItemActivate = reinterpret_cast<LPNMITEMACTIVATE>(pnmh);

		if (pNMItemActivate->iItem != -1){

			SetItemClickInfo(pNMItemActivate->iItem, pNMItemActivate->iSubItem);

			//
			// Create Popup menu
			//
			
			CMenu clsMenu = CreatePopupMenu();
			
			//
			// Properties
			//
			
			clsMenu.AppendMenu(MF_STRING, ID_MEMU_PROPERTIES,TEXT("Properties..."));
			clsMenu.SetMenuDefaultItem(ID_MEMU_PROPERTIES);
			clsMenu.AppendMenu(MF_STRING, ID_MEMU_STACK, TEXT("Stack..."));
			clsMenu.AppendMenu(MF_STRING, ID_MEMU_BOOKMARK, TEXT("Toggle Bookmark"));
			clsMenu.AppendMenu(MF_STRING, ID_MEMU_JUMPTO, TEXT("Jump to..."));

			clsMenu.AppendMenu(MF_SEPARATOR);
			
			//
			// Add Include exclude menu
			//
			
			TCHAR szColumName[260] = { 0 };
			LVCOLUMN Colum = {0};
			Colum.mask = LVCF_TEXT;
			Colum.pszText = szColumName;
			Colum.cchTextMax = 260;

			if (m_view.GetColumn(pNMItemActivate->iSubItem, &Colum)){
				CString strColumText = Colum.pszText;
				
				if (!strColumText.IsEmpty()){
					
					//
					// Get item text
					//

					CString strMenu;
					CString strItem;
					m_view.GetItemText(pNMItemActivate->iItem, pNMItemActivate->iSubItem, strItem);
					
					if (strItem.GetLength() > 50){
						strItem = strItem.Left(50);
						strItem += TEXT("...");
					}

					strMenu.Format(TEXT("Include \'%s\'"), strItem.GetBuffer());
					clsMenu.AppendMenu(MF_STRING, ID_MEMU_INCLUDE, strMenu);

					strMenu.Format(TEXT("HighLight \'%s\'"), strItem.GetBuffer());
					clsMenu.AppendMenu(MF_STRING, ID_MEMU_HIGHLIGHT, strMenu);

					strMenu.Format(TEXT("Exclude \'%s\'"), strItem.GetBuffer());
					clsMenu.AppendMenu(MF_STRING, ID_MEMU_EXCLUDE, strMenu);
				}
			}


			//
			// Show menu
			//

			DWORD dwPos = GetMessagePos();
			clsMenu.TrackPopupMenu(TPM_LEFTALIGN, LOWORD(dwPos), HIWORD(dwPos), this->m_hWnd);

		}

		return TRUE;
	}

	LRESULT OnNewOperator(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
		//m_view.SetItemCountEx((int)m_ShowViews.size(), LVSICF_NOINVALIDATEALL| LVSICF_NOSCROLL);
		bHandled = TRUE;
		return 0;
	}
	LRESULT OnCustomFilter(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
		//m_view.SetItemCountEx((int)m_ShowViews.size(), LVSICF_NOINVALIDATEALL| LVSICF_NOSCROLL);
		CFltProcessDlg Dlg;
		Dlg.DoModal();

		m_view.SetItemCountEx((int)DATAVIEW().GetShowViewCounts(), 0);
		return 0;
	}

	LRESULT OnCreate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{

		CDrvLoader& Drvload = Singleton<CDrvLoader>::getInstance();
		CEventMgr& Optmgr = Singleton<CEventMgr>::getInstance();
		CMonitorContoller& Monitormgr = Singleton<CMonitorContoller>::getInstance();

		Drvload.Init(TEXT("PROCMON24"), TEXT("procmon.sys"));

		//
		// create command bar window
		//

		HWND hWndCmdBar = m_CmdBar.Create(m_hWnd, rcDefault, NULL, ATL_SIMPLE_CMDBAR_PANE_STYLE);
		
		//
		// attach menu
		//

		m_CmdBar.AttachMenu(GetMenu());
		
		//
		// load command bar images
		//

		m_CmdBar.LoadImages(/*IDR_MAINFRAME*/IDR_TOOL);
		
		//
		// remove old menu
		//

		SetMenu(NULL);

		m_wndToolBar = CreateSimpleToolBarCtrl(m_hWnd, IDR_TOOL, FALSE, ATL_SIMPLE_TOOLBAR_PANE_STYLE);


		m_wndToolBar.HideButton(ID_BUTTON_ICONS8_STOP, FALSE);
		m_wndToolBar.HideButton(ID_BUTTON_ICONS8_START, TRUE);

		m_wndToolBar.HideButton(ID_BUTTON_ICONS8_SCROLLUP, TRUE);
		m_wndToolBar.HideButton(ID_BUTTON_ICONS8_SCROLLDOWN, FALSE);
		
		//
		// Set button style to check button
		//
		
		TBBUTTONINFO tbButtonInfo;
		tbButtonInfo.cbSize = sizeof(tbButtonInfo);
		tbButtonInfo.dwMask = TBIF_STYLE;
		m_wndToolBar.GetButtonInfo(ID_BUTTON_ICONS8_PROCESS, &tbButtonInfo);

		tbButtonInfo.fsStyle = BTNS_CHECK;
		m_wndToolBar.SetButtonInfo(ID_BUTTON_ICONS8_PROCESS, &tbButtonInfo);
		m_wndToolBar.SetButtonInfo(ID_BUTTON_ICONS8_REGISTRY, &tbButtonInfo);
		m_wndToolBar.SetButtonInfo(ID_BUTTON_ICONS8_FILE, &tbButtonInfo);

		m_wndToolBar.CheckButton(ID_BUTTON_ICONS8_PROCESS);
		m_wndToolBar.CheckButton(ID_BUTTON_ICONS8_FILE);

		//
		// set default all on
		//
		


		CreateSimpleReBar(ATL_SIMPLE_REBAR_NOBORDER_STYLE);
		AddSimpleReBarBand(hWndCmdBar);
		AddSimpleReBarBand(m_wndToolBar, NULL, TRUE);


		CreateSimpleStatusBar();
		DWORD SmallX = GetSystemMetrics(SM_CXSMICON);
		DWORD SmallY = GetSystemMetrics(SM_CYSMICON); 

		m_clsImageList.Create(SmallX, SmallY, 0xFF, 256, 256);

		m_hWndClient = m_view.Create(m_hWnd, rcDefault, NULL, WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | \
			WS_CLIPCHILDREN | LVS_REPORT | LVS_SHOWSELALWAYS | LVS_OWNERDATA, 
			WS_EX_CLIENTEDGE, IDC_LISTCTRL);
		
		//
		// Add column for list view
		//
		
		m_view.SetImageList(m_clsImageList, LVSIL_SMALL);
		m_view.SetExtendedListViewStyle(LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP | LVS_EX_SUBITEMIMAGES | LVS_EX_DOUBLEBUFFER);

		int n = 1;

		m_view.InsertColumn(0, TEXT("Fake"), 0, 0);
		m_view.InsertColumn(n++, TEXT("Time"), 0, 170);
		m_view.InsertColumn(n++, TEXT("Process Name"), 0, 280);
		m_view.InsertColumn(n++, TEXT("PID"), 0, 80);
		m_view.InsertColumn(n++, TEXT("Operation"), 0, 200);
		m_view.InsertColumn(n++, TEXT("Path"), 0, 380);	
		m_view.InsertColumn(n++, TEXT("Result"), 0, 180);
		m_view.InsertColumn(n++, TEXT("Detail"), 0, 180);

		HICON hDefault = UtilGetDefaultIcon(TRUE);
		if(hDefault){
			m_DefaultAppIcon = m_clsImageList.AddIcon(hDefault);
		}

		CIcon IcoProcess;
		IcoProcess.LoadIcon(IDI_ICON_PROCESS);
		m_IconProcess = m_clsImageList.AddIcon(IcoProcess);

		CIcon IcoFile;
		IcoFile.LoadIcon(IDI_ICON_FILE);
		m_IconFile = m_clsImageList.AddIcon(IcoFile);

		CIcon IcoReg;
		IcoReg.LoadIcon(IDI_ICON_REGISTERY);
		m_IconReg = m_clsImageList.AddIcon(IcoReg);

		UIAddToolBar(m_wndToolBar);
		UISetCheck(ID_VIEW_TOOLBAR, 1);
		UISetCheck(ID_VIEW_STATUS_BAR, 1);

		//
		// register object for message filtering and idle updates
		//

		CMessageLoop* pLoop = _Module.GetMessageLoop();
		ATLASSERT(pLoop != NULL);
		pLoop->AddMessageFilter(this);
		pLoop->AddIdleHandler(this);

		if (Monitormgr.Connect()) {
			
			//
			// register call back
			//
			
			Optmgr.RegisterCallback(this);
			Monitormgr.SetMonitor(TRUE, TRUE, FALSE);

			//
			// start
			//
			
			Monitormgr.Start();
		}else{
			MessageBox(TEXT("Failed to connect driver"), TEXT("Failed"), MB_OK | MB_ICONERROR);
		}

		return 0;
	}

	LRESULT OnDestroy(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		//
		// unregister message filtering and idle updates
		//

		CMessageLoop* pLoop = _Module.GetMessageLoop();
		ATLASSERT(pLoop != NULL);
		pLoop->RemoveMessageFilter(this);
		pLoop->RemoveIdleHandler(this);

		bHandled = FALSE;

		MONITORMGR().Stop();
		MONITORMGR().Destory();

		return 1;
	}

	LRESULT OnFileExit(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		PostMessage(WM_CLOSE);
		return 0;
	}

	LRESULT OnFileNew(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		// TODO: add code to initialize document

		return 0;
	}

	LRESULT OnViewToolBar(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		static BOOL bVisible = TRUE;	// initially visible
		bVisible = !bVisible;
		CReBarCtrl rebar = m_hWndToolBar;
		int nBandIndex = rebar.IdToIndex(ATL_IDW_BAND_FIRST + 1);	// toolbar is 2nd added band
		rebar.ShowBand(nBandIndex, bVisible);
		UISetCheck(ID_VIEW_TOOLBAR, bVisible);
		UpdateLayout();
		return 0;
	}

	LRESULT OnViewStatusBar(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		BOOL bVisible = !::IsWindowVisible(m_hWndStatusBar);
		::ShowWindow(m_hWndStatusBar, bVisible ? SW_SHOWNOACTIVATE : SW_HIDE);
		UISetCheck(ID_VIEW_STATUS_BAR, bVisible);
		UpdateLayout();
		return 0;
	}

	LRESULT OnAppAbout(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		CAboutDlg dlg;
		dlg.DoModal();
		return 0;
	}

	virtual BOOL DoEvent(CRefPtr<CEventView> pEventView)
	{
		DATAVIEW().Push(pEventView);
		return TRUE;
	}

	void SetHighLightColor(DWORD dwColor)
	{
		m_HighlightColor = dwColor;
	}

private:
	CImageList m_clsImageList;
	std::map<DWORD, int> m_ImageMap;
	int m_DefaultAppIcon = 0;
	CToolBarCtrl m_wndToolBar;

	int m_IconProcess = 0;
	int m_IconFile = 0;
	int m_IconReg = 0;

	BOOL m_bScrollDown = FALSE;

	int m_nListClickItem = -1;
	int m_nListClickSubItem = -1;

	DWORD m_HighlightColor = RGB(51, 247, 255);
};

```

`gui/View.h`:

```h
// View.h : interface of the CView class
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

#include <atlstr.h>

class CView : public CWindowImpl<CView, CListViewCtrl>
{
public:
	DECLARE_WND_SUPERCLASS(NULL, CListViewCtrl::GetWndClassName())

	BOOL PreTranslateMessage(MSG* pMsg)
	{
		pMsg;
		return FALSE;
	}

	BEGIN_MSG_MAP(CView)
	END_MSG_MAP()

// Handler prototypes (uncomment arguments if needed):
//	LRESULT MessageHandler(UINT uMsg, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
//	LRESULT CommandHandler(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
//	LRESULT NotifyHandler(int /*idCtrl*/, LPNMHDR pnmh, BOOL& /*bHandled*/);
};

```

`gui/dataview.cpp`:

```cpp

#include "stdafx.h"
#include "dataview.h"
#include "filtermgr.h"

CDataView::CDataView()
{
	m_Filter.AddFilter(emPath, emCMPContains, emRETExclude, TEXT("$Extend"));
	m_Filter.AddFilter(emPath, emCMPEndWith, emRETExclude, TEXT("$UpCase"));
	m_Filter.AddFilter(emPath, emCMPEndWith, emRETExclude, TEXT("$Secure"));
	m_Filter.AddFilter(emPath, emCMPEndWith, emRETExclude, TEXT("$BadClus"));
	m_Filter.AddFilter(emPath, emCMPEndWith, emRETExclude, TEXT("$Boot"));
	m_Filter.AddFilter(emPath, emCMPEndWith, emRETExclude, TEXT("$Bitmap"));
	m_Filter.AddFilter(emPath, emCMPEndWith, emRETExclude, TEXT("$Root"));
	m_Filter.AddFilter(emPath, emCMPEndWith, emRETExclude, TEXT("$AttrDef"));
	m_Filter.AddFilter(emPath, emCMPEndWith, emRETExclude, TEXT("$Volume"));
	m_Filter.AddFilter(emPath, emCMPEndWith, emRETExclude, TEXT("$LogFile"));
	m_Filter.AddFilter(emPath, emCMPEndWith, emRETExclude, TEXT("$MftMirr"));
	m_Filter.AddFilter(emPath, emCMPEndWith, emRETExclude, TEXT("$Mft"));
	m_Filter.AddFilter(emPath, emCMPEndWith, emRETExclude, TEXT("pagefile.sys"));
	m_Filter.AddFilter(emResult, emCMPEndWith, emRETExclude, TEXT("FAST_IO"));
	m_Filter.AddFilter(emOperation, emCMPBeginWith, emRETExclude, TEXT("FASTIO_"));
	m_Filter.AddFilter(emOperation, emCMPBeginWith, emRETExclude, TEXT("IRP_MJ_"));
	m_Filter.AddFilter(emProcessName, emCMPIs, emRETExclude, TEXT("system"));

	//m_Filter.AddFilter(emProcessName, emCMPIs, emRETInclude, TEXT("notepad.exe"));
	//m_Filter.AddFilter(emProcessName, emCMPIs, emRETInclude, TEXT("pdbex.exe"));

	TCHAR szPath[MAX_PATH];
	GetModuleFileName(NULL, szPath, MAX_PATH);
	LPCTSTR lpAppName = PathFindFileName(szPath);

	m_Filter.AddFilter(emProcessName, emCMPIs, emRETExclude, lpAppName);
}

CDataView::~CDataView()
{

}

void CDataView::SetSelectIndex(size_t Index)
{
	m_SelectIndex = Index;
}

size_t CDataView::GetSelectIndex()
{
	return m_SelectIndex;
}

BOOL CDataView::IsHighlight(size_t Index)
{
#if 0
	CRefPtr<CEventViewExt> pExt = _Get(Index);
	if (!pExt.IsNull())
		return pExt->IsHighLight();
	else
		return FALSE;
#endif

	CRefPtr<CEventViewExt> pExt = _Get(Index);
	if (!pExt.IsNull()) {
		if (pExt->IsHighLight()){
			return TRUE;
		}else{
			
			//
			// check highlight filter
			//

			if(m_HighLightFilter.GetCounts()){
				if (!m_HighLightFilter.Filter(pExt->GetView())) {
					return TRUE;
				}
			}
		}
	}	
	return FALSE;
}

CRefPtr<CEventView> CDataView::GetSelectView()
{
	return GetView(m_SelectIndex);
}

CRefPtr<CEventView> CDataView::GetView(size_t Index)
{
	CRefPtr<CEventViewExt> pExt = _Get(Index);
	if (!pExt.IsNull())
		return pExt->GetView();
	else
		return NULL;
}

CRefPtr<CEventViewExt> CDataView::_Get(size_t Index)
{
	std::shared_lock<std::shared_mutex> lock(m_Viewlock);
	if (Index >= m_ShowViews.size()) {
		return NULL;
	}

	return m_ShowViews.at(Index);
}

size_t CDataView::GetShowViewCounts()
{
	return m_ShowViews.size();
}

void CDataView::ClearShowViews()
{
	std::unique_lock<std::shared_mutex> lock(m_Viewlock);
	m_ShowViews.clear();
}

void CDataView::Push(CRefPtr<CEventView> pOpt)
{
	
	//
	// do not process process init message
	//
	
	if (pOpt->GetEventClass() == MONITOR_TYPE_PROCESS &&
		pOpt->GetEventOperator() == NOTIFY_PROCESS_INIT){
		return;
	}


	BOOL bHighLight = FALSE;
	CRefPtr<CEventViewExt> pOptEx = new CEventViewExt(pOpt, bHighLight);
	
	m_OptViewlock.lock();
	m_OptViews.push_back(pOptEx);
	m_OptViewlock.unlock();

	//
	// Is filtered?
	//
	
	if (!m_Filter.Filter(pOpt)){

		m_Viewlock.lock();
		m_ShowViews.push_back(pOptEx);
		m_Viewlock.unlock();
	}
}

void CDataView::AddFilter(CRefPtr<CFilter> pFilter)
{
	m_Filter.AddFilter(pFilter);
}

void CDataView::AddHighLightFilter(CRefPtr<CFilter> pFilter)
{
	m_HighLightFilter.AddFilter(pFilter);
}

void CDataView::RemoveFilter(CRefPtr<CFilter> pFilter)
{
	m_Filter.RemovFilter(pFilter);
}

void CDataView::RemoveHighLightFilter(CRefPtr<CFilter> pFilter)
{
	m_HighLightFilter.RemovFilter(pFilter);
}

void CDataView::ApplyNewFilter(FLTPROCGRESSCB Callback, LPVOID pParameter)
{
	ClearShowViews();
	
	std::unique_lock<std::shared_mutex> lock(m_OptViewlock);

	size_t Total = m_OptViews.size();
	size_t Now = 0;

	if (Callback) {
		Callback(Total, Now, pParameter);
	}

	for (auto it = m_OptViews.begin(); it != m_OptViews.end(); it++, Now++)
	{
		if (!m_Filter.Filter((*it)->GetView())){
			m_Viewlock.lock();
			m_ShowViews.push_back(*it);
			m_Viewlock.unlock();

			if (Callback){
				Callback(Total, Now, pParameter);
			}
		}
	}
}

CFilterMgr& CDataView::GetFilterMgr()
{
	return m_Filter;
}

```

`gui/dataview.h`:

```h
#pragma once

#include <vector>
#include <shared_mutex>
#include "filtermgr.h"

#define DATAVIEW()  Singleton<CDataView>::getInstance()

typedef VOID (*FLTPROCGRESSCB)(size_t Total, size_t Current, PVOID pParameter);

class CEventViewExt : public CRefBase
{
public:
	CEventViewExt(CRefPtr<CEventView> pOpt):
		m_EventView(pOpt),
		m_bHighLight(FALSE)
	{
	
	}

	CEventViewExt(CRefPtr<CEventView> pOpt, BOOL bH) :
		m_EventView(pOpt),
		m_bHighLight(bH)
	{

	}

	~CEventViewExt()
	{
	
	}

	VOID SetHighLight(BOOL bHighLigt)
	{
		m_bHighLight = bHighLigt;
	}

	BOOL IsHighLight()
	{
		return m_bHighLight;
	}

	CRefPtr<CEventView> GetView()
	{
		return m_EventView;
	}

private:
	CRefPtr<CEventView> m_EventView;
	BOOL m_bHighLight;
};

class CDataView
{
public:
	CDataView();
	~CDataView();

public:

	void SetSelectIndex(size_t Index);
	size_t GetSelectIndex();
	BOOL IsHighlight(size_t Index);
	CRefPtr<CEventView> GetSelectView();
	CRefPtr<CEventView> GetView(size_t Index);
	CRefPtr<CEventViewExt> _Get(size_t Index);
	size_t GetShowViewCounts();
	void ClearShowViews();
	void Push(CRefPtr<CEventView> pOpt);
	void AddFilter(CRefPtr<CFilter> pFilter);
	void AddHighLightFilter(CRefPtr<CFilter> pFilter);
	void RemoveFilter(CRefPtr<CFilter> pFilter);
	void RemoveHighLightFilter(CRefPtr<CFilter> pFilter);
	void ApplyNewFilter(FLTPROCGRESSCB Callback=NULL, LPVOID pParameter = NULL);
	CFilterMgr& GetFilterMgr();

private:

	size_t m_SelectIndex = 0;

	//
	// 这里保存了所有的消息
	//

	std::vector<CRefPtr<CEventViewExt>> m_OptViews;

	//
	// 这里只保存需要显示的消息
	//

	std::vector<CRefPtr<CEventViewExt>> m_ShowViews;
	std::shared_mutex m_Viewlock;
	std::shared_mutex m_OptViewlock;
	CFilterMgr m_Filter;
	CFilterMgr m_HighLightFilter;
};
```

`gui/filter.cpp`:

```cpp


#include "stdafx.h"
#include "filter.hpp"

CFilter::CFilter(
	MAP_SOURCE_TYPE Src, 
	FILTER_CMP_TYPE Cmp, 
	FILTER_RESULT_TYPE Ret, 
	const CString& strFilter,
	BOOL Enable
):m_SrcType(Src), m_CmpType(Cmp), m_ResultType(Ret),
m_strFilter(strFilter), m_Enable(Enable)
{
	
}

CFilter::~CFilter()
{

}

typedef BOOL (CFilter::* CMPFUNCTION)(const CString& strSrc, const CString& strDst);

BOOL
CFilter::BeginWith(const CString& strSrc, const CString& strDst)
{
	if (strSrc.GetLength() < strDst.GetLength()){
		return FALSE;
	}

	return strSrc.Left(strDst.GetLength()).CompareNoCase(strDst) == 0;
}

BOOL
CFilter::EndWith(const CString& strSrc, const CString& strDst)
{
	if (strSrc.GetLength() < strDst.GetLength()) {
		return FALSE;
	}

	return strSrc.Right(strDst.GetLength()).CompareNoCase(strDst) == 0;
}

BOOL
CFilter::Is(const CString& strSrc, const CString& strDst)
{
	if (strSrc.GetLength() != strDst.GetLength()) {
		return FALSE;
	}

	return strSrc.CompareNoCase(strDst) == 0;
}

BOOL
CFilter::IsNot(const CString& strSrc, const CString& strDst)
{
	return !Is(strSrc, strDst);
}

BOOL
CFilter::Lessthan(const CString& strSrc, const CString& strDst)
{
	return strSrc.CompareNoCase(strDst) < 0;
}

BOOL
CFilter::Morethan(const CString& strSrc, const CString& strDst)
{
	return strSrc.CompareNoCase(strDst) > 0;
}

BOOL
CFilter::Contains(const CString& strSrc, const CString& strDst)
{
	CString strSrcTmp = strSrc;
	CString strDstTmp = strDst;

	return strSrcTmp.MakeUpper().Find(strDstTmp.MakeUpper()) != -1;
}

BOOL
CFilter::NotContains(const CString& strSrc, const CString& strDst)
{
	return !Contains(strSrc, strDst);
}

typedef struct _CMP_TABLE
{
	CMPFUNCTION CmpFunction;
}CMP_TABLE;

CMPFUNCTION gFunctionTable[] =
{
	& CFilter::Is,
	& CFilter::IsNot,
	& CFilter::Lessthan,
	& CFilter::Morethan,
	& CFilter::BeginWith,
	& CFilter::EndWith,
	& CFilter::Contains,
	& CFilter::NotContains,
};

BOOL 
CFilter::Match(
	const CRefPtr<CEventView> pOptView
)
{
	CString strSrc;
	strSrc = pOptView->GetOperationStrResult(m_SrcType);
	
	//
	// Do not filter if is empty
	//
	
	if (strSrc.IsEmpty()){
		return FALSE;
	}
	
	BOOL bCompare = FALSE;
	if (m_CmpType <= emCMPExcludes && m_CmpType >= emCMPIs){
		bCompare = (this->*gFunctionTable[m_CmpType])(strSrc, m_strFilter);
	}

	return bCompare;
}

BOOL
CFilter::Filter(
	const CRefPtr<CEventView> pOptView
)
{
	if (!m_Enable) {
		return FALSE;
	}
	BOOL bMatch = Match(pOptView);
	return m_ResultType == emRETInclude ? !bMatch : bMatch;
}

VOID CFilter::SetEnable(BOOL bEnable)
{
	m_Enable = bEnable;
}

BOOL CFilter::IsEnable()
{
	return m_Enable;
}



```

`gui/filter.hpp`:

```hpp
#pragma once

typedef enum _FILTER_CMP_TYPE
{
	emCMPIs = 0,
	emCMPIsNot,
	emCMPLessThan,
	emCMPMoreThan,
	emCMPBeginWith,
	emCMPEndWith,
	emCMPContains,
	emCMPExcludes
}FILTER_CMP_TYPE;

typedef enum _FILTER_RESULT_TYPE
{
	emRETInclude = 0,
	emRETExclude
}FILTER_RESULT_TYPE;

class CFilter : public CRefBase
{
public:
	CFilter(MAP_SOURCE_TYPE Src, FILTER_CMP_TYPE Cmp, FILTER_RESULT_TYPE Ret, const CString& strFilter, BOOL Enable = TRUE);
	~CFilter();

	BOOL BeginWith(const CString& strSrc, const CString& strDst);
	BOOL EndWith(const CString& strSrc, const CString& strDst);
	BOOL Is(const CString& strSrc, const CString& strDst);
	BOOL IsNot(const CString& strSrc, const CString& strDst);
	BOOL Lessthan(const CString& strSrc, const CString& strDst);
	BOOL Morethan(const CString& strSrc, const CString& strDst);
	BOOL Contains(const CString& strSrc, const CString& strDst);
	BOOL NotContains(const CString& strSrc, const CString& strDst);
	BOOL Match(const CRefPtr<CEventView> pOptView);
	BOOL Filter(const CRefPtr<CEventView> pOptView);
	void SetEnable(BOOL bEnable = TRUE);
	BOOL IsEnable();

	//BOOL FilterTest(const CString& strSrc);


	MAP_SOURCE_TYPE GetSourceType()
	{
		return m_SrcType;
	}

	FILTER_CMP_TYPE GetCmpType()
	{
		return m_CmpType;
	}

	FILTER_RESULT_TYPE GetRetType()
	{
		return m_ResultType;
	}

	const CString& GetFilter()
	{
		return m_strFilter;
	}

private:
	MAP_SOURCE_TYPE m_SrcType;
	FILTER_CMP_TYPE m_CmpType;
	FILTER_RESULT_TYPE m_ResultType;
	CString m_strFilter;
	BOOL m_Enable;
};
```

`gui/filterdlg.cpp`:

```cpp

#include "stdafx.h"
#include "resource.h"
#include "dataview.h"
#include "filterdlg.h"

#define WM_CUSTOM_FILTER	(WM_USER+2)

LPCTSTR gSourceTypeStr[] = {
	TEXT("Architeture"),
	TEXT("AuthId"),
	TEXT("Category"),
	TEXT("CommandLine"),
	TEXT("Company"),
	TEXT("CompletionTime"),
	TEXT("DataTime"),
	TEXT("Description"),
	TEXT("Detail"),
	TEXT("Duration"),
	TEXT("EventClass"),
	TEXT("ImagePath"),
	TEXT("Integrity"),
	TEXT("Operation"),
	TEXT("ParentPid"),
	TEXT("Path"),
	TEXT("PID"),
	TEXT("ProcessName"),
	TEXT("RelativeTime"),
	TEXT("Result"),
	TEXT("Sequence"),
	TEXT("Session"),
	TEXT("TID"),
	TEXT("TimeOfDay"),
	TEXT("User"),
	TEXT("Version"),
	TEXT("Virtualize")
};

LPCTSTR gCmpTypeStr[] = {

	TEXT("Is"),
	TEXT("Is Not"),
	TEXT("Less Than"),
	TEXT("More Than"),
	TEXT("Begin With"),
	TEXT("End With"),
	TEXT("Contains"),
	TEXT("Excludes")
};

LPCTSTR gRetTypeStr[] = {
	TEXT("Include"),
	TEXT("Exclude")
};


LRESULT CFilterDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	DlgResize_Init(false);

	m_ComboBoxSrc = GetDlgItem(IDC_FILTER_SRC);
	m_ComboBoxOpt = GetDlgItem(IDC_FILTER_OPT);
	m_ComboBoxDst = GetDlgItem(IDC_FILTER_DEST);
	m_ComboBoxRet = GetDlgItem(IDC_FILTER_RET);
	m_FilterListView = this->GetDlgItem(IDC_FILTER_LIST);

	m_ApplyBtn = GetDlgItem(IDC_FILTER_APPLY);
	m_ApplyBtn.EnableWindow(FALSE);

	for (int i = 0; i < _countof(gSourceTypeStr); i++)
	{
		m_ComboBoxSrc.AddString(gSourceTypeStr[i]);
	}

	for (int i = 0; i < _countof(gCmpTypeStr); i++)
	{
		m_ComboBoxOpt.AddString(gCmpTypeStr[i]);
	}

	for (int i = 0; i < _countof(gRetTypeStr); i++)
	{
		m_ComboBoxRet.AddString(gRetTypeStr[i]);
	}

	m_ComboBoxSrc.SetCurSel(0);
	m_ComboBoxOpt.SetCurSel(0);
	m_ComboBoxRet.SetCurSel(0);

	DWORD SmallX = GetSystemMetrics(SM_CXSMICON);
	DWORD SmallY = GetSystemMetrics(SM_CYSMICON);

	m_clsImageList.Create(SmallX, SmallY, 0xFF, 256, 256);

	CIcon IcoInclude;
	IcoInclude.LoadIcon(IDI_ICON_ENABLE);
	m_IcoRet[0] = m_clsImageList.AddIcon(IcoInclude);

	CIcon IcoExclude;
	IcoExclude.LoadIcon(IDI_ICON_DISABLE);
	m_IcoRet[1] = m_clsImageList.AddIcon(IcoExclude);

	m_FilterListView.SetExtendedListViewStyle(LVS_EX_FULLROWSELECT | LVS_EX_CHECKBOXES);
	m_FilterListView.InsertColumn(0, TEXT("Column"), LVCFMT_LEFT, 300);
	m_FilterListView.InsertColumn(1, TEXT("Relation"), LVCFMT_LEFT, 150);
	m_FilterListView.InsertColumn(2, TEXT("Value"), LVCFMT_LEFT, 300);
	m_FilterListView.InsertColumn(3, TEXT("Action"), LVCFMT_LEFT, 150);
	m_FilterListView.SetImageList(m_clsImageList, LVSIL_SMALL);

	auto FilterList = DATAVIEW().GetFilterMgr().GetFilterList();

	int nIndex = 0;
	for (auto filter : FilterList)
	{
		int SrcIndex = static_cast<int>(filter->GetSourceType());
		int CmpIndex = static_cast<int>(filter->GetCmpType());
		int RetIndex = static_cast<int>(filter->GetRetType());
		auto& strDst = filter->GetFilter();

		m_FilterListView.InsertItem(nIndex, gSourceTypeStr[SrcIndex], m_IcoRet[RetIndex]);
		m_FilterListView.SetItemText(nIndex, 1, gCmpTypeStr[CmpIndex]);
		m_FilterListView.SetItemText(nIndex, 2, strDst);
		m_FilterListView.SetItemText(nIndex, 3, gRetTypeStr[RetIndex]);

		m_FilterListView.SetCheckState(nIndex, filter->IsEnable());

		nIndex++;
	}

	return 0;
}

int CFilterDlg::SourceTypeStringToIndex(const CString& strValue)
{
	for (int i = 0; i < _countof(gSourceTypeStr); i++)
	{
		if (strValue == gSourceTypeStr[i]) {
			return i;
		}
	}

	return 0;
}

int CFilterDlg::CmpTypeStringToIndex(const CString& strValue)
{
	for (int i = 0; i < _countof(gCmpTypeStr); i++)
	{
		if (strValue == gCmpTypeStr[i]) {
			return i;
		}
	}

	return 0;
}

int CFilterDlg::RetTypeStringToIndex(const CString& strValue)
{
	for (int i = 0; i < _countof(gRetTypeStr); i++)
	{
		if (strValue == gRetTypeStr[i]) {
			return i;
		}
	}

	return 0;
}

LRESULT CFilterDlg::OnBtnAdd(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
{
	int RetIndex = m_ComboBoxRet.GetCurSel();
	int SrcIndex = m_ComboBoxSrc.GetCurSel();
	int CmpIndex = m_ComboBoxOpt.GetCurSel();
	CString strFilter;
	m_ComboBoxDst.GetWindowText(strFilter);

	m_FilterListView.InsertItem(0, gSourceTypeStr[SrcIndex], m_IcoRet[RetIndex]);
	m_FilterListView.SetItemText(0, 1, gCmpTypeStr[CmpIndex]);
	m_FilterListView.SetItemText(0, 2, strFilter);
	m_FilterListView.SetItemText(0, 3, gRetTypeStr[RetIndex]);

	m_FilterListView.SetCheckState(0, TRUE);

	m_ApplyBtn.EnableWindow(TRUE);
	return S_OK;
}

LRESULT CFilterDlg::OnApplyCmd(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
{
	DATAVIEW().GetFilterMgr().RemoveAll();
	int nCounts = m_FilterListView.GetItemCount();

	for (auto i = 0; i < nCounts; i++)
	{
		CString strTemp;
		m_FilterListView.GetItemText(i, 0, strTemp);
		auto srcType = static_cast<MAP_SOURCE_TYPE>(SourceTypeStringToIndex(strTemp));

		m_FilterListView.GetItemText(i, 1, strTemp);
		auto optType = static_cast<FILTER_CMP_TYPE>(CmpTypeStringToIndex(strTemp));

		CString strFilter;
		m_FilterListView.GetItemText(i, 2, strFilter);

		m_FilterListView.GetItemText(i, 3, strTemp);
		auto retType = static_cast<FILTER_RESULT_TYPE>(RetTypeStringToIndex(strTemp));

		BOOL bEnable = m_FilterListView.GetCheckState(i);

		DATAVIEW().GetFilterMgr().AddFilter(srcType, optType, retType, strFilter, bEnable);
	}

	GetParent().PostMessage(WM_CUSTOM_FILTER, 0, 0);

	return 0;
}
```

`gui/filterdlg.h`:

```h
#pragma once

class CFilterDlg : public CDialogImpl<CFilterDlg>, public CDialogResize<CFilterDlg>
{
public:
	enum {
		IDD = FILTER_INIT
	};

	BEGIN_MSG_MAP(CFilterDlg)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		COMMAND_ID_HANDLER(IDC_FILTER_ADD, OnBtnAdd)
		COMMAND_ID_HANDLER(IDC_FILTER_REMOVE, OnBtnRemove)
		COMMAND_ID_HANDLER(IDOK, OnCloseCmd)
		COMMAND_ID_HANDLER(IDCANCEL, OnCloseCmd)
		COMMAND_ID_HANDLER(IDC_FILTER_APPLY, OnApplyCmd)

		NOTIFY_HANDLER(IDC_FILTER_LIST, NM_DBLCLK, NotifyDClickHandler)
		//NOTIFY_HANDLER(IDC_FILTER_LIST, LVN_ITEMCHANGED, NotifyItemChangedHandler)

		CHAIN_MSG_MAP(CDialogResize<CFilterDlg>)
	END_MSG_MAP()

	BEGIN_DLGRESIZE_MAP(CFilterDlg)
		DLGRESIZE_CONTROL(IDC_FILTER_DEST, DLSZ_SIZE_X)
		DLGRESIZE_CONTROL(IDC_FILTER_THEN, DLSZ_MOVE_X)
		DLGRESIZE_CONTROL(IDC_FILTER_RET, DLSZ_MOVE_X)
		DLGRESIZE_CONTROL(IDC_FILTER_ADD, DLSZ_MOVE_X)
		DLGRESIZE_CONTROL(IDC_FILTER_REMOVE, DLSZ_MOVE_X)
		DLGRESIZE_CONTROL(IDC_FILTER_LIST, DLSZ_SIZE_X | DLSZ_SIZE_Y)
		DLGRESIZE_CONTROL(IDOK, DLSZ_MOVE_X|DLSZ_MOVE_Y)
		DLGRESIZE_CONTROL(IDCANCEL, DLSZ_MOVE_X|DLSZ_MOVE_Y)
		DLGRESIZE_CONTROL(IDC_FILTER_APPLY, DLSZ_MOVE_X|DLSZ_MOVE_Y)
	END_DLGRESIZE_MAP()


	LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/);

	LRESULT OnApplyCmd(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/);
	//LRESULT OnOkCmd(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/);

	LRESULT OnCloseCmd(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		EndDialog(wID);
		return 0;
	}

	LRESULT OnBtnAdd(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/);

	LRESULT OnBtnRemove(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{

		int iItem = m_FilterListView.GetSelectedIndex();
		RemoveItemAddShowInCombox(iItem);
		return 0;
	}

	LRESULT NotifyDClickHandler(int /*idCtrl*/, LPNMHDR pnmh, BOOL& bHandled)
	{
		LPNMITEMACTIVATE pNMItemActivate = reinterpret_cast<LPNMITEMACTIVATE>(pnmh);
		if (pNMItemActivate->iItem != -1) {
			RemoveItemAddShowInCombox(pNMItemActivate->iItem);
		}

		return TRUE;
	}

private:

	int SourceTypeStringToIndex(const CString& strValue);
	int CmpTypeStringToIndex(const CString& strValue);
	int RetTypeStringToIndex(const CString& strValue);

	void RemoveItemAddShowInCombox(int nItem)
	{
		CString strTemp;
		m_FilterListView.GetItemText(nItem, 0, strTemp);
		m_ComboBoxSrc.SetCurSel(SourceTypeStringToIndex(strTemp));

		m_FilterListView.GetItemText(nItem, 1, strTemp);
		m_ComboBoxOpt.SetCurSel(CmpTypeStringToIndex(strTemp));

		CString strFilter;
		m_FilterListView.GetItemText(nItem, 2, strFilter);
		m_ComboBoxDst.AddString(strFilter);
		m_ComboBoxDst.SetCurSel(0);

		m_FilterListView.GetItemText(nItem, 3, strTemp);
		m_ComboBoxRet.SetCurSel(RetTypeStringToIndex(strTemp));

		//auto retType = static_cast<FILTER_RESULT_TYPE>(CmpTypeStringToIndex(strTemp));

		m_FilterListView.DeleteItem(nItem);
		m_ApplyBtn.EnableWindow(TRUE);

	}

public:
	CComboBox m_ComboBoxSrc;
	CComboBox m_ComboBoxOpt;
	CComboBox m_ComboBoxDst;
	CComboBox m_ComboBoxRet;
	CButton m_ApplyBtn;
	CListViewCtrl m_FilterListView;
	CImageList m_clsImageList;
	int m_IcoRet[2] = { 0 };
};
```

`gui/filtermgr.cpp`:

```cpp

#include "stdafx.h"
#include "filtermgr.h"

BOOL CFilterMgr::Filter(CRefPtr<CEventView> pView)
{
	std::shared_lock<std::shared_mutex> lock(m_lock);
	
	BOOL bFilter = FALSE;
	for (auto filter : m_FilterList) {
		if (filter->Filter(pView)) {
			bFilter = TRUE;
			break;
		}
	}

	return bFilter;
}

size_t CFilterMgr::GetCounts()
{
	return m_FilterList.size();
}

void CFilterMgr::AddFilter(
	MAP_SOURCE_TYPE SrcType, 
	FILTER_CMP_TYPE CmpType, 
	FILTER_RESULT_TYPE RetType, 
	const CString& strDst,
	BOOL Enable
)
{
	AddFilter(new CFilter(SrcType, CmpType, RetType, strDst, Enable));
}

void CFilterMgr::AddFilter(CRefPtr<CFilter> pFilter)
{
	std::unique_lock<std::shared_mutex> lock(m_lock);
	m_FilterList.insert(m_FilterList.begin(), pFilter);
	//Sort();
}

void CFilterMgr::RemovFilter(
	MAP_SOURCE_TYPE SrcType,
	FILTER_CMP_TYPE CmpType,
	FILTER_RESULT_TYPE RetType,
	const CString& strDst
)
{
	std::unique_lock<std::shared_mutex> lock(m_lock);
	for (auto it = m_FilterList.begin(); it != m_FilterList.end();)
	{
		if ((*it)->GetSourceType() == SrcType &&
			(*it)->GetCmpType() == CmpType && 
			(*it)->GetRetType() == RetType &&
			(*it)->GetFilter() == strDst){
			it = m_FilterList.erase(it);
		}else{
			it++;
		}
	}
}

void CFilterMgr::RemovFilter(CRefPtr<CFilter> pFilter)
{
	RemovFilter(pFilter->GetSourceType(), pFilter->GetCmpType(),
		pFilter->GetRetType(), pFilter->GetFilter());
}

class CFilterCompare
{
public:
	bool operator() (const CRefPtr<CFilter> p1, const CRefPtr<CFilter> p2)
	{
		return p1->GetRetType() > p2->GetRetType();
	}
};

void CFilterMgr::Sort()
{
	std::unique_lock<std::shared_mutex> lock(m_lock);
	std::sort(m_FilterList.begin(), m_FilterList.end(), CFilterCompare());
}

const std::vector<CRefPtr<CFilter>>& CFilterMgr::GetFilterList()
{
	return m_FilterList;
}

void CFilterMgr::SetEnable(ULONG Index, BOOL Enable)
{
	if (Index < m_FilterList.size()) {
		m_FilterList[Index]->SetEnable(Enable);
	}
}

BOOL CFilterMgr::IsEnable(ULONG Index)
{
	if (Index < m_FilterList.size()) {
		return m_FilterList[Index]->IsEnable();
	}

	return FALSE;
}

void CFilterMgr::RemoveAll()
{
	std::unique_lock<std::shared_mutex> lock(m_lock);
	m_FilterList.clear();
}


```

`gui/filtermgr.h`:

```h
#pragma once

#include "filter.hpp"
#include <vector>
#include <shared_mutex>

//#define FILETERMGR() Singleton<CFilterMgr>::getInstance()

class CFilterMgr
{
public:
	CFilterMgr(){}
	~CFilterMgr() {}

public:

	BOOL Filter(CRefPtr<CEventView> pView);
	size_t GetCounts();
	void AddFilter(CRefPtr<CFilter> pFilter);
	void AddFilter(MAP_SOURCE_TYPE SrcType, FILTER_CMP_TYPE CmpType, FILTER_RESULT_TYPE RetType, const CString& strDst, BOOL Enable = TRUE);
	void RemovFilter(MAP_SOURCE_TYPE SrcType, FILTER_CMP_TYPE CmpType, FILTER_RESULT_TYPE RetType, const CString& strDst);
	void RemovFilter(CRefPtr<CFilter> pFilter);
	void RemoveAll();
	const std::vector<CRefPtr<CFilter>>& GetFilterList();
	void SetEnable(ULONG Index, BOOL Enable = TRUE);
	BOOL IsEnable(ULONG Index);

private:
    void Sort();

private:

	std::shared_mutex m_lock;
	std::vector<CRefPtr<CFilter>> m_FilterList;
};
```

`gui/fltprocess.h`:

```h
#pragma once

#define WM_PROGRESSUPDATE WM_USER+1000

class CFltProcessDlg : public CDialogImpl<CFltProcessDlg>
{
public:
	enum { IDD = IDD_PROGRESS };

	BEGIN_MSG_MAP(CFltProcessDlg)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		MESSAGE_HANDLER(WM_PROGRESSUPDATE, OnProgressUpdate)
		MESSAGE_HANDLER(WM_DESTROY, OnDestory)

		COMMAND_ID_HANDLER(IDOK, OnCloseCmd)
		COMMAND_ID_HANDLER(IDCANCEL, OnCloseCmd)
	END_MSG_MAP()

	// Handler prototypes (uncomment arguments if needed):
	//	LRESULT MessageHandler(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	//	LRESULT CommandHandler(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	//	LRESULT NotifyHandler(int /*idCtrl*/, LPNMHDR /*pnmh*/, BOOL& /*bHandled*/)

	static VOID OnFltProcessing(size_t Total, size_t Current, PVOID pParamter)
	{
		CFltProcessDlg* pDlg = reinterpret_cast<CFltProcessDlg*>(pParamter);
		if (!Total){
			return;
		}
		
		//
		// Show progressing
		//
		
		int nPos = (int)(((float)(Current+1) / (float)Total) * 100.0);
		if (pDlg->m_CurProcess != nPos){
			pDlg->m_CurProcess = nPos;
			pDlg->PostMessage(WM_PROGRESSUPDATE, (WPARAM)nPos, 0);
		}
	}

	static DWORD ThreadUpdate(LPVOID lParam)
	{
		CFltProcessDlg* pDlg = reinterpret_cast<CFltProcessDlg*>(lParam);
		DATAVIEW().ApplyNewFilter(OnFltProcessing, lParam);
		pDlg->PostMessage(WM_PROGRESSUPDATE, (WPARAM)100, 0);
		return 0;
	}

	LRESULT OnDestory(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		CloseHandle(m_hThread);
		return 0;
	}

	LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		CenterWindow(GetParent());
		m_ProgressBar = GetDlgItem(1093);
		m_ProgressBar.SetRange(0, 100);
		m_CurProcess = 0;
		m_hThread = CreateThread(NULL, 0, ThreadUpdate, this, 0, NULL);

		return TRUE;
	}

	LRESULT OnProgressUpdate(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
	{
		int nPos = (int)wParam;
		if (nPos >= 100){
			EndDialog(0);
		}else{
			m_ProgressBar.SetPos(nPos);
		}
		return TRUE;
	}

	LRESULT OnCloseCmd(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		EndDialog(wID);
		return 0;
	}

public:
	CProgressBarCtrl m_ProgressBar;
	int m_CurProcess = 0;
	HANDLE m_hThread = NULL;
};
```

`gui/main.cpp`:

```cpp
// procmon_gui.cpp : main source file for procmon_gui.exe
//

#include "stdafx.h"

#include <shellscalingapi.h>

#include "resource.h"

#include "View.h"
#include "aboutdlg.h"
#include "propdlg.h"
#include "propproc.h"
#include "propstack.h"
#include "filter.hpp"
#include "fltprocess.h"
#include "filterdlg.h"
#include "MainFrm.h"


#pragma comment(lib, "Shcore.lib")

CAppModule _Module;

int Run(LPTSTR /*lpstrCmdLine*/ = NULL, int nCmdShow = SW_SHOWDEFAULT)
{
	CMessageLoop theLoop;
	_Module.AddMessageLoop(&theLoop);

	CRefPtr<CMainFrame> wndMain = new CMainFrame;

	if(wndMain->CreateEx() == NULL)
	{
		ATLTRACE(_T("Main window creation failed!\n"));
		return 0;
	}

	wndMain->ShowWindow(nCmdShow);

	int nRet = theLoop.Run();

	_Module.RemoveMessageLoop();
	return nRet;
}

int WINAPI _tWinMain(HINSTANCE hInstance, HINSTANCE /*hPrevInstance*/, LPTSTR lpstrCmdLine, int nCmdShow)
{
	HRESULT hRes = ::CoInitialize(NULL);
	ATLASSERT(SUCCEEDED(hRes));

	SetProcessDpiAwareness(PROCESS_SYSTEM_DPI_AWARE);
	AtlInitCommonControls(ICC_COOL_CLASSES | ICC_BAR_CLASSES);	// add flags to support other controls

	UtilSetPriviledge(SE_DEBUG_NAME, TRUE);

	hRes = _Module.Init(NULL, hInstance);
	ATLASSERT(SUCCEEDED(hRes));

	int nRet = Run(lpstrCmdLine, nCmdShow);

	_Module.Term();
	::CoUninitialize();

	return nRet;
}

```

`gui/procmon_gui.h`:

```h
// procmon_gui.h

```

`gui/procmon_gui.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "atlres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// 中文(简体，中国) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)
LANGUAGE LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED
#pragma code_page(936)

/////////////////////////////////////////////////////////////////////////////
//
// AFX_DIALOG_LAYOUT
//

IDD_DIALOG1 AFX_DIALOG_LAYOUT
BEGIN
    0
END


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_ICON_FILE           ICON                    "res\\file.ico"

IDI_ICON_PROCESS        ICON                    "res\\process.ico"

IDI_ICON_REGISTERY      ICON                    "res\\registry.ico"

IDI_ICON_ENABLE         ICON                    "res\\check.ico"

IDI_ICON_DISABLE        ICON                    "res\\remove.ico"


/////////////////////////////////////////////////////////////////////////////

#endif    // 中文(简体，中国) resources
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// 英语(美国) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)

/////////////////////////////////////////////////////////////////////////////
//
// AFX_DIALOG_LAYOUT
//

IDD_DIALOG_PROPERTIES AFX_DIALOG_LAYOUT
BEGIN
    0
END

PROP_STACKTRACE AFX_DIALOG_LAYOUT
BEGIN
    0
END

PROP_PROCESS AFX_DIALOG_LAYOUT
BEGIN
    0
END

PROP_EVENT AFX_DIALOG_LAYOUT
BEGIN
    0
END

FILTER_INIT AFX_DIALOG_LAYOUT
BEGIN
    0
END


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDR_MAINFRAME           ICON                    "res\\procmon_gui.ico"


/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_DIALOG_PROPERTIES DIALOGEX 50, 50, 370, 331
STYLE DS_SETFONT | DS_FIXEDSYS | DS_NOFAILCREATE | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME
EXSTYLE WS_EX_TRANSPARENT
CAPTION "Properties"
FONT 8, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    CONTROL         "Tab1",IDC_TAB_PROPERTIES,"SysTabControl32",WS_TABSTOP,7,7,358,291
    DEFPUSHBUTTON   "Close",ID_PROPERITIES_CLOSE,311,308,50,14
    PUSHBUTTON      "<<",IDC_PROPERITES_PREV,7,310,17,14,BS_ICON
    PUSHBUTTON      ">>",IDC_PROPERTIES_NEXT,27,310,17,14,BS_ICON
    CONTROL         "Next Highlighted",IDC_PROPERTIES_CHECK,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,50,312,69,10
    PUSHBUTTON      "Copy All",IDC_PROPERITES_COPYALL,255,308,50,14
END

IDD_ABOUTBOX DIALOG 0, 0, 187, 102
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "About"
FONT 9, "Segoe UI"
BEGIN
    DEFPUSHBUTTON   "OK",IDOK,130,81,50,14
    CTEXT           "procmon_gui Application v1.0\n\n(c) Copyright 2019",IDC_STATIC,25,57,78,32
    ICON            IDR_MAINFRAME,IDC_STATIC,55,26,18,20
    GROUPBOX        "",IDC_STATIC,7,7,115,88
END

PROP_EVENT DIALOGEX 0, 0, 306, 263
STYLE DS_SETFONT | DS_FIXEDSYS | DS_CONTROL | WS_CHILD | WS_VISIBLE
EXSTYLE WS_EX_TRANSPARENT
FONT 8, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    LTEXT           "Thread:",-1,7,19,27,8
    EDITTEXT        IDC_EVENT_THREAD,61,19,209,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER
    LTEXT           "Class:",-1,7,31,21,8
    EDITTEXT        IDC_EVENT_CLASS,61,31,209,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER
    LTEXT           "Operation:",-1,7,43,36,8
    EDITTEXT        IDC_EVENT_OPT,61,43,209,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER
    LTEXT           "Result:",-1,7,55,24,8
    EDITTEXT        IDC_EVENT_RET,61,55,209,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER
    LTEXT           "Path:",-1,7,67,18,8
    EDITTEXT        IDC_EVENT_PATH,61,67,209,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER
    LTEXT           "Date:",-1,7,7,19,8
    EDITTEXT        IDC_EVENT_DATA,61,7,209,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER
    LTEXT           "Duration:",-1,7,79,31,8
    EDITTEXT        IDC_EVENT_DURATION,61,79,209,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER
    CONTROL         "",-1,"Static",SS_ETCHEDHORZ,7,93,292,1
    EDITTEXT        IDC_EVENT_DETAIL,7,101,292,155,ES_MULTILINE | ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER | WS_VSCROLL,WS_EX_TRANSPARENT
END

PROP_PROCESS DIALOGEX 0, 0, 306, 280
STYLE DS_SETFONT | DS_FIXEDSYS | DS_CONTROL | WS_CHILD | WS_VISIBLE
EXSTYLE WS_EX_CONTROLPARENT
FONT 8, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    GROUPBOX        "Image",IDC_PROC_GROUP_BOX,7,6,292,116,0,WS_EX_TRANSPARENT
    ICON            "",IDC_PROCESS_ICON,18,17,20,20
    EDITTEXT        IDC_PROCESS_DESC,47,17,240,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER
    EDITTEXT        IDC_PROCESS_COMPANY,47,29,240,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER
    LTEXT           "Name:",-1,13,42,23,8
    EDITTEXT        IDC_PROCESS_NAME,47,42,219,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER
    LTEXT           "Version:",-1,13,54,28,8
    EDITTEXT        IDC_PROCESS_VERSION,47,54,239,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER
    LTEXT           "Path:",-1,13,68,18,8
    EDITTEXT        IDC_PROCESS_PATH,13,78,282,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_CLIENTEDGE
    LTEXT           "Command Line:",-1,13,95,52,8
    EDITTEXT        IDC_PROCESS_CMDLINE,13,105,282,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_CLIENTEDGE
    LTEXT           "PID:",-1,7,131,15,8
    EDITTEXT        IDC_PROCESS_PID,53,131,90,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER
    LTEXT           "Parent PID:",-1,7,144,38,8
    EDITTEXT        IDC_PROCESS_PPID,53,144,104,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER
    LTEXT           "Session ID:",-1,7,157,38,8
    EDITTEXT        IDC_PROCESS_SESSION,53,157,107,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER
    LTEXT           "User:",-1,7,170,19,8
    EDITTEXT        IDC_PROCESS_USER,53,170,239,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER
    LTEXT           "Auth ID:",-1,7,183,28,8
    EDITTEXT        IDC_PROCESS_AUTHID,53,183,93,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER
    LTEXT           "Started:",-1,7,196,28,8
    EDITTEXT        IDC_PROCESS_STARTTIME,53,196,101,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER
    LTEXT           "Architecture:",-1,165,131,43,8
    EDITTEXT        IDC_PROCESS_ARCH,215,131,84,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER
    LTEXT           "Virtualized:",-1,165,144,38,8
    EDITTEXT        IDC_PROCESS_VIRTUALIZED,215,144,84,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER
    LTEXT           "Integrity:",-1,165,157,31,8
    EDITTEXT        IDC_PROCESS_INTERGRITY,215,157,84,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER
    LTEXT           "Ended:",-1,165,196,24,8
    EDITTEXT        IDC_PROCESS_ENDED,215,196,84,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER
    LTEXT           "Modules:",-1,7,209,31,8
    CONTROL         "List1",IDC_PROCESS_MODULES,"SysListView32",LVS_REPORT | LVS_SINGLESEL | WS_BORDER | WS_TABSTOP,7,222,292,51
END

PROP_STACKTRACE DIALOGEX 0, 0, 301, 148
STYLE DS_SETFONT | DS_FIXEDSYS | DS_CONTROL | WS_CHILD | WS_VISIBLE
EXSTYLE WS_EX_CONTROLPARENT
FONT 8, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    CONTROL         "List1",IDC_PROP_STACKLIST,"SysListView32",LVS_REPORT | LVS_SHOWSELALWAYS | LVS_NOSORTHEADER | WS_BORDER | WS_TABSTOP,7,7,286,122
    LTEXT           "Status...",IDC_STATIC_STAUS,8,134,72,8
    PUSHBUTTON      "&Properties...",IDC_BTN_PROPS,84,131,50,14
    PUSHBUTTON      "&Save...",IDC_BTN_SAVE,243,131,50,14
    PUSHBUTTON      "Source...",IDC_BTN_SOURCE,190,131,50,14
    PUSHBUTTON      "Search...",IDC_BTN_SEARCH,137,131,50,14
END

IDD_PROGRESS DIALOGEX 0, 0, 249, 63
STYLE DS_SETFONT | DS_MODALFRAME | DS_SETFOREGROUND | DS_FIXEDSYS | DS_CENTER | WS_POPUP | WS_VISIBLE | WS_CAPTION
CAPTION "Dialog"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    PUSHBUTTON      "Cancel",2,192,42,50,14
    CONTROL         "",1093,"msctls_progress32",WS_BORDER,7,23,235,14
    LTEXT           "Initializing...",1095,7,7,235,8
END

FILTER_INIT DIALOGEX 50, 50, 337, 177
STYLE DS_SETFONT | DS_FIXEDSYS | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME
EXSTYLE WS_EX_CONTROLPARENT
CAPTION "Process Monitor Filter"
FONT 8, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    LTEXT           "Filters were in effect the last time you exited Process Monitor:",-1,8,8,204,8
    LTEXT           "Display entries matching these conditions:",-1,7,21,138,8
    DEFPUSHBUTTON   "&OK",IDOK,170,156,50,14
    PUSHBUTTON      "&Cancel",IDCANCEL,225,156,50,14
    PUSHBUTTON      "A&pply",IDC_FILTER_APPLY,280,156,50,14
    COMBOBOX        IDC_FILTER_SRC,7,33,78,238,CBS_DROPDOWNLIST | CBS_SORT | WS_VSCROLL | WS_TABSTOP
    COMBOBOX        IDC_FILTER_OPT,87,33,54,248,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    COMBOBOX        IDC_FILTER_DEST,142,33,118,184,CBS_DROPDOWN | CBS_AUTOHSCROLL | CBS_SORT | WS_VSCROLL | WS_TABSTOP
    CTEXT           "then",IDC_FILTER_THEN,261,35,20,8
    COMBOBOX        IDC_FILTER_RET,285,33,45,69,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON      "Reset",IDC_FILTER_RESET,7,55,50,14
    PUSHBUTTON      "&Add",IDC_FILTER_ADD,225,55,50,14
    PUSHBUTTON      "&Remove",IDC_FILTER_REMOVE,280,55,50,14
    CONTROL         "",IDC_FILTER_LIST,"SysListView32",LVS_REPORT | LVS_SINGLESEL | LVS_SHOWSELALWAYS | WS_BORDER | WS_TABSTOP,7,78,323,73
END


/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO
BEGIN
    IDD_DIALOG_PROPERTIES, DIALOG
    BEGIN
        RIGHTMARGIN, 351
        BOTTOMMARGIN, 322
    END

    IDD_ABOUTBOX, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 180
        TOPMARGIN, 7
        BOTTOMMARGIN, 95
    END

    PROP_EVENT, DIALOG
    BEGIN
    END

    PROP_PROCESS, DIALOG
    BEGIN
    END

    PROP_STACKTRACE, DIALOG
    BEGIN
        BOTTOMMARGIN, 147
    END

    IDD_PROGRESS, DIALOG
    BEGIN
    END

    FILTER_INIT, DIALOG
    BEGIN
    END
END
#endif    // APSTUDIO_INVOKED


#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""atlres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Bitmap
//

IDR_TOOL                BITMAP                  "res\\tool.bmp"

IDR_MAINFRAME           BITMAP                  "res\\Toolbar.bmp"


/////////////////////////////////////////////////////////////////////////////
//
// Toolbar
//

IDR_TOOL TOOLBAR 32, 32
BEGIN
    BUTTON      ID_BUTTON_ICONS8_OPENEDF
    BUTTON      ID_BUTTON_ICONS8_SAVE
    BUTTON      ID_BUTTON_ICONS8_START
    BUTTON      ID_BUTTON_ICONS8_STOP
    BUTTON      ID_BUTTON_ICONS8_FILTER
    BUTTON      ID_BUTTON_ICONS8_SCROLLDOWN
    BUTTON      ID_BUTTON_ICONS8_SCROLLUP
    BUTTON      ID_BUTTON_ICONS8_ERASE
    SEPARATOR
    BUTTON      ID_BUTTON_ICONS8_PROCESS
    BUTTON      ID_BUTTON_ICONS8_FILE
    BUTTON      ID_BUTTON_ICONS8_REGISTRY
END

IDR_MAINFRAME TOOLBAR 16, 15
BEGIN
    BUTTON      ID_FILE_NEW
    BUTTON      ID_FILE_OPEN
    BUTTON      ID_FILE_SAVE
    SEPARATOR
    BUTTON      ID_EDIT_CUT
    BUTTON      ID_EDIT_COPY
    BUTTON      ID_EDIT_PASTE
    SEPARATOR
    BUTTON      ID_FILE_PRINT
    BUTTON      ID_APP_ABOUT
END


/////////////////////////////////////////////////////////////////////////////
//
// Menu
//

IDR_MAINFRAME MENU
BEGIN
    POPUP "&File"
    BEGIN
        MENUITEM "&Open...\tCtrl+O",            ID_FILE_OPEN
        MENUITEM "&Save\tCtrl+S",               ID_FILE_SAVE
        MENUITEM SEPARATOR
        MENUITEM "Capture &Events...",          ID_FILE_SAVE_AS
        MENUITEM SEPARATOR
        MENUITEM "Export Configuration ...",    ID_FILE_PRINT
        MENUITEM "Import Configuration ...",    ID_FILE_PRINT_PREVIEW
        MENUITEM SEPARATOR
        MENUITEM "E&xit",                       ID_APP_EXIT
    END
    POPUP "&Edit"
    BEGIN
        MENUITEM "&Copy\tCtrl+C",               ID_EDIT_COPY
        MENUITEM "&Find\tCtrl+F",               ID_EDIT_FIND
        MENUITEM "Find Highlight",              ID_EDIT_FIND
        MENUITEM "Find Bookmark",               ID_EDIT_FIND
        MENUITEM SEPARATOR
        MENUITEM "Auto Scroll\tCtrl+A",         ID_EDIT_FIND
        MENUITEM SEPARATOR
        MENUITEM "Clear Display\tCtrl+X",       ID_EDIT_FIND
    END
    POPUP "&Event"
    BEGIN
        MENUITEM "&Properties..\tCtrl+P",       ID_EDIT_FIND
        MENUITEM "Stack\tCtrl+K",               ID_EDIT_FIND
    END
    POPUP "&Options"
    BEGIN
        MENUITEM "Always on Top",               ID_EDIT_FIND
        MENUITEM SEPARATOR
        MENUITEM "Configure Symbols",           ID_EDIT_FIND
    END
    POPUP "&Help"
    BEGIN
        MENUITEM "&About procmon_gui",          ID_APP_ABOUT
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// Accelerator
//

IDR_MAINFRAME ACCELERATORS
BEGIN
    "N",            ID_FILE_NEW,            VIRTKEY, CONTROL
    "O",            ID_FILE_OPEN,           VIRTKEY, CONTROL
    "S",            ID_FILE_SAVE,           VIRTKEY, CONTROL
    "P",            ID_FILE_PRINT,          VIRTKEY, CONTROL
    "Z",            ID_EDIT_UNDO,           VIRTKEY, CONTROL
    "X",            ID_EDIT_CUT,            VIRTKEY, CONTROL
    "C",            ID_EDIT_COPY,           VIRTKEY, CONTROL
    "V",            ID_EDIT_PASTE,          VIRTKEY, CONTROL
    VK_BACK,        ID_EDIT_UNDO,           VIRTKEY, ALT
    VK_DELETE,      ID_EDIT_CUT,            VIRTKEY, SHIFT
    VK_INSERT,      ID_EDIT_COPY,           VIRTKEY, CONTROL
    VK_INSERT,      ID_EDIT_PASTE,          VIRTKEY, SHIFT
    VK_F6,          ID_NEXT_PANE,           VIRTKEY 
    VK_F6,          ID_PREV_PANE,           VIRTKEY, SHIFT
END


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,1
 PRODUCTVERSION 1,0,0,1
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x4L
 FILETYPE 0x2L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904B0"
        BEGIN
            VALUE "FileDescription", "procmon_gui Module"
            VALUE "FileVersion", "1, 0, 0, 1"
            VALUE "InternalName", "procmon_gui"
            VALUE "LegalCopyright", "Copyright 2019"
            VALUE "OriginalFilename", "procmon_gui.exe"
            VALUE "ProductName", "procmon_gui Module"
            VALUE "ProductVersion", "1, 0, 0, 1"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// String Table
//

STRINGTABLE
BEGIN
    IDR_MAINFRAME           "procmon_gui"
END

STRINGTABLE
BEGIN
    ID_VIEW_TOOLBAR         "Show or hide the toolbar\nToggle ToolBar"
    ID_VIEW_STATUS_BAR      "Show or hide the status bar\nToggle StatusBar"
END

STRINGTABLE
BEGIN
    ID_BUTTON_ICONS8_OPENEDF "Open an existing log file\nOpen"
    ID_BUTTON_ICONS8_FILTER "Show filter dialog\nFilter"
END

STRINGTABLE
BEGIN
    ID_BUTTON_ICONS8_SAVE   "Show save log dialog\nSave"
    ID_BUTTON_ICONS8_START  "Start monitor\nStart"
    ID_BUTTON_ICONS8_STOP   "Stop monitor\nStop"
    ID_BUTTON_ICONS8_SCROLLDOWN "Auto scroll to bottom\nAuto Scroll"
    ID_BUTTON_ICONS8_SCROLLUP 
                            "Disable auto scroll to bottom\nDisable Auto Scroll"
    ID_BUTTON_ICONS8_ERASE  "Erase current event list\nErase"
    ID_BUTTON_ICONS8_PROCESS "Filter Process event\nProcess Event"
    ID_BUTTON_ICONS8_FILE   "Filter File event\nFile Event"
    ID_BUTTON_ICONS8_REGISTRY "Filter Registery event\nReg Event"
END

STRINGTABLE
BEGIN
    ATL_IDS_SCSIZE          "Change the window size"
    ATL_IDS_SCMOVE          "Change the window position"
    ATL_IDS_SCMINIMIZE      "Reduce the window to an icon"
    ATL_IDS_SCMAXIMIZE      "Enlarge the window to full size"
    ATL_IDS_SCNEXTWINDOW    "Switch to the next document window"
    ATL_IDS_SCPREVWINDOW    "Switch to the previous document window"
    ATL_IDS_SCCLOSE         "Close the active window and prompts to save the documents"
END

STRINGTABLE
BEGIN
    ATL_IDS_SCRESTORE       "Restore the window to normal size"
    ATL_IDS_SCTASKLIST      "Activate Task List"
    ATL_IDS_MDICHILD        "Activate this window"
END

STRINGTABLE
BEGIN
    ATL_IDS_IDLEMESSAGE     "Ready"
END

STRINGTABLE
BEGIN
    ATL_IDS_MRU_FILE        "Open this document"
END

#endif    // 英语(美国) resources
/////////////////////////////////////////////////////////////////////////////



```

`gui/procmon_gui.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29102.190
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "procmon_gui", "procmon_gui.vcxproj", "{7488FAC5-431F-4E66-AFAE-0858DF3E0FD7}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{7488FAC5-431F-4E66-AFAE-0858DF3E0FD7}.Debug|x64.ActiveCfg = Debug|x64
		{7488FAC5-431F-4E66-AFAE-0858DF3E0FD7}.Debug|x64.Build.0 = Debug|x64
		{7488FAC5-431F-4E66-AFAE-0858DF3E0FD7}.Debug|x86.ActiveCfg = Debug|Win32
		{7488FAC5-431F-4E66-AFAE-0858DF3E0FD7}.Debug|x86.Build.0 = Debug|Win32
		{7488FAC5-431F-4E66-AFAE-0858DF3E0FD7}.Release|x64.ActiveCfg = Release|x64
		{7488FAC5-431F-4E66-AFAE-0858DF3E0FD7}.Release|x64.Build.0 = Release|x64
		{7488FAC5-431F-4E66-AFAE-0858DF3E0FD7}.Release|x86.ActiveCfg = Release|Win32
		{7488FAC5-431F-4E66-AFAE-0858DF3E0FD7}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {60B42738-9F8E-46D8-96ED-E4E22F10770F}
	EndGlobalSection
EndGlobal

```

`gui/procmon_gui.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{7488FAC5-431F-4E66-AFAE-0858DF3E0FD7}</ProjectGuid>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_WINDOWS;STRICT;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <ResourceCompile>
      <Culture>0x0409</Culture>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <TargetEnvironment>Win32</TargetEnvironment>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <HeaderFileName>procmon_gui.h</HeaderFileName>
      <InterfaceIdentifierFileName>procmon_gui_i.c</InterfaceIdentifierFileName>
      <ProxyFileName>procmon_gui_p.c</ProxyFileName>
      <GenerateStublessProxies>true</GenerateStublessProxies>
      <TypeLibraryName>$(IntDir)/procmon_gui.tlb</TypeLibraryName>
      <DllDataFileName />
    </Midl>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_WINDOWS;STRICT;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>D:\source\WTL10_10320\Include</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <AdditionalDependencies>..\x64\Debug\procmonsdk.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <ResourceCompile>
      <Culture>0x0409</Culture>
      <AdditionalIncludeDirectories>$(IntDir);D:\source\WTL10_10320\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <HeaderFileName>procmon_gui.h</HeaderFileName>
      <InterfaceIdentifierFileName>procmon_gui_i.c</InterfaceIdentifierFileName>
      <ProxyFileName>procmon_gui_p.c</ProxyFileName>
      <GenerateStublessProxies>true</GenerateStublessProxies>
      <TypeLibraryName>$(IntDir)/procmon_gui.tlb</TypeLibraryName>
      <DllDataFileName />
    </Midl>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <ExceptionHandling />
      <DebugInformationFormat />
      <PreprocessorDefinitions>WIN32;_WINDOWS;STRICT;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
    <ResourceCompile>
      <Culture>0x0409</Culture>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <TargetEnvironment>Win32</TargetEnvironment>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <HeaderFileName>procmon_gui.h</HeaderFileName>
      <InterfaceIdentifierFileName>procmon_gui_i.c</InterfaceIdentifierFileName>
      <ProxyFileName>procmon_gui_p.c</ProxyFileName>
      <GenerateStublessProxies>true</GenerateStublessProxies>
      <TypeLibraryName>$(IntDir)/procmon_gui.tlb</TypeLibraryName>
      <DllDataFileName />
    </Midl>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <ExceptionHandling>Sync</ExceptionHandling>
      <DebugInformationFormat />
      <PreprocessorDefinitions>_WINDOWS;STRICT;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>D:\source\WTL10_10320\Include</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <ImageHasSafeExceptionHandlers>
      </ImageHasSafeExceptionHandlers>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <AdditionalDependencies>..\x64\Release\procmonsdk.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <ResourceCompile>
      <Culture>0x0409</Culture>
      <AdditionalIncludeDirectories>$(IntDir);D:\source\WTL10_10320\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <HeaderFileName>procmon_gui.h</HeaderFileName>
      <InterfaceIdentifierFileName>procmon_gui_i.c</InterfaceIdentifierFileName>
      <ProxyFileName>procmon_gui_p.c</ProxyFileName>
      <GenerateStublessProxies>true</GenerateStublessProxies>
      <TypeLibraryName>$(IntDir)/procmon_gui.tlb</TypeLibraryName>
      <DllDataFileName />
    </Midl>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="filter.cpp" />
    <ClCompile Include="filterdlg.cpp" />
    <ClCompile Include="filtermgr.cpp" />
    <ClCompile Include="propevent.cpp" />
    <ClCompile Include="dataview.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="propdlg.cpp" />
    <ClCompile Include="propstack.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="AboutDlg.h" />
    <ClInclude Include="filter.hpp" />
    <ClInclude Include="filterdlg.h" />
    <ClInclude Include="filtermgr.h" />
    <ClInclude Include="fltprocess.h" />
    <ClInclude Include="propevent.h" />
    <ClInclude Include="dataview.h" />
    <ClInclude Include="MainFrm.h" />
    <ClInclude Include="propdlg.h" />
    <ClInclude Include="propproc.h" />
    <ClInclude Include="propstack.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="View.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="procmon_gui.rc" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="C:\Users\pgboy\Desktop\check.png" />
    <Image Include="res\check.ico" />
    <Image Include="res\file.ico" />
    <Image Include="res\icon1.ico" />
    <Image Include="res\process.ico" />
    <Image Include="res\procmon_gui.ico" />
    <Image Include="res\registry.ico" />
    <Image Include="res\remove.ico" />
    <Image Include="res\tool.bmp" />
    <Image Include="res\toolbar.bmp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`gui/procmon_gui.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{99530944-f98a-49be-b4ba-6e6fee24177f}</UniqueIdentifier>
      <Extensions>cpp;c;cxx;def;odl;idl;hpj;bat;asm</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{fde2df5e-29d4-467a-80fb-069ca52c8367}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{307fa78e-d1cb-47ac-b370-352cbd4d6356}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;jpg;jpeg;jpe;manifest</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="dataview.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="propevent.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="propdlg.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="filter.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="filtermgr.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="propstack.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="filterdlg.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="MainFrm.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="View.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AboutDlg.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="propproc.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="propstack.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="dataview.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="propdlg.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="propevent.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="filter.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="filtermgr.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="fltprocess.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="filterdlg.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="procmon_gui.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="res\toolbar.bmp">
      <Filter>Resource Files</Filter>
    </Image>
    <Image Include="res\procmon_gui.ico">
      <Filter>Resource Files</Filter>
    </Image>
    <Image Include="res\icon1.ico">
      <Filter>Resource Files</Filter>
    </Image>
    <Image Include="res\tool.bmp">
      <Filter>Resource Files</Filter>
    </Image>
    <Image Include="res\file.ico">
      <Filter>Resource Files</Filter>
    </Image>
    <Image Include="res\process.ico">
      <Filter>Resource Files</Filter>
    </Image>
    <Image Include="res\registry.ico">
      <Filter>Resource Files</Filter>
    </Image>
    <Image Include="C:\Users\pgboy\Desktop\check.png" />
    <Image Include="res\check.ico">
      <Filter>Resource Files</Filter>
    </Image>
    <Image Include="res\remove.ico">
      <Filter>Resource Files</Filter>
    </Image>
  </ItemGroup>
</Project>
```

`gui/procmon_gui.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <RESOURCE_FILE>procmon_gui.rc</RESOURCE_FILE>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <RemoteDebuggerCommand>C:\tools\procmon_gui.exe</RemoteDebuggerCommand>
    <RemoteDebuggerWorkingDirectory>C:\tools\</RemoteDebuggerWorkingDirectory>
    <RemoteDebuggerServerName>192.168.10.159</RemoteDebuggerServerName>
    <RemoteDebuggerConnection>RemoteWithoutAuthentication</RemoteDebuggerConnection>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
</Project>
```

`gui/propdlg.cpp`:

```cpp
#include "stdafx.h"
#include "resource.h"
#include "propdlg.h"


```

`gui/propdlg.h`:

```h
#pragma once

#include "propevent.h"
#include "propproc.h"
#include "propstack.h"

class CPropertiesDlg : public CDialogImpl<CPropertiesDlg>, public CDialogResize<CPropertiesDlg>
{
public:
	enum {
		IDD = IDD_DIALOG_PROPERTIES
	};

	BEGIN_MSG_MAP(CPropertiesDlg)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		NOTIFY_HANDLER(IDC_TAB_PROPERTIES, TCN_SELCHANGE, OnSelTabChange)
		COMMAND_HANDLER(IDC_PROPERITES_COPYALL, BN_CLICKED, OnCopyAllClick)
		COMMAND_HANDLER(ID_PROPERITIES_CLOSE, BN_CLICKED, OnCloseCmd)
		COMMAND_ID_HANDLER(IDCANCEL, OnCloseCmd)
		MESSAGE_HANDLER(WM_SIZE, OnSize)
		CHAIN_MSG_MAP(CDialogResize<CPropertiesDlg>)
	END_MSG_MAP()

	BEGIN_DLGRESIZE_MAP(CPropertiesDlg)
		DLGRESIZE_CONTROL(ID_PROPERITIES_CLOSE, DLSZ_MOVE_X | DLSZ_MOVE_Y)
		DLGRESIZE_CONTROL(IDC_PROPERITES_COPYALL, DLSZ_MOVE_X | DLSZ_MOVE_Y)
		DLGRESIZE_CONTROL(IDC_TAB_PROPERTIES, DLSZ_SIZE_X | DLSZ_SIZE_Y)
		DLGRESIZE_CONTROL(IDC_PROPERITES_PREV, DLSZ_MOVE_Y)
		DLGRESIZE_CONTROL(IDC_PROPERTIES_NEXT, DLSZ_MOVE_Y)
		DLGRESIZE_CONTROL(IDC_PROPERTIES_CHECK, DLSZ_MOVE_Y)
	END_DLGRESIZE_MAP()

	void Resize()
	{
		CRect rcItem;
		m_TabCtrl.GetItemRect(0, &rcItem);

		CRect rc;
		m_TabCtrl.GetClientRect(&rc);

		rc.top += rcItem.Height();

		for (int i = 0; i < _countof(m_DiaLogArray); i++)
		{
			m_DiaLogArray[i]->MoveWindow(rc);
		}
	}

	void SetCurTab(int index)
	{
		if (index <0 || index >= 3) {
			return;
		}

		for (int i = 0; i < _countof(m_DiaLogArray); i++)
		{
			if (i == index){
				m_DiaLogArray[i]->ShowWindow(SW_SHOW);
				m_DiaLogArray[i]->EnableWindow(TRUE);
				m_preCurSel = i;
			}else{
				m_DiaLogArray[i]->ShowWindow(SW_HIDE);
			}
		}
	}

	void PreSetCurTab(int index)
	{
		m_preCurSel = index;
	}

	LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		DlgResize_Init();

		m_TabCtrl = GetDlgItem(IDC_TAB_PROPERTIES);
		m_TabCtrl.ModifyStyleEx(0, WS_EX_CONTROLPARENT);

		m_TabCtrl.AddItem(TEXT("Event"));
		m_TabCtrl.AddItem(TEXT("Process"));
		m_TabCtrl.AddItem(TEXT("Stack"));

		m_EventDlg.Create(m_TabCtrl);
		m_ProcDlg.Create(m_TabCtrl);
		m_StackDlg.Create(m_TabCtrl);

		m_DiaLogArray[0] = &m_EventDlg;
		m_DiaLogArray[1] = &m_ProcDlg;
		m_DiaLogArray[2] = &m_StackDlg;

		SetCurTab(m_preCurSel);
		m_TabCtrl.SetCurSel(m_preCurSel);

		Resize();

		CenterWindow(GetParent());

		return TRUE;
	}

	LRESULT OnSelTabChange(int /*idCtrl*/, LPNMHDR pnmh, BOOL& bHandled)
	{
		int nIndex = m_TabCtrl.GetCurSel();
		SetCurTab(nIndex);
		return 0;

	}

	LRESULT OnCloseCmd(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		EndDialog(wID);
		return 0;
	}

	VOID CopyToClipboard(CString& strData) {

		if (strData.IsEmpty()){
			return;
		}

		OpenClipboard();
		EmptyClipboard();
		HGLOBAL hMem = GlobalAlloc(GMEM_MOVEABLE, (strData.GetLength() + 1) * sizeof(TCHAR));
		if (!hMem) {
			CloseClipboard();
			return;
		}
		
		//
		// Copy data
		//
		
		CopyMemory(GlobalLock(hMem), strData.GetBuffer(), (strData.GetLength() + 1) * sizeof(TCHAR));
		GlobalUnlock(hMem);
		
		//
		// set data
		//
		
#ifdef _UNICODE
		SetClipboardData(CF_UNICODETEXT, hMem);
#else
		SetClipboardData(CF_TEXT, hMem);
#endif
		
		//
		// Cleanup
		//
		
		CloseClipboard();
		GlobalFree(hMem);
	}

	LRESULT OnCopyAllClick(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		int nIndex = m_TabCtrl.GetCurSel();
		CString strCopy;
		switch (nIndex)
		{
		case 0:
			strCopy = m_EventDlg.CopyAll();
			break;
		case 1:
			strCopy = m_ProcDlg.CopyAll();
			break;
		case 2:
			strCopy = m_StackDlg.CopyAll();
		default:
			break;
		}

		CopyToClipboard(strCopy);

		return 0;
	}

	LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{

		CDialogResize<CPropertiesDlg>::OnSize(uMsg, wParam, lParam, bHandled);

		Resize();

		bHandled = TRUE;

		return 0;
	}

private:
	CTabCtrl m_TabCtrl;
 	CPropEventDlg m_EventDlg;
 	CPropProcDlg m_ProcDlg;
 	CPropStackDlg m_StackDlg;
	CWindow* m_DiaLogArray[3];
	int m_preCurSel = 0;
};


```

`gui/propevent.cpp`:

```cpp


#include "stdafx.h"
#include "resource.h"
#include "dataview.h"
#include "propevent.h"

LRESULT CPropEventDlg::OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
{
	CRefPtr<CEventView> pView = DATAVIEW().GetSelectView();
	if (pView.IsNull()){
		return 0;
	}

	CString strTime = UtilConvertTimeOfDay(pView->GetStartTime());

	GetDlgItem(IDC_EVENT_DATA).SetWindowText(strTime);
	GetDlgItem(IDC_EVENT_THREAD).SetWindowText(pView->GetOperationStrResult(emTID));
	GetDlgItem(IDC_EVENT_CLASS).SetWindowText(pView->GetOperationStrResult(emEventClass));
	GetDlgItem(IDC_EVENT_OPT).SetWindowText(pView->GetOperationStrResult(emOperation));
	GetDlgItem(IDC_EVENT_RET).SetWindowText(pView->GetOperationStrResult(emResult));
	GetDlgItem(IDC_EVENT_PATH).SetWindowText(pView->GetPath());
	
	//
	// Duration
	//
	
	GetDlgItem(IDC_EVENT_DURATION).SetWindowText(pView->GetOperationStrResult(emDuration));
	GetDlgItem(IDC_EVENT_DETAIL).SetWindowText(pView->GetDetail());

	return 0;
}


CString CPropEventDlg::CopyAll()
{
	CString strCopy;
	CString strTemp;
	CString strItem;

	GetDlgItemText(IDC_EVENT_DATA, strItem);
	strTemp.Format(TEXT("Date: %s\n"), strItem);
	strCopy += strTemp;

	GetDlgItemText(IDC_EVENT_THREAD, strItem);
	strTemp.Format(TEXT("Thread: %s\n"), strItem);
	strCopy += strTemp;

	GetDlgItemText(IDC_EVENT_CLASS, strItem);
	strTemp.Format(TEXT("Event Class: %s\n"), strItem);
	strCopy += strTemp;

	GetDlgItemText(IDC_EVENT_OPT, strItem);
	strTemp.Format(TEXT("Operation: %s\n"), strItem);
	strCopy += strTemp;

	GetDlgItemText(IDC_EVENT_RET, strItem);
	strTemp.Format(TEXT("Result: %s\n"), strItem);
	strCopy += strTemp;

	GetDlgItemText(IDC_EVENT_PATH, strItem);
	strTemp.Format(TEXT("Path: %s\n"), strItem);
	strCopy += strTemp;

	GetDlgItemText(IDC_EVENT_DURATION, strItem);
	strTemp.Format(TEXT("Duration: %s\n"), strItem);
	strCopy += strTemp;

	GetDlgItemText(IDC_EVENT_DETAIL, strItem);
	strTemp.Format(TEXT("Detail: %s\n"), strItem);
	strCopy += strTemp;

	return strCopy;
}



```

`gui/propevent.h`:

```h
#pragma once

class CPropEventDlg : public CDialogImpl<CPropEventDlg>
{
public:
	enum {
		IDD = PROP_EVENT
	};

	BEGIN_MSG_MAP(CPropEventDlg)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	END_MSG_MAP()

	LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/);
	CString CopyAll();
};

```

`gui/propproc.h`:

```h
#pragma once

#include "dataview.h"

extern
HICON
UtilGetDefaultIcon(
	BOOL bSmall
);

class CPropProcDlg : public CDialogImpl<CPropProcDlg>, public CDialogResize<CPropProcDlg>
{
public:
	enum {
		IDD = PROP_PROCESS
	};

	BEGIN_MSG_MAP(CPropProcDlg)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		CHAIN_MSG_MAP(CDialogResize<CPropProcDlg>)
	END_MSG_MAP()

	BEGIN_DLGRESIZE_MAP(CPropProcDlg)
		DLGRESIZE_CONTROL(IDC_PROCESS_PATH, DLSZ_SIZE_X)
		DLGRESIZE_CONTROL(IDC_PROCESS_CMDLINE, DLSZ_SIZE_X)
		DLGRESIZE_CONTROL(IDC_PROCESS_MODULES, DLSZ_SIZE_X | DLSZ_SIZE_Y)
		DLGRESIZE_CONTROL(IDC_PROC_GROUP_BOX, DLSZ_SIZE_X)
	END_DLGRESIZE_MAP()


	LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		DlgResize_Init(false);

		CRefPtr<CEventView> pView = DATAVIEW().GetSelectView();
		if (pView.IsNull()){
			return 0;
		}

		CString strTmp;
		CStatic ImgCtl = this->GetDlgItem(IDC_PROCESS_ICON);

		CBuffer& clsIconBuffer = pView->GetProcIcon(FALSE);

		HICON hIcon = NULL;
		if (!clsIconBuffer.Empty()) {

			//
			// Load from memory
			//

			int cxLarge = GetSystemMetrics(SM_CXICON);
			int cyLarge = GetSystemMetrics(SM_CYICON);

			hIcon = CreateIconFromResourceEx(clsIconBuffer.GetBuffer(),
				clsIconBuffer.GetBufferLen(), TRUE, 0x30000, cxLarge, cyLarge, 0);
		}else{
			hIcon = UtilGetDefaultIcon(FALSE);
		}

		ImgCtl.SetIcon(hIcon);

		this->GetDlgItem(IDC_PROCESS_DESC).SetWindowText( pView->GetOperationStrResult(emDescription));
		this->GetDlgItem(IDC_PROCESS_COMPANY).SetWindowText(pView->GetOperationStrResult(emCompany));
		this->GetDlgItem(IDC_PROCESS_NAME).SetWindowText(pView->GetOperationStrResult(emProcessName));
		this->GetDlgItem(IDC_PROCESS_VERSION).SetWindowText(pView->GetOperationStrResult(emVersion));

		this->GetDlgItem(IDC_PROCESS_PATH).SetWindowText(pView->GetOperationStrResult(emImagePath));
		this->GetDlgItem(IDC_PROCESS_CMDLINE).SetWindowText(pView->GetOperationStrResult(emCommandLine));


		this->GetDlgItem(IDC_PROCESS_PID).SetWindowText(pView->GetOperationStrResult(emPID));
		this->GetDlgItem(IDC_PROCESS_PPID).SetWindowText(pView->GetOperationStrResult(emParentPid));
		this->GetDlgItem(IDC_PROCESS_SESSION).SetWindowText(pView->GetOperationStrResult(emSession));

		
		//
		// User
		//
		
		this->GetDlgItem(IDC_PROCESS_USER).SetWindowText(pView->GetOperationStrResult(emUser));

		//
		// StartTime
		//
		
		this->GetDlgItem(IDC_PROCESS_STARTTIME).SetWindowText(pView->GetOperationStrResult(emDataTime));

		//
		// Ended
		//
		
		strTmp = pView->IsProcessExit() ? UtilConvertDay(pView->GetProcessExitTime()) : TEXT("Runing");
		this->GetDlgItem(IDC_PROCESS_ENDED).SetWindowText(strTmp);

		this->GetDlgItem(IDC_PROCESS_ARCH).SetWindowText(pView->GetOperationStrResult(emArchiteture));
		this->GetDlgItem(IDC_PROCESS_AUTHID).SetWindowText(pView->GetOperationStrResult(emAuthId));
		this->GetDlgItem(IDC_PROCESS_VIRTUALIZED).SetWindowText(pView->GetOperationStrResult(emVirtualize));

		
		//
		// Integrity
		//
		
		this->GetDlgItem(IDC_PROCESS_INTERGRITY).SetWindowText(pView->GetOperationStrResult(emIntegrity));

		
		//
		// set list control
		//
		
		m_ListCtrl = this->GetDlgItem(IDC_PROCESS_MODULES);

		m_ListCtrl.SetExtendedListViewStyle(LVS_EX_FULLROWSELECT);
		m_ListCtrl.InsertColumn(0, TEXT("Module"), 0, 150);
		m_ListCtrl.InsertColumn(1, TEXT("Address"), 0, 150);
		m_ListCtrl.InsertColumn(2, TEXT("Size"), 0, 100);
		m_ListCtrl.InsertColumn(3, TEXT("Path"), 0, 200);
		m_ListCtrl.InsertColumn(4, TEXT("Company"), 0, 100);
		m_ListCtrl.InsertColumn(5, TEXT("Version"), 0, 100);
		m_ListCtrl.InsertColumn(6, TEXT("Timestamp"), 0, 180);

		std::vector<CModule>& ModuleList = pView->GetModuleList();
		int nIndex = 0;
		for (auto it = ModuleList.begin(); it != ModuleList.end(); it++)
		{
			m_ListCtrl.InsertItem(nIndex, PathFindFileName(it->GetPath()));

			strTmp.Format(TEXT("0x%p"), it->GetImageBase());
			m_ListCtrl.SetItemText(nIndex, 1, strTmp);
			
			strTmp.Format(TEXT("%08x"), it->GetSize());
			m_ListCtrl.SetItemText(nIndex, 2, strTmp);

			m_ListCtrl.SetItemText(nIndex, 3, it->GetPath());

			nIndex++;
		}

		return 0;
	}

	CString CopyAll()
	{
		CString strCopy;
		CString strTemp;
		CString strItem;

		GetDlgItemText(IDC_PROCESS_DESC, strItem);
		strTemp.Format(TEXT("Description: %s\n"), strItem);
		strCopy += strTemp;

		GetDlgItemText(IDC_PROCESS_COMPANY, strItem);
		strTemp.Format(TEXT("Compnay: %s\n"), strItem);
		strCopy += strTemp;

		GetDlgItemText(IDC_PROCESS_NAME, strItem);
		strTemp.Format(TEXT("Process Name: %s\n"), strItem);
		strCopy += strTemp;

		GetDlgItemText(IDC_PROCESS_VERSION, strItem);
		strTemp.Format(TEXT("Version: %s\n"), strItem);
		strCopy += strTemp;

		GetDlgItemText(IDC_PROCESS_ARCH, strItem);
		strTemp.Format(TEXT("Arch: %s\n"), strItem);
		strCopy += strTemp;

		GetDlgItemText(IDC_PROCESS_AUTHID, strItem);
		strTemp.Format(TEXT("Auth Id: %s\n"), strItem);
		strCopy += strTemp;

		GetDlgItemText(IDC_PROCESS_VIRTUALIZED, strItem);
		strTemp.Format(TEXT("Virtualized: %s\n"), strItem);
		strCopy += strTemp;

		GetDlgItemText(IDC_PROCESS_INTERGRITY, strItem);
		strTemp.Format(TEXT("Integrity: %s\n"), strItem);
		strCopy += strTemp;

		GetDlgItemText(IDC_PROCESS_PATH, strItem);
		strTemp.Format(TEXT("Image Path: %s\n"), strItem);
		strCopy += strTemp;

		GetDlgItemText(IDC_PROCESS_CMDLINE, strItem);
		strTemp.Format(TEXT("CommandLine: %s\n"), strItem);
		strCopy += strTemp;

		GetDlgItemText(IDC_PROCESS_PID, strItem);
		strTemp.Format(TEXT("Pid: %s\n"), strItem);
		strCopy += strTemp;

		GetDlgItemText(IDC_PROCESS_PPID, strItem);
		strTemp.Format(TEXT("Parent Pid: %s\n"), strItem);
		strCopy += strTemp;

		GetDlgItemText(IDC_PROCESS_SESSION, strItem);
		strTemp.Format(TEXT("Session id: %s\n"), strItem);
		strCopy += strTemp;

		GetDlgItemText(IDC_PROCESS_USER, strItem);
		strTemp.Format(TEXT("User: %s\n"), strItem);
		strCopy += strTemp;

		GetDlgItemText(IDC_PROCESS_STARTTIME, strItem);
		strTemp.Format(TEXT("StartTime: %s\n"), strItem);
		strCopy += strTemp;

		GetDlgItemText(IDC_PROCESS_ENDED, strItem);
		strTemp.Format(TEXT("Ended: %s\n"), strItem);
		strCopy += strTemp;

		for (int i = 0; i < m_ListCtrl.GetItemCount(); i++)
		{
			strTemp.Format(TEXT("%d"), i);
			
			for (int j = 0; j < m_ListCtrl.GetHeader().GetItemCount(); j++)
			{
				m_ListCtrl.GetItemText(i, j, strItem);
				strTemp += TEXT(" ");
				strTemp += strItem;
			}

			strTemp += TEXT("\n");
			strCopy += strTemp;
		}

		return strCopy;
	}

private:
	CListViewCtrl m_ListCtrl;
};
```

`gui/propstack.cpp`:

```cpp

#include "stdafx.h"
#include "resource.h"
#include <psapi.h>
#include <DbgHelp.h>
#include "propstack.h"

#pragma comment(lib, "dbghelp.lib")

BOOL CProcessInfo::LookupSymbolByAddress(
	IN LPVOID lpAddress,
	OUT CString& strSymbol
)
{
	ULONG_PTR imageLoadBase = 0;
	ULONG_PTR imageBase;
	ULONG_PTR Offset;

	//
	// get the module 
	//

	CRefPtr<CModuleInfo> pModule = LookupModuleByAddress(lpAddress);
	if (pModule.IsNull()) {
		return FALSE;
	}

	Offset = (ULONG_PTR)lpAddress - (ULONG_PTR)pModule->getBaseAddress();

	//
	// Init the symbol
	//

	strSymbol.Format(TEXT("%s+%x"), PathFindFileName(pModule->getPath()), (ULONG)Offset);

	//
	// Load the image in our process
	//

	imageLoadBase = (ULONG_PTR)LoadLibraryEx(pModule->getPath(),
		NULL,
		DONT_RESOLVE_DLL_REFERENCES);

	if (!imageLoadBase) {
		LogMessage(L_WARN, TEXT("Failed to load image \"%s\" to memory err 0x%x"),
			(LPCTSTR)pModule->getPath(), GetLastError());
		return FALSE;
	}

	MODULEINFO ModInfo;
	if (!GetModuleInformation(GetCurrentProcess(), (HMODULE)imageLoadBase,
		&ModInfo, sizeof(ModInfo))) {
		return FALSE;
	}

	//
	// Attach symbols to our module
	//

	CStringW strModuleName = CT2W(pModule->getPath());
	LPCWSTR lpModuleName = PathFindFileNameW(strModuleName);

	imageBase = SymLoadModuleExW(GetCurrentProcess(),
		NULL,
		lpModuleName,
		lpModuleName,
		imageLoadBase,
		ModInfo.SizeOfImage,//0,
		NULL,
		0);

	if (imageBase != imageLoadBase) {
		FreeLibrary((HMODULE)imageLoadBase);
		LogMessage(L_ERROR, TEXT("Failed load symbols for %s"), (LPCTSTR)pModule->getPath());
		return FALSE;
	}

	//
	// get the symbol name
	//

	ULONG_PTR Displacement = 0;
	SYMBOL_INFO_PACKAGEW SymbolInfo;

	RtlZeroMemory(&SymbolInfo, sizeof(SymbolInfo));
	SymbolInfo.si.SizeOfStruct = sizeof(SYMBOL_INFO);
	SymbolInfo.si.MaxNameLen = sizeof(SymbolInfo.name);

	if (SymFromAddrW(GetCurrentProcess(), imageLoadBase + Offset,
		&Displacement, &SymbolInfo.si)) {
		CStringW strStmbolW;

		if (Displacement) {
			strStmbolW.Format(L"%s!%s+%.8llx", lpModuleName,
				SymbolInfo.si.Name, Displacement);
		}else{
			strStmbolW.Format(L"%s!%s", lpModuleName,
				SymbolInfo.si.Name);
		}

		strSymbol = CW2T(strStmbolW);
	}

	FreeLibrary((HMODULE)imageLoadBase);
	SymUnloadModule64(GetCurrentProcess(), imageBase);

	return TRUE;
}

typedef struct _RTL_PROCESS_MODULE_INFORMATION {
	HANDLE Section;                 // Not filled in
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR  FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES {
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;
#define STATUS_INFO_LENGTH_MISMATCH ((NTSTATUS)0xC0000004L)

BOOL CProcessInfo::ListKernelModule()
{
	DWORD dwNeed = 0;
	DWORD dwBytes = 100;
	PRTL_PROCESS_MODULES lpModuleInfo = NULL;
	BOOL bOk = FALSE;
	NTSTATUS Status;

	do {

		if (lpModuleInfo) {
			LocalFree(lpModuleInfo);
		}

		lpModuleInfo = (PRTL_PROCESS_MODULES)LocalAlloc(0, dwBytes);
		if (!lpModuleInfo) {
			break;
		}

		Status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)11, lpModuleInfo, dwBytes, &dwNeed);
		if (!NT_SUCCESS(Status)) {
			if (Status == STATUS_INFO_LENGTH_MISMATCH) {
				dwBytes = dwNeed;
				continue;
			}
		}else{
			bOk = TRUE;
			break;
		}

	} while (TRUE);

	if (bOk) {
		for (int i = 0; i < (int)lpModuleInfo->NumberOfModules; i++) {

			CString strDosPath;
			CString strNtPath;

			strNtPath = lpModuleInfo->Modules[i].FullPathName;

			if (UtilConvertNtInternalPathToDosPath(strNtPath, strDosPath)) {
				CRefPtr<CModuleInfo> pModuleInfo = new CModuleInfo;
				if (pModuleInfo->Init(strDosPath, lpModuleInfo->Modules[i].ImageBase, lpModuleInfo->Modules[i].ImageSize)) {
					m_ModuleList.push_back(pModuleInfo);
				}
			}
		}
	}



	if (lpModuleInfo) {
		LocalFree(lpModuleInfo);
	}

	return bOk;
}

BOOL 
CProcessInfo::ListModule(
	DWORD dwProcessId
)
{
	BOOL bRet = FALSE;
	HMODULE* phModules = NULL;
	DWORD dwSize = 0x200 * sizeof(HMODULE);
	DWORD cbNeeded = 0;
	BOOL bOpened = FALSE;

	m_ModuleList.clear();

	//
	// List Kernel module first
	//
	
	ListKernelModule();

	HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ | PROCESS_QUERY_LIMITED_INFORMATION, FALSE, dwProcessId);
	if (!hProcess) {
		return FALSE;
	}

	//m_ModuleList.clear();

	do
	{

		if (phModules) {
			LocalFree(phModules);
		}

		//
		// Reallocate buffer
		//

		phModules = (HMODULE*)LocalAlloc(0, dwSize);
		if (!phModules) {
			bRet = FALSE;
			break;
		}

		//
		// get need size of buffer
		//

		bRet = EnumProcessModulesEx(hProcess, phModules, dwSize, &cbNeeded, LIST_MODULES_ALL);
		if (!bRet) {
			break;
		}

		if (cbNeeded > dwSize) {
			dwSize += (0x200 * sizeof(HMODULE));
		}
		else {
			break;
		}

	} while (TRUE);


	if (bRet) {
		for (int i = 0; i < (cbNeeded / sizeof(HMODULE)); i++)
		{
			CRefPtr<CModuleInfo> pModule = new CModuleInfo;

			//
			// Init module information
			//

			if (pModule->Init(hProcess, phModules[i])) {

				//
				// save the module information
				//

				m_ModuleList.push_back(pModule);
			}
			else {
				LogMessage(L_WARN, TEXT("Faile to init module 0x%p err 0x%x"), phModules[i], GetLastError());
			}
		}
	}

	if (phModules) {
		LocalFree(phModules);
	}

	if (bOpened) {
		CloseHandle(hProcess);
	}

	return bRet;
}

CRefPtr<CModuleInfo>
CProcessInfo::LookupModuleByAddress(
	IN LPVOID lpAddress
)
{
	for (auto it = m_ModuleList.begin(); it != m_ModuleList.end(); it++) {
		if ((*it)->IsAddressIn(lpAddress)) {
			return *it;
		}
	}
	return NULL;
}

BOOL 
CProcessInfo::ListModuleFromLog(
	std::vector<CModule>& modList
)
{
	m_ModuleList.clear();

	//
	// List Kernel module first
	//

	ListKernelModule();

	for (auto it = modList.begin(); it != modList.end(); it++)
	{
		CRefPtr<CModuleInfo> pModule = new CModuleInfo;
		if (pModule->Init(*it)) {
			m_ModuleList.push_back(pModule);
		}
	}

	return TRUE;
}


void CResolveSymbolThread::Run()
{
	CPropStackDlg* pDlg = reinterpret_cast<CPropStackDlg*>(getParam());
	int i = 0;
	for (auto it = m_FrameStack.begin(); it != m_FrameStack.end(); it++, i++)
	{
		CString strSymbol;
		if (m_ProcInfo->LookupSymbolByAddress(*it, strSymbol)) {

			LPCTSTR lpszDup = _tcsdup(strSymbol.GetBuffer());
			pDlg->PostMessage(WM_SYMBOL_PARSE, (WPARAM)i, (LPARAM)lpszDup);
		}else{
			pDlg->PostMessage(WM_SYMBOL_PARSE, (WPARAM)i, NULL);
		}
	}
}

void CResolveSymbolThread::SetProcInf(CRefPtr<CProcessInfo> pProcInfo)
{
	m_ProcInfo = pProcInfo;
}

void CResolveSymbolThread::SetFrameStack(std::vector<PVOID>& FrameStack)
{
	m_FrameStack = FrameStack;
}

BOOL CModuleInfo::Init(CModule& Module)
{
	m_pBase = Module.GetImageBase();
	m_Size = Module.GetSize();
	m_strPath = Module.GetPath();

	return TRUE;
}

BOOL CModuleInfo::Init(IN HANDLE hProcess, IN HMODULE hModule)
{
	TCHAR szModName[MAX_PATH] = { 0 };
	MODULEINFO modInfo;

	//
	// query module basic information
	//

	if (!GetModuleInformation(hProcess, hModule, &modInfo, sizeof(modInfo))) {
		LogMessage(L_ERROR, TEXT("Failed to get module information err 0x%x"), GetLastError());
		return FALSE;
	}

	m_pBase = modInfo.lpBaseOfDll;
	m_Size = modInfo.SizeOfImage;

	//
	// query module image name
	//

	if (!GetModuleFileNameEx(hProcess, hModule, szModName, MAX_PATH)) {
		LogMessage(L_ERROR, TEXT("Failed to get module filename err 0x%x"), GetLastError());
		return FALSE;
	}

	m_strPath = szModName;

	return TRUE;
}

BOOL CModuleInfo::Init(IN const CString& strPath, IN PVOID pImageBase, IN ULONG Size)
{
	m_pBase = pImageBase;
	m_Size = Size;
	m_strPath = strPath;
	return TRUE;
}

BOOL CPropStackDlg::InitSymbol()
{
	//
	// Initialize symbol engine
	//

	BOOL b;
	DWORD Options = SymGetOptions();

	//
	// SYMOPT_DEBUG option asks DbgHelp to print additional troubleshooting 
	// messages to debug output - use the debugger's Debug Output window 
	// to view the messages 
	//

	Options |= SYMOPT_DEFERRED_LOADS;
	SymSetOptions(Options);

	b = SymInitializeW(GetCurrentProcess(), NULL, TRUE);
	if (b == FALSE) {
		LogMessage(L_ERROR, TEXT("Failed to initialize symbol engine: %lx"), GetLastError());
	}

	return b;
}

void CPropStackDlg::CleanSymbols()
{
	SymCleanup(GetCurrentProcess());
}

LRESULT CPropStackDlg::OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
{
	DlgResize_Init();

	InitSymbol();

	CRefPtr<CEventView> pView = DATAVIEW().GetSelectView();
	m_ListCtrl = this->GetDlgItem(IDC_PROP_STACKLIST);
	m_StatusCtl = this->GetDlgItem(IDC_STATIC_STAUS);
	
	m_StatusCtl.SetWindowText(TEXT(""));

	m_ListCtrl.SetExtendedListViewStyle(LVS_EX_FULLROWSELECT);
	m_ListCtrl.InsertColumn(0, TEXT("Frame"), 0, 50);
	m_ListCtrl.InsertColumn(1, TEXT("Module"), 0, 100);
	m_ListCtrl.InsertColumn(2, TEXT("Location"), 0, 200);
	m_ListCtrl.InsertColumn(3, TEXT("Address"), 0, 150);
	m_ListCtrl.InsertColumn(4, TEXT("Path"), 0, 400);

	std::vector<PVOID> pStackFrame;
	pView->GetCallStack(pStackFrame);

	m_ProcInfo = new CProcessInfo;

	//
	// 首先判断进程是否在监控前已存在.
	// 如果是的话,再判断进程是否退出.
	// 如果没有退出的话,这里我们通过打开进程枚举模块的形式获取模块信息
	//

	if (pView->IsProcessFromInit() && !pView->IsProcessExit()) {

		//
		// 从进程中枚举模块
		//

		m_ProcInfo->ListModule(pView->GetProcessId());

	}else{

		//
		// 直接从记录中查找
		//

		m_ProcInfo->ListModuleFromLog(pView->GetModuleList());

	}

	int nIndex = 0;
	for (auto it = pStackFrame.begin(); it != pStackFrame.end(); it++)
	{
		CString strTmp;

		strTmp.Format(TEXT("%d"), nIndex);
		m_ListCtrl.InsertItem(nIndex, strTmp);

		strTmp.Format(TEXT("0x%p"), *it);
		m_ListCtrl.SetItemText(nIndex, 3, strTmp);

		CRefPtr<CModuleInfo> pModuleInfo = m_ProcInfo->LookupModuleByAddress(*it);
		if (!pModuleInfo.IsNull()) {
			m_ListCtrl.SetItemText(nIndex, 1, PathFindFileName(pModuleInfo->getPath()));
			m_ListCtrl.SetItemText(nIndex, 4, pModuleInfo->getPath());

			ULONG_PTR pOffset = (ULONG_PTR)(*it) - (ULONG_PTR)pModuleInfo->getBaseAddress();
			strTmp.Format(TEXT("%s+0x%p"), PathFindFileName(pModuleInfo->getPath()), pOffset);
			m_ListCtrl.SetItemText(nIndex, 2, strTmp);
		}else{
			m_ListCtrl.SetItemText(nIndex, 1, TEXT("<Unknown>"));
		}

		nIndex++;
	}

	m_ResoveSymbolThread.setParam((PVOID)this);
	m_ResoveSymbolThread.SetProcInf(m_ProcInfo);
	m_ResoveSymbolThread.SetFrameStack(pStackFrame);
	m_ResoveSymbolThread.SetTimeout(3);
	m_ResoveSymbolThread.Start();

	return TRUE;
}

LRESULT CPropStackDlg::OnDestroy(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
{
	m_ResoveSymbolThread.Stop();
	CleanSymbols();
	return TRUE;
}

CString CPropStackDlg::CopyAll()
{
	CString strCopy;
	
	for (int i = 0; i < m_ListCtrl.GetItemCount(); i++)
	{
		CString strTemp;
		for (int j = 0; j < m_ListCtrl.GetHeader().GetItemCount(); j++)
		{
			CString strItem;
			m_ListCtrl.GetItemText(i, j, strItem);
			strTemp += TEXT(" ");
			strTemp += strItem;
		}

		strTemp += TEXT("\n");
		strCopy += strTemp;
	}

	return strCopy;
}

LRESULT CPropStackDlg::OnSymbolParse(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
	int nIndex = (int)wParam;
	LPCTSTR lpszSymbol = (LPCTSTR)lParam;
	if (lpszSymbol){
		m_ListCtrl.SetItemText(nIndex, 2, lpszSymbol);
		free((PVOID)lpszSymbol);
	}

	if (nIndex < m_ListCtrl.GetItemCount()-1){
		CString strAddress;
		m_ListCtrl.GetItemText(nIndex, 3, strAddress);

		CString strShow;

		strShow.Format(TEXT("Parsing symbol for %s"), strAddress.GetBuffer());
		m_StatusCtl.SetWindowText(strShow);
	}else{
		m_StatusCtl.SetWindowText(TEXT(""));
	}

	return TRUE;

}
```

`gui/propstack.h`:

```h
#pragma once

#include "dataview.h"

#define WM_SYMBOL_PARSE WM_USER+250


class CModuleInfo : public CRefBase
{
public:
	CModuleInfo() {};
	virtual ~CModuleInfo() {};

	BOOL Init(CModule& Module);

	BOOL Init(IN HANDLE hProcess, IN HMODULE hModule);

	BOOL Init(IN const CString& strPath, IN PVOID pImageBase, IN ULONG Size);

	CString getName()
	{
		return PathFindFileName(m_strPath);
	}

	const CString& getPath()
	{
		return m_strPath;
	}
	LPVOID getBaseAddress()
	{
		return m_pBase;
	}

	ULONG getSize()
	{
		return m_Size;
	}

	BOOL IsAddressIn(LPVOID lpAddress)
	{
		if ((ULONG_PTR)lpAddress >= (ULONG_PTR)m_pBase &&
			(ULONG_PTR)(lpAddress) < ((ULONG_PTR)m_pBase + m_Size)) {
			return TRUE;
		}
		return FALSE;
	}

private:

	/** specific the module image path*/
	CString m_strPath;

	/** specific the module base address*/
	LPVOID m_pBase = NULL;

	/** specific the module image size*/
	ULONG m_Size = 0;
};

class CProcessInfo : public CRefBase
{
public:
	CProcessInfo()
	{

	}
	~CProcessInfo()
	{
	
	}

	BOOL LookupSymbolByAddress(
		IN LPVOID lpAddress,
		OUT CString& strSymbol
	);

	BOOL ListKernelModule();
	BOOL ListModule(DWORD dwProcessId);
	CRefPtr<CModuleInfo> LookupModuleByAddress(IN LPVOID lpAddress);
	BOOL ListModuleFromLog(std::vector<CModule>& modList);

private:
	std::vector<CRefPtr<CModuleInfo>> m_ModuleList;
};

class CResolveSymbolThread : public CThread
{
public:
	virtual void Run();
	void SetProcInf(CRefPtr<CProcessInfo> pProcInfo);
	void SetFrameStack(std::vector<PVOID>& FrameStack);

private:
	CRefPtr<CProcessInfo> m_ProcInfo;
	std::vector<PVOID> m_FrameStack;
};

class CPropStackDlg : public CDialogImpl<CPropStackDlg>, public CDialogResize<CPropStackDlg>
{
public:
	enum {
		IDD = PROP_STACKTRACE
	};

	BEGIN_MSG_MAP(CPropStackDlg)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
		MESSAGE_HANDLER(WM_SYMBOL_PARSE, OnSymbolParse)
		CHAIN_MSG_MAP(CDialogResize<CPropStackDlg>)
	END_MSG_MAP()

	BEGIN_DLGRESIZE_MAP(CPropStackDlg)
		DLGRESIZE_CONTROL(IDC_PROP_STACKLIST, DLSZ_SIZE_X | DLSZ_SIZE_Y)
		DLGRESIZE_CONTROL(IDC_BTN_PROPS, DLSZ_MOVE_X | DLSZ_MOVE_Y)
		DLGRESIZE_CONTROL(IDC_BTN_SAVE, DLSZ_MOVE_X | DLSZ_MOVE_Y)
		DLGRESIZE_CONTROL(IDC_BTN_SEARCH, DLSZ_MOVE_X | DLSZ_MOVE_Y)
		DLGRESIZE_CONTROL(IDC_BTN_SOURCE, DLSZ_MOVE_X | DLSZ_MOVE_Y)
		DLGRESIZE_CONTROL(IDC_STATIC_STAUS, DLSZ_MOVE_Y | DLSZ_SIZE_X)
	END_DLGRESIZE_MAP()

	BOOL InitSymbol();
	void CleanSymbols();
	LRESULT OnSymbolParse(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/);
	LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/);
	LRESULT OnDestroy(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/);

	CString CopyAll();

private:
	CRefPtr<CProcessInfo> m_ProcInfo;
	CResolveSymbolThread m_ResoveSymbolThread;
	CListViewCtrl m_ListCtrl;
	CStatic m_StatusCtl;
	
};

```

`gui/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ 生成的包含文件。
// 供 procmon_gui.rc 使用
//
#define IDD_ABOUTBOX                    100
#define IDC_FILTER_CANCEL               106
#define IDR_MAINFRAME                   128
#define IDC_LISTCTRL                    129
#define IDD_DIALOG_PROPERTIES           204
#define PROP_EVENT                      205
#define PROP_PROCESS                    206
#define PROP_STACKTRACE                 207
#define IDR_TOOL                        215
#define IDI_ICON_FILE                   219
#define IDI_ICON_PROCESS                220
#define IDI_ICON_REGISTERY              221
#define IDD_PROGRESS                    222
#define FILTER_INIT                     223
#define IDB_PNG1                        226
#define IDI_ICON_ENABLE                 227
#define IDI_ICON_ENABLE1                228
#define IDI_ICON_DISABLE                228
#define ID_PROPERITIES_CLOSE            300
#define IDC_STATIC20                    1000
#define IDC_EVENT_DETAIL                1017
#define IDC_FILTER_OPT                  1018
#define IDC_FILTER_SRC                  1019
#define IDC_FILTER_RET                  1022
#define IDC_EVENT_PATH                  1027
#define IDC_EVENT_DURATION              1028
#define IDC_EVENT_THREAD                1029
#define IDC_EVENT_CLASS                 1030
#define IDC_PROCESS_ICON                1031
#define IDC_PROCESS_COMPANY             1034
#define IDC_PROCESS_DESC                1035
#define IDC_PROP_STACKLIST              1036
#define IDC_TAB_PROPERTIES              1038
#define IDC_EVENT_DATA                  1040
#define IDC_EVENT_OPT                   1041
#define IDC_EVENT_RET                   1042
#define IDC_PROPERITES_PREV             1050
#define IDC_PROPERTIES_NEXT             1051
#define IDC_PROPERTIES_CHECK            1054
#define IDC_STATIC_STAUS                1071
#define IDC_BTN_PROPS                   1072
#define IDC_FILTER_APPLY                1094
#define IDC_BTN_SAVE                    1097
#define IDC_PROPERITES_COPYALL          1118
#define IDC_BTN_SOURCE                  1121
#define IDC_PROCESS_STARTTIME           1133
#define IDC_PROCESS_USER                1134
#define IDC_PROCESS_SESSION             1135
#define IDC_PROCESS_PPID                1136
#define IDC_PROCESS_PID                 1137
#define IDC_PROCESS_ARCH                1138
#define IDC_PROCESS_AUTHID              1139
#define IDC_PROCESS_VIRTUALIZED         1140
#define IDC_PROCESS_INTERGRITY          1141
#define IDC_PROCESS_ENDED               1142
#define IDC_PROC_GROUP_BOX              1200
#define IDC_PROCESS_PATH                1201
#define IDC_PROCESS_CMDLINE             1202
#define IDC_PROCESS_NAME                1203
#define IDC_PROCESS_VERSION             1204
#define IDC_PROCESS_MODULES             1205
#define IDC_FILTER_OK                   1312
#define IDC_FILTER_LIST                 1317
#define IDC_FILTER_ADD                  1320
#define IDC_FILTER_REMOVE               1321
#define IDC_FILTER_DEST                 1323
#define IDC_FILTER_THEN                 1324
#define IDC_FILTER_RESET                1325
#define ID_BUTTON_ICONS8_SAVE           32775
#define ID_BUTTON_ICONS8_START          32776
#define ID_BUTTON_ICONS8_STOP           32777
#define ID_BUTTON_ICONS8_SCROLLDOWN     32778
#define ID_BUTTON_ICONS8_SCROLLUP       32779
#define ID_BUTTON_ICONS8_ERASE          32780
#define ID_BUTTON_ICONS8_PROCESS        32781
#define ID_BUTTON_ICONS8_FILE           32782
#define ID_BUTTON_ICONS8_REGISTRY       32783
#define ID_BUTTON_ICONS8_OPENEDF        32785
#define ID_BUTTON_ICONS8_FILTER         32786
#define IDC_BTN_SEARCH                  40106

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        229
#define _APS_NEXT_COMMAND_VALUE         32788
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`gui/stdafx.cpp`:

```cpp
// stdafx.cpp : source file that includes just the standard includes
//	procmon_gui.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

```

`gui/stdafx.h`:

```h
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//  are changed infrequently
//

#pragma once

// Change these values to use different versions
//#define WINVER		0x0601
//#define _WIN32_WINNT	0x0601
//#define _WIN32_IE	0x0700
//#define _RICHEDIT_VER	0x0500

#include <atlstr.h>
#include <atltypes.h>
#include <atlbase.h>
#include <atlapp.h>

extern CAppModule _Module;

#include <atlwin.h>
#include <atlframe.h>
#include <atlctrls.h>
#include <atldlgs.h>
#include <atlctrlw.h>

#include "../sdk/procmonsdk/sdk.hpp"

#if defined _M_IX86
  #pragma comment(linker, "/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='x86' publicKeyToken='6595b64144ccf1df' language='*'\"")
#elif defined _M_IA64
  #pragma comment(linker, "/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='ia64' publicKeyToken='6595b64144ccf1df' language='*'\"")
#elif defined _M_X64
  #pragma comment(linker, "/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='amd64' publicKeyToken='6595b64144ccf1df' language='*'\"")
#else
  #pragma comment(linker, "/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
#endif

```

`kernel/CMakeLists.txt`:

```txt
project(procmon)

set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} /W4 /WX /wd4996")
set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} /INTEGRITYCHECK")

find_package(WDK REQUIRED)

file(GLOB DRIVER_HEADER *.h)
file(GLOB DRIVER_SOURCES *.c)

#source_group("inc" FILES ${DRIVER_HEADER})
#source_group("source" FILES ${DRIVER_SOURCES})
set(DRIVER_RC procmon.rc)

wdk_add_driver(procmon
    ${DRIVER_HEADER}
    ${DRIVER_SOURCES}
    ${DRIVER_RC}
)


target_link_libraries(procmon WDK::FLTMGR WDK::WDMSEC)
```

`kernel/file.c`:

```c

#include <ntifs.h>
#include "globals.h"
#include "log.h"
#include "utils.h"
#include "file.h"

PVOLUME_INFO gVolumeNamesList = NULL;
PPAGING_FILEINFO_LIST gPagingFileInfoList = NULL;

PUNICODE_STRING
FindPagingFileNameInList(
	_In_ PFILE_OBJECT FileObject
)
/*++

Routine Description:

	.

Arguments:

	FileObject -

Return Value:

	Routine can return non success error codes.

--*/
{
	KIRQL OldIrql = DISPATCH_LEVEL;
	PUNICODE_STRING pStrNameInfo = NULL;
	PPAGING_FILEINFO_LIST pFileNameInfo;

	if (KeGetCurrentIrql() < DISPATCH_LEVEL)
		OldIrql = KeAcquireSpinLockRaiseToDpc(&gFileNameInfoListSpinLock);
	if (gPagingFileInfoList) {

		for (pFileNameInfo = gPagingFileInfoList;
			pFileNameInfo;
			pFileNameInfo = pFileNameInfo->Next)
		{

			//
			// If the fileobject match we pass in
			// then copy the filename
			//

			if (pFileNameInfo->FileObject == FileObject) {
				pStrNameInfo = ProcmonDuplicateUnicodeString(NonPagedPool,
					&pFileNameInfo->FileName, '1');
			}
		}
	}
	if (OldIrql != DISPATCH_LEVEL)
		KeReleaseSpinLock(&gFileNameInfoListSpinLock, OldIrql);
	return pStrNameInfo;
}

VOID
AddToPagingFileNameList(
	_In_ PFILE_OBJECT FileObject,
	_In_ PUNICODE_STRING pStrFileName
)
/*++

Routine Description:

	.

Arguments:

	FileObject -
	pStrFileName -

Return Value:

	None.

--*/
{
	KIRQL OldIrql;
	PPAGING_FILEINFO_LIST pNewInfo;

	OldIrql = KeAcquireSpinLockRaiseToDpc(&gFileNameInfoListSpinLock);

	//
	// Check is the fileobject already in list
	//

	if (!FindPagingFileNameInList(FileObject)) {
		pNewInfo = (PPAGING_FILEINFO_LIST)ProcmonAllocatePoolWithTag(NonPagedPool,
			pStrFileName->Length + sizeof(PAGING_FILEINFO_LIST), '1');
		if (pNewInfo) {

			//
			// Fill the info
			//

			pNewInfo->FileObject = FileObject;
			pNewInfo->FileName.Length = pStrFileName->Length;
			pNewInfo->FileName.Buffer = (PWSTR)(pNewInfo + 1);
			RtlCopyMemory(pNewInfo->FileName.Buffer, pStrFileName->Buffer, pStrFileName->Length);

			//
			// Add to list
			//

			pNewInfo->Next = gPagingFileInfoList;
			gPagingFileInfoList = pNewInfo;
		}
	}
	KeReleaseSpinLock(&gFileNameInfoListSpinLock, OldIrql);
}


BOOLEAN
ProcmonIsFileInSystemRoot(
	_In_ PUNICODE_STRING pUniStrImageName
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	USHORT SavedLength;
	LONG nRet;
	BOOLEAN bRet = FALSE;

	SavedLength = pUniStrImageName->Length;
	if (pUniStrImageName->Length <= gUniStrSystemRoot.Length)
		return FALSE;
	pUniStrImageName->Length = gUniStrSystemRoot.Length;
	nRet = RtlCompareUnicodeString(&gUniStrSystemRoot, pUniStrImageName, TRUE);
	pUniStrImageName->Length = SavedLength;
	if (!nRet)
		bRet = 1;
	return bRet;
}

BOOLEAN
ProcmonIsFileExist(
	_In_ PUNICODE_STRING pUniStrFileName
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	NTSTATUS Status;
	IO_STATUS_BLOCK IoStatusBlock;
	OBJECT_ATTRIBUTES ObjectAttributes;
	HANDLE FileHandle;

	InitializeObjectAttributes(&ObjectAttributes, pUniStrFileName, 0x240, NULL, NULL);

	Status = FltCreateFile(gFilterHandle, NULL, &FileHandle, 0,
		&ObjectAttributes, &IoStatusBlock, NULL, 0, 7u, 1u, 0, NULL, 0, 0);
	if (NT_SUCCESS(Status))
		FltClose(FileHandle);
	return Status == STATUS_SUCCESS;
}

BOOLEAN
ProcmonAppendVolumeName(
	_In_ PCUNICODE_STRING pUniStrImageName,
	_Inout_ PUNICODE_STRING pUniStrFullName
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	ULONG Index, IndexTmp;
	BOOLEAN ErrorMode;
	VOLUME_INFO *pVolumeInfo;
	USHORT Length;

	Index = 0;
	ErrorMode = IoSetThreadHardErrorMode(FALSE);
	while (1)
	{
		ExAcquireFastMutex(&gMutexVolume);
		pVolumeInfo = gVolumeNamesList;
		if (Index)
		{
			IndexTmp = Index;
			do
			{
				pVolumeInfo = pVolumeInfo->Next;
				--IndexTmp;
			} while (IndexTmp);
		}
		if (!pVolumeInfo)
			break;
		Length = pUniStrImageName->Length + pVolumeInfo->Name.Length;
		pUniStrFullName->MaximumLength = Length;
		pUniStrFullName->Buffer = (PWCH)ProcmonAllocatePoolWithTag(NonPagedPool, Length, 'I');;
		if (!pUniStrFullName->Buffer)
			break;
		pUniStrFullName->Length = pVolumeInfo->Name.Length;
		RtlCopyMemory(pUniStrFullName->Buffer, pVolumeInfo->Name.Buffer, pVolumeInfo->Name.Length);
		ExReleaseFastMutex(&gMutexVolume);
		RtlAppendUnicodeStringToString(pUniStrFullName, pUniStrImageName);
		if (ProcmonIsFileExist(pUniStrFullName))
			return IoSetThreadHardErrorMode(ErrorMode);
		ExFreePoolWithTag(pUniStrFullName->Buffer, 0);
		pUniStrFullName->Buffer = NULL;
		++Index;
	}
	ExReleaseFastMutex(&gMutexVolume);
	return IoSetThreadHardErrorMode(ErrorMode);
}

VOID
ProcmonEnumAllVolumes(
	VOID
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	NTSTATUS Status;
	ULONG NumberVolumesReturned;
	PFLT_VOLUME *ppVolums;

	ExAcquireFastMutex(&gMutexVolume);

	//
	// Clear All volume name info
	//

	for (PVOLUME_INFO pVolumeInfo = gVolumeNamesList; gVolumeNamesList; pVolumeInfo = gVolumeNamesList)
	{
		gVolumeNamesList = pVolumeInfo->Next;
		ExFreePoolWithTag(pVolumeInfo->Name.Buffer, 0);
		ExFreePoolWithTag(pVolumeInfo, 0);
	}

	Status = FltEnumerateVolumes(gFilterHandle, NULL, 0, &NumberVolumesReturned);
	if (Status != STATUS_BUFFER_TOO_SMALL) {
		ExReleaseFastMutex(&gMutexVolume);
		return;
	}

	ppVolums = (PFLT_VOLUME *)ProcmonAllocatePoolWithTag(NonPagedPool, sizeof(PFLT_VOLUME) * NumberVolumesReturned, 'b');
	if (!ppVolums) {
		ExReleaseFastMutex(&gMutexVolume);
		return;
	}

	Status = FltEnumerateVolumes(gFilterHandle, ppVolums, NumberVolumesReturned, &NumberVolumesReturned);
	if (NT_SUCCESS(Status)) {

		for (ULONG i = 0; i < NumberVolumesReturned; i++)
		{
			BOOLEAN IsDiskObject = FALSE;
			DEVICE_TYPE DeviceType = IO_TYPE_DEVICE;
			PDEVICE_OBJECT pVolumeDevObj;
			PFLT_VOLUME pVolumes = ppVolums[i];
			Status = FltGetDiskDeviceObject(pVolumes, &pVolumeDevObj);
			if (NT_SUCCESS(Status)) {
				if (pVolumeDevObj->DeviceType == IO_TYPE_MASTER_ADAPTER ||
					pVolumeDevObj->DeviceType == IO_TYPE_CONTROLLER) {
					IsDiskObject = TRUE;
					DeviceType = pVolumeDevObj->DeviceType;
				}
				ObDereferenceObject(pVolumeDevObj);
				if (IsDiskObject) {
					BOOLEAN bOk = FALSE;
					ULONG BufferSizeNeeded;
					PVOLUME_INFO pVolumeInfo = NULL;

					do
					{
						PVOLUME_INFO *ppVolumeNext;
						PVOLUME_INFO pVolumeInfoInsert;

						pVolumeInfo = (PVOLUME_INFO)ProcmonAllocatePoolWithTag(NonPagedPool, sizeof(VOLUME_INFO), 'b');
						if (!pVolumeInfo) {
							break;
						}

						//
						// Initialize Volume Info
						//

						pVolumeInfo->Type = DeviceType;
						pVolumeInfo->Name.Buffer = NULL;
						Status = FltGetVolumeName(pVolumes, NULL, &BufferSizeNeeded);
						if (Status != STATUS_BUFFER_TOO_SMALL) {
							break;
						}

						pVolumeInfo->Name.Buffer = (PWCH)ProcmonAllocatePoolWithTag(NonPagedPool, BufferSizeNeeded, 'b');
						if (!pVolumeInfo->Name.Buffer){
							break;
						}

						pVolumeInfo->Name.MaximumLength = (USHORT)BufferSizeNeeded;
						Status = FltGetVolumeName(pVolumes, &pVolumeInfo->Name, NULL);
						if (!NT_SUCCESS(Status)) {
							break;
						}

						ppVolumeNext = &gVolumeNamesList;
						if (DeviceType == IO_TYPE_MASTER_ADAPTER) {
							for (pVolumeInfoInsert = gVolumeNamesList; pVolumeInfoInsert; pVolumeInfoInsert = pVolumeInfoInsert->Next) {
								if (pVolumeInfoInsert->Type != IO_TYPE_MASTER_ADAPTER) {
									break;
								}
								ppVolumeNext = &pVolumeInfoInsert->Next;
							}
						}
						else {
							for (pVolumeInfoInsert = gVolumeNamesList; pVolumeInfoInsert; pVolumeInfoInsert = pVolumeInfoInsert->Next) {
								if (pVolumeInfoInsert->Type == IO_TYPE_CONTROLLER) {
									break;
								}
								ppVolumeNext = &pVolumeInfoInsert->Next;
							}
						}

						pVolumeInfo->Next = *ppVolumeNext;
						*ppVolumeNext = pVolumeInfo;
						bOk = TRUE;
					} while (FALSE);

					if (!bOk) {
						if (pVolumeInfo) {
							if (pVolumeInfo->Name.Buffer) {
								ExFreePoolWithTag(pVolumeInfo->Name.Buffer, 0);
							}
							ExFreePoolWithTag(pVolumeInfo, 0);
						}
					}
				}
			}
			FltObjectDereference(pVolumes);
		}
	}

	ExFreePoolWithTag(ppVolums, 0);
	ExReleaseFastMutex(&gMutexVolume);
}


NTSTATUS
EnableFileMonitor(
	_In_ BOOLEAN bEnable
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	NTSTATUS Status;
	PFLT_VOLUME *ppVolumes;
	ULONG NumberVolumesReturned = 0;
	LARGE_INTEGER Interval;

	FltEnumerateVolumes(gFilterHandle, NULL, 0, &NumberVolumesReturned);
	if (!NumberVolumesReturned)
		return STATUS_SUCCESS;

	ppVolumes = ProcmonAllocatePoolWithTag(PagedPool, sizeof(PFLT_VOLUME) * NumberVolumesReturned, 'I');
	if (ppVolumes) {
		Status = FltEnumerateVolumes(gFilterHandle, ppVolumes, sizeof(PFLT_VOLUME) * NumberVolumesReturned,
			&NumberVolumesReturned);
		if (NT_SUCCESS(Status) && NumberVolumesReturned) {
			for (int i = 0; i < (int)NumberVolumesReturned; i++)
			{
				PFLT_VOLUME pVolume = ppVolumes[i];

				if (bEnable) {
					while (FltAttachVolume(gFilterHandle, pVolume, NULL, NULL) == STATUS_FLT_DELETING_OBJECT)
					{
						Interval.QuadPart = -10000000;
						KeDelayExecutionThread(0, 1u, &Interval);
					}
				}else{
					FltDetachVolume(gFilterHandle, pVolume, NULL);
				}

				FltObjectDereference(pVolume);
			}

		}
		ExFreePoolWithTag(ppVolumes, 0);
	}
	return STATUS_SUCCESS;
}

PVOID
ProcmonCollectFileOptPostInfo(
	_In_ PETHREAD Thread,
	_In_ UCHAR MajorFunction,
	_In_ FLT_CALLBACK_DATA_FLAGS Flags,
	_In_ PFLT_IO_PARAMETER_BLOCK Iopb,
	_In_ PIO_STATUS_BLOCK IoStatus,
	_In_ PULONG pLength
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	PVOID pDstBuffer = NULL;
	ULONG Length = 0xFFFF;
	if (*pLength < 0xFFFF) {
		Length = *pLength;
	}
	*pLength = Length;

	if (!IoStatus->Information && MajorFunction) {
		*pLength = 0;
		return NULL;
	}

	switch (MajorFunction)
	{
		case IRP_MJ_CREATE:
		{
			if (NT_SUCCESS(IoStatus->Status)) {
				pDstBuffer = ProcmonAllocatePoolWithTag(NonPagedPool, Length, '2');
				if (pDstBuffer) {
					ProcmonSafeCopy(TRUE, Thread, Flags, pDstBuffer, &IoStatus->Information, pLength);
				}
			}
		}
			break;
		case IRP_MJ_READ:
		{
			*pLength = Length = 8;
			pDstBuffer = ProcmonAllocatePoolWithTag(NonPagedPool, Length, '2');
			if (pDstBuffer) {
				ProcmonSafeCopy(TRUE, Thread, Flags, pDstBuffer, &IoStatus->Information, pLength);
			}
		}
			break;
		case IRP_MJ_QUERY_INFORMATION:
		case IRP_MJ_QUERY_VOLUME_INFORMATION:
		{
			if (Iopb->Parameters.QueryFileInformation.Length < 0xFFFF) {
				Length = Iopb->Parameters.QueryFileInformation.Length;
			}
			*pLength = Length;
			pDstBuffer = ProcmonAllocatePoolWithTag(NonPagedPool, Length, '2');
			if (pDstBuffer) {
				ProcmonSafeCopy(FALSE, Thread, Flags, pDstBuffer, 
					Iopb->Parameters.QueryFileInformation.InfoBuffer, pLength);
			}
		}
			break;
		case IRP_MJ_DIRECTORY_CONTROL:
		{
			if (Iopb->MinorFunction == IRP_MN_QUERY_DIRECTORY) {
				if (Iopb->Parameters.DirectoryControl.QueryDirectory.Length < 0xFFFF)
					Length = Iopb->Parameters.DirectoryControl.QueryDirectory.Length;

				*pLength = Length;
				pDstBuffer = ProcmonAllocatePoolWithTag(NonPagedPool, Length, '2');
				if (pDstBuffer){
					if (Iopb->Parameters.DirectoryControl.QueryDirectory.MdlAddress) {
						PVOID pMappedAddr = MmGetSystemAddressForMdlSafe(
							Iopb->Parameters.DirectoryControl.QueryDirectory.MdlAddress,
							NormalPagePriority);
						RtlCopyMemory(pDstBuffer, pMappedAddr, Length);
					}else{
						ProcmonSafeCopy(FALSE, Thread, Flags, pDstBuffer,
							Iopb->Parameters.DirectoryControl.QueryDirectory.DirectoryBuffer, pLength);
					}
				}
			}
		}
			break;
		case IRP_MJ_NETWORK_QUERY_OPEN:
		{
			pDstBuffer = ProcmonAllocatePoolWithTag(NonPagedPool, Length, '2');
			if (pDstBuffer) {
				ProcmonSafeCopy(FALSE, Thread, Flags, pDstBuffer,
					Iopb->Parameters.NetworkQueryOpen.NetworkInformation, pLength);
			}
		}
			break;
		default:
		{
			*pLength = 0;
		}
			break;
	}

	if (!*pLength) {
		if (pDstBuffer){
			ExFreePoolWithTag(pDstBuffer, 0);
		}

		return NULL;
	}

	if (!pDstBuffer){
		*pLength = 0;
	}

	return pDstBuffer;
}

NTSTATUS
ProcmonFilePostOptRoutine(
	_In_ PETHREAD Thread,
	_In_ UCHAR MajorFunction,
	_In_ PIO_STATUS_BLOCK IoStatus,
	_In_ PFLT_IO_PARAMETER_BLOCK Iopb,
	_In_ PVOID CompletionContext,
	_In_ LARGE_INTEGER Time,
	_In_ FLT_CALLBACK_DATA_FLAGS Flags
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	PVOID pFileOptPostInfo;
	ULONG Length;
	PLOG_BUFFER pLogBuf;
	PVOID pLogInfo;
	ULONG Seq = (ULONG)(ULONG_PTR)CompletionContext;

	if (MajorFunction == IRP_MJ_CREATE)
		Length = sizeof(IoStatus->Information);
	else
		Length = (ULONG)IoStatus->Information;

	pFileOptPostInfo = ProcmonCollectFileOptPostInfo(Thread, MajorFunction, Flags, Iopb, IoStatus, &Length);
	pLogInfo = ProcmonGetPostLogEntry(Seq, IoStatus->Status, Length, &pLogBuf);
	if (pLogInfo && Time.QuadPart) {
		PLOG_ENTRY pLogEntry = (PLOG_ENTRY)((ULONG_PTR)pLogInfo - sizeof(LOG_ENTRY));
		pLogEntry->Time = Time;
	}

	if (Length) {
		if (pLogInfo)
			RtlCopyMemory(pLogInfo, pFileOptPostInfo, Length);
		ExFreePoolWithTag(pFileOptPostInfo, 0);
	}
	if (pLogInfo){
		ProcmonNotifyProcessLog(pLogBuf);
	}
	
	return STATUS_SUCCESS;
}

VOID
ProcmonFilePostOptWorkerRoutine(
	_In_ PVOID Parameter
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	PFILEOPT_WORKQUEUEITEM pSelfWorkItem = (PFILEOPT_WORKQUEUEITEM)Parameter;
	ProcmonFilePostOptRoutine(
		pSelfWorkItem->Thread,
		pSelfWorkItem->MajorFunction,
		&pSelfWorkItem->IoStatus,
		NULL,
		pSelfWorkItem->CompletionContext,
		pSelfWorkItem->Time,
		pSelfWorkItem->Flags);
	ExFreePoolWithTag(pSelfWorkItem, 0);
}
```

`kernel/file.h`:

```h
#pragma once

#include <ntifs.h>
#include "process.h"


typedef struct _PAGING_FILEINFO_LIST
{
	struct _PAGING_FILEINFO_LIST* Next;
	PFILE_OBJECT FileObject;
	UNICODE_STRING FileName;
}PAGING_FILEINFO_LIST, *PPAGING_FILEINFO_LIST;

typedef struct _VOLUME_INFO
{
	UNICODE_STRING Name;
	ULONG Type;
	struct _VOLUME_INFO* Next;
}VOLUME_INFO, *PVOLUME_INFO;

typedef struct _FILEOPT_WORKQUEUEITEM
{
	WORK_QUEUE_ITEM WorkItem;
	PETHREAD Thread;
	UCHAR MajorFunction;
	LARGE_INTEGER Time;
	IO_STATUS_BLOCK IoStatus;
	PVOID CompletionContext;
	ULONG Flags;
}FILEOPT_WORKQUEUEITEM, *PFILEOPT_WORKQUEUEITEM;

NTSTATUS
EnableFileMonitor(
	_In_ BOOLEAN bEnable
);

VOID
ProcmonEnumAllVolumes(
	VOID
);

BOOLEAN
ProcmonIsFileInSystemRoot(
	_In_ PUNICODE_STRING pUniStrImageName
);

BOOLEAN
ProcmonIsFileExist(
	_In_ PUNICODE_STRING pUniStrFileName
);

BOOLEAN
ProcmonAppendVolumeName(
	_In_ PCUNICODE_STRING pUniStrImageName,
	_Inout_ PUNICODE_STRING pUniStrFullName
);

PUNICODE_STRING
FindPagingFileNameInList(
	_In_ PFILE_OBJECT FileObject
);

VOID
AddToPagingFileNameList(
	_In_ PFILE_OBJECT FileObject,
	_In_ PUNICODE_STRING pStrFileName
);

VOID
ProcmonFilePostOptWorkerRoutine(
	_In_ PVOID Parameter
);

PVOID
ProcmonCollectFileOptPostInfo(
	_In_ PETHREAD Thread,
	_In_ UCHAR MajorFunction,
	_In_ FLT_CALLBACK_DATA_FLAGS Flags,
	_In_ PFLT_IO_PARAMETER_BLOCK Iopb,
	_In_ PIO_STATUS_BLOCK IoStatus,
	_In_ PULONG pLength
);

NTSTATUS
ProcmonFilePostOptRoutine(
	_In_ PETHREAD Thread,
	_In_ UCHAR MajorFunction,
	_In_ PIO_STATUS_BLOCK IoStatus,
	_In_opt_ PFLT_IO_PARAMETER_BLOCK Iopb,
	_In_ PVOID CompletionContext,
	_In_ LARGE_INTEGER Time,
	_In_ FLT_CALLBACK_DATA_FLAGS Flags
);
```

`kernel/globals.c`:

```c

#include "globals.h"

ULONG gBuildNumber = 0;
PFLT_FILTER gFilterHandle = NULL;
ULONG gFlags;
PDRIVER_OBJECT gDriverObject = NULL;
PFLT_PORT gClientProcessPathPort;
PVOID gSelfImageBase = NULL;
ULONG gSelfImageSize;

KEVENT gEventProcessData;
KTIMER gTimerProcessLogData;
KDPC gDpcProcessData;
PEPROCESS gCurrentProcess = NULL;
HANDLE gProcessId;
KSPIN_LOCK gFileNameInfoListSpinLock;

LIST_ENTRY gThreadInfoList;
FAST_MUTEX gThreadInfoMutex;
NPAGED_LOOKASIDE_LIST gNPagedLooksideListThreadInfo;

FAST_MUTEX gMutexVolume;
UNICODE_STRING gUniStrSystemRoot;

BOOLEAN gbReady = FALSE;
BOOLEAN gbFinish = FALSE;
```

`kernel/globals.h`:

```h
#pragma once

#include <ntifs.h>
#include <fltKernel.h>

extern ULONG gBuildNumber;
extern PFLT_FILTER gFilterHandle;
extern ULONG gFlags;
extern PDRIVER_OBJECT gDriverObject;
extern PFLT_PORT gClientProcessPathPort;
extern PVOID gSelfImageBase;
extern ULONG gSelfImageSize;

extern KEVENT gEventProcessData;
extern KTIMER gTimerProcessLogData;
extern KDPC gDpcProcessData;
extern PEPROCESS gCurrentProcess;
extern HANDLE gProcessId;
extern KSPIN_LOCK gFileNameInfoListSpinLock;

extern LIST_ENTRY gThreadInfoList;
extern FAST_MUTEX gThreadInfoMutex;
extern NPAGED_LOOKASIDE_LIST gNPagedLooksideListThreadInfo;

extern FAST_MUTEX gMutexVolume;
extern UNICODE_STRING gUniStrSystemRoot;

extern BOOLEAN gbReady;
extern BOOLEAN gbFinish;
```

`kernel/log.c`:

```c

#include "log.h"
#include "globals.h"
#include "utils.h"
#include "process.h"

// #ifdef ALLOC_PRAGMA
// #pragma alloc_text(PAGE, ProcmonGenStackFrameChain)
// #pragma alloc_text(PAGE, ProcmonGetLogEntryAndCopyFrameChain)
// #pragma alloc_text(PAGE, ProcmonGetLogBufferAndLock)
// #pragma alloc_text(PAGE, ProcmonGetLogEntryAndInit)
// #endif

FAST_MUTEX gMutexLogList;
LIST_ENTRY gLogListHead;
LONG gRecordSequence = 0;
NPAGED_LOOKASIDE_LIST gNPagedLooksideListLogBuffer;
LARGE_INTEGER gMonitorStartCounter;
LARGE_INTEGER gPerformanceFrequency;
LARGE_INTEGER gMonitorStartTime;
LONGLONG gWriteFileFrqs;


ULONG
ProcmonGenStackFrameChain(
	_In_ BOOLEAN bRefThread,
	_Out_ PVOID *Callers,
	_In_ USHORT nCounts
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	int Index;
	USHORT nCaptured;

	nCaptured = (USHORT)RtlWalkFrameChain(Callers, nCounts, 0);

	//
	// Remove All record which called by ourself
	//

	if (gSelfImageBase) {
		for (Index = 0; Index < nCaptured; Index++)
		{
			ULONG_PTR pCallerRip = (ULONG_PTR)Callers[Index];
			if (pCallerRip <= (ULONG_PTR)gSelfImageBase ||
				pCallerRip >= (ULONG_PTR)gSelfImageBase + gSelfImageSize) {
				break;
			}
		}

		if (Index) {
			memmove(Callers, &Callers[Index], (nCounts - Index) * sizeof(PVOID));
			nCaptured -= (USHORT)Index;
		}
	}

	if (!bRefThread) {
		return nCaptured;
	}

	if (!RefThreadInfo()) {
		ULONG_PTR LowLimit, HighLimit;
		IoGetStackLimits(&LowLimit, &HighLimit);
		if ((ULONG_PTR)&HighLimit - LowLimit > PAGE_SIZE) {
			nCaptured += (USHORT)RtlWalkFrameChain(&Callers[nCaptured], nCounts - nCaptured, 1);
			DeRefThreadInfo();
			return nCaptured;
		}
	}

	DeRefThreadInfo();
	return 0;
}

PVOID
ProcmonGetLogEntryAndCopyFrameChain(
	_In_ UCHAR MonitorType,
	_In_ USHORT NotifyType,
	_In_ LONG Sequence,
	_In_ NTSTATUS Status,
	_In_ ULONG Length,
	_Out_ PLOG_BUFFER *ppLogBuffer
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	USHORT nFrameChainCounts;
	PVOID StackFrameChain[MAX_STACKFRAME_COUNTS];

	nFrameChainCounts = (USHORT)ProcmonGenStackFrameChain(TRUE, StackFrameChain, MAX_STACKFRAME_COUNTS);
	return ProcmonGetLogEntryAndInit(
		MonitorType,
		NotifyType,
		Sequence,
		Status,
		Length,
		ppLogBuffer,
		nFrameChainCounts,
		StackFrameChain);
}

PVOID
ProcmonGetLogEntryAndSeq(
	_In_ BOOLEAN bRefThread,
	_In_ UCHAR MonitorType,
	_In_ USHORT NotifyType,
	_In_ LONG Sequence,
	_In_ NTSTATUS Status,
	_In_ ULONG Length,
	_Out_ PLONG pRecordSequence,
	_Out_ PLOG_BUFFER *ppLogBuffer
)
/*++

Routine Description:

	.

Arguments:

	 -

Return Value:

	Routine can return non success error codes.

--*/
{
	PVOID pBuffer;
	USHORT nFrameChainCounts;
	PVOID StackFrameChain[MAX_STACKFRAME_COUNTS];

	//*pRecordSequence = -1;

	nFrameChainCounts = (USHORT)ProcmonGenStackFrameChain(bRefThread, StackFrameChain, MAX_STACKFRAME_COUNTS);
	pBuffer = ProcmonGetLogEntryAndInit(
		MonitorType,
		NotifyType,
		Sequence,
		Status,
		Length,
		ppLogBuffer,
		nFrameChainCounts,
		StackFrameChain);

	if (pBuffer) {
		*pRecordSequence = ((PLOG_ENTRY)((ULONG_PTR)pBuffer - sizeof(PVOID) * nFrameChainCounts - sizeof(LOG_ENTRY)))->Sequence;
	}
	return pBuffer;
}

PVOID
ProcmonGetLogBufferAndLock(
	_In_ ULONG Length,
	_Out_ PLOG_BUFFER* ppLogBuffer
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	PLOG_BUFFER pLogBuffer;
	LARGE_INTEGER Time;

	//
	// Lock
	//

	ExAcquireFastMutex(&gMutexLogList);

	if (!IsListEmpty(&gLogListHead)) {
		pLogBuffer = CONTAINING_RECORD(gLogListHead.Blink, LOG_BUFFER, List);
		if (MAX_PROCMON_MESSAGE_LEN - pLogBuffer->Length >= Length) {
			pLogBuffer->Length += Length;
			*ppLogBuffer = pLogBuffer;
			return &pLogBuffer->Text[pLogBuffer->Length - Length];
		}else{
			pLogBuffer = CONTAINING_RECORD(gLogListHead.Flink, LOG_BUFFER, List);
			KeQuerySystemTime(&Time);
			
			//
			// 如果写文件速度太快则不分配内存
			//
			
			if (Time.QuadPart - pLogBuffer->DataTime.QuadPart > gWriteFileFrqs){
				ExReleaseFastMutex(&gMutexLogList);
				*ppLogBuffer = NULL;
				return NULL;
			}
		}
	}

	pLogBuffer = ExAllocateFromNPagedLookasideList(&gNPagedLooksideListLogBuffer);
	if (pLogBuffer) {
		KeQuerySystemTime(&pLogBuffer->DataTime);
		pLogBuffer->Length = 0;
		InsertTailList(&gLogListHead, &pLogBuffer->List);
		pLogBuffer->Length += Length;
		*ppLogBuffer = pLogBuffer;
		return &pLogBuffer->Text[pLogBuffer->Length - Length];
	}

	ExReleaseFastMutex(&gMutexLogList);
	*ppLogBuffer = NULL;
	return 0;
}

// #define ALIGN_DOWN(length, type) \
//     ((ULONG)(length) & ~(sizeof(type) - 1))
// #define ALIGN_UP(length, type) \
//     (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))
// #define TIME_OFF(_Time, _PerformanceCounter, _PerformanceFrequency)	\
// 	KeQueryPerformanceCounter(NULL).QuadPart - _PerformanceCounter.QuadPart

LARGE_INTEGER
ProcmonGetTime(
	VOID
)
/*++

Routine Description:

	.

Arguments:

	 -

Return Value:

	Routine can return non success error codes.

--*/
{
	LARGE_INTEGER Time;
	LARGE_INTEGER CounterNow = KeQueryPerformanceCounter(NULL);
	LONGLONG CounterOff = CounterNow.QuadPart - gMonitorStartCounter.QuadPart;

	Time.QuadPart = gMonitorStartTime.QuadPart +
	(10000000 * (CounterOff / gPerformanceFrequency.QuadPart)) +
		((10000000 * (CounterOff % gPerformanceFrequency.QuadPart)) / gPerformanceFrequency.QuadPart);

	return Time;
}

PVOID
ProcmonGetLogEntryAndInit(
	_In_ UCHAR MonitorType,
	_In_ USHORT NotifyType,
	_In_ LONG Sequence,
	_In_ NTSTATUS Status,
	_In_ ULONG Length,
	_Out_ PLOG_BUFFER *ppLogBuffer,
	_In_ USHORT FrameChainDepth,
	_In_ PVOID pStackFrame
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	LONG DstSequence;
	PLOG_ENTRY pLogEntry;

	Length = ALIGN_UP(Length, 4);
	pLogEntry = (PLOG_ENTRY)ProcmonGetLogBufferAndLock(Length + sizeof(PVOID) * FrameChainDepth + sizeof(LOG_ENTRY), 
		ppLogBuffer);
	if (pLogEntry) {
		if (MonitorType == MONITOR_TYPE_POST) {
			DstSequence = Sequence;
		}else{
			if (MonitorType == MONITOR_TYPE_PROCESS && NotifyType == NOTIFY_PROCESS_INIT) {
				DstSequence = gRecordSequence;
			}else{
				DstSequence = InterlockedIncrement(&gRecordSequence);
			}
		}

		pLogEntry->Sequence = DstSequence;
		pLogEntry->NotifyType = NotifyType;
		pLogEntry->field_A = 0;
		pLogEntry->MonitorType = MonitorType;
		pLogEntry->ProcessSeq = Sequence;
		pLogEntry->Status = Status;
		pLogEntry->DataLength = Length;
		pLogEntry->ThreadId = (ULONG)(ULONG_PTR)PsGetCurrentThreadId();
		pLogEntry->nFrameChainCounts = FrameChainDepth;
		pLogEntry->Time = ProcmonGetTime();
		RtlCopyMemory(pLogEntry + 1, pStackFrame, sizeof(PVOID) * FrameChainDepth);
		return (PVOID)((ULONG_PTR)(pLogEntry + 1) + sizeof(PVOID) * FrameChainDepth);

	}

	return NULL;
}

PVOID
ProcmonGetPostLogEntry(
	_In_ LONG Sequence, 
	_In_ NTSTATUS Status, 
	_In_ ULONG Length, 
	_Out_ PLOG_BUFFER *ppLogBuffer
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	return ProcmonGetLogEntryAndInit(MONITOR_TYPE_POST, 0, Sequence, Status, Length, ppLogBuffer, 0, NULL);
}

VOID
ProcmonNotifyProcessLog(
	_In_ PLOG_BUFFER pLogBuf
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	if (pLogBuf) {
		if (gbReady) {
			if (!gbFinish && gLogListHead.Flink == &pLogBuf->List && pLogBuf->Length > 0x10000) {
				KeCancelTimer(&gTimerProcessLogData);

				//
				// 立即处理
				//

				KeSetEvent(&gEventProcessData, 0, 0);
				gbFinish = TRUE;
			}
		}
		else {
			LARGE_INTEGER DueTime;
			DueTime.QuadPart = -2500000;

			//
			// 使用Timer进行处理
			//

			KeSetTimer(&gTimerProcessLogData, DueTime, &gDpcProcessData);
		}
		gbReady = TRUE;
		ExReleaseFastMutex(&gMutexLogList);
	}
}

NTSTATUS
ProcessLogDataWithCallback(
	_In_ FNWRITEMSGCALLBACK Callback
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	NTSTATUS Status = STATUS_SUCCESS;
	PLIST_ENTRY pEntry = NULL;

	ExAcquireFastMutex(&gMutexLogList);

	if (IsListEmpty(&gLogListHead) ||
		(pEntry = RemoveHeadList(&gLogListHead), IsListEmpty(&gLogListHead))) {
		Status = STATUS_END_OF_FILE;
		gbReady = FALSE;
		gbFinish = FALSE;
		KeClearEvent(&gEventProcessData);
	}
	ExReleaseFastMutex(&gMutexLogList);

	if (pEntry) {
		PLOG_BUFFER pBuffer = CONTAINING_RECORD(pEntry, LOG_BUFFER, List);
		Callback(&pBuffer->Length, pBuffer->Length + sizeof(ULONG));
		ExFreeToNPagedLookasideList(&gNPagedLooksideListLogBuffer, pBuffer);
	}
	return Status;
}

VOID 
ProcmonCleanupWriteState(
	VOID
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	ExAcquireFastMutex(&gMutexLogList);
	gbReady = FALSE;
	gbFinish = FALSE;
	KeClearEvent(&gEventProcessData);
	ExReleaseFastMutex(&gMutexLogList);
}
```

`kernel/log.h`:

```h
#pragma once

#include <ntifs.h>
#include <fltKernel.h>
#include "ntheader.h"
#include "logsdk.h"

#define MAX_STACKFRAME_COUNTS 150

extern FAST_MUTEX gMutexLogList;
extern LIST_ENTRY gLogListHead;
extern LONG gRecordSequence;
extern NPAGED_LOOKASIDE_LIST gNPagedLooksideListLogBuffer;
extern LARGE_INTEGER gMonitorStartCounter;
extern LARGE_INTEGER gPerformanceFrequency;
extern LARGE_INTEGER gMonitorStartTime;
extern LONGLONG gWriteFileFrqs;

typedef
NTSTATUS
(NTAPI *FNWRITEMSGCALLBACK)(
	_In_ PVOID SenderBuffer,
	_In_ ULONG SenderBufferLength
	);

ULONG
ProcmonGenStackFrameChain(
	_In_ BOOLEAN bRefThread,
	_Out_ PVOID *Callers,
	_In_ USHORT nCounts
);

PVOID
ProcmonGetLogEntryAndCopyFrameChain(
	_In_ UCHAR MonitorType,
	_In_ USHORT NotifyType,
	_In_ LONG Sequence,
	_In_ NTSTATUS Status,
	_In_ ULONG Length,
	_Out_ PLOG_BUFFER *ppLogBuffer
);

PVOID
ProcmonGetLogBufferAndLock(
	_In_ ULONG Length,
	_Out_ PLOG_BUFFER* ppLogBuffer
);

PVOID
ProcmonGetLogEntryAndInit(
	_In_ UCHAR MonitorType,
	_In_ USHORT NotifyType,
	_In_ LONG Sequence,
	_In_ NTSTATUS Status,
	_In_ ULONG Length,
	_Out_ PLOG_BUFFER *ppLogBuffer,
	_In_ USHORT FrameChainDepth,
	_In_ PVOID pStackFrame
);

PVOID
ProcmonGetLogEntryAndSeq(
	_In_ BOOLEAN bRefThread,
	_In_ UCHAR MonitorType,
	_In_ USHORT NotifyType,
	_In_ LONG Sequence,
	_In_ NTSTATUS Status,
	_In_ ULONG Length,
	_Out_ PLONG pRecordSequence,
	_Out_ PLOG_BUFFER *ppLogBuffer
);

LARGE_INTEGER
ProcmonGetTime(
	VOID
);

PVOID
ProcmonGetPostLogEntry(
	_In_ LONG Sequence,
	_In_ NTSTATUS Status,
	_In_ ULONG Length,
	_Out_ PLOG_BUFFER *ppLogBuffer
);

VOID
ProcmonNotifyProcessLog(
	_In_ PLOG_BUFFER pLogBuf
);

NTSTATUS
ProcessLogDataWithCallback(
	_In_ FNWRITEMSGCALLBACK Callback
);

VOID
ProcmonCleanupWriteState(
	VOID
);
```

`kernel/logsdk.h`:

```h
#pragma once

#define MAX_PROCMON_MESSAGE_LEN	0x20000

#ifdef OPENPROCMON

#define PROCMON_PORTNAME L"\\OpenProcessMonitor24Port"
#define PROCMON_DEBUGLOGGER_DEVICE_NAME L"\\device\\OpenProcmonDebugLogger"
#define PROCMON_DEBUGLOGGER_SYMBOL_NAME L"\\DosDevices\\Global\\OpenProcmonDebugLogger"
#define PROCMON_EXTLOGGER_DEVICE_NAME L"\\device\\OpenProcmonExternalLogger"
#define PROCMON_EXTLOGGER_ENABLE_EVENT_NAME L"\\??\\OpenProcmonExternalLoggerEnabled"
#define PROCMON_DEFAULT_LOGFILE L"\\SystemRoot\\OpenProcmon.pmb"

#else
#define PROCMON_PORTNAME L"\\ProcessMonitor24Port"
#define PROCMON_DEBUGLOGGER_DEVICE_NAME L"\\device\\ProcmonDebugLogger"
#define PROCMON_DEBUGLOGGER_SYMBOL_NAME L"\\DosDevices\\Global\\ProcmonDebugLogger"
#define PROCMON_EXTLOGGER_DEVICE_NAME L"\\device\\ProcmonExternalLogger"
#define PROCMON_EXTLOGGER_ENABLE_EVENT_NAME L"\\??\\ProcmonExternalLoggerEnabled"
#define PROCMON_DEFAULT_LOGFILE L"\\SystemRoot\\Procmon.pmb"

#endif


//
// Control code definition
//

#define CTLCODE_MONITOR			0
#define CTLCODE_THREADPOFILING  1


//
// Control Flag for monitor
//

#define CTL_MONITOR_ALL_CLOSE		0x00
#define CTL_MONITOR_PROC_ON			0x01
#define CTL_MONITOR_FILE_ON			0x02
#define CTL_MONITOR_REG_ON			0x04
#define CTL_MONITOR_OLDREG_ON		0x08
#define CTL_MONITOR_EXTLOG_ON		0x10


#pragma pack(1)
typedef struct _FLTMSG_CONTROL_HEAD
{
	ULONG CtlCode;
}FLTMSG_CONTROL_HEAD, *PFLTMSG_CONTROL_HEAD;

//CtlCode == 1
typedef struct _FLTMSG_CONTROL_THREADPROFILING
{
	FLTMSG_CONTROL_HEAD Head;
	LARGE_INTEGER ThreadProfile;
}FLTMSG_CONTROL_THREADPROFILING, *PFLTMSG_CONTROL_THREADPROFILING;

//CtlCode == 0
typedef struct _FLTMSG_CONTROL_FLAGS
{
	FLTMSG_CONTROL_HEAD Head;
	ULONG Flags;
}FLTMSG_CONTROL_FLAGS, *PFLTMSG_CONTROL_FLAGS;
#pragma pack()

typedef enum _LOG_MONITOR_TYPE
{
	MONITOR_TYPE_POST = 0,
	MONITOR_TYPE_PROCESS = 1,
	MONITOR_TYPE_REG = 2,
	MONITOR_TYPE_FILE = 3,
	MONITOR_TYPE_PROFILING = 4,
}LOG_MONITOR_TYPE;

typedef enum _LOG_PROCESS_NOTIFY_TYPE
{
	NOTIFY_PROCESS_INIT = 0, //ProcmonFillProcessInfo(LOG_PROCESSCREATE_INFO)
	NOTIFY_PROCESS_CREATE = 1,   //ProcmonFillProcessInfo(LOG_PROCESSCREATE_INFO)
	NOTIFY_PROCESS_EXIT = 2,  //CreateProcessNotifyRoutineCommon
	NOTIFY_THREAD_CREATE = 3, // 
	NOTIFY_THREAD_EXIT = 4,
	NOTIFY_IMAGE_LOAD = 5, //LoadImageNotifyRoutine(LOG_LOADIMAGE_INFO)
	NOTIFY_PROCESS_THREADPERFORMANCE = 6,
	NOTIFY_PROCESS_START = 7, //ProcmonFillProcessInfo(LOG_PROCESSCREATEEXT_INFO)
	NOTIFY_PROCESS_PERFORMANCE = 8, //LOG_PROCESSBASIC_INFO
	NOTIFY_SYSTEM_PERFORMANCE = 9, //LOG_SYSTEMPERF_INFO
}LOG_PROCESS_NOTIFY_TYPE;

typedef enum _LOG_PROFILING_NOTIFY_TYPE
{
	NOTIFY_THREAD_PROFILING = 0, //MONITOR_TYPE_THREAD_PROFILING == 4
	NOTIFY_PROCESS_PROFILING,    //MONITOR_TYPE_THREAD_PROFILING == 4
	NOTIFY_PROFILING_DEBUG,
}LOG_PROFILING_NOTIFY_TYPE;


typedef enum _LOG_REG_NOTIFY_TYPE
{
	NOTIFY_REG_OPENKEYEX = 0,
	NOTIFY_REG_CREATEKEYEX,
	NOTIFY_REG_KEYHANDLECLOSE,
	NOTIFY_REG_QUERYKEY,
	NOTIFY_REG_SETVALUEKEY,
	NOTIFY_REG_QUERYVALUEKEY,
	NOTIFY_REG_ENUMERATEVALUEKEY,
	NOTIFY_REG_ENUMERATEKEY,
	NOTIFY_REG_SETINFORMATIONKEY,
	NOTIFY_REG_DELETEKEY,
	NOTIFY_REG_DELETEVALUEKEY,
	NOTIFY_REG_FLUSHKEY,
	NOTIFY_REG_LOADKEY,
	NOTIFY_REG_UNLOADKEY,
	NOTIFY_REG_RENAMEKEY,
	NOTIFY_REG_QUERYMULTIPLEVALUEKEY,
	NOTIFY_REG_SETKEYSECURITY,
	NOTIFY_REG_QUERYKEYSECURITY,
}LOG_REG_NOTIFY_TYPE;


//
// MAJORFUNCTION + 20, //for file
//


typedef struct _LOG_BUFFER
{
	LARGE_INTEGER DataTime;
	LIST_ENTRY List;
	ULONG Length;
	UCHAR Text[1];
}LOG_BUFFER, *PLOG_BUFFER;

#pragma pack(1)
typedef struct _LOG_ENTRY
{
	/*00*/LONG ProcessSeq;
	/*04*/ULONG ThreadId;
	/*08*/USHORT MonitorType;
	/*0A*/USHORT field_A;
	/*0c*/USHORT NotifyType;
	/*0E*/USHORT field_E;
	/*10*/LONG Sequence;
	/*14*/ULONG field_14;
	/*18*/ULONG field_18;
	/*1C*/LARGE_INTEGER Time;
	/*24*/NTSTATUS Status;
	/*28*/USHORT nFrameChainCounts;
	/*2A*/USHORT field_2A;
	/*2C*/ULONG DataLength;
	/*30*/ULONG field_30;
}LOG_ENTRY, *PLOG_ENTRY;


#define TO_EVENT_DATA(_type, _entry) (_type)((PUCHAR)((PLOG_ENTRY)_entry + 1) + ((PLOG_ENTRY)_entry)->nFrameChainCounts * sizeof(PVOID))
#define CALC_ENTRY_SIZE(_entry) (((PLOG_ENTRY)_entry)->DataLength + \
								(sizeof(PVOID) * ((PLOG_ENTRY)_entry)->nFrameChainCounts) + \
								sizeof(LOG_ENTRY));

typedef struct _LOG_PROCESSCREATE_INFO
{
	ULONG Seq;
	ULONG ProcessId;
	ULONG ParentProcSeq;
	ULONG ParentId;
	ULONG SessionId;
	ULONG IsWow64;
	LARGE_INTEGER CreateTime;
	LUID AuthenticationId;
	ULONG TokenVirtualizationEnabled;
	UCHAR SidLength;
	UCHAR IntegrityLevelSidLength;
	USHORT ProcNameLength;
	USHORT CommandLineLength;
	USHORT UnKnown1;
}LOG_PROCESSCREATE_INFO, *PLOG_PROCESSCREATE_INFO;

typedef struct _LOG_PROCESSSTART_INFO
{
	ULONG ParentId;
	USHORT CommandLineLength;
	USHORT CurrentDirectoryLength;
	ULONG EnvironmentLength;
}LOG_PROCESSSTART_INFO, *PLOG_PROCESSSTART_INFO;

typedef struct _LOG_THREADEXIT_INFO
{
	ULONG ExitStatus;
	LARGE_INTEGER KenrnelTime;
	LARGE_INTEGER UserTime;
}LOG_THREADEXIT_INFO, *PLOG_THREADEXIT_INFO;

typedef struct _LOG_PROCESSBASIC_INFO
{
	ULONG ExitStatus;
	LARGE_INTEGER KenrnelTime;
	LARGE_INTEGER UserTime;
	SIZE_T WorkingSetSize;
	SIZE_T PeakWorkingSetSize;
	SIZE_T PagefileUsage;
	SIZE_T PeakPagefileUsage;
}LOG_PROCESSBASIC_INFO, *PLOG_PROCESSBASIC_INFO;

typedef struct _LOG_SYSTEMPERF_INFO
{
	ULONG UnKnown;
	SYSTEM_PERFORMANCE_INFORMATION SystemPerfInfo;
}LOG_SYSTEMPERF_INFO, *PLOG_SYSTEMPERF_INFO;

typedef struct _LOG_PROCESS_PROFILING_INFO
{
	LARGE_INTEGER UserTime;
	LARGE_INTEGER KernelTime;
	SIZE_T WorkingSetSize;
	SIZE_T PagefileUsage;

}LOG_PROCESS_PROFILING_INFO, *PLOG_PROCESS_PROFILING_INFO;

typedef struct _LOG_LOADIMAGE_INFO
{
	/*00*/PVOID ImageBase;
	/*08*/ULONG ImageSize;
	/*0C*/USHORT ImageNameLength;
	/*0E*/WCHAR Fill0E[1];
	/*10*/
}LOG_LOADIMAGE_INFO, *PLOG_LOADIMAGE_INFO;

typedef struct _LOG_THREAD_PROFILING_INFO
{
	ULONG UserTimeChange;
	ULONG KernelTimeChange;
	ULONG ContextSwitchesChange;
}LOG_THREAD_PROFILING_INFO, *PLOG_THREAD_PROFILING_INFO;

typedef struct _LOG_FILE_OPT
{
	UCHAR MinorFunction;
	UCHAR Fill1[7];
	ULONG IopbFlag;
	ULONG Flags;
#if 0
	PVOID Argument1;
	PVOID Argument2;
	PVOID Argument3;
	PVOID Argument4;
	PVOID Argument5;
	LARGE_INTEGER Argument6;
#endif
	FLT_PARAMETERS FltParameter;
	USHORT NameLength;
	UCHAR Fill42[2];
	WCHAR Name[1];
}LOG_FILE_OPT, *PLOG_FILE_OPT;

typedef struct _LOG_FILE_NAME_COMMON
{
	USHORT FileNameLength;
}LOG_FILE_NAME_COMMON, *PLOG_FILE_NAME_COMMON;

typedef struct _LOG_FILE_LOCKCONTROL
{
	LONGLONG Length;
}LOG_FILE_LOCKCONTROL, *PLOG_FILE_LOCKCONTROL;

typedef struct _LOG_FILE_ACQUIREFORMODIFIEDPAGEWRITER
{
	LARGE_INTEGER EndingOffset;
}LOG_FILE_ACQUIREFORMODIFIEDPAGEWRITER, *PLOG_FILE_ACQUIREFORMODIFIEDPAGEWRITER;

typedef struct _LOG_FILE_CREATE
{
	ACCESS_MASK DesiredAccess;
	ULONG UserTokenLength;
}LOG_FILE_CREATE, *PLOG_FILE_CREATE;

typedef struct _LOG_REG_SETVALUEKEY
{
	USHORT KeyNameLength;
	USHORT Fill02;
	ULONG Type;
	ULONG DataSize;
	USHORT CopySize;
	USHORT Fill0E;
}LOG_REG_SETVALUEKEY, *PLOG_REG_SETVALUEKEY;

typedef struct _LOG_REG_DELETEVALUEKEY
{
	USHORT KeyNameLength;
}LOG_REG_DELETEVALUEKEY, *PLOG_REG_DELETEVALUEKEY;

typedef struct _LOG_REG_SETINFORMATIONKEY
{
	USHORT KeyNameLength;
	USHORT Fill02;
	KEY_SET_INFORMATION_CLASS KeySetInformationClass;
	ULONG KeySetInformationLength;
	USHORT CopySize;
	USHORT Fill0E;
}LOG_REG_SETINFORMATIONKEY, *PLOG_REG_SETINFORMATIONKEY;

typedef struct _LOG_REG_RENAMEKEY
{
	USHORT KeyNameLength;
	USHORT NewNameLength;
}LOG_REG_RENAMEKEY, *PLOG_REG_RENAMEKEY;


typedef struct _LOG_REG_ENUMERATEKEY
{
	USHORT KeyNameLength;
	USHORT Fill02;
	ULONG Length;
	ULONG Index;
	KEY_INFORMATION_CLASS KeyInformationClass;
}LOG_REG_ENUMERATEKEY, *PLOG_REG_ENUMERATEKEY;

typedef struct _LOG_REG_ENUMERATEVALUEKEY
{
	USHORT KeyNameLength;
	USHORT Fill02;
	ULONG Length;
	ULONG Index;
	KEY_VALUE_INFORMATION_CLASS  KeyValueInformationClass;
}LOG_REG_ENUMERATEVALUEKEY, *PLOG_REG_ENUMERATEVALUEKEY;

typedef struct _LOG_REG_QUERYKEY
{
	USHORT KeyNameLength;
	USHORT Fill02;
	ULONG Length;
	KEY_INFORMATION_CLASS KeyInformationClass;
}LOG_REG_QUERYKEY, *PLOG_REG_QUERYKEY;

typedef struct _LOG_REG_QUERYVALUEKEY
{
	USHORT KeyNameLength;
	USHORT Fill02;
	ULONG Length;
	KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass;
}LOG_REG_QUERYVALUEKEY, *PLOG_REG_QUERYVALUEKEY;

typedef struct _LOG_REG_CONNMON
{
	USHORT KeyNameLength;
}LOG_REG_CONNMON, *PLOG_REG_CONNMON;

typedef struct _LOG_REG_LOADKEY
{
	USHORT KeyNameLength;
	USHORT SourceFileLength;
}LOG_REG_LOADKEY, *PLOG_REG_LOADKEY;

typedef LOG_REG_CONNMON LOG_REG_UNLOADKEY;
typedef LOG_REG_CONNMON* PLOG_REG_UNLOADKEY;

typedef struct _LOG_REG_CREATEOPENKEY
{
	USHORT KeyNameLength;
	USHORT Fill02;
	ACCESS_MASK DesiredAccess;
}LOG_REG_CREATEOPENKEY, *PLOG_REG_CREATEOPENKEY;

typedef struct _LOG_REG_POSTCREATEOPENKEY
{
	ACCESS_MASK GrantedAccess;
	ULONG Disposition;
}LOG_REG_POSTCREATEOPENKEY, *PLOG_REG_POSTCREATEOPENKEY;

#pragma pack()

#pragma pack(4)
typedef struct _PROCMON_MESSAGE_HEADER
{
	FILTER_MESSAGE_HEADER Header;
	ULONG Length;
}PROCMON_MESSAGE_HEADER, * PPROCMON_MESSAGE_HEADER;
#pragma pack()
```

`kernel/ntheader.h`:

```h
#pragma once

#include <ntifs.h>

typedef unsigned char BYTE;

typedef struct _CURDIR
{
	UNICODE_STRING DosPath;
	HANDLE Handle;
}CURDIR, *PCURDIR;

typedef struct _RTL_USER_PROCESS_PARAMETERS {
	ULONG MaximumLength;
	ULONG Length;
	ULONG Flags;
	ULONG DebugFlags;
	PVOID Reserved2[5];
	CURDIR CurrentDirectory;
	UNICODE_STRING DllPath;
	UNICODE_STRING ImagePathName;
	UNICODE_STRING CommandLine;
	PVOID Environment;
} RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;

typedef struct _PEB {
	BYTE Reserved1[2];
	BYTE BeingDebugged;
	BYTE Reserved2[1];
	PVOID Reserved3[2];
	PVOID Ldr;
	PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
	PVOID Reserved4[3];
	PVOID AtlThunkSListPtr;
	PVOID Reserved5;
	ULONG Reserved6;
	PVOID Reserved7;
	ULONG Reserved8;
	ULONG AtlThunkSListPtr32;
	PVOID Reserved9[45];
	BYTE Reserved10[96];
	PVOID PostProcessInitRoutine;
	BYTE Reserved11[128];
	PVOID Reserved12[1];
	ULONG SessionId;
} PEB, *PPEB;

typedef enum _SYSTEM_INFORMATION_CLASS {
	SystemBasicInformation,
	SystemProcessorInformation,             // obsolete...delete
	SystemPerformanceInformation,
	SystemTimeOfDayInformation,
	SystemPathInformation,
	SystemProcessInformation,
	SystemCallCountInformation,
	SystemDeviceInformation,
	SystemProcessorPerformanceInformation,
	SystemFlagsInformation,
	SystemCallTimeInformation,
	SystemModuleInformation,
	SystemLocksInformation,
	SystemStackTraceInformation,
	SystemPagedPoolInformation,
	SystemNonPagedPoolInformation,
	SystemHandleInformation,
	SystemObjectInformation,
	SystemPageFileInformation,
	SystemVdmInstemulInformation,
	SystemVdmBopInformation,
	SystemFileCacheInformation,
	SystemPoolTagInformation,
	SystemInterruptInformation,
	SystemDpcBehaviorInformation,
	SystemFullMemoryInformation,
	SystemLoadGdiDriverInformation,
	SystemUnloadGdiDriverInformation,
	SystemTimeAdjustmentInformation,
	SystemSummaryMemoryInformation,
	SystemMirrorMemoryInformation,
	SystemPerformanceTraceInformation,
	SystemObsolete0,
	SystemExceptionInformation,
	SystemCrashDumpStateInformation,
	SystemKernelDebuggerInformation,
	SystemContextSwitchInformation,
	SystemRegistryQuotaInformation,
	SystemExtendServiceTableInformation,
	SystemPrioritySeperation,
	SystemVerifierAddDriverInformation,
	SystemVerifierRemoveDriverInformation,
	SystemProcessorIdleInformation,
	SystemLegacyDriverInformation,
	SystemCurrentTimeZoneInformation,
	SystemLookasideInformation,
	SystemTimeSlipNotification,
	SystemSessionCreate,
	SystemSessionDetach,
	SystemSessionInformation,
	SystemRangeStartInformation,
	SystemVerifierInformation,
	SystemVerifierThunkExtend,
	SystemSessionProcessInformation,
	SystemLoadGdiDriverInSystemSpace,
	SystemNumaProcessorMap,
	SystemPrefetcherInformation,
	SystemExtendedProcessInformation,
	SystemRecommendedSharedDataAlignment,
	SystemComPlusPackage,
	SystemNumaAvailableMemory,
	SystemProcessorPowerInformation,
	SystemEmulationBasicInformation,
	SystemEmulationProcessorInformation,
	SystemExtendedHandleInformation,
	SystemLostDelayedWriteInformation,
	SystemBigPoolInformation,
	SystemSessionPoolTagInformation,
	SystemSessionMappedViewInformation,
	SystemHotpatchInformation,
	SystemObjectSecurityMode,
	SystemWatchdogTimerHandler,
	SystemWatchdogTimerInformation,
	SystemLogicalProcessorInformation,
	SystemWow64SharedInformation,
	SystemRegisterFirmwareTableInformationHandler,
	SystemFirmwareTableInformation,
	SystemModuleInformationEx,
	SystemVerifierTriageInformation,
	SystemSuperfetchInformation,
	SystemMemoryListInformation,
	SystemFileCacheInformationEx,
	MaxSystemInfoClass  // MaxSystemInfoClass should always be the last enum
} SYSTEM_INFORMATION_CLASS;

typedef struct _RTL_PROCESS_MODULE_INFORMATION {
	HANDLE Section;                 // Not filled in
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR  FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES {
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;

#if defined(_WIN64)
typedef ULONG SYSINF_PAGE_COUNT;
#else
typedef SIZE_T SYSINF_PAGE_COUNT;
#endif

typedef struct _SYSTEM_PERFORMANCE_INFORMATION {
	LARGE_INTEGER IdleProcessTime;
	LARGE_INTEGER IoReadTransferCount;
	LARGE_INTEGER IoWriteTransferCount;
	LARGE_INTEGER IoOtherTransferCount;
	ULONG IoReadOperationCount;
	ULONG IoWriteOperationCount;
	ULONG IoOtherOperationCount;
	ULONG AvailablePages;
	SYSINF_PAGE_COUNT CommittedPages;
	SYSINF_PAGE_COUNT CommitLimit;
	SYSINF_PAGE_COUNT PeakCommitment;
	ULONG PageFaultCount;
	ULONG CopyOnWriteCount;
	ULONG TransitionCount;
	ULONG CacheTransitionCount;
	ULONG DemandZeroCount;
	ULONG PageReadCount;
	ULONG PageReadIoCount;
	ULONG CacheReadCount;
	ULONG CacheIoCount;
	ULONG DirtyPagesWriteCount;
	ULONG DirtyWriteIoCount;
	ULONG MappedPagesWriteCount;
	ULONG MappedWriteIoCount;
	ULONG PagedPoolPages;
	ULONG NonPagedPoolPages;
	ULONG PagedPoolAllocs;
	ULONG PagedPoolFrees;
	ULONG NonPagedPoolAllocs;
	ULONG NonPagedPoolFrees;
	ULONG FreeSystemPtes;
	ULONG ResidentSystemCodePage;
	ULONG TotalSystemDriverPages;
	ULONG TotalSystemCodePages;
	ULONG NonPagedPoolLookasideHits;
	ULONG PagedPoolLookasideHits;
	ULONG AvailablePagedPoolPages;
	ULONG ResidentSystemCachePage;
	ULONG ResidentPagedPoolPage;
	ULONG ResidentSystemDriverPage;
	ULONG CcFastReadNoWait;
	ULONG CcFastReadWait;
	ULONG CcFastReadResourceMiss;
	ULONG CcFastReadNotPossible;
	ULONG CcFastMdlReadNoWait;
	ULONG CcFastMdlReadWait;
	ULONG CcFastMdlReadResourceMiss;
	ULONG CcFastMdlReadNotPossible;
	ULONG CcMapDataNoWait;
	ULONG CcMapDataWait;
	ULONG CcMapDataNoWaitMiss;
	ULONG CcMapDataWaitMiss;
	ULONG CcPinMappedDataCount;
	ULONG CcPinReadNoWait;
	ULONG CcPinReadWait;
	ULONG CcPinReadNoWaitMiss;
	ULONG CcPinReadWaitMiss;
	ULONG CcCopyReadNoWait;
	ULONG CcCopyReadWait;
	ULONG CcCopyReadNoWaitMiss;
	ULONG CcCopyReadWaitMiss;
	ULONG CcMdlReadNoWait;
	ULONG CcMdlReadWait;
	ULONG CcMdlReadNoWaitMiss;
	ULONG CcMdlReadWaitMiss;
	ULONG CcReadAheadIos;
	ULONG CcLazyWriteIos;
	ULONG CcLazyWritePages;
	ULONG CcDataFlushes;
	ULONG CcDataPages;
	ULONG ContextSwitches;
	ULONG FirstLevelTbFills;
	ULONG SecondLevelTbFills;
	ULONG SystemCalls;
} SYSTEM_PERFORMANCE_INFORMATION, *PSYSTEM_PERFORMANCE_INFORMATION;

typedef struct _SYSTEM_THREAD_INFORMATION {
	LARGE_INTEGER KernelTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER CreateTime;
	ULONG WaitTime;
	PVOID StartAddress;
	CLIENT_ID ClientId;
	KPRIORITY Priority;
	LONG BasePriority;
	ULONG ContextSwitches;
	ULONG ThreadState;
	ULONG WaitReason;
} SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;


typedef struct _SYSTEM_PROCESS_INFORMATION {
	ULONG NextEntryOffset;
	ULONG NumberOfThreads;
	LARGE_INTEGER SpareLi1;
	LARGE_INTEGER SpareLi2;
	LARGE_INTEGER SpareLi3;
	LARGE_INTEGER CreateTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER KernelTime;
	UNICODE_STRING ImageName;
	KPRIORITY BasePriority;
	HANDLE UniqueProcessId;
	HANDLE InheritedFromUniqueProcessId;
	ULONG HandleCount;
	ULONG SessionId;
	ULONG_PTR PageDirectoryBase;
	SIZE_T PeakVirtualSize;
	SIZE_T VirtualSize;
	ULONG PageFaultCount;
	SIZE_T PeakWorkingSetSize;
	SIZE_T WorkingSetSize;
	SIZE_T QuotaPeakPagedPoolUsage;
	SIZE_T QuotaPagedPoolUsage;
	SIZE_T QuotaPeakNonPagedPoolUsage;
	SIZE_T QuotaNonPagedPoolUsage;
	SIZE_T PagefileUsage;
	SIZE_T PeakPagefileUsage;
	SIZE_T PrivatePageCount;
	LARGE_INTEGER ReadOperationCount;
	LARGE_INTEGER WriteOperationCount;
	LARGE_INTEGER OtherOperationCount;
	LARGE_INTEGER ReadTransferCount;
	LARGE_INTEGER WriteTransferCount;
	LARGE_INTEGER OtherTransferCount;
} SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQuerySystemInformation(
	__in SYSTEM_INFORMATION_CLASS SystemInformationClass,
	__out_bcount_opt(SystemInformationLength) PVOID SystemInformation,
	__in ULONG SystemInformationLength,
	__out_opt PULONG ReturnLength
);


typedef struct _SYSTEM_TIMEOFDAY_INFORMATION {
	LARGE_INTEGER BootTime;
	LARGE_INTEGER CurrentTime;
	LARGE_INTEGER TimeZoneBias;
	ULONG TimeZoneId;
	ULONG Reserved;
	ULONGLONG BootTimeBias;
	ULONGLONG SleepTimeBias;
} SYSTEM_TIMEOFDAY_INFORMATION, *PSYSTEM_TIMEOFDAY_INFORMATION;

#if 0
typedef enum _PROCESSINFOCLASS
{
	ProcessBasicInformation, // q: PROCESS_BASIC_INFORMATION, PROCESS_EXTENDED_BASIC_INFORMATION
	ProcessQuotaLimits, // qs: QUOTA_LIMITS, QUOTA_LIMITS_EX
	ProcessIoCounters, // q: IO_COUNTERS
	ProcessVmCounters, // q: VM_COUNTERS, VM_COUNTERS_EX, VM_COUNTERS_EX2
	ProcessTimes, // q: KERNEL_USER_TIMES
	ProcessBasePriority, // s: KPRIORITY
	ProcessRaisePriority, // s: ULONG
	ProcessDebugPort, // q: HANDLE
	ProcessExceptionPort, // s: PROCESS_EXCEPTION_PORT
	ProcessAccessToken, // s: PROCESS_ACCESS_TOKEN
	ProcessLdtInformation, // qs: PROCESS_LDT_INFORMATION // 10
	ProcessLdtSize, // s: PROCESS_LDT_SIZE
	ProcessDefaultHardErrorMode, // qs: ULONG
	ProcessIoPortHandlers, // (kernel-mode only)
	ProcessPooledUsageAndLimits, // q: POOLED_USAGE_AND_LIMITS
	ProcessWorkingSetWatch, // q: PROCESS_WS_WATCH_INFORMATION[]; s: void
	ProcessUserModeIOPL,
	ProcessEnableAlignmentFaultFixup, // s: BOOLEAN
	ProcessPriorityClass, // qs: PROCESS_PRIORITY_CLASS
	ProcessWx86Information,
	ProcessHandleCount, // q: ULONG, PROCESS_HANDLE_INFORMATION // 20
	ProcessAffinityMask, // s: KAFFINITY
	ProcessPriorityBoost, // qs: ULONG
	ProcessDeviceMap, // qs: PROCESS_DEVICEMAP_INFORMATION, PROCESS_DEVICEMAP_INFORMATION_EX
	ProcessSessionInformation, // q: PROCESS_SESSION_INFORMATION
	ProcessForegroundInformation, // s: PROCESS_FOREGROUND_BACKGROUND
	ProcessWow64Information, // q: ULONG_PTR
	ProcessImageFileName, // q: UNICODE_STRING
	ProcessLUIDDeviceMapsEnabled, // q: ULONG
	ProcessBreakOnTermination, // qs: ULONG
	ProcessDebugObjectHandle, // q: HANDLE // 30
	ProcessDebugFlags, // qs: ULONG
	ProcessHandleTracing, // q: PROCESS_HANDLE_TRACING_QUERY; s: size 0 disables, otherwise enables
	ProcessIoPriority, // qs: IO_PRIORITY_HINT
	ProcessExecuteFlags, // qs: ULONG
	ProcessResourceManagement, // ProcessTlsInformation // PROCESS_TLS_INFORMATION
	ProcessCookie, // q: ULONG
	ProcessImageInformation, // q: SECTION_IMAGE_INFORMATION
	ProcessCycleTime, // q: PROCESS_CYCLE_TIME_INFORMATION // since VISTA
	ProcessPagePriority, // q: PAGE_PRIORITY_INFORMATION
	ProcessInstrumentationCallback, // qs: PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION // 40
	ProcessThreadStackAllocation, // s: PROCESS_STACK_ALLOCATION_INFORMATION, PROCESS_STACK_ALLOCATION_INFORMATION_EX
	ProcessWorkingSetWatchEx, // q: PROCESS_WS_WATCH_INFORMATION_EX[]
	ProcessImageFileNameWin32, // q: UNICODE_STRING
	ProcessImageFileMapping, // q: HANDLE (input)
	ProcessAffinityUpdateMode, // qs: PROCESS_AFFINITY_UPDATE_MODE
	ProcessMemoryAllocationMode, // qs: PROCESS_MEMORY_ALLOCATION_MODE
	ProcessGroupInformation, // q: USHORT[]
	ProcessTokenVirtualizationEnabled, // s: ULONG
	ProcessConsoleHostProcess, // q: ULONG_PTR // ProcessOwnerInformation
	ProcessWindowInformation, // q: PROCESS_WINDOW_INFORMATION // 50
	ProcessHandleInformation, // q: PROCESS_HANDLE_SNAPSHOT_INFORMATION // since WIN8
	ProcessMitigationPolicy, // s: PROCESS_MITIGATION_POLICY_INFORMATION
	ProcessDynamicFunctionTableInformation,
	ProcessHandleCheckingMode, // qs: ULONG; s: 0 disables, otherwise enables
	ProcessKeepAliveCount, // q: PROCESS_KEEPALIVE_COUNT_INFORMATION
	ProcessRevokeFileHandles, // s: PROCESS_REVOKE_FILE_HANDLES_INFORMATION
	ProcessWorkingSetControl, // s: PROCESS_WORKING_SET_CONTROL
	ProcessHandleTable, // since WINBLUE
	ProcessCheckStackExtentsMode,
	ProcessCommandLineInformation, // q: UNICODE_STRING // 60
	ProcessProtectionInformation, // q: PS_PROTECTION
	ProcessMemoryExhaustion, // PROCESS_MEMORY_EXHAUSTION_INFO // since THRESHOLD
	ProcessFaultInformation, // PROCESS_FAULT_INFORMATION
	ProcessTelemetryIdInformation, // PROCESS_TELEMETRY_ID_INFORMATION
	ProcessCommitReleaseInformation, // PROCESS_COMMIT_RELEASE_INFORMATION
	ProcessDefaultCpuSetsInformation,
	ProcessAllowedCpuSetsInformation,
	ProcessSubsystemProcess,
	ProcessJobMemoryInformation, // PROCESS_JOB_MEMORY_INFO
	ProcessInPrivate, // since THRESHOLD2 // 70
	ProcessRaiseUMExceptionOnInvalidHandleClose,
	ProcessIumChallengeResponse,
	ProcessChildProcessInformation, // PROCESS_CHILD_PROCESS_INFORMATION
	ProcessHighGraphicsPriorityInformation,
	ProcessSubsystemInformation, // q: SUBSYSTEM_INFORMATION_TYPE // since REDSTONE2
	ProcessEnergyValues, // PROCESS_ENERGY_VALUES, PROCESS_EXTENDED_ENERGY_VALUES
	ProcessActivityThrottleState, // PROCESS_ACTIVITY_THROTTLE_STATE
	ProcessActivityThrottlePolicy, // PROCESS_ACTIVITY_THROTTLE_POLICY
	ProcessWin32kSyscallFilterInformation,
	ProcessDisableSystemAllowedCpuSets, // 80
	ProcessWakeInformation, // PROCESS_WAKE_INFORMATION
	ProcessEnergyTrackingState, // PROCESS_ENERGY_TRACKING_STATE
	ProcessManageWritesToExecutableMemory, // MANAGE_WRITES_TO_EXECUTABLE_MEMORY // since REDSTONE3
	ProcessCaptureTrustletLiveDump,
	ProcessTelemetryCoverage,
	ProcessEnclaveInformation,
	ProcessEnableReadWriteVmLogging, // PROCESS_READWRITEVM_LOGGING_INFORMATION
	ProcessUptimeInformation, // PROCESS_UPTIME_INFORMATION
	ProcessImageSection,
	ProcessDebugAuthInformation, // since REDSTONE4 // 90
	ProcessSystemResourceManagement, // PROCESS_SYSTEM_RESOURCE_MANAGEMENT
	ProcessSequenceNumber, // q: ULONGLONG
	ProcessLoaderDetour, // since REDSTONE5
	ProcessSecurityDomainInformation, // PROCESS_SECURITY_DOMAIN_INFORMATION
	ProcessCombineSecurityDomainsInformation, // PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION
	ProcessEnableLogging, // PROCESS_LOGGING_INFORMATION
	ProcessLeapSecondInformation, // PROCESS_LEAP_SECOND_INFORMATION
	ProcessFiberShadowStackAllocation, // PROCESS_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION // since 19H1
	ProcessFreeFiberShadowStackAllocation, // PROCESS_FREE_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION
	MaxProcessInfoClass
} PROCESSINFOCLASS;
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationProcess(
	_In_ HANDLE ProcessHandle,
	_In_ PROCESSINFOCLASS ProcessInformationClass,
	_Out_writes_bytes_(ProcessInformationLength) PVOID ProcessInformation,
	_In_ ULONG ProcessInformationLength,
	_Out_opt_ PULONG ReturnLength
);

typedef struct _THREAD_BASIC_INFORMATION {
	NTSTATUS ExitStatus;
	PVOID TebBaseAddress;
	CLIENT_ID ClientId;
	ULONG_PTR AffinityMask;
	KPRIORITY Priority;
	LONG BasePriority;
} THREAD_BASIC_INFORMATION;
typedef THREAD_BASIC_INFORMATION *PTHREAD_BASIC_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationThread(
	__in HANDLE ThreadHandle,
	__in THREADINFOCLASS ThreadInformationClass,
	__out_bcount(ThreadInformationLength) PVOID ThreadInformation,
	__in ULONG ThreadInformationLength,
	__out_opt PULONG ReturnLength
);

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenThread(
	__out PHANDLE ThreadHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes,
	__in_opt PCLIENT_ID ClientId
);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenProcessToken(
	_In_ HANDLE ProcessHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_Out_ PHANDLE TokenHandle
);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenProcessTokenEx(
	_In_ HANDLE ProcessHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ ULONG HandleAttributes,
	_Out_ PHANDLE TokenHandle
);

typedef
VOID
(*PKNORMAL_ROUTINE) (
	IN PVOID NormalContext,
	IN PVOID SystemArgument1,
	IN PVOID SystemArgument2
	);

typedef
VOID
(*PKKERNEL_ROUTINE) (
	IN struct _KAPC *Apc,
	IN OUT PKNORMAL_ROUTINE *NormalRoutine,
	IN OUT PVOID *NormalContext,
	IN OUT PVOID *SystemArgument1,
	IN OUT PVOID *SystemArgument2
	);

typedef
VOID
(*PKRUNDOWN_ROUTINE) (
	IN struct _KAPC *Apc
	);

typedef enum _KAPC_ENVIRONMENT {
	OriginalApcEnvironment,
	AttachedApcEnvironment,
	CurrentApcEnvironment,
	InsertApcEnvironment
} KAPC_ENVIRONMENT;


NTKERNELAPI
VOID
KeInitializeApc(
	__out PRKAPC Apc,
	__in PRKTHREAD Thread,
	__in KAPC_ENVIRONMENT Environment,
	__in PKKERNEL_ROUTINE KernelRoutine,
	__in_opt PKRUNDOWN_ROUTINE RundownRoutine,
	__in_opt PKNORMAL_ROUTINE NormalRoutine,
	__in_opt KPROCESSOR_MODE ProcessorMode,
	__in_opt PVOID NormalContext
);

NTKERNELAPI
BOOLEAN
KeInsertQueueApc(
	__inout PRKAPC Apc,
	__in_opt PVOID SystemArgument1,
	__in_opt PVOID SystemArgument2,
	__in KPRIORITY Increment
);
```

`kernel/process.c`:

```c

#include <ntifs.h>
#include <ntstrsafe.h>

#include "ntheader.h"
#include "globals.h"
#include "utils.h"
#include "log.h"
#include "process.h"
#include "file.h"

#define _countof(array) (sizeof(array)/sizeof(array[0]))

ULONG gProcessNameOff;
KTIMER gWaitProcessExitTimer;
KDPC gWaitProcessExitDpc;
FAST_MUTEX gProcessListMutex;
LIST_ENTRY gProcessInfoList;
LIST_ENTRY gProcessDelayExitList;
LONG gGlobalSeq = 0;
NPAGED_LOOKASIDE_LIST gLookasideListThreadProfiling;
KTIMER gTimerProcessProfiling;
KTIMER gTimerThreadProfiling;
KEVENT gEventProfilingReset;
LIST_ENTRY gListEntryArray[0x100];
BOOLEAN gThreadMonitorEnable = FALSE;
BOOLEAN gProcessMonitorEnable = FALSE;
BOOLEAN gSystemModuleLoadMonitorEnable = FALSE;
BOOLEAN gLoadImageMointorEnable = FALSE;
HANDLE ghThreadModuleMonitor;
KEVENT gModuleMonitorExitEvent;
HANDLE gSystemProcessId;
LIST_ENTRY gProcessWaitExitList;


FNZwQueryInformationThread fnZwQueryInformationThread;
FNSeLocateProcessImageName fnSeLocateProcessImageName;
FNPsSetCreateThreadNotifyRoutineEx fnPsSetCreateThreadNotifyRoutineEx;
FNPsSetCreateProcessNotifyRoutineEx2 fnPsSetCreateProcessNotifyRoutineEx2;
FNZwOpenProcessTokenEx fnZwOpenProcessTokenEx;


BOOLEAN
ProcmonQueryProcessInfoFromPeb(
	_In_ HANDLE hProcess,
	_In_ HANDLE ProcessId,
	_In_ PPEB Peb,
	_Out_ PUNICODE_STRING pUniStrProcessName,
	_Out_ PUNICODE_STRING pUniStrCommandLine,
	_Out_ PUNICODE_STRING pUniStrCurrentDirectory,
	_Out_ PVOID *ppEnvironment,
	_Out_ PULONG pEnvLength
)
/*++

Routine Description:

	.

Arguments:

	 -

Return Value:

	If get process name return TRUE. else FALSE

--*/
{
	NTSTATUS Status;
	KAPC_STATE ApcState;

	UNREFERENCED_PARAMETER(ProcessId);

	BOOLEAN bRet = (pUniStrProcessName == NULL);
	if (pUniStrCurrentDirectory) {
		pUniStrCurrentDirectory->Length = pUniStrCurrentDirectory->MaximumLength = 0;
		pUniStrCurrentDirectory->Buffer = NULL;
	}

	if (ppEnvironment) {
		*ppEnvironment = NULL;
	}

	if (pEnvLength) {
		*pEnvLength = 0;
	}

	if (hProcess && Peb) {
		PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
		PEPROCESS Process;

		Status = ObReferenceObjectByHandle(hProcess, 0, NULL, 0, &Process, NULL);
		if (!NT_SUCCESS(Status))
			return FALSE;


		//
		// Try to Attach process
		//

		KeStackAttachProcess(Process, &ApcState);

		//
		// Peb is usermode address so we need try except
		//

		try {
			ProcessParameters = Peb->ProcessParameters;
			if (ProcessParameters) {
				UNICODE_STRING uniStrTemp;
				if (pUniStrProcessName) {

					try {
						if (ProcessParameters->Flags & 1) {
							uniStrTemp.Buffer = ProcessParameters->ImagePathName.Buffer;
						}
						else {
							uniStrTemp.Buffer = (PWCH)((ULONG_PTR)ProcessParameters + (ULONG_PTR)ProcessParameters->ImagePathName.Buffer);
						}

						uniStrTemp.Length = ProcessParameters->ImagePathName.Length;
						uniStrTemp.MaximumLength = ProcessParameters->ImagePathName.MaximumLength;

						ProcmonDuplicateUnicodeString2(pUniStrProcessName, &uniStrTemp, '5');
						bRet = pUniStrProcessName->Buffer != NULL;
					}
					except (EXCEPTION_EXECUTE_HANDLER) {
						if (pUniStrProcessName->Buffer) {
							ExFreePoolWithTag(pUniStrProcessName->Buffer, 0);
						}
					}

				}

				if (pUniStrCommandLine) {

					try {
						if (ProcessParameters->Flags & 1) {
							uniStrTemp.Buffer = ProcessParameters->CommandLine.Buffer;
						}
						else {
							uniStrTemp.Buffer = (PWCH)((ULONG_PTR)ProcessParameters + (ULONG_PTR)ProcessParameters->CommandLine.Buffer);
						}
						uniStrTemp.Length = ProcessParameters->CommandLine.Length;
						uniStrTemp.MaximumLength = ProcessParameters->CommandLine.MaximumLength;

						ProcmonDuplicateUnicodeString2(pUniStrCommandLine, &uniStrTemp, '6');
					}
					except (EXCEPTION_EXECUTE_HANDLER) {
						if (pUniStrCommandLine->Buffer) {
							ExFreePoolWithTag(pUniStrCommandLine->Buffer, 0);
						}
					}
				}

				if (pUniStrCurrentDirectory) {

					try {
						if (ProcessParameters->Flags & 1) {
							uniStrTemp.Buffer = ProcessParameters->CurrentDirectory.DosPath.Buffer;
						}
						else {
							uniStrTemp.Buffer = (PWCH)((ULONG_PTR)ProcessParameters +
								(ULONG_PTR)ProcessParameters->CurrentDirectory.DosPath.Buffer);
						}
						uniStrTemp.Length = ProcessParameters->CurrentDirectory.DosPath.Length;
						uniStrTemp.MaximumLength = ProcessParameters->CurrentDirectory.DosPath.MaximumLength;

						ProcmonDuplicateUnicodeString2(pUniStrCurrentDirectory, &uniStrTemp, '7');
					}
					except (EXCEPTION_EXECUTE_HANDLER) {
						if (pUniStrCurrentDirectory->Buffer) {
							ExFreePoolWithTag(pUniStrCurrentDirectory->Buffer, 0);
						}
					}

				}

				if (ppEnvironment && pEnvLength) {
					try {
						PVOID pEnvNew;
						ULONG EnvironmentLength;
						PWCHAR s = (PWCHAR)ProcessParameters->Environment;
						while (*s++) {
							while (*s++) {
							}
						}

						EnvironmentLength = (ULONG)(s - (PWCHAR)ProcessParameters->Environment) * sizeof(WCHAR);
						pEnvNew = ProcmonAllocatePoolWithTag(NonPagedPool, EnvironmentLength, '8');
						*ppEnvironment = pEnvNew;
						if (pEnvNew) {
							RtlCopyMemory(pEnvNew, ProcessParameters->Environment, EnvironmentLength);
							*pEnvLength = EnvironmentLength;
						}

					}
					except (EXCEPTION_EXECUTE_HANDLER) {
						if (ppEnvironment) {
							ExFreePoolWithTag(ppEnvironment, 0);
						}
					}
				}
			}
		}
		except (EXCEPTION_EXECUTE_HANDLER) {
			NOTHING;
		}

		KeUnstackDetachProcess(&ApcState);
		ObDereferenceObject(Process);
	}

	return bRet;

}

#define IDLE_NAME "Idle"

NTSTATUS
ProcmonQueryProcessNameFromProcessObject(
	_In_ HANDLE hProcess,
	_Out_ PUNICODE_STRING pUniStrProcessName
)
/*++

Routine Description:

	.

Arguments:

	 -

Return Value:

	Routine can return non success error codes.

--*/
{
	NTSTATUS Status = STATUS_SUCCESS;
	PEPROCESS Process;
	ANSI_STRING StrProcName;
	CHAR ProcNameBuf[0x1F] = { 0 };

	pUniStrProcessName->Length = pUniStrProcessName->MaximumLength = 0;
	StrProcName.Buffer = ProcNameBuf;
	StrProcName.MaximumLength = sizeof(ProcNameBuf);

	if (!hProcess) {

		//
		// Idle
		//

		RtlStringCchCopyA(ProcNameBuf, sizeof(ProcNameBuf), "Idle");
		Status = STATUS_SUCCESS;
	}
	else {
		Status = ObReferenceObjectByHandle(hProcess, 0, NULL, KernelMode, &Process, NULL);
		if (NT_SUCCESS(Status)) {
			RtlStringCchCopyNA(ProcNameBuf, sizeof(ProcNameBuf), (PCHAR)((ULONG_PTR)Process + gProcessNameOff),
				sizeof(ProcNameBuf));
		}
	}

	if (ProcNameBuf[0]) {

		USHORT nNameLength, nUniNameLength;

		ProcNameBuf[sizeof(ProcNameBuf) - 1] = '\0';
		nNameLength = (USHORT)strlen(ProcNameBuf);

		StrProcName.Length = nNameLength;
		nUniNameLength = (nNameLength + 1) * sizeof(WCHAR);
		pUniStrProcessName->MaximumLength = nUniNameLength;
		pUniStrProcessName->Buffer = (PWCH)ProcmonAllocatePoolWithTag(NonPagedPool, nUniNameLength, 'G');
		if (pUniStrProcessName->Buffer) {
			Status = RtlAnsiStringToUnicodeString(pUniStrProcessName, &StrProcName, FALSE);
		}
	}

	return Status;
}


VOID
ProcmonFillProcessInfo(
	_In_ PPROCESSINFO_LIST pProcessInfo
)
/*++

Routine Description:

	.

Arguments:

	 -

Return Value:

	Routine can return non success error codes.

--*/
{
	NTSTATUS Status;
	CLIENT_ID ClientId;
	OBJECT_ATTRIBUTES ObjectAttributes;
	HANDLE hProcess = NULL;
	PROCESS_EXTENDED_BASIC_INFORMATION ProcessExtBasicInfo = { 0 };
	PROCESS_SESSION_INFORMATION SessinInfo = {0};
	PVOID pProcBasicInfo;
	ULONG Length, LogBufLength = 0, LogBufExtLength = 0;
	HANDLE hToken;
	PTOKEN_USER pTokenUser = NULL;
	ULONG TokenUserLength = 0;
	TOKEN_STATISTICS Statistics;
	ULONG VirtualizationEnabled = 0;
	PTOKEN_MANDATORY_LABEL pIntegrityLevel = NULL;
	ULONG IntegrityLevelSidLength = 0;
	ULONG_PTR pWow64Information = 0;
	PLOG_BUFFER pLogBuf;
	PPROCESS_FULL_INFO pProcessFullInfo;
	UNICODE_STRING UniStrProcessName = {0};
	UNICODE_STRING UniStrCommandLine = { 0 };
	UNICODE_STRING UniStrCurrentDirectory = {0};
	PVOID pEnvironment = NULL;
	ULONG EnvLength = 0;
	KERNEL_USER_TIMES KernelUserTime;
	PLOG_PROCESSCREATE_INFO pProcCreateInfo;
 
	RtlZeroMemory(&Statistics, sizeof(Statistics));

	pProcessInfo->bInit = TRUE;

	if (pProcessInfo->ProcessId){

		//
		// try to open process
		//

		ClientId.UniqueThread = 0;
		ClientId.UniqueProcess = pProcessInfo->ProcessId;
		InitializeObjectAttributes(&ObjectAttributes, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);
		Status = ZwOpenProcess(&hProcess, 0, &ObjectAttributes, &ClientId);
		if (!NT_SUCCESS(Status)) {
			pProcessInfo->bInit = FALSE;
			return;
		}

		if (gBuildNumber < 6000) {

			//
			// Xp or lower
			//

			LARGE_INTEGER Timeout;

			Timeout.QuadPart = 0;
			if (ZwWaitForSingleObject(hProcess, 0, &Timeout) != STATUS_TIMEOUT) {
				ZwClose(hProcess);
				pProcessInfo->bInit = FALSE;
				return;
			}
		}

		if (gBuildNumber < 6000) {
			pProcBasicInfo = &ProcessExtBasicInfo.BasicInfo;
			Length = sizeof(PROCESS_BASIC_INFORMATION);
		}else{
			pProcBasicInfo = &ProcessExtBasicInfo;
			ProcessExtBasicInfo.Size = Length = sizeof(PROCESS_EXTENDED_BASIC_INFORMATION);

		}

		//
		// Query process basic information
		//

		Status = ZwQueryInformationProcess(hProcess, ProcessBasicInformation,
			pProcBasicInfo, Length, NULL);
		if (!NT_SUCCESS(Status)) {
			ZwClose(hProcess);
			pProcessInfo->bInit = FALSE;
			return;
		}

		//
		// Query process session information
		// Always success
		//

		ZwQueryInformationProcess(hProcess, ProcessSessionInformation, &SessinInfo,
			sizeof(SessinInfo), NULL);
		
		if (fnZwOpenProcessTokenEx)
			Status = (fnZwOpenProcessTokenEx)(hProcess, TOKEN_READ, OBJ_KERNEL_HANDLE, &hToken);
		else
			Status = ZwOpenProcessToken(hProcess, TOKEN_READ, &hToken);
		if (NT_SUCCESS(Status)) {
			pTokenUser = ProcmonQueryTokenInformation(hToken, &Statistics, &VirtualizationEnabled, &pIntegrityLevel);
			if (pTokenUser) {
				TokenUserLength = RtlLengthSid(pTokenUser->User.Sid);
			}

			if (pIntegrityLevel) {
				IntegrityLevelSidLength = RtlLengthSid(pIntegrityLevel->Label.Sid);
			}

			ZwClose(hToken);
		}

		Status = ZwQueryInformationProcess(hProcess, ProcessWow64Information,
			&pWow64Information, sizeof(pWow64Information), NULL);

		if (!NT_SUCCESS(Status)) {
			pWow64Information = 0;
		}
	}

	//
	// Exchange the process full info
	//

	pProcessFullInfo = (PPROCESS_FULL_INFO)InterlockedExchangePointer(&pProcessInfo->pProcessFullInfo, NULL);
	if (pProcessFullInfo) {
		if (pProcessFullInfo->ImageFileName.Length) {
			ProcmonDuplicateUnicodeString2(&UniStrProcessName, &pProcessFullInfo->ImageFileName, '5');
		}

		if (pProcessFullInfo->CommandLine.Length) {
			ProcmonDuplicateUnicodeString2(&UniStrCommandLine, &pProcessFullInfo->CommandLine, '6');
		}
	}

	if (/*ProcessExtBasicInfo.IsSubsystemProcess*/ProcessExtBasicInfo.Flags & 0x100) {

		//
		// Try to get subsystem process name
		//

		if (UniStrProcessName.Length == 0) {

			PEPROCESS pProcess;
			Status = ObReferenceObjectByHandle(hProcess, 0, NULL, KernelMode, &pProcess, NULL);
			if (NT_SUCCESS(Status)) {

				PUNICODE_STRING pUniStrProcessName;

				Status = fnSeLocateProcessImageName(pProcess, &pUniStrProcessName);
				if (NT_SUCCESS(Status) && pUniStrProcessName) {
					ProcmonDuplicateUnicodeString2(&UniStrProcessName, pUniStrProcessName, '5');

					//
					// clean up
					//

					ExFreePoolWithTag(pUniStrProcessName, 0);
				}
				ObDereferenceObject(pProcess);
			}
		}
	}else{

		BOOLEAN bRet;
		PVOID *ppEnvironment = &pEnvironment;
		PULONG pEnvLength = &EnvLength;
		PUNICODE_STRING pUniStrCurrentDir = &UniStrCurrentDirectory;
		PUNICODE_STRING pUniStrProcessName = &UniStrProcessName;
		PUNICODE_STRING pUniStrCommandLine = &UniStrCommandLine;

		if (!pProcessFullInfo) {
			ppEnvironment = NULL;
			pEnvLength = NULL;
			pUniStrCurrentDir = NULL;
		}

		if (UniStrCommandLine.Length) {
			pUniStrCommandLine = NULL;
		}

		if (UniStrProcessName.Length) {
			pUniStrProcessName = NULL;
		}

		bRet = ProcmonQueryProcessInfoFromPeb(hProcess, pProcessInfo->ProcessId,
			ProcessExtBasicInfo.BasicInfo.PebBaseAddress, pUniStrProcessName, pUniStrCommandLine,
			pUniStrCurrentDir, ppEnvironment, pEnvLength);
		if (!bRet) {

			//
			// Failed we need get the process name from process object
			//

			ProcmonQueryProcessNameFromProcessObject(hProcess, &UniStrProcessName);

		}
	}

	//
	// Get process time
	//

	if (pProcessFullInfo) {
		KernelUserTime.CreateTime = ProcmonGetTime();
	}
	else {
		KernelUserTime.CreateTime.QuadPart = 0;
		if (hProcess) {
			ZwQueryInformationProcess(hProcess, ProcessTimes, &KernelUserTime, sizeof(KernelUserTime), NULL);
			if (!KernelUserTime.CreateTime.QuadPart) {
				SYSTEM_TIMEOFDAY_INFORMATION SystemTime;
				if (NT_SUCCESS(ZwQuerySystemInformation(SystemTimeOfDayInformation, &SystemTime,
					sizeof(SystemTime), NULL))) {
					KernelUserTime.CreateTime.QuadPart = SystemTime.BootTime.QuadPart - SystemTime.BootTimeBias;
				}
			}
		}
	}

	if (hProcess) {
		ZwClose(hProcess);
	}

	if (UniStrProcessName.Length) {
		LogBufLength = UniStrProcessName.Length;
	}

	if (UniStrCommandLine.Length) {
		LogBufLength += UniStrCommandLine.Length;
	}

	if (pTokenUser) {
		LogBufLength += (UCHAR)TokenUserLength;
	}

	if (pIntegrityLevel) {
		LogBufLength += (UCHAR)IntegrityLevelSidLength;
	}

	if (pProcessFullInfo) {
		LONG Seq;
		if (pProcessFullInfo->pParentProcessInfo) {
			Seq = pProcessFullInfo->pParentProcessInfo->Seq;
		}else{
			Seq = -1;
		}

		pProcCreateInfo = (PLOG_PROCESSCREATE_INFO)ProcmonGetLogEntryAndInit(
			MONITOR_TYPE_PROCESS, NOTIFY_PROCESS_CREATE, Seq, STATUS_SUCCESS,
			LogBufLength + sizeof(LOG_PROCESSCREATE_INFO), &pLogBuf,
			pProcessFullInfo->StackFrameCounts, pProcessFullInfo->StackFrame);
		DerefProcessInfo(pProcessFullInfo->pParentProcessInfo);
	}else{
		pProcCreateInfo = (PLOG_PROCESSCREATE_INFO)ProcmonGetLogEntryAndInit(
			MONITOR_TYPE_PROCESS, NOTIFY_PROCESS_INIT, pProcessInfo->Seq, STATUS_SUCCESS,
			LogBufLength + sizeof(LOG_PROCESSCREATE_INFO),
			&pLogBuf, 0, NULL);
	}

	if (pProcCreateInfo) {
		PPROCESSINFO_LIST pParentProcInfo;
		ULONG_PTR pBufferEnd = (ULONG_PTR)(pProcCreateInfo + 1);

		pProcCreateInfo->Seq = pProcessInfo->Seq;
		pProcCreateInfo->ParentId = (ULONG)ProcessExtBasicInfo.BasicInfo.InheritedFromUniqueProcessId;
		pParentProcInfo = RefProcessInfo((HANDLE)ProcessExtBasicInfo.BasicInfo.InheritedFromUniqueProcessId, FALSE);
		pProcCreateInfo->ParentProcSeq = pParentProcInfo ? pParentProcInfo->Seq : -1;
		DerefProcessInfo(pParentProcInfo);
		pProcCreateInfo->CreateTime = KernelUserTime.CreateTime;
		pProcCreateInfo->ProcessId = (ULONG)(ULONG_PTR)pProcessInfo->ProcessId;
		pProcCreateInfo->SessionId = SessinInfo.SessionId;
		pProcCreateInfo->TokenVirtualizationEnabled = VirtualizationEnabled;
		pProcCreateInfo->SidLength = (UCHAR)TokenUserLength;
		pProcCreateInfo->IntegrityLevelSidLength = (UCHAR)IntegrityLevelSidLength;
		pProcCreateInfo->IsWow64 = pWow64Information == 0;
		pProcCreateInfo->AuthenticationId = Statistics.AuthenticationId;
		pProcCreateInfo->CommandLineLength = UniStrCommandLine.Length >> 1;
		pProcCreateInfo->ProcNameLength = UniStrProcessName.Length >> 1;

		if (TokenUserLength) {
			RtlCopyMemory((PVOID)pBufferEnd, pTokenUser->User.Sid, TokenUserLength);
			pBufferEnd += TokenUserLength;
		}

		if (pIntegrityLevel) {
			RtlCopyMemory((PVOID)pBufferEnd, pIntegrityLevel->Label.Sid, IntegrityLevelSidLength);
			pBufferEnd += IntegrityLevelSidLength;
		}

		if (UniStrProcessName.Buffer) {
			RtlCopyMemory((PVOID)pBufferEnd, UniStrProcessName.Buffer, UniStrProcessName.Length);
			pBufferEnd += UniStrProcessName.Length;
		}

		if (UniStrCommandLine.Buffer) {
			RtlCopyMemory((PVOID)pBufferEnd, UniStrCommandLine.Buffer, UniStrCommandLine.Length);
		}

		ProcmonNotifyProcessLog(pLogBuf);
	}else{
		pProcessInfo->bInit = FALSE;
	}

	if (UniStrCommandLine.Length) {
		LogBufExtLength = UniStrCommandLine.Length;
	}

	if (UniStrCurrentDirectory.Length) {
		LogBufExtLength += UniStrCurrentDirectory.Length;
	}

	if (EnvLength) {
		LogBufExtLength += EnvLength;
	}

	if (pProcessFullInfo) {
		PLOG_PROCESSSTART_INFO pLogStartBuf = (PLOG_PROCESSSTART_INFO)ProcmonGetLogEntryAndCopyFrameChain(
			MONITOR_TYPE_PROCESS, NOTIFY_PROCESS_START, pProcessInfo->Seq, 0,
			LogBufExtLength + sizeof(LOG_PROCESSSTART_INFO), &pLogBuf);
		ULONG_PTR pBufEnd = (ULONG_PTR)(pLogStartBuf + 1);

		if (pLogStartBuf) {
			pLogStartBuf->ParentId = (ULONG)(ULONG_PTR)ProcessExtBasicInfo.BasicInfo.InheritedFromUniqueProcessId;
			pLogStartBuf->CommandLineLength = UniStrCommandLine.Length >> 1;
			pLogStartBuf->CurrentDirectoryLength = UniStrCurrentDirectory.Length >> 1;
			pLogStartBuf->EnvironmentLength = EnvLength >> 1;

			if (UniStrCommandLine.Buffer) {
				RtlCopyMemory((PVOID)pBufEnd, UniStrCommandLine.Buffer, UniStrCommandLine.Length);
				pBufEnd += UniStrCommandLine.Length;
			}

			if (UniStrCurrentDirectory.Buffer) {
				RtlCopyMemory((PVOID)pBufEnd, UniStrCurrentDirectory.Buffer, UniStrCurrentDirectory.Length);
				pBufEnd += UniStrCurrentDirectory.Length;
			}

			if (EnvLength) {
				RtlCopyMemory((PVOID)pBufEnd, pEnvironment, EnvLength);
			}

			ProcmonNotifyProcessLog(pLogBuf);
		}
	}

	//
	// Clean up
	//

	if (pProcessFullInfo)
		ExFreePoolWithTag(pProcessFullInfo, 0);
	if (TokenUserLength)
		ExFreePoolWithTag(pTokenUser, 0);
	if (UniStrProcessName.Length)
		ExFreePoolWithTag(UniStrProcessName.Buffer, 0);
	if (UniStrCommandLine.Length)
		ExFreePoolWithTag(UniStrCommandLine.Buffer, 0);
	if (EnvLength)
		ExFreePoolWithTag(pEnvironment, 0);
	if (UniStrCurrentDirectory.Length)
		ExFreePoolWithTag(UniStrCurrentDirectory.Buffer, 0);
	if (IntegrityLevelSidLength)
		ExFreePoolWithTag(pIntegrityLevel, 0);

}

PPROCESSINFO_LIST
FindProcessInfoByProcessId(
	_In_ HANDLE ProcessId
)
/*++

Routine Description:

	.

Arguments:

	 -

Return Value:

	Routine can return non success error codes.

--*/
{
	PLIST_ENTRY pEntry;

	if (IsListEmpty(&gProcessInfoList)) {
		return NULL;
	}

	for (pEntry = gProcessInfoList.Flink;
		pEntry != &gProcessInfoList;
		pEntry = pEntry->Flink)
	{
		PPROCESSINFO_LIST pProcessInfo = CONTAINING_RECORD(pEntry, PROCESSINFO_LIST, List);
		if (pProcessInfo->ProcessId == ProcessId) {

			//
			// find it, add refcount.
			//

			InterlockedIncrement(&pProcessInfo->RefCount);

			//
			// if this Entry not at the list head.move to list head
			//

			if (gProcessInfoList.Flink != pEntry) {
				RemoveEntryList(pEntry);
				InsertHeadList(&gProcessInfoList, pEntry);
			}

			return pProcessInfo;
		}
	}

	return NULL;
}

PPROCESSINFO_LIST
RefProcessInfo(
	_In_ HANDLE ProcessId,
	_In_ BOOLEAN bNotAsyn
)
/*++

Routine Description:

	.

Arguments:

	 -

Return Value:

	Routine can return non success error codes.

--*/
{
	PPROCESSINFO_LIST pProcessInfoFind;
	PPROCESSINFO_LIST pNewProcessInfo;

	//
	// 这里查询也需要锁得原因是由于在查询的过程中
	// 如果查询到ProcessInfo我们会将ProcessInfo放在链表的头部
	// 这样就对链表进行了修改,所以这里需要加锁
	//

	ExAcquireFastMutex(&gProcessListMutex);
	if (!gFlags) {
		ExReleaseFastMutex(&gProcessListMutex);
		return NULL;
	}

	pProcessInfoFind = FindProcessInfoByProcessId(ProcessId);
	ExReleaseFastMutex(&gProcessListMutex);
	if (pProcessInfoFind == NULL) {

		//
		// This process do not in process list
		// allocate a new one and add to process list
		//

		pNewProcessInfo = (PPROCESSINFO_LIST)ProcmonAllocatePoolWithTag(NonPagedPool,
			sizeof(PROCESSINFO_LIST), '7');
		if (pNewProcessInfo) {
			pNewProcessInfo->ProcessId = ProcessId;
			pNewProcessInfo->RefCount = 1;
			pNewProcessInfo->Seq = InterlockedExchangeAdd(&gGlobalSeq, 1) + 1;
			pNewProcessInfo->bInit = FALSE;
			pNewProcessInfo->pProcessFullInfo = NULL;
			pNewProcessInfo->Process = NULL;

			//
			// Find process again. because ProcmonAllocatePoolWithTag is slow
			// Another thread may add to list already.
			// 作者的意思:
			// 这里再次在链表里查找, 因为ProcmonAllocatePoolWithTag可能会慢.所以其他线程
			// 很有可能已经创建了这个Process结构, 所以我们再查询一下.
			//
			// 个人感觉：
			// 其实没这比较就直接一个锁锁住,然后添加就完事了,性能应该不会有太大的降低
			//

			ExAcquireFastMutex(&gProcessListMutex);
			pProcessInfoFind = FindProcessInfoByProcessId(ProcessId);

			//
			// 如果没有找到, 并且监控开关已经打开
			//

			if (!pProcessInfoFind && gFlags) {

				//
				// 添加到链表中去
				//

				InsertHeadList(&gProcessInfoList, &pNewProcessInfo->List);
				pProcessInfoFind = pNewProcessInfo;
				InterlockedIncrement(&pNewProcessInfo->RefCount);
			}
			ExReleaseFastMutex(&gProcessListMutex);

			//
			// 如果是新添加的
			//

			if (pProcessInfoFind == pNewProcessInfo) {

				//
				// 如果是同步IO,则立即填充ProcessInfo
				//

				if (bNotAsyn) {
					ProcmonFillProcessInfo(pProcessInfoFind);
				}
			}else{

				//
				// 这里表示其他线程已经添加了ProcessInfo
				// 不用我们再次添加,释放掉
				//

				ExFreePoolWithTag(pNewProcessInfo, 0);
			}
		}
	}

	if (pProcessInfoFind) {
		if (pProcessInfoFind->pProcessFullInfo || (bNotAsyn && !pProcessInfoFind->bInit)) {
			ProcmonFillProcessInfo(pProcessInfoFind);
		}
	}

	return pProcessInfoFind;
}

VOID
DerefProcessInfo(
	_In_ PPROCESSINFO_LIST pProcessInfo
)
/*++

Routine Description:

	.

Arguments:

	 -

Return Value:

	Routine can return non success error codes.

--*/
{
	BOOLEAN bNeedFree = FALSE;

	if (!pProcessInfo) {
		return;
	}

	if (!InterlockedDecrement(&pProcessInfo->RefCount)) {

		ExAcquireFastMutex(&gProcessListMutex);
		if (!pProcessInfo->RefCount) {
			if (pProcessInfo->List.Flink){
				RemoveEntryList(&pProcessInfo->List);
			}
			bNeedFree = TRUE;
		}
		ExReleaseFastMutex(&gProcessListMutex);
		if (bNeedFree) {
			ExFreePoolWithTag(pProcessInfo, 0);
		}
	}
}

BOOLEAN
RefThreadInfo(
	VOID
)
/*++

Routine Description:

	.

Arguments:

	 -

Return Value:

	Routine can return non success error codes.

--*/
{
	PETHREAD Thread;
	PLIST_ENTRY pEntry;
	PTHREADINFO_LIST pThreadInfo;
	BOOLEAN bFind = FALSE;

	//
	// Lock
	//

	Thread = KeGetCurrentThread();
	ExAcquireFastMutex(&gThreadInfoMutex);

	for (pEntry = gThreadInfoList.Flink;
		pEntry != &gThreadInfoList;
		pEntry = pEntry->Flink) {
		pThreadInfo = CONTAINING_RECORD(pEntry, THREADINFO_LIST, List);
		if (pThreadInfo->Thread == Thread) {

			//
			//  This thread has been record
			//

			++pThreadInfo->RefCount;
			//InterlockedIncrement(&pThreadInfo->RefCount);
			bFind = TRUE;
		}
	}

	if (!bFind) {

		//
		// Not find in thread list. add a new record
		//

		pThreadInfo = ExAllocateFromNPagedLookasideList(&gNPagedLooksideListThreadInfo);
		pThreadInfo->RefCount = 1;
		pThreadInfo->Thread = Thread;
		InsertHeadList(&gThreadInfoList, &pThreadInfo->List);
	}

	ExReleaseFastMutex(&gThreadInfoMutex);
	return bFind;

}

VOID
DeRefThreadInfo(
	VOID
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	PETHREAD Thread;
	PLIST_ENTRY pEntry;
	PTHREADINFO_LIST pThreadInfo = NULL;

	//
	// Lock
	//

	Thread = KeGetCurrentThread();
	ExAcquireFastMutex(&gThreadInfoMutex);

	for (pEntry = gThreadInfoList.Flink;
		pEntry != &gThreadInfoList;
		pEntry = pEntry->Flink) {
		PTHREADINFO_LIST pThreadInfoTmp = CONTAINING_RECORD(pEntry, THREADINFO_LIST, List);
		if (pThreadInfoTmp->Thread == Thread) {
			pThreadInfo = pThreadInfoTmp;
			break;
		}
	}

	if (pThreadInfo){
		if (pThreadInfo->RefCount-- == 1) {
			
			//
			// remove from list
			//
			
			RemoveEntryList(pEntry);
			
			//
			// free the buffer
			//
			
			ExFreeToNPagedLookasideList(&gNPagedLooksideListThreadInfo, pThreadInfo);
		}
	}


	ExReleaseFastMutex(&gThreadInfoMutex);
}

VOID
ProcmonWaitProcessExitWorkRoutine(
	_In_ PVOID pWorkItem
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	PLIST_ENTRY pEntry;
	PEPROCESS Process;
	PLIST_ENTRY pEntryTemp;
	PPROCESSINFO_LIST pProcessInfo;
	LARGE_INTEGER Timeout = { 0 };

	ExAcquireFastMutex(&gProcessListMutex);
	pEntry = gProcessWaitExitList.Flink;
	if (!IsListEmpty(&gProcessWaitExitList))
	{
		do
		{
			pProcessInfo = CONTAINING_RECORD(pEntry, PROCESSINFO_LIST, ProcessExitList);
			Process = pProcessInfo->Process;
			pEntryTemp = pEntry->Flink;

			//
			// Wait process exit 
			//

			if (KeWaitForSingleObject(Process, 0, 0, 0, &Timeout) != STATUS_TIMEOUT)
			{
				RemoveEntryList(&pProcessInfo->ProcessExitList);
				pProcessInfo->Process = NULL;
				if (!InterlockedDecrement(&pProcessInfo->RefCount) && !pProcessInfo->RefCount) {
					if (pProcessInfo->List.Flink) {
						RemoveEntryList(&pProcessInfo->List);
					}
					ExFreePoolWithTag(pProcessInfo, 0);
				}
				ObDereferenceObject(Process);
			}
			pEntry = pEntryTemp;
		} while (pEntryTemp != &gProcessWaitExitList);
		pEntry = gProcessWaitExitList.Flink;
	}
	if (pEntry != &gProcessWaitExitList) {
		LARGE_INTEGER TimerDue;
		TimerDue.QuadPart = -5000000;
		KeSetTimer(&gWaitProcessExitTimer, TimerDue, &gWaitProcessExitDpc);
	}
	ExReleaseFastMutex(&gProcessListMutex);
	ExFreePoolWithTag(pWorkItem, 0);
}

VOID
ProcmonWaitProcessExitDpcRoutine(
	_In_     struct _KDPC *Dpc,
	_In_opt_ PVOID        DeferredContext,
	_In_opt_ PVOID        SystemArgument1,
	_In_opt_ PVOID        SystemArgument2
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	PWORK_QUEUE_ITEM pWorkItem;

	UNREFERENCED_PARAMETER(Dpc);
	UNREFERENCED_PARAMETER(DeferredContext);
	UNREFERENCED_PARAMETER(SystemArgument1);
	UNREFERENCED_PARAMETER(SystemArgument2);

	pWorkItem = ProcmonAllocatePoolWithTag(NonPagedPool, sizeof(WORK_QUEUE_ITEM), 'M');
	if (pWorkItem) {
		pWorkItem->Parameter = pWorkItem;
		pWorkItem->WorkerRoutine = ProcmonWaitProcessExitWorkRoutine;
		pWorkItem->List.Flink = NULL;
		ExQueueWorkItem(pWorkItem, DelayedWorkQueue);
	}
}

VOID
ProcmonProcessMonitorInit(
	VOID
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	UNICODE_STRING UniStrFunctionName;
	PEPROCESS Process = IoGetCurrentProcess();

	for (ULONG Offset = 0; Offset < 0x3000; Offset++)
	{
		if (0 == strncmp("System", (const char*)((ULONG_PTR)Process + Offset), 6)) {
			gProcessNameOff = Offset;
			break;
		}
	}

	ExInitializeNPagedLookasideList(&gLookasideListThreadProfiling, NULL, NULL, 0, sizeof(THREAD_PROFILING_UPDATE_APC), 'nmP', 0);
	InitializeListHead(&gProcessInfoList);
	InitializeListHead(&gProcessWaitExitList);
	ExInitializeFastMutex(&gProcessListMutex);

	RtlInitUnicodeString(&UniStrFunctionName, L"ZwQueryInformationThread");
	fnZwQueryInformationThread = (FNZwQueryInformationThread)MmGetSystemRoutineAddress(&UniStrFunctionName);
	RtlInitUnicodeString(&UniStrFunctionName, L"SeLocateProcessImageName");
	fnSeLocateProcessImageName = (FNSeLocateProcessImageName)MmGetSystemRoutineAddress(&UniStrFunctionName);
	RtlInitUnicodeString(&UniStrFunctionName, L"PsSetCreateProcessNotifyRoutineEx2");
	fnPsSetCreateProcessNotifyRoutineEx2 = (FNPsSetCreateProcessNotifyRoutineEx2)MmGetSystemRoutineAddress(&UniStrFunctionName);
	RtlInitUnicodeString(&UniStrFunctionName, L"PsSetCreateThreadNotifyRoutineEx");
	fnPsSetCreateThreadNotifyRoutineEx = (FNPsSetCreateThreadNotifyRoutineEx)MmGetSystemRoutineAddress(&UniStrFunctionName);
	if (gBuildNumber >= 3790){
		RtlInitUnicodeString(&UniStrFunctionName, L"ZwOpenProcessTokenEx");
		fnZwOpenProcessTokenEx = (FNZwOpenProcessTokenEx)MmGetSystemRoutineAddress(&UniStrFunctionName);
	}

	KeInitializeTimer(&gWaitProcessExitTimer);
	KeInitializeDpc(&gWaitProcessExitDpc, ProcmonWaitProcessExitDpcRoutine, NULL);
	KeInitializeEvent(&gModuleMonitorExitEvent, SynchronizationEvent, 0);
	KeInitializeEvent(&gEventProfilingReset, SynchronizationEvent, 0);
	KeInitializeTimerEx(&gTimerThreadProfiling, SynchronizationTimer);
	KeInitializeTimerEx(&gTimerProcessProfiling, SynchronizationTimer);

	for (int i = 0; i < _countof(gListEntryArray); i++)
	{
		InitializeListHead(&gListEntryArray[i]);
	}

	gSystemProcessId = PsGetCurrentProcessId();

}


VOID
FreeAllProcessInfo(
	VOID
)
/*++

Routine Description:

	.

Arguments:

	 -

Return Value:

	Routine can return non success error codes.

--*/
{
	PLIST_ENTRY pEntry;
	ExAcquireFastMutex(&gProcessListMutex);

	pEntry = gProcessInfoList.Flink;
	if (!IsListEmpty(&gProcessInfoList)) {

		do
		{
			PLIST_ENTRY pEntryTmp = pEntry->Flink;
			PPROCESSINFO_LIST pProcList = CONTAINING_RECORD(pEntry, PROCESSINFO_LIST, List);
			if (pProcList->Process) {
				ObDereferenceObject(pProcList->Process);
				RemoveEntryList(&pProcList->ProcessExitList);
			}

			RemoveEntryList(pEntry);
			pEntry->Flink = NULL;

			if (!InterlockedDecrement(&pProcList->RefCount) && !pProcList->RefCount) {
				if (pEntry->Flink) {
					RemoveEntryList(pEntry);
				}
				ExFreePoolWithTag(pProcList, 0);
			}

			pEntry = pEntryTmp;
		} while (pEntry != &gProcessInfoList);

	}

	ExReleaseFastMutex(&gProcessListMutex);
}

NTSTATUS
ProcmonQueryThreadExitInfo(
	_In_ HANDLE ProcessId,
	_In_ HANDLE ThreadId,
	_Out_ PKERNEL_USER_TIMES pKernelUserTime
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	HANDLE hThread;
	NTSTATUS Status = STATUS_SUCCESS;;
	OBJECT_ATTRIBUTES ObjectAttributes;
	CLIENT_ID ClientId;

	RtlZeroMemory(pKernelUserTime, sizeof(KERNEL_USER_TIMES));
	InitializeObjectAttributes(&ObjectAttributes, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);
	ClientId.UniqueProcess = ProcessId;
	ClientId.UniqueThread = ThreadId;

	if (NT_SUCCESS(ZwOpenThread(&hThread, 0, &ObjectAttributes, &ClientId)) && hThread) {

		THREAD_BASIC_INFORMATION ThreadBasicInfo;
		if (NT_SUCCESS(ZwQueryInformationThread(hThread, ThreadBasicInformation, &ThreadBasicInfo,
			sizeof(ThreadBasicInfo), NULL))) {
			Status = ThreadBasicInfo.ExitStatus;
		}
		ZwQueryInformationThread(hThread, ThreadTimes, pKernelUserTime, sizeof(*pKernelUserTime), NULL);
		ZwClose(hThread);
	}

	return Status;
}

VOID
CreateThreadNotifyRoutine(
	_In_ HANDLE ProcessId,
	_In_ HANDLE ThreadId,
	_In_ BOOLEAN Create
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	NTSTATUS ThreadExitStatus;
	PLOG_BUFFER pLogBuf;
	if (gFlags & 1) {
		PPROCESSINFO_LIST pProcessInfo = RefProcessInfo(ProcessId, TRUE);
		if (pProcessInfo) {
			if (Create) {
				PULONG pThreadId = (PULONG)ProcmonGetLogEntryAndCopyFrameChain(
					MONITOR_TYPE_PROCESS, 
					NOTIFY_THREAD_CREATE, 
					pProcessInfo->Seq, 0,
					sizeof(ULONG), &pLogBuf);
				if (pThreadId) {
					*pThreadId = (ULONG)(ULONG_PTR)ThreadId;
					ProcmonNotifyProcessLog(pLogBuf);
				}
			}else{
				KERNEL_USER_TIMES KernelUserTimes;
				ThreadExitStatus = ProcmonQueryThreadExitInfo(ProcessId, ThreadId, &KernelUserTimes);

				PLOG_THREADEXIT_INFO pLogThreadExitInfo = (PLOG_THREADEXIT_INFO)ProcmonGetLogEntryAndCopyFrameChain(
					MONITOR_TYPE_PROCESS, NOTIFY_THREAD_EXIT, pProcessInfo->Seq, 0,
					sizeof(LOG_THREADEXIT_INFO), &pLogBuf);
				if (pLogThreadExitInfo) {
					pLogThreadExitInfo->ExitStatus = ThreadExitStatus;
					pLogThreadExitInfo->KenrnelTime = KernelUserTimes.KernelTime;
					pLogThreadExitInfo->UserTime = KernelUserTimes.UserTime;

					ProcmonNotifyProcessLog(pLogBuf);
				}
			}
			DerefProcessInfo(pProcessInfo);
		}
	}
}

NTSTATUS
ProcmonQueryProcessExitInfo(
	_In_ BOOLEAN bRefProcess,
	_In_ PPROCESSINFO_LIST ProcessInfo,
	_Out_ PKERNEL_USER_TIMES pUserTime,
	_Out_ PVM_COUNTERS pVmCounters
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	NTSTATUS ExitStatus = STATUS_SUCCESS;
	CLIENT_ID ClientId;
	OBJECT_ATTRIBUTES ObjectAttributes;
	PROCESS_BASIC_INFORMATION ProcessBasicInfo;
	HANDLE hProcess;

	RtlZeroMemory(pUserTime, sizeof(*pUserTime));
	RtlZeroMemory(pVmCounters, sizeof(*pVmCounters));

	ClientId.UniqueProcess = ProcessInfo->ProcessId;
	ClientId.UniqueThread = NULL;
	InitializeObjectAttributes(&ObjectAttributes, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);

	if (!NT_SUCCESS(ZwOpenProcess(&hProcess, 0, &ObjectAttributes, &ClientId)) || !hProcess)
		return STATUS_SUCCESS;

	if (!hProcess){
		return STATUS_SUCCESS;
	}

	if (NT_SUCCESS(ZwQueryInformationProcess(hProcess, ProcessBasicInformation, &ProcessBasicInfo,
		sizeof(PROCESS_BASIC_INFORMATION), NULL)))
		ExitStatus = ProcessBasicInfo.ExitStatus;
	ZwQueryInformationProcess(hProcess, ProcessTimes, pUserTime, sizeof(KERNEL_USER_TIMES), NULL);
	ZwQueryInformationProcess(hProcess, ProcessVmCounters, pVmCounters, sizeof(VM_COUNTERS), NULL);
	if (bRefProcess)
		ObReferenceObjectByHandle(hProcess, 0, NULL, 0, &ProcessInfo->Process, NULL);
	ZwClose(hProcess);
	return ExitStatus;
}


VOID
ProcmonAddProcessToWaitExitList(
	_In_  PPROCESSINFO_LIST pProcessInfo
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	PWORK_QUEUE_ITEM pWorkItem;

	ExAcquireFastMutex(&gProcessListMutex);
	InsertHeadList(&gProcessWaitExitList, &pProcessInfo->ProcessExitList);
	ExReleaseFastMutex(&gProcessListMutex);
	pWorkItem = ProcmonAllocatePoolWithTag(NonPagedPool, sizeof(WORK_QUEUE_ITEM), 'M');
	if (pWorkItem) {
		pWorkItem->Parameter = pWorkItem;
		pWorkItem->WorkerRoutine = ProcmonWaitProcessExitWorkRoutine;
		pWorkItem->List.Flink = NULL;
		ExQueueWorkItem(pWorkItem, DelayedWorkQueue);
	}
}

VOID
CreateProcessNotifyRoutineCommon(
	_In_ HANDLE ParentId,
	_In_ HANDLE ProcessId,
	_In_ BOOLEAN bCreate,
	_In_ PPS_CREATE_NOTIFY_INFO CreateInfo
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	USHORT CommandLineLength;
	USHORT ImgFileNameLength;
	PPROCESSINFO_LIST pParentProcessInfo;
	PPROCESSINFO_LIST pProcessInfo;
	PPROCESS_FULL_INFO pNewFullInfo;
	PWCHAR pCommandBuffer;
	PPROCESSINFO_LIST pProcessInfoTmp;
	NTSTATUS ExitStatus;

	CommandLineLength = 0;
	ImgFileNameLength = 0;
	if (bCreate) {
		pParentProcessInfo = RefProcessInfo(ParentId, TRUE);
		pProcessInfo = RefProcessInfo(ProcessId, FALSE);
		if (pProcessInfo) {
			if (CreateInfo) {
				ImgFileNameLength = CreateInfo->ImageFileName ? CreateInfo->ImageFileName->Length : 0;
				CommandLineLength = CreateInfo->CommandLine ? CreateInfo->CommandLine->Length : 0;
			}
			pNewFullInfo = ProcmonAllocatePoolWithTag(NonPagedPool, CommandLineLength + ImgFileNameLength + sizeof(PROCESS_FULL_INFO), '8');
			if (pNewFullInfo) {
				USHORT StackFrameCounts;

				pNewFullInfo->pParentProcessInfo = pParentProcessInfo;
				StackFrameCounts = (USHORT)ProcmonGenStackFrameChain(TRUE, pNewFullInfo->StackFrame, MAX_STACKFRAME_COUNTS);
				pNewFullInfo->ImageFileName.Buffer = (PWCH)&pNewFullInfo[1];
				pNewFullInfo->ImageFileName.MaximumLength = ImgFileNameLength;
				pNewFullInfo->ImageFileName.Length = ImgFileNameLength;
				pNewFullInfo->StackFrameCounts = StackFrameCounts;
				if (ImgFileNameLength)
					RtlCopyMemory(&pNewFullInfo[1], CreateInfo->ImageFileName->Buffer, ImgFileNameLength);
				pNewFullInfo->CommandLine.MaximumLength = CommandLineLength;
				pNewFullInfo->CommandLine.Length = CommandLineLength;
				pCommandBuffer = (PWCHAR)((ULONG_PTR)pNewFullInfo->ImageFileName.Buffer + ImgFileNameLength);
				pNewFullInfo->CommandLine.Buffer = pCommandBuffer;
				if (CommandLineLength)
					RtlCopyMemory(pCommandBuffer, CreateInfo->CommandLine->Buffer, CommandLineLength);
				pProcessInfo->pProcessFullInfo = pNewFullInfo;
			}
			pProcessInfoTmp = pProcessInfo;
		}else{
			pProcessInfoTmp = pParentProcessInfo;
		}
		DerefProcessInfo(pProcessInfoTmp);
	}else {
		pProcessInfo = RefProcessInfo(ProcessId, TRUE);
		if (pProcessInfo) {
			KERNEL_USER_TIMES KernelUserTime;
			VM_COUNTERS VmCounters;
			PLOG_PROCESSBASIC_INFO pLogProcessBasicInfo;
			PLOG_BUFFER pLogBuf;

			ExitStatus = ProcmonQueryProcessExitInfo(TRUE, pProcessInfo, &KernelUserTime, &VmCounters);
			pLogProcessBasicInfo = ProcmonGetLogEntryAndCopyFrameChain(MONITOR_TYPE_PROCESS, NOTIFY_PROCESS_EXIT,
				pProcessInfo->Seq, 0, sizeof(LOG_PROCESSBASIC_INFO), &pLogBuf);
			if (pLogProcessBasicInfo){
				pLogProcessBasicInfo->ExitStatus = ExitStatus;
				pLogProcessBasicInfo->KenrnelTime.QuadPart = KernelUserTime.KernelTime.QuadPart;
				pLogProcessBasicInfo->UserTime.QuadPart = KernelUserTime.UserTime.QuadPart;
				pLogProcessBasicInfo->PagefileUsage = VmCounters.PagefileUsage;
				pLogProcessBasicInfo->PeakPagefileUsage = VmCounters.PeakPagefileUsage;
				pLogProcessBasicInfo->WorkingSetSize = VmCounters.WorkingSetSize;
				pLogProcessBasicInfo->PeakWorkingSetSize = VmCounters.PeakWorkingSetSize;
				ProcmonNotifyProcessLog(pLogBuf);
			}
			DerefProcessInfo(pProcessInfo);
			if (pProcessInfo->Process)
				ProcmonAddProcessToWaitExitList(pProcessInfo);
		}
	}
}

VOID
CreateProcessNotifyRoutineEx2(
	_In_ HANDLE Process,
	_In_ HANDLE ProcessId,
	_In_ PPS_CREATE_NOTIFY_INFO CreateInfo
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	UNREFERENCED_PARAMETER(Process);

	if (CreateInfo)
		CreateProcessNotifyRoutineCommon(CreateInfo->ParentProcessId, ProcessId, TRUE, CreateInfo);
	else
		CreateProcessNotifyRoutineCommon(NULL, ProcessId, FALSE, NULL);
}

VOID
CreateProcessNotifyRoutine(
	_In_ HANDLE ParentId,
	_In_ HANDLE ProcessId,
	_In_ BOOLEAN Create
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	CreateProcessNotifyRoutineCommon(ParentId, ProcessId, Create, NULL);
}

VOID
ProcmonProcessProfilingNotify(
	_In_ PSYSTEM_PROCESS_INFORMATION pSystemProcessInfo
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	PPROCESSINFO_LIST pProcessInfo = RefProcessInfo(pSystemProcessInfo->UniqueProcessId, 1);
	if (pProcessInfo && !pProcessInfo->pProcessFullInfo)
	{
		PLOG_BUFFER pLogBuf;
		PLOG_PROCESS_PROFILING_INFO pProcessProfInfo = (PLOG_PROCESS_PROFILING_INFO)ProcmonGetLogEntryAndInit(
			MONITOR_TYPE_PROFILING, NOTIFY_PROCESS_PROFILING,
			pProcessInfo->Seq, 0, 0x20, &pLogBuf, 0, NULL);
		if (pProcessProfInfo)
		{
			pProcessProfInfo->UserTime = pSystemProcessInfo->UserTime;
			pProcessProfInfo->KernelTime = pSystemProcessInfo->KernelTime;
			pProcessProfInfo->WorkingSetSize = pSystemProcessInfo->WorkingSetSize;
			pProcessProfInfo->PagefileUsage = pSystemProcessInfo->PagefileUsage;
			ProcmonNotifyProcessLog(pLogBuf);
		}
		DerefProcessInfo(pProcessInfo);
	}
}

PTHREAD_PROFILING_INFO
ProcmonGetThreadInfoFromList(
	_In_ PCLIENT_ID pClientId
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	UCHAR Index = (UCHAR)((ULONG)(ULONG_PTR)pClientId->UniqueThread >> 4);
	PLIST_ENTRY pListHead = &gListEntryArray[Index];
	PTHREAD_PROFILING_INFO pThreadProfInfoNew;

	if (!IsListEmpty(pListHead)) {

		PLIST_ENTRY pEntry;
		for (pEntry = pListHead->Flink;
			pEntry != pListHead;
			pEntry = pEntry->Flink)
		{
			PTHREAD_PROFILING_INFO pThreadProfInfo = CONTAINING_RECORD(pEntry, THREAD_PROFILING_INFO, List);
			if (pThreadProfInfo->ClientId.UniqueThread == pClientId->UniqueThread) {
				return pThreadProfInfo;
			}
		}
	}

	//
	// Here listhead is empty or can not find the threadid in list
	// we need allocate a new one
	//

	pThreadProfInfoNew = (PTHREAD_PROFILING_INFO)ProcmonAllocatePoolWithTag(PagedPool,
		sizeof(THREAD_PROFILING_INFO), 'N');
	RtlZeroMemory(pThreadProfInfoNew, sizeof(THREAD_PROFILING_INFO));
	pThreadProfInfoNew->ClientId = *pClientId;
	InitializeListHead(&pThreadProfInfoNew->List);
	InsertHeadList(pListHead, &pThreadProfInfoNew->List);
	return pThreadProfInfoNew;
}


VOID
ProcmonThreadProfileUpdateRoutine(
	IN struct _KAPC *Apc,
	IN OUT PKNORMAL_ROUTINE *NormalRoutine,
	IN OUT PVOID *NormalContext,
	IN OUT PVOID *SystemArgument1,
	IN OUT PVOID *SystemArgument2
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	PPROCESSINFO_LIST pProcessInfo;
	PTHREAD_PROFILING_UPDATE_APC pThreadProfUpdateApc = (PTHREAD_PROFILING_UPDATE_APC)Apc;

	UNREFERENCED_PARAMETER(NormalContext);
	UNREFERENCED_PARAMETER(SystemArgument1);
	UNREFERENCED_PARAMETER(SystemArgument2);


	pProcessInfo = RefProcessInfo(pThreadProfUpdateApc->ProcessId, TRUE);
	if (pProcessInfo) {
		PLOG_BUFFER pLogBuf;
		PLOG_THREAD_PROFILING_INFO pLogInfo = ProcmonGetLogEntryAndCopyFrameChain(MONITOR_TYPE_PROFILING, 
			NOTIFY_THREAD_PROFILING,
			pProcessInfo->Seq, 0, 12, &pLogBuf);
		if (pLogInfo) {
			pLogInfo->UserTimeChange = pThreadProfUpdateApc->UserTimeChange;
			pLogInfo->KernelTimeChange = pThreadProfUpdateApc->KernelTimeChange;
			pLogInfo->ContextSwitchesChange = pThreadProfUpdateApc->ContextSwitchesChange;
			ProcmonNotifyProcessLog(pLogBuf);
		}
		DerefProcessInfo(pProcessInfo);
	}

	ExFreeToNPagedLookasideList(&gLookasideListThreadProfiling, pThreadProfUpdateApc);
	*NormalRoutine = NULL;
}

VOID
ProcmonAddToThreadProfileUpdateList(
	_In_ PCLIENT_ID pClientId,
	_In_ ULONG KernelTimeChange,
	_In_ ULONG UserTimeChange,
	_In_ ULONG ContextSwitchesChange
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	NTSTATUS Status;
	PETHREAD Thread;
	PTHREAD_PROFILING_UPDATE_APC pThreadProfilingUpdateApc;

	Status = PsLookupThreadByThreadId(pClientId->UniqueThread, &Thread);
	if (!NT_SUCCESS(Status)) {
		return;
	}

	pThreadProfilingUpdateApc = ExAllocateFromNPagedLookasideList(&gLookasideListThreadProfiling);
	if (pThreadProfilingUpdateApc) {
		pThreadProfilingUpdateApc->ContextSwitchesChange = ContextSwitchesChange;
		pThreadProfilingUpdateApc->KernelTimeChange = KernelTimeChange;
		pThreadProfilingUpdateApc->ProcessId = pClientId->UniqueProcess;
		pThreadProfilingUpdateApc->UserTimeChange = UserTimeChange;

		KeInitializeApc(&pThreadProfilingUpdateApc->Apc, Thread, OriginalApcEnvironment,
			ProcmonThreadProfileUpdateRoutine, NULL,
			(PKNORMAL_ROUTINE)ProcmonThreadProfileUpdateRoutine, KernelMode, NULL);
		if (!KeInsertQueueApc(&pThreadProfilingUpdateApc->Apc, NULL, NULL, 0)) {
			ExFreeToNPagedLookasideList(&gLookasideListThreadProfiling, pThreadProfilingUpdateApc);
		}
	}

	ObDereferenceObject(Thread);
}

PTHREAD_PROFILING_INFO
ProcmonThreadProfileNotify(
	_In_ PSYSTEM_THREAD_INFORMATION pThreadInfo
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	PTHREAD_PROFILING_INFO pThreadProfilingInfo;
	ULONG ContextSwitchesChange;
	ULONG UserTimeChange;
	ULONG KernelTimeChange;
	CLIENT_ID pClientId;

	pThreadProfilingInfo = ProcmonGetThreadInfoFromList(&pThreadInfo->ClientId);
	if (pThreadProfilingInfo) {
		if (pThreadProfilingInfo->ClientId.UniqueProcess == pThreadInfo->ClientId.UniqueProcess) {
			if ((pThreadProfilingInfo->KernelTime.QuadPart != pThreadInfo->KernelTime.QuadPart
				|| pThreadProfilingInfo->UserTime.QuadPart != pThreadInfo->UserTime.QuadPart
				|| pThreadProfilingInfo->ContextSwitches != pThreadInfo->ContextSwitches)
				&& (pThreadProfilingInfo->KernelTime.QuadPart ||
					pThreadProfilingInfo->UserTime.QuadPart ||
					pThreadProfilingInfo->ContextSwitches))
			{
				ContextSwitchesChange = pThreadInfo->ContextSwitches - pThreadProfilingInfo->ContextSwitches;
				UserTimeChange = pThreadInfo->UserTime.LowPart - pThreadProfilingInfo->UserTime.LowPart;
				KernelTimeChange = pThreadInfo->KernelTime.LowPart - pThreadProfilingInfo->KernelTime.LowPart;
				pClientId = pThreadInfo->ClientId;
				ProcmonAddToThreadProfileUpdateList(&pClientId, KernelTimeChange, UserTimeChange, ContextSwitchesChange);
			}
		}
		pThreadProfilingInfo->ClientId.UniqueProcess = pThreadInfo->ClientId.UniqueProcess;
		pThreadProfilingInfo->KernelTime.QuadPart = pThreadInfo->KernelTime.QuadPart;
		pThreadProfilingInfo->UserTime.QuadPart = pThreadInfo->UserTime.QuadPart;
		pThreadProfilingInfo->ContextSwitches = pThreadInfo->ContextSwitches;
	}
	return pThreadProfilingInfo;
}

VOID
ProcmonProcessThreadProfilingNotify(
	_In_ BOOLEAN bEnableThreadProfileNotify
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	BOOLEAN bThreadProfileNotify;
	BOOLEAN bSystemProcessProfileNotify;
	LARGE_INTEGER Timeout;
	NTSTATUS Status;
	PVOID pBuffer = NULL;
	ULONG NeedLength = 0x10000;
	PSYSTEM_PROCESS_INFORMATION pSystemProcessInfo;

	bThreadProfileNotify = bEnableThreadProfileNotify;
	bSystemProcessProfileNotify = !bEnableThreadProfileNotify;
	Timeout.QuadPart = 0;

	if (bEnableThreadProfileNotify) {
		if (KeWaitForSingleObject(&gTimerProcessProfiling, 0, 0, 0, &Timeout) != STATUS_TIMEOUT) {
			bSystemProcessProfileNotify = TRUE;
		}
	}
	else {
		if (KeWaitForSingleObject(&gTimerThreadProfiling, 0, 0, 0, &Timeout) != STATUS_TIMEOUT) {
			bThreadProfileNotify = TRUE;
		}

	}

	//
	// Allocate the buffer
	//

	do
	{
		if (pBuffer) {
			ExFreePoolWithTag(pBuffer, 0);
		}

		pBuffer = ProcmonAllocatePoolWithTag(PagedPool, NeedLength, '5');
		if (!pBuffer) {
			break;
		}

		//
		// try to query 
		//

		Status = ZwQuerySystemInformation(SystemProcessInformation, pBuffer, NeedLength, &NeedLength);
		if (NT_SUCCESS(Status)) {
			break;
		}

	} while (TRUE);

	if (!pBuffer) {
		return;
	}

	pSystemProcessInfo = (PSYSTEM_PROCESS_INFORMATION)pBuffer;
	do
	{

		if (bSystemProcessProfileNotify) {
			ProcmonProcessProfilingNotify(pSystemProcessInfo);
		}

		if (bThreadProfileNotify) {
			if (pSystemProcessInfo->UniqueProcessId &&
				pSystemProcessInfo->UniqueProcessId != gProcessId) {

				PSYSTEM_THREAD_INFORMATION pThreadInfo = (PSYSTEM_THREAD_INFORMATION)(pSystemProcessInfo + 1);
				for (int i = 0; i < (int)pSystemProcessInfo->NumberOfThreads; i++)
				{
					ProcmonThreadProfileNotify(&pThreadInfo[i]);
				}
			}
		}

		if (!pSystemProcessInfo->NextEntryOffset) {
			break;
		}
		pSystemProcessInfo = (PSYSTEM_PROCESS_INFORMATION)((ULONG_PTR)pSystemProcessInfo + pSystemProcessInfo->NextEntryOffset);
	} while (TRUE);

	ExFreePoolWithTag(pBuffer, 0);
}


VOID
ProcmonGetImageRealNameRoutine(
	_Inout_ PVOID Parameter
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	PGETFULLNAME_WORKITEM pWorkItem = (PGETFULLNAME_WORKITEM)Parameter;
	PUNICODE_STRING pUniStrFullName = pWorkItem->pUniStrFullName;
	PUNICODE_STRING pUniStrImageName = pWorkItem->pUniStrImageName;

	if (ProcmonIsFileInSystemRoot(pUniStrImageName) ||
		ProcmonIsFileExist(pUniStrImageName) ||
		((ProcmonAppendVolumeName(pUniStrImageName, pUniStrFullName), !pUniStrFullName->Buffer) &&
		(ProcmonEnumAllVolumes(), ProcmonAppendVolumeName(pUniStrImageName, pUniStrFullName), !pUniStrFullName->Buffer)))
	{
		pUniStrFullName->Buffer = (PWCH)ProcmonAllocatePoolWithTag(0, pUniStrImageName->Length, 'b');
		if (pUniStrFullName->Buffer) {
			pUniStrFullName->MaximumLength = pUniStrImageName->Length;
			RtlCopyUnicodeString(pUniStrFullName, pUniStrImageName);
		}
	}
	KeSetEvent(&pWorkItem->NotifyEvent, 0, 0);
}

VOID
ProcmonGetImageRealName(
	_In_ PUNICODE_STRING pUniImageName,
	_Out_ PUNICODE_STRING pUniStrFullName
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	WCHAR *pNewBuf;
	UNICODE_STRING UniImageNameCopy;
	GETFULLNAME_WORKITEM WorkItem;

	pUniStrFullName->Buffer = NULL;
	UniImageNameCopy.Length = pUniImageName->Length;
	pNewBuf = ProcmonAllocatePoolWithTag(0, UniImageNameCopy.Length, 'b');
	UniImageNameCopy.Buffer = pNewBuf;
	if (pNewBuf) {
		RtlCopyMemory(pNewBuf, pUniImageName->Buffer, UniImageNameCopy.Length);
		WorkItem.pUniStrImageName = &UniImageNameCopy;
		WorkItem.pUniStrFullName = pUniStrFullName;
		KeInitializeEvent(&WorkItem.NotifyEvent, 0, 0);
		WorkItem.WorkItem.WorkerRoutine = ProcmonGetImageRealNameRoutine;
		WorkItem.WorkItem.List.Flink = NULL;
		WorkItem.WorkItem.Parameter = &WorkItem;
		if (PsGetCurrentProcessId() == gSystemProcessId)
			ProcmonGetImageRealNameRoutine(&WorkItem);
		else
			ExQueueWorkItem(&WorkItem.WorkItem, DelayedWorkQueue);
		KeWaitForSingleObject(&WorkItem.NotifyEvent, 0, 0, 0, NULL);
		ExFreePoolWithTag(UniImageNameCopy.Buffer, 0);
	}
}

VOID
ProcmonNotifyImageLoad(
	_In_ PUNICODE_STRING pUniStrImageName,
	_In_ LONG Seq,
	_In_ PVOID ImageBase,
	_In_ ULONG ImageSize,
	_In_ USHORT nFrameChainDepth,
	_In_ PVOID pStackFrame
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	PLOG_BUFFER pLogBuf;

	PLOG_LOADIMAGE_INFO pLogImgInfo = (PLOG_LOADIMAGE_INFO)ProcmonGetLogEntryAndInit(
		MONITOR_TYPE_PROCESS,
		NOTIFY_IMAGE_LOAD,
		Seq,
		0,
		pUniStrImageName->Length + sizeof(LOG_LOADIMAGE_INFO),
		&pLogBuf,
		nFrameChainDepth,
		pStackFrame);
	if (pLogImgInfo) {
		pLogImgInfo->ImageBase = ImageBase;
		pLogImgInfo->ImageSize = ImageSize;
		pLogImgInfo->ImageNameLength = pUniStrImageName->Length >> 1;
		RtlCopyMemory((PVOID)(pLogImgInfo + 1), pUniStrImageName->Buffer, pUniStrImageName->Length);
		ProcmonNotifyProcessLog(pLogBuf);
	}
}

#pragma pack(1)
typedef struct _USER_GETIMAGENAME_MESSAGE
{
	ULONG ProcessId;
	PVOID ImageBase;
}USER_GETIMAGENAME_MESSAGE, *PUSER_GETIMAGENAME_MESSAGE;
#pragma pack()

NTSTATUS
CommunicateWithUserClient(
	_In_ PVOID SenderBuffer,
	_In_ ULONG SenderBufferLength,
	_Out_ PVOID ReplyBuffer,
	_Inout_ PULONG ReplyLength
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	LARGE_INTEGER Timeout;

	Timeout.QuadPart = -10000000;
	return FltSendMessage(
		gFilterHandle,
		&gClientProcessPathPort,
		SenderBuffer,
		SenderBufferLength,
		ReplyBuffer,
		ReplyLength,
		&Timeout);
}

VOID
ProcmonNotifyImageLoadApcRoutine(
	IN PVOID NormalContext,
	IN PVOID SystemArgument1,
	IN PVOID SystemArgument2
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	NTSTATUS Status;
	PPROCESSINFO_LIST pProcessInfo;
	PLOADIMAGE_INFO pLoadImageInfo = (PLOADIMAGE_INFO)SystemArgument1;
	HANDLE ProcessId = (HANDLE)SystemArgument2;

	UNREFERENCED_PARAMETER(NormalContext);

	pProcessInfo = RefProcessInfo(ProcessId, 1);
	if (pProcessInfo)
	{
		PFLT_FILE_NAME_INFORMATION pFileNameInfo = pLoadImageInfo->pFileNameInfo;
		if (pFileNameInfo) {
			ProcmonNotifyImageLoad(
				&pFileNameInfo->Name,
				pProcessInfo->Seq,
				pLoadImageInfo->ImageInfo.ImageBase,
				(ULONG)pLoadImageInfo->ImageInfo.ImageSize,
				pLoadImageInfo->StackFrameCounts,
				pLoadImageInfo->StackFrameChain);
			FltReleaseFileNameInformation(pLoadImageInfo->pFileNameInfo);
		}
		else {
			PUNICODE_STRING pImageFileName = (PUNICODE_STRING)ProcmonAllocatePoolWithTag(NonPagedPool, 0x8010, '9');
			if (pImageFileName) {
				USER_GETIMAGENAME_MESSAGE Message;
				ULONG ReplayBufferLen = 0x8010;
				Message.ProcessId = (ULONG)(ULONG_PTR)ProcessId;
				Message.ImageBase = pLoadImageInfo->ImageInfo.ImageBase;
				pImageFileName->Length = 0;
				Status = CommunicateWithUserClient(&Message, sizeof(USER_GETIMAGENAME_MESSAGE),
					pImageFileName, &ReplayBufferLen);
				if (NT_SUCCESS(Status) && pImageFileName->Length)
				{
					pImageFileName->Buffer = (PWCH)(pImageFileName + 1);
					ProcmonNotifyImageLoad(
						pImageFileName,
						pProcessInfo->Seq,
						pLoadImageInfo->ImageInfo.ImageBase,
						(ULONG)pLoadImageInfo->ImageInfo.ImageSize,
						pLoadImageInfo->StackFrameCounts,
						pLoadImageInfo->StackFrameChain);
				}
				ExFreePoolWithTag(pImageFileName, 0);
			}
		}
		DerefProcessInfo(pProcessInfo);
	}
	ExFreePoolWithTag(pLoadImageInfo, 0);
}

VOID
ProcmonQueueApcSpecialApc(
	IN PKAPC Apc,
	IN PKNORMAL_ROUTINE *NormalRoutine,
	IN PVOID *NormalContext,
	IN PVOID *SystemArgument1,
	IN PVOID *SystemArgument2
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	PAGED_CODE();

	UNREFERENCED_PARAMETER(NormalRoutine);
	UNREFERENCED_PARAMETER(NormalContext);
	UNREFERENCED_PARAMETER(SystemArgument1);
	UNREFERENCED_PARAMETER(SystemArgument2);

	ExFreePool(Apc);
}


VOID
LoadImageNotifyRoutine(
	_In_ PUNICODE_STRING FullImageName,
	_In_ HANDLE ProcessId,
	_In_ PIMAGE_INFO pImageInfo
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	UNICODE_STRING UniStrImageName = {0};
	PEPROCESS Process;
	PPROCESSINFO_LIST pProcessInfo;

	if (!FullImageName) {
		return;
	}

	Process = IoGetCurrentProcess();
	if (Process == gCurrentProcess || !(gFlags & 1)) {
		return;
	}

	if (!FullImageName->Length) {
		FullImageName->Length = FullImageName->MaximumLength;
	}

	if (pImageInfo->SystemModeImage) {
		if (gCurrentProcess) {
			UniStrImageName.MaximumLength = FullImageName->Length;
			UniStrImageName.Buffer = ProcmonAllocatePoolWithTag(0, FullImageName->Length, 'C');;
			if (!UniStrImageName.Buffer)
				return;
			RtlCopyUnicodeString(&UniStrImageName, FullImageName);
		}
	}else{
		if (gCurrentProcess) {
			PKAPC Apc = (PKAPC)ProcmonAllocatePoolWithTag(NonPagedPool, sizeof(KAPC), 'A');
			if (Apc) {
				PLOADIMAGE_INFO pLoadImageInfo = (PLOADIMAGE_INFO)ProcmonAllocatePoolWithTag(0, sizeof(LOADIMAGE_INFO), 'B');
				if (pLoadImageInfo) {
					pLoadImageInfo->pFileNameInfo = NULL;

					if (pImageInfo->ExtendedInfoPresent) {
						GETFILENAME_WORKITEM WorkItem;
						PIMAGE_INFO_EX pImageInfoEx = CONTAINING_RECORD(pImageInfo, IMAGE_INFO_EX, ImageInfo);

						KeInitializeEvent(&WorkItem.NotifyEvent, 0, 0);
						WorkItem.FileObject = pImageInfoEx->FileObject;
						WorkItem.WorkItem.WorkerRoutine = ProcmonGetFileNameInfoWorkRoutine;
						WorkItem.WorkItem.List.Flink = NULL;
						WorkItem.WorkItem.Parameter = &WorkItem;
						ExQueueWorkItem(&WorkItem.WorkItem, DelayedWorkQueue);
						KeWaitForSingleObject(&WorkItem.NotifyEvent, 0, 0, 0, NULL);
						if (NT_SUCCESS(WorkItem.Status)) {
							pLoadImageInfo->pFileNameInfo = WorkItem.pFileNameInfo;
						}
					}

					pLoadImageInfo->ImageInfo = *pImageInfo;
					pLoadImageInfo->StackFrameCounts = (USHORT)ProcmonGenStackFrameChain(TRUE, 
						pLoadImageInfo->StackFrameChain, MAX_STACKFRAME_COUNTS);
					KeInitializeApc(Apc, KeGetCurrentThread(), OriginalApcEnvironment, ProcmonQueueApcSpecialApc, NULL,
						ProcmonNotifyImageLoadApcRoutine, 0, NULL);
					KeInsertQueueApc(Apc, pLoadImageInfo, ProcessId, 0);
				}
			}
			return;
		}

		ProcmonGetImageRealName(FullImageName, &UniStrImageName);
	}

	if (UniStrImageName.Buffer) {
		if (pImageInfo->Properties & 0x100)
			ProcessId = gSystemProcessId;
		else
			ProcessId = PsGetCurrentProcessId();

		pProcessInfo = RefProcessInfo(ProcessId, TRUE);
		if (pProcessInfo) {

			PLOG_BUFFER pLogBuf;
			PLOG_LOADIMAGE_INFO pLogImgInfo = (PLOG_LOADIMAGE_INFO)ProcmonGetLogEntryAndCopyFrameChain(
				MONITOR_TYPE_PROCESS,
				NOTIFY_IMAGE_LOAD,
				pProcessInfo->Seq,
				0,
				UniStrImageName.Length + sizeof(LOG_LOADIMAGE_INFO),
				&pLogBuf);
			if (pLogImgInfo) {
				pLogImgInfo->ImageBase = pImageInfo->ImageBase;
				pLogImgInfo->ImageSize = (ULONG)pImageInfo->ImageSize;
				pLogImgInfo->ImageNameLength = UniStrImageName.Length >> 1;
				RtlCopyMemory(pLogImgInfo + 1, UniStrImageName.Buffer, UniStrImageName.Length);
				ProcmonNotifyProcessLog(pLogBuf);
			}
		}

		ExFreePoolWithTag(UniStrImageName.Buffer, 0);
	}

}


VOID
ThreadSystemModuleMonitor(
	_In_ PVOID StartContext
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	NTSTATUS Status;
	PVOID Objects[4];
	KWAIT_BLOCK WaitBlockArray[4];
	LARGE_INTEGER DueTime = { 0 };

	UNREFERENCED_PARAMETER(StartContext);

	KeSetTimerEx(&gTimerProcessProfiling, DueTime, 1000, NULL);

	Objects[ProfilingExitEvent] = &gModuleMonitorExitEvent;
	Objects[ProfilingProcess] = &gTimerProcessProfiling;
	Objects[ProfilingThread] = &gTimerThreadProfiling;
	Objects[ProfilingReset] = &gEventProfilingReset;

	while (TRUE)
	{
		Status = KeWaitForMultipleObjects(4, Objects, WaitAny, 0, KernelMode, FALSE, NULL, WaitBlockArray);
		if (Status == ProfilingExitEvent) {
			break;
		}
		else if (Status == ProfilingProcess) {
			ProcmonProcessThreadProfilingNotify(1);
		}
		else if (Status == ProfilingThread) {
			ProcmonProcessThreadProfilingNotify(0);
		}
		else if (Status == ProfilingReset) {
			for (int i = 0; i < 0x100; i++)
			{
				PLIST_ENTRY pListHead = &gListEntryArray[i];
				while (pListHead->Flink != pListHead)
				{
					PLIST_ENTRY pEntry = RemoveHeadList(pListHead);
					PTHREAD_PROFILING_INFO pThreadProfilingInfo = CONTAINING_RECORD(pEntry, THREAD_PROFILING_INFO, List);
					ExFreePoolWithTag(pThreadProfilingInfo, 0);
				}
			}
		}
	}


	//
	// Reset All
	//

	for (int i = 0; i < 0x100; i++)
	{
		PLIST_ENTRY pListHead = &gListEntryArray[i];
		while (pListHead->Flink != pListHead)
		{
			PLIST_ENTRY pEntry = RemoveHeadList(pListHead);
			PTHREAD_PROFILING_INFO pThreadProfilingInfo = CONTAINING_RECORD(pEntry, THREAD_PROFILING_INFO, List);
			ExFreePoolWithTag(pThreadProfilingInfo, 0);
		}
	}

}

NTSTATUS
EnableProcessMonitor(
	_In_ BOOLEAN bEnable
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	NTSTATUS Status = STATUS_SUCCESS;

	if (bEnable != gThreadMonitorEnable) {
		if (bEnable) {
			if (!fnPsSetCreateThreadNotifyRoutineEx ||
				(Status = fnPsSetCreateThreadNotifyRoutineEx(PsCreateThreadNotifySubsystems, 
				(PVOID)CreateThreadNotifyRoutine), 
					!NT_SUCCESS(Status))) {
				Status = PsSetCreateThreadNotifyRoutine(CreateThreadNotifyRoutine);
				gThreadMonitorEnable = bEnable;
			}
		}else{
			Status = PsRemoveCreateThreadNotifyRoutine(CreateThreadNotifyRoutine);
			gThreadMonitorEnable = bEnable;
		}
	}

	if (bEnable != gProcessMonitorEnable) {
		if (fnPsSetCreateProcessNotifyRoutineEx2) {
			Status = fnPsSetCreateProcessNotifyRoutineEx2(PsCreateProcessNotifySubsystems, 
				(PVOID)CreateProcessNotifyRoutineEx2, bEnable == 0);
		}else{
			Status = PsSetCreateProcessNotifyRoutine(CreateProcessNotifyRoutine, bEnable == 0);
		}
		gProcessMonitorEnable = bEnable;
	}

#if 0
	if (bEnable != gSystemModuleLoadMonitorEnable) {
		if (bEnable){
			OBJECT_ATTRIBUTES ObjectAttributes;
			InitializeObjectAttributes(&ObjectAttributes, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);
			PsCreateSystemThread(&ghThreadModuleMonitor, 0x1F03FFu, &ObjectAttributes, NULL, NULL, 
				ThreadSystemModuleMonitor, NULL);
		}else{
			KeSetEvent(&gModuleMonitorExitEvent, 0, 0);
			ZwWaitForSingleObject(ghThreadModuleMonitor, FALSE, NULL);
			ZwClose(ghThreadModuleMonitor);
		}
		gSystemModuleLoadMonitorEnable = bEnable;
	}
#endif

	if (bEnable) {
		if (!gCurrentProcess) {
			PPROCESSINFO_LIST pProcessInfo = RefProcessInfo(gSystemProcessId, FALSE);
			if (pProcessInfo) {
				PPROCESS_FULL_INFO pProcessFullInfo = ProcmonAllocatePoolWithTag(NonPagedPool, sizeof(PROCESS_FULL_INFO), '8');
				pProcessInfo->pProcessFullInfo = pProcessFullInfo;
				if (pProcessFullInfo){
					pProcessFullInfo->pParentProcessInfo = NULL;
					pProcessInfo->pProcessFullInfo->StackFrameCounts = 0;
					pProcessInfo->pProcessFullInfo->ImageFileName.MaximumLength = 0;
					pProcessInfo->pProcessFullInfo->ImageFileName.Length = 0;
					pProcessInfo->pProcessFullInfo->CommandLine.MaximumLength = 0;
					pProcessInfo->pProcessFullInfo->CommandLine.Length = 0;
				}
				DerefProcessInfo(pProcessInfo);
			}
		}
		PPROCESSINFO_LIST pProcessInfo2 = RefProcessInfo(gSystemProcessId, TRUE);
		DerefProcessInfo(pProcessInfo2);
	}

	if (bEnable != gLoadImageMointorEnable){
		if (bEnable) {
			Status = PsSetLoadImageNotifyRoutine(LoadImageNotifyRoutine);
		}else{
			Status = PsRemoveLoadImageNotifyRoutine(LoadImageNotifyRoutine);
		}
		gLoadImageMointorEnable = bEnable;
	}

	if (!bEnable && !gCurrentProcess)
		FreeAllProcessInfo();
	return Status;
}


VOID
ProcmonCollectProcessAndSystemPerformanceData(
	VOID
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	NTSTATUS Status;
	NTSTATUS ExitStatus = STATUS_SUCCESS;
	PLIST_ENTRY pEntry;
	HANDLE ProcessId;
	PPROCESSINFO_LIST pProcessInfo;
	PLOG_BUFFER pLogBuf;

	ExAcquireFastMutex(&gProcessListMutex);

	for (pEntry = gProcessInfoList.Flink;
		pEntry != &gProcessInfoList;
		pEntry = pEntry->Flink)
	{
		pProcessInfo = CONTAINING_RECORD(pEntry, PROCESSINFO_LIST, List);
		if (pProcessInfo->ProcessId) {
			KERNEL_USER_TIMES KernelUserTime = { 0 };
			VM_COUNTERS VmCounters = { 0 };
			PROCESS_BASIC_INFORMATION ProcessBasicInfo;
			CLIENT_ID ClientId;
			OBJECT_ATTRIBUTES ObjectAttributes;
			HANDLE hProcess;

			ClientId.UniqueThread = 0;
			ClientId.UniqueProcess = pProcessInfo->ProcessId;
			InitializeObjectAttributes(&ObjectAttributes, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);
			Status = ZwOpenProcess(&hProcess, 0, &ObjectAttributes, &ClientId);
			if (NT_SUCCESS(Status) && hProcess) {
				if (NT_SUCCESS(ZwQueryInformationProcess(hProcess, ProcessBasicInformation,
					&ProcessBasicInfo, sizeof(ProcessBasicInfo), NULL))) {
					ExitStatus = ProcessBasicInfo.ExitStatus;
					ZwQueryInformationProcess(hProcess, ProcessTimes, &KernelUserTime, sizeof(KERNEL_USER_TIMES), NULL);
					ZwQueryInformationProcess(hProcess, ProcessVmCounters, &VmCounters, sizeof(VM_COUNTERS), NULL);
					ZwClose(hProcess);
				}
			}

			if (NT_SUCCESS(ExitStatus)) {
				PLOG_PROCESSBASIC_INFO pLogBaiscInfo = (PLOG_PROCESSBASIC_INFO)ProcmonGetLogEntryAndInit(
					MONITOR_TYPE_PROCESS, NOTIFY_PROCESS_PERFORMANCE, pProcessInfo->Seq, 0, sizeof(LOG_PROCESSBASIC_INFO), &pLogBuf, 0, NULL);
				if (pLogBaiscInfo) {
					pLogBaiscInfo->ExitStatus = 0;
					pLogBaiscInfo->KenrnelTime.QuadPart = KernelUserTime.KernelTime.QuadPart;
					pLogBaiscInfo->UserTime.QuadPart = KernelUserTime.UserTime.QuadPart;
					pLogBaiscInfo->PagefileUsage = VmCounters.PagefileUsage;
					pLogBaiscInfo->PeakPagefileUsage = VmCounters.PeakPagefileUsage;
					pLogBaiscInfo->WorkingSetSize = VmCounters.WorkingSetSize;
					pLogBaiscInfo->PeakWorkingSetSize = VmCounters.PeakWorkingSetSize;
					ProcmonNotifyProcessLog(pLogBuf);
				}
			}
		}
	}
	ExReleaseFastMutex(&gProcessListMutex);
	ProcessId = PsGetCurrentProcessId();
	pProcessInfo = RefProcessInfo(ProcessId, TRUE);
	if (pProcessInfo) {
		SYSTEM_PERFORMANCE_INFORMATION SystemPerfInfo;
		ULONG ReturnLength = sizeof(SystemPerfInfo);

		Status = ZwQuerySystemInformation(SystemPerformanceInformation, &SystemPerfInfo, sizeof(SystemPerfInfo), &ReturnLength);
		if (NT_SUCCESS(Status)) {
			PLOG_SYSTEMPERF_INFO pLogSysPrefInfo = (PLOG_SYSTEMPERF_INFO)ProcmonGetLogEntryAndCopyFrameChain(
				MONITOR_TYPE_PROCESS, NOTIFY_SYSTEM_PERFORMANCE, 
				pProcessInfo->Seq, 0, sizeof(LOG_SYSTEMPERF_INFO), &pLogBuf);
			if (pLogSysPrefInfo) {
				pLogSysPrefInfo->UnKnown = 0x1000;
				pLogSysPrefInfo->SystemPerfInfo = SystemPerfInfo;
				ProcmonNotifyProcessLog(pLogBuf);
			}
		}

		DerefProcessInfo(pProcessInfo);
	}
}

BOOLEAN
ProcmonEnableThreadProfiling(
	_In_ LARGE_INTEGER Period
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	LARGE_INTEGER DueTime;

	DueTime.QuadPart = 0;

	if (DueTime.HighPart)
		return KeSetTimerEx(
			&gTimerThreadProfiling,
			DueTime,
			(LONG)(Period.QuadPart / 10000),
			NULL);
	KeSetEvent(&gEventProfilingReset, 0, 0);
	return KeCancelTimer(&gTimerThreadProfiling);
}
```

`kernel/process.h`:

```h
#pragma once

#include <ntifs.h>
#include <fltKernel.h>

struct _PROCESSINFO_LIST;

typedef struct _PROCESS_FULL_INFO
{
	struct _PROCESSINFO_LIST* pParentProcessInfo;
	USHORT StackFrameCounts;
	PVOID StackFrame[MAX_STACKFRAME_COUNTS];
	UNICODE_STRING ImageFileName;
	UNICODE_STRING CommandLine;
}PROCESS_FULL_INFO, *PPROCESS_FULL_INFO;

typedef struct _PROCESSINFO_LIST
{
	/*00*/PVOID Process;
	/*08*/LONG RefCount;
	/*0C*/LONG Seq;
	/*10*/HANDLE ProcessId;
	/*18*/BOOLEAN bInit;
	/*20*/PPROCESS_FULL_INFO pProcessFullInfo;
	/*28*/LIST_ENTRY List;
	/*38*/LIST_ENTRY ProcessExitList;
}PROCESSINFO_LIST, *PPROCESSINFO_LIST;

typedef struct _LOADIMAGE_INFO
{
	/*00*/IMAGE_INFO ImageInfo;
	/*28*/PFLT_FILE_NAME_INFORMATION pFileNameInfo;
	/*30*/USHORT StackFrameCounts;
	/*32*/UCHAR Fill32[0x6];
	/*38*/PVOID StackFrameChain[MAX_STACKFRAME_COUNTS];
}LOADIMAGE_INFO, *PLOADIMAGE_INFO;

typedef struct _THREADINFO_LIST
{
	ULONG RefCount;
	PETHREAD Thread;
	LIST_ENTRY List;
}THREADINFO_LIST, *PTHREADINFO_LIST;

typedef struct _THREAD_PROFILING_UPDATE_APC
{
	KAPC Apc;
	HANDLE ProcessId;
	ULONG ContextSwitchesChange;
	ULONG KernelTimeChange;
	ULONG UserTimeChange;
}THREAD_PROFILING_UPDATE_APC, *PTHREAD_PROFILING_UPDATE_APC;

typedef enum _THREAD_PROFILING_WAIT_OBJECTS
{
	ProfilingExitEvent = 0,
	ProfilingProcess,
	ProfilingThread,
	ProfilingReset
}THREAD_PROFILING_WAIT_OBJECTS;

typedef struct _THREAD_PROFILING_INFO
{
	CLIENT_ID ClientId;
	ULONG ContextSwitches;
	ULONG Fill14;
	LARGE_INTEGER KernelTime;
	LARGE_INTEGER UserTime;
	LIST_ENTRY List;
}THREAD_PROFILING_INFO, *PTHREAD_PROFILING_INFO;

typedef struct _GETFULLNAME_WORKITEM
{
	WORK_QUEUE_ITEM WorkItem;
	KEVENT NotifyEvent;
	PUNICODE_STRING pUniStrImageName;
	PUNICODE_STRING pUniStrFullName;
}GETFULLNAME_WORKITEM, *PGETFULLNAME_WORKITEM;

typedef
NTSTATUS
(NTAPI *FNZwQueryInformationThread)(
	__in HANDLE ThreadHandle,
	__in THREADINFOCLASS ThreadInformationClass,
	__out_bcount(ThreadInformationLength) PVOID ThreadInformation,
	__in ULONG ThreadInformationLength,
	__out_opt PULONG ReturnLength
	);

typedef
NTSTATUS
(NTAPI *FNSeLocateProcessImageName)(
	_Inout_ PEPROCESS Process,
	_Outptr_ PUNICODE_STRING *pImageFileName
	);

typedef
NTSTATUS
(NTAPI *FNPsSetCreateThreadNotifyRoutineEx)(
	_In_ PSCREATETHREADNOTIFYTYPE NotifyType,
	_In_ PVOID NotifyInformation
	);


typedef
NTSTATUS
(NTAPI *FNPsSetCreateProcessNotifyRoutineEx2)(
	_In_ PSCREATEPROCESSNOTIFYTYPE NotifyType,
	_In_ PVOID NotifyInformation,
	_In_ BOOLEAN Remove
	);

typedef
NTSTATUS
(NTAPI *FNZwOpenProcessTokenEx)(
	_In_ HANDLE ProcessHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ ULONG HandleAttributes,
	_Out_ PHANDLE TokenHandle
	);


PPROCESSINFO_LIST
RefProcessInfo(
	_In_ HANDLE ProcessId,
	_In_ BOOLEAN bNotAsyn
);

VOID
DerefProcessInfo(
	_In_ PPROCESSINFO_LIST pProcessInfo
);

BOOLEAN
RefThreadInfo(
	VOID
);

VOID
DeRefThreadInfo(
	VOID
);

BOOLEAN
ProcmonEnableThreadProfiling(
	_In_ LARGE_INTEGER Period
);

VOID
ProcmonCollectProcessAndSystemPerformanceData(
	VOID
);

VOID
ProcmonWaitProcessExitWorkRoutine(
	_In_ PVOID pWorkItem
);

VOID
ProcmonProcessMonitorInit(
	VOID
);

NTSTATUS
EnableProcessMonitor(
	_In_ BOOLEAN bEnable
);

VOID
LoadImageNotifyRoutine(
	_In_ PUNICODE_STRING FullImageName,
	_In_ HANDLE ProcessId,
	_In_ PIMAGE_INFO pImageInfo
);
```

`kernel/procmon.c`:

```c
/*++

Module Name:

    procmon.c

Abstract:

    This is the main module of the procmon miniFilter driver.

Environment:

    Kernel mode

--*/

#include <fltKernel.h>
#include <Wdmsec.h>
#include <dontuse.h>

#include "ntheader.h"
#include "globals.h"
#include "log.h"
#include "utils.h"
#include "process.h"
#include "file.h"
#include "reg.h"


#pragma prefast(disable:__WARNING_ENCODE_MEMBER_FUNCTION_POINTER, "Not valid for kernel mode drivers")

#define TAG_LOOKSIDE 'nmP'

#define SYSTEM_DRIVER_PATH L"\\SystemRoot\\System32\\Drivers\\"

typedef
NTSTATUS
(*FNMESSAGEPROCESSOR)(
	VOID
	);

PFLT_PORT gServerPort = NULL;
PDEVICE_OBJECT gProcmonDebugLoggerDeviceObject = NULL;
PDEVICE_OBJECT gDevProcmonExternalLogger = NULL;
PRKEVENT gProcmonExternalLoggerEnabledEvent = NULL;
HANDLE gEventHandle = NULL;
FNMESSAGEPROCESSOR gfnDataProcessor;

#define PTDBG_TRACE_ROUTINES            0x00000001
#define PTDBG_TRACE_OPERATION_STATUS    0x00000002

ULONG gTraceFlags = 0;


#define PT_DBG_PRINT( _dbgLevel, _string )          \
    (FlagOn(gTraceFlags,(_dbgLevel)) ?              \
        DbgPrint _string :                          \
        ((int)0))

#define INVALID_HANDLE_VALUE ((HANDLE) -1)
#define IsAddressInModule(_addr, _base, _size) (((ULONG_PTR)_addr > (ULONG_PTR)_base) && \
					(ULONG_PTR)_addr < (ULONG_PTR)((ULONG_PTR)_base + (ULONG)_size))

/*************************************************************************
    Prototypes
*************************************************************************/

EXTERN_C_START

DRIVER_INITIALIZE DriverEntry;
NTSTATUS
DriverEntry (
    _In_ PDRIVER_OBJECT DriverObject,
    _In_ PUNICODE_STRING RegistryPath
    );

NTSTATUS
ProcmonInstanceSetup (
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _In_ FLT_INSTANCE_SETUP_FLAGS Flags,
    _In_ DEVICE_TYPE VolumeDeviceType,
    _In_ FLT_FILESYSTEM_TYPE VolumeFilesystemType
    );

VOID
ProcmonInstanceTeardownStart (
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _In_ FLT_INSTANCE_TEARDOWN_FLAGS Flags
    );

VOID
ProcmonInstanceTeardownComplete (
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _In_ FLT_INSTANCE_TEARDOWN_FLAGS Flags
    );

NTSTATUS
ProcmonUnload (
    _In_ FLT_FILTER_UNLOAD_FLAGS Flags
    );

NTSTATUS
ProcmonInstanceQueryTeardown (
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _In_ FLT_INSTANCE_QUERY_TEARDOWN_FLAGS Flags
    );

FLT_PREOP_CALLBACK_STATUS
ProcmonPreOperation (
    _Inout_ PFLT_CALLBACK_DATA Data,
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _Flt_CompletionContext_Outptr_ PVOID *CompletionContext
    );

VOID
ProcmonOperationStatusCallback (
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _In_ PFLT_IO_PARAMETER_BLOCK ParameterSnapshot,
    _In_ NTSTATUS OperationStatus,
    _In_ PVOID RequesterContext
    );

FLT_POSTOP_CALLBACK_STATUS
ProcmonPostOperation (
    _Inout_ PFLT_CALLBACK_DATA Data,
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _In_opt_ PVOID CompletionContext,
    _In_ FLT_POST_OPERATION_FLAGS Flags
    );

FLT_PREOP_CALLBACK_STATUS
ProcmonPreOperationNoPostOperation (
    _Inout_ PFLT_CALLBACK_DATA Data,
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _Flt_CompletionContext_Outptr_ PVOID *CompletionContext
    );

BOOLEAN
procmonDoRequestOperationStatus(
    _In_ PFLT_CALLBACK_DATA Data
    );

EXTERN_C_END

VOID
ProcmonProcessExitOff(
	VOID
);

LONG
SetMessageProcessor(
	_In_ FNMESSAGEPROCESSOR Processor
);

VOID
ProcmonControlProcMonitor(
	_In_ ULONG Flags
);

NTSTATUS
ProcmonWriteToPbmFile(
	VOID
);

//
//  Assign text sections for each routine.
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, ProcmonUnload)
#pragma alloc_text(PAGE, ProcmonInstanceQueryTeardown)
#pragma alloc_text(PAGE, ProcmonInstanceSetup)
#pragma alloc_text(PAGE, ProcmonInstanceTeardownStart)
#pragma alloc_text(PAGE, ProcmonInstanceTeardownComplete)
#endif

//
//  operation registration
//

const FLT_OPERATION_REGISTRATION Callbacks[] = {

#if 1
    { IRP_MJ_CREATE,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_CREATE_NAMED_PIPE,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_CLOSE,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_READ,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_WRITE,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_QUERY_INFORMATION,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_SET_INFORMATION,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_QUERY_EA,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_SET_EA,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_FLUSH_BUFFERS,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_QUERY_VOLUME_INFORMATION,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_SET_VOLUME_INFORMATION,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_DIRECTORY_CONTROL,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_FILE_SYSTEM_CONTROL,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_DEVICE_CONTROL,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_INTERNAL_DEVICE_CONTROL,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_SHUTDOWN,
      0,
	  ProcmonPreOperation,
      NULL },                               //post operations not supported

    { IRP_MJ_LOCK_CONTROL,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_CLEANUP,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_CREATE_MAILSLOT,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_QUERY_SECURITY,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_SET_SECURITY,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_QUERY_QUOTA,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_SET_QUOTA,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_PNP,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_ACQUIRE_FOR_SECTION_SYNCHRONIZATION,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_RELEASE_FOR_SECTION_SYNCHRONIZATION,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_ACQUIRE_FOR_MOD_WRITE,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_RELEASE_FOR_MOD_WRITE,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_ACQUIRE_FOR_CC_FLUSH,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_RELEASE_FOR_CC_FLUSH,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_FAST_IO_CHECK_IF_POSSIBLE,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_NETWORK_QUERY_OPEN,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_MDL_READ,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_MDL_READ_COMPLETE,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_PREPARE_MDL_WRITE,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_MDL_WRITE_COMPLETE,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_VOLUME_MOUNT,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

    { IRP_MJ_VOLUME_DISMOUNT,
      0,
      ProcmonPreOperation,
      ProcmonPostOperation },

#endif

    { IRP_MJ_OPERATION_END }
};

//
//  This defines what we want to filter with FltMgr
//

CONST FLT_REGISTRATION FilterRegistration = {

    sizeof( FLT_REGISTRATION ),         //  Size
    FLT_REGISTRATION_VERSION,           //  Version
    0,                                  //  Flags

    NULL,                               //  Context
    Callbacks,                          //  Operation callbacks

    /*procmonUnload*/NULL,                           //  MiniFilterUnload

    ProcmonInstanceSetup,                    //  InstanceSetup
    ProcmonInstanceQueryTeardown,            //  InstanceQueryTeardown
    /*ProcmonInstanceTeardownStart*/NULL,            //  InstanceTeardownStart
    /*ProcmonInstanceTeardownComplete*/NULL,         //  InstanceTeardownComplete

    NULL,                               //  GenerateFileName
    NULL,                               //  GenerateDestinationFileName
    NULL                                //  NormalizeNameComponent

};



NTSTATUS
ProcmonInstanceSetup (
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _In_ FLT_INSTANCE_SETUP_FLAGS Flags,
    _In_ DEVICE_TYPE VolumeDeviceType,
    _In_ FLT_FILESYSTEM_TYPE VolumeFilesystemType
    )
/*++

Routine Description:

    This routine is called whenever a new instance is created on a volume. This
    gives us a chance to decide if we need to attach to this volume or not.

    If this routine is not defined in the registration structure, automatic
    instances are always created.

Arguments:

    FltObjects - Pointer to the FLT_RELATED_OBJECTS data structure containing
        opaque handles to this filter, instance and its associated volume.

    Flags - Flags describing the reason for this attach request.

Return Value:

    STATUS_SUCCESS - attach
    STATUS_FLT_DO_NOT_ATTACH - do not attach

--*/
{
    UNREFERENCED_PARAMETER( FltObjects );
    UNREFERENCED_PARAMETER( Flags );
    UNREFERENCED_PARAMETER( VolumeDeviceType );
    UNREFERENCED_PARAMETER( VolumeFilesystemType );

    PAGED_CODE();

    PT_DBG_PRINT( PTDBG_TRACE_ROUTINES,
                  ("procmon!procmonInstanceSetup: Entered\n") );

    return STATUS_SUCCESS;
}


NTSTATUS
ProcmonInstanceQueryTeardown (
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _In_ FLT_INSTANCE_QUERY_TEARDOWN_FLAGS Flags
    )
/*++

Routine Description:

    This is called when an instance is being manually deleted by a
    call to FltDetachVolume or FilterDetach thereby giving us a
    chance to fail that detach request.

    If this routine is not defined in the registration structure, explicit
    detach requests via FltDetachVolume or FilterDetach will always be
    failed.

Arguments:

    FltObjects - Pointer to the FLT_RELATED_OBJECTS data structure containing
        opaque handles to this filter, instance and its associated volume.

    Flags - Indicating where this detach request came from.

Return Value:

    Returns the status of this operation.

--*/
{
    UNREFERENCED_PARAMETER( FltObjects );
    UNREFERENCED_PARAMETER( Flags );

    PAGED_CODE();

    PT_DBG_PRINT( PTDBG_TRACE_ROUTINES,
                  ("procmon!procmonInstanceQueryTeardown: Entered\n") );

    return STATUS_SUCCESS;
}


VOID
ProcmonInstanceTeardownStart (
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _In_ FLT_INSTANCE_TEARDOWN_FLAGS Flags
    )
/*++

Routine Description:

    This routine is called at the start of instance teardown.

Arguments:

    FltObjects - Pointer to the FLT_RELATED_OBJECTS data structure containing
        opaque handles to this filter, instance and its associated volume.

    Flags - Reason why this instance is being deleted.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER( FltObjects );
    UNREFERENCED_PARAMETER( Flags );

    PAGED_CODE();

    PT_DBG_PRINT( PTDBG_TRACE_ROUTINES,
                  ("procmon!procmonInstanceTeardownStart: Entered\n") );
}


VOID
ProcmonInstanceTeardownComplete (
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _In_ FLT_INSTANCE_TEARDOWN_FLAGS Flags
    )
/*++

Routine Description:

    This routine is called at the end of instance teardown.

Arguments:

    FltObjects - Pointer to the FLT_RELATED_OBJECTS data structure containing
        opaque handles to this filter, instance and its associated volume.

    Flags - Reason why this instance is being deleted.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER( FltObjects );
    UNREFERENCED_PARAMETER( Flags );

    PAGED_CODE();

    PT_DBG_PRINT( PTDBG_TRACE_ROUTINES,
                  ("procmon!procmonInstanceTeardownComplete: Entered\n") );
}

PFLT_PORT gClientPort;

NTSTATUS 
FltOurSendMessage(
	_In_ PVOID SenderBuffer, 
	_In_ ULONG SenderBufferLength
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	return FltSendMessage(gFilterHandle, &gClientPort, SenderBuffer, 
		SenderBufferLength, NULL, NULL, NULL);
}

NTSTATUS 
ProcmonWriteToFltMessage(
	VOID
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	return ProcessLogDataWithCallback(FltOurSendMessage);
}

NTSTATUS
FLTAPI 
FltConnectNotify(
	_In_ PFLT_PORT ClientPort,
	_In_opt_ PVOID ServerPortCookie,
	_In_reads_bytes_opt_(SizeOfContext) PVOID ConnectionContext,
	_In_ ULONG SizeOfContext,
	_Outptr_result_maybenull_ PVOID *ConnectionPortCookie
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	NTSTATUS Status;
	ULONG Flag;

	UNREFERENCED_PARAMETER(ServerPortCookie);

	if (SizeOfContext != 4)
		return STATUS_INVALID_PARAMETER;

	Flag = *(PULONG)ConnectionContext;
	if (Flag){
		if (Flag == 1){
			
			//
			// 这个port使用来用环三来处理进程路径.
			// 如果内核不能获取进程的路径,则通过这个Port来通知环三
			//
			
			gClientProcessPathPort = ClientPort;
			*ConnectionPortCookie = &gClientProcessPathPort;
		}
		Status = STATUS_SUCCESS;
	}else if (gCurrentProcess){
		Status = STATUS_TOO_MANY_OPENED_FILES;
	}else{
		ProcmonProcessExitOff();
		SetMessageProcessor(ProcmonWriteToFltMessage);
		gCurrentProcess = IoGetCurrentProcess();
		gProcessId = PsGetCurrentProcessId();
		gClientPort = ClientPort;
		*ConnectionPortCookie = &gClientPort;
		Status = STATUS_SUCCESS;
	}
	
	return Status;
}

VOID
FLTAPI 
FltDisconnectNotify(
	_In_opt_ PVOID ConnectionCookie
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	if (ConnectionCookie == &gClientPort){
		gCurrentProcess = NULL;
		ProcmonControlProcMonitor(0);
		EnableFileMonitor(FALSE);
	}
	FltCloseClientPort(gFilterHandle, ConnectionCookie);
}

NTSTATUS
FLTAPI 
FltMessageNotify(
	_In_opt_ PVOID PortCookie,
	_In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
	_In_ ULONG InputBufferLength,
	_Out_writes_bytes_to_opt_(OutputBufferLength, *ReturnOutputBufferLength) PVOID OutputBuffer,
	_In_ ULONG OutputBufferLength,
	_Out_ PULONG ReturnOutputBufferLength
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{

	PFLTMSG_CONTROL_HEAD Header = (PFLTMSG_CONTROL_HEAD)InputBuffer;

	UNREFERENCED_PARAMETER(ReturnOutputBufferLength);
	UNREFERENCED_PARAMETER(OutputBufferLength);
	UNREFERENCED_PARAMETER(OutputBuffer);
	UNREFERENCED_PARAMETER(PortCookie);

	if (InputBufferLength < sizeof(FLTMSG_CONTROL_HEAD))
		return STATUS_INVALID_PARAMETER;
	if (Header->CtlCode){
		
		//
		// Enable or disable Thread profiling
		//
		
		if (Header->CtlCode == 1){
			if (InputBufferLength >= sizeof(FLTMSG_CONTROL_THREADPROFILING)){
				PFLTMSG_CONTROL_THREADPROFILING pThreadProfiling = (PFLTMSG_CONTROL_THREADPROFILING)InputBuffer;
				ProcmonEnableThreadProfiling(pThreadProfiling->ThreadProfile);
				return 0;
			}
			return STATUS_INVALID_PARAMETER;
		}
	}else{

		PFLTMSG_CONTROL_FLAGS pFlags = (PFLTMSG_CONTROL_FLAGS)InputBuffer;
		if (InputBufferLength < sizeof(FLTMSG_CONTROL_FLAGS))
			return STATUS_INVALID_PARAMETER;
		
		//
		// Control the procmon on/off
		//
		
		ProcmonControlProcMonitor(pFlags->Flags);
	}
	return STATUS_SUCCESS;
}

BOOLEAN
PromonCleanupDevice(
	VOID
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	UNICODE_STRING strDeviceSymbName;

	RtlInitUnicodeString(&strDeviceSymbName, PROCMON_DEBUGLOGGER_SYMBOL_NAME);
	IoDeleteSymbolicLink(&strDeviceSymbName);
	
	//
	// Clean up debug logger device
	//
	
	if (gProcmonDebugLoggerDeviceObject)
		IoDeleteDevice(gProcmonDebugLoggerDeviceObject);

	//
	// Clean up external logger device
	//

	if (gDevProcmonExternalLogger)
		IoDeleteDevice(gDevProcmonExternalLogger);
	
	//
	// Clean up external logger event object
	//
	
	if (gProcmonExternalLoggerEnabledEvent){
		KeClearEvent(gProcmonExternalLoggerEnabledEvent);
		ZwClose(gEventHandle);
	}
	return 1;
}

NTSTATUS
ProcmonStartFileFilter(
	_In_ PDRIVER_OBJECT DriverObject
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	
	NTSTATUS Status;
	OBJECT_ATTRIBUTES ObjectAttributes;
	UNICODE_STRING strObjectName;
	PSECURITY_DESCRIPTOR pSecurityDescriptor;

	//
	// Init spinlock for file name information list
	//
	
	KeInitializeSpinLock(&gFileNameInfoListSpinLock);
	
	//
	// Register with FltMgr to tell it our callback routines
	//
	
	Status = FltRegisterFilter(DriverObject, &FilterRegistration, &gFilterHandle);
	FLT_ASSERT(NT_SUCCESS(Status));

	if (NT_SUCCESS(Status)){
		
		//
		// Build security descriptor for server port
		//
		
		Status = FltBuildDefaultSecurityDescriptor(&pSecurityDescriptor, FLT_PORT_ALL_ACCESS);
		if (NT_SUCCESS(Status)){

			//
			// Set server port name and security descriptor
			//

			RtlInitUnicodeString(&strObjectName, PROCMON_PORTNAME);
			InitializeObjectAttributes(&ObjectAttributes, &strObjectName, 576, NULL, pSecurityDescriptor);
			
			//
			// Create communication port, we should use this port to communicate with user-mode app
			//
			
			FltCreateCommunicationPort(
				gFilterHandle,
				&gServerPort,
				&ObjectAttributes,
				NULL,
				FltConnectNotify,
				FltDisconnectNotify,
				FltMessageNotify,
				2);
			
			//
			// security descriptor is not useful here just release it
			//
			
			FltFreeSecurityDescriptor(pSecurityDescriptor);
			
			//
			// Start the filter
			//
			
			Status = FltStartFiltering(gFilterHandle);
		}
	}

	//
	// If somewhere failed clean up
	//
	
	if (!NT_SUCCESS(Status)){
		
		//
		// Close all device we create
		//
		
		PromonCleanupDevice();
		
		//
		// clean server port
		//
		
		if (gServerPort)
			FltCloseCommunicationPort(gServerPort);
		
		//
		// clean filter handle
		//
		
		if (gFilterHandle)
			FltUnregisterFilter(gFilterHandle);
	}
	return Status;
}


VOID
ProcessDataDpcRoutine(
	_In_ struct _KDPC *Dpc,
	_In_opt_ PVOID DeferredContext,
	_In_opt_ PVOID SystemArgument1,
	_In_opt_ PVOID SystemArgument2
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	UNREFERENCED_PARAMETER(Dpc);
	UNREFERENCED_PARAMETER(DeferredContext);
	UNREFERENCED_PARAMETER(SystemArgument1);
	UNREFERENCED_PARAMETER(SystemArgument2);

	KeSetEvent(&gEventProcessData, LOW_PRIORITY, FALSE);
}


VOID
ProcessDataThread(
	_In_ PVOID StartContext
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	UNREFERENCED_PARAMETER(StartContext);
	while (!KeWaitForSingleObject(&gEventProcessData, Executive, KernelMode, FALSE, NULL))
	{
		
		//
		// Process data
		//
		
		while (NT_SUCCESS(gfnDataProcessor()))
			;
	}
}

NTSTATUS
ProcmonInitialize(
	VOID
)
/*++

Routine Description:

    This routine use to initialize all the locks and lists.

Arguments:

	 None

Return Value:

    Routine can return non success error codes.

--*/
{
	NTSTATUS Status;
	ULONG NeedLength = 1000;
	PVOID pBuffer = NULL;
	OBJECT_ATTRIBUTES ObjectAttributes;
	HANDLE hThread;

	KeInitializeEvent(&gEventProcessData, SynchronizationEvent, 0);
	KeInitializeTimer(&gTimerProcessLogData);
	KeInitializeDpc(&gDpcProcessData, ProcessDataDpcRoutine, NULL);
	InitializeListHead(&gLogListHead);

	ExInitializeNPagedLookasideList(&gNPagedLooksideListLogBuffer, NULL, NULL, 0, 
		MAX_PROCMON_MESSAGE_LEN + sizeof(LOG_BUFFER),
		TAG_LOOKSIDE, 0);
	ExInitializeFastMutex(&gMutexLogList);
	InitializeListHead(&gThreadInfoList);
	ExInitializeNPagedLookasideList(&gNPagedLooksideListThreadInfo, NULL, NULL, 0, sizeof(THREADINFO_LIST), TAG_LOOKSIDE, 0);
	ExInitializeFastMutex(&gThreadInfoMutex);
	
	do 
	{
		if (pBuffer){
			ExFreePoolWithTag(pBuffer, 0);
		}

		pBuffer = ProcmonAllocatePoolWithTag(PagedPool, NeedLength, 'G');
		
		//
		// try to query 
		//
		
		Status = ZwQuerySystemInformation(SystemModuleInformation, pBuffer, NeedLength, &NeedLength);
		if (NT_SUCCESS(Status) || Status != STATUS_INFO_LENGTH_MISMATCH){
			break;
		}
		
		//
		// add NeedLength and continue
		//
		
		NeedLength += 1000;


	} while (TRUE);

	if (NT_SUCCESS(Status)){
		PRTL_PROCESS_MODULES pModuleInfo = (PRTL_PROCESS_MODULES)pBuffer;
		for (int i = 0; i < (int)pModuleInfo->NumberOfModules; i++)
		{
			PRTL_PROCESS_MODULE_INFORMATION pModule = &pModuleInfo->Modules[i];
			if (IsAddressInModule(ProcmonInitialize, pModule->ImageBase, pModule->ImageSize)){
				gSelfImageBase = pModule->ImageBase;
				gSelfImageSize = pModule->ImageSize;
				break;
			}
		}
		
		//
		// do not forget release the buffer
		//
		
		ExFreePoolWithTag(pBuffer, 0);
	}
	
	//
	// Create a new thread for data process
	//
	
	InitializeObjectAttributes(&ObjectAttributes, NULL, 512, NULL, NULL);
	
	gWriteFileFrqs = 100000000;

	PsCreateSystemThread(
		&hThread,
		THREAD_ALL_ACCESS,
		&ObjectAttributes,
		NULL,
		NULL,
		ProcessDataThread,
		NULL);
	return STATUS_SUCCESS;
}


KTIMER gTimerRuntimes;
KDPC gDpcRuntimes;
KEVENT gEventFileWriteFiled;


typedef
NTSTATUS
(NTAPI *FNMESSAGEPROCESSOR)(
	VOID
	);

FNMESSAGEPROCESSOR gfnDataProcessor;

LONG 
SetMessageProcessor(
	_In_ FNMESSAGEPROCESSOR Processor
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	gfnDataProcessor = Processor;
	return KeSetEvent(&gEventProcessData, 0, 0);
}


VOID 
ProcmonRuntimeDpcWorkRoutine(
	_In_ PVOID Parameter
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	PWORK_QUEUE_ITEM pWorkItem = (PWORK_QUEUE_ITEM)Parameter;
	if (gFlags){
		
		//
		// Collect the process data an turn off the monitor
		//
		
		ProcmonCollectProcessAndSystemPerformanceData();
		SetMessageProcessor(ProcmonWriteToPbmFile);
		KeWaitForSingleObject(&gEventFileWriteFiled, 0, 0, 0, NULL);
		ProcmonControlProcMonitor(0);
	}
	ExFreePoolWithTag(pWorkItem, 0);
}

VOID
ProcmonRuntimeDpcRoutine(
	_In_     struct _KDPC *Dpc,
	_In_opt_ PVOID        DeferredContext,
	_In_opt_ PVOID        SystemArgument1,
	_In_opt_ PVOID        SystemArgument2
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	PWORK_QUEUE_ITEM pWorkItem;

	UNREFERENCED_PARAMETER(Dpc);
	UNREFERENCED_PARAMETER(DeferredContext);
	UNREFERENCED_PARAMETER(SystemArgument1);
	UNREFERENCED_PARAMETER(SystemArgument2);

	pWorkItem = ProcmonAllocatePoolWithTag(NonPagedPool, sizeof(WORK_QUEUE_ITEM), 'M');
	if (pWorkItem) {
		pWorkItem->Parameter = pWorkItem;
		pWorkItem->WorkerRoutine = ProcmonRuntimeDpcWorkRoutine;
		pWorkItem->List.Flink = NULL;
		ExQueueWorkItem(pWorkItem, DelayedWorkQueue);
	}
}

HANDLE ghPMBFile = INVALID_HANDLE_VALUE;

NTSTATUS 
ProcmonCreateProcmonPmbFile(
	VOID
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	OBJECT_ATTRIBUTES ObjectAttributes;
	UNICODE_STRING UniStrPMBFileName;
	IO_STATUS_BLOCK IoStatusBlock;

	if (ghPMBFile != INVALID_HANDLE_VALUE)
		return STATUS_SUCCESS;

	RtlInitUnicodeString(&UniStrPMBFileName, PROCMON_DEFAULT_LOGFILE);
	InitializeObjectAttributes(&ObjectAttributes, &UniStrPMBFileName, 0x40, NULL, NULL);
	return ZwCreateFile(&ghPMBFile, 0x100002, &ObjectAttributes, &IoStatusBlock, 
		NULL, 0x80, 1u, 5, 0x20, NULL, 0);
}

NTSTATUS
ProcmonWriteMessageToFile(
	_In_ PVOID SenderBuffer,
	_In_ ULONG SenderBufferLength
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	NTSTATUS Status;
	IO_STATUS_BLOCK IoStatusBlock;
	LARGE_INTEGER FileInformation;

	UNREFERENCED_PARAMETER(SenderBufferLength);

	Status = ZwWriteFile(ghPMBFile, NULL, NULL, NULL, &IoStatusBlock, 
		(PVOID)((ULONG_PTR)SenderBuffer + sizeof(ULONG)), 
		*(PULONG)SenderBuffer, NULL, NULL);
	if (IoStatusBlock.Status == STATUS_DISK_FULL){
		FileInformation.QuadPart = 0;
		ZwSetInformationFile(ghPMBFile, &IoStatusBlock, &FileInformation, sizeof(FileInformation), FileEndOfFileInformation);
		Status = ProcessLogDataWithCallback(ProcmonWriteMessageToFile);
		if (!NT_SUCCESS(Status)){
			if (ghPMBFile != INVALID_HANDLE_VALUE){
				ZwClose(ghPMBFile);
				ghPMBFile = INVALID_HANDLE_VALUE;
				Status = KeSetEvent(&gEventFileWriteFiled, 0, 0);
			}
			gWriteFileFrqs = 100000000;
		}
	}
	return Status;
}

NTSTATUS 
ProcmonCreatePbmFiles(
	VOID
)
/*++

Routine Description:

    This function will open the pbm log file at default path "\\SystemRoot\\Procmon.pmb"
	And the write the log data which save in list to pbm log file.

Arguments:

	 -None

Return Value:

    Routine can return non success error codes.

--*/
{
	NTSTATUS Status = ProcmonCreateProcmonPmbFile();
	if (NT_SUCCESS(Status)) {
		
		//
		// We write the data to pmb file
		//
		
		return ProcessLogDataWithCallback(ProcmonWriteMessageToFile);
	}
	ProcmonCleanupWriteState();
	return STATUS_END_OF_FILE;
}

NTSTATUS
ProcmonWriteToPbmFile(
	VOID
)
/*++

Routine Description:

    这个函数用来将链表中保存的日志数据保存到文件中.

Arguments:

	 None

Return Value:

    Routine can return non success error codes.

--*/
{
	NTSTATUS Status;

	Status = ProcessLogDataWithCallback(ProcmonWriteMessageToFile);
	if (!NT_SUCCESS(Status)){
		if (ghPMBFile != INVALID_HANDLE_VALUE){
			ZwClose(ghPMBFile);
			ghPMBFile = INVALID_HANDLE_VALUE;
			KeSetEvent(&gEventFileWriteFiled, 0, 0);
		}
		gWriteFileFrqs = 100000000;
		Status = STATUS_END_OF_FILE;
	}
	return Status;
}

BOOLEAN 
ProcmonGetProcessParameter(
	_In_ PUNICODE_STRING pUniStrRegPath, 
	_Out_ PLONG pThreadProfiling, 
	_Out_ PLONG pRuntimeSeconds
)
/*++

Routine Description:

    这个函数会从注册表中读取驱动的参数.这里主要有ThreadProfiling 和 RuntimeSeconds.
	且都是REG_DWORD类型.

Arguments:

	 pUniStrRegPath - 驱动注册表路径,从DriverEntry传入.
	 pThreadProfiling - 用于保存获取的ThreadProfiling值
	 pRuntimeSeconds - 用于保存获取的RuntimeSeconds值

Return Value:

    Success - TRUE , failed - FALSE

--*/
{
	NTSTATUS Status;
	ULONG ResultLength;
	OBJECT_ATTRIBUTES ObjectAttributes;
	UNICODE_STRING ValueName;
	UNICODE_STRING UnistrKeyName;
	UNICODE_STRING UnistrParameters;
	HANDLE KeyHandle;
	HANDLE Handle;
	ULONG Value = 3;
	UCHAR KeyInfo[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG)];
	PKEY_VALUE_PARTIAL_INFORMATION pKeyInfo = (PKEY_VALUE_PARTIAL_INFORMATION)KeyInfo;


	InitializeObjectAttributes(&ObjectAttributes, pUniStrRegPath, 0x40, NULL, NULL);

	Status = ZwOpenKey(&KeyHandle, 0x2001Fu, &ObjectAttributes);
	if (NT_SUCCESS(Status)){
		RtlInitUnicodeString(&UnistrKeyName, L"Start");
		Status = ZwQueryValueKey(KeyHandle, &UnistrKeyName, KeyValuePartialInformation, pKeyInfo, sizeof(KeyInfo), &ResultLength);
		if (NT_SUCCESS(Status)){
			Value = *(PLONG)pKeyInfo->Data;
			if (!Value){

				ULONG DefaultStart = 3;

				RtlInitUnicodeString(&UnistrParameters, L"Parameters");
				InitializeObjectAttributes(&ObjectAttributes, &UnistrParameters, 0x40, KeyHandle, NULL);
				Status = ZwOpenKey(&Handle, 0x2001Fu, &ObjectAttributes);
				if (NT_SUCCESS(Status)){
					RtlInitUnicodeString(&ValueName, L"ThreadProfiling");
					Status = ZwQueryValueKey(Handle, &ValueName, KeyValuePartialInformation, 
						pKeyInfo, sizeof(KeyInfo), &ResultLength);
					if (NT_SUCCESS(Status))
						*pThreadProfiling = *(PLONG)pKeyInfo->Data;
					RtlInitUnicodeString(&ValueName, L"RuntimeSeconds");
					Status = ZwQueryValueKey(Handle, &ValueName, KeyValuePartialInformation, pKeyInfo, 
						sizeof(KeyInfo), &ResultLength);
					if (NT_SUCCESS(Status))
						*pRuntimeSeconds = *(PLONG)pKeyInfo->Data;
					ZwClose(Handle);
				}
				
				ZwSetValueKey(KeyHandle, &UnistrKeyName, 0, REG_DWORD, &DefaultStart, sizeof(ULONG));
				ZwFlushKey(KeyHandle);
			}
		}
		ZwClose(KeyHandle);
	}
	return Value == 0;
}


VOID
ProcmonEnumLoadedModule(
	VOID
)
/*++

Routine Description:

    这个函数用来枚举系统驱动模块,并记录之,这里需要注意的是Procmon始终将自己驱动的信息放在第一个.

Arguments:

	 None 

Return Value:

     None

--*/
{
	NTSTATUS Status;
	UNICODE_STRING UnistrDriversPath;
	PVOID pBuffer = NULL;
	ULONG NeedLength = 1000;
	ULONG Round = 0;
	PRTL_PROCESS_MODULES pSysModuleInfo;
	IMAGE_INFO ImageInfo = {0};

	RtlInitUnicodeString(&UnistrDriversPath, SYSTEM_DRIVER_PATH);

	do
	{
		if (pBuffer) {
			ExFreePoolWithTag(pBuffer, 0);
		}

		pBuffer = ProcmonAllocatePoolWithTag(PagedPool, NeedLength, 'b');
		if (!pBuffer) {
			break;
		}

		//
		// try to query 
		//

		Status = ZwQuerySystemInformation(SystemModuleInformation, pBuffer, NeedLength, &NeedLength);
		if (NT_SUCCESS(Status)) {
			break;
		}

		NeedLength += 1000;

	} while (TRUE);

	if (!pBuffer) {
		return;
	}

	pSysModuleInfo = (PRTL_PROCESS_MODULES)pBuffer;

	do 
	{
		
		//
		// 这里procmon要保证他的驱动信息在第一个,
		// 所以这里进行的两轮处理,第一轮主要是找procmon的驱动.
		// 第二轮找除了procmon的其他驱动.
		//
		
		for (ULONG i = 0; i < pSysModuleInfo->NumberOfModules; i++)
		{
			BOOLEAN bIsOurModule = IsAddressInModule(ProcmonEnumLoadedModule, 
				pSysModuleInfo->Modules[i].ImageBase, pSysModuleInfo->Modules[i].ImageSize);
			if ((Round == 1 && !bIsOurModule) ||
				(Round == 0 && bIsOurModule)){
				ANSI_STRING ImageNameAnsi;
				UNICODE_STRING UnistrImageName;
				UNICODE_STRING UnistrFullName;

				
				//
				// 这里我们需要记录三个信息就够了
				// 分别为Properties ImageBase 和 ImageSize
				//
				
				ImageInfo.Properties |= 0x100;
				ImageInfo.ImageBase = pSysModuleInfo->Modules[i].ImageBase;
				ImageInfo.ImageSize = pSysModuleInfo->Modules[i].ImageSize;

				ImageNameAnsi.Length = (USHORT)strlen((CHAR*)pSysModuleInfo->Modules[i].FullPathName);
				ImageNameAnsi.Buffer = (PCHAR)pSysModuleInfo->Modules[i].FullPathName;

				Status = RtlAnsiStringToUnicodeString(&UnistrImageName, &ImageNameAnsi, TRUE);

				if (NT_SUCCESS(Status)){
					
					//
					// 如果路径已\\开头,说明是相对路径
					// 我们需要添加上Driver文件夹的路径.
					//
					
					if (UnistrImageName.Buffer[0] != L'\\' &&
						(UnistrFullName.MaximumLength = UnistrImageName.Length + UnistrDriversPath.Length,
						(UnistrFullName.Buffer = ProcmonAllocatePoolWithTag(NonPagedPool, UnistrFullName.MaximumLength, 'b')) != NULL)) {


						if (UnistrFullName.Buffer) {
							RtlCopyUnicodeString(&UnistrFullName, &UnistrDriversPath);
							RtlAppendUnicodeStringToString(&UnistrFullName, &UnistrImageName);
							LoadImageNotifyRoutine(&UnistrFullName, PsGetCurrentProcessId(), &ImageInfo);
							ExFreePoolWithTag(UnistrFullName.Buffer, 0);
						}
					}else{
						LoadImageNotifyRoutine(&UnistrImageName, PsGetCurrentProcessId(), &ImageInfo);
					}

					RtlFreeUnicodeString(&UnistrImageName);
				}
			}

		}
		++Round;
	} while (Round < 2);
}

VOID
ProcmonStart(
	_In_ PUNICODE_STRING RegistryPath
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	LARGE_INTEGER DueTime;
	LONG RuntimeSeconds = -1;
	LONG ThreadProfiling = 0;

	ExInitializeFastMutex(&gMutexVolume);
	
	//
	// 首先枚举下磁盘卷设备
	//
	
	ProcmonEnumAllVolumes();
	
	//
	// 从注册表中获取参数的值
	//
	
	if (ProcmonGetProcessParameter(RegistryPath, &ThreadProfiling, &RuntimeSeconds)){

		KeInitializeEvent(&gEventFileWriteFiled, 0, 0);
		RtlInitUnicodeString(&gUniStrSystemRoot, L"\\SystemRoot");
		gWriteFileFrqs = 450000000;

		//
		// 设置回调为写日志文件.
		//
		
		SetMessageProcessor(ProcmonCreatePbmFiles);

		//
		// RuntimeSeconds 为设置允许多长时间后退出.
		//
		
		DueTime.QuadPart = -RuntimeSeconds;
		if (RuntimeSeconds != -1){
			KeInitializeTimer(&gTimerRuntimes);
			KeInitializeDpc(&gDpcRuntimes, ProcmonRuntimeDpcRoutine, NULL);
			KeSetTimer(&gTimerRuntimes, DueTime, &gDpcRuntimes);
		}


		ProcmonControlProcMonitor(7);
		if (ThreadProfiling) {
			LARGE_INTEGER Profiling;

			Profiling.QuadPart = ThreadProfiling;
			ProcmonEnableThreadProfiling(Profiling);
		}
		ProcmonEnumLoadedModule();
	}
}


GUID DeviceClassGuid = {
	0x3A1380F4,
	0x708F,
	0x49DE,
	{0xB2, 0xEF, 0x04, 0xD2, 0x5E, 0xB0, 0x09, 0xD5}
};

HANDLE ghEventHandle;

NTSTATUS
DispatchProcmonExternalLoggerCreateClose(
	_In_ PDEVICE_OBJECT DeviceObject, 
	_In_ PIRP Irp
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{

	UNREFERENCED_PARAMETER(DeviceObject);

	Irp->IoStatus.Information = 0;
	Irp->IoStatus.Status = STATUS_SUCCESS;
	IofCompleteRequest(Irp, 0);
	return STATUS_SUCCESS;
}

NTSTATUS 
DispatchProcmonExternalLogger(
	_In_ PDEVICE_OBJECT pDeviceObject, 
	_In_ PIRP pIrp
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	NTSTATUS Status = STATUS_INVALID_PARAMETER;
	PIO_STACK_LOCATION Irpsp;
	PPROCESSINFO_LIST pProcessInfo;
	PLOG_BUFFER pLogBuf;

	Irpsp = pIrp->Tail.Overlay.CurrentStackLocation;

	if (pDeviceObject == gDevProcmonExternalLogger){
		pIrp->IoStatus.Information = 0;
		Status = STATUS_SUCCESS;
#if 0
		if (Irpsp){
			if (Irpsp->Parameters.DeviceIoControl.IoControlCode == 0x95358200){
				pIrp->IoStatus.Information = 0;
				InputBufferLength = Irpsp->Parameters.DeviceIoControl.InputBufferLength;// InputBufferLength
				if (InputBufferLength < 0xFFF){

				}
			}
		}
#endif
	}

	if (pDeviceObject == gProcmonDebugLoggerDeviceObject){
		if (Irpsp){
			if (Irpsp->Parameters.DeviceIoControl.IoControlCode == 0x95358204 && 
				Irpsp->Parameters.DeviceIoControl.InputBufferLength < 0x1000){
				pProcessInfo = RefProcessInfo(PsGetCurrentProcessId(), TRUE);
				if (pProcessInfo){
					PVOID pLogInfo;
					pLogInfo = ProcmonGetLogEntryAndCopyFrameChain(
						MONITOR_TYPE_PROFILING,
						NOTIFY_PROFILING_DEBUG,
						pProcessInfo->Seq,
						259,
						Irpsp->Parameters.DeviceIoControl.InputBufferLength + 2,
						&pLogBuf);
					if (pLogInfo)
					{
						*(PUSHORT)pLogInfo = (USHORT)(Irpsp->Parameters.DeviceIoControl.InputBufferLength >> 1);
						RtlCopyMemory((PVOID)((ULONG_PTR)pLogInfo + sizeof(USHORT)), pIrp->AssociatedIrp.SystemBuffer, 
							Irpsp->Parameters.DeviceIoControl.InputBufferLength);
						ProcmonNotifyProcessLog(pLogBuf);
					}
					DerefProcessInfo(pProcessInfo);
					Status = STATUS_SUCCESS;
				}
			}
		}
	}
	pIrp->IoStatus.Information = 0;
	pIrp->IoStatus.Status = Status;
	IofCompleteRequest(pIrp, 0);
	return Status;
}

BOOLEAN
ProcmonCreateExternalLoggerDevice(
	_In_ PDRIVER_OBJECT DriverObject
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	NTSTATUS Status;
	PKEVENT pEvent;
	UNICODE_STRING UnistrDeviceName;
	UNICODE_STRING EventName;

	RtlInitUnicodeString(&UnistrDeviceName, PROCMON_EXTLOGGER_DEVICE_NAME);
	Status = WdmlibIoCreateDeviceSecure(
		DriverObject,
		0,
		&UnistrDeviceName,
		0x9535u,
		0x100u,
		0,
		&SDDL_DEVOBJ_KERNEL_ONLY,
		&DeviceClassGuid,
		&gDevProcmonExternalLogger);
	if (Status >= 0)
	{
		DriverObject->MajorFunction[IRP_MJ_CLOSE] = DispatchProcmonExternalLoggerCreateClose;
		DriverObject->MajorFunction[IRP_MJ_CREATE] = DispatchProcmonExternalLoggerCreateClose;
		DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = DispatchProcmonExternalLogger;
		DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DispatchProcmonExternalLogger;
		RtlInitUnicodeString(&EventName, PROCMON_EXTLOGGER_ENABLE_EVENT_NAME);
		pEvent = IoCreateNotificationEvent(&EventName, &ghEventHandle);
		gProcmonExternalLoggerEnabledEvent = pEvent;
		if (pEvent){
			KeClearEvent(pEvent);
			return Status >= 0;
		}
		Status = STATUS_UNSUCCESSFUL;
	}
	return NT_SUCCESS(Status);
}

BOOLEAN
ProcmonCreateDebugLoggerDevice(
	_In_ PDRIVER_OBJECT DriverObject
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	NTSTATUS Status;
	UNICODE_STRING UnistrDeviceName;
	UNICODE_STRING DefaultSDDLString;
	UNICODE_STRING SymbolicLinkName;

	RtlInitUnicodeString(&DefaultSDDLString, L"D:P(A;; GA;;; AU)");
	RtlInitUnicodeString(&UnistrDeviceName, PROCMON_DEBUGLOGGER_DEVICE_NAME);
	Status = WdmlibIoCreateDeviceSecure(
		DriverObject,
		0,
		&UnistrDeviceName,
		0x9535u,
		0x100u,
		0,
		&DefaultSDDLString,
		&DeviceClassGuid,
		&gProcmonDebugLoggerDeviceObject);
	if (NT_SUCCESS(Status)){
		RtlInitUnicodeString(&SymbolicLinkName, PROCMON_DEBUGLOGGER_SYMBOL_NAME);
		Status = IoCreateSymbolicLink(&SymbolicLinkName, &UnistrDeviceName);
		if (!NT_SUCCESS(Status)){
			IoDeleteDevice(gProcmonDebugLoggerDeviceObject);
			gProcmonDebugLoggerDeviceObject = NULL;
		}
	}
	return NT_SUCCESS(Status);
}

BOOLEAN 
ProcmonInitDevice(
	_In_ PDRIVER_OBJECT DriverObject
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	BOOLEAN bRet;

	gDevProcmonExternalLogger = NULL;
	gProcmonDebugLoggerDeviceObject = NULL;
	bRet = ProcmonCreateExternalLoggerDevice(DriverObject);
	if (bRet)
		ProcmonCreateDebugLoggerDevice(DriverObject);
	return bRet;
}

NTSTATUS
DriverEntry (
    _In_ PDRIVER_OBJECT DriverObject,
    _In_ PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This is the initialization routine for this miniFilter driver.  This
    registers with FltMgr and initializes all global data structures.

Arguments:

    DriverObject - Pointer to driver object created by the system to
        represent this driver.

    RegistryPath - Unicode string identifying where the parameters for this
        driver are located in the registry.

Return Value:

    Routine can return non success error codes.

--*/
{
    NTSTATUS status;

    PT_DBG_PRINT( PTDBG_TRACE_ROUTINES,
                  ("procmon!DriverEntry: Entered\n") );

	
	//
	//  Get system version and check
	//
	
	PsGetVersion(NULL, NULL, &gBuildNumber, 0);
	if (gBuildNumber < 2600)
		return STATUS_NOT_SUPPORTED;

	gDriverObject = DriverObject;

	//
	// Start file mini-filter
	//
	
	status = ProcmonStartFileFilter(DriverObject);
    FLT_ASSERT( NT_SUCCESS( status ) );

    if (NT_SUCCESS( status )) {
		ProcmonInitialize();
		ProcmonProcessMonitorInit();
		ProcmonRegMonitorInit();
		ProcmonInitDevice(DriverObject);
		ProcmonStart(RegistryPath);
    }

    return status;
}

NTSTATUS
ProcmonUnload (
    _In_ FLT_FILTER_UNLOAD_FLAGS Flags
    )
/*++

Routine Description:

    This is the unload routine for this miniFilter driver. This is called
    when the minifilter is about to be unloaded. We can fail this unload
    request if this is not a mandatory unload indicated by the Flags
    parameter.

Arguments:

    Flags - Indicating if this is a mandatory unload.

Return Value:

    Returns STATUS_SUCCESS.

--*/
{
    UNREFERENCED_PARAMETER( Flags );

    PAGED_CODE();

    PT_DBG_PRINT( PTDBG_TRACE_ROUTINES,
                  ("procmon!procmonUnload: Entered\n") );

    FltUnregisterFilter( gFilterHandle );

    return STATUS_SUCCESS;
}




PVOID
ProcmonCollectFileOptInfo(
	_In_ PCFLT_RELATED_OBJECTS FltObjects,
	_In_ const PFLT_IO_PARAMETER_BLOCK Iopb,
	_Out_ PULONG pSize
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{

	PVOID pFileOptInfo = NULL;
	ULONG TotalLength = 0;

	switch (Iopb->MajorFunction)
	{
	case IRP_MJ_CREATE:
	{
		PTOKEN_USER pTokenUser = NULL;
		ULONG TokenSize = 0;
		HANDLE hToken = ProcmonGetProcessTokenHandle(TRUE);
		if (hToken){
			pTokenUser = ProcmonQueryTokenInformation(hToken, NULL, NULL, NULL);
			if (pTokenUser){
				TokenSize = RtlLengthSid(pTokenUser->User.Sid);
			}
			ZwClose(hToken);
		}
		TotalLength = TokenSize + sizeof(LOG_FILE_CREATE);
		*pSize = TotalLength;
		pFileOptInfo = ProcmonAllocatePoolWithTag(NonPagedPool, TotalLength, 'H');
		if (pFileOptInfo){
			PLOG_FILE_CREATE pCreateFileOpt = (PLOG_FILE_CREATE)pFileOptInfo;
			pCreateFileOpt->DesiredAccess = Iopb->Parameters.Create.SecurityContext->DesiredAccess;
			pCreateFileOpt->UserTokenLength = TokenSize;
			if (TokenSize){
				RtlCopyMemory(pCreateFileOpt + 1, pTokenUser->User.Sid, TokenSize);
			}
		}

		if (pTokenUser){
			ExFreePoolWithTag(pTokenUser, 0);
		}
	}
		break;

	case IRP_MJ_SET_INFORMATION:
	{
		if (Iopb->Parameters.SetFileInformation.FileInformationClass == FileRenameInformation ||
			Iopb->Parameters.SetFileInformation.FileInformationClass == FileRenameInformationEx ||
			Iopb->Parameters.SetFileInformation.FileInformationClass == FileRenameInformationExBypassAccessCheck){

			NTSTATUS Status;
			PFILE_RENAME_INFORMATION pRenameInfo = (PFILE_RENAME_INFORMATION)Iopb->Parameters.SetFileInformation.InfoBuffer; 
			PFLT_FILE_NAME_INFORMATION pFileNameInformation = NULL;
			USHORT FileNameLength = 0;

			TotalLength = Iopb->Parameters.SetFileInformation.Length + sizeof(USHORT);

			Status = FltGetDestinationFileNameInformation(
				FltObjects->Instance,
				FltObjects->FileObject,
				pRenameInfo->RootDirectory,
				pRenameInfo->FileName,
				pRenameInfo->FileNameLength,
				FLT_FILE_NAME_QUERY_DEFAULT | FLT_FILE_NAME_NORMALIZED,
				&pFileNameInformation);
			if (NT_SUCCESS(Status)){
				FileNameLength = pFileNameInformation->Name.Length;
				TotalLength += FileNameLength;
			}else{
				pFileNameInformation = NULL;
				FileNameLength = 0;
			}

			*pSize = TotalLength;
			pFileOptInfo = ProcmonAllocatePoolWithTag(NonPagedPool, TotalLength, 'H');
			if (pFileOptInfo){
				RtlCopyMemory(pFileOptInfo, Iopb->Parameters.SetFileInformation.InfoBuffer, 
					Iopb->Parameters.SetFileInformation.Length);
				*(PUSHORT)((ULONG_PTR)pFileOptInfo + Iopb->Parameters.SetFileInformation.Length) = FileNameLength >> 1;
				if (FileNameLength){
					RtlCopyMemory((PVOID)((ULONG_PTR)pFileOptInfo + Iopb->Parameters.SetFileInformation.Length + sizeof(USHORT)),
						pFileNameInformation->Name.Buffer,
						FileNameLength
					);
				}
			}

			if (pFileNameInformation){
				FltReleaseFileNameInformation(pFileNameInformation);
			}
		}else{
			TotalLength = Iopb->Parameters.SetFileInformation.Length;

			*pSize = TotalLength;
			pFileOptInfo = ProcmonAllocatePoolWithTag(NonPagedPool, TotalLength, 'H');
			if (pFileOptInfo){
				RtlCopyMemory(pFileOptInfo, Iopb->Parameters.SetFileInformation.InfoBuffer,
					Iopb->Parameters.SetFileInformation.Length);
			}
		}
	}
		break;
	case IRP_MJ_SET_VOLUME_INFORMATION:
	{
		TotalLength = Iopb->Parameters.SetVolumeInformation.Length;
		*pSize = TotalLength;
		pFileOptInfo = ProcmonAllocatePoolWithTag(NonPagedPool, TotalLength, 'H');
		if (pFileOptInfo) {
			RtlCopyMemory(pFileOptInfo, Iopb->Parameters.SetVolumeInformation.VolumeBuffer,
				Iopb->Parameters.SetVolumeInformation.Length);
		}
	}
		break;
	case IRP_MJ_DIRECTORY_CONTROL:
	{
		if (Iopb->MinorFunction == IRP_MN_QUERY_DIRECTORY) {
			USHORT FileNameLength = 0;

			if (Iopb->Parameters.DirectoryControl.QueryDirectory.FileName){
				FileNameLength = Iopb->Parameters.DirectoryControl.QueryDirectory.FileName->Length;
				TotalLength = FileNameLength;
			}

			TotalLength += sizeof(LOG_FILE_NAME_COMMON);
			*pSize = TotalLength;
			pFileOptInfo = ProcmonAllocatePoolWithTag(NonPagedPool, TotalLength, 'H');
			if (pFileOptInfo) {
				PLOG_FILE_NAME_COMMON pFileNameOpt = (PLOG_FILE_NAME_COMMON)pFileOptInfo;
				pFileNameOpt->FileNameLength = FileNameLength >> 1;
				if (FileNameLength) {
					RtlCopyMemory(pFileNameOpt + 1, Iopb->Parameters.DirectoryControl.QueryDirectory.FileName->Buffer,
						FileNameLength);
				}
			}
		}
	}
		break;
	case IRP_MJ_FILE_SYSTEM_CONTROL:
	{
		ULONG FsControl = Iopb->Parameters.FileSystemControl.Common.FsControlCode;
		if (FsControl == FSCTL_OFFLOAD_READ || FsControl == FSCTL_OFFLOAD_WRITE){
			TotalLength = Iopb->Parameters.FileSystemControl.Buffered.InputBufferLength;
			*pSize = TotalLength;
			pFileOptInfo = ProcmonAllocatePoolWithTag(NonPagedPool, TotalLength, 'H');
			if (pFileOptInfo){
				RtlCopyMemory(pFileOptInfo, Iopb->Parameters.FileSystemControl.Buffered.SystemBuffer, TotalLength);
			}
		}
	}
		break;
	case IRP_MJ_LOCK_CONTROL:
	{
		LONGLONG LockCtlLength = 0;
		if (Iopb->Parameters.LockControl.Length){
			LockCtlLength = Iopb->Parameters.LockControl.Length->QuadPart;
		}

		TotalLength = sizeof(LOG_FILE_LOCKCONTROL);
		*pSize = TotalLength;
		pFileOptInfo = ProcmonAllocatePoolWithTag(NonPagedPool, TotalLength, 'H');
		if (pFileOptInfo) {
			RtlCopyMemory(pFileOptInfo, &LockCtlLength, TotalLength);
		}
	}
		break;
	case IRP_MJ_ACQUIRE_FOR_MOD_WRITE:
	{
		TotalLength = sizeof(LOG_FILE_ACQUIREFORMODIFIEDPAGEWRITER);
		*pSize = TotalLength;
		pFileOptInfo = ProcmonAllocatePoolWithTag(NonPagedPool, TotalLength, 'H');
		if (pFileOptInfo) {
			RtlCopyMemory(pFileOptInfo, Iopb->Parameters.AcquireForModifiedPageWriter.EndingOffset, TotalLength);
		}
	}
		break;
	default:
		break;
	}

	if (!pFileOptInfo){
		*pSize = 0;
	}else{

		//
		// jonasLyk find this oob bug of procmon
		// see:
		// https://twitter.com/jonasLyk/status/1301167318450532353
		//

		*pSize = min(TotalLength, 0xFFFF);//TotalLength > 0xFFFF ? 0xFFFF : TotalLength;
	}

	return pFileOptInfo;

}

/*************************************************************************
    MiniFilter callback routines.
*************************************************************************/
FLT_PREOP_CALLBACK_STATUS
ProcmonPreOperation (
    _Inout_ PFLT_CALLBACK_DATA Data,
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _Flt_CompletionContext_Outptr_ PVOID *CompletionContext
    )
/*++

Routine Description:

    This routine is a pre-operation dispatch routine for this miniFilter.

    This is non-pageable because it could be called on the paging path

Arguments:

    Data - Pointer to the filter callbackData that is passed to us.

    FltObjects - Pointer to the FLT_RELATED_OBJECTS data structure containing
        opaque handles to this filter, instance, its associated volume and
        file object.

    CompletionContext - The context for the completion routine for this
        operation.

Return Value:

    The return value is the status of the operation.

--*/
{
	NTSTATUS Status;
	PUNICODE_STRING pStrFileName = NULL;
	PFLT_FILE_NAME_INFORMATION FileNameInformation = NULL;
	BOOLEAN bSetTopIrql = FALSE;
	PIRP pTopIrpSaved = NULL;
	ULONG FullNameLength;
	HANDLE ProcessId;
	FLT_PREOP_CALLBACK_STATUS FltStatus = FLT_PREOP_SUCCESS_NO_CALLBACK;

	//
	// If major code is not shutdown
	// record the file operation and send to ring3
	//
	
	if (Data->Iopb->MajorFunction != IRP_MJ_SHUTDOWN){
		
		//
		// Invalid fileobject or User turn off the file monitor
		// do not call the post callback 
		//
		
		if (!FltObjects->FileObject || !FlagOn(gFlags, 2)){
			return FLT_PREOP_SUCCESS_NO_CALLBACK;
		}

		//
		// #define PASSIVE_LEVEL 0                 // Passive release level
		// #define LOW_LEVEL 0                     // Lowest interrupt level
		// #define APC_LEVEL 1                     // APC interrupt level
		// #define DISPATCH_LEVEL 2                // Dispatcher level
		//

		if (FsRtlIsPagingFile(FltObjects->FileObject) && KeGetCurrentIrql() == APC_LEVEL){
			pStrFileName = FindPagingFileNameInList(FltObjects->FileObject);
		}else{
			Status = FltGetFileNameInformation(Data,
				FLT_FILE_NAME_NORMALIZED | FLT_FILE_NAME_QUERY_ALWAYS_ALLOW_CACHE_LOOKUP,
				&FileNameInformation);
			if (NT_SUCCESS(Status)){
				
				//
				// duplicate the string
				//
				
				pStrFileName = ProcmonDuplicateUnicodeString(NonPagedPool, &FileNameInformation->Name, '1');
				FltReleaseFileNameInformation(FileNameInformation);
			}else{
				
				//
				// try use FLT_FILE_NAME_OPENED
				//
				
				Status = FltGetFileNameInformation(Data,
					FLT_FILE_NAME_OPENED | FLT_FILE_NAME_QUERY_ALWAYS_ALLOW_CACHE_LOOKUP,
					&FileNameInformation);
				if (NT_SUCCESS(Status)) {

					//
					// duplicate the string
					//

					pStrFileName = ProcmonDuplicateUnicodeString(NonPagedPool, &FileNameInformation->Name, '1');
					FltReleaseFileNameInformation(FileNameInformation);

				}else{
					
					//
					// Is paging file?
					//
					
					if (FsRtlIsPagingFile(FltObjects->FileObject) && 
						IoGetTopLevelIrp() == (PIRP)FltObjects->FileObject->FileName.Buffer ){
						
						//
						// Here we already add the paging file name to list
						//
						
						pStrFileName = FindPagingFileNameInList(FltObjects->FileObject);
					}else{

						if (FsRtlIsPagingFile(FltObjects->FileObject)){
							
							//
							// Save the old top Irp of this thread
							//
							
							pTopIrpSaved = IoGetTopLevelIrp();
							
							//
							// Set the our file name buffer
							//
							
							IoSetTopLevelIrp((PIRP)FltObjects->FileObject->FileName.Buffer);
							bSetTopIrql = TRUE;
						}
						
						//
						// Get volume name length
						//
						
						FltGetVolumeName(FltObjects->Volume, NULL, &FullNameLength);
						
						//
						// Calculate full file name length
						//
						
						FullNameLength += FltObjects->FileObject->FileName.Length;
						
						//
						// Allocate new buffer for full name
						//
						
						pStrFileName = (PUNICODE_STRING)ProcmonAllocatePoolWithTag(NonPagedPool, 
							FullNameLength + sizeof(UNICODE_STRING), '1');
						if (pStrFileName){
							
							//
							// Initialize the new string
							//
							
							pStrFileName->MaximumLength = (USHORT)FullNameLength;
							pStrFileName->Buffer = (PWCH)(pStrFileName + 1);
							
							//
							// Get the volume name
							//
							
							FltGetVolumeName(FltObjects->Volume, pStrFileName, &FullNameLength);
							RtlAppendUnicodeStringToString(pStrFileName, &FltObjects->FileObject->FileName);
						}

						
						//
						// Restore the top Irp
						//
						
						if (bSetTopIrql){
							IoSetTopLevelIrp(pTopIrpSaved);
						}
					}
				}
			}
		}
		
		//
		// Get file name finish
		//
		
		if (pStrFileName){
			
			BOOLEAN bNotAsyn;
			PPROCESSINFO_LIST pProcessInfo;
			ULONG FileInfoSize = 0, TotalLength;
			PVOID pFileOptInfo;
			UCHAR MinjorFunction;
			USHORT NotifyType;
			PLOG_FILE_OPT pLogEntry;
			LONG Seq;
			PLOG_BUFFER pLogBuf;

			//
			// Here we get the file name 
			//

			if (FsRtlIsPagingFile(FltObjects->FileObject)){
				
				//
				// Add to paging file object list
				//
				
				AddToPagingFileNameList(FltObjects->FileObject, pStrFileName);

			}

			bNotAsyn = !FlagOn(Data->Iopb->IrpFlags, IRP_SYNCHRONOUS_PAGING_IO) ? TRUE : FALSE;
			ProcessId = PsGetCurrentProcessId();
			pProcessInfo = RefProcessInfo(ProcessId, bNotAsyn);
			if (pProcessInfo && pProcessInfo->bInit){
				if (FlagOn(Data->Flags, FLTFL_CALLBACK_DATA_FAST_IO_OPERATION)){
					Data->IoStatus.Status = STATUS_SUCCESS;
				}

				pFileOptInfo = ProcmonCollectFileOptInfo(FltObjects, Data->Iopb, &FileInfoSize);
				if (Data->Iopb->MajorFunction == IRP_MJ_QUERY_INFORMATION ||
					Data->Iopb->MajorFunction == IRP_MJ_SET_INFORMATION ||
					Data->Iopb->MajorFunction == IRP_MJ_QUERY_VOLUME_INFORMATION) {
					MinjorFunction = (UCHAR)Data->Iopb->Parameters.QueryFileInformation.FileInformationClass;
				}else{

					//
					// IRP_MJ_QUERY_INFORMATION Or IRP_MJ_SET_INFORMATION
					//

					MinjorFunction = Data->Iopb->MinorFunction;
				}

				TotalLength = pStrFileName->Length + FileInfoSize + sizeof(LOG_FILE_OPT);
				
				//
				// like IRP_MJ_NETWORK_QUERY_OPEN will be failed
				//
				
				NotifyType = (UCHAR)(Data->Iopb->MajorFunction + 20);
				pLogEntry = (PLOG_FILE_OPT)ProcmonGetLogEntryAndSeq(
					!FsRtlIsPagingFile(FltObjects->FileObject),
					MONITOR_TYPE_FILE,
					NotifyType,
					pProcessInfo->Seq,
					STATUS_PENDING,
					TotalLength,
					&Seq,
					&pLogBuf);
				if (pLogEntry) {
					pLogEntry->MinorFunction = MinjorFunction;
					pLogEntry->IopbFlag = Data->Iopb->IrpFlags | (Data->Iopb->OperationFlags << 20);
					pLogEntry->Flags = Data->Flags;
#if 0
					pLogEntry->Argument1 = Data->Iopb->Parameters.Others.Argument1;
					pLogEntry->Argument2 = Data->Iopb->Parameters.Others.Argument2;
					pLogEntry->Argument3 = Data->Iopb->Parameters.Others.Argument3;
					pLogEntry->Argument4 = Data->Iopb->Parameters.Others.Argument4;
					pLogEntry->Argument5 = Data->Iopb->Parameters.Others.Argument5;
					pLogEntry->Argument6 = Data->Iopb->Parameters.Others.Argument6;
#endif
					pLogEntry->FltParameter.Others.Argument1 = Data->Iopb->Parameters.Others.Argument1;
					pLogEntry->FltParameter.Others.Argument2 = Data->Iopb->Parameters.Others.Argument2;
					pLogEntry->FltParameter.Others.Argument3 = Data->Iopb->Parameters.Others.Argument3;
					pLogEntry->FltParameter.Others.Argument4 = Data->Iopb->Parameters.Others.Argument4;
					pLogEntry->FltParameter.Others.Argument5 = Data->Iopb->Parameters.Others.Argument5;
					pLogEntry->FltParameter.Others.Argument6 = Data->Iopb->Parameters.Others.Argument6;
					pLogEntry->NameLength = pStrFileName->Length >> 1;
					RtlCopyMemory(pLogEntry->Name, pStrFileName->Buffer, pStrFileName->Length);
					if (FileInfoSize) {
						RtlCopyMemory((PVOID)((ULONG_PTR)pLogEntry->Name + pStrFileName->Length),
							pFileOptInfo, FileInfoSize);
						ExFreePoolWithTag(pFileOptInfo, 0);
					}

					ProcmonNotifyProcessLog(pLogBuf);
					*CompletionContext = (PVOID)Seq;
					FltStatus = FLT_PREOP_SUCCESS_WITH_CALLBACK;
				}
				DerefProcessInfo(pProcessInfo);
			}

			ExFreePoolWithTag(pStrFileName, 0);
			return FltStatus;

		}else{

			//
			// Hmm. some error occurred in getting filename
			// log it
			//

			KdPrint(("procmon!%s failed to get filename", __FUNCTION__));
			//__debugbreak();
			return FLT_PREOP_SUCCESS_NO_CALLBACK;
		}
	}
	
	//
	// if monitor process exit. 
	// we need turn off the monitor driver
	//
	
	if (!gCurrentProcess){

		ProcmonProcessExitOff();
		return FLT_PREOP_SUCCESS_NO_CALLBACK;
		
	}

	return FLT_PREOP_SUCCESS_NO_CALLBACK;
	
}



VOID
ProcmonOperationStatusCallback (
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _In_ PFLT_IO_PARAMETER_BLOCK ParameterSnapshot,
    _In_ NTSTATUS OperationStatus,
    _In_ PVOID RequesterContext
    )
/*++

Routine Description:

    This routine is called when the given operation returns from the call
    to IoCallDriver.  This is useful for operations where STATUS_PENDING
    means the operation was successfully queued.  This is useful for OpLocks
    and directory change notification operations.

    This callback is called in the context of the originating thread and will
    never be called at DPC level.  The file object has been correctly
    referenced so that you can access it.  It will be automatically
    dereferenced upon return.

    This is non-pageable because it could be called on the paging path

Arguments:

    FltObjects - Pointer to the FLT_RELATED_OBJECTS data structure containing
        opaque handles to this filter, instance, its associated volume and
        file object.

    RequesterContext - The context for the completion routine for this
        operation.

    OperationStatus -

Return Value:

    The return value is the status of the operation.

--*/
{
    UNREFERENCED_PARAMETER( FltObjects );

    PT_DBG_PRINT( PTDBG_TRACE_ROUTINES,
                  ("procmon!procmonOperationStatusCallback: Entered\n") );

    PT_DBG_PRINT( PTDBG_TRACE_OPERATION_STATUS,
                  ("procmon!procmonOperationStatusCallback: Status=%08x ctx=%p IrpMj=%02x.%02x \"%s\"\n",
                   OperationStatus,
                   RequesterContext,
                   ParameterSnapshot->MajorFunction,
                   ParameterSnapshot->MinorFunction,
                   FltGetIrpName(ParameterSnapshot->MajorFunction)) );
}

FLT_POSTOP_CALLBACK_STATUS
ProcmonPostOperation (
    _Inout_ PFLT_CALLBACK_DATA Data,
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _In_opt_ PVOID CompletionContext,
    _In_ FLT_POST_OPERATION_FLAGS Flags
    )
/*++

Routine Description:

    This routine is the post-operation completion routine for this
    miniFilter.

    This is non-pageable because it may be called at DPC level.

Arguments:

    Data - Pointer to the filter callbackData that is passed to us.

    FltObjects - Pointer to the FLT_RELATED_OBJECTS data structure containing
        opaque handles to this filter, instance, its associated volume and
        file object.

    CompletionContext - The completion context set in the pre-operation routine.

    Flags - Denotes whether the completion is successful or is being drained.

Return Value:

    The return value is the status of the operation.

--*/
{
	KIRQL Irql = KeGetCurrentIrql();

	if (!FlagOn(Flags, FLTFL_POST_OPERATION_DRAINING)){
		if (Irql == DISPATCH_LEVEL){
			PFILEOPT_WORKQUEUEITEM pFileOptWorkItem = ProcmonAllocatePoolWithTag(NonPagedPool, sizeof(FILEOPT_WORKQUEUEITEM), 'I');
			if (pFileOptWorkItem){
				pFileOptWorkItem->WorkItem.Parameter = pFileOptWorkItem;
				pFileOptWorkItem->WorkItem.List.Flink = NULL;
				pFileOptWorkItem->WorkItem.WorkerRoutine = ProcmonFilePostOptWorkerRoutine;
				pFileOptWorkItem->Thread = Data->Thread;
				pFileOptWorkItem->MajorFunction = Data->Iopb->MajorFunction;
				pFileOptWorkItem->Time = ProcmonGetTime();
				pFileOptWorkItem->IoStatus = Data->IoStatus;
				pFileOptWorkItem->CompletionContext = CompletionContext;
				pFileOptWorkItem->Flags = Data->Flags;
				ExQueueWorkItem(&pFileOptWorkItem->WorkItem, DelayedWorkQueue);
			}
		}else{			
			LARGE_INTEGER Time = {0};
			ProcmonFilePostOptRoutine(Data->Thread, Data->Iopb->MajorFunction,
				&Data->IoStatus, Data->Iopb, CompletionContext, Time, Data->Flags);
		}
	}
	if (Data->Iopb->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL && 
		Data->Iopb->Parameters.FileSystemControl.Common.FsControlCode == FSCTL_DISMOUNT_VOLUME){
		FltDetachVolume(gFilterHandle, FltObjects->Volume, NULL);
	}
		
	return FLT_POSTOP_FINISHED_PROCESSING;
}


FLT_PREOP_CALLBACK_STATUS
ProcmonPreOperationNoPostOperation (
    _Inout_ PFLT_CALLBACK_DATA Data,
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _Flt_CompletionContext_Outptr_ PVOID *CompletionContext
    )
/*++

Routine Description:

    This routine is a pre-operation dispatch routine for this miniFilter.

    This is non-pageable because it could be called on the paging path

Arguments:

    Data - Pointer to the filter callbackData that is passed to us.

    FltObjects - Pointer to the FLT_RELATED_OBJECTS data structure containing
        opaque handles to this filter, instance, its associated volume and
        file object.

    CompletionContext - The context for the completion routine for this
        operation.

Return Value:

    The return value is the status of the operation.

--*/
{
    UNREFERENCED_PARAMETER( Data );
    UNREFERENCED_PARAMETER( FltObjects );
    UNREFERENCED_PARAMETER( CompletionContext );

    PT_DBG_PRINT( PTDBG_TRACE_ROUTINES,
                  ("procmon!procmonPreOperationNoPostOperation: Entered\n") );

    // This template code does not do anything with the callbackData, but
    // rather returns FLT_PREOP_SUCCESS_NO_CALLBACK.
    // This passes the request down to the next miniFilter in the chain.

    return FLT_PREOP_SUCCESS_NO_CALLBACK;
}


BOOLEAN
procmonDoRequestOperationStatus(
    _In_ PFLT_CALLBACK_DATA Data
    )
/*++

Routine Description:

    This identifies those operations we want the operation status for.  These
    are typically operations that return STATUS_PENDING as a normal completion
    status.

Arguments:

Return Value:

    TRUE - If we want the operation status
    FALSE - If we don't

--*/
{
    PFLT_IO_PARAMETER_BLOCK iopb = Data->Iopb;

    //
    //  return boolean state based on which operations we are interested in
    //

    return (BOOLEAN)

            //
            //  Check for oplock operations
            //

             (((iopb->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL) &&
               ((iopb->Parameters.FileSystemControl.Common.FsControlCode == FSCTL_REQUEST_FILTER_OPLOCK)  ||
                (iopb->Parameters.FileSystemControl.Common.FsControlCode == FSCTL_REQUEST_BATCH_OPLOCK)   ||
                (iopb->Parameters.FileSystemControl.Common.FsControlCode == FSCTL_REQUEST_OPLOCK_LEVEL_1) ||
                (iopb->Parameters.FileSystemControl.Common.FsControlCode == FSCTL_REQUEST_OPLOCK_LEVEL_2)))

              ||

              //
              //    Check for directy change notification
              //

              ((iopb->MajorFunction == IRP_MJ_DIRECTORY_CONTROL) &&
               (iopb->MinorFunction == IRP_MN_NOTIFY_CHANGE_DIRECTORY))
             );
}

VOID 
EnableLogger(
	_In_ BOOLEAN bEnable
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	if (bEnable){
		KeQuerySystemTime(&gMonitorStartTime);
		gMonitorStartCounter = KeQueryPerformanceCounter(&gPerformanceFrequency);
		KeCancelTimer(&gTimerProcessLogData);
		gbReady = FALSE;
		gbFinish = FALSE;

	}else{

		PLIST_ENTRY pEntry;
		ExAcquireFastMutex(&gMutexLogList);
		for (pEntry = gLogListHead.Flink; 
			gLogListHead.Flink != &gLogListHead; 
			pEntry = gLogListHead.Flink)
		{
			PLOG_BUFFER pLogBuffer = CONTAINING_RECORD(pEntry, LOG_BUFFER, List);
			//RemoveEntryList(&gLogListHead);
			RemoveHeadList(&gLogListHead);
			ExFreeToNPagedLookasideList(&gNPagedLooksideListLogBuffer, pLogBuffer);

		}
		ExReleaseFastMutex(&gMutexLogList);
	}
}

VOID 
EnableExtLogEvent(
	UCHAR Flags)
{
	if (gProcmonExternalLoggerEnabledEvent){
		if (Flags)
			KeSetEvent(gProcmonExternalLoggerEnabledEvent, 0, FALSE);
		else
			KeClearEvent(gProcmonExternalLoggerEnabledEvent);
	}
}

#define PROCMON_ENBALE_PROCESS_MON			1
#define PROCMON_ENBALE_FILE_MON				2
#define PROCMON_ENBALE_REG_MON				4
#define PROCMON_ENBALE_REG_MON1				8
#define PROCMON_ENBALE_EXTLOG_EVENT			0x10

VOID 
ProcmonControlProcMonitor(
	_In_ ULONG Flags
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	if (Flags)
		EnableLogger(TRUE);
	EnableProcessMonitor(Flags & 1);
	EnableRegMonitor(Flags & 0xC);
	if (Flags & 2)
		EnableFileMonitor(TRUE);
	EnableExtLogEvent(Flags & 0x10);
	if (!Flags)
		EnableLogger(FALSE);
	gFlags = Flags;
}

VOID 
ProcmonProcessExitOff(
	VOID
)
/*++

Routine Description:

    .

Arguments:

	 None

Return Value:

	None

--*/
{
	if (gFlags){
		ProcmonCollectProcessAndSystemPerformanceData();
		SetMessageProcessor(ProcmonWriteToPbmFile);
		KeWaitForSingleObject(&gEventFileWriteFiled, 0, 0, 0, NULL);
		ProcmonControlProcMonitor(0);
	}
}
```

`kernel/procmon.inf`:

```inf
;;;
;;; procmon
;;;

[Version]
Signature   = "$Windows NT$"
; TODO - Change the Class and ClassGuid to match the Load Order Group value, see https://msdn.microsoft.com/en-us/windows/hardware/gg462963
; Class       = "ActivityMonitor"                         ;This is determined by the work this filter driver does
; ClassGuid   = {b86dff51-a31e-4bac-b3cf-e8cfe75c9fc2}    ;This value is determined by the Load Order Group value
Class = "_TODO_Change_Class_appropriately_"
ClassGuid = {_TODO_Change_ClassGuid_appropriately_}
Provider    = %ManufacturerName%
DriverVer   = 
CatalogFile = procmon.cat

[DestinationDirs]
DefaultDestDir          = 12
MiniFilter.DriverFiles  = 12            ;%windir%\system32\drivers

;;
;; Default install sections
;;

[DefaultInstall]
OptionDesc          = %ServiceDescription%
CopyFiles           = MiniFilter.DriverFiles

[DefaultInstall.Services]
AddService          = %ServiceName%,,MiniFilter.Service

;;
;; Default uninstall sections
;;

[DefaultUninstall]
DelFiles   = MiniFilter.DriverFiles

[DefaultUninstall.Services]
DelService = %ServiceName%,0x200      ;Ensure service is stopped before deleting

;
; Services Section
;

[MiniFilter.Service]
DisplayName      = %ServiceName%
Description      = %ServiceDescription%
ServiceBinary    = %12%\%DriverName%.sys        ;%windir%\system32\drivers\
Dependencies     = "FltMgr"
ServiceType      = 2                            ;SERVICE_FILE_SYSTEM_DRIVER
StartType        = 3                            ;SERVICE_DEMAND_START
ErrorControl     = 1                            ;SERVICE_ERROR_NORMAL
; TODO - Change the Load Order Group value
; LoadOrderGroup = "FSFilter Activity Monitor"
LoadOrderGroup = "_TODO_Change_LoadOrderGroup_appropriately_"
AddReg           = MiniFilter.AddRegistry

;
; Registry Modifications
;

[MiniFilter.AddRegistry]
HKR,,"DebugFlags",0x00010001 ,0x0
HKR,,"SupportedFeatures",0x00010001,0x3
HKR,"Instances","DefaultInstance",0x00000000,%DefaultInstance%
HKR,"Instances\"%Instance1.Name%,"Altitude",0x00000000,%Instance1.Altitude%
HKR,"Instances\"%Instance1.Name%,"Flags",0x00010001,%Instance1.Flags%

;
; Copy Files
;

[MiniFilter.DriverFiles]
%DriverName%.sys

[SourceDisksFiles]
procmon.sys = 1,,

[SourceDisksNames]
1 = %DiskId1%,,,

;;
;; String Section
;;

[Strings]
; TODO - Add your manufacturer
ManufacturerName        = "Template"
ServiceDescription      = "procmon Mini-Filter Driver"
ServiceName             = "procmon"
DriverName              = "procmon"
DiskId1                 = "procmon Device Installation Disk"

;Instances specific information.
DefaultInstance         = "procmon Instance"
Instance1.Name          = "procmon Instance"
; TODO - Change the altitude value, see https://msdn.microsoft.com/en-us/windows/hardware/drivers/ifs/load-order-groups-and-altitudes-for-minifilter-drivers
Instance1.Altitude       = "_TODO_Change_Altitude_appropriately_"
Instance1.Flags         = 0x0              ; Allow all attachments

```

`kernel/procmon.rc`:

```rc
#include <windows.h>

#include <ntverp.h>

#define VER_FILETYPE    VFT_DRV
#define VER_FILESUBTYPE VFT2_DRV_SYSTEM
#define VER_FILEDESCRIPTION_STR     "procmon Filter Driver"
#define VER_INTERNALNAME_STR        "procmon.sys"

#include "common.ver"

```

`kernel/procmon.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="file.c" />
    <ClCompile Include="globals.c" />
    <ClCompile Include="process.c" />
    <ClCompile Include="reg.c" />
    <ClCompile Include="utils.c" />
    <ResourceCompile Include="procmon.rc" />
    <ClCompile Include="log.c" />
    <ClCompile Include="procmon.c" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{A7878490-3B63-4BD7-B369-19BBC19DD3E8}</ProjectGuid>
    <TemplateGuid>{f2f62967-0815-4fd7-9b86-6eedcac766eb}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>procmon</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Link>
      <AdditionalDependencies>fltmgr.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Link>
      <AdditionalDependencies>fltmgr.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>fltmgr.lib;wdmsec.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalOptions>/INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>fltmgr.lib;wdmsec.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <Link>
      <AdditionalDependencies>fltmgr.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <Link>
      <AdditionalDependencies>fltmgr.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <AdditionalDependencies>fltmgr.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <AdditionalDependencies>fltmgr.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="file.h" />
    <ClInclude Include="globals.h" />
    <ClInclude Include="log.h" />
    <ClInclude Include="logsdk.h" />
    <ClInclude Include="ntheader.h" />
    <ClInclude Include="process.h" />
    <ClInclude Include="reg.h" />
    <ClInclude Include="utils.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`kernel/procmon.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="procmon.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="log.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="utils.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="file.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="reg.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="process.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="globals.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="procmon.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="log.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ntheader.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="file.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="reg.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="process.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="globals.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="logsdk.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`kernel/procmon.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`kernel/reg.c`:

```c

#include "reg.h"
#include "globals.h"
#include "utils.h"
#include "log.h"
#include "process.h"


BOOLEAN gbRegCallbackSet;
LARGE_INTEGER gCookie;
PAGED_LOOKASIDE_LIST gLookasideRegPostInfo;
KMUTEX gMutexRegPostInfo;
LIST_ENTRY gRegPostInfoList;
KMUTEX gMutexRegObjectList;
LIST_ENTRY gRegObjectList;

FNCmRegisterCallback fnCmRegisterCallback;
FNCmRegisterCallbackEx fnCmRegisterCallbackEx;
FNCmUnRegisterCallback fnCmUnRegisterCallback;
FNCmCallbackGetKeyObjectID fnCmCallbackGetKeyObjectID;

UNICODE_STRING gUniStrDefault;
UNICODE_STRING gUniStrInsufficentRef;
UNICODE_STRING gUniRegistry;
UNICODE_STRING gUniInvalidName;

VOID
ProcmonAddToPrePostList(
	_In_ ULONG RecordSequence,
	_In_ PVOID pRegData
)
{
	PREG_POST_INFO pRegPostInfo;

	pRegPostInfo = (PREG_POST_INFO)ExAllocateFromPagedLookasideList(&gLookasideRegPostInfo);
	if (pRegPostInfo) {
		pRegPostInfo->pRegData = pRegData;
		pRegPostInfo->Thread = KeGetCurrentThread();
		pRegPostInfo->Seq = RecordSequence;

		KeWaitForSingleObject(&gMutexRegPostInfo, 0, 0, 0, NULL);
		InsertHeadList(&gRegPostInfoList, &pRegPostInfo->List);
		KeReleaseMutex(&gMutexRegPostInfo, FALSE);
	}
}

PREG_POST_INFO
ProcmonRegGetPrePostInfo(
	VOID
)
{
	PREG_POST_INFO pRegPostInfo = NULL;
	PETHREAD Thread = KeGetCurrentThread();

	KeWaitForSingleObject(&gMutexRegPostInfo, 0, 0, 0, NULL);
	if (!IsListEmpty(&gRegPostInfoList)) {
		PLIST_ENTRY pEntry;

		for (pEntry = gRegPostInfoList.Flink;
			pEntry != &gRegPostInfoList;
			pEntry = pEntry->Flink)
		{
			PREG_POST_INFO pRegPostInfoTemp = CONTAINING_RECORD(pEntry, REG_POST_INFO, List);
			if (pRegPostInfoTemp->Thread == Thread) {
				pRegPostInfo = pRegPostInfoTemp;
				break;
			}
		}

		if (pRegPostInfo) {
			RemoveEntryList(pEntry);
		}
	}
	KeReleaseMutex(&gMutexRegPostInfo, FALSE);
	return pRegPostInfo;
}

VOID
ProcmonFreePostInfo(
	_In_ PREG_POST_INFO pPostInfo
)
{
	ExFreeToPagedLookasideList(&gLookasideRegPostInfo, pPostInfo);
}

VOID
ProcmonRegAddObjectNameToList(
	_In_ PVOID Object,
	_In_ PUNICODE_STRING pUniStrObjectName
)
{
	BOOLEAN bFind = FALSE;
	PREG_OBJECT_INFO pObjectNameInfo;

	KeWaitForSingleObject(&gMutexRegObjectList, 0, 0, 0, NULL);

	if (!IsListEmpty(&gRegObjectList)) {

		//
		// Try to find the object
		//

		PLIST_ENTRY pEntry;
		for (pEntry = gRegObjectList.Flink;
			pEntry != &gRegObjectList;
			pEntry = pEntry->Flink)
		{
			pObjectNameInfo = CONTAINING_RECORD(pEntry, REG_OBJECT_INFO, List);
			if (pObjectNameInfo->Object == Object) {
				bFind = TRUE;
				if (pObjectNameInfo->Name != pUniStrObjectName) {
					ExFreePoolWithTag(pUniStrObjectName, 0);
				}
				break;
			}
		}
	}

	if (!bFind) {

		//
		// Allocate a new buffer to save the object
		//

		pObjectNameInfo = (PREG_OBJECT_INFO)ProcmonAllocatePoolWithTag(NonPagedPool, sizeof(REG_OBJECT_INFO), '4');
		if (pObjectNameInfo) {
			pObjectNameInfo->Object = Object;
			pObjectNameInfo->Name = pUniStrObjectName;

			InsertHeadList(&gRegObjectList, &pObjectNameInfo->List);
		}
	}

	KeReleaseMutex(&gMutexRegObjectList, 0);

}

PUNICODE_STRING
ProcmonRegFindObjectNameFromList(
	_In_ PVOID Object
)
{
	PLIST_ENTRY pEntry;
	PUNICODE_STRING pRet = NULL;

	if (!Object){
		return NULL;
	}

	KeWaitForSingleObject(&gMutexRegObjectList, 0, 0, 0, NULL);

	for (pEntry = gRegObjectList.Flink;
		pEntry != &gRegObjectList;
		pEntry = pEntry->Flink)
	{
		PREG_OBJECT_INFO pRegObjInfo = CONTAINING_RECORD(pEntry, REG_OBJECT_INFO, List);
		if (pRegObjInfo->Object == Object) {
			pRet = pRegObjInfo->Name;
			break;
		}
	}
	KeReleaseMutex(&gMutexRegObjectList, 0);

	return NULL;
}

PUNICODE_STRING
ProcmonRegFindObjectNameFromListByNotifyType(
	_In_ USHORT NotifyType,
	_In_ PVOID Object
)
{
	PLIST_ENTRY pEntry;
	PREG_OBJECT_INFO pRegObjInfo = NULL;
	PUNICODE_STRING pRet = NULL;

	KeWaitForSingleObject(&gMutexRegObjectList, 0, 0, 0, NULL);

	for (pEntry = gRegObjectList.Flink;
		pEntry != &gRegObjectList;
		pEntry = pEntry->Flink)
	{
		PREG_OBJECT_INFO pRegObjInfoTmp = CONTAINING_RECORD(pEntry, REG_OBJECT_INFO, List);
		if (pRegObjInfoTmp->Object == Object) {
			pRegObjInfo = pRegObjInfoTmp;
			break;
		}
	}

	if (pRegObjInfo){
		pRet = pRegObjInfo->Name;
		if (NotifyType == NOTIFY_REG_KEYHANDLECLOSE) {
			RemoveEntryList(pEntry);
			ExFreePoolWithTag(pRegObjInfo, 0);
		}
	}

	KeReleaseMutex(&gMutexRegObjectList, 0);

	return pRet;
}

LONG CleanUpAllRegPostInfoList()
{
	PLIST_ENTRY pEntry;

	KeWaitForSingleObject(&gMutexRegPostInfo, 0, 0, 0, NULL);
	for (pEntry = gRegPostInfoList.Flink;
		gRegPostInfoList.Flink != &gRegPostInfoList;
		pEntry = gRegPostInfoList.Flink)
	{

		PREG_POST_INFO pRegPostInfo = CONTAINING_RECORD(pEntry, REG_POST_INFO, List);
		RemoveHeadList(&gRegPostInfoList);
		//RemoveEntryList(pEntry);

		ExFreePoolWithTag(pRegPostInfo, 0);
	}
	return KeReleaseMutex(&gMutexRegPostInfo, 0);
}

LONG CleanupRegObjectList()
{
	PLIST_ENTRY pEntry;

	KeWaitForSingleObject(&gMutexRegObjectList, 0, 0, 0, NULL);
	for (pEntry = gRegObjectList.Flink;
		gRegObjectList.Flink != &gRegObjectList;
		pEntry = gRegObjectList.Flink)
	{
		PREG_OBJECT_INFO pRegObjInfo = CONTAINING_RECORD(pEntry, REG_OBJECT_INFO, List);
		RemoveHeadList(&gRegPostInfoList);
		ExFreePoolWithTag(pRegObjInfo->Name, 0);
		ExFreePoolWithTag(pRegObjInfo, 0);
	}
	return KeReleaseMutex(&gMutexRegObjectList, 0);
}

USHORT
ProcmonGetTypeMaxSize(
	_In_ ULONG Type,
	_In_ PVOID Data,
	_In_ ULONG DataSize
)
{
	USHORT MaxSize;

	UNREFERENCED_PARAMETER(Data);

	switch (Type)
	{
	case REG_NONE:
	case REG_BINARY:
		MaxSize = 0x10;
		if (DataSize < 0x10)
			MaxSize = (USHORT)DataSize;
		break;
	case REG_SZ:
	case REG_EXPAND_SZ:
	case REG_MULTI_SZ:
		MaxSize = 0x800;
		if (DataSize < 0x800)
			MaxSize = (USHORT)DataSize;
		break;
	case REG_DWORD:
		MaxSize = 4;
		break;
	case REG_QWORD:
		MaxSize = 8;
		break;
	default:
		MaxSize = 0;
		break;
	}
	return MaxSize;
}

PUNICODE_STRING
ProcmonQueryObjectFullNameByObject(
	_In_ BOOLEAN bDefaultToNull,
	_In_ PVOID Object,
	_In_ PUNICODE_STRING ValueName
)
{
	NTSTATUS Status;
	PUNICODE_STRING pUniStrObjectName = NULL;
	PUNICODE_STRING pUniStrValueName = NULL;
	PUNICODE_STRING pUniStrFullName = NULL;

	if (ValueName) {

		
// 		try{
// 			if (ValueName->Length) {
// 				pUniStrValueName = ValueName;
// 			}else {
// 				pUniStrValueName = bDefaultToNull ? NULL : &gUniStrDefault;
// 			}
// 		}except(EXCEPTION_EXECUTE_HANDLER){
// 			pUniStrValueName = &gUniInvalidName;
// 		}

		try{
			if (ValueName->Length) {
				pUniStrValueName = ProcmonDuplicateUnicodeString(NonPagedPool, ValueName, 'R');
			}else{
				pUniStrValueName = bDefaultToNull ? NULL : &gUniStrDefault;
			}
		}except(EXCEPTION_EXECUTE_HANDLER){
			pUniStrValueName = &gUniInvalidName;
		}

	}

	if (Object) {

		if (fnCmCallbackGetKeyObjectID) {
			Status = fnCmCallbackGetKeyObjectID(&gCookie, Object, NULL, &pUniStrObjectName);
			if (NT_SUCCESS(Status)) {
				ULONG Length = pUniStrObjectName->Length + sizeof(UNICODE_STRING);
				if (pUniStrValueName) {
					Length += pUniStrValueName->Length + 4;
				}

				pUniStrFullName = (PUNICODE_STRING)ProcmonAllocatePoolWithTag(NonPagedPool, Length, 'D');
				if (pUniStrFullName) {
					pUniStrFullName->Length = 0;
					pUniStrFullName->MaximumLength = (USHORT)Length - sizeof(UNICODE_STRING);
					pUniStrFullName->Buffer = (PWCH)(pUniStrFullName + 1);

					//
					// Copy the object name to full name
					//

					RtlCopyUnicodeString(pUniStrFullName, pUniStrObjectName);
				}
			}
		}else{
			POBJECT_NAME_INFORMATION pObjNameInfo;
			ULONG ReturnLength;
			ULONG Length;
			Status = ObQueryNameString(Object, NULL, 0, &ReturnLength);
			if (Status == STATUS_INFO_LENGTH_MISMATCH) {
				Length = ReturnLength;
				if (pUniStrValueName) {
					Length += pUniStrValueName->Length + 4;
				}

				pObjNameInfo = (POBJECT_NAME_INFORMATION)ProcmonAllocatePoolWithTag(NonPagedPool, Length, 'D');
				if (pObjNameInfo) {
					pUniStrFullName = &pObjNameInfo->Name;
					Status = ObQueryNameString(Object, pObjNameInfo, ReturnLength, &ReturnLength);
					if (NT_SUCCESS(Status)) {
						if (pUniStrValueName) {
							pUniStrFullName->MaximumLength = (USHORT)Length;
						}
					}else{
						ExFreePoolWithTag(pObjNameInfo, 0);
						pUniStrFullName = &gUniStrInsufficentRef;
					}
				}
			}
		}

		if (pUniStrFullName && !RtlCompareUnicodeString(pUniStrFullName, &gUniRegistry, TRUE)) {
			if (pUniStrFullName != &gUniStrInsufficentRef)
				ExFreePoolWithTag(pUniStrFullName, 0);
			pUniStrFullName = NULL;
		}
	}

	if (pUniStrValueName) {
		if (pUniStrFullName) {
			if (pUniStrFullName != &gUniStrInsufficentRef) {
				UNICODE_STRING UniStrBackslash;
				RtlInitUnicodeString(&UniStrBackslash, L"\\");
				RtlAppendUnicodeStringToString(pUniStrFullName, &UniStrBackslash);
				RtlAppendUnicodeStringToString(pUniStrFullName, pUniStrValueName);
			}
		}
		else
		{
			PUNICODE_STRING pUniName = (PUNICODE_STRING)ProcmonAllocatePoolWithTag(NonPagedPool,
				pUniStrValueName->Length + 0x10, 'E');
			if (pUniName) {
				pUniName->Buffer = (PWCH)(pUniName + 1);
				pUniName->MaximumLength = pUniStrValueName->Length;
				RtlCopyUnicodeString(pUniName, pUniStrValueName);

				pUniStrFullName = pUniName;
			}else {
				pUniStrFullName = &gUniStrInsufficentRef;
			}
		}
	}

	if (!pUniStrFullName) {
		pUniStrFullName = &gUniInvalidName;
	}

	if (pUniStrFullName->Buffer) {
		if (!pUniStrValueName && pUniStrFullName->Buffer[(pUniStrFullName->Length >> 1) - 1] == L'\\') {
			pUniStrFullName->Length -= sizeof(WCHAR);
		}
	}

	if (pUniStrValueName && pUniStrValueName != &gUniInvalidName && pUniStrValueName != &gUniStrDefault) {
		ExFreePoolWithTag(pUniStrValueName, 0);
	}

	return pUniStrFullName;
}


PUNICODE_STRING
ProcmonQueryObjectFullName(
	_In_ BOOLEAN bDefaultToNull,
	_In_ HANDLE Handle,
	_In_ PVOID Object,
	_In_ PUNICODE_STRING ValueName
)
{
	PUNICODE_STRING pUniStrObjName;
	if (Handle) {
		Object = ObReferenceObjectByHandleSafe(Handle);
	}

	pUniStrObjName = ProcmonQueryObjectFullNameByObject(bDefaultToNull, Object, ValueName);

	if (Handle && Object) {
		ObDereferenceObject(Object);
	}

	return pUniStrObjName;
}

LONG
ProcmonNotifyRegSetValueKey(
	_In_ HANDLE Handle,
	_In_ PVOID Object,
	_In_ PUNICODE_STRING ValueName,
	_In_ ULONG TitleIndex,
	_In_ ULONG Type,
	_In_ PVOID Data,
	_In_ ULONG DataSize
)
{
	PUNICODE_STRING pUniStrObjName = NULL;
	PVOID pDataCopy = NULL;
	LONG Seq = -1;
	BOOLEAN bNameFind = FALSE;
	PLOG_REG_SETVALUEKEY pRegLogSetValueKey = NULL;
	PLOG_BUFFER pLogBuf = NULL;

	UNREFERENCED_PARAMETER(TitleIndex);

	USHORT CopySize = ProcmonGetTypeMaxSize(Type, Data, DataSize);
	if (CopySize) {
		CopySize = (USHORT)ProcmonDuplicateUserBuffer(Data, CopySize, &pDataCopy);
	}

	if (gFlags & 0xc) {
		PPROCESSINFO_LIST pProcessInfo = RefProcessInfo(PsGetCurrentProcessId(), TRUE);
		if (pProcessInfo) {
			if (Object) {

				//
				// Find Object name from list
				//

				pUniStrObjName = ProcmonRegFindObjectNameFromList(Object);
			}

			if (pUniStrObjName) {
				bNameFind = TRUE;
			}else{

				//
				// Try to query Object name
				//

				pUniStrObjName = ProcmonQueryObjectFullName(FALSE, Handle, Object, ValueName);
			}

			if (pUniStrObjName) {
				ULONG LogBufSize = pUniStrObjName->Length + CopySize + sizeof(LOG_REG_SETVALUEKEY);
				pRegLogSetValueKey = (PLOG_REG_SETVALUEKEY)ProcmonGetLogEntryAndSeq(
					TRUE,
					MONITOR_TYPE_REG,
					NOTIFY_REG_SETVALUEKEY,
					pProcessInfo->Seq,
					STATUS_PENDING,
					LogBufSize,
					&Seq,
					&pLogBuf);

				if (pRegLogSetValueKey) {
					pRegLogSetValueKey->KeyNameLength = pUniStrObjName->Length >> 1;
					RtlCopyMemory(pRegLogSetValueKey + 1, pUniStrObjName->Buffer, pUniStrObjName->Length);
				}

				if (!bNameFind && pUniStrObjName != &gUniInvalidName && pUniStrObjName != &gUniStrInsufficentRef) {
					ExFreePoolWithTag(pUniStrObjName, 0);
				}
			}

			DerefProcessInfo(pProcessInfo);
			if (pRegLogSetValueKey) {
				pRegLogSetValueKey->Type = Type;
				pRegLogSetValueKey->DataSize = DataSize;
				pRegLogSetValueKey->CopySize = 0;
				if (CopySize) {
					PVOID pLogBufEnd = (PVOID)((ULONG_PTR)pRegLogSetValueKey + sizeof(LOG_REG_SETVALUEKEY) +
						sizeof(WCHAR) * pRegLogSetValueKey->KeyNameLength);
					if (pDataCopy) {
						pRegLogSetValueKey->CopySize = CopySize;
						RtlCopyMemory(pLogBufEnd, pDataCopy, CopySize);
					}
					else {
						RtlZeroMemory(pLogBufEnd, CopySize);
					}
				}
				ProcmonNotifyProcessLog(pLogBuf);
			}
		}
	}

	if (pDataCopy) {
		ExFreePoolWithTag(pDataCopy, 0);
	}

	return Seq;
}

LONG
ProcmonNotifyRegDeleteValueKey(
	_In_ HANDLE Handle,
	_In_ PVOID Object,
	_In_ PUNICODE_STRING ValueName
)
{
	PUNICODE_STRING pUniStrObjName = NULL;
	LONG Seq = -1;
	BOOLEAN bNameFind = FALSE;
	PLOG_REG_DELETEVALUEKEY pRegLogDeleteValueKey = NULL;
	PLOG_BUFFER pLogBuf = NULL;

	if (gFlags & 0xc) {
		PPROCESSINFO_LIST pProcessInfo = RefProcessInfo(PsGetCurrentProcessId(), TRUE);
		if (pProcessInfo) {
			if (Object) {

				//
				// Find Object name from list
				//

				pUniStrObjName = ProcmonRegFindObjectNameFromList(Object);
			}

			if (pUniStrObjName) {
				bNameFind = TRUE;
			}
			else {

				//
				// Try to query Object name
				//

				pUniStrObjName = ProcmonQueryObjectFullName(FALSE, Handle, Object, ValueName);
			}

			if (pUniStrObjName) {
				ULONG LogBufSize = pUniStrObjName->Length + sizeof(LOG_REG_DELETEVALUEKEY);
				pRegLogDeleteValueKey = (PLOG_REG_DELETEVALUEKEY)ProcmonGetLogEntryAndSeq(
					TRUE,
					MONITOR_TYPE_REG,
					NOTIFY_REG_DELETEVALUEKEY,
					pProcessInfo->Seq,
					STATUS_PENDING,
					LogBufSize,
					&Seq,
					&pLogBuf);

				if (pRegLogDeleteValueKey) {
					pRegLogDeleteValueKey->KeyNameLength = pUniStrObjName->Length >> 1;
					RtlCopyMemory(pRegLogDeleteValueKey + 1, pUniStrObjName->Buffer, pUniStrObjName->Length);
				}

				if (!bNameFind && pUniStrObjName != &gUniInvalidName && pUniStrObjName != &gUniStrInsufficentRef) {
					ExFreePoolWithTag(pUniStrObjName, 0);
				}
			}

			DerefProcessInfo(pProcessInfo);
			if (pRegLogDeleteValueKey) {
				ProcmonNotifyProcessLog(pLogBuf);
			}
		}
	}

	return Seq;
}

LONG
ProcmonNotifyRegSetInformationKey(
	_In_ HANDLE Handle,
	_In_ PVOID Object,
	_In_ KEY_SET_INFORMATION_CLASS KeySetInformationClass,
	_In_ PVOID KeySetInformation,
	_In_ ULONG KeySetInformationLength
)
{
	PUNICODE_STRING pUniStrObjName = NULL;
	PVOID pDataCopy = NULL;
	LONG Seq = -1;
	BOOLEAN bNameFind = FALSE;
	PLOG_REG_SETINFORMATIONKEY pRegOptInfo = NULL;
	PLOG_BUFFER pLogBuf = NULL;
	USHORT CopySize = 0;

	if (KeySetInformationClass == KeyWriteTimeInformation) {
		CopySize = sizeof(KEY_WRITE_TIME_INFORMATION);
	}
	else if (KeySetInformationClass == KeyWow64FlagsInformation) {
		CopySize = sizeof(ULONG);
	}

	if (CopySize) {
		CopySize = (USHORT)ProcmonDuplicateUserBuffer(KeySetInformation, CopySize, &pDataCopy);
	}

	if (gFlags & 0xc) {
		PPROCESSINFO_LIST pProcessInfo = RefProcessInfo(PsGetCurrentProcessId(), TRUE);
		if (pProcessInfo) {
			if (Object) {

				//
				// Find Object name from list
				//

				pUniStrObjName = ProcmonRegFindObjectNameFromList(Object);
			}

			if (pUniStrObjName) {
				bNameFind = TRUE;
			}
			else {

				//
				// Try to query Object name
				//

				pUniStrObjName = ProcmonQueryObjectFullName(FALSE, Handle, Object, NULL);
			}

			if (pUniStrObjName) {
				ULONG LogBufSize = pUniStrObjName->Length + CopySize + sizeof(LOG_REG_SETINFORMATIONKEY);
				pRegOptInfo = (PLOG_REG_SETINFORMATIONKEY)ProcmonGetLogEntryAndSeq(
					TRUE,
					MONITOR_TYPE_REG,
					NOTIFY_REG_SETINFORMATIONKEY,
					pProcessInfo->Seq,
					STATUS_PENDING,
					LogBufSize,
					&Seq,
					&pLogBuf);

				if (pRegOptInfo) {
					pRegOptInfo->KeyNameLength = pUniStrObjName->Length >> 1;
					RtlCopyMemory(pRegOptInfo + 1, pUniStrObjName->Buffer, pUniStrObjName->Length);
				}

				if (!bNameFind && pUniStrObjName != &gUniInvalidName && pUniStrObjName != &gUniStrInsufficentRef) {
					ExFreePoolWithTag(pUniStrObjName, 0);
				}
			}

			DerefProcessInfo(pProcessInfo);
			if (pRegOptInfo) {
				pRegOptInfo->KeySetInformationClass = KeySetInformationClass;
				pRegOptInfo->KeySetInformationLength = KeySetInformationLength;
				pRegOptInfo->CopySize = 0;
				if (CopySize) {
					PVOID pLogBufEnd = (PVOID)((ULONG_PTR)pRegOptInfo + sizeof(LOG_REG_SETINFORMATIONKEY) +
						sizeof(WCHAR) * pRegOptInfo->KeyNameLength);
					if (pDataCopy) {
						pRegOptInfo->CopySize = CopySize;
						RtlCopyMemory(pLogBufEnd, pDataCopy, CopySize);
					}
					else {
						RtlZeroMemory(pLogBufEnd, CopySize);
					}
				}
				ProcmonNotifyProcessLog(pLogBuf);
			}
		}
	}

	if (pDataCopy) {
		ExFreePoolWithTag(pDataCopy, 0);
	}

	return Seq;
}

LONG
ProcmonNotifyRegRenameKey(
	_In_ HANDLE Handle,
	_In_ PVOID Object,
	_In_ PUNICODE_STRING NewName
)
{
	PUNICODE_STRING pUniStrObjName = NULL;
	LONG Seq = -1;
	BOOLEAN bNameFind = FALSE;
	PLOG_REG_RENAMEKEY pRegOptInfo = NULL;
	PLOG_BUFFER pLogBuf = NULL;

	if (gFlags & 0xc) {
		PPROCESSINFO_LIST pProcessInfo = RefProcessInfo(PsGetCurrentProcessId(), TRUE);
		if (pProcessInfo) {
			if (Object) {

				//
				// Find Object name from list
				//

				pUniStrObjName = ProcmonRegFindObjectNameFromList(Object);
			}

			if (pUniStrObjName) {
				bNameFind = TRUE;
			}
			else {

				//
				// Try to query Object name
				//

				pUniStrObjName = ProcmonQueryObjectFullName(FALSE, Handle, Object, NULL);
			}

			if (pUniStrObjName) {
				ULONG LogBufSize = pUniStrObjName->Length + NewName->Length + sizeof(LOG_REG_RENAMEKEY);
				pRegOptInfo = (PLOG_REG_RENAMEKEY)ProcmonGetLogEntryAndSeq(
					TRUE,
					MONITOR_TYPE_REG,
					NOTIFY_REG_RENAMEKEY,
					pProcessInfo->Seq,
					STATUS_PENDING,
					LogBufSize,
					&Seq,
					&pLogBuf);

				if (pRegOptInfo) {
					pRegOptInfo->KeyNameLength = pUniStrObjName->Length >> 1;
					RtlCopyMemory(pRegOptInfo + 1, pUniStrObjName->Buffer, pUniStrObjName->Length);
				}

				if (!bNameFind && pUniStrObjName != &gUniInvalidName && pUniStrObjName != &gUniStrInsufficentRef) {
					ExFreePoolWithTag(pUniStrObjName, 0);
				}
			}

			DerefProcessInfo(pProcessInfo);
			if (pRegOptInfo) {
				PVOID pLogBufEnd;

				pRegOptInfo->NewNameLength = NewName->Length;
				pLogBufEnd = (PVOID)((ULONG_PTR)pRegOptInfo + sizeof(LOG_REG_RENAMEKEY) +
					sizeof(WCHAR) * pRegOptInfo->KeyNameLength);
				RtlCopyMemory(pLogBufEnd, NewName->Buffer, NewName->Length);

				ProcmonNotifyProcessLog(pLogBuf);
			}
		}
	}

	return Seq;
}


LONG
ProcmonNotifyRegEnumerateKey(
	_In_ HANDLE Handle,
	_In_ PVOID Object,
	_In_ ULONG Index,
	_In_ KEY_INFORMATION_CLASS KeyInformationClass,
	_In_ ULONG Length
)
{
	PUNICODE_STRING pUniStrObjName = NULL;
	LONG Seq = -1;
	BOOLEAN bNameFind = FALSE;
	PLOG_REG_ENUMERATEKEY pRegOptInfo = NULL;
	PLOG_BUFFER pLogBuf = NULL;

	if (gFlags & 0xc) {
		PPROCESSINFO_LIST pProcessInfo = RefProcessInfo(PsGetCurrentProcessId(), TRUE);
		if (pProcessInfo) {
			if (Object) {

				//
				// Find Object name from list
				//

				pUniStrObjName = ProcmonRegFindObjectNameFromList(Object);
			}

			if (pUniStrObjName) {
				bNameFind = TRUE;
			}else{

				//
				// Try to query Object name
				//

				pUniStrObjName = ProcmonQueryObjectFullName(FALSE, Handle, Object, NULL);
			}

			if (pUniStrObjName) {
				ULONG LogBufSize = pUniStrObjName->Length + sizeof(LOG_REG_ENUMERATEKEY);
				pRegOptInfo = (PLOG_REG_ENUMERATEKEY)ProcmonGetLogEntryAndSeq(
					TRUE,
					MONITOR_TYPE_REG,
					NOTIFY_REG_ENUMERATEKEY,
					pProcessInfo->Seq,
					STATUS_PENDING,
					LogBufSize,
					&Seq,
					&pLogBuf);

				if (pRegOptInfo) {
					pRegOptInfo->KeyNameLength = pUniStrObjName->Length >> 1;
					RtlCopyMemory(pRegOptInfo + 1, pUniStrObjName->Buffer, pUniStrObjName->Length);
				}

				if (!bNameFind && pUniStrObjName != &gUniInvalidName && pUniStrObjName != &gUniStrInsufficentRef) {
					ExFreePoolWithTag(pUniStrObjName, 0);
				}
			}

			DerefProcessInfo(pProcessInfo);
			if (pRegOptInfo) {
				pRegOptInfo->Index = Index;
				pRegOptInfo->KeyInformationClass = KeyInformationClass;
				pRegOptInfo->Length = Length;
				ProcmonNotifyProcessLog(pLogBuf);
			}
		}
	}

	return Seq;
}

LONG
ProcmonNotifyRegEnumerateValueKey(
	_In_ HANDLE Handle,
	_In_ PVOID Object,
	_In_ ULONG Index,
	_In_ KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
	_In_ ULONG Length
)
{
	PUNICODE_STRING pUniStrObjName = NULL;
	LONG Seq = -1;
	BOOLEAN bNameFind = FALSE;
	PLOG_REG_ENUMERATEVALUEKEY pRegOptInfo = NULL;
	PLOG_BUFFER pLogBuf = NULL;

	if (gFlags & 0xc) {
		PPROCESSINFO_LIST pProcessInfo = RefProcessInfo(PsGetCurrentProcessId(), TRUE);
		if (pProcessInfo) {
			if (Object) {

				//
				// Find Object name from list
				//

				pUniStrObjName = ProcmonRegFindObjectNameFromList(Object);
			}

			if (pUniStrObjName) {
				bNameFind = TRUE;
			}
			else {

				//
				// Try to query Object name
				//

				pUniStrObjName = ProcmonQueryObjectFullName(FALSE, Handle, Object, NULL);
			}

			if (pUniStrObjName) {
				ULONG LogBufSize = pUniStrObjName->Length + sizeof(LOG_REG_ENUMERATEVALUEKEY);
				pRegOptInfo = (PLOG_REG_ENUMERATEVALUEKEY)ProcmonGetLogEntryAndSeq(
					TRUE,
					MONITOR_TYPE_REG,
					NOTIFY_REG_ENUMERATEVALUEKEY,
					pProcessInfo->Seq,
					STATUS_PENDING,
					LogBufSize,
					&Seq,
					&pLogBuf);

				if (pRegOptInfo) {
					pRegOptInfo->KeyNameLength = pUniStrObjName->Length >> 1;
					RtlCopyMemory(pRegOptInfo + 1, pUniStrObjName->Buffer, pUniStrObjName->Length);
				}

				if (!bNameFind && pUniStrObjName != &gUniInvalidName && pUniStrObjName != &gUniStrInsufficentRef) {
					ExFreePoolWithTag(pUniStrObjName, 0);
				}
			}

			DerefProcessInfo(pProcessInfo);
			if (pRegOptInfo) {
				pRegOptInfo->Index = Index;
				pRegOptInfo->KeyValueInformationClass = KeyValueInformationClass;
				pRegOptInfo->Length = Length;
				ProcmonNotifyProcessLog(pLogBuf);
			}
		}
	}

	return Seq;
}


LONG
ProcmonNotifyRegQueryKey(
	_In_ HANDLE Handle,
	_In_ PVOID Object,
	_In_ KEY_INFORMATION_CLASS KeyInformationClass,
	_In_ ULONG Length
)
{
	PUNICODE_STRING pUniStrObjName = NULL;
	LONG Seq = -1;
	BOOLEAN bNameFind = FALSE;
	PLOG_REG_QUERYKEY pRegOptInfo = NULL;
	PLOG_BUFFER pLogBuf = NULL;

	if (gFlags & 0xc) {
		PPROCESSINFO_LIST pProcessInfo = RefProcessInfo(PsGetCurrentProcessId(), TRUE);
		if (pProcessInfo) {
			if (Object) {

				//
				// Find Object name from list
				//

				pUniStrObjName = ProcmonRegFindObjectNameFromList(Object);
			}

			if (pUniStrObjName) {
				bNameFind = TRUE;
			}
			else {

				//
				// Try to query Object name
				//

				pUniStrObjName = ProcmonQueryObjectFullName(FALSE, Handle, Object, NULL);
			}

			if (pUniStrObjName) {
				ULONG LogBufSize = pUniStrObjName->Length + sizeof(LOG_REG_QUERYKEY);
				pRegOptInfo = (PLOG_REG_QUERYKEY)ProcmonGetLogEntryAndSeq(
					TRUE,
					MONITOR_TYPE_REG,
					NOTIFY_REG_QUERYKEY,
					pProcessInfo->Seq,
					STATUS_PENDING,
					LogBufSize,
					&Seq,
					&pLogBuf);

				if (pRegOptInfo) {
					pRegOptInfo->KeyNameLength = pUniStrObjName->Length >> 1;
					RtlCopyMemory(pRegOptInfo + 1, pUniStrObjName->Buffer, pUniStrObjName->Length);
				}

				if (!bNameFind && pUniStrObjName != &gUniInvalidName && pUniStrObjName != &gUniStrInsufficentRef) {
					ExFreePoolWithTag(pUniStrObjName, 0);
				}
			}

			DerefProcessInfo(pProcessInfo);
			if (pRegOptInfo) {
				pRegOptInfo->KeyInformationClass = KeyInformationClass;
				pRegOptInfo->Length = Length;
				ProcmonNotifyProcessLog(pLogBuf);
			}
		}
	}

	return Seq;
}

LONG
ProcmonNotifyRegQueryValueKey(
	_In_ HANDLE Handle,
	_In_ PVOID Object,
	_In_ PUNICODE_STRING ValueName,
	_In_ KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
	_In_ ULONG Length
)
{
	PUNICODE_STRING pUniStrObjName = NULL;
	LONG Seq = -1;
	BOOLEAN bNameFind = FALSE;
	PLOG_REG_QUERYVALUEKEY pRegOptInfo = NULL;
	PLOG_BUFFER pLogBuf = NULL;

	if (gFlags & 0xc) {
		PPROCESSINFO_LIST pProcessInfo = RefProcessInfo(PsGetCurrentProcessId(), TRUE);
		if (pProcessInfo) {
			if (Object) {

				//
				// Find Object name from list
				//

				pUniStrObjName = ProcmonRegFindObjectNameFromList(Object);
			}

			if (pUniStrObjName) {
				bNameFind = TRUE;
			}
			else {

				//
				// Try to query Object name
				//

				pUniStrObjName = ProcmonQueryObjectFullName(FALSE, Handle, Object, ValueName);
			}

			if (pUniStrObjName) {
				ULONG LogBufSize = pUniStrObjName->Length + sizeof(LOG_REG_QUERYVALUEKEY);
				pRegOptInfo = (PLOG_REG_QUERYVALUEKEY)ProcmonGetLogEntryAndSeq(
					TRUE,
					MONITOR_TYPE_REG,
					NOTIFY_REG_QUERYVALUEKEY,
					pProcessInfo->Seq,
					STATUS_PENDING,
					LogBufSize,
					&Seq,
					&pLogBuf);

				if (pRegOptInfo) {
					pRegOptInfo->KeyNameLength = pUniStrObjName->Length >> 1;
					RtlCopyMemory(pRegOptInfo + 1, pUniStrObjName->Buffer, pUniStrObjName->Length);
				}

				if (!bNameFind && pUniStrObjName != &gUniInvalidName && pUniStrObjName != &gUniStrInsufficentRef) {
					ExFreePoolWithTag(pUniStrObjName, 0);
				}
			}

			DerefProcessInfo(pProcessInfo);
			if (pRegOptInfo) {
				pRegOptInfo->KeyValueInformationClass = KeyValueInformationClass;
				pRegOptInfo->Length = Length;
				ProcmonNotifyProcessLog(pLogBuf);
			}
		}
	}

	return Seq;
}


LONG
ProcmonNotifyRegLoadKey(
	_In_ PVOID Object,
	_In_ PUNICODE_STRING KeyName,
	_In_ PUNICODE_STRING SourceFile
)
{
	PUNICODE_STRING pUniStrObjName = NULL;
	LONG Seq = -1;
	PLOG_REG_LOADKEY pRegOptInfo = NULL;
	PLOG_BUFFER pLogBuf = NULL;

	PPROCESSINFO_LIST pProcessInfo = RefProcessInfo(PsGetCurrentProcessId(), TRUE);
	if (pProcessInfo) {
		if (Object)
			pUniStrObjName = ProcmonQueryObjectFullNameByObject(TRUE, Object, KeyName);
		else
			pUniStrObjName = KeyName;
		pRegOptInfo = (PLOG_REG_LOADKEY)ProcmonGetLogEntryAndSeq(TRUE, MONITOR_TYPE_REG, NOTIFY_REG_LOADKEY, pProcessInfo->Seq,
			STATUS_PENDING, pUniStrObjName->Length + SourceFile->Length + sizeof(LOG_REG_LOADKEY),
			&Seq, &pLogBuf);
		if (pRegOptInfo) {
			pRegOptInfo->KeyNameLength = pUniStrObjName->Length >> 1;
			RtlCopyMemory(pRegOptInfo + 1, pUniStrObjName->Buffer, pUniStrObjName->Length);
			pRegOptInfo->SourceFileLength = SourceFile->Length >> 1;
			RtlCopyMemory((PVOID)((ULONG_PTR)pRegOptInfo + pUniStrObjName->Length + sizeof(LOG_REG_LOADKEY)),
				SourceFile->Buffer,
				SourceFile->Length);
			ProcmonNotifyProcessLog(pLogBuf);
		}
		if (pUniStrObjName != KeyName &&
			pUniStrObjName != &gUniInvalidName &&
			pUniStrObjName != &gUniStrInsufficentRef) {
			ExFreePoolWithTag(pUniStrObjName, 0);
		}
		DerefProcessInfo(pProcessInfo);
	}
	return Seq;
}

LONG
ProcmonNotifyRegUnLoadKey(
	_In_ HANDLE Handle,
	_In_ PVOID Object
)
{
	PUNICODE_STRING pUniStrObjName = NULL;
	LONG Seq = -1;
	PLOG_REG_UNLOADKEY pRegOptInfo = NULL;
	PLOG_BUFFER pLogBuf = NULL;

	PPROCESSINFO_LIST pProcessInfo = RefProcessInfo(PsGetCurrentProcessId(), TRUE);
	if (pProcessInfo) {
		if (!Handle)
			pUniStrObjName = ProcmonQueryObjectFullNameByObject(TRUE, Object, NULL);
		pRegOptInfo = (PLOG_REG_UNLOADKEY)ProcmonGetLogEntryAndSeq(TRUE, MONITOR_TYPE_REG, NOTIFY_REG_UNLOADKEY, pProcessInfo->Seq,
			STATUS_PENDING, pUniStrObjName->Length + sizeof(LOG_REG_UNLOADKEY),
			&Seq, &pLogBuf);
		if (pRegOptInfo) {
			pRegOptInfo->KeyNameLength = pUniStrObjName->Length >> 1;
			RtlCopyMemory(pRegOptInfo + 1, pUniStrObjName->Buffer, pUniStrObjName->Length);
			ProcmonNotifyProcessLog(pLogBuf);
		}
		if (pUniStrObjName != &gUniInvalidName &&
			pUniStrObjName != &gUniStrInsufficentRef) {
			ExFreePoolWithTag(pUniStrObjName, 0);
		}
		DerefProcessInfo(pProcessInfo);
	}
	return Seq;
}

BOOLEAN
ProcmonSelfReadUnicodeString(
	_In_ PUNICODE_STRING pUniStrSrc,
	_Out_ PUNICODE_STRING pUniStrRead)
{

	try {
		if (ExGetPreviousMode() == UserMode)
		{
			ProbeForRead(pUniStrSrc, sizeof(UNICODE_STRING), 1);
			*pUniStrRead = *pUniStrSrc;
			ProbeForRead(pUniStrRead->Buffer, pUniStrRead->Length, 1u);
		}
		else {
			*pUniStrRead = *pUniStrSrc;
		}
	}
	except (EXCEPTION_EXECUTE_HANDLER) {
		*pUniStrRead = gUniInvalidName;
	}
	return TRUE;
}

BOOLEAN
ProcmonSafeReadObjectAttributes(
	_In_ POBJECT_ATTRIBUTES pObjectAttribute,
	_Out_ PHANDLE phRoot,
	_Out_ PUNICODE_STRING pObjectName)
{
	try {

		if (ExGetPreviousMode() == UserMode) {
			ProbeForRead(pObjectAttribute, sizeof(OBJECT_ATTRIBUTES), 1);
			ProcmonSelfReadUnicodeString(pObjectAttribute->ObjectName, pObjectName);
		}
		else {
			*pObjectName = *pObjectAttribute->ObjectName;
		}

		*phRoot = pObjectAttribute->RootDirectory;
	}
	except (EXCEPTION_EXECUTE_HANDLER) {
		return FALSE;
	}
	return TRUE;
}

LONG
ProcmonNotifyRegCreateOpenKeyEx(
	_In_ USHORT NotifyType,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES pObjectAttribute,
	_In_ PVOID RootObject,
	_In_ PUNICODE_STRING CompleteName
)
{
	LONG Seq = -1;
	PUNICODE_STRING pUniStrObjName = NULL;
	PLOG_BUFFER pLogBuf;
	PLOG_REG_CREATEOPENKEY pRegOptInfo = NULL;

	PPROCESSINFO_LIST pProcessInfo = RefProcessInfo(PsGetCurrentProcessId(), TRUE);
	if (!pProcessInfo) {
		return -1;
	}

	if (pObjectAttribute) {
		HANDLE hRoot;
		UNICODE_STRING ObjectName;
		PVOID Object = NULL;
		if (ProcmonSafeReadObjectAttributes(pObjectAttribute, &hRoot, &ObjectName)) {
			if (hRoot) {
				Object = ObReferenceObjectByHandleSafe(hRoot);
			}
			pUniStrObjName = ProcmonQueryObjectFullNameByObject(TRUE, Object, &ObjectName);

			if (Object) {
				ObDereferenceObject(Object);
			}
		}
	}
	else {
		pUniStrObjName = ProcmonQueryObjectFullNameByObject(TRUE, RootObject, CompleteName);
	}

	if (pUniStrObjName) {
		ULONG LogBufSize = pUniStrObjName->Length + sizeof(LOG_REG_CREATEOPENKEY);
		pRegOptInfo = (PLOG_REG_CREATEOPENKEY)ProcmonGetLogEntryAndSeq(
			TRUE,
			MONITOR_TYPE_REG,
			NotifyType,
			pProcessInfo->Seq,
			STATUS_PENDING,
			LogBufSize,
			&Seq,
			&pLogBuf);

		if (pRegOptInfo) {
			pRegOptInfo->KeyNameLength = pUniStrObjName->Length >> 1;
			pRegOptInfo->DesiredAccess = DesiredAccess;
			RtlCopyMemory(pRegOptInfo + 1, pUniStrObjName->Buffer, pUniStrObjName->Length);
			ProcmonNotifyProcessLog(pLogBuf);
		}

		if (pUniStrObjName != &gUniInvalidName && pUniStrObjName != &gUniStrInsufficentRef) {
			ExFreePoolWithTag(pUniStrObjName, 0);
		}
	}

	DerefProcessInfo(pProcessInfo);
	return Seq;

}

PVOID
ProcmonNotifyRegOptCommonInternal(
	_In_ HANDLE Handle,
	_In_ PVOID Object,
	_In_ PUNICODE_STRING ValueName,
	_In_ USHORT NotifyType,
	_In_ ULONG HeaderLength,
	_In_ ULONG ExtendLength,
	_Out_ PLOG_BUFFER* ppLogBuffer,
	_Out_ PLONG pRecordSequence
)
{
	BOOLEAN bDefaultToNull = FALSE;
	BOOLEAN bNameFind = FALSE;
	PPROCESSINFO_LIST pProcessInfo;
	PUNICODE_STRING pUniStrObjectName = NULL;
	PLOG_REG_CONNMON pRegOptInfo = NULL;

	*ppLogBuffer = NULL;


	//
	// add by progmboy
	//

	if (HeaderLength < 2) {
		return NULL;
	}

	//
	// Is register monitor closed
	//

	if (!(gFlags & 0xc)) {
		return NULL;
	}

	pProcessInfo = RefProcessInfo(PsGetCurrentProcessId(), TRUE);
	if (!pProcessInfo) {
		return NULL;
	}


	if (NotifyType <= 1 || NotifyType <= 0xd) {
		bDefaultToNull = TRUE;
	}

	pUniStrObjectName = ProcmonRegFindObjectNameFromListByNotifyType(NotifyType, Object);
	if (pUniStrObjectName) {
		bNameFind = TRUE;
	}
	else {
		pUniStrObjectName = ProcmonQueryObjectFullName(bDefaultToNull, Handle, Object, ValueName);
	}

	if (pUniStrObjectName) {
		ULONG LogBufSize = pUniStrObjectName->Length + HeaderLength + ExtendLength;
		pRegOptInfo = (PLOG_REG_CONNMON)ProcmonGetLogEntryAndSeq(
			TRUE,
			MONITOR_TYPE_REG,
			NotifyType,
			pProcessInfo->Seq,
			STATUS_PENDING,
			LogBufSize,
			pRecordSequence,
			ppLogBuffer);

		if (pRegOptInfo) {
			pRegOptInfo->KeyNameLength = pUniStrObjectName->Length >> 1;
			RtlCopyMemory((PVOID)((ULONG_PTR)pRegOptInfo + HeaderLength), pUniStrObjectName->Buffer, pUniStrObjectName->Length);
		}

		if (NotifyType == NOTIFY_REG_DELETEKEY && Object) {
			ProcmonRegAddObjectNameToList(Object, pUniStrObjectName);
		}else if ((!bNameFind || NotifyType == NOTIFY_REG_KEYHANDLECLOSE)
			&& pUniStrObjectName != &gUniInvalidName
			&& pUniStrObjectName != &gUniStrInsufficentRef) {
			ExFreePoolWithTag(pUniStrObjectName, 0);
		}
	}

	DerefProcessInfo(pProcessInfo);
	return pRegOptInfo;

}

LONG
ProcmonNotifyRegOptCommon(
	_In_ HANDLE Handle,
	_In_ PVOID Object,
	_In_ USHORT NotifyType,
	_In_ ULONG HeadLength
)
{
	PLOG_BUFFER pLogBuffer;
	LONG RecordSequence = -1;

	if (ProcmonNotifyRegOptCommonInternal(Handle, Object, NULL, NotifyType, HeadLength, 0, &pLogBuffer, &RecordSequence))
		ProcmonNotifyProcessLog(pLogBuffer);
	return RecordSequence;
}

VOID
ProcmonNotifyPostRegEnumerateKey(
	_In_ LONG Seq,
	_In_ NTSTATUS Status,
	_In_ KEY_INFORMATION_CLASS KeyInformationClass,
	_In_ PVOID KeyInformation,
	_In_ PULONG ResultLength
)
{
	PLOG_BUFFER pLogBuf = NULL;
	PVOID pLogInfo = NULL;

	UNREFERENCED_PARAMETER(KeyInformationClass);

	if (Seq == -1) {
		return;
	}

	if (!NT_SUCCESS(Status)) {
		ProcmonGetPostLogEntry(Seq, Status, 0, &pLogBuf);
	}else{
		ULONG Length;
		PVOID pBufferDup = NULL;

		try {
			Length = *ResultLength;
		}except(EXCEPTION_EXECUTE_HANDLER) {
			return;
		}

		if (Length) {
			Length = ProcmonDuplicateUserBuffer(KeyInformation, (USHORT)Length, &pBufferDup);
		}

		pLogInfo = ProcmonGetPostLogEntry(Seq, Status, Length, &pLogBuf);
		if (pLogInfo) {
			if (pBufferDup) {
				RtlCopyMemory(pLogInfo, pBufferDup, Length);
				ExFreePoolWithTag(pBufferDup, 0);
			}
			else {
				RtlZeroMemory(pLogInfo, Length);
			}
		}
	}
	if (pLogBuf) {
		ProcmonNotifyProcessLog(pLogBuf);
	}

}

USHORT
ProcmonDupQueryValueKeyInformation(
	_In_ KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
	_In_ PVOID KeyValueInformation,
	_In_ ULONG Length,
	_Out_ PVOID *ppBufferDup
)
{
	ULONG DstLength;

	UNREFERENCED_PARAMETER(Length);

	
	//
	// Kernel buffer is a user buffer we need try
	//
	
	try {
		switch (KeyValueInformationClass)
		{
		case KeyValueBasicInformation:
			DstLength = sizeof(KEY_VALUE_BASIC_INFORMATION);
			break;
		case KeyValueFullInformation:
		{
			PKEY_VALUE_FULL_INFORMATION pFullInfo = (PKEY_VALUE_FULL_INFORMATION)KeyValueInformation;
			DstLength = ProcmonGetTypeMaxSize(
				pFullInfo->Type,
				(PVOID)((ULONG_PTR)pFullInfo + pFullInfo->DataOffset),
				pFullInfo->DataLength) + pFullInfo->DataOffset;
		}
			break;
		case KeyValuePartialInformation:
		{
			PKEY_VALUE_PARTIAL_INFORMATION pPartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION)KeyValueInformation;
			DstLength = ProcmonGetTypeMaxSize(
				pPartialInfo->Type,
				&pPartialInfo->Data[0],
				pPartialInfo->DataLength) + FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data);
		}
			break;
		default:
			return 0;
		}
	}except(EXCEPTION_EXECUTE_HANDLER){
		*ppBufferDup = NULL;
		return 0;
	}


	return ProcmonDuplicateUserBuffer(KeyValueInformation, (USHORT)DstLength, ppBufferDup);
}


VOID
ProcmonNotifyPostRegEnumerateValueKey(
	_In_ LONG Seq,
	_In_ NTSTATUS Status,
	_In_ KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
	_In_ PVOID KeyValueInformation,
	_In_ PULONG ResultLength
)
{
	PLOG_BUFFER pLogBuf = NULL;

	if (Seq == -1) {
		return;
	}

	if (!NT_SUCCESS(Status)) {
		ProcmonGetPostLogEntry(Seq, Status, 0, &pLogBuf);
	}else{
		USHORT CopyLength;
		PVOID pDataDup = NULL;
		PVOID pLogInfo;
		ULONG Length;

		try {
			Length = *ResultLength;
		}except(EXCEPTION_EXECUTE_HANDLER) {
			return;
		}

		CopyLength = ProcmonDupQueryValueKeyInformation(KeyValueInformationClass, KeyValueInformation, Length, &pDataDup);
		pLogInfo = ProcmonGetPostLogEntry(Seq, Status, CopyLength, &pLogBuf);

		if (pLogInfo) {
			if (pDataDup) {
				RtlCopyMemory(pLogInfo, pDataDup, CopyLength);
				ExFreePoolWithTag(pDataDup, 0);
			}
			else {
				RtlZeroMemory(pLogInfo, CopyLength);
			}
		}
	}

	if (pLogBuf) {
		ProcmonNotifyProcessLog(pLogBuf);
	}
}

VOID
ProcmonNotifyPostRegCreateOpenKey(
	_In_ LONG Seq,
	_In_ NTSTATUS Status,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ ACCESS_MASK GrantedAccess,
	_In_ ULONG Disposition)
{
	PLOG_BUFFER pLogBuf = NULL;
	ULONG Length = 0;
	PVOID pLogInfo;

	UNREFERENCED_PARAMETER(DesiredAccess);

	if (Seq == -1) {
		return;
	}

	if (NT_SUCCESS(Status))
		Length = sizeof(LOG_REG_POSTCREATEOPENKEY);

	pLogInfo = ProcmonGetPostLogEntry(Seq, Status, Length, &pLogBuf);
	if (pLogInfo) {
		if (Length) {
			LOG_REG_POSTCREATEOPENKEY PostCreateOpenKey;
			PostCreateOpenKey.GrantedAccess = GrantedAccess;
			PostCreateOpenKey.Disposition = Disposition;

			RtlCopyMemory(pLogInfo, &PostCreateOpenKey, Length);
		}
	}

	if (pLogBuf) {
		ProcmonNotifyProcessLog(pLogBuf);
	}
}

NTSTATUS
ProcmonRegistryCallback(
	_In_      PVOID CallbackContext,
	_In_opt_  PVOID Argument1,
	_In_opt_  PVOID Argument2
)
{
	USHORT NotifyType;
	LONG Seq;
	REG_NOTIFY_CLASS RegNotifyClass = (REG_NOTIFY_CLASS)(ULONG_PTR)Argument1;
	PLOG_BUFFER pLogBuffer = NULL;

	UNREFERENCED_PARAMETER(CallbackContext);

	switch (RegNotifyClass)
	{
	case RegNtPreDeleteKey:
		NotifyType = NOTIFY_REG_DELETEKEY;
		goto __label_reg_pre_common;
	case RegNtPreSetValueKey:
	{
		PREG_SET_VALUE_KEY_INFORMATION pRegSetValueInfo = (PREG_SET_VALUE_KEY_INFORMATION)Argument2;
		Seq = ProcmonNotifyRegSetValueKey(NULL, pRegSetValueInfo->Object,
			pRegSetValueInfo->ValueName, pRegSetValueInfo->TitleIndex,
			pRegSetValueInfo->Type, pRegSetValueInfo->Data, pRegSetValueInfo->DataSize);
		ProcmonAddToPrePostList(Seq, Argument2);
	}
	break;
	case RegNtDeleteValueKey:
	{
		PREG_DELETE_VALUE_KEY_INFORMATION pRegDelKeyInfo = (PREG_DELETE_VALUE_KEY_INFORMATION)Argument2;
		Seq = ProcmonNotifyRegDeleteValueKey(NULL, pRegDelKeyInfo->Object, pRegDelKeyInfo->ValueName);
		ProcmonAddToPrePostList(Seq, Argument2);
	}
	break;

	case RegNtSetInformationKey:
	{
		PREG_SET_INFORMATION_KEY_INFORMATION pRegOptInfo = (PREG_SET_INFORMATION_KEY_INFORMATION)Argument2;
		Seq = ProcmonNotifyRegSetInformationKey(NULL, pRegOptInfo->Object, pRegOptInfo->KeySetInformationClass,
			pRegOptInfo->KeySetInformation, pRegOptInfo->KeySetInformationLength);
		ProcmonAddToPrePostList(Seq, Argument2);
	}
	break;

	case RegNtRenameKey:
	{
		PREG_RENAME_KEY_INFORMATION pRegOptInfo = (PREG_RENAME_KEY_INFORMATION)Argument2;
		Seq = ProcmonNotifyRegRenameKey(NULL, pRegOptInfo->Object, pRegOptInfo->NewName);
		ProcmonAddToPrePostList(Seq, Argument2);
	}
	break;

	case RegNtEnumerateKey:
	{
		PREG_ENUMERATE_KEY_INFORMATION pRegOptInfo = (PREG_ENUMERATE_KEY_INFORMATION)Argument2;
		Seq = ProcmonNotifyRegEnumerateKey(NULL, pRegOptInfo->Object, pRegOptInfo->Index,
			pRegOptInfo->KeyInformationClass, pRegOptInfo->Length);
		ProcmonAddToPrePostList(Seq, Argument2);
	}
	break;

	case RegNtEnumerateValueKey:
	{
		PREG_ENUMERATE_VALUE_KEY_INFORMATION pRegOptInfo = (PREG_ENUMERATE_VALUE_KEY_INFORMATION)Argument2;
		Seq = ProcmonNotifyRegEnumerateValueKey(NULL, pRegOptInfo->Object, pRegOptInfo->Index,
			pRegOptInfo->KeyValueInformationClass, pRegOptInfo->Length);
		ProcmonAddToPrePostList(Seq, Argument2);
	}
	break;

	case RegNtQueryKey:
	{
		PREG_QUERY_KEY_INFORMATION pRegOptInfo = (PREG_QUERY_KEY_INFORMATION)Argument2;
		Seq = ProcmonNotifyRegQueryKey(NULL, pRegOptInfo->Object, pRegOptInfo->KeyInformationClass,
			pRegOptInfo->Length);
		ProcmonAddToPrePostList(Seq, Argument2);
	}
	break;

	case RegNtQueryValueKey:
	{
		PREG_QUERY_VALUE_KEY_INFORMATION pRegOptInfo = (PREG_QUERY_VALUE_KEY_INFORMATION)Argument2;
		Seq = ProcmonNotifyRegQueryValueKey(NULL, pRegOptInfo->Object, pRegOptInfo->ValueName,
			pRegOptInfo->KeyValueInformationClass, pRegOptInfo->Length);
		ProcmonAddToPrePostList(Seq, Argument2);
	}
	break;

	case RegNtQueryMultipleValueKey:
		NotifyType = NOTIFY_REG_QUERYMULTIPLEVALUEKEY;
		goto __label_reg_pre_common;

	case RegNtPostOpenKey:
	case RegNtPostDeleteKey:
	case RegNtPostSetValueKey:
	case RegNtPostDeleteValueKey:
	case RegNtPostSetInformationKey:
	case RegNtPostRenameKey:
	case RegNtPostQueryMultipleValueKey:
	case RegNtPostKeyHandleClose:
	case RegNtPostFlushKey:
	case RegNtPostLoadKey:
	case RegNtPostUnLoadKey:
	case RegNtPostQueryKeySecurity:
	case RegNtPostSetKeySecurity:
	{
		PREG_POST_OPERATION_INFORMATION pPostOptInfo = (PREG_POST_OPERATION_INFORMATION)Argument2;
		PREG_POST_INFO pPostInfo = ProcmonRegGetPrePostInfo();
		if (pPostInfo) {
			if (pPostInfo->Seq != -1) {
				ProcmonGetPostLogEntry(pPostInfo->Seq, pPostOptInfo->Status, 0, &pLogBuffer);
				ProcmonNotifyProcessLog(pLogBuffer);
			}
			ProcmonFreePostInfo(pPostInfo);
		}
	}
	break;

	case RegNtKeyHandleClose:
		NotifyType = NOTIFY_REG_KEYHANDLECLOSE;
		goto __label_reg_pre_common;

	case RegNtPostEnumerateKey:
	{
		PREG_POST_OPERATION_INFORMATION pPostOptInfo = (PREG_POST_OPERATION_INFORMATION)Argument2;
		PREG_POST_INFO pPostInfo = ProcmonRegGetPrePostInfo();
		if (pPostInfo) {
			if (pPostInfo->Seq != -1) {
				PREG_ENUMERATE_KEY_INFORMATION pRegOptInfo = (PREG_ENUMERATE_KEY_INFORMATION)pPostInfo->pRegData;
				ProcmonNotifyPostRegEnumerateKey(pPostInfo->Seq, pPostOptInfo->Status,
					pRegOptInfo->KeyInformationClass, pRegOptInfo->KeyInformation, pRegOptInfo->ResultLength);
				ProcmonFreePostInfo(pPostInfo);
			}
		}
	}
	break;
	case RegNtPostEnumerateValueKey:
	{
		PREG_POST_OPERATION_INFORMATION pPostOptInfo = (PREG_POST_OPERATION_INFORMATION)Argument2;
		PREG_POST_INFO pPostInfo = ProcmonRegGetPrePostInfo();
		if (pPostInfo) {
			if (pPostInfo->Seq != -1) {
				PREG_ENUMERATE_VALUE_KEY_INFORMATION pRegOptInfo = (PREG_ENUMERATE_VALUE_KEY_INFORMATION)pPostInfo->pRegData;
				ProcmonNotifyPostRegEnumerateValueKey(pPostInfo->Seq, pPostOptInfo->Status,
					pRegOptInfo->KeyValueInformationClass, pRegOptInfo->KeyValueInformation, pRegOptInfo->ResultLength);
				ProcmonFreePostInfo(pPostInfo);
			}
		}
	}
	break;
	case RegNtPostQueryKey:
	{
		PREG_POST_OPERATION_INFORMATION pPostOptInfo = (PREG_POST_OPERATION_INFORMATION)Argument2;
		PREG_POST_INFO pPostInfo = ProcmonRegGetPrePostInfo();
		if (pPostInfo) {
			if (pPostInfo->Seq != -1) {
				PREG_QUERY_KEY_INFORMATION pRegOptInfo = (PREG_QUERY_KEY_INFORMATION)pPostInfo->pRegData;
				ProcmonNotifyPostRegEnumerateKey(pPostInfo->Seq, pPostOptInfo->Status,
					pRegOptInfo->KeyInformationClass, pRegOptInfo->KeyInformation, pRegOptInfo->ResultLength);
				ProcmonFreePostInfo(pPostInfo);
			}
		}
	}
	break;

	case RegNtPostQueryValueKey:
	{
		PREG_POST_OPERATION_INFORMATION pPostOptInfo = (PREG_POST_OPERATION_INFORMATION)Argument2;
		PREG_POST_INFO pPostInfo = ProcmonRegGetPrePostInfo();
		if (pPostInfo) {
			if (pPostInfo->Seq != -1) {
				PREG_QUERY_VALUE_KEY_INFORMATION pRegOptInfo = (PREG_QUERY_VALUE_KEY_INFORMATION)pPostInfo->pRegData;
				ProcmonNotifyPostRegEnumerateValueKey(pPostInfo->Seq, pPostOptInfo->Status,
					pRegOptInfo->KeyValueInformationClass, pRegOptInfo->KeyValueInformation, pRegOptInfo->ResultLength);
				ProcmonFreePostInfo(pPostInfo);
			}
		}
	}
	break;

	case RegNtPreCreateKeyEx:
	case RegNtPreOpenKeyEx:
	{
		PREG_CREATE_KEY_INFORMATION pRegOptInfo = (PREG_CREATE_KEY_INFORMATION)Argument2;
		ACCESS_MASK DesiredAccess;
		if (gBuildNumber <= 3790)
			DesiredAccess = 0;
		else
			DesiredAccess = pRegOptInfo->DesiredAccess;
		if (RegNotifyClass == RegNtPreOpenKeyEx){
			NotifyType = NOTIFY_REG_OPENKEYEX;
		}else{
			NotifyType = NOTIFY_REG_CREATEKEYEX;
		}
		Seq = ProcmonNotifyRegCreateOpenKeyEx(NotifyType, DesiredAccess, NULL, pRegOptInfo->RootObject, pRegOptInfo->CompleteName);
		ProcmonAddToPrePostList(Seq, Argument2);
	}
	break;

	case RegNtPostCreateKeyEx:
	case RegNtPostOpenKeyEx:
	{
		PREG_POST_OPERATION_INFORMATION pPostOptInfo = (PREG_POST_OPERATION_INFORMATION)Argument2;
		PREG_POST_INFO pPostInfo = ProcmonRegGetPrePostInfo();
		if (pPostInfo) {
			ULONG Disposition = 0;
			ACCESS_MASK DesiredAccess = 0, GrantedAccess = 0;
			PREG_CREATE_KEY_INFORMATION pRegOptInfo = (PREG_CREATE_KEY_INFORMATION)pPostInfo->pRegData;

			if (gBuildNumber > 3790) {
				if (pRegOptInfo->Disposition) {
					Disposition = *pRegOptInfo->Disposition;
				}
				GrantedAccess = pRegOptInfo->GrantedAccess;
				DesiredAccess = pRegOptInfo->DesiredAccess;
			}

			ProcmonNotifyPostRegCreateOpenKey(
				pPostInfo->Seq,
				pPostOptInfo->Status,
				DesiredAccess,
				GrantedAccess,
				Disposition);

			ProcmonFreePostInfo(pPostInfo);
		}
	}
	break;

	case RegNtPreFlushKey:
		NotifyType = NOTIFY_REG_FLUSHKEY;
		goto __label_reg_pre_common;

	case RegNtPreLoadKey:
	{
		PREG_LOAD_KEY_INFORMATION pRegOptInfo = (PREG_LOAD_KEY_INFORMATION)Argument2;
		Seq = ProcmonNotifyRegLoadKey(pRegOptInfo->Object, pRegOptInfo->KeyName,
			pRegOptInfo->SourceFile);
		ProcmonAddToPrePostList(Seq, Argument2);
	}
	break;
	case RegNtPreUnLoadKey:
	{
		PREG_UNLOAD_KEY_INFORMATION pRegOptInfo = (PREG_UNLOAD_KEY_INFORMATION)Argument2;
		Seq = ProcmonNotifyRegUnLoadKey(NULL, pRegOptInfo->Object);
		ProcmonAddToPrePostList(Seq, Argument2);
	}
	break;
	case RegNtPreQueryKeySecurity:
		NotifyType = NOTIFY_REG_QUERYKEYSECURITY;
		goto __label_reg_pre_common;
	case RegNtPreSetKeySecurity:
		NotifyType = NOTIFY_REG_SETKEYSECURITY;
	__label_reg_pre_common:
		Seq = ProcmonNotifyRegOptCommon(NULL, *(PVOID*)Argument2, NotifyType, sizeof(USHORT));
		ProcmonAddToPrePostList(Seq, Argument2);
		break;
	default:
		break;
	}

	return STATUS_SUCCESS;
}

NTSTATUS
EnableRegMonitor(
	_In_ ULONG bEnable
)
{
	if (!bEnable) {

		if (gbRegCallbackSet && fnCmUnRegisterCallback)
		{
			CleanUpAllRegPostInfoList();
			fnCmUnRegisterCallback(gCookie);
			CleanupRegObjectList();
			gbRegCallbackSet = 0;
		}
		return STATUS_SUCCESS;
	}

	if (gbRegCallbackSet) {
		return STATUS_SUCCESS;
	}

	if ((fnCmRegisterCallback || fnCmRegisterCallbackEx) && !(bEnable & 8)) {
		if (fnCmRegisterCallbackEx) {
			UNICODE_STRING Altitude;
			RtlInitUnicodeString(&Altitude, L"500000");
			fnCmRegisterCallbackEx(ProcmonRegistryCallback, &Altitude, gDriverObject, NULL, &gCookie, NULL);
			gbRegCallbackSet = TRUE;
			return STATUS_SUCCESS;
		}
		fnCmRegisterCallback(ProcmonRegistryCallback, NULL, &gCookie);
	}

	gbRegCallbackSet = TRUE;
	return STATUS_SUCCESS;
}


VOID
ProcmonRegMonitorInit(
	VOID
)
{
	UNICODE_STRING UniStrFunction;

	RtlInitUnicodeString(&gUniStrInsufficentRef, L"<INSUFFICIENT RESOURCES>");
	RtlInitUnicodeString(&gUniInvalidName, L"<INVALID NAME>");
	RtlInitUnicodeString(&gUniStrDefault, L"(Default)");
	RtlInitUnicodeString(&gUniRegistry, L"\\Registry");
	if (gBuildNumber >= 3790)
	{
		RtlInitUnicodeString(&UniStrFunction, L"CmRegisterCallback");
		fnCmRegisterCallback = (FNCmRegisterCallback)MmGetSystemRoutineAddress(&UniStrFunction);
		RtlInitUnicodeString(&UniStrFunction, L"CmRegisterCallbackEx");
		fnCmRegisterCallbackEx = (FNCmRegisterCallbackEx)MmGetSystemRoutineAddress(&UniStrFunction);
		RtlInitUnicodeString(&UniStrFunction, L"CmUnRegisterCallback");
		fnCmUnRegisterCallback = (FNCmUnRegisterCallback)MmGetSystemRoutineAddress(&UniStrFunction);
		RtlInitUnicodeString(&UniStrFunction, L"CmCallbackGetKeyObjectID");
		fnCmCallbackGetKeyObjectID = (FNCmCallbackGetKeyObjectID)MmGetSystemRoutineAddress(&UniStrFunction);
		ExInitializePagedLookasideList(&gLookasideRegPostInfo, NULL, NULL, 0, sizeof(REG_POST_INFO), 'mgeR', 0x100);
		InitializeListHead(&gRegPostInfoList);
		KeInitializeMutex(&gMutexRegPostInfo, 0);
	}

	InitializeListHead(&gRegObjectList);
	KeInitializeMutex(&gMutexRegObjectList, 0);
}
```

`kernel/reg.h`:

```h
#pragma once

#include <ntifs.h>

typedef struct _REG_POST_INFO
{
	PVOID pRegData;
	PETHREAD Thread;
	LONG Seq;
	// ULONG Fill14;
	LIST_ENTRY List;
}REG_POST_INFO, *PREG_POST_INFO;

typedef struct _REG_OBJECT_INFO
{
	PVOID Object;
	PUNICODE_STRING Name;
	LIST_ENTRY List;
}REG_OBJECT_INFO, *PREG_OBJECT_INFO;

typedef
NTSTATUS
(NTAPI *FNCmRegisterCallback)(
	_In_     PEX_CALLBACK_FUNCTION Function,
	_In_opt_ PVOID                 Context,
	_Out_    PLARGE_INTEGER        Cookie
	);

typedef
NTSTATUS
(NTAPI *FNCmRegisterCallbackEx)(
	_In_        PEX_CALLBACK_FUNCTION   Function,
	_In_        PCUNICODE_STRING        Altitude,
	_In_        PVOID                   Driver, //PDRIVER_OBJECT
	_In_opt_    PVOID                   Context,
	_Out_       PLARGE_INTEGER          Cookie,
	_Reserved_  PVOID                   Reserved
	);

typedef
NTSTATUS
(NTAPI *FNCmUnRegisterCallback)(
	_In_ LARGE_INTEGER    Cookie
	);

typedef
NTSTATUS
(NTAPI *FNCmCallbackGetKeyObjectID)(
	_In_            PLARGE_INTEGER      Cookie,
	_In_            PVOID               Object,
	_Out_opt_       PULONG_PTR          ObjectID,
	_Outptr_opt_ PCUNICODE_STRING    *ObjectName
	);

VOID
ProcmonRegMonitorInit(
	VOID
);

NTSTATUS
EnableRegMonitor(
	_In_ ULONG bEnable
);
```

`kernel/utils.c`:

```c

#include "utils.h"
#include <fltKernel.h>


// #ifdef ALLOC_PRAGMA
// #pragma alloc_text(PAGE, ProcmonAllocatePoolWithTag)
// #pragma alloc_text(PAGE, ProcmonDuplicateUnicodeString)
// #pragma alloc_text(PAGE, ProcmonDuplicateUnicodeString2)
// #endif

PVOID
ProcmonAllocatePoolWithTag(
	_In_ POOL_TYPE PoolType,
	_In_ SIZE_T NumberOfBytes,
	_In_ ULONG Tag
)
{
	return ExAllocatePoolWithTag(PoolType, NumberOfBytes, ((CHAR)Tag << 24) | 'nmP');
}

PUNICODE_STRING
ProcmonDuplicateUnicodeString(
	_In_ POOL_TYPE PoolType,
	_In_ CONST PUNICODE_STRING pStrIn,
	_In_ CHAR Tag
)
/*++

Routine Description:

	.

Arguments:

	 PoolType -
	 pStrIn -
	 Tag -

Return Value:

	Routine can return non success error codes.

--*/
{

	FLT_ASSERT(pStrIn);
	FLT_ASSERT(pStrIn->Buffer);

	//
	// Allocate buffer for new string
	//

	PUNICODE_STRING pStrNew = ProcmonAllocatePoolWithTag(PoolType, pStrIn->Length +
		sizeof(UNICODE_STRING), Tag);

	//
	// Initialize the new string and copy the buffer from pStrIn
	//

	if (pStrNew) {
		pStrNew->MaximumLength = pStrIn->Length;
		pStrNew->Buffer = (PWCH)(pStrNew + 1);
		RtlCopyUnicodeString(pStrNew, pStrIn);
	}
	return pStrNew;

}

PWCHAR
ProcmonDuplicateUnicodeString2(
	_Out_ PUNICODE_STRING pDst,
	_In_ PUNICODE_STRING pSrc,
	_In_ ULONG Tag
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	USHORT wLength;
	PWCHAR lpszRet;

	if (!pSrc->Length) {
		pDst->Length = pDst->MaximumLength = 0;
		pDst->Buffer = NULL;
	}

	wLength = pSrc->Length / sizeof(WCHAR);
	lpszRet = (WCHAR *)ProcmonAllocatePoolWithTag(NonPagedPool, 2 * wLength + 2, Tag);
	pDst->Buffer = lpszRet;
	if (lpszRet)
	{
		memmove(lpszRet, pSrc->Buffer, 2 * wLength);
		lpszRet[wLength] = 0;
		pDst->Length = 2 * wLength;
		pDst->MaximumLength = pDst->Length;
	}
	return lpszRet;
}

USHORT
ProcmonDuplicateUserBuffer(
	_In_ PVOID Src, 
	_In_ USHORT Length, 
	_Out_ PVOID *pDest
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	USHORT Ret = 0;

	Ret = Length;
	if (Length)
	{
		try
		{
			*pDest = ProcmonAllocatePoolWithTag(NonPagedPool, Length, 'J');
			if (*pDest)
				RtlCopyMemory(*pDest, Src, Length);
			else
				Ret = 0;
		}except(EXCEPTION_EXECUTE_HANDLER){
			if (*pDest){
				ExFreePoolWithTag(*pDest, 0);
				*pDest = NULL;
				return 0;
			}
		}

	}
	return Ret;
}

VOID 
ProcmonSafeCopy(
	_In_ BOOLEAN bIsKernel, 
	_In_ PETHREAD Thread, 
	_In_ FLT_CALLBACK_DATA_FLAGS Flags, 
	_Out_ PVOID pDstBuffer,
	_In_ PVOID pSrcBuffer, 
	_Inout_ PULONG pLength
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	BOOLEAN bOk = TRUE;
	PMDL pMdl;
	PVOID pMappedAddr;

	if (bIsKernel || Flags & 8 || Flags & 2){
		try{
			RtlCopyMemory(pDstBuffer, pSrcBuffer, *pLength);
		}except(EXCEPTION_EXECUTE_HANDLER){
			bOk = FALSE;
		}
		
	}else{
		pMdl = IoAllocateMdl(pSrcBuffer, *pLength, 0, 0, NULL);
		if (pMdl){
			try{
				MmProbeAndLockProcessPages(pMdl, IoThreadToProcess(Thread), KernelMode, IoReadAccess);
			}except(EXCEPTION_EXECUTE_HANDLER){
				bOk = FALSE;
			}
			
			if (bOk){
				pMappedAddr = MmGetSystemAddressForMdlSafe(pMdl, NormalPagePriority);
				if (pMappedAddr)
					RtlCopyMemory(pDstBuffer, pMappedAddr, *pLength);
				else
					bOk = FALSE;
				MmUnlockPages(pMdl);
			}

			IoFreeMdl(pMdl);
		}else{
			bOk = FALSE;
		}
	}
	if (!bOk){
		*pLength = 0;
		ExFreePoolWithTag(pDstBuffer, 0);
	}
}

PVOID
ObReferenceObjectByHandleSafe(
	_In_ HANDLE Handle
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	NTSTATUS Status;
	PVOID Object = NULL;

	if (!Handle) {
		return NULL;
	}

	//
	// Like CurrentProcess(-1), CurrentThread(-2)
	//

	if (Handle < 0 && ExGetPreviousMode() == UserMode) {
		return NULL;
	}

	Status = ObReferenceObjectByHandle(Handle, 0, NULL, KernelMode, &Object, NULL);
	if (!NT_SUCCESS(Status)) {
		return NULL;
	}

	return Object;

}

LONG
ProcmonGetFileNameInfoWorkRoutine(
	_In_ PVOID Parameter
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	PGETFILENAME_WORKITEM pWorkItem = (PGETFILENAME_WORKITEM)Parameter;
	pWorkItem->Status = FltGetFileNameInformationUnsafe(pWorkItem->FileObject, NULL,
		FLT_FILE_NAME_QUERY_DEFAULT | FLT_FILE_NAME_NORMALIZED,
		&pWorkItem->pFileNameInfo);
	return KeSetEvent(&pWorkItem->NotifyEvent, 0, 0);
}

HANDLE
ProcmonGetProcessTokenHandle(
	_In_ BOOLEAN bRefImpersonationToken
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	PACCESS_TOKEN pToken;
	HANDLE hToken = NULL;
	BOOLEAN EffectiveOnly, CopyOnOpen;
	SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;

	pToken = PsReferenceImpersonationToken(KeGetCurrentThread(), &CopyOnOpen, &EffectiveOnly, &ImpersonationLevel);
	if (pToken || !bRefImpersonationToken && (pToken = PsReferencePrimaryToken(IoGetCurrentProcess())) != NULL)
	{
		ObOpenObjectByPointer(pToken, OBJ_KERNEL_HANDLE, NULL, TOKEN_QUERY, NULL, KernelMode, &hToken);
		ObfDereferenceObject(pToken);
	}
	return hToken;
}

EXTERN_C
BOOLEAN
NTAPI
PsIsThreadImpersonating(
	__in PETHREAD Thread
);

BOOLEAN
ProcmonIsThreadImpersonation()
/*++

Routine Description:

	.

Arguments:

	 -

Return Value:

	Routine can return non success error codes.

--*/
{
	return PsIsThreadImpersonating(KeGetCurrentThread());
}


PTOKEN_USER
ProcmonQueryTokenInformation(
	_In_ HANDLE hToken,
	_Out_opt_ PTOKEN_STATISTICS pTokenStatistics,
	_Out_opt_ PULONG pTokenVirtualizationEnabled,
	_Out_opt_ PTOKEN_MANDATORY_LABEL *pIntegrityLevel
)
/*++

Routine Description:

    .

Arguments:

	 - 

Return Value:

    Routine can return non success error codes.

--*/
{
	NTSTATUS Status;
	ULONG Length;
	PTOKEN_USER pTokenUserInfo = NULL;
	CHAR TagTokenInfo = '3';

	Status = ZwQueryInformationToken(hToken, TokenUser, NULL, 0, &Length);
	if (Status != STATUS_BUFFER_TOO_SMALL) {
		return NULL;
	}

	pTokenUserInfo = ProcmonAllocatePoolWithTag(NonPagedPool, Length, TagTokenInfo);
	if (!pTokenUserInfo) {
		return NULL;
	}

	Status = ZwQueryInformationToken(hToken, TokenUser, pTokenUserInfo, Length, &Length);
	if (!NT_SUCCESS(Status)) {
		ExFreePoolWithTag(pTokenUserInfo, 0);
		pTokenUserInfo = NULL;
	}

	if (pTokenStatistics) {
		ZwQueryInformationToken(hToken, TokenStatistics, pTokenStatistics, sizeof(*pTokenStatistics), &Length);
	}

	if (pTokenVirtualizationEnabled) {
		Status = ZwQueryInformationToken(hToken, TokenVirtualizationEnabled, pTokenVirtualizationEnabled,
			sizeof(*pTokenVirtualizationEnabled), &Length);
		if (!NT_SUCCESS(Status)) {
			*pTokenVirtualizationEnabled = (ULONG)-1;
		}
	}

	if (pIntegrityLevel) {

		//
		// Get the length of information
		//

		Status = ZwQueryInformationToken(hToken, TokenIntegrityLevel, NULL, 0, &Length);
		if (Status == STATUS_BUFFER_TOO_SMALL) {

			//
			// Allocate memory for information
			//

			*pIntegrityLevel = (PTOKEN_MANDATORY_LABEL)ProcmonAllocatePoolWithTag(NonPagedPool, Length, TagTokenInfo);
			if (*pIntegrityLevel) {

				//
				// Query again
				//

				Status = ZwQueryInformationToken(hToken, TokenIntegrityLevel, *pIntegrityLevel, Length, &Length);
				if (!NT_SUCCESS(Status)) {
					ExFreePoolWithTag(*pIntegrityLevel, 0);
					*pIntegrityLevel = NULL;
				}
			}
		}
	}

	return pTokenUserInfo;
}


```

`kernel/utils.h`:

```h
#pragma once

#include <ntifs.h>
#include <fltKernel.h>


typedef struct _GETFILENAME_WORKITEM
{
	WORK_QUEUE_ITEM WorkItem;
	NTSTATUS Status;
	PFILE_OBJECT FileObject;
	PFLT_FILE_NAME_INFORMATION pFileNameInfo;
	KEVENT NotifyEvent;
}GETFILENAME_WORKITEM, *PGETFILENAME_WORKITEM;

PVOID
ProcmonAllocatePoolWithTag(
	_In_ POOL_TYPE PoolType,
	_In_ SIZE_T NumberOfBytes,
	_In_ ULONG Tag
);

PUNICODE_STRING
ProcmonDuplicateUnicodeString(
	_In_ POOL_TYPE PoolType,
	_In_ CONST PUNICODE_STRING pStrIn,
	_In_ CHAR Tag
);

PWCHAR
ProcmonDuplicateUnicodeString2(
	_Out_ PUNICODE_STRING pDst,
	_In_ PUNICODE_STRING pSrc,
	_In_ ULONG Tag
);

USHORT
ProcmonDuplicateUserBuffer(
	_In_ PVOID Src,
	_In_ USHORT Length,
	_Out_ PVOID *pDest
);

PVOID
ObReferenceObjectByHandleSafe(
	_In_ HANDLE Handle
);

LONG
ProcmonGetFileNameInfoWorkRoutine(
	_In_ PVOID Parameter
);

HANDLE
ProcmonGetProcessTokenHandle(
	_In_ BOOLEAN bRefImpersonationToken
);

PTOKEN_USER
ProcmonQueryTokenInformation(
	_In_ HANDLE hToken,
	_Out_opt_ PTOKEN_STATISTICS pTokenStatistics,
	_Out_opt_ PULONG pTokenVirtualizationEnabled,
	_Out_opt_ PTOKEN_MANDATORY_LABEL *pIntegrityLevel
);

VOID
ProcmonSafeCopy(
	_In_ BOOLEAN bIsKernel,
	_In_ PETHREAD Thread,
	_In_ FLT_CALLBACK_DATA_FLAGS Flags,
	_Out_ PVOID pDstBuffer,
	_In_ PVOID pSrcBuffer,
	_Inout_ PULONG pLength
);

BOOLEAN
ProcmonIsThreadImpersonation();
```

`procmon.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29102.190
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "procmon", "kernel\procmon.vcxproj", "{A7878490-3B63-4BD7-B369-19BBC19DD3E8}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "procmonsdk", "sdk\procmonsdk\procmonsdk.vcxproj", "{C21EB4AB-5F89-4993-A408-873C6A5B60CB}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "sdktest", "sdk\example\example.vcxproj", "{582D2DBF-0CA2-4408-B86E-663A687411AE}"
	ProjectSection(ProjectDependencies) = postProject
		{C21EB4AB-5F89-4993-A408-873C6A5B60CB} = {C21EB4AB-5F89-4993-A408-873C6A5B60CB}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "procmon_gui", "gui\procmon_gui.vcxproj", "{7488FAC5-431F-4E66-AFAE-0858DF3E0FD7}"
	ProjectSection(ProjectDependencies) = postProject
		{C21EB4AB-5F89-4993-A408-873C6A5B60CB} = {C21EB4AB-5F89-4993-A408-873C6A5B60CB}
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{A7878490-3B63-4BD7-B369-19BBC19DD3E8}.Debug|ARM.ActiveCfg = Debug|ARM
		{A7878490-3B63-4BD7-B369-19BBC19DD3E8}.Debug|ARM.Build.0 = Debug|ARM
		{A7878490-3B63-4BD7-B369-19BBC19DD3E8}.Debug|ARM.Deploy.0 = Debug|ARM
		{A7878490-3B63-4BD7-B369-19BBC19DD3E8}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{A7878490-3B63-4BD7-B369-19BBC19DD3E8}.Debug|ARM64.Build.0 = Debug|ARM64
		{A7878490-3B63-4BD7-B369-19BBC19DD3E8}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{A7878490-3B63-4BD7-B369-19BBC19DD3E8}.Debug|x64.ActiveCfg = Debug|x64
		{A7878490-3B63-4BD7-B369-19BBC19DD3E8}.Debug|x64.Build.0 = Debug|x64
		{A7878490-3B63-4BD7-B369-19BBC19DD3E8}.Debug|x64.Deploy.0 = Debug|x64
		{A7878490-3B63-4BD7-B369-19BBC19DD3E8}.Debug|x86.ActiveCfg = Debug|Win32
		{A7878490-3B63-4BD7-B369-19BBC19DD3E8}.Debug|x86.Build.0 = Debug|Win32
		{A7878490-3B63-4BD7-B369-19BBC19DD3E8}.Debug|x86.Deploy.0 = Debug|Win32
		{A7878490-3B63-4BD7-B369-19BBC19DD3E8}.Release|ARM.ActiveCfg = Release|ARM
		{A7878490-3B63-4BD7-B369-19BBC19DD3E8}.Release|ARM.Build.0 = Release|ARM
		{A7878490-3B63-4BD7-B369-19BBC19DD3E8}.Release|ARM.Deploy.0 = Release|ARM
		{A7878490-3B63-4BD7-B369-19BBC19DD3E8}.Release|ARM64.ActiveCfg = Release|ARM64
		{A7878490-3B63-4BD7-B369-19BBC19DD3E8}.Release|ARM64.Build.0 = Release|ARM64
		{A7878490-3B63-4BD7-B369-19BBC19DD3E8}.Release|ARM64.Deploy.0 = Release|ARM64
		{A7878490-3B63-4BD7-B369-19BBC19DD3E8}.Release|x64.ActiveCfg = Release|x64
		{A7878490-3B63-4BD7-B369-19BBC19DD3E8}.Release|x64.Build.0 = Release|x64
		{A7878490-3B63-4BD7-B369-19BBC19DD3E8}.Release|x64.Deploy.0 = Release|x64
		{A7878490-3B63-4BD7-B369-19BBC19DD3E8}.Release|x86.ActiveCfg = Release|Win32
		{A7878490-3B63-4BD7-B369-19BBC19DD3E8}.Release|x86.Build.0 = Release|Win32
		{A7878490-3B63-4BD7-B369-19BBC19DD3E8}.Release|x86.Deploy.0 = Release|Win32
		{C21EB4AB-5F89-4993-A408-873C6A5B60CB}.Debug|ARM.ActiveCfg = Debug|Win32
		{C21EB4AB-5F89-4993-A408-873C6A5B60CB}.Debug|ARM64.ActiveCfg = Debug|Win32
		{C21EB4AB-5F89-4993-A408-873C6A5B60CB}.Debug|x64.ActiveCfg = Debug|x64
		{C21EB4AB-5F89-4993-A408-873C6A5B60CB}.Debug|x64.Build.0 = Debug|x64
		{C21EB4AB-5F89-4993-A408-873C6A5B60CB}.Debug|x86.ActiveCfg = Debug|Win32
		{C21EB4AB-5F89-4993-A408-873C6A5B60CB}.Debug|x86.Build.0 = Debug|Win32
		{C21EB4AB-5F89-4993-A408-873C6A5B60CB}.Release|ARM.ActiveCfg = Release|Win32
		{C21EB4AB-5F89-4993-A408-873C6A5B60CB}.Release|ARM64.ActiveCfg = Release|Win32
		{C21EB4AB-5F89-4993-A408-873C6A5B60CB}.Release|x64.ActiveCfg = Release|x64
		{C21EB4AB-5F89-4993-A408-873C6A5B60CB}.Release|x64.Build.0 = Release|x64
		{C21EB4AB-5F89-4993-A408-873C6A5B60CB}.Release|x86.ActiveCfg = Release|Win32
		{C21EB4AB-5F89-4993-A408-873C6A5B60CB}.Release|x86.Build.0 = Release|Win32
		{582D2DBF-0CA2-4408-B86E-663A687411AE}.Debug|ARM.ActiveCfg = Debug|Win32
		{582D2DBF-0CA2-4408-B86E-663A687411AE}.Debug|ARM64.ActiveCfg = Debug|Win32
		{582D2DBF-0CA2-4408-B86E-663A687411AE}.Debug|x64.ActiveCfg = Debug|x64
		{582D2DBF-0CA2-4408-B86E-663A687411AE}.Debug|x64.Build.0 = Debug|x64
		{582D2DBF-0CA2-4408-B86E-663A687411AE}.Debug|x86.ActiveCfg = Debug|Win32
		{582D2DBF-0CA2-4408-B86E-663A687411AE}.Debug|x86.Build.0 = Debug|Win32
		{582D2DBF-0CA2-4408-B86E-663A687411AE}.Release|ARM.ActiveCfg = Release|Win32
		{582D2DBF-0CA2-4408-B86E-663A687411AE}.Release|ARM64.ActiveCfg = Release|Win32
		{582D2DBF-0CA2-4408-B86E-663A687411AE}.Release|x64.ActiveCfg = Release|x64
		{582D2DBF-0CA2-4408-B86E-663A687411AE}.Release|x64.Build.0 = Release|x64
		{582D2DBF-0CA2-4408-B86E-663A687411AE}.Release|x86.ActiveCfg = Release|Win32
		{582D2DBF-0CA2-4408-B86E-663A687411AE}.Release|x86.Build.0 = Release|Win32
		{7488FAC5-431F-4E66-AFAE-0858DF3E0FD7}.Debug|ARM.ActiveCfg = Debug|Win32
		{7488FAC5-431F-4E66-AFAE-0858DF3E0FD7}.Debug|ARM64.ActiveCfg = Debug|Win32
		{7488FAC5-431F-4E66-AFAE-0858DF3E0FD7}.Debug|x64.ActiveCfg = Debug|x64
		{7488FAC5-431F-4E66-AFAE-0858DF3E0FD7}.Debug|x64.Build.0 = Debug|x64
		{7488FAC5-431F-4E66-AFAE-0858DF3E0FD7}.Debug|x86.ActiveCfg = Debug|Win32
		{7488FAC5-431F-4E66-AFAE-0858DF3E0FD7}.Debug|x86.Build.0 = Debug|Win32
		{7488FAC5-431F-4E66-AFAE-0858DF3E0FD7}.Release|ARM.ActiveCfg = Release|Win32
		{7488FAC5-431F-4E66-AFAE-0858DF3E0FD7}.Release|ARM64.ActiveCfg = Release|Win32
		{7488FAC5-431F-4E66-AFAE-0858DF3E0FD7}.Release|x64.ActiveCfg = Release|x64
		{7488FAC5-431F-4E66-AFAE-0858DF3E0FD7}.Release|x64.Build.0 = Release|x64
		{7488FAC5-431F-4E66-AFAE-0858DF3E0FD7}.Release|x86.ActiveCfg = Release|Win32
		{7488FAC5-431F-4E66-AFAE-0858DF3E0FD7}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {0F054EA3-70E3-44A8-BD95-A6BF4E0719DF}
	EndGlobalSection
EndGlobal

```

`sdk/example/CMakeLists.txt`:

```txt
project(example)

if (CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")
    set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} /MT")
    set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} /MTd")
endif()

add_definitions(-DUNICODE)
add_definitions(-D_UNICODE)

#add inc file search dir
INCLUDE_DIRECTORIES(
    "${OPENPROCMON_SOURCE_DIR}/sdk/procmonsdk"
)

add_executable(example 
    example.cpp
)

set_target_properties(example PROPERTIES LINK_FLAGS "/MANIFESTUAC:\"level='requireAdministrator' uiAccess='false'\"")
target_link_libraries(example libprocmon)
```

`sdk/example/example.cpp`:

```cpp
// sdktest.cpp : This file contains the 'main' function. Program execution begins and ends there.
//


#include <conio.h>
#include <atltime.h>
#include "../../sdk/procmonsdk/sdk.hpp"

class CMyEvent : public IEventCallback
{
public:
	virtual BOOL DoEvent(const CRefPtr<CEventView> pEventView)
	{

		ULONGLONG Time = pEventView->GetStartTime().QuadPart;

		LogMessage(L_INFO, TEXT("%llu Process %s Do 0x%x for %s"),
			Time,
			pEventView->GetProcessName().GetBuffer(),
			pEventView->GetEventOperator(),
			pEventView->GetPath().GetBuffer());
		//m_viewList.push_back(pEventView);
		return TRUE;
	}
};


int main()
{

	CEventMgr& Optmgr = Singleton<CEventMgr>::getInstance();
	CMonitorContoller& Monitormgr = Singleton<CMonitorContoller>::getInstance();
	CDrvLoader& Drvload = Singleton<CDrvLoader>::getInstance();
	
	if(!Drvload.Init(TEXT("PROCMON24"), TEXT("procmon.sys"))){
		return -1;
	}
	Optmgr.RegisterCallback(new CMyEvent);

	//
	// Try to connect to procmon driver
	//
	
	if (!Monitormgr.Connect()){
		LogMessage(L_ERROR, TEXT("Cannot connect to procmon driver"));
		return -1;
	}
	
	//
	// try to start monitor
	//
	
	Monitormgr.SetMonitor(TRUE, TRUE, FALSE);
	if (!Monitormgr.Start()){
		LogMessage(L_ERROR, TEXT("Cannot start the mointor"));
		return -1;
	}

	_getch();
	
	//
	// try to stop the monitor
	//
	
	Monitormgr.Stop();

	LogMessage(L_INFO, TEXT("!!!!!monitor stop press any key to start!!!!"));
	_getch();

	Monitormgr.Start();

	_getch();

	Monitormgr.Stop();
	Monitormgr.Destory();
	return 0;
}

```

`sdk/example/example.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{582D2DBF-0CA2-4408-B86E-663A687411AE}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>example</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>procmonsdk.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>../../X64/Debug</AdditionalLibraryDirectories>
      <UACExecutionLevel>AsInvoker</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>../../X64/Release</AdditionalLibraryDirectories>
      <AdditionalDependencies>procmonsdk.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="example.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`sdk/example/example.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`sdk/example/sdktest.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="example.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`sdk/procmonsdk/CMakeLists.txt`:

```txt
project(libprocmon)

if (CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")
    set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} /MT")
    set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} /MTd")
endif()

add_definitions(-DUNICODE)
add_definitions(-D_UNICODE)

#add inc file search dir
INCLUDE_DIRECTORIES(
    "${OPENPROCMON_SOURCE_DIR}/kernel"
)

file(GLOB SDK_HEADER *.hpp)
file(GLOB SDK_SOURCES *.cxx)

source_group("inc" FILES ${SDK_HEADER})
source_group("source" FILES ${SDK_SOURCES})

ADD_LIBRARY(libprocmon STATIC
    ${SDK_HEADER}
    ${SDK_SOURCES}
)
```

`sdk/procmonsdk/buffer.cxx`:

```cxx


#include "pch.hpp"

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>

#ifdef _WIN32
#include <windows.h>
#else
#define MoveMemory memmove
#define CopyMemory memcpy
#endif

#include "buffer.hpp"

#define ALIGN_SIZE 0x10

/** \fn CBuffer::CBuffer()
    \brief Constructs the buffer with a default size
*/

CBuffer::CBuffer()
{
	//
	// Initial size
	//

	m_nSize = 0;

	m_pPtr = m_pBase = NULL;
}

CBuffer::CBuffer(PBYTE pData, UINT nSize) :
	CBuffer()
{
	ClearBuffer();
	Write(pData, nSize);
}

CBuffer::CBuffer(const CBuffer& Src):
	CBuffer()
{
	Copy(Src);
}

/** \fn CBuffer::~CBuffer()
    \brief Deallocates the buffer
*/

CBuffer::~CBuffer()
{
	if (m_pBase)
		HeapFree(GetProcessHeap(), 0, m_pBase);//free(m_pBase);
}

bool CBuffer::operator==(const CBuffer& Src)
{
	if (this->GetBufferLen() != Src.GetBufferLen()){
		return false;
	}

	return memcmp(this->GetBuffer(), Src.GetBuffer(), this->GetBufferLen()) == 0;
}

CBuffer& CBuffer::operator+=(const CBuffer& Src)
{
	Write(Src.GetBuffer(), Src.GetBufferLen());
	return(*this);
}

CBuffer& CBuffer::operator=(const CBuffer& Src)
{
	Copy(Src);
	return(*this);
}

/** \fn BOOL CBuffer::Write(PBYTE pData, UINT nSize)
    \brief Writes data into the buffer
    \return 
*/

bool CBuffer::Write(PBYTE pData, UINT nSize)
{
	if(!ReAllocateBuffer(nSize + GetBufferLen())){
		return false;
	}

	CopyMemory(m_pPtr, pData, nSize);

	//
	// Advance Pointer
	//

	m_pPtr += nSize;

	return nSize != 0;
}

/** \fn BOOL CBuffer::Insert(PBYTE pData, UINT nSize)
    \brief Insert data into the buffer 
    \return 
*/

bool CBuffer::Insert(PBYTE pData, UINT nSize)
{
	ReAllocateBuffer(nSize + GetBufferLen());

	MoveMemory(m_pBase + nSize, m_pBase, GetMemSize() - nSize);
	CopyMemory(m_pBase, pData, nSize);

	//
	// Advance Pointer
	//

	m_pPtr += nSize;

	return nSize != 0;
}

/** \fn UINT CBuffer::Read(PBYTE pData, UINT nSize)
    \brief Reads data from the buffer and deletes what it reads
    \return 
*/

UINT CBuffer::Read(PBYTE pData, UINT nSize)
{
	//
	// Trying to byte off more than ya can chew - eh?
	//

	if (nSize > GetMemSize())
		return 0;

	//
	// all that we have 
	//

	if (nSize > GetBufferLen())
		nSize = GetBufferLen();

		
	if (nSize){

		//
		// Copy over required amount and its not up to us
		// to terminate the buffer - got that!!!
		//

		CopyMemory(pData,m_pBase,nSize);
		
		//
		// Slide the buffer back - like sinking the data
		//

		MoveMemory(m_pBase,m_pBase+nSize,GetMemSize() - nSize);

		m_pPtr -= nSize;
	}
		
	DeAllocateBuffer(GetBufferLen());

	return nSize;
}

/** \fn UINT CBuffer::GetMemSize() 
    \brief Returns the physical memory allocated to the buffer
    \return 
*/

UINT CBuffer::GetMemSize() const
{
	return m_nSize;
}

/** \fn UINT CBuffer::GetBufferLen() 
	\brief Get the buffer 'data' length
    \return 
*/

UINT CBuffer::GetBufferLen() const
{
	if (m_pBase == NULL)
		return 0;

	return (UINT)((ULONG_PTR)m_pPtr - (ULONG_PTR)m_pBase);
}

BOOL CBuffer::Empty()
{
	return GetBufferLen() == 0;
}


#define ALIGN_DOWN_BY(length, alignment) \
    ((ULONG_PTR)(length) & ~((ULONG_PTR)(alignment) - 1))

#define ALIGN_UP_BY(length, alignment) \
    (ALIGN_DOWN_BY(((ULONG_PTR)(length) + (alignment) - 1), alignment))

#define ALIGN_DOWN(length, type) \
    ALIGN_DOWN_BY(length, sizeof(type))

#define ALIGN_UP(length, type) \
    ALIGN_UP_BY(length, sizeof(type))

/** \fn UINT CBuffer::ReAllocateBuffer(UINT nRequestedSize)
    \brief ReAllocateBuffer the Buffer to the requested size
    \return 
*/

UINT CBuffer::ReAllocateBuffer(UINT nRequestedSize)
{
	if (nRequestedSize < GetMemSize())
		return 0;

	//
	// Allocate new size
	//

	UINT nNewSize = ALIGN_UP_BY(nRequestedSize, ALIGN_SIZE);

	//
	// New Copy Data Over
	//

	PBYTE pNewBuffer = (PBYTE)HeapAlloc(GetProcessHeap(), 0, nNewSize); //malloc(nNewSize);
	if (!pNewBuffer){
		return 0;
	}

	UINT nBufferLen = GetBufferLen();
	CopyMemory(pNewBuffer, m_pBase, nBufferLen);

	if (m_pBase)
		HeapFree(GetProcessHeap(), 0, m_pBase);//free(m_pBase);

	//
	// Hand over the pointer
	//

	m_pBase = pNewBuffer;

	//
	// Realign position pointer
	//

	m_pPtr = m_pBase + nBufferLen;

	m_nSize = nNewSize;

	return m_nSize;
}

/** \fn UINT CBuffer::DeAllocateBuffer(UINT nRequestedSize)
    \brief DeAllocates the Buffer to the requested size
    \return 
*/

UINT CBuffer::DeAllocateBuffer(UINT nRequestedSize)
{
	if (nRequestedSize < GetBufferLen())
		return 0;

	//
	// Allocate new size
	//

	UINT nNewSize = ALIGN_UP_BY(nRequestedSize, ALIGN_SIZE);

	if (nNewSize < GetMemSize())
		return 0;

	//
	// New Copy Data Over
	//

	PBYTE pNewBuffer = (PBYTE)HeapAlloc(GetProcessHeap(), 0, nNewSize);//malloc(nNewSize);
	if (!pNewBuffer){
		return 0;
	}

	UINT nBufferLen = GetBufferLen();
	CopyMemory(pNewBuffer,m_pBase,nBufferLen);

	HeapFree(GetProcessHeap(), 0, m_pBase);//free(m_pBase);

	//
	// Hand over the pointer
	//

	m_pBase = pNewBuffer;

	//
	// Realign position pointer
	//

	m_pPtr = m_pBase + nBufferLen;

	m_nSize = nNewSize;

	return m_nSize;
}


/** \fn void CBuffer::ClearBuffer()
    \brief Clears/Resets the buffer
    \return 
*/

void CBuffer::ClearBuffer()
{
	//
	// Force the buffer to be empty
	//

	m_pPtr = m_pBase;

	DeAllocateBuffer(ALIGN_SIZE);
}

/** \fn void CBuffer::Copy(CBuffer& buffer)
    \brief Copy from one buffer object to another...
    \return 
*/

void CBuffer::Copy(const CBuffer& buffer)
{
	int nReSize = buffer.GetMemSize();
	int nSize = buffer.GetBufferLen();
	ClearBuffer();
	ReAllocateBuffer(nReSize);

	m_pPtr = m_pBase + nSize;

	CopyMemory(m_pBase,buffer.GetBuffer(),buffer.GetBufferLen());
}

/** \fn PBYTE CBuffer::GetBuffer(UINT nPos)
    \brief Returns a pointer to the physical memory determined by the offset
    \return 
*/

PBYTE CBuffer::GetBuffer(UINT nPos) const
{
	return m_pBase+nPos;
}


void CBuffer::Clear()
{
	if (m_pBase) {
		HeapFree(GetProcessHeap(), 0, m_pBase);
	}

	m_nSize = 0;
	m_pBase = m_pPtr = NULL;
}

/** \fn UINT CBuffer::Delete(UINT nSize)
    \brief Delete data from the buffer and deletes what it reads
    \return 
*/

UINT CBuffer::Delete(UINT nSize)
{
	//
	// Trying to byte off more than ya can chew - eh?
	//

	if (nSize > GetMemSize())
		return 0;

	//
	// all that we have 
	//

	if (nSize > GetBufferLen())
		nSize = GetBufferLen();

		
	if (nSize){

		//
		// Slide the buffer back - like sinking the data
		//

		MoveMemory(m_pBase,m_pBase+nSize,GetMemSize() - nSize);

		m_pPtr -= nSize;
	}
		
	DeAllocateBuffer(GetBufferLen());

	return nSize;
}
```

`sdk/procmonsdk/buffer.hpp`:

```hpp

#ifndef __BUFFER_INCLUDE__H__
#define __BUFFER_INCLUDE__H__


class CBuffer  
{

public:
	CBuffer();
	CBuffer(PBYTE pData, UINT nSize);
	CBuffer(const CBuffer& Src);
	virtual ~CBuffer();

	CBuffer& operator=(const CBuffer& Src);
	CBuffer& operator+=(const CBuffer& Src);
	bool operator==(const CBuffer& Src);

protected:
	UINT ReAllocateBuffer(UINT nRequestedSize);
	UINT DeAllocateBuffer(UINT nRequestedSize);
	UINT GetMemSize() const;

public:
	void ClearBuffer();
	UINT Delete(UINT nSize);
	UINT Read(PBYTE pData, UINT nSize);
	bool Write(PBYTE pData, UINT nSize);
	UINT GetBufferLen() const;
	BOOL Empty();
	bool Insert(PBYTE pData, UINT nSize);
	void Copy(const CBuffer& buffer);	
	PBYTE GetBuffer(UINT nPos=0) const;
	void Clear();

protected:
	PBYTE m_pBase;
	PBYTE m_pPtr;
	UINT m_nSize;

};

#endif

```

`sdk/procmonsdk/drvload.cxx`:

```cxx

#include "pch.hpp"

#include "drvload.hpp"
#include "logger.hpp"
#include "utils.hpp"
#include <winternl.h>

#pragma comment(lib, "ntdll.lib")

#ifndef NT_SUCCESS
#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#endif

EXTERN_C
NTSYSAPI
NTSTATUS
NtLoadDriver(
	PUNICODE_STRING DriverServiceName
);

EXTERN_C
NTSYSAPI
NTSTATUS
NtUnloadDriver(
	PUNICODE_STRING DriverServiceName
);

#define REGISTRY_PATH_PREFIX		TEXT("System\\CurrentControlSet\\Services\\")
#define SERVICE_IMAGE_PATH_PREFIX	TEXT("\\??\\")
#define DRIVER_SERVICE_NAME_PREFIX	L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\"

CDrvLoader::CDrvLoader()
{

}

CDrvLoader::~CDrvLoader()
{

}

BOOL 
CDrvLoader::Init(
	IN const CString& strDriverName, 
	IN const CString& strDriverPath)
{

	CPath DriverPath(strDriverPath);
	if (DriverPath.IsRelative()){
		TCHAR szFullName[MAX_PATH] = { 0 };
		GetModuleFileName(NULL, szFullName, MAX_PATH);
		PathRemoveFileSpec(szFullName);
		PathAppend(szFullName, DriverPath);
		DriverPath = szFullName;
	}

	if(!DriverPath.FileExists()){
		LogMessage(L_WARN, TEXT("Driver file not exist"));
		return FALSE;
	}else{

		//
		// Try enable driver load privilege
		//

		if (UtilSetPriviledge(SE_LOAD_DRIVER_NAME, TRUE)){
			m_strDriverPath = (LPCTSTR)DriverPath;
			m_strDriverName = strDriverName;

			return TRUE;
		}
	}
	return FALSE;
}

#define STATUS_IMAGE_ALREADY_LOADED ((NTSTATUS)0xC000010EL)

BOOL CDrvLoader::Load()
{
	
	//
	// Delete the service first
	//

	//DeleteServiceKey();

	if (!CreateServiceKey()){
		return FALSE;
	}

	CStringW strDriverSrvName;
	UNICODE_STRING UniDrvSrvName;
	NTSTATUS Status;


	strDriverSrvName = DRIVER_SERVICE_NAME_PREFIX;
	strDriverSrvName += CT2W(m_strDriverName);

	RtlInitUnicodeString(&UniDrvSrvName, strDriverSrvName);
	Status = NtLoadDriver(&UniDrvSrvName);

	if (!NT_SUCCESS(Status) && Status != STATUS_IMAGE_ALREADY_LOADED){
		LogMessage(L_ERROR, TEXT("NtLoadDriver Failed code 0x%x"), Status);
		return FALSE;
	}

	return TRUE;
	
}

BOOL CDrvLoader::UnLoad()
{
	CStringW strDrvSrvName;
	UNICODE_STRING UniDrvSrvName;
	NTSTATUS Status;

	strDrvSrvName = DRIVER_SERVICE_NAME_PREFIX;
	strDrvSrvName += m_strDriverName;

	RtlInitUnicodeString(&UniDrvSrvName, strDrvSrvName);
	Status = NtUnloadDriver(&UniDrvSrvName);
	if (!NT_SUCCESS(Status)) {
		LogMessage(L_ERROR, TEXT("NtUnloadDriver Failed code 0x%x"), Status);
		return FALSE;
	}

	return TRUE;
}

BOOL CDrvLoader::CreateServiceInstanceKey(HKEY hKey)
{
	HKEY hKeySubIns;
	HKEY hKeyInstance;
	CString strTemp;
	DWORD Data = 3;

	RegSetValueEx(hKey, TEXT("SupportedFeatures"), 0, REG_DWORD, (const BYTE*)&Data, sizeof(DWORD));
	RegCreateKey(hKey, TEXT("Instances"), &hKeyInstance);

	strTemp = TEXT("Process Monitor 24 Instance");
	RegSetValueEx(hKeyInstance, TEXT("DefaultInstance"), 0, REG_SZ, (const BYTE*)strTemp.GetBuffer(),
		(DWORD)(((DWORD)strTemp.GetLength() + 1) * sizeof(TCHAR)));
	RegCreateKey(hKeyInstance, TEXT("Process Monitor 24 Instance"), &hKeySubIns);

	strTemp = TEXT("385200");
	RegSetValueEx(hKeySubIns, TEXT("Altitude"), 0, REG_SZ, (const BYTE*)strTemp.GetBuffer(), 
		(DWORD)(((DWORD)strTemp.GetLength() + 1) * sizeof(TCHAR)));
	Data = 0;
	RegSetValueEx(hKeySubIns, TEXT("Flags"), 0, REG_DWORD, (const BYTE*)&Data, sizeof(DWORD));

	RegCloseKey(hKeySubIns);
	RegCloseKey(hKeyInstance);

	return TRUE;
}

BOOL CDrvLoader::CreateServiceKey()
{
	CString strRegistryPath;
	HKEY hKey;
	LSTATUS dwErrorCode;
	DWORD dwDisposition;
	CString strServiceImagePath;
	DWORD dwImagPathSize;

	if (!IsReady()) {
		return FALSE;
	}

	//
	// Format registry path
	//

	strRegistryPath = REGISTRY_PATH_PREFIX;
	strRegistryPath += m_strDriverName;

	//
	// Convert dos path to nt path
	//

	strServiceImagePath = SERVICE_IMAGE_PATH_PREFIX;
	strServiceImagePath += m_strDriverPath;

	dwErrorCode = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
		strRegistryPath.GetBuffer(),
		0,
		NULL,
		0,
		KEY_ALL_ACCESS,
		NULL,
		&hKey,
		&dwDisposition);
	if (ERROR_SUCCESS != dwErrorCode) {
		return FALSE;
	}

	//
	// The key exist?
	//

	if (dwDisposition != REG_CREATED_NEW_KEY) {
		LogMessage(L_WARN, TEXT("RegCreateKeyEx return REG_CREATED_NEW_KEY"));
		//RegCloseKey(hKey);
		//return TRUE;
	}

	dwImagPathSize = (DWORD)(((DWORD)strServiceImagePath.GetLength() + 1) * sizeof(TCHAR));
	dwErrorCode = RegSetValueEx(hKey,
		TEXT("ImagePath"),
		0,
		REG_EXPAND_SZ,
		(const BYTE*)strServiceImagePath.GetBuffer(),
		dwImagPathSize);
	if (ERROR_SUCCESS != dwErrorCode) {
		RegCloseKey(hKey);
		return FALSE;
	}

	//
	// Set type
	//

	DWORD dwServiceType = 1;
	dwErrorCode = RegSetValueEx(hKey,
		TEXT("Type"),
		0,
		REG_DWORD,
		(const BYTE*)&dwServiceType,
		sizeof(dwServiceType));
	if (dwErrorCode) {
		RegCloseKey(hKey);
		return dwErrorCode;
	}

	//
	// Set error control
	//

	DWORD dwServiceErrorControl = 1;
	dwErrorCode = RegSetValueEx(hKey,
		TEXT("ErrorControl"),
		0,
		REG_DWORD,
		(const BYTE*)&dwServiceErrorControl,
		sizeof(DWORD));
	if (dwErrorCode) {
		RegCloseKey(hKey);
		return dwErrorCode;
	}

	DWORD dwServiceStart = 3;
	dwErrorCode = RegSetValueEx(hKey,
		TEXT("Start"),
		0,
		REG_DWORD,
		(const BYTE*)&dwServiceStart,
		sizeof(dwServiceStart));

	CreateServiceInstanceKey(hKey);

	//
	// Finish cleanup
	//

	RegCloseKey(hKey);
	return TRUE;
}

VOID CDrvLoader::DeleteServiceKey()
{
	CString strRegistryPath;
	
	if (!IsReady()){
		return;
	}

	//
	// Format service registry path
	//

	strRegistryPath = REGISTRY_PATH_PREFIX;
	strRegistryPath += m_strDriverName;

	SHDeleteKey(HKEY_LOCAL_MACHINE, strRegistryPath);
}

BOOL CDrvLoader::IsReady()
{
	if (!m_strDriverName ||
		!m_strDriverPath) {
		return FALSE;
	}
	return TRUE;
}

```

`sdk/procmonsdk/drvload.hpp`:

```hpp
#pragma once


class CDrvLoader
{
public:
	CDrvLoader();
	virtual ~CDrvLoader();

public:

	BOOL Init(
		IN const CString& strDriverName,
		IN const CString& strDriverPath);

	BOOL Load();
	BOOL UnLoad();
	BOOL IsReady();

private:

	BOOL CreateServiceKey();
	BOOL CreateServiceInstanceKey(HKEY hKey);
	VOID DeleteServiceKey();

private:

	CString m_strDriverName;
	CString m_strDriverPath;
};
```

`sdk/procmonsdk/event.cxx`:

```cxx

#include "pch.hpp"
#include "event.hpp"
#include "eventview.hpp"
#include "procmgr.hpp"

#include <assert.h>

USHORT CLogEvent::GetNotifyType()
{
	if (m_Prelog.Empty()) {
		return -1;
	}
	PLOG_ENTRY pEntry = (PLOG_ENTRY)m_Prelog.GetBuffer();
	return pEntry->NotifyType;
}

USHORT CLogEvent::GetMoniterType()
{
	if (m_Prelog.Empty()) {
		return -1;
	}
	return reinterpret_cast<PLOG_ENTRY>(m_Prelog.GetBuffer())->MonitorType;
}


DWORD CLogEvent::GetProcSeq()
{
	if (m_Prelog.Empty()) {
		return -1;
	}
	return reinterpret_cast<PLOG_ENTRY>(m_Prelog.GetBuffer())->ProcessSeq;
}

DWORD CLogEvent::GetSeq()
{
	if (m_Prelog.Empty()) {
		return -1;
	}
	return reinterpret_cast<PLOG_ENTRY>(m_Prelog.GetBuffer())->Sequence;
}

CString CLogEvent::GetPath()
{
	return TEXT("");
}

CString CLogEvent::GetDetail()
{
	return TEXT("");
}

CBuffer& CLogEvent::getPreLog()
{
	return m_Prelog;
}

CBuffer& CLogEvent::getPostLog()
{
	return m_Postlog;
}

VOID CLogEvent::setPreLog(const PLOG_ENTRY pEntry)
{
	ULONG EntryLength = CALC_ENTRY_SIZE(pEntry);
	m_Prelog.Write((PBYTE)pEntry, EntryLength);
}

VOID CLogEvent::setPostLog(const PLOG_ENTRY pEntry)
{
	ULONG EntryLength = CALC_ENTRY_SIZE(pEntry);
	m_Postlog.Write((PBYTE)pEntry, EntryLength);
}

```

`sdk/procmonsdk/event.hpp`:

```hpp
#pragma once

class CLogEvent : public CRefBase
{
public:
	CLogEvent() {};
	virtual ~CLogEvent() {};

public:

	CBuffer& getPreLog();
	CBuffer& getPostLog();

	VOID setPreLog(const PLOG_ENTRY pEntry);
	VOID setPostLog(const PLOG_ENTRY pEntry);

	USHORT GetNotifyType();
	USHORT GetMoniterType();
	DWORD GetProcSeq();
	DWORD GetSeq();

public:
	virtual CString GetPath();
	virtual CString GetDetail();

private:

	CBuffer m_Prelog;
	CBuffer m_Postlog;
};



```

`sdk/procmonsdk/eventfactory.cxx`:

```cxx

#include "pch.hpp"
#include "event.hpp"
#include "procopt.hpp"
#include "fileopt.hpp"
#include "regopt.hpp"
#include "eventfactory.hpp"

CRefPtr<CLogEvent> CEventFactory::CreateInstance(int EventClass)
{
	switch (EventClass)
	{
	case MONITOR_TYPE_PROCESS:
		return new CProcEvent;
	case MONITOR_TYPE_FILE:
		return new CFileEvent;
	case MONITOR_TYPE_REG:
		return new CRegEvent;
	default:
		return NULL;
	}
}


```

`sdk/procmonsdk/eventfactory.hpp`:

```hpp
#pragma once

class CEventFactory
{
public:
	static CRefPtr<CLogEvent> CreateInstance(int EventClass);
};
```

`sdk/procmonsdk/eventmgr.cxx`:

```cxx

#include "pch.hpp"
#include "logger.hpp"
#include "process.hpp"
#include "eventview.hpp"
#include "procmgr.hpp"
#include "eventmgr.hpp"
#include "procopt.hpp"
#include "eventfactory.hpp"

#include <conio.h>

CEventMgr::CEventMgr()
{
	RegisterProcessor(new CProcOpt);
}

BOOL
CEventMgr::ProcessMsgBlocks(
	_In_ PLOG_ENTRY pEntries,
	_In_ ULONG Length)
{
	ULONG TotalLength = 0;
	PLOG_ENTRY pEntry;
	pEntry = pEntries;
	if (!Length || !pEntries || Length < sizeof(LOG_ENTRY)){
		return FALSE;
	}

	while (TRUE)
	{

		//
		// Process Entry
		//


		ProcessEntry(pEntry);

		//
		// calc entry length
		//

		ULONG EntryLength = CALC_ENTRY_SIZE(pEntry);

		TotalLength += EntryLength;
		if (TotalLength >= Length) {
			break;
		}

		//
		// Next Entry
		//

		pEntry = (PLOG_ENTRY)((ULONG_PTR)pEntry + EntryLength);
	}

	return TRUE;
}

BOOL
CEventMgr::ProcessEntry(
	_In_ const PLOG_ENTRY pEntry
)
{
	//
	// filter the type
	//

	if (pEntry->MonitorType > MONITOR_TYPE_PROFILING ||
		pEntry->MonitorType < MONITOR_TYPE_POST) {
		return FALSE;
	}

	//
	// TODO: support thread profiling
	//

	if (pEntry->MonitorType == MONITOR_TYPE_PROFILING) {
		return TRUE;
	}

	//
	// Filter ourself
	//

	if (pEntry->MonitorType == MONITOR_TYPE_POST) {


		//
		// find the pre-operator
		//

		auto pEvent = RefEvent(pEntry->Sequence);
		if (pEvent.IsNull()) {
			return FALSE;
		}

		//
		// Set the post log
		//

		pEvent->setPostLog(pEntry);

		//
		// this operator is finish add to queue
		//

		PushEvent(pEvent);

		//
		// 将这个Operator在列表中移除
		//

		RemoveFromList(pEntry->Sequence);

	}else{

		//
		// If Status == STATUS_PENDING
		// is will has POST opt
		//

		CRefPtr<CLogEvent> newEvent = CEventFactory::CreateInstance(pEntry->MonitorType);
		newEvent->setPreLog(pEntry);

		if (pEntry->Status == STATUS_PENDING) {

			//
			// Insert to map
			//

			InsertOperator(pEntry->Sequence, newEvent);

		}else{
			PushEvent(newEvent);
		}
	}

	return TRUE;
}

VOID CEventMgr::InsertOperator(ULONG Seq, CRefPtr<CLogEvent> pEvent)
{
	m_EventMap.insert(std::make_pair(Seq, pEvent));
}

CRefPtr<CLogEvent> CEventMgr::RefEvent(ULONG Seq)
{
	EVENT_MAP::iterator it;
	it = m_EventMap.find(Seq);
	if (it != m_EventMap.end()) {
		return it->second;
	}

	return NULL;
}

VOID CEventMgr::RemoveFromList(ULONG Seq)
{
	CRefPtr<CLogEvent> OptFind = RefEvent(Seq);
	if (!OptFind.IsNull()) {
		m_EventMap.erase(Seq);
	}else{
		LogMessage(L_INFO, TEXT("Remove Opt seq 0x%x is not exist in list"), Seq);
		//__debugbreak();
		//_getch();
	}
}

BOOL CEventMgr::Process()
{

	//
	// Get one from Operator Queue
	//

	CRefPtr<CLogEvent> pEvent = PopEvent();
	if (pEvent.IsNull()) {
		return FALSE;
	}

	for (auto it = m_Processors.begin(); it != m_Processors.end(); it++)
	{
		PLOG_ENTRY pPreEntry = (PLOG_ENTRY)pEvent->getPreLog().GetBuffer();
		if ((*it)->IsType(pPreEntry->MonitorType)) {

			//
			// pre process
			//

			(*it)->Process(pEvent);
			break;
		}
	}

	//
	// gen view
	//

	CRefPtr<CProcess> pProcess = PROCMGR().RefProcessBySeq(pEvent->GetProcSeq());
	if (!pProcess.IsNull()) {

		CRefPtr <CEventView> pView = new CEventView;
		pView->SetEventOpt(pEvent);
		pView->SnapProcess(pProcess);

		//
		// do callback
		//

		for (auto itcall = m_callBackList.begin(); itcall != m_callBackList.end(); itcall++)
		{
			(*itcall)->DoEvent(pView);
		}
	}


	return TRUE;

}

VOID CEventMgr::RegisterProcessor(CRefPtr<IProcessor> Processor)
{
	m_Processors.push_back(Processor);
}

VOID CEventMgr::RegisterCallback(CRefPtr<IEventCallback> pCallback)
{
	m_callBackList.push_back(pCallback);
}

VOID CEventMgr::Clear()
{
	m_lock.lock();
	while (!m_msgQueue.empty()) {
		m_msgQueue.pop();
	}
	m_lock.unlock();

	m_EventMap.clear();
	m_PushCount = 0;
	m_PopCount = 0;
}

VOID CEventMgr::PushEvent(CRefPtr<CLogEvent> pEvent)
{
	std::unique_lock<std::mutex> lck(m_lock);
	m_msgQueue.push(pEvent);

	//
	// Notify process thread the log data coming
	//

	m_PushCount++;
	m_convar.notify_all();
}

CRefPtr<CLogEvent> CEventMgr::PopEvent()
{
	CRefPtr<CLogEvent> pEvent;
	std::unique_lock<std::mutex> lck(m_lock);

	//
	// wait until data coming
	//

	while (TRUE)
	{
		if (m_msgQueue.empty()) {
			if (m_convar.wait_for(lck, std::chrono::milliseconds(500)) == std::cv_status::no_timeout) {
				
				//
				// here some event coming
				// but here will be some fake signal 
				//
				
 				if (m_msgQueue.empty()){
 					continue;
 				}else{
 					break;
 				}

			}else{
				
				//
				// here wait time out we just return NULL 
				// to give a chance to loop to check is the thread what to exist
				//
				
				return NULL;
			}
		}else{
			break;
		}
	}

	m_PopCount++;

	//
	// get the front of the queue
	//

	pEvent = m_msgQueue.front();
	m_msgQueue.pop();

	return pEvent;
}

```

`sdk/procmonsdk/eventmgr.hpp`:

```hpp
#pragma once

#include "event.hpp"
#include "eventview.hpp"

#define EVENTMGR() Singleton<CEventMgr>::getInstance()

class IProcessor : public CRefBase
{
public:
	virtual BOOL Process(const CRefPtr<CLogEvent> pEvent) = 0;
	virtual BOOL IsType(ULONG MonitorType) = 0;
};

class IEventCallback : public CRefBase
{
public:
	virtual BOOL DoEvent(const CRefPtr<CEventView> pEventView) = 0;
};

typedef std::map<ULONG, CRefPtr<CLogEvent>> EVENT_MAP;
typedef std::vector<CRefPtr<IProcessor>> PROCESSOR_LIST;


class CEventMgr
{
public:
	CEventMgr();
	virtual ~CEventMgr() {};

public:


	//
	// Call from recv msg thread
	//

	BOOL ProcessMsgBlocks(
		_In_ PLOG_ENTRY pEntries,
		_In_ ULONG Length);

	BOOL ProcessEntry(
		_In_ const PLOG_ENTRY pEntry);

	//
	// Call from process thread
	//

	BOOL Process();

	//
	// Call from global
	//

	VOID RegisterProcessor(CRefPtr<IProcessor> Processor);

	//
	// 
	//

	VOID RegisterCallback(CRefPtr<IEventCallback> pCallback);

	VOID Clear();


private:
	VOID InsertOperator(ULONG Seq, CRefPtr<CLogEvent> pEvent);
	CRefPtr<CLogEvent> RefEvent(ULONG Seq);
	VOID RemoveFromList(ULONG Seq);

	VOID PushEvent(CRefPtr<CLogEvent> pEvent);
	CRefPtr<CLogEvent> PopEvent();

private:
	EVENT_MAP m_EventMap;
	PROCESSOR_LIST m_Processors;
	std::vector<CRefPtr<IEventCallback>> m_callBackList;

	std::condition_variable m_convar;
	std::mutex m_lock;
	std::queue<CRefPtr<CLogEvent>> m_msgQueue;

	DWORD m_PushCount = 0;
	DWORD m_PopCount = 0;
};
```

`sdk/procmonsdk/eventview.cxx`:

```cxx

#include "pch.hpp"
#include "eventview.hpp"
#include "process.hpp"
#include "utils.hpp"
#include "strmaps.hpp"

CEventView::CEventView()
{

}

CEventView::~CEventView()
{

}

void CEventView::SetEventOpt(CRefPtr<CLogEvent> pEvent)
{
	m_EventView = pEvent;
}

void CEventView::SnapProcess(CRefPtr<CProcess> pProcess)
{
	m_ProcView = pProcess->GetEvent();
	m_ModuleInfo = pProcess->GetModuleList();
	m_ProcInfo = pProcess->GetProcInfo();
}

DWORD CEventView::GetSeqNumber()
{
	return m_EventView.GetSeqNumber();
}

DWORD CEventView::GetEventClass()
{
	return m_EventView.GetEventClass();
}

DWORD CEventView::GetEventOperator()
{
	return m_EventView.GetOperator();
}

LARGE_INTEGER CEventView::GetStartTime()
{

	return m_EventView.GetStartTime();
}

LARGE_INTEGER CEventView::GetCompleteTime()
{
	return m_EventView.GetCompleteTime();
}

CString CEventView::GetPath()
{
	return m_EventView.GetPath();
}

CString CEventView::GetDetail()
{
	return m_EventView.GetDetail();
}

NTSTATUS CEventView::GetResult()
{
	return m_EventView.GetResult();
}

DWORD CEventView::GetCallStack(std::vector<PVOID>& callStacks)
{
	return m_EventView.GetCallStack(callStacks);
}

DWORD CEventView::GetProcessSeq()
{
	return m_EventView.GetProcessSeq();
}

PLOG_ENTRY CEventView::GetPreEventEntry()
{
	if (!m_EventView.GetEvent().IsNull()){
		if (m_EventView.GetEvent()->getPreLog().GetBufferLen()){
			return reinterpret_cast<PLOG_ENTRY>(m_EventView.GetEvent()->getPreLog().GetBuffer());
		}
	}
	return NULL;
	
}

PLOG_ENTRY CEventView::GetPostEventEntry()
{
	if (!m_EventView.GetEvent().IsNull()) {
		if (m_EventView.GetEvent()->getPostLog().GetBufferLen()) {
			return reinterpret_cast<PLOG_ENTRY>(m_EventView.GetEvent()->getPostLog().GetBuffer());
		}
	}
	return NULL;
}

DWORD CEventView::GetProcessId()
{
	return m_ProcView.GetProcessId();
}

DWORD CEventView::GetSessionId()
{
	return m_ProcView.GetSessionId();
}

DWORD CEventView::GetThreadId()
{
	return m_EventView.GetThreadId();
}

DWORD CEventView::GetParentProcessId()
{
	return m_ProcView.GetParentProcessId();
}

LUID CEventView::GetAuthId()
{
	return m_ProcView.GetAuthId();
}

CString CEventView::GetUserName()
{
	return m_ProcView.GetUserName();
}

PSID CEventView::GetUserSid()
{
	return m_ProcView.GetUserSid();
}

DWORD CEventView::GetIntegrity()
{
	return m_ProcView.GetIntegrity();
}

BOOL CEventView::IsVirtualize()
{
	return m_ProcView.IsVirtualize();
}

CString CEventView::GetProcessName()
{
	return m_ProcView.GetProcessName();
}

CString CEventView::GetImagePath()
{
	return m_ProcView.GetImagePath();
}

CString CEventView::GetCommandLine()
{
	return m_ProcView.GetCommandLine();
}

BOOL CEventView::IsWow64()
{
	return m_ProcView.IsWow64();
}


CBuffer& CEventView::GetProcIcon(BOOL bSmall)
{
	if (bSmall) {
		return m_ProcInfo->GetSmallIcon();
	}else{
		return m_ProcInfo->GetLargeIcon();
	}
}

const CString& CEventView::GetCompanyName()
{
	return m_ProcInfo->GetCompanyName();
}

const CString& CEventView::GetDisplayName()
{
	return m_ProcInfo->GetDisplayName();
}

const CString& CEventView::GetVersion()
{
	return m_ProcInfo->GetVersion();
}

std::vector<CModule>& CEventView::GetModuleList()
{
	return m_ModuleInfo;
}

BOOL CEventView::IsProcessExit()
{
	ULONG Seq = m_EventView.GetProcessSeq();
	CProcMgr& procMgr = Singleton<CProcMgr>::getInstance();

	CRefPtr<CProcess> pProcess = procMgr.RefProcessBySeq(Seq);
	if (pProcess.IsNull()) {
		return TRUE;
	}else{
		return pProcess->IsMarkExit();
	}
}

LARGE_INTEGER CEventView::GetProcessExitTime()
{
	LARGE_INTEGER ExitTime;
	ULONG Seq = m_EventView.GetProcessSeq();
	CProcMgr& procMgr = Singleton<CProcMgr>::getInstance();

	ExitTime.QuadPart = 0;

	CRefPtr<CProcess> pProcess = procMgr.RefProcessBySeq(Seq);
	if (!pProcess.IsNull()) {
		CRefPtr<CLogEvent> pExitEvent = pProcess->GetExitEvent();
		if (!pExitEvent.IsNull()) {
			CBaseView baseView(pExitEvent);
			return baseView.GetStartTime();
		}
	}

	return ExitTime;
}

BOOL CEventView::IsProcessFromInit()
{
	return m_ProcView.GetOperator() == NOTIFY_PROCESS_INIT;
}

CString
CEventView::GetOperationStrResult(
	_In_ MAP_SOURCE_TYPE SrcType
)
{
	CString strSrc;
	switch (SrcType)
	{
	case emArchiteture:
		strSrc = IsWow64() ? TEXT("32-bit") : TEXT("64-bit");
		break;
	case emAuthId:
		LUID AuthId = GetAuthId();
		strSrc.Format(TEXT("%08x:%08x"), AuthId.HighPart, AuthId.LowPart);
		break;
	case emCategory:
		break;
	case emCommandLine:
		strSrc = GetCommandLine();
		break;
	case emCompany:
		strSrc = GetCompanyName();
		break;
	case emCompletionTime:
		strSrc = UtilConvertTimeOfDay(GetCompleteTime());
		break;
	case emDataTime:
		strSrc = UtilConvertDay(GetStartTime());
		break;
	case emDescription:
		strSrc = GetDisplayName();
		break;
	case emDetail:
		strSrc = GetDetail();
		break;
	case emDuration:

		//
		// TODO
		//

		break;
	case emEventClass:
		strSrc = StrMapClassEvent(GetEventClass());
		break;
	case emImagePath:
		strSrc = GetImagePath();
		break;
	case emIntegrity:
		strSrc = StrMapIntegrityLevel(GetIntegrity());
		break;
	case emOperation:
		strSrc = StrMapOperation(GetPreEventEntry());
		break;
	case emParentPid:
		strSrc.Format(TEXT("%d"), GetParentProcessId());
		break;
	case emPath:
		strSrc = GetPath();
		break;
	case emPID:
		strSrc.Format(TEXT("%d"), GetProcessId());
		break;
	case emProcessName:
		strSrc = GetProcessName();
		break;
	case emRelativeTime:

		//
		// TODO
		//

		break;
	case emResult:
		strSrc = StrMapNtStatus(GetResult());
		break;
	case emSequence:
		strSrc.Format(TEXT("%lu"), GetSeqNumber());
		break;
	case emSession:
		strSrc.Format(TEXT("%u"), GetSessionId());
		break;
	case emTID:
		strSrc.Format(TEXT("%d"), GetThreadId());
		break;
	case emTimeOfDay:
		strSrc = UtilConvertTimeOfDay(GetStartTime());
		break;
	case emUser:
		strSrc = StrMapUserNameFromSid(GetUserSid());
		break;
	case emVersion:
		strSrc = GetVersion();
		break;
	case emVirtualize:
		strSrc = IsVirtualize() ? TEXT("True") : TEXT("False");
	default:
		break;
	}

	return strSrc;
}


```

`sdk/procmonsdk/eventview.hpp`:

```hpp
#pragma once

#include "event.hpp"
#include "process.hpp"
#include "procmgr.hpp"

typedef enum _MAP_SOURCE_TYPE
{
	emArchiteture = 0,
	emAuthId,
	emCategory,
	emCommandLine,
	emCompany,
	emCompletionTime,
	emDataTime,
	emDescription,
	emDetail,
	emDuration,
	emEventClass,
	emImagePath,
	emIntegrity,
	emOperation,
	emParentPid,
	emPath,
	emPID,
	emProcessName,
	emRelativeTime,
	emResult,
	emSequence,
	emSession,
	emTID,
	emTimeOfDay,
	emUser,
	emVersion,
	emVirtualize,
	emInvalid,
}MAP_SOURCE_TYPE;

class CEventView : public CRefBase
{

public:
	CEventView();
	~CEventView();

public:

	void SetEventOpt(CRefPtr<CLogEvent> pEvent);
	void SnapProcess(CRefPtr<CProcess> pProcess);

public:
	
	BOOL IsReady();

	//
	// For Event
	//
	
	DWORD GetSeqNumber();
	DWORD GetEventClass();
	DWORD GetEventOperator();
	LARGE_INTEGER GetStartTime();
	LARGE_INTEGER GetCompleteTime();
	CString GetPath();
	CString GetDetail();
	NTSTATUS GetResult();
	DWORD GetCallStack(std::vector<PVOID>& callStacks);
	DWORD GetProcessSeq();
	PLOG_ENTRY GetPreEventEntry();
	PLOG_ENTRY GetPostEventEntry();

	//
	// for Process
	//
	
	DWORD GetProcessId();
	DWORD GetSessionId();
	DWORD GetThreadId();
	DWORD GetParentProcessId();
	LUID GetAuthId();
	CString GetUserName();
	PSID GetUserSid();
	DWORD GetIntegrity();
	BOOL IsVirtualize();
	CString GetProcessName();
	CString GetImagePath();
	CString GetCommandLine();
	BOOL IsWow64();

	CBuffer& GetProcIcon(BOOL bSmall = TRUE);
	const CString& GetCompanyName();
	const CString& GetDisplayName();
	const CString& GetVersion();

	std::vector<CModule>& GetModuleList();

	BOOL IsProcessExit();
	LARGE_INTEGER GetProcessExitTime();
	BOOL IsProcessFromInit();
	CString GetOperationStrResult(_In_ MAP_SOURCE_TYPE SrcType);


private:

	CProcInfoView m_ProcView;
	CBaseView m_EventView;

	std::vector<CModule> m_ModuleInfo;
	CRefPtr<CProcInfo> m_ProcInfo;
};
```

`sdk/procmonsdk/fileopt.cxx`:

```cxx

#include "pch.hpp"
#include "procmgr.hpp"
#include "fileopt.hpp"
#include "eventview.hpp"
#include "strmaps.hpp"


CString CFileEvent::GetPath()
{
	PLOG_ENTRY pEntry = reinterpret_cast<PLOG_ENTRY>(getPreLog().GetBuffer());
	PLOG_FILE_OPT pFileOpt = TO_EVENT_DATA(PLOG_FILE_OPT, pEntry);

	CString strFileName;

	if (pFileOpt->NameLength){
		CString strFileNameTmp;
		strFileNameTmp.Append(pFileOpt->Name, pFileOpt->NameLength);
		UtilConvertNtInternalPathToDosPath(strFileNameTmp, strFileName);
	}
	

	return strFileName;
}

CString CFileEvent::GetDetail()
{
	PLOG_ENTRY pEntry = reinterpret_cast<PLOG_ENTRY>(getPreLog().GetBuffer());
	PLOG_ENTRY pPostEntry = reinterpret_cast<PLOG_ENTRY>(getPostLog().GetBuffer());

	PLOG_FILE_OPT pFileOpt = TO_EVENT_DATA(PLOG_FILE_OPT, pEntry);
	UCHAR MajorFunction = pEntry->NotifyType - 20;
	CString strDetail;

	switch (MajorFunction)
	{
	case IRP_MJ_CREATE:
	{
		CString strTemp;

		PLOG_FILE_CREATE pCreateInfo = reinterpret_cast<PLOG_FILE_CREATE>(pFileOpt->Name + pFileOpt->NameLength);

		strTemp.Format(TEXT("DesiredAccess:(0x%x) %s"), 
			pCreateInfo->DesiredAccess,
			(LPCTSTR)StrMapFileAccessMask(pCreateInfo->DesiredAccess));

		strDetail += strTemp;
		strDetail += TEXT("\r\n");

		strTemp.Format(TEXT("Io Status: %s"), StrMapNtStatus(pPostEntry->Status));

		strDetail += strTemp;
		strDetail += TEXT("\r\n");

		strTemp.Format(TEXT("AllocationSize: 0x%llx"), 
			pFileOpt->FltParameter.Create.AllocationSize.QuadPart);
		strDetail += strTemp;
		strDetail += TEXT("\r\n");

		strTemp.Format(TEXT("FileAttributes: (0x%x) %s"), 
			pFileOpt->FltParameter.Create.FileAttributes,
			(LPCTSTR)StrMapFileAttributes(pFileOpt->FltParameter.Create.FileAttributes));
		strDetail += strTemp;
		strDetail += TEXT("\r\n");

		strTemp.Format(TEXT("SharedAccess: (0x%x) %s"), 
			pFileOpt->FltParameter.Create.ShareAccess,
			StrMapFileShareAccess(pFileOpt->FltParameter.Create.ShareAccess).GetBuffer());
		strDetail += strTemp;
		strDetail += TEXT("\r\n");

		DWORD CreateOptions = pFileOpt->FltParameter.Create.Options & 0x00FFFFFF;
		DWORD CreateDisposition = pFileOpt->FltParameter.Create.Options >> 24;

		strTemp.Format(TEXT("CreateOptions: (0x%x) %s"), 
			CreateOptions, 
			(LPCTSTR)StrMapFileCreateOptions(CreateOptions));
		strDetail += strTemp;
		strDetail += TEXT("\r\n");

		strTemp.Format(TEXT("CreateDisposition:(0x%x) %s"), 
			CreateDisposition,
			StrMapFileCreateDisposition(CreateDisposition));
		strDetail += strTemp;
		strDetail += TEXT("\r\n");

		ULONG_PTR* pInformation = TO_EVENT_DATA(ULONG_PTR*, pPostEntry);

		strTemp.Format(TEXT("RetDisposition:(0x%x) %s"),
			(DWORD)*pInformation,
			StrMapFileRetDisposition((DWORD)*pInformation));
		strDetail += strTemp;
		strDetail += TEXT("\r\n");
		
	}
		break;

	case IRP_MJ_SET_SECURITY:
	{
		CString strTemp;
		strTemp.Format(TEXT("SecurityInformation: %s"), 
			StrMapSecurityInformation(pFileOpt->FltParameter.SetSecurity.SecurityInformation).GetBuffer());
		strDetail += strTemp;
		strDetail += TEXT("\r\n");
	}
	break;
	default:
		strDetail = TEXT("TODO");
		break;
	}

	return strDetail;
}

```

`sdk/procmonsdk/fileopt.hpp`:

```hpp
#pragma once


class CFileEvent : public CLogEvent
{
public:
	virtual CString GetPath();
	virtual CString GetDetail();
};
```

`sdk/procmonsdk/fltuser.hpp`:

```hpp

#ifndef __FLTUSER__
#define __FLTUSER__

#include <windows.h>
#include <winternl.h>

#ifdef __cplusplus
extern "C" {
#endif

#if defined(_WIN64)
#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)
#else
#define POINTER_ALIGNMENT
#endif

#define IRP_MJ_CREATE                   0x00
#define IRP_MJ_CREATE_NAMED_PIPE        0x01
#define IRP_MJ_CLOSE                    0x02
#define IRP_MJ_READ                     0x03
#define IRP_MJ_WRITE                    0x04
#define IRP_MJ_QUERY_INFORMATION        0x05
#define IRP_MJ_SET_INFORMATION          0x06
#define IRP_MJ_QUERY_EA                 0x07
#define IRP_MJ_SET_EA                   0x08
#define IRP_MJ_FLUSH_BUFFERS            0x09
#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a
#define IRP_MJ_SET_VOLUME_INFORMATION   0x0b
#define IRP_MJ_DIRECTORY_CONTROL        0x0c
#define IRP_MJ_FILE_SYSTEM_CONTROL      0x0d
#define IRP_MJ_DEVICE_CONTROL           0x0e
#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0f
#define IRP_MJ_SHUTDOWN                 0x10
#define IRP_MJ_LOCK_CONTROL             0x11
#define IRP_MJ_CLEANUP                  0x12
#define IRP_MJ_CREATE_MAILSLOT          0x13
#define IRP_MJ_QUERY_SECURITY           0x14
#define IRP_MJ_SET_SECURITY             0x15
#define IRP_MJ_POWER                    0x16
#define IRP_MJ_SYSTEM_CONTROL           0x17
#define IRP_MJ_DEVICE_CHANGE            0x18
#define IRP_MJ_QUERY_QUOTA              0x19
#define IRP_MJ_SET_QUOTA                0x1a
#define IRP_MJ_PNP                      0x1b

#define IRP_MJ_ACQUIRE_FOR_SECTION_SYNCHRONIZATION   ((UCHAR)-1)
#define IRP_MJ_RELEASE_FOR_SECTION_SYNCHRONIZATION   ((UCHAR)-2)
#define IRP_MJ_ACQUIRE_FOR_MOD_WRITE                 ((UCHAR)-3)
#define IRP_MJ_RELEASE_FOR_MOD_WRITE                 ((UCHAR)-4)
#define IRP_MJ_ACQUIRE_FOR_CC_FLUSH                  ((UCHAR)-5)
#define IRP_MJ_RELEASE_FOR_CC_FLUSH                  ((UCHAR)-6)
#define IRP_MJ_QUERY_OPEN                            ((UCHAR)-7)

#define IRP_MJ_FAST_IO_CHECK_IF_POSSIBLE             ((UCHAR)-13)
#define IRP_MJ_NETWORK_QUERY_OPEN                    ((UCHAR)-14)
#define IRP_MJ_MDL_READ                              ((UCHAR)-15)
#define IRP_MJ_MDL_READ_COMPLETE                     ((UCHAR)-16)
#define IRP_MJ_PREPARE_MDL_WRITE                     ((UCHAR)-17)
#define IRP_MJ_MDL_WRITE_COMPLETE                    ((UCHAR)-18)
#define IRP_MJ_VOLUME_MOUNT                          ((UCHAR)-19)
#define IRP_MJ_VOLUME_DISMOUNT                       ((UCHAR)-20)


typedef enum _DIRECTORY_NOTIFY_INFORMATION_CLASS {
	DirectoryNotifyInformation = 1,
	DirectoryNotifyExtendedInformation // 2
} DIRECTORY_NOTIFY_INFORMATION_CLASS, * PDIRECTORY_NOTIFY_INFORMATION_CLASS;

typedef enum _FSINFOCLASS {
	FileFsVolumeInformation = 1,
	FileFsLabelInformation,         // 2
	FileFsSizeInformation,          // 3
	FileFsDeviceInformation,        // 4
	FileFsAttributeInformation,     // 5
	FileFsControlInformation,       // 6
	FileFsFullSizeInformation,      // 7
	FileFsObjectIdInformation,      // 8
	FileFsDriverPathInformation,    // 9
	FileFsVolumeFlagsInformation,   // 10
	FileFsSectorSizeInformation,    // 11
	FileFsDataCopyInformation,      // 12
	FileFsMetadataSizeInformation,  // 13
	FileFsFullSizeInformationEx,    // 14
	FileFsMaximumInformation
} FS_INFORMATION_CLASS, * PFS_INFORMATION_CLASS;

typedef enum _DEVICE_RELATION_TYPE {
	BusRelations,
	EjectionRelations,
	PowerRelations,
	RemovalRelations,
	TargetDeviceRelation,
	SingleBusRelations,
	TransportRelations
} DEVICE_RELATION_TYPE, * PDEVICE_RELATION_TYPE;

typedef enum {
	BusQueryDeviceID = 0,       // <Enumerator>\<Enumerator-specific device id>
	BusQueryHardwareIDs = 1,    // Hardware ids
	BusQueryCompatibleIDs = 2,  // compatible device ids
	BusQueryInstanceID = 3,     // persistent id for this instance of the device
	BusQueryDeviceSerialNumber = 4,   // serial number for this device
	BusQueryContainerID = 5     // unique id of the device's physical container
} BUS_QUERY_ID_TYPE, * PBUS_QUERY_ID_TYPE;

typedef enum {
	DeviceTextDescription = 0,            // DeviceDesc property
	DeviceTextLocationInformation = 1     // DeviceLocation property
} DEVICE_TEXT_TYPE, * PDEVICE_TEXT_TYPE;


typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE {
	DeviceUsageTypeUndefined,
	DeviceUsageTypePaging,
	DeviceUsageTypeHibernation,
	DeviceUsageTypeDumpFile,
	DeviceUsageTypeBoot,
	DeviceUsageTypePostDisplay,
	DeviceUsageTypeGuestAssigned
} DEVICE_USAGE_NOTIFICATION_TYPE;

typedef enum _FS_FILTER_SECTION_SYNC_TYPE {
	SyncTypeOther = 0,
	SyncTypeCreateSection
} FS_FILTER_SECTION_SYNC_TYPE, * PFS_FILTER_SECTION_SYNC_TYPE;

typedef struct _FS_FILTER_SECTION_SYNC_OUTPUT {
	ULONG StructureSize;
	ULONG SizeReturned;
	ULONG Flags;
	ULONG DesiredReadAlignment;
} FS_FILTER_SECTION_SYNC_OUTPUT, * PFS_FILTER_SECTION_SYNC_OUTPUT;

typedef union _FLT_PARAMETERS {

	//
	//  IRP_MJ_CREATE
	//

	struct {
		PVOID SecurityContext;

		//
		//  The low 24 bits contains CreateOptions flag values.
		//  The high 8 bits contains the CreateDisposition values.
		//

		ULONG Options;

		USHORT POINTER_ALIGNMENT FileAttributes;
		USHORT ShareAccess;
		ULONG POINTER_ALIGNMENT EaLength;

		PVOID EaBuffer;                 //Not in IO_STACK_LOCATION parameters list
		LARGE_INTEGER AllocationSize;   //Not in IO_STACK_LOCATION parameters list
	} Create;

	//
	//  IRP_MJ_CREATE_NAMED_PIPE
	//
	//  Notice that the fields in the following parameter structure must
	//  match those for the create structure other than the last longword.
	//  This is so that no distinctions need be made by the I/O system's
	//  parse routine other than for the last longword.
	//

	struct {
		PVOID SecurityContext;
		ULONG Options;
		USHORT POINTER_ALIGNMENT Reserved;
		USHORT ShareAccess;
		PVOID Parameters; // PNAMED_PIPE_CREATE_PARAMETERS
	} CreatePipe;

	//
	//  IRP_MJ_CREATE_MAILSLOT
	//
	//  Notice that the fields in the following parameter structure must
	//  match those for the create structure other than the last longword.
	//  This is so that no distinctions need be made by the I/O system's
	//  parse routine other than for the last longword.
	//

	struct {
		PVOID SecurityContext;
		ULONG Options;
		USHORT POINTER_ALIGNMENT Reserved;
		USHORT ShareAccess;
		PVOID Parameters; // PMAILSLOT_CREATE_PARAMETERS
	} CreateMailslot;

	//
	//  IRP_MJ_READ
	//

	struct {
		ULONG Length;                   //Length of transfer
		ULONG POINTER_ALIGNMENT Key;
		LARGE_INTEGER ByteOffset;       //Offset to read from

		PVOID ReadBuffer;       //Not in IO_STACK_LOCATION parameters list
		PVOID MdlAddress;        //Mdl address for the buffer  (maybe NULL)
	} Read;

	//
	//  IRP_MJ_WRITE
	//

	struct {
		ULONG Length;                   //Length of transfer
		ULONG POINTER_ALIGNMENT Key;
		LARGE_INTEGER ByteOffset;       //Offset to write to

		PVOID WriteBuffer;      //Not in IO_STACK_LOCATION parameters list
		PVOID MdlAddress;        //Mdl address for the buffer  (maybe NULL)
	} Write;

	//
	//  IRP_MJ_QUERY_INFORMATION
	//

	struct {
		ULONG Length;           //Length of buffer
		FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass; //Class of information to query

		PVOID InfoBuffer;       //Not in IO_STACK_LOCATION parameters list
	} QueryFileInformation;

	//
	//  IRP_MJ_SET_INFORMATION
	//

	struct {
		ULONG Length;
		FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass;
		PVOID ParentOfTarget;
		union {
			struct {
				BOOLEAN ReplaceIfExists;
				BOOLEAN AdvanceOnly;
			};
			ULONG ClusterCount;
			HANDLE DeleteHandle;
		};

		PVOID InfoBuffer;       //Not in IO_STACK_LOCATION parameters list
	} SetFileInformation;

	//
	//  IRP_MJ_QUERY_EA
	//

	struct {
		ULONG Length;
		PVOID EaList;
		ULONG EaListLength;
		ULONG POINTER_ALIGNMENT EaIndex;

		PVOID EaBuffer;         //Not in IO_STACK_LOCATION parameters list
		PVOID MdlAddress;        //Mdl address for the buffer  (maybe NULL)
	} QueryEa;

	//
	//  IRP_MJ_SET_EA
	//

	struct {
		ULONG Length;

		PVOID EaBuffer;         //Not in IO_STACK_LOCATION parameters list
		PVOID MdlAddress;        //Mdl address for the buffer  (maybe NULL)
	} SetEa;

	//
	//  IRP_MJ_QUERY_VOLUME_INFORMATION
	//

	struct {
		ULONG Length;
		FS_INFORMATION_CLASS POINTER_ALIGNMENT FsInformationClass;

		PVOID VolumeBuffer;     //Not in IO_STACK_LOCATION parameters list
	} QueryVolumeInformation;

	//
	//  IRP_MJ_SET_VOLUME_INFORMATION
	//

	struct {
		ULONG Length;
		FS_INFORMATION_CLASS POINTER_ALIGNMENT FsInformationClass;

		PVOID VolumeBuffer;     //Not in IO_STACK_LOCATION parameters list
	} SetVolumeInformation;

	//
	//  IRP_MJ_DIRECTORY_CONTROL
	//

	union {

		//
		//  IRP_MN_QUERY_DIRECTORY or IRP_MN_QUERY_OLE_DIRECTORY
		//

		struct {
			ULONG Length;
			PUNICODE_STRING FileName;
			FILE_INFORMATION_CLASS FileInformationClass;
			ULONG POINTER_ALIGNMENT FileIndex;

			PVOID DirectoryBuffer;  //Not in IO_STACK_LOCATION parameters list
			PVOID MdlAddress;        //Mdl address for the buffer  (maybe NULL)
		} QueryDirectory;

		//
		//  IRP_MN_NOTIFY_CHANGE_DIRECTORY
		//

		struct {
			ULONG Length;
			ULONG POINTER_ALIGNMENT CompletionFilter;

			//
			// These spares ensure that the offset of DirectoryBuffer is
			// exactly the same as that for QueryDirectory minor code. This
			// needs to be the same because filter manager code makes the assumption
			// they are the same
			//

			ULONG POINTER_ALIGNMENT Spare1;
			ULONG POINTER_ALIGNMENT Spare2;

			PVOID DirectoryBuffer;  //Not in IO_STACK_LOCATION parameters list
			PVOID MdlAddress;        //Mdl address for the buffer  (maybe NULL)
		} NotifyDirectory;

		//
		//  IRP_MN_NOTIFY_CHANGE_DIRECTORY_EX
		//

		struct {
			ULONG Length;
			ULONG POINTER_ALIGNMENT CompletionFilter;

			DIRECTORY_NOTIFY_INFORMATION_CLASS POINTER_ALIGNMENT DirectoryNotifyInformationClass;

			//
			// These spares ensure that the offset of DirectoryBuffer is
			// exactly the same as that for QueryDirectory minor code. This
			// needs to be the same because filter manager code makes the assumption
			// they are the same
			//

			ULONG POINTER_ALIGNMENT Spare2;

			PVOID DirectoryBuffer;  //Not in IO_STACK_LOCATION parameters list
			PVOID MdlAddress;        //Mdl address for the buffer  (maybe NULL)
		} NotifyDirectoryEx;

	} DirectoryControl;

	//
	//  IRP_MJ_FILE_SYSTEM_CONTROL
	//
	//  Note that the user's output buffer is stored in the UserBuffer field
	//  and the user's input buffer is stored in the SystemBuffer field.
	//

	union {

		//
		//  IRP_MN_VERIFY_VOLUME
		//

		struct {
			PVOID Vpb;
			PVOID DeviceObject;
		} VerifyVolume;

		//
		//  IRP_MN_KERNEL_CALL and IRP_MN_USER_FS_REQUEST
		//  The parameters are broken out into 3 separate unions based on the
		//  method of the FSCTL Drivers should use the method-appropriate
		//  union for accessing parameters
		//

		struct {
			ULONG OutputBufferLength;
			ULONG POINTER_ALIGNMENT InputBufferLength;
			ULONG POINTER_ALIGNMENT FsControlCode;
		} Common;

		//
		//  METHOD_NEITHER Fsctl parameters
		//

		struct {
			ULONG OutputBufferLength;
			ULONG POINTER_ALIGNMENT InputBufferLength;
			ULONG POINTER_ALIGNMENT FsControlCode;

			//
			//  Type3InputBuffer: name changed from IO_STACK_LOCATION parameters
			//  Note for this mothod, both input & output buffers are 'raw',
			//  i.e. unbuffered, and should be treated with caution ( either
			//  probed & captured before access, or use try-except to enclose
			//  access to the buffer)
			//

			PVOID InputBuffer;
			PVOID OutputBuffer;

			//
			//  Mdl address for the output buffer  (maybe NULL)
			//

			PVOID OutputMdlAddress;
		} Neither;

		//
		//  METHOD_BUFFERED Fsctl parameters
		//

		struct {
			ULONG OutputBufferLength;
			ULONG POINTER_ALIGNMENT InputBufferLength;
			ULONG POINTER_ALIGNMENT FsControlCode;

			//
			//  For method buffered, this buffer is used both for input and
			//  output
			//

			PVOID SystemBuffer;

		} Buffered;

		//
		//  METHOD_IN_DIRECT/METHOD_OUT_DIRECT Fsctl parameters
		//

		struct {
			ULONG OutputBufferLength;
			ULONG POINTER_ALIGNMENT InputBufferLength;
			ULONG POINTER_ALIGNMENT FsControlCode;

			//
			//  Note the input buffer is already captured & buffered here - so
			//  can be safely accessed from kernel mode.  The output buffer is
			//  locked down - so also safe to access, however the OutputBuffer
			//  pointer is the user virtual address, so if the driver wishes to
			//  access the buffer in a different process context than that of
			//  the original i/o - it will have to obtain the system address
			//  from the MDL
			//

			PVOID InputSystemBuffer;

			//
			//  User virtual address of output buffer
			//

			PVOID OutputBuffer;

			//
			//  Mdl address for the locked down output buffer (should be
			//  non-NULL)
			//

			PVOID OutputMdlAddress;
		} Direct;

	} FileSystemControl;

	//
	//  IRP_MJ_DEVICE_CONTROL or IRP_MJ_INTERNAL_DEVICE_CONTROL
	//

	union {

		struct {
			ULONG OutputBufferLength;
			ULONG POINTER_ALIGNMENT InputBufferLength;
			ULONG POINTER_ALIGNMENT IoControlCode;
		} Common;

		//
		//  The parameters are broken out into 3 separate unions based on the
		//  method of the IOCTL.  Drivers should use the method-appropriate
		//  union for accessing parameters.
		//

		//
		//  METHOD_NEITHER Ioctl parameters for IRP path
		//

		struct {
			ULONG OutputBufferLength;
			ULONG POINTER_ALIGNMENT InputBufferLength;
			ULONG POINTER_ALIGNMENT IoControlCode;

			//
			//  Type3InputBuffer: name changed from IO_STACK_LOCATION parameters
			//  Note for this mothod, both input & output buffers are 'raw',
			//  i.e. unbuffered, and should be treated with caution ( either
			//  probed & captured before access, or use try-except to enclose
			//  access to the buffer)
			//

			PVOID InputBuffer;
			PVOID OutputBuffer;

			//
			//  Mdl address for the output buffer  (maybe NULL)
			//

			PVOID OutputMdlAddress;
		} Neither;

		//
		//  METHOD_BUFFERED Ioctl parameters for IRP path
		//

		struct {
			ULONG OutputBufferLength;
			ULONG POINTER_ALIGNMENT InputBufferLength;
			ULONG POINTER_ALIGNMENT IoControlCode;

			//
			//  For method buffered, this buffer is used both for input and
			//  output
			//

			PVOID SystemBuffer;

		} Buffered;

		//
		//  METHOD_IN_DIRECT/METHOD_OUT_DIRECT Ioctl parameters
		//

		struct {
			ULONG OutputBufferLength;
			ULONG POINTER_ALIGNMENT InputBufferLength;
			ULONG POINTER_ALIGNMENT IoControlCode;

			//
			//  Note the input buffer is already captured & buffered here - so
			//  can be safely accessed from kernel mode.  The output buffer is
			//  locked down - so also safe to access, however the OutputBuffer
			//  pointer is the user virtual address, so if the driver wishes to
			//  access the buffer in a different process context than that of
			//  the original i/o - it will have to obtain the system address
			//  from the MDL
			//

			PVOID InputSystemBuffer;

			//
			//  User virtual address of output buffer
			//

			PVOID OutputBuffer;

			//
			//  Mdl address for the locked down output buffer (should be non-NULL)
			//

			PVOID OutputMdlAddress;
		} Direct;

		//
		//  Regardless of method, if the CALLBACK_DATA represents a fast i/o
		//  device IOCTL, this structure must be used to access the parameters
		//

		struct {
			ULONG OutputBufferLength;
			ULONG POINTER_ALIGNMENT InputBufferLength;
			ULONG POINTER_ALIGNMENT IoControlCode;

			//
			//  Both buffers are 'raw', i.e. unbuffered
			//

			PVOID InputBuffer;
			PVOID OutputBuffer;

		} FastIo;

	} DeviceIoControl;

	//
	//  IRP_MJ_LOCK_CONTROL
	//

	struct {
		PLARGE_INTEGER Length;
		ULONG POINTER_ALIGNMENT Key;
		LARGE_INTEGER ByteOffset;

		PVOID ProcessId;        //  Only meaningful for FastIo locking operations.
		BOOLEAN FailImmediately;    //  Only meaningful for FastIo locking operations.
		BOOLEAN ExclusiveLock;      //  Only meaningful for FastIo locking operations.
	} LockControl;

	//
	//  IRP_MJ_QUERY_SECURITY
	//

	struct {
		SECURITY_INFORMATION SecurityInformation;
		ULONG POINTER_ALIGNMENT Length;

		PVOID SecurityBuffer;   //Not in IO_STACK_LOCATION parameters list
		PVOID MdlAddress;        //Mdl address for the buffer  (maybe NULL)
	} QuerySecurity;

	//
	//  IRP_MJ_SET_SECURITY
	//

	struct {
		SECURITY_INFORMATION SecurityInformation;
		PSECURITY_DESCRIPTOR SecurityDescriptor;
	} SetSecurity;

	//
	//  IRP_MJ_SYSTEM_CONTROL
	//

	struct {
		ULONG_PTR ProviderId;
		PVOID DataPath;
		ULONG BufferSize;
		PVOID Buffer;
	} WMI;

	//
	//  IRP_MJ_QUERY_QUOTA
	//

	struct {
		ULONG Length;
		PSID StartSid;
		PVOID SidList;
		ULONG SidListLength;

		PVOID QuotaBuffer;      //Not in IO_STACK_LOCATION parameters list
		PVOID MdlAddress;        //Mdl address for the buffer  (maybe NULL)
	} QueryQuota;

	//
	//  IRP_MJ_SET_QUOTA
	//

	struct {
		ULONG Length;

		PVOID QuotaBuffer;      //Not in IO_STACK_LOCATION parameters list
		PVOID MdlAddress;        //Mdl address for the buffer  (maybe NULL)
	} SetQuota;

	//
	//  IRP_MJ_PNP
	//

	union {

		//
		//  IRP_MN_START_DEVICE
		//

		struct {
			PVOID AllocatedResources;
			PVOID AllocatedResourcesTranslated;
		} StartDevice;

		//
		//  IRP_MN_QUERY_DEVICE_RELATIONS
		//

		struct {
			DEVICE_RELATION_TYPE Type;
		} QueryDeviceRelations;

		//
		//  IRP_MN_QUERY_INTERFACE
		//

		struct {
			CONST GUID* InterfaceType;
			USHORT Size;
			USHORT Version;
			PVOID Interface;
			PVOID InterfaceSpecificData;
		} QueryInterface;

		//
		//  IRP_MN_QUERY_CAPABILITIES
		//

		struct {
			PVOID Capabilities;
		} DeviceCapabilities;

		//
		//  IRP_MN_FILTER_RESOURCE_REQUIREMENTS
		//

		struct {
			PVOID IoResourceRequirementList;
		} FilterResourceRequirements;

		//
		//  IRP_MN_READ_CONFIG and IRP_MN_WRITE_CONFIG
		//

		struct {
			ULONG WhichSpace;
			PVOID Buffer;
			ULONG Offset;
			ULONG POINTER_ALIGNMENT Length;
		} ReadWriteConfig;

		//
		//  IRP_MN_SET_LOCK
		//

		struct {
			BOOLEAN Lock;
		} SetLock;

		//
		//  IRP_MN_QUERY_ID
		//

		struct {
			BUS_QUERY_ID_TYPE IdType;
		} QueryId;

		//
		//  IRP_MN_QUERY_DEVICE_TEXT
		//

		struct {
			DEVICE_TEXT_TYPE DeviceTextType;
			LCID POINTER_ALIGNMENT LocaleId;
		} QueryDeviceText;

		//
		//  IRP_MN_DEVICE_USAGE_NOTIFICATION
		//

		struct {
			BOOLEAN InPath;
			BOOLEAN Reserved[3];
			DEVICE_USAGE_NOTIFICATION_TYPE POINTER_ALIGNMENT Type;
		} UsageNotification;

	} Pnp;

	//
	//  ***** Start of Emulated IRP definitions
	//

	//
	//  IRP_MJ_ACQUIRE_FOR_SECTION_SYNCHRONIZATION
	//

	struct {
		FS_FILTER_SECTION_SYNC_TYPE SyncType;
		ULONG PageProtection;
		PFS_FILTER_SECTION_SYNC_OUTPUT OutputInformation;
	} AcquireForSectionSynchronization;

	//
	//  IRP_MJ_ACQUIRE_FOR_MOD_WRITE
	//

	struct {
		PLARGE_INTEGER EndingOffset;
		PVOID ResourceToRelease;
	} AcquireForModifiedPageWriter;

	//
	//  IRP_MJ_RELEASE_FOR_MOD_WRITE
	//

	struct {
		PVOID ResourceToRelease;
	} ReleaseForModifiedPageWriter;

	//
	// IRP_MJ_QUERY_OPEN
	//

	struct {
		PVOID Irp;
		PVOID FileInformation;
		PULONG Length;
		FILE_INFORMATION_CLASS FileInformationClass;
	} QueryOpen;


	//
	//  FAST_IO_CHECK_IF_POSSIBLE
	//

	struct {
		LARGE_INTEGER FileOffset;
		ULONG Length;
		ULONG POINTER_ALIGNMENT LockKey;
		BOOLEAN POINTER_ALIGNMENT CheckForReadOperation;
	} FastIoCheckIfPossible;

	//
	//  IRP_MJ_NETWORK_QUERY_OPEN
	//

	struct {
		PVOID Irp;
		PVOID NetworkInformation;
	} NetworkQueryOpen;

	//
	//  IRP_MJ_MDL_READ
	//

	struct {
		LARGE_INTEGER FileOffset;
		ULONG POINTER_ALIGNMENT Length;
		ULONG POINTER_ALIGNMENT Key;
		PVOID* MdlChain;
	} MdlRead;

	//
	//  IRP_MJ_MDL_READ_COMPLETE
	//

	struct {
		PVOID MdlChain;
	} MdlReadComplete;

	//
	//  IRP_MJ_PREPARE_MDL_WRITE
	//

	struct {
		LARGE_INTEGER FileOffset;
		ULONG POINTER_ALIGNMENT Length;
		ULONG POINTER_ALIGNMENT Key;
		PVOID* MdlChain;
	} PrepareMdlWrite;

	//
	//  IRP_MJ_MDL_WRITE_COMPLETE
	//

	struct {
		LARGE_INTEGER FileOffset;
		PVOID MdlChain;
	} MdlWriteComplete;

	//
	//  IRP_MJ_VOLUME_MOUNT
	//

	struct {
		ULONG DeviceType;
	} MountVolume;


	//
	// Others - driver-specific
	//

	struct {
		PVOID Argument1;
		PVOID Argument2;
		PVOID Argument3;
		PVOID Argument4;
		PVOID Argument5;
		LARGE_INTEGER Argument6;
	} Others;

} FLT_PARAMETERS, * PFLT_PARAMETERS;

#ifdef __cplusplus
}       //  Balance extern "C" above
#endif

#endif
```

`sdk/procmonsdk/kernelsdk.hpp`:

```hpp
#pragma once

#include <windows.h>
#include <winternl.h>
#include <fltUser.h>


typedef enum _KEY_INFORMATION_CLASS {
	KeyBasicInformation,
	KeyNodeInformation,
	KeyFullInformation,
	KeyNameInformation,
	KeyCachedInformation,
	KeyFlagsInformation,
	KeyVirtualizationInformation,
	KeyHandleTagsInformation,
	KeyTrustInformation,
	KeyLayerInformation,
	MaxKeyInfoClass  // MaxKeyInfoClass should always be the last enum
} KEY_INFORMATION_CLASS;

typedef enum _KEY_VALUE_INFORMATION_CLASS {
	KeyValueBasicInformation,
	KeyValueFullInformation,
	KeyValuePartialInformation,
	KeyValueFullInformationAlign64,
	KeyValuePartialInformationAlign64,
	KeyValueLayerInformation,
	MaxKeyValueInfoClass  // MaxKeyValueInfoClass should always be the last enum
} KEY_VALUE_INFORMATION_CLASS;

#include "fltuser.hpp"
#include "../../kernel/logsdk.h"




```

`sdk/procmonsdk/logger.cxx`:

```cxx

#include "pch.hpp"

#include "logger.hpp"
#include <mutex>

std::mutex gLogLock;

BOOL LogMessage(LEVEL Level, LPCTSTR Format, ...)
{
	TCHAR Buffer[MAX_LOG_MESSAGE] = { 0 };
	va_list Args;

	va_start(Args, Format);
	StringCchVPrintf(Buffer, MAX_LOG_MESSAGE, Format, Args);
	va_end(Args);

	gLogLock.lock();

	switch (Level) {
	case L_DEBUG: _ftprintf(stdout, TEXT("[?] %s\n"), Buffer); break;
	case L_INFO:  _ftprintf(stdout, TEXT("[+] %s\n"), Buffer); break;
	case L_WARN:  _ftprintf(stderr, TEXT("[*] %s\n"), Buffer); break;
	case L_ERROR: _ftprintf(stderr, TEXT("[!] %s\n"), Buffer); break;
	}

	fflush(stdout);
	fflush(stderr);

	gLogLock.unlock();

	return TRUE;
}
```

`sdk/procmonsdk/logger.hpp`:

```hpp
#pragma once

#include <windows.h>

typedef enum { L_DEBUG, L_INFO, L_WARN, L_ERROR } LEVEL, *PLEVEL;


//
// A quick logging routine for debug messages.
//

#define MAX_LOG_MESSAGE 1024
BOOL LogMessage(LEVEL Level, LPCTSTR Format, ...);
```

`sdk/procmonsdk/module.cxx`:

```cxx

#include "pch.hpp"
#include "module.hpp"
#include "utils.hpp"

CModule::CModule(_In_ PLOG_LOADIMAGE_INFO pInfo)
{
	m_Size = pInfo->ImageSize;
	m_ImageBase = pInfo->ImageBase;

	CString strPath;
	strPath.Append((PWCHAR)(pInfo + 1), pInfo->ImageNameLength);
	UtilConvertNtInternalPathToDosPath(strPath, m_strPath);
}

CModule::CModule()
{

}

CModule::~CModule()
{

}

PVOID CModule::GetImageBase()
{
	return m_ImageBase;
}

ULONG CModule::GetSize()
{
	return m_Size;
}

const CString& CModule::GetPath()
{
	return m_strPath;
}

BOOL CModule::IsAddressIn(LPVOID lpAddress)
{
	if ((ULONG_PTR)lpAddress >= (ULONG_PTR)m_ImageBase &&
		(ULONG_PTR)(lpAddress) < ((ULONG_PTR)m_ImageBase + m_Size)) {
		return TRUE;
	}
	return FALSE;
}

```

`sdk/procmonsdk/module.hpp`:

```hpp
#pragma once


class CModule
{
public:
	CModule();
	CModule(_In_ PLOG_LOADIMAGE_INFO pInfo);
	~CModule();

public:

	PVOID GetImageBase();
	ULONG GetSize();
	const CString& GetPath();
	BOOL IsAddressIn(LPVOID lpAddress);

private:
	PVOID m_ImageBase = NULL;
	ULONG m_Size = 0;
	CString m_strPath;
};
```

`sdk/procmonsdk/monctl.cxx`:

```cxx

#include "pch.hpp"
#include "logger.hpp"
#include "eventmgr.hpp"
#include "monctl.hpp"

#include <assert.h>

#pragma comment(lib, "FltLib.lib")

CMonitorContoller::CMonitorContoller()
{

}

CMonitorContoller::~CMonitorContoller()
{
	DisConnect();
}


BOOL CMonitorContoller::Connect()
{
	BOOL bOk = FALSE;
	ULONG Flag = 0;
	int i = 2;

	while (i--)
	{
		HRESULT hResult = FilterConnectCommunicationPort(PROCMON_PORTNAME,
			0,
			&Flag,
			sizeof(ULONG),
			NULL,
			&m_hPort);

		if (IS_ERROR(hResult)) {

			//
			// Try to load driver
			//

			if (hResult == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)){
				CDrvLoader& drvLoader = Singleton<CDrvLoader>::getInstance();
				if (drvLoader.IsReady() && drvLoader.Load()) {
					continue;
				}else{
					LogMessage(L_ERROR, TEXT("Could not connect to filter: 0x%08x"), hResult);
					return FALSE;
				}
			}else{
				break;
			}

		}else{
			bOk = TRUE;
			break;
		}
	}

	if (bOk){
		m_RecvThread.Init(m_hPort);
	}
	
	return bOk;
}

VOID 
CMonitorContoller::DisConnect()
{
	if (m_hPort){
		CloseHandle(m_hPort);
		m_hPort = NULL;
	}
}

VOID 
CMonitorContoller::SetMonitor(
	IN BOOL bEnableProc, 
	IN BOOL bEnableFile, 
	IN BOOL bEnableReg
)
{
	m_dwControl = 0;
	if (bEnableProc){
		m_dwControl |= CTL_MONITOR_PROC_ON;
	}

	if (bEnableFile) {
		m_dwControl |= CTL_MONITOR_FILE_ON;
	}

	if (bEnableReg) {
		m_dwControl |= CTL_MONITOR_REG_ON;
	}
}

BOOL CMonitorContoller::DisableAll()
{
	return Control(CTL_MONITOR_ALL_CLOSE);
}

BOOL CMonitorContoller::Start()
{
	bool bRet;

	//
	// start processing thread
	//
	
	bRet = m_OptThread.Start();
	if (!bRet){
		return FALSE;
	}
	
	//
	// start event receive thread
	//
	
	bRet = m_RecvThread.Start();
	if (!bRet){
		m_OptThread.Stop();
		return FALSE;
	}
	
	return Control(m_dwControl);
}

BOOL CMonitorContoller::Stop()
{
	BOOL bRet;
	bRet = DisableAll();
	EVENTMGR().Clear();
	//PROCMGR().Clear();

	return bRet;
}

BOOL CMonitorContoller::Destory()
{
	DisableAll();
	m_OptThread.Stop();
	m_RecvThread.Stop();
	DisConnect();
	return TRUE;
}

BOOL
CMonitorContoller::Control()
{
	return Control(m_dwControl);
}

BOOL 
CMonitorContoller::Control(
	IN DWORD Flags
)
{
	HRESULT hResult;
	DWORD dwRetBytes;
	FLTMSG_CONTROL_FLAGS Controls;

	Controls.Head.CtlCode = 0;
	Controls.Flags = Flags;
	hResult = FilterSendMessage(m_hPort, &Controls, sizeof(Controls), NULL, 0, &dwRetBytes);
	if (hResult != S_OK) {
		LogMessage(L_ERROR, TEXT("Can not enable monitor"));
		return FALSE;
	}
	return TRUE;
}

BOOL CRecvThread::Init(HANDLE hPort)
{
	m_hPort = hPort;
	return TRUE;
}



void CRecvThread::Run()
{
	HRESULT hResult;
	ULONG MessageLength = MAX_PROCMON_MESSAGE_LEN + sizeof(PROCMON_MESSAGE_HEADER);
	PPROCMON_MESSAGE_HEADER pMessage = (PPROCMON_MESSAGE_HEADER)HeapAlloc(GetProcessHeap(), 0,
		MAX_PROCMON_MESSAGE_LEN + sizeof(PROCMON_MESSAGE_HEADER));
	OVERLAPPED Overlapped = { 0 };

	if (!pMessage) {
		return;
	}

	ZeroMemory(&Overlapped, sizeof(Overlapped));
	Overlapped.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (!Overlapped.hEvent) {
		HeapFree(GetProcessHeap(), 0, pMessage);
		return;
	}

	while (!IsStop())
	{
		hResult = FilterGetMessage(m_hPort,
			&pMessage->Header, MessageLength, &Overlapped);

		if (hResult == HRESULT_FROM_WIN32(ERROR_IO_PENDING)) {

			//if(WaitForSingleObject(Overlapped.hEvent, 500) == WAIT_TIMEOUT){
			//	continue;
			//}
			
			//
			// wait until data ready
			//
			
			BOOL bNeedBreak = FALSE;
			while (TRUE)
			{
				DWORD dwWaitResult = WaitForSingleObject(Overlapped.hEvent, 500);
				if (dwWaitResult == WAIT_TIMEOUT){
					if (IsStop()){
						bNeedBreak = TRUE;
						break;
					}else{
						
						//
						// Continue waiting
						//
						
					}
				}else if (dwWaitResult == WAIT_OBJECT_0){
					
					//
					// the data ready
					//
					
					break;
				}else{
					bNeedBreak = TRUE;
					break;
				}
			}

			if (bNeedBreak) {
				break;
			}


		}else if (hResult != S_OK) {

			//
			// TODO error
			//

			assert(FALSE);

		}

		//
		// here we receive a message block.
		// try to decode the block
		//

		PLOG_ENTRY pEntries = (PLOG_ENTRY)(pMessage + 1);
		
		//
		// pass to operator mgr
		//
		
		if(!Singleton<CEventMgr>::getInstance().ProcessMsgBlocks(pEntries, pMessage->Length)){
			LogMessage(L_WARN, TEXT("Failed to process msg blocks"));
		}

	}

	LogMessage(L_INFO, TEXT(".......recv thread exit....."));

	//
	// clean up
	//

	if (pMessage) {
		HeapFree(GetProcessHeap(), 0, pMessage);
	}
}

void COPtThread::Run()
{
	while (!IsStop())
	{
		
		//
		// If queue have no data, the function return false
		// for every 500ms. so here we have a opportunity to 
		// exit the loop
		//
		
		Singleton<CEventMgr>::getInstance().Process();
	}

	LogMessage(L_INFO, TEXT(".......processing thread exit....."));

}


```

`sdk/procmonsdk/monctl.hpp`:

```hpp
#pragma once


#define MONITORMGR() Singleton<CMonitorContoller>::getInstance()

class CRecvThread : public CThread
{
public:
	CRecvThread() {};
	~CRecvThread() {};

public:

	BOOL Init(HANDLE hPort);
	virtual void Run();

private:
	HANDLE m_hPort = NULL;
};

class COPtThread : public CThread
{
public:
	COPtThread() {};
	~COPtThread() {};

public:
	virtual void Run();
};


class CMonitorContoller
{
public:
	CMonitorContoller();
	virtual ~CMonitorContoller();

public:
	
	BOOL Connect();
	VOID DisConnect();
	VOID SetMonitor(
		IN BOOL bEnableProc, 
		IN BOOL bEnableFile, 
		IN BOOL bEnableReg);
	BOOL DisableAll();
	BOOL Start();
	BOOL Stop();
	BOOL Destory();
	
private:
	BOOL Control(IN DWORD Flags);
	BOOL Control();

private:

	HANDLE m_hPort = NULL;
	COPtThread m_OptThread;
	CRecvThread m_RecvThread;
	DWORD m_dwControl = 0;
};
```

`sdk/procmonsdk/pch.cxx`:

```cxx
// pch.cpp: source file corresponding to the pre-compiled header

#include "pch.hpp"

// When you are using pre-compiled headers, this source file is necessary for compilation to succeed.

```

`sdk/procmonsdk/pch.hpp`:

```hpp
// pch.h: This is a precompiled header file.
// Files listed below are compiled only once, improving build performance for future builds.
// This also affects IntelliSense performance, including code completion and many code browsing features.
// However, files listed here are ALL re-compiled if any one of them is updated between builds.
// Do not add files here that you will be updating frequently as this negates the performance advantage.

#ifndef PCH_H
#define PCH_H

#include <stdio.h>
#include <tchar.h>
#include <strsafe.h>
#include <atlstr.h>
#include <atlpath.h>

#include <map>
#include <vector>
#include <mutex>
#include <condition_variable>
#include <queue>

#include "kernelsdk.hpp"
#include "singleton.hpp"
#include "refobject.hpp"
#include "drvload.hpp"
#include "buffer.hpp"
#include "utils.hpp"
#include "thread.hpp"
#include "logger.hpp"
#include "utils.hpp"

#endif //PCH_H

```

`sdk/procmonsdk/process.cxx`:

```cxx
#pragma once

#include "pch.hpp"
#include "process.hpp"
#include "utils.hpp"

VOID CProcess::InsertModule(const CModule& mod)
{
	m_ModuleList.push_back(mod);
}

VOID CProcess::SetExitEvent(CRefPtr<CLogEvent> pEvent)
{
	m_ProcessExit = pEvent;
}

CProcess::CProcess(CRefPtr<CLogEvent> pEvent) :
	CProcInfoView(pEvent)
{
	
	//
	// Create new ProcessInfo
	//
	
	m_ProcessInfo = new CProcInfo(GetImagePath());

}

CProcess::~CProcess()
{
	
}

VOID CProcess::Dump()
{

}

std::vector<CModule>& CProcess::GetModuleList()
{
	return m_ModuleList;
}

CRefPtr<CProcInfo> CProcess::GetProcInfo()
{
	return m_ProcessInfo;
}

CRefPtr<CLogEvent> CProcess::GetExitEvent()
{
	return m_ProcessExit;
}

CProcInfo::CProcInfo(const CString& strPath)
{
	Parse(strPath);
}

CProcInfo::~CProcInfo()
{

}

BOOL CProcInfo::Parse(const CString& strPath)
{
	
	//
	// Query file version info
	//
	
	UtilGetFileVersionInfo(strPath, m_strDisplay, m_strCompanyName, m_strVersion);

	//
	// Query EXE file icon.
	//
	
	UtilExtractIcon(strPath, m_SmallIcon, m_LargeIcon);

	return TRUE;
}

```

`sdk/procmonsdk/process.hpp`:

```hpp
#pragma once

#include <vector>
#include "refobject.hpp"
#include "buffer.hpp"
#include "module.hpp"
#include "viewer.hpp"

class CProcInfo : public CRefBase
{
public:
	CProcInfo(const CString& strPath);
	~CProcInfo();

public:

	const CString& GetDisplayName()
	{
		return m_strDisplay;
	}

	const CString& GetCompanyName()
	{
		return m_strCompanyName;
	}

	const CString& GetVersion()
	{
		return m_strVersion;
	}

	CBuffer& GetSmallIcon()
	{
		return m_SmallIcon;
	}

	CBuffer& GetLargeIcon()
	{
		return m_LargeIcon;
	}

private:

	BOOL Parse(const CString& strPath);

private:

	CString m_strDisplay;
	CString m_strCompanyName;
	CString m_strVersion;
	CBuffer m_SmallIcon;
	CBuffer m_LargeIcon;
};

class CProcess : public CProcInfoView, 
	public CRefBase
{
public:
	CProcess(CRefPtr<CLogEvent> pEvent);
	virtual ~CProcess();

public:
	VOID Dump();
	VOID InsertModule(const CModule& mod);

	VOID SetExitEvent(CRefPtr<CLogEvent> pEvent);

	VOID MarkExit(BOOL bMark)
	{
		m_bMarkExit = bMark;
	}

	BOOL IsMarkExit()
	{
		return m_bMarkExit;
	}

	std::vector<CModule>& GetModuleList();
	CRefPtr<CProcInfo> GetProcInfo();
	CRefPtr<CLogEvent> GetExitEvent();

private:
	BOOL m_bMarkExit = FALSE;
	std::vector<CModule> m_ModuleList;
	CRefPtr<CProcInfo> m_ProcessInfo;
	CRefPtr<CLogEvent> m_ProcessExit;
};
```

`sdk/procmonsdk/procmgr.cxx`:

```cxx

#include "pch.hpp"
#include "procmgr.hpp"
#include "logger.hpp"

CProcMgr::CProcMgr()
{

}

CProcMgr::~CProcMgr()
{

}

CRefPtr<CProcess> 
CProcMgr::RefProcessBySeq(
	_In_ ULONG Seq
)
{
	//
	// aquire read lock
	//

	std::shared_lock<std::shared_mutex> lock(m_lock);
	auto it = m_ProcessList.find(Seq);
	if (it == m_ProcessList.end()) {
		return NULL;
	}

	return it->second;
}

CRefPtr<CProcess> 
CProcMgr::RefProcessByProcessId(
	_In_ ULONG ProcessId
)
{
	
	//
	// this will be very slowly
	// Do not use this method if is necessary
	//
	
	//
	// aquire read lock
	//

	std::shared_lock<std::shared_mutex> lock(m_lock);

	for (auto it = m_ProcessList.begin(); it != m_ProcessList.end(); it++)
	{
		CRefPtr<CProcess> Process = it->second;
		if (Process->GetProcessId() == ProcessId){
			return Process;
		}
	}
	
	return NULL;
}

VOID CProcMgr::InsertModule(
	_In_ ULONG ProcSeq,
	_In_ PLOG_LOADIMAGE_INFO pInfo
)
{
	CRefPtr<CProcess> Process = RefProcessBySeq(ProcSeq);
	if (!Process.IsNull()){
		CModule mod(pInfo);
		Process->InsertModule(mod);
	}
}

VOID
CProcMgr::Replace(
	_In_ ULONG Seq,
	_In_ CRefPtr<CProcess> Process
)
{
	std::unique_lock<std::shared_mutex> lock(m_lock);

	//
	// remove from list
	//

	m_ProcessList.erase(Seq);

	//
	// Replace it with new one
	//

	m_ProcessList.insert(PROCESSLISTMAPPAIR(Seq, Process));
}

VOID 
CProcMgr::Insert(
	_In_ CRefPtr<CProcess> Process
)
{

	//
	// Check is process already in list
	//

	ULONG Seq = Process->GetProcSeq();
	CRefPtr<CProcess> ProcessFind = RefProcessBySeq(Seq);

	if (ProcessFind.IsNull()) {

		//
		// Add to process list
		//

		m_lock.lock();
		m_ProcessList.insert(PROCESSLISTMAPPAIR(Seq, Process));
		m_lock.unlock();
	}else{
		
		//
		// Replace it anyway
		//
		
		Replace(Seq, Process);

		if (!ProcessFind->IsMarkExit()) {

			//
			// Here must be something wrong
			//
			
			if (!Process->GetProcessId()) {
				Process->Dump();
			}

			LogMessage(L_WARN, TEXT("Process id 0x%x Exist SKIP!!"), Process->GetProcessId());

			//__debugbreak();
		}
	}
}

VOID 
CProcMgr::Remove(
	_In_ const CRefPtr<CLogEvent> pEvent
)
{
	CRefPtr<CProcess> ProcessFind = RefProcessBySeq(pEvent->GetProcSeq());
	if (!ProcessFind.IsNull()) {
		ProcessFind->MarkExit(TRUE);
		ProcessFind->SetExitEvent(pEvent);
	}else{
		LogMessage(L_INFO, TEXT("Remove process seq 0x%x is not exist in list"), pEvent->GetProcSeq());
	}
}

VOID CProcMgr::Dump()
{
#ifdef _DEBUG
	PROCESSLISTMAP::iterator it;
	int nCount;
	LogMessage(L_INFO, TEXT("===============dump process============="));
	for (it = m_ProcessList.begin(), nCount = 1; it != m_ProcessList.end(); it++, nCount++)
	{
		ULONG Seq = it->first;
		CRefPtr<CProcess> Process = it->second;
		LogMessage(L_INFO, TEXT("%d: seq=0x%x \t processId=0x%x"), nCount, Seq, Process->GetProcessId());
	}

	LogMessage(L_INFO, TEXT("======================================="));
#endif
}

VOID CProcMgr::Clear()
{
	std::unique_lock<std::shared_mutex> lock(m_lock);
	m_ProcessList.clear();
}

```

`sdk/procmonsdk/procmgr.hpp`:

```hpp
#pragma once

#include "singleton.hpp"
#include "process.hpp"
#include <map>
#include <shared_mutex>

#define PROCMGR()  Singleton<CProcMgr>::getInstance()

typedef std::map<ULONG, CRefPtr<CProcess>> PROCESSLISTMAP;
typedef std::pair<ULONG, CRefPtr<CProcess>> PROCESSLISTMAPPAIR;

class CProcMgr
{
public:
	CProcMgr();
	~CProcMgr();

public:

	CRefPtr<CProcess> RefProcessBySeq(
		_In_ ULONG Seq
	);

	CRefPtr<CProcess> RefProcessByProcessId(
		_In_ ULONG ProcessId
	);

	VOID Insert(
		_In_ CRefPtr<CProcess> Process
	);

	VOID InsertModule(
		_In_ ULONG ProcSeq,
		_In_ PLOG_LOADIMAGE_INFO pInfo
	);

	VOID Replace(
		_In_ ULONG Seq, 
		_In_ CRefPtr<CProcess> Process
	);

	VOID Remove(
		_In_ const CRefPtr<CLogEvent> pEvent
	);

	VOID Dump();

	VOID Clear();

private:

	
	//
	// 这里只有一个线程去处理数据,所以我们没必要加锁
	//
	
	std::shared_mutex m_lock;
	PROCESSLISTMAP m_ProcessList;

};

```

`sdk/procmonsdk/procmonsdk.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{C21EB4AB-5F89-4993-A408-873C6A5B60CB}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>procmonsdk</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>Create</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.hpp</PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Create</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.hpp</PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="buffer.hpp" />
    <ClInclude Include="drvload.hpp" />
    <ClInclude Include="eventfactory.hpp" />
    <ClInclude Include="fileopt.hpp" />
    <ClInclude Include="fltuser.hpp" />
    <ClInclude Include="logger.hpp" />
    <ClInclude Include="module.hpp" />
    <ClInclude Include="monctl.hpp" />
    <ClInclude Include="event.hpp" />
    <ClInclude Include="eventmgr.hpp" />
    <ClInclude Include="pch.hpp" />
    <ClInclude Include="process.hpp" />
    <ClInclude Include="procmgr.hpp" />
    <ClInclude Include="procopt.hpp" />
    <ClInclude Include="refobject.hpp" />
    <ClInclude Include="regopt.hpp" />
    <ClInclude Include="kernelsdk.hpp" />
    <ClInclude Include="sdk.hpp" />
    <ClInclude Include="singleton.hpp" />
    <ClInclude Include="strmaps.hpp" />
    <ClInclude Include="thread.hpp" />
    <ClInclude Include="utils.hpp" />
    <ClInclude Include="eventview.hpp" />
    <ClInclude Include="viewer.hpp" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="buffer.cxx" />
    <ClCompile Include="drvload.cxx" />
    <ClCompile Include="eventfactory.cxx" />
    <ClCompile Include="fileopt.cxx" />
    <ClCompile Include="logger.cxx" />
    <ClCompile Include="module.cxx" />
    <ClCompile Include="monctl.cxx" />
    <ClCompile Include="event.cxx" />
    <ClCompile Include="eventmgr.cxx" />
    <ClCompile Include="eventview.cxx" />
    <ClCompile Include="pch.cxx" />
    <ClCompile Include="process.cxx" />
    <ClCompile Include="procmgr.cxx" />
    <ClCompile Include="procopt.cxx" />
    <ClCompile Include="regopt.cxx" />
    <ClCompile Include="strmaps.cxx" />
    <ClCompile Include="thread.cxx" />
    <ClCompile Include="utils.cxx" />
    <ClCompile Include="viewer.cxx" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`sdk/procmonsdk/procmonsdk.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pch.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="drvload.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="fileopt.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="procopt.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="regopt.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="utils.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="singleton.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="refobject.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="thread.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="buffer.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="logger.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="monctl.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="procmgr.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="process.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="module.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="viewer.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="eventfactory.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="eventmgr.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="eventview.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="event.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="kernelsdk.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="sdk.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="fltuser.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="strmaps.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="pch.cxx">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="drvload.cxx">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="thread.cxx">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="buffer.cxx">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="logger.cxx">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="monctl.cxx">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="procmgr.cxx">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="process.cxx">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="module.cxx">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="procopt.cxx">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="fileopt.cxx">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="viewer.cxx">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="eventfactory.cxx">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="eventmgr.cxx">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="eventview.cxx">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="event.cxx">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="utils.cxx">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="strmaps.cxx">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="regopt.cxx">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`sdk/procmonsdk/procmonsdk.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`sdk/procmonsdk/procopt.cxx`:

```cxx

#include "pch.hpp"
#include "procmgr.hpp"
#include "procopt.hpp"

BOOL CProcOpt::Process(const CRefPtr<CLogEvent> pEvent)
{
	PLOG_ENTRY pEntry = (PLOG_ENTRY)pEvent->getPreLog().GetBuffer();
	if (pEntry->MonitorType != MONITOR_TYPE_PROCESS) {
		return TRUE;
	}

	switch (pEntry->NotifyType)
	{
	case NOTIFY_PROCESS_INIT:
	case NOTIFY_PROCESS_CREATE:
	{
		CRefPtr<CProcess> pProcess = new CProcess(pEvent);
		PROCMGR().Insert(pProcess);
	}
		break;
	case NOTIFY_PROCESS_EXIT:
		PROCMGR().Remove(pEvent);
		break;
	case NOTIFY_IMAGE_LOAD:
	{
		PLOG_LOADIMAGE_INFO pImageLoadInfo = TO_EVENT_DATA(PLOG_LOADIMAGE_INFO, pEntry);
		PROCMGR().InsertModule(pEntry->ProcessSeq, pImageLoadInfo);
	}
		break;
	default:
		break;
	}

	return TRUE;
}

BOOL CProcOpt::IsType(ULONG MonitorType)
{
	return MonitorType == MONITOR_TYPE_PROCESS;
}

CString CProcEvent::GetPath()
{
	PLOG_ENTRY pEntry = reinterpret_cast<PLOG_ENTRY>(getPreLog().GetBuffer());

	switch (pEntry->NotifyType)
	{
	case NOTIFY_PROCESS_INIT:
	case NOTIFY_PROCESS_EXIT:
		break;
	case NOTIFY_PROCESS_CREATE:
	{
		CProcInfoView clsView(this);
		return clsView.GetImagePath();
	}
	break;
	case NOTIFY_IMAGE_LOAD:
	{
		PLOG_LOADIMAGE_INFO pImageLoadInfo = TO_EVENT_DATA(PLOG_LOADIMAGE_INFO, pEntry);
		CModule Mod(pImageLoadInfo);
		return Mod.GetPath();
	}
	break;
	default:
		break;
	}

	return TEXT("");
}

CString CProcEvent::GetDetail()
{
	PLOG_ENTRY pEntry = reinterpret_cast<PLOG_ENTRY>(getPreLog().GetBuffer());
	CString strDetail;

	switch (pEntry->NotifyType)
	{
	case NOTIFY_PROCESS_CREATE:
	{
		CProcInfoView clsView(this);

		strDetail.Format(TEXT("PID: %d\r\nCommand Line:%s"), 
				clsView.GetProcessId(), 
				clsView.GetCommandLine().GetBuffer());
		
	}
	break;
	default:
		strDetail = TEXT("TODO");
		break;
	}
	
	return strDetail;
}

```

`sdk/procmonsdk/procopt.hpp`:

```hpp
#pragma once

#include "event.hpp"
#include "eventmgr.hpp"

class CProcOpt : public IProcessor
{
public:
	virtual BOOL Process(const CRefPtr<CLogEvent> pEvent);
	virtual BOOL IsType(ULONG MonitorType);
};

class CProcEvent : public CLogEvent
{
public:
	virtual CString GetPath();
	virtual CString GetDetail();
};

```

`sdk/procmonsdk/refobject.hpp`:

```hpp
#ifndef __REF_OBJECT_H__
#define __REF_OBJECT_H__

#ifdef _WIN32
#include <windows.h>
#endif


class CRefBase
{
public:
	CRefBase()
	{
		m_nRefCount = 0;
	}

	virtual ~CRefBase()
	{

	}

	int GetRef() const
	{
		return m_nRefCount;
	}

	int AddRef()
	{
		return InterlockedIncrement((long*)&m_nRefCount);
	}

	virtual int DeRef()
	{
		long refCounts = InterlockedDecrement((long*)&m_nRefCount);
        return refCounts;
	}

	void Reset()
	{
		InterlockedCompareExchange((long*)&m_nRefCount, 0, m_nRefCount);
	}


private:
	int	m_nRefCount;
};

template<typename T>
class CRefPtr
{
public:
	T* operator->() const
	{
		return m_pRawObj;
	}

	T& operator()() const
	{
		return *m_pRawObj;
	}

	T& operator*() const
	{
		return *m_pRawObj;
	}

	T* GetPtr() const
	{
		return m_pRawObj;
	}

	bool IsNull() const
	{
		return m_pRawObj == NULL;
	}

	CRefPtr()
	{
		m_pRawObj = NULL;
	}

	CRefPtr(T* p)
	{
		m_pRawObj = p;
		if(p != NULL){
			p->AddRef();
		}
	}

	CRefPtr(const CRefPtr& ref)
	{
		m_pRawObj = ref.m_pRawObj;
		if(m_pRawObj != NULL){
			m_pRawObj->AddRef();
		}
	}

	~CRefPtr()
	{
		if(m_pRawObj != NULL && !m_pRawObj->DeRef()){

			//
			//delete obejct
			//
			
			//LogMessage(L_INFO, "refcounts == 0 delete it");
			delete m_pRawObj;
		}
	}

	CRefPtr& operator = (const CRefPtr& ref)
	{
		if(this != &ref){
			if(m_pRawObj != NULL && !m_pRawObj->DeRef()){
				delete m_pRawObj;
			}

			m_pRawObj = ref.m_pRawObj;

			if(m_pRawObj != NULL){
				m_pRawObj->AddRef();
			}
		}

		return *this;
	}

	bool operator == (const CRefPtr& ref) const
	{
		return m_pRawObj == ref.m_pRawObj;
	}

	bool operator != (const CRefPtr& ref) const
	{
		return m_pRawObj != ref.m_pRawObj;
	}

private:
	T* m_pRawObj;
};

#endif //__REF_OBJECT_H__

```

`sdk/procmonsdk/regopt.cxx`:

```cxx
#pragma once

#include "pch.hpp"
#include "procmgr.hpp"
#include "regopt.hpp"
#include "eventview.hpp"
#include "strmaps.hpp"


template <class T>
CString GetRegKeyPath(PLOG_ENTRY pEntry)
{
    CString strRegPath;
    T pInfo = TO_EVENT_DATA(T, pEntry);
    if (pInfo->KeyNameLength) {
        CString strRegPathInternal;
        strRegPathInternal.Append((LPCWSTR)(pInfo + 1), pInfo->KeyNameLength);
        UtilConvertRegInternalToNormal(strRegPathInternal, strRegPath);
    }
    
    return strRegPath;
}

CString CRegEvent::GetPath()
{
    PLOG_ENTRY pEntry = reinterpret_cast<PLOG_ENTRY>(getPreLog().GetBuffer());

    switch (pEntry->NotifyType)
    {
    case NOTIFY_REG_CREATEKEYEX:
    case NOTIFY_REG_OPENKEYEX:
    {
        return GetRegKeyPath<PLOG_REG_CREATEOPENKEY>(pEntry);
    }

    case NOTIFY_REG_QUERYVALUEKEY:
    {
        return GetRegKeyPath<PLOG_REG_QUERYVALUEKEY>(pEntry);
    }
    case NOTIFY_REG_ENUMERATEVALUEKEY:
    {
        return GetRegKeyPath<PLOG_REG_ENUMERATEVALUEKEY>(pEntry);
    }
    case NOTIFY_REG_ENUMERATEKEY:
    {
        return GetRegKeyPath<PLOG_REG_ENUMERATEKEY>(pEntry);
    }
    case NOTIFY_REG_SETINFORMATIONKEY:
    {
        return GetRegKeyPath<PLOG_REG_SETINFORMATIONKEY>(pEntry);
    }
    case NOTIFY_REG_DELETEVALUEKEY:
    {
        return GetRegKeyPath<PLOG_REG_DELETEVALUEKEY>(pEntry);
    }
    case NOTIFY_REG_QUERYKEY:
    {
        return GetRegKeyPath<PLOG_REG_QUERYKEY>(pEntry);
    }

    case NOTIFY_REG_LOADKEY:
    {
        return GetRegKeyPath<PLOG_REG_LOADKEY>(pEntry);
    }

    case NOTIFY_REG_UNLOADKEY:
    {
        return GetRegKeyPath<PLOG_REG_UNLOADKEY>(pEntry);
    }

    case NOTIFY_REG_RENAMEKEY:
    {
        return GetRegKeyPath<PLOG_REG_RENAMEKEY>(pEntry);
    }

    case NOTIFY_REG_SETVALUEKEY:
    {
        return GetRegKeyPath<PLOG_REG_SETVALUEKEY>(pEntry);
    }
    case NOTIFY_REG_SETKEYSECURITY:
    case NOTIFY_REG_QUERYMULTIPLEVALUEKEY:
    case NOTIFY_REG_FLUSHKEY:
    case NOTIFY_REG_DELETEKEY:
    case NOTIFY_REG_KEYHANDLECLOSE:
    case NOTIFY_REG_QUERYKEYSECURITY:
    {
        return GetRegKeyPath<PLOG_REG_CONNMON>(pEntry);
    }
    default:
        break;
    }

    return TEXT("");
}
```

`sdk/procmonsdk/regopt.hpp`:

```hpp
#pragma once

class CRegEvent : public CLogEvent
{
public:
	virtual CString GetPath();

	virtual CString GetDetail()
	{
		return TEXT("TODO");
	}
};
```

`sdk/procmonsdk/sdk.hpp`:

```hpp
#pragma once

#include <stdio.h>
#include <tchar.h>
#include <strsafe.h>
#include <atlstr.h>
#include <atlpath.h>
#include <map>
#include <vector>
#include <mutex>
#include <condition_variable>
#include <queue>
#include <algorithm>

#include "kernelsdk.hpp"
#include "singleton.hpp"
#include "refobject.hpp"
#include "drvload.hpp"
#include "buffer.hpp"
#include "utils.hpp"
#include "thread.hpp"
#include "logger.hpp"
#include "utils.hpp"
#include "strmaps.hpp"

#include "monctl.hpp"
#include "eventmgr.hpp"
#include "eventview.hpp"
```

`sdk/procmonsdk/singleton.hpp`:

```hpp
#pragma once


template<typename T>
class Singleton
{
public:
	static T& getInstance()
	{
		static T value;
		return value;
	}

private:
	Singleton();
	~Singleton();
};
```

`sdk/procmonsdk/strmaps.cxx`:

```cxx

#include "pch.hpp"
#include "strmaps.hpp"

#include <sddl.h>

#define STATUS_SUCCESS ((NTSTATUS)0x00000000L) 
#define STATUS_UNSUCCESSFUL ((NTSTATUS)0xC0000001L)
#define STATUS_INVALID_EA_FLAG ((NTSTATUS)0x80000015L)
#define STATUS_BUFFER_OVERFLOW ((NTSTATUS)0x80000005L)
#define STATUS_NO_MORE_FILES ((NTSTATUS)0x80000006L)
#define STATUS_FLT_DISALLOW_FAST_IO ((NTSTATUS)0xC01C0004L)
#define STATUS_FILE_LOCKED_WITH_ONLY_READERS ((NTSTATUS)0x0000012AL)
#define STATUS_REPARSE ((NTSTATUS)0x00000104L)
#define STATUS_MORE_ENTRIES ((NTSTATUS)0x00000105L)
#define STATUS_OPLOCK_BREAK_IN_PROGRESS ((NTSTATUS)0x00000108L)
#define STATUS_NOTIFY_CLEANUP ((NTSTATUS)0x0000010BL)
#define STATUS_NOTIFY_ENUM_DIR ((NTSTATUS)0x0000010CL)
#define STATUS_FILE_LOCKED_WITH_WRITERS ((NTSTATUS)0x0000012BL)
#define STATUS_OPLOCK_SWITCHED_TO_NEW_HANDLE ((NTSTATUS)0x00000215L)
#define STATUS_OPLOCK_HANDLE_CLOSED ((NTSTATUS)0x00000216L)
#define STATUS_WAIT_FOR_OPLOCK ((NTSTATUS)0x00000367L)
#define STATUS_PREDEFINED_HANDLE ((NTSTATUS)0x40000016L)
#define STATUS_SPARSE_NOT_ALLOWED_IN_TRANSACTION ((NTSTATUS)0xC0190049L)
#define STATUS_CANNOT_BREAK_OPLOCK ((NTSTATUS)0xC0000909L)
#define STATUS_HIVE_UNLOADED ((NTSTATUS)0xC0000425L)
#define STATUS_FILE_SYSTEM_LIMITATION ((NTSTATUS)0xC0000427L)
#define STATUS_DEVICE_FEATURE_NOT_SUPPORTED ((NTSTATUS)0xC0000463L)
#define STATUS_OFFLOAD_READ_FLT_NOT_SUPPORTED ((NTSTATUS)0xC000A2A1L)
#define STATUS_OFFLOAD_WRITE_FLT_NOT_SUPPORTED ((NTSTATUS)0xC000A2A2L)
#define STATUS_OFFLOAD_READ_FILE_NOT_SUPPORTED ((NTSTATUS)0xC000A2A3L)
#define STATUS_TRANSACTIONAL_CONFLICT ((NTSTATUS)0xC0190001L)
#define STATUS_INVALID_TRANSACTION ((NTSTATUS)0xC0190002L)
#define STATUS_TRANSACTION_NOT_ACTIVE ((NTSTATUS)0xC0190003L)
#define STATUS_EFS_NOT_ALLOWED_IN_TRANSACTION ((NTSTATUS)0xC019003EL)
#define STATUS_TRANSACTED_MAPPING_UNSUPPORTED_REMOTE ((NTSTATUS)0xC0190040L)
#define STATUS_CANNOT_EXECUTE_FILE_IN_TRANSACTION ((NTSTATUS)0xC0190044L)
#define STATUS_DOWNGRADE_DETECTED ((NTSTATUS)0xC0000388L)
#define STATUS_INSUFF_SERVER_RESOURCES ((NTSTATUS)0xC0000205L)
#define STATUS_INVALID_ADDRESS_COMPONENT ((NTSTATUS)0xC0000207L)
#define STATUS_CONNECTION_DISCONNECTED ((NTSTATUS)0xC000020CL)
#define STATUS_NOT_FOUND ((NTSTATUS)0xC0000225L)
#define STATUS_USER_MAPPED_FILE ((NTSTATUS)0xC0000243L)
#define STATUS_LOGIN_WKSTA_RESTRICTION ((NTSTATUS)0xC0000248L)
#define STATUS_PATH_NOT_COVERED ((NTSTATUS)0xC0000257L)
#define STATUS_DFS_UNAVAILABLE ((NTSTATUS)0xC000026DL)
#define STATUS_NO_MORE_MATCHES ((NTSTATUS)0xC0000273L)
#define STATUS_NOT_A_REPARSE_POINT ((NTSTATUS)0xC0000275L)
#define STATUS_CANNOT_MAKE ((NTSTATUS)0xC00002EAL)
#define STATUS_OBJECTID_NOT_FOUND ((NTSTATUS)0xC00002F0L)
#define STATUS_USER_SESSION_DELETED ((NTSTATUS)0xC0000203L)
#define STATUS_FILE_CORRUPT_ERROR ((NTSTATUS)0xC0000102L)
#define STATUS_NOT_A_DIRECTORY ((NTSTATUS)0xC0000103L)
#define STATUS_FILES_OPEN ((NTSTATUS)0xC0000107L)
#define STATUS_CANNOT_IMPERSONATE ((NTSTATUS)0xC000010DL)
#define STATUS_CANCELLED ((NTSTATUS)0xC0000120L)
#define STATUS_CANNOT_DELETE ((NTSTATUS)0xC0000121L)
#define STATUS_FILE_DELETED ((NTSTATUS)0xC0000123L)
#define STATUS_FILE_CLOSED ((NTSTATUS)0xC0000128L)
#define STATUS_THREAD_NOT_IN_PROCESS ((NTSTATUS)0xC000012AL)
#define STATUS_INVALID_LEVEL ((NTSTATUS)0xC0000148L)
#define STATUS_PIPE_BROKEN ((NTSTATUS)0xC000014BL)
#define STATUS_REGISTRY_CORRUPT ((NTSTATUS)0xC000014CL)
#define STATUS_REGISTRY_IO_FAILED ((NTSTATUS)0xC000014DL)
#define STATUS_KEY_DELETED ((NTSTATUS)0xC000017CL)
#define STATUS_CHILD_MUST_BE_VOLATILE ((NTSTATUS)0xC0000181L)
#define STATUS_INVALID_DEVICE_STATE ((NTSTATUS)0xC0000184L)
#define STATUS_IO_DEVICE_ERROR ((NTSTATUS)0xC0000185L)
#define STATUS_LOG_FILE_FULL ((NTSTATUS)0xC0000188L)
#define STATUS_FS_DRIVER_REQUIRED ((NTSTATUS)0xC000019CL)
#define STATUS_DIRECTORY_NOT_EMPTY ((NTSTATUS)0xC0000101L)
#define STATUS_NOT_IMPLEMENTED ((NTSTATUS)0xC0000002L)
#define STATUS_INVALID_INFO_CLASS ((NTSTATUS)0xC0000003L) 
#define STATUS_INFO_LENGTH_MISMATCH ((NTSTATUS)0xC0000004L)
#define STATUS_NO_SUCH_DEVICE ((NTSTATUS)0xC000000EL)
#define STATUS_NO_SUCH_FILE ((NTSTATUS)0xC000000FL)
#define STATUS_INVALID_DEVICE_REQUEST ((NTSTATUS)0xC0000010L)
#define STATUS_END_OF_FILE ((NTSTATUS)0xC0000011L)
#define STATUS_WRONG_VOLUME ((NTSTATUS)0xC0000012L)
#define STATUS_NO_MEDIA_IN_DEVICE ((NTSTATUS)0xC0000013L)
#define STATUS_NONEXISTENT_SECTOR ((NTSTATUS)0xC0000015L)
#define STATUS_ALREADY_COMMITTED ((NTSTATUS)0xC0000021L)
#define STATUS_ACCESS_DENIED ((NTSTATUS)0xC0000022L)
#define STATUS_BUFFER_TOO_SMALL ((NTSTATUS)0xC0000023L)
#define STATUS_OBJECT_TYPE_MISMATCH ((NTSTATUS)0xC0000024L)
#define STATUS_DISK_CORRUPT_ERROR ((NTSTATUS)0xC0000032L)
#define STATUS_OBJECT_NAME_INVALID ((NTSTATUS)0xC0000033L)
#define STATUS_OBJECT_NAME_NOT_FOUND ((NTSTATUS)0xC0000034L)
#define STATUS_OBJECT_NAME_COLLISION ((NTSTATUS)0xC0000035L)
#define STATUS_OBJECT_PATH_INVALID ((NTSTATUS)0xC0000039L)
#define STATUS_OBJECT_PATH_NOT_FOUND ((NTSTATUS)0xC000003AL)
#define STATUS_OBJECT_PATH_SYNTAX_BAD ((NTSTATUS)0xC000003BL)
#define STATUS_DATA_OVERRUN ((NTSTATUS)0xC000003CL)
#define STATUS_CRC_ERROR ((NTSTATUS)0xC000003FL)
#define STATUS_SHARING_VIOLATION ((NTSTATUS)0xC0000043L)
#define STATUS_QUOTA_EXCEEDED ((NTSTATUS)0xC0000044L)
#define STATUS_EAS_NOT_SUPPORTED ((NTSTATUS)0xC000004FL)
#define STATUS_EA_TOO_LARGE ((NTSTATUS)0xC0000050L)
#define STATUS_NONEXISTENT_EA_ENTRY ((NTSTATUS)0xC0000051L)
#define STATUS_NO_EAS_ON_FILE ((NTSTATUS)0xC0000052L)
#define STATUS_EA_CORRUPT_ERROR ((NTSTATUS)0xC0000053L)
#define STATUS_FILE_LOCK_CONFLICT ((NTSTATUS)0xC0000054L)
#define STATUS_LOCK_NOT_GRANTED ((NTSTATUS)0xC0000055L)
#define STATUS_DELETE_PENDING ((NTSTATUS)0xC0000056L)
#define STATUS_PRIVILEGE_NOT_HELD ((NTSTATUS)0xC0000061L)
#define STATUS_LOGON_FAILURE ((NTSTATUS)0xC000006DL) 
#define STATUS_RANGE_NOT_LOCKED ((NTSTATUS)0xC000007EL)
#define STATUS_DISK_FULL ((NTSTATUS)0xC000007FL)
#define STATUS_FILE_INVALID ((NTSTATUS)0xC0000098L)
#define STATUS_INSUFFICIENT_RESOURCES ((NTSTATUS)0xC000009AL) 
#define STATUS_DEVICE_DATA_ERROR ((NTSTATUS)0xC000009CL)
#define STATUS_DEVICE_NOT_CONNECTED ((NTSTATUS)0xC000009DL)
#define STATUS_MEDIA_WRITE_PROTECTED ((NTSTATUS)0xC00000A2L)
#define STATUS_BAD_IMPERSONATION_LEVEL ((NTSTATUS)0xC00000A5L)
#define STATUS_INSTANCE_NOT_AVAILABLE ((NTSTATUS)0xC00000ABL)
#define STATUS_PIPE_NOT_AVAILABLE ((NTSTATUS)0xC00000ACL)
#define STATUS_INVALID_PIPE_STATE ((NTSTATUS)0xC00000ADL)
#define STATUS_PIPE_BUSY ((NTSTATUS)0xC00000AEL)
#define STATUS_PIPE_DISCONNECTED ((NTSTATUS)0xC00000B0L)
#define STATUS_PIPE_CLOSING ((NTSTATUS)0xC00000B1L)
#define STATUS_PIPE_CONNECTED ((NTSTATUS)0xC00000B2L)
#define STATUS_PIPE_LISTENING ((NTSTATUS)0xC00000B3L)
#define STATUS_INVALID_READ_MODE ((NTSTATUS)0xC00000B4L)
#define STATUS_IO_TIMEOUT ((NTSTATUS)0xC00000B5L)
#define STATUS_FILE_IS_A_DIRECTORY ((NTSTATUS)0xC00000BAL)
#define STATUS_NOT_SUPPORTED ((NTSTATUS)0xC00000BBL)
#define STATUS_DUPLICATE_NAME ((NTSTATUS)0xC00000BDL)
#define STATUS_BAD_NETWORK_PATH ((NTSTATUS)0xC00000BEL)
#define STATUS_TOO_MANY_COMMANDS ((NTSTATUS)0xC00000C1L)
#define STATUS_INVALID_NETWORK_RESPONSE ((NTSTATUS)0xC00000C3L)
#define STATUS_UNEXPECTED_NETWORK_ERROR ((NTSTATUS)0xC00000C4L)
#define STATUS_BAD_NETWORK_NAME ((NTSTATUS)0xC00000CCL)
#define STATUS_NOT_SAME_DEVICE ((NTSTATUS)0xC00000D4L)
#define STATUS_CANT_WAIT ((NTSTATUS)0xC00000D8L)
#define STATUS_PIPE_EMPTY ((NTSTATUS)0xC00000D9L)
#define STATUS_CANT_TERMINATE_SELF ((NTSTATUS)0xC00000DBL)
#define STATUS_OPLOCK_NOT_GRANTED ((NTSTATUS)0xC00000E2L)
#define STATUS_INVALID_PARAMETER_1 ((NTSTATUS)0xC00000EFL)
#define STATUS_INVALID_PARAMETER_2 ((NTSTATUS)0xC00000F0L)
#define STATUS_INVALID_PARAMETER_3 ((NTSTATUS)0xC00000F1L)
#define STATUS_INVALID_PARAMETER_4 ((NTSTATUS)0xC00000F2L)
#define STATUS_REDIRECTOR_NOT_STARTED ((NTSTATUS)0xC00000FBL)

typedef struct _STATUS_DEF
{
	NTSTATUS Status;
	LPCTSTR lpszStatus;
}STATUS_DEF, *PSTATUS_DEF;

#define STATUS_DEF(_x) {(NTSTATUS)_x, TEXT(#_x)}

STATUS_DEF gStatus[] = {
	STATUS_DEF(STATUS_SUCCESS),
	STATUS_DEF(STATUS_UNSUCCESSFUL),
	STATUS_DEF(SEC_E_WRONG_PRINCIPAL),
	STATUS_DEF(STATUS_INVALID_EA_FLAG),
	STATUS_DEF(STATUS_DATATYPE_MISALIGNMENT),
	STATUS_DEF(STATUS_BUFFER_OVERFLOW),
	STATUS_DEF(STATUS_BUFFER_OVERFLOW),
	STATUS_DEF(STATUS_NO_MORE_FILES),
	STATUS_DEF(STATUS_PENDING),
	STATUS_DEF(STATUS_FLT_DISALLOW_FAST_IO),
	STATUS_DEF(STATUS_FILE_LOCKED_WITH_ONLY_READERS),
	STATUS_DEF(STATUS_REPARSE),
	STATUS_DEF(STATUS_MORE_ENTRIES),
	STATUS_DEF(STATUS_OPLOCK_BREAK_IN_PROGRESS),
	STATUS_DEF(STATUS_NOTIFY_CLEANUP),
	STATUS_DEF(STATUS_NOTIFY_ENUM_DIR),
	STATUS_DEF(STATUS_FILE_LOCKED_WITH_WRITERS),
	STATUS_DEF(STATUS_OPLOCK_SWITCHED_TO_NEW_HANDLE),
	STATUS_DEF(STATUS_OPLOCK_HANDLE_CLOSED),
	STATUS_DEF(STATUS_WAIT_FOR_OPLOCK),
	STATUS_DEF(STATUS_PREDEFINED_HANDLE),
	STATUS_DEF(STATUS_SPARSE_NOT_ALLOWED_IN_TRANSACTION),
	STATUS_DEF(STATUS_CANNOT_BREAK_OPLOCK),
	STATUS_DEF(STATUS_HIVE_UNLOADED),
	STATUS_DEF(STATUS_FILE_SYSTEM_LIMITATION),
	STATUS_DEF(STATUS_DEVICE_FEATURE_NOT_SUPPORTED),
	STATUS_DEF(STATUS_OFFLOAD_READ_FLT_NOT_SUPPORTED),
	STATUS_DEF(STATUS_OFFLOAD_WRITE_FLT_NOT_SUPPORTED),
	STATUS_DEF(STATUS_OFFLOAD_READ_FILE_NOT_SUPPORTED),
	STATUS_DEF(STATUS_TRANSACTIONAL_CONFLICT),
	STATUS_DEF(STATUS_INVALID_TRANSACTION),
	STATUS_DEF(STATUS_TRANSACTION_NOT_ACTIVE),
	STATUS_DEF(STATUS_EFS_NOT_ALLOWED_IN_TRANSACTION),
	STATUS_DEF(STATUS_TRANSACTED_MAPPING_UNSUPPORTED_REMOTE),
	STATUS_DEF(STATUS_CANNOT_EXECUTE_FILE_IN_TRANSACTION),
	STATUS_DEF(STATUS_DOWNGRADE_DETECTED),
	STATUS_DEF(STATUS_INSUFF_SERVER_RESOURCES),
	STATUS_DEF(STATUS_INVALID_ADDRESS_COMPONENT),
	STATUS_DEF(STATUS_CONNECTION_DISCONNECTED),
	STATUS_DEF(STATUS_NOT_FOUND),
	STATUS_DEF(STATUS_USER_MAPPED_FILE),
	STATUS_DEF(STATUS_LOGIN_WKSTA_RESTRICTION),
	STATUS_DEF(STATUS_PATH_NOT_COVERED),
	STATUS_DEF(STATUS_DFS_UNAVAILABLE),
	STATUS_DEF(STATUS_NO_MORE_MATCHES),
	STATUS_DEF(STATUS_NOT_A_REPARSE_POINT),
	STATUS_DEF(STATUS_CANNOT_MAKE),
	STATUS_DEF(STATUS_OBJECTID_NOT_FOUND),
	STATUS_DEF(STATUS_USER_SESSION_DELETED),
	STATUS_DEF(STATUS_FILE_CORRUPT_ERROR),
	STATUS_DEF(STATUS_NOT_A_DIRECTORY),
	STATUS_DEF(STATUS_FILES_OPEN),
	STATUS_DEF(STATUS_CANNOT_IMPERSONATE),
	STATUS_DEF(STATUS_CANCELLED),
	STATUS_DEF(STATUS_CANNOT_DELETE),
	STATUS_DEF(STATUS_FILE_DELETED),
	STATUS_DEF(STATUS_FILE_CLOSED),
	STATUS_DEF(STATUS_THREAD_NOT_IN_PROCESS),
	STATUS_DEF(STATUS_INVALID_LEVEL),
	STATUS_DEF(STATUS_PIPE_BROKEN),
	STATUS_DEF(STATUS_REGISTRY_CORRUPT),
	STATUS_DEF(STATUS_REGISTRY_IO_FAILED),
	STATUS_DEF(STATUS_KEY_DELETED),
	STATUS_DEF(STATUS_CHILD_MUST_BE_VOLATILE),
	STATUS_DEF(STATUS_INVALID_DEVICE_STATE),
	STATUS_DEF(STATUS_IO_DEVICE_ERROR),
	STATUS_DEF(STATUS_LOG_FILE_FULL),
	STATUS_DEF(STATUS_FS_DRIVER_REQUIRED),
	STATUS_DEF(STATUS_DIRECTORY_NOT_EMPTY),
	STATUS_DEF(STATUS_NOT_IMPLEMENTED),
	STATUS_DEF(STATUS_INVALID_INFO_CLASS),
	STATUS_DEF(STATUS_INFO_LENGTH_MISMATCH),
	STATUS_DEF(STATUS_ACCESS_VIOLATION),
	STATUS_DEF(STATUS_IN_PAGE_ERROR),
	STATUS_DEF(STATUS_INVALID_HANDLE),
	STATUS_DEF(STATUS_INVALID_PARAMETER),
	STATUS_DEF(STATUS_NO_SUCH_DEVICE),
	STATUS_DEF(STATUS_NO_SUCH_FILE),
	STATUS_DEF(STATUS_INVALID_DEVICE_REQUEST),
	STATUS_DEF(STATUS_END_OF_FILE),
	STATUS_DEF(STATUS_WRONG_VOLUME),
	STATUS_DEF(STATUS_NO_MEDIA_IN_DEVICE),
	STATUS_DEF(STATUS_NONEXISTENT_SECTOR),
	STATUS_DEF(STATUS_NO_MEMORY),
	STATUS_DEF(STATUS_ALREADY_COMMITTED),
	STATUS_DEF(STATUS_ACCESS_DENIED),
	STATUS_DEF(STATUS_BUFFER_TOO_SMALL),
	STATUS_DEF(STATUS_OBJECT_TYPE_MISMATCH),
	STATUS_DEF(STATUS_DISK_CORRUPT_ERROR),
	STATUS_DEF(STATUS_OBJECT_NAME_INVALID),
	STATUS_DEF(STATUS_OBJECT_NAME_NOT_FOUND),
	STATUS_DEF(STATUS_OBJECT_NAME_COLLISION),
	STATUS_DEF(STATUS_OBJECT_PATH_INVALID),
	STATUS_DEF(STATUS_OBJECT_PATH_NOT_FOUND),
	STATUS_DEF(STATUS_OBJECT_PATH_SYNTAX_BAD),
	STATUS_DEF(STATUS_DATA_OVERRUN),
	STATUS_DEF(STATUS_CRC_ERROR),
	STATUS_DEF(STATUS_SHARING_VIOLATION),
	STATUS_DEF(STATUS_QUOTA_EXCEEDED),
	STATUS_DEF(STATUS_EAS_NOT_SUPPORTED),
	STATUS_DEF(STATUS_EA_TOO_LARGE),
	STATUS_DEF(STATUS_NONEXISTENT_EA_ENTRY),
	STATUS_DEF(STATUS_NO_EAS_ON_FILE),
	STATUS_DEF(STATUS_EA_CORRUPT_ERROR),
	STATUS_DEF(STATUS_FILE_LOCK_CONFLICT),
	STATUS_DEF(STATUS_LOCK_NOT_GRANTED),
	STATUS_DEF(STATUS_DELETE_PENDING),
	STATUS_DEF(STATUS_PRIVILEGE_NOT_HELD),
	STATUS_DEF(STATUS_LOGON_FAILURE),
	STATUS_DEF(STATUS_RANGE_NOT_LOCKED),
	STATUS_DEF(STATUS_DISK_FULL),
	STATUS_DEF(STATUS_FILE_INVALID),
	STATUS_DEF(STATUS_INSUFFICIENT_RESOURCES),
	STATUS_DEF(STATUS_DEVICE_DATA_ERROR),
	STATUS_DEF(STATUS_DEVICE_NOT_CONNECTED),
	STATUS_DEF(STATUS_MEDIA_WRITE_PROTECTED),
	STATUS_DEF(STATUS_BAD_IMPERSONATION_LEVEL),
	STATUS_DEF(STATUS_INSTANCE_NOT_AVAILABLE),
	STATUS_DEF(STATUS_PIPE_NOT_AVAILABLE),
	STATUS_DEF(STATUS_INVALID_PIPE_STATE),
	STATUS_DEF(STATUS_PIPE_BUSY),
	STATUS_DEF(STATUS_PIPE_DISCONNECTED),
	STATUS_DEF(STATUS_PIPE_CLOSING),
	STATUS_DEF(STATUS_PIPE_CONNECTED),
	STATUS_DEF(STATUS_PIPE_LISTENING),
	STATUS_DEF(STATUS_INVALID_READ_MODE),
	STATUS_DEF(STATUS_IO_TIMEOUT),
	STATUS_DEF(STATUS_FILE_IS_A_DIRECTORY),
	STATUS_DEF(STATUS_NOT_SUPPORTED),
	STATUS_DEF(STATUS_DUPLICATE_NAME),
	STATUS_DEF(STATUS_BAD_NETWORK_PATH),
	STATUS_DEF(STATUS_TOO_MANY_COMMANDS),
	STATUS_DEF(STATUS_INVALID_NETWORK_RESPONSE),
	STATUS_DEF(STATUS_UNEXPECTED_NETWORK_ERROR),
	STATUS_DEF(STATUS_BAD_NETWORK_NAME),
	STATUS_DEF(STATUS_NOT_SAME_DEVICE),
	STATUS_DEF(STATUS_CANT_WAIT),
	STATUS_DEF(STATUS_PIPE_EMPTY),
	STATUS_DEF(STATUS_CANT_TERMINATE_SELF),
	STATUS_DEF(STATUS_OPLOCK_NOT_GRANTED),
	STATUS_DEF(STATUS_INVALID_PARAMETER_1),
	STATUS_DEF(STATUS_INVALID_PARAMETER_2),
	STATUS_DEF(STATUS_INVALID_PARAMETER_3),
	STATUS_DEF(STATUS_INVALID_PARAMETER_4),
	STATUS_DEF(STATUS_REDIRECTOR_NOT_STARTED)
};

LPCTSTR
StrMapNtStatus(
	_In_ NTSTATUS Status
)
{
	for (int i = 0; i < _countof(gStatus); i++)
	{
		if (gStatus[i].Status == Status) {
			return gStatus[i].lpszStatus;
		}
	}
	return NULL;
}


typedef struct _DWORD_DEF
{
	DWORD dwValue;
	LPCTSTR lpszDword;
}DWORD_DEF, * PDWORD_DEF;
#define DWORD_DEF(_x) {(DWORD)_x, TEXT(#_x)}

DWORD_DEF gSecurityInformation[] = {
	DWORD_DEF(OWNER_SECURITY_INFORMATION),
	DWORD_DEF(GROUP_SECURITY_INFORMATION),
	DWORD_DEF(DACL_SECURITY_INFORMATION),
	DWORD_DEF(SACL_SECURITY_INFORMATION),
	DWORD_DEF(LABEL_SECURITY_INFORMATION),
	DWORD_DEF(ATTRIBUTE_SECURITY_INFORMATION),
	DWORD_DEF(SCOPE_SECURITY_INFORMATION),
	DWORD_DEF(PROCESS_TRUST_LABEL_SECURITY_INFORMATION),
	DWORD_DEF(ACCESS_FILTER_SECURITY_INFORMATION),
	DWORD_DEF(BACKUP_SECURITY_INFORMATION),
	DWORD_DEF(PROTECTED_DACL_SECURITY_INFORMATION),
	DWORD_DEF(PROTECTED_SACL_SECURITY_INFORMATION),
	DWORD_DEF(UNPROTECTED_DACL_SECURITY_INFORMATION),
	DWORD_DEF(UNPROTECTED_SACL_SECURITY_INFORMATION)
};

CString
StrMapSecurityInformation(
	_In_ DWORD dwSecurityInformation
)
{
	CString strRet;
	for (int i = 0; i < _countof(gSecurityInformation); i++)
	{
		if (dwSecurityInformation & gSecurityInformation[i].dwValue) {
			strRet += gSecurityInformation[i].lpszDword;
			strRet += TEXT("|");
		}
	}

	strRet.TrimRight(TEXT("|"));
	return strRet;
}

DWORD_DEF gFileAccessMask[] = {
// 	DWORD_DEF(GENERIC_READ),
// 	DWORD_DEF(GENERIC_WRITE),
// 	DWORD_DEF(GENERIC_EXECUTE),
	DWORD_DEF(FILE_ALL_ACCESS),
	DWORD_DEF(FILE_GENERIC_READ),
	DWORD_DEF(FILE_GENERIC_WRITE),
	DWORD_DEF(FILE_GENERIC_EXECUTE),
	DWORD_DEF(FILE_READ_DATA),
	DWORD_DEF(FILE_WRITE_DATA),
	DWORD_DEF(FILE_APPEND_DATA),
	DWORD_DEF(FILE_READ_EA),
	DWORD_DEF(FILE_WRITE_EA),
	DWORD_DEF(FILE_EXECUTE),
	DWORD_DEF(FILE_DELETE_CHILD),
	DWORD_DEF(FILE_READ_ATTRIBUTES),
	DWORD_DEF(FILE_WRITE_ATTRIBUTES),
	DWORD_DEF(SYNCHRONIZE),
	DWORD_DEF(WRITE_DAC),
	DWORD_DEF(WRITE_OWNER),
	DWORD_DEF(DELETE),
	DWORD_DEF(READ_CONTROL),
	DWORD_DEF(ACCESS_SYSTEM_SECURITY),
};


CString
StrMapFileAccessMask(
	_In_ DWORD AccessMask
)
{
	CString strAccessMask;

	for (int i = 0; i < _countof(gFileAccessMask); i++)
	{
		DWORD dwValue = gFileAccessMask[i].dwValue;

		if (i < 4) {
			if (dwValue == AccessMask) {
				strAccessMask = gFileAccessMask[i].lpszDword;
				break;
			}
		}else{
			if (dwValue & AccessMask) {
				strAccessMask += gFileAccessMask[i].lpszDword;
				strAccessMask += TEXT('|');
			}
		}
	}
	strAccessMask.TrimRight(TEXT("|"));
	return strAccessMask;
}

DWORD_DEF gFileShareAccess[] = {
	DWORD_DEF(FILE_SHARE_READ),
	DWORD_DEF(FILE_SHARE_WRITE),
	DWORD_DEF(FILE_SHARE_DELETE),
};


CString
StrMapFileShareAccess(
	_In_ DWORD ShareAccess
)
{
	CString strAccessMask;

	for (int i = 0; i < _countof(gFileShareAccess); i++)
	{
		if (gFileShareAccess[i].dwValue & ShareAccess) {
			strAccessMask += gFileShareAccess[i].lpszDword;
			strAccessMask += TEXT('|');

			ShareAccess = (~gFileShareAccess[i].dwValue) & ShareAccess;
		}
	}
	strAccessMask.TrimRight(TEXT("|"));
	return strAccessMask;
}

DWORD_DEF gFileCreateDisposition[] = {
	DWORD_DEF(FILE_SUPERSEDE),
	DWORD_DEF(FILE_OPEN),
	DWORD_DEF(FILE_CREATE),
	DWORD_DEF(FILE_OPEN_IF),
	DWORD_DEF(FILE_OVERWRITE),
	DWORD_DEF(FILE_OVERWRITE_IF),
};

LPCTSTR
StrMapFileCreateDisposition(
	_In_ DWORD CreateDisposition
)
{
	for (int i = 0; i < _countof(gFileCreateDisposition); i++)
	{
		if (gFileCreateDisposition[i].dwValue == CreateDisposition) {
			return gFileCreateDisposition[i].lpszDword;
		}
	}
	return NULL;
}

DWORD_DEF gFileRetDisposition[] = {
	DWORD_DEF(FILE_SUPERSEDE),
	DWORD_DEF(FILE_OPENED),
	DWORD_DEF(FILE_CREATED),
	DWORD_DEF(FILE_OVERWRITTEN),
	DWORD_DEF(FILE_EXISTS),
	DWORD_DEF(FILE_DOES_NOT_EXIST),
};

LPCTSTR
StrMapFileRetDisposition(
	_In_ DWORD CreateDisposition
)
{
	for (int i = 0; i < _countof(gFileRetDisposition); i++)
	{
		if (gFileRetDisposition[i].dwValue == CreateDisposition) {
			return gFileRetDisposition[i].lpszDword;
		}
	}
	return NULL;
}

#define FILE_DISALLOW_EXCLUSIVE                 0x00020000
#define FILE_SESSION_AWARE                      0x00040000

DWORD_DEF gFileCreateOptions[] = {
	DWORD_DEF(FILE_DIRECTORY_FILE),
	DWORD_DEF(FILE_WRITE_THROUGH),
	DWORD_DEF(FILE_SEQUENTIAL_ONLY),
	DWORD_DEF(FILE_NO_INTERMEDIATE_BUFFERING),
	DWORD_DEF(FILE_SYNCHRONOUS_IO_ALERT),
	DWORD_DEF(FILE_SYNCHRONOUS_IO_NONALERT),
	DWORD_DEF(FILE_NON_DIRECTORY_FILE),
	DWORD_DEF(FILE_CREATE_TREE_CONNECTION),
	DWORD_DEF(FILE_COMPLETE_IF_OPLOCKED),
	DWORD_DEF(FILE_NO_EA_KNOWLEDGE),
	DWORD_DEF(FILE_OPEN_REMOTE_INSTANCE),
	DWORD_DEF(FILE_RANDOM_ACCESS),
	DWORD_DEF(FILE_DELETE_ON_CLOSE),
	DWORD_DEF(FILE_OPEN_BY_FILE_ID),
	DWORD_DEF(FILE_OPEN_FOR_BACKUP_INTENT),
	DWORD_DEF(FILE_NO_COMPRESSION),
	DWORD_DEF(FILE_OPEN_REQUIRING_OPLOCK),
	DWORD_DEF(FILE_DISALLOW_EXCLUSIVE),
	DWORD_DEF(FILE_SESSION_AWARE),
	DWORD_DEF(FILE_RESERVE_OPFILTER),
	DWORD_DEF(FILE_OPEN_REPARSE_POINT),
	DWORD_DEF(FILE_OPEN_NO_RECALL),
	DWORD_DEF(FILE_OPEN_FOR_FREE_SPACE_QUERY)
};

CString
StrMapFileCreateOptions(
	_In_ DWORD CreateOptions
)
{
	CString strRet;

	for (int i = 0; i < _countof(gFileCreateOptions); i++)
	{
		if (gFileCreateOptions[i].dwValue & CreateOptions) {
			strRet += gFileCreateOptions[i].lpszDword;
			strRet += TEXT('|');

			CreateOptions = (~gFileCreateOptions[i].dwValue) & CreateOptions;
		}
	}
	strRet.TrimRight(TEXT("|"));
	return strRet;
}

DWORD_DEF gFileAttributes[] = {
	DWORD_DEF(FILE_ATTRIBUTE_READONLY),
	DWORD_DEF(FILE_ATTRIBUTE_HIDDEN),
	DWORD_DEF(FILE_ATTRIBUTE_SYSTEM),
	DWORD_DEF(FILE_ATTRIBUTE_DIRECTORY),
	DWORD_DEF(FILE_ATTRIBUTE_ARCHIVE),
	DWORD_DEF(FILE_ATTRIBUTE_DEVICE),
	DWORD_DEF(FILE_ATTRIBUTE_NORMAL),
	DWORD_DEF(FILE_ATTRIBUTE_TEMPORARY),
	DWORD_DEF(FILE_ATTRIBUTE_SPARSE_FILE),
	DWORD_DEF(FILE_ATTRIBUTE_REPARSE_POINT),
	DWORD_DEF(FILE_ATTRIBUTE_COMPRESSED),
	DWORD_DEF(FILE_ATTRIBUTE_OFFLINE),
	DWORD_DEF(FILE_ATTRIBUTE_NOT_CONTENT_INDEXED),
	DWORD_DEF(FILE_ATTRIBUTE_ENCRYPTED),
	DWORD_DEF(FILE_ATTRIBUTE_INTEGRITY_STREAM)
};


CString
StrMapFileAttributes(
	_In_ DWORD FileAttributes
)
{
	CString strRet;

	for (int i = 0; i < _countof(gFileAttributes); i++)
	{
		if (gFileAttributes[i].dwValue & FileAttributes) {
			strRet += gFileAttributes[i].lpszDword;
			strRet += TEXT('|');

			FileAttributes = (~gFileAttributes[i].dwValue) & FileAttributes;
		}
	}
	strRet.TrimRight(TEXT("|"));
	return strRet;
}

typedef struct _OPT_CLASS_MAP
{
	int Class;
	LPCTSTR lpClassName;
}OPT_CLASS_MAP, *POPT_CLASS_MAP;

OPT_CLASS_MAP gClassMap[] = {
	{MONITOR_TYPE_POST, TEXT("Completion")},
	{MONITOR_TYPE_PROCESS, TEXT("Process")},
	{MONITOR_TYPE_REG, TEXT("Registery")},
	{MONITOR_TYPE_FILE, TEXT("File System")},
	{MONITOR_TYPE_PROFILING, TEXT("Profiling")},
};

LPCTSTR
StrMapClassEvent(
	_In_ int Class
)
{
	for (int i = 0; i < _countof(gClassMap); i++)
	{
		if (gClassMap[i].Class == Class) {
			return gClassMap[i].lpClassName;
		}
	}
	return NULL;
}

typedef struct _OPT_OPERATOR_MAP
{
	int Operator;
	LPCTSTR lpOptName;
}OPT_OPERATOR_MAP, * POPT_OPERATOR_MAP;

OPT_OPERATOR_MAP gProcOptMap[] = {
	{NOTIFY_PROCESS_INIT, TEXT("Process Init")},
	{NOTIFY_PROCESS_CREATE, TEXT("Process Create")},
	{NOTIFY_PROCESS_EXIT, TEXT("Process Exit")},
	{NOTIFY_THREAD_CREATE, TEXT("Thread Create")},
	{NOTIFY_THREAD_EXIT, TEXT("Thread Exit")},
	{NOTIFY_IMAGE_LOAD, TEXT("Load Image")},
	{NOTIFY_PROCESS_THREADPERFORMANCE, TEXT("Thread Profile")},
	{NOTIFY_PROCESS_START, TEXT("Process Start")},
	{NOTIFY_PROCESS_PERFORMANCE, TEXT("Process Statistics")},
	{NOTIFY_SYSTEM_PERFORMANCE, TEXT("System Statistics")},
};


OPT_OPERATOR_MAP gRegOptMap[] = {
	{NOTIFY_REG_OPENKEYEX, TEXT("RegOpenKey")},
	{NOTIFY_REG_CREATEKEYEX, TEXT("RegCreateKey")},
	{NOTIFY_REG_KEYHANDLECLOSE, TEXT("RegCloseKey")},
	{NOTIFY_REG_QUERYKEY, TEXT("RegQueryKey")},
	{NOTIFY_REG_SETVALUEKEY, TEXT("RegSetValueKey")},
	{NOTIFY_REG_QUERYVALUEKEY, TEXT("RegQueryValueKey")},
	{NOTIFY_REG_ENUMERATEVALUEKEY, TEXT("RegEnumValueKey")},
	{NOTIFY_REG_ENUMERATEKEY, TEXT("RegEnumKey")},
	{NOTIFY_REG_SETINFORMATIONKEY, TEXT("RegSetInfoKey")},
	{NOTIFY_REG_DELETEKEY, TEXT("RegDeletKey")},
	{NOTIFY_REG_DELETEVALUEKEY, TEXT("RegDeletValueKey")},
	{NOTIFY_REG_FLUSHKEY, TEXT("RegFlushKey")},
	{NOTIFY_REG_LOADKEY, TEXT("RegLoadKey")},
	{NOTIFY_REG_UNLOADKEY, TEXT("RegUnLoadKey")},
	{NOTIFY_REG_RENAMEKEY, TEXT("RegRenameKey")},
	{NOTIFY_REG_QUERYMULTIPLEVALUEKEY, TEXT("RegQueryMultipleValueKey")},
	{NOTIFY_REG_SETKEYSECURITY, TEXT("RegSetKeySecurity")},
	{NOTIFY_REG_QUERYKEYSECURITY, TEXT("RegQueryKeySecurity")},
};


#define FILE_SUB_OPT_DEF(_minjor, _fastioname, _show) {_minjor, _fastioname, _show}
#define FILE_SUB_OPT_DEF_END() {0, NULL, NULL}
typedef struct _FILE_OPT_SUB_DESC
{
	UCHAR Minjor;
	LPCTSTR lpszFastIoName;
	LPCTSTR lpszShowName;
}FILE_OPT_SUB_DESC, *PFILE_OPT_SUB_DESC;


#define IRP_MAP_DEF(_x, _show, _psub) {(UCHAR)_x, TEXT(#_x), _show, _psub}
typedef struct _OPT_FILE_OPERATOR_MAP
{
	UCHAR Major;
	LPCTSTR lpOptName;
	LPCTSTR lpszShowName;
	PFILE_OPT_SUB_DESC pSubDesc;
}OPT_FILE_OPERATOR_MAP, * POPT_FILE_OPERATOR_MAP;


FILE_OPT_SUB_DESC gFileSubMapLockControl[] = {
	FILE_SUB_OPT_DEF(1, TEXT("FASTIO_LOCK"), TEXT("LockFile")),
	FILE_SUB_OPT_DEF(2, TEXT("FASTIO_UNLOCK_SINGLE"), TEXT("UnlockFileSingle")),
	FILE_SUB_OPT_DEF(3, TEXT("FASTIO_UNLOCK_ALL"), TEXT("UnlockFileAll")),
	FILE_SUB_OPT_DEF(4, TEXT("FASTIO_UNLOCK_ALL_BY_KEY"), TEXT("UnlockFileByKey")),
	FILE_SUB_OPT_DEF_END(),
};

FILE_OPT_SUB_DESC gFileSubMapRead[] = {
	FILE_SUB_OPT_DEF(0xFF, TEXT("FASTIO_READ"), TEXT("ReadFile")),
	FILE_SUB_OPT_DEF_END(),
};

FILE_OPT_SUB_DESC gFileSubMapWrite[] = {
	FILE_SUB_OPT_DEF(0xFF, TEXT("FASTIO_WRITE"), TEXT("WriteFile")),
	FILE_SUB_OPT_DEF_END(),
};

FILE_OPT_SUB_DESC gFileSubMapQueryInfo[] = {
	FILE_SUB_OPT_DEF(0x12, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryAllInformationFile")),
	FILE_SUB_OPT_DEF(0x23, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryAttributeTagFile")),
	FILE_SUB_OPT_DEF(0x04, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryBasicInformationFile")),
	FILE_SUB_OPT_DEF(0x1c, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryCompressionInformationFile")),
	FILE_SUB_OPT_DEF(0x07, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryEaInformationFile")),
	FILE_SUB_OPT_DEF(0x06, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryFileInternalInformationFile")),
	FILE_SUB_OPT_DEF(0x1f, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryMoveClusterInformationFile")),
	FILE_SUB_OPT_DEF(0x22, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryNetworkOpenInformationFile")),
	FILE_SUB_OPT_DEF(0x0e, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryPositionInformationFile")),
	FILE_SUB_OPT_DEF(0x05, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryStandardInformationFile")),
	FILE_SUB_OPT_DEF(0x16, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryStreamInformationFile")),
	FILE_SUB_OPT_DEF(0x09, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryNameInformationFile")),
	FILE_SUB_OPT_DEF(0x28, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryShortNameInformationFile")),
	FILE_SUB_OPT_DEF(0x30, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryNormalizedNameInformationFile")),
	FILE_SUB_OPT_DEF(0x31, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryNetworkPhysicalNameInformationFile")),
	FILE_SUB_OPT_DEF(0x25, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryIdBothDirectory")),
	FILE_SUB_OPT_DEF(0x27, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryValidDataLength")),
	FILE_SUB_OPT_DEF(0x2b, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryIoPiorityHint")),
	FILE_SUB_OPT_DEF(0x2e, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryLinks")),
	FILE_SUB_OPT_DEF(0x1d, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryId")),
	FILE_SUB_OPT_DEF(0x14, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryEndOfFile")),
	FILE_SUB_OPT_DEF(0x23, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryAttributeTag")),
	FILE_SUB_OPT_DEF(0x32, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryIdGlobalTxDirectoryInformation")),
	FILE_SUB_OPT_DEF(0x33, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryIsRemoteDeviceInformation")),
	FILE_SUB_OPT_DEF(0x34, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryAttributeCacheInformation")),
	FILE_SUB_OPT_DEF(0x35, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryNumaNodeInformation")),
	FILE_SUB_OPT_DEF(0x36, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryStandardLinkInformation")),
	FILE_SUB_OPT_DEF(0x37, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryRemoteProtocolInformation")),
	FILE_SUB_OPT_DEF(0x38, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryRenameInformationBypassAccessCheck")),
	FILE_SUB_OPT_DEF(0x39, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryLinkInformationBypassAccessCheck")),
	FILE_SUB_OPT_DEF(0x3a, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryVolumeNameInformation")),
	FILE_SUB_OPT_DEF(0x3b, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryIdInformation")),
	FILE_SUB_OPT_DEF(0x3c, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryIdExtdDirectoryInformation")),
	FILE_SUB_OPT_DEF(0x3e, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryHardLinkFullIdInformation")),
	FILE_SUB_OPT_DEF(0x3f, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryIdExtdBothDirectoryInformation")),
	FILE_SUB_OPT_DEF(0x43, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryDesiredStorageClassInformation")),
	FILE_SUB_OPT_DEF(0x44, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryStatInformation")),
	FILE_SUB_OPT_DEF(0x45, TEXT("FASTIO_QUERY_INFORMATION"), TEXT("QueryMemoryPartitionInformation")),
	FILE_SUB_OPT_DEF_END(),
};

FILE_OPT_SUB_DESC gFileSubMapSetInfo[] = {
	FILE_SUB_OPT_DEF(0x13, TEXT("FASTIO_SET_INFORMATION"), TEXT("SetAllocationInformationFile")),
	FILE_SUB_OPT_DEF(0x0d, TEXT("FASTIO_SET_INFORMATION"), TEXT("SetDispositionInformationFile")),
	FILE_SUB_OPT_DEF(0x04, TEXT("FASTIO_SET_INFORMATION"), TEXT("SetBasicInformationFile")),
	FILE_SUB_OPT_DEF(0x14, TEXT("FASTIO_SET_INFORMATION"), TEXT("SetEndOfFileInformationFile")),
	FILE_SUB_OPT_DEF(0x0b, TEXT("FASTIO_SET_INFORMATION"), TEXT("SetLinkInformationFile")),
	FILE_SUB_OPT_DEF(0x0e, TEXT("FASTIO_SET_INFORMATION"), TEXT("SetPositionInformationFile")),
	FILE_SUB_OPT_DEF(0x0a, TEXT("FASTIO_SET_INFORMATION"), TEXT("SetRenameInformationFile")),
	FILE_SUB_OPT_DEF(0x27, TEXT("FASTIO_SET_INFORMATION"), TEXT("SetValidDataLengthInformationFile")),
	FILE_SUB_OPT_DEF(0x16, TEXT("FASTIO_SET_INFORMATION"), TEXT("SetFileStreamInformation")),
	FILE_SUB_OPT_DEF(0x17, TEXT("FASTIO_SET_INFORMATION"), TEXT("SetPipeInformation")),
	FILE_SUB_OPT_DEF(0x28, TEXT("FASTIO_SET_INFORMATION"), TEXT("SetShortNameInformation")),
	FILE_SUB_OPT_DEF(0x40, TEXT("FASTIO_SET_INFORMATION"), TEXT("SetDispositionInformationEx")),
	FILE_SUB_OPT_DEF(0x3d, TEXT("FASTIO_SET_INFORMATION"), TEXT("SetReplaceCompletionInformation")),
	FILE_SUB_OPT_DEF(0x41, TEXT("FASTIO_SET_INFORMATION"), TEXT("SetRenameInformationEx")),
	FILE_SUB_OPT_DEF(0x42, TEXT("FASTIO_SET_INFORMATION"), TEXT("SetRenameInformationExBypassAccessCheck")),
	FILE_SUB_OPT_DEF_END(),
};

FILE_OPT_SUB_DESC gFileSubMapQueryVolumeInfo[] = {
	FILE_SUB_OPT_DEF(0x01, TEXT("FASTIO_QUERY_VOLUME_INFORMATION"), TEXT("QueryInformationVolume")),
	FILE_SUB_OPT_DEF(0x02, TEXT("FASTIO_QUERY_VOLUME_INFORMATION"), TEXT("QueryLabelInformationVolume")),
	FILE_SUB_OPT_DEF(0x03, TEXT("FASTIO_QUERY_VOLUME_INFORMATION"), TEXT("QuerySizeInformationVolume")),
	FILE_SUB_OPT_DEF(0x04, TEXT("FASTIO_QUERY_VOLUME_INFORMATION"), TEXT("QueryDeviceInformationVolume")),
	FILE_SUB_OPT_DEF(0x05, TEXT("FASTIO_QUERY_VOLUME_INFORMATION"), TEXT("QueryAttributeInformationVolume")),
	FILE_SUB_OPT_DEF(0x06, TEXT("FASTIO_QUERY_VOLUME_INFORMATION"), TEXT("QueryControlInformationVolume")),
	FILE_SUB_OPT_DEF(0x07, TEXT("FASTIO_QUERY_VOLUME_INFORMATION"), TEXT("QueryFullSizeInformationVolume")),
	FILE_SUB_OPT_DEF(0x08, TEXT("FASTIO_QUERY_VOLUME_INFORMATION"), TEXT("QueryObjectIdInformationVolume")),
	FILE_SUB_OPT_DEF_END(),
};

FILE_OPT_SUB_DESC gFileSubMapDirControl[] = {
	FILE_SUB_OPT_DEF(0x01, TEXT("FASTIO_DIRECTORY_CONTROL"), TEXT("QueryDirectory")),
	FILE_SUB_OPT_DEF(0x02, TEXT("FASTIO_DIRECTORY_CONTROL"), TEXT("NotifyChangeDirectory")),
	FILE_SUB_OPT_DEF_END(),
};

FILE_OPT_SUB_DESC gFileSubMapPnp[] = {
	FILE_SUB_OPT_DEF(0x00, TEXT("IRP_MJ_PNP"), TEXT("StartDevice")),
	FILE_SUB_OPT_DEF(0x01, TEXT("IRP_MJ_PNP"), TEXT("QueryRemoveDevice")),
	FILE_SUB_OPT_DEF(0x02, TEXT("IRP_MJ_PNP"), TEXT("RemoveDevice")),
	FILE_SUB_OPT_DEF(0x03, TEXT("IRP_MJ_PNP"), TEXT("CancelRemoveDevice")),
	FILE_SUB_OPT_DEF(0x04, TEXT("IRP_MJ_PNP"), TEXT("StopDevice")),
	FILE_SUB_OPT_DEF(0x05, TEXT("IRP_MJ_PNP"), TEXT("QueryStopDevice")),
	FILE_SUB_OPT_DEF(0x06, TEXT("IRP_MJ_PNP"), TEXT("CancelStopDevice")),
	FILE_SUB_OPT_DEF(0x07, TEXT("IRP_MJ_PNP"), TEXT("QueryDeviceRelations")),
	FILE_SUB_OPT_DEF(0x08, TEXT("IRP_MJ_PNP"), TEXT("QueryInterface")),
	FILE_SUB_OPT_DEF(0x09, TEXT("IRP_MJ_PNP"), TEXT("QueryCapabilities")),
	FILE_SUB_OPT_DEF(0x0a, TEXT("IRP_MJ_PNP"), TEXT("QueryResources")),
	FILE_SUB_OPT_DEF(0x0b, TEXT("IRP_MJ_PNP"), TEXT("QueryResourceRequirements")),
	FILE_SUB_OPT_DEF(0x0c, TEXT("IRP_MJ_PNP"), TEXT("QueryDeviceText")),
	FILE_SUB_OPT_DEF(0x0d, TEXT("IRP_MJ_PNP"), TEXT("FilterResourceRequirements")),
	FILE_SUB_OPT_DEF(0x0f, TEXT("IRP_MJ_PNP"), TEXT("ReadConfig")),
	FILE_SUB_OPT_DEF(0x10, TEXT("IRP_MJ_PNP"), TEXT("WriteConfig")),
	FILE_SUB_OPT_DEF(0x11, TEXT("IRP_MJ_PNP"), TEXT("Eject")),
	FILE_SUB_OPT_DEF(0x12, TEXT("IRP_MJ_PNP"), TEXT("SetLock")),
	FILE_SUB_OPT_DEF(0x13, TEXT("IRP_MJ_PNP"), TEXT("QueryId")),
	FILE_SUB_OPT_DEF(0x14, TEXT("IRP_MJ_PNP"), TEXT("QueryPnpDeviceState")),
	FILE_SUB_OPT_DEF(0x15, TEXT("IRP_MJ_PNP"), TEXT("QueryBusInformation")),
	FILE_SUB_OPT_DEF(0x16, TEXT("IRP_MJ_PNP"), TEXT("DeviceUsageNotification")),
	FILE_SUB_OPT_DEF(0x17, TEXT("IRP_MJ_PNP"), TEXT("SurpriseRemoval")),
	FILE_SUB_OPT_DEF(0x18, TEXT("IRP_MJ_PNP"), TEXT("QueryLegacyBusInformation")),
	FILE_SUB_OPT_DEF_END(),
};


OPT_FILE_OPERATOR_MAP gFileOptMap[] = {
	IRP_MAP_DEF(IRP_MJ_CREATE, TEXT("CreateFile"), NULL),
	IRP_MAP_DEF(IRP_MJ_CREATE_NAMED_PIPE, TEXT("CreatePipe"), NULL),
	IRP_MAP_DEF(IRP_MJ_CLOSE, TEXT("IRP_MJ_CLOSE"), NULL),
	IRP_MAP_DEF(IRP_MJ_READ, TEXT("ReadFile"), gFileSubMapRead),
	IRP_MAP_DEF(IRP_MJ_WRITE, TEXT("WriteFile"), gFileSubMapWrite),
	IRP_MAP_DEF(IRP_MJ_QUERY_INFORMATION, TEXT("QueryInformationFile"), gFileSubMapQueryInfo),
	IRP_MAP_DEF(IRP_MJ_SET_INFORMATION, TEXT("SetInformationFile"), gFileSubMapSetInfo),
	IRP_MAP_DEF(IRP_MJ_QUERY_EA, TEXT("QueryEAFile"), NULL),
	IRP_MAP_DEF(IRP_MJ_SET_EA, TEXT("SetEAFile"), NULL),
	IRP_MAP_DEF(IRP_MJ_FLUSH_BUFFERS, TEXT("FlushBuffersFile"), NULL),
	IRP_MAP_DEF(IRP_MJ_QUERY_VOLUME_INFORMATION, TEXT("QueryVolumeInformation"), gFileSubMapQueryVolumeInfo),
	IRP_MAP_DEF(IRP_MJ_SET_VOLUME_INFORMATION, TEXT("SetVolumeInformation"), NULL),
	IRP_MAP_DEF(IRP_MJ_DIRECTORY_CONTROL, TEXT("DirectoryControl"), gFileSubMapDirControl),
	IRP_MAP_DEF(IRP_MJ_FILE_SYSTEM_CONTROL, TEXT("FileSystemControl"), NULL),
	IRP_MAP_DEF(IRP_MJ_DEVICE_CONTROL, TEXT("DeviceIoControl"), NULL),
	IRP_MAP_DEF(IRP_MJ_INTERNAL_DEVICE_CONTROL, TEXT("InternalDeviceIoControl"), NULL),
	IRP_MAP_DEF(IRP_MJ_SHUTDOWN, TEXT("Shutdown"), NULL),
	IRP_MAP_DEF(IRP_MJ_LOCK_CONTROL, TEXT("LockUnlockFile"), gFileSubMapLockControl),
	IRP_MAP_DEF(IRP_MJ_CLEANUP, TEXT("CloseFile"), NULL),
	IRP_MAP_DEF(IRP_MJ_CREATE_MAILSLOT, TEXT("CreateMailSlot"), NULL),
	IRP_MAP_DEF(IRP_MJ_QUERY_SECURITY, TEXT("QuerySecurityFile"), NULL),
	IRP_MAP_DEF(IRP_MJ_SET_SECURITY, TEXT("SetSecurityFile"), NULL),
	IRP_MAP_DEF(IRP_MJ_POWER, TEXT("Power"), NULL),
	IRP_MAP_DEF(IRP_MJ_SYSTEM_CONTROL, TEXT("SystemControl"), NULL),
	IRP_MAP_DEF(IRP_MJ_DEVICE_CHANGE, TEXT("DeviceChange"), NULL),
	IRP_MAP_DEF(IRP_MJ_QUERY_QUOTA, TEXT("QueryFileQuota"), NULL),
	IRP_MAP_DEF(IRP_MJ_SET_QUOTA, TEXT("SetFileQuota"), NULL),
	IRP_MAP_DEF(IRP_MJ_PNP, TEXT("PlugAndPlay"), gFileSubMapPnp),

	IRP_MAP_DEF(IRP_MJ_ACQUIRE_FOR_SECTION_SYNCHRONIZATION, TEXT("CreateFileMapping"), NULL),
	IRP_MAP_DEF(IRP_MJ_RELEASE_FOR_SECTION_SYNCHRONIZATION, TEXT("IRP_MJ_RELEASE_FOR_SECTION_SYNCHRONIZATION"), NULL),
	IRP_MAP_DEF(IRP_MJ_ACQUIRE_FOR_MOD_WRITE, TEXT("IRP_MJ_ACQUIRE_FOR_MOD_WRITE"), NULL),
	IRP_MAP_DEF(IRP_MJ_RELEASE_FOR_MOD_WRITE, TEXT("IRP_MJ_RELEASE_FOR_MOD_WRITE"), NULL),
	IRP_MAP_DEF(IRP_MJ_ACQUIRE_FOR_CC_FLUSH, TEXT("IRP_MJ_ACQUIRE_FOR_CC_FLUSH"), NULL),
	IRP_MAP_DEF(IRP_MJ_RELEASE_FOR_CC_FLUSH, TEXT("IRP_MJ_RELEASE_FOR_CC_FLUSH"), NULL),
	IRP_MAP_DEF(IRP_MJ_QUERY_OPEN, TEXT("IRP_MJ_QUERY_OPEN"), NULL),

	IRP_MAP_DEF(IRP_MJ_FAST_IO_CHECK_IF_POSSIBLE, TEXT("FASTIO_CHECK_IF_POSSIBLE"), NULL),
	IRP_MAP_DEF(IRP_MJ_NETWORK_QUERY_OPEN, TEXT("QueryOpen"), NULL),
	IRP_MAP_DEF(IRP_MJ_MDL_READ, TEXT("ReadFile"), NULL),
	IRP_MAP_DEF(IRP_MJ_MDL_READ_COMPLETE, TEXT("FASTIO_MDL_READ_COMPLETE"), NULL),

	IRP_MAP_DEF(IRP_MJ_PREPARE_MDL_WRITE, TEXT("WriteFile"), NULL),
	IRP_MAP_DEF(IRP_MJ_MDL_WRITE_COMPLETE, TEXT("FASTIO_MDL_WRITE_COMPLETE"), NULL),
	IRP_MAP_DEF(IRP_MJ_VOLUME_MOUNT, TEXT("VolumeMount"), NULL),
	IRP_MAP_DEF(IRP_MJ_VOLUME_DISMOUNT, TEXT("VolumeDismount"), NULL),
};


LPCTSTR
StrMapOperation(
	_In_ PLOG_ENTRY pEntry
)
{
	if (!pEntry){
		return TEXT("Invalid Entry");
	}

	USHORT Class = pEntry->MonitorType;
	USHORT Operator = pEntry->NotifyType;

	if (Class == MONITOR_TYPE_PROCESS){
		for (int i = 0; i < _countof(gProcOptMap); i++)
		{
			if (gProcOptMap[i].Operator == Operator) {
				return gProcOptMap[i].lpOptName;
			}
		}
		return NULL;
	}else if (Class == MONITOR_TYPE_FILE){
		
		PLOG_FILE_OPT pFileOPt = TO_EVENT_DATA(PLOG_FILE_OPT, pEntry);
		UCHAR Major = (UCHAR)Operator - 20;
		UCHAR Minjor = pFileOPt->MinorFunction;
		LPCTSTR lpszRet = NULL;

		for (int i = 0; i < _countof(gFileOptMap); i++)
		{
			if (gFileOptMap[i].Major == Major){
				if (gFileOptMap[i].pSubDesc) {

					PFILE_OPT_SUB_DESC pSubDesc = gFileOptMap[i].pSubDesc;
					for (int j = 0; ; j++)
					{
						if (!pSubDesc[j].lpszFastIoName) {
							break;
						}
						if (pSubDesc[j].Minjor == 0xff ||
							pSubDesc[j].Minjor == Minjor) {
							if (pSubDesc[j].lpszShowName) {
								lpszRet = pSubDesc[j].lpszShowName;
							}

							break;
						}
					}

				}else{
					lpszRet = gFileOptMap[i].lpszShowName;
				}

				break;
			}
		}

		if (!lpszRet){
			lpszRet = TEXT("Unknown");
		}

		return lpszRet;

	}else if (Class == MONITOR_TYPE_REG){
		for (int i = 0; i < _countof(gRegOptMap); i++)
		{
			if (gRegOptMap[i].Operator == Operator) {
				return gRegOptMap[i].lpOptName;
			}
		}
		return NULL;
	}

	return NULL;
}


LPCTSTR
StrMapIntegrityLevel(
	_In_ DWORD dwIntegrityLevel
)
{
	switch (dwIntegrityLevel)
	{
	case SECURITY_MANDATORY_LOW_RID:
		return TEXT("Low");
	case SECURITY_MANDATORY_MEDIUM_RID:
		return TEXT("Medium");
	case SECURITY_MANDATORY_MEDIUM_PLUS_RID:
		return TEXT("Medium+");
	case SECURITY_MANDATORY_UNTRUSTED_RID:
		return TEXT("Untrusted");
	case SECURITY_MANDATORY_HIGH_RID:
		return TEXT("High");
	case SECURITY_MANDATORY_SYSTEM_RID:
		return TEXT("System");
	case SECURITY_MANDATORY_PROTECTED_PROCESS_RID:
		return TEXT("Protected");
	default:
		return TEXT("Invalid");
	}
}

CString
StrMapUserNameFromSid(
	_In_ PSID pSid
)
{

	CString strUserName;
	DWORD dwNameLength = 0, dwDomainNameLength = 0;
	SID_NAME_USE Use;
	BOOL bRet = FALSE;
	LPTSTR pName = NULL, pDomainName = NULL;
	LPTSTR pStrSid = NULL;

	if (!ConvertSidToStringSid(pSid, &pStrSid)) {
		return strUserName;
	}

	//
	// Is local user SID?
	//

	bRet = LookupAccountSid(NULL, pSid, NULL, &dwNameLength, NULL, &dwDomainNameLength, &Use);
	if (!bRet && GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

		//
		// Allocate buffer for Names
		//

		if (dwNameLength) {
			pName = (LPTSTR)LocalAlloc(0, dwNameLength * sizeof(TCHAR));
		}

		if (dwDomainNameLength) {
			pDomainName = (LPTSTR)LocalAlloc(0, dwDomainNameLength * sizeof(TCHAR));
		}

		//
		// Call the function again
		//

		bRet = LookupAccountSid(NULL, pSid, pName, &dwNameLength, pDomainName, &dwDomainNameLength, &Use);
		if (bRet) {

			//
			// Show SID first
			//

			if (dwDomainNameLength) {
				strUserName.Format(TEXT("%s\\%s"), pDomainName, pName);
			}else{
				strUserName = pName;
			}
		}
	}else{

		//
		// Can not convert to local user name. just show SID string
		//

		strUserName = pStrSid;
	}

	if (pStrSid) {
		LocalFree(pStrSid);
	}

	if (pName) {
		LocalFree(pName);
	}

	if (pDomainName) {
		LocalFree(pDomainName);
	}

	return strUserName;
}
```

`sdk/procmonsdk/strmaps.hpp`:

```hpp
#pragma once

LPCTSTR
StrMapNtStatus(
	_In_ NTSTATUS Status
);

CString
StrMapSecurityInformation(
	_In_ DWORD dwSecurityInformation
);

CString
StrMapFileAccessMask(
	_In_ DWORD AccessMask
);

LPCTSTR 
StrMapFileCreateDisposition(
	_In_ DWORD CreateDisposition
);

LPCTSTR 
StrMapFileRetDisposition(
	_In_ DWORD CreateDisposition
);

CString
StrMapFileCreateOptions(
	_In_ DWORD CreateOptions
);

CString 
StrMapFileAttributes(
	_In_ DWORD FileAttributes
);

CString
StrMapFileShareAccess(
	_In_ DWORD ShareAccess
);

LPCTSTR
StrMapClassEvent(
	_In_ int Class
);

LPCTSTR 
StrMapOperation(
	_In_ PLOG_ENTRY pEntry
);

CString
StrMapUserNameFromSid(
	_In_ PSID pSid
);

LPCTSTR
StrMapIntegrityLevel(
	_In_ DWORD dwIntegrityLevel
);
```

`sdk/procmonsdk/thread.cxx`:

```cxx

#include "pch.hpp"

#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <time.h>
#include <windows.h>

#include "thread.hpp"
#include "logger.hpp"

CThread::CThread()
{
}

CThread::~CThread()
{
    //Kill();
	SetTimeout(5);
	Stop();
}

DWORD WINAPI CThread::ThreadProc(void* lpParam)
{
    CThread* pThread = (CThread*)lpParam;
    pThread->m_startTime = time(NULL);
    pThread->Run();
    pThread->m_bIsStart = false;
    pThread->m_startTime = 0;
    return NULL;
}

bool CThread::Start()
{
	if (IsAlive()){
		return true;
	}else {
		m_bIsStart = true;
		m_bIsStop = false;
		m_ThreadHandle = CreateThread(NULL, 0, CThread::ThreadProc, this, 0, &m_ThreadID);
		return true;
	}
}


void CThread::Stop()
{
	m_bIsStop = true;
	//m_bIsStart = false;
	TryJoin();
}

void CThread::Join()
{
	WaitForSingleObject(m_ThreadHandle, INFINITE);
}

DWORD CThread::GetThreadID()
{
    return m_ThreadID;
}

void CThread::TryJoin()
{
    if(!m_bIsStart)
        return;
    
    if(!m_TimeoutSeconds){
        return Join();
    }


    int err = WaitForSingleObject(m_ThreadHandle, m_TimeoutSeconds*1000);
    if(err == WAIT_TIMEOUT){
        
        //
        // wait timeout
        //
        
        LogMessage(L_INFO, TEXT("waitout kill it"));
        Kill();
	} else if (err == WAIT_OBJECT_0) {
		LogMessage(L_INFO, TEXT("wait success"));
    }else if(err == 0){
		LogMessage(L_INFO, TEXT("invalid wait"));
    }
}

void CThread::Kill()
{
    if(IsAlive()){
		TerminateThread(m_ThreadHandle, -1);
    } 
    m_bIsStart = false;
    m_startTime = 0;
}

bool CThread::IsAlive()
{
    return m_bIsStart;
}

void CThread::SetTimeout(uint32_t timeout)
{
    m_TimeoutSeconds = timeout;
}

bool CThread::IsTimeout()
{
    if(!m_startTime || !m_TimeoutSeconds || !IsAlive()){
        return false;
    }

    return (time(NULL) - m_startTime) > m_TimeoutSeconds;
}
```

`sdk/procmonsdk/thread.hpp`:

```hpp

#ifndef __THREAD_INCLUDE__H__
#define __THREAD_INCLUDE__H__

#include <stdint.h>
#include <windows.h>

class IRunObject
{
public:
    virtual void Run() = 0;
    virtual ~IRunObject(){}
    void* getParam()
    {
        return m_lpParam;
    }

    void setParam(void* lpParam)
    {
        m_lpParam = lpParam;
    }

	virtual bool IsStop()
	{
		return m_bIsStop;
	}
private:
    void* m_lpParam;

protected:
	bool m_bIsStop = false;
};


class CThread : public IRunObject
{
public:
    CThread();
    ~CThread();

    bool Start();
    void Stop();
    void TryJoin();
    void Join();
    void Kill();
	static DWORD WINAPI ThreadProc(void* lpParam);
    DWORD GetThreadID();
    bool IsAlive();
    bool IsTimeout();
	void SetTimeout(uint32_t timeout);

private:
    DWORD m_ThreadID = 0;
	HANDLE m_ThreadHandle = NULL;
    bool m_bIsStart = false;
    time_t m_startTime = 0;
    uint32_t m_TimeoutSeconds = 0;
};


#endif

```

`sdk/procmonsdk/utils.cxx`:

```cxx

#include "pch.hpp"
#include "utils.hpp"
#include "logger.hpp"
#include <strsafe.h>
#include <winternl.h>
#include <atlstr.h>
#include <atltime.h>
#include <Sddl.h>
#include <map>
#include <minwindef.h>

#pragma comment(lib, "Version.lib")

#define BUFSIZE 512

struct cmpStringNocase {
	bool operator()(const CString& a, const CString& b) const {
		return a.CompareNoCase(b) < 0;
	}
};

std::map<CString, CString> gVolumeCache;

BOOL
CacheVolumePath(
	VOID
)
{
	//
	// Big enough
	//

	TCHAR szTemp[BUFSIZE];
	szTemp[0] = TEXT('\0');

	//
	// Query all volume
	//

	if (GetLogicalDriveStrings(BUFSIZE - 1, szTemp)) {

		TCHAR szName[MAX_PATH];
		TCHAR szDrive[3] = TEXT(" :");
		TCHAR* p = szTemp;


		do
		{
			//
			// Copy the drive letter to the template string
			//

			*szDrive = *p;

			//
			// Look up each device name
			//

			if (QueryDosDevice(szDrive, szName, MAX_PATH)) {
				gVolumeCache.insert(std::make_pair(szName, szDrive));
			}

			//
			// Go to the next NULL character.
			//

			while (*p++);
		} while (*p); // end of string
	}

	return TRUE;
}

BOOL 
UtilConvertNtInternalPathToDosPath(
	IN const CString& strNtPath,
	OUT CString& strDosPath
)
/*++

Routine Description:

	.

Arguments:

	lpszDosPath - Out Dos path the max length is MAX_PATH

Return Value:

	Routine can return non success error codes.

--*/
{
	BOOL bRet = FALSE;
	static BOOL bVolumePathCached = FALSE;
	
	do 
	{
		if (strNtPath.Find(TEXT("\\Device\\LanmanRedirector\\")) == 0) {
			strDosPath += TEXT("\\\\");
			strDosPath += strNtPath.Mid(25);

			bRet = TRUE;
			break;
		}

		if (strNtPath.Find(TEXT("\\Device\\Mup\\")) == 0) {
			strDosPath += TEXT("\\\\");
			strDosPath += strNtPath.Mid(12);
			
			bRet = TRUE;
			break;
		}

		if (strNtPath.Left(12) == TEXT("\\SystemRoot\\")) {
			static TCHAR szSystemRoot[MAX_PATH] = { 0 };

			if (szSystemRoot[0] == 0) {
				GetWindowsDirectory(szSystemRoot, MAX_PATH);
			}

			strDosPath += szSystemRoot;
			if (strDosPath[strDosPath.GetLength() - 1] != TEXT('\\')) {
				strDosPath += TEXT('\\');
			}
			strDosPath += strNtPath.Mid(12);

			bRet = TRUE;
			break;
		}

		if (strNtPath.Left(4) == TEXT("\\??\\")) {
			strDosPath = strNtPath.Mid(4);
			
			bRet = TRUE;
			break;
		}

		if (strNtPath[0] != TEXT('\\')) {
			strDosPath = strNtPath;
			
			bRet = TRUE;
			break;
		}

		if (!bVolumePathCached) {
			CacheVolumePath();
			bVolumePathCached = TRUE;
		}

		for (int i = 0; i < 2; i++)
		{
			for (auto it = gVolumeCache.begin(); it != gVolumeCache.end(); it++)
			{
				CString strDrive = strNtPath.Left(it->first.GetLength());
				if (0 == strDrive.CompareNoCase(it->first)) {
					strDosPath += it->second;
					strDosPath += strNtPath.Mid(it->first.GetLength());
					bRet = TRUE;
					break;
				}
			}

			if (bRet) {
				break;
			}else{

				//
				// CacheVolume and try again
				//

				CacheVolumePath();
			}
		}
	} while (FALSE);
	
	if (!bRet){
		strDosPath.Empty();
	}

	return bRet;
}


BOOL
UtilRegIsLocalMachine(
	IN LPCTSTR lpszRegPath
)
{
	CString strInternal = lpszRegPath;
	CString strStart = TEXT("\\REGISTRY\\MACHINE");

	if (0 != strStart.CompareNoCase(strInternal.Left(strStart.GetLength()))) {
		return FALSE;
	}

	return TRUE;
}

BOOL GetUserSid(CString& strUser)
{
	HANDLE hToken = NULL;
	PTOKEN_USER pUser = NULL;
	LPTSTR lpUserName = NULL;
	BOOL bRet = FALSE;
	DWORD retLength = 0;

	do
	{
		if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
			return FALSE;
		}

		if (!GetTokenInformation(hToken, TokenUser, NULL, 0, &retLength)) {
			if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
				break;
			}
		}

		pUser = (PTOKEN_USER)LocalAlloc(0, retLength);
		if (pUser == NULL) {
			break;
		}

		if (!GetTokenInformation(hToken, TokenUser, pUser, retLength, &retLength)) {
			break;
		}

		if (!ConvertSidToStringSid(pUser->User.Sid, &lpUserName)) {
			break;
		}

		strUser = lpUserName;
		bRet = TRUE;

	} while (FALSE);


	if (hToken) {
		CloseHandle(hToken);
	}

	if (pUser) {
		LocalFree(pUser);
	}

	if (lpUserName) {
		LocalFree(lpUserName);
	}

	return bRet;
}


BOOL
UtilConvertRegInternalToNormal(
	IN const CString& strInternalPath,
	OUT CString& strNormalPath
)
{
	BOOL bRet = FALSE;
	CString strInternalPathTemp = strInternalPath;
	CString strStart = TEXT("\\REGISTRY\\");
	
	//
	// try to get user sid
	//
	
	static CString strUser;
	if (!strUser.GetLength()){
		GetUserSid(strUser);
	}

	if (0 != strStart.CompareNoCase(strInternalPathTemp.Left(strStart.GetLength()))){
		return FALSE;
	}
	
	//
	// Skip \\REGISTRY\\
	//
	
	strInternalPathTemp = strInternalPathTemp.Right(strInternalPathTemp.GetLength() - strStart.GetLength());
	
	//
	// TODO :
	// <INSUFFICIENT RESOURCES>
	// <INVALID NAME>
	//

	do 
	{
		
		//
		// Is start with machine ?
		//
		
		strStart = TEXT("MACHINE");
		if (0 == strStart.CompareNoCase(strInternalPathTemp.Left(strStart.GetLength()))) {

			//
			// Skip MACHINE
			//

			strInternalPathTemp = strInternalPathTemp.Right(strInternalPathTemp.GetLength() - strStart.GetLength());

			strNormalPath += TEXT("HKLM");
			strNormalPath += strInternalPathTemp;

			bRet = TRUE;
			break;
		}

		
		//
		// Is start with user sid?
		//
		
		strStart = TEXT("USER");
		if (0 == strStart.CompareNoCase(strInternalPathTemp.Left(strStart.GetLength()))) {
			
			//
			// Skip USER
			//
			
			strInternalPathTemp = strInternalPathTemp.Right(strInternalPathTemp.GetLength() - strStart.GetLength());
			
			//
			// Skip the '\\'
			//
			strInternalPathTemp.TrimLeft(TEXT('\\'));

			//
			// Start with SID ?
			//
			
			if (0 == strUser.CompareNoCase(strInternalPathTemp.Left(strUser.GetLength()))) {

				strInternalPathTemp = strInternalPathTemp.Right(strInternalPathTemp.GetLength() - strUser.GetLength());

				if (!strInternalPathTemp.IsEmpty() && strInternalPathTemp[0] != TEXT('\\')) {
					CString strClassRoot = TEXT("_Classes");
					if (0 == strClassRoot.CompareNoCase(strInternalPathTemp.Left(strClassRoot.GetLength()))) {
						strNormalPath += TEXT("HKCR");
						strInternalPathTemp = strInternalPathTemp.Right(strInternalPathTemp.GetLength() - strClassRoot.GetLength());
						strNormalPath += strInternalPathTemp;
					}else{
						bRet = TRUE;
						break;
					}
				}else{
					strNormalPath += TEXT("HKCU");
					if(!strInternalPathTemp.IsEmpty()){
						strNormalPath += strInternalPathTemp;
					}
				}

			}else{

				strNormalPath += TEXT("HKU");
				if (!strInternalPathTemp.IsEmpty()) {
					strNormalPath += "\\";
					strNormalPath += strInternalPathTemp;
				}
			}

			bRet = TRUE;
			break;
		}
	} while (FALSE);


	if (!bRet) {
		strNormalPath = strInternalPath;
	}

	return bRet;
}

CString UtilConvertTimeOfDay(LARGE_INTEGER Time)
{
	FILETIME SystemTime;

	SystemTime.dwLowDateTime = Time.LowPart;
	SystemTime.dwHighDateTime = Time.HighPart;
	
	CTime time(SystemTime);
	CString strTimeOfDay;

	strTimeOfDay.Format(TEXT("%02u:%02u:%02u.%07u"),
		time.GetHour(), time.GetMinute(), time.GetSecond(),
		(ULONG)(Time.QuadPart / 10000000));

	return strTimeOfDay;
	
}

CString UtilConvertDay(LARGE_INTEGER Time)
{
	FILETIME SystemTime;

	SystemTime.dwLowDateTime = Time.LowPart;
	SystemTime.dwHighDateTime = Time.HighPart;

	CTime time(SystemTime);

	return time.Format(TEXT("%Y/%m/%d %H:%M:%S"));

}

CString 
UtilConvertTimeSpan(
	LARGE_INTEGER StartTime,
	LARGE_INTEGER CompleteTime
)
{
	FILETIME fStartTime;
	FILETIME fCompleteTime;

	fStartTime.dwLowDateTime = StartTime.LowPart;
	fStartTime.dwHighDateTime = StartTime.HighPart;
	fCompleteTime.dwLowDateTime = CompleteTime.LowPart;
	fCompleteTime.dwHighDateTime = CompleteTime.HighPart;

	CTime timeStart(fStartTime);
	CTime timeFinish(fStartTime);

	CTimeSpan TimeSpan = timeFinish - timeStart;
	CString strTimeOfDay;
	strTimeOfDay.Format(TEXT("%02u:%02u:%02u.%07u"),
		TimeSpan.GetHours(), TimeSpan.GetMinutes(), TimeSpan.GetSeconds(),
		(ULONG)((CompleteTime.QuadPart - StartTime.QuadPart) / 10000000));
	return strTimeOfDay;
	
}

PVOID
VerQueryByCodePage(
	PVOID pVersionInfo,
	WORD wLanguage,
	WORD wCodePage,
	LPCTSTR lpszQuery
)
{
	CString strQueryPath;
	PVOID pQueryRet = NULL;
	UINT cbTranslate = 0;

	strQueryPath.Format(TEXT("\\StringFileInfo\\%04X%04X\\%s"), wLanguage, wCodePage, lpszQuery);

	if(VerQueryValue(pVersionInfo, strQueryPath, &pQueryRet, &cbTranslate)){
		return pQueryRet;
	}
	return NULL;

}

typedef struct _LANGANDCODEPAGE {
	WORD wLanguage;
	WORD wCodePage;
}LANGANDCODEPAGE, *PLANGANDCODEPAGE;

PVOID
VerQueryByTranslation(
	PVOID pVersionInfo,
	LPCTSTR lpszQuery
)
{
	PVOID pValue = NULL;
	UINT cbTranslate = 0;
	PLANGANDCODEPAGE lpTranslate = NULL;
	BOOL bRet;

	bRet = VerQueryValue(pVersionInfo, TEXT("\\VarFileInfo\\Translation"), 
		(LPVOID*)&lpTranslate, &cbTranslate);
	if (bRet && cbTranslate){

		pValue = VerQueryByCodePage(pVersionInfo, lpTranslate->wLanguage, 
			lpTranslate->wCodePage, lpszQuery);

		if (!pValue){
			pValue = VerQueryByCodePage(pVersionInfo,
				lpTranslate->wLanguage, 0x4E4, lpszQuery);
		}
	}

	return pValue;
}

BOOL
UtilGetFileVersionInfo(
	const CString& strFilePath,
	CString& strDescription,
	CString& strCompany,
	CString& strVersion
)
{
	//
	// Get Version 
	//

	BOOL bRet = FALSE;
	PVOID lpVersionInfo = NULL;
	DWORD dwInfoSize;
	DWORD dwHandle;

	dwInfoSize = GetFileVersionInfoSize(strFilePath, &dwHandle);
	if (!dwInfoSize) {
		return FALSE;
	}

	lpVersionInfo = HeapAlloc(GetProcessHeap(), 0, dwInfoSize);
	if (!lpVersionInfo) {
		return FALSE;
	}

	bRet = GetFileVersionInfo(strFilePath, 0, dwInfoSize, lpVersionInfo);
	if (bRet){
		strDescription = (LPCTSTR)VerQueryByTranslation(lpVersionInfo, TEXT("FileDescription"));
		strCompany = (LPCTSTR)VerQueryByTranslation(lpVersionInfo, TEXT("CompanyName"));
		strVersion = (LPCTSTR)VerQueryByTranslation(lpVersionInfo, TEXT("FileVersion"));
	}

	HeapFree(GetProcessHeap(), 0, lpVersionInfo);

	return bRet;
}

typedef struct _EXTRACTICON_PARAM
{
	CBuffer* pBufSmall;
	CBuffer* pBufLarge;
}EXTRACTICON_PARAM, *PEXTRACTICON_PARAM;

BOOL
GetMatchIconBuffer(
	_In_ HMODULE hModule,
	_In_ LPVOID lpIconDir,
	_In_ int cxDesired, 
	_In_ int cyDesired,
	_Out_ CBuffer& clsBuffer
)
{
	DWORD dwResSize;
	PVOID lpResource;
	HGLOBAL hMem;
	HRSRC hResource;

	int nID = LookupIconIdFromDirectoryEx((PBYTE)lpIconDir, TRUE,
		cxDesired, cyDesired, LR_DEFAULTCOLOR);
	if (!nID) {
		return FALSE;
	}

	hResource = FindResource(hModule,
		MAKEINTRESOURCE(nID),
		RT_ICON);

	hMem = LoadResource(hModule, hResource);
	lpResource = LockResource(hMem);
	dwResSize = SizeofResource(hModule, hResource);

	clsBuffer.Clear();
	clsBuffer.Insert((PBYTE)lpResource, dwResSize);

	return TRUE;

}

BOOL
WINAPI
EnumIconResNameProc(
	_In_opt_ HMODULE hModule,
	_In_ LPCWSTR lpType,
	_In_ LPWSTR lpName,
	_In_ LONG_PTR lParam)
{
	
	//
	// 
	//
	
	HGLOBAL hMem;
	LPVOID lpResource;
	PEXTRACTICON_PARAM pParam = (PEXTRACTICON_PARAM)lParam;

	HRSRC hResourceDir = FindResource(hModule, lpName, lpType);
	if (!hResourceDir){
		return TRUE;
	}

	hMem = LoadResource(hModule, hResourceDir);
	lpResource = LockResource(hMem);
	if (!lpResource){
		return TRUE;
	}

	int cxSmall = GetSystemMetrics(SM_CXSMICON);
	int cySmall = GetSystemMetrics(SM_CYSMICON);

	int cxLarge = GetSystemMetrics(SM_CXICON);
	int cyLarge = GetSystemMetrics(SM_CYICON);

	if (!GetMatchIconBuffer(hModule, lpResource, cxSmall, cySmall, *pParam->pBufSmall)){
		return TRUE;
	}

	if (!GetMatchIconBuffer(hModule, lpResource, cxLarge, cyLarge, *pParam->pBufLarge)) {
		return TRUE;
	}

	return FALSE;
}


BOOL 
UtilExtractIcon(
	const CString& strFilePath, 
	CBuffer& bufSmallIcon, 
	CBuffer& bufLargeIcon)
{
	//
	// Try to load the EXE file
	//
	
	HMODULE hExe = LoadLibraryEx(strFilePath, NULL, LOAD_LIBRARY_AS_DATAFILE);
	if (!hExe){
		return FALSE;
	}
	
	EXTRACTICON_PARAM Paramter;
	Paramter.pBufLarge = &bufLargeIcon;
	Paramter.pBufSmall = &bufSmallIcon;

	EnumResourceNames(hExe, RT_GROUP_ICON, EnumIconResNameProc, (LONG_PTR)&Paramter);
	
	if (hExe){
		FreeLibrary(hExe);
	}

	if (!bufSmallIcon.Empty() && !bufLargeIcon.Empty()){
		return TRUE;
	}

	bufSmallIcon.Clear();
	bufLargeIcon.Clear();

	return FALSE;
}

BOOL
UtilAdjustPrivilegesByName(
	IN HANDLE TokenHandle,
	IN LPCTSTR lpName,
	IN BOOL bEnable
)
{
	LUID Luid;
	TOKEN_PRIVILEGES NewState;

	if (LookupPrivilegeValue(NULL, lpName, &Luid)) {
		NewState.Privileges[0].Luid = Luid;
		NewState.PrivilegeCount = 1;
		NewState.Privileges[0].Attributes = bEnable != 0 ? 2 : 0;
		if (AdjustTokenPrivileges(TokenHandle, 0, &NewState, sizeof(TOKEN_PRIVILEGES), NULL, NULL)) {
			return TRUE;
		}
	}
	return FALSE;
}

BOOL UtilSetPriviledge(LPCTSTR lpszPriviledgeName, BOOL bEnable)
{
	HANDLE hToken;
	if (!OpenProcessToken(GetCurrentProcess(), 0xF01FFu, &hToken)) {
		return FALSE;
	}
	if (!UtilAdjustPrivilegesByName(hToken, lpszPriviledgeName, bEnable)) {
		CloseHandle(hToken);
		return FALSE;
	}

	return TRUE;

}
```

`sdk/procmonsdk/utils.hpp`:

```hpp
#pragma once

#include "buffer.hpp"

BOOL
UtilConvertRegInternalToNormal(
	IN const CString& strInternalPath,
	OUT CString& strNormalPath
);

BOOL
UtilConvertNtInternalPathToDosPath(
	IN const CString& strNtPath,
	OUT CString& strDosPath
);

CString UtilConvertTimeOfDay(LARGE_INTEGER Time);
CString UtilConvertDay(LARGE_INTEGER Time);
CString
UtilConvertTimeSpan(
	LARGE_INTEGER StartTime,
	LARGE_INTEGER CompleteTime
);

BOOL
UtilGetFileVersionInfo(
	const CString& strFilePath,
	CString& strDescription,
	CString& strCompany,
	CString& strVersion
);

BOOL
UtilExtractIcon(
	const CString& strFilePath,
	CBuffer& bufSmallIcon,
	CBuffer& bufLargeIcon
);

BOOL 
UtilSetPriviledge(
	IN LPCTSTR lpszPriviledgeName, 
	IN BOOL bEnable
);
```

`sdk/procmonsdk/viewer.cxx`:

```cxx

#include "pch.hpp"
#include "viewer.hpp"
#include "utils.hpp"

CProcInfoView::CProcInfoView(CRefPtr<CLogEvent> Opt) :
	CBaseView(Opt)
{

}

CProcInfoView::CProcInfoView()
{

}

CProcInfoView::~CProcInfoView()
{

}

BOOL CProcInfoView::IsValid()
{
	if (CBaseView::IsValid()){
		USHORT Type = m_Event->GetNotifyType();
		if (Type == NOTIFY_PROCESS_CREATE ||
			Type == NOTIFY_PROCESS_INIT) {
			return TRUE;
		}
	}
	return FALSE;
}

DWORD CProcInfoView::GetProcSeq()
{
	return GetProcCreateInfo()->Seq;
}

DWORD CProcInfoView::GetProcessId()
{
	return GetProcCreateInfo()->ProcessId;
}

DWORD CProcInfoView::GetSessionId()
{
	return GetProcCreateInfo()->SessionId;
}

DWORD CProcInfoView::GetParentProcessId()
{
	return GetProcCreateInfo()->ParentId;
}

LUID CProcInfoView::GetAuthId()
{
	return GetProcCreateInfo()->AuthenticationId;
}

CString CProcInfoView::GetUserName()
{
	return TEXT("");
}

DWORD CProcInfoView::GetIntegrity()
{
	
	//
	// Get the sid buffer
	//
	
	DWORD dwIntegrity = 0;

	PLOG_PROCESSCREATE_INFO pCreateInfo = GetProcCreateInfo();
	if (pCreateInfo){
		PUCHAR pBufferTemp = (PUCHAR)(pCreateInfo + 1);
		
		//
		// Skip user SID
		//

		pBufferTemp += pCreateInfo->SidLength;

		PSID pIntegritySid = (PSID)pBufferTemp;
		
		//
		// Is valid sid
		//
		
		if (IsValidSid(pIntegritySid)){
			
			//
			// Get integrity level
			//

			dwIntegrity = *GetSidSubAuthority(pIntegritySid, (DWORD)(*GetSidSubAuthorityCount(pIntegritySid) - 1));
		}
	}


	return dwIntegrity;
}

BOOL CProcInfoView::IsVirtualize()
{
	return GetProcCreateInfo()->TokenVirtualizationEnabled != 0;
}

BOOL CProcInfoView::IsWow64()
{
	return !GetProcCreateInfo()->IsWow64;
}

CString CProcInfoView::GetProcessName()
{
	return CString(PathFindFileName(GetImagePath()));
}

CString CProcInfoView::GetImagePath()
{
	CString strProcessName;
	PLOG_PROCESSCREATE_INFO pCreateInfo = GetProcCreateInfo();

	if (pCreateInfo && pCreateInfo->ProcNameLength) {
		PUCHAR pBufferEnd = (PUCHAR)(pCreateInfo + 1);
		CString strImagePath;

		pBufferEnd += pCreateInfo->SidLength;
		pBufferEnd += pCreateInfo->IntegrityLevelSidLength;

		strImagePath.Append((LPCWSTR)pBufferEnd, pCreateInfo->ProcNameLength);

		//
		// Convert to dos path
		//

		UtilConvertNtInternalPathToDosPath(strImagePath, strProcessName);


	}
	return strProcessName;
}

CString CProcInfoView::GetCommandLine()
{
	CString strCmdline;
	PLOG_PROCESSCREATE_INFO pCreateInfo = GetProcCreateInfo();

	if (pCreateInfo && pCreateInfo->CommandLineLength) {
		PUCHAR pBufferEnd = (PUCHAR)(pCreateInfo + 1);
		pBufferEnd += pCreateInfo->SidLength;
		pBufferEnd += pCreateInfo->IntegrityLevelSidLength;
		pBufferEnd += pCreateInfo->ProcNameLength * sizeof(WCHAR);
		strCmdline.Append((LPCWSTR)pBufferEnd, pCreateInfo->CommandLineLength);
	}
	return strCmdline;
}

PSID CProcInfoView::GetUserSid()
{
	PLOG_PROCESSCREATE_INFO pCreateInfo = GetProcCreateInfo();

	if (pCreateInfo) {
		return (PSID)(pCreateInfo + 1);
	}
	return NULL;
}

FORCEINLINE
PLOG_PROCESSCREATE_INFO 
CProcInfoView::GetProcCreateInfo()
{
	if (m_Event->getPreLog().GetBufferLen()){
		PLOG_ENTRY pEntry = reinterpret_cast<PLOG_ENTRY>(m_Event->getPreLog().GetBuffer());
		return TO_EVENT_DATA(PLOG_PROCESSCREATE_INFO, pEntry);
	}

	return NULL;
}

BOOL CBaseView::IsValid()
{
	if (!m_Event.IsNull()){
		if (m_Event->getPreLog().GetBufferLen()){
			return TRUE;
		}
	}
	return FALSE;
}

DWORD CBaseView::GetThreadId()
{
	return GetPreLogEntry()->ThreadId;
}

DWORD CBaseView::GetSeqNumber()
{
	return m_Event->GetSeq();
}

DWORD CBaseView::GetEventClass()
{
	return m_Event->GetMoniterType();
}

DWORD CBaseView::GetOperator()
{
	return m_Event->GetNotifyType();
}

LARGE_INTEGER CBaseView::GetStartTime()
{
	return GetPreLogEntry()->Time;
}

ULONG CBaseView::GetStackFrameCount()
{
	return GetPreLogEntry()->nFrameChainCounts;
}

LARGE_INTEGER CBaseView::GetCompleteTime()
{
	auto pEntry = GetPostLogEntry();
	return pEntry ? pEntry->Time : GetPreLogEntry()->Time;
}


CString CBaseView::GetPath()
{
	return m_Event->GetPath();
}

CString CBaseView::GetDetail()
{
	return m_Event->GetDetail();
}

NTSTATUS CBaseView::GetResult()
{
	auto pEntry = GetPostLogEntry();
	return pEntry ? pEntry->Status : GetPreLogEntry()->Status;
}

DWORD CBaseView::GetProcessSeq()
{
	return GetPreLogEntry()->ProcessSeq;
}

CRefPtr<CLogEvent> CBaseView::GetEvent()
{
	return m_Event;
}

DWORD CBaseView::GetCallStack(std::vector<PVOID>& callStacks)
{
	PLOG_ENTRY pEntry = GetPreLogEntry();
	
	if (pEntry && pEntry->nFrameChainCounts){

		PVOID* pCallback = (PVOID*)(pEntry + 1);
		for (int i = 0; i < pEntry->nFrameChainCounts; i++)
		{
			callStacks.push_back(pCallback[i]);
		}
	}

	return (DWORD)callStacks.size();
}

void CBaseView::SetEvent(CRefPtr<CLogEvent> pEvent)
{
	m_Event = pEvent;
}

FORCEINLINE
PLOG_ENTRY 
CBaseView::GetPreLogEntry()
{
	return reinterpret_cast<PLOG_ENTRY>
		(m_Event->getPreLog().GetBuffer());
}

FORCEINLINE
PLOG_ENTRY 
CBaseView::GetPostLogEntry()
{
	return reinterpret_cast<PLOG_ENTRY>
		(m_Event->getPostLog().GetBuffer());
}

```

`sdk/procmonsdk/viewer.hpp`:

```hpp
#pragma once

#include "refobject.hpp"
#include "event.hpp"
#include <vector>

class CBaseView
{
public:
	CBaseView(CRefPtr<CLogEvent> pEvent)
	{
		m_Event = pEvent;
	}

	CBaseView()
	{

	}

	~CBaseView()
	{

	}

	virtual BOOL IsValid();


	DWORD GetThreadId();
	DWORD GetSeqNumber();
	DWORD GetEventClass();
	DWORD GetOperator();
	LARGE_INTEGER GetStartTime();
	ULONG GetStackFrameCount();
	LARGE_INTEGER GetCompleteTime();
	CString GetPath();
	CString GetDetail();
	NTSTATUS GetResult();
	DWORD GetProcessSeq();
	CRefPtr<CLogEvent> GetEvent();
	DWORD GetCallStack(std::vector<PVOID>& callStacks);

	void SetEvent(CRefPtr<CLogEvent> pEvent);

protected:

	PLOG_ENTRY GetPreLogEntry();
	PLOG_ENTRY GetPostLogEntry();

protected:
	CRefPtr<CLogEvent> m_Event;
};

class CProcInfoView : public CBaseView
{
public:
	CProcInfoView();
	CProcInfoView(CRefPtr<CLogEvent> Opt);
	~CProcInfoView();

public:
	virtual BOOL IsValid();

	DWORD GetProcSeq();
	DWORD GetProcessId();
	DWORD GetSessionId();
	DWORD GetParentProcessId();
	LUID GetAuthId();
	CString GetUserName();
	DWORD GetIntegrity();
	BOOL IsVirtualize();
	BOOL IsWow64();

	CString GetProcessName();
	CString GetImagePath();
	CString GetCommandLine();

	PSID GetUserSid();

private:
	PLOG_PROCESSCREATE_INFO GetProcCreateInfo();
};
```