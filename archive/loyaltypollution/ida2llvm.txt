Project Path: arc_loyaltypollution_ida2llvm_3kyu6vgv

Source Tree:

```txt
arc_loyaltypollution_ida2llvm_3kyu6vgv
├── Dockerfile
├── README.md
├── docker_entrypoint.py
├── ida2llvm
│   ├── __init__.py
│   ├── _utils.py
│   ├── address.py
│   ├── function.py
│   ├── insn.py
│   ├── syscall.py
│   └── type.py
├── ida2llvm_plugin.py
├── itadium_to_msvc.py
├── run.sh
├── screenshots
│   ├── default-roman.png
│   ├── fully-defined-main.png
│   ├── interactive.gif
│   ├── selected-function.png
│   └── viewer-UI.png
└── tests
    ├── bin
    │   └── romannumeral.out
    ├── idb
    │   ├── demo-control-flow-flatten.elf64.i64
    │   └── romannumeral.i64
    └── src
        └── romannumeral.cpp

```

`Dockerfile`:

```
FROM debian:stable-20230320-slim

# Global: ignore TLS errors
ENV CURL_CA_BUNDLE=""
ENV PYTHONWARNINGS="ignore:Unverified HTTPS request"
RUN echo 'Acquire::https::Verify-Peer "false";' > /etc/apt/apt.conf.d/99-cert

# Install prerequisites
RUN apt-get update --fix-missing && \
    DEBIAN_FRONTEND="noninteractive" apt-get install -y --no-install-recommends \
        ca-certificates \
        git \
        inotify-tools \
        sudo \
        wget && \
    rm -rf /var/lib/apt/lists/*

COPY .devcontainer/certs/ /usr/local/share/ca-certificates/
RUN update-ca-certificates

# Install wine
ARG DEBIAN_FRONTEND=noninteractive
RUN dpkg --add-architecture i386 && \
    mkdir -pm755 /etc/apt/keyrings && \
    wget --no-check-certificate --output-document /etc/apt/keyrings/winehq-archive.key https://dl.winehq.org/wine-builds/winehq.key && \
    wget --no-check-certificate -NP /etc/apt/sources.list.d/ https://dl.winehq.org/wine-builds/debian/dists/bullseye/winehq-bullseye.sources

RUN apt-get update --fix-missing && \
    DEBIAN_FRONTEND="noninteractive" apt-get install -y --no-install-recommends \
        winehq-stable \
        xvfb && \
    rm -rf /var/lib/apt/lists/*

# Prevents the popup to install mono
# https://superuser.com/questions/948508/how-to-disable-gecko-package-popup-for-wine
ENV WINEDLLOVERRIDES="mscoree,mshtml="

# Ensure that registry change is flushed from registry onto disk
# https://serverfault.com/questions/1082578/wine-in-docker-reg-add-only-keeps-effects-temporarily
RUN wine reg add "HKEY_CURRENT_USER\Software\Wine" /v Version /t REG_SZ /d win10 /f && \
    while [ ! -f ~/.wine/user.reg ]; do sleep 1; done

# Install python
# Note that Python 3.10 requires wine to emulate Windows 10
ARG PYTHON_URL=https://www.python.org/ftp/python/3.10.0/python-3.10.0-amd64.exe
ARG PYTHON_DIR="C:\\Program Files\\Python310"
RUN Xvfb :0 -screen 0 1024x768x16 & \
    wget --quiet --no-check-certificate "${PYTHON_URL}" --output-document \
        python_installer.exe && \
    DISPLAY=:0 wine python_installer.exe \
        /quiet \
        InstallAllUsers=1 \
        PrependPath=1 && \
    rm python_installer.exe

# Download python dependencies on Wine-Python
COPY .devcontainer/dep/requirements.txt ./requirements.txt
RUN WINEPATH="${PYTHON_DIR}" wine python -m pip install -r requirements.txt && \
    rm -rf requirements.txt

# Copy IDA over
ADD .devcontainer/dep/ida.tar ~/.wine/ida

# Accept IDA EUA and set Python's version via registry
RUN wine reg add "HKEY_CURRENT_USER\Software\Hex-Rays\IDA" /v Python3TargetDLL /t REG_SZ /d "${PYTHON_DIR}/python3.dll" /f && \
    wine reg add "HKEY_CURRENT_USER\Software\Hex-Rays\IDA" /v "License Think-Cell Operations GmbH" /t REG_DWORD /d 1 /f && \
    while inotifywait -e modify ~/.wine/user.reg; do sleep 1; done

# Install LLVM using pre-built apt.llvm.org packages
RUN wget -O- https://apt.llvm.org/llvm-snapshot.gpg.key | gpg --dearmor | sudo tee /usr/share/keyrings/llvm.gpg \
    && echo """deb [signed-by=/usr/share/keyrings/llvm.gpg] http://apt.llvm.org/bullseye/ llvm-toolchain-bullseye-16 main \
    deb-src http://apt.llvm.org/bullseye/ llvm-toolchain-bullseye-16 main""" >> /etc/apt/sources.list
 
RUN apt-get update && export DEBIAN_FRONTEND=noninteractive \
    && apt-get -y install --no-install-recommends clang-16 libclang-16-dev llvm-16-dev graphviz \
    && apt-get -y autoremove \
    && rm -rf /var/lib/apt/lists/*

RUN mkdir /home/bin2llvm
WORKDIR /home/bin2llvm

COPY ida2llvm /home/bin2llvm/ida2llvm/
COPY run.sh /home/bin2llvm/run.sh
COPY docker_entrypoint.py /home/bin2llvm/docker_entrypoint.py
ENTRYPOINT ["/home/bin2llvm/run.sh"]
```

`README.md`:

```md
# IDA2LLVM - Dynamic Binary Lifting IDA code to LLVM IR

Because I was curious, "can Hexrays decompilation be hijacked for LLVM lifting"?


## Features

1. Lifts all IDA-decompilable binaries to LLVM bitcode, including executables and shared libraries for each platform.
2. **guarantees CFG preservation** during lifting
3. enable **interactive lifting**, for reverse-engineers most familiar with state-of-the-art IDA

## Dependencies
| Name | Version | 
| ---- | ------- |
| [Python](https://www.python.org/) | 3.10* |
| [llvmlite](https://pypi.org/project/llvmlite/) | 0.39.1* |
| [headless-ida](https://pypi.org/project/headless-ida/)** | 0.5.2 |
| [pytest](https://pypi.org/project/pytest/)** | 7.4.3 |
| [IDA Pro](https://www.hex-rays.com/products/ida) | 7.7+ |

*llvmlite 0.39.1 did not have wheels for Python 3.11+  
**only needed for unittests

## Using the lifter

### Run as IDA Plugin

IDA2LLVM will load for any architecture with a Hex-Rays decompiler present. Use the hot-key (Ctrl+Alt+L) or <ins>Edit/IDA2LLVM/Lifting Viewer</ins> to open the Lifting Viewer.

![Lifting Viewer UI](screenshots/viewer-UI.png)

Lifting is performed at IDA's **function** level (assuming Microcode can be emitted). The viewer will always synchronize against the user's cursor in the disassembly window, indicating whether it can be lifted.

Functions are **recursively added** to children. If `main` calls the function `f` and main is defined, both `main` and `f` will be defined.

![Function selection](screenshots/selected-function.png)

Having added a function, we can select it in the panel. Here we can: 
1. mark function as declare-only
2. redefine the function
   - lifting is performed on a per-demand basis.
   - if there are changes to decompiler, we should redefine the function.
3. delete function, with `Del` key

An example of a fully defined main function is as such:

![Fully defined main](screenshots/fully-defined-main.png)

### Interactive lifting

> More often than not, lifting will not work out of the box. A key feature of IDA2LLVM is interactive lifting. 

Let's look `tests/bin/romannumeral.out`. Variable names have been renamed appropriately:

![Incorrect stack variables](screenshots/default-roman.png)

Pay attention to `arr_eleX` variables. 
- Hexray's decompiler has displayed these as individual stack variables,
- however, the line `*(&arr_ele0 + i)` betrays the fact that it is an array of integers `{1, 4, 123, 5123...}` of size 11.

Our lifted output will be faithful to Hexray's decompiler. Each integer variable will be an indepedent stack variable, and the line `*(&arr_ele0 + i)` will result in an memory access error.

![Interactive change](screenshots/interactive.gif)

We can fix this issue by appropriately defining the types in the decompiler, and redefining the function. All work has been done and saved in `tests/idb/romannumeral.i64`.

### Run in Docker

> This works mostly as a convenience tool. We sacrifice **the entire capability for a reverse engineer to interactively lift**, hence accuracy is severely diminished.

This requires an IDA Pro Windows installation.

Our Dockerfile runs Windows IDA Pro in a Linux container, emulating it in Wine. 

#### Step 1: Clone the repository

```pwsh
git clone https://github.com/loyaltypollution/ida2llvm
```

#### Step 2: Add `ida.tar` to `.devcontainer/dep`

Insert a tar zip of the entire IDA Pro folder 
```pwsh
tar cvf ida.tar "$(dirname "$(which ida64)")"
```

#### Step 3: Build & Run Dockerfile

Insert the idb in the directory 

```pwsh
docker build . -t bin2llvm
docker run --rm -it -v .\tests:/home/bin2llvm/tests bin2llvm
```

## Linking Notes

Suppose the user lifted all functions in the idb. This potentially includes symbols from the C standard library, such as `_start`.

Naievely compiling from `clang` will likely result in link issues. Common issues include:
- duplicate symbols
- undefined symbols

In general, link issues are not our concern. Our lifter has already done its work and it's up to the user to fix linking issues *(good luck)*. 

Here are some tips to fix linking issues:
- instruct the linker to use the first symbol seen (`allow-multiple-definition`)
    ```bash
        clang lifted.ll -c
        clang lifted.o -v -Wl,--allow-multiple-definition -o lifted.out
    ```

*please raise an issue and let the author learn more about cpp linking*
```

`docker_entrypoint.py`:

```py
import ida_pro
import ida_ida
import ida_nalt
import logging

from llvmlite import ir
from os.path import basename

import ida2llvm

logger = logging.getLogger(__name__)
filename = basename(ida_nalt.get_input_file_path())
logging.basicConfig(filename=f".\\tests\\log\\{filename}.log",
                    format='%(levelname)s (%(name)s.py) %(message)s',
                    filemode='a',
                    level=logging.DEBUG)

module = ir.Module(filename)
logger.info(f"declared ir module of name {filename}")

try:
    func_name = 'main'
    ida2llvm.function.lift_function(module, func_name, False)
except Exception as e:
    logger.exception(e)

with open(f'.\\tests\\ll\\{filename}.ll', 'w') as f:
    f.write(str(module))

ida_pro.qexit(ida_ida.IDB_PACKED)
```

`ida2llvm/__init__.py`:

```py
from . import _utils
from . import address
from . import function
from . import insn
from . import type
from . import syscall



```

`ida2llvm/_utils.py`:

```py
import logging
import llvmlite.binding as llvm
import ida_name

from llvmlite import ir

logger = logging.getLogger(__name__)

def get_offset_to(builder: ir.IRBuilder, arg: ir.Value, off: int = 0) -> ir.Value:
    """
    A Value can be indexed relative to some offset.

    :param arg: value to index from
    :type arg: ir.Value
    :param off: offset to index, defaults to 0
    :type off: int, optional
    :return: value after indexing by off
    :rtype: ir.Value
    """
    match arg:
        case ptr if isinstance(arg.type, ir.PointerType) and isinstance(ptr.type.pointee, ir.ArrayType):
            arr = ptr.type.pointee
            td = llvm.create_target_data("e")
            size = arr.element.get_abi_size(td)
            return builder.gep(ptr, (ir.Constant(ir.IntType(8), 0), ir.Constant(ir.IntType(8), off // size),))
        case ptr if isinstance(arg.type, ir.PointerType) and isinstance(ptr.type.pointee, ir.LiteralStructType):
            return builder.bitcast(ptr, ir.IntType(8).as_pointer())
        case ptr if isinstance(arg.type, ir.PointerType) and off > 0:
            td = llvm.create_target_data("e")
            size = ptr.type.pointee.get_abi_size(td)
            return builder.gep(ptr, (ir.Constant(ir.IntType(8), off // size),))
        case _:
            return arg

def dedereference(arg: ir.Value) -> ir.Value:
    """
    A memory address is deferenced if the memory at the address is loaded.
    In LLVM, a LoadInstruction instructs the CPU to perform the dereferencing.

    In cases where we wish to retrieve the memory address, we "de-dereference".
    - this is needed as IDA microcode treats all LVARS as registers
    - whereas during lifting we treat all LVARS as stack variables (in accordance to LLVM SSA)

    :param arg: value to de-dereference
    :type arg: ir.Value
    :raises NotImplementedError: arg is not of type LoadInstr
    :return: original memory address
    :rtype: ir.Value
    """
    match arg:
        case arg if isinstance(arg, ir.LoadInstr):
            return arg.operands[0]
        case arg if isinstance(arg.type, ir.PointerType):
            return arg
        case arg if isinstance(arg, ir.Constant) and isinstance(arg.type, ir.IntType):
            # An integer constant already represents a raw value, not a loaded pointer.
            # For address-like immediates (e.g., EA 0x1 lifted as i64 1) we simply
            # return the constant; caller may inttoptr later if pointer semantics needed.
            return arg
        case _:
            raise NotImplementedError(f"not implemented: get reference for object {arg} of type {arg.type}")

def demangle_name(mangled_name: str) -> tuple[str, str]:
    """
    Demangle a function name for display purposes.
    Returns both the demangled and original mangled names.
    
    :param mangled_name: The mangled function name from IDA
    :type mangled_name: str
    :return: Tuple of (demangled_name, original_mangled_name)
    :rtype: tuple[str, str]
    """
    # Try to demangle the name
    demangled = ida_name.demangle_name(mangled_name, 0)
    
    # If demangling fails or returns empty, use the original name
    if not demangled or demangled == "":
        demangled = mangled_name
    
    return demangled, mangled_name

def create_name_comment(demangled_name: str, mangled_name: str) -> str:
    """
    Create a comment showing the original mangled name.
    
    :param demangled_name: The demangled/display name
    :type demangled_name: str
    :param mangled_name: The original mangled name
    :type mangled_name: str
    :return: Comment string to add to LLVM IR
    :rtype: str
    """
    # Only add comment if the names differ
    if demangled_name.strip('"') != mangled_name:
        return f"; Mangled: {mangled_name}"
    return ""


```

`ida2llvm/address.py`:

```py
import ida_bytes
import ida_hexrays
import ida_segment
import ida_typeinf
import ida_nalt
import ida_name
import ida_funcs
import ida_idaapi
import logging
import struct
import llvmlite.binding as llvm

from llvmlite import ir
import ida2llvm

logger = logging.getLogger(__name__)

def lift_type_from_address(ea: int):
    if ida_segment.segtype(ea) & ida_segment.SEG_XTRN:
        # let's assume its a function that returns ONE register and takes in variadic arguments
        ida_func_details = ida_typeinf.func_type_data_t()
        void = ida_typeinf.tinfo_t()
        void.create_simple_type(ida_typeinf.BTF_VOID)
        ida_func_details.rettype = void
        ida_func_details.cc = ida_typeinf.CM_CC_ELLIPSIS | ida_typeinf.CC_CDECL_OK

        function_tinfo = ida_typeinf.tinfo_t()
        function_tinfo.create_func(ida_func_details)
        return function_tinfo

    if (func := ida_funcs.get_func(ea)) is not None:
        ida_hf = ida_hexrays.hexrays_failure_t()
        tif = ida_hexrays.decompile(func, ida_hf).type
        ida_nalt.set_tinfo(ea, tif)

    tif = ida_typeinf.tinfo_t()
    ida_nalt.get_tinfo(tif, ea)
    if tif.empty():
        raise NotImplementedError(f"not implemented: type inference for object at {hex(ea)}")
    return tif

def lift_from_address(module: ir.Module, ea: int, typ: ir.Type = None):
    if typ is None:
        tif = lift_type_from_address(ea)
        typ = ida2llvm.type.lift_tif(tif)
    return _lift_from_address(module, ea, typ)

def _lift_from_address(module: ir.Module, ea: int, typ: ir.Type):
    match typ:
        case typ if isinstance(typ, ir.FunctionType):
            ida_funcs.add_func(ea, ida_idaapi.BADADDR)
            func = ida_funcs.get_func(ea)
            func_name = ida_name.get_name(ea)
            res = module.get_global(func_name)
            res.lvars = dict()
            # Ensure Hex-Rays caches are invalidated so recent IDB type edits
            # are reflected in decompilation and microcode.
            try:
                ida_hexrays.mark_cfunc_dirty(func.start_ea)
            except Exception:
                pass
            # Clear global cached cfuncs (broader invalidation when multiple functions edited)
            try:
                ida_hexrays.clear_cached_cfuncs()
            except Exception:
                pass

            ida_hf = ida_hexrays.hexrays_failure_t()
            ida_mbr = ida_hexrays.mba_ranges_t()
            ida_mbr.ranges.push_back(func)

            cfunc = ida_hexrays.decompile(func, ida_hf)
            lvars = cfunc.lvars if cfunc else []
            mba = ida_hexrays.gen_microcode(
                ida_mbr,
                ida_hf,
                None,
                ida_hexrays.DECOMP_ALL_BLKS,
                ida_hexrays.MMAT_LVARS
            )

            # Debug: optional dump of microcode instruction at a watched EA.
            WATCH_EA = getattr(logger, "WATCH_EA", 0x400800)

            for index in range(mba.qty):
                res.append_basic_block(name = f"@{index}") 

            ida_func_details = ida_typeinf.func_type_data_t()
            tif = lift_type_from_address(ea)
            tif.get_func_details(ida_func_details)
            names = [ida_func_details.at(i).name for i in range(ida_func_details.size())]
            
            builder = ir.IRBuilder(res.entry_basic_block)

            with builder.goto_entry_block():
                # declare function arguments as stack variables
                for arg, arg_t, arg_n in zip(res.args, typ.args, names):
                    res.lvars[arg_n] = builder.alloca(arg_t, name = arg_n)
                
                # declare function results as stack variable
                if not isinstance(typ.return_type, ir.VoidType):
                    res.lvars["result"] = builder.alloca(typ.return_type, name = "result")

                # if function is variadic, declare va_start intrinsic
                if tif.is_vararg_cc() and typ.var_arg:
                    ptr = builder.alloca(ir.IntType(8).as_pointer(), name = "ArgList")
                    res.lvars["ArgList"] = ptr
                    va_start = module.declare_intrinsic('llvm.va_start', fnty=ir.FunctionType(ir.VoidType(), [ir.IntType(8).as_pointer()]))
                    ptr = builder.load(ptr)
                    builder.call(va_start, (ptr, ))

                # store stack variables
                for arg, arg_n in zip(res.args, names):
                    arg = ida2llvm.type.typecast(arg, res.lvars[arg_n].type.pointee, builder)
                    builder.store(arg, res.lvars[arg_n])

            with builder.goto_block(res.blocks[-1]):
                if isinstance(typ.return_type, ir.VoidType):
                    builder.ret_void()
                else:
                    builder.ret(builder.load(res.lvars["result"]))

            # lift each bblk in cfg
            for index, blk in enumerate(res.blocks):
                ida_blk = mba.get_mblock(index)
                ida_insn = ida_blk.head
                while ida_insn is not None:
                    lifted_insn = ida2llvm.insn.lift_insn(ida_insn, blk, builder)
                    logger.debug(f"=> {lifted_insn}")
                    ida_insn = ida_insn.next

                if not blk.is_terminated and index + 1 < len(res.blocks):
                    with builder.goto_block(blk):
                        builder.branch(res.blocks[index + 1])

            # if function is variadic, declare va_end intrinsic
            if tif.is_vararg_cc() and typ.var_arg:
                ptr = res.lvars["ArgList"]
                va_end = module.declare_intrinsic('llvm.va_end', fnty=ir.FunctionType(ir.VoidType(), [ir.IntType(8).as_pointer()]))
                with builder.goto_block(res.blocks[-1]):
                    ptr = builder.load(ptr)
                    builder.call(va_end, (ptr, ))

            return res

            # # define function return type
            # define_rettype()
        case typ if isinstance(typ, ir.IntType):
            # should probably check endianness
            r = ida_bytes.get_bytes(ea, typ.width // 8)
            return typ(int.from_bytes(r, "little"))
        case typ if isinstance(typ, ir.FloatType):
            # should probably check endianness
            # floats are not guaranteed to be 8 bytes long
            return typ(struct.unpack('f', ida_bytes.get_bytes(ea, 8)))
        case typ if isinstance(typ, ir.DoubleType):
            # should probably check endianness
            # doubles are not guaranteed to be 8 bytes long
            return typ(struct.unpack('d', ida_bytes.get_bytes(ea, 8)))
        case typ if isinstance(typ, ir.PointerType):
            # check if ea is valid
            if (ida_segment.segtype(ea) & ida_segment.SEG_BSS == ida_segment.SEG_BSS
                or isinstance(typ.pointee, ir.FunctionType)):
                val = ir.Constant(typ, None)
            else:
                assumedType = ir.ArrayType(typ.pointee, 1000) # we assume the pointer points to maximally 1000 elements
                val = lift_from_address(module, ea, assumedType)
            return val
        case typ if isinstance(typ, ir.ArrayType):
            td = llvm.create_target_data("e")
            subSize = typ.element.get_abi_size(td)

            return ir.Constant.literal_array([ lift_from_address(module, sub_ea, typ.element)
                for sub_ea in range(ea, ea + subSize * typ.count, subSize)
            ])
        case typ if isinstance(typ, ir.LiteralStructType) or isinstance(typ, ir.IdentifiedStructType):
            td = llvm.create_target_data("e")
            sub_ea = ea
            structEles = []
            for el in typ.elements:
                if isinstance(el, ir.PointerType):
                    address_ea = ida_bytes.get_dword(sub_ea)
                    if ida_idaapi.inf_is_64bit():
                        address_ea = ida_bytes.get_qword(sub_ea)
                    g_cmt = lift_from_address(module, address_ea, el)

                    val = ir.GlobalVariable(module, g_cmt.type, f"{typ}_{hex(ea)}")
                    val.initializer = g_cmt
                    structEle = val.gep((ir.IntType(64)(0),))
                else:
                    structEle = lift_from_address(module, sub_ea, el)
                structEles.append(structEle)
                subSize = el.get_abi_size(td)
                sub_ea += subSize

            return ir.Constant.literal_struct(structEles)
    raise NotImplementedError(f"object at {hex(ea)} is of unsupported type {typ}")
```

`ida2llvm/function.py`:

```py
import ida_typeinf
import ida_name
import ida_idaapi
import ida_segment
import logging

from llvmlite import ir
from contextlib import suppress

import ida2llvm

logger = logging.getLogger(__name__)
i8ptr = ir.IntType(8).as_pointer()

def str2size(str_size: str):
    """
    Converts a string representing memory size into its size in bits. 

    :param str_size: string describing size
    :type str_size: str
    :return: size of string, in bits
    :rtype: int
    """
    match str_size:
        case "byte":
            return 8
        case "word":
            return 16
        case "dword":
            return 32
        case "qword":
            return 64
    raise AssertionError("string size must be one of byte/word/dword/qword")

def lift_intrinsic_function(module: ir.Module, func_name: str):
    """
    Lifts IDA macros to corresponding LLVM intrinsics.

    Hexray's decompiler recognises higher-level functions at the Microcode level.
        Such ida_hexrays:mop_t objects are typed as ida_hexrays.mop_h (auxillary function member)
        
        This improves decompiler output, representing operations that cannot be mapped to nice C code
        (https://hex-rays.com/blog/igors-tip-of-the-week-67-decompiler-helpers/).

        For relevant #define macros, refer to IDA SDK: `defs.h` and `pro.h`.

    LLVM intrinsics have well known names and semantics and are required to follow certain restrictions.

    :param module: _description_
    :type module: ir.Module
    :param func_name: _description_
    :type func_name: str
    :raises NotImplementedError: _description_
    :return: _description_
    :rtype: _type_
    """
    # retrieve intrinsic function if it already exists
    with suppress(KeyError):
        return module.get_global(func_name)

    match func_name:
        case "strcpy":
            # strcpy cannot be safely implemented without runtime strlen
            # Mark as external declaration with variadic args to be safe
            typ = ir.FunctionType(i8ptr, (i8ptr, i8ptr))
            f = ir.Function(module, typ, "strcpy")
            return f
    
        case "__halt":
            fty = ir.FunctionType(ir.VoidType(), [])
            f = ir.Function(module, fty, "__halt")
            f.append_basic_block()
            builder = ir.IRBuilder(f.entry_basic_block)
            builder.asm(fty, "hlt", "", (), True)
            builder.ret_void()
            return f

        case func_name if func_name.startswith("__readfs"):
            _, size = func_name.split("__readfs")
            size = str2size(size)

            try:
                fs_reg = module.get_global("virtual_fs")
            except KeyError:
                fs_reg_typ = ir.ArrayType(ir.IntType(8), 65536)
                fs_reg = ir.GlobalVariable(module, fs_reg_typ, "virtual_fs")
                fs_reg.storage_class = "thread_local"
                fs_reg.initializer = fs_reg_typ(None)
            try:
                threadlocal_f = module.get_global('llvm.threadlocal.address')
            except KeyError:
                f_argty = (i8ptr, )
                fnty = ir.FunctionType(i8ptr, f_argty)
                threadlocal_f = module.declare_intrinsic('llvm.threadlocal.address', f_argty, fnty)

            fty = ir.FunctionType(ir.IntType(size), [ir.IntType(32),])

            f = ir.Function(module, fty, func_name)
            offset, = f.args
            f.append_basic_block()
            builder = ir.IRBuilder(f.entry_basic_block)
            fs_reg = ida2llvm.type.typecast(fs_reg, ir.IntType(8).as_pointer(), builder)
            threadlocal_address = builder.call(threadlocal_f, (fs_reg, ))
            pointer = builder.gep(threadlocal_address, (offset,))
            pointer = ida2llvm.type.typecast(pointer, ir.IntType(size).as_pointer(), builder)
            res = builder.load(pointer)
            builder.ret(res)

            return f

        case func_name if func_name.startswith("__writefs"):
            _, size = func_name.split("__writefs")
            size = str2size(size)

            try:
                fs_reg = module.get_global("virtual_fs")
            except KeyError:
                fs_reg_typ = ir.ArrayType(ir.IntType(8), 65536)
                fs_reg = ir.GlobalVariable(module, fs_reg_typ, "virtual_fs")
                fs_reg.storage_class = "thread_local"
                fs_reg.initializer = fs_reg_typ(None)            
            try:
                threadlocal_f = module.get_global('llvm.threadlocal.address')
            except KeyError:
                f_argty = (i8ptr, )
                fnty = ir.FunctionType(i8ptr, f_argty)
                threadlocal_f = module.declare_intrinsic('llvm.threadlocal.address', f_argty, fnty)

            fty = ir.FunctionType(ir.VoidType(), [ir.IntType(32), ir.IntType(size)])

            f = ir.Function(module, fty, func_name)
            offset, value  = f.args
            f.append_basic_block()
            builder = ir.IRBuilder(f.entry_basic_block)
            fs_reg = ida2llvm.type.typecast(fs_reg, ir.IntType(8).as_pointer(), builder)
            threadlocal_address = builder.call(threadlocal_f, (fs_reg, ))
            pointer = builder.gep(threadlocal_address, (offset,))
            pointer = ida2llvm.type.typecast(pointer, ir.IntType(size).as_pointer(), builder)
            builder.store(value, pointer)
            builder.ret_void()

            return f

        case func_name if func_name.startswith("sys_"):
            fty = ir.FunctionType(ir.IntType(64), [], var_arg=True)
            f = ir.Function(module, fty, func_name)
            return f

        case func_name if func_name.startswith("_InterlockedCompareExchange") or func_name.startswith("_InterlockedExchange"):
            fty = ir.FunctionType(ir.IntType(64), [], var_arg=True)
            f = ir.Function(module, fty, func_name)
            return f

        # case "memset":
        #     # ida_pro: (dest, src, length)
        #     # llvmintrinsic: (dest, src, length, isvolatile=True)
        #     typ = ir.FunctionType(ir.VoidType(), (i8ptr, ir.IntType(8), ir.IntType(64)))
        #     f = declare_function("_h_memset", typ)

        #     if not f.is_defined():
        #         f.llvm_f.append_basic_block()
        #         f.builder = ir.IRBuilder(f.llvm_f.entry_basic_block)

        #         memset = module.declare_intrinsic('llvm.memset', [i8ptr, ir.IntType(64)])

        #         dest, src, length = f.llvm_f.args
        #         volatile = ir.Constant(ir.IntType(1), True)
        #         f.builder.call(memset, (dest, src, length, volatile))
        #         f.builder.ret_void()
        #     return f.llvm_f

        # case "__ROL8__":
        #     # ida_pro: (item, shiftamount)
        #     # llvmintrinsic: (left, right, shiftamount) funnelshiftright is equal to rotateright iff left and right operands are equal.
        #     typ = ir.FunctionType(ir.IntType(64), (ir.IntType(64), ir.IntType(8)))
        #     f = declare_function("_h_rol8", typ)

        #     if not f.is_defined():
        #         f.llvm_f.append_basic_block()
        #         f.builder = ir.IRBuilder(f.llvm_f.entry_basic_block)
        #         rol_func_type = ir.FunctionType(ir.IntType(64), (ir.IntType(64), ir.IntType(64), ir.IntType(64)))
        #         rol8 = module.declare_intrinsic('llvm.fshl.i64', [ir.IntType(64), ir.IntType(64), ir.IntType(64)], rol_func_type)

        #         item, shiftamount = f.llvm_f.args
        #         shiftamount = llvmgen.ida2llvm.type.change_type(f.builder, shiftamount, ir.IntType(64))
        #         return_val = f.builder.call(rol8, (item, item, shiftamount))
        #         f.builder.ret(return_val)
        #     return f.llvm_f
            
        # case "_byteswap_uint64":
        #     # ida_pro: (item)
        #     # llvmintrinsic: (item)
        #     typ = ir.FunctionType(ir.IntType(64), (ir.IntType(64),))
        #     f = declare_function("_h_byteswap_uint64", typ)

        #     if not f.is_defined():
        #         f.llvm_f.append_basic_block()
        #         f.builder = ir.IRBuilder(f.llvm_f.entry_basic_block)
        #         byteswap_func_type = ir.FunctionType(ir.IntType(64), (ir.IntType(64),))
        #         byteswap64 = module.declare_intrinsic('llvm.bswap.i64', [ir.IntType(64),], byteswap_func_type)

        #         item, = f.llvm_f.args
        #         return_val = f.builder.call(byteswap64, (item,))
        #         f.builder.ret(return_val)
        #     return f.llvm_f

        # case "_byteswap_ulong":
        #     # ida_pro: (item)
        #     # llvmintrinsic: (item)
        #     typ = ir.FunctionType(ir.IntType(32), (ir.IntType(32),))
        #     f = declare_function("_h_byteswap_uint32", typ)

        #     if not f.is_defined():
        #         f.llvm_f.append_basic_block()
        #         f.builder = ir.IRBuilder(f.llvm_f.entry_basic_block)
        #         byteswap_func_type = ir.FunctionType(ir.IntType(32), (ir.IntType(32),))
        #         byteswap32 = module.declare_intrinsic('llvm.bswap.i32', [ir.IntType(32),], byteswap_func_type)

        #         item, = f.llvm_f.args
        #         return_val = f.builder.call(byteswap32, (item,))
        #         f.builder.ret(return_val)
        #     return f.llvm_f

        case _:
            raise NotImplementedError(f"NotImplementedError {func_name}")

def lift_function(module: ir.Module, func_name: str, is_declare: bool, tif: ida_typeinf.tinfo_t = None):
    """
    Declares function given its name. 
    If `is_declare` is False, also define the function by recursively.
    If `tif` is given, enforce function type as given.
    lifting its instructions in IDA decompiler output.
    Heavylifting is done in `lift_from_address`.

    :param module: parent module of function
    :type module: ir.Module
    :param func_name: name of function to lift
    :type func_name: str
    :param is_declare: is the function declare only?
    :type is_declare: bool
    :param tif: function type, defaults to None
    :type tif: ida_typeinf.tinfo_t, optional
    :return: lifted function
    :rtype: ir.Function
    """
    from contextlib import suppress
    with suppress(NotImplementedError):
        return lift_intrinsic_function(module, func_name)

    with suppress(KeyError):
        return module.get_global(func_name)

    func_ea = ida_name.get_name_ea(ida_idaapi.BADADDR, func_name)
    if ida_segment.segtype(func_ea) & ida_segment.SEG_XTRN:
        is_declare = True

    assert func_ea != ida_idaapi.BADADDR
    if tif is None:
        tif = ida2llvm.address.lift_type_from_address(func_ea)
    typ = ida2llvm.type.lift_tif(tif)
    res = ir.Function(module, typ, func_name)
    logger.debug(f"lifting function {func_name} at {hex(func_ea)}, type: {typ} from {tif}")

    # rename all function args to arg0, arg1, arg2, if does not exist
    ida_func_details = ida_typeinf.func_type_data_t()
    tif.get_func_details(ida_func_details)

    ida_args = (ida_func_details.at(i) for i in range(ida_func_details.size()))
    for i, arg in enumerate(ida_args):
        arg.name = f"arg{i}"
    function_tinfo = ida_typeinf.tinfo_t()
    function_tinfo.create_func(ida_func_details)
    if func_ea != 0xffffffffffffffff:
        ida_typeinf.apply_tinfo(func_ea, function_tinfo, ida_typeinf.TINFO_DEFINITE)

    if is_declare:
        return res
    return ida2llvm.address.lift_from_address(module, func_ea)

```

`ida2llvm/insn.py`:

```py
import ida_idaapi
import ida_ida
import ida_funcs
import ida_hexrays
import ida_typeinf
import ida_segment
import ida_nalt
import ida_name
import itertools
import logging
import llvmlite.binding as llvm

from llvmlite import ir
from contextlib import suppress
import ida2llvm

logger = logging.getLogger(__name__)
if not logger.handlers:
    logging.basicConfig(level=logging.DEBUG, format="LLVMLIFT %(levelname)s %(message)s")
logger.setLevel(logging.DEBUG)

def _parse_mop_global_offset(ea: int) -> tuple[str, int, int]:
    """
    Extract base symbol and offset from an effective address using IDA's name resolution.
    
    Uses ida_name.get_nice_colored_name() which provides stable output like:
    - "symbol" -> plain symbol at EA
    - "symbol+offset" -> base symbol + positive offset
    - "symbol-offset" -> base symbol + negative offset
    
    This is more reliable than parsing dstr() which can have $ prefixes and
    other microcode-specific formatting.
    
    :param ea: Effective address (mop.g)
    :return: (base_symbol_name, offset_from_base, base_ea) or raises ValueError
    :raises ValueError: if EA cannot be resolved to a named symbol
    """
    # Get the nice colored name without color codes or segment prefixes
    name_str = ida_name.get_nice_colored_name(ea, ida_name.GNCN_NOCOLOR | ida_name.GNCN_NOSEG)
    
    if not name_str:
        raise ValueError(f"Cannot resolve EA 0x{ea:X} to a named symbol")
    
    name_str = name_str.strip()
    
    # Parse the output: "symbol", "symbol+X", or "symbol-X"
    base_name = None
    offset = 0
    
    if '+' in name_str:
        # Format: "symbol+offset"
        parts = name_str.rsplit('+', 1)  # rsplit to handle symbols with + in name
        if len(parts) == 2:
            base_name = parts[0].strip()
            try:
                # IDA uses hex without 0x prefix for offsets
                offset_str = parts[1].strip()
                offset = int(offset_str, 16) if not offset_str.startswith('0x') else int(offset_str, 0)
            except ValueError:
                # Couldn't parse offset, treat whole thing as symbol name
                base_name = name_str
                offset = 0
        else:
            base_name = name_str
            offset = 0
    
    elif '-' in name_str:
        # Format: "symbol-offset"
        parts = name_str.rsplit('-', 1)
        if len(parts) == 2:
            base_name = parts[0].strip()
            try:
                offset_str = parts[1].strip()
                offset = -(int(offset_str, 16) if not offset_str.startswith('0x') else int(offset_str, 0))
            except ValueError:
                base_name = name_str
                offset = 0
        else:
            base_name = name_str
            offset = 0
    
    else:
        # Plain symbol, no offset
        base_name = name_str
        offset = 0
    
    # Look up base symbol EA
    base_ea = ida_name.get_name_ea(ida_idaapi.BADADDR, base_name)
    if base_ea == ida_idaapi.BADADDR:
        raise ValueError(f"Cannot find base symbol '{base_name}' from name '{name_str}'")
    
    # Verify offset matches
    computed_offset = ea - base_ea
    if offset != computed_offset:
        logger.debug(f"Parsed offset {offset} != computed {computed_offset} for '{name_str}', using computed")
        offset = computed_offset
    
    return base_name, offset, base_ea

def lift_mop(mop: ida_hexrays.mop_t, blk: ir.Block, builder: ir.IRBuilder) -> ir.Value:
    """Lifts an IDA mop_t object to LLVM Value.

    :param mop: mop_t object to lift
    :type mop: ida_hexrays.mop_t
    :param blk: LLVM Block to add instructions to
    :type blk: ir.Block
    :raises NotImplementedError: specific mop_t types are not implemented
    :param builder: builder to emit instructions into
    :type builder: ir.IRBuilder
    :return: lifted LLVM Value
    :rtype: ir.Value
    """
    builder.position_at_end(blk)
    try:
        logger.debug(f"ENTER lift_mop t={mop.t} size={getattr(mop,'size',None)} dstr='{mop.dstr()}'")
    except Exception:
        logger.debug("ENTER lift_mop <error printing mop>")
    match mop.t:
        case ida_hexrays.mop_r: # register value
            # logger.warning("register lifting not implemented, None is returned")
            return None
        case ida_hexrays.mop_n: # immediate value
            res = ir.Constant(ir.IntType(mop.size * 8), mop.nnn.value)
            res.parent = blk
            logger.debug(f"lift_mop immediate value={mop.nnn.value} llvm={res} type={res.type}")
            return res
        case ida_hexrays.mop_d: # another instruction
            d = lift_insn(mop.d, blk, builder)
            td = llvm.create_target_data("e")
            match mop:
                case voidType if isinstance(d.type, ir.VoidType):
                    pass
                case mcall if isinstance(mcall, ida_hexrays.mcallarg_t):
                    lltype = ida2llvm.type.lift_tif(mop.type)
                    d = ida2llvm.type.typecast(d, lltype, builder, signed=mop.type.is_signed())
                case sizeEnforced if d.type.get_abi_size(td) != mop.size and mop.size != -1:
                    d = ida2llvm.type.typecast(d, ir.IntType(mop.size * 8), builder)
            return d
        case ida_hexrays.mop_l: # local variables
            lvar_ref = mop.l
            lvar = lvar_ref.var()
            name = lvar.name
            off = lvar_ref.off

            if not lvar.has_user_type:
                ulvars = lvar_ref.mba.vars
                ulvar = ulvars.at(lvar_ref.idx)
                lvar.set_final_lvar_type(ulvar.tif)
                lvar.set_user_type()

            func = blk.parent
            if name not in func.lvars:
                with builder.goto_entry_block():                
                    func.lvars[name] = builder.alloca(ida2llvm.type.lift_tif(lvar.tif), name = name)

            llvm_arg = func.lvars[name]

            if lvar.width != mop.size and mop.size != -1:
                mop_type = ir.IntType(mop.size * 8).as_pointer()
                llvm_arg = ida2llvm.type.typecast(llvm_arg, mop_type, builder)

            llvm_arg = ida2llvm._utils.get_offset_to(builder, llvm_arg, off)
            loaded = builder.load(llvm_arg)
            logger.debug(f"lift_mop local name={name} off={off} loaded={loaded} type={loaded.type}")
            return loaded
        case ida_hexrays.mop_S: # stack variables
            pass
        case ida_hexrays.mop_b: # block number (used in jmp\call instruction)
            return blk.parent.blocks[mop.b]
        case ida_hexrays.mop_v: # global variable
            ea = mop.g
            dstr = mop.dstr()
            name = ida_name.get_name(ea)
            if name == "":
                name = f"g_{hex(ea)}"
            
            # If the address is not mapped to any segment, this is likely a numeric
            # immediate masquerading as a global EA (e.g., 0x1 -> g_0x1). In such
            # cases, lift it as an integer constant instead of fabricating a global.
            try:
                seg = ida_segment.getseg(ea)
            except Exception:
                seg = None
            if seg is None:
                width_bytes = mop.size if mop.size and mop.size > 0 else (8 if ida_ida.inf_is_64bit() else 4)
                width_bits = width_bytes * 8
                mask = (1 << width_bits) - 1
                const_val = ea & mask
                res = ir.Constant(ir.IntType(width_bits), const_val)
                res.parent = blk
                logger.debug(f"lift_mop unmapped EA=0x{ea:X} -> immediate {const_val} width_bits={width_bits}")
                return res
            
            # Try to resolve EA to base+offset using IDA's name resolution
            base_name = None
            offset = 0
            base_ea = ea
            try:
                base_name, offset, base_ea = _parse_mop_global_offset(ea)
                logger.debug(f"lift_mop resolved EA 0x{ea:X} -> base='{base_name}' offset={offset} base_ea=0x{base_ea:X}")
            except ValueError as e:
                # Name resolution failed, fall back to treating EA as-is
                logger.debug(f"lift_mop name resolution failed for EA 0x{ea:X}: {e} - using EA directly")
                base_name = None
            tif = ida_typeinf.tinfo_t()
            ida_nalt.get_tinfo(tif, ea)
            if tif.empty():
                match mop.size:
                    case 1:
                        tif.create_simple_type(ida_typeinf.BT_UNK_BYTE)
                    case 2:
                        tif.create_simple_type(ida_typeinf.BT_UNK_WORD)
                    case 4:
                        tif.create_simple_type(ida_typeinf.BT_UNK_DWORD)
                    case 8:
                        tif.create_simple_type(ida_typeinf.BT_UNK_QWORD)
                    case 16:
                        tif.create_simple_type(ida_typeinf.BT_UNK_OWORD)
                    case _:
                        size = mop.size if mop.size > 0 else 1000
                        onebyte_tif = ida_typeinf.tinfo_t()
                        onebyte_tif.create_simple_type(ida_typeinf.BT_UNK_BYTE)
                        tif.create_array(onebyte_tif, size, 0, ida_typeinf.BT_ARRAY)
            match tif:
                case func if func.is_func() or func.is_funcptr():
                    with suppress(KeyError):
                        g = blk.parent.parent.get_global(name)
                        typ = ida2llvm.type.lift_tif(tif).as_pointer()
                        g = ida2llvm.type.typecast(g, typ, builder)
                        return g
                    if func.is_funcptr():
                        tif = tif.get_ptrarr_object()
                    # if function is a thunk function, define the actual function instead
                    if ((ida_funcs.get_func(ea) is not None)
                    and (ida_funcs.get_func(ea).flags & ida_funcs.FUNC_THUNK)): 
                        tfunc_ea, ptr = ida_funcs.calc_thunk_func_target(ida_funcs.get_func(ea))
                        if tfunc_ea != ida_idaapi.BADADDR:
                            ea = tfunc_ea
                            name = ida_name.get_name(ea)
                    
                    # if no function definition,
                    if ((ida_funcs.get_func(ea) is None)
                    # or if the function is a library function,
                    or (ida_funcs.get_func(ea).flags & ida_funcs.FUNC_LIB) 
                    # or if the function is declared in a XTRN segment,
                    or ida_segment.segtype(ea) & ida_segment.SEG_XTRN): 
                        # return function declaration
                        g = ida2llvm.function.lift_function(blk.parent.parent, name, True, tif)
                    else:
                        g = ida2llvm.function.lift_function(blk.parent.parent, name, False, tif)
                    return g
                case _:
                    # Check if we have base+offset from dstr parsing
                    if base_name and offset != 0:
                        # Lift as base global + typed offset
                        # First, try to get or create the base global
                        try:
                            base_global = blk.parent.parent.get_global(base_name)
                            logger.debug(f"lift_mop using existing base global '{base_name}'")
                        except KeyError:
                            # Need to create base global from base_ea
                            base_tif = ida_typeinf.tinfo_t()
                            ida_nalt.get_tinfo(base_tif, base_ea)
                            if base_tif.empty():
                                # Default to byte array if no type info
                                onebyte_tif = ida_typeinf.tinfo_t()
                                onebyte_tif.create_simple_type(ida_typeinf.BT_UNK_BYTE)
                                # Make a reasonably sized array
                                arr_size = max(offset + mop.size, 1000)
                                base_tif.create_array(onebyte_tif, arr_size, 0, ida_typeinf.BT_ARRAY)
                            
                            base_typ = ida2llvm.type.lift_tif(base_tif)
                            base_cmt = ida2llvm.address.lift_from_address(blk.parent.parent, base_ea, base_typ)
                            base_global = ir.GlobalVariable(blk.parent.parent, base_cmt.type, name=base_name)
                            base_global.initializer = base_cmt
                            logger.debug(f"lift_mop created base global '{base_name}' type={base_global.type}")
                        
                        # Now compute offset pointer
                        # If base is array, use proper typed GEP
                        if isinstance(base_global.type.pointee, ir.ArrayType):
                            element_type = base_global.type.pointee.element
                            td = llvm.create_target_data("e")
                            element_size = element_type.get_abi_size(td)
                            if element_size > 0:
                                index = offset // element_size
                                # GEP with array indexing: [0, index]
                                offset_ptr = builder.gep(base_global, [
                                    ir.Constant(ir.IntType(64), 0),
                                    ir.Constant(ir.IntType(64), index)
                                ])
                                logger.debug(f"lift_mop GEP array base={base_name} elem_size={element_size} offset={offset} index={index}")
                            else:
                                # Element size is 0, fallback to byte pointer
                                byte_ptr = builder.bitcast(base_global, ir.IntType(8).as_pointer())
                                offset_ptr = builder.gep(byte_ptr, [ir.Constant(ir.IntType(64), offset)])
                                logger.debug(f"lift_mop GEP byte fallback base={base_name} offset={offset}")
                        else:
                            # Not an array, cast to byte pointer and offset
                            byte_ptr = builder.bitcast(base_global, ir.IntType(8).as_pointer())
                            offset_ptr = builder.gep(byte_ptr, [ir.Constant(ir.IntType(64), offset)])
                            logger.debug(f"lift_mop GEP non-array base={base_name} offset={offset}")
                        
                        # Cast to appropriate type if needed
                        if mop.size != -1:
                            target_type = ir.IntType(mop.size * 8).as_pointer()
                            offset_ptr = ida2llvm.type.typecast(offset_ptr, target_type, builder)
                        
                        loaded = builder.load(offset_ptr)
                        logger.debug(f"lift_mop loaded from base+offset: {loaded} type={loaded.type}")
                        return loaded
                    
                    # Fallback: no offset or dstr parse failed, use EA directly
                    with suppress(KeyError):
                        g = blk.parent.parent.get_global(name)
                        return builder.load(g)
                    typ = ida2llvm.type.lift_tif(tif)
                    g_cmt = ida2llvm.address.lift_from_address(blk.parent.parent, ea, typ)
                    g = ir.GlobalVariable(blk.parent.parent, g_cmt.type, name = name)
                    g.initializer = g_cmt
                    td = llvm.create_target_data("e")
                    if g.type.get_abi_size(td) != mop.size and mop.size != -1:
                        g = ida2llvm.type.typecast(g, ir.IntType(mop.size * 8).as_pointer(), builder)
                    return builder.load(g)
        case ida_hexrays.mop_f: # function call information
            mcallinfo = mop.f
            f_args = []
            f_ret = []
            for i in range(mcallinfo.retregs.size()):
                mopt = mcallinfo.retregs.at(i)
                f_ret.append(lift_mop(mopt, blk, builder))
            for arg in mcallinfo.args:
                typ = ida2llvm.type.lift_tif(arg.type)
                f_arg = lift_mop(arg, blk, builder)
                f_arg = ida2llvm.type.typecast(f_arg, typ, builder)
                logger.debug(f"{f_arg} ({f_arg.type}) lifted from {arg} ({typ})")
                f_args.append(f_arg)
            return f_ret,f_args
        case ida_hexrays.mop_a: # operating number address (mop_l\mop_v\mop_S\mop_r)
            mop_addr = mop.a
            val = ida2llvm._utils.dedereference(lift_mop(mop_addr, blk, builder))
            match mop:
                case mcall if isinstance(mcall, ida_hexrays.mcallarg_t):
                    lltype = ida2llvm.type.lift_tif(mop.type)
                    val = ida2llvm.type.typecast(val, lltype, builder)
                case mop_addr if isinstance(mop_addr, ida_hexrays.mop_addr_t):
                    lltype = ida2llvm.type.lift_tif(mop.type)
                    val = ida2llvm.type.typecast(val, lltype, builder)
                case _:
                    lltype = ir.IntType(8).as_pointer()
                    val = ida2llvm.type.typecast(val, lltype, builder)
            return val
        case ida_hexrays.mop_h: # auxiliary function number
            return ida2llvm.function.lift_intrinsic_function(blk.parent.parent, mop.helper)
        case ida_hexrays.mop_str: # string constant
            str_csnt = mop.cstr

            strType = ir.ArrayType(ir.IntType(8), len(str_csnt))
            g = ir.GlobalVariable(blk.parent.parent, strType, name=str_csnt)
            g.initializer = ir.Constant(strType, bytearray(str_csnt.encode("utf-8")))
            g.linkage = "private"
            g.global_constant = True
            return ida2llvm.type.typecast(g, ir.IntType(8).as_pointer(), builder)
        case ida_hexrays.mop_c: # switch case and target
            pass
        case ida_hexrays.mop_fn: # floating points constant
            # Floating point constant
            fpval = mop.fpc
            # Determine the type based on size
            if mop.size == 4:
                fp_type = ir.FloatType()
                res = ir.Constant(fp_type, fpval.fnum)
            elif mop.size == 8:
                fp_type = ir.DoubleType()
                res = ir.Constant(fp_type, fpval.fnum)
            else:
                # Default to double for other sizes
                fp_type = ir.DoubleType()
                res = ir.Constant(fp_type, fpval.fnum)
            res.parent = blk
            return res
        case ida_hexrays.mop_p: # the number of operations is correct
            pass
        case ida_hexrays.mop_sc: # decentralized operation information
            pass
        case ida_hexrays.mop_z: # does not exist
            return None
    mop_descs = {ida_hexrays.mop_r: "register value",
                ida_hexrays.mop_n: "immediate value",
                ida_hexrays.mop_d: "another instruction",
                ida_hexrays.mop_l: "local variables",
                ida_hexrays.mop_S: "stack variables",
                ida_hexrays.mop_b: "block number (used in jmp\\call instruction)",
                ida_hexrays.mop_v: "global variable",
                ida_hexrays.mop_f: "function call information",
                ida_hexrays.mop_a: "operating number address (mop_l\\mop_v\\mop_S\\mop_r)",
                ida_hexrays.mop_h: "auxiliary function number",
                ida_hexrays.mop_str: "string constant",
                ida_hexrays.mop_c: "switch case and target",
                ida_hexrays.mop_fn: "floating points constant",
                ida_hexrays.mop_p: "the number of operations is correct",
                ida_hexrays.mop_sc: "decentralized operation information"
    }
    raise NotImplementedError(f"not implemented: {mop.dstr()} of type {mop_descs[mop.t]}")

def _store_as(l: ir.Value, d: ir.Value, blk: ir.Block, builder: ir.IRBuilder, d_typ: ir.Type = None, signed: bool = True):
    """
    Private helper function to store value to destination.
    """
    if d is None:  # destination does not exist
        return l

    d = ida2llvm._utils.dedereference(d)
    if d_typ:
        d = ida2llvm.type.typecast(d, d_typ, builder, signed)
    assert isinstance(d.type, ir.PointerType)

    if isinstance(d.type.pointee, ir.ArrayType):
        arrtoptr = d.type.pointee.element.as_pointer()
        d = ida2llvm.type.typecast(d, arrtoptr.as_pointer(), builder, signed)

    if isinstance(l.type, ir.VoidType):
        return

    l = ida2llvm.type.typecast(l, d.type.pointee, builder, signed)
    return builder.store(l, d)

def lift_insn(ida_insn: ida_hexrays.minsn_t, blk: ir.Block, builder: ir.IRBuilder) -> ir.Instruction:
    """Heavylifter function that lifts a given IDA Microcode instruction.

    A given ida instruction could comprise multiple Instructions.
    Note that only final instruction is returned.
    Intermediate instructions emitted discretely into `blk`.

    :param ida_insn: IDA Microcode instruction
    :type ida_insn: ida_hexrays.minsn_t
    :param blk: LLVM Block to emit instructions into
    :type blk: ir.Block
    :raises NotImplementedError: m_add only supports addition between integers/pointers
    :raises NotImplementedError: m_sub only supports subtraction between integers/pointers
    :raises NotImplementedError: certain minsn_t have not been lifted yet
    :param builder: builder to emit instructions into
    :type builder: ir.IRBuilder
    :return: final instruction (intermediate instructions emitted are not returned)
    :rtype:ir.Instruction
    """
    builder.position_at_end(blk)
    try:
        logger.debug(f"ENTER lift_insn ea=0x{ida_insn.ea:X} opcode={ida_insn.opcode} dstr='{ida_insn.dstr()}'")
    except Exception:
        logger.debug("ENTER lift_insn <error printing insn>")
    l = lift_mop(ida_insn.l, blk, builder)
    r = lift_mop(ida_insn.r, blk, builder)
    d = lift_mop(ida_insn.d, blk, builder)
    def _valinfo(v):
        if v is None:
            return "None"
        ty = getattr(v, 'type', None)
        return f"{v} :: {ty}"
    logger.debug("lift_insn operands:\n- L=" + _valinfo(l) + "\n- R=" + _valinfo(r) + "\n- D=" + _valinfo(d))
    blk_itr = iter(blk.parent.blocks)
    list(itertools.takewhile(lambda x: x.name != blk.name, blk_itr)) # consume iter
    next_blk = next(blk_itr, None)

    match ida_insn.opcode:
        case ida_hexrays.m_nop:  # 0x00,  nop    no operation
            return
        case ida_hexrays.m_stx:  # 0x01,  stx  l,    {r=sel, d=off}  store register to memory*F
            if d is None:  # destination does not exist
                return l
            if isinstance(l.type, ir.VoidType):
                return

            if isinstance(d.type, ir.ArrayType):
                arrtoptr = d.type.element.as_pointer()
                d = ida2llvm.type.typecast(d, arrtoptr, builder, True)
            elif isinstance(d.type, ir.IntType):
                d = builder.inttoptr(d, l.type.as_pointer())

            assert isinstance(d.type, ir.PointerType)
            l = ida2llvm.type.typecast(l, d.type.pointee, builder, True)
            inst = builder.store(l, d)
            logger.debug(f"lift_insn m_stx store value={_valinfo(l)} dest={_valinfo(d)} -> {inst}")
            return inst
        case ida_hexrays.m_ldx:  # 0x02,  ldx  {l=sel,r=off}, d load    register from memory    *F
            if not isinstance(r.type, ir.PointerType):
                register_size = 8*ida_insn.r.size
                r = ida2llvm.type.typecast(r, ir.IntType(register_size).as_pointer(), builder)    
            r = builder.load(r)

            return _store_as(r, d, blk, builder)
        case ida_hexrays.m_ldc:  # 0x03,  ldc  l=const,d   load constant
            return _store_as(l, d, blk, builder)
        case ida_hexrays.m_mov:  # 0x04,  mov  l, d   move*F
            return _store_as(l, d, blk, builder)
        case ida_hexrays.m_neg:  # 0x05,  neg  l, d   negate
            l = builder.neg(l)
            return _store_as(l, d, blk, builder)
        case ida_hexrays.m_lnot:  # 0x06,  lnot l, d   logical not
            assert isinstance(l.type, ir.IntType)
            cmp = builder.icmp_unsigned("==", l, ir.IntType(l.type.width)(0))
            return _store_as(cmp, d, blk, builder)
        case ida_hexrays.m_bnot:  # 0x07,  bnot l, d   bitwise not
            l = builder.not_(l)
            return _store_as(l, d, blk, builder)
        case ida_hexrays.m_xds:  # 0x08,  xds  l, d   extend (signed)
            return _store_as(l, d, blk, builder)
        case ida_hexrays.m_xdu:  # 0x09,  xdu  l, d   extend (unsigned)
            return _store_as(l, d, blk, builder, signed=False)
        case ida_hexrays.m_low:  # 0x0A,  low  l, d   take low part
            return _store_as(l, d, blk, builder)
        case ida_hexrays.m_high:  # 0x0B,  high l, d   take high part
            return _store_as(l, d, blk, builder)
        case ida_hexrays.m_add:  # 0x0C,  add  l,   r, d   l + r -> dst
            match (l, r):
                case (ptr, const) if isinstance(ptr.type, ir.PointerType) and isinstance(const.type, ir.IntType):
                    castPtr = builder.bitcast(ptr, ir.IntType(8).as_pointer())
                    math = builder.gep(castPtr, (const, ))
                    math = builder.bitcast(math, ptr.type)
                case (const, ptr) if isinstance(ptr.type, ir.PointerType) and isinstance(const.type, ir.IntType):
                    castPtr = builder.bitcast(ptr, ir.IntType(8).as_pointer())
                    math = builder.gep(castPtr, (const, ))
                    math = builder.bitcast(math, ptr.type)
                case (const1, const2) if isinstance(const1.type, ir.IntType) and isinstance(const2.type, ir.IntType):
                    math = builder.add(const1, const2)
                case (ptr1, ptr2) if isinstance(ptr1.type, ir.PointerType) and isinstance(ptr2.type, ir.PointerType):
                    ptrType = ir.IntType(64) # get pointer type
                    const1 = builder.ptrtoint(ptr1, ptrType)
                    const2 = builder.ptrtoint(ptr2, ptrType)
                    math = builder.add(const1, const2)
                case _:
                    raise NotImplementedError("expected addition between pointer/integers")
            inst = _store_as(math, d, blk, builder)
            logger.debug(f"lift_insn m_add math={_valinfo(math)} dst={_valinfo(d)} -> {inst}")
            return inst 
        case ida_hexrays.m_sub:  # 0x0D,  sub  l,   r, d   l - r -> dst
            match (l, r):
                case (ptr, const) if isinstance(ptr.type, ir.PointerType) and isinstance(const.type, ir.IntType):
                    neg_const = builder.neg(const)
                    castPtr = builder.bitcast(ptr, ir.IntType(8).as_pointer())
                    math = builder.gep(castPtr, (neg_const, ))
                    math = builder.bitcast(math, ptr.type)
                case (const, ptr) if isinstance(ptr.type, ir.PointerType) and isinstance(const.type, ir.IntType):
                    neg_const = builder.neg(const)
                    castPtr = builder.bitcast(ptr, ir.IntType(8).as_pointer())
                    math = builder.gep(castPtr, (neg_const, ))
                    math = builder.bitcast(math, ptr.type)
                case (const1, const2) if isinstance(const1.type, ir.IntType) and isinstance(const2.type, ir.IntType):
                    math = builder.sub(const1, const2)
                case (ptr1, ptr2) if isinstance(ptr1.type, ir.PointerType) and isinstance(ptr2.type, ir.PointerType):
                    ptrType = ir.IntType(64) # get pointer type
                    const1 = builder.ptrtoint(ptr1, ptrType)
                    const2 = builder.ptrtoint(ptr2, ptrType)
                    math = builder.sub(const1, const2)
                case _:
                    raise NotImplementedError("expected subtraction between pointer/integers")
            return _store_as(math, d, blk, builder) 
        case ida_hexrays.m_mul:  # 0x0E,  mul  l,   r, d   l * r -> dst
            math = builder.mul(l, r)
            return _store_as(math, d, blk, builder)
        case ida_hexrays.m_udiv:  # 0x0F,  udiv l,   r, d   l / r -> dst
            r = ida2llvm.type.typecast(r, l.type, builder)
            math = builder.udiv(l, r)
            return _store_as(math, d, blk, builder)
        case ida_hexrays.m_sdiv:  # 0x10,  sdiv l,   r, d   l / r -> dst
            r = ida2llvm.type.typecast(r, l.type, builder)
            math = builder.sdiv(l, r)
            return _store_as(math, d, blk, builder)
        case ida_hexrays.m_umod:  # 0x11,  umod l,   r, d   l % r -> dst
            r = ida2llvm.type.typecast(r, l.type, builder)
            math = builder.urem(l, r)
            return _store_as(math, d, blk, builder)
        case ida_hexrays.m_smod:  # 0x12,  smod l,   r, d   l % r -> dst
            r = ida2llvm.type.typecast(r, l.type, builder)
            math = builder.srem(l, r)
            return _store_as(math, d, blk, builder)
        case ida_hexrays.m_or:  # 0x13,  or   l,   r, d   bitwise or
            r = ida2llvm.type.typecast(r, l.type, builder)
            math = builder.or_(l, r)
            return _store_as(math, d, blk, builder)
        case ida_hexrays.m_and:  # 0x14,  and  l,   r, d   bitwise and
            r = ida2llvm.type.typecast(r, l.type, builder)
            math = builder.and_(l, r)
            return _store_as(math, d, blk, builder)
        case ida_hexrays.m_xor:  # 0x15,  xor  l,   r, d   bitwise xor
            r = ida2llvm.type.typecast(r, l.type, builder)
            math = builder.xor(l, r)
            return _store_as(math, d, blk, builder)
        case ida_hexrays.m_shl:  # 0x16,  shl  l,   r, d   shift logical left
            r = ida2llvm.type.typecast(r, l.type, builder)
            math = builder.shl(l, r)
            return _store_as(math, d, blk, builder)
        case ida_hexrays.m_shr:  # 0x17,  shr  l,   r, d   shift logical right
            r = ida2llvm.type.typecast(r, l.type, builder)
            math = builder.ashr(l, r)
            return _store_as(math, d, blk, builder)
        case ida_hexrays.m_sar:  # 0x18,  sar  l,   r, d   shift arithmetic right
            r = ida2llvm.type.typecast(r, l.type, builder)
            math = builder.ashr(l, r)
            return _store_as(math, d, blk, builder)
        case ida_hexrays.m_cfadd:  # 0x19,  cfadd l,  r,    d=carry    calculate carry    bit of (l+r)
            math = builder.sadd_with_overflow(l, r) # a { result, overflow bit } structure is returned
            math = math.gep((ir.IntType(64)(0), ir.IntType(64)(0)))
            return _store_as(math, d, blk, builder)
        case ida_hexrays.m_ofadd:  # 0x1A,  ofadd l,  r,    d=overf    calculate overflow bit of (l+r)
            math = builder.sadd_with_overflow(l, r) # a { result, overflow bit } structure is returned
            math = math.gep((ir.IntType(64)(0), ir.IntType(64)(1)))
            return _store_as(math, d, blk, builder)
        case ida_hexrays.m_cfshl:  # 0x1B,  cfshl l,  r,    d=carry    calculate carry    bit of (l<<r)
            pass
        case ida_hexrays.m_cfshr:  # 0x1C,  cfshr l,  r,    d=carry    calculate carry    bit of (l>>r)
            pass
        case ida_hexrays.m_sets:  # 0x1D,  sets  l,d=byte  SF=1Sign
            pass
        case ida_hexrays.m_seto:  # 0x1E,  seto  l,  r, d=byte  OF=1Overflow of (l-r)
            pass
        case ida_hexrays.m_setp:  # 0x1F,  setp  l,  r, d=byte  PF=1Unordered/Parity  *F
            pass
        case ida_hexrays.m_setnz:  # 0x20,  setnz l,  r, d=byte  ZF=0Not Equal    *F
            l = ida2llvm.type.typecast(l, ir.IntType(64), builder)
            r = ida2llvm.type.typecast(r, ir.IntType(64), builder)
            cond = builder.icmp_unsigned("!=", l, r)
            result = builder.select(cond, ir.IntType(1)(1), ir.IntType(1)(0))
            return _store_as(result, d, blk, builder)
        case ida_hexrays.m_setz:  # 0x21,  setz  l,  r, d=byte  ZF=1Equal   *F
            l = ida2llvm.type.typecast(l, ir.IntType(64), builder)
            r = ida2llvm.type.typecast(r, ir.IntType(64), builder)
            cond = builder.icmp_unsigned("==", l, r)
            result = builder.select(cond, ir.IntType(1)(1), ir.IntType(1)(0))
            return _store_as(result, d, blk, builder)
        case ida_hexrays.m_setae:  # 0x22,  setae l,  r, d=byte  CF=0Above or Equal    *F
            l = ida2llvm.type.typecast(l, ir.IntType(64), builder)
            r = ida2llvm.type.typecast(r, ir.IntType(64), builder)
            cond = builder.icmp_unsigned(">=", l, r)
            result = builder.select(cond, ir.IntType(1)(1), ir.IntType(1)(0))
            return _store_as(result, d, blk, builder)
        case ida_hexrays.m_setb:  # 0x23,  setb  l,  r, d=byte  CF=1Below   *F
            l = ida2llvm.type.typecast(l, ir.IntType(64), builder)
            r = ida2llvm.type.typecast(r, ir.IntType(64), builder)
            cond = builder.icmp_unsigned("<", l, r)
            result = builder.select(cond, ir.IntType(1)(1), ir.IntType(1)(0))
            return _store_as(result, d, blk, builder)
        case ida_hexrays.m_seta:  # 0x24,  seta  l,  r, d=byte  CF=0 & ZF=0   Above   *F
            l = ida2llvm.type.typecast(l, ir.IntType(64), builder)
            r = ida2llvm.type.typecast(r, ir.IntType(64), builder)
            cond = builder.icmp_unsigned(">", l, r)
            result = builder.select(cond, ir.IntType(1)(1), ir.IntType(1)(0))
            return _store_as(result, d, blk, builder)
        case ida_hexrays.m_setbe:  # 0x25,  setbe l,  r, d=byte  CF=1 | ZF=1   Below or Equal    *F
            l = ida2llvm.type.typecast(l, ir.IntType(64), builder)
            r = ida2llvm.type.typecast(r, ir.IntType(64), builder)
            cond = builder.icmp_unsigned("<=", l, r)
            result = builder.select(cond, ir.IntType(1)(1), ir.IntType(1)(0))
            return _store_as(result, d, blk, builder)
        case ida_hexrays.m_setg:  # 0x26,  setg  l,  r, d=byte  SF=OF & ZF=0  Greater
            l = ida2llvm.type.typecast(l, ir.IntType(64), builder)
            r = ida2llvm.type.typecast(r, ir.IntType(64), builder)
            cond = builder.icmp_signed(">", l, r)
            result = builder.select(cond, ir.IntType(1)(1), ir.IntType(1)(0))
            return _store_as(result, d, blk, builder)
        case ida_hexrays.m_setge:  # 0x27,  setge l,  r, d=byte  SF=OF    Greater or Equal
            l = ida2llvm.type.typecast(l, ir.IntType(64), builder)
            r = ida2llvm.type.typecast(r, ir.IntType(64), builder)
            cond = builder.icmp_signed(">=", l, r)
            result = builder.select(cond, ir.IntType(1)(1), ir.IntType(1)(0))
            return _store_as(result, d, blk, builder)
        case ida_hexrays.m_setl:  # 0x28,  setl  l,  r, d=byte  SF!=OF   Less
            l = ida2llvm.type.typecast(l, ir.IntType(64), builder)
            r = ida2llvm.type.typecast(r, ir.IntType(64), builder)
            cond = builder.icmp_signed("<", l, r)
            result = builder.select(cond, ir.IntType(1)(1), ir.IntType(1)(0))
            return _store_as(result, d, blk, builder)
        case ida_hexrays.m_setle:  # 0x29,  setle l,  r, d=byte  SF!=OF | ZF=1 Less or Equal
            l = ida2llvm.type.typecast(l, ir.IntType(64), builder)
            r = ida2llvm.type.typecast(r, ir.IntType(64), builder)
            cond = builder.icmp_signed("<=", l, r)
            result = builder.select(cond, ir.IntType(1)(1), ir.IntType(1)(0))
            return _store_as(result, d, blk, builder)
        case ida_hexrays.m_jcnd:  # 0x2A,  jcnd   l,    d   d is mop_v or mop_b
            return builder.cbranch(l, d, next_blk)
        case ida_hexrays.m_jnz:  # 0x2B,  jnz    l, r, d   ZF=0Not Equal *F
            l = ida2llvm.type.typecast(l, ir.IntType(64), builder)
            r = ida2llvm.type.typecast(r, ir.IntType(64), builder)
            cond = builder.icmp_unsigned("!=", l, r)
            return builder.cbranch(cond, d, next_blk)
        case ida_hexrays.m_jz:  # 0x2C,  jzl, r, d   ZF=1Equal*F
            l = ida2llvm.type.typecast(l, ir.IntType(64), builder)
            r = ida2llvm.type.typecast(r, ir.IntType(64), builder)
            cond = builder.icmp_unsigned("==", l, r)
            return builder.cbranch(cond, d, next_blk)
        case ida_hexrays.m_jae:  # 0x2D,  jae    l, r, d   CF=0Above or Equal *F
            l = ida2llvm.type.typecast(l, ir.IntType(64), builder)
            r = ida2llvm.type.typecast(r, ir.IntType(64), builder)
            cond = builder.icmp_unsigned(">=", l, r)
            return builder.cbranch(cond, d, next_blk)
        case ida_hexrays.m_jb:  # 0x2E,  jbl, r, d   CF=1Below*F
            l = ida2llvm.type.typecast(l, ir.IntType(64), builder)
            r = ida2llvm.type.typecast(r, ir.IntType(64), builder)
            cond = builder.icmp_unsigned("<", l, r)
            return builder.cbranch(cond, d, next_blk)
        case ida_hexrays.m_ja:  # 0x2F,  jal, r, d   CF=0 & ZF=0   Above*F
            l = ida2llvm.type.typecast(l, ir.IntType(64), builder)
            r = ida2llvm.type.typecast(r, ir.IntType(64), builder)
            cond = builder.icmp_unsigned(">", l, r)
            return builder.cbranch(cond, d, next_blk)
        case ida_hexrays.m_jbe:  # 0x30,  jbe    l, r, d   CF=1 | ZF=1   Below or Equal *F
            l = ida2llvm.type.typecast(l, ir.IntType(64), builder)
            r = ida2llvm.type.typecast(r, ir.IntType(64), builder)
            cond = builder.icmp_unsigned("<=", l, r)
            return builder.cbranch(cond, d, next_blk)
        case ida_hexrays.m_jg:  # 0x31,  jgl, r, d   SF=OF & ZF=0  Greater
            l = ida2llvm.type.typecast(l, ir.IntType(64), builder)
            r = ida2llvm.type.typecast(r, ir.IntType(64), builder)
            cond = builder.icmp_signed(">", l, r)
            return builder.cbranch(cond, d, next_blk)
        case ida_hexrays.m_jge:  # 0x32,  jge    l, r, d   SF=OF    Greater or Equal
            l = ida2llvm.type.typecast(l, ir.IntType(64), builder)
            r = ida2llvm.type.typecast(r, ir.IntType(64), builder)
            cond = builder.icmp_signed(">=", l, r)
            return builder.cbranch(cond, d, next_blk)
        case ida_hexrays.m_jl:  # 0x33,  jll, r, d   SF!=OF   Less
            l = ida2llvm.type.typecast(l, ir.IntType(64), builder)
            r = ida2llvm.type.typecast(r, ir.IntType(64), builder)
            cond = builder.icmp_signed("<", l, r)
            return builder.cbranch(cond, d, next_blk)
        case ida_hexrays.m_jle:  # 0x34,  jle    l, r, d   SF!=OF | ZF=1 Less or Equal
            l = ida2llvm.type.typecast(l, ir.IntType(64), builder)
            r = ida2llvm.type.typecast(r, ir.IntType(64), builder)
            cond = builder.icmp_signed("<=", l, r)
            return builder.cbranch(cond, d, next_blk)
        case ida_hexrays.m_jtbl:  # 0x35,  jtbl   l, r=mcases    Table jump
            # Switch statement - l is the index, r contains the jump table cases
            mcases = ida_insn.r.c
            cases = []
            default_block = next_blk  # fallthrough as default
            
            for i in range(mcases.size()):
                case_val = mcases.at(i).first  # case value
                case_blk_num = mcases.at(i).second  # target block number
                case_blk = blk.parent.blocks[case_blk_num]
                cases.append((ir.Constant(l.type, case_val), case_blk))
            
            return builder.switch(l, default_block, cases)
        case ida_hexrays.m_ijmp:  # 0x36,  ijmp  {r=sel, d=off}  indirect unconditional jump
            # Indirect jump - convert pointer to integer and use indirectbr
            # This is conservative; we collect all possible destinations from CFG
            if isinstance(d, ir.Block):
                # If destination is known, use direct branch
                return builder.branch(d)
            else:
                # For truly indirect jumps, we need to use indirectbr
                # Collect all possible basic blocks as destinations
                possible_blocks = [b for b in blk.parent.blocks if b != blk]
                if possible_blocks:
                    return builder.indirectbr(d, possible_blocks)
                else:
                    # No valid targets, this is likely unreachable code
                    return builder.unreachable()
        case ida_hexrays.m_goto:  # 0x37,  goto   l    l is mop_v or mop_b
            return builder.branch(l)
        case ida_hexrays.m_call:  # 0x38,  call   ld   l is mop_v or mop_b or mop_h
            rets, args = d
            for (i, llvmtype) in enumerate(l.type.pointee.args):
                args[i] = ida2llvm.type.typecast(args[i], llvmtype, builder)
            
            if l.type.pointee.var_arg: # function is variadic
                function = blk.parent
                if "ArgList" in function.lvars:
                    logger.warning("nested variadic function detected, variadic arguments will not be passed properly")
                ltype = l.type.pointee
                newargs = list(ltype.args)
                for i in range(len(newargs), len(args)):
                    newargs.append(args[i].type)
                new_func_type = ir.FunctionType(ltype.return_type, newargs, var_arg=True).as_pointer()
                # l = ida2llvm.type.typecast(l, new_func_type, builder)
            logger.debug(f"lifting call: {l.type} {d}")
            ret = builder.call(l, args)
            for dst in rets:
                _store_as(ret, dst, blk, builder) 
            return ret
        case ida_hexrays.m_icall:  # 0x39,  icall  {l=sel, r=off} d    indirect call
            ftype = ir.FunctionType(ir.IntType(8).as_pointer(), (arg.type for arg in d))
            f = ida2llvm.type.typecast(r, ftype.as_pointer(), builder)
            return builder.call(f, d)
        case ida_hexrays.m_ret:  # 0x3A,  ret
            # Return instruction - store return value and branch to exit block
            func = blk.parent
            if l is not None and not isinstance(func.function_type.return_type, ir.VoidType):
                if "result" in func.lvars:
                    _store_as(l, func.lvars["result"], blk, builder)
            return builder.branch(func.blocks[-1])
        case ida_hexrays.m_push:  # 0x3B,  push   l
            pass
        case ida_hexrays.m_pop:  # 0x3C,  popd
            pass
        case ida_hexrays.m_und:  # 0x3D,  undd   undefine
            pass
        case ida_hexrays.m_ext:  # 0x3E,  ext  in1, in2,  out1  external insn, not microcode *F
            pass
        case ida_hexrays.m_f2i:  # 0x3F,  f2il,    d int(l) => d; convert fp -> integer   +F
            assert isinstance(l.type, (ir.FloatType, ir.DoubleType))
            target_type = ida2llvm.type.lift_tif(ida_insn.d.type) if hasattr(ida_insn.d, 'type') else ir.IntType(64)
            math = builder.fptosi(l, target_type)
            return _store_as(math, d, blk, builder)
        case ida_hexrays.m_f2u:  # 0x40,  f2ul,    d uint(l)=> d; convert fp -> uinteger  +F
            assert isinstance(l.type, (ir.FloatType, ir.DoubleType))
            target_type = ida2llvm.type.lift_tif(ida_insn.d.type) if hasattr(ida_insn.d, 'type') else ir.IntType(64)
            math = builder.fptoui(l, target_type)
            return _store_as(math, d, blk, builder)
        case ida_hexrays.m_i2f:  # 0x41,  i2fl,    d fp(l)  => d; convert integer -> fp e +F
            assert isinstance(l.type, ir.IntType)
            target_type = ida2llvm.type.lift_tif(ida_insn.d.type) if hasattr(ida_insn.d, 'type') else ir.DoubleType()
            math = builder.sitofp(l, target_type)
            return _store_as(math, d, blk, builder)
        case ida_hexrays.m_u2f:  # 0x42,  i2fl,    d fp(l)  => d; convert uinteger -> fp  +F
            assert isinstance(l.type, ir.IntType)
            target_type = ida2llvm.type.lift_tif(ida_insn.d.type) if hasattr(ida_insn.d, 'type') else ir.DoubleType()
            math = builder.uitofp(l, target_type)
            return _store_as(math, d, blk, builder)
        case ida_hexrays.m_f2f:  # 0x43,  f2fl,    d l => d; change fp precision+F
            assert isinstance(l.type, (ir.FloatType, ir.DoubleType))
            target_type = ida2llvm.type.lift_tif(ida_insn.d.type) if hasattr(ida_insn.d, 'type') else ir.DoubleType()
            if isinstance(target_type, (ir.FloatType, ir.DoubleType)):
                if l.type.width < target_type.width:
                    math = builder.fpext(l, target_type)
                elif l.type.width > target_type.width:
                    math = builder.fptrunc(l, target_type)
                else:
                    math = l
                return _store_as(math, d, blk, builder)
            return _store_as(l, d, blk, builder)
        case ida_hexrays.m_fneg:  # 0x44,  fneg    l,    d -l=> d; change sign   +F
            math = builder.fneg(l)
            return _store_as(math, d, blk, builder)
        case ida_hexrays.m_fadd:  # 0x45,  fadd    l, r, d l + r  => d; add +F
            assert l.isfloat() and r.isfloat()
            math = builder.fadd(l, r)
            return _store_as(math, d, blk, builder)
        case ida_hexrays.m_fsub:  # 0x46,  fsub    l, r, d l - r  => d; subtract +F
            assert l.isfloat() and r.isfloat()
            math = builder.fsub(l, r)
            return _store_as(math, d, blk, builder)
        case ida_hexrays.m_fmul:  # 0x47,  fmul    l, r, d l * r  => d; multiply +F
            assert l.isfloat() and r.isfloat()
            math = builder.fmul(l, r)
            return _store_as(math, d, blk, builder)
        case ida_hexrays.m_fdiv:  # 0x48,  fdiv    l, r, d l / r  => d; divide   +F
            assert l.isfloat() and r.isfloat()
            math = builder.fdiv(l, r)
            return _store_as(math, d, blk, builder)
    raise NotImplementedError(f"not implemented {ida_insn.dstr()}")
```

`ida2llvm/syscall.py`:

```py
"""
Syscall interop module for IDA2LLVM
Provides syscall detection and annotation across multiple architectures and operating systems.
"""

import ida_idaapi
import ida_allins
import ida_ua
import logging
from llvmlite import ir

logger = logging.getLogger(__name__)

# Linux x86_64 syscall table (partial - common syscalls)
LINUX_X86_64_SYSCALLS = {
    0: "read", 1: "write", 2: "open", 3: "close", 4: "stat", 5: "fstat",
    6: "lstat", 7: "poll", 8: "lseek", 9: "mmap", 10: "mprotect", 11: "munmap",
    12: "brk", 13: "rt_sigaction", 14: "rt_sigprocmask", 15: "rt_sigreturn",
    16: "ioctl", 17: "pread64", 18: "pwrite64", 19: "readv", 20: "writev",
    21: "access", 22: "pipe", 23: "select", 24: "sched_yield", 25: "mremap",
    26: "msync", 27: "mincore", 28: "madvise", 29: "shmget", 30: "shmat",
    31: "shmctl", 32: "dup", 33: "dup2", 34: "pause", 35: "nanosleep",
    36: "getitimer", 37: "alarm", 38: "setitimer", 39: "getpid", 40: "sendfile",
    41: "socket", 42: "connect", 43: "accept", 44: "sendto", 45: "recvfrom",
    46: "sendmsg", 47: "recvmsg", 48: "shutdown", 49: "bind", 50: "listen",
    51: "getsockname", 52: "getpeername", 53: "socketpair", 54: "setsockopt",
    55: "getsockopt", 56: "clone", 57: "fork", 58: "vfork", 59: "execve",
    60: "exit", 61: "wait4", 62: "kill", 63: "uname", 64: "semget",
    65: "semop", 66: "semctl", 67: "shmdt", 68: "msgget", 69: "msgsnd",
    70: "msgrcv", 71: "msgctl", 72: "fcntl", 73: "flock", 74: "fsync",
    75: "fdatasync", 76: "truncate", 77: "ftruncate", 78: "getdents",
    79: "getcwd", 80: "chdir", 81: "fchdir", 82: "rename", 83: "mkdir",
    84: "rmdir", 85: "creat", 86: "link", 87: "unlink", 88: "symlink",
    89: "readlink", 90: "chmod", 91: "fchmod", 92: "chown", 93: "fchown",
    94: "lchown", 95: "umask", 96: "gettimeofday", 97: "getrlimit",
    98: "getrusage", 99: "sysinfo", 100: "times", 101: "ptrace", 102: "getuid",
    103: "syslog", 104: "getgid", 105: "setuid", 106: "setgid", 107: "geteuid",
    108: "getegid", 109: "setpgid", 110: "getppid", 111: "getpgrp",
    112: "setsid", 113: "setreuid", 114: "setregid", 115: "getgroups",
    116: "setgroups", 117: "setresuid", 118: "getresuid", 119: "setresgid",
    120: "getresgid", 121: "getpgid", 122: "setfsuid", 123: "setfsgid",
    124: "getsid", 125: "capget", 126: "capset", 127: "rt_sigpending",
    128: "rt_sigtimedwait", 129: "rt_sigqueueinfo", 130: "rt_sigsuspend",
    131: "sigaltstack", 132: "utime", 133: "mknod", 134: "uselib",
    135: "personality", 136: "ustat", 137: "statfs", 138: "fstatfs",
    139: "sysfs", 140: "getpriority", 141: "setpriority", 142: "sched_setparam",
    143: "sched_getparam", 144: "sched_setscheduler", 145: "sched_getscheduler",
    146: "sched_get_priority_max", 147: "sched_get_priority_min",
    148: "sched_rr_get_interval", 149: "mlock", 150: "munlock",
}

# Linux x86 (32-bit) syscall table (partial)
LINUX_X86_SYSCALLS = {
    1: "exit", 2: "fork", 3: "read", 4: "write", 5: "open", 6: "close",
    7: "waitpid", 8: "creat", 9: "link", 10: "unlink", 11: "execve",
    12: "chdir", 13: "time", 14: "mknod", 15: "chmod", 16: "lchown",
    19: "lseek", 20: "getpid", 21: "mount", 22: "umount", 23: "setuid",
    24: "getuid", 25: "stime", 26: "ptrace", 27: "alarm", 29: "pause",
    30: "utime", 33: "access", 34: "nice", 36: "sync", 37: "kill",
    38: "rename", 39: "mkdir", 40: "rmdir", 41: "dup", 42: "pipe",
    43: "times", 45: "brk", 46: "setgid", 47: "getgid", 48: "signal",
    49: "geteuid", 50: "getegid", 51: "acct", 52: "umount2", 54: "ioctl",
    55: "fcntl", 57: "setpgid", 60: "umask", 61: "chroot", 62: "ustat",
    63: "dup2", 64: "getppid", 65: "getpgrp", 66: "setsid", 67: "sigaction",
}

# ARM/AArch64 Linux syscall table (partial)
ARM_LINUX_SYSCALLS = {
    0: "io_setup", 1: "io_destroy", 2: "io_submit", 3: "io_cancel",
    4: "io_getevents", 5: "setxattr", 6: "lsetxattr", 7: "fsetxattr",
    8: "getxattr", 9: "lgetxattr", 10: "fgetxattr", 11: "listxattr",
    12: "llistxattr", 13: "flistxattr", 14: "removexattr", 15: "lremovexattr",
    16: "fremovexattr", 17: "getcwd", 18: "lookup_dcookie", 19: "eventfd2",
    20: "epoll_create1", 21: "epoll_ctl", 22: "epoll_pwait", 23: "dup",
    24: "dup3", 25: "fcntl", 26: "inotify_init1", 27: "inotify_add_watch",
    28: "inotify_rm_watch", 29: "ioctl", 30: "ioprio_set", 31: "ioprio_get",
    32: "flock", 33: "mknodat", 34: "mkdirat", 35: "unlinkat", 36: "symlinkat",
    37: "linkat", 38: "renameat", 39: "umount2", 40: "mount", 41: "pivot_root",
    42: "nfsservctl", 43: "statfs", 44: "fstatfs", 45: "truncate",
    46: "ftruncate", 47: "fallocate", 48: "faccessat", 49: "chdir",
    50: "fchdir", 51: "chroot", 52: "fchmod", 53: "fchmodat", 54: "fchownat",
    55: "fchown", 56: "openat", 57: "close", 58: "vhangup", 59: "pipe2",
    60: "quotactl", 61: "getdents64", 62: "lseek", 63: "read", 64: "write",
    65: "readv", 66: "writev", 67: "pread64", 68: "pwrite64", 69: "preadv",
    70: "pwritev", 71: "sendfile", 72: "pselect6", 73: "ppoll", 74: "signalfd4",
    75: "vmsplice", 76: "splice", 77: "tee", 78: "readlinkat", 79: "fstatat",
    80: "fstat", 81: "sync", 82: "fsync", 83: "fdatasync", 84: "sync_file_range",
}

# Windows NT syscalls (x64) - partial
WINDOWS_X64_SYSCALLS = {
    0x00: "NtAccessCheck", 0x01: "NtWorkerFactoryWorkerReady",
    0x02: "NtAcceptConnectPort", 0x03: "NtMapUserPhysicalPagesScatter",
    0x04: "NtWaitForSingleObject", 0x05: "NtCallbackReturn",
    0x06: "NtReadFile", 0x07: "NtDeviceIoControlFile",
    0x08: "NtWriteFile", 0x09: "NtRemoveIoCompletion",
    0x0A: "NtReleaseSemaphore", 0x0B: "NtReplyWaitReplyPort",
    0x0C: "NtReplyPort", 0x0D: "NtSetInformationThread",
    0x0E: "NtSetEvent", 0x0F: "NtClose", 0x10: "NtQueryObject",
    0x11: "NtQueryInformationToken", 0x12: "NtOpenThreadTokenEx",
    0x13: "NtOpenProcessTokenEx", 0x14: "NtOpenThread",
    0x15: "NtOpenProcess", 0x16: "NtResumeThread", 0x17: "NtSuspendThread",
    0x18: "NtTerminateProcess", 0x19: "NtTerminateThread",
    0x1A: "NtCreateFile", 0x1B: "NtAllocateVirtualMemory",
    0x1C: "NtFreeVirtualMemory", 0x1D: "NtDuplicateObject",
    0x1E: "NtQueryInformationProcess", 0x1F: "NtWaitForMultipleObjects",
}

# WASI (WebAssembly System Interface) syscalls
WASI_SYSCALLS = {
    0: "args_get", 1: "args_sizes_get", 2: "environ_get", 3: "environ_sizes_get",
    4: "clock_res_get", 5: "clock_time_get", 6: "fd_advise", 7: "fd_allocate",
    8: "fd_close", 9: "fd_datasync", 10: "fd_fdstat_get", 11: "fd_fdstat_set_flags",
    12: "fd_fdstat_set_rights", 13: "fd_filestat_get", 14: "fd_filestat_set_size",
    15: "fd_filestat_set_times", 16: "fd_pread", 17: "fd_prestat_get",
    18: "fd_prestat_dir_name", 19: "fd_pwrite", 20: "fd_read", 21: "fd_readdir",
    22: "fd_renumber", 23: "fd_seek", 24: "fd_sync", 25: "fd_tell",
    26: "fd_write", 27: "path_create_directory", 28: "path_filestat_get",
    29: "path_filestat_set_times", 30: "path_link", 31: "path_open",
    32: "path_readlink", 33: "path_remove_directory", 34: "path_rename",
    35: "path_symlink", 36: "path_unlink_file", 37: "poll_oneoff",
    38: "proc_exit", 39: "proc_raise", 40: "sched_yield", 41: "random_get",
    42: "sock_recv", 43: "sock_send", 44: "sock_shutdown",
}


def get_architecture():
    """
    Determine the current binary architecture.
    
    :return: Architecture string (x86, x64, arm, arm64, wasm)
    :rtype: str
    """
    procname = ida_idaapi.inf_get_procname()
    
    if procname.startswith("ARM") or procname.startswith("metapc"):
        if ida_idaapi.inf_is_64bit():
            if "ARM" in procname:
                return "arm64"
            return "x64"
        else:
            if "ARM" in procname:
                return "arm"
            return "x86"
    elif procname == "wasm":
        return "wasm"
    return "unknown"


def get_os_type():
    """
    Heuristically determine the OS type of the binary.
    
    :return: OS string (linux, windows, wasi, unknown)
    :rtype: str
    """
    import ida_nalt
    
    filetype = ida_idaapi.inf_get_filetype()
    
    # Check file type
    if filetype == ida_idaapi.f_ELF:
        return "linux"
    elif filetype == ida_idaapi.f_PE:
        return "windows"
    elif filetype == ida_idaapi.f_LOADER:
        # Could be WASM or other
        if get_architecture() == "wasm":
            return "wasi"
    
    return "unknown"


def get_syscall_name(syscall_number: int, arch: str = None, os_type: str = None) -> str:
    """
    Get the syscall name given its number, architecture, and OS.
    
    :param syscall_number: The syscall number
    :type syscall_number: int
    :param arch: Architecture (x86, x64, arm, arm64, wasm), defaults to auto-detect
    :type arch: str, optional
    :param os_type: OS type (linux, windows, wasi), defaults to auto-detect
    :type os_type: str, optional
    :return: Syscall name or "syscall_{number}" if unknown
    :rtype: str
    """
    if arch is None:
        arch = get_architecture()
    if os_type is None:
        os_type = get_os_type()
    
    syscall_table = None
    
    # Select appropriate syscall table
    if os_type == "linux":
        if arch == "x64":
            syscall_table = LINUX_X86_64_SYSCALLS
        elif arch == "x86":
            syscall_table = LINUX_X86_SYSCALLS
        elif arch in ["arm", "arm64"]:
            syscall_table = ARM_LINUX_SYSCALLS
    elif os_type == "windows":
        if arch == "x64":
            syscall_table = WINDOWS_X64_SYSCALLS
    elif os_type == "wasi":
        syscall_table = WASI_SYSCALLS
    
    if syscall_table and syscall_number in syscall_table:
        return syscall_table[syscall_number]
    
    return f"syscall_{syscall_number}"


def is_syscall_instruction(ea: int) -> bool:
    """
    Check if the instruction at the given address is a syscall instruction.
    
    :param ea: Effective address
    :type ea: int
    :return: True if it's a syscall instruction
    :rtype: bool
    """
    insn = ida_ua.insn_t()
    if ida_ua.decode_insn(insn, ea) == 0:
        return False
    
    # Check for various syscall instructions
    arch = get_architecture()
    
    if arch in ["x86", "x64"]:
        # syscall, sysenter, int 0x80
        if insn.itype in [ida_allins.NN_syscall, ida_allins.NN_sysenter]:
            return True
        if insn.itype == ida_allins.NN_int and insn.Op1.value == 0x80:
            return True
    elif arch in ["arm", "arm64"]:
        # svc (supervisor call)
        if insn.itype == ida_allins.ARM_svc:
            return True
    
    return False


def inject_syscall_annotation(module: ir.Module, builder: ir.IRBuilder, 
                               syscall_name: str, syscall_number: int, 
                               args: list = None) -> ir.Value:
    """
    Inject a syscall annotation into the LLVM IR.
    This creates a call to a printf-style annotation function.
    
    :param module: LLVM module
    :type module: ir.Module
    :param builder: IR builder
    :type builder: ir.IRBuilder
    :param syscall_name: Name of the syscall
    :type syscall_name: str
    :param syscall_number: Syscall number
    :type syscall_number: int
    :param args: Optional syscall arguments to log
    :type args: list, optional
    :return: Annotation value
    :rtype: ir.Value
    """
    # Create or get the syscall_trace function
    i8ptr = ir.IntType(8).as_pointer()
    
    try:
        trace_func = module.get_global("syscall_trace")
    except KeyError:
        # Create syscall_trace function (external declaration)
        trace_func_type = ir.FunctionType(ir.VoidType(), [i8ptr, ir.IntType(64)], var_arg=True)
        trace_func = ir.Function(module, trace_func_type, "syscall_trace")
    
    # Create format string
    format_str = f"SYSCALL: {syscall_name} (#{syscall_number})\\n"
    str_type = ir.ArrayType(ir.IntType(8), len(format_str) + 1)
    str_constant = ir.Constant(str_type, bytearray(format_str.encode("utf-8") + b'\0'))
    
    str_global = ir.GlobalVariable(module, str_type, 
                                   name=f".syscall_str_{syscall_number}")
    str_global.initializer = str_constant
    str_global.linkage = "private"
    str_global.global_constant = True
    
    # Cast to i8*
    str_ptr = builder.bitcast(str_global, i8ptr)
    
    # Call trace function
    trace_args = [str_ptr, ir.Constant(ir.IntType(64), syscall_number)]
    if args:
        trace_args.extend(args[:6])  # Limit to first 6 arguments
    
    return builder.call(trace_func, trace_args)


def create_syscall_helper(module: ir.Module, syscall_name: str, 
                          syscall_number: int, arch: str = None) -> ir.Function:
    """
    Create a helper function that wraps a syscall.
    
    :param module: LLVM module
    :type module: ir.Module
    :param syscall_name: Name of the syscall
    :type syscall_name: str
    :param syscall_number: Syscall number
    :type syscall_number: int
    :param arch: Architecture (for calling convention)
    :type arch: str, optional
    :return: LLVM function wrapping the syscall
    :rtype: ir.Function
    """
    if arch is None:
        arch = get_architecture()
    
    # Create a generic syscall wrapper with variadic arguments
    func_type = ir.FunctionType(ir.IntType(64), [], var_arg=True)
    func = ir.Function(module, func_type, f"sys_{syscall_name}")
    
    # Add comment/metadata
    func.attributes.add("comment", f"Syscall {syscall_name} (#{syscall_number})")
    
    return func


```

`ida2llvm/type.py`:

```py
import ida_typeinf
import ida_ida
import ida_idaapi
import logging

from llvmlite import ir

logger = logging.getLogger(__name__)

def lift_tif(tif: ida_typeinf.tinfo_t) -> ir.Type:
    """
    Lifts the given IDA type to corresponding LLVM type.
    If IDA type is an array/struct/tif, type lifting is performed recursively.

    :param tif: the type to lift, in IDA
    :type tif: ida_typeinf.tinfo_t
    :raises NotImplementedError: variadic structs
    :return: lifted LLVM type
    :rtype: ir.Type
    """
    match tif:
        case tif if tif.is_func():
            # a function type is composed of:
            ## return type, argument types, variadic
            ida_rettype = tif.get_rettype()
            ida_args = (tif.get_nth_arg(i) for i in range(tif.get_nargs()))
            is_vararg = tif.is_vararg_cc()

            llvm_rettype = lift_tif(ida_rettype)
            llvm_args = (lift_tif(arg) for arg in ida_args)
            return ir.FunctionType(llvm_rettype, llvm_args, var_arg = is_vararg)

        case tif if tif.is_ptr():
            child_tif = tif.get_ptrarr_object()

            # clang compiles C void * to LLVM IR i8*
            if child_tif.is_void():
                return ir.IntType(8).as_pointer()

            return lift_tif(child_tif).as_pointer()

        case tif if tif.is_array():
            child_tif = tif.get_ptrarr_object()
            element = lift_tif(child_tif)

            count = tif.get_array_nelems()
            if count == 0:
                # an array with an indeterminate number of elements = type pointer
                tif.convert_array_to_ptr()
                return lift_tif(tif)

            return ir.ArrayType(element, count)

        case tif if tif.is_void():
            return ir.VoidType()

        case tif if tif.is_udt():
            udt_data = ida_typeinf.udt_type_data_t()
            tif.get_udt_details(udt_data)
            type_name = tif.get_type_name()
            context = ir.context.global_context

            if type_name not in context.identified_types:
                struct_t = context.get_identified_type(type_name)
                elementTypes = []
                for idx in range(udt_data.size()):
                    udt_member = udt_data.at(idx)
                    element = lift_tif(udt_member.type)
                    elementTypes.append(element)
                if tif.is_varstruct():
                    raise NotImplementedError(f"variadic structs not implemented: {tif}")
                struct_t.set_body(*elementTypes)
            return context.get_identified_type(type_name)

        case tif if tif.is_bool():
            return ir.IntType(1)

        case tif if tif.is_float():
            return ir.FloatType()

        case tif if tif.is_double():
            return ir.DoubleType()

        case _:
            byte_size = tif.get_size()
            # naieve assumption that system is either 32 bit or 64 bit
            bitness = 32
            if ida_ida.inf_is_64bit():
                bitness = 64
            if byte_size == (1 << bitness) - 1:
                byte_size = 1
            return ir.IntType(byte_size * 8)

def typecast(src: ir.Value, dst_type: ir.Type, builder: ir.IRBuilder, signed: bool = False) -> ir.Value:
    """
    Given some `src`, convert it to type `dst_type`.
    Instructions are emitted into `builder`.

    :param src: value to convert
    :type src: ir.Value
    :param dst_type: destination type
    :type dst_type: ir.Type
    :param builder: builds instructions
    :type builder: ir.IRBuilder
    :param signed: whether to preserve signness, defaults to True
    :type signed: bool, optional
    :raises NotImplementedError: type conversion not supported
    :return: value after typecast
    :rtype: ir.Value   
    """
    if src.type != dst_type:
        match (src, dst_type):
            case (src, dst_type) if isinstance(src.type, ir.PointerType) and isinstance(dst_type, ir.PointerType):
                return builder.bitcast(src, dst_type)
            case (src, dst_type) if isinstance(src.type, ir.PointerType) and isinstance(dst_type, ir.IntType):
                return builder.ptrtoint(src, dst_type)
            case (src, dst_type) if isinstance(src.type, ir.IntType) and isinstance(dst_type, ir.PointerType):
                return builder.inttoptr(src, dst_type)

            case (src, dst_type) if isinstance(src.type, ir.IntType) and isinstance(dst_type, ir.FloatType):
                return builder.uitofp(src, dst_type)
            case (src, dst_type) if isinstance(src.type, ir.FloatType) and isinstance(dst_type, ir.IntType):
                return builder.fptoui(src, dst_type)
            case (src, dst_type) if isinstance(src.type, ir.FloatType) and isinstance(dst_type, ir.FloatType):
                return src

            case (src, dst_type) if isinstance(src.type, ir.IntType) and isinstance(dst_type, ir.IntType) and src.type.width < dst_type.width:
                if signed:
                    return builder.sext(src, dst_type)
                else:
                    return builder.zext(src, dst_type)
            case (src, dst_type) if isinstance(src.type, ir.IntType) and isinstance(dst_type, ir.IntType) and src.type.width > dst_type.width:
                return builder.trunc(src, dst_type)
            case _:
                raise NotImplementedError(f"cannot convert {src} of type {src.type} into {dst_type}")
    return src
```

`ida2llvm_plugin.py`:

```py
import ida_idaapi
import ida_kernwin
import idautils
import ida_name
import ida_funcs
import ida_segment

from PySide6 import QtCore, QtWidgets
from PySide6.QtGui import QSyntaxHighlighter, QTextCharFormat, QColor, QFont

class LLVMSyntaxHighlighter(QSyntaxHighlighter):
    """
    Syntax highlighter for LLVM IR.
    """
    def __init__(self, document):
        super().__init__(document)
        
        # Define formats
        self.keyword_format = QTextCharFormat()
        self.keyword_format.setForeground(QColor(0, 0, 255))  # Blue
        self.keyword_format.setFontWeight(QFont.Weight.Bold)
        
        self.type_format = QTextCharFormat()
        self.type_format.setForeground(QColor(0, 128, 128))  # Teal
        
        self.function_format = QTextCharFormat()
        self.function_format.setForeground(QColor(128, 0, 128))  # Purple
        self.function_format.setFontWeight(QFont.Weight.Bold)
        
        self.comment_format = QTextCharFormat()
        self.comment_format.setForeground(QColor(0, 128, 0))  # Green
        self.comment_format.setFontItalic(True)
        
        self.string_format = QTextCharFormat()
        self.string_format.setForeground(QColor(163, 21, 21))  # Dark red
        
        self.number_format = QTextCharFormat()
        self.number_format.setForeground(QColor(255, 127, 0))  # Orange
        
        self.label_format = QTextCharFormat()
        self.label_format.setForeground(QColor(139, 69, 19))  # Brown
        self.label_format.setFontWeight(QFont.Weight.Bold)
        
        # LLVM keywords
        self.keywords = [
            'define', 'declare', 'target', 'datalayout', 'triple', 'ret', 'br',
            'switch', 'indirectbr', 'invoke', 'resume', 'unreachable', 'add',
            'fadd', 'sub', 'fsub', 'mul', 'fmul', 'udiv', 'sdiv', 'fdiv',
            'urem', 'srem', 'frem', 'shl', 'lshr', 'ashr', 'and', 'or', 'xor',
            'alloca', 'load', 'store', 'getelementptr', 'inbounds', 'trunc',
            'zext', 'sext', 'fptrunc', 'fpext', 'fptoui', 'fptosi', 'uitofp',
            'sitofp', 'ptrtoint', 'inttoptr', 'bitcast', 'addrspacecast',
            'icmp', 'fcmp', 'phi', 'select', 'call', 'va_arg', 'landingpad',
            'catchpad', 'cleanuppad', 'eq', 'ne', 'ugt', 'uge', 'ult', 'ule',
            'sgt', 'sge', 'slt', 'sle', 'oeq', 'ogt', 'oge', 'olt', 'ole',
            'one', 'ord', 'ueq', 'une', 'uno', 'to', 'nuw', 'nsw', 'exact',
            'volatile', 'atomic', 'unordered', 'monotonic', 'acquire', 'release',
            'acq_rel', 'seq_cst', 'private', 'internal', 'external', 'weak',
            'linkonce', 'common', 'appending', 'extern_weak', 'linkonce_odr',
            'weak_odr', 'dllimport', 'dllexport', 'align', 'gc', 'null',
            'undef', 'true', 'false', 'global', 'constant', 'entry'
        ]
        
        # LLVM types
        self.types = [
            'void', 'i1', 'i8', 'i16', 'i32', 'i64', 'i128',
            'float', 'double', 'x86_fp80', 'fp128', 'ppc_fp128',
            'label', 'metadata', 'type', 'opaque'
        ]
    
    def highlightBlock(self, text):
        # Highlight keywords
        for keyword in self.keywords:
            import re
            pattern = r'\b' + keyword + r'\b'
            for match in re.finditer(pattern, text):
                self.setFormat(match.start(), match.end() - match.start(), 
                              self.keyword_format)
        
        # Highlight types
        for type_word in self.types:
            import re
            pattern = r'\b' + type_word + r'\b'
            for match in re.finditer(pattern, text):
                self.setFormat(match.start(), match.end() - match.start(),
                              self.type_format)
        
        # Highlight type patterns (i8*, [100 x i32], etc.)
        import re
        type_patterns = [
            r'i\d+\*?',
            r'\[\d+ x [^\]]+\]',
            r'<\d+ x [^>]+>',
        ]
        for pattern in type_patterns:
            for match in re.finditer(pattern, text):
                self.setFormat(match.start(), match.end() - match.start(),
                              self.type_format)
        
        # Highlight comments
        import re
        comment_pattern = r';[^\n]*'
        for match in re.finditer(comment_pattern, text):
            self.setFormat(match.start(), match.end() - match.start(),
                          self.comment_format)
        
        # Highlight strings
        import re
        string_pattern = r'"[^"\\]*(\\.[^"\\]*)*"'
        for match in re.finditer(string_pattern, text):
            self.setFormat(match.start(), match.end() - match.start(),
                          self.string_format)
        
        # Highlight numbers
        import re
        number_pattern = r'\b-?\d+\.?\d*\b'
        for match in re.finditer(number_pattern, text):
            self.setFormat(match.start(), match.end() - match.start(),
                          self.number_format)
        
        # Highlight labels
        import re
        label_pattern = r'^\s*\w+:'
        for match in re.finditer(label_pattern, text, re.MULTILINE):
            self.setFormat(match.start(), match.end() - match.start(),
                          self.label_format)
        
        # Highlight function definitions
        import re
        function_pattern = r'@\w+'
        for match in re.finditer(function_pattern, text):
            self.setFormat(match.start(), match.end() - match.start(),
                          self.function_format)

def PLUGIN_ENTRY():
    return IDA2LLVMPlugin()

class IDA2LLVMPlugin(ida_idaapi.plugin_t):

    flags = ida_idaapi.PLUGIN_PROC | ida_idaapi.PLUGIN_HIDE
    comment = "Microcode Lifter to LLVM"
    help = ""
    wanted_name = "IDA2LLVM"
    wanted_hotkey = ""

    def init(self):
        
        action = {
            'id': 'ida2llvm:view_lifting',
            'name': 'Lifting Viewer',
            'hotkey': 'Ctrl-Alt-L',
            'comment': 'UI for which function to lift',
            'menu_location': 'Edit/IDA2LLVM/Viewer'
        }
        if not ida_kernwin.register_action(ida_kernwin.action_desc_t(
            action['id'],
            action['name'], # The name the user sees
            IDA2LLVMController(), # The function to call
            action['hotkey'], # A shortcut, if any (optional)
            action['comment'], # A comment, if any (optional)
            -1
        )):
            print("ida2llvm: failed to register action")

        if not ida_kernwin.attach_action_to_menu(
            action['menu_location'], # The menu location
            action['id'], # The unique function ID
            0):
            print("ida2llvm: failed to attach to menu")

        return ida_idaapi.PLUGIN_KEEP

    def run(self, arg):
        ida_kernwin.warning("%s cannot be run as a script in IDA." % self.wanted_name)

    def term(self):
        pass

class IDA2LLVMController(ida_kernwin.action_handler_t):
    """
    The control component of BinaryLift Explorer.
    """
    def __init__(self):
        from llvmlite import ir
        ida_kernwin.action_handler_t.__init__(self)
        self.current_address = None
        self.cache = dict()
        self.namecache = dict()  # address -> mangled name
        self.config = dict()
        self.m = ir.Module()

        class AddressHook(ida_kernwin.UI_Hooks):
            def __init__(self, controller):
                ida_kernwin.UI_Hooks.__init__(self)
                self.controller = controller
            def database_inited(self, is_new_database, idc_script):
                self.controller.cache = dict()
                self.controller.namecache = dict()  # address -> mangled name
                self.controller.config = dict()
                self.controller.m = ir.Module()
            def screen_ea_changed(self, ea, prev_ea):
                self.controller.screen_ea = ea
                self.controller.view.refresh()
        
        self._hook = AddressHook(self)
        self._hook.hook()
        self.view = IDA2LLVMView(self)

    def activate(self, ctx):
        self.view.Show()
        return 1

    def update(self, ctx):
        return ida_kernwin.AST_ENABLE_ALWAYS

    def isScreenEaInvalid(self):
        return ida_funcs.get_func(self.screen_ea) is None

    def resolveName(self, current_address):
        func_name = ida_name.get_name(current_address)
        if func_name != self.namecache.get(current_address, None):
            print("NAME NOT SYNCED, PROBABLY CHANGED")
        self.namecache[current_address] = func_name
        return self.namecache[current_address]

    def declareCurrentFunction(self, isDeclare):
        current_name = self.resolveName(self.current_address)
        self.config[self.current_address] = bool(isDeclare)
        self.cache[self.current_address] = self.getLiftedText()
        self.view.refresh()

    def updateFunctionSelected(self, selectName):
        if selectName == "":
            return
        current_address, _ = selectName.split(":", maxsplit=1)
        self.current_address = int(current_address, 16)
        current_name = self.resolveName(self.current_address)
        ida_kernwin.jumpto(self.current_address)
        ida_kernwin.activate_widget(self.view._twidget, True)

    def insertAllFunctions(self):
        for f_ea in idautils.Functions():
            name = ida_funcs.get_func_name(f_ea)
            if (ida_funcs.get_func(f_ea).flags & ida_funcs.FUNC_LIB
                or ida_segment.segtype(f_ea) & ida_segment.SEG_XTRN
                or name.startswith("_")):
                continue
            self.insertFunctionAtEa(f_ea)

    def insertFunctionAtScreenEa(self):
        if self.isScreenEaInvalid():
            return
        self.current_address = ida_funcs.get_func(self.screen_ea).start_ea
        self.insertFunctionAtEa(self.current_address)
        self.view.refresh()

    def insertFunctionAtEa(self, ea):
        temp_ea = self.current_address
        self.current_address = ea
        current_name = self.resolveName(self.current_address)

        if self.current_address not in self.config:
            self.config[self.current_address] = False
            
        self.cache[self.current_address] = self.getLiftedText()
        self.current_address = temp_ea

    def removeFromModule(self, func_name):
        from contextlib import suppress
        from llvmlite import ir
        
        # func_name is the mangled name from IDA
        with suppress(KeyError):
            old_func = self.m.globals[func_name]
            _m = ir.Module()
            for name, gv in self.m.globals.items():
                if name != func_name:
                    gv.parent = _m
                    _m.add_global(gv)
            self.m = _m

    def getLiftedText(self):
        import ida2llvm

        func_name = self.resolveName(self.current_address)
        isDeclare = self.config[self.current_address]
        self.removeFromModule(func_name)
        llvm_f = ida2llvm.function.lift_function(self.m, func_name, isDeclare)

        for f in self.m.functions:
            f_name = f.name  # This is the mangled name from IDA
            f_ea = ida_name.get_name_ea(ida_idaapi.BADADDR, f_name)
            self.namecache[f_ea] = f_name
            self.config[f_ea] = f.is_declaration
            self.cache[f_ea] = str(f)

            # Demangle name for display only
            demangled_name, _ = ida2llvm._utils.demangle_name(f_name)
            display_name = f"{hex(f_ea)}: {demangled_name}"
            if not self.view.function_list.findItems(display_name, QtCore.Qt.MatchFlag.MatchExactly):
                self.view.function_list.addItem(display_name)

        return str(llvm_f)

    def save_to_file(self):
       filename, _ = QtWidgets.QFileDialog.getSaveFileName(None, 'Save Lifted LLVM IR', '', 'LLVM IR (*.ll)')
       if filename:
           with open(filename, 'w') as f:
               f.write(str(self.m))

class IDA2LLVMView(ida_kernwin.PluginForm):
    """
    The view component of BinaryLift Explorer.
    """
    def __init__(self, controller):
        ida_kernwin.PluginForm.__init__(self)
        self.controller = controller
        self.created = False

    def Show(self):
        return ida_kernwin.PluginForm.Show(
            self, "IDA2LLVM Viewer",
            options=(ida_kernwin.PluginForm.WOPN_PERSIST |
                     ida_kernwin.PluginForm.WCLS_SAVE |
                     ida_kernwin.PluginForm.WOPN_MENU |
                     ida_kernwin.PluginForm.WOPN_RESTORE |
                     ida_kernwin.PluginForm.WOPN_TAB))

    def refresh(self):
        if not self.created:
            return
        self.lifting_settings.setDisabled(self.function_list.currentRow() == -1)
        self.curr_ea_button.setDisabled(self.controller.isScreenEaInvalid())
        if not self.controller.isScreenEaInvalid():
            self.curr_ea_button.setText(f"{'Redefine' if ida_funcs.get_func(self.controller.screen_ea).start_ea in self.controller.config else 'Add'} function at current address ({hex(self.controller.screen_ea)})")
        if self.controller.current_address:
            self.isDeclare.setChecked(self.controller.config[self.controller.current_address])
            self.code_view.setText(self.controller.cache[self.controller.current_address])

    def create_code_view(self):
        self.code_view = QtWidgets.QTextEdit(self.widget)
        # Enable line wrapping and read-only mode
        self.code_view.setLineWrapMode(QtWidgets.QTextEdit.LineWrapMode.NoWrap)
        self.code_view.setReadOnly(True)
        # Set monospace font
        font = QFont("Courier New", 10)
        font.setStyleHint(QFont.StyleHint.Monospace)
        self.code_view.setFont(font)
        # Add syntax highlighter
        self.highlighter = LLVMSyntaxHighlighter(self.code_view.document())

    def create_function_settings(self):
        self.isDeclare = QtWidgets.QCheckBox("Keep function as declare-only")
        self.isDeclare.setChecked(False)
        self.isDeclare.stateChanged.connect(self.controller.declareCurrentFunction)
        
        self.lifting_settings = QtWidgets.QGroupBox("Lift Settings")
        layout = QtWidgets.QVBoxLayout()
        layout.addWidget(self.isDeclare)
        self.lifting_settings.setLayout(layout)

    def create_function_list(self):
        controller = self.controller
        
        # Create search box for filtering
        self.search_box = QtWidgets.QLineEdit(self.widget)
        self.search_box.setPlaceholderText("Search functions...")
        self.search_box.textChanged.connect(self.filter_function_list)
        
        class FunctionListWidget(QtWidgets.QListWidget):
            def __init__(self, parent, *args, **kwargs):
                super().__init__(parent, *args, **kwargs)
                import ida2llvm

                for address in controller.config:
                    mangled_name = controller.resolveName(address)
                    demangled_name, _ = ida2llvm._utils.demangle_name(mangled_name)
                    is_declare = controller.config[address]
                    item = QtWidgets.QListWidgetItem(f"{hex(address)}: {demangled_name}")
                    # Add icon to indicate declare vs defined
                    if is_declare:
                        item.setForeground(QColor(150, 150, 150))  # Gray for declarations
                        item.setToolTip("Declaration only")
                    else:
                        item.setForeground(QColor(0, 128, 0))  # Green for definitions
                        item.setToolTip("Fully defined")
                    self.addItem(item)
                    
            def keyPressEvent(self, event):
                if event.key() == QtCore.Qt.Key.Key_Delete:
                    row = self.currentRow()
                    item = self.takeItem(row)
                    address, demangled_name = item.text().split(": ", maxsplit=1)
                    address = int(address, 16)
                    # Get the mangled name from our cache to remove from module
                    mangled_name = controller.namecache[address]
                    controller.removeFromModule(mangled_name)
                    del controller.cache[address]
                    del controller.namecache[address]
                    del controller.config[address]
                    del item
                else:
                    super().keyPressEvent(event)
        self.function_list = FunctionListWidget(self.widget)
        self.function_list.setSortingEnabled(True)
        self.function_list.currentTextChanged.connect(self.controller.updateFunctionSelected)
        
    def filter_function_list(self, text):
        """Filter function list based on search text."""
        for i in range(self.function_list.count()):
            item = self.function_list.item(i)
            if text.lower() in item.text().lower():
                item.setHidden(False)
            else:
                item.setHidden(True)

    def OnCreate(self, form):
        self._twidget = self.GetWidget()
        self.widget = self.FormToPyQtWidget(form)
        layout = QtWidgets.QGridLayout(self.widget)

        self.curr_ea_button         = QtWidgets.QPushButton("Add function at current address", self.widget)
        self.all_functions_button   = QtWidgets.QPushButton("Add all IDA-defined functions", self.widget)
        self.lift_button            = QtWidgets.QPushButton("Lift and save to file", self.widget)
        
        # Add progress bar
        self.progress_bar = QtWidgets.QProgressBar(self.widget)
        self.progress_bar.setVisible(False)

        self.curr_ea_button.clicked.connect(self.controller.insertFunctionAtScreenEa)
        self.all_functions_button.clicked.connect(self.controller.insertAllFunctions)
        self.lift_button.clicked.connect(self.controller.save_to_file)

        self.create_code_view()
        self.create_function_settings()
        self.create_function_list()

        # arrange the widgets in a 'grid'         row  col  row span  col span
        layout.addWidget(self.code_view,            0,   0,        5,        1)
        layout.addWidget(self.search_box,           0,   1,        1,        1)
        layout.addWidget(self.function_list,        1,   1,        1,        1)
        layout.addWidget(self.lifting_settings,     2,   1,        1,        1)
        layout.addWidget(self.curr_ea_button,       3,   1,        1,        1)
        layout.addWidget(self.all_functions_button, 4,   1,        1,        1)
        layout.addWidget(self.progress_bar,         5,   1,        1,        1)
        layout.addWidget(self.lift_button,          6,   1,        1,        1)

        self.widget.setLayout(layout)
        self.created = True
        self.refresh()
```

`itadium_to_msvc.py`:

```py
#!/usr/bin/env python3
"""
itanium_to_msvc.py

Usage:
  python itanium_to_msvc.py input.ll output.ll

What it does:
  - Extracts Itanium-mangled symbols (_Z...) from the LLVM IR (input.ll).
  - Demangles them using c++filt (must be in PATH).
  - Attempts to generate an MSVC-mangled name by:
      * generating a tiny C++ stub containing a declaration matching the demangled signature
      * compiling with MSVC (cl.exe) and getting symbols via dumpbin.exe
    This step runs only if you pass --msvc (and are running on Windows with MSVC in PATH).
  - Produces:
      - output.ll where all found Itanium symbols are replaced by mapped MSVC names
      - mappings.json listing original -> demangled -> msvc_mangled (or null)
Notes:
  - Automatic MSVC mangling may fail for very complex template/ctor signatures;
    in that case the script records null for the MSVC mangled name and you can manually fill mappings.json
  - Requires c++filt (from binutils) for demangling
  - To enable MSVC remangling: run on Windows with cl.exe and dumpbin.exe on PATH and pass --msvc
"""

import re
import sys
import json
import shutil
import subprocess
import tempfile
import os
from pathlib import Path

ITANIUM_RE = re.compile(r'(_Z[\w\d_@.$]+)')

def run_cmd(cmd, **kwargs):
    return subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, **kwargs)

def demangle_with_cxxfilt(name):
    proc = run_cmd(["c++filt", name])
    if proc.returncode != 0:
        return None, proc.stderr
    return proc.stdout.strip(), None

def extract_itanium_symbols(ir_text):
    return sorted(set(ITANIUM_RE.findall(ir_text)))

def try_msvc_mangle(demangled, workdir):
    """
    Attempt to get an MSVC mangled name for demangled signature by:
      - creating a C++ source that declares an inline wrapper with the same signature,
      - compiling with cl.exe /c
      - extracting symbols with dumpbin /SYMBOLS
    This is a heuristic and may not succeed for all signatures (constructors, templates, STL internals).
    """
    # Minimal heuristic: we will wrap the demangled signature as a free function name by
    # putting it in an `extern "C++" { ... }` block if necessary.
    # IMPORTANT: Many demangled outputs are not valid C++ declarations verbatim.
    # We'll generate a simple function name alias case for common function signatures.
    # If demangled includes '::' we attempt to produce a matching definition.

    # Create candidate C++ file
    cpp_file = Path(workdir) / "stub.cpp"
    # We'll create a best-effort C++ translation unit that defines an identically-named entity.
    # We try two strategies:
    #  1) If demangled looks like "namespace::...::foo(args) [cv]" -> emit a dummy function with that qualified name.
    #  2) Otherwise create a `void __dummy()` and fail gracefully.
    src = "// generated by itanium_to_msvc.py\n"
    src += "#include <string>\n#include <vector>\n#include <utility>\n\n"
    src += "using namespace std;\n\n"
    # sanitize demangled into something we can attempt to compile
    sig = demangled
    # remove excessive return types like 'int ' at front? demangled often is "<qual>::name(args)"
    # If the demangled contains "::__" or "<" it's complex. We'll try to interpret common forms.
    # Heuristic approach:
    m = re.search(r'^(.*?::)?([^\s:]+)\((.*)\)$', sig)
    if m:
        # try to convert 'Class::func(argtypes)' into a definition `void Class_func();` won't help for mangling.
        # Better: create a namespace/class matching the qualification and define function there.
        # Extract qualifiers
        qual_name = sig.split('(')[0].strip()
        args = sig[sig.find('(')+1 : sig.rfind(')')].strip()
        # split qualifiers
        qual_parts = qual_name.split('::')
        func_name = qual_parts[-1]
        namespaces = qual_parts[:-1]
        # Build a nested namespace/class chain (best-effort: treat everything before last as namespaces)
        open_ns = ""
        close_ns = ""
        for ns in namespaces:
            # ensure ns is identifier-like
            nsid = re.sub(r'[^a-zA-Z0-9_]', '_', ns)
            open_ns += f"namespace {nsid} {{\n"
            close_ns = "}\n" + close_ns
        # declare a dummy function with the same parameter list but return type void
        # This is risky but sometimes enough to cause MSVC to produce a mangled symbol for that name.
        src += open_ns
        # If method name is a constructor-like (same as class name), we cannot synthesize easily; fallback to function
        decl = f"void {func_name}({args}) {{}}\n"
        src += decl
        src += close_ns
    else:
        # fallback: create nothing useful
        src += "int __dummy_symbol_for_mapping() { return 0; }\n"

    cpp_file.write_text(src, encoding="utf-8")

    # compile with cl.exe
    cl = shutil.which("cl.exe")
    dumpbin = shutil.which("dumpbin.exe")
    if not cl or not dumpbin:
        return None, "MSVC tools (cl.exe or dumpbin.exe) not found in PATH"

    # run cl /c /nologo stub.cpp -> produces stub.obj
    result = run_cmd([cl, "/nologo", "/c", str(cpp_file)], cwd=workdir)
    if result.returncode != 0:
        return None, f"cl.exe failed: {result.stderr.strip() or result.stdout.strip()}"

    objfile = Path(workdir) / "stub.obj"
    if not objfile.exists():
        return None, "stub.obj not found after cl.exe"

    # run dumpbin /SYMBOLS stub.obj
    db = run_cmd([dumpbin, "/SYMBOLS", str(objfile)], cwd=workdir)
    if db.returncode != 0:
        return None, f"dumpbin failed: {db.stderr.strip() or db.stdout.strip()}"

    # search for decorated names starting with ? (MSVC symbols)
    # dumpbin outputs lines with symbol names; find candidates containing '?'
    symbols = []
    for line in db.stdout.splitlines():
        if "?" in line:
            # crude: pull last whitespace token
            tok = line.strip().split()[-1]
            if tok.startswith("?") or tok.startswith("??"):
                symbols.append(tok)
    if not symbols:
        return None, "no MSVC-decorated symbols found in dumpbin output"

    # Heuristic: pick the longest decorated symbol (more likely to include full signature)
    msvc_sym = max(symbols, key=len)
    return msvc_sym, None

def main():
    import argparse
    p = argparse.ArgumentParser(description="Convert Itanium mangled symbols in LLVM IR to MSVC-mangled symbols")
    p.add_argument("input", help="input LLVM IR (.ll)")
    p.add_argument("output", help="output LLVM IR (.ll) with replacements")
    p.add_argument("--msvc", action="store_true", help="attempt to remangle with MSVC (requires cl.exe/dumpbin.exe on PATH, Windows)")
    args = p.parse_args()

    irtext = Path(args.input).read_text(encoding="utf-8")
    itanium_syms = extract_itanium_symbols(irtext)
    print(f"Found {len(itanium_syms)} itanium symbols")

    mappings = {}
    tmpdir = tempfile.mkdtemp(prefix="itanium2msvc_")
    try:
        for s in itanium_syms:
            print(f"Processing: {s}")
            demangled, err = demangle_with_cxxfilt(s)
            if err:
                print(f"  demangle failed: {err.strip()}")
                demangled = None
            else:
                print(f"  demangled: {demangled}")

            msvc = None
            msvc_err = None
            if args.msvc and demangled:
                print("  attempting MSVC remangle (requires MSVC toolchain)...")
                msvc, msvc_err = try_msvc_mangle(demangled, tmpdir)
                if msvc:
                    print(f"  got MSVC symbol: {msvc}")
                else:
                    print(f"  MSVC remangle failed: {msvc_err}")

            mappings[s] = {
                "demangled": demangled,
                "msvc_mangled": msvc,
                "msvc_error": msvc_err
            }

        # Save mapping for manual review
        mappings_file = Path(args.output).with_suffix(".mappings.json")
        mappings_file.write_text(json.dumps(mappings, indent=2), encoding="utf-8")
        print(f"Wrote mappings to {mappings_file}")

        # Create output IR by replacing any symbols which have msvc_mangled non-null
        out_text = irtext
        replacements = 0
        for orig, info in mappings.items():
            if info.get("msvc_mangled"):
                out_text = out_text.replace(orig, info["msvc_mangled"])
                replacements += 1
        Path(args.output).write_text(out_text, encoding="utf-8")
        print(f"Wrote output IR to {args.output} (applied {replacements} replacements)")

        print("Done. If some msvc_mangled fields are null, open the .mappings.json and fill them by hand")
        print("or provide me the filled mappings and I can apply them to the IR for you.")
    finally:
        pass
        # keep tmpdir for debugging; delete if you prefer:
        # shutil.rmtree(tmpdir)

if __name__ == "__main__":
    main()

```

`run.sh`:

```sh
#!/bin/bash

# Select file from test/idb
files="$(ls -A ./tests/idb)"
echo "Select an valid idb:"

# Use the select statement to present the user with a numbered list of files
select filename in ${files}; do
    # If the user selects a valid file, echo its name
    if [[ -n "$filename" ]]; then
        # Make directory for script output
        mkdir -p ./tests/ll ./tests/log

        wine ~/.wine/ida/idat64.exe -A -S"./docker_entrypoint.py" "./tests/idb/$filename" -t 2>/dev/null
    else
        echo "Invalid selection"
    fi
    break
done

# Display results
echo 'results written to ./tests/ll'
```

`tests/src/romannumeral.cpp`:

```cpp
#include<stdio.h>
#include<vector>
#include<string>

using namespace std;

class Solution {
public:
    string intToRoman(int num) {
        vector<pair<int,string>> p={{1000, "M"}, {900, "CM"}, {500, "D"}, {400, "CD"}, {100, "C"}, {90, "XC"}, {50, "L"}, {40, "XL"}, {10, "X"}, {9, "IX"}, {5, "V"}, {4, "IV"}, {1, "I"}};
        string roman="";
        for(int i=0;i<p.size();i++){
            while(p[i].first<=num){
                roman=roman+p[i].second;
                num=num-p[i].first;
            }
        }
        return roman;
    }
};

int main() {
    int inputs[] = {1, 4, 123, 5123, 123, 6345, 7481, 13231, 21, 12321, 12315};
    for (int i = 0; i < 11; i++) {
        Solution sol;
        auto output = sol.intToRoman(inputs[i]);
        printf("%s\n", output.c_str());
    }
}
```