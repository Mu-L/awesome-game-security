Project Path: arc_es3n1n_nvidia-overlay-renderer_zf7wv4rs

Source Tree:

```txt
arc_es3n1n_nvidia-overlay-renderer_zf7wv4rs
├── nvidia-overlay
│   ├── logger
│   │   ├── logger.cpp
│   │   └── logger.h
│   ├── main.cpp
│   ├── nvidia-overlay.vcxproj
│   ├── nvidia-overlay.vcxproj.filters
│   ├── overlay
│   │   ├── overlay.cpp
│   │   └── overlay.h
│   ├── renderer
│   │   ├── colors.cpp
│   │   ├── fonts.cpp
│   │   ├── internal.cpp
│   │   ├── internal.h
│   │   ├── renderer.cpp
│   │   ├── renderer.h
│   │   └── scene.cpp
│   ├── scene.h
│   └── utils
│       ├── e_status.h
│       ├── fnv.h
│       └── vec2.h
├── nvidia-overlay.sln
└── readme.md

```

`nvidia-overlay.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31105.61
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "nvidia-overlay", "nvidia-overlay\nvidia-overlay.vcxproj", "{2D0DC6BB-A1AC-471F-88A7-982FFC335321}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{2D0DC6BB-A1AC-471F-88A7-982FFC335321}.Debug|x64.ActiveCfg = Debug|x64
		{2D0DC6BB-A1AC-471F-88A7-982FFC335321}.Debug|x64.Build.0 = Debug|x64
		{2D0DC6BB-A1AC-471F-88A7-982FFC335321}.Debug|x86.ActiveCfg = Debug|Win32
		{2D0DC6BB-A1AC-471F-88A7-982FFC335321}.Debug|x86.Build.0 = Debug|Win32
		{2D0DC6BB-A1AC-471F-88A7-982FFC335321}.Release|x64.ActiveCfg = Release|x64
		{2D0DC6BB-A1AC-471F-88A7-982FFC335321}.Release|x64.Build.0 = Release|x64
		{2D0DC6BB-A1AC-471F-88A7-982FFC335321}.Release|x86.ActiveCfg = Release|Win32
		{2D0DC6BB-A1AC-471F-88A7-982FFC335321}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {A80B7BCC-CF6C-4BC3-85B2-A578D5A53172}
	EndGlobalSection
EndGlobal

```

`nvidia-overlay/logger/logger.cpp`:

```cpp
#include "logger.h"


namespace logger {
	namespace _colors {
		void* m_console_handle = nullptr;

		bool ensure_handle( ) {
			if ( !m_console_handle )
				m_console_handle = GetStdHandle( STD_OUTPUT_HANDLE );
			return static_cast< bool >( m_console_handle );
		}

		void apply( uint32_t clr ) {
			if ( !ensure_handle( ) ) return;
			SetConsoleTextAttribute( m_console_handle, clr );
		}

		void reset( ) {
			apply( static_cast< uint32_t >( e_level_color::level_color_none ) );
		}
	}

	void log( const char* prefix, e_level_color level, const char* message ) {
		_colors::apply( static_cast< uint32_t >( level ) );
		printf( "%s >> ", prefix );
		_colors::reset( );

		printf( "%s\n", message );
	}
}
```

`nvidia-overlay/logger/logger.h`:

```h
#pragma once
#include <cstdint>
#include <stdio.h>
#include <Windows.h>
#include "../utils/e_status.h"


#define L_ERROR(txt) logger::error("%s(): %s", __FUNCTION__, txt); return utils::e_status::status_failed;
#define L_ASSERT(cond, txt) if (!cond) { L_ERROR(txt); }
#define TRACE_FN logger::debug( "%s()", __FUNCTION__ );

#define CREATE_LOGGER_METHOD(n) inline void n(const char* fmt, ...) { char buf[1024]; va_list va; va_start( va, fmt ); _vsnprintf_s( buf, 1024, fmt, va ); va_end( va ); log( #n, e_level_color::level_color_ ##n, buf ); }


namespace logger {
	enum class e_level_color : uint32_t {
		level_color_none = 15, // black bg and white fg
		level_color_debug = 8,
		level_color_info = 10,
		level_color_warn = 14,
		level_color_error = 12
	};

	namespace _colors {
		extern void* m_console_handle;

		bool ensure_handle( );
		void apply( uint32_t clr );
		void reset( );
	}

	void log( const char* prefix, e_level_color level, const char* message );

#ifdef LOG_DEBUG_MESSAGES
	CREATE_LOGGER_METHOD( debug );
#else
	inline void debug( const char* fmt, ... ) { }
#endif

	CREATE_LOGGER_METHOD( info );
	CREATE_LOGGER_METHOD( warn );
	CREATE_LOGGER_METHOD( error );
}

#undef CREATE_LOGGER_METHOD

```

`nvidia-overlay/main.cpp`:

```cpp
#ifdef _DEBUG
#define LOG_DEBUG_MESSAGES
#endif

#include "scene.h"


utils::e_status init( ) {
	TRACE_FN;

	L_ASSERT( overlay::init( ), "failed to initialize overlay" );
	logger::info( "Initialized overlay" );

	L_ASSERT( renderer::init( ), "failed to initialize renderer" );
	logger::info( "Initialized renderer" );

	return utils::e_status::status_ok;
}


utils::e_status shutdown( ) {
	TRACE_FN;

	L_ASSERT( renderer::shutdown( ), "failed to shut down renderer" );
	logger::info( "Shut down renderer" );

	return utils::e_status::status_ok;
}


int main( ) {
	TRACE_FN;

	if ( !init( ) ) return -1;
	if ( !show_scene( ) ) return -1;
	if ( !shutdown( ) ) return -1;

	return 0;
}
```

`nvidia-overlay/nvidia-overlay.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{2d0dc6bb-a1ac-471f-88a7-982ffc335321}</ProjectGuid>
    <RootNamespace>nvidiaoverlay</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="logger\logger.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="overlay\overlay.cpp" />
    <ClCompile Include="renderer\colors.cpp" />
    <ClCompile Include="renderer\fonts.cpp" />
    <ClCompile Include="renderer\internal.cpp" />
    <ClCompile Include="renderer\renderer.cpp" />
    <ClCompile Include="renderer\scene.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="logger\logger.h" />
    <ClInclude Include="overlay\overlay.h" />
    <ClInclude Include="renderer\internal.h" />
    <ClInclude Include="renderer\renderer.h" />
    <ClInclude Include="utils\e_status.h" />
    <ClInclude Include="scene.h" />
    <ClInclude Include="utils\fnv.h" />
    <ClInclude Include="utils\vec2.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`nvidia-overlay/nvidia-overlay.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="logger\logger.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="overlay\overlay.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="renderer\internal.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="renderer\renderer.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="renderer\colors.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="renderer\fonts.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="renderer\scene.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="logger\logger.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="overlay\overlay.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="renderer\internal.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="utils\e_status.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="renderer\renderer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="utils\vec2.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="scene.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="utils\fnv.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`nvidia-overlay/overlay/overlay.cpp`:

```cpp
#include "overlay.h"


namespace overlay {
	utils::e_status init( ) {
		TRACE_FN;

		vars::m_window_hwnd = FindWindowW( L"CEF-OSC-WIDGET", L"NVIDIA GeForce Overlay" );
		L_ASSERT( vars::m_window_hwnd, "overlay not found" );

		auto apply_window_styles = [ ] ( ) -> utils::e_status {
			TRACE_FN;

			// style
			SetWindowLongW(
				vars::m_window_hwnd,
				-20,
				static_cast< LONG_PTR >(
					static_cast< int >( GetWindowLongW( vars::m_window_hwnd, -20 ) ) | 0x20
				)
			);

			// transparency
			MARGINS margin = { -1, -1, -1, -1 };
			DwmExtendFrameIntoClientArea( 
				vars::m_window_hwnd, 
				&margin 
			);
			L_ASSERT( SetLayeredWindowAttributes( 
				vars::m_window_hwnd, 
				0x000000, 
				0xFF, 
				0x02 
			), "SetLayeredWindowAttributes() returned false" );

			// top most
			L_ASSERT( SetWindowPos( 
				vars::m_window_hwnd, 
				HWND_TOPMOST, 
				0, 0, 0, 0, 
				0x0002 | 0x0001 
			), "SetWindowPos() returned false" );

			return utils::e_status::status_ok;
		};

		L_ASSERT( apply_window_styles( ), "cannot apply styles" );
		L_ASSERT( ShowWindow( vars::m_window_hwnd, SW_SHOW ), "ShowWindow() returned false" );

		L_ASSERT( GetClientRect( vars::m_window_hwnd, &vars::m_window_rect ), "GetClientRect() returned false" );
		vars::m_window_size = D2D1::SizeU( vars::m_window_rect.right - vars::m_window_rect.left, vars::m_window_rect.bottom - vars::m_window_rect.top );

		return utils::e_status::status_ok;
	}
}

```

`nvidia-overlay/overlay/overlay.h`:

```h
#pragma once
#include "../logger/logger.h"
#include <d2d1.h>
#include <stdio.h>
#include <dwmapi.h> 
#pragma comment(lib, "Dwmapi.lib") 


namespace overlay {
	namespace vars {
		inline HWND m_window_hwnd;
		inline RECT m_window_rect;
		inline D2D1_SIZE_U m_window_size;
	}

	utils::e_status init( );
}

```

`nvidia-overlay/renderer/colors.cpp`:

```cpp
#include "renderer.h"

namespace renderer {
	namespace colors {
		ID2D1SolidColorBrush* get( uint32_t col ) {
			if ( _colors.find( col ) != _colors.end( ) )
				return _colors.at( col );
			_colors[ col ] = NULL;
			internal::m_render_target->CreateSolidColorBrush( D2D1::ColorF( col ), &_colors.at( col ) );
			return ::renderer::colors::get( col );
		}

		utils::e_status shutdown( ) {
			TRACE_FN;

			for ( auto&& p : _colors )
				p.second->Release( );  // @note: es3n1n: why would i care, nullptr here is an unexpected behavior!

			return utils::e_status::status_ok;
		}
	}
}

```

`nvidia-overlay/renderer/fonts.cpp`:

```cpp
#include "renderer.h"


namespace renderer {
	namespace fonts {
		IDWriteTextFormat* get( const char* name, float size ) {
			char _id[ 256 ];
			sprintf_s( _id, "%s_%f", name, size );
			const uint32_t id = hash::fnv1<uint32_t>::hash( _id );

			if ( _fonts.find( id ) != _fonts.end( ) )
				return _fonts.at( id );

			size_t font_name_size;
			wchar_t font_name[ 100 ];
			mbstowcs_s( &font_name_size, font_name, name, strlen( name ) );  // @note: es3n1n: this shit sucks

			_fonts[ id ] = NULL;
			internal::m_factory->CreateTextFormat(
				font_name, NULL,
				DWRITE_FONT_WEIGHT_REGULAR, DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL,
				size,
				L"en-us",
				&_fonts.at( id )
			);

			return _fonts[ id ];
		}

		utils::e_status shutdown( ) {
			TRACE_FN;

			for ( auto&& p : _fonts )
				p.second->Release( );  // @note: es3n1n: why would i care, nullptr here is an unexpected behavior!

			return utils::e_status::status_ok;
		}
	}
}
```

`nvidia-overlay/renderer/internal.cpp`:

```cpp
#include "internal.h"


namespace renderer {
	namespace internal {
		utils::e_status init( ) {
			TRACE_FN;

			L_ASSERT( !FAILED( 
				D2D1CreateFactory( D2D1_FACTORY_TYPE_SINGLE_THREADED, &m_d2d ) 
			), "failed to create render factory" );
			L_ASSERT( !FAILED( 
				DWriteCreateFactory( 
					DWRITE_FACTORY_TYPE_SHARED, 
					__uuidof( IDWriteFactory ), 
					reinterpret_cast< IUnknown** >( ( &m_factory ) )
				) 
			), "failed to create factory" );

			L_ASSERT( !FAILED( m_d2d->CreateHwndRenderTarget(
				D2D1::RenderTargetProperties( 
					D2D1_RENDER_TARGET_TYPE_DEFAULT,
					D2D1::PixelFormat( DXGI_FORMAT_UNKNOWN, D2D1_ALPHA_MODE_PREMULTIPLIED )
				),
				D2D1::HwndRenderTargetProperties(
					overlay::vars::m_window_hwnd,
					overlay::vars::m_window_size
				),
				&m_render_target
			) ), "failed to create render target" );

			return utils::e_status::status_ok;
		}

		utils::e_status shutdown( ) {
			TRACE_FN;

			m_d2d->Release( );
			m_factory->Release( );
			m_render_target->Release( );

			return utils::e_status::status_ok;
		}
	}
}
```

`nvidia-overlay/renderer/internal.h`:

```h
#pragma once
#include "../logger/logger.h"
#include "../overlay/overlay.h"

#include <stdio.h>
#include <dwmapi.h> 
#include <d2d1.h>
#include <dwrite.h>
#pragma comment(lib, "Dwrite")

#pragma comment(lib, "Dwmapi.lib") 
#pragma comment(lib, "d2d1.lib")


namespace renderer {
	namespace internal {
		inline ID2D1Factory* m_d2d;
		inline ID2D1HwndRenderTarget* m_render_target;
		inline IDWriteFactory* m_factory;

		utils::e_status init( );
		utils::e_status shutdown( );
	}
}

```

`nvidia-overlay/renderer/renderer.cpp`:

```cpp
#include "renderer.h"


namespace renderer {
	utils::e_status init( ) {
		TRACE_FN;

		L_ASSERT( internal::init( ), "failed to init internal render stuff" );

		return utils::e_status::status_ok;
	}

	utils::e_status shutdown( ) {
		TRACE_FN;

		scene::shutdown( );
		L_ASSERT( internal::shutdown( ), "failed to shutdown internal render stuff" );
		L_ASSERT( colors::shutdown( ), "failed to shutdown colors" );
		L_ASSERT( fonts::shutdown( ), "failed to shutdown colors" );

		return utils::e_status::status_ok;
	}
}

```

`nvidia-overlay/renderer/renderer.h`:

```h
#pragma once
#include "internal.h"
#include "../utils/vec2.h"
#include "../utils/fnv.h"
#include <unordered_map>


namespace renderer {
	// @note: es3n1n: if you are scared of stl n shit then you can hardcode all colors/fonts in their namespaces

	namespace colors {
		inline std::unordered_map<uint32_t, ID2D1SolidColorBrush*> _colors = {};

		ID2D1SolidColorBrush* get( uint32_t col );
		utils::e_status shutdown( );
	}

	namespace fonts {
		inline std::unordered_map<uint32_t,  IDWriteTextFormat*> _fonts = {};

		IDWriteTextFormat* get( const char* name, float size );
		utils::e_status shutdown( );
	}

	namespace scene {
		void start( ); // alias for begin() & clear()
		void begin( );
		void end( );
		void clear( );

		void text( utils::vec2 pos, const wchar_t* text, ID2D1SolidColorBrush* color, IDWriteTextFormat* font );

		void shutdown( );
	}

	utils::e_status init( );
	utils::e_status shutdown( );
}


#define COL_GET( hex_code ) ::renderer::colors::get( hex_code )
#define FONT_GET( font_name, font_size_float ) ::renderer::fonts::get( font_name, font_size_float )

```

`nvidia-overlay/renderer/scene.cpp`:

```cpp
#include "renderer.h"


namespace renderer {
	namespace scene {
		void start( ) {
			begin( );
			clear( );
		}

		void begin( ) {
			internal::m_render_target->BeginDraw( );
		}

		void end( ) {
			internal::m_render_target->EndDraw( );
		}

		void clear( ) {
			internal::m_render_target->Clear( );
		}

		void text( utils::vec2 pos, const wchar_t* text, ID2D1SolidColorBrush* color, IDWriteTextFormat* font ) {
			internal::m_render_target->DrawTextW( text, lstrlenW( text ), font, pos.rect( ), color, D2D1_DRAW_TEXT_OPTIONS_NONE, DWRITE_MEASURING_MODE_NATURAL );
		}

		void shutdown( ) {
			begin( );
			clear( );
			end( );
		}
	}
}
```

`nvidia-overlay/scene.h`:

```h
#pragma once
#include "renderer/renderer.h"


static void draw_demo_scene( ) {
	renderer::scene::start( );

	uint32_t x = 100;
	for ( uint32_t j = 0; j < 5; j++ ) {
		uint32_t y = 150;
		for ( uint32_t i = 0; i < 70; i++ ) {
			renderer::scene::text( utils::vec2( x, y ), L"русские вперед", COL_GET( 0xFFFFFFF ), FONT_GET( "Consolas", 13.0 ) );
			y += 10;
		}
		x += 120;
	}

	renderer::scene::end( );
}


utils::e_status show_scene( ) {
	TRACE_FN;

	logger::info( "Press [delete] key to exit" );

	while ( !GetAsyncKeyState( VK_DELETE ) )
		draw_demo_scene( );

	return utils::e_status::status_ok;
}

```

`nvidia-overlay/utils/e_status.h`:

```h
#pragma once


namespace utils {
	enum class e_status : int {
		status_ok = 0,
		status_failed
	};

	inline bool operator! ( e_status e ) {
		return e == e_status::status_failed;
	}
}

```

`nvidia-overlay/utils/fnv.h`:

```h
#pragma once

#include <iostream>
#include <cassert>

namespace hash {
	template <typename S> struct fnv1;

	template <> struct fnv1<uint32_t> {
		constexpr static inline uint32_t hash( char const* const aString, const uint32_t val = 0x811C9DC5 ) {
			return ( aString[ 0 ] == '\0' ) ? val : hash( &aString[ 1 ], ( val * 0x01000193 ) ^ uint32_t( aString[ 0 ] ) );
		}
	};
} // namespace hash

```

`nvidia-overlay/utils/vec2.h`:

```h
#pragma once
#include <cstdint>


namespace utils {
	struct vec2 {
		uint32_t x, y;

		vec2( uint32_t x, uint32_t y ) : x( x ), y( y ) { }

		D2D1_RECT_F rect( ) {
			return D2D1::RectF( static_cast< FLOAT >( x ), static_cast< FLOAT >( y ), static_cast< FLOAT >( INT_MAX ), static_cast< FLOAT >( INT_MAX ) );
		}
	};
}

```

`readme.md`:

```md

![pic](https://i.imgur.com/J7lFTCs.png)

```