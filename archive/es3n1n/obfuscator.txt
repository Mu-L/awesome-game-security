Project Path: arc_es3n1n_obfuscator_p6_3y62w

Source Tree:

```txt
arc_es3n1n_obfuscator_p6_3y62w
├── CMakeLists.txt
├── LICENSE
├── README.md
├── cmake
│   └── cmkr.cmake
├── cmake.toml
├── scripts
│   ├── bb_preview
│   │   ├── basic_blocks
│   │   ├── basic_blocks.png
│   │   ├── data
│   │   └── main.py
│   ├── opaque_predicates_expr_gen
│   │   ├── convert.py
│   │   ├── errors.txt
│   │   ├── generated.txt
│   │   ├── main.py
│   │   └── zasm_generated.cpp
│   └── show_disasm.sh
├── src
│   ├── CMakeLists.txt
│   ├── bin
│   │   └── entry.cpp
│   ├── cmake.toml
│   ├── lib
│   │   ├── analysis
│   │   │   ├── analysis.cpp
│   │   │   ├── analysis.hpp
│   │   │   ├── bb_decomp
│   │   │   │   ├── bb_decomp.cpp
│   │   │   │   ├── bb_decomp.hpp
│   │   │   │   └── jumptables.cpp
│   │   │   ├── common
│   │   │   │   ├── common.hpp
│   │   │   │   ├── debug.hpp
│   │   │   │   └── provider.hpp
│   │   │   ├── lru_reg
│   │   │   │   └── lru_reg.hpp
│   │   │   ├── observer
│   │   │   │   └── observer.hpp
│   │   │   ├── passes
│   │   │   │   ├── collect_img_references.hpp
│   │   │   │   ├── collect_lookup_table.hpp
│   │   │   │   ├── label_references.hpp
│   │   │   │   ├── lru_reg.hpp
│   │   │   │   ├── misc
│   │   │   │   │   ├── bb_insn_passes.cpp
│   │   │   │   │   └── bb_insn_passes.hpp
│   │   │   │   └── reloc_marker.hpp
│   │   │   └── var_alloc
│   │   │       └── var_alloc.hpp
│   │   ├── cli
│   │   │   └── cli.hpp
│   │   ├── config_parser
│   │   │   ├── config_parser.cpp
│   │   │   ├── config_parser.hpp
│   │   │   └── structs.hpp
│   │   ├── easm
│   │   │   ├── assembler
│   │   │   │   ├── assembler.cpp
│   │   │   │   └── assembler.hpp
│   │   │   ├── cursor
│   │   │   │   └── cursor.hpp
│   │   │   ├── debug
│   │   │   │   └── debug.hpp
│   │   │   ├── disassembler
│   │   │   │   ├── disassembler.cpp
│   │   │   │   └── disassembler.hpp
│   │   │   ├── easm.hpp
│   │   │   └── misc
│   │   │       ├── misc.hpp
│   │   │       └── reg_convert.hpp
│   │   ├── func_parser
│   │   │   ├── common
│   │   │   │   ├── combiner.hpp
│   │   │   │   ├── common.hpp
│   │   │   │   └── sanitizer.hpp
│   │   │   ├── map
│   │   │   │   ├── map.cpp
│   │   │   │   └── map.hpp
│   │   │   ├── parser.cpp
│   │   │   ├── parser.hpp
│   │   │   └── pdb
│   │   │       ├── detail
│   │   │       │   ├── parser_v7.hpp
│   │   │       │   ├── reader_v7.cpp
│   │   │       │   └── structs.hpp
│   │   │       ├── pdb.cpp
│   │   │       └── pdb.hpp
│   │   ├── mathop
│   │   │   ├── mathop.hpp
│   │   │   └── operations
│   │   │       ├── impl
│   │   │       │   ├── add.cpp
│   │   │       │   ├── dec.cpp
│   │   │       │   ├── inc.cpp
│   │   │       │   ├── neg.cpp
│   │   │       │   ├── not.cpp
│   │   │       │   ├── sub.cpp
│   │   │       │   ├── util.hpp
│   │   │       │   └── xor.cpp
│   │   │       ├── operation.hpp
│   │   │       └── operations.hpp
│   │   ├── obfuscator
│   │   │   ├── config_merger
│   │   │   │   └── config_merger.hpp
│   │   │   ├── function.hpp
│   │   │   ├── obfuscator.cpp
│   │   │   ├── obfuscator.hpp
│   │   │   └── transforms
│   │   │       ├── configs.hpp
│   │   │       ├── scheduler.hpp
│   │   │       ├── startup.cpp
│   │   │       ├── transform.hpp
│   │   │       ├── transforms
│   │   │       │   ├── bogus_control_flow.hpp
│   │   │       │   ├── constant_crypt.hpp
│   │   │       │   ├── decomp_break.hpp
│   │   │       │   ├── substitution.hpp
│   │   │       │   └── util
│   │   │       │       ├── anti_decompilers.hpp
│   │   │       │       ├── bcf.hpp
│   │   │       │       └── opaque_predicates.hpp
│   │   │       └── types.hpp
│   │   ├── pe
│   │   │   ├── arch
│   │   │   │   └── arch.hpp
│   │   │   ├── common
│   │   │   │   ├── common.hpp
│   │   │   │   └── types.hpp
│   │   │   ├── debug
│   │   │   │   └── debug.hpp
│   │   │   ├── pe.cpp
│   │   │   ├── pe.hpp
│   │   │   └── rebuilder
│   │   │       ├── detail
│   │   │       │   ├── common.hpp
│   │   │       │   ├── copy_sections.cpp
│   │   │       │   ├── init_header.cpp
│   │   │       │   ├── update_checksum.cpp
│   │   │       │   └── update_relocations.cpp
│   │   │       └── rebuilder.hpp
│   │   └── util
│   │       ├── defer.hpp
│   │       ├── files.hpp
│   │       ├── format.hpp
│   │       ├── iterators.hpp
│   │       ├── logger.hpp
│   │       ├── memory
│   │       │   ├── address.hpp
│   │       │   ├── casts.hpp
│   │       │   └── reader.hpp
│   │       ├── passes.hpp
│   │       ├── platform.hpp
│   │       ├── progress.hpp
│   │       ├── random.hpp
│   │       ├── sections.hpp
│   │       ├── stopwatch.hpp
│   │       ├── string_parser.hpp
│   │       ├── structs.hpp
│   │       └── types.hpp
│   └── tests
│       ├── analysis
│       │   └── bb_decomp
│       │       ├── bb_decomp.llvm.cpp
│       │       └── bb_decomp.msvc.cpp
│       ├── func_parser
│       │   ├── map
│       │   │   ├── map.ida.cpp
│       │   │   ├── map.llvm.cpp
│       │   │   └── map.msvc.cpp
│       │   └── pdb
│       │       ├── pdb.llvm.cpp
│       │       └── pdb.msvc.cpp
│       └── tests_util.hpp
├── todo.txt
└── vendor
    ├── CMakeLists.txt
    ├── cmake.toml
    ├── gtest
    ├── linux-pe
    ├── magic_enum
    └── zasm

```

`CMakeLists.txt`:

```txt
# This file is automatically generated from cmake.toml - DO NOT EDIT
# See https://github.com/build-cpp/cmkr for more information

cmake_minimum_required(VERSION 3.15)

# Enable support for MSVC_RUNTIME_LIBRARY
cmake_policy(SET CMP0091 NEW)
set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>")

if(CMAKE_SOURCE_DIR STREQUAL CMAKE_BINARY_DIR)
	message(FATAL_ERROR "In-tree builds are not supported. Run CMake from a separate directory: cmake -B build")
endif()

set(CMKR_ROOT_PROJECT OFF)
if(CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)
	set(CMKR_ROOT_PROJECT ON)

	# Bootstrap cmkr and automatically regenerate CMakeLists.txt
	include("cmake/cmkr.cmake" OPTIONAL RESULT_VARIABLE CMKR_INCLUDE_RESULT)
	if(CMKR_INCLUDE_RESULT)
		cmkr()
	endif()

	# Enable folder support
	set_property(GLOBAL PROPERTY USE_FOLDERS ON)

	# Create a configure-time dependency on cmake.toml to improve IDE support
	configure_file(cmake.toml cmake.toml COPYONLY)
endif()

# Options
option(OBFUSCATOR_BUILD_TESTS "" ON)

project(obfuscator
	LANGUAGES
		CXX
)

# Subdirectory: vendor
set(CMKR_CMAKE_FOLDER ${CMAKE_FOLDER})
if(CMAKE_FOLDER)
	set(CMAKE_FOLDER "${CMAKE_FOLDER}/vendor")
else()
	set(CMAKE_FOLDER vendor)
endif()
add_subdirectory(vendor)
set(CMAKE_FOLDER ${CMKR_CMAKE_FOLDER})

# Subdirectory: src
set(CMKR_CMAKE_FOLDER ${CMAKE_FOLDER})
if(CMAKE_FOLDER)
	set(CMAKE_FOLDER "${CMAKE_FOLDER}/src")
else()
	set(CMAKE_FOLDER src)
endif()
add_subdirectory(src)
set(CMAKE_FOLDER ${CMKR_CMAKE_FOLDER})


```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`README.md`:

```md
# Obfuscator
A native code obfuscator written in c++23.

## Available transforms:
* Bogus Control Flow
* Constant Crypt
* Decompilation breaker (ida, ghidra)
* Substitution

___

## Usage
```commandline
Available options:
    -h, --help                   -- This message
    -pdb         [path]          -- Set custom .pdb file location
    -map         [path]          -- Set custom .map file location
    -f           [name]          -- Start new function configuration
    -t           [name]          -- Start new transform configuration
    -g           [name]          -- Start new transform global configuration
    -v           [name] [value]  -- Push value
 
Examples:
    obfuscator hehe.exe -f main -t TransformName -v SomeName 1337
    obfuscator hehe.exe -f main -t TransformName -v SomeName 1337 -g TransformName -v SomeGlobalName 1337
    obfuscator hehe.exe -f main -t TransformName -v SomeName 1337 -v SomeName0 1337 -g TransformName -v SomeGlobalName 1337
    obfuscator hehe.exe -map mymap.map -pdb mypdb.pdb -f main -t TransformName -v SomeName 1337 -v SomeName0 1337 -g TransformName -v SomeGlobalName 1337
```

## Writeup
- [https://blog.es3n1n.eu/posts/obfuscator-pt-1](https://blog.es3n1n.eu/posts/obfuscator-pt-1)

___

## Building
This project is designed to be used on both Linux and Windows, and on any architecture.
Although you may need to update your compiler/libc++ to the latest version, as we're using some fancy C++23 features.

```commandline
cmake -B build -DOBFUSCATOR_BUILD_TESTS=0
cmake --build build --config Release
```

*If you are using Visual Studio on Windows, you can generate the sln project using the first command and build the project using the generated .sln file.*

## Contributing

Any contributions you make are **greatly appreciated**.

1. Fork the Project
2. Create your Feature Branch (`git checkout -b feature/AmazingFeature`)
3. Commit your Changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the Branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request

## Bug reporting

Before reporting any bugs that could be related to code generation,
please ensure that you attach the random seed used by the obfuscator. 
You can obtain this seed from the obfuscator logs; it is printed as the first message and looks like this:
```commandline
12:11:30.150 | [  info  ] random: seed is 0xcb91ccbef7cbcdc1
```

___

## Special thanks
- [@j4ckson4800](https://github.com/j4ckson4800), [@bs1337](https://github.com/bs1337) - Code review, proof-reading

## License
GPL-3.0

```

`cmake.toml`:

```toml
[cmake]
version = "3.15"
cmkr-include = "cmake/cmkr.cmake"

[project]
name = "obfuscator"
languages = ["CXX"]
msvc-runtime = "static"

[options]
OBFUSCATOR_BUILD_TESTS = true

[conditions]
build-tests = "OBFUSCATOR_BUILD_TESTS"

[subdir.vendor]
[subdir.src]

```

`cmake/cmkr.cmake`:

```cmake
include_guard()

# Change these defaults to point to your infrastructure if desired
set(CMKR_REPO "https://github.com/build-cpp/cmkr" CACHE STRING "cmkr git repository" FORCE)
set(CMKR_TAG "v0.2.24" CACHE STRING "cmkr git tag (this needs to be available forever)" FORCE)
set(CMKR_COMMIT_HASH "" CACHE STRING "cmkr git commit hash (optional)" FORCE)

# To bootstrap/generate a cmkr project: cmake -P cmkr.cmake
if(CMAKE_SCRIPT_MODE_FILE)
    set(CMAKE_BINARY_DIR "${CMAKE_BINARY_DIR}/build")
    set(CMAKE_CURRENT_BINARY_DIR "${CMAKE_BINARY_DIR}")
    file(MAKE_DIRECTORY "${CMAKE_BINARY_DIR}")
endif()

# Set these from the command line to customize for development/debugging purposes
set(CMKR_EXECUTABLE "" CACHE FILEPATH "cmkr executable")
set(CMKR_SKIP_GENERATION OFF CACHE BOOL "skip automatic cmkr generation")
set(CMKR_BUILD_TYPE "Debug" CACHE STRING "cmkr build configuration")
mark_as_advanced(CMKR_REPO CMKR_TAG CMKR_COMMIT_HASH CMKR_EXECUTABLE CMKR_SKIP_GENERATION CMKR_BUILD_TYPE)

# Disable cmkr if generation is disabled
if(DEFINED ENV{CI} OR CMKR_SKIP_GENERATION OR CMKR_BUILD_SKIP_GENERATION)
    message(STATUS "[cmkr] Skipping automatic cmkr generation")
    unset(CMKR_BUILD_SKIP_GENERATION CACHE)
    macro(cmkr)
    endmacro()
    return()
endif()

# Disable cmkr if no cmake.toml file is found
if(NOT CMAKE_SCRIPT_MODE_FILE AND NOT EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/cmake.toml")
    message(AUTHOR_WARNING "[cmkr] Not found: ${CMAKE_CURRENT_SOURCE_DIR}/cmake.toml")
    macro(cmkr)
    endmacro()
    return()
endif()

# Convert a Windows native path to CMake path
if(CMKR_EXECUTABLE MATCHES "\\\\")
    string(REPLACE "\\" "/" CMKR_EXECUTABLE_CMAKE "${CMKR_EXECUTABLE}")
    set(CMKR_EXECUTABLE "${CMKR_EXECUTABLE_CMAKE}" CACHE FILEPATH "" FORCE)
    unset(CMKR_EXECUTABLE_CMAKE)
endif()

# Helper macro to execute a process (COMMAND_ERROR_IS_FATAL ANY is 3.19 and higher)
function(cmkr_exec)
    execute_process(COMMAND ${ARGV} RESULT_VARIABLE CMKR_EXEC_RESULT)
    if(NOT CMKR_EXEC_RESULT EQUAL 0)
        message(FATAL_ERROR "cmkr_exec(${ARGV}) failed (exit code ${CMKR_EXEC_RESULT})")
    endif()
endfunction()

# Windows-specific hack (CMAKE_EXECUTABLE_PREFIX is not set at the moment)
if(WIN32)
    set(CMKR_EXECUTABLE_NAME "cmkr.exe")
else()
    set(CMKR_EXECUTABLE_NAME "cmkr")
endif()

# Use cached cmkr if found
if(DEFINED ENV{CMKR_CACHE})
    set(CMKR_DIRECTORY_PREFIX "$ENV{CMKR_CACHE}")
    string(REPLACE "\\" "/" CMKR_DIRECTORY_PREFIX "${CMKR_DIRECTORY_PREFIX}")
    if(NOT CMKR_DIRECTORY_PREFIX MATCHES "\\/$")
        set(CMKR_DIRECTORY_PREFIX "${CMKR_DIRECTORY_PREFIX}/")
    endif()
    # Build in release mode for the cache
    set(CMKR_BUILD_TYPE "Release")
else()
    set(CMKR_DIRECTORY_PREFIX "${CMAKE_CURRENT_BINARY_DIR}/_cmkr_")
endif()
set(CMKR_DIRECTORY "${CMKR_DIRECTORY_PREFIX}${CMKR_TAG}")
set(CMKR_CACHED_EXECUTABLE "${CMKR_DIRECTORY}/bin/${CMKR_EXECUTABLE_NAME}")

# Helper function to check if a string starts with a prefix
# Cannot use MATCHES, see: https://github.com/build-cpp/cmkr/issues/61
function(cmkr_startswith str prefix result)
    string(LENGTH "${prefix}" prefix_length)
    string(LENGTH "${str}" str_length)
    if(prefix_length LESS_EQUAL str_length)
        string(SUBSTRING "${str}" 0 ${prefix_length} str_prefix)
        if(prefix STREQUAL str_prefix)
            set("${result}" ON PARENT_SCOPE)
            return()
        endif()
    endif()
    set("${result}" OFF PARENT_SCOPE)
endfunction()

# Handle upgrading logic
if(CMKR_EXECUTABLE AND NOT CMKR_CACHED_EXECUTABLE STREQUAL CMKR_EXECUTABLE)
    cmkr_startswith("${CMKR_EXECUTABLE}" "${CMAKE_CURRENT_BINARY_DIR}/_cmkr" CMKR_STARTSWITH_BUILD)
    cmkr_startswith("${CMKR_EXECUTABLE}" "${CMKR_DIRECTORY_PREFIX}" CMKR_STARTSWITH_CACHE)
    if(CMKR_STARTSWITH_BUILD)
        if(DEFINED ENV{CMKR_CACHE})
            message(AUTHOR_WARNING "[cmkr] Switching to cached cmkr: '${CMKR_CACHED_EXECUTABLE}'")
            if(EXISTS "${CMKR_CACHED_EXECUTABLE}")
                set(CMKR_EXECUTABLE "${CMKR_CACHED_EXECUTABLE}" CACHE FILEPATH "Full path to cmkr executable" FORCE)
            else()
                unset(CMKR_EXECUTABLE CACHE)
            endif()
        else()
            message(AUTHOR_WARNING "[cmkr] Upgrading '${CMKR_EXECUTABLE}' to '${CMKR_CACHED_EXECUTABLE}'")
            unset(CMKR_EXECUTABLE CACHE)
        endif()
    elseif(DEFINED ENV{CMKR_CACHE} AND CMKR_STARTSWITH_CACHE)
        message(AUTHOR_WARNING "[cmkr] Upgrading cached '${CMKR_EXECUTABLE}' to '${CMKR_CACHED_EXECUTABLE}'")
        unset(CMKR_EXECUTABLE CACHE)
    endif()
endif()

if(CMKR_EXECUTABLE AND EXISTS "${CMKR_EXECUTABLE}")
    message(VERBOSE "[cmkr] Found cmkr: '${CMKR_EXECUTABLE}'")
elseif(CMKR_EXECUTABLE AND NOT CMKR_EXECUTABLE STREQUAL CMKR_CACHED_EXECUTABLE)
    message(FATAL_ERROR "[cmkr] '${CMKR_EXECUTABLE}' not found")
elseif(NOT CMKR_EXECUTABLE AND EXISTS "${CMKR_CACHED_EXECUTABLE}")
    set(CMKR_EXECUTABLE "${CMKR_CACHED_EXECUTABLE}" CACHE FILEPATH "Full path to cmkr executable" FORCE)
    message(STATUS "[cmkr] Found cached cmkr: '${CMKR_EXECUTABLE}'")
else()
    set(CMKR_EXECUTABLE "${CMKR_CACHED_EXECUTABLE}" CACHE FILEPATH "Full path to cmkr executable" FORCE)
    message(VERBOSE "[cmkr] Bootstrapping '${CMKR_EXECUTABLE}'")

    message(STATUS "[cmkr] Fetching cmkr...")
    if(EXISTS "${CMKR_DIRECTORY}")
        cmkr_exec("${CMAKE_COMMAND}" -E rm -rf "${CMKR_DIRECTORY}")
    endif()
    find_package(Git QUIET REQUIRED)
    cmkr_exec("${GIT_EXECUTABLE}"
            clone
            --config advice.detachedHead=false
            --branch ${CMKR_TAG}
            --depth 1
            ${CMKR_REPO}
            "${CMKR_DIRECTORY}"
            )
    if(CMKR_COMMIT_HASH)
        execute_process(
                COMMAND "${GIT_EXECUTABLE}" checkout -q "${CMKR_COMMIT_HASH}"
                RESULT_VARIABLE CMKR_EXEC_RESULT
                WORKING_DIRECTORY "${CMKR_DIRECTORY}"
        )
        if(NOT CMKR_EXEC_RESULT EQUAL 0)
            message(FATAL_ERROR "Tag '${CMKR_TAG}' hash is not '${CMKR_COMMIT_HASH}'")
        endif()
    endif()
    message(STATUS "[cmkr] Building cmkr (using system compiler)...")
    cmkr_exec("${CMAKE_COMMAND}"
            --no-warn-unused-cli
            "${CMKR_DIRECTORY}"
            "-B${CMKR_DIRECTORY}/build"
            "-DCMAKE_BUILD_TYPE=${CMKR_BUILD_TYPE}"
            "-DCMAKE_UNITY_BUILD=ON"
            "-DCMAKE_INSTALL_PREFIX=${CMKR_DIRECTORY}"
            "-DCMKR_GENERATE_DOCUMENTATION=OFF"
            )
    cmkr_exec("${CMAKE_COMMAND}"
            --build "${CMKR_DIRECTORY}/build"
            --config "${CMKR_BUILD_TYPE}"
            --parallel
            )
    cmkr_exec("${CMAKE_COMMAND}"
            --install "${CMKR_DIRECTORY}/build"
            --config "${CMKR_BUILD_TYPE}"
            --prefix "${CMKR_DIRECTORY}"
            --component cmkr
            )
    if(NOT EXISTS ${CMKR_EXECUTABLE})
        message(FATAL_ERROR "[cmkr] Failed to bootstrap '${CMKR_EXECUTABLE}'")
    endif()
    cmkr_exec("${CMKR_EXECUTABLE}" version)
    message(STATUS "[cmkr] Bootstrapped ${CMKR_EXECUTABLE}")
endif()
execute_process(COMMAND "${CMKR_EXECUTABLE}" version
        RESULT_VARIABLE CMKR_EXEC_RESULT
        )
if(NOT CMKR_EXEC_RESULT EQUAL 0)
    message(FATAL_ERROR "[cmkr] Failed to get version, try clearing the cache and rebuilding")
endif()

# Use cmkr.cmake as a script
if(CMAKE_SCRIPT_MODE_FILE)
    if(NOT EXISTS "${CMAKE_SOURCE_DIR}/cmake.toml")
        execute_process(COMMAND "${CMKR_EXECUTABLE}" init
                RESULT_VARIABLE CMKR_EXEC_RESULT
                )
        if(NOT CMKR_EXEC_RESULT EQUAL 0)
            message(FATAL_ERROR "[cmkr] Failed to bootstrap cmkr project. Please report an issue: https://github.com/build-cpp/cmkr/issues/new")
        else()
            message(STATUS "[cmkr] Modify cmake.toml and then configure using: cmake -B build")
        endif()
    else()
        execute_process(COMMAND "${CMKR_EXECUTABLE}" gen
                RESULT_VARIABLE CMKR_EXEC_RESULT
                )
        if(NOT CMKR_EXEC_RESULT EQUAL 0)
            message(FATAL_ERROR "[cmkr] Failed to generate project.")
        else()
            message(STATUS "[cmkr] Configure using: cmake -B build")
        endif()
    endif()
endif()

# This is the macro that contains black magic
macro(cmkr)
    # When this macro is called from the generated file, fake some internal CMake variables
    get_source_file_property(CMKR_CURRENT_LIST_FILE "${CMAKE_CURRENT_LIST_FILE}" CMKR_CURRENT_LIST_FILE)
    if(CMKR_CURRENT_LIST_FILE)
        set(CMAKE_CURRENT_LIST_FILE "${CMKR_CURRENT_LIST_FILE}")
        get_filename_component(CMAKE_CURRENT_LIST_DIR "${CMAKE_CURRENT_LIST_FILE}" DIRECTORY)
    endif()

    # File-based include guard (include_guard is not documented to work)
    get_source_file_property(CMKR_INCLUDE_GUARD "${CMAKE_CURRENT_LIST_FILE}" CMKR_INCLUDE_GUARD)
    if(NOT CMKR_INCLUDE_GUARD)
        set_source_files_properties("${CMAKE_CURRENT_LIST_FILE}" PROPERTIES CMKR_INCLUDE_GUARD TRUE)

        file(SHA256 "${CMAKE_CURRENT_LIST_FILE}" CMKR_LIST_FILE_SHA256_PRE)

        # Generate CMakeLists.txt
        cmkr_exec("${CMKR_EXECUTABLE}" gen
                WORKING_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}"
                )

        file(SHA256 "${CMAKE_CURRENT_LIST_FILE}" CMKR_LIST_FILE_SHA256_POST)

        # Delete the temporary file if it was left for some reason
        set(CMKR_TEMP_FILE "${CMAKE_CURRENT_SOURCE_DIR}/CMakerLists.txt")
        if(EXISTS "${CMKR_TEMP_FILE}")
            file(REMOVE "${CMKR_TEMP_FILE}")
        endif()

        if(NOT CMKR_LIST_FILE_SHA256_PRE STREQUAL CMKR_LIST_FILE_SHA256_POST)
            # Copy the now-generated CMakeLists.txt to CMakerLists.txt
            # This is done because you cannot include() a file you are currently in
            configure_file(CMakeLists.txt "${CMKR_TEMP_FILE}" COPYONLY)

            # Add the macro required for the hack at the start of the cmkr macro
            set_source_files_properties("${CMKR_TEMP_FILE}" PROPERTIES
                    CMKR_CURRENT_LIST_FILE "${CMAKE_CURRENT_LIST_FILE}"
                    )

            # 'Execute' the newly-generated CMakeLists.txt
            include("${CMKR_TEMP_FILE}")

            # Delete the generated file
            file(REMOVE "${CMKR_TEMP_FILE}")

            # Do not execute the rest of the original CMakeLists.txt
            return()
        endif()
        # Resume executing the unmodified CMakeLists.txt
    endif()
endmacro()

```

`scripts/bb_preview/basic_blocks`:

```
digraph {
	4144 [label="1030	ret"]
	4120 [label="1018	nop"]
	4120 -> 4121
	4128 [label="1020	jmp"]
	4128 -> 4120
	4112 [label="1010	cmp
1014	jnz"]
	4112 -> 4138
	4112 -> 4118
	4122 [label="101a	cmp
101e	jnz"]
	4122 -> 4122
	4122 -> 4128
	4138 [label="102a	cmp
102e	jz"]
	4138 -> 4121
	4138 -> 4144
	4121 [label="1019	nop"]
	4121 -> 4122
	4118 [label="1016	jmp"]
	4118 -> 4130
	4130 [label="1022	cmp
1026	jnz"]
	4130 -> 4130
	4130 -> 4136
	4136 [label="1028	jmp"]
	4136 -> 4121
}

```

`scripts/bb_preview/main.py`:

```py
import os
os.environ['PATH'] += os.pathsep + 'C:\\Program Files\\Graphviz\\bin'

from pathlib import Path
import graphviz


root_dir = Path(__file__).parent / 'data'

dot = graphviz.Digraph(format='png')


for file in root_dir.glob('*.bb'):
    with open(file, 'r') as f:
        content = f.read().splitlines()

    start: int = 0
    end: int = 0
    instructions = []
    successors = []
    predecessors = []

    for line in content:
        if line.startswith('start:'):
            start = int(line.split(':')[1], 16)
        if line.startswith('end:'):
            end = int(line.split(':')[1], 16)
        if line.startswith('instruction:'):
            data = line.split(':')[1]
            instructions.append(data.replace(';', '\t'))
        if line.startswith('successor:'):
            successors.append(int(line.split(':')[1], 16))
        if line.startswith('predecessor:'):
            predecessors.append(int(line.split(':')[1], 16))

    body = '\n'.join(instructions)
    dot.node(str(start), body)

    for successor in successors:
        dot.edge(str(start), str(successor))

    os.remove(file)


dot.render('basic_blocks', directory=root_dir.parent, view=True)

```

`scripts/opaque_predicates_expr_gen/convert.py`:

```py

with open('./zasm_generated.cpp', 'r') as f:
    content = f.read()


cases = []
cur = []

for line in content.splitlines():
    line = line.strip()
    if line in ['', ' ']:
        cases.append(list(cur))  # list for da copy
        cur.clear()
        continue

    cur.append(line)


print(f'switch (rnd::number<std::size_t>(0, {len(cases) - 1})) ' + '{')

for i in range(len(cases)):
    if i > 0:
        print()
    print('\t' + cases[i][0])
    print('\tcase ' + str(i) + ': {')
    for line in cases[i][1:]:
        print('\t\t' + line.replace('as->xor(', 'as->xor_(') + ';')
        if line.startswith('as->cmp'):
            print('\t\tvar_alloc.pop(as);')
    print('\t\tbreak;')
    print('\t}')

print()
print('\tdefault:')
print('\t\tthrow std::runtime_error("gen_predicate: invalid random index");')

print('};')

```

`scripts/opaque_predicates_expr_gen/errors.txt`:

```txt
((x & 8) >> 4) == Concat(0, Extract(3, 3, x3), 0) >> 4
(((x + 1) & 8) >> 16) == Concat(0, Extract(3, 3, 1 + x3), 0) >> 16
(((x << 2) + 8) & 2) == Concat(0,
       Extract(1, 1, 8 + Concat(Extract(29, 0, x3), 0)),
       0)
(((x << 4) >> 1) & 6) == Concat(0,
       Extract(2, 1, Concat(Extract(27, 0, x3), 0) >> 1),
       0)
(((x << 2) & 4) >> 16) == Concat(0, Extract(0, 0, x3), 0) >> 16
(((x << 16) - 13) & 2) == Concat(0,
       Extract(1,
               1,
               4294967283 + Concat(Extract(15, 0, x3), 0)),
       0)
(((x >> 1) & 4) >> 16) == Concat(0, Extract(2, 2, x3 >> 1), 0) >> 16
(((x & 2) + 8) >> 16) == Concat(2, Extract(1, 1, x3), 0) >> 16
(((x & 4) << 8) >> 16) == Concat(0, Extract(2, 2, x3), 0) >> 16
(((x & 4) >> 4) + 2) == 2 + (Concat(0, Extract(2, 2, x3), 0) >> 4)
(((x & 4) >> 4) << 4) == Concat(Extract(27, 0, Concat(0, Extract(2, 2, x3), 0) >> 4),
       0)
(((x & 4) >> 4) >> 1) == Concat(0, Extract(2, 2, x3), 0) >> 5
(((x & 8) >> 4) & 11) == Concat(0,
       Extract(3, 3, Concat(0, Extract(3, 3, x3), 0) >> 4),
       0,
       Extract(1, 0, Concat(0, Extract(3, 3, x3), 0) >> 4))
rotl((((x & 8) >> 4), 12)) == Concat(Extract(19, 0, Concat(0, Extract(3, 3, x3), 0) >> 4),
       Extract(31, 20, Concat(0, Extract(3, 3, x3), 0) >> 4))
rotr((((x & 2) >> 4), 1)) == Concat(Extract(0, 0, Concat(0, Extract(1, 1, x3), 0) >> 4),
       Extract(31, 1, Concat(0, Extract(1, 1, x3), 0) >> 4))
(((x & 8) >> 4) ^ 16) == Concat(Extract(31, 5, Concat(0, Extract(3, 3, x3), 0) >> 4),
       ~Extract(4, 4, Concat(0, Extract(3, 3, x3), 0) >> 4),
       Extract(3, 0, Concat(0, Extract(3, 3, x3), 0) >> 4))
(((x & 16) & 16) >> 16) == Concat(0, Extract(4, 4, x3), 0) >> 16
(rotl(((x & 2), 2)) >> 16) == Concat(0, Extract(1, 1, x3), 0) >> 16
(rotr(((x & 8), 3)) >> 7) == Concat(0, Extract(3, 3, x3)) >> 7
(((x & 15) ^ 15) >> 16) == Concat(0, ~Extract(3, 0, x3)) >> 16
((rotl((x, 16)) & 4) >> 16) == Concat(0, Extract(18, 18, x3), 0) >> 16
((rotr((x, 16)) & 4) >> 16) == Concat(0, Extract(18, 18, x3), 0) >> 16
(((x ^ 16) & 1) >> 16) == Concat(0, Extract(0, 0, x3)) >> 16
(((x - 14) & 1) >> 16) == Concat(0, Extract(0, 0, x3)) >> 16
((((x + 1) + 1) & 1) >> 16) == Concat(0, Extract(0, 0, x3)) >> 16
((((x + 4) << 4) >> 1) & 3) == Concat(0,
       Extract(1, 0, Concat(4 + Extract(27, 0, x3), 0) >> 1))
(rotl((((x + 1) << 16), 16)) >> 16) == Concat(0, 1 + Extract(15, 0, x3)) >> 16
(rotr((((x + 4) << 16), 16)) >> 16) == Concat(0, 4 + Extract(15, 0, x3)) >> 16
((((x + 16) << 16) - 15) & 11) == Concat(0,
       Extract(3,
               3,
               4294967281 +
               Concat(16 + Extract(15, 0, x3), 0)),
       1)
((((x + 1) >> 4) & 1) >> 16) == Concat(0, Extract(0, 0, 1 + x3 >> 4)) >> 16
((((x + 5) & 2) + 8) >> 16) == Concat(2, Extract(1, 1, 5 + x3), 0) >> 16
((((x + 1) & 4) << 2) >> 16) == Concat(0, Extract(2, 2, 1 + x3), 0) >> 16
((((x + 1) & 1) >> 16) + 1) == 1 + (Concat(0, 1 + Extract(0, 0, x3)) >> 16)
((((x + 3) & 8) >> 16) << 16) == Concat(Extract(15,
               0,
               Concat(0, Extract(3, 3, 3 + x3), 0) >> 16),
       0)
((((x + 2) & 8) >> 16) >> 8) == Concat(0, Extract(3, 3, 2 + x3), 0) >> 24
((((x + 1) & 2) >> 16) & 2) == Concat(0,
       Extract(1,
               1,
               Concat(0, Extract(1, 1, 1 + x3), 0) >> 16),
       0)
rotl(((((x + 2) & 3) >> 16), 3)) == Concat(Extract(28,
               0,
               Concat(0, 2 + Extract(1, 0, x3)) >> 16),
       Extract(31,
               29,
               Concat(0, 2 + Extract(1, 0, x3)) >> 16))
rotr(((((x + 1) & 2) >> 16), 16)) == Concat(Extract(15,
               0,
               Concat(0, Extract(1, 1, 1 + x3), 0) >> 16),
       Extract(31,
               16,
               Concat(0, Extract(1, 1, 1 + x3), 0) >> 16))
((((x + 1) & 2) >> 16) ^ 10) == Concat(Extract(31,
               4,
               Concat(0, Extract(1, 1, 1 + x3), 0) >> 16),
       ~Extract(3,
                3,
                Concat(0, Extract(1, 1, 1 + x3), 0) >> 16),
       Extract(2,
               2,
               Concat(0, Extract(1, 1, 1 + x3), 0) >> 16),
       ~Extract(1,
                1,
                Concat(0, Extract(1, 1, 1 + x3), 0) >> 16),
       Extract(0,
               0,
               Concat(0, Extract(1, 1, 1 + x3), 0) >> 16))
(rotl((((x + 5) & 16), 1)) >> 16) == Concat(0, Extract(4, 4, 5 + x3), 0) >> 16
(rotr((((x + 13) & 4), 2)) >> 16) == Concat(0, Extract(2, 2, 13 + x3)) >> 16
((((x + 1) & 16) ^ 16) >> 16) == Concat(0, ~Extract(4, 4, 1 + x3), 0) >> 16
((((x + 4) & 12) - 8) & 2) == Concat(0,
       Extract(1,
               1,
               4294967288 +
               Concat(0, Extract(3, 2, 4 + x3), 0)),
       0)
((rotl(((x + 2), 1)) & 16) >> 16) == Concat(0, Extract(3, 3, 2 + Extract(30, 0, x3)), 0) >> 16
((rotr(((x + 2), 1)) & 2) >> 16) == Concat(0, Extract(2, 2, 2 + x3), 0) >> 16
((((x + 15) ^ 16) & 1) >> 16) == Concat(0, 1 + Extract(0, 0, x3)) >> 16
((((x + 5) - 15) & 1) >> 16) == Concat(0, Extract(0, 0, x3)) >> 16
((((x << 16) + 1) >> 4) & 11) == Concat(0,
       Extract(3, 3, Concat(Extract(15, 0, x3), 1) >> 4),
       0,
       Extract(1, 0, Concat(Extract(15, 0, x3), 1) >> 4))
rotl(((((x << 4) + 16) & 10), 1)) == Concat(0,
       Extract(3, 3, 16 + Concat(Extract(27, 0, x3), 0)),
       0,
       Extract(1, 1, 16 + Concat(Extract(27, 0, x3), 0)),
       0)
rotr(((((x << 3) + 16) & 4), 16)) == Concat(0,
       Extract(2, 2, 16 + Concat(Extract(28, 0, x3), 0)),
       0)
(rotl((((x << 4) + 16), 1)) & 10) == Concat(0,
       Extract(2, 2, 16 + Concat(Extract(26, 0, x3), 0)),
       0)
(rotr((((x << 16) + 16), 16)) >> 16) == Concat(16, Extract(15, 0, x3)) >> 16
(rotr((((x << 3) + 10), 2)) & 1) == Concat(0, Extract(2, 2, 10 + Concat(Extract(28, 0, x3), 0)))
((((x << 14) << 16) >> 10) << 16) == Concat(Extract(15, 0, Concat(Extract(1, 0, x3), 0) >> 10),
       0)
((((x << 14) << 5) >> 16) & 3) == Concat(0,
       Extract(1, 0, Concat(Extract(12, 0, x3), 0) >> 16))
(rotl((((x << 3) << 15), 14)) >> 14) == Concat(0, Extract(13, 0, x3)) >> 14

```

`scripts/opaque_predicates_expr_gen/generated.txt`:

```txt
((x << 16) & 6) == 0
((x & 16) & 7) == 0
(((x + 2) << 4) & 6) == 0
(((x + 6) & 3) & 12) == 0
(((x << 9) << 1) & 4) == 0
(((x << 3) & 4) + 4) == 4
(((x << 1) & 1) << 9) == 0
(((x << 16) & 6) & 6) == 0
(((x << 2) & 2) ^ 2) == 2
(((x << 9) ^ 11) & 11) == 11
(((x >> 10) << 16) & 6) == 0
(((x >> 6) & 11) & 4) == 0
(((x & 1) + 16) & 2) == 0
(((x & 11) << 4) & 6) == 0
(((x & 4) & 3) + 16) == 16
(((x & 4) & 2) << 12) == 0
(((x & 11) & 3) & 12) == 0
(((x & 2) & 1) ^ 2) == 2
(((x & 8) ^ 1) & 2) == 0
(((x & 8) - 14) & 3) == 2
(((x ^ 6) << 9) & 12) == 0
(((x ^ 8) & 2) & 16) == 0
(((x - 15) << 16) & 6) == 0
(((x - 10) & 3) & 12) == 0
((((x + 3) + 4) << 6) & 10) == 0
((((x + 1) + 3) & 2) & 12) == 0
((((x + 9) << 5) + 1) & 2) == 0
((((x + 2) << 15) << 2) & 2) == 0
((((x + 6) << 11) & 8) + 2) == 2
((((x + 4) << 2) & 3) << 10) == 0
((((x + 1) << 1) & 1) >> 16) == 0
((((x + 4) << 16) & 2) & 7) == 0
((((x + 2) << 16) & 14) ^ 15) == 15
((((x + 15) << 4) ^ 15) & 2) == 2
((((x + 7) >> 1) << 8) & 6) == 0
((((x + 1) >> 12) & 2) & 4) == 0
((((x + 6) & 8) + 8) & 3) == 0
((((x + 3) & 3) << 8) & 10) == 0
((((x + 10) & 2) & 12) + 1) == 1
((((x + 8) & 2) & 8) << 12) == 0
((((x + 1) & 1) & 16) >> 16) == 0
((((x + 15) & 3) & 2) & 1) == 0
((((x + 4) & 1) & 12) ^ 8) == 8
((((x + 8) & 4) ^ 8) & 1) == 0
((((x + 6) ^ 3) << 16) & 6) == 0
((((x + 2) ^ 2) & 3) & 12) == 0
((((x + 1) - 8) << 16) & 6) == 0
((((x + 1) - 2) & 2) & 4) == 0
((((x << 2) + 2) + 1) & 3) == 3
((((x << 2) + 1) << 1) & 2) == 2
((((x << 6) + 15) & 14) + 4) == 18
((((x << 9) + 3) & 7) << 12) == 12288
((((x << 2) + 1) & 2) >> 16) == 0
((((x << 9) + 7) & 14) & 6) == 6
((((x << 16) + 3) & 3) ^ 2) == 1
((((x << 6) + 16) & 16) - 3) == 13
((((x << 16) + 3) ^ 1) & 2) == 2
((((x << 9) + 8) - 15) & 3) == 1
((((x << 16) << 2) + 7) & 3) == 3
((((x << 16) << 16) << 16) << 16) == 0
((((x << 6) << 5) << 14) & 2) == 0
((((x << 1) << 16) & 13) + 6) == 6
((((x << 1) << 3) & 1) << 2) == 0
((((x << 16) << 16) & 1) >> 16) == 0
((((x << 16) << 16) & 2) & 1) == 0
((((x << 1) << 4) & 1) ^ 1) == 1

```

`scripts/opaque_predicates_expr_gen/main.py`:

```py
# I feel sorry for whoever would try to understand this stuff
from numpy import *
from z3 import *

import itertools

sz = 32  # bits
namei = 0


def name():
    global namei
    namei += 1
    return f'v{namei}'


def add_(solver: Solver) -> list:
    x = BitVec(name(), sz)
    return ['{lhs} + {rhs}', x, lambda val: val + x, 'as->add(x, zasm::Imm({rhs}))']


def shl_(solver: Solver) -> list:
    x = BitVec(name(), sz)
    return ['{lhs} << {rhs}', x, lambda val: val << x, 'as->shl(x, zasm::Imm({rhs}))']


def shr_(solver: Solver) -> list:
    x = BitVec(name(), sz)
    return ['{lhs} >> {rhs}', x, lambda val: val >> x, 'as->shr(x, zasm::Imm({rhs}))']


def and_(solver: Solver) -> list:
    x = BitVec(name(), sz)
    return ['{lhs} & {rhs}', x, lambda val: val & x, 'as->and_(x, zasm::Imm({rhs}))']


def or_(solver: Solver) -> list:
    x = BitVec(name(), sz)
    return ['{lhs} | {rhs}', x, lambda val: val | x, 'as->or_(x, zasm::Imm({rhs}))']


def rotl(solver: Solver) -> list:
    x = BitVec(name(), sz)
    return ['rotl({lhs}, {rhs})', x, lambda val: RotateLeft(val, x), 'as->rol(x, zasm::Imm({rhs}))']


def rotr(solver: Solver) -> list:
    x = BitVec(name(), sz)
    return ['rotr({lhs}, {rhs})', x, lambda val: RotateRight(val, x), 'as->ror(x, zasm::Imm({rhs}))']


def xor(solver: Solver) -> list:
    x = BitVec(name(), sz)
    return ['{lhs} ^ {rhs}', x, lambda val: val ^ x, 'as->xor_(x, zasm::Imm({rhs}))']


def sub(solver: Solver) -> list:
    x = BitVec(name(), sz)
    return ['{lhs} - {rhs}', x, lambda val: val - x, 'as->sub(x, zasm::Imm({rhs}))']


operations = [
    add_,
    shl_,
    shr_,
    and_,
    # or_,
    rotl,
    rotr,
    xor,
    sub,
]


def generate_all(num: int = 3) -> None:
    global namei
    for combination in itertools.product(operations, repeat=num):
        s = Solver()
        namei = 0
        startv = BitVec(name(), sz)

        vals = []
        strs = []
        zstrs = []
        lambdas = []

        for operation in combination:
            r = operation(s)
            zstrs.append(r[3])
            lambdas.append(r[2])
            vals.append(r[1])
            strs.append(r[0])

        cur = startv
        for i in range(len(combination)):
            cur = lambdas[i](cur)

        for i in range(len(vals)):
            s.add(vals[i] > 0, vals[i] <= (sz//2))

        x1, x2 = BitVecs('x1 x2', sz)
        s.add(x1 != x2)
        s.add(cur >= 0, cur <= 40960)

        expr1 = substitute(cur, (startv, x1,))
        expr2 = substitute(cur, (startv, x1,))

        if s.check(expr1 != expr2) != unsat:
            continue

        print(f'({num})', cur, '(checking)')

        counter = 0

        while s.check(expr1 == expr2) != unsat:
            counter += 1

            if counter >= 500:
                break

            m = s.model()
            evaluated_vals = []
            for val in vals:
                evaluated_vals.append(m[val].as_long())

            x3, x4 = BitVecs('x3 x4', sz)
            v = cur

            expr3 = substitute(v, (startv, x3,))
            expr4 = substitute(v, (startv, x4,))

            s.push()

            for i in range(len(vals)):
                s.add(vals[i] == evaluated_vals[i])

            if s.check(expr3 != expr4) != sat:
                sssttrrr = 'x'
                for i in range(len(vals)):
                    sssttrrr = strs[i].format(lhs='(' + sssttrrr, rhs=str(evaluated_vals[i])) + ')'

                vv = m.eval(expr3)
                try:
                    result = vv.as_long()
                except:  # noqa
                    with open('./errors.txt', 'a+') as f:
                        f.write(f'{sssttrrr} == {vv}\n')
                    break  # weird

                sssttrrr += ' == ' + str(result)

                try:
                    ev_check = eval(sssttrrr.replace('x', f'uint{sz}(-1)'))
                    for val_to_check in range(0x1337):
                        ev_check = ev_check and eval(sssttrrr.replace('x', f'uint{sz}({val_to_check})'))
                        if not ev_check:
                            break
                except:
                    ev_check = False

                if ev_check:
                    print(f'({num})', sssttrrr, '(matches)')

                    with open('./generated.txt', 'a+') as f:
                        f.write(sssttrrr + '\n')
                    with open('./zasm_generated.cpp', 'a+') as f:
                        f.write('// ' + sssttrrr + '\n')
                        for i in range(len(vals)):
                            f.write(zstrs[i].format(rhs=str(evaluated_vals[i])) + '\n')
                        f.write(f'as->cmp(x, zasm::Imm({result}))\n')
                        f.write('as->jz(successor_label)\n')
                        f.write('as->jmp(dead_branch_label)\n')
                        f.write('\n')

                    break
            s.pop()

            s.add(Not(And(*[vals[i] == evaluated_vals[i] for i in range(len(vals))])))


for N in range(2, 1337):
    generate_all(N)

```

`scripts/opaque_predicates_expr_gen/zasm_generated.cpp`:

```cpp
// ((x << 16) & 6) == 0
as->shl(x, zasm::Imm(16))
as->and_(x, zasm::Imm(6))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((x & 16) & 7) == 0
as->and_(x, zasm::Imm(16))
as->and_(x, zasm::Imm(7))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// (((x + 2) << 4) & 6) == 0
as->add(x, zasm::Imm(2))
as->shl(x, zasm::Imm(4))
as->and_(x, zasm::Imm(6))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// (((x + 6) & 3) & 12) == 0
as->add(x, zasm::Imm(6))
as->and_(x, zasm::Imm(3))
as->and_(x, zasm::Imm(12))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// (((x << 9) << 1) & 4) == 0
as->shl(x, zasm::Imm(9))
as->shl(x, zasm::Imm(1))
as->and_(x, zasm::Imm(4))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// (((x << 3) & 4) + 4) == 4
as->shl(x, zasm::Imm(3))
as->and_(x, zasm::Imm(4))
as->add(x, zasm::Imm(4))
as->cmp(x, zasm::Imm(4))
as->jz(successor_label)
as->jmp(dead_branch_label)

// (((x << 1) & 1) << 9) == 0
as->shl(x, zasm::Imm(1))
as->and_(x, zasm::Imm(1))
as->shl(x, zasm::Imm(9))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// (((x << 16) & 6) & 6) == 0
as->shl(x, zasm::Imm(16))
as->and_(x, zasm::Imm(6))
as->and_(x, zasm::Imm(6))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// (((x << 2) & 2) ^ 2) == 2
as->shl(x, zasm::Imm(2))
as->and_(x, zasm::Imm(2))
as->xor(x, zasm::Imm(2))
as->cmp(x, zasm::Imm(2))
as->jz(successor_label)
as->jmp(dead_branch_label)

// (((x << 9) ^ 11) & 11) == 11
as->shl(x, zasm::Imm(9))
as->xor(x, zasm::Imm(11))
as->and_(x, zasm::Imm(11))
as->cmp(x, zasm::Imm(11))
as->jz(successor_label)
as->jmp(dead_branch_label)

// (((x >> 10) << 16) & 6) == 0
as->shr(x, zasm::Imm(10))
as->shl(x, zasm::Imm(16))
as->and_(x, zasm::Imm(6))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// (((x >> 6) & 11) & 4) == 0
as->shr(x, zasm::Imm(6))
as->and_(x, zasm::Imm(11))
as->and_(x, zasm::Imm(4))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// (((x & 1) + 16) & 2) == 0
as->and_(x, zasm::Imm(1))
as->add(x, zasm::Imm(16))
as->and_(x, zasm::Imm(2))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// (((x & 11) << 4) & 6) == 0
as->and_(x, zasm::Imm(11))
as->shl(x, zasm::Imm(4))
as->and_(x, zasm::Imm(6))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// (((x & 4) & 3) + 16) == 16
as->and_(x, zasm::Imm(4))
as->and_(x, zasm::Imm(3))
as->add(x, zasm::Imm(16))
as->cmp(x, zasm::Imm(16))
as->jz(successor_label)
as->jmp(dead_branch_label)

// (((x & 4) & 2) << 12) == 0
as->and_(x, zasm::Imm(4))
as->and_(x, zasm::Imm(2))
as->shl(x, zasm::Imm(12))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// (((x & 11) & 3) & 12) == 0
as->and_(x, zasm::Imm(11))
as->and_(x, zasm::Imm(3))
as->and_(x, zasm::Imm(12))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// (((x & 2) & 1) ^ 2) == 2
as->and_(x, zasm::Imm(2))
as->and_(x, zasm::Imm(1))
as->xor(x, zasm::Imm(2))
as->cmp(x, zasm::Imm(2))
as->jz(successor_label)
as->jmp(dead_branch_label)

// (((x & 8) ^ 1) & 2) == 0
as->and_(x, zasm::Imm(8))
as->xor(x, zasm::Imm(1))
as->and_(x, zasm::Imm(2))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// (((x & 8) - 14) & 3) == 2
as->and_(x, zasm::Imm(8))
as->sub(x, zasm::Imm(14))
as->and_(x, zasm::Imm(3))
as->cmp(x, zasm::Imm(2))
as->jz(successor_label)
as->jmp(dead_branch_label)

// (((x ^ 6) << 9) & 12) == 0
as->xor(x, zasm::Imm(6))
as->shl(x, zasm::Imm(9))
as->and_(x, zasm::Imm(12))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// (((x ^ 8) & 2) & 16) == 0
as->xor(x, zasm::Imm(8))
as->and_(x, zasm::Imm(2))
as->and_(x, zasm::Imm(16))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// (((x - 15) << 16) & 6) == 0
as->sub(x, zasm::Imm(15))
as->shl(x, zasm::Imm(16))
as->and_(x, zasm::Imm(6))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// (((x - 10) & 3) & 12) == 0
as->sub(x, zasm::Imm(10))
as->and_(x, zasm::Imm(3))
as->and_(x, zasm::Imm(12))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x + 3) + 4) << 6) & 10) == 0
as->add(x, zasm::Imm(3))
as->add(x, zasm::Imm(4))
as->shl(x, zasm::Imm(6))
as->and_(x, zasm::Imm(10))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x + 1) + 3) & 2) & 12) == 0
as->add(x, zasm::Imm(1))
as->add(x, zasm::Imm(3))
as->and_(x, zasm::Imm(2))
as->and_(x, zasm::Imm(12))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x + 9) << 5) + 1) & 2) == 0
as->add(x, zasm::Imm(9))
as->shl(x, zasm::Imm(5))
as->add(x, zasm::Imm(1))
as->and_(x, zasm::Imm(2))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x + 2) << 15) << 2) & 2) == 0
as->add(x, zasm::Imm(2))
as->shl(x, zasm::Imm(15))
as->shl(x, zasm::Imm(2))
as->and_(x, zasm::Imm(2))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x + 6) << 11) & 8) + 2) == 2
as->add(x, zasm::Imm(6))
as->shl(x, zasm::Imm(11))
as->and_(x, zasm::Imm(8))
as->add(x, zasm::Imm(2))
as->cmp(x, zasm::Imm(2))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x + 4) << 2) & 3) << 10) == 0
as->add(x, zasm::Imm(4))
as->shl(x, zasm::Imm(2))
as->and_(x, zasm::Imm(3))
as->shl(x, zasm::Imm(10))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x + 1) << 1) & 1) >> 16) == 0
as->add(x, zasm::Imm(1))
as->shl(x, zasm::Imm(1))
as->and_(x, zasm::Imm(1))
as->shr(x, zasm::Imm(16))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x + 4) << 16) & 2) & 7) == 0
as->add(x, zasm::Imm(4))
as->shl(x, zasm::Imm(16))
as->and_(x, zasm::Imm(2))
as->and_(x, zasm::Imm(7))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x + 2) << 16) & 14) ^ 15) == 15
as->add(x, zasm::Imm(2))
as->shl(x, zasm::Imm(16))
as->and_(x, zasm::Imm(14))
as->xor(x, zasm::Imm(15))
as->cmp(x, zasm::Imm(15))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x + 15) << 4) ^ 15) & 2) == 2
as->add(x, zasm::Imm(15))
as->shl(x, zasm::Imm(4))
as->xor(x, zasm::Imm(15))
as->and_(x, zasm::Imm(2))
as->cmp(x, zasm::Imm(2))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x + 7) >> 1) << 8) & 6) == 0
as->add(x, zasm::Imm(7))
as->shr(x, zasm::Imm(1))
as->shl(x, zasm::Imm(8))
as->and_(x, zasm::Imm(6))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x + 1) >> 12) & 2) & 4) == 0
as->add(x, zasm::Imm(1))
as->shr(x, zasm::Imm(12))
as->and_(x, zasm::Imm(2))
as->and_(x, zasm::Imm(4))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x + 6) & 8) + 8) & 3) == 0
as->add(x, zasm::Imm(6))
as->and_(x, zasm::Imm(8))
as->add(x, zasm::Imm(8))
as->and_(x, zasm::Imm(3))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x + 3) & 3) << 8) & 10) == 0
as->add(x, zasm::Imm(3))
as->and_(x, zasm::Imm(3))
as->shl(x, zasm::Imm(8))
as->and_(x, zasm::Imm(10))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x + 10) & 2) & 12) + 1) == 1
as->add(x, zasm::Imm(10))
as->and_(x, zasm::Imm(2))
as->and_(x, zasm::Imm(12))
as->add(x, zasm::Imm(1))
as->cmp(x, zasm::Imm(1))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x + 8) & 2) & 8) << 12) == 0
as->add(x, zasm::Imm(8))
as->and_(x, zasm::Imm(2))
as->and_(x, zasm::Imm(8))
as->shl(x, zasm::Imm(12))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x + 1) & 1) & 16) >> 16) == 0
as->add(x, zasm::Imm(1))
as->and_(x, zasm::Imm(1))
as->and_(x, zasm::Imm(16))
as->shr(x, zasm::Imm(16))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x + 15) & 3) & 2) & 1) == 0
as->add(x, zasm::Imm(15))
as->and_(x, zasm::Imm(3))
as->and_(x, zasm::Imm(2))
as->and_(x, zasm::Imm(1))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x + 4) & 1) & 12) ^ 8) == 8
as->add(x, zasm::Imm(4))
as->and_(x, zasm::Imm(1))
as->and_(x, zasm::Imm(12))
as->xor(x, zasm::Imm(8))
as->cmp(x, zasm::Imm(8))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x + 8) & 4) ^ 8) & 1) == 0
as->add(x, zasm::Imm(8))
as->and_(x, zasm::Imm(4))
as->xor(x, zasm::Imm(8))
as->and_(x, zasm::Imm(1))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x + 6) ^ 3) << 16) & 6) == 0
as->add(x, zasm::Imm(6))
as->xor(x, zasm::Imm(3))
as->shl(x, zasm::Imm(16))
as->and_(x, zasm::Imm(6))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x + 2) ^ 2) & 3) & 12) == 0
as->add(x, zasm::Imm(2))
as->xor(x, zasm::Imm(2))
as->and_(x, zasm::Imm(3))
as->and_(x, zasm::Imm(12))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x + 1) - 8) << 16) & 6) == 0
as->add(x, zasm::Imm(1))
as->sub(x, zasm::Imm(8))
as->shl(x, zasm::Imm(16))
as->and_(x, zasm::Imm(6))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x + 1) - 2) & 2) & 4) == 0
as->add(x, zasm::Imm(1))
as->sub(x, zasm::Imm(2))
as->and_(x, zasm::Imm(2))
as->and_(x, zasm::Imm(4))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x << 2) + 2) + 1) & 3) == 3
as->shl(x, zasm::Imm(2))
as->add(x, zasm::Imm(2))
as->add(x, zasm::Imm(1))
as->and_(x, zasm::Imm(3))
as->cmp(x, zasm::Imm(3))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x << 2) + 1) << 1) & 2) == 2
as->shl(x, zasm::Imm(2))
as->add(x, zasm::Imm(1))
as->shl(x, zasm::Imm(1))
as->and_(x, zasm::Imm(2))
as->cmp(x, zasm::Imm(2))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x << 6) + 15) & 14) + 4) == 18
as->shl(x, zasm::Imm(6))
as->add(x, zasm::Imm(15))
as->and_(x, zasm::Imm(14))
as->add(x, zasm::Imm(4))
as->cmp(x, zasm::Imm(18))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x << 9) + 3) & 7) << 12) == 12288
as->shl(x, zasm::Imm(9))
as->add(x, zasm::Imm(3))
as->and_(x, zasm::Imm(7))
as->shl(x, zasm::Imm(12))
as->cmp(x, zasm::Imm(12288))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x << 2) + 1) & 2) >> 16) == 0
as->shl(x, zasm::Imm(2))
as->add(x, zasm::Imm(1))
as->and_(x, zasm::Imm(2))
as->shr(x, zasm::Imm(16))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x << 9) + 7) & 14) & 6) == 6
as->shl(x, zasm::Imm(9))
as->add(x, zasm::Imm(7))
as->and_(x, zasm::Imm(14))
as->and_(x, zasm::Imm(6))
as->cmp(x, zasm::Imm(6))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x << 16) + 3) & 3) ^ 2) == 1
as->shl(x, zasm::Imm(16))
as->add(x, zasm::Imm(3))
as->and_(x, zasm::Imm(3))
as->xor(x, zasm::Imm(2))
as->cmp(x, zasm::Imm(1))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x << 6) + 16) & 16) - 3) == 13
as->shl(x, zasm::Imm(6))
as->add(x, zasm::Imm(16))
as->and_(x, zasm::Imm(16))
as->sub(x, zasm::Imm(3))
as->cmp(x, zasm::Imm(13))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x << 16) + 3) ^ 1) & 2) == 2
as->shl(x, zasm::Imm(16))
as->add(x, zasm::Imm(3))
as->xor(x, zasm::Imm(1))
as->and_(x, zasm::Imm(2))
as->cmp(x, zasm::Imm(2))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x << 9) + 8) - 15) & 3) == 1
as->shl(x, zasm::Imm(9))
as->add(x, zasm::Imm(8))
as->sub(x, zasm::Imm(15))
as->and_(x, zasm::Imm(3))
as->cmp(x, zasm::Imm(1))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x << 16) << 2) + 7) & 3) == 3
as->shl(x, zasm::Imm(16))
as->shl(x, zasm::Imm(2))
as->add(x, zasm::Imm(7))
as->and_(x, zasm::Imm(3))
as->cmp(x, zasm::Imm(3))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x << 16) << 16) << 16) << 16) == 0
as->shl(x, zasm::Imm(16))
as->shl(x, zasm::Imm(16))
as->shl(x, zasm::Imm(16))
as->shl(x, zasm::Imm(16))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x << 6) << 5) << 14) & 2) == 0
as->shl(x, zasm::Imm(6))
as->shl(x, zasm::Imm(5))
as->shl(x, zasm::Imm(14))
as->and_(x, zasm::Imm(2))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x << 1) << 16) & 13) + 6) == 6
as->shl(x, zasm::Imm(1))
as->shl(x, zasm::Imm(16))
as->and_(x, zasm::Imm(13))
as->add(x, zasm::Imm(6))
as->cmp(x, zasm::Imm(6))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x << 1) << 3) & 1) << 2) == 0
as->shl(x, zasm::Imm(1))
as->shl(x, zasm::Imm(3))
as->and_(x, zasm::Imm(1))
as->shl(x, zasm::Imm(2))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x << 16) << 16) & 1) >> 16) == 0
as->shl(x, zasm::Imm(16))
as->shl(x, zasm::Imm(16))
as->and_(x, zasm::Imm(1))
as->shr(x, zasm::Imm(16))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x << 16) << 16) & 2) & 1) == 0
as->shl(x, zasm::Imm(16))
as->shl(x, zasm::Imm(16))
as->and_(x, zasm::Imm(2))
as->and_(x, zasm::Imm(1))
as->cmp(x, zasm::Imm(0))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x << 1) << 4) & 1) ^ 1) == 1
as->shl(x, zasm::Imm(1))
as->shl(x, zasm::Imm(4))
as->and_(x, zasm::Imm(1))
as->xor(x, zasm::Imm(1))
as->cmp(x, zasm::Imm(1))
as->jz(successor_label)
as->jmp(dead_branch_label)

// ((((x << 16) << 16) ^ 15) & 3) == 3
as->shl(x, zasm::Imm(16))
as->shl(x, zasm::Imm(16))
as->xor(x, zasm::Imm(15))
as->and_(x, zasm::Imm(3))
as->cmp(x, zasm::Imm(3))
as->jz(successor_label)
as->jmp(dead_branch_label)


```

`scripts/show_disasm.sh`:

```sh
#!/usr/bin/env sh

objdump --disassemble --x86-asm-syntax=intel -j .s_code $1

```

`src/CMakeLists.txt`:

```txt
# This file is automatically generated from cmake.toml - DO NOT EDIT
# See https://github.com/build-cpp/cmkr for more information

# Create a configure-time dependency on cmake.toml to improve IDE support
if(CMKR_ROOT_PROJECT)
	configure_file(cmake.toml cmake.toml COPYONLY)
endif()

# Target: obfuscator-lib
set(obfuscator-lib_SOURCES
	"lib/analysis/analysis.cpp"
	"lib/analysis/bb_decomp/bb_decomp.cpp"
	"lib/analysis/bb_decomp/jumptables.cpp"
	"lib/analysis/passes/misc/bb_insn_passes.cpp"
	"lib/config_parser/config_parser.cpp"
	"lib/easm/assembler/assembler.cpp"
	"lib/easm/disassembler/disassembler.cpp"
	"lib/func_parser/map/map.cpp"
	"lib/func_parser/parser.cpp"
	"lib/func_parser/pdb/detail/reader_v7.cpp"
	"lib/func_parser/pdb/pdb.cpp"
	"lib/mathop/operations/impl/add.cpp"
	"lib/mathop/operations/impl/dec.cpp"
	"lib/mathop/operations/impl/inc.cpp"
	"lib/mathop/operations/impl/neg.cpp"
	"lib/mathop/operations/impl/not.cpp"
	"lib/mathop/operations/impl/sub.cpp"
	"lib/mathop/operations/impl/xor.cpp"
	"lib/obfuscator/obfuscator.cpp"
	"lib/obfuscator/transforms/startup.cpp"
	"lib/pe/pe.cpp"
	"lib/pe/rebuilder/detail/copy_sections.cpp"
	"lib/pe/rebuilder/detail/init_header.cpp"
	"lib/pe/rebuilder/detail/update_checksum.cpp"
	"lib/pe/rebuilder/detail/update_relocations.cpp"
	"lib/analysis/analysis.hpp"
	"lib/analysis/bb_decomp/bb_decomp.hpp"
	"lib/analysis/common/common.hpp"
	"lib/analysis/common/debug.hpp"
	"lib/analysis/common/provider.hpp"
	"lib/analysis/lru_reg/lru_reg.hpp"
	"lib/analysis/observer/observer.hpp"
	"lib/analysis/passes/collect_img_references.hpp"
	"lib/analysis/passes/collect_lookup_table.hpp"
	"lib/analysis/passes/label_references.hpp"
	"lib/analysis/passes/lru_reg.hpp"
	"lib/analysis/passes/misc/bb_insn_passes.hpp"
	"lib/analysis/passes/reloc_marker.hpp"
	"lib/analysis/var_alloc/var_alloc.hpp"
	"lib/cli/cli.hpp"
	"lib/config_parser/config_parser.hpp"
	"lib/config_parser/structs.hpp"
	"lib/easm/assembler/assembler.hpp"
	"lib/easm/cursor/cursor.hpp"
	"lib/easm/debug/debug.hpp"
	"lib/easm/disassembler/disassembler.hpp"
	"lib/easm/easm.hpp"
	"lib/easm/misc/misc.hpp"
	"lib/easm/misc/reg_convert.hpp"
	"lib/func_parser/common/combiner.hpp"
	"lib/func_parser/common/common.hpp"
	"lib/func_parser/common/sanitizer.hpp"
	"lib/func_parser/map/map.hpp"
	"lib/func_parser/parser.hpp"
	"lib/func_parser/pdb/detail/parser_v7.hpp"
	"lib/func_parser/pdb/detail/structs.hpp"
	"lib/func_parser/pdb/pdb.hpp"
	"lib/mathop/mathop.hpp"
	"lib/mathop/operations/impl/util.hpp"
	"lib/mathop/operations/operation.hpp"
	"lib/mathop/operations/operations.hpp"
	"lib/obfuscator/config_merger/config_merger.hpp"
	"lib/obfuscator/function.hpp"
	"lib/obfuscator/obfuscator.hpp"
	"lib/obfuscator/transforms/configs.hpp"
	"lib/obfuscator/transforms/scheduler.hpp"
	"lib/obfuscator/transforms/transform.hpp"
	"lib/obfuscator/transforms/transforms/bogus_control_flow.hpp"
	"lib/obfuscator/transforms/transforms/constant_crypt.hpp"
	"lib/obfuscator/transforms/transforms/decomp_break.hpp"
	"lib/obfuscator/transforms/transforms/substitution.hpp"
	"lib/obfuscator/transforms/transforms/util/anti_decompilers.hpp"
	"lib/obfuscator/transforms/transforms/util/bcf.hpp"
	"lib/obfuscator/transforms/transforms/util/opaque_predicates.hpp"
	"lib/obfuscator/transforms/types.hpp"
	"lib/pe/arch/arch.hpp"
	"lib/pe/common/common.hpp"
	"lib/pe/common/types.hpp"
	"lib/pe/debug/debug.hpp"
	"lib/pe/pe.hpp"
	"lib/pe/rebuilder/detail/common.hpp"
	"lib/pe/rebuilder/rebuilder.hpp"
	"lib/util/defer.hpp"
	"lib/util/files.hpp"
	"lib/util/format.hpp"
	"lib/util/iterators.hpp"
	"lib/util/logger.hpp"
	"lib/util/memory/address.hpp"
	"lib/util/memory/casts.hpp"
	"lib/util/memory/reader.hpp"
	"lib/util/passes.hpp"
	"lib/util/platform.hpp"
	"lib/util/progress.hpp"
	"lib/util/random.hpp"
	"lib/util/sections.hpp"
	"lib/util/stopwatch.hpp"
	"lib/util/string_parser.hpp"
	"lib/util/structs.hpp"
	"lib/util/types.hpp"
)

add_library(obfuscator-lib INTERFACE)

target_sources(obfuscator-lib INTERFACE ${obfuscator-lib_SOURCES})
source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${obfuscator-lib_SOURCES})

add_library(obfuscator::lib ALIAS obfuscator-lib)
target_compile_features(obfuscator-lib INTERFACE
	cxx_std_23
)

target_include_directories(obfuscator-lib INTERFACE
	"lib/"
)

target_link_libraries(obfuscator-lib INTERFACE
	zasm
	linux-pe
	magic_enum
)

# Target: obfuscator
set(obfuscator_SOURCES
	"bin/entry.cpp"
	cmake.toml
)

add_executable(obfuscator)

target_sources(obfuscator PRIVATE ${obfuscator_SOURCES})
source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${obfuscator_SOURCES})

target_compile_definitions(obfuscator PRIVATE
	NOMINMAX
)

target_compile_features(obfuscator PRIVATE
	cxx_std_23
)

if(UNIX) # unix
	target_compile_options(obfuscator PRIVATE
		-stdlib=libc++
	)
endif()

if(MSVC) # msvc
	target_compile_options(obfuscator PRIVATE
		"/wd4661"
		"/MP"
	)
endif()

if(UNIX) # unix
	target_link_options(obfuscator PRIVATE
		-fuse-ld=lld
		"-Wl,-L/usr/local/lib/"
	)
endif()

target_include_directories(obfuscator PRIVATE
	"bin/"
)

target_link_libraries(obfuscator PRIVATE
	obfuscator::lib
)

get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
if(NOT CMKR_VS_STARTUP_PROJECT)
	set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT obfuscator)
endif()

# Target: obfuscator-tests
if(OBFUSCATOR_BUILD_TESTS) # build-tests
	set(obfuscator-tests_SOURCES
		"tests/analysis/bb_decomp/bb_decomp.llvm.cpp"
		"tests/analysis/bb_decomp/bb_decomp.msvc.cpp"
		"tests/func_parser/map/map.ida.cpp"
		"tests/func_parser/map/map.llvm.cpp"
		"tests/func_parser/map/map.msvc.cpp"
		"tests/func_parser/pdb/pdb.llvm.cpp"
		"tests/func_parser/pdb/pdb.msvc.cpp"
		"tests/tests_util.hpp"
		cmake.toml
	)

	add_executable(obfuscator-tests)

	target_sources(obfuscator-tests PRIVATE ${obfuscator-tests_SOURCES})
	source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${obfuscator-tests_SOURCES})

	target_compile_definitions(obfuscator-tests PRIVATE
		NOMINMAX
	)

	target_compile_features(obfuscator-tests PRIVATE
		cxx_std_23
	)

	if(UNIX) # unix
		target_compile_options(obfuscator-tests PRIVATE
			-stdlib=libc++
		)
	endif()

	if(MSVC) # msvc
		target_compile_options(obfuscator-tests PRIVATE
			"/wd4661"
			"/MP"
		)
	endif()

	if(UNIX) # unix
		target_link_options(obfuscator-tests PRIVATE
			-fuse-ld=lld
			"-Wl,-L/usr/local/lib/"
		)
	endif()

	target_include_directories(obfuscator-tests PRIVATE
		"tests/"
	)

	target_link_libraries(obfuscator-tests PRIVATE
		obfuscator::lib
		GTest::gtest_main
	)

	set_target_properties(obfuscator-tests PROPERTIES
		PROJECT_LABEL
			tests
	)

	get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
	if(NOT CMKR_VS_STARTUP_PROJECT)
		set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT obfuscator-tests)
	endif()

	set(CMKR_TARGET obfuscator-tests)
	FetchContent_MakeAvailable(resources)
	target_compile_definitions(obfuscator-tests PRIVATE OBFUSCATOR_RESOURCES_PATH="${resources_SOURCE_DIR}")

endif()
enable_testing()

if(OBFUSCATOR_BUILD_TESTS) # build-tests
	add_test(
		NAME
			tests
		WORKING_DIRECTORY
			"${CMAKE_CURRENT_LIST_DIR}/"
		COMMAND
			"$<TARGET_FILE:obfuscator-tests>"
	)

endif()

```

`src/bin/entry.cpp`:

```cpp
#include "config_parser/config_parser.hpp"
#include "obfuscator/obfuscator.hpp"
#include "obfuscator/transforms/scheduler.hpp"
#include "pe/arch/arch.hpp"
#include "pe/common/common.hpp"
#include "util/files.hpp"
#include "util/logger.hpp"
#include "util/random.hpp"

namespace {
    template <pe::any_raw_image_t Img>
    void bootstrap(Img* raw_image, config_parser::Config& config) {
        pe::Image<Img> image(raw_image);

        obfuscator::Instance<decltype(image)> inst(&image, config);
        inst.setup();
        inst.obfuscate();
        inst.assemble();
        inst.save();

        logger::info("startup: bye-bye");
    }

    int startup(const int argc, char* argv[]) try {
        rnd::detail::seed();
        obfuscator::startup_scheduler();

        auto config = config_parser::from_argv(argc, argv);

        const auto binary_path = config.obfuscator_config().binary_path;

        logger::info("main: loading binary from {}", binary_path.string());
        auto file = util::read_file(binary_path);
        if (file.empty()) {
            throw std::runtime_error("Got empty binary");
        }

        // NOLINTNEXTLINE
        auto* img_x64 = reinterpret_cast<win::image_x64_t*>(file.data());
        // NOLINTNEXTLINE
        auto* img_x86 = reinterpret_cast<win::image_x86_t*>(file.data());

        if (!pe::common::is_valid(img_x64)) {
            throw std::runtime_error("Invalid pe header");
        }

        if (pe::arch::is_x64(img_x64)) {
            bootstrap(img_x64, config);
        } else {
            bootstrap(img_x86, config);
        }

        return 0;
    } catch (std::runtime_error& err) {
        logger::critical("RUNTIME ERROR: {}", err.what());
        return 1;
    }
} // namespace

int main(const int argc, char* argv[]) {
    return startup(argc, argv);
}

```

`src/cmake.toml`:

```toml
[template.obfuscator-executable]
type = "executable"
compile-features = ["cxx_std_23"]
compile-definitions = ["NOMINMAX"]
unix.compile-options = [
    "-stdlib=libc++",
    # "-Wall", "-Wextra", "-Wpedantic", "-Wno-nested-anon-types", "-Wno-gnu-anonymous-struct", "-Wno-unused-function",
]
unix.link-options = ["-fuse-ld=lld", "-Wl,-L/usr/local/lib/"]
msvc.compile-options = ["/wd4661", "/MP"]


[target.obfuscator-lib]
alias = "obfuscator::lib"
type = "interface"
compile-features = ["cxx_std_23"]
include-directories = ["lib/"]
sources = ["lib/**.cpp", "lib/**.hpp"]
link-libraries = [
    "zasm",
    "linux-pe",
    "magic_enum",
]


[target.obfuscator]
type = "obfuscator-executable"
sources = ["bin/**.cpp", "bin/**.hpp"]
include-directories = ["bin/"]
link-libraries = ["obfuscator::lib"]


[target.obfuscator-tests]
condition = "build-tests"
type = "obfuscator-executable"
sources = ["tests/**.cpp", "tests/**.hpp"]
include-directories = ["tests/"]
link-libraries = ["obfuscator::lib", "GTest::gtest_main"]
cmake-after = """
FetchContent_MakeAvailable(resources)
target_compile_definitions(obfuscator-tests PRIVATE OBFUSCATOR_RESOURCES_PATH="${resources_SOURCE_DIR}")
"""


[target.obfuscator-tests.properties]
PROJECT_LABEL = "tests"


[[test]]
condition = "build-tests"
name = "tests"
command = "$<TARGET_FILE:obfuscator-tests>"

```

`src/lib/analysis/analysis.cpp`:

```cpp
#include "analysis/analysis.hpp"
#include "util/passes.hpp"

#include "analysis/passes/label_references.hpp"
#include "analysis/passes/misc/bb_insn_passes.hpp"

namespace analysis {
    template <pe::any_image_t Img>
    void Function<Img>::apply_passes(Img* image) {
        // \note: @es3n1n: for the apply_bb/apply_insn callbacks please check out the file
        // `analysis/transforms/misc/bb_insn_passes.hpp`, pass that would need to iter bb/insns
        // by themselves should be inserted here
        //
        ::passes::apply< //
            passes::bb_insn_passes_t<Img>, //
            passes::label_references_t<Img> //
            >(this, image);
    }

    template <pe::any_image_t Img>
    void Function<Img>::calc_range() {
        // Reset state
        //
        range.start = ULLONG_MAX;
        range.end = nullptr;

        // Iterating over instructions and updating range
        //
        bb_storage->iter_insns([this](const insn_t& instruction) -> void {
            if (!instruction.rva.has_value()) {
                return;
            }

            if (instruction.rva < range.start) {
                range.start = *instruction.rva;
            }

            if (instruction.rva > range.end) {
                range.end = *instruction.rva;
            }
        });
    }

    PE_DECL_TEMPLATE_CLASSES(Function);
} // namespace analysis

```

`src/lib/analysis/analysis.hpp`:

```hpp
#pragma once
#include "analysis/bb_decomp/bb_decomp.hpp"
#include "analysis/common/common.hpp"
#include "analysis/lru_reg/lru_reg.hpp"
#include "func_parser/parser.hpp"
#include "observer/observer.hpp"
#include "util/types.hpp"

#include <list>

namespace analysis {
    template <pe::any_image_t Img>
    class Function {
    public:
        Function(Img* image, const func_parser::function_t& func): parsed_func(func) {
            bb_decomp::Instance<Img> bb_decomp_inst(image, func.rva, func.size);
            bb_storage = bb_decomp_inst.export_blocks();
            program = bb_decomp_inst.export_program();

            calc_range();

            /// Init the bb provider
            bb_provider = std::make_shared<functional_bb_provider_t>();

            /// Set RVA finder
            bb_provider->set_rva_finder([storage = bb_storage.get()](const rva_t rva, bb_t*) -> std::optional<std::shared_ptr<bb_t>> {
                /// Find by RVA
                auto it = std::ranges::find_if(storage->basic_blocks, [rva](auto&& bb) -> bool {
                    return bb->start_rva.has_value() && bb->start_rva.value() == rva; //
                });

                /// Return wrapped in optional
                return it == std::end(storage->basic_blocks) ? std::nullopt : std::make_optional(*it);
            });

            /// Set VA finder
            bb_provider->set_va_finder([img_base = image->raw_image->get_nt_headers()->optional_header.image_base,
                                        provider = bb_provider.get()](const rva_t va, bb_t* callee) -> std::optional<std::shared_ptr<bb_t>> {
                /// Substract base and find by RVA
                return provider->find_by_start_rva(va - img_base, callee); //
            });

            /// Set Label finder
            bb_provider->set_label_finder([storage = bb_storage.get()](const zasm::Label* label, bb_t*) -> std::optional<std::shared_ptr<bb_t>> {
                for (auto& bb : storage->basic_blocks) {
                    /// Continue if bb doesn't contain this label
                    if (!bb->contains_label(label->getId())) {
                        continue;
                    }

                    return bb;
                }

                return std::nullopt;
            });

            /// Set reference acquire callback
            bb_provider->set_ref_acquire([storage = bb_storage.get()](const bb_t* bb) -> std::optional<std::shared_ptr<bb_t>> {
                /// Try to find by ptr
                auto it = std::ranges::find_if(storage->basic_blocks, [bb](const auto& p) -> bool {
                    return p.get() == bb; //
                });

                /// Not found
                if (it == std::end(storage->basic_blocks)) {
                    return std::nullopt;
                }

                /// Found
                return std::make_optional(*it);
            });

            assembler = std::make_shared<zasm::x86::Assembler>(*program);
            observer = std::make_shared<Observer>(program, bb_storage, bb_provider);

            apply_passes(image);
        }

        ~Function() = default;
        Function(const Function& instance)
            : program(instance.program), assembler(instance.assembler), observer(instance.observer), bb_storage(instance.bb_storage),
              parsed_func(instance.parsed_func), range(instance.range), lru_reg(instance.lru_reg), bb_provider(instance.bb_provider) { }

    private:
        void apply_passes(Img* image);
        void calc_range();

    public:
        // A zasm program instance that contains all of our instructions
        //
        std::shared_ptr<zasm::Program> program;
        std::shared_ptr<zasm::x86::Assembler> assembler;
        std::shared_ptr<Observer> observer;

        // A list of split basic blocks
        //
        std::shared_ptr<bb_storage_t> bb_storage;

        // Info about the function from the .map/.pdb files
        //
        func_parser::function_t parsed_func;

        // A start/end range of function
        //
        types::range_t range;

        // Least recently used register info
        //
        LRUReg<Img> lru_reg;

        // A list of references within the image, key is the instruction and value is RVA
        // it referenced
        //
        std::unordered_map<rva_t, std::list<insn_t*>> image_references;

        // A lookup table with key set to insn rva and value is the ptr to insn info,
        // \fixme: @es3n1n: ptr could be invalid at some point
        //
        std::unordered_map<rva_t, insn_t*> instructions_lookup = {};

        // BB Provider
        //
        std::shared_ptr<functional_bb_provider_t> bb_provider = {};
    };

    template <pe::any_image_t Img>
    Function<Img> analyse(Img* image, const func_parser::function_t& function) {
        auto result = Function<Img>(image, function);
        logger::debug("analysis: analysed function {}", function);
        return result;
    }
} // namespace analysis

```

`src/lib/analysis/bb_decomp/bb_decomp.cpp`:

```cpp
#include "analysis/bb_decomp/bb_decomp.hpp"
#include "analysis/common/debug.hpp"
#include "util/logger.hpp"

namespace analysis::bb_decomp {
    template <pe::any_image_t Img>
    void Instance<Img>::collect() {
        // First of all, we should clear the previous results just in case
        //
        clear();

        // Setup the bb provider
        //
        const auto img_base = image_->raw_image->get_nt_headers()->optional_header.image_base;

        // Make successor proxy
        bb_provider_->set_va_finder([this, img_base](const rva_t va, const bb_t* callee) {
            return make_successor(va - img_base, callee); //
        });

        // Make successor proxy
        bb_provider_->set_rva_finder([this](const rva_t rva, const bb_t* callee) {
            return make_successor(rva, callee); //
        });

        // Ref acquire
        bb_provider_->set_ref_acquire([this](const bb_t* bb) -> std::optional<std::shared_ptr<bb_t>> {
            /// Try to find in basic_blocks_ first
            auto it = std::ranges::find_if(basic_blocks_, [bb](const auto& pair) -> bool {
                return pair.second.get() == bb; //
            });
            if (it != std::end(basic_blocks_)) {
                return it->second;
            }

            /// Try to find in virtual basic blocks
            auto vit = std::ranges::find_if(virtual_basic_blocks_, [bb](const auto& value) -> bool {
                return value.get() == bb; //
            });
            if (vit != std::end(virtual_basic_blocks_)) {
                return *vit;
            }

            /// Not found :shrug:
            return std::nullopt;
        });

        // Label finder
        bb_provider_->set_label_finder([this](const zasm::Label* label, bb_t*) -> std::optional<std::shared_ptr<bb_t>> {
            // Searching in basic blocks with rvas first
            for (auto& bb : std::views::values(basic_blocks_)) {
                if (!bb->contains_label(label->getId())) {
                    continue;
                }

                return bb;
            }

            // Searching in virtual basic blocks
            for (auto& bb : virtual_basic_blocks_) {
                if (!bb->contains_label(label->getId())) {
                    continue;
                }

                return bb;
            }

            // Not found
            return std::nullopt;
        });

        // Starting with the first basic block, and it will process others automatically
        //
        logger::info("bb_decomp: running phase 1");
        process_bb(function_start_);

        // Expand jumptables
        //
        logger::info("bb_decomp: running phase 2");
        collect_jumptables();
        collect_jumptable_entries();

        // Splitting basic blocks (pt.1)
        //
        logger::info("bb_decomp: running phase 3");
        split();
        update_refs();

        // Expand jumptables and split basic blocks one more time
        //
        logger::info("bb_decomp: running phase 4");
        expand_jumptables();
        update_rescheduled_cf();
        update_refs();
        split();

        // Insert jmps to successors
        //
        logger::info("bb_decomp: running phase 5");
        update_refs();
        insert_jmps();

        // Sanitizing blocks
        //
        logger::info("bb_decomp: running phase 6");
        sanitize();
        update_tree();
        // dump();
    }

    template <pe::any_image_t Img>
    std::shared_ptr<bb_t> Instance<Img>::process_bb(const rva_t rva) {
        // Initialising stuff
        // \fixme: @es3n1n: override `get_nt_headers` in `pe::Image` class
        const std::uint64_t image_base = image_->raw_image->get_nt_headers()->optional_header.image_base;
        const memory::address virtual_address = rva + image_base;
        const std::uint8_t* data_start = image_->rva_to_ptr(static_cast<std::uint32_t>(rva.inner()));

        // Init basic block info
        //
        auto result = at(rva);
        result->flags.valid = true;

        // Initializing state
        //
        std::expected<zasm::InstructionDetail, zasm::Error> insn = std::unexpected(zasm::Error::None);

        // Iterating over BBs instructions
        //
        for (std::size_t offset = 0; !is_rva_oob(rva + offset); offset += insn->getLength()) {
            // Decoding instruction
            //
            insn = decoder_.decode_insn_detail(data_start + offset, easm::kDefaultSize, (virtual_address + offset).inner());
            if (!insn) {
                throw std::runtime_error(std::format("Unable to decode data at {:#x}", rva + offset));
            }

            // Encoding instruction to our program
            //
            if (auto assembler_result = assembler_->emit(insn->getInstruction()); assembler_result != zasm::Error::None) {
                throw std::runtime_error(std::format("Unable to encode decoded data at {:#x} -> {}", rva + offset, static_cast<int>(assembler_result)));
            }

            // Saving instruction to the current BB struct
            //
            const auto insn_desc = push_last_instruction(result, rva + offset, insn->getLength());

            // Asserting reference
            //
            if (insn_desc->ref == nullptr) [[unlikely]] {
                throw std::runtime_error(std::format("Unable to obtain ref to the decoded data at {:#x}", rva + offset));
            }

            // Breaking on `ret` detail
            //
            if (easm::is_ret(*insn)) {
                break;
            }

            // Ignoring anything that wouldn't affect IP
            //
            if (!insn_desc->is_jump() && !(insn_desc->flags & UNABLE_TO_ESTIMATE_JCC)) {
                continue;
            }

            // Ending bb as soon as we hit JCC/JMP
            //
            break;
        }

        // Calculating ranges
        //
        result->update_ranges(true);
        return result;
    }

    template <pe::any_image_t Img>
    void Instance<Img>::update_refs() {
        /// Remove stuff that was marked as to be deleted
        sanitize();

        logger::debug("bb_decomp: updating BB references..");

        /// Collect all the current instructions that should be present within this program
        std::unordered_map<insn_t*, bb_t*> insns = {};
        for (auto& bb : std::views::values(basic_blocks_)) {
            for (auto& insn : *bb) {
                insns[insn.get()] = bb.get();
            }
        }

        /// Sum stats
        std::size_t weird_nodes = 0;

        for (auto node = program_->getHead(); node != nullptr; node = node->getNext()) {
            const auto user_data = node->getUserDataU64();

            // Weird, but ok
            if (user_data == 0) {
                if (node->holds<zasm::Label>() || node->holds<zasm::Instruction>()) {
                    weird_nodes++;
                }

                continue;
            }

            // This is kinda unsafe but whatever..
            auto* pinsn = memory::cast<insn_t*>(user_data);
            pinsn->node_ref = node;
            pinsn->ref = node->getIf<zasm::Instruction>();

            // This node is up2date, we can remove it as we checked it
            if (insns.contains(pinsn)) {
                insns.erase(pinsn);
            }
        }

        // Print stats, if needed
        if (weird_nodes > 0) {
            logger::warn("bb_decomp: got {} weird nodes while updating refs", weird_nodes);
        }

        // Remove oudated nodes that doesn't present in program
        if (!insns.empty()) [[unlikely]] {
            logger::warn("bb_decomp: got {} outdated nodes while updating refs", insns.size());

            for (auto& [insn, bb] : insns) {
                std::erase_if(bb->instructions, [insn](const std::shared_ptr<insn_t>& item) -> bool { return item.get() == insn; });
            }
        }
    }

    template <pe::any_image_t Img>
    void Instance<Img>::split() {
        /// \note @es3n1n: Looks kinda scary, but splitting 2k+ basic blocks took me ~350ms so
        /// i guess we'll keep it as it is (PR welcome), perhaps an interval/segment tree could be used here
        logger::debug("analysis: splitting BBs..");
        bool split_something;

        // Splitting while there's something to split
        //
        do {
            // Resetting state
            //
            split_something = false;

            // Iterating over BBs
            //
            for (auto& [address, bb] : basic_blocks_) {
                assert(bb->start_rva.has_value()); // wtf

                // Iterating over other BBs
                //
                for (auto& [address_2, bb_2] : basic_blocks_) {
                    // Skipping the same block
                    //
                    if (address == address_2) {
                        continue;
                    }

                    assert(bb_2->start_rva.has_value()); // wtf

                    // Continue if our block is not a part of the bb_2
                    //
                    if (!(*bb->start_rva >= *bb_2->start_rva && *bb->start_rva <= *bb_2->end_rva)) {
                        continue;
                    }

                    // Mark as split
                    //
                    split_something = true;

                    // Iterating over instructions and shrinking the ones that we already have in our BB
                    //
                    std::erase_if(bb_2->instructions, [this, bb](const std::shared_ptr<insn_t>& insn) -> bool {
                        // Removing `bb` instructions from the `bb_2`
                        //
                        // const bool should_remove = std::ranges::find_if(bb, [insn](const insn_t& insn2) -> bool {
                        //                                return insn.node_ref == insn2.node_ref; // we should remove duplicated stuff
                        //                            }) != std::end(bb);

                        // ignore insns without rvas
                        if (!insn->rva.has_value()) {
                            return false;
                        }

                        const bool should_remove = *insn->rva >= *bb->start_rva && *insn->rva <= *bb->end_rva;

                        // \fixme: @es3n1n: kinda sucks that we have to manually remove nodes, but whatever i guess
                        //
                        if (should_remove) {
                            this->program_->destroy(insn->node_ref);
                        }

                        // Returning result
                        //
                        return should_remove;
                    });

                    // Updating ranges since we modified the instruction set
                    //
                    bb_2->update_ranges(true);

                    // Updating successors of the basic block that contains instructions from the `bb_2`
                    //
                    for (auto& successor : bb_2->successors) {
                        bb->push_successor(successor);
                    }

                    // Updating predecessors because obviously it would contain the `bb_2` now
                    //
                    bb->push_predecessor(bb_2);

                    // Since we merged the successors from this list we can clear it and set to the `bb`
                    //
                    bb_2->successors.clear();
                    bb_2->push_successor(bb);

                    // Exit from loop
                    //
                    break;
                }

                // Exit from loop once we split something
                //
                if (split_something) {
                    break;
                }
            }
        } while (split_something);
    }

    template <pe::any_image_t Img>
    void Instance<Img>::sanitize() {
        const auto erased_bbs = std::erase_if(basic_blocks_, [](auto& basic_block) -> bool {
            const auto nodes_erased = std::erase_if(basic_block.second->instructions, [](auto& insn) -> bool {
                return insn->flags & TO_BE_REMOVED; //
            });

            if (nodes_erased > 0) {
                logger::debug("bb_decomp: sanitized {} nodes", nodes_erased);
            }

            return !basic_block.second->flags.valid;
        });

        if (erased_bbs > 0) {
            logger::debug("bb_decomp: sanitized {} basic blocks", erased_bbs);
        }
    }

    template <pe::any_image_t Img>
    void Instance<Img>::insert_jmps() {
        logger::debug("bb_decomp: veryfing BB intersections..");
        /// Lookup for the basic blocks that for some reason aren't jumping to their successor(s)
        for (auto& [rva, bb] : basic_blocks_) {
            if (bb->instructions.empty()) [[unlikely]] {
                continue;
            }

            auto& last_insn = bb->instructions.at(bb->size() - 1);
            const auto last_mnemonic = last_insn->ref->getMnemonic().value();

            /// Looks legit, i think?
            if (last_mnemonic == ZYDIS_MNEMONIC_JMP || last_mnemonic == ZYDIS_MNEMONIC_RET) {
                continue;
            }

            /// Skip stuff that we added by ourselves
            if (!last_insn->rva.has_value()) {
                continue;
            }

            /// Get the expected next bb
            auto expected_cf_next_bb = std::ranges::find_if(last_insn->cf, [](auto& cf_info) -> bool {
                switch (cf_info.type) {
                case cf_direction_t::e_type::JCC_CONDITION_NOT_MET:
                case cf_direction_t::e_type::JMP:
                    return true;
                default:
                    return false;
                }
            });
            auto* expected_next_bb = expected_cf_next_bb != std::end(last_insn->cf) ? expected_cf_next_bb->bb.get() : nullptr;

            /// If we didn't find it via CF info, then try to get the first successor
            if (expected_next_bb == nullptr) {
                assert(bb->successors.size() == 1);
                expected_next_bb = bb->successors.at(0).get();
            }

            /// Let's see if we end up on a successor after this node
            zasm::Node* next_node = last_insn->node_ref->getNext();
            while (next_node != nullptr && !next_node->holds<zasm::Instruction>())
                next_node = next_node->getNext();

            /// If there's no next node, then we totally should insert a jmp
            if (next_node != nullptr) {
                /// Get the next instruction analysis info
                const auto next_insn = next_node->getUserData<insn_t>();
                if (next_insn == nullptr || !next_insn->rva.has_value()) [[unlikely]] {
                    continue;
                }

                /// Get the next instruction bb
                auto next_bb = basic_blocks_.find(next_insn->rva.value());
                if (next_bb == std::end(basic_blocks_)) [[unlikely]] {
                    assert(false); // weird
                    continue;
                }

                /// Verify that the next BB is the expected one
                if (expected_next_bb == next_bb->second.get()) {
                    continue;
                }
            }

            /// We need to adjust this thing otherwise

            /// Create a label
            auto label = program_->createLabel();

            /// Bind this label to the beginning of the next bb
            assembler_->setCursor(expected_next_bb->node_at(0)->getPrev());
            assembler_->bind(label);
            push_last_label(expected_next_bb);

            /// Place the jmp
            assembler_->setCursor(last_insn->node_ref);
            assembler_->jmp(label);
            (void)push_last_instruction(bb);

            /// Theoretically now we should jump where we should?
        }
    }

    template <pe::any_image_t Img>
    void Instance<Img>::update_rescheduled_cf() {
        logger::debug("bb_decomp: updating rescheduled CF..");

        /// Iterating over the all basic blocks
        for (auto& bb : std::views::values(basic_blocks_)) {
            /// Trying to find the insn with CF changers
            const auto& last_insn = bb->instructions.at(bb->size() - 1);

            /// No CF info
            if (last_insn->cf.empty()) {
                continue;
            }

            /// Trying to find rescheduled CF changers
            for (auto& cf_changer : last_insn->cf) {
                /// Not rescheduled
                if (!cf_changer.rescheduled) {
                    continue;
                }

                /// Unset rescheduled flag
                cf_changer.rescheduled = false;
                cf_changer.rescheduled_va = std::nullopt;

                /// Discovering BB by VA
                if (cf_changer.rescheduled_va.has_value()) {
                    auto new_bb = bb_provider_->find_by_start_va(cf_changer.rescheduled_va.value(), bb.get());
                    assert(new_bb.has_value());
                    cf_changer.bb = new_bb.value();
                    continue;
                }

                /// Discovering "next" instruction
                auto* next_node = last_insn->node_ref->getNext();
                while (next_node != nullptr && !next_node->holds<zasm::Instruction>()) {
                    next_node = next_node->getNext();
                }

                assert(next_node != nullptr);

                /// Storing its BB
                const auto* analysis_info = next_node->getUserData<insn_t>();
                auto acquired_ref = bb_provider_->acquire_ref(analysis_info->bb_ref);
                assert(acquired_ref.has_value());
                cf_changer.bb = acquired_ref.value();
            }
        }
    }

    template <pe::any_image_t Img>
    void Instance<Img>::update_tree() {
        logger::debug("bb_decomp: updating the BB tree.. (this could take some time)");

        /// Since we splitted/merged some basic blocks, there could be some
        /// issues since we merged successors/predecessors list and it could
        /// contain some multiple "dead" nodes, that we should update manually

        /// Step 0. Clear all predecessors info
        /// We cannot do this in the Step 1
        for (auto& bb : std::views::values(basic_blocks_)) {
            bb->predecessors.clear();
        }

        /// Step 1. Updating successors
        for (auto& [start, bb] : basic_blocks_) {
            /// Remove all the "outdated" info
            bb->successors.clear();

            /// Looking for the dead CF changer refs
            /// (because since we're splitting them, the dst bb could've been already deleted at some point)
            for (auto it = bb->instructions.rbegin(); it != bb->instructions.rend(); std::advance(it, 1)) {
                const auto insn = *it;
                if (insn->cf.empty()) {
                    continue;
                }

                /// Found an instruction that changes the CF, there should be
                /// only 1 such function in BB

                /// Iterating over its entries and updating the BB references
                for (auto& cf_changer : insn->cf) {
                    /// Skip virtual bbs
                    /// \fixme @es3n1n: This could be a problem in the future
                    /// \todo @es3n1n: bb->is_virtual() instead of these checks
                    if (!cf_changer.bb->start_rva.has_value()) {
                        continue;
                    }

                    /// Update the ref
                    auto bb_it = basic_blocks_.find(cf_changer.bb->start_rva.value());
                    if (bb_it == std::end(basic_blocks_)) {
                        throw std::runtime_error("analysis: unable to update CF reference");
                    }
                    cf_changer.bb = bb_it->second;

                    /// Remember this BB as a successor
                    bb->successors.emplace_back(cf_changer.bb);
                }
                break;
            }

            /// If it wasn't already initialized by the CF changer
            if (bb->successors.empty()) {
                /// "Linear" CF

                /// Looking up for the next BBs
                auto* last_node = bb->instructions.at(bb->size() - 1)->node_ref->getNext();
                while (last_node != nullptr && !last_node->holds<zasm::Instruction>()) {
                    last_node = last_node->getNext();
                }

                /// No next instruction :shrug:
                if (last_node == nullptr) {
                    continue;
                }

                /// Get its BB and emplace it as the successor
                const auto* analysis_info = last_node->getUserData<insn_t>();
                auto acquired_bb = bb_provider_->acquire_ref(analysis_info->bb_ref);
                assert(acquired_bb.has_value());
                bb->successors.emplace_back(acquired_bb.value());
            }

            /// Iterating over the successors and updating predecessors in successors
            for (const auto& successor : bb->successors) {
                successor->predecessors.emplace_back(bb);
            }
        }
    }

    template <pe::any_image_t Img>
    void Instance<Img>::dump() {
        logger::info("-- Basic blocks for function {:#x}", function_start_);

        for (auto& v : std::views::values(basic_blocks_)) {
            debug::dump_bb(*v);
        }

        logger::info("-- EOF");
    }

    template <pe::any_image_t Img>
    void Instance<Img>::dump_to_visualizer() {
        const auto path = std::filesystem::path(R"(E:\local-projects\obfuscator\scripts\bb_preview\data\)");
        int iter = 0;

        for (auto& basic_block : std::views::values(basic_blocks_)) {
            debug::serialize_bb_to_file(*basic_block, path / (std::to_string(iter) + ".bb"));
            iter += 1;
        }
    }

    PE_DECL_TEMPLATE_CLASSES(Instance);
} // namespace analysis::bb_decomp

```

`src/lib/analysis/bb_decomp/bb_decomp.hpp`:

```hpp
#pragma once
#include "analysis/common/common.hpp"
#include "analysis/common/provider.hpp"
#include "pe/pe.hpp"

#include <optional>
#include <ranges>
#include <vector>

namespace analysis::bb_decomp {
    /// \brief BB Decomposition instance
    /// \tparam Img Image
    template <pe::any_image_t Img>
    class Instance {
    public:
        Instance(Img* image, const rva_t rva, const std::optional<std::size_t> function_size = std::nullopt)
            : image_(image), function_start_(rva), function_size_(function_size), program_(std::make_shared<zasm::Program>(image->guess_machine_mode())),
              assembler_(std::make_shared<zasm::x86::Assembler>(*program_)), decoder_(easm::Decoder(image_->guess_machine_mode())),
              bb_provider_(std::make_shared<functional_bb_provider_t>()) {
            collect();
        }
        ~Instance() = default;

        Instance(const Instance& instance)
            : image_(instance.image_), function_start_(instance.function_start_), function_size_(instance.function_size_),
              basic_blocks_(instance.basic_blocks_), program_(std::move(instance.program_)), assembler_(std::move(instance.assembler_)),
              decoder_(instance.decoder_), jump_tables_(instance.jump_tables_), bb_provider_(instance.bb_provider_) { }

        void collect();
        void split();
        void sanitize();

        [[maybe_unused]] void dump(); // to stdout
        [[maybe_unused]] void dump_to_visualizer(); // to visualizer script dir

        void clear() noexcept {
            basic_blocks_.clear();
        }

        [[nodiscard]] std::vector<std::shared_ptr<bb_t>> export_raw_blocks() const {
            auto result = basic_blocks_ | std::ranges::views::values | std::ranges::to<std::vector>();
            result.insert(result.end(), virtual_basic_blocks_.begin(), virtual_basic_blocks_.end());
            return result;
        }

        [[nodiscard]] std::shared_ptr<bb_storage_t> export_blocks() const {
            return std::make_shared<bb_storage_t>(export_raw_blocks());
        }

        [[nodiscard]] std::shared_ptr<zasm::Program> export_program() {
            return std::move(program_);
        }

    private:
        std::shared_ptr<bb_t> process_bb(rva_t rva);
        void update_refs();
        void insert_jmps();
        void update_tree();
        void update_rescheduled_cf();

        // jumptables shenainigans
        void collect_jumptables();
        void collect_jumptable_entries();
        void expand_jumptables();

        std::shared_ptr<bb_t> make_successor(const rva_t successor, const bb_t* predecessor) {
            const auto predecssor_ref = bb_provider_->acquire_ref(predecessor);
            assert(predecssor_ref.has_value());
            return make_successor(successor, predecssor_ref.value());
        }

        std::shared_ptr<bb_t> make_successor(const rva_t successor, const rva_t predecessor) {
            return make_successor(successor, at(predecessor));
        }

        std::shared_ptr<bb_t> make_successor(const rva_t successor, const std::shared_ptr<bb_t>& predecessor) {
            // Don't analyse already existing bbs
            //
            if (seen_bb(successor)) {
                auto successor_ptr = at(successor);
                predecessor->push_successor(successor_ptr);
                return successor_ptr;
            }

            // Processing bb
            //
            auto successor_ptr = process_bb(successor);

            // Add ass successor/predecessor
            //
            successor_ptr->push_predecessor(predecessor);
            predecessor->push_successor(successor_ptr);
            return successor_ptr;
        }

        [[nodiscard]] std::shared_ptr<bb_t> make_virtual_bb() {
            auto result = std::make_shared<bb_t>(image_->guess_machine_mode());
            virtual_basic_blocks_.emplace_back(result);
            return result;
        }

        [[nodiscard]] bool seen_bb(const rva_t rva) const {
            return basic_blocks_.contains(rva);
        }

        [[nodiscard]] bool is_rva_oob(const rva_t rva) const {
            if (!function_size_.has_value()) {
                return false;
            }

            return (rva - function_start_) >= function_size_;
        }

        [[nodiscard]] std::shared_ptr<bb_t> at(const rva_t rva) {
            if (const auto it = basic_blocks_.find(rva); it != basic_blocks_.end()) {
                return it->second;
            }

            basic_blocks_[rva] = std::make_shared<bb_t>(image_->guess_machine_mode());
            return basic_blocks_[rva];
        }

        void push_last_N_instruction(const std::size_t count, const std::shared_ptr<bb_t>& basic_block) const {
            basic_block->push_last_N_insns(assembler_.get(), bb_provider_.get(), count);
        }

        [[nodiscard]] std::shared_ptr<insn_t> push_last_instruction(const std::shared_ptr<bb_t>& basic_block,
                                                                    const std::optional<rva_t> rva = std::nullopt,
                                                                    const std::optional<std::uint8_t> size = std::nullopt) const {
            return basic_block->push_insn(assembler_->getCursor(), bb_provider_.get(), rva, size);
        }

        [[nodiscard]] std::shared_ptr<label_t> push_last_label(const std::shared_ptr<bb_t>& basic_block) const {
            return basic_block->push_label(assembler_->getCursor(), bb_provider_.get());
        }

        std::shared_ptr<label_t> push_last_label(bb_t* basic_block) const {
            return basic_block->push_label(assembler_->getCursor(), bb_provider_.get());
        }

        const Img* image_ = nullptr;
        rva_t function_start_ = nullptr;
        std::optional<std::size_t> function_size_ = std::nullopt;

        std::unordered_map<rva_t, std::shared_ptr<bb_t>> basic_blocks_ = {};
        std::vector<std::shared_ptr<bb_t>> virtual_basic_blocks_ = {}; // = without the rva

        std::shared_ptr<zasm::Program> program_ = {};
        std::shared_ptr<zasm::x86::Assembler> assembler_ = {};
        easm::Decoder decoder_;

        std::unordered_map<rva_t, jump_table_t> jump_tables_ = {};

        std::shared_ptr<functional_bb_provider_t> bb_provider_ = {};
    };

    template <pe::any_image_t Img>
    std::vector<bb_t> collect(Img* image, const rva_t rva, std::optional<std::size_t> size = std::nullopt) {
        const auto inst = Instance<Img>(image, rva, size);
        return inst.export_blocks();
    }
} // namespace analysis::bb_decomp

```

`src/lib/analysis/bb_decomp/jumptables.cpp`:

```cpp
#include "analysis/analysis.hpp"
#include "analysis/bb_decomp/bb_decomp.hpp"
#include "analysis/common/debug.hpp"
#include "util/logger.hpp"

/// \todo @es3n1n: Notify the linker somehow that it should erase jumptable pointers too
namespace analysis::bb_decomp {
    template <pe::any_image_t Img>
    void Instance<Img>::collect_jumptables() {
        const auto machine_mode = image_->guess_machine_mode();

        for (auto& basic_block : std::views::values(basic_blocks_)) {
            for (std::size_t i = 0; i < basic_block->size(); ++i) {
                const auto& insn = basic_block->instructions.at(i);

                /// We aren't interested in the successful estimations of jcc/jmps
                if (!(insn->flags & UNABLE_TO_ESTIMATE_JCC)) {
                    continue;
                }

                /// OK, we just hit a `jmp/jcc reg`, let's confirm that to be sure
                const auto jmp_reg = insn->ref->getOperandIf<zasm::Reg>(0);
                if (insn->ref->getOperandCount() != 1 || jmp_reg == nullptr) {
                    continue;
                }

                /// Init the jumptable info
                auto jump_table = jump_table_t{};
                jump_table.bb = basic_block;
                jump_table.jmp_at = basic_block->instructions.begin() + static_cast<std::ptrdiff_t>(i);

                /// Now we need find its table ptr, we are gonna do this by iterating back and
                /// matching the load_index and/or base_move
                for (std::size_t j = i; j != static_cast<std::size_t>(-1); j--) {
                    const auto& prev_insn = basic_block->instructions.at(j);

                    auto match_load_index = [&]() -> void {
                        /// If already found
                        if (jump_table.jump_table_rva.has_value()) {
                            return;
                        }

                        /// Match `mov`
                        if (prev_insn->ref->getMnemonic().value() != ZYDIS_MNEMONIC_MOV) {
                            return;
                        }

                        /// Match the dst reg
                        if (const auto* dst_reg = prev_insn->ref->getOperandIf<zasm::Reg>(0);
                            dst_reg == nullptr || dst_reg->getRoot(machine_mode).getId() != jmp_reg->getRoot(machine_mode).getId()) {
                            return;
                        }

                        /// Found it.

                        /// Now we just have to parse the second operand as Mem and extract the table
                        /// base from it.
                        const auto* mem = prev_insn->ref->getOperandIf<zasm::Mem>(1);
                        if (mem == nullptr) {
                            throw std::runtime_error("analysis: bb didn't have a Mem operand");
                        }

                        /// Yay.
                        jump_table.jump_table_rva = std::make_optional(mem->getDisplacement());
                        jump_table.index_load_at = basic_block->begin() + static_cast<std::ptrdiff_t>(j);
                    };

                    auto match_base_move = [&]() -> void {
                        /// If already found
                        if (jump_table.base_move_at.has_value()) {
                            return;
                        }

                        /// We should match only when we already know the index_move
                        if (!jump_table.index_load_at.has_value()) {
                            return;
                        }

                        /// Check the max allowed distance
                        if (std::distance(basic_block->begin(), *jump_table.index_load_at) - j > 3) {
                            return;
                        }

                        /// Match the lea
                        if (prev_insn->ref->getMnemonic().value() != ZYDIS_MNEMONIC_LEA) {
                            return;
                        }

                        /// Get the dst reg operand
                        const auto dst_op = prev_insn->ref->getOperandIf<zasm::Reg>(0);
                        const auto src_op = prev_insn->ref->getOperandIf<zasm::Mem>(1);
                        if (dst_op == nullptr || src_op == nullptr) {
                            return;
                        }

                        /// Get the memory operand from index_load
                        const auto mem_index_op = (**jump_table.index_load_at)->ref->getOperandIf<zasm::Mem>(1);
                        assert(mem_index_op != nullptr);

                        /// If matches, then yeah we found it
                        if (mem_index_op->getBase().getId() != dst_op->getId()) {
                            return;
                        }

                        jump_table.base_move_at = basic_block->begin() + static_cast<std::ptrdiff_t>(j);
                    };

                    match_load_index();
                    match_base_move();
                    if (jump_table.index_load_at.has_value() && jump_table.base_move_at.has_value())
                        break;
                }

                /// Something's off
                if (!jump_table.jump_table_rva.has_value()) {
                    logger::warn("analysis: discovered possible jump table, however didn't find the base at {:#x}", insn->rva.value_or(0));
                    continue;
                }

                /// Looks legit.
                logger::debug("analysis: discovered possible jump table jmp at {:#x} -> {:#x}", insn->rva.value_or(0), jump_table.jump_table_rva.value());
                jump_tables_[jump_table.jump_table_rva.value()] = jump_table;
            }
        }
    }

    template <pe::any_image_t Img>
    void Instance<Img>::collect_jumptable_entries() {
        /// Now we have to bruteforce the number of entries per table.
        /// I know, i know, it's not the proper solution; however, parsing
        /// the jumptables isn't that trivial of a task and it requires
        /// spending ~waaaay~ more time than i can afford on this task.
        /// We can't just look at the insn before `ja` because there
        /// are multiple possible code generation.
        /// And, with some compilers, the access to the jumptable could
        /// be optimized with some math stuff, which we'd have to handle.
        ///
        /// You probably are thinking that there could be potential
        /// collisions of jumptables and you'd be right!
        /// In order to fix that, we first collect all the tables and
        /// their addresses, then check if the entry we're parsing is
        /// colliding with entries from different jump tables.
        for (auto& [rva, info] : jump_tables_) {
            /// Get the table start
            auto* table = image_->template rva_to_ptr<std::uint32_t>(rva);
            if (!table) {
                throw std::runtime_error("analysis: unable to find the jump table, huh?");
            }

            /// Let the bruteforce begin
            for (std::size_t i = 0; true; i++) {
                /// Get the entry
                auto entry = table[i];

                /// Check if we hit any collision
                if (i != 0 && jump_tables_.contains(rva + (i * sizeof(entry)))) {
                    break;
                }

                /// Get the entry ptr
                auto ptr = image_->template rva_to_ptr<std::uint8_t>(entry);
                if (!ptr) {
                    break;
                }

                /// Get the section and check if its executable
                if (const auto* section = image_->rva_to_section(entry); //
                    !section->characteristics.cnt_code) {
                    break;
                }

                /// Looks like a valid entry to me.
                /// \todo @es3n1n: Check for function bounds (if its even possible)
                info.entries.emplace_back(entry);
            }

            logger::debug("analysis: got {} entries for a jump table at {:#x}", info.entries.size(), rva);
        }
    }

    template <pe::any_image_t Img>
    void Instance<Img>::expand_jumptables() {
        for (auto& [rva, info] : jump_tables_) {
            /// First, we should replace the
            /// `mov reg, [bla+bla*bla+0x1337]` with `lea reg, [bla+bla*bla]`
            /// then we should erase all the other stuff between it and the jump.
            /// Then, we could easily compare this reg value and jump to the bbs.

            /// Obtain the ptr mov operand
            const auto pjmp_reg = (**info.index_load_at)->ref->getOperandIf<zasm::Reg>(0);
            const auto pmem_op = (**info.index_load_at)->ref->getOperandIf<zasm::Mem>(1);
            if (pmem_op == nullptr || pjmp_reg == nullptr) [[unlikely]] {
                throw std::runtime_error("analysis: unable to obtain mem_op/jmp_reg for jumptable expansion");
            }

            /// Copy
            auto mem_op = *pmem_op;
            auto jmp_reg = zasm::x86::Gp(pjmp_reg->getRoot(image_->guess_machine_mode()).getId()); // eax->rax (just in case)

            /// Remove the imm part (that points to the jump table)
            assert(mem_op.getDisplacement() == rva.as<std::int64_t>());
            mem_op.setBitSize(jmp_reg.getBitSize(image_->guess_machine_mode()));
            mem_op.setDisplacement(0);

            /// Remove the base
            /// \fixme @es3n1n: Do we really need to always remove it though?
            mem_op.setBase(zasm::Reg(zasm::Reg::Id::None));

            /// Change the cursor pos
            const auto insert_to = (**info.index_load_at)->node_ref->getPrev();
            assembler_->setCursor(insert_to);

            /// Erase other nodes
            for (auto it = *info.index_load_at; it != (*info.bb)->instructions.end(); ++it) {
                const auto ptr = it->get();
                if (!ptr->rva.has_value()) {
                    continue;
                }

                if (*ptr->rva < *(**info.index_load_at)->rva) {
                    continue;
                }

                /// Destroy the node and mark to be removed
                program_->destroy(ptr->node_ref);
                ptr->flags |= TO_BE_REMOVED;
            }

            /// Destroy the base mov, if needed
            if (info.base_move_at.has_value()) {
                const auto ptr = **info.base_move_at;

                /// Destroy and mark as to be removed
                program_->destroy(ptr->node_ref);
                ptr->flags |= TO_BE_REMOVED;
            }

            /// Emit the lea instead
            assembler_->lea(jmp_reg, mem_op);
            auto last_node = assembler_->getCursor();
            (void)push_last_instruction(*info.bb);

            /// Current bb that it should treat as predecessor
            auto current_bb = *info.bb;

            /// Clear its old successors list
            current_bb->successors.clear();

            /// Some temporary info about the new virtual bbs
            struct bb_info_t {
                std::shared_ptr<bb_t> ptr = nullptr;
                zasm::Node* first = nullptr;
                zasm::Node* last = nullptr;
                const std::size_t count = 0;
            };
            std::vector<bb_info_t> new_bbs = {};

            /// Iterate over the jt entries
            std::size_t index = 0;
            for (auto it = info.entries.begin(); it != info.entries.end(); std::advance(it, 1)) {
                /// Create the new BB for this stuff
                auto new_bb = make_virtual_bb();

                /// Create a label, we'll bind it to where the new BB starts later
                auto label = program_->createLabel();

                /// Compare the index value with current index
                assembler_->setCursor(last_node);
                assembler_->cmp(jmp_reg, zasm::Imm16(index * std::max(mem_op.getScale(), static_cast<uint8_t>(1))));
                auto first_node = assembler_->getCursor();

                /// JZ
                assembler_->jz(label);

                /// Bind the label
                last_node = assembler_->getCursor();
                assembler_->bind(label);

                /// Save new bb info
                new_bbs.emplace_back(new_bb, first_node, last_node, 2); // \fixme @es3n1n: hardcoded count

                /// Analyse this stuff
                auto successor = make_successor(*it, *current_bb->start_rva);

                /// Store label info
                assembler_->setCursor(last_node->getNext());
                (void)push_last_label(successor);

                /// Save the successor for previous virtual bb
                current_bb->successors.emplace_back(new_bb);

                /// Save the successor
                new_bb->successors.emplace_back(successor);
                new_bb->predecessors.emplace_back(current_bb);

                /// Save the new_bb predecessor
                successor->predecessors.emplace_back(new_bb);

                current_bb = successor;
                index++;
            }

            /// Push new instructions to new bbs
            for (auto it = new_bbs.rbegin(); it != new_bbs.rend(); std::advance(it, 1)) {
                assembler_->setCursor(it->last);
                push_last_N_instruction(it->count, it->ptr);
            }
        }
    }

    PE_DECL_TEMPLATE_CLASSES(Instance);
} // namespace analysis::bb_decomp
```

`src/lib/analysis/common/common.hpp`:

```hpp
#pragma once
#include <algorithm>
#include <atomic>
#include <cstdint>
#include <functional>
#include <iterator>
#include <vector>

#include "easm/easm.hpp"
#include "util/iterators.hpp"
#include "util/structs.hpp"
#include "util/types.hpp"

/// \todo @es3n1n: split this monstrosity to multiple files
namespace analysis {
    using rva_t = types::rva_t;

    struct bb_t;

    // CF direction representation
    //
    struct cf_direction_t {
        enum class e_type : std::uint8_t {
            JCC_CONDITION_MET = 0,
            JCC_CONDITION_NOT_MET,
            JMP
        };

        std::shared_ptr<bb_t> bb;
        e_type type = e_type::JMP;

        /// Set to true if we were unable to find the next node.
        bool rescheduled = false;
        std::optional<rva_t> rescheduled_va = std::nullopt;
    };

    // If instruction contains some data that should be relocated
    //
    struct insn_reloc_t {
        enum class e_type : std::uint8_t {
            NONE = 0,
            HEADER, // reloc from .reloc section
            IP, // reloc [rip+0x1337]
        };

        rva_t imm_rva = nullptr;
        e_type type = e_type::NONE;

        // set only for .reloc relocations, basically offset from instruction start to the offset
        std::optional<std::uint8_t> offset = std::nullopt;
    };

    // Instruction flags repr
    //
    enum e_insn_fl : std::uint8_t {
        UNABLE_TO_ESTIMATE_JCC = (1 << 0),
        TO_BE_REMOVED = (1 << 1)
    };

    // CPU Flags
    //
    struct cpu_flags_t {
        bool cf = false; // Carry Flag
        bool pf = false; // Parity Flag
        bool af = false; // Adjust Flag
        bool zf = false; // Zero Flag
        bool sf = false; // Sign Flag
        bool tf = false; // Trap Flag (for single stepping)
        bool if_ = false; // Interrupt Enable Flag
        bool df = false; // Direction Flag
        bool of = false; // Overflow Flag
        bool iopl1 = false; // I/O Privilege Level flag, first bit
        bool iopl2 = false; // I/O Privilege Level flag, second bit
        bool nt = false; // Nested Task Flag
        bool rf = false; // Resume Flag (used to control the processor's response to debug exceptions)
        bool vm = false; // Virtual 8086 Mode Flag
        bool ac = false; // Alignment Check (or Access Control) Flag
        bool vif = false; // Virtual Interrupt Flag
        bool vip = false; // Virtual Interrupt Pending
        bool id = false; // ID flag (can CPUID instruction be used)

        void set(zasm::InstrCPUFlags flags) noexcept {
            namespace CPUFlags = zasm::x86::CPUFlags;
            auto test = [flags](const auto fl) -> bool {
                return (flags & fl) != CPUFlags::None;
            };

            cf = test(CPUFlags::CF);
            pf = test(CPUFlags::PF);
            af = test(CPUFlags::AF);
            zf = test(CPUFlags::ZF);
            sf = test(CPUFlags::SF);
            tf = test(CPUFlags::TF);
            if_ = test(CPUFlags::IF);
            df = test(CPUFlags::DF);
            of = test(CPUFlags::OF);
            iopl1 = test(CPUFlags::IOPL1);
            iopl2 = test(CPUFlags::IOPL2);
            nt = test(CPUFlags::NT);
            rf = test(CPUFlags::RF);
            vm = test(CPUFlags::VM);
            ac = test(CPUFlags::AC);
            vif = test(CPUFlags::VIF);
            vip = test(CPUFlags::VIP);
            id = test(CPUFlags::ID);
        }
    };

    struct bb_t;

    // Instruction repr
    // \todo @es3n1n: Some smart .destroy method that would unlink zasm node, remove relocs, etc
    struct insn_t {
        // RVA to the start of the insn
        //
        std::optional<rva_t> rva = std::nullopt;

        // Instruction info at the moment when we were decoding it
        //
        std::optional<std::uint8_t> length = std::nullopt;

        // A pointer to the instruction and node **in** the program class (the one that we'll encode)
        //
        zasm::Instruction* ref = nullptr;
        zasm::Node* node_ref = nullptr;

        // BB ref
        //
        bb_t* bb_ref = nullptr;

        // If this vector contains stuff then IP could be changed only
        // in the ways that are stored in this vector.
        // If not set the execution is just linear.
        //
        std::vector<cf_direction_t> cf = {};

        // Reloc info
        //
        insn_reloc_t reloc = {};

        // Internal analysis flags
        //
        std::underlying_type_t<e_insn_fl> flags = 0;

        // CPU Flags
        //
        cpu_flags_t flags_set_0 = {};
        cpu_flags_t flags_set_1 = {};
        cpu_flags_t flags_modified = {};
        cpu_flags_t flags_tested = {};
        cpu_flags_t flags_undefined = {};

        // Util to find first op of type
        //
        template <typename Ty>
        [[nodiscard]] std::optional<std::size_t> find_operand_index_if() const {
            // Iterating over operands and trying to get it as our type
            //
            for (std::size_t i = 0; i < ref->getOperandCount(); ++i) {
                if (!ref->getOperand(i).holds<Ty>()) {
                    continue;
                }

                return std::make_optional<std::size_t>(i);
            }

            return std::nullopt;
        }

        template <typename Ty>
        Ty* find_operand_if() {
            // Obtaining index of the desired operand
            //
            const auto index = find_operand_index_if<Ty>();
            if (!index.has_value()) {
                return nullptr;
            }

            // Returning it as the type that we were looking for
            //
            return ref->getOperandIf<Ty>(index.value());
        }

        [[nodiscard]] bool is_conditional_jump() const {
            return cf.size() > 1;
        }

        [[nodiscard]] bool is_jump() const {
            return !cf.empty();
        }

        [[nodiscard]] std::shared_ptr<bb_t> linear_successor() const;
    };

    struct bb_provider_t {
        virtual ~bb_provider_t() = default;

        /// \brief Find bb by start VA
        /// \param va virtual address
        /// \param callee basic block callee
        /// \return optional bb ref
        [[nodiscard]] virtual std::optional<std::shared_ptr<bb_t>> find_by_start_va(rva_t va, bb_t* callee) const = 0;

        /// \brief Find bb by start RVA
        /// \param rva relative virtual address
        /// \param callee basic block callee
        /// \return optional bb ref
        [[nodiscard]] virtual std::optional<std::shared_ptr<bb_t>> find_by_start_rva(rva_t rva, bb_t* callee) const = 0;

        /// \brief Find bb by label
        /// \param label label ptr
        /// \param callee basic block callee
        /// \return optional bb ref
        [[nodiscard]] virtual std::optional<std::shared_ptr<bb_t>> find_by_label(const zasm::Label* label, bb_t* callee) const = 0;

        /// \brief Acquire bb reference from raw BB ptr
        /// \param ptr basic block ptr
        /// \return optional bb ref
        [[nodiscard]] virtual std::optional<std::shared_ptr<bb_t>> acquire_ref(const bb_t* ptr) const = 0;
    };

    struct label_t {
        // References
        //
        bb_t* bb_ref = nullptr;
        zasm::Label* ref = nullptr;
        zasm::Node* node_ref = nullptr;

        // Info
        //
        zasm::Label::Id id = zasm::Label::Id::Invalid;
    };

    // Basic block representation, a function consists of multiple BBs
    //
    struct bb_t {
        explicit bb_t(const zasm::MachineMode machine_mode): machine_mode(machine_mode) { }

        // Common stuff for the next processings, this looks sketchy
        //
        zasm::MachineMode machine_mode;

        // Basic block start, end RVAs
        //
        std::optional<rva_t> start_rva;
        std::optional<rva_t> end_rva; // does not include the size of last instruction

        // A set of disassembled instructions
        //
        std::vector<std::shared_ptr<insn_t>> instructions;

        // Attached labels
        //
        std::unordered_map<zasm::Label::Id, std::shared_ptr<label_t>> labels;

        // BB Successor - a block that this block can lead to
        // BB Predecessor - a block that always executes before this block
        //
        std::vector<std::shared_ptr<bb_t>> successors;
        std::vector<std::shared_ptr<bb_t>> predecessors;

        // Set to true if we changed the instructions list, you should reset it by yourself
        //
        std::atomic_bool dirty = false;

        // bf Flags
        //
        union {
            struct {
                bool valid:1;
            };

            [[maybe_unused]] std::uint32_t raw = {0};
        } flags;

        // Util methods
        //
        void push_successor(const std::shared_ptr<bb_t>& value) {
            // Inserting only once
            //
            if (std::ranges::find(successors, value) != successors.end()) {
                return;
            }

            successors.emplace_back(value);
        }

        void push_predecessor(const std::shared_ptr<bb_t>& value) {
            // Inserting only once
            //
            if (std::ranges::find(predecessors, value) != predecessors.end()) {
                return;
            }

            predecessors.emplace_back(value);
        }

        std::shared_ptr<label_t> push_label(zasm::Node* label_node_ptr, const bb_provider_t* bb_provider) {
            assert(bb_provider != nullptr);

            // Acquire label ref
            const auto ref = label_node_ptr->getIf<zasm::Label>();
            if (ref == nullptr) {
                return nullptr;
            }

            // Construct info
            auto it = std::make_shared<label_t>();
            it->ref = ref;
            it->node_ref = label_node_ptr;
            it->bb_ref = this;
            it->id = ref->getId();

            // Save the ptr
            label_node_ptr->setUserData(it.get()); // remember the ptr
            labels[it->id] = it;

            // We are done here
            return it;
        }

        std::shared_ptr<insn_t> push_insn(zasm::Node* insn_node_ptr, const bb_provider_t* bb_provider, const std::optional<rva_t> rva = std::nullopt,
                                          const std::optional<std::uint8_t> size = std::nullopt,
                                          const std::optional<decltype(instructions)::iterator>& at = std::nullopt) {
            assert(bb_provider != nullptr);

            /// We are storing only instructions
            const auto ref = insn_node_ptr->getIf<zasm::Instruction>();
            if (ref == nullptr) {
                if (insn_node_ptr->holds<zasm::Label>()) { // \todo @es3n1n: issue some sort of warning?
                    push_label(insn_node_ptr, bb_provider);
                }
                return nullptr; // \fixme @es3n1n: this should be handled somehow different
            }

            /// Construct insn struct
            auto it = std::make_shared<insn_t>();
            it->node_ref = insn_node_ptr;
            it->ref = ref;
            it->bb_ref = this;

            /// Save rva/size
            it->rva = rva;
            it->length = size;

            /// Set some stuff from the insn detail
            if (auto res = ref->getDetail(machine_mode); res.hasValue()) {
                auto [set1, set0, modified, tested, undefined] = res->getCPUFlags();
                it->flags_set_0.set(set0);
                it->flags_set_1.set(set1);
                it->flags_modified.set(modified);
                it->flags_tested.set(tested);
                it->flags_undefined.set(undefined);
            }

            /// Fill the CF change info
            /// \todo @es3n1n: We can probably fill the successors/predecessors list from here?
            auto update_cf = [&it, &ref, &bb_provider, this]() -> void {
                if (!easm::is_jcc_or_jmp(*ref)) {
                    return;
                }

                // Trying to decode JCC/JMP address
                //
                const auto [is_conditional, jcc_branch, jcc_branch_label] = easm::follow_jcc_or_jmp(*ref);

                if (!jcc_branch.has_value() && !jcc_branch_label.has_value()) {
                    // This is bad. Probably we just hit jumptable or some other shenanigans like this
                    logger::warn("analysis: unable to follow JCC/JMP at {:#x}", it->rva.value_or(0));
                    it->flags |= UNABLE_TO_ESTIMATE_JCC;
                    return;
                }

                /// Updating cf
                ///
                auto reschedule = [&it](const cf_direction_t::e_type ref_type, const std::optional<rva_t> rescheduled_va = std::nullopt) -> void {
                    auto& ref_it = it->cf.emplace_back();
                    ref_it.type = ref_type;
                    ref_it.rescheduled = true;
                    ref_it.rescheduled_va = rescheduled_va;
                };
                auto push_cf_changer = [&it, reschedule](const cf_direction_t::e_type ref_type, const std::optional<std::shared_ptr<bb_t>>& bb_ref,
                                                         const std::optional<rva_t> va = std::nullopt) -> void {
                    if (!bb_ref.has_value()) {
                        // This is bad. Let's reschedule it
                        logger::warn("analysis: unable to follow JCC/JMP at {:#x} #2 --> rescheduling", it->rva.value_or(0));
                        reschedule(ref_type, va);
                        return;
                    }

                    auto& ref_it = it->cf.emplace_back();
                    ref_it.type = ref_type;
                    ref_it.bb = *bb_ref;
                };

                /// Push ref if condition not met
                ///
                auto push_not_met = [is_conditional, it, bb_provider, push_cf_changer, reschedule, this]() -> void {
                    if (!is_conditional) {
                        return;
                    }

                    if (it->rva.has_value() && it->length.has_value()) {
                        push_cf_changer(cf_direction_t::e_type::JCC_CONDITION_NOT_MET, bb_provider->find_by_start_rva(*it->rva + *it->length, this));
                        return;
                    }

                    auto* next_node = it->node_ref->getNext();
                    while (next_node != nullptr && !next_node->holds<zasm::Instruction>()) {
                        next_node = next_node->getNext();
                    }

                    if (next_node == nullptr) {
                        reschedule(cf_direction_t::e_type::JCC_CONDITION_NOT_MET);
                        return;
                    }

                    /// \todo @es3n1n: Make sure that this insn is at the very start of the basic block
                    const auto* next_insn = next_node->getUserData<insn_t>();

                    if (next_insn == nullptr) [[unlikely]] {
                        reschedule(cf_direction_t::e_type::JCC_CONDITION_NOT_MET);
                        return;
                    }

                    const auto next_bb_acquired = bb_provider->acquire_ref(next_insn->bb_ref);
                    push_cf_changer(cf_direction_t::e_type::JCC_CONDITION_NOT_MET, next_bb_acquired);
                };
                push_not_met();

                /// Push ref if condition met
                ///
                const auto not_met_type = is_conditional ? cf_direction_t::e_type::JCC_CONDITION_MET : cf_direction_t::e_type::JMP;

                if (jcc_branch.has_value()) {
                    push_cf_changer(not_met_type, bb_provider->find_by_start_va(jcc_branch.value(), this));
                    return;
                }

                if (jcc_branch_label.has_value()) {
                    auto bb_ref = bb_provider->find_by_label(jcc_branch_label.value(), this);
                    assert(bb_ref.has_value()); // we shouldn't reschedule this one
                    push_cf_changer(not_met_type, bb_ref.value());
                }
            };
            update_cf();

            /// Save the node
            insn_node_ptr->setUserData(it.get()); // remember the ptr
            instructions.emplace(at.value_or(instructions.end()), it);
            dirty = true;
            return it;
        }

        void push_last_N_insns(const zasm::x86::Assembler* assembler, const bb_provider_t* bb_provider, const std::size_t count) {
            /// Get the last inserted instruction
            ///
            auto node = assembler->getCursor();

            /// Insert in reverse order
            ///
            std::size_t i;
            for (i = 0; i < count && node != nullptr; i++, node = node->getPrev()) {
                (void)push_insn(node, bb_provider);
            }

            /// Reverse the newly inserted nodes
            ///
            auto iter = instructions.begin();
            std::advance(iter, count - i);
            std::reverse(iter, instructions.end());
        }

        [[nodiscard]] std::shared_ptr<insn_t> last_non_jmp_insn(zasm::Program* program = nullptr, const bool destroy_jmps = false,
                                                                const bool include_conditional_jmps = false) const {
            auto insns = temp_insns_copy();
            for (auto it = insns.rbegin(); it != insns.rend(); std::advance(it, 1)) {
                auto insn = *it;
                bool skip = false;

                if (include_conditional_jmps && insn->is_conditional_jump()) {
                    skip = true;
                }

                if (insn->is_jump() && !insn->is_conditional_jump()) {
                    skip = true;
                }

                if (skip) {
                    if (destroy_jmps) {
                        assert(program != nullptr);
                        program->destroy(insn->node_ref);
                    }

                    continue;
                }

                return insn;
            }

            throw std::runtime_error(std::format("last_non_jmp_insn: unable to query ({})", static_cast<int>(include_conditional_jmps)));
        }

        [[nodiscard]] bool contains_label(const zasm::Label::Id label_id) const {
            return labels.contains(label_id);
        }

        void clear() {
            // Clearing all BB state
            //
            flags.valid = false;
            start_rva = nullptr;
            end_rva = nullptr;
            successors.clear();
            predecessors.clear();
            instructions.clear();
        }

        void verify_ranges() const {
            if (!start_rva.has_value()) {
                // nothing to verify
                return;
            }

            auto addr = *start_rva;
            for (const auto& instruction : instructions) {
                if (!instruction->rva.has_value()) {
                    // skip newly added instructions (probably expanded jumptable)
                    break;
                }

                if (*instruction->rva != addr) {
                    throw std::runtime_error("bb_analysis: Invalid BB range found!");
                }

                addr = addr + *instruction->length;
            }
        }

        void update_ranges(const bool verify_ranges = false) {
            // If there's nothing to update
            //
            flags.valid = !instructions.empty();
            if (!flags.valid) {
                clear();
                return;
            }

            // Calculating start/end ranges
            //
            std::optional<memory::address> start_rva_ = std::nullopt;
            std::optional<memory::address> end_rva_ = std::nullopt;

            for (const auto& insn : instructions) {
                // skip instructions without rva
                if (!insn->rva.has_value()) {
                    continue;
                }

                // otherwise update start/end
                //
                if (!start_rva_.has_value() || *insn->rva < *start_rva_) {
                    start_rva_ = *insn->rva;
                }

                if (!end_rva_.has_value() || *insn->rva > *end_rva_) {
                    end_rva_ = *insn->rva;
                }
            }

            // Update the range within the struct
            //
            assert(start_rva_.has_value() && end_rva_.has_value());
            start_rva = *start_rva_;
            end_rva = *end_rva_;

            // Verifying ranges just in case
            //
            if (verify_ranges) {
                this->verify_ranges();
            }
        }

        [[nodiscard]] std::vector<std::shared_ptr<insn_t>> temp_insns_copy() const {
            return instructions;
        }

        [[nodiscard]] std::size_t size() const noexcept {
            return instructions.size();
        }

        [[nodiscard]] zasm::Node* node_at(const std::size_t i) const {
            assert(i < instructions.size());
            return instructions.at(i)->node_ref;
        }

        [[maybe_unused]] void update_addresses() const {
            if (!start_rva.has_value()) {
                // no info :(
                return;
            }

            // Address of the first instruction in BB should be the address
            //
            rva_t addr = *start_rva;

            // Iterating over instructions and updating their addresses
            //
            for (const auto& instruction : instructions) {
                // Skip instructions without rva
                //
                if (!instruction->rva.has_value() || !instruction->length.has_value()) {
                    continue;
                }

                instruction->rva = addr;
                addr = addr + *instruction->length;
            }
        }

        auto begin() {
            return instructions.begin();
        }

        auto begin() const {
            return instructions.begin();
        }

        auto end() {
            return instructions.end();
        }

        auto end() const {
            return instructions.end();
        }
    };

    /// \fixme @es3n1n: MOVE THIS STUFF TO .cpp!
    [[nodiscard]] inline std::shared_ptr<bb_t> insn_t::linear_successor() const {
        if (is_jump()) {
            const auto it = std::ranges::find_if(cf, [](auto& pred) -> bool {
                return pred.type == cf_direction_t::e_type::JCC_CONDITION_NOT_MET || pred.type == cf_direction_t::e_type::JMP;
            });
            return it->bb;
        }
        assert(!bb_ref->successors.empty());
        /// \todo @es3n1n: Check if last insn within the BB, return next insn if so
        return bb_ref->successors.at(0);
    }

    // Jump table representation
    //
    struct jump_table_t {
        using insn_ptr_t = std::vector<std::shared_ptr<insn_t>>::iterator;
        std::optional<std::shared_ptr<bb_t>> bb = std::nullopt;

        std::optional<insn_ptr_t> index_load_at = std::nullopt; // mov reg, [bla+bla*bla]
        std::optional<insn_ptr_t> base_move_at = std::nullopt; // insn that goes before index_load and that uses register from index_load insn
        std::optional<insn_ptr_t> jmp_at = std::nullopt; // jmp reg

        std::optional<memory::address> jump_table_rva = std::nullopt;
        std::vector<rva_t> entries = {};
    };

    struct bb_storage_t {
        DEFAULT_CTOR_DTOR(bb_storage_t);
        DEFAULT_COPY(bb_storage_t);
        explicit bb_storage_t(const std::vector<std::shared_ptr<bb_t>>& value): basic_blocks(value) { }

        using iterator = util::DerefSharedPtrIter<bb_t>;
        using const_iterator = util::DerefSharedPtrIter<const bb_t>;

        [[nodiscard]] auto& emplace_back() {
            return basic_blocks.emplace_back(std::make_shared<bb_t>(basic_blocks.begin()->get()->machine_mode));
        }

        void iter_bbs(const std::function<void(bb_t&)>& callback) {
            std::ranges::for_each(basic_blocks, [callback](const std::shared_ptr<bb_t>& value) -> void { callback(*value); });
        }

        void iter_insns(const std::function<void(insn_t&)>& callback) {
            iter_bbs([&callback](bb_t& basic_block) -> void { //
                std::ranges::for_each(basic_block.instructions, [&callback](auto& ptr) -> void { callback(*ptr); });
            });
        }

        /// Don't forget to stop the observer, i guess? (fixme)
        [[nodiscard]] std::shared_ptr<bb_t> copy_bb(const std::shared_ptr<bb_t>& bb, zasm::x86::Assembler* as, zasm::Program* program,
                                                    const bb_provider_t* provider) {
            /// Alloc bb
            auto new_bb = std::make_shared<bb_t>(bb->machine_mode);
            basic_blocks.emplace_back(new_bb);

            /// Copy all the instructions
            for (const auto& insn : bb->instructions) {
                /// Emit instruction copy, store it in the BB
                as->emit(*insn->ref);
                new_bb->push_insn(as->getCursor(), provider);
            }

            /// Insert jmp if needed
            if (const auto last_insn = bb->instructions.at(bb->size() - 1);
                !last_insn->is_jump() && !last_insn->is_conditional_jump() && !bb->successors.empty()) {
                /// Get the linear successor
                const auto successor = last_insn->linear_successor();

                /// Create new label
                const auto label = program->createLabel();
                auto label_node = program->bindLabel(label);
                assert(label_node.hasValue());

                /// Insert label, remember it
                program->insertBefore(successor->node_at(0), label_node.value());
                successor->push_label(label_node.value(), provider);

                /// Jmp to the successor
                as->jmp(label);
                bb->push_insn(as->getCursor(), provider);
            }

            return new_bb;
        }

        [[nodiscard]] auto begin() {
            return iterator(basic_blocks.begin());
        }

        [[nodiscard]] auto begin() const {
            return const_iterator(basic_blocks.begin());
        }

        [[nodiscard]] auto end() {
            return iterator(basic_blocks.end());
        }

        [[nodiscard]] auto end() const {
            return const_iterator(basic_blocks.end());
        }

        [[nodiscard]] std::size_t size() const {
            return basic_blocks.size();
        }

        [[nodiscard]] std::vector<std::shared_ptr<bb_t>> temp_copy() const {
            return basic_blocks;
        }

        std::vector<std::shared_ptr<bb_t>> basic_blocks = {};
    };
} // namespace analysis

```

`src/lib/analysis/common/debug.hpp`:

```hpp
#pragma once
#include "analysis/common/common.hpp"
#include "util/files.hpp"

#include <filesystem>
#include <sstream>

#include <magic_enum.hpp>

namespace analysis::debug {
    namespace detail {
        constexpr std::string_view unknown_type_name = "Unknown";

        const std::unordered_map<std::size_t, std::string_view> operand_type_lookup = {
            {0, std::string_view{"None"}}, {1, std::string_view{"Reg"}},   {2, std::string_view{"Mem"}},
            {3, std::string_view{"Imm"}},  {4, std::string_view{"Label"}},
        };
    } // namespace detail

    inline void serialize_bb_to_file(const bb_t& basic_block, const std::filesystem::path& file) {
        std::stringstream ss;

        ss << "start:" << std::hex << basic_block.start_rva.value_or(0).inner() << '\n';
        ss << "end:" << std::hex << basic_block.start_rva.value_or(0).inner() << '\n';

        for (auto& instruction : basic_block.instructions) {
            ss << "instruction:" << std::hex << instruction->rva.value_or(0).inner() << ";"
               << ZydisMnemonicGetString(static_cast<ZydisMnemonic>(instruction->ref->getMnemonic().value())) << '\n';
        }

        for (auto& successor : basic_block.successors) {
            ss << "successor:" << std::hex << successor->start_rva.value_or(0).inner() << '\n';
        }

        for (auto& predecessor : basic_block.predecessors) {
            ss << "predecessor:" << std::hex << predecessor->start_rva.value_or(0).inner() << '\n';
        }

        const auto data = ss.str();
        util::write_file(file, reinterpret_cast<const uint8_t*>(data.data()), data.size());
    }

    [[maybe_unused]] inline void dump_bb(const bb_t& bb) {
        using namespace detail;
        logger::info("BB: {:#x} :: {:#x}", bb.start_rva.value_or(0), bb.end_rva.value_or(0));
        logger::info<1>("Valid: {}", bb.flags.valid);
        logger::info<1>("Instructions:");

        for (const auto& instruction : bb.instructions) {
            logger::info<2>("{:#x}: {}", instruction->rva.value_or(0), //
                            ZydisMnemonicGetString(static_cast<ZydisMnemonic>(instruction->ref->getMnemonic().value())));

            if (const auto ops_count = instruction->ref->getOperandCount(); ops_count > 0) {
                logger::info<3>("Operands:");

                for (std::size_t i = 0; i < ops_count; ++i) {
                    const auto operand = instruction->ref->getOperand(i);

                    const auto operand_name_pair = operand_type_lookup.find(operand.getTypeIndex());
                    const auto operand_name = //
                        operand_name_pair == std::end(operand_type_lookup) ? unknown_type_name : operand_name_pair->second;

                    logger::info<4>("{}", operand_name);
                }
            }

            if (!instruction->cf.empty()) {
                logger::info<3>("CF:");
                for (const auto& cf : instruction->cf) {
                    logger::info<4>("{}: {:#x}", magic_enum::enum_name<cf_direction_t::e_type>(cf.type), *cf.bb->start_rva);
                }
            }

            if (instruction->reloc.type != insn_reloc_t::e_type::NONE) {
                logger::info<3>("Relocation:");
                logger::info<4>("TYPE_{}: {:#x} | Offset: {}", magic_enum::enum_name<insn_reloc_t::e_type>(instruction->reloc.type),
                                instruction->reloc.imm_rva,
                                instruction->reloc.offset.has_value() ? std::to_string(instruction->reloc.offset.value()) : "none");
            }
        }

        if (!bb.successors.empty()) {
            logger::info<1>("Successors:");

            for (const auto& successor : bb.successors) {
                logger::info<2>("{:#x}", successor->start_rva.value_or(0));
            }
        }

        if (!bb.predecessors.empty()) {
            logger::info<1>("Predecessors:");

            for (const auto& predecessor : bb.predecessors) {
                logger::info<2>("{:#x}", predecessor->start_rva.value_or(0));
            }
        }
    }
} // namespace analysis::debug

```

`src/lib/analysis/common/provider.hpp`:

```hpp
#pragma once
#include "common.hpp"

namespace analysis {
    struct functional_bb_provider_t final : bb_provider_t {
    private:
        template <typename Ty>
        using FuncTy = std::optional<std::function<Ty>>;
        using ResultTy = std::optional<std::shared_ptr<bb_t>>;

    public:
        /// \brief Find bb by start VA
        /// \param va virtual address
        /// \param callee basic block callee
        /// \return optional bb ref
        [[nodiscard]] ResultTy find_by_start_va(const rva_t va, bb_t* callee) const override {
            assert(find_by_start_va_.has_value());
            return (*find_by_start_va_)(va, callee);
        }

        /// \brief Find bb by start RVA
        /// \param rva relative virtual address
        /// \param callee basic block callee
        /// \return optional bb ref
        [[nodiscard]] ResultTy find_by_start_rva(const rva_t rva, bb_t* callee) const override {
            assert(find_by_start_rva_.has_value());
            return (*find_by_start_rva_)(rva, callee);
        }

        /// \brief Find bb by label
        /// \param label label ptr
        /// \param callee basic block callee
        /// \return optional bb ref
        [[nodiscard]] ResultTy find_by_label(const zasm::Label* label, bb_t* callee) const override {
            assert(find_by_label_.has_value());
            return (*find_by_label_)(label, callee);
        }

        /// \brief Acquire bb reference from raw BB ptr
        /// \param ptr basic block ptr
        /// \return optional bb ref
        [[nodiscard]] ResultTy acquire_ref(const bb_t* ptr) const override {
            assert(acquire_ref_.has_value());
            return (*acquire_ref_)(ptr);
        }

        /// \brief Set VA finder callback
        /// \param callback callback
        void set_va_finder(const FuncTy<ResultTy(rva_t, bb_t*)>& callback) noexcept {
            find_by_start_va_ = callback;
        }

        /// \brief Set RVA finder callback
        /// \param callback callback
        void set_rva_finder(const FuncTy<ResultTy(rva_t, bb_t*)>& callback) noexcept {
            find_by_start_rva_ = callback;
        }

        /// \brief Set label finder callback
        /// \param callback callback
        void set_label_finder(const FuncTy<ResultTy(const zasm::Label*, bb_t*)>& callback) noexcept {
            find_by_label_ = callback;
        }

        /// \brief Acquire bb reference from raw PTR
        /// \param callback callback
        void set_ref_acquire(const FuncTy<ResultTy(const bb_t*)>& callback) noexcept {
            acquire_ref_ = callback;
        }

    private:
        /// \brief VA finder callback
        FuncTy<ResultTy(rva_t, bb_t*)> find_by_start_va_ = std::nullopt;
        /// \brief RVA finder callback
        FuncTy<ResultTy(rva_t, bb_t*)> find_by_start_rva_ = std::nullopt;
        /// \brief Label finder callback
        FuncTy<ResultTy(const zasm::Label*, bb_t*)> find_by_label_ = std::nullopt;
        /// \brief Acquire ref callback
        FuncTy<ResultTy(const bb_t*)> acquire_ref_ = std::nullopt;
    };
} // namespace analysis

```

`src/lib/analysis/lru_reg/lru_reg.hpp`:

```hpp
#pragma once
#include "easm/easm.hpp"
#include "pe/pe.hpp"
#include "util/random.hpp"

#include <list>
#include <unordered_set>

namespace analysis {
    using RegID = zasm::Reg::Id;

    namespace detail {
        inline std::array kProtectedRegisters = {RegID{ZYDIS_REGISTER_RSP}, RegID{ZYDIS_REGISTER_RBP}, RegID{ZYDIS_REGISTER_RIP}};
        inline std::array kRegistersX86 = {
            RegID{ZYDIS_REGISTER_RAX}, RegID{ZYDIS_REGISTER_RBX}, RegID{ZYDIS_REGISTER_RCX}, RegID{ZYDIS_REGISTER_RDX},
            RegID{ZYDIS_REGISTER_RSI}, RegID{ZYDIS_REGISTER_RDI}, RegID{ZYDIS_REGISTER_RBP}, RegID{ZYDIS_REGISTER_RSP},
        };
        inline std::array kRegistersX64 = {
            RegID{ZYDIS_REGISTER_R8},  RegID{ZYDIS_REGISTER_R9},  RegID{ZYDIS_REGISTER_R10}, RegID{ZYDIS_REGISTER_R11},
            RegID{ZYDIS_REGISTER_R12}, RegID{ZYDIS_REGISTER_R13}, RegID{ZYDIS_REGISTER_R14}, RegID{ZYDIS_REGISTER_R15},
        };
    } // namespace detail

    /// \brief Least recently used register container
    class LRURegContainer {
    public:
        DEFAULT_CTOR_DTOR(LRURegContainer);
        DEFAULT_COPY(LRURegContainer);

        /// \brief Emplace register to the cache
        /// \param reg_id Register id
        void push(const RegID reg_id) {
            /// Mark as recently used
            if (cache_.contains(reg_id)) {
                items_.remove(reg_id);
                items_.push_front(reg_id);
                return;
            }

            /// Don't store protected registers
            if (std::ranges::find(detail::kProtectedRegisters, zasm::Reg{reg_id}.getRoot(zasm::MachineMode::AMD64).getId()) !=
                std::end(detail::kProtectedRegisters)) {
                return;
            }

            /// Otherwise insert
            items_.push_front(reg_id);
            cache_.insert(reg_id);
        }

        /// \brief Get the least recently used register
        /// \param return_random should we choose a random register across least recently used registers?
        /// \return Register id
        [[nodiscard]] RegID get(const bool return_random = false) {
            /// Return random, if needed
            if (return_random) {
                return random();
            }

            return filter([this]() -> RegID {
                /// Get the last recently used item
                const auto lru = items_.back();

                /// Mark as recently used
                items_.remove(lru);
                items_.push_front(lru);
                return lru;
            });
        }

        /// \brief Get a random register across least used registers cache
        /// \return Register id
        [[nodiscard]] RegID random() {
            return filter([this]() -> RegID {
                /// Get a random register
                const auto lru = rnd::item(items_);

                /// Mark as recently used
                items_.remove(lru);
                items_.push_front(lru);
                return lru;
            });
        }

        /// \brief Temporary blacklist register
        /// \param reg_id register
        void blacklist(const RegID reg_id) {
            blacklisted_.insert(reg_id);
        }

        /// \brief Clear blacklist
        void clear_blacklist() {
            blacklisted_.clear();
        }

        /// \brief An object that will clear blacklist in its destructor
        struct blacklist_state_t {
            explicit blacklist_state_t(LRURegContainer* container): container(container) { }
            ~blacklist_state_t() {
                container->clear_blacklist();
            }

            LRURegContainer* container = nullptr;
        };

        /// \brief Create a raii auto blacklist cleaner
        /// \return RAII object that will clear the blacklist in dctor
        [[nodiscard]] blacklist_state_t auto_cleaner() noexcept {
            return blacklist_state_t(this);
        }

    private:
        /// \brief Filter out blacklisted values
        /// \param callback callback that should return RegID
        /// \return filtered RegID that isn't blacklisted
        [[nodiscard]] RegID filter(const std::function<RegID()>& callback) const {
            RegID result;

            do {
                result = callback();
            } while (blacklisted_.contains(result));

            return result;
        }

        /// \brief Temporary blacklisted registers
        std::unordered_set<RegID> blacklisted_ = {};
        /// \brief Items storage itself
        std::list<RegID> items_ = {};
        /// \brief Unordered set for a bit faster contains checks
        std::unordered_set<RegID> cache_ = {};
    };

    /// \brief An lru cache for all types of GP registers
    /// \tparam Img X64 or X86 image, depending on this image, the gp64 lru cache could be available
    template <pe::any_image_t Img>
    class LRUReg {
        constexpr static bool IsX64 = pe::is_x64_v<Img>;
        using RegTy = zasm::x86::Gp;

    public:
        DEFAULT_DTOR(LRUReg);
        DEFAULT_COPY(LRUReg);

        LRUReg() {
            /// Push X86 registers
            for (const auto reg_id : detail::kRegistersX86) {
                push(reg_id);
            }

            /// Push x64 registers if needed
            if constexpr (IsX64) {
                for (const auto reg_id : detail::kRegistersX64) {
                    push(reg_id);
                }
            }
        }

        /// \brief Push register to the lru cache
        /// \param reg_id register
        void push(const RegID reg_id) {
            storage_.push(to_gp_ptr(reg_id));
        }

        /// \brief Temporary blacklist register
        /// \param reg_id register
        void blacklist(const RegID reg_id) {
            storage_.blacklist(to_gp_ptr(reg_id));
        }

        /// \brief Clear blacklist
        void clear_blacklist() {
            storage_.clear_blacklist();
        }

        /// \brief Create a raii auto blacklist cleaner
        /// \return RAII object that will clear the blacklist in dctor
        [[nodiscard]] LRURegContainer::blacklist_state_t auto_cleaner() noexcept {
            return storage_.auto_cleaner();
        }

        /// \brief Get least recently used register as Gp8
        /// \param random should we choose a random register across least recently used registers?
        /// \return Register
        [[nodiscard]] RegTy get_gp8_lo(const bool random = false) {
            return RegTy{easm::reg_convert::gp64_to_gp8(to_gp64_if_needed(storage_.get(random)))};
        }

        /// \brief Get least recently used register as Gp16
        /// \param random should we choose a random register across least recently used registers?
        /// \return Register
        [[nodiscard]] RegTy get_gp16_lo(const bool random = false) {
            return RegTy{easm::reg_convert::gp64_to_gp16(to_gp64_if_needed(storage_.get(random)))};
        }

        /// \brief Get least recently used register as Gp32
        /// \param random should we choose a random register across least recently used registers?
        /// \return Register
        [[nodiscard]] RegTy get_gp32_lo(const bool random = false) {
            return RegTy{easm::reg_convert::gp64_to_gp32(to_gp64_if_needed(storage_.get(random)))};
        }

        /// \brief Get least recently used register as Gp64
        /// \param random should we choose a random register across least recently used registers?
        /// \return Register
        [[nodiscard]] RegTy get_gp64(const bool random = false) {
            assert(IsX64); // no gp64 registers on x86
            return RegTy{to_gp64_if_needed(storage_.get(random))};
        }

        /// \brief Get least recently used register (gp64 for x64 and gp32 for x86)
        /// \param random should we choose a random register across least recently used registers?
        /// \return Register
        [[nodiscard]] RegTy get(const bool random = false) {
            return RegTy{storage_.get(random)};
        }

        /// \brief Get register with size passed as `bit_size`
        /// \param bit_size register bit size
        /// \param random should we choose a random register across least recently used registers?
        /// \return Register
        [[nodiscard]] RegTy get_for_bits(const zasm::BitSize bit_size, const bool random = false) {
            switch (getBitSize(bit_size)) {
            case 8:
                return get_gp8_lo(random);
            case 16:
                return get_gp16_lo(random);
            case 32:
                return get_gp32_lo(random);
            case 64:
                return get_gp64(random);
            default:
                break;
            }
            throw std::runtime_error("lru_reg: unsupported bit size");
        }

        /// \brief Get machine mode based on the image tparam type
        /// \return machine_mode
        [[nodiscard]] static zasm::MachineMode machine_mode() noexcept {
            return IsX64 ? zasm::MachineMode::AMD64 : zasm::MachineMode::I386;
        }

        /// \brief Converts any gp register to its base register, gp64 for x64 and gp32 for x86
        /// \param reg_id register that it should convert
        /// \return Converted register id
        [[nodiscard]] static RegID to_gp_ptr(const RegID reg_id) noexcept {
            const auto reg = zasm::Reg{reg_id};
            return reg.getRoot(machine_mode()).getId();
        }

        /// \brief Convert to GP64, if needed
        /// \param reg_id register that it should convert
        /// \return Converted GP64 reg id
        [[nodiscard]] static RegID to_gp64_if_needed(const RegID reg_id) noexcept {
            const auto gp_ptr = to_gp_ptr(reg_id);
            return IsX64 ? gp_ptr : easm::reg_convert::gp32_to_gp64(gp_ptr);
        }

    private:
        /// \brief gp uptr lru container
        LRURegContainer storage_ = {};
    };
} // namespace analysis
```

`src/lib/analysis/observer/observer.hpp`:

```hpp
#pragma once
#include "analysis/common/common.hpp"
#include "util/structs.hpp"

#include <regex>
#include <zasm/zasm.hpp>

namespace analysis {
    /// \brief Zasm observer that would update the bb decomp state according to the program modifications
    class Observer final : public zasm::Observer {
    public:
        NON_COPYABLE(Observer);

        /// \brief Init the observer
        /// \param program zasm program that it should be attached to
        /// \param bb_storage already analysed basic block storage
        /// \param bb_provider shared provider instance (should be already initialized)
        explicit Observer(const std::shared_ptr<zasm::Program>& program, const std::shared_ptr<bb_storage_t>& bb_storage,
                          const std::shared_ptr<functional_bb_provider_t>& bb_provider)
            : program_(program), bb_storage_(bb_storage), bb_provider_(bb_provider) {
            program->addObserver(*this);
        }

        /// \brief Shutdown observer
        ~Observer() override {
            program_->removeObserver(*this);
        }

        /// <summary>
        /// This is called before the node is destroyed.
        /// </summary>
        /// <param name="node">The node which will be destroyed</param>
        void onNodeDestroy(zasm::Node* node) override {
            /// Return if stopped
            if (stopped_) {
                return;
            }

            /// Trying to find the node within bb storage
            const auto pair = find_node(node, [](zasm::Node*) -> zasm::Node* { return nullptr; });
            if (!pair.has_value()) {
                throw std::runtime_error("observer: unable to find node [destroy]");
            }

            /// Erase the node
            pair->first->instructions.erase(pair->second);
            pair->first->dirty = true;
        }

        /// <summary>
        /// This is called after a node has been inserted.
        /// </summary>
        /// <param name="node">The node which was inserted</param>
        void onNodeInserted(zasm::Node* node) override {
            /// Return if stopped
            if (stopped_) {
                return;
            }

            /// Try to find prev/next nodes
            auto prev_pair = find_node(node->getPrev(), [](zasm::Node* cur_node) -> zasm::Node* {
                return cur_node->getPrev(); //
            });
            auto next_pair = find_node(node->getNext(), [](zasm::Node* cur_node) -> zasm::Node* {
                return cur_node->getNext(); //
            });

            /// util
            auto insert_to = [this, node](bb_t* bb, const decltype(bb->instructions)::iterator& at) -> void {
                bb->push_insn(node, bb_provider_.get(), std::nullopt, std::nullopt, at);
            };

            /// \fixme @es3n1n:
            /// This logic is slightly wrong. Instead of doing all of this, we have to:
            /// - Find the prev/next nodes
            /// - Check if prev node ends with jcc/jmp
            /// - If not -> insert new node there
            /// - Otherwise check if the newly inserted node is a jcc/jmp
            /// - If yes -> create a new BB for it, update successors for the prev bb
            /// - Otherwise insert it to the next bb
            ///
            /// Also we have to check if newly inserted node is a jcc/jmp and if its inserted
            /// to the middle of the BB, then we should split it.
            /// Hopefully i didn't forget anything

            if (prev_pair.has_value()) {
                /// If it wasn't inserted after the last entry within bb, then we should be good
                /// and we could just insert new node in this bb
                /// If the next pair is unknown, then fuck it just insert it somewhere
                if (auto [bb, insn] = *prev_pair; //
                    ((*insn)->is_jump() && !(*insn)->is_conditional_jump()) || //
                    !next_pair.has_value()) {
                    return insert_to(bb, insn + 1); // +1 because we want to insert it **after** the prev item
                }
            }

            if (next_pair.has_value()) {
                /// Oh well, just insert it before the `next` insn
                auto [bb, insn] = *next_pair;
                return insert_to(bb, insn);
            }

            throw std::runtime_error("observer: unable to process prev/next nodes [inserted]");
        }

        /// <summary>
        /// This is called after a node has been created.
        /// </summary>
        void onNodeCreated(zasm::Node*) override { }

        /// <summary>
        /// This is called before a node is detached.
        /// </summary>
        void onNodeDetach(zasm::Node*) override { }

        /// \brief Stop the observer
        void stop() {
            stopped_ = true;
        }

        /// \brief Start the observer
        void start() {
            stopped_ = false;
        }

        /// \brief
        /// \return true - stopped / false - running
        [[nodiscard]] bool stopped() const {
            return stopped_;
        }

    private:
        /// \brief
        /// \param node
        /// \param next
        /// \return
        static std::optional<std::pair<bb_t*, decltype(bb_t::instructions)::iterator>> find_node(zasm::Node* node,
                                                                                                 const std::function<zasm::Node*(zasm::Node*)>& next) {
            /// Looking up prev/next nodes until we hit an insn
            const auto* insn_ref = node->getIf<zasm::Instruction>();
            while (node != nullptr && insn_ref == nullptr) {
                node = next(node);
                if (node != nullptr)
                    insn_ref = node->getIf<zasm::Instruction>();
            }

            /// No node
            if (node == nullptr || insn_ref == nullptr) {
                return std::nullopt;
            }

            /// Get its analysis insn info
            auto* insn_info = node->getUserData<insn_t>();
            if (insn_info == nullptr || insn_info->bb_ref == nullptr) [[unlikely]] {
                assert(false); // huh?
                return std::nullopt;
            }

            /// Return info
            auto iter = std::ranges::find_if(insn_info->bb_ref->instructions, [&](const auto& ptr) -> bool {
                return ptr.get() == insn_info; //
            });
            assert(iter != std::end(insn_info->bb_ref->instructions));

            /// Not found
            return std::make_optional(std::make_pair(insn_info->bb_ref, iter));
        }

        /// \brief Zasm program instance that we're gonna analyze each time
        /// an obfuscation transform creates/destroys something
        std::shared_ptr<zasm::Program> program_ = {};
        /// \brief A reference to the basic block storage
        std::shared_ptr<bb_storage_t> bb_storage_ = {};
        /// \brief BB Provider reference
        std::shared_ptr<functional_bb_provider_t> bb_provider_ = {};
        /// \brief Start/stop
        bool stopped_ = false;
    };
} // namespace analysis

```

`src/lib/analysis/passes/collect_img_references.hpp`:

```hpp
#pragma once
#include "analysis/analysis.hpp"
#include "util/structs.hpp"

namespace analysis::passes {
    template <pe::any_image_t Img>
    struct collect_img_references_t {
        DEFAULT_CTOR_DTOR(collect_img_references_t);
        NON_COPYABLE(collect_img_references_t);

        static bool apply_insn(Function<Img>* function, insn_t& instruction, Img* image) {
            // Looking for IMMs in the insn
            //
            const auto* imm = instruction.find_operand_if<zasm::Imm>();
            if (imm == nullptr) {
                return false;
            }

            // Obtaining IMM value and image base
            //
            const auto imm_value = imm->value<std::uint64_t>();
            const auto base_address = image->raw_image->get_nt_headers()->optional_header.image_base;

            // Skip instruction if imm isn't in the range of image
            //
            if (imm_value < base_address) {
                return false;
            }

            // Remembering reference
            //
            function->image_references[imm_value - base_address].emplace_back(&instruction);
            return true;
        }
    };
} // namespace analysis::passes

```

`src/lib/analysis/passes/collect_lookup_table.hpp`:

```hpp
#pragma once
#include "analysis/analysis.hpp"
#include "util/structs.hpp"

namespace analysis::passes {
    template <pe::any_image_t Img>
    struct collect_lookup_table_t {
        DEFAULT_CTOR_DTOR(collect_lookup_table_t);
        NON_COPYABLE(collect_lookup_table_t);

        static bool apply_insn(Function<Img>* function, insn_t& instruction, Img*) {
            if (!instruction.rva.has_value()) {
                /// \fixme @es3n1n: this could be pretty bad that we don't push newly
                /// created insns to the lookup table, although we should be just fine without them
                return true;
            }

            // Building rva<->insn lookup table
            //
            function->instructions_lookup[*instruction.rva] = &instruction;
            return true;
        }
    };
} // namespace analysis::passes

```

`src/lib/analysis/passes/label_references.hpp`:

```hpp
#pragma once
#include "analysis/analysis.hpp"
#include "util/format.hpp"
#include "util/structs.hpp"

namespace analysis::passes {
    template <pe::any_image_t Img>
    struct label_references_t {
        DEFAULT_CTOR_DTOR(label_references_t);
        NON_COPYABLE(label_references_t);

        static bool apply(Function<Img>* function, Img*) {
            // Iterating over referenced RVAs within the function
            //
            for (const auto& [referenced_insn_rva, insn_ptrs] : function->image_references) {
                // Skip if reference is not within the function
                //
                if (!(referenced_insn_rva >= function->range.start && referenced_insn_rva <= function->range.end)) {
                    continue;
                }

                // Skip empty lists, huh?
                //
                if (insn_ptrs.empty()) [[unlikely]] {
                    continue;
                }

                // Formatting referenced location
                // \fixme: @es3n1n: add a template param to address class and add conversions to it
                const auto referenced_loc_name = format::loc(static_cast<std::int32_t>(referenced_insn_rva.inner()));

                // Creating label for the referenced loc
                //
                const auto referenced_loc_label = function->program.get()->createLabel(referenced_loc_name.c_str());
                const auto referenced_loc_label_node = function->program.get()->bindLabel(referenced_loc_label);
                if (!referenced_loc_label_node) [[unlikely]] {
                    throw std::runtime_error("analysis: Unable to bind the label");
                }

                // Moving label node to the referenced instruction
                //
                const auto referenced_insn = function->instructions_lookup.find(referenced_insn_rva);
                if (referenced_insn == function->instructions_lookup.end()) [[unlikely]] {
                    throw std::runtime_error("analysis: Unable to find referenced insn");
                }
                function->program.get()->moveBefore(referenced_insn->second->node_ref, *referenced_loc_label_node);

                // Iterating over instructions that referenced this RVA
                //
                for (auto* referrer_ptr : insn_ptrs) {
                    // Looking for the imm in this instruction
                    //
                    const auto imm_operand_index = referrer_ptr->template find_operand_index_if<zasm::Imm>();

                    // No imm, huh?
                    //
                    if (!imm_operand_index.has_value()) [[unlikely]] {
                        throw std::runtime_error("analysis: got an invalid imm operand index");
                    }

                    // Swapping imm with the label
                    //
                    referrer_ptr->ref->setOperand(imm_operand_index.value(), referenced_loc_label);
                }
            }

            return true;
        }
    };
} // namespace analysis::passes

```

`src/lib/analysis/passes/lru_reg.hpp`:

```hpp
#pragma once
#include "analysis/analysis.hpp"
#include "util/structs.hpp"

namespace analysis::passes {
    template <pe::any_image_t Img>
    struct lru_reg_t {
        DEFAULT_CTOR_DTOR(lru_reg_t);
        NON_COPYABLE(lru_reg_t);

        static bool apply_insn(Function<Img>* function, const insn_t& instruction, Img*) {
            /// Collect all the registers and push them to LRU
            for (auto& reg : easm::get_all_registers(*instruction.ref)) {
                function->lru_reg.push(reg.getId());
            }

            return true;
        }
    };
} // namespace analysis::passes

```

`src/lib/analysis/passes/misc/bb_insn_passes.cpp`:

```cpp
#include "analysis/passes/misc/bb_insn_passes.hpp"

#include "analysis/common/common.hpp"
#include "analysis/passes/collect_img_references.hpp"
#include "analysis/passes/collect_lookup_table.hpp"
#include "analysis/passes/lru_reg.hpp"
#include "analysis/passes/reloc_marker.hpp"

namespace analysis::passes {
    namespace detail::bb_insn_passes {
        template <pe::any_image_t Img>
        bool on_bb(Function<Img>* /*function*/, bb_t& /*basic_block*/, Img* /*image*/) {
            constexpr bool result = false;

            // result |= reloc_marker_t<Img>::apply_bb(function, basic_block, image);

            return result;
        }

        template <pe::any_image_t Img>
        bool on_insn(Function<Img>* function, insn_t& instruction, Img* image) {
            bool result = false;

            result |= reloc_marker_t<Img>::apply_insn(function, instruction, image);
            result |= collect_img_references_t<Img>::apply_insn(function, instruction, image);
            result |= collect_lookup_table_t<Img>::apply_insn(function, instruction, image);
            result |= lru_reg_t<Img>::apply_insn(function, instruction, image);

            return result;
        }
    } // namespace detail::bb_insn_passes

    template <pe::any_image_t Img>
    bool bb_insn_passes_t<Img>::apply(Function<Img>* function, Img* image) {
        using namespace detail::bb_insn_passes;
        bool result = false;

        // Iterating over BB and invoking callbacks
        //
        //
        function->bb_storage->iter_bbs([&](bb_t& basic_block) -> void {
            result |= on_bb<Img>(function, basic_block, image);

            // Iterating over instructions and invoking callbacks
            //
            std::for_each(basic_block.instructions.begin(), basic_block.instructions.end(), [&function, &image, &result](auto& instruction) -> void { //
                result |= on_insn<Img>(function, *instruction, image);
            });
        });

        return result;
    }

    PE_DECL_TEMPLATE_STRUCTS(bb_insn_passes_t);
} // namespace analysis::passes

```

`src/lib/analysis/passes/misc/bb_insn_passes.hpp`:

```hpp
#pragma once
#include "analysis/analysis.hpp"
#include "util/structs.hpp"

//
// This pass executes other standalone transforms that doesn't need to iter bb/insns by themselves,
// by using this pass we're reducing the number of iterations that we need to do, thus we reduce
// the time that we would need to spend in order to finish analysis.
//

namespace analysis::passes {
    template <pe::any_image_t Img>
    struct bb_insn_passes_t {
        DEFAULT_CTOR_DTOR(bb_insn_passes_t);
        NON_COPYABLE(bb_insn_passes_t);

        static bool apply(Function<Img>* function, Img* image);
    };
} // namespace analysis::passes

```

`src/lib/analysis/passes/reloc_marker.hpp`:

```hpp
#pragma once
#include "analysis/analysis.hpp"
#include "util/structs.hpp"

namespace analysis::passes {
    template <pe::any_image_t Img>
    struct reloc_marker_t {
        DEFAULT_CTOR_DTOR(reloc_marker_t);
        NON_COPYABLE(reloc_marker_t);

        static bool apply_insn(Function<Img>* function [[maybe_unused]], insn_t& instruction, Img* image) {
            // Would be set to true if instruction contains imm/ip operands
            //
            const zasm::Imm* imm = instruction.find_operand_if<zasm::Imm>();
            const zasm::Mem* mem = instruction.find_operand_if<zasm::Mem>();

            // If there are no imm and ip references, then there shouldn't be any relocated data :thinking:
            //
            if (imm == nullptr && mem == nullptr) {
                return false;
            }

            /// Obtain needed stuff from pe
            const auto image_base = image->raw_image->get_nt_headers()->optional_header.image_base;
            const auto ptr_size = image->get_ptr_size();

            // Force reloc mem
            if (mem != nullptr && mem->getBase().isIP()) {
                instruction.reloc = {
                    .imm_rva = memory::address{static_cast<uintptr_t>(mem->getDisplacement()) - image_base},
                    .type = insn_reloc_t::e_type::IP,
                    .offset = std::make_optional<std::uint8_t>(mem->getSegment().getOffset()),
                };

                return true;
            }

            // New instructions does not have any relocations
            //
            if (!instruction.rva.has_value() || !instruction.length.has_value()) {
                return true;
            }

            // At this point, we are 100% sure that imm is set to something, so we can ignore the `imm != 0` check.
            // If there's an imm with the size of uintptr_t, we should check maybe it's present in the .reloc dir
            //
            if (imm != nullptr && getBitSize(imm->getBitSize()) == (ptr_size * 8) && instruction.length >= ptr_size) {
                // Trying to find relocation from PE header within the instruction
                // \todo @es3n1n: check segments instead of just bruteforcing
                //
                for (std::size_t offset = 0; offset <= (*instruction.length - ptr_size); ++offset) {
                    auto iter = image->relocations.find(*instruction.rva + offset);
                    if (iter == image->relocations.end()) {
                        continue;
                    }

                    // Uh ohh we just found a relocation
                    //
                    instruction.reloc = {
                        .imm_rva = memory::address{static_cast<uintptr_t>(imm->value<std::int64_t>() - image_base)},
                        .type = insn_reloc_t::e_type::HEADER,
                        .offset = std::make_optional<std::uint8_t>(static_cast<std::uint8_t>(offset)),
                    };

                    // Erase the stored reloc info
                    //
                    image->relocations.erase(iter);

                    return true;
                }
            }

            // No reloc :sob:
            //
            return false;
        }
    };
} // namespace analysis::passes

```

`src/lib/analysis/var_alloc/var_alloc.hpp`:

```hpp
#pragma once
#include "analysis/lru_reg/lru_reg.hpp"
#include "pe/pe.hpp"

namespace analysis {
    struct SymVar {
        /// Allocated register
        zasm::Reg reg;
        /// Root of the allocated register
        zasm::Reg root_reg;
        /// Variable bitsize
        zasm::BitSize bit_size;
        /// Stack space that this variable takes (in bytes)
        std::size_t stack_space;

        /// Implicit conversion to Gp so that we can pass this to the assembler methods
        [[nodiscard]] /* implicit */ operator zasm::x86::Gp() const { // NOLINT
            return zasm::x86::Gp{reg.getId()};
        }

        /// Implicit conversion to Reg so that we can pass this as an operand
        [[nodiscard]] /* implicit */ operator zasm::Reg() const { // NOLINT
            return reg;
        }

        /// Implicit conversion to Operand so that we can pass this as an operand
        [[nodiscard]] /* implicit */ operator zasm::Operand() const { // NOLINT
            return {reg};
        }

        /// \brief Convert root register to gp
        /// \return gp instance
        [[nodiscard]] auto root_gp() const {
            return zasm::x86::Gp{root_reg.getId()};
        }
    };

    template <pe::any_image_t Img>
    class VarAlloc {
    public:
        DEFAULT_CTOR_DTOR(VarAlloc);
        DEFAULT_COPY(VarAlloc);
        explicit VarAlloc(LRUReg<Img>* lru_reg): lru_reg_(lru_reg) { }

        /// \brief Get least recently used register as Gp8
        /// \param random should we choose a random register across least recently used registers?
        /// \return SymVar
        [[nodiscard]] SymVar get_gp8_lo(const bool random = false) {
            return filter([this, random]() -> zasm::Reg { return lru_reg_->get_gp8_lo(random); });
        }

        /// \brief Get least recently used register as Gp16
        /// \param random should we choose a random register across least recently used registers?
        /// \return SymVar
        [[nodiscard]] SymVar get_gp16_lo(const bool random = false) {
            return filter([this, random]() -> zasm::Reg { return lru_reg_->get_gp16_lo(random); });
        }

        /// \brief Get least recently used register as Gp32
        /// \param random should we choose a random register across least recently used registers?
        /// \return SymVar
        [[nodiscard]] SymVar get_gp32_lo(const bool random = false) {
            return filter([this, random]() -> zasm::Reg { return lru_reg_->get_gp32_lo(random); });
        }

        /// \brief Get least recently used register as Gp64
        /// \param random should we choose a random register across least recently used registers?
        /// \return SymVar
        [[nodiscard]] SymVar get_gp64(const bool random = false) {
            return filter([this, random]() -> zasm::Reg { return lru_reg_->get_gp64(random); });
        }

        /// \brief Get least recently used register (gp64 for x64 and gp32 for x86)
        /// \param random should we choose a random register across least recently used registers?
        /// \return SymVar
        [[nodiscard]] SymVar get(const bool random = false) {
            return filter([this, random]() -> zasm::Reg { return lru_reg_->get(random); });
        }

        /// \brief Get register with size passed as `bit_size`
        /// \param bit_size register bit size
        /// \param random should we choose a random register across least recently used registers?
        /// \return SymVar
        [[nodiscard]] SymVar get_for_bits(const zasm::BitSize bit_size, const bool random = false) {
            return filter([this, bit_size, random]() -> zasm::Reg { return lru_reg_->get_for_bits(bit_size, random); });
        }

        /// \brief Push flags to stack
        /// \param assembler zasm assembler ptr
        static void push_flags(zasm::x86::Assembler* assembler) {
            /// \fixme @es3n1n: we should track the instructions that affect CF instead
            if constexpr (pe::is_x64_v<Img>) {
                assembler->pushfq();
            } else {
                assembler->pushfd();
            }
        }

        /// \brief Push all used variables on stack
        /// \param assembler zasm assembler ptr
        void push(zasm::x86::Assembler* assembler) const {
            for (const auto& reg_id : registers_in_use_) {
                assembler->push(zasm::x86::Gp(reg_id));
            }
        }

        /// \brief Pop flags from stack
        /// \param assembler zasm assembler ptr
        static void pop_flags(zasm::x86::Assembler* assembler) {
            if constexpr (pe::is_x64_v<Img>) {
                assembler->popfq();
            } else {
                assembler->popfd();
            }
        }

        /// \brief Pop all used variables from stack
        /// \param assembler zasm assembler ptr
        void pop(zasm::x86::Assembler* assembler) const {
            for (auto it = registers_in_use_.rbegin(); it != registers_in_use_.rend(); std::advance(it, 1)) {
                assembler->pop(zasm::x86::Gp(*it));
            }
        }

        /// \brief Clear all used variables
        void clear() {
            stack_space_used_ = 0;
            registers_in_use_.clear();
        }

        /// \brief Estimate how many bytes would we need for storing all the symbolic vars
        /// \return size in bytes
        [[nodiscard]] std::size_t stack_size() const {
            return stack_space_used_;
        }

    private:
        /// \brief Filter out registers that are already in use
        /// \param callback callback that should return allocated reg
        /// \return sym var
        [[nodiscard]] SymVar filter(const std::function<zasm::Reg()>& callback) {
            zasm::Reg result;
            RegID gp_ptr_id;
            do {
                result = callback();
                gp_ptr_id = lru_reg_->to_gp_ptr(result.getId());
            } while (std::ranges::find(registers_in_use_, gp_ptr_id) != std::end(registers_in_use_));

            /// Save the gp ptr as register in use
            registers_in_use_.emplace_back(gp_ptr_id);

            /// Construct the symbolic var
            const auto result_var = SymVar{
                .reg = result,
                .root_reg = zasm::Reg(gp_ptr_id),
                .bit_size = result.getBitSize(lru_reg_->machine_mode()),
                .stack_space = getBitSize(zasm::Reg(gp_ptr_id).getBitSize(lru_reg_->machine_mode())) / CHAR_BIT,
            };

            /// Update the stack space
            stack_space_used_ += result_var.stack_space;

            return result_var;
        }

        /// \brief A list of gp64 registers that we are already using
        std::list<RegID> registers_in_use_ = {};
        /// \brief How many bytes would we need for storing all allocated vars
        std::size_t stack_space_used_ = 0;
        /// \brief LRU registers storage
        LRUReg<Img>* lru_reg_ = nullptr;
    };
} // namespace analysis
```

`src/lib/cli/cli.hpp`:

```hpp
#pragma once
#include "obfuscator/transforms/configs.hpp"
#include "obfuscator/transforms/scheduler.hpp"
#include "util/logger.hpp"

namespace cli {
    namespace detail {
        /// { { name, arg1, arg2 }, description }
        constexpr auto kCLIOptionsHelp = std::to_array<std::pair<std::array<std::string_view, 3>, std::string_view>>({
            {{"-h, --help", "", ""}, "This message"},
            {{"-pdb", "[path]", ""}, "Set custom .pdb file location"},
            {{"-map", "[path]", ""}, "Set custom .map file location"},
            {{"-f", "[name]", ""}, "Start new function configuration"},
            {{"-t", "[name]", ""}, "Start new transform configuration"},
            {{"-g", "[name]", ""}, "Start new transform global configuration"},
            {{"-v", "[name]", "[value]"}, "Push value"},
        });

        template <pe::any_image_t Img>
        void dump_transforms(const std::string_view platform_name) {
            /// Header
            logger::info("Available {} transforms:", platform_name);

            /// Iterate over the transforms
            auto& scheduler = obfuscator::TransformScheduler::get().for_arch<Img>();
            for (auto& [tag, transform] : scheduler.transforms) {
                /// Get the shared cfg
                auto& shared_cfg = obfuscator::TransformSharedConfigStorage::get().get_for(tag);

                /// Dump transform name
                logger::info<1>("{}", shared_cfg.name);

                /// Dump variables
                std::once_flag fl;
                transform->iter_vars([&fl](const obfuscator::TransformConfig::Var& var) -> void {
                    std::call_once(fl, []() -> void { logger::info<2>("Variables:"); });

                    logger::info<3>("{}", var.name());
                    logger::info<4>("type: {}", var.var_type() == obfuscator::TransformConfig::Var::Type::GLOBAL ? "global" : "per function");
                    logger::info<4>("default: {}", var.serialize());
                    logger::info<4>("required: {}", var.required() ? "true" : "false");
                    if (const auto short_desc = var.short_description(); short_desc.has_value()) {
                        logger::info<4>("description: {}", short_desc.value());
                    }
                });
            }
        }

        inline void dump_shared_vars() {
            /// Banner
            logger::info("Shared transform variables (e.g could be set for every transform):");

            /// Get some scheduler and any transform + shared config for it
            const auto& scheduler = obfuscator::TransformScheduler::get().for_arch<pe::X64Image>();
            const auto& shared_cfg = obfuscator::TransformSharedConfigStorage::get().get_for(scheduler.transforms.begin()->first);

            /// Dump all vars + their defaults
            for (const auto& name : obfuscator::detail::kSharedConfigsVariableNames) {
                logger::info<1>("{:<12} -- default: {}", name, shared_cfg.stringify_var(name));
            }
        }
    } // namespace detail

    inline void print_help(char* argv[]) {
        logger::enabled = true; // just to be sure
        logger::info("github.com/es3n1n/obfuscator - A PoC native code obfuscator");
        auto pad = [] {
            logger::info(" ");
        };
        pad();

        logger::info("Usage: {} [binary] [options...]", argv[0]);
        pad();

        logger::info("Available options:");
        for (auto& [args, desc] : detail::kCLIOptionsHelp) {
            logger::info<1>("{:<12} {:<6} {:<8} -- {}", args[0], args[1], args[2], desc);
        }
        pad();

        logger::info("Examples:");
        logger::info<1>("obfuscator hehe.exe -f main -t TransformName -v SomeName 1337");
        logger::info<1>("obfuscator hehe.exe -f main -t TransformName -v SomeName 1337 -g TransformName -v SomeGlobalName 1337");
        logger::info<1>("obfuscator hehe.exe -f main -t TransformName -v SomeName 1337 -v SomeName0 1337 -g TransformName -v SomeGlobalName 1337");
        logger::info<1>("obfuscator hehe.exe -map mymap.map -pdb mypdb.pdb -f main -t TransformName -v SomeName 1337 -v SomeName0 1337 -g TransformName "
                        "-v SomeGlobalName 1337");
        pad();

        detail::dump_transforms<pe::X64Image>("x64");
        pad();

        detail::dump_transforms<pe::X86Image>("x86");
        pad();

        detail::dump_shared_vars();
        pad();

        std::exit(0);
    }
} // namespace cli
```

`src/lib/config_parser/config_parser.cpp`:

```cpp
#include "config_parser/config_parser.hpp"
#include "cli/cli.hpp"
#include "obfuscator/transforms/configs.hpp"

namespace config_parser {
    Config from_argv(std::size_t argc, char* argv[]) {
        /// No binary path
        if (argc < 2) {
            cli::print_help(argv);
        }

        /// Get the binary path, check for some meme stuff
        const auto binary_path = std::string_view{argv[1]};
        if (binary_path == "-h" || binary_path == "--help") {
            cli::print_help(argv);
        }

        /// Allocate result
        Config result = {};
        auto& [binary_path_value] = result.obfuscator_config();
        auto& func_parser_config = result.func_parser_config();

        /// Get some stuff for transforms resolving
        auto& shared_config_storage = obfuscator::TransformSharedConfigStorage::get();

        /// Save the binary path
        binary_path_value = binary_path;

        /// Some state stuff for parser
        struct {
            function_configuration_t* current_function = nullptr;
            transform_configuration_t* current_transform = nullptr;

            [[nodiscard]] bool busy() const {
                return static_cast<bool>(current_function);
            }
        } state;

        for (std::size_t i = 2; i < argc; ++i) {
            /// Get current arguments
            std::string arg_ = argv[i];

            /// \todo @es3n1n: Create a wrapper for these cringe checks
            std::optional<std::string> next_arg_ = i + 1 < argc && argv[i + 1][0] != '-' ? std::make_optional<std::string>(argv[i + 1]) : std::nullopt;
            std::optional<std::string> next_next_arg_ =
                i + 2 < argc && argv[i + 2][0] != '-' ? std::make_optional<std::string>(argv[i + 2]) : std::nullopt;

            /// Util to skip arguments, if needed
            auto skip = [&](const std::size_t count) -> void {
                if (!next_arg_.has_value()) {
                    return;
                }

                i += 1;
                if (count < 2) {
                    return;
                }

                if (!next_next_arg_.has_value()) {
                    return;
                }
                i += 1;
            };

            /// Help
            if (arg_ == "-h" || arg_ == "--help" || arg_ == "--version") {
                cli::print_help(argv);
                continue;
            }

            /// PDB path
            if (arg_ == "-pdb") {
                func_parser_config.pdb_enabled = true;
                func_parser_config.pdb_path = next_arg_;
                skip(1);
                continue;
            }

            /// Map path
            if (arg_ == "-map") {
                func_parser_config.map_enabled = true;
                func_parser_config.map_path = next_arg_;
                skip(1);
                continue;
            }

            /// Function start
            if (arg_ == "-f" && next_arg_.has_value()) {
                state.current_function = &result.create_function_config();
                state.current_function->function_name = next_arg_.value();
                skip(1);
                continue;
            }

            /// Transform configuration start
            if (arg_ == "-t" && next_arg_.has_value() && state.busy()) {
                state.current_transform = &state.current_function->transform_configurations.emplace_back();
                state.current_transform->tag = shared_config_storage.get_for_name(next_arg_.value()).tag;
                skip(1);
                continue;
            }

            /// Transform global configuration
            if (arg_ == "-g" && next_arg_.has_value()) {
                state.current_transform = &result.create_global_transform_config();
                state.current_transform->tag = shared_config_storage.get_for_name(next_arg_.value()).tag;
                skip(1);
                continue;
            }

            /// Push value
            if (arg_ == "-v" && next_arg_.has_value() && next_next_arg_.has_value() && state.current_transform != nullptr) {
                state.current_transform->values[next_arg_.value()] = next_next_arg_.value();
                skip(2);
            }
        }

        return result;
    }
} // namespace config_parser

```

`src/lib/config_parser/config_parser.hpp`:

```hpp
#pragma once
#include "config_parser/structs.hpp"
#include "util/structs.hpp"

#include <vector>

namespace config_parser {
    class Config {
    public:
        DEFAULT_CTOR_DTOR(Config);
        DEFAULT_COPY(Config);

        [[nodiscard]] function_configuration_t& create_function_config() {
            return function_configurations_.emplace_back();
        }

        [[nodiscard]] transform_configuration_t& create_global_transform_config() {
            return global_transform_configurations_.emplace_back();
        }

        [[nodiscard]] obfuscator_config_t& obfuscator_config() {
            return obfuscator_config_;
        }

        [[nodiscard]] func_parser_config_t& func_parser_config() {
            return func_parser_config_;
        }

        [[nodiscard]] std::vector<transform_configuration_t> global_transforms_config() {
            return global_transform_configurations_;
        }

        [[nodiscard]] auto begin() {
            return function_configurations_.begin();
        }

        [[nodiscard]] auto begin() const {
            return function_configurations_.begin();
        }

        [[nodiscard]] auto end() {
            return function_configurations_.end();
        }

        [[nodiscard]] auto end() const {
            return function_configurations_.end();
        }

        [[nodiscard]] auto size() const {
            return function_configurations_.size();
        }

    private:
        std::vector<function_configuration_t> function_configurations_ = {};
        std::vector<transform_configuration_t> global_transform_configurations_ = {};
        obfuscator_config_t obfuscator_config_ = {};
        func_parser_config_t func_parser_config_ = {};
    };

    Config from_argv(std::size_t argc, char* argv[]);
} // namespace config_parser

```

`src/lib/config_parser/structs.hpp`:

```hpp
#pragma once
#include <filesystem>
#include <optional>
#include <unordered_map>
#include <vector>

namespace config_parser {
    struct transform_configuration_t {
        std::size_t tag = {};
        std::unordered_map<std::string, std::string> values = {};
    };

    struct function_configuration_t {
        std::string function_name = {};
        std::vector<transform_configuration_t> transform_configurations = {};
    };

    struct obfuscator_config_t {
        std::filesystem::path binary_path = "";
    };

    struct func_parser_config_t {
        bool pdb_enabled = true;
        std::optional<std::filesystem::path> pdb_path = std::nullopt;

        bool map_enabled = false;
        std::optional<std::filesystem::path> map_path = std::nullopt;
    };
} // namespace config_parser
```

`src/lib/easm/assembler/assembler.cpp`:

```cpp
#include "easm/assembler/assembler.hpp"

namespace easm {
    constexpr auto kByteSizeInBits = 8;

    std::size_t estimate_program_size(const zasm::Program& program) {
        std::size_t result = 0;

        //
        // Iterating program nodes
        //
        for (auto* node = program.getHead(); node != nullptr; node = node->getNext()) {
            //
            // Handling `zasm::Data`
            //
            if (const auto* node_data = node->getIf<zasm::Data>(); node_data != nullptr) {
                result += node_data->getTotalSize();
                continue;
            }

            //
            // Handling `zasm::Instruction`
            //
            if (const auto* node_insn = node->getIf<zasm::Instruction>(); node_insn != nullptr) {
                const auto& insn_info = node_insn->getDetail(program.getMode());

                if (!insn_info) {
                    throw std::runtime_error("Unable to estimate program size: unable to get if instr info");
                }

                result += insn_info->getLength();
                continue;
            }

            //
            // Handling `zasm::EmbeddedLabel`
            //
            if (const auto* embedded_label = node->getIf<zasm::EmbeddedLabel>(); embedded_label != nullptr) {
                result += getBitSize(embedded_label->getSize()) / kByteSizeInBits;
            }
        }

        return result;
    }

    assembled_t assemble_program(const memory::address base_address, const zasm::Program& program) {
        zasm::Serializer serializer = {};

        // Serializing program
        //
        if (const auto err = serializer.serialize(program, base_address.as<std::int64_t>()); err != zasm::Error::None) {
            throw std::runtime_error(std::format("Unable to serialize program: {}", getErrorName(err)));
        }

        // Copying the result buffer
        //
        assembled_t result = {};
        result.data.resize(serializer.getCodeSize());
        std::memcpy(result.data.data(), serializer.getCode(), result.data.size());

        // Store relocations
        //
        for (std::size_t i = 0; i < serializer.getRelocationCount(); ++i) {
            result.relocations.emplace_back(*serializer.getRelocation(i));
        }

        return result;
    }

    std::expected<std::vector<std::uint8_t>, zasm::Error> encode_jmp(const zasm::MachineMode machine_mode, const memory::address source,
                                                                     const memory::address destination) {
        zasm::Program program(machine_mode);
        zasm::x86::Assembler assembler(program);

        assembler.jmp(zasm::Imm(destination.as<std::uint64_t>()));

        zasm::Serializer serializer;
        if (auto res = serializer.serialize(program, source.as<std::int64_t>()); res != zasm::Error::None) {
            return std::unexpected(res);
        }

        std::vector<std::uint8_t> result = {};
        result.resize(serializer.getCodeSize());
        std::memcpy(result.data(), serializer.getCode(), result.size());

        return result;
    }
} // namespace easm

```

`src/lib/easm/assembler/assembler.hpp`:

```hpp
#pragma once
#include "util/memory/address.hpp"
#include <expected>
#include <list>
#include <vector>
#include <zasm/zasm.hpp>

namespace easm {
    struct assembled_t {
        std::vector<std::uint8_t> data;
        std::list<zasm::RelocationInfo> relocations;
    };

    std::size_t estimate_program_size(const zasm::Program& program);
    assembled_t assemble_program(memory::address base_address, const zasm::Program& program);
    std::expected<std::vector<std::uint8_t>, zasm::Error> encode_jmp(zasm::MachineMode machine_mode, memory::address source, memory::address destination);
} // namespace easm

```

`src/lib/easm/cursor/cursor.hpp`:

```hpp
#pragma once
#include "util/structs.hpp"
#include <optional>
#include <zasm/zasm.hpp>

namespace easm {
    enum class node_pos_t : std::uint8_t {
        instead_of = 0,
        before,
        after
    };

    class Cursor {
    public:
        DEFAULT_DTOR(Cursor);
        DEFAULT_COPY(Cursor); // do we need to copy it though?
        explicit Cursor(std::shared_ptr<zasm::Program> program, std::shared_ptr<zasm::x86::Assembler> assembler)
            : program_(std::move(program)), assembler_(std::move(assembler)) { }

        /// \brief Set cursor at the node and destroy it
        /// \param node node that it should destroy
        /// \return assembler ptr
        std::optional<zasm::x86::Assembler*> instead_of(zasm::Node* node) const noexcept {
            if (node == nullptr) {
                return std::nullopt;
            }

            assembler_->setCursor(node);
            program_->destroy(node);
            return std::make_optional(assembler_.get());
        }

        /// \brief Set cursor before the node
        /// \param node node
        /// \return assembler ptr
        std::optional<zasm::x86::Assembler*> before(zasm::Node* node) const noexcept {
            if (node == nullptr) {
                return std::nullopt;
            }

            const auto prev_node = node->getPrev();
            if (prev_node == nullptr) {
                return std::nullopt;
            }

            assembler_->setCursor(prev_node);
            return std::make_optional(assembler_.get());
        }

        /// \brief Set cursor after the node
        /// \param node node
        /// \return assembler ptr
        std::optional<zasm::x86::Assembler*> after(zasm::Node* node) const noexcept {
            if (node == nullptr) {
                return std::nullopt;
            }

            assembler_->setCursor(node);
            return std::make_optional(assembler_.get());
        }

        /// \brief An all-in-one cursor setter
        /// \param node node
        /// \param pos position
        /// \return assembler ptr
        std::optional<zasm::x86::Assembler*> set(zasm::Node* node, const node_pos_t pos = node_pos_t::after) const noexcept {
            switch (pos) {
            case node_pos_t::after:
                return after(node);
            case node_pos_t::before:
                return before(node);
            case node_pos_t::instead_of:
                return instead_of(node);
            }

            std::unreachable();
        }

        /// \brief Set cursor at the program tail (end)
        /// \return assembler ptr
        [[nodiscard]] std::optional<zasm::x86::Assembler*> program_tail() const noexcept {
            assembler_->setCursor(program_->getTail());
            return std::make_optional(assembler_.get());
        }

    private:
        std::shared_ptr<zasm::Program> program_ = {};
        std::shared_ptr<zasm::x86::Assembler> assembler_ = {};
    };
} // namespace easm

```

`src/lib/easm/debug/debug.hpp`:

```hpp
#pragma once
#include "analysis/common/debug.hpp"
#include "util/memory/address.hpp"

namespace easm {
    inline void dump_program(const zasm::Program& program) {
        /// Iterating over the program nodes
        ///
        for (auto* node = program.getHead(); node != nullptr; node = node->getNext()) {
            // Handling `zasm::Data`
            //
            if (const auto* node_data = node->getIf<zasm::Data>(); node_data != nullptr) {
                logger::info("Data: {:#x}", node_data->valueAsU64());
                continue;
            }

            //
            // Handling `zasm::Instruction`
            //
            if (auto* node_insn = node->getIf<zasm::Instruction>(); node_insn != nullptr) {
                if (const auto& insn_info = node_insn->getDetail(program.getMode()); !insn_info) {
                    throw std::runtime_error("Unable to debug dump program: unable to get if instr info");
                }

                logger::info("Instruction: {}", ZydisMnemonicGetString(static_cast<ZydisMnemonic>(node_insn->getMnemonic().value())));
                if (const auto ops_count = node_insn->getOperandCount(); ops_count > 0) {
                    logger::info<1>("Operands:");

                    for (std::size_t i = 0; i < ops_count; ++i) {
                        const auto operand = node_insn->getOperand(i);

                        using namespace analysis::debug::detail;
                        const auto operand_name_pair = operand_type_lookup.find(operand.getTypeIndex());
                        const auto operand_name = //
                            operand_name_pair == std::end(operand_type_lookup) ? unknown_type_name : operand_name_pair->second;

                        logger::info<2>("{}", operand_name);

                        if (const auto* p_imm = node_insn->getOperandIf<zasm::Imm>(i); p_imm) {
                            logger::info<3>("Value: {:#x}", p_imm->value<std::uint64_t>());
                        }

                        if (const auto* p_mem = node_insn->getOperandIf<zasm::Mem>(i); p_mem) {
                            const auto reg = static_cast<ZydisRegister_>(p_mem->getBase().getId());
                            logger::info<3>("expr: [{} + {:#x}]",
                                            reg == 0                ? "none" :
                                            p_mem->getBase().isIP() ? "ip" :
                                                                      std::to_string(reg),
                                            p_mem->getDisplacement());
                        }
                    }
                }

                continue;
            }

            //
            // Handling `zasm::EmbeddedLabel`
            //
            if (const auto* embedded_label = node->getIf<zasm::EmbeddedLabel>(); embedded_label != nullptr) {
                logger::info("Label");
            }
        }
    }
} // namespace easm
```

`src/lib/easm/disassembler/disassembler.cpp`:

```cpp
#include "easm/disassembler/disassembler.hpp"
#include <stdexcept>

namespace easm {
    zasm::Program Decoder::decode_block(const std::uint8_t* data, const std::size_t size, const uint64_t orig_address) {
        zasm::Program result(machine_mode_);
        zasm::x86::Assembler assembler(result);

        std::size_t decoded = 0;
        while (decoded < size) {
            const auto decoded_result = decode_insn_detail(data + decoded, size - decoded, orig_address + decoded);
            if (!decoded_result) {
                throw std::runtime_error("Unable to decode data");
            }

            if (const auto res = assembler.emit(decoded_result->getInstruction()); res != zasm::Error::None) {
                throw std::runtime_error("Unable to encode decoded data");
            }

            decoded += decoded_result->getLength();
        }

        return result;
    }

    std::expected<zasm::InstructionDetail, zasm::Error> Decoder::decode_insn_detail(const std::uint8_t* data, const size_t size,
                                                                                    const uint64_t orig_address) {
        const auto result = decoder_.decode(data, size, orig_address);

        if (!result) {
            return std::unexpected(result.error());
        }

        return result.value();
    }

    std::expected<zasm::Instruction, zasm::Error> Decoder::decode_insn(const std::uint8_t* data, const size_t size, const uint64_t orig_address) {
        const auto result = decode_insn_detail(data, size, orig_address);

        if (!result) {
            return std::unexpected(result.error());
        }

        return result->getInstruction();
    }

    //

    zasm::Program decode_block(const std::uint8_t* data, const std::size_t size, const zasm::MachineMode machine_mode, const uint64_t orig_address) {
        Decoder decoder(machine_mode);

        return decoder.decode_block(data, size, orig_address);
    }

    std::expected<zasm::InstructionDetail, zasm::Error> decode_insn_detail(const std::uint8_t* data, const zasm::MachineMode machine_mode,
                                                                           const uint64_t orig_address) {
        Decoder decoder(machine_mode);

        return decoder.decode_insn_detail(data, orig_address);
    }

    std::expected<zasm::Instruction, zasm::Error> decode_insn(const std::uint8_t* data, const zasm::MachineMode machine_mode,
                                                              const uint64_t orig_address) {
        Decoder decoder(machine_mode);

        return decoder.decode_insn(data, orig_address);
    }
} // namespace easm

```

`src/lib/easm/disassembler/disassembler.hpp`:

```hpp
#pragma once
#include "util/structs.hpp"

#include <cstdint>
#include <expected>
#include <zasm/zasm.hpp>

namespace easm {
    constexpr zasm::MachineMode kDefaultMm = zasm::MachineMode::AMD64;
    constexpr size_t kDefaultSize = 15;

    class Decoder {
    public:
        DEFAULT_DTOR(Decoder);
        DEFAULT_COPY(Decoder);
        explicit Decoder(const zasm::MachineMode machine_mode = kDefaultMm): machine_mode_(machine_mode), decoder_(machine_mode_) { }

        zasm::Program decode_block(const std::uint8_t* data, std::size_t size, uint64_t orig_address = 0ULL);
        std::expected<zasm::InstructionDetail, zasm::Error> decode_insn_detail(const std::uint8_t* data, size_t size = kDefaultSize,
                                                                               uint64_t orig_address = 0ULL);
        std::expected<zasm::Instruction, zasm::Error> decode_insn(const std::uint8_t* data, size_t size = kDefaultSize, uint64_t orig_address = 0ULL);

    private:
        zasm::MachineMode machine_mode_;
        zasm::Decoder decoder_;
    };

    zasm::Program decode_block(const std::uint8_t* data, std::size_t size = kDefaultSize, zasm::MachineMode machine_mode = kDefaultMm,
                               uint64_t orig_address = 0ULL);

    std::expected<zasm::InstructionDetail, zasm::Error> decode_insn_detail(const std::uint8_t* data, size_t size = kDefaultSize,
                                                                           zasm::MachineMode machine_mode = kDefaultMm, uint64_t orig_address = 0ULL);

    std::expected<zasm::Instruction, zasm::Error> decode_insn(const std::uint8_t* data, size_t size = kDefaultSize,
                                                              zasm::MachineMode machine_mode = kDefaultMm, uint64_t orig_address = 0ULL);
} // namespace easm

```

`src/lib/easm/easm.hpp`:

```hpp
#pragma once

/// \note @es3n1n: Just some general notes
/// - I'm not really a fan of passing machine mode everywhere we can since there could be only 1 machine mode
///     per binary, so we can/should probbaly store it somewhere globally me thinks

#include "easm/assembler/assembler.hpp"
#include "easm/disassembler/disassembler.hpp"
#include "easm/misc/misc.hpp"
#include "easm/misc/reg_convert.hpp"

```

`src/lib/easm/misc/misc.hpp`:

```hpp
#pragma once
#include "pe/pe.hpp"

#include <optional>
#include <stdexcept>
#include <zasm/zasm.hpp>

namespace easm {
    inline bool is_jcc_or_jmp(const zasm::Instruction& insn) {
        const auto mnemonic = insn.getMnemonic();

        return mnemonic >= ZYDIS_MNEMONIC_JB && mnemonic <= ZYDIS_MNEMONIC_JZ;
    }

    inline bool is_jcc_or_jmp(const zasm::InstructionDetail& insn) {
        const auto insn_info = insn.getInstruction();
        return is_jcc_or_jmp(insn_info);
    }

    inline bool is_ret(const zasm::Instruction& insn) {
        const auto mnemonic = insn.getMnemonic();
        return mnemonic.value() == ZYDIS_MNEMONIC_RET;
    }

    inline bool is_ret(const zasm::InstructionDetail& insn) {
        const auto insn_info = insn.getInstruction();
        return is_ret(insn_info);
    }

    inline bool affects_ip(const zasm::Instruction& insn) {
        if (is_jcc_or_jmp(insn)) {
            return true;
        }

        if (insn.getMnemonic().value() == ZYDIS_MNEMONIC_CALL) {
            return true;
        }

        bool result = false;
        for (std::size_t i = 0; i < insn.getOperandCount() && !result; ++i) {
            if (const auto* op_reg = insn.getOperandIf<zasm::Reg>(i); op_reg != nullptr) {
                result = op_reg->isIP();
                continue;
            }

            if (const auto* op_mem = insn.getOperandIf<zasm::Mem>(i); op_mem != nullptr) {
                result = op_mem->getBase().isIP();
            }
        }

        return result;
    }

    inline bool affects_ip(const zasm::InstructionDetail& insn) {
        const auto insn_info = insn.getInstruction();
        return affects_ip(insn_info);
    }

    struct jcc_t {
        bool conditional = false;
        std::optional<std::uint64_t> branch = std::nullopt;
        std::optional<const zasm::Label*> branch_label = std::nullopt;
    };

    inline jcc_t follow_jcc_or_jmp(const zasm::Instruction& insn) {
        if (!is_jcc_or_jmp(insn)) {
            throw std::runtime_error("Tried to follow non-jcc instruction");
        }

        jcc_t result = {};
        result.conditional = insn.getMnemonic().value() != ZYDIS_MNEMONIC_JMP;

        for (std::size_t i = 0; i < insn.getOperandCount(); ++i) {
            if (const auto* operand = insn.getOperandIf<zasm::Imm>(i)) {
                result.branch = std::make_optional<std::uint64_t>(operand->value<std::uint64_t>());
                break;
            }

            if (const auto* label = insn.getOperandIf<zasm::Label>(i)) {
                result.branch_label = std::make_optional(label);
                break;
            }
        }

        return result;
    }

    inline jcc_t follow_jcc_or_jmp(const zasm::InstructionDetail& insn) {
        const auto insn_info = insn.getInstruction();
        return follow_jcc_or_jmp(insn_info);
    }

    inline std::optional<zasm::BitSize> get_operand_size(const zasm::MachineMode machine_mode, const zasm::Operand& operand) {
        if (auto* op_reg = operand.getIf<zasm::Reg>()) {
            return op_reg->getBitSize(machine_mode);
        }

        if (auto* op_mem = operand.getIf<zasm::Mem>()) {
            return op_mem->getBitSize(machine_mode);
        }

        return std::nullopt;
    }

    inline std::optional<zasm::BitSize> get_operand_size(const zasm::MachineMode machine_mode, const zasm::Instruction* insn, const std::size_t index) {
        return get_operand_size(machine_mode, insn->getOperand(index));
    }

    inline zasm::x86::Gp to_gp(const zasm::Reg reg) {
        return zasm::x86::Gp{reg.getId()};
    }

    inline zasm::x86::Gp to_root_gp(const zasm::MachineMode machine_mode, const zasm::Reg reg) {
        return zasm::x86::Gp{reg.getRoot(machine_mode).getId()};
    }

    inline std::pair<zasm::x86::Gp, zasm::x86::Gp> to_gp_root_gp(const zasm::MachineMode machine_mode, const zasm::Reg reg) {
        return std::make_pair<zasm::x86::Gp, zasm::x86::Gp>(to_gp(reg), to_root_gp(machine_mode, reg));
    }

    inline void assert_operand_used_reg(const zasm::MachineMode machine_mode, const zasm::Instruction* insn, const std::size_t index,
                                        const zasm::Reg reg) {
        if (auto* op_reg = insn->getOperandIf<zasm::Reg>(index)) {
            assert(to_root_gp(machine_mode, *op_reg).getId() != reg.getId());
        }

        if (auto* op_mem = insn->getOperandIf<zasm::Mem>(index); op_mem != nullptr && op_mem->getBase().isValid()) {
            assert(to_root_gp(machine_mode, op_mem->getBase()).getId() != reg.getId());
        }
    }

    inline void assert_operand_size(const zasm::MachineMode machine_mode, const zasm::Instruction* insn, const std::size_t index, const zasm::Reg reg) {
        if (const auto size = get_operand_size(machine_mode, insn, index); size.has_value()) {
            assert(size.value() == reg.getBitSize(machine_mode));
        }
    }

    inline bool is_sp(const zasm::MachineMode machine_mode, const zasm::Reg reg) {
        const auto sp_reg = static_cast<zasm::Reg::Id>(machine_mode == zasm::MachineMode::AMD64 ? ZYDIS_REGISTER_RSP : ZYDIS_REGISTER_ESP);
        return reg.getRoot(machine_mode).getId() == sp_reg;
    }

    inline bool affects_sp(const zasm::MachineMode machine_mode, const zasm::Instruction& insn) {
        for (std::size_t i = 0; i < insn.getOperandCount(); ++i) {
            if (auto* op_mem = insn.getOperandIf<zasm::Mem>(i); op_mem != nullptr) {
                if (is_sp(machine_mode, op_mem->getBase())) {
                    return true;
                }
                continue;
            }

            if (auto* op_reg = insn.getOperandIf<zasm::Reg>(i); op_reg != nullptr) {
                if (is_sp(machine_mode, *op_reg)) {
                    return true;
                }
            }
        }

        return false;
    }

    inline std::vector<zasm::Reg> get_all_registers(const zasm::Instruction& insn) {
        std::vector<zasm::Reg> result = {};

        for (std::size_t i = 0; i < insn.getOperandCount(); ++i) {
            if (auto* op_mem = insn.getOperandIf<zasm::Mem>(i); op_mem != nullptr && op_mem->getBase().isValid()) {
                result.emplace_back(op_mem->getBase());
                continue;
            }

            if (auto* op_reg = insn.getOperandIf<zasm::Reg>(i); op_reg != nullptr) {
                result.emplace_back(*op_reg);
            }
        }

        return result;
    }

    template <pe::any_image_t Img>
    constexpr zasm::x86::Gp sp_for_arch() {
        if constexpr (pe::is_x64_v<Img>) {
            return zasm::x86::rsp;
        } else {
            return zasm::x86::esp;
        }
    }

    template <pe::any_image_t Img, typename... TArgs>
    constexpr zasm::Mem ptr(TArgs... args) {
        if constexpr (pe::is_x64_v<Img>) {
            return zasm::x86::qword_ptr(std::forward<TArgs>(args)...);
        } else {
            return zasm::x86::dword_ptr(std::forward<TArgs>(args)...);
        }
    }
} // namespace easm

```

`src/lib/easm/misc/reg_convert.hpp`:

```hpp
#pragma once
#include <zasm/zasm.hpp>

/*
64	32lo	16lo	8lo
rax	eax	ax	al
rbx	ebx	bx	bl
rcx	ecx	cx	cl
rdx	edx	dx	dl
rsi	esi	si	sil
rdi	edi	di	dil
rbp	ebp	bp	bpl
rsp	esp	sp	spl
r8	r8d	r8w	r8b
r9	r9d	r9w	r9b
r10	r10d	r10w	r10b
r11	r11d	r11w	r11b
r12	r12d	r12w	r12b
r13	r13d	r13w	r13b
r14	r14d	r14w	r14b
r15	r15d	r15w	r15b

In [1]: lines = '''rax^Ieax^Iax^Ial
   ...: rbx^Iebx^Ibx^Ibl
   ...: rcx^Iecx^Icx^Icl
   ...: rdx^Iedx^Idx^Idl
   ...: rsi^Iesi^Isi^Isil
   ...: rdi^Iedi^Idi^Idil
   ...: rbp^Iebp^Ibp^Ibpl
   ...: rsp^Iesp^Isp^Ispl
   ...: r8^Ir8d^Ir8w^Ir8b
   ...: r9^Ir9d^Ir9w^Ir9b
   ...: r10^Ir10d^Ir10w^Ir10b
   ...: r11^Ir11d^Ir11w^Ir11b
   ...: r12^Ir12d^Ir12w^Ir12b
   ...: r13^Ir13d^Ir13w^Ir13b
   ...: r14^Ir14d^Ir14w^Ir14b
   ...: r15^Ir15d^Ir15w^Ir15b'''

In [2]: lines = lines.splitlines()

In [3]: lines = [x.split('\t') for x in lines]

In [4]: for line in lines:
   ...:     print(f'CONVERTER(ZYDIS_REGISTER_{line[1].upper()}, ZYDIS_REGISTER_{line[0].upper()});')
   ...:
 */

/// \note @es3n1n: Would be pretty cool to have something like this in zasm
namespace easm::reg_convert {
    namespace detail {
        inline void throw_exc() {
            throw std::runtime_error("reg_convert: unknown register");
        }
    } // namespace detail

#define CONVERTER(from, to) \
    case from:              \
        return zasm::Reg::Id(to)

    inline zasm::Reg::Id gp32_to_gp64(const zasm::Reg::Id reg_id) {
        switch (static_cast<ZydisRegister_>(reg_id)) {
            CONVERTER(ZYDIS_REGISTER_EAX, ZYDIS_REGISTER_RAX);
            CONVERTER(ZYDIS_REGISTER_EBX, ZYDIS_REGISTER_RBX);
            CONVERTER(ZYDIS_REGISTER_ECX, ZYDIS_REGISTER_RCX);
            CONVERTER(ZYDIS_REGISTER_EDX, ZYDIS_REGISTER_RDX);
            CONVERTER(ZYDIS_REGISTER_ESI, ZYDIS_REGISTER_RSI);
            CONVERTER(ZYDIS_REGISTER_EDI, ZYDIS_REGISTER_RDI);
            CONVERTER(ZYDIS_REGISTER_EBP, ZYDIS_REGISTER_RBP);
            CONVERTER(ZYDIS_REGISTER_ESP, ZYDIS_REGISTER_RSP);
            CONVERTER(ZYDIS_REGISTER_R8D, ZYDIS_REGISTER_R8);
            CONVERTER(ZYDIS_REGISTER_R9D, ZYDIS_REGISTER_R9);
            CONVERTER(ZYDIS_REGISTER_R10D, ZYDIS_REGISTER_R10);
            CONVERTER(ZYDIS_REGISTER_R11D, ZYDIS_REGISTER_R11);
            CONVERTER(ZYDIS_REGISTER_R12D, ZYDIS_REGISTER_R12);
            CONVERTER(ZYDIS_REGISTER_R13D, ZYDIS_REGISTER_R13);
            CONVERTER(ZYDIS_REGISTER_R14D, ZYDIS_REGISTER_R14);
            CONVERTER(ZYDIS_REGISTER_R15D, ZYDIS_REGISTER_R15);
        default:
            break;
        }
        detail::throw_exc();
        std::unreachable();
    }

    inline zasm::Reg::Id gp64_to_gp32(const zasm::Reg::Id reg_id) {
        switch (static_cast<ZydisRegister_>(reg_id)) {
            CONVERTER(ZYDIS_REGISTER_RAX, ZYDIS_REGISTER_EAX);
            CONVERTER(ZYDIS_REGISTER_RBX, ZYDIS_REGISTER_EBX);
            CONVERTER(ZYDIS_REGISTER_RCX, ZYDIS_REGISTER_ECX);
            CONVERTER(ZYDIS_REGISTER_RDX, ZYDIS_REGISTER_EDX);
            CONVERTER(ZYDIS_REGISTER_RSI, ZYDIS_REGISTER_ESI);
            CONVERTER(ZYDIS_REGISTER_RDI, ZYDIS_REGISTER_EDI);
            CONVERTER(ZYDIS_REGISTER_RBP, ZYDIS_REGISTER_EBP);
            CONVERTER(ZYDIS_REGISTER_RSP, ZYDIS_REGISTER_ESP);
            CONVERTER(ZYDIS_REGISTER_R8, ZYDIS_REGISTER_R8D);
            CONVERTER(ZYDIS_REGISTER_R9, ZYDIS_REGISTER_R9D);
            CONVERTER(ZYDIS_REGISTER_R10, ZYDIS_REGISTER_R10D);
            CONVERTER(ZYDIS_REGISTER_R11, ZYDIS_REGISTER_R11D);
            CONVERTER(ZYDIS_REGISTER_R12, ZYDIS_REGISTER_R12D);
            CONVERTER(ZYDIS_REGISTER_R13, ZYDIS_REGISTER_R13D);
            CONVERTER(ZYDIS_REGISTER_R14, ZYDIS_REGISTER_R14D);
            CONVERTER(ZYDIS_REGISTER_R15, ZYDIS_REGISTER_R15D);
        default:
            break;
        }
        detail::throw_exc();
        std::unreachable();
    }

    inline zasm::Reg::Id gp64_to_gp16(const zasm::Reg::Id reg_id) {
        switch (static_cast<ZydisRegister_>(reg_id)) {
            CONVERTER(ZYDIS_REGISTER_RAX, ZYDIS_REGISTER_AX);
            CONVERTER(ZYDIS_REGISTER_RBX, ZYDIS_REGISTER_BX);
            CONVERTER(ZYDIS_REGISTER_RCX, ZYDIS_REGISTER_CX);
            CONVERTER(ZYDIS_REGISTER_RDX, ZYDIS_REGISTER_DX);
            CONVERTER(ZYDIS_REGISTER_RSI, ZYDIS_REGISTER_SI);
            CONVERTER(ZYDIS_REGISTER_RDI, ZYDIS_REGISTER_DI);
            CONVERTER(ZYDIS_REGISTER_RBP, ZYDIS_REGISTER_BP);
            CONVERTER(ZYDIS_REGISTER_RSP, ZYDIS_REGISTER_SP);
            CONVERTER(ZYDIS_REGISTER_R8, ZYDIS_REGISTER_R8W);
            CONVERTER(ZYDIS_REGISTER_R9, ZYDIS_REGISTER_R9W);
            CONVERTER(ZYDIS_REGISTER_R10, ZYDIS_REGISTER_R10W);
            CONVERTER(ZYDIS_REGISTER_R11, ZYDIS_REGISTER_R11W);
            CONVERTER(ZYDIS_REGISTER_R12, ZYDIS_REGISTER_R12W);
            CONVERTER(ZYDIS_REGISTER_R13, ZYDIS_REGISTER_R13W);
            CONVERTER(ZYDIS_REGISTER_R14, ZYDIS_REGISTER_R14W);
            CONVERTER(ZYDIS_REGISTER_R15, ZYDIS_REGISTER_R15W);
        default:
            break;
        }
        detail::throw_exc();
        std::unreachable();
    }

    inline zasm::Reg::Id gp64_to_gp8(const zasm::Reg::Id reg_id) {
        switch (static_cast<ZydisRegister_>(reg_id)) {
            CONVERTER(ZYDIS_REGISTER_RAX, ZYDIS_REGISTER_AL);
            CONVERTER(ZYDIS_REGISTER_RBX, ZYDIS_REGISTER_BL);
            CONVERTER(ZYDIS_REGISTER_RCX, ZYDIS_REGISTER_CL);
            CONVERTER(ZYDIS_REGISTER_RDX, ZYDIS_REGISTER_DL);
            CONVERTER(ZYDIS_REGISTER_RSI, ZYDIS_REGISTER_SIL);
            CONVERTER(ZYDIS_REGISTER_RDI, ZYDIS_REGISTER_DIL);
            CONVERTER(ZYDIS_REGISTER_RBP, ZYDIS_REGISTER_BPL);
            CONVERTER(ZYDIS_REGISTER_RSP, ZYDIS_REGISTER_SPL);
            CONVERTER(ZYDIS_REGISTER_R8, ZYDIS_REGISTER_R8B);
            CONVERTER(ZYDIS_REGISTER_R9, ZYDIS_REGISTER_R9B);
            CONVERTER(ZYDIS_REGISTER_R10, ZYDIS_REGISTER_R10B);
            CONVERTER(ZYDIS_REGISTER_R11, ZYDIS_REGISTER_R11B);
            CONVERTER(ZYDIS_REGISTER_R12, ZYDIS_REGISTER_R12B);
            CONVERTER(ZYDIS_REGISTER_R13, ZYDIS_REGISTER_R13B);
            CONVERTER(ZYDIS_REGISTER_R14, ZYDIS_REGISTER_R14B);
            CONVERTER(ZYDIS_REGISTER_R15, ZYDIS_REGISTER_R15B);
        default:
            break;
        }
        detail::throw_exc();
        std::unreachable();
    }

#undef CONVERTER
} // namespace easm::reg_convert

```

`src/lib/func_parser/common/combiner.hpp`:

```hpp
#pragma once
#include <algorithm>

#include "func_parser/common/common.hpp"

namespace func_parser::combiner {
    inline function_list_t combine_function_lists(std::vector<function_list_t>& lists) {
        // No lists?
        //
        if (lists.empty()) {
            return {};
        }

        // Pick first entry as base entry
        //
        function_list_t result = lists.at(0);

        // Nothing to combine
        //
        if (lists.size() == 1) {
            return result;
        }

        // Iterating over other lists
        //
        std::for_each(lists.begin() + 1, lists.end(), [&result](const function_list_t& functions) -> void {
            std::ranges::for_each(functions, [&result](const function_t& function) -> void {
                // Looking for this function in result
                //
                const auto result_it = std::ranges::find_if(result, [function](const function_t& func) -> bool { //
                    return func.rva == function.rva;
                });

                // If this is something new that we haven't seen already then we
                // should just store it
                //
                if (result_it == result.end()) {
                    result.emplace_back(function);
                    return;
                }

                // Trying to merge attributes of a function
                //
                result_it->merge(function);
            });
        });

        // We are done here
        //
        return result;
    }
} // namespace func_parser::combiner

```

`src/lib/func_parser/common/common.hpp`:

```hpp
#pragma once
#include <cstdint>
#include <format>
#include <optional>
#include <string>
#include <vector>

namespace func_parser {
    struct function_t {
        constexpr function_t() = default;

        bool valid = false;
        std::string name = {};
        std::uint64_t rva = 0;
        std::optional<std::size_t> size = std::nullopt;

        // \note: @es3n1n: im not really sure how to properly merge stuff like
        // names. technically there could be a different size of function in the
        // different sources, but I'll let the future me to decide on this
        void merge(const function_t& another) {
            // Trying to merge size
            //
            if (!this->size.has_value() && another.size.has_value()) {
                this->size = std::make_optional<std::size_t>(another.size.value());
            }

            // Copying name if item is in a valid state now
            //
            if (!this->valid && another.valid) {
                this->valid = another.valid;
                this->name = another.name;
            }
        }
    };

    using function_list_t = std::vector<function_t>;
} // namespace func_parser

template <>
struct std::formatter<func_parser::function_t> : std::formatter<std::string> {
    template <class FormatContextTy>
    constexpr auto format(const func_parser::function_t& inst, FormatContextTy& ctx) const {
        return std::formatter<std::string>::format( //
            std::format("valid[{}] name[{}] size[{}] rva[{:#x}]", inst.valid, inst.name,
                        inst.size.has_value() ? std::to_string(inst.size.value()) : "none", inst.rva),
            ctx);
    }
};

```

`src/lib/func_parser/common/sanitizer.hpp`:

```hpp
#pragma once
#include "func_parser/common/common.hpp"
#include "pe/pe.hpp"

namespace func_parser::sanitizer {
    template <pe::any_image_t Img>
    function_list_t sanitize_function_list(function_list_t items, const Img* image) noexcept {
        // Obtaining executable sections
        //
        const auto exec_sections = image->find_sections_if([](const pe::section_t& sec) -> bool { //
            return sec.characteristics.mem_execute;
        });

        // Iterating over functions
        //
        std::erase_if(items, [exec_sections](const function_t& item) -> bool {
            // Erasing invalid functions
            //
            if (!item.valid) {
                logger::debug("func_parser: sanitizing: !valid: {}", item);
                return true;
            }

            // Checking whether function is in an executable section or not
            //
            bool in_exec_mem = false;
            for (auto& sec : exec_sections) {
                in_exec_mem = item.rva >= sec.virtual_address && item.rva <= (sec.virtual_address + sec.virtual_size);

                if (in_exec_mem) {
                    break;
                }
            }

            if (!in_exec_mem) {
                logger::debug("func_parser: sanitizing: !in_exec_mem: {}", item);
            }

            // If a function isn't in an executable memory, then we should get rid of it
            // because its obviously not a function, and we can't do much with it
            //
            return !in_exec_mem;
        });

        return items;
    }
} // namespace func_parser::sanitizer

```

`src/lib/func_parser/map/map.cpp`:

```cpp
#include <regex>

#include "func_parser/map/map.hpp"
#include "util/logger.hpp"
#include "util/memory/casts.hpp"

#include <cassert>

namespace func_parser::map {
    namespace {

        // Extracting `0001` segment index, `00000000` segment offset and `main` from
        // `0001:00000000 main 0000000140001000 f FileName.obj`
        //
        const std::regex SYMBOL_REGEX(R"(([0-9a-fA-F]+):([0-9a-fA-F]+)\s+([^\s]+))");

        std::uint64_t parse_hex_string(const std::string& value) {
            // NOLINTNEXTLINE
            return std::stoull(value, nullptr, 16);
        }
    } // namespace

    function_list_t discover_functions(const std::filesystem::path& map_path, const std::vector<pe::section_t>& sections) {
        // Reading map file
        //
        const auto map_content = util::read_file(map_path);
        if (map_content.empty()) {
            throw std::runtime_error("Empty map file");
        }

        // Converting to string stream
        //
        std::stringstream str_stream;
        str_stream.str(std::string{memory::cast<const char*>(map_content.data()), map_content.size()});

        // Initializing func_parser state
        //
        function_list_t result;
        bool parsing_symbols = false;

        // Initializing regex matches
        //
        std::smatch matches;

        for (std::string line; std::getline(str_stream, line);) {
            // Skipping empty lines
            //
            if (line.empty()) {
                continue;
            }

            // If we are not parsing symbols, then we should try to find the
            // start marker of symbols first
            // `Address Publics by Value Rva+Base Lib:Object`
            //
            if (!parsing_symbols) {
                parsing_symbols = line.find("ddress") != std::string::npos && //
                                  line.find("ublics by Value") != std::string::npos;
                continue;
            }

            // Stop once we hit the `entry point` and/or `Static symbols`
            //
            if (line.find("ntry point at") != std::string::npos || //
                line.find("tatic symbols") != std::string::npos) {
                break;
            }

            // Ok, at this point we are just parsing symbols, so we should extract
            // the VA, name and we are done
            //
            if (!std::regex_search(line, matches, SYMBOL_REGEX)) {
                continue;
            }

            // Get the section
            //
            auto section_index = parse_hex_string(matches[1]);
            if (section_index == 0) {
                continue; // garbage
            }
            section_index -= 1;
            assert(section_index < sections.size());
            const auto& section = sections.at(section_index);
            const auto section_offset = parse_hex_string(matches[2]);
            const auto name = matches[3];

            // Assembling the function info
            //
            auto& function = result.emplace_back();
            function.valid = true; // :skull:
            function.size = std::nullopt;
            function.rva = section.virtual_address + section_offset;
            function.name = name;
        }

        return result;
    }
} // namespace func_parser::map

```

`src/lib/func_parser/map/map.hpp`:

```hpp
#pragma once
#include "func_parser/common/common.hpp"
#include "pe/common/types.hpp"
#include "util/files.hpp"

namespace func_parser::map {
    function_list_t discover_functions(const std::filesystem::path& map_path, const std::vector<pe::section_t>& sections);
} // namespace func_parser::map

```

`src/lib/func_parser/parser.cpp`:

```cpp
#include "func_parser/parser.hpp"
#include "func_parser/common/combiner.hpp"
#include "func_parser/map/map.hpp"
#include "func_parser/pdb/pdb.hpp"
#include "util/logger.hpp"

namespace func_parser {
    template <pe::any_image_t Img>
    void Instance<Img>::collect_functions() {
        // Parsing from all sources possible
        //
        parse();

        // Combining and sanitizing results
        //
        function_list_ = combiner::combine_function_lists(function_lists_);
        progress_->step();

        function_list_ = sanitizer::sanitize_function_list(function_list_, image_);
        progress_->step();

        // If 0 functions found
        //
        if (function_list_.empty()) {
            throw std::runtime_error("parser: Parsed 0 functions in total");
        }

        logger::debug("func_parser: discovered {} functions", function_list_.size());
    }

    template <pe::any_image_t Img>
    void Instance<Img>::parse() {
        parse_pdb();
        progress_->step();

        parse_map();
        progress_->step();
    }

    template <pe::any_image_t Img>
    void Instance<Img>::parse_pdb() {
        // If force disabled
        //
        if (!config_.pdb_enabled) {
            return;
        }

        // Obtaining base of code
        //
        const auto base_of_code = image_->raw_image->get_nt_headers()->optional_header.base_of_code;

        // Trying to parse from a custom pdb path first
        //
        if (config_.pdb_path.has_value()) {
            if (push(pdb::discover_functions(config_.pdb_path.value(), base_of_code))) {
                return;
            }
        }

        // Trying to parse from a codeview path
        //
        if (push(pdb::discover_functions(image_->find_codeview70(), base_of_code))) {
            return;
        }

        // Trying to find .pdb near the executable
        //
        auto pdb_path = obfuscator_config_.binary_path;
        pdb_path = pdb_path.replace_extension(".pdb");
        push(pdb::discover_functions(pdb_path, base_of_code));
    }

    template <pe::any_image_t Img>
    void Instance<Img>::parse_map() {
        // If force disabled
        //
        if (!config_.map_enabled) {
            return;
        }

        // Trying to parse from a custom path first
        //
        if (config_.map_path.has_value()) {
            if (push(map::discover_functions(config_.map_path.value(), image_->sections))) {
                return;
            }
        }

        // Trying to find .map file near the binary
        //
        auto map_path = obfuscator_config_.binary_path;
        map_path = map_path.replace_extension(".map");
        push(map::discover_functions(map_path, image_->sections));
    }

    PE_DECL_TEMPLATE_CLASSES(Instance);
} // namespace func_parser
```

`src/lib/func_parser/parser.hpp`:

```hpp
#pragma once
#include "config_parser/config_parser.hpp"
#include "func_parser/common/common.hpp"
#include "func_parser/common/sanitizer.hpp"
#include "util/progress.hpp"

namespace func_parser {
    template <pe::any_image_t Img>
    class Instance {
    public:
        DEFAULT_CTOR_DTOR(Instance);
        DEFAULT_COPY(Instance);

        void setup(Img* image, const config_parser::func_parser_config_t& config, const config_parser::obfuscator_config_t& obfuscator_config) {
            image_ = image;
            config_ = config;
            obfuscator_config_ = obfuscator_config;
            progress_.emplace("func_parser: discovering functions", 4);
        }

        void collect_functions();

        std::optional<function_t> find_if(const std::function<bool(const function_t&)>& predicator) {
            const auto iter = std::ranges::find_if(function_list_, predicator);
            if (iter == function_list_.end()) {
                return std::nullopt;
            }

            return std::make_optional<function_t>(*iter);
        }

    private:
        void parse();
        void parse_pdb();
        void parse_map();

        bool push(function_list_t items) {
            if (items.empty()) {
                return false;
            }

            function_lists_.emplace_back(sanitizer::sanitize_function_list(std::move(items), image_));
            return true;
        }

        Img* image_ = nullptr;
        std::vector<function_list_t> function_lists_ = {};
        function_list_t function_list_ = {}; // function_lists_ combined and sanitized basically
        config_parser::func_parser_config_t config_ = {};
        config_parser::obfuscator_config_t obfuscator_config_ = {};
        std::optional<util::Progress> progress_ = std::nullopt;
    };
} // namespace func_parser
```

`src/lib/func_parser/pdb/detail/parser_v7.hpp`:

```hpp
#pragma once
#include <cstddef>
#include <cstdint>
#include <functional>
#include <optional>
#include <vector>

#include "func_parser/pdb/detail/structs.hpp"
#include "util/memory/address.hpp"
#include "util/types.hpp"

// \todo: @es3n1n: we should probably use OMAP from the pdb for rva conversion

namespace func_parser::pdb::detail {
    class V7Parser {
    public:
        V7Parser(const std::uint8_t* pdb_data, const size_t pdb_size): pdb_data_(pdb_data), pdb_size_(pdb_size) {
            read_header();
        }

        DEFAULT_DTOR(V7Parser);
        DEFAULT_COPY(V7Parser);

        void iter_symbols(const std::function<bool(std::uint16_t, memory::address)>& callback) const;

        template <typename Ty = DBIRecordHeader>
        void iter_symbols(const std::uint16_t kind, std::function<void(Ty*)> callback) const {
            iter_symbols([=](const std::uint16_t it_kind, const memory::address raw) -> bool {
                if (it_kind != kind) {
                    return true;
                }

                callback(raw.as<Ty*>());
                return true;
            });
        }

        template <typename Ty = DBIRecordHeader, typename... Args>
        void iter_symbols(std::function<void(Ty*)> callback, Args... args) const {
            for (auto kind : types::to_array(std::forward<Args>(args)...)) {
                iter_symbols(kind, callback);
            }
        }

    protected:
        void read_header();
        void read_streams();
        void read_dbi();

    public:
        [[nodiscard]] std::optional<std::uint64_t> get_section(const std::size_t num) const noexcept {
            if (sections_.size() <= num) {
                return std::nullopt;
            }

            return sections_.at(num);
        }

    private:
        memory::address pdb_data_ = memory::address(nullptr);
        [[maybe_unused]] size_t pdb_size_ = 0;

        SuperBlock* header_ = nullptr;

        // contains virtual addresses, cba storing anything else
        std::vector<std::uint64_t> sections_ = {};

        // these streams should be in the right order
        std::vector<std::vector<std::uint8_t>> streams_ = {};

        // key is sym kind, values are ptrs to the symbols
        std::unordered_map<std::uint16_t, std::vector<memory::address>> dbi_symbols_ = {};
    };
} // namespace func_parser::pdb::detail

```

`src/lib/func_parser/pdb/detail/reader_v7.cpp`:

```cpp
#include "func_parser/pdb/detail/parser_v7.hpp"
#include "util/logger.hpp"
#include "util/memory/address.hpp"

// \note: @es3n1n: s/o to @namazso for the stream related functions
namespace func_parser::pdb::detail {
    namespace {
        std::vector<std::uint8_t> get_stream_directory(const SuperBlock* header, const memory::address& raw) noexcept {
            const auto size = header->NumDirectoryBytes;
            const auto block_size = static_cast<std::ptrdiff_t>(header->BlockSize);
            const auto block_count = (size + block_size - 1) / block_size;

            if (size == 0 || block_count == 0 || block_size == 0) {
                logger::error("Empty stream directory, msg[0] size[{}] block_count[{}] block_size[{}]", size, block_count, block_size);
                return {};
            }

            std::vector<std::uint8_t> stream_dir;
            stream_dir.reserve(block_count * block_size);

            const auto* block_id_array = raw.offset(block_size * header->BlockMapAddr).cast<uint32_t*>();

            for (uint32_t i = 0; i < block_count; ++i) {
                const auto block = raw.offset(block_size * block_id_array[i]);
                stream_dir.insert(stream_dir.end(), block.cast<uint8_t*>(), //
                                  block.offset(block_size).cast<uint8_t*>());
            }

            if (stream_dir.empty()) {
                logger::error("Empty stream directory, msg[1] size[{}] block_count[{}] block_size[{}]", size, block_count, block_size);
                return {};
            }

            stream_dir.resize(size);
            return stream_dir;
        }
    } // namespace

    void V7Parser::read_header() {
        header_ = pdb_data_.cast<SuperBlock*>();

        if (std::memcmp(header_, kMicrosoftPdb7Magic.data(), kMicrosoftPdb7Magic.size()) != 0) {
            throw std::runtime_error("pdb: Invalid pdb7 header");
        }

        read_streams();
        read_dbi();
    }

    void V7Parser::read_streams() {
        const auto stream_directory = get_stream_directory(header_, pdb_data_);
        if (stream_directory.empty()) {
            throw std::runtime_error("pdb: Got empty stream directory");
        }

        const auto block_size = header_->BlockSize;

        const std::size_t streams_count = memory::address{stream_directory.data()}.get<std::uint32_t>().value();

        const auto* streams = memory::address{stream_directory.data()}.offset(sizeof(std::uint32_t)).cast<std::uint32_t*>();
        const auto* ids = memory::address{streams}.offset(static_cast<std::ptrdiff_t>(streams_count) * sizeof(std::uint32_t)).cast<std::uint32_t*>();

        streams_.clear();
        streams_.reserve(streams_count);

        for (std::size_t i = 0; i < streams_count; ++i) {
            const auto stream_size = streams[i];
            const auto stream_blocks = (stream_size + block_size - 1) / block_size;

            std::vector<std::uint8_t> stream = {};
            stream.reserve(static_cast<std::size_t>(stream_blocks) * block_size);

            if (stream_blocks == 0) {
                // Handling empty streams
                // \note: @es3n1n: not sure how we should handle streams with size -1,
                // maybe somehow different, but if it works - it works.
                //
                if (static_cast<int32_t>(stream_size) <= 0) {
                    streams_.emplace_back();
                    continue;
                }

                // Resizing stream then
                //
                stream.resize(stream_size);
                streams_.emplace_back(std::move(stream));
                continue;
            }

            for (std::size_t j = 0; j < stream_blocks; ++j) {
                const auto block_id = *ids++;
                const auto block_start = pdb_data_.offset(static_cast<std::ptrdiff_t>(block_size) * block_id);

                stream.insert(stream.end(), block_start.cast<std::uint8_t*>(), block_start.offset(block_size).cast<std::uint8_t*>());
            }

            stream.resize(stream_size);
            streams_.emplace_back(std::move(stream));
        }
    }

    void V7Parser::read_dbi() {
        if (streams_.size() <= DBI_HEADER) [[unlikely]] {
            logger::error("pdb: DBI header not found, huh? streams_size[{}]", streams_.size());
            return;
        }

        const auto dbi_header_raw = streams_.at(DBI_HEADER);
        const auto* dbi_header = memory::address{dbi_header_raw}.cast<DBIHeader*>();
        if (dbi_header_raw.empty() || //
            dbi_header == nullptr) [[unlikely]] {
            logger::error("pdb: got empty DBI header, huh?");
            return;
        }

        const auto parse_symbol_records = [this, dbi_header]() -> void {
            if (streams_.size() <= dbi_header->SymRecordStream) [[unlikely]] {
                logger::warn("pdb: DBI sym record stream not found");
                return;
            }

            auto& sym_stream_raw = streams_.at(dbi_header->SymRecordStream);
            auto* sym_stream = sym_stream_raw.data();
            const auto* sym_stream_end = sym_stream + sym_stream_raw.size();

            for (; sym_stream != sym_stream_end; sym_stream += (memory::cast<DBIRecordHeader*>(sym_stream)->Size + 2)) {
                dbi_symbols_[memory::cast<DBIRecordHeader*>(sym_stream)->Kind].emplace_back(sym_stream);
            }
        };

        const auto parse_module_infos = [this, dbi_header]() -> void {
            if (dbi_header->ModInfoSize <= 0) [[unlikely]] {
                logger::warn("pdb: got empty DBI mod info stream");
                return;
            }

            auto iter = memory::address{dbi_header}.offset(sizeof(DBIHeader));
            const auto end = iter.offset(dbi_header->ModInfoSize);

            for (; iter < end; iter = iter.align_up(kDBIAlignment)) {
                const auto* module_info = iter.cast<DBIModuleInfo*>();
                iter = iter.offset(sizeof(*module_info)); // skip header

                const auto* module_name = iter.cast<char*>();
                iter = iter.offset(static_cast<std::ptrdiff_t>(std::strlen(module_name)) + 1); // skip module name + '\0'

                const auto* object_name = iter.cast<char*>();
                iter = iter.offset(static_cast<std::ptrdiff_t>(std::strlen(object_name)) + 1); // skip object name + '\0'

                // \note: @es3n1n: we don't need it to parse modules that have no info
                if (module_info->ModuleSymStream <= 0 || module_info->SymByteSize <= 0 || //
                    streams_.size() <= module_info->ModuleSymStream) [[unlikely]] {
                    continue;
                }

                const auto& raw_module_symbol_stream = streams_.at(module_info->ModuleSymStream);

                // \note: @es3n1n: +sizeof(uint32_t) because we are skipping unknown signature,
                // we only need symbols :shrug:
                auto sym_stream = memory::address{raw_module_symbol_stream.data()}.offset(sizeof(uint32_t));
                const auto sym_stream_end = sym_stream.offset(module_info->SymByteSize);

                for (; sym_stream < sym_stream_end; sym_stream = sym_stream.align_up(kDBIAlignment)) {
                    const auto* record = sym_stream.as<DBIRecordHeader*>();

                    // \note: @es3n1n: break on stream end
                    // \note: @es3n1n: for some reason stream doesn't end on the end marker?
                    // if (record->Kind == detail::e_symbol_kind::S_END) {
                    //    break;
                    //}

                    dbi_symbols_[record->Kind].emplace_back(record);

                    // +sizeof(uint16_t) and not sizeof(header) cos they are accounting the Size field from header and not Kind field
                    sym_stream = sym_stream.offset(static_cast<std::ptrdiff_t>(sizeof(uint16_t)) + record->Size);
                }
            }
        };

        const auto parse_image_section_stream = [this, dbi_header]() -> void {
            if (dbi_header->OptionalDbgHeaderSize <= 0) [[unlikely]] {
                logger::warn("pdb: got empty optional DBG header");
                return;
            }

            // \fixme: @es3n1n: is there a better way? i dont think so.
            const auto* optional_debug_header = memory::address{dbi_header} //
                                                    .offset(sizeof(DBIHeader)) //
                                                    .offset(dbi_header->ModInfoSize) //
                                                    .offset(dbi_header->SectionContributionSize) //
                                                    .offset(dbi_header->SectionMapSize) //
                                                    .offset(dbi_header->SourceInfoSize) //
                                                    .offset(dbi_header->TypeServerSize) //
                                                    .offset(dbi_header->ECSubStreamSize) //
                                                    .as<DBIOptionalDebugHeader*>();

            if (optional_debug_header->SectionHeaderStreamIndex <= 0 || //
                streams_.size() <= optional_debug_header->SectionHeaderStreamIndex) {
                logger::warn("pdb: got invalid optional DBG header");
                return;
            }

            auto& raw_image_section_stream = streams_.at(optional_debug_header->SectionHeaderStreamIndex);
            auto* image_section_stream = memory::cast<IMAGE_SECTION_HEADER*>(raw_image_section_stream.data());

            for (std::size_t i = 0; i < (raw_image_section_stream.size() / sizeof(IMAGE_SECTION_HEADER)); ++i) {
                auto* image_section = &image_section_stream[i];

                sections_.emplace_back(image_section->VirtualAddress);
            }
        };

        parse_symbol_records();
        parse_module_infos();
        parse_image_section_stream();

        logger::debug("pdb: Parsed {} types of DBI symbols", dbi_symbols_.size());
    }

    void V7Parser::iter_symbols(const std::function<bool(std::uint16_t, memory::address)>& callback) const {
        for (const auto& [kind, pointers] : dbi_symbols_) {
            for (const auto& pointer : pointers) {
                if (callback(kind, pointer)) {
                    continue;
                }

                return;
            }
        }
    }
} // namespace func_parser::pdb::detail
```

`src/lib/func_parser/pdb/detail/structs.hpp`:

```hpp
#pragma once
#include <array>
#include <cstdint>

// @credits: llvm <3
namespace func_parser::pdb::detail {
    // Microsoft C/C++ MSF 7.00 ...
    //
    constexpr std::array<std::uint8_t, 32> kMicrosoftPdb7Magic = {0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66, 0x74, 0x20, 0x43,
                                                                  0x2F, 0x43, 0x2B, 0x2B, 0x20, 0x4D, 0x53, 0x46, 0x20, 0x37, 0x2E,
                                                                  0x30, 0x30, 0x0D, 0x0A, 0x1A, 0x44, 0x53, 0x00, 0x00, 0x00};

    constexpr std::size_t kDBIAlignment = sizeof(uint32_t);

    enum e_stream_index : std::uint8_t {
        DBI_HEADER = 3,
    };

    enum e_symbol_kind : std::uint16_t {
        S_LPROC32 = 0x110FU, // local fn
        S_GPROC32 = 0x1110U, // global fn
        S_END = 0x6, // end of mod symbols
    };

#pragma pack(push, 1)
    struct SuperBlock {
        std::array<char, kMicrosoftPdb7Magic.size()> FileMagic;
        uint32_t BlockSize;
        uint32_t FreeBlockMapBlock;
        uint32_t NumBlocks;
        uint32_t NumDirectoryBytes;
        uint32_t Unknown;
        uint32_t BlockMapAddr;
    };

    struct DBIHeader {
        int32_t VersionSignature;
        uint32_t VersionHeader;
        uint32_t Age;
        uint16_t GlobalStreamIndex;
        uint16_t BuildNumber;
        uint16_t PublicStreamIndex;
        uint16_t PdbDllVersion;
        uint16_t SymRecordStream;
        uint16_t PdbDllRebuild;
        int32_t ModInfoSize;
        int32_t SectionContributionSize;
        int32_t SectionMapSize;
        int32_t SourceInfoSize;
        int32_t TypeServerSize;
        uint32_t MFCTypeServerIndex;
        int32_t OptionalDbgHeaderSize;
        int32_t ECSubStreamSize;
        uint16_t Flags;
        uint16_t Machine;
        uint32_t Padding;
    };

    struct DBIModuleInfo {
        uint32_t Unused1;
        struct SectionContribEntry {
            uint16_t Section;
            // NOLINTNEXTLINE
            char Padding1[2];
            int32_t Offset;
            int32_t Size;
            uint32_t Characteristics;
            uint16_t ModuleIndex;
            // NOLINTNEXTLINE
            char Padding2[2];
            uint32_t DataCrc;
            uint32_t RelocCrc;
        } SectionContr;
        uint16_t Flags;
        uint16_t ModuleSymStream;
        uint32_t SymByteSize;
        uint32_t C11ByteSize;
        uint32_t C13ByteSize;
        uint16_t SourceFileCount;
        // NOLINTNEXTLINE
        char Padding[2];
        uint32_t Unused2;
        uint32_t SourceFileNameIndex;
        uint32_t PdbFilePathNameIndex;

        // char ModuleName[];
        // char ObjFileName[];
    };

    struct DBIOptionalDebugHeader { // tyty rawpdb
        uint16_t FpoDataStreamIndex; // IMAGE_DEBUG_TYPE_FPO
        uint16_t ExceptionDataStreamIndex; // IMAGE_DEBUG_TYPE_EXCEPTION
        uint16_t FixupDataStreamIndex; // IMAGE_DEBUG_TYPE_FIXUP
        uint16_t OmapToSrcDataStreamIndex; // IMAGE_DEBUG_TYPE_OMAP_TO_SRC
        uint16_t OmapFromSrcDataStreamIndex; // IMAGE_DEBUG_TYPE_OMAP_FROM_SRC
        uint16_t SectionHeaderStreamIndex; // a dump of all section headers (IMAGE_SECTION_HEADER) from the original executable
        uint16_t TokenDataStreamIndex;
        uint16_t XDataStreamIndex;
        uint16_t PDataStreamIndex;
        uint16_t NewFpoDataStreamIndex;
        uint16_t OriginalSectionHeaderDataStreamIndex;
    };

    struct IMAGE_SECTION_HEADER {
        // NOLINTNEXTLINE
        uint8_t Name[8];
        union {
            uint32_t PhysicalAddress;
            uint32_t VirtualSize;
        } Misc;
        uint32_t VirtualAddress;
        uint32_t SizeOfRawData;
        uint32_t PointerToRawData;
        uint32_t PointerToRelocations;
        uint32_t PointerToLineNumbers;
        uint16_t NumberOfRelocations;
        uint16_t NumberOfLineNumbers;
        uint32_t Characteristics;
    };

    struct DBIRecordHeader {
        uint16_t Size;
        uint16_t Kind;
    };

    struct DBIRecordPUB32 {
        DBIRecordHeader Header;
        uint16_t PubSymFlags;
        uint32_t Offset;
        uint16_t Segment;
    };

    struct DBIRecordProc32 {
        DBIRecordHeader Header;
        uint32_t Parent;
        uint32_t End;
        uint32_t Next;
        uint32_t Size;
        uint32_t DebugStart;
        uint32_t DebugEnd;
        uint32_t TypeIndex;
        uint32_t Offset;
        uint16_t Segment;
        uint8_t Flags;
        // NOLINTNEXTLINE
        char Name[1];
    };

    struct DBIRecordLProc32 : DBIRecordProc32 { };
    struct DBIRecordGProc32 : DBIRecordProc32 { };
#pragma pack(pop)
} // namespace func_parser::pdb::detail

```

`src/lib/func_parser/pdb/pdb.cpp`:

```cpp
#include "func_parser/pdb/pdb.hpp"
#include "func_parser/pdb/detail/parser_v7.hpp"
#include "util/logger.hpp"

namespace func_parser::pdb {
    function_list_t discover_functions(const std::filesystem::path& pdb_path, const std::uint64_t) {
        // Return an empty set if file doesn't exist
        //
        if (!exists(pdb_path)) {
            return {};
        }

        // Reading file
        //
        const auto pdb_content = util::read_file(pdb_path);
        if (pdb_content.empty()) [[unlikely]] {
            return {};
        }

        // If magic doesn't equal to pdb7 magic then sorry we cannot parse this pdb
        // \todo: @es3n1n: add pdb2 support
        //
        if (std::memcmp(pdb_content.data(), detail::kMicrosoftPdb7Magic.data(), detail::kMicrosoftPdb7Magic.size()) != 0) {
            FIXME_NO_ARG(1, "Only PDB7 is supported atm");
            return {};
        }

        // We gamin
        //
        function_list_t result = {};

        const detail::V7Parser parser(pdb_content.data(), pdb_content.size());
        parser.iter_symbols<detail::DBIRecordProc32>(
            [&result, parser](detail::DBIRecordProc32* sym) -> void {
                auto& item = result.emplace_back();
                item.valid = true; // probably we should check for something first

                item.name = sym->Name;
                item.size = std::make_optional<std::size_t>(sym->Size);

                const auto segment = parser.get_section(sym->Segment - 1);
                if (!segment.has_value()) {
                    item.valid = false;
                    logger::warn("pdb: Unable to obtain segment base num[{}] func[{}]", sym->Segment, sym->Name);
                    return;
                }

                item.rva = segment.value() + sym->Offset;
            },
            detail::e_symbol_kind::S_LPROC32, // Iterating over local procedures
            detail::e_symbol_kind::S_GPROC32 // Iterating over global procedures
        );

        // We are done here
        //
        return result;
    }
} // namespace func_parser::pdb

```

`src/lib/func_parser/pdb/pdb.hpp`:

```hpp
#pragma once
#include "func_parser/common/common.hpp"
#include "pe/pe.hpp"
#include "util/files.hpp"

// \todo: @es3n1n: validate that the pdb could be used for provided file
// \todo: @es3n1n: add custom pdb server support?

namespace func_parser::pdb {
    function_list_t discover_functions(const std::filesystem::path& pdb_path, std::uint64_t base_of_code = 0ULL);

    inline function_list_t discover_functions(const win::cv_pdb70_t* code_view, const std::uint64_t base_of_code = 0ULL) {
        // Return an empty set if there's no code view
        //
        if (code_view == nullptr) {
            return {};
        }

        return discover_functions(code_view->pdb_name, base_of_code);
    }
} // namespace func_parser::pdb

```

`src/lib/mathop/mathop.hpp`:

```hpp
#pragma once
#include "mathop/operations/operations.hpp"
#include "util/random.hpp"
#include "util/types.hpp"

#include <vector>

namespace mathop {
    /// \brief Operation and the second operand for it (if needed)
    class OperationValue {
    public:
        DEFAULT_DTOR(OperationValue);
        DEFAULT_COPY(OperationValue);
        explicit OperationValue(Operation* operation, const zasm::BitSize bit_size): operation_(operation), size_(bit_size) {
            /// We need to generate second operands only for the operations that needs them
            if (!operation_->has_second_operand()) {
                return;
            }

            /// Generate the expression and set it to both lift/emulation arguments
            emulation_rhs_ = operation_->generate_rhs(imm_for_bits(bit_size));
            lift_rhs_ = convert(emulation_rhs_.value());
        }

        /// \brief Emulate the operation
        /// \param lhs Lhs imm value
        /// \return Calculated value
        [[nodiscard]] ArgumentImm emulate(const ArgumentImm lhs) const {
            return operation_->emulate(lhs, emulation_rhs_);
        }

        /// \brief Lift revert operation to x86 code
        /// \param assembler zasm assembler
        /// \param dst_reg destination register
        void lift_revert(zasm::x86::Assembler* assembler, const zasm::x86::Gp dst_reg) const {
            return operation_->lift_revert(assembler, dst_reg, lift_rhs_);
        }

        /// \brief Get the emulation argument
        /// \return optional imm
        [[nodiscard]] std::optional<ArgumentImm> emulation_rhs() const {
            return emulation_rhs_;
        }

        /// \brief Set the emulation argument
        /// \param value New optional imm value
        void emulation_rhs(const std::optional<ArgumentImm>& value) {
            emulation_rhs_ = value;
        }

        /// \brief Get the lift argument
        /// \return optional argument (imm/reg)
        [[nodiscard]] std::optional<Argument> lift_rhs() const {
            return lift_rhs_;
        }

        /// \brief Set the lift argument
        /// \param value New optional argument value (imm/reg)
        void lift_rhs(const std::optional<Argument>& value) {
            lift_rhs_ = value;
        }

        /// \brief Returns true if this operation has a second operand
        /// \return bool
        [[nodiscard]] bool has_rhs() const {
            return emulation_rhs_.has_value() || lift_rhs_.has_value();
        }

        /// \brief Get the operands size
        /// \return operands size in bits
        [[nodiscard]] zasm::BitSize bit_size() const {
            return size_;
        }

    private:
        /// \brief Operation ptr
        Operation* operation_ = nullptr;
        /// \brief Arguments size
        zasm::BitSize size_ = {};
        /// \brief Emulation rhs (imm only)
        std::optional<ArgumentImm> emulation_rhs_ = std::nullopt;
        /// \brief Lift rhs (imm/register)
        std::optional<Argument> lift_rhs_ = std::nullopt;
    };

    /// \brief Expression with operations
    class Expression {
    public:
        DEFAULT_CTOR_DTOR(Expression);
        DEFAULT_COPY(Expression);

        /// \brief Emplace new operation
        /// \param operation mathop::Operation ptr
        /// \param bit_size operands bit size
        /// \return emplaced operation
        OperationValue& emplace_operation(Operation* operation, const zasm::BitSize bit_size) {
            return operations_.emplace_back(operation, bit_size);
        }

        /// \brief Emulate the whole expression
        /// \param start_value expression input
        /// \return calculated value
        [[nodiscard]] ArgumentImm emulate(const ArgumentImm start_value) const {
            ArgumentImm result = start_value;

            for (auto& operation : operations_) {
                result = operation.emulate(result);
            }

            return result;
        }

        /// \brief Lift reversion of this expression to x86 code
        /// \param assembler zasm assembler
        /// \param dst dst register
        void lift_revert(zasm::x86::Assembler* assembler, const zasm::x86::Gp dst) {
            /// Iterating over the reverted operations list
            for (auto it = operations_.rbegin(); it != operations_.rend(); std::advance(it, 1)) {
                it->lift_revert(assembler, dst);
            }
        }

        /// \brief Iterator begin
        /// \return operations begin
        [[nodiscard]] auto begin() {
            return operations_.begin();
        }

        /// \brief Iterator const begin
        /// \return operations const begin
        [[nodiscard]] auto begin() const {
            return operations_.begin();
        }

        /// \brief Iterator end
        /// \return operations end
        [[nodiscard]] auto end() {
            return operations_.end();
        }

        /// \brief Iterator const end
        /// \return operations const end
        [[nodiscard]] auto end() const {
            return operations_.end();
        }

    private:
        /// \brief A list of operations
        std::vector<OperationValue> operations_ = {};
    };

    /// \brief Expression generator
    class ExpressionGenerator : public types::Singleton<ExpressionGenerator> {
    public:
        DEFAULT_DTOR(ExpressionGenerator);
        NON_COPYABLE(ExpressionGenerator);

        /// \brief Operations initializer
        ExpressionGenerator() {
            operations_.emplace_back(std::make_unique<operations::Add>());
            operations_.emplace_back(std::make_unique<operations::Sub>());
            operations_.emplace_back(std::make_unique<operations::Inc>());
            operations_.emplace_back(std::make_unique<operations::Dec>());
            operations_.emplace_back(std::make_unique<operations::Xor>());
            operations_.emplace_back(std::make_unique<operations::Neg>());
            operations_.emplace_back(std::make_unique<operations::Not>());
        }

        /// \brief Generate a random math expression
        /// \param bit_size Operands bit size
        /// \param num_operations Number of operations
        /// \return Expression
        [[nodiscard]] Expression generate(const zasm::BitSize bit_size, const std::size_t num_operations) {
            Expression result;

            /// Generate the random expressions
            for (std::size_t i = 0; i < num_operations; ++i) {
                auto& operation = rnd::item(operations_);
                result.emplace_operation(operation.get(), bit_size);
            }

            return result;
        }

    private:
        /// \brief List of supported operations
        std::vector<std::unique_ptr<Operation>> operations_ = {};
    };
} // namespace mathop

```

`src/lib/mathop/operations/impl/add.cpp`:

```cpp
#include "mathop/operations/impl/util.hpp"

namespace mathop::operations {
    /// \brief Emulate the math operation under the two operands
    /// \param op1 lhs
    /// \param op2 rhs
    /// \return emulated result
    ArgumentImm Add::emulate(ArgumentImm op1, std::optional<ArgumentImm> op2) const {
        ArgumentImm result;
        std::visit(
            [&]<typename Ty>(Ty&& op1_value) -> void { //
                using Decay = std::decay_t<Ty>;
                result.emplace<Decay>(op1_value + std::get<Decay>(*op2));
            },
            op1);
        return result;
    }

    /// \brief Lift the revert operation for this math operation
    /// \param assembler zasm assembler
    /// \param operand dst operand
    /// \param argument optional rhs
    void Add::lift_revert(zasm::x86::Assembler* assembler, zasm::x86::Gp operand, const std::optional<Argument> argument) const {
        lift(
            argument, detail::none,
            [assembler, operand](const zasm::x86::Gp reg) -> void { //
                assembler->sub(operand, reg);
            },
            [assembler, operand](const zasm::Imm imm) -> void { //
                assembler->sub(operand, imm);
            });
    }

    /// \brief Generate a random second operand
    /// \param lhs Operand 1
    /// \return Generated operand
    ArgumentImm Add::generate_rhs(const ArgumentImm lhs) const {
        return detail::generate_random_argument_in_range(lhs);
    }
} // namespace mathop::operations
```

`src/lib/mathop/operations/impl/dec.cpp`:

```cpp
#include "mathop/operations/impl/util.hpp"
#include "util/random.hpp"

namespace mathop::operations {
    /// \brief Emulate the math operation under the two operands
    /// \param op1 lhs
    /// \param op2 rhs
    /// \return emulated result
    ArgumentImm Dec::emulate(ArgumentImm op1, std::optional<ArgumentImm> op2) const {
        ArgumentImm result;
        std::visit(
            [&]<typename Ty>(Ty&& op1_value) -> void { //
                result.emplace<std::decay_t<Ty>>(op1_value - 1);
            },
            op1);
        return result;
    }

    /// \brief Lift the revert operation for this math operation
    /// \param assembler zasm assembler
    /// \param operand dst operand
    /// \param argument optional rhs
    void Dec::lift_revert(zasm::x86::Assembler* assembler, const zasm::x86::Gp operand, std::optional<Argument> argument) const {
        assembler->inc(operand);
    }
} // namespace mathop::operations
```

`src/lib/mathop/operations/impl/inc.cpp`:

```cpp
#include "mathop/operations/impl/util.hpp"
#include "util/random.hpp"

namespace mathop::operations {
    /// \brief Emulate the math operation under the two operands
    /// \param op1 lhs
    /// \return emulated result
    ArgumentImm Inc::emulate(ArgumentImm op1, std::optional<ArgumentImm>) const {
        ArgumentImm result;
        std::visit(
            [&]<typename Ty>(Ty&& op1_value) -> void { //
                result.emplace<std::decay_t<Ty>>(op1_value + 1);
            },
            op1);
        return result;
    }

    /// \brief Lift the revert operation for this math operation
    /// \param assembler zasm assembler
    /// \param operand dst operand
    void Inc::lift_revert(zasm::x86::Assembler* assembler, const zasm::x86::Gp operand, std::optional<Argument>) const {
        assembler->dec(operand);
    }
} // namespace mathop::operations
```

`src/lib/mathop/operations/impl/neg.cpp`:

```cpp
#include "mathop/operations/impl/util.hpp"
#include "util/random.hpp"

namespace mathop::operations {
    /// \brief Emulate the math operation under the two operands
    /// \param op1 lhs
    /// \return emulated result
    ArgumentImm Neg::emulate(ArgumentImm op1, std::optional<ArgumentImm>) const {
        ArgumentImm result;
        std::visit(
            [&]<typename Ty>(Ty&& op1_value) -> void { //
                result.emplace<std::decay_t<Ty>>(-op1_value);
            },
            op1);
        return result;
    }

    /// \brief Lift the revert operation for this math operation
    /// \param assembler zasm assembler
    /// \param operand dst operand
    void Neg::lift_revert(zasm::x86::Assembler* assembler, const zasm::x86::Gp operand, std::optional<Argument>) const {
        assembler->neg(operand);
    }
} // namespace mathop::operations
```

`src/lib/mathop/operations/impl/not.cpp`:

```cpp
#include "mathop/operations/impl/util.hpp"
#include "util/random.hpp"

namespace mathop::operations {
    /// \brief Emulate the math operation under the two operands
    /// \param op1 lhs
    /// \return emulated result
    ArgumentImm Not::emulate(ArgumentImm op1, std::optional<ArgumentImm>) const {
        ArgumentImm result;
        std::visit(
            [&]<typename Ty>(Ty&& op1_value) -> void { //
                result.emplace<std::decay_t<Ty>>(~op1_value);
            },
            op1);
        return result;
    }

    /// \brief Lift the revert operation for this math operation
    /// \param assembler zasm assembler
    /// \param operand dst operand
    void Not::lift_revert(zasm::x86::Assembler* assembler, const zasm::x86::Gp operand, std::optional<Argument>) const {
        assembler->not_(operand);
    }
} // namespace mathop::operations
```

`src/lib/mathop/operations/impl/sub.cpp`:

```cpp
#include "mathop/operations/impl/util.hpp"
#include "util/random.hpp"

namespace mathop::operations {
    /// \brief Emulate the math operation under the two operands
    /// \param op1 lhs
    /// \param op2 rhs
    /// \return emulated result
    ArgumentImm Sub::emulate(ArgumentImm op1, std::optional<ArgumentImm> op2) const {
        ArgumentImm result;
        std::visit(
            [&]<typename Ty>(Ty&& op1_value) -> void { //
                result.emplace<std::decay_t<Ty>>(op1_value - std::get<std::decay_t<Ty>>(*op2));
            },
            op1);
        return result;
    }

    /// \brief Lift the revert operation for this math operation
    /// \param assembler zasm assembler
    /// \param operand dst operand
    /// \param argument optional rhs
    void Sub::lift_revert(zasm::x86::Assembler* assembler, zasm::x86::Gp operand, const std::optional<Argument> argument) const {
        lift(
            argument, detail::none,
            [assembler, operand](const zasm::x86::Gp reg) -> void { //
                assembler->add(operand, reg);
            },
            [assembler, operand](const zasm::Imm imm) -> void { //
                assembler->add(operand, imm);
            });
    }

    /// \brief Generate a random second operand
    /// \param lhs Operand 1
    /// \return Generated operand
    ArgumentImm Sub::generate_rhs(const ArgumentImm lhs) const {
        return detail::generate_random_argument_in_range(lhs);
    }
} // namespace mathop::operations
```

`src/lib/mathop/operations/impl/util.hpp`:

```hpp
#pragma once
#include "mathop/operations/operations.hpp"
#include "util/random.hpp"

#include <functional>

namespace mathop::detail {
    /// \brief Visitor helper
    /// \tparam Ts Visitors
    template <class... Ts>
    struct overloaded : Ts... {
        using Ts::operator()...;
    };

    /// \brief An util to simplify the Argument visiting process
    /// \param argument Optional argument that gets passed to the lift function
    /// \param lift_no_arg Executed if argument is not set
    /// \param lift_reg Executed if argument is a register
    /// \param lift_imm Executed if argument is an immediate constant
    inline void lift(const std::optional<Argument>& argument, const std::function<void()>& lift_no_arg, const std::function<void(zasm::x86::Gp)>& lift_reg,
                     const std::function<void(zasm::Imm)>& lift_imm) {
        /// If arg is unset
        if (!argument.has_value()) {
            lift_no_arg();
            return;
        }

        /// Visiting the argument then
        std::visit(overloaded{
                       [&](const zasm::Reg reg) -> void { lift_reg(zasm::x86::Gp(reg.getId())); },
                       [&](const std::int64_t imm) -> void { lift_imm(zasm::Imm(imm)); },
                       [&](const std::int32_t imm) -> void { lift_imm(zasm::Imm(imm)); },
                       [&](const std::int16_t imm) -> void { lift_imm(zasm::Imm(imm)); },
                       [&](const std::int8_t imm) -> void { lift_imm(zasm::Imm(imm)); },
                   },
                   *argument);
    }

    /// \brief Generate a random imm in range of the lhs type
    /// \param lhs Lhs
    /// \return Generated operand
    [[nodiscard]] inline ArgumentImm generate_random_argument_in_range(ArgumentImm lhs) {
        ArgumentImm result;

        /// Probably there's a smarter way how to avoid encoding errors
        std::visit(overloaded{
                       [&](const std::int64_t) -> void { result.emplace<std::int64_t>(rnd::number<std::int32_t>()); },
                       [&](const std::int32_t) -> void { result.emplace<std::int32_t>(rnd::number<std::int16_t>()); },
                       [&](const std::int16_t) -> void { result.emplace<std::int16_t>(rnd::number<std::int8_t>()); },
                       [&](const std::int8_t) -> void { result.emplace<std::int8_t>(rnd::number<std::int8_t>()); },
                   },
                   lhs);
        return result;
    }

    /// \brief Empty callback
    inline auto none = [](auto...) -> void {
    };
} // namespace mathop::detail

```

`src/lib/mathop/operations/impl/xor.cpp`:

```cpp
#include "mathop/operations/impl/util.hpp"
#include "util/random.hpp"

namespace mathop::operations {
    /// \brief Emulate the math operation under the two operands
    /// \param op1 lhs
    /// \param op2 rhs
    /// \return emulated result
    ArgumentImm Xor::emulate(ArgumentImm op1, std::optional<ArgumentImm> op2) const {
        ArgumentImm result;
        std::visit(
            [&]<typename Ty>(Ty&& op1_value) -> void { //
                result.emplace<std::decay_t<Ty>>(op1_value ^ std::get<std::decay_t<Ty>>(*op2));
            },
            op1);
        return result;
    }

    /// \brief Lift the revert operation for this math operation
    /// \param assembler zasm assembler
    /// \param operand dst operand
    /// \param argument optional rhs
    void Xor::lift_revert(zasm::x86::Assembler* assembler, zasm::x86::Gp operand, const std::optional<Argument> argument) const {
        lift(
            argument, detail::none,
            [assembler, operand](const zasm::x86::Gp reg) -> void { //
                assembler->xor_(operand, reg);
            },
            [assembler, operand](const zasm::Imm imm) -> void { //
                assembler->xor_(operand, imm);
            });
    }

    /// \brief Generate a random second operand
    /// \param lhs Operand 1
    /// \return Generated operand
    ArgumentImm Xor::generate_rhs(const ArgumentImm lhs) const {
        return detail::generate_random_argument_in_range(lhs);
    }
} // namespace mathop::operations
```

`src/lib/mathop/operations/operation.hpp`:

```hpp
#pragma once
#include "util/structs.hpp"

#include <cstdint>
#include <optional>
#include <variant>
#include <stdexcept>

#include <zasm/zasm.hpp>

namespace mathop {
    /// Argument variants (probably should be moved to some other file)
    using ArgumentImm = std::variant<std::int64_t, std::int32_t, std::int16_t, std::int8_t>;
    using Argument = std::variant<zasm::Reg, std::int64_t, std::int32_t, std::int16_t, std::int8_t>;

    /// \brief Convert argumentimm to argument
    /// \param argument_imm Argument imm
    /// \return converted argument
    [[nodiscard]] inline Argument convert(const ArgumentImm argument_imm) {
        Argument result;
        std::visit([&]<typename Ty>(Ty&& value) -> void { result.emplace<std::decay_t<Ty>>(std::forward<Ty>(value)); }, argument_imm);
        return result;
    }

    /// \brief Generate an imm argument for the bitsize
    /// \param bit_size bit size
    /// \param value imm value
    /// \return argument imm
    [[nodiscard]] inline ArgumentImm imm_for_bits(const zasm::BitSize bit_size, const std::int64_t value = 0) {
        ArgumentImm result;
        switch (getBitSize(bit_size)) {
        case 8:
            result.emplace<std::int8_t>(static_cast<std::int8_t>(value));
            break;
        case 16:
            result.emplace<std::int16_t>(static_cast<std::int16_t>(value));
            break;
        case 32:
            result.emplace<std::int32_t>(static_cast<std::int32_t>(value));
            break;
        case 64:
            result.emplace<std::int64_t>(static_cast<std::int64_t>(value));
            break;
        default:
            throw std::runtime_error("imm_for_bits: unsupported bitsize");
        }
        return result;
    }

    /// \brief Convert ArgumentImm to zasm Imm
    /// \param value Imm argument value
    /// \return converted zasm::Imm
    [[nodiscard]] inline zasm::Imm imm_to_zasm(const ArgumentImm value) {
        return std::visit([&]<typename Ty>(Ty&& visited_val) -> zasm::Imm { return zasm::Imm(std::forward<Ty>(visited_val)); }, value);
    }

    /// \brief Convert constant to ArgumentImm with saving the type of lhs
    /// \param lhs lhs
    /// \param value value to convert
    /// \return converted ArgumentImm
    [[nodiscard]] inline ArgumentImm const_to_imm_for_rhs(const ArgumentImm lhs, const std::uint64_t value) {
        return std::visit([&]<typename Ty>(Ty&&) -> ArgumentImm { return ArgumentImm(static_cast<Ty>(value)); }, lhs);
    }

    /// \brief Math operation representation
    class Operation {
    public:
        DEFAULT_CTOR(Operation);
        virtual ~Operation() = default;

        /// \brief Indicates whether this operation should have a second argument or not
        [[nodiscard]] virtual bool has_second_operand() const = 0;

        /// \brief Emulate the math operation under the two operands
        /// \param op1 lhs
        /// \param op2 rhs
        /// \return emulated result
        [[nodiscard]] virtual ArgumentImm emulate(ArgumentImm op1, std::optional<ArgumentImm> op2) const = 0;

        /// \brief Lift the revert operation for this math operation
        /// \param assembler zasm assembler
        /// \param operand dst operand
        /// \param argument optional rhs
        virtual void lift_revert(zasm::x86::Assembler* assembler, zasm::x86::Gp operand, std::optional<Argument> argument) const = 0;

        /// \brief Generate a random second operand
        /// \param lhs Operand 1
        /// \return Generated operand
        [[nodiscard]] virtual ArgumentImm generate_rhs(const ArgumentImm lhs) const {
            return const_to_imm_for_rhs(lhs, 0);
        }
    };

    /// \brief Math operation with one operand
    class OperationOneOperand : public Operation {
    public:
        /// \brief Indicates whether this operation should have a second argument or not
        [[nodiscard]] bool has_second_operand() const override {
            return false;
        }
    };

    /// \brief Math operation with two operands
    class OperationTwoOperands : public Operation {
    public:
        /// \brief Indicates whether this operation should have a second argument or not
        [[nodiscard]] bool has_second_operand() const override {
            return true;
        }
    };
} // namespace mathop

```

`src/lib/mathop/operations/operations.hpp`:

```hpp
#pragma once
#include "mathop/operations/operation.hpp"

#define MATHOP_OPERATION_STUB(name, base_name)                                                                                     \
    class name final : public base_name {                                                                                          \
    public:                                                                                                                        \
        ArgumentImm emulate(ArgumentImm op1, std::optional<ArgumentImm> op2) const override;                                       \
        void lift_revert(zasm::x86::Assembler* assembler, zasm::x86::Gp operand, std::optional<Argument> argument) const override; \
        ArgumentImm generate_rhs(ArgumentImm lhs) const override;                                                                  \
    }

#define MATHOP_OPERATION_STUB_NO_RHS(name, base_name)                                                                              \
    class name final : public base_name {                                                                                          \
    public:                                                                                                                        \
        ArgumentImm emulate(ArgumentImm op1, std::optional<ArgumentImm> op2) const override;                                       \
        void lift_revert(zasm::x86::Assembler* assembler, zasm::x86::Gp operand, std::optional<Argument> argument) const override; \
    }

#define MATHOP_OPERATION_ONE_OP(name) MATHOP_OPERATION_STUB_NO_RHS(name, mathop::OperationOneOperand)
#define MATHOP_OPERATION_TWO_OPS(name) MATHOP_OPERATION_STUB(name, mathop::OperationTwoOperands)

namespace mathop::operations {
    /// + -
    MATHOP_OPERATION_TWO_OPS(Add);
    MATHOP_OPERATION_TWO_OPS(Sub);

    /// ^
    MATHOP_OPERATION_TWO_OPS(Xor);

    /// +1 -1
    MATHOP_OPERATION_ONE_OP(Inc);
    MATHOP_OPERATION_ONE_OP(Dec);

    /// -
    MATHOP_OPERATION_ONE_OP(Neg);

    /// ~
    MATHOP_OPERATION_ONE_OP(Not);

    /// \todo @es3n1n: rotl, rotr, nand, nor, and, or, mul, div, lshl, lshr
} // namespace mathop::operations

#undef MATHOP_OPERATION_TWO_OPS
#undef MATHOP_OPERATION_ONE_OP
#undef MATHOP_OPERATION_STUB_NO_RHS
#undef MATHOP_OPERATION_STUB

```

`src/lib/obfuscator/config_merger/config_merger.hpp`:

```hpp
#pragma once
#include "obfuscator/transforms/configs.hpp"
#include "obfuscator/transforms/scheduler.hpp"
#include "obfuscator/transforms/transform.hpp"

namespace obfuscator::config_merger {
    namespace detail {
        /// \brief Util function to get all required vars for a transform
        /// \tparam Img X64 or X86 image
        /// \param transform Transform pointer
        /// \param type Var type
        /// \return vector of names
        template <pe::any_image_t Img>
        std::vector<std::string> get_all_required_vars_for(Transform<Img>* transform, const TransformConfig::Var::Type type) {
            std::vector<std::string> required_var_names = {};

            transform->iter_vars([&required_var_names, type](const TransformConfig::Var& var) -> void {
                if (var.var_type() != type) {
                    return;
                }
                if (!var.required()) {
                    return;
                }
                required_var_names.emplace_back(var.name());
            });

            return required_var_names;
        }

        /// \brief An util that applies desired config
        /// \tparam Img X64 or X86 image
        /// \param transform Transform pointer
        /// \param type var type
        /// \param values config values
        /// \param shared_config shared config reference
        template <pe::any_image_t Img>
        void apply_vars(Transform<Img>* transform, const TransformConfig::Var::Type type, const std::unordered_map<std::string, std::string>& values,
                        TransformSharedConfig& shared_config) {
            /// Collect all required vars
            auto required_var_names = get_all_required_vars_for(transform, type);

            /// Reset shared config state if we're parsing PER_FUNCTION stuff
            if (type == TransformConfig::Var::Type::PER_FUNCTION) {
                shared_config.reset();
            }

            /// Iterate over the vars
            for (auto&& [var_name, var_s_value] : values) {
                /// Try to load to shared config first
                if (shared_config.try_load(var_name, var_s_value, type == TransformConfig::Var::Type::GLOBAL)) {
                    continue;
                }

                /// Get the var
                auto& var = transform->get_var_by_name(var_name);

                /// Assert var type, we are only dealing with global ones here
                if (var.var_type() != type) {
                    throw std::runtime_error(std::format("apply_global_vars: unable to set the {} value", var_name));
                }

                /// Parse the value
                var.parse_value(var_s_value);

                /// Mark as set if this var was required
                std::erase_if(required_var_names, [&var](const auto& name) -> bool {
                    return var.name() == name; //
                });
            }

            /// Throw an error if some vars were unset
            if (!required_var_names.empty()) {
                throw std::runtime_error(std::format("apply_config: unable to find required {} value", required_var_names.at(0)));
            }
        }
    } // namespace detail

    /// \brief Apply transform global vars
    /// \tparam Img X64 or X86 image
    /// \param config config reference
    template <pe::any_image_t Img>
    void apply_global_vars(config_parser::Config& config) {
        /// Get the scheduler
        auto& scheduler = TransformScheduler::get().for_arch<Img>();

        /// Iterate over the global defined vars for the transform
        for (auto& [tag, values] : config.global_transforms_config()) {
            /// Get the transform, its shared config
            auto& transform = scheduler.transforms.at(tag);
            auto& shared_config = TransformSharedConfigStorage::get().get_for(tag);

            /// Apply vars
            detail::apply_vars(transform.get(), TransformConfig::Var::Type::GLOBAL, values, shared_config);
        }
    }

    /// \brief Apply user-defined configuration for the transform
    /// \tparam Img X64 or X86 image
    /// \param transform_config user-defined options
    template <pe::any_image_t Img>
    void apply_config(const config_parser::transform_configuration_t& transform_config) {
        /// Get all the needed stuff
        auto& scheduler = TransformScheduler::get().for_arch<Img>();
        auto& transform = scheduler.transforms.at(transform_config.tag);
        auto& shared_config = TransformSharedConfigStorage::get().get_for(transform_config.tag);

        /// Reset all PER_FUNCTION vars
        transform->reset_config(TransformConfig::Var::PER_FUNCTION);

        /// Apply vars
        detail::apply_vars(transform.get(), TransformConfig::Var::Type::PER_FUNCTION, transform_config.values, shared_config);
    }
} // namespace obfuscator::config_merger

```

`src/lib/obfuscator/function.hpp`:

```hpp
#pragma once
#include "analysis/var_alloc/var_alloc.hpp"
#include "obfuscator/transforms/types.hpp"

namespace obfuscator {
    /// \brief Function information representation
    /// \tparam Img PE Image type, either x64 or x86
    template <pe::any_image_t Img>
    struct Function {
        DEFAULT_DTOR(Function);
        NON_COPYABLE(Function);
        Function(const analysis::Function<Img>& func, const Img* image)
            : parsed_func(func.parsed_func), lru_reg(func.lru_reg), bb_storage(func.bb_storage), program(func.program), assembler(func.assembler),
              cursor(std::make_unique<easm::Cursor>(program, assembler)), observer(func.observer), bb_provider(func.bb_provider),
              machine_mode(image->guess_machine_mode()) { }

        /// \brief Construct new var allocator
        /// \return varalloc instance
        auto var_alloc() {
            return analysis::VarAlloc<Img>(&lru_reg);
        }

        /// \brief Parsed information from PDB/MAP/etc
        func_parser::function_t parsed_func;
        /// \brief Least recently used register cache
        analysis::LRUReg<Img> lru_reg;
        /// \brief A storage with basic blocks
        std::shared_ptr<analysis::bb_storage_t> bb_storage;
        /// \brief Zasm routine
        std::shared_ptr<zasm::Program> program;
        /// \brief Zasm assembler
        std::shared_ptr<zasm::x86::Assembler> assembler;
        /// \brief Assembler cursor wrapped
        std::unique_ptr<easm::Cursor> cursor;
        /// \brief Node observer
        std::shared_ptr<analysis::Observer> observer;
        /// \brief BB Provider
        std::shared_ptr<analysis::functional_bb_provider_t> bb_provider;
        /// \brief Zasm machine mode
        const zasm::MachineMode machine_mode;
    };
} // namespace obfuscator
```

`src/lib/obfuscator/obfuscator.cpp`:

```cpp
#include "obfuscator/obfuscator.hpp"
#include "analysis/observer/observer.hpp"
#include "easm/debug/debug.hpp"
#include "obfuscator/config_merger/config_merger.hpp"
#include "obfuscator/function.hpp"
#include "obfuscator/transforms/scheduler.hpp"
#include "util/logger.hpp"
#include "util/progress.hpp"
#include "util/random.hpp"

namespace obfuscator {
    constexpr size_t kTextSectionAlignment = 0x10;

    template <pe::any_image_t Img>
    void Instance<Img>::setup() {
        // Initializing instances
        //
        func_parser_.setup(image_, config_.func_parser_config(), config_.obfuscator_config());

        // Running setup tasks
        //
        func_parser_.collect_functions();

        // Add functions from config, that we should protecc
        //
        auto analysis_progress = util::Progress("obfuscator: setting up functions", config_.size());
        for (auto& configuration : config_) {
            add_function(configuration);
            analysis_progress.step();
        }

        // Enable transforms from global config
        //
        auto& scheduler = TransformScheduler::get();
        for (auto& [tag, _] : config_.global_transforms_config()) {
            scheduler.enable_transform(tag);
        }
    }

    template <pe::any_image_t Img>
    void Instance<Img>::add_function(const config_parser::function_configuration_t& configuration) {
        /// We don't want to obfuscate functions with 0 transforms
        // if (configuration.transform_configurations.empty()) {
        // logger::warn("collect: excluding function {} from obfuscation list", configuration.function_name);
        // return;
        //}

        /// Try to find function info from map/pdb
        const auto function_info =
            func_parser_.find_if([&configuration](const func_parser::function_t& func) -> bool { return func.name == configuration.function_name; });
        if (!function_info.has_value()) {
            throw std::runtime_error(std::format("collect: function {} not found", configuration.function_name));
        }

        /// Enable needed transforms
        auto& scheduler = TransformScheduler::get();
        for (const auto& [tag, _] : configuration.transform_configurations) {
            scheduler.enable_transform(tag);
        }

        /// Store function info
        functions_.emplace_back(function_t{
            .analysed = analysis::analyse(image_, function_info.value()),
            .configuration = configuration,
        });
    }

    template <pe::any_image_t Img>
    void Instance<Img>::obfuscate() {
        /// Debug log
        logger::info("obfuscator: got {} function(s) to obfuscate", functions_.size());

        if (functions_.empty()) {
            throw std::runtime_error("obfuscator: got 0 functions to protect");
        }

        /// Obtain transform scheduler for the platform
        auto& scheduler = TransformScheduler::get().for_arch<Img>();
        config_merger::apply_global_vars<Img>(config_);

        /// Iterate over functions that we need to obfuscate
        for (const auto& func : functions_) {
            /// Init the `obfuscator::Function` that is going to be used within
            /// transforms
            auto obf_func = obfuscator::Function<Img>(func.analysed, image_);

            /// Export tags that this function would need
            auto tags = std::views::all(func.configuration.transform_configurations) |
                        std::views::transform([](const config_parser::transform_configuration_t& it) -> TransformTag { return it.tag; }) |
                        std::ranges::to<std::vector>();

            /// Export transforms
            auto transforms = scheduler.select_transforms(tags);

            /// Init the progress bar
            auto progress = util::Progress(std::format("obfuscator: obfuscating {}", obf_func.parsed_func.name), transforms.size());

            /// An util that would check the chances and all this other crap, that would be
            /// needed for like  every possible function/transform
            auto execute_transform = [func](const TransformTag tag, const std::function<void(TransformContext&)>& callback,
                                            const bool check_chances = true) -> void {
                auto preset = std::ranges::find_if(func.configuration.transform_configurations, [tag](auto&& it) -> bool {
                    return it.tag == tag; //
                });
                if (preset == std::end(func.configuration.transform_configurations)) {
                    throw std::runtime_error(std::format("obfuscate: unable to find configuration for transform {}", tag));
                }

                /// Apply the preset
                config_merger::apply_config<Img>(*preset);

                /// Get the shared config and check the chance
                auto& cfg = TransformSharedConfigStorage::get().get_for(tag);

                /// Check the chance
                /// \todo @es3n1n: Check for chance feature
                if (check_chances && !rnd::chance(cfg.chance())) {
                    return;
                }

                /// Otherwise run this method
                for (std::size_t i = 0; i < cfg.repeat_times(); ++i) {
                    /// Init context, run the task
                    auto context = TransformContext(cfg);

                    do {
                        context.rerun_me = false;
                        callback(context);
                    } while (context.rerun_me);
                }
            };
            auto execute_transform_no_chances = [&](const TransformTag tag, const std::function<void(TransformContext&)>& callback) -> void {
                return execute_transform(tag, callback, false);
            };

            /// \note @es3n1n: We can't iterate through the insns/bbs and execute transforms
            /// from there as it would break the scheduling order
            for (auto& [tag, transform] : transforms) {
                /// Apply function transform
                if (transform->feature(TransformFeaturesSet::HAS_FUNCTION_TRANSFORM)) {
                    execute_transform_no_chances(tag, [&obf_func, &transform](auto& ctx) -> void {
                        transform->run_on_function(ctx, &obf_func); //
                    });
                }

                /// Apply basic block transforms
                if (transform->feature(TransformFeaturesSet::HAS_BB_TRANSFORM)) {
                    for (auto& basic_block : obf_func.bb_storage->temp_copy()) {
                        execute_transform(tag, [&obf_func, &transform, &basic_block](auto& ctx) -> void {
                            transform->run_on_bb(ctx, &obf_func, basic_block.get()); //
                        });
                    }
                }

                /// Apply analysis insn transforms
                if (transform->feature(TransformFeaturesSet::HAS_INSN_TRANSFORM)) {
                    for (auto& basic_block : obf_func.bb_storage->temp_copy()) {
                        for (auto& insn : basic_block->temp_insns_copy()) {
                            execute_transform(tag, [&obf_func, &transform, &insn](auto& ctx) -> void {
                                transform->run_on_insn(ctx, &obf_func, insn.get()); //
                            });
                        }
                    }
                }

                /// Apply program nodes transform
                if (transform->feature(TransformFeaturesSet::HAS_NODE_TRANSFORM)) {
                    for (auto* node = obf_func.program->getHead(); node != nullptr; node = node->getNext()) {
                        /// Transform nodes
                        execute_transform(tag, [&obf_func, &transform, &node](auto& ctx) -> void {
                            transform->run_on_node(ctx, &obf_func, node); //
                        });
                    }
                }

                /// Increment progress bar
                progress.step();
            }

            /// We are done here
        }
    }

    template <pe::any_image_t Img>
    void Instance<Img>::assemble() {
        /// Estimating section size
        auto size_estimation_progress = util::Progress("obfuscator: estimating section size", functions_.size());
        std::size_t section_size = 0;
        for (auto& func : functions_) {
            const auto program_size = easm::estimate_program_size(*func.analysed.program);
            section_size += memory::address{program_size}.align_up(kTextSectionAlignment).as<std::size_t>();
            size_estimation_progress.step();
        }
        logger::debug("assemble: estimated new section size: {:#x}", section_size);

        /// Allocate new section
        auto img_base = image_->raw_image->get_nt_headers()->optional_header.image_base;
        auto& new_sec = image_->new_section(sections::e_section_t::CODE, section_size);
        memory::address virt_address = new_sec.virtual_address;

        /// Iterate over the obfuscated functions
        auto linking_progress = util::Progress("obfuscator: linking functions", functions_.size());
        for (auto& [func, _] : functions_) {
            /// \todo @es3n1n: perhaps i should split this monstrosity into a separate functions

            /// Erase the original function code
            for (auto& basic_block : *func.bb_storage) {
                for (auto& insn : basic_block) {
                    /// No need to erase instructions that doesn't exist
                    if (!insn->rva.has_value()) {
                        continue;
                    }

                    /// Generate random bytes
                    const auto randomized = rnd::bytes(*insn->length);

                    /// Replace instruction with junk
                    auto* insn_ptr = image_->rva_to_ptr(*insn->rva);
                    std::memcpy(insn_ptr, randomized.data(), randomized.size());

                    /// Remove pe relocation, if there's any
                    if (insn->reloc.type == analysis::insn_reloc_t::e_type::HEADER) {
                        image_->relocations.erase(*insn->rva + insn->reloc.offset.value_or(0));
                    }
                }
            }

            /// Insert the jmp to obfuscated routine at the very beginning of the function
            auto* func_start_ptr = image_->rva_to_ptr(func.range.start);
            auto jmp_data = easm::encode_jmp(image_->guess_machine_mode(), func.range.start + img_base, virt_address + img_base);
            if (!jmp_data.has_value()) {
                throw std::runtime_error("assemble: unable to encode jmp");
            }
            std::memcpy(func_start_ptr, jmp_data->data(), jmp_data->size());

            /// Assemble the obfuscated function
            auto assemble_progress = util::Progress(std::format("obfuscator: assembling {}", func.parsed_func.name), 1);
            const auto assembled = easm::assemble_program(virt_address + img_base, *func.program);
            assemble_progress.step();

            /// Copy fresh new assembled function
            std::memcpy( //
                new_sec.raw_data.data() + (virt_address - new_sec.virtual_address).template as<std::size_t>(), //
                assembled.data.data(), //
                assembled.data.size() //
            );

            /// Save the new relocations
            for (const zasm::RelocationInfo& relocation : assembled.relocations) {
                /// Map zasm relocation kind to windows relocation kind
                win::reloc_type_id win_reloc_type;
                switch (relocation.kind) {
                default:
                case zasm::RelocationType::None:
                    throw std::runtime_error("linker: got invalid relocation");
                case zasm::RelocationType::Abs:
                    win_reloc_type = win::reloc_type_id::rel_based_absolute;
                    break;
                case zasm::RelocationType::Rel32:
                    win_reloc_type = win::reloc_type_id::rel_based_high_low;
                    break;
                }

                /// Store the new relocation data
                image_->relocations[relocation.address - img_base] =
                    pe::relocation_t{.rva = memory::address{static_cast<uintptr_t>(relocation.address - img_base)},
                                     .size = static_cast<std::uint8_t>(getBitSize(relocation.size) / CHAR_BIT),
                                     .type = win_reloc_type};
            }

            /// Align size and increment offset
            const auto aligned_size = memory::address{assembled.data.size()}.align_up(kTextSectionAlignment).as<std::size_t>();
            virt_address = virt_address.offset(aligned_size);

            /// Increment progress bar
            linking_progress.step();
        }

        logger::info("assemble: assembled {} functions", functions_.size());
    }

    template <pe::any_image_t Img>
    void Instance<Img>::save() {
        logger::info("obfuscator: saving..");
        auto new_img = image_->rebuild_pe_image();

        auto out_path = config_.obfuscator_config().binary_path;

        auto filename = out_path.filename();
        const auto file_ext = filename.extension().string();
        const auto filename_no_ext = filename.replace_extension().string();

        const auto new_filename = filename_no_ext + ".protected" + file_ext;

        out_path = out_path.replace_filename(new_filename);
        util::write_file(out_path, new_img.data(), new_img.size());

        logger::info("obfuscator: saved output to {}", out_path.string());
    }

    PE_DECL_TEMPLATE_CLASSES(Instance);
} // namespace obfuscator

```

`src/lib/obfuscator/obfuscator.hpp`:

```hpp
#pragma once
#include "analysis/analysis.hpp"
#include "config_parser/config_parser.hpp"
#include "func_parser/parser.hpp"
#include "pe/pe.hpp"
#include "util/structs.hpp"

namespace obfuscator {
    template <pe::any_image_t Img>
    class Instance {
    public:
        Instance(Img* image, config_parser::Config& config): image_(image), config_(std::move(config)) { }
        DEFAULT_DTOR(Instance);
        NON_COPYABLE(Instance);

        void setup();
        void add_function(const config_parser::function_configuration_t& configuration);
        void obfuscate();
        void assemble();
        void save();

        struct function_t {
            analysis::Function<Img> analysed;
            config_parser::function_configuration_t configuration;
        };

    private:
        Img* image_ = nullptr;
        config_parser::Config config_ = {};
        func_parser::Instance<Img> func_parser_ = {};
        std::vector<function_t> functions_ = {};
    };
} // namespace obfuscator
```

`src/lib/obfuscator/transforms/configs.hpp`:

```hpp
#pragma once
#include "obfuscator/transforms/types.hpp"
#include "util/string_parser.hpp"
#include "util/types.hpp"
#include <any>

namespace obfuscator {
    namespace detail {
        enum e_shared_config_variable_name_index {
            CHANCE = 0,
            REPEAT_TIMES = 1,
        };
        inline std::array kSharedConfigsVariableNames = {"chance", "repeat"};
    } // namespace detail

    /// \brief Configuration class that is used in scheduler for storing transform presets
    struct TransformSharedConfig {
        DEFAULT_DTOR(TransformSharedConfig);
        NON_COPYABLE(TransformSharedConfig);
        TransformSharedConfig(const std::string_view transform_name, const TransformTag transform_tag): name(transform_name), tag(transform_tag) { }

        /// \brief Set how many times we need to re-run the transform
        /// \param times Number of times (1 - 1 time, nullopt - 1 time)
        /// \param override_default Should we override the default value too?
        /// \return Config reference
        TransformSharedConfig& repeat_times(const std::uint8_t times, const bool override_default = false) noexcept {
            repeat_times_ = std::max(static_cast<std::uint8_t>(1), times);
            if (override_default) {
                repeat_times_default_ = repeat_times_;
            }
            return *this;
        }

        /// \brief Get how many times we need to re-run this transform
        /// \return number of times
        [[nodiscard]] std::uint8_t repeat_times() const noexcept {
            return repeat_times_;
        }

        /// \brief Set the transform run chance
        /// \param chance chance (from 0 to 100)%
        /// \param override_default Should we override the default value too?
        /// \return Config reference
        TransformSharedConfig& chance(const std::uint8_t chance, const bool override_default = false) noexcept {
            chance_ = std::clamp(chance, static_cast<std::uint8_t>(0), static_cast<std::uint8_t>(100));
            if (override_default) {
                chance_default_ = chance_;
            }
            return *this;
        }

        /// \brief Get the transform run chance
        /// \return chance (from 0 to 100)%
        [[nodiscard]] std::uint8_t chance() const noexcept {
            return chance_;
        }

        /// \brief Try to load the shared configuration var from string
        /// \param name Var name
        /// \param value Var stringified value
        /// \param override_default Should we override the default value too?
        /// \return true on success, false on failure
        bool try_load(const std::string_view name, const std::string_view value, const bool override_default = false) noexcept {
            static std::unordered_map<std::string, std::function<void(TransformSharedConfig*, std::string_view, bool)>> callbacks = {};

            /// A little bit of overhead with this once flag, but now the init looks n i c e
            static std::once_flag fl;
            std::call_once(fl, []() -> void {
                callbacks[detail::kSharedConfigsVariableNames[detail::CHANCE]] = [](auto* instance_, const auto value_, const auto override_default_) {
                    instance_->chance(util::string::parse_uint8(value_), override_default_);
                };

                callbacks[detail::kSharedConfigsVariableNames[detail::REPEAT_TIMES]] = [](auto* instance_, const auto value_,
                                                                                          const auto override_default_) {
                    instance_->repeat_times(util::string::parse_uint8(value_), override_default_);
                };
            });

            /// Try to find the loader, and load if found
            if (const auto it = callbacks.find(name.data()); it != std::end(callbacks)) {
                it->second(this, value, override_default);
                return true;
            }

            /// Not found
            return false;
        }

        /// \brief Stringify var value by its name
        /// \param var_name variable name
        /// \return stringified value
        [[nodiscard]] std::string stringify_var(const std::string_view var_name) const noexcept {
            if (var_name == detail::kSharedConfigsVariableNames[detail::CHANCE]) {
                return std::to_string(chance_);
            }
            if (var_name == detail::kSharedConfigsVariableNames[detail::REPEAT_TIMES]) {
                return std::to_string(repeat_times());
            }
            return "unknown var"; // maybe we should throw an exception?
        }

        /// \brief Reset the shared config state
        void reset() {
            repeat_times_ = repeat_times_default_;
            chance_ = chance_default_;
        }

        /// \brief Transform human-readable name
        const std::string name;
        /// \brief Transform internal identifier
        const TransformTag tag;

    private:
        /// \brief How many times do we need to re-run this transform
        /// \note If set to 1, the transform would be executed only 1 time
        std::uint8_t repeat_times_default_ = 1;
        std::uint8_t repeat_times_ = repeat_times_default_;

        /// \brief Transform run chance in percents
        std::uint8_t chance_default_ = 30; // (from 0 to 100)%
        std::uint8_t chance_ = chance_default_;
    };

    /// \brief Transform configuration storage
    class TransformSharedConfigStorage : public types::Singleton<TransformSharedConfigStorage> {
    public:
        DEFAULT_CTOR_DTOR(TransformSharedConfigStorage);
        NON_COPYABLE(TransformSharedConfigStorage);

        /// \brief Get transform config using the transform tag
        [[nodiscard]] TransformSharedConfig& get_for(const TransformTag tag, const std::optional<std::string_view>& name = std::nullopt) {
            /// If already cached
            if (const auto it = configurations_.find(tag); it != std::end(configurations_)) {
                return it->second;
            }

            /// Otherwise create new one
            configurations_.emplace(std::piecewise_construct, std::make_tuple(tag), std::make_tuple(*name, tag));
            return configurations_.at(tag);
        }

        /// \brief Get transform config using the transform type
        template <template <pe::any_image_t> class Ty>
        [[nodiscard]] TransformSharedConfig& get_for() {
            return get_for(get_transform_tag<Ty>(), get_transform_name<Ty>());
        }

        /// \brief Get transform config using its name
        [[nodiscard]] TransformSharedConfig& get_for_name(const std::string_view name) {
            const auto it = std::ranges::find_if(configurations_, [name](const auto& p) -> bool { return p.second.name == name; });

            if (it == std::end(configurations_)) {
                throw std::runtime_error(std::format("configs: Unable to find configuration for transform {}", name));
            }

            return it->second;
        }

    private:
        /// \brief Configuration storage
        std::unordered_map<TransformTag, TransformSharedConfig> configurations_ = {};
    };

    /// \brief Transform configuration storage
    class TransformConfig {
    public:
        DEFAULT_CTOR_DTOR(TransformConfig);
        NON_COPYABLE(TransformConfig);
        using Index = std::size_t;

        class Var {
        public:
            DEFAULT_CTOR_DTOR(Var);
            DEFAULT_COPY(Var);

            enum Type {
                GLOBAL = 0, // one option for all functions
                PER_FUNCTION, // sets per function
            };

            /// \brief Get the variable as desired type
            /// \tparam Ty type
            /// \return Value
            template <typename Ty>
            [[nodiscard]] Ty value() const {
                assert(value_.has_value());
                return std::any_cast<Ty>(value_);
            }

            /// \brief Get the variable, or default value if its value is unset
            /// \tparam Ty type
            /// \param default_value default value
            /// \return value
            template <typename Ty>
            [[nodiscard]] Ty value_or(const Ty default_value) const {
                if (!value_.has_value()) {
                    return default_value;
                }
                return std::any_cast<Ty>(value_);
            }

            /// \brief Set the variable value
            /// \tparam Ty type
            /// \param value value that it should set
            template <typename Ty>
            void set(const Ty value) {
                if (!value_.has_value()) {
                    default_value_.emplace<Ty>(value);
                }
                value_.emplace<Ty>(value);
            }

            /// \brief Set new value parsed from string
            /// \param value string that contain the new value
            void parse_value(const std::string_view value) {
                util::string::parse_to_any(value_, value);
            }

            /// \brief Verify that this variable has a value set
            /// \return true/false
            [[nodiscard]] bool is_set() const {
                return value_.has_value();
            }

            /// \brief Get the var type
            /// \return Type
            [[nodiscard]] Type var_type() const {
                return type_;
            }

            /// \brief Get var name
            /// \return Name
            [[nodiscard]] std::string name() const {
                return name_;
            }

            /// \brief Get var short description
            /// \return Name
            [[nodiscard]] std::optional<std::string> short_description() const {
                return short_description_;
            }

            /// \brief Set short description (1 line max)
            /// \param short_description description value
            void short_description(const std::string& short_description) {
                short_description_ = short_description;
            }

            /// \brief Is var required
            /// \return bool
            [[nodiscard]] bool required() const {
                return required_;
            }

            /// \brief Serialize current value as string
            /// \return string
            [[nodiscard]] std::string serialize() const {
                return util::string::serialize_any(value_);
            }

            /// \brief Set the variable info
            /// \param name variable name
            /// \param is_required is required
            /// \param type variable type, either global or per function
            void set_info(const std::string& name, const bool is_required, const Type type) {
                name_ = name;
                required_ = is_required;
                type_ = type;
            }

            /// \brief Reset variable to its default value
            void reset() {
                value_ = default_value_;
            }

        private:
            /// \brief Value holder
            std::any value_ = {};
            /// \brief First value holder
            std::any default_value_ = {};
            /// \brief Var name
            std::string name_ = {};
            /// \brief Short description (1 line max)
            std::optional<std::string> short_description_ = std::nullopt;
            /// \brief Is var required to set by user
            bool required_ = false;
            /// \brief Variable type, either global or per function
            Type type_ = GLOBAL;
        };

        /// \brief Create a new var with default value
        /// \tparam Ty value type
        /// \param index variable unique index
        /// \param name variable name
        /// \param is_required is required
        /// \param type Variable type, either global or per function
        /// \param default_value variable default value
        /// \return Var reference
        template <typename Ty>
        Var& new_var(const Index index, const std::string& name, const bool is_required, const Var::Type type, const Ty default_value) {
            variables_[index].set_info(name, is_required, type);
            auto& result = variables_.at(index);
            result.set(default_value);
            return result;
        }

        /// \brief Get variable object
        /// \param index variable index
        /// \return var object reference
        [[nodiscard]] const Var& get_var(const Index index) const {
            if (const auto iter = variables_.find(index); iter != std::end(variables_)) {
                return iter->second;
            }

            throw std::runtime_error(std::format("configs: unable to find var {}", index));
        }

        /// \brief Get variable object by name
        /// \param name Var name
        /// \return var object reference
        [[nodiscard]] Var& get_var_by_name(const std::string_view name) {
            if (const auto iter = std::ranges::find_if(variables_, [name](const auto& p) -> bool { return p.second.name() == name; });
                iter != std::end(variables_)) {
                return iter->second;
            }

            throw std::runtime_error(std::format("configs: unable to find var {}", name));
        }

        /// \brief Get variable value
        /// \tparam Ty value type
        /// \param index var index
        /// \return value
        template <typename Ty>
        [[nodiscard]] Ty get_value(const Index index) const {
            return get_var(index).value<Ty>();
        }

        /// \brief Reset all config vars to their default values
        /// \param type type of vars that it should reset
        void reset_vars(const Var::Type type) {
            for (auto& var : std::views::values(variables_)) {
                if (var.var_type() != type) {
                    continue;
                }

                var.reset();
            }
        }

        /// \brief Iterate over the all transform vars
        /// \param callback foreach callback
        void iter_vars(const std::function<void(Var&)>& callback) {
            std::ranges::for_each(variables_, [callback](auto&& p) -> void { callback(p.second); });
        }

    private:
        /// \brief A map that stores all the variables with their indices
        std::unordered_map<Index, Var> variables_ = {};
    };
} // namespace obfuscator

```

`src/lib/obfuscator/transforms/scheduler.hpp`:

```hpp
#pragma once
#include "obfuscator/transforms/configs.hpp"
#include "obfuscator/transforms/transform.hpp"
#include "obfuscator/transforms/types.hpp"

#include "pe/pe.hpp"

namespace obfuscator {
    /// \brief A container that stores transforms and their schedule state
    /// \tparam Img PE Image type, either x64 or x86
    template <pe::any_image_t Img>
    class TransformContainer {
    public:
        DEFAULT_CTOR_DTOR(TransformContainer);
        NON_COPYABLE(TransformContainer);
        using T = Img;
        using TransformPtr = std::unique_ptr<Transform<Img>>;
        using PairPtr = std::pair<TransformTag, Transform<Img>*>;

        /// \brief Register a transform under its tag
        /// \tparam Ty Transform type
        template <template <pe::any_image_t> class Ty>
        TransformSharedConfig& register_transform() {
            /// Init transform
            const auto tag = get_transform_tag<Ty>();
            auto instance = std::make_unique<Ty<Img>>();
            instance->init();

            /// Save transform
            transforms[tag] = std::move(instance);

            /// Init the config and return it
            return TransformSharedConfigStorage::get().get_for<Ty>();
        }

        /// \brief Enable desired transform
        /// \param tag transform tag
        /// \return Config reference
        TransformSharedConfig& enable_transform(const TransformTag tag) {
            if (std::ranges::find(enabled, tag) == std::end(enabled))
                enabled.emplace_back(tag);
            return TransformSharedConfigStorage::get().get_for(tag);
        }

        /// \brief Select transforms by their tags
        [[nodiscard]] auto select_transforms(const std::vector<TransformTag>& tags,
                                             const std::optional<TransformFeaturesSet::Index> feature_filter = std::nullopt) {
            std::vector<std::pair<TransformTag, Transform<Img>*>> result = {};

            for (const auto tag : tags) {
                const auto it = transforms.find(tag);
                if (it == std::end(transforms)) {
                    throw std::runtime_error(std::format("scheduler: unable to find transform with tag {:#x}", tag));
                }

                if (feature_filter.has_value() && !it->second->feature(feature_filter.value())) {
                    continue;
                }

                result.emplace_back(std::make_pair(tag, it->second.get()));
            }

            return result;
        }

        /// \brief Iterate over the enabled transforms using callback
        /// \param callback callback that should be invoked for every entry
        void iter_enabled_transforms(const std::function<void(Transform<Img>*)>& callback) {
            std::ranges::for_each(enabled, [this, &callback](const TransformTag tag) -> void { callback(transforms.at(tag).get()); });
        }

        /// \brief Get a std::views iterator for transforms
        auto transforms_iterator() {
            return std::views::all(transforms) | std::views::filter([this](const auto& value) -> bool {
                       return std::ranges::find(this->enabled, value.first) != std::end(this->enabled);
                   }) |
                   std::views::keys | std::views::transform([](const auto& value) -> Transform<Img>* { return value.get(); });
        }

        /// \brief Transforms iterator begin for the ranged loops
        /// \return iterator
        [[nodiscard]] auto begin() {
            return transforms_iterator().begin();
        }

        /// \brief Transforms const iterator begin for the ranged loops
        /// \return iterator
        [[nodiscard]] auto begin() const {
            return transforms_iterator().begin();
        }

        /// \brief Transforms iterator end for the ranged loops
        /// \return iterator
        [[nodiscard]] auto end() {
            return transforms_iterator().end();
        }

        /// \brief Transforms const iterator end for the ranged loops
        /// \return iterator
        [[nodiscard]] auto end() const {
            return transforms_iterator().end();
        }

        /// \brief A map that stores enabled transforms
        std::vector<TransformTag> enabled;

        /// \brief A map that stores transforms under their tags
        std::unordered_map<TransformTag, TransformPtr> transforms;
    };

    /// \brief Transform scheduler that stores all the transforms and their schedule state
    class TransformScheduler : public types::Singleton<TransformScheduler> {
    public:
        /// \brief Register a desired transform under the transform tag for **both** x64 and x86 architectures
        /// \tparam Ty Transform type
        template <template <pe::any_image_t Img> class Ty>
        TransformSharedConfig& register_transform() {
            for_arch<pe::X64Image>().register_transform<Ty>();
            return for_arch<pe::X86Image>().register_transform<Ty>();
        }

        template <pe::any_image_t Img>
        [[nodiscard]] TransformContainer<Img>& for_arch() {
            /// Hack: since for templated functions the compiler would generate unique functions,
            /// we could abuse it in our way in order to not init 2 type of containers at the
            /// same time.
            static TransformContainer<Img> container_ = {};
            return container_;
        }

        /// \brief Get the total number of enabled transforms
        /// \return
        [[nodiscard]] std::size_t enabled_count() {
            return for_arch<pe::X64Image>().enabled.size() + for_arch<pe::X86Image>().enabled.size();
        }

        /// \brief Enable transform on all architectures
        /// \param tag transform tag
        void enable_transform(const TransformTag tag) {
            for_arch<pe::X64Image>().enable_transform(tag);
            for_arch<pe::X86Image>().enable_transform(tag);
        }
    };

    /// \brief Scheduler initialization routine
    void startup_scheduler();
} // namespace obfuscator

```

`src/lib/obfuscator/transforms/startup.cpp`:

```cpp
#include "obfuscator/transforms/scheduler.hpp"
#include "obfuscator/transforms/transforms/bogus_control_flow.hpp"
#include "obfuscator/transforms/transforms/constant_crypt.hpp"
#include "obfuscator/transforms/transforms/substitution.hpp"
#include "obfuscator/transforms/transforms/decomp_break.hpp"

namespace obfuscator {
    /// \fixme @es3n1n: This could and should be moved to the transform scheduler constructor
    /// so that when we call singleton ::get() it would init it only once
    void startup_scheduler() {
        auto& scheduler = TransformScheduler::get();

        scheduler.register_transform<transforms::ConstantCrypt>();
        scheduler.register_transform<transforms::Substitution>();
        scheduler.register_transform<transforms::BogusControlFlow>();
        scheduler.register_transform<transforms::DecompBreak>();
    }
} // namespace obfuscator
```

`src/lib/obfuscator/transforms/transform.hpp`:

```hpp
#pragma once
#include "obfuscator/function.hpp"

namespace obfuscator {
    /// \brief Feature set represents what features does this transform support.
    /// Can contain only bool values by design.
    class TransformFeaturesSet {
    public:
        DEFAULT_CTOR_DTOR(TransformFeaturesSet);
        DEFAULT_COPY(TransformFeaturesSet);

        /// \brief Available features
        enum Index {
            HAS_FUNCTION_TRANSFORM = 0,
            HAS_BB_TRANSFORM,
            HAS_NODE_TRANSFORM,
            HAS_INSN_TRANSFORM,
            /// \todo @es3n1n: *_has_chance_check
        };

        /// \brief Get feature by its index
        /// \param feature Feature index
        /// \return reference to value
        bool& get(const Index feature) {
            return values_[feature];
        }

    private:
        /// \brief Features storage, by default it would initialize values to false
        std::unordered_map<Index, bool> values_ = {};
    };

    /// \brief Transform context that gets passed to the transform callback
    class TransformContext {
    public:
        DEFAULT_DTOR(TransformContext);
        NON_COPYABLE(TransformContext);
        explicit TransformContext(TransformSharedConfig& shared_config_value): shared_config(shared_config_value) { }

        /// \brief Shared config reference
        TransformSharedConfig& shared_config;

        /// \brief An option that could be set to true in order to force the obfuscator to re-run
        /// the transform, ignoring the `repeat_times` from its config.
        bool rerun_me = false;
    };

    /// \brief Obfuscation transform
    /// \tparam Img PE Image type, either x64 or x86
    template <pe::any_image_t Img>
    class Transform {
    public:
        DEFAULT_CTOR(Transform);
        NON_COPYABLE(Transform);
        virtual ~Transform() = default;

        /// \brief Callback that initializes `features_set_`
        virtual void init_features() = 0;

        /// \brief Optional callback that initializes config variables
        virtual void init_config() { }

        /// \brief Transform routine
        /// \param ctx Transform context
        /// \param function Routine that it should transform
        virtual void run_on_function(TransformContext& ctx, Function<Img>* function) = 0;

        /// \brief Transform basic block
        /// \param ctx Transform context
        /// \param function Routine that it should transform
        /// \param basic_block Basic block that it should transform
        virtual void run_on_bb(TransformContext& ctx, Function<Img>* function, analysis::bb_t* basic_block) = 0;

        /// \brief Transform zasm node
        /// \param ctx Transform context
        /// \param function Routine that it should transform
        /// \param node Node that it should transform
        virtual void run_on_node(TransformContext& ctx, Function<Img>* function, zasm::Node* node) = 0;

        /// \brief Transform analysis insn
        /// \param ctx Transform context
        /// \param function Routine that it should transform
        /// \param insn Instruction that it should transform
        virtual void run_on_insn(TransformContext& ctx, Function<Img>* function, analysis::insn_t* insn) = 0;

        /// \brief General purpose initializer
        void init() {
            this->init_features();
            this->init_config();
        }

        /// \brief `has_function_transform` getter
        [[nodiscard]] bool feature(const TransformFeaturesSet::Index index) noexcept {
            return features_set_.get(index);
        }

        /// \brief `has_node_transform` setter
        /// \param index feature index
        /// \param value new value
        void feature(const TransformFeaturesSet::Index index, const bool value) {
            features_set_.get(index) = value;
        }

        /// \brief Create a new config var with default value
        /// \tparam Ty value type
        /// \param index variable unique index
        /// \param name variable name
        /// \param is_required is required
        /// \param type Variable type, either global or per function
        /// \param default_value variable default value
        /// \return Var reference
        template <typename Ty>
        TransformConfig::Var& new_var(const TransformConfig::Index index, const std::string& name, const bool is_required,
                                      const TransformConfig::Var::Type type, const Ty default_value) {
            return config_.new_var<Ty>(index, name, is_required, type, default_value);
        }

        /// \brief Get config variable object
        /// \param index variable index
        /// \return var object reference
        [[nodiscard]] const TransformConfig::Var& get_var(const TransformConfig::Index index) const {
            return config_.get_var(index);
        }

        /// \brief Get config variable value
        /// \tparam Ty value type
        /// \param index var index
        /// \return value
        template <typename Ty>
        [[nodiscard]] Ty get_var_value(const TransformConfig::Index index) const {
            return config_.get_value<Ty>(index);
        }

        /// \brief Reset all config vars to their default values
        /// \param type type of vars that it should reset
        void reset_config(const TransformConfig::Var::Type type) {
            config_.reset_vars(type);
        }

        /// \brief Get variable object by name
        /// \param name Var name
        /// \return var object reference
        [[nodiscard]] TransformConfig::Var& get_var_by_name(const std::string_view name) {
            return config_.get_var_by_name(name);
        }

        void iter_vars(const std::function<void(TransformConfig::Var&)>& callback) {
            config_.iter_vars(callback);
        }

    private:
        /// \brief Features set
        TransformFeaturesSet features_set_ = {};
        /// \brief Config vars storage
        TransformConfig config_ = {};
    };

    /// \brief Function obfuscation transform. This class automatically discards bb/node/insn callbacks,
    /// just a nice thing to have if you don't want to override 3 unused methods every time.
    /// \tparam Img
    template <pe::any_image_t Img>
    class FunctionTransform : public Transform<Img> {
    public:
        friend Transform<Img>;

        /// \brief Callback that initializes `features_set_`
        void init_features() override {
            this->feature(TransformFeaturesSet::Index::HAS_FUNCTION_TRANSFORM, true);
        }

        /// \brief Transform basic block
        void run_on_bb(TransformContext&, Function<Img>*, analysis::bb_t*) override { }

        /// \brief Transform zasm node
        void run_on_node(TransformContext&, Function<Img>*, zasm::Node*) override { }

        /// \brief Transform analysis insn
        void run_on_insn(TransformContext&, Function<Img>*, analysis::insn_t*) override { }
    };

    /// \brief BB obfuscation transform.
    /// Same as `FunctionTransform`, but it discards func/node/insn transforms instead.
    /// \tparam Img
    template <pe::any_image_t Img>
    class BBTransform : public Transform<Img> {
    public:
        friend Transform<Img>;

        /// \brief Callback that initializes `features_set_`
        void init_features() override {
            this->feature(TransformFeaturesSet::Index::HAS_BB_TRANSFORM, true);
        }

        /// \brief Transform routine
        void run_on_function(TransformContext&, Function<Img>*) override { }

        /// \brief Transform zasm node
        void run_on_node(TransformContext&, Function<Img>*, zasm::Node*) override { }

        /// \brief Transform analysis insn
        void run_on_insn(TransformContext&, Function<Img>*, analysis::insn_t*) override { }
    };

    /// \brief Node obfuscation transform.
    /// Same as `FunctionTransform`, but it discards bb/func/insn transforms instead.
    /// \tparam Img
    template <pe::any_image_t Img>
    class NodeTransform : public Transform<Img> {
    public:
        friend Transform<Img>;

        /// \brief Callback that initializes `features_set_`
        void init_features() override {
            this->feature(TransformFeaturesSet::Index::HAS_NODE_TRANSFORM, true);
        }

        /// \brief Transform routine
        void run_on_function(TransformContext&, Function<Img>*) override { }

        /// \brief Transform basic block
        void run_on_bb(TransformContext&, Function<Img>*, analysis::bb_t*) override { }

        /// \brief Transform analysis insn
        void run_on_insn(TransformContext&, Function<Img>*, analysis::insn_t*) override { }
    };

    /// \brief Instruction obfuscation transform.
    /// Same as `FunctionTransform`, but it discards bb/func/node transforms instead.
    /// \tparam Img
    template <pe::any_image_t Img>
    class InstructionTransform : public Transform<Img> {
    public:
        friend Transform<Img>;

        /// \brief Callback that initializes `features_set_`
        void init_features() override {
            this->feature(TransformFeaturesSet::Index::HAS_INSN_TRANSFORM, true);
        }

        /// \brief Transform routine
        void run_on_function(TransformContext&, Function<Img>*) override { }

        /// \brief Transform basic block
        void run_on_bb(TransformContext&, Function<Img>*, analysis::bb_t*) override { }

        /// \brief Transform zasm node
        void run_on_node(TransformContext&, Function<Img>*, zasm::Node*) override { }
    };
} // namespace obfuscator
```

`src/lib/obfuscator/transforms/transforms/bogus_control_flow.hpp`:

```hpp
#pragma once
#include "mathop/mathop.hpp"
#include "obfuscator/transforms/scheduler.hpp"
#include "obfuscator/transforms/transforms/util/bcf.hpp"
#include "obfuscator/transforms/transforms/util/opaque_predicates.hpp"

namespace obfuscator::transforms {
    template <pe::any_image_t Img>
    class BogusControlFlow final : public FunctionTransform<Img> {
    public:
        enum Var {
            MODE = 0,
            EXPR_SIZE = 1,
        };
        enum Mode {
            OPAQUE_PREDICATES = 0,
            RANDOM_PREDICATES = 1,
        };

        /// \brief Optional callback that initializes config variables
        void init_config() override {
            auto& mode = this->new_var(Var::MODE, "mode", false, TransformConfig::Var::Type::PER_FUNCTION, 1);
            mode.short_description(std::format("opaque predicates (+tamper) - {} || random predicates - {}", static_cast<int>(Mode::OPAQUE_PREDICATES),
                                               static_cast<int>(Mode::RANDOM_PREDICATES)));

            auto& expr_size = this->new_var(Var::EXPR_SIZE, "expr_size", false, TransformConfig::Var::Type::PER_FUNCTION, 15);
            expr_size.short_description("used only if mode is set to RANDOM_PREDICATES");
        }

        /// \brief Transform function
        /// \param ctx Transform context
        /// \param function Routine that it should transform
        void run_on_function(TransformContext& ctx, Function<Img>* function) override {
            auto mode = static_cast<Mode>(this->template get_var_value<int>(Var::MODE));
            assert(mode == Mode::OPAQUE_PREDICATES || mode == Mode::RANDOM_PREDICATES);

            auto expr_size = this->template get_var_value<int>(Var::EXPR_SIZE);
            assert(expr_size > 0);

            /// Iterating over the basic blocks
            for (auto& bb : function->bb_storage->temp_copy()) {
                /// We aren't modifying BBs with no successors
                if (bb->successors.empty()) {
                    continue;
                }

                /// Check chance
                if (!rnd::chance(ctx.shared_config.chance())) {
                    continue;
                }

                /// Generating a BCF stub
                transform_util::generate_bogus_confrol_flow<Img>(
                    function, bb.get(),
                    [&](const analysis::bb_t* new_bb) -> void {
                        /// Tamper data if needed
                        switch (mode) { // NOLINT
                        case Mode::OPAQUE_PREDICATES:
                            tamper_instructions(function, new_bb);
                            break;
                        default:
                            break;
                        }
                    },
                    [&](zasm::x86::Assembler* assembler, zasm::Label successor_label, zasm::Label dead_branch_label,
                        analysis::VarAlloc<Img>* var_alloc) -> void {
                        /// Generate predicate
                        switch (mode) {
                        case Mode::OPAQUE_PREDICATES:
                            transform_util::generate_opaque_predicate(assembler, successor_label, dead_branch_label, var_alloc);
                            break;
                        case Mode::RANDOM_PREDICATES:
                            gen_random_predicate(assembler, successor_label, dead_branch_label, *var_alloc, expr_size);
                            break;
                        default:
                            assert(false);
                            break;
                        }
                    });
            }
        }

    private:
        static void tamper_instructions(Function<Img>* function, const analysis::bb_t* bb) {
            /// Iterating over the copied instructions
            for (const auto& insn : bb->instructions) {
                /// Skip instructions that affect IP
                if (easm::affects_ip(*insn->ref)) {
                    continue;
                }

                /// Iterate over the operands
                for (std::size_t i = 0; i < insn->ref->getOperandCount(); ++i) {
                    /// Tamper mem
                    if (auto* op_mem = insn->ref->template getOperandIf<zasm::Mem>(i)) {
                        if (auto base = op_mem->getBase(); base.isValid()) {
                            op_mem->setBase(function->lru_reg.get_for_bits(base.getBitSize(function->machine_mode), true));
                        }
                        if (op_mem->getDisplacement()) {
                            op_mem->setDisplacement(rnd::number<std::int8_t>());
                        }
                    }

                    /// Tamper reg
                    if (const auto* op_reg = insn->ref->template getOperandIf<zasm::Reg>(i)) {
                        insn->ref->setOperand(i, function->lru_reg.get_for_bits(op_reg->getBitSize(function->machine_mode), true));
                    }

                    /// Tamper imm
                    if (auto* op_imm = insn->ref->template getOperandIf<zasm::Imm>(i)) {
                        op_imm->setValue(rnd::number<std::int8_t>(0, 4));
                    }
                }
            }
        }

        static void gen_random_predicate(zasm::x86::Assembler* as, const zasm::Label successor_label, const zasm::Label dead_branch_label,
                                         analysis::VarAlloc<Img>& var_alloc, const std::size_t expr_size) {
            /// Generate the expr, alloc x
            auto expr = mathop::ExpressionGenerator::get().generate(zasm::BitSize::_32, expr_size);
            auto lreg = var_alloc.get_gp32_lo(true);

            /// Push x, lift expr
            var_alloc.push(as);
            expr.lift_revert(as, lreg);

            /// Compare with random result, doesn't really matter
            as->cmp(lreg, zasm::Imm(rnd::number<std::int16_t>()));
            var_alloc.pop(as);

            /// Two semantically identical branches
            as->jz(dead_branch_label);
            as->jmp(successor_label);
        }
    };
} // namespace obfuscator::transforms

```

`src/lib/obfuscator/transforms/transforms/constant_crypt.hpp`:

```hpp
#pragma once
#include "mathop/mathop.hpp"
#include "obfuscator/transforms/scheduler.hpp"
#include "obfuscator/transforms/transforms/util/anti_decompilers.hpp"

namespace obfuscator::transforms {
    template <pe::any_image_t Img>
    class ConstantCrypt final : public BBTransform<Img> {
    public:
        enum Var {
            EXPR_SIZE = 0
        };

        /// \brief Optional callback that initializes config variables
        void init_config() override {
            this->new_var(Var::EXPR_SIZE, "expr_size", false, TransformConfig::Var::Type::PER_FUNCTION, 5);
        }

        void transform_insn(const TransformContext& ctx, Function<Img>* function, analysis::insn_t* insn) const {
            /// Ignore relocated stuff
            if (insn->reloc.type == analysis::insn_reloc_t::e_type::HEADER) {
                return;
            }

            /// Don't really feel like messing around with something that affects IP
            if (easm::affects_ip(*insn->ref)) {
                return;
            }

            /// Looking up for immediate operands
            auto imm_op_index = insn->find_operand_index_if<zasm::Imm>();
            if (!imm_op_index.has_value()) {
                return;
            }
            const auto* imm_op = insn->ref->getOperandIf<zasm::Imm>(imm_op_index.value());

            /// Get its value, bitsize
            const auto imm_value = imm_op->value<std::uint64_t>();
            const auto imm_bitsize = easm::get_operand_size(function->machine_mode, insn->ref, 0).value_or(imm_op->getBitSize());

            /// Export all registers and push them to the LRU blacklist
            for (auto reg : easm::get_all_registers(*insn->ref)) {
                function->lru_reg.blacklist(reg.getId());
            }
            [[maybe_unused]] auto cleaner = function->lru_reg.auto_cleaner();

            /// Alloc some variables
            auto var_alloc = function->var_alloc();
            auto var_1 = var_alloc.get_for_bits(imm_bitsize);

            /// Set cursor
            auto as_opt = function->cursor->before(insn->node_ref);
            if (!as_opt.has_value()) {
                return;
            }
            auto as = *as_opt;

            /// Detect sp-related things before we lift our stuff
            std::optional<zasm::Mem*> sp_mem = std::nullopt;
            if (easm::affects_sp(function->machine_mode, *insn->ref)) {
                sp_mem = std::make_optional(insn->find_operand_if<zasm::Mem>());

                /// Uh oh, we don't know how to process other stuff (fixme)
                if (*sp_mem == nullptr || //
                    !easm::is_sp(function->machine_mode, (*sp_mem)->getBase())) {
                    // logger::warn("constant_crypt: not sure how to process SP at {:#x}", insn->rva.value_or(0));
                    return;
                }
            }

            /// Check the chance
            if (!rnd::chance(ctx.shared_config.chance())) {
                return;
            }

            /// Remember nodes where we should push/pop stuff
            auto* push_at = as->getCursor();
            auto* pop_at = insn->node_ref;

            /// Generate decryption
            const auto expr_size = this->template get_var_value<int>(Var::EXPR_SIZE);
            assert(expr_size > 0);
            auto expression = mathop::ExpressionGenerator::get().generate(imm_bitsize, expr_size);
            auto evaluated = expression.emulate(mathop::imm_for_bits(imm_bitsize, imm_value));

            /// Setup dst register and lift decryption
            as->mov(var_1, mathop::imm_to_zasm(evaluated));

            /// Lift decryption
            auto decryption_start_at = as->getCursor();
            expression.lift_revert(as, var_1);

            /// Remember the last decryption node
            auto decryption_ends_at = as->getCursor();

            /// Prevent symbolic execution
            transform_util::anti_symbolic_execution(var_alloc, imm_bitsize, function->program.get(), as, decryption_start_at, decryption_ends_at);

            /// Assert stuff before shit would hit the fan
            if (*imm_op_index == 1) {
                easm::assert_operand_size(function->machine_mode, insn->ref, 0, var_1);
                easm::assert_operand_used_reg(function->machine_mode, insn->ref, 0, var_1);
            }

            /// Update stack offset, if needed, because we're gonna change its layout with our pushes
            if (sp_mem.has_value()) {
                (*sp_mem)->setDisplacement((*sp_mem)->getDisplacement() + var_alloc.stack_size());
                logger::debug("constant_crypt: updated sp displacement at {:#x}", *insn->rva);
            }

            /// Swap the operand
            insn->ref->setOperand(*imm_op_index, var_1);

            /// Allocate vars on stack
            as = *function->cursor->after(push_at);
            var_alloc.push(as);
            var_alloc.push_flags(as);

            /// Pop flags if needed
            as = *function->cursor->before(pop_at);
            var_alloc.pop_flags(as);

            /// Deallocate vars from stack
            as = *function->cursor->after(pop_at);
            var_alloc.pop(as);
        }

        /// \brief Transform analysis insn
        /// \param ctx Transform context
        /// \param function Routine that it should transform
        /// \param bb BB that it should transform
        void run_on_bb(TransformContext& ctx, Function<Img>* function, analysis::bb_t* bb) override {
            for (auto& insn : bb->temp_insns_copy()) {
                transform_insn(ctx, function, insn.get());
            }
        }
    };
} // namespace obfuscator::transforms

```

`src/lib/obfuscator/transforms/transforms/decomp_break.hpp`:

```hpp
#pragma once
#include "obfuscator/transforms/scheduler.hpp"
#include "obfuscator/transforms/transforms/util/bcf.hpp"
#include "util/random.hpp"

namespace obfuscator::transforms {
    namespace detail::anti_ida_decomp {
        /// For some reason, zydis yells at me when i try to serialize it manually :shrug:
        constexpr std::array<std::uint8_t, 4> kEnterStub = {
            0xC8, 0xFF, 0xFF, 0xFF // enter 0xFFFF, 0xFF
        };
    } // namespace detail::anti_ida_decomp

    template <pe::any_image_t Img>
    class DecompBreak final : public BBTransform<Img> {
    public:
        enum Var : std::size_t {
            BREAK_IDA = 0,
            BREAK_GHIDRA = 1,
        };

        /// \brief Optional callback that initializes config variables
        void init_config() override {
            this->ida = &this->new_var(Var::BREAK_IDA, "ida", false, TransformConfig::Var::Type::PER_FUNCTION, true);
            this->ghidra = &this->new_var(Var::BREAK_GHIDRA, "ghidra", false, TransformConfig::Var::Type::PER_FUNCTION, true);
        }

        /// \brief Transform zasm node
        /// \param function Routine that it should transform
        /// \param bb BB that it should transform
        void run_on_bb(TransformContext&, Function<Img>* function, analysis::bb_t* bb) override {
            /// No successors?
            if (bb->successors.empty()) {
                return;
            }

            /// Get the config vars
            const bool ghidra_opt = this->ghidra->template value<bool>();
            const bool ida_opt = this->ida->template value<bool>();
            assert(ghidra_opt || ida_opt);

            /// Generate an opaque predicate and insert ENTER -1 somewhere over there
            transform_util::generate_bogus_confrol_flow<Img>(
                function, bb,
                [&](analysis::bb_t* new_bb) -> void {
                    /// Set cursor somewhere in the BB (-2 because i don't feel like placing it after the last insn)
                    auto* as = *function->cursor->after(
                        new_bb->node_at(rnd::number<size_t>(static_cast<size_t>(0), std::max(new_bb->size(), static_cast<size_t>(2)) - 2)));

                    /// Make the choice between ghidra and ida
                    Var mode = ida_opt ? Var::BREAK_IDA : Var::BREAK_GHIDRA;
                    if (ida_opt && ghidra_opt) {
                        mode = rnd::or_(Var::BREAK_IDA, Var::BREAK_GHIDRA);
                    }

                    /// Choose the mode and insert needed stuff
                    switch (mode) {
                    case Var::BREAK_IDA: {
                        as->embed(detail::anti_ida_decomp::kEnterStub.data(), detail::anti_ida_decomp::kEnterStub.size());
                        break;
                    }
                    case Var::BREAK_GHIDRA: {
                        auto var_alloc = function->var_alloc();
                        auto var_1 = var_alloc.get(true);
                        auto var_2 = var_alloc.get(true);

                        as->mov(var_1, pe::is_x64_v<Img> ? zasm::Imm(static_cast<std::int64_t>(-1)) : zasm::Imm(static_cast<std::int32_t>(-1L)));
                        as->lea(var_1, easm::ptr<Img>(var_1));
                        as->mov(var_2, easm::ptr<Img>(var_1));
                        new_bb->push_last_N_insns(as, function->bb_provider.get(), 3);
                        break;
                    }
                    default:
                        assert(false);
                        break;
                    }
                },
                [&](zasm::x86::Assembler* assembler, zasm::Label successor_label, zasm::Label dead_branch_label,
                    analysis::VarAlloc<Img>* var_alloc) -> void {
                    transform_util::generate_opaque_predicate(assembler, successor_label, dead_branch_label, var_alloc); //
                });
        }

    private:
        TransformConfig::Var* ida = nullptr;
        TransformConfig::Var* ghidra = nullptr;
    };
} // namespace obfuscator::transforms

```

`src/lib/obfuscator/transforms/transforms/substitution.hpp`:

```hpp
#pragma once
#include "obfuscator/transforms/scheduler.hpp"
#include "util/random.hpp"

namespace obfuscator::transforms {
    template <pe::any_image_t Img>
    class Substitution final : public BBTransform<Img> {
        /// Math operations replacement table
        using Cbk = std::function<void(Function<Img>*, analysis::insn_t*)>;
        std::unordered_map<std::uint16_t, std::vector<Cbk>> replacements;

        /// Temporary operand holder for substitutions
        struct tmp_op_holder_t {
            /// Constructor that captures the desired operands
            tmp_op_holder_t(zasm::x86::Assembler* assembler, analysis::VarAlloc<Img>& var_alloc, const analysis::insn_t* insn, const zasm::Operand& operand,
                            const std::optional<zasm::Operand>& other_operand = std::nullopt)
                : var_alloc(var_alloc), operand(operand), assembler(assembler) {
                /// No need to alloc anything
                if (operand.holds<zasm::Reg>()) {
                    return;
                }

                /// Get the bit size
                std::optional<zasm::BitSize> bitsize = std::nullopt;
                if (other_operand.has_value()) {
                    bitsize = easm::get_operand_size(insn->bb_ref->machine_mode, *other_operand);
                }
                bitsize = bitsize.value_or(operand.getBitSize(insn->bb_ref->machine_mode));
                assert(bitsize.has_value());

                /// Alloc sym var
                sym_var = this->var_alloc.get_for_bits(*bitsize, true);

                /// Push and setup sym var
                this->var_alloc.push(assembler);
                assembler->emit(zasm::Instruction(ZYDIS_MNEMONIC_MOV, 2, {sym_var->reg, operand}));

                /// Swap operand value
                this->operand = sym_var->reg;
            }

            /// Destructor that should pop sym vars if needed
            ~tmp_op_holder_t() {
                /// No need to pop anything
                if (!sym_var.has_value()) {
                    return;
                }

                /// Pop the vars from stack
                /// \note @es3n1n: We are reusing the same assembler pointer, hopefully its cursor would be
                /// set to where we should pop the vars :pray:
                var_alloc.pop(assembler);
            }

            /// Var alloc reference
            analysis::VarAlloc<Img>& var_alloc;
            /// Operand holder
            zasm::Operand operand;
            /// Stored symbolic var
            std::optional<analysis::SymVar> sym_var = std::nullopt;
            /// Assembler reference
            zasm::x86::Assembler* assembler;
        };

    public:
        /// \brief Optional callback that initializes config variables
        void init_config() override {
            /// x + y => x - (-y)
            replacements[ZYDIS_MNEMONIC_ADD].emplace_back([](Function<Img>* func, analysis::insn_t* insn) -> void {
                auto op1 = insn->ref->getOperand<zasm::Operand>(0);
                auto op2 = insn->ref->getOperand<zasm::Operand>(1);

                auto* as = *func->cursor->instead_of(insn->node_ref);
                auto var_alloc = func->var_alloc();
                auto op2_wrap = tmp_op_holder_t(as, var_alloc, insn, op2, op1);

                // x - (-y)
                as->emit(zasm::Instruction(ZYDIS_MNEMONIC_NEG, 1, {op2_wrap.operand}));
                as->emit(zasm::Instruction(ZYDIS_MNEMONIC_SUB, 2, {op1, op2_wrap.operand}));
            });

            /// x - y => x + (-y)
            replacements[ZYDIS_MNEMONIC_SUB].emplace_back([](Function<Img>* func, analysis::insn_t* insn) -> void {
                auto op1 = insn->ref->getOperand<zasm::Operand>(0);
                auto op2 = insn->ref->getOperand<zasm::Operand>(1);

                auto* as = *func->cursor->instead_of(insn->node_ref);
                auto var_alloc = func->var_alloc();
                auto op2_wrap = tmp_op_holder_t(as, var_alloc, insn, op2, op1);

                // x + (-y)
                as->emit(zasm::Instruction(ZYDIS_MNEMONIC_NEG, 1, {op2_wrap.operand}));
                as->emit(zasm::Instruction(ZYDIS_MNEMONIC_ADD, 2, {op1, op2_wrap.operand}));
            });

            /// x & y => (x ^ ~y) & x
            replacements[ZYDIS_MNEMONIC_AND].emplace_back([](Function<Img>* func, analysis::insn_t* insn) -> void {
                auto op1 = insn->ref->getOperand<zasm::Operand>(0);
                auto op2 = insn->ref->getOperand<zasm::Operand>(1);

                auto* as = *func->cursor->instead_of(insn->node_ref);
                auto var_alloc = func->var_alloc();
                auto op2_wrap = tmp_op_holder_t(as, var_alloc, insn, op2, op1);

                /// ~y
                as->emit(zasm::Instruction(ZYDIS_MNEMONIC_NOT, 1, {op2_wrap.operand}));

                /// ~y ^= x
                as->emit(zasm::Instruction(ZYDIS_MNEMONIC_XOR, 2, {op2_wrap.operand, op1}));

                /// & x
                as->emit(zasm::Instruction(ZYDIS_MNEMONIC_AND, 2, {op2_wrap.operand, op1}));

                /// mov to x
                as->emit(zasm::Instruction(ZYDIS_MNEMONIC_AND, 2, {op1, op2_wrap.operand}));
            });
        }

        /// \brief Transform zasm node
        /// \param function Routine that it should transform
        /// \param bb BB that it should transform
        void run_on_bb(TransformContext&, Function<Img>* function, analysis::bb_t* bb) override {
            /// Iterating over the instructions
            for (auto& insn : bb->temp_insns_copy()) {
                if (easm::affects_sp(function->machine_mode, *insn->ref)) {
                    continue;
                }

                auto it = replacements.find(insn->ref->getMnemonic().value());
                if (it == std::end(replacements)) {
                    continue;
                }

                auto& cb = rnd::item(it->second);
                cb(function, insn.get());
            }
        }
    };
} // namespace obfuscator::transforms

```

`src/lib/obfuscator/transforms/transforms/util/anti_decompilers.hpp`:

```hpp
#pragma once
#include "analysis/analysis.hpp"
#include "analysis/var_alloc/var_alloc.hpp"

namespace obfuscator::transform_util {
    /// \brief Prevent decompilers from symbolic execution of our stubs, also trigger a bug in
    /// binja decompiler
    /// \tparam Img X64 or X86 image
    /// \param var_alloc Var allocator
    /// \param imm_bit_size Imm bit size
    /// \param program zasm Program
    /// \param assembler zasm Assembler
    /// \param first first node
    /// \param last last node
    template <pe::any_image_t Img>
    void anti_symbolic_execution(analysis::VarAlloc<Img>& var_alloc, const zasm::BitSize imm_bit_size, zasm::Program* program,
                                 zasm::x86::Assembler* assembler, zasm::Node* first, zasm::Node* last) {
        /// Set cursor at the beginning
        assembler->setCursor(first);

        /// Decl some allocated vars that we could use later
        /// Set to nullopt for now since we aren't sure if we'd need them yet
        std::optional<analysis::SymVar> xchg_enc_holder = std::nullopt;
        std::optional<analysis::SymVar> adc_const_holder = std::nullopt;
        std::optional<analysis::SymVar> cf_val_holder = std::nullopt;

        /// Initializer util
        auto init_vars = [&]() -> void {
            if (xchg_enc_holder.has_value()) {
                return;
            }

            /// Init vars
            xchg_enc_holder = var_alloc.get_for_bits(imm_bit_size);
            adc_const_holder = var_alloc.get_for_bits(imm_bit_size);
            cf_val_holder = var_alloc.get_for_bits(imm_bit_size);

            /// Load empty val for the CF value holder
            assembler->push(zasm::Imm(0));
            assembler->pop(cf_val_holder->root_gp());

            /// Save the cf value
            assembler->adc(cf_val_holder->root_gp(), cf_val_holder->root_gp());
        };

        /// Iterating over the nodes
        for (auto cur = assembler->getCursor(); cur != nullptr && cur != last; cur = cur->getNext()) {
            /// Set the cursor, get the node
            auto insn = cur->getIf<zasm::Instruction>();

            /// Not an instruction
            if (insn == nullptr) {
                continue;
            }

            /// Get the imm
            auto imm = insn->getOperandIf<zasm::Imm>(1);
            if (imm == nullptr) {
                continue;
            }

            /// \fixme
            if (imm->getBitSize() == zasm::BitSize::_64) {
                continue;
            }

            /// For now let's modify only `xxx reg, 0x1337` instructions
            if (insn->getOperandIf<zasm::Reg>(0) == nullptr) {
                continue;
            }

            /// Set the cursor
            assembler->setCursor(cur->getPrev());

            /// Get some decryption keys
            const auto adc_key = rnd::number<std::int8_t>(0, 55);
            constexpr auto adc_cf_val = 1;

            /// Operand decryption with xchg (unsupported in ida)
            auto xchg_reencrypt_var = [&]<typename Ty>(Ty) -> void {
                /// Alloc some stack frame where the decrypted var would be stored at
                assembler->push(zasm::Imm(rnd::number<std::int16_t>()));
                /// Push encrypted constant
                assembler->mov(xchg_enc_holder->root_gp(), zasm::Imm(imm->value<Ty>() - (adc_key + adc_cf_val)));
                assembler->push(xchg_enc_holder->root_gp());
                /// Pop the encrypted val
                assembler->pop(xchg_enc_holder->root_gp());
                /// Push it on stack with xchg operation
                assembler->xchg(easm::ptr<Img>(easm::sp_for_arch<Img>()), xchg_enc_holder->root_gp());
                /// Load to register
                assembler->pop(xchg_enc_holder->root_gp());
            };

            /// Operand decryption with adc (unsupported in binja)
            auto adc_reencrypt_var = [&]<typename Ty>(Ty) -> void {
                /// Load the adc key
                assembler->push(zasm::Imm(adc_key));
                assembler->pop(adc_const_holder->root_gp());

                /// ADC
                assembler->stc(); // set CF to 1 so that it will add xchg_val + addc_val + 1 (binja doesn't track this)
                assembler->adc(*xchg_enc_holder, *adc_const_holder);
            };

            /// Invoke both
            auto reencrypt_var = [&]<typename Ty>(Ty) -> void {
                /// Init vars
                init_vars();
                /// Reencrypt stuff
                xchg_reencrypt_var(Ty{});
                adc_reencrypt_var(Ty{});
                /// Swap the operand
                insn->setOperand(1, *xchg_enc_holder);
            };

            /// Handle bit sizes (looks sketchy)
            /// \todo @es3n1n: some util that would do this
            switch (imm_bit_size) {
            case zasm::BitSize::_8:
                reencrypt_var(std::int8_t{});
                break;
            case zasm::BitSize::_16:
                reencrypt_var(std::int16_t{});
                break;
            case zasm::BitSize::_32:
                reencrypt_var(std::int32_t{});
                break;
            case zasm::BitSize::_64:
                reencrypt_var(std::int64_t{});
                break;
            default:
                break;
            }
            // break;
        }

        /// Hm
        if (!cf_val_holder.has_value()) [[unlikely]] {
            return;
        }

        /// Check the stored CF value
        const auto if_set = program->createLabel();
        assembler->test(cf_val_holder->root_gp(), cf_val_holder->root_gp());

        /// Bind the label and set cursor before the node
        assembler->bind(if_set);
        assembler->setCursor(assembler->getCursor()->getPrev());

        /// Clear CF if needed
        assembler->jnz(if_set);
        assembler->clc();
    }
} // namespace obfuscator::transform_util

```

`src/lib/obfuscator/transforms/transforms/util/bcf.hpp`:

```hpp
#pragma once
#include "analysis/analysis.hpp"
#include "analysis/var_alloc/var_alloc.hpp"
#include "obfuscator/function.hpp"

namespace obfuscator::transform_util {
    /// \brief Generate a new copy of the BB successor and make a [opaque] predicate
    /// \tparam Img X64 or X86 Image
    /// \param function Obfuscator function ptr
    /// \param bb BB ptr
    /// \param post_generation_callback Post generation callback (to tamper instructions or something)
    /// \param predicate_generator Predicate generator
    template <pe::any_image_t Img>
    void generate_bogus_confrol_flow(Function<Img>* function, analysis::bb_t* bb, const std::function<void(analysis::bb_t*)>& post_generation_callback,
                                     std::function<void(zasm::x86::Assembler*, zasm::Label, zasm::Label, analysis::VarAlloc<Img>*)> predicate_generator) {

        /// Get the last non-jmp insn
        auto last_insn = bb->last_non_jmp_insn(function->program.get(), true);

        /// Get the successor
        auto successor = last_insn->linear_successor();

        /// Place successor start label
        auto successor_label = function->program->createLabel();
        auto* as = *function->cursor->before(successor->node_at(0));
        as->bind(successor_label);

        /// Crete the label that would be placed at the beginning of the "dead" branch
        auto dummy_bb_label = function->program->createLabel();

        /// Get the var alloc
        auto var_alloc = function->var_alloc();

        /// Temporary disable oserver
        function->observer->stop();

        /// Setup dead branch
        as = *function->cursor->after(last_insn->node_ref);
        as->bind(dummy_bb_label);
        auto label_node = as->getCursor();

        /// Create dead branch
        auto new_bb = function->bb_storage->copy_bb(successor, as, function->program.get(), function->bb_provider.get());
        new_bb->push_label(label_node, function->bb_provider.get());

        /// Tamper instructions, if needed
        post_generation_callback(new_bb.get());

        /// Re-enable observer
        function->observer->start();

        /// Set the cursor, generate predicate
        as = *function->cursor->after(last_insn->node_ref);
        predicate_generator(as, successor_label, dummy_bb_label, &var_alloc);

        /// Update successors, predecessors
        /// \fixme @es3n1n: Temporary commented out, uncomment as soon as the fixme in observer is fixed
        // bb->successors.emplace_back(new_bb);
        // new_bb->predecessors.emplace_back(bb);
    }
} // namespace obfuscator::transform_util
```

`src/lib/obfuscator/transforms/transforms/util/opaque_predicates.hpp`:

```hpp
#pragma once
#include "analysis/analysis.hpp"
#include "analysis/var_alloc/var_alloc.hpp"

namespace obfuscator::transform_util {
    /// \brief
    /// \param as Zasm assembler ptr
    /// \param successor_label Successor
    /// \param dead_branch_label Dead branch
    /// \param var_alloc_ptr Var allocator
    template <pe::any_image_t Img>
    void generate_opaque_predicate(zasm::x86::Assembler* as, const zasm::Label successor_label, const zasm::Label dead_branch_label,
                                   analysis::VarAlloc<Img>* var_alloc_ptr) {
        /// I don't feel like changing these stubs -- fixme
        auto& var_alloc = *var_alloc_ptr;

        /// Alloc X
        auto x = var_alloc.get_gp32_lo();
        var_alloc.push(as);

        /// Mov random var from stack to x
        as->mov(x, zasm::x86::dword_ptr(easm::sp_for_arch<Img>(), rnd::number<uint32_t>(0, 0x250)));

        /// \note @es3n1n: Generated using `scripts/opaque_predicates_expr_gen`
        switch (rnd::number<std::size_t>(0, 66)) {
        // ((x << 16) & 6) == 0
        case 0: {
            as->shl(x, zasm::Imm(16));
            as->and_(x, zasm::Imm(6));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((x & 16) & 7) == 0
        case 1: {
            as->and_(x, zasm::Imm(16));
            as->and_(x, zasm::Imm(7));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // (((x + 2) << 4) & 6) == 0
        case 2: {
            as->add(x, zasm::Imm(2));
            as->shl(x, zasm::Imm(4));
            as->and_(x, zasm::Imm(6));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // (((x + 6) & 3) & 12) == 0
        case 3: {
            as->add(x, zasm::Imm(6));
            as->and_(x, zasm::Imm(3));
            as->and_(x, zasm::Imm(12));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // (((x << 9) << 1) & 4) == 0
        case 4: {
            as->shl(x, zasm::Imm(9));
            as->shl(x, zasm::Imm(1));
            as->and_(x, zasm::Imm(4));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // (((x << 3) & 4) + 4) == 4
        case 5: {
            as->shl(x, zasm::Imm(3));
            as->and_(x, zasm::Imm(4));
            as->add(x, zasm::Imm(4));
            as->cmp(x, zasm::Imm(4));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // (((x << 1) & 1) << 9) == 0
        case 6: {
            as->shl(x, zasm::Imm(1));
            as->and_(x, zasm::Imm(1));
            as->shl(x, zasm::Imm(9));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // (((x << 16) & 6) & 6) == 0
        case 7: {
            as->shl(x, zasm::Imm(16));
            as->and_(x, zasm::Imm(6));
            as->and_(x, zasm::Imm(6));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // (((x << 2) & 2) ^ 2) == 2
        case 8: {
            as->shl(x, zasm::Imm(2));
            as->and_(x, zasm::Imm(2));
            as->xor_(x, zasm::Imm(2));
            as->cmp(x, zasm::Imm(2));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // (((x << 9) ^ 11) & 11) == 11
        case 9: {
            as->shl(x, zasm::Imm(9));
            as->xor_(x, zasm::Imm(11));
            as->and_(x, zasm::Imm(11));
            as->cmp(x, zasm::Imm(11));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // (((x >> 10) << 16) & 6) == 0
        case 10: {
            as->shr(x, zasm::Imm(10));
            as->shl(x, zasm::Imm(16));
            as->and_(x, zasm::Imm(6));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // (((x >> 6) & 11) & 4) == 0
        case 11: {
            as->shr(x, zasm::Imm(6));
            as->and_(x, zasm::Imm(11));
            as->and_(x, zasm::Imm(4));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // (((x & 1) + 16) & 2) == 0
        case 12: {
            as->and_(x, zasm::Imm(1));
            as->add(x, zasm::Imm(16));
            as->and_(x, zasm::Imm(2));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // (((x & 11) << 4) & 6) == 0
        case 13: {
            as->and_(x, zasm::Imm(11));
            as->shl(x, zasm::Imm(4));
            as->and_(x, zasm::Imm(6));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // (((x & 4) & 3) + 16) == 16
        case 14: {
            as->and_(x, zasm::Imm(4));
            as->and_(x, zasm::Imm(3));
            as->add(x, zasm::Imm(16));
            as->cmp(x, zasm::Imm(16));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // (((x & 4) & 2) << 12) == 0
        case 15: {
            as->and_(x, zasm::Imm(4));
            as->and_(x, zasm::Imm(2));
            as->shl(x, zasm::Imm(12));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // (((x & 11) & 3) & 12) == 0
        case 16: {
            as->and_(x, zasm::Imm(11));
            as->and_(x, zasm::Imm(3));
            as->and_(x, zasm::Imm(12));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // (((x & 2) & 1) ^ 2) == 2
        case 17: {
            as->and_(x, zasm::Imm(2));
            as->and_(x, zasm::Imm(1));
            as->xor_(x, zasm::Imm(2));
            as->cmp(x, zasm::Imm(2));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // (((x & 8) ^ 1) & 2) == 0
        case 18: {
            as->and_(x, zasm::Imm(8));
            as->xor_(x, zasm::Imm(1));
            as->and_(x, zasm::Imm(2));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // (((x & 8) - 14) & 3) == 2
        case 19: {
            as->and_(x, zasm::Imm(8));
            as->sub(x, zasm::Imm(14));
            as->and_(x, zasm::Imm(3));
            as->cmp(x, zasm::Imm(2));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // (((x ^ 6) << 9) & 12) == 0
        case 20: {
            as->xor_(x, zasm::Imm(6));
            as->shl(x, zasm::Imm(9));
            as->and_(x, zasm::Imm(12));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // (((x ^ 8) & 2) & 16) == 0
        case 21: {
            as->xor_(x, zasm::Imm(8));
            as->and_(x, zasm::Imm(2));
            as->and_(x, zasm::Imm(16));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // (((x - 15) << 16) & 6) == 0
        case 22: {
            as->sub(x, zasm::Imm(15));
            as->shl(x, zasm::Imm(16));
            as->and_(x, zasm::Imm(6));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // (((x - 10) & 3) & 12) == 0
        case 23: {
            as->sub(x, zasm::Imm(10));
            as->and_(x, zasm::Imm(3));
            as->and_(x, zasm::Imm(12));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x + 3) + 4) << 6) & 10) == 0
        case 24: {
            as->add(x, zasm::Imm(3));
            as->add(x, zasm::Imm(4));
            as->shl(x, zasm::Imm(6));
            as->and_(x, zasm::Imm(10));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x + 1) + 3) & 2) & 12) == 0
        case 25: {
            as->add(x, zasm::Imm(1));
            as->add(x, zasm::Imm(3));
            as->and_(x, zasm::Imm(2));
            as->and_(x, zasm::Imm(12));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x + 9) << 5) + 1) & 2) == 0
        case 26: {
            as->add(x, zasm::Imm(9));
            as->shl(x, zasm::Imm(5));
            as->add(x, zasm::Imm(1));
            as->and_(x, zasm::Imm(2));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x + 2) << 15) << 2) & 2) == 0
        case 27: {
            as->add(x, zasm::Imm(2));
            as->shl(x, zasm::Imm(15));
            as->shl(x, zasm::Imm(2));
            as->and_(x, zasm::Imm(2));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x + 6) << 11) & 8) + 2) == 2
        case 28: {
            as->add(x, zasm::Imm(6));
            as->shl(x, zasm::Imm(11));
            as->and_(x, zasm::Imm(8));
            as->add(x, zasm::Imm(2));
            as->cmp(x, zasm::Imm(2));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x + 4) << 2) & 3) << 10) == 0
        case 29: {
            as->add(x, zasm::Imm(4));
            as->shl(x, zasm::Imm(2));
            as->and_(x, zasm::Imm(3));
            as->shl(x, zasm::Imm(10));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x + 1) << 1) & 1) >> 16) == 0
        case 30: {
            as->add(x, zasm::Imm(1));
            as->shl(x, zasm::Imm(1));
            as->and_(x, zasm::Imm(1));
            as->shr(x, zasm::Imm(16));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x + 4) << 16) & 2) & 7) == 0
        case 31: {
            as->add(x, zasm::Imm(4));
            as->shl(x, zasm::Imm(16));
            as->and_(x, zasm::Imm(2));
            as->and_(x, zasm::Imm(7));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x + 2) << 16) & 14) ^ 15) == 15
        case 32: {
            as->add(x, zasm::Imm(2));
            as->shl(x, zasm::Imm(16));
            as->and_(x, zasm::Imm(14));
            as->xor_(x, zasm::Imm(15));
            as->cmp(x, zasm::Imm(15));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x + 15) << 4) ^ 15) & 2) == 2
        case 33: {
            as->add(x, zasm::Imm(15));
            as->shl(x, zasm::Imm(4));
            as->xor_(x, zasm::Imm(15));
            as->and_(x, zasm::Imm(2));
            as->cmp(x, zasm::Imm(2));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x + 7) >> 1) << 8) & 6) == 0
        case 34: {
            as->add(x, zasm::Imm(7));
            as->shr(x, zasm::Imm(1));
            as->shl(x, zasm::Imm(8));
            as->and_(x, zasm::Imm(6));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x + 1) >> 12) & 2) & 4) == 0
        case 35: {
            as->add(x, zasm::Imm(1));
            as->shr(x, zasm::Imm(12));
            as->and_(x, zasm::Imm(2));
            as->and_(x, zasm::Imm(4));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x + 6) & 8) + 8) & 3) == 0
        case 36: {
            as->add(x, zasm::Imm(6));
            as->and_(x, zasm::Imm(8));
            as->add(x, zasm::Imm(8));
            as->and_(x, zasm::Imm(3));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x + 3) & 3) << 8) & 10) == 0
        case 37: {
            as->add(x, zasm::Imm(3));
            as->and_(x, zasm::Imm(3));
            as->shl(x, zasm::Imm(8));
            as->and_(x, zasm::Imm(10));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x + 10) & 2) & 12) + 1) == 1
        case 38: {
            as->add(x, zasm::Imm(10));
            as->and_(x, zasm::Imm(2));
            as->and_(x, zasm::Imm(12));
            as->add(x, zasm::Imm(1));
            as->cmp(x, zasm::Imm(1));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x + 8) & 2) & 8) << 12) == 0
        case 39: {
            as->add(x, zasm::Imm(8));
            as->and_(x, zasm::Imm(2));
            as->and_(x, zasm::Imm(8));
            as->shl(x, zasm::Imm(12));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x + 1) & 1) & 16) >> 16) == 0
        case 40: {
            as->add(x, zasm::Imm(1));
            as->and_(x, zasm::Imm(1));
            as->and_(x, zasm::Imm(16));
            as->shr(x, zasm::Imm(16));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x + 15) & 3) & 2) & 1) == 0
        case 41: {
            as->add(x, zasm::Imm(15));
            as->and_(x, zasm::Imm(3));
            as->and_(x, zasm::Imm(2));
            as->and_(x, zasm::Imm(1));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x + 4) & 1) & 12) ^ 8) == 8
        case 42: {
            as->add(x, zasm::Imm(4));
            as->and_(x, zasm::Imm(1));
            as->and_(x, zasm::Imm(12));
            as->xor_(x, zasm::Imm(8));
            as->cmp(x, zasm::Imm(8));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x + 8) & 4) ^ 8) & 1) == 0
        case 43: {
            as->add(x, zasm::Imm(8));
            as->and_(x, zasm::Imm(4));
            as->xor_(x, zasm::Imm(8));
            as->and_(x, zasm::Imm(1));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x + 6) ^ 3) << 16) & 6) == 0
        case 44: {
            as->add(x, zasm::Imm(6));
            as->xor_(x, zasm::Imm(3));
            as->shl(x, zasm::Imm(16));
            as->and_(x, zasm::Imm(6));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x + 2) ^ 2) & 3) & 12) == 0
        case 45: {
            as->add(x, zasm::Imm(2));
            as->xor_(x, zasm::Imm(2));
            as->and_(x, zasm::Imm(3));
            as->and_(x, zasm::Imm(12));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x + 1) - 8) << 16) & 6) == 0
        case 46: {
            as->add(x, zasm::Imm(1));
            as->sub(x, zasm::Imm(8));
            as->shl(x, zasm::Imm(16));
            as->and_(x, zasm::Imm(6));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x + 1) - 2) & 2) & 4) == 0
        case 47: {
            as->add(x, zasm::Imm(1));
            as->sub(x, zasm::Imm(2));
            as->and_(x, zasm::Imm(2));
            as->and_(x, zasm::Imm(4));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x << 2) + 2) + 1) & 3) == 3
        case 48: {
            as->shl(x, zasm::Imm(2));
            as->add(x, zasm::Imm(2));
            as->add(x, zasm::Imm(1));
            as->and_(x, zasm::Imm(3));
            as->cmp(x, zasm::Imm(3));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x << 2) + 1) << 1) & 2) == 2
        case 49: {
            as->shl(x, zasm::Imm(2));
            as->add(x, zasm::Imm(1));
            as->shl(x, zasm::Imm(1));
            as->and_(x, zasm::Imm(2));
            as->cmp(x, zasm::Imm(2));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x << 6) + 15) & 14) + 4) == 18
        case 50: {
            as->shl(x, zasm::Imm(6));
            as->add(x, zasm::Imm(15));
            as->and_(x, zasm::Imm(14));
            as->add(x, zasm::Imm(4));
            as->cmp(x, zasm::Imm(18));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x << 9) + 3) & 7) << 12) == 12288
        case 51: {
            as->shl(x, zasm::Imm(9));
            as->add(x, zasm::Imm(3));
            as->and_(x, zasm::Imm(7));
            as->shl(x, zasm::Imm(12));
            as->cmp(x, zasm::Imm(12288));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x << 2) + 1) & 2) >> 16) == 0
        case 52: {
            as->shl(x, zasm::Imm(2));
            as->add(x, zasm::Imm(1));
            as->and_(x, zasm::Imm(2));
            as->shr(x, zasm::Imm(16));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x << 9) + 7) & 14) & 6) == 6
        case 53: {
            as->shl(x, zasm::Imm(9));
            as->add(x, zasm::Imm(7));
            as->and_(x, zasm::Imm(14));
            as->and_(x, zasm::Imm(6));
            as->cmp(x, zasm::Imm(6));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x << 16) + 3) & 3) ^ 2) == 1
        case 54: {
            as->shl(x, zasm::Imm(16));
            as->add(x, zasm::Imm(3));
            as->and_(x, zasm::Imm(3));
            as->xor_(x, zasm::Imm(2));
            as->cmp(x, zasm::Imm(1));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x << 6) + 16) & 16) - 3) == 13
        case 55: {
            as->shl(x, zasm::Imm(6));
            as->add(x, zasm::Imm(16));
            as->and_(x, zasm::Imm(16));
            as->sub(x, zasm::Imm(3));
            as->cmp(x, zasm::Imm(13));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x << 16) + 3) ^ 1) & 2) == 2
        case 56: {
            as->shl(x, zasm::Imm(16));
            as->add(x, zasm::Imm(3));
            as->xor_(x, zasm::Imm(1));
            as->and_(x, zasm::Imm(2));
            as->cmp(x, zasm::Imm(2));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x << 9) + 8) - 15) & 3) == 1
        case 57: {
            as->shl(x, zasm::Imm(9));
            as->add(x, zasm::Imm(8));
            as->sub(x, zasm::Imm(15));
            as->and_(x, zasm::Imm(3));
            as->cmp(x, zasm::Imm(1));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x << 16) << 2) + 7) & 3) == 3
        case 58: {
            as->shl(x, zasm::Imm(16));
            as->shl(x, zasm::Imm(2));
            as->add(x, zasm::Imm(7));
            as->and_(x, zasm::Imm(3));
            as->cmp(x, zasm::Imm(3));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x << 16) << 16) << 16) << 16) == 0
        case 59: {
            as->shl(x, zasm::Imm(16));
            as->shl(x, zasm::Imm(16));
            as->shl(x, zasm::Imm(16));
            as->shl(x, zasm::Imm(16));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x << 6) << 5) << 14) & 2) == 0
        case 60: {
            as->shl(x, zasm::Imm(6));
            as->shl(x, zasm::Imm(5));
            as->shl(x, zasm::Imm(14));
            as->and_(x, zasm::Imm(2));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x << 1) << 16) & 13) + 6) == 6
        case 61: {
            as->shl(x, zasm::Imm(1));
            as->shl(x, zasm::Imm(16));
            as->and_(x, zasm::Imm(13));
            as->add(x, zasm::Imm(6));
            as->cmp(x, zasm::Imm(6));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x << 1) << 3) & 1) << 2) == 0
        case 62: {
            as->shl(x, zasm::Imm(1));
            as->shl(x, zasm::Imm(3));
            as->and_(x, zasm::Imm(1));
            as->shl(x, zasm::Imm(2));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x << 16) << 16) & 1) >> 16) == 0
        case 63: {
            as->shl(x, zasm::Imm(16));
            as->shl(x, zasm::Imm(16));
            as->and_(x, zasm::Imm(1));
            as->shr(x, zasm::Imm(16));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x << 16) << 16) & 2) & 1) == 0
        case 64: {
            as->shl(x, zasm::Imm(16));
            as->shl(x, zasm::Imm(16));
            as->and_(x, zasm::Imm(2));
            as->and_(x, zasm::Imm(1));
            as->cmp(x, zasm::Imm(0));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x << 1) << 4) & 1) ^ 1) == 1
        case 65: {
            as->shl(x, zasm::Imm(1));
            as->shl(x, zasm::Imm(4));
            as->and_(x, zasm::Imm(1));
            as->xor_(x, zasm::Imm(1));
            as->cmp(x, zasm::Imm(1));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        // ((((x << 16) << 16) ^ 15) & 3) == 3
        case 66: {
            as->shl(x, zasm::Imm(16));
            as->shl(x, zasm::Imm(16));
            as->xor_(x, zasm::Imm(15));
            as->and_(x, zasm::Imm(3));
            as->cmp(x, zasm::Imm(3));
            var_alloc.pop(as);
            as->jz(successor_label);
            as->jmp(dead_branch_label);
            break;
        }

        default:
            throw std::runtime_error("gen_predicate: invalid random index");
        }
    }
} // namespace obfuscator::transform_util
```

`src/lib/obfuscator/transforms/types.hpp`:

```hpp
#pragma once
#include "analysis/analysis.hpp"
#include "easm/cursor/cursor.hpp"
#include "pe/pe.hpp"
#include "util/types.hpp"

namespace obfuscator {
    /// \brief Transform tags
    using TransformTag = std::size_t;

    namespace transforms {
        /// \brief Dummy class for junk detection
        template <pe::any_image_t>
        class DummyTransform { };
    } // namespace transforms

    namespace detail {
        /// \brief Raw funcsig getter
        template <template <pe::any_image_t> class C> // C is not unused!
        [[nodiscard]] constexpr std::string_view get_funcsig() {
#if PLATFORM_IS_MSVC
            return __FUNCSIG__;
#else
            if constexpr (sizeof(__PRETTY_FUNCTION__) == sizeof(__FUNCTION__)) {
                static_assert(types::always_false_v<>, "Unsupported pretty function");
            }
            return __PRETTY_FUNCTION__;
#endif
        }

        /// \brief Junk info storage
        struct junk_info_t {
            std::size_t start;
            std::size_t total;
        };

        /// \brief Junk info
        constexpr junk_info_t junk_info = []() -> junk_info_t {
            constexpr std::string_view symbol = "DummyTransform";
            std::string_view sample = get_funcsig<transforms::DummyTransform>();
            return junk_info_t{.start = sample.find(symbol), //
                               .total = sample.size() - symbol.size()};
        }();
        static_assert(junk_info.start != static_cast<std::size_t>(-1), "Unable to find junk");

        /// \brief Transform name getter as an array
        template <template <pe::any_image_t> class C>
        constexpr static auto transform_name = [] {
            constexpr auto funcsig = get_funcsig<C>();
            std::array<char, funcsig.size() - junk_info.total + 1> ret{};
            std::copy_n(funcsig.data() + junk_info.start, ret.size() - 1, ret.data());
            return ret;
        }();
    } // namespace detail

    /// \brief Transform name getter
    template <template <pe::any_image_t> class C>
    [[nodiscard]] constexpr std::string_view get_transform_name() noexcept {
        return {detail::transform_name<C>.data(), detail::transform_name<C>.size() - 1};
    }

    /// \brief Transform tag getter
    template <template <pe::any_image_t> class C>
    [[nodiscard]] constexpr TransformTag get_transform_tag() noexcept {
        constexpr std::hash<std::string_view> hash;
        return hash(get_transform_name<C>());
    }
} // namespace obfuscator
```

`src/lib/pe/arch/arch.hpp`:

```hpp
#pragma once
#include "pe/pe.hpp"

namespace pe::arch {
    template <any_raw_image_t Img>
    [[nodiscard]] bool is_x64(const Img* image) {
        return image->get_nt_headers()->file_header.machine == win::machine_id::amd64;
    }

    template <any_raw_image_t Img>
    [[nodiscard]] zasm::MachineMode guess_machine_mode(const Img* image) {
        if (is_x64(image)) {
            return zasm::MachineMode::AMD64;
        }

        return zasm::MachineMode::I386;
    }
} // namespace pe::arch
```

`src/lib/pe/common/common.hpp`:

```hpp
#pragma once
#include "pe/pe.hpp"

namespace pe::common {
    template <any_raw_image_t Img>
    [[nodiscard]] bool is_valid(const Img* image) {
        return image->dos_header.e_magic == win::DOS_HDR_MAGIC;
    }
} // namespace pe::common

```

`src/lib/pe/common/types.hpp`:

```hpp
#pragma once
#include "util/memory/address.hpp"
#include "util/structs.hpp"
#include "util/types.hpp"
#include <linuxpe>
#include <optional>

#define TOGGLE_DIR_IMPORTER(id, name) \
    case id:                          \
        (name) = make();              \
        return

#define TOGGLE_DIR_EXPORTER(id, name) \
    if ((name).has_value()) {         \
        set(id, (name).value());      \
    }

#define TOGGLE_DIRECTORIES(fn)                                                   \
    fn(win::directory_id::directory_entry_export, contains_dir.exp);             \
    fn(win::directory_id::directory_entry_import, contains_dir.imp);             \
    fn(win::directory_id::directory_entry_resource, contains_dir.rsc);           \
    fn(win::directory_id::directory_entry_exception, contains_dir.exc);          \
    fn(win::directory_id::directory_entry_security, contains_dir.sec);           \
    fn(win::directory_id::directory_entry_basereloc, contains_dir.reloc);        \
    fn(win::directory_id::directory_entry_debug, contains_dir.dbg);              \
    fn(win::directory_id::directory_entry_architecture, contains_dir.arch);      \
    fn(win::directory_id::directory_entry_globalptr, contains_dir.gp);           \
    fn(win::directory_id::directory_entry_tls, contains_dir.tls);                \
    fn(win::directory_id::directory_entry_load_config, contains_dir.cfg);        \
    fn(win::directory_id::directory_entry_bound_import, contains_dir.imp_bound); \
    fn(win::directory_id::directory_entry_iat, contains_dir.iat);                \
    fn(win::directory_id::directory_entry_delay_import, contains_dir.imp_delay); \
    fn(win::directory_id::directory_entry_com_descriptor, contains_dir.com)

namespace pe {
    struct relocation_t {
        memory::address rva;
        std::uint8_t size; // in bytes
        win::reloc_type_id type;
    };

    struct dir_properties_t {
        std::uint32_t offset; // from the section start
        std::size_t size; // in bytes
    };

    struct section_t {
        DEFAULT_CTOR_DTOR(section_t);
        DEFAULT_COPY(section_t);

        explicit section_t(const win::section_header_t& header)
            : virtual_size(header.virtual_size), virtual_address(header.virtual_address), size_raw_data(header.size_raw_data),
              ptr_raw_data(header.ptr_raw_data), characteristics(header.characteristics) {
            std::memcpy(name.data(), header.name.short_name, name.size() * sizeof(decltype(name)::value_type));
        }

        std::array<char, LEN_SHORT_STR> name = {'\0'};
        std::uint32_t virtual_size = 0U;
        std::uint32_t virtual_address = 0U;
        std::uint32_t size_raw_data = 0U;
        std::uint32_t ptr_raw_data = 0U;
        win::section_characteristics_t characteristics = {0U};

        std::vector<std::uint8_t> raw_data = {};

        /// This struct contains directory offsets within the section, i.e
        /// If a section contains import descriptors the value of iat would be set
        /// to the offset where iat starts within this section, otherwise would be
        /// set to nullopt
        // \fixme: @es3n1n: THIS IS SO WRONG, BUT I DONT WANT TO STORE THEM IN CONTAINERS IM SO SORRY
        struct {
            std::optional<dir_properties_t> exp = std::nullopt; // export dir
            std::optional<dir_properties_t> imp = std::nullopt; // import dir
            std::optional<dir_properties_t> rsc = std::nullopt; // resource dir
            std::optional<dir_properties_t> exc = std::nullopt; // exception dir
            std::optional<dir_properties_t> sec = std::nullopt; // security dir
            std::optional<dir_properties_t> reloc = std::nullopt; // reloc dir
            std::optional<dir_properties_t> dbg = std::nullopt; // debug dir
            std::optional<dir_properties_t> arch = std::nullopt; // architecture dir
            std::optional<dir_properties_t> gp = std::nullopt; // GP dir
            std::optional<dir_properties_t> tls = std::nullopt; // tls dir
            std::optional<dir_properties_t> cfg = std::nullopt; // config dir
            std::optional<dir_properties_t> imp_bound = std::nullopt; // bound import dir
            std::optional<dir_properties_t> iat = std::nullopt; // import address table dir
            std::optional<dir_properties_t> imp_delay = std::nullopt; // delay import dir
            std::optional<dir_properties_t> com = std::nullopt; // COM descriptor dir
        } contains_dir;

        void set_contained_dir(const win::directory_id dir_id, const std::uint32_t offset, const std::optional<std::size_t> size = std::nullopt) {
            auto make = [&]() -> std::optional<dir_properties_t> {
                return dir_properties_t{.offset = offset, .size = size.has_value() ? size.value() : (virtual_size - offset)};
            };

            switch (dir_id) {
            case win::directory_id::directory_reserved0:
                break;
                TOGGLE_DIRECTORIES(TOGGLE_DIR_IMPORTER);
            }

            std::unreachable();
        }

        template <typename Ty>
            requires(types::is_any_of_v<Ty, win::optional_header_x64_t, win::optional_header_x86_t>)
        void export_contained_dir(Ty* optional_header) {
            auto set = [this, &optional_header](win::directory_id dir_id, const dir_properties_t props) -> void {
                auto& dir = optional_header->data_directories.entries[dir_id];

                if (dir.rva != 0UL || dir.size != 0UL) {
                    throw std::runtime_error(std::format("pe: export_contained_dir duplicated dir_id {} in section {}", //
                                                         static_cast<int>(dir_id), name.data()));
                }

                dir.rva = virtual_address + props.offset;
                dir.size = static_cast<std::uint32_t>(props.size);
            };

            TOGGLE_DIRECTORIES(TOGGLE_DIR_EXPORTER);
        }

        /// Some explicit conversions to other linux-pe stuff
        explicit operator win::section_header_t() const {
            win::section_header_t result{};

            std::ranges::copy(name, result.name.short_name);
            result.virtual_size = virtual_size;
            result.virtual_address = virtual_address;
            result.size_raw_data = size_raw_data;
            result.ptr_raw_data = ptr_raw_data;
            result.characteristics = characteristics;
            return result;
        }
    };
} // namespace pe

#undef TOGGLE_DIRECTORIES
#undef TOGGLE_DIR_EXPORTER
#undef TOGGLE_DIR_IMPORTER

```

`src/lib/pe/debug/debug.hpp`:

```hpp
#pragma once
#include "pe/pe.hpp"

namespace pe::debug {
    template <any_raw_image_t Img>
    [[nodiscard]] win::cv_pdb70_t* find_codeview70(const Img* image) {
        // Looking for debug directory in our PE
        //
        auto* const debug_dir_hdr = image->get_directory(win::directory_id::directory_entry_debug);
        if (!debug_dir_hdr || !debug_dir_hdr->present()) {
            return nullptr;
        }

        // Should never happen
        //
        auto* debug_dir = image->template rva_to_ptr<win::debug_directory_t>(debug_dir_hdr->rva);
        if (!debug_dir) [[unlikely]] {
            return nullptr;
        }

        for (auto* entry = &debug_dir->entries[0]; entry->size_raw_data; ++entry) {
            if (entry->type != win::debug_directory_type_id::codeview) {
                continue;
            }

            // Yay, we found our code view from the debug section
            // NOLINTNEXTLINE
            return reinterpret_cast<win::cv_pdb70_t*>(reinterpret_cast<std::uintptr_t>(image) + entry->ptr_raw_data);
        }

        // No code view
        //
        return nullptr;
    }
} // namespace pe::debug

```

`src/lib/pe/pe.cpp`:

```cpp
#include "pe/pe.hpp"

#include "pe/arch/arch.hpp"
#include "pe/common/common.hpp"
#include "pe/debug/debug.hpp"
#include "pe/rebuilder/rebuilder.hpp"

#include "util/format.hpp"
#include "util/logger.hpp"
#include <magic_enum_all.hpp>

namespace pe {
    template <any_raw_image_t Img>
    [[nodiscard]] bool Image<Img>::is_x64() const {
        return arch::is_x64(raw_image);
    }

    template <any_raw_image_t Img>
    [[nodiscard]] bool Image<Img>::is_valid() const {
        return common::is_valid(raw_image);
    }

    template <any_raw_image_t Img>
    [[nodiscard]] std::vector<section_t> Image<Img>::find_sections_if(const std::function<bool(const section_t&)>& pred) const {
        std::vector<section_t> result = {};

        std::for_each(sections.begin(), sections.end(), [&result, pred](const section_t& section) -> void {
            if (!pred(section)) {
                return;
            }

            result.emplace_back(section);
        });

        return result;
    }

    template <any_raw_image_t Img>
    [[nodiscard]] win::cv_pdb70_t* Image<Img>::find_codeview70() const {
        return debug::find_codeview70(raw_image);
    }

    template <any_raw_image_t Img>
    [[nodiscard]] zasm::MachineMode Image<Img>::guess_machine_mode() const {
        return arch::guess_machine_mode(raw_image);
    }

    template <any_raw_image_t Img>
    [[nodiscard]] section_t& Image<Img>::find_last_section() const {
        auto result = std::ranges::max_element(sections, [](const section_t& lhs, const section_t& rhs) -> bool { //
            return lhs.virtual_address < rhs.virtual_address;
        });

        if (result == std::end(sections)) {
            throw std::runtime_error("pe: Unable to find last section");
        }

        return *result;
    }

    template <any_raw_image_t Img>
    section_t& Image<Img>::new_section(const sections::e_section_t section, const std::size_t size) {
        return new_section(format::sec(section), size, characteristics(section));
    }

    template <any_raw_image_t Img>
    section_t& Image<Img>::new_section(const std::string_view name, const std::size_t size, //
                                       const win::section_characteristics_t characteristics) {
        // Creating a new section.
        // \note: @es3n1n: we must create a new section before the std::max_element call in
        // order to not corrupt the iterator
        auto& new_sec = sections.emplace_back();

        // Reserving section size
        //
        new_sec.raw_data.resize(size, 0);
        assert(size > 0);

        // Obtaining last section
        //
        auto last_section = find_last_section();

        // Obtaining section/file alignment values
        //
        const auto section_alignment = raw_image->get_nt_headers()->optional_header.section_alignment;
        const auto file_alignment = raw_image->get_nt_headers()->optional_header.file_alignment;

        // Assembling the new section
        //
        std::copy_n(name.begin(), std::min(new_sec.name.size() - 1, name.size()), new_sec.name.begin());

        new_sec.virtual_size = new_sec.size_raw_data = memory::address{size} //
                                                           .align_up(section_alignment)
                                                           .template as<uint32_t>();

        new_sec.virtual_address = memory::address{last_section.virtual_address + last_section.virtual_size} //
                                      .align_up(section_alignment)
                                      .template as<uint32_t>();

        new_sec.ptr_raw_data = memory::address{last_section.ptr_raw_data + last_section.size_raw_data} //
                                   .align_up(file_alignment)
                                   .template as<uint32_t>();

        new_sec.characteristics = characteristics;

        return new_sec;
    }
    
    template <any_raw_image_t Img>
    void Image<Img>::realign_sections() const {
        /// Nothing to realign
        if (sections.size() <= 1) {
            return;
        }

        /// Making sure that all section virtual sizes are aligned
        for (std::size_t i = 0; i < sections.size() - 1; ++i) {
            auto& sec = sections.at(i);
            const auto& next_sec = sections.at(i + 1);

            sec.virtual_size = next_sec.virtual_address - sec.virtual_address;
        }
    }

    template <any_raw_image_t Img>
    [[nodiscard]] section_t* Image<Img>::rva_to_section(std::uint32_t rva) const {
        auto iter = std::ranges::find_if(sections, [rva](const section_t& sec) -> bool { //
            return rva >= sec.virtual_address && rva <= (sec.virtual_address + sec.virtual_size);
        });

        if (iter == sections.end()) {
            return nullptr;
        }

        return &*iter;
    }

    template <any_raw_image_t Img>
    void Image<Img>::update_sections() {
        // Obtaining stuff that would be needed
        //
        const auto* nt_hdr = raw_image->get_nt_headers();

        // Reserving the num of sections
        //
        sections.clear();
        sections.reserve(nt_hdr->file_header.num_sections);

        for (std::size_t i = 0; i < nt_hdr->file_header.num_sections; ++i) {
            // Getting a section and validating it
            //
            const auto* section = nt_hdr->get_section(i);
            if (!section) {
                continue;
            }

            // Inserting a section to the result array
            //
            auto& new_elem = sections.emplace_back(*section);
            new_elem.raw_data.resize(new_elem.size_raw_data, 0);

            // NOLINTNEXTLINE
            std::memcpy(new_elem.raw_data.data(), reinterpret_cast<std::uint8_t*>(reinterpret_cast<uintptr_t>(raw_image) + new_elem.ptr_raw_data), //
                        new_elem.size_raw_data);
        }

        // Signalising that we successfully parsed sections
        //
        logger::debug("pe: parsed {} sections", sections.size());

        // Sort by virtual address
        //
        const struct {
            bool operator()(const section_t& lhs, const section_t& rhs) const {
                return lhs.virtual_address < rhs.virtual_address;
            }
        } comp;
        std::sort(sections.begin(), sections.end(), comp);

        // Marking directories
        //
        for (auto dir_id : magic_enum::enum_values<win::directory_id>()) {
            // Trying to find the header of the directory, skipping if not present
            //
            auto dir_hdr = raw_image->get_directory(dir_id);
            if (!dir_hdr || !dir_hdr->present()) {
                continue;
            }

            // Looking up the section by rva and changing flag
            //
            auto* sec = rva_to_section(dir_hdr->rva);
            sec->set_contained_dir(dir_id, dir_hdr->rva - sec->virtual_address, dir_hdr->size);
        }
    }

    // \todo: @es3n1n: check for IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE flag
    template <any_raw_image_t Img>
    void Image<Img>::update_relocations() {
        // Obtaining a pointer to reloc directory header
        //
        const win::data_directory_t* reloc_hdr = raw_image->get_directory(win::directory_id::directory_entry_basereloc);
        if ((reloc_hdr == nullptr) || !reloc_hdr->present()) [[unlikely]] {
            logger::warn("pe: relocation directory header does not present?");
            return;
        }

        // Obtaining a pointer to reloc directory
        //
        const win::reloc_directory_t* base_reloc = rva_to_ptr<win::reloc_directory_t>(reloc_hdr->rva);

        // Guessing the relocated ptr size
        // \todo: @es3n1n: is this even needed?
        const auto reloc_size = get_ptr_size<std::uint8_t>();

        // Iterating over reloc blocks
        //
        for (const auto* reloc_block = &base_reloc->first_block; //
             (reloc_block != nullptr) && (reloc_block->size_block != 0U) && (reloc_block->base_rva != 0U); //
             reloc_block = reloc_block->next()) {
            // Iterating over reloc entries
            //
            for (const auto& [offset, type] : *reloc_block) {
                // Inserting parsed reloc data
                //
                auto rva = static_cast<memory::address>(reloc_block->base_rva) + memory::address(offset);

                // Just to be sure
                //
                if (relocations.contains(rva)) [[unlikely]] {
                    throw std::runtime_error(std::format("pe: duplicated {:#x} rva entry", rva));
                }

                // Inserting relocation info
                //
                relocations[rva] = relocation_t{
                    .rva = rva, //
                    .size = reloc_size, //
                    .type = type //
                };
            }
        }

        logger::debug("pe: parsed total number of {} relocations", relocations.size());
    }

    template <any_raw_image_t Img>
    [[nodiscard]] std::vector<std::uint8_t> Image<Img>::rebuild_pe_image() {
        auto ctx = rebuilder_ctx_t<Image>{.image = this};
        return rebuild_pe(ctx);
    }

    template class Image<win::image_x64_t>;
    template class Image<win::image_x86_t>;
} // namespace pe
```

`src/lib/pe/pe.hpp`:

```hpp
#pragma once

#include "util/memory/address.hpp"
#include "util/sections.hpp"
#include "util/structs.hpp"
#include "util/types.hpp"

#include "pe/common/types.hpp"

#include <functional>
#include <linuxpe>
#include <unordered_map>
#include <vector>
#include <zasm/base/mode.hpp>

// NOLINTBEGIN(bugprone-macro-parentheses)
#define PE_DECL_TEMPLATE_CLASSES(class_name)                \
    template class class_name<pe::Image<win::image_x64_t>>; \
    template class class_name<pe::Image<win::image_x86_t>>
#define PE_DECL_TEMPLATE_STRUCTS(struct_name)                 \
    template struct struct_name<pe::Image<win::image_x64_t>>; \
    template struct struct_name<pe::Image<win::image_x86_t>>
// NOLINTEND(bugprone-macro-parentheses)

namespace pe {
    /// Concept for raw images from linux-pe, could also probably check for `win::image_t`
    template <typename Ty> concept any_raw_image_t = types::is_any_of_v<Ty, win::image_x86_t, win::image_x64_t>;

    /// Wrapper around pe header data, could be improved and hopefully everything could be merged from the
    ///
    template <any_raw_image_t Img>
    class Image {
    public:
        explicit Image(Img* image): raw_image(image) {
            update_sections();
            update_relocations();
        }
        DEFAULT_CTOR_DTOR(Image);
        DEFAULT_COPY(Image);

        [[nodiscard]] bool is_x64() const;

        [[nodiscard]] bool is_valid() const;

        [[nodiscard]] std::vector<section_t> find_sections_if(const std::function<bool(const section_t&)>& pred) const;

        [[nodiscard]] win::cv_pdb70_t* find_codeview70() const;

        [[nodiscard]] zasm::MachineMode guess_machine_mode() const;

        [[nodiscard]] section_t& find_last_section() const;

        section_t& new_section(sections::e_section_t section, std::size_t size);
        section_t& new_section(std::string_view name, std::size_t size, //
                               win::section_characteristics_t characteristics);

        void realign_sections() const;

        [[nodiscard]] section_t* rva_to_section(std::uint32_t rva) const;

        template <typename Ty = std::uint8_t>
        [[nodiscard]] Ty* rva_to_ptr(const memory::address rva) const {
            const auto* section = rva_to_section(rva.as<std::uint32_t>());
            if (section == nullptr) {
                return nullptr;
            }

            const auto offset = rva.inner() - section->virtual_address;
            return memory::address{section->raw_data.data()}.offset(offset).template as<std::add_pointer_t<Ty>>();
        }

        template <typename Ty = std::size_t>
        [[nodiscard]] Ty get_ptr_size() const {
            return sizeof(std::conditional_t<std::is_same_v<Img, win::image_x64_t>, uint64_t, uint32_t>);
        }

        [[nodiscard]] win::data_directory_t* get_directory(win::directory_id dir_id) const {
            auto nt_hdrs = raw_image->get_nt_headers();
            if (nt_hdrs->optional_header.num_data_directories <= dir_id) {
                return nullptr;
            }

            return &nt_hdrs->optional_header.data_directories.entries[dir_id];
        }

        [[nodiscard]] std::vector<std::uint8_t> rebuild_pe_image();

    private:
        void update_sections();
        void update_relocations();

    public:
        /// A raw image instance, that contains all PE info
        Img* raw_image = nullptr;

        /// An unordered map that consists of {rva: reloc_info}
        std::unordered_map<memory::address, relocation_t> relocations = {};

        /// A sections list
        mutable std::vector<section_t> sections = {};
    };

    /// A concept for our Image, so that we can just use it within the templates
    template <typename Ty> concept any_image_t = types::is_any_of_v<Ty, Image<win::image_x86_t>, Image<win::image_x64_t>>;

    /// Converter from `Image` to `win::image_x**_t`
    template <typename Ty>
    struct to_raw_img {
        using type = std::conditional_t<std::is_same_v<Ty, Image<win::image_x64_t>>, win::image_x64_t, win::image_x86_t>;
    };

    /// Alias to the converter
    template <typename Ty>
    using to_raw_img_t = typename to_raw_img<Ty>::type;

    /// Image aliases
    using X64Image = Image<win::image_x64_t>;
    using X86Image = Image<win::image_x86_t>;
    using DefaultImage = X64Image;

    /// Check if image is x64
    template <any_image_t Img>
    struct is_x64_img {
        constexpr static bool value = std::is_same_v<Img, X64Image>;
    };

    /// Check if image arch is x86
    template <any_image_t Img>
    struct is_x86_img {
        constexpr static bool value = std::is_same_v<Img, X86Image>;
    };

    /// Alias for is_x64<Img>::value
    template <any_image_t Img>
    constexpr static bool is_x64_v = is_x64_img<Img>::value;

    /// Alias for is_x86<Img>::value
    template <any_image_t Img>
    constexpr static bool is_x86_v = is_x86_img<Img>::value;
} // namespace pe

```

`src/lib/pe/rebuilder/detail/common.hpp`:

```hpp
#pragma once
#include "pe/pe.hpp"
#include <variant>

// there are no other ways, it seems.
// NOLINTNEXTLINE
#define UNWRAP_IMAGE(ty, fn) detail::visit_wrapped_image<ty>(image, &fn<pe::Image<win::image_x64_t>>, &fn<pe::Image<win::image_x86_t>>, data)

namespace pe::detail {
    template <typename T>
    struct BasePtrWrapper {
        T* ptr;
    };

    struct X64PtrWrapper : BasePtrWrapper<Image<win::image_x64_t>> { };
    struct X86PtrWrapper : BasePtrWrapper<Image<win::image_x86_t>> { };

    using ImgWrapped = std::variant<X64PtrWrapper, X86PtrWrapper>;

    template <any_image_t Ty>
    ImgWrapped wrap_image(Ty* image) {
        using WrapperTy = std::conditional_t<std::is_same_v<Ty, Image<win::image_x64_t>>, X64PtrWrapper, X86PtrWrapper>;
        return ImgWrapped(WrapperTy{image});
    }

    template <typename RetTy = void>
    RetTy visit_wrapped_image(ImgWrapped image_wrapped, //
                              std::function<RetTy(Image<win::image_x64_t>*, std::vector<std::uint8_t>&)> x64_visitor,
                              std::function<RetTy(Image<win::image_x86_t>*, std::vector<std::uint8_t>&)> x86_visitor, //
                              std::vector<std::uint8_t>& data) {
        return std::visit<RetTy>(
            [&]<typename Ty>(Ty&& inst) -> RetTy {
                if constexpr (std::is_same_v<std::decay_t<decltype(inst)>, X64PtrWrapper>) {
                    return x64_visitor(inst.ptr, data);
                } else {
                    return x86_visitor(inst.ptr, data);
                }
            },
            image_wrapped);
    }

    template <typename Ty>
    [[nodiscard]] Ty* buffer_pointer(std::vector<std::uint8_t>& data) {
        return memory::cast<Ty*>(data.data());
    }
} // namespace pe::detail

```

`src/lib/pe/rebuilder/detail/copy_sections.cpp`:

```cpp
#include "pe/rebuilder/rebuilder.hpp"

namespace pe::detail {
    namespace {
        win::section_header_t assemble_section_header(const section_t& section) {
            return static_cast<win::section_header_t>(section);
        }

        template <any_image_t Img>
        void copy_sections_(Img* image, std::vector<std::uint8_t>& data) {
            /// Casting our buffer as the raw image
            auto* out_img = detail::buffer_pointer<to_raw_img_t<Img>>(data);
            auto* nt_headers = out_img->get_nt_headers();
            auto* file_header = &nt_headers->file_header;
            auto* optional_header = &nt_headers->optional_header;

            /// Obtaining sections pointer within the nt headers
            auto* sections = out_img->get_nt_headers()->get_sections();

            /// Raligning sections
            image->realign_sections();

            /// Validating that there's enough space for our sections
            auto sections_start = memory::address{sections};
            auto header_end = memory::address{out_img}.offset(optional_header->size_headers);
            if (sections_start + (sizeof(win::section_header_t) * (image->sections.size() + 1)) > header_end) [[unlikely]] {
                throw std::runtime_error("pe: rebuilder: unable to fit new sections");
            }

            /// Erasing previous data directories info
            std::memset(&optional_header->data_directories, 0, sizeof(optional_header->data_directories));

            /// Iterating over the max value of sections
            /// If the amount of our sections is less than the number of sections
            /// within the PE that we're rebuilding, we would essentially need to
            /// erase all the other sections that presents within the PE
            for (std::size_t i = 0; i < std::max(static_cast<std::size_t>(file_header->num_sections), image->sections.size()); ++i) {
                /// Erasing previous data first
                std::memset(&sections[i], 0, sizeof(win::section_header_t));

                /// If we only need to erase the prev section data
                if (i >= image->sections.size()) {
                    continue;
                }

                /// Obtaining our section info
                auto& section = image->sections.at(i);

                /// Assembling the new section header and copying it
                auto sec_header = assemble_section_header(section);
                if (auto write_res = memory::address{&sections[i]}.write(memory::address{&sec_header}.as<const void*>(), sizeof(win::section_header_t));
                    !write_res.has_value()) {
                    throw std::runtime_error("pe: rebuilder: unable to write section header");
                }

                /// Copying section data, if needed
                if (!section.raw_data.empty()) {
                    auto sec_ptr = memory::address{data.data()}.offset(section.ptr_raw_data);
                    if (auto write_res = sec_ptr.write(section.raw_data.data(), section.raw_data.size()); !write_res.has_value()) {
                        throw std::runtime_error("pe: rebuilder: unable to write section raw data");
                    }
                }

                /// Updating the data directories
                section.export_contained_dir(optional_header);
            }

            /// Updating the sections count
            file_header->num_sections = static_cast<std::uint16_t>(image->sections.size());
        }
    } // namespace

    void copy_sections(const ImgWrapped image, std::vector<std::uint8_t>& data) {
        return UNWRAP_IMAGE(void, copy_sections_);
    }
} // namespace pe::detail
```

`src/lib/pe/rebuilder/detail/init_header.cpp`:

```cpp
#include "pe/rebuilder/rebuilder.hpp"

namespace pe::detail {
    namespace {
        template <any_image_t Img>
        void init_header_(Img* image, std::vector<std::uint8_t>& data) {
            // Obtaining header structs
            //
            auto* nt_headers = image->raw_image->get_nt_headers();
            auto* optional_header = &nt_headers->optional_header;

            // Obtaining some other stuff from the header
            //
            auto& last_section = image->find_last_section();

            // Estimating image sizes
            //
            const auto raw_image_size = last_section.ptr_raw_data + last_section.size_raw_data;
            const auto virtual_image_size = last_section.virtual_address + last_section.virtual_size;

            // Updating values in the header
            // \todo: @es3n1n: size_code, size_init_data, size_uninit_data, base_of_code, num_rva_sizes
            // \note: @es3n1n: the sections count field is updated within the `copy_sections` pass!
            //
            optional_header->size_image = virtual_image_size;

            // Reserving header size
            //
            data.resize(raw_image_size);

            // Copying the original header
            // NOLINTNEXTLINE
            std::memcpy(data.data(), image->raw_image, optional_header->size_headers);
        }
    } // namespace

    void init_header(const ImgWrapped image, std::vector<std::uint8_t>& data) {
        return UNWRAP_IMAGE(void, init_header_);
    }
} // namespace pe::detail

```

`src/lib/pe/rebuilder/detail/update_checksum.cpp`:

```cpp
#include "pe/rebuilder/rebuilder.hpp"

namespace pe::detail {
    namespace {
        template <any_image_t Img>
        void update_checksum_(Img*, std::vector<std::uint8_t>& data) {
            /// Get the headers
            auto* out_img = detail::buffer_pointer<to_raw_img_t<Img>>(data);

            /// Update checksum
            out_img->update_checksum(data.size());
        }
    } // namespace

    void update_checksum(const ImgWrapped image, std::vector<std::uint8_t>& data) {
        return UNWRAP_IMAGE(void, update_checksum_);
    }
} // namespace pe::detail

```

`src/lib/pe/rebuilder/detail/update_relocations.cpp`:

```cpp
#include "pe/rebuilder/rebuilder.hpp"
#include "util/format.hpp"

#include <list>

namespace pe::detail {
    namespace {
        constexpr std::size_t kRelocBlockAlignment = 0x1000;

        // Erasing previous relocations from the binary
        //
        template <any_image_t Img>
        void erase_relocations(Img* image) {
            // Looking for the section that contains relocations
            //
            auto reloc_section = std::ranges::find_if(image->sections, [](const section_t& sec) -> bool { //
                return sec.contains_dir.reloc.has_value();
            });

            // No relocation dir?
            //
            if (reloc_section == std::end(image->sections)) {
                return;
            }

            // Obtaining reloc entry offset from the base of section
            //
            auto reloc_offset = image->raw_image->get_directory(win::directory_id::directory_entry_basereloc)->rva;
            reloc_offset -= reloc_section->virtual_address;

            // Obtaining reloc directory and iterating over blocks in order to get the last block
            //
            auto* dir = memory::cast<win::reloc_directory_t*>(reloc_section->raw_data.data() + reloc_offset);
            auto* block = &dir->first_block;
            for (; block && block->size_block != 0U; block = block->next()) {
                // do nothing
            }

            // Calculating reloc dir size
            //
            const auto dir_size = reinterpret_cast<uintptr_t>(block) - reinterpret_cast<uintptr_t>(dir);

            // Erasing current reloc info
            //
            std::memset(memory::cast<void*>(dir), 0x00, dir_size);

            // If this section consists only of zeroes, then we could just remove the whole section :)
            // Otherwise, we should keep it.
            //
            if (std::ranges::find_if(reloc_section->raw_data, [](const uint8_t val) -> bool { //
                    return val != 0;
                }) != reloc_section->raw_data.end()) {
                return;
            }

            // Erasing section yay
            //
            image->sections.erase(reloc_section);
            logger::debug("pe: erased the whole reloc section :thinking:");
        }

        // Assembling the new reloc section
        //
        template <any_image_t Img>
        void assemble_relocations(Img* image) {
            // No relocations?
            //
            if (image->relocations.empty()) [[unlikely]] {
                logger::info("pe: rebuilder: skipped .reloc section assembling");
                return;
            }

            // Nicely assembling blocks
            // key is start rva, values are relocations, e.g.:
            // 0x1000 ->
            //	relocation {rva=0x1010}
            //	relocation {rva=0x1111}
            // 0x3000 ->
            //	relocation {rva=0x3FFFF}
            // etc
            //
            std::unordered_map<memory::address, std::list<relocation_t>> blocks;
            std::size_t section_size = 0ULL;

            // Iterating over relocations and obtaining start RVAs,
            // Estimating section size
            //
            for (auto&& [rva, relocation] : image->relocations) {
                const auto aligned_rva = rva.align_down(kRelocBlockAlignment);

                // Accounting new block header if we're creating one
                //
                if (!blocks.contains(aligned_rva)) {
                    section_size += sizeof(win::reloc_block_t);
                }

                // Prepending relocation to the block
                //
                blocks[aligned_rva].emplace_back(std::move(relocation));

                // Accounting entry
                //
                section_size += sizeof(win::reloc_entry_t);
            }

            // Obtaining a pointer to the directory header
            //
            auto* dir_header = image->get_directory(win::directory_id::directory_entry_basereloc);
            if (dir_header == nullptr) {
                throw std::runtime_error("pe: rebuilder: .reloc header not found");
            }

            // Inserting the new section with our relocations
            //
            auto& new_section = image->new_section(sections::e_section_t::RELOC, section_size);
            auto section_data = memory::address{new_section.raw_data.data()};
            auto section_end = section_data.offset(new_section.raw_data.size());

            // Serializing reloc entries
            //
            for (auto&& [rva, relocations] : blocks) {
                // Assembling block header
                //
                auto* header = section_data.self_inc_ptr<win::reloc_block_t>();
                header->base_rva = rva.as<std::uint32_t>();
                header->size_block = static_cast<uint32_t>(relocations.size() * sizeof(win::reloc_entry_t)) + sizeof(win::reloc_block_t);

                // Serializing entries
                //
                for (auto&& relocation : relocations) {
                    // Sanity checks
                    //
                    if (relocation.rva < rva || section_data >= section_end) {
                        throw std::runtime_error("pe: rebuilder: reloc serializer sanity error");
                    }

                    // Encoding our relocation struct to the windows' one
                    //
                    const auto reloc_encoded = win::reloc_entry_t{
                        .offset = (relocation.rva - rva).as<uint16_t>(),
                        .type = relocation.type,
                    };

                    // Writing it
                    //
                    if (auto result = section_data.self_write_inc(reloc_encoded); !result.has_value()) {
                        throw std::runtime_error("pe: rebuilder: Unable to write reloc");
                    }
                }
            }

            // Mark as sec with relocs
            //
            new_section.set_contained_dir(win::directory_id::directory_entry_basereloc, 0, section_size);
        }

        template <any_image_t Img>
        void update_relocations_(Img* image, std::vector<std::uint8_t>& data [[maybe_unused]]) {
            erase_relocations(image);
            assemble_relocations(image);
        }
    } // namespace

    void update_relocations(const ImgWrapped image, std::vector<std::uint8_t>& data) {
        return UNWRAP_IMAGE(void, update_relocations_);
    }
} // namespace pe::detail
```

`src/lib/pe/rebuilder/rebuilder.hpp`:

```hpp
#pragma once
#include "pe/rebuilder/detail/common.hpp"
#include "util/progress.hpp"

namespace pe {
    namespace detail {
        void update_relocations(ImgWrapped, std::vector<std::uint8_t>& data);
        void init_header(ImgWrapped image, std::vector<std::uint8_t>& data);
        void copy_sections(ImgWrapped image, std::vector<std::uint8_t>& data);
        void update_checksum(ImgWrapped image, std::vector<std::uint8_t>& data);
    } // namespace detail

    template <any_image_t Img>
    struct rebuilder_ctx_t {
        Img* image;

        [[nodiscard]] detail::ImgWrapped wrap() {
            return detail::wrap_image(image);
        }
    };

    template <any_image_t Img>
    [[nodiscard]] std::vector<std::uint8_t> rebuild_pe(rebuilder_ctx_t<Img> ctx) {
        // Init result data
        //
        std::vector<std::uint8_t> result = {};
        auto progress = util::Progress("pe: rebuilding", 4);

        // Updating .reloc section
        //
        detail::update_relocations(ctx.wrap(), result);
        progress.step();

        // Reserving and copying the original header first
        //
        detail::init_header(ctx.wrap(), result);
        progress.step();

        // Copying sections
        //
        detail::copy_sections(ctx.wrap(), result);
        progress.step();

        // Update checksum
        //
        detail::update_checksum(ctx.wrap(), result);
        progress.step();

        // We are done here
        //
        return result;
    }
} // namespace pe

```

`src/lib/util/defer.hpp`:

```hpp
#pragma once
#include <memory>

#define CAT_(x, y) x##y
#define CAT(x, y) CAT_(x, y)

#define defer auto CAT(_defer_instance_, __COUNTER__) = defer_::defer_{} % [&]()

namespace defer_ {
    template <typename callable>
    struct type {
        callable cb;

        explicit type(callable&& _cb): cb(std::forward<callable>(_cb)) { }

        ~type() {
            cb();
        }
    };

    struct defer_ {
        template <typename callable>
        type<callable> operator%(callable&& cb) {
            return type<callable>{std::forward<callable>(cb)};
        }
    };
} // namespace defer_

```

`src/lib/util/files.hpp`:

```hpp
#pragma once
#include <cstdint>
#include <filesystem>
#include <fstream>
#include <vector>

namespace util {
    inline std::vector<std::uint8_t> read_file(const std::filesystem::path& path) {
        std::fstream file(path, std::ios::in | std::ios::binary);
        if (!file) {
            return {};
        }

        file.seekg(0, std::fstream::end);
        const auto f_size = file.tellg();
        file.seekg(0, std::fstream::beg);

        std::vector<uint8_t> buffer(static_cast<const unsigned int>(f_size));

        // NOLINTNEXTLINE
        file.read(reinterpret_cast<char*>(buffer.data()), buffer.size());

        return buffer;
    }

    inline void write_file(const std::filesystem::path& path, const std::uint8_t* raw_buffer, const size_t buffer_size) {
        std::ofstream file(path, std::ios::binary | std::ios::out);
        // NOLINTNEXTLINE
        file.write(reinterpret_cast<const char*>(raw_buffer), buffer_size);
        file.close();
    }
} // namespace util
```

`src/lib/util/format.hpp`:

```hpp
#pragma once
#include "util/sections.hpp"
#include <format>
#include <string>

namespace format {
    inline std::string loc(const std::int32_t rva) {
        return std::format("loc_{:x}", rva);
    }

    inline std::string sec(const sections::e_section_t sec) {
        return name(sec);
    }
} // namespace format

```

`src/lib/util/iterators.hpp`:

```hpp
#pragma once
#include "util/structs.hpp"

namespace util {
    template <typename Ty>
    class DerefSharedPtrIter {
    public:
        using iterator_category = std::forward_iterator_tag;
        using value_type = std::remove_const_t<Ty>;
        using difference_type = std::ptrdiff_t;
        using pointer = value_type*;
        using reference = value_type&;

        using base_iter_type = typename std::vector<std::shared_ptr<value_type>>::iterator;
        using const_base_iter_type = typename std::vector<std::shared_ptr<value_type>>::const_iterator;
        using iter_type = std::conditional_t<std::is_const_v<Ty>, const_base_iter_type, base_iter_type>;

        explicit DerefSharedPtrIter(iter_type it): it_(it) { }
        DEFAULT_DTOR(DerefSharedPtrIter);

        DerefSharedPtrIter& operator++() {
            ++it_;
            return *this;
        }

        bool operator!=(const DerefSharedPtrIter& other) const {
            return it_ != other.it_;
        }

        Ty& operator*() const {
            return **it_;
        }

    private:
        iter_type it_;
    };
} // namespace util
```

`src/lib/util/logger.hpp`:

```hpp
#pragma once
#include <cstdint>

#include <format>
#include <functional>
#include <iostream>
#include <mutex>
#include <sstream>

#include <chrono>
#include <iomanip>

#include "util/platform.hpp"

namespace logger {
    //
    // Switch this var to false if you want to ignore all output
    // NOLINTNEXTLINE
    inline bool enabled = true;

    namespace detail {
        //
        // Config
        //
        inline bool colors_enabled = true; // NOLINT
        inline bool show_timestamps = true; // NOLINT

        //
        // Constants
        //
        constexpr std::size_t kMaxLevelNameSize = 8;
        constexpr std::size_t kIndentationSize = kMaxLevelNameSize; // in spaces

        //
        // A mutex that would be used to make sure that we are logging one line at the time
        // NOLINTNEXTLINE
        inline std::mutex _mtx = {};

        //
        // Just a set of colors for the verbose prefix in console
        //
        namespace colors {
            // clang-format off
            struct col_t { std::uint8_t fg, bg; };
            // clang-format on

            //
            // @credits: https://stackoverflow.com/a/54062826
            //
            [[maybe_unused]] inline constexpr col_t NO_COLOR = {0, 0}; // no color

            [[maybe_unused]] inline constexpr col_t BLACK = {30, 40};
            [[maybe_unused]] inline constexpr col_t RED = {31, 41};
            [[maybe_unused]] inline constexpr col_t GREEN = {32, 42};
            [[maybe_unused]] inline constexpr col_t YELLOW = {33, 43};
            [[maybe_unused]] inline constexpr col_t BLUE = {34, 44};
            [[maybe_unused]] inline constexpr col_t MAGNETA = {35, 45};
            [[maybe_unused]] inline constexpr col_t CYAN = {36, 46};
            [[maybe_unused]] inline constexpr col_t WHITE = {37, 47};

            [[maybe_unused]] inline constexpr col_t BRIGHT_BLACK = {90, 100};
            [[maybe_unused]] inline constexpr col_t BRIGHT_RED = {91, 101};
            [[maybe_unused]] inline constexpr col_t BRIGHT_GREEN = {92, 102};
            [[maybe_unused]] inline constexpr col_t BRIGHT_YELLOW = {93, 103};
            [[maybe_unused]] inline constexpr col_t BRIGHT_BLUE = {94, 104};
            [[maybe_unused]] inline constexpr col_t BRIGHT_MAGNETA = {95, 105};
            [[maybe_unused]] inline constexpr col_t BRIGHT_CYAN = {96, 106};
            [[maybe_unused]] inline constexpr col_t BRIGHT_WHITE = {97, 107};
        } // namespace colors

        //
        // Util function to set console colors
        // \todo: @es3n1n: maybe add font_style too?
        //
        inline void apply_style(const std::uint8_t foreground, const std::uint8_t background, const std::function<void()>& callback) noexcept {
#if PLATFORM_IS_WIN
            static std::once_flag once_flag;

            //
            // In order to use ANSI escape sequences we should make sure that we've activated virtual
            // terminal before using them
            //
            std::call_once(once_flag, []() -> void {
                const auto console_handle = GetStdHandle(STD_OUTPUT_HANDLE);

                if (console_handle == nullptr) {
                    colors_enabled = false;
                    return;
                }

                //
                // Obtaining current console mode
                //
                DWORD console_flags = 0;
                if (GetConsoleMode(console_handle, &console_flags) == 0) [[unlikely]] {
                    // wtf? ok lets pray ansi codes would work lol.
                    return;
                }

                //
                // Activating virtual terminal
                //
                console_flags |= ENABLE_VIRTUAL_TERMINAL_PROCESSING | DISABLE_NEWLINE_AUTO_RETURN;
                if (SetConsoleMode(console_handle, console_flags) == 0) {
                    console_flags &= ~DISABLE_NEWLINE_AUTO_RETURN;

                    //
                    // Try again without DISABLE_NEWLINE_AUTO_RETURN
                    //
                    if (SetConsoleMode(console_handle, console_flags) == 0) {
                        colors_enabled = false;
                    }
                }
            });
#endif

            //
            // Applying style
            //
            const auto apply = [](const std::uint8_t fg_value, const std::uint8_t bg_value) -> int {
                if (!colors_enabled) {
                    return 0;
                }

                if ((fg_value != 0U) && (bg_value == 0U)) {
                    return std::printf("\033[%dm", fg_value);
                }

                return std::printf("\033[%d;%dm", fg_value, bg_value);
            };
            apply(foreground, background);

            //
            // Invoke callback
            //
            callback();

            //
            // Reset style
            //
            apply(colors::NO_COLOR.fg, colors::NO_COLOR.bg);
        }

        //
        // Util traits
        //
        template <typename T> concept str_t = std::is_same_v<T, std::string> || std::is_same_v<T, std::wstring>;
        template <typename T> concept char_str_view_t = std::is_same_v<T, std::string_view> || std::is_same_v<T, const char*>;
        template <typename T> concept wchar_str_view_t = std::is_same_v<T, std::wstring_view> || std::is_same_v<T, const wchar_t*>;
        template <typename T> concept str_view_t = char_str_view_t<T> || wchar_str_view_t<T>;

        //
        // The main method that would be used to log lines
        //
        template <str_t T>
        void log_line(const std::uint8_t indentation, const std::string_view level_name, //
                      const std::uint8_t color_fg, const std::uint8_t color_bg, //
                      const T& msg) noexcept {
            //
            // If logger is disabled
            //
            if (!enabled) {
                return;
            }

            //
            // Locking mutex
            //
            const std::lock_guard _lock(_mtx);

            const auto indent = [](const std::uint8_t ind) -> void {
                if (ind <= 0) {
                    return;
                }

                // apply_style(colors::BRIGHT_WHITE.fg, colors::NO_COLOR.bg, [=]() -> void {
                for (std::size_t i = 0; i < ind; i++) {
                    std::cout << '|';

                    for (std::size_t j = 0; j < kIndentationSize; j++) {
                        std::cout << ' ';
                    }
                }
                //});
            };

            //
            // Iterating lines
            //
            T line;
            std::conditional_t<std::is_same_v<T, std::wstring>, std::wistringstream, std::istringstream> stream(msg);

            while (std::getline(stream, line)) {
                if (show_timestamps) {
                    auto now = std::chrono::system_clock::now();
                    std::time_t time_now = std::chrono::system_clock::to_time_t(now);
#if PLATFORM_IS_MSVC
                    std::tm now_tm;
                    localtime_s(&now_tm, &time_now);
#else
                    std::tm now_tm = *std::localtime(&time_now);
#endif

                    auto milliseconds = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()) % 1000;

                    std::cout << std::put_time(&now_tm, "%H:%M:%S.");
                    std::cout << std::setfill('0') << std::setw(3) << milliseconds.count() << " | ";
                }

                indent(indentation);

                std::cout << "[";
                apply_style(color_fg, color_bg, [=]() -> void { std::cout << std::format("{:^{}}", level_name, kMaxLevelNameSize); });
                std::cout << "] ";

                //
                // \fixme: @es3n1n: this is ugly af
                //
                if constexpr (std::is_same_v<T, std::wstring>) {
                    std::wcout << line << "\n";
                } else {
                    std::cout << line << "\n";
                }
            }
        }
    } // namespace detail

#define MAKE_LOGGER_METHOD(fn_name, prefix, color_fg, color_bg)                           \
    template <std::uint8_t Indentation = 0, detail::str_view_t Str, typename... Args>     \
    inline void fn_name(const Str fmt, Args... args) noexcept {                           \
        std::conditional_t<detail::wchar_str_view_t<Str>, std::wstring, std::string> msg; \
                                                                                          \
        if constexpr (detail::wchar_str_view_t<Str>) {                                    \
            msg = std::vformat(fmt, std::make_wformat_args(args...));                     \
        } else {                                                                          \
            msg = std::vformat(fmt, std::make_format_args(args...));                      \
        }                                                                                 \
                                                                                          \
        detail::log_line(Indentation, prefix, (color_fg).fg, (color_bg).bg, msg);         \
    }

    MAKE_LOGGER_METHOD(debug, "debug", detail::colors::BRIGHT_WHITE, detail::colors::NO_COLOR);
    MAKE_LOGGER_METHOD(info, "info", detail::colors::BRIGHT_GREEN, detail::colors::NO_COLOR);
    MAKE_LOGGER_METHOD(warn, "warn", detail::colors::BRIGHT_YELLOW, detail::colors::NO_COLOR);
    MAKE_LOGGER_METHOD(error, "error", detail::colors::BRIGHT_MAGNETA, detail::colors::NO_COLOR);
    MAKE_LOGGER_METHOD(critical, "critical", detail::colors::BRIGHT_WHITE, detail::colors::MAGNETA);

    MAKE_LOGGER_METHOD(msg, "msg", detail::colors::BRIGHT_WHITE, detail::colors::NO_COLOR);
    MAKE_LOGGER_METHOD(todo, "todo", detail::colors::BRIGHT_YELLOW, detail::colors::NO_COLOR);
    MAKE_LOGGER_METHOD(fixme, "fixme", detail::colors::BRIGHT_YELLOW, detail::colors::NO_COLOR);

#undef MAKE_LOGGER_METHOD

#define MAKE_LOGGER_OR_METHOD(fn_name, if_true, if_false)                             \
    template <std::uint8_t Indentation = 0, detail::str_view_t Str, typename... Args> \
    inline void fn_name(bool condition, const Str fmt, Args... args) {                \
        if (condition) {                                                              \
            if_true<Indentation>(fmt, std::forward<Args>(args)...);                   \
        } else {                                                                      \
            if_false<Indentation>(fmt, std::forward<Args>(args)...);                  \
        }                                                                             \
    }

    MAKE_LOGGER_OR_METHOD(info_or_warn, info, warn);
    MAKE_LOGGER_OR_METHOD(info_or_error, info, error);
    MAKE_LOGGER_OR_METHOD(info_or_critical, info, critical);

#undef MAKE_LOGGER_OR_METHOD
} // namespace logger

/// \note es3n1n: clang momento
#define FIXME_NO_ARG(indentation, fmt) logger::fixme<indentation>(fmt)
#define TODO_NO_ARG(indentation, fmt) logger::todo<indentation>(fmt)

#define FIXME(indentation, fmt, ...) logger::fixme<indentation>(fmt, __VA_ARGS__)
#define TODO(indentation, fmt, ...) logger::fixme<indentation>(fmt, __VA_ARGS__)

```

`src/lib/util/memory/address.hpp`:

```hpp
#pragma once
#include "util/logger.hpp"
#include <cstddef>
#include <cstdint>
#include <expected>
#include <format>
#include <vector>

#include "reader.hpp"

// \fixme: @es3n1n: this file is a mess
// \todo: @es3n1n: add += -= operators
// \todo: @es3n1n: add self_* funcs

namespace memory {
    class address {
    public:
        constexpr address() = default;

        /// Implicit conversions ftw
        constexpr address(const std::nullptr_t) { } // NOLINT
        constexpr address(const uintptr_t address): address_(address) { } // NOLINT
        address(const void* address): address_(reinterpret_cast<uintptr_t>(address)) { } // NOLINT
        address(const std::vector<std::uint8_t>& data): address_(reinterpret_cast<uintptr_t>(data.data())) { } // NOLINT

        address(const address& inst) = default;
        address(address&& inst) = default;
        address& operator=(const address& inst) = default;
        address& operator=(address&& inst) = default;
        ~address() = default;

        [[nodiscard]] constexpr address offset(const std::ptrdiff_t offset = 0) const noexcept {
            if (address_ == 0U) {
                return *this;
            }

            return {address_ + offset};
        }

        std::expected<address, e_error_code> write(const void* buffer, const std::size_t size) {
            if (auto result = memory::write(address_, buffer, size); !result.has_value()) {
                return std::unexpected(result.error());
            }

            return *this;
        }

        template <typename Ty>
        std::expected<address, e_error_code> write(Ty value) {
            auto copy = std::move(value);

            if (auto ret = memory::write(&copy, address_); !ret.has_value()) {
                return std::unexpected(ret.error());
            }

            return *this;
        }

        template <typename Ty>
        [[nodiscard]] std::expected<Ty, e_error_code> read() const {
            return memory::read<Ty>(address_);
        }

        template <typename Ty>
        std::expected<Ty*, e_error_code> read(Ty* dst) const {
            if (auto result = memory::read(dst, address_); !result.has_value()) {
                return std::unexpected(result.error());
            }

            return dst;
        }

        [[nodiscard]] std::expected<std::vector<std::uint8_t>, e_error_code> read_vector(const std::size_t size) const {
            std::vector<std::uint8_t> result = {};
            result.resize(size);

            if (auto stat = memory::read(result.data(), address_, size); !stat.has_value()) {
                return std::unexpected(stat.error());
            }

            return result;
        }

        template <typename T = address>
        [[nodiscard]] std::expected<T, e_error_code> deref() const {
            auto result = memory::read<T>(inner());

            if (!result.has_value()) {
                return std::unexpected(result.error());
            }

            return result.value();
        }

        template <typename T = address>
        [[nodiscard]] std::expected<T, e_error_code> get(std::size_t count = 1) const noexcept {
            if (!address_ || count == 0) {
                return std::unexpected(e_error_code::INVALID_ADDRESS);
            }

            address _tmp = *this;
            while (_tmp && count-- >= 2) {
                auto deref_value = _tmp.deref();
                if (!deref_value.has_value()) {
                    return std::unexpected(e_error_code::NOT_ENOUGH_BYTES);
                }

                _tmp = deref_value.value();
            }

            return _tmp.deref<T>();
        }

        template <typename T = address>
        [[nodiscard]] constexpr T* ptr(const std::ptrdiff_t offset = 0) const noexcept {
            return this->offset(offset).as<std::add_pointer_t<T>>();
        }

        template <typename T = address>
        [[nodiscard]] constexpr T* self_inc_ptr(const std::ptrdiff_t offset = 0) noexcept {
            auto* result = ptr<T>(offset);
            *this = address{result}.offset(sizeof(T));
            return result;
        }

        template <typename Ty>
        std::expected<address, e_error_code> self_write_inc(const Ty data, const std::ptrdiff_t offset = 0) noexcept {
            auto result = this->offset(offset).write(data);
            *this = this->offset(offset + sizeof(Ty));
            return result;
        }

        [[nodiscard]] constexpr address align_down(const std::ptrdiff_t factor) const noexcept {
            return {address_ & ~(factor - 1U)};
        }

        [[nodiscard]] constexpr address align_up(const std::ptrdiff_t factor) const noexcept {
            return address{address_ + factor - 1U}.align_down(factor);
        }

        template <typename T>
        [[nodiscard]] constexpr T cast() const noexcept {
            return memory::cast<T>(address_);
        }

        template <typename T>
        [[nodiscard]] constexpr T as() const noexcept {
            return cast<T>();
        }

        constexpr explicit operator std::uintptr_t() const noexcept {
            return address_;
        }

        [[nodiscard]] constexpr std::uintptr_t inner() const noexcept {
            return address_;
        }

        constexpr explicit operator bool() const noexcept {
            return static_cast<bool>(address_);
        }

#define MATH_OPERATOR(type, operation)                             \
    constexpr type operator operation(const address& rhs) const {  \
        return static_cast<type>(address_ operation rhs.address_); \
    }

        MATH_OPERATOR(bool, ==)
        MATH_OPERATOR(bool, !=)
        MATH_OPERATOR(bool, >)
        MATH_OPERATOR(bool, <)
        MATH_OPERATOR(bool, <=)
        MATH_OPERATOR(bool, >=)
        MATH_OPERATOR(address, +)
        MATH_OPERATOR(address, -)

#undef MATH_OPERATOR

    private:
        std::uintptr_t address_ = 0;
    };
} // namespace memory

//
// Creating custom formatters for the std::format function so that
// we can easily format addresses in logger
//
template <>
struct std::formatter<memory::address> : std::formatter<std::uintptr_t> {
    template <class FormatContextTy>
    constexpr auto format(const memory::address& instance, FormatContextTy& ctx) const {
        return std::formatter<std::uintptr_t>::format(instance.inner(), ctx);
    }
};

//
// Overriding custom implementation for std::hash in order to use
// this type in containers
//
template <>
struct std::hash<memory::address> {
    size_t operator()(const memory::address& instance) const noexcept {
        return std::hash<std::uintptr_t>()(instance.inner());
    }
};

```

`src/lib/util/memory/casts.hpp`:

```hpp
#pragma once

namespace memory {
    template <typename DstTy, typename SrcTy>
    DstTy cast(SrcTy src) {
        if constexpr (std::is_same_v<std::remove_cv_t<DstTy>, decltype(src)>) {
            return src;
        } else if constexpr (sizeof(DstTy) < sizeof(src)) {
            return static_cast<DstTy>(src);
        } else {
            // NOLINTNEXTLINE
            return (DstTy)src;
        }
    }
} // namespace memory

```

`src/lib/util/memory/reader.hpp`:

```hpp
#pragma once
#include "casts.hpp"
#include <cstdint>
#include <expected>

namespace memory {
    enum class e_error_code : std::uint8_t {
        INVALID_PARAMETERS = 0,
        INVALID_ADDRESS,
        NOT_ENOUGH_BYTES
    };

    inline std::expected<std::size_t, e_error_code> read(void* buffer, const std::uintptr_t address, const std::size_t size) {
        if (buffer == nullptr || address == 0U || size == 0U) {
            return std::unexpected(e_error_code::INVALID_PARAMETERS);
        }

        auto trivial_copy = [&buffer, &address]<typename T>(T) -> void {
            *static_cast<T*>(buffer) = *reinterpret_cast<T*>(address);
        };

        switch (size) {
        case sizeof(uint8_t):
            trivial_copy(uint8_t{});
            break;

        case sizeof(uint16_t):
            trivial_copy(uint16_t{});
            break;

        case sizeof(uint32_t):
            trivial_copy(uint32_t{});
            break;

        case sizeof(uint64_t):
            trivial_copy(uint64_t{});
            break;

        default:
            // NOLINTNEXTLINE
            std::memcpy(buffer, reinterpret_cast<void*>(address), size);
            break;
        }

        return size;
    }

    inline std::expected<std::size_t, e_error_code> write(std::uintptr_t address, const void* buffer, const std::size_t size) {
        if (buffer == nullptr || address == 0U || size == 0U) {
            return std::unexpected(e_error_code::INVALID_PARAMETERS);
        }

        auto trivial_copy = [&buffer, &address]<typename T>(T) -> void {
            // NOLINTNEXTLINE
            *reinterpret_cast<T*>(address) = *static_cast<T*>(const_cast<void*>(buffer));
        };

        switch (size) {
        case sizeof(uint8_t):
            trivial_copy(uint8_t{});
            break;

        case sizeof(uint16_t):
            trivial_copy(uint16_t{});
            break;

        case sizeof(uint32_t):
            trivial_copy(uint32_t{});
            break;

        case sizeof(uint64_t):
            trivial_copy(uint64_t{});
            break;

        default:
            // NOLINTNEXTLINE
            std::memcpy(reinterpret_cast<void*>(address), buffer, size);
            break;
        }

        return size;
    }

    template <typename Ty>
    std::expected<std::size_t, e_error_code> read(Ty* dst, const std::uintptr_t src) {
        return read(dst, src, sizeof(Ty));
    }

    template <typename Ty>
    std::expected<Ty, e_error_code> read(const std::uintptr_t src) {
        Ty _obj = {};

        if (const auto res = read(&_obj, src); !res.has_value()) {
            return std::unexpected(res.error());
        }

        return _obj;
    }

    template <typename Ty>
    std::expected<std::size_t, e_error_code> write(const Ty* src, const std::uintptr_t dst) {
        return write(memory::cast<const uintptr_t>(dst), src, sizeof(Ty));
    }
} // namespace memory
```

`src/lib/util/passes.hpp`:

```hpp
#pragma once
#include <tuple>

namespace passes {
    template <typename... Passes, typename... Args>
    bool apply(Args... args) {
        // Stores the value if we changed something
        //
        bool applied = false;

        // Applying transforms
        //
        const auto do_pass = [&](auto&& pass) -> void {
            applied |= pass.apply(std::forward<Args>(args)...);
        };

        // Creating pass instances and applying them
        //
        std::apply([&](auto&&... pass) { (do_pass(pass), ...); }, std::tuple<Passes...>());

        // Return true if we changed something
        //
        return applied;
    }
} // namespace passes
```

`src/lib/util/platform.hpp`:

```hpp
#pragma once
///
/// Systems
///
#if defined(_WIN32)
    #define PLATFORM_IS_WIN true
    #define PLATFORM_IS_WIN32 true
    #define PLATFORM_IS_WIN64 false
    #define PLATFORM_IS_LINUX false
    #define PLATFORM_IS_APPLE false
#elif defined(_WIN64)
    #define PLATFORM_IS_WIN true
    #define PLATFORM_IS_WIN32 false
    #define PLATFORM_IS_WIN64 true
    #define PLATFORM_IS_LINUX false
    #define PLATFORM_IS_APPLE false
#elif defined(__linux__)
    #define PLATFORM_IS_WIN false
    #define PLATFORM_IS_WIN32 false
    #define PLATFORM_IS_WIN64 false
    #define PLATFORM_IS_LINUX true
    #define PLATFORM_IS_APPLE false
#elif defined(__APPLE__)
    #define PLATFORM_IS_WIN false
    #define PLATFORM_IS_WIN32 false
    #define PLATFORM_IS_WIN64 false
    #define PLATFORM_IS_LINUX false
    #define PLATFORM_IS_APPLE true
#else
    #error UNKNOWN SYSTEM
#endif

#define PLATFORM_IS_UNIX (PLATFORM_IS_LINUX || PLATFORM_IS_APPLE)

///
/// Compilers
///
#if defined(__GNUC__)
    #define PLATFORM_IS_GCC true
    #define PLATFORM_IS_CLANG false
    #define PLATFORM_IS_MSVC false
#elif defined(__clang__)
    #define PLATFORM_IS_GCC false
    #define PLATFORM_IS_CLANG true
    #define PLATFORM_IS_MSVC false
#elif defined(_MSC_VER)
    #define PLATFORM_IS_GCC false
    #define PLATFORM_IS_CLANG false
    #define PLATFORM_IS_MSVC true
#else
    #error UNKNOWN_COMPILER
#endif

///
/// Cxx interface
///
namespace platform {
    [[maybe_unused]] constexpr bool is_win = PLATFORM_IS_WIN;
    [[maybe_unused]] constexpr bool is_win32 = PLATFORM_IS_WIN32;
    [[maybe_unused]] constexpr bool is_win64 = PLATFORM_IS_WIN64;

    [[maybe_unused]] constexpr bool is_linux = PLATFORM_IS_LINUX;
    [[maybe_unused]] constexpr bool is_apple = PLATFORM_IS_APPLE;
    [[maybe_unused]] constexpr bool is_unix = PLATFORM_IS_UNIX;

    [[maybe_unused]] constexpr bool is_gcc = PLATFORM_IS_GCC;
    [[maybe_unused]] constexpr bool is_clang = PLATFORM_IS_CLANG;
    [[maybe_unused]] constexpr bool is_msvc = PLATFORM_IS_MSVC;
} // namespace platform

///
/// \note: @es3n1n: this is needed because on gcc we'll get some warnings
/// since `[[maybe_unused]]` attribute is getting ignored on a member of
/// a class or struct
///
#if PLATFORM_IS_GCC
    #define MAYBE_UNUSED_FIELD
#else
    #define MAYBE_UNUSED_FIELD [[maybe_unused]]
#endif

///
/// Platform-specific includes
///
#if PLATFORM_IS_WIN
    #define NOGDI
    #include <Windows.h>
#endif

```

`src/lib/util/progress.hpp`:

```hpp
#pragma once
#include "logger.hpp"
#include "util/stopwatch.hpp"

namespace util {
    /// \brief Progress-bar object
    class Progress {
    public:
        DEFAULT_DTOR(Progress);
        NON_COPYABLE(Progress);

        /// \brief
        /// \param title Title like "Obfuscating function main"
        /// \param num_steps Number of total steps for a progress
        explicit Progress(const std::string_view title, const std::size_t num_steps): title_(title), steps_(num_steps) {
            step();
        }

        /// \brief Do a step and update the progress msg
        void step() {
            /// Increment the step
            ++step_;

            /// Calculate current percentage
            const auto percents = static_cast<float>(step_) / static_cast<float>(steps_);

            /// Format msg with elapsed time if needed
            std::string msg = std::format("{}: {}%", title_, static_cast<std::size_t>(percents * 100));
            if (step_ == steps_) {
                msg += std::format(" took {}", stopwatch_.elapsed());
            }

            /// Print it
            logger::info(msg.c_str());
        }

    private:
        /// \brief Stopwatch
        Stopwatch stopwatch_ = {};
        /// \brief Progress bar title
        std::string title_ = {};
        /// \brief Total number of steps
        std::size_t steps_ = {};
        /// \brief Current step
        std::ptrdiff_t step_ = -1; // we start at -1 and it will automatically increment it to 0
    };
} // namespace util

```

`src/lib/util/random.hpp`:

```hpp
#pragma once
#include "util/logger.hpp"
#include "util/types.hpp"

#include <algorithm>
#include <numeric>
#include <optional>
#include <random>

namespace rnd {
    namespace detail {
        /// We are gonna use the mersenne twister prng because its pretty convenient
        /// and its already present in std
        inline std::mt19937_64 prng = {}; // NOLINT

        /// \brief Set the MT seed
        /// \param seed seed to set
        inline void seed(std::optional<std::uint64_t> seed = std::nullopt) {
            /// Generate the random seed, if needed
            if (!seed.has_value()) {
                std::random_device device;
                seed = (static_cast<uint64_t>(device()) << (sizeof(uint32_t) * CHAR_BIT)) | device();
            }

            /// Set the seed
            logger::info("random: seed is {:#x}", *seed);
            prng.seed(*seed);
        }
    } // namespace detail

    /// \brief Get random number in desired range
    /// \tparam Ty result type
    /// \param min minimal value, by default set to the min limit of the `Ty` type
    /// \param max maximal value, by default set to the max limit of the `Ty` type
    /// \return random number
    template <typename Ty = std::uint32_t, typename TyVal = std::remove_reference_t<Ty>, typename Limits = std::numeric_limits<TyVal>>
    TyVal number(const TyVal min = Limits::min(), const TyVal max = Limits::max()) {
        /// We cannot generate une byte of data with uniform_int_distribution
        using GenTy = std::conditional_t<types::is_any_of_v<Ty, std::int8_t, std::uint8_t, char>, int, TyVal>;
        std::uniform_int_distribution<GenTy> dist(min, max);
        return static_cast<TyVal>(dist(detail::prng));
    }

    /// \brief Generate a number of bytes
    /// \param ptr pointer where it should write these bytes to
    /// \param size size
    inline void bytes(std::uint8_t* ptr, const std::size_t size) {
        std::generate_n(ptr, size, []() -> std::uint8_t { return number<std::uint8_t>(); });
    }

    /// \brief Generate a number of bytes and return them as a vector
    /// \param size size
    /// \return vector filled with random bytes
    inline std::vector<std::uint8_t> bytes(const std::size_t size) {
        std::vector<std::uint8_t> result = {};
        result.resize(size);

        bytes(result.data(), result.size());
        return result;
    }

    /// \brief
    /// \param chance (from 0 to 100)% chance
    /// \return true/false
    inline bool chance(const std::uint8_t chance) {
        return number<std::uint8_t>(0, 100) <= chance;
    }

    /// \brief Get a random item from the container
    /// \tparam Rng Range
    /// \param range Range value (vector/array/anything)
    /// \return random value reference
    template <std::ranges::range Rng>
    const std::ranges::range_value_t<Rng>& item(Rng&& range) {
        auto it = std::ranges::begin(range);
        std::advance(it, number<std::size_t>(static_cast<std::size_t>(0), //
                                             static_cast<std::size_t>(std::ranges::distance(range) - 1)));
        return *it;
    }

    /// \brief Select between values
    /// \tparam TArgs typename of the operands
    /// \param args variadic options
    /// \return random choosen result
    template <typename... TArgs>
    auto or_(TArgs... args) {
        return item(types::to_array(std::forward<TArgs>(args)...));
    }
} // namespace rnd

```

`src/lib/util/sections.hpp`:

```hpp
#pragma once
#include <../../../vendor/linux-pe/includes/linuxpe>
#include <cstdint>

namespace sections {
    enum class e_section_t : std::uint8_t {
        RELOC = 0,
        CODE,
    };

    namespace detail {
        constexpr std::array RELOC_NAME = {'.', 's', '_', 'r', 'e', 'l', '\x00', '\x00'};
        constexpr std::array CODE_NAME = {'.', 's', '_', 'c', 'o', 'd', 'e', '\x00'};

        static_assert(RELOC_NAME.size() == LEN_SHORT_STR);
        static_assert(CODE_NAME.size() == LEN_SHORT_STR);

        constexpr win::section_characteristics_t RELOC_CHARACTERISTICS = {.flags = 0x42000040}; // read, discard, init
        constexpr win::section_characteristics_t CODE_CHARACTERISTICS = {.flags = 0x60000020}; // contains code, exec, read
    } // namespace detail

    inline std::string name(const e_section_t sec) {
        switch (sec) {
        case e_section_t::RELOC:
            return detail::RELOC_NAME.data();
        case e_section_t::CODE:
            return detail::CODE_NAME.data();
        }

        std::unreachable();
    }

    inline win::section_characteristics_t characteristics(const e_section_t section) {
        switch (section) {
        case e_section_t::RELOC:
            return detail::RELOC_CHARACTERISTICS;
        case e_section_t::CODE:
            return detail::CODE_CHARACTERISTICS;
        }

        std::unreachable();
    }
} // namespace sections

```

`src/lib/util/stopwatch.hpp`:

```hpp
#pragma once
#include "util/structs.hpp"
#include <chrono>

namespace util {
    /// \brief Our custom elapsed time storage
    class ElapsedTime {
    public:
        DEFAULT_DTOR(ElapsedTime);
        DEFAULT_COPY(ElapsedTime);

        /// \brief Explicit conversion from chrono duration to our own stuff
        /// \tparam Rep Duration rep
        /// \tparam Period Duration period
        /// \param elapsed Duration value
        template <class Rep, class Period>
        explicit ElapsedTime(const std::chrono::duration<Rep, Period> elapsed) {
            microseconds_ = std::chrono::duration_cast<std::chrono::microseconds>(elapsed);
            hours_ = remainder_microseconds_cast<decltype(hours_)>();
            minutes_ = remainder_microseconds_cast<decltype(minutes_)>();
            seconds_ = remainder_microseconds_cast<decltype(seconds_)>();
            milliseconds_ = remainder_microseconds_cast<decltype(milliseconds_)>();
        }

        /// \brief Convert elapsed time to string in format "{} hr {} min {} sec {} ms"
        /// \return String
        [[nodiscard]] std::string str() const {
            std::string result = {};
            /// Convert hours
            if (auto hrs = hours_.count()) {
                result += std::format(" {} hr", hrs);
            }

            /// Convert minutes
            if (auto mins = minutes_.count()) {
                result += std::format(" {} min", mins);
            }

            /// Convert seconds
            if (auto sec = seconds_.count()) {
                result += std::format(" {} sec", sec);
            }

            /// Convert milliseconds
            if (auto ms = milliseconds_.count()) {
                result += std::format(" {} ms", ms);
            }

            /// Convert microseconds only if others are empty
            if (result.empty()) {
                result += std::format(" {} microseconds", microseconds_.count());
            }

            /// Remove the leading space
            result = result.substr(1);

            return result;
        }

    private:
        /// \brief Get remainder from total microseconds for a given duration
        /// \tparam Dst Destination duration type
        /// \return Converted amount
        template <typename Dst>
        [[nodiscard]] Dst remainder_microseconds_cast() noexcept {
            const auto result = std::chrono::duration_cast<Dst>(microseconds_);
            microseconds_ -= std::chrono::duration_cast<decltype(microseconds_)>(result);
            return result;
        }

        /// \brief Elapsed hours
        std::chrono::hours hours_ = {};
        /// \brief Elapsed minutes
        std::chrono::minutes minutes_ = {};
        /// \brief Elapsed seconds
        std::chrono::seconds seconds_ = {};
        /// \brief Elapsed milliseconds
        std::chrono::milliseconds milliseconds_ = {};
        /// \brief Elapsed **total** microseconds
        std::chrono::microseconds microseconds_ = {};
    };

    /// \brief A stopwatch class that should be used for all the time elapsing stuff
    class Stopwatch {
        using Clock = std::chrono::high_resolution_clock;
        using TimePoint = std::chrono::time_point<Clock>;

    public:
        DEFAULT_DTOR(Stopwatch);
        NON_COPYABLE(Stopwatch);

        /// \brief General constructor
        Stopwatch() noexcept {
            reset();
        }

        /// \brief Start time reset
        void reset() {
            started_ = Clock::now();
        }

        /// \brief Get the difference between current and start time
        /// \return ElapsedTime struct
        [[nodiscard]] auto elapsed() const noexcept {
            return ElapsedTime(Clock::now() - started_);
        }

    private:
        /// \brief Start time
        TimePoint started_ = {};
    };
} // namespace util

/// \brief Elapsed time formatter
template <>
struct std::formatter<util::ElapsedTime> : std::formatter<std::string> {
    template <class FormatContextTy>
    constexpr auto format(const util::ElapsedTime& instance, FormatContextTy& ctx) const {
        return std::formatter<std::string>::format(instance.str(), ctx);
    }
};

```

`src/lib/util/string_parser.hpp`:

```hpp
#pragma once
#include "types.hpp"

#include <any>
#include <cassert>
#include <cstdint>
#include <string>

namespace util::string {
    /// \brief Parse int32 from string
    /// \param s string that contain int32
    /// \param base base (10 for decimal, 16 for hex, etc)
    /// \return parsed value
    [[nodiscard]] inline std::int32_t parse_int32(const std::string_view s, const std::size_t base = 10) {
        return std::stoi(s.data(), nullptr, static_cast<int>(base));
    }

    /// \brief Parse uint32 from string
    /// \param s string that contain uint32
    /// \param base base (10 for decimal, 16 for hex, etc)
    /// \return parsed value
    [[nodiscard]] inline std::uint32_t parse_uint32(const std::string_view s, const std::size_t base = 10) {
        return std::stoul(s.data(), nullptr, static_cast<int>(base));
    }

    /// \brief Parse int8 from string
    /// \param s string that contain int8
    /// \param base base (10 for decimal, 16 for hex, etc)
    /// \return parsed value
    [[nodiscard]] inline std::int8_t parse_int8(const std::string_view s, const std::size_t base = 10) {
        return static_cast<std::int8_t>(parse_int32(s, base) & 0xFF);
    }

    /// \brief Parse uint8 from string
    /// \param s string that contain uint8
    /// \param base base (10 for decimal, 16 for hex, etc)
    /// \return parsed value
    [[nodiscard]] inline std::uint8_t parse_uint8(const std::string_view s, const std::size_t base = 10) {
        return parse_uint32(s, base) & 0xFF;
    }

    /// \brief Parse bool from string
    /// \param s stirng that contain bool
    /// \return parsed value
    [[nodiscard]] inline bool parse_bool(const std::string_view s) {
        return s == "true" || s == "1";
    }

    namespace detail {
        template <typename Ty, typename TyNoCV = std::remove_cv_t<Ty>>
        struct serializer_ctx {
            constexpr static bool is_int32 = std::is_same_v<TyNoCV, int> || std::is_same_v<TyNoCV, long>;
            constexpr static bool is_uint32 = std::is_same_v<TyNoCV, unsigned int> || std::is_same_v<TyNoCV, unsigned long>;
            constexpr static bool is_int8 = std::is_same_v<TyNoCV, char>;
            constexpr static bool is_uint8 = std::is_same_v<TyNoCV, unsigned char>;

            constexpr static bool is_number = is_int32 || is_uint32 || is_int8 || is_uint8;
            constexpr static bool is_bool = std::is_same_v<TyNoCV, bool>;
        };
    } // namespace detail

    /// \brief Parse the value from string using template
    /// \tparam Ty type that it should return
    /// \param s string
    /// \return parsed value
    template <typename Ty, typename Ctx = detail::serializer_ctx<Ty>>
    [[nodiscard]] Ty parse(const std::string_view s) {
        if constexpr (Ctx::is_int32) {
            return parse_int32(s);
        } else if constexpr (Ctx::is_uint32) {
            return parse_uint32(s);
        } else if constexpr (Ctx::is_bool) {
            return parse_bool(s);
        } else if constexpr (Ctx::is_int8) {
            return parse_int8(s);
        } else if constexpr (Ctx::is_uint8) {
            return parse_uint8(s);
        } else {
            static_assert(types::always_false_v<Ty>, "Unknown type to parse");
            return {};
        }
    }

    /// \brief Serialize value to string
    /// \tparam Ty type that we're serializing
    /// \param value value that we should serialize
    /// \return serialized value
    template <typename Ty, typename Ctx = detail::serializer_ctx<Ty>>
    [[nodiscard]] std::string serialize(const Ty value) {
        if constexpr (Ctx::is_number) {
            return std::to_string(value);
        } else if constexpr (Ctx::is_bool) {
            return value ? "true" : "false";
        } else {
            static_assert(types::always_false_v<Ty>, "Unknown type to serialize");
            return {};
        }
    }

    /// \brief Parse string to the `out` type and store it in the std::any ref
    /// \param out output reference
    /// \param s string that it should parse
    inline void parse_to_any(std::any& out, const std::string_view s) {
        assert(out.has_value());

        const auto hash = out.type().hash_code();

        /// This is ugly, however, i can't calculate typeid(T).hash_code() in constexpr so
        /// no optimized switch cases :shrug: (could be implementation defined)
#define MAKE_CASE(type)                     \
    if (hash == typeid(type).hash_code()) { \
        out.emplace<type>(parse<type>(s));  \
        return;                             \
    }

        MAKE_CASE(int)
        MAKE_CASE(unsigned int)
        MAKE_CASE(long)
        MAKE_CASE(unsigned long)
        MAKE_CASE(bool)

#undef MAKE_CASE

        throw std::runtime_error(std::format("parse_to_any: Unable to parse '{}' -> unsupported type", s));
    }

    /// \brief Serialize any value to string
    /// \param ref any reference
    /// \return serialized string
    [[nodiscard]] inline std::string serialize_any(const std::any& ref) {
        assert(ref.has_value());
        const auto hash = ref.type().hash_code();

/// This is ugly, however, i can't calculate typeid(T).hash_code() in constexpr so
/// no optimized switch cases :shrug: (could be implementation defined)
#define MAKE_CASE(type)                                   \
    if (hash == typeid(type).hash_code()) {               \
        return serialize<type>(std::any_cast<type>(ref)); \
    }

        MAKE_CASE(int)
        MAKE_CASE(unsigned int)
        MAKE_CASE(long)
        MAKE_CASE(unsigned long)
        MAKE_CASE(bool)

#undef MAKE_CASE

        throw std::runtime_error(std::format("parse_to_any: Unable to serialize -> unsupported type"));
    }
} // namespace util::string

```

`src/lib/util/structs.hpp`:

```hpp
#pragma once

// NOLINTBEGIN(bugprone-macro-parentheses)

#define DEFAULT_CTOR(name) constexpr name() = default
#define DEFAULT_DTOR(name) ~name() = default

#define DEFAULT_CTOR_DTOR(name) \
    DEFAULT_CTOR(name);         \
    DEFAULT_DTOR(name)

#define NON_COPYABLE(name)                 \
    name(const name&) = delete;            \
    name& operator=(name const&) = delete; \
    name(name&&) = delete;                 \
    name& operator=(name&&) = delete

#define DEFAULT_COPY(name)                  \
    name(const name&) = default;            \
    name& operator=(name const&) = default; \
    name(name&&) noexcept = default;        \
    name& operator=(name&&) noexcept = default

// NOLINTEND(bugprone-macro-parentheses)

```

`src/lib/util/types.hpp`:

```hpp
#pragma once
#include "memory/address.hpp"
#include "util/structs.hpp"
#include <array>

namespace types {
    template <class Ty, class... Types>
    inline constexpr bool is_any_of_v = std::disjunction_v<std::is_same<Ty, Types>...>;

    template <class... Args>
    auto to_array(Args&&... args) {
        return std::array<std::common_type_t<Args...>, sizeof...(Args)>{std::forward<Args>(args)...};
    }

    using rva_t = memory::address;

    struct range_t {
        rva_t start;
        rva_t end;
    };

    template <typename T>
    class Singleton {
    protected:
        DEFAULT_CTOR_DTOR(Singleton);
        NON_COPYABLE(Singleton);

    public:
        [[nodiscard]] static T& get() {
            static T instance = {};
            return instance;
        }
    };

    /// Used for static assertions
    template <typename = std::monostate> concept always_false_v = false;
} // namespace types

```

`src/tests/analysis/bb_decomp/bb_decomp.llvm.cpp`:

```cpp
#include "tests_util.hpp"

/// Unsupported for now

///
/// x64
///

TEST(BBDecompLLVM, v14_0_6__hello_world__x64) {
    ASSERT_EQ(false, true);
}

TEST(BBDecompLLVM, v14_0_6__loop__x64) {
    ASSERT_EQ(false, true);
}

TEST(BBDecompLLVM, v14_0_6__jump_table_6_1__x64) {
    ASSERT_EQ(false, true);
}

TEST(BBDecompLLVM, v14_0_6__jump_table_6_15__x64) {
    ASSERT_EQ(false, true);
}

TEST(BBDecompLLVM, v14_0_6__jump_table_6_500__x64) {
    ASSERT_EQ(false, true);
}

TEST(BBDecompLLVM, v14_0_6__jump_table_1000_1__x64) {
    ASSERT_EQ(false, true);
}

TEST(BBDecompLLVM, v14_0_6__jump_table_1000_15__x64) {
    ASSERT_EQ(false, true);
}

TEST(BBDecompLLVM, v14_0_6__jump_table_1000_500__x64) {
    ASSERT_EQ(false, true);
}

///
/// x86
///

TEST(BBDecompLLVM, v15_0_0__hello_world__x86) {
    ASSERT_EQ(false, true);
}

TEST(BBDecompLLVM, v15_0_0__loop__x86) {
    ASSERT_EQ(false, true);
}

TEST(BBDecompLLVM, v15_0_0__jump_table_6_1__x86) {
    ASSERT_EQ(false, true);
}

TEST(BBDecompLLVM, v15_0_0__jump_table_6_15__x86) {
    ASSERT_EQ(false, true);
}

TEST(BBDecompLLVM, v15_0_0__jump_table_6_500__x86) {
    ASSERT_EQ(false, true);
}

TEST(BBDecompLLVM, v15_0_0__jump_table_1000_1__x86) {
    ASSERT_EQ(false, true);
}

TEST(BBDecompLLVM, v15_0_0__jump_table_1000_15__x86) {
    ASSERT_EQ(false, true);
}

TEST(BBDecompLLVM, v15_0_0__jump_table_1000_500__x86) {
    ASSERT_EQ(false, true);
}

```

`src/tests/analysis/bb_decomp/bb_decomp.msvc.cpp`:

```cpp
#include "tests_util.hpp"

/// Unsupported for now

///
/// x64
///

TEST(BBDecompMSVC, hello_world__x64) {
    ASSERT_EQ(false, true);
}

TEST(BBDecompMSVC, loop__x64) {
    ASSERT_EQ(false, true);
}

TEST(BBDecompMSVC, jump_table_6_1__x64) {
    ASSERT_EQ(false, true);
}

TEST(BBDecompMSVC, jump_table_6_15__x64) {
    ASSERT_EQ(false, true);
}

TEST(BBDecompMSVC, jump_table_6_500__x64) {
    ASSERT_EQ(false, true);
}

TEST(BBDecompMSVC, jump_table_1000_1__x64) {
    ASSERT_EQ(false, true);
}

TEST(BBDecompMSVC, jump_table_1000_15__x64) {
    ASSERT_EQ(false, true);
}

TEST(BBDecompMSVC, jump_table_1000_500__x64) {
    ASSERT_EQ(false, true);
}

///
/// x86
///

TEST(BBDecompMSVC, hello_world__x86) {
    ASSERT_EQ(false, true);
}

TEST(BBDecompMSVC, loop__x86) {
    ASSERT_EQ(false, true);
}

TEST(BBDecompMSVC, jump_table_6_1__x86) {
    ASSERT_EQ(false, true);
}

TEST(BBDecompMSVC, jump_table_6_15__x86) {
    ASSERT_EQ(false, true);
}

TEST(BBDecompMSVC, jump_table_6_500__x86) {
    ASSERT_EQ(false, true);
}

TEST(BBDecompMSVC, jump_table_1000_1__x86) {
    ASSERT_EQ(false, true);
}

TEST(BBDecompMSVC, jump_table_1000_15__x86) {
    ASSERT_EQ(false, true);
}

TEST(BBDecompMSVC, jump_table_1000_500__x86) {
    ASSERT_EQ(false, true);
}

```

`src/tests/func_parser/map/map.ida.cpp`:

```cpp
#include "tests_util.hpp"

/// Unsupported for now

TEST(MapIDA, v7_7__X64_all) {
    ASSERT_EQ(false, true);
}

TEST(MapIDA, v7_7__X86_all) {
    ASSERT_EQ(false, true);
}

TEST(MapIDA, v7_7__X64_demangle) {
    ASSERT_EQ(false, true);
}

TEST(MapIDA, v7_7__X86_demangle) {
    ASSERT_EQ(false, true);
}

TEST(MapIDA, v7_7__X64_dummy) {
    ASSERT_EQ(false, true);
}

TEST(MapIDA, v7_7__X86_dummy) {
    ASSERT_EQ(false, true);
}

TEST(MapIDA, v7_7__X64_local) {
    ASSERT_EQ(false, true);
}

TEST(MapIDA, v7_7__X86_local) {
    ASSERT_EQ(false, true);
}

TEST(MapIDA, v7_7__X64_seg) {
    ASSERT_EQ(false, true);
}

TEST(MapIDA, v7_7__X86_seg) {
    ASSERT_EQ(false, true);
}

```

`src/tests/func_parser/map/map.llvm.cpp`:

```cpp
#include "tests_util.hpp"

#include <func_parser/map/map.hpp>

/// Unsupported for now

TEST(MapLLVM, v14_0_6__x64) {
    OBFUSCATOR_TEST_START;
    auto symbols = func_parser::map::discover_functions(test::get_resource("map", "llvm_clang_14_0_6_x64.map"));

    ASSERT_EQ(symbols.size(), 118);

    const auto sym_atexit =
        std::find_if(symbols.begin(), symbols.end(), [](const func_parser::function_t& function) -> bool { return function.name == "atexit"; });

    const auto sym_main =
        std::find_if(symbols.begin(), symbols.end(), [](const func_parser::function_t& function) -> bool { return function.name == "main"; });

    ASSERT_NE(sym_atexit, symbols.end());
    ASSERT_NE(sym_main, symbols.end());

    ASSERT_EQ(sym_atexit->rva, 0x1668);
    ASSERT_EQ(sym_main->rva, 0x1000);
}

TEST(MapLLVM, v15_0_0__x86) {
    ASSERT_EQ(false, true);
}

```

`src/tests/func_parser/map/map.msvc.cpp`:

```cpp
#include "tests_util.hpp"

#include <func_parser/map/map.hpp>

TEST(MapMSVC, x64) {
    OBFUSCATOR_TEST_START;
    auto symbols = func_parser::map::discover_functions(test::get_resource("map", "msvc_x64.map"));

    ASSERT_EQ(symbols.size(), 118);

    const auto sym_atexit =
        std::find_if(symbols.begin(), symbols.end(), [](const func_parser::function_t& function) -> bool { return function.name == "atexit"; });

    const auto sym_main =
        std::find_if(symbols.begin(), symbols.end(), [](const func_parser::function_t& function) -> bool { return function.name == "main"; });

    ASSERT_NE(sym_atexit, symbols.end());
    ASSERT_NE(sym_main, symbols.end());

    ASSERT_EQ(sym_atexit->rva, 0x1668);
    ASSERT_EQ(sym_main->rva, 0x1000);
}

TEST(MapMSVC, x86) {
    /// TODO
    ASSERT_EQ(1, 2);
}

```

`src/tests/func_parser/pdb/pdb.llvm.cpp`:

```cpp
#include "tests_util.hpp"

/// Unsupported for now

TEST(PDBLLVM, v14_0_6__x64) {
    ASSERT_EQ(false, true);
}

TEST(PDBLLVM, v15_0_0__x86) {
    ASSERT_EQ(false, true);
}

```

`src/tests/func_parser/pdb/pdb.msvc.cpp`:

```cpp
#include "tests_util.hpp"

/// Unsupported for now

TEST(PDBMSVC, x64) {
    ASSERT_EQ(false, true);
}

TEST(PDBMSVC, x86) {
    ASSERT_EQ(false, true);
}

```

`src/tests/tests_util.hpp`:

```hpp
#pragma once
#include <filesystem>

#include <util/files.hpp>
#include <util/types.hpp>

#include <gtest/gtest.h>

#define OBFUSCATOR_TEST_START test::start()
#define OBFUSCATOR_TEST_OPT_V(v) v.has_value() && v.value()

namespace test {
    // Common test startup stuff
    //
    inline void start() noexcept {
        logger::enabled = false;
    }

    inline std::filesystem::path get_resources_dir() noexcept {
        return OBFUSCATOR_RESOURCES_PATH;
    }

    // get_resource("some_dir", "some_file.dat") -> /resources/some_dir/some_file.dat
    //
    template <typename... TArgs>
    std::filesystem::path get_resource(TArgs... args) {
        // Converting variadic arguments to array
        //
        const auto paths = types::to_array(std::forward<TArgs>(args)...);

        // Resolving path
        //
        std::filesystem::path path = get_resources_dir();
        for (auto& child : paths) {
            path = path / child;
        }

        return path;
    }

    // read_resource("some_dir", "some_file.dat") -> file data from /resources/some_dir/some_file.dat
    //
    template <typename... TArgs>
    std::vector<std::uint8_t> read_resource(TArgs... args) {
        // Resolving path
        //
        const std::filesystem::path path = get_resource(std::forward<TArgs>(args)...);

        // Read the file and return as a result
        //
        return util::read_file(path.wstring());
    }
} // namespace test

```

`todo.txt`:

```txt
28/11/23: Split all this .hpp mess to .cpp(s) in order to reduce the compilation time
28/11/23: Split the bb_decomp logic
30/11/23: Replace all the manual sucessors/predecessors stuff, we should push them automatically or with a single method
19/12/23: Add progress-bar to function linking (prob need to ask ZehMatt how to get some sort of serializer callbacks)

```

`vendor/CMakeLists.txt`:

```txt
# This file is automatically generated from cmake.toml - DO NOT EDIT
# See https://github.com/build-cpp/cmkr for more information

# Create a configure-time dependency on cmake.toml to improve IDE support
if(CMKR_ROOT_PROJECT)
	configure_file(cmake.toml cmake.toml COPYONLY)
endif()

include(FetchContent)

# Fix warnings about DOWNLOAD_EXTRACT_TIMESTAMP
if(POLICY CMP0135)
	cmake_policy(SET CMP0135 NEW)
endif()
if(OBFUSCATOR_BUILD_TESTS) # build-tests
	message(STATUS "Fetching resources (e700be666074f6e21b6ed5920fd26289c6ed9d1f)...")
	FetchContent_Declare(resources SYSTEM
		GIT_REPOSITORY
			"https://github.com/es3n1n/obfuscator-resources.git"
		GIT_TAG
			e700be666074f6e21b6ed5920fd26289c6ed9d1f
	)
	FetchContent_MakeAvailable(resources)

endif()
# Subdirectory: zasm
set(CMKR_CMAKE_FOLDER ${CMAKE_FOLDER})
if(CMAKE_FOLDER)
	set(CMAKE_FOLDER "${CMAKE_FOLDER}/zasm")
else()
	set(CMAKE_FOLDER zasm)
endif()
add_subdirectory(zasm)
set(CMAKE_FOLDER ${CMKR_CMAKE_FOLDER})

# Subdirectory: gtest
set(CMKR_CMAKE_FOLDER ${CMAKE_FOLDER})
if(CMAKE_FOLDER)
	set(CMAKE_FOLDER "${CMAKE_FOLDER}/gtest")
else()
	set(CMAKE_FOLDER gtest)
endif()
add_subdirectory(gtest)
set(CMAKE_FOLDER ${CMKR_CMAKE_FOLDER})

# Subdirectory: linux-pe
set(CMKR_CMAKE_FOLDER ${CMAKE_FOLDER})
if(CMAKE_FOLDER)
	set(CMAKE_FOLDER "${CMAKE_FOLDER}/linux-pe")
else()
	set(CMAKE_FOLDER linux-pe)
endif()
add_subdirectory(linux-pe)
set(CMAKE_FOLDER ${CMKR_CMAKE_FOLDER})

# Subdirectory: magic_enum
set(CMKR_CMAKE_FOLDER ${CMAKE_FOLDER})
if(CMAKE_FOLDER)
	set(CMAKE_FOLDER "${CMAKE_FOLDER}/magic_enum")
else()
	set(CMAKE_FOLDER magic_enum)
endif()
add_subdirectory(magic_enum)
set(CMAKE_FOLDER ${CMKR_CMAKE_FOLDER})


```

`vendor/cmake.toml`:

```toml
[subdir.zasm]
[subdir.gtest]
[subdir.linux-pe]
[subdir.magic_enum]

[fetch-content.resources]
condition = "build-tests"
git = "https://github.com/es3n1n/obfuscator-resources.git"
tag = "e700be666074f6e21b6ed5920fd26289c6ed9d1f"

```