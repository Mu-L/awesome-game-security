Project Path: arc_pkurth_D3D12Renderer_q_6itk25

Source Tree:

```txt
arc_pkurth_D3D12Renderer_q_6itk25
├── LICENSE
├── README.md
├── ext
│   ├── concurrentqueue
│   │   ├── LICENSE.txt
│   │   └── concurrentqueue.h
│   ├── d3d12memoryallocator
│   │   ├── D3D12MemAlloc.cpp
│   │   ├── D3D12MemAlloc.h
│   │   └── LICENSE.txt
│   ├── directxtex
│   ├── dx
│   │   └── d3dx12.h
│   ├── entt
│   ├── fontawesome
│   │   ├── IconsFontAwesome5.h
│   │   ├── licence.txt
│   │   └── list.h
│   ├── half
│   │   ├── half.c
│   │   ├── half.h
│   │   └── int_insn.h
│   ├── imgui
│   ├── lib
│   │   └── WinPixEventRuntime.lib
│   ├── nanoflann
│   │   ├── COPYING.txt
│   │   └── nanoflann.hpp
│   ├── nanosvg
│   │   ├── nanosvg.h
│   │   └── nanosvgrast.h
│   ├── pix
│   │   ├── PIXEvents.h
│   │   ├── PIXEventsCommon.h
│   │   ├── ThirdPartyNotices.txt
│   │   ├── license.txt
│   │   ├── pix3.h
│   │   └── pix3_win.h
│   └── yaml-cpp
├── generate2019.bat
├── generate2022.bat
├── imgui.ini
├── learning
│   ├── convert_model_to_c++.py
│   ├── learn_locomotion.py
│   ├── loco_env.py
│   ├── util.py
│   └── vec_monitor.py
├── premake
│   ├── LICENSE.txt
│   └── premake5.exe
├── premake5.lua
├── resources
│   ├── fonts
│   │   ├── icons
│   │   │   ├── fa-regular-400.ttf
│   │   │   ├── fa-solid-900.ttf
│   │   │   └── licence.txt
│   │   └── opensans
│   │       ├── LICENSE.txt
│   │       ├── OpenSans-Bold.ttf
│   │       ├── OpenSans-BoldItalic.ttf
│   │       ├── OpenSans-ExtraBold.ttf
│   │       ├── OpenSans-ExtraBoldItalic.ttf
│   │       ├── OpenSans-Italic.ttf
│   │       ├── OpenSans-Light.ttf
│   │       ├── OpenSans-LightItalic.ttf
│   │       ├── OpenSans-Regular.ttf
│   │       ├── OpenSans-SemiBold.ttf
│   │       └── OpenSans-SemiBoldItalic.ttf
│   ├── icons
│   │   ├── icons_ui.svg
│   │   └── project_icon.png
│   └── noise
│       └── blue_noise.dds
├── shaders
│   ├── atmosphere_cs.hlsl
│   ├── bitonic_sort
│   │   ├── bitonic_inner_sort_float_cs.hlsl
│   │   ├── bitonic_inner_sort_uint_cs.hlsl
│   │   ├── bitonic_outer_sort_float_cs.hlsl
│   │   ├── bitonic_outer_sort_uint_cs.hlsl
│   │   ├── bitonic_pre_sort_float_cs.hlsl
│   │   ├── bitonic_pre_sort_uint_cs.hlsl
│   │   └── common
│   │       ├── bitonic_inner_sort.hlsli
│   │       ├── bitonic_outer_sort.hlsli
│   │       ├── bitonic_pre_sort.hlsli
│   │       └── bitonic_start_sort_cs.hlsl
│   ├── blit_ps.hlsl
│   ├── common
│   │   ├── brdf.hlsli
│   │   ├── camera.hlsli
│   │   ├── color.hlsli
│   │   ├── cs.hlsli
│   │   ├── indirect.hlsli
│   │   ├── light_probe.hlsli
│   │   ├── light_source.hlsli
│   │   ├── lighting.hlsli
│   │   ├── material.hlsli
│   │   ├── math.hlsli
│   │   ├── normal.hlsli
│   │   ├── particles.hlsli
│   │   ├── procedural_sky.hlsli
│   │   ├── random.hlsli
│   │   ├── raytracing.hlsli
│   │   └── transform.hlsli
│   ├── fullscreen_triangle_vs.hlsl
│   ├── geometry
│   │   ├── default_pbr_ps.hlsl
│   │   ├── default_pbr_transparent_ps.hlsl
│   │   ├── default_vs.hlsl
│   │   ├── depth_only_alpha_cutout_ps.hlsl
│   │   ├── depth_only_alpha_cutout_vs.hlsl
│   │   ├── depth_only_ps.hlsl
│   │   ├── depth_only_vs.hlsl
│   │   ├── shadow_point_light_ps.hlsl
│   │   ├── shadow_point_light_vs.hlsl
│   │   └── shadow_vs.hlsl
│   ├── grass
│   │   ├── grass_create_draw_calls_cs.hlsl
│   │   ├── grass_depth_only_vs.hlsl
│   │   ├── grass_generation_cs.hlsl
│   │   ├── grass_no_depth_prepass_ps.hlsl
│   │   ├── grass_no_depth_prepass_vs.hlsl
│   │   ├── grass_ps.hlsl
│   │   ├── grass_vertex.hlsli
│   │   └── grass_vs.hlsl
│   ├── light_culling
│   │   ├── light_culling_cs.hlsl
│   │   └── world_space_tiled_frusta_cs.hlsl
│   ├── light_probe
│   │   ├── light_probe_grid_visualization_ps.hlsl
│   │   ├── light_probe_grid_visualization_vs.hlsl
│   │   ├── light_probe_ray_visualization_ps.hlsl
│   │   ├── light_probe_ray_visualization_vs.hlsl
│   │   ├── light_probe_test_sample_ps.hlsl
│   │   ├── light_probe_test_sample_vs.hlsl
│   │   ├── light_probe_trace_rts.hlsl
│   │   ├── light_probe_update_depth_cs.hlsl
│   │   └── light_probe_update_irradiance_cs.hlsl
│   ├── mesh_shaders
│   │   ├── glass_ps.hlsl
│   │   ├── koch
│   │   │   ├── koch_as.hlsl
│   │   │   ├── koch_common.hlsli
│   │   │   └── koch_ms.hlsl
│   │   ├── marching_cubes
│   │   │   ├── marching_cubes_as.hlsli
│   │   │   ├── marching_cubes_common.hlsli
│   │   │   └── marching_cubes_ms.hlsli
│   │   ├── mesh_shader_ps.hlsl
│   │   ├── meshlet_ms.hlsl
│   │   └── meta_ball
│   │       ├── meta_ball_as.hlsl
│   │       ├── meta_ball_common.hlsli
│   │       └── meta_ball_ms.hlsl
│   ├── outline
│   │   ├── outline_ps.hlsl
│   │   └── outline_vs.hlsl
│   ├── particle_systems
│   │   ├── boid_particle_system.hlsli
│   │   ├── debris_particle_system.hlsli
│   │   ├── fire_particle_system.hlsli
│   │   └── smoke_particle_system.hlsli
│   ├── particles
│   │   ├── particle_emit.hlsli
│   │   ├── particle_ps.hlsli
│   │   ├── particle_sim.hlsli
│   │   ├── particle_start_cs.hlsl
│   │   └── particle_vs.hlsli
│   ├── post_processing
│   │   ├── blit_cs.hlsl
│   │   ├── bloom_combine_cs.hlsl
│   │   ├── bloom_threshold_cs.hlsl
│   │   ├── depth_sobel_cs.hlsl
│   │   ├── dilation_cs.hlsl
│   │   ├── erosion_cs.hlsl
│   │   ├── gaussian_blur_13x13_float4_cs.hlsl
│   │   ├── gaussian_blur_13x13_float_cs.hlsl
│   │   ├── gaussian_blur_5x5_float4_cs.hlsl
│   │   ├── gaussian_blur_5x5_float_cs.hlsl
│   │   ├── gaussian_blur_9x9_float4_cs.hlsl
│   │   ├── gaussian_blur_9x9_float_cs.hlsl
│   │   ├── gaussian_blur_common.hlsli
│   │   ├── hbao_cs.hlsl
│   │   ├── hierarchical_linear_depth_cs.hlsl
│   │   ├── morphology_common.hlsli
│   │   ├── present_cs.hlsl
│   │   ├── shadow_blur_common.hlsli
│   │   ├── shadow_blur_x_cs.hlsl
│   │   ├── shadow_blur_y_cs.hlsl
│   │   ├── specular_ambient_cs.hlsl
│   │   ├── sss_cs.hlsl
│   │   ├── taa_cs.hlsl
│   │   └── tonemap_cs.hlsl
│   ├── proc_placement
│   │   ├── proc_placement_create_draw_calls_cs.hlsl
│   │   ├── proc_placement_create_transforms_cs.hlsl
│   │   ├── proc_placement_generate_points_cs.hlsl
│   │   ├── proc_placement_points_ps.hlsl
│   │   ├── proc_placement_points_vs.hlsl
│   │   └── proc_placement_prefix_sum_cs.hlsl
│   ├── raytracing
│   │   └── path_tracing_rts.hlsl
│   ├── reflections
│   │   ├── rt_reflections_rts.hlsl
│   │   ├── ssr_median_blur_cs.hlsl
│   │   ├── ssr_raycast_cs.hlsl
│   │   ├── ssr_resolve_cs.hlsl
│   │   └── ssr_temporal_cs.hlsl
│   ├── rs
│   │   ├── bitonic_sort_rs.hlsli
│   │   ├── default_pbr_rs.hlsli
│   │   ├── depth_only_rs.hlsli
│   │   ├── grass_rs.hlsli
│   │   ├── light_culling_rs.hlsli
│   │   ├── light_probe_rs.hlsli
│   │   ├── outline_rs.hlsli
│   │   ├── particles_rs.hlsli
│   │   ├── post_processing_rs.hlsli
│   │   ├── proc_placement_rs.hlsli
│   │   ├── rt_reflections_rs.hlsli
│   │   ├── skinning_rs.hlsli
│   │   ├── sky_rs.hlsli
│   │   ├── ssr_rs.hlsli
│   │   ├── terrain_rs.hlsli
│   │   ├── tree_rs.hlsli
│   │   ├── visualization_rs.hlsli
│   │   └── water_rs.hlsli
│   ├── shadow_map_copy_ps.hlsl
│   ├── skinning
│   │   ├── cloth_skinning_cs.hlsl
│   │   └── skinning_cs.hlsl
│   ├── sky
│   │   ├── sky_procedural_ps.hlsl
│   │   ├── sky_texture_ps.hlsl
│   │   └── sky_vs.hlsl
│   ├── terrain
│   │   ├── terrain_depth_only_vs.hlsl
│   │   ├── terrain_generation_cs.hlsl
│   │   ├── terrain_height.hlsli
│   │   ├── terrain_outline_vs.hlsl
│   │   ├── terrain_ps.hlsl
│   │   ├── terrain_shadow_vs.hlsl
│   │   └── terrain_vs.hlsl
│   ├── texture_preprocessing
│   │   ├── equirectangular_to_cubemap_cs.hlsl
│   │   ├── generate_mips_cs.hlsl
│   │   ├── integrate_brdf_cs.hlsl
│   │   ├── procedural_sky_to_irradiance_cs.hlsl
│   │   ├── textured_sky_to_irradiance_cs.hlsl
│   │   ├── textured_sky_to_irradiance_sh_cs.hlsl
│   │   └── textured_sky_to_prefiltered_radiance_cs.hlsl
│   ├── tree
│   │   ├── tree_ps.hlsl
│   │   └── tree_vs.hlsl
│   ├── visualization
│   │   ├── flat_simple_ps.hlsl
│   │   ├── flat_simple_vs.hlsl
│   │   ├── flat_unlit_position_color_vs.hlsl
│   │   ├── flat_unlit_position_vs.hlsl
│   │   ├── flat_unlit_ps.hlsl
│   │   └── sun_shadow_cascades_cs.hlsl
│   └── water
│       ├── water_ps.hlsl
│       └── water_vs.hlsl
└── src
    ├── animation
    │   ├── animation.cpp
    │   ├── animation.h
    │   ├── skinning.cpp
    │   └── skinning.h
    ├── application.cpp
    ├── application.h
    ├── asset
    │   ├── asset.cpp
    │   ├── asset.h
    │   ├── bin.cpp
    │   ├── deflate.cpp
    │   ├── deflate.h
    │   ├── fbx.cpp
    │   ├── file_registry.cpp
    │   ├── file_registry.h
    │   ├── image.cpp
    │   ├── image.h
    │   ├── io.h
    │   ├── mesh_postprocessing.cpp
    │   ├── mesh_postprocessing.h
    │   ├── model_asset.cpp
    │   ├── model_asset.h
    │   ├── obj.cpp
    │   └── ply.cpp
    ├── audio
    │   ├── audio.cpp
    │   ├── audio.h
    │   ├── channel.cpp
    │   ├── channel.h
    │   ├── reverb.h
    │   ├── sound.cpp
    │   ├── sound.h
    │   ├── sound_management.cpp
    │   ├── sound_management.h
    │   └── synth.h
    ├── core
    │   ├── block_allocator.cpp
    │   ├── block_allocator.h
    │   ├── camera.cpp
    │   ├── camera.h
    │   ├── camera_controller.cpp
    │   ├── camera_controller.h
    │   ├── color.h
    │   ├── coroutine.h
    │   ├── cpu_profiling.cpp
    │   ├── cpu_profiling.h
    │   ├── file_system.cpp
    │   ├── file_system.h
    │   ├── hash.h
    │   ├── imgui.cpp
    │   ├── imgui.h
    │   ├── input.h
    │   ├── job_system.cpp
    │   ├── job_system.h
    │   ├── log.cpp
    │   ├── log.h
    │   ├── math.cpp
    │   ├── math.h
    │   ├── math_simd.h
    │   ├── memory.cpp
    │   ├── memory.h
    │   ├── nearest_neighbor.cpp
    │   ├── nearest_neighbor.h
    │   ├── perlin.cpp
    │   ├── perlin.h
    │   ├── preprocessor_for_each.h
    │   ├── profiling_internal.cpp
    │   ├── profiling_internal.h
    │   ├── random.h
    │   ├── reflect.h
    │   ├── simd.h
    │   ├── soa.h
    │   ├── string.h
    │   ├── system.cpp
    │   ├── system.h
    │   ├── threading.h
    │   └── yaml.h
    ├── dx
    │   ├── dx.h
    │   ├── dx_barrier_batcher.cpp
    │   ├── dx_barrier_batcher.h
    │   ├── dx_buffer.cpp
    │   ├── dx_buffer.h
    │   ├── dx_command_list.cpp
    │   ├── dx_command_list.h
    │   ├── dx_command_queue.cpp
    │   ├── dx_command_queue.h
    │   ├── dx_context.cpp
    │   ├── dx_context.h
    │   ├── dx_descriptor.cpp
    │   ├── dx_descriptor.h
    │   ├── dx_descriptor_allocation.cpp
    │   ├── dx_descriptor_allocation.h
    │   ├── dx_dynamic_descriptor_heap.cpp
    │   ├── dx_dynamic_descriptor_heap.h
    │   ├── dx_pipeline.cpp
    │   ├── dx_pipeline.h
    │   ├── dx_profiling.cpp
    │   ├── dx_profiling.h
    │   ├── dx_query.cpp
    │   ├── dx_query.h
    │   ├── dx_render_target.h
    │   ├── dx_texture.cpp
    │   ├── dx_texture.h
    │   ├── dx_upload_buffer.cpp
    │   └── dx_upload_buffer.h
    ├── editor
    │   ├── asset_editor_panel.cpp
    │   ├── asset_editor_panel.h
    │   ├── editor.cpp
    │   ├── editor.h
    │   ├── editor_icons.h
    │   ├── file_browser.cpp
    │   ├── file_browser.h
    │   ├── file_dialog.cpp
    │   ├── file_dialog.h
    │   ├── transformation_gizmo.cpp
    │   ├── transformation_gizmo.h
    │   ├── undo_stack.cpp
    │   └── undo_stack.h
    ├── geometry
    │   ├── mesh.cpp
    │   ├── mesh.h
    │   ├── mesh_builder.cpp
    │   └── mesh_builder.h
    ├── learning
    │   ├── learned_locomotion.cpp
    │   └── learned_locomotion.h
    ├── main.cpp
    ├── particles
    │   ├── boid_particle_system.cpp
    │   ├── boid_particle_system.h
    │   ├── debris_particle_system.cpp
    │   ├── debris_particle_system.h
    │   ├── fire_particle_system.cpp
    │   ├── fire_particle_system.h
    │   ├── particle_systems.cpp
    │   ├── particle_systems.h
    │   ├── particles.cpp
    │   ├── particles.h
    │   ├── smoke_particle_system.cpp
    │   └── smoke_particle_system.h
    ├── pch.cpp
    ├── pch.h
    ├── physics
    │   ├── bounding_volumes.cpp
    │   ├── bounding_volumes.h
    │   ├── bounding_volumes_simd.h
    │   ├── cloth.cpp
    │   ├── cloth.h
    │   ├── collision_broad.cpp
    │   ├── collision_broad.h
    │   ├── collision_epa.cpp
    │   ├── collision_epa.h
    │   ├── collision_gjk.cpp
    │   ├── collision_gjk.h
    │   ├── collision_narrow.cpp
    │   ├── collision_narrow.h
    │   ├── collision_sat.h
    │   ├── constraints.cpp
    │   ├── constraints.h
    │   ├── heightmap_collision.cpp
    │   ├── heightmap_collision.h
    │   ├── island.cpp
    │   ├── island.h
    │   ├── physics.cpp
    │   ├── physics.h
    │   ├── ragdoll.cpp
    │   ├── ragdoll.h
    │   ├── rigid_body.cpp
    │   ├── rigid_body.h
    │   ├── vehicle.cpp
    │   └── vehicle.h
    ├── rendering
    │   ├── bitonic_sort.cpp
    │   ├── bitonic_sort.h
    │   ├── debug_visualization.cpp
    │   ├── debug_visualization.h
    │   ├── depth_prepass.cpp
    │   ├── depth_prepass.h
    │   ├── light_probe.cpp
    │   ├── light_probe.h
    │   ├── light_source.cpp
    │   ├── light_source.h
    │   ├── main_renderer.cpp
    │   ├── main_renderer.h
    │   ├── material.h
    │   ├── mesh_shader.cpp
    │   ├── mesh_shader.h
    │   ├── outline.cpp
    │   ├── outline.h
    │   ├── path_tracing.cpp
    │   ├── path_tracing.h
    │   ├── pbr.cpp
    │   ├── pbr.h
    │   ├── pbr_environment.cpp
    │   ├── pbr_environment.h
    │   ├── pbr_material.cpp
    │   ├── pbr_material.h
    │   ├── pbr_raytracer.cpp
    │   ├── pbr_raytracer.h
    │   ├── raytraced_reflections.cpp
    │   ├── raytraced_reflections.h
    │   ├── raytracer.cpp
    │   ├── raytracer.h
    │   ├── raytracing.cpp
    │   ├── raytracing.h
    │   ├── raytracing_binding_table.h
    │   ├── raytracing_tlas.cpp
    │   ├── raytracing_tlas.h
    │   ├── render_algorithms.cpp
    │   ├── render_algorithms.h
    │   ├── render_command.h
    │   ├── render_command_buffer.h
    │   ├── render_pass.h
    │   ├── render_resources.cpp
    │   ├── render_resources.h
    │   ├── render_utils.cpp
    │   ├── render_utils.h
    │   ├── shadow_map.cpp
    │   ├── shadow_map.h
    │   ├── shadow_map_cache.cpp
    │   ├── shadow_map_cache.h
    │   ├── texture_preprocessing.cpp
    │   └── texture_preprocessing.h
    ├── scene
    │   ├── components.h
    │   ├── scene.cpp
    │   ├── scene.h
    │   ├── scene_rendering.cpp
    │   ├── scene_rendering.h
    │   ├── serialization_binary.cpp
    │   ├── serialization_binary.h
    │   ├── serialization_yaml.cpp
    │   └── serialization_yaml.h
    ├── terrain
    │   ├── grass.cpp
    │   ├── grass.h
    │   ├── heightmap_collider.cpp
    │   ├── heightmap_collider.h
    │   ├── proc_placement.cpp
    │   ├── proc_placement.h
    │   ├── terrain.cpp
    │   ├── terrain.h
    │   ├── tree.cpp
    │   ├── tree.h
    │   ├── water.cpp
    │   └── water.h
    └── window
        ├── dx_window.cpp
        ├── dx_window.h
        ├── software_window.cpp
        ├── software_window.h
        ├── window.cpp
        └── window.h

```

`LICENSE`:

```
MIT License

Copyright (c) 2021 pkurth

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# D3D12Renderer

This project implements a custom rendering engine build from the ground up in C++ using Direct3D 12. 
It supports some "new" features like raytracing, mesh shaders etc. 

It also features a custom written physics engine written completely from scratch.

## Table of Contents
- [Graphics](#graphics-features)
- [Physics](#physics-features)
- [Other](#other-features)
- [System Requirements](#system-requirements)
- [Build Instructions](#build-instructions)
- [Locomotion Learning](#locomotion-learning)

## Graphics features

<img align="right" src="assets/samples/raster.png" width="300"/>
<img align="right" width="100%" />

<img align="right" src="assets/samples/raster2.png" width="300"/>
<img align="right" width="100%" />

<img align="right" src="assets/samples/raster3.png" width="300"/>

<p align="left">

- Forward+ rendering
- Physically based rendering
- Dynamic lights and dynamic shadows
	- Sun (with cascaded shadow maps)
	- Point lights
	- Spot lights
- Decals
- Post processing stack
	- Temporal anti-aliasing
	- Horizon-based ambient occlusion
	- Screen space shadows
	- Bloom
	- Filmic tone-mapping
	- Sharpening
- Tiled light and decal culling
- Screen space reflections
- Real-time raytracing (DXR)
- Integrated path tracer
- Skeletal animation
- Mesh shaders
- Hot-reloading of shaders

</p>

<img width="100%" />

It has an integrated (albeit pretty simple) path tracer (using hardware-accelerated raytracing), which in the future will be integrated into the real-time pipeline in some form to compute global illumination effects.

<img src="assets/samples/path_trace.png" width="512"/><br>


## Physics features

<a href="https://youtu.be/FqwCIoI-c_A"><img align="right" src="https://img.youtube.com/vi/FqwCIoI-c_A/mqdefault.jpg" width="300" /></a>
<img align="right" width="100%" />
<a href="https://youtu.be/YLASi_r13cc"><img align="right" src="https://img.youtube.com/vi/YLASi_r13cc/mqdefault.jpg" width="300" /></a>
<img align="right" width="100%" />
<a href="https://youtu.be/3I1dQZXHvrQ"><img align="right" src="https://img.youtube.com/vi/3I1dQZXHvrQ/mqdefault.jpg" width="300" /></a>
<img align="right" width="100%" />
<a href="https://youtu.be/j3n3yseyKFU"><img align="right" src="https://img.youtube.com/vi/j3n3yseyKFU/mqdefault.jpg" width="300" /></a>

<p align="left">
Images to the right are links to YouTube videos showcasing the various physics features.

- Rigid body dynamics
- Cloth simulation
- Various constraints between rigid bodies (many with limits and motors)
  - Distance
  - Ball joints
  - Hinge joints
  - Cone twist
  - Slider
- Various collider types
  - Spheres
  - Capsules
  - Cylinders
  - AABBs and OBBs
  - Arbitrary convex hulls
- SIMD support for constraint resolution (SSE4 and AVX2)
- Ragdolls
- Vehicle physics
- Machine learning for ragdoll locomotion. Based on [Machine Learning Summit: Ragdoll Motion Matching](https://www.youtube.com/watch?v=JZKaqQKcAnw) and [DReCon: Data-Driven Responsive Control of Physics-Based Characters](https://static-wordpress.akamaized.net/montreal.ubisoft.com/wp-content/uploads/2019/11/13214229/DReCon.pdf) by Ubisoft. See [below](#locomotion-learning).

</p>

## Other features

- Editor tools
- Integrated CPU and GPU profiler (with multi-threading support)

## System Requirements

Since this project uses Direct3D 12 as the only rendering backend, the only supported platforms are Windows 10 or higher. 
The project is only tested with Visual Studio 2019 and 2022, and only on NVIDIA GPUs.

For mesh shaders you will need the Windows 10 SDK version 10.0.19041.0 or higher.
This can be downloaded using the Visual Studio Installer.
If you only have an older version of the SDK installed, the build system will automatically disable mesh shaders. 
To run you will need the Windows 10 May 2020 Update (20H1) or newer.
If these requirements are not met, you should still be able to build and run the program, but without mesh shader support.

If you want to use raytracing or mesh shaders, you need a compatible NVIDIA GPU. 
For raytracing these are the GPUs with the Pascal architecture or newer.
For mesh shaders you will need a Turing GPU or newer.

The project files are currently generated with the AVX2 instruction set. 
If your processor does not support this, set another instruction set (either in Visual Studio or in premake5.lua).

All other dependencies (external libraries) either come directly with the source code or in the form of submodules.


## Build Instructions

<a href="https://youtu.be/Ey90fI_2MFU"><img align="right" src="https://img.youtube.com/vi/Ey90fI_2MFU/mqdefault.jpg" width="300" /></a>

<p align="left">

I have tried to keep the build process as simple as possible.
Therefore you will not need any build tools installed on your machine.
The project uses Premake, but all you need comes with the source.
See also the video linked to the right for detailed instructions.

- Clone the repository and make sure to clone with submodules. 
- Double-click either the _generate2019.bat_ or _generate2022.bat_ file in the root directory to generate a Visual Studio 2019 or 2022 solution, respectively.
The build process will automatically enable and disable certain features based on your installed GPU and the available Windows 10 SDK.
- Open the solution and build.
- If you add new source files (or shaders), re-run the _generate\*.bat_ file.

The assets seen in the screenshots above are not included with the source code. 

</p>

## Locomotion Learning

<a href="https://youtu.be/IVmj8vP_oQM"><img align="right" src="https://img.youtube.com/vi/IVmj8vP_oQM/mqdefault.jpg" width="300" /></a>
<img align="right" width="100%" />

<p align="left">
This project implements a very simplified version of learned ragdoll locomotion.
The ragdoll is constructed of various separate rigid bodies, connected with hinge constraints on elbows and knees, and cone twist constraints on shoulders, hips, neck etc.
Currently the ragdoll only learns to stand upright, by controlling forces applied to all these constraints.
It can withstand minor forces.

The neural network has a very simple structure.
It only features two fully connected layers with a tanh activation.
It is trained using the [Proximal Policy Optimization Algorithm (PPO)](https://arxiv.org/abs/1707.06347), implemented in [`stable-baselines3`](https://stable-baselines3.readthedocs.io/en/master/index.html).

### Learning

The training is implemented in PyTorch, so you'll need to install Python 3.x and some packages.
I am using Miniconda, but the steps below should work fine with just Python (replace `conda` calls with `pip`).

To set up the enviroment, in the Anaconda Powershell execute the following commands (depending on installation, maybe you'll need to start as administrator):
- `conda create --name learning`
- `conda activate learning`
- `conda install pytorch cpuonly -c pytorch` (I'm training on the CPU, but feel free to experiment with training on CUDA)
- `pip install stable-baselines3`


To start the training:
- Build the C++ code (see [above](#build-instructions)) in a Release build. This builds a separate DLL (_Physics-DLL.dll_), which is accessed by the Python code.
- In the Anaconda Powershell, navigate to root directory of this project.
- `python ./learning/learn_locomotion.py`
- Wait a couple of hours.
- You can cancel and continue the training at any time. Just set the variable `start_from_pretrained` inside _learning/learn_locomotion.py_ to `True`.

### Inference

I didn't feel like linking against the huge `libtorch` C++ library for inference of such a simple network, so I wrote the inference myself.
Thus, after learning, execute the following command to export the layer weights and biases from Python to a text file: `python ./learning/convert_model_to_c++.py`.
Then rebuild the C++ code.
The weights then get compiled automatically into the C++ executable.

</p>


```

`ext/concurrentqueue/LICENSE.txt`:

```txt
Simplified BSD License:

Copyright (c) 2013-2016, Cameron Desrochers. All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

I have also chosen to dual-license under the Boost Software License as an alternative to the Simplified BSD license above:

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute, and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the Software is furnished to do so, all subject to the following:

The copyright notices in the Software and this entire statement, including the above license grant, this restriction and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all derivative works of the Software, unless such copies or derivative works are solely in the form of machine-executable object code generated by a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```

`ext/concurrentqueue/concurrentqueue.h`:

```h
// Provides a C++11 implementation of a multi-producer, multi-consumer lock-free queue.
// An overview, including benchmark results, is provided here:
//     http://moodycamel.com/blog/2014/a-fast-general-purpose-lock-free-queue-for-c++
// The full design is also described in excruciating detail at:
//    http://moodycamel.com/blog/2014/detailed-design-of-a-lock-free-queue

// Simplified BSD license:
// Copyright (c) 2013-2020, Cameron Desrochers.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
// - Redistributions of source code must retain the above copyright notice, this list of
// conditions and the following disclaimer.
// - Redistributions in binary form must reproduce the above copyright notice, this list of
// conditions and the following disclaimer in the documentation and/or other materials
// provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
// THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
// OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
// TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Also dual-licensed under the Boost Software License (see LICENSE.md)

#pragma once

#if defined(__GNUC__) && !defined(__INTEL_COMPILER)
// Disable -Wconversion warnings (spuriously triggered when Traits::size_t and
// Traits::index_t are set to < 32 bits, causing integer promotion, causing warnings
// upon assigning any computed values)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wconversion"

#ifdef MCDBGQ_USE_RELACY
#pragma GCC diagnostic ignored "-Wint-to-pointer-cast"
#endif
#endif

#if defined(_MSC_VER) && (!defined(_HAS_CXX17) || !_HAS_CXX17)
// VS2019 with /W4 warns about constant conditional expressions but unless /std=c++17 or higher
// does not support `if constexpr`, so we have no choice but to simply disable the warning
#pragma warning(push)
#pragma warning(disable: 4127)  // conditional expression is constant
#endif

#if defined(__APPLE__)
#include "TargetConditionals.h"
#endif

#ifdef MCDBGQ_USE_RELACY
#include "relacy/relacy_std.hpp"
#include "relacy_shims.h"
// We only use malloc/free anyway, and the delete macro messes up `= delete` method declarations.
// We'll override the default trait malloc ourselves without a macro.
#undef new
#undef delete
#undef malloc
#undef free
#else
#include <atomic>		// Requires C++11. Sorry VS2010.
#include <cassert>
#endif
#include <cstddef>              // for max_align_t
#include <cstdint>
#include <cstdlib>
#include <type_traits>
#include <algorithm>
#include <utility>
#include <limits>
#include <climits>		// for CHAR_BIT
#include <array>
#include <thread>		// partly for __WINPTHREADS_VERSION if on MinGW-w64 w/ POSIX threading
#include <mutex>        // used for thread exit synchronization

// Platform-specific definitions of a numeric thread ID type and an invalid value
namespace moodycamel { namespace details {
	template<typename thread_id_t> struct thread_id_converter {
		typedef thread_id_t thread_id_numeric_size_t;
		typedef thread_id_t thread_id_hash_t;
		static thread_id_hash_t prehash(thread_id_t const& x) { return x; }
	};
} }
#if defined(MCDBGQ_USE_RELACY)
namespace moodycamel { namespace details {
	typedef std::uint32_t thread_id_t;
	static const thread_id_t invalid_thread_id  = 0xFFFFFFFFU;
	static const thread_id_t invalid_thread_id2 = 0xFFFFFFFEU;
	static inline thread_id_t thread_id() { return rl::thread_index(); }
} }
#elif defined(_WIN32) || defined(__WINDOWS__) || defined(__WIN32__)
// No sense pulling in windows.h in a header, we'll manually declare the function
// we use and rely on backwards-compatibility for this not to break
extern "C" __declspec(dllimport) unsigned long __stdcall GetCurrentThreadId(void);
namespace moodycamel { namespace details {
	static_assert(sizeof(unsigned long) == sizeof(std::uint32_t), "Expected size of unsigned long to be 32 bits on Windows");
	typedef std::uint32_t thread_id_t;
	static const thread_id_t invalid_thread_id  = 0;			// See http://blogs.msdn.com/b/oldnewthing/archive/2004/02/23/78395.aspx
	static const thread_id_t invalid_thread_id2 = 0xFFFFFFFFU;	// Not technically guaranteed to be invalid, but is never used in practice. Note that all Win32 thread IDs are presently multiples of 4.
	static inline thread_id_t thread_id() { return static_cast<thread_id_t>(::GetCurrentThreadId()); }
} }
#elif defined(__arm__) || defined(_M_ARM) || defined(__aarch64__) || (defined(__APPLE__) && TARGET_OS_IPHONE) || defined(MOODYCAMEL_NO_THREAD_LOCAL)
namespace moodycamel { namespace details {
	static_assert(sizeof(std::thread::id) == 4 || sizeof(std::thread::id) == 8, "std::thread::id is expected to be either 4 or 8 bytes");
	
	typedef std::thread::id thread_id_t;
	static const thread_id_t invalid_thread_id;         // Default ctor creates invalid ID

	// Note we don't define a invalid_thread_id2 since std::thread::id doesn't have one; it's
	// only used if MOODYCAMEL_CPP11_THREAD_LOCAL_SUPPORTED is defined anyway, which it won't
	// be.
	static inline thread_id_t thread_id() { return std::this_thread::get_id(); }

	template<std::size_t> struct thread_id_size { };
	template<> struct thread_id_size<4> { typedef std::uint32_t numeric_t; };
	template<> struct thread_id_size<8> { typedef std::uint64_t numeric_t; };

	template<> struct thread_id_converter<thread_id_t> {
		typedef thread_id_size<sizeof(thread_id_t)>::numeric_t thread_id_numeric_size_t;
#ifndef __APPLE__
		typedef std::size_t thread_id_hash_t;
#else
		typedef thread_id_numeric_size_t thread_id_hash_t;
#endif

		static thread_id_hash_t prehash(thread_id_t const& x)
		{
#ifndef __APPLE__
			return std::hash<std::thread::id>()(x);
#else
			return *reinterpret_cast<thread_id_hash_t const*>(&x);
#endif
		}
	};
} }
#else
// Use a nice trick from this answer: http://stackoverflow.com/a/8438730/21475
// In order to get a numeric thread ID in a platform-independent way, we use a thread-local
// static variable's address as a thread identifier :-)
#if defined(__GNUC__) || defined(__INTEL_COMPILER)
#define MOODYCAMEL_THREADLOCAL __thread
#elif defined(_MSC_VER)
#define MOODYCAMEL_THREADLOCAL __declspec(thread)
#else
// Assume C++11 compliant compiler
#define MOODYCAMEL_THREADLOCAL thread_local
#endif
namespace moodycamel { namespace details {
	typedef std::uintptr_t thread_id_t;
	static const thread_id_t invalid_thread_id  = 0;		// Address can't be nullptr
	static const thread_id_t invalid_thread_id2 = 1;		// Member accesses off a null pointer are also generally invalid. Plus it's not aligned.
	inline thread_id_t thread_id() { static MOODYCAMEL_THREADLOCAL int x; return reinterpret_cast<thread_id_t>(&x); }
} }
#endif

// Constexpr if
#ifndef MOODYCAMEL_CONSTEXPR_IF
#if (defined(_MSC_VER) && defined(_HAS_CXX17) && _HAS_CXX17) || __cplusplus > 201402L
#define MOODYCAMEL_CONSTEXPR_IF if constexpr
#define MOODYCAMEL_MAYBE_UNUSED [[maybe_unused]]
#else
#define MOODYCAMEL_CONSTEXPR_IF if
#define MOODYCAMEL_MAYBE_UNUSED
#endif
#endif

// Exceptions
#ifndef MOODYCAMEL_EXCEPTIONS_ENABLED
#if (defined(_MSC_VER) && defined(_CPPUNWIND)) || (defined(__GNUC__) && defined(__EXCEPTIONS)) || (!defined(_MSC_VER) && !defined(__GNUC__))
#define MOODYCAMEL_EXCEPTIONS_ENABLED
#endif
#endif
#ifdef MOODYCAMEL_EXCEPTIONS_ENABLED
#define MOODYCAMEL_TRY try
#define MOODYCAMEL_CATCH(...) catch(__VA_ARGS__)
#define MOODYCAMEL_RETHROW throw
#define MOODYCAMEL_THROW(expr) throw (expr)
#else
#define MOODYCAMEL_TRY MOODYCAMEL_CONSTEXPR_IF (true)
#define MOODYCAMEL_CATCH(...) else MOODYCAMEL_CONSTEXPR_IF (false)
#define MOODYCAMEL_RETHROW
#define MOODYCAMEL_THROW(expr)
#endif

#ifndef MOODYCAMEL_NOEXCEPT
#if !defined(MOODYCAMEL_EXCEPTIONS_ENABLED)
#define MOODYCAMEL_NOEXCEPT
#define MOODYCAMEL_NOEXCEPT_CTOR(type, valueType, expr) true
#define MOODYCAMEL_NOEXCEPT_ASSIGN(type, valueType, expr) true
#elif defined(_MSC_VER) && defined(_NOEXCEPT) && _MSC_VER < 1800
// VS2012's std::is_nothrow_[move_]constructible is broken and returns true when it shouldn't :-(
// We have to assume *all* non-trivial constructors may throw on VS2012!
#define MOODYCAMEL_NOEXCEPT _NOEXCEPT
#define MOODYCAMEL_NOEXCEPT_CTOR(type, valueType, expr) (std::is_rvalue_reference<valueType>::value && std::is_move_constructible<type>::value ? std::is_trivially_move_constructible<type>::value : std::is_trivially_copy_constructible<type>::value)
#define MOODYCAMEL_NOEXCEPT_ASSIGN(type, valueType, expr) ((std::is_rvalue_reference<valueType>::value && std::is_move_assignable<type>::value ? std::is_trivially_move_assignable<type>::value || std::is_nothrow_move_assignable<type>::value : std::is_trivially_copy_assignable<type>::value || std::is_nothrow_copy_assignable<type>::value) && MOODYCAMEL_NOEXCEPT_CTOR(type, valueType, expr))
#elif defined(_MSC_VER) && defined(_NOEXCEPT) && _MSC_VER < 1900
#define MOODYCAMEL_NOEXCEPT _NOEXCEPT
#define MOODYCAMEL_NOEXCEPT_CTOR(type, valueType, expr) (std::is_rvalue_reference<valueType>::value && std::is_move_constructible<type>::value ? std::is_trivially_move_constructible<type>::value || std::is_nothrow_move_constructible<type>::value : std::is_trivially_copy_constructible<type>::value || std::is_nothrow_copy_constructible<type>::value)
#define MOODYCAMEL_NOEXCEPT_ASSIGN(type, valueType, expr) ((std::is_rvalue_reference<valueType>::value && std::is_move_assignable<type>::value ? std::is_trivially_move_assignable<type>::value || std::is_nothrow_move_assignable<type>::value : std::is_trivially_copy_assignable<type>::value || std::is_nothrow_copy_assignable<type>::value) && MOODYCAMEL_NOEXCEPT_CTOR(type, valueType, expr))
#else
#define MOODYCAMEL_NOEXCEPT noexcept
#define MOODYCAMEL_NOEXCEPT_CTOR(type, valueType, expr) noexcept(expr)
#define MOODYCAMEL_NOEXCEPT_ASSIGN(type, valueType, expr) noexcept(expr)
#endif
#endif

#ifndef MOODYCAMEL_CPP11_THREAD_LOCAL_SUPPORTED
#ifdef MCDBGQ_USE_RELACY
#define MOODYCAMEL_CPP11_THREAD_LOCAL_SUPPORTED
#else
// VS2013 doesn't support `thread_local`, and MinGW-w64 w/ POSIX threading has a crippling bug: http://sourceforge.net/p/mingw-w64/bugs/445
// g++ <=4.7 doesn't support thread_local either.
// Finally, iOS/ARM doesn't have support for it either, and g++/ARM allows it to compile but it's unconfirmed to actually work
#if (!defined(_MSC_VER) || _MSC_VER >= 1900) && (!defined(__MINGW32__) && !defined(__MINGW64__) || !defined(__WINPTHREADS_VERSION)) && (!defined(__GNUC__) || __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)) && (!defined(__APPLE__) || !TARGET_OS_IPHONE) && !defined(__arm__) && !defined(_M_ARM) && !defined(__aarch64__)
// Assume `thread_local` is fully supported in all other C++11 compilers/platforms
#define MOODYCAMEL_CPP11_THREAD_LOCAL_SUPPORTED    // tentatively enabled for now; years ago several users report having problems with it on
#endif
#endif
#endif

// VS2012 doesn't support deleted functions. 
// In this case, we declare the function normally but don't define it. A link error will be generated if the function is called.
#ifndef MOODYCAMEL_DELETE_FUNCTION
#if defined(_MSC_VER) && _MSC_VER < 1800
#define MOODYCAMEL_DELETE_FUNCTION
#else
#define MOODYCAMEL_DELETE_FUNCTION = delete
#endif
#endif

namespace moodycamel { namespace details {
#ifndef MOODYCAMEL_ALIGNAS
// VS2013 doesn't support alignas or alignof, and align() requires a constant literal
#if defined(_MSC_VER) && _MSC_VER <= 1800
#define MOODYCAMEL_ALIGNAS(alignment) __declspec(align(alignment))
#define MOODYCAMEL_ALIGNOF(obj) __alignof(obj)
#define MOODYCAMEL_ALIGNED_TYPE_LIKE(T, obj) typename details::Vs2013Aligned<std::alignment_of<obj>::value, T>::type
	template<int Align, typename T> struct Vs2013Aligned { };  // default, unsupported alignment
	template<typename T> struct Vs2013Aligned<1, T> { typedef __declspec(align(1)) T type; };
	template<typename T> struct Vs2013Aligned<2, T> { typedef __declspec(align(2)) T type; };
	template<typename T> struct Vs2013Aligned<4, T> { typedef __declspec(align(4)) T type; };
	template<typename T> struct Vs2013Aligned<8, T> { typedef __declspec(align(8)) T type; };
	template<typename T> struct Vs2013Aligned<16, T> { typedef __declspec(align(16)) T type; };
	template<typename T> struct Vs2013Aligned<32, T> { typedef __declspec(align(32)) T type; };
	template<typename T> struct Vs2013Aligned<64, T> { typedef __declspec(align(64)) T type; };
	template<typename T> struct Vs2013Aligned<128, T> { typedef __declspec(align(128)) T type; };
	template<typename T> struct Vs2013Aligned<256, T> { typedef __declspec(align(256)) T type; };
#else
	template<typename T> struct identity { typedef T type; };
#define MOODYCAMEL_ALIGNAS(alignment) alignas(alignment)
#define MOODYCAMEL_ALIGNOF(obj) alignof(obj)
#define MOODYCAMEL_ALIGNED_TYPE_LIKE(T, obj) alignas(alignof(obj)) typename details::identity<T>::type
#endif
#endif
} }


// TSAN can false report races in lock-free code.  To enable TSAN to be used from projects that use this one,
// we can apply per-function compile-time suppression.
// See https://clang.llvm.org/docs/ThreadSanitizer.html#has-feature-thread-sanitizer
#define MOODYCAMEL_NO_TSAN
#if defined(__has_feature)
 #if __has_feature(thread_sanitizer)
  #undef MOODYCAMEL_NO_TSAN
  #define MOODYCAMEL_NO_TSAN __attribute__((no_sanitize("thread")))
 #endif // TSAN
#endif // TSAN

// Compiler-specific likely/unlikely hints
namespace moodycamel { namespace details {
#if defined(__GNUC__)
	static inline bool (likely)(bool x) { return __builtin_expect((x), true); }
	static inline bool (unlikely)(bool x) { return __builtin_expect((x), false); }
#else
	static inline bool (likely)(bool x) { return x; }
	static inline bool (unlikely)(bool x) { return x; }
#endif
} }

#ifdef MOODYCAMEL_QUEUE_INTERNAL_DEBUG
#include "internal/concurrentqueue_internal_debug.h"
#endif

namespace moodycamel {
namespace details {
	template<typename T>
	struct const_numeric_max {
		static_assert(std::is_integral<T>::value, "const_numeric_max can only be used with integers");
		static const T value = std::numeric_limits<T>::is_signed
			? (static_cast<T>(1) << (sizeof(T) * CHAR_BIT - 1)) - static_cast<T>(1)
			: static_cast<T>(-1);
	};

#if defined(__GLIBCXX__)
	typedef ::max_align_t std_max_align_t;      // libstdc++ forgot to add it to std:: for a while
#else
	typedef std::max_align_t std_max_align_t;   // Others (e.g. MSVC) insist it can *only* be accessed via std::
#endif

	// Some platforms have incorrectly set max_align_t to a type with <8 bytes alignment even while supporting
	// 8-byte aligned scalar values (*cough* 32-bit iOS). Work around this with our own union. See issue #64.
	typedef union {
		std_max_align_t x;
		long long y;
		void* z;
	} max_align_t;
}

// Default traits for the ConcurrentQueue. To change some of the
// traits without re-implementing all of them, inherit from this
// struct and shadow the declarations you wish to be different;
// since the traits are used as a template type parameter, the
// shadowed declarations will be used where defined, and the defaults
// otherwise.
struct ConcurrentQueueDefaultTraits
{
	// General-purpose size type. std::size_t is strongly recommended.
	typedef std::size_t size_t;
	
	// The type used for the enqueue and dequeue indices. Must be at least as
	// large as size_t. Should be significantly larger than the number of elements
	// you expect to hold at once, especially if you have a high turnover rate;
	// for example, on 32-bit x86, if you expect to have over a hundred million
	// elements or pump several million elements through your queue in a very
	// short space of time, using a 32-bit type *may* trigger a race condition.
	// A 64-bit int type is recommended in that case, and in practice will
	// prevent a race condition no matter the usage of the queue. Note that
	// whether the queue is lock-free with a 64-int type depends on the whether
	// std::atomic<std::uint64_t> is lock-free, which is platform-specific.
	typedef std::size_t index_t;
	
	// Internally, all elements are enqueued and dequeued from multi-element
	// blocks; this is the smallest controllable unit. If you expect few elements
	// but many producers, a smaller block size should be favoured. For few producers
	// and/or many elements, a larger block size is preferred. A sane default
	// is provided. Must be a power of 2.
	static const size_t BLOCK_SIZE = 32;
	
	// For explicit producers (i.e. when using a producer token), the block is
	// checked for being empty by iterating through a list of flags, one per element.
	// For large block sizes, this is too inefficient, and switching to an atomic
	// counter-based approach is faster. The switch is made for block sizes strictly
	// larger than this threshold.
	static const size_t EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD = 32;
	
	// How many full blocks can be expected for a single explicit producer? This should
	// reflect that number's maximum for optimal performance. Must be a power of 2.
	static const size_t EXPLICIT_INITIAL_INDEX_SIZE = 32;
	
	// How many full blocks can be expected for a single implicit producer? This should
	// reflect that number's maximum for optimal performance. Must be a power of 2.
	static const size_t IMPLICIT_INITIAL_INDEX_SIZE = 32;
	
	// The initial size of the hash table mapping thread IDs to implicit producers.
	// Note that the hash is resized every time it becomes half full.
	// Must be a power of two, and either 0 or at least 1. If 0, implicit production
	// (using the enqueue methods without an explicit producer token) is disabled.
	static const size_t INITIAL_IMPLICIT_PRODUCER_HASH_SIZE = 32;
	
	// Controls the number of items that an explicit consumer (i.e. one with a token)
	// must consume before it causes all consumers to rotate and move on to the next
	// internal queue.
	static const std::uint32_t EXPLICIT_CONSUMER_CONSUMPTION_QUOTA_BEFORE_ROTATE = 256;
	
	// The maximum number of elements (inclusive) that can be enqueued to a sub-queue.
	// Enqueue operations that would cause this limit to be surpassed will fail. Note
	// that this limit is enforced at the block level (for performance reasons), i.e.
	// it's rounded up to the nearest block size.
	static const size_t MAX_SUBQUEUE_SIZE = details::const_numeric_max<size_t>::value;

	// The number of times to spin before sleeping when waiting on a semaphore.
	// Recommended values are on the order of 1000-10000 unless the number of
	// consumer threads exceeds the number of idle cores (in which case try 0-100).
	// Only affects instances of the BlockingConcurrentQueue.
	static const int MAX_SEMA_SPINS = 10000;

	// Whether to recycle dynamically-allocated blocks into an internal free list or
	// not. If false, only pre-allocated blocks (controlled by the constructor
	// arguments) will be recycled, and all others will be `free`d back to the heap.
	// Note that blocks consumed by explicit producers are only freed on destruction
	// of the queue (not following destruction of the token) regardless of this trait.
	static const bool RECYCLE_ALLOCATED_BLOCKS = false;

	
#ifndef MCDBGQ_USE_RELACY
	// Memory allocation can be customized if needed.
	// malloc should return nullptr on failure, and handle alignment like std::malloc.
#if defined(malloc) || defined(free)
	// Gah, this is 2015, stop defining macros that break standard code already!
	// Work around malloc/free being special macros:
	static inline void* WORKAROUND_malloc(size_t size) { return malloc(size); }
	static inline void WORKAROUND_free(void* ptr) { return free(ptr); }
	static inline void* (malloc)(size_t size) { return WORKAROUND_malloc(size); }
	static inline void (free)(void* ptr) { return WORKAROUND_free(ptr); }
#else
	static inline void* malloc(size_t size) { return std::malloc(size); }
	static inline void free(void* ptr) { return std::free(ptr); }
#endif
#else
	// Debug versions when running under the Relacy race detector (ignore
	// these in user code)
	static inline void* malloc(size_t size) { return rl::rl_malloc(size, $); }
	static inline void free(void* ptr) { return rl::rl_free(ptr, $); }
#endif
};


// When producing or consuming many elements, the most efficient way is to:
//    1) Use one of the bulk-operation methods of the queue with a token
//    2) Failing that, use the bulk-operation methods without a token
//    3) Failing that, create a token and use that with the single-item methods
//    4) Failing that, use the single-parameter methods of the queue
// Having said that, don't create tokens willy-nilly -- ideally there should be
// a maximum of one token per thread (of each kind).
struct ProducerToken;
struct ConsumerToken;

template<typename T, typename Traits> class ConcurrentQueue;
template<typename T, typename Traits> class BlockingConcurrentQueue;
class ConcurrentQueueTests;


namespace details
{
	struct ConcurrentQueueProducerTypelessBase
	{
		ConcurrentQueueProducerTypelessBase* next;
		std::atomic<bool> inactive;
		ProducerToken* token;
		
		ConcurrentQueueProducerTypelessBase()
			: next(nullptr), inactive(false), token(nullptr)
		{
		}
	};
	
	template<bool use32> struct _hash_32_or_64 {
		static inline std::uint32_t hash(std::uint32_t h)
		{
			// MurmurHash3 finalizer -- see https://code.google.com/p/smhasher/source/browse/trunk/MurmurHash3.cpp
			// Since the thread ID is already unique, all we really want to do is propagate that
			// uniqueness evenly across all the bits, so that we can use a subset of the bits while
			// reducing collisions significantly
			h ^= h >> 16;
			h *= 0x85ebca6b;
			h ^= h >> 13;
			h *= 0xc2b2ae35;
			return h ^ (h >> 16);
		}
	};
	template<> struct _hash_32_or_64<1> {
		static inline std::uint64_t hash(std::uint64_t h)
		{
			h ^= h >> 33;
			h *= 0xff51afd7ed558ccd;
			h ^= h >> 33;
			h *= 0xc4ceb9fe1a85ec53;
			return h ^ (h >> 33);
		}
	};
	template<std::size_t size> struct hash_32_or_64 : public _hash_32_or_64<(size > 4)> {  };
	
	static inline size_t hash_thread_id(thread_id_t id)
	{
		static_assert(sizeof(thread_id_t) <= 8, "Expected a platform where thread IDs are at most 64-bit values");
		return static_cast<size_t>(hash_32_or_64<sizeof(thread_id_converter<thread_id_t>::thread_id_hash_t)>::hash(
			thread_id_converter<thread_id_t>::prehash(id)));
	}
	
	template<typename T>
	static inline bool circular_less_than(T a, T b)
	{
		static_assert(std::is_integral<T>::value && !std::numeric_limits<T>::is_signed, "circular_less_than is intended to be used only with unsigned integer types");
		return static_cast<T>(a - b) > static_cast<T>(static_cast<T>(1) << (static_cast<T>(sizeof(T) * CHAR_BIT - 1)));
		// Note: extra parens around rhs of operator<< is MSVC bug: https://developercommunity2.visualstudio.com/t/C4554-triggers-when-both-lhs-and-rhs-is/10034931
		//       silencing the bug requires #pragma warning(disable: 4554) around the calling code and has no effect when done here.
	}
	
	template<typename U>
	static inline char* align_for(char* ptr)
	{
		const std::size_t alignment = std::alignment_of<U>::value;
		return ptr + (alignment - (reinterpret_cast<std::uintptr_t>(ptr) % alignment)) % alignment;
	}

	template<typename T>
	static inline T ceil_to_pow_2(T x)
	{
		static_assert(std::is_integral<T>::value && !std::numeric_limits<T>::is_signed, "ceil_to_pow_2 is intended to be used only with unsigned integer types");

		// Adapted from http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2
		--x;
		x |= x >> 1;
		x |= x >> 2;
		x |= x >> 4;
		for (std::size_t i = 1; i < sizeof(T); i <<= 1) {
			x |= x >> (i << 3);
		}
		++x;
		return x;
	}
	
	template<typename T>
	static inline void swap_relaxed(std::atomic<T>& left, std::atomic<T>& right)
	{
		T temp = std::move(left.load(std::memory_order_relaxed));
		left.store(std::move(right.load(std::memory_order_relaxed)), std::memory_order_relaxed);
		right.store(std::move(temp), std::memory_order_relaxed);
	}
	
	template<typename T>
	static inline T const& nomove(T const& x)
	{
		return x;
	}
	
	template<bool Enable>
	struct nomove_if
	{
		template<typename T>
		static inline T const& eval(T const& x)
		{
			return x;
		}
	};
	
	template<>
	struct nomove_if<false>
	{
		template<typename U>
		static inline auto eval(U&& x)
			-> decltype(std::forward<U>(x))
		{
			return std::forward<U>(x);
		}
	};
	
	template<typename It>
	static inline auto deref_noexcept(It& it) MOODYCAMEL_NOEXCEPT -> decltype(*it)
	{
		return *it;
	}
	
#if defined(__clang__) || !defined(__GNUC__) || __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
	template<typename T> struct is_trivially_destructible : std::is_trivially_destructible<T> { };
#else
	template<typename T> struct is_trivially_destructible : std::has_trivial_destructor<T> { };
#endif
	
#ifdef MOODYCAMEL_CPP11_THREAD_LOCAL_SUPPORTED
#ifdef MCDBGQ_USE_RELACY
	typedef RelacyThreadExitListener ThreadExitListener;
	typedef RelacyThreadExitNotifier ThreadExitNotifier;
#else
	class ThreadExitNotifier;

	struct ThreadExitListener
	{
		typedef void (*callback_t)(void*);
		callback_t callback;
		void* userData;
		
		ThreadExitListener* next;		// reserved for use by the ThreadExitNotifier
		ThreadExitNotifier* chain;		// reserved for use by the ThreadExitNotifier
	};

	class ThreadExitNotifier
	{
	public:
		static void subscribe(ThreadExitListener* listener)
		{
			auto& tlsInst = instance();
			std::lock_guard<std::mutex> guard(mutex());
			listener->next = tlsInst.tail;
			listener->chain = &tlsInst;
			tlsInst.tail = listener;
		}
		
		static void unsubscribe(ThreadExitListener* listener)
		{
			std::lock_guard<std::mutex> guard(mutex());
			if (!listener->chain) {
				return;  // race with ~ThreadExitNotifier
			}
			auto& tlsInst = *listener->chain;
			listener->chain = nullptr;
			ThreadExitListener** prev = &tlsInst.tail;
			for (auto ptr = tlsInst.tail; ptr != nullptr; ptr = ptr->next) {
				if (ptr == listener) {
					*prev = ptr->next;
					break;
				}
				prev = &ptr->next;
			}
		}
		
	private:
		ThreadExitNotifier() : tail(nullptr) { }
		ThreadExitNotifier(ThreadExitNotifier const&) MOODYCAMEL_DELETE_FUNCTION;
		ThreadExitNotifier& operator=(ThreadExitNotifier const&) MOODYCAMEL_DELETE_FUNCTION;
		
		~ThreadExitNotifier()
		{
			// This thread is about to exit, let everyone know!
			assert(this == &instance() && "If this assert fails, you likely have a buggy compiler! Change the preprocessor conditions such that MOODYCAMEL_CPP11_THREAD_LOCAL_SUPPORTED is no longer defined.");
			std::lock_guard<std::mutex> guard(mutex());
			for (auto ptr = tail; ptr != nullptr; ptr = ptr->next) {
				ptr->chain = nullptr;
				ptr->callback(ptr->userData);
			}
		}
		
		// Thread-local
		static inline ThreadExitNotifier& instance()
		{
			static thread_local ThreadExitNotifier notifier;
			return notifier;
		}

		static inline std::mutex& mutex()
		{
			// Must be static because the ThreadExitNotifier could be destroyed while unsubscribe is called
			static std::mutex mutex;
			return mutex;
		}
		
	private:
		ThreadExitListener* tail;
	};
#endif
#endif
	
	template<typename T> struct static_is_lock_free_num { enum { value = 0 }; };
	template<> struct static_is_lock_free_num<signed char> { enum { value = ATOMIC_CHAR_LOCK_FREE }; };
	template<> struct static_is_lock_free_num<short> { enum { value = ATOMIC_SHORT_LOCK_FREE }; };
	template<> struct static_is_lock_free_num<int> { enum { value = ATOMIC_INT_LOCK_FREE }; };
	template<> struct static_is_lock_free_num<long> { enum { value = ATOMIC_LONG_LOCK_FREE }; };
	template<> struct static_is_lock_free_num<long long> { enum { value = ATOMIC_LLONG_LOCK_FREE }; };
	template<typename T> struct static_is_lock_free : static_is_lock_free_num<typename std::make_signed<T>::type> {  };
	template<> struct static_is_lock_free<bool> { enum { value = ATOMIC_BOOL_LOCK_FREE }; };
	template<typename U> struct static_is_lock_free<U*> { enum { value = ATOMIC_POINTER_LOCK_FREE }; };
}


struct ProducerToken
{
	template<typename T, typename Traits>
	explicit ProducerToken(ConcurrentQueue<T, Traits>& queue);
	
	template<typename T, typename Traits>
	explicit ProducerToken(BlockingConcurrentQueue<T, Traits>& queue);
	
	ProducerToken(ProducerToken&& other) MOODYCAMEL_NOEXCEPT
		: producer(other.producer)
	{
		other.producer = nullptr;
		if (producer != nullptr) {
			producer->token = this;
		}
	}
	
	inline ProducerToken& operator=(ProducerToken&& other) MOODYCAMEL_NOEXCEPT
	{
		swap(other);
		return *this;
	}
	
	void swap(ProducerToken& other) MOODYCAMEL_NOEXCEPT
	{
		std::swap(producer, other.producer);
		if (producer != nullptr) {
			producer->token = this;
		}
		if (other.producer != nullptr) {
			other.producer->token = &other;
		}
	}
	
	// A token is always valid unless:
	//     1) Memory allocation failed during construction
	//     2) It was moved via the move constructor
	//        (Note: assignment does a swap, leaving both potentially valid)
	//     3) The associated queue was destroyed
	// Note that if valid() returns true, that only indicates
	// that the token is valid for use with a specific queue,
	// but not which one; that's up to the user to track.
	inline bool valid() const { return producer != nullptr; }
	
	~ProducerToken()
	{
		if (producer != nullptr) {
			producer->token = nullptr;
			producer->inactive.store(true, std::memory_order_release);
		}
	}
	
	// Disable copying and assignment
	ProducerToken(ProducerToken const&) MOODYCAMEL_DELETE_FUNCTION;
	ProducerToken& operator=(ProducerToken const&) MOODYCAMEL_DELETE_FUNCTION;
	
private:
	template<typename T, typename Traits> friend class ConcurrentQueue;
	friend class ConcurrentQueueTests;
	
protected:
	details::ConcurrentQueueProducerTypelessBase* producer;
};


struct ConsumerToken
{
	template<typename T, typename Traits>
	explicit ConsumerToken(ConcurrentQueue<T, Traits>& q);
	
	template<typename T, typename Traits>
	explicit ConsumerToken(BlockingConcurrentQueue<T, Traits>& q);
	
	ConsumerToken(ConsumerToken&& other) MOODYCAMEL_NOEXCEPT
		: initialOffset(other.initialOffset), lastKnownGlobalOffset(other.lastKnownGlobalOffset), itemsConsumedFromCurrent(other.itemsConsumedFromCurrent), currentProducer(other.currentProducer), desiredProducer(other.desiredProducer)
	{
	}
	
	inline ConsumerToken& operator=(ConsumerToken&& other) MOODYCAMEL_NOEXCEPT
	{
		swap(other);
		return *this;
	}
	
	void swap(ConsumerToken& other) MOODYCAMEL_NOEXCEPT
	{
		std::swap(initialOffset, other.initialOffset);
		std::swap(lastKnownGlobalOffset, other.lastKnownGlobalOffset);
		std::swap(itemsConsumedFromCurrent, other.itemsConsumedFromCurrent);
		std::swap(currentProducer, other.currentProducer);
		std::swap(desiredProducer, other.desiredProducer);
	}
	
	// Disable copying and assignment
	ConsumerToken(ConsumerToken const&) MOODYCAMEL_DELETE_FUNCTION;
	ConsumerToken& operator=(ConsumerToken const&) MOODYCAMEL_DELETE_FUNCTION;

private:
	template<typename T, typename Traits> friend class ConcurrentQueue;
	friend class ConcurrentQueueTests;
	
private: // but shared with ConcurrentQueue
	std::uint32_t initialOffset;
	std::uint32_t lastKnownGlobalOffset;
	std::uint32_t itemsConsumedFromCurrent;
	details::ConcurrentQueueProducerTypelessBase* currentProducer;
	details::ConcurrentQueueProducerTypelessBase* desiredProducer;
};

// Need to forward-declare this swap because it's in a namespace.
// See http://stackoverflow.com/questions/4492062/why-does-a-c-friend-class-need-a-forward-declaration-only-in-other-namespaces
template<typename T, typename Traits>
inline void swap(typename ConcurrentQueue<T, Traits>::ImplicitProducerKVP& a, typename ConcurrentQueue<T, Traits>::ImplicitProducerKVP& b) MOODYCAMEL_NOEXCEPT;


template<typename T, typename Traits = ConcurrentQueueDefaultTraits>
class ConcurrentQueue
{
public:
	typedef ::moodycamel::ProducerToken producer_token_t;
	typedef ::moodycamel::ConsumerToken consumer_token_t;
	
	typedef typename Traits::index_t index_t;
	typedef typename Traits::size_t size_t;
	
	static const size_t BLOCK_SIZE = static_cast<size_t>(Traits::BLOCK_SIZE);
	static const size_t EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD = static_cast<size_t>(Traits::EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD);
	static const size_t EXPLICIT_INITIAL_INDEX_SIZE = static_cast<size_t>(Traits::EXPLICIT_INITIAL_INDEX_SIZE);
	static const size_t IMPLICIT_INITIAL_INDEX_SIZE = static_cast<size_t>(Traits::IMPLICIT_INITIAL_INDEX_SIZE);
	static const size_t INITIAL_IMPLICIT_PRODUCER_HASH_SIZE = static_cast<size_t>(Traits::INITIAL_IMPLICIT_PRODUCER_HASH_SIZE);
	static const std::uint32_t EXPLICIT_CONSUMER_CONSUMPTION_QUOTA_BEFORE_ROTATE = static_cast<std::uint32_t>(Traits::EXPLICIT_CONSUMER_CONSUMPTION_QUOTA_BEFORE_ROTATE);
#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable: 4307)		// + integral constant overflow (that's what the ternary expression is for!)
#pragma warning(disable: 4309)		// static_cast: Truncation of constant value
#endif
	static const size_t MAX_SUBQUEUE_SIZE = (details::const_numeric_max<size_t>::value - static_cast<size_t>(Traits::MAX_SUBQUEUE_SIZE) < BLOCK_SIZE) ? details::const_numeric_max<size_t>::value : ((static_cast<size_t>(Traits::MAX_SUBQUEUE_SIZE) + (BLOCK_SIZE - 1)) / BLOCK_SIZE * BLOCK_SIZE);
#ifdef _MSC_VER
#pragma warning(pop)
#endif

	static_assert(!std::numeric_limits<size_t>::is_signed && std::is_integral<size_t>::value, "Traits::size_t must be an unsigned integral type");
	static_assert(!std::numeric_limits<index_t>::is_signed && std::is_integral<index_t>::value, "Traits::index_t must be an unsigned integral type");
	static_assert(sizeof(index_t) >= sizeof(size_t), "Traits::index_t must be at least as wide as Traits::size_t");
	static_assert((BLOCK_SIZE > 1) && !(BLOCK_SIZE & (BLOCK_SIZE - 1)), "Traits::BLOCK_SIZE must be a power of 2 (and at least 2)");
	static_assert((EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD > 1) && !(EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD & (EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD - 1)), "Traits::EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD must be a power of 2 (and greater than 1)");
	static_assert((EXPLICIT_INITIAL_INDEX_SIZE > 1) && !(EXPLICIT_INITIAL_INDEX_SIZE & (EXPLICIT_INITIAL_INDEX_SIZE - 1)), "Traits::EXPLICIT_INITIAL_INDEX_SIZE must be a power of 2 (and greater than 1)");
	static_assert((IMPLICIT_INITIAL_INDEX_SIZE > 1) && !(IMPLICIT_INITIAL_INDEX_SIZE & (IMPLICIT_INITIAL_INDEX_SIZE - 1)), "Traits::IMPLICIT_INITIAL_INDEX_SIZE must be a power of 2 (and greater than 1)");
	static_assert((INITIAL_IMPLICIT_PRODUCER_HASH_SIZE == 0) || !(INITIAL_IMPLICIT_PRODUCER_HASH_SIZE & (INITIAL_IMPLICIT_PRODUCER_HASH_SIZE - 1)), "Traits::INITIAL_IMPLICIT_PRODUCER_HASH_SIZE must be a power of 2");
	static_assert(INITIAL_IMPLICIT_PRODUCER_HASH_SIZE == 0 || INITIAL_IMPLICIT_PRODUCER_HASH_SIZE >= 1, "Traits::INITIAL_IMPLICIT_PRODUCER_HASH_SIZE must be at least 1 (or 0 to disable implicit enqueueing)");

public:
	// Creates a queue with at least `capacity` element slots; note that the
	// actual number of elements that can be inserted without additional memory
	// allocation depends on the number of producers and the block size (e.g. if
	// the block size is equal to `capacity`, only a single block will be allocated
	// up-front, which means only a single producer will be able to enqueue elements
	// without an extra allocation -- blocks aren't shared between producers).
	// This method is not thread safe -- it is up to the user to ensure that the
	// queue is fully constructed before it starts being used by other threads (this
	// includes making the memory effects of construction visible, possibly with a
	// memory barrier).
	explicit ConcurrentQueue(size_t capacity = 32 * BLOCK_SIZE)
		: producerListTail(nullptr),
		producerCount(0),
		initialBlockPoolIndex(0),
		nextExplicitConsumerId(0),
		globalExplicitConsumerOffset(0)
	{
		implicitProducerHashResizeInProgress.clear(std::memory_order_relaxed);
		populate_initial_implicit_producer_hash();
		populate_initial_block_list(capacity / BLOCK_SIZE + ((capacity & (BLOCK_SIZE - 1)) == 0 ? 0 : 1));
		
#ifdef MOODYCAMEL_QUEUE_INTERNAL_DEBUG
		// Track all the producers using a fully-resolved typed list for
		// each kind; this makes it possible to debug them starting from
		// the root queue object (otherwise wacky casts are needed that
		// don't compile in the debugger's expression evaluator).
		explicitProducers.store(nullptr, std::memory_order_relaxed);
		implicitProducers.store(nullptr, std::memory_order_relaxed);
#endif
	}
	
	// Computes the correct amount of pre-allocated blocks for you based
	// on the minimum number of elements you want available at any given
	// time, and the maximum concurrent number of each type of producer.
	ConcurrentQueue(size_t minCapacity, size_t maxExplicitProducers, size_t maxImplicitProducers)
		: producerListTail(nullptr),
		producerCount(0),
		initialBlockPoolIndex(0),
		nextExplicitConsumerId(0),
		globalExplicitConsumerOffset(0)
	{
		implicitProducerHashResizeInProgress.clear(std::memory_order_relaxed);
		populate_initial_implicit_producer_hash();
		size_t blocks = (((minCapacity + BLOCK_SIZE - 1) / BLOCK_SIZE) - 1) * (maxExplicitProducers + 1) + 2 * (maxExplicitProducers + maxImplicitProducers);
		populate_initial_block_list(blocks);
		
#ifdef MOODYCAMEL_QUEUE_INTERNAL_DEBUG
		explicitProducers.store(nullptr, std::memory_order_relaxed);
		implicitProducers.store(nullptr, std::memory_order_relaxed);
#endif
	}
	
	// Note: The queue should not be accessed concurrently while it's
	// being deleted. It's up to the user to synchronize this.
	// This method is not thread safe.
	~ConcurrentQueue()
	{
		// Destroy producers
		auto ptr = producerListTail.load(std::memory_order_relaxed);
		while (ptr != nullptr) {
			auto next = ptr->next_prod();
			if (ptr->token != nullptr) {
				ptr->token->producer = nullptr;
			}
			destroy(ptr);
			ptr = next;
		}
		
		// Destroy implicit producer hash tables
		MOODYCAMEL_CONSTEXPR_IF (INITIAL_IMPLICIT_PRODUCER_HASH_SIZE != 0) {
			auto hash = implicitProducerHash.load(std::memory_order_relaxed);
			while (hash != nullptr) {
				auto prev = hash->prev;
				if (prev != nullptr) {		// The last hash is part of this object and was not allocated dynamically
					for (size_t i = 0; i != hash->capacity; ++i) {
						hash->entries[i].~ImplicitProducerKVP();
					}
					hash->~ImplicitProducerHash();
					(Traits::free)(hash);
				}
				hash = prev;
			}
		}
		
		// Destroy global free list
		auto block = freeList.head_unsafe();
		while (block != nullptr) {
			auto next = block->freeListNext.load(std::memory_order_relaxed);
			if (block->dynamicallyAllocated) {
				destroy(block);
			}
			block = next;
		}
		
		// Destroy initial free list
		destroy_array(initialBlockPool, initialBlockPoolSize);
	}

	// Disable copying and copy assignment
	ConcurrentQueue(ConcurrentQueue const&) MOODYCAMEL_DELETE_FUNCTION;
	ConcurrentQueue& operator=(ConcurrentQueue const&) MOODYCAMEL_DELETE_FUNCTION;
	
	// Moving is supported, but note that it is *not* a thread-safe operation.
	// Nobody can use the queue while it's being moved, and the memory effects
	// of that move must be propagated to other threads before they can use it.
	// Note: When a queue is moved, its tokens are still valid but can only be
	// used with the destination queue (i.e. semantically they are moved along
	// with the queue itself).
	ConcurrentQueue(ConcurrentQueue&& other) MOODYCAMEL_NOEXCEPT
		: producerListTail(other.producerListTail.load(std::memory_order_relaxed)),
		producerCount(other.producerCount.load(std::memory_order_relaxed)),
		initialBlockPoolIndex(other.initialBlockPoolIndex.load(std::memory_order_relaxed)),
		initialBlockPool(other.initialBlockPool),
		initialBlockPoolSize(other.initialBlockPoolSize),
		freeList(std::move(other.freeList)),
		nextExplicitConsumerId(other.nextExplicitConsumerId.load(std::memory_order_relaxed)),
		globalExplicitConsumerOffset(other.globalExplicitConsumerOffset.load(std::memory_order_relaxed))
	{
		// Move the other one into this, and leave the other one as an empty queue
		implicitProducerHashResizeInProgress.clear(std::memory_order_relaxed);
		populate_initial_implicit_producer_hash();
		swap_implicit_producer_hashes(other);
		
		other.producerListTail.store(nullptr, std::memory_order_relaxed);
		other.producerCount.store(0, std::memory_order_relaxed);
		other.nextExplicitConsumerId.store(0, std::memory_order_relaxed);
		other.globalExplicitConsumerOffset.store(0, std::memory_order_relaxed);
		
#ifdef MOODYCAMEL_QUEUE_INTERNAL_DEBUG
		explicitProducers.store(other.explicitProducers.load(std::memory_order_relaxed), std::memory_order_relaxed);
		other.explicitProducers.store(nullptr, std::memory_order_relaxed);
		implicitProducers.store(other.implicitProducers.load(std::memory_order_relaxed), std::memory_order_relaxed);
		other.implicitProducers.store(nullptr, std::memory_order_relaxed);
#endif
		
		other.initialBlockPoolIndex.store(0, std::memory_order_relaxed);
		other.initialBlockPoolSize = 0;
		other.initialBlockPool = nullptr;
		
		reown_producers();
	}
	
	inline ConcurrentQueue& operator=(ConcurrentQueue&& other) MOODYCAMEL_NOEXCEPT
	{
		return swap_internal(other);
	}
	
	// Swaps this queue's state with the other's. Not thread-safe.
	// Swapping two queues does not invalidate their tokens, however
	// the tokens that were created for one queue must be used with
	// only the swapped queue (i.e. the tokens are tied to the
	// queue's movable state, not the object itself).
	inline void swap(ConcurrentQueue& other) MOODYCAMEL_NOEXCEPT
	{
		swap_internal(other);
	}
	
private:
	ConcurrentQueue& swap_internal(ConcurrentQueue& other)
	{
		if (this == &other) {
			return *this;
		}
		
		details::swap_relaxed(producerListTail, other.producerListTail);
		details::swap_relaxed(producerCount, other.producerCount);
		details::swap_relaxed(initialBlockPoolIndex, other.initialBlockPoolIndex);
		std::swap(initialBlockPool, other.initialBlockPool);
		std::swap(initialBlockPoolSize, other.initialBlockPoolSize);
		freeList.swap(other.freeList);
		details::swap_relaxed(nextExplicitConsumerId, other.nextExplicitConsumerId);
		details::swap_relaxed(globalExplicitConsumerOffset, other.globalExplicitConsumerOffset);
		
		swap_implicit_producer_hashes(other);
		
		reown_producers();
		other.reown_producers();
		
#ifdef MOODYCAMEL_QUEUE_INTERNAL_DEBUG
		details::swap_relaxed(explicitProducers, other.explicitProducers);
		details::swap_relaxed(implicitProducers, other.implicitProducers);
#endif
		
		return *this;
	}
	
public:
	// Enqueues a single item (by copying it).
	// Allocates memory if required. Only fails if memory allocation fails (or implicit
	// production is disabled because Traits::INITIAL_IMPLICIT_PRODUCER_HASH_SIZE is 0,
	// or Traits::MAX_SUBQUEUE_SIZE has been defined and would be surpassed).
	// Thread-safe.
	inline bool enqueue(T const& item)
	{
		MOODYCAMEL_CONSTEXPR_IF (INITIAL_IMPLICIT_PRODUCER_HASH_SIZE == 0) return false;
		else return inner_enqueue<CanAlloc>(item);
	}
	
	// Enqueues a single item (by moving it, if possible).
	// Allocates memory if required. Only fails if memory allocation fails (or implicit
	// production is disabled because Traits::INITIAL_IMPLICIT_PRODUCER_HASH_SIZE is 0,
	// or Traits::MAX_SUBQUEUE_SIZE has been defined and would be surpassed).
	// Thread-safe.
	inline bool enqueue(T&& item)
	{
		MOODYCAMEL_CONSTEXPR_IF (INITIAL_IMPLICIT_PRODUCER_HASH_SIZE == 0) return false;
		else return inner_enqueue<CanAlloc>(std::move(item));
	}
	
	// Enqueues a single item (by copying it) using an explicit producer token.
	// Allocates memory if required. Only fails if memory allocation fails (or
	// Traits::MAX_SUBQUEUE_SIZE has been defined and would be surpassed).
	// Thread-safe.
	inline bool enqueue(producer_token_t const& token, T const& item)
	{
		return inner_enqueue<CanAlloc>(token, item);
	}
	
	// Enqueues a single item (by moving it, if possible) using an explicit producer token.
	// Allocates memory if required. Only fails if memory allocation fails (or
	// Traits::MAX_SUBQUEUE_SIZE has been defined and would be surpassed).
	// Thread-safe.
	inline bool enqueue(producer_token_t const& token, T&& item)
	{
		return inner_enqueue<CanAlloc>(token, std::move(item));
	}
	
	// Enqueues several items.
	// Allocates memory if required. Only fails if memory allocation fails (or
	// implicit production is disabled because Traits::INITIAL_IMPLICIT_PRODUCER_HASH_SIZE
	// is 0, or Traits::MAX_SUBQUEUE_SIZE has been defined and would be surpassed).
	// Note: Use std::make_move_iterator if the elements should be moved instead of copied.
	// Thread-safe.
	template<typename It>
	bool enqueue_bulk(It itemFirst, size_t count)
	{
		MOODYCAMEL_CONSTEXPR_IF (INITIAL_IMPLICIT_PRODUCER_HASH_SIZE == 0) return false;
		else return inner_enqueue_bulk<CanAlloc>(itemFirst, count);
	}
	
	// Enqueues several items using an explicit producer token.
	// Allocates memory if required. Only fails if memory allocation fails
	// (or Traits::MAX_SUBQUEUE_SIZE has been defined and would be surpassed).
	// Note: Use std::make_move_iterator if the elements should be moved
	// instead of copied.
	// Thread-safe.
	template<typename It>
	bool enqueue_bulk(producer_token_t const& token, It itemFirst, size_t count)
	{
		return inner_enqueue_bulk<CanAlloc>(token, itemFirst, count);
	}
	
	// Enqueues a single item (by copying it).
	// Does not allocate memory. Fails if not enough room to enqueue (or implicit
	// production is disabled because Traits::INITIAL_IMPLICIT_PRODUCER_HASH_SIZE
	// is 0).
	// Thread-safe.
	inline bool try_enqueue(T const& item)
	{
		MOODYCAMEL_CONSTEXPR_IF (INITIAL_IMPLICIT_PRODUCER_HASH_SIZE == 0) return false;
		else return inner_enqueue<CannotAlloc>(item);
	}
	
	// Enqueues a single item (by moving it, if possible).
	// Does not allocate memory (except for one-time implicit producer).
	// Fails if not enough room to enqueue (or implicit production is
	// disabled because Traits::INITIAL_IMPLICIT_PRODUCER_HASH_SIZE is 0).
	// Thread-safe.
	inline bool try_enqueue(T&& item)
	{
		MOODYCAMEL_CONSTEXPR_IF (INITIAL_IMPLICIT_PRODUCER_HASH_SIZE == 0) return false;
		else return inner_enqueue<CannotAlloc>(std::move(item));
	}
	
	// Enqueues a single item (by copying it) using an explicit producer token.
	// Does not allocate memory. Fails if not enough room to enqueue.
	// Thread-safe.
	inline bool try_enqueue(producer_token_t const& token, T const& item)
	{
		return inner_enqueue<CannotAlloc>(token, item);
	}
	
	// Enqueues a single item (by moving it, if possible) using an explicit producer token.
	// Does not allocate memory. Fails if not enough room to enqueue.
	// Thread-safe.
	inline bool try_enqueue(producer_token_t const& token, T&& item)
	{
		return inner_enqueue<CannotAlloc>(token, std::move(item));
	}
	
	// Enqueues several items.
	// Does not allocate memory (except for one-time implicit producer).
	// Fails if not enough room to enqueue (or implicit production is
	// disabled because Traits::INITIAL_IMPLICIT_PRODUCER_HASH_SIZE is 0).
	// Note: Use std::make_move_iterator if the elements should be moved
	// instead of copied.
	// Thread-safe.
	template<typename It>
	bool try_enqueue_bulk(It itemFirst, size_t count)
	{
		MOODYCAMEL_CONSTEXPR_IF (INITIAL_IMPLICIT_PRODUCER_HASH_SIZE == 0) return false;
		else return inner_enqueue_bulk<CannotAlloc>(itemFirst, count);
	}
	
	// Enqueues several items using an explicit producer token.
	// Does not allocate memory. Fails if not enough room to enqueue.
	// Note: Use std::make_move_iterator if the elements should be moved
	// instead of copied.
	// Thread-safe.
	template<typename It>
	bool try_enqueue_bulk(producer_token_t const& token, It itemFirst, size_t count)
	{
		return inner_enqueue_bulk<CannotAlloc>(token, itemFirst, count);
	}
	
	
	
	// Attempts to dequeue from the queue.
	// Returns false if all producer streams appeared empty at the time they
	// were checked (so, the queue is likely but not guaranteed to be empty).
	// Never allocates. Thread-safe.
	template<typename U>
	bool try_dequeue(U& item)
	{
		// Instead of simply trying each producer in turn (which could cause needless contention on the first
		// producer), we score them heuristically.
		size_t nonEmptyCount = 0;
		ProducerBase* best = nullptr;
		size_t bestSize = 0;
		for (auto ptr = producerListTail.load(std::memory_order_acquire); nonEmptyCount < 3 && ptr != nullptr; ptr = ptr->next_prod()) {
			auto size = ptr->size_approx();
			if (size > 0) {
				if (size > bestSize) {
					bestSize = size;
					best = ptr;
				}
				++nonEmptyCount;
			}
		}
		
		// If there was at least one non-empty queue but it appears empty at the time
		// we try to dequeue from it, we need to make sure every queue's been tried
		if (nonEmptyCount > 0) {
			if ((details::likely)(best->dequeue(item))) {
				return true;
			}
			for (auto ptr = producerListTail.load(std::memory_order_acquire); ptr != nullptr; ptr = ptr->next_prod()) {
				if (ptr != best && ptr->dequeue(item)) {
					return true;
				}
			}
		}
		return false;
	}
	
	// Attempts to dequeue from the queue.
	// Returns false if all producer streams appeared empty at the time they
	// were checked (so, the queue is likely but not guaranteed to be empty).
	// This differs from the try_dequeue(item) method in that this one does
	// not attempt to reduce contention by interleaving the order that producer
	// streams are dequeued from. So, using this method can reduce overall throughput
	// under contention, but will give more predictable results in single-threaded
	// consumer scenarios. This is mostly only useful for internal unit tests.
	// Never allocates. Thread-safe.
	template<typename U>
	bool try_dequeue_non_interleaved(U& item)
	{
		for (auto ptr = producerListTail.load(std::memory_order_acquire); ptr != nullptr; ptr = ptr->next_prod()) {
			if (ptr->dequeue(item)) {
				return true;
			}
		}
		return false;
	}
	
	// Attempts to dequeue from the queue using an explicit consumer token.
	// Returns false if all producer streams appeared empty at the time they
	// were checked (so, the queue is likely but not guaranteed to be empty).
	// Never allocates. Thread-safe.
	template<typename U>
	bool try_dequeue(consumer_token_t& token, U& item)
	{
		// The idea is roughly as follows:
		// Every 256 items from one producer, make everyone rotate (increase the global offset) -> this means the highest efficiency consumer dictates the rotation speed of everyone else, more or less
		// If you see that the global offset has changed, you must reset your consumption counter and move to your designated place
		// If there's no items where you're supposed to be, keep moving until you find a producer with some items
		// If the global offset has not changed but you've run out of items to consume, move over from your current position until you find an producer with something in it
		
		if (token.desiredProducer == nullptr || token.lastKnownGlobalOffset != globalExplicitConsumerOffset.load(std::memory_order_relaxed)) {
			if (!update_current_producer_after_rotation(token)) {
				return false;
			}
		}
		
		// If there was at least one non-empty queue but it appears empty at the time
		// we try to dequeue from it, we need to make sure every queue's been tried
		if (static_cast<ProducerBase*>(token.currentProducer)->dequeue(item)) {
			if (++token.itemsConsumedFromCurrent == EXPLICIT_CONSUMER_CONSUMPTION_QUOTA_BEFORE_ROTATE) {
				globalExplicitConsumerOffset.fetch_add(1, std::memory_order_relaxed);
			}
			return true;
		}
		
		auto tail = producerListTail.load(std::memory_order_acquire);
		auto ptr = static_cast<ProducerBase*>(token.currentProducer)->next_prod();
		if (ptr == nullptr) {
			ptr = tail;
		}
		while (ptr != static_cast<ProducerBase*>(token.currentProducer)) {
			if (ptr->dequeue(item)) {
				token.currentProducer = ptr;
				token.itemsConsumedFromCurrent = 1;
				return true;
			}
			ptr = ptr->next_prod();
			if (ptr == nullptr) {
				ptr = tail;
			}
		}
		return false;
	}
	
	// Attempts to dequeue several elements from the queue.
	// Returns the number of items actually dequeued.
	// Returns 0 if all producer streams appeared empty at the time they
	// were checked (so, the queue is likely but not guaranteed to be empty).
	// Never allocates. Thread-safe.
	template<typename It>
	size_t try_dequeue_bulk(It itemFirst, size_t max)
	{
		size_t count = 0;
		for (auto ptr = producerListTail.load(std::memory_order_acquire); ptr != nullptr; ptr = ptr->next_prod()) {
			count += ptr->dequeue_bulk(itemFirst, max - count);
			if (count == max) {
				break;
			}
		}
		return count;
	}
	
	// Attempts to dequeue several elements from the queue using an explicit consumer token.
	// Returns the number of items actually dequeued.
	// Returns 0 if all producer streams appeared empty at the time they
	// were checked (so, the queue is likely but not guaranteed to be empty).
	// Never allocates. Thread-safe.
	template<typename It>
	size_t try_dequeue_bulk(consumer_token_t& token, It itemFirst, size_t max)
	{
		if (token.desiredProducer == nullptr || token.lastKnownGlobalOffset != globalExplicitConsumerOffset.load(std::memory_order_relaxed)) {
			if (!update_current_producer_after_rotation(token)) {
				return 0;
			}
		}
		
		size_t count = static_cast<ProducerBase*>(token.currentProducer)->dequeue_bulk(itemFirst, max);
		if (count == max) {
			if ((token.itemsConsumedFromCurrent += static_cast<std::uint32_t>(max)) >= EXPLICIT_CONSUMER_CONSUMPTION_QUOTA_BEFORE_ROTATE) {
				globalExplicitConsumerOffset.fetch_add(1, std::memory_order_relaxed);
			}
			return max;
		}
		token.itemsConsumedFromCurrent += static_cast<std::uint32_t>(count);
		max -= count;
		
		auto tail = producerListTail.load(std::memory_order_acquire);
		auto ptr = static_cast<ProducerBase*>(token.currentProducer)->next_prod();
		if (ptr == nullptr) {
			ptr = tail;
		}
		while (ptr != static_cast<ProducerBase*>(token.currentProducer)) {
			auto dequeued = ptr->dequeue_bulk(itemFirst, max);
			count += dequeued;
			if (dequeued != 0) {
				token.currentProducer = ptr;
				token.itemsConsumedFromCurrent = static_cast<std::uint32_t>(dequeued);
			}
			if (dequeued == max) {
				break;
			}
			max -= dequeued;
			ptr = ptr->next_prod();
			if (ptr == nullptr) {
				ptr = tail;
			}
		}
		return count;
	}
	
	
	
	// Attempts to dequeue from a specific producer's inner queue.
	// If you happen to know which producer you want to dequeue from, this
	// is significantly faster than using the general-case try_dequeue methods.
	// Returns false if the producer's queue appeared empty at the time it
	// was checked (so, the queue is likely but not guaranteed to be empty).
	// Never allocates. Thread-safe.
	template<typename U>
	inline bool try_dequeue_from_producer(producer_token_t const& producer, U& item)
	{
		return static_cast<ExplicitProducer*>(producer.producer)->dequeue(item);
	}
	
	// Attempts to dequeue several elements from a specific producer's inner queue.
	// Returns the number of items actually dequeued.
	// If you happen to know which producer you want to dequeue from, this
	// is significantly faster than using the general-case try_dequeue methods.
	// Returns 0 if the producer's queue appeared empty at the time it
	// was checked (so, the queue is likely but not guaranteed to be empty).
	// Never allocates. Thread-safe.
	template<typename It>
	inline size_t try_dequeue_bulk_from_producer(producer_token_t const& producer, It itemFirst, size_t max)
	{
		return static_cast<ExplicitProducer*>(producer.producer)->dequeue_bulk(itemFirst, max);
	}
	
	
	// Returns an estimate of the total number of elements currently in the queue. This
	// estimate is only accurate if the queue has completely stabilized before it is called
	// (i.e. all enqueue and dequeue operations have completed and their memory effects are
	// visible on the calling thread, and no further operations start while this method is
	// being called).
	// Thread-safe.
	size_t size_approx() const
	{
		size_t size = 0;
		for (auto ptr = producerListTail.load(std::memory_order_acquire); ptr != nullptr; ptr = ptr->next_prod()) {
			size += ptr->size_approx();
		}
		return size;
	}
	
	
	// Returns true if the underlying atomic variables used by
	// the queue are lock-free (they should be on most platforms).
	// Thread-safe.
	static constexpr bool is_lock_free()
	{
		return
			details::static_is_lock_free<bool>::value == 2 &&
			details::static_is_lock_free<size_t>::value == 2 &&
			details::static_is_lock_free<std::uint32_t>::value == 2 &&
			details::static_is_lock_free<index_t>::value == 2 &&
			details::static_is_lock_free<void*>::value == 2 &&
			details::static_is_lock_free<typename details::thread_id_converter<details::thread_id_t>::thread_id_numeric_size_t>::value == 2;
	}


private:
	friend struct ProducerToken;
	friend struct ConsumerToken;
	struct ExplicitProducer;
	friend struct ExplicitProducer;
	struct ImplicitProducer;
	friend struct ImplicitProducer;
	friend class ConcurrentQueueTests;
		
	enum AllocationMode { CanAlloc, CannotAlloc };
	
	
	///////////////////////////////
	// Queue methods
	///////////////////////////////
	
	template<AllocationMode canAlloc, typename U>
	inline bool inner_enqueue(producer_token_t const& token, U&& element)
	{
		return static_cast<ExplicitProducer*>(token.producer)->ConcurrentQueue::ExplicitProducer::template enqueue<canAlloc>(std::forward<U>(element));
	}
	
	template<AllocationMode canAlloc, typename U>
	inline bool inner_enqueue(U&& element)
	{
		auto producer = get_or_add_implicit_producer();
		return producer == nullptr ? false : producer->ConcurrentQueue::ImplicitProducer::template enqueue<canAlloc>(std::forward<U>(element));
	}
	
	template<AllocationMode canAlloc, typename It>
	inline bool inner_enqueue_bulk(producer_token_t const& token, It itemFirst, size_t count)
	{
		return static_cast<ExplicitProducer*>(token.producer)->ConcurrentQueue::ExplicitProducer::template enqueue_bulk<canAlloc>(itemFirst, count);
	}
	
	template<AllocationMode canAlloc, typename It>
	inline bool inner_enqueue_bulk(It itemFirst, size_t count)
	{
		auto producer = get_or_add_implicit_producer();
		return producer == nullptr ? false : producer->ConcurrentQueue::ImplicitProducer::template enqueue_bulk<canAlloc>(itemFirst, count);
	}
	
	inline bool update_current_producer_after_rotation(consumer_token_t& token)
	{
		// Ah, there's been a rotation, figure out where we should be!
		auto tail = producerListTail.load(std::memory_order_acquire);
		if (token.desiredProducer == nullptr && tail == nullptr) {
			return false;
		}
		auto prodCount = producerCount.load(std::memory_order_relaxed);
		auto globalOffset = globalExplicitConsumerOffset.load(std::memory_order_relaxed);
		if ((details::unlikely)(token.desiredProducer == nullptr)) {
			// Aha, first time we're dequeueing anything.
			// Figure out our local position
			// Note: offset is from start, not end, but we're traversing from end -- subtract from count first
			std::uint32_t offset = prodCount - 1 - (token.initialOffset % prodCount);
			token.desiredProducer = tail;
			for (std::uint32_t i = 0; i != offset; ++i) {
				token.desiredProducer = static_cast<ProducerBase*>(token.desiredProducer)->next_prod();
				if (token.desiredProducer == nullptr) {
					token.desiredProducer = tail;
				}
			}
		}
		
		std::uint32_t delta = globalOffset - token.lastKnownGlobalOffset;
		if (delta >= prodCount) {
			delta = delta % prodCount;
		}
		for (std::uint32_t i = 0; i != delta; ++i) {
			token.desiredProducer = static_cast<ProducerBase*>(token.desiredProducer)->next_prod();
			if (token.desiredProducer == nullptr) {
				token.desiredProducer = tail;
			}
		}
		
		token.lastKnownGlobalOffset = globalOffset;
		token.currentProducer = token.desiredProducer;
		token.itemsConsumedFromCurrent = 0;
		return true;
	}
	
	
	///////////////////////////
	// Free list
	///////////////////////////
	
	template <typename N>
	struct FreeListNode
	{
		FreeListNode() : freeListRefs(0), freeListNext(nullptr) { }
		
		std::atomic<std::uint32_t> freeListRefs;
		std::atomic<N*> freeListNext;
	};
	
	// A simple CAS-based lock-free free list. Not the fastest thing in the world under heavy contention, but
	// simple and correct (assuming nodes are never freed until after the free list is destroyed), and fairly
	// speedy under low contention.
	template<typename N>		// N must inherit FreeListNode or have the same fields (and initialization of them)
	struct FreeList
	{
		FreeList() : freeListHead(nullptr) { }
		FreeList(FreeList&& other) : freeListHead(other.freeListHead.load(std::memory_order_relaxed)) { other.freeListHead.store(nullptr, std::memory_order_relaxed); }
		void swap(FreeList& other) { details::swap_relaxed(freeListHead, other.freeListHead); }
		
		FreeList(FreeList const&) MOODYCAMEL_DELETE_FUNCTION;
		FreeList& operator=(FreeList const&) MOODYCAMEL_DELETE_FUNCTION;
		
		inline void add(N* node)
		{
#ifdef MCDBGQ_NOLOCKFREE_FREELIST
			debug::DebugLock lock(mutex);
#endif		
			// We know that the should-be-on-freelist bit is 0 at this point, so it's safe to
			// set it using a fetch_add
			if (node->freeListRefs.fetch_add(SHOULD_BE_ON_FREELIST, std::memory_order_acq_rel) == 0) {
				// Oh look! We were the last ones referencing this node, and we know
				// we want to add it to the free list, so let's do it!
		 		add_knowing_refcount_is_zero(node);
			}
		}
		
		inline N* try_get()
		{
#ifdef MCDBGQ_NOLOCKFREE_FREELIST
			debug::DebugLock lock(mutex);
#endif		
			auto head = freeListHead.load(std::memory_order_acquire);
			while (head != nullptr) {
				auto prevHead = head;
				auto refs = head->freeListRefs.load(std::memory_order_relaxed);
				if ((refs & REFS_MASK) == 0 || !head->freeListRefs.compare_exchange_strong(refs, refs + 1, std::memory_order_acquire, std::memory_order_relaxed)) {
					head = freeListHead.load(std::memory_order_acquire);
					continue;
				}
				
				// Good, reference count has been incremented (it wasn't at zero), which means we can read the
				// next and not worry about it changing between now and the time we do the CAS
				auto next = head->freeListNext.load(std::memory_order_relaxed);
				if (freeListHead.compare_exchange_strong(head, next, std::memory_order_acquire, std::memory_order_relaxed)) {
					// Yay, got the node. This means it was on the list, which means shouldBeOnFreeList must be false no
					// matter the refcount (because nobody else knows it's been taken off yet, it can't have been put back on).
					assert((head->freeListRefs.load(std::memory_order_relaxed) & SHOULD_BE_ON_FREELIST) == 0);
					
					// Decrease refcount twice, once for our ref, and once for the list's ref
					head->freeListRefs.fetch_sub(2, std::memory_order_release);
					return head;
				}
				
				// OK, the head must have changed on us, but we still need to decrease the refcount we increased.
				// Note that we don't need to release any memory effects, but we do need to ensure that the reference
				// count decrement happens-after the CAS on the head.
				refs = prevHead->freeListRefs.fetch_sub(1, std::memory_order_acq_rel);
				if (refs == SHOULD_BE_ON_FREELIST + 1) {
					add_knowing_refcount_is_zero(prevHead);
				}
			}
			
			return nullptr;
		}
		
		// Useful for traversing the list when there's no contention (e.g. to destroy remaining nodes)
		N* head_unsafe() const { return freeListHead.load(std::memory_order_relaxed); }
		
	private:
		inline void add_knowing_refcount_is_zero(N* node)
		{
			// Since the refcount is zero, and nobody can increase it once it's zero (except us, and we run
			// only one copy of this method per node at a time, i.e. the single thread case), then we know
			// we can safely change the next pointer of the node; however, once the refcount is back above
			// zero, then other threads could increase it (happens under heavy contention, when the refcount
			// goes to zero in between a load and a refcount increment of a node in try_get, then back up to
			// something non-zero, then the refcount increment is done by the other thread) -- so, if the CAS
			// to add the node to the actual list fails, decrease the refcount and leave the add operation to
			// the next thread who puts the refcount back at zero (which could be us, hence the loop).
			auto head = freeListHead.load(std::memory_order_relaxed);
			while (true) {
				node->freeListNext.store(head, std::memory_order_relaxed);
				node->freeListRefs.store(1, std::memory_order_release);
				if (!freeListHead.compare_exchange_strong(head, node, std::memory_order_release, std::memory_order_relaxed)) {
					// Hmm, the add failed, but we can only try again when the refcount goes back to zero
					if (node->freeListRefs.fetch_add(SHOULD_BE_ON_FREELIST - 1, std::memory_order_release) == 1) {
						continue;
					}
				}
				return;
			}
		}
		
	private:
		// Implemented like a stack, but where node order doesn't matter (nodes are inserted out of order under contention)
		std::atomic<N*> freeListHead;
	
	static const std::uint32_t REFS_MASK = 0x7FFFFFFF;
	static const std::uint32_t SHOULD_BE_ON_FREELIST = 0x80000000;
		
#ifdef MCDBGQ_NOLOCKFREE_FREELIST
		debug::DebugMutex mutex;
#endif
	};
	
	
	///////////////////////////
	// Block
	///////////////////////////
	
	enum InnerQueueContext { implicit_context = 0, explicit_context = 1 };
	
	struct Block
	{
		Block()
			: next(nullptr), elementsCompletelyDequeued(0), freeListRefs(0), freeListNext(nullptr), dynamicallyAllocated(true)
		{
#ifdef MCDBGQ_TRACKMEM
			owner = nullptr;
#endif
		}
		
		template<InnerQueueContext context>
		inline bool is_empty() const
		{
			MOODYCAMEL_CONSTEXPR_IF (context == explicit_context && BLOCK_SIZE <= EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD) {
				// Check flags
				for (size_t i = 0; i < BLOCK_SIZE; ++i) {
					if (!emptyFlags[i].load(std::memory_order_relaxed)) {
						return false;
					}
				}
				
				// Aha, empty; make sure we have all other memory effects that happened before the empty flags were set
				std::atomic_thread_fence(std::memory_order_acquire);
				return true;
			}
			else {
				// Check counter
				if (elementsCompletelyDequeued.load(std::memory_order_relaxed) == BLOCK_SIZE) {
					std::atomic_thread_fence(std::memory_order_acquire);
					return true;
				}
				assert(elementsCompletelyDequeued.load(std::memory_order_relaxed) <= BLOCK_SIZE);
				return false;
			}
		}
		
		// Returns true if the block is now empty (does not apply in explicit context)
		template<InnerQueueContext context>
		inline bool set_empty(MOODYCAMEL_MAYBE_UNUSED index_t i)
		{
			MOODYCAMEL_CONSTEXPR_IF (context == explicit_context && BLOCK_SIZE <= EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD) {
				// Set flag
				assert(!emptyFlags[BLOCK_SIZE - 1 - static_cast<size_t>(i & static_cast<index_t>(BLOCK_SIZE - 1))].load(std::memory_order_relaxed));
				emptyFlags[BLOCK_SIZE - 1 - static_cast<size_t>(i & static_cast<index_t>(BLOCK_SIZE - 1))].store(true, std::memory_order_release);
				return false;
			}
			else {
				// Increment counter
				auto prevVal = elementsCompletelyDequeued.fetch_add(1, std::memory_order_release);
				assert(prevVal < BLOCK_SIZE);
				return prevVal == BLOCK_SIZE - 1;
			}
		}
		
		// Sets multiple contiguous item statuses to 'empty' (assumes no wrapping and count > 0).
		// Returns true if the block is now empty (does not apply in explicit context).
		template<InnerQueueContext context>
		inline bool set_many_empty(MOODYCAMEL_MAYBE_UNUSED index_t i, size_t count)
		{
			MOODYCAMEL_CONSTEXPR_IF (context == explicit_context && BLOCK_SIZE <= EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD) {
				// Set flags
				std::atomic_thread_fence(std::memory_order_release);
				i = BLOCK_SIZE - 1 - static_cast<size_t>(i & static_cast<index_t>(BLOCK_SIZE - 1)) - count + 1;
				for (size_t j = 0; j != count; ++j) {
					assert(!emptyFlags[i + j].load(std::memory_order_relaxed));
					emptyFlags[i + j].store(true, std::memory_order_relaxed);
				}
				return false;
			}
			else {
				// Increment counter
				auto prevVal = elementsCompletelyDequeued.fetch_add(count, std::memory_order_release);
				assert(prevVal + count <= BLOCK_SIZE);
				return prevVal + count == BLOCK_SIZE;
			}
		}
		
		template<InnerQueueContext context>
		inline void set_all_empty()
		{
			MOODYCAMEL_CONSTEXPR_IF (context == explicit_context && BLOCK_SIZE <= EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD) {
				// Set all flags
				for (size_t i = 0; i != BLOCK_SIZE; ++i) {
					emptyFlags[i].store(true, std::memory_order_relaxed);
				}
			}
			else {
				// Reset counter
				elementsCompletelyDequeued.store(BLOCK_SIZE, std::memory_order_relaxed);
			}
		}
		
		template<InnerQueueContext context>
		inline void reset_empty()
		{
			MOODYCAMEL_CONSTEXPR_IF (context == explicit_context && BLOCK_SIZE <= EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD) {
				// Reset flags
				for (size_t i = 0; i != BLOCK_SIZE; ++i) {
					emptyFlags[i].store(false, std::memory_order_relaxed);
				}
			}
			else {
				// Reset counter
				elementsCompletelyDequeued.store(0, std::memory_order_relaxed);
			}
		}
		
		inline T* operator[](index_t idx) MOODYCAMEL_NOEXCEPT { return static_cast<T*>(static_cast<void*>(elements)) + static_cast<size_t>(idx & static_cast<index_t>(BLOCK_SIZE - 1)); }
		inline T const* operator[](index_t idx) const MOODYCAMEL_NOEXCEPT { return static_cast<T const*>(static_cast<void const*>(elements)) + static_cast<size_t>(idx & static_cast<index_t>(BLOCK_SIZE - 1)); }
		
	private:
		static_assert(std::alignment_of<T>::value <= sizeof(T), "The queue does not support types with an alignment greater than their size at this time");
		MOODYCAMEL_ALIGNED_TYPE_LIKE(char[sizeof(T) * BLOCK_SIZE], T) elements;
	public:
		Block* next;
		std::atomic<size_t> elementsCompletelyDequeued;
		std::atomic<bool> emptyFlags[BLOCK_SIZE <= EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD ? BLOCK_SIZE : 1];
	public:
		std::atomic<std::uint32_t> freeListRefs;
		std::atomic<Block*> freeListNext;
		bool dynamicallyAllocated;		// Perhaps a better name for this would be 'isNotPartOfInitialBlockPool'
		
#ifdef MCDBGQ_TRACKMEM
		void* owner;
#endif
	};
	static_assert(std::alignment_of<Block>::value >= std::alignment_of<T>::value, "Internal error: Blocks must be at least as aligned as the type they are wrapping");


#ifdef MCDBGQ_TRACKMEM
public:
	struct MemStats;
private:
#endif
	
	///////////////////////////
	// Producer base
	///////////////////////////
	
	struct ProducerBase : public details::ConcurrentQueueProducerTypelessBase
	{
		ProducerBase(ConcurrentQueue* parent_, bool isExplicit_) :
			tailIndex(0),
			headIndex(0),
			dequeueOptimisticCount(0),
			dequeueOvercommit(0),
			tailBlock(nullptr),
			isExplicit(isExplicit_),
			parent(parent_)
		{
		}
		
		virtual ~ProducerBase() { }
		
		template<typename U>
		inline bool dequeue(U& element)
		{
			if (isExplicit) {
				return static_cast<ExplicitProducer*>(this)->dequeue(element);
			}
			else {
				return static_cast<ImplicitProducer*>(this)->dequeue(element);
			}
		}
		
		template<typename It>
		inline size_t dequeue_bulk(It& itemFirst, size_t max)
		{
			if (isExplicit) {
				return static_cast<ExplicitProducer*>(this)->dequeue_bulk(itemFirst, max);
			}
			else {
				return static_cast<ImplicitProducer*>(this)->dequeue_bulk(itemFirst, max);
			}
		}
		
		inline ProducerBase* next_prod() const { return static_cast<ProducerBase*>(next); }
		
		inline size_t size_approx() const
		{
			auto tail = tailIndex.load(std::memory_order_relaxed);
			auto head = headIndex.load(std::memory_order_relaxed);
			return details::circular_less_than(head, tail) ? static_cast<size_t>(tail - head) : 0;
		}
		
		inline index_t getTail() const { return tailIndex.load(std::memory_order_relaxed); }
	protected:
		std::atomic<index_t> tailIndex;		// Where to enqueue to next
		std::atomic<index_t> headIndex;		// Where to dequeue from next
		
		std::atomic<index_t> dequeueOptimisticCount;
		std::atomic<index_t> dequeueOvercommit;
		
		Block* tailBlock;
		
	public:
		bool isExplicit;
		ConcurrentQueue* parent;
		
	protected:
#ifdef MCDBGQ_TRACKMEM
		friend struct MemStats;
#endif
	};
	
	
	///////////////////////////
	// Explicit queue
	///////////////////////////
		
	struct ExplicitProducer : public ProducerBase
	{
		explicit ExplicitProducer(ConcurrentQueue* parent_) :
			ProducerBase(parent_, true),
			blockIndex(nullptr),
			pr_blockIndexSlotsUsed(0),
			pr_blockIndexSize(EXPLICIT_INITIAL_INDEX_SIZE >> 1),
			pr_blockIndexFront(0),
			pr_blockIndexEntries(nullptr),
			pr_blockIndexRaw(nullptr)
		{
			size_t poolBasedIndexSize = details::ceil_to_pow_2(parent_->initialBlockPoolSize) >> 1;
			if (poolBasedIndexSize > pr_blockIndexSize) {
				pr_blockIndexSize = poolBasedIndexSize;
			}
			
			new_block_index(0);		// This creates an index with double the number of current entries, i.e. EXPLICIT_INITIAL_INDEX_SIZE
		}
		
		~ExplicitProducer()
		{
			// Destruct any elements not yet dequeued.
			// Since we're in the destructor, we can assume all elements
			// are either completely dequeued or completely not (no halfways).
			if (this->tailBlock != nullptr) {		// Note this means there must be a block index too
				// First find the block that's partially dequeued, if any
				Block* halfDequeuedBlock = nullptr;
				if ((this->headIndex.load(std::memory_order_relaxed) & static_cast<index_t>(BLOCK_SIZE - 1)) != 0) {
					// The head's not on a block boundary, meaning a block somewhere is partially dequeued
					// (or the head block is the tail block and was fully dequeued, but the head/tail are still not on a boundary)
					size_t i = (pr_blockIndexFront - pr_blockIndexSlotsUsed) & (pr_blockIndexSize - 1);
					while (details::circular_less_than<index_t>(pr_blockIndexEntries[i].base + BLOCK_SIZE, this->headIndex.load(std::memory_order_relaxed))) {
						i = (i + 1) & (pr_blockIndexSize - 1);
					}
					assert(details::circular_less_than<index_t>(pr_blockIndexEntries[i].base, this->headIndex.load(std::memory_order_relaxed)));
					halfDequeuedBlock = pr_blockIndexEntries[i].block;
				}
				
				// Start at the head block (note the first line in the loop gives us the head from the tail on the first iteration)
				auto block = this->tailBlock;
				do {
					block = block->next;
					if (block->ConcurrentQueue::Block::template is_empty<explicit_context>()) {
						continue;
					}
					
					size_t i = 0;	// Offset into block
					if (block == halfDequeuedBlock) {
						i = static_cast<size_t>(this->headIndex.load(std::memory_order_relaxed) & static_cast<index_t>(BLOCK_SIZE - 1));
					}
					
					// Walk through all the items in the block; if this is the tail block, we need to stop when we reach the tail index
					auto lastValidIndex = (this->tailIndex.load(std::memory_order_relaxed) & static_cast<index_t>(BLOCK_SIZE - 1)) == 0 ? BLOCK_SIZE : static_cast<size_t>(this->tailIndex.load(std::memory_order_relaxed) & static_cast<index_t>(BLOCK_SIZE - 1));
					while (i != BLOCK_SIZE && (block != this->tailBlock || i != lastValidIndex)) {
						(*block)[i++]->~T();
					}
				} while (block != this->tailBlock);
			}
			
			// Destroy all blocks that we own
			if (this->tailBlock != nullptr) {
				auto block = this->tailBlock;
				do {
					auto nextBlock = block->next;
					this->parent->add_block_to_free_list(block);
					block = nextBlock;
				} while (block != this->tailBlock);
			}
			
			// Destroy the block indices
			auto header = static_cast<BlockIndexHeader*>(pr_blockIndexRaw);
			while (header != nullptr) {
				auto prev = static_cast<BlockIndexHeader*>(header->prev);
				header->~BlockIndexHeader();
				(Traits::free)(header);
				header = prev;
			}
		}
		
		template<AllocationMode allocMode, typename U>
		inline bool enqueue(U&& element)
		{
			index_t currentTailIndex = this->tailIndex.load(std::memory_order_relaxed);
			index_t newTailIndex = 1 + currentTailIndex;
			if ((currentTailIndex & static_cast<index_t>(BLOCK_SIZE - 1)) == 0) {
				// We reached the end of a block, start a new one
				auto startBlock = this->tailBlock;
				auto originalBlockIndexSlotsUsed = pr_blockIndexSlotsUsed;
				if (this->tailBlock != nullptr && this->tailBlock->next->ConcurrentQueue::Block::template is_empty<explicit_context>()) {
					// We can re-use the block ahead of us, it's empty!					
					this->tailBlock = this->tailBlock->next;
					this->tailBlock->ConcurrentQueue::Block::template reset_empty<explicit_context>();
					
					// We'll put the block on the block index (guaranteed to be room since we're conceptually removing the
					// last block from it first -- except instead of removing then adding, we can just overwrite).
					// Note that there must be a valid block index here, since even if allocation failed in the ctor,
					// it would have been re-attempted when adding the first block to the queue; since there is such
					// a block, a block index must have been successfully allocated.
				}
				else {
					// Whatever head value we see here is >= the last value we saw here (relatively),
					// and <= its current value. Since we have the most recent tail, the head must be
					// <= to it.
					auto head = this->headIndex.load(std::memory_order_relaxed);
					assert(!details::circular_less_than<index_t>(currentTailIndex, head));
					if (!details::circular_less_than<index_t>(head, currentTailIndex + BLOCK_SIZE)
						|| (MAX_SUBQUEUE_SIZE != details::const_numeric_max<size_t>::value && (MAX_SUBQUEUE_SIZE == 0 || MAX_SUBQUEUE_SIZE - BLOCK_SIZE < currentTailIndex - head))) {
						// We can't enqueue in another block because there's not enough leeway -- the
						// tail could surpass the head by the time the block fills up! (Or we'll exceed
						// the size limit, if the second part of the condition was true.)
						return false;
					}
					// We're going to need a new block; check that the block index has room
					if (pr_blockIndexRaw == nullptr || pr_blockIndexSlotsUsed == pr_blockIndexSize) {
						// Hmm, the circular block index is already full -- we'll need
						// to allocate a new index. Note pr_blockIndexRaw can only be nullptr if
						// the initial allocation failed in the constructor.
						
						MOODYCAMEL_CONSTEXPR_IF (allocMode == CannotAlloc) {
							return false;
						}
						else if (!new_block_index(pr_blockIndexSlotsUsed)) {
							return false;
						}
					}
					
					// Insert a new block in the circular linked list
					auto newBlock = this->parent->ConcurrentQueue::template requisition_block<allocMode>();
					if (newBlock == nullptr) {
						return false;
					}
#ifdef MCDBGQ_TRACKMEM
					newBlock->owner = this;
#endif
					newBlock->ConcurrentQueue::Block::template reset_empty<explicit_context>();
					if (this->tailBlock == nullptr) {
						newBlock->next = newBlock;
					}
					else {
						newBlock->next = this->tailBlock->next;
						this->tailBlock->next = newBlock;
					}
					this->tailBlock = newBlock;
					++pr_blockIndexSlotsUsed;
				}

				MOODYCAMEL_CONSTEXPR_IF (!MOODYCAMEL_NOEXCEPT_CTOR(T, U, new (static_cast<T*>(nullptr)) T(std::forward<U>(element)))) {
					// The constructor may throw. We want the element not to appear in the queue in
					// that case (without corrupting the queue):
					MOODYCAMEL_TRY {
						new ((*this->tailBlock)[currentTailIndex]) T(std::forward<U>(element));
					}
					MOODYCAMEL_CATCH (...) {
						// Revert change to the current block, but leave the new block available
						// for next time
						pr_blockIndexSlotsUsed = originalBlockIndexSlotsUsed;
						this->tailBlock = startBlock == nullptr ? this->tailBlock : startBlock;
						MOODYCAMEL_RETHROW;
					}
				}
				else {
					(void)startBlock;
					(void)originalBlockIndexSlotsUsed;
				}
				
				// Add block to block index
				auto& entry = blockIndex.load(std::memory_order_relaxed)->entries[pr_blockIndexFront];
				entry.base = currentTailIndex;
				entry.block = this->tailBlock;
				blockIndex.load(std::memory_order_relaxed)->front.store(pr_blockIndexFront, std::memory_order_release);
				pr_blockIndexFront = (pr_blockIndexFront + 1) & (pr_blockIndexSize - 1);
				
				MOODYCAMEL_CONSTEXPR_IF (!MOODYCAMEL_NOEXCEPT_CTOR(T, U, new (static_cast<T*>(nullptr)) T(std::forward<U>(element)))) {
					this->tailIndex.store(newTailIndex, std::memory_order_release);
					return true;
				}
			}
			
			// Enqueue
			new ((*this->tailBlock)[currentTailIndex]) T(std::forward<U>(element));
			
			this->tailIndex.store(newTailIndex, std::memory_order_release);
			return true;
		}
		
		template<typename U>
		bool dequeue(U& element)
		{
			auto tail = this->tailIndex.load(std::memory_order_relaxed);
			auto overcommit = this->dequeueOvercommit.load(std::memory_order_relaxed);
			if (details::circular_less_than<index_t>(this->dequeueOptimisticCount.load(std::memory_order_relaxed) - overcommit, tail)) {
				// Might be something to dequeue, let's give it a try
				
				// Note that this if is purely for performance purposes in the common case when the queue is
				// empty and the values are eventually consistent -- we may enter here spuriously.
				
				// Note that whatever the values of overcommit and tail are, they are not going to change (unless we
				// change them) and must be the same value at this point (inside the if) as when the if condition was
				// evaluated.

				// We insert an acquire fence here to synchronize-with the release upon incrementing dequeueOvercommit below.
				// This ensures that whatever the value we got loaded into overcommit, the load of dequeueOptisticCount in
				// the fetch_add below will result in a value at least as recent as that (and therefore at least as large).
				// Note that I believe a compiler (signal) fence here would be sufficient due to the nature of fetch_add (all
				// read-modify-write operations are guaranteed to work on the latest value in the modification order), but
				// unfortunately that can't be shown to be correct using only the C++11 standard.
				// See http://stackoverflow.com/questions/18223161/what-are-the-c11-memory-ordering-guarantees-in-this-corner-case
				std::atomic_thread_fence(std::memory_order_acquire);
				
				// Increment optimistic counter, then check if it went over the boundary
				auto myDequeueCount = this->dequeueOptimisticCount.fetch_add(1, std::memory_order_relaxed);
				
				// Note that since dequeueOvercommit must be <= dequeueOptimisticCount (because dequeueOvercommit is only ever
				// incremented after dequeueOptimisticCount -- this is enforced in the `else` block below), and since we now
				// have a version of dequeueOptimisticCount that is at least as recent as overcommit (due to the release upon
				// incrementing dequeueOvercommit and the acquire above that synchronizes with it), overcommit <= myDequeueCount.
				// However, we can't assert this since both dequeueOptimisticCount and dequeueOvercommit may (independently)
				// overflow; in such a case, though, the logic still holds since the difference between the two is maintained.
				
				// Note that we reload tail here in case it changed; it will be the same value as before or greater, since
				// this load is sequenced after (happens after) the earlier load above. This is supported by read-read
				// coherency (as defined in the standard), explained here: http://en.cppreference.com/w/cpp/atomic/memory_order
				tail = this->tailIndex.load(std::memory_order_acquire);
				if ((details::likely)(details::circular_less_than<index_t>(myDequeueCount - overcommit, tail))) {
					// Guaranteed to be at least one element to dequeue!
					
					// Get the index. Note that since there's guaranteed to be at least one element, this
					// will never exceed tail. We need to do an acquire-release fence here since it's possible
					// that whatever condition got us to this point was for an earlier enqueued element (that
					// we already see the memory effects for), but that by the time we increment somebody else
					// has incremented it, and we need to see the memory effects for *that* element, which is
					// in such a case is necessarily visible on the thread that incremented it in the first
					// place with the more current condition (they must have acquired a tail that is at least
					// as recent).
					auto index = this->headIndex.fetch_add(1, std::memory_order_acq_rel);
					
					
					// Determine which block the element is in
					
					auto localBlockIndex = blockIndex.load(std::memory_order_acquire);
					auto localBlockIndexHead = localBlockIndex->front.load(std::memory_order_acquire);
					
					// We need to be careful here about subtracting and dividing because of index wrap-around.
					// When an index wraps, we need to preserve the sign of the offset when dividing it by the
					// block size (in order to get a correct signed block count offset in all cases):
					auto headBase = localBlockIndex->entries[localBlockIndexHead].base;
					auto blockBaseIndex = index & ~static_cast<index_t>(BLOCK_SIZE - 1);
					auto offset = static_cast<size_t>(static_cast<typename std::make_signed<index_t>::type>(blockBaseIndex - headBase) / static_cast<typename std::make_signed<index_t>::type>(BLOCK_SIZE));
					auto block = localBlockIndex->entries[(localBlockIndexHead + offset) & (localBlockIndex->size - 1)].block;
					
					// Dequeue
					auto& el = *((*block)[index]);
					if (!MOODYCAMEL_NOEXCEPT_ASSIGN(T, T&&, element = std::move(el))) {
						// Make sure the element is still fully dequeued and destroyed even if the assignment
						// throws
						struct Guard {
							Block* block;
							index_t index;
							
							~Guard()
							{
								(*block)[index]->~T();
								block->ConcurrentQueue::Block::template set_empty<explicit_context>(index);
							}
						} guard = { block, index };

						element = std::move(el); // NOLINT
					}
					else {
						element = std::move(el); // NOLINT
						el.~T(); // NOLINT
						block->ConcurrentQueue::Block::template set_empty<explicit_context>(index);
					}
					
					return true;
				}
				else {
					// Wasn't anything to dequeue after all; make the effective dequeue count eventually consistent
					this->dequeueOvercommit.fetch_add(1, std::memory_order_release);		// Release so that the fetch_add on dequeueOptimisticCount is guaranteed to happen before this write
				}
			}
		
			return false;
		}
		
		template<AllocationMode allocMode, typename It>
		bool MOODYCAMEL_NO_TSAN enqueue_bulk(It itemFirst, size_t count)
		{
			// First, we need to make sure we have enough room to enqueue all of the elements;
			// this means pre-allocating blocks and putting them in the block index (but only if
			// all the allocations succeeded).
			index_t startTailIndex = this->tailIndex.load(std::memory_order_relaxed);
			auto startBlock = this->tailBlock;
			auto originalBlockIndexFront = pr_blockIndexFront;
			auto originalBlockIndexSlotsUsed = pr_blockIndexSlotsUsed;
			
			Block* firstAllocatedBlock = nullptr;
			
			// Figure out how many blocks we'll need to allocate, and do so
			size_t blockBaseDiff = ((startTailIndex + count - 1) & ~static_cast<index_t>(BLOCK_SIZE - 1)) - ((startTailIndex - 1) & ~static_cast<index_t>(BLOCK_SIZE - 1));
			index_t currentTailIndex = (startTailIndex - 1) & ~static_cast<index_t>(BLOCK_SIZE - 1);
			if (blockBaseDiff > 0) {
				// Allocate as many blocks as possible from ahead
				while (blockBaseDiff > 0 && this->tailBlock != nullptr && this->tailBlock->next != firstAllocatedBlock && this->tailBlock->next->ConcurrentQueue::Block::template is_empty<explicit_context>()) {
					blockBaseDiff -= static_cast<index_t>(BLOCK_SIZE);
					currentTailIndex += static_cast<index_t>(BLOCK_SIZE);
					
					this->tailBlock = this->tailBlock->next;
					firstAllocatedBlock = firstAllocatedBlock == nullptr ? this->tailBlock : firstAllocatedBlock;
					
					auto& entry = blockIndex.load(std::memory_order_relaxed)->entries[pr_blockIndexFront];
					entry.base = currentTailIndex;
					entry.block = this->tailBlock;
					pr_blockIndexFront = (pr_blockIndexFront + 1) & (pr_blockIndexSize - 1);
				}
				
				// Now allocate as many blocks as necessary from the block pool
				while (blockBaseDiff > 0) {
					blockBaseDiff -= static_cast<index_t>(BLOCK_SIZE);
					currentTailIndex += static_cast<index_t>(BLOCK_SIZE);
					
					auto head = this->headIndex.load(std::memory_order_relaxed);
					assert(!details::circular_less_than<index_t>(currentTailIndex, head));
					bool full = !details::circular_less_than<index_t>(head, currentTailIndex + BLOCK_SIZE) || (MAX_SUBQUEUE_SIZE != details::const_numeric_max<size_t>::value && (MAX_SUBQUEUE_SIZE == 0 || MAX_SUBQUEUE_SIZE - BLOCK_SIZE < currentTailIndex - head));
					if (pr_blockIndexRaw == nullptr || pr_blockIndexSlotsUsed == pr_blockIndexSize || full) {
						MOODYCAMEL_CONSTEXPR_IF (allocMode == CannotAlloc) {
							// Failed to allocate, undo changes (but keep injected blocks)
							pr_blockIndexFront = originalBlockIndexFront;
							pr_blockIndexSlotsUsed = originalBlockIndexSlotsUsed;
							this->tailBlock = startBlock == nullptr ? firstAllocatedBlock : startBlock;
							return false;
						}
						else if (full || !new_block_index(originalBlockIndexSlotsUsed)) {
							// Failed to allocate, undo changes (but keep injected blocks)
							pr_blockIndexFront = originalBlockIndexFront;
							pr_blockIndexSlotsUsed = originalBlockIndexSlotsUsed;
							this->tailBlock = startBlock == nullptr ? firstAllocatedBlock : startBlock;
							return false;
						}
						
						// pr_blockIndexFront is updated inside new_block_index, so we need to
						// update our fallback value too (since we keep the new index even if we
						// later fail)
						originalBlockIndexFront = originalBlockIndexSlotsUsed;
					}
					
					// Insert a new block in the circular linked list
					auto newBlock = this->parent->ConcurrentQueue::template requisition_block<allocMode>();
					if (newBlock == nullptr) {
						pr_blockIndexFront = originalBlockIndexFront;
						pr_blockIndexSlotsUsed = originalBlockIndexSlotsUsed;
						this->tailBlock = startBlock == nullptr ? firstAllocatedBlock : startBlock;
						return false;
					}
					
#ifdef MCDBGQ_TRACKMEM
					newBlock->owner = this;
#endif
					newBlock->ConcurrentQueue::Block::template set_all_empty<explicit_context>();
					if (this->tailBlock == nullptr) {
						newBlock->next = newBlock;
					}
					else {
						newBlock->next = this->tailBlock->next;
						this->tailBlock->next = newBlock;
					}
					this->tailBlock = newBlock;
					firstAllocatedBlock = firstAllocatedBlock == nullptr ? this->tailBlock : firstAllocatedBlock;
					
					++pr_blockIndexSlotsUsed;
					
					auto& entry = blockIndex.load(std::memory_order_relaxed)->entries[pr_blockIndexFront];
					entry.base = currentTailIndex;
					entry.block = this->tailBlock;
					pr_blockIndexFront = (pr_blockIndexFront + 1) & (pr_blockIndexSize - 1);
				}
				
				// Excellent, all allocations succeeded. Reset each block's emptiness before we fill them up, and
				// publish the new block index front
				auto block = firstAllocatedBlock;
				while (true) {
					block->ConcurrentQueue::Block::template reset_empty<explicit_context>();
					if (block == this->tailBlock) {
						break;
					}
					block = block->next;
				}
				
				MOODYCAMEL_CONSTEXPR_IF (MOODYCAMEL_NOEXCEPT_CTOR(T, decltype(*itemFirst), new (static_cast<T*>(nullptr)) T(details::deref_noexcept(itemFirst)))) {
					blockIndex.load(std::memory_order_relaxed)->front.store((pr_blockIndexFront - 1) & (pr_blockIndexSize - 1), std::memory_order_release);
				}
			}
			
			// Enqueue, one block at a time
			index_t newTailIndex = startTailIndex + static_cast<index_t>(count);
			currentTailIndex = startTailIndex;
			auto endBlock = this->tailBlock;
			this->tailBlock = startBlock;
			assert((startTailIndex & static_cast<index_t>(BLOCK_SIZE - 1)) != 0 || firstAllocatedBlock != nullptr || count == 0);
			if ((startTailIndex & static_cast<index_t>(BLOCK_SIZE - 1)) == 0 && firstAllocatedBlock != nullptr) {
				this->tailBlock = firstAllocatedBlock;
			}
			while (true) {
				index_t stopIndex = (currentTailIndex & ~static_cast<index_t>(BLOCK_SIZE - 1)) + static_cast<index_t>(BLOCK_SIZE);
				if (details::circular_less_than<index_t>(newTailIndex, stopIndex)) {
					stopIndex = newTailIndex;
				}
				MOODYCAMEL_CONSTEXPR_IF (MOODYCAMEL_NOEXCEPT_CTOR(T, decltype(*itemFirst), new (static_cast<T*>(nullptr)) T(details::deref_noexcept(itemFirst)))) {
					while (currentTailIndex != stopIndex) {
						new ((*this->tailBlock)[currentTailIndex++]) T(*itemFirst++);
					}
				}
				else {
					MOODYCAMEL_TRY {
						while (currentTailIndex != stopIndex) {
							// Must use copy constructor even if move constructor is available
							// because we may have to revert if there's an exception.
							// Sorry about the horrible templated next line, but it was the only way
							// to disable moving *at compile time*, which is important because a type
							// may only define a (noexcept) move constructor, and so calls to the
							// cctor will not compile, even if they are in an if branch that will never
							// be executed
							new ((*this->tailBlock)[currentTailIndex]) T(details::nomove_if<!MOODYCAMEL_NOEXCEPT_CTOR(T, decltype(*itemFirst), new (static_cast<T*>(nullptr)) T(details::deref_noexcept(itemFirst)))>::eval(*itemFirst));
							++currentTailIndex;
							++itemFirst;
						}
					}
					MOODYCAMEL_CATCH (...) {
						// Oh dear, an exception's been thrown -- destroy the elements that
						// were enqueued so far and revert the entire bulk operation (we'll keep
						// any allocated blocks in our linked list for later, though).
						auto constructedStopIndex = currentTailIndex;
						auto lastBlockEnqueued = this->tailBlock;
						
						pr_blockIndexFront = originalBlockIndexFront;
						pr_blockIndexSlotsUsed = originalBlockIndexSlotsUsed;
						this->tailBlock = startBlock == nullptr ? firstAllocatedBlock : startBlock;
						
						if (!details::is_trivially_destructible<T>::value) {
							auto block = startBlock;
							if ((startTailIndex & static_cast<index_t>(BLOCK_SIZE - 1)) == 0) {
								block = firstAllocatedBlock;
							}
							currentTailIndex = startTailIndex;
							while (true) {
								stopIndex = (currentTailIndex & ~static_cast<index_t>(BLOCK_SIZE - 1)) + static_cast<index_t>(BLOCK_SIZE);
								if (details::circular_less_than<index_t>(constructedStopIndex, stopIndex)) {
									stopIndex = constructedStopIndex;
								}
								while (currentTailIndex != stopIndex) {
									(*block)[currentTailIndex++]->~T();
								}
								if (block == lastBlockEnqueued) {
									break;
								}
								block = block->next;
							}
						}
						MOODYCAMEL_RETHROW;
					}
				}
				
				if (this->tailBlock == endBlock) {
					assert(currentTailIndex == newTailIndex);
					break;
				}
				this->tailBlock = this->tailBlock->next;
			}
			
			MOODYCAMEL_CONSTEXPR_IF (!MOODYCAMEL_NOEXCEPT_CTOR(T, decltype(*itemFirst), new (static_cast<T*>(nullptr)) T(details::deref_noexcept(itemFirst)))) {
				if (firstAllocatedBlock != nullptr)
					blockIndex.load(std::memory_order_relaxed)->front.store((pr_blockIndexFront - 1) & (pr_blockIndexSize - 1), std::memory_order_release);
			}
			
			this->tailIndex.store(newTailIndex, std::memory_order_release);
			return true;
		}
		
		template<typename It>
		size_t dequeue_bulk(It& itemFirst, size_t max)
		{
			auto tail = this->tailIndex.load(std::memory_order_relaxed);
			auto overcommit = this->dequeueOvercommit.load(std::memory_order_relaxed);
			auto desiredCount = static_cast<size_t>(tail - (this->dequeueOptimisticCount.load(std::memory_order_relaxed) - overcommit));
			if (details::circular_less_than<size_t>(0, desiredCount)) {
				desiredCount = desiredCount < max ? desiredCount : max;
				std::atomic_thread_fence(std::memory_order_acquire);
				
				auto myDequeueCount = this->dequeueOptimisticCount.fetch_add(desiredCount, std::memory_order_relaxed);
				
				tail = this->tailIndex.load(std::memory_order_acquire);
				auto actualCount = static_cast<size_t>(tail - (myDequeueCount - overcommit));
				if (details::circular_less_than<size_t>(0, actualCount)) {
					actualCount = desiredCount < actualCount ? desiredCount : actualCount;
					if (actualCount < desiredCount) {
						this->dequeueOvercommit.fetch_add(desiredCount - actualCount, std::memory_order_release);
					}
					
					// Get the first index. Note that since there's guaranteed to be at least actualCount elements, this
					// will never exceed tail.
					auto firstIndex = this->headIndex.fetch_add(actualCount, std::memory_order_acq_rel);
					
					// Determine which block the first element is in
					auto localBlockIndex = blockIndex.load(std::memory_order_acquire);
					auto localBlockIndexHead = localBlockIndex->front.load(std::memory_order_acquire);
					
					auto headBase = localBlockIndex->entries[localBlockIndexHead].base;
					auto firstBlockBaseIndex = firstIndex & ~static_cast<index_t>(BLOCK_SIZE - 1);
					auto offset = static_cast<size_t>(static_cast<typename std::make_signed<index_t>::type>(firstBlockBaseIndex - headBase) / static_cast<typename std::make_signed<index_t>::type>(BLOCK_SIZE));
					auto indexIndex = (localBlockIndexHead + offset) & (localBlockIndex->size - 1);
					
					// Iterate the blocks and dequeue
					auto index = firstIndex;
					do {
						auto firstIndexInBlock = index;
						index_t endIndex = (index & ~static_cast<index_t>(BLOCK_SIZE - 1)) + static_cast<index_t>(BLOCK_SIZE);
						endIndex = details::circular_less_than<index_t>(firstIndex + static_cast<index_t>(actualCount), endIndex) ? firstIndex + static_cast<index_t>(actualCount) : endIndex;
						auto block = localBlockIndex->entries[indexIndex].block;
						if (MOODYCAMEL_NOEXCEPT_ASSIGN(T, T&&, details::deref_noexcept(itemFirst) = std::move((*(*block)[index])))) {
							while (index != endIndex) {
								auto& el = *((*block)[index]);
								*itemFirst++ = std::move(el);
								el.~T();
								++index;
							}
						}
						else {
							MOODYCAMEL_TRY {
								while (index != endIndex) {
									auto& el = *((*block)[index]);
									*itemFirst = std::move(el);
									++itemFirst;
									el.~T();
									++index;
								}
							}
							MOODYCAMEL_CATCH (...) {
								// It's too late to revert the dequeue, but we can make sure that all
								// the dequeued objects are properly destroyed and the block index
								// (and empty count) are properly updated before we propagate the exception
								do {
									block = localBlockIndex->entries[indexIndex].block;
									while (index != endIndex) {
										(*block)[index++]->~T();
									}
									block->ConcurrentQueue::Block::template set_many_empty<explicit_context>(firstIndexInBlock, static_cast<size_t>(endIndex - firstIndexInBlock));
									indexIndex = (indexIndex + 1) & (localBlockIndex->size - 1);
									
									firstIndexInBlock = index;
									endIndex = (index & ~static_cast<index_t>(BLOCK_SIZE - 1)) + static_cast<index_t>(BLOCK_SIZE);
									endIndex = details::circular_less_than<index_t>(firstIndex + static_cast<index_t>(actualCount), endIndex) ? firstIndex + static_cast<index_t>(actualCount) : endIndex;
								} while (index != firstIndex + actualCount);
								
								MOODYCAMEL_RETHROW;
							}
						}
						block->ConcurrentQueue::Block::template set_many_empty<explicit_context>(firstIndexInBlock, static_cast<size_t>(endIndex - firstIndexInBlock));
						indexIndex = (indexIndex + 1) & (localBlockIndex->size - 1);
					} while (index != firstIndex + actualCount);
					
					return actualCount;
				}
				else {
					// Wasn't anything to dequeue after all; make the effective dequeue count eventually consistent
					this->dequeueOvercommit.fetch_add(desiredCount, std::memory_order_release);
				}
			}
			
			return 0;
		}
		
	private:
		struct BlockIndexEntry
		{
			index_t base;
			Block* block;
		};
		
		struct BlockIndexHeader
		{
			size_t size;
			std::atomic<size_t> front;		// Current slot (not next, like pr_blockIndexFront)
			BlockIndexEntry* entries;
			void* prev;
		};
		
		
		bool new_block_index(size_t numberOfFilledSlotsToExpose)
		{
			auto prevBlockSizeMask = pr_blockIndexSize - 1;
			
			// Create the new block
			pr_blockIndexSize <<= 1;
			auto newRawPtr = static_cast<char*>((Traits::malloc)(sizeof(BlockIndexHeader) + std::alignment_of<BlockIndexEntry>::value - 1 + sizeof(BlockIndexEntry) * pr_blockIndexSize));
			if (newRawPtr == nullptr) {
				pr_blockIndexSize >>= 1;		// Reset to allow graceful retry
				return false;
			}
			
			auto newBlockIndexEntries = reinterpret_cast<BlockIndexEntry*>(details::align_for<BlockIndexEntry>(newRawPtr + sizeof(BlockIndexHeader)));
			
			// Copy in all the old indices, if any
			size_t j = 0;
			if (pr_blockIndexSlotsUsed != 0) {
				auto i = (pr_blockIndexFront - pr_blockIndexSlotsUsed) & prevBlockSizeMask;
				do {
					newBlockIndexEntries[j++] = pr_blockIndexEntries[i];
					i = (i + 1) & prevBlockSizeMask;
				} while (i != pr_blockIndexFront);
			}
			
			// Update everything
			auto header = new (newRawPtr) BlockIndexHeader;
			header->size = pr_blockIndexSize;
			header->front.store(numberOfFilledSlotsToExpose - 1, std::memory_order_relaxed);
			header->entries = newBlockIndexEntries;
			header->prev = pr_blockIndexRaw;		// we link the new block to the old one so we can free it later
			
			pr_blockIndexFront = j;
			pr_blockIndexEntries = newBlockIndexEntries;
			pr_blockIndexRaw = newRawPtr;
			blockIndex.store(header, std::memory_order_release);
			
			return true;
		}
		
	private:
		std::atomic<BlockIndexHeader*> blockIndex;
		
		// To be used by producer only -- consumer must use the ones in referenced by blockIndex
		size_t pr_blockIndexSlotsUsed;
		size_t pr_blockIndexSize;
		size_t pr_blockIndexFront;		// Next slot (not current)
		BlockIndexEntry* pr_blockIndexEntries;
		void* pr_blockIndexRaw;
		
#ifdef MOODYCAMEL_QUEUE_INTERNAL_DEBUG
	public:
		ExplicitProducer* nextExplicitProducer;
	private:
#endif
		
#ifdef MCDBGQ_TRACKMEM
		friend struct MemStats;
#endif
	};
	
	
	//////////////////////////////////
	// Implicit queue
	//////////////////////////////////
	
	struct ImplicitProducer : public ProducerBase
	{			
		ImplicitProducer(ConcurrentQueue* parent_) :
			ProducerBase(parent_, false),
			nextBlockIndexCapacity(IMPLICIT_INITIAL_INDEX_SIZE),
			blockIndex(nullptr)
		{
			new_block_index();
		}
		
		~ImplicitProducer()
		{
			// Note that since we're in the destructor we can assume that all enqueue/dequeue operations
			// completed already; this means that all undequeued elements are placed contiguously across
			// contiguous blocks, and that only the first and last remaining blocks can be only partially
			// empty (all other remaining blocks must be completely full).
			
#ifdef MOODYCAMEL_CPP11_THREAD_LOCAL_SUPPORTED
			// Unregister ourselves for thread termination notification
			if (!this->inactive.load(std::memory_order_relaxed)) {
				details::ThreadExitNotifier::unsubscribe(&threadExitListener);
			}
#endif
			
			// Destroy all remaining elements!
			auto tail = this->tailIndex.load(std::memory_order_relaxed);
			auto index = this->headIndex.load(std::memory_order_relaxed);
			Block* block = nullptr;
			assert(index == tail || details::circular_less_than(index, tail));
			bool forceFreeLastBlock = index != tail;		// If we enter the loop, then the last (tail) block will not be freed
			while (index != tail) {
				if ((index & static_cast<index_t>(BLOCK_SIZE - 1)) == 0 || block == nullptr) {
					if (block != nullptr) {
						// Free the old block
						this->parent->add_block_to_free_list(block);
					}
					
					block = get_block_index_entry_for_index(index)->value.load(std::memory_order_relaxed);
				}
				
				((*block)[index])->~T();
				++index;
			}
			// Even if the queue is empty, there's still one block that's not on the free list
			// (unless the head index reached the end of it, in which case the tail will be poised
			// to create a new block).
			if (this->tailBlock != nullptr && (forceFreeLastBlock || (tail & static_cast<index_t>(BLOCK_SIZE - 1)) != 0)) {
				this->parent->add_block_to_free_list(this->tailBlock);
			}
			
			// Destroy block index
			auto localBlockIndex = blockIndex.load(std::memory_order_relaxed);
			if (localBlockIndex != nullptr) {
				for (size_t i = 0; i != localBlockIndex->capacity; ++i) {
					localBlockIndex->index[i]->~BlockIndexEntry();
				}
				do {
					auto prev = localBlockIndex->prev;
					localBlockIndex->~BlockIndexHeader();
					(Traits::free)(localBlockIndex);
					localBlockIndex = prev;
				} while (localBlockIndex != nullptr);
			}
		}
		
		template<AllocationMode allocMode, typename U>
		inline bool enqueue(U&& element)
		{
			index_t currentTailIndex = this->tailIndex.load(std::memory_order_relaxed);
			index_t newTailIndex = 1 + currentTailIndex;
			if ((currentTailIndex & static_cast<index_t>(BLOCK_SIZE - 1)) == 0) {
				// We reached the end of a block, start a new one
				auto head = this->headIndex.load(std::memory_order_relaxed);
				assert(!details::circular_less_than<index_t>(currentTailIndex, head));
				if (!details::circular_less_than<index_t>(head, currentTailIndex + BLOCK_SIZE) || (MAX_SUBQUEUE_SIZE != details::const_numeric_max<size_t>::value && (MAX_SUBQUEUE_SIZE == 0 || MAX_SUBQUEUE_SIZE - BLOCK_SIZE < currentTailIndex - head))) {
					return false;
				}
#ifdef MCDBGQ_NOLOCKFREE_IMPLICITPRODBLOCKINDEX
				debug::DebugLock lock(mutex);
#endif
				// Find out where we'll be inserting this block in the block index
				BlockIndexEntry* idxEntry;
				if (!insert_block_index_entry<allocMode>(idxEntry, currentTailIndex)) {
					return false;
				}
				
				// Get ahold of a new block
				auto newBlock = this->parent->ConcurrentQueue::template requisition_block<allocMode>();
				if (newBlock == nullptr) {
					rewind_block_index_tail();
					idxEntry->value.store(nullptr, std::memory_order_relaxed);
					return false;
				}
#ifdef MCDBGQ_TRACKMEM
				newBlock->owner = this;
#endif
				newBlock->ConcurrentQueue::Block::template reset_empty<implicit_context>();

				MOODYCAMEL_CONSTEXPR_IF (!MOODYCAMEL_NOEXCEPT_CTOR(T, U, new (static_cast<T*>(nullptr)) T(std::forward<U>(element)))) {
					// May throw, try to insert now before we publish the fact that we have this new block
					MOODYCAMEL_TRY {
						new ((*newBlock)[currentTailIndex]) T(std::forward<U>(element));
					}
					MOODYCAMEL_CATCH (...) {
						rewind_block_index_tail();
						idxEntry->value.store(nullptr, std::memory_order_relaxed);
						this->parent->add_block_to_free_list(newBlock);
						MOODYCAMEL_RETHROW;
					}
				}
				
				// Insert the new block into the index
				idxEntry->value.store(newBlock, std::memory_order_relaxed);
				
				this->tailBlock = newBlock;
				
				MOODYCAMEL_CONSTEXPR_IF (!MOODYCAMEL_NOEXCEPT_CTOR(T, U, new (static_cast<T*>(nullptr)) T(std::forward<U>(element)))) {
					this->tailIndex.store(newTailIndex, std::memory_order_release);
					return true;
				}
			}
			
			// Enqueue
			new ((*this->tailBlock)[currentTailIndex]) T(std::forward<U>(element));
			
			this->tailIndex.store(newTailIndex, std::memory_order_release);
			return true;
		}
		
		template<typename U>
		bool dequeue(U& element)
		{
			// See ExplicitProducer::dequeue for rationale and explanation
			index_t tail = this->tailIndex.load(std::memory_order_relaxed);
			index_t overcommit = this->dequeueOvercommit.load(std::memory_order_relaxed);
			if (details::circular_less_than<index_t>(this->dequeueOptimisticCount.load(std::memory_order_relaxed) - overcommit, tail)) {
				std::atomic_thread_fence(std::memory_order_acquire);
				
				index_t myDequeueCount = this->dequeueOptimisticCount.fetch_add(1, std::memory_order_relaxed);
				tail = this->tailIndex.load(std::memory_order_acquire);
				if ((details::likely)(details::circular_less_than<index_t>(myDequeueCount - overcommit, tail))) {
					index_t index = this->headIndex.fetch_add(1, std::memory_order_acq_rel);
					
					// Determine which block the element is in
					auto entry = get_block_index_entry_for_index(index);
					
					// Dequeue
					auto block = entry->value.load(std::memory_order_relaxed);
					auto& el = *((*block)[index]);
					
					if (!MOODYCAMEL_NOEXCEPT_ASSIGN(T, T&&, element = std::move(el))) {
#ifdef MCDBGQ_NOLOCKFREE_IMPLICITPRODBLOCKINDEX
						// Note: Acquiring the mutex with every dequeue instead of only when a block
						// is released is very sub-optimal, but it is, after all, purely debug code.
						debug::DebugLock lock(producer->mutex);
#endif
						struct Guard {
							Block* block;
							index_t index;
							BlockIndexEntry* entry;
							ConcurrentQueue* parent;
							
							~Guard()
							{
								(*block)[index]->~T();
								if (block->ConcurrentQueue::Block::template set_empty<implicit_context>(index)) {
									entry->value.store(nullptr, std::memory_order_relaxed);
									parent->add_block_to_free_list(block);
								}
							}
						} guard = { block, index, entry, this->parent };

						element = std::move(el); // NOLINT
					}
					else {
						element = std::move(el); // NOLINT
						el.~T(); // NOLINT

						if (block->ConcurrentQueue::Block::template set_empty<implicit_context>(index)) {
							{
#ifdef MCDBGQ_NOLOCKFREE_IMPLICITPRODBLOCKINDEX
								debug::DebugLock lock(mutex);
#endif
								// Add the block back into the global free pool (and remove from block index)
								entry->value.store(nullptr, std::memory_order_relaxed);
							}
							this->parent->add_block_to_free_list(block);		// releases the above store
						}
					}
					
					return true;
				}
				else {
					this->dequeueOvercommit.fetch_add(1, std::memory_order_release);
				}
			}
		
			return false;
		}
		
#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable: 4706)  // assignment within conditional expression
#endif
		template<AllocationMode allocMode, typename It>
		bool enqueue_bulk(It itemFirst, size_t count)
		{
			// First, we need to make sure we have enough room to enqueue all of the elements;
			// this means pre-allocating blocks and putting them in the block index (but only if
			// all the allocations succeeded).
			
			// Note that the tailBlock we start off with may not be owned by us any more;
			// this happens if it was filled up exactly to the top (setting tailIndex to
			// the first index of the next block which is not yet allocated), then dequeued
			// completely (putting it on the free list) before we enqueue again.
			
			index_t startTailIndex = this->tailIndex.load(std::memory_order_relaxed);
			auto startBlock = this->tailBlock;
			Block* firstAllocatedBlock = nullptr;
			auto endBlock = this->tailBlock;
			
			// Figure out how many blocks we'll need to allocate, and do so
			size_t blockBaseDiff = ((startTailIndex + count - 1) & ~static_cast<index_t>(BLOCK_SIZE - 1)) - ((startTailIndex - 1) & ~static_cast<index_t>(BLOCK_SIZE - 1));
			index_t currentTailIndex = (startTailIndex - 1) & ~static_cast<index_t>(BLOCK_SIZE - 1);
			if (blockBaseDiff > 0) {
#ifdef MCDBGQ_NOLOCKFREE_IMPLICITPRODBLOCKINDEX
				debug::DebugLock lock(mutex);
#endif
				do {
					blockBaseDiff -= static_cast<index_t>(BLOCK_SIZE);
					currentTailIndex += static_cast<index_t>(BLOCK_SIZE);
					
					// Find out where we'll be inserting this block in the block index
					BlockIndexEntry* idxEntry = nullptr;  // initialization here unnecessary but compiler can't always tell
					Block* newBlock;
					bool indexInserted = false;
					auto head = this->headIndex.load(std::memory_order_relaxed);
					assert(!details::circular_less_than<index_t>(currentTailIndex, head));
					bool full = !details::circular_less_than<index_t>(head, currentTailIndex + BLOCK_SIZE) || (MAX_SUBQUEUE_SIZE != details::const_numeric_max<size_t>::value && (MAX_SUBQUEUE_SIZE == 0 || MAX_SUBQUEUE_SIZE - BLOCK_SIZE < currentTailIndex - head));

					if (full || !(indexInserted = insert_block_index_entry<allocMode>(idxEntry, currentTailIndex)) || (newBlock = this->parent->ConcurrentQueue::template requisition_block<allocMode>()) == nullptr) {
						// Index allocation or block allocation failed; revert any other allocations
						// and index insertions done so far for this operation
						if (indexInserted) {
							rewind_block_index_tail();
							idxEntry->value.store(nullptr, std::memory_order_relaxed);
						}
						currentTailIndex = (startTailIndex - 1) & ~static_cast<index_t>(BLOCK_SIZE - 1);
						for (auto block = firstAllocatedBlock; block != nullptr; block = block->next) {
							currentTailIndex += static_cast<index_t>(BLOCK_SIZE);
							idxEntry = get_block_index_entry_for_index(currentTailIndex);
							idxEntry->value.store(nullptr, std::memory_order_relaxed);
							rewind_block_index_tail();
						}
						this->parent->add_blocks_to_free_list(firstAllocatedBlock);
						this->tailBlock = startBlock;
						
						return false;
					}
					
#ifdef MCDBGQ_TRACKMEM
					newBlock->owner = this;
#endif
					newBlock->ConcurrentQueue::Block::template reset_empty<implicit_context>();
					newBlock->next = nullptr;
					
					// Insert the new block into the index
					idxEntry->value.store(newBlock, std::memory_order_relaxed);
					
					// Store the chain of blocks so that we can undo if later allocations fail,
					// and so that we can find the blocks when we do the actual enqueueing
					if ((startTailIndex & static_cast<index_t>(BLOCK_SIZE - 1)) != 0 || firstAllocatedBlock != nullptr) {
						assert(this->tailBlock != nullptr);
						this->tailBlock->next = newBlock;
					}
					this->tailBlock = newBlock;
					endBlock = newBlock;
					firstAllocatedBlock = firstAllocatedBlock == nullptr ? newBlock : firstAllocatedBlock;
				} while (blockBaseDiff > 0);
			}
			
			// Enqueue, one block at a time
			index_t newTailIndex = startTailIndex + static_cast<index_t>(count);
			currentTailIndex = startTailIndex;
			this->tailBlock = startBlock;
			assert((startTailIndex & static_cast<index_t>(BLOCK_SIZE - 1)) != 0 || firstAllocatedBlock != nullptr || count == 0);
			if ((startTailIndex & static_cast<index_t>(BLOCK_SIZE - 1)) == 0 && firstAllocatedBlock != nullptr) {
				this->tailBlock = firstAllocatedBlock;
			}
			while (true) {
				index_t stopIndex = (currentTailIndex & ~static_cast<index_t>(BLOCK_SIZE - 1)) + static_cast<index_t>(BLOCK_SIZE);
				if (details::circular_less_than<index_t>(newTailIndex, stopIndex)) {
					stopIndex = newTailIndex;
				}
				MOODYCAMEL_CONSTEXPR_IF (MOODYCAMEL_NOEXCEPT_CTOR(T, decltype(*itemFirst), new (static_cast<T*>(nullptr)) T(details::deref_noexcept(itemFirst)))) {
					while (currentTailIndex != stopIndex) {
						new ((*this->tailBlock)[currentTailIndex++]) T(*itemFirst++);
					}
				}
				else {
					MOODYCAMEL_TRY {
						while (currentTailIndex != stopIndex) {
							new ((*this->tailBlock)[currentTailIndex]) T(details::nomove_if<!MOODYCAMEL_NOEXCEPT_CTOR(T, decltype(*itemFirst), new (static_cast<T*>(nullptr)) T(details::deref_noexcept(itemFirst)))>::eval(*itemFirst));
							++currentTailIndex;
							++itemFirst;
						}
					}
					MOODYCAMEL_CATCH (...) {
						auto constructedStopIndex = currentTailIndex;
						auto lastBlockEnqueued = this->tailBlock;
						
						if (!details::is_trivially_destructible<T>::value) {
							auto block = startBlock;
							if ((startTailIndex & static_cast<index_t>(BLOCK_SIZE - 1)) == 0) {
								block = firstAllocatedBlock;
							}
							currentTailIndex = startTailIndex;
							while (true) {
								stopIndex = (currentTailIndex & ~static_cast<index_t>(BLOCK_SIZE - 1)) + static_cast<index_t>(BLOCK_SIZE);
								if (details::circular_less_than<index_t>(constructedStopIndex, stopIndex)) {
									stopIndex = constructedStopIndex;
								}
								while (currentTailIndex != stopIndex) {
									(*block)[currentTailIndex++]->~T();
								}
								if (block == lastBlockEnqueued) {
									break;
								}
								block = block->next;
							}
						}
						
						currentTailIndex = (startTailIndex - 1) & ~static_cast<index_t>(BLOCK_SIZE - 1);
						for (auto block = firstAllocatedBlock; block != nullptr; block = block->next) {
							currentTailIndex += static_cast<index_t>(BLOCK_SIZE);
							auto idxEntry = get_block_index_entry_for_index(currentTailIndex);
							idxEntry->value.store(nullptr, std::memory_order_relaxed);
							rewind_block_index_tail();
						}
						this->parent->add_blocks_to_free_list(firstAllocatedBlock);
						this->tailBlock = startBlock;
						MOODYCAMEL_RETHROW;
					}
				}
				
				if (this->tailBlock == endBlock) {
					assert(currentTailIndex == newTailIndex);
					break;
				}
				this->tailBlock = this->tailBlock->next;
			}
			this->tailIndex.store(newTailIndex, std::memory_order_release);
			return true;
		}
#ifdef _MSC_VER
#pragma warning(pop)
#endif
		
		template<typename It>
		size_t dequeue_bulk(It& itemFirst, size_t max)
		{
			auto tail = this->tailIndex.load(std::memory_order_relaxed);
			auto overcommit = this->dequeueOvercommit.load(std::memory_order_relaxed);
			auto desiredCount = static_cast<size_t>(tail - (this->dequeueOptimisticCount.load(std::memory_order_relaxed) - overcommit));
			if (details::circular_less_than<size_t>(0, desiredCount)) {
				desiredCount = desiredCount < max ? desiredCount : max;
				std::atomic_thread_fence(std::memory_order_acquire);
				
				auto myDequeueCount = this->dequeueOptimisticCount.fetch_add(desiredCount, std::memory_order_relaxed);
				
				tail = this->tailIndex.load(std::memory_order_acquire);
				auto actualCount = static_cast<size_t>(tail - (myDequeueCount - overcommit));
				if (details::circular_less_than<size_t>(0, actualCount)) {
					actualCount = desiredCount < actualCount ? desiredCount : actualCount;
					if (actualCount < desiredCount) {
						this->dequeueOvercommit.fetch_add(desiredCount - actualCount, std::memory_order_release);
					}
					
					// Get the first index. Note that since there's guaranteed to be at least actualCount elements, this
					// will never exceed tail.
					auto firstIndex = this->headIndex.fetch_add(actualCount, std::memory_order_acq_rel);
					
					// Iterate the blocks and dequeue
					auto index = firstIndex;
					BlockIndexHeader* localBlockIndex;
					auto indexIndex = get_block_index_index_for_index(index, localBlockIndex);
					do {
						auto blockStartIndex = index;
						index_t endIndex = (index & ~static_cast<index_t>(BLOCK_SIZE - 1)) + static_cast<index_t>(BLOCK_SIZE);
						endIndex = details::circular_less_than<index_t>(firstIndex + static_cast<index_t>(actualCount), endIndex) ? firstIndex + static_cast<index_t>(actualCount) : endIndex;
						
						auto entry = localBlockIndex->index[indexIndex];
						auto block = entry->value.load(std::memory_order_relaxed);
						if (MOODYCAMEL_NOEXCEPT_ASSIGN(T, T&&, details::deref_noexcept(itemFirst) = std::move((*(*block)[index])))) {
							while (index != endIndex) {
								auto& el = *((*block)[index]);
								*itemFirst++ = std::move(el);
								el.~T();
								++index;
							}
						}
						else {
							MOODYCAMEL_TRY {
								while (index != endIndex) {
									auto& el = *((*block)[index]);
									*itemFirst = std::move(el);
									++itemFirst;
									el.~T();
									++index;
								}
							}
							MOODYCAMEL_CATCH (...) {
								do {
									entry = localBlockIndex->index[indexIndex];
									block = entry->value.load(std::memory_order_relaxed);
									while (index != endIndex) {
										(*block)[index++]->~T();
									}
									
									if (block->ConcurrentQueue::Block::template set_many_empty<implicit_context>(blockStartIndex, static_cast<size_t>(endIndex - blockStartIndex))) {
#ifdef MCDBGQ_NOLOCKFREE_IMPLICITPRODBLOCKINDEX
										debug::DebugLock lock(mutex);
#endif
										entry->value.store(nullptr, std::memory_order_relaxed);
										this->parent->add_block_to_free_list(block);
									}
									indexIndex = (indexIndex + 1) & (localBlockIndex->capacity - 1);
									
									blockStartIndex = index;
									endIndex = (index & ~static_cast<index_t>(BLOCK_SIZE - 1)) + static_cast<index_t>(BLOCK_SIZE);
									endIndex = details::circular_less_than<index_t>(firstIndex + static_cast<index_t>(actualCount), endIndex) ? firstIndex + static_cast<index_t>(actualCount) : endIndex;
								} while (index != firstIndex + actualCount);
								
								MOODYCAMEL_RETHROW;
							}
						}
						if (block->ConcurrentQueue::Block::template set_many_empty<implicit_context>(blockStartIndex, static_cast<size_t>(endIndex - blockStartIndex))) {
							{
#ifdef MCDBGQ_NOLOCKFREE_IMPLICITPRODBLOCKINDEX
								debug::DebugLock lock(mutex);
#endif
								// Note that the set_many_empty above did a release, meaning that anybody who acquires the block
								// we're about to free can use it safely since our writes (and reads!) will have happened-before then.
								entry->value.store(nullptr, std::memory_order_relaxed);
							}
							this->parent->add_block_to_free_list(block);		// releases the above store
						}
						indexIndex = (indexIndex + 1) & (localBlockIndex->capacity - 1);
					} while (index != firstIndex + actualCount);
					
					return actualCount;
				}
				else {
					this->dequeueOvercommit.fetch_add(desiredCount, std::memory_order_release);
				}
			}
			
			return 0;
		}
		
	private:
		// The block size must be > 1, so any number with the low bit set is an invalid block base index
		static const index_t INVALID_BLOCK_BASE = 1;
		
		struct BlockIndexEntry
		{
			std::atomic<index_t> key;
			std::atomic<Block*> value;
		};
		
		struct BlockIndexHeader
		{
			size_t capacity;
			std::atomic<size_t> tail;
			BlockIndexEntry* entries;
			BlockIndexEntry** index;
			BlockIndexHeader* prev;
		};
		
		template<AllocationMode allocMode>
		inline bool insert_block_index_entry(BlockIndexEntry*& idxEntry, index_t blockStartIndex)
		{
			auto localBlockIndex = blockIndex.load(std::memory_order_relaxed);		// We're the only writer thread, relaxed is OK
			if (localBlockIndex == nullptr) {
				return false;  // this can happen if new_block_index failed in the constructor
			}
			size_t newTail = (localBlockIndex->tail.load(std::memory_order_relaxed) + 1) & (localBlockIndex->capacity - 1);
			idxEntry = localBlockIndex->index[newTail];
			if (idxEntry->key.load(std::memory_order_relaxed) == INVALID_BLOCK_BASE ||
				idxEntry->value.load(std::memory_order_relaxed) == nullptr) {
				
				idxEntry->key.store(blockStartIndex, std::memory_order_relaxed);
				localBlockIndex->tail.store(newTail, std::memory_order_release);
				return true;
			}
			
			// No room in the old block index, try to allocate another one!
			MOODYCAMEL_CONSTEXPR_IF (allocMode == CannotAlloc) {
				return false;
			}
			else if (!new_block_index()) {
				return false;
			}
			else {
				localBlockIndex = blockIndex.load(std::memory_order_relaxed);
				newTail = (localBlockIndex->tail.load(std::memory_order_relaxed) + 1) & (localBlockIndex->capacity - 1);
				idxEntry = localBlockIndex->index[newTail];
				assert(idxEntry->key.load(std::memory_order_relaxed) == INVALID_BLOCK_BASE);
				idxEntry->key.store(blockStartIndex, std::memory_order_relaxed);
				localBlockIndex->tail.store(newTail, std::memory_order_release);
				return true;
			}
		}
		
		inline void rewind_block_index_tail()
		{
			auto localBlockIndex = blockIndex.load(std::memory_order_relaxed);
			localBlockIndex->tail.store((localBlockIndex->tail.load(std::memory_order_relaxed) - 1) & (localBlockIndex->capacity - 1), std::memory_order_relaxed);
		}
		
		inline BlockIndexEntry* get_block_index_entry_for_index(index_t index) const
		{
			BlockIndexHeader* localBlockIndex;
			auto idx = get_block_index_index_for_index(index, localBlockIndex);
			return localBlockIndex->index[idx];
		}
		
		inline size_t get_block_index_index_for_index(index_t index, BlockIndexHeader*& localBlockIndex) const
		{
#ifdef MCDBGQ_NOLOCKFREE_IMPLICITPRODBLOCKINDEX
			debug::DebugLock lock(mutex);
#endif
			index &= ~static_cast<index_t>(BLOCK_SIZE - 1);
			localBlockIndex = blockIndex.load(std::memory_order_acquire);
			auto tail = localBlockIndex->tail.load(std::memory_order_acquire);
			auto tailBase = localBlockIndex->index[tail]->key.load(std::memory_order_relaxed);
			assert(tailBase != INVALID_BLOCK_BASE);
			// Note: Must use division instead of shift because the index may wrap around, causing a negative
			// offset, whose negativity we want to preserve
			auto offset = static_cast<size_t>(static_cast<typename std::make_signed<index_t>::type>(index - tailBase) / static_cast<typename std::make_signed<index_t>::type>(BLOCK_SIZE));
			size_t idx = (tail + offset) & (localBlockIndex->capacity - 1);
			assert(localBlockIndex->index[idx]->key.load(std::memory_order_relaxed) == index && localBlockIndex->index[idx]->value.load(std::memory_order_relaxed) != nullptr);
			return idx;
		}
		
		bool new_block_index()
		{
			auto prev = blockIndex.load(std::memory_order_relaxed);
			size_t prevCapacity = prev == nullptr ? 0 : prev->capacity;
			auto entryCount = prev == nullptr ? nextBlockIndexCapacity : prevCapacity;
			auto raw = static_cast<char*>((Traits::malloc)(
				sizeof(BlockIndexHeader) +
				std::alignment_of<BlockIndexEntry>::value - 1 + sizeof(BlockIndexEntry) * entryCount +
				std::alignment_of<BlockIndexEntry*>::value - 1 + sizeof(BlockIndexEntry*) * nextBlockIndexCapacity));
			if (raw == nullptr) {
				return false;
			}
			
			auto header = new (raw) BlockIndexHeader;
			auto entries = reinterpret_cast<BlockIndexEntry*>(details::align_for<BlockIndexEntry>(raw + sizeof(BlockIndexHeader)));
			auto index = reinterpret_cast<BlockIndexEntry**>(details::align_for<BlockIndexEntry*>(reinterpret_cast<char*>(entries) + sizeof(BlockIndexEntry) * entryCount));
			if (prev != nullptr) {
				auto prevTail = prev->tail.load(std::memory_order_relaxed);
				auto prevPos = prevTail;
				size_t i = 0;
				do {
					prevPos = (prevPos + 1) & (prev->capacity - 1);
					index[i++] = prev->index[prevPos];
				} while (prevPos != prevTail);
				assert(i == prevCapacity);
			}
			for (size_t i = 0; i != entryCount; ++i) {
				new (entries + i) BlockIndexEntry;
				entries[i].key.store(INVALID_BLOCK_BASE, std::memory_order_relaxed);
				index[prevCapacity + i] = entries + i;
			}
			header->prev = prev;
			header->entries = entries;
			header->index = index;
			header->capacity = nextBlockIndexCapacity;
			header->tail.store((prevCapacity - 1) & (nextBlockIndexCapacity - 1), std::memory_order_relaxed);
			
			blockIndex.store(header, std::memory_order_release);
			
			nextBlockIndexCapacity <<= 1;
			
			return true;
		}
		
	private:
		size_t nextBlockIndexCapacity;
		std::atomic<BlockIndexHeader*> blockIndex;

#ifdef MOODYCAMEL_CPP11_THREAD_LOCAL_SUPPORTED
	public:
		details::ThreadExitListener threadExitListener;
	private:
#endif
		
#ifdef MOODYCAMEL_QUEUE_INTERNAL_DEBUG
	public:
		ImplicitProducer* nextImplicitProducer;
	private:
#endif

#ifdef MCDBGQ_NOLOCKFREE_IMPLICITPRODBLOCKINDEX
		mutable debug::DebugMutex mutex;
#endif
#ifdef MCDBGQ_TRACKMEM
		friend struct MemStats;
#endif
	};
	
	
	//////////////////////////////////
	// Block pool manipulation
	//////////////////////////////////
	
	void populate_initial_block_list(size_t blockCount)
	{
		initialBlockPoolSize = blockCount;
		if (initialBlockPoolSize == 0) {
			initialBlockPool = nullptr;
			return;
		}
		
		initialBlockPool = create_array<Block>(blockCount);
		if (initialBlockPool == nullptr) {
			initialBlockPoolSize = 0;
		}
		for (size_t i = 0; i < initialBlockPoolSize; ++i) {
			initialBlockPool[i].dynamicallyAllocated = false;
		}
	}
	
	inline Block* try_get_block_from_initial_pool()
	{
		if (initialBlockPoolIndex.load(std::memory_order_relaxed) >= initialBlockPoolSize) {
			return nullptr;
		}
		
		auto index = initialBlockPoolIndex.fetch_add(1, std::memory_order_relaxed);
		
		return index < initialBlockPoolSize ? (initialBlockPool + index) : nullptr;
	}
	
	inline void add_block_to_free_list(Block* block)
	{
#ifdef MCDBGQ_TRACKMEM
		block->owner = nullptr;
#endif
		if (!Traits::RECYCLE_ALLOCATED_BLOCKS && block->dynamicallyAllocated) {
			destroy(block);
		}
		else {
			freeList.add(block);
		}
	}
	
	inline void add_blocks_to_free_list(Block* block)
	{
		while (block != nullptr) {
			auto next = block->next;
			add_block_to_free_list(block);
			block = next;
		}
	}
	
	inline Block* try_get_block_from_free_list()
	{
		return freeList.try_get();
	}
	
	// Gets a free block from one of the memory pools, or allocates a new one (if applicable)
	template<AllocationMode canAlloc>
	Block* requisition_block()
	{
		auto block = try_get_block_from_initial_pool();
		if (block != nullptr) {
			return block;
		}
		
		block = try_get_block_from_free_list();
		if (block != nullptr) {
			return block;
		}
		
		MOODYCAMEL_CONSTEXPR_IF (canAlloc == CanAlloc) {
			return create<Block>();
		}
		else {
			return nullptr;
		}
	}
	

#ifdef MCDBGQ_TRACKMEM
	public:
		struct MemStats {
			size_t allocatedBlocks;
			size_t usedBlocks;
			size_t freeBlocks;
			size_t ownedBlocksExplicit;
			size_t ownedBlocksImplicit;
			size_t implicitProducers;
			size_t explicitProducers;
			size_t elementsEnqueued;
			size_t blockClassBytes;
			size_t queueClassBytes;
			size_t implicitBlockIndexBytes;
			size_t explicitBlockIndexBytes;
			
			friend class ConcurrentQueue;
			
		private:
			static MemStats getFor(ConcurrentQueue* q)
			{
				MemStats stats = { 0 };
				
				stats.elementsEnqueued = q->size_approx();
			
				auto block = q->freeList.head_unsafe();
				while (block != nullptr) {
					++stats.allocatedBlocks;
					++stats.freeBlocks;
					block = block->freeListNext.load(std::memory_order_relaxed);
				}
				
				for (auto ptr = q->producerListTail.load(std::memory_order_acquire); ptr != nullptr; ptr = ptr->next_prod()) {
					bool implicit = dynamic_cast<ImplicitProducer*>(ptr) != nullptr;
					stats.implicitProducers += implicit ? 1 : 0;
					stats.explicitProducers += implicit ? 0 : 1;
					
					if (implicit) {
						auto prod = static_cast<ImplicitProducer*>(ptr);
						stats.queueClassBytes += sizeof(ImplicitProducer);
						auto head = prod->headIndex.load(std::memory_order_relaxed);
						auto tail = prod->tailIndex.load(std::memory_order_relaxed);
						auto hash = prod->blockIndex.load(std::memory_order_relaxed);
						if (hash != nullptr) {
							for (size_t i = 0; i != hash->capacity; ++i) {
								if (hash->index[i]->key.load(std::memory_order_relaxed) != ImplicitProducer::INVALID_BLOCK_BASE && hash->index[i]->value.load(std::memory_order_relaxed) != nullptr) {
									++stats.allocatedBlocks;
									++stats.ownedBlocksImplicit;
								}
							}
							stats.implicitBlockIndexBytes += hash->capacity * sizeof(typename ImplicitProducer::BlockIndexEntry);
							for (; hash != nullptr; hash = hash->prev) {
								stats.implicitBlockIndexBytes += sizeof(typename ImplicitProducer::BlockIndexHeader) + hash->capacity * sizeof(typename ImplicitProducer::BlockIndexEntry*);
							}
						}
						for (; details::circular_less_than<index_t>(head, tail); head += BLOCK_SIZE) {
							//auto block = prod->get_block_index_entry_for_index(head);
							++stats.usedBlocks;
						}
					}
					else {
						auto prod = static_cast<ExplicitProducer*>(ptr);
						stats.queueClassBytes += sizeof(ExplicitProducer);
						auto tailBlock = prod->tailBlock;
						bool wasNonEmpty = false;
						if (tailBlock != nullptr) {
							auto block = tailBlock;
							do {
								++stats.allocatedBlocks;
								if (!block->ConcurrentQueue::Block::template is_empty<explicit_context>() || wasNonEmpty) {
									++stats.usedBlocks;
									wasNonEmpty = wasNonEmpty || block != tailBlock;
								}
								++stats.ownedBlocksExplicit;
								block = block->next;
							} while (block != tailBlock);
						}
						auto index = prod->blockIndex.load(std::memory_order_relaxed);
						while (index != nullptr) {
							stats.explicitBlockIndexBytes += sizeof(typename ExplicitProducer::BlockIndexHeader) + index->size * sizeof(typename ExplicitProducer::BlockIndexEntry);
							index = static_cast<typename ExplicitProducer::BlockIndexHeader*>(index->prev);
						}
					}
				}
				
				auto freeOnInitialPool = q->initialBlockPoolIndex.load(std::memory_order_relaxed) >= q->initialBlockPoolSize ? 0 : q->initialBlockPoolSize - q->initialBlockPoolIndex.load(std::memory_order_relaxed);
				stats.allocatedBlocks += freeOnInitialPool;
				stats.freeBlocks += freeOnInitialPool;
				
				stats.blockClassBytes = sizeof(Block) * stats.allocatedBlocks;
				stats.queueClassBytes += sizeof(ConcurrentQueue);
				
				return stats;
			}
		};
		
		// For debugging only. Not thread-safe.
		MemStats getMemStats()
		{
			return MemStats::getFor(this);
		}
	private:
		friend struct MemStats;
#endif
	
	
	//////////////////////////////////
	// Producer list manipulation
	//////////////////////////////////	
	
	ProducerBase* recycle_or_create_producer(bool isExplicit)
	{
#ifdef MCDBGQ_NOLOCKFREE_IMPLICITPRODHASH
		debug::DebugLock lock(implicitProdMutex);
#endif
		// Try to re-use one first
		for (auto ptr = producerListTail.load(std::memory_order_acquire); ptr != nullptr; ptr = ptr->next_prod()) {
			if (ptr->inactive.load(std::memory_order_relaxed) && ptr->isExplicit == isExplicit) {
				bool expected = true;
				if (ptr->inactive.compare_exchange_strong(expected, /* desired */ false, std::memory_order_acquire, std::memory_order_relaxed)) {
					// We caught one! It's been marked as activated, the caller can have it
					return ptr;
				}
			}
		}

		return add_producer(isExplicit ? static_cast<ProducerBase*>(create<ExplicitProducer>(this)) : create<ImplicitProducer>(this));
	}
	
	ProducerBase* add_producer(ProducerBase* producer)
	{
		// Handle failed memory allocation
		if (producer == nullptr) {
			return nullptr;
		}
		
		producerCount.fetch_add(1, std::memory_order_relaxed);
		
		// Add it to the lock-free list
		auto prevTail = producerListTail.load(std::memory_order_relaxed);
		do {
			producer->next = prevTail;
		} while (!producerListTail.compare_exchange_weak(prevTail, producer, std::memory_order_release, std::memory_order_relaxed));
		
#ifdef MOODYCAMEL_QUEUE_INTERNAL_DEBUG
		if (producer->isExplicit) {
			auto prevTailExplicit = explicitProducers.load(std::memory_order_relaxed);
			do {
				static_cast<ExplicitProducer*>(producer)->nextExplicitProducer = prevTailExplicit;
			} while (!explicitProducers.compare_exchange_weak(prevTailExplicit, static_cast<ExplicitProducer*>(producer), std::memory_order_release, std::memory_order_relaxed));
		}
		else {
			auto prevTailImplicit = implicitProducers.load(std::memory_order_relaxed);
			do {
				static_cast<ImplicitProducer*>(producer)->nextImplicitProducer = prevTailImplicit;
			} while (!implicitProducers.compare_exchange_weak(prevTailImplicit, static_cast<ImplicitProducer*>(producer), std::memory_order_release, std::memory_order_relaxed));
		}
#endif
		
		return producer;
	}
	
	void reown_producers()
	{
		// After another instance is moved-into/swapped-with this one, all the
		// producers we stole still think their parents are the other queue.
		// So fix them up!
		for (auto ptr = producerListTail.load(std::memory_order_relaxed); ptr != nullptr; ptr = ptr->next_prod()) {
			ptr->parent = this;
		}
	}
	
	
	//////////////////////////////////
	// Implicit producer hash
	//////////////////////////////////
	
	struct ImplicitProducerKVP
	{
		std::atomic<details::thread_id_t> key;
		ImplicitProducer* value;		// No need for atomicity since it's only read by the thread that sets it in the first place
		
		ImplicitProducerKVP() : value(nullptr) { }
		
		ImplicitProducerKVP(ImplicitProducerKVP&& other) MOODYCAMEL_NOEXCEPT
		{
			key.store(other.key.load(std::memory_order_relaxed), std::memory_order_relaxed);
			value = other.value;
		}
		
		inline ImplicitProducerKVP& operator=(ImplicitProducerKVP&& other) MOODYCAMEL_NOEXCEPT
		{
			swap(other);
			return *this;
		}
		
		inline void swap(ImplicitProducerKVP& other) MOODYCAMEL_NOEXCEPT
		{
			if (this != &other) {
				details::swap_relaxed(key, other.key);
				std::swap(value, other.value);
			}
		}
	};
	
	template<typename XT, typename XTraits>
	friend void moodycamel::swap(typename ConcurrentQueue<XT, XTraits>::ImplicitProducerKVP&, typename ConcurrentQueue<XT, XTraits>::ImplicitProducerKVP&) MOODYCAMEL_NOEXCEPT;
	
	struct ImplicitProducerHash
	{
		size_t capacity;
		ImplicitProducerKVP* entries;
		ImplicitProducerHash* prev;
	};
	
	inline void populate_initial_implicit_producer_hash()
	{
		MOODYCAMEL_CONSTEXPR_IF (INITIAL_IMPLICIT_PRODUCER_HASH_SIZE == 0) {
			return;
		}
		else {
			implicitProducerHashCount.store(0, std::memory_order_relaxed);
			auto hash = &initialImplicitProducerHash;
			hash->capacity = INITIAL_IMPLICIT_PRODUCER_HASH_SIZE;
			hash->entries = &initialImplicitProducerHashEntries[0];
			for (size_t i = 0; i != INITIAL_IMPLICIT_PRODUCER_HASH_SIZE; ++i) {
				initialImplicitProducerHashEntries[i].key.store(details::invalid_thread_id, std::memory_order_relaxed);
			}
			hash->prev = nullptr;
			implicitProducerHash.store(hash, std::memory_order_relaxed);
		}
	}
	
	void swap_implicit_producer_hashes(ConcurrentQueue& other)
	{
		MOODYCAMEL_CONSTEXPR_IF (INITIAL_IMPLICIT_PRODUCER_HASH_SIZE == 0) {
			return;
		}
		else {
			// Swap (assumes our implicit producer hash is initialized)
			initialImplicitProducerHashEntries.swap(other.initialImplicitProducerHashEntries);
			initialImplicitProducerHash.entries = &initialImplicitProducerHashEntries[0];
			other.initialImplicitProducerHash.entries = &other.initialImplicitProducerHashEntries[0];
			
			details::swap_relaxed(implicitProducerHashCount, other.implicitProducerHashCount);
			
			details::swap_relaxed(implicitProducerHash, other.implicitProducerHash);
			if (implicitProducerHash.load(std::memory_order_relaxed) == &other.initialImplicitProducerHash) {
				implicitProducerHash.store(&initialImplicitProducerHash, std::memory_order_relaxed);
			}
			else {
				ImplicitProducerHash* hash;
				for (hash = implicitProducerHash.load(std::memory_order_relaxed); hash->prev != &other.initialImplicitProducerHash; hash = hash->prev) {
					continue;
				}
				hash->prev = &initialImplicitProducerHash;
			}
			if (other.implicitProducerHash.load(std::memory_order_relaxed) == &initialImplicitProducerHash) {
				other.implicitProducerHash.store(&other.initialImplicitProducerHash, std::memory_order_relaxed);
			}
			else {
				ImplicitProducerHash* hash;
				for (hash = other.implicitProducerHash.load(std::memory_order_relaxed); hash->prev != &initialImplicitProducerHash; hash = hash->prev) {
					continue;
				}
				hash->prev = &other.initialImplicitProducerHash;
			}
		}
	}
	
	// Only fails (returns nullptr) if memory allocation fails
	ImplicitProducer* get_or_add_implicit_producer()
	{
		// Note that since the data is essentially thread-local (key is thread ID),
		// there's a reduced need for fences (memory ordering is already consistent
		// for any individual thread), except for the current table itself.
		
		// Start by looking for the thread ID in the current and all previous hash tables.
		// If it's not found, it must not be in there yet, since this same thread would
		// have added it previously to one of the tables that we traversed.
		
		// Code and algorithm adapted from http://preshing.com/20130605/the-worlds-simplest-lock-free-hash-table
		
#ifdef MCDBGQ_NOLOCKFREE_IMPLICITPRODHASH
		debug::DebugLock lock(implicitProdMutex);
#endif
		
		auto id = details::thread_id();
		auto hashedId = details::hash_thread_id(id);
		
		auto mainHash = implicitProducerHash.load(std::memory_order_acquire);
		assert(mainHash != nullptr);  // silence clang-tidy and MSVC warnings (hash cannot be null)
		for (auto hash = mainHash; hash != nullptr; hash = hash->prev) {
			// Look for the id in this hash
			auto index = hashedId;
			while (true) {		// Not an infinite loop because at least one slot is free in the hash table
				index &= hash->capacity - 1u;
				
				auto probedKey = hash->entries[index].key.load(std::memory_order_relaxed);
				if (probedKey == id) {
					// Found it! If we had to search several hashes deep, though, we should lazily add it
					// to the current main hash table to avoid the extended search next time.
					// Note there's guaranteed to be room in the current hash table since every subsequent
					// table implicitly reserves space for all previous tables (there's only one
					// implicitProducerHashCount).
					auto value = hash->entries[index].value;
					if (hash != mainHash) {
						index = hashedId;
						while (true) {
							index &= mainHash->capacity - 1u;
							auto empty = details::invalid_thread_id;
#ifdef MOODYCAMEL_CPP11_THREAD_LOCAL_SUPPORTED
							auto reusable = details::invalid_thread_id2;
							if (mainHash->entries[index].key.compare_exchange_strong(empty,    id, std::memory_order_seq_cst, std::memory_order_relaxed) ||
								mainHash->entries[index].key.compare_exchange_strong(reusable, id, std::memory_order_seq_cst, std::memory_order_relaxed)) {
#else
							if (mainHash->entries[index].key.compare_exchange_strong(empty,    id, std::memory_order_seq_cst, std::memory_order_relaxed)) {
#endif
								mainHash->entries[index].value = value;
								break;
							}
							++index;
						}
					}
					
					return value;
				}
				if (probedKey == details::invalid_thread_id) {
					break;		// Not in this hash table
				}
				++index;
			}
		}
		
		// Insert!
		auto newCount = 1 + implicitProducerHashCount.fetch_add(1, std::memory_order_relaxed);
		while (true) {
			// NOLINTNEXTLINE(clang-analyzer-core.NullDereference)
			if (newCount >= (mainHash->capacity >> 1) && !implicitProducerHashResizeInProgress.test_and_set(std::memory_order_acquire)) {
				// We've acquired the resize lock, try to allocate a bigger hash table.
				// Note the acquire fence synchronizes with the release fence at the end of this block, and hence when
				// we reload implicitProducerHash it must be the most recent version (it only gets changed within this
				// locked block).
				mainHash = implicitProducerHash.load(std::memory_order_acquire);
				if (newCount >= (mainHash->capacity >> 1)) {
					size_t newCapacity = mainHash->capacity << 1;
					while (newCount >= (newCapacity >> 1)) {
						newCapacity <<= 1;
					}
					auto raw = static_cast<char*>((Traits::malloc)(sizeof(ImplicitProducerHash) + std::alignment_of<ImplicitProducerKVP>::value - 1 + sizeof(ImplicitProducerKVP) * newCapacity));
					if (raw == nullptr) {
						// Allocation failed
						implicitProducerHashCount.fetch_sub(1, std::memory_order_relaxed);
						implicitProducerHashResizeInProgress.clear(std::memory_order_relaxed);
						return nullptr;
					}
					
					auto newHash = new (raw) ImplicitProducerHash;
					newHash->capacity = static_cast<size_t>(newCapacity);
					newHash->entries = reinterpret_cast<ImplicitProducerKVP*>(details::align_for<ImplicitProducerKVP>(raw + sizeof(ImplicitProducerHash)));
					for (size_t i = 0; i != newCapacity; ++i) {
						new (newHash->entries + i) ImplicitProducerKVP;
						newHash->entries[i].key.store(details::invalid_thread_id, std::memory_order_relaxed);
					}
					newHash->prev = mainHash;
					implicitProducerHash.store(newHash, std::memory_order_release);
					implicitProducerHashResizeInProgress.clear(std::memory_order_release);
					mainHash = newHash;
				}
				else {
					implicitProducerHashResizeInProgress.clear(std::memory_order_release);
				}
			}
			
			// If it's < three-quarters full, add to the old one anyway so that we don't have to wait for the next table
			// to finish being allocated by another thread (and if we just finished allocating above, the condition will
			// always be true)
			if (newCount < (mainHash->capacity >> 1) + (mainHash->capacity >> 2)) {
				auto producer = static_cast<ImplicitProducer*>(recycle_or_create_producer(false));
				if (producer == nullptr) {
					implicitProducerHashCount.fetch_sub(1, std::memory_order_relaxed);
					return nullptr;
				}
				
#ifdef MOODYCAMEL_CPP11_THREAD_LOCAL_SUPPORTED
				producer->threadExitListener.callback = &ConcurrentQueue::implicit_producer_thread_exited_callback;
				producer->threadExitListener.userData = producer;
				details::ThreadExitNotifier::subscribe(&producer->threadExitListener);
#endif
				
				auto index = hashedId;
				while (true) {
					index &= mainHash->capacity - 1u;
					auto empty = details::invalid_thread_id;
#ifdef MOODYCAMEL_CPP11_THREAD_LOCAL_SUPPORTED
					auto reusable = details::invalid_thread_id2;
					if (mainHash->entries[index].key.compare_exchange_strong(reusable, id, std::memory_order_seq_cst, std::memory_order_relaxed)) {
						implicitProducerHashCount.fetch_sub(1, std::memory_order_relaxed);  // already counted as a used slot
						mainHash->entries[index].value = producer;
						break;
					}
#endif
					if (mainHash->entries[index].key.compare_exchange_strong(empty,    id, std::memory_order_seq_cst, std::memory_order_relaxed)) {
						mainHash->entries[index].value = producer;
						break;
					}
					++index;
				}
				return producer;
			}
			
			// Hmm, the old hash is quite full and somebody else is busy allocating a new one.
			// We need to wait for the allocating thread to finish (if it succeeds, we add, if not,
			// we try to allocate ourselves).
			mainHash = implicitProducerHash.load(std::memory_order_acquire);
		}
	}
	
#ifdef MOODYCAMEL_CPP11_THREAD_LOCAL_SUPPORTED
	void implicit_producer_thread_exited(ImplicitProducer* producer)
	{
		// Remove from hash
#ifdef MCDBGQ_NOLOCKFREE_IMPLICITPRODHASH
		debug::DebugLock lock(implicitProdMutex);
#endif
		auto hash = implicitProducerHash.load(std::memory_order_acquire);
		assert(hash != nullptr);		// The thread exit listener is only registered if we were added to a hash in the first place
		auto id = details::thread_id();
		auto hashedId = details::hash_thread_id(id);
		details::thread_id_t probedKey;
		
		// We need to traverse all the hashes just in case other threads aren't on the current one yet and are
		// trying to add an entry thinking there's a free slot (because they reused a producer)
		for (; hash != nullptr; hash = hash->prev) {
			auto index = hashedId;
			do {
				index &= hash->capacity - 1u;
				probedKey = id;
				if (hash->entries[index].key.compare_exchange_strong(probedKey, details::invalid_thread_id2, std::memory_order_seq_cst, std::memory_order_relaxed)) {
					break;
				}
				++index;
			} while (probedKey != details::invalid_thread_id);		// Can happen if the hash has changed but we weren't put back in it yet, or if we weren't added to this hash in the first place
		}
		
		// Mark the queue as being recyclable
		producer->inactive.store(true, std::memory_order_release);
	}
	
	static void implicit_producer_thread_exited_callback(void* userData)
	{
		auto producer = static_cast<ImplicitProducer*>(userData);
		auto queue = producer->parent;
		queue->implicit_producer_thread_exited(producer);
	}
#endif
	
	//////////////////////////////////
	// Utility functions
	//////////////////////////////////

	template<typename TAlign>
	static inline void* aligned_malloc(size_t size)
	{
		MOODYCAMEL_CONSTEXPR_IF (std::alignment_of<TAlign>::value <= std::alignment_of<details::max_align_t>::value)
			return (Traits::malloc)(size);
		else {
			size_t alignment = std::alignment_of<TAlign>::value;
			void* raw = (Traits::malloc)(size + alignment - 1 + sizeof(void*));
			if (!raw)
				return nullptr;
			char* ptr = details::align_for<TAlign>(reinterpret_cast<char*>(raw) + sizeof(void*));
			*(reinterpret_cast<void**>(ptr) - 1) = raw;
			return ptr;
		}
	}

	template<typename TAlign>
	static inline void aligned_free(void* ptr)
	{
		MOODYCAMEL_CONSTEXPR_IF (std::alignment_of<TAlign>::value <= std::alignment_of<details::max_align_t>::value)
			return (Traits::free)(ptr);
		else
			(Traits::free)(ptr ? *(reinterpret_cast<void**>(ptr) - 1) : nullptr);
	}

	template<typename U>
	static inline U* create_array(size_t count)
	{
		assert(count > 0);
		U* p = static_cast<U*>(aligned_malloc<U>(sizeof(U) * count));
		if (p == nullptr)
			return nullptr;

		for (size_t i = 0; i != count; ++i)
			new (p + i) U();
		return p;
	}

	template<typename U>
	static inline void destroy_array(U* p, size_t count)
	{
		if (p != nullptr) {
			assert(count > 0);
			for (size_t i = count; i != 0; )
				(p + --i)->~U();
		}
		aligned_free<U>(p);
	}

	template<typename U>
	static inline U* create()
	{
		void* p = aligned_malloc<U>(sizeof(U));
		return p != nullptr ? new (p) U : nullptr;
	}

	template<typename U, typename A1>
	static inline U* create(A1&& a1)
	{
		void* p = aligned_malloc<U>(sizeof(U));
		return p != nullptr ? new (p) U(std::forward<A1>(a1)) : nullptr;
	}

	template<typename U>
	static inline void destroy(U* p)
	{
		if (p != nullptr)
			p->~U();
		aligned_free<U>(p);
	}

private:
	std::atomic<ProducerBase*> producerListTail;
	std::atomic<std::uint32_t> producerCount;
	
	std::atomic<size_t> initialBlockPoolIndex;
	Block* initialBlockPool;
	size_t initialBlockPoolSize;
	
#ifndef MCDBGQ_USEDEBUGFREELIST
	FreeList<Block> freeList;
#else
	debug::DebugFreeList<Block> freeList;
#endif
	
	std::atomic<ImplicitProducerHash*> implicitProducerHash;
	std::atomic<size_t> implicitProducerHashCount;		// Number of slots logically used
	ImplicitProducerHash initialImplicitProducerHash;
	std::array<ImplicitProducerKVP, INITIAL_IMPLICIT_PRODUCER_HASH_SIZE> initialImplicitProducerHashEntries;
	std::atomic_flag implicitProducerHashResizeInProgress;
	
	std::atomic<std::uint32_t> nextExplicitConsumerId;
	std::atomic<std::uint32_t> globalExplicitConsumerOffset;
	
#ifdef MCDBGQ_NOLOCKFREE_IMPLICITPRODHASH
	debug::DebugMutex implicitProdMutex;
#endif
	
#ifdef MOODYCAMEL_QUEUE_INTERNAL_DEBUG
	std::atomic<ExplicitProducer*> explicitProducers;
	std::atomic<ImplicitProducer*> implicitProducers;
#endif
};


template<typename T, typename Traits>
ProducerToken::ProducerToken(ConcurrentQueue<T, Traits>& queue)
	: producer(queue.recycle_or_create_producer(true))
{
	if (producer != nullptr) {
		producer->token = this;
	}
}

template<typename T, typename Traits>
ProducerToken::ProducerToken(BlockingConcurrentQueue<T, Traits>& queue)
	: producer(reinterpret_cast<ConcurrentQueue<T, Traits>*>(&queue)->recycle_or_create_producer(true))
{
	if (producer != nullptr) {
		producer->token = this;
	}
}

template<typename T, typename Traits>
ConsumerToken::ConsumerToken(ConcurrentQueue<T, Traits>& queue)
	: itemsConsumedFromCurrent(0), currentProducer(nullptr), desiredProducer(nullptr)
{
	initialOffset = queue.nextExplicitConsumerId.fetch_add(1, std::memory_order_release);
	lastKnownGlobalOffset = static_cast<std::uint32_t>(-1);
}

template<typename T, typename Traits>
ConsumerToken::ConsumerToken(BlockingConcurrentQueue<T, Traits>& queue)
	: itemsConsumedFromCurrent(0), currentProducer(nullptr), desiredProducer(nullptr)
{
	initialOffset = reinterpret_cast<ConcurrentQueue<T, Traits>*>(&queue)->nextExplicitConsumerId.fetch_add(1, std::memory_order_release);
	lastKnownGlobalOffset = static_cast<std::uint32_t>(-1);
}

template<typename T, typename Traits>
inline void swap(ConcurrentQueue<T, Traits>& a, ConcurrentQueue<T, Traits>& b) MOODYCAMEL_NOEXCEPT
{
	a.swap(b);
}

inline void swap(ProducerToken& a, ProducerToken& b) MOODYCAMEL_NOEXCEPT
{
	a.swap(b);
}

inline void swap(ConsumerToken& a, ConsumerToken& b) MOODYCAMEL_NOEXCEPT
{
	a.swap(b);
}

template<typename T, typename Traits>
inline void swap(typename ConcurrentQueue<T, Traits>::ImplicitProducerKVP& a, typename ConcurrentQueue<T, Traits>::ImplicitProducerKVP& b) MOODYCAMEL_NOEXCEPT
{
	a.swap(b);
}

}

#if defined(_MSC_VER) && (!defined(_HAS_CXX17) || !_HAS_CXX17)
#pragma warning(pop)
#endif

#if defined(__GNUC__) && !defined(__INTEL_COMPILER)
#pragma GCC diagnostic pop
#endif

```

`ext/d3d12memoryallocator/D3D12MemAlloc.cpp`:

```cpp
//
// Copyright (c) 2019-2021 Advanced Micro Devices, Inc. All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

#include "D3D12MemAlloc.h"

#ifndef D3D12MA_D3D12_HEADERS_ALREADY_INCLUDED
    #include <dxgi.h>
    #if D3D12MA_DXGI_1_4
        #include <dxgi1_4.h>
    #endif
#endif

#include <combaseapi.h>
#include <mutex>
#include <atomic>
#include <algorithm>
#include <utility>
#include <cstdlib>
#include <malloc.h> // for _aligned_malloc, _aligned_free

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// Configuration Begin
//
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

#ifndef D3D12MA_ASSERT
    #include <cassert>
    #define D3D12MA_ASSERT(cond) assert(cond)
#endif

// Assert that will be called very often, like inside data structures e.g. operator[].
// Making it non-empty can make program slow.
#ifndef D3D12MA_HEAVY_ASSERT
    #ifdef _DEBUG
        #define D3D12MA_HEAVY_ASSERT(expr)   //D3D12MA_ASSERT(expr)
    #else
        #define D3D12MA_HEAVY_ASSERT(expr)
    #endif
#endif

#ifndef D3D12MA_DEBUG_ALIGNMENT
    /*
    Minimum alignment of all allocations, in bytes.
    Set to more than 1 for debugging purposes only. Must be power of two.
    */
    #define D3D12MA_DEBUG_ALIGNMENT (1)
#endif

#ifndef D3D12MA_DEBUG_MARGIN
    // Minimum margin before and after every allocation, in bytes.
    // Set nonzero for debugging purposes only.
    #define D3D12MA_DEBUG_MARGIN (0)
#endif

#ifndef D3D12MA_DEBUG_GLOBAL_MUTEX
    /*
    Set this to 1 for debugging purposes only, to enable single mutex protecting all
    entry calls to the library. Can be useful for debugging multithreading issues.
    */
    #define D3D12MA_DEBUG_GLOBAL_MUTEX (0)
#endif

/*
Define this macro for debugging purposes only to force specific D3D12_RESOURCE_HEAP_TIER,
especially to test compatibility with D3D12_RESOURCE_HEAP_TIER_1 on modern GPUs.
*/
//#define D3D12MA_FORCE_RESOURCE_HEAP_TIER D3D12_RESOURCE_HEAP_TIER_1

#ifndef D3D12MA_DEFAULT_BLOCK_SIZE
   /// Default size of a block allocated as single ID3D12Heap.
   #define D3D12MA_DEFAULT_BLOCK_SIZE (64ull * 1024 * 1024)
#endif

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// Configuration End
//
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////


namespace D3D12MA
{

////////////////////////////////////////////////////////////////////////////////
// Private globals - CPU memory allocation

static void* DefaultAllocate(size_t Size, size_t Alignment, void* /*pUserData*/)
{
    return _aligned_malloc(Size, Alignment);
}
static void DefaultFree(void* pMemory, void* /*pUserData*/)
{
    return _aligned_free(pMemory);
}

static void* Malloc(const ALLOCATION_CALLBACKS& allocs, size_t size, size_t alignment)
{
    void* const result = (*allocs.pAllocate)(size, alignment, allocs.pUserData);
    D3D12MA_ASSERT(result);
    return result;
}
static void Free(const ALLOCATION_CALLBACKS& allocs, void* memory)
{
    (*allocs.pFree)(memory, allocs.pUserData);
}

template<typename T>
static T* Allocate(const ALLOCATION_CALLBACKS& allocs)
{
    return (T*)Malloc(allocs, sizeof(T), __alignof(T));
}
template<typename T>
static T* AllocateArray(const ALLOCATION_CALLBACKS& allocs, size_t count)
{
    return (T*)Malloc(allocs, sizeof(T) * count, __alignof(T));
}

#define D3D12MA_NEW(allocs, type) new(D3D12MA::Allocate<type>(allocs))(type)
#define D3D12MA_NEW_ARRAY(allocs, type, count) new(D3D12MA::AllocateArray<type>((allocs), (count)))(type)

template<typename T>
void D3D12MA_DELETE(const ALLOCATION_CALLBACKS& allocs, T* memory)
{
    if(memory)
    {
        memory->~T();
        Free(allocs, memory);
    }
}
template<typename T>
void D3D12MA_DELETE_ARRAY(const ALLOCATION_CALLBACKS& allocs, T* memory, size_t count)
{
    if(memory)
    {
        for(size_t i = count; i--; )
        {
            memory[i].~T();
        }
        Free(allocs, memory);
    }
}

static void SetupAllocationCallbacks(ALLOCATION_CALLBACKS& outAllocs, const ALLOCATION_CALLBACKS* allocationCallbacks)
{
    if(allocationCallbacks)
    {
        outAllocs = *allocationCallbacks;
        D3D12MA_ASSERT(outAllocs.pAllocate != NULL && outAllocs.pFree != NULL);
    }
    else
    {
        outAllocs.pAllocate = &DefaultAllocate;
        outAllocs.pFree = &DefaultFree;
        outAllocs.pUserData = NULL;
    }
}

////////////////////////////////////////////////////////////////////////////////
// Private globals - basic facilities

#define SAFE_RELEASE(ptr)   do { if(ptr) { (ptr)->Release(); (ptr) = NULL; } } while(false)

#define D3D12MA_VALIDATE(cond) do { if(!(cond)) { \
        D3D12MA_ASSERT(0 && "Validation failed: " #cond); \
        return false; \
    } } while(false)

const UINT NEW_BLOCK_SIZE_SHIFT_MAX = 3;

template<typename T>
static inline T D3D12MA_MIN(const T& a, const T& b)
{
    return a <= b ? a : b;
}
template<typename T>
static inline T D3D12MA_MAX(const T& a, const T& b)
{
    return a <= b ? b : a;
}

template<typename T>
static inline void D3D12MA_SWAP(T& a, T& b)
{
    T tmp = a; a = b; b = tmp;
}

#ifndef D3D12MA_MUTEX
    class Mutex
    {
    public:
        void Lock() { m_Mutex.lock(); }
        void Unlock() { m_Mutex.unlock(); }
    private:
        std::mutex m_Mutex;
    };
    #define D3D12MA_MUTEX Mutex
#endif

#if !defined(_WIN32) || !defined(WINVER) || WINVER < 0x0600
    #error Required at least WinAPI version supporting: client = Windows Vista, server = Windows Server 2008.
#endif

#ifndef D3D12MA_RW_MUTEX
    class RWMutex
    {
    public:
        RWMutex() { InitializeSRWLock(&m_Lock); }
        void LockRead() { AcquireSRWLockShared(&m_Lock); }
        void UnlockRead() { ReleaseSRWLockShared(&m_Lock); }
        void LockWrite() { AcquireSRWLockExclusive(&m_Lock); }
        void UnlockWrite() { ReleaseSRWLockExclusive(&m_Lock); }
    private:
        SRWLOCK m_Lock;
    };
    #define D3D12MA_RW_MUTEX RWMutex
#endif

/*
If providing your own implementation, you need to implement a subset of std::atomic.
*/
#ifndef D3D12MA_ATOMIC_UINT32
    #define D3D12MA_ATOMIC_UINT32 std::atomic<UINT>
#endif

#ifndef D3D12MA_ATOMIC_UINT64
    #define D3D12MA_ATOMIC_UINT64 std::atomic<UINT64>
#endif

/*
Returns true if given number is a power of two.
T must be unsigned integer number or signed integer but always nonnegative.
For 0 returns true.
*/
template <typename T>
inline bool IsPow2(T x)
{
    return (x & (x-1)) == 0;
}

// Aligns given value up to nearest multiply of align value. For example: AlignUp(11, 8) = 16.
// Use types like UINT, uint64_t as T.
template <typename T>
static inline T AlignUp(T val, T alignment)
{
    D3D12MA_HEAVY_ASSERT(IsPow2(alignment));
	return (val + alignment - 1) & ~(alignment - 1);
}
// Aligns given value down to nearest multiply of align value. For example: AlignUp(11, 8) = 8.
// Use types like UINT, uint64_t as T.
template <typename T>
static inline T AlignDown(T val, T alignment)
{
    D3D12MA_HEAVY_ASSERT(IsPow2(alignment));
    return val & ~(alignment - 1);
}

// Division with mathematical rounding to nearest number.
template <typename T>
static inline T RoundDiv(T x, T y)
{
	return (x + (y / (T)2)) / y;
}
template <typename T>
static inline T DivideRoudingUp(T x, T y)
{
    return (x + y - 1) / y;
}

// Returns smallest power of 2 greater or equal to v.
static inline UINT NextPow2(UINT v)
{
	v--;
    v |= v >> 1;
    v |= v >> 2;
    v |= v >> 4;
    v |= v >> 8;
    v |= v >> 16;
    v++;
    return v;
}
static inline uint64_t NextPow2(uint64_t v)
{
	v--;
    v |= v >> 1;
    v |= v >> 2;
    v |= v >> 4;
    v |= v >> 8;
    v |= v >> 16;
    v |= v >> 32;
    v++;
    return v;
}

// Returns largest power of 2 less or equal to v.
static inline UINT PrevPow2(UINT v)
{
    v |= v >> 1;
    v |= v >> 2;
    v |= v >> 4;
    v |= v >> 8;
    v |= v >> 16;
    v = v ^ (v >> 1);
    return v;
}
static inline uint64_t PrevPow2(uint64_t v)
{
    v |= v >> 1;
    v |= v >> 2;
    v |= v >> 4;
    v |= v >> 8;
    v |= v >> 16;
    v |= v >> 32;
    v = v ^ (v >> 1);
    return v;
}

static inline bool StrIsEmpty(const char* pStr)
{
    return pStr == NULL || *pStr == '\0';
}

// Helper RAII class to lock a mutex in constructor and unlock it in destructor (at the end of scope).
struct MutexLock
{
public:
    MutexLock(D3D12MA_MUTEX& mutex, bool useMutex = true) :
        m_pMutex(useMutex ? &mutex : NULL)
    {
        if(m_pMutex)
        {
            m_pMutex->Lock();
        }
    }
    ~MutexLock()
    {
        if(m_pMutex)
        {
            m_pMutex->Unlock();
        }
    }
private:
    D3D12MA_MUTEX* m_pMutex;

    D3D12MA_CLASS_NO_COPY(MutexLock)
};

// Helper RAII class to lock a RW mutex in constructor and unlock it in destructor (at the end of scope), for reading.
struct MutexLockRead
{
public:
    MutexLockRead(D3D12MA_RW_MUTEX& mutex, bool useMutex) :
        m_pMutex(useMutex ? &mutex : NULL)
    {
        if(m_pMutex)
        {
            m_pMutex->LockRead();
        }
    }
    ~MutexLockRead()
    {
        if(m_pMutex)
        {
            m_pMutex->UnlockRead();
        }
    }
private:
    D3D12MA_RW_MUTEX* m_pMutex;

    D3D12MA_CLASS_NO_COPY(MutexLockRead)
};

// Helper RAII class to lock a RW mutex in constructor and unlock it in destructor (at the end of scope), for writing.
struct MutexLockWrite
{
public:
    MutexLockWrite(D3D12MA_RW_MUTEX& mutex, bool useMutex) :
        m_pMutex(useMutex ? &mutex : NULL)
    {
        if(m_pMutex)
        {
            m_pMutex->LockWrite();
        }
    }
    ~MutexLockWrite()
    {
        if(m_pMutex)
        {
            m_pMutex->UnlockWrite();
        }
    }
private:
    D3D12MA_RW_MUTEX* m_pMutex;

    D3D12MA_CLASS_NO_COPY(MutexLockWrite)
};

#if D3D12MA_DEBUG_GLOBAL_MUTEX
    static D3D12MA_MUTEX g_DebugGlobalMutex;
    #define D3D12MA_DEBUG_GLOBAL_MUTEX_LOCK MutexLock debugGlobalMutexLock(g_DebugGlobalMutex, true);
#else
    #define D3D12MA_DEBUG_GLOBAL_MUTEX_LOCK
#endif

// Minimum size of a free suballocation to register it in the free suballocation collection.
static const UINT64 MIN_FREE_SUBALLOCATION_SIZE_TO_REGISTER = 16;

/*
Performs binary search and returns iterator to first element that is greater or
equal to `key`, according to comparison `cmp`.

Cmp should return true if first argument is less than second argument.

Returned value is the found element, if present in the collection or place where
new element with value (key) should be inserted.
*/
template <typename CmpLess, typename IterT, typename KeyT>
static IterT BinaryFindFirstNotLess(IterT beg, IterT end, const KeyT &key, const CmpLess& cmp)
{
    size_t down = 0, up = (end - beg);
    while(down < up)
    {
        const size_t mid = (down + up) / 2;
        if(cmp(*(beg+mid), key))
        {
            down = mid + 1;
        }
        else
        {
            up = mid;
        }
    }
    return beg + down;
}

/*
Performs binary search and returns iterator to an element that is equal to `key`,
according to comparison `cmp`.

Cmp should return true if first argument is less than second argument.

Returned value is the found element, if present in the collection or end if not
found.
*/
template<typename CmpLess, typename IterT, typename KeyT>
IterT BinaryFindSorted(const IterT& beg, const IterT& end, const KeyT& value, const CmpLess& cmp)
{
    IterT it = BinaryFindFirstNotLess<CmpLess, IterT, KeyT>(beg, end, value, cmp);
    if(it == end ||
        (!cmp(*it, value) && !cmp(value, *it)))
    {
        return it;
    }
    return end;
}

static UINT HeapTypeToIndex(D3D12_HEAP_TYPE type)
{
    switch(type)
    {
    case D3D12_HEAP_TYPE_DEFAULT:  return 0;
    case D3D12_HEAP_TYPE_UPLOAD:   return 1;
    case D3D12_HEAP_TYPE_READBACK: return 2;
    default: D3D12MA_ASSERT(0); return UINT_MAX;
    }
}

static const WCHAR* const HeapTypeNames[] = {
    L"DEFAULT",
    L"UPLOAD",
    L"READBACK",
};

// Stat helper functions

static void AddStatInfo(StatInfo& dst, const StatInfo& src)
{
    dst.BlockCount += src.BlockCount;
    dst.AllocationCount += src.AllocationCount;
    dst.UnusedRangeCount += src.UnusedRangeCount;
    dst.UsedBytes += src.UsedBytes;
    dst.UnusedBytes += src.UnusedBytes;
    dst.AllocationSizeMin = D3D12MA_MIN(dst.AllocationSizeMin, src.AllocationSizeMin);
    dst.AllocationSizeMax = D3D12MA_MAX(dst.AllocationSizeMax, src.AllocationSizeMax);
    dst.UnusedRangeSizeMin = D3D12MA_MIN(dst.UnusedRangeSizeMin, src.UnusedRangeSizeMin);
    dst.UnusedRangeSizeMax = D3D12MA_MAX(dst.UnusedRangeSizeMax, src.UnusedRangeSizeMax);
}

static void PostProcessStatInfo(StatInfo& statInfo)
{
    statInfo.AllocationSizeAvg = statInfo.AllocationCount ?
        statInfo.UsedBytes / statInfo.AllocationCount : 0;
    statInfo.UnusedRangeSizeAvg = statInfo.UnusedRangeCount ?
        statInfo.UnusedBytes / statInfo.UnusedRangeCount : 0;
}

static UINT64 HeapFlagsToAlignment(D3D12_HEAP_FLAGS flags)
{
    /*
    Documentation of D3D12_HEAP_DESC structure says:

    - D3D12_DEFAULT_RESOURCE_PLACEMENT_ALIGNMENT   defined as 64KB.
    - D3D12_DEFAULT_MSAA_RESOURCE_PLACEMENT_ALIGNMENT   defined as 4MB. An
    application must decide whether the heap will contain multi-sample
    anti-aliasing (MSAA), in which case, the application must choose [this flag].

    https://docs.microsoft.com/en-us/windows/desktop/api/d3d12/ns-d3d12-d3d12_heap_desc
    */

    const D3D12_HEAP_FLAGS denyAllTexturesFlags =
        D3D12_HEAP_FLAG_DENY_NON_RT_DS_TEXTURES | D3D12_HEAP_FLAG_DENY_RT_DS_TEXTURES;
    const bool canContainAnyTextures =
        (flags & denyAllTexturesFlags) != denyAllTexturesFlags;
    return canContainAnyTextures ?
        D3D12_DEFAULT_MSAA_RESOURCE_PLACEMENT_ALIGNMENT : D3D12_DEFAULT_RESOURCE_PLACEMENT_ALIGNMENT;
}

static bool IsFormatCompressed(DXGI_FORMAT format)
{
    switch(format)
    {
    case DXGI_FORMAT_BC1_TYPELESS:
    case DXGI_FORMAT_BC1_UNORM:
    case DXGI_FORMAT_BC1_UNORM_SRGB:
    case DXGI_FORMAT_BC2_TYPELESS:
    case DXGI_FORMAT_BC2_UNORM:
    case DXGI_FORMAT_BC2_UNORM_SRGB:
    case DXGI_FORMAT_BC3_TYPELESS:
    case DXGI_FORMAT_BC3_UNORM:
    case DXGI_FORMAT_BC3_UNORM_SRGB:
    case DXGI_FORMAT_BC4_TYPELESS:
    case DXGI_FORMAT_BC4_UNORM:
    case DXGI_FORMAT_BC4_SNORM:
    case DXGI_FORMAT_BC5_TYPELESS:
    case DXGI_FORMAT_BC5_UNORM:
    case DXGI_FORMAT_BC5_SNORM:
    case DXGI_FORMAT_BC6H_TYPELESS:
    case DXGI_FORMAT_BC6H_UF16:
    case DXGI_FORMAT_BC6H_SF16:
    case DXGI_FORMAT_BC7_TYPELESS:
    case DXGI_FORMAT_BC7_UNORM:
    case DXGI_FORMAT_BC7_UNORM_SRGB:
        return true;
    default:
        return false;
    }
}

// Only some formats are supported. For others it returns 0.
static UINT GetBitsPerPixel(DXGI_FORMAT format)
{
    switch(format)
    {
    case DXGI_FORMAT_R32G32B32A32_TYPELESS:
    case DXGI_FORMAT_R32G32B32A32_FLOAT:
    case DXGI_FORMAT_R32G32B32A32_UINT:
    case DXGI_FORMAT_R32G32B32A32_SINT:
        return 128;
    case DXGI_FORMAT_R32G32B32_TYPELESS:
    case DXGI_FORMAT_R32G32B32_FLOAT:
    case DXGI_FORMAT_R32G32B32_UINT:
    case DXGI_FORMAT_R32G32B32_SINT:
        return 96;
    case DXGI_FORMAT_R16G16B16A16_TYPELESS:
    case DXGI_FORMAT_R16G16B16A16_FLOAT:
    case DXGI_FORMAT_R16G16B16A16_UNORM:
    case DXGI_FORMAT_R16G16B16A16_UINT:
    case DXGI_FORMAT_R16G16B16A16_SNORM:
    case DXGI_FORMAT_R16G16B16A16_SINT:
        return 64;
    case DXGI_FORMAT_R32G32_TYPELESS:
    case DXGI_FORMAT_R32G32_FLOAT:
    case DXGI_FORMAT_R32G32_UINT:
    case DXGI_FORMAT_R32G32_SINT:
        return 64;
    case DXGI_FORMAT_R32G8X24_TYPELESS:
    case DXGI_FORMAT_D32_FLOAT_S8X24_UINT:
    case DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS:
    case DXGI_FORMAT_X32_TYPELESS_G8X24_UINT:
        return 64;
    case DXGI_FORMAT_R10G10B10A2_TYPELESS:
    case DXGI_FORMAT_R10G10B10A2_UNORM:
    case DXGI_FORMAT_R10G10B10A2_UINT:
    case DXGI_FORMAT_R11G11B10_FLOAT:
        return 32;
    case DXGI_FORMAT_R8G8B8A8_TYPELESS:
    case DXGI_FORMAT_R8G8B8A8_UNORM:
    case DXGI_FORMAT_R8G8B8A8_UNORM_SRGB:
    case DXGI_FORMAT_R8G8B8A8_UINT:
    case DXGI_FORMAT_R8G8B8A8_SNORM:
    case DXGI_FORMAT_R8G8B8A8_SINT:
        return 32;
    case DXGI_FORMAT_R16G16_TYPELESS:
    case DXGI_FORMAT_R16G16_FLOAT:
    case DXGI_FORMAT_R16G16_UNORM:
    case DXGI_FORMAT_R16G16_UINT:
    case DXGI_FORMAT_R16G16_SNORM:
    case DXGI_FORMAT_R16G16_SINT:
        return 32;
    case DXGI_FORMAT_R32_TYPELESS:
    case DXGI_FORMAT_D32_FLOAT:
    case DXGI_FORMAT_R32_FLOAT:
    case DXGI_FORMAT_R32_UINT:
    case DXGI_FORMAT_R32_SINT:
        return 32;
    case DXGI_FORMAT_R24G8_TYPELESS:
    case DXGI_FORMAT_D24_UNORM_S8_UINT:
    case DXGI_FORMAT_R24_UNORM_X8_TYPELESS:
    case DXGI_FORMAT_X24_TYPELESS_G8_UINT:
        return 32;
    case DXGI_FORMAT_R8G8_TYPELESS:
    case DXGI_FORMAT_R8G8_UNORM:
    case DXGI_FORMAT_R8G8_UINT:
    case DXGI_FORMAT_R8G8_SNORM:
    case DXGI_FORMAT_R8G8_SINT:
        return 16;
    case DXGI_FORMAT_R16_TYPELESS:
    case DXGI_FORMAT_R16_FLOAT:
    case DXGI_FORMAT_D16_UNORM:
    case DXGI_FORMAT_R16_UNORM:
    case DXGI_FORMAT_R16_UINT:
    case DXGI_FORMAT_R16_SNORM:
    case DXGI_FORMAT_R16_SINT:
        return 16;
    case DXGI_FORMAT_R8_TYPELESS:
    case DXGI_FORMAT_R8_UNORM:
    case DXGI_FORMAT_R8_UINT:
    case DXGI_FORMAT_R8_SNORM:
    case DXGI_FORMAT_R8_SINT:
    case DXGI_FORMAT_A8_UNORM:
        return 8;
    case DXGI_FORMAT_BC1_TYPELESS:
    case DXGI_FORMAT_BC1_UNORM:
    case DXGI_FORMAT_BC1_UNORM_SRGB:
        return 4;
    case DXGI_FORMAT_BC2_TYPELESS:
    case DXGI_FORMAT_BC2_UNORM:
    case DXGI_FORMAT_BC2_UNORM_SRGB:
        return 8;
    case DXGI_FORMAT_BC3_TYPELESS:
    case DXGI_FORMAT_BC3_UNORM:
    case DXGI_FORMAT_BC3_UNORM_SRGB:
        return 8;
    case DXGI_FORMAT_BC4_TYPELESS:
    case DXGI_FORMAT_BC4_UNORM:
    case DXGI_FORMAT_BC4_SNORM:
        return 4;
    case DXGI_FORMAT_BC5_TYPELESS:
    case DXGI_FORMAT_BC5_UNORM:
    case DXGI_FORMAT_BC5_SNORM:
        return 8;
    case DXGI_FORMAT_BC6H_TYPELESS:
    case DXGI_FORMAT_BC6H_UF16:
    case DXGI_FORMAT_BC6H_SF16:
        return 8;
    case DXGI_FORMAT_BC7_TYPELESS:
    case DXGI_FORMAT_BC7_UNORM:
    case DXGI_FORMAT_BC7_UNORM_SRGB:
        return 8;
    default:
        return 0;
    }
}

// This algorithm is overly conservative.
template<typename D3D12_RESOURCE_DESC_T>
static bool CanUseSmallAlignment(const D3D12_RESOURCE_DESC_T& resourceDesc)
{
    if(resourceDesc.Dimension != D3D12_RESOURCE_DIMENSION_TEXTURE2D)
        return false;
    if((resourceDesc.Flags & (D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET | D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL)) != 0)
        return false;
    if(resourceDesc.SampleDesc.Count > 1)
        return false;
    if(resourceDesc.DepthOrArraySize != 1)
        return false;

    UINT sizeX = (UINT)resourceDesc.Width;
    UINT sizeY = resourceDesc.Height;
    UINT bitsPerPixel = GetBitsPerPixel(resourceDesc.Format);
    if(bitsPerPixel == 0)
        return false;

    if(IsFormatCompressed(resourceDesc.Format))
    {
        sizeX = DivideRoudingUp(sizeX / 4, 1u);
        sizeY = DivideRoudingUp(sizeY / 4, 1u);
        bitsPerPixel *= 16;
    }

    UINT tileSizeX = 0, tileSizeY = 0;
    switch(bitsPerPixel)
    {
    case   8: tileSizeX = 64; tileSizeY = 64; break;
    case  16: tileSizeX = 64; tileSizeY = 32; break;
    case  32: tileSizeX = 32; tileSizeY = 32; break;
    case  64: tileSizeX = 32; tileSizeY = 16; break;
    case 128: tileSizeX = 16; tileSizeY = 16; break;
    default: return false;
    }

    const UINT tileCount = DivideRoudingUp(sizeX, tileSizeX) * DivideRoudingUp(sizeY, tileSizeY);
    return tileCount <= 16;
}

static D3D12_HEAP_FLAGS GetExtraHeapFlagsToIgnore()
{
    D3D12_HEAP_FLAGS result =
        D3D12_HEAP_FLAG_DENY_BUFFERS | D3D12_HEAP_FLAG_DENY_RT_DS_TEXTURES | D3D12_HEAP_FLAG_DENY_NON_RT_DS_TEXTURES;
    return result;
}

static inline bool IsHeapTypeValid(D3D12_HEAP_TYPE type)
{
    return type == D3D12_HEAP_TYPE_DEFAULT ||
        type == D3D12_HEAP_TYPE_UPLOAD ||
        type == D3D12_HEAP_TYPE_READBACK;
}

////////////////////////////////////////////////////////////////////////////////
// Private class Vector

/*
Dynamically resizing continuous array. Class with interface similar to std::vector.
T must be POD because constructors and destructors are not called and memcpy is
used for these objects.
*/
template<typename T>
class Vector
{
public:
    typedef T value_type;

    // allocationCallbacks externally owned, must outlive this object.
    Vector(const ALLOCATION_CALLBACKS& allocationCallbacks) :
        m_AllocationCallbacks(allocationCallbacks),
        m_pArray(NULL),
        m_Count(0),
        m_Capacity(0)
    {
    }

    Vector(size_t count, const ALLOCATION_CALLBACKS& allocationCallbacks) :
        m_AllocationCallbacks(allocationCallbacks),
        m_pArray(count ? AllocateArray<T>(allocationCallbacks, count) : NULL),
        m_Count(count),
        m_Capacity(count)
    {
    }

    Vector(const Vector<T>& src) :
        m_AllocationCallbacks(src.m_AllocationCallbacks),
        m_pArray(src.m_Count ? AllocateArray<T>(src.m_AllocationCallbacks, src.m_Count) : NULL),
        m_Count(src.m_Count),
        m_Capacity(src.m_Count)
    {
        if(m_Count > 0)
        {
            memcpy(m_pArray, src.m_pArray, m_Count * sizeof(T));
        }
    }

    ~Vector()
    {
        Free(m_AllocationCallbacks, m_pArray);
    }

    Vector& operator=(const Vector<T>& rhs)
    {
        if(&rhs != this)
        {
            resize(rhs.m_Count);
            if(m_Count != 0)
            {
                memcpy(m_pArray, rhs.m_pArray, m_Count * sizeof(T));
            }
        }
        return *this;
    }

    bool empty() const { return m_Count == 0; }
    size_t size() const { return m_Count; }
    T* data() { return m_pArray; }
    const T* data() const { return m_pArray; }

    T& operator[](size_t index)
    {
        D3D12MA_HEAVY_ASSERT(index < m_Count);
        return m_pArray[index];
    }
    const T& operator[](size_t index) const
    {
        D3D12MA_HEAVY_ASSERT(index < m_Count);
        return m_pArray[index];
    }

    T& front()
    {
        D3D12MA_HEAVY_ASSERT(m_Count > 0);
        return m_pArray[0];
    }
    const T& front() const
    {
        D3D12MA_HEAVY_ASSERT(m_Count > 0);
        return m_pArray[0];
    }
    T& back()
    {
        D3D12MA_HEAVY_ASSERT(m_Count > 0);
        return m_pArray[m_Count - 1];
    }
    const T& back() const
    {
        D3D12MA_HEAVY_ASSERT(m_Count > 0);
        return m_pArray[m_Count - 1];
    }

    void reserve(size_t newCapacity, bool freeMemory = false)
    {
        newCapacity = D3D12MA_MAX(newCapacity, m_Count);

        if((newCapacity < m_Capacity) && !freeMemory)
        {
            newCapacity = m_Capacity;
        }

        if(newCapacity != m_Capacity)
        {
            T* const newArray = newCapacity ? AllocateArray<T>(m_AllocationCallbacks, newCapacity) : NULL;
            if(m_Count != 0)
            {
                memcpy(newArray, m_pArray, m_Count * sizeof(T));
            }
            Free(m_AllocationCallbacks, m_pArray);
            m_Capacity = newCapacity;
            m_pArray = newArray;
        }
    }

    void resize(size_t newCount, bool freeMemory = false)
    {
        size_t newCapacity = m_Capacity;
        if(newCount > m_Capacity)
        {
            newCapacity = D3D12MA_MAX(newCount, D3D12MA_MAX(m_Capacity * 3 / 2, (size_t)8));
        }
        else if(freeMemory)
        {
            newCapacity = newCount;
        }

        if(newCapacity != m_Capacity)
        {
            T* const newArray = newCapacity ? AllocateArray<T>(m_AllocationCallbacks, newCapacity) : NULL;
            const size_t elementsToCopy = D3D12MA_MIN(m_Count, newCount);
            if(elementsToCopy != 0)
            {
                memcpy(newArray, m_pArray, elementsToCopy * sizeof(T));
            }
            Free(m_AllocationCallbacks, m_pArray);
            m_Capacity = newCapacity;
            m_pArray = newArray;
        }

        m_Count = newCount;
    }

    void clear(bool freeMemory = false)
    {
        resize(0, freeMemory);
    }

    void insert(size_t index, const T& src)
    {
        D3D12MA_HEAVY_ASSERT(index <= m_Count);
        const size_t oldCount = size();
        resize(oldCount + 1);
        if(index < oldCount)
        {
            memmove(m_pArray + (index + 1), m_pArray + index, (oldCount - index) * sizeof(T));
        }
        m_pArray[index] = src;
    }

    void remove(size_t index)
    {
        D3D12MA_HEAVY_ASSERT(index < m_Count);
        const size_t oldCount = size();
        if(index < oldCount - 1)
        {
            memmove(m_pArray + index, m_pArray + (index + 1), (oldCount - index - 1) * sizeof(T));
        }
        resize(oldCount - 1);
    }

    void push_back(const T& src)
    {
        const size_t newIndex = size();
        resize(newIndex + 1);
        m_pArray[newIndex] = src;
    }

    void pop_back()
    {
        D3D12MA_HEAVY_ASSERT(m_Count > 0);
        resize(size() - 1);
    }

    void push_front(const T& src)
    {
        insert(0, src);
    }

    void pop_front()
    {
        D3D12MA_HEAVY_ASSERT(m_Count > 0);
        remove(0);
    }

    typedef T* iterator;

    iterator begin() { return m_pArray; }
    iterator end() { return m_pArray + m_Count; }

    template<typename CmpLess>
    size_t InsertSorted(const T& value, const CmpLess& cmp)
    {
        const size_t indexToInsert = BinaryFindFirstNotLess<CmpLess, iterator, T>(
            m_pArray,
            m_pArray + m_Count,
            value,
            cmp) - m_pArray;
        insert(indexToInsert, value);
        return indexToInsert;
    }

    template<typename CmpLess>
    bool RemoveSorted(const T& value, const CmpLess& cmp)
    {
        const iterator it = BinaryFindFirstNotLess(
            m_pArray,
            m_pArray + m_Count,
            value,
            cmp);
        if((it != end()) && !cmp(*it, value) && !cmp(value, *it))
        {
            size_t indexToRemove = it - begin();
            remove(indexToRemove);
            return true;
        }
        return false;
    }

private:
    const ALLOCATION_CALLBACKS& m_AllocationCallbacks;
    T* m_pArray;
    size_t m_Count;
    size_t m_Capacity;
};

////////////////////////////////////////////////////////////////////////////////
// Private class StringBuilder

class StringBuilder
{
public:
    StringBuilder(const ALLOCATION_CALLBACKS& allocationCallbacks) : m_Data(allocationCallbacks) { }

    size_t GetLength() const { return m_Data.size(); }
    LPCWSTR GetData() const { return m_Data.data(); }

    void Add(WCHAR ch) { m_Data.push_back(ch); }
    void Add(LPCWSTR str);
    void AddNewLine() { Add(L'\n'); }
    void AddNumber(UINT num);
    void AddNumber(UINT64 num);

private:
    Vector<WCHAR> m_Data;
};

void StringBuilder::Add(LPCWSTR str)
{
    const size_t len = wcslen(str);
    if (len > 0)
    {
        const size_t oldCount = m_Data.size();
        m_Data.resize(oldCount + len);
        memcpy(m_Data.data() + oldCount, str, len * sizeof(WCHAR));
    }
}

void StringBuilder::AddNumber(UINT num)
{
    WCHAR buf[11];
    buf[10] = L'\0';
    WCHAR *p = &buf[10];
    do
    {
        *--p = L'0' + (num % 10);
        num /= 10;
    }
    while (num);
    Add(p);
}

void StringBuilder::AddNumber(UINT64 num)
{
    WCHAR buf[21];
    buf[20] = L'\0';
    WCHAR *p = &buf[20];
    do
    {
        *--p = L'0' + (num % 10);
        num /= 10;
    }
    while (num);
    Add(p);
}

////////////////////////////////////////////////////////////////////////////////
// Private class JsonWriter
class JsonWriter
{
public:
    JsonWriter(const ALLOCATION_CALLBACKS& allocationCallbacks, StringBuilder& stringBuilder);
    ~JsonWriter();

    void BeginObject(bool singleLine = false);
    void EndObject();

    void BeginArray(bool singleLine = false);
    void EndArray();

    void WriteString(LPCWSTR pStr);
    void BeginString(LPCWSTR pStr = NULL);
    void ContinueString(LPCWSTR pStr);
    void ContinueString(UINT num);
    void ContinueString(UINT64 num);
    void AddAllocationToObject(const Allocation& alloc);
    // void ContinueString_Pointer(const void* ptr);
    void EndString(LPCWSTR pStr = NULL);

    void WriteNumber(UINT num);
    void WriteNumber(UINT64 num);
    void WriteBool(bool b);
    void WriteNull();

private:
    static const WCHAR* const INDENT;

    enum CollectionType
    {
        COLLECTION_TYPE_OBJECT,
        COLLECTION_TYPE_ARRAY,
    };
    struct StackItem
    {
        CollectionType type;
        UINT valueCount;
        bool singleLineMode;
    };

    StringBuilder& m_SB;
    Vector<StackItem> m_Stack;
    bool m_InsideString;

    void BeginValue(bool isString);
    void WriteIndent(bool oneLess = false);
};

const WCHAR* const JsonWriter::INDENT = L"  ";

JsonWriter::JsonWriter(const ALLOCATION_CALLBACKS& allocationCallbacks, StringBuilder& stringBuilder) :
    m_SB(stringBuilder),
    m_Stack(allocationCallbacks),
    m_InsideString(false)
{
}

JsonWriter::~JsonWriter()
{
    D3D12MA_ASSERT(!m_InsideString);
    D3D12MA_ASSERT(m_Stack.empty());
}

void JsonWriter::BeginObject(bool singleLine)
{
    D3D12MA_ASSERT(!m_InsideString);

    BeginValue(false);
    m_SB.Add(L'{');

    StackItem stackItem;
    stackItem.type = COLLECTION_TYPE_OBJECT;
    stackItem.valueCount = 0;
    stackItem.singleLineMode = singleLine;
    m_Stack.push_back(stackItem);
}

void JsonWriter::EndObject()
{
    D3D12MA_ASSERT(!m_InsideString);
    D3D12MA_ASSERT(!m_Stack.empty() && m_Stack.back().type == COLLECTION_TYPE_OBJECT);
    D3D12MA_ASSERT(m_Stack.back().valueCount % 2 == 0);

    WriteIndent(true);
    m_SB.Add(L'}');

    m_Stack.pop_back();
}

void JsonWriter::BeginArray(bool singleLine)
{
    D3D12MA_ASSERT(!m_InsideString);

    BeginValue(false);
    m_SB.Add(L'[');

    StackItem stackItem;
    stackItem.type = COLLECTION_TYPE_ARRAY;
    stackItem.valueCount = 0;
    stackItem.singleLineMode = singleLine;
    m_Stack.push_back(stackItem);
}

void JsonWriter::EndArray()
{
    D3D12MA_ASSERT(!m_InsideString);
    D3D12MA_ASSERT(!m_Stack.empty() && m_Stack.back().type == COLLECTION_TYPE_ARRAY);

    WriteIndent(true);
    m_SB.Add(L']');

    m_Stack.pop_back();
}

void JsonWriter::WriteString(LPCWSTR pStr)
{
    BeginString(pStr);
    EndString();
}

void JsonWriter::BeginString(LPCWSTR pStr)
{
    D3D12MA_ASSERT(!m_InsideString);

    BeginValue(true);
    m_InsideString = true;
    m_SB.Add(L'"');
    if (pStr != NULL)
    {
        ContinueString(pStr);
    }
}

void JsonWriter::ContinueString(LPCWSTR pStr)
{
    D3D12MA_ASSERT(m_InsideString);
    D3D12MA_ASSERT(pStr);

    for (const WCHAR *p = pStr; *p; ++p)
    {
        // the strings we encode are assumed to be in UTF-16LE format, the native
        // windows wide character unicode format. In this encoding unicode code
        // points U+0000 to U+D7FF and U+E000 to U+FFFF are encoded in two bytes,
        // and everything else takes more than two bytes. We will reject any
        // multi wchar character encodings for simplicity.
        UINT val = (UINT)*p;
        D3D12MA_ASSERT(((val <= 0xD7FF) || (0xE000 <= val && val <= 0xFFFF)) &&
            "Character not currently supported.");
        switch (*p)
        {
        case L'"':  m_SB.Add(L'\\'); m_SB.Add(L'"');  break;
        case L'\\': m_SB.Add(L'\\'); m_SB.Add(L'\\'); break;
        case L'/':  m_SB.Add(L'\\'); m_SB.Add(L'/');  break;
        case L'\b': m_SB.Add(L'\\'); m_SB.Add(L'b');  break;
        case L'\f': m_SB.Add(L'\\'); m_SB.Add(L'f');  break;
        case L'\n': m_SB.Add(L'\\'); m_SB.Add(L'n');  break;
        case L'\r': m_SB.Add(L'\\'); m_SB.Add(L'r');  break;
        case L'\t': m_SB.Add(L'\\'); m_SB.Add(L't');  break;
        default:
            // conservatively use encoding \uXXXX for any unicode character
            // requiring more than one byte.
            if (32 <= val && val < 256)
                m_SB.Add(*p);
            else
            {
                m_SB.Add(L'\\');
                m_SB.Add(L'u');
                for (UINT i = 0; i < 4; ++i)
                {
                    UINT hexDigit = (val & 0xF000) >> 12;
                    val <<= 4;
                    if (hexDigit < 10)
                        m_SB.Add(L'0' + (WCHAR)hexDigit);
                    else
                        m_SB.Add(L'A' + (WCHAR)hexDigit);
                }
            }
            break;
        }
    }
}

void JsonWriter::ContinueString(UINT num)
{
    D3D12MA_ASSERT(m_InsideString);
    m_SB.AddNumber(num);
}

void JsonWriter::ContinueString(UINT64 num)
{
    D3D12MA_ASSERT(m_InsideString);
    m_SB.AddNumber(num);
}

void JsonWriter::EndString(LPCWSTR pStr)
{
    D3D12MA_ASSERT(m_InsideString);

    if (pStr)
        ContinueString(pStr);
    m_SB.Add(L'"');
    m_InsideString = false;
}

void JsonWriter::WriteNumber(UINT num)
{
    D3D12MA_ASSERT(!m_InsideString);
    BeginValue(false);
    m_SB.AddNumber(num);
}

void JsonWriter::WriteNumber(UINT64 num)
{
    D3D12MA_ASSERT(!m_InsideString);
    BeginValue(false);
    m_SB.AddNumber(num);
}

void JsonWriter::WriteBool(bool b)
{
    D3D12MA_ASSERT(!m_InsideString);
    BeginValue(false);
    if (b)
        m_SB.Add(L"true");
    else
        m_SB.Add(L"false");
}

void JsonWriter::WriteNull()
{
    D3D12MA_ASSERT(!m_InsideString);
    BeginValue(false);
    m_SB.Add(L"null");
}

void JsonWriter::BeginValue(bool isString)
{
    if (!m_Stack.empty())
    {
        StackItem& currItem = m_Stack.back();
        if (currItem.type == COLLECTION_TYPE_OBJECT && currItem.valueCount % 2 == 0)
        {
            D3D12MA_ASSERT(isString);
        }

        if (currItem.type == COLLECTION_TYPE_OBJECT && currItem.valueCount % 2 == 1)
        {
            m_SB.Add(L':'); m_SB.Add(L' ');
        }
        else if (currItem.valueCount > 0)
        {
            m_SB.Add(L','); m_SB.Add(L' ');
            WriteIndent();
        }
        else
        {
            WriteIndent();
        }
        ++currItem.valueCount;
    }
}

void JsonWriter::WriteIndent(bool oneLess)
{
    if (!m_Stack.empty() && !m_Stack.back().singleLineMode)
    {
        m_SB.AddNewLine();

        size_t count = m_Stack.size();
        if (count > 0 && oneLess)
        {
            --count;
        }
        for (size_t i = 0; i < count; ++i)
        {
            m_SB.Add(INDENT);
        }
    }
}

void JsonWriter::AddAllocationToObject(const Allocation& alloc)
{
    WriteString(L"Type");
    switch (alloc.m_PackedData.GetResourceDimension()) {
    case D3D12_RESOURCE_DIMENSION_UNKNOWN:
        WriteString(L"UNKNOWN");
        break;
    case D3D12_RESOURCE_DIMENSION_BUFFER:
        WriteString(L"BUFFER");
        break;
    case D3D12_RESOURCE_DIMENSION_TEXTURE1D:
        WriteString(L"TEXTURE1D");
        break;
    case D3D12_RESOURCE_DIMENSION_TEXTURE2D:
        WriteString(L"TEXTURE2D");
        break;
    case D3D12_RESOURCE_DIMENSION_TEXTURE3D:
        WriteString(L"TEXTURE3D");
        break;
    default: D3D12MA_ASSERT(0); break;
    }
    WriteString(L"Size");
    WriteNumber(alloc.GetSize());
    LPCWSTR name = alloc.GetName();
    if(name != NULL)
    {
        WriteString(L"Name");
        WriteString(name);
    }
    if(alloc.m_PackedData.GetResourceFlags())
    {
        WriteString(L"Flags");
        WriteNumber((UINT)alloc.m_PackedData.GetResourceFlags());
    }
    if(alloc.m_PackedData.GetTextureLayout())
    {
        WriteString(L"Layout");
        WriteNumber((UINT)alloc.m_PackedData.GetTextureLayout());
    }
    if(alloc.m_CreationFrameIndex)
    {
        WriteString(L"CreationFrameIndex");
        WriteNumber(alloc.m_CreationFrameIndex);
    }
}

////////////////////////////////////////////////////////////////////////////////
// Private class PoolAllocator

/*
Allocator for objects of type T using a list of arrays (pools) to speed up
allocation. Number of elements that can be allocated is not bounded because
allocator can create multiple blocks.
T should be POD because constructor and destructor is not called in Alloc or
Free.
*/
template<typename T>
class PoolAllocator
{
    D3D12MA_CLASS_NO_COPY(PoolAllocator)
public:
    // allocationCallbacks externally owned, must outlive this object.
    PoolAllocator(const ALLOCATION_CALLBACKS& allocationCallbacks, UINT firstBlockCapacity);
    ~PoolAllocator() { Clear(); }
    void Clear();
    template<typename... Types> T* Alloc(Types... args);
    void Free(T* ptr);

private:
    union Item
    {
        UINT NextFreeIndex; // UINT32_MAX means end of list.
        alignas(T) char Value[sizeof(T)];
    };

    struct ItemBlock
    {
        Item* pItems;
        UINT Capacity;
        UINT FirstFreeIndex;
    };

    const ALLOCATION_CALLBACKS& m_AllocationCallbacks;
    const UINT m_FirstBlockCapacity;
    Vector<ItemBlock> m_ItemBlocks;

    ItemBlock& CreateNewBlock();
};

template<typename T>
PoolAllocator<T>::PoolAllocator(const ALLOCATION_CALLBACKS& allocationCallbacks, UINT firstBlockCapacity) :
    m_AllocationCallbacks(allocationCallbacks),
    m_FirstBlockCapacity(firstBlockCapacity),
    m_ItemBlocks(allocationCallbacks)
{
    D3D12MA_ASSERT(m_FirstBlockCapacity > 1);
}

template<typename T>
void PoolAllocator<T>::Clear()
{
    for(size_t i = m_ItemBlocks.size(); i--; )
    {
        D3D12MA_DELETE_ARRAY(m_AllocationCallbacks, m_ItemBlocks[i].pItems, m_ItemBlocks[i].Capacity);
    }
    m_ItemBlocks.clear(true);
}

template<typename T>
template<typename... Types> T* PoolAllocator<T>::Alloc(Types... args)
{
    for(size_t i = m_ItemBlocks.size(); i--; )
    {
        ItemBlock& block = m_ItemBlocks[i];
        // This block has some free items: Use first one.
        if(block.FirstFreeIndex != UINT32_MAX)
        {
            Item* const pItem = &block.pItems[block.FirstFreeIndex];
            block.FirstFreeIndex = pItem->NextFreeIndex;
            T* result = (T*)&pItem->Value;
            new(result)T(std::forward<Types>(args)...); // Explicit constructor call.
            return result;
        }
    }

    // No block has free item: Create new one and use it.
    ItemBlock& newBlock = CreateNewBlock();
    Item* const pItem = &newBlock.pItems[0];
    newBlock.FirstFreeIndex = pItem->NextFreeIndex;
    T* result = (T*)pItem->Value;
    new(result)T(std::forward<Types>(args)...); // Explicit constructor call.
    return result;
}

template<typename T>
void PoolAllocator<T>::Free(T* ptr)
{
    // Search all memory blocks to find ptr.
    for(size_t i = m_ItemBlocks.size(); i--; )
    {
        ItemBlock& block = m_ItemBlocks[i];

        Item* pItemPtr;
        memcpy(&pItemPtr, &ptr, sizeof(pItemPtr));

        // Check if pItemPtr is in address range of this block.
        if((pItemPtr >= block.pItems) && (pItemPtr < block.pItems + block.Capacity))
        {
            ptr->~T(); // Explicit destructor call.
            const UINT index = static_cast<UINT>(pItemPtr - block.pItems);
            pItemPtr->NextFreeIndex = block.FirstFreeIndex;
            block.FirstFreeIndex = index;
            return;
        }
    }
    D3D12MA_ASSERT(0 && "Pointer doesn't belong to this memory pool.");
}

template<typename T>
typename PoolAllocator<T>::ItemBlock& PoolAllocator<T>::CreateNewBlock()
{
    const UINT newBlockCapacity = m_ItemBlocks.empty() ?
        m_FirstBlockCapacity : m_ItemBlocks.back().Capacity * 3 / 2;

    const ItemBlock newBlock = {
        D3D12MA_NEW_ARRAY(m_AllocationCallbacks, Item, newBlockCapacity),
        newBlockCapacity,
        0 };

    m_ItemBlocks.push_back(newBlock);

    // Setup singly-linked list of all free items in this block.
    for(UINT i = 0; i < newBlockCapacity - 1; ++i)
    {
        newBlock.pItems[i].NextFreeIndex = i + 1;
    }
    newBlock.pItems[newBlockCapacity - 1].NextFreeIndex = UINT32_MAX;
    return m_ItemBlocks.back();
}

////////////////////////////////////////////////////////////////////////////////
// Private class List

/*
Doubly linked list, with elements allocated out of PoolAllocator.
Has custom interface, as well as STL-style interface, including iterator and
const_iterator.
*/
template<typename T>
class List
{
    D3D12MA_CLASS_NO_COPY(List)
public:
    struct Item
    {
        Item* pPrev;
        Item* pNext;
        T Value;
    };

    // allocationCallbacks externally owned, must outlive this object.
    List(const ALLOCATION_CALLBACKS& allocationCallbacks);
    ~List();
    void Clear();

    size_t GetCount() const { return m_Count; }
    bool IsEmpty() const { return m_Count == 0; }

    Item* Front() { return m_pFront; }
    const Item* Front() const { return m_pFront; }
    Item* Back() { return m_pBack; }
    const Item* Back() const { return m_pBack; }

    Item* PushBack();
    Item* PushFront();
    Item* PushBack(const T& value);
    Item* PushFront(const T& value);
    void PopBack();
    void PopFront();

    // Item can be null - it means PushBack.
    Item* InsertBefore(Item* pItem);
    // Item can be null - it means PushFront.
    Item* InsertAfter(Item* pItem);

    Item* InsertBefore(Item* pItem, const T& value);
    Item* InsertAfter(Item* pItem, const T& value);

    void Remove(Item* pItem);

    class iterator
    {
    public:
        iterator() :
            m_pList(NULL),
            m_pItem(NULL)
        {
        }

        T& operator*() const
        {
            D3D12MA_HEAVY_ASSERT(m_pItem != NULL);
            return m_pItem->Value;
        }
        T* operator->() const
        {
            D3D12MA_HEAVY_ASSERT(m_pItem != NULL);
            return &m_pItem->Value;
        }

        iterator& operator++()
        {
            D3D12MA_HEAVY_ASSERT(m_pItem != NULL);
            m_pItem = m_pItem->pNext;
            return *this;
        }
        iterator& operator--()
        {
            if(m_pItem != NULL)
            {
                m_pItem = m_pItem->pPrev;
            }
            else
            {
                D3D12MA_HEAVY_ASSERT(!m_pList->IsEmpty());
                m_pItem = m_pList->Back();
            }
            return *this;
        }

        iterator operator++(int)
        {
            iterator result = *this;
            ++*this;
            return result;
        }
        iterator operator--(int)
        {
            iterator result = *this;
            --*this;
            return result;
        }

        bool operator==(const iterator& rhs) const
        {
            D3D12MA_HEAVY_ASSERT(m_pList == rhs.m_pList);
            return m_pItem == rhs.m_pItem;
        }
        bool operator!=(const iterator& rhs) const
        {
            D3D12MA_HEAVY_ASSERT(m_pList == rhs.m_pList);
            return m_pItem != rhs.m_pItem;
        }

    private:
        List<T>* m_pList;
        Item* m_pItem;

        iterator(List<T>* pList, Item* pItem) :
            m_pList(pList),
            m_pItem(pItem)
        {
        }

        friend class List<T>;
    };

    class const_iterator
    {
    public:
        const_iterator() :
            m_pList(NULL),
            m_pItem(NULL)
        {
        }

        const_iterator(const iterator& src) :
            m_pList(src.m_pList),
            m_pItem(src.m_pItem)
        {
        }

        const T& operator*() const
        {
            D3D12MA_HEAVY_ASSERT(m_pItem != NULL);
            return m_pItem->Value;
        }
        const T* operator->() const
        {
            D3D12MA_HEAVY_ASSERT(m_pItem != NULL);
            return &m_pItem->Value;
        }

        const_iterator& operator++()
        {
            D3D12MA_HEAVY_ASSERT(m_pItem != NULL);
            m_pItem = m_pItem->pNext;
            return *this;
        }
        const_iterator& operator--()
        {
            if(m_pItem != NULL)
            {
                m_pItem = m_pItem->pPrev;
            }
            else
            {
                D3D12MA_HEAVY_ASSERT(!m_pList->IsEmpty());
                m_pItem = m_pList->Back();
            }
            return *this;
        }

        const_iterator operator++(int)
        {
            const_iterator result = *this;
            ++*this;
            return result;
        }
        const_iterator operator--(int)
        {
            const_iterator result = *this;
            --*this;
            return result;
        }

        bool operator==(const const_iterator& rhs) const
        {
            D3D12MA_HEAVY_ASSERT(m_pList == rhs.m_pList);
            return m_pItem == rhs.m_pItem;
        }
        bool operator!=(const const_iterator& rhs) const
        {
            D3D12MA_HEAVY_ASSERT(m_pList == rhs.m_pList);
            return m_pItem != rhs.m_pItem;
        }

    private:
        const_iterator(const List<T>* pList, const Item* pItem) :
            m_pList(pList),
            m_pItem(pItem)
        {
        }

        const List<T>* m_pList;
        const Item* m_pItem;

        friend class List<T>;
    };

    bool empty() const { return IsEmpty(); }
    size_t size() const { return GetCount(); }

    iterator begin() { return iterator(this, Front()); }
    iterator end() { return iterator(this, NULL); }

    const_iterator cbegin() const { return const_iterator(this, Front()); }
    const_iterator cend() const { return const_iterator(this, NULL); }

    void clear() { Clear(); }
    void push_back(const T& value) { PushBack(value); }
    void erase(iterator it) { Remove(it.m_pItem); }
    iterator insert(iterator it, const T& value) { return iterator(this, InsertBefore(it.m_pItem, value)); }

private:
    const ALLOCATION_CALLBACKS& m_AllocationCallbacks;
    PoolAllocator<Item> m_ItemAllocator;
    Item* m_pFront;
    Item* m_pBack;
    size_t m_Count;
};

template<typename T>
List<T>::List(const ALLOCATION_CALLBACKS& allocationCallbacks) :
    m_AllocationCallbacks(allocationCallbacks),
    m_ItemAllocator(allocationCallbacks, 128),
    m_pFront(NULL),
    m_pBack(NULL),
    m_Count(0)
{
}

template<typename T>
List<T>::~List()
{
    // Intentionally not calling Clear, because that would be unnecessary
    // computations to return all items to m_ItemAllocator as free.
}

template<typename T>
void List<T>::Clear()
{
    if(!IsEmpty())
    {
        Item* pItem = m_pBack;
        while(pItem != NULL)
        {
            Item* const pPrevItem = pItem->pPrev;
            m_ItemAllocator.Free(pItem);
            pItem = pPrevItem;
        }
        m_pFront = NULL;
        m_pBack = NULL;
        m_Count = 0;
    }
}

template<typename T>
typename List<T>::Item* List<T>::PushBack()
{
    Item* const pNewItem = m_ItemAllocator.Alloc();
    pNewItem->pNext = NULL;
    if(IsEmpty())
    {
        pNewItem->pPrev = NULL;
        m_pFront = pNewItem;
        m_pBack = pNewItem;
        m_Count = 1;
    }
    else
    {
        pNewItem->pPrev = m_pBack;
        m_pBack->pNext = pNewItem;
        m_pBack = pNewItem;
        ++m_Count;
    }
    return pNewItem;
}

template<typename T>
typename List<T>::Item* List<T>::PushFront()
{
    Item* const pNewItem = m_ItemAllocator.Alloc();
    pNewItem->pPrev = NULL;
    if(IsEmpty())
    {
        pNewItem->pNext = NULL;
        m_pFront = pNewItem;
        m_pBack = pNewItem;
        m_Count = 1;
    }
    else
    {
        pNewItem->pNext = m_pFront;
        m_pFront->pPrev = pNewItem;
        m_pFront = pNewItem;
        ++m_Count;
    }
    return pNewItem;
}

template<typename T>
typename List<T>::Item* List<T>::PushBack(const T& value)
{
    Item* const pNewItem = PushBack();
    pNewItem->Value = value;
    return pNewItem;
}

template<typename T>
typename List<T>::Item* List<T>::PushFront(const T& value)
{
    Item* const pNewItem = PushFront();
    pNewItem->Value = value;
    return pNewItem;
}

template<typename T>
void List<T>::PopBack()
{
    D3D12MA_HEAVY_ASSERT(m_Count > 0);
    Item* const pBackItem = m_pBack;
    Item* const pPrevItem = pBackItem->pPrev;
    if(pPrevItem != NULL)
    {
        pPrevItem->pNext = NULL;
    }
    m_pBack = pPrevItem;
    m_ItemAllocator.Free(pBackItem);
    --m_Count;
}

template<typename T>
void List<T>::PopFront()
{
    D3D12MA_HEAVY_ASSERT(m_Count > 0);
    Item* const pFrontItem = m_pFront;
    Item* const pNextItem = pFrontItem->pNext;
    if(pNextItem != NULL)
    {
        pNextItem->pPrev = NULL;
    }
    m_pFront = pNextItem;
    m_ItemAllocator.Free(pFrontItem);
    --m_Count;
}

template<typename T>
void List<T>::Remove(Item* pItem)
{
    D3D12MA_HEAVY_ASSERT(pItem != NULL);
    D3D12MA_HEAVY_ASSERT(m_Count > 0);

    if(pItem->pPrev != NULL)
    {
        pItem->pPrev->pNext = pItem->pNext;
    }
    else
    {
        D3D12MA_HEAVY_ASSERT(m_pFront == pItem);
        m_pFront = pItem->pNext;
    }

    if(pItem->pNext != NULL)
    {
        pItem->pNext->pPrev = pItem->pPrev;
    }
    else
    {
        D3D12MA_HEAVY_ASSERT(m_pBack == pItem);
        m_pBack = pItem->pPrev;
    }

    m_ItemAllocator.Free(pItem);
    --m_Count;
}

template<typename T>
typename List<T>::Item* List<T>::InsertBefore(Item* pItem)
{
    if(pItem != NULL)
    {
        Item* const prevItem = pItem->pPrev;
        Item* const newItem = m_ItemAllocator.Alloc();
        newItem->pPrev = prevItem;
        newItem->pNext = pItem;
        pItem->pPrev = newItem;
        if(prevItem != NULL)
        {
            prevItem->pNext = newItem;
        }
        else
        {
            D3D12MA_HEAVY_ASSERT(m_pFront == pItem);
            m_pFront = newItem;
        }
        ++m_Count;
        return newItem;
    }
    else
    {
        return PushBack();
    }
}

template<typename T>
typename List<T>::Item* List<T>::InsertAfter(Item* pItem)
{
    if(pItem != NULL)
    {
        Item* const nextItem = pItem->pNext;
        Item* const newItem = m_ItemAllocator.Alloc();
        newItem->pNext = nextItem;
        newItem->pPrev = pItem;
        pItem->pNext = newItem;
        if(nextItem != NULL)
        {
            nextItem->pPrev = newItem;
        }
        else
        {
            D3D12MA_HEAVY_ASSERT(m_pBack == pItem);
            m_pBack = newItem;
        }
        ++m_Count;
        return newItem;
    }
    else
        return PushFront();
}

template<typename T>
typename List<T>::Item* List<T>::InsertBefore(Item* pItem, const T& value)
{
    Item* const newItem = InsertBefore(pItem);
    newItem->Value = value;
    return newItem;
}

template<typename T>
typename List<T>::Item* List<T>::InsertAfter(Item* pItem, const T& value)
{
    Item* const newItem = InsertAfter(pItem);
    newItem->Value = value;
    return newItem;
}

////////////////////////////////////////////////////////////////////////////////
// Private class IntrusiveLinkedList

/*
Expected interface of ItemTypeTraits:
struct MyItemTypeTraits
{
    typedef MyItem ItemType;
    static ItemType* GetPrev(const ItemType* item) { return item->myPrevPtr; }
    static ItemType* GetNext(const ItemType* item) { return item->myNextPtr; }
    static ItemType*& AccessPrev(ItemType* item) { return item->myPrevPtr; }
    static ItemType*& AccessNext(ItemType* item) { return item->myNextPtr; }
};
*/
template<typename ItemTypeTraits>
class IntrusiveLinkedList
{
public:
    typedef typename ItemTypeTraits::ItemType ItemType;
    static ItemType* GetPrev(const ItemType* item) { return ItemTypeTraits::GetPrev(item); }
    static ItemType* GetNext(const ItemType* item) { return ItemTypeTraits::GetNext(item); }
    // Movable, not copyable.
    IntrusiveLinkedList() { }
    IntrusiveLinkedList(const IntrusiveLinkedList<ItemTypeTraits>& src) = delete;
    IntrusiveLinkedList(IntrusiveLinkedList<ItemTypeTraits>&& src) :
        m_Front(src.m_Front), m_Back(src.m_Back), m_Count(src.m_Count)
    {
        src.m_Front = src.m_Back = NULL;
        src.m_Count = 0;
    }
    ~IntrusiveLinkedList()
    {
        D3D12MA_HEAVY_ASSERT(IsEmpty());
    }
    IntrusiveLinkedList<ItemTypeTraits>& operator=(const IntrusiveLinkedList<ItemTypeTraits>& src) = delete;
    IntrusiveLinkedList<ItemTypeTraits>& operator=(IntrusiveLinkedList<ItemTypeTraits>&& src)
    {
        if(&src != this)
        {
            D3D12MA_HEAVY_ASSERT(IsEmpty());
            m_Front = src.m_Front;
            m_Back = src.m_Back;
            m_Count = src.m_Count;
            src.m_Front = src.m_Back = NULL;
            src.m_Count = 0;
        }
        return *this;
    }
    void RemoveAll()
    {
        if(!IsEmpty())
        {
            ItemType* item = m_Back;
            while(item != NULL)
            {
                ItemType* const prevItem = ItemTypeTraits::AccessPrev(item);
                ItemTypeTraits::AccessPrev(item) = NULL;
                ItemTypeTraits::AccessNext(item) = NULL;
                item = prevItem;
            }
            m_Front = NULL;
            m_Back = NULL;
            m_Count = 0;
        }
    }
    size_t GetCount() const { return m_Count; }
    bool IsEmpty() const { return m_Count == 0; }
    ItemType* Front() { return m_Front; }
    const ItemType* Front() const { return m_Front; }
    ItemType* Back() { return m_Back; }
    const ItemType* Back() const { return m_Back; }
    void PushBack(ItemType* item)
    {
        D3D12MA_HEAVY_ASSERT(ItemTypeTraits::GetPrev(item) == NULL && ItemTypeTraits::GetNext(item) == NULL);
        if(IsEmpty())
        {
            m_Front = item;
            m_Back = item;
            m_Count = 1;
        }
        else
        {
            ItemTypeTraits::AccessPrev(item) = m_Back;
            ItemTypeTraits::AccessNext(m_Back) = item;
            m_Back = item;
            ++m_Count;
        }
    }
    void PushFront(ItemType* item)
    {
        D3D12MA_HEAVY_ASSERT(ItemTypeTraits::GetPrev(item) == NULL && ItemTypeTraits::GetNext(item) == NULL);
        if(IsEmpty())
        {
            m_Front = item;
            m_Back = item;
            m_Count = 1;
        }
        else
        {
            ItemTypeTraits::AccessNext(item) = m_Front;
            ItemTypeTraits::AccessPrev(m_Front) = item;
            m_Front = item;
            ++m_Count;
        }
    }
    ItemType* PopBack()
    {
        D3D12MA_HEAVY_ASSERT(m_Count > 0);
        ItemType* const backItem = m_Back;
        ItemType* const prevItem = ItemTypeTraits::GetPrev(backItem);
        if(prevItem != NULL)
        {
            ItemTypeTraits::AccessNext(prevItem) = NULL;
        }
        m_Back = prevItem;
        --m_Count;
        ItemTypeTraits::AccessPrev(backItem) = NULL;
        ItemTypeTraits::AccessNext(backItem) = NULL;
        return backItem;
    }
    ItemType* PopFront()
    {
        D3D12MA_HEAVY_ASSERT(m_Count > 0);
        ItemType* const frontItem = m_Front;
        ItemType* const nextItem = ItemTypeTraits::GetNext(frontItem);
        if(nextItem != NULL)
        {
            ItemTypeTraits::AccessPrev(nextItem) = NULL;
        }
        m_Front = nextItem;
        --m_Count;
        ItemTypeTraits::AccessPrev(frontItem) = NULL;
        ItemTypeTraits::AccessNext(frontItem) = NULL;
        return frontItem;
    }

    // MyItem can be null - it means PushBack.
    void InsertBefore(ItemType* existingItem, ItemType* newItem)
    {
        D3D12MA_HEAVY_ASSERT(newItem != NULL && ItemTypeTraits::GetPrev(newItem) == NULL && ItemTypeTraits::GetNext(newItem) == NULL);
        if(existingItem != NULL)
        {
            ItemType* const prevItem = ItemTypeTraits::GetPrev(existingItem);
            ItemTypeTraits::AccessPrev(newItem) = prevItem;
            ItemTypeTraits::AccessNext(newItem) = existingItem;
            ItemTypeTraits::AccessPrev(existingItem) = newItem;
            if(prevItem != NULL)
            {
                ItemTypeTraits::AccessNext(prevItem) = newItem;
            }
            else
            {
                D3D12MA_HEAVY_ASSERT(m_Front == existingItem);
                m_Front = newItem;
            }
            ++m_Count;
        }
        else
            PushBack(newItem);
    }
    // MyItem can be null - it means PushFront.
    void InsertAfter(ItemType* existingItem, ItemType* newItem)
    {
        D3D12MA_HEAVY_ASSERT(newItem != NULL && ItemTypeTraits::GetPrev(newItem) == NULL && ItemTypeTraits::GetNext(newItem) == NULL);
        if(existingItem != NULL)
        {
            ItemType* const nextItem = ItemTypeTraits::GetNext(existingItem);
            ItemTypeTraits::AccessNext(newItem) = nextItem;
            ItemTypeTraits::AccessPrev(newItem) = existingItem;
            ItemTypeTraits::AccessNext(existingItem) = newItem;
            if(nextItem != NULL)
            {
                ItemTypeTraits::AccessPrev(nextItem) = newItem;
            }
            else
            {
                D3D12MA_HEAVY_ASSERT(m_Back == existingItem);
                m_Back = newItem;
            }
            ++m_Count;
        }
        else
            return PushFront(newItem);
    }
    void Remove(ItemType* item)
    {
        D3D12MA_HEAVY_ASSERT(item != NULL && m_Count > 0);
        if(ItemTypeTraits::GetPrev(item) != NULL)
        {
            ItemTypeTraits::AccessNext(ItemTypeTraits::AccessPrev(item)) = ItemTypeTraits::GetNext(item);
        }
        else
        {
            D3D12MA_HEAVY_ASSERT(m_Front == item);
            m_Front = ItemTypeTraits::GetNext(item);
        }

        if(ItemTypeTraits::GetNext(item) != NULL)
        {
            ItemTypeTraits::AccessPrev(ItemTypeTraits::AccessNext(item)) = ItemTypeTraits::GetPrev(item);
        }
        else
        {
            D3D12MA_HEAVY_ASSERT(m_Back == item);
            m_Back = ItemTypeTraits::GetPrev(item);
        }
        ItemTypeTraits::AccessPrev(item) = NULL;
        ItemTypeTraits::AccessNext(item) = NULL;
        --m_Count;
    }
private:
    ItemType* m_Front = NULL;
    ItemType* m_Back = NULL;
    size_t m_Count = 0;
};

////////////////////////////////////////////////////////////////////////////////
// Private class AllocationObjectAllocator definition

/*
Thread-safe wrapper over PoolAllocator free list, for allocation of Allocation objects.
*/
class AllocationObjectAllocator
{
    D3D12MA_CLASS_NO_COPY(AllocationObjectAllocator);
public:
    AllocationObjectAllocator(const ALLOCATION_CALLBACKS& allocationCallbacks);

    template<typename... Types> Allocation* Allocate(Types... args);
    void Free(Allocation* alloc);

private:
    D3D12MA_MUTEX m_Mutex;
    PoolAllocator<Allocation> m_Allocator;
};

////////////////////////////////////////////////////////////////////////////////
// Private class BlockMetadata and derived classes - declarations

enum SuballocationType
{
    SUBALLOCATION_TYPE_FREE = 0,
    SUBALLOCATION_TYPE_ALLOCATION = 1,
};

/*
Represents a region of NormalBlock that is either assigned and returned as
allocated memory block or free.
*/
struct Suballocation
{
    UINT64 offset;
    UINT64 size;
    void* userData;
    SuballocationType type;
};

// Comparator for offsets.
struct SuballocationOffsetLess
{
    bool operator()(const Suballocation& lhs, const Suballocation& rhs) const
    {
        return lhs.offset < rhs.offset;
    }
};
struct SuballocationOffsetGreater
{
    bool operator()(const Suballocation& lhs, const Suballocation& rhs) const
    {
        return lhs.offset > rhs.offset;
    }
};

typedef List<Suballocation> SuballocationList;

struct SuballocationItemSizeLess
{
    bool operator()(const SuballocationList::iterator lhs, const SuballocationList::iterator rhs) const
    {
        return lhs->size < rhs->size;
    }
    bool operator()(const SuballocationList::iterator lhs, UINT64 rhsSize) const
    {
        return lhs->size < rhsSize;
    }
};

/*
Parameters of planned allocation inside a NormalBlock.
*/
struct AllocationRequest
{
    UINT64 offset;
    UINT64 sumFreeSize; // Sum size of free items that overlap with proposed allocation.
    UINT64 sumItemSize; // Sum size of items to make lost that overlap with proposed allocation.
    SuballocationList::iterator item;
    BOOL zeroInitialized;
};

/*
Keeps track of the range of bytes that are surely initialized with zeros.
Everything outside of it is considered uninitialized memory that may contain
garbage data.

The range is left-inclusive.
*/
class ZeroInitializedRange
{
public:
    void Reset(UINT64 size)
    {
        D3D12MA_ASSERT(size > 0);
        m_ZeroBeg = 0;
        m_ZeroEnd = size;
    }

    BOOL IsRangeZeroInitialized(UINT64 beg, UINT64 end) const
    {
        D3D12MA_ASSERT(beg < end);
        return m_ZeroBeg <= beg && end <= m_ZeroEnd;
    }

    void MarkRangeAsUsed(UINT64 usedBeg, UINT64 usedEnd)
    {
        D3D12MA_ASSERT(usedBeg < usedEnd);
        // No new bytes marked.
        if(usedEnd <= m_ZeroBeg || m_ZeroEnd <= usedBeg)
        {
            return;
        }
        // All bytes marked.
        if(usedBeg <= m_ZeroBeg && m_ZeroEnd <= usedEnd)
        {
            m_ZeroBeg = m_ZeroEnd = 0;
        }
        // Some bytes marked.
        else
        {
            const UINT64 remainingZeroBefore = usedBeg > m_ZeroBeg ? usedBeg - m_ZeroBeg : 0;
            const UINT64 remainingZeroAfter  = usedEnd < m_ZeroEnd ? m_ZeroEnd - usedEnd : 0;
            D3D12MA_ASSERT(remainingZeroBefore > 0 || remainingZeroAfter > 0);
            if(remainingZeroBefore > remainingZeroAfter)
            {
                m_ZeroEnd = usedBeg;
            }
            else
            {
                m_ZeroBeg = usedEnd;
            }
        }
    }

private:
    UINT64 m_ZeroBeg = 0, m_ZeroEnd = 0;
};

/*
Data structure used for bookkeeping of allocations and unused ranges of memory
in a single ID3D12Heap memory block.
*/
class BlockMetadata
{
public:
    BlockMetadata(const ALLOCATION_CALLBACKS* allocationCallbacks, bool isVirtual);
    virtual ~BlockMetadata() { }
    virtual void Init(UINT64 size) { m_Size = size; }

    // Validates all data structures inside this object. If not valid, returns false.
    virtual bool Validate() const = 0;
    UINT64 GetSize() const { return m_Size; }
    bool IsVirtual() const { return m_IsVirtual; }
    virtual size_t GetAllocationCount() const = 0;
    virtual UINT64 GetSumFreeSize() const = 0;
    virtual UINT64 GetUnusedRangeSizeMax() const = 0;
    // Returns true if this block is empty - contains only single free suballocation.
    virtual bool IsEmpty() const = 0;

    virtual void GetAllocationInfo(UINT64 offset, VIRTUAL_ALLOCATION_INFO& outInfo) const = 0;

    // Tries to find a place for suballocation with given parameters inside this block.
    // If succeeded, fills pAllocationRequest and returns true.
    // If failed, returns false.
    virtual bool CreateAllocationRequest(
        UINT64 allocSize,
        UINT64 allocAlignment,
        AllocationRequest* pAllocationRequest) = 0;

    // Makes actual allocation based on request. Request must already be checked and valid.
    virtual void Alloc(
        const AllocationRequest& request,
        UINT64 allocSize,
        void* userData) = 0;

    virtual void FreeAtOffset(UINT64 offset) = 0;
    // Frees all allocations.
    // Careful! Don't call it if there are Allocation objects owned by pUserData of of cleared allocations!
    virtual void Clear() = 0;

    virtual void SetAllocationUserData(UINT64 offset, void* userData) = 0;

    virtual void CalcAllocationStatInfo(StatInfo& outInfo) const = 0;
    virtual void WriteAllocationInfoToJson(JsonWriter& json) const = 0;

protected:
    const ALLOCATION_CALLBACKS* GetAllocs() const { return m_pAllocationCallbacks; }

private:
    UINT64 m_Size;
    bool m_IsVirtual;
    const ALLOCATION_CALLBACKS* m_pAllocationCallbacks;

    D3D12MA_CLASS_NO_COPY(BlockMetadata);
};

class BlockMetadata_Generic : public BlockMetadata
{
public:
    BlockMetadata_Generic(const ALLOCATION_CALLBACKS* allocationCallbacks, bool isVirtual);
    virtual ~BlockMetadata_Generic();
    virtual void Init(UINT64 size);

    virtual bool Validate() const;
    virtual size_t GetAllocationCount() const { return m_Suballocations.size() - m_FreeCount; }
    virtual UINT64 GetSumFreeSize() const { return m_SumFreeSize; }
    virtual UINT64 GetUnusedRangeSizeMax() const;
    virtual bool IsEmpty() const;

    virtual void GetAllocationInfo(UINT64 offset, VIRTUAL_ALLOCATION_INFO& outInfo) const;

    virtual bool CreateAllocationRequest(
        UINT64 allocSize,
        UINT64 allocAlignment,
        AllocationRequest* pAllocationRequest);

    virtual void Alloc(
        const AllocationRequest& request,
        UINT64 allocSize,
        void* userData);

    virtual void FreeAtOffset(UINT64 offset);
    virtual void Clear();

    virtual void SetAllocationUserData(UINT64 offset, void* userData);

    virtual void CalcAllocationStatInfo(StatInfo& outInfo) const;
    virtual void WriteAllocationInfoToJson(JsonWriter& json) const;

private:
    UINT m_FreeCount;
    UINT64 m_SumFreeSize;
    SuballocationList m_Suballocations;
    // Suballocations that are free and have size greater than certain threshold.
    // Sorted by size, ascending.
    Vector<SuballocationList::iterator> m_FreeSuballocationsBySize;
    ZeroInitializedRange m_ZeroInitializedRange;

    bool ValidateFreeSuballocationList() const;

    // Checks if requested suballocation with given parameters can be placed in given pFreeSuballocItem.
    // If yes, fills pOffset and returns true. If no, returns false.
    bool CheckAllocation(
        UINT64 allocSize,
        UINT64 allocAlignment,
        SuballocationList::const_iterator suballocItem,
        UINT64* pOffset,
        UINT64* pSumFreeSize,
        UINT64* pSumItemSize,
        BOOL *pZeroInitialized) const;
    // Given free suballocation, it merges it with following one, which must also be free.
    void MergeFreeWithNext(SuballocationList::iterator item);
    // Releases given suballocation, making it free.
    // Merges it with adjacent free suballocations if applicable.
    // Returns iterator to new free suballocation at this place.
    SuballocationList::iterator FreeSuballocation(SuballocationList::iterator suballocItem);
    // Given free suballocation, it inserts it into sorted list of
    // m_FreeSuballocationsBySize if it's suitable.
    void RegisterFreeSuballocation(SuballocationList::iterator item);
    // Given free suballocation, it removes it from sorted list of
    // m_FreeSuballocationsBySize if it's suitable.
    void UnregisterFreeSuballocation(SuballocationList::iterator item);

    D3D12MA_CLASS_NO_COPY(BlockMetadata_Generic)
};

////////////////////////////////////////////////////////////////////////////////
// Private class MemoryBlock definition

/*
Represents a single block of device memory (heap).
Base class for inheritance.
Thread-safety: This class must be externally synchronized.
*/
class MemoryBlock
{
public:
    MemoryBlock(
        AllocatorPimpl* allocator,
        D3D12_HEAP_TYPE heapType,
        D3D12_HEAP_FLAGS heapFlags,
        UINT64 size,
        UINT id);
    virtual ~MemoryBlock();
    // Creates the ID3D12Heap.

    D3D12_HEAP_TYPE GetHeapType() const { return m_HeapType; }
    D3D12_HEAP_FLAGS GetHeapFlags() const { return m_HeapFlags; }
    UINT64 GetSize() const { return m_Size; }
    UINT GetId() const { return m_Id; }
    ID3D12Heap* GetHeap() const { return m_Heap; }

protected:
    AllocatorPimpl* const m_Allocator;
    const D3D12_HEAP_TYPE m_HeapType;
    const D3D12_HEAP_FLAGS m_HeapFlags;
    const UINT64 m_Size;
    const UINT m_Id;

    HRESULT Init();

private:
    ID3D12Heap* m_Heap = NULL;

    D3D12MA_CLASS_NO_COPY(MemoryBlock)
};

////////////////////////////////////////////////////////////////////////////////
// Private class NormalBlock definition

/*
Represents a single block of device memory (heap) with all the data about its
regions (aka suballocations, Allocation), assigned and free.
Thread-safety: This class must be externally synchronized.
*/
class NormalBlock : public MemoryBlock
{
public:
    BlockMetadata* m_pMetadata;

    NormalBlock(
        AllocatorPimpl* allocator,
        BlockVector* blockVector,
        D3D12_HEAP_TYPE heapType,
        D3D12_HEAP_FLAGS heapFlags,
        UINT64 size,
        UINT id);
    virtual ~NormalBlock();
    HRESULT Init();

    BlockVector* GetBlockVector() const { return m_BlockVector; }

    // Validates all data structures inside this object. If not valid, returns false.
    bool Validate() const;

private:
    BlockVector* m_BlockVector;

    D3D12MA_CLASS_NO_COPY(NormalBlock)
};

////////////////////////////////////////////////////////////////////////////////
// Private class BlockVector definition

/*
Sequence of NormalBlock. Represents memory blocks allocated for a specific
heap type and possibly resource type (if only Tier 1 is supported).

Synchronized internally with a mutex.
*/
class BlockVector
{
    D3D12MA_CLASS_NO_COPY(BlockVector)
public:
    BlockVector(
        AllocatorPimpl* hAllocator,
        D3D12_HEAP_TYPE heapType,
        D3D12_HEAP_FLAGS heapFlags,
        UINT64 preferredBlockSize,
        size_t minBlockCount,
        size_t maxBlockCount,
        bool explicitBlockSize);
    ~BlockVector();

    HRESULT CreateMinBlocks();

    UINT GetHeapType() const { return m_HeapType; }
    UINT64 GetPreferredBlockSize() const { return m_PreferredBlockSize; }

    bool IsEmpty();

    HRESULT Allocate(
        UINT64 size,
        UINT64 alignment,
        const ALLOCATION_DESC& allocDesc,
        size_t allocationCount,
        Allocation** pAllocations);

    void Free(
        Allocation* hAllocation);

    HRESULT CreateResource(
        UINT64 size,
        UINT64 alignment,
        const ALLOCATION_DESC& allocDesc,
        const D3D12_RESOURCE_DESC& resourceDesc,
        D3D12_RESOURCE_STATES InitialResourceState,
        const D3D12_CLEAR_VALUE *pOptimizedClearValue,
        Allocation** ppAllocation,
        REFIID riidResource,
        void** ppvResource);

#ifdef __ID3D12Device8_INTERFACE_DEFINED__
    HRESULT CreateResource2(
        UINT64 size,
        UINT64 alignment,
        const ALLOCATION_DESC& allocDesc,
        const D3D12_RESOURCE_DESC1& resourceDesc,
        D3D12_RESOURCE_STATES InitialResourceState,
        const D3D12_CLEAR_VALUE *pOptimizedClearValue,
        ID3D12ProtectedResourceSession *pProtectedSession,
        Allocation** ppAllocation,
        REFIID riidResource,
        void** ppvResource);
#endif // #ifdef __ID3D12Device8_INTERFACE_DEFINED__

    HRESULT SetMinBytes(UINT64 minBytes);

    void AddStats(StatInfo& outStats);
    void AddStats(Stats& outStats);

    void WriteBlockInfoToJson(JsonWriter& json);

private:
    AllocatorPimpl* const m_hAllocator;
    const D3D12_HEAP_TYPE m_HeapType;
    const D3D12_HEAP_FLAGS m_HeapFlags;
    const UINT64 m_PreferredBlockSize;
    const size_t m_MinBlockCount;
    const size_t m_MaxBlockCount;
    const bool m_ExplicitBlockSize;
    UINT64 m_MinBytes;
    /* There can be at most one allocation that is completely empty - a
    hysteresis to avoid pessimistic case of alternating creation and destruction
    of a VkDeviceMemory. */
    bool m_HasEmptyBlock;
    D3D12MA_RW_MUTEX m_Mutex;
    // Incrementally sorted by sumFreeSize, ascending.
    Vector<NormalBlock*> m_Blocks;
    UINT m_NextBlockId;

    UINT64 CalcSumBlockSize() const;
    UINT64 CalcMaxBlockSize() const;

    // Finds and removes given block from vector.
    void Remove(NormalBlock* pBlock);

    // Performs single step in sorting m_Blocks. They may not be fully sorted
    // after this call.
    void IncrementallySortBlocks();

    HRESULT AllocatePage(
        UINT64 size,
        UINT64 alignment,
        const ALLOCATION_DESC& allocDesc,
        Allocation** pAllocation);

    HRESULT AllocateFromBlock(
        NormalBlock* pBlock,
        UINT64 size,
        UINT64 alignment,
        ALLOCATION_FLAGS allocFlags,
        Allocation** pAllocation);

    HRESULT CreateBlock(UINT64 blockSize, size_t* pNewBlockIndex);
};

////////////////////////////////////////////////////////////////////////////////
// Private class AllocatorPimpl definition

static const UINT DEFAULT_POOL_MAX_COUNT = 9;

struct CurrentBudgetData
{
    D3D12MA_ATOMIC_UINT64 m_BlockBytes[HEAP_TYPE_COUNT];
    D3D12MA_ATOMIC_UINT64 m_AllocationBytes[HEAP_TYPE_COUNT];

    D3D12MA_ATOMIC_UINT32 m_OperationsSinceBudgetFetch;
    D3D12MA_RW_MUTEX m_BudgetMutex;
    UINT64 m_D3D12UsageLocal, m_D3D12UsageNonLocal;
    UINT64 m_D3D12BudgetLocal, m_D3D12BudgetNonLocal;
    UINT64 m_BlockBytesAtBudgetFetch[HEAP_TYPE_COUNT];

    CurrentBudgetData()
    {
        for(UINT i = 0; i < HEAP_TYPE_COUNT; ++i)
        {
            m_BlockBytes[i] = 0;
            m_AllocationBytes[i] = 0;
            m_BlockBytesAtBudgetFetch[i] = 0;
        }

        m_D3D12UsageLocal = 0;
        m_D3D12UsageNonLocal = 0;
        m_D3D12BudgetLocal = 0;
        m_D3D12BudgetNonLocal = 0;
        m_OperationsSinceBudgetFetch = 0;
    }

    void AddAllocation(UINT heapTypeIndex, UINT64 allocationSize)
    {
        m_AllocationBytes[heapTypeIndex] += allocationSize;
        ++m_OperationsSinceBudgetFetch;
    }

    void RemoveAllocation(UINT heapTypeIndex, UINT64 allocationSize)
    {
        m_AllocationBytes[heapTypeIndex] -= allocationSize;
        ++m_OperationsSinceBudgetFetch;
    }
};

struct CommittedAllocationListItemTraits
{
    typedef Allocation ItemType;
    static ItemType* GetPrev(const ItemType* item)
    {
        D3D12MA_ASSERT(item->m_PackedData.GetType() == Allocation::TYPE_COMMITTED || item->m_PackedData.GetType() == Allocation::TYPE_HEAP);
        return item->m_Committed.prev;
    }
    static ItemType* GetNext(const ItemType* item)
    {
        D3D12MA_ASSERT(item->m_PackedData.GetType() == Allocation::TYPE_COMMITTED || item->m_PackedData.GetType() == Allocation::TYPE_HEAP);
        return item->m_Committed.next;
    }
    static ItemType*& AccessPrev(ItemType* item)
    {
        D3D12MA_ASSERT(item->m_PackedData.GetType() == Allocation::TYPE_COMMITTED || item->m_PackedData.GetType() == Allocation::TYPE_HEAP);
        return item->m_Committed.prev;
    }
    static ItemType*& AccessNext(ItemType* item)
    {
        D3D12MA_ASSERT(item->m_PackedData.GetType() == Allocation::TYPE_COMMITTED || item->m_PackedData.GetType() == Allocation::TYPE_HEAP);
        return item->m_Committed.next;
    }
};

class PoolPimpl
{
public:
    PoolPimpl(AllocatorPimpl* allocator, const POOL_DESC& desc);
    HRESULT Init();
    ~PoolPimpl();

    AllocatorPimpl* GetAllocator() const { return m_Allocator; }
    const POOL_DESC& GetDesc() const { return m_Desc; }
    BlockVector* GetBlockVector() { return m_BlockVector; }

    HRESULT SetMinBytes(UINT64 minBytes) { return m_BlockVector->SetMinBytes(minBytes); }

    void CalculateStats(StatInfo& outStats);

    void SetName(LPCWSTR Name);
    LPCWSTR GetName() const { return m_Name; }

private:
    friend class Allocator;
    friend struct PoolListItemTraits;

    AllocatorPimpl* m_Allocator; // Externally owned object.
    POOL_DESC m_Desc;
    BlockVector* m_BlockVector; // Owned object.
    wchar_t* m_Name;
    PoolPimpl* m_PrevPool = NULL;
    PoolPimpl* m_NextPool = NULL;

    void FreeName();
};

struct PoolListItemTraits
{
    typedef PoolPimpl ItemType;
    static ItemType* GetPrev(const ItemType* item) { return item->m_PrevPool; }
    static ItemType* GetNext(const ItemType* item) { return item->m_NextPool; }
    static ItemType*& AccessPrev(ItemType* item) { return item->m_PrevPool; }
    static ItemType*& AccessNext(ItemType* item) { return item->m_NextPool; }
};

class AllocatorPimpl
{
public:
    CurrentBudgetData m_Budget;

    AllocatorPimpl(const ALLOCATION_CALLBACKS& allocationCallbacks, const ALLOCATOR_DESC& desc);
    HRESULT Init(const ALLOCATOR_DESC& desc);
    ~AllocatorPimpl();

    ID3D12Device* GetDevice() const { return m_Device; }
#ifdef __ID3D12Device4_INTERFACE_DEFINED__
    ID3D12Device4* GetDevice4() const { return m_Device4; }
#endif
#ifdef __ID3D12Device8_INTERFACE_DEFINED__
    ID3D12Device8* GetDevice8() const { return m_Device8; }
#endif
    // Shortcut for "Allocation Callbacks", because this function is called so often.
    const ALLOCATION_CALLBACKS& GetAllocs() const { return m_AllocationCallbacks; }
    const D3D12_FEATURE_DATA_D3D12_OPTIONS& GetD3D12Options() const { return m_D3D12Options; }
    bool SupportsResourceHeapTier2() const { return m_D3D12Options.ResourceHeapTier >= D3D12_RESOURCE_HEAP_TIER_2; }
    bool UseMutex() const { return m_UseMutex; }
    AllocationObjectAllocator& GetAllocationObjectAllocator() { return m_AllocationObjectAllocator; }
    bool HeapFlagsFulfillResourceHeapTier(D3D12_HEAP_FLAGS flags) const;

    HRESULT CreateResource(
        const ALLOCATION_DESC* pAllocDesc,
        const D3D12_RESOURCE_DESC* pResourceDesc,
        D3D12_RESOURCE_STATES InitialResourceState,
        const D3D12_CLEAR_VALUE *pOptimizedClearValue,
        Allocation** ppAllocation,
        REFIID riidResource,
        void** ppvResource);

#ifdef __ID3D12Device4_INTERFACE_DEFINED__
    HRESULT CreateResource1(
        const ALLOCATION_DESC* pAllocDesc,
        const D3D12_RESOURCE_DESC* pResourceDesc,
        D3D12_RESOURCE_STATES InitialResourceState,
        const D3D12_CLEAR_VALUE *pOptimizedClearValue,
        ID3D12ProtectedResourceSession *pProtectedSession,
        Allocation** ppAllocation,
        REFIID riidResource,
        void** ppvResource);
#endif // #ifdef __ID3D12Device4_INTERFACE_DEFINED__

#ifdef __ID3D12Device8_INTERFACE_DEFINED__
    HRESULT CreateResource2(
        const ALLOCATION_DESC* pAllocDesc,
        const D3D12_RESOURCE_DESC1* pResourceDesc,
        D3D12_RESOURCE_STATES InitialResourceState,
        const D3D12_CLEAR_VALUE *pOptimizedClearValue,
        ID3D12ProtectedResourceSession *pProtectedSession,
        Allocation** ppAllocation,
        REFIID riidResource,
        void** ppvResource);
#endif // #ifdef __ID3D12Device8_INTERFACE_DEFINED__

    HRESULT AllocateMemory(
        const ALLOCATION_DESC* pAllocDesc,
        const D3D12_RESOURCE_ALLOCATION_INFO* pAllocInfo,
        Allocation** ppAllocation);

#ifdef __ID3D12Device4_INTERFACE_DEFINED__
    HRESULT AllocateMemory1(
        const ALLOCATION_DESC* pAllocDesc,
        const D3D12_RESOURCE_ALLOCATION_INFO* pAllocInfo,
        ID3D12ProtectedResourceSession *pProtectedSession,
        Allocation** ppAllocation);
#endif // #ifdef __ID3D12Device4_INTERFACE_DEFINED__

    HRESULT CreateAliasingResource(
        Allocation* pAllocation,
        UINT64 AllocationLocalOffset,
        const D3D12_RESOURCE_DESC* pResourceDesc,
        D3D12_RESOURCE_STATES InitialResourceState,
        const D3D12_CLEAR_VALUE *pOptimizedClearValue,
        REFIID riidResource,
        void** ppvResource);

    HRESULT SetDefaultHeapMinBytes(
        D3D12_HEAP_TYPE heapType,
        D3D12_HEAP_FLAGS heapFlags,
        UINT64 minBytes);

    // Unregisters allocation from the collection of dedicated allocations.
    // Allocation object must be deleted externally afterwards.
    void FreeCommittedMemory(Allocation* allocation);
    // Unregisters allocation from the collection of placed allocations.
    // Allocation object must be deleted externally afterwards.
    void FreePlacedMemory(Allocation* allocation);
    // Unregisters allocation from the collection of dedicated allocations and destroys associated heap.
    // Allocation object must be deleted externally afterwards.
    void FreeHeapMemory(Allocation* allocation);

    void SetCurrentFrameIndex(UINT frameIndex);

    UINT GetCurrentFrameIndex() const { return m_CurrentFrameIndex.load(); }

    void CalculateStats(Stats& outStats);

    void GetBudget(Budget* outGpuBudget, Budget* outCpuBudget);
    void GetBudgetForHeapType(Budget& outBudget, D3D12_HEAP_TYPE heapType);

    void BuildStatsString(WCHAR** ppStatsString, BOOL DetailedMap);

    void FreeStatsString(WCHAR* pStatsString);

private:
    friend class Allocator;
    friend class Pool;

    /*
    Heuristics that decides whether a resource should better be placed in its own,
    dedicated allocation (committed resource rather than placed resource).
    */
    template<typename D3D12_RESOURCE_DESC_T>
    static bool PrefersCommittedAllocation(const D3D12_RESOURCE_DESC_T& resourceDesc);

    const bool m_UseMutex;
    const bool m_AlwaysCommitted;
    ID3D12Device* m_Device; // AddRef
#ifdef __ID3D12Device4_INTERFACE_DEFINED__
    ID3D12Device4* m_Device4 = NULL; // AddRef, optional
#endif
#ifdef __ID3D12Device8_INTERFACE_DEFINED__
    ID3D12Device8* m_Device8 = NULL; // AddRef, optional
#endif
    IDXGIAdapter* m_Adapter; // AddRef
#if D3D12MA_DXGI_1_4
    IDXGIAdapter3* m_Adapter3 = NULL; // AddRef, optional
#endif
    UINT64 m_PreferredBlockSize;
    ALLOCATION_CALLBACKS m_AllocationCallbacks;
    D3D12MA_ATOMIC_UINT32 m_CurrentFrameIndex;
    DXGI_ADAPTER_DESC m_AdapterDesc;
    D3D12_FEATURE_DATA_D3D12_OPTIONS m_D3D12Options;
    AllocationObjectAllocator m_AllocationObjectAllocator;

    typedef IntrusiveLinkedList<CommittedAllocationListItemTraits> CommittedAllocationList;
    CommittedAllocationList m_CommittedAllocations[HEAP_TYPE_COUNT];
    D3D12MA_RW_MUTEX m_CommittedAllocationsMutex[HEAP_TYPE_COUNT];

    typedef IntrusiveLinkedList<PoolListItemTraits> PoolList;
    PoolList m_Pools[HEAP_TYPE_COUNT];
    D3D12MA_RW_MUTEX m_PoolsMutex[HEAP_TYPE_COUNT];

    // Default pools.
    BlockVector* m_BlockVectors[DEFAULT_POOL_MAX_COUNT];

    // # Used only when ResourceHeapTier = 1
    UINT64 m_DefaultPoolTier1MinBytes[DEFAULT_POOL_MAX_COUNT]; // Default 0
    UINT64 m_DefaultPoolHeapTypeMinBytes[HEAP_TYPE_COUNT]; // Default UINT64_MAX, meaning not set
    D3D12MA_RW_MUTEX m_DefaultPoolMinBytesMutex;

    // Allocates and registers new committed resource with implicit heap, as dedicated allocation.
    // Creates and returns Allocation object.
    HRESULT AllocateCommittedResource(
        const ALLOCATION_DESC* pAllocDesc,
        const D3D12_RESOURCE_DESC* pResourceDesc,
        const D3D12_RESOURCE_ALLOCATION_INFO& resAllocInfo,
        D3D12_RESOURCE_STATES InitialResourceState,
        const D3D12_CLEAR_VALUE *pOptimizedClearValue,
        Allocation** ppAllocation,
        REFIID riidResource,
        void** ppvResource);

#ifdef __ID3D12Device4_INTERFACE_DEFINED__
    HRESULT AllocateCommittedResource1(
        const ALLOCATION_DESC* pAllocDesc,
        const D3D12_RESOURCE_DESC* pResourceDesc,
        const D3D12_RESOURCE_ALLOCATION_INFO& resAllocInfo,
        D3D12_RESOURCE_STATES InitialResourceState,
        const D3D12_CLEAR_VALUE *pOptimizedClearValue,
        ID3D12ProtectedResourceSession *pProtectedSession,
        Allocation** ppAllocation,
        REFIID riidResource,
        void** ppvResource);
#endif // #ifdef __ID3D12Device4_INTERFACE_DEFINED__

#ifdef __ID3D12Device8_INTERFACE_DEFINED__
    HRESULT AllocateCommittedResource2(
        const ALLOCATION_DESC* pAllocDesc,
        const D3D12_RESOURCE_DESC1* pResourceDesc,
        const D3D12_RESOURCE_ALLOCATION_INFO& resAllocInfo,
        D3D12_RESOURCE_STATES InitialResourceState,
        const D3D12_CLEAR_VALUE *pOptimizedClearValue,
        ID3D12ProtectedResourceSession *pProtectedSession,
        Allocation** ppAllocation,
        REFIID riidResource,
        void** ppvResource);
#endif // #ifdef __ID3D12Device8_INTERFACE_DEFINED__

    // Allocates and registers new heap without any resources placed in it, as dedicated allocation.
    // Creates and returns Allocation object.
    HRESULT AllocateHeap(
        const ALLOCATION_DESC* pAllocDesc,
        const D3D12_RESOURCE_ALLOCATION_INFO& allocInfo,
        Allocation** ppAllocation);

#ifdef __ID3D12Device4_INTERFACE_DEFINED__
    HRESULT AllocateHeap1(
        const ALLOCATION_DESC* pAllocDesc,
        const D3D12_RESOURCE_ALLOCATION_INFO& allocInfo,
        ID3D12ProtectedResourceSession *pProtectedSession,
        Allocation** ppAllocation);
#endif // #ifdef __ID3D12Device4_INTERFACE_DEFINED__

    /*
    If SupportsResourceHeapTier2():
        0: D3D12_HEAP_TYPE_DEFAULT
        1: D3D12_HEAP_TYPE_UPLOAD
        2: D3D12_HEAP_TYPE_READBACK
    else:
        0: D3D12_HEAP_TYPE_DEFAULT + buffer
        1: D3D12_HEAP_TYPE_DEFAULT + texture
        2: D3D12_HEAP_TYPE_DEFAULT + texture RT or DS
        3: D3D12_HEAP_TYPE_UPLOAD + buffer
        4: D3D12_HEAP_TYPE_UPLOAD + texture
        5: D3D12_HEAP_TYPE_UPLOAD + texture RT or DS
        6: D3D12_HEAP_TYPE_READBACK + buffer
        7: D3D12_HEAP_TYPE_READBACK + texture
        8: D3D12_HEAP_TYPE_READBACK + texture RT or DS
    */
    UINT CalcDefaultPoolCount() const;
    template<typename D3D12_RESOURCE_DESC_T>
    UINT CalcDefaultPoolIndex(const ALLOCATION_DESC& allocDesc, const D3D12_RESOURCE_DESC_T& resourceDesc) const;
    // This one returns UINT32_MAX if nonstandard heap flags are used and index cannot be calculcated.
    static UINT CalcDefaultPoolIndex(D3D12_HEAP_TYPE heapType, D3D12_HEAP_FLAGS heapFlags, bool supportsResourceHeapTier2);
    UINT CalcDefaultPoolIndex(D3D12_HEAP_TYPE heapType, D3D12_HEAP_FLAGS heapFlags) const
    {
        return CalcDefaultPoolIndex(heapType, heapFlags, SupportsResourceHeapTier2());
    }
    UINT CalcDefaultPoolIndex(const ALLOCATION_DESC& allocDesc) const
    {
        return CalcDefaultPoolIndex(allocDesc.HeapType, allocDesc.ExtraHeapFlags);
    }
    void CalcDefaultPoolParams(D3D12_HEAP_TYPE& outHeapType, D3D12_HEAP_FLAGS& outHeapFlags, UINT index) const;

    // Registers Allocation object in m_CommittedAllocations.
    void RegisterCommittedAllocation(Allocation* alloc, D3D12_HEAP_TYPE heapType);
    // Unregisters Allocation object from m_CommittedAllocations.
    void UnregisterCommittedAllocation(Allocation* alloc, D3D12_HEAP_TYPE heapType);

    // Registers Pool object in m_Pools.
    void RegisterPool(Pool* pool, D3D12_HEAP_TYPE heapType);
    // Unregisters Pool object from m_Pools.
    void UnregisterPool(Pool* pool, D3D12_HEAP_TYPE heapType);

    HRESULT UpdateD3D12Budget();
    
    D3D12_RESOURCE_ALLOCATION_INFO GetResourceAllocationInfoNative(const D3D12_RESOURCE_DESC& resourceDesc) const;
#ifdef __ID3D12Device8_INTERFACE_DEFINED__
    D3D12_RESOURCE_ALLOCATION_INFO GetResourceAllocationInfoNative(const D3D12_RESOURCE_DESC1& resourceDesc) const;
#endif // #ifdef __ID3D12Device8_INTERFACE_DEFINED__

    template<typename D3D12_RESOURCE_DESC_T>
    D3D12_RESOURCE_ALLOCATION_INFO GetResourceAllocationInfo(D3D12_RESOURCE_DESC_T& inOutResourceDesc) const;

    bool NewAllocationWithinBudget(D3D12_HEAP_TYPE heapType, UINT64 size);

    // Writes object { } with data of given budget.
    static void WriteBudgetToJson(JsonWriter& json, const Budget& budget);
};

////////////////////////////////////////////////////////////////////////////////
// Private class BlockMetadata implementation

BlockMetadata::BlockMetadata(const ALLOCATION_CALLBACKS* allocationCallbacks, bool isVirtual) :
    m_Size(0),
    m_IsVirtual(isVirtual),
    m_pAllocationCallbacks(allocationCallbacks)
{
    D3D12MA_ASSERT(allocationCallbacks);
}

////////////////////////////////////////////////////////////////////////////////
// Private class BlockMetadata_Generic implementation

BlockMetadata_Generic::BlockMetadata_Generic(const ALLOCATION_CALLBACKS* allocationCallbacks, bool isVirtual) :
    BlockMetadata(allocationCallbacks, isVirtual),
    m_FreeCount(0),
    m_SumFreeSize(0),
    m_Suballocations(*allocationCallbacks),
    m_FreeSuballocationsBySize(*allocationCallbacks)
{
    D3D12MA_ASSERT(allocationCallbacks);
}

BlockMetadata_Generic::~BlockMetadata_Generic()
{
}

void BlockMetadata_Generic::Init(UINT64 size)
{
    BlockMetadata::Init(size);
    m_ZeroInitializedRange.Reset(size);

    m_FreeCount = 1;
    m_SumFreeSize = size;

    Suballocation suballoc = {};
    suballoc.offset = 0;
    suballoc.size = size;
    suballoc.type = SUBALLOCATION_TYPE_FREE;
    suballoc.userData = NULL;

    D3D12MA_ASSERT(size > MIN_FREE_SUBALLOCATION_SIZE_TO_REGISTER);
    m_Suballocations.push_back(suballoc);
    SuballocationList::iterator suballocItem = m_Suballocations.end();
    --suballocItem;
    m_FreeSuballocationsBySize.push_back(suballocItem);
}

bool BlockMetadata_Generic::Validate() const
{
    D3D12MA_VALIDATE(!m_Suballocations.empty());

    // Expected offset of new suballocation as calculated from previous ones.
    UINT64 calculatedOffset = 0;
    // Expected number of free suballocations as calculated from traversing their list.
    UINT calculatedFreeCount = 0;
    // Expected sum size of free suballocations as calculated from traversing their list.
    UINT64 calculatedSumFreeSize = 0;
    // Expected number of free suballocations that should be registered in
    // m_FreeSuballocationsBySize calculated from traversing their list.
    size_t freeSuballocationsToRegister = 0;
    // True if previous visited suballocation was free.
    bool prevFree = false;

    for(SuballocationList::const_iterator suballocItem = m_Suballocations.cbegin();
        suballocItem != m_Suballocations.cend();
        ++suballocItem)
    {
        const Suballocation& subAlloc = *suballocItem;

        // Actual offset of this suballocation doesn't match expected one.
        D3D12MA_VALIDATE(subAlloc.offset == calculatedOffset);

        const bool currFree = (subAlloc.type == SUBALLOCATION_TYPE_FREE);
        // Two adjacent free suballocations are invalid. They should be merged.
        D3D12MA_VALIDATE(!prevFree || !currFree);

        const Allocation* const alloc = (Allocation*)subAlloc.userData;
        if(!IsVirtual())
        {
            D3D12MA_VALIDATE(currFree == (alloc == NULL));
        }

        if(currFree)
        {
            calculatedSumFreeSize += subAlloc.size;
            ++calculatedFreeCount;
            if(subAlloc.size >= MIN_FREE_SUBALLOCATION_SIZE_TO_REGISTER)
            {
                ++freeSuballocationsToRegister;
            }

            // Margin required between allocations - every free space must be at least that large.
            D3D12MA_VALIDATE(subAlloc.size >= D3D12MA_DEBUG_MARGIN);
        }
        else
        {
            if(!IsVirtual())
            {
                D3D12MA_VALIDATE(alloc->GetOffset() == subAlloc.offset);
                D3D12MA_VALIDATE(alloc->GetSize() == subAlloc.size);
            }

            // Margin required between allocations - previous allocation must be free.
            D3D12MA_VALIDATE(D3D12MA_DEBUG_MARGIN == 0 || prevFree);
        }

        calculatedOffset += subAlloc.size;
        prevFree = currFree;
    }

    // Number of free suballocations registered in m_FreeSuballocationsBySize doesn't
    // match expected one.
    D3D12MA_VALIDATE(m_FreeSuballocationsBySize.size() == freeSuballocationsToRegister);

    UINT64 lastSize = 0;
    for(size_t i = 0; i < m_FreeSuballocationsBySize.size(); ++i)
    {
        SuballocationList::iterator suballocItem = m_FreeSuballocationsBySize[i];

        // Only free suballocations can be registered in m_FreeSuballocationsBySize.
        D3D12MA_VALIDATE(suballocItem->type == SUBALLOCATION_TYPE_FREE);
        // They must be sorted by size ascending.
        D3D12MA_VALIDATE(suballocItem->size >= lastSize);

        lastSize = suballocItem->size;
    }

    // Check if totals match calculacted values.
    D3D12MA_VALIDATE(ValidateFreeSuballocationList());
    D3D12MA_VALIDATE(calculatedOffset == GetSize());
    D3D12MA_VALIDATE(calculatedSumFreeSize == m_SumFreeSize);
    D3D12MA_VALIDATE(calculatedFreeCount == m_FreeCount);

    return true;
}

UINT64 BlockMetadata_Generic::GetUnusedRangeSizeMax() const
{
    if(!m_FreeSuballocationsBySize.empty())
    {
        return m_FreeSuballocationsBySize.back()->size;
    }
    else
    {
        return 0;
    }
}

bool BlockMetadata_Generic::IsEmpty() const
{
    return (m_Suballocations.size() == 1) && (m_FreeCount == 1);
}

void BlockMetadata_Generic::GetAllocationInfo(UINT64 offset, VIRTUAL_ALLOCATION_INFO& outInfo) const
{
    for(SuballocationList::const_iterator suballocItem = m_Suballocations.cbegin();
        suballocItem != m_Suballocations.cend();
        ++suballocItem)
    {
        const Suballocation& suballoc = *suballocItem;
        if(suballoc.offset == offset)
        {
            outInfo.size = suballoc.size;
            outInfo.pUserData = suballoc.userData;
            return;
        }
    }
    D3D12MA_ASSERT(0 && "Not found!");
}

bool BlockMetadata_Generic::CreateAllocationRequest(
    UINT64 allocSize,
    UINT64 allocAlignment,
    AllocationRequest* pAllocationRequest)
{
    D3D12MA_ASSERT(allocSize > 0);
    D3D12MA_ASSERT(pAllocationRequest != NULL);
    D3D12MA_HEAVY_ASSERT(Validate());

    // There is not enough total free space in this block to fullfill the request: Early return.
    if(m_SumFreeSize < allocSize + 2 * D3D12MA_DEBUG_MARGIN)
    {
        return false;
    }

    // New algorithm, efficiently searching freeSuballocationsBySize.
    const size_t freeSuballocCount = m_FreeSuballocationsBySize.size();
    if(freeSuballocCount > 0)
    {
        // Find first free suballocation with size not less than allocSize + 2 * D3D12MA_DEBUG_MARGIN.
        SuballocationList::iterator* const it = BinaryFindFirstNotLess(
            m_FreeSuballocationsBySize.data(),
            m_FreeSuballocationsBySize.data() + freeSuballocCount,
            allocSize + 2 * D3D12MA_DEBUG_MARGIN,
            SuballocationItemSizeLess());
        size_t index = it - m_FreeSuballocationsBySize.data();
        for(; index < freeSuballocCount; ++index)
        {
            if(CheckAllocation(
                allocSize,
                allocAlignment,
                m_FreeSuballocationsBySize[index],
                &pAllocationRequest->offset,
                &pAllocationRequest->sumFreeSize,
                &pAllocationRequest->sumItemSize,
                &pAllocationRequest->zeroInitialized))
            {
                pAllocationRequest->item = m_FreeSuballocationsBySize[index];
                return true;
            }
        }
    }

    return false;
}

void BlockMetadata_Generic::Alloc(
    const AllocationRequest& request,
    UINT64 allocSize,
    void* userData)
{
    D3D12MA_ASSERT(request.item != m_Suballocations.end());
    Suballocation& suballoc = *request.item;
    // Given suballocation is a free block.
    D3D12MA_ASSERT(suballoc.type == SUBALLOCATION_TYPE_FREE);
    // Given offset is inside this suballocation.
    D3D12MA_ASSERT(request.offset >= suballoc.offset);
    const UINT64 paddingBegin = request.offset - suballoc.offset;
    D3D12MA_ASSERT(suballoc.size >= paddingBegin + allocSize);
    const UINT64 paddingEnd = suballoc.size - paddingBegin - allocSize;

    // Unregister this free suballocation from m_FreeSuballocationsBySize and update
    // it to become used.
    UnregisterFreeSuballocation(request.item);

    suballoc.offset = request.offset;
    suballoc.size = allocSize;
    suballoc.type = SUBALLOCATION_TYPE_ALLOCATION;
    suballoc.userData = userData;

    // If there are any free bytes remaining at the end, insert new free suballocation after current one.
    if(paddingEnd)
    {
        Suballocation paddingSuballoc = {};
        paddingSuballoc.offset = request.offset + allocSize;
        paddingSuballoc.size = paddingEnd;
        paddingSuballoc.type = SUBALLOCATION_TYPE_FREE;
        SuballocationList::iterator next = request.item;
        ++next;
        const SuballocationList::iterator paddingEndItem =
            m_Suballocations.insert(next, paddingSuballoc);
        RegisterFreeSuballocation(paddingEndItem);
    }

    // If there are any free bytes remaining at the beginning, insert new free suballocation before current one.
    if(paddingBegin)
    {
        Suballocation paddingSuballoc = {};
        paddingSuballoc.offset = request.offset - paddingBegin;
        paddingSuballoc.size = paddingBegin;
        paddingSuballoc.type = SUBALLOCATION_TYPE_FREE;
        const SuballocationList::iterator paddingBeginItem =
            m_Suballocations.insert(request.item, paddingSuballoc);
        RegisterFreeSuballocation(paddingBeginItem);
    }

    // Update totals.
    m_FreeCount = m_FreeCount - 1;
    if(paddingBegin > 0)
    {
        ++m_FreeCount;
    }
    if(paddingEnd > 0)
    {
        ++m_FreeCount;
    }
    m_SumFreeSize -= allocSize;

    m_ZeroInitializedRange.MarkRangeAsUsed(request.offset, request.offset + allocSize);
}

void BlockMetadata_Generic::FreeAtOffset(UINT64 offset)
{
    for(SuballocationList::iterator suballocItem = m_Suballocations.begin();
        suballocItem != m_Suballocations.end();
        ++suballocItem)
    {
        Suballocation& suballoc = *suballocItem;
        if(suballoc.offset == offset)
        {
            FreeSuballocation(suballocItem);
            return;
        }
    }
    D3D12MA_ASSERT(0 && "Not found!");
}

void BlockMetadata_Generic::Clear()
{
    m_FreeCount = 1;
    m_SumFreeSize = GetSize();

    m_Suballocations.clear();
    Suballocation suballoc = {};
    suballoc.offset = 0;
    suballoc.size = GetSize();
    suballoc.type = SUBALLOCATION_TYPE_FREE;
    m_Suballocations.push_back(suballoc);

    m_FreeSuballocationsBySize.clear();
    m_FreeSuballocationsBySize.push_back(m_Suballocations.begin());
}

bool BlockMetadata_Generic::ValidateFreeSuballocationList() const
{
    UINT64 lastSize = 0;
    for(size_t i = 0, count = m_FreeSuballocationsBySize.size(); i < count; ++i)
    {
        const SuballocationList::iterator it = m_FreeSuballocationsBySize[i];

        D3D12MA_VALIDATE(it->type == SUBALLOCATION_TYPE_FREE);
        D3D12MA_VALIDATE(it->size >= MIN_FREE_SUBALLOCATION_SIZE_TO_REGISTER);
        D3D12MA_VALIDATE(it->size >= lastSize);
        lastSize = it->size;
    }
    return true;
}

bool BlockMetadata_Generic::CheckAllocation(
    UINT64 allocSize,
    UINT64 allocAlignment,
    SuballocationList::const_iterator suballocItem,
    UINT64* pOffset,
    UINT64* pSumFreeSize,
    UINT64* pSumItemSize,
    BOOL *pZeroInitialized) const
{
    D3D12MA_ASSERT(allocSize > 0);
    D3D12MA_ASSERT(suballocItem != m_Suballocations.cend());
    D3D12MA_ASSERT(pOffset != NULL && pZeroInitialized != NULL);

    *pSumFreeSize = 0;
    *pSumItemSize = 0;
    *pZeroInitialized = FALSE;

    const Suballocation& suballoc = *suballocItem;
    D3D12MA_ASSERT(suballoc.type == SUBALLOCATION_TYPE_FREE);

    *pSumFreeSize = suballoc.size;

    // Size of this suballocation is too small for this request: Early return.
    if(suballoc.size < allocSize)
    {
        return false;
    }

    // Start from offset equal to beginning of this suballocation.
    *pOffset = suballoc.offset;

    // Apply D3D12MA_DEBUG_MARGIN at the beginning.
    if(D3D12MA_DEBUG_MARGIN > 0)
    {
        *pOffset += D3D12MA_DEBUG_MARGIN;
    }

    // Apply alignment.
    *pOffset = AlignUp(*pOffset, allocAlignment);

    // Calculate padding at the beginning based on current offset.
    const UINT64 paddingBegin = *pOffset - suballoc.offset;

    // Calculate required margin at the end.
    const UINT64 requiredEndMargin = D3D12MA_DEBUG_MARGIN;

    // Fail if requested size plus margin before and after is bigger than size of this suballocation.
    if(paddingBegin + allocSize + requiredEndMargin > suballoc.size)
    {
        return false;
    }

    // All tests passed: Success. pOffset is already filled.
    *pZeroInitialized = m_ZeroInitializedRange.IsRangeZeroInitialized(*pOffset, *pOffset + allocSize);
    return true;
}

void BlockMetadata_Generic::MergeFreeWithNext(SuballocationList::iterator item)
{
    D3D12MA_ASSERT(item != m_Suballocations.end());
    D3D12MA_ASSERT(item->type == SUBALLOCATION_TYPE_FREE);

    SuballocationList::iterator nextItem = item;
    ++nextItem;
    D3D12MA_ASSERT(nextItem != m_Suballocations.end());
    D3D12MA_ASSERT(nextItem->type == SUBALLOCATION_TYPE_FREE);

    item->size += nextItem->size;
    --m_FreeCount;
    m_Suballocations.erase(nextItem);
}

SuballocationList::iterator BlockMetadata_Generic::FreeSuballocation(SuballocationList::iterator suballocItem)
{
    // Change this suballocation to be marked as free.
    Suballocation& suballoc = *suballocItem;
    suballoc.type = SUBALLOCATION_TYPE_FREE;
    suballoc.userData = NULL;

    // Update totals.
    ++m_FreeCount;
    m_SumFreeSize += suballoc.size;

    // Merge with previous and/or next suballocation if it's also free.
    bool mergeWithNext = false;
    bool mergeWithPrev = false;

    SuballocationList::iterator nextItem = suballocItem;
    ++nextItem;
    if((nextItem != m_Suballocations.end()) && (nextItem->type == SUBALLOCATION_TYPE_FREE))
    {
        mergeWithNext = true;
    }

    SuballocationList::iterator prevItem = suballocItem;
    if(suballocItem != m_Suballocations.begin())
    {
        --prevItem;
        if(prevItem->type == SUBALLOCATION_TYPE_FREE)
        {
            mergeWithPrev = true;
        }
    }

    if(mergeWithNext)
    {
        UnregisterFreeSuballocation(nextItem);
        MergeFreeWithNext(suballocItem);
    }

    if(mergeWithPrev)
    {
        UnregisterFreeSuballocation(prevItem);
        MergeFreeWithNext(prevItem);
        RegisterFreeSuballocation(prevItem);
        return prevItem;
    }
    else
    {
        RegisterFreeSuballocation(suballocItem);
        return suballocItem;
    }
}

void BlockMetadata_Generic::RegisterFreeSuballocation(SuballocationList::iterator item)
{
    D3D12MA_ASSERT(item->type == SUBALLOCATION_TYPE_FREE);
    D3D12MA_ASSERT(item->size > 0);

    // You may want to enable this validation at the beginning or at the end of
    // this function, depending on what do you want to check.
    D3D12MA_HEAVY_ASSERT(ValidateFreeSuballocationList());

    if(item->size >= MIN_FREE_SUBALLOCATION_SIZE_TO_REGISTER)
    {
        if(m_FreeSuballocationsBySize.empty())
        {
            m_FreeSuballocationsBySize.push_back(item);
        }
        else
        {
            m_FreeSuballocationsBySize.InsertSorted(item, SuballocationItemSizeLess());
        }
    }

    //D3D12MA_HEAVY_ASSERT(ValidateFreeSuballocationList());
}


void BlockMetadata_Generic::UnregisterFreeSuballocation(SuballocationList::iterator item)
{
    D3D12MA_ASSERT(item->type == SUBALLOCATION_TYPE_FREE);
    D3D12MA_ASSERT(item->size > 0);

    // You may want to enable this validation at the beginning or at the end of
    // this function, depending on what do you want to check.
    D3D12MA_HEAVY_ASSERT(ValidateFreeSuballocationList());

    if(item->size >= MIN_FREE_SUBALLOCATION_SIZE_TO_REGISTER)
    {
        SuballocationList::iterator* const it = BinaryFindFirstNotLess(
            m_FreeSuballocationsBySize.data(),
            m_FreeSuballocationsBySize.data() + m_FreeSuballocationsBySize.size(),
            item,
            SuballocationItemSizeLess());
        for(size_t index = it - m_FreeSuballocationsBySize.data();
            index < m_FreeSuballocationsBySize.size();
            ++index)
        {
            if(m_FreeSuballocationsBySize[index] == item)
            {
                m_FreeSuballocationsBySize.remove(index);
                return;
            }
            D3D12MA_ASSERT((m_FreeSuballocationsBySize[index]->size == item->size) && "Not found.");
        }
        D3D12MA_ASSERT(0 && "Not found.");
    }

    //D3D12MA_HEAVY_ASSERT(ValidateFreeSuballocationList());
}

void BlockMetadata_Generic::SetAllocationUserData(UINT64 offset, void* userData)
{
    for(SuballocationList::iterator suballocItem = m_Suballocations.begin();
        suballocItem != m_Suballocations.end();
        ++suballocItem)
    {
        Suballocation& suballoc = *suballocItem;
        if(suballoc.offset == offset)
        {
            suballoc.userData = userData;
            return;
        }
    }
    D3D12MA_ASSERT(0 && "Not found!");
}

void BlockMetadata_Generic::CalcAllocationStatInfo(StatInfo& outInfo) const
{
    outInfo.BlockCount = 1;

    const UINT rangeCount = (UINT)m_Suballocations.size();
    outInfo.AllocationCount = rangeCount - m_FreeCount;
    outInfo.UnusedRangeCount = m_FreeCount;

    outInfo.UsedBytes = GetSize() - m_SumFreeSize;
    outInfo.UnusedBytes = m_SumFreeSize;

    outInfo.AllocationSizeMin = UINT64_MAX;
    outInfo.AllocationSizeMax = 0;
    outInfo.UnusedRangeSizeMin = UINT64_MAX;
    outInfo.UnusedRangeSizeMax = 0;

    for(SuballocationList::const_iterator suballocItem = m_Suballocations.cbegin();
        suballocItem != m_Suballocations.cend();
        ++suballocItem)
    {
        const Suballocation& suballoc = *suballocItem;
        if(suballoc.type == SUBALLOCATION_TYPE_FREE)
        {
            outInfo.UnusedRangeSizeMin = D3D12MA_MIN(suballoc.size, outInfo.UnusedRangeSizeMin);
            outInfo.UnusedRangeSizeMax = D3D12MA_MAX(suballoc.size, outInfo.UnusedRangeSizeMax);
        }
        else
        {
            outInfo.AllocationSizeMin = D3D12MA_MIN(suballoc.size, outInfo.AllocationSizeMin);
            outInfo.AllocationSizeMax = D3D12MA_MAX(suballoc.size, outInfo.AllocationSizeMax);
        }
    }
}

void BlockMetadata_Generic::WriteAllocationInfoToJson(JsonWriter& json) const
{
    json.BeginObject();
    json.WriteString(L"TotalBytes");
    json.WriteNumber(GetSize());
    json.WriteString(L"UnusuedBytes");
    json.WriteNumber(GetSumFreeSize());
    json.WriteString(L"Allocations");
    json.WriteNumber(GetAllocationCount());
    json.WriteString(L"UnusedRanges");
    json.WriteNumber(m_FreeCount);
    json.WriteString(L"Suballocations");
    json.BeginArray();
    for(SuballocationList::const_iterator suballocItem = m_Suballocations.cbegin();
        suballocItem != m_Suballocations.cend();
        ++suballocItem)
    {
        const Suballocation& suballoc = *suballocItem;
        json.BeginObject(true);
        json.WriteString(L"Offset");
        json.WriteNumber(suballoc.offset);
        if(suballoc.type == SUBALLOCATION_TYPE_FREE)
        {
            json.WriteString(L"Type");
            json.WriteString(L"FREE");
            json.WriteString(L"Size");
            json.WriteNumber(suballoc.size);
        }
        else if(IsVirtual())
        {
            json.WriteString(L"Type");
            json.WriteString(L"ALLOCATION");
            json.WriteString(L"Size");
            json.WriteNumber(suballoc.size);
            if(suballoc.userData)
            {
                json.WriteString(L"UserData");
                json.WriteNumber((uintptr_t)suballoc.userData);
            }
        }
        else
        {
            const Allocation* const alloc = (const Allocation*)suballoc.userData;
            D3D12MA_ASSERT(alloc);
            json.AddAllocationToObject(*alloc);
        }
        json.EndObject();
    }
    json.EndArray();
    json.EndObject();
}

////////////////////////////////////////////////////////////////////////////////
// Private class NormalBlock implementation

NormalBlock::NormalBlock(
    AllocatorPimpl* allocator,
    BlockVector* blockVector,
    D3D12_HEAP_TYPE heapType,
    D3D12_HEAP_FLAGS heapFlags,
    UINT64 size,
    UINT id) :
    MemoryBlock(allocator, heapType, heapFlags, size, id),
    m_pMetadata(NULL),
    m_BlockVector(blockVector)
{
}

NormalBlock::~NormalBlock()
{
    if(m_pMetadata != NULL)
    {
        // THIS IS THE MOST IMPORTANT ASSERT IN THE ENTIRE LIBRARY!
        // Hitting it means you have some memory leak - unreleased Allocation objects.
        D3D12MA_ASSERT(m_pMetadata->IsEmpty() && "Some allocations were not freed before destruction of this memory block!");

        D3D12MA_DELETE(m_Allocator->GetAllocs(), m_pMetadata);
    }
}

HRESULT NormalBlock::Init()
{
    HRESULT hr = MemoryBlock::Init();
    if(FAILED(hr))
    {
        return hr;
    }
    
    m_pMetadata = D3D12MA_NEW(m_Allocator->GetAllocs(), BlockMetadata_Generic)(&m_Allocator->GetAllocs(), false);
    m_pMetadata->Init(m_Size);

    return hr;
}

bool NormalBlock::Validate() const
{
    D3D12MA_VALIDATE(GetHeap() &&
        m_pMetadata &&
        m_pMetadata->GetSize() != 0 &&
        m_pMetadata->GetSize() == GetSize());
    return m_pMetadata->Validate();
}

////////////////////////////////////////////////////////////////////////////////
// Private class MemoryBlock definition

MemoryBlock::MemoryBlock(
    AllocatorPimpl* allocator,
    D3D12_HEAP_TYPE heapType,
    D3D12_HEAP_FLAGS heapFlags,
    UINT64 size,
    UINT id) :
    m_Allocator(allocator),
    m_HeapType(heapType),
    m_HeapFlags(heapFlags),
    m_Size(size),
    m_Id(id)
{
}

MemoryBlock::~MemoryBlock()
{
    if(m_Heap)
    {
        m_Allocator->m_Budget.m_BlockBytes[HeapTypeToIndex(m_HeapType)] -= m_Size;
        m_Heap->Release();
    }
}

HRESULT MemoryBlock::Init()
{
    D3D12MA_ASSERT(m_Heap == NULL && m_Size > 0);

    D3D12_HEAP_DESC heapDesc = {};
    heapDesc.SizeInBytes = m_Size;
    heapDesc.Properties.Type = m_HeapType;
    heapDesc.Alignment = HeapFlagsToAlignment(m_HeapFlags);
    heapDesc.Flags = m_HeapFlags;

    HRESULT hr = m_Allocator->GetDevice()->CreateHeap(&heapDesc, __uuidof(*m_Heap), (void**)&m_Heap);
    if(SUCCEEDED(hr))
    {
        m_Allocator->m_Budget.m_BlockBytes[HeapTypeToIndex(m_HeapType)] += m_Size;
    }
    return hr;
}

////////////////////////////////////////////////////////////////////////////////
// Private class BlockVector implementation

BlockVector::BlockVector(
    AllocatorPimpl* hAllocator,
    D3D12_HEAP_TYPE heapType,
    D3D12_HEAP_FLAGS heapFlags,
    UINT64 preferredBlockSize,
    size_t minBlockCount,
    size_t maxBlockCount,
    bool explicitBlockSize) :
    m_hAllocator(hAllocator),
    m_HeapType(heapType),
    m_HeapFlags(heapFlags),
    m_PreferredBlockSize(preferredBlockSize),
    m_MinBlockCount(minBlockCount),
    m_MaxBlockCount(maxBlockCount),
    m_ExplicitBlockSize(explicitBlockSize),
    m_MinBytes(0),
    m_HasEmptyBlock(false),
    m_Blocks(hAllocator->GetAllocs()),
    m_NextBlockId(0)
{
}

BlockVector::~BlockVector()
{
    for(size_t i = m_Blocks.size(); i--; )
    {
        D3D12MA_DELETE(m_hAllocator->GetAllocs(), m_Blocks[i]);
    }
}

HRESULT BlockVector::CreateMinBlocks()
{
    for(size_t i = 0; i < m_MinBlockCount; ++i)
    {
        HRESULT hr = CreateBlock(m_PreferredBlockSize, NULL);
        if(FAILED(hr))
        {
            return hr;
        }
    }
    return S_OK;
}

bool BlockVector::IsEmpty()
{
    MutexLockRead lock(m_Mutex, m_hAllocator->UseMutex());
    return m_Blocks.empty();
}

HRESULT BlockVector::Allocate(
    UINT64 size,
    UINT64 alignment,
    const ALLOCATION_DESC& allocDesc,
    size_t allocationCount,
    Allocation** pAllocations)
{
    size_t allocIndex;
    HRESULT hr = S_OK;

    {
        MutexLockWrite lock(m_Mutex, m_hAllocator->UseMutex());
        for(allocIndex = 0; allocIndex < allocationCount; ++allocIndex)
        {
            hr = AllocatePage(
                size,
                alignment,
                allocDesc,
                pAllocations + allocIndex);
            if(FAILED(hr))
            {
                break;
            }
        }
    }

    if(FAILED(hr))
    {
        // Free all already created allocations.
        while(allocIndex--)
        {
            Free(pAllocations[allocIndex]);
        }
        ZeroMemory(pAllocations, sizeof(Allocation*) * allocationCount);
    }

    return hr;
}

HRESULT BlockVector::AllocatePage(
    UINT64 size,
    UINT64 alignment,
    const ALLOCATION_DESC& allocDesc,
    Allocation** pAllocation)
{
    // Early reject: requested allocation size is larger that maximum block size for this block vector.
    if(size + 2 * D3D12MA_DEBUG_MARGIN > m_PreferredBlockSize)
    {
        return E_OUTOFMEMORY;
    }

    UINT64 freeMemory;
    {
        Budget budget = {};
        m_hAllocator->GetBudgetForHeapType(budget, m_HeapType);
        freeMemory = (budget.UsageBytes < budget.BudgetBytes) ? (budget.BudgetBytes - budget.UsageBytes) : 0;
    }

    const bool canCreateNewBlock =
        ((allocDesc.Flags & ALLOCATION_FLAG_NEVER_ALLOCATE) == 0) &&
        (m_Blocks.size() < m_MaxBlockCount) &&
        // Even if we don't have to stay within budget with this allocation, when the
        // budget would be exceeded, we don't want to allocate new blocks, but always
        // create resources as committed.
        freeMemory >= size;

    // 1. Search existing allocations
    {
        // Forward order in m_Blocks - prefer blocks with smallest amount of free space.
        for(size_t blockIndex = 0; blockIndex < m_Blocks.size(); ++blockIndex )
        {
            NormalBlock* const pCurrBlock = m_Blocks[blockIndex];
            D3D12MA_ASSERT(pCurrBlock);
            HRESULT hr = AllocateFromBlock(
                pCurrBlock,
                size,
                alignment,
                allocDesc.Flags,
                pAllocation);
            if(SUCCEEDED(hr))
            {
                return hr;
            }
        }
    }

    // 2. Try to create new block.
    if(canCreateNewBlock)
    {
        // Calculate optimal size for new block.
        UINT64 newBlockSize = m_PreferredBlockSize;
        UINT newBlockSizeShift = 0;

        if(!m_ExplicitBlockSize)
        {
            // Allocate 1/8, 1/4, 1/2 as first blocks.
            const UINT64 maxExistingBlockSize = CalcMaxBlockSize();
            for(UINT i = 0; i < NEW_BLOCK_SIZE_SHIFT_MAX; ++i)
            {
                const UINT64 smallerNewBlockSize = newBlockSize / 2;
                if(smallerNewBlockSize > maxExistingBlockSize && smallerNewBlockSize >= size * 2)
                {
                    newBlockSize = smallerNewBlockSize;
                    ++newBlockSizeShift;
                }
                else
                {
                    break;
                }
            }
        }

        size_t newBlockIndex = 0;
        HRESULT hr = newBlockSize <= freeMemory ?
            CreateBlock(newBlockSize, &newBlockIndex) : E_OUTOFMEMORY;
        // Allocation of this size failed? Try 1/2, 1/4, 1/8 of m_PreferredBlockSize.
        if(!m_ExplicitBlockSize)
        {
            while(FAILED(hr) && newBlockSizeShift < NEW_BLOCK_SIZE_SHIFT_MAX)
            {
                const UINT64 smallerNewBlockSize = newBlockSize / 2;
                if(smallerNewBlockSize >= size)
                {
                    newBlockSize = smallerNewBlockSize;
                    ++newBlockSizeShift;
                    hr = newBlockSize <= freeMemory ?
                        CreateBlock(newBlockSize, &newBlockIndex) : E_OUTOFMEMORY;
                }
                else
                {
                    break;
                }
            }
        }

        if(SUCCEEDED(hr))
        {
            NormalBlock* const pBlock = m_Blocks[newBlockIndex];
            D3D12MA_ASSERT(pBlock->m_pMetadata->GetSize() >= size);

            hr = AllocateFromBlock(
                pBlock,
                size,
                alignment,
                allocDesc.Flags,
                pAllocation);
            if(SUCCEEDED(hr))
            {
                return hr;
            }
            else
            {
                // Allocation from new block failed, possibly due to D3D12MA_DEBUG_MARGIN or alignment.
                return E_OUTOFMEMORY;
            }
        }
    }

    return E_OUTOFMEMORY;
}

void BlockVector::Free(Allocation* hAllocation)
{
    NormalBlock* pBlockToDelete = NULL;

    bool budgetExceeded = false;
    {
        Budget budget = {};
        m_hAllocator->GetBudgetForHeapType(budget, m_HeapType);
        budgetExceeded = budget.UsageBytes >= budget.BudgetBytes;
    }

    // Scope for lock.
    {
        MutexLockWrite lock(m_Mutex, m_hAllocator->UseMutex());

        NormalBlock* pBlock = hAllocation->m_Placed.block;

        pBlock->m_pMetadata->FreeAtOffset(hAllocation->GetOffset());
        D3D12MA_HEAVY_ASSERT(pBlock->Validate());

        const size_t blockCount = m_Blocks.size();
        const UINT64 sumBlockSize = CalcSumBlockSize();
        // pBlock became empty after this deallocation.
        if(pBlock->m_pMetadata->IsEmpty())
        {
            // Already has empty Allocation. We don't want to have two, so delete this one.
            if((m_HasEmptyBlock || budgetExceeded) &&
                blockCount > m_MinBlockCount &&
                sumBlockSize - pBlock->m_pMetadata->GetSize() >= m_MinBytes)
            {
                pBlockToDelete = pBlock;
                Remove(pBlock);
            }
            // We now have first empty block.
            else
            {
                m_HasEmptyBlock = true;
            }
        }
        // pBlock didn't become empty, but we have another empty block - find and free that one.
        // (This is optional, heuristics.)
        else if(m_HasEmptyBlock && blockCount > m_MinBlockCount)
        {
            NormalBlock* pLastBlock = m_Blocks.back();
            if(pLastBlock->m_pMetadata->IsEmpty() &&
                sumBlockSize - pLastBlock->m_pMetadata->GetSize() >= m_MinBytes)
            {
                pBlockToDelete = pLastBlock;
                m_Blocks.pop_back();
                m_HasEmptyBlock = false;
            }
        }

        IncrementallySortBlocks();
    }

    // Destruction of a free Allocation. Deferred until this point, outside of mutex
    // lock, for performance reason.
    if(pBlockToDelete != NULL)
    {
        D3D12MA_DELETE(m_hAllocator->GetAllocs(), pBlockToDelete);
    }
}

HRESULT BlockVector::CreateResource(
    UINT64 size,
    UINT64 alignment,
    const ALLOCATION_DESC& allocDesc,
    const D3D12_RESOURCE_DESC& resourceDesc,
    D3D12_RESOURCE_STATES InitialResourceState,
    const D3D12_CLEAR_VALUE *pOptimizedClearValue,
    Allocation** ppAllocation,
    REFIID riidResource,
    void** ppvResource)
{
    HRESULT hr = Allocate(size, alignment, allocDesc, 1, ppAllocation);
    if(SUCCEEDED(hr))
    {
        ID3D12Resource* res = NULL;
        hr = m_hAllocator->GetDevice()->CreatePlacedResource(
            (*ppAllocation)->m_Placed.block->GetHeap(),
            (*ppAllocation)->GetOffset(),
            &resourceDesc,
            InitialResourceState,
            pOptimizedClearValue,
            IID_PPV_ARGS(&res));
        if(SUCCEEDED(hr))
        {
            if(ppvResource != NULL)
            {
                hr = res->QueryInterface(riidResource, ppvResource);
            }
            if(SUCCEEDED(hr))
            {
                (*ppAllocation)->SetResource(res, &resourceDesc);
            }
            else
            {
                res->Release();
                SAFE_RELEASE(*ppAllocation);
            }
        }
        else
        {
            SAFE_RELEASE(*ppAllocation);
        }
    }
    return hr;
}

#ifdef __ID3D12Device8_INTERFACE_DEFINED__
HRESULT BlockVector::CreateResource2(
    UINT64 size,
    UINT64 alignment,
    const ALLOCATION_DESC& allocDesc,
    const D3D12_RESOURCE_DESC1& resourceDesc,
    D3D12_RESOURCE_STATES InitialResourceState,
    const D3D12_CLEAR_VALUE *pOptimizedClearValue,
    ID3D12ProtectedResourceSession *pProtectedSession,
    Allocation** ppAllocation,
    REFIID riidResource,
    void** ppvResource)
{
    D3D12MA_ASSERT(pProtectedSession == NULL && "Should never get here. pProtectedSession != NULL currently requires committed resources.");

    ID3D12Device8* const device8 = m_hAllocator->GetDevice8();
    if(device8 == NULL)
    {
        return E_NOINTERFACE;
    }

    HRESULT hr = Allocate(size, alignment, allocDesc, 1, ppAllocation);
    if(SUCCEEDED(hr))
    {
        ID3D12Resource* res = NULL;
        hr = device8->CreatePlacedResource1(
            (*ppAllocation)->m_Placed.block->GetHeap(),
            (*ppAllocation)->GetOffset(),
            &resourceDesc,
            InitialResourceState,
            pOptimizedClearValue,
            IID_PPV_ARGS(&res));
        if(SUCCEEDED(hr))
        {
            if(ppvResource != NULL)
            {
                hr = res->QueryInterface(riidResource, ppvResource);
            }
            if(SUCCEEDED(hr))
            {
                (*ppAllocation)->SetResource(res, &resourceDesc);
            }
            else
            {
                res->Release();
                SAFE_RELEASE(*ppAllocation);
            }
        }
        else
        {
            SAFE_RELEASE(*ppAllocation);
        }
    }
    return hr;
}
#endif // #ifdef __ID3D12Device8_INTERFACE_DEFINED__

UINT64 BlockVector::CalcSumBlockSize() const
{
    UINT64 result = 0;
    for(size_t i = m_Blocks.size(); i--; )
    {
        result += m_Blocks[i]->m_pMetadata->GetSize();
    }
    return result;
}

UINT64 BlockVector::CalcMaxBlockSize() const
{
    UINT64 result = 0;
    for(size_t i = m_Blocks.size(); i--; )
    {
        result = D3D12MA_MAX(result, m_Blocks[i]->m_pMetadata->GetSize());
        if(result >= m_PreferredBlockSize)
        {
            break;
        }
    }
    return result;
}

void BlockVector::Remove(NormalBlock* pBlock)
{
    for(size_t blockIndex = 0; blockIndex < m_Blocks.size(); ++blockIndex)
    {
        if(m_Blocks[blockIndex] == pBlock)
        {
            m_Blocks.remove(blockIndex);
            return;
        }
    }
    D3D12MA_ASSERT(0);
}

void BlockVector::IncrementallySortBlocks()
{
    // Bubble sort only until first swap.
    for(size_t i = 1; i < m_Blocks.size(); ++i)
    {
        if(m_Blocks[i - 1]->m_pMetadata->GetSumFreeSize() > m_Blocks[i]->m_pMetadata->GetSumFreeSize())
        {
            D3D12MA_SWAP(m_Blocks[i - 1], m_Blocks[i]);
            return;
        }
    }
}

HRESULT BlockVector::AllocateFromBlock(
    NormalBlock* pBlock,
    UINT64 size,
    UINT64 alignment,
    ALLOCATION_FLAGS allocFlags,
    Allocation** pAllocation)
{
    AllocationRequest currRequest = {};
    if(pBlock->m_pMetadata->CreateAllocationRequest(
        size,
        alignment,
        &currRequest))
    {
        // We no longer have an empty Allocation.
        if(pBlock->m_pMetadata->IsEmpty())
        {
            m_HasEmptyBlock = false;
        }

        *pAllocation = m_hAllocator->GetAllocationObjectAllocator().Allocate(m_hAllocator, size, currRequest.zeroInitialized);
        pBlock->m_pMetadata->Alloc(currRequest, size, *pAllocation);
        (*pAllocation)->InitPlaced(currRequest.offset, alignment, pBlock);
        D3D12MA_HEAVY_ASSERT(pBlock->Validate());
        m_hAllocator->m_Budget.AddAllocation(HeapTypeToIndex(m_HeapType), size);
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

HRESULT BlockVector::CreateBlock(UINT64 blockSize, size_t* pNewBlockIndex)
{
    NormalBlock* const pBlock = D3D12MA_NEW(m_hAllocator->GetAllocs(), NormalBlock)(
        m_hAllocator,
        this,
        m_HeapType,
        m_HeapFlags,
        blockSize,
        m_NextBlockId++);
    HRESULT hr = pBlock->Init();
    if(FAILED(hr))
    {
        D3D12MA_DELETE(m_hAllocator->GetAllocs(), pBlock);
        return hr;
    }

    m_Blocks.push_back(pBlock);
    if(pNewBlockIndex != NULL)
    {
        *pNewBlockIndex = m_Blocks.size() - 1;
    }

    return hr;
}

HRESULT BlockVector::SetMinBytes(UINT64 minBytes)
{
    MutexLockWrite lock(m_Mutex, m_hAllocator->UseMutex());

    if(minBytes == m_MinBytes)
    {
        return S_OK;
    }

    HRESULT hr = S_OK;
    UINT64 sumBlockSize = CalcSumBlockSize();
    size_t blockCount = m_Blocks.size();

    // New minBytes is smaller - may be able to free some blocks.
    if(minBytes < m_MinBytes)
    {
        m_HasEmptyBlock = false; // Will recalculate this value from scratch.
        for(size_t blockIndex = blockCount; blockIndex--; )
        {
            NormalBlock* const block = m_Blocks[blockIndex];
            const UINT64 size = block->m_pMetadata->GetSize();
            const bool isEmpty = block->m_pMetadata->IsEmpty();
            if(isEmpty &&
                sumBlockSize - size >= minBytes &&
                blockCount - 1 >= m_MinBlockCount)
            {
                D3D12MA_DELETE(m_hAllocator->GetAllocs(), block);
                m_Blocks.remove(blockIndex);
                sumBlockSize -= size;
                --blockCount;
            }
            else
            {
                if(isEmpty)
                {
                    m_HasEmptyBlock = true;
                }
            }
        }
    }
    // New minBytes is larger - may need to allocate some blocks.
    else
    {
        const UINT64 minBlockSize = m_PreferredBlockSize >> NEW_BLOCK_SIZE_SHIFT_MAX;
        while(SUCCEEDED(hr) && sumBlockSize < minBytes)
        {
            if(blockCount < m_MaxBlockCount)
            {
                UINT64 newBlockSize = m_PreferredBlockSize;
                if(!m_ExplicitBlockSize)
                {
                    if(sumBlockSize + newBlockSize > minBytes)
                    {
                        newBlockSize = minBytes - sumBlockSize;
                    }
                    // Next one would be the last block to create and its size would be smaller than
                    // the smallest block size we want to use here, so make this one smaller.
                    else if(blockCount + 1 < m_MaxBlockCount &&
                        sumBlockSize + newBlockSize + minBlockSize > minBytes)
                    {
                        newBlockSize -= minBlockSize + sumBlockSize + m_PreferredBlockSize - minBytes;
                    }
                }

                hr = CreateBlock(newBlockSize, NULL);
                if(SUCCEEDED(hr))
                {
                    m_HasEmptyBlock = true;
                    sumBlockSize += newBlockSize;
                    ++blockCount;
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }
    }

    m_MinBytes = minBytes;
    return hr;
}

void BlockVector::AddStats(StatInfo& outStats)
{
    MutexLockRead lock(m_Mutex, m_hAllocator->UseMutex());

    for(size_t i = 0; i < m_Blocks.size(); ++i)
    {
        const NormalBlock* const pBlock = m_Blocks[i];
        D3D12MA_ASSERT(pBlock);
        D3D12MA_HEAVY_ASSERT(pBlock->Validate());
        StatInfo blockStatInfo;
        pBlock->m_pMetadata->CalcAllocationStatInfo(blockStatInfo);
        AddStatInfo(outStats, blockStatInfo);
    }
}

void BlockVector::AddStats(Stats& outStats)
{
    const UINT heapTypeIndex = HeapTypeToIndex(m_HeapType);
    StatInfo* const pStatInfo = &outStats.HeapType[heapTypeIndex];

    MutexLockRead lock(m_Mutex, m_hAllocator->UseMutex());

    for(size_t i = 0; i < m_Blocks.size(); ++i)
    {
        const NormalBlock* const pBlock = m_Blocks[i];
        D3D12MA_ASSERT(pBlock);
        D3D12MA_HEAVY_ASSERT(pBlock->Validate());
        StatInfo blockStatInfo;
        pBlock->m_pMetadata->CalcAllocationStatInfo(blockStatInfo);
        AddStatInfo(outStats.Total, blockStatInfo);
        AddStatInfo(*pStatInfo, blockStatInfo);
    }
}

void BlockVector::WriteBlockInfoToJson(JsonWriter& json)
{
    MutexLockRead lock(m_Mutex, m_hAllocator->UseMutex());

    json.BeginObject();

    for (size_t i = 0, count = m_Blocks.size(); i < count; ++i)
    {
        const NormalBlock* const pBlock = m_Blocks[i];
        D3D12MA_ASSERT(pBlock);
        D3D12MA_HEAVY_ASSERT(pBlock->Validate());
        json.BeginString();
        json.ContinueString(pBlock->GetId());
        json.EndString();

        pBlock->m_pMetadata->WriteAllocationInfoToJson(json);
    }

    json.EndObject();
}

////////////////////////////////////////////////////////////////////////////////
// Private class PoolPimpl

PoolPimpl::PoolPimpl(AllocatorPimpl* allocator, const POOL_DESC& desc) :
    m_Allocator(allocator),
    m_Desc(desc),
    m_BlockVector(NULL),
    m_Name(NULL)
{
    const bool explicitBlockSize = desc.BlockSize != 0;
    const UINT64 preferredBlockSize = explicitBlockSize ? desc.BlockSize : D3D12MA_DEFAULT_BLOCK_SIZE;

    D3D12_HEAP_FLAGS heapFlags = desc.HeapFlags;

    UINT maxBlockCount = desc.MaxBlockCount != 0 ? desc.MaxBlockCount : UINT_MAX;

    m_BlockVector = D3D12MA_NEW(allocator->GetAllocs(), BlockVector)(
        allocator, desc.HeapType, heapFlags,
        preferredBlockSize,
        desc.MinBlockCount, maxBlockCount,
        explicitBlockSize);
}

HRESULT PoolPimpl::Init()
{
    return m_BlockVector->CreateMinBlocks();
}

PoolPimpl::~PoolPimpl()
{
    D3D12MA_ASSERT(m_PrevPool == NULL && m_NextPool == NULL);
    FreeName();
    D3D12MA_DELETE(m_Allocator->GetAllocs(), m_BlockVector);
}

void PoolPimpl::CalculateStats(StatInfo& outStats)
{
    ZeroMemory(&outStats, sizeof(outStats));
    outStats.AllocationSizeMin = UINT64_MAX;
    outStats.UnusedRangeSizeMin = UINT64_MAX;

    m_BlockVector->AddStats(outStats);

    PostProcessStatInfo(outStats);
}

void PoolPimpl::SetName(LPCWSTR Name)
{
    FreeName();

    if(Name)
    {
        const size_t nameCharCount = wcslen(Name) + 1;
        m_Name = D3D12MA_NEW_ARRAY(m_Allocator->GetAllocs(), WCHAR, nameCharCount);
        memcpy(m_Name, Name, nameCharCount * sizeof(WCHAR));
    }
}

void PoolPimpl::FreeName()
{
    if(m_Name)
    {
        const size_t nameCharCount = wcslen(m_Name) + 1;
        D3D12MA_DELETE_ARRAY(m_Allocator->GetAllocs(), m_Name, nameCharCount);
        m_Name = NULL;
    }
}

////////////////////////////////////////////////////////////////////////////////
// Public class Pool implementation

void Pool::Release()
{
    if(this == NULL)
    {
        return;
    }

    D3D12MA_DEBUG_GLOBAL_MUTEX_LOCK

    D3D12MA_DELETE(m_Pimpl->GetAllocator()->GetAllocs(), this);
}

POOL_DESC Pool::GetDesc() const
{
    return m_Pimpl->GetDesc();
}

HRESULT Pool::SetMinBytes(UINT64 minBytes)
{
    return m_Pimpl->SetMinBytes(minBytes);
}

void Pool::CalculateStats(StatInfo* pStats)
{
    D3D12MA_ASSERT(pStats);
    D3D12MA_DEBUG_GLOBAL_MUTEX_LOCK
    m_Pimpl->CalculateStats(*pStats);
}

void Pool::SetName(LPCWSTR Name)
{
    D3D12MA_DEBUG_GLOBAL_MUTEX_LOCK
    m_Pimpl->SetName(Name);
}

LPCWSTR Pool::GetName() const
{
    return m_Pimpl->GetName();
}

Pool::Pool(Allocator* allocator, const POOL_DESC &desc) :
    m_Pimpl(D3D12MA_NEW(allocator->m_Pimpl->GetAllocs(), PoolPimpl)(allocator->m_Pimpl, desc))
{
}

Pool::~Pool()
{
    m_Pimpl->GetAllocator()->UnregisterPool(this, m_Pimpl->GetDesc().HeapType);

    D3D12MA_DELETE(m_Pimpl->GetAllocator()->GetAllocs(), m_Pimpl);
}

////////////////////////////////////////////////////////////////////////////////
// Private class AllocatorPimpl implementation

AllocatorPimpl::AllocatorPimpl(const ALLOCATION_CALLBACKS& allocationCallbacks, const ALLOCATOR_DESC& desc) :
    m_UseMutex((desc.Flags & ALLOCATOR_FLAG_SINGLETHREADED) == 0),
    m_AlwaysCommitted((desc.Flags & ALLOCATOR_FLAG_ALWAYS_COMMITTED) != 0),
    m_Device(desc.pDevice),
    m_Adapter(desc.pAdapter),
    m_PreferredBlockSize(desc.PreferredBlockSize != 0 ? desc.PreferredBlockSize : D3D12MA_DEFAULT_BLOCK_SIZE),
    m_AllocationCallbacks(allocationCallbacks),
    m_CurrentFrameIndex(0),
    // Below this line don't use allocationCallbacks but m_AllocationCallbacks!!!
    m_AllocationObjectAllocator(m_AllocationCallbacks)
{
    // desc.pAllocationCallbacks intentionally ignored here, preprocessed by CreateAllocator.
    ZeroMemory(&m_D3D12Options, sizeof(m_D3D12Options));

    ZeroMemory(m_BlockVectors, sizeof(m_BlockVectors));
    ZeroMemory(m_DefaultPoolTier1MinBytes, sizeof(m_DefaultPoolTier1MinBytes));

    for(UINT i = 0; i < HEAP_TYPE_COUNT; ++i)
    {
        m_DefaultPoolHeapTypeMinBytes[i] = UINT64_MAX;
    }

    m_Device->AddRef();
    m_Adapter->AddRef();
}

HRESULT AllocatorPimpl::Init(const ALLOCATOR_DESC& desc)
{
#if D3D12MA_DXGI_1_4
    desc.pAdapter->QueryInterface<IDXGIAdapter3>(&m_Adapter3);
#endif

#ifdef __ID3D12Device4_INTERFACE_DEFINED__
    m_Device->QueryInterface<ID3D12Device4>(&m_Device4);
#endif

#ifdef __ID3D12Device8_INTERFACE_DEFINED__
    m_Device->QueryInterface<ID3D12Device8>(&m_Device8);
#endif

    HRESULT hr = m_Adapter->GetDesc(&m_AdapterDesc);
    if(FAILED(hr))
    {
        return hr;
    }

    hr = m_Device->CheckFeatureSupport(D3D12_FEATURE_D3D12_OPTIONS, &m_D3D12Options, sizeof(m_D3D12Options));
    if(FAILED(hr))
    {
        return hr;
    }
#ifdef D3D12MA_FORCE_RESOURCE_HEAP_TIER
    m_D3D12Options.ResourceHeapTier = (D3D12MA_FORCE_RESOURCE_HEAP_TIER);
#endif

    const UINT defaultPoolCount = CalcDefaultPoolCount();
    for(UINT i = 0; i < defaultPoolCount; ++i)
    {
        D3D12_HEAP_TYPE heapType;
        D3D12_HEAP_FLAGS heapFlags;
        CalcDefaultPoolParams(heapType, heapFlags, i);

        m_BlockVectors[i] = D3D12MA_NEW(GetAllocs(), BlockVector)(
            this, // hAllocator
            heapType, // heapType
            heapFlags, // heapFlags
            m_PreferredBlockSize,
            0, // minBlockCount
            SIZE_MAX, // maxBlockCount
            false); // explicitBlockSize
        // No need to call m_pBlockVectors[i]->CreateMinBlocks here, becase minBlockCount is 0.
    }

#if D3D12MA_DXGI_1_4
    if(m_Adapter3)
    {
        UpdateD3D12Budget();
    }
#endif

    return S_OK;
}

AllocatorPimpl::~AllocatorPimpl()
{
#ifdef __ID3D12Device8_INTERFACE_DEFINED__
    SAFE_RELEASE(m_Device8);
#endif
#ifdef __ID3D12Device4_INTERFACE_DEFINED__
    SAFE_RELEASE(m_Device4);
#endif
#if D3D12MA_DXGI_1_4
    SAFE_RELEASE(m_Adapter3);
#endif
    SAFE_RELEASE(m_Adapter);
    SAFE_RELEASE(m_Device);

    for(UINT i = DEFAULT_POOL_MAX_COUNT; i--; )
    {
        D3D12MA_DELETE(GetAllocs(), m_BlockVectors[i]);
    }

    for(UINT i = HEAP_TYPE_COUNT; i--; )
    {
        if(!m_Pools[i].IsEmpty())
        {
            D3D12MA_ASSERT(0 && "Unfreed pools found!");
        }
    }

    for(UINT i = HEAP_TYPE_COUNT; i--; )
    {
        if(!m_CommittedAllocations[i].IsEmpty())
        {
            D3D12MA_ASSERT(0 && "Unfreed committed allocations found!");
        }
    }
}

bool AllocatorPimpl::HeapFlagsFulfillResourceHeapTier(D3D12_HEAP_FLAGS flags) const
{
    if(SupportsResourceHeapTier2())
    {
        return true;
    }
    else
    {
        const bool allowBuffers         = (flags & D3D12_HEAP_FLAG_DENY_BUFFERS           ) == 0;
        const bool allowRtDsTextures    = (flags & D3D12_HEAP_FLAG_DENY_RT_DS_TEXTURES    ) == 0;
        const bool allowNonRtDsTextures = (flags & D3D12_HEAP_FLAG_DENY_NON_RT_DS_TEXTURES) == 0;
        const uint8_t allowedGroupCount = (allowBuffers ? 1 : 0) + (allowRtDsTextures ? 1 : 0) + (allowNonRtDsTextures ? 1 : 0);
        return allowedGroupCount == 1;
    }
}

HRESULT AllocatorPimpl::CreateResource(
    const ALLOCATION_DESC* pAllocDesc,
    const D3D12_RESOURCE_DESC* pResourceDesc,
    D3D12_RESOURCE_STATES InitialResourceState,
    const D3D12_CLEAR_VALUE *pOptimizedClearValue,
    Allocation** ppAllocation,
    REFIID riidResource,
    void** ppvResource)
{
    *ppAllocation = NULL;
    if(ppvResource)
    {
        *ppvResource = NULL;
    }

    if(pAllocDesc->CustomPool == NULL && !IsHeapTypeValid(pAllocDesc->HeapType))
    {
        return E_INVALIDARG;
    }

    ALLOCATION_DESC finalAllocDesc = *pAllocDesc;

    D3D12_RESOURCE_DESC finalResourceDesc = *pResourceDesc;
    D3D12_RESOURCE_ALLOCATION_INFO resAllocInfo = GetResourceAllocationInfo(finalResourceDesc);
    resAllocInfo.Alignment = D3D12MA_MAX<UINT64>(resAllocInfo.Alignment, D3D12MA_DEBUG_ALIGNMENT);
    D3D12MA_ASSERT(IsPow2(resAllocInfo.Alignment));
    D3D12MA_ASSERT(resAllocInfo.SizeInBytes > 0);

    if(pAllocDesc->CustomPool != NULL)
    {
        if((finalAllocDesc.Flags & ALLOCATION_FLAG_COMMITTED) != 0)
        {
            return E_INVALIDARG;
        }

        BlockVector* blockVector = pAllocDesc->CustomPool->m_Pimpl->GetBlockVector();
        D3D12MA_ASSERT(blockVector);
        return blockVector->CreateResource(
            resAllocInfo.SizeInBytes,
            resAllocInfo.Alignment,
            finalAllocDesc,
            finalResourceDesc,
            InitialResourceState,
            pOptimizedClearValue,
            ppAllocation,
            riidResource,
            ppvResource);
    }
    else
    {
        const UINT defaultPoolIndex = CalcDefaultPoolIndex(*pAllocDesc, finalResourceDesc);
        const bool requireCommittedMemory = defaultPoolIndex == UINT32_MAX;
        if(requireCommittedMemory)
        {
            return AllocateCommittedResource(
                &finalAllocDesc,
                &finalResourceDesc,
                resAllocInfo,
                InitialResourceState,
                pOptimizedClearValue,
                ppAllocation,
                riidResource,
                ppvResource);
        }

        BlockVector* const blockVector = m_BlockVectors[defaultPoolIndex];
        D3D12MA_ASSERT(blockVector);

        const UINT64 preferredBlockSize = blockVector->GetPreferredBlockSize();
        bool preferCommittedMemory =
            m_AlwaysCommitted ||
            PrefersCommittedAllocation(finalResourceDesc) ||
            // Heuristics: Allocate committed memory if requested size if greater than half of preferred block size.
            resAllocInfo.SizeInBytes > preferredBlockSize / 2;
        if(preferCommittedMemory &&
            (finalAllocDesc.Flags & ALLOCATION_FLAG_NEVER_ALLOCATE) == 0)
        {
            finalAllocDesc.Flags |= ALLOCATION_FLAG_COMMITTED;
        }

        if((finalAllocDesc.Flags & ALLOCATION_FLAG_COMMITTED) != 0)
        {
            return AllocateCommittedResource(
                &finalAllocDesc,
                &finalResourceDesc,
                resAllocInfo,
                InitialResourceState,
                pOptimizedClearValue,
                ppAllocation,
                riidResource,
                ppvResource);
        }
        else
        {
            HRESULT hr = blockVector->CreateResource(
                resAllocInfo.SizeInBytes,
                resAllocInfo.Alignment,
                finalAllocDesc,
                finalResourceDesc,
                InitialResourceState,
                pOptimizedClearValue,
                ppAllocation,
                riidResource,
                ppvResource);
            if(SUCCEEDED(hr))
            {
                return hr;
            }

            return AllocateCommittedResource(
                &finalAllocDesc,
                &finalResourceDesc,
                resAllocInfo,
                InitialResourceState,
                pOptimizedClearValue,
                ppAllocation,
                riidResource,
                ppvResource);
        }
    }
}

#ifdef __ID3D12Device4_INTERFACE_DEFINED__
HRESULT AllocatorPimpl::CreateResource1(
    const ALLOCATION_DESC* pAllocDesc,
    const D3D12_RESOURCE_DESC* pResourceDesc,
    D3D12_RESOURCE_STATES InitialResourceState,
    const D3D12_CLEAR_VALUE *pOptimizedClearValue,
    ID3D12ProtectedResourceSession *pProtectedSession,
    Allocation** ppAllocation,
    REFIID riidResource,
    void** ppvResource)
{
    // Fall back to old implementation
    if(pProtectedSession == NULL)
    {
        return CreateResource(pAllocDesc, pResourceDesc, InitialResourceState, pOptimizedClearValue, ppAllocation, riidResource, ppvResource);
    }

    *ppAllocation = NULL;
    if(ppvResource)
    {
        *ppvResource = NULL;
    }

    // In current implementation it must always be allocated as committed.
    if(pAllocDesc->CustomPool != NULL ||
        (pAllocDesc->Flags & ALLOCATION_FLAG_NEVER_ALLOCATE) != 0)
    {
        return E_INVALIDARG;
    }

    D3D12_RESOURCE_DESC finalResourceDesc = *pResourceDesc;
    D3D12_RESOURCE_ALLOCATION_INFO resAllocInfo = GetResourceAllocationInfo(finalResourceDesc);
    resAllocInfo.Alignment = D3D12MA_MAX<UINT64>(resAllocInfo.Alignment, D3D12MA_DEBUG_ALIGNMENT);
    D3D12MA_ASSERT(IsPow2(resAllocInfo.Alignment));
    D3D12MA_ASSERT(resAllocInfo.SizeInBytes > 0);

    return AllocateCommittedResource1(
        pAllocDesc,
        &finalResourceDesc,
        resAllocInfo,
        InitialResourceState,
        pOptimizedClearValue,
        pProtectedSession,
        ppAllocation,
        riidResource,
        ppvResource);
}
#endif // #ifdef __ID3D12Device4_INTERFACE_DEFINED__

#ifdef __ID3D12Device8_INTERFACE_DEFINED__
HRESULT AllocatorPimpl::CreateResource2(
    const ALLOCATION_DESC* pAllocDesc,
    const D3D12_RESOURCE_DESC1* pResourceDesc,
    D3D12_RESOURCE_STATES InitialResourceState,
    const D3D12_CLEAR_VALUE *pOptimizedClearValue,
    ID3D12ProtectedResourceSession *pProtectedSession,
    Allocation** ppAllocation,
    REFIID riidResource,
    void** ppvResource)
{
    *ppAllocation = NULL;
    if(ppvResource)
    {
        *ppvResource = NULL;
    }

    if(m_Device8 == NULL)
    {
        return E_NOINTERFACE;
    }

    if(pAllocDesc->CustomPool == NULL && !IsHeapTypeValid(pAllocDesc->HeapType))
    {
        return E_INVALIDARG;
    }

    ALLOCATION_DESC finalAllocDesc = *pAllocDesc;

    D3D12_RESOURCE_DESC1 finalResourceDesc = *pResourceDesc;
    D3D12_RESOURCE_ALLOCATION_INFO resAllocInfo = GetResourceAllocationInfo(finalResourceDesc);
    resAllocInfo.Alignment = D3D12MA_MAX<UINT64>(resAllocInfo.Alignment, D3D12MA_DEBUG_ALIGNMENT);
    D3D12MA_ASSERT(IsPow2(resAllocInfo.Alignment));
    D3D12MA_ASSERT(resAllocInfo.SizeInBytes > 0);

    bool requireCommittedMemory = pProtectedSession != NULL || (finalAllocDesc.Flags & ALLOCATION_FLAG_COMMITTED) != 0;

    if(pAllocDesc->CustomPool != NULL)
    {
        if(requireCommittedMemory)
        {
            return E_INVALIDARG;
        }

        BlockVector* blockVector = pAllocDesc->CustomPool->m_Pimpl->GetBlockVector();
        D3D12MA_ASSERT(blockVector);
        return blockVector->CreateResource2(
            resAllocInfo.SizeInBytes,
            resAllocInfo.Alignment,
            finalAllocDesc,
            finalResourceDesc,
            InitialResourceState,
            pOptimizedClearValue,
            pProtectedSession,
            ppAllocation,
            riidResource,
            ppvResource);
    }
    else
    {
        const UINT defaultPoolIndex = CalcDefaultPoolIndex(*pAllocDesc, finalResourceDesc);
        requireCommittedMemory = requireCommittedMemory || defaultPoolIndex == UINT32_MAX;
        if(requireCommittedMemory)
        {
            return AllocateCommittedResource2(
                &finalAllocDesc,
                &finalResourceDesc,
                resAllocInfo,
                InitialResourceState,
                pOptimizedClearValue,
                pProtectedSession,
                ppAllocation,
                riidResource,
                ppvResource);
        }

        BlockVector* const blockVector = m_BlockVectors[defaultPoolIndex];
        D3D12MA_ASSERT(blockVector);

        const UINT64 preferredBlockSize = blockVector->GetPreferredBlockSize();
        bool preferCommittedMemory =
            m_AlwaysCommitted ||
            PrefersCommittedAllocation(finalResourceDesc) ||
            // Heuristics: Allocate committed memory if requested size if greater than half of preferred block size.
            resAllocInfo.SizeInBytes > preferredBlockSize / 2;
        if(preferCommittedMemory &&
            (finalAllocDesc.Flags & ALLOCATION_FLAG_NEVER_ALLOCATE) == 0)
        {
            finalAllocDesc.Flags |= ALLOCATION_FLAG_COMMITTED;
        }

        if((finalAllocDesc.Flags & ALLOCATION_FLAG_COMMITTED) != 0)
        {
            return AllocateCommittedResource2(
                &finalAllocDesc,
                &finalResourceDesc,
                resAllocInfo,
                InitialResourceState,
                pOptimizedClearValue,
                pProtectedSession,
                ppAllocation,
                riidResource,
                ppvResource);
        }
        else
        {
            HRESULT hr = blockVector->CreateResource2(
                resAllocInfo.SizeInBytes,
                resAllocInfo.Alignment,
                finalAllocDesc,
                finalResourceDesc,
                InitialResourceState,
                pOptimizedClearValue,
                pProtectedSession,
                ppAllocation,
                riidResource,
                ppvResource);
            if(SUCCEEDED(hr))
            {
                return hr;
            }

            return AllocateCommittedResource2(
                &finalAllocDesc,
                &finalResourceDesc,
                resAllocInfo,
                InitialResourceState,
                pOptimizedClearValue,
                pProtectedSession,
                ppAllocation,
                riidResource,
                ppvResource);
        }
    }
}
#endif // #ifdef __ID3D12Device8_INTERFACE_DEFINED__

HRESULT AllocatorPimpl::AllocateMemory(
    const ALLOCATION_DESC* pAllocDesc,
    const D3D12_RESOURCE_ALLOCATION_INFO* pAllocInfo,
    Allocation** ppAllocation)
{
    *ppAllocation = NULL;

    if(pAllocDesc->CustomPool != NULL)
    {
        BlockVector* const blockVector = pAllocDesc->CustomPool->m_Pimpl->GetBlockVector();
        D3D12MA_ASSERT(blockVector);
        return blockVector->Allocate(
            pAllocInfo->SizeInBytes,
            pAllocInfo->Alignment,
            *pAllocDesc,
            1,
            (Allocation**)ppAllocation);
    }
    else
    {
        if(!IsHeapTypeValid(pAllocDesc->HeapType))
        {
            return E_INVALIDARG;
        }

        ALLOCATION_DESC finalAllocDesc = *pAllocDesc;

        const UINT defaultPoolIndex = CalcDefaultPoolIndex(*pAllocDesc);
        bool requireCommittedMemory = (defaultPoolIndex == UINT32_MAX);
        if(requireCommittedMemory)
        {
            return AllocateHeap(&finalAllocDesc, *pAllocInfo, ppAllocation);
        }

        BlockVector* blockVector = m_BlockVectors[defaultPoolIndex];
        D3D12MA_ASSERT(blockVector);

        const UINT64 preferredBlockSize = blockVector->GetPreferredBlockSize();
        const bool preferCommittedMemory =
            m_AlwaysCommitted ||
            // Heuristics: Allocate committed memory if requested size if greater than half of preferred block size.
            pAllocInfo->SizeInBytes > preferredBlockSize / 2;
        if(preferCommittedMemory &&
            (finalAllocDesc.Flags & ALLOCATION_FLAG_NEVER_ALLOCATE) == 0)
        {
            finalAllocDesc.Flags |= ALLOCATION_FLAG_COMMITTED;
        }

        if((finalAllocDesc.Flags & ALLOCATION_FLAG_COMMITTED) != 0)
        {
            return AllocateHeap(&finalAllocDesc, *pAllocInfo, ppAllocation);
        }
        else
        {
            HRESULT hr = blockVector->Allocate(
                pAllocInfo->SizeInBytes,
                pAllocInfo->Alignment,
                finalAllocDesc,
                1,
                (Allocation**)ppAllocation);
            if(SUCCEEDED(hr))
            {
                return hr;
            }

            return AllocateHeap(&finalAllocDesc, *pAllocInfo, ppAllocation);
        }
    }
}

#ifdef __ID3D12Device4_INTERFACE_DEFINED__
HRESULT AllocatorPimpl::AllocateMemory1(
    const ALLOCATION_DESC* pAllocDesc,
    const D3D12_RESOURCE_ALLOCATION_INFO* pAllocInfo,
    ID3D12ProtectedResourceSession *pProtectedSession,
    Allocation** ppAllocation)
{
    // Fall back to old implementation
    if(pProtectedSession == NULL)
    {
        return AllocateMemory(pAllocDesc, pAllocInfo, ppAllocation);
    }

    *ppAllocation = NULL;

    // In current implementation it must always be allocated as separate CreateHeap1.
    if(pAllocDesc->CustomPool != NULL ||
        (pAllocDesc->Flags & ALLOCATION_FLAG_NEVER_ALLOCATE) != 0)
    {
        return E_INVALIDARG;
    }

    if(!IsHeapTypeValid(pAllocDesc->HeapType))
    {
        return E_INVALIDARG;
    }

    return AllocateHeap1(pAllocDesc, *pAllocInfo, pProtectedSession, ppAllocation);
}
#endif // #ifdef __ID3D12Device4_INTERFACE_DEFINED__

HRESULT AllocatorPimpl::CreateAliasingResource(
    Allocation* pAllocation,
    UINT64 AllocationLocalOffset,
    const D3D12_RESOURCE_DESC* pResourceDesc,
    D3D12_RESOURCE_STATES InitialResourceState,
    const D3D12_CLEAR_VALUE *pOptimizedClearValue,
    REFIID riidResource,
    void** ppvResource)
{
    *ppvResource = NULL;

    D3D12_RESOURCE_DESC resourceDesc2 = *pResourceDesc;
    D3D12_RESOURCE_ALLOCATION_INFO resAllocInfo = GetResourceAllocationInfo(resourceDesc2);
    resAllocInfo.Alignment = D3D12MA_MAX<UINT64>(resAllocInfo.Alignment, D3D12MA_DEBUG_ALIGNMENT);
    D3D12MA_ASSERT(IsPow2(resAllocInfo.Alignment));
    D3D12MA_ASSERT(resAllocInfo.SizeInBytes > 0);

    ID3D12Heap* const existingHeap = pAllocation->GetHeap();
    const UINT64 existingOffset = pAllocation->GetOffset();
    const UINT64 existingSize = pAllocation->GetSize();
    const UINT64 newOffset = existingOffset + AllocationLocalOffset;

    if(existingHeap == NULL ||
        AllocationLocalOffset + resAllocInfo.SizeInBytes > existingSize ||
        newOffset % resAllocInfo.Alignment != 0)
    {
        return E_INVALIDARG;
    }

    return m_Device->CreatePlacedResource(
        existingHeap,
        newOffset,
        &resourceDesc2,
        InitialResourceState,
        pOptimizedClearValue,
        riidResource,
        ppvResource);
}

HRESULT AllocatorPimpl::SetDefaultHeapMinBytes(
    D3D12_HEAP_TYPE heapType,
    D3D12_HEAP_FLAGS heapFlags,
    UINT64 minBytes)
{
    if(!IsHeapTypeValid(heapType))
    {
        D3D12MA_ASSERT(0 && "Allocator::SetDefaultHeapMinBytes: Invalid heapType passed.");
        return E_INVALIDARG;
    }

    if(SupportsResourceHeapTier2())
    {
        if(heapFlags != D3D12_HEAP_FLAG_ALLOW_ALL_BUFFERS_AND_TEXTURES &&
            heapFlags != D3D12_HEAP_FLAG_ALLOW_ONLY_BUFFERS &&
            heapFlags != D3D12_HEAP_FLAG_ALLOW_ONLY_NON_RT_DS_TEXTURES &&
            heapFlags != D3D12_HEAP_FLAG_ALLOW_ONLY_RT_DS_TEXTURES)
        {
            D3D12MA_ASSERT(0 && "Allocator::SetDefaultHeapMinBytes: Invalid heapFlags passed.");
            return E_INVALIDARG;
        }

        UINT64 newMinBytes = UINT64_MAX;

        {
            MutexLockWrite lock(m_DefaultPoolMinBytesMutex, m_UseMutex);

            if(heapFlags == D3D12_HEAP_FLAG_ALLOW_ALL_BUFFERS_AND_TEXTURES)
            {
                m_DefaultPoolHeapTypeMinBytes[HeapTypeToIndex(heapType)] = minBytes;
                newMinBytes = minBytes;
            }
            else
            {
                const UINT defaultPoolTier1Index = CalcDefaultPoolIndex(heapType, heapFlags, false);
                m_DefaultPoolTier1MinBytes[defaultPoolTier1Index] = minBytes;

                newMinBytes = m_DefaultPoolHeapTypeMinBytes[HeapTypeToIndex(heapType)];
                if(newMinBytes == UINT64_MAX)
                {
                    newMinBytes = m_DefaultPoolTier1MinBytes[CalcDefaultPoolIndex(heapType, D3D12_HEAP_FLAG_ALLOW_ONLY_BUFFERS, false)] +
                        m_DefaultPoolTier1MinBytes[CalcDefaultPoolIndex(heapType, D3D12_HEAP_FLAG_ALLOW_ONLY_NON_RT_DS_TEXTURES, false)] +
                        m_DefaultPoolTier1MinBytes[CalcDefaultPoolIndex(heapType, D3D12_HEAP_FLAG_ALLOW_ONLY_RT_DS_TEXTURES, false)];
                }
            }
        }

        const UINT defaultPoolIndex = CalcDefaultPoolIndex(heapType, D3D12_HEAP_FLAG_ALLOW_ALL_BUFFERS_AND_TEXTURES);
        return m_BlockVectors[defaultPoolIndex]->SetMinBytes(newMinBytes);
    }
    else
    {
        if(heapFlags != D3D12_HEAP_FLAG_ALLOW_ONLY_BUFFERS &&
            heapFlags != D3D12_HEAP_FLAG_ALLOW_ONLY_NON_RT_DS_TEXTURES &&
            heapFlags != D3D12_HEAP_FLAG_ALLOW_ONLY_RT_DS_TEXTURES)
        {
            D3D12MA_ASSERT(0 && "Allocator::SetDefaultHeapMinBytes: Invalid heapFlags passed.");
            return E_INVALIDARG;
        }
        
        const UINT defaultPoolIndex = CalcDefaultPoolIndex(heapType, heapFlags);
        return m_BlockVectors[defaultPoolIndex]->SetMinBytes(minBytes);
    }
}

template<typename D3D12_RESOURCE_DESC_T>
bool AllocatorPimpl::PrefersCommittedAllocation(const D3D12_RESOURCE_DESC_T& resourceDesc)
{
    // Intentional. It may change in the future.
    return false;
}

HRESULT AllocatorPimpl::AllocateCommittedResource(
    const ALLOCATION_DESC* pAllocDesc,
    const D3D12_RESOURCE_DESC* pResourceDesc,
    const D3D12_RESOURCE_ALLOCATION_INFO& resAllocInfo,
    D3D12_RESOURCE_STATES InitialResourceState,
    const D3D12_CLEAR_VALUE *pOptimizedClearValue,
    Allocation** ppAllocation,
    REFIID riidResource,
    void** ppvResource)
{
    if((pAllocDesc->Flags & ALLOCATION_FLAG_NEVER_ALLOCATE) != 0)
    {
        return E_OUTOFMEMORY;
    }

    if((pAllocDesc->Flags & ALLOCATION_FLAG_WITHIN_BUDGET) != 0 &&
        !NewAllocationWithinBudget(pAllocDesc->HeapType, resAllocInfo.SizeInBytes))
    {
        return E_OUTOFMEMORY;
    }

    D3D12_HEAP_PROPERTIES heapProps = {};
    heapProps.Type = pAllocDesc->HeapType;

    const D3D12_HEAP_FLAGS heapFlags = pAllocDesc->ExtraHeapFlags;

    ID3D12Resource* res = NULL;
    HRESULT hr = m_Device->CreateCommittedResource(
        &heapProps, heapFlags, pResourceDesc, InitialResourceState,
        pOptimizedClearValue, IID_PPV_ARGS(&res));
    if(SUCCEEDED(hr))
    {
        if(ppvResource != NULL)
        {
            hr = res->QueryInterface(riidResource, ppvResource);
        }
        if(SUCCEEDED(hr))
        {
            const BOOL wasZeroInitialized = TRUE;
            Allocation* alloc = m_AllocationObjectAllocator.Allocate(this, resAllocInfo.SizeInBytes, wasZeroInitialized);
            alloc->InitCommitted(pAllocDesc->HeapType);
            alloc->SetResource(res, pResourceDesc);

            *ppAllocation = alloc;

            RegisterCommittedAllocation(*ppAllocation, pAllocDesc->HeapType);

            const UINT heapTypeIndex = HeapTypeToIndex(pAllocDesc->HeapType);
            m_Budget.AddAllocation(heapTypeIndex, resAllocInfo.SizeInBytes);
            m_Budget.m_BlockBytes[heapTypeIndex] += resAllocInfo.SizeInBytes;
        }
        else
        {
            res->Release();
        }
    }
    return hr;
}

#ifdef __ID3D12Device4_INTERFACE_DEFINED__
HRESULT AllocatorPimpl::AllocateCommittedResource1(
    const ALLOCATION_DESC* pAllocDesc,
    const D3D12_RESOURCE_DESC* pResourceDesc,
    const D3D12_RESOURCE_ALLOCATION_INFO& resAllocInfo,
    D3D12_RESOURCE_STATES InitialResourceState,
    const D3D12_CLEAR_VALUE *pOptimizedClearValue,
    ID3D12ProtectedResourceSession *pProtectedSession,
    Allocation** ppAllocation,
    REFIID riidResource,
    void** ppvResource)
{
    if(m_Device4 == NULL)
    {
        return E_NOINTERFACE;
    }

    if((pAllocDesc->Flags & ALLOCATION_FLAG_NEVER_ALLOCATE) != 0)
    {
        return E_OUTOFMEMORY;
    }

    if((pAllocDesc->Flags & ALLOCATION_FLAG_WITHIN_BUDGET) != 0 &&
        !NewAllocationWithinBudget(pAllocDesc->HeapType, resAllocInfo.SizeInBytes))
    {
        return E_OUTOFMEMORY;
    }

    D3D12_HEAP_PROPERTIES heapProps = {};
    heapProps.Type = pAllocDesc->HeapType;

    const D3D12_HEAP_FLAGS heapFlags = pAllocDesc->ExtraHeapFlags;

    ID3D12Resource* res = NULL;
    HRESULT hr = m_Device4->CreateCommittedResource1(
        &heapProps, heapFlags, pResourceDesc, InitialResourceState,
        pOptimizedClearValue, pProtectedSession, IID_PPV_ARGS(&res));
    if(SUCCEEDED(hr))
    {
        if(ppvResource != NULL)
        {
            hr = res->QueryInterface(riidResource, ppvResource);
        }
        if(SUCCEEDED(hr))
        {
            const BOOL wasZeroInitialized = TRUE;
            Allocation* alloc = m_AllocationObjectAllocator.Allocate(this, resAllocInfo.SizeInBytes, wasZeroInitialized);
            alloc->InitCommitted(pAllocDesc->HeapType);
            alloc->SetResource(res, pResourceDesc);

            *ppAllocation = alloc;

            RegisterCommittedAllocation(*ppAllocation, pAllocDesc->HeapType);

            const UINT heapTypeIndex = HeapTypeToIndex(pAllocDesc->HeapType);
            m_Budget.AddAllocation(heapTypeIndex, resAllocInfo.SizeInBytes);
            m_Budget.m_BlockBytes[heapTypeIndex] += resAllocInfo.SizeInBytes;
        }
        else
        {
            res->Release();
        }
    }
    return hr;
}
#endif // #ifdef __ID3D12Device4_INTERFACE_DEFINED__

#ifdef __ID3D12Device8_INTERFACE_DEFINED__
HRESULT AllocatorPimpl::AllocateCommittedResource2(
    const ALLOCATION_DESC* pAllocDesc,
    const D3D12_RESOURCE_DESC1* pResourceDesc,
    const D3D12_RESOURCE_ALLOCATION_INFO& resAllocInfo,
    D3D12_RESOURCE_STATES InitialResourceState,
    const D3D12_CLEAR_VALUE *pOptimizedClearValue,
    ID3D12ProtectedResourceSession *pProtectedSession,
    Allocation** ppAllocation,
    REFIID riidResource,
    void** ppvResource)
{
    if(m_Device8 == NULL)
    {
        return E_NOINTERFACE;
    }

    if((pAllocDesc->Flags & ALLOCATION_FLAG_NEVER_ALLOCATE) != 0)
    {
        return E_OUTOFMEMORY;
    }

    if((pAllocDesc->Flags & ALLOCATION_FLAG_WITHIN_BUDGET) != 0 &&
        !NewAllocationWithinBudget(pAllocDesc->HeapType, resAllocInfo.SizeInBytes))
    {
        return E_OUTOFMEMORY;
    }

    D3D12_HEAP_PROPERTIES heapProps = {};
    heapProps.Type = pAllocDesc->HeapType;

    const D3D12_HEAP_FLAGS heapFlags = pAllocDesc->ExtraHeapFlags;

    ID3D12Resource* res = NULL;
    HRESULT hr = m_Device8->CreateCommittedResource2(
        &heapProps, heapFlags, pResourceDesc, InitialResourceState,
        pOptimizedClearValue, pProtectedSession, IID_PPV_ARGS(&res));
    if(SUCCEEDED(hr))
    {
        if(ppvResource != NULL)
        {
            hr = res->QueryInterface(riidResource, ppvResource);
        }
        if(SUCCEEDED(hr))
        {
            const BOOL wasZeroInitialized = TRUE;
            Allocation* alloc = m_AllocationObjectAllocator.Allocate(this, resAllocInfo.SizeInBytes, wasZeroInitialized);
            alloc->InitCommitted(pAllocDesc->HeapType);
            alloc->SetResource(res, pResourceDesc);

            *ppAllocation = alloc;

            RegisterCommittedAllocation(*ppAllocation, pAllocDesc->HeapType);

            const UINT heapTypeIndex = HeapTypeToIndex(pAllocDesc->HeapType);
            m_Budget.AddAllocation(heapTypeIndex, resAllocInfo.SizeInBytes);
            m_Budget.m_BlockBytes[heapTypeIndex] += resAllocInfo.SizeInBytes;
        }
        else
        {
            res->Release();
        }
    }
    return hr;
}
#endif // #ifdef __ID3D12Device8_INTERFACE_DEFINED__

HRESULT AllocatorPimpl::AllocateHeap(
    const ALLOCATION_DESC* pAllocDesc,
    const D3D12_RESOURCE_ALLOCATION_INFO& allocInfo,
    Allocation** ppAllocation)
{
    *ppAllocation = nullptr;

    if((pAllocDesc->Flags & ALLOCATION_FLAG_NEVER_ALLOCATE) != 0)
    {
        return E_OUTOFMEMORY;
    }

    if((pAllocDesc->Flags & ALLOCATION_FLAG_WITHIN_BUDGET) != 0 &&
        !NewAllocationWithinBudget(pAllocDesc->HeapType, allocInfo.SizeInBytes))
    {
        return E_OUTOFMEMORY;
    }

    D3D12_HEAP_FLAGS heapFlags = pAllocDesc->ExtraHeapFlags;

    D3D12_HEAP_DESC heapDesc = {};
    heapDesc.SizeInBytes = allocInfo.SizeInBytes;
    heapDesc.Properties.Type = pAllocDesc->HeapType;
    heapDesc.Alignment = allocInfo.Alignment;
    heapDesc.Flags = heapFlags;

    ID3D12Heap* heap = nullptr;
    HRESULT hr = m_Device->CreateHeap(&heapDesc, __uuidof(*heap), (void**)&heap);
    if(SUCCEEDED(hr))
    {
        const BOOL wasZeroInitialized = TRUE;
        (*ppAllocation) = m_AllocationObjectAllocator.Allocate(this, allocInfo.SizeInBytes, wasZeroInitialized);
        (*ppAllocation)->InitHeap(pAllocDesc->HeapType, heap);
        RegisterCommittedAllocation(*ppAllocation, pAllocDesc->HeapType);

        const UINT heapTypeIndex = HeapTypeToIndex(pAllocDesc->HeapType);
        m_Budget.AddAllocation(heapTypeIndex, allocInfo.SizeInBytes);
        m_Budget.m_BlockBytes[heapTypeIndex] += allocInfo.SizeInBytes;
    }
    return hr;
}

#ifdef __ID3D12Device4_INTERFACE_DEFINED__
HRESULT AllocatorPimpl::AllocateHeap1(
    const ALLOCATION_DESC* pAllocDesc,
    const D3D12_RESOURCE_ALLOCATION_INFO& allocInfo,
    ID3D12ProtectedResourceSession *pProtectedSession,
    Allocation** ppAllocation)
{
    *ppAllocation = nullptr;

    if(m_Device4 == NULL)
    {
        return E_NOINTERFACE;
    }

    if((pAllocDesc->Flags & ALLOCATION_FLAG_NEVER_ALLOCATE) != 0)
    {
        return E_OUTOFMEMORY;
    }

    if((pAllocDesc->Flags & ALLOCATION_FLAG_WITHIN_BUDGET) != 0 &&
        !NewAllocationWithinBudget(pAllocDesc->HeapType, allocInfo.SizeInBytes))
    {
        return E_OUTOFMEMORY;
    }

    D3D12_HEAP_FLAGS heapFlags = pAllocDesc->ExtraHeapFlags;

    D3D12_HEAP_DESC heapDesc = {};
    heapDesc.SizeInBytes = allocInfo.SizeInBytes;
    heapDesc.Properties.Type = pAllocDesc->HeapType;
    heapDesc.Alignment = allocInfo.Alignment;
    heapDesc.Flags = heapFlags;

    ID3D12Heap* heap = nullptr;
    HRESULT hr = m_Device4->CreateHeap1(&heapDesc, pProtectedSession, __uuidof(*heap), (void**)&heap);
    if(SUCCEEDED(hr))
    {
        const BOOL wasZeroInitialized = TRUE;
        (*ppAllocation) = m_AllocationObjectAllocator.Allocate(this, allocInfo.SizeInBytes, wasZeroInitialized);
        (*ppAllocation)->InitHeap(pAllocDesc->HeapType, heap);
        RegisterCommittedAllocation(*ppAllocation, pAllocDesc->HeapType);

        const UINT heapTypeIndex = HeapTypeToIndex(pAllocDesc->HeapType);
        m_Budget.AddAllocation(heapTypeIndex, allocInfo.SizeInBytes);
        m_Budget.m_BlockBytes[heapTypeIndex] += allocInfo.SizeInBytes;
    }
    return hr;
}
#endif // #ifdef __ID3D12Device4_INTERFACE_DEFINED__

UINT AllocatorPimpl::CalcDefaultPoolCount() const
{
    if(SupportsResourceHeapTier2())
    {
        return 3;
    }
    else
    {
        return 9;
    }
}

template<typename D3D12_RESOURCE_DESC_T>
UINT AllocatorPimpl::CalcDefaultPoolIndex(const ALLOCATION_DESC& allocDesc, const D3D12_RESOURCE_DESC_T& resourceDesc) const
{
    const D3D12_HEAP_FLAGS extraHeapFlags = allocDesc.ExtraHeapFlags & ~GetExtraHeapFlagsToIgnore();
    if(extraHeapFlags != 0)
    {
        return UINT32_MAX;
    }

    UINT poolIndex = UINT_MAX;
    switch(allocDesc.HeapType)
    {
    case D3D12_HEAP_TYPE_DEFAULT:  poolIndex = 0; break;
    case D3D12_HEAP_TYPE_UPLOAD:   poolIndex = 1; break;
    case D3D12_HEAP_TYPE_READBACK: poolIndex = 2; break;
    default: D3D12MA_ASSERT(0);
    }

    if(!SupportsResourceHeapTier2())
    {
        poolIndex *= 3;
        if(resourceDesc.Dimension != D3D12_RESOURCE_DIMENSION_BUFFER)
        {
            ++poolIndex;
            const bool isRenderTargetOrDepthStencil =
                (resourceDesc.Flags & (D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET | D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL)) != 0;
            if(isRenderTargetOrDepthStencil)
            {
                ++poolIndex;
            }
        }
    }

    return poolIndex;
}

UINT AllocatorPimpl::CalcDefaultPoolIndex(D3D12_HEAP_TYPE heapType, D3D12_HEAP_FLAGS heapFlags, bool supportsResourceHeapTier2)
{
    const D3D12_HEAP_FLAGS extraHeapFlags = heapFlags & ~GetExtraHeapFlagsToIgnore();
    if(extraHeapFlags != 0)
    {
        return UINT32_MAX;
    }

    UINT poolIndex = UINT_MAX;
    switch(heapType)
    {
    case D3D12_HEAP_TYPE_DEFAULT:  poolIndex = 0; break;
    case D3D12_HEAP_TYPE_UPLOAD:   poolIndex = 1; break;
    case D3D12_HEAP_TYPE_READBACK: poolIndex = 2; break;
    default: D3D12MA_ASSERT(0);
    }

    if(!supportsResourceHeapTier2)
    {
        poolIndex *= 3;

        const bool allowBuffers = (heapFlags & D3D12_HEAP_FLAG_DENY_BUFFERS) == 0;
        const bool allowRtDsTextures = (heapFlags & D3D12_HEAP_FLAG_DENY_RT_DS_TEXTURES) == 0;
        const bool allowNonRtDsTextures = (heapFlags & D3D12_HEAP_FLAG_DENY_NON_RT_DS_TEXTURES) == 0;

        const uint8_t allowedGroupCount = (allowBuffers ? 1 : 0) + (allowRtDsTextures ? 1 : 0) + (allowNonRtDsTextures ? 1 : 0);
        if(allowedGroupCount != 1)
        {
            return UINT32_MAX;
        }

        if(!allowBuffers)
        {
            ++poolIndex;
            if(allowRtDsTextures)
            {
                ++poolIndex;
            }
        }
    }

    return poolIndex;
}

void AllocatorPimpl::CalcDefaultPoolParams(D3D12_HEAP_TYPE& outHeapType, D3D12_HEAP_FLAGS& outHeapFlags, UINT index) const
{
    outHeapType = D3D12_HEAP_TYPE_DEFAULT;
    outHeapFlags = D3D12_HEAP_FLAG_NONE;

    if(!SupportsResourceHeapTier2())
    {
        switch(index % 3)
        {
        case 0:
            outHeapFlags = D3D12_HEAP_FLAG_DENY_RT_DS_TEXTURES | D3D12_HEAP_FLAG_DENY_NON_RT_DS_TEXTURES;
            break;
        case 1:
            outHeapFlags = D3D12_HEAP_FLAG_DENY_BUFFERS | D3D12_HEAP_FLAG_DENY_RT_DS_TEXTURES;
            break;
        case 2:
            outHeapFlags = D3D12_HEAP_FLAG_DENY_BUFFERS | D3D12_HEAP_FLAG_DENY_NON_RT_DS_TEXTURES;
            break;
        }

        index /= 3;
    }

    switch(index)
    {
    case 0:
        outHeapType = D3D12_HEAP_TYPE_DEFAULT;
        break;
    case 1:
        outHeapType = D3D12_HEAP_TYPE_UPLOAD;
        break;
    case 2:
        outHeapType = D3D12_HEAP_TYPE_READBACK;
        break;
    default:
        D3D12MA_ASSERT(0);
    }
}

void AllocatorPimpl::RegisterCommittedAllocation(Allocation* alloc, D3D12_HEAP_TYPE heapType)
{
    const UINT heapTypeIndex = HeapTypeToIndex(heapType);

    MutexLockWrite lock(m_CommittedAllocationsMutex[heapTypeIndex], m_UseMutex);
    CommittedAllocationList& committedAllocations = m_CommittedAllocations[heapTypeIndex];
    committedAllocations.PushBack(alloc);
}

void AllocatorPimpl::UnregisterCommittedAllocation(Allocation* alloc, D3D12_HEAP_TYPE heapType)
{
    const UINT heapTypeIndex = HeapTypeToIndex(heapType);
    
    MutexLockWrite lock(m_CommittedAllocationsMutex[heapTypeIndex], m_UseMutex);
    CommittedAllocationList& committedAllocations = m_CommittedAllocations[heapTypeIndex];
    committedAllocations.Remove(alloc);
}

void AllocatorPimpl::RegisterPool(Pool* pool, D3D12_HEAP_TYPE heapType)
{
    const UINT heapTypeIndex = HeapTypeToIndex(heapType);

    MutexLockWrite lock(m_PoolsMutex[heapTypeIndex], m_UseMutex);
    m_Pools[heapTypeIndex].PushBack(pool->m_Pimpl);
}

void AllocatorPimpl::UnregisterPool(Pool* pool, D3D12_HEAP_TYPE heapType)
{
    const UINT heapTypeIndex = HeapTypeToIndex(heapType);

    MutexLockWrite lock(m_PoolsMutex[heapTypeIndex], m_UseMutex);
    m_Pools[heapTypeIndex].Remove(pool->m_Pimpl);
}

void AllocatorPimpl::FreeCommittedMemory(Allocation* allocation)
{
    D3D12MA_ASSERT(allocation && allocation->m_PackedData.GetType() == Allocation::TYPE_COMMITTED);
    UnregisterCommittedAllocation(allocation, allocation->m_Committed.heapType);

    const UINT64 allocationSize = allocation->GetSize();
    const UINT heapTypeIndex = HeapTypeToIndex(allocation->m_Committed.heapType);
    m_Budget.RemoveAllocation(heapTypeIndex, allocationSize);
    m_Budget.m_BlockBytes[heapTypeIndex] -= allocationSize;
}

void AllocatorPimpl::FreePlacedMemory(Allocation* allocation)
{
    D3D12MA_ASSERT(allocation && allocation->m_PackedData.GetType() == Allocation::TYPE_PLACED);

    NormalBlock* const block = allocation->m_Placed.block;
    D3D12MA_ASSERT(block);
    BlockVector* const blockVector = block->GetBlockVector();
    D3D12MA_ASSERT(blockVector);
    m_Budget.RemoveAllocation(HeapTypeToIndex(block->GetHeapType()), allocation->GetSize());
    blockVector->Free(allocation);
}

void AllocatorPimpl::FreeHeapMemory(Allocation* allocation)
{
    D3D12MA_ASSERT(allocation && allocation->m_PackedData.GetType() == Allocation::TYPE_HEAP);
    UnregisterCommittedAllocation(allocation, allocation->m_Heap.heapType);
    SAFE_RELEASE(allocation->m_Heap.heap);

    const UINT heapTypeIndex = HeapTypeToIndex(allocation->m_Heap.heapType);
    const UINT64 allocationSize = allocation->GetSize();
    m_Budget.m_BlockBytes[heapTypeIndex] -= allocationSize;
    m_Budget.RemoveAllocation(heapTypeIndex, allocationSize);
}

void AllocatorPimpl::SetCurrentFrameIndex(UINT frameIndex)
{
    m_CurrentFrameIndex.store(frameIndex);

#if D3D12MA_DXGI_1_4
    if(m_Adapter3)
    {
        UpdateD3D12Budget();
    }
#endif
}

void AllocatorPimpl::CalculateStats(Stats& outStats)
{
    // Init stats
    ZeroMemory(&outStats, sizeof(outStats));
    outStats.Total.AllocationSizeMin = UINT64_MAX;
    outStats.Total.UnusedRangeSizeMin = UINT64_MAX;
    for(size_t i = 0; i < HEAP_TYPE_COUNT; i++)
    {
        outStats.HeapType[i].AllocationSizeMin = UINT64_MAX;
        outStats.HeapType[i].UnusedRangeSizeMin = UINT64_MAX;
    }

    // Process deafult pools.
    
    if(SupportsResourceHeapTier2())
    {
        for(size_t heapTypeIndex = 0; heapTypeIndex < HEAP_TYPE_COUNT; ++heapTypeIndex)
        {
            BlockVector* const pBlockVector = m_BlockVectors[heapTypeIndex];
            D3D12MA_ASSERT(pBlockVector);
            pBlockVector->AddStats(outStats);
        }
    }
    else
    {
        for(size_t heapTypeIndex = 0; heapTypeIndex < HEAP_TYPE_COUNT; ++heapTypeIndex)
        {
            for(size_t heapSubType = 0; heapSubType < 3; ++heapSubType)
            {
                BlockVector* const pBlockVector = m_BlockVectors[heapTypeIndex * 3 + heapSubType];
                D3D12MA_ASSERT(pBlockVector);
                pBlockVector->AddStats(outStats);
            }
        }
    }

    // Process custom pools
    for(size_t heapTypeIndex = 0; heapTypeIndex < HEAP_TYPE_COUNT; ++heapTypeIndex)
    {
        MutexLockRead lock(m_PoolsMutex[heapTypeIndex], m_UseMutex);
        PoolList& poolList = m_Pools[heapTypeIndex];
        for(PoolPimpl* pool = poolList.Front(); pool != NULL; pool = poolList.GetNext(pool))
        {
            pool->GetBlockVector()->AddStats(outStats);
        }
    }

    // Process committed allocations.
    for(size_t heapTypeIndex = 0; heapTypeIndex < HEAP_TYPE_COUNT; ++heapTypeIndex)
    {
        StatInfo& heapStatInfo = outStats.HeapType[heapTypeIndex];
        MutexLockRead lock(m_CommittedAllocationsMutex[heapTypeIndex], m_UseMutex);
        CommittedAllocationList& committedAllocations = m_CommittedAllocations[heapTypeIndex];
        for(Allocation* alloc = committedAllocations.Front();
            alloc != NULL; alloc = committedAllocations.GetNext(alloc))
        {
            UINT64 size = alloc->GetSize();
            StatInfo statInfo = {};
            statInfo.BlockCount = 1;
            statInfo.AllocationCount = 1;
            statInfo.UnusedRangeCount = 0;
            statInfo.UsedBytes = size;
            statInfo.UnusedBytes = 0;
            statInfo.AllocationSizeMin = size;
            statInfo.AllocationSizeMax = size;
            statInfo.UnusedRangeSizeMin = UINT64_MAX;
            statInfo.UnusedRangeSizeMax = 0;
            AddStatInfo(outStats.Total, statInfo);
            AddStatInfo(heapStatInfo, statInfo);
        }
    }

    // Post process
    PostProcessStatInfo(outStats.Total);
    for(size_t i = 0; i < HEAP_TYPE_COUNT; ++i)
        PostProcessStatInfo(outStats.HeapType[i]);
}

void AllocatorPimpl::GetBudget(Budget* outGpuBudget, Budget* outCpuBudget)
{
    if(outGpuBudget)
    {
        // Taking DEFAULT.
        outGpuBudget->BlockBytes = m_Budget.m_BlockBytes[0];
        outGpuBudget->AllocationBytes = m_Budget.m_AllocationBytes[0];
    }
    if(outCpuBudget)
    {
        // Taking UPLOAD + READBACK.
        outCpuBudget->BlockBytes = m_Budget.m_BlockBytes[1] + m_Budget.m_BlockBytes[2];
        outCpuBudget->AllocationBytes = m_Budget.m_AllocationBytes[1] + m_Budget.m_AllocationBytes[2];
    }

#if D3D12MA_DXGI_1_4
    if(m_Adapter3)
    {
        if(m_Budget.m_OperationsSinceBudgetFetch < 30)
        {
            MutexLockRead lockRead(m_Budget.m_BudgetMutex, m_UseMutex);
            if(outGpuBudget)
            {

                if(m_Budget.m_D3D12UsageLocal + outGpuBudget->BlockBytes > m_Budget.m_BlockBytesAtBudgetFetch[0])
                {
                    outGpuBudget->UsageBytes = m_Budget.m_D3D12UsageLocal +
                        outGpuBudget->BlockBytes - m_Budget.m_BlockBytesAtBudgetFetch[0];
                }
                else
                {
                    outGpuBudget->UsageBytes = 0;
                }
                outGpuBudget->BudgetBytes = m_Budget.m_D3D12BudgetLocal;
            }
            if(outCpuBudget)
            {
                if(m_Budget.m_D3D12UsageNonLocal + outCpuBudget->BlockBytes > m_Budget.m_BlockBytesAtBudgetFetch[1] + m_Budget.m_BlockBytesAtBudgetFetch[2])
                {
                    outCpuBudget->UsageBytes = m_Budget.m_D3D12UsageNonLocal +
                        outCpuBudget->BlockBytes - (m_Budget.m_BlockBytesAtBudgetFetch[1] + m_Budget.m_BlockBytesAtBudgetFetch[2]);
                }
                else
                {
                    outCpuBudget->UsageBytes = 0;
                }
                outCpuBudget->BudgetBytes = m_Budget.m_D3D12BudgetNonLocal;
            }
        }
        else
        {
            UpdateD3D12Budget(); // Outside of mutex lock
            GetBudget(outGpuBudget, outCpuBudget); // Recursion
        }
    }
    else
#endif
    {
        if(outGpuBudget)
        {
            const UINT64 gpuMemorySize = m_AdapterDesc.DedicatedVideoMemory + m_AdapterDesc.DedicatedSystemMemory; // TODO: Is this right?
            outGpuBudget->UsageBytes = outGpuBudget->BlockBytes;
            outGpuBudget->BudgetBytes = gpuMemorySize * 8 / 10; // 80% heuristics.
        }
        if(outCpuBudget)
        {
            const UINT64 cpuMemorySize = m_AdapterDesc.SharedSystemMemory; // TODO: Is this right?
            outCpuBudget->UsageBytes = outCpuBudget->BlockBytes;
            outCpuBudget->BudgetBytes = cpuMemorySize * 8 / 10; // 80% heuristics.
        }
    }
}

void AllocatorPimpl::GetBudgetForHeapType(Budget& outBudget, D3D12_HEAP_TYPE heapType)
{
    switch(heapType)
    {
    case D3D12_HEAP_TYPE_DEFAULT:
        GetBudget(&outBudget, NULL);
        break;
    case D3D12_HEAP_TYPE_UPLOAD:
    case D3D12_HEAP_TYPE_READBACK:
        GetBudget(NULL, &outBudget);
        break;
    default: D3D12MA_ASSERT(0);
    }
}

static void AddStatInfoToJson(JsonWriter& json, const StatInfo& statInfo)
{
    json.BeginObject();
    json.WriteString(L"Blocks");
    json.WriteNumber(statInfo.BlockCount);
    json.WriteString(L"Allocations");
    json.WriteNumber(statInfo.AllocationCount);
    json.WriteString(L"UnusedRanges");
    json.WriteNumber(statInfo.UnusedRangeCount);
    json.WriteString(L"UsedBytes");
    json.WriteNumber(statInfo.UsedBytes);
    json.WriteString(L"UnusedBytes");
    json.WriteNumber(statInfo.UnusedBytes);

    json.WriteString(L"AllocationSize");
    json.BeginObject(true);
    json.WriteString(L"Min");
    json.WriteNumber(statInfo.AllocationSizeMin);
    json.WriteString(L"Avg");
    json.WriteNumber(statInfo.AllocationSizeAvg);
    json.WriteString(L"Max");
    json.WriteNumber(statInfo.AllocationSizeMax);
    json.EndObject();

    json.WriteString(L"UnusedRangeSize");
    json.BeginObject(true);
    json.WriteString(L"Min");
    json.WriteNumber(statInfo.UnusedRangeSizeMin);
    json.WriteString(L"Avg");
    json.WriteNumber(statInfo.UnusedRangeSizeAvg);
    json.WriteString(L"Max");
    json.WriteNumber(statInfo.UnusedRangeSizeMax);
    json.EndObject();

    json.EndObject();
}

void AllocatorPimpl::BuildStatsString(WCHAR** ppStatsString, BOOL DetailedMap)
{
    StringBuilder sb(GetAllocs());
    {
        JsonWriter json(GetAllocs(), sb);

        Budget gpuBudget = {}, cpuBudget = {};
        GetBudget(&gpuBudget, &cpuBudget);

        Stats stats;
        CalculateStats(stats);

        json.BeginObject();
        
        json.WriteString(L"Total");
        AddStatInfoToJson(json, stats.Total);
        for (size_t heapType = 0; heapType < HEAP_TYPE_COUNT; ++heapType)
        {
            json.WriteString(HeapTypeNames[heapType]);
            AddStatInfoToJson(json, stats.HeapType[heapType]);
        }

        json.WriteString(L"Budget");
        json.BeginObject();
        {
            json.WriteString(L"GPU");
            WriteBudgetToJson(json, gpuBudget);
            json.WriteString(L"CPU");
            WriteBudgetToJson(json, cpuBudget);
        }
        json.EndObject();

        if (DetailedMap)
        {
            json.WriteString(L"DetailedMap");
            json.BeginObject();

            json.WriteString(L"DefaultPools");
            json.BeginObject();

            if (SupportsResourceHeapTier2())
            {
                for (size_t heapType = 0; heapType < HEAP_TYPE_COUNT; ++heapType)
                {
                    json.WriteString(HeapTypeNames[heapType]);
                    json.BeginObject();

                    json.WriteString(L"Blocks");

                    BlockVector* blockVector = m_BlockVectors[heapType];
                    D3D12MA_ASSERT(blockVector);
                    blockVector->WriteBlockInfoToJson(json);

                    json.EndObject(); // heap name
                }
            }
            else
            {
                for (size_t heapType = 0; heapType < HEAP_TYPE_COUNT; ++heapType)
                {
                    for (size_t heapSubType = 0; heapSubType < 3; ++heapSubType)
                    {
                        static const WCHAR* const heapSubTypeName[] = {
                            L" + buffer",
                            L" + texture",
                            L" + texture RT or DS",
                        };
                        json.BeginString();
                        json.ContinueString(HeapTypeNames[heapType]);
                        json.ContinueString(heapSubTypeName[heapSubType]);
                        json.EndString();
                        json.BeginObject();

                        json.WriteString(L"Blocks");

                        BlockVector* blockVector = m_BlockVectors[heapType * 3 + heapSubType];
                        D3D12MA_ASSERT(blockVector);
                        blockVector->WriteBlockInfoToJson(json);

                        json.EndObject(); // heap name
                    }
                }
            }

            json.EndObject(); // DefaultPools

            json.WriteString(L"CommittedAllocations");
            json.BeginObject();

            for (size_t heapType = 0; heapType < HEAP_TYPE_COUNT; ++heapType)
            {
                json.WriteString(HeapTypeNames[heapType]);
                MutexLockRead lock(m_CommittedAllocationsMutex[heapType], m_UseMutex);

                json.BeginArray();
                CommittedAllocationList& committedAllocations = m_CommittedAllocations[heapType];
                for(Allocation* alloc = committedAllocations.Front();
                    alloc != NULL; alloc = committedAllocations.GetNext(alloc))
                {
                    D3D12MA_ASSERT(alloc);
                    json.BeginObject(true);
                    json.AddAllocationToObject(*alloc);
                    json.EndObject();
                }
                json.EndArray();
            }

            json.EndObject(); // CommittedAllocations

            json.EndObject(); // DetailedMap
        }
        json.EndObject();
    }

    const size_t length = sb.GetLength();
    WCHAR* result = AllocateArray<WCHAR>(GetAllocs(), length + 1);
    memcpy(result, sb.GetData(), length * sizeof(WCHAR));
    result[length] = L'\0';
    *ppStatsString = result;
}

void AllocatorPimpl::FreeStatsString(WCHAR* pStatsString)
{
    D3D12MA_ASSERT(pStatsString);
    Free(GetAllocs(), pStatsString);
}

HRESULT AllocatorPimpl::UpdateD3D12Budget()
{
#if D3D12MA_DXGI_1_4
    D3D12MA_ASSERT(m_Adapter3);

    DXGI_QUERY_VIDEO_MEMORY_INFO infoLocal = {};
    DXGI_QUERY_VIDEO_MEMORY_INFO infoNonLocal = {};
    HRESULT hrLocal = m_Adapter3->QueryVideoMemoryInfo(0, DXGI_MEMORY_SEGMENT_GROUP_LOCAL, &infoLocal);
    HRESULT hrNonLocal = m_Adapter3->QueryVideoMemoryInfo(0, DXGI_MEMORY_SEGMENT_GROUP_NON_LOCAL, &infoNonLocal);

    {
        MutexLockWrite lockWrite(m_Budget.m_BudgetMutex, m_UseMutex);

        if(SUCCEEDED(hrLocal))
        {
            m_Budget.m_D3D12UsageLocal = infoLocal.CurrentUsage;
            m_Budget.m_D3D12BudgetLocal = infoLocal.Budget;
        }
        if(SUCCEEDED(hrNonLocal))
        {
            m_Budget.m_D3D12UsageNonLocal = infoNonLocal.CurrentUsage;
            m_Budget.m_D3D12BudgetNonLocal = infoNonLocal.Budget;
        }

        for(UINT i = 0; i < HEAP_TYPE_COUNT; ++i)
        {
            m_Budget.m_BlockBytesAtBudgetFetch[i] = m_Budget.m_BlockBytes[i].load();
        }

        m_Budget.m_OperationsSinceBudgetFetch = 0;
    }

    return FAILED(hrLocal) ? hrLocal : hrNonLocal;
#else
    return S_OK;
#endif
}

D3D12_RESOURCE_ALLOCATION_INFO AllocatorPimpl::GetResourceAllocationInfoNative(const D3D12_RESOURCE_DESC& resourceDesc) const
{
    return m_Device->GetResourceAllocationInfo(0, 1, &resourceDesc);
}

#ifdef __ID3D12Device8_INTERFACE_DEFINED__
D3D12_RESOURCE_ALLOCATION_INFO AllocatorPimpl::GetResourceAllocationInfoNative(const D3D12_RESOURCE_DESC1& resourceDesc) const
{
    D3D12MA_ASSERT(m_Device8 != NULL);
    D3D12_RESOURCE_ALLOCATION_INFO1 info1Unused;
    return m_Device8->GetResourceAllocationInfo2(0, 1, &resourceDesc, &info1Unused);
}
#endif // #ifdef __ID3D12Device8_INTERFACE_DEFINED__

template<typename D3D12_RESOURCE_DESC_T>
D3D12_RESOURCE_ALLOCATION_INFO AllocatorPimpl::GetResourceAllocationInfo(D3D12_RESOURCE_DESC_T& inOutResourceDesc) const
{
    /* Optional optimization: Microsoft documentation says:
    https://docs.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-getresourceallocationinfo
    
    Your application can forgo using GetResourceAllocationInfo for buffer resources
    (D3D12_RESOURCE_DIMENSION_BUFFER). Buffers have the same size on all adapters,
    which is merely the smallest multiple of 64KB that's greater or equal to
    D3D12_RESOURCE_DESC::Width.
    */
    if(inOutResourceDesc.Alignment == 0 &&
        inOutResourceDesc.Dimension == D3D12_RESOURCE_DIMENSION_BUFFER)
    {
        return {
            AlignUp<UINT64>(inOutResourceDesc.Width, D3D12_DEFAULT_RESOURCE_PLACEMENT_ALIGNMENT), // SizeInBytes
            D3D12_DEFAULT_RESOURCE_PLACEMENT_ALIGNMENT}; // Alignment
    }

#if D3D12MA_USE_SMALL_RESOURCE_PLACEMENT_ALIGNMENT
    if(inOutResourceDesc.Alignment == 0 &&
        inOutResourceDesc.Dimension == D3D12_RESOURCE_DIMENSION_TEXTURE2D &&
        (inOutResourceDesc.Flags & (D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET | D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL)) == 0
#if D3D12MA_USE_SMALL_RESOURCE_PLACEMENT_ALIGNMENT == 1
        && CanUseSmallAlignment(inOutResourceDesc)
#endif
        )
    {
        /*
        The algorithm here is based on Microsoft sample: "Small Resources Sample"
        https://github.com/microsoft/DirectX-Graphics-Samples/tree/master/Samples/Desktop/D3D12SmallResources
        */
        const UINT64 smallAlignmentToTry = inOutResourceDesc.SampleDesc.Count > 1 ?
            D3D12_SMALL_MSAA_RESOURCE_PLACEMENT_ALIGNMENT :
            D3D12_SMALL_RESOURCE_PLACEMENT_ALIGNMENT;
        inOutResourceDesc.Alignment = smallAlignmentToTry;
        const D3D12_RESOURCE_ALLOCATION_INFO smallAllocInfo = GetResourceAllocationInfoNative(inOutResourceDesc);
        // Check if alignment requested has been granted.
        if(smallAllocInfo.Alignment == smallAlignmentToTry)
        {
            return smallAllocInfo;
        }
        inOutResourceDesc.Alignment = 0; // Restore original
    }
#endif // #if D3D12MA_USE_SMALL_RESOURCE_PLACEMENT_ALIGNMENT

    return GetResourceAllocationInfoNative(inOutResourceDesc);
}

bool AllocatorPimpl::NewAllocationWithinBudget(D3D12_HEAP_TYPE heapType, UINT64 size)
{
    Budget budget = {};
    GetBudgetForHeapType(budget, heapType);
    return budget.UsageBytes + size <= budget.BudgetBytes;
}

void AllocatorPimpl::WriteBudgetToJson(JsonWriter& json, const Budget& budget)
{
    json.BeginObject();
    {
        json.WriteString(L"BlockBytes");
        json.WriteNumber(budget.BlockBytes);
        json.WriteString(L"AllocationBytes");
        json.WriteNumber(budget.AllocationBytes);
        json.WriteString(L"UsageBytes");
        json.WriteNumber(budget.UsageBytes);
        json.WriteString(L"BudgetBytes");
        json.WriteNumber(budget.BudgetBytes);
    }
    json.EndObject();
}

////////////////////////////////////////////////////////////////////////////////
// Public class Allocation implementation

void Allocation::PackedData::SetType(Type type)
{
    const UINT u = (UINT)type;
    D3D12MA_ASSERT(u < (1u << 2));
    m_Type = u;
}

void Allocation::PackedData::SetResourceDimension(D3D12_RESOURCE_DIMENSION resourceDimension)
{
    const UINT u = (UINT)resourceDimension;
    D3D12MA_ASSERT(u < (1u << 3));
    m_ResourceDimension = u;
}

void Allocation::PackedData::SetResourceFlags(D3D12_RESOURCE_FLAGS resourceFlags)
{
    const UINT u = (UINT)resourceFlags;
    D3D12MA_ASSERT(u < (1u << 24));
    m_ResourceFlags = u;
}

void Allocation::PackedData::SetTextureLayout(D3D12_TEXTURE_LAYOUT textureLayout)
{
    const UINT u = (UINT)textureLayout;
    D3D12MA_ASSERT(u < (1u << 9));
    m_TextureLayout = u;
}

void Allocation::Release()
{
    if(this == NULL)
    {
        return;
    }

    D3D12MA_DEBUG_GLOBAL_MUTEX_LOCK

    SAFE_RELEASE(m_Resource);

    switch(m_PackedData.GetType())
    {
    case TYPE_COMMITTED:
        m_Allocator->FreeCommittedMemory(this);
        break;
    case TYPE_PLACED:
        m_Allocator->FreePlacedMemory(this);
        break;
    case TYPE_HEAP:
        m_Allocator->FreeHeapMemory(this);
        break;
    }

    FreeName();

    m_Allocator->GetAllocationObjectAllocator().Free(this);
}

UINT64 Allocation::GetOffset() const
{
    switch(m_PackedData.GetType())
    {
    case TYPE_COMMITTED:
    case TYPE_HEAP:
        return 0;
    case TYPE_PLACED:
        return m_Placed.offset;
    default:
        D3D12MA_ASSERT(0);
        return 0;
    }
}

ID3D12Heap* Allocation::GetHeap() const
{
    switch(m_PackedData.GetType())
    {
    case TYPE_COMMITTED:
        return NULL;
    case TYPE_PLACED:
        return m_Placed.block->GetHeap();
    case TYPE_HEAP:
        return m_Heap.heap;
    default:
        D3D12MA_ASSERT(0);
        return 0;
    }
}

void Allocation::SetName(LPCWSTR Name)
{
    FreeName();

    if(Name)
    {
        const size_t nameCharCount = wcslen(Name) + 1;
        m_Name = D3D12MA_NEW_ARRAY(m_Allocator->GetAllocs(), WCHAR, nameCharCount);
        memcpy(m_Name, Name, nameCharCount * sizeof(WCHAR));
    }
}

Allocation::Allocation(AllocatorPimpl* allocator, UINT64 size, BOOL wasZeroInitialized) :
    m_Allocator{allocator},
    m_Size{size},
    m_Resource{NULL},
    m_CreationFrameIndex{allocator->GetCurrentFrameIndex()},
    m_Name{NULL}
{
    D3D12MA_ASSERT(allocator);

    m_PackedData.SetType(TYPE_COUNT);
    m_PackedData.SetResourceDimension(D3D12_RESOURCE_DIMENSION_UNKNOWN);
    m_PackedData.SetResourceFlags(D3D12_RESOURCE_FLAG_NONE);
    m_PackedData.SetTextureLayout(D3D12_TEXTURE_LAYOUT_UNKNOWN);
    m_PackedData.SetWasZeroInitialized(wasZeroInitialized);
}

Allocation::~Allocation()
{
    // Nothing here, everything already done in Release.
}

void Allocation::InitCommitted(D3D12_HEAP_TYPE heapType)
{
    m_PackedData.SetType(TYPE_COMMITTED);
    m_Committed.heapType = heapType;
    m_Committed.prev = NULL;
    m_Committed.next = NULL;
}

void Allocation::InitPlaced(UINT64 offset, UINT64 alignment, NormalBlock* block)
{
    m_PackedData.SetType(TYPE_PLACED);
    m_Placed.offset = offset;
    m_Placed.block = block;
}

void Allocation::InitHeap(D3D12_HEAP_TYPE heapType, ID3D12Heap* heap)
{
    m_PackedData.SetType(TYPE_HEAP);
    m_Heap.heapType = heapType;
    m_Committed.prev = NULL;
    m_Committed.next = NULL;
    m_Heap.heap = heap;
}

template<typename D3D12_RESOURCE_DESC_T>
void Allocation::SetResource(ID3D12Resource* resource, const D3D12_RESOURCE_DESC_T* pResourceDesc)
{
    D3D12MA_ASSERT(m_Resource == NULL && pResourceDesc);
    m_Resource = resource;
    m_PackedData.SetResourceDimension(pResourceDesc->Dimension);
    m_PackedData.SetResourceFlags(pResourceDesc->Flags);
    m_PackedData.SetTextureLayout(pResourceDesc->Layout);
}

void Allocation::FreeName()
{
    if(m_Name)
    {
        const size_t nameCharCount = wcslen(m_Name) + 1;
        D3D12MA_DELETE_ARRAY(m_Allocator->GetAllocs(), m_Name, nameCharCount);
        m_Name = NULL;
    }
}

////////////////////////////////////////////////////////////////////////////////
// Private class AllocationObjectAllocator implementation

AllocationObjectAllocator::AllocationObjectAllocator(const ALLOCATION_CALLBACKS& allocationCallbacks) :
    m_Allocator(allocationCallbacks, 1024)
{
}

template<typename... Types> Allocation* AllocationObjectAllocator::Allocate(Types... args)
{
    MutexLock mutexLock(m_Mutex);
    return m_Allocator.Alloc(std::forward<Types>(args)...);
}

void AllocationObjectAllocator::Free(Allocation* alloc)
{
    MutexLock mutexLock(m_Mutex);
    m_Allocator.Free(alloc);
}

////////////////////////////////////////////////////////////////////////////////
// Public class Allocator implementation

Allocator::Allocator(const ALLOCATION_CALLBACKS& allocationCallbacks, const ALLOCATOR_DESC& desc) :
    m_Pimpl(D3D12MA_NEW(allocationCallbacks, AllocatorPimpl)(allocationCallbacks, desc))
{
}

Allocator::~Allocator()
{
    D3D12MA_DELETE(m_Pimpl->GetAllocs(), m_Pimpl);
}

void Allocator::Release()
{
    D3D12MA_DEBUG_GLOBAL_MUTEX_LOCK

    // Copy is needed because otherwise we would call destructor and invalidate the structure with callbacks before using it to free memory.
    const ALLOCATION_CALLBACKS allocationCallbacksCopy = m_Pimpl->GetAllocs();
    D3D12MA_DELETE(allocationCallbacksCopy, this);
}



const D3D12_FEATURE_DATA_D3D12_OPTIONS& Allocator::GetD3D12Options() const
{
    return m_Pimpl->GetD3D12Options();
}

HRESULT Allocator::CreateResource(
    const ALLOCATION_DESC* pAllocDesc,
    const D3D12_RESOURCE_DESC* pResourceDesc,
    D3D12_RESOURCE_STATES InitialResourceState,
    const D3D12_CLEAR_VALUE *pOptimizedClearValue,
    Allocation** ppAllocation,
    REFIID riidResource,
    void** ppvResource)
{
    if(!pAllocDesc || !pResourceDesc || !ppAllocation)
    {
        D3D12MA_ASSERT(0 && "Invalid arguments passed to Allocator::CreateResource.");
        return E_INVALIDARG;
    }
    D3D12MA_DEBUG_GLOBAL_MUTEX_LOCK
    return m_Pimpl->CreateResource(pAllocDesc, pResourceDesc, InitialResourceState, pOptimizedClearValue, ppAllocation, riidResource, ppvResource);
}

#ifdef __ID3D12Device4_INTERFACE_DEFINED__
HRESULT Allocator::CreateResource1(
    const ALLOCATION_DESC* pAllocDesc,
    const D3D12_RESOURCE_DESC* pResourceDesc,
    D3D12_RESOURCE_STATES InitialResourceState,
    const D3D12_CLEAR_VALUE *pOptimizedClearValue,
    ID3D12ProtectedResourceSession *pProtectedSession,
    Allocation** ppAllocation,
    REFIID riidResource,
    void** ppvResource)
{
    if(!pAllocDesc || !pResourceDesc || !ppAllocation)
    {
        D3D12MA_ASSERT(0 && "Invalid arguments passed to Allocator::CreateResource1.");
        return E_INVALIDARG;
    }
    D3D12MA_DEBUG_GLOBAL_MUTEX_LOCK
    return m_Pimpl->CreateResource1(pAllocDesc, pResourceDesc, InitialResourceState, pOptimizedClearValue, pProtectedSession, ppAllocation, riidResource, ppvResource);
}
#endif // #ifdef __ID3D12Device4_INTERFACE_DEFINED__

#ifdef __ID3D12Device8_INTERFACE_DEFINED__
HRESULT Allocator::CreateResource2(
    const ALLOCATION_DESC* pAllocDesc,
    const D3D12_RESOURCE_DESC1* pResourceDesc,
    D3D12_RESOURCE_STATES InitialResourceState,
    const D3D12_CLEAR_VALUE *pOptimizedClearValue,
    ID3D12ProtectedResourceSession *pProtectedSession,
    Allocation** ppAllocation,
    REFIID riidResource,
    void** ppvResource)
{
    if(!pAllocDesc || !pResourceDesc || !ppAllocation)
    {
        D3D12MA_ASSERT(0 && "Invalid arguments passed to Allocator::CreateResource2.");
        return E_INVALIDARG;
    }
    D3D12MA_DEBUG_GLOBAL_MUTEX_LOCK
    return m_Pimpl->CreateResource2(pAllocDesc, pResourceDesc, InitialResourceState, pOptimizedClearValue, pProtectedSession, ppAllocation, riidResource, ppvResource);
}
#endif // #ifdef __ID3D12Device8_INTERFACE_DEFINED__

static inline bool ValidateAllocateMemoryParameters(
    const ALLOCATION_DESC* pAllocDesc,
    const D3D12_RESOURCE_ALLOCATION_INFO* pAllocInfo,
    Allocation** ppAllocation)
{
    return pAllocDesc &&
        pAllocInfo &&
        ppAllocation &&
        (pAllocInfo->Alignment == 0 ||
            pAllocInfo->Alignment == D3D12_DEFAULT_RESOURCE_PLACEMENT_ALIGNMENT ||
            pAllocInfo->Alignment == D3D12_DEFAULT_MSAA_RESOURCE_PLACEMENT_ALIGNMENT) &&
        pAllocInfo->SizeInBytes != 0 &&
        pAllocInfo->SizeInBytes % (64ull * 1024) == 0;
}

HRESULT Allocator::AllocateMemory(
    const ALLOCATION_DESC* pAllocDesc,
    const D3D12_RESOURCE_ALLOCATION_INFO* pAllocInfo,
    Allocation** ppAllocation)
{
    if(!ValidateAllocateMemoryParameters(pAllocDesc, pAllocInfo, ppAllocation))
    {
        D3D12MA_ASSERT(0 && "Invalid arguments passed to Allocator::AllocateMemory.");
        return E_INVALIDARG;
    }
    D3D12MA_DEBUG_GLOBAL_MUTEX_LOCK
    return m_Pimpl->AllocateMemory(pAllocDesc, pAllocInfo, ppAllocation);
}

#ifdef __ID3D12Device4_INTERFACE_DEFINED__
HRESULT Allocator::AllocateMemory1(
    const ALLOCATION_DESC* pAllocDesc,
    const D3D12_RESOURCE_ALLOCATION_INFO* pAllocInfo,
    ID3D12ProtectedResourceSession *pProtectedSession,
    Allocation** ppAllocation)
{
    if(!ValidateAllocateMemoryParameters(pAllocDesc, pAllocInfo, ppAllocation))
    {
        D3D12MA_ASSERT(0 && "Invalid arguments passed to Allocator::AllocateMemory1.");
        return E_INVALIDARG;
    }
    D3D12MA_DEBUG_GLOBAL_MUTEX_LOCK
    return m_Pimpl->AllocateMemory1(pAllocDesc, pAllocInfo, pProtectedSession, ppAllocation);
}
#endif // #ifdef __ID3D12Device4_INTERFACE_DEFINED__

HRESULT Allocator::CreateAliasingResource(
    Allocation* pAllocation,
    UINT64 AllocationLocalOffset,
    const D3D12_RESOURCE_DESC* pResourceDesc,
    D3D12_RESOURCE_STATES InitialResourceState,
    const D3D12_CLEAR_VALUE *pOptimizedClearValue,
    REFIID riidResource,
    void** ppvResource)
{
    if(!pAllocation || !pResourceDesc || !ppvResource)
    {
        D3D12MA_ASSERT(0 && "Invalid arguments passed to Allocator::CreateAliasingResource.");
        return E_INVALIDARG;
    }
    D3D12MA_DEBUG_GLOBAL_MUTEX_LOCK
    return m_Pimpl->CreateAliasingResource(pAllocation, AllocationLocalOffset, pResourceDesc, InitialResourceState, pOptimizedClearValue, riidResource, ppvResource);
}

HRESULT Allocator::CreatePool(
    const POOL_DESC* pPoolDesc,
    Pool** ppPool)
{
    if(!pPoolDesc || !ppPool ||
        !IsHeapTypeValid(pPoolDesc->HeapType) ||
        (pPoolDesc->MaxBlockCount > 0 && pPoolDesc->MaxBlockCount < pPoolDesc->MinBlockCount))
    {
        D3D12MA_ASSERT(0 && "Invalid arguments passed to Allocator::CreatePool.");
        return E_INVALIDARG;
    }
    if(!m_Pimpl->HeapFlagsFulfillResourceHeapTier(pPoolDesc->HeapFlags))
    {
        D3D12MA_ASSERT(0 && "Invalid pPoolDesc->HeapFlags passed to Allocator::CreatePool. Did you forget to handle ResourceHeapTier=1?");
        return E_INVALIDARG;
    }
    D3D12MA_DEBUG_GLOBAL_MUTEX_LOCK
    *ppPool = D3D12MA_NEW(m_Pimpl->GetAllocs(), Pool)(this, *pPoolDesc);
    HRESULT hr = (*ppPool)->m_Pimpl->Init();
    if(SUCCEEDED(hr))
    {
        m_Pimpl->RegisterPool(*ppPool, pPoolDesc->HeapType);
    }
    else
    {
        D3D12MA_DELETE(m_Pimpl->GetAllocs(), *ppPool);
        *ppPool = NULL;
    }
    return hr;
}

HRESULT Allocator::SetDefaultHeapMinBytes(
    D3D12_HEAP_TYPE heapType,
    D3D12_HEAP_FLAGS heapFlags,
    UINT64 minBytes)
{
    D3D12MA_DEBUG_GLOBAL_MUTEX_LOCK
    return m_Pimpl->SetDefaultHeapMinBytes(heapType, heapFlags, minBytes);
}

void Allocator::SetCurrentFrameIndex(UINT frameIndex)
{
    D3D12MA_DEBUG_GLOBAL_MUTEX_LOCK
    m_Pimpl->SetCurrentFrameIndex(frameIndex);
}

void Allocator::CalculateStats(Stats* pStats)
{
    D3D12MA_ASSERT(pStats);
    D3D12MA_DEBUG_GLOBAL_MUTEX_LOCK
    m_Pimpl->CalculateStats(*pStats);
}

void Allocator::GetBudget(Budget* pGpuBudget, Budget* pCpuBudget)
{
    if(pGpuBudget == NULL && pCpuBudget == NULL)
    {
        return;
    }
    D3D12MA_DEBUG_GLOBAL_MUTEX_LOCK
    m_Pimpl->GetBudget(pGpuBudget, pCpuBudget);
}

void Allocator::BuildStatsString(WCHAR** ppStatsString, BOOL DetailedMap) const
{
    D3D12MA_ASSERT(ppStatsString);
    D3D12MA_DEBUG_GLOBAL_MUTEX_LOCK
    m_Pimpl->BuildStatsString(ppStatsString, DetailedMap);
}

void Allocator::FreeStatsString(WCHAR* pStatsString) const
{
    if (pStatsString != NULL)
    {
        D3D12MA_DEBUG_GLOBAL_MUTEX_LOCK
        m_Pimpl->FreeStatsString(pStatsString);
    }
}

////////////////////////////////////////////////////////////////////////////////
// Private class VirtualBlockPimpl definition

class VirtualBlockPimpl
{
public:
    const ALLOCATION_CALLBACKS m_AllocationCallbacks;
    const UINT64 m_Size;
    BlockMetadata_Generic m_Metadata;

    VirtualBlockPimpl(const ALLOCATION_CALLBACKS& allocationCallbacks, UINT64 size);
    ~VirtualBlockPimpl();
};

VirtualBlockPimpl::VirtualBlockPimpl(const ALLOCATION_CALLBACKS& allocationCallbacks, UINT64 size) :
    m_AllocationCallbacks(allocationCallbacks),
    m_Size(size),
    m_Metadata(&m_AllocationCallbacks,
        true) // isVirtual
{
    m_Metadata.Init(m_Size);
}

VirtualBlockPimpl::~VirtualBlockPimpl()
{
}

////////////////////////////////////////////////////////////////////////////////
// Public class VirtualBlock implementation

VirtualBlock::VirtualBlock(const ALLOCATION_CALLBACKS& allocationCallbacks, const VIRTUAL_BLOCK_DESC& desc) :
    m_Pimpl(D3D12MA_NEW(allocationCallbacks, VirtualBlockPimpl)(allocationCallbacks, desc.Size))
{
}

VirtualBlock::~VirtualBlock()
{
    // THIS IS AN IMPORTANT ASSERT!
    // Hitting it means you have some memory leak - unreleased allocations in this virtual block.
    D3D12MA_ASSERT(m_Pimpl->m_Metadata.IsEmpty() && "Some allocations were not freed before destruction of this virtual block!");

    D3D12MA_DELETE(m_Pimpl->m_AllocationCallbacks, m_Pimpl);
}

void VirtualBlock::Release()
{
    D3D12MA_DEBUG_GLOBAL_MUTEX_LOCK

    // Copy is needed because otherwise we would call destructor and invalidate the structure with callbacks before using it to free memory.
    const ALLOCATION_CALLBACKS allocationCallbacksCopy = m_Pimpl->m_AllocationCallbacks;
    D3D12MA_DELETE(allocationCallbacksCopy, this);
}

BOOL VirtualBlock::IsEmpty() const
{
    D3D12MA_DEBUG_GLOBAL_MUTEX_LOCK

    return m_Pimpl->m_Metadata.IsEmpty() ? TRUE : FALSE;
}

void VirtualBlock::GetAllocationInfo(UINT64 offset, VIRTUAL_ALLOCATION_INFO* pInfo) const
{
    D3D12MA_ASSERT(offset != UINT64_MAX && pInfo);

    D3D12MA_DEBUG_GLOBAL_MUTEX_LOCK

    m_Pimpl->m_Metadata.GetAllocationInfo(offset, *pInfo);
}

HRESULT VirtualBlock::Allocate(const VIRTUAL_ALLOCATION_DESC* pDesc, UINT64* pOffset)
{
    if(!pDesc || !pOffset || pDesc->Size == 0 || !IsPow2(pDesc->Alignment))
    {
        D3D12MA_ASSERT(0 && "Invalid arguments passed to VirtualBlock::Allocate.");
        return E_INVALIDARG;
    }

    *pOffset = UINT64_MAX;

    D3D12MA_DEBUG_GLOBAL_MUTEX_LOCK
        
    const UINT64 alignment = pDesc->Alignment != 0 ? pDesc->Alignment : 1;
    AllocationRequest allocRequest = {};
    if(m_Pimpl->m_Metadata.CreateAllocationRequest(pDesc->Size, alignment, &allocRequest))
    {
        m_Pimpl->m_Metadata.Alloc(allocRequest, pDesc->Size, pDesc->pUserData);
        D3D12MA_HEAVY_ASSERT(m_Pimpl->m_Metadata.Validate());
        *pOffset = allocRequest.offset;
        return S_OK;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

void VirtualBlock::FreeAllocation(UINT64 offset)
{
    D3D12MA_DEBUG_GLOBAL_MUTEX_LOCK

    D3D12MA_ASSERT(offset != UINT64_MAX);
        
    m_Pimpl->m_Metadata.FreeAtOffset(offset);
    D3D12MA_HEAVY_ASSERT(m_Pimpl->m_Metadata.Validate());
}

void VirtualBlock::Clear()
{
    D3D12MA_DEBUG_GLOBAL_MUTEX_LOCK

    m_Pimpl->m_Metadata.Clear();
    D3D12MA_HEAVY_ASSERT(m_Pimpl->m_Metadata.Validate());
}

void VirtualBlock::SetAllocationUserData(UINT64 offset, void* pUserData)
{
    D3D12MA_ASSERT(offset != UINT64_MAX);

    D3D12MA_DEBUG_GLOBAL_MUTEX_LOCK

    m_Pimpl->m_Metadata.SetAllocationUserData(offset, pUserData);
}

void VirtualBlock::CalculateStats(StatInfo* pInfo) const
{
    D3D12MA_ASSERT(pInfo);

    D3D12MA_DEBUG_GLOBAL_MUTEX_LOCK

    D3D12MA_HEAVY_ASSERT(m_Pimpl->m_Metadata.Validate());
    m_Pimpl->m_Metadata.CalcAllocationStatInfo(*pInfo);
}

void VirtualBlock::BuildStatsString(WCHAR** ppStatsString) const
{
    D3D12MA_ASSERT(ppStatsString);

    D3D12MA_DEBUG_GLOBAL_MUTEX_LOCK

    StringBuilder sb(m_Pimpl->m_AllocationCallbacks);
    {
        JsonWriter json(m_Pimpl->m_AllocationCallbacks, sb);
        D3D12MA_HEAVY_ASSERT(m_Pimpl->m_Metadata.Validate());
        m_Pimpl->m_Metadata.WriteAllocationInfoToJson(json);
    } // Scope for JsonWriter

    const size_t length = sb.GetLength();
    WCHAR* result = AllocateArray<WCHAR>(m_Pimpl->m_AllocationCallbacks, length + 1);
    memcpy(result, sb.GetData(), length * sizeof(WCHAR));
    result[length] = L'\0';
    *ppStatsString = result;
}

void VirtualBlock::FreeStatsString(WCHAR* pStatsString) const
{
    if (pStatsString != NULL)
    {
        D3D12MA_DEBUG_GLOBAL_MUTEX_LOCK
        D3D12MA::Free(m_Pimpl->m_AllocationCallbacks, pStatsString);
    }
}


////////////////////////////////////////////////////////////////////////////////
// Public global functions

HRESULT CreateAllocator(const ALLOCATOR_DESC* pDesc, Allocator** ppAllocator)
{
    if(!pDesc || !ppAllocator || !pDesc->pDevice || !pDesc->pAdapter ||
        !(pDesc->PreferredBlockSize == 0 || (pDesc->PreferredBlockSize >= 16 && pDesc->PreferredBlockSize < 0x10000000000ull)))
    {
        D3D12MA_ASSERT(0 && "Invalid arguments passed to CreateAllocator.");
        return E_INVALIDARG;
    }

    D3D12MA_DEBUG_GLOBAL_MUTEX_LOCK

    ALLOCATION_CALLBACKS allocationCallbacks;
    SetupAllocationCallbacks(allocationCallbacks, pDesc->pAllocationCallbacks);

    *ppAllocator = D3D12MA_NEW(allocationCallbacks, Allocator)(allocationCallbacks, *pDesc);
    HRESULT hr = (*ppAllocator)->m_Pimpl->Init(*pDesc);
    if(FAILED(hr))
    {
        D3D12MA_DELETE(allocationCallbacks, *ppAllocator);
        *ppAllocator = NULL;
    }
    return hr;
}

HRESULT CreateVirtualBlock(const VIRTUAL_BLOCK_DESC* pDesc, VirtualBlock** ppVirtualBlock)
{
    if(!pDesc || !ppVirtualBlock)
    {
        D3D12MA_ASSERT(0 && "Invalid arguments passed to CreateVirtualBlock.");
        return E_INVALIDARG;
    }

    D3D12MA_DEBUG_GLOBAL_MUTEX_LOCK

    ALLOCATION_CALLBACKS allocationCallbacks;
    SetupAllocationCallbacks(allocationCallbacks, pDesc->pAllocationCallbacks);

    *ppVirtualBlock = D3D12MA_NEW(allocationCallbacks, VirtualBlock)(allocationCallbacks, *pDesc);
    return S_OK;
}

} // namespace D3D12MA

```

`ext/d3d12memoryallocator/D3D12MemAlloc.h`:

```h
//
// Copyright (c) 2019-2021 Advanced Micro Devices, Inc. All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

#pragma once

/** \mainpage D3D12 Memory Allocator

<b>Version 2.0.0-development</b> (2021-02-16)

Copyright (c) 2019-2021 Advanced Micro Devices, Inc. All rights reserved. \n
License: MIT

Documentation of all members: D3D12MemAlloc.h

\section main_table_of_contents Table of contents

- <b>User guide</b>
    - \subpage quick_start
        - [Project setup](@ref quick_start_project_setup)
        - [Creating resources](@ref quick_start_creating_resources)
        - [Mapping memory](@ref quick_start_mapping_memory)
    - \subpage resource_aliasing
    - \subpage reserving_memory
    - \subpage virtual_allocator
- \subpage configuration
  - [Custom CPU memory allocator](@ref custom_memory_allocator)
- \subpage general_considerations
  - [Thread safety](@ref general_considerations_thread_safety)
  - [Future plans](@ref general_considerations_future_plans)
  - [Features not supported](@ref general_considerations_features_not_supported)
		
\section main_see_also See also

- [Product page on GPUOpen](https://gpuopen.com/gaming-product/d3d12-memory-allocator/)
- [Source repository on GitHub](https://github.com/GPUOpen-LibrariesAndSDKs/D3D12MemoryAllocator)


\page quick_start Quick start

\section quick_start_project_setup Project setup and initialization

This is a small, standalone C++ library. It consists of a pair of 2 files:
"%D3D12MemAlloc.h" header file with public interface and "D3D12MemAlloc.cpp" with
internal implementation. The only external dependencies are WinAPI, Direct3D 12,
and parts of C/C++ standard library (but STL containers, exceptions, or RTTI are
not used).

The library is developed and tested using Microsoft Visual Studio 2019, but it
should work with other compilers as well. It is designed for 64-bit code.

To use the library in your project:

(1.) Copy files `D3D12MemAlloc.cpp`, `%D3D12MemAlloc.h` to your project.

(2.) Make `D3D12MemAlloc.cpp` compiling as part of the project, as C++ code.

(3.) Include library header in each CPP file that needs to use the library.

\code
#include "D3D12MemAlloc.h"
\endcode

(4.) Right after you created `ID3D12Device`, fill D3D12MA::ALLOCATOR_DESC
structure and call function D3D12MA::CreateAllocator to create the main
D3D12MA::Allocator object.

Please note that all symbols of the library are declared inside #D3D12MA namespace.

\code
IDXGIAdapter* adapter = (...)
ID3D12Device* device = (...)

D3D12MA::ALLOCATOR_DESC allocatorDesc = {};
allocatorDesc.pDevice = device;
allocatorDesc.pAdapter = adapter;

D3D12MA::Allocator* allocator;
HRESULT hr = D3D12MA::CreateAllocator(&allocatorDesc, &allocator);
\endcode

(5.) Right before destroying the D3D12 device, destroy the allocator object.

Please note that objects of this library must be destroyed by calling `Release`
method (despite they are not COM interfaces and no reference counting is involved).

\code
allocator->Release();
\endcode


\section quick_start_creating_resources Creating resources

To use the library for creating resources (textures and buffers), call method
D3D12MA::Allocator::CreateResource in the place where you would previously call
`ID3D12Device::CreateCommittedResource`.

The function has similar syntax, but it expects structure D3D12MA::ALLOCATION_DESC
to be passed along with `D3D12_RESOURCE_DESC` and other parameters for created
resource. This structure describes parameters of the desired memory allocation,
including choice of `D3D12_HEAP_TYPE`.

The function also returns a new object of type D3D12MA::Allocation, created along
with usual `ID3D12Resource`. It represents allocated memory and can be queried
for size, offset, `ID3D12Resource`, and `ID3D12Heap` if needed.

\code
D3D12_RESOURCE_DESC resourceDesc = {};
resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
resourceDesc.Alignment = 0;
resourceDesc.Width = 1024;
resourceDesc.Height = 1024;
resourceDesc.DepthOrArraySize = 1;
resourceDesc.MipLevels = 1;
resourceDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
resourceDesc.SampleDesc.Count = 1;
resourceDesc.SampleDesc.Quality = 0;
resourceDesc.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN;
resourceDesc.Flags = D3D12_RESOURCE_FLAG_NONE;

D3D12MA::ALLOCATION_DESC allocationDesc = {};
allocDesc.HeapType = D3D12_HEAP_TYPE_DEFAULT;

D3D12Resource* resource;
D3D12MA::Allocation* allocation;
HRESULT hr = allocator->CreateResource(
    &allocationDesc,
    &resourceDesc,
    D3D12_RESOURCE_STATE_COPY_DEST,
    NULL,
    &allocation,
    IID_PPV_ARGS(&resource));
\endcode

You need to remember both resource and allocation objects and destroy them
separately when no longer needed.

\code
allocation->Release();
resource->Release();
\endcode

The advantage of using the allocator instead of creating committed resource, and
the main purpose of this library, is that it can decide to allocate bigger memory
heap internally using `ID3D12Device::CreateHeap` and place multiple resources in
it, at different offsets, using `ID3D12Device::CreatePlacedResource`. The library
manages its own collection of allocated memory blocks (heaps) and remembers which
parts of them are occupied and which parts are free to be used for new resources.

It is important to remember that resources created as placed don't have their memory
initialized to zeros, but may contain garbage data, so they need to be fully initialized
before usage, e.g. using Clear (`ClearRenderTargetView`), Discard (`DiscardResource`),
or copy (`CopyResource`).

The library also automatically handles resource heap tier.
When `D3D12_FEATURE_DATA_D3D12_OPTIONS::ResourceHeapTier` equals `D3D12_RESOURCE_HEAP_TIER_1`,
resources of 3 types: buffers, textures that are render targets or depth-stencil,
and other textures must be kept in separate heaps. When `D3D12_RESOURCE_HEAP_TIER_2`,
they can be kept together. By using this library, you don't need to handle this
manually.


\section quick_start_mapping_memory Mapping memory

The process of getting regular CPU-side pointer to the memory of a resource in
Direct3D is called "mapping". There are rules and restrictions to this process,
as described in D3D12 documentation of [ID3D12Resource::Map method](https://docs.microsoft.com/en-us/windows/desktop/api/d3d12/nf-d3d12-id3d12resource-map).

Mapping happens on the level of particular resources, not entire memory heaps,
and so it is out of scope of this library. Just as the linked documentation says:

- Returned pointer refers to data of particular subresource, not entire memory heap.
- You can map same resource multiple times. It is ref-counted internally.
- Mapping is thread-safe.
- Unmapping is not required before resource destruction.
- Unmapping may not be required before using written data - some heap types on
  some platforms support resources persistently mapped.

When using this library, you can map and use your resources normally without
considering whether they are created as committed resources or placed resources in one large heap.

Example for buffer created and filled in `UPLOAD` heap type:

\code
const UINT64 bufSize = 65536;
const float* bufData = (...);

D3D12_RESOURCE_DESC resourceDesc = {};
resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
resourceDesc.Alignment = 0;
resourceDesc.Width = bufSize;
resourceDesc.Height = 1;
resourceDesc.DepthOrArraySize = 1;
resourceDesc.MipLevels = 1;
resourceDesc.Format = DXGI_FORMAT_UNKNOWN;
resourceDesc.SampleDesc.Count = 1;
resourceDesc.SampleDesc.Quality = 0;
resourceDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;
resourceDesc.Flags = D3D12_RESOURCE_FLAG_NONE;

D3D12MA::ALLOCATION_DESC allocationDesc = {};
allocationDesc.HeapType = D3D12_HEAP_TYPE_UPLOAD;

D3D12Resource* resource;
D3D12MA::Allocation* allocation;
HRESULT hr = allocator->CreateResource(
    &allocationDesc,
    &resourceDesc,
    D3D12_RESOURCE_STATE_GENERIC_READ,
    NULL,
    &allocation,
    IID_PPV_ARGS(&resource));

void* mappedPtr;
hr = resource->Map(0, NULL, &mappedPtr);

memcpy(mappedPtr, bufData, bufSize);

resource->Unmap(0, NULL);
\endcode


\page resource_aliasing Resource aliasing (overlap)

New explicit graphics APIs (Vulkan and Direct3D 12), thanks to manual memory
management, give an opportunity to alias (overlap) multiple resources in the
same region of memory - a feature not available in the old APIs (Direct3D 11, OpenGL).
It can be useful to save video memory, but it must be used with caution.

For example, if you know the flow of your whole render frame in advance, you
are going to use some intermediate textures or buffers only during a small range of render passes,
and you know these ranges don't overlap in time, you can create these resources in
the same place in memory, even if they have completely different parameters (width, height, format etc.).

![Resource aliasing (overlap)](../gfx/Aliasing.png)

Such scenario is possible using D3D12MA, but you need to create your resources
using special function D3D12MA::Allocator::CreateAliasingResource.
Before that, you need to allocate memory with parameters calculated using formula:

- allocation size = max(size of each resource)
- allocation alignment = max(alignment of each resource)

Following example shows two different textures created in the same place in memory,
allocated to fit largest of them.

\code
D3D12_RESOURCE_DESC resDesc1 = {};
resDesc1.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
resDesc1.Alignment = 0;
resDesc1.Width = 1920;
resDesc1.Height = 1080;
resDesc1.DepthOrArraySize = 1;
resDesc1.MipLevels = 1;
resDesc1.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
resDesc1.SampleDesc.Count = 1;
resDesc1.SampleDesc.Quality = 0;
resDesc1.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN;
resDesc1.Flags = D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET | D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS;

D3D12_RESOURCE_DESC resDesc2 = {};
resDesc2.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
resDesc2.Alignment = 0;
resDesc2.Width = 1024;
resDesc2.Height = 1024;
resDesc2.DepthOrArraySize = 1;
resDesc2.MipLevels = 0;
resDesc2.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
resDesc2.SampleDesc.Count = 1;
resDesc2.SampleDesc.Quality = 0;
resDesc2.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN;
resDesc2.Flags = D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET;

const D3D12_RESOURCE_ALLOCATION_INFO allocInfo1 =
    device->GetResourceAllocationInfo(0, 1, &resDesc1);
const D3D12_RESOURCE_ALLOCATION_INFO allocInfo2 =
    device->GetResourceAllocationInfo(0, 1, &resDesc2);

D3D12_RESOURCE_ALLOCATION_INFO finalAllocInfo = {};
finalAllocInfo.Alignment = std::max(allocInfo1.Alignment, allocInfo2.Alignment);
finalAllocInfo.SizeInBytes = std::max(allocInfo1.SizeInBytes, allocInfo2.SizeInBytes);

D3D12MA::ALLOCATION_DESC allocDesc = {};
allocDesc.HeapType = D3D12_HEAP_TYPE_DEFAULT;
allocDesc.ExtraHeapFlags = D3D12_HEAP_FLAG_ALLOW_ONLY_RT_DS_TEXTURES;

D3D12MA::Allocation* alloc;
hr = allocator->AllocateMemory(&allocDesc, &finalAllocInfo, &alloc);
assert(alloc != NULL && alloc->GetHeap() != NULL);

ID3D12Resource* res1;
hr = allocator->CreateAliasingResource(
    alloc,
    0, // AllocationLocalOffset
    &resDesc1,
    D3D12_RESOURCE_STATE_COMMON,
    NULL, // pOptimizedClearValue
    IID_PPV_ARGS(&res1));

ID3D12Resource* res2;
hr = allocator->CreateAliasingResource(
    alloc,
    0, // AllocationLocalOffset
    &resDesc2,
    D3D12_RESOURCE_STATE_COMMON,
    NULL, // pOptimizedClearValue
    IID_PPV_ARGS(&res2));

// You can use res1 and res2, but not at the same time!

res2->Release();
res1->Release();
alloc->Release();
\endcode

Remember that using resouces that alias in memory requires proper synchronization.
You need to issue a special barrier of type `D3D12_RESOURCE_BARRIER_TYPE_ALIASING`.
You also need to treat a resource after aliasing as uninitialized - containing garbage data.
For example, if you use `res1` and then want to use `res2`, you need to first initialize `res2`
using either Clear, Discard, or Copy to the entire resource.

Additional considerations:

- D3D12 also allows to interpret contents of memory between aliasing resources consistently in some cases,
  which is called "data inheritance". For details, see
  Microsoft documentation, chapter [Memory Aliasing and Data Inheritance](https://docs.microsoft.com/en-us/windows/win32/direct3d12/memory-aliasing-and-data-inheritance).
- You can create more complex layout where different textures and buffers are bound
  at different offsets inside one large allocation. For example, one can imagine
  a big texture used in some render passes, aliasing with a set of many small buffers
  used in some further passes. To bind a resource at non-zero offset of an allocation,
  call D3D12MA::Allocator::CreateAliasingResource with appropriate value of `AllocationLocalOffset` parameter.
- Resources of the three categories: buffers, textures with `RENDER_TARGET` or `DEPTH_STENCIL` flags, and all other textures,
  can be placed in the same memory only when `allocator->GetD3D12Options().ResourceHeapTier >= D3D12_RESOURCE_HEAP_TIER_2`.
  Otherwise they must be placed in different memory heap types, and thus aliasing them is not possible.


\page reserving_memory Reserving minimum amount of memory

The library automatically allocates and frees memory heaps.
It also applies some hysteresis so that it doesn't allocate and free entire heap
when you repeatedly create and release a single resource.
However, if you want to make sure certain number of bytes is always allocated as heaps in a specific pool,
you can use functions designed for this purpose:

- For default heaps use D3D12MA::Allocator::SetDefaultHeapMinBytes.
- For custom heaps use D3D12MA::Pool::SetMinBytes.

Default is 0. You can change this parameter any time.
Setting it to higher value may cause new heaps to be allocated.
If this allocation fails, the function returns appropriate error code, but the parameter remains set to the new value.
Setting it to lower value may cause some empty heaps to be released.

You can always call D3D12MA::Allocator::SetDefaultHeapMinBytes for 3 sets of heap flags separately:
`D3D12_HEAP_FLAG_ALLOW_ONLY_BUFFERS`, `D3D12_HEAP_FLAG_ALLOW_ONLY_NON_RT_DS_TEXTURES`, `D3D12_HEAP_FLAG_ALLOW_ONLY_RT_DS_TEXTURES`.
When ResourceHeapTier = 2, so that all types of resourced are kept together,
these 3 values as simply summed up to calculate minimum amount of bytes for default pool with certain heap type.
Alternatively, when ResourceHeapTier = 2, you can call this function with
`D3D12_HEAP_FLAG_ALLOW_ALL_BUFFERS_AND_TEXTURES` = 0. This will set a single value for the default pool and
will override the sum of those three.

Reservation of minimum number of bytes interacts correctly with
D3D12MA::POOL_DESC::MinBlockCount and D3D12MA::POOL_DESC::MaxBlockCount.
For example, free blocks (heaps) of a custom pool will be released only when
their number doesn't fall below `MinBlockCount` and their sum size doesn't fall below `MinBytes`.

Some restrictions apply:

- Setting `MinBytes` doesn't interact with memory budget. The allocator tries
  to create additional heaps when necessary without checking if they will exceed the budget.
- Resources created as committed don't count into the number of bytes compared with `MinBytes` set.
  Only placed resources are considered.


\page virtual_allocator Virtual allocator

As an extra feature, the core allocation algorithm of the library is exposed through a simple and convenient API of "virtual allocator".
It doesn't allocate any real GPU memory. It just keeps track of used and free regions of a "virtual block".
You can use it to allocate your own memory or other objects, even completely unrelated to D3D12.
A common use case is sub-allocation of pieces of one large GPU buffer.

\section virtual_allocator_creating_virtual_block Creating virtual block

To use this functionality, there is no main "allocator" object.
You don't need to have D3D12MA::Allocator object created.
All you need to do is to create a separate D3D12MA::VirtualBlock object for each block of memory you want to be managed by the allocator:

-# Fill in D3D12MA::ALLOCATOR_DESC structure.
-# Call D3D12MA::CreateVirtualBlock. Get new D3D12MA::VirtualBlock object.

Example:

\code
D3D12MA::VIRTUAL_BLOCK_DESC blockDesc = {};
blockDesc.Size = 1048576; // 1 MB

D3D12MA::VirtualBlock *block;
HRESULT hr = CreateVirtualBlock(&blockDesc, &block);
\endcode

\section virtual_allocator_making_virtual_allocations Making virtual allocations

D3D12MA::VirtualBlock object contains internal data structure that keeps track of free and occupied regions
using the same code as the main D3D12 memory allocator.
However, there is no "virtual allocation" object.
When you request a new allocation, a `UINT64` number is returned.
It is an offset inside the block where the allocation has been placed, but it also uniquely identifies the allocation within this block.

In order to make an allocation:

-# Fill in D3D12MA::VIRTUAL_ALLOCATION_DESC structure.
-# Call D3D12MA::VirtualBlock::Allocate. Get new `UINT64 offset` that identifies the allocation.

Example:

\code
D3D12MA::VIRTUAL_ALLOCATION_DESC allocDesc = {};
allocDesc.Size = 4096; // 4 KB

UINT64 allocOffset;
hr = block->Allocate(&allocDesc, &allocOffset);
if(SUCCEEDED(hr))
{
    // Use the 4 KB of your memory starting at allocOffset.
}
else
{
    // Allocation failed - no space for it could be found. Handle this error!
}
\endcode

\section virtual_allocator_deallocation Deallocation

When no longer needed, an allocation can be freed by calling D3D12MA::VirtualBlock::FreeAllocation.
You can only pass to this function the exact offset that was previously returned by D3D12MA::VirtualBlock::Allocate
and not any other location within the memory.

When whole block is no longer needed, the block object can be released by calling D3D12MA::VirtualBlock::Release.
All allocations must be freed before the block is destroyed, which is checked internally by an assert.
However, if you don't want to call `block->FreeAllocation` for each allocation, you can use D3D12MA::VirtualBlock::Clear to free them all at once -
a feature not available in normal D3D12 memory allocator. Example:

\code
block->FreeAllocation(allocOffset);
block->Release();
\endcode

\section virtual_allocator_allocation_parameters Allocation parameters

You can attach a custom pointer to each allocation by using D3D12MA::VirtualBlock::SetAllocationUserData.
Its default value is `NULL`.
It can be used to store any data that needs to be associated with that allocation - e.g. an index, a handle, or a pointer to some
larger data structure containing more information. Example:

\code
struct CustomAllocData
{
    std::string m_AllocName;
};
CustomAllocData* allocData = new CustomAllocData();
allocData->m_AllocName = "My allocation 1";
block->SetAllocationUserData(allocOffset, allocData);
\endcode

The pointer can later be fetched, along with allocation size, by passing the allocation offset to function
D3D12MA::VirtualBlock::GetAllocationInfo and inspecting returned structure D3D12MA::VIRTUAL_ALLOCATION_INFO.
If you allocated a new object to be used as the custom pointer, don't forget to delete that object before freeing the allocation!
Example:

\code
VIRTUAL_ALLOCATION_INFO allocInfo;
block->GetAllocationInfo(allocOffset, &allocInfo);
delete (CustomAllocData*)allocInfo.pUserData;

block->FreeAllocation(allocOffset);
\endcode

\section virtual_allocator_alignment_and_units Alignment and units

It feels natural to express sizes and offsets in bytes.
If an offset of an allocation needs to be aligned to a multiply of some number (e.g. 4 bytes), you can fill optional member
D3D12MA::VIRTUAL_ALLOCATION_DESC::Alignment to request it. Example:

\code
D3D12MA::VIRTUAL_ALLOCATION_DESC allocDesc = {};
allocDesc.Size = 4096; // 4 KB
allocDesc.Alignment = 4; // Returned offset must be a multiply of 4 B

UINT64 allocOffset;
hr = block->Allocate(&allocDesc, &allocOffset);
\endcode

Alignments of different allocations made from one block may vary.
However, if all alignments and sizes are always multiply of some size e.g. 4 B or `sizeof(MyDataStruct)`,
you can express all sizes, alignments, and offsets in multiples of that size instead of individual bytes.
It might be more convenient, but you need to make sure to use this new unit consistently in all the places:

- D3D12MA::VIRTUAL_BLOCK_DESC::Size
- D3D12MA::VIRTUAL_ALLOCATION_DESC::Size and D3D12MA::VIRTUAL_ALLOCATION_DESC::Alignment
- Using offset returned by D3D12MA::VirtualBlock::Allocate

\section virtual_allocator_statistics Statistics

You can obtain statistics of a virtual block using D3D12MA::VirtualBlock::CalculateStats.
The function fills structure D3D12MA::StatInfo - same as used by the normal D3D12 memory allocator.
Example:

\code
D3D12MA::StatInfo statInfo;
block->CalculateStats(&statInfo);
printf("My virtual block has %llu bytes used by %u virtual allocations\n",
    statInfo.UsedBytes, statInfo.AllocationCount);
\endcode

You can also request a full list of allocations and free regions as a string in JSON format by calling
D3D12MA::VirtualBlock::BuildStatsString.
Returned string must be later freed using D3D12MA::VirtualBlock::FreeStatsString.
The format of this string may differ from the one returned by the main D3D12 allocator, but it is similar.

\section virtual_allocator_additional_considerations Additional considerations

Note that the "virtual allocator" functionality is implemented on a level of individual memory blocks.
Keeping track of a whole collection of blocks, allocating new ones when out of free space,
deleting empty ones, and deciding which one to try first for a new allocation must be implemented by the user.


\page configuration Configuration

Please check file `D3D12MemAlloc.cpp` lines between "Configuration Begin" and
"Configuration End" to find macros that you can define to change the behavior of
the library, primarily for debugging purposes.

\section custom_memory_allocator Custom CPU memory allocator

If you use custom allocator for CPU memory rather than default C++ operator `new`
and `delete` or `malloc` and `free` functions, you can make this library using
your allocator as well by filling structure D3D12MA::ALLOCATION_CALLBACKS and
passing it as optional member D3D12MA::ALLOCATOR_DESC::pAllocationCallbacks.
Functions pointed there will be used by the library to make any CPU-side
allocations. Example:

\code
#include <malloc.h>

void* CustomAllocate(size_t Size, size_t Alignment, void* pUserData)
{
    void* memory = _aligned_malloc(Size, Alignment);
    // Your extra bookkeeping here...
    return memory;
}

void CustomFree(void* pMemory, void* pUserData)
{
    // Your extra bookkeeping here...
    _aligned_free(pMemory);
}

(...)

D3D12MA::ALLOCATION_CALLBACKS allocationCallbacks = {};
allocationCallbacks.pAllocate = &CustomAllocate;
allocationCallbacks.pFree = &CustomFree;

D3D12MA::ALLOCATOR_DESC allocatorDesc = {};
allocatorDesc.pDevice = device;
allocatorDesc.pAdapter = adapter;
allocatorDesc.pAllocationCallbacks = &allocationCallbacks;

D3D12MA::Allocator* allocator;
HRESULT hr = D3D12MA::CreateAllocator(&allocatorDesc, &allocator);
\endcode


\page general_considerations General considerations

\section general_considerations_thread_safety Thread safety

- The library has no global state, so separate D3D12MA::Allocator objects can be used independently.
  In typical applications there should be no need to create multiple such objects though - one per `ID3D12Device` is enough.
- All calls to methods of D3D12MA::Allocator class are safe to be made from multiple
  threads simultaneously because they are synchronized internally when needed.
- When the allocator is created with D3D12MA::ALLOCATOR_FLAG_SINGLETHREADED,
  calls to methods of D3D12MA::Allocator class must be made from a single thread or synchronized by the user.
  Using this flag may improve performance.

\section general_considerations_future_plans Future plans

Features planned for future releases:

Near future: feature parity with [Vulkan Memory Allocator](https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator/), including:

- Alternative allocation algorithms: linear allocator, buddy allocator
- Support for priorities using `ID3D12Device1::SetResidencyPriority`

Later:

- Memory defragmentation
- Support for multi-GPU (multi-adapter)

\section general_considerations_features_not_supported Features not supported

Features deliberately excluded from the scope of this library:

- Descriptor allocation. Although also called "heaps", objects that represent
  descriptors are separate part of the D3D12 API from buffers and textures.
- Support for `D3D12_HEAP_TYPE_CUSTOM`. Only the default heap types are supported:
  `UPLOAD`, `DEFAULT`, `READBACK`.
- Support for reserved (tiled) resources. We don't recommend using them.
- Support for `ID3D12Device::Evict` and `MakeResident`. We don't recommend using them.
- Handling CPU memory allocation failures. When dynamically creating small C++
  objects in CPU memory (not the GPU memory), allocation failures are not
  handled gracefully, because that would complicate code significantly and
  is usually not needed in desktop PC applications anyway.
  Success of an allocation is just checked with an assert.
- Code free of any compiler warnings - especially those that would require complicating the code
  just to please the compiler complaining about unused parameters, variables, or expressions being
  constant in Relese configuration, e.g. because they are only used inside an assert.
- This is a C++ library.
  Bindings or ports to any other programming languages are welcomed as external projects and
  are not going to be included into this repository.
*/

// Define this macro to 0 to disable usage of DXGI 1.4 (needed for IDXGIAdapter3 and query for memory budget).
#ifndef D3D12MA_DXGI_1_4
    #ifdef __IDXGIAdapter3_INTERFACE_DEFINED__
        #define D3D12MA_DXGI_1_4 1
    #else
        #define D3D12MA_DXGI_1_4 0
    #endif
#endif

// If using this library on a platform different than Windows PC, you should
// include D3D12-compatible header before this library on your own and define this macro.
#ifndef D3D12MA_D3D12_HEADERS_ALREADY_INCLUDED
    #include <d3d12.h>
    #include <dxgi.h>
#endif

/*
When defined to value other than 0, the library will try to use
D3D12_SMALL_RESOURCE_PLACEMENT_ALIGNMENT or D3D12_SMALL_MSAA_RESOURCE_PLACEMENT_ALIGNMENT
for created textures when possible, which can save memory because some small textures
may get their alignment 4K and their size a multiply of 4K instead of 64K.

#define D3D12MA_USE_SMALL_RESOURCE_PLACEMENT_ALIGNMENT 0
    Disables small texture alignment.
#define D3D12MA_USE_SMALL_RESOURCE_PLACEMENT_ALIGNMENT 1
    Enables conservative algorithm that will use small alignment only for some textures
    that are surely known to support it.
#define D3D12MA_USE_SMALL_RESOURCE_PLACEMENT_ALIGNMENT 2
    Enables query for small alignment to D3D12 (based on Microsoft sample) which will
    enable small alignment for more textures, but will also generate D3D Debug Layer
    error #721 on call to ID3D12Device::GetResourceAllocationInfo, which you should just
    ignore.
*/
#ifndef D3D12MA_USE_SMALL_RESOURCE_PLACEMENT_ALIGNMENT
    #define D3D12MA_USE_SMALL_RESOURCE_PLACEMENT_ALIGNMENT 1
#endif

/// \cond INTERNAL

#define D3D12MA_CLASS_NO_COPY(className) \
    private: \
        className(const className&) = delete; \
        className(className&&) = delete; \
        className& operator=(const className&) = delete; \
        className& operator=(className&&) = delete;

// To be used with MAKE_HRESULT to define custom error codes.
#define FACILITY_D3D12MA 3542

/// \endcond

namespace D3D12MA
{

/// \cond INTERNAL
class AllocatorPimpl;
class PoolPimpl;
class NormalBlock;
class BlockVector;
class JsonWriter;
class VirtualBlockPimpl;
/// \endcond

class Pool;
class Allocator;
struct StatInfo;

/// Pointer to custom callback function that allocates CPU memory.
typedef void* (*ALLOCATE_FUNC_PTR)(size_t Size, size_t Alignment, void* pUserData);
/**
\brief Pointer to custom callback function that deallocates CPU memory.

`pMemory = null` should be accepted and ignored.
*/
typedef void (*FREE_FUNC_PTR)(void* pMemory, void* pUserData);

/// Custom callbacks to CPU memory allocation functions.
struct ALLOCATION_CALLBACKS
{
    /// %Allocation function.
    ALLOCATE_FUNC_PTR pAllocate;
    /// Dellocation function.
    FREE_FUNC_PTR pFree;
    /// Custom data that will be passed to allocation and deallocation functions as `pUserData` parameter.
    void* pUserData;
};

/// \brief Bit flags to be used with ALLOCATION_DESC::Flags.
typedef enum ALLOCATION_FLAGS
{
    /// Zero
    ALLOCATION_FLAG_NONE = 0,

    /**
    Set this flag if the allocation should have its own dedicated memory allocation (committed resource with implicit heap).
    
    Use it for special, big resources, like fullscreen textures used as render targets.
    */
    ALLOCATION_FLAG_COMMITTED = 0x1,

    /**
    Set this flag to only try to allocate from existing memory heaps and never create new such heap.

    If new allocation cannot be placed in any of the existing heaps, allocation
    fails with `E_OUTOFMEMORY` error.

    You should not use D3D12MA::ALLOCATION_FLAG_COMMITTED and
    D3D12MA::ALLOCATION_FLAG_NEVER_ALLOCATE at the same time. It makes no sense.
    */
    ALLOCATION_FLAG_NEVER_ALLOCATE = 0x2,

    /** Create allocation only if additional memory required for it, if any, won't exceed
    memory budget. Otherwise return `E_OUTOFMEMORY`.
    */
    ALLOCATION_FLAG_WITHIN_BUDGET = 0x4,
} ALLOCATION_FLAGS;

/// \brief Parameters of created D3D12MA::Allocation object. To be used with Allocator::CreateResource.
struct ALLOCATION_DESC
{
    /// Flags.
    ALLOCATION_FLAGS Flags;
    /** \brief The type of memory heap where the new allocation should be placed.

    It must be one of: `D3D12_HEAP_TYPE_DEFAULT`, `D3D12_HEAP_TYPE_UPLOAD`, `D3D12_HEAP_TYPE_READBACK`.

    When D3D12MA::ALLOCATION_DESC::CustomPool != NULL this member is ignored.
    */
    D3D12_HEAP_TYPE HeapType;
    /** \brief Additional heap flags to be used when allocating memory.

    In most cases it can be 0.
    
    - If you use D3D12MA::Allocator::CreateResource(), you don't need to care.
      Necessary flag `D3D12_HEAP_FLAG_ALLOW_ONLY_BUFFERS`, `D3D12_HEAP_FLAG_ALLOW_ONLY_NON_RT_DS_TEXTURES`,
      or `D3D12_HEAP_FLAG_ALLOW_ONLY_RT_DS_TEXTURES` is added automatically.
    - If you use D3D12MA::Allocator::AllocateMemory(), you should specify one of those `ALLOW_ONLY` flags.
      Except when you validate that D3D12MA::Allocator::GetD3D12Options()`.ResourceHeapTier == D3D12_RESOURCE_HEAP_TIER_1` -
      then you can leave it 0.
    - You can specify additional flags if needed. Then the memory will always be allocated as
      separate block using `D3D12Device::CreateCommittedResource` or `CreateHeap`, not as part of an existing larget block.

    When D3D12MA::ALLOCATION_DESC::CustomPool != NULL this member is ignored.
    */
    D3D12_HEAP_FLAGS ExtraHeapFlags;
    /** \brief Custom pool to place the new resource in. Optional.

    When not NULL, the resource will be created inside specified custom pool.
    It will then never be created as committed.
    */
    Pool* CustomPool;
};

/** \brief Represents single memory allocation.

It may be either implicit memory heap dedicated to a single resource or a
specific region of a bigger heap plus unique offset.

To create such object, fill structure D3D12MA::ALLOCATION_DESC and call function
Allocator::CreateResource.

The object remembers size and some other information.
To retrieve this information, use methods of this class.

The object also remembers `ID3D12Resource` and "owns" a reference to it,
so it calls `%Release()` on the resource when destroyed.
*/
class Allocation
{
public:
    /** \brief Deletes this object.

    This function must be used instead of destructor, which is private.
    There is no reference counting involved.
    */
    void Release();

    /** \brief Returns offset in bytes from the start of memory heap.

    You usually don't need to use this offset. If you create a buffer or a texture together with the allocation using function
    D3D12MA::Allocator::CreateResource, functions that operate on that resource refer to the beginning of the resource,
    not entire memory heap.

    If the Allocation represents committed resource with implicit heap, returns 0.
    */
    UINT64 GetOffset() const;

    /** \brief Returns size in bytes of the allocation.

    - If you created a buffer or a texture together with the allocation using function D3D12MA::Allocator::CreateResource,
      this is the size of the resource returned by `ID3D12Device::GetResourceAllocationInfo`.
    - For allocations made out of bigger memory blocks, this also is the size of the memory region assigned exclusively to this allocation.
    - For resources created as committed, this value may not be accurate. DirectX implementation may optimize memory usage internally
      so that you may even observe regions of `ID3D12Resource::GetGPUVirtualAddress()` + Allocation::GetSize() to overlap in memory and still work correctly.
    */
    UINT64 GetSize() const { return m_Size; }

    /** \brief Returns D3D12 resource associated with this object.

    Calling this method doesn't increment resource's reference counter.
    */
    ID3D12Resource* GetResource() const { return m_Resource; }

    /** \brief Returns memory heap that the resource is created in.

    If the Allocation represents committed resource with implicit heap, returns NULL.
    */
    ID3D12Heap* GetHeap() const;

    /** \brief Associates a name with the allocation object. This name is for use in debug diagnostics and tools.

    Internal copy of the string is made, so the memory pointed by the argument can be
    changed of freed immediately after this call.

    `Name` can be null.
    */
    void SetName(LPCWSTR Name);

    /** \brief Returns the name associated with the allocation object.

    Returned string points to an internal copy.

    If no name was associated with the allocation, returns null.
    */
    LPCWSTR GetName() const { return m_Name; }

    /** \brief Returns `TRUE` if the memory of the allocation was filled with zeros when the allocation was created.

    Returns `TRUE` only if the allocator is sure that the entire memory where the
    allocation was created was filled with zeros at the moment the allocation was made.
    
    Returns `FALSE` if the memory could potentially contain garbage data.
    If it's a render-target or depth-stencil texture, it then needs proper
    initialization with `ClearRenderTargetView`, `ClearDepthStencilView`, `DiscardResource`,
    or a copy operation, as described on page:
    [ID3D12Device::CreatePlacedResource method - Notes on the required resource initialization](https://docs.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createplacedresource#notes-on-the-required-resource-initialization).
    Please note that rendering a fullscreen triangle or quad to the texture as
    a render target is not a proper way of initialization!

    See also articles:
    ["Coming to DirectX 12: More control over memory allocation"](https://devblogs.microsoft.com/directx/coming-to-directx-12-more-control-over-memory-allocation/),
    ["Initializing DX12 Textures After Allocation and Aliasing"](https://asawicki.info/news_1724_initializing_dx12_textures_after_allocation_and_aliasing).
    */
    BOOL WasZeroInitialized() const { return m_PackedData.WasZeroInitialized(); }

private:
    friend class AllocatorPimpl;
    friend class BlockVector;
    friend class JsonWriter;
    friend struct CommittedAllocationListItemTraits;
    template<typename T> friend void D3D12MA_DELETE(const ALLOCATION_CALLBACKS&, T*);
    template<typename T> friend class PoolAllocator;

    enum Type
    {
        TYPE_COMMITTED,
        TYPE_PLACED,
        TYPE_HEAP,
        TYPE_COUNT
    };

    AllocatorPimpl* m_Allocator;
    UINT64 m_Size;
    ID3D12Resource* m_Resource;
    UINT m_CreationFrameIndex;
    wchar_t* m_Name;

    union
    {
        struct
        {
            D3D12_HEAP_TYPE heapType;
            Allocation* prev;
            Allocation* next;
        } m_Committed;

        struct
        {
            UINT64 offset;
            NormalBlock* block;
        } m_Placed;

        struct
        {
            // Beginning must be compatible with m_Committed.
            D3D12_HEAP_TYPE heapType;
            Allocation* prev;
            Allocation* next;
            ID3D12Heap* heap;
        } m_Heap;
    };

    struct PackedData
    {
    public:
        PackedData() :
            m_Type(0), m_ResourceDimension(0), m_ResourceFlags(0), m_TextureLayout(0), m_WasZeroInitialized(0) { }

        Type GetType() const { return (Type)m_Type; }
        D3D12_RESOURCE_DIMENSION GetResourceDimension() const { return (D3D12_RESOURCE_DIMENSION)m_ResourceDimension; }
        D3D12_RESOURCE_FLAGS GetResourceFlags() const { return (D3D12_RESOURCE_FLAGS)m_ResourceFlags; }
        D3D12_TEXTURE_LAYOUT GetTextureLayout() const { return (D3D12_TEXTURE_LAYOUT)m_TextureLayout; }
        BOOL WasZeroInitialized() const { return (BOOL)m_WasZeroInitialized; }

        void SetType(Type type);
        void SetResourceDimension(D3D12_RESOURCE_DIMENSION resourceDimension);
        void SetResourceFlags(D3D12_RESOURCE_FLAGS resourceFlags);
        void SetTextureLayout(D3D12_TEXTURE_LAYOUT textureLayout);
        void SetWasZeroInitialized(BOOL wasZeroInitialized) { m_WasZeroInitialized = wasZeroInitialized ? 1 : 0; }

    private:
        UINT m_Type : 2;               // enum Type
        UINT m_ResourceDimension : 3;  // enum D3D12_RESOURCE_DIMENSION
        UINT m_ResourceFlags : 24;     // flags D3D12_RESOURCE_FLAGS
        UINT m_TextureLayout : 9;      // enum D3D12_TEXTURE_LAYOUT
        UINT m_WasZeroInitialized : 1; // BOOL
    } m_PackedData;

    Allocation(AllocatorPimpl* allocator, UINT64 size, BOOL wasZeroInitialized);
    ~Allocation();
    void InitCommitted(D3D12_HEAP_TYPE heapType);
    void InitPlaced(UINT64 offset, UINT64 alignment, NormalBlock* block);
    void InitHeap(D3D12_HEAP_TYPE heapType, ID3D12Heap* heap);
    template<typename D3D12_RESOURCE_DESC_T>
    void SetResource(ID3D12Resource* resource, const D3D12_RESOURCE_DESC_T* pResourceDesc);
    void FreeName();

    D3D12MA_CLASS_NO_COPY(Allocation)
};

/// \brief Parameters of created D3D12MA::Pool object. To be used with D3D12MA::Allocator::CreatePool.
struct POOL_DESC
{
    /** \brief The type of memory heap where allocations of this pool should be placed.

    It must be one of: `D3D12_HEAP_TYPE_DEFAULT`, `D3D12_HEAP_TYPE_UPLOAD`, `D3D12_HEAP_TYPE_READBACK`.
    */
    D3D12_HEAP_TYPE HeapType;
    /** \brief Heap flags to be used when allocating heaps of this pool.

    It should contain one of these values, depending on type of resources you are going to create in this heap:
    `D3D12_HEAP_FLAG_ALLOW_ONLY_BUFFERS`,
    `D3D12_HEAP_FLAG_ALLOW_ONLY_NON_RT_DS_TEXTURES`,
    `D3D12_HEAP_FLAG_ALLOW_ONLY_RT_DS_TEXTURES`.
    Except if ResourceHeapTier = 2, then it may be `D3D12_HEAP_FLAG_ALLOW_ALL_BUFFERS_AND_TEXTURES` = 0.
    
    You can specify additional flags if needed.
    */
    D3D12_HEAP_FLAGS HeapFlags;
    /** \brief Size of a single heap (memory block) to be allocated as part of this pool, in bytes. Optional.

    Specify nonzero to set explicit, constant size of memory blocks used by this pool.
    Leave 0 to use default and let the library manage block sizes automatically.
    Then sizes of particular blocks may vary.
    */
    UINT64 BlockSize;
    /** \brief Minimum number of heaps (memory blocks) to be always allocated in this pool, even if they stay empty. Optional.

    Set to 0 to have no preallocated blocks and allow the pool be completely empty.
    */
    UINT MinBlockCount;
    /** \brief Maximum number of heaps (memory blocks) that can be allocated in this pool. Optional.

    Set to 0 to use default, which is `UINT64_MAX`, which means no limit.

    Set to same value as D3D12MA::POOL_DESC::MinBlockCount to have fixed amount of memory allocated
    throughout whole lifetime of this pool.
    */
    UINT MaxBlockCount;
};

/** \brief Custom memory pool

Represents a separate set of heaps (memory blocks) that can be used to create
D3D12MA::Allocation-s and resources in it. Usually there is no need to create custom
pools - creating resources in default pool is sufficient.

To create custom pool, fill D3D12MA::POOL_DESC and call D3D12MA::Allocator::CreatePool.
*/
class Pool
{
public:
    /** \brief Deletes pool object, frees D3D12 heaps (memory blocks) managed by it. Allocations and resources must already be released!

    It doesn't delete allocations and resources created in this pool. They must be all
    released before calling this function!
    */
    void Release();
    
    /** \brief Returns copy of parameters of the pool.

    These are the same parameters as passed to D3D12MA::Allocator::CreatePool.
    */
    POOL_DESC GetDesc() const;

    /** \brief Sets the minimum number of bytes that should always be allocated (reserved) in this pool.

    See also: \subpage reserving_memory.
    */
    HRESULT SetMinBytes(UINT64 minBytes);

    /** \brief Retrieves statistics from the current state of this pool.
    */
    void CalculateStats(StatInfo* pStats);

    /** \brief Associates a name with the pool. This name is for use in debug diagnostics and tools.

    Internal copy of the string is made, so the memory pointed by the argument can be
    changed of freed immediately after this call.

    `Name` can be NULL.
    */
    void SetName(LPCWSTR Name);

    /** \brief Returns the name associated with the pool object.

    Returned string points to an internal copy.

    If no name was associated with the allocation, returns NULL.
    */
    LPCWSTR GetName() const;

private:
    friend class Allocator;
    friend class AllocatorPimpl;
    template<typename T> friend void D3D12MA_DELETE(const ALLOCATION_CALLBACKS&, T*);

    PoolPimpl* m_Pimpl;

    Pool(Allocator* allocator, const POOL_DESC &desc);
    ~Pool();

    D3D12MA_CLASS_NO_COPY(Pool)
};

/// \brief Bit flags to be used with ALLOCATOR_DESC::Flags.
typedef enum ALLOCATOR_FLAGS
{
    /// Zero
    ALLOCATOR_FLAG_NONE = 0,

    /**
    Allocator and all objects created from it will not be synchronized internally,
    so you must guarantee they are used from only one thread at a time or
    synchronized by you.

    Using this flag may increase performance because internal mutexes are not used.
    */
    ALLOCATOR_FLAG_SINGLETHREADED = 0x1,

    /**
    Every allocation will have its own memory block.
    To be used for debugging purposes.
   */
    ALLOCATOR_FLAG_ALWAYS_COMMITTED = 0x2,
} ALLOCATOR_FLAGS;

/// \brief Parameters of created Allocator object. To be used with CreateAllocator().
struct ALLOCATOR_DESC
{
    /// Flags.
    ALLOCATOR_FLAGS Flags;
    
    /** Direct3D device object that the allocator should be attached to.

    Allocator is doing `AddRef`/`Release` on this object.
    */
    ID3D12Device* pDevice;
    
    /** \brief Preferred size of a single `ID3D12Heap` block to be allocated.
    
    Set to 0 to use default, which is currently 64 MiB.
    */
    UINT64 PreferredBlockSize;
    
    /** \brief Custom CPU memory allocation callbacks. Optional.

    Optional, can be null. When specified, will be used for all CPU-side memory allocations.
    */
    const ALLOCATION_CALLBACKS* pAllocationCallbacks;

    /** DXGI Adapter object that you use for D3D12 and this allocator.

    Allocator is doing `AddRef`/`Release` on this object.
    */
    IDXGIAdapter* pAdapter;
};

/**
\brief Number of D3D12 memory heap types supported.
*/
const UINT HEAP_TYPE_COUNT = 3;

/**
\brief Calculated statistics of memory usage in entire allocator.
*/
struct StatInfo
{
    /// Number of memory blocks (heaps) allocated.
    UINT BlockCount;
    /// Number of D3D12MA::Allocation objects allocated.
    UINT AllocationCount;
    /// Number of free ranges of memory between allocations.
    UINT UnusedRangeCount;
    /// Total number of bytes occupied by all allocations.
    UINT64 UsedBytes;
    /// Total number of bytes occupied by unused ranges.
    UINT64 UnusedBytes;
    UINT64 AllocationSizeMin;
    UINT64 AllocationSizeAvg;
    UINT64 AllocationSizeMax;
    UINT64 UnusedRangeSizeMin;
    UINT64 UnusedRangeSizeAvg;
    UINT64 UnusedRangeSizeMax;
};

/**
\brief General statistics from the current state of the allocator.
*/
struct Stats
{
    /// Total statistics from all heap types.
    StatInfo Total;
    /**
    One StatInfo for each type of heap located at the following indices:
    0 - DEFAULT, 1 - UPLOAD, 2 - READBACK.
    */
    StatInfo HeapType[HEAP_TYPE_COUNT];
};

/** \brief Statistics of current memory usage and available budget, in bytes, for GPU or CPU memory.
*/
struct Budget
{
    /** \brief Sum size of all memory blocks allocated from particular heap type, in bytes.
    */
    UINT64 BlockBytes;

    /** \brief Sum size of all allocations created in particular heap type, in bytes.

    Always less or equal than `BlockBytes`.
    Difference `BlockBytes - AllocationBytes` is the amount of memory allocated but unused -
    available for new allocations or wasted due to fragmentation.
    */
    UINT64 AllocationBytes;

    /** \brief Estimated current memory usage of the program, in bytes.

    Fetched from system using `IDXGIAdapter3::QueryVideoMemoryInfo` if enabled.

    It might be different than `BlockBytes` (usually higher) due to additional implicit objects
    also occupying the memory, like swapchain, pipeline state objects, descriptor heaps, command lists, or
    memory blocks allocated outside of this library, if any.
    */
    UINT64 UsageBytes;

    /** \brief Estimated amount of memory available to the program, in bytes.

    Fetched from system using `IDXGIAdapter3::QueryVideoMemoryInfo` if enabled.

    It might be different (most probably smaller) than memory sizes reported in `DXGI_ADAPTER_DESC` due to factors
    external to the program, like other programs also consuming system resources.
    Difference `BudgetBytes - UsageBytes` is the amount of additional memory that can probably
    be allocated without problems. Exceeding the budget may result in various problems.
    */
    UINT64 BudgetBytes;
};

/**
\brief Represents main object of this library initialized for particular `ID3D12Device`.

Fill structure D3D12MA::ALLOCATOR_DESC and call function CreateAllocator() to create it.
Call method Allocator::Release to destroy it.

It is recommended to create just one object of this type per `ID3D12Device` object,
right after Direct3D 12 is initialized and keep it alive until before Direct3D device is destroyed.
*/
class Allocator
{
public:
    /** \brief Deletes this object.
    
    This function must be used instead of destructor, which is private.
    There is no reference counting involved.
    */
    void Release();
    
    /// Returns cached options retrieved from D3D12 device.
    const D3D12_FEATURE_DATA_D3D12_OPTIONS& GetD3D12Options() const;

    /** \brief Allocates memory and creates a D3D12 resource (buffer or texture). This is the main allocation function.

    The function is similar to `ID3D12Device::CreateCommittedResource`, but it may
    really call `ID3D12Device::CreatePlacedResource` to assign part of a larger,
    existing memory heap to the new resource, which is the main purpose of this
    whole library.

    If `ppvResource` is null, you receive only `ppAllocation` object from this function.
    It holds pointer to `ID3D12Resource` that can be queried using function D3D12MA::Allocation::GetResource().
    Reference count of the resource object is 1.
    It is automatically destroyed when you destroy the allocation object.

    If `ppvResource` is not null, you receive pointer to the resource next to allocation object.
    Reference count of the resource object is then increased by calling `QueryInterface`, so you need to manually `Release` it
    along with the allocation.

    \param pAllocDesc   Parameters of the allocation.
    \param pResourceDesc   Description of created resource.
    \param InitialResourceState   Initial resource state.
    \param pOptimizedClearValue   Optional. Either null or optimized clear value.
    \param[out] ppAllocation   Filled with pointer to new allocation object created.
    \param riidResource   IID of a resource to be returned via `ppvResource`.
    \param[out] ppvResource   Optional. If not null, filled with pointer to new resouce created.

    \note This function creates a new resource. Sub-allocation of parts of one large buffer,
    although recommended as a good practice, is out of scope of this library and could be implemented
    by the user as a higher-level logic on top of it, e.g. using the \ref virtual_allocator feature.
    */
    HRESULT CreateResource(
        const ALLOCATION_DESC* pAllocDesc,
        const D3D12_RESOURCE_DESC* pResourceDesc,
        D3D12_RESOURCE_STATES InitialResourceState,
        const D3D12_CLEAR_VALUE *pOptimizedClearValue,
        Allocation** ppAllocation,
        REFIID riidResource,
        void** ppvResource);

#ifdef __ID3D12Device4_INTERFACE_DEFINED__
    /** \brief Similar to Allocator::CreateResource, but supports additional parameter `pProtectedSession`.
    
    If `pProtectedSession` is not null, current implementation always creates the resource as committed
    using `ID3D12Device4::CreateCommittedResource1`.

    To work correctly, `ID3D12Device4` interface must be available in the current system. Otherwise, `E_NOINTERFACE` is returned.
    */
    HRESULT CreateResource1(
        const ALLOCATION_DESC* pAllocDesc,
        const D3D12_RESOURCE_DESC* pResourceDesc,
        D3D12_RESOURCE_STATES InitialResourceState,
        const D3D12_CLEAR_VALUE *pOptimizedClearValue,
        ID3D12ProtectedResourceSession *pProtectedSession,
        Allocation** ppAllocation,
        REFIID riidResource,
        void** ppvResource);
#endif // #ifdef __ID3D12Device4_INTERFACE_DEFINED__

#ifdef __ID3D12Device8_INTERFACE_DEFINED__
    /** \brief Similar to Allocator::CreateResource1, but supports new structure `D3D12_RESOURCE_DESC1`.
    
    It internally uses `ID3D12Device8::CreateCommittedResource2` or `ID3D12Device8::CreatePlacedResource1`.

    To work correctly, `ID3D12Device8` interface must be available in the current system. Otherwise, `E_NOINTERFACE` is returned.
    */
    HRESULT CreateResource2(
        const ALLOCATION_DESC* pAllocDesc,
        const D3D12_RESOURCE_DESC1* pResourceDesc,
        D3D12_RESOURCE_STATES InitialResourceState,
        const D3D12_CLEAR_VALUE *pOptimizedClearValue,
        ID3D12ProtectedResourceSession *pProtectedSession,
        Allocation** ppAllocation,
        REFIID riidResource,
        void** ppvResource);
#endif // #ifdef __ID3D12Device4_INTERFACE_DEFINED__

    /** \brief Allocates memory without creating any resource placed in it.

    This function is similar to `ID3D12Device::CreateHeap`, but it may really assign
    part of a larger, existing heap to the allocation.

    `pAllocDesc->heapFlags` should contain one of these values, depending on type of resources you are going to create in this memory:
    `D3D12_HEAP_FLAG_ALLOW_ONLY_BUFFERS`,
    `D3D12_HEAP_FLAG_ALLOW_ONLY_NON_RT_DS_TEXTURES`,
    `D3D12_HEAP_FLAG_ALLOW_ONLY_RT_DS_TEXTURES`.
    Except if you validate that ResourceHeapTier = 2 - then `heapFlags`
    may be `D3D12_HEAP_FLAG_ALLOW_ALL_BUFFERS_AND_TEXTURES` = 0.
    Additional flags in `heapFlags` are allowed as well.

    `pAllocInfo->SizeInBytes` must be multiply of 64KB.
    `pAllocInfo->Alignment` must be one of the legal values as described in documentation of `D3D12_HEAP_DESC`.

    If you use D3D12MA::ALLOCATION_FLAG_COMMITTED you will get a separate memory block -
    a heap that always has offset 0.
    */
    HRESULT AllocateMemory(
        const ALLOCATION_DESC* pAllocDesc,
        const D3D12_RESOURCE_ALLOCATION_INFO* pAllocInfo,
        Allocation** ppAllocation);

#ifdef __ID3D12Device4_INTERFACE_DEFINED__
    /** \brief Similar to Allocator::AllocateMemory, but supports additional parameter `pProtectedSession`.
    
    If `pProtectedSession` is not null, current implementation always creates separate heap
    using `ID3D12Device4::CreateHeap1`.

    To work correctly, `ID3D12Device4` interface must be available in the current system. Otherwise, `E_NOINTERFACE` is returned.
    */
    HRESULT AllocateMemory1(
        const ALLOCATION_DESC* pAllocDesc,
        const D3D12_RESOURCE_ALLOCATION_INFO* pAllocInfo,
        ID3D12ProtectedResourceSession *pProtectedSession,
        Allocation** ppAllocation);
#endif // #ifdef __ID3D12Device4_INTERFACE_DEFINED__

    /** \brief Creates a new resource in place of an existing allocation. This is useful for memory aliasing.

    \param pAllocation Existing allocation indicating the memory where the new resource should be created.
        It can be created using D3D12MA::Allocator::CreateResource and already have a resource bound to it,
        or can be a raw memory allocated with D3D12MA::Allocator::AllocateMemory.
        It must not be created as committed so that `ID3D12Heap` is available and not implicit.
    \param AllocationLocalOffset Additional offset in bytes to be applied when allocating the resource.
        Local from the start of `pAllocation`, not the beginning of the whole `ID3D12Heap`!
        If the new resource should start from the beginning of the `pAllocation` it should be 0.
    \param pResourceDesc Description of the new resource to be created.
    \param InitialResourceState
    \param pOptimizedClearValue
    \param riidResource
    \param[out] ppvResource Returns pointer to the new resource.
        The resource is not bound with `pAllocation`.
        This pointer must not be null - you must get the resource pointer and `Release` it when no longer needed.

    Memory requirements of the new resource are checked for validation.
    If its size exceeds the end of `pAllocation` or required alignment is not fulfilled
    considering `pAllocation->GetOffset() + AllocationLocalOffset`, the function
    returns `E_INVALIDARG`.
    */
    HRESULT CreateAliasingResource(
        Allocation* pAllocation,
        UINT64 AllocationLocalOffset,
        const D3D12_RESOURCE_DESC* pResourceDesc,
        D3D12_RESOURCE_STATES InitialResourceState,
        const D3D12_CLEAR_VALUE *pOptimizedClearValue,
        REFIID riidResource,
        void** ppvResource);

    /** \brief Creates custom pool.
    */
    HRESULT CreatePool(
        const POOL_DESC* pPoolDesc,
        Pool** ppPool);

    /** \brief Sets the minimum number of bytes that should always be allocated (reserved) in a specific default pool.

    \param heapType Must be one of: `D3D12_HEAP_TYPE_DEFAULT`, `D3D12_HEAP_TYPE_UPLOAD`, `D3D12_HEAP_TYPE_READBACK`.
    \param heapFlags Must be one of: `D3D12_HEAP_FLAG_ALLOW_ONLY_BUFFERS`, `D3D12_HEAP_FLAG_ALLOW_ONLY_NON_RT_DS_TEXTURES`,
        `D3D12_HEAP_FLAG_ALLOW_ONLY_RT_DS_TEXTURES`. If ResourceHeapTier = 2, it can also be `D3D12_HEAP_FLAG_ALLOW_ALL_BUFFERS_AND_TEXTURES`.
    \param minBytes Minimum number of bytes to keep allocated.

    See also: \subpage reserving_memory.
    */
    HRESULT SetDefaultHeapMinBytes(
        D3D12_HEAP_TYPE heapType,
        D3D12_HEAP_FLAGS heapFlags,
        UINT64 minBytes);

    /** \brief Sets the index of the current frame.

    This function is used to set the frame index in the allocator when a new game frame begins.
    */
    void SetCurrentFrameIndex(UINT frameIndex);

    /** \brief Retrieves statistics from the current state of the allocator.
    */
    void CalculateStats(Stats* pStats);

    /** \brief Retrieves information about current memory budget.

    \param[out] pGpuBudget Optional, can be null.
    \param[out] pCpuBudget Optional, can be null.

    This function is called "get" not "calculate" because it is very fast, suitable to be called
    every frame or every allocation. For more detailed statistics use CalculateStats().

    Note that when using allocator from multiple threads, returned information may immediately
    become outdated.
    */
    void GetBudget(Budget* pGpuBudget, Budget* pCpuBudget);

    /// Builds and returns statistics as a string in JSON format.
    /** @param[out] ppStatsString Must be freed using Allocator::FreeStatsString.
    @param DetailedMap `TRUE` to include full list of allocations (can make the string quite long), `FALSE` to only return statistics.
    */
    void BuildStatsString(WCHAR** ppStatsString, BOOL DetailedMap) const;

    /// Frees memory of a string returned from Allocator::BuildStatsString.
    void FreeStatsString(WCHAR* pStatsString) const;

private:
    friend HRESULT CreateAllocator(const ALLOCATOR_DESC*, Allocator**);
    template<typename T> friend void D3D12MA_DELETE(const ALLOCATION_CALLBACKS&, T*);
    friend class Pool;

    Allocator(const ALLOCATION_CALLBACKS& allocationCallbacks, const ALLOCATOR_DESC& desc);
    ~Allocator();
    
    AllocatorPimpl* m_Pimpl;
    
    D3D12MA_CLASS_NO_COPY(Allocator)
};

/// Parameters of created D3D12MA::VirtualBlock object to be passed to CreateVirtualBlock().
struct VIRTUAL_BLOCK_DESC
{
    /** \brief Total size of the block.

    Sizes can be expressed in bytes or any units you want as long as you are consistent in using them.
    For example, if you allocate from some array of structures, 1 can mean single instance of entire structure.
    */
    UINT64 Size;
    /** \brief Custom CPU memory allocation callbacks. Optional.

    Optional, can be null. When specified, will be used for all CPU-side memory allocations.
    */
    const ALLOCATION_CALLBACKS* pAllocationCallbacks;
};

/// Parameters of created virtual allocation to be passed to VirtualBlock::Allocate().
struct VIRTUAL_ALLOCATION_DESC
{
    /** \brief Size of the allocation.
    
    Cannot be zero.
    */
    UINT64 Size;
    /** \brief Required alignment of the allocation.
    
    Must be power of two. Special value 0 has the same meaning as 1 - means no special alignment is required, so allocation can start at any offset.
    */
    UINT64 Alignment;
    /** \brief Custom pointer to be associated with the allocation.

    It can be fetched or changed later.
    */
    void* pUserData;
};

/// Parameters of an existing virtual allocation, returned by VirtualBlock::GetAllocationInfo().
struct VIRTUAL_ALLOCATION_INFO
{
    /** \brief Size of the allocation.

    Same value as passed in VIRTUAL_ALLOCATION_DESC::Size.
    */
    UINT64 size;
    /** \brief Custom pointer associated with the allocation.

    Same value as passed in VIRTUAL_ALLOCATION_DESC::pUserData or VirtualBlock::SetAllocationUserData().
    */
    void* pUserData;
};

/** \brief Represents pure allocation algorithm and a data structure with allocations in some memory block, without actually allocating any GPU memory.

This class allows to use the core algorithm of the library custom allocations e.g. CPU memory or
sub-allocation regions inside a single GPU buffer.

To create this object, fill in D3D12MA::VIRTUAL_BLOCK_DESC and call CreateVirtualBlock().
To destroy it, call its method VirtualBlock::Release().
*/
class VirtualBlock
{
public:
    /** \brief Destroys this object and frees it from memory.

    You need to free all the allocations within this block or call Clear() before destroying it.
    */
    void Release();

    /** \brief Returns true if the block is empty - contains 0 allocations.
    */
    BOOL IsEmpty() const;
    /** \brief Returns information about an allocation at given offset - its size and custom pointer.
    */
    void GetAllocationInfo(UINT64 offset, VIRTUAL_ALLOCATION_INFO* pInfo) const;

    /** \brief Creates new allocation.
    \param pDesc
    \param[out] pOffset Offset of the new allocation, which can also be treated as an unique identifier of the allocation within this block. `UINT64_MAX` if allocation failed.
    \return `S_OK` if allocation succeeded, `E_OUTOFMEMORY` if it failed.
    */
    HRESULT Allocate(const VIRTUAL_ALLOCATION_DESC* pDesc, UINT64* pOffset);
    /** \brief Frees the allocation at given offset.
    */
    void FreeAllocation(UINT64 offset);
    /** \brief Frees all the allocations.
    */
    void Clear();
    /** \brief Changes custom pointer for an allocation at given offset to a new value.
    */
    void SetAllocationUserData(UINT64 offset, void* pUserData);

    /** \brief Retrieves statistics from the current state of the block.
    */
    void CalculateStats(StatInfo* pInfo) const;

    /** \brief Builds and returns statistics as a string in JSON format, including the list of allocations with their parameters.
    @param[out] ppStatsString Must be freed using VirtualBlock::FreeStatsString.
    */
    void BuildStatsString(WCHAR** ppStatsString) const;

    /** \brief Frees memory of a string returned from VirtualBlock::BuildStatsString.
    */
    void FreeStatsString(WCHAR* pStatsString) const;

private:
    friend HRESULT CreateVirtualBlock(const VIRTUAL_BLOCK_DESC*, VirtualBlock**);
    template<typename T> friend void D3D12MA_DELETE(const ALLOCATION_CALLBACKS&, T*);

    VirtualBlockPimpl* m_Pimpl;

    VirtualBlock(const ALLOCATION_CALLBACKS& allocationCallbacks, const VIRTUAL_BLOCK_DESC& desc);
    ~VirtualBlock();

    D3D12MA_CLASS_NO_COPY(VirtualBlock)
};

/** \brief Creates new main D3D12MA::Allocator object and returns it through `ppAllocator`.

You normally only need to call it once and keep a single Allocator object for your `ID3D12Device`.
*/
HRESULT CreateAllocator(const ALLOCATOR_DESC* pDesc, Allocator** ppAllocator);

/** \brief Creates new D3D12MA::VirtualBlock object and returns it through `ppVirtualBlock`.

Note you don't need to create D3D12MA::Allocator to use virtual blocks.
*/
HRESULT CreateVirtualBlock(const VIRTUAL_BLOCK_DESC* pDesc, VirtualBlock** ppVirtualBlock);

} // namespace D3D12MA

/// \cond INTERNAL
DEFINE_ENUM_FLAG_OPERATORS(D3D12MA::ALLOCATION_FLAGS);
DEFINE_ENUM_FLAG_OPERATORS(D3D12MA::ALLOCATOR_FLAGS);
/// \endcond

```

`ext/d3d12memoryallocator/LICENSE.txt`:

```txt
Copyright (c) 2019-2021 Advanced Micro Devices, Inc. All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

```

`ext/dx/d3dx12.h`:

```h
//*********************************************************
//
// Copyright (c) Microsoft. All rights reserved.
// This code is licensed under the MIT License (MIT).
// THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
// IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
// PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.
//
//*********************************************************

#ifndef __D3DX12_H__
#define __D3DX12_H__

#include "d3d12.h"

#if defined( __cplusplus )

struct CD3DX12_DEFAULT {};
extern const DECLSPEC_SELECTANY CD3DX12_DEFAULT D3D12_DEFAULT;

//------------------------------------------------------------------------------------------------
inline bool operator==(const D3D12_VIEWPORT& l, const D3D12_VIEWPORT& r) noexcept
{
    return l.TopLeftX == r.TopLeftX && l.TopLeftY == r.TopLeftY && l.Width == r.Width &&
        l.Height == r.Height && l.MinDepth == r.MinDepth && l.MaxDepth == r.MaxDepth;
}

//------------------------------------------------------------------------------------------------
inline bool operator!=(const D3D12_VIEWPORT& l, const D3D12_VIEWPORT& r) noexcept
{
    return !(l == r);
}

//------------------------------------------------------------------------------------------------
struct CD3DX12_RECT : public D3D12_RECT
{
    CD3DX12_RECT() = default;
    explicit CD3DX12_RECT(const D3D12_RECT& o) noexcept :
        D3D12_RECT(o)
    {}
    explicit CD3DX12_RECT(
        LONG Left,
        LONG Top,
        LONG Right,
        LONG Bottom) noexcept
    {
        left = Left;
        top = Top;
        right = Right;
        bottom = Bottom;
    }
};

//------------------------------------------------------------------------------------------------
struct CD3DX12_VIEWPORT : public D3D12_VIEWPORT
{
    CD3DX12_VIEWPORT() = default;
    explicit CD3DX12_VIEWPORT(const D3D12_VIEWPORT& o) noexcept :
        D3D12_VIEWPORT(o)
    {}
    explicit CD3DX12_VIEWPORT(
        FLOAT topLeftX,
        FLOAT topLeftY,
        FLOAT width,
        FLOAT height,
        FLOAT minDepth = D3D12_MIN_DEPTH,
        FLOAT maxDepth = D3D12_MAX_DEPTH) noexcept
    {
        TopLeftX = topLeftX;
        TopLeftY = topLeftY;
        Width = width;
        Height = height;
        MinDepth = minDepth;
        MaxDepth = maxDepth;
    }
    explicit CD3DX12_VIEWPORT(
        _In_ ID3D12Resource* pResource,
        UINT mipSlice = 0,
        FLOAT topLeftX = 0.0f,
        FLOAT topLeftY = 0.0f,
        FLOAT minDepth = D3D12_MIN_DEPTH,
        FLOAT maxDepth = D3D12_MAX_DEPTH) noexcept
    {
        auto Desc = pResource->GetDesc();
        const UINT64 SubresourceWidth = Desc.Width >> mipSlice;
        const UINT64 SubresourceHeight = Desc.Height >> mipSlice;
        switch (Desc.Dimension)
        {
            case D3D12_RESOURCE_DIMENSION_BUFFER:
                TopLeftX = topLeftX;
                TopLeftY = 0.0f;
                Width = float(Desc.Width) - topLeftX;
                Height = 1.0f;
                break;
            case D3D12_RESOURCE_DIMENSION_TEXTURE1D:
                TopLeftX = topLeftX;
                TopLeftY = 0.0f;
                Width = (SubresourceWidth ? float(SubresourceWidth) : 1.0f) - topLeftX;
                Height = 1.0f;
                break;
            case D3D12_RESOURCE_DIMENSION_TEXTURE2D:
            case D3D12_RESOURCE_DIMENSION_TEXTURE3D:
                TopLeftX = topLeftX;
                TopLeftY = topLeftY;
                Width = (SubresourceWidth ? float(SubresourceWidth) : 1.0f) - topLeftX;
                Height = (SubresourceHeight ? float(SubresourceHeight) : 1.0f) - topLeftY;
                break;
            default: break;
        }

        MinDepth = minDepth;
        MaxDepth = maxDepth;
    }
};

//------------------------------------------------------------------------------------------------
struct CD3DX12_BOX : public D3D12_BOX
{
    CD3DX12_BOX() = default;
    explicit CD3DX12_BOX(const D3D12_BOX& o) noexcept :
        D3D12_BOX(o)
    {}
    explicit CD3DX12_BOX(
        LONG Left,
        LONG Right) noexcept
    {
        left = static_cast<UINT>(Left);
        top = 0;
        front = 0;
        right = static_cast<UINT>(Right);
        bottom = 1;
        back = 1;
    }
    explicit CD3DX12_BOX(
        LONG Left,
        LONG Top,
        LONG Right,
        LONG Bottom) noexcept
    {
        left = static_cast<UINT>(Left);
        top = static_cast<UINT>(Top);
        front = 0;
        right = static_cast<UINT>(Right);
        bottom = static_cast<UINT>(Bottom);
        back = 1;
    }
    explicit CD3DX12_BOX(
        LONG Left,
        LONG Top,
        LONG Front,
        LONG Right,
        LONG Bottom,
        LONG Back) noexcept
    {
        left = static_cast<UINT>(Left);
        top = static_cast<UINT>(Top);
        front = static_cast<UINT>(Front);
        right = static_cast<UINT>(Right);
        bottom = static_cast<UINT>(Bottom);
        back = static_cast<UINT>(Back);
    }
};
inline bool operator==(const D3D12_BOX& l, const D3D12_BOX& r) noexcept
{
    return l.left == r.left && l.top == r.top && l.front == r.front &&
        l.right == r.right && l.bottom == r.bottom && l.back == r.back;
}
inline bool operator!=(const D3D12_BOX& l, const D3D12_BOX& r) noexcept
{
    return !(l == r);
}

//------------------------------------------------------------------------------------------------
struct CD3DX12_DEPTH_STENCIL_DESC : public D3D12_DEPTH_STENCIL_DESC
{
    CD3DX12_DEPTH_STENCIL_DESC() = default;
    explicit CD3DX12_DEPTH_STENCIL_DESC(const D3D12_DEPTH_STENCIL_DESC& o) noexcept :
        D3D12_DEPTH_STENCIL_DESC(o)
    {}
    explicit CD3DX12_DEPTH_STENCIL_DESC(CD3DX12_DEFAULT) noexcept
    {
        DepthEnable = TRUE;
        DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ALL;
        DepthFunc = D3D12_COMPARISON_FUNC_LESS;
        StencilEnable = FALSE;
        StencilReadMask = D3D12_DEFAULT_STENCIL_READ_MASK;
        StencilWriteMask = D3D12_DEFAULT_STENCIL_WRITE_MASK;
        const D3D12_DEPTH_STENCILOP_DESC defaultStencilOp =
        { D3D12_STENCIL_OP_KEEP, D3D12_STENCIL_OP_KEEP, D3D12_STENCIL_OP_KEEP, D3D12_COMPARISON_FUNC_ALWAYS };
        FrontFace = defaultStencilOp;
        BackFace = defaultStencilOp;
    }
    explicit CD3DX12_DEPTH_STENCIL_DESC(
        BOOL depthEnable,
        D3D12_DEPTH_WRITE_MASK depthWriteMask,
        D3D12_COMPARISON_FUNC depthFunc,
        BOOL stencilEnable,
        UINT8 stencilReadMask,
        UINT8 stencilWriteMask,
        D3D12_STENCIL_OP frontStencilFailOp,
        D3D12_STENCIL_OP frontStencilDepthFailOp,
        D3D12_STENCIL_OP frontStencilPassOp,
        D3D12_COMPARISON_FUNC frontStencilFunc,
        D3D12_STENCIL_OP backStencilFailOp,
        D3D12_STENCIL_OP backStencilDepthFailOp,
        D3D12_STENCIL_OP backStencilPassOp,
        D3D12_COMPARISON_FUNC backStencilFunc) noexcept
    {
        DepthEnable = depthEnable;
        DepthWriteMask = depthWriteMask;
        DepthFunc = depthFunc;
        StencilEnable = stencilEnable;
        StencilReadMask = stencilReadMask;
        StencilWriteMask = stencilWriteMask;
        FrontFace.StencilFailOp = frontStencilFailOp;
        FrontFace.StencilDepthFailOp = frontStencilDepthFailOp;
        FrontFace.StencilPassOp = frontStencilPassOp;
        FrontFace.StencilFunc = frontStencilFunc;
        BackFace.StencilFailOp = backStencilFailOp;
        BackFace.StencilDepthFailOp = backStencilDepthFailOp;
        BackFace.StencilPassOp = backStencilPassOp;
        BackFace.StencilFunc = backStencilFunc;
    }
};

//------------------------------------------------------------------------------------------------
// Requires the Windows 10 Creators Update SDK (15063)
#if defined(NTDDI_WIN10_RS2) && (NTDDI_VERSION >= NTDDI_WIN10_RS2)
struct CD3DX12_DEPTH_STENCIL_DESC1 : public D3D12_DEPTH_STENCIL_DESC1
{
    CD3DX12_DEPTH_STENCIL_DESC1() = default;
    explicit CD3DX12_DEPTH_STENCIL_DESC1(const D3D12_DEPTH_STENCIL_DESC1& o) noexcept :
        D3D12_DEPTH_STENCIL_DESC1(o)
    {}
    explicit CD3DX12_DEPTH_STENCIL_DESC1(const D3D12_DEPTH_STENCIL_DESC& o) noexcept
    {
        DepthEnable = o.DepthEnable;
        DepthWriteMask = o.DepthWriteMask;
        DepthFunc = o.DepthFunc;
        StencilEnable = o.StencilEnable;
        StencilReadMask = o.StencilReadMask;
        StencilWriteMask = o.StencilWriteMask;
        FrontFace.StencilFailOp = o.FrontFace.StencilFailOp;
        FrontFace.StencilDepthFailOp = o.FrontFace.StencilDepthFailOp;
        FrontFace.StencilPassOp = o.FrontFace.StencilPassOp;
        FrontFace.StencilFunc = o.FrontFace.StencilFunc;
        BackFace.StencilFailOp = o.BackFace.StencilFailOp;
        BackFace.StencilDepthFailOp = o.BackFace.StencilDepthFailOp;
        BackFace.StencilPassOp = o.BackFace.StencilPassOp;
        BackFace.StencilFunc = o.BackFace.StencilFunc;
        DepthBoundsTestEnable = FALSE;
    }
    explicit CD3DX12_DEPTH_STENCIL_DESC1(CD3DX12_DEFAULT) noexcept
    {
        DepthEnable = TRUE;
        DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ALL;
        DepthFunc = D3D12_COMPARISON_FUNC_LESS;
        StencilEnable = FALSE;
        StencilReadMask = D3D12_DEFAULT_STENCIL_READ_MASK;
        StencilWriteMask = D3D12_DEFAULT_STENCIL_WRITE_MASK;
        const D3D12_DEPTH_STENCILOP_DESC defaultStencilOp =
        { D3D12_STENCIL_OP_KEEP, D3D12_STENCIL_OP_KEEP, D3D12_STENCIL_OP_KEEP, D3D12_COMPARISON_FUNC_ALWAYS };
        FrontFace = defaultStencilOp;
        BackFace = defaultStencilOp;
        DepthBoundsTestEnable = FALSE;
    }
    explicit CD3DX12_DEPTH_STENCIL_DESC1(
        BOOL depthEnable,
        D3D12_DEPTH_WRITE_MASK depthWriteMask,
        D3D12_COMPARISON_FUNC depthFunc,
        BOOL stencilEnable,
        UINT8 stencilReadMask,
        UINT8 stencilWriteMask,
        D3D12_STENCIL_OP frontStencilFailOp,
        D3D12_STENCIL_OP frontStencilDepthFailOp,
        D3D12_STENCIL_OP frontStencilPassOp,
        D3D12_COMPARISON_FUNC frontStencilFunc,
        D3D12_STENCIL_OP backStencilFailOp,
        D3D12_STENCIL_OP backStencilDepthFailOp,
        D3D12_STENCIL_OP backStencilPassOp,
        D3D12_COMPARISON_FUNC backStencilFunc,
        BOOL depthBoundsTestEnable) noexcept
    {
        DepthEnable = depthEnable;
        DepthWriteMask = depthWriteMask;
        DepthFunc = depthFunc;
        StencilEnable = stencilEnable;
        StencilReadMask = stencilReadMask;
        StencilWriteMask = stencilWriteMask;
        FrontFace.StencilFailOp = frontStencilFailOp;
        FrontFace.StencilDepthFailOp = frontStencilDepthFailOp;
        FrontFace.StencilPassOp = frontStencilPassOp;
        FrontFace.StencilFunc = frontStencilFunc;
        BackFace.StencilFailOp = backStencilFailOp;
        BackFace.StencilDepthFailOp = backStencilDepthFailOp;
        BackFace.StencilPassOp = backStencilPassOp;
        BackFace.StencilFunc = backStencilFunc;
        DepthBoundsTestEnable = depthBoundsTestEnable;
    }
    operator D3D12_DEPTH_STENCIL_DESC() const noexcept
    {
        D3D12_DEPTH_STENCIL_DESC D;
        D.DepthEnable = DepthEnable;
        D.DepthWriteMask = DepthWriteMask;
        D.DepthFunc = DepthFunc;
        D.StencilEnable = StencilEnable;
        D.StencilReadMask = StencilReadMask;
        D.StencilWriteMask = StencilWriteMask;
        D.FrontFace.StencilFailOp = FrontFace.StencilFailOp;
        D.FrontFace.StencilDepthFailOp = FrontFace.StencilDepthFailOp;
        D.FrontFace.StencilPassOp = FrontFace.StencilPassOp;
        D.FrontFace.StencilFunc = FrontFace.StencilFunc;
        D.BackFace.StencilFailOp = BackFace.StencilFailOp;
        D.BackFace.StencilDepthFailOp = BackFace.StencilDepthFailOp;
        D.BackFace.StencilPassOp = BackFace.StencilPassOp;
        D.BackFace.StencilFunc = BackFace.StencilFunc;
        return D;
    }
};
#endif // NTDDI_WIN10_RS2

//------------------------------------------------------------------------------------------------
struct CD3DX12_BLEND_DESC : public D3D12_BLEND_DESC
{
    CD3DX12_BLEND_DESC() = default;
    explicit CD3DX12_BLEND_DESC(const D3D12_BLEND_DESC& o) noexcept :
        D3D12_BLEND_DESC(o)
    {}
    explicit CD3DX12_BLEND_DESC(CD3DX12_DEFAULT) noexcept
    {
        AlphaToCoverageEnable = FALSE;
        IndependentBlendEnable = FALSE;
        const D3D12_RENDER_TARGET_BLEND_DESC defaultRenderTargetBlendDesc =
        {
            FALSE,FALSE,
            D3D12_BLEND_ONE, D3D12_BLEND_ZERO, D3D12_BLEND_OP_ADD,
            D3D12_BLEND_ONE, D3D12_BLEND_ZERO, D3D12_BLEND_OP_ADD,
            D3D12_LOGIC_OP_NOOP,
            D3D12_COLOR_WRITE_ENABLE_ALL,
        };
        for (UINT i = 0; i < D3D12_SIMULTANEOUS_RENDER_TARGET_COUNT; ++i)
            RenderTarget[i] = defaultRenderTargetBlendDesc;
    }
};

//------------------------------------------------------------------------------------------------
struct CD3DX12_RASTERIZER_DESC : public D3D12_RASTERIZER_DESC
{
    CD3DX12_RASTERIZER_DESC() = default;
    explicit CD3DX12_RASTERIZER_DESC(const D3D12_RASTERIZER_DESC& o) noexcept :
        D3D12_RASTERIZER_DESC(o)
    {}
    explicit CD3DX12_RASTERIZER_DESC(CD3DX12_DEFAULT) noexcept
    {
        FillMode = D3D12_FILL_MODE_SOLID;
        CullMode = D3D12_CULL_MODE_BACK;
        FrontCounterClockwise = FALSE;
        DepthBias = D3D12_DEFAULT_DEPTH_BIAS;
        DepthBiasClamp = D3D12_DEFAULT_DEPTH_BIAS_CLAMP;
        SlopeScaledDepthBias = D3D12_DEFAULT_SLOPE_SCALED_DEPTH_BIAS;
        DepthClipEnable = TRUE;
        MultisampleEnable = FALSE;
        AntialiasedLineEnable = FALSE;
        ForcedSampleCount = 0;
        ConservativeRaster = D3D12_CONSERVATIVE_RASTERIZATION_MODE_OFF;
    }
    explicit CD3DX12_RASTERIZER_DESC(
        D3D12_FILL_MODE fillMode,
        D3D12_CULL_MODE cullMode,
        BOOL frontCounterClockwise,
        INT depthBias,
        FLOAT depthBiasClamp,
        FLOAT slopeScaledDepthBias,
        BOOL depthClipEnable,
        BOOL multisampleEnable,
        BOOL antialiasedLineEnable,
        UINT forcedSampleCount,
        D3D12_CONSERVATIVE_RASTERIZATION_MODE conservativeRaster) noexcept
    {
        FillMode = fillMode;
        CullMode = cullMode;
        FrontCounterClockwise = frontCounterClockwise;
        DepthBias = depthBias;
        DepthBiasClamp = depthBiasClamp;
        SlopeScaledDepthBias = slopeScaledDepthBias;
        DepthClipEnable = depthClipEnable;
        MultisampleEnable = multisampleEnable;
        AntialiasedLineEnable = antialiasedLineEnable;
        ForcedSampleCount = forcedSampleCount;
        ConservativeRaster = conservativeRaster;
    }
};

//------------------------------------------------------------------------------------------------
struct CD3DX12_RESOURCE_ALLOCATION_INFO : public D3D12_RESOURCE_ALLOCATION_INFO
{
    CD3DX12_RESOURCE_ALLOCATION_INFO() = default;
    explicit CD3DX12_RESOURCE_ALLOCATION_INFO(const D3D12_RESOURCE_ALLOCATION_INFO& o) noexcept :
        D3D12_RESOURCE_ALLOCATION_INFO(o)
    {}
    CD3DX12_RESOURCE_ALLOCATION_INFO(
        UINT64 size,
        UINT64 alignment) noexcept
    {
        SizeInBytes = size;
        Alignment = alignment;
    }
};

//------------------------------------------------------------------------------------------------
struct CD3DX12_HEAP_PROPERTIES : public D3D12_HEAP_PROPERTIES
{
    CD3DX12_HEAP_PROPERTIES() = default;
    explicit CD3DX12_HEAP_PROPERTIES(const D3D12_HEAP_PROPERTIES& o) noexcept :
        D3D12_HEAP_PROPERTIES(o)
    {}
    CD3DX12_HEAP_PROPERTIES(
        D3D12_CPU_PAGE_PROPERTY cpuPageProperty,
        D3D12_MEMORY_POOL memoryPoolPreference,
        UINT creationNodeMask = 1,
        UINT nodeMask = 1) noexcept
    {
        Type = D3D12_HEAP_TYPE_CUSTOM;
        CPUPageProperty = cpuPageProperty;
        MemoryPoolPreference = memoryPoolPreference;
        CreationNodeMask = creationNodeMask;
        VisibleNodeMask = nodeMask;
    }
    explicit CD3DX12_HEAP_PROPERTIES(
        D3D12_HEAP_TYPE type,
        UINT creationNodeMask = 1,
        UINT nodeMask = 1) noexcept
    {
        Type = type;
        CPUPageProperty = D3D12_CPU_PAGE_PROPERTY_UNKNOWN;
        MemoryPoolPreference = D3D12_MEMORY_POOL_UNKNOWN;
        CreationNodeMask = creationNodeMask;
        VisibleNodeMask = nodeMask;
    }
    bool IsCPUAccessible() const noexcept
    {
        return Type == D3D12_HEAP_TYPE_UPLOAD || Type == D3D12_HEAP_TYPE_READBACK || (Type == D3D12_HEAP_TYPE_CUSTOM &&
            (CPUPageProperty == D3D12_CPU_PAGE_PROPERTY_WRITE_COMBINE || CPUPageProperty == D3D12_CPU_PAGE_PROPERTY_WRITE_BACK));
    }
};
inline bool operator==(const D3D12_HEAP_PROPERTIES& l, const D3D12_HEAP_PROPERTIES& r) noexcept
{
    return l.Type == r.Type && l.CPUPageProperty == r.CPUPageProperty &&
        l.MemoryPoolPreference == r.MemoryPoolPreference &&
        l.CreationNodeMask == r.CreationNodeMask &&
        l.VisibleNodeMask == r.VisibleNodeMask;
}
inline bool operator!=(const D3D12_HEAP_PROPERTIES& l, const D3D12_HEAP_PROPERTIES& r) noexcept
{
    return !(l == r);
}

//------------------------------------------------------------------------------------------------
struct CD3DX12_HEAP_DESC : public D3D12_HEAP_DESC
{
    CD3DX12_HEAP_DESC() = default;
    explicit CD3DX12_HEAP_DESC(const D3D12_HEAP_DESC& o) noexcept :
        D3D12_HEAP_DESC(o)
    {}
    CD3DX12_HEAP_DESC(
        UINT64 size,
        D3D12_HEAP_PROPERTIES properties,
        UINT64 alignment = 0,
        D3D12_HEAP_FLAGS flags = D3D12_HEAP_FLAG_NONE) noexcept
    {
        SizeInBytes = size;
        Properties = properties;
        Alignment = alignment;
        Flags = flags;
    }
    CD3DX12_HEAP_DESC(
        UINT64 size,
        D3D12_HEAP_TYPE type,
        UINT64 alignment = 0,
        D3D12_HEAP_FLAGS flags = D3D12_HEAP_FLAG_NONE) noexcept
    {
        SizeInBytes = size;
        Properties = CD3DX12_HEAP_PROPERTIES(type);
        Alignment = alignment;
        Flags = flags;
    }
    CD3DX12_HEAP_DESC(
        UINT64 size,
        D3D12_CPU_PAGE_PROPERTY cpuPageProperty,
        D3D12_MEMORY_POOL memoryPoolPreference,
        UINT64 alignment = 0,
        D3D12_HEAP_FLAGS flags = D3D12_HEAP_FLAG_NONE) noexcept
    {
        SizeInBytes = size;
        Properties = CD3DX12_HEAP_PROPERTIES(cpuPageProperty, memoryPoolPreference);
        Alignment = alignment;
        Flags = flags;
    }
    CD3DX12_HEAP_DESC(
        const D3D12_RESOURCE_ALLOCATION_INFO& resAllocInfo,
        D3D12_HEAP_PROPERTIES properties,
        D3D12_HEAP_FLAGS flags = D3D12_HEAP_FLAG_NONE) noexcept
    {
        SizeInBytes = resAllocInfo.SizeInBytes;
        Properties = properties;
        Alignment = resAllocInfo.Alignment;
        Flags = flags;
    }
    CD3DX12_HEAP_DESC(
        const D3D12_RESOURCE_ALLOCATION_INFO& resAllocInfo,
        D3D12_HEAP_TYPE type,
        D3D12_HEAP_FLAGS flags = D3D12_HEAP_FLAG_NONE) noexcept
    {
        SizeInBytes = resAllocInfo.SizeInBytes;
        Properties = CD3DX12_HEAP_PROPERTIES(type);
        Alignment = resAllocInfo.Alignment;
        Flags = flags;
    }
    CD3DX12_HEAP_DESC(
        const D3D12_RESOURCE_ALLOCATION_INFO& resAllocInfo,
        D3D12_CPU_PAGE_PROPERTY cpuPageProperty,
        D3D12_MEMORY_POOL memoryPoolPreference,
        D3D12_HEAP_FLAGS flags = D3D12_HEAP_FLAG_NONE) noexcept
    {
        SizeInBytes = resAllocInfo.SizeInBytes;
        Properties = CD3DX12_HEAP_PROPERTIES(cpuPageProperty, memoryPoolPreference);
        Alignment = resAllocInfo.Alignment;
        Flags = flags;
    }
    bool IsCPUAccessible() const noexcept
    {
        return static_cast<const CD3DX12_HEAP_PROPERTIES*>(&Properties)->IsCPUAccessible();
    }
};
inline bool operator==(const D3D12_HEAP_DESC& l, const D3D12_HEAP_DESC& r) noexcept
{
    return l.SizeInBytes == r.SizeInBytes &&
        l.Properties == r.Properties &&
        l.Alignment == r.Alignment &&
        l.Flags == r.Flags;
}
inline bool operator!=(const D3D12_HEAP_DESC& l, const D3D12_HEAP_DESC& r) noexcept
{
    return !(l == r);
}

//------------------------------------------------------------------------------------------------
struct CD3DX12_CLEAR_VALUE : public D3D12_CLEAR_VALUE
{
    CD3DX12_CLEAR_VALUE() = default;
    explicit CD3DX12_CLEAR_VALUE(const D3D12_CLEAR_VALUE& o) noexcept :
        D3D12_CLEAR_VALUE(o)
    {}
    CD3DX12_CLEAR_VALUE(
        DXGI_FORMAT format,
        const FLOAT color[4]) noexcept
    {
        Format = format;
        memcpy(Color, color, sizeof(Color));
    }
    CD3DX12_CLEAR_VALUE(
        DXGI_FORMAT format,
        FLOAT depth,
        UINT8 stencil) noexcept
    {
        Format = format;
        memset(&Color, 0, sizeof(Color));
        /* Use memcpy to preserve NAN values */
        memcpy(&DepthStencil.Depth, &depth, sizeof(depth));
        DepthStencil.Stencil = stencil;
    }
};

//------------------------------------------------------------------------------------------------
struct CD3DX12_RANGE : public D3D12_RANGE
{
    CD3DX12_RANGE() = default;
    explicit CD3DX12_RANGE(const D3D12_RANGE& o) noexcept :
        D3D12_RANGE(o)
    {}
    CD3DX12_RANGE(
        SIZE_T begin,
        SIZE_T end) noexcept
    {
        Begin = begin;
        End = end;
    }
};

//------------------------------------------------------------------------------------------------
#if defined(NTDDI_WIN10_RS2) && (NTDDI_VERSION >= NTDDI_WIN10_RS2)
struct CD3DX12_RANGE_UINT64 : public D3D12_RANGE_UINT64
{
    CD3DX12_RANGE_UINT64() = default;
    explicit CD3DX12_RANGE_UINT64(const D3D12_RANGE_UINT64& o) noexcept :
        D3D12_RANGE_UINT64(o)
    {}
    CD3DX12_RANGE_UINT64(
        UINT64 begin,
        UINT64 end) noexcept
    {
        Begin = begin;
        End = end;
    }
};

//------------------------------------------------------------------------------------------------
struct CD3DX12_SUBRESOURCE_RANGE_UINT64 : public D3D12_SUBRESOURCE_RANGE_UINT64
{
    CD3DX12_SUBRESOURCE_RANGE_UINT64() = default;
    explicit CD3DX12_SUBRESOURCE_RANGE_UINT64(const D3D12_SUBRESOURCE_RANGE_UINT64& o) noexcept :
        D3D12_SUBRESOURCE_RANGE_UINT64(o)
    {}
    CD3DX12_SUBRESOURCE_RANGE_UINT64(
        UINT subresource,
        const D3D12_RANGE_UINT64& range) noexcept
    {
        Subresource = subresource;
        Range = range;
    }
    CD3DX12_SUBRESOURCE_RANGE_UINT64(
        UINT subresource,
        UINT64 begin,
        UINT64 end) noexcept
    {
        Subresource = subresource;
        Range.Begin = begin;
        Range.End = end;
    }
};
#endif // NTDDI_WIN10_RS2

//------------------------------------------------------------------------------------------------
struct CD3DX12_SHADER_BYTECODE : public D3D12_SHADER_BYTECODE
{
    CD3DX12_SHADER_BYTECODE() = default;
    explicit CD3DX12_SHADER_BYTECODE(const D3D12_SHADER_BYTECODE& o) noexcept :
        D3D12_SHADER_BYTECODE(o)
    {}
    CD3DX12_SHADER_BYTECODE(
        _In_ ID3DBlob* pShaderBlob) noexcept
    {
        pShaderBytecode = pShaderBlob->GetBufferPointer();
        BytecodeLength = pShaderBlob->GetBufferSize();
    }
    CD3DX12_SHADER_BYTECODE(
        const void* _pShaderBytecode,
        SIZE_T bytecodeLength) noexcept
    {
        pShaderBytecode = _pShaderBytecode;
        BytecodeLength = bytecodeLength;
    }
};

//------------------------------------------------------------------------------------------------
struct CD3DX12_TILED_RESOURCE_COORDINATE : public D3D12_TILED_RESOURCE_COORDINATE
{
    CD3DX12_TILED_RESOURCE_COORDINATE() = default;
    explicit CD3DX12_TILED_RESOURCE_COORDINATE(const D3D12_TILED_RESOURCE_COORDINATE& o) noexcept :
        D3D12_TILED_RESOURCE_COORDINATE(o)
    {}
    CD3DX12_TILED_RESOURCE_COORDINATE(
        UINT x,
        UINT y,
        UINT z,
        UINT subresource) noexcept
    {
        X = x;
        Y = y;
        Z = z;
        Subresource = subresource;
    }
};

//------------------------------------------------------------------------------------------------
struct CD3DX12_TILE_REGION_SIZE : public D3D12_TILE_REGION_SIZE
{
    CD3DX12_TILE_REGION_SIZE() = default;
    explicit CD3DX12_TILE_REGION_SIZE(const D3D12_TILE_REGION_SIZE& o) noexcept :
        D3D12_TILE_REGION_SIZE(o)
    {}
    CD3DX12_TILE_REGION_SIZE(
        UINT numTiles,
        BOOL useBox,
        UINT width,
        UINT16 height,
        UINT16 depth) noexcept
    {
        NumTiles = numTiles;
        UseBox = useBox;
        Width = width;
        Height = height;
        Depth = depth;
    }
};

//------------------------------------------------------------------------------------------------
struct CD3DX12_SUBRESOURCE_TILING : public D3D12_SUBRESOURCE_TILING
{
    CD3DX12_SUBRESOURCE_TILING() = default;
    explicit CD3DX12_SUBRESOURCE_TILING(const D3D12_SUBRESOURCE_TILING& o) noexcept :
        D3D12_SUBRESOURCE_TILING(o)
    {}
    CD3DX12_SUBRESOURCE_TILING(
        UINT widthInTiles,
        UINT16 heightInTiles,
        UINT16 depthInTiles,
        UINT startTileIndexInOverallResource) noexcept
    {
        WidthInTiles = widthInTiles;
        HeightInTiles = heightInTiles;
        DepthInTiles = depthInTiles;
        StartTileIndexInOverallResource = startTileIndexInOverallResource;
    }
};

//------------------------------------------------------------------------------------------------
struct CD3DX12_TILE_SHAPE : public D3D12_TILE_SHAPE
{
    CD3DX12_TILE_SHAPE() = default;
    explicit CD3DX12_TILE_SHAPE(const D3D12_TILE_SHAPE& o) noexcept :
        D3D12_TILE_SHAPE(o)
    {}
    CD3DX12_TILE_SHAPE(
        UINT widthInTexels,
        UINT heightInTexels,
        UINT depthInTexels) noexcept
    {
        WidthInTexels = widthInTexels;
        HeightInTexels = heightInTexels;
        DepthInTexels = depthInTexels;
    }
};

//------------------------------------------------------------------------------------------------
struct CD3DX12_RESOURCE_BARRIER : public D3D12_RESOURCE_BARRIER
{
    CD3DX12_RESOURCE_BARRIER() = default;
    explicit CD3DX12_RESOURCE_BARRIER(const D3D12_RESOURCE_BARRIER& o) noexcept :
        D3D12_RESOURCE_BARRIER(o)
    {}
    static inline CD3DX12_RESOURCE_BARRIER Transition(
        _In_ ID3D12Resource* pResource,
        D3D12_RESOURCE_STATES stateBefore,
        D3D12_RESOURCE_STATES stateAfter,
        UINT subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES,
        D3D12_RESOURCE_BARRIER_FLAGS flags = D3D12_RESOURCE_BARRIER_FLAG_NONE) noexcept
    {
        CD3DX12_RESOURCE_BARRIER result = {};
        D3D12_RESOURCE_BARRIER& barrier = result;
        result.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
        result.Flags = flags;
        barrier.Transition.pResource = pResource;
        barrier.Transition.StateBefore = stateBefore;
        barrier.Transition.StateAfter = stateAfter;
        barrier.Transition.Subresource = subresource;
        return result;
    }
    static inline CD3DX12_RESOURCE_BARRIER Aliasing(
        _In_ ID3D12Resource* pResourceBefore,
        _In_ ID3D12Resource* pResourceAfter) noexcept
    {
        CD3DX12_RESOURCE_BARRIER result = {};
        D3D12_RESOURCE_BARRIER& barrier = result;
        result.Type = D3D12_RESOURCE_BARRIER_TYPE_ALIASING;
        barrier.Aliasing.pResourceBefore = pResourceBefore;
        barrier.Aliasing.pResourceAfter = pResourceAfter;
        return result;
    }
    static inline CD3DX12_RESOURCE_BARRIER UAV(
        _In_ ID3D12Resource* pResource) noexcept
    {
        CD3DX12_RESOURCE_BARRIER result = {};
        D3D12_RESOURCE_BARRIER& barrier = result;
        result.Type = D3D12_RESOURCE_BARRIER_TYPE_UAV;
        barrier.UAV.pResource = pResource;
        return result;
    }
};

//------------------------------------------------------------------------------------------------
struct CD3DX12_PACKED_MIP_INFO : public D3D12_PACKED_MIP_INFO
{
    CD3DX12_PACKED_MIP_INFO() = default;
    explicit CD3DX12_PACKED_MIP_INFO(const D3D12_PACKED_MIP_INFO& o) noexcept :
        D3D12_PACKED_MIP_INFO(o)
    {}
    CD3DX12_PACKED_MIP_INFO(
        UINT8 numStandardMips,
        UINT8 numPackedMips,
        UINT numTilesForPackedMips,
        UINT startTileIndexInOverallResource) noexcept
    {
        NumStandardMips = numStandardMips;
        NumPackedMips = numPackedMips;
        NumTilesForPackedMips = numTilesForPackedMips;
        StartTileIndexInOverallResource = startTileIndexInOverallResource;
    }
};

//------------------------------------------------------------------------------------------------
struct CD3DX12_SUBRESOURCE_FOOTPRINT : public D3D12_SUBRESOURCE_FOOTPRINT
{
    CD3DX12_SUBRESOURCE_FOOTPRINT() = default;
    explicit CD3DX12_SUBRESOURCE_FOOTPRINT(const D3D12_SUBRESOURCE_FOOTPRINT& o) noexcept :
        D3D12_SUBRESOURCE_FOOTPRINT(o)
    {}
    CD3DX12_SUBRESOURCE_FOOTPRINT(
        DXGI_FORMAT format,
        UINT width,
        UINT height,
        UINT depth,
        UINT rowPitch) noexcept
    {
        Format = format;
        Width = width;
        Height = height;
        Depth = depth;
        RowPitch = rowPitch;
    }
    explicit CD3DX12_SUBRESOURCE_FOOTPRINT(
        const D3D12_RESOURCE_DESC& resDesc,
        UINT rowPitch) noexcept
    {
        Format = resDesc.Format;
        Width = UINT(resDesc.Width);
        Height = resDesc.Height;
        Depth = (resDesc.Dimension == D3D12_RESOURCE_DIMENSION_TEXTURE3D ? resDesc.DepthOrArraySize : 1);
        RowPitch = rowPitch;
    }
};

//------------------------------------------------------------------------------------------------
struct CD3DX12_TEXTURE_COPY_LOCATION : public D3D12_TEXTURE_COPY_LOCATION
{
    CD3DX12_TEXTURE_COPY_LOCATION() = default;
    explicit CD3DX12_TEXTURE_COPY_LOCATION(const D3D12_TEXTURE_COPY_LOCATION& o) noexcept :
        D3D12_TEXTURE_COPY_LOCATION(o)
    {}
    CD3DX12_TEXTURE_COPY_LOCATION(_In_ ID3D12Resource* pRes) noexcept
    {
        pResource = pRes;
        Type = D3D12_TEXTURE_COPY_TYPE_SUBRESOURCE_INDEX;
        PlacedFootprint = {};
    }
    CD3DX12_TEXTURE_COPY_LOCATION(_In_ ID3D12Resource* pRes, D3D12_PLACED_SUBRESOURCE_FOOTPRINT const& Footprint) noexcept
    {
        pResource = pRes;
        Type = D3D12_TEXTURE_COPY_TYPE_PLACED_FOOTPRINT;
        PlacedFootprint = Footprint;
    }
    CD3DX12_TEXTURE_COPY_LOCATION(_In_ ID3D12Resource* pRes, UINT Sub) noexcept
    {
        pResource = pRes;
        Type = D3D12_TEXTURE_COPY_TYPE_SUBRESOURCE_INDEX;
        PlacedFootprint = {};
        SubresourceIndex = Sub;
    }
};

//------------------------------------------------------------------------------------------------
struct CD3DX12_DESCRIPTOR_RANGE : public D3D12_DESCRIPTOR_RANGE
{
    CD3DX12_DESCRIPTOR_RANGE() = default;
    explicit CD3DX12_DESCRIPTOR_RANGE(const D3D12_DESCRIPTOR_RANGE& o) noexcept :
        D3D12_DESCRIPTOR_RANGE(o)
    {}
    CD3DX12_DESCRIPTOR_RANGE(
        D3D12_DESCRIPTOR_RANGE_TYPE rangeType,
        UINT numDescriptors,
        UINT baseShaderRegister,
        UINT registerSpace = 0,
        UINT offsetInDescriptorsFromTableStart =
        D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND) noexcept
    {
        Init(rangeType, numDescriptors, baseShaderRegister, registerSpace, offsetInDescriptorsFromTableStart);
    }

    inline void Init(
        D3D12_DESCRIPTOR_RANGE_TYPE rangeType,
        UINT numDescriptors,
        UINT baseShaderRegister,
        UINT registerSpace = 0,
        UINT offsetInDescriptorsFromTableStart =
        D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND) noexcept
    {
        Init(*this, rangeType, numDescriptors, baseShaderRegister, registerSpace, offsetInDescriptorsFromTableStart);
    }

    static inline void Init(
        _Out_ D3D12_DESCRIPTOR_RANGE& range,
        D3D12_DESCRIPTOR_RANGE_TYPE rangeType,
        UINT numDescriptors,
        UINT baseShaderRegister,
        UINT registerSpace = 0,
        UINT offsetInDescriptorsFromTableStart =
        D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND) noexcept
    {
        range.RangeType = rangeType;
        range.NumDescriptors = numDescriptors;
        range.BaseShaderRegister = baseShaderRegister;
        range.RegisterSpace = registerSpace;
        range.OffsetInDescriptorsFromTableStart = offsetInDescriptorsFromTableStart;
    }
};

//------------------------------------------------------------------------------------------------
struct CD3DX12_ROOT_DESCRIPTOR_TABLE : public D3D12_ROOT_DESCRIPTOR_TABLE
{
    CD3DX12_ROOT_DESCRIPTOR_TABLE() = default;
    explicit CD3DX12_ROOT_DESCRIPTOR_TABLE(const D3D12_ROOT_DESCRIPTOR_TABLE& o) noexcept :
        D3D12_ROOT_DESCRIPTOR_TABLE(o)
    {}
    CD3DX12_ROOT_DESCRIPTOR_TABLE(
        UINT numDescriptorRanges,
        _In_reads_opt_(numDescriptorRanges) const D3D12_DESCRIPTOR_RANGE* _pDescriptorRanges) noexcept
    {
        Init(numDescriptorRanges, _pDescriptorRanges);
    }

    inline void Init(
        UINT numDescriptorRanges,
        _In_reads_opt_(numDescriptorRanges) const D3D12_DESCRIPTOR_RANGE* _pDescriptorRanges) noexcept
    {
        Init(*this, numDescriptorRanges, _pDescriptorRanges);
    }

    static inline void Init(
        _Out_ D3D12_ROOT_DESCRIPTOR_TABLE& rootDescriptorTable,
        UINT numDescriptorRanges,
        _In_reads_opt_(numDescriptorRanges) const D3D12_DESCRIPTOR_RANGE* _pDescriptorRanges) noexcept
    {
        rootDescriptorTable.NumDescriptorRanges = numDescriptorRanges;
        rootDescriptorTable.pDescriptorRanges = _pDescriptorRanges;
    }
};

//------------------------------------------------------------------------------------------------
struct CD3DX12_ROOT_CONSTANTS : public D3D12_ROOT_CONSTANTS
{
    CD3DX12_ROOT_CONSTANTS() = default;
    explicit CD3DX12_ROOT_CONSTANTS(const D3D12_ROOT_CONSTANTS& o) noexcept :
        D3D12_ROOT_CONSTANTS(o)
    {}
    CD3DX12_ROOT_CONSTANTS(
        UINT num32BitValues,
        UINT shaderRegister,
        UINT registerSpace = 0) noexcept
    {
        Init(num32BitValues, shaderRegister, registerSpace);
    }

    inline void Init(
        UINT num32BitValues,
        UINT shaderRegister,
        UINT registerSpace = 0) noexcept
    {
        Init(*this, num32BitValues, shaderRegister, registerSpace);
    }

    static inline void Init(
        _Out_ D3D12_ROOT_CONSTANTS& rootConstants,
        UINT num32BitValues,
        UINT shaderRegister,
        UINT registerSpace = 0) noexcept
    {
        rootConstants.Num32BitValues = num32BitValues;
        rootConstants.ShaderRegister = shaderRegister;
        rootConstants.RegisterSpace = registerSpace;
    }
};

//------------------------------------------------------------------------------------------------
struct CD3DX12_ROOT_DESCRIPTOR : public D3D12_ROOT_DESCRIPTOR
{
    CD3DX12_ROOT_DESCRIPTOR() = default;
    explicit CD3DX12_ROOT_DESCRIPTOR(const D3D12_ROOT_DESCRIPTOR& o) noexcept :
        D3D12_ROOT_DESCRIPTOR(o)
    {}
    CD3DX12_ROOT_DESCRIPTOR(
        UINT shaderRegister,
        UINT registerSpace = 0) noexcept
    {
        Init(shaderRegister, registerSpace);
    }

    inline void Init(
        UINT shaderRegister,
        UINT registerSpace = 0) noexcept
    {
        Init(*this, shaderRegister, registerSpace);
    }

    static inline void Init(_Out_ D3D12_ROOT_DESCRIPTOR& table, UINT shaderRegister, UINT registerSpace = 0) noexcept
    {
        table.ShaderRegister = shaderRegister;
        table.RegisterSpace = registerSpace;
    }
};

//------------------------------------------------------------------------------------------------
struct CD3DX12_ROOT_PARAMETER : public D3D12_ROOT_PARAMETER
{
    CD3DX12_ROOT_PARAMETER() = default;
    explicit CD3DX12_ROOT_PARAMETER(const D3D12_ROOT_PARAMETER& o) noexcept :
        D3D12_ROOT_PARAMETER(o)
    {}

    static inline void InitAsDescriptorTable(
        _Out_ D3D12_ROOT_PARAMETER& rootParam,
        UINT numDescriptorRanges,
        _In_reads_(numDescriptorRanges) const D3D12_DESCRIPTOR_RANGE* pDescriptorRanges,
        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL) noexcept
    {
        rootParam.ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;
        rootParam.ShaderVisibility = visibility;
        CD3DX12_ROOT_DESCRIPTOR_TABLE::Init(rootParam.DescriptorTable, numDescriptorRanges, pDescriptorRanges);
    }

    static inline void InitAsConstants(
        _Out_ D3D12_ROOT_PARAMETER& rootParam,
        UINT num32BitValues,
        UINT shaderRegister,
        UINT registerSpace = 0,
        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL) noexcept
    {
        rootParam.ParameterType = D3D12_ROOT_PARAMETER_TYPE_32BIT_CONSTANTS;
        rootParam.ShaderVisibility = visibility;
        CD3DX12_ROOT_CONSTANTS::Init(rootParam.Constants, num32BitValues, shaderRegister, registerSpace);
    }

    static inline void InitAsConstantBufferView(
        _Out_ D3D12_ROOT_PARAMETER& rootParam,
        UINT shaderRegister,
        UINT registerSpace = 0,
        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL) noexcept
    {
        rootParam.ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
        rootParam.ShaderVisibility = visibility;
        CD3DX12_ROOT_DESCRIPTOR::Init(rootParam.Descriptor, shaderRegister, registerSpace);
    }

    static inline void InitAsShaderResourceView(
        _Out_ D3D12_ROOT_PARAMETER& rootParam,
        UINT shaderRegister,
        UINT registerSpace = 0,
        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL) noexcept
    {
        rootParam.ParameterType = D3D12_ROOT_PARAMETER_TYPE_SRV;
        rootParam.ShaderVisibility = visibility;
        CD3DX12_ROOT_DESCRIPTOR::Init(rootParam.Descriptor, shaderRegister, registerSpace);
    }

    static inline void InitAsUnorderedAccessView(
        _Out_ D3D12_ROOT_PARAMETER& rootParam,
        UINT shaderRegister,
        UINT registerSpace = 0,
        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL) noexcept
    {
        rootParam.ParameterType = D3D12_ROOT_PARAMETER_TYPE_UAV;
        rootParam.ShaderVisibility = visibility;
        CD3DX12_ROOT_DESCRIPTOR::Init(rootParam.Descriptor, shaderRegister, registerSpace);
    }

    inline void InitAsDescriptorTable(
        UINT numDescriptorRanges,
        _In_reads_(numDescriptorRanges) const D3D12_DESCRIPTOR_RANGE* pDescriptorRanges,
        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL) noexcept
    {
        InitAsDescriptorTable(*this, numDescriptorRanges, pDescriptorRanges, visibility);
    }

    inline void InitAsConstants(
        UINT num32BitValues,
        UINT shaderRegister,
        UINT registerSpace = 0,
        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL) noexcept
    {
        InitAsConstants(*this, num32BitValues, shaderRegister, registerSpace, visibility);
    }

    inline void InitAsConstantBufferView(
        UINT shaderRegister,
        UINT registerSpace = 0,
        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL) noexcept
    {
        InitAsConstantBufferView(*this, shaderRegister, registerSpace, visibility);
    }

    inline void InitAsShaderResourceView(
        UINT shaderRegister,
        UINT registerSpace = 0,
        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL) noexcept
    {
        InitAsShaderResourceView(*this, shaderRegister, registerSpace, visibility);
    }

    inline void InitAsUnorderedAccessView(
        UINT shaderRegister,
        UINT registerSpace = 0,
        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL) noexcept
    {
        InitAsUnorderedAccessView(*this, shaderRegister, registerSpace, visibility);
    }
};

//------------------------------------------------------------------------------------------------
struct CD3DX12_STATIC_SAMPLER_DESC : public D3D12_STATIC_SAMPLER_DESC
{
    CD3DX12_STATIC_SAMPLER_DESC() = default;
    explicit CD3DX12_STATIC_SAMPLER_DESC(const D3D12_STATIC_SAMPLER_DESC& o) noexcept :
        D3D12_STATIC_SAMPLER_DESC(o)
    {}
    CD3DX12_STATIC_SAMPLER_DESC(
        UINT shaderRegister,
        D3D12_FILTER filter = D3D12_FILTER_ANISOTROPIC,
        D3D12_TEXTURE_ADDRESS_MODE addressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP,
        D3D12_TEXTURE_ADDRESS_MODE addressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP,
        D3D12_TEXTURE_ADDRESS_MODE addressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP,
        FLOAT mipLODBias = 0,
        UINT maxAnisotropy = 16,
        D3D12_COMPARISON_FUNC comparisonFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL,
        D3D12_STATIC_BORDER_COLOR borderColor = D3D12_STATIC_BORDER_COLOR_OPAQUE_WHITE,
        FLOAT minLOD = 0.f,
        FLOAT maxLOD = D3D12_FLOAT32_MAX,
        D3D12_SHADER_VISIBILITY shaderVisibility = D3D12_SHADER_VISIBILITY_ALL,
        UINT registerSpace = 0) noexcept
    {
        Init(
            shaderRegister,
            filter,
            addressU,
            addressV,
            addressW,
            mipLODBias,
            maxAnisotropy,
            comparisonFunc,
            borderColor,
            minLOD,
            maxLOD,
            shaderVisibility,
            registerSpace);
    }

    static inline void Init(
        _Out_ D3D12_STATIC_SAMPLER_DESC& samplerDesc,
        UINT shaderRegister,
        D3D12_FILTER filter = D3D12_FILTER_ANISOTROPIC,
        D3D12_TEXTURE_ADDRESS_MODE addressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP,
        D3D12_TEXTURE_ADDRESS_MODE addressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP,
        D3D12_TEXTURE_ADDRESS_MODE addressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP,
        FLOAT mipLODBias = 0,
        UINT maxAnisotropy = 16,
        D3D12_COMPARISON_FUNC comparisonFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL,
        D3D12_STATIC_BORDER_COLOR borderColor = D3D12_STATIC_BORDER_COLOR_OPAQUE_WHITE,
        FLOAT minLOD = 0.f,
        FLOAT maxLOD = D3D12_FLOAT32_MAX,
        D3D12_SHADER_VISIBILITY shaderVisibility = D3D12_SHADER_VISIBILITY_ALL,
        UINT registerSpace = 0) noexcept
    {
        samplerDesc.ShaderRegister = shaderRegister;
        samplerDesc.Filter = filter;
        samplerDesc.AddressU = addressU;
        samplerDesc.AddressV = addressV;
        samplerDesc.AddressW = addressW;
        samplerDesc.MipLODBias = mipLODBias;
        samplerDesc.MaxAnisotropy = maxAnisotropy;
        samplerDesc.ComparisonFunc = comparisonFunc;
        samplerDesc.BorderColor = borderColor;
        samplerDesc.MinLOD = minLOD;
        samplerDesc.MaxLOD = maxLOD;
        samplerDesc.ShaderVisibility = shaderVisibility;
        samplerDesc.RegisterSpace = registerSpace;
    }
    inline void Init(
        UINT shaderRegister,
        D3D12_FILTER filter = D3D12_FILTER_ANISOTROPIC,
        D3D12_TEXTURE_ADDRESS_MODE addressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP,
        D3D12_TEXTURE_ADDRESS_MODE addressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP,
        D3D12_TEXTURE_ADDRESS_MODE addressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP,
        FLOAT mipLODBias = 0,
        UINT maxAnisotropy = 16,
        D3D12_COMPARISON_FUNC comparisonFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL,
        D3D12_STATIC_BORDER_COLOR borderColor = D3D12_STATIC_BORDER_COLOR_OPAQUE_WHITE,
        FLOAT minLOD = 0.f,
        FLOAT maxLOD = D3D12_FLOAT32_MAX,
        D3D12_SHADER_VISIBILITY shaderVisibility = D3D12_SHADER_VISIBILITY_ALL,
        UINT registerSpace = 0) noexcept
    {
        Init(
            *this,
            shaderRegister,
            filter,
            addressU,
            addressV,
            addressW,
            mipLODBias,
            maxAnisotropy,
            comparisonFunc,
            borderColor,
            minLOD,
            maxLOD,
            shaderVisibility,
            registerSpace);
    }

};

//------------------------------------------------------------------------------------------------
struct CD3DX12_ROOT_SIGNATURE_DESC : public D3D12_ROOT_SIGNATURE_DESC
{
    CD3DX12_ROOT_SIGNATURE_DESC() = default;
    explicit CD3DX12_ROOT_SIGNATURE_DESC(const D3D12_ROOT_SIGNATURE_DESC& o) noexcept :
        D3D12_ROOT_SIGNATURE_DESC(o)
    {}
    CD3DX12_ROOT_SIGNATURE_DESC(
        UINT numParameters,
        _In_reads_opt_(numParameters) const D3D12_ROOT_PARAMETER* _pParameters,
        UINT numStaticSamplers = 0,
        _In_reads_opt_(numStaticSamplers) const D3D12_STATIC_SAMPLER_DESC* _pStaticSamplers = nullptr,
        D3D12_ROOT_SIGNATURE_FLAGS flags = D3D12_ROOT_SIGNATURE_FLAG_NONE) noexcept
    {
        Init(numParameters, _pParameters, numStaticSamplers, _pStaticSamplers, flags);
    }
    CD3DX12_ROOT_SIGNATURE_DESC(CD3DX12_DEFAULT) noexcept
    {
        Init(0, nullptr, 0, nullptr, D3D12_ROOT_SIGNATURE_FLAG_NONE);
    }

    inline void Init(
        UINT numParameters,
        _In_reads_opt_(numParameters) const D3D12_ROOT_PARAMETER* _pParameters,
        UINT numStaticSamplers = 0,
        _In_reads_opt_(numStaticSamplers) const D3D12_STATIC_SAMPLER_DESC* _pStaticSamplers = nullptr,
        D3D12_ROOT_SIGNATURE_FLAGS flags = D3D12_ROOT_SIGNATURE_FLAG_NONE) noexcept
    {
        Init(*this, numParameters, _pParameters, numStaticSamplers, _pStaticSamplers, flags);
    }

    static inline void Init(
        _Out_ D3D12_ROOT_SIGNATURE_DESC& desc,
        UINT numParameters,
        _In_reads_opt_(numParameters) const D3D12_ROOT_PARAMETER* _pParameters,
        UINT numStaticSamplers = 0,
        _In_reads_opt_(numStaticSamplers) const D3D12_STATIC_SAMPLER_DESC* _pStaticSamplers = nullptr,
        D3D12_ROOT_SIGNATURE_FLAGS flags = D3D12_ROOT_SIGNATURE_FLAG_NONE) noexcept
    {
        desc.NumParameters = numParameters;
        desc.pParameters = _pParameters;
        desc.NumStaticSamplers = numStaticSamplers;
        desc.pStaticSamplers = _pStaticSamplers;
        desc.Flags = flags;
    }
};

//------------------------------------------------------------------------------------------------
struct CD3DX12_DESCRIPTOR_RANGE1 : public D3D12_DESCRIPTOR_RANGE1
{
    CD3DX12_DESCRIPTOR_RANGE1() = default;
    explicit CD3DX12_DESCRIPTOR_RANGE1(const D3D12_DESCRIPTOR_RANGE1& o) noexcept :
        D3D12_DESCRIPTOR_RANGE1(o)
    {}
    CD3DX12_DESCRIPTOR_RANGE1(
        D3D12_DESCRIPTOR_RANGE_TYPE rangeType,
        UINT numDescriptors,
        UINT baseShaderRegister,
        UINT registerSpace = 0,
        D3D12_DESCRIPTOR_RANGE_FLAGS flags = D3D12_DESCRIPTOR_RANGE_FLAG_NONE,
        UINT offsetInDescriptorsFromTableStart =
        D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND) noexcept
    {
        Init(rangeType, numDescriptors, baseShaderRegister, registerSpace, flags, offsetInDescriptorsFromTableStart);
    }

    inline void Init(
        D3D12_DESCRIPTOR_RANGE_TYPE rangeType,
        UINT numDescriptors,
        UINT baseShaderRegister,
        UINT registerSpace = 0,
        D3D12_DESCRIPTOR_RANGE_FLAGS flags = D3D12_DESCRIPTOR_RANGE_FLAG_NONE,
        UINT offsetInDescriptorsFromTableStart =
        D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND) noexcept
    {
        Init(*this, rangeType, numDescriptors, baseShaderRegister, registerSpace, flags, offsetInDescriptorsFromTableStart);
    }

    static inline void Init(
        _Out_ D3D12_DESCRIPTOR_RANGE1& range,
        D3D12_DESCRIPTOR_RANGE_TYPE rangeType,
        UINT numDescriptors,
        UINT baseShaderRegister,
        UINT registerSpace = 0,
        D3D12_DESCRIPTOR_RANGE_FLAGS flags = D3D12_DESCRIPTOR_RANGE_FLAG_NONE,
        UINT offsetInDescriptorsFromTableStart =
        D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND) noexcept
    {
        range.RangeType = rangeType;
        range.NumDescriptors = numDescriptors;
        range.BaseShaderRegister = baseShaderRegister;
        range.RegisterSpace = registerSpace;
        range.Flags = flags;
        range.OffsetInDescriptorsFromTableStart = offsetInDescriptorsFromTableStart;
    }
};

//------------------------------------------------------------------------------------------------
struct CD3DX12_ROOT_DESCRIPTOR_TABLE1 : public D3D12_ROOT_DESCRIPTOR_TABLE1
{
    CD3DX12_ROOT_DESCRIPTOR_TABLE1() = default;
    explicit CD3DX12_ROOT_DESCRIPTOR_TABLE1(const D3D12_ROOT_DESCRIPTOR_TABLE1& o) noexcept :
        D3D12_ROOT_DESCRIPTOR_TABLE1(o)
    {}
    CD3DX12_ROOT_DESCRIPTOR_TABLE1(
        UINT numDescriptorRanges,
        _In_reads_opt_(numDescriptorRanges) const D3D12_DESCRIPTOR_RANGE1* _pDescriptorRanges) noexcept
    {
        Init(numDescriptorRanges, _pDescriptorRanges);
    }

    inline void Init(
        UINT numDescriptorRanges,
        _In_reads_opt_(numDescriptorRanges) const D3D12_DESCRIPTOR_RANGE1* _pDescriptorRanges) noexcept
    {
        Init(*this, numDescriptorRanges, _pDescriptorRanges);
    }

    static inline void Init(
        _Out_ D3D12_ROOT_DESCRIPTOR_TABLE1& rootDescriptorTable,
        UINT numDescriptorRanges,
        _In_reads_opt_(numDescriptorRanges) const D3D12_DESCRIPTOR_RANGE1* _pDescriptorRanges) noexcept
    {
        rootDescriptorTable.NumDescriptorRanges = numDescriptorRanges;
        rootDescriptorTable.pDescriptorRanges = _pDescriptorRanges;
    }
};

//------------------------------------------------------------------------------------------------
struct CD3DX12_ROOT_DESCRIPTOR1 : public D3D12_ROOT_DESCRIPTOR1
{
    CD3DX12_ROOT_DESCRIPTOR1() = default;
    explicit CD3DX12_ROOT_DESCRIPTOR1(const D3D12_ROOT_DESCRIPTOR1& o) noexcept :
        D3D12_ROOT_DESCRIPTOR1(o)
    {}
    CD3DX12_ROOT_DESCRIPTOR1(
        UINT shaderRegister,
        UINT registerSpace = 0,
        D3D12_ROOT_DESCRIPTOR_FLAGS flags = D3D12_ROOT_DESCRIPTOR_FLAG_NONE) noexcept
    {
        Init(shaderRegister, registerSpace, flags);
    }

    inline void Init(
        UINT shaderRegister,
        UINT registerSpace = 0,
        D3D12_ROOT_DESCRIPTOR_FLAGS flags = D3D12_ROOT_DESCRIPTOR_FLAG_NONE) noexcept
    {
        Init(*this, shaderRegister, registerSpace, flags);
    }

    static inline void Init(
        _Out_ D3D12_ROOT_DESCRIPTOR1& table,
        UINT shaderRegister,
        UINT registerSpace = 0,
        D3D12_ROOT_DESCRIPTOR_FLAGS flags = D3D12_ROOT_DESCRIPTOR_FLAG_NONE) noexcept
    {
        table.ShaderRegister = shaderRegister;
        table.RegisterSpace = registerSpace;
        table.Flags = flags;
    }
};

//------------------------------------------------------------------------------------------------
struct CD3DX12_ROOT_PARAMETER1 : public D3D12_ROOT_PARAMETER1
{
    CD3DX12_ROOT_PARAMETER1() = default;
    explicit CD3DX12_ROOT_PARAMETER1(const D3D12_ROOT_PARAMETER1& o) noexcept :
        D3D12_ROOT_PARAMETER1(o)
    {}

    static inline void InitAsDescriptorTable(
        _Out_ D3D12_ROOT_PARAMETER1& rootParam,
        UINT numDescriptorRanges,
        _In_reads_(numDescriptorRanges) const D3D12_DESCRIPTOR_RANGE1* pDescriptorRanges,
        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL) noexcept
    {
        rootParam.ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;
        rootParam.ShaderVisibility = visibility;
        CD3DX12_ROOT_DESCRIPTOR_TABLE1::Init(rootParam.DescriptorTable, numDescriptorRanges, pDescriptorRanges);
    }

    static inline void InitAsConstants(
        _Out_ D3D12_ROOT_PARAMETER1& rootParam,
        UINT num32BitValues,
        UINT shaderRegister,
        UINT registerSpace = 0,
        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL) noexcept
    {
        rootParam.ParameterType = D3D12_ROOT_PARAMETER_TYPE_32BIT_CONSTANTS;
        rootParam.ShaderVisibility = visibility;
        CD3DX12_ROOT_CONSTANTS::Init(rootParam.Constants, num32BitValues, shaderRegister, registerSpace);
    }

    static inline void InitAsConstantBufferView(
        _Out_ D3D12_ROOT_PARAMETER1& rootParam,
        UINT shaderRegister,
        UINT registerSpace = 0,
        D3D12_ROOT_DESCRIPTOR_FLAGS flags = D3D12_ROOT_DESCRIPTOR_FLAG_NONE,
        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL) noexcept
    {
        rootParam.ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
        rootParam.ShaderVisibility = visibility;
        CD3DX12_ROOT_DESCRIPTOR1::Init(rootParam.Descriptor, shaderRegister, registerSpace, flags);
    }

    static inline void InitAsShaderResourceView(
        _Out_ D3D12_ROOT_PARAMETER1& rootParam,
        UINT shaderRegister,
        UINT registerSpace = 0,
        D3D12_ROOT_DESCRIPTOR_FLAGS flags = D3D12_ROOT_DESCRIPTOR_FLAG_NONE,
        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL) noexcept
    {
        rootParam.ParameterType = D3D12_ROOT_PARAMETER_TYPE_SRV;
        rootParam.ShaderVisibility = visibility;
        CD3DX12_ROOT_DESCRIPTOR1::Init(rootParam.Descriptor, shaderRegister, registerSpace, flags);
    }

    static inline void InitAsUnorderedAccessView(
        _Out_ D3D12_ROOT_PARAMETER1& rootParam,
        UINT shaderRegister,
        UINT registerSpace = 0,
        D3D12_ROOT_DESCRIPTOR_FLAGS flags = D3D12_ROOT_DESCRIPTOR_FLAG_NONE,
        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL) noexcept
    {
        rootParam.ParameterType = D3D12_ROOT_PARAMETER_TYPE_UAV;
        rootParam.ShaderVisibility = visibility;
        CD3DX12_ROOT_DESCRIPTOR1::Init(rootParam.Descriptor, shaderRegister, registerSpace, flags);
    }

    inline void InitAsDescriptorTable(
        UINT numDescriptorRanges,
        _In_reads_(numDescriptorRanges) const D3D12_DESCRIPTOR_RANGE1* pDescriptorRanges,
        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL) noexcept
    {
        InitAsDescriptorTable(*this, numDescriptorRanges, pDescriptorRanges, visibility);
    }

    inline void InitAsConstants(
        UINT num32BitValues,
        UINT shaderRegister,
        UINT registerSpace = 0,
        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL) noexcept
    {
        InitAsConstants(*this, num32BitValues, shaderRegister, registerSpace, visibility);
    }

    inline void InitAsConstantBufferView(
        UINT shaderRegister,
        UINT registerSpace = 0,
        D3D12_ROOT_DESCRIPTOR_FLAGS flags = D3D12_ROOT_DESCRIPTOR_FLAG_NONE,
        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL) noexcept
    {
        InitAsConstantBufferView(*this, shaderRegister, registerSpace, flags, visibility);
    }

    inline void InitAsShaderResourceView(
        UINT shaderRegister,
        UINT registerSpace = 0,
        D3D12_ROOT_DESCRIPTOR_FLAGS flags = D3D12_ROOT_DESCRIPTOR_FLAG_NONE,
        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL) noexcept
    {
        InitAsShaderResourceView(*this, shaderRegister, registerSpace, flags, visibility);
    }

    inline void InitAsUnorderedAccessView(
        UINT shaderRegister,
        UINT registerSpace = 0,
        D3D12_ROOT_DESCRIPTOR_FLAGS flags = D3D12_ROOT_DESCRIPTOR_FLAG_NONE,
        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL) noexcept
    {
        InitAsUnorderedAccessView(*this, shaderRegister, registerSpace, flags, visibility);
    }
};

//------------------------------------------------------------------------------------------------
struct CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC : public D3D12_VERSIONED_ROOT_SIGNATURE_DESC
{
    CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC() = default;
    explicit CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC(const D3D12_VERSIONED_ROOT_SIGNATURE_DESC& o) noexcept :
        D3D12_VERSIONED_ROOT_SIGNATURE_DESC(o)
    {}
    explicit CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC(const D3D12_ROOT_SIGNATURE_DESC& o) noexcept
    {
        Version = D3D_ROOT_SIGNATURE_VERSION_1_0;
        Desc_1_0 = o;
    }
    explicit CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC(const D3D12_ROOT_SIGNATURE_DESC1& o) noexcept
    {
        Version = D3D_ROOT_SIGNATURE_VERSION_1_1;
        Desc_1_1 = o;
    }
    CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC(
        UINT numParameters,
        _In_reads_opt_(numParameters) const D3D12_ROOT_PARAMETER* _pParameters,
        UINT numStaticSamplers = 0,
        _In_reads_opt_(numStaticSamplers) const D3D12_STATIC_SAMPLER_DESC* _pStaticSamplers = nullptr,
        D3D12_ROOT_SIGNATURE_FLAGS flags = D3D12_ROOT_SIGNATURE_FLAG_NONE) noexcept
    {
        Init_1_0(numParameters, _pParameters, numStaticSamplers, _pStaticSamplers, flags);
    }
    CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC(
        UINT numParameters,
        _In_reads_opt_(numParameters) const D3D12_ROOT_PARAMETER1* _pParameters,
        UINT numStaticSamplers = 0,
        _In_reads_opt_(numStaticSamplers) const D3D12_STATIC_SAMPLER_DESC* _pStaticSamplers = nullptr,
        D3D12_ROOT_SIGNATURE_FLAGS flags = D3D12_ROOT_SIGNATURE_FLAG_NONE) noexcept
    {
        Init_1_1(numParameters, _pParameters, numStaticSamplers, _pStaticSamplers, flags);
    }
    CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC(CD3DX12_DEFAULT) noexcept
    {
        Init_1_1(0, nullptr, 0, nullptr, D3D12_ROOT_SIGNATURE_FLAG_NONE);
    }

    inline void Init_1_0(
        UINT numParameters,
        _In_reads_opt_(numParameters) const D3D12_ROOT_PARAMETER* _pParameters,
        UINT numStaticSamplers = 0,
        _In_reads_opt_(numStaticSamplers) const D3D12_STATIC_SAMPLER_DESC* _pStaticSamplers = nullptr,
        D3D12_ROOT_SIGNATURE_FLAGS flags = D3D12_ROOT_SIGNATURE_FLAG_NONE) noexcept
    {
        Init_1_0(*this, numParameters, _pParameters, numStaticSamplers, _pStaticSamplers, flags);
    }

    static inline void Init_1_0(
        _Out_ D3D12_VERSIONED_ROOT_SIGNATURE_DESC& desc,
        UINT numParameters,
        _In_reads_opt_(numParameters) const D3D12_ROOT_PARAMETER* _pParameters,
        UINT numStaticSamplers = 0,
        _In_reads_opt_(numStaticSamplers) const D3D12_STATIC_SAMPLER_DESC* _pStaticSamplers = nullptr,
        D3D12_ROOT_SIGNATURE_FLAGS flags = D3D12_ROOT_SIGNATURE_FLAG_NONE) noexcept
    {
        desc.Version = D3D_ROOT_SIGNATURE_VERSION_1_0;
        desc.Desc_1_0.NumParameters = numParameters;
        desc.Desc_1_0.pParameters = _pParameters;
        desc.Desc_1_0.NumStaticSamplers = numStaticSamplers;
        desc.Desc_1_0.pStaticSamplers = _pStaticSamplers;
        desc.Desc_1_0.Flags = flags;
    }

    inline void Init_1_1(
        UINT numParameters,
        _In_reads_opt_(numParameters) const D3D12_ROOT_PARAMETER1* _pParameters,
        UINT numStaticSamplers = 0,
        _In_reads_opt_(numStaticSamplers) const D3D12_STATIC_SAMPLER_DESC* _pStaticSamplers = nullptr,
        D3D12_ROOT_SIGNATURE_FLAGS flags = D3D12_ROOT_SIGNATURE_FLAG_NONE) noexcept
    {
        Init_1_1(*this, numParameters, _pParameters, numStaticSamplers, _pStaticSamplers, flags);
    }

    static inline void Init_1_1(
        _Out_ D3D12_VERSIONED_ROOT_SIGNATURE_DESC& desc,
        UINT numParameters,
        _In_reads_opt_(numParameters) const D3D12_ROOT_PARAMETER1* _pParameters,
        UINT numStaticSamplers = 0,
        _In_reads_opt_(numStaticSamplers) const D3D12_STATIC_SAMPLER_DESC* _pStaticSamplers = nullptr,
        D3D12_ROOT_SIGNATURE_FLAGS flags = D3D12_ROOT_SIGNATURE_FLAG_NONE) noexcept
    {
        desc.Version = D3D_ROOT_SIGNATURE_VERSION_1_1;
        desc.Desc_1_1.NumParameters = numParameters;
        desc.Desc_1_1.pParameters = _pParameters;
        desc.Desc_1_1.NumStaticSamplers = numStaticSamplers;
        desc.Desc_1_1.pStaticSamplers = _pStaticSamplers;
        desc.Desc_1_1.Flags = flags;
    }
};

//------------------------------------------------------------------------------------------------
struct CD3DX12_CPU_DESCRIPTOR_HANDLE : public D3D12_CPU_DESCRIPTOR_HANDLE
{
    CD3DX12_CPU_DESCRIPTOR_HANDLE() = default;
    explicit CD3DX12_CPU_DESCRIPTOR_HANDLE(const D3D12_CPU_DESCRIPTOR_HANDLE& o) noexcept :
        D3D12_CPU_DESCRIPTOR_HANDLE(o)
    {}
    CD3DX12_CPU_DESCRIPTOR_HANDLE(CD3DX12_DEFAULT) noexcept { ptr = 0; }
    CD3DX12_CPU_DESCRIPTOR_HANDLE(_In_ const D3D12_CPU_DESCRIPTOR_HANDLE& other, INT offsetScaledByIncrementSize) noexcept
    {
        InitOffsetted(other, offsetScaledByIncrementSize);
    }
    CD3DX12_CPU_DESCRIPTOR_HANDLE(_In_ const D3D12_CPU_DESCRIPTOR_HANDLE& other, INT offsetInDescriptors, UINT descriptorIncrementSize) noexcept
    {
        InitOffsetted(other, offsetInDescriptors, descriptorIncrementSize);
    }
    CD3DX12_CPU_DESCRIPTOR_HANDLE& Offset(INT offsetInDescriptors, UINT descriptorIncrementSize) noexcept
    {
        ptr = SIZE_T(INT64(ptr) + INT64(offsetInDescriptors) * INT64(descriptorIncrementSize));
        return *this;
    }
    CD3DX12_CPU_DESCRIPTOR_HANDLE& Offset(INT offsetScaledByIncrementSize) noexcept
    {
        ptr = SIZE_T(INT64(ptr) + INT64(offsetScaledByIncrementSize));
        return *this;
    }
    bool operator==(_In_ const D3D12_CPU_DESCRIPTOR_HANDLE& other) const noexcept
    {
        return (ptr == other.ptr);
    }
    bool operator!=(_In_ const D3D12_CPU_DESCRIPTOR_HANDLE& other) const noexcept
    {
        return (ptr != other.ptr);
    }
    CD3DX12_CPU_DESCRIPTOR_HANDLE& operator=(const D3D12_CPU_DESCRIPTOR_HANDLE& other) noexcept
    {
        ptr = other.ptr;
        return *this;
    }

    inline void InitOffsetted(_In_ const D3D12_CPU_DESCRIPTOR_HANDLE& base, INT offsetScaledByIncrementSize) noexcept
    {
        InitOffsetted(*this, base, offsetScaledByIncrementSize);
    }

    inline void InitOffsetted(_In_ const D3D12_CPU_DESCRIPTOR_HANDLE& base, INT offsetInDescriptors, UINT descriptorIncrementSize) noexcept
    {
        InitOffsetted(*this, base, offsetInDescriptors, descriptorIncrementSize);
    }

    static inline void InitOffsetted(_Out_ D3D12_CPU_DESCRIPTOR_HANDLE& handle, _In_ const D3D12_CPU_DESCRIPTOR_HANDLE& base, INT offsetScaledByIncrementSize) noexcept
    {
        handle.ptr = SIZE_T(INT64(base.ptr) + INT64(offsetScaledByIncrementSize));
    }

    static inline void InitOffsetted(_Out_ D3D12_CPU_DESCRIPTOR_HANDLE& handle, _In_ const D3D12_CPU_DESCRIPTOR_HANDLE& base, INT offsetInDescriptors, UINT descriptorIncrementSize) noexcept
    {
        handle.ptr = SIZE_T(INT64(base.ptr) + INT64(offsetInDescriptors) * INT64(descriptorIncrementSize));
    }
};

//------------------------------------------------------------------------------------------------
struct CD3DX12_GPU_DESCRIPTOR_HANDLE : public D3D12_GPU_DESCRIPTOR_HANDLE
{
    CD3DX12_GPU_DESCRIPTOR_HANDLE() = default;
    explicit CD3DX12_GPU_DESCRIPTOR_HANDLE(const D3D12_GPU_DESCRIPTOR_HANDLE& o) noexcept :
        D3D12_GPU_DESCRIPTOR_HANDLE(o)
    {}
    CD3DX12_GPU_DESCRIPTOR_HANDLE(CD3DX12_DEFAULT) noexcept { ptr = 0; }
    CD3DX12_GPU_DESCRIPTOR_HANDLE(_In_ const D3D12_GPU_DESCRIPTOR_HANDLE& other, INT offsetScaledByIncrementSize) noexcept
    {
        InitOffsetted(other, offsetScaledByIncrementSize);
    }
    CD3DX12_GPU_DESCRIPTOR_HANDLE(_In_ const D3D12_GPU_DESCRIPTOR_HANDLE& other, INT offsetInDescriptors, UINT descriptorIncrementSize) noexcept
    {
        InitOffsetted(other, offsetInDescriptors, descriptorIncrementSize);
    }
    CD3DX12_GPU_DESCRIPTOR_HANDLE& Offset(INT offsetInDescriptors, UINT descriptorIncrementSize) noexcept
    {
        ptr = UINT64(INT64(ptr) + INT64(offsetInDescriptors) * INT64(descriptorIncrementSize));
        return *this;
    }
    CD3DX12_GPU_DESCRIPTOR_HANDLE& Offset(INT offsetScaledByIncrementSize) noexcept
    {
        ptr = UINT64(INT64(ptr) + INT64(offsetScaledByIncrementSize));
        return *this;
    }
    inline bool operator==(_In_ const D3D12_GPU_DESCRIPTOR_HANDLE& other) const noexcept
    {
        return (ptr == other.ptr);
    }
    inline bool operator!=(_In_ const D3D12_GPU_DESCRIPTOR_HANDLE& other) const noexcept
    {
        return (ptr != other.ptr);
    }
    CD3DX12_GPU_DESCRIPTOR_HANDLE& operator=(const D3D12_GPU_DESCRIPTOR_HANDLE& other) noexcept
    {
        ptr = other.ptr;
        return *this;
    }

    inline void InitOffsetted(_In_ const D3D12_GPU_DESCRIPTOR_HANDLE& base, INT offsetScaledByIncrementSize) noexcept
    {
        InitOffsetted(*this, base, offsetScaledByIncrementSize);
    }

    inline void InitOffsetted(_In_ const D3D12_GPU_DESCRIPTOR_HANDLE& base, INT offsetInDescriptors, UINT descriptorIncrementSize) noexcept
    {
        InitOffsetted(*this, base, offsetInDescriptors, descriptorIncrementSize);
    }

    static inline void InitOffsetted(_Out_ D3D12_GPU_DESCRIPTOR_HANDLE& handle, _In_ const D3D12_GPU_DESCRIPTOR_HANDLE& base, INT offsetScaledByIncrementSize) noexcept
    {
        handle.ptr = UINT64(INT64(base.ptr) + INT64(offsetScaledByIncrementSize));
    }

    static inline void InitOffsetted(_Out_ D3D12_GPU_DESCRIPTOR_HANDLE& handle, _In_ const D3D12_GPU_DESCRIPTOR_HANDLE& base, INT offsetInDescriptors, UINT descriptorIncrementSize) noexcept
    {
        handle.ptr = UINT64(INT64(base.ptr) + INT64(offsetInDescriptors) * INT64(descriptorIncrementSize));
    }
};

//------------------------------------------------------------------------------------------------
inline constexpr UINT D3D12CalcSubresource(UINT MipSlice, UINT ArraySlice, UINT PlaneSlice, UINT MipLevels, UINT ArraySize) noexcept
{
    return MipSlice + ArraySlice * MipLevels + PlaneSlice * MipLevels * ArraySize;
}

//------------------------------------------------------------------------------------------------
template <typename T, typename U, typename V>
inline void D3D12DecomposeSubresource(UINT Subresource, UINT MipLevels, UINT ArraySize, _Out_ T& MipSlice, _Out_ U& ArraySlice, _Out_ V& PlaneSlice) noexcept
{
    MipSlice = static_cast<T>(Subresource % MipLevels);
    ArraySlice = static_cast<U>((Subresource / MipLevels) % ArraySize);
    PlaneSlice = static_cast<V>(Subresource / (MipLevels * ArraySize));
}

//------------------------------------------------------------------------------------------------
inline UINT8 D3D12GetFormatPlaneCount(
    _In_ ID3D12Device* pDevice,
    DXGI_FORMAT Format
) noexcept
{
    D3D12_FEATURE_DATA_FORMAT_INFO formatInfo = { Format, 0 };
    if (FAILED(pDevice->CheckFeatureSupport(D3D12_FEATURE_FORMAT_INFO, &formatInfo, sizeof(formatInfo))))
    {
        return 0;
    }
    return formatInfo.PlaneCount;
}

//------------------------------------------------------------------------------------------------
struct CD3DX12_RESOURCE_DESC : public D3D12_RESOURCE_DESC
{
    CD3DX12_RESOURCE_DESC() = default;
    explicit CD3DX12_RESOURCE_DESC(const D3D12_RESOURCE_DESC& o) noexcept :
        D3D12_RESOURCE_DESC(o)
    {}
    CD3DX12_RESOURCE_DESC(
        D3D12_RESOURCE_DIMENSION dimension,
        UINT64 alignment,
        UINT64 width,
        UINT height,
        UINT16 depthOrArraySize,
        UINT16 mipLevels,
        DXGI_FORMAT format,
        UINT sampleCount,
        UINT sampleQuality,
        D3D12_TEXTURE_LAYOUT layout,
        D3D12_RESOURCE_FLAGS flags) noexcept
    {
        Dimension = dimension;
        Alignment = alignment;
        Width = width;
        Height = height;
        DepthOrArraySize = depthOrArraySize;
        MipLevels = mipLevels;
        Format = format;
        SampleDesc.Count = sampleCount;
        SampleDesc.Quality = sampleQuality;
        Layout = layout;
        Flags = flags;
    }
    static inline CD3DX12_RESOURCE_DESC Buffer(
        const D3D12_RESOURCE_ALLOCATION_INFO& resAllocInfo,
        D3D12_RESOURCE_FLAGS flags = D3D12_RESOURCE_FLAG_NONE) noexcept
    {
        return CD3DX12_RESOURCE_DESC(D3D12_RESOURCE_DIMENSION_BUFFER, resAllocInfo.Alignment, resAllocInfo.SizeInBytes,
            1, 1, 1, DXGI_FORMAT_UNKNOWN, 1, 0, D3D12_TEXTURE_LAYOUT_ROW_MAJOR, flags);
    }
    static inline CD3DX12_RESOURCE_DESC Buffer(
        UINT64 width,
        D3D12_RESOURCE_FLAGS flags = D3D12_RESOURCE_FLAG_NONE,
        UINT64 alignment = 0) noexcept
    {
        return CD3DX12_RESOURCE_DESC(D3D12_RESOURCE_DIMENSION_BUFFER, alignment, width, 1, 1, 1,
            DXGI_FORMAT_UNKNOWN, 1, 0, D3D12_TEXTURE_LAYOUT_ROW_MAJOR, flags);
    }
    static inline CD3DX12_RESOURCE_DESC Tex1D(
        DXGI_FORMAT format,
        UINT64 width,
        UINT16 arraySize = 1,
        UINT16 mipLevels = 0,
        D3D12_RESOURCE_FLAGS flags = D3D12_RESOURCE_FLAG_NONE,
        D3D12_TEXTURE_LAYOUT layout = D3D12_TEXTURE_LAYOUT_UNKNOWN,
        UINT64 alignment = 0) noexcept
    {
        return CD3DX12_RESOURCE_DESC(D3D12_RESOURCE_DIMENSION_TEXTURE1D, alignment, width, 1, arraySize,
            mipLevels, format, 1, 0, layout, flags);
    }
    static inline CD3DX12_RESOURCE_DESC Tex2D(
        DXGI_FORMAT format,
        UINT64 width,
        UINT height,
        UINT16 arraySize = 1,
        UINT16 mipLevels = 0,
        UINT sampleCount = 1,
        UINT sampleQuality = 0,
        D3D12_RESOURCE_FLAGS flags = D3D12_RESOURCE_FLAG_NONE,
        D3D12_TEXTURE_LAYOUT layout = D3D12_TEXTURE_LAYOUT_UNKNOWN,
        UINT64 alignment = 0) noexcept
    {
        return CD3DX12_RESOURCE_DESC(D3D12_RESOURCE_DIMENSION_TEXTURE2D, alignment, width, height, arraySize,
            mipLevels, format, sampleCount, sampleQuality, layout, flags);
    }
    static inline CD3DX12_RESOURCE_DESC Tex3D(
        DXGI_FORMAT format,
        UINT64 width,
        UINT height,
        UINT16 depth,
        UINT16 mipLevels = 0,
        D3D12_RESOURCE_FLAGS flags = D3D12_RESOURCE_FLAG_NONE,
        D3D12_TEXTURE_LAYOUT layout = D3D12_TEXTURE_LAYOUT_UNKNOWN,
        UINT64 alignment = 0) noexcept
    {
        return CD3DX12_RESOURCE_DESC(D3D12_RESOURCE_DIMENSION_TEXTURE3D, alignment, width, height, depth,
            mipLevels, format, 1, 0, layout, flags);
    }
    inline UINT16 Depth() const noexcept
    {
        return (Dimension == D3D12_RESOURCE_DIMENSION_TEXTURE3D ? DepthOrArraySize : 1);
    }
    inline UINT16 ArraySize() const noexcept
    {
        return (Dimension != D3D12_RESOURCE_DIMENSION_TEXTURE3D ? DepthOrArraySize : 1);
    }
    inline UINT8 PlaneCount(_In_ ID3D12Device* pDevice) const noexcept
    {
        return D3D12GetFormatPlaneCount(pDevice, Format);
    }
    inline UINT Subresources(_In_ ID3D12Device* pDevice) const noexcept
    {
        return MipLevels * ArraySize() * PlaneCount(pDevice);
    }
    inline UINT CalcSubresource(UINT MipSlice, UINT ArraySlice, UINT PlaneSlice) noexcept
    {
        return D3D12CalcSubresource(MipSlice, ArraySlice, PlaneSlice, MipLevels, ArraySize());
    }
};
inline bool operator==(const D3D12_RESOURCE_DESC& l, const D3D12_RESOURCE_DESC& r) noexcept
{
    return l.Dimension == r.Dimension &&
        l.Alignment == r.Alignment &&
        l.Width == r.Width &&
        l.Height == r.Height &&
        l.DepthOrArraySize == r.DepthOrArraySize &&
        l.MipLevels == r.MipLevels &&
        l.Format == r.Format &&
        l.SampleDesc.Count == r.SampleDesc.Count &&
        l.SampleDesc.Quality == r.SampleDesc.Quality &&
        l.Layout == r.Layout &&
        l.Flags == r.Flags;
}
inline bool operator!=(const D3D12_RESOURCE_DESC& l, const D3D12_RESOURCE_DESC& r) noexcept
{
    return !(l == r);
}

//------------------------------------------------------------------------------------------------
// Requires the Windows 10 SDK (19041)
#if defined(NTDDI_WIN10_VB) && (NTDDI_VERSION >= NTDDI_WIN10_VB)
struct CD3DX12_RESOURCE_DESC1 : public D3D12_RESOURCE_DESC1
{
    CD3DX12_RESOURCE_DESC1() = default;
    explicit CD3DX12_RESOURCE_DESC1(const D3D12_RESOURCE_DESC1& o) noexcept :
        D3D12_RESOURCE_DESC1(o)
    {}
    CD3DX12_RESOURCE_DESC1(
        D3D12_RESOURCE_DIMENSION dimension,
        UINT64 alignment,
        UINT64 width,
        UINT height,
        UINT16 depthOrArraySize,
        UINT16 mipLevels,
        DXGI_FORMAT format,
        UINT sampleCount,
        UINT sampleQuality,
        D3D12_TEXTURE_LAYOUT layout,
        D3D12_RESOURCE_FLAGS flags,
        UINT samplerFeedbackMipRegionWidth = 0,
        UINT samplerFeedbackMipRegionHeight = 0,
        UINT samplerFeedbackMipRegionDepth = 0) noexcept
    {
        Dimension = dimension;
        Alignment = alignment;
        Width = width;
        Height = height;
        DepthOrArraySize = depthOrArraySize;
        MipLevels = mipLevels;
        Format = format;
        SampleDesc.Count = sampleCount;
        SampleDesc.Quality = sampleQuality;
        Layout = layout;
        Flags = flags;
        SamplerFeedbackMipRegion.Width = samplerFeedbackMipRegionWidth;
        SamplerFeedbackMipRegion.Height = samplerFeedbackMipRegionHeight;
        SamplerFeedbackMipRegion.Depth = samplerFeedbackMipRegionDepth;
    }
    static inline CD3DX12_RESOURCE_DESC1 Buffer(
        const D3D12_RESOURCE_ALLOCATION_INFO& resAllocInfo,
        D3D12_RESOURCE_FLAGS flags = D3D12_RESOURCE_FLAG_NONE) noexcept
    {
        return CD3DX12_RESOURCE_DESC1(D3D12_RESOURCE_DIMENSION_BUFFER, resAllocInfo.Alignment, resAllocInfo.SizeInBytes,
            1, 1, 1, DXGI_FORMAT_UNKNOWN, 1, 0, D3D12_TEXTURE_LAYOUT_ROW_MAJOR, flags, 0, 0, 0);
    }
    static inline CD3DX12_RESOURCE_DESC1 Buffer(
        UINT64 width,
        D3D12_RESOURCE_FLAGS flags = D3D12_RESOURCE_FLAG_NONE,
        UINT64 alignment = 0) noexcept
    {
        return CD3DX12_RESOURCE_DESC1(D3D12_RESOURCE_DIMENSION_BUFFER, alignment, width, 1, 1, 1,
            DXGI_FORMAT_UNKNOWN, 1, 0, D3D12_TEXTURE_LAYOUT_ROW_MAJOR, flags, 0, 0, 0);
    }
    static inline CD3DX12_RESOURCE_DESC1 Tex1D(
        DXGI_FORMAT format,
        UINT64 width,
        UINT16 arraySize = 1,
        UINT16 mipLevels = 0,
        D3D12_RESOURCE_FLAGS flags = D3D12_RESOURCE_FLAG_NONE,
        D3D12_TEXTURE_LAYOUT layout = D3D12_TEXTURE_LAYOUT_UNKNOWN,
        UINT64 alignment = 0) noexcept
    {
        return CD3DX12_RESOURCE_DESC1(D3D12_RESOURCE_DIMENSION_TEXTURE1D, alignment, width, 1, arraySize,
            mipLevels, format, 1, 0, layout, flags, 0, 0, 0);
    }
    static inline CD3DX12_RESOURCE_DESC1 Tex2D(
        DXGI_FORMAT format,
        UINT64 width,
        UINT height,
        UINT16 arraySize = 1,
        UINT16 mipLevels = 0,
        UINT sampleCount = 1,
        UINT sampleQuality = 0,
        D3D12_RESOURCE_FLAGS flags = D3D12_RESOURCE_FLAG_NONE,
        D3D12_TEXTURE_LAYOUT layout = D3D12_TEXTURE_LAYOUT_UNKNOWN,
        UINT64 alignment = 0,
        UINT samplerFeedbackMipRegionWidth = 0,
        UINT samplerFeedbackMipRegionHeight = 0,
        UINT samplerFeedbackMipRegionDepth = 0) noexcept
    {
        return CD3DX12_RESOURCE_DESC1(D3D12_RESOURCE_DIMENSION_TEXTURE2D, alignment, width, height, arraySize,
            mipLevels, format, sampleCount, sampleQuality, layout, flags, samplerFeedbackMipRegionWidth,
            samplerFeedbackMipRegionHeight, samplerFeedbackMipRegionDepth);
    }
    static inline CD3DX12_RESOURCE_DESC1 Tex3D(
        DXGI_FORMAT format,
        UINT64 width,
        UINT height,
        UINT16 depth,
        UINT16 mipLevels = 0,
        D3D12_RESOURCE_FLAGS flags = D3D12_RESOURCE_FLAG_NONE,
        D3D12_TEXTURE_LAYOUT layout = D3D12_TEXTURE_LAYOUT_UNKNOWN,
        UINT64 alignment = 0) noexcept
    {
        return CD3DX12_RESOURCE_DESC1(D3D12_RESOURCE_DIMENSION_TEXTURE3D, alignment, width, height, depth,
            mipLevels, format, 1, 0, layout, flags, 0, 0, 0);
    }
    inline UINT16 Depth() const noexcept
    {
        return (Dimension == D3D12_RESOURCE_DIMENSION_TEXTURE3D ? DepthOrArraySize : 1);
    }
    inline UINT16 ArraySize() const noexcept
    {
        return (Dimension != D3D12_RESOURCE_DIMENSION_TEXTURE3D ? DepthOrArraySize : 1);
    }
    inline UINT8 PlaneCount(_In_ ID3D12Device* pDevice) const noexcept
    {
        return D3D12GetFormatPlaneCount(pDevice, Format);
    }
    inline UINT Subresources(_In_ ID3D12Device* pDevice) const noexcept
    {
        return MipLevels * ArraySize() * PlaneCount(pDevice);
    }
    inline UINT CalcSubresource(UINT MipSlice, UINT ArraySlice, UINT PlaneSlice) noexcept
    {
        return D3D12CalcSubresource(MipSlice, ArraySlice, PlaneSlice, MipLevels, ArraySize());
    }
};
inline bool operator==(const D3D12_RESOURCE_DESC1& l, const D3D12_RESOURCE_DESC1& r) noexcept
{
    return l.Dimension == r.Dimension &&
        l.Alignment == r.Alignment &&
        l.Width == r.Width &&
        l.Height == r.Height &&
        l.DepthOrArraySize == r.DepthOrArraySize &&
        l.MipLevels == r.MipLevels &&
        l.Format == r.Format &&
        l.SampleDesc.Count == r.SampleDesc.Count &&
        l.SampleDesc.Quality == r.SampleDesc.Quality &&
        l.Layout == r.Layout &&
        l.Flags == r.Flags &&
        l.SamplerFeedbackMipRegion.Width == r.SamplerFeedbackMipRegion.Width &&
        l.SamplerFeedbackMipRegion.Height == r.SamplerFeedbackMipRegion.Height &&
        l.SamplerFeedbackMipRegion.Depth == r.SamplerFeedbackMipRegion.Depth;
}
inline bool operator!=(const D3D12_RESOURCE_DESC1& l, const D3D12_RESOURCE_DESC1& r) noexcept
{
    return !(l == r);
}
#endif // NTDDI_WIN10_VB

//------------------------------------------------------------------------------------------------
// Requires the Windows 10 Fall Creators Update SDK (16299)
#if defined(NTDDI_WIN10_RS3) && (NTDDI_VERSION >= NTDDI_WIN10_RS3)
struct CD3DX12_VIEW_INSTANCING_DESC : public D3D12_VIEW_INSTANCING_DESC
{
    CD3DX12_VIEW_INSTANCING_DESC() = default;
    explicit CD3DX12_VIEW_INSTANCING_DESC(const D3D12_VIEW_INSTANCING_DESC& o) noexcept :
        D3D12_VIEW_INSTANCING_DESC(o)
    {}
    explicit CD3DX12_VIEW_INSTANCING_DESC(CD3DX12_DEFAULT) noexcept
    {
        ViewInstanceCount = 0;
        pViewInstanceLocations = nullptr;
        Flags = D3D12_VIEW_INSTANCING_FLAG_NONE;
    }
    explicit CD3DX12_VIEW_INSTANCING_DESC(
        UINT InViewInstanceCount,
        const D3D12_VIEW_INSTANCE_LOCATION* InViewInstanceLocations,
        D3D12_VIEW_INSTANCING_FLAGS InFlags) noexcept
    {
        ViewInstanceCount = InViewInstanceCount;
        pViewInstanceLocations = InViewInstanceLocations;
        Flags = InFlags;
    }
};
#endif // NTDDI_WIN10_RS3

//------------------------------------------------------------------------------------------------
// Row-by-row memcpy
inline void MemcpySubresource(
    _In_ const D3D12_MEMCPY_DEST* pDest,
    _In_ const D3D12_SUBRESOURCE_DATA* pSrc,
    SIZE_T RowSizeInBytes,
    UINT NumRows,
    UINT NumSlices) noexcept
{
    for (UINT z = 0; z < NumSlices; ++z)
    {
        auto pDestSlice = static_cast<BYTE*>(pDest->pData) + pDest->SlicePitch * z;
        auto pSrcSlice = static_cast<const BYTE*>(pSrc->pData) + pSrc->SlicePitch * LONG_PTR(z);
        for (UINT y = 0; y < NumRows; ++y)
        {
            memcpy(pDestSlice + pDest->RowPitch * y,
                pSrcSlice + pSrc->RowPitch * LONG_PTR(y),
                RowSizeInBytes);
        }
    }
}

//------------------------------------------------------------------------------------------------
// Row-by-row memcpy
inline void MemcpySubresource(
    _In_ const D3D12_MEMCPY_DEST* pDest,
    _In_ const void* pResourceData,
    _In_ const D3D12_SUBRESOURCE_INFO* pSrc,
    SIZE_T RowSizeInBytes,
    UINT NumRows,
    UINT NumSlices) noexcept
{
    for (UINT z = 0; z < NumSlices; ++z)
    {
        auto pDestSlice = static_cast<BYTE*>(pDest->pData) + pDest->SlicePitch * z;
        auto pSrcSlice = (static_cast<const BYTE*>(pResourceData) + pSrc->Offset) + pSrc->DepthPitch * LONG_PTR(z);
        for (UINT y = 0; y < NumRows; ++y)
        {
            memcpy(pDestSlice + pDest->RowPitch * y,
                pSrcSlice + pSrc->RowPitch * LONG_PTR(y),
                RowSizeInBytes);
        }
    }
}

//------------------------------------------------------------------------------------------------
// Returns required size of a buffer to be used for data upload
inline UINT64 GetRequiredIntermediateSize(
    _In_ ID3D12Resource* pDestinationResource,
    _In_range_(0, D3D12_REQ_SUBRESOURCES) UINT FirstSubresource,
    _In_range_(0, D3D12_REQ_SUBRESOURCES - FirstSubresource) UINT NumSubresources) noexcept
{
    auto Desc = pDestinationResource->GetDesc();
    UINT64 RequiredSize = 0;

    ID3D12Device* pDevice = nullptr;
    pDestinationResource->GetDevice(IID_ID3D12Device, reinterpret_cast<void**>(&pDevice));
    pDevice->GetCopyableFootprints(&Desc, FirstSubresource, NumSubresources, 0, nullptr, nullptr, nullptr, &RequiredSize);
    pDevice->Release();

    return RequiredSize;
}

//------------------------------------------------------------------------------------------------
// All arrays must be populated (e.g. by calling GetCopyableFootprints)
inline UINT64 UpdateSubresources(
    _In_ ID3D12GraphicsCommandList* pCmdList,
    _In_ ID3D12Resource* pDestinationResource,
    _In_ ID3D12Resource* pIntermediate,
    _In_range_(0, D3D12_REQ_SUBRESOURCES) UINT FirstSubresource,
    _In_range_(0, D3D12_REQ_SUBRESOURCES - FirstSubresource) UINT NumSubresources,
    UINT64 RequiredSize,
    _In_reads_(NumSubresources) const D3D12_PLACED_SUBRESOURCE_FOOTPRINT* pLayouts,
    _In_reads_(NumSubresources) const UINT* pNumRows,
    _In_reads_(NumSubresources) const UINT64* pRowSizesInBytes,
    _In_reads_(NumSubresources) const D3D12_SUBRESOURCE_DATA* pSrcData) noexcept
{
    // Minor validation
    auto IntermediateDesc = pIntermediate->GetDesc();
    auto DestinationDesc = pDestinationResource->GetDesc();
    if (IntermediateDesc.Dimension != D3D12_RESOURCE_DIMENSION_BUFFER ||
        IntermediateDesc.Width < RequiredSize + pLayouts[0].Offset ||
        RequiredSize > SIZE_T(-1) ||
        (DestinationDesc.Dimension == D3D12_RESOURCE_DIMENSION_BUFFER &&
            (FirstSubresource != 0 || NumSubresources != 1)))
    {
        return 0;
    }

    BYTE* pData;
    HRESULT hr = pIntermediate->Map(0, nullptr, reinterpret_cast<void**>(&pData));
    if (FAILED(hr))
    {
        return 0;
    }

    for (UINT i = 0; i < NumSubresources; ++i)
    {
        if (pRowSizesInBytes[i] > SIZE_T(-1)) return 0;
        D3D12_MEMCPY_DEST DestData = { pData + pLayouts[i].Offset, pLayouts[i].Footprint.RowPitch, SIZE_T(pLayouts[i].Footprint.RowPitch) * SIZE_T(pNumRows[i]) };
        MemcpySubresource(&DestData, &pSrcData[i], static_cast<SIZE_T>(pRowSizesInBytes[i]), pNumRows[i], pLayouts[i].Footprint.Depth);
    }
    pIntermediate->Unmap(0, nullptr);

    if (DestinationDesc.Dimension == D3D12_RESOURCE_DIMENSION_BUFFER)
    {
        pCmdList->CopyBufferRegion(
            pDestinationResource, 0, pIntermediate, pLayouts[0].Offset, pLayouts[0].Footprint.Width);
    }
    else
    {
        for (UINT i = 0; i < NumSubresources; ++i)
        {
            CD3DX12_TEXTURE_COPY_LOCATION Dst(pDestinationResource, i + FirstSubresource);
            CD3DX12_TEXTURE_COPY_LOCATION Src(pIntermediate, pLayouts[i]);
            pCmdList->CopyTextureRegion(&Dst, 0, 0, 0, &Src, nullptr);
        }
    }
    return RequiredSize;
}

//------------------------------------------------------------------------------------------------
// All arrays must be populated (e.g. by calling GetCopyableFootprints)
inline UINT64 UpdateSubresources(
    _In_ ID3D12GraphicsCommandList* pCmdList,
    _In_ ID3D12Resource* pDestinationResource,
    _In_ ID3D12Resource* pIntermediate,
    _In_range_(0, D3D12_REQ_SUBRESOURCES) UINT FirstSubresource,
    _In_range_(0, D3D12_REQ_SUBRESOURCES - FirstSubresource) UINT NumSubresources,
    UINT64 RequiredSize,
    _In_reads_(NumSubresources) const D3D12_PLACED_SUBRESOURCE_FOOTPRINT* pLayouts,
    _In_reads_(NumSubresources) const UINT* pNumRows,
    _In_reads_(NumSubresources) const UINT64* pRowSizesInBytes,
    _In_ const void* pResourceData,
    _In_reads_(NumSubresources) const D3D12_SUBRESOURCE_INFO* pSrcData) noexcept
{
    // Minor validation
    auto IntermediateDesc = pIntermediate->GetDesc();
    auto DestinationDesc = pDestinationResource->GetDesc();
    if (IntermediateDesc.Dimension != D3D12_RESOURCE_DIMENSION_BUFFER ||
        IntermediateDesc.Width < RequiredSize + pLayouts[0].Offset ||
        RequiredSize > SIZE_T(-1) ||
        (DestinationDesc.Dimension == D3D12_RESOURCE_DIMENSION_BUFFER &&
            (FirstSubresource != 0 || NumSubresources != 1)))
    {
        return 0;
    }

    BYTE* pData;
    HRESULT hr = pIntermediate->Map(0, nullptr, reinterpret_cast<void**>(&pData));
    if (FAILED(hr))
    {
        return 0;
    }

    for (UINT i = 0; i < NumSubresources; ++i)
    {
        if (pRowSizesInBytes[i] > SIZE_T(-1)) return 0;
        D3D12_MEMCPY_DEST DestData = { pData + pLayouts[i].Offset, pLayouts[i].Footprint.RowPitch, SIZE_T(pLayouts[i].Footprint.RowPitch) * SIZE_T(pNumRows[i]) };
        MemcpySubresource(&DestData, pResourceData, &pSrcData[i], static_cast<SIZE_T>(pRowSizesInBytes[i]), pNumRows[i], pLayouts[i].Footprint.Depth);
    }
    pIntermediate->Unmap(0, nullptr);

    if (DestinationDesc.Dimension == D3D12_RESOURCE_DIMENSION_BUFFER)
    {
        pCmdList->CopyBufferRegion(
            pDestinationResource, 0, pIntermediate, pLayouts[0].Offset, pLayouts[0].Footprint.Width);
    }
    else
    {
        for (UINT i = 0; i < NumSubresources; ++i)
        {
            CD3DX12_TEXTURE_COPY_LOCATION Dst(pDestinationResource, i + FirstSubresource);
            CD3DX12_TEXTURE_COPY_LOCATION Src(pIntermediate, pLayouts[i]);
            pCmdList->CopyTextureRegion(&Dst, 0, 0, 0, &Src, nullptr);
        }
    }
    return RequiredSize;
}

//------------------------------------------------------------------------------------------------
// Heap-allocating UpdateSubresources implementation
inline UINT64 UpdateSubresources(
    _In_ ID3D12GraphicsCommandList* pCmdList,
    _In_ ID3D12Resource* pDestinationResource,
    _In_ ID3D12Resource* pIntermediate,
    UINT64 IntermediateOffset,
    _In_range_(0, D3D12_REQ_SUBRESOURCES) UINT FirstSubresource,
    _In_range_(0, D3D12_REQ_SUBRESOURCES - FirstSubresource) UINT NumSubresources,
    _In_reads_(NumSubresources) const D3D12_SUBRESOURCE_DATA* pSrcData) noexcept
{
    UINT64 RequiredSize = 0;
    auto MemToAlloc = static_cast<UINT64>(sizeof(D3D12_PLACED_SUBRESOURCE_FOOTPRINT) + sizeof(UINT) + sizeof(UINT64)) * NumSubresources;
    if (MemToAlloc > SIZE_MAX)
    {
        return 0;
    }
    void* pMem = HeapAlloc(GetProcessHeap(), 0, static_cast<SIZE_T>(MemToAlloc));
    if (pMem == nullptr)
    {
        return 0;
    }
    auto pLayouts = static_cast<D3D12_PLACED_SUBRESOURCE_FOOTPRINT*>(pMem);
    auto pRowSizesInBytes = reinterpret_cast<UINT64*>(pLayouts + NumSubresources);
    auto pNumRows = reinterpret_cast<UINT*>(pRowSizesInBytes + NumSubresources);

    auto Desc = pDestinationResource->GetDesc();
    ID3D12Device* pDevice = nullptr;
    pDestinationResource->GetDevice(IID_ID3D12Device, reinterpret_cast<void**>(&pDevice));
    pDevice->GetCopyableFootprints(&Desc, FirstSubresource, NumSubresources, IntermediateOffset, pLayouts, pNumRows, pRowSizesInBytes, &RequiredSize);
    pDevice->Release();

    UINT64 Result = UpdateSubresources(pCmdList, pDestinationResource, pIntermediate, FirstSubresource, NumSubresources, RequiredSize, pLayouts, pNumRows, pRowSizesInBytes, pSrcData);
    HeapFree(GetProcessHeap(), 0, pMem);
    return Result;
}

//------------------------------------------------------------------------------------------------
// Heap-allocating UpdateSubresources implementation
inline UINT64 UpdateSubresources(
    _In_ ID3D12GraphicsCommandList* pCmdList,
    _In_ ID3D12Resource* pDestinationResource,
    _In_ ID3D12Resource* pIntermediate,
    UINT64 IntermediateOffset,
    _In_range_(0, D3D12_REQ_SUBRESOURCES) UINT FirstSubresource,
    _In_range_(0, D3D12_REQ_SUBRESOURCES - FirstSubresource) UINT NumSubresources,
    _In_ const void* pResourceData,
    _In_reads_(NumSubresources) D3D12_SUBRESOURCE_INFO* pSrcData) noexcept
{
    UINT64 RequiredSize = 0;
    auto MemToAlloc = static_cast<UINT64>(sizeof(D3D12_PLACED_SUBRESOURCE_FOOTPRINT) + sizeof(UINT) + sizeof(UINT64)) * NumSubresources;
    if (MemToAlloc > SIZE_MAX)
    {
        return 0;
    }
    void* pMem = HeapAlloc(GetProcessHeap(), 0, static_cast<SIZE_T>(MemToAlloc));
    if (pMem == nullptr)
    {
        return 0;
    }
    auto pLayouts = reinterpret_cast<D3D12_PLACED_SUBRESOURCE_FOOTPRINT*>(pMem);
    auto pRowSizesInBytes = reinterpret_cast<UINT64*>(pLayouts + NumSubresources);
    auto pNumRows = reinterpret_cast<UINT*>(pRowSizesInBytes + NumSubresources);

    auto Desc = pDestinationResource->GetDesc();
    ID3D12Device* pDevice = nullptr;
    pDestinationResource->GetDevice(IID_ID3D12Device, reinterpret_cast<void**>(&pDevice));
    pDevice->GetCopyableFootprints(&Desc, FirstSubresource, NumSubresources, IntermediateOffset, pLayouts, pNumRows, pRowSizesInBytes, &RequiredSize);
    pDevice->Release();

    UINT64 Result = UpdateSubresources(pCmdList, pDestinationResource, pIntermediate, FirstSubresource, NumSubresources, RequiredSize, pLayouts, pNumRows, pRowSizesInBytes, pResourceData, pSrcData);
    HeapFree(GetProcessHeap(), 0, pMem);
    return Result;
}

//------------------------------------------------------------------------------------------------
// Stack-allocating UpdateSubresources implementation
template <UINT MaxSubresources>
inline UINT64 UpdateSubresources(
    _In_ ID3D12GraphicsCommandList* pCmdList,
    _In_ ID3D12Resource* pDestinationResource,
    _In_ ID3D12Resource* pIntermediate,
    UINT64 IntermediateOffset,
    _In_range_(0, MaxSubresources) UINT FirstSubresource,
    _In_range_(1, MaxSubresources - FirstSubresource) UINT NumSubresources,
    _In_reads_(NumSubresources) const D3D12_SUBRESOURCE_DATA* pSrcData) noexcept
{
    UINT64 RequiredSize = 0;
    D3D12_PLACED_SUBRESOURCE_FOOTPRINT Layouts[MaxSubresources];
    UINT NumRows[MaxSubresources];
    UINT64 RowSizesInBytes[MaxSubresources];

    auto Desc = pDestinationResource->GetDesc();
    ID3D12Device* pDevice = nullptr;
    pDestinationResource->GetDevice(IID_ID3D12Device, reinterpret_cast<void**>(&pDevice));
    pDevice->GetCopyableFootprints(&Desc, FirstSubresource, NumSubresources, IntermediateOffset, Layouts, NumRows, RowSizesInBytes, &RequiredSize);
    pDevice->Release();

    return UpdateSubresources(pCmdList, pDestinationResource, pIntermediate, FirstSubresource, NumSubresources, RequiredSize, Layouts, NumRows, RowSizesInBytes, pSrcData);
}

//------------------------------------------------------------------------------------------------
// Stack-allocating UpdateSubresources implementation
template <UINT MaxSubresources>
inline UINT64 UpdateSubresources(
    _In_ ID3D12GraphicsCommandList* pCmdList,
    _In_ ID3D12Resource* pDestinationResource,
    _In_ ID3D12Resource* pIntermediate,
    UINT64 IntermediateOffset,
    _In_range_(0, MaxSubresources) UINT FirstSubresource,
    _In_range_(1, MaxSubresources - FirstSubresource) UINT NumSubresources,
    _In_ const void* pResourceData,
    _In_reads_(NumSubresources) D3D12_SUBRESOURCE_INFO* pSrcData) noexcept
{
    UINT64 RequiredSize = 0;
    D3D12_PLACED_SUBRESOURCE_FOOTPRINT Layouts[MaxSubresources];
    UINT NumRows[MaxSubresources];
    UINT64 RowSizesInBytes[MaxSubresources];

    auto Desc = pDestinationResource->GetDesc();
    ID3D12Device* pDevice = nullptr;
    pDestinationResource->GetDevice(IID_ID3D12Device, reinterpret_cast<void**>(&pDevice));
    pDevice->GetCopyableFootprints(&Desc, FirstSubresource, NumSubresources, IntermediateOffset, Layouts, NumRows, RowSizesInBytes, &RequiredSize);
    pDevice->Release();

    return UpdateSubresources(pCmdList, pDestinationResource, pIntermediate, FirstSubresource, NumSubresources, RequiredSize, Layouts, NumRows, RowSizesInBytes, pResourceData, pSrcData);
}

//------------------------------------------------------------------------------------------------
inline constexpr bool D3D12IsLayoutOpaque(D3D12_TEXTURE_LAYOUT Layout) noexcept
{
    return Layout == D3D12_TEXTURE_LAYOUT_UNKNOWN || Layout == D3D12_TEXTURE_LAYOUT_64KB_UNDEFINED_SWIZZLE;
}

//------------------------------------------------------------------------------------------------
template <typename t_CommandListType>
inline ID3D12CommandList* const* CommandListCast(t_CommandListType* const* pp) noexcept
{
    // This cast is useful for passing strongly typed command list pointers into
    // ExecuteCommandLists.
    // This cast is valid as long as the const-ness is respected. D3D12 APIs do
    // respect the const-ness of their arguments.
    return reinterpret_cast<ID3D12CommandList* const*>(pp);
}

//------------------------------------------------------------------------------------------------
// D3D12 exports a new method for serializing root signatures in the Windows 10 Anniversary Update.
// To help enable root signature 1.1 features when they are available and not require maintaining
// two code paths for building root signatures, this helper method reconstructs a 1.0 signature when
// 1.1 is not supported.
inline HRESULT D3DX12SerializeVersionedRootSignature(
    _In_ const D3D12_VERSIONED_ROOT_SIGNATURE_DESC* pRootSignatureDesc,
    D3D_ROOT_SIGNATURE_VERSION MaxVersion,
    _Outptr_ ID3DBlob** ppBlob,
    _Always_(_Outptr_opt_result_maybenull_) ID3DBlob** ppErrorBlob) noexcept
{
    if (ppErrorBlob != nullptr)
    {
        *ppErrorBlob = nullptr;
    }

    switch (MaxVersion)
    {
        case D3D_ROOT_SIGNATURE_VERSION_1_0:
            switch (pRootSignatureDesc->Version)
            {
                case D3D_ROOT_SIGNATURE_VERSION_1_0:
                    return D3D12SerializeRootSignature(&pRootSignatureDesc->Desc_1_0, D3D_ROOT_SIGNATURE_VERSION_1, ppBlob, ppErrorBlob);

                case D3D_ROOT_SIGNATURE_VERSION_1_1:
                {
                    HRESULT hr = S_OK;
                    const D3D12_ROOT_SIGNATURE_DESC1& desc_1_1 = pRootSignatureDesc->Desc_1_1;

                    const SIZE_T ParametersSize = sizeof(D3D12_ROOT_PARAMETER) * desc_1_1.NumParameters;
                    void* pParameters = (ParametersSize > 0) ? HeapAlloc(GetProcessHeap(), 0, ParametersSize) : nullptr;
                    if (ParametersSize > 0 && pParameters == nullptr)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    auto pParameters_1_0 = static_cast<D3D12_ROOT_PARAMETER*>(pParameters);

                    if (SUCCEEDED(hr))
                    {
                        for (UINT n = 0; n < desc_1_1.NumParameters; n++)
                        {
                            __analysis_assume(ParametersSize == sizeof(D3D12_ROOT_PARAMETER) * desc_1_1.NumParameters);
                            pParameters_1_0[n].ParameterType = desc_1_1.pParameters[n].ParameterType;
                            pParameters_1_0[n].ShaderVisibility = desc_1_1.pParameters[n].ShaderVisibility;

                            switch (desc_1_1.pParameters[n].ParameterType)
                            {
                                case D3D12_ROOT_PARAMETER_TYPE_32BIT_CONSTANTS:
                                    pParameters_1_0[n].Constants.Num32BitValues = desc_1_1.pParameters[n].Constants.Num32BitValues;
                                    pParameters_1_0[n].Constants.RegisterSpace = desc_1_1.pParameters[n].Constants.RegisterSpace;
                                    pParameters_1_0[n].Constants.ShaderRegister = desc_1_1.pParameters[n].Constants.ShaderRegister;
                                    break;

                                case D3D12_ROOT_PARAMETER_TYPE_CBV:
                                case D3D12_ROOT_PARAMETER_TYPE_SRV:
                                case D3D12_ROOT_PARAMETER_TYPE_UAV:
                                    pParameters_1_0[n].Descriptor.RegisterSpace = desc_1_1.pParameters[n].Descriptor.RegisterSpace;
                                    pParameters_1_0[n].Descriptor.ShaderRegister = desc_1_1.pParameters[n].Descriptor.ShaderRegister;
                                    break;

                                case D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE:
                                    const D3D12_ROOT_DESCRIPTOR_TABLE1& table_1_1 = desc_1_1.pParameters[n].DescriptorTable;

                                    const SIZE_T DescriptorRangesSize = sizeof(D3D12_DESCRIPTOR_RANGE) * table_1_1.NumDescriptorRanges;
                                    void* pDescriptorRanges = (DescriptorRangesSize > 0 && SUCCEEDED(hr)) ? HeapAlloc(GetProcessHeap(), 0, DescriptorRangesSize) : nullptr;
                                    if (DescriptorRangesSize > 0 && pDescriptorRanges == nullptr)
                                    {
                                        hr = E_OUTOFMEMORY;
                                    }
                                    auto pDescriptorRanges_1_0 = static_cast<D3D12_DESCRIPTOR_RANGE*>(pDescriptorRanges);

                                    if (SUCCEEDED(hr))
                                    {
                                        for (UINT x = 0; x < table_1_1.NumDescriptorRanges; x++)
                                        {
                                            __analysis_assume(DescriptorRangesSize == sizeof(D3D12_DESCRIPTOR_RANGE) * table_1_1.NumDescriptorRanges);
                                            pDescriptorRanges_1_0[x].BaseShaderRegister = table_1_1.pDescriptorRanges[x].BaseShaderRegister;
                                            pDescriptorRanges_1_0[x].NumDescriptors = table_1_1.pDescriptorRanges[x].NumDescriptors;
                                            pDescriptorRanges_1_0[x].OffsetInDescriptorsFromTableStart = table_1_1.pDescriptorRanges[x].OffsetInDescriptorsFromTableStart;
                                            pDescriptorRanges_1_0[x].RangeType = table_1_1.pDescriptorRanges[x].RangeType;
                                            pDescriptorRanges_1_0[x].RegisterSpace = table_1_1.pDescriptorRanges[x].RegisterSpace;
                                        }
                                    }

                                    D3D12_ROOT_DESCRIPTOR_TABLE& table_1_0 = pParameters_1_0[n].DescriptorTable;
                                    table_1_0.NumDescriptorRanges = table_1_1.NumDescriptorRanges;
                                    table_1_0.pDescriptorRanges = pDescriptorRanges_1_0;
                            }
                        }
                    }

                    if (SUCCEEDED(hr))
                    {
                        CD3DX12_ROOT_SIGNATURE_DESC desc_1_0(desc_1_1.NumParameters, pParameters_1_0, desc_1_1.NumStaticSamplers, desc_1_1.pStaticSamplers, desc_1_1.Flags);
                        hr = D3D12SerializeRootSignature(&desc_1_0, D3D_ROOT_SIGNATURE_VERSION_1, ppBlob, ppErrorBlob);
                    }

                    if (pParameters)
                    {
                        for (UINT n = 0; n < desc_1_1.NumParameters; n++)
                        {
                            if (desc_1_1.pParameters[n].ParameterType == D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE)
                            {
                                HeapFree(GetProcessHeap(), 0, reinterpret_cast<void*>(const_cast<D3D12_DESCRIPTOR_RANGE*>(pParameters_1_0[n].DescriptorTable.pDescriptorRanges)));
                            }
                        }
                        HeapFree(GetProcessHeap(), 0, pParameters);
                    }
                    return hr;
                }
            }
            break;

        case D3D_ROOT_SIGNATURE_VERSION_1_1:
            return D3D12SerializeVersionedRootSignature(pRootSignatureDesc, ppBlob, ppErrorBlob);
    }

    return E_INVALIDARG;
}

//------------------------------------------------------------------------------------------------
#if defined(NTDDI_WIN10_RS2) && (NTDDI_VERSION >= NTDDI_WIN10_RS2)
struct CD3DX12_RT_FORMAT_ARRAY : public D3D12_RT_FORMAT_ARRAY
{
    CD3DX12_RT_FORMAT_ARRAY() = default;
    explicit CD3DX12_RT_FORMAT_ARRAY(const D3D12_RT_FORMAT_ARRAY& o) noexcept
        : D3D12_RT_FORMAT_ARRAY(o)
    {}
    explicit CD3DX12_RT_FORMAT_ARRAY(_In_reads_(NumFormats) const DXGI_FORMAT* pFormats, UINT NumFormats) noexcept
    {
        NumRenderTargets = NumFormats;
        memcpy(RTFormats, pFormats, sizeof(RTFormats));
        // assumes ARRAY_SIZE(pFormats) == ARRAY_SIZE(RTFormats)
    }
};

//------------------------------------------------------------------------------------------------
// Pipeline State Stream Helpers
//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------
// Stream Subobjects, i.e. elements of a stream

struct DefaultSampleMask { operator UINT() noexcept { return UINT_MAX; } };
struct DefaultSampleDesc { operator DXGI_SAMPLE_DESC() noexcept { return DXGI_SAMPLE_DESC{ 1, 0 }; } };

#pragma warning(push)
#pragma warning(disable : 4324)
template <typename InnerStructType, D3D12_PIPELINE_STATE_SUBOBJECT_TYPE Type, typename DefaultArg = InnerStructType>
class alignas(void*) CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT
{
private:
    D3D12_PIPELINE_STATE_SUBOBJECT_TYPE _Type;
    InnerStructType _Inner;
public:
    CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT() noexcept : _Type(Type), _Inner(DefaultArg()) {}
    CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT(InnerStructType const& i) noexcept : _Type(Type), _Inner(i) {}
    CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT& operator=(InnerStructType const& i) noexcept { _Type = Type; _Inner = i; return *this; }
    operator InnerStructType const& () const noexcept { return _Inner; }
    operator InnerStructType& () noexcept { return _Inner; }
    InnerStructType* operator&() noexcept { return &_Inner; }
    InnerStructType const* operator&() const noexcept { return &_Inner; }
};
#pragma warning(pop)
typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< D3D12_PIPELINE_STATE_FLAGS, D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_FLAGS>                             CD3DX12_PIPELINE_STATE_STREAM_FLAGS;
typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< UINT, D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_NODE_MASK>                         CD3DX12_PIPELINE_STATE_STREAM_NODE_MASK;
typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< ID3D12RootSignature*, D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_ROOT_SIGNATURE>                    CD3DX12_PIPELINE_STATE_STREAM_ROOT_SIGNATURE;
typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< D3D12_INPUT_LAYOUT_DESC, D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_INPUT_LAYOUT>                      CD3DX12_PIPELINE_STATE_STREAM_INPUT_LAYOUT;
typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< D3D12_INDEX_BUFFER_STRIP_CUT_VALUE, D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_IB_STRIP_CUT_VALUE>                CD3DX12_PIPELINE_STATE_STREAM_IB_STRIP_CUT_VALUE;
typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< D3D12_PRIMITIVE_TOPOLOGY_TYPE, D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_PRIMITIVE_TOPOLOGY>                CD3DX12_PIPELINE_STATE_STREAM_PRIMITIVE_TOPOLOGY;
typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< D3D12_SHADER_BYTECODE, D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_VS>                                CD3DX12_PIPELINE_STATE_STREAM_VS;
typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< D3D12_SHADER_BYTECODE, D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_GS>                                CD3DX12_PIPELINE_STATE_STREAM_GS;
typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< D3D12_STREAM_OUTPUT_DESC, D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_STREAM_OUTPUT>                     CD3DX12_PIPELINE_STATE_STREAM_STREAM_OUTPUT;
typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< D3D12_SHADER_BYTECODE, D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_HS>                                CD3DX12_PIPELINE_STATE_STREAM_HS;
typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< D3D12_SHADER_BYTECODE, D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DS>                                CD3DX12_PIPELINE_STATE_STREAM_DS;
typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< D3D12_SHADER_BYTECODE, D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_PS>                                CD3DX12_PIPELINE_STATE_STREAM_PS;
#if defined(NTDDI_WIN10_VB) && (NTDDI_VERSION >= NTDDI_WIN10_VB)
typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< D3D12_SHADER_BYTECODE, D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_AS>                                CD3DX12_PIPELINE_STATE_STREAM_AS;
typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< D3D12_SHADER_BYTECODE, D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_MS>                                CD3DX12_PIPELINE_STATE_STREAM_MS;
#endif
typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< D3D12_SHADER_BYTECODE, D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_CS>                                CD3DX12_PIPELINE_STATE_STREAM_CS;
typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< CD3DX12_BLEND_DESC, D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_BLEND, CD3DX12_DEFAULT>   CD3DX12_PIPELINE_STATE_STREAM_BLEND_DESC;
typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< CD3DX12_DEPTH_STENCIL_DESC, D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL, CD3DX12_DEFAULT>   CD3DX12_PIPELINE_STATE_STREAM_DEPTH_STENCIL;
typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< CD3DX12_DEPTH_STENCIL_DESC1, D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL1, CD3DX12_DEFAULT>   CD3DX12_PIPELINE_STATE_STREAM_DEPTH_STENCIL1;
typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< DXGI_FORMAT, D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL_FORMAT>              CD3DX12_PIPELINE_STATE_STREAM_DEPTH_STENCIL_FORMAT;
typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< CD3DX12_RASTERIZER_DESC, D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_RASTERIZER, CD3DX12_DEFAULT>   CD3DX12_PIPELINE_STATE_STREAM_RASTERIZER;
typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< D3D12_RT_FORMAT_ARRAY, D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_RENDER_TARGET_FORMATS>             CD3DX12_PIPELINE_STATE_STREAM_RENDER_TARGET_FORMATS;
typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< DXGI_SAMPLE_DESC, D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_SAMPLE_DESC, DefaultSampleDesc> CD3DX12_PIPELINE_STATE_STREAM_SAMPLE_DESC;
typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< UINT, D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_SAMPLE_MASK, DefaultSampleMask> CD3DX12_PIPELINE_STATE_STREAM_SAMPLE_MASK;
typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< D3D12_CACHED_PIPELINE_STATE, D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_CACHED_PSO>                        CD3DX12_PIPELINE_STATE_STREAM_CACHED_PSO;
#if defined(NTDDI_WIN10_RS3) && (NTDDI_VERSION >= NTDDI_WIN10_RS3)
typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< CD3DX12_VIEW_INSTANCING_DESC, D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_VIEW_INSTANCING, CD3DX12_DEFAULT>  CD3DX12_PIPELINE_STATE_STREAM_VIEW_INSTANCING;
#endif

//------------------------------------------------------------------------------------------------
// Stream Parser Helpers

struct ID3DX12PipelineParserCallbacks
{
    // Subobject Callbacks
    virtual void FlagsCb(D3D12_PIPELINE_STATE_FLAGS) {}
    virtual void NodeMaskCb(UINT) {}
    virtual void RootSignatureCb(ID3D12RootSignature*) {}
    virtual void InputLayoutCb(const D3D12_INPUT_LAYOUT_DESC&) {}
    virtual void IBStripCutValueCb(D3D12_INDEX_BUFFER_STRIP_CUT_VALUE) {}
    virtual void PrimitiveTopologyTypeCb(D3D12_PRIMITIVE_TOPOLOGY_TYPE) {}
    virtual void VSCb(const D3D12_SHADER_BYTECODE&) {}
    virtual void GSCb(const D3D12_SHADER_BYTECODE&) {}
    virtual void StreamOutputCb(const D3D12_STREAM_OUTPUT_DESC&) {}
    virtual void HSCb(const D3D12_SHADER_BYTECODE&) {}
    virtual void DSCb(const D3D12_SHADER_BYTECODE&) {}
    virtual void PSCb(const D3D12_SHADER_BYTECODE&) {}
    virtual void CSCb(const D3D12_SHADER_BYTECODE&) {}
#if defined(NTDDI_WIN10_VB) && (NTDDI_VERSION >= NTDDI_WIN10_VB)
    virtual void ASCb(const D3D12_SHADER_BYTECODE&) {}
    virtual void MSCb(const D3D12_SHADER_BYTECODE&) {}
#endif
    virtual void BlendStateCb(const D3D12_BLEND_DESC&) {}
    virtual void DepthStencilStateCb(const D3D12_DEPTH_STENCIL_DESC&) {}
    virtual void DepthStencilState1Cb(const D3D12_DEPTH_STENCIL_DESC1&) {}
    virtual void DSVFormatCb(DXGI_FORMAT) {}
    virtual void RasterizerStateCb(const D3D12_RASTERIZER_DESC&) {}
    virtual void RTVFormatsCb(const D3D12_RT_FORMAT_ARRAY&) {}
    virtual void SampleDescCb(const DXGI_SAMPLE_DESC&) {}
    virtual void SampleMaskCb(UINT) {}
#if defined(NTDDI_WIN10_RS3) && (NTDDI_VERSION >= NTDDI_WIN10_RS3)
    virtual void ViewInstancingCb(const D3D12_VIEW_INSTANCING_DESC&) {}
#endif
    virtual void CachedPSOCb(const D3D12_CACHED_PIPELINE_STATE&) {}

    // Error Callbacks
    virtual void ErrorBadInputParameter(UINT /*ParameterIndex*/) {}
    virtual void ErrorDuplicateSubobject(D3D12_PIPELINE_STATE_SUBOBJECT_TYPE /*DuplicateType*/) {}
    virtual void ErrorUnknownSubobject(UINT /*UnknownTypeValue*/) {}

    virtual ~ID3DX12PipelineParserCallbacks() = default;
};

#if defined(NTDDI_WIN10_VB) && (NTDDI_VERSION >= NTDDI_WIN10_VB)
struct D3DX12_MESH_SHADER_PIPELINE_STATE_DESC
{
    ID3D12RootSignature* pRootSignature;
    D3D12_SHADER_BYTECODE         AS;
    D3D12_SHADER_BYTECODE         MS;
    D3D12_SHADER_BYTECODE         PS;
    D3D12_BLEND_DESC              BlendState;
    UINT                          SampleMask;
    D3D12_RASTERIZER_DESC         RasterizerState;
    D3D12_DEPTH_STENCIL_DESC      DepthStencilState;
    D3D12_PRIMITIVE_TOPOLOGY_TYPE PrimitiveTopologyType;
    UINT                          NumRenderTargets;
    DXGI_FORMAT                   RTVFormats[D3D12_SIMULTANEOUS_RENDER_TARGET_COUNT];
    DXGI_FORMAT                   DSVFormat;
    DXGI_SAMPLE_DESC              SampleDesc;
    UINT                          NodeMask;
    D3D12_CACHED_PIPELINE_STATE   CachedPSO;
    D3D12_PIPELINE_STATE_FLAGS    Flags;
};

// CD3DX12_PIPELINE_STATE_STREAM2 Works on OS Build 19041+ (where there is a new mesh shader pipeline).
// Use CD3DX12_PIPELINE_STATE_STREAM1 for OS Build 16299+ (where there is a new view instancing subobject).
// Use CD3DX12_PIPELINE_STATE_STREAM for OS Build 15063+ support.
struct CD3DX12_PIPELINE_STATE_STREAM2
{
    CD3DX12_PIPELINE_STATE_STREAM2() = default;
    // Mesh and amplification shaders must be set manually, since they do not have representation in D3D12_GRAPHICS_PIPELINE_STATE_DESC
    CD3DX12_PIPELINE_STATE_STREAM2(const D3D12_GRAPHICS_PIPELINE_STATE_DESC& Desc) noexcept
        : Flags(Desc.Flags)
        , NodeMask(Desc.NodeMask)
        , pRootSignature(Desc.pRootSignature)
        , InputLayout(Desc.InputLayout)
        , IBStripCutValue(Desc.IBStripCutValue)
        , PrimitiveTopologyType(Desc.PrimitiveTopologyType)
        , VS(Desc.VS)
        , GS(Desc.GS)
        , StreamOutput(Desc.StreamOutput)
        , HS(Desc.HS)
        , DS(Desc.DS)
        , PS(Desc.PS)
        , BlendState(CD3DX12_BLEND_DESC(Desc.BlendState))
        , DepthStencilState(CD3DX12_DEPTH_STENCIL_DESC1(Desc.DepthStencilState))
        , DSVFormat(Desc.DSVFormat)
        , RasterizerState(CD3DX12_RASTERIZER_DESC(Desc.RasterizerState))
        , RTVFormats(CD3DX12_RT_FORMAT_ARRAY(Desc.RTVFormats, Desc.NumRenderTargets))
        , SampleDesc(Desc.SampleDesc)
        , SampleMask(Desc.SampleMask)
        , CachedPSO(Desc.CachedPSO)
        , ViewInstancingDesc(CD3DX12_VIEW_INSTANCING_DESC(CD3DX12_DEFAULT()))
    {}
    CD3DX12_PIPELINE_STATE_STREAM2(const D3DX12_MESH_SHADER_PIPELINE_STATE_DESC& Desc) noexcept
        : Flags(Desc.Flags)
        , NodeMask(Desc.NodeMask)
        , pRootSignature(Desc.pRootSignature)
        , PrimitiveTopologyType(Desc.PrimitiveTopologyType)
        , PS(Desc.PS)
        , AS(Desc.AS)
        , MS(Desc.MS)
        , BlendState(CD3DX12_BLEND_DESC(Desc.BlendState))
        , DepthStencilState(CD3DX12_DEPTH_STENCIL_DESC1(Desc.DepthStencilState))
        , DSVFormat(Desc.DSVFormat)
        , RasterizerState(CD3DX12_RASTERIZER_DESC(Desc.RasterizerState))
        , RTVFormats(CD3DX12_RT_FORMAT_ARRAY(Desc.RTVFormats, Desc.NumRenderTargets))
        , SampleDesc(Desc.SampleDesc)
        , SampleMask(Desc.SampleMask)
        , CachedPSO(Desc.CachedPSO)
        , ViewInstancingDesc(CD3DX12_VIEW_INSTANCING_DESC(CD3DX12_DEFAULT()))
    {}
    CD3DX12_PIPELINE_STATE_STREAM2(const D3D12_COMPUTE_PIPELINE_STATE_DESC& Desc) noexcept
        : Flags(Desc.Flags)
        , NodeMask(Desc.NodeMask)
        , pRootSignature(Desc.pRootSignature)
        , CS(CD3DX12_SHADER_BYTECODE(Desc.CS))
        , CachedPSO(Desc.CachedPSO)
    {
        static_cast<D3D12_DEPTH_STENCIL_DESC1&>(DepthStencilState).DepthEnable = false;
    }
    CD3DX12_PIPELINE_STATE_STREAM_FLAGS Flags;
    CD3DX12_PIPELINE_STATE_STREAM_NODE_MASK NodeMask;
    CD3DX12_PIPELINE_STATE_STREAM_ROOT_SIGNATURE pRootSignature;
    CD3DX12_PIPELINE_STATE_STREAM_INPUT_LAYOUT InputLayout;
    CD3DX12_PIPELINE_STATE_STREAM_IB_STRIP_CUT_VALUE IBStripCutValue;
    CD3DX12_PIPELINE_STATE_STREAM_PRIMITIVE_TOPOLOGY PrimitiveTopologyType;
    CD3DX12_PIPELINE_STATE_STREAM_VS VS;
    CD3DX12_PIPELINE_STATE_STREAM_GS GS;
    CD3DX12_PIPELINE_STATE_STREAM_STREAM_OUTPUT StreamOutput;
    CD3DX12_PIPELINE_STATE_STREAM_HS HS;
    CD3DX12_PIPELINE_STATE_STREAM_DS DS;
    CD3DX12_PIPELINE_STATE_STREAM_PS PS;
    CD3DX12_PIPELINE_STATE_STREAM_AS AS;
    CD3DX12_PIPELINE_STATE_STREAM_MS MS;
    CD3DX12_PIPELINE_STATE_STREAM_CS CS;
    CD3DX12_PIPELINE_STATE_STREAM_BLEND_DESC BlendState;
    CD3DX12_PIPELINE_STATE_STREAM_DEPTH_STENCIL1 DepthStencilState;
    CD3DX12_PIPELINE_STATE_STREAM_DEPTH_STENCIL_FORMAT DSVFormat;
    CD3DX12_PIPELINE_STATE_STREAM_RASTERIZER RasterizerState;
    CD3DX12_PIPELINE_STATE_STREAM_RENDER_TARGET_FORMATS RTVFormats;
    CD3DX12_PIPELINE_STATE_STREAM_SAMPLE_DESC SampleDesc;
    CD3DX12_PIPELINE_STATE_STREAM_SAMPLE_MASK SampleMask;
    CD3DX12_PIPELINE_STATE_STREAM_CACHED_PSO CachedPSO;
    CD3DX12_PIPELINE_STATE_STREAM_VIEW_INSTANCING ViewInstancingDesc;
    D3D12_GRAPHICS_PIPELINE_STATE_DESC GraphicsDescV0() const noexcept
    {
        D3D12_GRAPHICS_PIPELINE_STATE_DESC D;
        D.Flags = this->Flags;
        D.NodeMask = this->NodeMask;
        D.pRootSignature = this->pRootSignature;
        D.InputLayout = this->InputLayout;
        D.IBStripCutValue = this->IBStripCutValue;
        D.PrimitiveTopologyType = this->PrimitiveTopologyType;
        D.VS = this->VS;
        D.GS = this->GS;
        D.StreamOutput = this->StreamOutput;
        D.HS = this->HS;
        D.DS = this->DS;
        D.PS = this->PS;
        D.BlendState = this->BlendState;
        D.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC1(D3D12_DEPTH_STENCIL_DESC1(this->DepthStencilState));
        D.DSVFormat = this->DSVFormat;
        D.RasterizerState = this->RasterizerState;
        D.NumRenderTargets = D3D12_RT_FORMAT_ARRAY(this->RTVFormats).NumRenderTargets;
        memcpy(D.RTVFormats, D3D12_RT_FORMAT_ARRAY(this->RTVFormats).RTFormats, sizeof(D.RTVFormats));
        D.SampleDesc = this->SampleDesc;
        D.SampleMask = this->SampleMask;
        D.CachedPSO = this->CachedPSO;
        return D;
    }
    D3D12_COMPUTE_PIPELINE_STATE_DESC ComputeDescV0() const noexcept
    {
        D3D12_COMPUTE_PIPELINE_STATE_DESC D;
        D.Flags = this->Flags;
        D.NodeMask = this->NodeMask;
        D.pRootSignature = this->pRootSignature;
        D.CS = this->CS;
        D.CachedPSO = this->CachedPSO;
        return D;
    }
};
#endif // NTDDI_WIN10_VB

#if defined(NTDDI_WIN10_RS3) && (NTDDI_VERSION >= NTDDI_WIN10_RS3)
// CD3DX12_PIPELINE_STATE_STREAM1 Works on OS Build 16299+ (where there is a new view instancing subobject).
// Use CD3DX12_PIPELINE_STATE_STREAM for OS Build 15063+ support.
struct CD3DX12_PIPELINE_STATE_STREAM1
{
    CD3DX12_PIPELINE_STATE_STREAM1() = default;
    // Mesh and amplification shaders must be set manually, since they do not have representation in D3D12_GRAPHICS_PIPELINE_STATE_DESC
    CD3DX12_PIPELINE_STATE_STREAM1(const D3D12_GRAPHICS_PIPELINE_STATE_DESC& Desc) noexcept
        : Flags(Desc.Flags)
        , NodeMask(Desc.NodeMask)
        , pRootSignature(Desc.pRootSignature)
        , InputLayout(Desc.InputLayout)
        , IBStripCutValue(Desc.IBStripCutValue)
        , PrimitiveTopologyType(Desc.PrimitiveTopologyType)
        , VS(Desc.VS)
        , GS(Desc.GS)
        , StreamOutput(Desc.StreamOutput)
        , HS(Desc.HS)
        , DS(Desc.DS)
        , PS(Desc.PS)
        , BlendState(CD3DX12_BLEND_DESC(Desc.BlendState))
        , DepthStencilState(CD3DX12_DEPTH_STENCIL_DESC1(Desc.DepthStencilState))
        , DSVFormat(Desc.DSVFormat)
        , RasterizerState(CD3DX12_RASTERIZER_DESC(Desc.RasterizerState))
        , RTVFormats(CD3DX12_RT_FORMAT_ARRAY(Desc.RTVFormats, Desc.NumRenderTargets))
        , SampleDesc(Desc.SampleDesc)
        , SampleMask(Desc.SampleMask)
        , CachedPSO(Desc.CachedPSO)
        , ViewInstancingDesc(CD3DX12_VIEW_INSTANCING_DESC(CD3DX12_DEFAULT()))
    {}
#if defined(NTDDI_WIN10_VB) && (NTDDI_VERSION >= NTDDI_WIN10_VB)
    CD3DX12_PIPELINE_STATE_STREAM1(const D3DX12_MESH_SHADER_PIPELINE_STATE_DESC& Desc) noexcept
        : Flags(Desc.Flags)
        , NodeMask(Desc.NodeMask)
        , pRootSignature(Desc.pRootSignature)
        , PrimitiveTopologyType(Desc.PrimitiveTopologyType)
        , PS(Desc.PS)
        , BlendState(CD3DX12_BLEND_DESC(Desc.BlendState))
        , DepthStencilState(CD3DX12_DEPTH_STENCIL_DESC1(Desc.DepthStencilState))
        , DSVFormat(Desc.DSVFormat)
        , RasterizerState(CD3DX12_RASTERIZER_DESC(Desc.RasterizerState))
        , RTVFormats(CD3DX12_RT_FORMAT_ARRAY(Desc.RTVFormats, Desc.NumRenderTargets))
        , SampleDesc(Desc.SampleDesc)
        , SampleMask(Desc.SampleMask)
        , CachedPSO(Desc.CachedPSO)
        , ViewInstancingDesc(CD3DX12_VIEW_INSTANCING_DESC(CD3DX12_DEFAULT()))
    {}
#endif
    CD3DX12_PIPELINE_STATE_STREAM1(const D3D12_COMPUTE_PIPELINE_STATE_DESC& Desc) noexcept
        : Flags(Desc.Flags)
        , NodeMask(Desc.NodeMask)
        , pRootSignature(Desc.pRootSignature)
        , CS(CD3DX12_SHADER_BYTECODE(Desc.CS))
        , CachedPSO(Desc.CachedPSO)
    {
        static_cast<D3D12_DEPTH_STENCIL_DESC1&>(DepthStencilState).DepthEnable = false;
    }
    CD3DX12_PIPELINE_STATE_STREAM_FLAGS Flags;
    CD3DX12_PIPELINE_STATE_STREAM_NODE_MASK NodeMask;
    CD3DX12_PIPELINE_STATE_STREAM_ROOT_SIGNATURE pRootSignature;
    CD3DX12_PIPELINE_STATE_STREAM_INPUT_LAYOUT InputLayout;
    CD3DX12_PIPELINE_STATE_STREAM_IB_STRIP_CUT_VALUE IBStripCutValue;
    CD3DX12_PIPELINE_STATE_STREAM_PRIMITIVE_TOPOLOGY PrimitiveTopologyType;
    CD3DX12_PIPELINE_STATE_STREAM_VS VS;
    CD3DX12_PIPELINE_STATE_STREAM_GS GS;
    CD3DX12_PIPELINE_STATE_STREAM_STREAM_OUTPUT StreamOutput;
    CD3DX12_PIPELINE_STATE_STREAM_HS HS;
    CD3DX12_PIPELINE_STATE_STREAM_DS DS;
    CD3DX12_PIPELINE_STATE_STREAM_PS PS;
    CD3DX12_PIPELINE_STATE_STREAM_CS CS;
    CD3DX12_PIPELINE_STATE_STREAM_BLEND_DESC BlendState;
    CD3DX12_PIPELINE_STATE_STREAM_DEPTH_STENCIL1 DepthStencilState;
    CD3DX12_PIPELINE_STATE_STREAM_DEPTH_STENCIL_FORMAT DSVFormat;
    CD3DX12_PIPELINE_STATE_STREAM_RASTERIZER RasterizerState;
    CD3DX12_PIPELINE_STATE_STREAM_RENDER_TARGET_FORMATS RTVFormats;
    CD3DX12_PIPELINE_STATE_STREAM_SAMPLE_DESC SampleDesc;
    CD3DX12_PIPELINE_STATE_STREAM_SAMPLE_MASK SampleMask;
    CD3DX12_PIPELINE_STATE_STREAM_CACHED_PSO CachedPSO;
    CD3DX12_PIPELINE_STATE_STREAM_VIEW_INSTANCING ViewInstancingDesc;
    D3D12_GRAPHICS_PIPELINE_STATE_DESC GraphicsDescV0() const noexcept
    {
        D3D12_GRAPHICS_PIPELINE_STATE_DESC D;
        D.Flags = this->Flags;
        D.NodeMask = this->NodeMask;
        D.pRootSignature = this->pRootSignature;
        D.InputLayout = this->InputLayout;
        D.IBStripCutValue = this->IBStripCutValue;
        D.PrimitiveTopologyType = this->PrimitiveTopologyType;
        D.VS = this->VS;
        D.GS = this->GS;
        D.StreamOutput = this->StreamOutput;
        D.HS = this->HS;
        D.DS = this->DS;
        D.PS = this->PS;
        D.BlendState = this->BlendState;
        D.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC1(D3D12_DEPTH_STENCIL_DESC1(this->DepthStencilState));
        D.DSVFormat = this->DSVFormat;
        D.RasterizerState = this->RasterizerState;
        D.NumRenderTargets = D3D12_RT_FORMAT_ARRAY(this->RTVFormats).NumRenderTargets;
        memcpy(D.RTVFormats, D3D12_RT_FORMAT_ARRAY(this->RTVFormats).RTFormats, sizeof(D.RTVFormats));
        D.SampleDesc = this->SampleDesc;
        D.SampleMask = this->SampleMask;
        D.CachedPSO = this->CachedPSO;
        return D;
    }
    D3D12_COMPUTE_PIPELINE_STATE_DESC ComputeDescV0() const noexcept
    {
        D3D12_COMPUTE_PIPELINE_STATE_DESC D;
        D.Flags = this->Flags;
        D.NodeMask = this->NodeMask;
        D.pRootSignature = this->pRootSignature;
        D.CS = this->CS;
        D.CachedPSO = this->CachedPSO;
        return D;
    }
};
#endif // NTDDI_WIN10_RS3

#if defined(NTDDI_WIN10_VB) && (NTDDI_VERSION >= NTDDI_WIN10_VB)
struct CD3DX12_PIPELINE_MESH_STATE_STREAM
{
    CD3DX12_PIPELINE_MESH_STATE_STREAM() = default;
    CD3DX12_PIPELINE_MESH_STATE_STREAM(const D3DX12_MESH_SHADER_PIPELINE_STATE_DESC& Desc) noexcept
        : Flags(Desc.Flags)
        , NodeMask(Desc.NodeMask)
        , pRootSignature(Desc.pRootSignature)
        , PS(Desc.PS)
        , AS(Desc.AS)
        , MS(Desc.MS)
        , BlendState(CD3DX12_BLEND_DESC(Desc.BlendState))
        , DepthStencilState(CD3DX12_DEPTH_STENCIL_DESC1(Desc.DepthStencilState))
        , DSVFormat(Desc.DSVFormat)
        , RasterizerState(CD3DX12_RASTERIZER_DESC(Desc.RasterizerState))
        , RTVFormats(CD3DX12_RT_FORMAT_ARRAY(Desc.RTVFormats, Desc.NumRenderTargets))
        , SampleDesc(Desc.SampleDesc)
        , SampleMask(Desc.SampleMask)
        , CachedPSO(Desc.CachedPSO)
        , ViewInstancingDesc(CD3DX12_VIEW_INSTANCING_DESC(CD3DX12_DEFAULT()))
    {}
    CD3DX12_PIPELINE_STATE_STREAM_FLAGS Flags;
    CD3DX12_PIPELINE_STATE_STREAM_NODE_MASK NodeMask;
    CD3DX12_PIPELINE_STATE_STREAM_ROOT_SIGNATURE pRootSignature;
    CD3DX12_PIPELINE_STATE_STREAM_PS PS;
    CD3DX12_PIPELINE_STATE_STREAM_AS AS;
    CD3DX12_PIPELINE_STATE_STREAM_MS MS;
    CD3DX12_PIPELINE_STATE_STREAM_BLEND_DESC BlendState;
    CD3DX12_PIPELINE_STATE_STREAM_DEPTH_STENCIL1 DepthStencilState;
    CD3DX12_PIPELINE_STATE_STREAM_DEPTH_STENCIL_FORMAT DSVFormat;
    CD3DX12_PIPELINE_STATE_STREAM_RASTERIZER RasterizerState;
    CD3DX12_PIPELINE_STATE_STREAM_RENDER_TARGET_FORMATS RTVFormats;
    CD3DX12_PIPELINE_STATE_STREAM_SAMPLE_DESC SampleDesc;
    CD3DX12_PIPELINE_STATE_STREAM_SAMPLE_MASK SampleMask;
    CD3DX12_PIPELINE_STATE_STREAM_CACHED_PSO CachedPSO;
    CD3DX12_PIPELINE_STATE_STREAM_VIEW_INSTANCING ViewInstancingDesc;
    D3DX12_MESH_SHADER_PIPELINE_STATE_DESC MeshShaderDescV0() const noexcept
    {
        D3DX12_MESH_SHADER_PIPELINE_STATE_DESC D;
        D.Flags = this->Flags;
        D.NodeMask = this->NodeMask;
        D.pRootSignature = this->pRootSignature;
        D.PS = this->PS;
        D.AS = this->AS;
        D.MS = this->MS;
        D.BlendState = this->BlendState;
        D.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC1(D3D12_DEPTH_STENCIL_DESC1(this->DepthStencilState));
        D.DSVFormat = this->DSVFormat;
        D.RasterizerState = this->RasterizerState;
        D.NumRenderTargets = D3D12_RT_FORMAT_ARRAY(this->RTVFormats).NumRenderTargets;
        memcpy(D.RTVFormats, D3D12_RT_FORMAT_ARRAY(this->RTVFormats).RTFormats, sizeof(D.RTVFormats));
        D.SampleDesc = this->SampleDesc;
        D.SampleMask = this->SampleMask;
        D.CachedPSO = this->CachedPSO;
        return D;
    }
};
#endif // NTDDI_WIN10_VB

// CD3DX12_PIPELINE_STATE_STREAM works on OS Build 15063+ but does not support new subobject(s) added in OS Build 16299+.
// See CD3DX12_PIPELINE_STATE_STREAM1 for instance.
struct CD3DX12_PIPELINE_STATE_STREAM
{
    CD3DX12_PIPELINE_STATE_STREAM() = default;
    CD3DX12_PIPELINE_STATE_STREAM(const D3D12_GRAPHICS_PIPELINE_STATE_DESC& Desc) noexcept
        : Flags(Desc.Flags)
        , NodeMask(Desc.NodeMask)
        , pRootSignature(Desc.pRootSignature)
        , InputLayout(Desc.InputLayout)
        , IBStripCutValue(Desc.IBStripCutValue)
        , PrimitiveTopologyType(Desc.PrimitiveTopologyType)
        , VS(Desc.VS)
        , GS(Desc.GS)
        , StreamOutput(Desc.StreamOutput)
        , HS(Desc.HS)
        , DS(Desc.DS)
        , PS(Desc.PS)
        , BlendState(CD3DX12_BLEND_DESC(Desc.BlendState))
        , DepthStencilState(CD3DX12_DEPTH_STENCIL_DESC1(Desc.DepthStencilState))
        , DSVFormat(Desc.DSVFormat)
        , RasterizerState(CD3DX12_RASTERIZER_DESC(Desc.RasterizerState))
        , RTVFormats(CD3DX12_RT_FORMAT_ARRAY(Desc.RTVFormats, Desc.NumRenderTargets))
        , SampleDesc(Desc.SampleDesc)
        , SampleMask(Desc.SampleMask)
        , CachedPSO(Desc.CachedPSO)
    {}
    CD3DX12_PIPELINE_STATE_STREAM(const D3D12_COMPUTE_PIPELINE_STATE_DESC& Desc) noexcept
        : Flags(Desc.Flags)
        , NodeMask(Desc.NodeMask)
        , pRootSignature(Desc.pRootSignature)
        , CS(CD3DX12_SHADER_BYTECODE(Desc.CS))
        , CachedPSO(Desc.CachedPSO)
    {}
    CD3DX12_PIPELINE_STATE_STREAM_FLAGS Flags;
    CD3DX12_PIPELINE_STATE_STREAM_NODE_MASK NodeMask;
    CD3DX12_PIPELINE_STATE_STREAM_ROOT_SIGNATURE pRootSignature;
    CD3DX12_PIPELINE_STATE_STREAM_INPUT_LAYOUT InputLayout;
    CD3DX12_PIPELINE_STATE_STREAM_IB_STRIP_CUT_VALUE IBStripCutValue;
    CD3DX12_PIPELINE_STATE_STREAM_PRIMITIVE_TOPOLOGY PrimitiveTopologyType;
    CD3DX12_PIPELINE_STATE_STREAM_VS VS;
    CD3DX12_PIPELINE_STATE_STREAM_GS GS;
    CD3DX12_PIPELINE_STATE_STREAM_STREAM_OUTPUT StreamOutput;
    CD3DX12_PIPELINE_STATE_STREAM_HS HS;
    CD3DX12_PIPELINE_STATE_STREAM_DS DS;
    CD3DX12_PIPELINE_STATE_STREAM_PS PS;
    CD3DX12_PIPELINE_STATE_STREAM_CS CS;
    CD3DX12_PIPELINE_STATE_STREAM_BLEND_DESC BlendState;
    CD3DX12_PIPELINE_STATE_STREAM_DEPTH_STENCIL1 DepthStencilState;
    CD3DX12_PIPELINE_STATE_STREAM_DEPTH_STENCIL_FORMAT DSVFormat;
    CD3DX12_PIPELINE_STATE_STREAM_RASTERIZER RasterizerState;
    CD3DX12_PIPELINE_STATE_STREAM_RENDER_TARGET_FORMATS RTVFormats;
    CD3DX12_PIPELINE_STATE_STREAM_SAMPLE_DESC SampleDesc;
    CD3DX12_PIPELINE_STATE_STREAM_SAMPLE_MASK SampleMask;
    CD3DX12_PIPELINE_STATE_STREAM_CACHED_PSO CachedPSO;
    D3D12_GRAPHICS_PIPELINE_STATE_DESC GraphicsDescV0() const noexcept
    {
        D3D12_GRAPHICS_PIPELINE_STATE_DESC D;
        D.Flags = this->Flags;
        D.NodeMask = this->NodeMask;
        D.pRootSignature = this->pRootSignature;
        D.InputLayout = this->InputLayout;
        D.IBStripCutValue = this->IBStripCutValue;
        D.PrimitiveTopologyType = this->PrimitiveTopologyType;
        D.VS = this->VS;
        D.GS = this->GS;
        D.StreamOutput = this->StreamOutput;
        D.HS = this->HS;
        D.DS = this->DS;
        D.PS = this->PS;
        D.BlendState = this->BlendState;
        D.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC1(D3D12_DEPTH_STENCIL_DESC1(this->DepthStencilState));
        D.DSVFormat = this->DSVFormat;
        D.RasterizerState = this->RasterizerState;
        D.NumRenderTargets = D3D12_RT_FORMAT_ARRAY(this->RTVFormats).NumRenderTargets;
        memcpy(D.RTVFormats, D3D12_RT_FORMAT_ARRAY(this->RTVFormats).RTFormats, sizeof(D.RTVFormats));
        D.SampleDesc = this->SampleDesc;
        D.SampleMask = this->SampleMask;
        D.CachedPSO = this->CachedPSO;
        return D;
    }
    D3D12_COMPUTE_PIPELINE_STATE_DESC ComputeDescV0() const noexcept
    {
        D3D12_COMPUTE_PIPELINE_STATE_DESC D;
        D.Flags = this->Flags;
        D.NodeMask = this->NodeMask;
        D.pRootSignature = this->pRootSignature;
        D.CS = this->CS;
        D.CachedPSO = this->CachedPSO;
        return D;
    }
};

#if defined(NTDDI_WIN10_VB) && (NTDDI_VERSION >= NTDDI_WIN10_VB)
struct CD3DX12_PIPELINE_STATE_STREAM2_PARSE_HELPER : public ID3DX12PipelineParserCallbacks
{
    CD3DX12_PIPELINE_STATE_STREAM2 PipelineStream;
    CD3DX12_PIPELINE_STATE_STREAM2_PARSE_HELPER() noexcept
        : SeenDSS(false)
    {
        // Adjust defaults to account for absent members.
        PipelineStream.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;

        // Depth disabled if no DSV format specified.
        static_cast<D3D12_DEPTH_STENCIL_DESC1&>(PipelineStream.DepthStencilState).DepthEnable = false;
    }

    // ID3DX12PipelineParserCallbacks
    void FlagsCb(D3D12_PIPELINE_STATE_FLAGS Flags) override { PipelineStream.Flags = Flags; }
    void NodeMaskCb(UINT NodeMask) override { PipelineStream.NodeMask = NodeMask; }
    void RootSignatureCb(ID3D12RootSignature* pRootSignature) override { PipelineStream.pRootSignature = pRootSignature; }
    void InputLayoutCb(const D3D12_INPUT_LAYOUT_DESC& InputLayout) override { PipelineStream.InputLayout = InputLayout; }
    void IBStripCutValueCb(D3D12_INDEX_BUFFER_STRIP_CUT_VALUE IBStripCutValue) override { PipelineStream.IBStripCutValue = IBStripCutValue; }
    void PrimitiveTopologyTypeCb(D3D12_PRIMITIVE_TOPOLOGY_TYPE PrimitiveTopologyType) override { PipelineStream.PrimitiveTopologyType = PrimitiveTopologyType; }
    void VSCb(const D3D12_SHADER_BYTECODE& VS) override { PipelineStream.VS = VS; }
    void GSCb(const D3D12_SHADER_BYTECODE& GS) override { PipelineStream.GS = GS; }
    void StreamOutputCb(const D3D12_STREAM_OUTPUT_DESC& StreamOutput) override { PipelineStream.StreamOutput = StreamOutput; }
    void HSCb(const D3D12_SHADER_BYTECODE& HS) override { PipelineStream.HS = HS; }
    void DSCb(const D3D12_SHADER_BYTECODE& DS) override { PipelineStream.DS = DS; }
    void PSCb(const D3D12_SHADER_BYTECODE& PS) override { PipelineStream.PS = PS; }
    void CSCb(const D3D12_SHADER_BYTECODE& CS) override { PipelineStream.CS = CS; }
    void ASCb(const D3D12_SHADER_BYTECODE& AS) override { PipelineStream.AS = AS; }
    void MSCb(const D3D12_SHADER_BYTECODE& MS) override { PipelineStream.MS = MS; }
    void BlendStateCb(const D3D12_BLEND_DESC& BlendState) override { PipelineStream.BlendState = CD3DX12_BLEND_DESC(BlendState); }
    void DepthStencilStateCb(const D3D12_DEPTH_STENCIL_DESC& DepthStencilState) override
    {
        PipelineStream.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC1(DepthStencilState);
        SeenDSS = true;
    }
    void DepthStencilState1Cb(const D3D12_DEPTH_STENCIL_DESC1& DepthStencilState) override
    {
        PipelineStream.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC1(DepthStencilState);
        SeenDSS = true;
    }
    void DSVFormatCb(DXGI_FORMAT DSVFormat) override
    {
        PipelineStream.DSVFormat = DSVFormat;
        if (!SeenDSS && DSVFormat != DXGI_FORMAT_UNKNOWN)
        {
            // Re-enable depth for the default state.
            static_cast<D3D12_DEPTH_STENCIL_DESC1&>(PipelineStream.DepthStencilState).DepthEnable = true;
        }
    }
    void RasterizerStateCb(const D3D12_RASTERIZER_DESC& RasterizerState) override { PipelineStream.RasterizerState = CD3DX12_RASTERIZER_DESC(RasterizerState); }
    void RTVFormatsCb(const D3D12_RT_FORMAT_ARRAY& RTVFormats) override { PipelineStream.RTVFormats = RTVFormats; }
    void SampleDescCb(const DXGI_SAMPLE_DESC& SampleDesc) override { PipelineStream.SampleDesc = SampleDesc; }
    void SampleMaskCb(UINT SampleMask) override { PipelineStream.SampleMask = SampleMask; }
    void ViewInstancingCb(const D3D12_VIEW_INSTANCING_DESC& ViewInstancingDesc) override { PipelineStream.ViewInstancingDesc = CD3DX12_VIEW_INSTANCING_DESC(ViewInstancingDesc); }
    void CachedPSOCb(const D3D12_CACHED_PIPELINE_STATE& CachedPSO) override { PipelineStream.CachedPSO = CachedPSO; }

private:
    bool SeenDSS;
};
#endif // NTDDI_WIN10_VB

struct CD3DX12_PIPELINE_STATE_STREAM_PARSE_HELPER : public ID3DX12PipelineParserCallbacks
{
#if defined(NTDDI_WIN10_RS3) && (NTDDI_VERSION >= NTDDI_WIN10_RS3)
    CD3DX12_PIPELINE_STATE_STREAM1 PipelineStream;
#else
    CD3DX12_PIPELINE_STATE_STREAM PipelineStream;
#endif
    CD3DX12_PIPELINE_STATE_STREAM_PARSE_HELPER() noexcept
        : SeenDSS(false)
    {
        // Adjust defaults to account for absent members.
        PipelineStream.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;

        // Depth disabled if no DSV format specified.
        static_cast<D3D12_DEPTH_STENCIL_DESC1&>(PipelineStream.DepthStencilState).DepthEnable = false;
    }

    // ID3DX12PipelineParserCallbacks
    void FlagsCb(D3D12_PIPELINE_STATE_FLAGS Flags) override { PipelineStream.Flags = Flags; }
    void NodeMaskCb(UINT NodeMask) override { PipelineStream.NodeMask = NodeMask; }
    void RootSignatureCb(ID3D12RootSignature* pRootSignature) override { PipelineStream.pRootSignature = pRootSignature; }
    void InputLayoutCb(const D3D12_INPUT_LAYOUT_DESC& InputLayout) override { PipelineStream.InputLayout = InputLayout; }
    void IBStripCutValueCb(D3D12_INDEX_BUFFER_STRIP_CUT_VALUE IBStripCutValue) override { PipelineStream.IBStripCutValue = IBStripCutValue; }
    void PrimitiveTopologyTypeCb(D3D12_PRIMITIVE_TOPOLOGY_TYPE PrimitiveTopologyType) override { PipelineStream.PrimitiveTopologyType = PrimitiveTopologyType; }
    void VSCb(const D3D12_SHADER_BYTECODE& VS) override { PipelineStream.VS = VS; }
    void GSCb(const D3D12_SHADER_BYTECODE& GS) override { PipelineStream.GS = GS; }
    void StreamOutputCb(const D3D12_STREAM_OUTPUT_DESC& StreamOutput) override { PipelineStream.StreamOutput = StreamOutput; }
    void HSCb(const D3D12_SHADER_BYTECODE& HS) override { PipelineStream.HS = HS; }
    void DSCb(const D3D12_SHADER_BYTECODE& DS) override { PipelineStream.DS = DS; }
    void PSCb(const D3D12_SHADER_BYTECODE& PS) override { PipelineStream.PS = PS; }
    void CSCb(const D3D12_SHADER_BYTECODE& CS) override { PipelineStream.CS = CS; }
    void BlendStateCb(const D3D12_BLEND_DESC& BlendState) override { PipelineStream.BlendState = CD3DX12_BLEND_DESC(BlendState); }
    void DepthStencilStateCb(const D3D12_DEPTH_STENCIL_DESC& DepthStencilState) override
    {
        PipelineStream.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC1(DepthStencilState);
        SeenDSS = true;
    }
    void DepthStencilState1Cb(const D3D12_DEPTH_STENCIL_DESC1& DepthStencilState) override
    {
        PipelineStream.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC1(DepthStencilState);
        SeenDSS = true;
    }
    void DSVFormatCb(DXGI_FORMAT DSVFormat) override
    {
        PipelineStream.DSVFormat = DSVFormat;
        if (!SeenDSS && DSVFormat != DXGI_FORMAT_UNKNOWN)
        {
            // Re-enable depth for the default state.
            static_cast<D3D12_DEPTH_STENCIL_DESC1&>(PipelineStream.DepthStencilState).DepthEnable = true;
        }
    }
    void RasterizerStateCb(const D3D12_RASTERIZER_DESC& RasterizerState) override { PipelineStream.RasterizerState = CD3DX12_RASTERIZER_DESC(RasterizerState); }
    void RTVFormatsCb(const D3D12_RT_FORMAT_ARRAY& RTVFormats) override { PipelineStream.RTVFormats = RTVFormats; }
    void SampleDescCb(const DXGI_SAMPLE_DESC& SampleDesc) override { PipelineStream.SampleDesc = SampleDesc; }
    void SampleMaskCb(UINT SampleMask) override { PipelineStream.SampleMask = SampleMask; }
#if defined(NTDDI_WIN10_RS3) && (NTDDI_VERSION >= NTDDI_WIN10_RS3)
    void ViewInstancingCb(const D3D12_VIEW_INSTANCING_DESC& ViewInstancingDesc) override { PipelineStream.ViewInstancingDesc = CD3DX12_VIEW_INSTANCING_DESC(ViewInstancingDesc); }
#endif
    void CachedPSOCb(const D3D12_CACHED_PIPELINE_STATE& CachedPSO) override { PipelineStream.CachedPSO = CachedPSO; }

private:
    bool SeenDSS;
};

inline D3D12_PIPELINE_STATE_SUBOBJECT_TYPE D3DX12GetBaseSubobjectType(D3D12_PIPELINE_STATE_SUBOBJECT_TYPE SubobjectType) noexcept
{
    switch (SubobjectType)
    {
        case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL1:
            return D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL;
        default:
            return SubobjectType;
    }
}

inline HRESULT D3DX12ParsePipelineStream(const D3D12_PIPELINE_STATE_STREAM_DESC& Desc, ID3DX12PipelineParserCallbacks* pCallbacks)
{
    if (pCallbacks == nullptr)
    {
        return E_INVALIDARG;
    }

    if (Desc.SizeInBytes == 0 || Desc.pPipelineStateSubobjectStream == nullptr)
    {
        pCallbacks->ErrorBadInputParameter(1); // first parameter issue
        return E_INVALIDARG;
    }

    bool SubobjectSeen[D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_MAX_VALID] = {};
    for (SIZE_T CurOffset = 0, SizeOfSubobject = 0; CurOffset < Desc.SizeInBytes; CurOffset += SizeOfSubobject)
    {
        BYTE* pStream = static_cast<BYTE*>(Desc.pPipelineStateSubobjectStream) + CurOffset;
        auto SubobjectType = *reinterpret_cast<D3D12_PIPELINE_STATE_SUBOBJECT_TYPE*>(pStream);
        if (SubobjectType < 0 || SubobjectType >= D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_MAX_VALID)
        {
            pCallbacks->ErrorUnknownSubobject(SubobjectType);
            return E_INVALIDARG;
        }
        if (SubobjectSeen[D3DX12GetBaseSubobjectType(SubobjectType)])
        {
            pCallbacks->ErrorDuplicateSubobject(SubobjectType);
            return E_INVALIDARG; // disallow subobject duplicates in a stream
        }
        SubobjectSeen[SubobjectType] = true;
        switch (SubobjectType)
        {
            case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_ROOT_SIGNATURE:
                pCallbacks->RootSignatureCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::pRootSignature)*>(pStream));
                SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::pRootSignature);
                break;
            case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_VS:
                pCallbacks->VSCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::VS)*>(pStream));
                SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::VS);
                break;
            case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_PS:
                pCallbacks->PSCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::PS)*>(pStream));
                SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::PS);
                break;
            case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DS:
                pCallbacks->DSCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::DS)*>(pStream));
                SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::DS);
                break;
            case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_HS:
                pCallbacks->HSCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::HS)*>(pStream));
                SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::HS);
                break;
            case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_GS:
                pCallbacks->GSCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::GS)*>(pStream));
                SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::GS);
                break;
            case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_CS:
                pCallbacks->CSCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::CS)*>(pStream));
                SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::CS);
                break;
#if defined(NTDDI_WIN10_VB) && (NTDDI_VERSION >= NTDDI_WIN10_VB)
            case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_AS:
                pCallbacks->ASCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM2::AS)*>(pStream));
                SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM2::AS);
                break;
            case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_MS:
                pCallbacks->MSCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM2::MS)*>(pStream));
                SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM2::MS);
                break;
#endif
            case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_STREAM_OUTPUT:
                pCallbacks->StreamOutputCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::StreamOutput)*>(pStream));
                SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::StreamOutput);
                break;
            case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_BLEND:
                pCallbacks->BlendStateCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::BlendState)*>(pStream));
                SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::BlendState);
                break;
            case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_SAMPLE_MASK:
                pCallbacks->SampleMaskCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::SampleMask)*>(pStream));
                SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::SampleMask);
                break;
            case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_RASTERIZER:
                pCallbacks->RasterizerStateCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::RasterizerState)*>(pStream));
                SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::RasterizerState);
                break;
            case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL:
                pCallbacks->DepthStencilStateCb(*reinterpret_cast<CD3DX12_PIPELINE_STATE_STREAM_DEPTH_STENCIL*>(pStream));
                SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM_DEPTH_STENCIL);
                break;
            case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL1:
                pCallbacks->DepthStencilState1Cb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::DepthStencilState)*>(pStream));
                SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::DepthStencilState);
                break;
            case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_INPUT_LAYOUT:
                pCallbacks->InputLayoutCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::InputLayout)*>(pStream));
                SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::InputLayout);
                break;
            case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_IB_STRIP_CUT_VALUE:
                pCallbacks->IBStripCutValueCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::IBStripCutValue)*>(pStream));
                SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::IBStripCutValue);
                break;
            case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_PRIMITIVE_TOPOLOGY:
                pCallbacks->PrimitiveTopologyTypeCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::PrimitiveTopologyType)*>(pStream));
                SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::PrimitiveTopologyType);
                break;
            case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_RENDER_TARGET_FORMATS:
                pCallbacks->RTVFormatsCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::RTVFormats)*>(pStream));
                SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::RTVFormats);
                break;
            case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL_FORMAT:
                pCallbacks->DSVFormatCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::DSVFormat)*>(pStream));
                SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::DSVFormat);
                break;
            case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_SAMPLE_DESC:
                pCallbacks->SampleDescCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::SampleDesc)*>(pStream));
                SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::SampleDesc);
                break;
            case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_NODE_MASK:
                pCallbacks->NodeMaskCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::NodeMask)*>(pStream));
                SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::NodeMask);
                break;
            case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_CACHED_PSO:
                pCallbacks->CachedPSOCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::CachedPSO)*>(pStream));
                SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::CachedPSO);
                break;
            case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_FLAGS:
                pCallbacks->FlagsCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::Flags)*>(pStream));
                SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::Flags);
                break;
#if defined(NTDDI_WIN10_RS3) && (NTDDI_VERSION >= NTDDI_WIN10_RS3)
            case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_VIEW_INSTANCING:
                pCallbacks->ViewInstancingCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM1::ViewInstancingDesc)*>(pStream));
                SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM1::ViewInstancingDesc);
                break;
#endif
            default:
                pCallbacks->ErrorUnknownSubobject(SubobjectType);
                return E_INVALIDARG;
        }
    }

    return S_OK;
}
#endif // NTDDI_WIN10_RS2

// Requires the Windows 10 October 2018 Update SDK (17763)
#if defined(NTDDI_WIN10_RS5) && (NTDDI_VERSION >= NTDDI_WIN10_RS5)
//------------------------------------------------------------------------------------------------
inline bool operator==(const D3D12_CLEAR_VALUE& a, const D3D12_CLEAR_VALUE& b) noexcept
{
    if (a.Format != b.Format) return false;
    if (a.Format == DXGI_FORMAT_D24_UNORM_S8_UINT
        || a.Format == DXGI_FORMAT_D16_UNORM
        || a.Format == DXGI_FORMAT_D32_FLOAT
        || a.Format == DXGI_FORMAT_D32_FLOAT_S8X24_UINT)
    {
        return (a.DepthStencil.Depth == b.DepthStencil.Depth) &&
            (a.DepthStencil.Stencil == b.DepthStencil.Stencil);
    }
    else {
        return (a.Color[0] == b.Color[0]) &&
            (a.Color[1] == b.Color[1]) &&
            (a.Color[2] == b.Color[2]) &&
            (a.Color[3] == b.Color[3]);
    }
}
inline bool operator==(const D3D12_RENDER_PASS_BEGINNING_ACCESS_CLEAR_PARAMETERS& a, const D3D12_RENDER_PASS_BEGINNING_ACCESS_CLEAR_PARAMETERS& b) noexcept
{
    return a.ClearValue == b.ClearValue;
}
inline bool operator==(const D3D12_RENDER_PASS_ENDING_ACCESS_RESOLVE_PARAMETERS& a, const D3D12_RENDER_PASS_ENDING_ACCESS_RESOLVE_PARAMETERS& b) noexcept
{
    if (a.pSrcResource != b.pSrcResource) return false;
    if (a.pDstResource != b.pDstResource) return false;
    if (a.SubresourceCount != b.SubresourceCount) return false;
    if (a.Format != b.Format) return false;
    if (a.ResolveMode != b.ResolveMode) return false;
    if (a.PreserveResolveSource != b.PreserveResolveSource) return false;
    return true;
}
inline bool operator==(const D3D12_RENDER_PASS_BEGINNING_ACCESS& a, const D3D12_RENDER_PASS_BEGINNING_ACCESS& b) noexcept
{
    if (a.Type != b.Type) return false;
    if (a.Type == D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE_CLEAR && !(a.Clear == b.Clear)) return false;
    return true;
}
inline bool operator==(const D3D12_RENDER_PASS_ENDING_ACCESS& a, const D3D12_RENDER_PASS_ENDING_ACCESS& b) noexcept
{
    if (a.Type != b.Type) return false;
    if (a.Type == D3D12_RENDER_PASS_ENDING_ACCESS_TYPE_RESOLVE && !(a.Resolve == b.Resolve)) return false;
    return true;
}
inline bool operator==(const D3D12_RENDER_PASS_RENDER_TARGET_DESC& a, const D3D12_RENDER_PASS_RENDER_TARGET_DESC& b) noexcept
{
    if (a.cpuDescriptor.ptr != b.cpuDescriptor.ptr) return false;
    if (!(a.BeginningAccess == b.BeginningAccess)) return false;
    if (!(a.EndingAccess == b.EndingAccess)) return false;
    return true;
}
inline bool operator==(const D3D12_RENDER_PASS_DEPTH_STENCIL_DESC& a, const D3D12_RENDER_PASS_DEPTH_STENCIL_DESC& b) noexcept
{
    if (a.cpuDescriptor.ptr != b.cpuDescriptor.ptr) return false;
    if (!(a.DepthBeginningAccess == b.DepthBeginningAccess)) return false;
    if (!(a.StencilBeginningAccess == b.StencilBeginningAccess)) return false;
    if (!(a.DepthEndingAccess == b.DepthEndingAccess)) return false;
    if (!(a.StencilEndingAccess == b.StencilEndingAccess)) return false;
    return true;
}


#ifndef D3DX12_NO_STATE_OBJECT_HELPERS

//================================================================================================
// D3DX12 State Object Creation Helpers
//
// Helper classes for creating new style state objects out of an arbitrary set of subobjects.
// Uses STL
//
// Start by instantiating CD3DX12_STATE_OBJECT_DESC (see it's public methods).
// One of its methods is CreateSubobject(), which has a comment showing a couple of options for
// defining subobjects using the helper classes for each subobject (CD3DX12_DXIL_LIBRARY_SUBOBJECT
// etc.). The subobject helpers each have methods specific to the subobject for configuring it's
// contents.
//
//================================================================================================
#include <list>
#include <vector>
#include <string>
#include <memory>
#include <wrl/client.h>

//------------------------------------------------------------------------------------------------
class CD3DX12_STATE_OBJECT_DESC
{
public:
    CD3DX12_STATE_OBJECT_DESC() noexcept
    {
        Init(D3D12_STATE_OBJECT_TYPE_COLLECTION);
    }
    CD3DX12_STATE_OBJECT_DESC(D3D12_STATE_OBJECT_TYPE Type) noexcept
    {
        Init(Type);
    }
    void SetStateObjectType(D3D12_STATE_OBJECT_TYPE Type) noexcept { m_Desc.Type = Type; }
    operator const D3D12_STATE_OBJECT_DESC& ()
    {
        // Do final preparation work
        m_RepointedAssociations.clear();
        m_SubobjectArray.clear();
        m_SubobjectArray.reserve(m_Desc.NumSubobjects);
        // Flatten subobjects into an array (each flattened subobject still has a
        // member that's a pointer to it's desc that's not flattened)
        for (auto Iter = m_SubobjectList.begin();
            Iter != m_SubobjectList.end(); Iter++)
        {
            m_SubobjectArray.push_back(*Iter);
            // Store new location in array so we can redirect pointers contained in subobjects
            Iter->pSubobjectArrayLocation = &m_SubobjectArray.back();
        }
        // For subobjects with pointer fields, create a new copy of those subobject definitions
        // with fixed pointers
        for (UINT i = 0; i < m_Desc.NumSubobjects; i++)
        {
            if (m_SubobjectArray[i].Type == D3D12_STATE_SUBOBJECT_TYPE_SUBOBJECT_TO_EXPORTS_ASSOCIATION)
            {
                auto pOriginalSubobjectAssociation =
                    static_cast<const D3D12_SUBOBJECT_TO_EXPORTS_ASSOCIATION*>(m_SubobjectArray[i].pDesc);
                D3D12_SUBOBJECT_TO_EXPORTS_ASSOCIATION Repointed = *pOriginalSubobjectAssociation;
                auto pWrapper =
                    static_cast<const SUBOBJECT_WRAPPER*>(pOriginalSubobjectAssociation->pSubobjectToAssociate);
                Repointed.pSubobjectToAssociate = pWrapper->pSubobjectArrayLocation;
                m_RepointedAssociations.push_back(Repointed);
                m_SubobjectArray[i].pDesc = &m_RepointedAssociations.back();
            }
        }
        // Below: using ugly way to get pointer in case .data() is not defined
        m_Desc.pSubobjects = m_Desc.NumSubobjects ? &m_SubobjectArray[0] : nullptr;
        return m_Desc;
    }
    operator const D3D12_STATE_OBJECT_DESC* ()
    {
        // Cast calls the above final preparation work
        return &static_cast<const D3D12_STATE_OBJECT_DESC&>(*this);
    }

    // CreateSubobject creates a sububject helper (e.g. CD3DX12_HIT_GROUP_SUBOBJECT)
    // whose lifetime is owned by this class.
    // e.g.
    //
    //    CD3DX12_STATE_OBJECT_DESC Collection1(D3D12_STATE_OBJECT_TYPE_COLLECTION);
    //    auto Lib0 = Collection1.CreateSubobject<CD3DX12_DXIL_LIBRARY_SUBOBJECT>();
    //    Lib0->SetDXILLibrary(&pMyAppDxilLibs[0]);
    //    Lib0->DefineExport(L"rayGenShader0"); // in practice these export listings might be
    //                                          // data/engine driven
    //    etc.
    //
    // Alternatively, users can instantiate sububject helpers explicitly, such as via local
    // variables instead, passing the state object desc that should point to it into the helper
    // constructor (or call mySubobjectHelper.AddToStateObject(Collection1)).
    // In this alternative scenario, the user must keep the subobject alive as long as the state
    // object it is associated with is alive, else it's pointer references will be stale.
    // e.g.
    //
    //    CD3DX12_STATE_OBJECT_DESC RaytracingState2(D3D12_STATE_OBJECT_TYPE_RAYTRACING_PIPELINE);
    //    CD3DX12_DXIL_LIBRARY_SUBOBJECT LibA(RaytracingState2);
    //    LibA.SetDXILLibrary(&pMyAppDxilLibs[4]); // not manually specifying exports
    //                                             // - meaning all exports in the libraries
    //                                             // are exported
    //    etc.

    template<typename T>
    T* CreateSubobject()
    {
        T* pSubobject = new T(*this);
        m_OwnedSubobjectHelpers.emplace_back(pSubobject);
        return pSubobject;
    }

private:
    D3D12_STATE_SUBOBJECT* TrackSubobject(D3D12_STATE_SUBOBJECT_TYPE Type, void* pDesc)
    {
        SUBOBJECT_WRAPPER Subobject;
        Subobject.pSubobjectArrayLocation = nullptr;
        Subobject.Type = Type;
        Subobject.pDesc = pDesc;
        m_SubobjectList.push_back(Subobject);
        m_Desc.NumSubobjects++;
        return &m_SubobjectList.back();
    }
    void Init(D3D12_STATE_OBJECT_TYPE Type) noexcept
    {
        SetStateObjectType(Type);
        m_Desc.pSubobjects = nullptr;
        m_Desc.NumSubobjects = 0;
        m_SubobjectList.clear();
        m_SubobjectArray.clear();
        m_RepointedAssociations.clear();
    }
    typedef struct SUBOBJECT_WRAPPER : public D3D12_STATE_SUBOBJECT
    {
        D3D12_STATE_SUBOBJECT* pSubobjectArrayLocation; // new location when flattened into array
                                                        // for repointing pointers in subobjects
    } SUBOBJECT_WRAPPER;
    D3D12_STATE_OBJECT_DESC m_Desc;
    std::list<SUBOBJECT_WRAPPER>   m_SubobjectList; // Pointers to list nodes handed out so
                                                    // these can be edited live
    std::vector<D3D12_STATE_SUBOBJECT> m_SubobjectArray; // Built at the end, copying list contents

    std::list<D3D12_SUBOBJECT_TO_EXPORTS_ASSOCIATION>
        m_RepointedAssociations; // subobject type that contains pointers to other subobjects,
                                 // repointed to flattened array

    class StringContainer
    {
    public:
        LPCWSTR LocalCopy(LPCWSTR string, bool bSingleString = false)
        {
            if (string)
            {
                if (bSingleString)
                {
                    m_Strings.clear();
                    m_Strings.push_back(string);
                }
                else
                {
                    m_Strings.push_back(string);
                }
                return m_Strings.back().c_str();
            }
            else
            {
                return nullptr;
            }
        }
        void clear() noexcept { m_Strings.clear(); }
    private:
        std::list<std::wstring> m_Strings;
    };

    class SUBOBJECT_HELPER_BASE
    {
    public:
        SUBOBJECT_HELPER_BASE() noexcept { Init(); }
        virtual ~SUBOBJECT_HELPER_BASE() = default;
        virtual D3D12_STATE_SUBOBJECT_TYPE Type() const noexcept = 0;
        void AddToStateObject(CD3DX12_STATE_OBJECT_DESC& ContainingStateObject)
        {
            m_pSubobject = ContainingStateObject.TrackSubobject(Type(), Data());
        }
    protected:
        virtual void* Data() noexcept = 0;
        void Init() noexcept { m_pSubobject = nullptr; }
        D3D12_STATE_SUBOBJECT* m_pSubobject;
    };

#if(__cplusplus >= 201103L)
    std::list<std::unique_ptr<const SUBOBJECT_HELPER_BASE>> m_OwnedSubobjectHelpers;
#else
    class OWNED_HELPER
    {
    public:
        OWNED_HELPER(const SUBOBJECT_HELPER_BASE* pHelper) noexcept { m_pHelper = pHelper; }
        ~OWNED_HELPER() { delete m_pHelper; }
        const SUBOBJECT_HELPER_BASE* m_pHelper;
    };

    std::list<OWNED_HELPER> m_OwnedSubobjectHelpers;
#endif

    friend class CD3DX12_DXIL_LIBRARY_SUBOBJECT;
    friend class CD3DX12_EXISTING_COLLECTION_SUBOBJECT;
    friend class CD3DX12_SUBOBJECT_TO_EXPORTS_ASSOCIATION_SUBOBJECT;
    friend class CD3DX12_DXIL_SUBOBJECT_TO_EXPORTS_ASSOCIATION;
    friend class CD3DX12_HIT_GROUP_SUBOBJECT;
    friend class CD3DX12_RAYTRACING_SHADER_CONFIG_SUBOBJECT;
    friend class CD3DX12_RAYTRACING_PIPELINE_CONFIG_SUBOBJECT;
#if defined(NTDDI_WIN10_VB) && (NTDDI_VERSION >= NTDDI_WIN10_VB)
    friend class CD3DX12_RAYTRACING_PIPELINE_CONFIG1_SUBOBJECT;
#endif
    friend class CD3DX12_GLOBAL_ROOT_SIGNATURE_SUBOBJECT;
    friend class CD3DX12_LOCAL_ROOT_SIGNATURE_SUBOBJECT;
    friend class CD3DX12_STATE_OBJECT_CONFIG_SUBOBJECT;
    friend class CD3DX12_NODE_MASK_SUBOBJECT;
};

//------------------------------------------------------------------------------------------------
class CD3DX12_DXIL_LIBRARY_SUBOBJECT
    : public CD3DX12_STATE_OBJECT_DESC::SUBOBJECT_HELPER_BASE
{
public:
    CD3DX12_DXIL_LIBRARY_SUBOBJECT() noexcept
    {
        Init();
    }
    CD3DX12_DXIL_LIBRARY_SUBOBJECT(CD3DX12_STATE_OBJECT_DESC& ContainingStateObject)
    {
        Init();
        AddToStateObject(ContainingStateObject);
    }
    void SetDXILLibrary(const D3D12_SHADER_BYTECODE* pCode) noexcept
    {
        static const D3D12_SHADER_BYTECODE Default = {};
        m_Desc.DXILLibrary = pCode ? *pCode : Default;
    }
    void DefineExport(
        LPCWSTR Name,
        LPCWSTR ExportToRename = nullptr,
        D3D12_EXPORT_FLAGS Flags = D3D12_EXPORT_FLAG_NONE)
    {
        D3D12_EXPORT_DESC Export;
        Export.Name = m_Strings.LocalCopy(Name);
        Export.ExportToRename = m_Strings.LocalCopy(ExportToRename);
        Export.Flags = Flags;
        m_Exports.push_back(Export);
        m_Desc.pExports = &m_Exports[0];  // using ugly way to get pointer in case .data() is not defined
        m_Desc.NumExports = static_cast<UINT>(m_Exports.size());
    }
    template<size_t N>
    void DefineExports(LPCWSTR(&Exports)[N])
    {
        for (UINT i = 0; i < N; i++)
        {
            DefineExport(Exports[i]);
        }
    }
    void DefineExports(const LPCWSTR* Exports, UINT N)
    {
        for (UINT i = 0; i < N; i++)
        {
            DefineExport(Exports[i]);
        }
    }
    D3D12_STATE_SUBOBJECT_TYPE Type() const noexcept override
    {
        return D3D12_STATE_SUBOBJECT_TYPE_DXIL_LIBRARY;
    }
    operator const D3D12_STATE_SUBOBJECT& () const noexcept { return *m_pSubobject; }
    operator const D3D12_DXIL_LIBRARY_DESC& () const noexcept { return m_Desc; }
private:
    void Init() noexcept
    {
        SUBOBJECT_HELPER_BASE::Init();
        m_Desc = {};
        m_Strings.clear();
        m_Exports.clear();
    }
    void* Data() noexcept override { return &m_Desc; }
    D3D12_DXIL_LIBRARY_DESC m_Desc;
    CD3DX12_STATE_OBJECT_DESC::StringContainer m_Strings;
    std::vector<D3D12_EXPORT_DESC> m_Exports;
};

//------------------------------------------------------------------------------------------------
class CD3DX12_EXISTING_COLLECTION_SUBOBJECT
    : public CD3DX12_STATE_OBJECT_DESC::SUBOBJECT_HELPER_BASE
{
public:
    CD3DX12_EXISTING_COLLECTION_SUBOBJECT() noexcept
    {
        Init();
    }
    CD3DX12_EXISTING_COLLECTION_SUBOBJECT(CD3DX12_STATE_OBJECT_DESC& ContainingStateObject)
    {
        Init();
        AddToStateObject(ContainingStateObject);
    }
    void SetExistingCollection(ID3D12StateObject* pExistingCollection) noexcept
    {
        m_Desc.pExistingCollection = pExistingCollection;
        m_CollectionRef = pExistingCollection;
    }
    void DefineExport(
        LPCWSTR Name,
        LPCWSTR ExportToRename = nullptr,
        D3D12_EXPORT_FLAGS Flags = D3D12_EXPORT_FLAG_NONE)
    {
        D3D12_EXPORT_DESC Export;
        Export.Name = m_Strings.LocalCopy(Name);
        Export.ExportToRename = m_Strings.LocalCopy(ExportToRename);
        Export.Flags = Flags;
        m_Exports.push_back(Export);
        m_Desc.pExports = &m_Exports[0]; // using ugly way to get pointer in case .data() is not defined
        m_Desc.NumExports = static_cast<UINT>(m_Exports.size());
    }
    template<size_t N>
    void DefineExports(LPCWSTR(&Exports)[N])
    {
        for (UINT i = 0; i < N; i++)
        {
            DefineExport(Exports[i]);
        }
    }
    void DefineExports(const LPCWSTR* Exports, UINT N)
    {
        for (UINT i = 0; i < N; i++)
        {
            DefineExport(Exports[i]);
        }
    }
    D3D12_STATE_SUBOBJECT_TYPE Type() const noexcept override
    {
        return D3D12_STATE_SUBOBJECT_TYPE_EXISTING_COLLECTION;
    }
    operator const D3D12_STATE_SUBOBJECT& () const noexcept { return *m_pSubobject; }
    operator const D3D12_EXISTING_COLLECTION_DESC& () const noexcept { return m_Desc; }
private:
    void Init() noexcept
    {
        SUBOBJECT_HELPER_BASE::Init();
        m_Desc = {};
        m_CollectionRef = nullptr;
        m_Strings.clear();
        m_Exports.clear();
    }
    void* Data() noexcept override { return &m_Desc; }
    D3D12_EXISTING_COLLECTION_DESC m_Desc;
    Microsoft::WRL::ComPtr<ID3D12StateObject> m_CollectionRef;
    CD3DX12_STATE_OBJECT_DESC::StringContainer m_Strings;
    std::vector<D3D12_EXPORT_DESC> m_Exports;
};

//------------------------------------------------------------------------------------------------
class CD3DX12_SUBOBJECT_TO_EXPORTS_ASSOCIATION_SUBOBJECT
    : public CD3DX12_STATE_OBJECT_DESC::SUBOBJECT_HELPER_BASE
{
public:
    CD3DX12_SUBOBJECT_TO_EXPORTS_ASSOCIATION_SUBOBJECT() noexcept
    {
        Init();
    }
    CD3DX12_SUBOBJECT_TO_EXPORTS_ASSOCIATION_SUBOBJECT(CD3DX12_STATE_OBJECT_DESC& ContainingStateObject)
    {
        Init();
        AddToStateObject(ContainingStateObject);
    }
    void SetSubobjectToAssociate(const D3D12_STATE_SUBOBJECT& SubobjectToAssociate) noexcept
    {
        m_Desc.pSubobjectToAssociate = &SubobjectToAssociate;
    }
    void AddExport(LPCWSTR Export)
    {
        m_Desc.NumExports++;
        m_Exports.push_back(m_Strings.LocalCopy(Export));
        m_Desc.pExports = &m_Exports[0];  // using ugly way to get pointer in case .data() is not defined
    }
    template<size_t N>
    void AddExports(LPCWSTR(&Exports)[N])
    {
        for (UINT i = 0; i < N; i++)
        {
            AddExport(Exports[i]);
        }
    }
    void AddExports(const LPCWSTR* Exports, UINT N)
    {
        for (UINT i = 0; i < N; i++)
        {
            AddExport(Exports[i]);
        }
    }
    D3D12_STATE_SUBOBJECT_TYPE Type() const noexcept override
    {
        return D3D12_STATE_SUBOBJECT_TYPE_SUBOBJECT_TO_EXPORTS_ASSOCIATION;
    }
    operator const D3D12_STATE_SUBOBJECT& () const noexcept { return *m_pSubobject; }
    operator const D3D12_SUBOBJECT_TO_EXPORTS_ASSOCIATION& () const noexcept { return m_Desc; }
private:
    void Init() noexcept
    {
        SUBOBJECT_HELPER_BASE::Init();
        m_Desc = {};
        m_Strings.clear();
        m_Exports.clear();
    }
    void* Data() noexcept override { return &m_Desc; }
    D3D12_SUBOBJECT_TO_EXPORTS_ASSOCIATION m_Desc;
    CD3DX12_STATE_OBJECT_DESC::StringContainer m_Strings;
    std::vector<LPCWSTR> m_Exports;
};

//------------------------------------------------------------------------------------------------
class CD3DX12_DXIL_SUBOBJECT_TO_EXPORTS_ASSOCIATION
    : public CD3DX12_STATE_OBJECT_DESC::SUBOBJECT_HELPER_BASE
{
public:
    CD3DX12_DXIL_SUBOBJECT_TO_EXPORTS_ASSOCIATION() noexcept
    {
        Init();
    }
    CD3DX12_DXIL_SUBOBJECT_TO_EXPORTS_ASSOCIATION(CD3DX12_STATE_OBJECT_DESC& ContainingStateObject)
    {
        Init();
        AddToStateObject(ContainingStateObject);
    }
    void SetSubobjectNameToAssociate(LPCWSTR SubobjectToAssociate)
    {
        m_Desc.SubobjectToAssociate = m_SubobjectName.LocalCopy(SubobjectToAssociate, true);
    }
    void AddExport(LPCWSTR Export)
    {
        m_Desc.NumExports++;
        m_Exports.push_back(m_Strings.LocalCopy(Export));
        m_Desc.pExports = &m_Exports[0];  // using ugly way to get pointer in case .data() is not defined
    }
    template<size_t N>
    void AddExports(LPCWSTR(&Exports)[N])
    {
        for (UINT i = 0; i < N; i++)
        {
            AddExport(Exports[i]);
        }
    }
    void AddExports(const LPCWSTR* Exports, UINT N)
    {
        for (UINT i = 0; i < N; i++)
        {
            AddExport(Exports[i]);
        }
    }
    D3D12_STATE_SUBOBJECT_TYPE Type() const noexcept override
    {
        return D3D12_STATE_SUBOBJECT_TYPE_DXIL_SUBOBJECT_TO_EXPORTS_ASSOCIATION;
    }
    operator const D3D12_STATE_SUBOBJECT& () const noexcept { return *m_pSubobject; }
    operator const D3D12_DXIL_SUBOBJECT_TO_EXPORTS_ASSOCIATION& () const noexcept { return m_Desc; }
private:
    void Init() noexcept
    {
        SUBOBJECT_HELPER_BASE::Init();
        m_Desc = {};
        m_Strings.clear();
        m_SubobjectName.clear();
        m_Exports.clear();
    }
    void* Data() noexcept override { return &m_Desc; }
    D3D12_DXIL_SUBOBJECT_TO_EXPORTS_ASSOCIATION m_Desc;
    CD3DX12_STATE_OBJECT_DESC::StringContainer m_Strings;
    CD3DX12_STATE_OBJECT_DESC::StringContainer m_SubobjectName;
    std::vector<LPCWSTR> m_Exports;
};

//------------------------------------------------------------------------------------------------
class CD3DX12_HIT_GROUP_SUBOBJECT
    : public CD3DX12_STATE_OBJECT_DESC::SUBOBJECT_HELPER_BASE
{
public:
    CD3DX12_HIT_GROUP_SUBOBJECT() noexcept
    {
        Init();
    }
    CD3DX12_HIT_GROUP_SUBOBJECT(CD3DX12_STATE_OBJECT_DESC& ContainingStateObject)
    {
        Init();
        AddToStateObject(ContainingStateObject);
    }
    void SetHitGroupExport(LPCWSTR exportName)
    {
        m_Desc.HitGroupExport = m_Strings[0].LocalCopy(exportName, true);
    }
    void SetHitGroupType(D3D12_HIT_GROUP_TYPE Type) noexcept { m_Desc.Type = Type; }
    void SetAnyHitShaderImport(LPCWSTR importName)
    {
        m_Desc.AnyHitShaderImport = m_Strings[1].LocalCopy(importName, true);
    }
    void SetClosestHitShaderImport(LPCWSTR importName)
    {
        m_Desc.ClosestHitShaderImport = m_Strings[2].LocalCopy(importName, true);
    }
    void SetIntersectionShaderImport(LPCWSTR importName)
    {
        m_Desc.IntersectionShaderImport = m_Strings[3].LocalCopy(importName, true);
    }
    D3D12_STATE_SUBOBJECT_TYPE Type() const noexcept override
    {
        return D3D12_STATE_SUBOBJECT_TYPE_HIT_GROUP;
    }
    operator const D3D12_STATE_SUBOBJECT& () const noexcept { return *m_pSubobject; }
    operator const D3D12_HIT_GROUP_DESC& () const noexcept { return m_Desc; }
private:
    void Init() noexcept
    {
        SUBOBJECT_HELPER_BASE::Init();
        m_Desc = {};
        for (UINT i = 0; i < m_NumStrings; i++)
        {
            m_Strings[i].clear();
        }
    }
    void* Data() noexcept override { return &m_Desc; }
    D3D12_HIT_GROUP_DESC m_Desc;
    static const UINT m_NumStrings = 4;
    CD3DX12_STATE_OBJECT_DESC::StringContainer
        m_Strings[m_NumStrings]; // one string for every entrypoint name
};

//------------------------------------------------------------------------------------------------
class CD3DX12_RAYTRACING_SHADER_CONFIG_SUBOBJECT
    : public CD3DX12_STATE_OBJECT_DESC::SUBOBJECT_HELPER_BASE
{
public:
    CD3DX12_RAYTRACING_SHADER_CONFIG_SUBOBJECT() noexcept
    {
        Init();
    }
    CD3DX12_RAYTRACING_SHADER_CONFIG_SUBOBJECT(CD3DX12_STATE_OBJECT_DESC& ContainingStateObject)
    {
        Init();
        AddToStateObject(ContainingStateObject);
    }
    void Config(UINT MaxPayloadSizeInBytes, UINT MaxAttributeSizeInBytes) noexcept
    {
        m_Desc.MaxPayloadSizeInBytes = MaxPayloadSizeInBytes;
        m_Desc.MaxAttributeSizeInBytes = MaxAttributeSizeInBytes;
    }
    D3D12_STATE_SUBOBJECT_TYPE Type() const noexcept override
    {
        return D3D12_STATE_SUBOBJECT_TYPE_RAYTRACING_SHADER_CONFIG;
    }
    operator const D3D12_STATE_SUBOBJECT& () const noexcept { return *m_pSubobject; }
    operator const D3D12_RAYTRACING_SHADER_CONFIG& () const noexcept { return m_Desc; }
private:
    void Init() noexcept
    {
        SUBOBJECT_HELPER_BASE::Init();
        m_Desc = {};
    }
    void* Data() noexcept override { return &m_Desc; }
    D3D12_RAYTRACING_SHADER_CONFIG m_Desc;
};

//------------------------------------------------------------------------------------------------
class CD3DX12_RAYTRACING_PIPELINE_CONFIG_SUBOBJECT
    : public CD3DX12_STATE_OBJECT_DESC::SUBOBJECT_HELPER_BASE
{
public:
    CD3DX12_RAYTRACING_PIPELINE_CONFIG_SUBOBJECT() noexcept
    {
        Init();
    }
    CD3DX12_RAYTRACING_PIPELINE_CONFIG_SUBOBJECT(CD3DX12_STATE_OBJECT_DESC& ContainingStateObject)
    {
        Init();
        AddToStateObject(ContainingStateObject);
    }
    void Config(UINT MaxTraceRecursionDepth) noexcept
    {
        m_Desc.MaxTraceRecursionDepth = MaxTraceRecursionDepth;
    }
    D3D12_STATE_SUBOBJECT_TYPE Type() const noexcept override
    {
        return D3D12_STATE_SUBOBJECT_TYPE_RAYTRACING_PIPELINE_CONFIG;
    }
    operator const D3D12_STATE_SUBOBJECT& () const noexcept { return *m_pSubobject; }
    operator const D3D12_RAYTRACING_PIPELINE_CONFIG& () const noexcept { return m_Desc; }
private:
    void Init() noexcept
    {
        SUBOBJECT_HELPER_BASE::Init();
        m_Desc = {};
    }
    void* Data() noexcept override { return &m_Desc; }
    D3D12_RAYTRACING_PIPELINE_CONFIG m_Desc;
};

//------------------------------------------------------------------------------------------------
#if defined(NTDDI_WIN10_VB) && (NTDDI_VERSION >= NTDDI_WIN10_VB)
class CD3DX12_RAYTRACING_PIPELINE_CONFIG1_SUBOBJECT
    : public CD3DX12_STATE_OBJECT_DESC::SUBOBJECT_HELPER_BASE
{
public:
    CD3DX12_RAYTRACING_PIPELINE_CONFIG1_SUBOBJECT() noexcept
    {
        Init();
    }
    CD3DX12_RAYTRACING_PIPELINE_CONFIG1_SUBOBJECT(CD3DX12_STATE_OBJECT_DESC& ContainingStateObject)
    {
        Init();
        AddToStateObject(ContainingStateObject);
    }
    void Config(UINT MaxTraceRecursionDepth, D3D12_RAYTRACING_PIPELINE_FLAGS Flags) noexcept
    {
        m_Desc.MaxTraceRecursionDepth = MaxTraceRecursionDepth;
        m_Desc.Flags = Flags;
    }
    D3D12_STATE_SUBOBJECT_TYPE Type() const noexcept override
    {
        return D3D12_STATE_SUBOBJECT_TYPE_RAYTRACING_PIPELINE_CONFIG1;
    }
    operator const D3D12_STATE_SUBOBJECT& () const noexcept { return *m_pSubobject; }
    operator const D3D12_RAYTRACING_PIPELINE_CONFIG1& () const noexcept { return m_Desc; }
private:
    void Init() noexcept
    {
        SUBOBJECT_HELPER_BASE::Init();
        m_Desc = {};
    }
    void* Data() noexcept override { return &m_Desc; }
    D3D12_RAYTRACING_PIPELINE_CONFIG1 m_Desc;
};
#endif // NTDDI_WIN10_VB

//------------------------------------------------------------------------------------------------
class CD3DX12_GLOBAL_ROOT_SIGNATURE_SUBOBJECT
    : public CD3DX12_STATE_OBJECT_DESC::SUBOBJECT_HELPER_BASE
{
public:
    CD3DX12_GLOBAL_ROOT_SIGNATURE_SUBOBJECT() noexcept
    {
        Init();
    }
    CD3DX12_GLOBAL_ROOT_SIGNATURE_SUBOBJECT(CD3DX12_STATE_OBJECT_DESC& ContainingStateObject)
    {
        Init();
        AddToStateObject(ContainingStateObject);
    }
    void SetRootSignature(ID3D12RootSignature* pRootSig) noexcept
    {
        m_pRootSig = pRootSig;
    }
    D3D12_STATE_SUBOBJECT_TYPE Type() const noexcept override
    {
        return D3D12_STATE_SUBOBJECT_TYPE_GLOBAL_ROOT_SIGNATURE;
    }
    operator const D3D12_STATE_SUBOBJECT& () const noexcept { return *m_pSubobject; }
    operator ID3D12RootSignature* () const noexcept { return m_pRootSig.Get(); }
private:
    void Init() noexcept
    {
        SUBOBJECT_HELPER_BASE::Init();
        m_pRootSig = nullptr;
    }
    void* Data() noexcept override { return m_pRootSig.GetAddressOf(); }
    Microsoft::WRL::ComPtr<ID3D12RootSignature> m_pRootSig;
};

//------------------------------------------------------------------------------------------------
class CD3DX12_LOCAL_ROOT_SIGNATURE_SUBOBJECT
    : public CD3DX12_STATE_OBJECT_DESC::SUBOBJECT_HELPER_BASE
{
public:
    CD3DX12_LOCAL_ROOT_SIGNATURE_SUBOBJECT() noexcept
    {
        Init();
    }
    CD3DX12_LOCAL_ROOT_SIGNATURE_SUBOBJECT(CD3DX12_STATE_OBJECT_DESC& ContainingStateObject)
    {
        Init();
        AddToStateObject(ContainingStateObject);
    }
    void SetRootSignature(ID3D12RootSignature* pRootSig) noexcept
    {
        m_pRootSig = pRootSig;
    }
    D3D12_STATE_SUBOBJECT_TYPE Type() const noexcept override
    {
        return D3D12_STATE_SUBOBJECT_TYPE_LOCAL_ROOT_SIGNATURE;
    }
    operator const D3D12_STATE_SUBOBJECT& () const noexcept { return *m_pSubobject; }
    operator ID3D12RootSignature* () const noexcept { return m_pRootSig.Get(); }
private:
    void Init() noexcept
    {
        SUBOBJECT_HELPER_BASE::Init();
        m_pRootSig = nullptr;
    }
    void* Data() noexcept override { return m_pRootSig.GetAddressOf(); }
    Microsoft::WRL::ComPtr<ID3D12RootSignature> m_pRootSig;
};

//------------------------------------------------------------------------------------------------
class CD3DX12_STATE_OBJECT_CONFIG_SUBOBJECT
    : public CD3DX12_STATE_OBJECT_DESC::SUBOBJECT_HELPER_BASE
{
public:
    CD3DX12_STATE_OBJECT_CONFIG_SUBOBJECT() noexcept
    {
        Init();
    }
    CD3DX12_STATE_OBJECT_CONFIG_SUBOBJECT(CD3DX12_STATE_OBJECT_DESC& ContainingStateObject)
    {
        Init();
        AddToStateObject(ContainingStateObject);
    }
    void SetFlags(D3D12_STATE_OBJECT_FLAGS Flags) noexcept
    {
        m_Desc.Flags = Flags;
    }
    D3D12_STATE_SUBOBJECT_TYPE Type() const noexcept override
    {
        return D3D12_STATE_SUBOBJECT_TYPE_STATE_OBJECT_CONFIG;
    }
    operator const D3D12_STATE_SUBOBJECT& () const noexcept { return *m_pSubobject; }
    operator const D3D12_STATE_OBJECT_CONFIG& () const noexcept { return m_Desc; }
private:
    void Init() noexcept
    {
        SUBOBJECT_HELPER_BASE::Init();
        m_Desc = {};
    }
    void* Data() noexcept override { return &m_Desc; }
    D3D12_STATE_OBJECT_CONFIG m_Desc;
};

//------------------------------------------------------------------------------------------------
class CD3DX12_NODE_MASK_SUBOBJECT
    : public CD3DX12_STATE_OBJECT_DESC::SUBOBJECT_HELPER_BASE
{
public:
    CD3DX12_NODE_MASK_SUBOBJECT() noexcept
    {
        Init();
    }
    CD3DX12_NODE_MASK_SUBOBJECT(CD3DX12_STATE_OBJECT_DESC& ContainingStateObject)
    {
        Init();
        AddToStateObject(ContainingStateObject);
    }
    void SetNodeMask(UINT NodeMask) noexcept
    {
        m_Desc.NodeMask = NodeMask;
    }
    D3D12_STATE_SUBOBJECT_TYPE Type() const noexcept override
    {
        return D3D12_STATE_SUBOBJECT_TYPE_NODE_MASK;
    }
    operator const D3D12_STATE_SUBOBJECT& () const noexcept { return *m_pSubobject; }
    operator const D3D12_NODE_MASK& () const noexcept { return m_Desc; }
private:
    void Init() noexcept
    {
        SUBOBJECT_HELPER_BASE::Init();
        m_Desc = {};
    }
    void* Data() noexcept override { return &m_Desc; }
    D3D12_NODE_MASK m_Desc;
};

#endif // #ifndef D3DX12_NO_STATE_OBJECT_HELPERS
#endif // NTDDI_WIN10_RS5

#endif // defined( __cplusplus )

#endif //__D3DX12_H__
```

`ext/fontawesome/IconsFontAwesome5.h`:

```h
// Generated by https://github.com/juliettef/IconFontCppHeaders script GenerateIconFontCppHeaders.py for languages C and C++
// from https://github.com/FortAwesome/Font-Awesome/raw/5.x/metadata/icons.yml
// for use with https://github.com/FortAwesome/Font-Awesome/blob/5.x/webfonts/fa-regular-400.ttf, https://github.com/FortAwesome/Font-Awesome/blob/5.x/webfonts/fa-solid-900.ttf
#pragma once

#define FONT_ICON_FILE_NAME_FAR "fa-regular-400.ttf"
#define FONT_ICON_FILE_NAME_FAS "fa-solid-900.ttf"

#define ICON_MIN_FA 0xe005
#define ICON_MAX_FA 0xf8ff
#define ICON_FA_AD "\xef\x99\x81"	// U+f641
#define ICON_FA_ADDRESS_BOOK "\xef\x8a\xb9"	// U+f2b9
#define ICON_FA_ADDRESS_CARD "\xef\x8a\xbb"	// U+f2bb
#define ICON_FA_ADJUST "\xef\x81\x82"	// U+f042
#define ICON_FA_AIR_FRESHENER "\xef\x97\x90"	// U+f5d0
#define ICON_FA_ALIGN_CENTER "\xef\x80\xb7"	// U+f037
#define ICON_FA_ALIGN_JUSTIFY "\xef\x80\xb9"	// U+f039
#define ICON_FA_ALIGN_LEFT "\xef\x80\xb6"	// U+f036
#define ICON_FA_ALIGN_RIGHT "\xef\x80\xb8"	// U+f038
#define ICON_FA_ALLERGIES "\xef\x91\xa1"	// U+f461
#define ICON_FA_AMBULANCE "\xef\x83\xb9"	// U+f0f9
#define ICON_FA_AMERICAN_SIGN_LANGUAGE_INTERPRETING "\xef\x8a\xa3"	// U+f2a3
#define ICON_FA_ANCHOR "\xef\x84\xbd"	// U+f13d
#define ICON_FA_ANGLE_DOUBLE_DOWN "\xef\x84\x83"	// U+f103
#define ICON_FA_ANGLE_DOUBLE_LEFT "\xef\x84\x80"	// U+f100
#define ICON_FA_ANGLE_DOUBLE_RIGHT "\xef\x84\x81"	// U+f101
#define ICON_FA_ANGLE_DOUBLE_UP "\xef\x84\x82"	// U+f102
#define ICON_FA_ANGLE_DOWN "\xef\x84\x87"	// U+f107
#define ICON_FA_ANGLE_LEFT "\xef\x84\x84"	// U+f104
#define ICON_FA_ANGLE_RIGHT "\xef\x84\x85"	// U+f105
#define ICON_FA_ANGLE_UP "\xef\x84\x86"	// U+f106
#define ICON_FA_ANGRY "\xef\x95\x96"	// U+f556
#define ICON_FA_ANKH "\xef\x99\x84"	// U+f644
#define ICON_FA_APPLE_ALT "\xef\x97\x91"	// U+f5d1
#define ICON_FA_ARCHIVE "\xef\x86\x87"	// U+f187
#define ICON_FA_ARCHWAY "\xef\x95\x97"	// U+f557
#define ICON_FA_ARROW_ALT_CIRCLE_DOWN "\xef\x8d\x98"	// U+f358
#define ICON_FA_ARROW_ALT_CIRCLE_LEFT "\xef\x8d\x99"	// U+f359
#define ICON_FA_ARROW_ALT_CIRCLE_RIGHT "\xef\x8d\x9a"	// U+f35a
#define ICON_FA_ARROW_ALT_CIRCLE_UP "\xef\x8d\x9b"	// U+f35b
#define ICON_FA_ARROW_CIRCLE_DOWN "\xef\x82\xab"	// U+f0ab
#define ICON_FA_ARROW_CIRCLE_LEFT "\xef\x82\xa8"	// U+f0a8
#define ICON_FA_ARROW_CIRCLE_RIGHT "\xef\x82\xa9"	// U+f0a9
#define ICON_FA_ARROW_CIRCLE_UP "\xef\x82\xaa"	// U+f0aa
#define ICON_FA_ARROW_DOWN "\xef\x81\xa3"	// U+f063
#define ICON_FA_ARROW_LEFT "\xef\x81\xa0"	// U+f060
#define ICON_FA_ARROW_RIGHT "\xef\x81\xa1"	// U+f061
#define ICON_FA_ARROW_UP "\xef\x81\xa2"	// U+f062
#define ICON_FA_ARROWS_ALT "\xef\x82\xb2"	// U+f0b2
#define ICON_FA_ARROWS_ALT_H "\xef\x8c\xb7"	// U+f337
#define ICON_FA_ARROWS_ALT_V "\xef\x8c\xb8"	// U+f338
#define ICON_FA_ASSISTIVE_LISTENING_SYSTEMS "\xef\x8a\xa2"	// U+f2a2
#define ICON_FA_ASTERISK "\xef\x81\xa9"	// U+f069
#define ICON_FA_AT "\xef\x87\xba"	// U+f1fa
#define ICON_FA_ATLAS "\xef\x95\x98"	// U+f558
#define ICON_FA_ATOM "\xef\x97\x92"	// U+f5d2
#define ICON_FA_AUDIO_DESCRIPTION "\xef\x8a\x9e"	// U+f29e
#define ICON_FA_AWARD "\xef\x95\x99"	// U+f559
#define ICON_FA_BABY "\xef\x9d\xbc"	// U+f77c
#define ICON_FA_BABY_CARRIAGE "\xef\x9d\xbd"	// U+f77d
#define ICON_FA_BACKSPACE "\xef\x95\x9a"	// U+f55a
#define ICON_FA_BACKWARD "\xef\x81\x8a"	// U+f04a
#define ICON_FA_BACON "\xef\x9f\xa5"	// U+f7e5
#define ICON_FA_BACTERIA "\xee\x81\x99"	// U+e059
#define ICON_FA_BACTERIUM "\xee\x81\x9a"	// U+e05a
#define ICON_FA_BAHAI "\xef\x99\xa6"	// U+f666
#define ICON_FA_BALANCE_SCALE "\xef\x89\x8e"	// U+f24e
#define ICON_FA_BALANCE_SCALE_LEFT "\xef\x94\x95"	// U+f515
#define ICON_FA_BALANCE_SCALE_RIGHT "\xef\x94\x96"	// U+f516
#define ICON_FA_BAN "\xef\x81\x9e"	// U+f05e
#define ICON_FA_BAND_AID "\xef\x91\xa2"	// U+f462
#define ICON_FA_BARCODE "\xef\x80\xaa"	// U+f02a
#define ICON_FA_BARS "\xef\x83\x89"	// U+f0c9
#define ICON_FA_BASEBALL_BALL "\xef\x90\xb3"	// U+f433
#define ICON_FA_BASKETBALL_BALL "\xef\x90\xb4"	// U+f434
#define ICON_FA_BATH "\xef\x8b\x8d"	// U+f2cd
#define ICON_FA_BATTERY_EMPTY "\xef\x89\x84"	// U+f244
#define ICON_FA_BATTERY_FULL "\xef\x89\x80"	// U+f240
#define ICON_FA_BATTERY_HALF "\xef\x89\x82"	// U+f242
#define ICON_FA_BATTERY_QUARTER "\xef\x89\x83"	// U+f243
#define ICON_FA_BATTERY_THREE_QUARTERS "\xef\x89\x81"	// U+f241
#define ICON_FA_BED "\xef\x88\xb6"	// U+f236
#define ICON_FA_BEER "\xef\x83\xbc"	// U+f0fc
#define ICON_FA_BELL "\xef\x83\xb3"	// U+f0f3
#define ICON_FA_BELL_SLASH "\xef\x87\xb6"	// U+f1f6
#define ICON_FA_BEZIER_CURVE "\xef\x95\x9b"	// U+f55b
#define ICON_FA_BIBLE "\xef\x99\x87"	// U+f647
#define ICON_FA_BICYCLE "\xef\x88\x86"	// U+f206
#define ICON_FA_BIKING "\xef\xa1\x8a"	// U+f84a
#define ICON_FA_BINOCULARS "\xef\x87\xa5"	// U+f1e5
#define ICON_FA_BIOHAZARD "\xef\x9e\x80"	// U+f780
#define ICON_FA_BIRTHDAY_CAKE "\xef\x87\xbd"	// U+f1fd
#define ICON_FA_BLENDER "\xef\x94\x97"	// U+f517
#define ICON_FA_BLENDER_PHONE "\xef\x9a\xb6"	// U+f6b6
#define ICON_FA_BLIND "\xef\x8a\x9d"	// U+f29d
#define ICON_FA_BLOG "\xef\x9e\x81"	// U+f781
#define ICON_FA_BOLD "\xef\x80\xb2"	// U+f032
#define ICON_FA_BOLT "\xef\x83\xa7"	// U+f0e7
#define ICON_FA_BOMB "\xef\x87\xa2"	// U+f1e2
#define ICON_FA_BONE "\xef\x97\x97"	// U+f5d7
#define ICON_FA_BONG "\xef\x95\x9c"	// U+f55c
#define ICON_FA_BOOK "\xef\x80\xad"	// U+f02d
#define ICON_FA_BOOK_DEAD "\xef\x9a\xb7"	// U+f6b7
#define ICON_FA_BOOK_MEDICAL "\xef\x9f\xa6"	// U+f7e6
#define ICON_FA_BOOK_OPEN "\xef\x94\x98"	// U+f518
#define ICON_FA_BOOK_READER "\xef\x97\x9a"	// U+f5da
#define ICON_FA_BOOKMARK "\xef\x80\xae"	// U+f02e
#define ICON_FA_BORDER_ALL "\xef\xa1\x8c"	// U+f84c
#define ICON_FA_BORDER_NONE "\xef\xa1\x90"	// U+f850
#define ICON_FA_BORDER_STYLE "\xef\xa1\x93"	// U+f853
#define ICON_FA_BOWLING_BALL "\xef\x90\xb6"	// U+f436
#define ICON_FA_BOX "\xef\x91\xa6"	// U+f466
#define ICON_FA_BOX_OPEN "\xef\x92\x9e"	// U+f49e
#define ICON_FA_BOX_TISSUE "\xee\x81\x9b"	// U+e05b
#define ICON_FA_BOXES "\xef\x91\xa8"	// U+f468
#define ICON_FA_BRAILLE "\xef\x8a\xa1"	// U+f2a1
#define ICON_FA_BRAIN "\xef\x97\x9c"	// U+f5dc
#define ICON_FA_BREAD_SLICE "\xef\x9f\xac"	// U+f7ec
#define ICON_FA_BRIEFCASE "\xef\x82\xb1"	// U+f0b1
#define ICON_FA_BRIEFCASE_MEDICAL "\xef\x91\xa9"	// U+f469
#define ICON_FA_BROADCAST_TOWER "\xef\x94\x99"	// U+f519
#define ICON_FA_BROOM "\xef\x94\x9a"	// U+f51a
#define ICON_FA_BRUSH "\xef\x95\x9d"	// U+f55d
#define ICON_FA_BUG "\xef\x86\x88"	// U+f188
#define ICON_FA_BUILDING "\xef\x86\xad"	// U+f1ad
#define ICON_FA_BULLHORN "\xef\x82\xa1"	// U+f0a1
#define ICON_FA_BULLSEYE "\xef\x85\x80"	// U+f140
#define ICON_FA_BURN "\xef\x91\xaa"	// U+f46a
#define ICON_FA_BUS "\xef\x88\x87"	// U+f207
#define ICON_FA_BUS_ALT "\xef\x95\x9e"	// U+f55e
#define ICON_FA_BUSINESS_TIME "\xef\x99\x8a"	// U+f64a
#define ICON_FA_CALCULATOR "\xef\x87\xac"	// U+f1ec
#define ICON_FA_CALENDAR "\xef\x84\xb3"	// U+f133
#define ICON_FA_CALENDAR_ALT "\xef\x81\xb3"	// U+f073
#define ICON_FA_CALENDAR_CHECK "\xef\x89\xb4"	// U+f274
#define ICON_FA_CALENDAR_DAY "\xef\x9e\x83"	// U+f783
#define ICON_FA_CALENDAR_MINUS "\xef\x89\xb2"	// U+f272
#define ICON_FA_CALENDAR_PLUS "\xef\x89\xb1"	// U+f271
#define ICON_FA_CALENDAR_TIMES "\xef\x89\xb3"	// U+f273
#define ICON_FA_CALENDAR_WEEK "\xef\x9e\x84"	// U+f784
#define ICON_FA_CAMERA "\xef\x80\xb0"	// U+f030
#define ICON_FA_CAMERA_RETRO "\xef\x82\x83"	// U+f083
#define ICON_FA_CAMPGROUND "\xef\x9a\xbb"	// U+f6bb
#define ICON_FA_CANDY_CANE "\xef\x9e\x86"	// U+f786
#define ICON_FA_CANNABIS "\xef\x95\x9f"	// U+f55f
#define ICON_FA_CAPSULES "\xef\x91\xab"	// U+f46b
#define ICON_FA_CAR "\xef\x86\xb9"	// U+f1b9
#define ICON_FA_CAR_ALT "\xef\x97\x9e"	// U+f5de
#define ICON_FA_CAR_BATTERY "\xef\x97\x9f"	// U+f5df
#define ICON_FA_CAR_CRASH "\xef\x97\xa1"	// U+f5e1
#define ICON_FA_CAR_SIDE "\xef\x97\xa4"	// U+f5e4
#define ICON_FA_CARAVAN "\xef\xa3\xbf"	// U+f8ff
#define ICON_FA_CARET_DOWN "\xef\x83\x97"	// U+f0d7
#define ICON_FA_CARET_LEFT "\xef\x83\x99"	// U+f0d9
#define ICON_FA_CARET_RIGHT "\xef\x83\x9a"	// U+f0da
#define ICON_FA_CARET_SQUARE_DOWN "\xef\x85\x90"	// U+f150
#define ICON_FA_CARET_SQUARE_LEFT "\xef\x86\x91"	// U+f191
#define ICON_FA_CARET_SQUARE_RIGHT "\xef\x85\x92"	// U+f152
#define ICON_FA_CARET_SQUARE_UP "\xef\x85\x91"	// U+f151
#define ICON_FA_CARET_UP "\xef\x83\x98"	// U+f0d8
#define ICON_FA_CARROT "\xef\x9e\x87"	// U+f787
#define ICON_FA_CART_ARROW_DOWN "\xef\x88\x98"	// U+f218
#define ICON_FA_CART_PLUS "\xef\x88\x97"	// U+f217
#define ICON_FA_CASH_REGISTER "\xef\x9e\x88"	// U+f788
#define ICON_FA_CAT "\xef\x9a\xbe"	// U+f6be
#define ICON_FA_CERTIFICATE "\xef\x82\xa3"	// U+f0a3
#define ICON_FA_CHAIR "\xef\x9b\x80"	// U+f6c0
#define ICON_FA_CHALKBOARD "\xef\x94\x9b"	// U+f51b
#define ICON_FA_CHALKBOARD_TEACHER "\xef\x94\x9c"	// U+f51c
#define ICON_FA_CHARGING_STATION "\xef\x97\xa7"	// U+f5e7
#define ICON_FA_CHART_AREA "\xef\x87\xbe"	// U+f1fe
#define ICON_FA_CHART_BAR "\xef\x82\x80"	// U+f080
#define ICON_FA_CHART_LINE "\xef\x88\x81"	// U+f201
#define ICON_FA_CHART_PIE "\xef\x88\x80"	// U+f200
#define ICON_FA_CHECK "\xef\x80\x8c"	// U+f00c
#define ICON_FA_CHECK_CIRCLE "\xef\x81\x98"	// U+f058
#define ICON_FA_CHECK_DOUBLE "\xef\x95\xa0"	// U+f560
#define ICON_FA_CHECK_SQUARE "\xef\x85\x8a"	// U+f14a
#define ICON_FA_CHEESE "\xef\x9f\xaf"	// U+f7ef
#define ICON_FA_CHESS "\xef\x90\xb9"	// U+f439
#define ICON_FA_CHESS_BISHOP "\xef\x90\xba"	// U+f43a
#define ICON_FA_CHESS_BOARD "\xef\x90\xbc"	// U+f43c
#define ICON_FA_CHESS_KING "\xef\x90\xbf"	// U+f43f
#define ICON_FA_CHESS_KNIGHT "\xef\x91\x81"	// U+f441
#define ICON_FA_CHESS_PAWN "\xef\x91\x83"	// U+f443
#define ICON_FA_CHESS_QUEEN "\xef\x91\x85"	// U+f445
#define ICON_FA_CHESS_ROOK "\xef\x91\x87"	// U+f447
#define ICON_FA_CHEVRON_CIRCLE_DOWN "\xef\x84\xba"	// U+f13a
#define ICON_FA_CHEVRON_CIRCLE_LEFT "\xef\x84\xb7"	// U+f137
#define ICON_FA_CHEVRON_CIRCLE_RIGHT "\xef\x84\xb8"	// U+f138
#define ICON_FA_CHEVRON_CIRCLE_UP "\xef\x84\xb9"	// U+f139
#define ICON_FA_CHEVRON_DOWN "\xef\x81\xb8"	// U+f078
#define ICON_FA_CHEVRON_LEFT "\xef\x81\x93"	// U+f053
#define ICON_FA_CHEVRON_RIGHT "\xef\x81\x94"	// U+f054
#define ICON_FA_CHEVRON_UP "\xef\x81\xb7"	// U+f077
#define ICON_FA_CHILD "\xef\x86\xae"	// U+f1ae
#define ICON_FA_CHURCH "\xef\x94\x9d"	// U+f51d
#define ICON_FA_CIRCLE "\xef\x84\x91"	// U+f111
#define ICON_FA_CIRCLE_NOTCH "\xef\x87\x8e"	// U+f1ce
#define ICON_FA_CITY "\xef\x99\x8f"	// U+f64f
#define ICON_FA_CLINIC_MEDICAL "\xef\x9f\xb2"	// U+f7f2
#define ICON_FA_CLIPBOARD "\xef\x8c\xa8"	// U+f328
#define ICON_FA_CLIPBOARD_CHECK "\xef\x91\xac"	// U+f46c
#define ICON_FA_CLIPBOARD_LIST "\xef\x91\xad"	// U+f46d
#define ICON_FA_CLOCK "\xef\x80\x97"	// U+f017
#define ICON_FA_CLONE "\xef\x89\x8d"	// U+f24d
#define ICON_FA_CLOSED_CAPTIONING "\xef\x88\x8a"	// U+f20a
#define ICON_FA_CLOUD "\xef\x83\x82"	// U+f0c2
#define ICON_FA_CLOUD_DOWNLOAD_ALT "\xef\x8e\x81"	// U+f381
#define ICON_FA_CLOUD_MEATBALL "\xef\x9c\xbb"	// U+f73b
#define ICON_FA_CLOUD_MOON "\xef\x9b\x83"	// U+f6c3
#define ICON_FA_CLOUD_MOON_RAIN "\xef\x9c\xbc"	// U+f73c
#define ICON_FA_CLOUD_RAIN "\xef\x9c\xbd"	// U+f73d
#define ICON_FA_CLOUD_SHOWERS_HEAVY "\xef\x9d\x80"	// U+f740
#define ICON_FA_CLOUD_SUN "\xef\x9b\x84"	// U+f6c4
#define ICON_FA_CLOUD_SUN_RAIN "\xef\x9d\x83"	// U+f743
#define ICON_FA_CLOUD_UPLOAD_ALT "\xef\x8e\x82"	// U+f382
#define ICON_FA_COCKTAIL "\xef\x95\xa1"	// U+f561
#define ICON_FA_CODE "\xef\x84\xa1"	// U+f121
#define ICON_FA_CODE_BRANCH "\xef\x84\xa6"	// U+f126
#define ICON_FA_COFFEE "\xef\x83\xb4"	// U+f0f4
#define ICON_FA_COG "\xef\x80\x93"	// U+f013
#define ICON_FA_COGS "\xef\x82\x85"	// U+f085
#define ICON_FA_COINS "\xef\x94\x9e"	// U+f51e
#define ICON_FA_COLUMNS "\xef\x83\x9b"	// U+f0db
#define ICON_FA_COMMENT "\xef\x81\xb5"	// U+f075
#define ICON_FA_COMMENT_ALT "\xef\x89\xba"	// U+f27a
#define ICON_FA_COMMENT_DOLLAR "\xef\x99\x91"	// U+f651
#define ICON_FA_COMMENT_DOTS "\xef\x92\xad"	// U+f4ad
#define ICON_FA_COMMENT_MEDICAL "\xef\x9f\xb5"	// U+f7f5
#define ICON_FA_COMMENT_SLASH "\xef\x92\xb3"	// U+f4b3
#define ICON_FA_COMMENTS "\xef\x82\x86"	// U+f086
#define ICON_FA_COMMENTS_DOLLAR "\xef\x99\x93"	// U+f653
#define ICON_FA_COMPACT_DISC "\xef\x94\x9f"	// U+f51f
#define ICON_FA_COMPASS "\xef\x85\x8e"	// U+f14e
#define ICON_FA_COMPRESS "\xef\x81\xa6"	// U+f066
#define ICON_FA_COMPRESS_ALT "\xef\x90\xa2"	// U+f422
#define ICON_FA_COMPRESS_ARROWS_ALT "\xef\x9e\x8c"	// U+f78c
#define ICON_FA_CONCIERGE_BELL "\xef\x95\xa2"	// U+f562
#define ICON_FA_COOKIE "\xef\x95\xa3"	// U+f563
#define ICON_FA_COOKIE_BITE "\xef\x95\xa4"	// U+f564
#define ICON_FA_COPY "\xef\x83\x85"	// U+f0c5
#define ICON_FA_COPYRIGHT "\xef\x87\xb9"	// U+f1f9
#define ICON_FA_COUCH "\xef\x92\xb8"	// U+f4b8
#define ICON_FA_CREDIT_CARD "\xef\x82\x9d"	// U+f09d
#define ICON_FA_CROP "\xef\x84\xa5"	// U+f125
#define ICON_FA_CROP_ALT "\xef\x95\xa5"	// U+f565
#define ICON_FA_CROSS "\xef\x99\x94"	// U+f654
#define ICON_FA_CROSSHAIRS "\xef\x81\x9b"	// U+f05b
#define ICON_FA_CROW "\xef\x94\xa0"	// U+f520
#define ICON_FA_CROWN "\xef\x94\xa1"	// U+f521
#define ICON_FA_CRUTCH "\xef\x9f\xb7"	// U+f7f7
#define ICON_FA_CUBE "\xef\x86\xb2"	// U+f1b2
#define ICON_FA_CUBES "\xef\x86\xb3"	// U+f1b3
#define ICON_FA_CUT "\xef\x83\x84"	// U+f0c4
#define ICON_FA_DATABASE "\xef\x87\x80"	// U+f1c0
#define ICON_FA_DEAF "\xef\x8a\xa4"	// U+f2a4
#define ICON_FA_DEMOCRAT "\xef\x9d\x87"	// U+f747
#define ICON_FA_DESKTOP "\xef\x84\x88"	// U+f108
#define ICON_FA_DHARMACHAKRA "\xef\x99\x95"	// U+f655
#define ICON_FA_DIAGNOSES "\xef\x91\xb0"	// U+f470
#define ICON_FA_DICE "\xef\x94\xa2"	// U+f522
#define ICON_FA_DICE_D20 "\xef\x9b\x8f"	// U+f6cf
#define ICON_FA_DICE_D6 "\xef\x9b\x91"	// U+f6d1
#define ICON_FA_DICE_FIVE "\xef\x94\xa3"	// U+f523
#define ICON_FA_DICE_FOUR "\xef\x94\xa4"	// U+f524
#define ICON_FA_DICE_ONE "\xef\x94\xa5"	// U+f525
#define ICON_FA_DICE_SIX "\xef\x94\xa6"	// U+f526
#define ICON_FA_DICE_THREE "\xef\x94\xa7"	// U+f527
#define ICON_FA_DICE_TWO "\xef\x94\xa8"	// U+f528
#define ICON_FA_DIGITAL_TACHOGRAPH "\xef\x95\xa6"	// U+f566
#define ICON_FA_DIRECTIONS "\xef\x97\xab"	// U+f5eb
#define ICON_FA_DISEASE "\xef\x9f\xba"	// U+f7fa
#define ICON_FA_DIVIDE "\xef\x94\xa9"	// U+f529
#define ICON_FA_DIZZY "\xef\x95\xa7"	// U+f567
#define ICON_FA_DNA "\xef\x91\xb1"	// U+f471
#define ICON_FA_DOG "\xef\x9b\x93"	// U+f6d3
#define ICON_FA_DOLLAR_SIGN "\xef\x85\x95"	// U+f155
#define ICON_FA_DOLLY "\xef\x91\xb2"	// U+f472
#define ICON_FA_DOLLY_FLATBED "\xef\x91\xb4"	// U+f474
#define ICON_FA_DONATE "\xef\x92\xb9"	// U+f4b9
#define ICON_FA_DOOR_CLOSED "\xef\x94\xaa"	// U+f52a
#define ICON_FA_DOOR_OPEN "\xef\x94\xab"	// U+f52b
#define ICON_FA_DOT_CIRCLE "\xef\x86\x92"	// U+f192
#define ICON_FA_DOVE "\xef\x92\xba"	// U+f4ba
#define ICON_FA_DOWNLOAD "\xef\x80\x99"	// U+f019
#define ICON_FA_DRAFTING_COMPASS "\xef\x95\xa8"	// U+f568
#define ICON_FA_DRAGON "\xef\x9b\x95"	// U+f6d5
#define ICON_FA_DRAW_POLYGON "\xef\x97\xae"	// U+f5ee
#define ICON_FA_DRUM "\xef\x95\xa9"	// U+f569
#define ICON_FA_DRUM_STEELPAN "\xef\x95\xaa"	// U+f56a
#define ICON_FA_DRUMSTICK_BITE "\xef\x9b\x97"	// U+f6d7
#define ICON_FA_DUMBBELL "\xef\x91\x8b"	// U+f44b
#define ICON_FA_DUMPSTER "\xef\x9e\x93"	// U+f793
#define ICON_FA_DUMPSTER_FIRE "\xef\x9e\x94"	// U+f794
#define ICON_FA_DUNGEON "\xef\x9b\x99"	// U+f6d9
#define ICON_FA_EDIT "\xef\x81\x84"	// U+f044
#define ICON_FA_EGG "\xef\x9f\xbb"	// U+f7fb
#define ICON_FA_EJECT "\xef\x81\x92"	// U+f052
#define ICON_FA_ELLIPSIS_H "\xef\x85\x81"	// U+f141
#define ICON_FA_ELLIPSIS_V "\xef\x85\x82"	// U+f142
#define ICON_FA_ENVELOPE "\xef\x83\xa0"	// U+f0e0
#define ICON_FA_ENVELOPE_OPEN "\xef\x8a\xb6"	// U+f2b6
#define ICON_FA_ENVELOPE_OPEN_TEXT "\xef\x99\x98"	// U+f658
#define ICON_FA_ENVELOPE_SQUARE "\xef\x86\x99"	// U+f199
#define ICON_FA_EQUALS "\xef\x94\xac"	// U+f52c
#define ICON_FA_ERASER "\xef\x84\xad"	// U+f12d
#define ICON_FA_ETHERNET "\xef\x9e\x96"	// U+f796
#define ICON_FA_EURO_SIGN "\xef\x85\x93"	// U+f153
#define ICON_FA_EXCHANGE_ALT "\xef\x8d\xa2"	// U+f362
#define ICON_FA_EXCLAMATION "\xef\x84\xaa"	// U+f12a
#define ICON_FA_EXCLAMATION_CIRCLE "\xef\x81\xaa"	// U+f06a
#define ICON_FA_EXCLAMATION_TRIANGLE "\xef\x81\xb1"	// U+f071
#define ICON_FA_EXPAND "\xef\x81\xa5"	// U+f065
#define ICON_FA_EXPAND_ALT "\xef\x90\xa4"	// U+f424
#define ICON_FA_EXPAND_ARROWS_ALT "\xef\x8c\x9e"	// U+f31e
#define ICON_FA_EXTERNAL_LINK_ALT "\xef\x8d\x9d"	// U+f35d
#define ICON_FA_EXTERNAL_LINK_SQUARE_ALT "\xef\x8d\xa0"	// U+f360
#define ICON_FA_EYE "\xef\x81\xae"	// U+f06e
#define ICON_FA_EYE_DROPPER "\xef\x87\xbb"	// U+f1fb
#define ICON_FA_EYE_SLASH "\xef\x81\xb0"	// U+f070
#define ICON_FA_FAN "\xef\xa1\xa3"	// U+f863
#define ICON_FA_FAST_BACKWARD "\xef\x81\x89"	// U+f049
#define ICON_FA_FAST_FORWARD "\xef\x81\x90"	// U+f050
#define ICON_FA_FAUCET "\xee\x80\x85"	// U+e005
#define ICON_FA_FAX "\xef\x86\xac"	// U+f1ac
#define ICON_FA_FEATHER "\xef\x94\xad"	// U+f52d
#define ICON_FA_FEATHER_ALT "\xef\x95\xab"	// U+f56b
#define ICON_FA_FEMALE "\xef\x86\x82"	// U+f182
#define ICON_FA_FIGHTER_JET "\xef\x83\xbb"	// U+f0fb
#define ICON_FA_FILE "\xef\x85\x9b"	// U+f15b
#define ICON_FA_FILE_ALT "\xef\x85\x9c"	// U+f15c
#define ICON_FA_FILE_ARCHIVE "\xef\x87\x86"	// U+f1c6
#define ICON_FA_FILE_AUDIO "\xef\x87\x87"	// U+f1c7
#define ICON_FA_FILE_CODE "\xef\x87\x89"	// U+f1c9
#define ICON_FA_FILE_CONTRACT "\xef\x95\xac"	// U+f56c
#define ICON_FA_FILE_CSV "\xef\x9b\x9d"	// U+f6dd
#define ICON_FA_FILE_DOWNLOAD "\xef\x95\xad"	// U+f56d
#define ICON_FA_FILE_EXCEL "\xef\x87\x83"	// U+f1c3
#define ICON_FA_FILE_EXPORT "\xef\x95\xae"	// U+f56e
#define ICON_FA_FILE_IMAGE "\xef\x87\x85"	// U+f1c5
#define ICON_FA_FILE_IMPORT "\xef\x95\xaf"	// U+f56f
#define ICON_FA_FILE_INVOICE "\xef\x95\xb0"	// U+f570
#define ICON_FA_FILE_INVOICE_DOLLAR "\xef\x95\xb1"	// U+f571
#define ICON_FA_FILE_MEDICAL "\xef\x91\xb7"	// U+f477
#define ICON_FA_FILE_MEDICAL_ALT "\xef\x91\xb8"	// U+f478
#define ICON_FA_FILE_PDF "\xef\x87\x81"	// U+f1c1
#define ICON_FA_FILE_POWERPOINT "\xef\x87\x84"	// U+f1c4
#define ICON_FA_FILE_PRESCRIPTION "\xef\x95\xb2"	// U+f572
#define ICON_FA_FILE_SIGNATURE "\xef\x95\xb3"	// U+f573
#define ICON_FA_FILE_UPLOAD "\xef\x95\xb4"	// U+f574
#define ICON_FA_FILE_VIDEO "\xef\x87\x88"	// U+f1c8
#define ICON_FA_FILE_WORD "\xef\x87\x82"	// U+f1c2
#define ICON_FA_FILL "\xef\x95\xb5"	// U+f575
#define ICON_FA_FILL_DRIP "\xef\x95\xb6"	// U+f576
#define ICON_FA_FILM "\xef\x80\x88"	// U+f008
#define ICON_FA_FILTER "\xef\x82\xb0"	// U+f0b0
#define ICON_FA_FINGERPRINT "\xef\x95\xb7"	// U+f577
#define ICON_FA_FIRE "\xef\x81\xad"	// U+f06d
#define ICON_FA_FIRE_ALT "\xef\x9f\xa4"	// U+f7e4
#define ICON_FA_FIRE_EXTINGUISHER "\xef\x84\xb4"	// U+f134
#define ICON_FA_FIRST_AID "\xef\x91\xb9"	// U+f479
#define ICON_FA_FISH "\xef\x95\xb8"	// U+f578
#define ICON_FA_FIST_RAISED "\xef\x9b\x9e"	// U+f6de
#define ICON_FA_FLAG "\xef\x80\xa4"	// U+f024
#define ICON_FA_FLAG_CHECKERED "\xef\x84\x9e"	// U+f11e
#define ICON_FA_FLAG_USA "\xef\x9d\x8d"	// U+f74d
#define ICON_FA_FLASK "\xef\x83\x83"	// U+f0c3
#define ICON_FA_FLUSHED "\xef\x95\xb9"	// U+f579
#define ICON_FA_FOLDER "\xef\x81\xbb"	// U+f07b
#define ICON_FA_FOLDER_MINUS "\xef\x99\x9d"	// U+f65d
#define ICON_FA_FOLDER_OPEN "\xef\x81\xbc"	// U+f07c
#define ICON_FA_FOLDER_PLUS "\xef\x99\x9e"	// U+f65e
#define ICON_FA_FONT "\xef\x80\xb1"	// U+f031
#define ICON_FA_FONT_AWESOME_LOGO_FULL "\xef\x93\xa6"	// U+f4e6
#define ICON_FA_FOOTBALL_BALL "\xef\x91\x8e"	// U+f44e
#define ICON_FA_FORWARD "\xef\x81\x8e"	// U+f04e
#define ICON_FA_FROG "\xef\x94\xae"	// U+f52e
#define ICON_FA_FROWN "\xef\x84\x99"	// U+f119
#define ICON_FA_FROWN_OPEN "\xef\x95\xba"	// U+f57a
#define ICON_FA_FUNNEL_DOLLAR "\xef\x99\xa2"	// U+f662
#define ICON_FA_FUTBOL "\xef\x87\xa3"	// U+f1e3
#define ICON_FA_GAMEPAD "\xef\x84\x9b"	// U+f11b
#define ICON_FA_GAS_PUMP "\xef\x94\xaf"	// U+f52f
#define ICON_FA_GAVEL "\xef\x83\xa3"	// U+f0e3
#define ICON_FA_GEM "\xef\x8e\xa5"	// U+f3a5
#define ICON_FA_GENDERLESS "\xef\x88\xad"	// U+f22d
#define ICON_FA_GHOST "\xef\x9b\xa2"	// U+f6e2
#define ICON_FA_GIFT "\xef\x81\xab"	// U+f06b
#define ICON_FA_GIFTS "\xef\x9e\x9c"	// U+f79c
#define ICON_FA_GLASS_CHEERS "\xef\x9e\x9f"	// U+f79f
#define ICON_FA_GLASS_MARTINI "\xef\x80\x80"	// U+f000
#define ICON_FA_GLASS_MARTINI_ALT "\xef\x95\xbb"	// U+f57b
#define ICON_FA_GLASS_WHISKEY "\xef\x9e\xa0"	// U+f7a0
#define ICON_FA_GLASSES "\xef\x94\xb0"	// U+f530
#define ICON_FA_GLOBE "\xef\x82\xac"	// U+f0ac
#define ICON_FA_GLOBE_AFRICA "\xef\x95\xbc"	// U+f57c
#define ICON_FA_GLOBE_AMERICAS "\xef\x95\xbd"	// U+f57d
#define ICON_FA_GLOBE_ASIA "\xef\x95\xbe"	// U+f57e
#define ICON_FA_GLOBE_EUROPE "\xef\x9e\xa2"	// U+f7a2
#define ICON_FA_GOLF_BALL "\xef\x91\x90"	// U+f450
#define ICON_FA_GOPURAM "\xef\x99\xa4"	// U+f664
#define ICON_FA_GRADUATION_CAP "\xef\x86\x9d"	// U+f19d
#define ICON_FA_GREATER_THAN "\xef\x94\xb1"	// U+f531
#define ICON_FA_GREATER_THAN_EQUAL "\xef\x94\xb2"	// U+f532
#define ICON_FA_GRIMACE "\xef\x95\xbf"	// U+f57f
#define ICON_FA_GRIN "\xef\x96\x80"	// U+f580
#define ICON_FA_GRIN_ALT "\xef\x96\x81"	// U+f581
#define ICON_FA_GRIN_BEAM "\xef\x96\x82"	// U+f582
#define ICON_FA_GRIN_BEAM_SWEAT "\xef\x96\x83"	// U+f583
#define ICON_FA_GRIN_HEARTS "\xef\x96\x84"	// U+f584
#define ICON_FA_GRIN_SQUINT "\xef\x96\x85"	// U+f585
#define ICON_FA_GRIN_SQUINT_TEARS "\xef\x96\x86"	// U+f586
#define ICON_FA_GRIN_STARS "\xef\x96\x87"	// U+f587
#define ICON_FA_GRIN_TEARS "\xef\x96\x88"	// U+f588
#define ICON_FA_GRIN_TONGUE "\xef\x96\x89"	// U+f589
#define ICON_FA_GRIN_TONGUE_SQUINT "\xef\x96\x8a"	// U+f58a
#define ICON_FA_GRIN_TONGUE_WINK "\xef\x96\x8b"	// U+f58b
#define ICON_FA_GRIN_WINK "\xef\x96\x8c"	// U+f58c
#define ICON_FA_GRIP_HORIZONTAL "\xef\x96\x8d"	// U+f58d
#define ICON_FA_GRIP_LINES "\xef\x9e\xa4"	// U+f7a4
#define ICON_FA_GRIP_LINES_VERTICAL "\xef\x9e\xa5"	// U+f7a5
#define ICON_FA_GRIP_VERTICAL "\xef\x96\x8e"	// U+f58e
#define ICON_FA_GUITAR "\xef\x9e\xa6"	// U+f7a6
#define ICON_FA_H_SQUARE "\xef\x83\xbd"	// U+f0fd
#define ICON_FA_HAMBURGER "\xef\xa0\x85"	// U+f805
#define ICON_FA_HAMMER "\xef\x9b\xa3"	// U+f6e3
#define ICON_FA_HAMSA "\xef\x99\xa5"	// U+f665
#define ICON_FA_HAND_HOLDING "\xef\x92\xbd"	// U+f4bd
#define ICON_FA_HAND_HOLDING_HEART "\xef\x92\xbe"	// U+f4be
#define ICON_FA_HAND_HOLDING_MEDICAL "\xee\x81\x9c"	// U+e05c
#define ICON_FA_HAND_HOLDING_USD "\xef\x93\x80"	// U+f4c0
#define ICON_FA_HAND_HOLDING_WATER "\xef\x93\x81"	// U+f4c1
#define ICON_FA_HAND_LIZARD "\xef\x89\x98"	// U+f258
#define ICON_FA_HAND_MIDDLE_FINGER "\xef\xa0\x86"	// U+f806
#define ICON_FA_HAND_PAPER "\xef\x89\x96"	// U+f256
#define ICON_FA_HAND_PEACE "\xef\x89\x9b"	// U+f25b
#define ICON_FA_HAND_POINT_DOWN "\xef\x82\xa7"	// U+f0a7
#define ICON_FA_HAND_POINT_LEFT "\xef\x82\xa5"	// U+f0a5
#define ICON_FA_HAND_POINT_RIGHT "\xef\x82\xa4"	// U+f0a4
#define ICON_FA_HAND_POINT_UP "\xef\x82\xa6"	// U+f0a6
#define ICON_FA_HAND_POINTER "\xef\x89\x9a"	// U+f25a
#define ICON_FA_HAND_ROCK "\xef\x89\x95"	// U+f255
#define ICON_FA_HAND_SCISSORS "\xef\x89\x97"	// U+f257
#define ICON_FA_HAND_SPARKLES "\xee\x81\x9d"	// U+e05d
#define ICON_FA_HAND_SPOCK "\xef\x89\x99"	// U+f259
#define ICON_FA_HANDS "\xef\x93\x82"	// U+f4c2
#define ICON_FA_HANDS_HELPING "\xef\x93\x84"	// U+f4c4
#define ICON_FA_HANDS_WASH "\xee\x81\x9e"	// U+e05e
#define ICON_FA_HANDSHAKE "\xef\x8a\xb5"	// U+f2b5
#define ICON_FA_HANDSHAKE_ALT_SLASH "\xee\x81\x9f"	// U+e05f
#define ICON_FA_HANDSHAKE_SLASH "\xee\x81\xa0"	// U+e060
#define ICON_FA_HANUKIAH "\xef\x9b\xa6"	// U+f6e6
#define ICON_FA_HARD_HAT "\xef\xa0\x87"	// U+f807
#define ICON_FA_HASHTAG "\xef\x8a\x92"	// U+f292
#define ICON_FA_HAT_COWBOY "\xef\xa3\x80"	// U+f8c0
#define ICON_FA_HAT_COWBOY_SIDE "\xef\xa3\x81"	// U+f8c1
#define ICON_FA_HAT_WIZARD "\xef\x9b\xa8"	// U+f6e8
#define ICON_FA_HDD "\xef\x82\xa0"	// U+f0a0
#define ICON_FA_HEAD_SIDE_COUGH "\xee\x81\xa1"	// U+e061
#define ICON_FA_HEAD_SIDE_COUGH_SLASH "\xee\x81\xa2"	// U+e062
#define ICON_FA_HEAD_SIDE_MASK "\xee\x81\xa3"	// U+e063
#define ICON_FA_HEAD_SIDE_VIRUS "\xee\x81\xa4"	// U+e064
#define ICON_FA_HEADING "\xef\x87\x9c"	// U+f1dc
#define ICON_FA_HEADPHONES "\xef\x80\xa5"	// U+f025
#define ICON_FA_HEADPHONES_ALT "\xef\x96\x8f"	// U+f58f
#define ICON_FA_HEADSET "\xef\x96\x90"	// U+f590
#define ICON_FA_HEART "\xef\x80\x84"	// U+f004
#define ICON_FA_HEART_BROKEN "\xef\x9e\xa9"	// U+f7a9
#define ICON_FA_HEARTBEAT "\xef\x88\x9e"	// U+f21e
#define ICON_FA_HELICOPTER "\xef\x94\xb3"	// U+f533
#define ICON_FA_HIGHLIGHTER "\xef\x96\x91"	// U+f591
#define ICON_FA_HIKING "\xef\x9b\xac"	// U+f6ec
#define ICON_FA_HIPPO "\xef\x9b\xad"	// U+f6ed
#define ICON_FA_HISTORY "\xef\x87\x9a"	// U+f1da
#define ICON_FA_HOCKEY_PUCK "\xef\x91\x93"	// U+f453
#define ICON_FA_HOLLY_BERRY "\xef\x9e\xaa"	// U+f7aa
#define ICON_FA_HOME "\xef\x80\x95"	// U+f015
#define ICON_FA_HORSE "\xef\x9b\xb0"	// U+f6f0
#define ICON_FA_HORSE_HEAD "\xef\x9e\xab"	// U+f7ab
#define ICON_FA_HOSPITAL "\xef\x83\xb8"	// U+f0f8
#define ICON_FA_HOSPITAL_ALT "\xef\x91\xbd"	// U+f47d
#define ICON_FA_HOSPITAL_SYMBOL "\xef\x91\xbe"	// U+f47e
#define ICON_FA_HOSPITAL_USER "\xef\xa0\x8d"	// U+f80d
#define ICON_FA_HOT_TUB "\xef\x96\x93"	// U+f593
#define ICON_FA_HOTDOG "\xef\xa0\x8f"	// U+f80f
#define ICON_FA_HOTEL "\xef\x96\x94"	// U+f594
#define ICON_FA_HOURGLASS "\xef\x89\x94"	// U+f254
#define ICON_FA_HOURGLASS_END "\xef\x89\x93"	// U+f253
#define ICON_FA_HOURGLASS_HALF "\xef\x89\x92"	// U+f252
#define ICON_FA_HOURGLASS_START "\xef\x89\x91"	// U+f251
#define ICON_FA_HOUSE_DAMAGE "\xef\x9b\xb1"	// U+f6f1
#define ICON_FA_HOUSE_USER "\xee\x81\xa5"	// U+e065
#define ICON_FA_HRYVNIA "\xef\x9b\xb2"	// U+f6f2
#define ICON_FA_I_CURSOR "\xef\x89\x86"	// U+f246
#define ICON_FA_ICE_CREAM "\xef\xa0\x90"	// U+f810
#define ICON_FA_ICICLES "\xef\x9e\xad"	// U+f7ad
#define ICON_FA_ICONS "\xef\xa1\xad"	// U+f86d
#define ICON_FA_ID_BADGE "\xef\x8b\x81"	// U+f2c1
#define ICON_FA_ID_CARD "\xef\x8b\x82"	// U+f2c2
#define ICON_FA_ID_CARD_ALT "\xef\x91\xbf"	// U+f47f
#define ICON_FA_IGLOO "\xef\x9e\xae"	// U+f7ae
#define ICON_FA_IMAGE "\xef\x80\xbe"	// U+f03e
#define ICON_FA_IMAGES "\xef\x8c\x82"	// U+f302
#define ICON_FA_INBOX "\xef\x80\x9c"	// U+f01c
#define ICON_FA_INDENT "\xef\x80\xbc"	// U+f03c
#define ICON_FA_INDUSTRY "\xef\x89\xb5"	// U+f275
#define ICON_FA_INFINITY "\xef\x94\xb4"	// U+f534
#define ICON_FA_INFO "\xef\x84\xa9"	// U+f129
#define ICON_FA_INFO_CIRCLE "\xef\x81\x9a"	// U+f05a
#define ICON_FA_ITALIC "\xef\x80\xb3"	// U+f033
#define ICON_FA_JEDI "\xef\x99\xa9"	// U+f669
#define ICON_FA_JOINT "\xef\x96\x95"	// U+f595
#define ICON_FA_JOURNAL_WHILLS "\xef\x99\xaa"	// U+f66a
#define ICON_FA_KAABA "\xef\x99\xab"	// U+f66b
#define ICON_FA_KEY "\xef\x82\x84"	// U+f084
#define ICON_FA_KEYBOARD "\xef\x84\x9c"	// U+f11c
#define ICON_FA_KHANDA "\xef\x99\xad"	// U+f66d
#define ICON_FA_KISS "\xef\x96\x96"	// U+f596
#define ICON_FA_KISS_BEAM "\xef\x96\x97"	// U+f597
#define ICON_FA_KISS_WINK_HEART "\xef\x96\x98"	// U+f598
#define ICON_FA_KIWI_BIRD "\xef\x94\xb5"	// U+f535
#define ICON_FA_LANDMARK "\xef\x99\xaf"	// U+f66f
#define ICON_FA_LANGUAGE "\xef\x86\xab"	// U+f1ab
#define ICON_FA_LAPTOP "\xef\x84\x89"	// U+f109
#define ICON_FA_LAPTOP_CODE "\xef\x97\xbc"	// U+f5fc
#define ICON_FA_LAPTOP_HOUSE "\xee\x81\xa6"	// U+e066
#define ICON_FA_LAPTOP_MEDICAL "\xef\xa0\x92"	// U+f812
#define ICON_FA_LAUGH "\xef\x96\x99"	// U+f599
#define ICON_FA_LAUGH_BEAM "\xef\x96\x9a"	// U+f59a
#define ICON_FA_LAUGH_SQUINT "\xef\x96\x9b"	// U+f59b
#define ICON_FA_LAUGH_WINK "\xef\x96\x9c"	// U+f59c
#define ICON_FA_LAYER_GROUP "\xef\x97\xbd"	// U+f5fd
#define ICON_FA_LEAF "\xef\x81\xac"	// U+f06c
#define ICON_FA_LEMON "\xef\x82\x94"	// U+f094
#define ICON_FA_LESS_THAN "\xef\x94\xb6"	// U+f536
#define ICON_FA_LESS_THAN_EQUAL "\xef\x94\xb7"	// U+f537
#define ICON_FA_LEVEL_DOWN_ALT "\xef\x8e\xbe"	// U+f3be
#define ICON_FA_LEVEL_UP_ALT "\xef\x8e\xbf"	// U+f3bf
#define ICON_FA_LIFE_RING "\xef\x87\x8d"	// U+f1cd
#define ICON_FA_LIGHTBULB "\xef\x83\xab"	// U+f0eb
#define ICON_FA_LINK "\xef\x83\x81"	// U+f0c1
#define ICON_FA_LIRA_SIGN "\xef\x86\x95"	// U+f195
#define ICON_FA_LIST "\xef\x80\xba"	// U+f03a
#define ICON_FA_LIST_ALT "\xef\x80\xa2"	// U+f022
#define ICON_FA_LIST_OL "\xef\x83\x8b"	// U+f0cb
#define ICON_FA_LIST_UL "\xef\x83\x8a"	// U+f0ca
#define ICON_FA_LOCATION_ARROW "\xef\x84\xa4"	// U+f124
#define ICON_FA_LOCK "\xef\x80\xa3"	// U+f023
#define ICON_FA_LOCK_OPEN "\xef\x8f\x81"	// U+f3c1
#define ICON_FA_LONG_ARROW_ALT_DOWN "\xef\x8c\x89"	// U+f309
#define ICON_FA_LONG_ARROW_ALT_LEFT "\xef\x8c\x8a"	// U+f30a
#define ICON_FA_LONG_ARROW_ALT_RIGHT "\xef\x8c\x8b"	// U+f30b
#define ICON_FA_LONG_ARROW_ALT_UP "\xef\x8c\x8c"	// U+f30c
#define ICON_FA_LOW_VISION "\xef\x8a\xa8"	// U+f2a8
#define ICON_FA_LUGGAGE_CART "\xef\x96\x9d"	// U+f59d
#define ICON_FA_LUNGS "\xef\x98\x84"	// U+f604
#define ICON_FA_LUNGS_VIRUS "\xee\x81\xa7"	// U+e067
#define ICON_FA_MAGIC "\xef\x83\x90"	// U+f0d0
#define ICON_FA_MAGNET "\xef\x81\xb6"	// U+f076
#define ICON_FA_MAIL_BULK "\xef\x99\xb4"	// U+f674
#define ICON_FA_MALE "\xef\x86\x83"	// U+f183
#define ICON_FA_MAP "\xef\x89\xb9"	// U+f279
#define ICON_FA_MAP_MARKED "\xef\x96\x9f"	// U+f59f
#define ICON_FA_MAP_MARKED_ALT "\xef\x96\xa0"	// U+f5a0
#define ICON_FA_MAP_MARKER "\xef\x81\x81"	// U+f041
#define ICON_FA_MAP_MARKER_ALT "\xef\x8f\x85"	// U+f3c5
#define ICON_FA_MAP_PIN "\xef\x89\xb6"	// U+f276
#define ICON_FA_MAP_SIGNS "\xef\x89\xb7"	// U+f277
#define ICON_FA_MARKER "\xef\x96\xa1"	// U+f5a1
#define ICON_FA_MARS "\xef\x88\xa2"	// U+f222
#define ICON_FA_MARS_DOUBLE "\xef\x88\xa7"	// U+f227
#define ICON_FA_MARS_STROKE "\xef\x88\xa9"	// U+f229
#define ICON_FA_MARS_STROKE_H "\xef\x88\xab"	// U+f22b
#define ICON_FA_MARS_STROKE_V "\xef\x88\xaa"	// U+f22a
#define ICON_FA_MASK "\xef\x9b\xba"	// U+f6fa
#define ICON_FA_MEDAL "\xef\x96\xa2"	// U+f5a2
#define ICON_FA_MEDKIT "\xef\x83\xba"	// U+f0fa
#define ICON_FA_MEH "\xef\x84\x9a"	// U+f11a
#define ICON_FA_MEH_BLANK "\xef\x96\xa4"	// U+f5a4
#define ICON_FA_MEH_ROLLING_EYES "\xef\x96\xa5"	// U+f5a5
#define ICON_FA_MEMORY "\xef\x94\xb8"	// U+f538
#define ICON_FA_MENORAH "\xef\x99\xb6"	// U+f676
#define ICON_FA_MERCURY "\xef\x88\xa3"	// U+f223
#define ICON_FA_METEOR "\xef\x9d\x93"	// U+f753
#define ICON_FA_MICROCHIP "\xef\x8b\x9b"	// U+f2db
#define ICON_FA_MICROPHONE "\xef\x84\xb0"	// U+f130
#define ICON_FA_MICROPHONE_ALT "\xef\x8f\x89"	// U+f3c9
#define ICON_FA_MICROPHONE_ALT_SLASH "\xef\x94\xb9"	// U+f539
#define ICON_FA_MICROPHONE_SLASH "\xef\x84\xb1"	// U+f131
#define ICON_FA_MICROSCOPE "\xef\x98\x90"	// U+f610
#define ICON_FA_MINUS "\xef\x81\xa8"	// U+f068
#define ICON_FA_MINUS_CIRCLE "\xef\x81\x96"	// U+f056
#define ICON_FA_MINUS_SQUARE "\xef\x85\x86"	// U+f146
#define ICON_FA_MITTEN "\xef\x9e\xb5"	// U+f7b5
#define ICON_FA_MOBILE "\xef\x84\x8b"	// U+f10b
#define ICON_FA_MOBILE_ALT "\xef\x8f\x8d"	// U+f3cd
#define ICON_FA_MONEY_BILL "\xef\x83\x96"	// U+f0d6
#define ICON_FA_MONEY_BILL_ALT "\xef\x8f\x91"	// U+f3d1
#define ICON_FA_MONEY_BILL_WAVE "\xef\x94\xba"	// U+f53a
#define ICON_FA_MONEY_BILL_WAVE_ALT "\xef\x94\xbb"	// U+f53b
#define ICON_FA_MONEY_CHECK "\xef\x94\xbc"	// U+f53c
#define ICON_FA_MONEY_CHECK_ALT "\xef\x94\xbd"	// U+f53d
#define ICON_FA_MONUMENT "\xef\x96\xa6"	// U+f5a6
#define ICON_FA_MOON "\xef\x86\x86"	// U+f186
#define ICON_FA_MORTAR_PESTLE "\xef\x96\xa7"	// U+f5a7
#define ICON_FA_MOSQUE "\xef\x99\xb8"	// U+f678
#define ICON_FA_MOTORCYCLE "\xef\x88\x9c"	// U+f21c
#define ICON_FA_MOUNTAIN "\xef\x9b\xbc"	// U+f6fc
#define ICON_FA_MOUSE "\xef\xa3\x8c"	// U+f8cc
#define ICON_FA_MOUSE_POINTER "\xef\x89\x85"	// U+f245
#define ICON_FA_MUG_HOT "\xef\x9e\xb6"	// U+f7b6
#define ICON_FA_MUSIC "\xef\x80\x81"	// U+f001
#define ICON_FA_NETWORK_WIRED "\xef\x9b\xbf"	// U+f6ff
#define ICON_FA_NEUTER "\xef\x88\xac"	// U+f22c
#define ICON_FA_NEWSPAPER "\xef\x87\xaa"	// U+f1ea
#define ICON_FA_NOT_EQUAL "\xef\x94\xbe"	// U+f53e
#define ICON_FA_NOTES_MEDICAL "\xef\x92\x81"	// U+f481
#define ICON_FA_OBJECT_GROUP "\xef\x89\x87"	// U+f247
#define ICON_FA_OBJECT_UNGROUP "\xef\x89\x88"	// U+f248
#define ICON_FA_OIL_CAN "\xef\x98\x93"	// U+f613
#define ICON_FA_OM "\xef\x99\xb9"	// U+f679
#define ICON_FA_OTTER "\xef\x9c\x80"	// U+f700
#define ICON_FA_OUTDENT "\xef\x80\xbb"	// U+f03b
#define ICON_FA_PAGER "\xef\xa0\x95"	// U+f815
#define ICON_FA_PAINT_BRUSH "\xef\x87\xbc"	// U+f1fc
#define ICON_FA_PAINT_ROLLER "\xef\x96\xaa"	// U+f5aa
#define ICON_FA_PALETTE "\xef\x94\xbf"	// U+f53f
#define ICON_FA_PALLET "\xef\x92\x82"	// U+f482
#define ICON_FA_PAPER_PLANE "\xef\x87\x98"	// U+f1d8
#define ICON_FA_PAPERCLIP "\xef\x83\x86"	// U+f0c6
#define ICON_FA_PARACHUTE_BOX "\xef\x93\x8d"	// U+f4cd
#define ICON_FA_PARAGRAPH "\xef\x87\x9d"	// U+f1dd
#define ICON_FA_PARKING "\xef\x95\x80"	// U+f540
#define ICON_FA_PASSPORT "\xef\x96\xab"	// U+f5ab
#define ICON_FA_PASTAFARIANISM "\xef\x99\xbb"	// U+f67b
#define ICON_FA_PASTE "\xef\x83\xaa"	// U+f0ea
#define ICON_FA_PAUSE "\xef\x81\x8c"	// U+f04c
#define ICON_FA_PAUSE_CIRCLE "\xef\x8a\x8b"	// U+f28b
#define ICON_FA_PAW "\xef\x86\xb0"	// U+f1b0
#define ICON_FA_PEACE "\xef\x99\xbc"	// U+f67c
#define ICON_FA_PEN "\xef\x8c\x84"	// U+f304
#define ICON_FA_PEN_ALT "\xef\x8c\x85"	// U+f305
#define ICON_FA_PEN_FANCY "\xef\x96\xac"	// U+f5ac
#define ICON_FA_PEN_NIB "\xef\x96\xad"	// U+f5ad
#define ICON_FA_PEN_SQUARE "\xef\x85\x8b"	// U+f14b
#define ICON_FA_PENCIL_ALT "\xef\x8c\x83"	// U+f303
#define ICON_FA_PENCIL_RULER "\xef\x96\xae"	// U+f5ae
#define ICON_FA_PEOPLE_ARROWS "\xee\x81\xa8"	// U+e068
#define ICON_FA_PEOPLE_CARRY "\xef\x93\x8e"	// U+f4ce
#define ICON_FA_PEPPER_HOT "\xef\xa0\x96"	// U+f816
#define ICON_FA_PERCENT "\xef\x8a\x95"	// U+f295
#define ICON_FA_PERCENTAGE "\xef\x95\x81"	// U+f541
#define ICON_FA_PERSON_BOOTH "\xef\x9d\x96"	// U+f756
#define ICON_FA_PHONE "\xef\x82\x95"	// U+f095
#define ICON_FA_PHONE_ALT "\xef\xa1\xb9"	// U+f879
#define ICON_FA_PHONE_SLASH "\xef\x8f\x9d"	// U+f3dd
#define ICON_FA_PHONE_SQUARE "\xef\x82\x98"	// U+f098
#define ICON_FA_PHONE_SQUARE_ALT "\xef\xa1\xbb"	// U+f87b
#define ICON_FA_PHONE_VOLUME "\xef\x8a\xa0"	// U+f2a0
#define ICON_FA_PHOTO_VIDEO "\xef\xa1\xbc"	// U+f87c
#define ICON_FA_PIGGY_BANK "\xef\x93\x93"	// U+f4d3
#define ICON_FA_PILLS "\xef\x92\x84"	// U+f484
#define ICON_FA_PIZZA_SLICE "\xef\xa0\x98"	// U+f818
#define ICON_FA_PLACE_OF_WORSHIP "\xef\x99\xbf"	// U+f67f
#define ICON_FA_PLANE "\xef\x81\xb2"	// U+f072
#define ICON_FA_PLANE_ARRIVAL "\xef\x96\xaf"	// U+f5af
#define ICON_FA_PLANE_DEPARTURE "\xef\x96\xb0"	// U+f5b0
#define ICON_FA_PLANE_SLASH "\xee\x81\xa9"	// U+e069
#define ICON_FA_PLAY "\xef\x81\x8b"	// U+f04b
#define ICON_FA_PLAY_CIRCLE "\xef\x85\x84"	// U+f144
#define ICON_FA_PLUG "\xef\x87\xa6"	// U+f1e6
#define ICON_FA_PLUS "\xef\x81\xa7"	// U+f067
#define ICON_FA_PLUS_CIRCLE "\xef\x81\x95"	// U+f055
#define ICON_FA_PLUS_SQUARE "\xef\x83\xbe"	// U+f0fe
#define ICON_FA_PODCAST "\xef\x8b\x8e"	// U+f2ce
#define ICON_FA_POLL "\xef\x9a\x81"	// U+f681
#define ICON_FA_POLL_H "\xef\x9a\x82"	// U+f682
#define ICON_FA_POO "\xef\x8b\xbe"	// U+f2fe
#define ICON_FA_POO_STORM "\xef\x9d\x9a"	// U+f75a
#define ICON_FA_POOP "\xef\x98\x99"	// U+f619
#define ICON_FA_PORTRAIT "\xef\x8f\xa0"	// U+f3e0
#define ICON_FA_POUND_SIGN "\xef\x85\x94"	// U+f154
#define ICON_FA_POWER_OFF "\xef\x80\x91"	// U+f011
#define ICON_FA_PRAY "\xef\x9a\x83"	// U+f683
#define ICON_FA_PRAYING_HANDS "\xef\x9a\x84"	// U+f684
#define ICON_FA_PRESCRIPTION "\xef\x96\xb1"	// U+f5b1
#define ICON_FA_PRESCRIPTION_BOTTLE "\xef\x92\x85"	// U+f485
#define ICON_FA_PRESCRIPTION_BOTTLE_ALT "\xef\x92\x86"	// U+f486
#define ICON_FA_PRINT "\xef\x80\xaf"	// U+f02f
#define ICON_FA_PROCEDURES "\xef\x92\x87"	// U+f487
#define ICON_FA_PROJECT_DIAGRAM "\xef\x95\x82"	// U+f542
#define ICON_FA_PUMP_MEDICAL "\xee\x81\xaa"	// U+e06a
#define ICON_FA_PUMP_SOAP "\xee\x81\xab"	// U+e06b
#define ICON_FA_PUZZLE_PIECE "\xef\x84\xae"	// U+f12e
#define ICON_FA_QRCODE "\xef\x80\xa9"	// U+f029
#define ICON_FA_QUESTION "\xef\x84\xa8"	// U+f128
#define ICON_FA_QUESTION_CIRCLE "\xef\x81\x99"	// U+f059
#define ICON_FA_QUIDDITCH "\xef\x91\x98"	// U+f458
#define ICON_FA_QUOTE_LEFT "\xef\x84\x8d"	// U+f10d
#define ICON_FA_QUOTE_RIGHT "\xef\x84\x8e"	// U+f10e
#define ICON_FA_QURAN "\xef\x9a\x87"	// U+f687
#define ICON_FA_RADIATION "\xef\x9e\xb9"	// U+f7b9
#define ICON_FA_RADIATION_ALT "\xef\x9e\xba"	// U+f7ba
#define ICON_FA_RAINBOW "\xef\x9d\x9b"	// U+f75b
#define ICON_FA_RANDOM "\xef\x81\xb4"	// U+f074
#define ICON_FA_RECEIPT "\xef\x95\x83"	// U+f543
#define ICON_FA_RECORD_VINYL "\xef\xa3\x99"	// U+f8d9
#define ICON_FA_RECYCLE "\xef\x86\xb8"	// U+f1b8
#define ICON_FA_REDO "\xef\x80\x9e"	// U+f01e
#define ICON_FA_REDO_ALT "\xef\x8b\xb9"	// U+f2f9
#define ICON_FA_REGISTERED "\xef\x89\x9d"	// U+f25d
#define ICON_FA_REMOVE_FORMAT "\xef\xa1\xbd"	// U+f87d
#define ICON_FA_REPLY "\xef\x8f\xa5"	// U+f3e5
#define ICON_FA_REPLY_ALL "\xef\x84\xa2"	// U+f122
#define ICON_FA_REPUBLICAN "\xef\x9d\x9e"	// U+f75e
#define ICON_FA_RESTROOM "\xef\x9e\xbd"	// U+f7bd
#define ICON_FA_RETWEET "\xef\x81\xb9"	// U+f079
#define ICON_FA_RIBBON "\xef\x93\x96"	// U+f4d6
#define ICON_FA_RING "\xef\x9c\x8b"	// U+f70b
#define ICON_FA_ROAD "\xef\x80\x98"	// U+f018
#define ICON_FA_ROBOT "\xef\x95\x84"	// U+f544
#define ICON_FA_ROCKET "\xef\x84\xb5"	// U+f135
#define ICON_FA_ROUTE "\xef\x93\x97"	// U+f4d7
#define ICON_FA_RSS "\xef\x82\x9e"	// U+f09e
#define ICON_FA_RSS_SQUARE "\xef\x85\x83"	// U+f143
#define ICON_FA_RUBLE_SIGN "\xef\x85\x98"	// U+f158
#define ICON_FA_RULER "\xef\x95\x85"	// U+f545
#define ICON_FA_RULER_COMBINED "\xef\x95\x86"	// U+f546
#define ICON_FA_RULER_HORIZONTAL "\xef\x95\x87"	// U+f547
#define ICON_FA_RULER_VERTICAL "\xef\x95\x88"	// U+f548
#define ICON_FA_RUNNING "\xef\x9c\x8c"	// U+f70c
#define ICON_FA_RUPEE_SIGN "\xef\x85\x96"	// U+f156
#define ICON_FA_SAD_CRY "\xef\x96\xb3"	// U+f5b3
#define ICON_FA_SAD_TEAR "\xef\x96\xb4"	// U+f5b4
#define ICON_FA_SATELLITE "\xef\x9e\xbf"	// U+f7bf
#define ICON_FA_SATELLITE_DISH "\xef\x9f\x80"	// U+f7c0
#define ICON_FA_SAVE "\xef\x83\x87"	// U+f0c7
#define ICON_FA_SCHOOL "\xef\x95\x89"	// U+f549
#define ICON_FA_SCREWDRIVER "\xef\x95\x8a"	// U+f54a
#define ICON_FA_SCROLL "\xef\x9c\x8e"	// U+f70e
#define ICON_FA_SD_CARD "\xef\x9f\x82"	// U+f7c2
#define ICON_FA_SEARCH "\xef\x80\x82"	// U+f002
#define ICON_FA_SEARCH_DOLLAR "\xef\x9a\x88"	// U+f688
#define ICON_FA_SEARCH_LOCATION "\xef\x9a\x89"	// U+f689
#define ICON_FA_SEARCH_MINUS "\xef\x80\x90"	// U+f010
#define ICON_FA_SEARCH_PLUS "\xef\x80\x8e"	// U+f00e
#define ICON_FA_SEEDLING "\xef\x93\x98"	// U+f4d8
#define ICON_FA_SERVER "\xef\x88\xb3"	// U+f233
#define ICON_FA_SHAPES "\xef\x98\x9f"	// U+f61f
#define ICON_FA_SHARE "\xef\x81\xa4"	// U+f064
#define ICON_FA_SHARE_ALT "\xef\x87\xa0"	// U+f1e0
#define ICON_FA_SHARE_ALT_SQUARE "\xef\x87\xa1"	// U+f1e1
#define ICON_FA_SHARE_SQUARE "\xef\x85\x8d"	// U+f14d
#define ICON_FA_SHEKEL_SIGN "\xef\x88\x8b"	// U+f20b
#define ICON_FA_SHIELD_ALT "\xef\x8f\xad"	// U+f3ed
#define ICON_FA_SHIELD_VIRUS "\xee\x81\xac"	// U+e06c
#define ICON_FA_SHIP "\xef\x88\x9a"	// U+f21a
#define ICON_FA_SHIPPING_FAST "\xef\x92\x8b"	// U+f48b
#define ICON_FA_SHOE_PRINTS "\xef\x95\x8b"	// U+f54b
#define ICON_FA_SHOPPING_BAG "\xef\x8a\x90"	// U+f290
#define ICON_FA_SHOPPING_BASKET "\xef\x8a\x91"	// U+f291
#define ICON_FA_SHOPPING_CART "\xef\x81\xba"	// U+f07a
#define ICON_FA_SHOWER "\xef\x8b\x8c"	// U+f2cc
#define ICON_FA_SHUTTLE_VAN "\xef\x96\xb6"	// U+f5b6
#define ICON_FA_SIGN "\xef\x93\x99"	// U+f4d9
#define ICON_FA_SIGN_IN_ALT "\xef\x8b\xb6"	// U+f2f6
#define ICON_FA_SIGN_LANGUAGE "\xef\x8a\xa7"	// U+f2a7
#define ICON_FA_SIGN_OUT_ALT "\xef\x8b\xb5"	// U+f2f5
#define ICON_FA_SIGNAL "\xef\x80\x92"	// U+f012
#define ICON_FA_SIGNATURE "\xef\x96\xb7"	// U+f5b7
#define ICON_FA_SIM_CARD "\xef\x9f\x84"	// U+f7c4
#define ICON_FA_SINK "\xee\x81\xad"	// U+e06d
#define ICON_FA_SITEMAP "\xef\x83\xa8"	// U+f0e8
#define ICON_FA_SKATING "\xef\x9f\x85"	// U+f7c5
#define ICON_FA_SKIING "\xef\x9f\x89"	// U+f7c9
#define ICON_FA_SKIING_NORDIC "\xef\x9f\x8a"	// U+f7ca
#define ICON_FA_SKULL "\xef\x95\x8c"	// U+f54c
#define ICON_FA_SKULL_CROSSBONES "\xef\x9c\x94"	// U+f714
#define ICON_FA_SLASH "\xef\x9c\x95"	// U+f715
#define ICON_FA_SLEIGH "\xef\x9f\x8c"	// U+f7cc
#define ICON_FA_SLIDERS_H "\xef\x87\x9e"	// U+f1de
#define ICON_FA_SMILE "\xef\x84\x98"	// U+f118
#define ICON_FA_SMILE_BEAM "\xef\x96\xb8"	// U+f5b8
#define ICON_FA_SMILE_WINK "\xef\x93\x9a"	// U+f4da
#define ICON_FA_SMOG "\xef\x9d\x9f"	// U+f75f
#define ICON_FA_SMOKING "\xef\x92\x8d"	// U+f48d
#define ICON_FA_SMOKING_BAN "\xef\x95\x8d"	// U+f54d
#define ICON_FA_SMS "\xef\x9f\x8d"	// U+f7cd
#define ICON_FA_SNOWBOARDING "\xef\x9f\x8e"	// U+f7ce
#define ICON_FA_SNOWFLAKE "\xef\x8b\x9c"	// U+f2dc
#define ICON_FA_SNOWMAN "\xef\x9f\x90"	// U+f7d0
#define ICON_FA_SNOWPLOW "\xef\x9f\x92"	// U+f7d2
#define ICON_FA_SOAP "\xee\x81\xae"	// U+e06e
#define ICON_FA_SOCKS "\xef\x9a\x96"	// U+f696
#define ICON_FA_SOLAR_PANEL "\xef\x96\xba"	// U+f5ba
#define ICON_FA_SORT "\xef\x83\x9c"	// U+f0dc
#define ICON_FA_SORT_ALPHA_DOWN "\xef\x85\x9d"	// U+f15d
#define ICON_FA_SORT_ALPHA_DOWN_ALT "\xef\xa2\x81"	// U+f881
#define ICON_FA_SORT_ALPHA_UP "\xef\x85\x9e"	// U+f15e
#define ICON_FA_SORT_ALPHA_UP_ALT "\xef\xa2\x82"	// U+f882
#define ICON_FA_SORT_AMOUNT_DOWN "\xef\x85\xa0"	// U+f160
#define ICON_FA_SORT_AMOUNT_DOWN_ALT "\xef\xa2\x84"	// U+f884
#define ICON_FA_SORT_AMOUNT_UP "\xef\x85\xa1"	// U+f161
#define ICON_FA_SORT_AMOUNT_UP_ALT "\xef\xa2\x85"	// U+f885
#define ICON_FA_SORT_DOWN "\xef\x83\x9d"	// U+f0dd
#define ICON_FA_SORT_NUMERIC_DOWN "\xef\x85\xa2"	// U+f162
#define ICON_FA_SORT_NUMERIC_DOWN_ALT "\xef\xa2\x86"	// U+f886
#define ICON_FA_SORT_NUMERIC_UP "\xef\x85\xa3"	// U+f163
#define ICON_FA_SORT_NUMERIC_UP_ALT "\xef\xa2\x87"	// U+f887
#define ICON_FA_SORT_UP "\xef\x83\x9e"	// U+f0de
#define ICON_FA_SPA "\xef\x96\xbb"	// U+f5bb
#define ICON_FA_SPACE_SHUTTLE "\xef\x86\x97"	// U+f197
#define ICON_FA_SPELL_CHECK "\xef\xa2\x91"	// U+f891
#define ICON_FA_SPIDER "\xef\x9c\x97"	// U+f717
#define ICON_FA_SPINNER "\xef\x84\x90"	// U+f110
#define ICON_FA_SPLOTCH "\xef\x96\xbc"	// U+f5bc
#define ICON_FA_SPRAY_CAN "\xef\x96\xbd"	// U+f5bd
#define ICON_FA_SQUARE "\xef\x83\x88"	// U+f0c8
#define ICON_FA_SQUARE_FULL "\xef\x91\x9c"	// U+f45c
#define ICON_FA_SQUARE_ROOT_ALT "\xef\x9a\x98"	// U+f698
#define ICON_FA_STAMP "\xef\x96\xbf"	// U+f5bf
#define ICON_FA_STAR "\xef\x80\x85"	// U+f005
#define ICON_FA_STAR_AND_CRESCENT "\xef\x9a\x99"	// U+f699
#define ICON_FA_STAR_HALF "\xef\x82\x89"	// U+f089
#define ICON_FA_STAR_HALF_ALT "\xef\x97\x80"	// U+f5c0
#define ICON_FA_STAR_OF_DAVID "\xef\x9a\x9a"	// U+f69a
#define ICON_FA_STAR_OF_LIFE "\xef\x98\xa1"	// U+f621
#define ICON_FA_STEP_BACKWARD "\xef\x81\x88"	// U+f048
#define ICON_FA_STEP_FORWARD "\xef\x81\x91"	// U+f051
#define ICON_FA_STETHOSCOPE "\xef\x83\xb1"	// U+f0f1
#define ICON_FA_STICKY_NOTE "\xef\x89\x89"	// U+f249
#define ICON_FA_STOP "\xef\x81\x8d"	// U+f04d
#define ICON_FA_STOP_CIRCLE "\xef\x8a\x8d"	// U+f28d
#define ICON_FA_STOPWATCH "\xef\x8b\xb2"	// U+f2f2
#define ICON_FA_STOPWATCH_20 "\xee\x81\xaf"	// U+e06f
#define ICON_FA_STORE "\xef\x95\x8e"	// U+f54e
#define ICON_FA_STORE_ALT "\xef\x95\x8f"	// U+f54f
#define ICON_FA_STORE_ALT_SLASH "\xee\x81\xb0"	// U+e070
#define ICON_FA_STORE_SLASH "\xee\x81\xb1"	// U+e071
#define ICON_FA_STREAM "\xef\x95\x90"	// U+f550
#define ICON_FA_STREET_VIEW "\xef\x88\x9d"	// U+f21d
#define ICON_FA_STRIKETHROUGH "\xef\x83\x8c"	// U+f0cc
#define ICON_FA_STROOPWAFEL "\xef\x95\x91"	// U+f551
#define ICON_FA_SUBSCRIPT "\xef\x84\xac"	// U+f12c
#define ICON_FA_SUBWAY "\xef\x88\xb9"	// U+f239
#define ICON_FA_SUITCASE "\xef\x83\xb2"	// U+f0f2
#define ICON_FA_SUITCASE_ROLLING "\xef\x97\x81"	// U+f5c1
#define ICON_FA_SUN "\xef\x86\x85"	// U+f185
#define ICON_FA_SUPERSCRIPT "\xef\x84\xab"	// U+f12b
#define ICON_FA_SURPRISE "\xef\x97\x82"	// U+f5c2
#define ICON_FA_SWATCHBOOK "\xef\x97\x83"	// U+f5c3
#define ICON_FA_SWIMMER "\xef\x97\x84"	// U+f5c4
#define ICON_FA_SWIMMING_POOL "\xef\x97\x85"	// U+f5c5
#define ICON_FA_SYNAGOGUE "\xef\x9a\x9b"	// U+f69b
#define ICON_FA_SYNC "\xef\x80\xa1"	// U+f021
#define ICON_FA_SYNC_ALT "\xef\x8b\xb1"	// U+f2f1
#define ICON_FA_SYRINGE "\xef\x92\x8e"	// U+f48e
#define ICON_FA_TABLE "\xef\x83\x8e"	// U+f0ce
#define ICON_FA_TABLE_TENNIS "\xef\x91\x9d"	// U+f45d
#define ICON_FA_TABLET "\xef\x84\x8a"	// U+f10a
#define ICON_FA_TABLET_ALT "\xef\x8f\xba"	// U+f3fa
#define ICON_FA_TABLETS "\xef\x92\x90"	// U+f490
#define ICON_FA_TACHOMETER_ALT "\xef\x8f\xbd"	// U+f3fd
#define ICON_FA_TAG "\xef\x80\xab"	// U+f02b
#define ICON_FA_TAGS "\xef\x80\xac"	// U+f02c
#define ICON_FA_TAPE "\xef\x93\x9b"	// U+f4db
#define ICON_FA_TASKS "\xef\x82\xae"	// U+f0ae
#define ICON_FA_TAXI "\xef\x86\xba"	// U+f1ba
#define ICON_FA_TEETH "\xef\x98\xae"	// U+f62e
#define ICON_FA_TEETH_OPEN "\xef\x98\xaf"	// U+f62f
#define ICON_FA_TEMPERATURE_HIGH "\xef\x9d\xa9"	// U+f769
#define ICON_FA_TEMPERATURE_LOW "\xef\x9d\xab"	// U+f76b
#define ICON_FA_TENGE "\xef\x9f\x97"	// U+f7d7
#define ICON_FA_TERMINAL "\xef\x84\xa0"	// U+f120
#define ICON_FA_TEXT_HEIGHT "\xef\x80\xb4"	// U+f034
#define ICON_FA_TEXT_WIDTH "\xef\x80\xb5"	// U+f035
#define ICON_FA_TH "\xef\x80\x8a"	// U+f00a
#define ICON_FA_TH_LARGE "\xef\x80\x89"	// U+f009
#define ICON_FA_TH_LIST "\xef\x80\x8b"	// U+f00b
#define ICON_FA_THEATER_MASKS "\xef\x98\xb0"	// U+f630
#define ICON_FA_THERMOMETER "\xef\x92\x91"	// U+f491
#define ICON_FA_THERMOMETER_EMPTY "\xef\x8b\x8b"	// U+f2cb
#define ICON_FA_THERMOMETER_FULL "\xef\x8b\x87"	// U+f2c7
#define ICON_FA_THERMOMETER_HALF "\xef\x8b\x89"	// U+f2c9
#define ICON_FA_THERMOMETER_QUARTER "\xef\x8b\x8a"	// U+f2ca
#define ICON_FA_THERMOMETER_THREE_QUARTERS "\xef\x8b\x88"	// U+f2c8
#define ICON_FA_THUMBS_DOWN "\xef\x85\xa5"	// U+f165
#define ICON_FA_THUMBS_UP "\xef\x85\xa4"	// U+f164
#define ICON_FA_THUMBTACK "\xef\x82\x8d"	// U+f08d
#define ICON_FA_TICKET_ALT "\xef\x8f\xbf"	// U+f3ff
#define ICON_FA_TIMES "\xef\x80\x8d"	// U+f00d
#define ICON_FA_TIMES_CIRCLE "\xef\x81\x97"	// U+f057
#define ICON_FA_TINT "\xef\x81\x83"	// U+f043
#define ICON_FA_TINT_SLASH "\xef\x97\x87"	// U+f5c7
#define ICON_FA_TIRED "\xef\x97\x88"	// U+f5c8
#define ICON_FA_TOGGLE_OFF "\xef\x88\x84"	// U+f204
#define ICON_FA_TOGGLE_ON "\xef\x88\x85"	// U+f205
#define ICON_FA_TOILET "\xef\x9f\x98"	// U+f7d8
#define ICON_FA_TOILET_PAPER "\xef\x9c\x9e"	// U+f71e
#define ICON_FA_TOILET_PAPER_SLASH "\xee\x81\xb2"	// U+e072
#define ICON_FA_TOOLBOX "\xef\x95\x92"	// U+f552
#define ICON_FA_TOOLS "\xef\x9f\x99"	// U+f7d9
#define ICON_FA_TOOTH "\xef\x97\x89"	// U+f5c9
#define ICON_FA_TORAH "\xef\x9a\xa0"	// U+f6a0
#define ICON_FA_TORII_GATE "\xef\x9a\xa1"	// U+f6a1
#define ICON_FA_TRACTOR "\xef\x9c\xa2"	// U+f722
#define ICON_FA_TRADEMARK "\xef\x89\x9c"	// U+f25c
#define ICON_FA_TRAFFIC_LIGHT "\xef\x98\xb7"	// U+f637
#define ICON_FA_TRAILER "\xee\x81\x81"	// U+e041
#define ICON_FA_TRAIN "\xef\x88\xb8"	// U+f238
#define ICON_FA_TRAM "\xef\x9f\x9a"	// U+f7da
#define ICON_FA_TRANSGENDER "\xef\x88\xa4"	// U+f224
#define ICON_FA_TRANSGENDER_ALT "\xef\x88\xa5"	// U+f225
#define ICON_FA_TRASH "\xef\x87\xb8"	// U+f1f8
#define ICON_FA_TRASH_ALT "\xef\x8b\xad"	// U+f2ed
#define ICON_FA_TRASH_RESTORE "\xef\xa0\xa9"	// U+f829
#define ICON_FA_TRASH_RESTORE_ALT "\xef\xa0\xaa"	// U+f82a
#define ICON_FA_TREE "\xef\x86\xbb"	// U+f1bb
#define ICON_FA_TROPHY "\xef\x82\x91"	// U+f091
#define ICON_FA_TRUCK "\xef\x83\x91"	// U+f0d1
#define ICON_FA_TRUCK_LOADING "\xef\x93\x9e"	// U+f4de
#define ICON_FA_TRUCK_MONSTER "\xef\x98\xbb"	// U+f63b
#define ICON_FA_TRUCK_MOVING "\xef\x93\x9f"	// U+f4df
#define ICON_FA_TRUCK_PICKUP "\xef\x98\xbc"	// U+f63c
#define ICON_FA_TSHIRT "\xef\x95\x93"	// U+f553
#define ICON_FA_TTY "\xef\x87\xa4"	// U+f1e4
#define ICON_FA_TV "\xef\x89\xac"	// U+f26c
#define ICON_FA_UMBRELLA "\xef\x83\xa9"	// U+f0e9
#define ICON_FA_UMBRELLA_BEACH "\xef\x97\x8a"	// U+f5ca
#define ICON_FA_UNDERLINE "\xef\x83\x8d"	// U+f0cd
#define ICON_FA_UNDO "\xef\x83\xa2"	// U+f0e2
#define ICON_FA_UNDO_ALT "\xef\x8b\xaa"	// U+f2ea
#define ICON_FA_UNIVERSAL_ACCESS "\xef\x8a\x9a"	// U+f29a
#define ICON_FA_UNIVERSITY "\xef\x86\x9c"	// U+f19c
#define ICON_FA_UNLINK "\xef\x84\xa7"	// U+f127
#define ICON_FA_UNLOCK "\xef\x82\x9c"	// U+f09c
#define ICON_FA_UNLOCK_ALT "\xef\x84\xbe"	// U+f13e
#define ICON_FA_UPLOAD "\xef\x82\x93"	// U+f093
#define ICON_FA_USER "\xef\x80\x87"	// U+f007
#define ICON_FA_USER_ALT "\xef\x90\x86"	// U+f406
#define ICON_FA_USER_ALT_SLASH "\xef\x93\xba"	// U+f4fa
#define ICON_FA_USER_ASTRONAUT "\xef\x93\xbb"	// U+f4fb
#define ICON_FA_USER_CHECK "\xef\x93\xbc"	// U+f4fc
#define ICON_FA_USER_CIRCLE "\xef\x8a\xbd"	// U+f2bd
#define ICON_FA_USER_CLOCK "\xef\x93\xbd"	// U+f4fd
#define ICON_FA_USER_COG "\xef\x93\xbe"	// U+f4fe
#define ICON_FA_USER_EDIT "\xef\x93\xbf"	// U+f4ff
#define ICON_FA_USER_FRIENDS "\xef\x94\x80"	// U+f500
#define ICON_FA_USER_GRADUATE "\xef\x94\x81"	// U+f501
#define ICON_FA_USER_INJURED "\xef\x9c\xa8"	// U+f728
#define ICON_FA_USER_LOCK "\xef\x94\x82"	// U+f502
#define ICON_FA_USER_MD "\xef\x83\xb0"	// U+f0f0
#define ICON_FA_USER_MINUS "\xef\x94\x83"	// U+f503
#define ICON_FA_USER_NINJA "\xef\x94\x84"	// U+f504
#define ICON_FA_USER_NURSE "\xef\xa0\xaf"	// U+f82f
#define ICON_FA_USER_PLUS "\xef\x88\xb4"	// U+f234
#define ICON_FA_USER_SECRET "\xef\x88\x9b"	// U+f21b
#define ICON_FA_USER_SHIELD "\xef\x94\x85"	// U+f505
#define ICON_FA_USER_SLASH "\xef\x94\x86"	// U+f506
#define ICON_FA_USER_TAG "\xef\x94\x87"	// U+f507
#define ICON_FA_USER_TIE "\xef\x94\x88"	// U+f508
#define ICON_FA_USER_TIMES "\xef\x88\xb5"	// U+f235
#define ICON_FA_USERS "\xef\x83\x80"	// U+f0c0
#define ICON_FA_USERS_COG "\xef\x94\x89"	// U+f509
#define ICON_FA_USERS_SLASH "\xee\x81\xb3"	// U+e073
#define ICON_FA_UTENSIL_SPOON "\xef\x8b\xa5"	// U+f2e5
#define ICON_FA_UTENSILS "\xef\x8b\xa7"	// U+f2e7
#define ICON_FA_VECTOR_SQUARE "\xef\x97\x8b"	// U+f5cb
#define ICON_FA_VENUS "\xef\x88\xa1"	// U+f221
#define ICON_FA_VENUS_DOUBLE "\xef\x88\xa6"	// U+f226
#define ICON_FA_VENUS_MARS "\xef\x88\xa8"	// U+f228
#define ICON_FA_VEST "\xee\x82\x85"	// U+e085
#define ICON_FA_VEST_PATCHES "\xee\x82\x86"	// U+e086
#define ICON_FA_VIAL "\xef\x92\x92"	// U+f492
#define ICON_FA_VIALS "\xef\x92\x93"	// U+f493
#define ICON_FA_VIDEO "\xef\x80\xbd"	// U+f03d
#define ICON_FA_VIDEO_SLASH "\xef\x93\xa2"	// U+f4e2
#define ICON_FA_VIHARA "\xef\x9a\xa7"	// U+f6a7
#define ICON_FA_VIRUS "\xee\x81\xb4"	// U+e074
#define ICON_FA_VIRUS_SLASH "\xee\x81\xb5"	// U+e075
#define ICON_FA_VIRUSES "\xee\x81\xb6"	// U+e076
#define ICON_FA_VOICEMAIL "\xef\xa2\x97"	// U+f897
#define ICON_FA_VOLLEYBALL_BALL "\xef\x91\x9f"	// U+f45f
#define ICON_FA_VOLUME_DOWN "\xef\x80\xa7"	// U+f027
#define ICON_FA_VOLUME_MUTE "\xef\x9a\xa9"	// U+f6a9
#define ICON_FA_VOLUME_OFF "\xef\x80\xa6"	// U+f026
#define ICON_FA_VOLUME_UP "\xef\x80\xa8"	// U+f028
#define ICON_FA_VOTE_YEA "\xef\x9d\xb2"	// U+f772
#define ICON_FA_VR_CARDBOARD "\xef\x9c\xa9"	// U+f729
#define ICON_FA_WALKING "\xef\x95\x94"	// U+f554
#define ICON_FA_WALLET "\xef\x95\x95"	// U+f555
#define ICON_FA_WAREHOUSE "\xef\x92\x94"	// U+f494
#define ICON_FA_WATER "\xef\x9d\xb3"	// U+f773
#define ICON_FA_WAVE_SQUARE "\xef\xa0\xbe"	// U+f83e
#define ICON_FA_WEIGHT "\xef\x92\x96"	// U+f496
#define ICON_FA_WEIGHT_HANGING "\xef\x97\x8d"	// U+f5cd
#define ICON_FA_WHEELCHAIR "\xef\x86\x93"	// U+f193
#define ICON_FA_WIFI "\xef\x87\xab"	// U+f1eb
#define ICON_FA_WIND "\xef\x9c\xae"	// U+f72e
#define ICON_FA_WINDOW_CLOSE "\xef\x90\x90"	// U+f410
#define ICON_FA_WINDOW_MAXIMIZE "\xef\x8b\x90"	// U+f2d0
#define ICON_FA_WINDOW_MINIMIZE "\xef\x8b\x91"	// U+f2d1
#define ICON_FA_WINDOW_RESTORE "\xef\x8b\x92"	// U+f2d2
#define ICON_FA_WINE_BOTTLE "\xef\x9c\xaf"	// U+f72f
#define ICON_FA_WINE_GLASS "\xef\x93\xa3"	// U+f4e3
#define ICON_FA_WINE_GLASS_ALT "\xef\x97\x8e"	// U+f5ce
#define ICON_FA_WON_SIGN "\xef\x85\x99"	// U+f159
#define ICON_FA_WRENCH "\xef\x82\xad"	// U+f0ad
#define ICON_FA_X_RAY "\xef\x92\x97"	// U+f497
#define ICON_FA_YEN_SIGN "\xef\x85\x97"	// U+f157
#define ICON_FA_YIN_YANG "\xef\x9a\xad"	// U+f6ad
```

`ext/fontawesome/licence.txt`:

```txt
Copyright (c) 2017 Juliette Foucaut and Doug Binks

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.

```

`ext/fontawesome/list.h`:

```h
#pragma once

#include "IconsFontAwesome5.h"

const char* awesomeIcons[] =
{
	ICON_FA_AD,
	ICON_FA_ADDRESS_BOOK,
	ICON_FA_ADDRESS_CARD,
	ICON_FA_ADJUST,
	ICON_FA_AIR_FRESHENER,
	ICON_FA_ALIGN_CENTER,
	ICON_FA_ALIGN_JUSTIFY,
	ICON_FA_ALIGN_LEFT,
	ICON_FA_ALIGN_RIGHT,
	ICON_FA_ALLERGIES,
	ICON_FA_AMBULANCE,
	ICON_FA_AMERICAN_SIGN_LANGUAGE_INTERPRETING,
	ICON_FA_ANCHOR,
	ICON_FA_ANGLE_DOUBLE_DOWN,
	ICON_FA_ANGLE_DOUBLE_LEFT,
	ICON_FA_ANGLE_DOUBLE_RIGHT,
	ICON_FA_ANGLE_DOUBLE_UP,
	ICON_FA_ANGLE_DOWN,
	ICON_FA_ANGLE_LEFT,
	ICON_FA_ANGLE_RIGHT,
	ICON_FA_ANGLE_UP,
	ICON_FA_ANGRY,
	ICON_FA_ANKH,
	ICON_FA_APPLE_ALT,
	ICON_FA_ARCHIVE,
	ICON_FA_ARCHWAY,
	ICON_FA_ARROW_ALT_CIRCLE_DOWN,
	ICON_FA_ARROW_ALT_CIRCLE_LEFT,
	ICON_FA_ARROW_ALT_CIRCLE_RIGHT,
	ICON_FA_ARROW_ALT_CIRCLE_UP,
	ICON_FA_ARROW_CIRCLE_DOWN,
	ICON_FA_ARROW_CIRCLE_LEFT,
	ICON_FA_ARROW_CIRCLE_RIGHT,
	ICON_FA_ARROW_CIRCLE_UP,
	ICON_FA_ARROW_DOWN,
	ICON_FA_ARROW_LEFT,
	ICON_FA_ARROW_RIGHT,
	ICON_FA_ARROW_UP,
	ICON_FA_ARROWS_ALT,
	ICON_FA_ARROWS_ALT_H,
	ICON_FA_ARROWS_ALT_V,
	ICON_FA_ASSISTIVE_LISTENING_SYSTEMS,
	ICON_FA_ASTERISK,
	ICON_FA_AT,
	ICON_FA_ATLAS,
	ICON_FA_ATOM,
	ICON_FA_AUDIO_DESCRIPTION,
	ICON_FA_AWARD,
	ICON_FA_BABY,
	ICON_FA_BABY_CARRIAGE,
	ICON_FA_BACKSPACE,
	ICON_FA_BACKWARD,
	ICON_FA_BACON,
	ICON_FA_BACTERIA,
	ICON_FA_BACTERIUM,
	ICON_FA_BAHAI,
	ICON_FA_BALANCE_SCALE,
	ICON_FA_BALANCE_SCALE_LEFT,
	ICON_FA_BALANCE_SCALE_RIGHT,
	ICON_FA_BAN,
	ICON_FA_BAND_AID,
	ICON_FA_BARCODE,
	ICON_FA_BARS,
	ICON_FA_BASEBALL_BALL,
	ICON_FA_BASKETBALL_BALL,
	ICON_FA_BATH,
	ICON_FA_BATTERY_EMPTY,
	ICON_FA_BATTERY_FULL,
	ICON_FA_BATTERY_HALF,
	ICON_FA_BATTERY_QUARTER,
	ICON_FA_BATTERY_THREE_QUARTERS,
	ICON_FA_BED,
	ICON_FA_BEER,
	ICON_FA_BELL,
	ICON_FA_BELL_SLASH,
	ICON_FA_BEZIER_CURVE,
	ICON_FA_BIBLE,
	ICON_FA_BICYCLE,
	ICON_FA_BIKING,
	ICON_FA_BINOCULARS,
	ICON_FA_BIOHAZARD,
	ICON_FA_BIRTHDAY_CAKE,
	ICON_FA_BLENDER,
	ICON_FA_BLENDER_PHONE,
	ICON_FA_BLIND,
	ICON_FA_BLOG,
	ICON_FA_BOLD,
	ICON_FA_BOLT,
	ICON_FA_BOMB,
	ICON_FA_BONE,
	ICON_FA_BONG,
	ICON_FA_BOOK,
	ICON_FA_BOOK_DEAD,
	ICON_FA_BOOK_MEDICAL,
	ICON_FA_BOOK_OPEN,
	ICON_FA_BOOK_READER,
	ICON_FA_BOOKMARK,
	ICON_FA_BORDER_ALL,
	ICON_FA_BORDER_NONE,
	ICON_FA_BORDER_STYLE,
	ICON_FA_BOWLING_BALL,
	ICON_FA_BOX,
	ICON_FA_BOX_OPEN,
	ICON_FA_BOX_TISSUE,
	ICON_FA_BOXES,
	ICON_FA_BRAILLE,
	ICON_FA_BRAIN,
	ICON_FA_BREAD_SLICE,
	ICON_FA_BRIEFCASE,
	ICON_FA_BRIEFCASE_MEDICAL,
	ICON_FA_BROADCAST_TOWER,
	ICON_FA_BROOM,
	ICON_FA_BRUSH,
	ICON_FA_BUG,
	ICON_FA_BUILDING,
	ICON_FA_BULLHORN,
	ICON_FA_BULLSEYE,
	ICON_FA_BURN,
	ICON_FA_BUS,
	ICON_FA_BUS_ALT,
	ICON_FA_BUSINESS_TIME,
	ICON_FA_CALCULATOR,
	ICON_FA_CALENDAR,
	ICON_FA_CALENDAR_ALT,
	ICON_FA_CALENDAR_CHECK,
	ICON_FA_CALENDAR_DAY,
	ICON_FA_CALENDAR_MINUS,
	ICON_FA_CALENDAR_PLUS,
	ICON_FA_CALENDAR_TIMES,
	ICON_FA_CALENDAR_WEEK,
	ICON_FA_CAMERA,
	ICON_FA_CAMERA_RETRO,
	ICON_FA_CAMPGROUND,
	ICON_FA_CANDY_CANE,
	ICON_FA_CANNABIS,
	ICON_FA_CAPSULES,
	ICON_FA_CAR,
	ICON_FA_CAR_ALT,
	ICON_FA_CAR_BATTERY,
	ICON_FA_CAR_CRASH,
	ICON_FA_CAR_SIDE,
	ICON_FA_CARAVAN,
	ICON_FA_CARET_DOWN,
	ICON_FA_CARET_LEFT,
	ICON_FA_CARET_RIGHT,
	ICON_FA_CARET_SQUARE_DOWN,
	ICON_FA_CARET_SQUARE_LEFT,
	ICON_FA_CARET_SQUARE_RIGHT,
	ICON_FA_CARET_SQUARE_UP,
	ICON_FA_CARET_UP,
	ICON_FA_CARROT,
	ICON_FA_CART_ARROW_DOWN,
	ICON_FA_CART_PLUS,
	ICON_FA_CASH_REGISTER,
	ICON_FA_CAT,
	ICON_FA_CERTIFICATE,
	ICON_FA_CHAIR,
	ICON_FA_CHALKBOARD,
	ICON_FA_CHALKBOARD_TEACHER,
	ICON_FA_CHARGING_STATION,
	ICON_FA_CHART_AREA,
	ICON_FA_CHART_BAR,
	ICON_FA_CHART_LINE,
	ICON_FA_CHART_PIE,
	ICON_FA_CHECK,
	ICON_FA_CHECK_CIRCLE,
	ICON_FA_CHECK_DOUBLE,
	ICON_FA_CHECK_SQUARE,
	ICON_FA_CHEESE,
	ICON_FA_CHESS,
	ICON_FA_CHESS_BISHOP,
	ICON_FA_CHESS_BOARD,
	ICON_FA_CHESS_KING,
	ICON_FA_CHESS_KNIGHT,
	ICON_FA_CHESS_PAWN,
	ICON_FA_CHESS_QUEEN,
	ICON_FA_CHESS_ROOK,
	ICON_FA_CHEVRON_CIRCLE_DOWN,
	ICON_FA_CHEVRON_CIRCLE_LEFT,
	ICON_FA_CHEVRON_CIRCLE_RIGHT,
	ICON_FA_CHEVRON_CIRCLE_UP,
	ICON_FA_CHEVRON_DOWN,
	ICON_FA_CHEVRON_LEFT,
	ICON_FA_CHEVRON_RIGHT,
	ICON_FA_CHEVRON_UP,
	ICON_FA_CHILD,
	ICON_FA_CHURCH,
	ICON_FA_CIRCLE,
	ICON_FA_CIRCLE_NOTCH,
	ICON_FA_CITY,
	ICON_FA_CLINIC_MEDICAL,
	ICON_FA_CLIPBOARD,
	ICON_FA_CLIPBOARD_CHECK,
	ICON_FA_CLIPBOARD_LIST,
	ICON_FA_CLOCK,
	ICON_FA_CLONE,
	ICON_FA_CLOSED_CAPTIONING,
	ICON_FA_CLOUD,
	ICON_FA_CLOUD_DOWNLOAD_ALT,
	ICON_FA_CLOUD_MEATBALL,
	ICON_FA_CLOUD_MOON,
	ICON_FA_CLOUD_MOON_RAIN,
	ICON_FA_CLOUD_RAIN,
	ICON_FA_CLOUD_SHOWERS_HEAVY,
	ICON_FA_CLOUD_SUN,
	ICON_FA_CLOUD_SUN_RAIN,
	ICON_FA_CLOUD_UPLOAD_ALT,
	ICON_FA_COCKTAIL,
	ICON_FA_CODE,
	ICON_FA_CODE_BRANCH,
	ICON_FA_COFFEE,
	ICON_FA_COG,
	ICON_FA_COGS,
	ICON_FA_COINS,
	ICON_FA_COLUMNS,
	ICON_FA_COMMENT,
	ICON_FA_COMMENT_ALT,
	ICON_FA_COMMENT_DOLLAR,
	ICON_FA_COMMENT_DOTS,
	ICON_FA_COMMENT_MEDICAL,
	ICON_FA_COMMENT_SLASH,
	ICON_FA_COMMENTS,
	ICON_FA_COMMENTS_DOLLAR,
	ICON_FA_COMPACT_DISC,
	ICON_FA_COMPASS,
	ICON_FA_COMPRESS,
	ICON_FA_COMPRESS_ALT,
	ICON_FA_COMPRESS_ARROWS_ALT,
	ICON_FA_CONCIERGE_BELL,
	ICON_FA_COOKIE,
	ICON_FA_COOKIE_BITE,
	ICON_FA_COPY,
	ICON_FA_COPYRIGHT,
	ICON_FA_COUCH,
	ICON_FA_CREDIT_CARD,
	ICON_FA_CROP,
	ICON_FA_CROP_ALT,
	ICON_FA_CROSS,
	ICON_FA_CROSSHAIRS,
	ICON_FA_CROW,
	ICON_FA_CROWN,
	ICON_FA_CRUTCH,
	ICON_FA_CUBE,
	ICON_FA_CUBES,
	ICON_FA_CUT,
	ICON_FA_DATABASE,
	ICON_FA_DEAF,
	ICON_FA_DEMOCRAT,
	ICON_FA_DESKTOP,
	ICON_FA_DHARMACHAKRA,
	ICON_FA_DIAGNOSES,
	ICON_FA_DICE,
	ICON_FA_DICE_D20,
	ICON_FA_DICE_D6,
	ICON_FA_DICE_FIVE,
	ICON_FA_DICE_FOUR,
	ICON_FA_DICE_ONE,
	ICON_FA_DICE_SIX,
	ICON_FA_DICE_THREE,
	ICON_FA_DICE_TWO,
	ICON_FA_DIGITAL_TACHOGRAPH,
	ICON_FA_DIRECTIONS,
	ICON_FA_DISEASE,
	ICON_FA_DIVIDE,
	ICON_FA_DIZZY,
	ICON_FA_DNA,
	ICON_FA_DOG,
	ICON_FA_DOLLAR_SIGN,
	ICON_FA_DOLLY,
	ICON_FA_DOLLY_FLATBED,
	ICON_FA_DONATE,
	ICON_FA_DOOR_CLOSED,
	ICON_FA_DOOR_OPEN,
	ICON_FA_DOT_CIRCLE,
	ICON_FA_DOVE,
	ICON_FA_DOWNLOAD,
	ICON_FA_DRAFTING_COMPASS,
	ICON_FA_DRAGON,
	ICON_FA_DRAW_POLYGON,
	ICON_FA_DRUM,
	ICON_FA_DRUM_STEELPAN,
	ICON_FA_DRUMSTICK_BITE,
	ICON_FA_DUMBBELL,
	ICON_FA_DUMPSTER,
	ICON_FA_DUMPSTER_FIRE,
	ICON_FA_DUNGEON,
	ICON_FA_EDIT,
	ICON_FA_EGG,
	ICON_FA_EJECT,
	ICON_FA_ELLIPSIS_H,
	ICON_FA_ELLIPSIS_V,
	ICON_FA_ENVELOPE,
	ICON_FA_ENVELOPE_OPEN,
	ICON_FA_ENVELOPE_OPEN_TEXT,
	ICON_FA_ENVELOPE_SQUARE,
	ICON_FA_EQUALS,
	ICON_FA_ERASER,
	ICON_FA_ETHERNET,
	ICON_FA_EURO_SIGN,
	ICON_FA_EXCHANGE_ALT,
	ICON_FA_EXCLAMATION,
	ICON_FA_EXCLAMATION_CIRCLE,
	ICON_FA_EXCLAMATION_TRIANGLE,
	ICON_FA_EXPAND,
	ICON_FA_EXPAND_ALT,
	ICON_FA_EXPAND_ARROWS_ALT,
	ICON_FA_EXTERNAL_LINK_ALT,
	ICON_FA_EXTERNAL_LINK_SQUARE_ALT,
	ICON_FA_EYE,
	ICON_FA_EYE_DROPPER,
	ICON_FA_EYE_SLASH,
	ICON_FA_FAN,
	ICON_FA_FAST_BACKWARD,
	ICON_FA_FAST_FORWARD,
	ICON_FA_FAUCET,
	ICON_FA_FAX,
	ICON_FA_FEATHER,
	ICON_FA_FEATHER_ALT,
	ICON_FA_FEMALE,
	ICON_FA_FIGHTER_JET,
	ICON_FA_FILE,
	ICON_FA_FILE_ALT,
	ICON_FA_FILE_ARCHIVE,
	ICON_FA_FILE_AUDIO,
	ICON_FA_FILE_CODE,
	ICON_FA_FILE_CONTRACT,
	ICON_FA_FILE_CSV,
	ICON_FA_FILE_DOWNLOAD,
	ICON_FA_FILE_EXCEL,
	ICON_FA_FILE_EXPORT,
	ICON_FA_FILE_IMAGE,
	ICON_FA_FILE_IMPORT,
	ICON_FA_FILE_INVOICE,
	ICON_FA_FILE_INVOICE_DOLLAR,
	ICON_FA_FILE_MEDICAL,
	ICON_FA_FILE_MEDICAL_ALT,
	ICON_FA_FILE_PDF,
	ICON_FA_FILE_POWERPOINT,
	ICON_FA_FILE_PRESCRIPTION,
	ICON_FA_FILE_SIGNATURE,
	ICON_FA_FILE_UPLOAD,
	ICON_FA_FILE_VIDEO,
	ICON_FA_FILE_WORD,
	ICON_FA_FILL,
	ICON_FA_FILL_DRIP,
	ICON_FA_FILM,
	ICON_FA_FILTER,
	ICON_FA_FINGERPRINT,
	ICON_FA_FIRE,
	ICON_FA_FIRE_ALT,
	ICON_FA_FIRE_EXTINGUISHER,
	ICON_FA_FIRST_AID,
	ICON_FA_FISH,
	ICON_FA_FIST_RAISED,
	ICON_FA_FLAG,
	ICON_FA_FLAG_CHECKERED,
	ICON_FA_FLAG_USA,
	ICON_FA_FLASK,
	ICON_FA_FLUSHED,
	ICON_FA_FOLDER,
	ICON_FA_FOLDER_MINUS,
	ICON_FA_FOLDER_OPEN,
	ICON_FA_FOLDER_PLUS,
	ICON_FA_FONT,
	ICON_FA_FONT_AWESOME_LOGO_FULL,
	ICON_FA_FOOTBALL_BALL,
	ICON_FA_FORWARD,
	ICON_FA_FROG,
	ICON_FA_FROWN,
	ICON_FA_FROWN_OPEN,
	ICON_FA_FUNNEL_DOLLAR,
	ICON_FA_FUTBOL,
	ICON_FA_GAMEPAD,
	ICON_FA_GAS_PUMP,
	ICON_FA_GAVEL,
	ICON_FA_GEM,
	ICON_FA_GENDERLESS,
	ICON_FA_GHOST,
	ICON_FA_GIFT,
	ICON_FA_GIFTS,
	ICON_FA_GLASS_CHEERS,
	ICON_FA_GLASS_MARTINI,
	ICON_FA_GLASS_MARTINI_ALT,
	ICON_FA_GLASS_WHISKEY,
	ICON_FA_GLASSES,
	ICON_FA_GLOBE,
	ICON_FA_GLOBE_AFRICA,
	ICON_FA_GLOBE_AMERICAS,
	ICON_FA_GLOBE_ASIA,
	ICON_FA_GLOBE_EUROPE,
	ICON_FA_GOLF_BALL,
	ICON_FA_GOPURAM,
	ICON_FA_GRADUATION_CAP,
	ICON_FA_GREATER_THAN,
	ICON_FA_GREATER_THAN_EQUAL,
	ICON_FA_GRIMACE,
	ICON_FA_GRIN,
	ICON_FA_GRIN_ALT,
	ICON_FA_GRIN_BEAM,
	ICON_FA_GRIN_BEAM_SWEAT,
	ICON_FA_GRIN_HEARTS,
	ICON_FA_GRIN_SQUINT,
	ICON_FA_GRIN_SQUINT_TEARS,
	ICON_FA_GRIN_STARS,
	ICON_FA_GRIN_TEARS,
	ICON_FA_GRIN_TONGUE,
	ICON_FA_GRIN_TONGUE_SQUINT,
	ICON_FA_GRIN_TONGUE_WINK,
	ICON_FA_GRIN_WINK,
	ICON_FA_GRIP_HORIZONTAL,
	ICON_FA_GRIP_LINES,
	ICON_FA_GRIP_LINES_VERTICAL,
	ICON_FA_GRIP_VERTICAL,
	ICON_FA_GUITAR,
	ICON_FA_H_SQUARE,
	ICON_FA_HAMBURGER,
	ICON_FA_HAMMER,
	ICON_FA_HAMSA,
	ICON_FA_HAND_HOLDING,
	ICON_FA_HAND_HOLDING_HEART,
	ICON_FA_HAND_HOLDING_MEDICAL,
	ICON_FA_HAND_HOLDING_USD,
	ICON_FA_HAND_HOLDING_WATER,
	ICON_FA_HAND_LIZARD,
	ICON_FA_HAND_MIDDLE_FINGER,
	ICON_FA_HAND_PAPER,
	ICON_FA_HAND_PEACE,
	ICON_FA_HAND_POINT_DOWN,
	ICON_FA_HAND_POINT_LEFT,
	ICON_FA_HAND_POINT_RIGHT,
	ICON_FA_HAND_POINT_UP,
	ICON_FA_HAND_POINTER,
	ICON_FA_HAND_ROCK,
	ICON_FA_HAND_SCISSORS,
	ICON_FA_HAND_SPARKLES,
	ICON_FA_HAND_SPOCK,
	ICON_FA_HANDS,
	ICON_FA_HANDS_HELPING,
	ICON_FA_HANDS_WASH,
	ICON_FA_HANDSHAKE,
	ICON_FA_HANDSHAKE_ALT_SLASH,
	ICON_FA_HANDSHAKE_SLASH,
	ICON_FA_HANUKIAH,
	ICON_FA_HARD_HAT,
	ICON_FA_HASHTAG,
	ICON_FA_HAT_COWBOY,
	ICON_FA_HAT_COWBOY_SIDE,
	ICON_FA_HAT_WIZARD,
	ICON_FA_HDD,
	ICON_FA_HEAD_SIDE_COUGH,
	ICON_FA_HEAD_SIDE_COUGH_SLASH,
	ICON_FA_HEAD_SIDE_MASK,
	ICON_FA_HEAD_SIDE_VIRUS,
	ICON_FA_HEADING,
	ICON_FA_HEADPHONES,
	ICON_FA_HEADPHONES_ALT,
	ICON_FA_HEADSET,
	ICON_FA_HEART,
	ICON_FA_HEART_BROKEN,
	ICON_FA_HEARTBEAT,
	ICON_FA_HELICOPTER,
	ICON_FA_HIGHLIGHTER,
	ICON_FA_HIKING,
	ICON_FA_HIPPO,
	ICON_FA_HISTORY,
	ICON_FA_HOCKEY_PUCK,
	ICON_FA_HOLLY_BERRY,
	ICON_FA_HOME,
	ICON_FA_HORSE,
	ICON_FA_HORSE_HEAD,
	ICON_FA_HOSPITAL,
	ICON_FA_HOSPITAL_ALT,
	ICON_FA_HOSPITAL_SYMBOL,
	ICON_FA_HOSPITAL_USER,
	ICON_FA_HOT_TUB,
	ICON_FA_HOTDOG,
	ICON_FA_HOTEL,
	ICON_FA_HOURGLASS,
	ICON_FA_HOURGLASS_END,
	ICON_FA_HOURGLASS_HALF,
	ICON_FA_HOURGLASS_START,
	ICON_FA_HOUSE_DAMAGE,
	ICON_FA_HOUSE_USER,
	ICON_FA_HRYVNIA,
	ICON_FA_I_CURSOR,
	ICON_FA_ICE_CREAM,
	ICON_FA_ICICLES,
	ICON_FA_ICONS,
	ICON_FA_ID_BADGE,
	ICON_FA_ID_CARD,
	ICON_FA_ID_CARD_ALT,
	ICON_FA_IGLOO,
	ICON_FA_IMAGE,
	ICON_FA_IMAGES,
	ICON_FA_INBOX,
	ICON_FA_INDENT,
	ICON_FA_INDUSTRY,
	ICON_FA_INFINITY,
	ICON_FA_INFO,
	ICON_FA_INFO_CIRCLE,
	ICON_FA_ITALIC,
	ICON_FA_JEDI,
	ICON_FA_JOINT,
	ICON_FA_JOURNAL_WHILLS,
	ICON_FA_KAABA,
	ICON_FA_KEY,
	ICON_FA_KEYBOARD,
	ICON_FA_KHANDA,
	ICON_FA_KISS,
	ICON_FA_KISS_BEAM,
	ICON_FA_KISS_WINK_HEART,
	ICON_FA_KIWI_BIRD,
	ICON_FA_LANDMARK,
	ICON_FA_LANGUAGE,
	ICON_FA_LAPTOP,
	ICON_FA_LAPTOP_CODE,
	ICON_FA_LAPTOP_HOUSE,
	ICON_FA_LAPTOP_MEDICAL,
	ICON_FA_LAUGH,
	ICON_FA_LAUGH_BEAM,
	ICON_FA_LAUGH_SQUINT,
	ICON_FA_LAUGH_WINK,
	ICON_FA_LAYER_GROUP,
	ICON_FA_LEAF,
	ICON_FA_LEMON,
	ICON_FA_LESS_THAN,
	ICON_FA_LESS_THAN_EQUAL,
	ICON_FA_LEVEL_DOWN_ALT,
	ICON_FA_LEVEL_UP_ALT,
	ICON_FA_LIFE_RING,
	ICON_FA_LIGHTBULB,
	ICON_FA_LINK,
	ICON_FA_LIRA_SIGN,
	ICON_FA_LIST,
	ICON_FA_LIST_ALT,
	ICON_FA_LIST_OL,
	ICON_FA_LIST_UL,
	ICON_FA_LOCATION_ARROW,
	ICON_FA_LOCK,
	ICON_FA_LOCK_OPEN,
	ICON_FA_LONG_ARROW_ALT_DOWN,
	ICON_FA_LONG_ARROW_ALT_LEFT,
	ICON_FA_LONG_ARROW_ALT_RIGHT,
	ICON_FA_LONG_ARROW_ALT_UP,
	ICON_FA_LOW_VISION,
	ICON_FA_LUGGAGE_CART,
	ICON_FA_LUNGS,
	ICON_FA_LUNGS_VIRUS,
	ICON_FA_MAGIC,
	ICON_FA_MAGNET,
	ICON_FA_MAIL_BULK,
	ICON_FA_MALE,
	ICON_FA_MAP,
	ICON_FA_MAP_MARKED,
	ICON_FA_MAP_MARKED_ALT,
	ICON_FA_MAP_MARKER,
	ICON_FA_MAP_MARKER_ALT,
	ICON_FA_MAP_PIN,
	ICON_FA_MAP_SIGNS,
	ICON_FA_MARKER,
	ICON_FA_MARS,
	ICON_FA_MARS_DOUBLE,
	ICON_FA_MARS_STROKE,
	ICON_FA_MARS_STROKE_H,
	ICON_FA_MARS_STROKE_V,
	ICON_FA_MASK,
	ICON_FA_MEDAL,
	ICON_FA_MEDKIT,
	ICON_FA_MEH,
	ICON_FA_MEH_BLANK,
	ICON_FA_MEH_ROLLING_EYES,
	ICON_FA_MEMORY,
	ICON_FA_MENORAH,
	ICON_FA_MERCURY,
	ICON_FA_METEOR,
	ICON_FA_MICROCHIP,
	ICON_FA_MICROPHONE,
	ICON_FA_MICROPHONE_ALT,
	ICON_FA_MICROPHONE_ALT_SLASH,
	ICON_FA_MICROPHONE_SLASH,
	ICON_FA_MICROSCOPE,
	ICON_FA_MINUS,
	ICON_FA_MINUS_CIRCLE,
	ICON_FA_MINUS_SQUARE,
	ICON_FA_MITTEN,
	ICON_FA_MOBILE,
	ICON_FA_MOBILE_ALT,
	ICON_FA_MONEY_BILL,
	ICON_FA_MONEY_BILL_ALT,
	ICON_FA_MONEY_BILL_WAVE,
	ICON_FA_MONEY_BILL_WAVE_ALT,
	ICON_FA_MONEY_CHECK,
	ICON_FA_MONEY_CHECK_ALT,
	ICON_FA_MONUMENT,
	ICON_FA_MOON,
	ICON_FA_MORTAR_PESTLE,
	ICON_FA_MOSQUE,
	ICON_FA_MOTORCYCLE,
	ICON_FA_MOUNTAIN,
	ICON_FA_MOUSE,
	ICON_FA_MOUSE_POINTER,
	ICON_FA_MUG_HOT,
	ICON_FA_MUSIC,
	ICON_FA_NETWORK_WIRED,
	ICON_FA_NEUTER,
	ICON_FA_NEWSPAPER,
	ICON_FA_NOT_EQUAL,
	ICON_FA_NOTES_MEDICAL,
	ICON_FA_OBJECT_GROUP,
	ICON_FA_OBJECT_UNGROUP,
	ICON_FA_OIL_CAN,
	ICON_FA_OM,
	ICON_FA_OTTER,
	ICON_FA_OUTDENT,
	ICON_FA_PAGER,
	ICON_FA_PAINT_BRUSH,
	ICON_FA_PAINT_ROLLER,
	ICON_FA_PALETTE,
	ICON_FA_PALLET,
	ICON_FA_PAPER_PLANE,
	ICON_FA_PAPERCLIP,
	ICON_FA_PARACHUTE_BOX,
	ICON_FA_PARAGRAPH,
	ICON_FA_PARKING,
	ICON_FA_PASSPORT,
	ICON_FA_PASTAFARIANISM,
	ICON_FA_PASTE,
	ICON_FA_PAUSE,
	ICON_FA_PAUSE_CIRCLE,
	ICON_FA_PAW,
	ICON_FA_PEACE,
	ICON_FA_PEN,
	ICON_FA_PEN_ALT,
	ICON_FA_PEN_FANCY,
	ICON_FA_PEN_NIB,
	ICON_FA_PEN_SQUARE,
	ICON_FA_PENCIL_ALT,
	ICON_FA_PENCIL_RULER,
	ICON_FA_PEOPLE_ARROWS,
	ICON_FA_PEOPLE_CARRY,
	ICON_FA_PEPPER_HOT,
	ICON_FA_PERCENT,
	ICON_FA_PERCENTAGE,
	ICON_FA_PERSON_BOOTH,
	ICON_FA_PHONE,
	ICON_FA_PHONE_ALT,
	ICON_FA_PHONE_SLASH,
	ICON_FA_PHONE_SQUARE,
	ICON_FA_PHONE_SQUARE_ALT,
	ICON_FA_PHONE_VOLUME,
	ICON_FA_PHOTO_VIDEO,
	ICON_FA_PIGGY_BANK,
	ICON_FA_PILLS,
	ICON_FA_PIZZA_SLICE,
	ICON_FA_PLACE_OF_WORSHIP,
	ICON_FA_PLANE,
	ICON_FA_PLANE_ARRIVAL,
	ICON_FA_PLANE_DEPARTURE,
	ICON_FA_PLANE_SLASH,
	ICON_FA_PLAY,
	ICON_FA_PLAY_CIRCLE,
	ICON_FA_PLUG,
	ICON_FA_PLUS,
	ICON_FA_PLUS_CIRCLE,
	ICON_FA_PLUS_SQUARE,
	ICON_FA_PODCAST,
	ICON_FA_POLL,
	ICON_FA_POLL_H,
	ICON_FA_POO,
	ICON_FA_POO_STORM,
	ICON_FA_POOP,
	ICON_FA_PORTRAIT,
	ICON_FA_POUND_SIGN,
	ICON_FA_POWER_OFF,
	ICON_FA_PRAY,
	ICON_FA_PRAYING_HANDS,
	ICON_FA_PRESCRIPTION,
	ICON_FA_PRESCRIPTION_BOTTLE,
	ICON_FA_PRESCRIPTION_BOTTLE_ALT,
	ICON_FA_PRINT,
	ICON_FA_PROCEDURES,
	ICON_FA_PROJECT_DIAGRAM,
	ICON_FA_PUMP_MEDICAL,
	ICON_FA_PUMP_SOAP,
	ICON_FA_PUZZLE_PIECE,
	ICON_FA_QRCODE,
	ICON_FA_QUESTION,
	ICON_FA_QUESTION_CIRCLE,
	ICON_FA_QUIDDITCH,
	ICON_FA_QUOTE_LEFT,
	ICON_FA_QUOTE_RIGHT,
	ICON_FA_QURAN,
	ICON_FA_RADIATION,
	ICON_FA_RADIATION_ALT,
	ICON_FA_RAINBOW,
	ICON_FA_RANDOM,
	ICON_FA_RECEIPT,
	ICON_FA_RECORD_VINYL,
	ICON_FA_RECYCLE,
	ICON_FA_REDO,
	ICON_FA_REDO_ALT,
	ICON_FA_REGISTERED,
	ICON_FA_REMOVE_FORMAT,
	ICON_FA_REPLY,
	ICON_FA_REPLY_ALL,
	ICON_FA_REPUBLICAN,
	ICON_FA_RESTROOM,
	ICON_FA_RETWEET,
	ICON_FA_RIBBON,
	ICON_FA_RING,
	ICON_FA_ROAD,
	ICON_FA_ROBOT,
	ICON_FA_ROCKET,
	ICON_FA_ROUTE,
	ICON_FA_RSS,
	ICON_FA_RSS_SQUARE,
	ICON_FA_RUBLE_SIGN,
	ICON_FA_RULER,
	ICON_FA_RULER_COMBINED,
	ICON_FA_RULER_HORIZONTAL,
	ICON_FA_RULER_VERTICAL,
	ICON_FA_RUNNING,
	ICON_FA_RUPEE_SIGN,
	ICON_FA_SAD_CRY,
	ICON_FA_SAD_TEAR,
	ICON_FA_SATELLITE,
	ICON_FA_SATELLITE_DISH,
	ICON_FA_SAVE,
	ICON_FA_SCHOOL,
	ICON_FA_SCREWDRIVER,
	ICON_FA_SCROLL,
	ICON_FA_SD_CARD,
	ICON_FA_SEARCH,
	ICON_FA_SEARCH_DOLLAR,
	ICON_FA_SEARCH_LOCATION,
	ICON_FA_SEARCH_MINUS,
	ICON_FA_SEARCH_PLUS,
	ICON_FA_SEEDLING,
	ICON_FA_SERVER,
	ICON_FA_SHAPES,
	ICON_FA_SHARE,
	ICON_FA_SHARE_ALT,
	ICON_FA_SHARE_ALT_SQUARE,
	ICON_FA_SHARE_SQUARE,
	ICON_FA_SHEKEL_SIGN,
	ICON_FA_SHIELD_ALT,
	ICON_FA_SHIELD_VIRUS,
	ICON_FA_SHIP,
	ICON_FA_SHIPPING_FAST,
	ICON_FA_SHOE_PRINTS,
	ICON_FA_SHOPPING_BAG,
	ICON_FA_SHOPPING_BASKET,
	ICON_FA_SHOPPING_CART,
	ICON_FA_SHOWER,
	ICON_FA_SHUTTLE_VAN,
	ICON_FA_SIGN,
	ICON_FA_SIGN_IN_ALT,
	ICON_FA_SIGN_LANGUAGE,
	ICON_FA_SIGN_OUT_ALT,
	ICON_FA_SIGNAL,
	ICON_FA_SIGNATURE,
	ICON_FA_SIM_CARD,
	ICON_FA_SINK,
	ICON_FA_SITEMAP,
	ICON_FA_SKATING,
	ICON_FA_SKIING,
	ICON_FA_SKIING_NORDIC,
	ICON_FA_SKULL,
	ICON_FA_SKULL_CROSSBONES,
	ICON_FA_SLASH,
	ICON_FA_SLEIGH,
	ICON_FA_SLIDERS_H,
	ICON_FA_SMILE,
	ICON_FA_SMILE_BEAM,
	ICON_FA_SMILE_WINK,
	ICON_FA_SMOG,
	ICON_FA_SMOKING,
	ICON_FA_SMOKING_BAN,
	ICON_FA_SMS,
	ICON_FA_SNOWBOARDING,
	ICON_FA_SNOWFLAKE,
	ICON_FA_SNOWMAN,
	ICON_FA_SNOWPLOW,
	ICON_FA_SOAP,
	ICON_FA_SOCKS,
	ICON_FA_SOLAR_PANEL,
	ICON_FA_SORT,
	ICON_FA_SORT_ALPHA_DOWN,
	ICON_FA_SORT_ALPHA_DOWN_ALT,
	ICON_FA_SORT_ALPHA_UP,
	ICON_FA_SORT_ALPHA_UP_ALT,
	ICON_FA_SORT_AMOUNT_DOWN,
	ICON_FA_SORT_AMOUNT_DOWN_ALT,
	ICON_FA_SORT_AMOUNT_UP,
	ICON_FA_SORT_AMOUNT_UP_ALT,
	ICON_FA_SORT_DOWN,
	ICON_FA_SORT_NUMERIC_DOWN,
	ICON_FA_SORT_NUMERIC_DOWN_ALT,
	ICON_FA_SORT_NUMERIC_UP,
	ICON_FA_SORT_NUMERIC_UP_ALT,
	ICON_FA_SORT_UP,
	ICON_FA_SPA,
	ICON_FA_SPACE_SHUTTLE,
	ICON_FA_SPELL_CHECK,
	ICON_FA_SPIDER,
	ICON_FA_SPINNER,
	ICON_FA_SPLOTCH,
	ICON_FA_SPRAY_CAN,
	ICON_FA_SQUARE,
	ICON_FA_SQUARE_FULL,
	ICON_FA_SQUARE_ROOT_ALT,
	ICON_FA_STAMP,
	ICON_FA_STAR,
	ICON_FA_STAR_AND_CRESCENT,
	ICON_FA_STAR_HALF,
	ICON_FA_STAR_HALF_ALT,
	ICON_FA_STAR_OF_DAVID,
	ICON_FA_STAR_OF_LIFE,
	ICON_FA_STEP_BACKWARD,
	ICON_FA_STEP_FORWARD,
	ICON_FA_STETHOSCOPE,
	ICON_FA_STICKY_NOTE,
	ICON_FA_STOP,
	ICON_FA_STOP_CIRCLE,
	ICON_FA_STOPWATCH,
	ICON_FA_STOPWATCH_20,
	ICON_FA_STORE,
	ICON_FA_STORE_ALT,
	ICON_FA_STORE_ALT_SLASH,
	ICON_FA_STORE_SLASH,
	ICON_FA_STREAM,
	ICON_FA_STREET_VIEW,
	ICON_FA_STRIKETHROUGH,
	ICON_FA_STROOPWAFEL,
	ICON_FA_SUBSCRIPT,
	ICON_FA_SUBWAY,
	ICON_FA_SUITCASE,
	ICON_FA_SUITCASE_ROLLING,
	ICON_FA_SUN,
	ICON_FA_SUPERSCRIPT,
	ICON_FA_SURPRISE,
	ICON_FA_SWATCHBOOK,
	ICON_FA_SWIMMER,
	ICON_FA_SWIMMING_POOL,
	ICON_FA_SYNAGOGUE,
	ICON_FA_SYNC,
	ICON_FA_SYNC_ALT,
	ICON_FA_SYRINGE,
	ICON_FA_TABLE,
	ICON_FA_TABLE_TENNIS,
	ICON_FA_TABLET,
	ICON_FA_TABLET_ALT,
	ICON_FA_TABLETS,
	ICON_FA_TACHOMETER_ALT,
	ICON_FA_TAG,
	ICON_FA_TAGS,
	ICON_FA_TAPE,
	ICON_FA_TASKS,
	ICON_FA_TAXI,
	ICON_FA_TEETH,
	ICON_FA_TEETH_OPEN,
	ICON_FA_TEMPERATURE_HIGH,
	ICON_FA_TEMPERATURE_LOW,
	ICON_FA_TENGE,
	ICON_FA_TERMINAL,
	ICON_FA_TEXT_HEIGHT,
	ICON_FA_TEXT_WIDTH,
	ICON_FA_TH,
	ICON_FA_TH_LARGE,
	ICON_FA_TH_LIST,
	ICON_FA_THEATER_MASKS,
	ICON_FA_THERMOMETER,
	ICON_FA_THERMOMETER_EMPTY,
	ICON_FA_THERMOMETER_FULL,
	ICON_FA_THERMOMETER_HALF,
	ICON_FA_THERMOMETER_QUARTER,
	ICON_FA_THERMOMETER_THREE_QUARTERS,
	ICON_FA_THUMBS_DOWN,
	ICON_FA_THUMBS_UP,
	ICON_FA_THUMBTACK,
	ICON_FA_TICKET_ALT,
	ICON_FA_TIMES,
	ICON_FA_TIMES_CIRCLE,
	ICON_FA_TINT,
	ICON_FA_TINT_SLASH,
	ICON_FA_TIRED,
	ICON_FA_TOGGLE_OFF,
	ICON_FA_TOGGLE_ON,
	ICON_FA_TOILET,
	ICON_FA_TOILET_PAPER,
	ICON_FA_TOILET_PAPER_SLASH,
	ICON_FA_TOOLBOX,
	ICON_FA_TOOLS,
	ICON_FA_TOOTH,
	ICON_FA_TORAH,
	ICON_FA_TORII_GATE,
	ICON_FA_TRACTOR,
	ICON_FA_TRADEMARK,
	ICON_FA_TRAFFIC_LIGHT,
	ICON_FA_TRAILER,
	ICON_FA_TRAIN,
	ICON_FA_TRAM,
	ICON_FA_TRANSGENDER,
	ICON_FA_TRANSGENDER_ALT,
	ICON_FA_TRASH,
	ICON_FA_TRASH_ALT,
	ICON_FA_TRASH_RESTORE,
	ICON_FA_TRASH_RESTORE_ALT,
	ICON_FA_TREE,
	ICON_FA_TROPHY,
	ICON_FA_TRUCK,
	ICON_FA_TRUCK_LOADING,
	ICON_FA_TRUCK_MONSTER,
	ICON_FA_TRUCK_MOVING,
	ICON_FA_TRUCK_PICKUP,
	ICON_FA_TSHIRT,
	ICON_FA_TTY,
	ICON_FA_TV,
	ICON_FA_UMBRELLA,
	ICON_FA_UMBRELLA_BEACH,
	ICON_FA_UNDERLINE,
	ICON_FA_UNDO,
	ICON_FA_UNDO_ALT,
	ICON_FA_UNIVERSAL_ACCESS,
	ICON_FA_UNIVERSITY,
	ICON_FA_UNLINK,
	ICON_FA_UNLOCK,
	ICON_FA_UNLOCK_ALT,
	ICON_FA_UPLOAD,
	ICON_FA_USER,
	ICON_FA_USER_ALT,
	ICON_FA_USER_ALT_SLASH,
	ICON_FA_USER_ASTRONAUT,
	ICON_FA_USER_CHECK,
	ICON_FA_USER_CIRCLE,
	ICON_FA_USER_CLOCK,
	ICON_FA_USER_COG,
	ICON_FA_USER_EDIT,
	ICON_FA_USER_FRIENDS,
	ICON_FA_USER_GRADUATE,
	ICON_FA_USER_INJURED,
	ICON_FA_USER_LOCK,
	ICON_FA_USER_MD,
	ICON_FA_USER_MINUS,
	ICON_FA_USER_NINJA,
	ICON_FA_USER_NURSE,
	ICON_FA_USER_PLUS,
	ICON_FA_USER_SECRET,
	ICON_FA_USER_SHIELD,
	ICON_FA_USER_SLASH,
	ICON_FA_USER_TAG,
	ICON_FA_USER_TIE,
	ICON_FA_USER_TIMES,
	ICON_FA_USERS,
	ICON_FA_USERS_COG,
	ICON_FA_USERS_SLASH,
	ICON_FA_UTENSIL_SPOON,
	ICON_FA_UTENSILS,
	ICON_FA_VECTOR_SQUARE,
	ICON_FA_VENUS,
	ICON_FA_VENUS_DOUBLE,
	ICON_FA_VENUS_MARS,
	ICON_FA_VIAL,
	ICON_FA_VIALS,
	ICON_FA_VIDEO,
	ICON_FA_VIDEO_SLASH,
	ICON_FA_VIHARA,
	ICON_FA_VIRUS,
	ICON_FA_VIRUS_SLASH,
	ICON_FA_VIRUSES,
	ICON_FA_VOICEMAIL,
	ICON_FA_VOLLEYBALL_BALL,
	ICON_FA_VOLUME_DOWN,
	ICON_FA_VOLUME_MUTE,
	ICON_FA_VOLUME_OFF,
	ICON_FA_VOLUME_UP,
	ICON_FA_VOTE_YEA,
	ICON_FA_VR_CARDBOARD,
	ICON_FA_WALKING,
	ICON_FA_WALLET,
	ICON_FA_WAREHOUSE,
	ICON_FA_WATER,
	ICON_FA_WAVE_SQUARE,
	ICON_FA_WEIGHT,
	ICON_FA_WEIGHT_HANGING,
	ICON_FA_WHEELCHAIR,
	ICON_FA_WIFI,
	ICON_FA_WIND,
	ICON_FA_WINDOW_CLOSE,
	ICON_FA_WINDOW_MAXIMIZE,
	ICON_FA_WINDOW_MINIMIZE,
	ICON_FA_WINDOW_RESTORE,
	ICON_FA_WINE_BOTTLE,
	ICON_FA_WINE_GLASS,
	ICON_FA_WINE_GLASS_ALT,
	ICON_FA_WON_SIGN,
	ICON_FA_WRENCH,
	ICON_FA_X_RAY,
	ICON_FA_YEN_SIGN,
	ICON_FA_YIN_YANG,
};

const char* awesomeIconNames[] =
{
	"ICON_FA_AD", 
	"ICON_FA_ADDRESS_BOOK", 
	"ICON_FA_ADDRESS_CARD", 
	"ICON_FA_ADJUST", 
	"ICON_FA_AIR_FRESHENER", 
	"ICON_FA_ALIGN_CENTER", 
	"ICON_FA_ALIGN_JUSTIFY", 
	"ICON_FA_ALIGN_LEFT", 
	"ICON_FA_ALIGN_RIGHT", 
	"ICON_FA_ALLERGIES", 
	"ICON_FA_AMBULANCE", 
	"ICON_FA_AMERICAN_SIGN_LANGUAGE_INTERPRETING", 
	"ICON_FA_ANCHOR", 
	"ICON_FA_ANGLE_DOUBLE_DOWN", 
	"ICON_FA_ANGLE_DOUBLE_LEFT", 
	"ICON_FA_ANGLE_DOUBLE_RIGHT", 
	"ICON_FA_ANGLE_DOUBLE_UP", 
	"ICON_FA_ANGLE_DOWN", 
	"ICON_FA_ANGLE_LEFT", 
	"ICON_FA_ANGLE_RIGHT", 
	"ICON_FA_ANGLE_UP", 
	"ICON_FA_ANGRY", 
	"ICON_FA_ANKH", 
	"ICON_FA_APPLE_ALT", 
	"ICON_FA_ARCHIVE", 
	"ICON_FA_ARCHWAY", 
	"ICON_FA_ARROW_ALT_CIRCLE_DOWN", 
	"ICON_FA_ARROW_ALT_CIRCLE_LEFT", 
	"ICON_FA_ARROW_ALT_CIRCLE_RIGHT", 
	"ICON_FA_ARROW_ALT_CIRCLE_UP", 
	"ICON_FA_ARROW_CIRCLE_DOWN", 
	"ICON_FA_ARROW_CIRCLE_LEFT", 
	"ICON_FA_ARROW_CIRCLE_RIGHT", 
	"ICON_FA_ARROW_CIRCLE_UP", 
	"ICON_FA_ARROW_DOWN", 
	"ICON_FA_ARROW_LEFT", 
	"ICON_FA_ARROW_RIGHT", 
	"ICON_FA_ARROW_UP", 
	"ICON_FA_ARROWS_ALT", 
	"ICON_FA_ARROWS_ALT_H", 
	"ICON_FA_ARROWS_ALT_V", 
	"ICON_FA_ASSISTIVE_LISTENING_SYSTEMS", 
	"ICON_FA_ASTERISK", 
	"ICON_FA_AT", 
	"ICON_FA_ATLAS", 
	"ICON_FA_ATOM", 
	"ICON_FA_AUDIO_DESCRIPTION", 
	"ICON_FA_AWARD", 
	"ICON_FA_BABY", 
	"ICON_FA_BABY_CARRIAGE", 
	"ICON_FA_BACKSPACE", 
	"ICON_FA_BACKWARD", 
	"ICON_FA_BACON", 
	"ICON_FA_BACTERIA", 
	"ICON_FA_BACTERIUM", 
	"ICON_FA_BAHAI", 
	"ICON_FA_BALANCE_SCALE", 
	"ICON_FA_BALANCE_SCALE_LEFT", 
	"ICON_FA_BALANCE_SCALE_RIGHT", 
	"ICON_FA_BAN", 
	"ICON_FA_BAND_AID", 
	"ICON_FA_BARCODE", 
	"ICON_FA_BARS", 
	"ICON_FA_BASEBALL_BALL", 
	"ICON_FA_BASKETBALL_BALL", 
	"ICON_FA_BATH", 
	"ICON_FA_BATTERY_EMPTY", 
	"ICON_FA_BATTERY_FULL", 
	"ICON_FA_BATTERY_HALF", 
	"ICON_FA_BATTERY_QUARTER", 
	"ICON_FA_BATTERY_THREE_QUARTERS", 
	"ICON_FA_BED", 
	"ICON_FA_BEER", 
	"ICON_FA_BELL", 
	"ICON_FA_BELL_SLASH", 
	"ICON_FA_BEZIER_CURVE", 
	"ICON_FA_BIBLE", 
	"ICON_FA_BICYCLE", 
	"ICON_FA_BIKING", 
	"ICON_FA_BINOCULARS", 
	"ICON_FA_BIOHAZARD", 
	"ICON_FA_BIRTHDAY_CAKE", 
	"ICON_FA_BLENDER", 
	"ICON_FA_BLENDER_PHONE", 
	"ICON_FA_BLIND", 
	"ICON_FA_BLOG", 
	"ICON_FA_BOLD", 
	"ICON_FA_BOLT", 
	"ICON_FA_BOMB", 
	"ICON_FA_BONE", 
	"ICON_FA_BONG", 
	"ICON_FA_BOOK", 
	"ICON_FA_BOOK_DEAD", 
	"ICON_FA_BOOK_MEDICAL", 
	"ICON_FA_BOOK_OPEN", 
	"ICON_FA_BOOK_READER", 
	"ICON_FA_BOOKMARK", 
	"ICON_FA_BORDER_ALL", 
	"ICON_FA_BORDER_NONE", 
	"ICON_FA_BORDER_STYLE", 
	"ICON_FA_BOWLING_BALL", 
	"ICON_FA_BOX", 
	"ICON_FA_BOX_OPEN", 
	"ICON_FA_BOX_TISSUE", 
	"ICON_FA_BOXES", 
	"ICON_FA_BRAILLE", 
	"ICON_FA_BRAIN", 
	"ICON_FA_BREAD_SLICE", 
	"ICON_FA_BRIEFCASE", 
	"ICON_FA_BRIEFCASE_MEDICAL", 
	"ICON_FA_BROADCAST_TOWER", 
	"ICON_FA_BROOM", 
	"ICON_FA_BRUSH", 
	"ICON_FA_BUG", 
	"ICON_FA_BUILDING", 
	"ICON_FA_BULLHORN", 
	"ICON_FA_BULLSEYE", 
	"ICON_FA_BURN", 
	"ICON_FA_BUS", 
	"ICON_FA_BUS_ALT", 
	"ICON_FA_BUSINESS_TIME", 
	"ICON_FA_CALCULATOR", 
	"ICON_FA_CALENDAR", 
	"ICON_FA_CALENDAR_ALT", 
	"ICON_FA_CALENDAR_CHECK", 
	"ICON_FA_CALENDAR_DAY", 
	"ICON_FA_CALENDAR_MINUS", 
	"ICON_FA_CALENDAR_PLUS", 
	"ICON_FA_CALENDAR_TIMES", 
	"ICON_FA_CALENDAR_WEEK", 
	"ICON_FA_CAMERA", 
	"ICON_FA_CAMERA_RETRO", 
	"ICON_FA_CAMPGROUND", 
	"ICON_FA_CANDY_CANE", 
	"ICON_FA_CANNABIS", 
	"ICON_FA_CAPSULES", 
	"ICON_FA_CAR", 
	"ICON_FA_CAR_ALT", 
	"ICON_FA_CAR_BATTERY", 
	"ICON_FA_CAR_CRASH", 
	"ICON_FA_CAR_SIDE", 
	"ICON_FA_CARAVAN", 
	"ICON_FA_CARET_DOWN", 
	"ICON_FA_CARET_LEFT", 
	"ICON_FA_CARET_RIGHT", 
	"ICON_FA_CARET_SQUARE_DOWN", 
	"ICON_FA_CARET_SQUARE_LEFT", 
	"ICON_FA_CARET_SQUARE_RIGHT", 
	"ICON_FA_CARET_SQUARE_UP", 
	"ICON_FA_CARET_UP", 
	"ICON_FA_CARROT", 
	"ICON_FA_CART_ARROW_DOWN", 
	"ICON_FA_CART_PLUS", 
	"ICON_FA_CASH_REGISTER", 
	"ICON_FA_CAT", 
	"ICON_FA_CERTIFICATE", 
	"ICON_FA_CHAIR", 
	"ICON_FA_CHALKBOARD", 
	"ICON_FA_CHALKBOARD_TEACHER", 
	"ICON_FA_CHARGING_STATION", 
	"ICON_FA_CHART_AREA", 
	"ICON_FA_CHART_BAR", 
	"ICON_FA_CHART_LINE", 
	"ICON_FA_CHART_PIE", 
	"ICON_FA_CHECK", 
	"ICON_FA_CHECK_CIRCLE", 
	"ICON_FA_CHECK_DOUBLE", 
	"ICON_FA_CHECK_SQUARE", 
	"ICON_FA_CHEESE", 
	"ICON_FA_CHESS", 
	"ICON_FA_CHESS_BISHOP", 
	"ICON_FA_CHESS_BOARD", 
	"ICON_FA_CHESS_KING", 
	"ICON_FA_CHESS_KNIGHT", 
	"ICON_FA_CHESS_PAWN", 
	"ICON_FA_CHESS_QUEEN", 
	"ICON_FA_CHESS_ROOK", 
	"ICON_FA_CHEVRON_CIRCLE_DOWN", 
	"ICON_FA_CHEVRON_CIRCLE_LEFT", 
	"ICON_FA_CHEVRON_CIRCLE_RIGHT", 
	"ICON_FA_CHEVRON_CIRCLE_UP", 
	"ICON_FA_CHEVRON_DOWN", 
	"ICON_FA_CHEVRON_LEFT", 
	"ICON_FA_CHEVRON_RIGHT", 
	"ICON_FA_CHEVRON_UP", 
	"ICON_FA_CHILD", 
	"ICON_FA_CHURCH", 
	"ICON_FA_CIRCLE", 
	"ICON_FA_CIRCLE_NOTCH", 
	"ICON_FA_CITY", 
	"ICON_FA_CLINIC_MEDICAL", 
	"ICON_FA_CLIPBOARD", 
	"ICON_FA_CLIPBOARD_CHECK", 
	"ICON_FA_CLIPBOARD_LIST", 
	"ICON_FA_CLOCK", 
	"ICON_FA_CLONE", 
	"ICON_FA_CLOSED_CAPTIONING", 
	"ICON_FA_CLOUD", 
	"ICON_FA_CLOUD_DOWNLOAD_ALT", 
	"ICON_FA_CLOUD_MEATBALL", 
	"ICON_FA_CLOUD_MOON", 
	"ICON_FA_CLOUD_MOON_RAIN", 
	"ICON_FA_CLOUD_RAIN", 
	"ICON_FA_CLOUD_SHOWERS_HEAVY", 
	"ICON_FA_CLOUD_SUN", 
	"ICON_FA_CLOUD_SUN_RAIN", 
	"ICON_FA_CLOUD_UPLOAD_ALT", 
	"ICON_FA_COCKTAIL", 
	"ICON_FA_CODE", 
	"ICON_FA_CODE_BRANCH", 
	"ICON_FA_COFFEE", 
	"ICON_FA_COG", 
	"ICON_FA_COGS", 
	"ICON_FA_COINS", 
	"ICON_FA_COLUMNS", 
	"ICON_FA_COMMENT", 
	"ICON_FA_COMMENT_ALT", 
	"ICON_FA_COMMENT_DOLLAR", 
	"ICON_FA_COMMENT_DOTS", 
	"ICON_FA_COMMENT_MEDICAL", 
	"ICON_FA_COMMENT_SLASH", 
	"ICON_FA_COMMENTS", 
	"ICON_FA_COMMENTS_DOLLAR", 
	"ICON_FA_COMPACT_DISC", 
	"ICON_FA_COMPASS", 
	"ICON_FA_COMPRESS", 
	"ICON_FA_COMPRESS_ALT", 
	"ICON_FA_COMPRESS_ARROWS_ALT", 
	"ICON_FA_CONCIERGE_BELL", 
	"ICON_FA_COOKIE", 
	"ICON_FA_COOKIE_BITE", 
	"ICON_FA_COPY", 
	"ICON_FA_COPYRIGHT", 
	"ICON_FA_COUCH", 
	"ICON_FA_CREDIT_CARD", 
	"ICON_FA_CROP", 
	"ICON_FA_CROP_ALT", 
	"ICON_FA_CROSS", 
	"ICON_FA_CROSSHAIRS", 
	"ICON_FA_CROW", 
	"ICON_FA_CROWN", 
	"ICON_FA_CRUTCH", 
	"ICON_FA_CUBE", 
	"ICON_FA_CUBES", 
	"ICON_FA_CUT", 
	"ICON_FA_DATABASE", 
	"ICON_FA_DEAF", 
	"ICON_FA_DEMOCRAT", 
	"ICON_FA_DESKTOP", 
	"ICON_FA_DHARMACHAKRA", 
	"ICON_FA_DIAGNOSES", 
	"ICON_FA_DICE", 
	"ICON_FA_DICE_D20", 
	"ICON_FA_DICE_D6", 
	"ICON_FA_DICE_FIVE", 
	"ICON_FA_DICE_FOUR", 
	"ICON_FA_DICE_ONE", 
	"ICON_FA_DICE_SIX", 
	"ICON_FA_DICE_THREE", 
	"ICON_FA_DICE_TWO", 
	"ICON_FA_DIGITAL_TACHOGRAPH", 
	"ICON_FA_DIRECTIONS", 
	"ICON_FA_DISEASE", 
	"ICON_FA_DIVIDE", 
	"ICON_FA_DIZZY", 
	"ICON_FA_DNA", 
	"ICON_FA_DOG", 
	"ICON_FA_DOLLAR_SIGN", 
	"ICON_FA_DOLLY", 
	"ICON_FA_DOLLY_FLATBED", 
	"ICON_FA_DONATE", 
	"ICON_FA_DOOR_CLOSED", 
	"ICON_FA_DOOR_OPEN", 
	"ICON_FA_DOT_CIRCLE", 
	"ICON_FA_DOVE", 
	"ICON_FA_DOWNLOAD", 
	"ICON_FA_DRAFTING_COMPASS", 
	"ICON_FA_DRAGON", 
	"ICON_FA_DRAW_POLYGON", 
	"ICON_FA_DRUM", 
	"ICON_FA_DRUM_STEELPAN", 
	"ICON_FA_DRUMSTICK_BITE", 
	"ICON_FA_DUMBBELL", 
	"ICON_FA_DUMPSTER", 
	"ICON_FA_DUMPSTER_FIRE", 
	"ICON_FA_DUNGEON", 
	"ICON_FA_EDIT", 
	"ICON_FA_EGG", 
	"ICON_FA_EJECT", 
	"ICON_FA_ELLIPSIS_H", 
	"ICON_FA_ELLIPSIS_V", 
	"ICON_FA_ENVELOPE", 
	"ICON_FA_ENVELOPE_OPEN", 
	"ICON_FA_ENVELOPE_OPEN_TEXT", 
	"ICON_FA_ENVELOPE_SQUARE", 
	"ICON_FA_EQUALS", 
	"ICON_FA_ERASER", 
	"ICON_FA_ETHERNET", 
	"ICON_FA_EURO_SIGN", 
	"ICON_FA_EXCHANGE_ALT", 
	"ICON_FA_EXCLAMATION", 
	"ICON_FA_EXCLAMATION_CIRCLE", 
	"ICON_FA_EXCLAMATION_TRIANGLE", 
	"ICON_FA_EXPAND", 
	"ICON_FA_EXPAND_ALT", 
	"ICON_FA_EXPAND_ARROWS_ALT", 
	"ICON_FA_EXTERNAL_LINK_ALT", 
	"ICON_FA_EXTERNAL_LINK_SQUARE_ALT", 
	"ICON_FA_EYE", 
	"ICON_FA_EYE_DROPPER", 
	"ICON_FA_EYE_SLASH", 
	"ICON_FA_FAN", 
	"ICON_FA_FAST_BACKWARD", 
	"ICON_FA_FAST_FORWARD", 
	"ICON_FA_FAUCET", 
	"ICON_FA_FAX", 
	"ICON_FA_FEATHER", 
	"ICON_FA_FEATHER_ALT", 
	"ICON_FA_FEMALE", 
	"ICON_FA_FIGHTER_JET", 
	"ICON_FA_FILE", 
	"ICON_FA_FILE_ALT", 
	"ICON_FA_FILE_ARCHIVE", 
	"ICON_FA_FILE_AUDIO", 
	"ICON_FA_FILE_CODE", 
	"ICON_FA_FILE_CONTRACT", 
	"ICON_FA_FILE_CSV", 
	"ICON_FA_FILE_DOWNLOAD", 
	"ICON_FA_FILE_EXCEL", 
	"ICON_FA_FILE_EXPORT", 
	"ICON_FA_FILE_IMAGE", 
	"ICON_FA_FILE_IMPORT", 
	"ICON_FA_FILE_INVOICE", 
	"ICON_FA_FILE_INVOICE_DOLLAR", 
	"ICON_FA_FILE_MEDICAL", 
	"ICON_FA_FILE_MEDICAL_ALT", 
	"ICON_FA_FILE_PDF", 
	"ICON_FA_FILE_POWERPOINT", 
	"ICON_FA_FILE_PRESCRIPTION", 
	"ICON_FA_FILE_SIGNATURE", 
	"ICON_FA_FILE_UPLOAD", 
	"ICON_FA_FILE_VIDEO", 
	"ICON_FA_FILE_WORD", 
	"ICON_FA_FILL", 
	"ICON_FA_FILL_DRIP", 
	"ICON_FA_FILM", 
	"ICON_FA_FILTER", 
	"ICON_FA_FINGERPRINT", 
	"ICON_FA_FIRE", 
	"ICON_FA_FIRE_ALT", 
	"ICON_FA_FIRE_EXTINGUISHER", 
	"ICON_FA_FIRST_AID", 
	"ICON_FA_FISH", 
	"ICON_FA_FIST_RAISED", 
	"ICON_FA_FLAG", 
	"ICON_FA_FLAG_CHECKERED", 
	"ICON_FA_FLAG_USA", 
	"ICON_FA_FLASK", 
	"ICON_FA_FLUSHED", 
	"ICON_FA_FOLDER", 
	"ICON_FA_FOLDER_MINUS", 
	"ICON_FA_FOLDER_OPEN", 
	"ICON_FA_FOLDER_PLUS", 
	"ICON_FA_FONT", 
	"ICON_FA_FONT_AWESOME_LOGO_FULL", 
	"ICON_FA_FOOTBALL_BALL", 
	"ICON_FA_FORWARD", 
	"ICON_FA_FROG", 
	"ICON_FA_FROWN", 
	"ICON_FA_FROWN_OPEN", 
	"ICON_FA_FUNNEL_DOLLAR", 
	"ICON_FA_FUTBOL", 
	"ICON_FA_GAMEPAD", 
	"ICON_FA_GAS_PUMP", 
	"ICON_FA_GAVEL", 
	"ICON_FA_GEM", 
	"ICON_FA_GENDERLESS", 
	"ICON_FA_GHOST", 
	"ICON_FA_GIFT", 
	"ICON_FA_GIFTS", 
	"ICON_FA_GLASS_CHEERS", 
	"ICON_FA_GLASS_MARTINI", 
	"ICON_FA_GLASS_MARTINI_ALT", 
	"ICON_FA_GLASS_WHISKEY", 
	"ICON_FA_GLASSES", 
	"ICON_FA_GLOBE", 
	"ICON_FA_GLOBE_AFRICA", 
	"ICON_FA_GLOBE_AMERICAS", 
	"ICON_FA_GLOBE_ASIA", 
	"ICON_FA_GLOBE_EUROPE", 
	"ICON_FA_GOLF_BALL", 
	"ICON_FA_GOPURAM", 
	"ICON_FA_GRADUATION_CAP", 
	"ICON_FA_GREATER_THAN", 
	"ICON_FA_GREATER_THAN_EQUAL", 
	"ICON_FA_GRIMACE", 
	"ICON_FA_GRIN", 
	"ICON_FA_GRIN_ALT", 
	"ICON_FA_GRIN_BEAM", 
	"ICON_FA_GRIN_BEAM_SWEAT", 
	"ICON_FA_GRIN_HEARTS", 
	"ICON_FA_GRIN_SQUINT", 
	"ICON_FA_GRIN_SQUINT_TEARS", 
	"ICON_FA_GRIN_STARS", 
	"ICON_FA_GRIN_TEARS", 
	"ICON_FA_GRIN_TONGUE", 
	"ICON_FA_GRIN_TONGUE_SQUINT", 
	"ICON_FA_GRIN_TONGUE_WINK", 
	"ICON_FA_GRIN_WINK", 
	"ICON_FA_GRIP_HORIZONTAL", 
	"ICON_FA_GRIP_LINES", 
	"ICON_FA_GRIP_LINES_VERTICAL", 
	"ICON_FA_GRIP_VERTICAL", 
	"ICON_FA_GUITAR", 
	"ICON_FA_H_SQUARE", 
	"ICON_FA_HAMBURGER", 
	"ICON_FA_HAMMER", 
	"ICON_FA_HAMSA", 
	"ICON_FA_HAND_HOLDING", 
	"ICON_FA_HAND_HOLDING_HEART", 
	"ICON_FA_HAND_HOLDING_MEDICAL", 
	"ICON_FA_HAND_HOLDING_USD", 
	"ICON_FA_HAND_HOLDING_WATER", 
	"ICON_FA_HAND_LIZARD", 
	"ICON_FA_HAND_MIDDLE_FINGER", 
	"ICON_FA_HAND_PAPER", 
	"ICON_FA_HAND_PEACE", 
	"ICON_FA_HAND_POINT_DOWN", 
	"ICON_FA_HAND_POINT_LEFT", 
	"ICON_FA_HAND_POINT_RIGHT", 
	"ICON_FA_HAND_POINT_UP", 
	"ICON_FA_HAND_POINTER", 
	"ICON_FA_HAND_ROCK", 
	"ICON_FA_HAND_SCISSORS", 
	"ICON_FA_HAND_SPARKLES", 
	"ICON_FA_HAND_SPOCK", 
	"ICON_FA_HANDS", 
	"ICON_FA_HANDS_HELPING", 
	"ICON_FA_HANDS_WASH", 
	"ICON_FA_HANDSHAKE", 
	"ICON_FA_HANDSHAKE_ALT_SLASH", 
	"ICON_FA_HANDSHAKE_SLASH", 
	"ICON_FA_HANUKIAH", 
	"ICON_FA_HARD_HAT", 
	"ICON_FA_HASHTAG", 
	"ICON_FA_HAT_COWBOY", 
	"ICON_FA_HAT_COWBOY_SIDE", 
	"ICON_FA_HAT_WIZARD", 
	"ICON_FA_HDD", 
	"ICON_FA_HEAD_SIDE_COUGH", 
	"ICON_FA_HEAD_SIDE_COUGH_SLASH", 
	"ICON_FA_HEAD_SIDE_MASK", 
	"ICON_FA_HEAD_SIDE_VIRUS", 
	"ICON_FA_HEADING", 
	"ICON_FA_HEADPHONES", 
	"ICON_FA_HEADPHONES_ALT", 
	"ICON_FA_HEADSET", 
	"ICON_FA_HEART", 
	"ICON_FA_HEART_BROKEN", 
	"ICON_FA_HEARTBEAT", 
	"ICON_FA_HELICOPTER", 
	"ICON_FA_HIGHLIGHTER", 
	"ICON_FA_HIKING", 
	"ICON_FA_HIPPO", 
	"ICON_FA_HISTORY", 
	"ICON_FA_HOCKEY_PUCK", 
	"ICON_FA_HOLLY_BERRY", 
	"ICON_FA_HOME", 
	"ICON_FA_HORSE", 
	"ICON_FA_HORSE_HEAD", 
	"ICON_FA_HOSPITAL", 
	"ICON_FA_HOSPITAL_ALT", 
	"ICON_FA_HOSPITAL_SYMBOL", 
	"ICON_FA_HOSPITAL_USER", 
	"ICON_FA_HOT_TUB", 
	"ICON_FA_HOTDOG", 
	"ICON_FA_HOTEL", 
	"ICON_FA_HOURGLASS", 
	"ICON_FA_HOURGLASS_END", 
	"ICON_FA_HOURGLASS_HALF", 
	"ICON_FA_HOURGLASS_START", 
	"ICON_FA_HOUSE_DAMAGE", 
	"ICON_FA_HOUSE_USER", 
	"ICON_FA_HRYVNIA", 
	"ICON_FA_I_CURSOR", 
	"ICON_FA_ICE_CREAM", 
	"ICON_FA_ICICLES", 
	"ICON_FA_ICONS", 
	"ICON_FA_ID_BADGE", 
	"ICON_FA_ID_CARD", 
	"ICON_FA_ID_CARD_ALT", 
	"ICON_FA_IGLOO", 
	"ICON_FA_IMAGE", 
	"ICON_FA_IMAGES", 
	"ICON_FA_INBOX", 
	"ICON_FA_INDENT", 
	"ICON_FA_INDUSTRY", 
	"ICON_FA_INFINITY", 
	"ICON_FA_INFO", 
	"ICON_FA_INFO_CIRCLE", 
	"ICON_FA_ITALIC", 
	"ICON_FA_JEDI", 
	"ICON_FA_JOINT", 
	"ICON_FA_JOURNAL_WHILLS", 
	"ICON_FA_KAABA", 
	"ICON_FA_KEY", 
	"ICON_FA_KEYBOARD", 
	"ICON_FA_KHANDA", 
	"ICON_FA_KISS", 
	"ICON_FA_KISS_BEAM", 
	"ICON_FA_KISS_WINK_HEART", 
	"ICON_FA_KIWI_BIRD", 
	"ICON_FA_LANDMARK", 
	"ICON_FA_LANGUAGE", 
	"ICON_FA_LAPTOP", 
	"ICON_FA_LAPTOP_CODE", 
	"ICON_FA_LAPTOP_HOUSE", 
	"ICON_FA_LAPTOP_MEDICAL", 
	"ICON_FA_LAUGH", 
	"ICON_FA_LAUGH_BEAM", 
	"ICON_FA_LAUGH_SQUINT", 
	"ICON_FA_LAUGH_WINK", 
	"ICON_FA_LAYER_GROUP", 
	"ICON_FA_LEAF", 
	"ICON_FA_LEMON", 
	"ICON_FA_LESS_THAN", 
	"ICON_FA_LESS_THAN_EQUAL", 
	"ICON_FA_LEVEL_DOWN_ALT", 
	"ICON_FA_LEVEL_UP_ALT", 
	"ICON_FA_LIFE_RING", 
	"ICON_FA_LIGHTBULB", 
	"ICON_FA_LINK", 
	"ICON_FA_LIRA_SIGN", 
	"ICON_FA_LIST", 
	"ICON_FA_LIST_ALT", 
	"ICON_FA_LIST_OL", 
	"ICON_FA_LIST_UL", 
	"ICON_FA_LOCATION_ARROW", 
	"ICON_FA_LOCK", 
	"ICON_FA_LOCK_OPEN", 
	"ICON_FA_LONG_ARROW_ALT_DOWN", 
	"ICON_FA_LONG_ARROW_ALT_LEFT", 
	"ICON_FA_LONG_ARROW_ALT_RIGHT", 
	"ICON_FA_LONG_ARROW_ALT_UP", 
	"ICON_FA_LOW_VISION", 
	"ICON_FA_LUGGAGE_CART", 
	"ICON_FA_LUNGS", 
	"ICON_FA_LUNGS_VIRUS", 
	"ICON_FA_MAGIC", 
	"ICON_FA_MAGNET", 
	"ICON_FA_MAIL_BULK", 
	"ICON_FA_MALE", 
	"ICON_FA_MAP", 
	"ICON_FA_MAP_MARKED", 
	"ICON_FA_MAP_MARKED_ALT", 
	"ICON_FA_MAP_MARKER", 
	"ICON_FA_MAP_MARKER_ALT", 
	"ICON_FA_MAP_PIN", 
	"ICON_FA_MAP_SIGNS", 
	"ICON_FA_MARKER", 
	"ICON_FA_MARS", 
	"ICON_FA_MARS_DOUBLE", 
	"ICON_FA_MARS_STROKE", 
	"ICON_FA_MARS_STROKE_H", 
	"ICON_FA_MARS_STROKE_V", 
	"ICON_FA_MASK", 
	"ICON_FA_MEDAL", 
	"ICON_FA_MEDKIT", 
	"ICON_FA_MEH", 
	"ICON_FA_MEH_BLANK", 
	"ICON_FA_MEH_ROLLING_EYES", 
	"ICON_FA_MEMORY", 
	"ICON_FA_MENORAH", 
	"ICON_FA_MERCURY", 
	"ICON_FA_METEOR", 
	"ICON_FA_MICROCHIP", 
	"ICON_FA_MICROPHONE", 
	"ICON_FA_MICROPHONE_ALT", 
	"ICON_FA_MICROPHONE_ALT_SLASH", 
	"ICON_FA_MICROPHONE_SLASH", 
	"ICON_FA_MICROSCOPE", 
	"ICON_FA_MINUS", 
	"ICON_FA_MINUS_CIRCLE", 
	"ICON_FA_MINUS_SQUARE", 
	"ICON_FA_MITTEN", 
	"ICON_FA_MOBILE", 
	"ICON_FA_MOBILE_ALT", 
	"ICON_FA_MONEY_BILL", 
	"ICON_FA_MONEY_BILL_ALT", 
	"ICON_FA_MONEY_BILL_WAVE", 
	"ICON_FA_MONEY_BILL_WAVE_ALT", 
	"ICON_FA_MONEY_CHECK", 
	"ICON_FA_MONEY_CHECK_ALT", 
	"ICON_FA_MONUMENT", 
	"ICON_FA_MOON", 
	"ICON_FA_MORTAR_PESTLE", 
	"ICON_FA_MOSQUE", 
	"ICON_FA_MOTORCYCLE", 
	"ICON_FA_MOUNTAIN", 
	"ICON_FA_MOUSE", 
	"ICON_FA_MOUSE_POINTER", 
	"ICON_FA_MUG_HOT", 
	"ICON_FA_MUSIC", 
	"ICON_FA_NETWORK_WIRED", 
	"ICON_FA_NEUTER", 
	"ICON_FA_NEWSPAPER", 
	"ICON_FA_NOT_EQUAL", 
	"ICON_FA_NOTES_MEDICAL", 
	"ICON_FA_OBJECT_GROUP", 
	"ICON_FA_OBJECT_UNGROUP", 
	"ICON_FA_OIL_CAN", 
	"ICON_FA_OM", 
	"ICON_FA_OTTER", 
	"ICON_FA_OUTDENT", 
	"ICON_FA_PAGER", 
	"ICON_FA_PAINT_BRUSH", 
	"ICON_FA_PAINT_ROLLER", 
	"ICON_FA_PALETTE", 
	"ICON_FA_PALLET", 
	"ICON_FA_PAPER_PLANE", 
	"ICON_FA_PAPERCLIP", 
	"ICON_FA_PARACHUTE_BOX", 
	"ICON_FA_PARAGRAPH", 
	"ICON_FA_PARKING", 
	"ICON_FA_PASSPORT", 
	"ICON_FA_PASTAFARIANISM", 
	"ICON_FA_PASTE", 
	"ICON_FA_PAUSE", 
	"ICON_FA_PAUSE_CIRCLE", 
	"ICON_FA_PAW", 
	"ICON_FA_PEACE", 
	"ICON_FA_PEN", 
	"ICON_FA_PEN_ALT", 
	"ICON_FA_PEN_FANCY", 
	"ICON_FA_PEN_NIB", 
	"ICON_FA_PEN_SQUARE", 
	"ICON_FA_PENCIL_ALT", 
	"ICON_FA_PENCIL_RULER", 
	"ICON_FA_PEOPLE_ARROWS", 
	"ICON_FA_PEOPLE_CARRY", 
	"ICON_FA_PEPPER_HOT", 
	"ICON_FA_PERCENT", 
	"ICON_FA_PERCENTAGE", 
	"ICON_FA_PERSON_BOOTH", 
	"ICON_FA_PHONE", 
	"ICON_FA_PHONE_ALT", 
	"ICON_FA_PHONE_SLASH", 
	"ICON_FA_PHONE_SQUARE", 
	"ICON_FA_PHONE_SQUARE_ALT", 
	"ICON_FA_PHONE_VOLUME", 
	"ICON_FA_PHOTO_VIDEO", 
	"ICON_FA_PIGGY_BANK", 
	"ICON_FA_PILLS", 
	"ICON_FA_PIZZA_SLICE", 
	"ICON_FA_PLACE_OF_WORSHIP", 
	"ICON_FA_PLANE", 
	"ICON_FA_PLANE_ARRIVAL", 
	"ICON_FA_PLANE_DEPARTURE", 
	"ICON_FA_PLANE_SLASH", 
	"ICON_FA_PLAY", 
	"ICON_FA_PLAY_CIRCLE", 
	"ICON_FA_PLUG", 
	"ICON_FA_PLUS", 
	"ICON_FA_PLUS_CIRCLE", 
	"ICON_FA_PLUS_SQUARE", 
	"ICON_FA_PODCAST", 
	"ICON_FA_POLL", 
	"ICON_FA_POLL_H", 
	"ICON_FA_POO", 
	"ICON_FA_POO_STORM", 
	"ICON_FA_POOP", 
	"ICON_FA_PORTRAIT", 
	"ICON_FA_POUND_SIGN", 
	"ICON_FA_POWER_OFF", 
	"ICON_FA_PRAY", 
	"ICON_FA_PRAYING_HANDS", 
	"ICON_FA_PRESCRIPTION", 
	"ICON_FA_PRESCRIPTION_BOTTLE", 
	"ICON_FA_PRESCRIPTION_BOTTLE_ALT", 
	"ICON_FA_PRINT", 
	"ICON_FA_PROCEDURES", 
	"ICON_FA_PROJECT_DIAGRAM", 
	"ICON_FA_PUMP_MEDICAL", 
	"ICON_FA_PUMP_SOAP", 
	"ICON_FA_PUZZLE_PIECE", 
	"ICON_FA_QRCODE", 
	"ICON_FA_QUESTION", 
	"ICON_FA_QUESTION_CIRCLE", 
	"ICON_FA_QUIDDITCH", 
	"ICON_FA_QUOTE_LEFT", 
	"ICON_FA_QUOTE_RIGHT", 
	"ICON_FA_QURAN", 
	"ICON_FA_RADIATION", 
	"ICON_FA_RADIATION_ALT", 
	"ICON_FA_RAINBOW", 
	"ICON_FA_RANDOM", 
	"ICON_FA_RECEIPT", 
	"ICON_FA_RECORD_VINYL", 
	"ICON_FA_RECYCLE", 
	"ICON_FA_REDO", 
	"ICON_FA_REDO_ALT", 
	"ICON_FA_REGISTERED", 
	"ICON_FA_REMOVE_FORMAT", 
	"ICON_FA_REPLY", 
	"ICON_FA_REPLY_ALL", 
	"ICON_FA_REPUBLICAN", 
	"ICON_FA_RESTROOM", 
	"ICON_FA_RETWEET", 
	"ICON_FA_RIBBON", 
	"ICON_FA_RING", 
	"ICON_FA_ROAD", 
	"ICON_FA_ROBOT", 
	"ICON_FA_ROCKET", 
	"ICON_FA_ROUTE", 
	"ICON_FA_RSS", 
	"ICON_FA_RSS_SQUARE", 
	"ICON_FA_RUBLE_SIGN", 
	"ICON_FA_RULER", 
	"ICON_FA_RULER_COMBINED", 
	"ICON_FA_RULER_HORIZONTAL", 
	"ICON_FA_RULER_VERTICAL", 
	"ICON_FA_RUNNING", 
	"ICON_FA_RUPEE_SIGN", 
	"ICON_FA_SAD_CRY", 
	"ICON_FA_SAD_TEAR", 
	"ICON_FA_SATELLITE", 
	"ICON_FA_SATELLITE_DISH", 
	"ICON_FA_SAVE", 
	"ICON_FA_SCHOOL", 
	"ICON_FA_SCREWDRIVER", 
	"ICON_FA_SCROLL", 
	"ICON_FA_SD_CARD", 
	"ICON_FA_SEARCH", 
	"ICON_FA_SEARCH_DOLLAR", 
	"ICON_FA_SEARCH_LOCATION", 
	"ICON_FA_SEARCH_MINUS", 
	"ICON_FA_SEARCH_PLUS", 
	"ICON_FA_SEEDLING", 
	"ICON_FA_SERVER", 
	"ICON_FA_SHAPES", 
	"ICON_FA_SHARE", 
	"ICON_FA_SHARE_ALT", 
	"ICON_FA_SHARE_ALT_SQUARE", 
	"ICON_FA_SHARE_SQUARE", 
	"ICON_FA_SHEKEL_SIGN", 
	"ICON_FA_SHIELD_ALT", 
	"ICON_FA_SHIELD_VIRUS", 
	"ICON_FA_SHIP", 
	"ICON_FA_SHIPPING_FAST", 
	"ICON_FA_SHOE_PRINTS", 
	"ICON_FA_SHOPPING_BAG", 
	"ICON_FA_SHOPPING_BASKET", 
	"ICON_FA_SHOPPING_CART", 
	"ICON_FA_SHOWER", 
	"ICON_FA_SHUTTLE_VAN", 
	"ICON_FA_SIGN", 
	"ICON_FA_SIGN_IN_ALT", 
	"ICON_FA_SIGN_LANGUAGE", 
	"ICON_FA_SIGN_OUT_ALT", 
	"ICON_FA_SIGNAL", 
	"ICON_FA_SIGNATURE", 
	"ICON_FA_SIM_CARD", 
	"ICON_FA_SINK", 
	"ICON_FA_SITEMAP", 
	"ICON_FA_SKATING", 
	"ICON_FA_SKIING", 
	"ICON_FA_SKIING_NORDIC", 
	"ICON_FA_SKULL", 
	"ICON_FA_SKULL_CROSSBONES", 
	"ICON_FA_SLASH", 
	"ICON_FA_SLEIGH", 
	"ICON_FA_SLIDERS_H", 
	"ICON_FA_SMILE", 
	"ICON_FA_SMILE_BEAM", 
	"ICON_FA_SMILE_WINK", 
	"ICON_FA_SMOG", 
	"ICON_FA_SMOKING", 
	"ICON_FA_SMOKING_BAN", 
	"ICON_FA_SMS", 
	"ICON_FA_SNOWBOARDING", 
	"ICON_FA_SNOWFLAKE", 
	"ICON_FA_SNOWMAN", 
	"ICON_FA_SNOWPLOW", 
	"ICON_FA_SOAP", 
	"ICON_FA_SOCKS", 
	"ICON_FA_SOLAR_PANEL", 
	"ICON_FA_SORT", 
	"ICON_FA_SORT_ALPHA_DOWN", 
	"ICON_FA_SORT_ALPHA_DOWN_ALT", 
	"ICON_FA_SORT_ALPHA_UP", 
	"ICON_FA_SORT_ALPHA_UP_ALT", 
	"ICON_FA_SORT_AMOUNT_DOWN", 
	"ICON_FA_SORT_AMOUNT_DOWN_ALT", 
	"ICON_FA_SORT_AMOUNT_UP", 
	"ICON_FA_SORT_AMOUNT_UP_ALT", 
	"ICON_FA_SORT_DOWN", 
	"ICON_FA_SORT_NUMERIC_DOWN", 
	"ICON_FA_SORT_NUMERIC_DOWN_ALT", 
	"ICON_FA_SORT_NUMERIC_UP", 
	"ICON_FA_SORT_NUMERIC_UP_ALT", 
	"ICON_FA_SORT_UP", 
	"ICON_FA_SPA", 
	"ICON_FA_SPACE_SHUTTLE", 
	"ICON_FA_SPELL_CHECK", 
	"ICON_FA_SPIDER", 
	"ICON_FA_SPINNER", 
	"ICON_FA_SPLOTCH", 
	"ICON_FA_SPRAY_CAN", 
	"ICON_FA_SQUARE", 
	"ICON_FA_SQUARE_FULL", 
	"ICON_FA_SQUARE_ROOT_ALT", 
	"ICON_FA_STAMP", 
	"ICON_FA_STAR", 
	"ICON_FA_STAR_AND_CRESCENT", 
	"ICON_FA_STAR_HALF", 
	"ICON_FA_STAR_HALF_ALT", 
	"ICON_FA_STAR_OF_DAVID", 
	"ICON_FA_STAR_OF_LIFE", 
	"ICON_FA_STEP_BACKWARD", 
	"ICON_FA_STEP_FORWARD", 
	"ICON_FA_STETHOSCOPE", 
	"ICON_FA_STICKY_NOTE", 
	"ICON_FA_STOP", 
	"ICON_FA_STOP_CIRCLE", 
	"ICON_FA_STOPWATCH", 
	"ICON_FA_STOPWATCH_20", 
	"ICON_FA_STORE", 
	"ICON_FA_STORE_ALT", 
	"ICON_FA_STORE_ALT_SLASH", 
	"ICON_FA_STORE_SLASH", 
	"ICON_FA_STREAM", 
	"ICON_FA_STREET_VIEW", 
	"ICON_FA_STRIKETHROUGH", 
	"ICON_FA_STROOPWAFEL", 
	"ICON_FA_SUBSCRIPT", 
	"ICON_FA_SUBWAY", 
	"ICON_FA_SUITCASE", 
	"ICON_FA_SUITCASE_ROLLING", 
	"ICON_FA_SUN", 
	"ICON_FA_SUPERSCRIPT", 
	"ICON_FA_SURPRISE", 
	"ICON_FA_SWATCHBOOK", 
	"ICON_FA_SWIMMER", 
	"ICON_FA_SWIMMING_POOL", 
	"ICON_FA_SYNAGOGUE", 
	"ICON_FA_SYNC", 
	"ICON_FA_SYNC_ALT", 
	"ICON_FA_SYRINGE", 
	"ICON_FA_TABLE", 
	"ICON_FA_TABLE_TENNIS", 
	"ICON_FA_TABLET", 
	"ICON_FA_TABLET_ALT", 
	"ICON_FA_TABLETS", 
	"ICON_FA_TACHOMETER_ALT", 
	"ICON_FA_TAG", 
	"ICON_FA_TAGS", 
	"ICON_FA_TAPE", 
	"ICON_FA_TASKS", 
	"ICON_FA_TAXI", 
	"ICON_FA_TEETH", 
	"ICON_FA_TEETH_OPEN", 
	"ICON_FA_TEMPERATURE_HIGH", 
	"ICON_FA_TEMPERATURE_LOW", 
	"ICON_FA_TENGE", 
	"ICON_FA_TERMINAL", 
	"ICON_FA_TEXT_HEIGHT", 
	"ICON_FA_TEXT_WIDTH", 
	"ICON_FA_TH", 
	"ICON_FA_TH_LARGE", 
	"ICON_FA_TH_LIST", 
	"ICON_FA_THEATER_MASKS", 
	"ICON_FA_THERMOMETER", 
	"ICON_FA_THERMOMETER_EMPTY", 
	"ICON_FA_THERMOMETER_FULL", 
	"ICON_FA_THERMOMETER_HALF", 
	"ICON_FA_THERMOMETER_QUARTER", 
	"ICON_FA_THERMOMETER_THREE_QUARTERS", 
	"ICON_FA_THUMBS_DOWN", 
	"ICON_FA_THUMBS_UP", 
	"ICON_FA_THUMBTACK", 
	"ICON_FA_TICKET_ALT", 
	"ICON_FA_TIMES", 
	"ICON_FA_TIMES_CIRCLE", 
	"ICON_FA_TINT", 
	"ICON_FA_TINT_SLASH", 
	"ICON_FA_TIRED", 
	"ICON_FA_TOGGLE_OFF", 
	"ICON_FA_TOGGLE_ON", 
	"ICON_FA_TOILET", 
	"ICON_FA_TOILET_PAPER", 
	"ICON_FA_TOILET_PAPER_SLASH", 
	"ICON_FA_TOOLBOX", 
	"ICON_FA_TOOLS", 
	"ICON_FA_TOOTH", 
	"ICON_FA_TORAH", 
	"ICON_FA_TORII_GATE", 
	"ICON_FA_TRACTOR", 
	"ICON_FA_TRADEMARK", 
	"ICON_FA_TRAFFIC_LIGHT", 
	"ICON_FA_TRAILER", 
	"ICON_FA_TRAIN", 
	"ICON_FA_TRAM", 
	"ICON_FA_TRANSGENDER", 
	"ICON_FA_TRANSGENDER_ALT", 
	"ICON_FA_TRASH", 
	"ICON_FA_TRASH_ALT", 
	"ICON_FA_TRASH_RESTORE", 
	"ICON_FA_TRASH_RESTORE_ALT", 
	"ICON_FA_TREE", 
	"ICON_FA_TROPHY", 
	"ICON_FA_TRUCK", 
	"ICON_FA_TRUCK_LOADING", 
	"ICON_FA_TRUCK_MONSTER", 
	"ICON_FA_TRUCK_MOVING", 
	"ICON_FA_TRUCK_PICKUP", 
	"ICON_FA_TSHIRT", 
	"ICON_FA_TTY", 
	"ICON_FA_TV", 
	"ICON_FA_UMBRELLA", 
	"ICON_FA_UMBRELLA_BEACH", 
	"ICON_FA_UNDERLINE", 
	"ICON_FA_UNDO", 
	"ICON_FA_UNDO_ALT", 
	"ICON_FA_UNIVERSAL_ACCESS", 
	"ICON_FA_UNIVERSITY", 
	"ICON_FA_UNLINK", 
	"ICON_FA_UNLOCK", 
	"ICON_FA_UNLOCK_ALT", 
	"ICON_FA_UPLOAD", 
	"ICON_FA_USER", 
	"ICON_FA_USER_ALT", 
	"ICON_FA_USER_ALT_SLASH", 
	"ICON_FA_USER_ASTRONAUT", 
	"ICON_FA_USER_CHECK", 
	"ICON_FA_USER_CIRCLE", 
	"ICON_FA_USER_CLOCK", 
	"ICON_FA_USER_COG", 
	"ICON_FA_USER_EDIT", 
	"ICON_FA_USER_FRIENDS", 
	"ICON_FA_USER_GRADUATE", 
	"ICON_FA_USER_INJURED", 
	"ICON_FA_USER_LOCK", 
	"ICON_FA_USER_MD", 
	"ICON_FA_USER_MINUS", 
	"ICON_FA_USER_NINJA", 
	"ICON_FA_USER_NURSE", 
	"ICON_FA_USER_PLUS", 
	"ICON_FA_USER_SECRET", 
	"ICON_FA_USER_SHIELD", 
	"ICON_FA_USER_SLASH", 
	"ICON_FA_USER_TAG", 
	"ICON_FA_USER_TIE", 
	"ICON_FA_USER_TIMES", 
	"ICON_FA_USERS", 
	"ICON_FA_USERS_COG", 
	"ICON_FA_USERS_SLASH", 
	"ICON_FA_UTENSIL_SPOON", 
	"ICON_FA_UTENSILS", 
	"ICON_FA_VECTOR_SQUARE", 
	"ICON_FA_VENUS", 
	"ICON_FA_VENUS_DOUBLE", 
	"ICON_FA_VENUS_MARS", 
	"ICON_FA_VIAL", 
	"ICON_FA_VIALS", 
	"ICON_FA_VIDEO", 
	"ICON_FA_VIDEO_SLASH", 
	"ICON_FA_VIHARA", 
	"ICON_FA_VIRUS", 
	"ICON_FA_VIRUS_SLASH", 
	"ICON_FA_VIRUSES", 
	"ICON_FA_VOICEMAIL", 
	"ICON_FA_VOLLEYBALL_BALL", 
	"ICON_FA_VOLUME_DOWN", 
	"ICON_FA_VOLUME_MUTE", 
	"ICON_FA_VOLUME_OFF", 
	"ICON_FA_VOLUME_UP", 
	"ICON_FA_VOTE_YEA", 
	"ICON_FA_VR_CARDBOARD", 
	"ICON_FA_WALKING", 
	"ICON_FA_WALLET", 
	"ICON_FA_WAREHOUSE", 
	"ICON_FA_WATER", 
	"ICON_FA_WAVE_SQUARE", 
	"ICON_FA_WEIGHT", 
	"ICON_FA_WEIGHT_HANGING", 
	"ICON_FA_WHEELCHAIR", 
	"ICON_FA_WIFI", 
	"ICON_FA_WIND", 
	"ICON_FA_WINDOW_CLOSE", 
	"ICON_FA_WINDOW_MAXIMIZE", 
	"ICON_FA_WINDOW_MINIMIZE", 
	"ICON_FA_WINDOW_RESTORE", 
	"ICON_FA_WINE_BOTTLE", 
	"ICON_FA_WINE_GLASS", 
	"ICON_FA_WINE_GLASS_ALT", 
	"ICON_FA_WON_SIGN", 
	"ICON_FA_WRENCH", 
	"ICON_FA_X_RAY", 
	"ICON_FA_YEN_SIGN", 
	"ICON_FA_YIN_YANG", 
};

```

`ext/half/half.c`:

```c
// Branch-free implementation of half-precision (16 bit) floating point
// Copyright 2006 Mike Acton <macton@gmail.com>
// 
// Preferred compile flags for GCC: 
//     -O3 -fstrict-aliasing -std=c99 -pedantic -Wall -Wstrict-aliasing
//
// Half-precision floating point format
// ------------------------------------
//
//   | Field    | Last | First | Note
//   |----------|------|-------|----------
//   | Sign     | 15   | 15    |
//   | Exponent | 14   | 10    | Bias = 15
//   | Mantissa | 9    | 0     |
//
// Note: USE A BETTER COMPILER
// ---------------------------
//
//     This file is a C99 source file, intended to be compiled with a C99 
//     compliant compiler. However, for the moment it remains combatible
//     with C++98. Therefore if you are using a compiler that poorly implements
//     C standards (e.g. MSVC), it may be compiled as C++. This is not
//     guaranteed for future versions. 
//
// Features
// --------
//
//     * QNaN + <x>  = QNaN
//     * <x>  + +INF = +INF
//     * <x>  - -INF = -INF
//     * INF  - INF  = SNaN
//     * Denormalized values
//     * Difference of ZEROs is always +ZERO
//     * Sum round with guard + round + sticky bit (grs)
//     * And of course... no branching
// 
// Precision of Sum
// ----------------
//
//     uint16_t z = half_add( x, y );
//
//     Will have exactly (0 ulps difference) the same result as:
//     (For 32 bit IEEE 784 floating point and same rounding mode)
//
//     union FLOAT_32
//     {
//       float    f32;
//       uint32_t u32;
//     };
//
//     union FLOAT_32 fx = { .u32 = half_to_float( x ) };
//     union FLOAT_32 fy = { .u32 = half_to_float( y ) };
//     union FLOAT_32 fz = { .f32 = fx.f32 + fy.f32    };
//     uint16_t       z  = float_to_half( fz );
//
// Precision of Difference
// -----------------------
//
//     uint16_t z = half_add( x, -y );
//
//     Will have exactly (0 ulps difference) the same result as:
//     (For 32 bit IEEE 784 floating point and same rounding mode)
//
//     union FLOAT_32
//     {
//       float    f32;
//       uint32_t u32;
//     };
//
//     union FLOAT_32 fx = { .u32 = half_to_float( x ) };
//     union FLOAT_32 fy = { .u32 = half_to_float( y ) };
//     union FLOAT_32 fz = { .f32 = fx.f32 - fy.f32    };
//     uint16_t       z  = float_to_half( fz.u32 );

#pragma warning( disable : 4146 )

#include "int_insn.h"
#include "half.h"

uint32_t
half_to_float( uint16_t h )
{
  const uint16_t one                  = 0x0001;
  const uint16_t two                  = 0x0002;
  const uint32_t f_e_mask             = 0x7f800000;
  const uint32_t f_m_mask             = 0x007fffff;
  const uint16_t f_e_bias             = 0x007f;
  const uint16_t h_e_bias             = 0x000f;
  const uint16_t h_s_mask             = 0x8000;
  const uint16_t h_e_mask             = 0x7c00;
  const uint16_t h_m_mask             = 0x03ff;
  const uint16_t h_e_pos              = 0x000a;
  const uint16_t f_e_pos              = 0x0017;
  const uint16_t f_s_pos              = 0x001f;
  const uint16_t h_s_pos              = 0x000f;
  const uint16_t h_f_denorm_sa_offset = 0x000a;
  const uint32_t h_f_bias_offset      = uint16_sub( h_e_bias, f_e_bias );
  const uint16_t h_f_s_pos_offset     = uint16_sub( f_s_pos, h_s_pos );
  const uint16_t h_f_m_pos_offset     = uint16_sub( f_e_pos, h_e_pos );
  const uint32_t h_s                  = uint32_and( h, h_s_mask );
  const uint32_t h_e                  = uint32_and( h, h_e_mask );
  const uint16_t h_m                  = uint32_and( h, h_m_mask );
  const uint32_t f_s                  = uint32_sll( h_s, h_f_s_pos_offset );
  const uint16_t h_e_half_bias        = uint16_srl( h_e, h_e_pos );
  const uint32_t f_e                  = uint16_sub( h_e_half_bias, h_f_bias_offset );
  const uint32_t f_m                  = uint32_sll( h_m, h_f_m_pos_offset );
  const uint32_t is_e_nezero          = uint32_nez( h_e );
  const uint32_t is_m_nezero          = uint32_nez( h_m );
  const uint32_t is_zero              = uint32_nor( is_e_nezero, is_m_nezero );
  const uint32_t is_denorm            = uint32_nor( is_zero, is_e_nezero );
  const uint32_t is_e_flagged         = uint32_eq( h_e, h_e_mask );
  const uint32_t is_inf               = uint32_andc( is_e_flagged, is_m_nezero );
  const uint32_t is_nan               = uint32_and( is_e_flagged,  is_m_nezero ); 
  const uint16_t h_m_nlz              = uint16_cntlz( h_m );
  const uint16_t h_denorm_sa          = uint32_add( h_m_nlz, h_f_denorm_sa_offset );
  const uint32_t h_f_denorm_m_sa      = uint32_sub( h_denorm_sa, two );
  const uint32_t h_f_denorm_m         = uint32_sll( h_m, h_f_denorm_m_sa );
  const uint32_t f_denorm_m           = uint32_and( h_f_denorm_m, f_m_mask );
  const uint32_t h_f_denorm_sa        = uint32_sub( one, h_denorm_sa );
  const uint32_t f_denorm_e           = uint32_add( h_f_denorm_sa, f_e_bias );
  const uint32_t f_denorm_e_packed    = uint32_sll( f_denorm_e, f_e_pos );
  const uint32_t f_denorm             = uint32_or3( f_s, f_denorm_e_packed, f_denorm_m );
  const uint32_t f_inf                = uint32_or( f_s,  f_e_mask );
  const uint32_t f_nan                = uint32_or3( f_s, f_e_mask, f_m );
  const uint32_t f_zero               = uint32_cp( f_s );
  const uint32_t f_e_packed           = uint32_sll( f_e, f_e_pos );
  const uint32_t packed               = uint32_or3( f_s, f_e_packed, f_m );
  const uint32_t check_zero_result    = uint32_mux( is_zero, f_zero, packed );
  const uint32_t check_denorm_result  = uint32_mux( is_denorm, f_denorm, check_zero_result );
  const uint32_t check_inf_result     = uint32_mux( is_inf, f_inf, check_denorm_result );
  const uint32_t check_nan_result     = uint32_mux( is_nan, f_nan, check_inf_result    );
  const uint32_t result               = check_nan_result;

  return (result);
}

uint16_t
half_from_float( uint32_t f )
{
  const uint16_t one                        = 0x0001;
  const uint32_t f_s_mask                   = 0x80000000;
  const uint32_t f_e_mask                   = 0x7f800000;
  const uint32_t f_m_mask                   = 0x007fffff;
  const uint32_t f_m_hidden_bit             = 0x00800000;
  const uint32_t f_m_round_bit              = 0x00001000;
  const uint32_t f_snan_mask                = 0x7fc00000;
  const uint16_t f_e_bias                   = 0x007f;
  const uint16_t h_e_bias                   = 0x000f;
  const uint16_t f_s_pos                    = 0x001f;
  const uint16_t h_s_pos                    = 0x000f;
  const uint16_t f_e_pos                    = 0x0017;
  const uint16_t h_e_pos                    = 0x000a;
  const uint16_t h_e_mask                   = 0x7c00;
  const uint16_t h_snan_mask                = 0x7e00;
  const uint16_t f_e_flagged_value          = 0x00ff;
  const uint16_t h_e_mask_value             = uint16_srl( h_e_mask, h_e_pos );
  const uint16_t f_h_s_pos_offset           = uint16_sub( f_s_pos, h_s_pos );
  const uint16_t f_h_bias_offset            = uint16_sub( f_e_bias, h_e_bias );
  const uint16_t f_h_m_pos_offset           = uint16_sub( f_e_pos, h_e_pos );
  const uint16_t h_nan_min                  = uint16_or( h_e_mask, one );
  const uint32_t f_s_masked                 = uint32_and( f, f_s_mask );
  const uint32_t f_e_masked                 = uint32_and( f, f_e_mask );
  const uint16_t h_s                        = uint32_srl( f_s_masked, f_h_s_pos_offset );
  const uint16_t f_e                        = uint32_srl( f_e_masked, f_e_pos );
  const uint32_t f_m                        = uint32_and( f, f_m_mask );
  const uint16_t f_e_half_bias              = uint16_sub( f_e, f_h_bias_offset );
  const uint32_t f_m_round_mask             = uint32_and( f_m, f_m_round_bit );
  const uint32_t f_m_round_offset           = uint32_sll( f_m_round_mask, one );
  const uint32_t f_m_rounded                = uint32_add( f_m, f_m_round_offset );
  const uint32_t f_m_denorm_sa              = uint32_sub( one, f_e_half_bias );
  const uint32_t f_m_with_hidden            = uint32_or( f_m_rounded, f_m_hidden_bit );
  const uint32_t f_m_denorm                 = uint32_srl( f_m_with_hidden, f_m_denorm_sa );
  const uint16_t h_m_denorm                 = uint32_srl( f_m_denorm, f_h_m_pos_offset );
  const uint16_t h_denorm                   = uint16_or( h_s, h_m_denorm );
  const uint16_t h_inf                      = uint16_or( h_s, h_e_mask );
  const uint16_t m_nan                      = uint32_srl( f_m, f_h_m_pos_offset );
  const uint16_t h_nan                      = uint16_or3( h_s, h_e_mask, m_nan );
  const uint16_t h_nan_notinf               = uint16_or( h_s, h_nan_min );
  const uint16_t h_e_norm_overflow_offset   = uint16_add( f_e_half_bias, one );
  const uint16_t h_e_norm_overflow          = uint16_sll( h_e_norm_overflow_offset, h_e_pos );
  const uint16_t h_norm_overflow            = uint16_or( h_s, h_e_norm_overflow );
  const uint16_t h_e_norm                   = uint16_sll( f_e_half_bias, h_e_pos );
  const uint16_t h_m_norm                   = uint32_srl( f_m_rounded, f_h_m_pos_offset );
  const uint16_t h_norm                     = uint16_or3( h_s, h_e_norm, h_m_norm );
  const uint16_t is_h_denorm                = uint16_gte( f_h_bias_offset, f_e );
  const uint16_t f_h_e_biased_flag          = uint16_sub( f_e_flagged_value, f_h_bias_offset );
  const uint16_t is_f_e_flagged             = uint16_eq( f_e_half_bias, f_h_e_biased_flag );
  const uint16_t is_f_m_zero                = uint32_eqz( f_m );
  const uint16_t is_h_nan_zero              = uint16_eqz( m_nan );
  const uint16_t is_f_inf                   = uint16_and( is_f_e_flagged, is_f_m_zero );
  const uint16_t is_f_nan_underflow         = uint16_and( is_f_e_flagged, is_h_nan_zero );
  const uint16_t is_f_nan                   = uint16_cp( is_f_e_flagged );
  const uint16_t is_e_overflow              = uint16_gt( f_e_half_bias, h_e_mask_value );
  const uint32_t f_m_rounded_overflow       = uint32_and( f_m_rounded, f_m_hidden_bit );
  const uint32_t is_m_norm_overflow         = uint32_nez( f_m_rounded_overflow );
  const uint16_t is_h_inf                   = uint16_or( is_e_overflow, is_f_inf );
  const uint32_t f_snan                     = uint32_and( f, f_snan_mask );
  const uint32_t is_f_snan                  = uint32_eq( f_snan, f_snan_mask );
  const uint16_t h_snan                     = uint16_or( h_s, h_snan_mask );
  const uint16_t check_overflow_result      = uint16_mux( is_m_norm_overflow, h_norm_overflow, h_norm );
  const uint16_t check_nan_result           = uint16_mux( is_f_nan, h_nan, check_overflow_result );
  const uint16_t check_nan_underflow_result = uint16_mux( is_f_nan_underflow, h_nan_notinf,    check_nan_result );
  const uint16_t check_inf_result           = uint16_mux( is_h_inf, h_inf, check_nan_underflow_result );
  const uint16_t check_denorm_result        = uint16_mux( is_h_denorm, h_denorm, check_inf_result );
  const uint16_t check_snan_result          = uint16_mux( is_f_snan, h_snan, check_denorm_result );
  const uint16_t result                     = uint16_cp( check_snan_result );

  return (result);
}

uint16_t
half_add( uint16_t x, uint16_t y )
{
  const uint16_t one                  = 0x0001;
  const uint16_t h_s_mask             = 0x8000;
  const uint16_t h_e_mask             = 0x7c00;
  const uint16_t h_m_mask             = 0x03ff;
  const uint16_t h_m_msb_mask         = 0x2000;
  const uint16_t h_m_hidden           = 0x0400;
  const uint16_t h_e_pos              = 0x000a;
  const uint16_t h_e_bias             = 0x000f;
  const uint16_t h_m_grs_carry        = 0x4000;
  const uint16_t h_m_grs_carry_pos    = 0x000e;
  const uint16_t h_grs_size           = 0x0003;
  const uint16_t h_snan               = 0xfe00;
  const uint16_t h_grs_round_carry    = uint16_sll( one, h_grs_size );
  const uint16_t h_grs_round_mask     = uint16_sub( h_grs_round_carry, one );

  const uint16_t x_s                  = uint16_and( x, h_s_mask );
  const uint16_t x_e                  = uint16_and( x, h_e_mask );
  const uint16_t x_m                  = uint16_and( x, h_m_mask );
  const uint16_t y_s                  = uint16_and( y, h_s_mask );
  const uint16_t y_e                  = uint16_and( y, h_e_mask );
  const uint16_t y_m                  = uint16_and( y, h_m_mask );

  const uint16_t is_y_e_larger        = uint16_gt( y_e, x_e );
  const uint16_t a_s                  = uint16_mux( is_y_e_larger, y_s, x_s );
  const uint16_t a_e                  = uint16_mux( is_y_e_larger, y_e, x_e );
  const uint16_t a_m_no_hidden_bit    = uint16_mux( is_y_e_larger, y_m, x_m );
  const uint16_t b_s                  = uint16_mux( is_y_e_larger, x_s, y_s );
  const uint16_t b_e                  = uint16_mux( is_y_e_larger, x_e, y_e );
  const uint16_t b_m_no_hidden_bit    = uint16_mux( is_y_e_larger, x_m, y_m );

  const uint16_t a_e_unbias           = uint16_sub( a_e, h_e_bias );
  const uint16_t a_e_unbias_adj       = uint16_sub( a_e_unbias, one );
  const uint16_t m_sa_unbias          = uint16_srl( a_e_unbias_adj, h_e_pos );
  const uint16_t diff_e               = uint16_sub( a_e, b_e );
  const uint16_t m_sa_default         = uint16_srl( diff_e, h_e_pos );
  const uint16_t b_e_c_mask           = uint16_eqz( b_e );
  const uint16_t a_e_nez_mask         = uint16_nez( a_e );
  const uint16_t m_sa_unbias_mask     = uint16_and( b_e_c_mask, a_e_nez_mask );
  const uint16_t m_sa                 = uint16_mux( m_sa_unbias_mask, m_sa_unbias, m_sa_default );

  const uint16_t a_e_m_no_hidden_bit  = uint16_or( a_e, a_m_no_hidden_bit );
  const uint16_t a_e_nzero            = uint16_nez( a_e );
  const uint16_t a_m_hidden_bit       = uint16_and( a_e_nzero, h_m_hidden );
  const uint16_t a_m_no_grs           = uint16_or( a_m_no_hidden_bit, a_m_hidden_bit );
  const uint16_t a_m                  = uint16_sll( a_m_no_grs, h_grs_size );

  const uint16_t b_e_m_no_hidden_bit  = uint16_or( b_e, b_m_no_hidden_bit );
  const uint16_t b_e_nzero            = uint16_nez( b_e );
  const uint16_t b_m_hidden_bit       = uint16_and( b_e_nzero, h_m_hidden );
  const uint16_t b_m_no_grs           = uint16_or( b_m_no_hidden_bit, b_m_hidden_bit );
  const uint16_t b_m_no_sticky        = uint16_sll( b_m_no_grs, h_grs_size );
  const uint16_t sh_m                 = uint16_srl( b_m_no_sticky, m_sa );
  const uint16_t sticky_overflow      = uint16_sll( one, m_sa );
  const uint16_t sticky_mask          = uint16_sub( sticky_overflow, one );
  const uint16_t sticky_collect       = uint16_and( b_m_no_sticky, sticky_mask );
  const uint16_t sticky               = uint16_nez_p( sticky_collect );
  const uint16_t b_m                  = uint16_or( sh_m, sticky );

  const uint16_t sel_sign             = uint16_xor( a_s, b_s );
  const uint16_t is_diff_sign         = uint16_nez( sel_sign );
  const uint16_t c_m_diff_ab          = uint16_sub( a_m, b_m );
  const uint16_t c_m_diff_ba          = uint16_sub( b_m, a_m );
  const uint16_t is_c_m_ab_pos        = uint16_gt( a_m, b_m );
  const uint16_t c_m_smag_diff        = uint16_mux( is_c_m_ab_pos, c_m_diff_ab, c_m_diff_ba );
  const uint16_t c_s_diff             = uint16_mux( is_c_m_ab_pos, a_s, b_s );
  const uint16_t c_s                  = uint16_mux( is_diff_sign, c_s_diff, a_s );

  const uint16_t is_a_inf             = uint16_eq( a_e_m_no_hidden_bit, h_e_mask );
  const uint16_t a_inf                = uint16_or( a_s, h_e_mask );
  const uint16_t is_b_inf             = uint16_eq( b_e_m_no_hidden_bit, h_e_mask );
  const uint16_t a_e_biased           = uint16_srl( a_e, h_e_pos );
  const uint16_t c_m_sum              = uint16_add( a_m, b_m );
  const uint16_t c_m_smag_diff_nlz    = uint16_cntlz( c_m_smag_diff );
  const uint16_t diff_norm_sa         = uint16_sub( c_m_smag_diff_nlz, one );
  const uint16_t is_diff_denorm       = uint16_lt( a_e_biased, diff_norm_sa );
  const uint16_t diff_denorm_sa       = uint16_sub( a_e_biased, one );
  const uint16_t c_m_diff_denorm      = uint16_sll( c_m_smag_diff, diff_denorm_sa );
  const uint16_t c_m_diff_norm        = uint16_sll( c_m_smag_diff, diff_norm_sa );
  const uint16_t c_e_diff_norm        = uint16_sub( a_e_biased,  diff_norm_sa );
  const uint16_t is_a_or_b_norm       = uint16_nez( a_e_biased );
  const uint16_t c_m_diff_ab_norm     = uint16_mux( is_diff_denorm, c_m_diff_denorm, c_m_diff_norm );

  const uint16_t c_e_diff_ab_norm     = uint16_andc( c_e_diff_norm, is_diff_denorm );
  const uint16_t c_m_diff_ab_denorm   = uint16_cp( c_m_smag_diff );
  const uint16_t c_e_diff_ab_denorm   = uint16_cp( a_e_biased );
  const uint16_t c_m_diff             = uint16_mux( is_a_or_b_norm, c_m_diff_ab_norm, c_m_diff_ab_denorm );
  const uint16_t c_e_diff             = uint16_mux( is_a_or_b_norm, c_e_diff_ab_norm, c_e_diff_ab_denorm );
  const uint16_t is_diff_zero         = uint16_eqz( c_m_diff );
  const uint16_t is_diff_exactly_zero = uint16_and( is_diff_sign, is_diff_zero );
  const uint16_t c_m_added            = uint16_mux( is_diff_sign, c_m_diff, c_m_sum );
  const uint16_t c_e_added            = uint16_mux( is_diff_sign, c_e_diff, a_e_biased );
  const uint16_t c_m_carry            = uint16_and( c_m_added, h_m_grs_carry );
  const uint16_t is_c_m_carry         = uint16_nez( c_m_carry );
  const uint16_t c_e_hidden_offset    = uint16_andsrl( c_m_added, h_m_grs_carry, h_m_grs_carry_pos);
  const uint16_t c_m_sub_hidden       = uint16_srl( c_m_added, one );
  const uint16_t c_m_no_hidden        = uint16_mux( is_c_m_carry, c_m_sub_hidden, c_m_added );
  const uint16_t c_e_no_hidden        = uint16_add( c_e_added, c_e_hidden_offset );
  const uint16_t is_undenorm          = uint16_eqz_p( a_e );
  const uint16_t c_m_no_hidden_msb    = uint16_and( c_m_no_hidden, h_m_msb_mask );
  const uint16_t undenorm_m_msb_odd   = uint16_nez_p( c_m_no_hidden_msb );
  const uint16_t undenorm_fix_e       = uint16_and( is_undenorm, undenorm_m_msb_odd );
  const uint16_t c_e_fixed            = uint16_add( c_e_no_hidden, undenorm_fix_e );
  const uint16_t c_m_round_amount     = uint16_and( c_m_no_hidden, h_grs_round_mask );
  const uint16_t c_m_rounded          = uint16_add( c_m_no_hidden, c_m_round_amount );
  const uint16_t c_m_round_overflow   = uint16_andsrl( c_m_rounded, h_m_grs_carry, h_m_grs_carry_pos );
  const uint16_t c_e_rounded          = uint16_add( c_e_fixed, c_m_round_overflow );
  const uint16_t c_m_no_grs           = uint16_srlm( c_m_rounded, h_grs_size,  h_m_mask );
  const uint16_t c_e                  = uint16_sll( c_e_rounded, h_e_pos );
  const uint16_t c_packed             = uint16_or3( c_s, c_e, c_m_no_grs );
  const uint16_t is_b_neg             = uint16_nez( b_s );
  const uint16_t is_both_inf          = uint16_and( is_a_inf, is_b_inf );
  const uint16_t is_invalid_inf_op    = uint16_and( is_both_inf, is_b_neg );
  const uint16_t check_inf_result     = uint16_mux( is_a_inf, a_inf, c_packed );
  const uint16_t check_zero_result    = uint16_andc( check_inf_result, is_diff_exactly_zero );
  const uint16_t check_invalid_inf_op = uint16_mux( is_invalid_inf_op, h_snan, check_zero_result );
  const uint16_t result               = uint16_cp( check_invalid_inf_op );

  return (result);
}

uint16_t
half_mul( uint16_t x, uint16_t y )
{
  uint16_t one                  = 0x0001;
  uint16_t h_s_mask             = 0x8000;
  uint16_t h_e_mask             = 0x7c00;
  uint16_t h_m_mask             = 0x03ff;
  uint16_t h_m_msb_mask         = 0x2000;
  uint16_t h_m_hidden           = 0x0400;
  uint16_t h_e_pos              = 0x000a;
  uint16_t h_e_bias             = 0x000f;
  uint16_t h_m_grs_carry        = 0x4000;
  uint16_t h_m_grs_carry_pos    = 0x000e;
  uint16_t h_grs_size           = 0x0003;
  uint16_t h_snan               = 0xfe00;
  uint16_t h_grs_round_carry    = uint16_sll( one, h_grs_size );
  uint16_t h_grs_round_mask     = uint16_sub( h_grs_round_carry, one );
  uint16_t x_s                  = uint16_and( x, h_s_mask );
  uint16_t x_e                  = uint16_and( x, h_e_mask );
  uint16_t x_m                  = uint16_and( x, h_m_mask );
  uint16_t y_s                  = uint16_and( y, h_s_mask );
  uint16_t y_e                  = uint16_and( y, h_e_mask );
  uint16_t y_m                  = uint16_and( y, h_m_mask );
  uint16_t z_s                  = uint16_xor( x_s, y_s );

  uint16_t z_e;
  uint32_t z_m;

  if ( x_e == h_e_mask )
  {
    if ( x_s || ( ( y_e == h_e_mask ) && y_m ) )
    {
      return ( x_s | h_e_mask | x_m );
    }
 
    if ( ( y_e | y_m ) == 0 )
    {
      return ( h_e_mask | 0x0001 );
    }

    return ( z_s | h_e_mask | 0 );
  }

  if ( y_e == h_e_mask )
  {
    if ( y_m )
    {
      return ( x_s | h_e_mask | x_m );
    }

    if ( ( x_e | x_m ) == 0 )
    {
      return ( h_e_mask | 0x0001 );
    }

    return ( z_s | h_e_mask | 0 );
  }

  if ( x_e == 0 )
  {
    uint16_t t_e = y_e;
    uint16_t t_m = y_m;

    y_e = x_e;
    y_m = x_m;
    x_e = t_e;
    x_m = t_m;
  }

  if ( y_e == 0 )
  {
    if ( y_m == 0 )
    {
      return ( z_s );
    }
    
    // Normalize:
    x_m = ( x_m | h_m_hidden );
    z_m = (uint32_t)x_m * (uint32_t)y_m;
    z_e = 0;

    x_e = x_e >> h_e_pos;
    int unbias_e = (h_e_bias - x_e);

    // Only want h.10
    // Round result
    z_m += z_m & h_m_mask;
    z_m >>= 10;

    // Shift radix point
    uint32_t sa = unbias_e;
    z_m >>= sa;
    z_m &= 0x000003ff;

    return ( y_s | 0 | z_m  );
  }

  x_e = x_e >> h_e_pos;
  y_e = y_e >> h_e_pos;

  x_m = ( x_m | h_m_hidden );
  y_m = ( y_m | h_m_hidden );

  z_m = (uint32_t)x_m * (uint32_t)y_m;

  if ( ( x_e + y_e - h_e_bias ) < 0 )
  {
    z_e = 0;

    uint16_t underflow = -(x_e + y_e - h_e_bias);

    z_m >>= (underflow << 1);
  }
  else
  {
    z_e = x_e + y_e - h_e_bias;
  }

  // if exponent overflow
  if (z_e & 0x00000020)
  {
    return ( z_s | h_e_mask | 0x0000 ); // inf
  }

  // The mantissa is 10 bits so, the result is now
  // hh.(10x10)

  // Shift radix point right one unit
  z_e += 1;
  z_m >>= 1;

  // The result is now
  // h.(10x10)
  if ( ( z_m & 0x00100000 ) == 0 )
  {  
    uint16_t nlz = uint16_cntlz( z_m >> 5 );

    if ( nlz >= z_e )
    {
      z_m <<= (nlz >> 1);
      z_e = 0;
    }
    else
    {
      z_e -= nlz;
      z_m <<= nlz;
    }
  }

  // Only want h.10
  // Round result
  z_m += z_m & h_m_mask;

  // if exponent overflow
  if (z_e & 0x00000020)
  {
      return ( z_s | h_e_mask | 0x0000 ); // inf
  }
  z_m >>= 10;
  z_m &= 0x000003ff;
  z_e &= 0x0000001f;

  z_e = z_e << h_e_pos;

  return ( z_s | z_e | z_m );
}

uint16_t
half_div( uint16_t x, uint16_t y )
{
  uint16_t one                  = 0x0001;
  uint16_t h_s_pos              = 0x000f;
  uint16_t h_s_mask             = 0x8000;
  uint16_t h_e_mask             = 0x7c00;
  uint16_t h_m_mask             = 0x03ff;
  uint16_t h_m_msb_mask         = 0x2000;
  uint16_t h_m_hidden           = 0x0400;
  uint16_t h_e_pos              = 0x000a;
  uint16_t h_e_bias             = 0x000f;
  uint16_t h_m_grs_carry        = 0x4000;
  uint16_t h_m_grs_carry_pos    = 0x000e;
  uint16_t h_grs_size           = 0x0003;
  uint16_t h_snan               = 0xfe00;
  uint16_t h_grs_round_carry    = uint16_sll( one, h_grs_size );
  uint16_t h_grs_round_mask     = uint16_sub( h_grs_round_carry, one );

  uint16_t x_s                  = uint16_and( x, h_s_mask ) >> h_s_pos;
  uint16_t x_e                  = uint16_and( x, h_e_mask ) >> h_e_pos;
  uint16_t x_f                  = uint16_and( x, h_m_mask );

  uint16_t y_s                  = uint16_and( y, h_s_mask ) >> h_s_pos;
  uint16_t y_e                  = uint16_and( y, h_e_mask ) >> h_e_pos;
  uint16_t y_f                  = uint16_and( y, h_m_mask );

  uint16_t z_s                  = uint16_xor( x_s, y_s );

  uint16_t z_e = x_e-y_e+(0x0d);

  x_f = ( x_f | h_m_hidden )<<4;
  y_f = ( y_f | h_m_hidden )<<5;

  if ( y_f <= ( x_f + x_f ) ) 
  {
    x_f >>= 1;
    ++z_e;
  }

  uint32_t z_f = ( ( (uint32_t) x_f )<<16 ) / y_f;

  if ( ( z_f & 0x1F ) == 0 ) 
  {
    z_f |= ( (uint64_t) y_f * z_f != ( (uint32_t) x_f )<<16);
  }

  uint16_t r = (z_f >> 4) | (z_e << h_e_pos) | (z_s << h_s_pos);

  return (r);

  // return roundAndPackFloat32( c_s, c_e, c_f );


#if 0
    zExp = aExp - bExp + 0x7D;
    aSig = ( aSig | 0x00800000 )<<7;
    bSig = ( bSig | 0x00800000 )<<8;
    if ( bSig <= ( aSig + aSig ) ) {
        aSig >>= 1;
        ++zExp;
    }
    zSig = ( ( (bits64) aSig )<<32 ) / bSig;
    if ( ( zSig & 0x3F ) == 0 ) {
        zSig |= ( (bits64) bSig * zSig != ( (bits64) aSig )<<32 );
    }
    return roundAndPackFloat32( zSign, zExp, zSig );
#endif
}

```

`ext/half/half.h`:

```h
#ifndef SOFT_HALF_H
#define SOFT_HALF_H

#include <stdint.h>

uint32_t half_to_float(uint16_t h);
uint16_t half_from_float(uint32_t f);
uint16_t half_add(uint16_t arg0, uint16_t arg1);
uint16_t half_mul(uint16_t arg0, uint16_t arg1);
uint16_t half_div(uint16_t arg0, uint16_t arg1);

static inline uint16_t
half_sub(uint16_t ha, uint16_t hb)
{
	// (a-b) is the same as (a+(-b))
	return half_add(ha, hb ^ 0x8000);
}

#endif /* SOFT_HALF_H */
```

`ext/half/int_insn.h`:

```h
#ifndef INT_INSN_H
#define INT_INSN_H

#include <stdint.h>

static inline uint32_t uint32_nor( uint32_t a, uint32_t b )
{
  return ~(a | b);
}

static inline uint32_t uint32_andc( uint32_t a, uint32_t b )
{
  return (a & (~b));
}

static inline uint32_t uint32_and( uint32_t a, uint32_t b )
{
  return (a & b);
}

static inline uint32_t uint32_or( uint32_t a, uint32_t b )
{
  return (a | b);
}

static inline uint32_t uint32_or3( uint32_t a, uint32_t b, uint32_t c )
{
  return (a | b | c);
}

static inline uint32_t uint32_mux( uint32_t mask, uint32_t a, uint32_t b )
{
  return ( ( mask & (uint32_t)a) | ( (~mask) & (uint32_t)b ) );
}

static inline uint32_t uint32_lt( uint32_t a, uint32_t b )
{
  // NOTE: Result is invalid when a=INT32_MAX, b=INT32_MIN
  // For the purposes used in half.c the result is always valid
  return (uint32_t)( (int32_t)( a - b ) >> 31 );
}

static inline uint32_t uint32_gte( uint32_t a, uint32_t b )
{
  return ~uint32_lt( a, b );
}

static inline uint32_t uint32_gt( uint32_t a, uint32_t b )
{
  // NOTE: Result is invalid when b=INT32_MIN, a=INT32_MAX
  // For the purposes used in half.c the result is always valid
  return (uint32_t)( (int32_t)( b - a ) >> 31 );
}

static inline uint32_t uint32_nez( uint32_t a )
{
  return (uint32_t)( (int32_t)( a | -a ) >> 31 );
}

static inline uint32_t uint32_eqz( uint32_t a )
{
  return ~uint32_nez( a );
}

static inline uint32_t uint32_nez_p( uint32_t a )
{
  return (uint32_t)( (uint32_t)( a | -a ) >> 31 );
}

static inline uint32_t uint32_eq( uint32_t a, uint32_t b )
{
  return ( ~uint32_nez( a-b ) );
}

static inline uint32_t uint32_srl( uint32_t a, uint32_t sa )
{
  return (a >> sa);
}

static inline uint32_t uint32_sll( uint32_t a, uint32_t sa )
{
  return (a << sa);
}

static inline uint32_t uint32_cp( uint32_t a )
{
  return (a);
}

static inline uint32_t uint32_add( uint32_t a, uint32_t b )
{
  return (a + b);
}

static inline uint32_t uint32_sub( uint32_t a, uint32_t b )
{
  return (a - b);
}

static inline uint16_t uint16_mux( uint16_t mask, uint16_t a, uint16_t b )
{
  return ( ( mask & (uint16_t)a) | ( (~mask) & (uint16_t)b ) );
}

static inline uint16_t uint16_lt( uint16_t a, uint16_t b )
{
  // NOTE: Result is invalid when a=INT16_MAX, b=INT16_MIN
  // For the purposes used in half.c the result is always valid
  return (uint16_t)( (int16_t)( a - b ) >> 15 );
}

static inline uint16_t uint16_gte( uint16_t a, uint16_t b )
{
  return ~uint16_lt( a, b );
}

static inline uint16_t uint16_gt( uint16_t a, uint16_t b )
{
  // NOTE: Result is invalid when b=INT32_MIN, a=INT32_MAX
  // For the purposes used in half.c the result is always valid
  return (uint16_t)( (int16_t)( b - a ) >> 15 );
}

static inline uint16_t uint16_nez( uint16_t a )
{
  return (uint16_t)( (int16_t)( a | -a ) >> 15 );
}

static inline uint16_t uint16_eqz( uint16_t a )
{
  return ~uint16_nez( a );
}

static inline uint16_t uint16_nez_p( uint16_t a )
{
  return (uint16_t)( (uint16_t)( a | -a ) >> 15 );
}

static inline uint16_t uint16_eqz_p( uint16_t a )
{
  return ~uint16_nez_p( a );
}

static inline uint16_t uint16_eq( uint16_t a, uint16_t b )
{
  return ( ~uint16_nez( a-b ) );
}

static inline uint16_t uint16_andc( uint16_t a, uint16_t b )
{
  return (a & (~b));
}

static inline uint16_t uint16_and( uint16_t a, uint16_t b )
{
  return (a & b);
}

static inline uint16_t uint16_andsrl( uint16_t a, uint16_t b, uint16_t sa )
{
  return ((a & b) >> sa);
}

static inline uint16_t uint16_or( uint16_t a, uint16_t b )
{
  return (a | b);
}

static inline uint16_t uint16_or3( uint16_t a, uint16_t b, uint16_t c )
{
  return (a | b | c);
}

static inline uint16_t uint16_add( uint16_t a, uint16_t b )
{
  return (a + b);
}

static inline uint16_t uint16_addm( uint16_t a, uint16_t b, uint16_t mask )
{
  return ((a + b) & mask);
}

static inline uint16_t uint16_sub( uint16_t a, uint16_t b )
{
  return (a - b);
}

static inline uint16_t uint16_xor( uint16_t a, uint16_t b )
{
  return (a ^ b);
}

static inline uint16_t uint16_srl( uint16_t a, uint16_t sa )
{
  return (a >> sa);
}

static inline uint16_t uint16_srlm( uint16_t a, uint16_t sa, uint16_t mask )
{
  return ((a >> sa) & mask);
}

static inline uint16_t uint16_sll( uint16_t a, uint16_t sa )
{
  return (a << sa);
}

static inline uint16_t uint16_not( uint16_t a )
{
  return (~a);
}

static inline uint16_t uint16_cp( uint16_t a )
{
  return (a);
}

static inline uint16_t uint16_cntlz( uint16_t x )
{
  const uint16_t x0  = uint16_srl(  x,  1 );
  const uint16_t x1  = uint16_or(   x,  x0 );
  const uint16_t x2  = uint16_srl(  x1, 2 );
  const uint16_t x3  = uint16_or(   x1, x2 );
  const uint16_t x4  = uint16_srl(  x3, 4 );
  const uint16_t x5  = uint16_or(   x3, x4 );
  const uint16_t x6  = uint16_srl(  x5, 8 );
  const uint16_t x7  = uint16_or(   x5, x6 );
  const uint16_t x8  = uint16_not(  x7 );
  const uint16_t x9  = uint16_srlm( x8, 1, 0x5555 );
  const uint16_t xA  = uint16_sub(  x8, x9 );
  const uint16_t xB  = uint16_and(  xA, 0x3333 );
  const uint16_t xC  = uint16_srlm( xA, 2, 0x3333 );
  const uint16_t xD  = uint16_add(  xB, xC );
  const uint16_t xE  = uint16_srl(  xD, 4 );
  const uint16_t xF  = uint16_addm( xD, xE, 0x0f0f );
  const uint16_t x10 = uint16_srl(  xF, 8 );
  const uint16_t x11 = uint16_addm( xF, x10, 0x001f );

  return ( x11 );
}

#endif /* INT_INSN_H */

```

`ext/nanoflann/COPYING.txt`:

```txt
Software License Agreement (BSD License)

Copyright 2008-2009  Marius Muja (mariusm@cs.ubc.ca). All rights reserved.
Copyright 2008-2009  David G. Lowe (lowe@cs.ubc.ca). All rights reserved.
Copyright 2011 Jose L. Blanco (joseluisblancoc@gmail.com). All rights reserved.

THE BSD LICENSE

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


```

`ext/nanoflann/nanoflann.hpp`:

```hpp
/***********************************************************************
 * Software License Agreement (BSD License)
 *
 * Copyright 2008-2009  Marius Muja (mariusm@cs.ubc.ca). All rights reserved.
 * Copyright 2008-2009  David G. Lowe (lowe@cs.ubc.ca). All rights reserved.
 * Copyright 2011-2022  Jose Luis Blanco (joseluisblancoc@gmail.com).
 *   All rights reserved.
 *
 * THE BSD LICENSE
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *************************************************************************/

/** \mainpage nanoflann C++ API documentation
 *  nanoflann is a C++ header-only library for building KD-Trees, mostly
 *  optimized for 2D or 3D point clouds.
 *
 *  nanoflann does not require compiling or installing, just an
 *  #include <nanoflann.hpp> in your code.
 *
 *  See:
 *   - [Online README](https://github.com/jlblancoc/nanoflann)
 *   - [C++ API documentation](https://jlblancoc.github.io/nanoflann/)
 */

#pragma once

#include <algorithm>
#include <array>
#include <cassert>
#include <cmath>  // for abs()
#include <cstdlib>  // for abs()
#include <functional>  // std::reference_wrapper
#include <istream>
#include <limits>  // std::numeric_limits
#include <ostream>
#include <stdexcept>
#include <unordered_set>
#include <vector>

/** Library version: 0xMmP (M=Major,m=minor,P=patch) */
#define NANOFLANN_VERSION 0x150

// Avoid conflicting declaration of min/max macros in Windows headers
#if !defined(NOMINMAX) && \
    (defined(_WIN32) || defined(_WIN32_) || defined(WIN32) || defined(_WIN64))
#define NOMINMAX
#ifdef max
#undef max
#undef min
#endif
#endif
// Avoid conflicts with X11 headers
#ifdef None
#undef None
#endif

namespace nanoflann
{
/** @addtogroup nanoflann_grp nanoflann C++ library for KD-trees
 *  @{ */

/** the PI constant (required to avoid MSVC missing symbols) */
template <typename T>
T pi_const()
{
    return static_cast<T>(3.14159265358979323846);
}

/**
 * Traits if object is resizable and assignable (typically has a resize | assign
 * method)
 */
template <typename T, typename = int>
struct has_resize : std::false_type
{
};

template <typename T>
struct has_resize<T, decltype((void)std::declval<T>().resize(1), 0)>
    : std::true_type
{
};

template <typename T, typename = int>
struct has_assign : std::false_type
{
};

template <typename T>
struct has_assign<T, decltype((void)std::declval<T>().assign(1, 0), 0)>
    : std::true_type
{
};

/**
 * Free function to resize a resizable object
 */
template <typename Container>
inline typename std::enable_if<has_resize<Container>::value, void>::type resize(
    Container& c, const size_t nElements)
{
    c.resize(nElements);
}

/**
 * Free function that has no effects on non resizable containers (e.g.
 * std::array) It raises an exception if the expected size does not match
 */
template <typename Container>
inline typename std::enable_if<!has_resize<Container>::value, void>::type
    resize(Container& c, const size_t nElements)
{
    if (nElements != c.size())
        throw std::logic_error("Try to change the size of a std::array.");
}

/**
 * Free function to assign to a container
 */
template <typename Container, typename T>
inline typename std::enable_if<has_assign<Container>::value, void>::type assign(
    Container& c, const size_t nElements, const T& value)
{
    c.assign(nElements, value);
}

/**
 * Free function to assign to a std::array
 */
template <typename Container, typename T>
inline typename std::enable_if<!has_assign<Container>::value, void>::type
    assign(Container& c, const size_t nElements, const T& value)
{
    for (size_t i = 0; i < nElements; i++) c[i] = value;
}

/** @addtogroup result_sets_grp Result set classes
 *  @{ */
template <
    typename _DistanceType, typename _IndexType = size_t,
    typename _CountType = size_t>
class KNNResultSet
{
   public:
    using DistanceType = _DistanceType;
    using IndexType    = _IndexType;
    using CountType    = _CountType;

   private:
    IndexType*    indices;
    DistanceType* dists;
    CountType     capacity;
    CountType     count;

   public:
    explicit KNNResultSet(CountType capacity_)
        : indices(nullptr), dists(nullptr), capacity(capacity_), count(0)
    {
    }

    void init(IndexType* indices_, DistanceType* dists_)
    {
        indices = indices_;
        dists   = dists_;
        count   = 0;
        if (capacity)
            dists[capacity - 1] = (std::numeric_limits<DistanceType>::max)();
    }

    CountType size() const { return count; }

    bool full() const { return count == capacity; }

    /**
     * Called during search to add an element matching the criteria.
     * @return true if the search should be continued, false if the results are
     * sufficient
     */
    bool addPoint(DistanceType dist, IndexType index)
    {
        CountType i;
        for (i = count; i > 0; --i)
        {
            /** If defined and two points have the same distance, the one with
             *  the lowest-index will be returned first. */
#ifdef NANOFLANN_FIRST_MATCH
            if ((dists[i - 1] > dist) ||
                ((dist == dists[i - 1]) && (indices[i - 1] > index)))
            {
#else
            if (dists[i - 1] > dist)
            {
#endif
                if (i < capacity)
                {
                    dists[i]   = dists[i - 1];
                    indices[i] = indices[i - 1];
                }
            }
            else
                break;
        }
        if (i < capacity)
        {
            dists[i]   = dist;
            indices[i] = index;
        }
        if (count < capacity) count++;

        // tell caller that the search shall continue
        return true;
    }

    DistanceType worstDist() const { return dists[capacity - 1]; }
};

/** operator "<" for std::sort() */
struct IndexDist_Sorter
{
    /** PairType will be typically: ResultItem<IndexType,DistanceType> */
    template <typename PairType>
    bool operator()(const PairType& p1, const PairType& p2) const
    {
        return p1.second < p2.second;
    }
};

/**
 * Each result element in RadiusResultSet. Note that distances and indices
 * are named `first` and `second` to keep backward-compatibility with the
 * `std::pair<>` type used in the past. In contrast, this structure is ensured
 * to be `std::is_standard_layout` so it can be used in wrappers to other
 * languages.
 * See: https://github.com/jlblancoc/nanoflann/issues/166
 */
template <typename IndexType = size_t, typename DistanceType = double>
struct ResultItem
{
    ResultItem() = default;
    ResultItem(const IndexType index, const DistanceType distance)
        : first(index), second(distance)
    {
    }

    IndexType    first;  //!< Index of the sample in the dataset
    DistanceType second;  //!< Distance from sample to query point
};

/**
 * A result-set class used when performing a radius based search.
 */
template <typename _DistanceType, typename _IndexType = size_t>
class RadiusResultSet
{
   public:
    using DistanceType = _DistanceType;
    using IndexType    = _IndexType;

   public:
    const DistanceType radius;

    std::vector<ResultItem<IndexType, DistanceType>>& m_indices_dists;

    explicit RadiusResultSet(
        DistanceType                                      radius_,
        std::vector<ResultItem<IndexType, DistanceType>>& indices_dists)
        : radius(radius_), m_indices_dists(indices_dists)
    {
        init();
    }

    void init() { clear(); }
    void clear() { m_indices_dists.clear(); }

    size_t size() const { return m_indices_dists.size(); }
    size_t empty() const { return m_indices_dists.empty(); }

    bool full() const { return true; }

    /**
     * Called during search to add an element matching the criteria.
     * @return true if the search should be continued, false if the results are
     * sufficient
     */
    bool addPoint(DistanceType dist, IndexType index)
    {
        if (dist < radius) m_indices_dists.emplace_back(index, dist);
        return true;
    }

    DistanceType worstDist() const { return radius; }

    /**
     * Find the worst result (farthest neighbor) without copying or sorting
     * Pre-conditions: size() > 0
     */
    ResultItem<IndexType, DistanceType> worst_item() const
    {
        if (m_indices_dists.empty())
            throw std::runtime_error(
                "Cannot invoke RadiusResultSet::worst_item() on "
                "an empty list of results.");
        auto it = std::max_element(
            m_indices_dists.begin(), m_indices_dists.end(), IndexDist_Sorter());
        return *it;
    }
};

/** @} */

/** @addtogroup loadsave_grp Load/save auxiliary functions
 * @{ */
template <typename T>
void save_value(std::ostream& stream, const T& value)
{
    stream.write(reinterpret_cast<const char*>(&value), sizeof(T));
}

template <typename T>
void save_value(std::ostream& stream, const std::vector<T>& value)
{
    size_t size = value.size();
    stream.write(reinterpret_cast<const char*>(&size), sizeof(size_t));
    stream.write(reinterpret_cast<const char*>(value.data()), sizeof(T) * size);
}

template <typename T>
void load_value(std::istream& stream, T& value)
{
    stream.read(reinterpret_cast<char*>(&value), sizeof(T));
}

template <typename T>
void load_value(std::istream& stream, std::vector<T>& value)
{
    size_t size;
    stream.read(reinterpret_cast<char*>(&size), sizeof(size_t));
    value.resize(size);
    stream.read(reinterpret_cast<char*>(value.data()), sizeof(T) * size);
}
/** @} */

/** @addtogroup metric_grp Metric (distance) classes
 * @{ */

struct Metric
{
};

/** Manhattan distance functor (generic version, optimized for
 * high-dimensionality data sets). Corresponding distance traits:
 * nanoflann::metric_L1
 *
 * \tparam T Type of the elements (e.g. double, float, uint8_t)
 * \tparam DataSource Source of the data, i.e. where the vectors are stored
 * \tparam _DistanceType Type of distance variables (must be signed)
 * \tparam IndexType Type of the arguments with which the data can be
 * accessed (e.g. float, double, int64_t, T*)
 */
template <
    class T, class DataSource, typename _DistanceType = T,
    typename IndexType = uint32_t>
struct L1_Adaptor
{
    using ElementType  = T;
    using DistanceType = _DistanceType;

    const DataSource& data_source;

    L1_Adaptor(const DataSource& _data_source) : data_source(_data_source) {}

    DistanceType evalMetric(
        const T* a, const IndexType b_idx, size_t size,
        DistanceType worst_dist = -1) const
    {
        DistanceType result    = DistanceType();
        const T*     last      = a + size;
        const T*     lastgroup = last - 3;
        size_t       d         = 0;

        /* Process 4 items with each loop for efficiency. */
        while (a < lastgroup)
        {
            const DistanceType diff0 =
                std::abs(a[0] - data_source.kdtree_get_pt(b_idx, d++));
            const DistanceType diff1 =
                std::abs(a[1] - data_source.kdtree_get_pt(b_idx, d++));
            const DistanceType diff2 =
                std::abs(a[2] - data_source.kdtree_get_pt(b_idx, d++));
            const DistanceType diff3 =
                std::abs(a[3] - data_source.kdtree_get_pt(b_idx, d++));
            result += diff0 + diff1 + diff2 + diff3;
            a += 4;
            if ((worst_dist > 0) && (result > worst_dist)) { return result; }
        }
        /* Process last 0-3 components.  Not needed for standard vector lengths.
         */
        while (a < last)
        { result += std::abs(*a++ - data_source.kdtree_get_pt(b_idx, d++)); }
        return result;
    }

    template <typename U, typename V>
    DistanceType accum_dist(const U a, const V b, const size_t) const
    {
        return std::abs(a - b);
    }
};

/** **Squared** Euclidean distance functor (generic version, optimized for
 * high-dimensionality data sets). Corresponding distance traits:
 * nanoflann::metric_L2
 *
 * \tparam T Type of the elements (e.g. double, float, uint8_t)
 * \tparam DataSource Source of the data, i.e. where the vectors are stored
 * \tparam _DistanceType Type of distance variables (must be signed)
 * \tparam IndexType Type of the arguments with which the data can be
 * accessed (e.g. float, double, int64_t, T*)
 */
template <
    class T, class DataSource, typename _DistanceType = T,
    typename IndexType = uint32_t>
struct L2_Adaptor
{
    using ElementType  = T;
    using DistanceType = _DistanceType;

    const DataSource& data_source;

    L2_Adaptor(const DataSource& _data_source) : data_source(_data_source) {}

    DistanceType evalMetric(
        const T* a, const IndexType b_idx, size_t size,
        DistanceType worst_dist = -1) const
    {
        DistanceType result    = DistanceType();
        const T*     last      = a + size;
        const T*     lastgroup = last - 3;
        size_t       d         = 0;

        /* Process 4 items with each loop for efficiency. */
        while (a < lastgroup)
        {
            const DistanceType diff0 =
                a[0] - data_source.kdtree_get_pt(b_idx, d++);
            const DistanceType diff1 =
                a[1] - data_source.kdtree_get_pt(b_idx, d++);
            const DistanceType diff2 =
                a[2] - data_source.kdtree_get_pt(b_idx, d++);
            const DistanceType diff3 =
                a[3] - data_source.kdtree_get_pt(b_idx, d++);
            result +=
                diff0 * diff0 + diff1 * diff1 + diff2 * diff2 + diff3 * diff3;
            a += 4;
            if ((worst_dist > 0) && (result > worst_dist)) { return result; }
        }
        /* Process last 0-3 components.  Not needed for standard vector lengths.
         */
        while (a < last)
        {
            const DistanceType diff0 =
                *a++ - data_source.kdtree_get_pt(b_idx, d++);
            result += diff0 * diff0;
        }
        return result;
    }

    template <typename U, typename V>
    DistanceType accum_dist(const U a, const V b, const size_t) const
    {
        return (a - b) * (a - b);
    }
};

/** **Squared** Euclidean (L2) distance functor (suitable for low-dimensionality
 * datasets, like 2D or 3D point clouds) Corresponding distance traits:
 * nanoflann::metric_L2_Simple
 *
 * \tparam T Type of the elements (e.g. double, float, uint8_t)
 * \tparam DataSource Source of the data, i.e. where the vectors are stored
 * \tparam _DistanceType Type of distance variables (must be signed)
 * \tparam IndexType Type of the arguments with which the data can be
 * accessed (e.g. float, double, int64_t, T*)
 */
template <
    class T, class DataSource, typename _DistanceType = T,
    typename IndexType = uint32_t>
struct L2_Simple_Adaptor
{
    using ElementType  = T;
    using DistanceType = _DistanceType;

    const DataSource& data_source;

    L2_Simple_Adaptor(const DataSource& _data_source)
        : data_source(_data_source)
    {
    }

    DistanceType evalMetric(
        const T* a, const IndexType b_idx, size_t size) const
    {
        DistanceType result = DistanceType();
        for (size_t i = 0; i < size; ++i)
        {
            const DistanceType diff =
                a[i] - data_source.kdtree_get_pt(b_idx, i);
            result += diff * diff;
        }
        return result;
    }

    template <typename U, typename V>
    DistanceType accum_dist(const U a, const V b, const size_t) const
    {
        return (a - b) * (a - b);
    }
};

/** SO2 distance functor
 *  Corresponding distance traits: nanoflann::metric_SO2
 *
 * \tparam T Type of the elements (e.g. double, float, uint8_t)
 * \tparam DataSource Source of the data, i.e. where the vectors are stored
 * \tparam _DistanceType Type of distance variables (must be signed) (e.g.
 * float, double) orientation is constrained to be in [-pi, pi]
 * \tparam IndexType Type of the arguments with which the data can be
 * accessed (e.g. float, double, int64_t, T*)
 */
template <
    class T, class DataSource, typename _DistanceType = T,
    typename IndexType = uint32_t>
struct SO2_Adaptor
{
    using ElementType  = T;
    using DistanceType = _DistanceType;

    const DataSource& data_source;

    SO2_Adaptor(const DataSource& _data_source) : data_source(_data_source) {}

    DistanceType evalMetric(
        const T* a, const IndexType b_idx, size_t size) const
    {
        return accum_dist(
            a[size - 1], data_source.kdtree_get_pt(b_idx, size - 1), size - 1);
    }

    /** Note: this assumes that input angles are already in the range [-pi,pi]
     */
    template <typename U, typename V>
    DistanceType accum_dist(const U a, const V b, const size_t) const
    {
        DistanceType result = DistanceType();
        DistanceType PI     = pi_const<DistanceType>();
        result              = b - a;
        if (result > PI)
            result -= 2 * PI;
        else if (result < -PI)
            result += 2 * PI;
        return result;
    }
};

/** SO3 distance functor (Uses L2_Simple)
 *  Corresponding distance traits: nanoflann::metric_SO3
 *
 * \tparam T Type of the elements (e.g. double, float, uint8_t)
 * \tparam DataSource Source of the data, i.e. where the vectors are stored
 * \tparam _DistanceType Type of distance variables (must be signed) (e.g.
 * float, double)
 * \tparam IndexType Type of the arguments with which the data can be
 * accessed (e.g. float, double, int64_t, T*)
 */
template <
    class T, class DataSource, typename _DistanceType = T,
    typename IndexType = uint32_t>
struct SO3_Adaptor
{
    using ElementType  = T;
    using DistanceType = _DistanceType;

    L2_Simple_Adaptor<T, DataSource, DistanceType, IndexType>
        distance_L2_Simple;

    SO3_Adaptor(const DataSource& _data_source)
        : distance_L2_Simple(_data_source)
    {
    }

    DistanceType evalMetric(
        const T* a, const IndexType b_idx, size_t size) const
    {
        return distance_L2_Simple.evalMetric(a, b_idx, size);
    }

    template <typename U, typename V>
    DistanceType accum_dist(const U a, const V b, const size_t idx) const
    {
        return distance_L2_Simple.accum_dist(a, b, idx);
    }
};

/** Metaprogramming helper traits class for the L1 (Manhattan) metric */
struct metric_L1 : public Metric
{
    template <class T, class DataSource, typename IndexType = uint32_t>
    struct traits
    {
        using distance_t = L1_Adaptor<T, DataSource, T, IndexType>;
    };
};
/** Metaprogramming helper traits class for the L2 (Euclidean) **squared**
 * distance metric */
struct metric_L2 : public Metric
{
    template <class T, class DataSource, typename IndexType = uint32_t>
    struct traits
    {
        using distance_t = L2_Adaptor<T, DataSource, T, IndexType>;
    };
};
/** Metaprogramming helper traits class for the L2_simple (Euclidean)
 * **squared** distance metric */
struct metric_L2_Simple : public Metric
{
    template <class T, class DataSource, typename IndexType = uint32_t>
    struct traits
    {
        using distance_t = L2_Simple_Adaptor<T, DataSource, T, IndexType>;
    };
};
/** Metaprogramming helper traits class for the SO3_InnerProdQuat metric */
struct metric_SO2 : public Metric
{
    template <class T, class DataSource, typename IndexType = uint32_t>
    struct traits
    {
        using distance_t = SO2_Adaptor<T, DataSource, T, IndexType>;
    };
};
/** Metaprogramming helper traits class for the SO3_InnerProdQuat metric */
struct metric_SO3 : public Metric
{
    template <class T, class DataSource, typename IndexType = uint32_t>
    struct traits
    {
        using distance_t = SO3_Adaptor<T, DataSource, T, IndexType>;
    };
};

/** @} */

/** @addtogroup param_grp Parameter structs
 * @{ */

enum class KDTreeSingleIndexAdaptorFlags
{
    None                  = 0,
    SkipInitialBuildIndex = 1
};

inline std::underlying_type<KDTreeSingleIndexAdaptorFlags>::type operator&(
    KDTreeSingleIndexAdaptorFlags lhs, KDTreeSingleIndexAdaptorFlags rhs)
{
    using underlying =
        typename std::underlying_type<KDTreeSingleIndexAdaptorFlags>::type;
    return static_cast<underlying>(lhs) & static_cast<underlying>(rhs);
}

/**  Parameters (see README.md) */
struct KDTreeSingleIndexAdaptorParams
{
    KDTreeSingleIndexAdaptorParams(
        size_t _leaf_max_size = 10, KDTreeSingleIndexAdaptorFlags _flags =
                                        KDTreeSingleIndexAdaptorFlags::None)
        : leaf_max_size(_leaf_max_size), flags(_flags)
    {
    }

    size_t                        leaf_max_size;
    KDTreeSingleIndexAdaptorFlags flags;
};

/** Search options for KDTreeSingleIndexAdaptor::findNeighbors() */
struct SearchParameters
{
    SearchParameters(float eps_ = 0, bool sorted_ = true)
        : eps(eps_), sorted(sorted_)
    {
    }

    float eps;  //!< search for eps-approximate neighbours (default: 0)
    bool  sorted;  //!< only for radius search, require neighbours sorted by
                  //!< distance (default: true)
};
/** @} */

/** @addtogroup memalloc_grp Memory allocation
 * @{ */

/**
 * Pooled storage allocator
 *
 * The following routines allow for the efficient allocation of storage in
 * small chunks from a specified pool.  Rather than allowing each structure
 * to be freed individually, an entire pool of storage is freed at once.
 * This method has two advantages over just using malloc() and free().  First,
 * it is far more efficient for allocating small objects, as there is
 * no overhead for remembering all the information needed to free each
 * object or consolidating fragmented memory.  Second, the decision about
 * how long to keep an object is made at the time of allocation, and there
 * is no need to track down all the objects to free them.
 *
 */
class PooledAllocator
{
    static constexpr size_t WORDSIZE  = 16;
    static constexpr size_t BLOCKSIZE = 8192;

    /* We maintain memory alignment to word boundaries by requiring that all
        allocations be in multiples of the machine wordsize.  */
    /* Size of machine word in bytes.  Must be power of 2. */
    /* Minimum number of bytes requested at a time from	the system.  Must be
     * multiple of WORDSIZE. */

    using Offset    = uint32_t;
    using Size      = uint32_t;
    using Dimension = int32_t;

    Size  remaining_ = 0;  //!< Number of bytes left in current block of storage
    void* base_ = nullptr;  //!< Pointer to base of current block of storage
    void* loc_  = nullptr;  //!< Current location in block to next allocate

    void internal_init()
    {
        remaining_   = 0;
        base_        = nullptr;
        usedMemory   = 0;
        wastedMemory = 0;
    }

   public:
    Size usedMemory   = 0;
    Size wastedMemory = 0;

    /**
        Default constructor. Initializes a new pool.
     */
    PooledAllocator() { internal_init(); }

    /**
     * Destructor. Frees all the memory allocated in this pool.
     */
    ~PooledAllocator() { free_all(); }

    /** Frees all allocated memory chunks */
    void free_all()
    {
        while (base_ != nullptr)
        {
            // Get pointer to prev block
            void* prev = *(static_cast<void**>(base_));
            ::free(base_);
            base_ = prev;
        }
        internal_init();
    }

    /**
     * Returns a pointer to a piece of new memory of the given size in bytes
     * allocated from the pool.
     */
    void* malloc(const size_t req_size)
    {
        /* Round size up to a multiple of wordsize.  The following expression
            only works for WORDSIZE that is a power of 2, by masking last bits
           of incremented size to zero.
         */
        const Size size = (req_size + (WORDSIZE - 1)) & ~(WORDSIZE - 1);

        /* Check whether a new block must be allocated.  Note that the first
           word of a block is reserved for a pointer to the previous block.
         */
        if (size > remaining_)
        {
            wastedMemory += remaining_;

            /* Allocate new storage. */
            const Size blocksize =
                (size + sizeof(void*) + (WORDSIZE - 1) > BLOCKSIZE)
                    ? size + sizeof(void*) + (WORDSIZE - 1)
                    : BLOCKSIZE;

            // use the standard C malloc to allocate memory
            void* m = ::malloc(blocksize);
            if (!m)
            {
                fprintf(stderr, "Failed to allocate memory.\n");
                throw std::bad_alloc();
            }

            /* Fill first word of new block with pointer to previous block. */
            static_cast<void**>(m)[0] = base_;
            base_                     = m;

            Size shift = 0;
            // int size_t = (WORDSIZE - ( (((size_t)m) + sizeof(void*)) &
            // (WORDSIZE-1))) & (WORDSIZE-1);

            remaining_ = blocksize - sizeof(void*) - shift;
            loc_       = (static_cast<char*>(m) + sizeof(void*) + shift);
        }
        void* rloc = loc_;
        loc_       = static_cast<char*>(loc_) + size;
        remaining_ -= size;

        usedMemory += size;

        return rloc;
    }

    /**
     * Allocates (using this pool) a generic type T.
     *
     * Params:
     *     count = number of instances to allocate.
     * Returns: pointer (of type T*) to memory buffer
     */
    template <typename T>
    T* allocate(const size_t count = 1)
    {
        T* mem = static_cast<T*>(this->malloc(sizeof(T) * count));
        return mem;
    }
};
/** @} */

/** @addtogroup nanoflann_metaprog_grp Auxiliary metaprogramming stuff
 * @{ */

/** Used to declare fixed-size arrays when DIM>0, dynamically-allocated vectors
 * when DIM=-1. Fixed size version for a generic DIM:
 */
template <int32_t DIM, typename T>
struct array_or_vector
{
    using type = std::array<T, DIM>;
};
/** Dynamic size version */
template <typename T>
struct array_or_vector<-1, T>
{
    using type = std::vector<T>;
};

/** @} */

/** kd-tree base-class
 *
 * Contains the member functions common to the classes KDTreeSingleIndexAdaptor
 * and KDTreeSingleIndexDynamicAdaptor_.
 *
 * \tparam Derived The name of the class which inherits this class.
 * \tparam DatasetAdaptor The user-provided adaptor, which must be ensured to
 *         have a lifetime equal or longer than the instance of this class.
 * \tparam Distance The distance metric to use, these are all classes derived
 * from nanoflann::Metric
 * \tparam DIM Dimensionality of data points (e.g. 3 for 3D points)
 * \tparam IndexType Type of the arguments with which the data can be
 * accessed (e.g. float, double, int64_t, T*)
 */
template <
    class Derived, typename Distance, class DatasetAdaptor, int32_t DIM = -1,
    typename IndexType = uint32_t>
class KDTreeBaseClass
{
   public:
    /** Frees the previously-built index. Automatically called within
     * buildIndex(). */
    void freeIndex(Derived& obj)
    {
        obj.pool_.free_all();
        obj.root_node_           = nullptr;
        obj.size_at_index_build_ = 0;
    }

    using ElementType  = typename Distance::ElementType;
    using DistanceType = typename Distance::DistanceType;

    /**
     *  Array of indices to vectors in the dataset_.
     */
    std::vector<IndexType> vAcc_;

    using Offset    = typename decltype(vAcc_)::size_type;
    using Size      = typename decltype(vAcc_)::size_type;
    using Dimension = int32_t;

    /*---------------------------
     * Internal Data Structures
     * --------------------------*/
    struct Node
    {
        /** Union used because a node can be either a LEAF node or a non-leaf
         * node, so both data fields are never used simultaneously */
        union
        {
            struct leaf
            {
                Offset left, right;  //!< Indices of points in leaf node
            } lr;
            struct nonleaf
            {
                Dimension divfeat;  //!< Dimension used for subdivision.
                /// The values used for subdivision.
                DistanceType divlow, divhigh;
            } sub;
        } node_type;

        /** Child nodes (both=nullptr mean its a leaf node) */
        Node *child1 = nullptr, *child2 = nullptr;
    };

    using NodePtr      = Node*;
    using NodeConstPtr = const Node*;

    struct Interval
    {
        ElementType low, high;
    };

    NodePtr root_node_ = nullptr;

    Size leaf_max_size_ = 0;

    /// Number of current points in the dataset
    Size size_ = 0;
    /// Number of points in the dataset when the index was built
    Size      size_at_index_build_ = 0;
    Dimension dim_                 = 0;  //!< Dimensionality of each data point

    /** Define "BoundingBox" as a fixed-size or variable-size container
     * depending on "DIM" */
    using BoundingBox = typename array_or_vector<DIM, Interval>::type;

    /** Define "distance_vector_t" as a fixed-size or variable-size container
     * depending on "DIM" */
    using distance_vector_t = typename array_or_vector<DIM, DistanceType>::type;

    /** The KD-tree used to find neighbours */
    BoundingBox root_bbox_;

    /**
     * Pooled memory allocator.
     *
     * Using a pooled memory allocator is more efficient
     * than allocating memory directly when there is a large
     * number small of memory allocations.
     */
    PooledAllocator pool_;

    /** Returns number of points in dataset  */
    Size size(const Derived& obj) const { return obj.size_; }

    /** Returns the length of each point in the dataset */
    Size veclen(const Derived& obj) { return DIM > 0 ? DIM : obj.dim; }

    /// Helper accessor to the dataset points:
    ElementType dataset_get(
        const Derived& obj, IndexType element, Dimension component) const
    {
        return obj.dataset_.kdtree_get_pt(element, component);
    }

    /**
     * Computes the inde memory usage
     * Returns: memory used by the index
     */
    Size usedMemory(Derived& obj)
    {
        return obj.pool_.usedMemory + obj.pool_.wastedMemory +
               obj.dataset_.kdtree_get_point_count() *
                   sizeof(IndexType);  // pool memory and vind array memory
    }

    void computeMinMax(
        const Derived& obj, Offset ind, Size count, Dimension element,
        ElementType& min_elem, ElementType& max_elem)
    {
        min_elem = dataset_get(obj, vAcc_[ind], element);
        max_elem = min_elem;
        for (Offset i = 1; i < count; ++i)
        {
            ElementType val = dataset_get(obj, vAcc_[ind + i], element);
            if (val < min_elem) min_elem = val;
            if (val > max_elem) max_elem = val;
        }
    }

    /**
     * Create a tree node that subdivides the list of vecs from vind[first]
     * to vind[last].  The routine is called recursively on each sublist.
     *
     * @param left index of the first vector
     * @param right index of the last vector
     */
    NodePtr divideTree(
        Derived& obj, const Offset left, const Offset right, BoundingBox& bbox)
    {
        NodePtr node = obj.pool_.template allocate<Node>();  // allocate memory
        const auto dims = (DIM > 0 ? DIM : obj.dim_);

        /* If too few exemplars remain, then make this a leaf node. */
        if ((right - left) <= static_cast<Offset>(obj.leaf_max_size_))
        {
            node->child1 = node->child2 = nullptr; /* Mark as leaf node. */
            node->node_type.lr.left     = left;
            node->node_type.lr.right    = right;

            // compute bounding-box of leaf points
            for (Dimension i = 0; i < dims; ++i)
            {
                bbox[i].low  = dataset_get(obj, obj.vAcc_[left], i);
                bbox[i].high = dataset_get(obj, obj.vAcc_[left], i);
            }
            for (Offset k = left + 1; k < right; ++k)
            {
                for (Dimension i = 0; i < dims; ++i)
                {
                    const auto val = dataset_get(obj, obj.vAcc_[k], i);
                    if (bbox[i].low > val) bbox[i].low = val;
                    if (bbox[i].high < val) bbox[i].high = val;
                }
            }
        }
        else
        {
            Offset       idx;
            Dimension    cutfeat;
            DistanceType cutval;
            middleSplit_(obj, left, right - left, idx, cutfeat, cutval, bbox);

            node->node_type.sub.divfeat = cutfeat;

            BoundingBox left_bbox(bbox);
            left_bbox[cutfeat].high = cutval;
            node->child1 = this->divideTree(obj, left, left + idx, left_bbox);

            BoundingBox right_bbox(bbox);
            right_bbox[cutfeat].low = cutval;
            node->child2 = this->divideTree(obj, left + idx, right, right_bbox);

            node->node_type.sub.divlow  = left_bbox[cutfeat].high;
            node->node_type.sub.divhigh = right_bbox[cutfeat].low;

            for (Dimension i = 0; i < dims; ++i)
            {
                bbox[i].low  = std::min(left_bbox[i].low, right_bbox[i].low);
                bbox[i].high = std::max(left_bbox[i].high, right_bbox[i].high);
            }
        }

        return node;
    }

    void middleSplit_(
        const Derived& obj, const Offset ind, const Size count, Offset& index,
        Dimension& cutfeat, DistanceType& cutval, const BoundingBox& bbox)
    {
        const auto  dims     = (DIM > 0 ? DIM : obj.dim_);
        const auto  EPS      = static_cast<DistanceType>(0.00001);
        ElementType max_span = bbox[0].high - bbox[0].low;
        for (Dimension i = 1; i < dims; ++i)
        {
            ElementType span = bbox[i].high - bbox[i].low;
            if (span > max_span) { max_span = span; }
        }
        ElementType max_spread = -1;
        cutfeat                = 0;
        for (Dimension i = 0; i < dims; ++i)
        {
            ElementType span = bbox[i].high - bbox[i].low;
            if (span > (1 - EPS) * max_span)
            {
                ElementType min_elem, max_elem;
                computeMinMax(obj, ind, count, i, min_elem, max_elem);
                ElementType spread = max_elem - min_elem;
                if (spread > max_spread)
                {
                    cutfeat    = i;
                    max_spread = spread;
                }
            }
        }
        // split in the middle
        DistanceType split_val = (bbox[cutfeat].low + bbox[cutfeat].high) / 2;
        ElementType  min_elem, max_elem;
        computeMinMax(obj, ind, count, cutfeat, min_elem, max_elem);

        if (split_val < min_elem)
            cutval = min_elem;
        else if (split_val > max_elem)
            cutval = max_elem;
        else
            cutval = split_val;

        Offset lim1, lim2;
        planeSplit(obj, ind, count, cutfeat, cutval, lim1, lim2);

        if (lim1 > count / 2)
            index = lim1;
        else if (lim2 < count / 2)
            index = lim2;
        else
            index = count / 2;
    }

    /**
     *  Subdivide the list of points by a plane perpendicular on the axis
     * corresponding to the 'cutfeat' dimension at 'cutval' position.
     *
     *  On return:
     *  dataset[ind[0..lim1-1]][cutfeat]<cutval
     *  dataset[ind[lim1..lim2-1]][cutfeat]==cutval
     *  dataset[ind[lim2..count]][cutfeat]>cutval
     */
    void planeSplit(
        const Derived& obj, const Offset ind, const Size count,
        const Dimension cutfeat, const DistanceType& cutval, Offset& lim1,
        Offset& lim2)
    {
        /* Move vector indices for left subtree to front of list. */
        Offset left  = 0;
        Offset right = count - 1;
        for (;;)
        {
            while (left <= right &&
                   dataset_get(obj, vAcc_[ind + left], cutfeat) < cutval)
                ++left;
            while (right && left <= right &&
                   dataset_get(obj, vAcc_[ind + right], cutfeat) >= cutval)
                --right;
            if (left > right || !right)
                break;  // "!right" was added to support unsigned Index types
            std::swap(vAcc_[ind + left], vAcc_[ind + right]);
            ++left;
            --right;
        }
        /* If either list is empty, it means that all remaining features
         * are identical. Split in the middle to maintain a balanced tree.
         */
        lim1  = left;
        right = count - 1;
        for (;;)
        {
            while (left <= right &&
                   dataset_get(obj, vAcc_[ind + left], cutfeat) <= cutval)
                ++left;
            while (right && left <= right &&
                   dataset_get(obj, vAcc_[ind + right], cutfeat) > cutval)
                --right;
            if (left > right || !right)
                break;  // "!right" was added to support unsigned Index types
            std::swap(vAcc_[ind + left], vAcc_[ind + right]);
            ++left;
            --right;
        }
        lim2 = left;
    }

    DistanceType computeInitialDistances(
        const Derived& obj, const ElementType* vec,
        distance_vector_t& dists) const
    {
        assert(vec);
        DistanceType dist = DistanceType();

        for (Dimension i = 0; i < (DIM > 0 ? DIM : obj.dim_); ++i)
        {
            if (vec[i] < obj.root_bbox_[i].low)
            {
                dists[i] =
                    obj.distance_.accum_dist(vec[i], obj.root_bbox_[i].low, i);
                dist += dists[i];
            }
            if (vec[i] > obj.root_bbox_[i].high)
            {
                dists[i] =
                    obj.distance_.accum_dist(vec[i], obj.root_bbox_[i].high, i);
                dist += dists[i];
            }
        }
        return dist;
    }

    static void save_tree(
        const Derived& obj, std::ostream& stream, const NodeConstPtr tree)
    {
        save_value(stream, *tree);
        if (tree->child1 != nullptr) { save_tree(obj, stream, tree->child1); }
        if (tree->child2 != nullptr) { save_tree(obj, stream, tree->child2); }
    }

    static void load_tree(Derived& obj, std::istream& stream, NodePtr& tree)
    {
        tree = obj.pool_.template allocate<Node>();
        load_value(stream, *tree);
        if (tree->child1 != nullptr) { load_tree(obj, stream, tree->child1); }
        if (tree->child2 != nullptr) { load_tree(obj, stream, tree->child2); }
    }

    /**  Stores the index in a binary file.
     *   IMPORTANT NOTE: The set of data points is NOT stored in the file, so
     * when loading the index object it must be constructed associated to the
     * same source of data points used while building it. See the example:
     * examples/saveload_example.cpp \sa loadIndex  */
    void saveIndex(const Derived& obj, std::ostream& stream) const
    {
        save_value(stream, obj.size_);
        save_value(stream, obj.dim_);
        save_value(stream, obj.root_bbox_);
        save_value(stream, obj.leaf_max_size_);
        save_value(stream, obj.vAcc_);
        save_tree(obj, stream, obj.root_node_);
    }

    /**  Loads a previous index from a binary file.
     *   IMPORTANT NOTE: The set of data points is NOT stored in the file, so
     * the index object must be constructed associated to the same source of
     * data points used while building the index. See the example:
     * examples/saveload_example.cpp \sa loadIndex  */
    void loadIndex(Derived& obj, std::istream& stream)
    {
        load_value(stream, obj.size_);
        load_value(stream, obj.dim_);
        load_value(stream, obj.root_bbox_);
        load_value(stream, obj.leaf_max_size_);
        load_value(stream, obj.vAcc_);
        load_tree(obj, stream, obj.root_node_);
    }
};

/** @addtogroup kdtrees_grp KD-tree classes and adaptors
 * @{ */

/** kd-tree static index
 *
 * Contains the k-d trees and other information for indexing a set of points
 * for nearest-neighbor matching.
 *
 *  The class "DatasetAdaptor" must provide the following interface (can be
 * non-virtual, inlined methods):
 *
 *  \code
 *   // Must return the number of data poins
 *   size_t kdtree_get_point_count() const { ... }
 *
 *
 *   // Must return the dim'th component of the idx'th point in the class:
 *   T kdtree_get_pt(const size_t idx, const size_t dim) const { ... }
 *
 *   // Optional bounding-box computation: return false to default to a standard
 * bbox computation loop.
 *   //   Return true if the BBOX was already computed by the class and returned
 * in "bb" so it can be avoided to redo it again.
 *   //   Look at bb.size() to find out the expected dimensionality (e.g. 2 or 3
 * for point clouds) template <class BBOX> bool kdtree_get_bbox(BBOX &bb) const
 *   {
 *      bb[0].low = ...; bb[0].high = ...;  // 0th dimension limits
 *      bb[1].low = ...; bb[1].high = ...;  // 1st dimension limits
 *      ...
 *      return true;
 *   }
 *
 *  \endcode
 *
 * \tparam DatasetAdaptor The user-provided adaptor, which must be ensured to
 *         have a lifetime equal or longer than the instance of this class.
 * \tparam Distance The distance metric to use: nanoflann::metric_L1,
 * nanoflann::metric_L2, nanoflann::metric_L2_Simple, etc. \tparam DIM
 * Dimensionality of data points (e.g. 3 for 3D points) \tparam IndexType Will
 * be typically size_t or int
 */
template <
    typename Distance, class DatasetAdaptor, int32_t DIM = -1,
    typename IndexType = uint32_t>
class KDTreeSingleIndexAdaptor
    : public KDTreeBaseClass<
          KDTreeSingleIndexAdaptor<Distance, DatasetAdaptor, DIM, IndexType>,
          Distance, DatasetAdaptor, DIM, IndexType>
{
   public:
    /** Deleted copy constructor*/
    explicit KDTreeSingleIndexAdaptor(
        const KDTreeSingleIndexAdaptor<
            Distance, DatasetAdaptor, DIM, IndexType>&) = delete;

    /** The data source used by this index */
    const DatasetAdaptor& dataset_;

    const KDTreeSingleIndexAdaptorParams indexParams;

    Distance distance_;

    using Base = typename nanoflann::KDTreeBaseClass<
        nanoflann::KDTreeSingleIndexAdaptor<
            Distance, DatasetAdaptor, DIM, IndexType>,
        Distance, DatasetAdaptor, DIM, IndexType>;

    using Offset    = typename Base::Offset;
    using Size      = typename Base::Size;
    using Dimension = typename Base::Dimension;

    using ElementType  = typename Base::ElementType;
    using DistanceType = typename Base::DistanceType;

    using Node    = typename Base::Node;
    using NodePtr = Node*;

    using Interval = typename Base::Interval;

    /** Define "BoundingBox" as a fixed-size or variable-size container
     * depending on "DIM" */
    using BoundingBox = typename Base::BoundingBox;

    /** Define "distance_vector_t" as a fixed-size or variable-size container
     * depending on "DIM" */
    using distance_vector_t = typename Base::distance_vector_t;

    /**
     * KDTree constructor
     *
     * Refer to docs in README.md or online in
     * https://github.com/jlblancoc/nanoflann
     *
     * The KD-Tree point dimension (the length of each point in the datase, e.g.
     * 3 for 3D points) is determined by means of:
     *  - The \a DIM template parameter if >0 (highest priority)
     *  - Otherwise, the \a dimensionality parameter of this constructor.
     *
     * @param inputData Dataset with the input features. Its lifetime must be
     *  equal or longer than that of the instance of this class.
     * @param params Basically, the maximum leaf node size
     *
     * Note that there is a variable number of optional additional parameters
     * which will be forwarded to the metric class constructor. Refer to example
     * `examples/pointcloud_custom_metric.cpp` for a use case.
     *
     */
    template <class... Args>
    explicit KDTreeSingleIndexAdaptor(
        const Dimension dimensionality, const DatasetAdaptor& inputData,
        const KDTreeSingleIndexAdaptorParams& params, Args&&... args)
        : dataset_(inputData),
          indexParams(params),
          distance_(inputData, std::forward<Args>(args)...)
    {
        init(dimensionality, params);
    }

    explicit KDTreeSingleIndexAdaptor(
        const Dimension dimensionality, const DatasetAdaptor& inputData,
        const KDTreeSingleIndexAdaptorParams& params = {})
        : dataset_(inputData), indexParams(params), distance_(inputData)
    {
        init(dimensionality, params);
    }

   private:
    void init(
        const Dimension                       dimensionality,
        const KDTreeSingleIndexAdaptorParams& params)
    {
        Base::size_                = dataset_.kdtree_get_point_count();
        Base::size_at_index_build_ = Base::size_;
        Base::dim_                 = dimensionality;
        if (DIM > 0) Base::dim_ = DIM;
        Base::leaf_max_size_ = params.leaf_max_size;

        if (!(params.flags &
              KDTreeSingleIndexAdaptorFlags::SkipInitialBuildIndex))
        {
            // Build KD-tree:
            buildIndex();
        }
    }

   public:
    /**
     * Builds the index
     */
    void buildIndex()
    {
        Base::size_                = dataset_.kdtree_get_point_count();
        Base::size_at_index_build_ = Base::size_;
        init_vind();
        this->freeIndex(*this);
        Base::size_at_index_build_ = Base::size_;
        if (Base::size_ == 0) return;
        computeBoundingBox(Base::root_bbox_);
        // construct the tree
        Base::root_node_ =
            this->divideTree(*this, 0, Base::size_, Base::root_bbox_);
    }

    /** \name Query methods
     * @{ */

    /**
     * Find set of nearest neighbors to vec[0:dim-1]. Their indices are stored
     * inside the result object.
     *
     * Params:
     *     result = the result object in which the indices of the
     * nearest-neighbors are stored vec = the vector for which to search the
     * nearest neighbors
     *
     * \tparam RESULTSET Should be any ResultSet<DistanceType>
     * \return  True if the requested neighbors could be found.
     * \sa knnSearch, radiusSearch
     *
     * \note If L2 norms are used, all returned distances are actually squared
     *       distances.
     */
    template <typename RESULTSET>
    bool findNeighbors(
        RESULTSET& result, const ElementType* vec,
        const SearchParameters& searchParams = {}) const
    {
        assert(vec);
        if (this->size(*this) == 0) return false;
        if (!Base::root_node_)
            throw std::runtime_error(
                "[nanoflann] findNeighbors() called before building the "
                "index.");
        float epsError = 1 + searchParams.eps;

        // fixed or variable-sized container (depending on DIM)
        distance_vector_t dists;
        // Fill it with zeros.
        auto zero = static_cast<decltype(result.worstDist())>(0);
        assign(dists, (DIM > 0 ? DIM : Base::dim_), zero);
        DistanceType dist = this->computeInitialDistances(*this, vec, dists);
        searchLevel(result, vec, Base::root_node_, dist, dists, epsError);
        return result.full();
    }

    /**
     * Find the "num_closest" nearest neighbors to the \a query_point[0:dim-1].
     * Their indices and distances are stored in the provided pointers to
     * array/vector.
     *
     * \sa radiusSearch, findNeighbors
     * \return Number `N` of valid points in the result set.
     *
     * \note If L2 norms are used, all returned distances are actually squared
     *       distances.
     *
     * \note Only the first `N` entries in `out_indices` and `out_distances`
     *       will be valid. Return is less than `num_closest` only if the
     *       number of elements in the tree is less than `num_closest`.
     */
    Size knnSearch(
        const ElementType* query_point, const Size num_closest,
        IndexType* out_indices, DistanceType* out_distances) const
    {
        nanoflann::KNNResultSet<DistanceType, IndexType> resultSet(num_closest);
        resultSet.init(out_indices, out_distances);
        findNeighbors(resultSet, query_point);
        return resultSet.size();
    }

    /**
     * Find all the neighbors to \a query_point[0:dim-1] within a maximum
     * radius. The output is given as a vector of pairs, of which the first
     * element is a point index and the second the corresponding distance.
     * Previous contents of \a IndicesDists are cleared.
     *
     *  If searchParams.sorted==true, the output list is sorted by ascending
     * distances.
     *
     *  For a better performance, it is advisable to do a .reserve() on the
     * vector if you have any wild guess about the number of expected matches.
     *
     *  \sa knnSearch, findNeighbors, radiusSearchCustomCallback
     * \return The number of points within the given radius (i.e. indices.size()
     * or dists.size() )
     *
     * \note If L2 norms are used, search radius and all returned distances
     *       are actually squared distances.
     */
    Size radiusSearch(
        const ElementType* query_point, const DistanceType& radius,
        std::vector<ResultItem<IndexType, DistanceType>>& IndicesDists,
        const SearchParameters& searchParams = {}) const
    {
        RadiusResultSet<DistanceType, IndexType> resultSet(
            radius, IndicesDists);
        const Size nFound =
            radiusSearchCustomCallback(query_point, resultSet, searchParams);
        if (searchParams.sorted)
            std::sort(
                IndicesDists.begin(), IndicesDists.end(), IndexDist_Sorter());
        return nFound;
    }

    /**
     * Just like radiusSearch() but with a custom callback class for each point
     * found in the radius of the query. See the source of RadiusResultSet<> as
     * a start point for your own classes. \sa radiusSearch
     */
    template <class SEARCH_CALLBACK>
    Size radiusSearchCustomCallback(
        const ElementType* query_point, SEARCH_CALLBACK& resultSet,
        const SearchParameters& searchParams = {}) const
    {
        findNeighbors(resultSet, query_point, searchParams);
        return resultSet.size();
    }

    /** @} */

   public:
    /** Make sure the auxiliary list \a vind has the same size than the current
     * dataset, and re-generate if size has changed. */
    void init_vind()
    {
        // Create a permutable array of indices to the input vectors.
        Base::size_ = dataset_.kdtree_get_point_count();
        if (Base::vAcc_.size() != Base::size_) Base::vAcc_.resize(Base::size_);
        for (Size i = 0; i < Base::size_; i++) 
            Base::vAcc_[i] = (IndexType)i;
    }

    void computeBoundingBox(BoundingBox& bbox)
    {
        const auto dims = (DIM > 0 ? DIM : Base::dim_);
        resize(bbox, dims);
        if (dataset_.kdtree_get_bbox(bbox))
        {
            // Done! It was implemented in derived class
        }
        else
        {
            const Size N = dataset_.kdtree_get_point_count();
            if (!N)
                throw std::runtime_error(
                    "[nanoflann] computeBoundingBox() called but "
                    "no data points found.");
            for (Dimension i = 0; i < dims; ++i)
            {
                bbox[i].low = bbox[i].high =
                    this->dataset_get(*this, Base::vAcc_[0], i);
            }
            for (Offset k = 1; k < N; ++k)
            {
                for (Dimension i = 0; i < dims; ++i)
                {
                    const auto val =
                        this->dataset_get(*this, Base::vAcc_[k], i);
                    if (val < bbox[i].low) bbox[i].low = val;
                    if (val > bbox[i].high) bbox[i].high = val;
                }
            }
        }
    }

    /**
     * Performs an exact search in the tree starting from a node.
     * \tparam RESULTSET Should be any ResultSet<DistanceType>
     * \return true if the search should be continued, false if the results are
     * sufficient
     */
    template <class RESULTSET>
    bool searchLevel(
        RESULTSET& result_set, const ElementType* vec, const NodePtr node,
        DistanceType mindist, distance_vector_t& dists,
        const float epsError) const
    {
        /* If this is a leaf node, then do check and return. */
        if ((node->child1 == nullptr) && (node->child2 == nullptr))
        {
            DistanceType worst_dist = result_set.worstDist();
            for (Offset i = node->node_type.lr.left;
                 i < node->node_type.lr.right; ++i)
            {
                const IndexType accessor = Base::vAcc_[i];  // reorder... : i;
                DistanceType    dist     = distance_.evalMetric(
                    vec, accessor, (DIM > 0 ? DIM : Base::dim_));
                if (dist < worst_dist)
                {
                    if (!result_set.addPoint(dist, Base::vAcc_[i]))
                    {
                        // the resultset doesn't want to receive any more
                        // points, we're done searching!
                        return false;
                    }
                }
            }
            return true;
        }

        /* Which child branch should be taken first? */
        Dimension    idx   = node->node_type.sub.divfeat;
        ElementType  val   = vec[idx];
        DistanceType diff1 = val - node->node_type.sub.divlow;
        DistanceType diff2 = val - node->node_type.sub.divhigh;

        NodePtr      bestChild;
        NodePtr      otherChild;
        DistanceType cut_dist;
        if ((diff1 + diff2) < 0)
        {
            bestChild  = node->child1;
            otherChild = node->child2;
            cut_dist =
                distance_.accum_dist(val, node->node_type.sub.divhigh, idx);
        }
        else
        {
            bestChild  = node->child2;
            otherChild = node->child1;
            cut_dist =
                distance_.accum_dist(val, node->node_type.sub.divlow, idx);
        }

        /* Call recursively to search next level down. */
        if (!searchLevel(
                result_set, vec, bestChild, mindist, dists, epsError))
        {
            // the resultset doesn't want to receive any more points, we're done
            // searching!
            return false;
        }

        DistanceType dst = dists[idx];
        mindist        = mindist + cut_dist - dst;
        dists[idx]       = cut_dist;
        if (mindist * epsError <= result_set.worstDist())
        {
            if (!searchLevel(
                    result_set, vec, otherChild, mindist, dists, epsError))
            {
                // the resultset doesn't want to receive any more points, we're
                // done searching!
                return false;
            }
        }
        dists[idx] = dst;
        return true;
    }

   public:
    /**  Stores the index in a binary file.
     *   IMPORTANT NOTE: The set of data points is NOT stored in the file, so
     * when loading the index object it must be constructed associated to the
     * same source of data points used while building it. See the example:
     * examples/saveload_example.cpp \sa loadIndex  */
    void saveIndex(std::ostream& stream) const
    {
        Base::saveIndex(*this, stream);
    }

    /**  Loads a previous index from a binary file.
     *   IMPORTANT NOTE: The set of data points is NOT stored in the file, so
     * the index object must be constructed associated to the same source of
     * data points used while building the index. See the example:
     * examples/saveload_example.cpp \sa loadIndex  */
    void loadIndex(std::istream& stream) { Base::loadIndex(*this, stream); }

};  // class KDTree

/** kd-tree dynamic index
 *
 * Contains the k-d trees and other information for indexing a set of points
 * for nearest-neighbor matching.
 *
 * The class "DatasetAdaptor" must provide the following interface (can be
 * non-virtual, inlined methods):
 *
 *  \code
 *   // Must return the number of data poins
 *   size_t kdtree_get_point_count() const { ... }
 *
 *   // Must return the dim'th component of the idx'th point in the class:
 *   T kdtree_get_pt(const size_t idx, const size_t dim) const { ... }
 *
 *   // Optional bounding-box computation: return false to default to a standard
 * bbox computation loop.
 *   //   Return true if the BBOX was already computed by the class and returned
 * in "bb" so it can be avoided to redo it again.
 *   //   Look at bb.size() to find out the expected dimensionality (e.g. 2 or 3
 * for point clouds) template <class BBOX> bool kdtree_get_bbox(BBOX &bb) const
 *   {
 *      bb[0].low = ...; bb[0].high = ...;  // 0th dimension limits
 *      bb[1].low = ...; bb[1].high = ...;  // 1st dimension limits
 *      ...
 *      return true;
 *   }
 *
 *  \endcode
 *
 * \tparam DatasetAdaptor The user-provided adaptor (see comments above).
 * \tparam Distance The distance metric to use: nanoflann::metric_L1,
 * nanoflann::metric_L2, nanoflann::metric_L2_Simple, etc.
 * \tparam DIM Dimensionality of data points (e.g. 3 for 3D points)
 * \tparam IndexType Type of the arguments with which the data can be
 * accessed (e.g. float, double, int64_t, T*)
 */
template <
    typename Distance, class DatasetAdaptor, int32_t DIM = -1,
    typename IndexType = uint32_t>
class KDTreeSingleIndexDynamicAdaptor_
    : public KDTreeBaseClass<
          KDTreeSingleIndexDynamicAdaptor_<
              Distance, DatasetAdaptor, DIM, IndexType>,
          Distance, DatasetAdaptor, DIM, IndexType>
{
   public:
    /**
     * The dataset used by this index
     */
    const DatasetAdaptor& dataset_;  //!< The source of our data

    KDTreeSingleIndexAdaptorParams index_params_;

    std::vector<int>& treeIndex_;

    Distance distance_;

    using Base = typename nanoflann::KDTreeBaseClass<
        nanoflann::KDTreeSingleIndexDynamicAdaptor_<
            Distance, DatasetAdaptor, DIM, IndexType>,
        Distance, DatasetAdaptor, DIM, IndexType>;

    using ElementType  = typename Base::ElementType;
    using DistanceType = typename Base::DistanceType;

    using Offset    = typename Base::Offset;
    using Size      = typename Base::Size;
    using Dimension = typename Base::Dimension;

    using Node    = typename Base::Node;
    using NodePtr = Node*;

    using Interval = typename Base::Interval;
    /** Define "BoundingBox" as a fixed-size or variable-size container
     * depending on "DIM" */
    using BoundingBox = typename Base::BoundingBox;

    /** Define "distance_vector_t" as a fixed-size or variable-size container
     * depending on "DIM" */
    using distance_vector_t = typename Base::distance_vector_t;

    /**
     * KDTree constructor
     *
     * Refer to docs in README.md or online in
     * https://github.com/jlblancoc/nanoflann
     *
     * The KD-Tree point dimension (the length of each point in the datase, e.g.
     * 3 for 3D points) is determined by means of:
     *  - The \a DIM template parameter if >0 (highest priority)
     *  - Otherwise, the \a dimensionality parameter of this constructor.
     *
     * @param inputData Dataset with the input features. Its lifetime must be
     *  equal or longer than that of the instance of this class.
     * @param params Basically, the maximum leaf node size
     */
    KDTreeSingleIndexDynamicAdaptor_(
        const Dimension dimensionality, const DatasetAdaptor& inputData,
        std::vector<int>&                     treeIndex,
        const KDTreeSingleIndexAdaptorParams& params =
            KDTreeSingleIndexAdaptorParams())
        : dataset_(inputData),
          index_params_(params),
          treeIndex_(treeIndex),
          distance_(inputData)
    {
        Base::size_                = 0;
        Base::size_at_index_build_ = 0;
        for (auto& v : Base::root_bbox_) v = {};
        Base::dim_ = dimensionality;
        if (DIM > 0) Base::dim_ = DIM;
        Base::leaf_max_size_ = params.leaf_max_size;
    }

    /** Explicitly default the copy constructor */
    KDTreeSingleIndexDynamicAdaptor_(
        const KDTreeSingleIndexDynamicAdaptor_& rhs) = default;

    /** Assignment operator definiton */
    KDTreeSingleIndexDynamicAdaptor_ operator=(
        const KDTreeSingleIndexDynamicAdaptor_& rhs)
    {
        KDTreeSingleIndexDynamicAdaptor_ tmp(rhs);
        std::swap(Base::vAcc_, tmp.Base::vAcc_);
        std::swap(Base::leaf_max_size_, tmp.Base::leaf_max_size_);
        std::swap(index_params_, tmp.index_params_);
        std::swap(treeIndex_, tmp.treeIndex_);
        std::swap(Base::size_, tmp.Base::size_);
        std::swap(Base::size_at_index_build_, tmp.Base::size_at_index_build_);
        std::swap(Base::root_node_, tmp.Base::root_node_);
        std::swap(Base::root_bbox_, tmp.Base::root_bbox_);
        std::swap(Base::pool_, tmp.Base::pool_);
        return *this;
    }

    /**
     * Builds the index
     */
    void buildIndex()
    {
        Base::size_ = Base::vAcc_.size();
        this->freeIndex(*this);
        Base::size_at_index_build_ = Base::size_;
        if (Base::size_ == 0) return;
        computeBoundingBox(Base::root_bbox_);
        // construct the tree
        Base::root_node_ =
            this->divideTree(*this, 0, Base::size_, Base::root_bbox_);
    }

    /** \name Query methods
     * @{ */

    /**
     * Find set of nearest neighbors to vec[0:dim-1]. Their indices are stored
     * inside the result object.
     * This is the core search function, all others are wrappers around this
     * one.
     *
     * \param result The result object in which the indices of the
     *               nearest-neighbors are stored.
     * \param vec    The vector of the query point for which to search the
     *               nearest neighbors.
     * \param searchParams Optional parameters for the search.
     *
     * \tparam RESULTSET Should be any ResultSet<DistanceType>
     * \return True if the requested neighbors could be found.
     *
     * \sa knnSearch(), radiusSearch(), radiusSearchCustomCallback()
     *
     * \note If L2 norms are used, all returned distances are actually squared
     *       distances.
     */
    template <typename RESULTSET>
    bool findNeighbors(
        RESULTSET& result, const ElementType* vec,
        const SearchParameters& searchParams = {}) const
    {
        assert(vec);
        if (this->size(*this) == 0) return false;
        if (!Base::root_node_) return false;
        float epsError = 1 + searchParams.eps;

        // fixed or variable-sized container (depending on DIM)
        distance_vector_t dists;
        // Fill it with zeros.
        assign(
            dists, (DIM > 0 ? DIM : Base::dim_),
            static_cast<typename distance_vector_t::value_type>(0));
        DistanceType dist = this->computeInitialDistances(*this, vec, dists);
        searchLevel(result, vec, Base::root_node_, dist, dists, epsError);
        return result.full();
    }

    /**
     * Find the "num_closest" nearest neighbors to the \a query_point[0:dim-1].
     * Their indices are stored inside the result object. \sa radiusSearch,
     * findNeighbors
     * \return Number `N` of valid points in
     * the result set.
     *
     * \note If L2 norms are used, all returned distances are actually squared
     *       distances.
     *
     * \note Only the first `N` entries in `out_indices` and `out_distances`
     *       will be valid. Return may be less than `num_closest` only if the
     *       number of elements in the tree is less than `num_closest`.
     */
    Size knnSearch(
        const ElementType* query_point, const Size num_closest,
        IndexType* out_indices, DistanceType* out_distances) const
    {
        nanoflann::KNNResultSet<DistanceType, IndexType> resultSet(num_closest);
        resultSet.init(out_indices, out_distances);
        findNeighbors(resultSet, query_point);
        return resultSet.size();
    }

    /**
     * Find all the neighbors to \a query_point[0:dim-1] within a maximum
     * radius. The output is given as a vector of pairs, of which the first
     * element is a point index and the second the corresponding distance.
     * Previous contents of \a IndicesDists are cleared.
     *
     * If searchParams.sorted==true, the output list is sorted by ascending
     * distances.
     *
     * For a better performance, it is advisable to do a .reserve() on the
     * vector if you have any wild guess about the number of expected matches.
     *
     *  \sa knnSearch, findNeighbors, radiusSearchCustomCallback
     * \return The number of points within the given radius (i.e. indices.size()
     * or dists.size() )
     *
     * \note If L2 norms are used, search radius and all returned distances
     *       are actually squared distances.
     */
    Size radiusSearch(
        const ElementType* query_point, const DistanceType& radius,
        std::vector<ResultItem<IndexType, DistanceType>>& IndicesDists,
        const SearchParameters& searchParams = {}) const
    {
        RadiusResultSet<DistanceType, IndexType> resultSet(
            radius, IndicesDists);
        const size_t nFound =
            radiusSearchCustomCallback(query_point, resultSet, searchParams);
        if (searchParams.sorted)
            std::sort(
                IndicesDists.begin(), IndicesDists.end(), IndexDist_Sorter());
        return nFound;
    }

    /**
     * Just like radiusSearch() but with a custom callback class for each point
     * found in the radius of the query. See the source of RadiusResultSet<> as
     * a start point for your own classes. \sa radiusSearch
     */
    template <class SEARCH_CALLBACK>
    Size radiusSearchCustomCallback(
        const ElementType* query_point, SEARCH_CALLBACK& resultSet,
        const SearchParameters& searchParams = {}) const
    {
        findNeighbors(resultSet, query_point, searchParams);
        return resultSet.size();
    }

    /** @} */

   public:
    void computeBoundingBox(BoundingBox& bbox)
    {
        const auto dims = (DIM > 0 ? DIM : Base::dim_);
        resize(bbox, dims);

        if (dataset_.kdtree_get_bbox(bbox))
        {
            // Done! It was implemented in derived class
        }
        else
        {
            const Size N = Base::size_;
            if (!N)
                throw std::runtime_error(
                    "[nanoflann] computeBoundingBox() called but "
                    "no data points found.");
            for (Dimension i = 0; i < dims; ++i)
            {
                bbox[i].low = bbox[i].high =
                    this->dataset_get(*this, Base::vAcc_[0], i);
            }
            for (Offset k = 1; k < N; ++k)
            {
                for (Dimension i = 0; i < dims; ++i)
                {
                    const auto val =
                        this->dataset_get(*this, Base::vAcc_[k], i);
                    if (val < bbox[i].low) bbox[i].low = val;
                    if (val > bbox[i].high) bbox[i].high = val;
                }
            }
        }
    }

    /**
     * Performs an exact search in the tree starting from a node.
     * \tparam RESULTSET Should be any ResultSet<DistanceType>
     */
    template <class RESULTSET>
    void searchLevel(
        RESULTSET& result_set, const ElementType* vec, const NodePtr node,
        DistanceType mindist, distance_vector_t& dists,
        const float epsError) const
    {
        /* If this is a leaf node, then do check and return. */
        if ((node->child1 == nullptr) && (node->child2 == nullptr))
        {
            DistanceType worst_dist = result_set.worstDist();
            for (Offset i = node->node_type.lr.left;
                 i < node->node_type.lr.right; ++i)
            {
                const IndexType index = Base::vAcc_[i];  // reorder... : i;
                if (treeIndex_[index] == -1) continue;
                DistanceType dist = distance_.evalMetric(
                    vec, index, (DIM > 0 ? DIM : Base::dim_));
                if (dist < worst_dist)
                {
                    if (!result_set.addPoint(
                            static_cast<typename RESULTSET::DistanceType>(dist),
                            static_cast<typename RESULTSET::IndexType>(
                                Base::vAcc_[i])))
                    {
                        // the resultset doesn't want to receive any more
                        // points, we're done searching!
                        return;  // false;
                    }
                }
            }
            return;
        }

        /* Which child branch should be taken first? */
        Dimension    idx   = node->node_type.sub.divfeat;
        ElementType  val   = vec[idx];
        DistanceType diff1 = val - node->node_type.sub.divlow;
        DistanceType diff2 = val - node->node_type.sub.divhigh;

        NodePtr      bestChild;
        NodePtr      otherChild;
        DistanceType cut_dist;
        if ((diff1 + diff2) < 0)
        {
            bestChild  = node->child1;
            otherChild = node->child2;
            cut_dist =
                distance_.accum_dist(val, node->node_type.sub.divhigh, idx);
        }
        else
        {
            bestChild  = node->child2;
            otherChild = node->child1;
            cut_dist =
                distance_.accum_dist(val, node->node_type.sub.divlow, idx);
        }

        /* Call recursively to search next level down. */
        searchLevel(result_set, vec, bestChild, mindist, dists, epsError);

        DistanceType dst = dists[idx];
        mindist        = mindist + cut_dist - dst;
        dists[idx]       = cut_dist;
        if (mindist * epsError <= result_set.worstDist())
        {
            searchLevel(
                result_set, vec, otherChild, mindist, dists, epsError);
        }
        dists[idx] = dst;
    }

   public:
    /**  Stores the index in a binary file.
     *   IMPORTANT NOTE: The set of data points is NOT stored in the file, so
     * when loading the index object it must be constructed associated to the
     * same source of data points used while building it. See the example:
     * examples/saveload_example.cpp \sa loadIndex  */
    void saveIndex(std::ostream& stream) { saveIndex(*this, stream); }

    /**  Loads a previous index from a binary file.
     *   IMPORTANT NOTE: The set of data points is NOT stored in the file, so
     * the index object must be constructed associated to the same source of
     * data points used while building the index. See the example:
     * examples/saveload_example.cpp \sa loadIndex  */
    void loadIndex(std::istream& stream) { loadIndex(*this, stream); }
};

/** kd-tree dynaimic index
 *
 * class to create multiple static index and merge their results to behave as
 * single dynamic index as proposed in Logarithmic Approach.
 *
 *  Example of usage:
 *  examples/dynamic_pointcloud_example.cpp
 *
 * \tparam DatasetAdaptor The user-provided adaptor (see comments above).
 * \tparam Distance The distance metric to use: nanoflann::metric_L1,
 * nanoflann::metric_L2, nanoflann::metric_L2_Simple, etc. \tparam DIM
 * Dimensionality of data points (e.g. 3 for 3D points) \tparam IndexType
 * Will be typically size_t or int
 */
template <
    typename Distance, class DatasetAdaptor, int32_t DIM = -1,
    typename IndexType = uint32_t>
class KDTreeSingleIndexDynamicAdaptor
{
   public:
    using ElementType  = typename Distance::ElementType;
    using DistanceType = typename Distance::DistanceType;

    using Offset = typename KDTreeSingleIndexDynamicAdaptor_<
        Distance, DatasetAdaptor, DIM>::Offset;
    using Size = typename KDTreeSingleIndexDynamicAdaptor_<
        Distance, DatasetAdaptor, DIM>::Size;
    using Dimension = typename KDTreeSingleIndexDynamicAdaptor_<
        Distance, DatasetAdaptor, DIM>::Dimension;

   protected:
    Size leaf_max_size_;
    Size treeCount_;
    Size pointCount_;

    /**
     * The dataset used by this index
     */
    const DatasetAdaptor& dataset_;  //!< The source of our data

    /** treeIndex[idx] is the index of tree in which point at idx is stored.
     * treeIndex[idx]=-1 means that point has been removed. */
    std::vector<int>        treeIndex_;
    std::unordered_set<int> removedPoints_;

    KDTreeSingleIndexAdaptorParams index_params_;

    Dimension dim_;  //!< Dimensionality of each data point

    using index_container_t = KDTreeSingleIndexDynamicAdaptor_<
        Distance, DatasetAdaptor, DIM, IndexType>;
    std::vector<index_container_t> index_;

   public:
    /** Get a const ref to the internal list of indices; the number of indices
     * is adapted dynamically as the dataset grows in size. */
    const std::vector<index_container_t>& getAllIndices() const
    {
        return index_;
    }

   private:
    /** finds position of least significant unset bit */
    int First0Bit(IndexType num)
    {
        int pos = 0;
        while (num & 1)
        {
            num = num >> 1;
            pos++;
        }
        return pos;
    }

    /** Creates multiple empty trees to handle dynamic support */
    void init()
    {
        using my_kd_tree_t = KDTreeSingleIndexDynamicAdaptor_<
            Distance, DatasetAdaptor, DIM, IndexType>;
        std::vector<my_kd_tree_t> index(
            treeCount_,
            my_kd_tree_t(dim_ /*dim*/, dataset_, treeIndex_, index_params_));
        index_ = index;
    }

   public:
    Distance distance_;

    /**
     * KDTree constructor
     *
     * Refer to docs in README.md or online in
     * https://github.com/jlblancoc/nanoflann
     *
     * The KD-Tree point dimension (the length of each point in the datase, e.g.
     * 3 for 3D points) is determined by means of:
     *  - The \a DIM template parameter if >0 (highest priority)
     *  - Otherwise, the \a dimensionality parameter of this constructor.
     *
     * @param inputData Dataset with the input features. Its lifetime must be
     *  equal or longer than that of the instance of this class.
     * @param params Basically, the maximum leaf node size
     */
    explicit KDTreeSingleIndexDynamicAdaptor(
        const int dimensionality, const DatasetAdaptor& inputData,
        const KDTreeSingleIndexAdaptorParams& params =
            KDTreeSingleIndexAdaptorParams(),
        const size_t maximumPointCount = 1000000000U)
        : dataset_(inputData), index_params_(params), distance_(inputData)
    {
        treeCount_  = static_cast<size_t>(std::log2(maximumPointCount)) + 1;
        pointCount_ = 0U;
        dim_        = dimensionality;
        treeIndex_.clear();
        if (DIM > 0) dim_ = DIM;
        leaf_max_size_ = params.leaf_max_size;
        init();
        const size_t num_initial_points = dataset_.kdtree_get_point_count();
        if (num_initial_points > 0) { addPoints(0, num_initial_points - 1); }
    }

    /** Deleted copy constructor*/
    explicit KDTreeSingleIndexDynamicAdaptor(
        const KDTreeSingleIndexDynamicAdaptor<
            Distance, DatasetAdaptor, DIM, IndexType>&) = delete;

    /** Add points to the set, Inserts all points from [start, end] */
    void addPoints(IndexType start, IndexType end)
    {
        const Size count    = end - start + 1;
        int        maxIndex = 0;
        treeIndex_.resize(treeIndex_.size() + count);
        for (IndexType idx = start; idx <= end; idx++)
        {
            const int pos           = First0Bit(pointCount_);
            maxIndex                = std::max(pos, maxIndex);
            treeIndex_[pointCount_] = pos;

            const auto it = removedPoints_.find(idx);
            if (it != removedPoints_.end())
            {
                removedPoints_.erase(it);
                treeIndex_[idx] = pos;
            }

            for (int i = 0; i < pos; i++)
            {
                for (int j = 0; j < static_cast<int>(index_[i].vAcc_.size());
                     j++)
                {
                    index_[pos].vAcc_.push_back(index_[i].vAcc_[j]);
                    if (treeIndex_[index_[i].vAcc_[j]] != -1)
                        treeIndex_[index_[i].vAcc_[j]] = pos;
                }
                index_[i].vAcc_.clear();
            }
            index_[pos].vAcc_.push_back(idx);
            pointCount_++;
        }

        for (int i = 0; i <= maxIndex; ++i)
        {
            index_[i].freeIndex(index_[i]);
            if (!index_[i].vAcc_.empty()) index_[i].buildIndex();
        }
    }

    /** Remove a point from the set (Lazy Deletion) */
    void removePoint(size_t idx)
    {
        if (idx >= pointCount_) return;
        removedPoints_.insert(idx);
        treeIndex_[idx] = -1;
    }

    /**
     * Find set of nearest neighbors to vec[0:dim-1]. Their indices are stored
     * inside the result object.
     *
     * Params:
     *     result = the result object in which the indices of the
     * nearest-neighbors are stored vec = the vector for which to search the
     * nearest neighbors
     *
     * \tparam RESULTSET Should be any ResultSet<DistanceType>
     * \return  True if the requested neighbors could be found.
     * \sa knnSearch, radiusSearch
     *
     * \note If L2 norms are used, all returned distances are actually squared
     *       distances.
     */
    template <typename RESULTSET>
    bool findNeighbors(
        RESULTSET& result, const ElementType* vec,
        const SearchParameters& searchParams = {}) const
    {
        for (size_t i = 0; i < treeCount_; i++)
        { index_[i].findNeighbors(result, &vec[0], searchParams); }
        return result.full();
    }
};

/** An L2-metric KD-tree adaptor for working with data directly stored in an
 * Eigen Matrix, without duplicating the data storage. You can select whether a
 * row or column in the matrix represents a point in the state space.
 *
 * Example of usage:
 * \code
 * Eigen::Matrix<num_t,Eigen::Dynamic,Eigen::Dynamic>  mat;
 *
 * // Fill out "mat"...
 * using my_kd_tree_t = nanoflann::KDTreeEigenMatrixAdaptor<
 *   Eigen::Matrix<num_t,Dynamic,Dynamic>>;
 *
 * const int max_leaf = 10;
 * my_kd_tree_t mat_index(mat, max_leaf);
 * mat_index.index->...
 * \endcode
 *
 *  \tparam DIM If set to >0, it specifies a compile-time fixed dimensionality
 * for the points in the data set, allowing more compiler optimizations.
 * \tparam Distance The distance metric to use: nanoflann::metric_L1,
 * nanoflann::metric_L2, nanoflann::metric_L2_Simple, etc.
 * \tparam row_major If set to true the rows of the matrix are used as the
 *         points, if set to false  the columns of the matrix are used as the
 *         points.
 */
template <
    class MatrixType, int32_t DIM = -1, class Distance = nanoflann::metric_L2,
    bool row_major = true>
struct KDTreeEigenMatrixAdaptor
{
    using self_t =
        KDTreeEigenMatrixAdaptor<MatrixType, DIM, Distance, row_major>;
    using num_t     = typename MatrixType::Scalar;
    using IndexType = typename MatrixType::Index;
    using metric_t  = typename Distance::template traits<
        num_t, self_t, IndexType>::distance_t;

    using index_t = KDTreeSingleIndexAdaptor<
        metric_t, self_t,
        row_major ? MatrixType::ColsAtCompileTime
                  : MatrixType::RowsAtCompileTime,
        IndexType>;

    index_t* index_;  //! The kd-tree index for the user to call its methods as
                      //! usual with any other FLANN index.

    using Offset    = typename index_t::Offset;
    using Size      = typename index_t::Size;
    using Dimension = typename index_t::Dimension;

    /// Constructor: takes a const ref to the matrix object with the data points
    explicit KDTreeEigenMatrixAdaptor(
        const Dimension                                 dimensionality,
        const std::reference_wrapper<const MatrixType>& mat,
        const int                                       leaf_max_size = 10)
        : m_data_matrix(mat)
    {
        const auto dims = row_major ? mat.get().cols() : mat.get().rows();
        if (static_cast<Dimension>(dims) != dimensionality)
            throw std::runtime_error(
                "Error: 'dimensionality' must match column count in data "
                "matrix");
        if (DIM > 0 && static_cast<int32_t>(dims) != DIM)
            throw std::runtime_error(
                "Data set dimensionality does not match the 'DIM' template "
                "argument");
        index_ = new index_t(
            dims, *this /* adaptor */,
            nanoflann::KDTreeSingleIndexAdaptorParams(leaf_max_size));
    }

   public:
    /** Deleted copy constructor */
    KDTreeEigenMatrixAdaptor(const self_t&) = delete;

    ~KDTreeEigenMatrixAdaptor() { delete index_; }

    const std::reference_wrapper<const MatrixType> m_data_matrix;

    /** Query for the \a num_closest closest points to a given point (entered as
     * query_point[0:dim-1]). Note that this is a short-cut method for
     * index->findNeighbors(). The user can also call index->... methods as
     * desired.
     *
     * \note If L2 norms are used, all returned distances are actually squared
     *       distances.
     */
    void query(
        const num_t* query_point, const Size num_closest,
        IndexType* out_indices, num_t* out_distances) const
    {
        nanoflann::KNNResultSet<num_t, IndexType> resultSet(num_closest);
        resultSet.init(out_indices, out_distances);
        index_->findNeighbors(resultSet, query_point);
    }

    /** @name Interface expected by KDTreeSingleIndexAdaptor
     * @{ */

    const self_t& derived() const { return *this; }
    self_t&       derived() { return *this; }

    // Must return the number of data points
    Size kdtree_get_point_count() const
    {
        if (row_major)
            return m_data_matrix.get().rows();
        else
            return m_data_matrix.get().cols();
    }

    // Returns the dim'th component of the idx'th point in the class:
    num_t kdtree_get_pt(const IndexType idx, size_t dim) const
    {
        if (row_major)
            return m_data_matrix.get().coeff(idx, IndexType(dim));
        else
            return m_data_matrix.get().coeff(IndexType(dim), idx);
    }

    // Optional bounding-box computation: return false to default to a standard
    // bbox computation loop.
    //   Return true if the BBOX was already computed by the class and returned
    //   in "bb" so it can be avoided to redo it again. Look at bb.size() to
    //   find out the expected dimensionality (e.g. 2 or 3 for point clouds)
    template <class BBOX>
    bool kdtree_get_bbox(BBOX& /*bb*/) const
    {
        return false;
    }

    /** @} */

};  // end of KDTreeEigenMatrixAdaptor
/** @} */

/** @} */  // end of grouping
}  // namespace nanoflann

```

`ext/nanosvg/nanosvg.h`:

```h
/*
 * Copyright (c) 2013-14 Mikko Mononen memon@inside.org
 *
 * This software is provided 'as-is', without any express or implied
 * warranty.  In no event will the authors be held liable for any damages
 * arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must not
 * claim that you wrote the original software. If you use this software
 * in a product, an acknowledgment in the product documentation would be
 * appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be
 * misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 *
 * The SVG parser is based on Anti-Grain Geometry 2.4 SVG example
 * Copyright (C) 2002-2004 Maxim Shemanarev (McSeem) (http://www.antigrain.com/)
 *
 * Arc calculation code based on canvg (https://code.google.com/p/canvg/)
 *
 * Bounding box calculation based on http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
 *
 */

#ifndef NANOSVG_H
#define NANOSVG_H

#ifndef NANOSVG_CPLUSPLUS
#ifdef __cplusplus
extern "C" {
#endif
#endif

// NanoSVG is a simple stupid single-header-file SVG parse. The output of the parser is a list of cubic bezier shapes.
//
// The library suits well for anything from rendering scalable icons in your editor application to prototyping a game.
//
// NanoSVG supports a wide range of SVG features, but something may be missing, feel free to create a pull request!
//
// The shapes in the SVG images are transformed by the viewBox and converted to specified units.
// That is, you should get the same looking data as your designed in your favorite app.
//
// NanoSVG can return the paths in few different units. For example if you want to render an image, you may choose
// to get the paths in pixels, or if you are feeding the data into a CNC-cutter, you may want to use millimeters.
//
// The units passed to NanoSVG should be one of: 'px', 'pt', 'pc' 'mm', 'cm', or 'in'.
// DPI (dots-per-inch) controls how the unit conversion is done.
//
// If you don't know or care about the units stuff, "px" and 96 should get you going.


/* Example Usage:
	// Load SVG
	NSVGimage* image;
	image = nsvgParseFromFile("test.svg", "px", 96);
	printf("size: %f x %f\n", image->width, image->height);
	// Use...
	for (NSVGshape *shape = image->shapes; shape != NULL; shape = shape->next) {
		for (NSVGpath *path = shape->paths; path != NULL; path = path->next) {
			for (int i = 0; i < path->npts-1; i += 3) {
				float* p = &path->pts[i*2];
				drawCubicBez(p[0],p[1], p[2],p[3], p[4],p[5], p[6],p[7]);
			}
		}
	}
	// Delete
	nsvgDelete(image);
*/

enum NSVGpaintType {
	NSVG_PAINT_NONE = 0,
	NSVG_PAINT_COLOR = 1,
	NSVG_PAINT_LINEAR_GRADIENT = 2,
	NSVG_PAINT_RADIAL_GRADIENT = 3
};

enum NSVGspreadType {
	NSVG_SPREAD_PAD = 0,
	NSVG_SPREAD_REFLECT = 1,
	NSVG_SPREAD_REPEAT = 2
};

enum NSVGlineJoin {
	NSVG_JOIN_MITER = 0,
	NSVG_JOIN_ROUND = 1,
	NSVG_JOIN_BEVEL = 2
};

enum NSVGlineCap {
	NSVG_CAP_BUTT = 0,
	NSVG_CAP_ROUND = 1,
	NSVG_CAP_SQUARE = 2
};

enum NSVGfillRule {
	NSVG_FILLRULE_NONZERO = 0,
	NSVG_FILLRULE_EVENODD = 1
};

enum NSVGflags {
	NSVG_FLAGS_VISIBLE = 0x01
};

typedef struct NSVGgradientStop {
	unsigned int color;
	float offset;
} NSVGgradientStop;

typedef struct NSVGgradient {
	float xform[6];
	char spread;
	float fx, fy;
	int nstops;
	NSVGgradientStop stops[1];
} NSVGgradient;

typedef struct NSVGpaint {
	char type;
	union {
		unsigned int color;
		NSVGgradient* gradient;
	};
} NSVGpaint;

typedef struct NSVGpath
{
	float* pts;					// Cubic bezier points: x0,y0, [cpx1,cpx1,cpx2,cpy2,x1,y1], ...
	int npts;					// Total number of bezier points.
	char closed;				// Flag indicating if shapes should be treated as closed.
	float bounds[4];			// Tight bounding box of the shape [minx,miny,maxx,maxy].
	struct NSVGpath* next;		// Pointer to next path, or NULL if last element.
} NSVGpath;

typedef struct NSVGshape
{
	char id[64];				// Optional 'id' attr of the shape or its group
	NSVGpaint fill;				// Fill paint
	NSVGpaint stroke;			// Stroke paint
	float opacity;				// Opacity of the shape.
	float strokeWidth;			// Stroke width (scaled).
	float strokeDashOffset;		// Stroke dash offset (scaled).
	float strokeDashArray[8];			// Stroke dash array (scaled).
	char strokeDashCount;				// Number of dash values in dash array.
	char strokeLineJoin;		// Stroke join type.
	char strokeLineCap;			// Stroke cap type.
	float miterLimit;			// Miter limit
	char fillRule;				// Fill rule, see NSVGfillRule.
	unsigned char flags;		// Logical or of NSVG_FLAGS_* flags
	float bounds[4];			// Tight bounding box of the shape [minx,miny,maxx,maxy].
	NSVGpath* paths;			// Linked list of paths in the image.
	struct NSVGshape* next;		// Pointer to next shape, or NULL if last element.
} NSVGshape;

typedef struct NSVGimage
{
	float width;				// Width of the image.
	float height;				// Height of the image.
	NSVGshape* shapes;			// Linked list of shapes in the image.
} NSVGimage;

// Parses SVG file from a file, returns SVG image as paths.
NSVGimage* nsvgParseFromFile(const char* filename, const char* units, float dpi);

// Parses SVG file from a null terminated string, returns SVG image as paths.
// Important note: changes the string.
NSVGimage* nsvgParse(char* input, const char* units, float dpi);

// Duplicates a path.
NSVGpath* nsvgDuplicatePath(NSVGpath* p);

// Deletes an image.
void nsvgDelete(NSVGimage* image);

#ifndef NANOSVG_CPLUSPLUS
#ifdef __cplusplus
}
#endif
#endif

#endif // NANOSVG_H

#ifdef NANOSVG_IMPLEMENTATION

#include <string.h>
#include <stdlib.h>
#include <math.h>

#define NSVG_PI (3.14159265358979323846264338327f)
#define NSVG_KAPPA90 (0.5522847493f)	// Length proportional to radius of a cubic bezier handle for 90deg arcs.

#define NSVG_ALIGN_MIN 0
#define NSVG_ALIGN_MID 1
#define NSVG_ALIGN_MAX 2
#define NSVG_ALIGN_NONE 0
#define NSVG_ALIGN_MEET 1
#define NSVG_ALIGN_SLICE 2

#define NSVG_NOTUSED(v) do { (void)(1 ? (void)0 : ( (void)(v) ) ); } while(0)
#define NSVG_RGB(r, g, b) (((unsigned int)r) | ((unsigned int)g << 8) | ((unsigned int)b << 16))

#ifdef _MSC_VER
	#pragma warning (disable: 4996) // Switch off security warnings
	#pragma warning (disable: 4100) // Switch off unreferenced formal parameter warnings
	#ifdef __cplusplus
	#define NSVG_INLINE inline
	#else
	#define NSVG_INLINE
	#endif
#else
	#define NSVG_INLINE inline
#endif


static int nsvg__isspace(char c)
{
	return strchr(" \t\n\v\f\r", c) != 0;
}

static int nsvg__isdigit(char c)
{
	return c >= '0' && c <= '9';
}

static NSVG_INLINE float nsvg__minf(float a, float b) { return a < b ? a : b; }
static NSVG_INLINE float nsvg__maxf(float a, float b) { return a > b ? a : b; }


// Simple XML parser

#define NSVG_XML_TAG 1
#define NSVG_XML_CONTENT 2
#define NSVG_XML_MAX_ATTRIBS 256

static void nsvg__parseContent(char* s,
							   void (*contentCb)(void* ud, const char* s),
							   void* ud)
{
	// Trim start white spaces
	while (*s && nsvg__isspace(*s)) s++;
	if (!*s) return;

	if (contentCb)
		(*contentCb)(ud, s);
}

static void nsvg__parseElement(char* s,
							   void (*startelCb)(void* ud, const char* el, const char** attr),
							   void (*endelCb)(void* ud, const char* el),
							   void* ud)
{
	const char* attr[NSVG_XML_MAX_ATTRIBS];
	int nattr = 0;
	char* name;
	int start = 0;
	int end = 0;
	char quote;

	// Skip white space after the '<'
	while (*s && nsvg__isspace(*s)) s++;

	// Check if the tag is end tag
	if (*s == '/') {
		s++;
		end = 1;
	} else {
		start = 1;
	}

	// Skip comments, data and preprocessor stuff.
	if (!*s || *s == '?' || *s == '!')
		return;

	// Get tag name
	name = s;
	while (*s && !nsvg__isspace(*s)) s++;
	if (*s) { *s++ = '\0'; }

	// Get attribs
	while (!end && *s && nattr < NSVG_XML_MAX_ATTRIBS-3) {
		char* name = NULL;
		char* value = NULL;

		// Skip white space before the attrib name
		while (*s && nsvg__isspace(*s)) s++;
		if (!*s) break;
		if (*s == '/') {
			end = 1;
			break;
		}
		name = s;
		// Find end of the attrib name.
		while (*s && !nsvg__isspace(*s) && *s != '=') s++;
		if (*s) { *s++ = '\0'; }
		// Skip until the beginning of the value.
		while (*s && *s != '\"' && *s != '\'') s++;
		if (!*s) break;
		quote = *s;
		s++;
		// Store value and find the end of it.
		value = s;
		while (*s && *s != quote) s++;
		if (*s) { *s++ = '\0'; }

		// Store only well formed attributes
		if (name && value) {
			attr[nattr++] = name;
			attr[nattr++] = value;
		}
	}

	// List terminator
	attr[nattr++] = 0;
	attr[nattr++] = 0;

	// Call callbacks.
	if (start && startelCb)
		(*startelCb)(ud, name, attr);
	if (end && endelCb)
		(*endelCb)(ud, name);
}

int nsvg__parseXML(char* input,
				   void (*startelCb)(void* ud, const char* el, const char** attr),
				   void (*endelCb)(void* ud, const char* el),
				   void (*contentCb)(void* ud, const char* s),
				   void* ud)
{
	char* s = input;
	char* mark = s;
	int state = NSVG_XML_CONTENT;
	while (*s) {
		if (*s == '<' && state == NSVG_XML_CONTENT) {
			// Start of a tag
			*s++ = '\0';
			nsvg__parseContent(mark, contentCb, ud);
			mark = s;
			state = NSVG_XML_TAG;
		} else if (*s == '>' && state == NSVG_XML_TAG) {
			// Start of a content or new tag.
			*s++ = '\0';
			nsvg__parseElement(mark, startelCb, endelCb, ud);
			mark = s;
			state = NSVG_XML_CONTENT;
		} else {
			s++;
		}
	}

	return 1;
}


/* Simple SVG parser. */

#define NSVG_MAX_ATTR 128

enum NSVGgradientUnits {
	NSVG_USER_SPACE = 0,
	NSVG_OBJECT_SPACE = 1
};

#define NSVG_MAX_DASHES 8

enum NSVGunits {
	NSVG_UNITS_USER,
	NSVG_UNITS_PX,
	NSVG_UNITS_PT,
	NSVG_UNITS_PC,
	NSVG_UNITS_MM,
	NSVG_UNITS_CM,
	NSVG_UNITS_IN,
	NSVG_UNITS_PERCENT,
	NSVG_UNITS_EM,
	NSVG_UNITS_EX
};

typedef struct NSVGcoordinate {
	float value;
	int units;
} NSVGcoordinate;

typedef struct NSVGlinearData {
	NSVGcoordinate x1, y1, x2, y2;
} NSVGlinearData;

typedef struct NSVGradialData {
	NSVGcoordinate cx, cy, r, fx, fy;
} NSVGradialData;

typedef struct NSVGgradientData
{
	char id[64];
	char ref[64];
	char type;
	union {
		NSVGlinearData linear;
		NSVGradialData radial;
	};
	char spread;
	char units;
	float xform[6];
	int nstops;
	NSVGgradientStop* stops;
	struct NSVGgradientData* next;
} NSVGgradientData;

typedef struct NSVGattrib
{
	char id[64];
	float xform[6];
	unsigned int fillColor;
	unsigned int strokeColor;
	float opacity;
	float fillOpacity;
	float strokeOpacity;
	char fillGradient[64];
	char strokeGradient[64];
	float strokeWidth;
	float strokeDashOffset;
	float strokeDashArray[NSVG_MAX_DASHES];
	int strokeDashCount;
	char strokeLineJoin;
	char strokeLineCap;
	float miterLimit;
	char fillRule;
	float fontSize;
	unsigned int stopColor;
	float stopOpacity;
	float stopOffset;
	char hasFill;
	char hasStroke;
	char visible;
} NSVGattrib;

typedef struct NSVGparser
{
	NSVGattrib attr[NSVG_MAX_ATTR];
	int attrHead;
	float* pts;
	int npts;
	int cpts;
	NSVGpath* plist;
	NSVGimage* image;
	NSVGgradientData* gradients;
	NSVGshape* shapesTail;
	float viewMinx, viewMiny, viewWidth, viewHeight;
	int alignX, alignY, alignType;
	float dpi;
	char pathFlag;
	char defsFlag;
} NSVGparser;

static void nsvg__xformIdentity(float* t)
{
	t[0] = 1.0f; t[1] = 0.0f;
	t[2] = 0.0f; t[3] = 1.0f;
	t[4] = 0.0f; t[5] = 0.0f;
}

static void nsvg__xformSetTranslation(float* t, float tx, float ty)
{
	t[0] = 1.0f; t[1] = 0.0f;
	t[2] = 0.0f; t[3] = 1.0f;
	t[4] = tx; t[5] = ty;
}

static void nsvg__xformSetScale(float* t, float sx, float sy)
{
	t[0] = sx; t[1] = 0.0f;
	t[2] = 0.0f; t[3] = sy;
	t[4] = 0.0f; t[5] = 0.0f;
}

static void nsvg__xformSetSkewX(float* t, float a)
{
	t[0] = 1.0f; t[1] = 0.0f;
	t[2] = tanf(a); t[3] = 1.0f;
	t[4] = 0.0f; t[5] = 0.0f;
}

static void nsvg__xformSetSkewY(float* t, float a)
{
	t[0] = 1.0f; t[1] = tanf(a);
	t[2] = 0.0f; t[3] = 1.0f;
	t[4] = 0.0f; t[5] = 0.0f;
}

static void nsvg__xformSetRotation(float* t, float a)
{
	float cs = cosf(a), sn = sinf(a);
	t[0] = cs; t[1] = sn;
	t[2] = -sn; t[3] = cs;
	t[4] = 0.0f; t[5] = 0.0f;
}

static void nsvg__xformMultiply(float* t, float* s)
{
	float t0 = t[0] * s[0] + t[1] * s[2];
	float t2 = t[2] * s[0] + t[3] * s[2];
	float t4 = t[4] * s[0] + t[5] * s[2] + s[4];
	t[1] = t[0] * s[1] + t[1] * s[3];
	t[3] = t[2] * s[1] + t[3] * s[3];
	t[5] = t[4] * s[1] + t[5] * s[3] + s[5];
	t[0] = t0;
	t[2] = t2;
	t[4] = t4;
}

static void nsvg__xformInverse(float* inv, float* t)
{
	double invdet, det = (double)t[0] * t[3] - (double)t[2] * t[1];
	if (det > -1e-6 && det < 1e-6) {
		nsvg__xformIdentity(t);
		return;
	}
	invdet = 1.0 / det;
	inv[0] = (float)(t[3] * invdet);
	inv[2] = (float)(-t[2] * invdet);
	inv[4] = (float)(((double)t[2] * t[5] - (double)t[3] * t[4]) * invdet);
	inv[1] = (float)(-t[1] * invdet);
	inv[3] = (float)(t[0] * invdet);
	inv[5] = (float)(((double)t[1] * t[4] - (double)t[0] * t[5]) * invdet);
}

static void nsvg__xformPremultiply(float* t, float* s)
{
	float s2[6];
	memcpy(s2, s, sizeof(float)*6);
	nsvg__xformMultiply(s2, t);
	memcpy(t, s2, sizeof(float)*6);
}

static void nsvg__xformPoint(float* dx, float* dy, float x, float y, float* t)
{
	*dx = x*t[0] + y*t[2] + t[4];
	*dy = x*t[1] + y*t[3] + t[5];
}

static void nsvg__xformVec(float* dx, float* dy, float x, float y, float* t)
{
	*dx = x*t[0] + y*t[2];
	*dy = x*t[1] + y*t[3];
}

#define NSVG_EPSILON (1e-12)

static int nsvg__ptInBounds(float* pt, float* bounds)
{
	return pt[0] >= bounds[0] && pt[0] <= bounds[2] && pt[1] >= bounds[1] && pt[1] <= bounds[3];
}


static double nsvg__evalBezier(double t, double p0, double p1, double p2, double p3)
{
	double it = 1.0-t;
	return it*it*it*p0 + 3.0*it*it*t*p1 + 3.0*it*t*t*p2 + t*t*t*p3;
}

static void nsvg__curveBounds(float* bounds, float* curve)
{
	int i, j, count;
	double roots[2], a, b, c, b2ac, t, v;
	float* v0 = &curve[0];
	float* v1 = &curve[2];
	float* v2 = &curve[4];
	float* v3 = &curve[6];

	// Start the bounding box by end points
	bounds[0] = nsvg__minf(v0[0], v3[0]);
	bounds[1] = nsvg__minf(v0[1], v3[1]);
	bounds[2] = nsvg__maxf(v0[0], v3[0]);
	bounds[3] = nsvg__maxf(v0[1], v3[1]);

	// Bezier curve fits inside the convex hull of it's control points.
	// If control points are inside the bounds, we're done.
	if (nsvg__ptInBounds(v1, bounds) && nsvg__ptInBounds(v2, bounds))
		return;

	// Add bezier curve inflection points in X and Y.
	for (i = 0; i < 2; i++) {
		a = -3.0 * v0[i] + 9.0 * v1[i] - 9.0 * v2[i] + 3.0 * v3[i];
		b = 6.0 * v0[i] - 12.0 * v1[i] + 6.0 * v2[i];
		c = 3.0 * v1[i] - 3.0 * v0[i];
		count = 0;
		if (fabs(a) < NSVG_EPSILON) {
			if (fabs(b) > NSVG_EPSILON) {
				t = -c / b;
				if (t > NSVG_EPSILON && t < 1.0-NSVG_EPSILON)
					roots[count++] = t;
			}
		} else {
			b2ac = b*b - 4.0*c*a;
			if (b2ac > NSVG_EPSILON) {
				t = (-b + sqrt(b2ac)) / (2.0 * a);
				if (t > NSVG_EPSILON && t < 1.0-NSVG_EPSILON)
					roots[count++] = t;
				t = (-b - sqrt(b2ac)) / (2.0 * a);
				if (t > NSVG_EPSILON && t < 1.0-NSVG_EPSILON)
					roots[count++] = t;
			}
		}
		for (j = 0; j < count; j++) {
			v = nsvg__evalBezier(roots[j], v0[i], v1[i], v2[i], v3[i]);
			bounds[0+i] = nsvg__minf(bounds[0+i], (float)v);
			bounds[2+i] = nsvg__maxf(bounds[2+i], (float)v);
		}
	}
}

static NSVGparser* nsvg__createParser()
{
	NSVGparser* p;
	p = (NSVGparser*)malloc(sizeof(NSVGparser));
	if (p == NULL) goto error;
	memset(p, 0, sizeof(NSVGparser));

	p->image = (NSVGimage*)malloc(sizeof(NSVGimage));
	if (p->image == NULL) goto error;
	memset(p->image, 0, sizeof(NSVGimage));

	// Init style
	nsvg__xformIdentity(p->attr[0].xform);
	memset(p->attr[0].id, 0, sizeof p->attr[0].id);
	p->attr[0].fillColor = NSVG_RGB(0,0,0);
	p->attr[0].strokeColor = NSVG_RGB(0,0,0);
	p->attr[0].opacity = 1;
	p->attr[0].fillOpacity = 1;
	p->attr[0].strokeOpacity = 1;
	p->attr[0].stopOpacity = 1;
	p->attr[0].strokeWidth = 1;
	p->attr[0].strokeLineJoin = NSVG_JOIN_MITER;
	p->attr[0].strokeLineCap = NSVG_CAP_BUTT;
	p->attr[0].miterLimit = 4;
	p->attr[0].fillRule = NSVG_FILLRULE_NONZERO;
	p->attr[0].hasFill = 1;
	p->attr[0].visible = 1;

	return p;

error:
	if (p) {
		if (p->image) free(p->image);
		free(p);
	}
	return NULL;
}

static void nsvg__deletePaths(NSVGpath* path)
{
	while (path) {
		NSVGpath *next = path->next;
		if (path->pts != NULL)
			free(path->pts);
		free(path);
		path = next;
	}
}

static void nsvg__deletePaint(NSVGpaint* paint)
{
	if (paint->type == NSVG_PAINT_LINEAR_GRADIENT || paint->type == NSVG_PAINT_RADIAL_GRADIENT)
		free(paint->gradient);
}

static void nsvg__deleteGradientData(NSVGgradientData* grad)
{
	NSVGgradientData* next;
	while (grad != NULL) {
		next = grad->next;
		free(grad->stops);
		free(grad);
		grad = next;
	}
}

static void nsvg__deleteParser(NSVGparser* p)
{
	if (p != NULL) {
		nsvg__deletePaths(p->plist);
		nsvg__deleteGradientData(p->gradients);
		nsvgDelete(p->image);
		free(p->pts);
		free(p);
	}
}

static void nsvg__resetPath(NSVGparser* p)
{
	p->npts = 0;
}

static void nsvg__addPoint(NSVGparser* p, float x, float y)
{
	if (p->npts+1 > p->cpts) {
		p->cpts = p->cpts ? p->cpts*2 : 8;
		p->pts = (float*)realloc(p->pts, p->cpts*2*sizeof(float));
		if (!p->pts) return;
	}
	p->pts[p->npts*2+0] = x;
	p->pts[p->npts*2+1] = y;
	p->npts++;
}

static void nsvg__moveTo(NSVGparser* p, float x, float y)
{
	if (p->npts > 0) {
		p->pts[(p->npts-1)*2+0] = x;
		p->pts[(p->npts-1)*2+1] = y;
	} else {
		nsvg__addPoint(p, x, y);
	}
}

static void nsvg__lineTo(NSVGparser* p, float x, float y)
{
	float px,py, dx,dy;
	if (p->npts > 0) {
		px = p->pts[(p->npts-1)*2+0];
		py = p->pts[(p->npts-1)*2+1];
		dx = x - px;
		dy = y - py;
		nsvg__addPoint(p, px + dx/3.0f, py + dy/3.0f);
		nsvg__addPoint(p, x - dx/3.0f, y - dy/3.0f);
		nsvg__addPoint(p, x, y);
	}
}

static void nsvg__cubicBezTo(NSVGparser* p, float cpx1, float cpy1, float cpx2, float cpy2, float x, float y)
{
	if (p->npts > 0) {
		nsvg__addPoint(p, cpx1, cpy1);
		nsvg__addPoint(p, cpx2, cpy2);
		nsvg__addPoint(p, x, y);
	}
}

static NSVGattrib* nsvg__getAttr(NSVGparser* p)
{
	return &p->attr[p->attrHead];
}

static void nsvg__pushAttr(NSVGparser* p)
{
	if (p->attrHead < NSVG_MAX_ATTR-1) {
		p->attrHead++;
		memcpy(&p->attr[p->attrHead], &p->attr[p->attrHead-1], sizeof(NSVGattrib));
	}
}

static void nsvg__popAttr(NSVGparser* p)
{
	if (p->attrHead > 0)
		p->attrHead--;
}

static float nsvg__actualOrigX(NSVGparser* p)
{
	return p->viewMinx;
}

static float nsvg__actualOrigY(NSVGparser* p)
{
	return p->viewMiny;
}

static float nsvg__actualWidth(NSVGparser* p)
{
	return p->viewWidth;
}

static float nsvg__actualHeight(NSVGparser* p)
{
	return p->viewHeight;
}

static float nsvg__actualLength(NSVGparser* p)
{
	float w = nsvg__actualWidth(p), h = nsvg__actualHeight(p);
	return sqrtf(w*w + h*h) / sqrtf(2.0f);
}

static float nsvg__convertToPixels(NSVGparser* p, NSVGcoordinate c, float orig, float length)
{
	NSVGattrib* attr = nsvg__getAttr(p);
	switch (c.units) {
		case NSVG_UNITS_USER:		return c.value;
		case NSVG_UNITS_PX:			return c.value;
		case NSVG_UNITS_PT:			return c.value / 72.0f * p->dpi;
		case NSVG_UNITS_PC:			return c.value / 6.0f * p->dpi;
		case NSVG_UNITS_MM:			return c.value / 25.4f * p->dpi;
		case NSVG_UNITS_CM:			return c.value / 2.54f * p->dpi;
		case NSVG_UNITS_IN:			return c.value * p->dpi;
		case NSVG_UNITS_EM:			return c.value * attr->fontSize;
		case NSVG_UNITS_EX:			return c.value * attr->fontSize * 0.52f; // x-height of Helvetica.
		case NSVG_UNITS_PERCENT:	return orig + c.value / 100.0f * length;
		default:					return c.value;
	}
	return c.value;
}

static NSVGgradientData* nsvg__findGradientData(NSVGparser* p, const char* id)
{
	NSVGgradientData* grad = p->gradients;
	if (id == NULL || *id == '\0')
		return NULL;
	while (grad != NULL) {
		if (strcmp(grad->id, id) == 0)
			return grad;
		grad = grad->next;
	}
	return NULL;
}

static NSVGgradient* nsvg__createGradient(NSVGparser* p, const char* id, const float* localBounds, char* paintType)
{
	NSVGattrib* attr = nsvg__getAttr(p);
	NSVGgradientData* data = NULL;
	NSVGgradientData* ref = NULL;
	NSVGgradientStop* stops = NULL;
	NSVGgradient* grad;
	float ox, oy, sw, sh, sl;
	int nstops = 0;
	int refIter;

	data = nsvg__findGradientData(p, id);
	if (data == NULL) return NULL;

	// TODO: use ref to fill in all unset values too.
	ref = data;
	refIter = 0;
	while (ref != NULL) {
		NSVGgradientData* nextRef = NULL;
		if (stops == NULL && ref->stops != NULL) {
			stops = ref->stops;
			nstops = ref->nstops;
			break;
		}
		nextRef = nsvg__findGradientData(p, ref->ref);
		if (nextRef == ref) break; // prevent infite loops on malformed data
		ref = nextRef;
		refIter++;
		if (refIter > 32) break; // prevent infite loops on malformed data
	}
	if (stops == NULL) return NULL;

	grad = (NSVGgradient*)malloc(sizeof(NSVGgradient) + sizeof(NSVGgradientStop)*(nstops-1));
	if (grad == NULL) return NULL;

	// The shape width and height.
	if (data->units == NSVG_OBJECT_SPACE) {
		ox = localBounds[0];
		oy = localBounds[1];
		sw = localBounds[2] - localBounds[0];
		sh = localBounds[3] - localBounds[1];
	} else {
		ox = nsvg__actualOrigX(p);
		oy = nsvg__actualOrigY(p);
		sw = nsvg__actualWidth(p);
		sh = nsvg__actualHeight(p);
	}
	sl = sqrtf(sw*sw + sh*sh) / sqrtf(2.0f);

	if (data->type == NSVG_PAINT_LINEAR_GRADIENT) {
		float x1, y1, x2, y2, dx, dy;
		x1 = nsvg__convertToPixels(p, data->linear.x1, ox, sw);
		y1 = nsvg__convertToPixels(p, data->linear.y1, oy, sh);
		x2 = nsvg__convertToPixels(p, data->linear.x2, ox, sw);
		y2 = nsvg__convertToPixels(p, data->linear.y2, oy, sh);
		// Calculate transform aligned to the line
		dx = x2 - x1;
		dy = y2 - y1;
		grad->xform[0] = dy; grad->xform[1] = -dx;
		grad->xform[2] = dx; grad->xform[3] = dy;
		grad->xform[4] = x1; grad->xform[5] = y1;
	} else {
		float cx, cy, fx, fy, r;
		cx = nsvg__convertToPixels(p, data->radial.cx, ox, sw);
		cy = nsvg__convertToPixels(p, data->radial.cy, oy, sh);
		fx = nsvg__convertToPixels(p, data->radial.fx, ox, sw);
		fy = nsvg__convertToPixels(p, data->radial.fy, oy, sh);
		r = nsvg__convertToPixels(p, data->radial.r, 0, sl);
		// Calculate transform aligned to the circle
		grad->xform[0] = r; grad->xform[1] = 0;
		grad->xform[2] = 0; grad->xform[3] = r;
		grad->xform[4] = cx; grad->xform[5] = cy;
		grad->fx = fx / r;
		grad->fy = fy / r;
	}

	nsvg__xformMultiply(grad->xform, data->xform);
	nsvg__xformMultiply(grad->xform, attr->xform);

	grad->spread = data->spread;
	memcpy(grad->stops, stops, nstops*sizeof(NSVGgradientStop));
	grad->nstops = nstops;

	*paintType = data->type;

	return grad;
}

static float nsvg__getAverageScale(float* t)
{
	float sx = sqrtf(t[0]*t[0] + t[2]*t[2]);
	float sy = sqrtf(t[1]*t[1] + t[3]*t[3]);
	return (sx + sy) * 0.5f;
}

static void nsvg__getLocalBounds(float* bounds, NSVGshape *shape, float* xform)
{
	NSVGpath* path;
	float curve[4*2], curveBounds[4];
	int i, first = 1;
	for (path = shape->paths; path != NULL; path = path->next) {
		nsvg__xformPoint(&curve[0], &curve[1], path->pts[0], path->pts[1], xform);
		for (i = 0; i < path->npts-1; i += 3) {
			nsvg__xformPoint(&curve[2], &curve[3], path->pts[(i+1)*2], path->pts[(i+1)*2+1], xform);
			nsvg__xformPoint(&curve[4], &curve[5], path->pts[(i+2)*2], path->pts[(i+2)*2+1], xform);
			nsvg__xformPoint(&curve[6], &curve[7], path->pts[(i+3)*2], path->pts[(i+3)*2+1], xform);
			nsvg__curveBounds(curveBounds, curve);
			if (first) {
				bounds[0] = curveBounds[0];
				bounds[1] = curveBounds[1];
				bounds[2] = curveBounds[2];
				bounds[3] = curveBounds[3];
				first = 0;
			} else {
				bounds[0] = nsvg__minf(bounds[0], curveBounds[0]);
				bounds[1] = nsvg__minf(bounds[1], curveBounds[1]);
				bounds[2] = nsvg__maxf(bounds[2], curveBounds[2]);
				bounds[3] = nsvg__maxf(bounds[3], curveBounds[3]);
			}
			curve[0] = curve[6];
			curve[1] = curve[7];
		}
	}
}

static void nsvg__addShape(NSVGparser* p)
{
	NSVGattrib* attr = nsvg__getAttr(p);
	float scale = 1.0f;
	NSVGshape* shape;
	NSVGpath* path;
	int i;

	if (p->plist == NULL)
		return;

	shape = (NSVGshape*)malloc(sizeof(NSVGshape));
	if (shape == NULL) goto error;
	memset(shape, 0, sizeof(NSVGshape));

	memcpy(shape->id, attr->id, sizeof shape->id);
	scale = nsvg__getAverageScale(attr->xform);
	shape->strokeWidth = attr->strokeWidth * scale;
	shape->strokeDashOffset = attr->strokeDashOffset * scale;
	shape->strokeDashCount = (char)attr->strokeDashCount;
	for (i = 0; i < attr->strokeDashCount; i++)
		shape->strokeDashArray[i] = attr->strokeDashArray[i] * scale;
	shape->strokeLineJoin = attr->strokeLineJoin;
	shape->strokeLineCap = attr->strokeLineCap;
	shape->miterLimit = attr->miterLimit;
	shape->fillRule = attr->fillRule;
	shape->opacity = attr->opacity;

	shape->paths = p->plist;
	p->plist = NULL;

	// Calculate shape bounds
	shape->bounds[0] = shape->paths->bounds[0];
	shape->bounds[1] = shape->paths->bounds[1];
	shape->bounds[2] = shape->paths->bounds[2];
	shape->bounds[3] = shape->paths->bounds[3];
	for (path = shape->paths->next; path != NULL; path = path->next) {
		shape->bounds[0] = nsvg__minf(shape->bounds[0], path->bounds[0]);
		shape->bounds[1] = nsvg__minf(shape->bounds[1], path->bounds[1]);
		shape->bounds[2] = nsvg__maxf(shape->bounds[2], path->bounds[2]);
		shape->bounds[3] = nsvg__maxf(shape->bounds[3], path->bounds[3]);
	}

	// Set fill
	if (attr->hasFill == 0) {
		shape->fill.type = NSVG_PAINT_NONE;
	} else if (attr->hasFill == 1) {
		shape->fill.type = NSVG_PAINT_COLOR;
		shape->fill.color = attr->fillColor;
		shape->fill.color |= (unsigned int)(attr->fillOpacity*255) << 24;
	} else if (attr->hasFill == 2) {
		float inv[6], localBounds[4];
		nsvg__xformInverse(inv, attr->xform);
		nsvg__getLocalBounds(localBounds, shape, inv);
		shape->fill.gradient = nsvg__createGradient(p, attr->fillGradient, localBounds, &shape->fill.type);
		if (shape->fill.gradient == NULL) {
			shape->fill.type = NSVG_PAINT_NONE;
		}
	}

	// Set stroke
	if (attr->hasStroke == 0) {
		shape->stroke.type = NSVG_PAINT_NONE;
	} else if (attr->hasStroke == 1) {
		shape->stroke.type = NSVG_PAINT_COLOR;
		shape->stroke.color = attr->strokeColor;
		shape->stroke.color |= (unsigned int)(attr->strokeOpacity*255) << 24;
	} else if (attr->hasStroke == 2) {
		float inv[6], localBounds[4];
		nsvg__xformInverse(inv, attr->xform);
		nsvg__getLocalBounds(localBounds, shape, inv);
		shape->stroke.gradient = nsvg__createGradient(p, attr->strokeGradient, localBounds, &shape->stroke.type);
		if (shape->stroke.gradient == NULL)
			shape->stroke.type = NSVG_PAINT_NONE;
	}

	// Set flags
	shape->flags = (attr->visible ? NSVG_FLAGS_VISIBLE : 0x00);

	// Add to tail
	if (p->image->shapes == NULL)
		p->image->shapes = shape;
	else
		p->shapesTail->next = shape;
	p->shapesTail = shape;

	return;

error:
	if (shape) free(shape);
}

static void nsvg__addPath(NSVGparser* p, char closed)
{
	NSVGattrib* attr = nsvg__getAttr(p);
	NSVGpath* path = NULL;
	float bounds[4];
	float* curve;
	int i;

	if (p->npts < 4)
		return;

	if (closed)
		nsvg__lineTo(p, p->pts[0], p->pts[1]);

	// Expect 1 + N*3 points (N = number of cubic bezier segments).
	if ((p->npts % 3) != 1)
		return;

	path = (NSVGpath*)malloc(sizeof(NSVGpath));
	if (path == NULL) goto error;
	memset(path, 0, sizeof(NSVGpath));

	path->pts = (float*)malloc(p->npts*2*sizeof(float));
	if (path->pts == NULL) goto error;
	path->closed = closed;
	path->npts = p->npts;

	// Transform path.
	for (i = 0; i < p->npts; ++i)
		nsvg__xformPoint(&path->pts[i*2], &path->pts[i*2+1], p->pts[i*2], p->pts[i*2+1], attr->xform);

	// Find bounds
	for (i = 0; i < path->npts-1; i += 3) {
		curve = &path->pts[i*2];
		nsvg__curveBounds(bounds, curve);
		if (i == 0) {
			path->bounds[0] = bounds[0];
			path->bounds[1] = bounds[1];
			path->bounds[2] = bounds[2];
			path->bounds[3] = bounds[3];
		} else {
			path->bounds[0] = nsvg__minf(path->bounds[0], bounds[0]);
			path->bounds[1] = nsvg__minf(path->bounds[1], bounds[1]);
			path->bounds[2] = nsvg__maxf(path->bounds[2], bounds[2]);
			path->bounds[3] = nsvg__maxf(path->bounds[3], bounds[3]);
		}
	}

	path->next = p->plist;
	p->plist = path;

	return;

error:
	if (path != NULL) {
		if (path->pts != NULL) free(path->pts);
		free(path);
	}
}

// We roll our own string to float because the std library one uses locale and messes things up.
static double nsvg__atof(const char* s)
{
	char* cur = (char*)s;
	char* end = NULL;
	double res = 0.0, sign = 1.0;
	long long intPart = 0, fracPart = 0;
	char hasIntPart = 0, hasFracPart = 0;

	// Parse optional sign
	if (*cur == '+') {
		cur++;
	} else if (*cur == '-') {
		sign = -1;
		cur++;
	}

	// Parse integer part
	if (nsvg__isdigit(*cur)) {
		// Parse digit sequence
		intPart = strtoll(cur, &end, 10);
		if (cur != end) {
			res = (double)intPart;
			hasIntPart = 1;
			cur = end;
		}
	}

	// Parse fractional part.
	if (*cur == '.') {
		cur++; // Skip '.'
		if (nsvg__isdigit(*cur)) {
			// Parse digit sequence
			fracPart = strtoll(cur, &end, 10);
			if (cur != end) {
				res += (double)fracPart / pow(10.0, (double)(end - cur));
				hasFracPart = 1;
				cur = end;
			}
		}
	}

	// A valid number should have integer or fractional part.
	if (!hasIntPart && !hasFracPart)
		return 0.0;

	// Parse optional exponent
	if (*cur == 'e' || *cur == 'E') {
		long expPart = 0;
		cur++; // skip 'E'
		expPart = strtol(cur, &end, 10); // Parse digit sequence with sign
		if (cur != end) {
			res *= pow(10.0, (double)expPart);
		}
	}

	return res * sign;
}


static const char* nsvg__parseNumber(const char* s, char* it, const int size)
{
	const int last = size-1;
	int i = 0;

	// sign
	if (*s == '-' || *s == '+') {
		if (i < last) it[i++] = *s;
		s++;
	}
	// integer part
	while (*s && nsvg__isdigit(*s)) {
		if (i < last) it[i++] = *s;
		s++;
	}
	if (*s == '.') {
		// decimal point
		if (i < last) it[i++] = *s;
		s++;
		// fraction part
		while (*s && nsvg__isdigit(*s)) {
			if (i < last) it[i++] = *s;
			s++;
		}
	}
	// exponent
	if ((*s == 'e' || *s == 'E') && (s[1] != 'm' && s[1] != 'x')) {
		if (i < last) it[i++] = *s;
		s++;
		if (*s == '-' || *s == '+') {
			if (i < last) it[i++] = *s;
			s++;
		}
		while (*s && nsvg__isdigit(*s)) {
			if (i < last) it[i++] = *s;
			s++;
		}
	}
	it[i] = '\0';

	return s;
}

static const char* nsvg__getNextPathItem(const char* s, char* it)
{
	it[0] = '\0';
	// Skip white spaces and commas
	while (*s && (nsvg__isspace(*s) || *s == ',')) s++;
	if (!*s) return s;
	if (*s == '-' || *s == '+' || *s == '.' || nsvg__isdigit(*s)) {
		s = nsvg__parseNumber(s, it, 64);
	} else {
		// Parse command
		it[0] = *s++;
		it[1] = '\0';
		return s;
	}

	return s;
}

static unsigned int nsvg__parseColorHex(const char* str)
{
	unsigned int c = 0, r = 0, g = 0, b = 0;
	int n = 0;
	str++; // skip #
	// Calculate number of characters.
	while(str[n] && !nsvg__isspace(str[n]))
		n++;
	if (n == 6) {
		sscanf(str, "%x", &c);
	} else if (n == 3) {
		sscanf(str, "%x", &c);
		c = (c&0xf) | ((c&0xf0) << 4) | ((c&0xf00) << 8);
		c |= c<<4;
	}
	r = (c >> 16) & 0xff;
	g = (c >> 8) & 0xff;
	b = c & 0xff;
	return NSVG_RGB(r,g,b);
}

static unsigned int nsvg__parseColorRGB(const char* str)
{
	int r = -1, g = -1, b = -1;
	char s1[32]="", s2[32]="";
	sscanf(str + 4, "%d%[%%, \t]%d%[%%, \t]%d", &r, s1, &g, s2, &b);
	if (strchr(s1, '%')) {
		return NSVG_RGB((r*255)/100,(g*255)/100,(b*255)/100);
	} else {
		return NSVG_RGB(r,g,b);
	}
}

typedef struct NSVGNamedColor {
	const char* name;
	unsigned int color;
} NSVGNamedColor;

NSVGNamedColor nsvg__colors[] = {

	{ "red", NSVG_RGB(255, 0, 0) },
	{ "green", NSVG_RGB( 0, 128, 0) },
	{ "blue", NSVG_RGB( 0, 0, 255) },
	{ "yellow", NSVG_RGB(255, 255, 0) },
	{ "cyan", NSVG_RGB( 0, 255, 255) },
	{ "magenta", NSVG_RGB(255, 0, 255) },
	{ "black", NSVG_RGB( 0, 0, 0) },
	{ "grey", NSVG_RGB(128, 128, 128) },
	{ "gray", NSVG_RGB(128, 128, 128) },
	{ "white", NSVG_RGB(255, 255, 255) },

#ifdef NANOSVG_ALL_COLOR_KEYWORDS
	{ "aliceblue", NSVG_RGB(240, 248, 255) },
	{ "antiquewhite", NSVG_RGB(250, 235, 215) },
	{ "aqua", NSVG_RGB( 0, 255, 255) },
	{ "aquamarine", NSVG_RGB(127, 255, 212) },
	{ "azure", NSVG_RGB(240, 255, 255) },
	{ "beige", NSVG_RGB(245, 245, 220) },
	{ "bisque", NSVG_RGB(255, 228, 196) },
	{ "blanchedalmond", NSVG_RGB(255, 235, 205) },
	{ "blueviolet", NSVG_RGB(138, 43, 226) },
	{ "brown", NSVG_RGB(165, 42, 42) },
	{ "burlywood", NSVG_RGB(222, 184, 135) },
	{ "cadetblue", NSVG_RGB( 95, 158, 160) },
	{ "chartreuse", NSVG_RGB(127, 255, 0) },
	{ "chocolate", NSVG_RGB(210, 105, 30) },
	{ "coral", NSVG_RGB(255, 127, 80) },
	{ "cornflowerblue", NSVG_RGB(100, 149, 237) },
	{ "cornsilk", NSVG_RGB(255, 248, 220) },
	{ "crimson", NSVG_RGB(220, 20, 60) },
	{ "darkblue", NSVG_RGB( 0, 0, 139) },
	{ "darkcyan", NSVG_RGB( 0, 139, 139) },
	{ "darkgoldenrod", NSVG_RGB(184, 134, 11) },
	{ "darkgray", NSVG_RGB(169, 169, 169) },
	{ "darkgreen", NSVG_RGB( 0, 100, 0) },
	{ "darkgrey", NSVG_RGB(169, 169, 169) },
	{ "darkkhaki", NSVG_RGB(189, 183, 107) },
	{ "darkmagenta", NSVG_RGB(139, 0, 139) },
	{ "darkolivegreen", NSVG_RGB( 85, 107, 47) },
	{ "darkorange", NSVG_RGB(255, 140, 0) },
	{ "darkorchid", NSVG_RGB(153, 50, 204) },
	{ "darkred", NSVG_RGB(139, 0, 0) },
	{ "darksalmon", NSVG_RGB(233, 150, 122) },
	{ "darkseagreen", NSVG_RGB(143, 188, 143) },
	{ "darkslateblue", NSVG_RGB( 72, 61, 139) },
	{ "darkslategray", NSVG_RGB( 47, 79, 79) },
	{ "darkslategrey", NSVG_RGB( 47, 79, 79) },
	{ "darkturquoise", NSVG_RGB( 0, 206, 209) },
	{ "darkviolet", NSVG_RGB(148, 0, 211) },
	{ "deeppink", NSVG_RGB(255, 20, 147) },
	{ "deepskyblue", NSVG_RGB( 0, 191, 255) },
	{ "dimgray", NSVG_RGB(105, 105, 105) },
	{ "dimgrey", NSVG_RGB(105, 105, 105) },
	{ "dodgerblue", NSVG_RGB( 30, 144, 255) },
	{ "firebrick", NSVG_RGB(178, 34, 34) },
	{ "floralwhite", NSVG_RGB(255, 250, 240) },
	{ "forestgreen", NSVG_RGB( 34, 139, 34) },
	{ "fuchsia", NSVG_RGB(255, 0, 255) },
	{ "gainsboro", NSVG_RGB(220, 220, 220) },
	{ "ghostwhite", NSVG_RGB(248, 248, 255) },
	{ "gold", NSVG_RGB(255, 215, 0) },
	{ "goldenrod", NSVG_RGB(218, 165, 32) },
	{ "greenyellow", NSVG_RGB(173, 255, 47) },
	{ "honeydew", NSVG_RGB(240, 255, 240) },
	{ "hotpink", NSVG_RGB(255, 105, 180) },
	{ "indianred", NSVG_RGB(205, 92, 92) },
	{ "indigo", NSVG_RGB( 75, 0, 130) },
	{ "ivory", NSVG_RGB(255, 255, 240) },
	{ "khaki", NSVG_RGB(240, 230, 140) },
	{ "lavender", NSVG_RGB(230, 230, 250) },
	{ "lavenderblush", NSVG_RGB(255, 240, 245) },
	{ "lawngreen", NSVG_RGB(124, 252, 0) },
	{ "lemonchiffon", NSVG_RGB(255, 250, 205) },
	{ "lightblue", NSVG_RGB(173, 216, 230) },
	{ "lightcoral", NSVG_RGB(240, 128, 128) },
	{ "lightcyan", NSVG_RGB(224, 255, 255) },
	{ "lightgoldenrodyellow", NSVG_RGB(250, 250, 210) },
	{ "lightgray", NSVG_RGB(211, 211, 211) },
	{ "lightgreen", NSVG_RGB(144, 238, 144) },
	{ "lightgrey", NSVG_RGB(211, 211, 211) },
	{ "lightpink", NSVG_RGB(255, 182, 193) },
	{ "lightsalmon", NSVG_RGB(255, 160, 122) },
	{ "lightseagreen", NSVG_RGB( 32, 178, 170) },
	{ "lightskyblue", NSVG_RGB(135, 206, 250) },
	{ "lightslategray", NSVG_RGB(119, 136, 153) },
	{ "lightslategrey", NSVG_RGB(119, 136, 153) },
	{ "lightsteelblue", NSVG_RGB(176, 196, 222) },
	{ "lightyellow", NSVG_RGB(255, 255, 224) },
	{ "lime", NSVG_RGB( 0, 255, 0) },
	{ "limegreen", NSVG_RGB( 50, 205, 50) },
	{ "linen", NSVG_RGB(250, 240, 230) },
	{ "maroon", NSVG_RGB(128, 0, 0) },
	{ "mediumaquamarine", NSVG_RGB(102, 205, 170) },
	{ "mediumblue", NSVG_RGB( 0, 0, 205) },
	{ "mediumorchid", NSVG_RGB(186, 85, 211) },
	{ "mediumpurple", NSVG_RGB(147, 112, 219) },
	{ "mediumseagreen", NSVG_RGB( 60, 179, 113) },
	{ "mediumslateblue", NSVG_RGB(123, 104, 238) },
	{ "mediumspringgreen", NSVG_RGB( 0, 250, 154) },
	{ "mediumturquoise", NSVG_RGB( 72, 209, 204) },
	{ "mediumvioletred", NSVG_RGB(199, 21, 133) },
	{ "midnightblue", NSVG_RGB( 25, 25, 112) },
	{ "mintcream", NSVG_RGB(245, 255, 250) },
	{ "mistyrose", NSVG_RGB(255, 228, 225) },
	{ "moccasin", NSVG_RGB(255, 228, 181) },
	{ "navajowhite", NSVG_RGB(255, 222, 173) },
	{ "navy", NSVG_RGB( 0, 0, 128) },
	{ "oldlace", NSVG_RGB(253, 245, 230) },
	{ "olive", NSVG_RGB(128, 128, 0) },
	{ "olivedrab", NSVG_RGB(107, 142, 35) },
	{ "orange", NSVG_RGB(255, 165, 0) },
	{ "orangered", NSVG_RGB(255, 69, 0) },
	{ "orchid", NSVG_RGB(218, 112, 214) },
	{ "palegoldenrod", NSVG_RGB(238, 232, 170) },
	{ "palegreen", NSVG_RGB(152, 251, 152) },
	{ "paleturquoise", NSVG_RGB(175, 238, 238) },
	{ "palevioletred", NSVG_RGB(219, 112, 147) },
	{ "papayawhip", NSVG_RGB(255, 239, 213) },
	{ "peachpuff", NSVG_RGB(255, 218, 185) },
	{ "peru", NSVG_RGB(205, 133, 63) },
	{ "pink", NSVG_RGB(255, 192, 203) },
	{ "plum", NSVG_RGB(221, 160, 221) },
	{ "powderblue", NSVG_RGB(176, 224, 230) },
	{ "purple", NSVG_RGB(128, 0, 128) },
	{ "rosybrown", NSVG_RGB(188, 143, 143) },
	{ "royalblue", NSVG_RGB( 65, 105, 225) },
	{ "saddlebrown", NSVG_RGB(139, 69, 19) },
	{ "salmon", NSVG_RGB(250, 128, 114) },
	{ "sandybrown", NSVG_RGB(244, 164, 96) },
	{ "seagreen", NSVG_RGB( 46, 139, 87) },
	{ "seashell", NSVG_RGB(255, 245, 238) },
	{ "sienna", NSVG_RGB(160, 82, 45) },
	{ "silver", NSVG_RGB(192, 192, 192) },
	{ "skyblue", NSVG_RGB(135, 206, 235) },
	{ "slateblue", NSVG_RGB(106, 90, 205) },
	{ "slategray", NSVG_RGB(112, 128, 144) },
	{ "slategrey", NSVG_RGB(112, 128, 144) },
	{ "snow", NSVG_RGB(255, 250, 250) },
	{ "springgreen", NSVG_RGB( 0, 255, 127) },
	{ "steelblue", NSVG_RGB( 70, 130, 180) },
	{ "tan", NSVG_RGB(210, 180, 140) },
	{ "teal", NSVG_RGB( 0, 128, 128) },
	{ "thistle", NSVG_RGB(216, 191, 216) },
	{ "tomato", NSVG_RGB(255, 99, 71) },
	{ "turquoise", NSVG_RGB( 64, 224, 208) },
	{ "violet", NSVG_RGB(238, 130, 238) },
	{ "wheat", NSVG_RGB(245, 222, 179) },
	{ "whitesmoke", NSVG_RGB(245, 245, 245) },
	{ "yellowgreen", NSVG_RGB(154, 205, 50) },
#endif
};

static unsigned int nsvg__parseColorName(const char* str)
{
	int i, ncolors = sizeof(nsvg__colors) / sizeof(NSVGNamedColor);

	for (i = 0; i < ncolors; i++) {
		if (strcmp(nsvg__colors[i].name, str) == 0) {
			return nsvg__colors[i].color;
		}
	}

	return NSVG_RGB(128, 128, 128);
}

static unsigned int nsvg__parseColor(const char* str)
{
	size_t len = 0;
	while(*str == ' ') ++str;
	len = strlen(str);
	if (len >= 1 && *str == '#')
		return nsvg__parseColorHex(str);
	else if (len >= 4 && str[0] == 'r' && str[1] == 'g' && str[2] == 'b' && str[3] == '(')
		return nsvg__parseColorRGB(str);
	return nsvg__parseColorName(str);
}

static float nsvg__parseOpacity(const char* str)
{
	float val = (float)nsvg__atof(str);
	if (val < 0.0f) val = 0.0f;
	if (val > 1.0f) val = 1.0f;
	return val;
}

static float nsvg__parseMiterLimit(const char* str)
{
	float val = (float)nsvg__atof(str);
	if (val < 0.0f) val = 0.0f;
	return val;
}

static int nsvg__parseUnits(const char* units)
{
	if (units[0] == 'p' && units[1] == 'x')
		return NSVG_UNITS_PX;
	else if (units[0] == 'p' && units[1] == 't')
		return NSVG_UNITS_PT;
	else if (units[0] == 'p' && units[1] == 'c')
		return NSVG_UNITS_PC;
	else if (units[0] == 'm' && units[1] == 'm')
		return NSVG_UNITS_MM;
	else if (units[0] == 'c' && units[1] == 'm')
		return NSVG_UNITS_CM;
	else if (units[0] == 'i' && units[1] == 'n')
		return NSVG_UNITS_IN;
	else if (units[0] == '%')
		return NSVG_UNITS_PERCENT;
	else if (units[0] == 'e' && units[1] == 'm')
		return NSVG_UNITS_EM;
	else if (units[0] == 'e' && units[1] == 'x')
		return NSVG_UNITS_EX;
	return NSVG_UNITS_USER;
}

static int nsvg__isCoordinate(const char* s)
{
	// optional sign
	if (*s == '-' || *s == '+')
		s++;
	// must have at least one digit, or start by a dot
	return (nsvg__isdigit(*s) || *s == '.');
}

static NSVGcoordinate nsvg__parseCoordinateRaw(const char* str)
{
	NSVGcoordinate coord = {0, NSVG_UNITS_USER};
	char buf[64];
	coord.units = nsvg__parseUnits(nsvg__parseNumber(str, buf, 64));
	coord.value = (float)nsvg__atof(buf);
	return coord;
}

static NSVGcoordinate nsvg__coord(float v, int units)
{
	NSVGcoordinate coord = {v, units};
	return coord;
}

static float nsvg__parseCoordinate(NSVGparser* p, const char* str, float orig, float length)
{
	NSVGcoordinate coord = nsvg__parseCoordinateRaw(str);
	return nsvg__convertToPixels(p, coord, orig, length);
}

static int nsvg__parseTransformArgs(const char* str, float* args, int maxNa, int* na)
{
	const char* end;
	const char* ptr;
	char it[64];

	*na = 0;
	ptr = str;
	while (*ptr && *ptr != '(') ++ptr;
	if (*ptr == 0)
		return 1;
	end = ptr;
	while (*end && *end != ')') ++end;
	if (*end == 0)
		return 1;

	while (ptr < end) {
		if (*ptr == '-' || *ptr == '+' || *ptr == '.' || nsvg__isdigit(*ptr)) {
			if (*na >= maxNa) return 0;
			ptr = nsvg__parseNumber(ptr, it, 64);
			args[(*na)++] = (float)nsvg__atof(it);
		} else {
			++ptr;
		}
	}
	return (int)(end - str);
}


static int nsvg__parseMatrix(float* xform, const char* str)
{
	float t[6];
	int na = 0;
	int len = nsvg__parseTransformArgs(str, t, 6, &na);
	if (na != 6) return len;
	memcpy(xform, t, sizeof(float)*6);
	return len;
}

static int nsvg__parseTranslate(float* xform, const char* str)
{
	float args[2];
	float t[6];
	int na = 0;
	int len = nsvg__parseTransformArgs(str, args, 2, &na);
	if (na == 1) args[1] = 0.0;

	nsvg__xformSetTranslation(t, args[0], args[1]);
	memcpy(xform, t, sizeof(float)*6);
	return len;
}

static int nsvg__parseScale(float* xform, const char* str)
{
	float args[2];
	int na = 0;
	float t[6];
	int len = nsvg__parseTransformArgs(str, args, 2, &na);
	if (na == 1) args[1] = args[0];
	nsvg__xformSetScale(t, args[0], args[1]);
	memcpy(xform, t, sizeof(float)*6);
	return len;
}

static int nsvg__parseSkewX(float* xform, const char* str)
{
	float args[1];
	int na = 0;
	float t[6];
	int len = nsvg__parseTransformArgs(str, args, 1, &na);
	nsvg__xformSetSkewX(t, args[0]/180.0f*NSVG_PI);
	memcpy(xform, t, sizeof(float)*6);
	return len;
}

static int nsvg__parseSkewY(float* xform, const char* str)
{
	float args[1];
	int na = 0;
	float t[6];
	int len = nsvg__parseTransformArgs(str, args, 1, &na);
	nsvg__xformSetSkewY(t, args[0]/180.0f*NSVG_PI);
	memcpy(xform, t, sizeof(float)*6);
	return len;
}

static int nsvg__parseRotate(float* xform, const char* str)
{
	float args[3];
	int na = 0;
	float m[6];
	float t[6];
	int len = nsvg__parseTransformArgs(str, args, 3, &na);
	if (na == 1)
		args[1] = args[2] = 0.0f;
	nsvg__xformIdentity(m);

	if (na > 1) {
		nsvg__xformSetTranslation(t, -args[1], -args[2]);
		nsvg__xformMultiply(m, t);
	}

	nsvg__xformSetRotation(t, args[0]/180.0f*NSVG_PI);
	nsvg__xformMultiply(m, t);

	if (na > 1) {
		nsvg__xformSetTranslation(t, args[1], args[2]);
		nsvg__xformMultiply(m, t);
	}

	memcpy(xform, m, sizeof(float)*6);

	return len;
}

static void nsvg__parseTransform(float* xform, const char* str)
{
	float t[6];
	int len;
	nsvg__xformIdentity(xform);
	while (*str)
	{
		if (strncmp(str, "matrix", 6) == 0)
			len = nsvg__parseMatrix(t, str);
		else if (strncmp(str, "translate", 9) == 0)
			len = nsvg__parseTranslate(t, str);
		else if (strncmp(str, "scale", 5) == 0)
			len = nsvg__parseScale(t, str);
		else if (strncmp(str, "rotate", 6) == 0)
			len = nsvg__parseRotate(t, str);
		else if (strncmp(str, "skewX", 5) == 0)
			len = nsvg__parseSkewX(t, str);
		else if (strncmp(str, "skewY", 5) == 0)
			len = nsvg__parseSkewY(t, str);
		else{
			++str;
			continue;
		}
		if (len != 0) {
			str += len;
		} else {
			++str;
			continue;
		}

		nsvg__xformPremultiply(xform, t);
	}
}

static void nsvg__parseUrl(char* id, const char* str)
{
	int i = 0;
	str += 4; // "url(";
	if (*str == '#')
		str++;
	while (i < 63 && *str != ')') {
		id[i] = *str++;
		i++;
	}
	id[i] = '\0';
}

static char nsvg__parseLineCap(const char* str)
{
	if (strcmp(str, "butt") == 0)
		return NSVG_CAP_BUTT;
	else if (strcmp(str, "round") == 0)
		return NSVG_CAP_ROUND;
	else if (strcmp(str, "square") == 0)
		return NSVG_CAP_SQUARE;
	// TODO: handle inherit.
	return NSVG_CAP_BUTT;
}

static char nsvg__parseLineJoin(const char* str)
{
	if (strcmp(str, "miter") == 0)
		return NSVG_JOIN_MITER;
	else if (strcmp(str, "round") == 0)
		return NSVG_JOIN_ROUND;
	else if (strcmp(str, "bevel") == 0)
		return NSVG_JOIN_BEVEL;
	// TODO: handle inherit.
	return NSVG_JOIN_MITER;
}

static char nsvg__parseFillRule(const char* str)
{
	if (strcmp(str, "nonzero") == 0)
		return NSVG_FILLRULE_NONZERO;
	else if (strcmp(str, "evenodd") == 0)
		return NSVG_FILLRULE_EVENODD;
	// TODO: handle inherit.
	return NSVG_FILLRULE_NONZERO;
}

static const char* nsvg__getNextDashItem(const char* s, char* it)
{
	int n = 0;
	it[0] = '\0';
	// Skip white spaces and commas
	while (*s && (nsvg__isspace(*s) || *s == ',')) s++;
	// Advance until whitespace, comma or end.
	while (*s && (!nsvg__isspace(*s) && *s != ',')) {
		if (n < 63)
			it[n++] = *s;
		s++;
	}
	it[n++] = '\0';
	return s;
}

static int nsvg__parseStrokeDashArray(NSVGparser* p, const char* str, float* strokeDashArray)
{
	char item[64];
	int count = 0, i;
	float sum = 0.0f;

	// Handle "none"
	if (str[0] == 'n')
		return 0;

	// Parse dashes
	while (*str) {
		str = nsvg__getNextDashItem(str, item);
		if (!*item) break;
		if (count < NSVG_MAX_DASHES)
			strokeDashArray[count++] = fabsf(nsvg__parseCoordinate(p, item, 0.0f, nsvg__actualLength(p)));
	}

	for (i = 0; i < count; i++)
		sum += strokeDashArray[i];
	if (sum <= 1e-6f)
		count = 0;

	return count;
}

static void nsvg__parseStyle(NSVGparser* p, const char* str);

static int nsvg__parseAttr(NSVGparser* p, const char* name, const char* value)
{
	float xform[6];
	NSVGattrib* attr = nsvg__getAttr(p);
	if (!attr) return 0;

	if (strcmp(name, "style") == 0) {
		nsvg__parseStyle(p, value);
	} else if (strcmp(name, "display") == 0) {
		if (strcmp(value, "none") == 0)
			attr->visible = 0;
		// Don't reset ->visible on display:inline, one display:none hides the whole subtree

	} else if (strcmp(name, "fill") == 0) {
		if (strcmp(value, "none") == 0) {
			attr->hasFill = 0;
		} else if (strncmp(value, "url(", 4) == 0) {
			attr->hasFill = 2;
			nsvg__parseUrl(attr->fillGradient, value);
		} else {
			attr->hasFill = 1;
			attr->fillColor = nsvg__parseColor(value);
		}
	} else if (strcmp(name, "opacity") == 0) {
		attr->opacity = nsvg__parseOpacity(value);
	} else if (strcmp(name, "fill-opacity") == 0) {
		attr->fillOpacity = nsvg__parseOpacity(value);
	} else if (strcmp(name, "stroke") == 0) {
		if (strcmp(value, "none") == 0) {
			attr->hasStroke = 0;
		} else if (strncmp(value, "url(", 4) == 0) {
			attr->hasStroke = 2;
			nsvg__parseUrl(attr->strokeGradient, value);
		} else {
			attr->hasStroke = 1;
			attr->strokeColor = nsvg__parseColor(value);
		}
	} else if (strcmp(name, "stroke-width") == 0) {
		attr->strokeWidth = nsvg__parseCoordinate(p, value, 0.0f, nsvg__actualLength(p));
	} else if (strcmp(name, "stroke-dasharray") == 0) {
		attr->strokeDashCount = nsvg__parseStrokeDashArray(p, value, attr->strokeDashArray);
	} else if (strcmp(name, "stroke-dashoffset") == 0) {
		attr->strokeDashOffset = nsvg__parseCoordinate(p, value, 0.0f, nsvg__actualLength(p));
	} else if (strcmp(name, "stroke-opacity") == 0) {
		attr->strokeOpacity = nsvg__parseOpacity(value);
	} else if (strcmp(name, "stroke-linecap") == 0) {
		attr->strokeLineCap = nsvg__parseLineCap(value);
	} else if (strcmp(name, "stroke-linejoin") == 0) {
		attr->strokeLineJoin = nsvg__parseLineJoin(value);
	} else if (strcmp(name, "stroke-miterlimit") == 0) {
		attr->miterLimit = nsvg__parseMiterLimit(value);
	} else if (strcmp(name, "fill-rule") == 0) {
		attr->fillRule = nsvg__parseFillRule(value);
	} else if (strcmp(name, "font-size") == 0) {
		attr->fontSize = nsvg__parseCoordinate(p, value, 0.0f, nsvg__actualLength(p));
	} else if (strcmp(name, "transform") == 0) {
		nsvg__parseTransform(xform, value);
		nsvg__xformPremultiply(attr->xform, xform);
	} else if (strcmp(name, "stop-color") == 0) {
		attr->stopColor = nsvg__parseColor(value);
	} else if (strcmp(name, "stop-opacity") == 0) {
		attr->stopOpacity = nsvg__parseOpacity(value);
	} else if (strcmp(name, "offset") == 0) {
		attr->stopOffset = nsvg__parseCoordinate(p, value, 0.0f, 1.0f);
	} else if (strcmp(name, "id") == 0) {
		strncpy(attr->id, value, 63);
		attr->id[63] = '\0';
	} else {
		return 0;
	}
	return 1;
}

static int nsvg__parseNameValue(NSVGparser* p, const char* start, const char* end)
{
	const char* str;
	const char* val;
	char name[512];
	char value[512];
	int n;

	str = start;
	while (str < end && *str != ':') ++str;

	val = str;

	// Right Trim
	while (str > start &&  (*str == ':' || nsvg__isspace(*str))) --str;
	++str;

	n = (int)(str - start);
	if (n > 511) n = 511;
	if (n) memcpy(name, start, n);
	name[n] = 0;

	while (val < end && (*val == ':' || nsvg__isspace(*val))) ++val;

	n = (int)(end - val);
	if (n > 511) n = 511;
	if (n) memcpy(value, val, n);
	value[n] = 0;

	return nsvg__parseAttr(p, name, value);
}

static void nsvg__parseStyle(NSVGparser* p, const char* str)
{
	const char* start;
	const char* end;

	while (*str) {
		// Left Trim
		while(*str && nsvg__isspace(*str)) ++str;
		start = str;
		while(*str && *str != ';') ++str;
		end = str;

		// Right Trim
		while (end > start &&  (*end == ';' || nsvg__isspace(*end))) --end;
		++end;

		nsvg__parseNameValue(p, start, end);
		if (*str) ++str;
	}
}

static void nsvg__parseAttribs(NSVGparser* p, const char** attr)
{
	int i;
	for (i = 0; attr[i]; i += 2)
	{
		if (strcmp(attr[i], "style") == 0)
			nsvg__parseStyle(p, attr[i + 1]);
		else
			nsvg__parseAttr(p, attr[i], attr[i + 1]);
	}
}

static int nsvg__getArgsPerElement(char cmd)
{
	switch (cmd) {
		case 'v':
		case 'V':
		case 'h':
		case 'H':
			return 1;
		case 'm':
		case 'M':
		case 'l':
		case 'L':
		case 't':
		case 'T':
			return 2;
		case 'q':
		case 'Q':
		case 's':
		case 'S':
			return 4;
		case 'c':
		case 'C':
			return 6;
		case 'a':
		case 'A':
			return 7;
		case 'z':
		case 'Z':
			return 0;
	}
	return -1;
}

static void nsvg__pathMoveTo(NSVGparser* p, float* cpx, float* cpy, float* args, int rel)
{
	if (rel) {
		*cpx += args[0];
		*cpy += args[1];
	} else {
		*cpx = args[0];
		*cpy = args[1];
	}
	nsvg__moveTo(p, *cpx, *cpy);
}

static void nsvg__pathLineTo(NSVGparser* p, float* cpx, float* cpy, float* args, int rel)
{
	if (rel) {
		*cpx += args[0];
		*cpy += args[1];
	} else {
		*cpx = args[0];
		*cpy = args[1];
	}
	nsvg__lineTo(p, *cpx, *cpy);
}

static void nsvg__pathHLineTo(NSVGparser* p, float* cpx, float* cpy, float* args, int rel)
{
	if (rel)
		*cpx += args[0];
	else
		*cpx = args[0];
	nsvg__lineTo(p, *cpx, *cpy);
}

static void nsvg__pathVLineTo(NSVGparser* p, float* cpx, float* cpy, float* args, int rel)
{
	if (rel)
		*cpy += args[0];
	else
		*cpy = args[0];
	nsvg__lineTo(p, *cpx, *cpy);
}

static void nsvg__pathCubicBezTo(NSVGparser* p, float* cpx, float* cpy,
								 float* cpx2, float* cpy2, float* args, int rel)
{
	float x2, y2, cx1, cy1, cx2, cy2;

	if (rel) {
		cx1 = *cpx + args[0];
		cy1 = *cpy + args[1];
		cx2 = *cpx + args[2];
		cy2 = *cpy + args[3];
		x2 = *cpx + args[4];
		y2 = *cpy + args[5];
	} else {
		cx1 = args[0];
		cy1 = args[1];
		cx2 = args[2];
		cy2 = args[3];
		x2 = args[4];
		y2 = args[5];
	}

	nsvg__cubicBezTo(p, cx1,cy1, cx2,cy2, x2,y2);

	*cpx2 = cx2;
	*cpy2 = cy2;
	*cpx = x2;
	*cpy = y2;
}

static void nsvg__pathCubicBezShortTo(NSVGparser* p, float* cpx, float* cpy,
									  float* cpx2, float* cpy2, float* args, int rel)
{
	float x1, y1, x2, y2, cx1, cy1, cx2, cy2;

	x1 = *cpx;
	y1 = *cpy;
	if (rel) {
		cx2 = *cpx + args[0];
		cy2 = *cpy + args[1];
		x2 = *cpx + args[2];
		y2 = *cpy + args[3];
	} else {
		cx2 = args[0];
		cy2 = args[1];
		x2 = args[2];
		y2 = args[3];
	}

	cx1 = 2*x1 - *cpx2;
	cy1 = 2*y1 - *cpy2;

	nsvg__cubicBezTo(p, cx1,cy1, cx2,cy2, x2,y2);

	*cpx2 = cx2;
	*cpy2 = cy2;
	*cpx = x2;
	*cpy = y2;
}

static void nsvg__pathQuadBezTo(NSVGparser* p, float* cpx, float* cpy,
								float* cpx2, float* cpy2, float* args, int rel)
{
	float x1, y1, x2, y2, cx, cy;
	float cx1, cy1, cx2, cy2;

	x1 = *cpx;
	y1 = *cpy;
	if (rel) {
		cx = *cpx + args[0];
		cy = *cpy + args[1];
		x2 = *cpx + args[2];
		y2 = *cpy + args[3];
	} else {
		cx = args[0];
		cy = args[1];
		x2 = args[2];
		y2 = args[3];
	}

	// Convert to cubic bezier
	cx1 = x1 + 2.0f/3.0f*(cx - x1);
	cy1 = y1 + 2.0f/3.0f*(cy - y1);
	cx2 = x2 + 2.0f/3.0f*(cx - x2);
	cy2 = y2 + 2.0f/3.0f*(cy - y2);

	nsvg__cubicBezTo(p, cx1,cy1, cx2,cy2, x2,y2);

	*cpx2 = cx;
	*cpy2 = cy;
	*cpx = x2;
	*cpy = y2;
}

static void nsvg__pathQuadBezShortTo(NSVGparser* p, float* cpx, float* cpy,
									 float* cpx2, float* cpy2, float* args, int rel)
{
	float x1, y1, x2, y2, cx, cy;
	float cx1, cy1, cx2, cy2;

	x1 = *cpx;
	y1 = *cpy;
	if (rel) {
		x2 = *cpx + args[0];
		y2 = *cpy + args[1];
	} else {
		x2 = args[0];
		y2 = args[1];
	}

	cx = 2*x1 - *cpx2;
	cy = 2*y1 - *cpy2;

	// Convert to cubix bezier
	cx1 = x1 + 2.0f/3.0f*(cx - x1);
	cy1 = y1 + 2.0f/3.0f*(cy - y1);
	cx2 = x2 + 2.0f/3.0f*(cx - x2);
	cy2 = y2 + 2.0f/3.0f*(cy - y2);

	nsvg__cubicBezTo(p, cx1,cy1, cx2,cy2, x2,y2);

	*cpx2 = cx;
	*cpy2 = cy;
	*cpx = x2;
	*cpy = y2;
}

static float nsvg__sqr(float x) { return x*x; }
static float nsvg__vmag(float x, float y) { return sqrtf(x*x + y*y); }

static float nsvg__vecrat(float ux, float uy, float vx, float vy)
{
	return (ux*vx + uy*vy) / (nsvg__vmag(ux,uy) * nsvg__vmag(vx,vy));
}

static float nsvg__vecang(float ux, float uy, float vx, float vy)
{
	float r = nsvg__vecrat(ux,uy, vx,vy);
	if (r < -1.0f) r = -1.0f;
	if (r > 1.0f) r = 1.0f;
	return ((ux*vy < uy*vx) ? -1.0f : 1.0f) * acosf(r);
}

static void nsvg__pathArcTo(NSVGparser* p, float* cpx, float* cpy, float* args, int rel)
{
	// Ported from canvg (https://code.google.com/p/canvg/)
	float rx, ry, rotx;
	float x1, y1, x2, y2, cx, cy, dx, dy, d;
	float x1p, y1p, cxp, cyp, s, sa, sb;
	float ux, uy, vx, vy, a1, da;
	float x, y, tanx, tany, a, px = 0, py = 0, ptanx = 0, ptany = 0, t[6];
	float sinrx, cosrx;
	int fa, fs;
	int i, ndivs;
	float hda, kappa;

	rx = fabsf(args[0]);				// y radius
	ry = fabsf(args[1]);				// x radius
	rotx = args[2] / 180.0f * NSVG_PI;		// x rotation angle
	fa = fabsf(args[3]) > 1e-6 ? 1 : 0;	// Large arc
	fs = fabsf(args[4]) > 1e-6 ? 1 : 0;	// Sweep direction
	x1 = *cpx;							// start point
	y1 = *cpy;
	if (rel) {							// end point
		x2 = *cpx + args[5];
		y2 = *cpy + args[6];
	} else {
		x2 = args[5];
		y2 = args[6];
	}

	dx = x1 - x2;
	dy = y1 - y2;
	d = sqrtf(dx*dx + dy*dy);
	if (d < 1e-6f || rx < 1e-6f || ry < 1e-6f) {
		// The arc degenerates to a line
		nsvg__lineTo(p, x2, y2);
		*cpx = x2;
		*cpy = y2;
		return;
	}

	sinrx = sinf(rotx);
	cosrx = cosf(rotx);

	// Convert to center point parameterization.
	// http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
	// 1) Compute x1', y1'
	x1p = cosrx * dx / 2.0f + sinrx * dy / 2.0f;
	y1p = -sinrx * dx / 2.0f + cosrx * dy / 2.0f;
	d = nsvg__sqr(x1p)/nsvg__sqr(rx) + nsvg__sqr(y1p)/nsvg__sqr(ry);
	if (d > 1) {
		d = sqrtf(d);
		rx *= d;
		ry *= d;
	}
	// 2) Compute cx', cy'
	s = 0.0f;
	sa = nsvg__sqr(rx)*nsvg__sqr(ry) - nsvg__sqr(rx)*nsvg__sqr(y1p) - nsvg__sqr(ry)*nsvg__sqr(x1p);
	sb = nsvg__sqr(rx)*nsvg__sqr(y1p) + nsvg__sqr(ry)*nsvg__sqr(x1p);
	if (sa < 0.0f) sa = 0.0f;
	if (sb > 0.0f)
		s = sqrtf(sa / sb);
	if (fa == fs)
		s = -s;
	cxp = s * rx * y1p / ry;
	cyp = s * -ry * x1p / rx;

	// 3) Compute cx,cy from cx',cy'
	cx = (x1 + x2)/2.0f + cosrx*cxp - sinrx*cyp;
	cy = (y1 + y2)/2.0f + sinrx*cxp + cosrx*cyp;

	// 4) Calculate theta1, and delta theta.
	ux = (x1p - cxp) / rx;
	uy = (y1p - cyp) / ry;
	vx = (-x1p - cxp) / rx;
	vy = (-y1p - cyp) / ry;
	a1 = nsvg__vecang(1.0f,0.0f, ux,uy);	// Initial angle
	da = nsvg__vecang(ux,uy, vx,vy);		// Delta angle

//	if (vecrat(ux,uy,vx,vy) <= -1.0f) da = NSVG_PI;
//	if (vecrat(ux,uy,vx,vy) >= 1.0f) da = 0;

	if (fs == 0 && da > 0)
		da -= 2 * NSVG_PI;
	else if (fs == 1 && da < 0)
		da += 2 * NSVG_PI;

	// Approximate the arc using cubic spline segments.
	t[0] = cosrx; t[1] = sinrx;
	t[2] = -sinrx; t[3] = cosrx;
	t[4] = cx; t[5] = cy;

	// Split arc into max 90 degree segments.
	// The loop assumes an iteration per end point (including start and end), this +1.
	ndivs = (int)(fabsf(da) / (NSVG_PI*0.5f) + 1.0f);
	hda = (da / (float)ndivs) / 2.0f;
	// Fix for ticket #179: division by 0: avoid cotangens around 0 (infinite)
	if ((hda < 1e-3f) && (hda > -1e-3f))
		hda *= 0.5f;
	else
		hda = (1.0f - cosf(hda)) / sinf(hda);
	kappa = fabsf(4.0f / 3.0f * hda);
	if (da < 0.0f)
		kappa = -kappa;

	for (i = 0; i <= ndivs; i++) {
		a = a1 + da * ((float)i/(float)ndivs);
		dx = cosf(a);
		dy = sinf(a);
		nsvg__xformPoint(&x, &y, dx*rx, dy*ry, t); // position
		nsvg__xformVec(&tanx, &tany, -dy*rx * kappa, dx*ry * kappa, t); // tangent
		if (i > 0)
			nsvg__cubicBezTo(p, px+ptanx,py+ptany, x-tanx, y-tany, x, y);
		px = x;
		py = y;
		ptanx = tanx;
		ptany = tany;
	}

	*cpx = x2;
	*cpy = y2;
}

static void nsvg__parsePath(NSVGparser* p, const char** attr)
{
	const char* s = NULL;
	char cmd = '\0';
	float args[10];
	int nargs;
	int rargs = 0;
	char initPoint;
	float cpx, cpy, cpx2, cpy2;
	const char* tmp[4];
	char closedFlag;
	int i;
	char item[64];

	for (i = 0; attr[i]; i += 2) {
		if (strcmp(attr[i], "d") == 0) {
			s = attr[i + 1];
		} else {
			tmp[0] = attr[i];
			tmp[1] = attr[i + 1];
			tmp[2] = 0;
			tmp[3] = 0;
			nsvg__parseAttribs(p, tmp);
		}
	}

	if (s) {
		nsvg__resetPath(p);
		cpx = 0; cpy = 0;
		cpx2 = 0; cpy2 = 0;
		initPoint = 0;
		closedFlag = 0;
		nargs = 0;

		while (*s) {
			s = nsvg__getNextPathItem(s, item);
			if (!*item) break;
			if (cmd != '\0' && nsvg__isCoordinate(item)) {
				if (nargs < 10)
					args[nargs++] = (float)nsvg__atof(item);
				if (nargs >= rargs) {
					switch (cmd) {
						case 'm':
						case 'M':
							nsvg__pathMoveTo(p, &cpx, &cpy, args, cmd == 'm' ? 1 : 0);
							// Moveto can be followed by multiple coordinate pairs,
							// which should be treated as linetos.
							cmd = (cmd == 'm') ? 'l' : 'L';
							rargs = nsvg__getArgsPerElement(cmd);
							cpx2 = cpx; cpy2 = cpy;
							initPoint = 1;
							break;
						case 'l':
						case 'L':
							nsvg__pathLineTo(p, &cpx, &cpy, args, cmd == 'l' ? 1 : 0);
							cpx2 = cpx; cpy2 = cpy;
							break;
						case 'H':
						case 'h':
							nsvg__pathHLineTo(p, &cpx, &cpy, args, cmd == 'h' ? 1 : 0);
							cpx2 = cpx; cpy2 = cpy;
							break;
						case 'V':
						case 'v':
							nsvg__pathVLineTo(p, &cpx, &cpy, args, cmd == 'v' ? 1 : 0);
							cpx2 = cpx; cpy2 = cpy;
							break;
						case 'C':
						case 'c':
							nsvg__pathCubicBezTo(p, &cpx, &cpy, &cpx2, &cpy2, args, cmd == 'c' ? 1 : 0);
							break;
						case 'S':
						case 's':
							nsvg__pathCubicBezShortTo(p, &cpx, &cpy, &cpx2, &cpy2, args, cmd == 's' ? 1 : 0);
							break;
						case 'Q':
						case 'q':
							nsvg__pathQuadBezTo(p, &cpx, &cpy, &cpx2, &cpy2, args, cmd == 'q' ? 1 : 0);
							break;
						case 'T':
						case 't':
							nsvg__pathQuadBezShortTo(p, &cpx, &cpy, &cpx2, &cpy2, args, cmd == 't' ? 1 : 0);
							break;
						case 'A':
						case 'a':
							nsvg__pathArcTo(p, &cpx, &cpy, args, cmd == 'a' ? 1 : 0);
							cpx2 = cpx; cpy2 = cpy;
							break;
						default:
							if (nargs >= 2) {
								cpx = args[nargs-2];
								cpy = args[nargs-1];
								cpx2 = cpx; cpy2 = cpy;
							}
							break;
					}
					nargs = 0;
				}
			} else {
				cmd = item[0];
				if (cmd == 'M' || cmd == 'm') {
					// Commit path.
					if (p->npts > 0)
						nsvg__addPath(p, closedFlag);
					// Start new subpath.
					nsvg__resetPath(p);
					closedFlag = 0;
					nargs = 0;
				} else if (initPoint == 0) {
					// Do not allow other commands until initial point has been set (moveTo called once).
					cmd = '\0';
				}
				if (cmd == 'Z' || cmd == 'z') {
					closedFlag = 1;
					// Commit path.
					if (p->npts > 0) {
						// Move current point to first point
						cpx = p->pts[0];
						cpy = p->pts[1];
						cpx2 = cpx; cpy2 = cpy;
						nsvg__addPath(p, closedFlag);
					}
					// Start new subpath.
					nsvg__resetPath(p);
					nsvg__moveTo(p, cpx, cpy);
					closedFlag = 0;
					nargs = 0;
				}
				rargs = nsvg__getArgsPerElement(cmd);
				if (rargs == -1) {
					// Command not recognized
					cmd = '\0';
					rargs = 0;
				}
			}
		}
		// Commit path.
		if (p->npts)
			nsvg__addPath(p, closedFlag);
	}

	nsvg__addShape(p);
}

static void nsvg__parseRect(NSVGparser* p, const char** attr)
{
	float x = 0.0f;
	float y = 0.0f;
	float w = 0.0f;
	float h = 0.0f;
	float rx = -1.0f; // marks not set
	float ry = -1.0f;
	int i;

	for (i = 0; attr[i]; i += 2) {
		if (!nsvg__parseAttr(p, attr[i], attr[i + 1])) {
			if (strcmp(attr[i], "x") == 0) x = nsvg__parseCoordinate(p, attr[i+1], nsvg__actualOrigX(p), nsvg__actualWidth(p));
			if (strcmp(attr[i], "y") == 0) y = nsvg__parseCoordinate(p, attr[i+1], nsvg__actualOrigY(p), nsvg__actualHeight(p));
			if (strcmp(attr[i], "width") == 0) w = nsvg__parseCoordinate(p, attr[i+1], 0.0f, nsvg__actualWidth(p));
			if (strcmp(attr[i], "height") == 0) h = nsvg__parseCoordinate(p, attr[i+1], 0.0f, nsvg__actualHeight(p));
			if (strcmp(attr[i], "rx") == 0) rx = fabsf(nsvg__parseCoordinate(p, attr[i+1], 0.0f, nsvg__actualWidth(p)));
			if (strcmp(attr[i], "ry") == 0) ry = fabsf(nsvg__parseCoordinate(p, attr[i+1], 0.0f, nsvg__actualHeight(p)));
		}
	}

	if (rx < 0.0f && ry > 0.0f) rx = ry;
	if (ry < 0.0f && rx > 0.0f) ry = rx;
	if (rx < 0.0f) rx = 0.0f;
	if (ry < 0.0f) ry = 0.0f;
	if (rx > w/2.0f) rx = w/2.0f;
	if (ry > h/2.0f) ry = h/2.0f;

	if (w != 0.0f && h != 0.0f) {
		nsvg__resetPath(p);

		if (rx < 0.00001f || ry < 0.0001f) {
			nsvg__moveTo(p, x, y);
			nsvg__lineTo(p, x+w, y);
			nsvg__lineTo(p, x+w, y+h);
			nsvg__lineTo(p, x, y+h);
		} else {
			// Rounded rectangle
			nsvg__moveTo(p, x+rx, y);
			nsvg__lineTo(p, x+w-rx, y);
			nsvg__cubicBezTo(p, x+w-rx*(1-NSVG_KAPPA90), y, x+w, y+ry*(1-NSVG_KAPPA90), x+w, y+ry);
			nsvg__lineTo(p, x+w, y+h-ry);
			nsvg__cubicBezTo(p, x+w, y+h-ry*(1-NSVG_KAPPA90), x+w-rx*(1-NSVG_KAPPA90), y+h, x+w-rx, y+h);
			nsvg__lineTo(p, x+rx, y+h);
			nsvg__cubicBezTo(p, x+rx*(1-NSVG_KAPPA90), y+h, x, y+h-ry*(1-NSVG_KAPPA90), x, y+h-ry);
			nsvg__lineTo(p, x, y+ry);
			nsvg__cubicBezTo(p, x, y+ry*(1-NSVG_KAPPA90), x+rx*(1-NSVG_KAPPA90), y, x+rx, y);
		}

		nsvg__addPath(p, 1);

		nsvg__addShape(p);
	}
}

static void nsvg__parseCircle(NSVGparser* p, const char** attr)
{
	float cx = 0.0f;
	float cy = 0.0f;
	float r = 0.0f;
	int i;

	for (i = 0; attr[i]; i += 2) {
		if (!nsvg__parseAttr(p, attr[i], attr[i + 1])) {
			if (strcmp(attr[i], "cx") == 0) cx = nsvg__parseCoordinate(p, attr[i+1], nsvg__actualOrigX(p), nsvg__actualWidth(p));
			if (strcmp(attr[i], "cy") == 0) cy = nsvg__parseCoordinate(p, attr[i+1], nsvg__actualOrigY(p), nsvg__actualHeight(p));
			if (strcmp(attr[i], "r") == 0) r = fabsf(nsvg__parseCoordinate(p, attr[i+1], 0.0f, nsvg__actualLength(p)));
		}
	}

	if (r > 0.0f) {
		nsvg__resetPath(p);

		nsvg__moveTo(p, cx+r, cy);
		nsvg__cubicBezTo(p, cx+r, cy+r*NSVG_KAPPA90, cx+r*NSVG_KAPPA90, cy+r, cx, cy+r);
		nsvg__cubicBezTo(p, cx-r*NSVG_KAPPA90, cy+r, cx-r, cy+r*NSVG_KAPPA90, cx-r, cy);
		nsvg__cubicBezTo(p, cx-r, cy-r*NSVG_KAPPA90, cx-r*NSVG_KAPPA90, cy-r, cx, cy-r);
		nsvg__cubicBezTo(p, cx+r*NSVG_KAPPA90, cy-r, cx+r, cy-r*NSVG_KAPPA90, cx+r, cy);

		nsvg__addPath(p, 1);

		nsvg__addShape(p);
	}
}

static void nsvg__parseEllipse(NSVGparser* p, const char** attr)
{
	float cx = 0.0f;
	float cy = 0.0f;
	float rx = 0.0f;
	float ry = 0.0f;
	int i;

	for (i = 0; attr[i]; i += 2) {
		if (!nsvg__parseAttr(p, attr[i], attr[i + 1])) {
			if (strcmp(attr[i], "cx") == 0) cx = nsvg__parseCoordinate(p, attr[i+1], nsvg__actualOrigX(p), nsvg__actualWidth(p));
			if (strcmp(attr[i], "cy") == 0) cy = nsvg__parseCoordinate(p, attr[i+1], nsvg__actualOrigY(p), nsvg__actualHeight(p));
			if (strcmp(attr[i], "rx") == 0) rx = fabsf(nsvg__parseCoordinate(p, attr[i+1], 0.0f, nsvg__actualWidth(p)));
			if (strcmp(attr[i], "ry") == 0) ry = fabsf(nsvg__parseCoordinate(p, attr[i+1], 0.0f, nsvg__actualHeight(p)));
		}
	}

	if (rx > 0.0f && ry > 0.0f) {

		nsvg__resetPath(p);

		nsvg__moveTo(p, cx+rx, cy);
		nsvg__cubicBezTo(p, cx+rx, cy+ry*NSVG_KAPPA90, cx+rx*NSVG_KAPPA90, cy+ry, cx, cy+ry);
		nsvg__cubicBezTo(p, cx-rx*NSVG_KAPPA90, cy+ry, cx-rx, cy+ry*NSVG_KAPPA90, cx-rx, cy);
		nsvg__cubicBezTo(p, cx-rx, cy-ry*NSVG_KAPPA90, cx-rx*NSVG_KAPPA90, cy-ry, cx, cy-ry);
		nsvg__cubicBezTo(p, cx+rx*NSVG_KAPPA90, cy-ry, cx+rx, cy-ry*NSVG_KAPPA90, cx+rx, cy);

		nsvg__addPath(p, 1);

		nsvg__addShape(p);
	}
}

static void nsvg__parseLine(NSVGparser* p, const char** attr)
{
	float x1 = 0.0;
	float y1 = 0.0;
	float x2 = 0.0;
	float y2 = 0.0;
	int i;

	for (i = 0; attr[i]; i += 2) {
		if (!nsvg__parseAttr(p, attr[i], attr[i + 1])) {
			if (strcmp(attr[i], "x1") == 0) x1 = nsvg__parseCoordinate(p, attr[i + 1], nsvg__actualOrigX(p), nsvg__actualWidth(p));
			if (strcmp(attr[i], "y1") == 0) y1 = nsvg__parseCoordinate(p, attr[i + 1], nsvg__actualOrigY(p), nsvg__actualHeight(p));
			if (strcmp(attr[i], "x2") == 0) x2 = nsvg__parseCoordinate(p, attr[i + 1], nsvg__actualOrigX(p), nsvg__actualWidth(p));
			if (strcmp(attr[i], "y2") == 0) y2 = nsvg__parseCoordinate(p, attr[i + 1], nsvg__actualOrigY(p), nsvg__actualHeight(p));
		}
	}

	nsvg__resetPath(p);

	nsvg__moveTo(p, x1, y1);
	nsvg__lineTo(p, x2, y2);

	nsvg__addPath(p, 0);

	nsvg__addShape(p);
}

static void nsvg__parsePoly(NSVGparser* p, const char** attr, int closeFlag)
{
	int i;
	const char* s;
	float args[2];
	int nargs, npts = 0;
	char item[64];

	nsvg__resetPath(p);

	for (i = 0; attr[i]; i += 2) {
		if (!nsvg__parseAttr(p, attr[i], attr[i + 1])) {
			if (strcmp(attr[i], "points") == 0) {
				s = attr[i + 1];
				nargs = 0;
				while (*s) {
					s = nsvg__getNextPathItem(s, item);
					args[nargs++] = (float)nsvg__atof(item);
					if (nargs >= 2) {
						if (npts == 0)
							nsvg__moveTo(p, args[0], args[1]);
						else
							nsvg__lineTo(p, args[0], args[1]);
						nargs = 0;
						npts++;
					}
				}
			}
		}
	}

	nsvg__addPath(p, (char)closeFlag);

	nsvg__addShape(p);
}

static void nsvg__parseSVG(NSVGparser* p, const char** attr)
{
	int i;
	for (i = 0; attr[i]; i += 2) {
		if (!nsvg__parseAttr(p, attr[i], attr[i + 1])) {
			if (strcmp(attr[i], "width") == 0) {
				p->image->width = nsvg__parseCoordinate(p, attr[i + 1], 0.0f, 0.0f);
			} else if (strcmp(attr[i], "height") == 0) {
				p->image->height = nsvg__parseCoordinate(p, attr[i + 1], 0.0f, 0.0f);
			} else if (strcmp(attr[i], "viewBox") == 0) {
				const char *s = attr[i + 1];
				char buf[64];
				s = nsvg__parseNumber(s, buf, 64);
				p->viewMinx = (float)nsvg__atof(buf);
				while (*s && (nsvg__isspace(*s) || *s == '%' || *s == ',')) s++;
				if (!*s) return;
				s = nsvg__parseNumber(s, buf, 64);
				p->viewMiny = (float)nsvg__atof(buf);
				while (*s && (nsvg__isspace(*s) || *s == '%' || *s == ',')) s++;
				if (!*s) return;
				s = nsvg__parseNumber(s, buf, 64);
				p->viewWidth = (float)nsvg__atof(buf);
				while (*s && (nsvg__isspace(*s) || *s == '%' || *s == ',')) s++;
				if (!*s) return;
				s = nsvg__parseNumber(s, buf, 64);
				p->viewHeight = (float)nsvg__atof(buf);
			} else if (strcmp(attr[i], "preserveAspectRatio") == 0) {
				if (strstr(attr[i + 1], "none") != 0) {
					// No uniform scaling
					p->alignType = NSVG_ALIGN_NONE;
				} else {
					// Parse X align
					if (strstr(attr[i + 1], "xMin") != 0)
						p->alignX = NSVG_ALIGN_MIN;
					else if (strstr(attr[i + 1], "xMid") != 0)
						p->alignX = NSVG_ALIGN_MID;
					else if (strstr(attr[i + 1], "xMax") != 0)
						p->alignX = NSVG_ALIGN_MAX;
					// Parse X align
					if (strstr(attr[i + 1], "yMin") != 0)
						p->alignY = NSVG_ALIGN_MIN;
					else if (strstr(attr[i + 1], "yMid") != 0)
						p->alignY = NSVG_ALIGN_MID;
					else if (strstr(attr[i + 1], "yMax") != 0)
						p->alignY = NSVG_ALIGN_MAX;
					// Parse meet/slice
					p->alignType = NSVG_ALIGN_MEET;
					if (strstr(attr[i + 1], "slice") != 0)
						p->alignType = NSVG_ALIGN_SLICE;
				}
			}
		}
	}
}

static void nsvg__parseGradient(NSVGparser* p, const char** attr, char type)
{
	int i;
	NSVGgradientData* grad = (NSVGgradientData*)malloc(sizeof(NSVGgradientData));
	if (grad == NULL) return;
	memset(grad, 0, sizeof(NSVGgradientData));
	grad->units = NSVG_OBJECT_SPACE;
	grad->type = type;
	if (grad->type == NSVG_PAINT_LINEAR_GRADIENT) {
		grad->linear.x1 = nsvg__coord(0.0f, NSVG_UNITS_PERCENT);
		grad->linear.y1 = nsvg__coord(0.0f, NSVG_UNITS_PERCENT);
		grad->linear.x2 = nsvg__coord(100.0f, NSVG_UNITS_PERCENT);
		grad->linear.y2 = nsvg__coord(0.0f, NSVG_UNITS_PERCENT);
	} else if (grad->type == NSVG_PAINT_RADIAL_GRADIENT) {
		grad->radial.cx = nsvg__coord(50.0f, NSVG_UNITS_PERCENT);
		grad->radial.cy = nsvg__coord(50.0f, NSVG_UNITS_PERCENT);
		grad->radial.r = nsvg__coord(50.0f, NSVG_UNITS_PERCENT);
	}

	nsvg__xformIdentity(grad->xform);

	for (i = 0; attr[i]; i += 2) {
		if (strcmp(attr[i], "id") == 0) {
			strncpy(grad->id, attr[i+1], 63);
			grad->id[63] = '\0';
		} else if (!nsvg__parseAttr(p, attr[i], attr[i + 1])) {
			if (strcmp(attr[i], "gradientUnits") == 0) {
				if (strcmp(attr[i+1], "objectBoundingBox") == 0)
					grad->units = NSVG_OBJECT_SPACE;
				else
					grad->units = NSVG_USER_SPACE;
			} else if (strcmp(attr[i], "gradientTransform") == 0) {
				nsvg__parseTransform(grad->xform, attr[i + 1]);
			} else if (strcmp(attr[i], "cx") == 0) {
				grad->radial.cx = nsvg__parseCoordinateRaw(attr[i + 1]);
			} else if (strcmp(attr[i], "cy") == 0) {
				grad->radial.cy = nsvg__parseCoordinateRaw(attr[i + 1]);
			} else if (strcmp(attr[i], "r") == 0) {
				grad->radial.r = nsvg__parseCoordinateRaw(attr[i + 1]);
			} else if (strcmp(attr[i], "fx") == 0) {
				grad->radial.fx = nsvg__parseCoordinateRaw(attr[i + 1]);
			} else if (strcmp(attr[i], "fy") == 0) {
				grad->radial.fy = nsvg__parseCoordinateRaw(attr[i + 1]);
			} else if (strcmp(attr[i], "x1") == 0) {
				grad->linear.x1 = nsvg__parseCoordinateRaw(attr[i + 1]);
			} else if (strcmp(attr[i], "y1") == 0) {
				grad->linear.y1 = nsvg__parseCoordinateRaw(attr[i + 1]);
			} else if (strcmp(attr[i], "x2") == 0) {
				grad->linear.x2 = nsvg__parseCoordinateRaw(attr[i + 1]);
			} else if (strcmp(attr[i], "y2") == 0) {
				grad->linear.y2 = nsvg__parseCoordinateRaw(attr[i + 1]);
			} else if (strcmp(attr[i], "spreadMethod") == 0) {
				if (strcmp(attr[i+1], "pad") == 0)
					grad->spread = NSVG_SPREAD_PAD;
				else if (strcmp(attr[i+1], "reflect") == 0)
					grad->spread = NSVG_SPREAD_REFLECT;
				else if (strcmp(attr[i+1], "repeat") == 0)
					grad->spread = NSVG_SPREAD_REPEAT;
			} else if (strcmp(attr[i], "xlink:href") == 0) {
				const char *href = attr[i+1];
				strncpy(grad->ref, href+1, 62);
				grad->ref[62] = '\0';
			}
		}
	}

	grad->next = p->gradients;
	p->gradients = grad;
}

static void nsvg__parseGradientStop(NSVGparser* p, const char** attr)
{
	NSVGattrib* curAttr = nsvg__getAttr(p);
	NSVGgradientData* grad;
	NSVGgradientStop* stop;
	int i, idx;

	curAttr->stopOffset = 0;
	curAttr->stopColor = 0;
	curAttr->stopOpacity = 1.0f;

	for (i = 0; attr[i]; i += 2) {
		nsvg__parseAttr(p, attr[i], attr[i + 1]);
	}

	// Add stop to the last gradient.
	grad = p->gradients;
	if (grad == NULL) return;

	grad->nstops++;
	grad->stops = (NSVGgradientStop*)realloc(grad->stops, sizeof(NSVGgradientStop)*grad->nstops);
	if (grad->stops == NULL) return;

	// Insert
	idx = grad->nstops-1;
	for (i = 0; i < grad->nstops-1; i++) {
		if (curAttr->stopOffset < grad->stops[i].offset) {
			idx = i;
			break;
		}
	}
	if (idx != grad->nstops-1) {
		for (i = grad->nstops-1; i > idx; i--)
			grad->stops[i] = grad->stops[i-1];
	}

	stop = &grad->stops[idx];
	stop->color = curAttr->stopColor;
	stop->color |= (unsigned int)(curAttr->stopOpacity*255) << 24;
	stop->offset = curAttr->stopOffset;
}

static void nsvg__startElement(void* ud, const char* el, const char** attr)
{
	NSVGparser* p = (NSVGparser*)ud;

	if (p->defsFlag) {
		// Skip everything but gradients in defs
		if (strcmp(el, "linearGradient") == 0) {
			nsvg__parseGradient(p, attr, NSVG_PAINT_LINEAR_GRADIENT);
		} else if (strcmp(el, "radialGradient") == 0) {
			nsvg__parseGradient(p, attr, NSVG_PAINT_RADIAL_GRADIENT);
		} else if (strcmp(el, "stop") == 0) {
			nsvg__parseGradientStop(p, attr);
		}
		return;
	}

	if (strcmp(el, "g") == 0) {
		nsvg__pushAttr(p);
		nsvg__parseAttribs(p, attr);
	} else if (strcmp(el, "path") == 0) {
		if (p->pathFlag)	// Do not allow nested paths.
			return;
		nsvg__pushAttr(p);
		nsvg__parsePath(p, attr);
		nsvg__popAttr(p);
	} else if (strcmp(el, "rect") == 0) {
		nsvg__pushAttr(p);
		nsvg__parseRect(p, attr);
		nsvg__popAttr(p);
	} else if (strcmp(el, "circle") == 0) {
		nsvg__pushAttr(p);
		nsvg__parseCircle(p, attr);
		nsvg__popAttr(p);
	} else if (strcmp(el, "ellipse") == 0) {
		nsvg__pushAttr(p);
		nsvg__parseEllipse(p, attr);
		nsvg__popAttr(p);
	} else if (strcmp(el, "line") == 0)  {
		nsvg__pushAttr(p);
		nsvg__parseLine(p, attr);
		nsvg__popAttr(p);
	} else if (strcmp(el, "polyline") == 0)  {
		nsvg__pushAttr(p);
		nsvg__parsePoly(p, attr, 0);
		nsvg__popAttr(p);
	} else if (strcmp(el, "polygon") == 0)  {
		nsvg__pushAttr(p);
		nsvg__parsePoly(p, attr, 1);
		nsvg__popAttr(p);
	} else  if (strcmp(el, "linearGradient") == 0) {
		nsvg__parseGradient(p, attr, NSVG_PAINT_LINEAR_GRADIENT);
	} else if (strcmp(el, "radialGradient") == 0) {
		nsvg__parseGradient(p, attr, NSVG_PAINT_RADIAL_GRADIENT);
	} else if (strcmp(el, "stop") == 0) {
		nsvg__parseGradientStop(p, attr);
	} else if (strcmp(el, "defs") == 0) {
		p->defsFlag = 1;
	} else if (strcmp(el, "svg") == 0) {
		nsvg__parseSVG(p, attr);
	}
}

static void nsvg__endElement(void* ud, const char* el)
{
	NSVGparser* p = (NSVGparser*)ud;

	if (strcmp(el, "g") == 0) {
		nsvg__popAttr(p);
	} else if (strcmp(el, "path") == 0) {
		p->pathFlag = 0;
	} else if (strcmp(el, "defs") == 0) {
		p->defsFlag = 0;
	}
}

static void nsvg__content(void* ud, const char* s)
{
	NSVG_NOTUSED(ud);
	NSVG_NOTUSED(s);
	// empty
}

static void nsvg__imageBounds(NSVGparser* p, float* bounds)
{
	NSVGshape* shape;
	shape = p->image->shapes;
	if (shape == NULL) {
		bounds[0] = bounds[1] = bounds[2] = bounds[3] = 0.0;
		return;
	}
	bounds[0] = shape->bounds[0];
	bounds[1] = shape->bounds[1];
	bounds[2] = shape->bounds[2];
	bounds[3] = shape->bounds[3];
	for (shape = shape->next; shape != NULL; shape = shape->next) {
		bounds[0] = nsvg__minf(bounds[0], shape->bounds[0]);
		bounds[1] = nsvg__minf(bounds[1], shape->bounds[1]);
		bounds[2] = nsvg__maxf(bounds[2], shape->bounds[2]);
		bounds[3] = nsvg__maxf(bounds[3], shape->bounds[3]);
	}
}

static float nsvg__viewAlign(float content, float container, int type)
{
	if (type == NSVG_ALIGN_MIN)
		return 0;
	else if (type == NSVG_ALIGN_MAX)
		return container - content;
	// mid
	return (container - content) * 0.5f;
}

static void nsvg__scaleGradient(NSVGgradient* grad, float tx, float ty, float sx, float sy)
{
	float t[6];
	nsvg__xformSetTranslation(t, tx, ty);
	nsvg__xformMultiply (grad->xform, t);

	nsvg__xformSetScale(t, sx, sy);
	nsvg__xformMultiply (grad->xform, t);
}

static void nsvg__scaleToViewbox(NSVGparser* p, const char* units)
{
	NSVGshape* shape;
	NSVGpath* path;
	float tx, ty, sx, sy, us, bounds[4], t[6], avgs;
	int i;
	float* pt;

	// Guess image size if not set completely.
	nsvg__imageBounds(p, bounds);

	if (p->viewWidth == 0) {
		if (p->image->width > 0) {
			p->viewWidth = p->image->width;
		} else {
			p->viewMinx = bounds[0];
			p->viewWidth = bounds[2] - bounds[0];
		}
	}
	if (p->viewHeight == 0) {
		if (p->image->height > 0) {
			p->viewHeight = p->image->height;
		} else {
			p->viewMiny = bounds[1];
			p->viewHeight = bounds[3] - bounds[1];
		}
	}
	if (p->image->width == 0)
		p->image->width = p->viewWidth;
	if (p->image->height == 0)
		p->image->height = p->viewHeight;

	tx = -p->viewMinx;
	ty = -p->viewMiny;
	sx = p->viewWidth > 0 ? p->image->width / p->viewWidth : 0;
	sy = p->viewHeight > 0 ? p->image->height / p->viewHeight : 0;
	// Unit scaling
	us = 1.0f / nsvg__convertToPixels(p, nsvg__coord(1.0f, nsvg__parseUnits(units)), 0.0f, 1.0f);

	// Fix aspect ratio
	if (p->alignType == NSVG_ALIGN_MEET) {
		// fit whole image into viewbox
		sx = sy = nsvg__minf(sx, sy);
		tx += nsvg__viewAlign(p->viewWidth*sx, p->image->width, p->alignX) / sx;
		ty += nsvg__viewAlign(p->viewHeight*sy, p->image->height, p->alignY) / sy;
	} else if (p->alignType == NSVG_ALIGN_SLICE) {
		// fill whole viewbox with image
		sx = sy = nsvg__maxf(sx, sy);
		tx += nsvg__viewAlign(p->viewWidth*sx, p->image->width, p->alignX) / sx;
		ty += nsvg__viewAlign(p->viewHeight*sy, p->image->height, p->alignY) / sy;
	}

	// Transform
	sx *= us;
	sy *= us;
	avgs = (sx+sy) / 2.0f;
	for (shape = p->image->shapes; shape != NULL; shape = shape->next) {
		shape->bounds[0] = (shape->bounds[0] + tx) * sx;
		shape->bounds[1] = (shape->bounds[1] + ty) * sy;
		shape->bounds[2] = (shape->bounds[2] + tx) * sx;
		shape->bounds[3] = (shape->bounds[3] + ty) * sy;
		for (path = shape->paths; path != NULL; path = path->next) {
			path->bounds[0] = (path->bounds[0] + tx) * sx;
			path->bounds[1] = (path->bounds[1] + ty) * sy;
			path->bounds[2] = (path->bounds[2] + tx) * sx;
			path->bounds[3] = (path->bounds[3] + ty) * sy;
			for (i =0; i < path->npts; i++) {
				pt = &path->pts[i*2];
				pt[0] = (pt[0] + tx) * sx;
				pt[1] = (pt[1] + ty) * sy;
			}
		}

		if (shape->fill.type == NSVG_PAINT_LINEAR_GRADIENT || shape->fill.type == NSVG_PAINT_RADIAL_GRADIENT) {
			nsvg__scaleGradient(shape->fill.gradient, tx,ty, sx,sy);
			memcpy(t, shape->fill.gradient->xform, sizeof(float)*6);
			nsvg__xformInverse(shape->fill.gradient->xform, t);
		}
		if (shape->stroke.type == NSVG_PAINT_LINEAR_GRADIENT || shape->stroke.type == NSVG_PAINT_RADIAL_GRADIENT) {
			nsvg__scaleGradient(shape->stroke.gradient, tx,ty, sx,sy);
			memcpy(t, shape->stroke.gradient->xform, sizeof(float)*6);
			nsvg__xformInverse(shape->stroke.gradient->xform, t);
		}

		shape->strokeWidth *= avgs;
		shape->strokeDashOffset *= avgs;
		for (i = 0; i < shape->strokeDashCount; i++)
			shape->strokeDashArray[i] *= avgs;
	}
}

NSVGimage* nsvgParse(char* input, const char* units, float dpi)
{
	NSVGparser* p;
	NSVGimage* ret = 0;

	p = nsvg__createParser();
	if (p == NULL) {
		return NULL;
	}
	p->dpi = dpi;

	nsvg__parseXML(input, nsvg__startElement, nsvg__endElement, nsvg__content, p);

	// Scale to viewBox
	nsvg__scaleToViewbox(p, units);

	ret = p->image;
	p->image = NULL;

	nsvg__deleteParser(p);

	return ret;
}

NSVGimage* nsvgParseFromFile(const char* filename, const char* units, float dpi)
{
	FILE* fp = NULL;
	size_t size;
	char* data = NULL;
	NSVGimage* image = NULL;

	fp = fopen(filename, "rb");
	if (!fp) goto error;
	fseek(fp, 0, SEEK_END);
	size = ftell(fp);
	fseek(fp, 0, SEEK_SET);
	data = (char*)malloc(size+1);
	if (data == NULL) goto error;
	if (fread(data, 1, size, fp) != size) goto error;
	data[size] = '\0';	// Must be null terminated.
	fclose(fp);
	image = nsvgParse(data, units, dpi);
	free(data);

	return image;

error:
	if (fp) fclose(fp);
	if (data) free(data);
	if (image) nsvgDelete(image);
	return NULL;
}

NSVGpath* nsvgDuplicatePath(NSVGpath* p)
{
    NSVGpath* res = NULL;

    if (p == NULL)
        return NULL;

    res = (NSVGpath*)malloc(sizeof(NSVGpath));
    if (res == NULL) goto error;
    memset(res, 0, sizeof(NSVGpath));

    res->pts = (float*)malloc(p->npts*2*sizeof(float));
    if (res->pts == NULL) goto error;
    memcpy(res->pts, p->pts, p->npts * sizeof(float) * 2);
    res->npts = p->npts;

    memcpy(res->bounds, p->bounds, sizeof(p->bounds));

    res->closed = p->closed;

    return res;

error:
    if (res != NULL) {
        free(res->pts);
        free(res);
    }
    return NULL;
}

void nsvgDelete(NSVGimage* image)
{
	NSVGshape *snext, *shape;
	if (image == NULL) return;
	shape = image->shapes;
	while (shape != NULL) {
		snext = shape->next;
		nsvg__deletePaths(shape->paths);
		nsvg__deletePaint(&shape->fill);
		nsvg__deletePaint(&shape->stroke);
		free(shape);
		shape = snext;
	}
	free(image);
}

#endif

```

`ext/nanosvg/nanosvgrast.h`:

```h
/*
 * Copyright (c) 2013-14 Mikko Mononen memon@inside.org
 *
 * This software is provided 'as-is', without any express or implied
 * warranty.  In no event will the authors be held liable for any damages
 * arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must not
 * claim that you wrote the original software. If you use this software
 * in a product, an acknowledgment in the product documentation would be
 * appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be
 * misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 *
 * The polygon rasterization is heavily based on stb_truetype rasterizer
 * by Sean Barrett - http://nothings.org/
 *
 */

#ifndef NANOSVGRAST_H
#define NANOSVGRAST_H

#ifndef NANOSVGRAST_CPLUSPLUS
#ifdef __cplusplus
extern "C" {
#endif
#endif

typedef struct NSVGrasterizer NSVGrasterizer;

/* Example Usage:
	// Load SVG
	NSVGimage* image;
	image = nsvgParseFromFile("test.svg", "px", 96);

	// Create rasterizer (can be used to render multiple images).
	struct NSVGrasterizer* rast = nsvgCreateRasterizer();
	// Allocate memory for image
	unsigned char* img = malloc(w*h*4);
	// Rasterize
	nsvgRasterize(rast, image, 0,0,1, img, w, h, w*4);
*/

// Allocated rasterizer context.
NSVGrasterizer* nsvgCreateRasterizer();

// Rasterizes SVG image, returns RGBA image (non-premultiplied alpha)
//   r - pointer to rasterizer context
//   image - pointer to image to rasterize
//   tx,ty - image offset (applied after scaling)
//   scale - image scale
//   dst - pointer to destination image data, 4 bytes per pixel (RGBA)
//   w - width of the image to render
//   h - height of the image to render
//   stride - number of bytes per scaleline in the destination buffer
void nsvgRasterize(NSVGrasterizer* r,
				   NSVGimage* image, float tx, float ty, float scale,
				   unsigned char* dst, int w, int h, int stride);

// Deletes rasterizer context.
void nsvgDeleteRasterizer(NSVGrasterizer*);


#ifndef NANOSVGRAST_CPLUSPLUS
#ifdef __cplusplus
}
#endif
#endif

#endif // NANOSVGRAST_H

#ifdef NANOSVGRAST_IMPLEMENTATION

#include <math.h>

#define NSVG__SUBSAMPLES	5
#define NSVG__FIXSHIFT		10
#define NSVG__FIX			(1 << NSVG__FIXSHIFT)
#define NSVG__FIXMASK		(NSVG__FIX-1)
#define NSVG__MEMPAGE_SIZE	1024

typedef struct NSVGedge {
	float x0,y0, x1,y1;
	int dir;
	struct NSVGedge* next;
} NSVGedge;

typedef struct NSVGpoint {
	float x, y;
	float dx, dy;
	float len;
	float dmx, dmy;
	unsigned char flags;
} NSVGpoint;

typedef struct NSVGactiveEdge {
	int x,dx;
	float ey;
	int dir;
	struct NSVGactiveEdge *next;
} NSVGactiveEdge;

typedef struct NSVGmemPage {
	unsigned char mem[NSVG__MEMPAGE_SIZE];
	int size;
	struct NSVGmemPage* next;
} NSVGmemPage;

typedef struct NSVGcachedPaint {
	char type;
	char spread;
	float xform[6];
	unsigned int colors[256];
} NSVGcachedPaint;

struct NSVGrasterizer
{
	float px, py;

	float tessTol;
	float distTol;

	NSVGedge* edges;
	int nedges;
	int cedges;

	NSVGpoint* points;
	int npoints;
	int cpoints;

	NSVGpoint* points2;
	int npoints2;
	int cpoints2;

	NSVGactiveEdge* freelist;
	NSVGmemPage* pages;
	NSVGmemPage* curpage;

	unsigned char* scanline;
	int cscanline;

	unsigned char* bitmap;
	int width, height, stride;
};

NSVGrasterizer* nsvgCreateRasterizer()
{
	NSVGrasterizer* r = (NSVGrasterizer*)malloc(sizeof(NSVGrasterizer));
	if (r == NULL) goto error;
	memset(r, 0, sizeof(NSVGrasterizer));

	r->tessTol = 0.25f;
	r->distTol = 0.01f;

	return r;

error:
	nsvgDeleteRasterizer(r);
	return NULL;
}

void nsvgDeleteRasterizer(NSVGrasterizer* r)
{
	NSVGmemPage* p;

	if (r == NULL) return;

	p = r->pages;
	while (p != NULL) {
		NSVGmemPage* next = p->next;
		free(p);
		p = next;
	}

	if (r->edges) free(r->edges);
	if (r->points) free(r->points);
	if (r->points2) free(r->points2);
	if (r->scanline) free(r->scanline);

	free(r);
}

static NSVGmemPage* nsvg__nextPage(NSVGrasterizer* r, NSVGmemPage* cur)
{
	NSVGmemPage *newp;

	// If using existing chain, return the next page in chain
	if (cur != NULL && cur->next != NULL) {
		return cur->next;
	}

	// Alloc new page
	newp = (NSVGmemPage*)malloc(sizeof(NSVGmemPage));
	if (newp == NULL) return NULL;
	memset(newp, 0, sizeof(NSVGmemPage));

	// Add to linked list
	if (cur != NULL)
		cur->next = newp;
	else
		r->pages = newp;

	return newp;
}

static void nsvg__resetPool(NSVGrasterizer* r)
{
	NSVGmemPage* p = r->pages;
	while (p != NULL) {
		p->size = 0;
		p = p->next;
	}
	r->curpage = r->pages;
}

static unsigned char* nsvg__alloc(NSVGrasterizer* r, int size)
{
	unsigned char* buf;
	if (size > NSVG__MEMPAGE_SIZE) return NULL;
	if (r->curpage == NULL || r->curpage->size+size > NSVG__MEMPAGE_SIZE) {
		r->curpage = nsvg__nextPage(r, r->curpage);
	}
	buf = &r->curpage->mem[r->curpage->size];
	r->curpage->size += size;
	return buf;
}

static int nsvg__ptEquals(float x1, float y1, float x2, float y2, float tol)
{
	float dx = x2 - x1;
	float dy = y2 - y1;
	return dx*dx + dy*dy < tol*tol;
}

static void nsvg__addPathPoint(NSVGrasterizer* r, float x, float y, int flags)
{
	NSVGpoint* pt;

	if (r->npoints > 0) {
		pt = &r->points[r->npoints-1];
		if (nsvg__ptEquals(pt->x,pt->y, x,y, r->distTol)) {
			pt->flags = (unsigned char)(pt->flags | flags);
			return;
		}
	}

	if (r->npoints+1 > r->cpoints) {
		r->cpoints = r->cpoints > 0 ? r->cpoints * 2 : 64;
		r->points = (NSVGpoint*)realloc(r->points, sizeof(NSVGpoint) * r->cpoints);
		if (r->points == NULL) return;
	}

	pt = &r->points[r->npoints];
	pt->x = x;
	pt->y = y;
	pt->flags = (unsigned char)flags;
	r->npoints++;
}

static void nsvg__appendPathPoint(NSVGrasterizer* r, NSVGpoint pt)
{
	if (r->npoints+1 > r->cpoints) {
		r->cpoints = r->cpoints > 0 ? r->cpoints * 2 : 64;
		r->points = (NSVGpoint*)realloc(r->points, sizeof(NSVGpoint) * r->cpoints);
		if (r->points == NULL) return;
	}
	r->points[r->npoints] = pt;
	r->npoints++;
}

static void nsvg__duplicatePoints(NSVGrasterizer* r)
{
	if (r->npoints > r->cpoints2) {
		r->cpoints2 = r->npoints;
		r->points2 = (NSVGpoint*)realloc(r->points2, sizeof(NSVGpoint) * r->cpoints2);
		if (r->points2 == NULL) return;
	}

	memcpy(r->points2, r->points, sizeof(NSVGpoint) * r->npoints);
	r->npoints2 = r->npoints;
}

static void nsvg__addEdge(NSVGrasterizer* r, float x0, float y0, float x1, float y1)
{
	NSVGedge* e;

	// Skip horizontal edges
	if (y0 == y1)
		return;

	if (r->nedges+1 > r->cedges) {
		r->cedges = r->cedges > 0 ? r->cedges * 2 : 64;
		r->edges = (NSVGedge*)realloc(r->edges, sizeof(NSVGedge) * r->cedges);
		if (r->edges == NULL) return;
	}

	e = &r->edges[r->nedges];
	r->nedges++;

	if (y0 < y1) {
		e->x0 = x0;
		e->y0 = y0;
		e->x1 = x1;
		e->y1 = y1;
		e->dir = 1;
	} else {
		e->x0 = x1;
		e->y0 = y1;
		e->x1 = x0;
		e->y1 = y0;
		e->dir = -1;
	}
}

static float nsvg__normalize(float *x, float* y)
{
	float d = sqrtf((*x)*(*x) + (*y)*(*y));
	if (d > 1e-6f) {
		float id = 1.0f / d;
		*x *= id;
		*y *= id;
	}
	return d;
}

static float nsvg__absf(float x) { return x < 0 ? -x : x; }

static void nsvg__flattenCubicBez(NSVGrasterizer* r,
								  float x1, float y1, float x2, float y2,
								  float x3, float y3, float x4, float y4,
								  int level, int type)
{
	float x12,y12,x23,y23,x34,y34,x123,y123,x234,y234,x1234,y1234;
	float dx,dy,d2,d3;

	if (level > 10) return;

	x12 = (x1+x2)*0.5f;
	y12 = (y1+y2)*0.5f;
	x23 = (x2+x3)*0.5f;
	y23 = (y2+y3)*0.5f;
	x34 = (x3+x4)*0.5f;
	y34 = (y3+y4)*0.5f;
	x123 = (x12+x23)*0.5f;
	y123 = (y12+y23)*0.5f;

	dx = x4 - x1;
	dy = y4 - y1;
	d2 = nsvg__absf(((x2 - x4) * dy - (y2 - y4) * dx));
	d3 = nsvg__absf(((x3 - x4) * dy - (y3 - y4) * dx));

	if ((d2 + d3)*(d2 + d3) < r->tessTol * (dx*dx + dy*dy)) {
		nsvg__addPathPoint(r, x4, y4, type);
		return;
	}

	x234 = (x23+x34)*0.5f;
	y234 = (y23+y34)*0.5f;
	x1234 = (x123+x234)*0.5f;
	y1234 = (y123+y234)*0.5f;

	nsvg__flattenCubicBez(r, x1,y1, x12,y12, x123,y123, x1234,y1234, level+1, 0);
	nsvg__flattenCubicBez(r, x1234,y1234, x234,y234, x34,y34, x4,y4, level+1, type);
}

static void nsvg__flattenShape(NSVGrasterizer* r, NSVGshape* shape, float scale)
{
	int i, j;
	NSVGpath* path;

	for (path = shape->paths; path != NULL; path = path->next) {
		r->npoints = 0;
		// Flatten path
		nsvg__addPathPoint(r, path->pts[0]*scale, path->pts[1]*scale, 0);
		for (i = 0; i < path->npts-1; i += 3) {
			float* p = &path->pts[i*2];
			nsvg__flattenCubicBez(r, p[0]*scale,p[1]*scale, p[2]*scale,p[3]*scale, p[4]*scale,p[5]*scale, p[6]*scale,p[7]*scale, 0, 0);
		}
		// Close path
		nsvg__addPathPoint(r, path->pts[0]*scale, path->pts[1]*scale, 0);
		// Build edges
		for (i = 0, j = r->npoints-1; i < r->npoints; j = i++)
			nsvg__addEdge(r, r->points[j].x, r->points[j].y, r->points[i].x, r->points[i].y);
	}
}

enum NSVGpointFlags
{
	NSVG_PT_CORNER = 0x01,
	NSVG_PT_BEVEL = 0x02,
	NSVG_PT_LEFT = 0x04
};

static void nsvg__initClosed(NSVGpoint* left, NSVGpoint* right, NSVGpoint* p0, NSVGpoint* p1, float lineWidth)
{
	float w = lineWidth * 0.5f;
	float dx = p1->x - p0->x;
	float dy = p1->y - p0->y;
	float len = nsvg__normalize(&dx, &dy);
	float px = p0->x + dx*len*0.5f, py = p0->y + dy*len*0.5f;
	float dlx = dy, dly = -dx;
	float lx = px - dlx*w, ly = py - dly*w;
	float rx = px + dlx*w, ry = py + dly*w;
	left->x = lx; left->y = ly;
	right->x = rx; right->y = ry;
}

static void nsvg__buttCap(NSVGrasterizer* r, NSVGpoint* left, NSVGpoint* right, NSVGpoint* p, float dx, float dy, float lineWidth, int connect)
{
	float w = lineWidth * 0.5f;
	float px = p->x, py = p->y;
	float dlx = dy, dly = -dx;
	float lx = px - dlx*w, ly = py - dly*w;
	float rx = px + dlx*w, ry = py + dly*w;

	nsvg__addEdge(r, lx, ly, rx, ry);

	if (connect) {
		nsvg__addEdge(r, left->x, left->y, lx, ly);
		nsvg__addEdge(r, rx, ry, right->x, right->y);
	}
	left->x = lx; left->y = ly;
	right->x = rx; right->y = ry;
}

static void nsvg__squareCap(NSVGrasterizer* r, NSVGpoint* left, NSVGpoint* right, NSVGpoint* p, float dx, float dy, float lineWidth, int connect)
{
	float w = lineWidth * 0.5f;
	float px = p->x - dx*w, py = p->y - dy*w;
	float dlx = dy, dly = -dx;
	float lx = px - dlx*w, ly = py - dly*w;
	float rx = px + dlx*w, ry = py + dly*w;

	nsvg__addEdge(r, lx, ly, rx, ry);

	if (connect) {
		nsvg__addEdge(r, left->x, left->y, lx, ly);
		nsvg__addEdge(r, rx, ry, right->x, right->y);
	}
	left->x = lx; left->y = ly;
	right->x = rx; right->y = ry;
}

#ifndef NSVG_PI
#define NSVG_PI (3.14159265358979323846264338327f)
#endif

static void nsvg__roundCap(NSVGrasterizer* r, NSVGpoint* left, NSVGpoint* right, NSVGpoint* p, float dx, float dy, float lineWidth, int ncap, int connect)
{
	int i;
	float w = lineWidth * 0.5f;
	float px = p->x, py = p->y;
	float dlx = dy, dly = -dx;
	float lx = 0, ly = 0, rx = 0, ry = 0, prevx = 0, prevy = 0;

	for (i = 0; i < ncap; i++) {
		float a = (float)i/(float)(ncap-1)*NSVG_PI;
		float ax = cosf(a) * w, ay = sinf(a) * w;
		float x = px - dlx*ax - dx*ay;
		float y = py - dly*ax - dy*ay;

		if (i > 0)
			nsvg__addEdge(r, prevx, prevy, x, y);

		prevx = x;
		prevy = y;

		if (i == 0) {
			lx = x; ly = y;
		} else if (i == ncap-1) {
			rx = x; ry = y;
		}
	}

	if (connect) {
		nsvg__addEdge(r, left->x, left->y, lx, ly);
		nsvg__addEdge(r, rx, ry, right->x, right->y);
	}

	left->x = lx; left->y = ly;
	right->x = rx; right->y = ry;
}

static void nsvg__bevelJoin(NSVGrasterizer* r, NSVGpoint* left, NSVGpoint* right, NSVGpoint* p0, NSVGpoint* p1, float lineWidth)
{
	float w = lineWidth * 0.5f;
	float dlx0 = p0->dy, dly0 = -p0->dx;
	float dlx1 = p1->dy, dly1 = -p1->dx;
	float lx0 = p1->x - (dlx0 * w), ly0 = p1->y - (dly0 * w);
	float rx0 = p1->x + (dlx0 * w), ry0 = p1->y + (dly0 * w);
	float lx1 = p1->x - (dlx1 * w), ly1 = p1->y - (dly1 * w);
	float rx1 = p1->x + (dlx1 * w), ry1 = p1->y + (dly1 * w);

	nsvg__addEdge(r, lx0, ly0, left->x, left->y);
	nsvg__addEdge(r, lx1, ly1, lx0, ly0);

	nsvg__addEdge(r, right->x, right->y, rx0, ry0);
	nsvg__addEdge(r, rx0, ry0, rx1, ry1);

	left->x = lx1; left->y = ly1;
	right->x = rx1; right->y = ry1;
}

static void nsvg__miterJoin(NSVGrasterizer* r, NSVGpoint* left, NSVGpoint* right, NSVGpoint* p0, NSVGpoint* p1, float lineWidth)
{
	float w = lineWidth * 0.5f;
	float dlx0 = p0->dy, dly0 = -p0->dx;
	float dlx1 = p1->dy, dly1 = -p1->dx;
	float lx0, rx0, lx1, rx1;
	float ly0, ry0, ly1, ry1;

	if (p1->flags & NSVG_PT_LEFT) {
		lx0 = lx1 = p1->x - p1->dmx * w;
		ly0 = ly1 = p1->y - p1->dmy * w;
		nsvg__addEdge(r, lx1, ly1, left->x, left->y);

		rx0 = p1->x + (dlx0 * w);
		ry0 = p1->y + (dly0 * w);
		rx1 = p1->x + (dlx1 * w);
		ry1 = p1->y + (dly1 * w);
		nsvg__addEdge(r, right->x, right->y, rx0, ry0);
		nsvg__addEdge(r, rx0, ry0, rx1, ry1);
	} else {
		lx0 = p1->x - (dlx0 * w);
		ly0 = p1->y - (dly0 * w);
		lx1 = p1->x - (dlx1 * w);
		ly1 = p1->y - (dly1 * w);
		nsvg__addEdge(r, lx0, ly0, left->x, left->y);
		nsvg__addEdge(r, lx1, ly1, lx0, ly0);

		rx0 = rx1 = p1->x + p1->dmx * w;
		ry0 = ry1 = p1->y + p1->dmy * w;
		nsvg__addEdge(r, right->x, right->y, rx1, ry1);
	}

	left->x = lx1; left->y = ly1;
	right->x = rx1; right->y = ry1;
}

static void nsvg__roundJoin(NSVGrasterizer* r, NSVGpoint* left, NSVGpoint* right, NSVGpoint* p0, NSVGpoint* p1, float lineWidth, int ncap)
{
	int i, n;
	float w = lineWidth * 0.5f;
	float dlx0 = p0->dy, dly0 = -p0->dx;
	float dlx1 = p1->dy, dly1 = -p1->dx;
	float a0 = atan2f(dly0, dlx0);
	float a1 = atan2f(dly1, dlx1);
	float da = a1 - a0;
	float lx, ly, rx, ry;

	if (da < NSVG_PI) da += NSVG_PI*2;
	if (da > NSVG_PI) da -= NSVG_PI*2;

	n = (int)ceilf((nsvg__absf(da) / NSVG_PI) * (float)ncap);
	if (n < 2) n = 2;
	if (n > ncap) n = ncap;

	lx = left->x;
	ly = left->y;
	rx = right->x;
	ry = right->y;

	for (i = 0; i < n; i++) {
		float u = (float)i/(float)(n-1);
		float a = a0 + u*da;
		float ax = cosf(a) * w, ay = sinf(a) * w;
		float lx1 = p1->x - ax, ly1 = p1->y - ay;
		float rx1 = p1->x + ax, ry1 = p1->y + ay;

		nsvg__addEdge(r, lx1, ly1, lx, ly);
		nsvg__addEdge(r, rx, ry, rx1, ry1);

		lx = lx1; ly = ly1;
		rx = rx1; ry = ry1;
	}

	left->x = lx; left->y = ly;
	right->x = rx; right->y = ry;
}

static void nsvg__straightJoin(NSVGrasterizer* r, NSVGpoint* left, NSVGpoint* right, NSVGpoint* p1, float lineWidth)
{
	float w = lineWidth * 0.5f;
	float lx = p1->x - (p1->dmx * w), ly = p1->y - (p1->dmy * w);
	float rx = p1->x + (p1->dmx * w), ry = p1->y + (p1->dmy * w);

	nsvg__addEdge(r, lx, ly, left->x, left->y);
	nsvg__addEdge(r, right->x, right->y, rx, ry);

	left->x = lx; left->y = ly;
	right->x = rx; right->y = ry;
}

static int nsvg__curveDivs(float r, float arc, float tol)
{
	float da = acosf(r / (r + tol)) * 2.0f;
	int divs = (int)ceilf(arc / da);
	if (divs < 2) divs = 2;
	return divs;
}

static void nsvg__expandStroke(NSVGrasterizer* r, NSVGpoint* points, int npoints, int closed, int lineJoin, int lineCap, float lineWidth)
{
	int ncap = nsvg__curveDivs(lineWidth*0.5f, NSVG_PI, r->tessTol);	// Calculate divisions per half circle.
	NSVGpoint left = {0,0,0,0,0,0,0,0}, right = {0,0,0,0,0,0,0,0}, firstLeft = {0,0,0,0,0,0,0,0}, firstRight = {0,0,0,0,0,0,0,0};
	NSVGpoint* p0, *p1;
	int j, s, e;

	// Build stroke edges
	if (closed) {
		// Looping
		p0 = &points[npoints-1];
		p1 = &points[0];
		s = 0;
		e = npoints;
	} else {
		// Add cap
		p0 = &points[0];
		p1 = &points[1];
		s = 1;
		e = npoints-1;
	}

	if (closed) {
		nsvg__initClosed(&left, &right, p0, p1, lineWidth);
		firstLeft = left;
		firstRight = right;
	} else {
		// Add cap
		float dx = p1->x - p0->x;
		float dy = p1->y - p0->y;
		nsvg__normalize(&dx, &dy);
		if (lineCap == NSVG_CAP_BUTT)
			nsvg__buttCap(r, &left, &right, p0, dx, dy, lineWidth, 0);
		else if (lineCap == NSVG_CAP_SQUARE)
			nsvg__squareCap(r, &left, &right, p0, dx, dy, lineWidth, 0);
		else if (lineCap == NSVG_CAP_ROUND)
			nsvg__roundCap(r, &left, &right, p0, dx, dy, lineWidth, ncap, 0);
	}

	for (j = s; j < e; ++j) {
		if (p1->flags & NSVG_PT_CORNER) {
			if (lineJoin == NSVG_JOIN_ROUND)
				nsvg__roundJoin(r, &left, &right, p0, p1, lineWidth, ncap);
			else if (lineJoin == NSVG_JOIN_BEVEL || (p1->flags & NSVG_PT_BEVEL))
				nsvg__bevelJoin(r, &left, &right, p0, p1, lineWidth);
			else
				nsvg__miterJoin(r, &left, &right, p0, p1, lineWidth);
		} else {
			nsvg__straightJoin(r, &left, &right, p1, lineWidth);
		}
		p0 = p1++;
	}

	if (closed) {
		// Loop it
		nsvg__addEdge(r, firstLeft.x, firstLeft.y, left.x, left.y);
		nsvg__addEdge(r, right.x, right.y, firstRight.x, firstRight.y);
	} else {
		// Add cap
		float dx = p1->x - p0->x;
		float dy = p1->y - p0->y;
		nsvg__normalize(&dx, &dy);
		if (lineCap == NSVG_CAP_BUTT)
			nsvg__buttCap(r, &right, &left, p1, -dx, -dy, lineWidth, 1);
		else if (lineCap == NSVG_CAP_SQUARE)
			nsvg__squareCap(r, &right, &left, p1, -dx, -dy, lineWidth, 1);
		else if (lineCap == NSVG_CAP_ROUND)
			nsvg__roundCap(r, &right, &left, p1, -dx, -dy, lineWidth, ncap, 1);
	}
}

static void nsvg__prepareStroke(NSVGrasterizer* r, float miterLimit, int lineJoin)
{
	int i, j;
	NSVGpoint* p0, *p1;

	p0 = &r->points[r->npoints-1];
	p1 = &r->points[0];
	for (i = 0; i < r->npoints; i++) {
		// Calculate segment direction and length
		p0->dx = p1->x - p0->x;
		p0->dy = p1->y - p0->y;
		p0->len = nsvg__normalize(&p0->dx, &p0->dy);
		// Advance
		p0 = p1++;
	}

	// calculate joins
	p0 = &r->points[r->npoints-1];
	p1 = &r->points[0];
	for (j = 0; j < r->npoints; j++) {
		float dlx0, dly0, dlx1, dly1, dmr2, cross;
		dlx0 = p0->dy;
		dly0 = -p0->dx;
		dlx1 = p1->dy;
		dly1 = -p1->dx;
		// Calculate extrusions
		p1->dmx = (dlx0 + dlx1) * 0.5f;
		p1->dmy = (dly0 + dly1) * 0.5f;
		dmr2 = p1->dmx*p1->dmx + p1->dmy*p1->dmy;
		if (dmr2 > 0.000001f) {
			float s2 = 1.0f / dmr2;
			if (s2 > 600.0f) {
				s2 = 600.0f;
			}
			p1->dmx *= s2;
			p1->dmy *= s2;
		}

		// Clear flags, but keep the corner.
		p1->flags = (p1->flags & NSVG_PT_CORNER) ? NSVG_PT_CORNER : 0;

		// Keep track of left turns.
		cross = p1->dx * p0->dy - p0->dx * p1->dy;
		if (cross > 0.0f)
			p1->flags |= NSVG_PT_LEFT;

		// Check to see if the corner needs to be beveled.
		if (p1->flags & NSVG_PT_CORNER) {
			if ((dmr2 * miterLimit*miterLimit) < 1.0f || lineJoin == NSVG_JOIN_BEVEL || lineJoin == NSVG_JOIN_ROUND) {
				p1->flags |= NSVG_PT_BEVEL;
			}
		}

		p0 = p1++;
	}
}

static void nsvg__flattenShapeStroke(NSVGrasterizer* r, NSVGshape* shape, float scale)
{
	int i, j, closed;
	NSVGpath* path;
	NSVGpoint* p0, *p1;
	float miterLimit = shape->miterLimit;
	int lineJoin = shape->strokeLineJoin;
	int lineCap = shape->strokeLineCap;
	float lineWidth = shape->strokeWidth * scale;

	for (path = shape->paths; path != NULL; path = path->next) {
		// Flatten path
		r->npoints = 0;
		nsvg__addPathPoint(r, path->pts[0]*scale, path->pts[1]*scale, NSVG_PT_CORNER);
		for (i = 0; i < path->npts-1; i += 3) {
			float* p = &path->pts[i*2];
			nsvg__flattenCubicBez(r, p[0]*scale,p[1]*scale, p[2]*scale,p[3]*scale, p[4]*scale,p[5]*scale, p[6]*scale,p[7]*scale, 0, NSVG_PT_CORNER);
		}
		if (r->npoints < 2)
			continue;

		closed = path->closed;

		// If the first and last points are the same, remove the last, mark as closed path.
		p0 = &r->points[r->npoints-1];
		p1 = &r->points[0];
		if (nsvg__ptEquals(p0->x,p0->y, p1->x,p1->y, r->distTol)) {
			r->npoints--;
			p0 = &r->points[r->npoints-1];
			closed = 1;
		}

		if (shape->strokeDashCount > 0) {
			int idash = 0, dashState = 1;
			float totalDist = 0, dashLen, allDashLen, dashOffset;
			NSVGpoint cur;

			if (closed)
				nsvg__appendPathPoint(r, r->points[0]);

			// Duplicate points -> points2.
			nsvg__duplicatePoints(r);

			r->npoints = 0;
 			cur = r->points2[0];
			nsvg__appendPathPoint(r, cur);

			// Figure out dash offset.
			allDashLen = 0;
			for (j = 0; j < shape->strokeDashCount; j++)
				allDashLen += shape->strokeDashArray[j];
			if (shape->strokeDashCount & 1)
				allDashLen *= 2.0f;
			// Find location inside pattern
			dashOffset = fmodf(shape->strokeDashOffset, allDashLen);
			if (dashOffset < 0.0f)
				dashOffset += allDashLen;

			while (dashOffset > shape->strokeDashArray[idash]) {
				dashOffset -= shape->strokeDashArray[idash];
				idash = (idash + 1) % shape->strokeDashCount;
			}
			dashLen = (shape->strokeDashArray[idash] - dashOffset) * scale;

			for (j = 1; j < r->npoints2; ) {
				float dx = r->points2[j].x - cur.x;
				float dy = r->points2[j].y - cur.y;
				float dist = sqrtf(dx*dx + dy*dy);

				if ((totalDist + dist) > dashLen) {
					// Calculate intermediate point
					float d = (dashLen - totalDist) / dist;
					float x = cur.x + dx * d;
					float y = cur.y + dy * d;
					nsvg__addPathPoint(r, x, y, NSVG_PT_CORNER);

					// Stroke
					if (r->npoints > 1 && dashState) {
						nsvg__prepareStroke(r, miterLimit, lineJoin);
						nsvg__expandStroke(r, r->points, r->npoints, 0, lineJoin, lineCap, lineWidth);
					}
					// Advance dash pattern
					dashState = !dashState;
					idash = (idash+1) % shape->strokeDashCount;
					dashLen = shape->strokeDashArray[idash] * scale;
					// Restart
					cur.x = x;
					cur.y = y;
					cur.flags = NSVG_PT_CORNER;
					totalDist = 0.0f;
					r->npoints = 0;
					nsvg__appendPathPoint(r, cur);
				} else {
					totalDist += dist;
					cur = r->points2[j];
					nsvg__appendPathPoint(r, cur);
					j++;
				}
			}
			// Stroke any leftover path
			if (r->npoints > 1 && dashState)
				nsvg__expandStroke(r, r->points, r->npoints, 0, lineJoin, lineCap, lineWidth);
		} else {
			nsvg__prepareStroke(r, miterLimit, lineJoin);
			nsvg__expandStroke(r, r->points, r->npoints, closed, lineJoin, lineCap, lineWidth);
		}
	}
}

static int nsvg__cmpEdge(const void *p, const void *q)
{
	const NSVGedge* a = (const NSVGedge*)p;
	const NSVGedge* b = (const NSVGedge*)q;

	if (a->y0 < b->y0) return -1;
	if (a->y0 > b->y0) return  1;
	return 0;
}


static NSVGactiveEdge* nsvg__addActive(NSVGrasterizer* r, NSVGedge* e, float startPoint)
{
	 NSVGactiveEdge* z;

	if (r->freelist != NULL) {
		// Restore from freelist.
		z = r->freelist;
		r->freelist = z->next;
	} else {
		// Alloc new edge.
		z = (NSVGactiveEdge*)nsvg__alloc(r, sizeof(NSVGactiveEdge));
		if (z == NULL) return NULL;
	}

	float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
//	STBTT_assert(e->y0 <= start_point);
	// round dx down to avoid going too far
	if (dxdy < 0)
		z->dx = (int)(-floorf(NSVG__FIX * -dxdy));
	else
		z->dx = (int)floorf(NSVG__FIX * dxdy);
	z->x = (int)floorf(NSVG__FIX * (e->x0 + dxdy * (startPoint - e->y0)));
//	z->x -= off_x * FIX;
	z->ey = e->y1;
	z->next = 0;
	z->dir = e->dir;

	return z;
}

static void nsvg__freeActive(NSVGrasterizer* r, NSVGactiveEdge* z)
{
	z->next = r->freelist;
	r->freelist = z;
}

static void nsvg__fillScanline(unsigned char* scanline, int len, int x0, int x1, int maxWeight, int* xmin, int* xmax)
{
	int i = x0 >> NSVG__FIXSHIFT;
	int j = x1 >> NSVG__FIXSHIFT;
	if (i < *xmin) *xmin = i;
	if (j > *xmax) *xmax = j;
	if (i < len && j >= 0) {
		if (i == j) {
			// x0,x1 are the same pixel, so compute combined coverage
			scanline[i] = (unsigned char)(scanline[i] + ((x1 - x0) * maxWeight >> NSVG__FIXSHIFT));
		} else {
			if (i >= 0) // add antialiasing for x0
				scanline[i] = (unsigned char)(scanline[i] + (((NSVG__FIX - (x0 & NSVG__FIXMASK)) * maxWeight) >> NSVG__FIXSHIFT));
			else
				i = -1; // clip

			if (j < len) // add antialiasing for x1
				scanline[j] = (unsigned char)(scanline[j] + (((x1 & NSVG__FIXMASK) * maxWeight) >> NSVG__FIXSHIFT));
			else
				j = len; // clip

			for (++i; i < j; ++i) // fill pixels between x0 and x1
				scanline[i] = (unsigned char)(scanline[i] + maxWeight);
		}
	}
}

// note: this routine clips fills that extend off the edges... ideally this
// wouldn't happen, but it could happen if the truetype glyph bounding boxes
// are wrong, or if the user supplies a too-small bitmap
static void nsvg__fillActiveEdges(unsigned char* scanline, int len, NSVGactiveEdge* e, int maxWeight, int* xmin, int* xmax, char fillRule)
{
	// non-zero winding fill
	int x0 = 0, w = 0;

	if (fillRule == NSVG_FILLRULE_NONZERO) {
		// Non-zero
		while (e != NULL) {
			if (w == 0) {
				// if we're currently at zero, we need to record the edge start point
				x0 = e->x; w += e->dir;
			} else {
				int x1 = e->x; w += e->dir;
				// if we went to zero, we need to draw
				if (w == 0)
					nsvg__fillScanline(scanline, len, x0, x1, maxWeight, xmin, xmax);
			}
			e = e->next;
		}
	} else if (fillRule == NSVG_FILLRULE_EVENODD) {
		// Even-odd
		while (e != NULL) {
			if (w == 0) {
				// if we're currently at zero, we need to record the edge start point
				x0 = e->x; w = 1;
			} else {
				int x1 = e->x; w = 0;
				nsvg__fillScanline(scanline, len, x0, x1, maxWeight, xmin, xmax);
			}
			e = e->next;
		}
	}
}

static float nsvg__clampf(float a, float mn, float mx) { return a < mn ? mn : (a > mx ? mx : a); }

static unsigned int nsvg__RGBA(unsigned char r, unsigned char g, unsigned char b, unsigned char a)
{
	return (r) | (g << 8) | (b << 16) | (a << 24);
}

static unsigned int nsvg__lerpRGBA(unsigned int c0, unsigned int c1, float u)
{
	int iu = (int)(nsvg__clampf(u, 0.0f, 1.0f) * 256.0f);
	int r = (((c0) & 0xff)*(256-iu) + (((c1) & 0xff)*iu)) >> 8;
	int g = (((c0>>8) & 0xff)*(256-iu) + (((c1>>8) & 0xff)*iu)) >> 8;
	int b = (((c0>>16) & 0xff)*(256-iu) + (((c1>>16) & 0xff)*iu)) >> 8;
	int a = (((c0>>24) & 0xff)*(256-iu) + (((c1>>24) & 0xff)*iu)) >> 8;
	return nsvg__RGBA((unsigned char)r, (unsigned char)g, (unsigned char)b, (unsigned char)a);
}

static unsigned int nsvg__applyOpacity(unsigned int c, float u)
{
	int iu = (int)(nsvg__clampf(u, 0.0f, 1.0f) * 256.0f);
	int r = (c) & 0xff;
	int g = (c>>8) & 0xff;
	int b = (c>>16) & 0xff;
	int a = (((c>>24) & 0xff)*iu) >> 8;
	return nsvg__RGBA((unsigned char)r, (unsigned char)g, (unsigned char)b, (unsigned char)a);
}

static inline int nsvg__div255(int x)
{
    return ((x+1) * 257) >> 16;
}

static void nsvg__scanlineSolid(unsigned char* dst, int count, unsigned char* cover, int x, int y,
								float tx, float ty, float scale, NSVGcachedPaint* cache)
{

	if (cache->type == NSVG_PAINT_COLOR) {
		int i, cr, cg, cb, ca;
		cr = cache->colors[0] & 0xff;
		cg = (cache->colors[0] >> 8) & 0xff;
		cb = (cache->colors[0] >> 16) & 0xff;
		ca = (cache->colors[0] >> 24) & 0xff;

		for (i = 0; i < count; i++) {
			int r,g,b;
			int a = nsvg__div255((int)cover[0] * ca);
			int ia = 255 - a;
			// Premultiply
			r = nsvg__div255(cr * a);
			g = nsvg__div255(cg * a);
			b = nsvg__div255(cb * a);

			// Blend over
			r += nsvg__div255(ia * (int)dst[0]);
			g += nsvg__div255(ia * (int)dst[1]);
			b += nsvg__div255(ia * (int)dst[2]);
			a += nsvg__div255(ia * (int)dst[3]);

			dst[0] = (unsigned char)r;
			dst[1] = (unsigned char)g;
			dst[2] = (unsigned char)b;
			dst[3] = (unsigned char)a;

			cover++;
			dst += 4;
		}
	} else if (cache->type == NSVG_PAINT_LINEAR_GRADIENT) {
		// TODO: spread modes.
		// TODO: plenty of opportunities to optimize.
		float fx, fy, dx, gy;
		float* t = cache->xform;
		int i, cr, cg, cb, ca;
		unsigned int c;

		fx = ((float)x - tx) / scale;
		fy = ((float)y - ty) / scale;
		dx = 1.0f / scale;

		for (i = 0; i < count; i++) {
			int r,g,b,a,ia;
			gy = fx*t[1] + fy*t[3] + t[5];
			c = cache->colors[(int)nsvg__clampf(gy*255.0f, 0, 255.0f)];
			cr = (c) & 0xff;
			cg = (c >> 8) & 0xff;
			cb = (c >> 16) & 0xff;
			ca = (c >> 24) & 0xff;

			a = nsvg__div255((int)cover[0] * ca);
			ia = 255 - a;

			// Premultiply
			r = nsvg__div255(cr * a);
			g = nsvg__div255(cg * a);
			b = nsvg__div255(cb * a);

			// Blend over
			r += nsvg__div255(ia * (int)dst[0]);
			g += nsvg__div255(ia * (int)dst[1]);
			b += nsvg__div255(ia * (int)dst[2]);
			a += nsvg__div255(ia * (int)dst[3]);

			dst[0] = (unsigned char)r;
			dst[1] = (unsigned char)g;
			dst[2] = (unsigned char)b;
			dst[3] = (unsigned char)a;

			cover++;
			dst += 4;
			fx += dx;
		}
	} else if (cache->type == NSVG_PAINT_RADIAL_GRADIENT) {
		// TODO: spread modes.
		// TODO: plenty of opportunities to optimize.
		// TODO: focus (fx,fy)
		float fx, fy, dx, gx, gy, gd;
		float* t = cache->xform;
		int i, cr, cg, cb, ca;
		unsigned int c;

		fx = ((float)x - tx) / scale;
		fy = ((float)y - ty) / scale;
		dx = 1.0f / scale;

		for (i = 0; i < count; i++) {
			int r,g,b,a,ia;
			gx = fx*t[0] + fy*t[2] + t[4];
			gy = fx*t[1] + fy*t[3] + t[5];
			gd = sqrtf(gx*gx + gy*gy);
			c = cache->colors[(int)nsvg__clampf(gd*255.0f, 0, 255.0f)];
			cr = (c) & 0xff;
			cg = (c >> 8) & 0xff;
			cb = (c >> 16) & 0xff;
			ca = (c >> 24) & 0xff;

			a = nsvg__div255((int)cover[0] * ca);
			ia = 255 - a;

			// Premultiply
			r = nsvg__div255(cr * a);
			g = nsvg__div255(cg * a);
			b = nsvg__div255(cb * a);

			// Blend over
			r += nsvg__div255(ia * (int)dst[0]);
			g += nsvg__div255(ia * (int)dst[1]);
			b += nsvg__div255(ia * (int)dst[2]);
			a += nsvg__div255(ia * (int)dst[3]);

			dst[0] = (unsigned char)r;
			dst[1] = (unsigned char)g;
			dst[2] = (unsigned char)b;
			dst[3] = (unsigned char)a;

			cover++;
			dst += 4;
			fx += dx;
		}
	}
}

static void nsvg__rasterizeSortedEdges(NSVGrasterizer *r, float tx, float ty, float scale, NSVGcachedPaint* cache, char fillRule)
{
	NSVGactiveEdge *active = NULL;
	int y, s;
	int e = 0;
	int maxWeight = (255 / NSVG__SUBSAMPLES);  // weight per vertical scanline
	int xmin, xmax;

	for (y = 0; y < r->height; y++) {
		memset(r->scanline, 0, r->width);
		xmin = r->width;
		xmax = 0;
		for (s = 0; s < NSVG__SUBSAMPLES; ++s) {
			// find center of pixel for this scanline
			float scany = (float)(y*NSVG__SUBSAMPLES + s) + 0.5f;
			NSVGactiveEdge **step = &active;

			// update all active edges;
			// remove all active edges that terminate before the center of this scanline
			while (*step) {
				NSVGactiveEdge *z = *step;
				if (z->ey <= scany) {
					*step = z->next; // delete from list
//					NSVG__assert(z->valid);
					nsvg__freeActive(r, z);
				} else {
					z->x += z->dx; // advance to position for current scanline
					step = &((*step)->next); // advance through list
				}
			}

			// resort the list if needed
			for (;;) {
				int changed = 0;
				step = &active;
				while (*step && (*step)->next) {
					if ((*step)->x > (*step)->next->x) {
						NSVGactiveEdge* t = *step;
						NSVGactiveEdge* q = t->next;
						t->next = q->next;
						q->next = t;
						*step = q;
						changed = 1;
					}
					step = &(*step)->next;
				}
				if (!changed) break;
			}

			// insert all edges that start before the center of this scanline -- omit ones that also end on this scanline
			while (e < r->nedges && r->edges[e].y0 <= scany) {
				if (r->edges[e].y1 > scany) {
					NSVGactiveEdge* z = nsvg__addActive(r, &r->edges[e], scany);
					if (z == NULL) break;
					// find insertion point
					if (active == NULL) {
						active = z;
					} else if (z->x < active->x) {
						// insert at front
						z->next = active;
						active = z;
					} else {
						// find thing to insert AFTER
						NSVGactiveEdge* p = active;
						while (p->next && p->next->x < z->x)
							p = p->next;
						// at this point, p->next->x is NOT < z->x
						z->next = p->next;
						p->next = z;
					}
				}
				e++;
			}

			// now process all active edges in non-zero fashion
			if (active != NULL)
				nsvg__fillActiveEdges(r->scanline, r->width, active, maxWeight, &xmin, &xmax, fillRule);
		}
		// Blit
		if (xmin < 0) xmin = 0;
		if (xmax > r->width-1) xmax = r->width-1;
		if (xmin <= xmax) {
			nsvg__scanlineSolid(&r->bitmap[y * r->stride] + xmin*4, xmax-xmin+1, &r->scanline[xmin], xmin, y, tx,ty, scale, cache);
		}
	}

}

static void nsvg__unpremultiplyAlpha(unsigned char* image, int w, int h, int stride)
{
	int x,y;

	// Unpremultiply
	for (y = 0; y < h; y++) {
		unsigned char *row = &image[y*stride];
		for (x = 0; x < w; x++) {
			int r = row[0], g = row[1], b = row[2], a = row[3];
			if (a != 0) {
				row[0] = (unsigned char)(r*255/a);
				row[1] = (unsigned char)(g*255/a);
				row[2] = (unsigned char)(b*255/a);
			}
			row += 4;
		}
	}

	// Defringe
	for (y = 0; y < h; y++) {
		unsigned char *row = &image[y*stride];
		for (x = 0; x < w; x++) {
			int r = 0, g = 0, b = 0, a = row[3], n = 0;
			if (a == 0) {
				if (x-1 > 0 && row[-1] != 0) {
					r += row[-4];
					g += row[-3];
					b += row[-2];
					n++;
				}
				if (x+1 < w && row[7] != 0) {
					r += row[4];
					g += row[5];
					b += row[6];
					n++;
				}
				if (y-1 > 0 && row[-stride+3] != 0) {
					r += row[-stride];
					g += row[-stride+1];
					b += row[-stride+2];
					n++;
				}
				if (y+1 < h && row[stride+3] != 0) {
					r += row[stride];
					g += row[stride+1];
					b += row[stride+2];
					n++;
				}
				if (n > 0) {
					row[0] = (unsigned char)(r/n);
					row[1] = (unsigned char)(g/n);
					row[2] = (unsigned char)(b/n);
				}
			}
			row += 4;
		}
	}
}


static void nsvg__initPaint(NSVGcachedPaint* cache, NSVGpaint* paint, float opacity)
{
	int i, j;
	NSVGgradient* grad;

	cache->type = paint->type;

	if (paint->type == NSVG_PAINT_COLOR) {
		cache->colors[0] = nsvg__applyOpacity(paint->color, opacity);
		return;
	}

	grad = paint->gradient;

	cache->spread = grad->spread;
	memcpy(cache->xform, grad->xform, sizeof(float)*6);

	if (grad->nstops == 0) {
		for (i = 0; i < 256; i++)
			cache->colors[i] = 0;
	} if (grad->nstops == 1) {
		for (i = 0; i < 256; i++)
			cache->colors[i] = nsvg__applyOpacity(grad->stops[i].color, opacity);
	} else {
		unsigned int ca, cb = 0;
		float ua, ub, du, u;
		int ia, ib, count;

		ca = nsvg__applyOpacity(grad->stops[0].color, opacity);
		ua = nsvg__clampf(grad->stops[0].offset, 0, 1);
		ub = nsvg__clampf(grad->stops[grad->nstops-1].offset, ua, 1);
		ia = (int)(ua * 255.0f);
		ib = (int)(ub * 255.0f);
		for (i = 0; i < ia; i++) {
			cache->colors[i] = ca;
		}

		for (i = 0; i < grad->nstops-1; i++) {
			ca = nsvg__applyOpacity(grad->stops[i].color, opacity);
			cb = nsvg__applyOpacity(grad->stops[i+1].color, opacity);
			ua = nsvg__clampf(grad->stops[i].offset, 0, 1);
			ub = nsvg__clampf(grad->stops[i+1].offset, 0, 1);
			ia = (int)(ua * 255.0f);
			ib = (int)(ub * 255.0f);
			count = ib - ia;
			if (count <= 0) continue;
			u = 0;
			du = 1.0f / (float)count;
			for (j = 0; j < count; j++) {
				cache->colors[ia+j] = nsvg__lerpRGBA(ca,cb,u);
				u += du;
			}
		}

		for (i = ib; i < 256; i++)
			cache->colors[i] = cb;
	}

}

/*
static void dumpEdges(NSVGrasterizer* r, const char* name)
{
	float xmin = 0, xmax = 0, ymin = 0, ymax = 0;
	NSVGedge *e = NULL;
	int i;
	if (r->nedges == 0) return;
	FILE* fp = fopen(name, "w");
	if (fp == NULL) return;

	xmin = xmax = r->edges[0].x0;
	ymin = ymax = r->edges[0].y0;
	for (i = 0; i < r->nedges; i++) {
		e = &r->edges[i];
		xmin = nsvg__minf(xmin, e->x0);
		xmin = nsvg__minf(xmin, e->x1);
		xmax = nsvg__maxf(xmax, e->x0);
		xmax = nsvg__maxf(xmax, e->x1);
		ymin = nsvg__minf(ymin, e->y0);
		ymin = nsvg__minf(ymin, e->y1);
		ymax = nsvg__maxf(ymax, e->y0);
		ymax = nsvg__maxf(ymax, e->y1);
	}

	fprintf(fp, "<svg viewBox=\"%f %f %f %f\" xmlns=\"http://www.w3.org/2000/svg\">", xmin, ymin, (xmax - xmin), (ymax - ymin));

	for (i = 0; i < r->nedges; i++) {
		e = &r->edges[i];
		fprintf(fp ,"<line x1=\"%f\" y1=\"%f\" x2=\"%f\" y2=\"%f\" style=\"stroke:#000;\" />", e->x0,e->y0, e->x1,e->y1);
	}

	for (i = 0; i < r->npoints; i++) {
		if (i+1 < r->npoints)
			fprintf(fp ,"<line x1=\"%f\" y1=\"%f\" x2=\"%f\" y2=\"%f\" style=\"stroke:#f00;\" />", r->points[i].x, r->points[i].y, r->points[i+1].x, r->points[i+1].y);
		fprintf(fp ,"<circle cx=\"%f\" cy=\"%f\" r=\"1\" style=\"fill:%s;\" />", r->points[i].x, r->points[i].y, r->points[i].flags == 0 ? "#f00" : "#0f0");
	}

	fprintf(fp, "</svg>");
	fclose(fp);
}
*/

void nsvgRasterize(NSVGrasterizer* r,
				   NSVGimage* image, float tx, float ty, float scale,
				   unsigned char* dst, int w, int h, int stride)
{
	NSVGshape *shape = NULL;
	NSVGedge *e = NULL;
	NSVGcachedPaint cache;
	int i;

	r->bitmap = dst;
	r->width = w;
	r->height = h;
	r->stride = stride;

	if (w > r->cscanline) {
		r->cscanline = w;
		r->scanline = (unsigned char*)realloc(r->scanline, w);
		if (r->scanline == NULL) return;
	}

	for (i = 0; i < h; i++)
		memset(&dst[i*stride], 0, w*4);

	for (shape = image->shapes; shape != NULL; shape = shape->next) {
		if (!(shape->flags & NSVG_FLAGS_VISIBLE))
			continue;

		if (shape->fill.type != NSVG_PAINT_NONE) {
			nsvg__resetPool(r);
			r->freelist = NULL;
			r->nedges = 0;

			nsvg__flattenShape(r, shape, scale);

			// Scale and translate edges
			for (i = 0; i < r->nedges; i++) {
				e = &r->edges[i];
				e->x0 = tx + e->x0;
				e->y0 = (ty + e->y0) * NSVG__SUBSAMPLES;
				e->x1 = tx + e->x1;
				e->y1 = (ty + e->y1) * NSVG__SUBSAMPLES;
			}

			// Rasterize edges
			qsort(r->edges, r->nedges, sizeof(NSVGedge), nsvg__cmpEdge);

			// now, traverse the scanlines and find the intersections on each scanline, use non-zero rule
			nsvg__initPaint(&cache, &shape->fill, shape->opacity);

			nsvg__rasterizeSortedEdges(r, tx,ty,scale, &cache, shape->fillRule);
		}
		if (shape->stroke.type != NSVG_PAINT_NONE && (shape->strokeWidth * scale) > 0.01f) {
			nsvg__resetPool(r);
			r->freelist = NULL;
			r->nedges = 0;

			nsvg__flattenShapeStroke(r, shape, scale);

//			dumpEdges(r, "edge.svg");

			// Scale and translate edges
			for (i = 0; i < r->nedges; i++) {
				e = &r->edges[i];
				e->x0 = tx + e->x0;
				e->y0 = (ty + e->y0) * NSVG__SUBSAMPLES;
				e->x1 = tx + e->x1;
				e->y1 = (ty + e->y1) * NSVG__SUBSAMPLES;
			}

			// Rasterize edges
			qsort(r->edges, r->nedges, sizeof(NSVGedge), nsvg__cmpEdge);

			// now, traverse the scanlines and find the intersections on each scanline, use non-zero rule
			nsvg__initPaint(&cache, &shape->stroke, shape->opacity);

			nsvg__rasterizeSortedEdges(r, tx,ty,scale, &cache, NSVG_FILLRULE_NONZERO);
		}
	}

	nsvg__unpremultiplyAlpha(dst, w, h, stride);

	r->bitmap = NULL;
	r->width = 0;
	r->height = 0;
	r->stride = 0;
}

#endif

```

`ext/pix/PIXEvents.h`:

```h
// Copyright (c) Microsoft Corporation. All rights reserved.

/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       PIXEvents.h
 *  Content:    PIX include file
 *              Don't include this file directly - use pix3.h
 *
 ****************************************************************************/
#pragma once

#ifndef _PixEvents_H_
#define _PixEvents_H_

#ifndef _PIX3_H_
# error Do not include this file directly - use pix3.h
#endif

#include "PIXEventsCommon.h"

#if _MSC_VER < 1800
# error This version of pix3.h is only supported on Visual Studio 2013 or higher
#elif _MSC_VER < 1900
# ifndef constexpr // Visual Studio 2013 doesn't support constexpr
#  define constexpr
#  define PIX3__DEFINED_CONSTEXPR
# endif
#endif

// Xbox does not support CPU events for retail scenarios
#if defined(USE_PIX) || !defined(PIX_XBOX)
#define PIX_CONTEXT_EMIT_CPU_EVENTS
#endif

namespace PIXEventsDetail
{
    template<typename... ARGS>
    struct PIXEventTypeInferer
    {
        static constexpr PIXEventType Begin() { return PIXEvent_BeginEvent_VarArgs; }
        static constexpr PIXEventType SetMarker() { return PIXEvent_SetMarker_VarArgs; }
        static constexpr PIXEventType BeginOnContext() { return PIXEvent_BeginEvent_OnContext_VarArgs; }
        static constexpr PIXEventType SetMarkerOnContext() { return PIXEvent_SetMarker_OnContext_VarArgs; }

        // Xbox and Windows store different types of events for context events.
        // On Xbox these include a context argument, while on Windows they do
        // not. It is important not to change the event types used on the
        // Windows version as there are OS components (eg debug layer & DRED)
        // that decode event structs.
#ifdef PIX_XBOX
        static constexpr PIXEventType GpuBeginOnContext() { return PIXEvent_BeginEvent_OnContext_VarArgs; }
        static constexpr PIXEventType GpuSetMarkerOnContext() { return PIXEvent_SetMarker_OnContext_VarArgs; }
#else
        static constexpr PIXEventType GpuBeginOnContext() { return PIXEvent_BeginEvent_VarArgs; }
        static constexpr PIXEventType GpuSetMarkerOnContext() { return PIXEvent_SetMarker_VarArgs; }
#endif
    };

    template<>
    struct PIXEventTypeInferer<void>
    {
        static constexpr PIXEventType Begin() { return PIXEvent_BeginEvent_NoArgs; }
        static constexpr PIXEventType SetMarker() { return PIXEvent_SetMarker_NoArgs; }
        static constexpr PIXEventType BeginOnContext() { return PIXEvent_BeginEvent_OnContext_NoArgs; }
        static constexpr PIXEventType SetMarkerOnContext() { return PIXEvent_SetMarker_OnContext_NoArgs; }

#ifdef PIX_XBOX
        static constexpr PIXEventType GpuBeginOnContext() { return PIXEvent_BeginEvent_OnContext_NoArgs; }
        static constexpr PIXEventType GpuSetMarkerOnContext() { return PIXEvent_SetMarker_OnContext_NoArgs; }
#else
        static constexpr PIXEventType GpuBeginOnContext() { return PIXEvent_BeginEvent_NoArgs; }
        static constexpr PIXEventType GpuSetMarkerOnContext() { return PIXEvent_SetMarker_NoArgs; }
#endif
    };

    inline void PIXCopyEventArguments(_Out_writes_to_ptr_(limit) UINT64*& destination, _In_ const UINT64* limit)
    {
        // nothing
        UNREFERENCED_PARAMETER(destination);
        UNREFERENCED_PARAMETER(limit);
    }

    template<typename ARG, typename... ARGS>
    void PIXCopyEventArguments(_Out_writes_to_ptr_(limit) UINT64*& destination, _In_ const UINT64* limit, ARG const& arg, ARGS const&... args)
    {
        PIXCopyEventArgument(destination, limit, arg);
        PIXCopyEventArguments(destination, limit, args...);
    }

    template<typename STR, typename... ARGS>
    __declspec(noinline) void PIXBeginEventAllocate(PIXEventsThreadInfo* threadInfo, UINT64 color, STR formatString, ARGS... args)
    {
#ifdef PIX_XBOX
        UINT64 time = PIXEventsReplaceBlock(false);
#else
        UINT64 time = PIXEventsReplaceBlock(threadInfo, false);
#endif
        if (!time)
            return;

        UINT64* destination = threadInfo->destination;
        UINT64* limit = threadInfo->biasedLimit;
        if (destination >= limit)
            return;

        limit += PIXEventsSafeFastCopySpaceQwords;
        *destination++ = PIXEncodeEventInfo(time, PIXEventTypeInferer<ARGS...>::Begin());
        *destination++ = color;

        PIXCopyEventArguments(destination, limit, formatString, args...);

        *destination = PIXEventsBlockEndMarker;
        threadInfo->destination = destination;
    }

    template<typename STR, typename... ARGS>
    void PIXBeginEvent(UINT64 color, STR formatString, ARGS... args)
    {
        PIXEventsThreadInfo* threadInfo = PIXGetThreadInfo();
        UINT64* limit = threadInfo->biasedLimit;
        if (limit != nullptr)
        {
            UINT64* destination = threadInfo->destination;
            if (destination < limit)
            {
                limit += PIXEventsSafeFastCopySpaceQwords;
                UINT64 time = PIXGetTimestampCounter();
                *destination++ = PIXEncodeEventInfo(time, PIXEventTypeInferer<ARGS...>::Begin());
                *destination++ = color;

                PIXCopyEventArguments(destination, limit, formatString, args...);

                *destination = PIXEventsBlockEndMarker;
                threadInfo->destination = destination;
            }
            else
            {
                PIXBeginEventAllocate(threadInfo, color, formatString, args...);
            }
        }
    }

    template<typename STR, typename... ARGS>
    __declspec(noinline) void PIXSetMarkerAllocate(PIXEventsThreadInfo* threadInfo, UINT64 color, STR formatString, ARGS... args)
    {
#ifdef PIX_XBOX
        UINT64 time = PIXEventsReplaceBlock(false);
#else
        UINT64 time = PIXEventsReplaceBlock(threadInfo, false);
#endif
        if (!time)
            return;

        UINT64* destination = threadInfo->destination;
        UINT64* limit = threadInfo->biasedLimit;

        if (destination >= limit)
            return;

        limit += PIXEventsSafeFastCopySpaceQwords;
        *destination++ = PIXEncodeEventInfo(time, PIXEventTypeInferer<ARGS...>::SetMarker());
        *destination++ = color;

        PIXCopyEventArguments(destination, limit, formatString, args...);

        *destination = PIXEventsBlockEndMarker;
        threadInfo->destination = destination;
    }

    template<typename STR, typename... ARGS>
    void PIXSetMarker(UINT64 color, STR formatString, ARGS... args)
    {
        PIXEventsThreadInfo* threadInfo = PIXGetThreadInfo();
        UINT64* limit = threadInfo->biasedLimit;
        if (limit != nullptr)
        {
            UINT64* destination = threadInfo->destination;
            if (destination < limit)
            {
                limit += PIXEventsSafeFastCopySpaceQwords;
                UINT64 time = PIXGetTimestampCounter();
                *destination++ = PIXEncodeEventInfo(time, PIXEventTypeInferer<ARGS...>::SetMarker());
                *destination++ = color;

                PIXCopyEventArguments(destination, limit, formatString, args...);

                *destination = PIXEventsBlockEndMarker;
                threadInfo->destination = destination;
            }
            else
            {
                PIXSetMarkerAllocate(threadInfo, color, formatString, args...);
            }
        }
    }

    template<typename STR, typename... ARGS>
    __declspec(noinline) void PIXBeginEventOnContextCpuAllocate(PIXEventsThreadInfo* threadInfo, void* context, UINT64 color, STR formatString, ARGS... args)
    {
#ifdef PIX_XBOX
        UINT64 time = PIXEventsReplaceBlock(false);
#else
        UINT64 time = PIXEventsReplaceBlock(threadInfo, false);
#endif
        if (!time)
            return;

        UINT64* destination = threadInfo->destination;
        UINT64* limit = threadInfo->biasedLimit;

        if (destination >= limit)
            return;

        limit += PIXEventsSafeFastCopySpaceQwords;
        *destination++ = PIXEncodeEventInfo(time, PIXEventTypeInferer<ARGS...>::BeginOnContext());
        *destination++ = color;

#ifdef PIX_XBOX
        UNREFERENCED_PARAMETER(context);
        PIXCopyEventArguments(destination, limit, formatString, args...);
#else
        PIXCopyEventArguments(destination, limit, context, formatString, args...);
#endif

        *destination = PIXEventsBlockEndMarker;
        threadInfo->destination = destination;
    }

    template<typename STR, typename... ARGS>
    void PIXBeginEventOnContextCpu(void* context, UINT64 color, STR formatString, ARGS... args)
    {
        PIXEventsThreadInfo* threadInfo = PIXGetThreadInfo();
        UINT64* limit = threadInfo->biasedLimit;
        if (limit != nullptr)
        {
            UINT64* destination = threadInfo->destination;
            if (destination < limit)
            {
                limit += PIXEventsSafeFastCopySpaceQwords;
                UINT64 time = PIXGetTimestampCounter();
                *destination++ = PIXEncodeEventInfo(time, PIXEventTypeInferer<ARGS...>::BeginOnContext());
                *destination++ = color;

#ifdef PIX_XBOX
                PIXCopyEventArguments(destination, limit, formatString, args...);
#else
                PIXCopyEventArguments(destination, limit, context, formatString, args...);
#endif

                *destination = PIXEventsBlockEndMarker;
                threadInfo->destination = destination;
            }
            else
            {
                PIXBeginEventOnContextCpuAllocate(threadInfo, context, color, formatString, args...);
            }
        }
    }

    template<typename CONTEXT, typename STR, typename... ARGS>
    void PIXBeginEvent(CONTEXT* context, UINT64 color, STR formatString, ARGS... args)
    {
#ifdef PIX_CONTEXT_EMIT_CPU_EVENTS
        PIXBeginEventOnContextCpu(context, color, formatString, args...);
#endif

        // TODO: we've already encoded this once for the CPU event - figure out way to avoid doing it again
        UINT64 buffer[PIXEventsGraphicsRecordSpaceQwords];
        UINT64* destination = buffer;
        UINT64* limit = buffer + PIXEventsGraphicsRecordSpaceQwords - PIXEventsReservedTailSpaceQwords;

        *destination++ = PIXEncodeEventInfo(0, PIXEventTypeInferer<ARGS...>::GpuBeginOnContext());
        *destination++ = color;

        PIXCopyEventArguments(destination, limit, formatString, args...);
        *destination = 0ull;

        PIXBeginGPUEventOnContext(context, static_cast<void*>(buffer), static_cast<UINT>(reinterpret_cast<BYTE*>(destination) - reinterpret_cast<BYTE*>(buffer)));
    }

    template<typename STR, typename... ARGS>
    __declspec(noinline) void PIXSetMarkerOnContextCpuAllocate(PIXEventsThreadInfo* threadInfo, void* context, UINT64 color, STR formatString, ARGS... args)
    {
#ifdef PIX_XBOX
        UINT64 time = PIXEventsReplaceBlock(false);
#else
        UINT64 time = PIXEventsReplaceBlock(threadInfo, false);
#endif
        if (!time)
            return;

        UINT64* destination = threadInfo->destination;
        UINT64* limit = threadInfo->biasedLimit;

        if (destination >= limit)
            return;

        limit += PIXEventsSafeFastCopySpaceQwords;
        *destination++ = PIXEncodeEventInfo(time, PIXEventTypeInferer<ARGS...>::SetMarkerOnContext());
        *destination++ = color;

#ifdef PIX_XBOX
        UNREFERENCED_PARAMETER(context);
        PIXCopyEventArguments(destination, limit, formatString, args...);
#else
        PIXCopyEventArguments(destination, limit, context, formatString, args...);
#endif

        *destination = PIXEventsBlockEndMarker;
        threadInfo->destination = destination;
    }

    template<typename STR, typename... ARGS>
    void PIXSetMarkerOnContextCpu(void* context, UINT64 color, STR formatString, ARGS... args)
    {
        PIXEventsThreadInfo* threadInfo = PIXGetThreadInfo();
        UINT64* limit = threadInfo->biasedLimit;
        if (limit != nullptr)
        {
            UINT64* destination = threadInfo->destination;
            if (destination < limit)
            {
                limit += PIXEventsSafeFastCopySpaceQwords;
                UINT64 time = PIXGetTimestampCounter();
                *destination++ = PIXEncodeEventInfo(time, PIXEventTypeInferer<ARGS...>::SetMarkerOnContext());
                *destination++ = color;

#ifdef PIX_XBOX
                PIXCopyEventArguments(destination, limit, formatString, args...);
#else
                PIXCopyEventArguments(destination, limit, context, formatString, args...);
#endif

                *destination = PIXEventsBlockEndMarker;
                threadInfo->destination = destination;
            }
            else
            {
                PIXSetMarkerOnContextCpuAllocate(threadInfo, context, color, formatString, args...);
            }
        }
    }

    template<typename CONTEXT, typename STR, typename... ARGS>
    void PIXSetMarker(CONTEXT* context, UINT64 color, STR formatString, ARGS... args)
    {
#ifdef PIX_CONTEXT_EMIT_CPU_EVENTS
        PIXSetMarkerOnContextCpu(context, color, formatString, args...);
#endif

        UINT64 buffer[PIXEventsGraphicsRecordSpaceQwords];
        UINT64* destination = buffer;
        UINT64* limit = buffer + PIXEventsGraphicsRecordSpaceQwords - PIXEventsReservedTailSpaceQwords;

        *destination++ = PIXEncodeEventInfo(0, PIXEventTypeInferer<ARGS...>::GpuSetMarkerOnContext());
        *destination++ = color;

        PIXCopyEventArguments(destination, limit, formatString, args...);
        *destination = 0ull;

        PIXSetGPUMarkerOnContext(context, static_cast<void*>(buffer), static_cast<UINT>(reinterpret_cast<BYTE*>(destination) - reinterpret_cast<BYTE*>(buffer)));
    }

    __declspec(noinline) inline void PIXEndEventAllocate(PIXEventsThreadInfo* threadInfo)
    {
#ifdef PIX_XBOX
        UINT64 time = PIXEventsReplaceBlock(true);
#else
        UINT64 time = PIXEventsReplaceBlock(threadInfo, true);
#endif
        if (!time)
            return;

        UINT64* destination = threadInfo->destination;
        UINT64* limit = threadInfo->biasedLimit;

        if (destination >= limit)
            return;

        limit += PIXEventsSafeFastCopySpaceQwords;
        *destination++ = PIXEncodeEventInfo(time, PIXEvent_EndEvent);
        *destination = PIXEventsBlockEndMarker;
        threadInfo->destination = destination;
    }

    inline void PIXEndEvent()
    {
        PIXEventsThreadInfo* threadInfo = PIXGetThreadInfo();
        UINT64* limit = threadInfo->biasedLimit;
        if (limit != nullptr)
        {
            UINT64* destination = threadInfo->destination;
            if (destination < limit)
            {
                limit += PIXEventsSafeFastCopySpaceQwords;
                UINT64 time = PIXGetTimestampCounter();
                *destination++ = PIXEncodeEventInfo(time, PIXEvent_EndEvent);
                *destination = PIXEventsBlockEndMarker;
                threadInfo->destination = destination;
            }
            else
            {
                PIXEndEventAllocate(threadInfo);
            }
        }
    }

    __declspec(noinline) inline void PIXEndEventOnContextCpuAllocate(PIXEventsThreadInfo* threadInfo, void* context)
    {
#ifdef PIX_XBOX
        UINT64 time = PIXEventsReplaceBlock(true);
#else
        UINT64 time = PIXEventsReplaceBlock(threadInfo, true);
#endif
        if (!time)
            return;

        UINT64* destination = threadInfo->destination;
        UINT64* limit = threadInfo->biasedLimit;

        if (destination >= limit)
            return;

        limit += PIXEventsSafeFastCopySpaceQwords;
        *destination++ = PIXEncodeEventInfo(time, PIXEvent_EndEvent_OnContext);
#ifdef PIX_XBOX
        UNREFERENCED_PARAMETER(context);
#else
        PIXCopyEventArgument(destination, limit, context);
#endif
        *destination = PIXEventsBlockEndMarker;
        threadInfo->destination = destination;
    }

    inline void PIXEndEventOnContextCpu(void* context)
    {
        PIXEventsThreadInfo* threadInfo = PIXGetThreadInfo();
        UINT64* limit = threadInfo->biasedLimit;
        if (limit != nullptr)
        {
            UINT64* destination = threadInfo->destination;
            if (destination < limit)
            {
                limit += PIXEventsSafeFastCopySpaceQwords;
                UINT64 time = PIXGetTimestampCounter();
                *destination++ = PIXEncodeEventInfo(time, PIXEvent_EndEvent_OnContext);
#ifndef PIX_XBOX
                PIXCopyEventArgument(destination, limit, context);
#endif
                *destination = PIXEventsBlockEndMarker;
                threadInfo->destination = destination;
            }
            else
            {
                PIXEndEventOnContextCpuAllocate(threadInfo, context);
            }
        }
    }

    template<typename CONTEXT>
    void PIXEndEvent(CONTEXT* context)
    {
#ifdef PIX_CONTEXT_EMIT_CPU_EVENTS
        PIXEndEventOnContextCpu(context);
#endif
        PIXEndGPUEventOnContext(context);
    }
}

#if defined(USE_PIX)

template<typename... ARGS>
void PIXBeginEvent(UINT64 color, PCWSTR formatString, ARGS... args)
{
    PIXEventsDetail::PIXBeginEvent(color, formatString, args...);
}

template<typename... ARGS>
void PIXBeginEvent(UINT64 color, PCSTR formatString, ARGS... args)
{
    PIXEventsDetail::PIXBeginEvent(color, formatString, args...);
}

template<typename... ARGS>
void PIXSetMarker(UINT64 color, PCWSTR formatString, ARGS... args)
{
    PIXEventsDetail::PIXSetMarker(color, formatString, args...);
}

template<typename... ARGS>
void PIXSetMarker(UINT64 color, PCSTR formatString, ARGS... args)
{
    PIXEventsDetail::PIXSetMarker(color, formatString, args...);
}

template<typename CONTEXT, typename... ARGS>
void PIXBeginEvent(CONTEXT* context, UINT64 color, PCWSTR formatString, ARGS... args)
{
    PIXEventsDetail::PIXBeginEvent(context, color, formatString, args...);
}

template<typename CONTEXT, typename... ARGS>
void PIXBeginEvent(CONTEXT* context, UINT64 color, PCSTR formatString, ARGS... args)
{
    PIXEventsDetail::PIXBeginEvent(context, color, formatString, args...);
}

template<typename CONTEXT, typename... ARGS>
void PIXSetMarker(CONTEXT* context, UINT64 color, PCWSTR formatString, ARGS... args)
{
    PIXEventsDetail::PIXSetMarker(context, color, formatString, args...);
}

template<typename CONTEXT, typename... ARGS>
void PIXSetMarker(CONTEXT* context, UINT64 color, PCSTR formatString, ARGS... args)
{
    PIXEventsDetail::PIXSetMarker(context, color, formatString, args...);
}

inline void PIXEndEvent()
{
    PIXEventsDetail::PIXEndEvent();
}

template<typename CONTEXT>
void PIXEndEvent(CONTEXT* context)
{
    PIXEventsDetail::PIXEndEvent(context);
}

#else // USE_PIX_RETAIL

inline void PIXBeginEvent(UINT64, _In_ PCSTR, ...) {}
inline void PIXBeginEvent(UINT64, _In_ PCWSTR, ...) {}
inline void PIXBeginEvent(void*, UINT64, _In_ PCSTR, ...) {}
inline void PIXBeginEvent(void*, UINT64, _In_ PCWSTR, ...) {}
inline void PIXEndEvent() {}
inline void PIXEndEvent(void*) {}
inline void PIXSetMarker(UINT64, _In_ PCSTR, ...) {}
inline void PIXSetMarker(UINT64, _In_ PCWSTR, ...) {}
inline void PIXSetMarker(void*, UINT64, _In_ PCSTR, ...) {}
inline void PIXSetMarker(void*, UINT64, _In_ PCWSTR, ...) {}

#endif // USE_PIX

template<typename CONTEXT, typename... ARGS>
void PIXBeginRetailEvent(CONTEXT* context, UINT64 color, PCWSTR formatString, ARGS... args)
{
    PIXEventsDetail::PIXBeginEvent(context, color, formatString, args...);
}

template<typename CONTEXT, typename... ARGS>
void PIXBeginRetailEvent(CONTEXT* context, UINT64 color, PCSTR formatString, ARGS... args)
{
    PIXEventsDetail::PIXBeginEvent(context, color, formatString, args...);
}

template<typename CONTEXT, typename... ARGS>
void PIXSetRetailMarker(CONTEXT* context, UINT64 color, PCWSTR formatString, ARGS... args)
{
    PIXEventsDetail::PIXSetMarker(context, color, formatString, args...);
}

template<typename CONTEXT, typename... ARGS>
void PIXSetRetailMarker(CONTEXT* context, UINT64 color, PCSTR formatString, ARGS... args)
{
    PIXEventsDetail::PIXSetMarker(context, color, formatString, args...);
}

template<typename CONTEXT>
void PIXEndRetailEvent(CONTEXT* context)
{
    PIXEventsDetail::PIXEndEvent(context);
}

template<typename CONTEXT>
class PIXScopedEventObject
{
    CONTEXT* m_context;

public:
    template<typename... ARGS>
    PIXScopedEventObject(CONTEXT* context, UINT64 color, PCWSTR formatString, ARGS... args)
        : m_context(context)
    {
        PIXBeginEvent(m_context, color, formatString, args...);
    }

    template<typename... ARGS>
    PIXScopedEventObject(CONTEXT* context, UINT64 color, PCSTR formatString, ARGS... args)
        : m_context(context)
    {
        PIXBeginEvent(m_context, color, formatString, args...);
    }

    ~PIXScopedEventObject()
    {
        PIXEndEvent(m_context);
    }
};

template<typename CONTEXT>
class PIXScopedRetailEventObject
{
    CONTEXT* m_context;

public:
    template<typename... ARGS>
    PIXScopedRetailEventObject(CONTEXT* context, UINT64 color, PCWSTR formatString, ARGS... args)
        : m_context(context)
    {
        PIXBeginRetailEvent(m_context, color, formatString, args...);
    }

    template<typename... ARGS>
    PIXScopedRetailEventObject(CONTEXT* context, UINT64 color, PCSTR formatString, ARGS... args)
        : m_context(context)
    {
        PIXBeginRetailEvent(m_context, color, formatString, args...);
    }

    ~PIXScopedRetailEventObject()
    {
        PIXEndRetailEvent(m_context);
    }
};

template<>
class PIXScopedEventObject<void>
{
public:
    template<typename... ARGS>
    PIXScopedEventObject(UINT64 color, PCWSTR formatString, ARGS... args)
    {
        PIXBeginEvent(color, formatString, args...);
    }

    template<typename... ARGS>
    PIXScopedEventObject(UINT64 color, PCSTR formatString, ARGS... args)
    {
        PIXBeginEvent(color, formatString, args...);
    }

    ~PIXScopedEventObject()
    {
        PIXEndEvent();
    }
};

#define PIXConcatenate(a, b) a ## b
#define PIXGetScopedEventVariableName(a, b) PIXConcatenate(a, b)
#define PIXScopedEvent(context, ...) PIXScopedEventObject<PIXInferScopedEventType<decltype(context)>::Type> PIXGetScopedEventVariableName(pixEvent, __LINE__)(context, __VA_ARGS__)

#ifdef PIX3__DEFINED_CONSTEXPR
#undef constexpr
#undef PIX3__DEFINED_CONSTEXPR
#endif

#endif // _PIXEvents_H__

```

`ext/pix/PIXEventsCommon.h`:

```h
// Copyright (c) Microsoft Corporation. All rights reserved.

/*==========================================================================;
*
*  Copyright (C) Microsoft Corporation.  All Rights Reserved.
*
*  File:       PIXEventsCommon.h
*  Content:    PIX include file
*              Don't include this file directly - use pix3.h
*
****************************************************************************/
#pragma once

#ifndef _PIXEventsCommon_H_
#define _PIXEventsCommon_H_

#if defined(XBOX) || defined(_XBOX_ONE) || defined(_DURANGO) || defined(_GAMING_XBOX) || defined(_GAMING_XBOX_SCARLETT)
#define PIX_XBOX
#endif

#include <cstdint>

#if defined(_M_X64) || defined(_M_IX86)
#include <emmintrin.h>
#endif

//
// The PIXBeginEvent and PIXSetMarker functions have an optimized path for
// copying strings that work by copying 128-bit or 64-bits at a time. In some
// circumstances this may result in PIX logging the remaining memory after the
// null terminator.
//
// By default this optimization is enabled unless Address Sanitizer is enabled,
// since this optimization can trigger a global-buffer-overflow when copying
// string literals.
//
// The PIX_ENABLE_BLOCK_ARGUMENT_COPY controls whether or not this optimization
// is enabled. Applications may also explicitly set this macro to 0 to disable
// the optimization if necessary.
//

// Check for Address Sanitizer on either Clang or MSVC

#if defined(__has_feature)
#if __has_feature(address_sanitizer)
#define PIX_ASAN_ENABLED
#endif
#elif defined(__SANITIZE_ADDRESS__)
#define PIX_ASAN_ENABLED
#endif

#if defined(PIX_ENABLE_BLOCK_ARGUMENT_COPY)
// Previously set values override everything
# define PIX_ENABLE_BLOCK_ARGUMENT_COPY_SET 0
#elif defined(PIX_ASAN_ENABLED)
// Disable block argument copy when address sanitizer is enabled
#define PIX_ENABLE_BLOCK_ARGUMENT_COPY 0
#define PIX_ENABLE_BLOCK_ARGUMENT_COPY_SET 1
#endif

#if !defined(PIX_ENABLE_BLOCK_ARGUMENT_COPY)
// Default to enabled.
#define PIX_ENABLE_BLOCK_ARGUMENT_COPY 1
#define PIX_ENABLE_BLOCK_ARGUMENT_COPY_SET 1
#endif

struct PIXEventsBlockInfo;

struct PIXEventsThreadInfo
{
    PIXEventsBlockInfo* block;
    UINT64* biasedLimit;
    UINT64* destination;
};

#ifdef PIX_XBOX
extern "C" UINT64 WINAPI PIXEventsReplaceBlock(bool getEarliestTime) noexcept;
#else
extern "C" UINT64 WINAPI PIXEventsReplaceBlock(PIXEventsThreadInfo * threadInfo, bool getEarliestTime) noexcept;
#endif

enum PIXEventType
{
    PIXEvent_EndEvent                       = 0x000,
    PIXEvent_BeginEvent_VarArgs             = 0x001,
    PIXEvent_BeginEvent_NoArgs              = 0x002,
    PIXEvent_SetMarker_VarArgs              = 0x007,
    PIXEvent_SetMarker_NoArgs               = 0x008,

    PIXEvent_EndEvent_OnContext             = 0x010,
    PIXEvent_BeginEvent_OnContext_VarArgs   = 0x011,
    PIXEvent_BeginEvent_OnContext_NoArgs    = 0x012,
    PIXEvent_SetMarker_OnContext_VarArgs    = 0x017,
    PIXEvent_SetMarker_OnContext_NoArgs     = 0x018,
};

static const UINT64 PIXEventsReservedRecordSpaceQwords = 64;
//this is used to make sure SSE string copy always will end 16-byte write in the current block
//this way only a check if destination < limit can be performed, instead of destination < limit - 1
//since both these are UINT64* and SSE writes in 16 byte chunks, 8 bytes are kept in reserve
//so even if SSE overwrites 8 extra bytes, those will still belong to the correct block
//on next iteration check destination will be greater than limit
//this is used as well for fixed size UMD events and PIXEndEvent since these require less space
//than other variable length user events and do not need big reserved space
static const UINT64 PIXEventsReservedTailSpaceQwords = 2;
static const UINT64 PIXEventsSafeFastCopySpaceQwords = PIXEventsReservedRecordSpaceQwords - PIXEventsReservedTailSpaceQwords;
static const UINT64 PIXEventsGraphicsRecordSpaceQwords = 64;

//Bits 7-19 (13 bits)
static const UINT64 PIXEventsBlockEndMarker     = 0x00000000000FFF80;

//Bits 10-19 (10 bits)
static const UINT64 PIXEventsTypeReadMask       = 0x00000000000FFC00;
static const UINT64 PIXEventsTypeWriteMask      = 0x00000000000003FF;
static const UINT64 PIXEventsTypeBitShift       = 10;

//Bits 20-63 (44 bits)
static const UINT64 PIXEventsTimestampReadMask  = 0xFFFFFFFFFFF00000;
static const UINT64 PIXEventsTimestampWriteMask = 0x00000FFFFFFFFFFF;
static const UINT64 PIXEventsTimestampBitShift  = 20;

inline UINT64 PIXEncodeEventInfo(UINT64 timestamp, PIXEventType eventType)
{
    return ((timestamp & PIXEventsTimestampWriteMask) << PIXEventsTimestampBitShift) |
        (((UINT64)eventType & PIXEventsTypeWriteMask) << PIXEventsTypeBitShift);
}

//Bits 60-63 (4)
static const UINT64 PIXEventsStringAlignmentWriteMask     = 0x000000000000000F;
static const UINT64 PIXEventsStringAlignmentReadMask      = 0xF000000000000000;
static const UINT64 PIXEventsStringAlignmentBitShift      = 60;

//Bits 55-59 (5)
static const UINT64 PIXEventsStringCopyChunkSizeWriteMask = 0x000000000000001F;
static const UINT64 PIXEventsStringCopyChunkSizeReadMask  = 0x0F80000000000000;
static const UINT64 PIXEventsStringCopyChunkSizeBitShift  = 55;

//Bit 54
static const UINT64 PIXEventsStringIsANSIWriteMask        = 0x0000000000000001;
static const UINT64 PIXEventsStringIsANSIReadMask         = 0x0040000000000000;
static const UINT64 PIXEventsStringIsANSIBitShift         = 54;

//Bit 53
static const UINT64 PIXEventsStringIsShortcutWriteMask    = 0x0000000000000001;
static const UINT64 PIXEventsStringIsShortcutReadMask     = 0x0020000000000000;
static const UINT64 PIXEventsStringIsShortcutBitShift     = 53;

inline UINT64 PIXEncodeStringInfo(UINT64 alignment, UINT64 copyChunkSize, BOOL isANSI, BOOL isShortcut)
{
    return ((alignment & PIXEventsStringAlignmentWriteMask) << PIXEventsStringAlignmentBitShift) |
        ((copyChunkSize & PIXEventsStringCopyChunkSizeWriteMask) << PIXEventsStringCopyChunkSizeBitShift) |
        (((UINT64)isANSI & PIXEventsStringIsANSIWriteMask) << PIXEventsStringIsANSIBitShift) |
        (((UINT64)isShortcut & PIXEventsStringIsShortcutWriteMask) << PIXEventsStringIsShortcutBitShift);
}

template<UINT alignment, class T>
inline bool PIXIsPointerAligned(T* pointer)
{
    return !(((UINT64)pointer) & (alignment - 1));
}

// Generic template version slower because of the additional clear write
template<class T>
inline void PIXCopyEventArgument(_Out_writes_to_ptr_(limit) UINT64*& destination, _In_ const UINT64* limit, T argument)
{
    if (destination < limit)
    {
        *destination = 0ull;
        *((T*)destination) = argument;
        ++destination;
    }
}

// int32 specialization to avoid slower double memory writes
template<>
inline void PIXCopyEventArgument<INT32>(_Out_writes_to_ptr_(limit) UINT64*& destination, _In_ const UINT64* limit, INT32 argument)
{
    if (destination < limit)
    {
        *reinterpret_cast<INT64*>(destination) = static_cast<INT64>(argument);
        ++destination;
    }
}

// unsigned int32 specialization to avoid slower double memory writes
template<>
inline void PIXCopyEventArgument<UINT32>(_Out_writes_to_ptr_(limit) UINT64*& destination, _In_ const UINT64* limit, UINT32 argument)
{
    if (destination < limit)
    {
        *destination = static_cast<UINT64>(argument);
        ++destination;
    }
}

// int64 specialization to avoid slower double memory writes
template<>
inline void PIXCopyEventArgument<INT64>(_Out_writes_to_ptr_(limit) UINT64*& destination, _In_ const UINT64* limit, INT64 argument)
{
    if (destination < limit)
    {
        *reinterpret_cast<INT64*>(destination) = argument;
        ++destination;
    }
}

// unsigned int64 specialization to avoid slower double memory writes
template<>
inline void PIXCopyEventArgument<UINT64>(_Out_writes_to_ptr_(limit) UINT64*& destination, _In_ const UINT64* limit, UINT64 argument)
{
    if (destination < limit)
    {
        *destination = argument;
        ++destination;
    }
}

//floats must be cast to double during writing the data to be properly printed later when reading the data
//this is needed because when float is passed to varargs function it's cast to double
template<>
inline void PIXCopyEventArgument<float>(_Out_writes_to_ptr_(limit) UINT64*& destination, _In_ const UINT64* limit, float argument)
{
    if (destination < limit)
    {
        *reinterpret_cast<double*>(destination) = static_cast<double>(argument);
        ++destination;
    }
}

//char has to be cast to a longer signed integer type
//this is due to printf not ignoring correctly the upper bits of unsigned long long for a char format specifier
template<>
inline void PIXCopyEventArgument<char>(_Out_writes_to_ptr_(limit) UINT64*& destination, _In_ const UINT64* limit, char argument)
{
    if (destination < limit)
    {
        *reinterpret_cast<INT64*>(destination) = static_cast<INT64>(argument);
        ++destination;
    }
}

//unsigned char has to be cast to a longer unsigned integer type
//this is due to printf not ignoring correctly the upper bits of unsigned long long for a char format specifier
template<>
inline void PIXCopyEventArgument<unsigned char>(_Out_writes_to_ptr_(limit) UINT64*& destination, _In_ const UINT64* limit, unsigned char argument)
{
    if (destination < limit)
    {
        *destination = static_cast<UINT64>(argument);
        ++destination;
    }
}

//bool has to be cast to an integer since it's not explicitly supported by string format routines
//there's no format specifier for bool type, but it should work with integer format specifiers
template<>
inline void PIXCopyEventArgument<bool>(_Out_writes_to_ptr_(limit) UINT64*& destination, _In_ const UINT64* limit, bool argument)
{
    if (destination < limit)
    {
        *destination = static_cast<UINT64>(argument);
        ++destination;
    }
}

inline void PIXCopyEventArgumentSlowest(_Out_writes_to_ptr_(limit) UINT64*& destination, _In_ const UINT64* limit, _In_ PCSTR argument)
{
    *destination++ = PIXEncodeStringInfo(0, 8, TRUE, FALSE);
    while (destination < limit)
    {
        UINT64 c = static_cast<uint8_t>(argument[0]);
        if (!c)
        {
            *destination++ = 0;
            return;
        }
        UINT64 x = c;
        c = static_cast<uint8_t>(argument[1]);
        if (!c)
        {
            *destination++ = x;
            return;
        }
        x |= c << 8;
        c = static_cast<uint8_t>(argument[2]);
        if (!c)
        {
            *destination++ = x;
            return;
        }
        x |= c << 16;
        c = static_cast<uint8_t>(argument[3]);
        if (!c)
        {
            *destination++ = x;
            return;
        }
        x |= c << 24;
        c = static_cast<uint8_t>(argument[4]);
        if (!c)
        {
            *destination++ = x;
            return;
        }
        x |= c << 32;
        c = static_cast<uint8_t>(argument[5]);
        if (!c)
        {
            *destination++ = x;
            return;
        }
        x |= c << 40;
        c = static_cast<uint8_t>(argument[6]);
        if (!c)
        {
            *destination++ = x;
            return;
        }
        x |= c << 48;
        c = static_cast<uint8_t>(argument[7]);
        if (!c)
        {
            *destination++ = x;
            return;
        }
        x |= c << 56;
        *destination++ = x;
        argument += 8;
    }
}

inline void PIXCopyEventArgumentSlow(_Out_writes_to_ptr_(limit) UINT64*& destination, _In_ const UINT64* limit, _In_ PCSTR argument)
{
#if PIX_ENABLE_BLOCK_ARGUMENT_COPY
    if (PIXIsPointerAligned<8>(argument))
    {
        *destination++ = PIXEncodeStringInfo(0, 8, TRUE, FALSE);
        UINT64* source = (UINT64*)argument;
        while (destination < limit)
        {
            UINT64 qword = *source++;
            *destination++ = qword;
            //check if any of the characters is a terminating zero
            if (!((qword & 0xFF00000000000000) &&
                (qword & 0xFF000000000000) &&
                (qword & 0xFF0000000000) &&
                (qword & 0xFF00000000) &&
                (qword & 0xFF000000) &&
                (qword & 0xFF0000) &&
                (qword & 0xFF00) &&
                (qword & 0xFF)))
            {
                break;
            }
        }
    }
    else
#endif // PIX_ENABLE_BLOCK_ARGUMENT_COPY
    {
        PIXCopyEventArgumentSlowest(destination, limit, argument);
    }
}

template<>
inline void PIXCopyEventArgument<PCSTR>(_Out_writes_to_ptr_(limit) UINT64*& destination, _In_ const UINT64* limit, _In_ PCSTR argument)
{
    if (destination < limit)
    {
        if (argument != nullptr)
        {
#if (defined(_M_X64) || defined(_M_IX86)) && PIX_ENABLE_BLOCK_ARGUMENT_COPY
            if (PIXIsPointerAligned<16>(argument))
            {
                *destination++ = PIXEncodeStringInfo(0, 16, TRUE, FALSE);
                __m128i zero = _mm_setzero_si128();
                if (PIXIsPointerAligned<16>(destination))
                {
                    while (destination < limit)
                    {
                        __m128i mem = _mm_load_si128((__m128i*)argument);
                        _mm_store_si128((__m128i*)destination, mem);
                        //check if any of the characters is a terminating zero
                        __m128i res = _mm_cmpeq_epi8(mem, zero);
                        destination += 2;
                        if (_mm_movemask_epi8(res))
                            break;
                        argument += 16;
                    }
                }
                else
                {
                    while (destination < limit)
                    {
                        __m128i mem = _mm_load_si128((__m128i*)argument);
                        _mm_storeu_si128((__m128i*)destination, mem);
                        //check if any of the characters is a terminating zero
                        __m128i res = _mm_cmpeq_epi8(mem, zero);
                        destination += 2;
                        if (_mm_movemask_epi8(res))
                            break;
                        argument += 16;
                    }
                }
            }
            else
#endif // (defined(_M_X64) || defined(_M_IX86)) && PIX_ENABLE_BLOCK_ARGUMENT_COPY
            {
                PIXCopyEventArgumentSlow(destination, limit, argument);
            }
        }
        else
        {
            *destination++ = 0ull;
        }
    }
}

template<>
inline void PIXCopyEventArgument<PSTR>(_Out_writes_to_ptr_(limit) UINT64*& destination, _In_ const UINT64* limit, _In_ PSTR argument)
{
    PIXCopyEventArgument(destination, limit, (PCSTR)argument);
}

inline void PIXCopyEventArgumentSlowest(_Out_writes_to_ptr_(limit) UINT64*& destination, _In_ const UINT64* limit, _In_ PCWSTR argument)
{
    *destination++ = PIXEncodeStringInfo(0, 8, FALSE, FALSE);
    while (destination < limit)
    {
        UINT64 c = static_cast<uint16_t>(argument[0]);
        if (!c)
        {
            *destination++ = 0;
            return;
        }
        UINT64 x = c;
        c = static_cast<uint16_t>(argument[1]);
        if (!c)
        {
            *destination++ = x;
            return;
        }
        x |= c << 16;
        c = static_cast<uint16_t>(argument[2]);
        if (!c)
        {
            *destination++ = x;
            return;
        }
        x |= c << 32;
        c = static_cast<uint16_t>(argument[3]);
        if (!c)
        {
            *destination++ = x;
            return;
        }
        x |= c << 48;
        *destination++ = x;
        argument += 4;
    }
}

inline void PIXCopyEventArgumentSlow(_Out_writes_to_ptr_(limit) UINT64*& destination, _In_ const UINT64* limit, _In_ PCWSTR argument)
{
#if PIX_ENABLE_BLOCK_ARGUMENT_COPY
    if (PIXIsPointerAligned<8>(argument))
    {
        *destination++ = PIXEncodeStringInfo(0, 8, FALSE, FALSE);
        UINT64* source = (UINT64*)argument;
        while (destination < limit)
        {
            UINT64 qword = *source++;
            *destination++ = qword;
            //check if any of the characters is a terminating zero
            //TODO: check if reversed condition is faster
            if (!((qword & 0xFFFF000000000000) &&
                (qword & 0xFFFF00000000) &&
                (qword & 0xFFFF0000) &&
                (qword & 0xFFFF)))
            {
                break;
            }
        }
    }
    else
#endif // PIX_ENABLE_BLOCK_ARGUMENT_COPY
    {
        PIXCopyEventArgumentSlowest(destination, limit, argument);
    }
}

template<>
inline void PIXCopyEventArgument<PCWSTR>(_Out_writes_to_ptr_(limit) UINT64*& destination, _In_ const UINT64* limit, _In_ PCWSTR argument)
{
    if (destination < limit)
    {
        if (argument != nullptr)
        {
#if (defined(_M_X64) || defined(_M_IX86)) && PIX_ENABLE_BLOCK_ARGUMENT_COPY
            if (PIXIsPointerAligned<16>(argument))
            {
                *destination++ = PIXEncodeStringInfo(0, 16, FALSE, FALSE);
                __m128i zero = _mm_setzero_si128();
                if (PIXIsPointerAligned<16>(destination))
                {
                    while (destination < limit)
                    {
                        __m128i mem = _mm_load_si128((__m128i*)argument);
                        _mm_store_si128((__m128i*)destination, mem);
                        //check if any of the characters is a terminating zero
                        __m128i res = _mm_cmpeq_epi16(mem, zero);
                        destination += 2;
                        if (_mm_movemask_epi8(res))
                            break;
                        argument += 8;
                    }
                }
                else
                {
                    while (destination < limit)
                    {
                        __m128i mem = _mm_load_si128((__m128i*)argument);
                        _mm_storeu_si128((__m128i*)destination, mem);
                        //check if any of the characters is a terminating zero
                        __m128i res = _mm_cmpeq_epi16(mem, zero);
                        destination += 2;
                        if (_mm_movemask_epi8(res))
                            break;
                        argument += 8;
                    }
                }
            }
            else
#endif // (defined(_M_X64) || defined(_M_IX86)) && PIX_ENABLE_BLOCK_ARGUMENT_COPY
            {
                PIXCopyEventArgumentSlow(destination, limit, argument);
            }
        }
        else
        {
            *destination++ = 0ull;
        }
    }
}

template<>
inline void PIXCopyEventArgument<PWSTR>(_Out_writes_to_ptr_(limit) UINT64*& destination, _In_ const UINT64* limit, _In_ PWSTR argument)
{
    PIXCopyEventArgument(destination, limit, (PCWSTR)argument);
};

#if defined(__d3d12_x_h__) || defined(__d3d12_xs_h__) || defined(__d3d12_h__)

inline void PIXSetGPUMarkerOnContext(_In_ ID3D12GraphicsCommandList* commandList, _In_reads_bytes_(size) void* data, UINT size)
{
    commandList->SetMarker(D3D12_EVENT_METADATA, data, size);
}

inline void PIXSetGPUMarkerOnContext(_In_ ID3D12CommandQueue* commandQueue, _In_reads_bytes_(size) void* data, UINT size)
{
    commandQueue->SetMarker(D3D12_EVENT_METADATA, data, size);
}

inline void PIXBeginGPUEventOnContext(_In_ ID3D12GraphicsCommandList* commandList, _In_reads_bytes_(size) void* data, UINT size)
{
    commandList->BeginEvent(D3D12_EVENT_METADATA, data, size);
}

inline void PIXBeginGPUEventOnContext(_In_ ID3D12CommandQueue* commandQueue, _In_reads_bytes_(size) void* data, UINT size)
{
    commandQueue->BeginEvent(D3D12_EVENT_METADATA, data, size);
}

inline void PIXEndGPUEventOnContext(_In_ ID3D12GraphicsCommandList* commandList)
{
    commandList->EndEvent();
}

inline void PIXEndGPUEventOnContext(_In_ ID3D12CommandQueue* commandQueue)
{
    commandQueue->EndEvent();
}

#endif //__d3d12_h__

template<class T> struct PIXInferScopedEventType { typedef T Type; };
template<class T> struct PIXInferScopedEventType<const T> { typedef T Type; };
template<class T> struct PIXInferScopedEventType<T*> { typedef T Type; };
template<class T> struct PIXInferScopedEventType<T* const> { typedef T Type; };
template<> struct PIXInferScopedEventType<UINT64> { typedef void Type; };
template<> struct PIXInferScopedEventType<const UINT64> { typedef void Type; };
template<> struct PIXInferScopedEventType<INT64> { typedef void Type; };
template<> struct PIXInferScopedEventType<const INT64> { typedef void Type; };
template<> struct PIXInferScopedEventType<UINT> { typedef void Type; };
template<> struct PIXInferScopedEventType<const UINT> { typedef void Type; };
template<> struct PIXInferScopedEventType<INT> { typedef void Type; };
template<> struct PIXInferScopedEventType<const INT> { typedef void Type; };


#if PIX_ENABLE_BLOCK_ARGUMENT_COPY_SET
#undef PIX_ENABLE_BLOCK_ARGUMENT_COPY
#endif

#undef PIX_ENABLE_BLOCK_ARGUMENT_COPY_SET

#endif //_PIXEventsCommon_H_

```

`ext/pix/ThirdPartyNotices.txt`:

```txt
THIRD-PARTY SOFTWARE NOTICES AND INFORMATION

Note: While Microsoft is not the author of the files below, Microsoft is
offering you a license subject to the terms of the Microsoft Software License
Terms for Microsoft PIX Developer Tool (the "Microsoft Program"). Microsoft
reserves all other rights. The notices below are provided for informational
purposes only and are not the license terms under which Microsoft distributes
these files.

The Microsoft Program includes the following third-party software:

1. Boost v. 1.66.0 (https://sourceforge.net/projects/boost/files/boost/1.66.0)
2. fmt v4.1.0 (https://github.com/fmtlib/fmt/releases/tag/4.1.0)
3. SQLite 3 (http://www.sqlite.org/)
4. AMD PIX Plugin
5. nlohmann JSON (https://github.com/nlohmann/json)
6. PresentMon (https://github.com/GameTechDev/PresentMon)
7. DirectXTex (https://github.com/microsoft/directxtex)
8. DirectXTK12 (https://github.com/microsoft/DirectXTK12)
9. Guidelines Support Library (GSL) (https://github.com/microsoft/GSL)
10. Windows Implementation Library (WIL) (https://github.com/microsoft/wil)
11. GoogleTest (https://github.com/google/googletest/)
12. Newtonsoft.Json (https://www.newtonsoft.com/json)
13. WIX (https://wixtoolset.org/)

As the recipient of the above third-party software, Microsoft sets forth a copy
of the notices and other information below.


BOOST NOTICES AND INFORMATION BEGIN HERE
========================================

Boost v. 1.66.0
Copyright Beman Dawes, David Abrahams, 1998-2005
Copyright Rene Rivera 2006-2007
Provided for Informational Purposes Only
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by this
license (the "Software") to use, reproduce, display, distribute, execute, and
transmit the Software, and to prepare derivative works of the Software, and to
permit third-parties to whom the Software is furnished to do so, all subject to
the following:

The copyright notices in the Software and this entire statement, including the
above license grant, this restriction and the following disclaimer, must be
included in all copies of the Software, in whole or in part, and all derivative
works of the Software, unless such copies or derivative works are solely in the
form of machine-executable object code generated by a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY
DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE

END OF BOOST NOTICES AND INFORMATION
====================================

FMT NOTICES AND INFORMATION BEGIN HERE
======================================

fmt v4.1.0
Copyright (c) 2012 - 2016, Victor Zverovich
Provided for Informational Purposes Only
BSD 2-clause


Copyright (c) 2012 - 2016, Victor Zverovich

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

END OF FMT NOTICES AND INFORMATION
==================================

SQLITE3 NOTICES AND INFORMATION BEGIN HERE
==========================================

https://www.sqlite.org/copyright.html
SQLite Is Public Domain

All of the code and documentation in SQLite has been dedicated to the public
domain by the authors. All code authors, and representatives of the companies
they work for, have signed affidavits dedicating their contributions to the
public domain and originals of those signed affidavits are stored in a firesafe
at the main offices of Hwaci. Anyone is free to copy, modify, publish, use,
compile, sell, or distribute the original SQLite code, either in source code
form or as a compiled binary, for any purpose, commercial or non-commercial, and
by any means.

The previous paragraph applies to the deliverable code and documentation in SQLite -
those parts of the SQLite library that you actually bundle and ship with a larger
application. Some scripts used as part of the build process (for example the "configure"
scripts generated by autoconf) might fall under other open-source licenses. Nothing
from these build scripts ever reaches the final deliverable SQLite library, however,
and so the licenses associated with those scripts should not be a factor in assessing
your rights to copy and use the SQLite library.

All of the deliverable code in SQLite has been written from scratch. No code has been
taken from other projects or from the open internet. Every line of code can be traced
back to its original author, and all of those authors have public domain dedications
on file. So the SQLite code base is clean and is uncontaminated with licensed code
from other projects.

END OF SQLITE3 NOTICES AND INFORMATION
======================================

AMD NOTICES AND INFORMATION BEGIN HERE
======================================

AMD copyrighted code (MIT) 
Copyright (c) 2016-2021 Advanced Micro Devices, Inc. All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

END OF AMD NOTICES AND INFORMATION
==================================

NLOHMANN JSON NOTICES AND INFORMATION BEGIN HERE
======================================

MIT License 

Copyright (c) 2013-2021 Niels Lohmann

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

END OF NLOHMANN JSON NOTICES AND INFORMATION
==================================

PRESENTMON NOTICES AND INFORMATION BEGIN HERE
======================================

Copyright 2017 Intel Corporation

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

END OF PRESENTMON NOTICES AND INFORMATION
==================================

DIRECTXTEX NOTICES AND INFORMATION BEGIN HERE
======================================

Copyright (c) 2011-2021 Microsoft Corp

Permission is hereby granted, free of charge, to any person obtaining a copy of this
software and associated documentation files (the "Software"), to deal in the Software
without restriction, including without limitation the rights to use, copy, modify,
merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be included in all copies
or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

END OF DIRECTXTEX NOTICES AND INFORMATION
==================================

DIRECTXTK12 NOTICES AND INFORMATION BEGIN HERE
======================================

Copyright (c) 2016-2021 Microsoft Corp

Permission is hereby granted, free of charge, to any person obtaining a copy of this
software and associated documentation files (the "Software"), to deal in the Software
without restriction, including without limitation the rights to use, copy, modify,
merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be included in all copies
or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

END OF DIRECTXTK12 NOTICES AND INFORMATION
==================================

GSL NOTICES AND INFORMATION BEGIN HERE
======================================

Copyright (c) 2015 Microsoft Corporation. All rights reserved. 
 
This code is licensed under the MIT License (MIT). 

Permission is hereby granted, free of charge, to any person obtaining a copy 
of this software and associated documentation files (the "Software"), to deal 
in the Software without restriction, including without limitation the rights 
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies 
of the Software, and to permit persons to whom the Software is furnished to do 
so, subject to the following conditions: 

The above copyright notice and this permission notice shall be included in all 
copies or substantial portions of the Software. 

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN 
THE SOFTWARE. 

END OF GSL NOTICES AND INFORMATION
==================================

WIL NOTICES AND INFORMATION BEGIN HERE
======================================
MIT License

Copyright (c) Microsoft Corporation. All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE

END OF WIL NOTICES AND INFORMATION
==================================

GOOGLETEST NOTICES AND INFORMATION BEGIN HERE
======================================
Copyright 2008, Google Inc.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following disclaimer
in the documentation and/or other materials provided with the
distribution.
    * Neither the name of Google Inc. nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

END OF GOOGLETEST NOTICES AND INFORMATION
==================================

NEWTONSOFT.JSON NOTICES AND INFORMATION BEGIN HERE
======================================
The MIT License (MIT)

Copyright (c) 2007 James Newton-King

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

END OF NEWTONSOFT.JSON NOTICES AND INFORMATION
=================================

WIX NOTICES AND INFORMATION BEGIN HERE
======================================
Copyright (c) .NET Foundation and contributors. This software is released under
the Microsoft Reciprocal License (MS-RL) (the "License"); you may not use the
software except in compliance with the License.

The text of the Microsoft Reciprocal License (MS-RL) can be found online at:
http://opensource.org/licenses/ms-rl


Microsoft Reciprocal License (MS-RL)

This license governs use of the accompanying software. If you use the software,
you accept this license. If you do not accept the license, do not use the
software.

1. Definitions The terms "reproduce," "reproduction," "derivative works," and
"distribution" have the same meaning here as under U.S. copyright law. A
"contribution" is the original software, or any additions or changes to the
software. A "contributor" is any person that distributes its contribution under
this license. "Licensed patents" are a contributor's patent claims that read
directly on its contribution.

2. Grant of Rights (A) Copyright Grant- Subject to the terms of this license,
including the license conditions and limitations in section 3, each contributor
grants you a non-exclusive, worldwide, royalty-free copyright license to
reproduce its contribution, prepare derivative works of its contribution, and
distribute its contribution or any derivative works that you create. (B) Patent
Grant- Subject to the terms of this license, including the license conditions and
limitations in section 3, each contributor grants you a non-exclusive, worldwide,
royalty-free license under its licensed patents to make, have made, use, sell,
offer for sale, import, and/or otherwise dispose of its contribution in the
software or derivative works of the contribution in the software.

3. Conditions and Limitations (A) Reciprocal Grants- For any file you distribute
that contains code from the software (in source code or binary format), you must
provide recipients the source code to that file along with a copy of this
license, which license will govern that file. You may license other files that
are entirely your own work and do not contain code from the software under any
terms you choose. (B) No Trademark License- This license does not grant you
rights to use any contributors' name, logo, or trademarks. (C) If you bring a
patent claim against any contributor over patents that you claim are infringed by
the software, your patent license from such contributor to the software ends
automatically. (D) If you distribute any portion of the software, you must retain
all copyright, patent, trademark, and attribution notices that are present in the
software. (E) If you distribute any portion of the software in source code form,
you may do so only under this license by including a complete copy of this
license with your distribution. If you distribute any portion of the software in
compiled or object code form, you may only do so under a license that complies
with this license. (F) The software is licensed "as-is." You bear the risk of
using it. The contributors give no express warranties, guarantees or conditions.
You may have additional consumer rights under your local laws which this license
cannot change. To the extent permitted under your local laws, the contributors
exclude the implied warranties of merchantability, fitness for a particular
purpose and non-infringement.

END OF WIX NOTICES AND INFORMATION
=================================
```

`ext/pix/license.txt`:

```txt
MICROSOFT SOFTWARE LICENSE TERMS

PIX EVENT RUNTIME FOR WINDOWS

IF YOU LIVE IN (OR ARE A BUSINESS WITH A PRINCIPAL PLACE OF BUSINESS IN) THE UNITED STATES, PLEASE READ THE “BINDING ARBITRATION AND CLASS ACTION WAIVER” SECTION BELOW. IT AFFECTS HOW DISPUTES ARE RESOLVED.

These license terms are an agreement between you and Microsoft Corporation (or one of its affiliates). They apply to the software named above and any Microsoft services or software updates (except to the extent such services or updates are accompanied by new or additional terms, in which case those different terms apply prospectively and do not alter your or Microsoft’s rights relating to pre-updated software or services). IF YOU COMPLY WITH THESE LICENSE TERMS, YOU HAVE THE RIGHTS BELOW. BY USING THE SOFTWARE, YOU ACCEPT THESE TERMS.

1. INSTALLATION AND USE RIGHTS.
  a. General. You may install and use any number of copies of the software to design, develop and test your Microsoft Windows programs.
  b. Third Party Software. The software may include third party applications that are licensed to you under this agreement or under their own terms. License terms, notices, and acknowledgements, if any, for the third party applications may be accessible online at http://aka.ms/thirdpartynotices or in an accompanying notices file. Even if such applications are governed by other agreements, the disclaimer, limitations on, and exclusions of damages below also apply to the extent allowed by applicable law.

2. DISTRIBUTABLE CODE.
  a. Distributable Code. The software is comprised of Distributable Code. “Distributable Code” is code that you are permitted to distribute in programs you develop if you comply with the terms below.
    (i) Right to Use and Distribute.
      * You may copy and distribute the object code form of the software.
      * Third Party Distribution. You may permit distributors of your programs to copy and distribute the Distributable Code as part of those programs.
    (ii) Distribution Requirements. For any Distributable Code you distribute, you must
      * add significant primary functionality to it in your programs;
      * require distributors and external end users to agree to terms that protect it at least as much as this agreement;
      * display your valid copyright notice on your programs; and
      * indemnify, defend, and hold harmless Microsoft from any claims, including attorneys’ fees, related to the distribution or use of your programs.
    (iii) Distribution Restrictions. You may not
      * alter any copyright, trademark or patent notice in the Distributable Code;
      * use Microsoft’s trademarks in your programs’ names or in a way that suggests your programs come from or are endorsed by Microsoft;
      * distribute Distributable Code to run on a platform other than a Windows platform;
      * include Distributable Code in malicious, deceptive or unlawful programs; or
      * modify or distribute the source code of any Distributable Code so that any part of it becomes subject to an Excluded License. An Excluded License is one that requires, as a condition of use, modification or distribution, that
        * the code be disclosed or distributed in source code form; or
        * others have the right to modify it.

3. SCOPE OF LICENSE. The software is licensed, not sold. Microsoft reserves all other rights. Unless applicable law gives you more rights despite this limitation, you will not (and have no right to):
  a. work around any technical limitations in the software that only allow you to use it in certain ways;
  b. reverse engineer, decompile or disassemble the software;
  c. remove, minimize, block, or modify any notices of Microsoft or its suppliers in the software;
  d. use the software in any way that is against the law or to create or propagate malware; or
  e. share, publish, distribute, or lend the software, provide the software as a stand-alone hosted solution for others to use, or transfer the software or this agreement to any third party.

4. EXPORT RESTRICTIONS. You must comply with all domestic and international export laws and regulations that apply to the software, which include restrictions on destinations, end users, and end use. For further information on export restrictions, visit http://aka.ms/exporting.

5. SUPPORT SERVICES. Microsoft is not obligated under this agreement to provide any support services for the software. Any support provided is “as is”, “with all faults”, and without warranty of any kind.

6. BINDING ARBITRATION AND CLASS ACTION WAIVER. This Section applies if you live in (or, if a business, your principal place of business is in) the United States. If you and Microsoft have a dispute, you and Microsoft agree to try for 60 days to resolve it informally. If you and Microsoft can’t, you and Microsoft agree to binding individual arbitration before the American Arbitration Association under the Federal Arbitration Act (“FAA”), and not to sue in court in front of a judge or jury. Instead, a neutral arbitrator will decide. Class action lawsuits, class-wide arbitrations, private attorney-general actions, and any other proceeding where someone acts in a representative capacity are not allowed; nor is combining individual proceedings without the consent of all parties. The complete Arbitration Agreement contains more terms and is at http://aka.ms/arb-agreement-1. You and Microsoft agree to these terms.

7. ENTIRE AGREEMENT. This agreement, and any other terms Microsoft may provide for supplements, updates, or third-party applications, is the entire agreement for the software.

8. APPLICABLE LAW AND PLACE TO RESOLVE DISPUTES. If you acquired the software in the United States or Canada, the laws of the state or province where you live (or, if a business, where your principal place of business is located) govern the interpretation of this agreement, claims for its breach, and all other claims (including consumer protection, unfair competition, and tort claims), regardless of conflict of laws principles, except that the FAA governs everything related to arbitration. If you acquired the software in any other country, its laws apply, except that the FAA governs everything related to arbitration. If U.S. federal jurisdiction exists, you and Microsoft consent to exclusive jurisdiction and venue in the federal court in King County, Washington for all disputes heard in court (excluding arbitration). If not, you and Microsoft consent to exclusive jurisdiction and venue in the Superior Court of King County, Washington for all disputes heard in court (excluding arbitration).

9. CONSUMER RIGHTS; REGIONAL VARIATIONS. This agreement describes certain legal rights. You may have other rights, including consumer rights, under the laws of your state, province, or country. Separate and apart from your relationship with Microsoft, you may also have rights with respect to the party from which you acquired the software. This agreement does not change those other rights if the laws of your state, province, or country do not permit it to do so. For example, if you acquired the software in one of the below regions, or mandatory country law applies, then the following provisions apply to you:
  a. Australia. You have statutory guarantees under the Australian Consumer Law and nothing in this agreement is intended to affect those rights.
  b. Canada. If you acquired this software in Canada, you may stop receiving updates by turning off the automatic update feature, disconnecting your device from the Internet (if and when you re-connect to the Internet, however, the software will resume checking for and installing updates), or uninstalling the software. The product documentation, if any, may also specify how to turn off updates for your specific device or software.
  c. Germany and Austria.
    (i) Warranty. The properly licensed software will perform substantially as described in any Microsoft materials that accompany the software. However, Microsoft gives no contractual guarantee in relation to the licensed software.
    (ii) Limitation of Liability. In case of intentional conduct, gross negligence, claims based on the Product Liability Act, as well as, in case of death or personal or physical injury, Microsoft is liable according to the statutory law.
    Subject to the foregoing clause (ii), Microsoft will only be liable for slight negligence if Microsoft is in breach of such material contractual obligations, the fulfillment of which facilitate the due performance of this agreement, the breach of which would endanger the purpose of this agreement and the compliance with which a party may constantly trust in (so-called "cardinal obligations"). In other cases of slight negligence, Microsoft will not be liable for slight negligence.

10. DISCLAIMER OF WARRANTY. THE SOFTWARE IS LICENSED “AS IS.” YOU BEAR THE RISK OF USING IT. MICROSOFT GIVES NO EXPRESS WARRANTIES, GUARANTEES, OR CONDITIONS. TO THE EXTENT PERMITTED UNDER APPLICABLE LAWS, MICROSOFT EXCLUDES ALL IMPLIED WARRANTIES, INCLUDING MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.

11. LIMITATION ON AND EXCLUSION OF DAMAGES. IF YOU HAVE ANY BASIS FOR RECOVERING DAMAGES DESPITE THE PRECEDING DISCLAIMER OF WARRANTY, YOU CAN RECOVER FROM MICROSOFT AND ITS SUPPLIERS ONLY DIRECT DAMAGES UP TO U.S. $5.00. YOU CANNOT RECOVER ANY OTHER DAMAGES, INCLUDING CONSEQUENTIAL, LOST PROFITS, SPECIAL, INDIRECT OR INCIDENTAL DAMAGES.
This limitation applies to (a) anything related to the software, services, content (including code) on third party Internet sites, or third party applications; and (b) claims for breach of contract, warranty, guarantee, or condition; strict liability, negligence, or other tort; or any other claim; in each case to the extent permitted by applicable law.
It also applies even if Microsoft knew or should have known about the possibility of the damages. The above limitation or exclusion may not apply to you because your state, province, or country may not allow the exclusion or limitation of incidental, consequential, or other damages.


[Please note: As this software is distributed in Canada, some of the clauses in this agreement are provided below in French.

Remarque: Ce logiciel étant distribué au Canada, certaines des clauses dans ce contrat sont fournies ci-dessous en français.

EXONÉRATION DE GARANTIE. Le logiciel visé par une licence est offert « tel quel ». Toute utilisation de ce logiciel est à votre seule risque et péril. Microsoft n’accorde aucune autre garantie expresse. Vous pouvez bénéficier de droits additionnels en vertu du droit local sur la protection des consommateurs, que ce contrat ne peut modifier. La ou elles sont permises par le droit locale, les garanties implicites de qualité marchande, d’adéquation à un usage particulier et d’absence de contrefaçon sont exclues.

LIMITATION DES DOMMAGES-INTÉRÊTS ET EXCLUSION DE RESPONSABILITÉ POUR LES DOMMAGES. Vous pouvez obtenir de Microsoft et de ses fournisseurs une indemnisation en cas de dommages directs uniquement à hauteur de 5,00 $ US. Vous ne pouvez prétendre à aucune indemnisation pour les autres dommages, y compris les dommages spéciaux, indirects ou accessoires et pertes de bénéfices.

Cette limitation concerne:
  * tout ce qui est relié au logiciel, aux services ou au contenu (y compris le code) figurant sur des sites Internet tiers ou dans des programmes tiers; et
  * les réclamations au titre de violation de contrat ou de garantie, ou au titre de responsabilité stricte, de négligence ou d’une autre faute dans la limite autorisée par la loi en vigueur.

Elle s’applique également, même si Microsoft connaissait ou devrait connaître l’éventualité d’un tel dommage. Si votre pays n’autorise pas l’exclusion ou la limitation de responsabilité pour les dommages indirects, accessoires ou de quelque nature que ce soit, il se peut que la limitation ou l’exclusion ci-dessus ne s’appliquera pas à votre égard.

EFFET JURIDIQUE. Le présent contrat décrit certains droits juridiques. Vous pourriez avoir d’autres droits prévus par les lois de votre pays. Le présent contrat ne modifie pas les droits que vous confèrent les lois de votre pays si celles-ci ne le permettent pas.]

```

`ext/pix/pix3.h`:

```h
// Copyright (c) Microsoft Corporation. All rights reserved.

/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       pix3.h
 *  Content:    PIX include file
 *
 ****************************************************************************/
#pragma once

#ifndef _PIX3_H_
#define _PIX3_H_

#include <sal.h>

#ifndef __cplusplus
#error "Only C++ files can include pix3.h. C is not supported."
#endif

#if !defined(USE_PIX_SUPPORTED_ARCHITECTURE)
#if defined(_M_X64) || defined(USE_PIX_ON_ALL_ARCHITECTURES) || defined(_M_ARM64)
#define USE_PIX_SUPPORTED_ARCHITECTURE
#endif
#endif

#if !defined(USE_PIX)
#if defined(USE_PIX_SUPPORTED_ARCHITECTURE) && (defined(_DEBUG) || DBG || defined(PROFILE) || defined(PROFILE_BUILD)) && !defined(_PREFAST_)
#define USE_PIX
#endif
#endif

#if defined(USE_PIX) && !defined(USE_PIX_SUPPORTED_ARCHITECTURE)
#pragma message("Warning: Pix markers are only supported on AMD64 and ARM64")
#endif


// These flags are used by both PIXBeginCapture and PIXGetCaptureState
#define PIX_CAPTURE_TIMING                  (1 << 0)
#define PIX_CAPTURE_GPU                     (1 << 1)
#define PIX_CAPTURE_FUNCTION_SUMMARY        (1 << 2)
#define PIX_CAPTURE_FUNCTION_DETAILS        (1 << 3)
#define PIX_CAPTURE_CALLGRAPH               (1 << 4)
#define PIX_CAPTURE_INSTRUCTION_TRACE       (1 << 5)
#define PIX_CAPTURE_SYSTEM_MONITOR_COUNTERS (1 << 6)
#define PIX_CAPTURE_VIDEO                   (1 << 7)
#define PIX_CAPTURE_AUDIO                   (1 << 8)
#define PIX_CAPTURE_RESERVED                (1 << 15)

union PIXCaptureParameters
{
    enum PIXCaptureStorage
    {
        Memory = 0,
    };

    struct GpuCaptureParameters
    {
        PCWSTR FileName;
    } GpuCaptureParameters;

    struct TimingCaptureParameters
    {
        PCWSTR FileName;
        UINT32 MaximumToolingMemorySizeMb;
        PIXCaptureStorage CaptureStorage;

        BOOL CaptureGpuTiming;

        BOOL CaptureCallstacks;
        BOOL CaptureCpuSamples;
        UINT32 CpuSamplesPerSecond;

        BOOL CaptureFileIO;

        BOOL CaptureVirtualAllocEvents;
        BOOL CaptureHeapAllocEvents;
        BOOL CaptureXMemEvents; // Xbox only
        BOOL CapturePixMemEvents; // Xbox only
    } TimingCaptureParameters;
};

typedef PIXCaptureParameters* PPIXCaptureParameters;

#if defined(XBOX) || defined(_XBOX_ONE) || defined(_DURANGO) || defined(_GAMING_XBOX) || defined(_GAMING_XBOX_SCARLETT)
#include "pix3_xbox.h"
#else
#include "pix3_win.h"
#endif

#if defined(USE_PIX_SUPPORTED_ARCHITECTURE) && (defined(USE_PIX) || defined(USE_PIX_RETAIL))

#define PIX_EVENTS_ARE_TURNED_ON

#include "PIXEventsCommon.h"
#include "PIXEvents.h"

#ifdef USE_PIX
// Starts a programmatically controlled capture.
// captureFlags uses the PIX_CAPTURE_* family of flags to specify the type of capture to take
extern "C" HRESULT WINAPI PIXBeginCapture2(DWORD captureFlags, _In_opt_ const PPIXCaptureParameters captureParameters);
inline HRESULT PIXBeginCapture(DWORD captureFlags, _In_opt_ const PPIXCaptureParameters captureParameters) { return PIXBeginCapture2(captureFlags, captureParameters); }

// Stops a programmatically controlled capture
//  If discard == TRUE, the captured data is discarded
//  If discard == FALSE, the captured data is saved
//  discard parameter is not supported on Windows
extern "C" HRESULT WINAPI PIXEndCapture(BOOL discard);

extern "C" DWORD WINAPI PIXGetCaptureState();

extern "C" void WINAPI PIXReportCounter(_In_ PCWSTR name, float value);

#endif // USE_PIX

#endif // (USE_PIX_SUPPORTED_ARCHITECTURE) && (USE_PIX || USE_PIX_RETAIL)

#if !defined(USE_PIX_SUPPORTED_ARCHITECTURE) || !defined(USE_PIX)

// Eliminate these APIs when not using PIX
inline HRESULT PIXBeginCapture2(DWORD, _In_opt_ const PIXCaptureParameters*) { return S_OK; }
inline HRESULT PIXBeginCapture(DWORD, _In_opt_ const PIXCaptureParameters*) { return S_OK; }
inline HRESULT PIXEndCapture(BOOL) { return S_OK; }
inline HRESULT PIXGpuCaptureNextFrames(PCWSTR, UINT32) { return S_OK; }
inline HRESULT PIXSetTargetWindow(HWND) { return S_OK; }
inline HRESULT PIXForceD3D11On12() { return S_OK; }
inline HRESULT WINAPI PIXSetHUDOptions(PIXHUDOptions) { return S_OK; }
inline HMODULE PIXLoadLatestWinPixGpuCapturerLibrary() { return nullptr; }
inline DWORD PIXGetCaptureState() { return 0; }
inline void PIXReportCounter(_In_ PCWSTR, float) {}
inline void PIXNotifyWakeFromFenceSignal(_In_ HANDLE) {}

#if !defined(USE_PIX_RETAIL)

inline void PIXBeginEvent(UINT64, _In_ PCSTR, ...) {}
inline void PIXBeginEvent(UINT64, _In_ PCWSTR, ...) {}
inline void PIXBeginEvent(void*, UINT64, _In_ PCSTR, ...) {}
inline void PIXBeginEvent(void*, UINT64, _In_ PCWSTR, ...) {}
inline void PIXEndEvent() {}
inline void PIXEndEvent(void*) {}
inline void PIXSetMarker(UINT64, _In_ PCSTR, ...) {}
inline void PIXSetMarker(UINT64, _In_ PCWSTR, ...) {}
inline void PIXSetMarker(void*, UINT64, _In_ PCSTR, ...) {}
inline void PIXSetMarker(void*, UINT64, _In_ PCWSTR, ...) {}
inline void PIXBeginRetailEvent(void*, UINT64, _In_ PCSTR, ...) {}
inline void PIXBeginRetailEvent(void*, UINT64, _In_ PCWSTR, ...) {}
inline void PIXEndRetailEvent(void*) {}
inline void PIXSetRetailMarker(void*, UINT64, _In_ PCSTR, ...) {}
inline void PIXSetRetailMarker(void*, UINT64, _In_ PCWSTR, ...) {}
inline void PIXScopedEvent(UINT64, _In_ PCSTR, ...) {}
inline void PIXScopedEvent(UINT64, _In_ PCWSTR, ...) {}
inline void PIXScopedEvent(void*, UINT64, _In_ PCSTR, ...) {}
inline void PIXScopedEvent(void*, UINT64, _In_ PCWSTR, ...) {}

#endif // !USE_PIX_RETAIL

// don't show warnings about expressions with no effect
#pragma warning(disable:4548)
#pragma warning(disable:4555)

#endif // !USE_PIX_SUPPORTED_ARCHITECTURE || !USE_PIX

// Use these functions to specify colors to pass as metadata to a PIX event/marker API.
// Use PIX_COLOR() to specify a particular color for an event.
// Or, use PIX_COLOR_INDEX() to specify a set of unique event categories, and let PIX choose
// the colors to represent each category.
inline UINT PIX_COLOR(BYTE r, BYTE g, BYTE b) { return 0xff000000 | (r << 16) | (g << 8) | b; }
inline UINT PIX_COLOR_INDEX(BYTE i) { return i; }
const UINT PIX_COLOR_DEFAULT = PIX_COLOR_INDEX(0);

#endif // _PIX3_H_

```

`ext/pix/pix3_win.h`:

```h
// Copyright (c) Microsoft Corporation. All rights reserved.

/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       PIX3_win.h
 *  Content:    PIX include file
 *              Don't include this file directly - use pix3.h
 *
 ****************************************************************************/

#pragma once

#ifndef _PIX3_H_
#error Don't include this file directly - use pix3.h
#endif

#ifndef _PIX3_WIN_H_
#define _PIX3_WIN_H_

// PIXEventsThreadInfo is defined in PIXEventsCommon.h
struct PIXEventsThreadInfo;

extern "C" PIXEventsThreadInfo* WINAPI PIXGetThreadInfo() noexcept;

#if defined(USE_PIX) && defined(USE_PIX_SUPPORTED_ARCHITECTURE)
// Notifies PIX that an event handle was set as a result of a D3D12 fence being signaled.
// The event specified must have the same handle value as the handle
// used in ID3D12Fence::SetEventOnCompletion.
extern "C" void WINAPI PIXNotifyWakeFromFenceSignal(_In_ HANDLE event);
#endif

// The following defines denote the different metadata values that have been used
// by tools to denote how to parse pix marker event data. The first two values
// are legacy values.
#define WINPIX_EVENT_UNICODE_VERSION 0
#define WINPIX_EVENT_ANSI_VERSION 1
#define WINPIX_EVENT_PIX3BLOB_VERSION 2

#define D3D12_EVENT_METADATA WINPIX_EVENT_PIX3BLOB_VERSION

__forceinline UINT64 PIXGetTimestampCounter()
{
    LARGE_INTEGER time = {};
    QueryPerformanceCounter(&time);
    return static_cast<UINT64>(time.QuadPart);
}

enum PIXHUDOptions
{
    PIX_HUD_SHOW_ON_ALL_WINDOWS = 0x1,
    PIX_HUD_SHOW_ON_TARGET_WINDOW_ONLY = 0x2,
    PIX_HUD_SHOW_ON_NO_WINDOWS = 0x4
};
DEFINE_ENUM_FLAG_OPERATORS(PIXHUDOptions);

#if defined(USE_PIX_SUPPORTED_ARCHITECTURE) && defined(USE_PIX)

#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM | WINAPI_PARTITION_GAMES)

namespace PixImpl
{
    __forceinline void * GetFunctionPtr(LPCSTR fnName) noexcept
    {
        HMODULE module = GetModuleHandleW(L"WinPixGpuCapturer.dll");
        if (module == NULL)
        {
            return nullptr;
        }

        auto fn = GetProcAddress(module, fnName);
        if (fn == nullptr)
        {
            return nullptr;
        }

        return fn;
    }
}

#include <shlobj.h>
#include <strsafe.h>
#include <knownfolders.h>

#define PIXERRORCHECK(value)  do {                      \
                                 if (FAILED(value))     \
                                     return nullptr;    \
                                 } while(0)

__forceinline HMODULE PIXLoadLatestWinPixGpuCapturerLibrary()
{
    HMODULE libHandle{};

    if (GetModuleHandleExW(0, L"WinPixGpuCapturer.dll", &libHandle))
    {
        return libHandle;
    }

    LPWSTR programFilesPath = nullptr;
    if (FAILED(SHGetKnownFolderPath(FOLDERID_ProgramFiles, KF_FLAG_DEFAULT, NULL, &programFilesPath)))
    {
        CoTaskMemFree(programFilesPath);
        return nullptr;
    }

    wchar_t pixSearchPath[MAX_PATH];

    if (FAILED(StringCchCopyW(pixSearchPath, MAX_PATH, programFilesPath)))
    {
        CoTaskMemFree(programFilesPath);
        return nullptr;
    }
    CoTaskMemFree(programFilesPath);

    PIXERRORCHECK(StringCchCatW(pixSearchPath, MAX_PATH, L"\\Microsoft PIX\\*"));

    WIN32_FIND_DATAW findData;
    bool foundPixInstallation = false;
    wchar_t newestVersionFound[MAX_PATH];
    wchar_t output[MAX_PATH];
    wchar_t possibleOutput[MAX_PATH];

    HANDLE hFind = FindFirstFileW(pixSearchPath, &findData);
    if (hFind != INVALID_HANDLE_VALUE)
    {
        do
        {
            if (((findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY) &&
                (findData.cFileName[0] != '.'))
            {
                if (!foundPixInstallation || wcscmp(newestVersionFound, findData.cFileName) <= 0)
                {
                    // length - 1 to get rid of the wildcard character in the search path
                    PIXERRORCHECK(StringCchCopyNW(possibleOutput, MAX_PATH, pixSearchPath, wcslen(pixSearchPath) - 1));
                    PIXERRORCHECK(StringCchCatW(possibleOutput, MAX_PATH, findData.cFileName));
                    PIXERRORCHECK(StringCchCatW(possibleOutput, MAX_PATH, L"\\WinPixGpuCapturer.dll"));

                    DWORD result = GetFileAttributesW(possibleOutput);

                    if (result != INVALID_FILE_ATTRIBUTES && !(result & FILE_ATTRIBUTE_DIRECTORY))
                    {
                        foundPixInstallation = true;
                        PIXERRORCHECK(StringCchCopyW(newestVersionFound, _countof(newestVersionFound), findData.cFileName));
                        PIXERRORCHECK(StringCchCopyW(output, _countof(possibleOutput), possibleOutput));
                    }
                }
            }
        } while (FindNextFileW(hFind, &findData) != 0);
    }

    FindClose(hFind);

    if (!foundPixInstallation)
    {
        SetLastError(ERROR_FILE_NOT_FOUND);
        return nullptr;
    }

    return LoadLibraryW(output);
}

#undef PIXERRORCHECK

__forceinline HRESULT WINAPI PIXSetTargetWindow(HWND hwnd)
{
    typedef void(WINAPI* SetGlobalTargetWindowFn)(HWND);

    auto fn = (SetGlobalTargetWindowFn)PixImpl::GetFunctionPtr("SetGlobalTargetWindow");
    if (fn == nullptr)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    fn(hwnd);
    return S_OK;
}

__forceinline HRESULT WINAPI PIXGpuCaptureNextFrames(PCWSTR fileName, UINT32 numFrames)
{
    typedef HRESULT(WINAPI* CaptureNextFrameFn)(PCWSTR, UINT32);

    auto fn = (CaptureNextFrameFn)PixImpl::GetFunctionPtr("CaptureNextFrame");
    if (fn == nullptr)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return fn(fileName, numFrames);
}

extern "C"  __forceinline HRESULT WINAPI PIXBeginCapture2(DWORD captureFlags, _In_opt_ const PPIXCaptureParameters captureParameters)
{
    if (captureFlags == PIX_CAPTURE_GPU)
    {
        typedef HRESULT(WINAPI* BeginProgrammaticGpuCaptureFn)(const PPIXCaptureParameters);

        auto fn = (BeginProgrammaticGpuCaptureFn)PixImpl::GetFunctionPtr("BeginProgrammaticGpuCapture");
        if (fn == nullptr)
        {
            return HRESULT_FROM_WIN32(GetLastError());
        }

        return fn(captureParameters);
    }
    else
    {
        return E_NOTIMPL;
    }
}

extern "C"  __forceinline HRESULT WINAPI PIXEndCapture(BOOL discard)
{
    UNREFERENCED_PARAMETER(discard);

    typedef HRESULT(WINAPI* EndProgrammaticGpuCaptureFn)(void);

    auto fn = (EndProgrammaticGpuCaptureFn)PixImpl::GetFunctionPtr("EndProgrammaticGpuCapture");
    if (fn == NULL)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return fn();
}

__forceinline HRESULT WINAPI PIXForceD3D11On12()
{
    typedef HRESULT (WINAPI* ForceD3D11On12Fn)(void);

    auto fn = (ForceD3D11On12Fn)PixImpl::GetFunctionPtr("ForceD3D11On12");
    if (fn == NULL)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return fn();
}

__forceinline HRESULT WINAPI PIXSetHUDOptions(PIXHUDOptions hudOptions)
{
    typedef HRESULT(WINAPI* SetHUDOptionsFn)(PIXHUDOptions);

    auto fn = (SetHUDOptionsFn)PixImpl::GetFunctionPtr("SetHUDOptions");
    if (fn == NULL)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return fn(hudOptions);
}

#else
__forceinline HMODULE PIXLoadLatestWinPixGpuCapturerLibrary()
{
    return nullptr;
}
__forceinline HRESULT WINAPI PIXSetTargetWindow(HWND)
{
    return E_NOTIMPL;
}

__forceinline HRESULT WINAPI PIXGpuCaptureNextFrames(PCWSTR, UINT32)
{
    return E_NOTIMPL;
}
extern "C"  __forceinline HRESULT WINAPI PIXBeginCapture2(DWORD, _In_opt_ const PPIXCaptureParameters)
{
    return E_NOTIMPL;
}
extern "C"  __forceinline HRESULT WINAPI PIXEndCapture(BOOL)
{
    return E_NOTIMPL;
}
__forceinline HRESULT WINAPI PIXForceD3D11On12()
{
    return E_NOTIMPL;
}
__forceinline HRESULT WINAPI PIXSetHUDOptions(PIXHUDOptions)
{
    return E_NOTIMPL;
}
#endif // WINAPI_PARTITION

#endif // USE_PIX_SUPPORTED_ARCHITECTURE || USE_PIX

#endif //_PIX3_WIN_H_

```

`generate2019.bat`:

```bat
call premake\premake5.exe %* vs2019
PAUSE

```

`generate2022.bat`:

```bat
call premake\premake5.exe %* vs2022
PAUSE

```

`imgui.ini`:

```ini
[Window][DockSpaceViewport_11111111]
Pos=0,22
Size=2576,1355
Collapsed=0

[Window][Assets]
Pos=0,1198
Size=2002,179
Collapsed=0
DockId=0x00000004,0

[Window][Scene]
Pos=0,24
Size=929,581
Collapsed=0
DockId=0x00000002

[Window][Settings]
Pos=2004,22
Size=572,1355
Collapsed=0
DockId=0x00000007,0

[Window][  Icons]
Pos=60,60
Size=656,628
Collapsed=0

[Window][Dear ImGui Demo]
Pos=957,146
Size=550,680
Collapsed=0

[Window][Scene Hierarchy]
Pos=2004,22
Size=572,1355
Collapsed=0
DockId=0x00000007,1

[Window][Scene Viewport]
Pos=0,22
Size=2002,1174
Collapsed=0
DockId=0x00000002,0

[Window][##MessageLog]
Pos=7,177
Size=32,32
Collapsed=0

[Window][  GPU Profiling]
Pos=60,60
Size=1471,759
Collapsed=0

[Window][  CPU Profiling]
Pos=60,60
Size=1374,839
Collapsed=0

[Window][  Message log]
Pos=446,171
Size=556,383
Collapsed=0

[Window][  About]
Pos=903,491
Size=135,86
Collapsed=0

[Window][  Controls]
Pos=687,324
Size=562,440
Collapsed=0

[Window][Light probe]
Pos=1506,868
Size=430,220
Collapsed=0
DockId=0x00000008,0

[Window][Debug##Default]
Pos=60,60
Size=400,400
Collapsed=0

[Table][0xC596C2EE,2]
Column 0  Weight=0.7052
Column 1  Weight=1.2948

[Table][0xD0B05A78,2]
Column 0  Weight=0.6446
Column 1  Weight=1.3554

[Table][0x5B3BD610,2]
Column 0  Weight=0.7052
Column 1  Weight=1.2948

[Table][0xC0ADC04F,2]
Column 0  Weight=0.8490
Column 1  Weight=1.1510

[Table][0xD5B817DB,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xCAC1815A,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x925E460C,2]
Column 0  Weight=0.7134
Column 1  Weight=1.2866

[Table][0x971380F8,2]
Column 0  Weight=0.6901
Column 1  Weight=1.3099

[Table][0x69C22710,2]
Column 0  Weight=0.9049
Column 1  Weight=1.0951

[Table][0xEBACF1A4,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xB79E5298,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x95639DC2,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xE8E9D430,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x734C985F,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x7F5475A3,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x7A5E3822,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xD57E663F,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xFC248860,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x704AA320,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x04D24AAF,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x936FEB3C,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x6765AE5B,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x8B5E30C4,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x6E770E26,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x687B78D8,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xA3A96BE0,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xB72737EE,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xAA1CA197,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xDE844818,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xC18F2EA3,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xBCD0FD61,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x32BFD687,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xA91A9AE8,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x54027FF2,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x9DBD8D9F,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xB839E16D,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xBB3FDA12,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x5E16E4F0,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xB22D7A6F,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x0BCEC10A,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x9F839713,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x209A967D,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xD6FBD90C,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xA2633083,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x4854D8E2,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xCFA7339D,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x3FCA0A12,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x51083273,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xA7697D02,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x2590DBFC,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xF1B76387,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x30D4DC91,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xC6B593E0,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x474A0E61,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xB12B4110,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xDFE97971,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xA30E01EA,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xA5027714,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xE4F364EA,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x73B8098C,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xE7F55F95,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x03B1501E,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xEF8ACE81,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x02DC6177,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x99792D18,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xEBEDB269,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x7048FE06,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xEC8CF5FE,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x06BB1D9F,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xEA808300,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x7125CF6F,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xB4210C91,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x9F8336CD,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x4939E98B,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x0EC48C8B,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x70BE32F3,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xF3D242F6,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x59DC5397,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x6B46B2F7,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x197BFBB5,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x4BF9136D,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x3F61FAE2,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xAED02D8F,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xEF1A0A9D,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x42EBB310,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xEA2B73F0,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x91CCFAC3,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x2DF79E6E,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xADD616F0,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x41ED886F,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x44E7C5EE,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xFD047E8B,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x7BFDC768,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x462CF2C8,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xC17F2487,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xD72B071D,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xD146043C,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xEBFF8FC3,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x7D96D263,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x090E3BEC,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x92AB7783,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xE535A573,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x887C0E60,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x5FCAD72C,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x3411BB8A,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xA4779DD7,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xAE159B7A,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xDC44B2FE,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xDA48C400,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x8E3C903D,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xDF298DC5,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x59AAE3FC,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x5DE9054C,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x047F84DA,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x718E3F9F,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x096CE736,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xCFACF171,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x0BD2C13F,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x97B573BA,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xE2CBF82B,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xA9702AB6,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x816C1138,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x8AEC1C10,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xC30932C4,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x2BA5AC30,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x0B99B77C,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x97A13A02,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x23F871E8,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x77824961,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x76D15C54,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x181A283D,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x98BFEC81,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x639B173B,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x7484721E,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x9DB5A100,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x9EB39A7F,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x1C26AC59,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x728804E0,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x7B9AA49D,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x94A7017D,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x36B23A87,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x789C9FE2,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x91AD4CFC,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xB3EBBBF6,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xA5164E5F,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x2B48CCE6,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x90FBF80C,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x5CD61E16,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xCECD22F9,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xC2791FF8,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x2C964DE6,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xB6E1F677,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x72A09713,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x24561A65,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x474D2140,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x53C8C895,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x6D674F6C,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xCB6BBF85,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xA337B3C4,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xB9FF20F4,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xD10AFA86,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x215C57E4,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xE4E74CD5,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xCD67C97B,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x0D2E0951,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x3379171E,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xDF428981,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x36735A9F,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x357561E0,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xD94EFF7F,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x3C67C19D,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xD05C5F02,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x9BB9D7FE,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xD35A647D,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x4DF56593,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x396D8C1C,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x1C33C293,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xA4C4B68D,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x48FF2812,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x3A6BB763,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xA1CEFB0C,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xE184810F,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xA2C8C073,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xF057BB8F,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x64B12A89,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xE59E9AE8,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xD66E0C26,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x79C741EC,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x1CA07AAA,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x827FB774,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x2D44BA18,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x5ADA68E8,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xBFF3560A,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xC86D84FA,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xE03FE8F2,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x0F024D12,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xE339D38D,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x0A080093,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xE6339E0C,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x28F83841,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x7D4961EE,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x0516D610,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xE92D488F,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x0C04766D,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xA22A22A6,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xC7735279,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xB5E7CD08,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x891DDDE8,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xFB2094AA,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x2F50EC64,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x71E52E16,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x4EB9F720,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x2A5CC1D0,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x2750211A,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xBCF56D75,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x284EF799,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xC4756906,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x5FD02569,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xB0ED8089,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x2E428167,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xAE7F5C05,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xF96AFC3B,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x50CEF3EA,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x225A6C9B,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xCE61F204,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x55C4BE6B,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xBAF91B8B,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x93657473,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x3A013CFA,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x817BAC18,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x307F2C61,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xABDA600E,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x47E1FE91,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xA8DC5B71,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xB7871762,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xE110BAEA,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x2E6FC48C,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x594138DB,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xEF213E71,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x19AC571E,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xEAF629E6,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x20385F6A,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xC232D20F,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x182E5AA8,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xF30E6281,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x1746E9A6,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xF6024F35,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x6533273F,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xC3F91765,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xB5408FCB,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xCC3C393C,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xFC66D18F,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x7E90E91C,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xB6051AD4,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xEC27050E,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x5741BC47,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xAFFD51B3,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x2BDECC66,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x588AFDB1,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x031AA0EE,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x9D8FCACB,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xCA9A6AF5,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x2E8A2639,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x7CCB6C58,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xC3A5B6F6,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x0610ED6F,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xD3622192,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x85936254,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x184F6947,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xBB19EFEE,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xCFADE91F,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x65A7099B,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x113FE014,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x8A9AAC7B,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x2E55EAF6,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xF9E333BA,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x92385F1C,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x025E7941,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x1E3BD5A6,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x222CDCF0,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x5CA0AE7D,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xC705E212,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xB09B30E2,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x11DA5A08,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xEA6710F3,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xF5A0C88C,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x65C6EED1,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xAB961279,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x5CDBEA99,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xD8F8774C,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x10854B93,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x6C2F673B,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x3B3AC705,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x4DC1299E,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x28A612D8,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x543962F9,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xE214A186,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x86F19776,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x33A48AB7,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xE9CE304A,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x36A8A703,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x61BD073D,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x8A9D3F14,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x6BD99987,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x0EBEA2C1,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xE092B75C,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x1FF3358C,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x9883E77F,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xBBB045A8,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x400D0F53,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xD06B290E,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x97BBD61F,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xA256604C,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x9C0DC77D,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x411FBE19,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x1D22771C,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x4A37D722,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xD2E02C24,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xA5DBBF64,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xCB186743,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x80F9A1AE,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x25C74BF2,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x524D91F3,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xD0663AFE,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xB50101B8,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x63AB7F65,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x173396EA,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x8C96DA85,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xFB080875,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x60AD441A,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x1239DB6B,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x899C9704,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xFE0245F4,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xF21AA808,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x69BFE467,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x1D270DE8,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x86824187,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xF11C9377,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x6AB9DF18,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x1435AD95,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x8F90E1FA,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xACF94ADF,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xC99E7199,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xF80E330A,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x1E213697,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x85847AF8,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x83880C06,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x901DAACD,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xF57A918B,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x8AE1FAC6,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x44A1AC48,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xC082319D,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xE149D397,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x6EA971E1,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x868D52A4,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x47A5B724,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x6DAD6A8D,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x92DDC7E8,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x34742C68,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x9BDD61A2,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x2E887C63,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x64EBB738,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xAE25C1B4,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x949EE1C6,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x1AF2D1C3,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x4601E2F1,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xC9C4EC28,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x432B9726,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xD65029FC,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x2DD6FABE,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xD5561283,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x9901EAC9,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x5762950E,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x7C76B16A,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x07DE2717,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xAFDC2B24,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xC335393E,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xFD9EEA20,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0xF6BE0803,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x15FEB73F,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Table][0x8EEF148D,2]
Column 0  Weight=1.0000
Column 1  Weight=1.0000

[Docking][Data]
DockSpace         ID=0x8B93E3BD Window=0xA787BDB4 Pos=-8,45 Size=2576,1355 Split=Y
  DockNode        ID=0x00000009 Parent=0x8B93E3BD SizeRef=1280,58 HiddenTabBar=1 Selected=0x039BEE69
  DockNode        ID=0x0000000A Parent=0x8B93E3BD SizeRef=1280,996 Split=Y
    DockNode      ID=0x00000001 Parent=0x0000000A SizeRef=1280,568 Split=X Selected=0x18B8C0DE
      DockNode    ID=0x00000005 Parent=0x00000001 SizeRef=1504,599 Split=Y Selected=0xC2FD1931
        DockNode  ID=0x00000002 Parent=0x00000005 SizeRef=982,866 CentralNode=1 HiddenTabBar=1 Selected=0xC2FD1931
        DockNode  ID=0x00000004 Parent=0x00000005 SizeRef=982,179 Selected=0x7E7D78B8
      DockNode    ID=0x00000006 Parent=0x00000001 SizeRef=430,599 Split=Y Selected=0x1C33C293
        DockNode  ID=0x00000007 Parent=0x00000006 SizeRef=347,844 Selected=0x1C33C293
        DockNode  ID=0x00000008 Parent=0x00000006 SizeRef=347,220 Selected=0xAFDC2B24
    DockNode      ID=0x00000003 Parent=0x0000000A SizeRef=1280,145 Selected=0x7E7D78B8


```

`learning/convert_model_to_c++.py`:

```py
import torch
import util
import os

from stable_baselines3 import PPO
from stable_baselines3.common.policies import ActorCriticPolicy

def write_network(network, file, variable_names) :

    i = 0
    for name, param in network.named_parameters():
        #print(name, param, param.size())
        var = variable_names[i]
        i += 1
        size = list(param.size())
        if len(size) == 2:
            file.write("static const float " + var + "[" + str(size[0]) + "][" + str(size[1]) + "] =\n{\n");
            for row in param.tolist() :
                file.write("\t{ ") # Row start.
                for val in row :
                    file.write(str(val))
                    file.write("f, ")
                file.write("},\n") # Row end.
            file.write("};\n\n") # 2D end.
        elif len(size) == 1:
            file.write("static const float " + var + "[" + str(size[0]) + "] =\n{\n\t");
            for val in param.tolist() :
                file.write(str(val))
                file.write("f, ")
            file.write("\n};\n\n")


def write_policy(policy, log_dir) :

    print(policy)

    with open(log_dir + "network.h", "w") as file :

        file.write("#pragma once\n\n")
        file.write("#define HIDDEN_LAYER_SIZE 128\n\n")

        policy_net = policy.mlp_extractor.policy_net
        write_network(policy_net, file, ["policyWeights1", "policyBias1", "policyWeights2", "policyBias2"])

        action_net = policy.action_net
        write_network(action_net, file, ["actionWeights", "actionBias"])


if __name__ == '__main__':
    
    log_dir = "tmp/"
    device = "cpu"

    env = util.make_loco_env(log_dir)

    model = PPO.load(os.path.join(log_dir, 'best_model.zip'), env=env, policy=ActorCriticPolicy, device=device)

    policy = model.policy
    write_policy(policy, log_dir)



```

`learning/learn_locomotion.py`:

```py
import numpy as np
import os
import torch
import math
import util

from stable_baselines3 import PPO
from stable_baselines3 import DQN
from stable_baselines3.common.utils import set_random_seed
from stable_baselines3.common.evaluation import evaluate_policy
from stable_baselines3.common.callbacks import BaseCallback
from stable_baselines3.common.results_plotter import load_results, ts2xy, plot_results
from stable_baselines3.common.env_checker import check_env
from stable_baselines3.common.policies import ActorCriticPolicy



class SaveOnBestTrainingRewardCallback(BaseCallback):
    def __init__(self, check_freq: int, trace_freq: int, log_dir: str, verbose=1):
        super(SaveOnBestTrainingRewardCallback, self).__init__(verbose)
        self.check_freq = check_freq
        self.trace_freq = trace_freq
        self.log_dir = log_dir
        self.save_path = os.path.join(log_dir, 'best_model')
        self.best_mean_reward = -np.inf
        self.best_counter = 0

    def _init_callback(self) -> None:
        # Create folder if needed
        if self.save_path is not None:
            os.makedirs(self.save_path, exist_ok=True)

    def _on_step(self) -> bool:
        if self.n_calls % self.check_freq == 0:

          # Retrieve training reward
          x, y = ts2xy(load_results(self.log_dir), 'timesteps')
          if len(x) > 0:
              # Mean training reward over the last 100 episodes
              mean_reward = np.mean(y[-100:])
              if self.verbose > 0:
                print("Num timesteps: {}".format(self.num_timesteps))
                print("Best mean reward: {:.2f} - Last mean reward per episode: {:.2f}".format(self.best_mean_reward, mean_reward))

              # New best model, you could save the agent here
              if mean_reward > self.best_mean_reward:
                  self.best_mean_reward = mean_reward
                  # Example for saving best model
                  if self.verbose > 0:
                    print("Saving new best model to {}".format(self.save_path))
                  self.model.save(self.save_path)
                  self.best_counter += 1
                  
                  if self.best_counter % self.trace_freq == 0:
                      util.trace_model(self.model, self.model.get_env(), log_dir)


if __name__ == '__main__':

    log_dir = "tmp/"
    os.makedirs(log_dir, exist_ok=True)
    
    env = util.make_loco_env(log_dir)
    
    callback = SaveOnBestTrainingRewardCallback(
        check_freq=1000, 
        trace_freq=5, 
        log_dir=log_dir
    )

    policy_kwargs = dict(activation_fn=torch.nn.Tanh,
                     net_arch=[dict(pi=[128, 128], vf=[128, 128])])
    
    start_from_pretrained = False

    device = "cpu"

    if start_from_pretrained :
        print("Starting from pretrained.")
        model = PPO.load(os.path.join(log_dir, 'best_model.zip'), env=env, policy=ActorCriticPolicy, device=device)
    else :
        # https://stable-baselines3.readthedocs.io/en/master/modules/ppo.html
        model = PPO(
            ActorCriticPolicy, 
            env, 
            verbose=2, 
            #tensorboard_log=log_dir, 
            policy_kwargs=policy_kwargs,
            clip_range=0.1,
            batch_size=128,
            n_epochs = 10,
            n_steps=2048, 
            learning_rate = 2.5e-5,
            device=device
        )

        def init_weights(m):
            m.weight.data.uniform_(-0.01, 0.01)
            m.bias.data.fill_(0.0)

        #print(model.policy)
        model.policy.action_net.apply(init_weights)
    
    model.learn(
        callback=callback,
        total_timesteps=1e8,
    )


    # Export.

    model = PPO.load(os.path.join(log_dir, 'best_model.zip'), env=env, policy=ActorCriticPolicy, device=device)

    util.trace_model(model, env, log_dir)



```

`learning/loco_env.py`:

```py
import gym
from gym import error, spaces, utils
from gym.utils import seeding
import numpy as np
import ctypes

class PhysicsDLL() :
    def __init__(self):
        self._physics = ctypes.CDLL('bin/Release_x86_64/Physics-Lib.dll')

        self._physics.updatePhysics.argtypes = (ctypes.POINTER(ctypes.c_float), ctypes.POINTER(ctypes.c_float))
        self._physics.resetPhysics.argtypes = (ctypes.POINTER(ctypes.c_float),)
        self._physics.getPhysicsRanges.argtypes = (ctypes.POINTER(ctypes.c_float), ctypes.POINTER(ctypes.c_float))

        self.state_size = self._physics.getPhysicsStateSize()
        self.action_size = self._physics.getPhysicsActionSize()
        
        state_min = (ctypes.c_float * self.state_size)(*([0] * self.state_size))
        state_max = (ctypes.c_float * self.state_size)(*([0] * self.state_size))
        action_min = (ctypes.c_float * self.action_size)(*([0] * self.action_size))
        action_max = (ctypes.c_float * self.action_size)(*([0] * self.action_size))
        self._physics.getPhysicsRanges(state_min, state_max, action_min, action_max)
        
        self.state_min = np.array([ state_min[i] if abs(state_min[i]) < 9999.0 else -np.inf      for i in range(self.state_size) ])
        self.state_max = np.array([ state_max[i] if abs(state_max[i]) < 9999.0 else np.inf       for i in range(self.state_size) ])
        self.action_min = np.array([ action_min[i] if abs(action_min[i]) < 9999.0 else -np.inf   for i in range(self.action_size) ])
        self.action_max = np.array([ action_max[i] if abs(action_max[i]) < 9999.0 else np.inf    for i in range(self.action_size) ])


    def reset(self):
        out_state = (ctypes.c_float * self.state_size)(*([0] * self.state_size))
        self._physics.resetPhysics(out_state)
        result_state = [ out_state[i] for i in range(self.state_size) ]
        return result_state

    def step(self, action):
        out_state = (ctypes.c_float * self.state_size)(*([0] * self.state_size))
        out_reward = (ctypes.c_float * 1)(*[0.0])
        action = (ctypes.c_float * self.action_size)(*action)

        done = self._physics.updatePhysics(action, out_state, out_reward)

        result_state = [ out_state[i] for i in range(self.state_size) ]

        return result_state, out_reward[0], done != 0


# https://blog.paperspace.com/creating-custom-environments-openai-gym/
# Simple example: https://github.com/openai/gym/blob/master/gym/envs/classic_control/pendulum.py

class LocoEnv(gym.Env):
    metadata = {'render.modes': ['human']}

    def __init__(self):
        super(LocoEnv, self).__init__()

        self.dll = PhysicsDLL()

        self.observation_space = spaces.Box(np.float32(self.dll.state_min), np.float32(self.dll.state_max))
        self.action_space = spaces.Box(np.float32(self.dll.action_min), np.float32(self.dll.action_max))

        self.reset()



    def step(self, action):
        new_state, reward, done = self.dll.step(action)
        return np.array(new_state, dtype=np.float32), reward, done, {}

    def reset(self):
        state = self.dll.reset()
        return np.array(state, dtype=np.float32)

    def render(self, mode='human', close=False):
        # Not implemented.
        pass
    


# For testing only.

def main():
    dll = PhysicsDLL()
    print(dll.action_size)

    action = list(range(dll.action_size))
    state, reward, done = dll.step(action)
    print(state, reward, done)

    state = dll.reset()
    print(state)

if __name__ == "__main__":
    main()


```

`learning/util.py`:

```py
import gym
import loco_env
import torch

from stable_baselines3.common.vec_env import SubprocVecEnv, DummyVecEnv, VecNormalize
from stable_baselines3.common.env_util import make_vec_env
from stable_baselines3.common.utils import set_random_seed
from stable_baselines3.common.monitor import Monitor

from vec_monitor import VecMonitor


def make_env(env_type, rank, seed=0):
    """
    Utility function for multiprocessed env.

    :param env_type: (type) the environment type
    :param num_env: (int) the number of environments you wish to have in subprocesses
    :param seed: (int) the inital seed for RNG
    :param rank: (int) index of the subprocess
    """
    def _init():
        env = env_type()
        env.seed(seed + rank)
        return env
    set_random_seed(seed)
    return _init


def make_loco_env(log_dir) :
    env_type = loco_env.LocoEnv
    num_cpu = 16
    
    env = SubprocVecEnv([make_env(env_type, i) for i in range(num_cpu)])
    env = VecMonitor(env, log_dir)
    torch.set_num_threads(num_cpu)
    return env


class ExportPolicy(torch.nn.Module):
    def __init__(self, policy) :
        super(ExportPolicy, self).__init__()
        self.policy = policy

    def forward(self, obs) :
        # This is what the ActorCriticPolicy does internally to compute the actions.

        # policies.py -> forward -> _get_latent
        features = self.policy.extract_features(obs)

        # policies.py -> forward -> _get_latent -> mlp_extractor -> forward
        shared_latent = self.policy.mlp_extractor.shared_net(features)
        latent_pi = self.policy.mlp_extractor.policy_net(shared_latent)

        # policies.py -> forward -> distribution.get_actions(deterministic=true) -> distribution.mode (do not sample).
        actions = self.policy.action_net(latent_pi)
        return actions
    

def trace_model(model, env, log_dir) :
    
    path = log_dir + "testexport.pt"
    
    example = torch.Tensor(env.observation_space.sample()).unsqueeze(0)
    
    policy = model.policy
    policy = ExportPolicy(policy)
    
    #print("Example input", example)
    #print("Example output", policy(example))

    traced_script_module = torch.jit.trace(policy, example)
    traced_script_module.save(path)

    print("Model traced to", path)

```

`learning/vec_monitor.py`:

```py
import time
import warnings
from typing import Dict, List, Optional, Tuple, Union

import numpy as np
import os
import os.path as osp
import csv
import json

from stable_baselines3.common.vec_env.base_vec_env import VecEnv, VecEnvObs, VecEnvStepReturn, VecEnvWrapper


class VecMonitor(VecEnvWrapper):
    """
    A vectorized monitor wrapper for *vectorized* Gym environments,
    it is used to record the episode reward, length, time and other data.
    Some environments like `openai/procgen <https://github.com/openai/procgen>`_
    or `gym3 <https://github.com/openai/gym3>`_ directly initialize the
    vectorized environments, without giving us a chance to use the ``Monitor``
    wrapper. So this class simply does the job of the ``Monitor`` wrapper on
    a vectorized level.
    :param venv: The vectorized environment
    :param filename: the location to save a log file, can be None for no log
    :param info_keywords: extra information to log, from the information return of env.step()
    """
    
    EXT = "monitor.csv"

    def __init__(
        self,
        venv: VecEnv,
        filename: Optional[str] = None,
        info_keywords: Tuple[str, ...] = (),
    ):
        # Avoid circular import
        from stable_baselines3.common.monitor import Monitor

        # This check is not valid for special `VecEnv`
        # like the ones created by Procgen, that does follow completely
        # the `VecEnv` interface
        try:
            is_wrapped_with_monitor = venv.env_is_wrapped(Monitor)[0]
        except AttributeError:
            is_wrapped_with_monitor = False

        if is_wrapped_with_monitor:
            warnings.warn(
                "The environment is already wrapped with a `Monitor` wrapper"
                "but you are wrapping it with a `VecMonitor` wrapper, the `Monitor` statistics will be"
                "overwritten by the `VecMonitor` ones.",
                UserWarning,
            )

        VecEnvWrapper.__init__(self, venv)
        self.episode_returns = None
        self.episode_lengths = None
        self.episode_count = 0
        self.t_start = time.time()

        env_id = None
        if hasattr(venv, "spec") and venv.spec is not None:
            env_id = venv.spec.id

        if filename:
            self.results_writer = ResultsWriter(
                filename, header={"t_start": self.t_start, "env_id": env_id}, extra_keys=info_keywords
            )
        else:
            self.results_writer = None
        self.info_keywords = info_keywords

    def reset(self) -> VecEnvObs:
        obs = self.venv.reset()
        self.episode_returns = np.zeros(self.num_envs, dtype=np.float32)
        self.episode_lengths = np.zeros(self.num_envs, dtype=np.int32)
        return obs

    def step_wait(self) -> VecEnvStepReturn:
        obs, rewards, dones, infos = self.venv.step_wait()
        self.episode_returns += rewards
        self.episode_lengths += 1
        new_infos = list(infos[:])
        for i in range(len(dones)):
            if dones[i]:
                info = infos[i].copy()
                episode_return = self.episode_returns[i]
                episode_length = self.episode_lengths[i]
                episode_info = {"r": episode_return, "l": episode_length, "t": round(time.time() - self.t_start, 6)}
                for k in self.info_keywords:
                    episode_info[k] = info[k]
                info["episode"] = episode_info
                self.episode_count += 1
                self.episode_returns[i] = 0
                self.episode_lengths[i] = 0
                if self.results_writer:
                    self.results_writer.write_row(episode_info)
                new_infos[i] = info
        return obs, rewards, dones, new_infos

    def close(self) -> None:
        if self.results_writer:
            self.results_writer.close()
        return self.venv.close()


class ResultsWriter(object):
    def __init__(self, filename, header='', extra_keys=()):
        print('Init resultswriter')
        self.extra_keys = extra_keys
        assert filename is not None
        if not filename.endswith(VecMonitor.EXT):
            if osp.isdir(filename):
                filename = osp.join(filename, VecMonitor.EXT)
            else:
                filename = filename #   + "." + VecMonitor.EXT
        self.f = open(filename, "wt")
        if isinstance(header, dict):
            header = '# {} \n'.format(json.dumps(header))
        self.f.write(header)
        self.logger = csv.DictWriter(self.f, fieldnames=('r', 'l', 't')+tuple(extra_keys))
        self.logger.writeheader()
        self.f.flush()

    def write_row(self, epinfo):
        if self.logger:
            self.logger.writerow(epinfo)
            self.f.flush() 

```

`premake/LICENSE.txt`:

```txt
Copyright (c) 2003-2019 Jason Perkins and individual contributors.
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  1. Redistributions of source code must retain the above copyright notice,
     this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright notice,
     this list of conditions and the following disclaimer in the documentation
     and/or other materials provided with the distribution.

  3. Neither the name of Premake nor the names of its contributors may be
     used to endorse or promote products derived from this software without
     specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`premake5.lua`:

```lua
local gpu_name = ""
local gpu_model_number = 0
local sdk_version = 0


-------------------------
-- CHECK GPU
-------------------------

local gpu_handle = io.popen("wmic path win32_VideoController get name")
local gpu_string = gpu_handle:read("*a")
gpu_handle:close()

for str in string.gmatch(gpu_string, "NVIDIA (.-)\n") do
	for model in string.gmatch(str, "%d%d%d%d?") do
		gpu_model_number = tonumber(model)
		gpu_name = str
	end
end


-------------------------
-- CHECK WINDOWS SDK
-------------------------

local sdk_directory = os.getenv("programfiles(x86)") .. "/Windows Kits/10/bin/"
local sdk_directory_handle = io.popen('dir "'..sdk_directory..'" /b')
for filename in sdk_directory_handle:lines() do
    for version in string.gmatch(filename, "10.0.(%d+).0") do
		local v = tonumber(version)
		if v > sdk_version then
			sdk_version = v
		end
	end
end
sdk_directory_handle:close()


print("Windows SDK version: ", sdk_version)
print("Installed GPU: ", gpu_name)

local turing_or_higher = gpu_model_number >= 1650

local new_sdk_version = 19041
local new_sdk_available = sdk_version >= new_sdk_version


local force_old_sdk = false

local sdk_version_string = "latest"
if force_old_sdk then
	sdk_version_string = "10.0.18362.0"
	new_sdk_available = false
end



local mesh_shaders_supported = turing_or_higher and new_sdk_available

if not mesh_shaders_supported then
	term.pushColor(term.infoColor)
	print("Disabling mesh shader compilation, since not all requirements are met.")
	term.popColor()
end


print("\n")


-------------------------
-- GENERATING SHADERS
-------------------------

print("Generating custom shaders..")

local generated_directory = "shaders/generated/"
os.mkdir(generated_directory)

local generated_directory_handle = io.popen('dir "'..generated_directory..'" /b')
for filename in generated_directory_handle:lines() do
	os.remove(generated_directory..filename)
end


local local_particle_system_directory = "particle_systems/"

local local_emit_path = "particles/particle_emit.hlsli"
local local_sim_path = "particles/particle_sim.hlsli"
local local_vs_path = "particles/particle_vs.hlsli"
local local_ps_path = "particles/particle_ps.hlsli"

local particle_system_directory = "shaders/" .. local_particle_system_directory
local shader_directory_handle = io.popen('dir "'..particle_system_directory..'" /b')

for filename in shader_directory_handle:lines() do
	if filename:sub(-string.len(".hlsli")) == ".hlsli" then
		local stem = filename:match("(.+)%..+")
		local compute_header = '#define PARTICLE_SIMULATION\n#include "random.hlsli"\n#include "../' .. local_particle_system_directory .. filename .. '"\n'
		local render_header = '#define PARTICLE_RENDERING\n#include "random.hlsli"\n#include "../' .. local_particle_system_directory .. filename .. '"\n'


		local new_emit_content = compute_header .. '#include "../' .. local_emit_path .. '"\n'
		local new_sim_content = compute_header .. '#include "../' .. local_sim_path .. '"\n'
		local new_vs_content = render_header .. '#include "../' .. local_vs_path .. '"\n'
		local new_ps_content = render_header .. '#include "../' .. local_ps_path .. '"\n'
	
		local emit_file = assert(io.open(generated_directory .. stem .. "_emit_cs.hlsl", "w"))
		emit_file:write(new_emit_content)
		emit_file:close()
	
		local sim_file = assert(io.open(generated_directory .. stem .. "_sim_cs.hlsl", "w"))
		sim_file:write(new_sim_content)
		sim_file:close()
		
		local vs_file = assert(io.open(generated_directory .. stem .. "_vs.hlsl", "w"))
		vs_file:write(new_vs_content)
		vs_file:close()
		
		local ps_file = assert(io.open(generated_directory .. stem .. "_ps.hlsl", "w"))
		ps_file:write(new_ps_content)
		ps_file:close()

		print("- Generated particle system '" .. stem .. "'.")
	end
end


print("\n")


-- Premake extension to include files at solution-scope. From https://github.com/premake/premake-core/issues/1061#issuecomment-441417853

require('vstudio')
premake.api.register {
	name = "workspacefiles",
	scope = "workspace",
	kind = "list:string",
}

premake.override(premake.vstudio.sln2005, "projects", function(base, wks)
	if wks.workspacefiles and #wks.workspacefiles > 0 then
		premake.push('Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{' .. os.uuid("Solution Items:"..wks.name) .. '}"')
		premake.push("ProjectSection(SolutionItems) = preProject")
		for _, file in ipairs(wks.workspacefiles) do
			file = path.rebase(file, ".", wks.location)
			premake.w(file.." = "..file)
		end
		premake.pop("EndProjectSection")
		premake.pop("EndProject")
	end
	base(wks)
end)


-----------------------------------------
-- GENERATE SOLUTION
-----------------------------------------

workspace "D3D12Renderer"
	architecture "x64"
	startproject "D3D12Renderer"

	configurations {
		"Debug",
		"Release"
	}

	flags {
		"MultiProcessorCompile"
	}
	
	workspacefiles {
        "premake5.lua",
		"README.md",
		"LICENSE",
    }


outputdir = "%{cfg.buildcfg}_%{cfg.architecture}"
shaderoutputdir = "shaders/bin/%{cfg.buildcfg}/"


group "Dependencies"
	include "ext/directxtex"
	include "ext/yaml-cpp"
group ""





-----------------------------------------
-- GENERATE MAIN PROGRAM
-----------------------------------------


project "D3D12Renderer"
	--location "bin/D3D12Renderer"
	kind "ConsoleApp"
	language "C++"
	cppdialect "C++17"
	staticruntime "Off"

	targetdir ("./bin/" .. outputdir)
	objdir ("./bin_int/" .. outputdir ..  "/%{prj.name}")

	debugenvs {
		"PATH=ext/bin;%PATH%;"
	}
	debugdir "."

	pchheader "pch.h"
	pchsource "src/pch.cpp"

	files {
		"src/**.h",
		"src/**.cpp",
		"shaders/**.hlsl*",
	}

	vpaths {
		["Headers/*"] = { "src/**.h" },
		["Sources/*"] = { "src/**.cpp" },
		["Shaders/*"] = { "shaders/**.hlsl" },
	}

	libdirs {
		"ext/lib",
	}

	links {
		"d3d12",
		"D3Dcompiler",
		"DXGI",
		"dxguid",
		"dxcompiler",
		"XAudio2",
		"uxtheme",
		"directxtex",
		"yaml-cpp",
	}

	dependson {
		"directxtex",
		"yaml-cpp",
	}

	includedirs {
		"src",
		"shaders/rs",
		"shaders/common",
		"shaders/particle_systems",
	}

	sysincludedirs {
		"ext/yaml-cpp/include",
		"ext/entt/src",
		"ext/directxtex",
		"ext",
	}

	prebuildcommands {
		"ECHO Compiling shaders...",
	}

	vectorextensions "AVX2"
	floatingpoint "Fast"

	filter "configurations:Debug"
        runtime "Debug"
		symbols "On"
		
	filter "configurations:Release"
        runtime "Release"
		optimize "On"
		inlining "Auto"

	filter "system:windows"
		systemversion (sdk_version_string)

		defines {
			"_UNICODE",
			"UNICODE",
			"_CRT_SECURE_NO_WARNINGS",
			"ENABLE_CPU_PROFILING=1",
			"ENABLE_DX_PROFILING=1",
			"ENABLE_MESSAGE_LOG=1",
		}

		defines { "SHADER_BIN_DIR=L\"" .. shaderoutputdir .. "\"" }

		if mesh_shaders_supported then
			defines { "MESH_SHADER_SUPPORTED "}
		end


	filter "files:**.hlsl"
		if turing_or_higher and new_sdk_available then
			shadermodel "6.5"
			shaderdefines {
				"SHADERMODEL=65"
			}
		elseif turing_or_higher then
			shadermodel "6.1"
			shaderdefines {
				"SHADERMODEL=61"
			}
		else
			shadermodel "5.1"
			shaderdefines {
				"SHADERMODEL=51"
			}
		end

		flags "ExcludeFromBuild"
		shaderobjectfileoutput(shaderoutputdir .. "%{file.basename}.cso")
		shaderincludedirs {
			"shaders/rs",
			"shaders/common"
		}
		shaderdefines {
			"HLSL",
			"mat4=float4x4",
			"mat4x3=float4x3",
			"mat3x4=float3x4",
			"vec2=float2",
			"vec3=float3",
			"vec4=float4",
			"int32=int",
			"uint32=uint",
			"uint64=uint64_t",
		}
	
		shaderoptions {
			"/WX",
			"/all_resources_bound",
		}
	
	if turing_or_higher then
		filter { "configurations:Debug", "files:**.hlsl" }
			shaderoptions {
				"/Qembed_debug",
			}
	end
		
 	
	filter("files:**_vs.hlsl")
		removeflags("ExcludeFromBuild")
		shadertype("Vertex")
 	
	filter("files:**_gs.hlsl")
		removeflags("ExcludeFromBuild")
		shadertype("Geometry")
 	
	filter("files:**_hs.hlsl")
		removeflags("ExcludeFromBuild")
		shadertype("Hull")
 	
	filter("files:**_ds.hlsl")
		removeflags("ExcludeFromBuild")
		shadertype("Domain")
	
	filter("files:**_ps.hlsl")
		removeflags("ExcludeFromBuild")
		shadertype("Pixel")
 	
	filter("files:**_cs.hlsl")
		removeflags("ExcludeFromBuild")
		shadertype("Compute")
		
	if mesh_shaders_supported then
		filter("files:**_ms.hlsl")
			removeflags("ExcludeFromBuild")
			shadertype("Mesh")
			shadermodel "6.5" -- Required for mesh shaders.
	
		filter("files:**_as.hlsl")
			removeflags("ExcludeFromBuild")
			shadertype("Amplification")
			shadermodel "6.5" -- Required for amplification shaders.
	end



-----------------------------------------
-- GENERATE PHYSICS ONLY DLL
-----------------------------------------

project "Physics-Lib"
	--location "bin/Physics-Lib"
	kind "SharedLib"
	language "C++"
	cppdialect "C++17"
	staticruntime "Off"

	targetdir ("./bin/" .. outputdir)
	objdir ("./bin_int/" .. outputdir ..  "/%{prj.name}")

	debugdir "."
	debugenvs {
		"PATH=ext/bin;%PATH%;"
	}

	pchheader "pch.h"
	pchsource "src/pch.cpp"

	includedirs {
		"src",
	}

	sysincludedirs {
		"ext/entt/src",
		"ext",
	}

	vectorextensions "AVX2"
	floatingpoint "Fast"

	files {
		"src/physics/bounding_volumes.*",
		"src/physics/collision_broad.*",
		"src/physics/collision_epa.*",
		"src/physics/collision_gjk.*",
		"src/physics/collision_narrow.*",
		"src/physics/collision_sat.*",
		"src/physics/constraints.*",
		"src/physics/physics.*",
		"src/physics/cloth.*",
		"src/physics/rigid_body.*",
		"src/physics/ragdoll.*",
		"src/physics/heightmap_collision.*",
		"src/learning/**",
		"src/core/math.*",
		"src/core/memory.*",
		"src/core/threading.*",
		"src/scene/scene.*",
		"src/terrain/heightmap_collider.*",
		"src/pch.*",
	}

	vpaths {
		["Headers/*"] = { "src/**.h" },
		["Sources/*"] = { "src/**.cpp" },
	}

	filter "system:windows"
		systemversion "latest"

		defines {
			"PHYSICS_ONLY",
			"_UNICODE",
			"UNICODE",
			"_CRT_SECURE_NO_WARNINGS",
			"ENABLE_CPU_PROFILING=0",
			"ENABLE_DX_PROFILING=0",
		}

	filter "configurations:Debug"
        runtime "Debug"
		symbols "On"
		
	filter "configurations:Release"
        runtime "Release"
		optimize "On"
		inlining "Auto"


```

`resources/fonts/icons/licence.txt`:

```txt
Copyright (c) 2017 Juliette Foucaut and Doug Binks

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.

```

`resources/fonts/opensans/LICENSE.txt`:

```txt

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`resources/icons/icons_ui.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   width="67.630486mm"
   height="67.630508mm"
   viewBox="0 0 67.630486 67.63051"
   version="1.1"
   id="svg5"
   inkscape:version="1.1.1 (3bf5ae0d25, 2021-09-20)"
   sodipodi:docname="icons_ui.svg"
   inkscape:export-filename="C:\Users\philipp\Documents\Projects\LGDV\D3D12Renderer\assets\icons\icons.png"
   inkscape:export-xdpi="50.980968"
   inkscape:export-ydpi="50.980968"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:svg="http://www.w3.org/2000/svg">
  <sodipodi:namedview
     id="namedview7"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageshadow="2"
     inkscape:pageopacity="0.0"
     inkscape:pagecheckerboard="0"
     inkscape:document-units="mm"
     showgrid="false"
     inkscape:zoom="2.8284271"
     inkscape:cx="29.168155"
     inkscape:cy="133.46641"
     inkscape:window-width="2560"
     inkscape:window-height="1377"
     inkscape:window-x="2552"
     inkscape:window-y="-8"
     inkscape:window-maximized="1"
     inkscape:current-layer="g10569"
     fit-margin-top="0"
     fit-margin-left="0"
     fit-margin-right="0"
     fit-margin-bottom="0" />
  <defs
     id="defs2">
    <marker
       style="overflow:visible"
       id="marker2307"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="TriangleOutL"
       inkscape:isstock="true">
      <path
         transform="scale(0.8)"
         style="fill:context-stroke;fill-rule:evenodd;stroke:context-stroke;stroke-width:1pt"
         d="M 5.77,0 -2.88,5 V -5 Z"
         id="path2305" />
    </marker>
    <marker
       style="overflow:visible"
       id="marker1798"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="TriangleOutL"
       inkscape:isstock="true">
      <path
         transform="scale(0.8)"
         style="fill:context-stroke;fill-rule:evenodd;stroke:context-stroke;stroke-width:1pt"
         d="M 5.77,0 -2.88,5 V -5 Z"
         id="path1796" />
    </marker>
    <marker
       style="overflow:visible"
       id="TriangleInL"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="TriangleInL"
       inkscape:isstock="true">
      <path
         transform="scale(-0.8)"
         style="fill:context-stroke;fill-rule:evenodd;stroke:context-stroke;stroke-width:1pt"
         d="M 5.77,0 -2.88,5 V -5 Z"
         id="path1653" />
    </marker>
    <marker
       style="overflow:visible"
       id="TriangleOutL"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="TriangleOutL"
       inkscape:isstock="true">
      <path
         transform="scale(0.8)"
         style="fill:context-stroke;fill-rule:evenodd;stroke:context-stroke;stroke-width:1pt"
         d="M 5.77,0 -2.88,5 V -5 Z"
         id="path1662" />
    </marker>
    <marker
       style="overflow:visible"
       id="marker2307-6"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="TriangleOutL"
       inkscape:isstock="true">
      <path
         transform="scale(0.8)"
         style="fill:context-stroke;fill-rule:evenodd;stroke:context-stroke;stroke-width:1pt"
         d="M 5.77,0 -2.88,5 V -5 Z"
         id="path2305-7" />
    </marker>
    <marker
       style="overflow:visible"
       id="marker2307-5"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="TriangleOutL"
       inkscape:isstock="true">
      <path
         transform="scale(0.8)"
         style="fill:context-stroke;fill-rule:evenodd;stroke:context-stroke;stroke-width:1pt"
         d="M 5.77,0 -2.88,5 V -5 Z"
         id="path2305-2" />
    </marker>
    <marker
       style="overflow:visible"
       id="marker2307-6-1"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="TriangleOutL"
       inkscape:isstock="true">
      <path
         transform="scale(0.8)"
         style="fill:context-stroke;fill-rule:evenodd;stroke:context-stroke;stroke-width:1pt"
         d="M 5.77,0 -2.88,5 V -5 Z"
         id="path2305-7-0" />
    </marker>
    <marker
       style="overflow:visible"
       id="marker2307-3"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="TriangleOutL"
       inkscape:isstock="true">
      <path
         transform="scale(0.8)"
         style="fill:context-stroke;fill-rule:evenodd;stroke:context-stroke;stroke-width:1pt"
         d="M 5.77,0 -2.88,5 V -5 Z"
         id="path2305-0" />
    </marker>
    <marker
       style="overflow:visible"
       id="marker2307-5-4"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="TriangleOutL"
       inkscape:isstock="true">
      <path
         transform="scale(0.8)"
         style="fill:context-stroke;fill-rule:evenodd;stroke:context-stroke;stroke-width:1pt"
         d="M 5.77,0 -2.88,5 V -5 Z"
         id="path2305-2-0" />
    </marker>
    <marker
       style="overflow:visible"
       id="marker2307-6-0"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="TriangleOutL"
       inkscape:isstock="true">
      <path
         transform="scale(0.8)"
         style="fill:context-stroke;fill-rule:evenodd;stroke:context-stroke;stroke-width:1pt"
         d="M 5.77,0 -2.88,5 V -5 Z"
         id="path2305-7-9" />
    </marker>
    <marker
       style="overflow:visible"
       id="marker2307-5-7"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="TriangleOutL"
       inkscape:isstock="true">
      <path
         transform="scale(0.8)"
         style="fill:context-stroke;fill-rule:evenodd;stroke:context-stroke;stroke-width:1pt"
         d="M 5.77,0 -2.88,5 V -5 Z"
         id="path2305-2-6" />
    </marker>
    <marker
       style="overflow:visible"
       id="marker2307-8"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="TriangleOutL"
       inkscape:isstock="true">
      <path
         transform="scale(0.8)"
         style="fill:context-stroke;fill-rule:evenodd;stroke:context-stroke;stroke-width:1pt"
         d="M 5.77,0 -2.88,5 V -5 Z"
         id="path2305-3" />
    </marker>
    <marker
       style="overflow:visible"
       id="marker2307-8-7"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="TriangleOutL"
       inkscape:isstock="true">
      <path
         transform="scale(0.8)"
         style="fill:context-stroke;fill-rule:evenodd;stroke:context-stroke;stroke-width:1pt"
         d="M 5.77,0 -2.88,5 V -5 Z"
         id="path2305-3-4" />
    </marker>
    <marker
       style="overflow:visible"
       id="marker2307-8-3"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="TriangleOutL"
       inkscape:isstock="true">
      <path
         transform="scale(0.8)"
         style="fill:context-stroke;fill-rule:evenodd;stroke:context-stroke;stroke-width:1pt"
         d="M 5.77,0 -2.88,5 V -5 Z"
         id="path2305-3-1" />
    </marker>
    <marker
       style="overflow:visible"
       id="TriangleInL-9"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="TriangleInL"
       inkscape:isstock="true">
      <path
         transform="scale(-0.8)"
         style="fill:context-stroke;fill-rule:evenodd;stroke:context-stroke;stroke-width:1pt"
         d="M 5.77,0 -2.88,5 V -5 Z"
         id="path1653-8" />
    </marker>
    <marker
       style="overflow:visible"
       id="marker2307-8-9"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="TriangleOutL"
       inkscape:isstock="true">
      <path
         transform="scale(0.8)"
         style="fill:context-stroke;fill-rule:evenodd;stroke:context-stroke;stroke-width:1pt"
         d="M 5.77,0 -2.88,5 V -5 Z"
         id="path2305-3-0" />
    </marker>
    <marker
       style="overflow:visible"
       id="marker2307-0"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="TriangleOutL"
       inkscape:isstock="true">
      <path
         transform="scale(0.8)"
         style="fill:context-stroke;fill-rule:evenodd;stroke:context-stroke;stroke-width:1pt"
         d="M 5.77,0 -2.88,5 V -5 Z"
         id="path2305-6" />
    </marker>
    <marker
       style="overflow:visible"
       id="marker2307-55"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="TriangleOutL"
       inkscape:isstock="true">
      <path
         transform="scale(0.8)"
         style="fill:context-stroke;fill-rule:evenodd;stroke:context-stroke;stroke-width:1pt"
         d="M 5.77,0 -2.88,5 V -5 Z"
         id="path2305-9" />
    </marker>
    <marker
       style="overflow:visible"
       id="marker2307-04"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="TriangleOutL"
       inkscape:isstock="true">
      <path
         transform="scale(0.8)"
         style="fill:context-stroke;fill-rule:evenodd;stroke:context-stroke;stroke-width:1pt"
         d="M 5.77,0 -2.88,5 V -5 Z"
         id="path2305-8" />
    </marker>
    <marker
       style="overflow:visible"
       id="marker2307-5-8"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="TriangleOutL"
       inkscape:isstock="true">
      <path
         transform="scale(0.8)"
         style="fill:context-stroke;fill-rule:evenodd;stroke:context-stroke;stroke-width:1pt"
         d="M 5.77,0 -2.88,5 V -5 Z"
         id="path2305-2-2" />
    </marker>
    <marker
       style="overflow:visible"
       id="marker2307-5-4-9"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="TriangleOutL"
       inkscape:isstock="true">
      <path
         transform="scale(0.8)"
         style="fill:context-stroke;fill-rule:evenodd;stroke:context-stroke;stroke-width:1pt"
         d="M 5.77,0 -2.88,5 V -5 Z"
         id="path2305-2-0-7" />
    </marker>
    <marker
       style="overflow:visible"
       id="marker2307-6-1-0"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="TriangleOutL"
       inkscape:isstock="true">
      <path
         transform="scale(0.8)"
         style="fill:context-stroke;fill-rule:evenodd;stroke:context-stroke;stroke-width:1pt"
         d="M 5.77,0 -2.88,5 V -5 Z"
         id="path2305-7-0-1" />
    </marker>
    <marker
       style="overflow:visible"
       id="marker2307-3-2"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="TriangleOutL"
       inkscape:isstock="true">
      <path
         transform="scale(0.8)"
         style="fill:context-stroke;fill-rule:evenodd;stroke:context-stroke;stroke-width:1pt"
         d="M 5.77,0 -2.88,5 V -5 Z"
         id="path2305-0-9" />
    </marker>
    <marker
       style="overflow:visible"
       id="marker2307-55-1"
       refX="0"
       refY="0"
       orient="auto"
       inkscape:stockid="TriangleOutL"
       inkscape:isstock="true">
      <path
         transform="scale(0.8)"
         style="fill:context-stroke;fill-rule:evenodd;stroke:context-stroke;stroke-width:1pt"
         d="M 5.77,0 -2.88,5 V -5 Z"
         id="path2305-9-8" />
    </marker>
  </defs>
  <g
     inkscape:groupmode="layer"
     id="layer2"
     inkscape:label="Grid"
     style="display:inline"
     transform="translate(-19.050594,-84.884584)">
    <rect
       style="fill:none;fill-opacity:1;stroke:#000000;stroke-width:0.0662805;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect10250-2-6"
       width="16.891052"
       height="16.891052"
       x="69.756889"
       y="84.917725" />
    <rect
       style="fill:none;fill-opacity:1;stroke:#000000;stroke-width:0.0662805;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect10250"
       width="16.891052"
       height="16.891052"
       x="-35.974789"
       y="84.917725"
       transform="scale(-1,1)" />
    <rect
       style="fill:none;fill-opacity:1;stroke:#000000;stroke-width:0.0662805;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect10250-2"
       width="16.891052"
       height="16.891052"
       x="35.974789"
       y="84.917725" />
    <rect
       style="fill:none;fill-opacity:1;stroke:#000000;stroke-width:0.0662805;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect10250-9"
       width="16.891052"
       height="16.891052"
       x="19.083735"
       y="101.80875" />
    <rect
       style="fill:none;fill-opacity:1;stroke:#000000;stroke-width:0.0662805;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect10250-2-3"
       width="16.891052"
       height="16.891052"
       x="35.974789"
       y="101.80875" />
    <rect
       style="fill:none;fill-opacity:1;stroke:#000000;stroke-width:0.0662805;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect10250-21"
       width="16.891052"
       height="16.891052"
       x="52.865845"
       y="84.917725" />
    <rect
       style="fill:none;fill-opacity:1;stroke:#000000;stroke-width:0.0662805;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect10250-9-0"
       width="16.891052"
       height="16.891052"
       x="52.865845"
       y="101.80878" />
    <rect
       style="fill:none;fill-opacity:1;stroke:#000000;stroke-width:0.0662805;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect10250-2-3-6"
       width="16.891052"
       height="16.891052"
       x="69.756889"
       y="101.80878" />
    <rect
       style="fill:none;fill-opacity:1;stroke:#000000;stroke-width:0.0662805;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect10250-4"
       width="16.891052"
       height="16.891052"
       x="19.083735"
       y="118.69981" />
    <rect
       style="fill:none;fill-opacity:1;stroke:#000000;stroke-width:0.0662805;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect10250-2-4"
       width="16.891052"
       height="16.891052"
       x="35.974792"
       y="118.69981" />
    <rect
       style="fill:none;fill-opacity:1;stroke:#000000;stroke-width:0.0662805;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect10250-9-6"
       width="16.891052"
       height="16.891052"
       x="19.083735"
       y="135.59088" />
    <rect
       style="fill:none;fill-opacity:1;stroke:#000000;stroke-width:0.0662805;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect10250-2-3-2"
       width="16.891052"
       height="16.891052"
       x="35.974792"
       y="135.59088" />
    <rect
       style="fill:none;fill-opacity:1;stroke:#000000;stroke-width:0.0662805;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect10250-21-4"
       width="16.891052"
       height="16.891052"
       x="52.865845"
       y="118.69981" />
    <rect
       style="fill:none;fill-opacity:1;stroke:#000000;stroke-width:0.0662805;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect10250-2-6-1"
       width="16.891052"
       height="16.891052"
       x="69.756889"
       y="118.69981" />
    <rect
       style="fill:none;fill-opacity:1;stroke:#000000;stroke-width:0.0662805;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect10250-9-0-0"
       width="16.891052"
       height="16.891052"
       x="52.865845"
       y="135.5909" />
    <rect
       style="fill:none;fill-opacity:1;stroke:#000000;stroke-width:0.0662805;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect10250-2-3-6-8"
       width="16.891052"
       height="16.891052"
       x="69.756889"
       y="135.5909" />
  </g>
  <g
     inkscape:label="Icons"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(-19.050594,-84.884584)">
    <g
       id="g10569"
       transform="matrix(0.3269758,0,0,0.3269758,59.924635,39.834259)">
      <g
         id="g9277">
        <path
           d="m -67.917427,144.53271 18.416734,7.11014 20.271355,-3.18127 -23.750743,-5.68593 z"
           style="fill:#dbdbdb;fill-opacity:1;fill-rule:evenodd;stroke:#ffffff;stroke-width:1.025;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
           id="path4971" />
        <path
           d="m -49.500693,151.64285 v 34.93741 l 20.271355,-6.18208 v -31.9366 z"
           style="fill:#e6e6e6;fill-opacity:1;fill-rule:evenodd;stroke:#ffffff;stroke-width:1.025;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
           id="path4973" />
        <path
           d="m -67.917427,144.53271 18.416734,7.11014 v 34.93741 l -18.416734,-18.85634 z"
           style="fill:#a3a3a3;fill-opacity:1;fill-rule:evenodd;stroke:#ffffff;stroke-width:1.025;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
           id="path4975" />
      </g>
      <g
         id="path2303-9">
        <path
           style="color:#000000;fill:#00ff00;-inkscape-stroke:none"
           d="m -50.033203,151.64258 v 34.9375 h 1.064453 v -34.9375 z"
           id="path1981" />
        <g
           id="g1969">
          <g
             id="path1971">
            <path
               style="color:#000000;fill:#00ff00;fill-rule:evenodd;stroke-width:0.852344pt;-inkscape-stroke:none"
               d="m -49.500693,146.72482 4.26172,7.37278 h -8.52344 z"
               id="path1975" />
            <path
               style="color:#000000;fill:#00ff00;fill-rule:evenodd;-inkscape-stroke:none"
               d="m -49.5,145.58984 -0.492187,0.85157 -4.75586,8.22461 h 10.494141 z m 0,2.27149 3.275391,5.66797 h -6.550782 z"
               id="path1977" />
          </g>
        </g>
      </g>
      <path
         style="fill:none;stroke:#00ff00;stroke-width:3.03089;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
         d="M -49.500693,186.58026 V 151.64285"
         id="path2303-9-4"
         sodipodi:nodetypes="cc" />
      <g
         id="path2303-4-4">
        <path
           style="color:#000000;fill:#0000ff;-inkscape-stroke:none"
           d="m -67.537109,167.35156 -0.761719,0.74414 18.417969,18.85742 0.761718,-0.74414 z"
           id="path1667" />
        <g
           id="g1654">
          <g
             id="path1656">
            <path
               style="color:#000000;fill:#0000ff;fill-rule:evenodd;stroke-width:0.852pt;-inkscape-stroke:none"
               d="m -71.352354,164.20699 8.197005,2.29579 -6.095182,5.95308 z"
               id="path1660" />
            <path
               style="color:#000000;fill:#0000ff;fill-rule:evenodd;-inkscape-stroke:none"
               d="m -72.144531,163.39453 0.242187,0.95313 2.34375,9.20312 7.503907,-7.33008 z m 1.583984,1.625 6.304688,1.76367 -4.6875,4.57813 z"
               id="path1663" />
          </g>
        </g>
      </g>
      <path
         style="fill:none;stroke:#0000ff;stroke-width:3.03089;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
         d="M -49.500693,186.58026 -67.917427,167.72391"
         id="path2303-4-4-4"
         sodipodi:nodetypes="cc" />
      <g
         id="path2303-5-2">
        <path
           style="color:#000000;fill:#ff1000;-inkscape-stroke:none"
           d="m -29.384766,179.88867 -20.271484,6.18164 0.310547,1.01953 20.271484,-6.18164 z"
           id="path1864" />
        <g
           id="g1852">
          <g
             id="path1854">
            <path
               style="color:#000000;fill:#ff1000;fill-rule:evenodd;stroke-width:0.852pt;-inkscape-stroke:none"
               d="m -24.527102,178.96416 -5.806624,6.22452 -2.485311,-8.14946 z"
               id="path1858" />
            <path
               style="color:#000000;fill:#ff1000;fill-rule:evenodd;-inkscape-stroke:none"
               d="m -33.650391,176.26367 3.060547,10.0332 7.148438,-7.66406 -0.957031,-0.22265 z m 1.66211,1.55078 6.375,1.48047 -4.464844,4.78516 z"
               id="path1860" />
          </g>
        </g>
      </g>
      <path
         style="fill:none;stroke:#ff1000;stroke-width:3.03089;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
         d="m -49.500688,186.58026 20.27135,-6.18208"
         id="path2303-5-2-0"
         sodipodi:nodetypes="cc" />
    </g>
    <g
       id="g10679"
       transform="matrix(0.53470452,0,0,0.53470452,91.929618,13.474686)">
      <g
         id="path2303-4">
        <path
           style="color:#000000;fill:#0000ff;-inkscape-stroke:none"
           d="m -127.85938,155.45117 -4.01953,5.2461 0.44922,0.34179 4.01758,-5.24414 z"
           id="path1477" />
        <g
           id="g1465">
          <g
             id="path1467">
            <path
               style="color:#000000;fill:#0000ff;fill-rule:evenodd;stroke-width:0.451767pt;-inkscape-stroke:none"
               d="m -126.05031,153.55386 -0.58349,4.47579 -3.58617,-2.7475 z"
               id="path1471" />
            <path
               style="color:#000000;fill:#0000ff;fill-rule:evenodd;-inkscape-stroke:none"
               d="m -125.68359,153.07617 -0.48243,0.19922 -4.65234,1.92773 4.41602,3.38282 z m -0.73243,0.95508 -0.44921,3.44336 -2.75782,-2.11328 z"
               id="path1473" />
          </g>
        </g>
      </g>
      <path
         style="fill:none;stroke:#0000ff;stroke-width:1.85342;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
         d="m -131.65403,160.86813 4.01842,-5.24505"
         id="path2303-4-49"
         sodipodi:nodetypes="cc" />
      <g
         id="g1356"
         transform="matrix(0.05538555,0,0,0.05538555,-139.2485,161.50079)">
        <g
           id="g1294">
          <g
             id="g1292"
             transform="translate(167.72614,-402.54274)">
            <g
               id="g1290">
              <g
                 id="g2163"
                 style="fill:#ffffff;fill-opacity:1">
                <polygon
                   points="260.677,88.517 266.998,87.913 270.251,84.021 266.788,82.678 264.883,80.488 262.024,75.858 260.677,69.329 255.286,70.409 253.799,72.721 253.799,75.312 256.378,77.084 260.072,79.408 260.398,82.045 256.447,82.882 255.913,88.517 "
                   id="polygon1278"
                   style="fill:#ffffff;fill-opacity:1" />
                <polygon
                   points="248.768,86.344 255.495,81.569 255.773,78.037 252.637,76.683 248.233,77.706 244.945,82.94 244.945,86.344 "
                   id="polygon1280"
                   style="fill:#ffffff;fill-opacity:1" />
                <path
                   d="m 164.852,96.598 -0.976,2.498 h -4.7 v 2.428 h 1.121 c 0,0 0.07,0.511 0.168,1.191 l 2.876,-0.238 1.783,-1.121 0.465,-2.248 2.335,-0.204 0.912,-1.888 -2.138,-0.442 z"
                   id="path1282"
                   style="fill:#ffffff;fill-opacity:1" />
                <polygon
                   points="154.279,99.096 152.739,101.001 152.565,103.366 155.976,103.081 156.324,100.705 "
                   id="polygon1284"
                   style="fill:#ffffff;fill-opacity:1" />
                <path
                   d="m 356.868,176.633 c -0.047,-5.223 -0.313,-10.398 -0.802,-15.505 -1.662,-17.01 -5.717,-33.311 -11.828,-48.589 -0.441,-1.127 -0.859,-2.283 -1.336,-3.41 -8.121,-19.183 -19.531,-36.646 -33.474,-51.721 -0.906,-0.987 -1.835,-1.952 -2.765,-2.916 -2.649,-2.736 -5.333,-5.415 -8.156,-7.971 C 266.788,17.631 224.642,0 178.463,0 131.896,0 89.447,17.957 57.635,47.271 50.222,54.103 43.414,61.574 37.227,69.556 13.919,99.717 0,137.49 0,178.463 c 0,98.398 80.059,178.463 178.463,178.463 69.225,0 129.316,-39.643 158.897,-97.399 6.32,-12.327 11.247,-25.491 14.569,-39.294 0.837,-3.486 1.58,-7.018 2.208,-10.585 1.801,-10.137 2.788,-20.56 2.788,-31.196 -0.023,-0.593 -0.057,-1.203 -0.057,-1.819 z m -33.59,-71.327 1.022,-1.162 c 1.359,2.637 2.649,5.304 3.846,8.028 l -1.708,-0.07 -3.172,0.436 v -7.233 h 0.012 z m -25.794,-31.15 0.023,-7.971 c 2.812,2.975 5.508,6.036 8.087,9.214 l -3.207,4.781 -11.247,-0.111 -0.696,-2.341 z M 82.214,54.364 v -0.302 h 3.567 l 0.325,-1.226 h 5.838 v 2.55 l -1.691,2.236 h -8.052 v -3.259 h 0.013 z m 5.711,7.959 c 0,0 3.578,-0.61 3.892,-0.61 0.296,0 0,3.573 0,3.573 l -8.081,0.511 -1.534,-1.847 z m 246.717,70.833 h -13.06 l -7.971,-5.92 -8.365,0.808 v 5.112 h -2.648 l -2.848,-2.033 -14.512,-3.671 v -9.4 l -18.38,1.423 -5.705,3.062 h -7.285 l -3.59,-0.36 -8.854,4.926 v 9.254 l -18.097,13.065 1.5,5.583 h 3.677 l -0.964,5.315 -2.58,0.953 -0.133,13.884 15.633,17.823 h 6.819 l 0.407,-1.081 h 12.246 l 3.531,-3.265 h 6.948 l 3.812,3.811 10.328,1.069 -1.359,13.757 11.503,20.28 -6.064,11.572 0.406,5.438 4.775,4.752 v 13.095 l 6.251,8.412 v 10.897 h 5.391 c -30.046,36.913 -75.823,60.534 -127.026,60.534 -90.312,0 -163.783,-73.454 -163.783,-163.777 0,-22.732 4.665,-44.401 13.077,-64.089 v -5.106 l 5.855,-7.11 c 2.033,-3.846 4.212,-7.582 6.542,-11.235 l 0.25,2.974 -6.791,8.261 c -2.108,3.985 -4.084,8.052 -5.855,12.217 v 9.312 l 6.791,3.276 v 12.955 l 6.535,11.136 5.316,0.808 0.68,-3.817 -6.245,-9.661 -1.237,-9.388 h 3.677 l 1.557,9.673 9.051,13.193 -2.33,4.27 5.734,8.795 14.291,3.532 v -2.306 l 5.711,0.808 -0.534,4.078 4.484,0.825 6.948,1.888 9.8,11.171 12.507,0.941 1.237,10.207 -8.58,5.984 -0.39,9.115 -1.237,5.588 12.386,15.5 0.947,5.32 c 0,0 4.49,1.209 5.048,1.209 0.535,0 10.062,7.227 10.062,7.227 v 28.024 l 3.393,0.964 -2.294,12.92 5.71,7.634 -1.068,12.827 7.563,13.269 9.696,8.47 9.731,0.197 0.952,-3.148 -7.163,-6.029 0.418,-2.986 1.272,-3.684 0.273,-3.741 -4.839,-0.14 -2.44,-3.066 4.021,-3.881 0.546,-2.916 -4.496,-1.29 0.261,-2.719 6.402,-0.976 9.73,-4.672 3.265,-6.006 10.196,-13.06 -2.312,-10.213 3.131,-5.438 9.399,0.278 6.327,-5.02 2.051,-19.693 7.04,-8.877 1.237,-5.704 -6.39,-2.045 -4.224,-6.942 -14.419,-0.145 -11.444,-4.351 -0.534,-8.162 -3.811,-6.675 -10.335,-0.145 -5.995,-9.382 -5.298,-2.585 -0.273,2.858 -9.672,0.569 -3.532,-4.926 -10.079,-2.045 -8.302,9.603 -13.065,-2.23 -0.953,-14.727 -9.527,-1.632 3.805,-7.221 -1.092,-4.148 -12.531,8.371 -7.877,-0.964 -2.817,-6.158 1.737,-6.355 4.339,-8.005 9.998,-5.072 h 19.322 l -0.064,5.891 6.948,3.235 -0.558,-10.062 5.007,-5.037 10.103,-6.64 0.703,-4.659 10.068,-10.486 10.707,-5.937 -0.941,-0.773 7.256,-6.826 2.655,0.703 1.214,1.522 2.76,-3.062 0.68,-0.296 -3.021,-0.43 -3.084,-0.987 v -2.963 l 1.632,-1.33 h 3.579 l 1.655,0.726 1.418,2.858 1.737,-0.267 v -0.244 l 0.5,0.163 5.02,-0.772 0.714,-2.463 2.852,0.726 v 2.667 l -2.666,1.818 h 0.018 l 0.377,2.928 9.115,2.794 c 0,0 0,0.035 0.023,0.11 l 2.079,-0.18 0.146,-3.939 -7.209,-3.282 -0.396,-1.894 5.972,-2.033 0.273,-5.722 -6.245,-3.805 -0.412,-9.667 -8.581,4.218 h -3.143 l 0.837,-7.355 -11.688,-2.748 -4.816,3.654 v 11.119 l -8.673,2.754 -3.486,7.244 -3.758,0.604 v -9.277 l -8.162,-1.133 -4.096,-2.667 -1.639,-6.007 14.611,-8.54 7.14,-2.179 0.72,4.804 3.991,-0.215 0.308,-2.411 4.166,-0.599 0.07,-0.842 -1.784,-0.738 -0.407,-2.544 5.118,-0.43 3.091,-3.213 0.18,-0.238 0.035,0.012 0.941,-0.976 10.753,-1.354 4.746,4.032 -12.467,6.64 15.871,3.747 2.045,-5.31 h 6.948 l 2.44,-4.625 -4.903,-1.226 v -5.856 l -15.359,-6.803 -10.62,1.226 -6.001,3.125 0.407,7.628 -6.257,-0.953 -0.964,-4.212 6.007,-5.449 -10.898,-0.535 -3.125,0.953 -1.359,3.677 4.084,0.686 -0.813,4.084 -6.936,0.406 -1.092,2.725 -10.075,0.277 c 0,0 -0.273,-5.711 -0.703,-5.711 -0.389,0 7.901,-0.145 7.901,-0.145 l 5.995,-5.85 -3.271,-1.632 -4.339,4.223 -7.222,-0.406 -4.403,-6.019 h -9.254 l -9.661,7.21 h 8.848 l 0.796,2.597 -2.307,2.172 9.807,0.279 1.487,3.532 -11.032,-0.407 -0.546,-2.725 -6.925,-1.499 -3.689,-2.033 -8.255,0.069 c 27.043,-19.699 60.284,-31.358 96.226,-31.358 41.403,0 79.263,15.476 108.124,40.915 l -1.929,3.474 -7.564,2.962 -3.194,3.462 0.743,4.02 3.893,0.546 2.358,5.867 6.704,-2.713 1.127,7.86 h -2.045 l -5.519,-0.819 -6.111,1.022 -5.926,8.377 -8.458,1.319 -1.221,7.25 3.579,0.842 -1.046,4.665 -8.412,-1.69 -7.703,1.69 -1.639,4.293 1.325,9.01 4.531,2.115 7.61,-0.046 5.123,-0.465 1.58,-4.078 8.018,-10.422 5.264,1.081 5.193,-4.7 0.976,3.678 12.78,8.621 -1.557,2.108 -5.763,-0.308 2.23,3.137 3.556,0.79 4.159,-1.737 -0.093,-5.002 1.859,-0.923 -1.487,-1.575 -8.528,-4.758 -2.254,-6.314 h 7.099 l 2.243,2.248 6.134,5.257 0.244,6.367 6.332,6.733 2.348,-9.231 4.392,-2.394 0.802,7.552 4.287,4.7 8.54,-0.139 c 1.661,4.247 3.148,8.563 4.427,12.978 z M 97.324,81.092 l 4.27,-2.044 3.881,0.929 -1.324,5.211 -4.183,1.319 z m 22.749,12.258 v 3.37 h -9.783 l -3.689,-1.028 0.918,-2.341 4.7,-1.94 h 6.437 v 1.94 h 1.417 z m 4.509,4.7 v 3.259 l -2.463,1.58 -3.044,0.575 c 0,0 0,-4.903 0,-5.415 h 5.507 z m -2.76,-1.33 v -3.893 l 3.363,3.067 z m 1.533,7.848 v 3.178 l -2.347,2.347 h -5.211 l 0.813,-3.573 2.463,-0.215 0.5,-1.226 z M 110.39,98.05 h 5.408 l -6.948,9.696 -2.852,-1.534 0.616,-4.084 z m 22.139,5.414 v 3.166 h -5.211 l -1.417,-2.062 v -2.951 h 0.406 z m -4.781,-4.368 1.475,-1.557 2.498,1.557 -1.999,1.656 z m 209.543,42.332 0.511,-0.61 c 0.232,0.93 0.441,1.859 0.662,2.789 z"
                   id="path1286"
                   style="fill:#ffffff;fill-opacity:1" />
                <path
                   d="m 27.734,109.268 v 5.106 c 1.771,-4.177 3.747,-8.231 5.855,-12.223 z"
                   id="path1288"
                   style="fill:#ffffff;fill-opacity:1" />
              </g>
            </g>
          </g>
        </g>
        <g
           id="g1296" />
        <g
           id="g1298" />
        <g
           id="g1300" />
        <g
           id="g1302" />
        <g
           id="g1304" />
        <g
           id="g1306" />
        <g
           id="g1308" />
        <g
           id="g1310" />
        <g
           id="g1312" />
        <g
           id="g1314" />
        <g
           id="g1316" />
        <g
           id="g1318" />
        <g
           id="g1320" />
        <g
           id="g1322" />
        <g
           id="g1324" />
      </g>
      <g
         id="path2303">
        <path
           style="color:#000000;fill:#00ff00;-inkscape-stroke:none"
           d="m -131.93555,139.76172 v 21.10547 h 0.56446 v -21.10547 z"
           id="path1299" />
        <g
           id="g1286">
          <g
             id="path1289">
            <path
               style="color:#000000;fill:#00ff00;fill-rule:evenodd;stroke-width:0.451767pt;-inkscape-stroke:none"
               d="m -131.65403,137.15549 2.25884,3.90779 h -4.51768 z"
               id="path1293" />
            <path
               style="color:#000000;fill:#00ff00;fill-rule:evenodd;-inkscape-stroke:none"
               d="m -131.6543,136.55273 -0.25976,0.45118 -2.52149,4.36132 h 5.5625 z m 0,1.20508 1.73633,3.00391 h -3.47265 z"
               id="path1295" />
          </g>
        </g>
      </g>
      <path
         style="fill:none;stroke:#00ff00;stroke-width:1.85342;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
         d="M -131.65403,160.86813 V 139.76219"
         id="path2303-3"
         sodipodi:nodetypes="cc" />
      <path
         style="fill:none;stroke:#ff0000;stroke-width:1.85342;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
         d="m -131.65403,160.86813 h 21.10595"
         id="path2303-3-5"
         sodipodi:nodetypes="cc" />
      <g
         id="path2303-5">
        <path
           style="color:#000000;fill:#ff0000;-inkscape-stroke:none"
           d="m -131.6543,160.58594 v 0.56445 h 21.10547 v -0.56445 z"
           id="path1459" />
        <g
           id="g1447">
          <g
             id="path1449">
            <path
               style="color:#000000;fill:#ff0000;fill-rule:evenodd;stroke-width:0.451767pt;-inkscape-stroke:none"
               d="m -107.94138,160.86813 -3.90779,2.25884 v -4.51768 z"
               id="path1453" />
            <path
               style="color:#000000;fill:#ff0000;fill-rule:evenodd;-inkscape-stroke:none"
               d="m -112.15039,158.08789 v 5.56055 l 4.81055,-2.78125 -0.45118,-0.25977 z m 0.60156,1.04297 3.00586,1.73633 -3.00586,1.73828 z"
               id="path1455" />
          </g>
        </g>
      </g>
      <g
         id="path2303-8">
        <path
           style="color:#000000;fill:#ffffff;-inkscape-stroke:none"
           d="m -112.75977,172.99023 -11.33007,11.02735 0.39257,0.40429 11.33008,-11.02539 z"
           id="path2289" />
        <g
           id="g2277">
          <g
             id="path2279">
            <path
               style="color:#000000;fill:#ffffff;fill-rule:evenodd;stroke-width:0.451767pt;-inkscape-stroke:none"
               d="m -110.69572,171.37543 -1.22506,4.34423 -3.15082,-3.23755 z"
               id="path2283" />
            <path
               style="color:#000000;fill:#ffffff;fill-rule:evenodd;-inkscape-stroke:none"
               d="m -110.26367,170.95508 -0.50586,0.1289 -4.88281,1.23438 3.8789,3.98633 z m -0.86524,0.84179 -0.93945,3.3379 -2.42383,-2.48829 z"
               id="path2285" />
          </g>
        </g>
      </g>
      <path
         style="fill:none;stroke:#fdffff;stroke-width:1.85342;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
         d="m -123.89362,184.2198 11.32984,-11.02635"
         id="path2303-8-8"
         sodipodi:nodetypes="cc" />
      <g
         id="g1117"
         transform="matrix(0.53024554,0,0,0.53024554,-64.026476,62.20169)">
        <g
           id="g3548"
           transform="rotate(90,4.258258,174.40527)">
          <g
             id="g3561">
            <g
               id="g3552"
               transform="rotate(-90,-1.7671463,169.14375)">
              <g
                 id="path2303-1">
                <path
                   style="color:#000000;fill:#00ff00;-inkscape-stroke:none"
                   d="m 0.19335937,145.94141 v 40.13476 H 1.2578125 v -40.13476 z"
                   id="path2089" />
                <g
                   id="g2067">
                  <g
                     id="path2079">
                    <path
                       style="color:#000000;fill:#00ff00;fill-rule:evenodd;stroke-width:0.851312pt;-inkscape-stroke:none"
                       d="m 0.7262086,141.02974 4.2565598,7.36385 h -8.5131196 z"
                       id="path2083" />
                    <path
                       style="color:#000000;fill:#00ff00;fill-rule:evenodd;-inkscape-stroke:none"
                       d="m 0.7265625,139.89648 -0.4921875,0.84961 -4.7480469,8.21485 H 5.9667969 Z m 0,2.26758 L 4,147.82617 h -6.546875 z"
                       id="path2085" />
                  </g>
                  <g
                     id="path2069">
                    <path
                       style="color:#000000;fill:#00ff00;fill-rule:evenodd;stroke-width:0.851312pt;-inkscape-stroke:none"
                       d="m 0.7262086,190.98897 -4.2565598,-7.36385 h 8.5131196 z"
                       id="path2073" />
                    <path
                       style="color:#000000;fill:#00ff00;fill-rule:evenodd;-inkscape-stroke:none"
                       d="m -4.5136719,183.05664 5.2402344,9.06641 0.4902344,-0.84961 4.75,-8.2168 z m 1.9667969,1.13672 H 4 l -3.2734375,5.66211 z"
                       id="path2075" />
                  </g>
                </g>
              </g>
              <path
                 style="color:#000000;fill:#00ff00;-inkscape-stroke:none"
                 d="m -1.0214844,145.94141 v 40.13476 h 3.4960938 v -40.13476 z"
                 id="path2303-1-8" />
            </g>
          </g>
          <g
             id="g3561-7"
             transform="rotate(90,-4.9015413,166.6504)">
            <g
               id="g3552-3"
               transform="rotate(-90,-1.7671463,169.14375)">
              <g
                 id="path2303-1-4">
                <path
                   style="color:#000000;fill:#ff0000;-inkscape-stroke:none"
                   d="m 0.19335937,145.94141 v 40.13476 H 1.2578125 v -40.13476 z"
                   id="path2123" />
                <g
                   id="g2101">
                  <g
                     id="path2113">
                    <path
                       style="color:#000000;fill:#ff0000;fill-rule:evenodd;stroke-width:0.851312pt;-inkscape-stroke:none"
                       d="m 0.7262086,141.02974 4.2565598,7.36385 h -8.5131196 z"
                       id="path2117" />
                    <path
                       style="color:#000000;fill:#ff0000;fill-rule:evenodd;-inkscape-stroke:none"
                       d="m 0.7265625,139.89648 -0.4921875,0.84961 -4.7480469,8.21485 H 5.9667969 Z m 0,2.26758 L 4,147.82617 h -6.546875 z"
                       id="path2119" />
                  </g>
                  <g
                     id="path2103">
                    <path
                       style="color:#000000;fill:#ff0000;fill-rule:evenodd;stroke-width:0.851312pt;-inkscape-stroke:none"
                       d="m 0.7262086,190.98897 -4.2565598,-7.36385 h 8.5131196 z"
                       id="path2107" />
                    <path
                       style="color:#000000;fill:#ff0000;fill-rule:evenodd;-inkscape-stroke:none"
                       d="m -4.5136719,183.05664 5.2402344,9.06641 0.4902344,-0.84961 4.75,-8.2168 z m 1.9667969,1.13672 H 4 l -3.2734375,5.66211 z"
                       id="path2109" />
                  </g>
                </g>
              </g>
              <path
                 style="fill:none;stroke:#ff0000;stroke-width:3.49539;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
                 d="M 0.7262086,186.0769 V 145.94181"
                 id="path2303-1-8-0"
                 sodipodi:nodetypes="cc" />
              <path
                 style="fill:none;stroke:#fbffff;stroke-width:3.49539;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
                 d="M 45.641629,239.39844 74.021423,211.01865"
                 id="path2303-1-8-0-9"
                 sodipodi:nodetypes="cc" />
              <path
                 style="fill:none;stroke:#fbffff;stroke-width:3.49539;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
                 d="m 45.641632,211.01864 28.379795,28.3798"
                 id="path2303-1-8-0-9-7"
                 sodipodi:nodetypes="cc" />
              <rect
                 style="fill:#000000;fill-opacity:1;stroke:none;stroke-width:1.18381;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
                 id="rect5107"
                 width="3.5083394"
                 height="3.5003369"
                 x="-167.76384"
                 y="-1.015478"
                 transform="rotate(-90)" />
            </g>
          </g>
        </g>
      </g>
      <g
         id="g5880"
         transform="matrix(0.53024554,0,0,0.53024554,-64.289901,62.56056)">
        <g
           id="g5826"
           style="stroke:#00ff00">
          <path
             style="color:#000000;fill:#00ff00;fill-rule:evenodd;stroke:none;-inkscape-stroke:none"
             d="m -197.90625,483.68164 c -2.95126,24.86525 6.339,50.06922 24.7207,67.07227 31.53466,29.16951 82.080485,27.19872 111.250003,-4.33594 L -70.5,538.49609 c -24.755329,26.76256 -68.00112,28.44674 -94.76367,3.69141 -15.5853,-14.41638 -23.55893,-36.04836 -21.05664,-57.13086 z"
             id="path1316"
             transform="matrix(0.29959369,0,0,0.29959369,110.00023,17.278744)" />
          <g
             id="path1316-2"
             transform="matrix(0.29959369,0,0,0.29959369,110.00023,17.278744)">
            <path
               style="color:#000000;fill:#00ff00;fill-rule:evenodd;stroke:none;-inkscape-stroke:none"
               d="m -194.14844,484.12695 c -2.80569,23.63874 6.05625,47.68526 23.53125,63.84961 29.98737,27.73827 78.166029,25.86041 105.904299,-4.12695 l -3.011718,-2.78516 c -26.186576,28.30986 -71.797571,30.08697 -100.107421,3.90039 -16.492,-15.25507 -24.892,-38.0445 -22.24414,-60.35351 z"
               id="path2172" />
            <g
               id="g2159">
              <g
                 id="path2161">
                <path
                   style="color:#000000;fill:#00ff00;fill-rule:evenodd;stroke:none;stroke-width:3.28102pt;-inkscape-stroke:none"
                   d="m -189.88117,465.56982 12.94569,30.11653 -32.58147,-3.86711 z"
                   id="path2166" />
                <path
                   style="color:#000000;fill:#00ff00;fill-rule:evenodd;stroke:none;-inkscape-stroke:none"
                   d="m -189.36523,461.22852 -2.26758,3.03125 -21.90625,29.28515 40.10937,4.75977 z m -1.03125,8.68164 9.95312,23.15625 -25.05078,-2.97266 z"
                   id="path2168" />
              </g>
            </g>
          </g>
        </g>
        <g
           id="g5826-0"
           transform="rotate(180,73.112735,164.51371)"
           style="stroke:#ff0000">
          <path
             style="color:#000000;fill:#ff0000;fill-rule:evenodd;stroke:none;-inkscape-stroke:none"
             d="m -197.90625,483.68164 c -2.95126,24.86525 6.339,50.06922 24.7207,67.07227 31.53466,29.16951 82.080485,27.19872 111.250003,-4.33594 L -70.5,538.49609 c -24.755329,26.76256 -68.00112,28.44674 -94.76367,3.69141 -15.5853,-14.41638 -23.55893,-36.04836 -21.05664,-57.13086 z"
             id="path1316-3"
             transform="matrix(0.29959369,0,0,0.29959369,110.00023,17.278744)" />
          <g
             id="path1316-2-1"
             transform="matrix(0.29959369,0,0,0.29959369,110.00023,17.278744)">
            <path
               style="color:#000000;fill:#ff0000;fill-rule:evenodd;stroke:none;-inkscape-stroke:none"
               d="m -194.14844,484.12695 c -2.80569,23.63874 6.05625,47.68526 23.53125,63.84961 29.98737,27.73827 78.166029,25.86041 105.904299,-4.12695 l -3.011718,-2.78516 c -26.186576,28.30986 -71.797571,30.08697 -100.107421,3.90039 -16.492,-15.25507 -24.892,-38.0445 -22.24414,-60.35351 z"
               id="path2147" />
            <g
               id="g2135">
              <g
                 id="path2137">
                <path
                   style="color:#000000;fill:#ff0000;fill-rule:evenodd;stroke:none;stroke-width:3.28102pt;-inkscape-stroke:none"
                   d="m -189.88117,465.56982 12.94569,30.11653 -32.58147,-3.86711 z"
                   id="path2141" />
                <path
                   style="color:#000000;fill:#ff0000;fill-rule:evenodd;stroke:none;-inkscape-stroke:none"
                   d="m -189.36523,461.22852 -2.26758,3.03125 -21.90625,29.28515 40.10937,4.75977 z m -1.03125,8.68164 9.95312,23.15625 -25.05078,-2.97266 z"
                   id="path2143" />
              </g>
            </g>
          </g>
        </g>
      </g>
      <rect
         style="fill:none;fill-opacity:1;stroke:#00ff00;stroke-width:1.39132;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
         id="rect6016-6"
         width="22.652628"
         height="22.125669"
         x="-132.15019"
         y="170.1586" />
      <rect
         style="fill:none;fill-opacity:1;stroke:#ff0000;stroke-width:1.14734;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
         id="rect6016"
         width="8.2565641"
         height="8.064497"
         x="-132.15019"
         y="184.2198" />
      <path
         sodipodi:type="star"
         style="fill:#ebffff;fill-opacity:1;stroke:none;stroke-width:0.00724341;stroke-linecap:round;stroke-miterlimit:4;stroke-dasharray:0.0144868, 0.00724341;stroke-dashoffset:0;stroke-opacity:1;paint-order:stroke markers fill"
         id="path1181"
         inkscape:flatsided="true"
         sodipodi:sides="3"
         sodipodi:cx="75.75"
         sodipodi:cy="74.5"
         sodipodi:r1="32.03904"
         sodipodi:r2="16.01952"
         sodipodi:arg1="-2.0943951"
         sodipodi:arg2="-1.0471976"
         inkscape:rounded="0"
         inkscape:randomized="0"
         d="M 59.73048,46.753378 107.78904,74.5 59.73048,102.24662 Z"
         transform="matrix(0.35862906,0,0,0.40571931,-87.300678,150.77036)"
         inkscape:transform-center-x="-1.5359549"
         inkscape:transform-center-y="-5.0111038e-06" />
      <g
         id="g1597"
         transform="matrix(0.90246803,0,0,0.90246803,-68.718902,48.912193)"
         style="fill:#ebffff;fill-opacity:1;stroke:none;stroke-width:0;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1">
        <rect
           style="fill:#ebffff;fill-opacity:1;stroke:none;stroke-width:0;stroke-linecap:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;paint-order:stroke markers fill"
           id="rect1365"
           width="3.5874565"
           height="25.112196"
           x="-64.548622"
           y="168.80624" />
        <rect
           style="fill:#ebffff;fill-opacity:1;stroke:none;stroke-width:0;stroke-linecap:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;paint-order:stroke markers fill"
           id="rect1365-1"
           width="3.5874565"
           height="25.112196"
           x="-53.662544"
           y="168.80624" />
      </g>
      <rect
         style="fill:#ebffff;fill-opacity:1;stroke:none;stroke-width:0;stroke-linecap:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;paint-order:stroke markers fill"
         id="rect1645"
         width="22.613089"
         height="22.613089"
         x="-36.979046"
         y="169.6899" />
    </g>
  </g>
</svg>

```

`shaders/atmosphere_cs.hlsl`:

```hlsl
#include "cs.hlsli"
#include "camera.hlsli"
#include "lighting.hlsli"

#define RS \
    "RootFlags(0), " \
    "CBV(b0), " \
    "CBV(b1), " \
    "StaticSampler(s0," \
        "addressU = TEXTURE_ADDRESS_BORDER," \
        "addressV = TEXTURE_ADDRESS_BORDER," \
        "addressW = TEXTURE_ADDRESS_BORDER," \
        "filter = FILTER_COMPARISON_MIN_MAG_LINEAR_MIP_POINT)," \
    "DescriptorTable( SRV(t0, numDescriptors = 2, flags = DESCRIPTORS_VOLATILE), UAV(u0, numDescriptors = 1, flags = DESCRIPTORS_VOLATILE) )"

#define BLOCK_SIZE 16

ConstantBuffer<camera_cb> camera			: register(b0);
ConstantBuffer<directional_light_cb> sun	: register(b1);
Texture2D<float> depthBuffer				: register(t0);
Texture2D<float> shadowMap					: register(t1);

RWTexture2D<float4> output					: register(u0);

SamplerComparisonState shadowSampler		: register(s0);


// Returns (distanceToIntersection, distanceThroughVolume)
static float2 raySphereIntersection(float3 origin, float3 direction, float3 center, float radius)
{
	float3 oc = origin - center;
	const float a = 1.f; // dot(d, d)
	float b = 2.f * dot(oc, direction);
	float c = dot(oc, oc) - radius * radius;
	float d = b * b - 4.f * a * c;

	float2 result = float2(-1.f, -1.f);
	if (d > 0.f)
	{
		float s = sqrt(d);
		float distToNear = max(0.f, (-b - s) / (2.f * a));
		float distToFar = (-b + s) / (2.f * a);

		if (distToFar >= 0.f)
		{
			result = float2(distToNear, distToFar - distToNear);
		}
	}
	return result;
}

// Returns (distanceToIntersection, distanceThroughVolume)
static float2 rayBoxIntersection(float3 origin, float3 direction, float3 minCorner, float3 maxCorner)
{
	float3 invDir = 1.f / direction; // This can be Inf (when one direction component is 0) but still works.

	float tx1 = (minCorner.x - origin.x) * invDir.x;
	float tx2 = (maxCorner.x - origin.x) * invDir.x;

	float tmin = min(tx1, tx2);
	float tmax = max(tx1, tx2);

	float ty1 = (minCorner.y - origin.y) * invDir.y;
	float ty2 = (maxCorner.y - origin.y) * invDir.y;

	tmin = max(tmin, min(ty1, ty2));
	tmax = min(tmax, max(ty1, ty2));

	float tz1 = (minCorner.z - origin.z) * invDir.z;
	float tz2 = (maxCorner.z - origin.z) * invDir.z;

	tmin = max(tmin, min(tz1, tz2));
	tmax = min(tmax, max(tz1, tz2));

	float2 result = float2(-1.f, -1.f);
	if (tmax >= 0.f)
	{
		result = float2(max(0.f, tmin), tmax - tmin);
	}
	return result;
}

static float densityAtPoint(float3 position)
{
	return 50.8f;
}

static float opticalDepth(float3 position, float3 direction, float dist)
{
	return densityAtPoint(position) * dist;
}

[RootSignature(RS)]
[numthreads(BLOCK_SIZE, BLOCK_SIZE, 1)]
void main(cs_input IN)
{
	const uint numInScatteringPoints = 30;

	const float3 minCorner = float3(-80.f, 0.f, -80.f);
	const float3 maxCorner = float3(80.f, 50.f, 80.f);

	const float3 waveLengths = float3(700, 530, 440);
	const float scatteringStrength = 1.f;
	// https://www.desmos.com/calculator/64odtmkk9m
	const float3 scatteringCoefficients = pow(10.f / waveLengths, 4) * scatteringStrength; // Rayleigh scattering.

	const float ditherPattern[4][4] = 
	{ 
		{ 0.0f, 0.5f, 0.125f, 0.625f},
		{ 0.75f, 0.22f, 0.875f, 0.375f},
		{ 0.1875f, 0.6875f, 0.0625f, 0.5625},
		{ 0.9375f, 0.4375f, 0.8125f, 0.3125} 
	};


	uint2 texCoord = IN.dispatchThreadID.xy;
	if (texCoord.x >= (uint)camera.screenDims.x || texCoord.y >= (uint)camera.screenDims.y)
	{
		return;
	}

	float depth = depthBuffer[texCoord];

	float2 screenUV = texCoord * camera.invScreenDims;

	float3 P = camera.restoreWorldSpacePosition(screenUV, depth);
	float3 O = camera.position.xyz;
	float3 V = P - O;
	float distanceToGeometry = length(V);
	V /= distanceToGeometry;

	float2 hitInfo = rayBoxIntersection(O, V, minCorner, maxCorner);

	float distToVolume = hitInfo.x;
	float distThroughVolume = min(hitInfo.y, distanceToGeometry);

	if (distToVolume > distanceToGeometry || distThroughVolume <= 0.f)
	{
		output[texCoord] = float4(0.f, 0.f, 0.f, 0.f); // TODO
		return;
	}

	float ditherOffset = ditherPattern[texCoord.x % 4][texCoord.y % 4];

	const float epsilon = 0.00001f;
	distToVolume += epsilon;
	distThroughVolume -= 2.f * epsilon;

	float stepSize = distThroughVolume / (numInScatteringPoints - 1);
	float3 inScatterPoint = O + (distToVolume + ditherOffset * stepSize) * V;
	float3 inScatteredLight = 0.f;

	float3 L = -sun.direction;

	for (uint i = 0; i < numInScatteringPoints; ++i)
	{
		float sunRayLength = rayBoxIntersection(inScatterPoint, L, minCorner, maxCorner).y;
		float sunRayOpticalDepth = opticalDepth(inScatterPoint, L, sunRayLength);
		float viewRayOpticalDepth = opticalDepth(inScatterPoint, -V, stepSize * i);

		float3 transmittance = exp(-(sunRayOpticalDepth + viewRayOpticalDepth) * scatteringCoefficients);
		float localDensity = densityAtPoint(inScatterPoint);

#if 1 // Cascaded vs single.
		float pixelDepth = dot(camera.forward.xyz, inScatterPoint - O);
#if 1 // Simple vs PCF
		float visibility = sampleCascadedShadowMapSimple(sun.viewProjs, inScatterPoint, 
			shadowMap, sun.viewports,
			shadowSampler, pixelDepth, sun.numShadowCascades,
			sun.cascadeDistances, sun.bias, sun.blendDistances);
#else
		float visibility = sampleCascadedShadowMapPCF(sun.vp, inScatterPoint, 
			shadowMap, sun.viewports,
			shadowSampler, sun.texelSize, pixelDepth, sun.numShadowCascades,
			sun.cascadeDistances, sun.bias, sun.blendArea);
#endif
#else
		uint currentCascadeIndex = sun.numShadowCascades - 1;
		float4 bias = sun.bias;
		float visibility = sampleShadowMapPCF(sun.viewProjs[currentCascadeIndex], inScatterPoint,
			shadowMap, sun.viewports[currentCascadeIndex],
			shadowSampler, sun.texelSize, bias[currentCascadeIndex]);
#endif

		inScatteredLight += localDensity * transmittance * visibility;
		inScatterPoint += V * stepSize;
	}

	inScatteredLight *= scatteringCoefficients * stepSize * sun.radiance;

	output[texCoord] = float4(inScatteredLight, 0.f);
}


```

`shaders/bitonic_sort/bitonic_inner_sort_float_cs.hlsl`:

```hlsl
#define BITONIC_SORT_FLOAT
#include "common/bitonic_inner_sort.hlsli"

```

`shaders/bitonic_sort/bitonic_inner_sort_uint_cs.hlsl`:

```hlsl
#define BITONIC_SORT_UINT
#include "common/bitonic_inner_sort.hlsli"

```

`shaders/bitonic_sort/bitonic_outer_sort_float_cs.hlsl`:

```hlsl
#define BITONIC_SORT_FLOAT
#include "common/bitonic_outer_sort.hlsli"

```

`shaders/bitonic_sort/bitonic_outer_sort_uint_cs.hlsl`:

```hlsl
#define BITONIC_SORT_UINT
#include "common/bitonic_outer_sort.hlsli"

```

`shaders/bitonic_sort/bitonic_pre_sort_float_cs.hlsl`:

```hlsl
#define BITONIC_SORT_FLOAT
#include "common/bitonic_pre_sort.hlsli"

```

`shaders/bitonic_sort/bitonic_pre_sort_uint_cs.hlsl`:

```hlsl
#define BITONIC_SORT_UINT
#include "common/bitonic_pre_sort.hlsli"

```

`shaders/bitonic_sort/common/bitonic_inner_sort.hlsli`:

```hlsli
#include "cs.hlsli"
#include "bitonic_sort_rs.hlsli"

//
// Copyright(c) 2013 - 2015 Microsoft
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files(the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
// Developed by Minigraph
//
// Author:  James Stanard 
//

ConstantBuffer<bitonic_sort_cb> cb		    : register(b0);
StructuredBuffer<uint> counterBuffer	    : register(t0);
RWStructuredBuffer<uint> sortBuffer         : register(u0);

#if defined(BITONIC_SORT_FLOAT)
RWStructuredBuffer<float> comparisonBuffer  : register(u1);
#endif


groupshared key_value gs_sortKeys[2048];

void loadKeyIndexPair(uint element, uint listCount)
{
#if defined(BITONIC_SORT_UINT)
    gs_sortKeys[element & 2047] = (element < listCount ? sortBuffer[element] : cb.nullItem);
#elif defined(BITONIC_SORT_FLOAT)
    key_value kv = {
        element < listCount ? comparisonBuffer[element] : cb.nullItem,
        element < listCount ? sortBuffer[element] : 0
    };
    gs_sortKeys[element & 2047] = kv;
#endif
}

void storeKeyIndexPair(uint element, uint listCount)
{
    if (element < listCount)
    {
#if defined(BITONIC_SORT_UINT)
        sortBuffer[element] = gs_sortKeys[element & 2047];
#elif defined(BITONIC_SORT_FLOAT)
        comparisonBuffer[element] = gs_sortKeys[element & 2047].key;
        sortBuffer[element] = gs_sortKeys[element & 2047].value;
#endif
    }
}

[numthreads(1024, 1, 1)]
[RootSignature(BITONIC_SORT_RS)]
void main(cs_input IN)
{
    uint listCount = counterBuffer[cb.counterOffset];

    // Item index of the start of this group.
    const uint groupStart = IN.groupID.x * 2048;

    // Load from memory into LDS to prepare sort.
    loadKeyIndexPair(groupStart + IN.groupIndex, listCount);
    loadKeyIndexPair(groupStart + IN.groupIndex + 1024, listCount);

    GroupMemoryBarrierWithGroupSync();

#if defined(BITONIC_SORT_FLOAT)
    bool ascending = cb.nullItem > 0.f;
#endif

    // This is better unrolled because it reduces ALU and because some
    // architectures can load/store two LDS items in a single instruction
    // as long as their separation is a compile-time constant.
    [unroll]
    for (uint j = 1024; j > 0; j /= 2)
    {
        uint index2 = insertOneBit(IN.groupIndex, j);
        uint index1 = index2 ^ j;

        key_value a = gs_sortKeys[index1];
        key_value b = gs_sortKeys[index2];

        if (
#if defined(BITONIC_SORT_UINT)
            shouldSwapUint(a, b, cb.nullItem)
#elif defined(BITONIC_SORT_FLOAT)
            shouldSwapFloat(a.key, b.key, ascending)
#endif                
            )
        {
            // Swap the keys.
            gs_sortKeys[index1] = b;
            gs_sortKeys[index2] = a;
        }

        GroupMemoryBarrierWithGroupSync();
    }

    storeKeyIndexPair(groupStart + IN.groupIndex, listCount);
    storeKeyIndexPair(groupStart + IN.groupIndex + 1024, listCount);
}

```

`shaders/bitonic_sort/common/bitonic_outer_sort.hlsli`:

```hlsli
#include "cs.hlsli"
#include "bitonic_sort_rs.hlsli"

//
// Copyright(c) 2013 - 2015 Microsoft
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files(the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
// Developed by Minigraph
//
// Author:  James Stanard 
//

ConstantBuffer<bitonic_sort_cb> cb		: register(b0);
ConstantBuffer<bitonic_sort_kj_cb> kj	: register(b1);
StructuredBuffer<uint> counterBuffer	: register(t0);
RWStructuredBuffer<uint> sortBuffer     : register(u0);

#if defined(BITONIC_SORT_FLOAT)
RWStructuredBuffer<float> comparisonBuffer  : register(u1);
#endif

[numthreads(1024, 1, 1)]
[RootSignature(BITONIC_SORT_RS)]
void main(cs_input IN)
{
    uint listCount = counterBuffer[cb.counterOffset];

    // Form unique index pair from dispatch thread ID.
    uint k = kj.k;
    uint j = kj.j;
    uint index2 = insertOneBit(IN.dispatchThreadID.x, j);
    uint index1 = index2 ^ (k == 2 * j ? k - 1 : j);

    if (index2 >= listCount)
    {
        return;
    }

#if defined(BITONIC_SORT_UINT)
    key_value a = sortBuffer[index1];
    key_value b = sortBuffer[index2];

    if (shouldSwapUint(a, b, cb.nullItem))
    {
        sortBuffer[index1] = b;
        sortBuffer[index2] = a;
    }
#elif defined(BITONIC_SORT_FLOAT)

    bool ascending = cb.nullItem > 0.f;

    float a = comparisonBuffer[index1];
    float b = comparisonBuffer[index2];

    if (shouldSwapFloat(a, b, ascending))
    {
        uint aVal = sortBuffer[index1];
        uint bVal = sortBuffer[index2];

        sortBuffer[index1] = bVal;
        sortBuffer[index2] = aVal;

        comparisonBuffer[index1] = b;
        comparisonBuffer[index2] = a;
    }
#endif
}

```

`shaders/bitonic_sort/common/bitonic_pre_sort.hlsli`:

```hlsli
#include "cs.hlsli"
#include "bitonic_sort_rs.hlsli"

//
// Copyright(c) 2013 - 2015 Microsoft
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files(the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
// Developed by Minigraph
//
// Author:  James Stanard 
//

ConstantBuffer<bitonic_sort_cb> cb		    : register(b0);
StructuredBuffer<uint> counterBuffer	    : register(t0);
RWStructuredBuffer<uint> sortBuffer         : register(u0);

#if defined(BITONIC_SORT_FLOAT)
RWStructuredBuffer<float> comparisonBuffer  : register(u1);
#endif

groupshared key_value gs_sortKeys[2048];

void fillSortKey(uint element, uint listCount)
{
    // Unused elements must sort to the end.
#if defined(BITONIC_SORT_UINT)
    gs_sortKeys[element & 2047] = (element < listCount ? sortBuffer[element] : cb.nullItem);
#elif defined(BITONIC_SORT_FLOAT)
    key_value kv = {
        element < listCount ? comparisonBuffer[element] : cb.nullItem,
        element < listCount ? sortBuffer[element] : 0
    };
    gs_sortKeys[element & 2047] = kv;        
#endif
}

void storeKeyIndexPair(uint element, uint listCount)
{
    if (element < listCount)
    {
#if defined(BITONIC_SORT_UINT)
        sortBuffer[element] = gs_sortKeys[element & 2047];
#elif defined(BITONIC_SORT_FLOAT)
        comparisonBuffer[element] = gs_sortKeys[element & 2047].key;
        sortBuffer[element] = gs_sortKeys[element & 2047].value;
#endif
    }
}

[numthreads(1024, 1, 1)]
[RootSignature(BITONIC_SORT_RS)]
void main(cs_input IN)
{
    // Item index of the start of this group.
    const uint groupStart = IN.groupID.x * 2048;

    // Actual number of items that need sorting.
    uint listCount = counterBuffer[cb.counterOffset];

    fillSortKey(groupStart + IN.groupIndex, listCount);
    fillSortKey(groupStart + IN.groupIndex + 1024, listCount);

    GroupMemoryBarrierWithGroupSync();

    uint k;

#if defined(BITONIC_SORT_FLOAT)
    bool ascending = cb.nullItem > 0.f;
#endif

    // This is better unrolled because it reduces ALU and because some
    // architectures can load/store two LDS items in a single instruction
    // as long as their separation is a compile-time constant.
    //[unroll]
    for (k = 2; k <= 2048; k <<= 1)
    {
        //[unroll] // This produces a compile-time error with DXC.
        for (uint j = k / 2; j > 0; j /= 2)
        {
            uint index2 = insertOneBit(IN.groupIndex, j);
            uint index1 = index2 ^ (k == 2 * j ? k - 1 : j);

            key_value a = gs_sortKeys[index1];
            key_value b = gs_sortKeys[index2];

            if (
#if defined(BITONIC_SORT_UINT)
                shouldSwapUint(a, b, cb.nullItem)
#elif defined(BITONIC_SORT_FLOAT)
                shouldSwapFloat(a.key, b.key, ascending)
#endif                
                )
            {
                // Swap the keys
                gs_sortKeys[index1] = b;
                gs_sortKeys[index2] = a;
            }

            GroupMemoryBarrierWithGroupSync();
        }
    }

    // Write sorted results to memory
    storeKeyIndexPair(groupStart + IN.groupIndex, listCount);
    storeKeyIndexPair(groupStart + IN.groupIndex + 1024, listCount);
}

```

`shaders/bitonic_sort/common/bitonic_start_sort_cs.hlsl`:

```hlsl
#include "cs.hlsli"
#include "bitonic_sort_rs.hlsli"
#include "indirect.hlsli"

//
// Copyright(c) 2013 - 2015 Microsoft
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files(the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
// Developed by Minigraph
//
// Author:  James Stanard 
//


ConstantBuffer<bitonic_sort_cb> cb						: register(b0);
StructuredBuffer<uint> counterBuffer					: register(t0);
RWStructuredBuffer<D3D12_DISPATCH_ARGUMENTS> dispatch	: register(u0);


uint nextPowerOfTwo(uint i)
{
	uint mask = (1u << firstbithigh(i)) - 1;
	return (i + mask) & ~mask;
}

[numthreads(22, 1, 1)]
[RootSignature(BITONIC_SORT_RS)]
void main(cs_input IN)
{
	if (IN.groupIndex >= cb.maxNumIterations)
	{
		return;
	}

	uint listCount = counterBuffer[cb.counterOffset];
	uint k = 2048u << IN.groupIndex;

	// We need one more iteration every time the number of thread groups doubles.
	if (k > nextPowerOfTwo((listCount + 2047) & ~2047))
	{
		listCount = 0;
	}

	uint offset = IN.groupIndex * (IN.groupIndex + 1) / 2;

	// Generate outer sort dispatch arguments.
	for (uint j = k / 2; j > 1024; j /= 2)
	{
		// All of the groups of size 2j that are full.
		uint completeGroups = (listCount & ~(2 * j - 1)) / 2048;

		// Remaining items must only be sorted if there are more than j of them.
		uint partialGroups = ((uint)max(int(listCount - completeGroups * 2048 - j), 0) + 1023) / 1024;

		D3D12_DISPATCH_ARGUMENTS arguments = { completeGroups + partialGroups, 1, 1 };
		dispatch[offset] = arguments;

		++offset;
	}

	// The inner sort always sorts all groups (rounded up to multiples of 2048).
	D3D12_DISPATCH_ARGUMENTS arguments = { (listCount + 2047) / 2048, 1, 1 };
	dispatch[offset] = arguments;
}

```

`shaders/blit_ps.hlsl`:

```hlsl

#define BLIT_RS \
"RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT |" \
"DENY_VERTEX_SHADER_ROOT_ACCESS |" \
"DENY_HULL_SHADER_ROOT_ACCESS |" \
"DENY_DOMAIN_SHADER_ROOT_ACCESS |" \
"DENY_GEOMETRY_SHADER_ROOT_ACCESS)," \
"StaticSampler(s0," \
	"addressU = TEXTURE_ADDRESS_CLAMP," \
	"addressV = TEXTURE_ADDRESS_CLAMP," \
	"addressW = TEXTURE_ADDRESS_CLAMP," \
	"filter = FILTER_MIN_MAG_LINEAR_MIP_POINT,"	\
	"visibility=SHADER_VISIBILITY_PIXEL)," \
"DescriptorTable(SRV(t0, numDescriptors=1, flags = DESCRIPTORS_VOLATILE), visibility=SHADER_VISIBILITY_PIXEL)"

struct ps_input
{
	float2 uv	: TEXCOORDS;
};

SamplerState texSampler				: register(s0);
Texture2D<float4> tex				: register(t0);

[RootSignature(BLIT_RS)]
float4 main(ps_input IN) : SV_TARGET
{
	return tex.Sample(texSampler, IN.uv);
}

```

`shaders/common/brdf.hlsli`:

```hlsli
#ifndef BRDF_HLSLI
#define BRDF_HLSLI

#include "math.hlsli"
#include "random.hlsli"
#include "light_source.hlsli"


struct surface_info
{
	// Set from outside.
	float3 P;
	float3 N;
	float3 V;

	float4 albedo;
	float roughness;
	float metallic;
	float3 emission;



	// Inferred from properties above.
	float alphaRoughness;
	float alphaRoughnessSquared;
	float NdotV;
	float3 F0;
	float3 F;
	float3 R;


	inline void inferRemainingProperties()
	{
		alphaRoughness = roughness * roughness;
		alphaRoughnessSquared = alphaRoughness * alphaRoughness;
		NdotV = saturate(dot(N, V));
		F0 = lerp(float3(0.04f, 0.04f, 0.04f), albedo.xyz, metallic);
		R = reflect(-V, N);

		float F90 = saturate(50.f * dot(F0, (1.f / 3.f)));
		F = F0 + (F90 - F0) * pow(1.f - NdotV, 5.f); // Fresnel.
	}
};

struct light_info
{
	float3 L;
	float3 H;
	float NdotL;
	float NdotH;
	float LdotH;
	float VdotH;

	float3 radiance;
	float distanceToLight; // Only set if using a specialized initialize function. 

	inline void initialize(surface_info surface, float3 L_, float3 rad)
	{
		L = L_;
		H = normalize(L + surface.V);

		NdotL = saturate(dot(surface.N, L));
		NdotH = saturate(dot(surface.N, H));
		LdotH = saturate(dot(L, H));
		VdotH = saturate(dot(surface.V, H));

		radiance = rad;
	}

	inline void initializeFromPointLight(surface_info surface, point_light_cb pl)
	{
		float3 L = pl.position - surface.P;
		distanceToLight = length(L);
		L /= distanceToLight;

		initialize(surface, L, pl.radiance * getAttenuation(distanceToLight, pl.radius) * LIGHT_RADIANCE_SCALE);
	}

	inline void initializeFromRandomPointOnSphereLight(surface_info surface, point_light_cb pl, float radius, inout uint randSeed)
	{
		float3 randomPointOnLight = pl.position + getRandomPointOnSphere(randSeed, radius);

		float3 L = randomPointOnLight - surface.P;
		distanceToLight = length(L);
		L /= distanceToLight;

		initialize(surface, L, pl.radiance * getAttenuation(distanceToLight, pl.radius) * LIGHT_RADIANCE_SCALE);
	}

	inline void initializeFromSpotLight(surface_info surface, spot_light_cb sl)
	{
		float3 L = (sl.position - surface.P);
		distanceToLight = length(L);
		L /= distanceToLight;

		float innerCutoff = sl.getInnerCutoff();
		float outerCutoff = sl.getOuterCutoff();
		float epsilon = innerCutoff - outerCutoff;

		float theta = dot(-L, sl.direction);
		float attenuation = getAttenuation(distanceToLight, sl.maxDistance);
		float intensity = saturate((theta - outerCutoff) / epsilon) * attenuation;

		initialize(surface, L, sl.radiance * intensity * LIGHT_RADIANCE_SCALE);
	}
};



// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html





// ----------------------------------------
// FRESNEL (Surface becomes more reflective when seen from a grazing angle).
// ----------------------------------------

static float3 fresnelSchlick(float LdotH, float3 F0)
{
	return F0 + (float3(1.f, 1.f, 1.f) - F0) * pow(1.f - LdotH, 5.f);
}

static float3 fresnelSchlick(float3 F0, float F90, float VdotH)
{
	return F0 + (F90 - F0) * pow(1.f - VdotH, 5.f);
}

static float3 fresnelSchlickRoughness(float LdotH, float3 F0, float roughness)
{
	float v = 1.f - roughness;
	return F0 + (max(float3(v, v, v), F0) - F0) * pow(1.f - LdotH, 5.f);
}




// ----------------------------------------
// DISTRIBUTION (Microfacets' orientation based on roughness).
// ----------------------------------------

static float distributionGGX(float NdotH, float roughness)
{
	float a = roughness * roughness;
	float a2 = a * a;
	float NdotH2 = NdotH * NdotH;

	float d = (NdotH2 * (a2 - 1.f) + 1.f);
	return a2 / max(d * d * M_PI, 0.001f);
}

static float distributionGGX(surface_info surface, light_info light)
{
	float NdotH = light.NdotH;
	float NdotH2 = NdotH * NdotH;
	float a2 = surface.alphaRoughnessSquared;
	float d = (NdotH2 * (a2 - 1.f) + 1.f);
	return a2 / max(d * d * M_PI, 0.001f);
}




// ----------------------------------------
// GEOMETRIC MASKING (Microfacets may shadow each-other).
// ----------------------------------------

static float geometrySmith(float NdotL, float NdotV, float roughness)
{
	float k = (roughness * roughness) * 0.5f;

	float ggx2 = NdotV / (NdotV * (1.f - k) + k);
	float ggx1 = NdotL / (NdotL * (1.f - k) + k);

	return ggx1 * ggx2;
}

static float geometrySmith(surface_info surface, light_info light)
{
	float k = surface.alphaRoughness * 0.5f;

	float ggx2 = surface.NdotV / (surface.NdotV * (1.f - k) + k);
	float ggx1 = light.NdotL / (light.NdotL * (1.f - k) + k);

	return ggx1 * ggx2;
}






// ----------------------------------------
// IMPORTANCE SAMPLING
// ----------------------------------------

// When using this function to sample, the probability density is:
//      pdf = D * NdotH / (4 * HdotV)
static float3 importanceSampleGGX(inout uint randSeed, float3 N, float roughness)
{
	// Get our uniform random numbers.
	float2 randVal = float2(nextRand(randSeed), nextRand(randSeed));

	// Get an orthonormal basis from the normal.
	float3 B = getPerpendicularVector(N);
	float3 T = cross(B, N);

	// GGX NDF sampling.
	float a2 = roughness * roughness;
	float cosThetaH = sqrt(max(0.f, (1.f - randVal.x) / ((a2 - 1.f) * randVal.x + 1.f)));
	float sinThetaH = sqrt(max(0.f, 1.f - cosThetaH * cosThetaH));
	float phiH = randVal.y * M_PI * 2.f;

	// Get our GGX NDF sample (i.e., the half vector).
	return T * (sinThetaH * cos(phiH)) +
		B * (sinThetaH * sin(phiH)) +
		N * cosThetaH;
}

// Call this with a hammersley distribution as Xi.
static float4 importanceSampleGGX(float2 Xi, float3 N, float roughness)
{
	float a = roughness * roughness;
	float a2 = a * a;

	float phi = 2.f * M_PI * Xi.x;
	float cosTheta = sqrt((1.f - Xi.y) / (1.f + (a2 - 1.f) * Xi.y));
	float sinTheta = sqrt(1.f - cosTheta * cosTheta);

	// From spherical coordinates to cartesian coordinates.
	float3 H;
	H.x = cos(phi) * sinTheta;
	H.y = sin(phi) * sinTheta;
	H.z = cosTheta;

	// From tangent-space vector to world-space sample vector.
	float3 up = abs(N.z) < 0.999f ? float3(0.f, 0.f, 1.f) : float3(1.f, 0.f, 0.f);
	float3 tangent = normalize(cross(up, N));
	float3 bitangent = cross(N, tangent);

	H = tangent * H.x + bitangent * H.y + N * H.z;

	float d = (cosTheta * a2 - cosTheta) * cosTheta + 1.f;
	float D = a2 / (M_PI * d * d);
	float pdf = D * cosTheta;
	return float4(normalize(H), pdf);
}

// W = PDF = 1 / 4pi
static float4 uniformSampleSphere(float2 E)
{
	float phi = 2 * M_PI * E.x;
	float cosTheta = 1.f - 2.f * E.y;
	float sinTheta = sqrt(1.f - cosTheta * cosTheta);

	float3 H;
	H.x = sinTheta * cos(phi);
	H.y = sinTheta * sin(phi);
	H.z = cosTheta;

	float PDF = 1.f / (4.f * M_PI);

	return float4(H, PDF);
}


#endif

```

`shaders/common/camera.hlsli`:

```hlsli
#ifndef CAMERA_HLSLI
#define CAMERA_HLSLI

struct camera_cb
{
	mat4 viewProj;
	mat4 view;
	mat4 proj;
	mat4 invViewProj;
	mat4 invView;
	mat4 invProj;
	mat4 prevFrameView;
	mat4 prevFrameViewProj;
	vec4 position;
	vec4 forward;
	vec4 right;
	vec4 up;
	vec4 projectionParams; // nearPlane, farPlane, farPlane / nearPlane, 1 - farPlane / nearPlane
	vec4 viewSpaceTopLeftFrustumVector; // z = -1.
	vec2 extentAtDistanceOne;
	vec2 screenDims;
	vec2 invScreenDims;
	vec2 jitter;
	vec2 prevFrameJitter;


#ifdef HLSL
	float depthBufferDepthToEyeDepth(float depthBufferDepth)
	{
		if (projectionParams.y < 0.f) // Infinite far plane.
		{
			depthBufferDepth = clamp(depthBufferDepth, 0.f, 1.f - 1e-7f); // A depth of 1 is at infinity.
			return -projectionParams.x / (depthBufferDepth - 1.f);
		}
		else
		{
			const float c1 = projectionParams.z;
			const float c0 = projectionParams.w;
			return projectionParams.y / (c0 * depthBufferDepth + c1);
		}
	}

	// NOT normalized. Z-coordinate is 1 unit long.
	float3 restoreViewDirection(float2 uv)
	{
		float2 offset = extentAtDistanceOne * uv;
		return viewSpaceTopLeftFrustumVector.xyz + float3(offset.x, -offset.y, 0.f);
	}

	float3 restoreViewSpacePosition(float2 uv, float depth)
	{
		float viewDepth = depthBufferDepthToEyeDepth(depth);
		return restoreViewDirection(uv) * viewDepth;
	}

	float3 restoreViewSpacePositionEyeDepth(float2 uv, float eyeDepth)
	{
		return restoreViewDirection(uv) * eyeDepth;
	}

	float3 restoreWorldSpacePosition(float2 uv, float depth)
	{
		uv.y = 1.f - uv.y; // Screen uvs start at the top left, so flip y.
		float3 ndc = float3(uv * 2.f - float2(1.f, 1.f), depth);
		float4 homPosition = mul(invViewProj, float4(ndc, 1.f));
		float3 position = homPosition.xyz / homPosition.w;
		return position;
	}
#endif
};

#ifdef HLSL

static float depthBufferDepthToEyeDepth(float depthBufferDepth, float4 projectionParams)
{
	if (projectionParams.y < 0.f) // Infinite far plane.
	{
		depthBufferDepth = clamp(depthBufferDepth, 0.f, 1.f - 1e-7f); // A depth of 1 is at infinity.
		return -projectionParams.x / (depthBufferDepth - 1.f);
	}
	else
	{
		const float c1 = projectionParams.z;
		const float c0 = projectionParams.w;
		return projectionParams.y / (c0 * depthBufferDepth + c1);
	}
}

static float3 restoreViewSpacePosition(float4x4 invProj, float2 uv, float depth)
{
	uv.y = 1.f - uv.y; // Screen uvs start at the top left, so flip y.
	float3 ndc = float3(uv * 2.f - float2(1.f, 1.f), depth);
	float4 homPosition = mul(invProj, float4(ndc, 1.f));
	float3 position = homPosition.xyz / homPosition.w;
	return position;
}

static float3 restoreWorldSpacePosition(float4x4 invViewProj, float2 uv, float depth)
{
	uv.y = 1.f - uv.y; // Screen uvs start at the top left, so flip y.
	float3 ndc = float3(uv * 2.f - float2(1.f, 1.f), depth);
	float4 homPosition = mul(invViewProj, float4(ndc, 1.f));
	float3 position = homPosition.xyz / homPosition.w;
	return position;
}

// The directions are NOT normalized. Their z-coordinate is 'nearPlane' long.
static float3 restoreViewDirection(float4x4 invProj, float2 uv)
{
	return restoreViewSpacePosition(invProj, uv, 0.f);
}

static float3 restoreWorldDirection(float4x4 invViewProj, float2 uv, float3 cameraPos)
{
	return restoreWorldSpacePosition(invViewProj, uv, 0.f) - cameraPos; // At this point, the result should be 'nearPlane' units away from the camera.
}

struct camera_frustum_planes
{
	float4 planes[6];
};

// Returns true, if object should be culled.
static bool cullWorldSpaceAABB(camera_frustum_planes planes, float4 min, float4 max)
{
	for (uint i = 0; i < 6; ++i)
	{
		float4 plane = planes.planes[i];
		float4 vertex = float4(
			(plane.x < 0.f) ? min.x : max.x,
			(plane.y < 0.f) ? min.y : max.y,
			(plane.z < 0.f) ? min.z : max.z,
			1.f
			);
		if (dot(plane, vertex) < 0.f)
		{
			return true;
		}
	}
	return false;
}

static bool cullModelSpaceAABB(camera_frustum_planes planes, float4 min, float4 max, float4x4 transform)
{
	float4 worldSpaceCorners[] =
	{
		mul(transform, float4(min.x, min.y, min.z, 1.f)),
		mul(transform, float4(max.x, min.y, min.z, 1.f)),
		mul(transform, float4(min.x, max.y, min.z, 1.f)),
		mul(transform, float4(max.x, max.y, min.z, 1.f)),
		mul(transform, float4(min.x, min.y, max.z, 1.f)),
		mul(transform, float4(max.x, min.y, max.z, 1.f)),
		mul(transform, float4(min.x, max.y, max.z, 1.f)),
		mul(transform, float4(max.x, max.y, max.z, 1.f)),
	};

	for (uint i = 0; i < 6; ++i)
	{
		float4 plane = planes.planes[i];

		bool inside = false;

		for (uint j = 0; j < 8; ++j)
		{
			if (dot(plane, worldSpaceCorners[j]) > 0.f)
			{
				inside = true;
				break;
			}
		}

		if (!inside)
		{
			return true;
		}
	}

	return false;
}
#endif

#endif

```

`shaders/common/color.hlsli`:

```hlsli
#ifndef COLOR_HLSLI
#define COLOR_HLSLI

static float3 linearToSRGB(float3 color)
{
	// Approximately pow(color, 1.0 / 2.2).
	return color < 0.0031308f ? 12.92f * color : 1.055f * pow(abs(color), 1.f / 2.4f) - 0.055f;
}

static float3 sRGBToLinear(float3 color)
{
	// Approximately pow(color, 2.2).
	return color < 0.04045f ? color / 12.92f : pow(abs(color + 0.055f) / 1.055f, 2.4f);
}

static float3 rec709ToRec2020(float3 color)
{
	static const float3x3 conversion =
	{
		0.627402f, 0.329292f, 0.043306f,
		0.069095f, 0.919544f, 0.011360f,
		0.016394f, 0.088028f, 0.895578f
	};
	return mul(conversion, color);
}

static float3 rec2020ToRec709(float3 color)
{
	static const float3x3 conversion =
	{
		1.660496f, -0.587656f, -0.072840f,
		-0.124547f, 1.132895f, -0.008348f,
		-0.018154f, -0.100597f, 1.118751f
	};
	return mul(conversion, color);
}

static float3 linearToST2084(float3 color)
{
	float m1 = 2610.f / 4096.f / 4.f;
	float m2 = 2523.f / 4096.f * 128.f;
	float c1 = 3424.f / 4096.f;
	float c2 = 2413.f / 4096.f * 32.f;
	float c3 = 2392.f / 4096.f * 32.f;
	float3 cp = pow(abs(color), m1);
	return pow((c1 + c2 * cp) / (1.f + c3 * cp), m2);
}

static float3 YxyToXYZ(float3 Yxy)
{
	float Y = Yxy.r;
	float x = Yxy.g;
	float y = Yxy.b;

	float X = x * (Y / y);
	float Z = (1.f - x - y) * (Y / y);

	return float3(X, Y, Z);
}

static float3 XYZToRGB(float3 XYZ)
{
	// CIE/E.
	static const float3x3 M = 
	{
		2.3706743f, -0.9000405f, -0.4706338f,
		-0.5138850f, 1.4253036f, 0.0885814f,
		0.0052982f, -0.0146949f, 1.0093968f
	};

	return mul(M, XYZ);
}

static float3 YxyToRGB(float3 Yxy)
{
	float3 XYZ = YxyToXYZ(Yxy);
	float3 RGB = XYZToRGB(XYZ);
	return RGB;
}

#endif

```

`shaders/common/cs.hlsli`:

```hlsli
#ifndef CS_HLSLI
#define CS_HLSLI

struct cs_input
{
    uint3 groupID           : SV_GroupID;           // 3D index of the thread group in the dispatch.
    uint3 groupThreadID     : SV_GroupThreadID;     // 3D index of local thread ID in a thread group.
    uint3 dispatchThreadID  : SV_DispatchThreadID;  // 3D index of global thread ID in the dispatch.
    uint  groupIndex        : SV_GroupIndex;        // Flattened local index of the thread within a thread group.
};

#endif

```

`shaders/common/indirect.hlsli`:

```hlsli
#ifndef INDIRECT_HLSLI
#define INDIRECT_HLSLI

#ifdef HLSL
struct D3D12_DISPATCH_ARGUMENTS
{
	uint32 ThreadGroupCountX;
	uint32 ThreadGroupCountY;
	uint32 ThreadGroupCountZ;
};

struct D3D12_DRAW_ARGUMENTS
{
	uint32 VertexCountPerInstance;
	uint32 InstanceCount;
	uint32 StartVertexLocation;
	uint32 StartInstanceLocation;
};

struct D3D12_DRAW_INDEXED_ARGUMENTS
{
	uint32 IndexCountPerInstance;
	uint32 InstanceCount;
	uint32 StartIndexLocation;
	int BaseVertexLocation;
	uint32 StartInstanceLocation;
};

#endif

#endif

```

`shaders/common/light_probe.hlsli`:

```hlsli
#ifndef LIGHT_PROBE_HLSLI
#define LIGHT_PROBE_HLSLI

#ifdef HLSL
#include "math.hlsli"
#endif

#define LIGHT_PROBE_RESOLUTION	6
#define LIGHT_PROBE_TOTAL_RESOLUTION (LIGHT_PROBE_RESOLUTION + 2)

#define LIGHT_PROBE_DEPTH_RESOLUTION	14
#define LIGHT_PROBE_TOTAL_DEPTH_RESOLUTION (LIGHT_PROBE_DEPTH_RESOLUTION + 2)

#define NUM_RAYS_PER_PROBE 64

#define ENERGY_CONSERVATION 0.95f





static float signNotZero(float v)
{
	return (v >= 0.f) ? 1.f : -1.f;
}

static vec2 signNotZero(vec2 v)
{
	return vec2(signNotZero(v.x), signNotZero(v.y));
}

#ifdef HLSL
#define YX(vec) vec.yx
#else
#define YX(vec) vec2(vec.y, vec.x)
#endif


// [A Survey of Efficient Representations for Independent Unit Vectors]
// Maps between 3D direction and encoded vec2 [-1, 1]^2.
static vec2 encodeOctahedral(vec3 dir)
{
	float l1Norm = abs(dir.x) + abs(dir.y) + abs(dir.z);
	vec2 result = (1.f / l1Norm) * dir.xy;

	if (dir.z < 0.f)
	{
		result = (1.f - abs(YX(result))) * signNotZero(result);
	}

	return result;
}

static vec3 decodeOctahedral(vec2 o)
{
	vec3 v = vec3(o, 1.f - abs(o.x) - abs(o.y));
	if (v.z < 0.f)
	{
		v.xy = (1.f - abs(YX(v))) * signNotZero(v.xy);
	}
	return normalize(v);
}

static vec3 linearIndexTo3DIndex(uint32 i, uint32 countX, uint32 countY)
{
	uint32 slice = countX * countY;
	uint32 z = i / slice;
	uint32 xy = i % slice;
	uint32 y = xy / countX;
	uint32 x = xy % countX;

	return vec3((float)x, (float)y, (float)z);
}

struct light_probe_grid_cb
{
	vec3 minCorner;
	float cellSize;
	uint32 countX;
	uint32 countY;
	uint32 countZ;

	uint32 padding;

	vec3 linearIndexTo3DIndex(uint32 i)
	{
		return ::linearIndexTo3DIndex(i, countX, countY);
	}

	vec3 indexToPosition(vec3 i)
	{
		return i * cellSize + minCorner;
	}

	vec3 linearIndexToPosition(uint32 i)
	{
		return indexToPosition(linearIndexTo3DIndex(i));
	}

#ifdef HLSL
	int3 baseGridCoordinate(float3 position)
	{
		return clamp(int3((position - minCorner) / cellSize), int3(0, 0, 0), int3(countX, countY, countZ) - 1);
	}

	float2 directionToUV(float3 dir, float scale)
	{
		float2 oct = encodeOctahedral(dir);
		oct *= scale;
		oct = oct * 0.5f + 0.5f;
		return oct;
	}

	float3 sampleIrradianceAtPosition(float3 position, float3 normal, Texture2D<float3> irradiance, Texture2D<float2> depth, SamplerState linearSampler)
	{
		int3 baseIndex = baseGridCoordinate(position);
		float3 basePosition = (float3)baseIndex * cellSize + minCorner;

		float3 irradianceSum = 0.f;
		float weightSum = 0.f;

		float3 barycentric =  saturate((position - basePosition) / cellSize);

		const float irradianceOctScale = (float)LIGHT_PROBE_RESOLUTION / (float)LIGHT_PROBE_TOTAL_RESOLUTION;
		const float depthOctScale = (float)LIGHT_PROBE_DEPTH_RESOLUTION / (float)LIGHT_PROBE_TOTAL_DEPTH_RESOLUTION;

		float2 irradianceOct = directionToUV(normal, irradianceOctScale);


		float2 uvScale = 1.f / float2(countX * countY, countZ);

		const float normalBias = 0.0001f;

		for (int i = 0; i < 8; ++i)
		{
			int3 offset = int3(i, i >> 1, i >> 2) & 0x1;
			int3 probeIndex3 = clamp(baseIndex + offset, int3(0, 0, 0), int3(countX, countY, countZ) - 1);
			float2 uvOffset = float2(probeIndex3.y * countX + probeIndex3.x, probeIndex3.z);

			float weight = 1.f;


			float3 probePosition = indexToPosition((float3)probeIndex3);
			float3 pointToProbe = probePosition - position;

			// Don't sample probes which are behind us.
			weight *= square(max(0.0001f, (dot(normalize(pointToProbe), normal) + 1.f) * 0.5f)) + 0.2f;


			// Moment visibility.
#if 0
			pointToProbe -= normal * normalBias; // Offset a bit to avoid sampling directly at the surface. This shortens the vector.

			float distToProbe = length(pointToProbe);
			pointToProbe *= (1.f / distToProbe); // Normalize.

			float2 depthUV = (uvOffset + directionToUV(-pointToProbe, depthOctScale));
			float2 meanAndVariance = depth.SampleLevel(linearSampler, depthUV, 0);

			float mean = meanAndVariance.x;
			float variance = abs(square(meanAndVariance.x) - meanAndVariance.y);

			float chebyshevWeight = variance / (variance + square(max(distToProbe - mean, 0.f)));

			chebyshevWeight = max(pow3(chebyshevWeight), 0.f); // Increase contrast in the weight.
			weight *= (distToProbe <= mean) ? 1.f : chebyshevWeight;
#endif


			
			// Trilinear weights.
			float3 trilinear = lerp(1.f - barycentric, barycentric, offset);
			weight *= trilinear.x * trilinear.y * trilinear.z;


			float2 irradianceUV = (uvOffset + irradianceOct) * uvScale;
			irradianceSum += irradiance.SampleLevel(linearSampler, irradianceUV, 0) * weight;
			weightSum += weight;
		}

		return irradianceSum * (1.f / max(weightSum, 1e-5f)) * ENERGY_CONSERVATION;
	}
#endif

};


#endif

```

`shaders/common/light_source.hlsli`:

```hlsli
#ifndef LIGHT_SOURCE_HLSLI
#define LIGHT_SOURCE_HLSLI

#include "light_probe.hlsli"

#define M_SQRT_PI 1.77245385090f

// Used for point and spot lights, because I dislike very high numbers.
#define LIGHT_RADIANCE_SCALE 1000.f

#define MAX_NUM_SUN_SHADOW_CASCADES 4


static float getAttenuation(float distance, float maxDistance)
{
	// https://imdoingitwrong.wordpress.com/2011/02/10/improved-light-attenuation/
	float relDist = min(distance / maxDistance, 1.f);
	float d = distance / (1.f - relDist * relDist);

	float att = 1.f / (d * d + 1.f);
	return att;
}

struct directional_light_cb
{
	mat4 viewProjs[MAX_NUM_SUN_SHADOW_CASCADES];
	vec4 viewports[MAX_NUM_SUN_SHADOW_CASCADES];

	vec4 cascadeDistances;
	vec4 bias;

	vec3 direction;
	uint32 numShadowCascades;
	vec3 radiance;
	uint32 padding;
	vec4 blendDistances;
};

struct point_light_cb
{
	vec3 position;
	float radius; // Maximum distance.
	vec3 radiance;
	int shadowInfoIndex; // -1, if light casts no shadows.


	void initialize(vec3 position_, vec3 radiance_, float radius_, int shadowInfoIndex_ = -1)
	{
		position = position_;
		radiance = radiance_;
		radius = radius_;
		shadowInfoIndex = shadowInfoIndex_;
	}

#ifndef HLSL
	point_light_cb() {}

	point_light_cb(vec3 position_, vec3 radiance_, float radius_, int shadowInfoIndex_ = -1)
	{
		initialize(position_, radiance_, radius_, shadowInfoIndex_);
	}
#endif
};

struct spot_light_cb
{
	vec3 position;
	int innerAndOuterCutoff; // cos(innerAngle) << 16 | cos(outerAngle). Both are packed into 16 bit signed ints.
	vec3 direction;
	float maxDistance;
	vec3 radiance;
	int shadowInfoIndex; // -1, if light casts no shadows.


	void initialize(vec3 position_, vec3 direction_, vec3 radiance_, float innerAngle_, float outerAngle_, float maxDistance_, int shadowInfoIndex_ = -1)
	{
		position = position_;
		direction = direction_;
		radiance = radiance_;
		
		int inner = (int)(cos(innerAngle_) * ((1 << 15) - 1));
		int outer = (int)(cos(outerAngle_) * ((1 << 15) - 1));
		innerAndOuterCutoff = (inner << 16) | outer;

		maxDistance = maxDistance_;
		shadowInfoIndex = shadowInfoIndex_;
	}

#ifndef HLSL
	spot_light_cb() {}

	spot_light_cb(vec3 position_, vec3 direction_, vec3 radiance_, float innerAngle_, float outerAngle_, float maxDistance_, int shadowInfoIndex_ = -1)
	{
		initialize(position_, direction_, radiance_, innerAngle_, outerAngle_, maxDistance_, shadowInfoIndex_);
	}
#endif

	float getInnerCutoff()
#ifndef HLSL
		const
#endif
	{
		return (innerAndOuterCutoff >> 16) / float((1 << 15) - 1);
	}

	float getOuterCutoff()
#ifndef HLSL
		const
#endif
	{
		return (innerAndOuterCutoff & 0xFFFF) / float((1 << 15) - 1);
	}
};

struct spot_shadow_info
{
	mat4 viewProj;

	vec4 viewport;

	float bias;
	float padding0[3];
};

struct point_shadow_info
{
	vec4 viewport0;
	vec4 viewport1;
};

struct spherical_harmonics
{
	vec4 coefficients[7];

	void initialize(float r[9], float g[9], float b[9])
	{
		// Pack the SH coefficients in a way that makes applying the lighting use the least shader instructions
		// This has the diffuse convolution coefficients baked in. See "Stupid Spherical Harmonics (SH) Tricks", Appendix A10.
		const float c0 = 1.f / (2.f * M_SQRT_PI);
		const float c1 = sqrt(3.f) / (3.f * M_SQRT_PI);
		const float c2 = sqrt(15.f) / (8.f * M_SQRT_PI);
		const float c3 = sqrt(5.f) / (16.f * M_SQRT_PI);
		const float c4 = 0.5f * c2;

		coefficients[0].x = -c1 * r[3];
		coefficients[0].y = -c1 * r[1];
		coefficients[0].z = c1 * r[2];
		coefficients[0].w = c0 * r[0] - c3 * r[6];

		coefficients[1].x = -c1 * g[3];
		coefficients[1].y = -c1 * g[1];
		coefficients[1].z = c1 * g[2];
		coefficients[1].w = c0 * g[0] - c3 * g[6];

		coefficients[2].x = -c1 * b[3];
		coefficients[2].y = -c1 * b[1];
		coefficients[2].z = c1 * b[2];
		coefficients[2].w = c0 * b[0] - c3 * b[6];

		coefficients[3].x = c2 * r[4];
		coefficients[3].y = -c2 * r[5];
		coefficients[3].z = 3.f * c3 * r[6];
		coefficients[3].w = -c2 * r[7];

		coefficients[4].x = c2 * g[4];
		coefficients[4].y = -c2 * g[5];
		coefficients[4].z = 3.f * c3 * g[6];
		coefficients[4].w = -c2 * g[7];

		coefficients[5].x = c2 * b[4];
		coefficients[5].y = -c2 * b[5];
		coefficients[5].z = 3.f * c3 * b[6];
		coefficients[5].w = -c2 * b[7];

		coefficients[6].x = c4 * r[8];
		coefficients[6].y = c4 * g[8];
		coefficients[6].z = c4 * b[8];
		coefficients[6].w = 1.f;
	}

#ifndef HLSL
	spherical_harmonics() {}

	spherical_harmonics(float r[9], float g[9], float b[9])
	{
		initialize(r, g, b);
	}
#endif

#ifdef HLSL
	vec3 evaluate(vec3 normal)
	{
		// See "Stupid Spherical Harmonics (SH) Tricks", Appendix A10.
		vec4 N = vec4(normal, 1.f);

		vec3 x1, x2, x3;

		// Linear + constant polynomial terms.
		x1.x = dot(coefficients[0], N);
		x1.y = dot(coefficients[1], N);
		x1.z = dot(coefficients[2], N);

		// 4 of the quadratic polynomials.
		vec4 vB = N.xyzz * N.yzzx;

		x2.x = dot(coefficients[3], vB);
		x2.y = dot(coefficients[4], vB);
		x2.z = dot(coefficients[5], vB);

		// Final quadratic polynomial.
		float vC = N.x * N.x - N.y * N.y;
		x3 = coefficients[6].xyz * vC;

		return max(0, x1 + x2 + x3);
	}
#endif
};

struct spherical_harmonics_basis
{
	float v[9];
};

static spherical_harmonics_basis getSHBasis(vec3 dir)
{
	spherical_harmonics_basis result;
	result.v[0] = 0.282095f;
	result.v[1] = -0.488603f * dir.y;
	result.v[2] = 0.488603f * dir.z;
	result.v[3] = -0.488603f * dir.x;
	result.v[4] = 1.092548f * dir.x * dir.y;
	result.v[5] = -1.092548f * dir.y * dir.z;
	result.v[6] = 0.315392f * (3.f * dir.z * dir.z - 1.f);
	result.v[7] = -1.092548f * dir.z * dir.x;
	result.v[8] = 0.546274f * (dir.x * dir.x - dir.y * dir.y);
	return result;
}

struct lighting_cb
{
	directional_light_cb sun;
	light_probe_grid_cb lightProbeGrid;

	vec2 shadowMapTexelSize;
	float globalIlluminationIntensity;
	uint32 useRaytracedGlobalIllumination;
};

#endif

```

`shaders/common/lighting.hlsli`:

```hlsli
#ifndef LIGHTING_HLSLI
#define LIGHTING_HLSLI

#include "brdf.hlsli"
#include "../rs/light_culling_rs.hlsli"

static float3 diffuseIBL(float3 kd, surface_info surface, TextureCube<float4> irradianceTexture, SamplerState clampSampler)
{
	float3 irradiance = irradianceTexture.SampleLevel(clampSampler, surface.N, 0).rgb;
	return kd * irradiance;
}

static float3 specularIBL(float3 F, surface_info surface, TextureCube<float4> environmentTexture, Texture2D<float2> brdf, SamplerState clampSampler, float specularScale = 1.f)
{
	uint width, height, numMipLevels;
	environmentTexture.GetDimensions(0, width, height, numMipLevels);
	float lod = surface.roughness * float(numMipLevels - 1);

	float3 prefilteredColor = environmentTexture.SampleLevel(clampSampler, surface.R, lod).rgb;
	float2 envBRDF = brdf.SampleLevel(clampSampler, float2(surface.roughness, surface.NdotV), 0);
	float3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y) * specularScale;

	return specular;
}

struct ambient_factors
{
	float3 kd;
	float3 ks;
};

static ambient_factors getAmbientFactors(surface_info surface)
{
	float3 F = fresnelSchlickRoughness(surface.NdotV, surface.F0, surface.roughness);
	float3 kd = float3(1.f, 1.f, 1.f) - F;
	kd *= 1.f - surface.metallic;

	ambient_factors result = { kd, F };
	return result;
}




static float sampleShadowMapSimple(float4x4 vp, float3 worldPosition,
	Texture2D<float> shadowMap, float4 viewport,
	SamplerComparisonState shadowMapSampler, float bias)
{
	float4 lightProjected = mul(vp, float4(worldPosition, 1.f));
	lightProjected.xyz /= lightProjected.w;

	float2 lightUV = lightProjected.xy * float2(0.5f, -0.5f) + float2(0.5f, 0.5f);

	float visibility = 1.f;

	// This case is not handled by a border sampler because we are using a shadow map atlas.
	if (all(lightUV >= 0.f && lightUV <= 1.f))
	{
		lightUV = lightUV * viewport.zw + viewport.xy;

		visibility = shadowMap.SampleCmpLevelZero(
			shadowMapSampler,
			lightUV,
			lightProjected.z - bias);
	}

	return visibility;
}

static float sampleShadowMapPCF(float4x4 vp, float3 worldPosition,
	Texture2D<float> shadowMap, float4 viewport,
	SamplerComparisonState shadowMapSampler,
	float2 texelSize, float bias, float pcfRadius = 1.5f, float numPCFSamples = 16.f)
{
	float4 lightProjected = mul(vp, float4(worldPosition, 1.f));
	lightProjected.xyz /= lightProjected.w;

	float2 lightUV = lightProjected.xy * float2(0.5f, -0.5f) + float2(0.5f, 0.5f);

	float visibility = 1.f;

	// This case is not handled by a border sampler because we are using a shadow map atlas.
	if (all(lightUV >= 0.f && lightUV <= 1.f))
	{
		lightUV = lightUV * viewport.zw + viewport.xy;

		visibility = 0.f;
		for (float y = -pcfRadius; y <= pcfRadius + 0.01f; y += 1.f)
		{
			for (float x = -pcfRadius; x <= pcfRadius + 0.01f; x += 1.f)
			{
				visibility += shadowMap.SampleCmpLevelZero(
					shadowMapSampler,
					lightUV + float2(x, y) * texelSize,
					lightProjected.z - bias);
			}
		}
		visibility /= numPCFSamples;
	}

	return visibility;
}

static float samplePointLightShadowMapPCF(float3 worldPosition, float3 lightPosition,
	Texture2D<float> shadowMap,
	float4 viewport, float4 viewport2,
	SamplerComparisonState shadowMapSampler,
	float2 texelSize, float maxDistance, float pcfRadius = 1.5f, float numPCFSamples = 16.f)
{
	float3 L = worldPosition - lightPosition;
	float l = length(L);
	L /= l;

	float flip = L.z > 0.f ? 1.f : -1.f;
	float4 vp = L.z > 0.f ? viewport : viewport2;

	L.z *= flip;
	L.xy /= L.z + 1.f;

	float2 lightUV = L.xy * float2(0.5f, -0.5f) + float2(0.5f, 0.5f);

	lightUV = lightUV * vp.zw + vp.xy;

	float compareDistance = l / maxDistance;

	float bias = -0.001f * flip;

	float visibility = 0.f;
	for (float y = -pcfRadius; y <= pcfRadius + 0.01f; y += 1.f)
	{
		for (float x = -pcfRadius; x <= pcfRadius + 0.01f; x += 1.f)
		{
			visibility += shadowMap.SampleCmpLevelZero(
				shadowMapSampler,
				lightUV + float2(x, y) * texelSize,
				compareDistance - bias);
		}
	}
	visibility /= numPCFSamples;

	return visibility;
}

static float sampleCascadedShadowMapSimple(float4x4 vp[4], float3 worldPosition,
	Texture2D<float> shadowMap, float4 viewports[4],
	SamplerComparisonState shadowMapSampler,
	float pixelDepth, uint numCascades, float4 cascadeDistances, float4 bias, float4 blendDistances)
{
	if (numCascades == 0)
	{
		return 1.f;
	}
	else
	{
		float blendArea = blendDistances.x;

		float4 comparison = pixelDepth.xxxx > cascadeDistances;

		int currentCascadeIndex = dot(float4(numCascades > 0, numCascades > 1, numCascades > 2, numCascades > 3), comparison);
		currentCascadeIndex = min(currentCascadeIndex, numCascades - 1);

		int nextCascadeIndex = min(numCascades - 1, currentCascadeIndex + 1);

		float visibility = sampleShadowMapSimple(vp[currentCascadeIndex], worldPosition,
			shadowMap, viewports[currentCascadeIndex],
			shadowMapSampler, bias[currentCascadeIndex]);

		float blendEnd = cascadeDistances[currentCascadeIndex];
		float blendStart = blendEnd - blendDistances[currentCascadeIndex];
		float alpha = smoothstep(blendStart, blendEnd, pixelDepth);

		float nextCascadeVisibility = visibility;

		[branch]
		if (currentCascadeIndex != nextCascadeIndex && alpha != 0.f)
		{
			nextCascadeVisibility = sampleShadowMapSimple(vp[nextCascadeIndex], worldPosition,
				shadowMap, viewports[nextCascadeIndex],
				shadowMapSampler, bias[nextCascadeIndex]);
		}

		visibility = lerp(visibility, nextCascadeVisibility, alpha);
		return visibility;
	}
}

static float sampleCascadedShadowMapPCF(float4x4 vp[4], float3 worldPosition,
	Texture2D<float> shadowMap, float4 viewports[4],
	SamplerComparisonState shadowMapSampler,
	float2 texelSize, float pixelDepth, uint numCascades, float4 cascadeDistances, float4 bias, float4 blendDistances)
{
	if (numCascades == 0)
	{
		return 1.f;
	}
	else
	{
		float4 comparison = pixelDepth.xxxx > cascadeDistances;

		int currentCascadeIndex = dot(float4(numCascades > 0, numCascades > 1, numCascades > 2, numCascades > 3), comparison);
		currentCascadeIndex = min(currentCascadeIndex, numCascades - 1);

		int nextCascadeIndex = min(numCascades - 1, currentCascadeIndex + 1);

		static const float pcfRadius[4] = {
			1.5f, 1.f, 0.5f, 0.f,
		};

		static const float numPCFSamples[4] = {
			16.f, 9.f, 4.f, 1.f,
		};

		float visibility = sampleShadowMapPCF(vp[currentCascadeIndex], worldPosition,
			shadowMap, viewports[currentCascadeIndex],
			shadowMapSampler, texelSize, bias[currentCascadeIndex], pcfRadius[currentCascadeIndex], numPCFSamples[currentCascadeIndex]);

		float blendEnd = cascadeDistances[currentCascadeIndex];
		float blendStart = blendEnd - blendDistances[currentCascadeIndex];
		float alpha = smoothstep(blendStart, blendEnd, pixelDepth);

		float nextCascadeVisibility = visibility;

		[branch]
		if (currentCascadeIndex != nextCascadeIndex && alpha != 0.f)
		{
			nextCascadeVisibility = sampleShadowMapPCF(vp[nextCascadeIndex], worldPosition,
				shadowMap, viewports[nextCascadeIndex],
				shadowMapSampler, texelSize, bias[nextCascadeIndex], pcfRadius[nextCascadeIndex], numPCFSamples[nextCascadeIndex]);
		}

		visibility = lerp(visibility, nextCascadeVisibility, alpha);
		return visibility;
	}
}






struct light_contribution
{
	float3 diffuse;
	float3 specular;

	void add(light_contribution other, float visibility = 1.f)
	{
		diffuse += other.diffuse * visibility;
		specular += other.specular * visibility;
	}

	float4 evaluate(float4 albedo)
	{
		float3 c = albedo.rgb * diffuse + specular;
		return float4(c, albedo.a);
	}

	void addSunLight(surface_info surface, lighting_cb lighting, float2 screenUV, float pixelDepth,
		Texture2D<float> shadowMap, SamplerComparisonState shadowSampler, float2 shadowMapTexelSize,
		Texture2D<float> sssTexture, SamplerState clampSampler, float subSurfaceScale = 0.f);

	void addPointLights(surface_info surface, StructuredBuffer<point_light_cb> pointLights, StructuredBuffer<point_shadow_info> pointShadowInfos,
		StructuredBuffer<uint> tiledObjectsIndexList, uint2 tiledIndexData,
		Texture2D<float> shadowMap, SamplerComparisonState shadowSampler, float2 shadowMapTexelSize);

	void addSpotLights(surface_info surface, StructuredBuffer<spot_light_cb> spotLights, StructuredBuffer<spot_shadow_info> spotShadowInfos,
		StructuredBuffer<uint> tiledObjectsIndexList, uint2 tiledIndexData,
		Texture2D<float> shadowMap, SamplerComparisonState shadowSampler, float2 shadowMapTexelSize);

	void addImageBasedAmbientLighting(surface_info surface, TextureCube<float4> irradianceTexture, TextureCube<float4> prefilteredRadianceTexture,
		Texture2D<float2> brdf, Texture2D<float4> ssrTexture, Texture2D<float> aoTexture, SamplerState clampSampler, float2 screenUV, float globalIlluminationIntensity);

	void addRaytracedAmbientLighting(surface_info surface, lighting_cb lighting, Texture2D<float3> lightProbeIrradiance, Texture2D<float2> lightProbeDepth,
		Texture2D<float4> ssrTexture, Texture2D<float> aoTexture, SamplerState clampSampler, float2 screenUV);
};

static light_contribution calculateDirectLighting(surface_info surface, light_info light, float specularScale = 1.f)
{
	float D = distributionGGX(surface, light);
	float G = geometrySmith(surface, light);
	float3 F = fresnelSchlick(light.VdotH, surface.F0);

	float3 kD = float3(1.f, 1.f, 1.f) - F;
	kD *= 1.f - surface.metallic;
	float3 diffuse = kD * M_INV_PI * light.radiance * light.NdotL;

	float3 specular = (D * G * F) / max(4.f * surface.NdotV, 0.001f) * light.radiance * specularScale;

	light_contribution result = { diffuse, specular };
	return result;
}

static light_contribution calculateImageBasedAmbientLighting(surface_info surface, TextureCube<float4> irradianceTexture, TextureCube<float4> prefilteredRadianceTexture,
	Texture2D<float2> brdf, Texture2D<float4> ssrTexture, Texture2D<float> aoTexture, SamplerState clampSampler, float2 screenUV, float globalIlluminationIntensity)
{
	ambient_factors factors = getAmbientFactors(surface);

	float3 diffuse = diffuseIBL(factors.kd, surface, irradianceTexture, clampSampler);
	float3 specular = specularIBL(factors.ks, surface, prefilteredRadianceTexture, brdf, clampSampler);
	
	float4 ssr = ssrTexture.SampleLevel(clampSampler, screenUV, 0);
	specular = lerp(specular, ssr.rgb * surface.F, ssr.a);

	float ao = aoTexture.SampleLevel(clampSampler, screenUV, 0);
	float intensity = ao * globalIlluminationIntensity;

	light_contribution result = { diffuse * intensity, specular * intensity };
	return result;
}

static light_contribution calculateRaytracedAmbientLighting(surface_info surface, lighting_cb lighting, Texture2D<float3> lightProbeIrradiance, Texture2D<float2> lightProbeDepth,
	Texture2D<float4> ssrTexture, Texture2D<float> aoTexture, SamplerState clampSampler, float2 screenUV)
{
	float ao = aoTexture.SampleLevel(clampSampler, screenUV, 0);
	float intensity = ao * lighting.globalIlluminationIntensity;
	float4 ssr = ssrTexture.SampleLevel(clampSampler, screenUV, 0);

	light_contribution totalLighting;
	totalLighting.diffuse = lighting.lightProbeGrid.sampleIrradianceAtPosition(surface.P, surface.N, lightProbeIrradiance, lightProbeDepth, clampSampler) * intensity;
	totalLighting.specular = ssr.rgb * surface.F * intensity;
	return totalLighting;
}



void light_contribution::addSunLight(surface_info surface, lighting_cb lighting, float2 screenUV, float pixelDepth,
	Texture2D<float> shadowMap, SamplerComparisonState shadowSampler, float2 shadowMapTexelSize,
	Texture2D<float> sssTexture, SamplerState clampSampler, float subSurfaceScale)
{
	float3 L = -lighting.sun.direction;

	light_info light;
	light.initialize(surface, L, lighting.sun.radiance);

	float visibility = sampleCascadedShadowMapPCF(lighting.sun.viewProjs, surface.P,
		shadowMap, lighting.sun.viewports,
		shadowSampler, lighting.shadowMapTexelSize, pixelDepth, lighting.sun.numShadowCascades,
		lighting.sun.cascadeDistances, lighting.sun.bias, lighting.sun.blendDistances);

	float sss = sssTexture.SampleLevel(clampSampler, screenUV, 0);
	visibility *= sss;

	[branch]
	if (visibility > 0.f)
	{
		add(calculateDirectLighting(surface, light), visibility);


		if (subSurfaceScale > 0.f)
		{
			// Subsurface scattering.
			// https://www.alanzucconi.com/2017/08/30/fast-subsurface-scattering-1/
			const float distortion = 0.4f;
			float3 sssH = L + surface.N * distortion;
			float sssVdotH = saturate(dot(surface.V, -sssH));

			float sssIntensity = sssVdotH * subSurfaceScale;
			diffuse += sssIntensity * lighting.sun.radiance * visibility;
		}

	}
}

void light_contribution::addPointLights(surface_info surface, StructuredBuffer<point_light_cb> pointLights, StructuredBuffer<point_shadow_info> pointShadowInfos,
	StructuredBuffer<uint> tiledObjectsIndexList, uint2 tiledIndexData,
	Texture2D<float> shadowMap, SamplerComparisonState shadowSampler, float2 shadowMapTexelSize)
{
	const uint pointLightCount = (tiledIndexData.y >> 20) & 0x3FF;
	uint lightReadIndex = tiledIndexData.x + TILE_LIGHT_OFFSET;

	for (uint i = 0; i < pointLightCount; ++i)
	{
		point_light_cb pl = pointLights[tiledObjectsIndexList[lightReadIndex++]];

		light_info light;
		light.initializeFromPointLight(surface, pl);

		float visibility = 1.f;

		[branch]
		if (pl.shadowInfoIndex != -1)
		{
			point_shadow_info info = pointShadowInfos[pl.shadowInfoIndex];

			visibility = samplePointLightShadowMapPCF(surface.P, pl.position,
				shadowMap,
				info.viewport0, info.viewport1,
				shadowSampler,
				shadowMapTexelSize, pl.radius);
		}

		[branch]
		if (visibility > 0.f)
		{
			add(calculateDirectLighting(surface, light), visibility);
		}
	}
}

void light_contribution::addSpotLights(surface_info surface, StructuredBuffer<spot_light_cb> spotLights, StructuredBuffer<spot_shadow_info> spotShadowInfos,
	StructuredBuffer<uint> tiledObjectsIndexList, uint2 tiledIndexData, 
	Texture2D<float> shadowMap, SamplerComparisonState shadowSampler, float2 shadowMapTexelSize)
{
	const uint pointLightCount = (tiledIndexData.y >> 20) & 0x3FF;
	const uint spotLightCount = (tiledIndexData.y >> 10) & 0x3FF;
	uint lightReadIndex = tiledIndexData.x + TILE_LIGHT_OFFSET + pointLightCount;

	for (uint i = 0; i < spotLightCount; ++i)
	{
		spot_light_cb sl = spotLights[tiledObjectsIndexList[lightReadIndex++]];

		light_info light;
		light.initializeFromSpotLight(surface, sl);

		float visibility = 1.f;

		[branch]
		if (sl.shadowInfoIndex != -1)
		{
			spot_shadow_info info = spotShadowInfos[sl.shadowInfoIndex];
			visibility = sampleShadowMapPCF(info.viewProj, surface.P,
				shadowMap, info.viewport,
				shadowSampler,
				shadowMapTexelSize, info.bias);
		}

		[branch]
		if (visibility > 0.f)
		{
			add(calculateDirectLighting(surface, light), visibility);
		}
	}
}

void light_contribution::addImageBasedAmbientLighting(surface_info surface, TextureCube<float4> irradianceTexture, TextureCube<float4> prefilteredRadianceTexture,
	Texture2D<float2> brdf, Texture2D<float4> ssrTexture, Texture2D<float> aoTexture, SamplerState clampSampler, float2 screenUV, float globalIlluminationIntensity)
{
	add(calculateImageBasedAmbientLighting(surface, irradianceTexture, prefilteredRadianceTexture, brdf, ssrTexture, aoTexture, clampSampler, screenUV, globalIlluminationIntensity));
}

void light_contribution::addRaytracedAmbientLighting(surface_info surface, lighting_cb lighting, Texture2D<float3> lightProbeIrradiance, Texture2D<float2> lightProbeDepth,
	Texture2D<float4> ssrTexture, Texture2D<float> aoTexture, SamplerState clampSampler, float2 screenUV)
{
	add(calculateRaytracedAmbientLighting(surface, lighting, lightProbeIrradiance, lightProbeDepth, ssrTexture, aoTexture, clampSampler, screenUV));
}

#endif

```

`shaders/common/material.hlsli`:

```hlsli
#ifndef MATERIAL_HLSLI
#define MATERIAL_HLSLI


static uint32 packColor(uint32 r, uint32 g, uint32 b, uint32 a)
{
    return ((a & 0xFF) << 24) | ((b & 0xFF) << 16) | ((g & 0xFF) << 8) | (r & 0xFF);
}

static uint32 packColor(float r, float g, float b, float a)
{
    return packColor(
        (uint32)clamp(r * 255.f, 0.f, 255.f),
        (uint32)clamp(g * 255.f, 0.f, 255.f),
        (uint32)clamp(b * 255.f, 0.f, 255.f),
        (uint32)clamp(a * 255.f, 0.f, 255.f));
}

static uint32 packColor(vec4 rgba)
{
    return packColor(rgba.r, rgba.g, rgba.b, rgba.a);
}

static vec4 unpackColor(uint32 c)
{
    const float mul = 1.f / 255.f;
    float r = (c & 0xFF) * mul;
    float g = ((c >> 8) & 0xFF) * mul;
    float b = ((c >> 16) & 0xFF) * mul;
    float a = ((c >> 24) & 0xFF) * mul;
    return vec4(r, g, b, a);
}


struct texture_atlas_cb
{
	uint32 totalNumCells_numCols; // Each 16 bit.
	uint32 invCols_invRows; // Each 16 bit halfs.

	void initialize(uint32 rows, uint32 cols)
	{
		totalNumCells_numCols = ((rows * cols) << 16) | cols;

#ifndef HLSL
		uint32 invCols = half(1.f / cols).h;
		uint32 invRows = half(1.f / rows).h;
#else
		uint32 invCols = f32tof16(1.f / cols);
		uint32 invRows = f32tof16(1.f / rows);
#endif

		invCols_invRows = (invCols << 16) | invRows;
	}

	uint32 getTotalNumCells()
	{
		return totalNumCells_numCols >> 16;
	}

	uint32 getNumCols()
	{
		return totalNumCells_numCols & 0xFFFF;
	}

	float getInvNumCols()
	{
		uint32 i = invCols_invRows >> 16;
#ifndef HLSL
		return half((uint16)i);
#else
		return f16tof32(i);
#endif
	}

	float getInvNumRows()
	{
		uint32 i = invCols_invRows;
#ifndef HLSL
		return half((uint16)i);
#else
		return f16tof32(i);
#endif
	}

	uint32 getX(uint32 i)
	{
		return i % getNumCols();
	}

	uint32 getY(uint32 i)
	{
		return i / getNumCols();
	}
};




#define MATERIAL_USE_ALBEDO_TEXTURE			(1 << 0)
#define MATERIAL_USE_NORMAL_TEXTURE			(1 << 1)
#define MATERIAL_USE_ROUGHNESS_TEXTURE		(1 << 2)
#define MATERIAL_USE_METALLIC_TEXTURE		(1 << 3)
#define MATERIAL_DOUBLE_SIDED				(1 << 4)
#define MATERIAL_USE_32_BIT_INDICES			(1 << 5) // Ugly to put this in the material. Only used in the ray tracing shaders.

struct pbr_material_cb // 24 bytes.
{
    vec3 emission;      // Since emission can be HDR, we use full precision floats here.
    uint32 albedoTint;  // RGBA packed into one uint32. Can only be between 0 and 1, which is why we are only using 8 bit per channel.
    uint32 roughness_metallic_flags_translucency; // 8 bit each.
	uint32 normalMapStrength_unused_uvScale; // 8 bit for normal map strength, 8 bit unused, 16 bit half for uvScale.

    void initialize(vec4 albedo_, vec3 emission_, float roughness_, float metallic_, uint32 flags_, float normalMapStrength_ = 1.f, float translucency_ = 0.f,
		float uvScale = 1.f)
    {
        emission = emission_;
        albedoTint = packColor(albedo_);
        
		roughness_ = clamp(roughness_, 0.f, 1.f);
		metallic_ = clamp(metallic_, 0.f, 1.f);
		translucency_ = clamp(translucency_, 0.f, 1.f);
		normalMapStrength_ = clamp(normalMapStrength_, 0.f, 1.f);

		roughness_metallic_flags_translucency =
			((uint32)(roughness_ * 0xFF) << 24) |
			((uint32)(metallic_ * 0xFF) << 16) |
			(flags_ << 8) |
			((uint32)(translucency_ * 0xFF) << 0);

#ifndef HLSL
		uint32 uvScaleHalf = half(uvScale).h;
#else
		uint32 uvScaleHalf = f32tof16(uvScale);
#endif
		
		normalMapStrength_unused_uvScale =
			((uint32)(normalMapStrength_ * 0xFF) << 24) |
			0 |
			uvScaleHalf;
    }

#ifndef HLSL
    pbr_material_cb() {}

    pbr_material_cb(vec4 albedo_, vec3 emission_, float roughness_, float metallic_, uint32 flags_, float normalMapStrength_ = 1.f, float translucency_ = 0.f, float uvScale_ = 1.f)
    {
        initialize(albedo_, emission_, roughness_, metallic_, flags_, normalMapStrength_, translucency_, uvScale_);
    }
#endif

    vec4 getAlbedo()
    {
        return unpackColor(albedoTint);
    }

    float getRoughnessOverride()
    {
        return ((roughness_metallic_flags_translucency >> 24) & 0xFF) * (1.f / 255.f);
    }

    float getMetallicOverride()
    {
        return ((roughness_metallic_flags_translucency >> 16) & 0xFF) * (1.f / 255.f);
    }

	float getNormalMapStrength()
	{
		return ((normalMapStrength_unused_uvScale >> 24) & 0xFF) * (1.f / 255.f);
	}

	float uvScale()
	{
		uint32 uvScaleHalf = normalMapStrength_unused_uvScale & 0xFFFF;
#ifndef HLSL
		return half((uint16)uvScaleHalf);
#else
		return f16tof32(uvScaleHalf);
#endif
	}

	float getTranslucency()
	{
		return ((roughness_metallic_flags_translucency >> 0) & 0xFF) * (1.f / 255.f);
	}

	uint32 getFlags()
	{
		return (roughness_metallic_flags_translucency >> 8) & 0xFF;
	}
};




struct pbr_decal_cb
{
	vec3 position;
	uint32 albedoTint;			// RGBA packed into one uint32.
	vec3 right;					// Scaled by half dimension.
	uint32 roughnessOverride_metallicOverride;
	vec3 up;					// Scaled by half dimension.
	uint32 viewportXY;			// Top left corner packed into 16 bits each.
	vec3 forward;				// Scaled by half dimension.
	uint32 viewportScale;       // Width and height packed into 16 bits each.


	void initialize(vec3 position_, vec3 right_, vec3 up_, vec3 forward_, vec4 albedo_, float roughness_, float metallic_, vec4 viewport_)
	{
		position = position_;
		right = right_;
		up = up_;
		forward = forward_;

		albedoTint = packColor(albedo_);

		uint32 r = (uint32)(roughness_ * 0xFFFF);
		uint32 m = (uint32)(metallic_ * 0xFFFF);
		roughnessOverride_metallicOverride = (r << 16) | m;

		uint32 x = (uint32)(viewport_.x * 0xFFFF);
		uint32 y = (uint32)(viewport_.y * 0xFFFF);
		uint32 w = (uint32)(viewport_.z * 0xFFFF);
		uint32 h = (uint32)(viewport_.w * 0xFFFF);
		viewportXY = (x << 16) | y;
		viewportScale = (w << 16) | h;
	}

#ifndef HLSL
	pbr_decal_cb() {}

	pbr_decal_cb(vec3 position_, vec3 right_, vec3 up_, vec3 forward_, vec4 albedo_, float roughness_, float metallic_, vec4 viewport_)
	{
		initialize(position_, right_, up_, forward_, albedo_, roughness_, metallic_, viewport_);
	}
#endif

	vec4 getAlbedo()
	{
		return unpackColor(albedoTint);
	}

	float getRoughnessOverride()
	{
		return (roughnessOverride_metallicOverride >> 16) / (float)0xFFFF;
	}

	float getMetallicOverride()
	{
		return (roughnessOverride_metallicOverride & 0xFFFF) / (float)0xFFFF;
	}

	vec4 getViewport()
	{
		float x = (viewportXY >> 16) / (float)0xFFFF;
		float y = (viewportXY & 0xFFFF) / (float)0xFFFF;
		float w = (viewportScale >> 16) / (float)0xFFFF;
		float h = (viewportScale & 0xFFFF) / (float)0xFFFF;
		return vec4(x, y, w, h);
	}
};


// Alpha-blending performs the following operation: final = alpha * src + (1 - alpha) * dest.
// The factor on the destination-color is correct, and so is the factor on the diffuse part of the source-color.
// However emission and specular light should not be modulated by alpha, since these components are not affected by transparency.
// To counteract the hardware alpha-blending for these components, we pre-divide them by alpha.

static vec4 mergeAlphaBlended(vec3 diffuse, vec3 specular, vec3 emission, float alpha)
{
	return vec4((emission + specular) * (1.f / max(alpha, 1e-5f)) + diffuse, alpha);
}


#endif

```

`shaders/common/math.hlsli`:

```hlsli
#ifndef MATH_HLSLI
#define MATH_HLSLI


#define M_PI 3.14159265359f
#define M_PI_OVER_2 (M_PI * 0.5f)
#define M_PI_OVER_180 (M_PI / 180.f)
#define M_180_OVER_PI (180.f / M_PI)
#define M_SQRT_PI 1.77245385090f
#define M_TAU 6.28318530718f

#define M_INV_PI 0.3183098861837906f
#define M_INV_2_PI 0.1591549430918953f
#define M_INV_ATAN float2(M_INV_2_PI, M_INV_PI)


static float inverseLerp(float l, float u, float v) { return (v - l) / (u - l); }
static float remap(float v, float oldL, float oldU, float newL, float newU) { return lerp(newL, newU, inverseLerp(oldL, oldU, v)); }

static float solidAngleOfSphere(float radius, float distance)
{
	// The angular radius of a sphere is p = arcsin(radius / d). 
	// The solid angle of a circular cap (projection of sphere) is 2pi * (1 - cos(p)).
	// cos(arcsin(x)) = sqrt(1 - x*x)

	float s = radius / distance;
	return 2.f * M_PI * (1.f - sqrt(max(0.f, 1.f - s * s)));
}

static float square(float v) { return v * v; }
static float2 square(float2 v) { return v * v; }
static float3 square(float3 v) { return v * v; }
static float4 square(float4 v) { return v * v; }
static float pow3(float v) { return v * v * v; }

static float maxComponent(float3 a) { return max(a.x, max(a.y, a.z)); }

static uint flatten2D(uint2 coord, uint2 dim)
{
	return coord.x + coord.y * dim.x;
}

static uint flatten2D(uint2 coord, uint width)
{
	return coord.x + coord.y * width;
}

// Flattened array index to 2D array index.
static uint2 unflatten2D(uint idx, uint2 dim)
{
	return uint2(idx % dim.x, idx / dim.x);
}

static uint2 unflatten2D(uint idx, uint width)
{
	return uint2(idx % width, idx / width);
}

inline bool isSaturated(float a) { return a == saturate(a); }
inline bool isSaturated(float2 a) { return isSaturated(a.x) && isSaturated(a.y); }
inline bool isSaturated(float3 a) { return isSaturated(a.x) && isSaturated(a.y) && isSaturated(a.z); }
inline bool isSaturated(float4 a) { return isSaturated(a.x) && isSaturated(a.y) && isSaturated(a.z) && isSaturated(a.w); }


static float2 screenSpaceVelocity(float3 ndc, float3 prevFrameNDC, float2 jitter, float2 prevFrameJitter)
{
	float2 currNDC = (ndc.xy / ndc.z) - jitter;
	float2 prevNDC = (prevFrameNDC.xy / prevFrameNDC.z) - prevFrameJitter;

	float2 motion = (prevNDC - currNDC) * float2(0.5f, -0.5f);
	return motion;
}

static float2 quadFromVertexID(uint vertexID)
{
	return float2((vertexID << 1) & 2, vertexID & 2) - 1.f;
}


#define pack_float	4
#define pack_vec4	1
#define pack_float4	1

#define pack(num, data_type) num / pack_##data_type

// maxNumPoints must be a multiple of 4!
// data_type can currently be either float or vec4.
// The values are internally stored packed. This is because HLSL packs arrays in constant buffers
// in float4s. See https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-packing-rules.
// In order to conform to C++'s packing rules, we declare an array of float4s and cast it to an array of floats.
#define spline(data_type, maxNumPoints) catmull_rom_spline_##data_type##_##maxNumPoints

#define defineSpline(data_type, maxNumPoints)															\
struct spline(data_type, maxNumPoints)																	\
{																										\
	float4 packedTs[maxNumPoints / 4];																	\
	float4 packedValues[pack(maxNumPoints, data_type)];													\
																										\
	inline data_type evaluate(int numActualPoints, float t)												\
	{																									\
		float ts[maxNumPoints] = (float[maxNumPoints])packedTs;											\
		data_type values[maxNumPoints] = (data_type[maxNumPoints])packedValues;							\
																										\
		int k = 0;																						\
		[unroll(maxNumPoints)]																			\
		while (ts[k] < t)																				\
		{																								\
			++k;																						\
		}																								\
																										\
		const float h1 = inverseLerp(ts[k - 1], ts[k], t);												\
		const float h2 = h1 * h1;																		\
		const float h3 = h2 * h1;																		\
		const float4 h = float4(h3, h2, h1, 1.f);														\
																										\
		data_type result = (data_type)0;																\
																										\
		int m = numActualPoints - 1;																	\
		result += values[clamp(k - 2, 0, m)] * dot(float4(-1, 2, -1, 0), h);							\
		result += values[k - 1] * dot(float4(3, -5, 0, 2), h);											\
		result += values[k] * dot(float4(-3, 4, 1, 0), h);												\
		result += values[clamp(k + 1, 0, m)] * dot(float4(1, -1, 0, 0), h);								\
																										\
		result *= 0.5f;																					\
																										\
		return result;																					\
	}																									\
};

static inline uint packHalfs(float left, float right)
{
	return (f32tof16(left) << 16) | f32tof16(right);
}

static inline float unpackHalfsLeft(uint x)
{
	return f16tof32(x >> 16);
}

static inline float unpackHalfsRight(uint x)
{
	return f16tof32(x);
}

static inline void unpackHalfs(uint x, out float left, out float right)
{
	left = unpackHalfsLeft(x);
	right = unpackHalfsRight(x);
}

static inline float cross2(float2 a, float2 b)
{ 
	return a.x * b.y - a.y * b.x; 
}

//	https://www.lgdv.tf.fau.de/publications/spherical-fibonacci-mapping/
static float3 sphericalFibonacci(float i, float n)
{
	const float PHI = sqrt(5.f) * 0.5f + 0.5f;
#   define madfrac(a, b) ((a)*(b)-floor((a)*(b)))
	float phi = 2.f * M_PI * madfrac(i, PHI - 1);
	float cosTheta = 1.f - (2.f * i + 1.f) * (1.f / n);
	float sinTheta = sqrt(saturate(1.f - cosTheta * cosTheta));

	float sinPhi, cosPhi;
	sincos(phi, sinPhi, cosPhi);

	return float3(
		cosPhi * sinTheta,
		sinPhi * sinTheta,
		cosTheta);

#   undef madfrac
}


#endif

```

`shaders/common/normal.hlsli`:

```hlsli
#ifndef NORMAL_HLSLI
#define NORMAL_HLSLI


#if 0

// Spheremap Transform
// https://aras-p.info/texts/CompactNormalStorage.html#method04spheremap
static float2 packNormal(float3 n)
{
    float p = sqrt(n.z * 8 + 8);
    return float2(n.xy / p + 0.5);
}

static float3 unpackNormal(float2 enc)
{
    float2 fenc = enc * 4 - 2;
    float f = dot(fenc, fenc);
    if (f != f)
    {
        return float3(0.f, 0.f, -1.f);
    }

    float g = sqrt(1 - f / 4);
    float3 n;
    n.xy = fenc * g;
    n.z = 1 - f / 2;
    return n;
}

#else

// Stereographic Transform
// https://aras-p.info/texts/CompactNormalStorage.html#method07stereo
static float2 packNormal(float3 n)
{
    float2 enc = n.xy / (n.z + 1.f);

    // This scaling would be necessary, if we store the normal in a UNORM-format.
    //const float scale = 1.f / 1.7777f;
    //enc *= scale;
    //enc = enc * 0.5f + 0.5f;

    return enc;
}

static float3 unpackNormal(float2 enc)
{
    // enc = enc * 2 - vec2(1, 1);
    //const float scale = 1.7777f;
    //enc = enc * scale;

    float3 nn = float3(enc, 1.f);
    float g = 2.f / dot(nn, nn);

    return (g != g) ? float3(0.f, 0.f, -1.f) : float3(g * nn.xy, g - 1.f);
}

#endif


static float3 sampleNormalMap(Texture2D<float3> normalMap, SamplerState s, float2 uv)
{
    float3 N = normalMap.Sample(s, uv).xyz;
    bool reconstructZ = N.z == 0.f;
    N = N * 2.f - 1.f;

    if (reconstructZ)
    {
        N.z = sqrt(1.f - dot(N.xy, N.xy));
    }

    return N;
}

static float3 combineNormalMaps(float3 n1, float3 n2)
{
    // Whiteout blend: https://blog.selfshadow.com/publications/blending-in-detail/
    return normalize(float3(n1.xy + n2.xy, n1.z * n2.z));
}

static float3 scaleNormalMap(float3 n, float strength)
{
    return n * float3(strength, strength, 1.f);
}

#endif

```

`shaders/common/particles.hlsli`:

```hlsli
#ifndef PARTICLES_HLSLI
#define PARTICLES_HLSLI


static float getRelLife(float life, float maxLife)
{
	float relLife = saturate((maxLife - life) / maxLife);
	return relLife;
}


#endif

```

`shaders/common/procedural_sky.hlsli`:

```hlsli
#ifndef PROCEDURAL_SKY_HLSLI
#define PROCEDURAL_SKY_HLSLI

#include "random.hlsli"
#include "math.hlsli"


static float getStars(float3 V)
{
	const float scale = 60.f;
	float3 id = floor(V * scale);
	float d = length(scale * V - (id + 0.5f));

	float2 uv = id.xy + vec2(37.f, 17.f) * id.z;
	float rnd = random(uv + 0.5f);

	// https://www.shadertoy.com/view/ttScDc
	float stars = sqrt(0.075f / max(d, 1e-7f)) * (rnd.x > 0.92f && d < 0.15f);

	return stars;
}



// Based on Morgan McGuire @morgan3d
// https://www.shadertoy.com/view/4dS3Wd
float fbmNoise(float2 st)
{
	float2 i = floor(st);
	float2 f = frac(st);

	// Four corners in 2D of a tile
	float a = random(i);
	float b = random(i + float2(1.f, 0.f));
	float c = random(i + float2(0.f, 1.f));
	float d = random(i + float2(1.f, 1.f));

	vec2 u = f * f * (3.f - 2.f * f);

	return lerp(a, b, u.x) +
		(c - a) * u.y * (1.f - u.x) +
		(d - b) * u.x * u.y;
}

#define FBM_OCTAVES 6
float cloudFBM(float2 st)
{
	// Initial values
	float value = 0.f;
	float amplitude = .5f;
	float frequency = 0.f;
	//
	// Loop of octaves
	for (int i = 0; i < FBM_OCTAVES; ++i)
	{
		value += amplitude * fbmNoise(st);
		st *= 2.;
		amplitude *= .5;
	}
	return value;
}







static float getCloudValue(float2 p, float intensity)
{
	const float density = 0.5f;
	const float sharpness = 0.1f;
	const float scale = 1.f / 0.05f;

	float noise = cloudFBM(p);

	noise = saturate(1.f - exp(-(noise - density) * sharpness)) * scale;
	return noise * intensity;
}

static float getClouds(float3 V)
{
	const float height = 1000.f;

	float ndotd = -V.y;

	float result = 0.f;
	if (abs(ndotd) >= 1e-6f)
	{
		float t = -height / ndotd;
		if (t > 0.f)
		{
			float3 hit = t * V;
			float l = length(hit.xz);

			float intensity = 1.f - smoothstep(0.f, 30000.f, l);

			float2 p = hit.xz * 0.0007f;
			result = getCloudValue(p, intensity);
		}
#if 0
		const float delta = 0.1f;
		const float invDelta = 1.f / delta;

		float nx = getCloudValue(p + float2(delta, 0.f), intensity);
		float nz = getCloudValue(p + float2(0.f, delta), intensity);

		float3 N = normalize(float3(
			-(nx - value) * invDelta,
			-1.f,
			-(nz - value) * invDelta
			));

#endif
	}
	return result;
}

static float3 proceduralSky(float3 V, float3 L)
{
	float LdotV = dot(V, L);

	// https://www.shadertoy.com/view/tt3cDl
	float3 skycolor = float3(0.2f, 0.4f, 0.8f) * max(0.2f, L.y);
	float3 suncolor = saturate(lerp(float3(0.99f, 0.3f, 0.1f), float3(1.f, 1.f, 0.8f), L.y));
	float3 sunhalo =
		lerp(
			max(0.f, (1.f - max(0.f, (1.f - L.y * 3.f)) * V.y * 4.f)),
			0.f,
			L.y)
		* saturate(pow(saturate(0.5f * LdotV + 0.5f), (8.f - L.y * 5.f)))
		* suncolor;


	float3 color = skycolor;
	//color += saturate(2.f * pow(saturate(LdotV), 800.f)) * (suncolor + 0.4f.xxx);
	color += saturate(2.f * pow(saturate(LdotV), 2500.f)) * (suncolor + 0.4f.xxx) * 300.f;
	color += square(sunhalo);
	color += square(1.f - V.y) * suncolor * 0.5f;

	color += (getStars(V * 1.5f) + getStars(V * 3.f)) * saturate(-0.3f - L.y);

	color += getClouds(V);

	return color;
}

static float3 proceduralSkySimple(float3 V, float3 L)
{
	float LdotV = dot(V, L);

	// https://www.shadertoy.com/view/tt3cDl
	float3 skycolor = float3(0.2f, 0.4f, 0.8f) * max(0.2f, L.y);
	float3 suncolor = saturate(lerp(float3(0.99f, 0.3f, 0.1f), float3(1.f, 1.f, 0.8f), L.y));
	float3 sunhalo =
		lerp(
			max(0.f, (1.f - max(0.f, (1.f - L.y * 3.f)) * V.y * 4.f)),
			0.f,
			L.y)
		* saturate(pow(saturate(0.5f * LdotV + 0.5f), (8.f - L.y * 5.f)))
		* suncolor;


	float3 color = skycolor;
	color += square(sunhalo);
	color += square(1.f - V.y) * suncolor * 0.5f;

	color += getClouds(V);

	return color;
}


#endif

```

`shaders/common/random.hlsli`:

```hlsli
#ifndef RANDOM_HLSLI
#define RANDOM_HLSLI

#include "math.hlsli"

static float halton(uint index, uint base)
{
	float fraction = 1.f;
	float result = 0.f;
	while (index > 0)
	{
		fraction /= (float)base;
		result += fraction * (index % base);
		index = ~~(index / base);
	}
	return result;
}

static float2 halton23(uint index)
{
	return float2(halton(index, 2), halton(index, 3));
}



static uint hash(uint x)
{
	x += (x << 10u);
	x ^= (x >> 6u);
	x += (x << 3u);
	x ^= (x >> 11u);
	x += (x << 15u);
	return x;
}

// Compound versions of the hashing algorithm I whipped together.
static uint hash(uint2 v) { return hash(v.x ^ hash(v.y)); }
static uint hash(uint3 v) { return hash(v.x ^ hash(v.y) ^ hash(v.z)); }
static uint hash(uint4 v) { return hash(v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w)); }

// Construct a float with half-open range [0:1] using low 23 bits.
// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.
static float floatConstruct(uint m)
{
	const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask
	const uint ieeeOne = 0x3F800000u; // 1.0 in IEEE binary32

	m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)
	m |= ieeeOne;                          // Add fractional part to 1.0

	float  f = asfloat(m);       // Range [1:2]
	return f - 1.f;              // Range [0:1]
}

// Pseudo-random value in half-open range [0:1].
static float random(float  x) { return floatConstruct(hash(asuint(x))); }
static float random(float2 v) { return floatConstruct(hash(asuint(v))); }
static float random(float3 v) { return floatConstruct(hash(asuint(v))); }
static float random(float4 v) { return floatConstruct(hash(asuint(v))); }




static float2 hammersley(uint i, uint N)
{
	// Van der Corpus sequence.
	uint bits = i;
	bits = (bits << 16u) | (bits >> 16u);
	bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
	bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
	bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
	bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
	float vdc = float(bits) * 2.3283064365386963e-10; // / 0x100000000

	return float2(float(i) / float(N), vdc);
}

// "Next Generation Post Processing in Call of Duty: Advanced Warfare"
// http://advances.realtimerendering.com/s2014/index.html
static float interleavedGradientNoise(float2 uv, uint frameCount)
{
	frameCount &= 1023;
	const float2 magicFrameScale = float2(47.f, 17.f) * 0.695f;
	uv += frameCount * magicFrameScale;

	const float3 magic = float3(0.06711056f, 0.00583715f, 52.9829189f);
	return frac(magic.z * frac(dot(uv, magic.xy)));
}





static uint initRand(uint val0, uint val1, uint backoff = 16)
{
	uint v0 = val0, v1 = val1, s0 = 0;

	[unroll]
	for (uint n = 0; n < backoff; n++)
	{
		s0 += 0x9e3779b9;
		v0 += ((v1 << 4) + 0xa341316c) ^ (v1 + s0) ^ ((v1 >> 5) + 0xc8013ea4);
		v1 += ((v0 << 4) + 0xad90777d) ^ (v0 + s0) ^ ((v0 >> 5) + 0x7e95761e);
	}
	return v0;
}

// Returns a pseudorandom float in [0..1].
static float nextRand(inout uint s)
{
	s = (1664525u * s + 1013904223u);
	return float(s & 0x00FFFFFF) / float(0x01000000);
}

// Returns a pseudorandom float in [lo..hi].
static float nextRandBetween(inout uint s, float lo, float hi)
{
	return nextRand(s) * (hi - lo) + lo;
}

// Utility function to get a vector perpendicular to an input vector 
//    (from "Efficient Construction of Perpendicular Vectors Without Branching")
static float3 getPerpendicularVector(float3 u)
{
	float3 a = abs(u);
	uint xm = ((a.x - a.y) < 0 && (a.x - a.z) < 0) ? 1 : 0;
	uint ym = (a.y - a.z) < 0 ? (1 ^ xm) : 0;
	uint zm = 1 ^ (xm | ym);
	return cross(u, float3(xm, ym, zm));
}

// Get a cosine-weighted random vector centered around a specified normal direction.
static float3 getCosHemisphereSample(inout uint randSeed, float3 hitNorm)
{
	// Get 2 random numbers to select our sample with.
	float2 randVal = float2(nextRand(randSeed), nextRand(randSeed));

	// Cosine weighted hemisphere sample from RNG.
	float3 bitangent = getPerpendicularVector(hitNorm);
	float3 tangent = cross(bitangent, hitNorm);
	float r = sqrt(randVal.x);
	float phi = 2.0f * 3.14159265f * randVal.y;

	// Get our cosine-weighted hemisphere lobe sample direction.
	return tangent * (r * cos(phi).x) + bitangent * (r * sin(phi)) + hitNorm.xyz * sqrt(1 - randVal.x);
}

static float3 getRandomPointOnUnitSphere(inout uint randSeed)
{
	float2 h = float2(nextRand(randSeed), nextRand(randSeed)) * float2(2.f, 2.f * M_PI) - float2(1.f, 0.f);
	float phi = h.y;
	return normalize(float3(sqrt(1.f - h.x * h.x) * float2(sin(phi), cos(phi)), h.x));
}

static float3 getRandomPointOnSphere(inout uint randSeed, float radius)
{
	return getRandomPointOnUnitSphere(randSeed) * radius;
}

static float2 getRandomPointOnUnitDisk(inout uint randSeed)
{
	float d;
	float2 result;

	do 
	{
		result = float2(nextRand(randSeed), nextRand(randSeed)) * 2.f - 1.f;
		d = dot(result, result);
	} while (d >= 1.f);

	return result;
}

static float2 getRandomPointOnDisk(inout uint randSeed, float radius)
{
	return getRandomPointOnUnitDisk(randSeed) * radius;
}



static float3 valueNoise(float2 x)
{
	float2 p = floor(x);
	float2 w = frac(x);

	float2 u = w * w * w * (w * (w * 6.f - 15.f) + 10.f);
	float2 du = 30.f * w * w * (w * (w - 2.f) + 1.f);

	float a = random(p);
	float b = random(p + float2(1, 0));
	float c = random(p + float2(0, 1));
	float d = random(p + float2(1, 1));

	float k0 = a;
	float k1 = b - a;
	float k2 = c - a;
	float k3 = a - b - c + d;

	float value = -1.f + 2.f * (k0 + k1 * u.x + k2 * u.y + k3 * u.x * u.y);
	float2 deriv = 2.f * du *
		float2(
			k1 + k3 * u.y,
			k2 + k3 * u.x);

	return float3(value, deriv.x, deriv.y);
}

static float3 fbm(float2 x, uint numOctaves = 6, float lacunarity = 1.98f, float gain = 0.49f)
{
	float value = 0.f;
	float amplitude = 0.5f;

	float2 deriv = 0.f;
	float m = 1.f;

	for (uint32 i = 0; i < numOctaves; ++i)
	{
		float3 n = valueNoise(x);

		value += amplitude * n.x;		// Accumulate values.
		deriv += amplitude * m * n.yz;  // Accumulate derivatives.

		amplitude *= gain;

		x *= lacunarity;
		m *= lacunarity;
	}
	return float3(value, deriv.x, deriv.y);
}





#endif

```

`shaders/common/raytracing.hlsli`:

```hlsli
#ifndef RAYTRACING_HLSLI
#define RAYTRACING_HLSLI

struct path_tracing_cb
{
	uint32 frameCount;
	uint32 numAccumulatedFrames;
	uint32 maxRecursionDepth;
	uint32 startRussianRouletteAfter;

	uint32 useThinLensCamera;
	float focalLength;
	float lensRadius;

	uint32 useRealMaterials;
	uint32 enableDirectLighting;
	float lightIntensityScale;
	float pointLightRadius;

	uint32 multipleImportanceSampling;
};


#ifdef HLSL

static float3 hitWorldPosition()
{
	return WorldRayOrigin() + RayTCurrent() * WorldRayDirection();
}

// Careful: These two functions transform from BLAS space to TLAS space (world space). 
// However, if your geometry _inside_ the BLAS has a local transform, this is NOT
// accounted for here. For some reason, DX requires you to pass this transform in as 
// a buffer and do the transformation yourself, even though it has this information 
// already. 
static float3 transformPositionToWorld(float3 position)
{
	float3x4 M = ObjectToWorld3x4();
	return mul(M, float4(position, 1.f)).xyz;
}

static float3 transformDirectionToWorld(float3 direction)
{
	float3x4 M = ObjectToWorld3x4();
	return normalize(mul(M, float4(direction, 0.f)).xyz);
}

static float2 interpolateAttribute(float2 vertexAttribute[3], BuiltInTriangleIntersectionAttributes attribs)
{
	return vertexAttribute[0] +
		attribs.barycentrics.x * (vertexAttribute[1] - vertexAttribute[0]) +
		attribs.barycentrics.y * (vertexAttribute[2] - vertexAttribute[0]);
}

static float3 interpolateAttribute(float3 vertexAttribute[3], BuiltInTriangleIntersectionAttributes attribs)
{
	return vertexAttribute[0] +
		attribs.barycentrics.x * (vertexAttribute[1] - vertexAttribute[0]) +
		attribs.barycentrics.y * (vertexAttribute[2] - vertexAttribute[0]);
}

static float4 interpolateAttribute(float4 vertexAttribute[3], BuiltInTriangleIntersectionAttributes attribs)
{
	return vertexAttribute[0] +
		attribs.barycentrics.x * (vertexAttribute[1] - vertexAttribute[0]) +
		attribs.barycentrics.y * (vertexAttribute[2] - vertexAttribute[0]);
}

static uint3 load3x16BitIndices(ByteAddressBuffer meshIndices)
{
	const uint indexSizeInBytes = 2;
	const uint indicesPerTriangle = 3;
	const uint triangleIndexStride = indicesPerTriangle * indexSizeInBytes;
	uint baseIndex = PrimitiveIndex() * triangleIndexStride;

	uint3 indices;

	// ByteAdressBuffer loads must be aligned at a 4 byte boundary.
	// Since we need to read three 16 bit indices: { 0, 1, 2 } 
	// aligned at a 4 byte boundary as: { 0 1 } { 2 0 } { 1 2 } { 0 1 } ...
	// we will load 8 bytes (~ 4 indices { a b | c d }) to handle two possible index triplet layouts,
	// based on first index's baseIndex being aligned at the 4 byte boundary or not:
	//  Aligned:     { 0 1 | 2 - }
	//  Not aligned: { - 0 | 1 2 }
	const uint dwordAlignedOffset = baseIndex & ~3;
	const uint2 four16BitIndices = meshIndices.Load2(dwordAlignedOffset);

	// Aligned: { 0 1 | 2 - } => retrieve first three 16bit indices
	if (dwordAlignedOffset == baseIndex)
	{
		indices.x = four16BitIndices.x & 0xffff;
		indices.y = (four16BitIndices.x >> 16) & 0xffff;
		indices.z = four16BitIndices.y & 0xffff;
	}
	else // Not aligned: { - 0 | 1 2 } => retrieve last three 16bit indices
	{
		indices.x = (four16BitIndices.x >> 16) & 0xffff;
		indices.y = four16BitIndices.y & 0xffff;
		indices.z = (four16BitIndices.y >> 16) & 0xffff;
	}

	return indices;
}

static uint3 load3x32BitIndices(ByteAddressBuffer meshIndices)
{
	const uint indexSizeInBytes = 4;
	const uint indicesPerTriangle = 3;
	const uint triangleIndexStride = indicesPerTriangle * indexSizeInBytes;
	uint baseIndex = PrimitiveIndex() * triangleIndexStride;

	uint3 indices = meshIndices.Load3(baseIndex);

	return indices;
}

#endif


#endif

```

`shaders/common/transform.hlsli`:

```hlsli
#ifndef TRANSFORM_HLSLI
#define TRANSFORM_HLSLI

// Attention: Even though transform.m is declared as a 3x4 matrix, due to padding it is actually a 4x4 matrix (each column is padded to a float4). Therefore it takes 16 floats of space.
// On the CPU side we act as if 'm' is a mat4. My hope is that a 3x4 matrix uses fewer instructions than a 4x4 matrix, when multiplied with a vector. This remains to be tested though.

#ifndef HLSL
#define mat3x4 mat4
#endif

struct transform_cb
{
    mat4 mvp;
    mat3x4 m;
};

#endif

```

`shaders/fullscreen_triangle_vs.hlsl`:

```hlsl

struct vs_input
{
	uint vertexID	: SV_VertexID;
};

struct vs_output
{
	float2 uv		: TEXCOORDS;
	float4 position : SV_Position;
};

vs_output main(vs_input IN)
{
	vs_output OUT;

	float x = float((IN.vertexID & 1) << 2) - 1.f;
	float y = 1.f - float((IN.vertexID & 2) << 1);
	float u = x * 0.5f + 0.5f;
	float v = y * 0.5f + 0.5f;
	OUT.position = float4(x, -y, 0.f, 1.f);
	OUT.uv = float2(u, v);

	return OUT;
}

```

`shaders/geometry/default_pbr_ps.hlsl`:

```hlsl
#include "default_pbr_rs.hlsli"
#include "camera.hlsli"
#include "lighting.hlsli"
#include "normal.hlsli"
#include "material.hlsli"

struct ps_input
{
	float2 uv				: TEXCOORDS;
	float3x3 tbn			: TANGENT_FRAME;
	float3 worldPosition	: POSITION;

	float4 screenPosition	: SV_POSITION;
	bool isFrontFace		: SV_IsFrontFace;
};

ConstantBuffer<pbr_material_cb> material				: register(b0, space1);
ConstantBuffer<camera_cb> camera						: register(b1, space1);
ConstantBuffer<lighting_cb> lighting					: register(b2, space1);


SamplerState wrapSampler								: register(s0);
SamplerState clampSampler								: register(s1);
SamplerComparisonState shadowSampler					: register(s2);


Texture2D<float4> albedoTex								: register(t0, space1);
Texture2D<float3> normalTex								: register(t1, space1);
Texture2D<float> roughTex								: register(t2, space1);
Texture2D<float> metalTex								: register(t3, space1);


TextureCube<float4> irradianceTexture					: register(t0, space2);
TextureCube<float4> prefilteredRadianceTexture			: register(t1, space2);

Texture2D<float2> brdf									: register(t2, space2);

Texture2D<uint4> tiledCullingGrid						: register(t3, space2);
StructuredBuffer<uint> tiledObjectsIndexList			: register(t4, space2);
StructuredBuffer<point_light_cb> pointLights			: register(t5, space2);
StructuredBuffer<spot_light_cb> spotLights				: register(t6, space2);
StructuredBuffer<pbr_decal_cb> decals					: register(t7, space2);
Texture2D<float> shadowMap								: register(t8, space2);
StructuredBuffer<point_shadow_info> pointShadowInfos	: register(t9, space2);
StructuredBuffer<spot_shadow_info> spotShadowInfos		: register(t10, space2);

Texture2D<float4> decalTextureAtlas                     : register(t11, space2);

Texture2D<float> aoTexture								: register(t12, space2);
Texture2D<float> sssTexture								: register(t13, space2);
Texture2D<float4> ssrTexture							: register(t14, space2);

Texture2D<float3> lightProbeIrradiance					: register(t15, space2);
Texture2D<float2> lightProbeDepth						: register(t16, space2);


struct ps_output
{
	float4 hdrColor				: SV_Target0;

#ifndef TRANSPARENT
	float4 worldNormalRoughness	: SV_Target1;
#endif
};


#ifndef RS
#define RS DEFAULT_PBR_RS
#endif

#ifndef ALPHA_CUTOUT
[earlydepthstencil]
#endif
[RootSignature(RS)]
ps_output main(ps_input IN)
{
	uint flags = material.getFlags();
	float2 materialUV = IN.uv * material.uvScale();

	surface_info surface;

	surface.albedo = ((flags & MATERIAL_USE_ALBEDO_TEXTURE)
		? albedoTex.Sample(wrapSampler, materialUV)
		: float4(1.f, 1.f, 1.f, 1.f))
		* material.getAlbedo();

#ifdef ALPHA_CUTOUT
	clip(surface.albedo.w - 0.5f);
#endif

	const float normalMapStrength = material.getNormalMapStrength() * 0.2f;
	surface.N = (flags & MATERIAL_USE_NORMAL_TEXTURE)
		? mul(float3(normalMapStrength, normalMapStrength, 1.f) * sampleNormalMap(normalTex, wrapSampler, materialUV), IN.tbn)
		: IN.tbn[2];
	surface.N = normalize(surface.N);
	if ((flags & MATERIAL_DOUBLE_SIDED) && !IN.isFrontFace)
	{
		surface.N = -surface.N;
	}

	surface.roughness = (flags & MATERIAL_USE_ROUGHNESS_TEXTURE)
		? roughTex.Sample(wrapSampler, materialUV)
		: material.getRoughnessOverride();
	surface.roughness = clamp(surface.roughness, 0.01f, 0.99f);

	surface.metallic = (flags & MATERIAL_USE_METALLIC_TEXTURE)
		? metalTex.Sample(wrapSampler, materialUV)
		: material.getMetallicOverride();

	surface.emission = material.emission;

	surface.P = IN.worldPosition;
	float3 camToP = surface.P - camera.position.xyz;
	surface.V = -normalize(camToP);

	float pixelDepth = dot(camera.forward.xyz, camToP);




	light_contribution totalLighting = { float3(0.f, 0.f, 0.f), float3(0.f, 0.f, 0.f) };


	// Tiled lighting.
	const uint2 tileIndex = uint2(IN.screenPosition.xy / LIGHT_CULLING_TILE_SIZE);

#ifndef TRANSPARENT
	const uint2 tiledIndexData = tiledCullingGrid[tileIndex].xy;
#else
	const uint2 tiledIndexData = tiledCullingGrid[tileIndex].zw;
#endif

	const uint decalReadOffset = tiledIndexData.x;


	// Decals.
#if 1
	float3 decalAlbedoAccum = (float3)0.f;
	float decalRoughnessAccum = 0.f;
	float decalMetallicAccum = 0.f;
	float decalAlphaAccum = 0.f;

	for (uint decalBucketIndex = 0; (decalBucketIndex < NUM_DECAL_BUCKETS) && (decalAlphaAccum < 1.f); ++decalBucketIndex)
	{
		uint bucket = tiledObjectsIndexList[decalReadOffset + decalBucketIndex];

		[loop]
		while (bucket)
		{
			const uint indexOfLowestSetBit = firstbitlow(bucket);
			bucket ^= 1u << indexOfLowestSetBit; // Unset this bit.

			uint decalIndex = decalBucketIndex * 32 + indexOfLowestSetBit;
			decalIndex = MAX_NUM_TOTAL_DECALS - decalIndex - 1; // Reverse of operation in culling shader.
			pbr_decal_cb decal = decals[decalIndex];

			float3 offset = surface.P - decal.position;
			float3 local = float3(
				dot(decal.right, offset) / (dot(decal.right, decal.right)),
				dot(decal.up, offset) / (dot(decal.up, decal.up)),
				dot(decal.forward, offset) / (dot(decal.forward, decal.forward))
				);

			float decalStrength = saturate(dot(-surface.N, normalize(decal.forward)));

			[branch]
			if (all(local >= -1.f && local <= 1.f) && decalStrength > 0.f)
			{
				float2 uv = local.xy * 0.5f + 0.5f;                
				
				float4 viewport = decal.getViewport();
				uv = viewport.xy + uv * viewport.zw;

				// Since this loop has variable length, we cannot use automatic mip-selection here. Gradients may be undefined.
				const float4 decalAlbedo = decalTextureAtlas.SampleLevel(wrapSampler, uv, 0) * decal.getAlbedo();
				const float decalRoughness = decal.getRoughnessOverride();
				const float decalMetallic = decal.getMetallicOverride();
				
				const float alpha = decalAlbedo.a * decalStrength;
				const float oneMinusDecalAlphaAccum = 1.f - decalAlphaAccum;

				decalAlbedoAccum += oneMinusDecalAlphaAccum * (alpha * decalAlbedo.rgb);
				decalRoughnessAccum += oneMinusDecalAlphaAccum * (alpha * decalRoughness);
				decalMetallicAccum += oneMinusDecalAlphaAccum * (alpha * decalMetallic);

				decalAlphaAccum = alpha + (1.f - alpha) * decalAlphaAccum;

				[branch]
				if (decalAlphaAccum >= 1.f)
				{
					decalAlphaAccum = 1.f;
					break;
				}
			}
		}
	}

	surface.albedo.rgb = lerp(surface.albedo.rgb, decalAlbedoAccum, decalAlphaAccum);
	surface.roughness = lerp(surface.roughness, decalRoughnessAccum, decalAlphaAccum);
	surface.metallic = lerp(surface.metallic, decalMetallicAccum, decalAlphaAccum);
#endif

	surface.inferRemainingProperties();

	float2 screenUV = IN.screenPosition.xy * camera.invScreenDims;

	totalLighting.addPointLights(surface, pointLights, pointShadowInfos, tiledObjectsIndexList, tiledIndexData, 
		shadowMap, shadowSampler, lighting.shadowMapTexelSize);

	totalLighting.addSpotLights(surface, spotLights, spotShadowInfos, tiledObjectsIndexList, tiledIndexData,
		shadowMap, shadowSampler, lighting.shadowMapTexelSize);

	totalLighting.addSunLight(surface, lighting, screenUV, pixelDepth, 
		shadowMap, shadowSampler, lighting.shadowMapTexelSize, sssTexture, clampSampler, material.getTranslucency());

	[branch]
	if (lighting.useRaytracedGlobalIllumination)
	{
		totalLighting.addRaytracedAmbientLighting(surface, lighting, lightProbeIrradiance, lightProbeDepth, ssrTexture, aoTexture, clampSampler, screenUV);
	}
	else
	{
		totalLighting.addImageBasedAmbientLighting(surface, irradianceTexture, prefilteredRadianceTexture, brdf, ssrTexture, aoTexture, clampSampler, screenUV, lighting.globalIlluminationIntensity);
	}

	// Output.
	ps_output OUT;

#ifndef TRANSPARENT
	OUT.hdrColor = totalLighting.evaluate(surface.albedo);
	OUT.hdrColor.rgb += surface.emission;

	OUT.worldNormalRoughness = float4(packNormal(surface.N), surface.roughness, 0.f);
#else

	OUT.hdrColor = mergeAlphaBlended(totalLighting.diffuse * surface.albedo.rgb, totalLighting.specular, surface.emission, surface.albedo.a);
#endif

	return OUT;
}

```

`shaders/geometry/default_pbr_transparent_ps.hlsl`:

```hlsl
#define TRANSPARENT
#include "default_pbr_ps.hlsl"

```

`shaders/geometry/default_vs.hlsl`:

```hlsl
#include "default_pbr_rs.hlsli"
#include "camera.hlsli"

StructuredBuffer<float4x4> transforms	: register(t0);
ConstantBuffer<camera_cb> camera		: register(b1, space1);

struct vs_input
{
	float3 position		: POSITION;
	float2 uv			: TEXCOORDS;
	float3 normal		: NORMAL;
	float3 tangent		: TANGENT;

	uint instanceID		: SV_InstanceID;
};

struct vs_output
{
	float2 uv				: TEXCOORDS;
	float3x3 tbn			: TANGENT_FRAME;
	float3 worldPosition	: POSITION;

	float4 position			: SV_POSITION;
};

vs_output main(vs_input IN)
{
	float4x4 m = transforms[IN.instanceID];
	float4 worldPosition = mul(m, float4(IN.position, 1.f));

	vs_output OUT;
	OUT.position = mul(camera.viewProj, worldPosition);

	OUT.uv = IN.uv;
	OUT.worldPosition = worldPosition.xyz;

	float3 normal = normalize(mul(m, float4(IN.normal, 0.f)).xyz);
	float3 tangent = normalize(mul(m, float4(IN.tangent, 0.f)).xyz);
	float3 bitangent = normalize(cross(normal, tangent));
	OUT.tbn = float3x3(tangent, bitangent, normal);

	return OUT;
}

```

`shaders/geometry/depth_only_alpha_cutout_ps.hlsl`:

```hlsl
#include "depth_only_rs.hlsli"
#include "camera.hlsli"
#include "math.hlsli"

ConstantBuffer<camera_cb> camera	: register(b0, space1);

Texture2D<float4> alpha				: register(t0, space1);
SamplerState wrapSampler			: register(s0);

struct ps_input
{
	float2 uv						: TEXCOORDS;
	float3 ndc						: NDC;
	float3 prevFrameNDC				: PREV_FRAME_NDC;

	nointerpolation uint objectID	: OBJECT_ID;
};

struct ps_output
{
	float2 screenVelocity	: SV_Target0;
	uint objectID			: SV_Target1;
};

ps_output main(ps_input IN)
{
	float a = alpha.Sample(wrapSampler, IN.uv).w;
	clip(a - 0.5f);

	ps_output OUT;
	OUT.screenVelocity = screenSpaceVelocity(IN.ndc, IN.prevFrameNDC, camera.jitter, camera.prevFrameJitter);
	OUT.objectID = IN.objectID;
	return OUT;
}

```

`shaders/geometry/depth_only_alpha_cutout_vs.hlsl`:

```hlsl
#define ALPHA_CUTOUT
#define RS ALPHA_CUTOUT_DEPTH_ONLY_RS
#include "depth_only_vs.hlsl"

```

`shaders/geometry/depth_only_ps.hlsl`:

```hlsl
#include "depth_only_rs.hlsli"
#include "camera.hlsli"
#include "math.hlsli"

ConstantBuffer<camera_cb> camera	: register(b0, space1);

struct ps_input
{
	float3 ndc						: NDC;
	float3 prevFrameNDC				: PREV_FRAME_NDC;

	nointerpolation uint objectID	: OBJECT_ID;
};

struct ps_output
{
	float2 screenVelocity	: SV_Target0;
	uint objectID			: SV_Target1;
};

ps_output main(ps_input IN)
{
	ps_output OUT;
	OUT.screenVelocity = screenSpaceVelocity(IN.ndc, IN.prevFrameNDC, camera.jitter, camera.prevFrameJitter);
	OUT.objectID = IN.objectID;
	return OUT;
}

```

`shaders/geometry/depth_only_vs.hlsl`:

```hlsl
#include "depth_only_rs.hlsli"
#include "camera.hlsli"

StructuredBuffer<float4x4> transforms			: register(t0);
StructuredBuffer<float4x4> prevFrameTransforms	: register(t1);
StructuredBuffer<uint> objectIDs				: register(t2);
ConstantBuffer<camera_cb> camera				: register(b0, space1);

struct vs_input
{
	float3 position				: POSITION;
	float3 prevFramePosition	: PREV_POSITION;

#ifdef ALPHA_CUTOUT
	float2 uv					: TEXCOORDS;
#endif

	uint instanceID				: SV_InstanceID;
};

struct vs_output
{
#ifdef ALPHA_CUTOUT
	float2 uv						: TEXCOORDS;
#endif

	float3 ndc						: NDC;
	float3 prevFrameNDC				: PREV_FRAME_NDC;

	nointerpolation uint objectID	: OBJECT_ID;

	float4 position					: SV_POSITION;
};

#ifndef RS
#define RS DEPTH_ONLY_RS
#endif

[RootSignature(RS)]
vs_output main(vs_input IN)
{
	float4 worldPosition = mul(transforms[IN.instanceID], float4(IN.position, 1.f));
	float4 prevFrameWorldPosition = mul(prevFrameTransforms[IN.instanceID], float4(IN.prevFramePosition, 1.f));

	vs_output OUT;
	OUT.position = mul(camera.viewProj, worldPosition);
	OUT.ndc = OUT.position.xyw;
	OUT.prevFrameNDC = mul(camera.prevFrameViewProj, prevFrameWorldPosition).xyw;
	OUT.objectID = objectIDs[IN.instanceID];

#ifdef ALPHA_CUTOUT
	OUT.uv = IN.uv;
#endif

	return OUT;
}

```

`shaders/geometry/shadow_point_light_ps.hlsl`:

```hlsl


struct ps_input
{
	float clipDepth		: CLIP_DEPTH;
};

void main(ps_input IN)
{
	clip(IN.clipDepth);
}

```

`shaders/geometry/shadow_point_light_vs.hlsl`:

```hlsl
#include "depth_only_rs.hlsli"


StructuredBuffer<float4x4> transforms	: register(t0);
ConstantBuffer<point_shadow_cb> cb		: register(b0);

struct vs_input
{
	float3 position		: POSITION;

	uint instanceID		: SV_InstanceID;
};

struct vs_output
{
	float clipDepth		: CLIP_DEPTH;
	float4 position		: SV_POSITION;
};

[RootSignature(POINT_SHADOW_RS)]
vs_output main(vs_input IN)
{
	float3 worldPosition = mul(transforms[IN.instanceID], float4(IN.position, 1.f)).xyz;
	
	float3 L = worldPosition - cb.lightPosition;

	L.z *= cb.flip;

	float l = length(L);
	L /= l;

	L.xy /= L.z + 1.f;

	vs_output OUT;
	OUT.clipDepth = L.z;
	OUT.position = float4(L.xy, l / cb.maxDistance, 1.f);
	return OUT;
}

```

`shaders/geometry/shadow_vs.hlsl`:

```hlsl
#include "depth_only_rs.hlsli"


struct light_vp
{
	float4x4 viewProj;
};

StructuredBuffer<float4x4> transforms	: register(t0);
ConstantBuffer<light_vp> vp				: register(b0);

struct vs_input
{
	float3 position		: POSITION;

	uint instanceID		: SV_InstanceID;
};

struct vs_output
{
	float4 position			: SV_POSITION;
};

[RootSignature(SHADOW_RS)]
vs_output main(vs_input IN)
{
	float4 worldPosition = mul(transforms[IN.instanceID], float4(IN.position, 1.f));

	vs_output OUT;
	OUT.position = mul(vp.viewProj, worldPosition);
	return OUT;
}

```

`shaders/grass/grass_create_draw_calls_cs.hlsl`:

```hlsl
#include "cs.hlsli"
#include "grass_rs.hlsli"

ConstantBuffer<grass_create_draw_calls_cb> cb	: register(b0);
StructuredBuffer<uint> counts					: register(t0);
RWStructuredBuffer<grass_draw> draws			: register(u0);


[RootSignature(GRASS_CREATE_DRAW_CALLS_RS)]
[numthreads(GRASS_CREATE_DRAW_CALLS_BLOCK_SIZE, 1, 1)]
void main(cs_input IN)
{
	uint id = IN.dispatchThreadID.x;
	draws[id].draw.InstanceCount = min(counts[id], cb.maxNumInstances);
}

```

`shaders/grass/grass_depth_only_vs.hlsl`:

```hlsl
#include "grass_rs.hlsli"
#include "depth_only_rs.hlsli"
#include "grass_vertex.hlsli"
#include "camera.hlsli"


ConstantBuffer<grass_cb> cb							: register(b0);
ConstantBuffer<depth_only_object_id_cb> id			: register(b1);

ConstantBuffer<camera_cb> camera					: register(b0, space1);

StructuredBuffer<grass_blade> blades				: register(t0);


struct vs_output
{
	float3 ndc						: NDC;
	float3 prevFrameNDC				: PREV_FRAME_NDC;

	nointerpolation uint objectID	: OBJECT_ID;

	float4 position					: SV_POSITION;
};

[RootSignature(GRASS_DEPTH_ONLY_RS)]
vs_output main(uint vertexID : SV_VertexID, uint instanceID : SV_InstanceID)
{
	grass_bend_settings bendSettings;
	bendSettings.relTipOffsetZ = 0.7f;
	bendSettings.controlPointZ = bendSettings.relTipOffsetZ * 0.5f;
	bendSettings.controlPointY = 0.8f;



	grass_blade blade = blades[instanceID];

	float2 uv = grassUV(blade, vertexID, cb.numVertices);
	float2 wind = cb.windDirection * blade.windStrength();
	float2 prevFrameWind = cb.windDirection * blade.prevFrameWindStrength();
	float3 position = grassPosition(blade, uv, blade.height, cb.halfWidth, bendSettings, wind);

	float3 prevFramePosition = position;
	prevFramePosition.xz += uv.y * (prevFrameWind - wind);

	vs_output OUT;
	OUT.position = mul(camera.viewProj, float4(position, 1.f));
	OUT.ndc = OUT.position.xyw;
	OUT.prevFrameNDC = mul(camera.prevFrameViewProj, float4(prevFramePosition, 1.f)).xyw;
	OUT.objectID = id.id;
	return OUT;
}

```

`shaders/grass/grass_generation_cs.hlsl`:

```hlsl
#include "cs.hlsli"
#include "grass_rs.hlsli"
#include "math.hlsli"
#include "random.hlsli"

ConstantBuffer<grass_generation_cb> cb				: register(b0);
ConstantBuffer<grass_generation_common_cb> common	: register(b1);

Texture2D<float> heightmap							: register(t0);
Texture2D<float2> normalmap							: register(t1);

RWStructuredBuffer<grass_blade> blades[2]			: register(u0);
RWStructuredBuffer<uint> count						: register(u2);

SamplerState clampSampler							: register(s0);

// Returns true, if object should be culled.
static bool cull(float3 minCorner, float3 maxCorner)
{
	for (uint32 i = 0; i < 6; ++i)
	{
		float4 plane = common.frustumPlanes[i];
		float4 vertex = float4(
			(plane.x < 0.f) ? minCorner.x : maxCorner.x,
			(plane.y < 0.f) ? minCorner.y : maxCorner.y,
			(plane.z < 0.f) ? minCorner.z : maxCorner.z,
			1.f
			);
		if (dot(plane, vertex) < 0.f)
		{
			return true;
		}
	}
	return false;
}

static const float cullCutoffsLOD0[2][2] =
{
	{ 2.f, 0.25f },
	{ 0.75f, 0.8f },
};

static const float cullCutoffsLOD1[2][2] =
{
	{ 1.f, 0.25f },
	{ 0.75f, 0.8f },
};

[RootSignature(GRASS_GENERATION_RS)]
[numthreads(GRASS_GENERATION_BLOCK_SIZE, GRASS_GENERATION_BLOCK_SIZE, 1)]
void main(cs_input IN)
{
	uint seed = initRand(IN.dispatchThreadID.x << cb.lodIndex, IN.dispatchThreadID.y << cb.lodIndex);

	float2 uv = ((IN.dispatchThreadID.xy << cb.lodIndex) + 0.5f) * common.uvScale;
	float uvOffsetX = (nextRand(seed) * 2.f - 1.f) * common.uvScale;
	float uvOffsetZ = (nextRand(seed) * 2.f - 1.f) * common.uvScale;
	uv += float2(uvOffsetX, uvOffsetZ);

	if (isSaturated(uv))
	{
		float height = heightmap.SampleLevel(clampSampler, uv, 0) * common.amplitudeScale;
		float2 n = normalmap.SampleLevel(clampSampler, uv, 0) * common.amplitudeScale;
		float3 normal = normalize(float3(n.x, 1.f, n.y));


		float2 xz = uv * common.chunkSize;

		float3 position = float3(xz.x, height, xz.y) + cb.chunkCorner;

		if (normal.y > 0.9f && !cull(position - float3(1.f, 0.f, 1.f), position + float3(1.f, 2.f, 1.f)))
		{
			float distance = length(position - common.cameraPosition);

			float cullStartDistance = (cb.lodIndex == 0) ? common.lodChangeStartDistance : common.cullStartDistance;
			float cullEndDistance = (cb.lodIndex == 0) ? common.lodChangeEndDistance : common.cullEndDistance;
			float cutoff = (cb.lodIndex == 0) 
				? cullCutoffsLOD0[IN.dispatchThreadID.x & 1][IN.dispatchThreadID.y & 1] 
				: cullCutoffsLOD1[IN.dispatchThreadID.x & 1][IN.dispatchThreadID.y & 1];

			float cullValue = smoothstep(cullStartDistance, cullEndDistance, distance);// -nextRand(seed) * 0.1f;

			bool cull = cullValue >= cutoff;
			float lod = (cb.lodIndex == 0) ? cullValue : 0.f;

			if (!cull)
			{
				uint lodIndex = cb.lodIndex;

				float height = common.baseHeight + fbm(position.xz * 2.f + 10000.f, 3).x * 0.8f;
				float windStrength = fbm(position.xz * 0.6f + common.time * 0.3f + 10000.f).x + 0.6f;
				float prevFrameWindStrength = fbm(position.xz * 0.6f + common.prevFrameTime * 0.3f + 10000.f).x + 0.6f;

				grass_blade blade;
				blade.initialize(
					position,
					random(xz) * M_PI * 2.f,
					0, // TODO: Type.
					lod,
					height,
					windStrength, prevFrameWindStrength);

				uint index;
				InterlockedAdd(count[lodIndex], 1, index);
				blades[lodIndex][index] = blade;
			}
		}
	}
}

```

`shaders/grass/grass_no_depth_prepass_ps.hlsl`:

```hlsl
#define NO_DEPTH_PREPASS
#include "grass_ps.hlsl"

```

`shaders/grass/grass_no_depth_prepass_vs.hlsl`:

```hlsl
#define NO_DEPTH_PREPASS
#include "grass_vs.hlsl"

```

`shaders/grass/grass_ps.hlsl`:

```hlsl
#include "grass_rs.hlsli"
#include "camera.hlsli"
#include "normal.hlsli"
#include "lighting.hlsli"
#include "depth_only_rs.hlsli"

ConstantBuffer<camera_cb> camera		: register(b1);
ConstantBuffer<lighting_cb> lighting	: register(b2);

TextureCube<float4> irradianceTexture			: register(t0, space2);
TextureCube<float4> prefilteredRadianceTexture	: register(t1, space2);

Texture2D<float2> brdf							: register(t2, space2);

Texture2D<float> shadowMap						: register(t3, space2);

Texture2D<float> aoTexture						: register(t4, space2);
Texture2D<float> sssTexture						: register(t5, space2);
Texture2D<float4> ssrTexture					: register(t6, space2);

SamplerState clampSampler						: register(s0);
SamplerComparisonState shadowSampler			: register(s1);


#ifdef NO_DEPTH_PREPASS
ConstantBuffer<depth_only_object_id_cb> id		: register(b3);
#endif


struct ps_input
{
	float2 uv				: TEXCOORDS;
	float3 normal			: NORMAL;
	float3 tangent			: TANGENT;
	float3 worldPosition	: POSITION;

#ifdef NO_DEPTH_PREPASS
	float3 ndc				: NDC;
	float3 prevFrameNDC		: PREV_FRAME_NDC;
#endif

	float4 screenPosition	: SV_POSITION;
	bool isFrontFace		: SV_IsFrontFace;
};


struct ps_output
{
	float4 hdrColor				: SV_Target0;
	float4 worldNormalRoughness	: SV_Target1;

#ifdef NO_DEPTH_PREPASS
	float2 screenVelocity		: SV_Target2;
	uint objectID				: SV_Target3;
#endif
};

[earlydepthstencil]
[RootSignature(GRASS_RS)]
ps_output main(ps_input IN)
{
	float3 N = IN.normal;
	float3 T = IN.tangent;
	if (!IN.isFrontFace)
	{
		N = -N;
	}
	N = normalize(N);
	N = normalize(N + T * IN.uv.x * 0.8);

	float3 camToP = IN.worldPosition - camera.position.xyz;
	float pixelDepth = dot(camera.forward.xyz, camToP);

#if 1
	N = lerp(N, float3(0.f, 1.f, 0.f), smoothstep(80.f, 100.f, pixelDepth) * 0.4f);
#endif

	surface_info surface;

	surface.albedo = float4(lerp(pow(float3(121, 208, 33) / 255, 2.2), pow(float3(193, 243, 118) / 255, 2.2), IN.uv.y), 1.f);
	surface.N = N;
	surface.roughness = 0.9f;
	surface.roughness = clamp(surface.roughness, 0.01f, 0.99f);
	surface.metallic = 0.f;
	surface.emission = 0.f;

	surface.P = IN.worldPosition;
	surface.V = -normalize(camToP);

	surface.inferRemainingProperties();


	float2 screenUV = IN.screenPosition.xy * camera.invScreenDims;

	light_contribution totalLighting = { float3(0.f, 0.f, 0.f), float3(0.f, 0.f, 0.f) };

	totalLighting.addSunLight(surface, lighting, screenUV, pixelDepth,
		shadowMap, shadowSampler, lighting.shadowMapTexelSize, sssTexture, clampSampler, 0.5f);

	totalLighting.addImageBasedAmbientLighting(surface, irradianceTexture, prefilteredRadianceTexture, brdf, ssrTexture, aoTexture,
		clampSampler, screenUV, lighting.globalIlluminationIntensity);





	surface.roughness = 1.f;

	ps_output OUT;
	OUT.hdrColor = totalLighting.evaluate(surface.albedo);
	OUT.worldNormalRoughness = float4(packNormal(surface.N), surface.roughness, 0.f);


#ifdef NO_DEPTH_PREPASS
	OUT.screenVelocity = screenSpaceVelocity(IN.ndc, IN.prevFrameNDC, camera.jitter, camera.prevFrameJitter);
	OUT.objectID = id.id;
#endif

	return OUT;

}


```

`shaders/grass/grass_vertex.hlsli`:

```hlsli
#ifndef GRASS_VERTEX_HLSLI
#define GRASS_VERTEX_HLSLI

#include "grass_rs.hlsli"
#include "random.hlsli"

#define DISABLE_FACING				0
#define DISABLE_BEND				0
#define DISABLE_WIND				0
#define DISABLE_ALL_GRASS_DYNAMICS  0


static float getRelY(uint vertexID, uint numVertices, uint lod)
{
	uint numLevels = numVertices >> 1 >> lod;

	uint vertical = vertexID >> 1 >> lod;
	return (float)vertical * (1.f / numLevels);
}

struct grass_bend_settings
{
	float relTipOffsetZ;
	float controlPointZ;
	float controlPointY;
};

static float2 grassUV(grass_blade blade, uint vertexID, uint numVertices)
{
	uint leftRight = vertexID & 1;
	float relX = (float)leftRight * 2.f - 1.f;
	relX *= (vertexID != numVertices - 1);

	float relY0 = getRelY(vertexID, numVertices, 0);
	float relY1 = getRelY(vertexID, numVertices, 1);

	float relY = lerp(relY0, relY1, blade.lod());

	float2 uv = float2(relX, relY);

	return uv;
}

static float3 grassPosition(grass_blade blade, float2 uv, float height, float halfWidth, grass_bend_settings bend, float2 wind)
{
	float relX = uv.x;
	float relY = uv.y;
	float relY2 = relY * relY;

	float2 zy = float2(bend.controlPointZ, bend.controlPointY) * (2.f * relY - 2.f * relY2) + float2(bend.relTipOffsetZ, 1.f) * relY2;
#if DISABLE_ALL_GRASS_DYNAMICS || DISABLE_BEND
	zy = float2(0.f, relY);
#endif

	zy *= height;

	float x = relX * halfWidth;
	float y = zy.y;
	float z = zy.x;

	float2 facing = blade.facing;
#if DISABLE_ALL_GRASS_DYNAMICS || DISABLE_FACING
	facing = float2(0.f, 1.f);
#endif
	float3 position = float3(
		facing.y * x - facing.x * z,
		y,
		facing.x * x + facing.y * z);


#if DISABLE_ALL_GRASS_DYNAMICS || DISABLE_WIND
	wind = float2(0.f, 0.f);
#endif
	position.xz += wind * relY;
	position += blade.position;

	return position;
}

static float3 grassNormal(grass_blade blade, float2 uv, float height, grass_bend_settings bend, float2 wind)
{
	float relY = uv.y;

	float2 d_zy = float2(bend.controlPointZ, bend.controlPointY) * (2.f - 4.f * relY) + float2(bend.relTipOffsetZ, 1.f) * (2.f * relY);
#if DISABLE_ALL_GRASS_DYNAMICS || DISABLE_BEND
	d_zy = float2(0.f, 1.f);
#endif

	d_zy *= height;


	float2 facing = blade.facing;
#if DISABLE_ALL_GRASS_DYNAMICS || DISABLE_FACING
	facing = float2(0.f, 1.f);
#endif

	float z = d_zy.x;
	float y = d_zy.y;

	float d_x = height * (-facing.x * z);
	float d_y = height * y;
	float d_z = height * (facing.y * z);

#if DISABLE_ALL_GRASS_DYNAMICS || DISABLE_WIND
	wind = float2(0.f, 0.f);
#endif

	d_x += wind.x;
	d_z += wind.y;

	float3 tangent = float3(facing.y, 0.f, facing.x);
	float3 normal = cross(tangent, float3(d_x, d_y, d_z));

	return normal;
}

#endif


```

`shaders/grass/grass_vs.hlsl`:

```hlsl
#include "grass_rs.hlsli"
#include "camera.hlsli"
#include "grass_vertex.hlsli"

ConstantBuffer<grass_cb> cb				: register(b0);
ConstantBuffer<camera_cb> camera		: register(b1);
StructuredBuffer<grass_blade> blades	: register(t0);

struct vs_output
{
	float2 uv				: TEXCOORDS;
	float3 normal			: NORMAL;
	float3 tangent			: TANGENT;
	float3 worldPosition	: POSITION;

#ifdef NO_DEPTH_PREPASS
	float3 ndc				: NDC;
	float3 prevFrameNDC		: PREV_FRAME_NDC;
#endif

	float4 position : SV_POSITION;
};

vs_output main(uint vertexID : SV_VertexID, uint instanceID : SV_InstanceID)
{
	grass_bend_settings bendSettings;
	bendSettings.relTipOffsetZ = 0.7f;
	bendSettings.controlPointZ = bendSettings.relTipOffsetZ * 0.5f;
	bendSettings.controlPointY = 0.8f;



	grass_blade blade = blades[instanceID];

	float2 uv = grassUV(blade, vertexID, cb.numVertices);
	float2 wind = cb.windDirection * blade.windStrength();
	float3 position = grassPosition(blade, uv, blade.height, cb.halfWidth, bendSettings, wind);
	float3 normal = grassNormal(blade, uv, blade.height, bendSettings, wind);



	vs_output OUT;
	OUT.uv = uv;
	OUT.normal = normal;
	OUT.tangent = float3(blade.facing.y, 0.f, blade.facing.x);
	OUT.worldPosition = position;
	OUT.position = mul(camera.viewProj, float4(position, 1.f));

#ifdef NO_DEPTH_PREPASS
	float2 prevFrameWind = cb.windDirection * blade.prevFrameWindStrength();
	float3 prevFramePosition = position;
	prevFramePosition.xz += uv.y * (prevFrameWind - wind);

	OUT.ndc = OUT.position.xyw;
	OUT.prevFrameNDC = mul(camera.prevFrameViewProj, float4(prevFramePosition, 1.f)).xyw;
#endif

	return OUT;
}

```

`shaders/light_culling/light_culling_cs.hlsl`:

```hlsl
#include "cs.hlsli"
#include "camera.hlsli"
#include "light_culling_rs.hlsli"
#include "light_source.hlsli"
#include "material.hlsli"

/*
    This shader culls lights and decals against screen space tiles.
    The emitted indices are handled differently for lights and decals.

    - For lights we simply write a dense list of indices per tile.
    - For decals we output a bit mask, where a 1 means that this decal influences this surface point. This limits the total number of decals per frame, but this way we don't need
      a sorting step, to properly draw the decals.
*/


ConstantBuffer<camera_cb> camera	                : register(b0);
ConstantBuffer<light_culling_cb> cb	                : register(b1);

Texture2D<float> depthBuffer                        : register(t0);
StructuredBuffer<light_culling_view_frustum> frusta : register(t1);

StructuredBuffer<point_light_cb> pointLights        : register(t2);
StructuredBuffer<spot_light_cb> spotLights          : register(t3);
StructuredBuffer<pbr_decal_cb> decals               : register(t4);

RWTexture2D<uint4> tiledCullingGrid                 : register(u0);
RWStructuredBuffer<uint> tiledCullingIndexCounter   : register(u1);

RWStructuredBuffer<uint> tiledObjectsIndexList      : register(u2);


groupshared uint groupMinDepth;
groupshared uint groupMaxDepth;
groupshared light_culling_view_frustum groupFrustum;

groupshared float3 groupViewSpaceAABBCorners[8];
groupshared float3 groupViewSpaceAABBCenter;
groupshared float3 groupViewSpaceAABBExtent;

groupshared uint groupTileDepthMask;

groupshared uint groupObjectsStartOffset;

// Opaque.
groupshared uint groupObjectsListOpaque[MAX_NUM_INDICES_PER_TILE];
groupshared uint groupLightCountOpaque;

// Transparent.
groupshared uint groupObjectsListTransparent[MAX_NUM_INDICES_PER_TILE];
groupshared uint groupLightCountTransparent;




struct spot_light_bounding_volume
{
    float3 tip;
    float height;
    float3 direction;
    float radius;
};

static spot_light_bounding_volume getSpotLightBoundingVolume(spot_light_cb sl)
{
    spot_light_bounding_volume result;
    result.tip = sl.position;
    result.direction = sl.direction;
    result.height = sl.maxDistance;

    float oc = sl.getOuterCutoff();
    result.radius = result.height * sqrt(1.f - oc * oc) / oc; // Same as height * tan(acos(oc)).
    return result;
}

static bool pointLightOutsidePlane(point_light_cb pl, light_culling_frustum_plane plane)
{
    return dot(plane.N, pl.position) - plane.d < -pl.radius;
}

static bool pointLightInsideFrustum(point_light_cb pl, light_culling_view_frustum frustum, light_culling_frustum_plane nearPlane, light_culling_frustum_plane farPlane)
{
    bool result = true;

    if (pointLightOutsidePlane(pl, nearPlane)
        || pointLightOutsidePlane(pl, farPlane))
    {
        result = false;
    }

    for (int i = 0; i < 4 && result; ++i)
    {
        if (pointLightOutsidePlane(pl, frustum.planes[i]))
        {
            result = false;
        }
    }

    return result;
}

static bool sphereInAABB(vec3 sphereCenter, float sphereRadius, float3 aabbCenter, float3 aabbExtents)
{
    float3 delta = max(0, abs(aabbCenter - sphereCenter) - aabbExtents);
    float distSq = dot(delta, delta);

    return distSq <= sphereRadius * sphereRadius;
}

static bool pointOutsidePlane(float3 p, light_culling_frustum_plane plane)
{
    return dot(plane.N, p) - plane.d < 0;
}

static bool spotLightOutsidePlane(spot_light_bounding_volume sl, light_culling_frustum_plane plane)
{
    float3 m = normalize(cross(cross(plane.N, sl.direction), sl.direction));
    float3 Q = sl.tip + sl.direction * sl.height - m * sl.radius;
    return pointOutsidePlane(sl.tip, plane) && pointOutsidePlane(Q, plane);
}

static bool spotLightInsideFrustum(spot_light_bounding_volume sl, light_culling_view_frustum frustum, light_culling_frustum_plane nearPlane, light_culling_frustum_plane farPlane)
{
    bool result = true;

    if (spotLightOutsidePlane(sl, nearPlane)
        || spotLightOutsidePlane(sl, farPlane))
    {
        result = false;
    }

    for (int i = 0; i < 4 && result; ++i)
    {
        if (spotLightOutsidePlane(sl, frustum.planes[i]))
        {
            result = false;
        }
    }

    return result;
}

static bool decalOutsidePlane(pbr_decal_cb decal, light_culling_frustum_plane plane)
{
    float x = dot(decal.right, plane.N)     >= 0.f ? 1.f : -1.f;
    float y = dot(decal.up, plane.N)        >= 0.f ? 1.f : -1.f;
    float z = dot(decal.forward, plane.N)   >= 0.f ? 1.f : -1.f;

    float3 diag = x * decal.right + y * decal.up + z * decal.forward;

    float3 nPoint = decal.position + diag;
    return pointOutsidePlane(nPoint, plane);
}

static bool decalInsideFrustum(pbr_decal_cb decal, light_culling_view_frustum frustum, light_culling_frustum_plane nearPlane, light_culling_frustum_plane farPlane)
{
    bool result = true;

    if (decalOutsidePlane(decal, nearPlane)
        || decalOutsidePlane(decal, farPlane))
    {
        result = false;
    }

    for (int i = 0; i < 4 && result; ++i)
    {		
        if (decalOutsidePlane(decal, frustum.planes[i]))
        {
            result = false;
        }
    }	
        
    return result;
}

static uint getLightMask(float sphereCenterDepth, float radius, float depthRangeRecip, float nearZ)
{
    // https://wickedengine.net/2018/01/10/optimizing-tile-based-light-culling/

    const float plMin = sphereCenterDepth - radius;
    const float plMax = sphereCenterDepth + radius;
    const uint plMaskIndexMin = max(0, min(31, floor((plMin - nearZ) * depthRangeRecip)));
    const uint plMaskIndexMax = max(0, min(31, floor((plMax - nearZ) * depthRangeRecip)));

    // Set all bits between plMaskIndexMin and (inclusive) plMaskIndexMax.
    uint lightMask = 0xFFFFFFFF;
    lightMask >>= 31 - (plMaskIndexMax - plMaskIndexMin);
    lightMask <<= plMaskIndexMin;
    return lightMask;
}



#define groupAppendLight(type, index)                               \
    {                                                               \
        uint v;                                                     \
        InterlockedAdd(groupLightCount##type, 1, v);                \
        if (v < MAX_NUM_LIGHTS_PER_TILE)                            \
        {                                                           \
            groupObjectsList##type[TILE_LIGHT_OFFSET + v] = index;  \
        }                                                           \
    }

// We flip the index, such that the first set bit corresponds to the front-most decal. We render the decals front to back, such that we can early exit when alpha >= 1.
#define groupAppendDecal(type, index)                               \
    {                                                               \
        const uint v = MAX_NUM_TOTAL_DECALS - index - 1;            \
        const uint bucket = v >> 5u;                                \
        const uint bit = v & ((1u << 5u) - 1);                      \
        InterlockedOr(groupObjectsList##type[bucket], 1u << bit);   \
    }

#define groupAppendLightOpaque(index) groupAppendLight(Opaque, index)
#define groupAppendLightTransparent(index) groupAppendLight(Transparent, index)
#define groupAppendDecalOpaque(index) groupAppendDecal(Opaque, index)
#define groupAppendDecalTransparent(index) groupAppendDecal(Transparent, index)


[RootSignature(LIGHT_CULLING_RS)]
[numthreads(LIGHT_CULLING_TILE_SIZE, LIGHT_CULLING_TILE_SIZE, 1)]
void main(cs_input IN)
{
    uint i;

    // Initialize.
    if (IN.groupIndex == 0)
    {
        groupMinDepth = asuint(0.9999999f);
        groupMaxDepth = 0;

        groupLightCountOpaque = 0;
        groupLightCountTransparent = 0;

        groupTileDepthMask = 0;

        groupFrustum = frusta[IN.groupID.y * cb.numThreadGroupsX + IN.groupID.x];
    }

    // Initialize decal masks to zero.
    for (i = IN.groupIndex; i < NUM_DECAL_BUCKETS; i += LIGHT_CULLING_TILE_SIZE * LIGHT_CULLING_TILE_SIZE)
    {
        groupObjectsListOpaque[i] = 0;
    }
    for (i = IN.groupIndex; i < NUM_DECAL_BUCKETS; i += LIGHT_CULLING_TILE_SIZE * LIGHT_CULLING_TILE_SIZE)
    {
        groupObjectsListTransparent[i] = 0;
    }


    GroupMemoryBarrierWithGroupSync();




    // Determine minimum and maximum depth.
    uint2 screenSize;
    depthBuffer.GetDimensions(screenSize.x, screenSize.y);

    const float fDepth = depthBuffer[min(IN.dispatchThreadID.xy, screenSize - 1)];
    // Since the depth is between 0 and 1, we can perform min and max operations on the bit pattern as uint. This is because native HLSL does not support floating point atomics.
    if (fDepth != 1.f)
    {
        const uint uDepth = asuint(fDepth);

        InterlockedMin(groupMinDepth, uDepth);
        InterlockedMax(groupMaxDepth, uDepth);
    }
    GroupMemoryBarrierWithGroupSync();

    const float minDepth = asfloat(groupMinDepth);
    const float maxDepth = asfloat(groupMaxDepth);

    const float3 forward = camera.forward.xyz;
    const float3 cameraPos = camera.position.xyz;

    const float nearZ = camera.depthBufferDepthToEyeDepth(minDepth); // Positive.
    const float farZ  = camera.depthBufferDepthToEyeDepth(maxDepth); // Positive.
    const float myZ   = camera.depthBufferDepthToEyeDepth(fDepth);   // Positive.

    const float depthRangeRecip = 31.f / (farZ - nearZ);
    const uint depthMaskIndex = max(0, min(31, floor((myZ - nearZ) * depthRangeRecip)));
    InterlockedOr(groupTileDepthMask, 1u << depthMaskIndex);


    const light_culling_frustum_plane cameraNearPlane = {  forward,  dot(forward, cameraPos + camera.projectionParams.x * forward) };
    const light_culling_frustum_plane nearPlane       = {  forward,  dot(forward, cameraPos + nearZ * forward) };
    const light_culling_frustum_plane farPlane        = { -forward, -dot(forward, cameraPos + farZ  * forward) };


    if (IN.groupIndex < 8)
    {
        const uint x = IN.groupIndex & 0x1;
        const uint y = (IN.groupIndex >> 1) & 0x1;
        const uint z = (IN.groupIndex >> 2);

        const uint2 coord = (IN.groupID.xy + uint2(x, y)) * LIGHT_CULLING_TILE_SIZE;
        const float2 uv = (float2(coord) + 0.5f) / screenSize;

        groupViewSpaceAABBCorners[IN.groupIndex] = camera.restoreViewSpacePosition(uv, lerp(minDepth, maxDepth, z));
    }

    GroupMemoryBarrierWithGroupSync();

    if (IN.groupIndex == 0)
    {
        float3 minAABB = 10000000;
        float3 maxAABB = -10000000;

        for (uint i = 0; i < 8; ++i)
        {
            minAABB = min(minAABB, groupViewSpaceAABBCorners[i]);
            maxAABB = max(maxAABB, groupViewSpaceAABBCorners[i]);
        }

        groupViewSpaceAABBCenter = (maxAABB + minAABB) * 0.5f;
        groupViewSpaceAABBExtent = maxAABB - groupViewSpaceAABBCenter;
    }

    GroupMemoryBarrierWithGroupSync();

    // Decals.
    const uint numDecals = cb.numDecals;
    for (i = IN.groupIndex; i < numDecals; i += LIGHT_CULLING_TILE_SIZE * LIGHT_CULLING_TILE_SIZE)
    {
        pbr_decal_cb d = decals[i];
        if (decalInsideFrustum(d, groupFrustum, cameraNearPlane, farPlane))
        {
            groupAppendDecalTransparent(i);

            if (!decalOutsidePlane(d, nearPlane))
            {
                groupAppendDecalOpaque(i);
            }
        }
    }


    // Point lights.
    const uint numPointLights = cb.numPointLights;
    for (i = IN.groupIndex; i < numPointLights; i += LIGHT_CULLING_TILE_SIZE * LIGHT_CULLING_TILE_SIZE)
    {
        point_light_cb pl = pointLights[i];
        if (pointLightInsideFrustum(pl, groupFrustum, cameraNearPlane, farPlane))
        {
            groupAppendLightTransparent(i);

            pl.position = mul(camera.view, float4(pl.position, 1.f)).xyz;

            if (sphereInAABB(pl.position, pl.radius, groupViewSpaceAABBCenter, groupViewSpaceAABBExtent))
            {
                const uint lightMask = getLightMask(-pl.position.z, pl.radius, depthRangeRecip, nearZ);

                if (lightMask & groupTileDepthMask)
                {
                    groupAppendLightOpaque(i);
                }
            }
        }
    }

    GroupMemoryBarrierWithGroupSync();
    const uint numTilePointLightsOpaque = groupLightCountOpaque;
    const uint numTilePointLightsTransparent = groupLightCountTransparent;


    // Spot lights.
    const uint numSpotLights = cb.numSpotLights;
    for (i = IN.groupIndex; i < numSpotLights; i += LIGHT_CULLING_TILE_SIZE * LIGHT_CULLING_TILE_SIZE)
    {
        const spot_light_cb sl = spotLights[i];
        const spot_light_bounding_volume slBV = getSpotLightBoundingVolume(sl);
        if (spotLightInsideFrustum(slBV, groupFrustum, cameraNearPlane, farPlane))
        {
            groupAppendLightTransparent(i);

            const float oc = sl.getOuterCutoff();
            const float radius = sl.maxDistance * 0.5f / (oc * oc);
            const float3 center = mul(camera.view, float4(sl.position + sl.direction * radius, 1.f)).xyz;

            if (sphereInAABB(center, radius, groupViewSpaceAABBCenter, groupViewSpaceAABBExtent))
            {
                const uint lightMask = getLightMask(-center.z, radius, depthRangeRecip, nearZ);

                if (lightMask & groupTileDepthMask)
                {
                    groupAppendLightOpaque(i);
                }
            }
        }
    }

    GroupMemoryBarrierWithGroupSync();
    const uint numTileSpotLightsOpaque = groupLightCountOpaque - numTilePointLightsOpaque;
    const uint numTileSpotLightsTransparent = groupLightCountTransparent - numTilePointLightsTransparent;


    const uint totalIndexCountOpaque = groupLightCountOpaque + NUM_DECAL_BUCKETS;
    const uint totalIndexCountTransparent = groupLightCountTransparent + NUM_DECAL_BUCKETS;
    const uint totalIndexCount = totalIndexCountOpaque + totalIndexCountTransparent;
    if (IN.groupIndex == 0)
    {
        InterlockedAdd(tiledCullingIndexCounter[0], totalIndexCount, groupObjectsStartOffset);

        tiledCullingGrid[IN.groupID.xy] = uint4(
            groupObjectsStartOffset,
            (numTilePointLightsOpaque << 20) | (numTileSpotLightsOpaque << 10),
            groupObjectsStartOffset + totalIndexCountOpaque, // Transparent objects are directly after opaques.
            (numTilePointLightsTransparent << 20) | (numTileSpotLightsTransparent << 10)
        );
    }

    GroupMemoryBarrierWithGroupSync();

    const uint offsetOpaque = groupObjectsStartOffset + 0;
    for (i = IN.groupIndex; i < totalIndexCountOpaque; i += LIGHT_CULLING_TILE_SIZE * LIGHT_CULLING_TILE_SIZE)
    {
        tiledObjectsIndexList[offsetOpaque + i] = groupObjectsListOpaque[i];
    }

    const uint offsetTransparent = groupObjectsStartOffset + totalIndexCountOpaque;
    for (i = IN.groupIndex; i < totalIndexCountTransparent; i += LIGHT_CULLING_TILE_SIZE * LIGHT_CULLING_TILE_SIZE)
    {
        tiledObjectsIndexList[offsetTransparent + i] = groupObjectsListTransparent[i];
    }
}

```

`shaders/light_culling/world_space_tiled_frusta_cs.hlsl`:

```hlsl
#include "cs.hlsli"
#include "camera.hlsli"
#include "light_culling_rs.hlsli"

#define BLOCK_SIZE 16

ConstantBuffer<camera_cb> camera	: register(b0);
ConstantBuffer<frusta_cb> cb	    : register(b1);
RWStructuredBuffer<light_culling_view_frustum> outFrusta  : register(u0);


static light_culling_frustum_plane getPlane(float3 p0, float3 p1, float3 p2)
{
    // The plane normal points to the inside of the frustum.

    light_culling_frustum_plane plane;

    float3 v0 = p1 - p0;
    float3 v2 = p2 - p0;

    plane.N = normalize(cross(v0, v2));
    plane.d = dot(plane.N, p0);

    return plane;
}

[RootSignature(WORLD_SPACE_TILED_FRUSTA_RS)]
[numthreads(BLOCK_SIZE, BLOCK_SIZE, 1)]
void main(cs_input IN)
{
    float2 invScreenDims = camera.invScreenDims;

    float2 screenTL = invScreenDims * (IN.dispatchThreadID.xy * LIGHT_CULLING_TILE_SIZE);
    float2 screenTR = invScreenDims * (float2(IN.dispatchThreadID.x + 1, IN.dispatchThreadID.y) * LIGHT_CULLING_TILE_SIZE);
    float2 screenBL = invScreenDims * (float2(IN.dispatchThreadID.x, IN.dispatchThreadID.y + 1) * LIGHT_CULLING_TILE_SIZE);
    float2 screenBR = invScreenDims * (float2(IN.dispatchThreadID.x + 1, IN.dispatchThreadID.y + 1) * LIGHT_CULLING_TILE_SIZE);

    // Points on near plane.
    float3 tl = camera.restoreWorldSpacePosition(screenTL, 0.f);
    float3 tr = camera.restoreWorldSpacePosition(screenTR, 0.f);
    float3 bl = camera.restoreWorldSpacePosition(screenBL, 0.f);
    float3 br = camera.restoreWorldSpacePosition(screenBR, 0.f);

    float3 cameraPos = camera.position.xyz;
    light_culling_view_frustum frustum;
    frustum.planes[0] = getPlane(cameraPos, bl, tl);
    frustum.planes[1] = getPlane(cameraPos, tr, br);
    frustum.planes[2] = getPlane(cameraPos, tl, tr);
    frustum.planes[3] = getPlane(cameraPos, br, bl);

    if (IN.dispatchThreadID.x < cb.numThreadsX && IN.dispatchThreadID.y < cb.numThreadsY)
    {
        uint index = IN.dispatchThreadID.y * cb.numThreadsX + IN.dispatchThreadID.x;
        outFrusta[index] = frustum;
    }
}

```

`shaders/light_probe/light_probe_grid_visualization_ps.hlsl`:

```hlsl
#include "light_probe_rs.hlsli"

struct ps_input
{
	float2 uvOffset			: UV_OFFSET;
	float2 uvScale			: UV_SCALE;
	float3 normal			: NORMAL;
};

Texture2D<float3> irradiance	: register(t0);
SamplerState linearSampler		: register(s0);



[RootSignature(LIGHT_PROBE_GRID_VISUALIZATION_RS)]
float4 main(ps_input IN) : SV_TARGET
{
	const float octScale = (float)LIGHT_PROBE_RESOLUTION / (float)LIGHT_PROBE_TOTAL_RESOLUTION;

	float2 oct = encodeOctahedral(normalize(IN.normal));
	oct *= octScale;
	float2 uv = (IN.uvOffset + oct * 0.5f + 0.5f) * IN.uvScale;

	return float4(irradiance.Sample(linearSampler, uv), 1.f);
}

```

`shaders/light_probe/light_probe_grid_visualization_vs.hlsl`:

```hlsl
#include "light_probe_rs.hlsli"

ConstantBuffer<light_probe_grid_visualization_cb> cb : register(b0);

struct vs_input
{
	float3 position		: POSITION;
	uint instanceID		: SV_InstanceID;
};

struct vs_output
{
	float2 uvOffset			: UV_OFFSET;
	float2 uvScale			: UV_SCALE;
	float3 normal			: NORMAL;
	float4 position			: SV_POSITION;
};

vs_output main(vs_input IN)
{
	float3 index = linearIndexTo3DIndex(IN.instanceID, cb.countX, cb.countY);

	float radius = 0.1f;

	vs_output OUT;
	OUT.normal = IN.position;
	OUT.position = mul(cb.mvp, float4(IN.position * radius + index * cb.cellSize, 1.f));
	OUT.uvOffset = float2(index.y * cb.countX + index.x, index.z);
	OUT.uvScale = cb.uvScale;
	return OUT;
}

```

`shaders/light_probe/light_probe_ray_visualization_ps.hlsl`:

```hlsl
#include "light_probe_rs.hlsli"

struct ps_input
{
	float3 color : COLOR;
	float distance : DISTANCE;
};


[RootSignature(LIGHT_PROBE_RAY_VISUALIZATION_RS)]
float4 main(ps_input IN) : SV_TARGET
{
	return float4(IN.color, 1.f);
	//return (IN.distance < 100.f) ? float4(0.f, 1.f, 0.f, 1.f) : float4(1.f, 0.f, 0.f, 1.f);
}

```

`shaders/light_probe/light_probe_ray_visualization_vs.hlsl`:

```hlsl
#include "light_probe_rs.hlsli"

ConstantBuffer<light_probe_ray_visualization_cb> cb : register(b0);
Texture2D<float3> radiance							: register(t0);
Texture2D<float4> directionAndDistance				: register(t1);

struct vs_input
{
	uint vertexID		: SV_VertexID;
	uint instanceID		: SV_InstanceID;
};

struct vs_output
{
	float3 color			: COLOR;
	float distance			: DISTANCE;
	float4 position			: SV_POSITION;
};

vs_output main(vs_input IN)
{
	uint probeID = IN.instanceID / NUM_RAYS_PER_PROBE;
	uint rayID = IN.instanceID % NUM_RAYS_PER_PROBE;

	uint2 c = uint2(rayID, probeID);

	float4 dirDist = directionAndDistance[c];

	float3 index = linearIndexTo3DIndex(probeID, cb.countX, cb.countY);
	float3 position = index * cb.cellSize;

	if (IN.vertexID == 1)
	{
		position += dirDist.xyz * dirDist.w;
	}

	vs_output OUT;
	OUT.position = mul(cb.mvp, float4(position, 1.f));
	OUT.color = radiance[c];
	OUT.distance = dirDist.w;
	return OUT;
}

```

`shaders/light_probe/light_probe_test_sample_ps.hlsl`:

```hlsl
#include "light_probe_rs.hlsli"

ConstantBuffer<light_probe_grid_cb> grid	: register(b1);

struct ps_input
{
	float3 worldPosition	: POSITION;
	float3 worldNormal		: NORMAL;
};

Texture2D<float3> irradiance		: register(t0);
Texture2D<float2> depth				: register(t1);
SamplerState linearSampler			: register(s0);


[RootSignature(LIGHT_PROBE_TEST_SAMPLE_RS)]
float4 main(ps_input IN) : SV_TARGET
{
	float3 N = normalize(IN.worldNormal);
	float3 irr = grid.sampleIrradianceAtPosition(IN.worldPosition, N, irradiance, depth, linearSampler);

	return float4(irr, 1.f);
}

```

`shaders/light_probe/light_probe_test_sample_vs.hlsl`:

```hlsl
#include "transform.hlsli"

ConstantBuffer<transform_cb> transform	: register(b0);

struct vs_input
{
	float3 position		: POSITION;
};

struct vs_output
{
	float3 worldPosition	: POSITION;
	float3 worldNormal		: NORMAL;
	float4 position			: SV_POSITION;
};

vs_output main(vs_input IN)
{
	vs_output OUT;
	OUT.worldPosition = mul(transform.m, float4(IN.position, 1.f));
	OUT.worldNormal = mul(transform.m, float4(IN.position, 0.f));
	OUT.position = mul(transform.mvp, float4(IN.position, 1.f));
	return OUT;
}

```

`shaders/light_probe/light_probe_trace_rts.hlsl`:

```hlsl
#include "../common/camera.hlsli"
#include "../common/material.hlsli"
#include "../common/random.hlsli"
#include "../common/lighting.hlsli"
#include "../common/raytracing.hlsli"
#include "../common/procedural_sky.hlsli"
#include "../rs/light_probe_rs.hlsli"

// Raytracing intrinsics: https://microsoft.github.io/DirectX-Specs/d3d/Raytracing.html#ray-system-values
// Ray flags: https://microsoft.github.io/DirectX-Specs/d3d/Raytracing.html#ray-flags

struct mesh_vertex
{
	float2 uv;
	float3 normal;
	float3 tangent;
};


// Global.
RaytracingAccelerationStructure rtScene		: register(t0);
TextureCube<float4> sky						: register(t1);

Texture2D<float3> irradiance				: register(t2);
Texture2D<float2> depth						: register(t3);

RWTexture2D<float3> radianceOutput			: register(u0);
RWTexture2D<float4> directionDepthOutput	: register(u1);

ConstantBuffer<light_probe_trace_cb> cb		: register(b0);
ConstantBuffer<directional_light_cb> sun	: register(b1);

SamplerState linearSampler					: register(s0);


// Radiance hit group.
ConstantBuffer<pbr_material_cb> material	: register(b0, space1);
StructuredBuffer<mesh_vertex> meshVertices	: register(t0, space1);
ByteAddressBuffer meshIndices				: register(t1, space1);
Texture2D<float4> albedoTex					: register(t2, space1);
Texture2D<float3> normalTex					: register(t3, space1);
Texture2D<float> roughTex					: register(t4, space1);
Texture2D<float> metalTex					: register(t5, space1);


struct radiance_ray_payload
{
	float3 color;
	float distance;
};

struct shadow_ray_payload
{
	float visible;
};


static float4 traceRadianceRay(float3 origin, float3 direction)
{
	RayDesc ray;
	ray.Origin = origin;
	ray.Direction = direction;
	ray.TMin = 0.01f;
	ray.TMax = 10000.f;

	radiance_ray_payload payload = { float3(0.f, 0.f, 0.f), 10000.f };

	TraceRay(rtScene,
		RAY_FLAG_CULL_BACK_FACING_TRIANGLES,
		0xFF,				// Cull mask.
		RADIANCE,			// Addend on the hit index.
		NUM_RAY_TYPES,		// Multiplier on the geometry index within a BLAS.
		RADIANCE,			// Miss index.
		ray,
		payload);

	return float4(payload.color, payload.distance);
}

static float traceShadowRay(float3 origin, float3 direction, float distance)
{
#ifdef SHADOW
	RayDesc ray;
	ray.Origin = origin;
	ray.Direction = direction;
	ray.TMin = 0.01f;
	ray.TMax = distance;

	shadow_ray_payload payload = { 0.f };

	TraceRay(rtScene,
		RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER, // No need to invoke closest hit shader.
		0xFF,				// Cull mask.
		SHADOW,				// Addend on the hit index.
		NUM_RAY_TYPES,		// Multiplier on the geometry index within a BLAS.
		SHADOW,				// Miss index.
		ray,
		payload);

	return payload.visible;
#else
	return 1.f;
#endif
}





// ----------------------------------------
// RAY GENERATION
// ----------------------------------------


[shader("raygeneration")]
void rayGen()
{
	uint3 launchIndex = DispatchRaysIndex();
	uint3 launchDim = DispatchRaysDimensions();

	uint rayID = launchIndex.x;
	uint probeID = launchIndex.y;

	float3 origin = cb.grid.linearIndexToPosition(probeID);
	float3 direction = sphericalFibonacci(rayID, NUM_RAYS_PER_PROBE);

	direction = mul(cb.rayRotation, float4(direction, 0.f)).xyz;

	float4 radianceAndDistance = traceRadianceRay(origin, direction);
	radianceOutput[launchIndex.xy] = radianceAndDistance.xyz;
	directionDepthOutput[launchIndex.xy] = float4(direction, radianceAndDistance.w);
}



// ----------------------------------------
// RADIANCE
// ----------------------------------------

[shader("closesthit")]
void radianceClosestHit(inout radiance_ray_payload payload, in BuiltInTriangleIntersectionAttributes attribs)
{
	uint flags = material.getFlags();

	uint3 tri = (flags & MATERIAL_USE_32_BIT_INDICES) ? load3x32BitIndices(meshIndices) : load3x16BitIndices(meshIndices);

	// Interpolate vertex attributes over triangle.
	float2 uvs[] = { meshVertices[tri.x].uv, meshVertices[tri.y].uv, meshVertices[tri.z].uv };
	float3 normals[] = { meshVertices[tri.x].normal, meshVertices[tri.y].normal, meshVertices[tri.z].normal };

	float2 uv = interpolateAttribute(uvs, attribs);

	surface_info surface;
	surface.N = normalize(transformDirectionToWorld(interpolateAttribute(normals, attribs))); // We ignore normal maps.
	surface.V = -WorldRayDirection();
	surface.P = hitWorldPosition();

	uint mipLevel = 3;

	surface.albedo = (((flags & MATERIAL_USE_ALBEDO_TEXTURE)
		? albedoTex.SampleLevel(linearSampler, uv, mipLevel)
		: float4(1.f, 1.f, 1.f, 1.f))
		* unpackColor(material.albedoTint));

	surface.roughness = (flags & MATERIAL_USE_ROUGHNESS_TEXTURE)
		? roughTex.SampleLevel(linearSampler, uv, mipLevel)
		: material.getRoughnessOverride();

	surface.metallic = (flags & MATERIAL_USE_METALLIC_TEXTURE)
		? metalTex.SampleLevel(linearSampler, uv, mipLevel)
		: material.getMetallicOverride();

	surface.emission = material.emission;
	surface.roughness = clamp(surface.roughness, 0.01f, 0.99f);

	surface.inferRemainingProperties();



	float3 L = -sun.direction;
	float sunVisibility = traceShadowRay(surface.P, L, 10000.f);

	light_info light;
	light.initialize(surface, L, sun.radiance);

	light_contribution totalLighting = { float3(0.f, 0.f, 0.f), float3(0.f, 0.f, 0.f) };
	totalLighting.add(calculateDirectLighting(surface, light), sunVisibility);

	totalLighting.diffuse += cb.grid.sampleIrradianceAtPosition(surface.P, surface.N, irradiance, depth, linearSampler);

	payload.color = totalLighting.evaluate(surface.albedo).rgb + surface.emission;
	payload.distance = RayTCurrent();
}

[shader("miss")]
void radianceMiss(inout radiance_ray_payload payload)
{
	if (cb.sampleSkyFromTexture == 1)
	{
		payload.color = sky.SampleLevel(linearSampler, WorldRayDirection(), 8).xyz; // We sample a very high mip level of the sky here, because a small sun makes the samples very noisy.
	}
	else
	{
		payload.color = proceduralSkySimple(normalize(WorldRayDirection()), normalize(-sun.direction));
	}
}





// ----------------------------------------
// SHADOW
// ----------------------------------------

[shader("miss")]
void shadowMiss(inout shadow_ray_payload payload)
{
	payload.visible = 1.f;
}



```

`shaders/light_probe/light_probe_update_depth_cs.hlsl`:

```hlsl
#include "light_probe_rs.hlsli"
#include "cs.hlsli"

ConstantBuffer<light_probe_update_cb> cb	: register(b0);
Texture2D<float3> radiance					: register(t0);
Texture2D<float4> directionAndDistance		: register(t1);

RWTexture2D<float2> output					: register(u0);


[numthreads(LIGHT_PROBE_BLOCK_SIZE, LIGHT_PROBE_BLOCK_SIZE, 1)]
[RootSignature(LIGHT_PROBE_UPDATE_RS)]
void main(cs_input IN)
{
	uint2 coord = IN.dispatchThreadID.xy;

	uint2 probeIndex2 = coord / LIGHT_PROBE_TOTAL_DEPTH_RESOLUTION;
	uint3 probeIndex3 = uint3(probeIndex2.x % cb.countX, probeIndex2.x / cb.countX, probeIndex2.y);

	uint probeIndex = probeIndex3.z * cb.countX * cb.countY + probeIndex3.y * cb.countX + probeIndex3.x;

	uint2 pixelIndex = coord % LIGHT_PROBE_TOTAL_DEPTH_RESOLUTION; // [1, 14]


	// Map borders to wrapping interior texel.
	pixelIndex = (pixelIndex.x == 0) ? uint2(1, LIGHT_PROBE_TOTAL_DEPTH_RESOLUTION - pixelIndex.y - 1) : pixelIndex;
	pixelIndex = (pixelIndex.x == LIGHT_PROBE_TOTAL_DEPTH_RESOLUTION - 1) ? uint2(LIGHT_PROBE_TOTAL_DEPTH_RESOLUTION - 2, LIGHT_PROBE_TOTAL_DEPTH_RESOLUTION - pixelIndex.y - 1) : pixelIndex;
	pixelIndex = (pixelIndex.y == 0) ? uint2(LIGHT_PROBE_TOTAL_DEPTH_RESOLUTION - pixelIndex.x - 1, 1) : pixelIndex;
	pixelIndex = (pixelIndex.y == LIGHT_PROBE_TOTAL_DEPTH_RESOLUTION - 1) ? uint2(LIGHT_PROBE_TOTAL_DEPTH_RESOLUTION - pixelIndex.x - 1, LIGHT_PROBE_TOTAL_DEPTH_RESOLUTION - 2) : pixelIndex;


	pixelIndex -= 1; // Subtract the border -> [0, 13]

	float2 uv = ((float2)pixelIndex + 0.5f) / LIGHT_PROBE_DEPTH_RESOLUTION;
	float2 oct = uv * 2.f - 1.f;

	float3 pixelDirection = decodeOctahedral(oct);

	float2 result = float2(0.f, 0.f);
	float totalWeight = 0.f;

	const float depthSharpness = 3.f;
	const float maxRayDistance = 3.f;

	for (uint r = 0; r < NUM_RAYS_PER_PROBE; ++r)
	{
		uint2 c = uint2(r, probeIndex);
		
		float4 dirDist = directionAndDistance[c];
		float3 rayDirection = dirDist.xyz;
		float rayDistance = dirDist.w;

		rayDistance = min(rayDistance, maxRayDistance);

		float weight = pow(max(0.f, dot(rayDirection, pixelDirection)), depthSharpness);
		float weightedDistance = weight * rayDistance;
		result += float2(weightedDistance, weightedDistance * rayDistance);
		totalWeight += weight;
	}

	result *= 1.f / (max(totalWeight, 1e-4f));

	const float hysteresis = 0.99f;

	float2 previous = output[coord];
	output[coord] = lerp(previous, result, 1.f - hysteresis);
}

```

`shaders/light_probe/light_probe_update_irradiance_cs.hlsl`:

```hlsl
#include "light_probe_rs.hlsli"
#include "cs.hlsli"

ConstantBuffer<light_probe_update_cb> cb	: register(b0);
Texture2D<float3> radiance					: register(t0);
Texture2D<float4> directionAndDistance		: register(t1);

RWTexture2D<float3> output					: register(u0);

#define USE_SHARED_MEMORY 1

#if USE_SHARED_MEMORY
groupshared float3 g_radiance[NUM_RAYS_PER_PROBE];
groupshared float4 g_directionAndDistance[NUM_RAYS_PER_PROBE];
#endif

[numthreads(LIGHT_PROBE_BLOCK_SIZE, LIGHT_PROBE_BLOCK_SIZE, 1)]
[RootSignature(LIGHT_PROBE_UPDATE_RS)]
void main(cs_input IN)
{
	uint2 coord = IN.dispatchThreadID.xy;

	uint2 probeIndex2 = IN.groupID.xy;// coord / LIGHT_PROBE_TOTAL_RESOLUTION;
	uint3 probeIndex3 = uint3(probeIndex2.x % cb.countX, probeIndex2.x / cb.countX, probeIndex2.y);

	uint probeIndex = probeIndex3.z * cb.countX * cb.countY + probeIndex3.y * cb.countX + probeIndex3.x;

#if USE_SHARED_MEMORY
#define NUM_THREADS (LIGHT_PROBE_BLOCK_SIZE * LIGHT_PROBE_BLOCK_SIZE)
	[unroll((NUM_RAYS_PER_PROBE + NUM_THREADS - 1) / NUM_THREADS)]
	for (uint i = IN.groupIndex; i < NUM_RAYS_PER_PROBE; i += (LIGHT_PROBE_BLOCK_SIZE * LIGHT_PROBE_BLOCK_SIZE))
	{
		uint2 c = uint2(i, probeIndex);
		g_radiance[i] = radiance[c];
		g_directionAndDistance[i] = directionAndDistance[c];
	}
	GroupMemoryBarrierWithGroupSync();
#endif


	uint2 pixelIndex = coord % LIGHT_PROBE_TOTAL_RESOLUTION; // [1, 6]


	// Map borders to wrapping interior texel.
	pixelIndex = (pixelIndex.x == 0) ? uint2(1, LIGHT_PROBE_TOTAL_RESOLUTION - pixelIndex.y - 1) : pixelIndex;
	pixelIndex = (pixelIndex.x == LIGHT_PROBE_TOTAL_RESOLUTION - 1) ? uint2(LIGHT_PROBE_TOTAL_RESOLUTION - 2, LIGHT_PROBE_TOTAL_RESOLUTION - pixelIndex.y - 1) : pixelIndex;
	pixelIndex = (pixelIndex.y == 0) ? uint2(LIGHT_PROBE_TOTAL_RESOLUTION - pixelIndex.x - 1, 1) : pixelIndex;
	pixelIndex = (pixelIndex.y == LIGHT_PROBE_TOTAL_RESOLUTION - 1) ? uint2(LIGHT_PROBE_TOTAL_RESOLUTION - pixelIndex.x - 1, LIGHT_PROBE_TOTAL_RESOLUTION - 2) : pixelIndex;


	pixelIndex -= 1; // Subtract the border -> [0, 5]

	float2 uv = ((float2)pixelIndex + 0.5f) / LIGHT_PROBE_RESOLUTION;
	float2 oct = uv * 2.f - 1.f;

	float3 pixelDirection = decodeOctahedral(oct);

	float3 result = float3(0.f, 0.f, 0.f);
	float totalWeight = 0.f;

	for (uint j = 0; j < NUM_RAYS_PER_PROBE; ++j)
	{
#if USE_SHARED_MEMORY
		float3 rad = g_radiance[j];
		float4 dirDist = g_directionAndDistance[j];
#else
		uint2 c = uint2(j, probeIndex);
		float3 rad = radiance[c];
		float4 dirDist = directionAndDistance[c];
#endif

		float3 rayDirection = dirDist.xyz;
		float rayDistance = dirDist.w;

		float weight = max(0.f, dot(rayDirection, pixelDirection));
		result += rad * weight;
		totalWeight += weight;
	}

	result *= ENERGY_CONSERVATION / max(totalWeight, 1e-4f);

	float hysteresis = 0.99f;

	const float3 previous = output[coord];

	if (dot(previous, previous) == 0.f)
	{
		hysteresis = 0.f; // Speed up first frame's convergence.
	}

	output[coord] = lerp(previous, result, 1.f - hysteresis);
}

```

`shaders/mesh_shaders/glass_ps.hlsl`:

```hlsl
#include "camera.hlsli"

struct ps_input
{
	float3 worldPos : POSITION;
	float3 normal	: NORMAL;
}; 

ConstantBuffer<camera_cb> camera	: register(b1);

SamplerState texSampler				: register(s0, space1);
TextureCube<float4> tex				: register(t0, space1);

float4 main(ps_input IN) : SV_TARGET
{
	float3 V = normalize(IN.worldPos - camera.position.xyz);
	float3 N = normalize(IN.normal);

	// Compute reflection and refraction vectors.
	const float ETA = 1.12f;
	float c = dot(V, N);
	float d = ETA * c;
	float k = saturate(d * d + (1.f - ETA * ETA));
	float3 reflVec = V - 2.f * c * N;				// reflect(V, N)
	float3 refrVec = ETA * V - (d + sqrt(k)) * N;	// refract(V, N, ETA)

	// Sample and blend.
	float3 refl = tex.Sample(texSampler, reflVec).rgb;
	float3 refr = tex.Sample(texSampler, refrVec).rgb;
	float3 sky = lerp(refl, refr, k);

	// Add a cheap and fake bubble color effect.
	float3 bubbleTint = 0.25f * pow(1.f - k, 5.f) * abs(N);

	return float4(sky + bubbleTint, 1.f);
}

```

`shaders/mesh_shaders/koch/koch_as.hlsl`:

```hlsl
#include "koch_common.hlsli"
#include "../marching_cubes/marching_cubes_as.hlsli"


```

`shaders/mesh_shaders/koch/koch_common.hlsli`:

```hlsli


static const uint DEFAULT_SHIFT = 7;
static const uint SHIFT = DEFAULT_SHIFT;

#define GRID_SIZE (1u << SHIFT)
#define STEP_SIZE (1.f / float(GRID_SIZE))

// From here: https://www.shadertoy.com/view/sdtcR2

float2 N(float angle) 
{
    return float2(sin(angle), cos(angle));
}

float2 koch(float2 uv)
{
    uv.x = abs(uv.x);

    float3 col = 0.f;
    float d;

    float angle = 0.f;
    float2 n = N((5.f / 6.f) * 3.1415f);

    uv.y += tan((5.f / 6.f) * 3.1415f) * 0.5f;
    d = dot(uv - float2(0.5f, 0.f), n);
    uv -= max(0.f, d) * n * 2.f;

    float scale = 1.;

    n = N((2.f / 3.f) * 3.1415f);
    uv.x += 0.5f;
    for (int i = 0; i < 8; ++i)
    {
        uv *= 3.f;
        scale *= 3.f;
        uv.x -= 1.5f;

        uv.x = abs(uv.x);
        uv.x -= 0.5f;
        d = dot(uv, n);
        uv -= min(0.f, d) * n * 2.f;
    }
    uv /= scale;

    return uv;
}

float field(float3 pos)
{
    pos = pos * 2.f - 1.f;


    float2 xz = koch(float2(length(pos.xz), pos.y));
    float2 yz = koch(float2(length(pos.yz), pos.x));
    float2 xy = koch(float2(length(pos.xy), pos.z));
    float d = max(xy.x, max(yz.x, xz.x));

    d = lerp(d, length(pos) - 0.5f, 0.5f);
    return -d;
}

```

`shaders/mesh_shaders/koch/koch_ms.hlsl`:

```hlsl

#define MESH_RS \
    "RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT |" \
	"DENY_VERTEX_SHADER_ROOT_ACCESS |" \
    "DENY_HULL_SHADER_ROOT_ACCESS |" \
    "DENY_DOMAIN_SHADER_ROOT_ACCESS |" \
    "DENY_GEOMETRY_SHADER_ROOT_ACCESS)," \
    "CBV(b1), " \
	"SRV(t0), " \
	"StaticSampler(s0, space=1), " \
	"DescriptorTable(SRV(t0, space=1, numDescriptors=1), visibility=SHADER_VISIBILITY_PIXEL)"


#include "koch_common.hlsli"
#include "../marching_cubes/marching_cubes_ms.hlsli"

```

`shaders/mesh_shaders/marching_cubes/marching_cubes_as.hlsli`:

```hlsli
#include "marching_cubes_common.hlsli"

groupshared uint values[5][5][5]; // 125 intermediate values for the 5x5x5 corners of 4x4x4 cubes.

[numthreads(32, 1, 1)]
void main(
	in uint groupThreadID : SV_GroupThreadID,
	in uint groupID : SV_GroupID
)
{
	uint miX = 4 * ((groupID >> (0 * (SHIFT - 2))) & (GRID_SIZE / 4 - 1));
	uint miY = 4 * ((groupID >> (1 * (SHIFT - 2))) & (GRID_SIZE / 4 - 1));
	uint miZ = 4 * ((groupID >> (2 * (SHIFT - 2))));
	
	// 125 values are needed, so this loops 4 times, 3 lanes get wasted on last iteration.
	for (uint i = groupThreadID; i < 5 * 5 * 5; i += 32)
	{
		uint t = (205 * i) >> 10; // Fast i / 5, works for values < 1024. (205/1024 = 0.2001953125 ~ 1/5).
		uint x = i - 5 * t;       // Fast i % 5
		uint z = (205 * t) >> 10;
		uint y = t - 5 * z;

		float3 pos = float3(miX + x, miY + y, miZ + z) * STEP_SIZE;
		values[z][y][x] = (field(pos) >= 0.f) ? 1 : 0;
	}

	// Two loops, all lanes used.
	uint count = 0;
	mesh_payload payload;
	payload.meshletIDs[0] = 0; // This suppresses a warning, but is not necessary.

	for (i = groupThreadID; i < 64; i += 32)
	{
		uint x = i & 0x3;
		uint y = (i >> 2) & 0x3;
		uint z = i >> 4;

		// Collect the sign bits for the cube corners. If all are zeros or all ones we're either fully inside or outside
		// the surface, so no triangles will be generated. In all other cases, the isosurface cuts through the cube somewhere.
		uint cubeIndex;
		cubeIndex  = (values[z + 0][y + 0][x + 0] << 0);
		cubeIndex |= (values[z + 0][y + 0][x + 1] << 1);
		cubeIndex |= (values[z + 0][y + 1][x + 0] << 2);
		cubeIndex |= (values[z + 0][y + 1][x + 1] << 3);
		cubeIndex |= (values[z + 1][y + 0][x + 0] << 4);
		cubeIndex |= (values[z + 1][y + 0][x + 1] << 5);
		cubeIndex |= (values[z + 1][y + 1][x + 0] << 6);
		cubeIndex |= (values[z + 1][y + 1][x + 1] << 7);


		// See if our cube intersects the isosurface.
		uint accept = (cubeIndex != 0 && cubeIndex != 0xFF);

		uint4 ballot = WaveActiveBallot(accept);

		if (accept)
		{
			uint index = countbits(ballot.x & ((1u << groupThreadID) - 1));

			// Output a linear meshlet ID for the mesh shader.
			uint meshletID = ((((miZ + z) << SHIFT) + miY + y) << SHIFT) + miX + x;
			payload.meshletIDs[count + index] = meshletID;
		}

		count += countbits(ballot.x);
	}

	DispatchMesh(count, 1, 1, payload);
}

```

`shaders/mesh_shaders/marching_cubes/marching_cubes_common.hlsli`:

```hlsli


struct marching_cubes_lookup
{
	uint indices[4];
	uint vertices[3];
	uint triangleAndVertexCount;
};


struct mesh_payload
{
	uint meshletIDs[64];
};



```

`shaders/mesh_shaders/marching_cubes/marching_cubes_ms.hlsli`:

```hlsli
#include "marching_cubes_common.hlsli"
#include "camera.hlsli"


struct mesh_output
{
	float4 pos : SV_POSITION;
	float3 worldPos : POSITION;
	float3 normal : NORMAL;
};


struct cube_corner
{
	float3 normal;
	float value;
};
groupshared cube_corner corners[8];

ConstantBuffer<camera_cb> camera								: register(b1);
StructuredBuffer<marching_cubes_lookup> marchingCubesLookup     : register(t0);

[RootSignature(MESH_RS)]
[outputtopology("triangle")]
[numthreads(32, 1, 1)]
void main(
	in uint groupID : SV_GroupID,
	in uint groupThreadID : SV_GroupThreadID,
	in payload mesh_payload p,
	out vertices mesh_output outVerts[12],
	out indices uint3 outTriangles[5])
{
	const uint meshletID = p.meshletIDs[groupID];

	// Convert linear meshletID into x, y and z coordinates
	uint miX = (meshletID >> (0 * SHIFT)) & (GRID_SIZE - 1);
	uint miY = (meshletID >> (1 * SHIFT)) & (GRID_SIZE - 1);
	uint miZ = (meshletID >> (2 * SHIFT));

	// Corner positions of the cube
	float3 cornerPos0 = float3(miX, miY, miZ) * STEP_SIZE;
	float3 cornerPos1 = cornerPos0 + STEP_SIZE;

	// First 8 lanes evaluate the field for each corner, the other 24 evaluate at offsetted positions in x, y and z so we can compute a normal at each corner from the field gradient
	float3 pos = float3((groupThreadID & 1) != 0 ? cornerPos1.x : cornerPos0.x, (groupThreadID & 2) != 0 ? cornerPos1.y : cornerPos0.y, (groupThreadID & 4) != 0 ? cornerPos1.z : cornerPos0.z);

	const float epsilon = (1.f / 16.f) * STEP_SIZE;
	uint off = groupThreadID / 8;
	pos.x += (off == 1) ? epsilon : 0.f;
	pos.y += (off == 2) ? epsilon : 0.f;
	pos.z += (off == 3) ? epsilon : 0.f;

	// Evaluate the field function for all 32 lanes
	float value = field(pos);

	// Grab data from other lanes so we can compute the normal by computing the difference in value in x, y and z directions.
	float3 normal;
	normal.x = WaveReadLaneAt(value, WaveGetLaneIndex() +  8);
	normal.y = WaveReadLaneAt(value, WaveGetLaneIndex() + 16);
	normal.z = WaveReadLaneAt(value, WaveGetLaneIndex() + 24);

	// Save intermediates to LDS. Corner positions can be computed directly from indices, so no need to put in LDS.
	if (groupThreadID < 8)
	{
		cube_corner corner;
		corner.normal = normalize(value - normal);
		corner.value = value;
		corners[groupThreadID] = corner;
	}

	// Look up the Marching Cubes index from the signs of corner nodes. Only the lowest 8 lanes are relevant here, hence the 0xFF mask.
	uint4 ballot = WaveActiveBallot(value >= 0.f);
	uint index = (ballot.x & 0xFF);

	const uint vertexCount = uint(marchingCubesLookup[index].triangleAndVertexCount >> 16);
	const uint triangleCount = marchingCubesLookup[index].triangleAndVertexCount & 0xFFFF;

	SetMeshOutputCounts(vertexCount, triangleCount);

	// Output up to 12 vertices, one lane per vertex.
	if (groupThreadID < vertexCount)
	{
		// Look up the corner indices for this edge
		uint lookupWord = groupThreadID >> 2; // Divide by 4.
		uint lookupID = groupThreadID & 0x3;  // Modulo 4.

		uint word = marchingCubesLookup[index].vertices[lookupWord];
		uint edge = (word >> (lookupID * 8)) & 0xFF;

		uint i0 = edge & 0x7;
		uint i1 = edge >> 3;

		// Corner positions
		float3 pos0 = float3((i0 & 1) != 0 ? cornerPos1.x : cornerPos0.x, (i0 & 2) != 0 ? cornerPos1.y : cornerPos0.y, (i0 & 4) != 0 ? cornerPos1.z : cornerPos0.z);
		float3 pos1 = float3((i1 & 1) != 0 ? cornerPos1.x : cornerPos0.x, (i1 & 2) != 0 ? cornerPos1.y : cornerPos0.y, (i1 & 4) != 0 ? cornerPos1.z : cornerPos0.z);

		// Interpolate position and normal
		float t = corners[i0].value / (corners[i0].value - corners[i1].value);
		float3 pos = lerp(pos0, pos1, t);
		float3 normal = lerp(corners[i0].normal, corners[i1].normal, t);

		// Output final vertex
		pos *= 20.f;
		outVerts[groupThreadID].pos = mul(camera.viewProj, float4(pos, 1.f));
		outVerts[groupThreadID].worldPos = pos;
		outVerts[groupThreadID].normal = normal;
	}

	// Output up to 5 triangles, one lane per triangle. 
	if (groupThreadID < triangleCount)
	{
		struct single_unpack
		{
			uint index;
			uint shiftDown;
		};

		struct unpack_info
		{
			single_unpack singleUnpacks[3];
		};

		static const unpack_info unpack[5] =
		{
			{ { 0, 0 }, { 0, 8 }, { 0, 16 } },
			{ { 0, 24 }, { 1, 0 }, { 1, 8 } },
			{ { 1, 16 }, { 1, 24 }, { 2, 0 } },
			{ { 2, 8 }, { 2, 16 }, { 2, 24 } },
			{ { 3, 0 }, { 3, 8 }, { 3, 16 } },
		};

		unpack_info info = unpack[groupThreadID];

		uint packedIndex = marchingCubesLookup[index].indices[groupThreadID];

		outTriangles[groupThreadID] = uint3
		(
			(marchingCubesLookup[index].indices[info.singleUnpacks[0].index] >> (info.singleUnpacks[0].shiftDown)) & 0xFF,
			(marchingCubesLookup[index].indices[info.singleUnpacks[1].index] >> (info.singleUnpacks[1].shiftDown)) & 0xFF,
			(marchingCubesLookup[index].indices[info.singleUnpacks[2].index] >> (info.singleUnpacks[2].shiftDown)) & 0xFF
		);
	}
}

```

`shaders/mesh_shaders/mesh_shader_ps.hlsl`:

```hlsl

struct ps_input
{
	float3 color : COLOR0;
};

float4 main(ps_input IN) : SV_TARGET
{
	return float4(IN.color, 1.f);
}

```

`shaders/mesh_shaders/meshlet_ms.hlsl`:

```hlsl
#include "transform.hlsli"

#define MESH_RS \
    "RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT |" \
	"DENY_VERTEX_SHADER_ROOT_ACCESS |" \
    "DENY_HULL_SHADER_ROOT_ACCESS |" \
    "DENY_DOMAIN_SHADER_ROOT_ACCESS |" \
    "DENY_GEOMETRY_SHADER_ROOT_ACCESS |" \
    "DENY_PIXEL_SHADER_ROOT_ACCESS)," \
    "RootConstants(num32BitConstants=32, b0), " \
    "SRV(t0), " \
    "SRV(t1), " \
    "SRV(t2), " \
    "SRV(t3)"

struct mesh_output
{
	float4 pos : SV_POSITION;
	float3 color : COLOR0;
};



struct mesh_vertex
{
    float3 position;
    float3 normal;
};

struct meshlet_info
{
    uint numVertices;
    uint firstVertex;
    uint numPrimitives;
    uint firstPrimitive;
};

ConstantBuffer<transform_cb> transform      : register(b0);

StructuredBuffer<mesh_vertex> vertices      : register(t0);
StructuredBuffer<meshlet_info> meshlets     : register(t1);
StructuredBuffer<uint> uniqueVertexIndices  : register(t2);
StructuredBuffer<uint> primitiveIndices     : register(t3);



[outputtopology("triangle")]
[numthreads(128, 1, 1)]
[RootSignature(MESH_RS)]
void main(
    in uint groupThreadID : SV_GroupThreadID, 
    in uint groupID : SV_GroupID, 
    out vertices mesh_output outVerts[64], 
    out indices uint3 outIndices[126]
)
{
    meshlet_info m = meshlets[groupID];

    SetMeshOutputCounts(m.numVertices, m.numPrimitives);

    if (groupThreadID < m.numPrimitives)
    {
        uint packedPrimitive = primitiveIndices[m.firstPrimitive + groupThreadID];

        // Unpacks a 10 bits per index triangle from a 32-bit uint.
        outIndices[groupThreadID] = uint3(packedPrimitive & 0x3FF, (packedPrimitive >> 10) & 0x3FF, (packedPrimitive >> 20) & 0x3FF);
    }

    if (groupThreadID < m.numVertices)
    {
        uint vertexIndex = uniqueVertexIndices[m.firstVertex + groupThreadID];
        uint meshletIndex = groupID;

        // Color based on meshlet index for visualization.
        outVerts[groupThreadID].color = float3(
            float(meshletIndex & 1),
            float(meshletIndex & 3) / 4,
            float(meshletIndex & 7) / 8);

        outVerts[groupThreadID].pos = mul(transform.mvp, float4(vertices[vertexIndex].position, 1.f));
    }
}

```

`shaders/mesh_shaders/meta_ball/meta_ball_as.hlsl`:

```hlsl
#include "meta_ball_common.hlsli"
#include "../marching_cubes/marching_cubes_as.hlsli"


```

`shaders/mesh_shaders/meta_ball/meta_ball_common.hlsli`:

```hlsli


static const uint DEFAULT_SHIFT = 7;
static const uint DEFAULT_BALL_COUNT = 32;
static const uint MAX_BALL_COUNT = 128;

static const uint BALL_COUNT = DEFAULT_BALL_COUNT;
static const uint SHIFT = DEFAULT_SHIFT;

#define GRID_SIZE (1u << SHIFT)
#define STEP_SIZE (1.f / float(GRID_SIZE))

struct constant_cb
{
	float4 balls[MAX_BALL_COUNT];
};



ConstantBuffer<constant_cb> constants : register(b0);



// The isosurface is defined where this function returns zero.
float field(vec3 pos)
{
	// Compute metaballs
	float sum = -1.f;
	for (int i = 0; i < BALL_COUNT; i++)
	{
		float3 d = constants.balls[i].xyz - pos;
		sum += constants.balls[i].w / dot(d, d);
	}

	// Occasionally some balls swing across the outer edge of the volume, causing a visible cut.
	// For more visually pleasing results, we manipulate the field a bit with a fade gradient near the edge, so that the balls flatten against the edge instead.
	vec3 d = abs(pos - 0.5f.xxx);
	float edge_dist = max(d.x, max(d.y, d.z));
	sum = sum * min(0.5f * (0.5f - edge_dist), 1.f) - 0.001f;

	return sum;
}


```

`shaders/mesh_shaders/meta_ball/meta_ball_ms.hlsl`:

```hlsl

#define MESH_RS \
    "RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT |" \
	"DENY_VERTEX_SHADER_ROOT_ACCESS |" \
    "DENY_HULL_SHADER_ROOT_ACCESS |" \
    "DENY_DOMAIN_SHADER_ROOT_ACCESS |" \
    "DENY_GEOMETRY_SHADER_ROOT_ACCESS)," \
    "CBV(b0), " \
    "CBV(b1), " \
	"SRV(t0), " \
	"StaticSampler(s0, space=1), " \
	"DescriptorTable(SRV(t0, space=1, numDescriptors=1), visibility=SHADER_VISIBILITY_PIXEL)"


#include "meta_ball_common.hlsli"
#include "../marching_cubes/marching_cubes_ms.hlsli"

```

`shaders/outline/outline_ps.hlsl`:

```hlsl
#include "outline_rs.hlsli"

struct ps_input
{
	float2 uv				: TEXCOORDS;
	float4 screenPosition	: SV_POSITION;
};

ConstantBuffer<outline_drawer_cb> outline : register(b0);

Texture2D<uint2> stencil	: register(t0);


static const int selected = (1 << 0); // TODO: This must be the same as in renderer.

static uint sampleAt(int2 texCoords)
{
	uint result = 1;
	if (texCoords.x >= 0 && texCoords.y >= 0 && texCoords.x < outline.width && texCoords.y < outline.height)
	{
		result = (stencil[texCoords].y & selected) != 0;
	}
	return result;
}

[RootSignature(OUTLINE_DRAWER_RS)]
float4 main(ps_input IN) : SV_TARGET
{
	int2 texCoords = int2(IN.screenPosition.xy);

	uint s = 0;

	[unroll]
	for (int x = -2; x <= 2; ++x)
	{
		for (int y = -2; y <= 2; ++y)
		{
			s += sampleAt(texCoords + int2(x, y));
		}
	}

	if (s == 25)
	{
		discard;
	}

	return float4(1.f, 0, 0.f, 1.f);
}

```

`shaders/outline/outline_vs.hlsl`:

```hlsl
#include "outline_rs.hlsli"


ConstantBuffer<outline_marker_cb> outline : register(b0);

struct vs_input
{
	float3 position		: POSITION;
};

struct vs_output
{
	float4 position			: SV_POSITION;
};

[RootSignature(OUTLINE_MARKER_RS)]
vs_output main(vs_input IN)
{
	vs_output OUT;
	OUT.position = mul(outline.mvp, float4(IN.position, 1.f));
	return OUT;
}

```

`shaders/particle_systems/boid_particle_system.hlsli`:

```hlsli
#include "camera.hlsli"

struct boid_particle_data
{
	vec3 position;
	uint32 maxLife_life;
	vec3 velocity;
	uint32 color;
};

struct boid_particle_settings
{
	float radius;
};

struct boid_simulation_cb
{
	vec3 emitPosition;
	uint32 frameIndex;
	float radius;
};

#ifdef HLSL
#define particle_data boid_particle_data

#include "material.hlsli"
#endif

#ifdef PARTICLE_SIMULATION

#define USER_PARTICLE_SIMULATION_RS \
	"RootConstants(num32BitConstants=5, b0)"

ConstantBuffer<boid_simulation_cb> cb		: register(b0);

static particle_data emitParticle(uint emitIndex)
{
	uint rng = initRand(emitIndex, cb.frameIndex);

	const float radius = cb.radius;

	float2 offset2D = getRandomPointOnDisk(rng, radius);
	float height = nextRand(rng) * 2.f + 3.f;
	float3 position = cb.emitPosition + float3(offset2D.x, height, offset2D.y);

	float maxLife = nextRand(rng) + 4.5f;

	float2 velocity = getRandomPointOnUnitDisk(rng) * (5.f + nextRand(rng) * 1.5f);

	particle_data particle = {
		position,
		packHalfs(maxLife, maxLife),
		float3(velocity.x, 0.f, velocity.y),
		packColor(0, 0, 255, 255)  //packColor(nextRand(rng), nextRand(rng), nextRand(rng), 1.f)
	};

	return particle;
}

static bool simulateParticle(inout particle_data particle, float dt)
{
	float life = unpackHalfsRight(particle.maxLife_life);
	life -= dt;
	if (life <= 0)
	{
		return false;
	}
	else
	{
		float3 gravity = float3(0.f, -9.81f * dt, 0.f);
		particle.position = particle.position + 0.5f * gravity * dt + particle.velocity * dt;
		particle.velocity = particle.velocity + gravity;
		if (particle.position.y <= cb.emitPosition.y)
		{
			particle.position.y = cb.emitPosition.y;
			particle.velocity.y = 0.f;
		}

		float maxLife = unpackHalfsLeft(particle.maxLife_life);
		particle.maxLife_life = packHalfs(maxLife, life);

		return true;
	}
}

#endif


#ifdef PARTICLE_RENDERING

#include "lighting.hlsli"

#define USER_PARTICLE_RENDERING_RS \
    "CBV(b0), " \
	"DescriptorTable(SRV(t0, numDescriptors=3), visibility=SHADER_VISIBILITY_PIXEL), " \
	"StaticSampler(s0," \
        "addressU = TEXTURE_ADDRESS_CLAMP," \
        "addressV = TEXTURE_ADDRESS_CLAMP," \
        "addressW = TEXTURE_ADDRESS_CLAMP," \
        "filter = FILTER_MIN_MAG_MIP_LINEAR," \
        "visibility=SHADER_VISIBILITY_PIXEL)"


struct vs_input
{
	float3 position				: POSITION;
	float2 uv					: TEXCOORDS;
	float3 normal				: NORMAL;
	float3 tangent				: TANGENT;
};

struct vs_output
{
	float3 worldPosition		: POSITION;
	float3 normal				: NORMAL;
	nointerpolation uint color	: COLOR;
	float4 position				: SV_Position;
};

ConstantBuffer<camera_cb> camera		: register(b0);

TextureCube<float4> irradianceTexture	: register(t0);
TextureCube<float4> environmentTexture	: register(t1);
Texture2D<float2> brdf					: register(t2);

SamplerState clampSampler				: register(s0);


static vs_output vertexShader(vs_input IN, StructuredBuffer<particle_data> particles, uint index)
{
	uint maxLife_life = particles[index].maxLife_life;
	float life = unpackHalfsRight(maxLife_life);
	float maxLife = unpackHalfsLeft(maxLife_life);
	float relLife = clamp(1.f - life / maxLife, 0.01f, 0.99f);

	float scale = smoothstep(relLife, 0.f, 0.005f);
	scale = min(scale, smoothstep(1.f - relLife, 0.f, 0.005f));


	float3 backward = particles[index].velocity;
	backward.y = 0.f;
	backward = normalize(backward);
	float3 up = float3(0.f, 1.f, 0.f);
	float3 right = cross(up, backward);

	float3 localPosition = IN.position;
	float3 localNormal = IN.normal;

	float3 rotatedPosition = localPosition.x * right + localPosition.y * up + localPosition.z * backward;
	float3 rotatedNormal = localNormal.x * right + localNormal.y * up + localNormal.z * backward;

	float3 pos = particles[index].position + rotatedPosition * scale;

	vs_output OUT;
	OUT.worldPosition = pos;
	OUT.position = mul(camera.viewProj, float4(pos, 1.f));
	OUT.normal = rotatedNormal;
	OUT.color = particles[index].color;
	return OUT;
}

static float4 pixelShader(vs_output IN)
{
	surface_info surface;

	surface.albedo = unpackColor(IN.color);
	surface.N = normalize(IN.normal);

	surface.roughness = 0.6f;
	surface.roughness = clamp(surface.roughness, 0.01f, 0.99f);
	surface.metallic = 0.f;

	surface.emission = float3(0.f, 0.f, 0.f);

	surface.P = IN.worldPosition;
	float3 camToP = surface.P - camera.position.xyz;
	surface.V = -normalize(camToP);

	surface.inferRemainingProperties();


	float3 L = normalize(float3(1.f, 0.5f, -1.f));
	float3 radiance = float3(1.f, 1.f, 1.f) * 20.f;

	light_info light;
	light.initialize(surface, L, radiance);


	light_contribution totalLighting = { float3(0.f, 0.f, 0.f), float3(0.f, 0.f, 0.f) };
	totalLighting.add(calculateDirectLighting(surface, light), 1.f);


	ambient_factors factors = getAmbientFactors(surface);
	totalLighting.diffuse += diffuseIBL(factors.kd, surface, irradianceTexture, clampSampler);
	totalLighting.specular += specularIBL(factors.ks, surface, environmentTexture, brdf, clampSampler);


	return totalLighting.evaluate(surface.albedo);
}

#endif


// Simulation.
#define BOID_PARTICLE_SYSTEM_COMPUTE_RS_CBV			0

// Rendering.
#define BOID_PARTICLE_SYSTEM_RENDERING_RS_CAMERA	0
#define BOID_PARTICLE_SYSTEM_RENDERING_RS_PBR		1

```

`shaders/particle_systems/debris_particle_system.hlsli`:

```hlsli
#include "material.hlsli"
#include "camera.hlsli"
#include "particles.hlsli"

struct debris_particle_data
{
	vec3 position;
	uint32 maxLife_life;
	vec3 velocity;
	uint32 sinAngle_cosAngle;
};

struct debris_simulation_cb
{
	vec4 emitPositions[4];

	mat4 cameraVP;
	vec4 cameraProjectionParams;

	vec3 cameraPosition;
	uint32 frameIndex;
	float drag;
};

#ifdef HLSL
#define particle_data debris_particle_data
#endif


#ifdef PARTICLE_SIMULATION

#include "normal.hlsli"
#include "random.hlsli"

#define REQUIRES_SORTING

#define USER_PARTICLE_SIMULATION_RS \
	"CBV(b0), " \
	"DescriptorTable(SRV(t0, numDescriptors=2)), " \
    "StaticSampler(s0," \
        "addressU = TEXTURE_ADDRESS_BORDER," \
        "addressV = TEXTURE_ADDRESS_BORDER," \
        "addressW = TEXTURE_ADDRESS_BORDER," \
		"borderColor = STATIC_BORDER_COLOR_OPAQUE_WHITE," \
        "filter = FILTER_MIN_MAG_MIP_POINT)"

ConstantBuffer<debris_simulation_cb> cb	: register(b0);
Texture2D<float> depthBuffer			: register(t0);
Texture2D<float2> sceneNormals			: register(t1);
SamplerState pointSampler				: register(s0);

static particle_data emitParticle(uint emitIndex)
{
	uint rng = initRand(emitIndex, cb.frameIndex);

	uint emitBatch = emitIndex / 256;
	emitIndex = emitIndex % 256;

	float2 randomOnDisk = getRandomPointOnUnitDisk(rng) * 0.3f;
	float3 position = float3(randomOnDisk.x, 0.f, randomOnDisk.y);
	float maxLife = 5.5f;

	float3 velocity = normalize(position);

	position += cb.emitPositions[emitBatch].xyz;

	float i = (float)emitIndex * 2.f * M_PI;
	float sinAngle, cosAngle;
	sincos(i, sinAngle, cosAngle);

	particle_data particle = {
		position,
		packHalfs(maxLife, maxLife),
		velocity,
		packHalfs(sinAngle, cosAngle)
	};

	return particle;
}

static bool simulateParticle(inout particle_data particle, float dt, out float sortKey)
{
	float life = unpackHalfsRight(particle.maxLife_life);
	life -= dt;
	if (life <= 0)
	{
		sortKey = 0;
		return false;
	}
	else
	{
		float maxLife = unpackHalfsLeft(particle.maxLife_life);
		float relLife = getRelLife(life, maxLife);

		particle.velocity.y -= 9.81f * dt;
		particle.velocity *= cb.drag;

		float4 p = mul(cb.cameraVP, float4(particle.position, 1.f));
		p.xyz /= p.w;
		float2 uv = p.xy * float2(0.5f, -0.5f) + float2(0.5f, 0.5f);

		float particleDepth = depthBufferDepthToEyeDepth(p.z, cb.cameraProjectionParams);
		float sceneDepth = depthBufferDepthToEyeDepth(isSaturated(p.z) ? depthBuffer.SampleLevel(pointSampler, uv, 0) : 1.f, cb.cameraProjectionParams); // Due to the border sampler, this defaults to 1 (infinite depth) outside the image.


		if (particleDepth > sceneDepth - 0.05f && particleDepth < sceneDepth + 1.f)
		{
			float3 sceneNormal = normalize(unpackNormal(sceneNormals.SampleLevel(pointSampler, uv, 0)));

			float VdotN = dot(particle.velocity, sceneNormal);
			if (VdotN < 0.f)
			{
				particle.velocity = reflect(particle.velocity, sceneNormal) * 0.5f;
				//particle.position += sceneNormal * (particleDepth - sceneDepth);
			}
		}

		particle.position += particle.velocity * dt;

		particle.maxLife_life = packHalfs(maxLife, life);

		float3 V = particle.position - cb.cameraPosition;
		sortKey = dot(V, V);


		return true;
	}
}

#endif




#ifdef PARTICLE_RENDERING

#define USER_PARTICLE_RENDERING_RS \
    "CBV(b0, visibility=SHADER_VISIBILITY_VERTEX)"


struct vs_input
{
	float3 position			: POSITION;
};

struct vs_output
{
	float2 uv				: TEXCOORD;
	float4 position			: SV_Position;
};

ConstantBuffer<camera_cb> camera		: register(b0);

static vs_output vertexShader(vs_input IN, StructuredBuffer<particle_data> particles, uint index)
{
	float3 pos = particles[index].position;

	float2 rotation; // Sin(angle), cos(angle).
	unpackHalfs(particles[index].sinAngle_cosAngle, rotation.x, rotation.y);

	float2 uv = IN.position.xy * 0.5f + 0.5f;

	float size = 0.1f;
	float2 localPosition = IN.position.xy * size;
	localPosition = float2(dot(localPosition, float2(rotation.y, -rotation.x)), dot(localPosition, rotation));
	pos += localPosition.x * camera.right.xyz + localPosition.y * camera.up.xyz;

	vs_output OUT;
	OUT.position = mul(camera.viewProj, float4(pos, 1.f));
	//OUT.color = particles[index].velocity;
	OUT.uv = uv;
	return OUT;
}

static float4 pixelShader(vs_output IN)
{
	float radius = 0.5f;
	float2 o = IN.uv - float2(0.5f, 0.5f);

	float2 o2 = o * 2.f;
	float z = 1 - sqrt(dot(o2, o2));
	float3 N = float3(o2.xy, z);

	float alpha = step(dot(o, o), radius * radius);
	return float4(abs(N), alpha);
}

#endif


// Simulation.
#define DEBRIS_PARTICLE_SYSTEM_COMPUTE_RS_CBV				0
#define DEBRIS_PARTICLE_SYSTEM_COMPUTE_RS_TEXTURES			1

// Rendering.
#define DEBRIS_PARTICLE_SYSTEM_RENDERING_RS_CAMERA			0




```

`shaders/particle_systems/fire_particle_system.hlsli`:

```hlsli
#include "material.hlsli"
#include "camera.hlsli"
#include "particles.hlsli"

struct fire_particle_data
{
	vec3 position;
	uint32 maxLife_life;
	vec3 velocity;
	uint32 sinAngle_cosAngle;
};

defineSpline(float, 4)
defineSpline(float, 8)

struct fire_particle_settings
{
	spline(float, 4) sizeOverLifetime;
	spline(float, 4) intensityOverLifetime;
	spline(float, 4) atlasProgressionOverLifetime;
};

struct fire_simulation_cb
{
	vec3 emitPosition;
	uint32 frameIndex;
	vec3 cameraPosition;
	uint32 padding;
};

struct fire_rendering_cb
{
	fire_particle_settings settings;
	texture_atlas_cb atlas;
};

#ifdef HLSL
#define particle_data fire_particle_data
#endif

#ifdef PARTICLE_SIMULATION

#define REQUIRES_SORTING

#define USER_PARTICLE_SIMULATION_RS \
	"RootConstants(num32BitConstants=8, b0)"

ConstantBuffer<fire_simulation_cb> cb		: register(b0);

static particle_data emitParticle(uint emitIndex)
{
	uint rng = initRand(emitIndex, cb.frameIndex);

	float radiusAtDistanceOne = 0.1f;
	float2 diskPoint = getRandomPointOnDisk(rng, radiusAtDistanceOne);

	float3 position = cb.emitPosition;
	float3 velocity = normalize(float3(1.f, diskPoint.x, diskPoint.y));
	velocity.x *= 4.f;

	float maxLife = nextRandBetween(rng, 1.3f, 1.8f);

	float angle = nextRand(rng) * 2.f * M_PI;
	float sinAngle, cosAngle;
	sincos(angle, sinAngle, cosAngle);

	particle_data particle = {
		position,
		packHalfs(maxLife, maxLife),
		velocity,
		packHalfs(sinAngle, cosAngle)
	};

	return particle;
}

static bool simulateParticle(inout particle_data particle, float dt, out float sortKey)
{
	float life = unpackHalfsRight(particle.maxLife_life);
	life -= dt;
	if (life <= 0)
	{
		sortKey = 0;
		return false;
	}
	else
	{
		float maxLife = unpackHalfsLeft(particle.maxLife_life);
		float relLife = getRelLife(life, maxLife);

		float3 velocity = particle.velocity;
		velocity.y += 5.f * dt;

		const float damping = 1.f;
		//velocity *= 1.f / (1.f + dt * damping);

		particle.position = particle.position + velocity * dt;
		particle.maxLife_life = packHalfs(maxLife, life);
		particle.velocity = velocity;

		float3 V = particle.position - cb.cameraPosition;
		sortKey = dot(V, V);

		return true;
	}
}

#endif




#ifdef PARTICLE_RENDERING

#define USER_PARTICLE_RENDERING_RS \
    "CBV(b0, visibility=SHADER_VISIBILITY_VERTEX), " \
    "CBV(b1, visibility=SHADER_VISIBILITY_VERTEX), " \
	"DescriptorTable(SRV(t0, numDescriptors=1), visibility=SHADER_VISIBILITY_PIXEL), " \
	"StaticSampler(s0," \
        "addressU = TEXTURE_ADDRESS_WRAP," \
        "addressV = TEXTURE_ADDRESS_WRAP," \
        "addressW = TEXTURE_ADDRESS_WRAP," \
        "filter = FILTER_MIN_MAG_MIP_LINEAR," \
        "visibility=SHADER_VISIBILITY_PIXEL)"


struct vs_input
{
	float3 position			: POSITION;
};

struct vs_output
{
	float intensity			: INTENSITY;
	float2 uv0				: TEXCOORDS0;
	float2 uv1				: TEXCOORDS1;
	float uvBlend			: BLEND;
	float alphaScale		: ALPHASCALE;
	float4 position			: SV_Position;
};

ConstantBuffer<fire_rendering_cb> cb	: register(b0);
ConstantBuffer<camera_cb> camera		: register(b1);

Texture2D<float4> tex					: register(t0);
SamplerState texSampler					: register(s0);

static float2 getUVs(texture_atlas_cb atlas, uint atlasIndex, float2 originalUV)
{
	uint x = atlas.getX(atlasIndex);
	uint y = atlas.getY(atlasIndex);

	float invCols = atlas.getInvNumCols();
	float invRows = atlas.getInvNumRows();
	float2 uv0 = float2(x * invCols, y * invRows);
	float2 uv1 = float2((x + 1) * invCols, (y + 1) * invRows);

	return lerp(uv0, uv1, originalUV);
}

static vs_output vertexShader(vs_input IN, StructuredBuffer<particle_data> particles, uint index)
{
	float3 pos = particles[index].position;

	uint maxLife_life = particles[index].maxLife_life;
	float life, maxLife;
	unpackHalfs(maxLife_life, maxLife, life);
	float relLife = getRelLife(life, maxLife);

	float2 rotation; // Sin(angle), cos(angle).
	unpackHalfs(particles[index].sinAngle_cosAngle, rotation.x, rotation.y);

	float size = cb.settings.sizeOverLifetime.evaluate(4, relLife);
	float2 localPosition = IN.position.xy * size;
	localPosition = float2(dot(localPosition, float2(rotation.y, -rotation.x)), dot(localPosition, rotation));
	pos += localPosition.x * camera.right.xyz + localPosition.y * camera.up.xyz;

	texture_atlas_cb atlas = cb.atlas;
	float atlasProgression = cb.settings.atlasProgressionOverLifetime.evaluate(4, relLife);
	float atlasIndex = atlasProgression * (atlas.getTotalNumCells() - 1);
	float2 originalUV = IN.position.xy * 0.5f + 0.5f;

	vs_output OUT;
	OUT.position = mul(camera.viewProj, float4(pos, 1.f));
	OUT.intensity = 20 * cb.settings.intensityOverLifetime.evaluate(4, relLife);

	OUT.uv0 = getUVs(atlas, (uint)atlasIndex, originalUV);
	OUT.uv1 = getUVs(atlas, (uint)atlasIndex + 1, originalUV);
	OUT.uvBlend = frac(atlasIndex);

	OUT.alphaScale = 1.f - smoothstep(0.9f, 1.f, atlasProgression);

	return OUT;
}

static float4 pixelShader(vs_output IN)
{
	float4 color = lerp(tex.Sample(texSampler, IN.uv0), tex.Sample(texSampler, IN.uv1), IN.uvBlend);
	float3 emission = color.rgb * float3(0.75f, 0.25f, 0.09f) * IN.intensity;
	return mergeAlphaBlended(color.rgb, (float3)0.f, emission, color.a * IN.alphaScale);
}

#endif


// Simulation.
#define FIRE_PARTICLE_SYSTEM_COMPUTE_RS_CBV			0

// Rendering.
#define FIRE_PARTICLE_SYSTEM_RENDERING_RS_CBV		0
#define FIRE_PARTICLE_SYSTEM_RENDERING_RS_CAMERA	1
#define FIRE_PARTICLE_SYSTEM_RENDERING_RS_TEXTURE	2



```

`shaders/particle_systems/smoke_particle_system.hlsli`:

```hlsli
#include "material.hlsli"
#include "camera.hlsli"

struct smoke_particle_data
{
	vec3 position;
	uint32 maxLife_life;
	vec3 velocity;
	uint32 sinAngle_cosAngle;
};

defineSpline(float, 4)
defineSpline(float, 8)

struct smoke_particle_settings
{
	spline(float, 8) lifeScaleFromDistance;
	spline(float, 4) intensityOverLifetime;
	spline(float, 4) atlasProgressionOverLifetime;
};

struct smoke_simulation_cb
{
	vec3 emitPosition;
	uint32 frameIndex;
	vec3 cameraPosition;
	uint32 padding;

	spline(float, 8) lifeScaleFromDistance;
};

struct smoke_rendering_cb
{
	spline(float, 4) intensityOverLifetime;
	spline(float, 4) atlasProgressionOverLifetime;

	texture_atlas_cb atlas;
};

#ifdef HLSL
#define particle_data smoke_particle_data
#endif

#ifdef PARTICLE_SIMULATION

#define REQUIRES_SORTING

#define USER_PARTICLE_SIMULATION_RS \
	"CBV(b0)"

ConstantBuffer<smoke_simulation_cb> cb		: register(b0);

static particle_data emitParticle(uint emitIndex)
{
	uint rng = initRand(emitIndex, cb.frameIndex);

	const float radius = 4.f;

	float2 offset2D = getRandomPointOnDisk(rng, radius);
	float3 offset = float3(offset2D.x, nextRand(rng) * 0.5f, offset2D.y);
	float3 position = cb.emitPosition + offset;
	float3 velocity = float3(nextRand(rng), nextRand(rng) * 3.f + 4.f, nextRand(rng));

	float distance = saturate(length(offset.xz) / radius);
	float lifeScale = cb.lifeScaleFromDistance.evaluate(8, distance);

	float maxLife = nextRand(rng) * 5.f * lifeScale + 3.f;

	float angle = nextRand(rng) * 2.f * M_PI;
	float sinAngle, cosAngle;
	sincos(angle, sinAngle, cosAngle);

	particle_data particle = {
		position,
		packHalfs(maxLife, maxLife),
		velocity,
		packHalfs(sinAngle, cosAngle)
	};

	return particle;
}

static bool simulateParticle(inout particle_data particle, float dt, out float sortKey)
{
	float life = unpackHalfsRight(particle.maxLife_life);
	life -= dt;
	if (life <= 0)
	{
		sortKey = 0;
		return false;
	}
	else
	{
		float3 gravity = float3(0.f, -1.f * dt, 0.f);
		particle.position = particle.position + 0.5f * gravity * dt + particle.velocity * dt;
		particle.velocity = particle.velocity + gravity;
		float maxLife = unpackHalfsLeft(particle.maxLife_life);
		particle.maxLife_life = packHalfs(maxLife, life);

		float3 V = particle.position - cb.cameraPosition;
		sortKey = dot(V, V);

		return true;
	}
}

#endif




#ifdef PARTICLE_RENDERING

#define USER_PARTICLE_RENDERING_RS \
    "CBV(b0, visibility=SHADER_VISIBILITY_VERTEX), " \
    "CBV(b1, visibility=SHADER_VISIBILITY_VERTEX), " \
	"DescriptorTable(SRV(t0, numDescriptors=1), visibility=SHADER_VISIBILITY_PIXEL), " \
	"StaticSampler(s0," \
        "addressU = TEXTURE_ADDRESS_WRAP," \
        "addressV = TEXTURE_ADDRESS_WRAP," \
        "addressW = TEXTURE_ADDRESS_WRAP," \
        "filter = FILTER_MIN_MAG_MIP_LINEAR," \
        "visibility=SHADER_VISIBILITY_PIXEL)"


struct vs_input
{
	float3 position			: POSITION;
};

struct vs_output
{
	float intensity : INTENSITY;
	float2 uv				: TEXCOORDS;
	float4 position			: SV_Position;
};

ConstantBuffer<smoke_rendering_cb> cb	: register(b0);
ConstantBuffer<camera_cb> camera		: register(b1);

Texture2D<float4> tex					: register(t0);
SamplerState texSampler					: register(s0);


static vs_output vertexShader(vs_input IN, StructuredBuffer<particle_data> particles, uint index)
{
	float3 pos = particles[index].position;

	uint maxLife_life = particles[index].maxLife_life;
	float life = unpackHalfsRight(maxLife_life);
	float maxLife = unpackHalfsLeft(maxLife_life);
	float relLife = clamp(1.f - life / maxLife, 0.01f, 0.99f);

	float2 rotation; // Sin(angle), cos(angle).
	unpackHalfs(particles[index].sinAngle_cosAngle, rotation.x, rotation.y);

	float2 localPosition = IN.position.xy * 1.f;
	localPosition = float2(dot(localPosition, float2(rotation.y, -rotation.x)), dot(localPosition, rotation));
	pos += localPosition.x * camera.right.xyz + localPosition.y * camera.up.xyz;

	texture_atlas_cb atlas = cb.atlas;
	uint atlasIndex = cb.atlasProgressionOverLifetime.evaluate(4, relLife) * (atlas.getTotalNumCells() - 1);
	uint x = atlas.getX(atlasIndex);
	uint y = atlas.getY(atlasIndex);

	float invCols = atlas.getInvNumCols();
	float invRows = atlas.getInvNumRows();
	float2 uv0 = float2(x * invCols, y * invRows);
	float2 uv1 = float2((x + 1) * invCols, (y + 1) * invRows);


	vs_output OUT;
	OUT.position = mul(camera.viewProj, float4(pos, 1.f));
	OUT.uv = lerp(uv0, uv1, IN.position.xy * 0.5f + 0.5f);
	OUT.intensity = 10.f;// cb.intensityOverLifetime.evaluate(4, relLife);
	return OUT;
}

static float4 pixelShader(vs_output IN)
{
	float4 color = tex.Sample(texSampler, IN.uv);
	color.rgb *= IN.intensity;
	return color;
}

#endif


// Simulation.
#define SMOKE_PARTICLE_SYSTEM_COMPUTE_RS_CBV		0

// Rendering.
#define SMOKE_PARTICLE_SYSTEM_RENDERING_RS_CBV		0
#define SMOKE_PARTICLE_SYSTEM_RENDERING_RS_CAMERA	1
#define SMOKE_PARTICLE_SYSTEM_RENDERING_RS_TEXTURE	2



```

`shaders/particles/particle_emit.hlsli`:

```hlsli
#include "cs.hlsli"
#include "particles_rs.hlsli"

ConstantBuffer<particle_start_cb> simCB					: register(b0, space1);

RWStructuredBuffer<particle_draw> drawInfo				: register(u1, space1);
RWStructuredBuffer<particle_counters> counters			: register(u2, space1);

RWStructuredBuffer<particle_data> particles				: register(u3, space1);
RWStructuredBuffer<uint> deadList						: register(u4, space1);
RWStructuredBuffer<uint> currentAliveList				: register(u5, space1);


[numthreads(PARTICLES_EMIT_BLOCK_SIZE, 1, 1)]
[RootSignature(PARTICLE_START_RS)]
void main(cs_input IN)
{
	const uint i = IN.dispatchThreadID.x;
	const uint count = counters[0].newParticles;
	if (i >= count)
	{
		return;
	}

	uint dead;
	InterlockedAdd(counters[0].numDeadParticles, -1, dead);
	
	uint index = deadList[dead - 1];

	particles[index] = emitParticle(i);

	uint alive;
	InterlockedAdd(counters[0].numAliveParticlesThisFrame, 1, alive);

	currentAliveList[alive] = index;
}

```

`shaders/particles/particle_ps.hlsli`:

```hlsli
#include "particles_rs.hlsli"

[RootSignature(PARTICLES_RENDERING_RS)]
float4 main(vs_output IN) : SV_TARGET
{
	return pixelShader(IN);
}

```

`shaders/particles/particle_sim.hlsli`:

```hlsli
#include "cs.hlsli"
#include "particles_rs.hlsli"

ConstantBuffer<particle_sim_cb> simCB					: register(b0, space1);

RWStructuredBuffer<particle_draw> drawInfo				: register(u1, space1);
RWStructuredBuffer<particle_counters> counters			: register(u2, space1);

RWStructuredBuffer<particle_data> particles				: register(u3, space1);
RWStructuredBuffer<uint> deadList						: register(u4, space1);
RWStructuredBuffer<uint> currentAliveList				: register(u5, space1);
RWStructuredBuffer<uint> newAliveList					: register(u6, space1);

#ifdef REQUIRES_SORTING
RWStructuredBuffer<float> sortKeys						: register(u7, space1);
#endif



[numthreads(PARTICLES_SIMULATE_BLOCK_SIZE, 1, 1)]
[RootSignature(PARTICLE_SIM_RS)]
void main(cs_input IN)
{
	const uint i = IN.dispatchThreadID.x;
	const uint count = counters[0].numAliveParticlesThisFrame;
	if (i >= count)
	{
		return;
	}

	float dt = simCB.dt;

	uint index = currentAliveList[i];

	particle_data particle = particles[index];

#ifdef REQUIRES_SORTING
	float sortKey;
	bool shouldLive = simulateParticle(particle, dt, sortKey);
#else
	bool shouldLive = simulateParticle(particle, dt);
#endif

	if (shouldLive)
	{
		particles[index] = particle;

		uint alive;
		InterlockedAdd(drawInfo[0].arguments.InstanceCount, 1, alive);
		newAliveList[alive] = index;

#ifdef REQUIRES_SORTING
		sortKeys[alive] = sortKey;
#endif
	}
	else
	{
		uint dead;
		InterlockedAdd(counters[0].numDeadParticles, 1, dead);
		deadList[dead] = index;
	}
}

```

`shaders/particles/particle_start_cs.hlsl`:

```hlsl
#include "cs.hlsli"
#include "particles_rs.hlsli"

ConstantBuffer<particle_start_cb> cb					: register(b0, space1);

RWStructuredBuffer<particle_dispatch> dispatchInfo		: register(u0, space1);
RWStructuredBuffer<particle_draw> drawInfo				: register(u1, space1);
RWStructuredBuffer<particle_counters> counters			: register(u2, space1);


static uint bucketize(uint problemSize, uint bucketSize) 
{ 
	return (problemSize + bucketSize - 1) / bucketSize; 
}


[numthreads(1, 1, 1)]
[RootSignature(PARTICLE_START_RS)]
void main(cs_input IN)
{
	particle_counters c = counters[0];
	particle_draw draw = drawInfo[0];
	particle_dispatch dispatch = dispatchInfo[0];

	c.emitRateAccum += cb.newParticlesRequest; // TODO: How do we prevent this from running to infinity, if the system is saturated?

	uint spaceLeft = c.numDeadParticles;
	uint numNewParticles = min((uint)c.emitRateAccum, spaceLeft);

	c.emitRateAccum -= numNewParticles;

	uint numAliveParticlesInLastFrame = draw.arguments.InstanceCount;

	dispatch.emit.ThreadGroupCountX = bucketize(numNewParticles, PARTICLES_EMIT_BLOCK_SIZE);
	dispatch.emit.ThreadGroupCountY = 1;
	dispatch.emit.ThreadGroupCountZ = 1;

	dispatch.simulate.ThreadGroupCountX = bucketize(numAliveParticlesInLastFrame + numNewParticles, PARTICLES_SIMULATE_BLOCK_SIZE);
	dispatch.simulate.ThreadGroupCountY = 1;
	dispatch.simulate.ThreadGroupCountZ = 1;

	c.numAliveParticlesThisFrame = numAliveParticlesInLastFrame;
	draw.arguments.InstanceCount = 0;
	draw.arguments.IndexCountPerInstance = cb.indexCount;
	draw.arguments.StartIndexLocation = cb.startIndex;
	draw.arguments.BaseVertexLocation = cb.baseVertex;
	c.newParticles = numNewParticles;

	dispatchInfo[0] = dispatch;
	drawInfo[0] = draw;
	counters[0] = c;
}

```

`shaders/particles/particle_vs.hlsli`:

```hlsli
#include "particles_rs.hlsli"

StructuredBuffer<particle_data> particles			: register(t0, space1);
StructuredBuffer<uint> aliveList					: register(t1, space1);


vs_output main(vs_input IN, uint instanceID	: SV_InstanceID)
{
	uint index = aliveList[instanceID];
	return vertexShader(IN, particles, index);
}

```

`shaders/post_processing/blit_cs.hlsl`:

```hlsl
#include "post_processing_rs.hlsli"
#include "cs.hlsli"

ConstantBuffer<blit_cb> cb				: register(b0);
RWTexture2D<float4> output				: register(u0);
Texture2D<float4> input					: register(t0);
SamplerState linearClampSampler			: register(s0);

[numthreads(POST_PROCESSING_BLOCK_SIZE, POST_PROCESSING_BLOCK_SIZE, 1)]
[RootSignature(BLIT_RS)]
void main(cs_input IN)
{
	const float2 uv = (IN.dispatchThreadID.xy + float2(0.5f, 0.5f)) * cb.invDimensions;
	output[IN.dispatchThreadID.xy] = input.SampleLevel(linearClampSampler, uv, 0);
}

```

`shaders/post_processing/bloom_combine_cs.hlsl`:

```hlsl
#include "post_processing_rs.hlsli"
#include "cs.hlsli"

ConstantBuffer<bloom_combine_cb> cb		: register(b0);

RWTexture2D<float4> output				: register(u0);
Texture2D<float4> scene					: register(t0);
Texture2D<float4> bloom					: register(t1);

SamplerState linearClampSampler			: register(s0);


[numthreads(POST_PROCESSING_BLOCK_SIZE, POST_PROCESSING_BLOCK_SIZE, 1)]
[RootSignature(BLOOM_COMBINE_RS)]
void main(cs_input IN)
{
	const float2 uv = (IN.dispatchThreadID.xy + float2(0.5f, 0.5f)) * cb.invDimensions;

	float3 color = (float3)0.f;

	color += bloom.SampleLevel(linearClampSampler, uv, 1.5f).rgb;
	color += bloom.SampleLevel(linearClampSampler, uv, 3.5f).rgb;
	color += bloom.SampleLevel(linearClampSampler, uv, 4.5f).rgb;

	color /= 3.f;

	color *= cb.strength;

	output[IN.dispatchThreadID.xy] = float4(scene[IN.dispatchThreadID.xy].rgb + color, 1.f);
}

```

`shaders/post_processing/bloom_threshold_cs.hlsl`:

```hlsl
#include "post_processing_rs.hlsli"
#include "cs.hlsli"

ConstantBuffer<bloom_threshold_cb> cb	: register(b0);

RWTexture2D<float4> output				: register(u0);
Texture2D<float4> input					: register(t0);

SamplerState linearClampSampler			: register(s0);


[numthreads(POST_PROCESSING_BLOCK_SIZE, POST_PROCESSING_BLOCK_SIZE, 1)]
[RootSignature(BLOOM_THRESHOLD_RS)]
void main(cs_input IN)
{
	const float2 uv = IN.dispatchThreadID.xy + float2(0.5f, 0.5f);

	float3 color = (float3)0.f;

	const float2 invDimensions = cb.invDimensions;
	const float offset = 0.25f;
	color += input.SampleLevel(linearClampSampler, (uv + float2(-offset, -offset)) * invDimensions, 0).rgb;
	color += input.SampleLevel(linearClampSampler, (uv + float2(offset, -offset)) * invDimensions, 0).rgb;
	color += input.SampleLevel(linearClampSampler, (uv + float2(-offset, offset)) * invDimensions, 0).rgb;
	color += input.SampleLevel(linearClampSampler, (uv + float2(offset, offset)) * invDimensions, 0).rgb;

	color *= 0.25f;
	color = max(0, color - cb.threshold.xxx);

	output[IN.dispatchThreadID.xy] = float4(color, 1.f);
}

```

`shaders/post_processing/depth_sobel_cs.hlsl`:

```hlsl
#include "cs.hlsli"
#include "post_processing_rs.hlsli"
#include "camera.hlsli"


ConstantBuffer<depth_sobel_cb> cb	: register(b0);
RWTexture2D<float> output			: register(u0);
Texture2D<float> input				: register(t0);

[numthreads(POST_PROCESSING_BLOCK_SIZE, POST_PROCESSING_BLOCK_SIZE, 1)]
[RootSignature(DEPTH_SOBEL_RS)]
void main(cs_input IN)
{
	int2 xy = IN.dispatchThreadID.xy;

	float tl = depthBufferDepthToEyeDepth(input[xy + int2(-1, -1)], cb.projectionParams);
	float t  = depthBufferDepthToEyeDepth(input[xy + int2(0, -1)], cb.projectionParams);
	float tr = depthBufferDepthToEyeDepth(input[xy + int2(1, -1)], cb.projectionParams);
	float l  = depthBufferDepthToEyeDepth(input[xy + int2(-1, 0)], cb.projectionParams);
	float r  = depthBufferDepthToEyeDepth(input[xy + int2(1, 0)], cb.projectionParams);
	float bl = depthBufferDepthToEyeDepth(input[xy + int2(-1, 1)], cb.projectionParams);
	float b  = depthBufferDepthToEyeDepth(input[xy + int2(0, 1)], cb.projectionParams);
	float br = depthBufferDepthToEyeDepth(input[xy + int2(1, 1)], cb.projectionParams);

	float horizontal = abs((tl + 2.f * t + tr) - (bl + 2.f * b + br));
	float vertical   = abs((tl + 2.f * l + bl) - (tr + 2.f * r + br));

	float edge = (horizontal > cb.threshold || vertical > cb.threshold) ? 1.f : 0.f;
	output[xy] = edge;
}


```

`shaders/post_processing/dilation_cs.hlsl`:

```hlsl
#define OP max
#define NULL_VALUE 0.f
#include "morphology_common.hlsli"

```

`shaders/post_processing/erosion_cs.hlsl`:

```hlsl
#define OP min
#define NULL_VALUE 3.402823466e+38F
#include "morphology_common.hlsli"

```

`shaders/post_processing/gaussian_blur_13x13_float4_cs.hlsl`:

```hlsl

#ifndef DATA_T
#define DATA_T float4
#endif

#define NUM_WEIGHTS 4

static const float kernelOffsets[4] = { 0.f, 1.411764705882353f, 3.2941176470588234f, 5.176470588235294f };
static const float blurWeights[4] = { 0.1964825501511404f, 0.2969069646728344f, 0.09447039785044732f, 0.010381362401148057f };

#include "gaussian_blur_common.hlsli"

```

`shaders/post_processing/gaussian_blur_13x13_float_cs.hlsl`:

```hlsl

#define DATA_T float
#include "gaussian_blur_13x13_float4_cs.hlsl"

```

`shaders/post_processing/gaussian_blur_5x5_float4_cs.hlsl`:

```hlsl

#ifndef DATA_T
#define DATA_T float4
#endif

#define NUM_WEIGHTS 2

static const float kernelOffsets[2] = { 0.f, 1.33333333333333f };
static const float blurWeights[2] = { 0.29411764705882354f, 0.35294117647058826f };

#include "gaussian_blur_common.hlsli"

```

`shaders/post_processing/gaussian_blur_5x5_float_cs.hlsl`:

```hlsl

#define DATA_T float
#include "gaussian_blur_5x5_float4_cs.hlsl"

```

`shaders/post_processing/gaussian_blur_9x9_float4_cs.hlsl`:

```hlsl

#ifndef DATA_T
#define DATA_T float4
#endif

#define NUM_WEIGHTS 3

static const float kernelOffsets[3] = { 0.f, 1.3846153846f, 3.2307692308f };
static const float blurWeights[3] = { 0.2270270270f, 0.3162162162f, 0.0702702703f };

#include "gaussian_blur_common.hlsli"

```

`shaders/post_processing/gaussian_blur_9x9_float_cs.hlsl`:

```hlsl

#define DATA_T float
#include "gaussian_blur_9x9_float4_cs.hlsl"

```

`shaders/post_processing/gaussian_blur_common.hlsli`:

```hlsli
#include "cs.hlsli"
#include "post_processing_rs.hlsli"

ConstantBuffer<gaussian_blur_cb> cb	    : register(b0);

Texture2D<DATA_T> input		            : register(t0);
RWTexture2D<DATA_T> output		        : register(u0);
SamplerState linearClampSampler         : register(s0);


[RootSignature(GAUSSIAN_BLUR_RS)]
[numthreads(POST_PROCESSING_BLOCK_SIZE, POST_PROCESSING_BLOCK_SIZE, 1)]
void main(cs_input IN)
{
    float2 uv = (IN.dispatchThreadID.xy + float2(0.5f, 0.5f)) * cb.invDimensions;

    uint directionIndex = cb.directionAndSourceMipLevel >> 16;
    float2 direction = (directionIndex == 0) ? float2(1.f, 0.f) : float2(0.f, 1.f);
    direction *= cb.invDimensions;
    direction *= cb.stepScale;

    uint sourceMipLevel = cb.directionAndSourceMipLevel & 0xFFFF;
    DATA_T color = input.SampleLevel(linearClampSampler, uv, sourceMipLevel) * blurWeights[0];

    [unroll]
    for (int i = 1; i < NUM_WEIGHTS; ++i)
    {
        float2 normalizedOffset = kernelOffsets[i] * direction;
        color += input.SampleLevel(linearClampSampler, uv + normalizedOffset, sourceMipLevel) * blurWeights[i];
        color += input.SampleLevel(linearClampSampler, uv - normalizedOffset, sourceMipLevel) * blurWeights[i];
    }

    output[IN.dispatchThreadID.xy] = color;
}

```

`shaders/post_processing/hbao_cs.hlsl`:

```hlsl
#include "cs.hlsli"
#include "post_processing_rs.hlsli"
#include "camera.hlsli"
#include "random.hlsli"

// This file is based on https://github.com/scanberg/hbao

ConstantBuffer<hbao_cb> cb				: register(b0);
ConstantBuffer<camera_cb> camera		: register(b1);

Texture2D<float> depthBuffer			: register(t0);

RWTexture2D<float> resultTexture		: register(u0);

SamplerState linearSampler				: register(s0);

static float3 positionAt(float2 uv)
{
	float depth = depthBuffer.SampleLevel(linearSampler, uv, cb.depthBufferMipLevel);
	float3 pos = camera.restoreViewSpacePositionEyeDepth(uv, depth);
	return pos;
}

static float length2(float3 v)
{
	return dot(v, v);
}

static float3 minDiff(float3 P, float3 right, float3 left)
{
	float3 V1 = right - P;
	float3 V2 = P - left;
	return (length2(V1) < length2(V2)) ? V1 : V2;
}

static float2 rotateDirections(float2 dir, float2 cosSin)
{
	return float2(dir.x * cosSin.x - dir.y * cosSin.y,
		dir.x * cosSin.y + dir.y * cosSin.x);
}

static float2 snapUVOffset(float2 uv, float2 dims, float2 invDims)
{
	return round(uv * dims) * invDims;
}

static float tanToSin(float x)
{
	return x * rsqrt(x * x + 1.f);
}

static float invLength(float2 v)
{
	return rsqrt(dot(v, v));
}

static const float tanBias = tan(30.f * M_PI / 180.f);
static float biasedTangent(float3 v)
{
	return v.z * invLength(v.xy) + tanBias;
}

static float tangent(float3 P, float3 S)
{
	return -(P.z - S.z) * invLength(S.xy - P.xy);
}

static float falloff(float d2, float negInvRadius2)
{
	return d2 * negInvRadius2 + 1.f;
}

static float horizonOcclusion(float2 centerUV, float2 deltaUV, float3 P, 
	float3 dPdu, float3 dPdv, float jitter, float numSamples,
	float radius2, float negInvRadius2,
	float2 dims, float2 invDims)
{
	// Offset the first coord with some noise.
	float2 uv = centerUV + snapUVOffset(jitter * deltaUV, dims, invDims);
	deltaUV = snapUVOffset(deltaUV, dims, invDims);

	// Calculate the tangent vector.
	float3 T = deltaUV.x * dPdu + deltaUV.y * dPdv;

	// Get the angle of the tangent vector from the viewspace axis.
	float tanH = biasedTangent(T);
	float sinH = tanToSin(tanH);

	float ao = 0.f;

	// Sample to find the maximum angle
	for (float s = 0; s < numSamples; ++s)
	{
		uv += deltaUV;
		float3 S = positionAt(uv);
		float tanS = tangent(P, S);
		float d2 = length2(S - P);

		// Is the sample within the radius and the angle greater?
		if (d2 < radius2 && tanS > tanH)
		{
			float sinS = tanToSin(tanS);
			// Apply falloff based on the distance.
			ao += falloff(d2, negInvRadius2) * (sinS - sinH);

			tanH = tanS;
			sinH = sinS;
		}
	}

	return ao;
}

[RootSignature(HBAO_RS)]
[numthreads(POST_PROCESSING_BLOCK_SIZE, POST_PROCESSING_BLOCK_SIZE, 1)]
void main(cs_input IN)
{
	if (IN.dispatchThreadID.x >= cb.screenWidth || IN.dispatchThreadID.y >= cb.screenHeight) 
	{
		return;
	}

	float2 screenDims = float2(cb.screenWidth, cb.screenHeight);
	float2 invScreenDims = rcp(screenDims);

	float2 centerUV = (IN.dispatchThreadID.xy + float2(0.5f, 0.5f)) * invScreenDims;
	float3 centerPos = positionAt(centerUV);

	if (centerPos.z < -1000.f)
	{
		resultTexture[IN.dispatchThreadID.xy] = 1.f;
		return;
	}

	float3 rightPos = positionAt(centerUV + float2(invScreenDims.x, 0.f));
	float3 leftPos = positionAt(centerUV - float2(invScreenDims.x, 0.f));
	float3 topPos = positionAt(centerUV - float2(0.f, invScreenDims.y));
	float3 bottomPos = positionAt(centerUV + float2(0.f, invScreenDims.y));

	float3 dPdu = minDiff(centerPos, rightPos, leftPos);
	float3 dPdv = minDiff(centerPos, bottomPos, topPos) * (screenDims.y * invScreenDims.x);

	float2 rayRadiusUV = 0.5f * cb.radius * camera.proj._m00_m11 / -centerPos.z;

	float rayRadiusPix = rayRadiusUV.x * screenDims.x;


	float ao = 1.f;

	if (rayRadiusPix > 1.f)
	{
		ao = 0.f;

		float jitter = random(centerUV * 9523.f + cb.seed) * 0.4f;

		// Compute steps.
		float numSteps = min((float)cb.maxNumStepsPerRay, rayRadiusPix);

		// Divide by Ns+1 so that the farthest samples are not fully attenuated.
		float stepSizePix = rayRadiusPix / (numSteps + 1);

		// Clamp numSteps if it is greater than the max kernel footprint.
		float maxNumSteps = cb.maxNumStepsPerRay / stepSizePix;
		if (maxNumSteps < numSteps)
		{
			// Use dithering to avoid AO discontinuities.
			numSteps = floor(maxNumSteps + jitter);
			numSteps = max(numSteps, 1);
			stepSizePix = cb.maxNumStepsPerRay / numSteps;
		}

		float2 stepSizeUV = stepSizePix * invScreenDims;


		float angle = random(centerUV * 5416.f + cb.seed) * M_PI * 2.f;
		float2 randomRotation = float2(cos(angle), sin(angle)); // TODO: Maybe get this from texture.

		// Apply noise to initial rotation.
		float2 dir = rotateDirections(float2(1.f, 0.f), randomRotation);

		float2 rayDeltaRotation = cb.rayDeltaRotation;

		float radius2 = cb.radius * cb.radius;
		float negInvRadius2 = rcp(radius2);

		for (float d = 0; d < (float)cb.numRays; d += 1.f)
		{
			float2 deltaUV = dir * stepSizeUV;

			// Sample the pixels along the direction.
			ao += horizonOcclusion(
				centerUV, deltaUV,
				centerPos,
				dPdu, dPdv,
				jitter, numSteps,
				radius2, negInvRadius2,
				screenDims, invScreenDims);

			dir = rotateDirections(dir, rayDeltaRotation);
		}

		// Average the results and produce the final AO.
		ao = saturate(1.f - ao / cb.numRays * cb.strength);
	}

	resultTexture[IN.dispatchThreadID.xy] = ao;
}

```

`shaders/post_processing/hierarchical_linear_depth_cs.hlsl`:

```hlsl
#include "cs.hlsli"
#include "post_processing_rs.hlsli"
#include "camera.hlsli"

// This shader outputs the depth in world units!

ConstantBuffer<hierarchical_linear_depth_cb> cb	    : register(b0);

RWTexture2D<float> outputMip0						: register(u0);
RWTexture2D<float> outputMip1						: register(u1);
RWTexture2D<float> outputMip2						: register(u2);
RWTexture2D<float> outputMip3						: register(u3);
RWTexture2D<float> outputMip4						: register(u4);
RWTexture2D<float> outputMip5						: register(u5);

Texture2D<float> input								: register(t0);

SamplerState linearClampSampler						: register(s0);



groupshared float tile[POST_PROCESSING_BLOCK_SIZE][POST_PROCESSING_BLOCK_SIZE];


[RootSignature(HIERARCHICAL_LINEAR_DEPTH_RS)]
[numthreads(POST_PROCESSING_BLOCK_SIZE, POST_PROCESSING_BLOCK_SIZE, 1)]
void main(cs_input IN)
{
	const uint2 groupThreadID = IN.groupThreadID.xy;
	const uint2 dispatchThreadID = IN.dispatchThreadID.xy;


#if 0
	float2 uv = (dispatchThreadID + float2(0.7f, 0.7f)) * cb.invDimensions;
	float4 depths = input.Gather(linearClampSampler, uv);
	depths = depths.wzxy; // This brings it into the same order as the variant below. See https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/gather4--sm5---asm-
#else
	float4 depths = float4(
		input[dispatchThreadID * 2 + uint2(0, 0)],
		input[dispatchThreadID * 2 + uint2(1, 0)],
		input[dispatchThreadID * 2 + uint2(0, 1)],
		input[dispatchThreadID * 2 + uint2(1, 1)]
	);
#endif
	float maxdepth = max(depths.x, max(depths.y, max(depths.z, depths.w)));
	tile[groupThreadID.x][groupThreadID.y] = maxdepth;

	GroupMemoryBarrierWithGroupSync();

	if (groupThreadID.x % 2 == 0 && groupThreadID.y % 2 == 0)
	{
		maxdepth = max(tile[groupThreadID.x][groupThreadID.y], 
			max(tile[groupThreadID.x + 1][groupThreadID.y], 
			max(tile[groupThreadID.x][groupThreadID.y + 1], 
				tile[groupThreadID.x + 1][groupThreadID.y + 1])));
		tile[groupThreadID.x][groupThreadID.y] = maxdepth;
	}
	GroupMemoryBarrierWithGroupSync();



	const float4 lineardepths = float4
	(
		depthBufferDepthToEyeDepth(depths.x, cb.projectionParams),
		depthBufferDepthToEyeDepth(depths.y, cb.projectionParams),
		depthBufferDepthToEyeDepth(depths.z, cb.projectionParams),
		depthBufferDepthToEyeDepth(depths.w, cb.projectionParams)
	);

	outputMip0[dispatchThreadID * 2 + uint2(0, 0)] = lineardepths.x;
	outputMip0[dispatchThreadID * 2 + uint2(1, 0)] = lineardepths.y;
	outputMip0[dispatchThreadID * 2 + uint2(0, 1)] = lineardepths.z;
	outputMip0[dispatchThreadID * 2 + uint2(1, 1)] = lineardepths.w;

	maxdepth = max(lineardepths.x, max(lineardepths.y, max(lineardepths.z, lineardepths.w)));
	tile[groupThreadID.x][groupThreadID.y] = maxdepth;
	outputMip1[dispatchThreadID] = maxdepth;
	GroupMemoryBarrierWithGroupSync();

	if (groupThreadID.x % 2 == 0 && groupThreadID.y % 2 == 0)
	{
		maxdepth = max(tile[groupThreadID.x][groupThreadID.y], max(tile[groupThreadID.x + 1][groupThreadID.y], max(tile[groupThreadID.x][groupThreadID.y + 1], tile[groupThreadID.x + 1][groupThreadID.y + 1])));
		tile[groupThreadID.x][groupThreadID.y] = maxdepth;
		outputMip2[dispatchThreadID / 2] = maxdepth;
	}
	GroupMemoryBarrierWithGroupSync();

	if (groupThreadID.x % 4 == 0 && groupThreadID.y % 4 == 0)
	{
		maxdepth = max(tile[groupThreadID.x][groupThreadID.y], max(tile[groupThreadID.x + 2][groupThreadID.y], max(tile[groupThreadID.x][groupThreadID.y + 2], tile[groupThreadID.x + 2][groupThreadID.y + 2])));
		tile[groupThreadID.x][groupThreadID.y] = maxdepth;
		outputMip3[dispatchThreadID / 4] = maxdepth;
	}
	GroupMemoryBarrierWithGroupSync();

	if (groupThreadID.x % 8 == 0 && groupThreadID.y % 8 == 0)
	{
		maxdepth = max(tile[groupThreadID.x][groupThreadID.y], max(tile[groupThreadID.x + 4][groupThreadID.y], max(tile[groupThreadID.x][groupThreadID.y + 4], tile[groupThreadID.x + 4][groupThreadID.y + 4])));
		tile[groupThreadID.x][groupThreadID.y] = maxdepth;
		outputMip4[dispatchThreadID / 8] = maxdepth;
	}
	GroupMemoryBarrierWithGroupSync();

	if (groupThreadID.x % 16 == 0 && groupThreadID.y % 16 == 0)
	{
		maxdepth = max(tile[groupThreadID.x][groupThreadID.y], max(tile[groupThreadID.x + 8][groupThreadID.y], max(tile[groupThreadID.x][groupThreadID.y + 8], tile[groupThreadID.x + 8][groupThreadID.y + 8])));
		outputMip5[dispatchThreadID / 16] = maxdepth;
	}
}

```

`shaders/post_processing/morphology_common.hlsli`:

```hlsli
#include "cs.hlsli"
#include "post_processing_rs.hlsli"

#ifndef DATA_TYPE
#define DATA_TYPE float
#endif

#define MAX_SHARED_MEM_WIDTH (MORPHOLOGY_BLOCK_SIZE + MORPHOLOGY_MAX_RADIUS * 2)

ConstantBuffer<morphology_cb> cb	: register(b0);
RWTexture2D<DATA_TYPE> output		: register(u0);
Texture2D<DATA_TYPE> input			: register(t0);

groupshared DATA_TYPE g_values[MAX_SHARED_MEM_WIDTH];

[numthreads(MORPHOLOGY_BLOCK_SIZE, 1, 1)]
[RootSignature(MORPHOLOGY_RS)]
void main(cs_input IN)
{
	const int direction = cb.direction;
	const int radius = cb.radius;
	const int dimInDirection = cb.dimInDirection;
	const int actualSharedMemoryWidth = MORPHOLOGY_BLOCK_SIZE + radius * 2;

	const int y = IN.dispatchThreadID.y;
	const int tileStart = IN.groupID.x * MORPHOLOGY_BLOCK_SIZE;
	const int paddedTileStart = tileStart - radius;

	const int blockOverlapLeft = -min(paddedTileStart, 0);
	const int blockEnd = actualSharedMemoryWidth - 1;
	const int blockOverlapRight = max(paddedTileStart + blockEnd + 1 - dimInDirection, 0);

	for (int t = IN.groupIndex + blockOverlapLeft; t <= blockEnd - blockOverlapRight; t += MORPHOLOGY_BLOCK_SIZE)
	{
		int x = paddedTileStart + t;
		int2 pos = int2(x, y);
		pos = (direction == 0) ? pos.xy : pos.yx;
		g_values[t] = input[pos];
	}

	GroupMemoryBarrierWithGroupSync();



	DATA_TYPE value = NULL_VALUE;

	const int globalStart = IN.dispatchThreadID.x - radius;
	const int overlapLeft = -min(globalStart, 0);

	const int globalEnd = IN.dispatchThreadID.x + radius;
	const int overlapRight = max(globalEnd + 1 - dimInDirection, 0);

	const int start = IN.groupIndex + overlapLeft;
	const int end = IN.groupIndex + radius * 2 - overlapRight;
	for (int i = start; i <= end; ++i)
	{
		value = OP(value, g_values[i]);
	}

	int2 outPos = IN.dispatchThreadID.xy;
	outPos = (direction == 0) ? outPos.xy : outPos.yx;
	output[outPos] = value;
}




```

`shaders/post_processing/present_cs.hlsl`:

```hlsl
#include "cs.hlsli"
#include "post_processing_rs.hlsli"
#include "color.hlsli"


ConstantBuffer<present_cb> present	: register(b0);
RWTexture2D<float4> output	: register(u0);
Texture2D<float4>	input	: register(t0);




[numthreads(POST_PROCESSING_BLOCK_SIZE, POST_PROCESSING_BLOCK_SIZE, 1)]
[RootSignature(PRESENT_RS)]
void main(cs_input IN)
{
	int xOffset = present.offset >> 16;
	int yOffset = present.offset & 0xFFFF;

	int2 center = IN.dispatchThreadID.xy - int2(xOffset, yOffset);

	float3 scene = input[center + int2(0, 0)].rgb;

	if (present.sharpenStrength > 0.f)
	{
		float3 top = input[center + int2(0, -1)].rgb;
		float3 left = input[center + int2(-1, 0)].rgb;
		float3 right = input[center + int2(1, 0)].rgb;
		float3 bottom = input[center + int2(0, 1)].rgb;

		scene = max(scene + (4.f * scene - top - bottom - left - right) * present.sharpenStrength, 0.f);
	}

	if (present.displayMode == present_sdr)
	{
		scene = linearToSRGB(scene);
	}
	else if (present.displayMode == present_hdr)
	{
		const float st2084max = 10000.f;
		const float hdrScalar = present.standardNits / st2084max;

		// The HDR scene is in Rec.709, but the display is Rec.2020.
		scene = rec709ToRec2020(scene);

		// Apply the ST.2084 curve to the scene.
		scene = linearToST2084(scene * hdrScalar);
	}

	output[IN.dispatchThreadID.xy] = float4(scene, 1.f);
}

```

`shaders/post_processing/shadow_blur_common.hlsli`:

```hlsli

ConstantBuffer<shadow_blur_cb> cb		: register(b0);

Texture2D<float> input		            : register(t0); // Usually half res in horizontal pass, full res in vertical pass.
Texture2D<float> depthBuffer            : register(t1); // Full res.

RWTexture2D<float> output	            : register(u0); // Full res.

SamplerState pointSampler				: register(s0);
SamplerState linearSampler				: register(s1);

#define KERNEL_RADIUS 8.f

// https://developer.nvidia.com/sites/default/files/akamai/gamedev/files/gdc12/GDC12_Bavoil_Stable_SSAO_In_BF3_With_STF.pdf
static float crossBilateralWeight(float offset, float depth, float centerDepth)
{
	const float sigma = (KERNEL_RADIUS + 1.f) * 0.5f;
	const float falloff = 1.f / (2.f * sigma * sigma);

	float dz = centerDepth - depth;
	return exp2(-offset * offset * falloff - dz * dz);
}

static void accumulate(float2 uv, float offset, float centerDepth, inout float total, inout float totalWeight)
{
	float value = input.SampleLevel(linearSampler, uv, 0);
	float depth = depthBuffer.SampleLevel(pointSampler, uv, 0);

	float weight = crossBilateralWeight(offset, depth, centerDepth);

	total += value * weight;
	totalWeight += weight;
}

static float blur(float2 direction, uint2 dispatchThreadID)
{
	direction *= cb.invDimensions;
	float2 centerUV = (dispatchThreadID + float2(0.5f, 0.5f)) * cb.invDimensions;

	float value = input.SampleLevel(linearSampler, centerUV, 0);
#if 1
	float depth = depthBuffer.SampleLevel(pointSampler, centerUV, 0);

	float total = value;
	float totalWeight = 1.f;

	float i = 1.f;
	for (; i <= KERNEL_RADIUS * 0.5f; i += 1.f)
	{
		accumulate(centerUV + i * direction, i, depth, total, totalWeight);
		accumulate(centerUV - i * direction, -i, depth, total, totalWeight);
	}

	for (; i <= KERNEL_RADIUS; i += 2.f)
	{
		accumulate(centerUV + (i + 0.5f) * direction, i, depth, total, totalWeight);
		accumulate(centerUV - (i + 0.5f) * direction, -i, depth, total, totalWeight);
	}

	value = total / totalWeight;
#endif
	return value;
}

```

`shaders/post_processing/shadow_blur_x_cs.hlsl`:

```hlsl
#include "cs.hlsli"
#include "post_processing_rs.hlsli"
#include "shadow_blur_common.hlsli"

[RootSignature(SHADOW_BLUR_X_RS)]
[numthreads(POST_PROCESSING_BLOCK_SIZE, POST_PROCESSING_BLOCK_SIZE, 1)]
void main(cs_input IN)
{
	float value = blur(float2(1.f, 0.f), IN.dispatchThreadID.xy);
	output[IN.dispatchThreadID.xy] = value;
}

```

`shaders/post_processing/shadow_blur_y_cs.hlsl`:

```hlsl
#include "cs.hlsli"
#include "post_processing_rs.hlsli"
#include "shadow_blur_common.hlsli"
#include "math.hlsli"

Texture2D<float2> motion            : register(t2);
Texture2D<float> history            : register(t3);

[RootSignature(SHADOW_BLUR_Y_RS)]
[numthreads(POST_PROCESSING_BLOCK_SIZE, POST_PROCESSING_BLOCK_SIZE, 1)]
void main(cs_input IN)
{
	float value = blur(float2(0.f, 1.f), IN.dispatchThreadID.xy);

#if 1
	float2 uv = (IN.dispatchThreadID.xy + float2(0.5f, 0.5f)) * cb.invDimensions;

	const float2 m = motion[IN.dispatchThreadID.xy].xy;
	const float2 prevUV = uv + m;

	float prev = history.SampleLevel(linearSampler, prevUV, 0);

	float subpixelCorrection = frac(
		max(
			abs(m.x) * cb.dimensions.x,
			abs(m.y) * cb.dimensions.y
		)
	) * 0.5f;

	float blendfactor = saturate(lerp(0.05f, 0.8f, subpixelCorrection));
	blendfactor = isSaturated(prevUV) ? blendfactor : 1.f;
	blendfactor = (abs(value - prev) < 0.1f) ? blendfactor : 1.f;

	value = lerp(prev, value, blendfactor);
#endif

	output[IN.dispatchThreadID.xy] = value;
}

```

`shaders/post_processing/specular_ambient_cs.hlsl`:

```hlsl
#include "cs.hlsli"
#include "post_processing_rs.hlsli"
#include "lighting.hlsli"
#include "normal.hlsli"
#include "camera.hlsli"

ConstantBuffer<specular_ambient_cb> cb		: register(b0);
ConstantBuffer<camera_cb> camera			: register(b1);

RWTexture2D<float4> output					: register(u0);

Texture2D<float4> scene						: register(t0);
Texture2D<float2> worldNormals				: register(t1);
Texture2D<float4> reflectance				: register(t2);

Texture2D<float4> reflection				: register(t3);


TextureCube<float4> environmentTexture		: register(t4);
Texture2D<float2> brdf						: register(t5);
Texture2D<float> aoTexture					: register(t6);

SamplerState clampSampler					: register(s0);


[numthreads(POST_PROCESSING_BLOCK_SIZE, POST_PROCESSING_BLOCK_SIZE, 1)]
[RootSignature(SPECULAR_AMBIENT_RS)]
void main(cs_input IN)
{
	float2 uv = (IN.dispatchThreadID.xy + 0.5f) * cb.invDimensions;

	float4 color = scene[IN.dispatchThreadID.xy];
	if (color.a > 0.f) // Alpha of 0 indicates sky.
	{
		float4 refl = reflectance[IN.dispatchThreadID.xy];

		surface_info surface;
		surface.albedo = 0.f.xxxx;
		surface.metallic = 0.f;
		surface.N = normalize(unpackNormal(worldNormals[IN.dispatchThreadID.xy]));
		surface.V = -normalize(restoreWorldDirection(camera.invViewProj, uv, camera.position.xyz));
		surface.roughness = clamp(refl.a, 0.01f, 0.99f);

		surface.inferRemainingProperties();

		float4 ssr = reflection.SampleLevel(clampSampler, uv, 0);

		float3 specular = specularIBL(refl.rgb, surface, environmentTexture, brdf, clampSampler);
		specular = lerp(specular, ssr.rgb, ssr.a);

		float ao = aoTexture.SampleLevel(clampSampler, uv, 0);

		color.rgb += specular * ao;
	}
	output[IN.dispatchThreadID.xy] = color;
}

```

`shaders/post_processing/sss_cs.hlsl`:

```hlsl
#include "cs.hlsli"
#include "post_processing_rs.hlsli"
#include "camera.hlsli"
#include "math.hlsli"
#include "random.hlsli"

ConstantBuffer<sss_cb> cb				: register(b0);
ConstantBuffer<camera_cb> camera		: register(b1);

Texture2D<float> linearDepthBuffer		: register(t0);

RWTexture2D<float> result               : register(u0);

SamplerState pointSampler			    : register(s0);


[numthreads(POST_PROCESSING_BLOCK_SIZE, POST_PROCESSING_BLOCK_SIZE, 1)]
[RootSignature(SSS_RS)]
void main(cs_input IN)
{
    float2 uv = (IN.dispatchThreadID.xy + 0.5f) * cb.invDimensions;
	float depth = linearDepthBuffer.SampleLevel(pointSampler, uv, 1);

    float visibility = 1.f;

    if (depth < cb.maxDistanceFromCamera)
    {
        float3 rayOrigin = camera.restoreViewSpacePositionEyeDepth(uv, depth);
        float3 rayDirection = cb.lightDirection;

        float jitter = random(uv * 51239.f + cb.seed) * 0.05f + 1.2f;

        float occlusion = 0.f;

        float stepSize = cb.rayDistance / cb.numSteps;
        float3 step = rayDirection * stepSize;

        float3 rayPos = rayOrigin + step * jitter;

        float threshold = 0.02f;

        for (uint i = 0; i < cb.numSteps; ++i)
        {
            rayPos += step;
            float4 proj = mul(camera.proj, float4(rayPos, 1.f));
            proj.xyz /= proj.w;

            float2 uv = proj.xy * float2(0.5f, -0.5f) + 0.5f;

            [branch]
            if (isSaturated(uv) && isSaturated(proj.z))
            {
                float rayDepth = proj.w;
                float depth = linearDepthBuffer.SampleLevel(pointSampler, uv, 1);
                float delta = rayDepth - depth;

                if (delta > threshold && delta < cb.thickness)
                {
                    float borderDist = min(1.f - max(uv.x, uv.y), min(uv.x, uv.y));
                    occlusion = saturate(borderDist * cb.invBorderFadeout);

                    break;
                }
            }

        }

        float t = smoothstep(cb.maxDistanceFromCamera - cb.distanceFadeoutRange, cb.maxDistanceFromCamera, depth);
        occlusion = lerp(occlusion, 0.f, t);

        visibility = 1.f - occlusion;
    }

    result[IN.dispatchThreadID.xy] = visibility;
}

```

`shaders/post_processing/taa_cs.hlsl`:

```hlsl
#include "post_processing_rs.hlsli"
#include "cs.hlsli"
#include "camera.hlsli"
#include "math.hlsli"

ConstantBuffer<taa_cb> cb			: register(b0);

RWTexture2D<float4> output			: register(u0);
Texture2D<float4> currentFrame		: register(t0);
Texture2D<float4> prevFrame			: register(t1);
Texture2D<float2> motion			: register(t2);
Texture2D<float> depthBuffer		: register(t3);

SamplerState linearSampler			: register(s0);


#define TILE_BORDER 1
#define TILE_SIZE (POST_PROCESSING_BLOCK_SIZE + TILE_BORDER * 2)

#define HDR_CORRECTION

groupshared uint tileRedGreen[TILE_SIZE * TILE_SIZE];
groupshared uint tileBlueDepth[TILE_SIZE * TILE_SIZE];


static float3 tonemap(float3 x)
{
	return x / (x + 1.f); // Reinhard tonemap
}

static float3 inverseTonemap(float3 x)
{
	return x / (1.f - x);
}

[numthreads(POST_PROCESSING_BLOCK_SIZE, POST_PROCESSING_BLOCK_SIZE, 1)]
[RootSignature(TAA_RS)]
void main(cs_input IN)
{
	int2 texCoord = IN.dispatchThreadID.xy;
	float2 invDimensions = 1.f / cb.dimensions;
	float2 uv = (float2(texCoord) + float2(0.5f, 0.5f)) * invDimensions;

	const int2 upperLeft = IN.groupID.xy * POST_PROCESSING_BLOCK_SIZE - TILE_BORDER;

	for (uint t = IN.groupIndex; t < TILE_SIZE * TILE_SIZE; t += POST_PROCESSING_BLOCK_SIZE * POST_PROCESSING_BLOCK_SIZE)
	{
		const uint2 pixel = upperLeft + unflatten2D(t, TILE_SIZE);
		const float depth = depthBuffer[pixel];
		const float3 color = currentFrame[pixel].rgb;
		tileRedGreen[t] = f32tof16(color.r) | (f32tof16(color.g) << 16);
		tileBlueDepth[t] = f32tof16(color.b) | (f32tof16(depth) << 16);
	}
	GroupMemoryBarrierWithGroupSync();


	float3 neighborhoodMin = 100000;
	float3 neighborhoodMax = -100000;
	float3 current;
	float bestDepth = 1;

	// Search for best velocity and compute color clamping range in 3x3 neighborhood.
	int2 bestOffset = 0;
	for (int x = -1; x <= 1; ++x)
	{
		for (int y = -1; y <= 1; ++y)
		{
			const int2 offset = int2(x, y);
			const uint idx = flatten2D(IN.groupThreadID.xy + TILE_BORDER + offset, TILE_SIZE);
			const uint redGreen = tileRedGreen[idx];
			const uint blueDepth = tileBlueDepth[idx];

			const float3 neighbor = float3(f16tof32(redGreen), f16tof32(redGreen >> 16), f16tof32(blueDepth));
			neighborhoodMin = min(neighborhoodMin, neighbor);
			neighborhoodMax = max(neighborhoodMax, neighbor);
			if (x == 0 && y == 0)
			{
				current = neighbor;
			}

			const float depth = f16tof32(blueDepth >> 16);
			if (depth < bestDepth)
			{
				bestDepth = depth;
				bestOffset = offset;
			}
		}
	}

	const float2 m = motion[IN.dispatchThreadID.xy + bestOffset].xy;
	const float2 prevUV = uv + m;

	float4 prev = prevFrame.SampleLevel(linearSampler, prevUV, 0);
	prev.rgb = clamp(prev.rgb, neighborhoodMin, neighborhoodMax);

	float subpixelCorrection = frac(
		max(
			abs(m.x) * cb.dimensions.x,
			abs(m.y) * cb.dimensions.y
		)
	) * 0.5f;

	float blendfactor = saturate(lerp(0.05f, 0.8f, subpixelCorrection));
	blendfactor = isSaturated(prevUV) ? blendfactor : 1.f;

#ifdef HDR_CORRECTION
	prev.rgb = tonemap(prev.rgb);
	current.rgb = tonemap(current.rgb);
#endif

	float3 resolved = lerp(prev.rgb, current.rgb, blendfactor);

#ifdef HDR_CORRECTION
	resolved.rgb = inverseTonemap(resolved.rgb);
#endif

	output[texCoord] = float4(resolved, 1.f);
}

```

`shaders/post_processing/tonemap_cs.hlsl`:

```hlsl
#include "cs.hlsli"
#include "post_processing_rs.hlsli"


ConstantBuffer<tonemap_cb> tonemap	: register(b0);
RWTexture2D<float4> output	: register(u0);
Texture2D<float4>	input	: register(t0);


[numthreads(POST_PROCESSING_BLOCK_SIZE, POST_PROCESSING_BLOCK_SIZE, 1)]
[RootSignature(TONEMAP_RS)]
void main(cs_input IN)
{
	output[IN.dispatchThreadID.xy] = float4(
		tonemap.tonemap(
			input[IN.dispatchThreadID.xy].rgb
		)
		, 1.f);
}

```

`shaders/proc_placement/proc_placement_create_draw_calls_cs.hlsl`:

```hlsl
#include "cs.hlsli"
#include "proc_placement_rs.hlsli"

ConstantBuffer<proc_placement_create_draw_calls_cb> cb	: register(b0);
StructuredBuffer<uint> meshCounts						: register(t0);
StructuredBuffer<uint> meshOffsets						: register(t1);
StructuredBuffer<uint> submeshToMesh					: register(t2);
RWStructuredBuffer<placement_draw> draws				: register(u0);


[RootSignature(PROC_PLACEMENT_CREATE_DRAW_CALLS_RS)]
[numthreads(PROC_PLACEMENT_CREATE_DRAW_CALLS_BLOCK_SIZE, 1, 1)]
void main(cs_input IN)
{
	uint id = IN.dispatchThreadID.x;
	uint meshID = submeshToMesh[id];

	placement_draw draw = draws[id];
	draw.draw.InstanceCount = meshCounts[meshID];

	uint offset = meshOffsets[meshID] * cb.stride;
	draw.transformSRVLow = cb.transformAddressLow + offset;
	draw.transformSRVHigh = cb.transformAddressHigh + uint(draw.transformSRVLow < cb.transformAddressLow);
	draws[id] = draw;
}

```

`shaders/proc_placement/proc_placement_create_transforms_cs.hlsl`:

```hlsl
#include "cs.hlsli"
#include "proc_placement_rs.hlsli"

StructuredBuffer<placement_point> placementPoints	: register(t0);
StructuredBuffer<uint> meshOffsets					: register(t1);

RWStructuredBuffer<placement_transform> transforms	: register(u0);
RWStructuredBuffer<uint> meshCounts					: register(u1);

[RootSignature(PROC_PLACEMENT_CREATE_TRANSFORMS_RS)]
[numthreads(PROC_PLACEMENT_CREATE_TRANSFORMS_BLOCK_SIZE, 1, 1)]
void main(cs_input IN)
{
	uint totalCount = meshCounts[0];

	uint id = IN.dispatchThreadID.x;
	if (id >= totalCount)
	{
		return;
	}

	placement_point p = placementPoints[id];
	
	uint globalOffset = meshOffsets[p.meshID];
	
	uint localOffset;
	InterlockedAdd(meshCounts[p.meshID], -1, localOffset);
	--localOffset;
	
	float3 yAxis = p.normal;
	float3 xAxis = normalize(cross(yAxis, float3(0.f, 0.f, 1.f)));
	float3 zAxis = cross(xAxis, yAxis);

	float4x4 m = {
		{ xAxis.x, yAxis.x, zAxis.x, p.position.x },
		{ xAxis.y, yAxis.y, zAxis.y, p.position.y },
		{ xAxis.z, yAxis.z, zAxis.z, p.position.z },
		{ 0, 0, 0, 1 }
	};

	placement_transform transform;
	transform.m = m;
	
	transforms[globalOffset + localOffset] = transform;
}

```

`shaders/proc_placement/proc_placement_generate_points_cs.hlsl`:

```hlsl
#include "cs.hlsli"
#include "proc_placement_rs.hlsli"
#include "math.hlsli"
#include "random.hlsli"

ConstantBuffer<proc_placement_generate_points_cb> cb	: register(b0);

Texture2D<float> heightmap								: register(t0);
Texture2D<float2> normalmap								: register(t1);

RWStructuredBuffer<placement_point> placementPoints		: register(u0);
RWStructuredBuffer<uint> pointAndMeshCount				: register(u1);

SamplerState clampSampler								: register(s0);



[RootSignature(PROC_PLACEMENT_GENERATE_POINTS_RS)]
[numthreads(16, 16, 1)]
void main(cs_input IN)
{
	//float2 uv = (POISSON_SAMPLES[IN.groupIndex] + IN.groupID.xy) * cb.uvScale;
	float2 localUV = (IN.groupThreadID.xy + 0.5f) * (1.f / 16.f);
	float2 uv = (localUV + IN.groupID.xy) * cb.uvScale;

	if (isSaturated(uv))
	{
		float height = heightmap.SampleLevel(clampSampler, uv, 0) * cb.amplitudeScale;
		float2 n = normalmap.SampleLevel(clampSampler, uv, 0) * cb.amplitudeScale;
		float3 normal = normalize(float3(n.x, 1.f, n.y));

		if (normal.y > 0.9f)
		{
			float4 densities = cb.densities;
			
			float densitySum = dot(densities, (float4)1.f);
			
			densitySum = max(densitySum, 1.f); // Only normalize if we are above 1.
			densities *= 1.f / densitySum;
			
			float4 unusedChannels = float4(cb.numMeshes < 1, cb.numMeshes < 2, cb.numMeshes < 3, cb.numMeshes < 4);
			densities += unusedChannels; // Initialize unused channels to high.
			
			densities.y += densities.x;
			densities.z += densities.y;
			densities.w += densities.z;



			float threshold = fbm(uv * 1.5f, 4).x * 0.5f + 0.5f;
			
			float4 comparison = (float4)threshold > densities;
			uint meshIndex = (uint)dot(comparison, comparison);

			uint globalMeshIndex = cb.globalMeshOffset + meshIndex;

			uint offset;
			InterlockedAdd(pointAndMeshCount[0], 1, offset);
			InterlockedAdd(pointAndMeshCount[globalMeshIndex], 1);

			float2 xz = uv * cb.chunkSize;

			placement_point result;
			result.position = float3(xz.x, height, xz.y) + cb.chunkCorner;
			result.normal = normal;
			result.meshID = globalMeshIndex;
			result.lod = 0; // TODO
			placementPoints[offset] = result;
		}
	}
}

```

`shaders/proc_placement/proc_placement_points_ps.hlsl`:

```hlsl

#define RS \
    "RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT |" \
    "DENY_HULL_SHADER_ROOT_ACCESS |" \
    "DENY_DOMAIN_SHADER_ROOT_ACCESS |" \
    "DENY_GEOMETRY_SHADER_ROOT_ACCESS)," \
    "CBV(b0, visibility=SHADER_VISIBILITY_VERTEX), " \
    "SRV(t0, visibility=SHADER_VISIBILITY_VERTEX), " \
    "DescriptorTable(SRV(t0, numDescriptors=1, space=1), visibility=SHADER_VISIBILITY_PIXEL), " \
    "StaticSampler(s0, space=1," \
	    "addressU = TEXTURE_ADDRESS_WRAP," \
	    "addressV = TEXTURE_ADDRESS_WRAP," \
	    "addressW = TEXTURE_ADDRESS_WRAP," \
	    "filter = FILTER_MIN_MAG_MIP_LINEAR)"

Texture2D<float4> albedo    : register(t0, space1);
SamplerState wrapSampler    : register(s0, space1);


[RootSignature(RS)]
float4 main(float2 uv : TEXCOORDS) : SV_TARGET
{
	return albedo.Sample(wrapSampler, uv);
}

```

`shaders/proc_placement/proc_placement_points_vs.hlsl`:

```hlsl
#include "proc_placement_rs.hlsli"
#include "camera.hlsli"

ConstantBuffer<camera_cb> camera						: register(b0);
StructuredBuffer<placement_transform> transforms		: register(t0);

struct vs_input
{
	float3 position		: POSITION;
	float2 uv			: TEXCOORDS;
	float3 normal		: NORMAL;
	float3 tangent		: TANGENT;

	uint instanceID		: SV_InstanceID;
};

struct vs_output
{
	float2 uv			: TEXCOORDS;
	float4 position		: SV_POSITION;
};

vs_output main(vs_input IN)
{
	float4x4 mvp = mul(camera.viewProj, transforms[IN.instanceID].m);

	vs_output OUT;
	OUT.position = mul(mvp, float4(IN.position * 0.02f, 1.f));
	OUT.uv = IN.uv;
	return OUT;
}

```

`shaders/proc_placement/proc_placement_prefix_sum_cs.hlsl`:

```hlsl
#include "cs.hlsli"
#include "proc_placement_rs.hlsli"

ConstantBuffer<prefix_sum_cb> cb	: register(b0);
RWStructuredBuffer<uint> output		: register(u0);
StructuredBuffer<uint> input		: register(t0);

groupshared uint temp[512];

[RootSignature(PROC_PLACEMENT_PREFIX_SUM_RS)]
[numthreads(512, 1, 1)]
void main(cs_input IN)
{
	uint id = IN.dispatchThreadID.x;

	uint x = (id < cb.size) ? input[id] : 0;
	temp[id] = x;

	uint sum = x;

	[unroll]
	for (uint offset = 1; offset < 512; offset <<= 1)
	{
		GroupMemoryBarrierWithGroupSync();

		if (id >= offset)
		{
			sum += temp[id - offset];
		}

		temp[id] = sum;
	}

	if (id < cb.size)
	{
		output[id] = sum - x; // Subtract original value x, since we perform an exclusive sum.
	}
}

```

`shaders/raytracing/path_tracing_rts.hlsl`:

```hlsl
#include "../common/camera.hlsli"
#include "../common/raytracing.hlsli"
#include "../common/material.hlsli"
#include "../common/random.hlsli"
#include "../common/lighting.hlsli"

// Raytracing intrinsics: https://microsoft.github.io/DirectX-Specs/d3d/Raytracing.html#ray-system-values
// Ray flags: https://microsoft.github.io/DirectX-Specs/d3d/Raytracing.html#ray-flags

struct mesh_vertex
{
	float2 uv;
	float3 normal;
	float3 tangent;
};


// Global.
RaytracingAccelerationStructure rtScene		: register(t0);
TextureCube<float4> sky						: register(t1);

RWTexture2D<float4> output					: register(u0);

ConstantBuffer<camera_cb> camera			: register(b0);
ConstantBuffer<path_tracing_cb> constants	: register(b1);

SamplerState wrapSampler					: register(s0);


// Radiance hit group.
ConstantBuffer<pbr_material_cb> material	: register(b0, space1);
StructuredBuffer<mesh_vertex> meshVertices	: register(t0, space1);
ByteAddressBuffer meshIndices				: register(t1, space1);
Texture2D<float4> albedoTex					: register(t2, space1);
Texture2D<float3> normalTex					: register(t3, space1);
Texture2D<float> roughTex					: register(t4, space1);
Texture2D<float> metalTex					: register(t5, space1);


struct radiance_ray_payload
{
	float3 color;
	uint recursion;
	uint randSeed;
};

struct shadow_ray_payload
{
	float visible;
};


#define NUM_LIGHTS 3

static const point_light_cb pointLights[NUM_LIGHTS] =
{
	// Position, radius, radiance. The last value (-1) is only useful for rasterization, where this is the index into a list of shadow maps (-1 means no shadows).
	{
		float3(0.f, 3.f, 0.f),
		15.f,
		float3(0.8f, 0.2f, 0.1f) * 50.f,
		-1
	},
	{
		float3(-5.f, 8.f, 0.f),
		15.f,
		float3(0.2f, 0.8f, 0.3f) * 50.f,
		-1
	},
	{
		float3(5.f, 8.f, 0.f),
		15.f,
		float3(0.2f, 0.3f, 0.8f) * 50.f,
		-1
	},
};



static float3 traceRadianceRay(float3 origin, float3 direction, uint randSeed, uint recursion)
{
	// This is replaced by the russian roulette below.
	/*if (recursion >= constants.maxRecursionDepth)
	{
		return float3(0, 0, 0);
	}*/

	// My attempt at writing a russian roulette termination, which guarantees that the recursion depth does not exceed the maximum.
	// Lower numbers make rays terminate earlier, which improves performance, but hurts the convergence speed.
	// I think normally you wouldn't want the termination probability to go to 1, but DirectX will remove the device, if you exceed
	// the recursion limit.
	float russianRouletteFactor = 1.f;
	if (recursion >= constants.startRussianRouletteAfter)
	{
		uint rouletteSteps = constants.maxRecursionDepth - constants.startRussianRouletteAfter + 1;
		uint stepsRemaining = recursion - constants.startRussianRouletteAfter + 1;
		float stopProbability = min(1.f, (float)stepsRemaining / (float)rouletteSteps);

		if (nextRand(randSeed) <= stopProbability)
		{
			return (float3)0.f;
		}

		russianRouletteFactor = 1.f / (1.f - stopProbability);
	}

	RayDesc ray;
	ray.Origin = origin;
	ray.Direction = direction;
	ray.TMin = 0.01f;
	ray.TMax = 10000.f;

	radiance_ray_payload payload = { float3(0.f, 0.f, 0.f), recursion + 1, randSeed };

	TraceRay(rtScene,
		RAY_FLAG_CULL_BACK_FACING_TRIANGLES,
		0xFF,				// Cull mask.
		RADIANCE,			// Addend on the hit index.
		NUM_RAY_TYPES,		// Multiplier on the geometry index within a BLAS.
		RADIANCE,			// Miss index.
		ray,
		payload);

	return payload.color * russianRouletteFactor;
}

static float traceShadowRay(float3 origin, float3 direction, float distance, uint recursion) // This shader type is also used for ambient occlusion. Just set the distance to something small.
{
	if (recursion >= constants.maxRecursionDepth)
	{
		return 1.f;
	}

#ifdef SHADOW
	RayDesc ray;
	ray.Origin = origin;
	ray.Direction = direction;
	ray.TMin = 0.01f;
	ray.TMax = distance;

	shadow_ray_payload payload = { 0.f };

	TraceRay(rtScene,
		RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER, // No need to invoke closest hit shader.
		0xFF,				// Cull mask.
		SHADOW,				// Addend on the hit index.
		NUM_RAY_TYPES,		// Multiplier on the geometry index within a BLAS.
		SHADOW,				// Miss index.
		ray,
		payload);

	return payload.visible;
#else
	return 1.f;
#endif
}





// ----------------------------------------
// RAY GENERATION
// ----------------------------------------

[shader("raygeneration")]
void rayGen()
{
	uint3 launchIndex = DispatchRaysIndex();
	uint3 launchDim = DispatchRaysDimensions();

	uint randSeed = initRand(launchIndex.x + launchIndex.y * launchDim.x, constants.frameCount, 16);


	// Jitter for anti-aliasing.
	float2 pixelOffset = float2(nextRand(randSeed), nextRand(randSeed));
	float2 uv = (float2(launchIndex.xy) + pixelOffset) / float2(launchDim.xy);

	float3 origin = camera.position.xyz;
	float3 direction = restoreWorldDirection(camera.invViewProj, uv, origin);


	if (constants.useThinLensCamera)
	{
		direction /= camera.projectionParams.x;

		float3 focalPoint = origin + constants.focalLength * direction;

		float2 rnd = float2(2.f * M_PI * nextRand(randSeed), constants.lensRadius * nextRand(randSeed));
		float2 originOffset = float2(cos(rnd.x) * rnd.y, sin(rnd.x) * rnd.y);

		origin += camera.right.xyz * originOffset.x + camera.up.xyz * originOffset.y;
		direction = focalPoint - origin;
	}

	direction = normalize(direction);


	// Trace ray.
	float3 color = traceRadianceRay(origin, direction, randSeed, 0);


	// Blend result color with previous frames.
	float3 previousColor = output[launchIndex.xy].xyz;
	float previousCount = (float)constants.numAccumulatedFrames;
	float3 newColor = (previousCount * previousColor + color) / (previousCount + 1);

	output[launchIndex.xy] = float4(newColor, 1.f);
}




// ----------------------------------------
// RADIANCE
// ----------------------------------------

static float probabilityToSampleDiffuse(float roughness)
{
	// I don't know what a good way to choose is. My understanding is that it doesn't really matter, as long as you account for the probability in your results. 
	// It has an impact on covergence speed though.
	// TODO: Can we calculate this using fresnel?
	return 0.5f;
	return roughness;
}

static float3 calculateIndirectLighting(inout uint randSeed, surface_info surface, uint recursion)
{
	float probDiffuse = probabilityToSampleDiffuse(surface.roughness);
	float chooseDiffuse = (nextRand(randSeed) < probDiffuse);

	if (chooseDiffuse)
	{
		float3 L = getCosHemisphereSample(randSeed, surface.N);
		float3 bounceColor = traceRadianceRay(surface.P, L, randSeed, recursion);

		// Accumulate the color: (NdotL * incomingLight * dif / pi) 
		// Probability of sampling:  (NdotL / pi) * probDiffuse
		return bounceColor * surface.albedo.rgb / probDiffuse;
	}
	else
	{
		float3 H = importanceSampleGGX(randSeed, surface.N, surface.roughness);
		float3 L = reflect(-surface.V, H);

		float3 bounceColor = traceRadianceRay(surface.P, L, randSeed, recursion);

		float NdotV = saturate(dot(surface.N, surface.V));
		float NdotL = saturate(dot(surface.N, L));
		float NdotH = saturate(dot(surface.N, H));
		float LdotH = saturate(dot(L, H));

		float D = distributionGGX(NdotH, surface.roughness);
		float G = geometrySmith(NdotL, NdotV, surface.roughness);
		float3 F = fresnelSchlick(LdotH, surface.F0);

		float3 numerator = D * G * F;
		float denominator = 4.f * NdotV * NdotL;
		float3 brdf = numerator / max(denominator, 0.001f);

		// Probability of sampling vector H from GGX.
		float ggxProb = max(D * NdotH / (4.f * LdotH), 0.01f);

		// Accumulate the color:  ggx-BRDF * incomingLight * NdotL / probability-of-sampling
		//    -> Should really simplify the math above.
		return NdotL * bounceColor * brdf / (ggxProb * (1.f - probDiffuse));
	}
}


[shader("closesthit")]
void radianceClosestHit(inout radiance_ray_payload payload, in BuiltInTriangleIntersectionAttributes attribs)
{
	uint flags = material.getFlags();

	uint3 tri = (flags & MATERIAL_USE_32_BIT_INDICES) ? load3x32BitIndices(meshIndices) : load3x16BitIndices(meshIndices);

	// Interpolate vertex attributes over triangle.
	float2 uvs[] = { meshVertices[tri.x].uv, meshVertices[tri.y].uv, meshVertices[tri.z].uv };
	float3 normals[] = { meshVertices[tri.x].normal, meshVertices[tri.y].normal, meshVertices[tri.z].normal };

	float2 uv = interpolateAttribute(uvs, attribs);

	surface_info surface;
	surface.N = normalize(transformDirectionToWorld(interpolateAttribute(normals, attribs)));
	surface.V = -WorldRayDirection();
	surface.P = hitWorldPosition();

	surface.emission = (float3)0.f;
	surface.albedo = (float4)1.f;
	surface.roughness = 1.f;
	surface.metallic = 0.f;

	if (constants.useRealMaterials)
	{
		uint mipLevel = 0;

		surface.albedo = (((flags & MATERIAL_USE_ALBEDO_TEXTURE)
			? albedoTex.SampleLevel(wrapSampler, uv, mipLevel)
			: float4(1.f, 1.f, 1.f, 1.f))
			* unpackColor(material.albedoTint));

		// We ignore normal maps for now.

		surface.roughness = (flags & MATERIAL_USE_ROUGHNESS_TEXTURE)
			? roughTex.SampleLevel(wrapSampler, uv, mipLevel)
			: material.getRoughnessOverride();

		surface.metallic = (flags & MATERIAL_USE_METALLIC_TEXTURE)
			? metalTex.SampleLevel(wrapSampler, uv, mipLevel)
			: material.getMetallicOverride();

		surface.emission = material.emission;
	}

	surface.roughness = clamp(surface.roughness, 0.01f, 0.99f);

	surface.inferRemainingProperties();

	payload.color = surface.emission;
	payload.color += calculateIndirectLighting(payload.randSeed, surface, payload.recursion);


	if (constants.enableDirectLighting)
	{
		// Sun light.
		{
			float3 sunL = -normalize(float3(-0.6f, -1.f, -0.3f));
			float3 sunRadiance = float3(1.f, 0.93f, 0.76f) * constants.lightIntensityScale * 2.f;

			light_info light;
			light.initialize(surface, sunL, sunRadiance);

			payload.color +=
				calculateDirectLighting(surface, light).evaluate(surface.albedo)
				* traceShadowRay(surface.P, sunL, 10000.f, payload.recursion);
		}



		// Random point light.
		{
			uint lightIndex = min(uint(NUM_LIGHTS * nextRand(payload.randSeed)), NUM_LIGHTS - 1);

			light_info light;
			light.initializeFromRandomPointOnSphereLight(surface, pointLights[lightIndex], constants.pointLightRadius, payload.randSeed);

			float pointLightVisibility = traceShadowRay(surface.P, light.L, light.distanceToLight, payload.recursion);

			float3 pointLightColor =
				calculateDirectLighting(surface, light).evaluate(surface.albedo)
				* pointLightVisibility;

			float pointLightSolidAngle = solidAngleOfSphere(constants.pointLightRadius, light.distanceToLight) * 0.5f; // Divide by 2, since we are only interested in hemisphere.
			if (constants.multipleImportanceSampling)
			{
				// Multiple importance sampling. At least if I've done this correctly. See http://www.cs.uu.nl/docs/vakken/magr/2015-2016/slides/lecture%2008%20-%20variance%20reduction.pdf, slide 50.
				float lightPDF = 1.f / (pointLightSolidAngle * NUM_LIGHTS); // Correct for PDFs, see comment below.

				// Lambertian part.
				float diffusePDF = dot(surface.N, light.L) * M_INV_PI; // Cosine-distributed for Lambertian BRDF.

				// Specular part.
				float D = distributionGGX(surface, light);
				float specularPDF = max(D * light.NdotH / (4.f * light.LdotH), 0.01f);

				float probDiffuse = probabilityToSampleDiffuse(surface.roughness);

				// Total BRDF PDF. This is the probability that we had randomly hit this direction using our brdf importance sampling.
				float brdfPDF = lerp(specularPDF, diffusePDF, probDiffuse);

				// Blend PDFs.
				float t = lightPDF / (lightPDF + brdfPDF);
				float misPDF = lerp(brdfPDF, lightPDF, t); // Balance heuristic.

				pointLightColor /= misPDF;
			}
			else
			{
				pointLightColor = pointLightColor
					* NUM_LIGHTS			 // Correct for probability of choosing this particular light.
					* pointLightSolidAngle;  // Correct for probability of "randomly" hitting this light. I *think* this is correct. See https://github.com/NVIDIA/Q2RTX/blob/master/src/refresh/vkpt/shader/light_lists.h#L295.
			}

			payload.color += pointLightColor;
		}
	}
}

[shader("miss")]
void radianceMiss(inout radiance_ray_payload payload)
{
	payload.color = sky.SampleLevel(wrapSampler, WorldRayDirection(), 0).xyz;
}





// ----------------------------------------
// SHADOW
// ----------------------------------------

[shader("miss")]
void shadowMiss(inout shadow_ray_payload payload)
{
	payload.visible = 1.f;
}



```

`shaders/reflections/rt_reflections_rts.hlsl`:

```hlsl
#include "../common/camera.hlsli"
#include "../common/raytracing.hlsli"
#include "../rs/rt_reflections_rs.hlsli"
#include "../rs/ssr_rs.hlsli"
#include "../common/light_source.hlsli"
#include "../common/lighting.hlsli"
#include "../common/brdf.hlsli"
#include "../common/normal.hlsli"
#include "../common/material.hlsli"
#include "../common/procedural_sky.hlsli"

// Raytracing intrinsics: https://microsoft.github.io/DirectX-Specs/d3d/Raytracing.html#ray-system-values
// Ray flags: https://microsoft.github.io/DirectX-Specs/d3d/Raytracing.html#ray-flags

struct mesh_vertex
{
	float2 uv;
	float3 normal;
	float3 tangent;
};


// Global.
RaytracingAccelerationStructure rtScene		: register(t0);
TextureCube<float4> sky						: register(t1);

Texture2D<float3> probeIrradiance			: register(t2);
Texture2D<float2> probeDepth				: register(t3);

Texture2D<float> depthBuffer                : register(t4);
Texture2D<float3> worldNormalsRoughness		: register(t5);
Texture2D<float2> noise						: register(t6);
Texture2D<float2> motion					: register(t7);

RWTexture2D<float4> output					: register(u0);

ConstantBuffer<rt_reflections_cb> cb		: register(b0);
ConstantBuffer<camera_cb> camera			: register(b1);
ConstantBuffer<lighting_cb> lighting		: register(b2);
SamplerState linearSampler					: register(s0);
SamplerState pointSampler					: register(s1);


// Radiance hit group.
ConstantBuffer<pbr_material_cb> material	: register(b0, space1);
StructuredBuffer<mesh_vertex> meshVertices	: register(t0, space1);
ByteAddressBuffer meshIndices				: register(t1, space1);
Texture2D<float4> albedoTex					: register(t2, space1);
Texture2D<float3> normalTex					: register(t3, space1);
Texture2D<float> roughTex					: register(t4, space1);
Texture2D<float> metalTex					: register(t5, space1);


struct radiance_ray_payload
{
	float3 color;
};

struct shadow_ray_payload
{
	float visible;
};

static float3 traceRadianceRay(float3 origin, float3 direction, uint recursion)
{
	RayDesc ray;
	ray.Origin = origin;
	ray.Direction = direction;
	ray.TMin = 0.01f;
	ray.TMax = 10000.f;

	radiance_ray_payload payload = { float3(0.f, 0.f, 0.f) };

	TraceRay(rtScene,
		RAY_FLAG_CULL_BACK_FACING_TRIANGLES,
		0xFF,				// Cull mask.
		RADIANCE,			// Addend on the hit index.
		NUM_RAY_TYPES,		// Multiplier on the geometry index within a BLAS.
		RADIANCE,			// Miss index.
		ray,
		payload);

	return payload.color;
}

static float traceShadowRay(float3 origin, float3 direction, float distance)
{
#ifdef SHADOW
	RayDesc ray;
	ray.Origin = origin;
	ray.Direction = direction;
	ray.TMin = 0.01f;
	ray.TMax = distance;

	shadow_ray_payload payload = { 0.f };

	TraceRay(rtScene,
		RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER, // No need to invoke closest hit shader.
		0xFF,				// Cull mask.
		SHADOW,				// Addend on the hit index.
		NUM_RAY_TYPES,		// Multiplier on the geometry index within a BLAS.
		SHADOW,				// Miss index.
		ray,
		payload);

	return payload.visible;
#else
	return 1.f;
#endif
}

[shader("raygeneration")]
void rayGen()
{
	uint3 launchIndex = DispatchRaysIndex();
	uint3 launchDim = DispatchRaysDimensions();

	float2 uv = float2(launchIndex.xy) / float2(launchDim.xy);
    const float depth = depthBuffer.SampleLevel(pointSampler, uv, 0);

	if (depth == 1.f)
	{
		output[launchIndex.xy] = float4(0.f, 0.f, -1.f, 0.f);
		return;
	}

	const float2 uvM = motion.SampleLevel(linearSampler, uv, 0);
	const float3 normalAndRoughness = worldNormalsRoughness.SampleLevel(linearSampler, uv + uvM, 0);

	if (all(normalAndRoughness.xy == float2(0.f, 0.f)))
	{
		// If normal is zero length, just return no hit.
		// This happens if the window is resized, because we are sampling the last frame's normals.
		output[launchIndex.xy] = float4(0.f, 0.f, -1.f, 0.f);
		return;
	}

	const float3 normal = unpackNormal(normalAndRoughness.xy);
	const float roughness = clamp(normalAndRoughness.z * normalAndRoughness.z * normalAndRoughness.z, 0.03f, 0.97f); // Raising the roughness to a power gets rid of some jittering.

	float3 origin = restoreWorldSpacePosition(camera.invViewProj, uv, depth);
	float3 viewDir = normalize(origin - camera.position.xyz);

	float2 h = halton23(cb.frameIndex & 31);
	uint3 noiseDims;
	noise.GetDimensions(0, noiseDims.x, noiseDims.y, noiseDims.z);
	float2 Xi = noise.SampleLevel(linearSampler, (uv + h) * float2(launchDim.xy) / float2(noiseDims.xy), 0);
	Xi.y = lerp(Xi.y, 0.f, SSR_GGX_IMPORTANCE_SAMPLE_BIAS);

	float4 H = importanceSampleGGX(Xi, normal, roughness);
	float3 direction = reflect(viewDir, H.xyz);

	float3 color = traceRadianceRay(origin, direction, 0);

	output[launchIndex.xy] = float4(color, 1);
}

// ----------------------------------------
// RADIANCE
// ----------------------------------------

[shader("closesthit")]
void radianceClosestHit(inout radiance_ray_payload payload, in BuiltInTriangleIntersectionAttributes attribs)
{
	uint flags = material.getFlags();

	uint3 tri = (flags & MATERIAL_USE_32_BIT_INDICES) ? load3x32BitIndices(meshIndices) : load3x16BitIndices(meshIndices);

	// Interpolate vertex attributes over triangle.
	float2 uvs[] = { meshVertices[tri.x].uv, meshVertices[tri.y].uv, meshVertices[tri.z].uv };
	float3 normals[] = { meshVertices[tri.x].normal, meshVertices[tri.y].normal, meshVertices[tri.z].normal };

	float2 uv = interpolateAttribute(uvs, attribs);

	surface_info surface;
	surface.N = normalize(transformDirectionToWorld(interpolateAttribute(normals, attribs))); // We ignore normal maps.
	surface.V = -WorldRayDirection();
	surface.P = hitWorldPosition();

	uint mipLevel = 3;

	surface.albedo = (((flags & MATERIAL_USE_ALBEDO_TEXTURE)
		? albedoTex.SampleLevel(linearSampler, uv, mipLevel)
		: float4(1.f, 1.f, 1.f, 1.f))
		* unpackColor(material.albedoTint));

	surface.roughness = (flags & MATERIAL_USE_ROUGHNESS_TEXTURE)
		? roughTex.SampleLevel(linearSampler, uv, mipLevel)
		: material.getRoughnessOverride();

	surface.metallic = (flags & MATERIAL_USE_METALLIC_TEXTURE)
		? metalTex.SampleLevel(linearSampler, uv, mipLevel)
		: material.getMetallicOverride();

	surface.emission = material.emission;
	surface.roughness = clamp(surface.roughness, 0.01f, 0.99f);

	surface.inferRemainingProperties();



	float3 L = -lighting.sun.direction;
	float sunVisibility = traceShadowRay(surface.P, L, 10000.f);

	light_info light;
	light.initialize(surface, L, lighting.sun.radiance);

	light_contribution totalLighting = { float3(0.f, 0.f, 0.f), float3(0.f, 0.f, 0.f) };
	totalLighting.add(calculateDirectLighting(surface, light), sunVisibility);

	totalLighting.diffuse += lighting.lightProbeGrid.sampleIrradianceAtPosition(surface.P, surface.N, probeIrradiance, probeDepth, linearSampler);

	payload.color = totalLighting.evaluate(surface.albedo).rgb + surface.emission;
}

[shader("miss")]
void radianceMiss(inout radiance_ray_payload payload)
{
	if(cb.sampleSkyFromTexture == 1)
	{
		payload.color = sky.SampleLevel(linearSampler, WorldRayDirection(), 0).xyz;
	}
	else
	{
		payload.color = proceduralSkySimple(normalize(WorldRayDirection()), normalize(-lighting.sun.direction));
	}
}



// ----------------------------------------
// SHADOW
// ----------------------------------------

[shader("miss")]
void shadowMiss(inout shadow_ray_payload payload)
{
	payload.visible = 1.f;
}

```

`shaders/reflections/ssr_median_blur_cs.hlsl`:

```hlsl
#include "ssr_rs.hlsli"
#include "cs.hlsli"


ConstantBuffer<ssr_median_blur_cb> cb	: register(b0);

RWTexture2D<float4> output	            : register(u0);
Texture2D<float4> input	                : register(t0);

SamplerState linearSampler			    : register(s0);



// A Fast, Small-Radius GPU Median Filter by Morgan McGuire
// https://casual-effects.com/research/McGuire2008Median/index.html

#define s2(a, b)                            temp = a; a = min(a, b); b = max(temp, b);
#define t2(a, b)                            s2(v[a], v[b]);
#define t24(a, b, c, d, e, f, g, h)         t2(a, b); t2(c, d); t2(e, f); t2(g, h); 
#define t25(a, b, c, d, e, f, g, h, i, j)   t24(a, b, c, d, e, f, g, h); t2(i, j);


[numthreads(SSR_BLOCK_SIZE, SSR_BLOCK_SIZE, 1)]
[RootSignature(SSR_MEDIAN_BLUR_RS)]
void main(cs_input IN)
{
    const float2 uv = (IN.dispatchThreadID.xy + 0.5f) * cb.invDimensions;
    //const float depth = texture_depth.SampleLevel(sampler_point_clamp, uv, 1);
    //if (depth == 0.0f)
    //    return;

#if 0
    // Disable.
    output[IN.dispatchThreadID.xy] = input.SampleLevel(linearSampler, uv, 0);
    return;
#endif



    half4 v[25];

    // Add the pixels which make up our window to the pixel array.
    [unroll]
    for (int dX = -2; dX <= 2; ++dX)
    {
        [unroll]
        for (int dY = -2; dY <= 2; ++dY)
        {
            float2 offset = float2(float(dX), float(dY));

            // If a pixel in the window is located at (x+dX, y+dY), put it at index (dX + R)(2R + 1) + (dY + R) of the
            // pixel array. This will fill the pixel array, with the top left pixel of the window at pixel[0] and the
            // bottom right pixel of the window at pixel[N-1].
            v[(dX + 2) * 5 + (dY + 2)] = input.SampleLevel(linearSampler, uv + offset * cb.invDimensions, 0);
        }
    }

    half4 temp;
    t25(0, 1, 3, 4, 2, 4, 2, 3, 6, 7);
    t25(5, 7, 5, 6, 9, 7, 1, 7, 1, 4);
    t25(12, 13, 11, 13, 11, 12, 15, 16, 14, 16);
    t25(14, 15, 18, 19, 17, 19, 17, 18, 21, 22);
    t25(20, 22, 20, 21, 23, 24, 2, 5, 3, 6);
    t25(0, 6, 0, 3, 4, 7, 1, 7, 1, 4);
    t25(11, 14, 8, 14, 8, 11, 12, 15, 9, 15);
    t25(9, 12, 13, 16, 10, 16, 10, 13, 20, 23);
    t25(17, 23, 17, 20, 21, 24, 18, 24, 18, 21);
    t25(19, 22, 8, 17, 9, 18, 0, 18, 0, 9);
    t25(10, 19, 1, 19, 1, 10, 11, 20, 2, 20);
    t25(2, 11, 12, 21, 3, 21, 3, 12, 13, 22);
    t25(4, 22, 4, 13, 14, 23, 5, 23, 5, 14);
    t25(15, 24, 6, 24, 6, 15, 7, 16, 7, 19);
    t25(3, 11, 5, 17, 11, 17, 9, 17, 4, 10);
    t25(6, 12, 7, 14, 4, 6, 4, 7, 12, 14);
    t25(10, 14, 6, 7, 10, 12, 6, 10, 6, 17);
    t25(12, 17, 7, 17, 7, 10, 12, 18, 7, 12);
    t24(10, 18, 12, 20, 10, 20, 10, 12);

    output[IN.dispatchThreadID.xy] = v[12];
}

```

`shaders/reflections/ssr_raycast_cs.hlsl`:

```hlsl
#include "ssr_rs.hlsli"
#include "cs.hlsli"
#include "camera.hlsli"
#include "normal.hlsli"
#include "brdf.hlsli"
#include "random.hlsli"

ConstantBuffer<ssr_raycast_cb> cb	    : register(b0);
ConstantBuffer<camera_cb> camera	    : register(b1);

Texture2D<float> depthBuffer		    : register(t0);
Texture2D<float> linearDepthBuffer	    : register(t1);
Texture2D<float3> worldNormalsRoughness	: register(t2);
Texture2D<float2> noise     		    : register(t3);
Texture2D<float2> motion			    : register(t4);


RWTexture2D<float4> output			    : register(u0);

SamplerState linearSampler			    : register(s0);
SamplerState pointSampler			    : register(s1);

static float distanceSquared(float2 a, float2 b) 
{
    a -= b;
    return dot(a, a);
}

static void swap(inout float a, inout float b)
{
    float t = a;
    a = b;
    b = t;
}

static bool intersectsDepthBuffer(float sceneZMax, float rayZMin, float rayZMax)
{
    // Increase thickness along distance. 
    float thickness = max(sceneZMax * 0.2f, 1.f);

    // Effectively remove line/tiny artifacts, mostly caused by Zbuffers precision.
    float depthScale = min(1.f, sceneZMax / 100.f);
    sceneZMax += lerp(0.05f, 0.f, depthScale);

    return (rayZMin >= sceneZMax) && (rayZMax - thickness <= sceneZMax);
}

static bool traceScreenSpaceRay(float3 rayOrigin, float3 rayDirection, float jitter, float roughness,
    out float2 hitPixel)
{
    hitPixel = float2(-1.f, -1.f);

    const float cameraNearPlane = -camera.projectionParams.x; // Now negative.
    float rayLength = ((rayOrigin.z + rayDirection.z * cb.maxDistance) > cameraNearPlane)
        ? (cameraNearPlane - rayOrigin.z) / rayDirection.z
        : cb.maxDistance;

    float3 rayEnd = rayOrigin + rayDirection * rayLength;

    // Project into screen space.
    float4 H0 = mul(camera.proj, float4(rayOrigin, 1.f));
    float4 H1 = mul(camera.proj, float4(rayEnd, 1.f));
    float k0 = 1.f / H0.w;
    float k1 = 1.f / H1.w;
    float3 Q0 = rayOrigin * k0;
    float3 Q1 = rayEnd * k1;

    Q0.z *= -1.f;
    Q1.z *= -1.f;

    // Screen space endpoints.
    float2 P0 = H0.xy * k0;
    float2 P1 = H1.xy * k1;
    P0 = P0 * float2(0.5f, -0.5f) + float2(0.5f, 0.5f);
    P1 = P1 * float2(0.5f, -0.5f) + float2(0.5f, 0.5f);
    P0.xy *= cb.dimensions;
    P1.xy *= cb.dimensions;

    // Avoid degenerate lines.
    P1 += (distanceSquared(P0, P1) < 0.0001f) ? 0.01f : 0.f;

    float2 screenDelta = P1 - P0;

    bool permute = false;
    if (abs(screenDelta.x) < abs(screenDelta.y))
    {
        permute = true;
        screenDelta = screenDelta.yx;
        P0 = P0.yx;
        P1 = P1.yx;
    }

    float stepSign = sign(screenDelta.x);
    float invdx = stepSign / screenDelta.x;

    // Derivatives of Q and k.
    float3 dQ = (Q1 - Q0) * invdx;
    float  dk = (k1 - k0) * invdx;
    float2 dP = float2(stepSign, screenDelta.y * invdx);

    float zMin = min(-rayEnd.z, -rayOrigin.z);
    float zMax = max(-rayEnd.z, -rayOrigin.z);


    // Stride based on roughness. Matte materials will recieve higher stride.
    float alphaRoughness = roughness * roughness;
    float alphaRoughnessSq = alphaRoughness * alphaRoughness;

    float strideScale = 1.f - min(1.f, -rayOrigin.z / cb.strideCutoff);
    float strideRoughnessScale = lerp(cb.minStride, cb.maxStride, min(alphaRoughnessSq, 1.f)); // Climb exponentially at extreme conditions.
    float pixelStride = 1.f + strideScale * strideRoughnessScale;

    // Scale derivatives by stride.
    dP *= pixelStride; dQ *= pixelStride; dk *= pixelStride;
    P0 += dP * jitter; Q0 += dQ * jitter; k0 += dk * jitter;

    // Start values and derivatives packed together -> only one operation needed to increase.
    float4 PQk = float4(P0, Q0.z, k0);
    float4 dPQk = float4(dP, dQ.z, dk);


    float level = 0.f;

    float prevZMaxEstimate = -rayOrigin.z;
    float rayZMin = -rayOrigin.z;
    float rayZMax = -rayOrigin.z;
    float sceneZMax = rayZMax + 100000.0f;
    
    uint stepCount = 0;
    float end = P1.x * stepSign;

    hitPixel = float2(0.f, 0.f);

    while (((PQk.x * stepSign) <= end) &&
        (stepCount < cb.numSteps) &&
        (!intersectsDepthBuffer(sceneZMax, rayZMin, rayZMax)) &&
        (sceneZMax != 0.f))
    {
        if (any(hitPixel < 0.f || hitPixel > 1.f))
        {
            return false;
        }

        rayZMin = prevZMaxEstimate;

        // Compute the value at 1/2 step into the future.
        rayZMax = (dPQk.z * 0.5f + PQk.z) / (dPQk.w * 0.5f + PQk.w);
        rayZMax = clamp(rayZMax, zMin, zMax);

        prevZMaxEstimate = rayZMax;

        if (rayZMin > rayZMax) { swap(rayZMin, rayZMax); }

        const float hzbBias = 0.05f;
        const float hzbMinStep = 0.005f;

        // A simple HZB approach based on roughness.
        level += max(hzbBias * roughness, hzbMinStep);
        level = min(level, 6.f);

        hitPixel = permute ? PQk.yx : PQk.xy;
        hitPixel *= cb.invDimensions;

        sceneZMax = linearDepthBuffer.SampleLevel(pointSampler, hitPixel, level); // Already in world units.


        PQk += dPQk;
        ++stepCount;
    }

    return intersectsDepthBuffer(sceneZMax, rayZMin, rayZMax);
}

[numthreads(SSR_BLOCK_SIZE, SSR_BLOCK_SIZE, 1)]
[RootSignature(SSR_RAYCAST_RS)]
void main(cs_input IN)
{
    float2 uv = (IN.dispatchThreadID.xy + 0.5f) * cb.invDimensions;

    const float depth = depthBuffer.SampleLevel(pointSampler, uv, 0);
    if (depth == 1.f)
    {
        output[IN.dispatchThreadID.xy] = float4(0.f, 0.f, -1.f, 0.f);
        return;
    }

    const float2 uvM = motion.SampleLevel(linearSampler, uv, 0);
    const float3 normalAndRoughness = worldNormalsRoughness.SampleLevel(linearSampler, uv + uvM, 0);

	if (all(normalAndRoughness.xy == float2(0.f, 0.f)))
	{
		// If normal is zero length, just return no hit.
		// This happens if the window is resized, because we are sampling the last frame's normals.
		output[IN.dispatchThreadID.xy] = float4(0.f, 0.f, -1.f, 0.f);
		return;
	}

    const float3 normal = unpackNormal(normalAndRoughness.xy);
    const float3 viewNormal = mul(camera.view, float4(normal, 0.f)).xyz;
    float roughness = normalAndRoughness.z;
#if 1
    if (roughness > 0.85f)
    {
        output[IN.dispatchThreadID.xy] = float4(0.f, 0.f, -1.f, 0.f);
        return;
    }
#endif

    const float3 viewPos = restoreViewSpacePosition(camera.invProj, uv, depth);
    const float3 viewDir = normalize(viewPos);

#if 1
    roughness = clamp(roughness * roughness * roughness, 0.03f, 0.97f); // Raising the roughness to a power gets rid of some flickering.

    float2 h = halton23(cb.frameIndex & 31);
    uint3 noiseDims;
    noise.GetDimensions(0, noiseDims.x, noiseDims.y, noiseDims.z);
    float2 Xi = noise.SampleLevel(linearSampler, (uv + h) * cb.dimensions / float2(noiseDims.xy), 0);
    Xi.y = lerp(Xi.y, 0.f, SSR_GGX_IMPORTANCE_SAMPLE_BIAS);

    float4 H = importanceSampleGGX(Xi, viewNormal, roughness);
    float3 reflDir = reflect(viewDir, H.xyz);
#else
    // Perfect reflection.
    float3 reflDir = reflect(viewDir, viewNormal);
    float4 H = 1.f;
#endif

#if 0
    // Don't allow reflections towards camera.
    if (dot(reflDir, -viewDir) > 0.f)
    {
        output[IN.dispatchThreadID.xy] = float4(0.f, 0.f, -1.f, 0.f);
        return;
    }
#endif


    float jitter = 0.f;// interleavedGradientNoise(IN.dispatchThreadID.xy, cb.frameIndex);

    float2 hitPixel;
    bool hit = traceScreenSpaceRay(viewPos + viewNormal * 0.005f, reflDir, jitter, roughness, hitPixel);

    float hitDepth = depthBuffer.SampleLevel(pointSampler, hitPixel, 0);
    float hitMul = hit ? 1.f : -1.f; // We pack the info whether we hit or not in the sign of the depth.
    output[IN.dispatchThreadID.xy] = float4(hitPixel, hitDepth * hitMul, H.w);
}

```

`shaders/reflections/ssr_resolve_cs.hlsl`:

```hlsl
#include "ssr_rs.hlsli"
#include "cs.hlsli"
#include "camera.hlsli"
#include "normal.hlsli"
#include "math.hlsli"
#include "brdf.hlsli"

ConstantBuffer<ssr_resolve_cb> cb	    : register(b0);
ConstantBuffer<camera_cb> camera	    : register(b1);

Texture2D<float> depthBuffer		    : register(t0);
Texture2D<float3> worldNormalsRoughness	: register(t1);
Texture2D<float4> reflection		    : register(t2);
Texture2D<float4> hdrColor  		    : register(t3);
Texture2D<float2> motion			    : register(t4);

RWTexture2D<float4> output              : register(u0);

SamplerState linearSampler			    : register(s0);
SamplerState pointSampler			    : register(s1);


static const int2 resolveOffset[] =
{
    int2(0, 0),
    int2(0, 1),
    int2(1, -1),
    int2(-1, -1),
};

// Based on https://github.com/simeonradivoev/ComputeStochasticReflections

/*
Copyright (c) 2018 Simeon Radivoev

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/


#define SSR_RESOLVE_RAD  4
#define SSR_RESOLVE_RAD2 (SSR_RESOLVE_RAD * 2)

groupshared uint groupR[(SSR_BLOCK_SIZE + SSR_RESOLVE_RAD2) * (SSR_BLOCK_SIZE + SSR_RESOLVE_RAD2)];
groupshared uint groupG[(SSR_BLOCK_SIZE + SSR_RESOLVE_RAD2) * (SSR_BLOCK_SIZE + SSR_RESOLVE_RAD2)];
groupshared uint groupB[(SSR_BLOCK_SIZE + SSR_RESOLVE_RAD2) * (SSR_BLOCK_SIZE + SSR_RESOLVE_RAD2)];
groupshared uint groupA[(SSR_BLOCK_SIZE + SSR_RESOLVE_RAD2) * (SSR_BLOCK_SIZE + SSR_RESOLVE_RAD2)];

static void packResolveData(uint index, float4 raycast, float4 color)
{
    groupR[index] = f32tof16(raycast.r) | (f32tof16(color.r) << 16);
    groupG[index] = f32tof16(raycast.g) | (f32tof16(color.g) << 16);
    groupB[index] = f32tof16(raycast.b) | (f32tof16(color.b) << 16);
    groupA[index] = f32tof16(raycast.a) | (f32tof16(color.a) << 16);
}

static void getResolveData(uint index, out float4 raycast, out float4 color)
{
    uint rr = groupR[index];
    uint gg = groupG[index];
    uint bb = groupB[index];
    uint aa = groupA[index];
    raycast = float4(f16tof32(rr), f16tof32(gg), f16tof32(bb), f16tof32(aa));
    color = float4(f16tof32(rr >> 16), f16tof32(gg >> 16), f16tof32(bb >> 16), f16tof32(aa >> 16));
}

[numthreads(SSR_BLOCK_SIZE + SSR_RESOLVE_RAD2, SSR_BLOCK_SIZE + SSR_RESOLVE_RAD2, 1)]
[RootSignature(SSR_RESOLVE_RS)]
void main(cs_input IN)
{
    const float3 luminanceWeights = float3(0.2126f, 0.7152f, 0.0722f);
    const float borderAttenuationDistance = 0.25f;



    const uint2 uvInt = (IN.groupID.xy * SSR_BLOCK_SIZE) + IN.groupThreadID.xy - SSR_RESOLVE_RAD;
    const float2 uv = (uvInt.xy + 0.5f) * cb.invDimensions;

    const float2 uvM = motion.SampleLevel(linearSampler, uv, 0);
    const float3 normalAndRoughness = worldNormalsRoughness.SampleLevel(linearSampler, uv + uvM, 0);
    const float3 normal = unpackNormal(normalAndRoughness.xy);
    const float3 N = normalize(mul(camera.view, float4(normal, 0.f)).xyz);
    const float roughness = clamp(normalAndRoughness.z, 0.03f, 0.97f);
     
    const float depth = depthBuffer.SampleLevel(pointSampler, uv, 0);
    const float3 viewPos = restoreViewSpacePosition(camera.invProj, uv, depth);
    const float3 V = normalize(-viewPos);

    const float NdotV = saturate(dot(N, V));
    const float sqrtRoughness = sqrt(roughness);
    float coneTangent = lerp(0.f, roughness * (1.f - SSR_GGX_IMPORTANCE_SAMPLE_BIAS), NdotV * sqrtRoughness);
    coneTangent *= lerp(saturate(NdotV * 2.f), 1.f, sqrtRoughness);

    float4 raycastResult = reflection.SampleLevel(linearSampler, uv, 0);
    float hit = raycastResult.z > 0.f;

    raycastResult.z = abs(raycastResult.z); // Remove sign.

    float sourceMip = clamp(log2(coneTangent * max(cb.dimensions.x, cb.dimensions.y)), 0.f, 4.f);

    const float2 m = motion.SampleLevel(linearSampler, raycastResult.xy, 0);
    float4 sceneColor = hdrColor.SampleLevel(linearSampler, raycastResult.xy + m, sourceMip);
    sceneColor.w = hit; // Store hit result.

    packResolveData(IN.groupIndex, raycastResult, sceneColor);

    GroupMemoryBarrierWithGroupSync();

    if (IN.groupThreadID.x < SSR_RESOLVE_RAD | IN.groupThreadID.y < SSR_RESOLVE_RAD | IN.groupThreadID.x >= SSR_BLOCK_SIZE + SSR_RESOLVE_RAD || IN.groupThreadID.y >= SSR_BLOCK_SIZE + SSR_RESOLVE_RAD)
    {
        return;
    }

    if (depth == 1.f)
    {
        output[uvInt.xy] = float4(0.f, 0.f, 0.f, 0.f);
        return;
    }


#if 0
    // Disable.
    float borderDist = min(1.f - max(raycastResult.x, raycastResult.y), min(raycastResult.x, raycastResult.y));
    float borderAttenuation = saturate(borderDist / borderAttenuationDistance);

    output[uvInt.xy] = float4(sceneColor.rgb, borderAttenuation * sceneColor.a);

    output[uvInt.xy] = float4(hit.xxx, 1.f);
    return;
#endif




    float4 result = 0.f.xxxx;
    float totalWeight = 0.f;

    [unroll]
    for (uint i = 0; i < 4; ++i)
    {
        int2 offset = resolveOffset[i] * 2;
        int2 neighborGroupThreadID = IN.groupThreadID.xy + offset;
        uint neighborIndex = flatten2D(neighborGroupThreadID, SSR_BLOCK_SIZE + SSR_RESOLVE_RAD2);

        float4 neighborRaycastResult;
        float4 neighborSceneColor;
        getResolveData(neighborIndex, neighborRaycastResult, neighborSceneColor);

        float2 neighborUV = neighborRaycastResult.xy;
        float neighborDepth = neighborRaycastResult.z;
        float neighborPDF = neighborRaycastResult.w;

        float neighborHit = neighborSceneColor.a;

        const float3 neighborViewPos = camera.restoreViewSpacePosition(neighborUV, neighborDepth);


        // BRDF weight.

        float3 L = normalize(neighborViewPos - viewPos);
        float3 H = normalize(L + V);

        float NdotH = saturate(dot(N, H));
        float NdotL = saturate(dot(N, L));

        float G = geometrySmith(NdotL, NdotV, roughness);
        float D = distributionGGX(NdotH, roughness);
        float specularLight = G * D * M_PI / 4.f;

        float weight = specularLight / max(neighborPDF, 0.00001f);




        float borderDist = min(1.f - max(neighborUV.x, neighborUV.y), min(neighborUV.x, neighborUV.y));
        float borderAttenuation = saturate(borderDist / borderAttenuationDistance);
       
        neighborSceneColor.a = borderAttenuation * neighborHit;
        //neighborSceneColor.rgb /= 1.f + dot(neighborSceneColor.rgb, luminanceWeights);

        result += neighborSceneColor * weight;
        totalWeight += weight;
    }

    result /= totalWeight;
    //result.rgb /= 1.f - dot(result.rgb, luminanceWeights);

    output[uvInt.xy] = max(1e-5f, result);
}

```

`shaders/reflections/ssr_temporal_cs.hlsl`:

```hlsl
#include "ssr_rs.hlsli"
#include "cs.hlsli"

// Adapted from Wicked Engine. https://github.com/turanszkij/WickedEngine

/*
Copyright (c) 2018 Wicked Engine

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
IN THE SOFTWARE.
*/


ConstantBuffer<ssr_temporal_cb> cb	: register(b0);

RWTexture2D<float4> output			: register(u0);

Texture2D<float4> currResolve	    : register(t0);
Texture2D<float4> prevResolve	    : register(t1);
Texture2D<float2> motion		    : register(t2);

SamplerState linearSampler			: register(s0);



static const int2 sampleOffset[9] = 
{ 
    int2(-1, -1), 
    int2(0, -1), 
    int2(1, -1), 
    int2(-1, 0), 
    int2(0, 0), 
    int2(1, 0), 
    int2(-1, 1), 
    int2(0, 1), 
    int2(1, 1) 
};


static float luma4(float3 color)
{
    return (color.g * 2.f) + (color.r + color.b);
}

static float hdrWeight4(float3 color, float exposure)
{
    return rcp(luma4(color) * exposure + 4.f);
}

static void resolverAABB(Texture2D<float4> currentColor, SamplerState currentSampler, float sharpness, float exposureScale, float AABBScale, float2 uv, float2 texelSize, 
    inout float4 currentMin, inout float4 currentMax, inout float4 currentAverage, inout float4 currentOutput)
{
    // Modulate Luma HDR.

    float4 sampleColors[9];
    [unroll]
    for (uint i = 0; i < 9; i++)
    {
        sampleColors[i] = currentColor.SampleLevel(currentSampler, uv + (sampleOffset[i] * texelSize), 0.f);
    }

    float sampleWeights[9];
    [unroll]
    for (uint j = 0; j < 9; j++)
    {
        sampleWeights[j] = hdrWeight4(sampleColors[j].rgb, exposureScale);
    }

    float totalWeight = 0;
    [unroll]
    for (uint k = 0; k < 9; k++)
    {
        totalWeight += sampleWeights[k];
    }
    sampleColors[4] = (sampleColors[0] * sampleWeights[0] + sampleColors[1] * sampleWeights[1] + sampleColors[2] * sampleWeights[2] + sampleColors[3] * sampleWeights[3] + sampleColors[4] * sampleWeights[4] +
        sampleColors[5] * sampleWeights[5] + sampleColors[6] * sampleWeights[6] + sampleColors[7] * sampleWeights[7] + sampleColors[8] * sampleWeights[8]) / totalWeight;

    // Variance Clipping (AABB).

    float4 m1 = 0.f;
    float4 m2 = 0.f;
    [unroll]
    for (uint x = 0; x < 9; x++)
    {
        m1 += sampleColors[x];
        m2 += sampleColors[x] * sampleColors[x];
    }

    float4 mean = m1 / 9.f;
    float4 stddev = sqrt((m2 / 9.f) - mean * mean);

    currentMin = mean - AABBScale * stddev;
    currentMax = mean + AABBScale * stddev;

    currentOutput = sampleColors[4];
    currentMin = min(currentMin, currentOutput);
    currentMax = max(currentMax, currentOutput);
    currentAverage = mean;
}

static float4 clipAABB(float3 aabb_min, float3 aabb_max, float4 p, float4 q)
{
    float3 p_clip = 0.5f * (aabb_max + aabb_min);
    float3 e_clip = 0.5f * (aabb_max - aabb_min) + 0.00000001f;

    float4 v_clip = q - float4(p_clip, p.w);
    float3 v_unit = v_clip.xyz / e_clip;
    float3 a_unit = abs(v_unit);
    float ma_unit = max(a_unit.x, max(a_unit.y, a_unit.z));

    if (ma_unit > 1.f)
    {
        return float4(p_clip, p.w) + v_clip / ma_unit;
    }
    else
    {
        return q; // Point inside AABB.
    }
}

[numthreads(SSR_BLOCK_SIZE, SSR_BLOCK_SIZE, 1)]
[RootSignature(SSR_TEMPORAL_RS)]
void main(cs_input IN)
{
    const float2 uv = (IN.dispatchThreadID.xy + 0.5f) * cb.invDimensions;

#if 0
    // Disable.
    output[IN.dispatchThreadID.xy] = currResolve.SampleLevel(linearSampler, uv, 0.f);
    return;
#endif


    const float2 m = motion.SampleLevel(linearSampler, uv, 0);
    const float2 prevUV = uv + m;

    float4 prev = prevResolve.SampleLevel(linearSampler, prevUV, 0);


    float4 current = 0.f.xxxx;
    float4 currentMin, currentMax, currentAverage;
    resolverAABB(currResolve, linearSampler, 0.f, 10.f, 3.f, uv, cb.invDimensions, currentMin, currentMax, currentAverage, current);

    prev.xyz = clipAABB(currentMin.xyz, currentMax.xyz, clamp(currentAverage, currentMin, currentMax), prev).xyz;
    prev.a = clamp(prev.a, currentMin.a, currentMax.a);



    float blendFinal = lerp(0.85f, 0.98f, saturate(1.f - length(m) * 100.f));

    float4 result = lerp(current, prev, blendFinal);
    output[IN.dispatchThreadID.xy] = max(0, result);
}

```

`shaders/rs/bitonic_sort_rs.hlsli`:

```hlsli
#ifndef BITONIC_SORT_RS_HLSLI
#define BITONIC_SORT_RS_HLSLI

//
// Copyright(c) 2013 - 2015 Microsoft
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files(the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
// Developed by Minigraph
//
// Author:  James Stanard 
//


struct bitonic_sort_cb
{
	uint32 maxNumIterations;
	uint32 counterOffset;
#if defined(BITONIC_SORT_UINT)
	uint32 nullItem;
#elif defined(BITONIC_SORT_FLOAT)
	float nullItem;
#elif !defined(HLSL)
	union
	{
		uint32 nullUint;
		float nullFloat;
	};
#endif
};

struct bitonic_sort_kj_cb
{
	uint32 k; // k >= 4096.
	uint32 j; // j >= 2048 && j < k.
};

#define BITONIC_SORT_RS \
	"RootConstants(num32BitConstants=3, b0), " \
    "UAV(u0), " \
    "UAV(u1), " \
    "SRV(t0), " \
	"RootConstants(num32BitConstants=2, b1)"


#define BITONIC_SORT_RS_CB					0
#define BITONIC_SORT_RS_DISPATCH			1 // For start shader.
#define BITONIC_SORT_RS_SORT_BUFFER			1 // For the others.
#define BITONIC_SORT_RS_COMPARISON_BUFFER	2 // If sorting with separate float comparison buffer.
#define BITONIC_SORT_RS_COUNTER_BUFFER		3
#define BITONIC_SORT_RS_KJ					4


#ifdef HLSL

#if defined(BITONIC_SORT_UINT)
#define key_value uint
#elif defined(BITONIC_SORT_FLOAT)
struct key_value
{
	float key;
	uint value;
};
#endif

// Takes Value and widens it by one bit at the location of the bit
// in the mask.  A one is inserted in the space. OneBitMask must
// have one and only one bit set.
static inline uint insertOneBit(uint value, uint oneBitMask)
{
	uint mask = oneBitMask - 1;
	return (value & ~mask) << 1 | (value & mask) | oneBitMask;
}

// Determines if two sort keys should be swapped in the list.  NullItem is
// either 0 or 0xffffffff.  XOR with the NullItem will either invert the bits
// (effectively a negation) or leave the bits alone.  When the the NullItem is
// 0, we are sorting descending, so when A < B, they should swap.  For an
// ascending sort, ~A < ~B should swap.
static inline bool shouldSwapUint(uint a, uint b, uint nullItem)
{
    return (a ^ nullItem) < (b ^ nullItem);
}

static inline bool shouldSwapFloat(float a, float b, bool ascending)
{
	return (a > b) == ascending;
}

//static inline bool shouldSwapHalf(uint a, uint b, bool ascending)
//{
//	float af = f16tof32(a >> 16);
//	float bf = f16tof32(b >> 16);
//	return shouldSwapFloat(af, bf, ascending);
//}

#endif


#endif

```

`shaders/rs/default_pbr_rs.hlsli`:

```hlsli
#ifndef DEFAULT_PBR_RS_HLSLI
#define DEFAULT_PBR_RS_HLSLI

#include "transform.hlsli"

#define DEFAULT_PBR_RS \
    "RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT |" \
    "DENY_HULL_SHADER_ROOT_ACCESS |" \
    "DENY_DOMAIN_SHADER_ROOT_ACCESS |" \
    "DENY_GEOMETRY_SHADER_ROOT_ACCESS)," \
    "SRV(t0, visibility=SHADER_VISIBILITY_VERTEX), " \
    "RootConstants(num32BitConstants=6, b0, space=1, visibility=SHADER_VISIBILITY_PIXEL),"  \
    "CBV(b1, space=1), " \
    "CBV(b2, space=1, visibility=SHADER_VISIBILITY_PIXEL),"  \
    "DescriptorTable(SRV(t0, numDescriptors=4, space=1), visibility=SHADER_VISIBILITY_PIXEL), " \
    "DescriptorTable(SRV(t0, space=2, numDescriptors=17), visibility=SHADER_VISIBILITY_PIXEL), " \
    "StaticSampler(s0," \
        "addressU = TEXTURE_ADDRESS_WRAP," \
        "addressV = TEXTURE_ADDRESS_WRAP," \
        "addressW = TEXTURE_ADDRESS_WRAP," \
        "filter = FILTER_ANISOTROPIC," \
        "visibility=SHADER_VISIBILITY_PIXEL)," \
    "StaticSampler(s1," \
        "addressU = TEXTURE_ADDRESS_CLAMP," \
        "addressV = TEXTURE_ADDRESS_CLAMP," \
        "addressW = TEXTURE_ADDRESS_CLAMP," \
        "filter = FILTER_ANISOTROPIC," \
        "visibility=SHADER_VISIBILITY_PIXEL)," \
    "StaticSampler(s2," \
        "addressU = TEXTURE_ADDRESS_CLAMP," \
        "addressV = TEXTURE_ADDRESS_CLAMP," \
        "addressW = TEXTURE_ADDRESS_CLAMP," \
        "filter = FILTER_COMPARISON_MIN_MAG_LINEAR_MIP_POINT," \
        "visibility=SHADER_VISIBILITY_PIXEL)"

#define DEFAULT_PBR_RS_TRANSFORM            0
#define DEFAULT_PBR_RS_MATERIAL             1
#define DEFAULT_PBR_RS_CAMERA               2
#define DEFAULT_PBR_RS_LIGHTING             3
#define DEFAULT_PBR_RS_PBR_TEXTURES         4
#define DEFAULT_PBR_RS_FRAME_CONSTANTS      5


#endif


```

`shaders/rs/depth_only_rs.hlsli`:

```hlsli
#ifndef DEPTH_ONLY_RS_HLSLI
#define DEPTH_ONLY_RS_HLSLI

struct shadow_transform_cb
{
    mat4 mvp;
};

struct point_shadow_cb
{
    vec3 lightPosition;
    float maxDistance;
    float flip;
};

struct depth_only_object_id_cb
{
    uint32 id;
};

struct depth_only_camera_jitter_cb
{
    vec2 jitter;
    vec2 prevFrameJitter;
};

struct depth_only_transform_cb
{
    mat4 mvp;
    mat4 prevFrameMVP;
};

#define SHADOW_RS \
    "RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT |" \
    "DENY_HULL_SHADER_ROOT_ACCESS |" \
    "DENY_DOMAIN_SHADER_ROOT_ACCESS |" \
    "DENY_GEOMETRY_SHADER_ROOT_ACCESS |" \
    "DENY_PIXEL_SHADER_ROOT_ACCESS)," \
    "SRV(t0, visibility=SHADER_VISIBILITY_VERTEX), " \
    "RootConstants(num32BitConstants=16, b0, visibility=SHADER_VISIBILITY_VERTEX)"

#define POINT_SHADOW_RS \
    "RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT |" \
    "DENY_HULL_SHADER_ROOT_ACCESS |" \
    "DENY_DOMAIN_SHADER_ROOT_ACCESS |" \
    "DENY_GEOMETRY_SHADER_ROOT_ACCESS |" \
    "DENY_PIXEL_SHADER_ROOT_ACCESS)," \
    "SRV(t0, visibility=SHADER_VISIBILITY_VERTEX), " \
    "RootConstants(num32BitConstants=5, b0, visibility=SHADER_VISIBILITY_VERTEX), " \

#define DEPTH_ONLY_RS \
    "RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT |" \
    "DENY_HULL_SHADER_ROOT_ACCESS |" \
    "DENY_DOMAIN_SHADER_ROOT_ACCESS |" \
    "DENY_GEOMETRY_SHADER_ROOT_ACCESS)," \
    "SRV(t0, visibility=SHADER_VISIBILITY_VERTEX), " \
    "SRV(t1, visibility=SHADER_VISIBILITY_VERTEX), " \
    "SRV(t2, visibility=SHADER_VISIBILITY_VERTEX), " \
    "CBV(b0, space=1)"

#define ALPHA_CUTOUT_DEPTH_ONLY_RS \
    DEPTH_ONLY_RS ", " \
    "DescriptorTable(SRV(t0, numDescriptors=1, space=1), visibility=SHADER_VISIBILITY_PIXEL), " \
    "StaticSampler(s0," \
        "addressU = TEXTURE_ADDRESS_WRAP," \
        "addressV = TEXTURE_ADDRESS_WRAP," \
        "addressW = TEXTURE_ADDRESS_WRAP," \
        "filter = FILTER_MIN_MAG_LINEAR_MIP_POINT," \
        "visibility=SHADER_VISIBILITY_PIXEL)"

#define DEPTH_ONLY_RS_TRANSFORM             0
#define DEPTH_ONLY_RS_PREV_FRAME_TRANSFORM  1
#define DEPTH_ONLY_RS_OBJECT_ID             2
#define DEPTH_ONLY_RS_CAMERA                3
#define DEPTH_ONLY_RS_ALPHA_TEXTURE         4

#define SHADOW_RS_TRANSFORMS                0
#define SHADOW_RS_VIEWPROJ                  1
#define POINT_SHADOW_RS_CB                  1

#endif


```

`shaders/rs/grass_rs.hlsli`:

```hlsli
#ifndef GRASS_RS_HLSLI
#define GRASS_RS_HLSLI

#include "indirect.hlsli"

struct grass_blade
{
    vec3 position;
    uint32 misc; // Type, lod
    vec2 facing; // sin(angle), cos(angle)
    float height;
    uint32 windStrength_prevWindStrength;

#ifdef HLSL
    void initialize(float3 position_, float angle, uint type, float lod, float height_, float windStrength, float prevFrameWindStrength)
    {
        position = position_;
        sincos(angle, facing.x, facing.y);
        misc = (type << 16) | f32tof16(lod);
        height = height_;
        windStrength_prevWindStrength = (f32tof16(windStrength) << 16) | f32tof16(prevFrameWindStrength);
    }

    uint type()
    {
        return misc >> 16;
    }

    float lod()
    {
        return f16tof32(misc & 0xFFFF);
    }

    float windStrength()
    {
        return f16tof32(windStrength_prevWindStrength >> 16);
    }

    float prevFrameWindStrength()
    {
        return f16tof32(windStrength_prevWindStrength & 0xFFFF);
    }
#endif
};

struct grass_draw
{
    D3D12_DRAW_ARGUMENTS draw;
};


struct grass_cb
{
    vec2 windDirection;

    uint32 numVertices;
    float halfWidth;
};

#ifdef NO_DEPTH_PREPASS
#define GRASS_OBJECT_ID ", RootConstants(num32BitConstants=1, b3, visibility=SHADER_VISIBILITY_PIXEL)"
#else
#define GRASS_OBJECT_ID ""
#endif


#define GRASS_RS \
	"RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT |" \
    "DENY_HULL_SHADER_ROOT_ACCESS |" \
    "DENY_DOMAIN_SHADER_ROOT_ACCESS |" \
    "DENY_GEOMETRY_SHADER_ROOT_ACCESS)," \
    "RootConstants(num32BitConstants=4, b0, visibility=SHADER_VISIBILITY_VERTEX), " \
    "SRV(t0, visibility=SHADER_VISIBILITY_VERTEX), " \
    "CBV(b1), " \
    "CBV(b2, visibility=SHADER_VISIBILITY_PIXEL), " \
    "DescriptorTable(SRV(t0, space=2, numDescriptors=7), visibility=SHADER_VISIBILITY_PIXEL), " \
	"StaticSampler(s0," \
        "addressU = TEXTURE_ADDRESS_CLAMP," \
        "addressV = TEXTURE_ADDRESS_CLAMP," \
        "addressW = TEXTURE_ADDRESS_CLAMP," \
        "filter = FILTER_MIN_MAG_MIP_LINEAR," \
        "visibility=SHADER_VISIBILITY_PIXEL), " \
    "StaticSampler(s1," \
        "addressU = TEXTURE_ADDRESS_CLAMP," \
        "addressV = TEXTURE_ADDRESS_CLAMP," \
        "addressW = TEXTURE_ADDRESS_CLAMP," \
        "filter = FILTER_COMPARISON_MIN_MAG_LINEAR_MIP_POINT," \
        "visibility=SHADER_VISIBILITY_PIXEL)" \
    GRASS_OBJECT_ID

#define GRASS_RS_CB                 0
#define GRASS_RS_BLADES             1
#define GRASS_RS_CAMERA             2
#define GRASS_RS_LIGHTING           3
#define GRASS_RS_FRAME_CONSTANTS    4
#define GRASS_RS_OBJECT_ID          5


#define GRASS_DEPTH_ONLY_RS \
    "RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT |" \
    "DENY_HULL_SHADER_ROOT_ACCESS |" \
    "DENY_DOMAIN_SHADER_ROOT_ACCESS |" \
    "DENY_GEOMETRY_SHADER_ROOT_ACCESS)," \
    "RootConstants(num32BitConstants=7, b0, visibility=SHADER_VISIBILITY_VERTEX), " \
    "RootConstants(num32BitConstants=1, b1, visibility=SHADER_VISIBILITY_VERTEX), " \
    "CBV(b0, space=1), " \
    "SRV(t0, visibility=SHADER_VISIBILITY_VERTEX)"

#define GRASS_DEPTH_ONLY_RS_CB              0
#define GRASS_DEPTH_ONLY_RS_OBJECT_ID       1
#define GRASS_DEPTH_ONLY_RS_CAMERA          2
#define GRASS_DEPTH_ONLY_RS_BLADES          3



#define GRASS_GENERATION_BLOCK_SIZE 8


struct grass_generation_common_cb
{
    vec4 frustumPlanes[6];
    vec3 cameraPosition;
    float chunkSize;
    float amplitudeScale;
    float uvScale;

    float lodChangeStartDistance;
    float lodChangeEndDistance;

    float cullStartDistance;
    float cullEndDistance;

    float time;
    float prevFrameTime;
    float baseHeight;
};

struct grass_generation_cb
{
    vec3 chunkCorner;
    uint32 lodIndex;
};

#define GRASS_GENERATION_RS \
	"RootConstants(num32BitConstants=4, b0), " \
	"CBV(b1), " \
	"DescriptorTable(SRV(t0, numDescriptors=2), UAV(u0, numDescriptors=3)), " \
    "StaticSampler(s0," \
        "addressU = TEXTURE_ADDRESS_CLAMP," \
        "addressV = TEXTURE_ADDRESS_CLAMP," \
        "addressW = TEXTURE_ADDRESS_CLAMP," \
        "filter = FILTER_MIN_MAG_MIP_LINEAR)"

#define GRASS_GENERATION_RS_CB        0
#define GRASS_GENERATION_RS_COMMON    1
#define GRASS_GENERATION_RS_RESOURCES 2



#define GRASS_CREATE_DRAW_CALLS_BLOCK_SIZE 32


struct grass_create_draw_calls_cb
{
    uint32 maxNumInstances;
};

#define GRASS_CREATE_DRAW_CALLS_RS \
    "RootConstants(num32BitConstants=1, b0), " \
	"UAV(u0), " \
	"SRV(t0)"

#define GRASS_CREATE_DRAW_CALLS_RS_CB			    0
#define GRASS_CREATE_DRAW_CALLS_RS_OUTPUT			1
#define GRASS_CREATE_DRAW_CALLS_RS_MESH_COUNTS		2


#endif

```

`shaders/rs/light_culling_rs.hlsli`:

```hlsli
#ifndef LIGHT_CULLING_H
#define LIGHT_CULLING_H

#define LIGHT_CULLING_TILE_SIZE 16
#define MAX_NUM_LIGHTS_PER_TILE 256 // Total for point and spot lights. Per tile.
#define MAX_NUM_TOTAL_DECALS 256   // Total per frame (not per tile).

#define NUM_DECAL_BUCKETS (MAX_NUM_TOTAL_DECALS / 32)
#define TILE_LIGHT_OFFSET (NUM_DECAL_BUCKETS)

#define MAX_NUM_INDICES_PER_TILE (MAX_NUM_LIGHTS_PER_TILE + NUM_DECAL_BUCKETS)

struct light_culling_frustum_plane
{
    vec3 N;
    float d;
};

struct light_culling_view_frustum
{
    light_culling_frustum_plane planes[4]; // Left, right, top, bottom frustum planes.
};

struct frusta_cb
{
    uint32 numThreadsX;
    uint32 numThreadsY;
};

struct light_culling_cb
{
    uint32 numThreadGroupsX;
    uint32 numPointLights;
    uint32 numSpotLights;
    uint32 numDecals;
};

#define WORLD_SPACE_TILED_FRUSTA_RS \
    "RootFlags(0), " \
    "CBV(b0), " \
    "RootConstants(b1, num32BitConstants = 2), " \
    "UAV(u0)"


#define LIGHT_CULLING_RS \
    "RootFlags(0), " \
    "CBV(b0), " \
    "RootConstants(b1, num32BitConstants = 4), " \
    "DescriptorTable( SRV(t0, numDescriptors = 5), UAV(u0, numDescriptors = 3) )"


#define WORLD_SPACE_TILED_FRUSTA_RS_CAMERA      0
#define WORLD_SPACE_TILED_FRUSTA_RS_CB          1
#define WORLD_SPACE_TILED_FRUSTA_RS_FRUSTA_UAV  2

#define LIGHT_CULLING_RS_CAMERA                 0
#define LIGHT_CULLING_RS_CB                     1
#define LIGHT_CULLING_RS_SRV_UAV                2

#endif

```

`shaders/rs/light_probe_rs.hlsli`:

```hlsli
#ifndef LIGHT_PROBE_RS_H
#define LIGHT_PROBE_RS_H

#include "../common/light_probe.hlsli"


#define LIGHT_PROBE_BLOCK_SIZE LIGHT_PROBE_TOTAL_RESOLUTION


struct light_probe_grid_visualization_cb
{
	mat4 mvp;
	vec2 uvScale;
	float cellSize;
	uint32 countX;
	uint32 countY;
};

#define LIGHT_PROBE_GRID_VISUALIZATION_RS \
	"RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT |" \
	"DENY_HULL_SHADER_ROOT_ACCESS |" \
	"DENY_DOMAIN_SHADER_ROOT_ACCESS |" \
	"DENY_GEOMETRY_SHADER_ROOT_ACCESS)," \
	"RootConstants(num32BitConstants=32, b0, visibility=SHADER_VISIBILITY_VERTEX), " \
	"DescriptorTable(SRV(t0, numDescriptors=1), visibility=SHADER_VISIBILITY_PIXEL), " \
	"StaticSampler(s0," \
        "addressU = TEXTURE_ADDRESS_CLAMP," \
        "addressV = TEXTURE_ADDRESS_CLAMP," \
        "addressW = TEXTURE_ADDRESS_CLAMP," \
        "filter = FILTER_MIN_MAG_MIP_LINEAR," \
        "visibility=SHADER_VISIBILITY_PIXEL)"

#define LIGHT_PROBE_GRID_VISUALIZATION_RS_CB			0
#define LIGHT_PROBE_GRID_VISUALIZATION_RS_IRRADIANCE	1



struct light_probe_ray_visualization_cb
{
	mat4 mvp;
	float cellSize;
	uint32 countX;
	uint32 countY;
};

#define LIGHT_PROBE_RAY_VISUALIZATION_RS \
	"RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT |" \
	"DENY_HULL_SHADER_ROOT_ACCESS |" \
	"DENY_DOMAIN_SHADER_ROOT_ACCESS |" \
	"DENY_GEOMETRY_SHADER_ROOT_ACCESS)," \
	"RootConstants(num32BitConstants=32, b0, visibility=SHADER_VISIBILITY_VERTEX), " \
	"DescriptorTable(SRV(t0, numDescriptors=2), visibility=SHADER_VISIBILITY_VERTEX)"

#define LIGHT_PROBE_RAY_VISUALIZATION_RS_CB			0
#define LIGHT_PROBE_RAY_VISUALIZATION_RS_RAYS		1



#define LIGHT_PROBE_TEST_SAMPLE_RS \
	"RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT |" \
	"DENY_HULL_SHADER_ROOT_ACCESS |" \
	"DENY_DOMAIN_SHADER_ROOT_ACCESS |" \
	"DENY_GEOMETRY_SHADER_ROOT_ACCESS)," \
	"RootConstants(num32BitConstants=32, b0, visibility=SHADER_VISIBILITY_VERTEX), " \
	"RootConstants(num32BitConstants=8, b1, visibility=SHADER_VISIBILITY_PIXEL), " \
	"DescriptorTable(SRV(t0, numDescriptors=2), visibility=SHADER_VISIBILITY_PIXEL), " \
	"StaticSampler(s0," \
        "addressU = TEXTURE_ADDRESS_CLAMP," \
        "addressV = TEXTURE_ADDRESS_CLAMP," \
        "addressW = TEXTURE_ADDRESS_CLAMP," \
        "filter = FILTER_MIN_MAG_MIP_LINEAR," \
        "visibility=SHADER_VISIBILITY_PIXEL)"

#define LIGHT_PROBE_TEST_SAMPLE_RS_TRANSFORM	0
#define LIGHT_PROBE_TEST_SAMPLE_RS_GRID			1
#define LIGHT_PROBE_TEST_SAMPLE_RS_TEXTURES		2




struct light_probe_update_cb
{
	uint32 countX;
	uint32 countY;
};

#define LIGHT_PROBE_UPDATE_RS \
	"RootFlags(0)," \
	"RootConstants(num32BitConstants=2, b0), " \
	"DescriptorTable(SRV(t0, numDescriptors=2), UAV(u0, numDescriptors=1))"

#define LIGHT_PROBE_UPDATE_RS_CB				0
#define LIGHT_PROBE_UPDATE_RS_RAYTRACE_RESULTS	1




struct light_probe_trace_cb
{
	mat4 rayRotation;
	light_probe_grid_cb grid;
	uint32 sampleSkyFromTexture;
};

#endif

```

`shaders/rs/outline_rs.hlsli`:

```hlsli
#ifndef OUTLINE_RS_HLSLI
#define OUTLINE_RS_HLSLI

struct outline_marker_cb
{
    mat4 mvp;
};

struct outline_drawer_cb
{
    int width, height;
};

#define OUTLINE_MARKER_RS \
    "RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT |" \
    "DENY_HULL_SHADER_ROOT_ACCESS |" \
    "DENY_DOMAIN_SHADER_ROOT_ACCESS |" \
    "DENY_GEOMETRY_SHADER_ROOT_ACCESS |" \
    "DENY_PIXEL_SHADER_ROOT_ACCESS)," \
    "RootConstants(num32BitConstants=16, b0, visibility=SHADER_VISIBILITY_VERTEX)"

#define OUTLINE_DRAWER_RS \
    "RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT |" \
    "DENY_HULL_SHADER_ROOT_ACCESS |" \
    "DENY_DOMAIN_SHADER_ROOT_ACCESS |" \
    "DENY_GEOMETRY_SHADER_ROOT_ACCESS)," \
    "RootConstants(b0, num32BitConstants = 2, visibility=SHADER_VISIBILITY_PIXEL), " \
    "DescriptorTable(SRV(t0, numDescriptors=1), visibility=SHADER_VISIBILITY_PIXEL)"


#define OUTLINE_RS_MVP	    0

#define OUTLINE_RS_CB       0
#define OUTLINE_RS_STENCIL  1

#endif


```

`shaders/rs/particles_rs.hlsli`:

```hlsli
#ifndef PARTICLES_RS_HLSLI
#define PARTICLES_RS_HLSLI

#include "indirect.hlsli"

struct particle_dispatch
{
	D3D12_DISPATCH_ARGUMENTS emit;
	D3D12_DISPATCH_ARGUMENTS simulate;
};

struct particle_draw
{
	// If you add stuff here, update the command signature creation.
	D3D12_DRAW_INDEXED_ARGUMENTS arguments;
};

struct particle_counters
{
	uint32 numDeadParticles;
	uint32 numAliveParticlesThisFrame;
	float emitRateAccum;
	uint32 newParticles;
};

#define PARTICLES_EMIT_BLOCK_SIZE		256
#define PARTICLES_SIMULATE_BLOCK_SIZE	256



struct particle_start_cb
{
	float newParticlesRequest;
	uint32 indexCount;
	uint32 startIndex;
	uint32 baseVertex;
};

struct particle_sim_cb
{
	float dt;
};

#ifndef USER_PARTICLE_SIMULATION_RS
#define USER_APPEND_PARTICLE_SIMULATION_RS ""
#else
#define USER_APPEND_PARTICLE_SIMULATION_RS USER_PARTICLE_SIMULATION_RS ", "
#endif

#define PARTICLE_COMPUTE_COMMON  \
    "UAV(u0, space=1), " \
    "UAV(u1, space=1), " \
    "UAV(u2, space=1), " \
    "UAV(u3, space=1), " \
    "UAV(u4, space=1), " \
    "UAV(u5, space=1), " \
    "UAV(u6, space=1), " \
    "UAV(u7, space=1)"

#define PARTICLE_START_RS \
	USER_APPEND_PARTICLE_SIMULATION_RS \
	"RootConstants(num32BitConstants=4, b0, space=1), " \
	PARTICLE_COMPUTE_COMMON

#define PARTICLE_SIM_RS \
	USER_APPEND_PARTICLE_SIMULATION_RS \
	"RootConstants(num32BitConstants=1, b0, space=1), " \
	PARTICLE_COMPUTE_COMMON
	

#define PARTICLE_COMPUTE_RS_CB					0
#define PARTICLE_COMPUTE_RS_DISPATCH_INFO		1
#define PARTICLE_COMPUTE_RS_DRAW_INFO			2
#define PARTICLE_COMPUTE_RS_COUNTERS			3
#define PARTICLE_COMPUTE_RS_PARTICLES			4
#define PARTICLE_COMPUTE_RS_DEAD_LIST			5
#define PARTICLE_COMPUTE_RS_CURRENT_ALIVE		6
#define PARTICLE_COMPUTE_RS_NEW_ALIVE			7
#define PARTICLE_COMPUTE_RS_SORT_KEY			8

#define PARTICLE_COMPUTE_RS_COUNT				(PARTICLE_COMPUTE_RS_SORT_KEY + 1)





#ifndef USER_PARTICLE_RENDERING_RS
#define USER_APPEND_PARTICLE_RENDERING_RS ""
#else
#define USER_APPEND_PARTICLE_RENDERING_RS USER_PARTICLE_RENDERING_RS ", "
#endif

#define PARTICLES_RENDERING_RS \
	"RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT |" \
    "DENY_HULL_SHADER_ROOT_ACCESS |" \
    "DENY_DOMAIN_SHADER_ROOT_ACCESS |" \
    "DENY_GEOMETRY_SHADER_ROOT_ACCESS), " \
	USER_APPEND_PARTICLE_RENDERING_RS \
	"SRV(t0, space=1, visibility=SHADER_VISIBILITY_VERTEX), " \
	"SRV(t1, space=1, visibility=SHADER_VISIBILITY_VERTEX)"


#define PARTICLE_RENDERING_RS_PARTICLES			0
#define PARTICLE_RENDERING_RS_ALIVE_LIST		1

#define PARTICLE_RENDERING_RS_COUNT				(PARTICLE_RENDERING_RS_ALIVE_LIST + 1)


#endif


```

`shaders/rs/post_processing_rs.hlsli`:

```hlsli
#ifndef POST_PROCESSING_RS_HLSLI
#define POST_PROCESSING_RS_HLSLI

#define POST_PROCESSING_BLOCK_SIZE 16



// ----------------------------------------
// BLOOM
// ----------------------------------------

struct bloom_threshold_cb
{
    vec2 invDimensions;
    float threshold;
};

#define BLOOM_THRESHOLD_RS \
    "RootFlags(0), " \
    "RootConstants(num32BitConstants=3, b0),"  \
    "StaticSampler(s0," \
	    "addressU = TEXTURE_ADDRESS_CLAMP," \
	    "addressV = TEXTURE_ADDRESS_CLAMP," \
	    "addressW = TEXTURE_ADDRESS_CLAMP," \
	    "filter = FILTER_MIN_MAG_MIP_LINEAR)," \
    "DescriptorTable( UAV(u0, numDescriptors = 1), SRV(t0, numDescriptors = 1) )"


#define BLOOM_THRESHOLD_RS_CB           0
#define BLOOM_THRESHOLD_RS_TEXTURES     1


struct bloom_combine_cb
{
    vec2 invDimensions;
    float strength;
};

#define BLOOM_COMBINE_RS \
    "RootFlags(0), " \
    "RootConstants(num32BitConstants=3, b0),"  \
    "StaticSampler(s0," \
	    "addressU = TEXTURE_ADDRESS_CLAMP," \
	    "addressV = TEXTURE_ADDRESS_CLAMP," \
	    "addressW = TEXTURE_ADDRESS_CLAMP," \
	    "filter = FILTER_MIN_MAG_MIP_LINEAR)," \
    "DescriptorTable( UAV(u0, numDescriptors = 1), SRV(t0, numDescriptors = 2) )"


#define BLOOM_COMBINE_RS_CB           0
#define BLOOM_COMBINE_RS_TEXTURES     1




// ----------------------------------------
// BLIT
// ----------------------------------------

struct blit_cb
{
    vec2 invDimensions;
};

#define BLIT_RS \
    "RootFlags(0), " \
    "RootConstants(b0, num32BitConstants = 2), " \
    "DescriptorTable( UAV(u0, numDescriptors = 1), SRV(t0, numDescriptors = 1) )," \
    "StaticSampler(s0," \
        "addressU = TEXTURE_ADDRESS_CLAMP," \
        "addressV = TEXTURE_ADDRESS_CLAMP," \
        "addressW = TEXTURE_ADDRESS_CLAMP," \
        "filter = FILTER_MIN_MAG_MIP_LINEAR)"


#define BLIT_RS_CB                    0
#define BLIT_RS_TEXTURES              1



// ----------------------------------------
// GAUSSIAN BLUR
// ----------------------------------------

struct gaussian_blur_cb
{
    vec2 invDimensions;
    float stepScale;
    uint32 directionAndSourceMipLevel; // Direction (0 is horizontal, 1 is vertical) | sourceMipLevel.
};

#define GAUSSIAN_BLUR_RS \
    "RootFlags(0), " \
    "RootConstants(b0, num32BitConstants = 4), " \
    "DescriptorTable( UAV(u0, numDescriptors = 1), SRV(t0, numDescriptors = 1) )," \
    "StaticSampler(s0," \
        "addressU = TEXTURE_ADDRESS_CLAMP," \
        "addressV = TEXTURE_ADDRESS_CLAMP," \
        "addressW = TEXTURE_ADDRESS_CLAMP," \
        "filter = FILTER_MIN_MAG_MIP_LINEAR)"


#define GAUSSIAN_BLUR_RS_CB           0
#define GAUSSIAN_BLUR_RS_TEXTURES     1



// ----------------------------------------
// MORPHOLOGY
// ----------------------------------------

struct morphology_cb
{
    uint32 radius;
    uint32 direction; // 0 = x, 1 = y.
    uint32 dimInDirection;
};

#define MORPHOLOGY_MAX_RADIUS 16
#define MORPHOLOGY_BLOCK_SIZE 128

#define MORPHOLOGY_RS \
    "RootFlags(0), " \
    "RootConstants(b0, num32BitConstants = 3), " \
    "DescriptorTable( UAV(u0, numDescriptors = 1), SRV(t0, numDescriptors = 1) )"


#define MORPHOLOGY_RS_CB              0
#define MORPHOLOGY_RS_TEXTURES        1



// ----------------------------------------
// HIERARCHICAL LINEAR DEPTH
// ----------------------------------------

struct hierarchical_linear_depth_cb
{
    vec4 projectionParams;
    vec2 invDimensions;
};

#define HIERARCHICAL_LINEAR_DEPTH_RS \
    "RootFlags(0), " \
    "RootConstants(b0, num32BitConstants = 8), " \
    "DescriptorTable( UAV(u0, numDescriptors = 6), SRV(t0, numDescriptors = 1) )," \
    "StaticSampler(s0," \
        "addressU = TEXTURE_ADDRESS_CLAMP," \
        "addressV = TEXTURE_ADDRESS_CLAMP," \
        "addressW = TEXTURE_ADDRESS_CLAMP," \
        "filter = FILTER_MIN_MAG_MIP_LINEAR)"


#define HIERARCHICAL_LINEAR_DEPTH_RS_CB           0
#define HIERARCHICAL_LINEAR_DEPTH_RS_TEXTURES     1



// ----------------------------------------
// TEMPORAL ANTI-ALIASING
// ----------------------------------------

struct taa_cb
{
    vec4 projectionParams;
    vec2 dimensions;
};

#define TAA_RS \
    "RootFlags(0), " \
    "RootConstants(num32BitConstants=8, b0),"  \
    "DescriptorTable( UAV(u0, numDescriptors = 1), SRV(t0, numDescriptors = 4) ), " \
    "StaticSampler(s0," \
        "addressU = TEXTURE_ADDRESS_CLAMP," \
        "addressV = TEXTURE_ADDRESS_CLAMP," \
        "addressW = TEXTURE_ADDRESS_CLAMP," \
        "filter = FILTER_MIN_MAG_MIP_LINEAR)"

#define TAA_RS_CB               0
#define TAA_RS_TEXTURES         1



// ----------------------------------------
// HBAO
// ----------------------------------------

struct hbao_cb
{
    uint32 screenWidth;
    uint32 screenHeight;
    float depthBufferMipLevel;
    uint32 numRays;
    vec2 rayDeltaRotation;
    uint32 maxNumStepsPerRay;
    float radius;
    float strength;
    float seed;
};

#define HBAO_RS \
    "RootFlags(0), " \
    "RootConstants(num32BitConstants=10, b0),"  \
    "CBV(b1), " \
    "DescriptorTable( UAV(u0, numDescriptors = 1), SRV(t0, numDescriptors = 1) ), " \
    "StaticSampler(s0," \
        "addressU = TEXTURE_ADDRESS_CLAMP," \
        "addressV = TEXTURE_ADDRESS_CLAMP," \
        "addressW = TEXTURE_ADDRESS_CLAMP," \
        "filter = FILTER_MIN_MAG_MIP_LINEAR)"

#define HBAO_RS_CB                  0
#define HBAO_RS_CAMERA              1
#define HBAO_RS_TEXTURES            2




// ----------------------------------------
// SCREEN-SPACE SHADOWS
// ----------------------------------------

struct sss_cb
{
    vec2 invDimensions;
    uint32 numSteps;
    float rayDistance;
    vec3 lightDirection;
    float thickness;
    float maxDistanceFromCamera;
    float distanceFadeoutRange;
    float invBorderFadeout;
    float seed;
};

#define SSS_RS \
    "RootFlags(0), " \
    "RootConstants(num32BitConstants=12, b0),"  \
    "CBV(b1), " \
    "DescriptorTable( UAV(u0, numDescriptors = 1), SRV(t0, numDescriptors = 1) )," \
    "StaticSampler(s0," \
        "addressU = TEXTURE_ADDRESS_CLAMP," \
        "addressV = TEXTURE_ADDRESS_CLAMP," \
        "addressW = TEXTURE_ADDRESS_CLAMP," \
        "filter = FILTER_MIN_MAG_MIP_POINT)"

#define SSS_RS_CB                   0
#define SSS_RS_CAMERA               1
#define SSS_RS_TEXTURES             2




// ----------------------------------------
// SHADOW BLUR
// ----------------------------------------

struct shadow_blur_cb
{
    vec2 dimensions;
    vec2 invDimensions;
};

#define SHADOW_BLUR_X_RS \
    "RootFlags(0), " \
    "RootConstants(num32BitConstants=4, b0),"  \
    "DescriptorTable( UAV(u0, numDescriptors = 1), SRV(t0, numDescriptors = 2) ), " \
    "StaticSampler(s0," \
        "addressU = TEXTURE_ADDRESS_CLAMP," \
        "addressV = TEXTURE_ADDRESS_CLAMP," \
        "addressW = TEXTURE_ADDRESS_CLAMP," \
        "filter = FILTER_MIN_MAG_MIP_POINT), " \
    "StaticSampler(s1," \
        "addressU = TEXTURE_ADDRESS_CLAMP," \
        "addressV = TEXTURE_ADDRESS_CLAMP," \
        "addressW = TEXTURE_ADDRESS_CLAMP," \
        "filter = FILTER_MIN_MAG_MIP_LINEAR)"

#define SHADOW_BLUR_Y_RS \
    "RootFlags(0), " \
    "RootConstants(num32BitConstants=4, b0),"  \
    "DescriptorTable( UAV(u0, numDescriptors = 1), SRV(t0, numDescriptors = 4) ), " \
    "StaticSampler(s0," \
        "addressU = TEXTURE_ADDRESS_CLAMP," \
        "addressV = TEXTURE_ADDRESS_CLAMP," \
        "addressW = TEXTURE_ADDRESS_CLAMP," \
        "filter = FILTER_MIN_MAG_MIP_POINT), " \
    "StaticSampler(s1," \
        "addressU = TEXTURE_ADDRESS_CLAMP," \
        "addressV = TEXTURE_ADDRESS_CLAMP," \
        "addressW = TEXTURE_ADDRESS_CLAMP," \
        "filter = FILTER_MIN_MAG_MIP_LINEAR)"

#define SHADOW_BLUR_RS_CB                  0
#define SHADOW_BLUR_RS_TEXTURES            1




// ----------------------------------------
// SPECULAR AMBIENT
// ----------------------------------------

struct specular_ambient_cb
{
    vec2 invDimensions;
};

#define SPECULAR_AMBIENT_RS \
    "RootFlags(0), " \
    "RootConstants(b0, num32BitConstants = 2), " \
    "CBV(b1), " \
    "DescriptorTable( UAV(u0, numDescriptors = 1), SRV(t0, numDescriptors = 7) )," \
    "StaticSampler(s0," \
        "addressU = TEXTURE_ADDRESS_CLAMP," \
        "addressV = TEXTURE_ADDRESS_CLAMP," \
        "addressW = TEXTURE_ADDRESS_CLAMP," \
        "filter = FILTER_MIN_MAG_MIP_LINEAR)"


#define SPECULAR_AMBIENT_RS_CB           0
#define SPECULAR_AMBIENT_RS_CAMERA       1
#define SPECULAR_AMBIENT_RS_TEXTURES     2




// ----------------------------------------
// TONEMAPPING
// ----------------------------------------

struct tonemap_cb
{
    float A;
    float B;
    float C;
    float D;
    float E;
    float F;
    float invEvaluatedLinearWhite;
    float expExposure;

    vec3 evaluate(vec3 x)
    {
        return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - (E / F);
    }

    vec3 tonemap(vec3 color)
    {
        color *= expExposure;
        return evaluate(color) * invEvaluatedLinearWhite;
    }
};

#define TONEMAP_RS \
    "RootFlags(0), " \
    "RootConstants(num32BitConstants=8, b0),"  \
    "DescriptorTable( UAV(u0, numDescriptors = 1), SRV(t0, numDescriptors = 1) )"

#define TONEMAP_RS_CB               0
#define TONEMAP_RS_TEXTURES         1




// ----------------------------------------
// PRESENT
// ----------------------------------------

#define present_sdr 0
#define present_hdr 1


struct present_cb
{
    uint32 displayMode;
    float standardNits;
    float sharpenStrength;
    uint32 offset; // x-offset | y-offset.
};

#define PRESENT_RS \
    "RootFlags(0), " \
    "RootConstants(num32BitConstants=4, b0),"  \
    "DescriptorTable( UAV(u0, numDescriptors = 1), SRV(t0, numDescriptors = 1) )"

#define PRESENT_RS_CB               0
#define PRESENT_RS_TEXTURES         1




// ----------------------------------------
// DEPTH SOBEL
// ----------------------------------------

struct depth_sobel_cb
{
    vec4 projectionParams;
    float threshold;
};

#define DEPTH_SOBEL_RS \
    "RootFlags(0), " \
    "RootConstants(num32BitConstants=8, b0),"  \
    "DescriptorTable( UAV(u0, numDescriptors = 1), SRV(t0, numDescriptors = 1) )"

#define DEPTH_SOBEL_RS_CB           0
#define DEPTH_SOBEL_RS_TEXTURES     1


#endif

```

`shaders/rs/proc_placement_rs.hlsli`:

```hlsli
#ifndef PROC_PLACEMENT_RS_HLSLI
#define PROC_PLACEMENT_RS_HLSLI

#include "indirect.hlsli"

struct placement_point
{
	vec3 position;
	uint32 meshID;
	vec3 normal;
	uint32 lod;
};

struct placement_draw
{
	uint32 transformSRVLow;
	uint32 transformSRVHigh;
	D3D12_DRAW_INDEXED_ARGUMENTS draw;
};

struct placement_transform
{
	mat4 m;
};






struct proc_placement_generate_points_cb
{
	vec4 densities;

	vec3 chunkCorner;
	float chunkSize;

	float amplitudeScale;

	float uvScale;
	
	uint32 globalMeshOffset;
	uint32 numMeshes;
};

#define PROC_PLACEMENT_GENERATE_POINTS_RS \
	"RootConstants(num32BitConstants=12, b0), " \
	"DescriptorTable(SRV(t0, numDescriptors=2), UAV(u0, numDescriptors=2)), " \
    "StaticSampler(s0," \
        "addressU = TEXTURE_ADDRESS_CLAMP," \
        "addressV = TEXTURE_ADDRESS_CLAMP," \
        "addressW = TEXTURE_ADDRESS_CLAMP," \
        "filter = FILTER_MIN_MAG_MIP_LINEAR)"

#define PROC_PLACEMENT_GENERATE_POINTS_RS_CB        0
#define PROC_PLACEMENT_GENERATE_POINTS_RS_RESOURCES 1



struct prefix_sum_cb
{
	uint32 size;
};

#define PROC_PLACEMENT_PREFIX_SUM_RS \
	"RootConstants(num32BitConstants=1, b0), " \
	"UAV(u0), " \
	"SRV(t0)"

#define PROC_PLACEMENT_PREFIX_SUM_RS_CB		0
#define PROC_PLACEMENT_PREFIX_SUM_RS_OUTPUT	1
#define PROC_PLACEMENT_PREFIX_SUM_RS_INPUT	2



#define PROC_PLACEMENT_CREATE_DRAW_CALLS_BLOCK_SIZE 32
#define PROC_PLACEMENT_CREATE_TRANSFORMS_BLOCK_SIZE 256


struct proc_placement_create_draw_calls_cb
{
	uint32 transformAddressLow;
	uint32 transformAddressHigh;
	uint32 stride;
};

#define PROC_PLACEMENT_CREATE_DRAW_CALLS_RS \
	"RootConstants(num32BitConstants=3, b0), " \
	"UAV(u0), " \
	"SRV(t0), " \
	"SRV(t1), " \
	"SRV(t2)"

#define PROC_PLACEMENT_CREATE_DRAW_CALLS_RS_CB				0
#define PROC_PLACEMENT_CREATE_DRAW_CALLS_RS_OUTPUT			1
#define PROC_PLACEMENT_CREATE_DRAW_CALLS_RS_MESH_COUNTS		2
#define PROC_PLACEMENT_CREATE_DRAW_CALLS_RS_MESH_OFFSETS	3
#define PROC_PLACEMENT_CREATE_DRAW_CALLS_RS_SUBMESH_TO_MESH	4



#define PROC_PLACEMENT_CREATE_TRANSFORMS_RS \
	"UAV(u0), " \
	"UAV(u1), " \
	"SRV(t0), " \
	"SRV(t1)"

#define PROC_PLACEMENT_CREATE_TRANSFORMS_RS_TRANSFORMS		0
#define PROC_PLACEMENT_CREATE_TRANSFORMS_RS_MESH_COUNTS		1
#define PROC_PLACEMENT_CREATE_TRANSFORMS_RS_POINTS			2
#define PROC_PLACEMENT_CREATE_TRANSFORMS_RS_MESH_OFFSETS	3



static const uint32 SAMPLE_NUM = 1024;
static const vec2 POISSON_SAMPLES[SAMPLE_NUM] =
{
vec2(0.10685437273009968f, 0.9936634109808322f),
vec2(0.1929792179126878f, 0.9972403504649794f),
vec2(0.22467249034050807f, 0.9932759474481923f),
vec2(0.25924625943834045f, 0.994183731910238f),
vec2(0.4329183928410619f, 0.9966876152055749f),
vec2(0.596130491724118f, 0.996670191741061f),
vec2(0.6778282654924236f, 0.9926524461516664f),
vec2(0.8142186688004268f, 0.9943479921229873f),
vec2(0.9348140034520755f, 0.9935296530704175f),
vec2(0.006763867667216594f, 0.9877955625271047f),
vec2(0.04849478128737905f, 0.9913481064108483f),
vec2(0.13136735734380833f, 0.985573596164426f),
vec2(0.1634255531854224f, 0.9868541099936288f),
vec2(0.3715488526602575f, 0.9907908910557864f),
vec2(0.47662352706381605f, 0.984595768266847f),
vec2(0.5092883992201592f, 0.9874947960247739f),
vec2(0.5404056423817339f, 0.9858397891251041f),
vec2(0.7846240780062531f, 0.9917422666345128f),
vec2(0.8549606921877926f, 0.9907787886623186f),
vec2(0.8862241830565702f, 0.9883635682959953f),
vec2(0.9724150880404874f, 0.9851990765637622f),
vec2(0.07286294436987928f, 0.9768410063016636f),
vec2(0.31480588101395635f, 0.9802472897589348f),
vec2(0.34061912897660696f, 0.9788532084573431f),
vec2(0.6511807877549666f, 0.9783286969901723f),
vec2(0.7083791166876584f, 0.9798870355471122f),
vec2(0.7391249623785291f, 0.9803740191002567f),
vec2(0.7635787046529013f, 0.9794413057009843f),
vec2(0.2768298826959047f, 0.9707065113816353f),
vec2(0.39924516170912805f, 0.9725185992192072f),
vec2(0.5654939404934562f, 0.9702260649112338f),
vec2(0.6245197875718994f, 0.9756395110950352f),
vec2(0.024534103689904496f, 0.9619153997264072f),
vec2(0.10298799511463075f, 0.9642326569531647f),
vec2(0.1921176320405693f, 0.9685476435015442f),
vec2(0.2443431303807444f, 0.9630938324036358f),
vec2(0.36137439148570294f, 0.9623943189125526f),
vec2(0.427587576290694f, 0.9660466755294088f),
vec2(0.4545040098034058f, 0.9621954905576222f),
vec2(0.7969980277655625f, 0.962087140239868f),
vec2(0.8687576183020767f, 0.9685606590025615f),
vec2(0.9105797550577778f, 0.9678658351444903f),
vec2(0.9933955024451266f, 0.9617173025019036f),
vec2(0.05306060662064138f, 0.9558174313607921f),
vec2(0.1327461337810677f, 0.9573723041737457f),
vec2(0.2163458213289723f, 0.9565480789933531f),
vec2(0.49031560224965876f, 0.9588945421370686f),
vec2(0.5919313193829104f, 0.9567706955027407f),
vec2(0.6789351562266093f, 0.9596984067336228f),
vec2(0.8273794109177925f, 0.9576411337368048f),
vec2(0.9444222866893821f, 0.9585789513777441f),
vec2(0.5300327376270751f, 0.9496732810574696f),
vec2(0.6266605012604587f, 0.9485469462470648f),
vec2(0.6531107641554378f, 0.9521006204690143f),
vec2(0.7042332435522256f, 0.950625929860196f),
vec2(0.7714432969422392f, 0.9527097993103149f),
vec2(0.0830248654269703f, 0.945308244000302f),
vec2(0.15824939233607704f, 0.9401829898791112f),
vec2(0.19130906415308668f, 0.9426234874199484f),
vec2(0.2829220244723174f, 0.9438081023533705f),
vec2(0.32615281988563183f, 0.9451176310518097f),
vec2(0.37488052879651756f, 0.9382790876839926f),
vec2(0.4233685035014044f, 0.9388647202376297f),
vec2(0.5603976747112547f, 0.9396267619812695f),
vec2(0.7435947250866622f, 0.9403636219060448f),
vec2(0.8555773874780003f, 0.9445889389957611f),
vec2(0.8933335405296777f, 0.9387298911200421f),
vec2(0.971958679335768f, 0.944297445284442f),
vec2(0.021870464141468093f, 0.9354506233087442f),
vec2(0.12681196563425823f, 0.9315763579396982f),
vec2(0.2176079879206526f, 0.9302904413573315f),
vec2(0.6073991258154148f, 0.9301636283821862f),
vec2(0.9452485003899995f, 0.9312490730094899f),
vec2(0.06044503817699809f, 0.9271892280993114f),
vec2(0.10162875215163836f, 0.9254417423998358f),
vec2(0.25315609657049354f, 0.9289007727409893f),
vec2(0.46120967277922253f, 0.9273558506170634f),
vec2(0.49566071432211123f, 0.925220259534791f),
vec2(0.8055638146492706f, 0.9283880863140358f),
vec2(0.994230764469407f, 0.9227576186669705f),
vec2(0.18110920457993407f, 0.9156012996288974f),
vec2(0.3093763526599398f, 0.9164888136491901f),
vec2(0.5282603643231177f, 0.9176496184719257f),
vec2(0.6516545439773485f, 0.9160563566307122f),
vec2(0.6851822497513431f, 0.9174355039182943f),
vec2(0.9198708120962038f, 0.9172572214865652f),
vec2(0.028714958370853028f, 0.9096796714661852f),
vec2(0.34187451465084684f, 0.9088031882588343f),
vec2(0.3866459830260357f, 0.912967979705148f),
vec2(0.41816453048382596f, 0.9131409245168942f),
vec2(0.5650200039016434f, 0.9089127401472071f),
vec2(0.7196585784463735f, 0.9079980137973568f),
vec2(0.7804366989305271f, 0.9139147602206145f),
vec2(0.8317576902065114f, 0.907151570995632f),
vec2(0.8746015662532343f, 0.9107903133150818f),
vec2(0.9592849489079368f, 0.9083386133392259f),
vec2(0.07793771637182811f, 0.9058210989319858f),
vec2(0.13612860526238835f, 0.9032582126534353f),
vec2(0.2035015532411666f, 0.905668760396537f),
vec2(0.2802441032411168f, 0.9017717010399798f),
vec2(0.48808215893353757f, 0.8994323955673248f),
vec2(0.5908364635258452f, 0.9052643236385932f),
vec2(0.23912428264904662f, 0.8977631604349104f),
vec2(0.4423633212265773f, 0.8941816555952439f),
vec2(0.5150818185555466f, 0.8956223780160326f),
vec2(0.6184981762314201f, 0.8977786468835052f),
vec2(0.6890012552332129f, 0.893223745394294f),
vec2(0.747446188944729f, 0.8916166358288596f),
vec2(0.9355843947885876f, 0.8928714545229821f),
vec2(0.018169232520743983f, 0.886984702893491f),
vec2(0.058819792226242895f, 0.8837561111641564f),
vec2(0.16706333270590934f, 0.8842031682411559f),
vec2(0.3107484034224077f, 0.8849367021738641f),
vec2(0.36761066009520793f, 0.8901413283207651f),
vec2(0.40934666292756205f, 0.8829531873994837f),
vec2(0.5384784439224336f, 0.8847522125003825f),
vec2(0.6448026885782211f, 0.8863700863776848f),
vec2(0.7759954058771656f, 0.8857151367354741f),
vec2(0.8852816353523338f, 0.8883349387624657f),
vec2(0.9675104819907091f, 0.8866000160884687f),
vec2(0.13139378430588955f, 0.8758133127256864f),
vec2(0.20616671716483204f, 0.8802744110547701f),
vec2(0.4724274495643712f, 0.8784578024941506f),
vec2(0.8094334526197492f, 0.8791926915597947f),
vec2(0.9090616377559789f, 0.8799288245119278f),
vec2(0.9897119768566289f, 0.8817644079104595f),
vec2(0.10004605400269062f, 0.8746035362449709f),
vec2(0.23403014993342575f, 0.8688275558739603f),
vec2(0.3394573766355756f, 0.8746128376062067f),
vec2(0.5067441787784152f, 0.8687736580158585f),
vec2(0.5953100633979407f, 0.8741931806593969f),
vec2(0.6724726132646086f, 0.8720341725594233f),
vec2(0.706051360427366f, 0.8705857708186329f),
vec2(0.7333254905422173f, 0.867800524561417f),
vec2(0.8393518816168298f, 0.8740646031975742f),
vec2(0.8647038535640116f, 0.8738755663069754f),
vec2(0.9451354292142752f, 0.8691012980937797f),
vec2(0.02544372195848843f, 0.8597795219007071f),
vec2(0.26519495628037804f, 0.8599487855096521f),
vec2(0.3676896963327242f, 0.8611997918994516f),
vec2(0.43060353460879786f, 0.8625074567562593f),
vec2(0.45359684635556996f, 0.8640663213730339f),
vec2(0.7617786372330365f, 0.8604708576938925f),
vec2(0.07434775253744519f, 0.8561680434528797f),
vec2(0.16153148957187147f, 0.8521622323161537f),
vec2(0.18964165445133319f, 0.8554436628217958f),
vec2(0.30210444480487264f, 0.8567228637047887f),
vec2(0.5308623686672693f, 0.8559255219612185f),
vec2(0.5607304869998722f, 0.8567733609022895f),
vec2(0.6232487301073499f, 0.8569304729022937f),
vec2(0.33072364304094537f, 0.844064070109136f),
vec2(0.4080004107812103f, 0.8443813003463969f),
vec2(0.48521515044430497f, 0.8476723101009315f),
vec2(0.6015855966813848f, 0.8454185942322823f),
vec2(0.6527997003695959f, 0.8510947691698775f),
vec2(0.6804335752881051f, 0.8504109125949628f),
vec2(0.791696781359723f, 0.8509905737375988f),
vec2(0.9086086514832425f, 0.8499053111750312f),
vec2(0.9663018987778322f, 0.8457908308573812f),
vec2(0.10843990732199094f, 0.8406440725886605f),
vec2(0.21807633591753595f, 0.8433710272332453f),
vec2(0.24544826254512997f, 0.8363401193102872f),
vec2(0.38374264774026967f, 0.8415752856189024f),
vec2(0.4565427994407709f, 0.8394277951324175f),
vec2(0.8206623411199886f, 0.8431275251122595f),
vec2(0.8515154420889812f, 0.8426459482313682f),
vec2(0.05058260075527021f, 0.8287880447907893f),
vec2(0.14329123254438647f, 0.8308322685986926f),
vec2(0.2900072730036778f, 0.8287774151119666f),
vec2(0.35931196071572125f, 0.8315732353381634f),
vec2(0.512328841338262f, 0.8332312801542379f),
vec2(0.555511245141533f, 0.8298595506850898f),
vec2(0.6969093716380633f, 0.8322217435073153f),
vec2(0.7368706132361993f, 0.8317216670774568f),
vec2(0.7681199473327346f, 0.828385397943254f),
vec2(0.8834447681854019f, 0.8320900940227204f),
vec2(0.9294150717631374f, 0.8314072911110688f),
vec2(0.9957879734736733f, 0.8324390828724157f),
vec2(0.026311530017426255f, 0.8221514464930125f),
vec2(0.08405010725607542f, 0.8228984298020765f),
vec2(0.18713170782397237f, 0.825324520709847f),
vec2(0.4355772925110719f, 0.8214853815237453f),
vec2(0.5913603807598186f, 0.8224075102081475f),
vec2(0.6231783341443341f, 0.8267773922100814f),
vec2(0.7967164298507523f, 0.8265113365718569f),
vec2(0.9064296712638611f, 0.8218733709177322f),
vec2(0.12265385181695732f, 0.8144788069306754f),
vec2(0.3228250395719051f, 0.8165279710261417f),
vec2(0.38405199697265324f, 0.8135565747740344f),
vec2(0.48877370666157083f, 0.8187680175528622f),
vec2(0.6602482407937528f, 0.8185138999806653f),
vec2(0.7126732446127766f, 0.8131800410794064f),
vec2(0.8221945683087326f, 0.8141048295959726f),
vec2(0.9489212434561172f, 0.8178933396550305f),
vec2(0.22106167940304933f, 0.8093800340476247f),
vec2(0.46349728554074354f, 0.8080176906233554f),
vec2(0.5214757284578574f, 0.8084112609718296f),
vec2(0.8500480660860532f, 0.8115010705937936f),
vec2(0.9259233658143449f, 0.804981240836595f),
vec2(0.9705625559110491f, 0.8058718659073884f),
vec2(0.011025501231516466f, 0.8032158280785725f),
vec2(0.25652126703743305f, 0.8035043343633134f),
vec2(0.3506267138875696f, 0.8027602802111287f),
vec2(0.4187471748482744f, 0.798656148617732f),
vec2(0.5507537052356277f, 0.8045628596673373f),
vec2(0.6919762630080553f, 0.799028642749671f),
vec2(0.7319854501261885f, 0.7995355715176579f),
vec2(0.7638515844365721f, 0.8001336180877187f),
vec2(0.7958710166391071f, 0.8007823512024154f),
vec2(0.8868576687376598f, 0.7988509185595798f),
vec2(0.039551505977098333f, 0.7951131803325434f),
vec2(0.10049439607158273f, 0.795120245745459f),
vec2(0.16621528932902152f, 0.7957677284287162f),
vec2(0.19431484479125005f, 0.7911954190219178f),
vec2(0.29823704349337554f, 0.7968134894069172f),
vec2(0.4919576986451032f, 0.791227211610262f),
vec2(0.6198349410801458f, 0.7963126805230321f),
vec2(0.1362326774576349f, 0.7864548133425424f),
vec2(0.39600100027661744f, 0.787912700601788f),
vec2(0.5890053387495269f, 0.782181465977762f),
vec2(0.6452818825346422f, 0.7840774100910184f),
vec2(0.8504513274265316f, 0.7858251038423052f),
vec2(0.9473608430782079f, 0.7832679875426645f),
vec2(0.07550305805148427f, 0.7801644853491327f),
vec2(0.22002633522893456f, 0.7789901331209268f),
vec2(0.25358277208082336f, 0.7756061446727789f),
vec2(0.32372415574074465f, 0.7736606456901325f),
vec2(0.45222889655878873f, 0.7746762315989607f),
vec2(0.5259673229086222f, 0.780986547315338f),
vec2(0.7145105080161583f, 0.7751781384338668f),
vec2(0.8204782933599885f, 0.7787552009433377f),
vec2(0.9145799871816601f, 0.7804359327008646f),
vec2(0.9748614033232919f, 0.777749846338607f),
vec2(0.003485958166373204f, 0.7720838894613881f),
vec2(0.050496536224531874f, 0.7690724623850101f),
vec2(0.11227710775676536f, 0.7697740124723498f),
vec2(0.37982515311817133f, 0.7679229089353681f),
vec2(0.5560683529955097f, 0.7679694720042033f),
vec2(0.7439952074572304f, 0.7696086504164735f),
vec2(0.7728628104254759f, 0.7687000805417789f),
vec2(0.18744963502957224f, 0.7649189526256008f),
vec2(0.283257484938361f, 0.7646430342563145f),
vec2(0.3517980624160313f, 0.7622523131285946f),
vec2(0.4226026346092907f, 0.7650975566292856f),
vec2(0.4911431431596469f, 0.7587819384288812f),
vec2(0.6660317297523739f, 0.7624331883750383f),
vec2(0.8644170672154483f, 0.762981756845271f),
vec2(0.8907127386491921f, 0.7615982026639257f),
vec2(0.0320197416582062f, 0.7536549181611112f),
vec2(0.1542290482475378f, 0.7538765634797437f),
vec2(0.6256117632567147f, 0.7573207613857541f),
vec2(0.6995912526149695f, 0.7527246303259767f),
vec2(0.9629779722157358f, 0.7529500281697752f),
vec2(0.0899467693742022f, 0.7455376295879269f),
vec2(0.24760894575283332f, 0.7465376190505368f),
vec2(0.5272764881739085f, 0.7469635205849694f),
vec2(0.5811462972666961f, 0.7431763441182143f),
vec2(0.6034530579675416f, 0.748604058451351f),
vec2(0.796540560939431f, 0.7437732157196358f),
vec2(0.8290587635918606f, 0.7496860871072486f),
vec2(0.9093822662362814f, 0.7433375203317812f),
vec2(0.9372953084945259f, 0.7444409671094324f),
vec2(0.06066290793991502f, 0.737083229831767f),
vec2(0.12582671013270508f, 0.7393991167435678f),
vec2(0.17696011987358784f, 0.736348985116082f),
vec2(0.34301091822617247f, 0.737867015422795f),
vec2(0.3700513709783797f, 0.7390938120675876f),
vec2(0.41111879214932856f, 0.7381042787129f),
vec2(0.439496564894301f, 0.7406999263795017f),
vec2(0.5518427043442434f, 0.7419646955366289f),
vec2(0.6477302046909565f, 0.7421391220492568f),
vec2(0.6809449962558488f, 0.7387835896586505f),
vec2(0.7292053915442469f, 0.7393798650177782f),
vec2(0.7566068690998068f, 0.7389936834543398f),
vec2(0.0018808157766403433f, 0.7288928681774907f),
vec2(0.030727920443302192f, 0.7278127306022404f),
vec2(0.21024977662258304f, 0.732782930438057f),
vec2(0.27366521690330614f, 0.7343233006127875f),
vec2(0.3031313922014093f, 0.7303321063448356f),
vec2(0.4683865471038472f, 0.7318831780387786f),
vec2(0.8570820544266272f, 0.7294407552204836f),
vec2(0.9748402467314179f, 0.7282544126717367f),
vec2(0.6022174222434178f, 0.7187995757805292f),
vec2(0.7049500618397995f, 0.7264274655339172f),
vec2(0.8250025064508921f, 0.7197580954621795f),
vec2(0.11004504731513465f, 0.7122870496984477f),
vec2(0.23796615948531386f, 0.7130379104578698f),
vec2(0.32138267355942174f, 0.7112253175743712f),
vec2(0.35507976880552083f, 0.7156741769410832f),
vec2(0.40974882519962996f, 0.7144800313504257f),
vec2(0.4367498821738607f, 0.7131192709760372f),
vec2(0.5048439184115142f, 0.7154942711426f),
vec2(0.5540129186206404f, 0.717867338963838f),
vec2(0.578487428984949f, 0.7116260976457621f),
vec2(0.6317973476375033f, 0.7183386329368103f),
vec2(0.6651725656179406f, 0.7144850932567984f),
vec2(0.7352765472319424f, 0.7111546458829254f),
vec2(0.7600155478500178f, 0.7116147266069668f),
vec2(0.8798912136520752f, 0.716601060039646f),
vec2(0.907858084600902f, 0.7179110948603845f),
vec2(0.9415652172729672f, 0.7150533717855272f),
vec2(0.16703926789768664f, 0.7105717357411862f),
vec2(0.19958598973241615f, 0.7070574810118655f),
vec2(0.2729173819784547f, 0.7031338497025168f),
vec2(0.38163291753777373f, 0.7107997805434183f),
vec2(0.4640499118199001f, 0.7058308653421808f),
vec2(0.004962317045771991f, 0.699732708787729f),
vec2(0.03559787326291619f, 0.7000924143798684f),
vec2(0.07900047842748403f, 0.7018811368839583f),
vec2(0.13808058151935798f, 0.6991653937052699f),
vec2(0.6188778143547972f, 0.6969740160349561f),
vec2(0.7831511383180906f, 0.703047489791869f),
vec2(0.8073912606253282f, 0.7010669982837805f),
vec2(0.9728351156558872f, 0.7031073877111587f),
vec2(0.25286646015716474f, 0.6878978688029317f),
vec2(0.30609233016713444f, 0.6882742448785732f),
vec2(0.35034099253162876f, 0.6876161908127612f),
vec2(0.41552360304822034f, 0.6880959252417217f),
vec2(0.7083320351712284f, 0.6917255030377193f),
vec2(0.8439979648934871f, 0.6888069303251486f),
vec2(0.8859719092146399f, 0.6910099327804912f),
vec2(0.9117122418092506f, 0.6916360693581906f),
vec2(0.18267286588784037f, 0.6839085695869725f),
vec2(0.21486981041452557f, 0.6811037655728289f),
vec2(0.4841785538072594f, 0.6818948253158021f),
vec2(0.5305959217614327f, 0.6823642271961418f),
vec2(0.5770624718686351f, 0.6870302251083674f),
vec2(0.6790261546359101f, 0.6805636622835032f),
vec2(0.9469361470583483f, 0.6800054722790065f),
vec2(0.10459652355942839f, 0.6734979356047719f),
vec2(0.447253422018556f, 0.6795493431570099f),
vec2(0.605887130563627f, 0.6735718307572992f),
vec2(0.6359151503230625f, 0.6774307372997348f),
vec2(0.7420165183513221f, 0.6783437799609995f),
vec2(0.7720182607102036f, 0.6737280309412301f),
vec2(0.9919759008700155f, 0.6741163547659316f),
vec2(0.0303605103909399f, 0.6642325479551552f),
vec2(0.06613432672581787f, 0.667763634633887f),
vec2(0.14852905779096748f, 0.6696227737555586f),
vec2(0.26423314525667063f, 0.6652652722743007f),
vec2(0.39183306564420195f, 0.6687971142137504f),
vec2(0.8047177629338288f, 0.6671194531181609f),
vec2(0.8957420542544479f, 0.6679799447760256f),
vec2(0.29007422712258657f, 0.6589072467209295f),
vec2(0.3449259480075547f, 0.6600244012819636f),
vec2(0.7101424231189699f, 0.658653542329323f),
vec2(0.8340180916158336f, 0.6603227952034667f),
vec2(0.8681478859198228f, 0.6613204258585554f),
vec2(0.922331634586872f, 0.6564563996105116f),
vec2(0.08583013541897644f, 0.6528771662942618f),
vec2(0.1278769886092781f, 0.6484447687886346f),
vec2(0.18631038344116424f, 0.6490964829497232f),
vec2(0.22912452254264093f, 0.6517791107274004f),
vec2(0.31606900995404785f, 0.6533396441479833f),
vec2(0.42461205292315984f, 0.6512154335424424f),
vec2(0.46570592671635636f, 0.652047579317226f),
vec2(0.5070837274203747f, 0.649011936189624f),
vec2(0.5458722956029014f, 0.6543872825805479f),
vec2(0.5725696659177769f, 0.6520275298345712f),
vec2(0.6588392608323961f, 0.653218739926746f),
vec2(0.7375217100603356f, 0.6508174889238441f),
vec2(0.39903796302946404f, 0.6413001756640053f),
vec2(0.6119185389011724f, 0.6424247506296924f),
vec2(0.6838940441808933f, 0.6473095271898742f),
vec2(0.7724139225771468f, 0.6422994255934545f),
vec2(0.9610350159070123f, 0.6445862699116703f),
vec2(0.004887888476287516f, 0.6401375130628674f),
vec2(0.8028230122504894f, 0.6403292293436245f),
vec2(0.03654601770788091f, 0.6272752611687771f),
vec2(0.06967825037996056f, 0.6280251457082598f),
vec2(0.10243648881699341f, 0.6314422366756691f),
vec2(0.17573172758378497f, 0.6255256475672866f),
vec2(0.25091257159704494f, 0.6261688988722715f),
vec2(0.28860842846508494f, 0.629944152694953f),
vec2(0.3709248522133547f, 0.6303839905639761f),
vec2(0.44591323502635394f, 0.6321522062243626f),
vec2(0.4739395290376822f, 0.625285952474963f),
vec2(0.542099745985565f, 0.6282484355871946f),
vec2(0.825836823465427f, 0.628481437990355f),
vec2(0.8535270903594374f, 0.630822436795771f),
vec2(0.8968637603102643f, 0.629464170460761f),
vec2(0.9306188465877668f, 0.6295782685559025f),
vec2(0.9816534694146335f, 0.6308241971399372f),
vec2(0.14912669820588031f, 0.6230789737547902f),
vec2(0.22178442827472789f, 0.6245900660663305f),
vec2(0.33178711935095406f, 0.6244264876606015f),
vec2(0.6636079509593098f, 0.6202297463463505f),
vec2(0.6966071031437988f, 0.6216893910112145f),
vec2(0.7291733395131097f, 0.6226208383180488f),
vec2(0.12097107763359416f, 0.6156077944425052f),
vec2(0.41580396264609143f, 0.6129379161173214f),
vec2(0.5092332252275336f, 0.6137836184143663f),
vec2(0.5770482170327672f, 0.6130826121456197f),
vec2(0.6242799019564131f, 0.6099043093658282f),
vec2(0.953673501965259f, 0.6125621468042264f),
vec2(0.015255288947047418f, 0.6075756200644955f),
vec2(0.08915080718199564f, 0.6055642576366735f),
vec2(0.19667941347748297f, 0.6075758117057124f),
vec2(0.23404498448005862f, 0.6043649854534903f),
vec2(0.44246496965583093f, 0.608064330725545f),
vec2(0.8158544917376512f, 0.6029696356699654f),
vec2(0.8623677708311743f, 0.6038056932843828f),
vec2(0.9880521449492176f, 0.6083062119992764f),
vec2(0.04540914419619746f, 0.6006253380088488f),
vec2(0.2699250907320643f, 0.6004511077589761f),
vec2(0.2963206032255259f, 0.5956441812950451f),
vec2(0.3220526766896944f, 0.5984357964734225f),
vec2(0.34970331691030043f, 0.5972064802177502f),
vec2(0.48330323983948864f, 0.5977814668972659f),
vec2(0.5345233542339285f, 0.5956853547746623f),
vec2(0.6496655070651701f, 0.5972690636616264f),
vec2(0.7287920914653082f, 0.5977058501878741f),
vec2(0.7535120453148466f, 0.5968988209608328f),
vec2(0.7859639876930048f, 0.6011945087123636f),
vec2(0.8900299348619773f, 0.5953496643539264f),
vec2(0.9189066749342698f, 0.5997153679290363f),
vec2(0.11441509296018892f, 0.590200747371553f),
vec2(0.14787570985438592f, 0.5896831608037124f),
vec2(0.3884371273992666f, 0.5888077222746683f),
vec2(0.5894572378715887f, 0.58817968555109f),
vec2(0.6984123894049685f, 0.591059878585368f),
vec2(0.024873591322955635f, 0.5782574105841246f),
vec2(0.07249103345720032f, 0.580743915132495f),
vec2(0.2160540966989054f, 0.5848789770055044f),
vec2(0.2462385691881045f, 0.5819842587059219f),
vec2(0.42169121722589387f, 0.5824564158648731f),
vec2(0.45311352064014976f, 0.5838274889340157f),
vec2(0.5004111319444614f, 0.5798634123048615f),
vec2(0.8018711259176304f, 0.578394001660076f),
vec2(0.8330426111578775f, 0.5812325555157788f),
vec2(0.9514491324815517f, 0.5795540915096749f),
vec2(0.17214408016300486f, 0.5705940542838567f),
vec2(0.5255041772478568f, 0.5718782815471621f),
vec2(0.558868774910194f, 0.5750106490994641f),
vec2(0.6127967475476649f, 0.5778640631175191f),
vec2(0.7738367998103225f, 0.5741082495740957f),
vec2(0.8681235248566181f, 0.5731215158374201f),
vec2(0.9894693769006818f, 0.5707101186712564f),
vec2(0.3246561833480772f, 0.5674920911304443f),
vec2(0.6599889392528115f, 0.5696382007599351f),
vec2(0.7362880094074618f, 0.5662325147776682f),
vec2(0.8959452384222754f, 0.5679353850431418f),
vec2(0.9239259384237373f, 0.5700442021751174f),
vec2(0.05089785432692773f, 0.5582725209954172f),
vec2(0.10122926318199776f, 0.5582391364632944f),
vec2(0.14040932081534696f, 0.5567626589950369f),
vec2(0.24520406020970387f, 0.555722543023014f),
vec2(0.27404896127751777f, 0.556270819807587f),
vec2(0.49143605794372947f, 0.5568308540860119f),
vec2(0.6340977680113593f, 0.5609952358306856f),
vec2(0.7059664556047778f, 0.5591965376639141f),
vec2(0.011317848333841307f, 0.5523188054409789f),
vec2(0.20585083362314227f, 0.5539072534098498f),
vec2(0.3641494386735491f, 0.5544135356292068f),
vec2(0.389443720332066f, 0.5497450198656099f),
vec2(0.4167723449110763f, 0.5494654201507844f),
vec2(0.5149980006793963f, 0.5475070884987328f),
vec2(0.5504016752140534f, 0.5483782989428104f),
vec2(0.5877114668447371f, 0.5471046423512759f),
vec2(0.7942443686442968f, 0.5520144691971935f),
vec2(0.8282157262584325f, 0.5492126782664282f),
vec2(0.9515974375052948f, 0.551495384860437f),
vec2(0.07351880757577367f, 0.5406387099687568f),
vec2(0.3051103854372125f, 0.5426431233487047f),
vec2(0.33940305349250677f, 0.5453898807714965f),
vec2(0.4618105112695977f, 0.5458466608777669f),
vec2(0.7652601185680109f, 0.5455487701979267f),
vec2(0.8580810858267074f, 0.5465292180407744f),
vec2(0.9257321982019652f, 0.5424025111376913f),
vec2(0.029911673750364187f, 0.5318688686295749f),
vec2(0.11404481350588236f, 0.5370145745324401f),
vec2(0.17073907102014574f, 0.5343333136685807f),
vec2(0.22390482208035112f, 0.5324236685111636f),
vec2(0.6100438302198181f, 0.5362339386163865f),
vec2(0.6384592357217203f, 0.5326611979476624f),
vec2(0.6868715230254369f, 0.5362838300251178f),
vec2(0.9763253032954948f, 0.5367787482372568f),
vec2(0.13360573178853474f, 0.5253184551951878f),
vec2(0.2519895119397969f, 0.5305338411277306f),
vec2(0.3800835759492128f, 0.5264947603485192f),
vec2(0.4339741602001602f, 0.5276455641380885f),
vec2(0.7365324134990575f, 0.5279622956454495f),
vec2(0.8924360051610658f, 0.5237456039850986f),
vec2(0.1919143916445194f, 0.5221725248437552f),
vec2(0.2806577933820338f, 0.5227945469312979f),
vec2(0.34280359341337596f, 0.517426033496181f),
vec2(0.493860564417971f, 0.5184659782704916f),
vec2(0.543569709025596f, 0.5207155617989493f),
vec2(0.5734839325875365f, 0.5173883830834307f),
vec2(0.6675691875409767f, 0.5197239444042587f),
vec2(0.7944855930952457f, 0.5217138166240117f),
vec2(0.8350024920806886f, 0.5160362634250679f),
vec2(0.8606405486128565f, 0.520333490800667f),
vec2(0.05456530280784622f, 0.514368468225099f),
vec2(0.10317771633785644f, 0.5110301180455851f),
vec2(0.23906204796873332f, 0.50864662948543f),
vec2(0.46804616122132514f, 0.508864658703648f),
vec2(0.6065110697811446f, 0.5113328930003628f),
vec2(0.7664709935679322f, 0.5155802267933282f),
vec2(0.9543364691873973f, 0.5078399566394173f),
vec2(0.9817051692121584f, 0.5081103423074752f),
vec2(0.009042687893559775f, 0.5045688876519401f),
vec2(0.21181125395043188f, 0.5069080567732707f),
vec2(0.301341812886152f, 0.5020257894785162f),
vec2(0.4000833304081882f, 0.5047393409579151f),
vec2(0.4436362341871096f, 0.5008677591123109f),
vec2(0.6895001062397057f, 0.5027014427493812f),
vec2(0.7203983085156358f, 0.5022367488911025f),
vec2(0.07801371191634665f, 0.49938846936179726f),
vec2(0.14180618073439877f, 0.4930440476909308f),
vec2(0.17993479592402462f, 0.4977911122729808f),
vec2(0.49729725698512983f, 0.4932434492571304f),
vec2(0.5204913371699103f, 0.49897554223861496f),
vec2(0.6608714481961303f, 0.49255958932281096f),
vec2(0.8077285051361731f, 0.4937620632994978f),
vec2(0.8643183397716113f, 0.49382459109542987f),
vec2(0.040043665088317804f, 0.4891146585169446f),
vec2(0.3276605334821038f, 0.48581673846278206f),
vec2(0.36061018012313706f, 0.4847547369777988f),
vec2(0.6292383265145362f, 0.48888709479237424f),
vec2(0.7811584814223408f, 0.49089330729927627f),
vec2(0.8922402132860148f, 0.48864923747851774f),
vec2(0.9234090667872418f, 0.49013761754438856f),
vec2(0.23978962350456023f, 0.4776703722830049f),
vec2(0.27193340457113047f, 0.48416026257419353f),
vec2(0.3877727444328042f, 0.4784121501054067f),
vec2(0.4562030935720506f, 0.4783529252286053f),
vec2(0.5554157545238764f, 0.4816789898329148f),
vec2(0.7529664157615765f, 0.4824563712012607f),
vec2(0.8348141761231637f, 0.481639398496178f),
vec2(0.9604166715062348f, 0.4825825677768266f),
vec2(0.9868446765278936f, 0.48277885357845385f),
vec2(0.06355279602941455f, 0.4744649858271984f),
vec2(0.0895301528390805f, 0.4737996736238108f),
vec2(0.11914596161188296f, 0.4758630419982628f),
vec2(0.18277493196745198f, 0.47370036896604306f),
vec2(0.413753663282706f, 0.4732487371119203f),
vec2(0.4858982316969467f, 0.4701122049760824f),
vec2(0.5891833624538684f, 0.4738419678010478f),
vec2(0.7969604569024281f, 0.4698976976552318f),
vec2(0.876151548482519f, 0.4694897997649595f),
vec2(0.015134520971651577f, 0.46858003521174185f),
vec2(0.3006730271385071f, 0.464855351104813f),
vec2(0.5236439335985805f, 0.46802977490413067f),
vec2(0.658213030905952f, 0.4617478606457789f),
vec2(0.6989408880654964f, 0.46618222567929923f),
vec2(0.04107125171831616f, 0.45759186768870996f),
vec2(0.15218053593577408f, 0.4572543359709256f),
vec2(0.20373354172981717f, 0.45886783939891107f),
vec2(0.27017541213915575f, 0.4532607162329245f),
vec2(0.37678663173303806f, 0.45315685238883996f),
vec2(0.6316758169819391f, 0.4604954955591729f),
vec2(0.733409627014302f, 0.4598653086846033f),
vec2(0.7716339553282249f, 0.4594043053335517f),
vec2(0.8457762131688997f, 0.45588610589517153f),
vec2(0.8993497380911799f, 0.45680839684001306f),
vec2(0.9241394460930831f, 0.46028628470105115f),
vec2(0.9494132345805103f, 0.45791300973582705f),
vec2(0.9948240297558905f, 0.45745736044031793f),
vec2(0.11894922522463036f, 0.4507872984870783f),
vec2(0.23735050819338277f, 0.4468226930961299f),
vec2(0.4524081416852169f, 0.4514904426754759f),
vec2(0.5099875607638077f, 0.4481840606608294f),
vec2(0.5629147261965334f, 0.4460204994624012f),
vec2(0.8190040304031898f, 0.44970006789103467f),
vec2(0.019033521013450905f, 0.4396740560930983f),
vec2(0.06168316571159671f, 0.442307980498846f),
vec2(0.3492818526501489f, 0.4420069465526125f),
vec2(0.4195029762098058f, 0.4446644586756491f),
vec2(0.7196738260048277f, 0.43906781181436794f),
vec2(0.7550336787729286f, 0.4383022869899923f),
vec2(0.8669077731037915f, 0.4394378659504621f),
vec2(0.9753825491354774f, 0.4394232424215404f),
vec2(0.1395138680222704f, 0.4354063121717917f),
vec2(0.3234314875688493f, 0.4311306181751927f),
vec2(0.3932896148773851f, 0.43330102402109694f),
vec2(0.4905406788203326f, 0.4339502951042794f),
vec2(0.5309489765782419f, 0.4360423652149822f),
vec2(0.5942393402493257f, 0.4320712499621622f),
vec2(0.625660549927284f, 0.4373240708258884f),
vec2(0.6487755558433586f, 0.43526154514607596f),
vec2(0.679723973968563f, 0.43526732187889494f),
vec2(0.7894627454242092f, 0.4304745348996647f),
vec2(0.09666796038616043f, 0.42398042366281197f),
vec2(0.17983980514112796f, 0.4293767612740822f),
vec2(0.2151530288198733f, 0.42280104741248326f),
vec2(0.29023910052033897f, 0.4272482564019784f),
vec2(0.4651803010636233f, 0.4236565636597138f),
vec2(0.8357704327275526f, 0.4265751170122847f),
vec2(0.9204109368427998f, 0.42729968532476326f),
vec2(0.1256297780022746f, 0.414557561071606f),
vec2(0.2523111060443942f, 0.41661057692077574f),
vec2(0.43190359677792367f, 0.4186619378191041f),
vec2(0.5555469914099799f, 0.4178549536950201f),
vec2(0.7039861580012715f, 0.4180679413459384f),
vec2(0.7352358270361429f, 0.4197875498790171f),
vec2(0.8936807750427745f, 0.4157449344507044f),
vec2(0.9491330114957419f, 0.418913111433885f),
vec2(0.007843627829534627f, 0.4102726945125649f),
vec2(0.04484786295708598f, 0.413054961925564f),
vec2(0.36683816733087093f, 0.4119983928434625f),
vec2(0.4969693867909334f, 0.41052960824621476f),
vec2(0.6306361755691967f, 0.40777167111629076f),
vec2(0.6663382277583663f, 0.4134231408533836f),
vec2(0.7634449594193522f, 0.41207804164498807f),
vec2(0.8136765814089533f, 0.4088388400284779f),
vec2(0.07177810438779375f, 0.39961661951144634f),
vec2(0.15268630413512496f, 0.40102572702239736f),
vec2(0.2954943339924755f, 0.4032471015812432f),
vec2(0.3206445081932646f, 0.4017150516718402f),
vec2(0.40207517859824005f, 0.4052018536766342f),
vec2(0.8614023717590217f, 0.4046090045812656f),
vec2(0.9778952881347055f, 0.40216597934665155f),
vec2(0.4626380278353085f, 0.39707263963272865f),
vec2(0.517023309958043f, 0.39694985199054145f),
vec2(0.5597747018374527f, 0.39095948198850217f),
vec2(0.5969491186900717f, 0.397573451851992f),
vec2(0.713339268743678f, 0.39123824059875834f),
vec2(0.9087686941771661f, 0.3951078240763578f),
vec2(0.027776350901192348f, 0.38613856330620167f),
vec2(0.11553436963668395f, 0.38496801113514734f),
vec2(0.188854966229679f, 0.38581793204885273f),
vec2(0.22670818368995949f, 0.38678493390482993f),
vec2(0.25195201249967514f, 0.3835671945534138f),
vec2(0.27693661917927637f, 0.3882981115278953f),
vec2(0.37890855090941367f, 0.390586116040484f),
vec2(0.435994967404564f, 0.38544017651877227f),
vec2(0.48900428587922184f, 0.3875204225247768f),
vec2(0.6740410822662565f, 0.3863547188479305f),
vec2(0.7437326006092023f, 0.38965625878462407f),
vec2(0.8223361283744016f, 0.3834056788082997f),
vec2(0.8884366797096539f, 0.3838247817869901f),
vec2(0.9340818444636723f, 0.38835326874208476f),
vec2(0.0902047122887597f, 0.38075101567084235f),
vec2(0.3591840530180763f, 0.37531559332121833f),
vec2(0.4052288247386854f, 0.3780823714069086f),
vec2(0.7707453802009581f, 0.38135565617970646f),
vec2(0.9940845158966872f, 0.3820557837129651f),
vec2(0.05642668645256266f, 0.37414657374039917f),
vec2(0.13709315725322413f, 0.36991751273397433f),
vec2(0.16410088344203322f, 0.3697406333622749f),
vec2(0.3225591850251187f, 0.3737175409642095f),
vec2(0.470597670561527f, 0.3698539066591431f),
vec2(0.5149594404220521f, 0.3736062807466446f),
vec2(0.5442882332604877f, 0.37036236881534057f),
vec2(0.5774172301288938f, 0.37350813896181234f),
vec2(0.6036232507881714f, 0.37055386012486335f),
vec2(0.6517996586757295f, 0.3720825232094692f),
vec2(0.8468426921220396f, 0.3731052257169445f),
vec2(0.9619944034771298f, 0.3722214987689859f),
vec2(0.22490151390970914f, 0.3638737337541341f),
vec2(0.6292398517478048f, 0.36343299836955545f),
vec2(0.8080171583988021f, 0.3604897096296532f),
vec2(0.870084348516864f, 0.36199639918127524f),
vec2(0.917593099189628f, 0.3657334467356448f),
vec2(0.09621706248538198f, 0.35447629317991725f),
vec2(0.20200819190762997f, 0.3558575242083155f),
vec2(0.24906579322836253f, 0.354021710358166f),
vec2(0.30600850952125236f, 0.3547142976299461f),
vec2(0.4445986511925487f, 0.35670760878844543f),
vec2(0.496972230987449f, 0.3584533624011843f),
vec2(0.6894650891586119f, 0.35310538286487125f),
vec2(0.7248572892749843f, 0.35597007111444856f),
vec2(0.7571267356241347f, 0.35412117869939563f),
vec2(0.9924992965649727f, 0.3527366037022547f),
vec2(0.02600196967608559f, 0.3450728646008068f),
vec2(0.061406391604536315f, 0.34675600899169357f),
vec2(0.1336939941607661f, 0.34590780314048575f),
vec2(0.2790728140820117f, 0.3455848928060563f),
vec2(0.3380195616430983f, 0.35123794746654213f),
vec2(0.4098763475878905f, 0.3499043945745828f),
vec2(0.47457696289339546f, 0.3452434502910635f),
vec2(0.5236266656602798f, 0.34607252430675217f),
vec2(0.5665027547427122f, 0.3493954137143257f),
vec2(0.8327581533472483f, 0.345134764209557f),
vec2(0.8889939754734355f, 0.3456297434828425f),
vec2(0.1752490612213452f, 0.3419436950148319f),
vec2(0.3713287053626332f, 0.33883311613903033f),
vec2(0.6152521766153566f, 0.339285203527653f),
vec2(0.6573030210399107f, 0.34248194771913665f),
vec2(0.9360839796820899f, 0.3425472191191935f),
vec2(0.9620829459357878f, 0.3369499693011918f),
vec2(0.5460360307428358f, 0.32966742611952304f),
vec2(0.5877084738060557f, 0.3330504236345033f),
vec2(0.683038221460897f, 0.33112208686662314f),
vec2(0.7801249815194368f, 0.3311635457534686f),
vec2(0.8107356631362784f, 0.33069900350288617f),
vec2(0.21608314845284238f, 0.3254867876041888f),
vec2(0.3047229463979635f, 0.32306628125949577f),
vec2(0.43611531220256206f, 0.3261180548147705f),
vec2(0.5067296853477208f, 0.3219053282569727f),
vec2(0.7058171203351873f, 0.3276855420564072f),
vec2(0.7455928487808042f, 0.3244487663169303f),
vec2(0.8489935151953633f, 0.3254083356347667f),
vec2(0.9112108265665325f, 0.32375312591433303f),
vec2(0.997015038451497f, 0.3270468905756947f),
vec2(0.09864935192713575f, 0.31969919290225024f),
vec2(0.16939339258380404f, 0.31504519075628357f),
vec2(0.2523226210172851f, 0.31903339653680696f),
vec2(0.3394984294403537f, 0.3175674148451604f),
vec2(0.37255749005046435f, 0.3161971423864288f),
vec2(0.40797014108066076f, 0.3172279546661436f),
vec2(0.4711895798764347f, 0.31709847552582127f),
vec2(0.6284171973581529f, 0.31493131125119755f),
vec2(0.01883406700544432f, 0.3078089008811894f),
vec2(0.055633570465477455f, 0.3103882788223228f),
vec2(0.14421701514240282f, 0.3084941807974657f),
vec2(0.19887987966966636f, 0.3059844462332486f),
vec2(0.5937607245770574f, 0.3054683432558738f),
vec2(0.6763913944939898f, 0.3082971497319664f),
vec2(0.8695400266198368f, 0.307400147194976f),
vec2(0.9691155221008246f, 0.3105845574793553f),
vec2(0.08256709993660338f, 0.2976115026188916f),
vec2(0.28333060284048095f, 0.30259320987372296f),
vec2(0.31235954074227135f, 0.2977478416275806f),
vec2(0.5327024137033539f, 0.3034245663769629f),
vec2(0.5647010797448506f, 0.299524159938542f),
vec2(0.6521032691524599f, 0.3018023423851377f),
vec2(0.7030207895158422f, 0.3015015671599015f),
vec2(0.8067939866107696f, 0.2992144526634234f),
vec2(0.8321975708838923f, 0.29981135626360467f),
vec2(0.9955585054751864f, 0.3003254755952782f),
vec2(0.11648511793392013f, 0.2951765477613679f),
vec2(0.3365542676144756f, 0.29049323705679553f),
vec2(0.3720366148670764f, 0.2896698296754183f),
vec2(0.4639403885275981f, 0.29026009745051096f),
vec2(0.7289662985684735f, 0.2922873591502283f),
vec2(0.7659410896090758f, 0.29656681087770453f),
vec2(0.8983332503777447f, 0.2937459744775057f),
vec2(0.9368714851255322f, 0.29503054579221943f),
vec2(0.18181357410200105f, 0.28592467656655607f),
vec2(0.22572269901429642f, 0.28684879651762496f),
vec2(0.4014806422076489f, 0.28612666289042044f),
vec2(0.4350379668546617f, 0.2849068196454976f),
vec2(0.5054240971655912f, 0.2861498900448828f),
vec2(0.9680618881720574f, 0.28484867857814333f),
vec2(0.0005578912759877097f, 0.27581165069661306f),
vec2(0.05945403948547212f, 0.2761277762819552f),
vec2(0.25960060642307003f, 0.27600375954493384f),
vec2(0.5953891598407269f, 0.2787114912512385f),
vec2(0.6252103390648924f, 0.2766158552787701f),
vec2(0.6913337428142001f, 0.2776635316469501f),
vec2(0.7499496863308397f, 0.2791610910958682f),
vec2(0.851433624129055f, 0.27623731263321094f),
vec2(0.029797755095763767f, 0.267811266979474f),
vec2(0.09412441008199113f, 0.27202089336978674f),
vec2(0.14787739328152072f, 0.26694248147414223f),
vec2(0.2891220634707572f, 0.2717976244829925f),
vec2(0.3187966546368173f, 0.271030549390458f),
vec2(0.5273968042098944f, 0.27294310869842897f),
vec2(0.5524285370205153f, 0.27303588347513497f),
vec2(0.6540792139928364f, 0.2715474671844217f),
vec2(0.8881551426296321f, 0.2714486894933076f),
vec2(0.9175418389856167f, 0.27056287926901246f),
vec2(0.17495112188364859f, 0.2618088824678535f),
vec2(0.3617841945566552f, 0.2601780857664018f),
vec2(0.4646044971824499f, 0.259584676162426f),
vec2(0.7745700707555931f, 0.2640741010269312f),
vec2(0.8081536419328061f, 0.2635056067530347f),
vec2(0.9533023724976647f, 0.26172472726581664f),
vec2(0.11989238393561485f, 0.25386400644888585f),
vec2(0.20926395016320087f, 0.2552883513693549f),
vec2(0.39632745682975035f, 0.25418570846727206f),
vec2(0.602599163171088f, 0.25236294284563576f),
vec2(0.7280654318790208f, 0.25630924959081347f),
vec2(0.850958409743398f, 0.25018047603305626f),
vec2(0.008098726506235776f, 0.24586926261508157f),
vec2(0.4357525575482136f, 0.24263704918470952f),
vec2(0.6862699963641877f, 0.24540642232476406f),
vec2(0.8939739004877204f, 0.24306757369510779f),
vec2(0.9271391943408169f, 0.24297125813002418f),
vec2(0.0578283507530537f, 0.24192845537447583f),
vec2(0.09285177710507064f, 0.23706006211982633f),
vec2(0.14399011010644114f, 0.23481897540991414f),
vec2(0.18209046190502454f, 0.23460280026743885f),
vec2(0.2392103361495982f, 0.23822126127862842f),
vec2(0.28238121933118365f, 0.2420964134001662f),
vec2(0.33922337243037104f, 0.2348255487938109f),
vec2(0.4909385828676591f, 0.24011513851399535f),
vec2(0.5212764126393203f, 0.240269889327964f),
vec2(0.5517295807618464f, 0.24009646946330343f),
vec2(0.5803368770964266f, 0.2350107182047796f),
vec2(0.6298826462419992f, 0.2386495257516542f),
vec2(0.7692993852458806f, 0.23898059433916963f),
vec2(0.7994900791205427f, 0.24076585483132518f),
vec2(0.8246936685340841f, 0.23662706040889825f),
vec2(0.030576916922999353f, 0.2294193718364257f),
vec2(0.39233336474355296f, 0.22730033198502897f),
vec2(0.46005137346365077f, 0.22688667855936484f),
vec2(0.7188160486707434f, 0.23290957178356353f),
vec2(0.9511780299099868f, 0.23354047542182266f),
vec2(0.9847096985696215f, 0.23079937582444776f),
vec2(0.12204599751333067f, 0.22558001032008268f),
vec2(0.20710533381251128f, 0.2232748832902357f),
vec2(0.6582884607534351f, 0.2246986646859318f),
vec2(0.7469100835719585f, 0.2257832547194354f),
vec2(0.787786922290263f, 0.2192531594289101f),
vec2(0.8613970361425924f, 0.2239293033307983f),
vec2(0.0060931815173188575f, 0.21662174487531194f),
vec2(0.07968690162928505f, 0.21695341088724263f),
vec2(0.2837664327628333f, 0.2110104006776684f),
vec2(0.31536402438996647f, 0.21351845053622254f),
vec2(0.3693252554422959f, 0.2162186098353035f),
vec2(0.4165221784535982f, 0.2149986099372051f),
vec2(0.601748661578216f, 0.21301585350442664f),
vec2(0.8143256900228787f, 0.21145552122840172f),
vec2(0.9266850764554082f, 0.21233253891981374f),
vec2(0.10680097770209751f, 0.20481449725040257f),
vec2(0.17118598938514884f, 0.21045209644757235f),
vec2(0.49118355024302995f, 0.2078329802722646f),
vec2(0.5234861867034392f, 0.20983269618529798f),
vec2(0.5516028894010818f, 0.20964032024195567f),
vec2(0.7022759179749707f, 0.2104652628571163f),
vec2(0.7266116058564716f, 0.20545814966202558f),
vec2(0.9655124056798019f, 0.2089647961721257f),
vec2(0.027729953559646248f, 0.1977789433538878f),
vec2(0.062466877999700965f, 0.20011178779837213f),
vec2(0.14460403719153125f, 0.20208721998210688f),
vec2(0.2103439212913809f, 0.19789422563130465f),
vec2(0.25045105137636214f, 0.19914684761833323f),
vec2(0.3398159245891066f, 0.1957277794643415f),
vec2(0.6309857459811018f, 0.2019793816338057f),
vec2(0.7648580010900322f, 0.20251254726289325f),
vec2(0.40044152233189956f, 0.19083966061638802f),
vec2(0.45336888926764607f, 0.1906394768787819f),
vec2(0.590598778338311f, 0.18942431767071555f),
vec2(0.6684380557635629f, 0.19434127212785357f),
vec2(0.8368938390254786f, 0.1888161334967503f),
vec2(0.8699105351337909f, 0.19002436977591108f),
vec2(0.9009937987876333f, 0.1915845283754325f),
vec2(0.9901073332065342f, 0.1914540356174379f),
vec2(0.12398667691126963f, 0.1802460239099566f),
vec2(0.17691128633498832f, 0.1839939248996315f),
vec2(0.3034711834869668f, 0.18675627284899066f),
vec2(0.43101071113829514f, 0.18001748010963248f),
vec2(0.47962809775550574f, 0.18541549110849675f),
vec2(0.5595434006386795f, 0.18129931707357883f),
vec2(0.8022218772469757f, 0.18089307564934132f),
vec2(0.9280348012379144f, 0.18528234888871975f),
vec2(0.26632901572599f, 0.1760507604975371f),
vec2(0.3719664504205056f, 0.17657286733545252f),
vec2(0.5198689611646207f, 0.17640356493972031f),
vec2(0.6979100609603923f, 0.17452718873959583f),
vec2(0.725173641347281f, 0.17863142153402245f),
vec2(0.7639477104847867f, 0.17360042653489116f),
vec2(0.9530589200736551f, 0.17381485556433995f),
vec2(0.018830999468893883f, 0.16656780201419363f),
vec2(0.09183261223810746f, 0.16635567738298607f),
vec2(0.22565426937545463f, 0.17097320937980542f),
vec2(0.6258153862628427f, 0.17044433470427967f),
vec2(0.6716399509896396f, 0.16410117988711648f),
vec2(0.9810861085382403f, 0.16556268833775256f),
vec2(0.05736365686550826f, 0.16260757494855183f),
vec2(0.15860630906474427f, 0.15735718717427027f),
vec2(0.19696763152856278f, 0.15726662320391238f),
vec2(0.28446751734414044f, 0.16032169260149765f),
vec2(0.4146776206685092f, 0.16134239349518253f),
vec2(0.47381460460251423f, 0.15852336270042855f),
vec2(0.502236539527098f, 0.15657729392297137f),
vec2(0.5861870219276778f, 0.159479513348601f),
vec2(0.7365911319027434f, 0.15653780079557011f),
vec2(0.8139299912662361f, 0.158203317581182f),
vec2(0.8395396954599748f, 0.15643900476339878f),
vec2(0.8720799671339344f, 0.16074332857873186f),
vec2(0.9099620253658034f, 0.1592629904877546f),
vec2(0.13194277838785007f, 0.15542597229360655f),
vec2(0.2506655514368644f, 0.15090452619633787f),
vec2(0.3137651253914887f, 0.15556300604228424f),
vec2(0.3427842274783991f, 0.1561105867226773f),
vec2(0.3856350170259786f, 0.15019270381240213f),
vec2(0.7864184796868771f, 0.15423328121075008f),
vec2(0.9403843866291838f, 0.15046040839346353f),
vec2(0.22007145487728852f, 0.14141247702115556f),
vec2(0.4446498271143131f, 0.1467945479055125f),
vec2(0.5586890375361444f, 0.14715302579060063f),
vec2(0.7046389166168899f, 0.1455973440845021f),
vec2(0.9652097321269398f, 0.14142060445258542f),
vec2(0.07330775005901313f, 0.13908789915653508f),
vec2(0.10558465051739363f, 0.13789781798565748f),
vec2(0.5244385787666327f, 0.1361661486781507f),
vec2(0.6305191409023743f, 0.13704983561385864f),
vec2(0.6583953263984933f, 0.13811758491194503f),
vec2(0.7515484915677442f, 0.13694187579615635f),
vec2(0.9988912012507241f, 0.13962249543682326f),
vec2(0.044013514837917156f, 0.1325124074103895f),
vec2(0.13792022039949803f, 0.13047475683046028f),
vec2(0.31521773483715343f, 0.12844547119359162f),
vec2(0.3684341527838073f, 0.12606246502014318f),
vec2(0.39948731644693647f, 0.12761286719465048f),
vec2(0.5980147704168337f, 0.1294306925747215f),
vec2(0.728376288773351f, 0.12815544074915386f),
vec2(0.8141901292585343f, 0.12872216009877224f),
vec2(0.8421682260894082f, 0.1262167122505642f),
vec2(0.8760583419107719f, 0.13158966253497495f),
vec2(0.9036308355812444f, 0.13174438753837103f),
vec2(0.16167090698361497f, 0.12422750235823299f),
vec2(0.19113413922065847f, 0.11849751211833404f),
vec2(0.2468333609239044f, 0.12472531136371878f),
vec2(0.2747958462235929f, 0.1193777049255067f),
vec2(0.3406343687405361f, 0.12229464695119774f),
vec2(0.4290908353381053f, 0.1181022491540823f),
vec2(0.4861858782372255f, 0.12475083730350411f),
vec2(0.5666813155609016f, 0.12121113195057676f),
vec2(0.6837621348311146f, 0.12054423595142005f),
vec2(0.7831811677524921f, 0.12388994269727593f),
vec2(0.010696054332622218f, 0.11078566646731336f),
vec2(0.08096700574088389f, 0.1134599930201261f),
vec2(0.22220208344770642f, 0.1139692201391318f),
vec2(0.6240721117665702f, 0.10942042706549626f),
vec2(0.6482911454442627f, 0.11508268407360811f),
vec2(0.7561499524751282f, 0.11476758766773609f),
vec2(0.9253485802137789f, 0.11496521648034674f),
vec2(0.9773792168252217f, 0.10992274868912588f),
vec2(0.05349325710045949f, 0.10923968656520466f),
vec2(0.12105154294386233f, 0.10794469681532526f),
vec2(0.38686207287407093f, 0.10286661230202154f),
vec2(0.4594957278207943f, 0.10743754544611672f),
vec2(0.5404513357442344f, 0.10778776328965123f),
vec2(0.7097551158835308f, 0.10376760149220343f),
vec2(0.8963224489987364f, 0.10764334905980244f),
vec2(0.29847808875119597f, 0.09678603590926049f),
vec2(0.3415919190730088f, 0.09482386385853636f),
vec2(0.5781339405035899f, 0.09642973585826164f),
vec2(0.6024454560528252f, 0.10069007156720244f),
vec2(0.7379259671520809f, 0.10114614794159771f),
vec2(0.8238876625999741f, 0.0992335873584872f),
vec2(0.8517829682013877f, 0.09746547500222391f),
vec2(0.9497879099061673f, 0.09655343190858101f),
vec2(0.03458407851402623f, 0.09161877723553902f),
vec2(0.16399187585206076f, 0.09033253427215104f),
vec2(0.2159995425790482f, 0.08780650883611585f),
vec2(0.27765359964105774f, 0.0870621452561251f),
vec2(0.36573046743446347f, 0.08788372691651625f),
vec2(0.503185361112382f, 0.09249620994723351f),
vec2(0.6556893547443058f, 0.08821790483642367f),
vec2(0.6838942379211267f, 0.09289395859154104f),
vec2(0.7758115374045325f, 0.09346711959832754f),
vec2(0.9193165084011218f, 0.0896638927813157f),
vec2(0.10783910626693616f, 0.08383290673066501f),
vec2(0.1921750686383099f, 0.08099841705031541f),
vec2(0.2496291276062399f, 0.08284215257143046f),
vec2(0.44503427587776123f, 0.07980474987580288f),
vec2(0.5262414161467301f, 0.08158166590357396f),
vec2(0.8901543100417897f, 0.08482673292437859f),
vec2(0.9997924459011173f, 0.08230660603303463f),
vec2(0.05702949574242577f, 0.07473118503931464f),
vec2(0.08435059531539157f, 0.07081883034524328f),
vec2(0.40870440429659016f, 0.07433142050126529f),
vec2(0.582914369030603f, 0.07260170958092049f),
vec2(0.6163442090008732f, 0.07638391059430982f),
vec2(0.7389394446269842f, 0.07110176155830927f),
vec2(0.8093597309557479f, 0.07170490768908033f),
vec2(0.13998450223257586f, 0.06391164760245849f),
vec2(0.3082176092915657f, 0.06586186738421129f),
vec2(0.3412975702192501f, 0.06636831349098427f),
vec2(0.37065296711885165f, 0.06265209458332988f),
vec2(0.5022925355253767f, 0.06536959843969803f),
vec2(0.558789030368755f, 0.07016013015142408f),
vec2(0.707530999231952f, 0.06389514167612709f),
vec2(0.8707656491014595f, 0.06744069062951974f),
vec2(0.9356164775054936f, 0.06952096395777096f),
vec2(0.9629906905117755f, 0.06928702721022817f),
vec2(0.010064169207899432f, 0.05677466419674715f),
vec2(0.24674977531582043f, 0.05641931478618878f),
vec2(0.428880146376572f, 0.058471003240373576f),
vec2(0.4766536907086978f, 0.06193552158604987f),
vec2(0.5243729542412059f, 0.05648615981144112f),
vec2(0.6441130528755116f, 0.056569281605685195f),
vec2(0.677570977819472f, 0.05476504317144182f),
vec2(0.777750128908335f, 0.05759462143431182f),
vec2(0.8463374514681927f, 0.057674090923978016f),
vec2(0.039485895441230934f, 0.049864242367427036f),
vec2(0.18712225512372005f, 0.05280386144358973f),
vec2(0.21834512679269613f, 0.053702538033325475f),
vec2(0.5937139471414786f, 0.0496865125343513f),
vec2(0.752170285269382f, 0.049933415476172915f),
vec2(0.8918158835375386f, 0.04714787567763745f),
vec2(0.9836188091456487f, 0.052802523107291055f),
vec2(0.11261325220119367f, 0.04133965859716193f),
vec2(0.16227833603712216f, 0.0407102991675129f),
vec2(0.27617682469391314f, 0.04511506521600828f),
vec2(0.3326953379228187f, 0.0401626949254037f),
vec2(0.39893954984737956f, 0.04232491391684068f),
vec2(0.45012793367572923f, 0.0444793445813515f),
vec2(0.5421963246658011f, 0.039787026535041514f),
vec2(0.8028141418096797f, 0.0444583739071196f),
vec2(0.9226917644970043f, 0.04282715469539222f),
vec2(0.304466947329153f, 0.034008390386708776f),
vec2(0.49913637017254553f, 0.034125535647991034f),
vec2(0.5669264976985081f, 0.03681953916548386f),
vec2(0.6990611961926898f, 0.03453602093778574f),
vec2(0.7316159790311443f, 0.03529853317970466f),
vec2(0.951567870409444f, 0.03167684317650499f),
vec2(0.08469240698934577f, 0.026857709286714715f),
vec2(0.19238114335809087f, 0.02474309087405635f),
vec2(0.2425380869381918f, 0.02875552108532664f),
vec2(0.3657637540418376f, 0.030920505301234025f),
vec2(0.4247874782503521f, 0.030413532317274283f),
vec2(0.6232116445328614f, 0.0246889459425933f),
vec2(0.6701946673716853f, 0.023812511915735746f),
vec2(0.8275990878557571f, 0.02944660263522203f),
vec2(0.8686314140484853f, 0.026510145441450694f),
vec2(0.022272823283805532f, 0.015871985677062384f),
vec2(0.05291942494263546f, 0.020390785066829786f),
vec2(0.1351365138164291f, 0.017542178584055823f),
vec2(0.2680155694823093f, 0.020803352152827803f),
vec2(0.47374039409932045f, 0.01764598861349198f),
vec2(0.5313929599016378f, 0.01823148951077902f),
vec2(0.5868333354272052f, 0.019486215122294426f),
vec2(0.7926093204880902f, 0.021716974080633f),
vec2(0.9062621223242663f, 0.01876381241676983f),
vec2(0.9892955407350505f, 0.020417267793279792f),
vec2(0.16392312091897365f, 0.01481433447799807f),
vec2(0.28965168799897933f, 0.008233728920750472f),
vec2(0.3913755531247535f, 0.013065883455006144f),
vec2(0.7088711580120723f, 0.008035033444522499f),
vec2(0.7614073635262197f, 0.009791159672862593f),
vec2(0.07487209701834319f, 0.003750368521545089f),
vec2(0.3250054144694329f, 0.003752326488546398f),
vec2(0.34967501602762185f, 0.0077812871733595745f),
vec2(0.4535709326827616f, 0.007297696706726087f),
vec2(0.566302206546454f, 0.002777698427839037f),
vec2(0.6452983241053707f, 0.00516409575995902f),
vec2(0.9602439352544099f, 0.005542681732912613f),
};


#endif

```

`shaders/rs/rt_reflections_rs.hlsli`:

```hlsli
#ifndef RT_REFLECTIONS_RS_HLSLI
#define RT_REFLECTIONS_RS_HLSLI

#include "../common/light_probe.hlsli"

struct rt_reflections_cb
{
	uint32 sampleSkyFromTexture;
	uint32 frameIndex;
};

#define RT_REFLECTIONS_RS_RESOURCES	0
#define RT_REFLECTIONS_RS_CB		1
#define RT_REFLECTIONS_RS_CAMERA	2
#define RT_REFLECTIONS_RS_LIGHTING	3



#endif

```

`shaders/rs/skinning_rs.hlsli`:

```hlsli
#ifndef SKINNING_RS_HLSLI
#define SKINNING_RS_HLSLI


struct skinning_cb
{
    uint32 firstJoint;
    uint32 numJoints;
    uint32 firstVertex;
    uint32 numVertices;
    uint32 writeOffset;
};

#define SKINNING_RS \
    "RootConstants(b0, num32BitConstants = 5), " \
    "SRV(t0), " \
    "SRV(t1), " \
    "SRV(t2), " \
    "UAV(u0), " \
    "UAV(u1)"

#define SKINNING_RS_CB			                0
#define SKINNING_RS_INPUT_VERTEX_BUFFER0        1
#define SKINNING_RS_INPUT_VERTEX_BUFFER1        2
#define SKINNING_RS_MATRICES                    3
#define SKINNING_RS_OUTPUT0                     4
#define SKINNING_RS_OUTPUT1                     5




struct cloth_skinning_cb
{
    uint32 gridSizeX;
    uint32 gridSizeY;
    uint32 writeOffset;
};

#define CLOTH_SKINNING_RS \
    "RootConstants(b0, num32BitConstants = 3), " \
    "SRV(t0), " \
    "UAV(u0), " \
    "UAV(u1)"
    
#define CLOTH_SKINNING_RS_CB                    0
#define CLOTH_SKINNING_RS_INPUT                 1
#define CLOTH_SKINNING_RS_OUTPUT0               2
#define CLOTH_SKINNING_RS_OUTPUT1               3


struct mesh_position
{
    vec3 position;
};

struct mesh_others
{
    vec2 uv;
    vec3 normal;
    vec3 tangent;
};

struct skinned_mesh_position
{
    vec3 position;
};

struct skinned_mesh_others
{
    vec2 uv;
    vec3 normal;
    vec3 tangent;
    uint32 skinIndices;
    uint32 skinWeights;
};


#endif


```

`shaders/rs/sky_rs.hlsli`:

```hlsli
#ifndef SKY_RS_HLSLI
#define SKY_RS_HLSLI

struct sky_transform_cb
{
	mat4 vp;
	mat4 prevFrameVP;
};

struct sky_cb
{
	vec2 jitter;
	vec2 prevFrameJitter;
	float intensity;
	vec3 sunDirection;
};

#define SKY_PROCEDURAL_RS \
	"RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT |" \
	"DENY_HULL_SHADER_ROOT_ACCESS |" \
	"DENY_DOMAIN_SHADER_ROOT_ACCESS |" \
	"DENY_GEOMETRY_SHADER_ROOT_ACCESS)," \
	"RootConstants(num32BitConstants=32, b0, visibility=SHADER_VISIBILITY_VERTEX)," \
	"RootConstants(num32BitConstants=8, b1, visibility=SHADER_VISIBILITY_PIXEL)"

#define SKY_TEXTURE_RS \
	"RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT |" \
	"DENY_HULL_SHADER_ROOT_ACCESS |" \
	"DENY_DOMAIN_SHADER_ROOT_ACCESS |" \
	"DENY_GEOMETRY_SHADER_ROOT_ACCESS)," \
	"RootConstants(num32BitConstants=32, b0, visibility=SHADER_VISIBILITY_VERTEX)," \
	"RootConstants(num32BitConstants=8, b1, visibility=SHADER_VISIBILITY_PIXEL)," \
	"StaticSampler(s0, visibility=SHADER_VISIBILITY_PIXEL)," \
	"DescriptorTable(SRV(t0, numDescriptors=1), visibility=SHADER_VISIBILITY_PIXEL)"

#define SKY_RS_TRANSFORM	0
#define SKY_RS_CB			1
#define SKY_RS_TEX			2

#endif


```

`shaders/rs/ssr_rs.hlsli`:

```hlsli
#ifndef SSR_RS_HLSLI
#define SSR_RS_HLSLI

#define SSR_BLOCK_SIZE 16

#define SSR_GGX_IMPORTANCE_SAMPLE_BIAS 0.1f

struct ssr_raycast_cb
{
    vec2 dimensions;
    vec2 invDimensions;
    uint32 frameIndex;

    uint32 numSteps;

    float maxDistance;

    float strideCutoff;
    float minStride;
    float maxStride;
};


#define SSR_RAYCAST_RS \
    "RootFlags(0), " \
    "RootConstants(b0, num32BitConstants = 10), " \
    "CBV(b1), " \
    "DescriptorTable( UAV(u0, numDescriptors = 1), SRV(t0, numDescriptors = 5) )," \
    "StaticSampler(s0," \
        "addressU = TEXTURE_ADDRESS_CLAMP," \
        "addressV = TEXTURE_ADDRESS_CLAMP," \
        "addressW = TEXTURE_ADDRESS_CLAMP," \
        "filter = FILTER_MIN_MAG_MIP_LINEAR), " \
    "StaticSampler(s1," \
        "addressU = TEXTURE_ADDRESS_CLAMP," \
        "addressV = TEXTURE_ADDRESS_CLAMP," \
        "addressW = TEXTURE_ADDRESS_CLAMP," \
        "filter = FILTER_MIN_MAG_MIP_POINT)"


#define SSR_RAYCAST_RS_CB           0
#define SSR_RAYCAST_RS_CAMERA       1
#define SSR_RAYCAST_RS_TEXTURES     2



struct ssr_resolve_cb
{
    vec2 dimensions;
    vec2 invDimensions;
};

#define SSR_RESOLVE_RS \
    "RootFlags(0), " \
    "RootConstants(b0, num32BitConstants = 4), " \
    "CBV(b1), " \
    "DescriptorTable( UAV(u0, numDescriptors = 1), SRV(t0, numDescriptors = 5) )," \
    "StaticSampler(s0," \
        "addressU = TEXTURE_ADDRESS_CLAMP," \
        "addressV = TEXTURE_ADDRESS_CLAMP," \
        "addressW = TEXTURE_ADDRESS_CLAMP," \
        "filter = FILTER_MIN_MAG_MIP_LINEAR), " \
    "StaticSampler(s1," \
        "addressU = TEXTURE_ADDRESS_CLAMP," \
        "addressV = TEXTURE_ADDRESS_CLAMP," \
        "addressW = TEXTURE_ADDRESS_CLAMP," \
        "filter = FILTER_MIN_MAG_MIP_POINT)"


#define SSR_RESOLVE_RS_CB           0
#define SSR_RESOLVE_RS_CAMERA       1
#define SSR_RESOLVE_RS_TEXTURES     2



struct ssr_temporal_cb
{
    vec2 invDimensions;
};

#define SSR_TEMPORAL_RS \
    "RootFlags(0), " \
    "RootConstants(b0, num32BitConstants = 2), " \
    "DescriptorTable( UAV(u0, numDescriptors = 1), SRV(t0, numDescriptors = 3) )," \
    "StaticSampler(s0," \
        "addressU = TEXTURE_ADDRESS_CLAMP," \
        "addressV = TEXTURE_ADDRESS_CLAMP," \
        "addressW = TEXTURE_ADDRESS_CLAMP," \
        "filter = FILTER_MIN_MAG_MIP_LINEAR)"


#define SSR_TEMPORAL_RS_CB           0
#define SSR_TEMPORAL_RS_TEXTURES     1



struct ssr_median_blur_cb
{
    vec2 invDimensions;
};

#define SSR_MEDIAN_BLUR_RS \
    "RootFlags(0), " \
    "RootConstants(b0, num32BitConstants = 2), " \
    "DescriptorTable( UAV(u0, numDescriptors = 1), SRV(t0, numDescriptors = 1) )," \
    "StaticSampler(s0," \
        "addressU = TEXTURE_ADDRESS_CLAMP," \
        "addressV = TEXTURE_ADDRESS_CLAMP," \
        "addressW = TEXTURE_ADDRESS_CLAMP," \
        "filter = FILTER_MIN_MAG_MIP_LINEAR)"


#define SSR_MEDIAN_BLUR_RS_CB           0
#define SSR_MEDIAN_BLUR_RS_TEXTURES     1

#endif

```

`shaders/rs/terrain_rs.hlsli`:

```hlsli
#ifndef TERRAIN_RS_HLSLI
#define TERRAIN_RS_HLSLI

// Must match heightmap_collider.h
#define TERRAIN_LOD_0_VERTICES_PER_DIMENSION 129u
#define TERRAIN_MAX_LOD 5u


struct terrain_cb
{
	vec3 minCorner;
	uint32 lod;
	float chunkSize;
	float amplitudeScale;
	uint32 scaleDownByLODs; // 4 * 8 bit.
};

struct terrain_water_plane_cb
{
	vec4 waterMinMaxXZ[4];
	vec4 waterHeights;
	uint32 numWaterPlanes;
};

#define SCALE_DOWN_BY_LODS(negX, posX, negZ, posZ) ((negX << 24) | (posX << 16) | (negZ << 8) | posZ)
#define DECODE_LOD_SCALE(v, negX, posX, negZ, posZ) negX = v >> 24, posX = (v >> 16) & 0xFF, negZ = (v >> 8) & 0xFF, posZ = v & 0xFF;

struct terrain_transform_cb
{
	mat4 vp;
};


#define TERRAIN_RS \
	"RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT |" \
	"DENY_HULL_SHADER_ROOT_ACCESS |" \
	"DENY_DOMAIN_SHADER_ROOT_ACCESS |" \
	"DENY_GEOMETRY_SHADER_ROOT_ACCESS)," \
	"RootConstants(num32BitConstants=16, b0, visibility=SHADER_VISIBILITY_VERTEX)," \
	"RootConstants(num32BitConstants=7, b1)," \
	"CBV(b2)," \
	"DescriptorTable(SRV(t0, numDescriptors=1), visibility=SHADER_VISIBILITY_VERTEX)," \
	"DescriptorTable(SRV(t1, numDescriptors=1), visibility=SHADER_VISIBILITY_PIXEL)," \
	"CBV(b1, space=1), " \
	"CBV(b2, space=1), " \
	"DescriptorTable(SRV(t0, space=1, numDescriptors=9), visibility=SHADER_VISIBILITY_PIXEL)," \
    "DescriptorTable(SRV(t0, space=2, numDescriptors=7), visibility=SHADER_VISIBILITY_PIXEL), " \
	"StaticSampler(s0," \
        "addressU = TEXTURE_ADDRESS_CLAMP," \
        "addressV = TEXTURE_ADDRESS_CLAMP," \
        "addressW = TEXTURE_ADDRESS_CLAMP," \
        "filter = FILTER_MIN_MAG_MIP_LINEAR," \
        "visibility=SHADER_VISIBILITY_PIXEL), " \
	"StaticSampler(s1," \
        "addressU = TEXTURE_ADDRESS_WRAP," \
        "addressV = TEXTURE_ADDRESS_WRAP," \
        "addressW = TEXTURE_ADDRESS_WRAP," \
        "filter = FILTER_ANISOTROPIC," \
        "visibility=SHADER_VISIBILITY_PIXEL), " \
    "StaticSampler(s2," \
        "addressU = TEXTURE_ADDRESS_CLAMP," \
        "addressV = TEXTURE_ADDRESS_CLAMP," \
        "addressW = TEXTURE_ADDRESS_CLAMP," \
        "filter = FILTER_COMPARISON_MIN_MAG_LINEAR_MIP_POINT," \
        "visibility=SHADER_VISIBILITY_PIXEL)"


#define TERRAIN_RS_TRANSFORM		0
#define TERRAIN_RS_CB				1
#define TERRAIN_RS_WATER			2
#define TERRAIN_RS_HEIGHTMAP		3
#define TERRAIN_RS_NORMALMAP		4
#define TERRAIN_RS_CAMERA			5
#define TERRAIN_RS_LIGHTING			6
#define TERRAIN_RS_TEXTURES			7
#define TERRAIN_RS_FRAME_CONSTANTS  8




#define TERRAIN_DEPTH_ONLY_RS \
    "RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT |" \
    "DENY_HULL_SHADER_ROOT_ACCESS |" \
    "DENY_DOMAIN_SHADER_ROOT_ACCESS |" \
    "DENY_GEOMETRY_SHADER_ROOT_ACCESS)," \
    "RootConstants(num32BitConstants=32, b0, visibility=SHADER_VISIBILITY_VERTEX), " \
    "RootConstants(num32BitConstants=7, b1, visibility=SHADER_VISIBILITY_VERTEX), " \
    "RootConstants(num32BitConstants=1, b2, visibility=SHADER_VISIBILITY_VERTEX), " \
    "CBV(b0, space=1), " \
	"DescriptorTable(SRV(t0, numDescriptors=1), visibility=SHADER_VISIBILITY_VERTEX)"

#define TERRAIN_DEPTH_ONLY_RS_TRANSFORM		0
#define TERRAIN_DEPTH_ONLY_RS_CB			1
#define TERRAIN_DEPTH_ONLY_RS_OBJECT_ID     2
#define TERRAIN_DEPTH_ONLY_RS_CAMERA		3
#define TERRAIN_DEPTH_ONLY_RS_HEIGHTMAP		4



#define TERRAIN_SHADOW_RS \
	"RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT |" \
    "DENY_HULL_SHADER_ROOT_ACCESS |" \
    "DENY_DOMAIN_SHADER_ROOT_ACCESS |" \
    "DENY_GEOMETRY_SHADER_ROOT_ACCESS |" \
    "DENY_PIXEL_SHADER_ROOT_ACCESS)," \
    "RootConstants(num32BitConstants=16, b0, visibility=SHADER_VISIBILITY_VERTEX), " \
	"RootConstants(num32BitConstants=7, b1, visibility=SHADER_VISIBILITY_VERTEX), " \
	"DescriptorTable(SRV(t0, numDescriptors=1), visibility=SHADER_VISIBILITY_VERTEX)"

#define TERRAIN_SHADOW_RS_TRANSFORM		0
#define TERRAIN_SHADOW_RS_CB			1
#define TERRAIN_SHADOW_RS_HEIGHTMAP		2


#define TERRAIN_OUTLINE_RS \
    "RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT |" \
    "DENY_HULL_SHADER_ROOT_ACCESS |" \
    "DENY_DOMAIN_SHADER_ROOT_ACCESS |" \
    "DENY_GEOMETRY_SHADER_ROOT_ACCESS |" \
    "DENY_PIXEL_SHADER_ROOT_ACCESS)," \
    "RootConstants(num32BitConstants=16, b0, visibility=SHADER_VISIBILITY_VERTEX), " \
    "RootConstants(num32BitConstants=7, b1, visibility=SHADER_VISIBILITY_VERTEX), " \
	"DescriptorTable(SRV(t0, numDescriptors=1), visibility=SHADER_VISIBILITY_VERTEX)"

#define TERRAIN_OUTLINE_RS_TRANSFORM		0
#define TERRAIN_OUTLINE_RS_CB				1
#define TERRAIN_OUTLINE_RS_HEIGHTMAP		2


struct terrain_generation_settings_cb
{
	vec2 domainWarpNoiseOffset;
	vec2 noiseOffset;

	uint32 heightWidth;
	uint32 heightHeight;
	uint32 normalWidth;
	uint32 normalHeight;

	float positionScale;
	float normalScale;

	float scale;

	float domainWarpStrength;

	uint32 domainWarpOctaves;

	uint32 noiseOctaves;
};

struct terrain_generation_cb
{
	vec2 minCorner;
};

#define TERRAIN_GENERATION_RS \
	"RootConstants(num32BitConstants=2, b0), " \
	"CBV(b1), " \
	"DescriptorTable(UAV(u0, numDescriptors=2))"

#define TERRAIN_GENERATION_RS_CB		0
#define TERRAIN_GENERATION_RS_SETTINGS	1
#define TERRAIN_GENERATION_RS_TEXTURES	2




#endif


```

`shaders/rs/tree_rs.hlsli`:

```hlsli
#ifndef TREE_RS_HLSLI
#define TREE_RS_HLSLI

#include "transform.hlsli"

struct tree_cb
{
    float time;
};

#define TREE_RS \
    "RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT |" \
    "DENY_HULL_SHADER_ROOT_ACCESS |" \
    "DENY_DOMAIN_SHADER_ROOT_ACCESS |" \
    "DENY_GEOMETRY_SHADER_ROOT_ACCESS)," \
    "SRV(t0, visibility=SHADER_VISIBILITY_VERTEX), " \
    "RootConstants(num32BitConstants=1, b1, visibility=SHADER_VISIBILITY_VERTEX), " \
    "RootConstants(num32BitConstants=6, b0, space=1, visibility=SHADER_VISIBILITY_PIXEL),"  \
    "CBV(b1, space=1), " \
    "CBV(b2, space=1, visibility=SHADER_VISIBILITY_PIXEL),"  \
    "DescriptorTable(SRV(t0, numDescriptors=4, space=1), visibility=SHADER_VISIBILITY_PIXEL), " \
    "DescriptorTable(SRV(t0, space=2, numDescriptors=17), visibility=SHADER_VISIBILITY_PIXEL), " \
    "StaticSampler(s0," \
        "addressU = TEXTURE_ADDRESS_WRAP," \
        "addressV = TEXTURE_ADDRESS_WRAP," \
        "addressW = TEXTURE_ADDRESS_WRAP," \
        "filter = FILTER_ANISOTROPIC," \
        "visibility=SHADER_VISIBILITY_PIXEL)," \
    "StaticSampler(s1," \
        "addressU = TEXTURE_ADDRESS_CLAMP," \
        "addressV = TEXTURE_ADDRESS_CLAMP," \
        "addressW = TEXTURE_ADDRESS_CLAMP," \
        "filter = FILTER_ANISOTROPIC," \
        "visibility=SHADER_VISIBILITY_PIXEL)," \
    "StaticSampler(s2," \
        "addressU = TEXTURE_ADDRESS_CLAMP," \
        "addressV = TEXTURE_ADDRESS_CLAMP," \
        "addressW = TEXTURE_ADDRESS_CLAMP," \
        "filter = FILTER_COMPARISON_MIN_MAG_LINEAR_MIP_POINT," \
        "visibility=SHADER_VISIBILITY_PIXEL)"


#define TREE_RS_TRANSFORM	        0
#define TREE_RS_CB                  1
#define TREE_RS_MATERIAL            2
#define TREE_RS_CAMERA              3
#define TREE_RS_LIGHTING            4
#define TREE_RS_PBR_TEXTURES        5
#define TREE_RS_FRAME_CONSTANTS     6

#endif

```

`shaders/rs/visualization_rs.hlsli`:

```hlsli
#ifndef VISUALIZATION_HLSLI
#define VISUALIZATION_HLSLI

struct visualization_cb
{
	vec4 color;
};

#define FLAT_SIMPLE_RS \
	"RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT |" \
	"DENY_HULL_SHADER_ROOT_ACCESS |" \
	"DENY_DOMAIN_SHADER_ROOT_ACCESS |" \
	"DENY_GEOMETRY_SHADER_ROOT_ACCESS)," \
	"RootConstants(num32BitConstants=32, b0, visibility=SHADER_VISIBILITY_VERTEX), " \
	"RootConstants(num32BitConstants=4, b1, visibility=SHADER_VISIBILITY_PIXEL), " \
	"CBV(b2, visibility=SHADER_VISIBILITY_PIXEL)"

#define FLAT_SIMPLE_RS_TRANFORM			0
#define FLAT_SIMPLE_RS_CB				1
#define FLAT_SIMPLE_RS_CAMERA			2


#define FLAT_UNLIT_RS \
	"RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT |" \
	"DENY_HULL_SHADER_ROOT_ACCESS |" \
	"DENY_DOMAIN_SHADER_ROOT_ACCESS |" \
	"DENY_GEOMETRY_SHADER_ROOT_ACCESS)," \
	"RootConstants(num32BitConstants=16, b0, visibility=SHADER_VISIBILITY_VERTEX)," \
	"RootConstants(num32BitConstants=4, b1, visibility=SHADER_VISIBILITY_PIXEL)"

#define FLAT_UNLIT_RS_TRANFORM			0
#define FLAT_UNLIT_RS_CB				1




struct visualize_sun_shadow_cascades_cb
{
	mat4 invViewProj;
	vec4 cameraPosition;
	vec4 cameraForward;
};

#define VISUALIZE_SUN_SHADOW_CASCADES_RS \
	"RootFlags(0), " \
	"RootConstants(num32BitConstants=24, b0)," \
	"CBV(b1), " \
	"DescriptorTable(UAV(u0, numDescriptors=1), SRV(t0, numDescriptors=1))"

#define VISUALIZE_SUN_SHADOW_CASCADES_RS_CB			0
#define VISUALIZE_SUN_SHADOW_CASCADES_RS_SUN		1
#define VISUALIZE_SUN_SHADOW_CASCADES_RS_TEXTURES	2


#endif

```

`shaders/rs/water_rs.hlsli`:

```hlsli
#ifndef WATER_RS_HLSLI
#define WATER_RS_HLSLI

#include "transform.hlsli"

struct water_cb
{
    vec4 deepColor;
    vec4 shallowColor;
    vec2 uvOffset;
    float uvScale;
    float shallowDepth;
    float transitionStrength;
    float normalmapStrength;
};


#define WATER_RS \
	"RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT |" \
    "DENY_HULL_SHADER_ROOT_ACCESS |" \
    "DENY_DOMAIN_SHADER_ROOT_ACCESS |" \
    "DENY_GEOMETRY_SHADER_ROOT_ACCESS)," \
    "RootConstants(num32BitConstants=32, b0, visibility=SHADER_VISIBILITY_VERTEX), " \
    "RootConstants(num32BitConstants=16, b0, space=1, visibility=SHADER_VISIBILITY_PIXEL), " \
    "CBV(b1, space=1, visibility=SHADER_VISIBILITY_PIXEL), " \
    "CBV(b2, space=1, visibility=SHADER_VISIBILITY_PIXEL), " \
    "DescriptorTable(SRV(t0, numDescriptors=6), visibility=SHADER_VISIBILITY_PIXEL)," \
    "DescriptorTable(SRV(t0, space=2, numDescriptors=7), visibility=SHADER_VISIBILITY_PIXEL), " \
    "StaticSampler(s0," \
        "addressU = TEXTURE_ADDRESS_CLAMP," \
        "addressV = TEXTURE_ADDRESS_CLAMP," \
        "addressW = TEXTURE_ADDRESS_CLAMP," \
        "filter = FILTER_MIN_MAG_MIP_LINEAR," \
        "visibility=SHADER_VISIBILITY_PIXEL), " \
    "StaticSampler(s1," \
        "addressU = TEXTURE_ADDRESS_WRAP," \
        "addressV = TEXTURE_ADDRESS_WRAP," \
        "addressW = TEXTURE_ADDRESS_WRAP," \
        "filter = FILTER_ANISOTROPIC," \
        "visibility=SHADER_VISIBILITY_PIXEL), " \
    "StaticSampler(s2," \
        "addressU = TEXTURE_ADDRESS_CLAMP," \
        "addressV = TEXTURE_ADDRESS_CLAMP," \
        "addressW = TEXTURE_ADDRESS_CLAMP," \
        "filter = FILTER_COMPARISON_MIN_MAG_LINEAR_MIP_POINT," \
        "visibility=SHADER_VISIBILITY_PIXEL)"

#define WATER_RS_TRANSFORM          0
#define WATER_RS_SETTINGS           1
#define WATER_RS_CAMERA             2
#define WATER_RS_LIGHTING           3
#define WATER_RS_TEXTURES           4
#define WATER_RS_FRAME_CONSTANTS    5

#endif


```

`shaders/shadow_map_copy_ps.hlsl`:

```hlsl

#define SHADOW_MAP_COPY_RS \
"RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT |" \
"DENY_VERTEX_SHADER_ROOT_ACCESS |" \
"DENY_HULL_SHADER_ROOT_ACCESS |" \
"DENY_DOMAIN_SHADER_ROOT_ACCESS |" \
"DENY_GEOMETRY_SHADER_ROOT_ACCESS)," \
"RootConstants(num32BitConstants=4, b0, visibility=SHADER_VISIBILITY_PIXEL),"  \
"StaticSampler(s0," \
	"addressU = TEXTURE_ADDRESS_CLAMP," \
	"addressV = TEXTURE_ADDRESS_CLAMP," \
	"addressW = TEXTURE_ADDRESS_CLAMP," \
	"filter = FILTER_MIN_MAG_MIP_POINT,"	\
	"visibility=SHADER_VISIBILITY_PIXEL)," \
"DescriptorTable(SRV(t0, numDescriptors=1, flags = DESCRIPTORS_VOLATILE), visibility=SHADER_VISIBILITY_PIXEL)"

struct ps_input
{
	float2 uv	: TEXCOORDS;
};

cbuffer shadow_map_copy_cb : register(b0)
{
	float2 uvOffset;
	float2 uvScale;
};

SamplerState texSampler				: register(s0);
Texture2D<float> shadowMap			: register(t0);

[RootSignature(SHADOW_MAP_COPY_RS)]
float main(ps_input IN) : SV_Depth
{
	return shadowMap.Sample(texSampler, IN.uv * uvScale + uvOffset);
}

```

`shaders/skinning/cloth_skinning_cs.hlsl`:

```hlsl
#include "cs.hlsli"
#include "skinning_rs.hlsli"
#include "math.hlsli"


#define NUM_QUADS_PER_DIM 16
#define NUM_TOTAL_QUADS (NUM_QUADS_PER_DIM * NUM_QUADS_PER_DIM)
#define NUM_TOTAL_TRIS (NUM_TOTAL_QUADS * 2)
#define NUM_VERTS_TO_WRITE_PER_DIM (NUM_QUADS_PER_DIM - 1)
#define NUM_VERTS_TO_LOAD_PER_DIM (NUM_VERTS_TO_WRITE_PER_DIM + 2)
#define NUM_TOTAL_VERTS_TO_WRITE (NUM_VERTS_TO_WRITE_PER_DIM * NUM_VERTS_TO_WRITE_PER_DIM)
#define NUM_TOTAL_VERTS_TO_LOAD (NUM_VERTS_TO_LOAD_PER_DIM * NUM_VERTS_TO_LOAD_PER_DIM)

#define GROUP_FIRST_VERTEX_STRIDE NUM_VERTS_TO_WRITE_PER_DIM

#define BLOCK_SIZE NUM_QUADS_PER_DIM
#define NUM_THREADS (BLOCK_SIZE * BLOCK_SIZE)








ConstantBuffer<cloth_skinning_cb> skinningCB		: register(b0);

StructuredBuffer<mesh_position> inputPositions		: register(t0);
RWStructuredBuffer<mesh_position> outputPositions	: register(u0);
RWStructuredBuffer<mesh_others> outputOthers		: register(u1);

groupshared float3 g_positions[NUM_TOTAL_VERTS_TO_LOAD];
groupshared int3 g_normals[NUM_TOTAL_VERTS_TO_LOAD];
groupshared int3 g_tangents[NUM_TOTAL_VERTS_TO_LOAD];


static void processTriangle(int a, int b, int c, float2 aUV, float2 bUV, float2 cUV)
{
	float3 edge0 = g_positions[b] - g_positions[a];
	float3 edge1 = g_positions[c] - g_positions[a];

	float3 normal = cross(edge0, edge1);
	int3 inormal = int3(normal * 0xFFFF);

	InterlockedAdd(g_normals[a].x, inormal.x);
	InterlockedAdd(g_normals[a].y, inormal.y);
	InterlockedAdd(g_normals[a].z, inormal.z);
	InterlockedAdd(g_normals[b].x, inormal.x);
	InterlockedAdd(g_normals[b].y, inormal.y);
	InterlockedAdd(g_normals[b].z, inormal.z);
	InterlockedAdd(g_normals[c].x, inormal.x);
	InterlockedAdd(g_normals[c].y, inormal.y);
	InterlockedAdd(g_normals[c].z, inormal.z);


	float2 deltaUV0 = cUV - aUV;
	float2 deltaUV1 = bUV - aUV;

	float f = 1.f / cross2(deltaUV0, deltaUV1);
	float3 tangent = f * (deltaUV1.y * edge0 - deltaUV0.y * edge1);
	int3 itangent = int3(tangent * 0xFFFF);

	InterlockedAdd(g_tangents[a].x, itangent.x);
	InterlockedAdd(g_tangents[a].y, itangent.y);
	InterlockedAdd(g_tangents[a].z, itangent.z);
	InterlockedAdd(g_tangents[b].x, itangent.x);
	InterlockedAdd(g_tangents[b].y, itangent.y);
	InterlockedAdd(g_tangents[b].z, itangent.z);
	InterlockedAdd(g_tangents[c].x, itangent.x);
	InterlockedAdd(g_tangents[c].y, itangent.y);
	InterlockedAdd(g_tangents[c].z, itangent.z);
}


[RootSignature(CLOTH_SKINNING_RS)]
[numthreads(BLOCK_SIZE, BLOCK_SIZE, 1)]
void main(cs_input IN)
{
	const int2 firstVertexToProcess = IN.groupID.xy * GROUP_FIRST_VERTEX_STRIDE;
	const int2 firstVertexToLoad = firstVertexToProcess - int2(1, 1);

	uint t;
	for (t = IN.groupIndex; t < NUM_TOTAL_VERTS_TO_LOAD; t += NUM_THREADS)
	{
		int2 globalIndex2D = firstVertexToLoad + unflatten2D(t, NUM_VERTS_TO_LOAD_PER_DIM);
		globalIndex2D = clamp(globalIndex2D, 0, int2(skinningCB.gridSizeX - 1, skinningCB.gridSizeY - 1));
		const int index = flatten2D(globalIndex2D, skinningCB.gridSizeX);
		g_positions[t] = inputPositions[index].position;
		g_normals[t] = int3(0, 0, 0);
		g_tangents[t] = int3(0, 0, 0);
	}

	GroupMemoryBarrierWithGroupSync();

	// Each thread processes one quad -> two triangles.
	{
		const int2 quadIndex = unflatten2D(IN.groupIndex, NUM_QUADS_PER_DIM);
		const int tlIndex = flatten2D(quadIndex, NUM_VERTS_TO_LOAD_PER_DIM);
		const int trIndex = tlIndex + 1;
		const int blIndex = tlIndex + NUM_VERTS_TO_LOAD_PER_DIM;
		const int brIndex = blIndex + 1;

		const float2 tlUV = float2(0.f, 0.f);
		const float2 trUV = float2(1.f, 0.f);
		const float2 blUV = float2(0.f, 1.f);
		const float2 brUV = float2(1.f, 1.f);

		processTriangle(tlIndex, blIndex, trIndex, tlUV, blUV, trUV);
		processTriangle(brIndex, trIndex, blIndex, brUV, trUV, blUV);
	}

	GroupMemoryBarrierWithGroupSync();

	float2 invSize = float2(1.f, 1.f) / float2(skinningCB.gridSizeX - 1, skinningCB.gridSizeY - 1);

	for (t = IN.groupIndex; t < NUM_TOTAL_VERTS_TO_WRITE; t += NUM_THREADS)
	{
		uint2 blockIndex2D = unflatten2D(t, NUM_VERTS_TO_WRITE_PER_DIM);
		uint2 globalIndex2D = blockIndex2D + firstVertexToProcess;

		if (globalIndex2D.x < skinningCB.gridSizeX && globalIndex2D.y < skinningCB.gridSizeY)
		{
			uint globalIndex = flatten2D(globalIndex2D, skinningCB.gridSizeX);
			uint readIndex = (blockIndex2D.y + 1) * NUM_VERTS_TO_LOAD_PER_DIM + blockIndex2D.x + 1;

			mesh_position position;
			position.position = g_positions[readIndex];
			outputPositions[skinningCB.writeOffset + globalIndex] = position;

			mesh_others others;
			others.uv = globalIndex2D * invSize;
			others.normal = (float3)g_normals[readIndex] / 0xFFFF;
			others.tangent = (float3)g_tangents[readIndex] / 0xFFFF;
			outputOthers[skinningCB.writeOffset + globalIndex] = others;
		}
	}
}

```

`shaders/skinning/skinning_cs.hlsl`:

```hlsl
#include "cs.hlsli"
#include "skinning_rs.hlsli"


#define BLOCK_SIZE 512


ConstantBuffer<skinning_cb> skinningCB					: register(b0);

StructuredBuffer<skinned_mesh_position> inputPositions	: register(t0);
StructuredBuffer<skinned_mesh_others> inputOthers		: register(t1);

StructuredBuffer<float4x4> skinningMatrices				: register(t2);
RWStructuredBuffer<mesh_position> outputPositions		: register(u0);
RWStructuredBuffer<mesh_others> outputOthers			: register(u1);


[RootSignature(SKINNING_RS)]
[numthreads(BLOCK_SIZE, 1, 1)]
void main(cs_input IN)
{
	uint index = IN.dispatchThreadID.x;

	if (index >= skinningCB.numVertices)
	{
		return;
	}

	float3 inputPosition = inputPositions[skinningCB.firstVertex + index].position;
	skinned_mesh_others inputOther = inputOthers[skinningCB.firstVertex + index];

	uint4 skinIndices = uint4(
		inputOther.skinIndices >> 24,
		(inputOther.skinIndices >> 16) & 0xFF,
		(inputOther.skinIndices >> 8) & 0xFF,
		inputOther.skinIndices & 0xFF
		);

	float4 skinWeights = float4(
		inputOther.skinWeights >> 24,
		(inputOther.skinWeights >> 16) & 0xFF,
		(inputOther.skinWeights >> 8) & 0xFF,
		inputOther.skinWeights & 0xFF
		) * (1.f / 255.f);

	skinWeights /= dot(skinWeights, (float4)1.f);

	skinIndices += skinningCB.firstJoint.xxxx;

	float4x4 s =
		skinningMatrices[skinIndices.x] * skinWeights.x +
		skinningMatrices[skinIndices.y] * skinWeights.y +
		skinningMatrices[skinIndices.z] * skinWeights.z +
		skinningMatrices[skinIndices.w] * skinWeights.w;

	float3 position = mul(s, float4(inputPosition, 1.f)).xyz;
	float3 normal = mul(s, float4(inputOther.normal, 0.f)).xyz;
	float3 tangent = mul(s, float4(inputOther.tangent, 0.f)).xyz;


	mesh_position outputPosition = { position };
	mesh_others outputOther = { inputOther.uv, normal, tangent };
	outputPositions[skinningCB.writeOffset + index] = outputPosition;
	outputOthers[skinningCB.writeOffset + index] = outputOther;
}

```

`shaders/sky/sky_procedural_ps.hlsl`:

```hlsl
#include "math.hlsli"
#include "sky_rs.hlsli"
#include "procedural_sky.hlsli"


ConstantBuffer<sky_cb> cb : register(b1);

struct ps_input
{
	float3 uv				: TEXCOORDS;
	float3 ndc				: NDC;
	float3 prevFrameNDC		: PREV_FRAME_NDC;
};

struct ps_output
{
	float4 color			: SV_Target0;
	float2 screenVelocity	: SV_Target1;
	uint objectID			: SV_Target2;
};

[RootSignature(SKY_PROCEDURAL_RS)]
ps_output main(ps_input IN)
{
	float3 V = normalize(IN.uv);
	float3 L = -cb.sunDirection;

	float3 color = proceduralSky(V, L);

	color *= cb.intensity;

	ps_output OUT;
	OUT.color = float4(max(color, 0.f), 0.f);
	OUT.screenVelocity = screenSpaceVelocity(IN.ndc, IN.prevFrameNDC, cb.jitter, cb.prevFrameJitter);
	OUT.objectID = 0xFFFFFFFF; // -1.
	return OUT;
}

```

`shaders/sky/sky_texture_ps.hlsl`:

```hlsl
#include "sky_rs.hlsli"
#include "math.hlsli"

ConstantBuffer<sky_cb> cb : register(b1);

struct ps_input
{
	float3 uv				: TEXCOORDS;
	float3 ndc				: NDC;
	float3 prevFrameNDC		: PREV_FRAME_NDC;
};

SamplerState texSampler	: register(s0);
TextureCube<float4> tex	: register(t0);

struct ps_output
{
	float4 color			: SV_Target0;
	float2 screenVelocity	: SV_Target1;
	uint objectID			: SV_Target2;
};

[RootSignature(SKY_TEXTURE_RS)]
ps_output main(ps_input IN)
{
	ps_output OUT;
	OUT.color = float4((tex.Sample(texSampler, IN.uv) * cb.intensity).xyz, 0.f);
	OUT.screenVelocity = screenSpaceVelocity(IN.ndc, IN.prevFrameNDC, cb.jitter, cb.prevFrameJitter);
	OUT.objectID = 0xFFFFFFFF; // -1.
	return OUT;
}

```

`shaders/sky/sky_vs.hlsl`:

```hlsl
#include "sky_rs.hlsli"

ConstantBuffer<sky_transform_cb> transform : register(b0);

struct vs_input
{
	uint vertexID	: SV_VertexID;
};

struct vs_output
{
	float3 uv				: TEXCOORDS;
	float3 ndc				: NDC;
	float3 prevFrameNDC		: PREV_FRAME_NDC;

	float4 position			: SV_Position;
};

vs_output main(vs_input IN)
{
	vs_output OUT;

	uint b = 1u << IN.vertexID;
	float3 pos = float3(
		(0x287a & b) != 0, 
		(0x02af & b) != 0, 
		(0x31e3 & b) != 0
	) * 2.f - 1.f;

	OUT.uv = pos;
	OUT.position = mul(transform.vp, float4(pos, 1.f));
	OUT.position.z = OUT.position.w - 1e-6f;

	OUT.ndc = OUT.position.xyw;
	OUT.prevFrameNDC = mul(transform.prevFrameVP, float4(pos, 1.f)).xyw;

	return OUT;
}

```

`shaders/terrain/terrain_depth_only_vs.hlsl`:

```hlsl
#include "depth_only_rs.hlsli"
#include "terrain_height.hlsli"


ConstantBuffer<depth_only_transform_cb> transform	: register(b0);
ConstantBuffer<terrain_cb> terrain					: register(b1);
ConstantBuffer<depth_only_object_id_cb> id			: register(b2);

Texture2D<float> heightmap							: register(t0);

struct vs_input
{
	uint vertexID	: SV_VertexID;
};

struct vs_output
{
	float3 ndc						: NDC;
	float3 prevFrameNDC				: PREV_FRAME_NDC;

	nointerpolation uint objectID	: OBJECT_ID;

	float4 position					: SV_POSITION;
};

[RootSignature(TERRAIN_DEPTH_ONLY_RS)]
vs_output main(vs_input IN)
{
	float3 position;
	float2 uv;
	terrainVertexPosition(terrain, IN.vertexID, heightmap, position, uv);

	vs_output OUT;
	OUT.position = mul(transform.mvp, float4(position, 1.f));
	OUT.ndc = OUT.position.xyw;
	OUT.prevFrameNDC = mul(transform.prevFrameMVP, float4(position, 1.f)).xyw;
	OUT.objectID = id.id;
	return OUT;
}

```

`shaders/terrain/terrain_generation_cs.hlsl`:

```hlsl
#include "cs.hlsli"
#include "random.hlsli"
#include "terrain_rs.hlsli"

ConstantBuffer<terrain_generation_cb> cb				: register(b0);
ConstantBuffer<terrain_generation_settings_cb> settings	: register(b1);

RWTexture2D<float> heights								: register(u0);
RWTexture2D<float2> normals								: register(u1);



[numthreads(16, 16, 1)]
[RootSignature(TERRAIN_GENERATION_RS)]
void main(cs_input IN)
{
	uint2 i = IN.dispatchThreadID.xy;

	if (i.x < settings.normalWidth && i.y < settings.normalHeight)
	{
		float2 position = float2(i) * settings.normalScale + cb.minCorner;

		float2 fbmPosition = position * settings.scale;
		float J_fbmPosition_position = settings.scale;

		float3 domainWarpValue = fbm(fbmPosition + settings.domainWarpNoiseOffset, settings.domainWarpOctaves);
		float domainWarpHeight = domainWarpValue.x;
		float2 J_domainWarpHeight_fbmPosition = domainWarpValue.yz;

		float2 warpedFbmPosition = fbmPosition + domainWarpHeight * settings.domainWarpStrength + settings.noiseOffset + 1000.f;
		float J_warpedFbmPosition_fbmPosition = 1.f;
		float J_warpedFbmPosition_domainWarpHeight = settings.domainWarpStrength;

		float3 value = fbm(warpedFbmPosition, settings.noiseOctaves);
		float height = value.x;
		float2 J_height_warpedFbmPosition = value.yz;

		float scaledHeight = height * 0.5f + 0.5f;
		float J_scaledHeight_height = 0.5f;

		float2 grad = J_scaledHeight_height * J_height_warpedFbmPosition *
			(J_warpedFbmPosition_fbmPosition + J_warpedFbmPosition_domainWarpHeight * J_domainWarpHeight_fbmPosition) * J_fbmPosition_position;

		normals[i] = -grad;
	}

	if (i.x < settings.heightWidth && i.y < settings.heightHeight)
	{
		float2 position = float2(i) * settings.positionScale + cb.minCorner;

		float2 fbmPosition = position * settings.scale;

		float3 domainWarpValue = fbm(fbmPosition + settings.domainWarpNoiseOffset, settings.domainWarpOctaves);

		float2 warpedFbmPosition = fbmPosition + domainWarpValue.x * settings.domainWarpStrength + settings.noiseOffset + 1000.f;
		float3 value = fbm(warpedFbmPosition); // We are using a lower number of noise octaves here, since the heightmap is lowres anyway.
		float height = value.x;

		height = height * 0.5f + 0.5f;

		heights[i] = height;
	}
}

```

`shaders/terrain/terrain_height.hlsli`:

```hlsli
#ifndef TERRAIN_HEIGHT_HLSLI
#define TERRAIN_HEIGHT_HLSLI

#include "terrain_rs.hlsli"

static uint getMask(uint isBorder, uint scaleDownByLOD)
{
	return ~0u << (scaleDownByLOD * isBorder);
}

#define ENSURE_CONSISTENT_ORIENTATION 1

static void terrainVertexPosition(terrain_cb terrain, uint vertexID, Texture2D<float> heightmap, out float3 outPosition, out float2 outUV)
{
	uint numSegmentsPerDim = (TERRAIN_LOD_0_VERTICES_PER_DIMENSION - 1) >> terrain.lod;
	uint numVerticesPerDim = numSegmentsPerDim + 1;

	uint x = vertexID % numVerticesPerDim;
	uint z = vertexID / numVerticesPerDim;

	uint scaleDownByLOD_left, scaleDownByLOD_right, scaleDownByLOD_top, scaleDownByLOD_bottom;
	DECODE_LOD_SCALE(terrain.scaleDownByLODs, scaleDownByLOD_left, scaleDownByLOD_right, scaleDownByLOD_top, scaleDownByLOD_bottom);

	const uint leftMask = getMask(x == 0, scaleDownByLOD_left);
	const uint rightMask = getMask(x == numVerticesPerDim - 1, scaleDownByLOD_right);
	const uint topMask = getMask(z == 0, scaleDownByLOD_top);
	const uint bottomMask = getMask(z == numVerticesPerDim - 1, scaleDownByLOD_bottom);

	const uint zMask = leftMask & rightMask;
	const uint xMask = topMask & bottomMask;

#if ENSURE_CONSISTENT_ORIENTATION
	// Will this vertex be shifted by the mask?
	const uint shiftedRight = (z & ~rightMask) != 0;
	const uint shiftedTop = (x & ~topMask) != 0;
#endif

	x &= xMask;
	z &= zMask;

#if ENSURE_CONSISTENT_ORIENTATION
	// Offset shifted vertices to next neighbor.
	x += shiftedTop * (1u << scaleDownByLOD_top);
	z += shiftedRight * (1u << scaleDownByLOD_right);
#endif



	float norm = 1.f / (float)numSegmentsPerDim;

	float height = heightmap[uint2(x << terrain.lod, z << terrain.lod)] * terrain.amplitudeScale;

	float2 uv = float2(x * norm, z * norm);

	float3 position = float3(uv.x * terrain.chunkSize, height, uv.y * terrain.chunkSize) + terrain.minCorner;

	outPosition = position;
	outUV = uv;
}



#endif


```

`shaders/terrain/terrain_outline_vs.hlsl`:

```hlsl
#include "terrain_height.hlsli"


ConstantBuffer<terrain_transform_cb> transform		: register(b0);
ConstantBuffer<terrain_cb> terrain					: register(b1);

Texture2D<float> heightmap							: register(t0);

struct vs_input
{
	uint vertexID	: SV_VertexID;
};

[RootSignature(TERRAIN_OUTLINE_RS)]
float4 main(vs_input IN) : SV_POSITION
{
	float3 position;
	float2 uv;
	terrainVertexPosition(terrain, IN.vertexID, heightmap, position, uv);

	return mul(transform.vp, float4(position, 1.f));
}

```

`shaders/terrain/terrain_ps.hlsl`:

```hlsl
#include "terrain_rs.hlsli"
#include "normal.hlsli"
#include "random.hlsli"
#include "camera.hlsli"
#include "lighting.hlsli"

Texture2D<float2> normals						: register(t1);
SamplerState clampSampler						: register(s0);
SamplerState wrapSampler						: register(s1);
SamplerComparisonState shadowSampler			: register(s2);

ConstantBuffer<terrain_cb> cb					: register(b1);
ConstantBuffer<terrain_water_plane_cb> water	: register(b2);

ConstantBuffer<camera_cb> camera				: register(b1, space1);
ConstantBuffer<lighting_cb> lighting			: register(b2, space1);

Texture2D<float4> groundAlbedoTexture			: register(t0, space1);
Texture2D<float3> groundNormalTexture			: register(t1, space1);
Texture2D<float1> groundRoughnessTexture		: register(t2, space1);
Texture2D<float4> rockAlbedoTexture				: register(t3, space1);
Texture2D<float3> rockNormalTexture				: register(t4, space1);
Texture2D<float1> rockRoughnessTexture			: register(t5, space1);
Texture2D<float4> mudAlbedoTexture				: register(t6, space1);
Texture2D<float3> mudNormalTexture				: register(t7, space1);
Texture2D<float1> mudRoughnessTexture			: register(t8, space1);


TextureCube<float4> irradianceTexture					: register(t0, space2);
TextureCube<float4> prefilteredRadianceTexture			: register(t1, space2);

Texture2D<float2> brdf									: register(t2, space2);

Texture2D<float> shadowMap								: register(t3, space2);

Texture2D<float> aoTexture								: register(t4, space2);
Texture2D<float> sssTexture								: register(t5, space2);
Texture2D<float4> ssrTexture							: register(t6, space2);


struct ps_input
{
	float2 uv				: TEXCOORDS;
	float3 worldPosition	: POSITION;

	float4 screenPosition	: SV_POSITION;
};

struct ps_output
{
	float4 hdrColor				: SV_Target0;
	float4 worldNormalRoughness	: SV_Target1;
};

struct triplanar_mapping
{
	float2 uvX, uvY, uvZ;
	float3 weights;


	void initialize(float3 position, float3 normal, float3 textureScale, float sharpness)
	{
		uvX = position.zy * textureScale.x;
		uvY = position.xz * textureScale.y;
		uvZ = position.xy * textureScale.z;

		weights = pow(abs(normal), sharpness);
		weights /= dot(weights, 1.f);
	}

	float3 normalmap(float3 normal, float3 tnormalX, float3 tnormalY, float3 tnormalZ)
	{
		// Whiteout blend: https://bgolus.medium.com/normal-mapping-for-a-triplanar-shader-10bf39dca05a

		tnormalX = float3(
			tnormalX.xy + normal.zy,
			abs(tnormalX.z) * normal.x
			);
		tnormalY = float3(
			tnormalY.xy + normal.xz,
			abs(tnormalY.z) * normal.y
			);
		tnormalZ = float3(
			tnormalZ.xy + normal.xy,
			abs(tnormalZ.z) * normal.z
			);

		return normalize(
			tnormalX.zyx * weights.x +
			tnormalY.xzy * weights.y +
			tnormalZ.xyz * weights.z
		);
	}
};

[earlydepthstencil]
[RootSignature(TERRAIN_RS)]
ps_output main(ps_input IN)
{
	float2 n = normals.Sample(clampSampler, IN.uv) * cb.amplitudeScale;
	float3 N = normalize(float3(n.x, 1.f, n.y));
	
	float groundTexScale = 0.1f;
	float rockTexScale = 0.1f;

	triplanar_mapping tri;
	tri.initialize(IN.worldPosition, N, float3(rockTexScale, groundTexScale, rockTexScale), 15.f);


	float2 groundUV = tri.uvY;

#if 0
	float2 tileUV = IN.uv + 0.1f * float2(fbm(IN.uv * 13.f, 2).x, fbm(IN.uv * 15.f, 3).x);
	float2 tileID = floor(tileUV * 20.f) / 20.f;
	float tileRotation = random(tileID) * M_PI * 2.f;

	float sinRotation, cosRotation;
	sincos(tileRotation, sinRotation, cosRotation);

	groundUV = float2(cosRotation * tri.uvY.x - sinRotation * tri.uvY.y, sinRotation * tri.uvY.x + cosRotation * tri.uvY.y);
#endif
	
	float4 albedo =
		rockAlbedoTexture.Sample(wrapSampler, tri.uvX) * tri.weights.x +
		groundAlbedoTexture.Sample(wrapSampler, groundUV) * tri.weights.y +
		rockAlbedoTexture.Sample(wrapSampler, tri.uvZ) * tri.weights.z;

	float roughness =
		rockRoughnessTexture.Sample(wrapSampler, tri.uvX) * tri.weights.x +
		groundRoughnessTexture.Sample(wrapSampler, groundUV) * tri.weights.y +
		rockRoughnessTexture.Sample(wrapSampler, tri.uvZ) * tri.weights.z;


	float3 tnormalX = sampleNormalMap(rockNormalTexture, wrapSampler, tri.uvX);
	float3 tnormalY = sampleNormalMap(groundNormalTexture, wrapSampler, groundUV);
	float3 tnormalZ = sampleNormalMap(rockNormalTexture, wrapSampler, tri.uvZ);

	N = tri.normalmap(N, tnormalX, tnormalY, tnormalZ);



	float mudMask = 0.f;
	for (uint w = 0; w < water.numWaterPlanes; ++w)
	{
		float4 minMax = water.waterMinMaxXZ[w];
		float height = water.waterHeights[w];
		float3 minCorner = float3(minMax.x, height, minMax.y);
		float3 maxCorner = float3(minMax.z, height, minMax.w);

		float dx = max(max(minCorner.x - IN.worldPosition.x, 0), IN.worldPosition.x - maxCorner.x);
		float dz = max(max(minCorner.z - IN.worldPosition.z, 0), IN.worldPosition.z - maxCorner.z);
		float dy = abs(height - IN.worldPosition.y);

		float3 d = float3(dx, dy, dz);

		float distance = length(d);

		float m = max(
			dx == 0.f && dz == 0.f && IN.worldPosition.y <= height,
			smoothstep(2.f, 0.f, distance));

		mudMask = max(mudMask, m);
	}

	[branch]
	if (mudMask > 0.f)
	{
		albedo = lerp(albedo, mudAlbedoTexture.Sample(wrapSampler, groundUV), mudMask);
		N = normalize(lerp(N, sampleNormalMap(mudNormalTexture, wrapSampler, groundUV), mudMask));
		roughness = lerp(roughness, mudRoughnessTexture.Sample(wrapSampler, groundUV), mudMask);
	}


	surface_info surface;

	surface.albedo = albedo;
	surface.N = N;
	surface.roughness = roughness;
	surface.roughness = clamp(surface.roughness, 0.01f, 0.99f);
	surface.metallic = 0.f;
	surface.emission = 0.f;

	surface.P = IN.worldPosition;
	float3 camToP = surface.P - camera.position.xyz;
	surface.V = -normalize(camToP);

	surface.inferRemainingProperties();


	float pixelDepth = dot(camera.forward.xyz, camToP);



	float2 screenUV = IN.screenPosition.xy * camera.invScreenDims;


	light_contribution totalLighting = { float3(0.f, 0.f, 0.f), float3(0.f, 0.f, 0.f) };

	totalLighting.addSunLight(surface, lighting, screenUV, pixelDepth,
		shadowMap, shadowSampler, lighting.shadowMapTexelSize, sssTexture, clampSampler);

	totalLighting.addImageBasedAmbientLighting(surface, irradianceTexture, prefilteredRadianceTexture, brdf, ssrTexture, aoTexture,
		clampSampler, screenUV, lighting.globalIlluminationIntensity);





	surface.roughness = 1.f; // This is a fake to disable SSR on terrain (I find it costs more than it's worth for the grassy terrain we have).


	ps_output OUT;
	OUT.hdrColor = totalLighting.evaluate(surface.albedo);
	OUT.worldNormalRoughness = float4(packNormal(N), surface.roughness, 0.f);
	return OUT;
}

```

`shaders/terrain/terrain_shadow_vs.hlsl`:

```hlsl
#include "depth_only_rs.hlsli"
#include "terrain_height.hlsli"


ConstantBuffer<shadow_transform_cb> transform	: register(b0);
ConstantBuffer<terrain_cb> terrain				: register(b1);

Texture2D<float> heightmap						: register(t0);

struct vs_input
{
	uint vertexID	: SV_VertexID;
};

struct vs_output
{
	float4 position			: SV_POSITION;
};

[RootSignature(TERRAIN_SHADOW_RS)]
vs_output main(vs_input IN)
{
	float3 position;
	float2 uv;
	terrainVertexPosition(terrain, IN.vertexID, heightmap, position, uv);

	vs_output OUT;
	OUT.position = mul(transform.mvp, float4(position, 1.f));
	return OUT;
}

```

`shaders/terrain/terrain_vs.hlsl`:

```hlsl
#include "terrain_rs.hlsli"
#include "terrain_height.hlsli"

ConstantBuffer<terrain_transform_cb> transform	: register(b0);
ConstantBuffer<terrain_cb> terrain				: register(b1);

Texture2D<float> heightmap						: register(t0);

struct vs_input
{
	uint vertexID	: SV_VertexID;
};

struct vs_output
{
	float2 uv				: TEXCOORDS;
	float3 worldPosition	: POSITION;
	float4 position			: SV_Position;
};

vs_output main(vs_input IN)
{
	float3 position;
	float2 uv;
	terrainVertexPosition(terrain, IN.vertexID, heightmap, position, uv);

	vs_output OUT;
	OUT.uv = uv;
	OUT.worldPosition = position;
	OUT.position = mul(transform.vp, float4(position, 1.f));
	return OUT;
}

```

`shaders/texture_preprocessing/equirectangular_to_cubemap_cs.hlsl`:

```hlsl
#define RS \
    "RootFlags(0), " \
    "RootConstants(b0, num32BitConstants = 4), " \
    "DescriptorTable( SRV(t0, numDescriptors = 1, flags = DESCRIPTORS_VOLATILE) )," \
    "DescriptorTable( UAV(u0, numDescriptors = 5, flags = DESCRIPTORS_VOLATILE) )," \
    "StaticSampler(s0," \
        "addressU = TEXTURE_ADDRESS_WRAP," \
        "addressV = TEXTURE_ADDRESS_WRAP," \
        "addressW = TEXTURE_ADDRESS_WRAP," \
        "filter = FILTER_MIN_MAG_MIP_LINEAR)"

#include "cs.hlsli"

#define BLOCK_SIZE 16

cbuffer cb : register(b0)
{
	uint cubemapSize;				// Size of the cubemap face in pixels at the current mipmap level.
	uint firstMip;					// The first mip level to generate.
	uint numMipLevelsToGenerate;	// The number of mips to generate.
	bool isSRGB;					// Must apply gamma correction to sRGB textures.
};

// Source texture as an equirectangular panoramic image.
// It is assumed that the src texture has a full mipmap chain.
Texture2D<float4> srcTexture : register(t0);

// Destination texture as a mip slice in the cubemap texture (texture array with 6 elements).
RWTexture2DArray<float4> outMip1 : register(u0);
RWTexture2DArray<float4> outMip2 : register(u1);
RWTexture2DArray<float4> outMip3 : register(u2);
RWTexture2DArray<float4> outMip4 : register(u3);
RWTexture2DArray<float4> outMip5 : register(u4);

// Linear repeat sampler.
SamplerState linearRepeatSampler : register(s0);


// 1 / PI
static const float invPI = 0.31830988618379067153776752674503f;
static const float inv2PI = 0.15915494309189533576888376337251f;
static const float2 invAtan = float2(inv2PI, invPI);

// Transform from dispatch ID to cubemap face direction
static const float3x3 rotateUV[6] = {
	// +X
	float3x3(0,  0,  1,
			 0, -1,  0,
			 -1,  0,  0),
    // -X
    float3x3(0,  0, -1,
    		 0, -1,  0,
    		 1,  0,  0),
    // +Y
    float3x3(1,  0,  0,
   			 0,  0,  1,
   			 0,  1,  0),
   	// -Y
   	float3x3(1,  0,  0,
   	         0,  0, -1,
   			 0, -1,  0),
    // +Z
    float3x3(1,  0,  0,
   	     	 0, -1,  0,
   			 0,  0,  1),
	// -Z
   	float3x3(-1,  0,  0,
   	 	     0,  -1,  0,
   			 0,   0, -1)
};

float3 sRGBToLinear(float3 x)
{
	return x < 0.04045f ? x / 12.92f : pow((x + 0.055f) / 1.055f, 2.4f);
}

float3 linearToSRGB(float3 x)
{
	return x < 0.0031308f ? 12.92f * x : 1.055f * pow(abs(x), 1.f / 2.4f) - 0.055f;
}

float4 packColor(float4 x)
{
	if (isSRGB)
	{
		return float4(linearToSRGB(x.rgb), x.a);
	}
	else
	{
		return x;
	}
}

[RootSignature(RS)]
[numthreads(BLOCK_SIZE, BLOCK_SIZE, 1)]
void main(cs_input IN)
{
	uint3 texCoord = IN.dispatchThreadID;
	if (texCoord.x >= cubemapSize || texCoord.y >= cubemapSize) return;

	// Map the UV coords of the cubemap face to a direction
	// [(0, 0), (1, 1)] => [(-0.5, -0.5), (0.5, 0.5)]
	float3 dir = float3(texCoord.xy / float(cubemapSize) - 0.5f, 0.5f);

	// Rotate to cubemap face.
	dir = normalize(mul(rotateUV[texCoord.z], dir));
	dir.z *= -1.f;


	// Convert the world space direction into U,V texture coordinates in the panoramic texture.
	// Source: http://gl.ict.usc.edu/Data/HighResProbes/
	float2 panoUV = float2(atan2(-dir.x, -dir.z), acos(dir.y)) * invAtan;

	outMip1[texCoord] = packColor(srcTexture.SampleLevel(linearRepeatSampler, panoUV, firstMip));

	// Only perform on threads that are a multiple of 2.
	if (numMipLevelsToGenerate > 1 && (IN.groupIndex & 0x11) == 0)
	{
		outMip2[uint3(texCoord.xy / 2, texCoord.z)] = packColor(srcTexture.SampleLevel(linearRepeatSampler, panoUV, firstMip + 1));
	}

	// Only perform on threads that are a multiple of 4.
	if (numMipLevelsToGenerate > 2 && (IN.groupIndex & 0x33) == 0)
	{
		outMip3[uint3(texCoord.xy / 4, texCoord.z)] = packColor(srcTexture.SampleLevel(linearRepeatSampler, panoUV, firstMip + 2));
	}

	// Only perform on threads that are a multiple of 8.
	if (numMipLevelsToGenerate > 3 && (IN.groupIndex & 0x77) == 0)
	{
		outMip4[uint3(texCoord.xy / 8, texCoord.z)] = packColor(srcTexture.SampleLevel(linearRepeatSampler, panoUV, firstMip + 3));
	}

	// Only perform on threads that are a multiple of 16.
	// This should only be thread 0 in this group.
	if (numMipLevelsToGenerate > 4 && (IN.groupIndex & 0xFF) == 0)
	{
		outMip5[uint3(texCoord.xy / 16, texCoord.z)] = packColor(srcTexture.SampleLevel(linearRepeatSampler, panoUV, firstMip + 4));
	}
}

```

`shaders/texture_preprocessing/generate_mips_cs.hlsl`:

```hlsl
// Adapted from Source: https://github.com/Microsoft/DirectX-Graphics-Samples/blob/master/MiniEngine/Core/Shaders/GenerateMipsCS.hlsli

#define RS \
    "RootFlags(0), " \
    "RootConstants(b0, num32BitConstants = 6), " \
    "DescriptorTable( SRV(t0, numDescriptors = 1, flags = DESCRIPTORS_VOLATILE) )," \
    "DescriptorTable( UAV(u0, numDescriptors = 4, flags = DESCRIPTORS_VOLATILE) )," \
    "StaticSampler(s0," \
        "addressU = TEXTURE_ADDRESS_CLAMP," \
        "addressV = TEXTURE_ADDRESS_CLAMP," \
        "addressW = TEXTURE_ADDRESS_CLAMP," \
        "filter = FILTER_MIN_MAG_MIP_LINEAR)"

#include "cs.hlsli"

#define BLOCK_SIZE 8 // In one dimension. 64 in total.

#define WIDTH_HEIGHT_EVEN		0 // Both the width and the height of the texture are even.
#define WIDTH_ODD_HEIGHT_EVEN	1 // The texture width is odd and the height is even.
#define WIDTH_EVEN_HEIGHT_ODD	2 // The texture width is even and the height is odd.
#define WIDTH_HEIGHT_ODD		3 // Both the width and height of the texture are odd.

cbuffer generate_mips_cb : register(b0)
{
	uint srcMipLevel;				// Texture level of source mip
	uint numMipLevelsToGenerate;	// The shader can generate up to 4 mips at once.
	uint srcDimensionFlags;			// Flags specifying whether width and height are even or odd (see above).
	bool isSRGB;					// Must apply gamma correction to sRGB textures.
	float2 texelSize;				// 1.0 / OutMip1.Dimensions
};

// Source mip map.
Texture2D<float4> srcMip		: register(t0);

// Write up to 4 mip map levels. These are successive levels after the source.
RWTexture2D<float4> outMip1		: register(u0);
RWTexture2D<float4> outMip2		: register(u1);
RWTexture2D<float4> outMip3		: register(u2);
RWTexture2D<float4> outMip4		: register(u3);

// Linear clamp sampler.
SamplerState linearClampSampler : register(s0);

// The reason for separating channels is to reduce bank conflicts in the
// local data memory controller.  A large stride will cause more threads
// to collide on the same memory bank.
groupshared float gs_R[BLOCK_SIZE * BLOCK_SIZE];
groupshared float gs_G[BLOCK_SIZE * BLOCK_SIZE];
groupshared float gs_B[BLOCK_SIZE * BLOCK_SIZE];
groupshared float gs_A[BLOCK_SIZE * BLOCK_SIZE];

void storeColorToSharedMemory(uint index, float4 color)
{
	gs_R[index] = color.r;
	gs_G[index] = color.g;
	gs_B[index] = color.b;
	gs_A[index] = color.a;
}

float4 loadColorFromSharedMemory(uint index)
{
	return float4(gs_R[index], gs_G[index], gs_B[index], gs_A[index]);
}

float3 sRGBToLinear(float3 x)
{
	return x < 0.04045f ? x / 12.92f : pow((x + 0.055f) / 1.055f, 2.4f);
}

float3 linearToSRGB(float3 x)
{
	return x < 0.0031308f ? 12.92f * x : 1.055f * pow(abs(x), 1.f / 2.4f) - 0.055f;
}

float4 packColor(float4 x)
{
	if (isSRGB)
	{
		return float4(linearToSRGB(x.rgb), x.a);
	}
	else
	{
		return x;
	}
}

[RootSignature(RS)]
[numthreads(BLOCK_SIZE, BLOCK_SIZE, 1)]
void main(cs_input IN)
{
	float4 src1 = (float4)0;

	switch (srcDimensionFlags)
	{
	case WIDTH_HEIGHT_EVEN:
	{
		float2 uv = texelSize * (IN.dispatchThreadID.xy + 0.5f);
		src1 = srcMip.SampleLevel(linearClampSampler, uv, srcMipLevel);
	} break;

	case WIDTH_ODD_HEIGHT_EVEN:
	{
		// > 2:1 in X dimension
		// Use 2 bilinear samples to guarantee we don't undersample when downsizing by more than 2x
		// horizontally.
		float2 uv1 = texelSize * (IN.dispatchThreadID.xy + float2(0.25f, 0.5f));
		float2 off = texelSize * float2(0.5f, 0.f);

		src1 = 0.5f * (srcMip.SampleLevel(linearClampSampler, uv1, srcMipLevel) +
			srcMip.SampleLevel(linearClampSampler, uv1 + off, srcMipLevel));
	} break;

	case WIDTH_EVEN_HEIGHT_ODD:
	{
		// > 2:1 in Y dimension
		// Use 2 bilinear samples to guarantee we don't undersample when downsizing by more than 2x
		// vertically.
		float2 uv1 = texelSize * (IN.dispatchThreadID.xy + float2(0.5f, 0.25f));
		float2 off = texelSize * float2(0.f, 0.5f);

		src1 = 0.5f * (srcMip.SampleLevel(linearClampSampler, uv1, srcMipLevel) +
			srcMip.SampleLevel(linearClampSampler, uv1 + off, srcMipLevel));
	} break;

	case WIDTH_HEIGHT_ODD:
	{
		// > 2:1 in in both dimensions
		// Use 4 bilinear samples to guarantee we don't undersample when downsizing by more than 2x
		// in both directions.
		float2 uv1 = texelSize * (IN.dispatchThreadID.xy + float2(0.25f, 0.25f));
		float2 off = texelSize * 0.5f;

		src1 = srcMip.SampleLevel(linearClampSampler, uv1, srcMipLevel);
		src1 += srcMip.SampleLevel(linearClampSampler, uv1 + float2(off.x, 0.0), srcMipLevel);
		src1 += srcMip.SampleLevel(linearClampSampler, uv1 + float2(0.0, off.y), srcMipLevel);
		src1 += srcMip.SampleLevel(linearClampSampler, uv1 + float2(off.x, off.y), srcMipLevel);
		src1 *= 0.25;
	} break;
	}

	outMip1[IN.dispatchThreadID.xy] = packColor(src1);

	if (numMipLevelsToGenerate == 1)
	{
		return;
	}

	storeColorToSharedMemory(IN.groupIndex, src1);

	GroupMemoryBarrierWithGroupSync();

	if ((IN.groupIndex & 0x9) == 0)
	{
		float4 src2 = loadColorFromSharedMemory(IN.groupIndex + 0x01);
		float4 src3 = loadColorFromSharedMemory(IN.groupIndex + 0x08);
		float4 src4 = loadColorFromSharedMemory(IN.groupIndex + 0x09);
		src1 = 0.25f * (src1 + src2 + src3 + src4);

		outMip2[IN.dispatchThreadID.xy / 2] = packColor(src1);
		storeColorToSharedMemory(IN.groupIndex, src1);
	}

	if (numMipLevelsToGenerate == 2)
	{
		return;
	}

	GroupMemoryBarrierWithGroupSync();

	if ((IN.groupIndex & 0x1B) == 0)
	{
		float4 src2 = loadColorFromSharedMemory(IN.groupIndex + 0x02);
		float4 src3 = loadColorFromSharedMemory(IN.groupIndex + 0x10);
		float4 src4 = loadColorFromSharedMemory(IN.groupIndex + 0x12);
		src1 = 0.25f * (src1 + src2 + src3 + src4);

		outMip3[IN.dispatchThreadID.xy / 4] = packColor(src1);
		storeColorToSharedMemory(IN.groupIndex, src1);
	}

	if (numMipLevelsToGenerate == 3)
	{
		return;
	}

	GroupMemoryBarrierWithGroupSync();

	if (IN.groupIndex == 0)
	{
		float4 src2 = loadColorFromSharedMemory(IN.groupIndex + 0x04);
		float4 src3 = loadColorFromSharedMemory(IN.groupIndex + 0x20);
		float4 src4 = loadColorFromSharedMemory(IN.groupIndex + 0x24);
		src1 = 0.25f * (src1 + src2 + src3 + src4);

		outMip4[IN.dispatchThreadID.xy / 8] = packColor(src1);
	}
}



```

`shaders/texture_preprocessing/integrate_brdf_cs.hlsl`:

```hlsl
#define RS \
    "RootFlags(0), " \
    "RootConstants(b0, num32BitConstants = 1), " \
    "DescriptorTable( UAV(u0, numDescriptors = 1, flags = DESCRIPTORS_VOLATILE) )"

#include "cs.hlsli"
#include "brdf.hlsli"
#include "random.hlsli"

#define BLOCK_SIZE 16

cbuffer cb : register(b0)
{
	uint textureDim;
};

RWTexture2D<float2> outBRDF : register(u0);

[RootSignature(RS)]
[numthreads(BLOCK_SIZE, BLOCK_SIZE, 1)]
void main(cs_input IN)
{
	if (IN.dispatchThreadID.x >= textureDim || IN.dispatchThreadID.y >= textureDim)
	{
		return;
	}

	float NdotV = float(IN.dispatchThreadID.x) / (textureDim - 1);
	float roughness = float(IN.dispatchThreadID.y) / (textureDim - 1);


	float3 V;
	V.x = sqrt(1.f - NdotV * NdotV);
	V.y = 0.f;
	V.z = NdotV;

	float A = 0.f;
	float B = 0.f;

	float3 N = float3(0.f, 0.f, 1.f);

	const uint SAMPLE_COUNT = 1024u;
	for (uint i = 0u; i < SAMPLE_COUNT; ++i)
	{
		float2 Xi = hammersley(i, SAMPLE_COUNT);
		float3 H = importanceSampleGGX(Xi, N, roughness).xyz;
		float3 L = normalize(2.f * dot(V, H) * H - V);

		float NdotL = max(L.z, 0.f);
		float NdotH = max(H.z, 0.f);
		float VdotH = max(dot(V, H), 0.f);

		if (NdotL > 0.f)
		{
			float G = geometrySmith(NdotL, NdotV, roughness);
			float G_Vis = (G * VdotH) / (NdotH * NdotV);
			float Fc = pow(1.f - VdotH, 5.f);

			A += (1.f - Fc) * G_Vis;
			B += Fc * G_Vis;
		}
	}
	A /= float(SAMPLE_COUNT);
	B /= float(SAMPLE_COUNT);

	float2 integratedBRDF = float2(A, B);
	outBRDF[IN.dispatchThreadID.xy] = integratedBRDF;
}
```

`shaders/texture_preprocessing/procedural_sky_to_irradiance_cs.hlsl`:

```hlsl
#define RS \
    "RootFlags(0), " \
    "RootConstants(b0, num32BitConstants = 4), " \
    "DescriptorTable( UAV(u0, numDescriptors = 1, flags = DESCRIPTORS_VOLATILE) )"

#include "cs.hlsli"
#include "procedural_sky.hlsli"

#define BLOCK_SIZE 16

cbuffer cb : register(b0)
{
	float3 L;
	uint irradianceMapSize;
};

RWTexture2DArray<float4> outIrradiance : register(u0);

static const float pi = 3.141592653589793238462643383279f;

// Transform from dispatch ID to cubemap face direction
static const float3x3 rotateUV[6] = {
	// +X
	float3x3(0,  0,  1,
			 0, -1,  0,
			 -1,  0,  0),
	// -X
    float3x3(0,  0, -1,
    		 0, -1,  0,
    		 1,  0,  0),
	// +Y
	float3x3(1,  0,  0,
	         0,  0,  1,
			 0,  1,  0),
	// -Y
	float3x3(1,  0,  0,
	    	 0,  0, -1,
			 0, -1,  0),
	// +Z
	float3x3(1,  0,  0,
			 0, -1,  0,
			 0,  0,  1),
	// -Z
	float3x3(-1,  0,  0,
		     0,  -1,  0,
			 0,   0, -1)
};


#define NUM_SAMPLES 1024

groupshared float3 radianceSamples[NUM_SAMPLES];
groupshared float3 directions[NUM_SAMPLES];

[RootSignature(RS)]
[numthreads(BLOCK_SIZE, BLOCK_SIZE, 1)]
void main(cs_input IN)
{
	for (uint i = IN.groupIndex; i < NUM_SAMPLES; i += BLOCK_SIZE * BLOCK_SIZE)
	{
		float3 V = sphericalFibonacci(i, NUM_SAMPLES);
		radianceSamples[i] = proceduralSkySimple(V, L);
		directions[i] = V;
	}

	GroupMemoryBarrierWithGroupSync();


	uint3 texCoord = IN.dispatchThreadID;
	if (texCoord.x >= irradianceMapSize || texCoord.y >= irradianceMapSize) return;


	float3 V = float3(texCoord.xy / float(irradianceMapSize) - 0.5f, 0.5f);
	V = normalize(mul(rotateUV[texCoord.z], V));

	float3 result = 0.f;
	float totalWeight = 0.f;

	for (uint j = 0; j < NUM_SAMPLES; ++j)
	{
		float3 rad = radianceSamples[j];
		float3 L = directions[j];

		float weight = max(0.f, dot(V, L));
		result += rad * weight;
		totalWeight += weight;
	}

	result *= 1.f / max(totalWeight, 1e-4f);

	outIrradiance[texCoord] = float4(result, 1.f);
}

```

`shaders/texture_preprocessing/textured_sky_to_irradiance_cs.hlsl`:

```hlsl
#define RS \
    "RootFlags(0), " \
    "RootConstants(b0, num32BitConstants = 1), " \
    "DescriptorTable( SRV(t0, numDescriptors = 1, flags = DESCRIPTORS_VOLATILE), UAV(u0, numDescriptors = 1, flags = DESCRIPTORS_VOLATILE) )," \
    "StaticSampler(s0," \
        "addressU = TEXTURE_ADDRESS_WRAP," \
        "addressV = TEXTURE_ADDRESS_WRAP," \
        "addressW = TEXTURE_ADDRESS_WRAP," \
        "filter = FILTER_MIN_MAG_MIP_LINEAR)"

#include "cs.hlsli"

#define BLOCK_SIZE 16

cbuffer cb : register(b0)
{
	uint irradianceMapSize;
};

TextureCube<float4> srcTexture : register(t0);

RWTexture2DArray<float4> outIrradiance : register(u0);

SamplerState linearRepeatSampler : register(s0);

static const float pi = 3.141592653589793238462643383279f;

// Transform from dispatch ID to cubemap face direction
static const float3x3 rotateUV[6] = {
	// +X
	float3x3(0,  0,  1,
			 0, -1,  0,
			 -1,  0,  0),
	// -X
    float3x3(0,  0, -1,
    		 0, -1,  0,
    		 1,  0,  0),
	// +Y
	float3x3(1,  0,  0,
	         0,  0,  1,
			 0,  1,  0),
	// -Y
	float3x3(1,  0,  0,
	    	 0,  0, -1,
			 0, -1,  0),
	// +Z
	float3x3(1,  0,  0,
			 0, -1,  0,
			 0,  0,  1),
	// -Z
	float3x3(-1,  0,  0,
		     0,  -1,  0,
			 0,   0, -1)
};


[RootSignature(RS)]
[numthreads(BLOCK_SIZE, BLOCK_SIZE, 1)]
void main(cs_input IN)
{
	uint3 texCoord = IN.dispatchThreadID;
	if (texCoord.x >= irradianceMapSize || texCoord.y >= irradianceMapSize) return;

	// Map the UV coords of the cubemap face to a direction.
	// [(0, 0), (1, 1)] => [(-0.5, -0.5), (0.5, 0.5)]
	float3 dir = float3(texCoord.xy / float(irradianceMapSize) - 0.5f, 0.5f);
	dir = normalize(mul(rotateUV[texCoord.z], dir));

	float3 up = float3(0.f, 1.f, 0.f);
	float3 right = cross(up, dir);
	up = cross(dir, right);

	float3 irradiance = float3(0.f, 0.f, 0.f);


	uint srcWidth, srcHeight, numMipLevels;
	srcTexture.GetDimensions(0, srcWidth, srcHeight, numMipLevels);

	float sampleMipLevel = log2((float)srcWidth / (float)irradianceMapSize);

	const float sampleDelta = 0.025f;
	float nrSamples = 0.f;
	for (float phi = 0.f; phi < 2.f * pi; phi += sampleDelta)
	{
		for (float theta = 0.f; theta < 0.5f * pi; theta += sampleDelta)
		{
			float sinTheta, cosTheta;
			float sinPhi, cosPhi;
			sincos(theta, sinTheta, cosTheta);
			sincos(phi, sinPhi, cosPhi);

			// Spherical to cartesian (in tangent space).
			float3 tangentSample = float3(sinTheta * cosPhi, sinTheta * sinPhi, cosTheta);
			// Tangent space to world.
			float3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * dir;

			float4 color = srcTexture.SampleLevel(linearRepeatSampler, sampleVec, sampleMipLevel);
			irradiance += color.xyz * cosTheta * sinTheta;
			nrSamples++;
		}
	}

	irradiance = pi * irradiance * (1.f / float(nrSamples));

	outIrradiance[texCoord] = float4(irradiance, 1.f);
}
```

`shaders/texture_preprocessing/textured_sky_to_irradiance_sh_cs.hlsl`:

```hlsl
#define RS \
    "RootFlags(0), " \
    "RootConstants(b0, num32BitConstants = 1), " \
    "DescriptorTable( SRV(t0, numDescriptors = 1, flags = DESCRIPTORS_VOLATILE) )," \
    "UAV(u0)," \
    "StaticSampler(s0," \
        "addressU = TEXTURE_ADDRESS_WRAP," \
        "addressV = TEXTURE_ADDRESS_WRAP," \
        "addressW = TEXTURE_ADDRESS_WRAP," \
        "filter = FILTER_MIN_MAG_MIP_LINEAR)"

#include "cs.hlsli"
#include "brdf.hlsli"
#include "light_source.hlsli"

cbuffer cb : register(b0)
{
	uint mipLevel;
};

TextureCube<float4> srcTexture : register(t0);
SamplerState linearRepeatSampler : register(s0);

RWStructuredBuffer<spherical_harmonics> outSphericalHarmonics : register(u0);

#define BLOCK_SIZE 16


struct spherical_harmonics_vector
{
	float v[9];

	inline void initialize(float color, spherical_harmonics_basis basis)
	{
		[unroll]
		for (uint i = 0; i < 9; ++i)
		{
			v[i] = color * basis.v[i];
		}
	}

	inline void add(spherical_harmonics_vector other)
	{
		[unroll]
		for (uint i = 0; i < 9; ++i)
		{
			v[i] += other.v[i];
		}
	}
};

struct spherical_harmonics_rgb
{
	spherical_harmonics_vector r;
	spherical_harmonics_vector g;
	spherical_harmonics_vector b;

	inline void initialize(float3 dir, float3 color)
	{
		spherical_harmonics_basis basis = getSHBasis(dir);
		r.initialize(color.r, basis);
		g.initialize(color.g, basis);
		b.initialize(color.b, basis);
	}

	inline void add(spherical_harmonics_rgb other)
	{
		r.add(other.r);
		g.add(other.g);
		b.add(other.b);
	}
};

groupshared spherical_harmonics_rgb g_sh[BLOCK_SIZE * BLOCK_SIZE];


[RootSignature(RS)]
[numthreads(BLOCK_SIZE, BLOCK_SIZE, 1)]
void main(cs_input IN)
{
	const uint sampleCount = BLOCK_SIZE * BLOCK_SIZE;

	const float uniformSampleSolidAngle = 4.f * M_PI / sampleCount;
	float3 dir = uniformSampleSphere((float2(IN.dispatchThreadID.xy) + 0.5f) / float2(BLOCK_SIZE, BLOCK_SIZE)).xyz;

	const uint linearIndex = BLOCK_SIZE * IN.dispatchThreadID.y + IN.dispatchThreadID.x;


	float3 radiance = srcTexture.SampleLevel(linearRepeatSampler, dir, mipLevel).rgb;
	float3 weightedRadiance = radiance * uniformSampleSolidAngle;

	g_sh[linearIndex].initialize(dir, weightedRadiance);
	GroupMemoryBarrierWithGroupSync();

	if (sampleCount >= 256)
	{
		if (linearIndex < 128) { g_sh[linearIndex].add(g_sh[linearIndex + 128]); }
		GroupMemoryBarrierWithGroupSync();

		if (linearIndex < 64) { g_sh[linearIndex].add(g_sh[linearIndex + 64]); }
		GroupMemoryBarrierWithGroupSync();
	}

	if (linearIndex < 32) {	g_sh[linearIndex].add(g_sh[linearIndex + 32]); }
	GroupMemoryBarrierWithGroupSync();

	if (linearIndex < 16) {	g_sh[linearIndex].add(g_sh[linearIndex + 16]); }
	GroupMemoryBarrierWithGroupSync();

	// From here on we don't need to synchronize, because this is the minimum warp size commonly present.
	if (linearIndex < 8) { g_sh[linearIndex].add(g_sh[linearIndex + 8]); }
	if (linearIndex < 4) { g_sh[linearIndex].add(g_sh[linearIndex + 4]); }
	if (linearIndex < 2) { g_sh[linearIndex].add(g_sh[linearIndex + 2]); }
	
	if (linearIndex < 1)
	{
		g_sh[linearIndex].add(g_sh[linearIndex + 1]);

		outSphericalHarmonics[0].initialize(g_sh[0].r.v, g_sh[0].g.v, g_sh[0].b.v);
	}
}



```

`shaders/texture_preprocessing/textured_sky_to_prefiltered_radiance_cs.hlsl`:

```hlsl
#define RS \
    "RootFlags(0), " \
    "RootConstants(b0, num32BitConstants = 4), " \
    "DescriptorTable( SRV(t0, numDescriptors = 1, flags = DESCRIPTORS_VOLATILE), UAV(u0, numDescriptors = 5, flags = DESCRIPTORS_VOLATILE) )," \
    "StaticSampler(s0," \
        "addressU = TEXTURE_ADDRESS_WRAP," \
        "addressV = TEXTURE_ADDRESS_WRAP," \
        "addressW = TEXTURE_ADDRESS_WRAP," \
        "filter = FILTER_MIN_MAG_MIP_LINEAR)"

#define BLOCK_SIZE 16

#include "brdf.hlsli"
#include "cs.hlsli"
#include "random.hlsli"


cbuffer cb : register(b0)
{
	uint cubemapSize;				// Size of the cubemap face in pixels at the current mipmap level.
	uint firstMip;					// The first mip level to generate.
	uint numMipLevelsToGenerate;	// The number of mips to generate.
	uint totalNumMipLevels;
};

TextureCube<float4> srcTexture : register(t0);

RWTexture2DArray<float4> outMip1 : register(u0);
RWTexture2DArray<float4> outMip2 : register(u1);
RWTexture2DArray<float4> outMip3 : register(u2);
RWTexture2DArray<float4> outMip4 : register(u3);
RWTexture2DArray<float4> outMip5 : register(u4);

SamplerState linearRepeatSampler : register(s0);


// Transform from dispatch ID to cubemap face direction
static const float3x3 rotateUV[6] = {
	// +X
	float3x3(0,  0,  1,
			 0, -1,  0,
			 -1,  0,  0),
	// -X
    float3x3(0,  0, -1,
    		 0, -1,  0,
    		 1,  0,  0),
	// +Y
	float3x3(1,  0,  0,
	         0,  0,  1,
			 0,  1,  0),
	// -Y
	float3x3(1,  0,  0,
	    	 0,  0, -1,
			 0, -1,  0),
	// +Z
	float3x3(1,  0,  0,
			 0, -1,  0,
			 0,  0,  1),
	// -Z
	float3x3(-1,  0,  0,
		     0,  -1,  0,
			 0,   0, -1)
};


static float4 filter(uint mip, float3 N, float3 V)
{
	float roughness = float(mip) / (totalNumMipLevels - 1);

	const uint SAMPLE_COUNT = 1024u;
	float totalWeight = 0.f;
	float3 prefilteredColor = float3(0.f, 0.f, 0.f);


	uint width, height, numMipLevels;
	srcTexture.GetDimensions(0, width, height, numMipLevels);

	for (uint i = 0; i < SAMPLE_COUNT; ++i)
	{
		float2 Xi = hammersley(i, SAMPLE_COUNT);
		float3 H = importanceSampleGGX(Xi, N, roughness).xyz;
		float3 L = normalize(2.f * dot(V, H) * H - V);

		float NdotL = max(dot(N, L), 0.f);
		float NdotH = max(dot(N, H), 0.f);
		float HdotV = max(dot(H, V), 0.f);
		if (NdotL > 0.f)
		{
			float D = distributionGGX(NdotH, roughness);
			float pdf = (D * NdotH / (4.f * HdotV)) + 0.0001f;

			uint resolution = width; // We expect quadratic faces, so width == height.
			float saTexel = 4.f * M_PI / (6.f * width * height);
			float saSample = 1.f / (SAMPLE_COUNT * pdf + 0.00001f);

			float sampleMipLevel = (roughness == 0.f) ? 0.f : 0.5f * log2(saSample / saTexel);

			prefilteredColor += srcTexture.SampleLevel(linearRepeatSampler, L, sampleMipLevel).xyz * NdotL;
			totalWeight += NdotL;
		}
	}
	prefilteredColor = prefilteredColor / totalWeight;
	return float4(prefilteredColor, 1.f);
}

[RootSignature(RS)]
[numthreads(BLOCK_SIZE, BLOCK_SIZE, 1)]
void main(cs_input IN)
{
	uint3 texCoord = IN.dispatchThreadID;
	if (texCoord.x >= cubemapSize || texCoord.y >= cubemapSize) return;

	// Map the UV coords of the cubemap face to a direction
	// [(0, 0), (1, 1)] => [(-0.5, -0.5), (0.5, 0.5)]
	float3 N = float3(texCoord.xy / float(cubemapSize) - 0.5f, 0.5f);
	N = normalize(mul(rotateUV[texCoord.z], N));

	float3 R = N;
	float3 V = R;

	outMip1[texCoord] = filter(firstMip, N, V);

	if (numMipLevelsToGenerate > 1 && (IN.groupIndex & 0x11) == 0)
	{
		outMip2[uint3(texCoord.xy / 2, texCoord.z)] = filter(firstMip + 1, N, V);
	}

	if (numMipLevelsToGenerate > 2 && (IN.groupIndex & 0x33) == 0)
	{
		outMip3[uint3(texCoord.xy / 4, texCoord.z)] = filter(firstMip + 2, N, V);
	}

	if (numMipLevelsToGenerate > 3 && (IN.groupIndex & 0x77) == 0)
	{
		outMip4[uint3(texCoord.xy / 8, texCoord.z)] = filter(firstMip + 3, N, V);
	}

	if (numMipLevelsToGenerate > 4 && (IN.groupIndex & 0xFF) == 0)
	{
		outMip5[uint3(texCoord.xy / 16, texCoord.z)] = filter(firstMip + 4, N, V);
	}
}

```

`shaders/tree/tree_ps.hlsl`:

```hlsl
#include "tree_rs.hlsli"

#define RS TREE_RS
#define ALPHA_CUTOUT // TODO: Remove this when we have a depth prepass for trees.

#include "../geometry/default_pbr_ps.hlsl"

```

`shaders/tree/tree_vs.hlsl`:

```hlsl
#include "tree_rs.hlsli"
#include "random.hlsli"
#include "camera.hlsli"

StructuredBuffer<float4x4> transforms	: register(t0);
ConstantBuffer<tree_cb> cb				: register(b1);
ConstantBuffer<camera_cb> camera		: register(b1, space1);

struct vs_input
{
	float3 position		: POSITION;
	float2 uv			: TEXCOORDS;
	float3 normal		: NORMAL;
	float3 tangent		: TANGENT;
	float4 color		: COLOR;

	uint instanceID		: SV_InstanceID;
};

struct vs_output
{
	float2 uv				: TEXCOORDS;
	float3x3 tbn			: TANGENT_FRAME;
	float3 worldPosition	: POSITION;

	float4 position			: SV_POSITION;
};

vs_output main(vs_input IN)
{
	const float2 windDirection = normalize(float2(1.f, 1.f));
	const float3 treeDistances = IN.color.rgb;

	const float movementScale = 15.f;
	const float bend = pow(2, 1.f / 4.f);

	float4x4 m = transforms[IN.instanceID];
	float4 worldPosition = mul(m, float4(IN.position, 1.f));

	float trunkSwing = fbm(cb.time * 0.1f, 2).x * 0.4f + 0.6f;
	float2 trunkMovement = windDirection * (movementScale * trunkSwing * pow(treeDistances.x, bend));

	float branchSwing = fbm(worldPosition.xz * 0.03f + cb.time * 0.3f, 3).x * 0.3f + 0.1f;
	float2 branchMovement = windDirection * (movementScale * branchSwing * pow(treeDistances.y, bend));

	float leafSwing = fbm(worldPosition.xz + cb.time * 3.f, 3).x * 0.3f + 0.1f;
	float2 leafMovement = windDirection * (movementScale * leafSwing * pow(treeDistances.z, 1.f));



	worldPosition.xz += trunkMovement + branchMovement + leafMovement;



	vs_output OUT;
	OUT.position = mul(camera.viewProj, worldPosition);

	OUT.uv = IN.uv;
	OUT.worldPosition = worldPosition.xyz;

	float3 normal = normalize(mul(m, float4(IN.normal, 0.f)).xyz);
	float3 tangent = normalize(mul(m, float4(IN.tangent, 0.f)).xyz);
	float3 bitangent = normalize(cross(normal, tangent));
	OUT.tbn = float3x3(tangent, bitangent, normal);

	return OUT;
}

```

`shaders/visualization/flat_simple_ps.hlsl`:

```hlsl
#include "visualization_rs.hlsli"
#include "camera.hlsli"

ConstantBuffer<visualization_cb> cb	: register(b1);
ConstantBuffer<camera_cb> camera	: register(b2);

struct ps_input
{
	float3 worldPosition	: WORLD_POSITION;
	float3 worldNormal		: WORLD_NORMAL;
};

[RootSignature(FLAT_SIMPLE_RS)]
float4 main(ps_input IN) : SV_TARGET
{
	float ndotv = saturate(dot(normalize(camera.position.xyz - IN.worldPosition), normalize(IN.worldNormal))) * 0.8 + 0.2;
	return ndotv * cb.color;
}

```

`shaders/visualization/flat_simple_vs.hlsl`:

```hlsl
#include "transform.hlsli"

ConstantBuffer<transform_cb> transform : register(b0);

struct vs_input
{
	float3 position			: POSITION;
	float3 normal			: NORMAL;
};

struct vs_output
{
	float3 worldPosition	: WORLD_POSITION;
	float3 worldNormal		: WORLD_NORMAL;
	float4 position			: SV_POSITION;
};

vs_output main(vs_input IN)
{
	vs_output OUT;
	OUT.position = mul(transform.mvp, float4(IN.position, 1.f));
	OUT.worldPosition = mul(transform.m, float4(IN.position, 1.f)).xyz;
	OUT.worldNormal = mul(transform.m, float4(IN.normal, 0.f)).xyz;
	return OUT;
}

```

`shaders/visualization/flat_unlit_position_color_vs.hlsl`:

```hlsl

struct transform_cb
{
	float4x4 mvp;
};

ConstantBuffer<transform_cb> transform : register(b0);

struct vs_input
{
	float3 position		: POSITION;
	float3 color		: COLOR;
};

struct vs_output
{
	float3 color		: COLOR;
	float4 position		: SV_POSITION;
};

vs_output main(vs_input IN)
{
	vs_output OUT;
	OUT.position = mul(transform.mvp, float4(IN.position, 1.f));
	OUT.color = IN.color;
	return OUT;
}

```

`shaders/visualization/flat_unlit_position_vs.hlsl`:

```hlsl

struct transform_cb
{
	float4x4 mvp;
};

ConstantBuffer<transform_cb> transform : register(b0);

struct vs_input
{
	float3 position		: POSITION;
};

struct vs_output
{
	float3 color		: COLOR;
	float4 position		: SV_POSITION;
};

vs_output main(vs_input IN)
{
	vs_output OUT;
	OUT.position = mul(transform.mvp, float4(IN.position, 1.f));
	OUT.color = float3(1.f, 1.f, 1.f);
	return OUT;
}

```

`shaders/visualization/flat_unlit_ps.hlsl`:

```hlsl
#include "visualization_rs.hlsli"

ConstantBuffer<visualization_cb> cb		: register(b1);



struct ps_input
{
	float3 color		: COLOR;
};

[RootSignature(FLAT_UNLIT_RS)]
float4 main(ps_input IN) : SV_TARGET
{
	return cb.color * float4(IN.color, 1.f);
}

```

`shaders/visualization/sun_shadow_cascades_cs.hlsl`:

```hlsl
#include "cs.hlsli"
#include "visualization_rs.hlsli"
#include "light_source.hlsli"
#include "camera.hlsli"
#include "random.hlsli"

ConstantBuffer<visualize_sun_shadow_cascades_cb> cb		: register(b0);
ConstantBuffer<directional_light_cb> sun				: register(b1);

RWTexture2D<float4> outputTexture						: register(u0);
Texture2D<float> depthBuffer							: register(t0);


static const float3 cascadeColors[4] =
{
	float3(1.f, 0.f, 0.f),
	float3(0.f, 1.f, 0.f),
	float3(0.f, 0.f, 1.f),
	float3(1.f, 1.f, 0.f)
};

[numthreads(16, 16, 1)]
[RootSignature(VISUALIZE_SUN_SHADOW_CASCADES_RS)]
void main(cs_input IN)
{
	float depth = depthBuffer[IN.dispatchThreadID.xy];
	if (depth == 1.f)
	{
		outputTexture[IN.dispatchThreadID.xy] = float4(0.f, 0.f, 0.f, 0.f);
		return;
	}

	uint2 dims;
	uint numMips;
	depthBuffer.GetDimensions(0, dims.x, dims.y, numMips);

	float2 invDims = rcp((float2)dims);
	float2 uv = (IN.dispatchThreadID.xy + 0.5f) * invDims;

	float3 worldPosition = restoreWorldSpacePosition(cb.invViewProj, uv, depth);

#if 1
	float worldDepth = dot(worldPosition - cb.cameraPosition.xyz, cb.cameraForward.xyz);

	float4 comparison = worldDepth.xxxx > sun.cascadeDistances;

	int currentCascadeIndex = dot(float4(sun.numShadowCascades > 0, sun.numShadowCascades > 1, sun.numShadowCascades > 2, sun.numShadowCascades > 3), comparison);
	currentCascadeIndex = min(currentCascadeIndex, sun.numShadowCascades - 1);

	outputTexture[IN.dispatchThreadID.xy] = float4(cascadeColors[currentCascadeIndex], 1.f);

#else

	float4 color = float4(0.f, 0.f, 0.f, 1.f);

	for (uint i = 0; i < sun.numShadowCascades; ++i)
	{
		float4x4 vp = sun.viewProjs[i];

		float4 lightProjected = mul(vp, float4(worldPosition, 1.f));
		lightProjected.xyz /= lightProjected.w;

		lightProjected.xy = lightProjected.xy * 0.5f + float2(0.5f, 0.5f);
		lightProjected.y = 1.f - lightProjected.y;

		if (all(lightProjected.xyz > 0.f && lightProjected.xyz < 1.f))
		{
			float size = 2048;
			float2 pixel = floor(lightProjected.xy * size) / size;

			color.rgb = cascadeColors[i];
			//color.rgb = random(pixel);
			break;
		}
	}

	outputTexture[IN.dispatchThreadID.xy] = color;

#endif
}

```

`shaders/water/water_ps.hlsl`:

```hlsl
#include "water_rs.hlsli"
#include "camera.hlsli"
#include "normal.hlsli"
#include "lighting.hlsli"


SamplerState clampSampler								: register(s0);
SamplerState wrapSampler								: register(s1);
SamplerComparisonState shadowSampler					: register(s2);

ConstantBuffer<water_cb> cb								: register(b0, space1);
ConstantBuffer<camera_cb> camera						: register(b1, space1);
ConstantBuffer<lighting_cb> lighting					: register(b2, space1);

Texture2D<float3> opaqueColor							: register(t0);
Texture2D<float> opaqueDepth							: register(t1);
Texture2D<float3> normalmap1							: register(t2);
Texture2D<float3> normalmap2							: register(t3);
Texture2D<float3> foamTexture							: register(t4);
Texture2D<float> noiseTexture							: register(t5);

TextureCube<float4> irradianceTexture					: register(t0, space2);
TextureCube<float4> prefilteredRadianceTexture			: register(t1, space2);

Texture2D<float2> brdf									: register(t2, space2);

Texture2D<float> shadowMap								: register(t3, space2);

Texture2D<float> aoTexture								: register(t4, space2);
Texture2D<float> sssTexture								: register(t5, space2);
Texture2D<float4> ssrTexture							: register(t6, space2);



struct ps_input
{
	float3 worldPosition	: POSITION;

    float4 screenPosition	: SV_POSITION;
};


[earlydepthstencil]
[RootSignature(WATER_RS)]
float4 main(ps_input IN) : SV_TARGET
{
	float2 uv = IN.worldPosition.xz * 0.1f * cb.uvScale;
	float2 uv0 = uv - cb.uvOffset;
	float2 uv1 = (uv + cb.uvOffset) * 0.7f;

	float3 N0 = scaleNormalMap(sampleNormalMap(normalmap2, wrapSampler, uv0), cb.normalmapStrength);
	float3 N1 = scaleNormalMap(sampleNormalMap(normalmap1, wrapSampler, uv1), cb.normalmapStrength * 0.6f);

	float3 N = combineNormalMaps(N0, N1).xzy;


	const float refractionDistortionFactor = 0.015f;

	float2 screenUV = IN.screenPosition.xy * camera.invScreenDims;
	float2 distortedScreenUV = (screenUV + ((N.xz + N.xy) * 0.5f) * refractionDistortionFactor);


	float sceneDepth = camera.depthBufferDepthToEyeDepth(opaqueDepth.Sample(clampSampler, distortedScreenUV));
	float thisDepth = camera.depthBufferDepthToEyeDepth(IN.screenPosition.z);
	if (sceneDepth < thisDepth)
	{
		distortedScreenUV = screenUV;
		sceneDepth = camera.depthBufferDepthToEyeDepth(opaqueDepth.Sample(clampSampler, distortedScreenUV));
	}

	float3 sceneColor = opaqueColor.Sample(clampSampler, distortedScreenUV);

	float transition = saturate((sceneDepth - (thisDepth + cb.shallowDepth)) * cb.transitionStrength);


	// Inspired by https://alextardif.com/Water.html
	const float noiseUVScale = 0.7f;
	float specularNoise = 1.f + 
		3.f * noiseTexture.Sample(wrapSampler, uv0 * noiseUVScale) * 
		noiseTexture.Sample(wrapSampler, uv1 * noiseUVScale) *
		noiseTexture.Sample(wrapSampler, uv * noiseUVScale);



	surface_info surface;

	surface.albedo = lerp(cb.shallowColor, cb.deepColor, transition);
	surface.N = N;
	surface.roughness = 0.2f;
	surface.roughness = clamp(surface.roughness, 0.01f, 0.99f);
	surface.metallic = 0.f;
	surface.emission = 0.f;

	surface.P = IN.worldPosition;
	float3 camToP = surface.P - camera.position.xyz;
	surface.V = -normalize(camToP);

	surface.inferRemainingProperties();



	float pixelDepth = dot(camera.forward.xyz, camToP);





	light_contribution totalLighting = { float3(0.f, 0.f, 0.f), float3(0.f, 0.f, 0.f) };

	totalLighting.addSunLight(surface, lighting, screenUV, pixelDepth,
		shadowMap, shadowSampler, lighting.shadowMapTexelSize, sssTexture, clampSampler);


	// Ambient light.
	float ao = aoTexture.SampleLevel(clampSampler, screenUV, 0);

	ambient_factors factors = getAmbientFactors(surface);
	totalLighting.diffuse += diffuseIBL(factors.kd, surface, irradianceTexture, clampSampler) * lighting.globalIlluminationIntensity * ao;
	float3 specular = specularIBL(factors.ks, surface, prefilteredRadianceTexture, brdf, clampSampler, specularNoise);
	totalLighting.specular += specular * lighting.globalIlluminationIntensity * ao;


	float3 color = lerp(sceneColor, totalLighting.diffuse * surface.albedo.xyz, surface.albedo.a) + totalLighting.specular; // albedo

	return float4(color, 1.f);
}

```

`shaders/water/water_vs.hlsl`:

```hlsl
#include "water_rs.hlsli"

ConstantBuffer<transform_cb> cb	: register(b0);


struct vs_output
{
	float3 worldPosition	: POSITION;

	float4 position	: SV_POSITION;
};

vs_output main(uint vertexID : SV_VertexID)
{
	float3 pos = float3(vertexID & 1, 0.5f, vertexID >> 1) * 2.f - 1.f;

	vs_output OUT;
	OUT.worldPosition = mul(cb.m, float4(pos, 1.f));
	OUT.position = mul(cb.mvp, float4(pos, 1.f));
	return OUT;
}

```

`src/animation/animation.cpp`:

```cpp
#include "pch.h"
#include "animation.h"
#include "core/imgui.h"
#include "core/string.h"
#include "geometry/mesh.h"
#include "skinning.h"

#include "dx/dx_context.h"
#include "rendering/debug_visualization.h"

#include <algorithm>

static void scaleKeyframes(animation_clip& clip, animation_joint& joint, float scale)
{
	for (uint32 keyID = 0; keyID < joint.numPositionKeyframes; ++keyID)
	{
		clip.positionKeyframes[joint.firstPositionKeyframe + keyID] *= scale;
	}
	for (uint32 keyID = 0; keyID < joint.numScaleKeyframes; ++keyID)
	{
		clip.scaleKeyframes[joint.firstScaleKeyframe + keyID] *= scale;
	}
}

void animation_skeleton::analyzeJoints(const vec3* positions, const void* others, uint32 otherStride, uint32 numVertices)
{
	for (uint32 jointID = 0; jointID < (uint32)joints.size(); ++jointID)
	{
		skeleton_joint& j = joints[jointID];

		std::string name = j.name;
		std::transform(name.begin(), name.end(), name.begin(), ::tolower);

		limb_type c = limb_type_unknown;

		bool left = contains(name, "left") || endsWith(name, ".l") || endsWith(name, "_l");

		if (contains(name, "spine") || contains(name, "hip") || contains(name, "rib") || contains(name, "pelvis") || contains(name, "shoulder") || contains(name, "clavicle")) { c = limb_type_torso; }
		else if (contains(name, "head") || contains(name, "neck")) { c = limb_type_head; }
		else if (contains(name, "arm"))
		{
			limb_type parentType = (j.parentID != INVALID_JOINT) ? joints[j.parentID].limbType : limb_type_unknown;

			if (contains(name, "lower") || contains(name, "lo") || contains(name, "fore")) { c = left ? limb_type_lower_arm_left : limb_type_lower_arm_right; }
			else if (contains(name, "upper") || contains(name, "up")) { c = left ? limb_type_upper_arm_left : limb_type_upper_arm_right; }
			else if (parentType == limb_type_torso) { c = left ? limb_type_upper_arm_left : limb_type_upper_arm_right; }
			else { c = left ? limb_type_lower_arm_left : limb_type_lower_arm_right; }
		}
		else if (contains(name, "hand") || contains(name, "finger") || contains(name, "thumb") || contains(name, "index") || contains(name, "middle") || contains(name, "ring") || contains(name, "pinky"))
		{
			c = left ? limb_type_hand_left : limb_type_hand_right;
		}
		else if (contains(name, "leg") || contains(name, "thigh") || contains(name, "shin") || contains(name, "calf"))
		{
			limb_type parentType = (j.parentID != INVALID_JOINT) ? joints[j.parentID].limbType : limb_type_unknown;

			if (contains(name, "lower") || contains(name, "lo") || contains(name, "shin") || contains(name, "calf")) { c = left ? limb_type_lower_leg_left : limb_type_lower_leg_right; }
			else if (contains(name, "upper") || contains(name, "up") || contains(name, "thigh")) { c = left ? limb_type_upper_leg_left : limb_type_upper_leg_right; }
			else if (parentType == limb_type_torso) { c = left ? limb_type_upper_leg_left : limb_type_upper_leg_right; }
			else { c = left ? limb_type_lower_leg_left : limb_type_lower_leg_right; }
		}
		else if (contains(name, "foot") || contains(name, "toe") || contains(name, "ball"))
		{
			c = left ? limb_type_foot_left : limb_type_foot_right;
		}

		j.limbType = c;
		j.ik = contains(name, "ik");

		if (limbs[c].representativeJoint == INVALID_JOINT)
		{
			// The highest joint in the hierarchy for this type is chosen as the representative.
			// Because we order the joints, the first joint we encounter is automatically the highest in the hierarchy.
			limbs[c].representativeJoint = jointID;
		}
	}

#if 0

	struct limb_analysis
	{
		vec3 vertexMean;
		uint32 numVertices;
		mat3 covariance;
	};

	limb_analysis analysis[limb_type_count] = {};

	for (uint32 i = 0; i < numVertices; ++i)
	{
		vec3 p = positions[i];
		skinning_weights w = *(skinning_weights*)((uint8*)others + i * otherStride);
		for (uint32 j = 0; j < 4; ++j)
		{
			if (w.skinWeights[j] > 150)
			{
				const auto& joint = joints[w.skinIndices[j]];
				limb_type c = joint.limbType;
				if (c != limb_type_unknown)
				{
					limb_analysis& a = analysis[c];
					a.vertexMean += p;
					++a.numVertices;
				}
			}
		}
	}

	for (uint32 i = 0; i < limb_type_count; ++i)
	{
		if (analysis[i].numVertices)
		{
			analysis[i].vertexMean /= (float)analysis[i].numVertices;
		}
	}


	for (uint32 i = 0; i < numVertices; ++i)
	{
		vec3 p = positions[i];
		skinning_weights w = *(skinning_weights*)((uint8*)others + i * otherStride);
		for (uint32 j = 0; j < 4; ++j)
		{
			if (w.skinWeights[j] > 150)
			{
				const auto& joint = joints[w.skinIndices[j]];
				limb_type c = joint.limbType;
				if (c != limb_type_unknown)
				{
					limb_analysis& a = analysis[c];
					vec3 m = a.vertexMean;

					for (uint32 y = 0; y < 3; ++y)
					{
						for (uint32 x = 0; x < 3; ++x)
						{
							a.covariance.m[3 * y + x] += (m.data[y] - p.data[y]) * (m.data[x] - p.data[x]);
						}
					}
				}
			}
		}
	}

	for (uint32 i = 0; i < limb_type_count; ++i)
	{
		if (analysis[i].numVertices)
		{
			analysis[i].covariance *= 1.f / (float)analysis[i].numVertices;

			//singular_value_decomposition svd = computeSVD(analysis[i].covariance);
			//vec3 principalAxis = col(svd.U, 0);

			vec3 eigenValues;
			mat3 eigenVectors;

			getEigen(analysis[i].covariance, eigenValues, eigenVectors);
			uint32 maxComponent = (eigenValues.x > eigenValues.y) ? (eigenValues.x > eigenValues.z) ? 0 : 2 : (eigenValues.y > eigenValues.z) ? 1 : 2;

			vec3 principalAxis = col(eigenVectors, maxComponent);

			limbs[i].mean = analysis[i].vertexMean;
			limbs[i].principalAxis = principalAxis;
		}
	}

#else

	for (uint32 i = 0; i < limb_type_count; ++i)
	{
		limbs[i].dimensions = { FLT_MAX, -FLT_MAX, -FLT_MAX };
	}

	for (uint32 i = 0; i < numVertices; ++i)
	{
		vec3 p = positions[i];
		skinning_weights w = *(skinning_weights*)((uint8*)others + i * otherStride);
		for (uint32 j = 0; j < 4; ++j)
		{
			if (w.skinWeights[j] > 200)
			{
				limb_type type = joints[w.skinIndices[j]].limbType;
				if (type != limb_type_unknown)
				{
					if (limbs[type].representativeJoint != INVALID_JOINT)
					{
						const skeleton_joint& j = joints[limbs[type].representativeJoint];
						limb_dimensions& d = limbs[type].dimensions;

						p = transformPosition(j.invBindTransform, p);

						d.minY = min(d.minY, p.y);
						d.maxY = max(d.maxY, p.y);
						d.radius = max(d.radius, squaredLength(vec2(p.x, p.z)));
					}
				}
			}
		}
	}

	for (uint32 i = 0; i < limb_type_count; ++i)
	{
		limb_dimensions& d = limbs[i].dimensions;

		d.radius = sqrt(d.radius); // Above, we calculate the squared radius.

		float c = 0.5f * (d.minY + d.maxY);

		const float scaleFactor = 0.8f;
		d.minY = (d.minY - c) * scaleFactor + c;
		d.maxY = (d.maxY - c) * scaleFactor + c;
		d.radius *= scaleFactor;

		d.minY += d.radius;
		d.maxY -= d.radius;
		if (d.minY > d.maxY)
		{
			d.minY = c - EPSILON;
			d.maxY = c + EPSILON;
		}
	}

#endif
}

static vec3 samplePosition(const animation_clip& clip, const animation_joint& animJoint, float time)
{
	if (time >= clip.lengthInSeconds)
	{
		return clip.positionKeyframes[animJoint.firstPositionKeyframe + animJoint.numPositionKeyframes - 1];
	}

	if (animJoint.numPositionKeyframes == 1)
	{
		return clip.positionKeyframes[animJoint.firstPositionKeyframe];
	}

	uint32 firstKeyframeIndex = -1;
	for (uint32 i = 0; i < animJoint.numPositionKeyframes - 1; ++i)
	{
		uint32 j = i + animJoint.firstPositionKeyframe;
		if (time < clip.positionTimestamps[j + 1])
		{
			firstKeyframeIndex = j;
			break;
		}
	}
	ASSERT(firstKeyframeIndex != -1);

	uint32 secondKeyframeIndex = firstKeyframeIndex + 1;

	float t = inverseLerp(clip.positionTimestamps[firstKeyframeIndex], clip.positionTimestamps[secondKeyframeIndex], time);

	vec3 a = clip.positionKeyframes[firstKeyframeIndex];
	vec3 b = clip.positionKeyframes[secondKeyframeIndex];

	return lerp(a, b, t);
}

static quat sampleRotation(const animation_clip& clip, const animation_joint& animJoint, float time)
{
	if (time >= clip.lengthInSeconds)
	{
		return clip.rotationKeyframes[animJoint.firstRotationKeyframe + animJoint.numRotationKeyframes - 1];
	}

	if (animJoint.numRotationKeyframes == 1)
	{
		return clip.rotationKeyframes[animJoint.firstRotationKeyframe];
	}

	uint32 firstKeyframeIndex = -1;
	for (uint32 i = 0; i < animJoint.numRotationKeyframes - 1; ++i)
	{
		uint32 j = i + animJoint.firstRotationKeyframe;
		if (time < clip.rotationTimestamps[j + 1])
		{
			firstKeyframeIndex = j;
			break;
		}
	}
	ASSERT(firstKeyframeIndex != -1);

	uint32 secondKeyframeIndex = firstKeyframeIndex + 1;

	float t = inverseLerp(clip.rotationTimestamps[firstKeyframeIndex], clip.rotationTimestamps[secondKeyframeIndex], time);

	quat a = clip.rotationKeyframes[firstKeyframeIndex];
	quat b = clip.rotationKeyframes[secondKeyframeIndex];

	if (dot(a.v4, b.v4) < 0.f)
	{
		b.v4 *= -1.f;
	}

	return lerp(a, b, t);
}

static vec3 sampleScale(const animation_clip& clip, const animation_joint& animJoint, float time)
{
	if (time >= clip.lengthInSeconds)
	{
		return clip.scaleKeyframes[animJoint.firstScaleKeyframe + animJoint.numScaleKeyframes - 1];
	}

	if (animJoint.numScaleKeyframes == 1)
	{
		return clip.scaleKeyframes[animJoint.firstScaleKeyframe];
	}

	uint32 firstKeyframeIndex = -1;
	for (uint32 i = 0; i < animJoint.numScaleKeyframes - 1; ++i)
	{
		uint32 j = i + animJoint.firstScaleKeyframe;
		if (time < clip.scaleTimestamps[j + 1])
		{
			firstKeyframeIndex = j;
			break;
		}
	}
	ASSERT(firstKeyframeIndex != -1);

	uint32 secondKeyframeIndex = firstKeyframeIndex + 1;

	float t = inverseLerp(clip.scaleTimestamps[firstKeyframeIndex], clip.scaleTimestamps[secondKeyframeIndex], time);

	vec3 a = clip.scaleKeyframes[firstKeyframeIndex];
	vec3 b = clip.scaleKeyframes[secondKeyframeIndex];

	return lerp(a, b, t);
}

void animation_skeleton::sampleAnimation(const animation_clip& clip, float time, trs* outLocalTransforms, trs* outRootMotion) const
{
	ASSERT(clip.joints.size() == joints.size());

	time = clamp(time, 0.f, clip.lengthInSeconds);

	uint32 numJoints = (uint32)joints.size();
	for (uint32 i = 0; i < numJoints; ++i)
	{
		const animation_joint& animJoint = clip.joints[i];

		if (animJoint.isAnimated)
		{
			outLocalTransforms[i].position = samplePosition(clip, animJoint, time);
			outLocalTransforms[i].rotation = sampleRotation(clip, animJoint, time);
			outLocalTransforms[i].scale = sampleScale(clip, animJoint, time);
		}
		else
		{
			outLocalTransforms[i] = trs::identity;
		}
	}

	trs rootMotion;
	if (clip.rootMotionJoint.isAnimated)
	{
		rootMotion.position = samplePosition(clip, clip.rootMotionJoint, time);
		rootMotion.rotation = sampleRotation(clip, clip.rootMotionJoint, time);
		rootMotion.scale = sampleScale(clip, clip.rootMotionJoint, time);
	}
	else
	{
		rootMotion = trs::identity;
	}

	if (outRootMotion)
	{
		if (clip.bakeRootRotationIntoPose)
		{
			outLocalTransforms[0] = trs(0.f, rootMotion.rotation) * outLocalTransforms[0];
			rootMotion.rotation = quat::identity;
		}

		if (clip.bakeRootXZTranslationIntoPose)
		{
			outLocalTransforms[0].position.x += rootMotion.position.x;
			outLocalTransforms[0].position.z += rootMotion.position.z;
			rootMotion.position.x = 0.f;
			rootMotion.position.z = 0.f;
		}

		if (clip.bakeRootYTranslationIntoPose)
		{
			outLocalTransforms[0].position.y += rootMotion.position.y;
			rootMotion.position.y = 0.f;
		}

		*outRootMotion = rootMotion;
	}
	else
	{
		outLocalTransforms[0] = rootMotion * outLocalTransforms[0];
	}
}

void animation_skeleton::sampleAnimation(uint32 index, float time, trs* outLocalTransforms, trs* outRootMotion) const
{
	sampleAnimation(clips[index], time, outLocalTransforms, outRootMotion);
}

void animation_skeleton::blendLocalTransforms(const trs* localTransforms1, const trs* localTransforms2, float t, trs* outBlendedLocalTransforms) const
{
	t = clamp01(t);
	for (uint32 jointID = 0; jointID < (uint32)joints.size(); ++jointID)
	{
		outBlendedLocalTransforms[jointID] = lerp(localTransforms1[jointID], localTransforms2[jointID], t);
	}
}

void animation_skeleton::getSkinningMatricesFromLocalTransforms(const trs* localTransforms, mat4* outSkinningMatrices, const trs& worldTransform) const
{
	uint32 numJoints = (uint32)joints.size();
	trs* globalTransforms = (trs*)alloca(sizeof(trs) * numJoints);

	for (uint32 i = 0; i < numJoints; ++i)
	{
		const skeleton_joint& skelJoint = joints[i];
		if (skelJoint.parentID != INVALID_JOINT)
		{
			ASSERT(i > skelJoint.parentID); // Parent already processed.
			globalTransforms[i] = globalTransforms[skelJoint.parentID] * localTransforms[i];
		}
		else
		{
			globalTransforms[i] = worldTransform * localTransforms[i];
		}

		outSkinningMatrices[i] = trsToMat4(globalTransforms[i]) * joints[i].invBindTransform;
	}
}

void animation_skeleton::getSkinningMatricesFromLocalTransforms(const trs* localTransforms, trs* outGlobalTransforms, mat4* outSkinningMatrices, const trs& worldTransform) const
{
	uint32 numJoints = (uint32)joints.size();

	for (uint32 i = 0; i < numJoints; ++i)
	{
		const skeleton_joint& skelJoint = joints[i];
		if (skelJoint.parentID != INVALID_JOINT)
		{
			ASSERT(i > skelJoint.parentID); // Parent already processed.
			outGlobalTransforms[i] = outGlobalTransforms[skelJoint.parentID] * localTransforms[i];
		}
		else
		{
			outGlobalTransforms[i] = worldTransform * localTransforms[i];
		}

		outSkinningMatrices[i] = trsToMat4(outGlobalTransforms[i]) * joints[i].invBindTransform;
	}
}

void animation_skeleton::getSkinningMatricesFromGlobalTransforms(const trs* globalTransforms, mat4* outSkinningMatrices) const
{
	uint32 numJoints = (uint32)joints.size();

	for (uint32 i = 0; i < numJoints; ++i)
	{
		outSkinningMatrices[i] = trsToMat4(globalTransforms[i]) * joints[i].invBindTransform;
	}
}

std::vector<uint32> animation_skeleton::getClipsByName(const std::string& name)
{
	std::vector<uint32> result;
	for (uint32 i = 0; i < (uint32)clips.size(); ++i)
	{
		if (clips[i].name == name)
		{
			result.push_back(i);
		}
	}
	return result;
}

static void prettyPrint(const animation_skeleton& skeleton, uint32 parent, uint32 indent)
{
	for (uint32 i = 0; i < (uint32)skeleton.joints.size(); ++i)
	{
		if (skeleton.joints[i].parentID == parent)
		{
			std::cout << std::string(indent, ' ') << skeleton.joints[i].name << '\n';
			prettyPrint(skeleton, i, indent + 1);
		}
	}
}

void animation_skeleton::prettyPrintHierarchy() const
{
	prettyPrint(*this, INVALID_JOINT, 0);
}

void animation_clip::edit()
{
	ImGui::Checkbox("Bake root rotation into pose", &bakeRootRotationIntoPose);
	ImGui::Checkbox("Bake xz translation into pose", &bakeRootXZTranslationIntoPose);
	ImGui::Checkbox("Bake y translation into pose", &bakeRootYTranslationIntoPose);
}

trs animation_clip::getFirstRootTransform() const
{
	if (rootMotionJoint.isAnimated)
	{
		trs t;
		t.position = positionKeyframes[rootMotionJoint.firstPositionKeyframe];
		t.rotation = rotationKeyframes[rootMotionJoint.firstRotationKeyframe];
		t.scale = scaleKeyframes[rootMotionJoint.firstScaleKeyframe];

		if (bakeRootRotationIntoPose)
		{
			t.rotation = quat::identity;
		}
		if (bakeRootXZTranslationIntoPose)
		{
			t.position.x = 0.f;
			t.position.z = 0.f;
		}
		if (bakeRootYTranslationIntoPose)
		{
			t.position.y = 0.f;
		}

		return t;
	}
	return trs::identity;
}

trs animation_clip::getLastRootTransform() const
{
	if (rootMotionJoint.isAnimated)
	{
		trs t;
		t.position = positionKeyframes[rootMotionJoint.firstPositionKeyframe + rootMotionJoint.numPositionKeyframes - 1];
		t.rotation = rotationKeyframes[rootMotionJoint.firstRotationKeyframe + rootMotionJoint.numRotationKeyframes - 1];
		t.scale = scaleKeyframes[rootMotionJoint.firstScaleKeyframe + rootMotionJoint.numScaleKeyframes - 1];

		if (bakeRootRotationIntoPose)
		{
			t.rotation = quat::identity;
		}
		if (bakeRootXZTranslationIntoPose)
		{
			t.position.x = 0.f;
			t.position.z = 0.f;
		}
		if (bakeRootYTranslationIntoPose)
		{
			t.position.y = 0.f;
		}

		return t;
	}
	return trs::identity;
}

animation_instance::animation_instance(const animation_clip* clip, float startTime)
{
	set(clip, startTime);
}

void animation_instance::set(const animation_clip* clip, float startTime)
{
	this->clip = clip;
	time = startTime;
	lastRootMotion = clip->getFirstRootTransform();
}

void animation_instance::update(const animation_skeleton& skeleton, float dt, trs* outLocalTransforms, trs& outDeltaRootMotion)
{
	if (valid())
	{
		time += dt;
		if (time >= clip->lengthInSeconds)
		{
			if (clip->looping)
			{
				time = fmod(time, clip->lengthInSeconds);
				lastRootMotion = clip->getFirstRootTransform();
			}
			else
			{
				time = clip->lengthInSeconds;
			}
		}

		trs rootMotion;
		skeleton.sampleAnimation(*clip, time, outLocalTransforms, &rootMotion);

		outDeltaRootMotion = invert(lastRootMotion) * rootMotion;
		lastRootMotion = rootMotion;
	}
}

#if 0
animation_blend_tree_1d::animation_blend_tree_1d(std::initializer_list<animation_clip*> clips, float startBlendValue, float startRelTime)
{
	ASSERT(clips.size() <= arraysize(this->clips));
	ASSERT(clips.size() > 1);

	numClips = 0;
	for (animation_clip* clip : clips)
	{
		this->clips[numClips++] = clip;
	}

	first = 0;
	second = 1;
	relTime = startRelTime;

	setBlendValue(startBlendValue);

	lastRootMotion = lerp(this->clips[first]->getFirstRootTransform(), this->clips[second]->getFirstRootTransform(), blendValue);
}

void animation_blend_tree_1d::update(const animation_skeleton& skeleton, float dt, trs* outLocalTransforms, trs& outDeltaRootMotion)
{
	const animation_clip* first = clips[this->first];
	const animation_clip* second = clips[this->second];

	float firstLength = first->lengthInSeconds;
	float secondLength = second->lengthInSeconds;

	float lengthDist = secondLength - firstLength;
	float targetLength = firstLength + lengthDist * blendValue;

	float start = relTime;
	relTime += dt / targetLength;
	relTime = fmodf(relTime, 1.f);


	trs* totalLocalTransforms = (trs*)alloca(sizeof(trs) * skeleton.joints.size() * 2);
	trs* localTransforms1 = totalLocalTransforms;
	trs* localTransforms2 = totalLocalTransforms + skeleton.joints.size();

	trs rootMotion1, rootMotion2;
	skeleton.sampleAnimation(*first, first->lengthInSeconds * relTime, localTransforms1, &rootMotion1);
	skeleton.sampleAnimation(*second, second->lengthInSeconds * relTime, localTransforms2, &rootMotion2);

	skeleton.blendLocalTransforms(localTransforms1, localTransforms2, blendValue, outLocalTransforms);
	
	trs rootMotion = lerp(rootMotion1, rootMotion2, blendValue);

	outDeltaRootMotion = invert(lastRootMotion) * rootMotion;
	lastRootMotion = rootMotion;
}

void animation_blend_tree_1d::setBlendValue(float value)
{
	value = clamp01(value);

	float step = 1.f / (numClips - 1);

	uint32 newFirstAnimationIndex = numClips - 2, newSecondAnimationIndex = numClips - 1;
	if (value < 1.f)
	{
		newFirstAnimationIndex = (uint32)(value / step);
		newSecondAnimationIndex = newFirstAnimationIndex + 1;
	}

	first = newFirstAnimationIndex;
	second = newSecondAnimationIndex;

	float begin = newFirstAnimationIndex * step;
	this->blendValue = (value - begin) / step;
	this->value = value;
}
#endif

void animation_component::update(const ref<multi_mesh>& mesh, memory_arena& arena, float dt, trs* transform)
{
	const dx_mesh& dxMesh = mesh->mesh;
	animation_skeleton& skeleton = mesh->skeleton;

	currentGlobalTransforms = 0;

	if (animation.valid())
	{
		auto [vb, skinningMatrices] = skinObject(dxMesh.vertexBuffer, dxMesh.vertexBuffer.positions->elementCount, (uint32)skeleton.joints.size());

		prevFrameVertexBuffer = currentVertexBuffer;
		currentVertexBuffer = vb;

		trs* localTransforms = (trs*)alloca(sizeof(trs) * skeleton.joints.size());
		trs deltaRootMotion;
		animation.update(skeleton, dt * timeScale, localTransforms, deltaRootMotion);

		trs* globalTransforms = arena.allocate<trs>((uint32)skeleton.joints.size());

		skeleton.getSkinningMatricesFromLocalTransforms(localTransforms, globalTransforms, skinningMatrices);

		if (transform)
		{
			*transform = *transform * deltaRootMotion;
			transform->rotation = normalize(transform->rotation);
		}

		currentGlobalTransforms = globalTransforms;
	}
	else
	{
		currentVertexBuffer = dxMesh.vertexBuffer;
		if (!prevFrameVertexBuffer)
		{
			prevFrameVertexBuffer = currentVertexBuffer;
		}
	}
}

const char* limbTypeNames[] =
{
	"Unknown",

	"Torso",
	"Head",

	"Upper arm right",
	"Lower arm right",
	"Hand right",

	"Upper arm left",
	"Lower arm left",
	"Hand left",

	"Upper leg right",
	"Lower leg right",
	"Foot right",

	"Upper leg left",
	"Lower leg left",
	"Foot left",
};

const vec3 limbTypeColors[] =
{
	vec3(1.f, 0.f, 1.f),

	vec3(1.f, 0.f, 0.f),
	vec3(0.f, 1.f, 0.f),

	vec3(1.f, 1.f, 0.f),
	vec3(0.f, 1.f, 1.f),
	vec3(1.f, 1.f, 1.f),

	vec3(1.f, 1.f, 0.f),
	vec3(0.f, 1.f, 1.f),
	vec3(1.f, 1.f, 1.f),

	vec3(1.f, 1.f, 0.f),
	vec3(0.f, 1.f, 1.f),
	vec3(1.f, 1.f, 1.f),

	vec3(1.f, 1.f, 0.f),
	vec3(0.f, 1.f, 1.f),
	vec3(1.f, 1.f, 1.f),
};

void animation_component::drawCurrentSkeleton(const ref<multi_mesh>& mesh, const trs& transform, ldr_render_pass* renderPass)
{
	const dx_mesh& dxMesh = mesh->mesh;
	animation_skeleton& skeleton = mesh->skeleton;

#if 1

	uint32 numJoints = (uint32)skeleton.joints.size();

	auto [vb, vertexPtr] = dxContext.createDynamicVertexBuffer(sizeof(position_color), numJoints * 2);
	auto [ib, indexPtr] = dxContext.createDynamicIndexBuffer(sizeof(uint16), numJoints * 2);

	position_color* vertices = (position_color*)vertexPtr;
	indexed_line16* lines = (indexed_line16*)indexPtr;

	for (uint32 i = 0; i < numJoints; ++i)
	{
		const auto& joint = skeleton.joints[i];
		if (joint.parentID != INVALID_JOINT && !joint.ik)
		{
			const auto& parentJoint = skeleton.joints[joint.parentID];
			if (currentGlobalTransforms)
			{
				*vertices++ = { currentGlobalTransforms[joint.parentID].position, limbTypeColors[parentJoint.limbType] };
				*vertices++ = { currentGlobalTransforms[i].position, limbTypeColors[parentJoint.limbType] };
			}
			else
			{
				*vertices++ = { skeleton.joints[joint.parentID].bindTransform.col3.xyz, limbTypeColors[parentJoint.limbType] };
				*vertices++ = { joint.bindTransform.col3.xyz, limbTypeColors[parentJoint.limbType] };
			}
		}
		else
		{
			*vertices++ = { vec3(0.f, 0.f, 0.f), vec3(1.f, 1.f, 1.f) };
			*vertices++ = { vec3(0.f, 0.f, 0.f), vec3(1.f, 1.f, 1.f) };
		}

		*lines++ = { (uint16)(2 * i), (uint16)(2 * i + 1) };
	}

	renderDebug<debug_unlit_line_pipeline::position_color>(trsToMat4(transform), vb, ib, vec4(1.f, 1.f, 1.f, 1.f), renderPass, true);

#else


#if 0

	auto [vb, vertexPtr] = dxContext.createDynamicVertexBuffer(sizeof(position_color), limb_type_count * 2);
	auto [ib, indexPtr] = dxContext.createDynamicIndexBuffer(sizeof(uint16), limb_type_count * 2);

	position_color* vertices = (position_color*)vertexPtr;
	indexed_line16* lines = (indexed_line16*)indexPtr;

	for (uint32 i = 0; i < limb_type_count; ++i)
	{
		const auto& limb = skeleton.limbs[i];
		*vertices++ = { limb.mean - limb.principalAxis / transform.scale * 0.2f, limbTypeColors[i] };
		*vertices++ = { limb.mean + limb.principalAxis / transform.scale * 0.2f, limbTypeColors[i] };

		*lines++ = { (uint16)(2 * i), (uint16)(2 * i + 1) };
	}

	renderDebug<debug_unlit_line_pipeline::position_color>(trsToMat4(transform), vb, ib, vec4(1.f, 1.f, 1.f, 1.f), renderPass, true);

#else

	for (uint32 i = 0; i < limb_type_count; ++i)
	{
		const auto& limb = skeleton.limbs[i];

		if (limb.representativeJoint != INVALID_JOINT)
		{
			const auto& joint = skeleton.joints[limb.representativeJoint];
			vec3 a = vec3(limb.dimensions.xOffset, limb.dimensions.minY, limb.dimensions.zOffset);
			vec3 b = vec3(limb.dimensions.xOffset, limb.dimensions.maxY, limb.dimensions.zOffset);
			a = transformPosition(joint.bindTransform, a);
			b = transformPosition(joint.bindTransform, b);
			a = transformPosition(transform, a);
			b = transformPosition(transform, b);

			renderWireCapsule(a, b, limb.dimensions.radius * transform.scale.x, vec4(limbTypeColors[i], 1.f), renderPass, true);
		}

	}


#endif

#endif
}

```

`src/animation/animation.h`:

```h
#pragma once

#include "core/math.h"
#include "core/random.h"
#include "core/memory.h"
#include "dx/dx_buffer.h"
#include <unordered_map>

#define INVALID_JOINT 0xFFFFFFFF

struct skinning_weights
{
	uint8 skinIndices[4];
	uint8 skinWeights[4];
};


enum limb_type
{
	limb_type_unknown,

	limb_type_torso,
	limb_type_head,

	limb_type_upper_arm_right,
	limb_type_lower_arm_right,
	limb_type_hand_right,

	limb_type_upper_arm_left,
	limb_type_lower_arm_left,
	limb_type_hand_left,

	limb_type_upper_leg_right,
	limb_type_lower_leg_right,
	limb_type_foot_right,

	limb_type_upper_leg_left,
	limb_type_lower_leg_left,
	limb_type_foot_left,

	limb_type_count,
};

extern const char* limbTypeNames[limb_type_count];
extern const vec3 limbTypeColors[limb_type_count];

struct skeleton_joint
{
	std::string name;
	limb_type limbType;
	bool ik;

	mat4 invBindTransform; // Transforms from model space to joint space.
	mat4 bindTransform;	  // Position of joint relative to model space.
	uint32 parentID;
};

struct animation_joint
{
	bool isAnimated = false;

	uint32 firstPositionKeyframe;
	uint32 numPositionKeyframes;

	uint32 firstRotationKeyframe;
	uint32 numRotationKeyframes;

	uint32 firstScaleKeyframe;
	uint32 numScaleKeyframes;
};

struct animation_clip
{
	std::string name;
	fs::path filename;

	std::vector<float> positionTimestamps;
	std::vector<float> rotationTimestamps;
	std::vector<float> scaleTimestamps;

	std::vector<vec3> positionKeyframes;
	std::vector<quat> rotationKeyframes;
	std::vector<vec3> scaleKeyframes;

	std::vector<animation_joint> joints;

	animation_joint rootMotionJoint;
	
	float lengthInSeconds;
	bool looping = true;
	bool bakeRootRotationIntoPose = false;
	bool bakeRootXZTranslationIntoPose = false;
	bool bakeRootYTranslationIntoPose = false;


	void edit();
	trs getFirstRootTransform() const;
	trs getLastRootTransform() const;
};

struct limb_dimensions
{
	float minY, maxY;
	float radius;
	float xOffset, zOffset;
};

struct skeleton_limb
{
	uint32 representativeJoint = INVALID_JOINT;
	limb_dimensions dimensions;
};

struct animation_skeleton
{
	std::vector<skeleton_joint> joints;
	std::unordered_map<std::string, uint32> nameToJointID;

	std::vector<animation_clip> clips;
	std::vector<fs::path> files;

	skeleton_limb limbs[limb_type_count];

	void analyzeJoints(const vec3* positions, const void* others, uint32 otherStride, uint32 numVertices);

	void sampleAnimation(const animation_clip& clip, float time, trs* outLocalTransforms, trs* outRootMotion = 0) const;
	void sampleAnimation(uint32 index, float time, trs* outLocalTransforms, trs* outRootMotion = 0) const;
	void blendLocalTransforms(const trs* localTransforms1, const trs* localTransforms2, float t, trs* outBlendedLocalTransforms) const;
	void getSkinningMatricesFromLocalTransforms(const trs* localTransforms, mat4* outSkinningMatrices, const trs& worldTransform = trs::identity) const;
	void getSkinningMatricesFromLocalTransforms(const trs* localTransforms, trs* outGlobalTransforms, mat4* outSkinningMatrices, const trs& worldTransform = trs::identity) const;
	void getSkinningMatricesFromGlobalTransforms(const trs* globalTransforms, mat4* outSkinningMatrices) const;

	std::vector<uint32> getClipsByName(const std::string& name);

	void prettyPrintHierarchy() const;
};

struct animation_instance
{
	animation_instance() { }
	animation_instance(const animation_clip* clip, float startTime = 0.f);

	void set(const animation_clip* clip, float startTime = 0.f);
	void update(const animation_skeleton& skeleton, float dt, trs* outLocalTransforms, trs& outDeltaRootMotion);

	bool valid() const { return clip != 0; }

	const animation_clip* clip = 0;
	float time = 0.f;

	trs lastRootMotion;
};

#if 0
struct animation_blend_tree_1d
{
	animation_blend_tree_1d() { }
	animation_blend_tree_1d(std::initializer_list<animation_clip*> clips, float startRelTime = 0.f, float startBlendValue = 0.f);

	void setBlendValue(float blendValue);
	void update(const animation_skeleton& skeleton, float dt, trs* outLocalTransforms, trs& outDeltaRootMotion);

private:
	animation_clip* clips[8];
	uint32 numClips = 0;

	float value;
	uint32 first;
	uint32 second;
	float relTime;
	float blendValue;

	trs lastRootMotion;
};
#endif

struct animation_component
{
	animation_instance animation;
	float timeScale = 1.f;

	dx_vertex_buffer_group_view currentVertexBuffer;
	dx_vertex_buffer_group_view prevFrameVertexBuffer;
	trs* currentGlobalTransforms = 0;

	void update(const ref<struct multi_mesh>& mesh, memory_arena& arena, float dt, trs* transform = 0);
	void drawCurrentSkeleton(const ref<struct multi_mesh>& mesh, const trs& transform, struct ldr_render_pass* renderPass);
};


```

`src/animation/skinning.cpp`:

```cpp
#include "pch.h"
#include "skinning.h"
#include "dx/dx_command_list.h"
#include "dx/dx_barrier_batcher.h"
#include "dx/dx_profiling.h"
#include "rendering/material.h"
#include "rendering/render_pass.h"
#include "dx/dx_buffer.h"

#include "skinning_rs.hlsli"




static dx_pipeline skinningPipeline;
static dx_pipeline clothSkinningPipeline;


struct skinning_call
{
	dx_vertex_buffer_group_view vertexBuffer;
	vertex_range range;
	uint32 jointOffset;
	uint32 numJoints;
	uint32 vertexOffset;
};

struct cloth_skinning_call
{
	dx_vertex_buffer_view vertexBuffer;
	uint32 gridSizeX;
	uint32 gridSizeY;
	uint32 vertexOffset;
};

struct skinning_data
{
	vertex_buffer_group skinnedVertexBuffer;
	ref<dx_buffer> skinningMatricesBuffer;

	mat4* skinningMatrices;
	uint32 numSkinningMatrices;
	uint32 matrixOffset;

	skinning_call* calls;
	uint32 numCalls;

	cloth_skinning_call* clothCalls;
	uint32 numClothCalls;
};

struct skinning_pipeline
{
	PIPELINE_SETUP_DECL{}

	PIPELINE_COMPUTE_DECL(skinning_data)
	{
		PROFILE_ALL(cl, "Skinning");

		if (data.numCalls)
		{
			PROFILE_ALL(cl, "Skeletal");

			mat4* mats = (mat4*)mapBuffer(data.skinningMatricesBuffer, false);
			memcpy(mats + data.matrixOffset, data.skinningMatrices, sizeof(mat4) * data.numSkinningMatrices);
			unmapBuffer(data.skinningMatricesBuffer, true, map_range{ data.matrixOffset, data.numSkinningMatrices });


			cl->setPipelineState(*skinningPipeline.pipeline);
			cl->setComputeRootSignature(*skinningPipeline.rootSignature);

			cl->setRootComputeSRV(SKINNING_RS_MATRICES, data.skinningMatricesBuffer->gpuVirtualAddress + sizeof(mat4) * data.matrixOffset);
			cl->setRootComputeUAV(SKINNING_RS_OUTPUT0, data.skinnedVertexBuffer.positions);
			cl->setRootComputeUAV(SKINNING_RS_OUTPUT1, data.skinnedVertexBuffer.others);

			for (uint32 i = 0; i < data.numCalls; ++i)
			{
				auto& c = data.calls[i];
				cl->setRootComputeSRV(SKINNING_RS_INPUT_VERTEX_BUFFER0, c.vertexBuffer.positions.view.BufferLocation);
				cl->setRootComputeSRV(SKINNING_RS_INPUT_VERTEX_BUFFER1, c.vertexBuffer.others.view.BufferLocation);
				cl->setCompute32BitConstants(SKINNING_RS_CB, skinning_cb{ c.jointOffset, c.numJoints, c.range.firstVertex, c.range.numVertices, c.vertexOffset });
				cl->dispatch(bucketize(c.range.numVertices, 512));
			}
		}
		if (data.numClothCalls)
		{
			PROFILE_ALL(cl, "Cloth");

			cl->setPipelineState(*clothSkinningPipeline.pipeline);
			cl->setComputeRootSignature(*clothSkinningPipeline.rootSignature);

			cl->setRootComputeUAV(CLOTH_SKINNING_RS_OUTPUT0, data.skinnedVertexBuffer.positions);
			cl->setRootComputeUAV(CLOTH_SKINNING_RS_OUTPUT1, data.skinnedVertexBuffer.others);

			for (uint32 i = 0; i < data.numClothCalls; ++i)
			{
				auto& c = data.clothCalls[i];
				cl->setRootComputeSRV(CLOTH_SKINNING_RS_INPUT, c.vertexBuffer.view.BufferLocation);
				cl->setCompute32BitConstants(CLOTH_SKINNING_RS_CB, cloth_skinning_cb{ c.gridSizeX, c.gridSizeY, c.vertexOffset });
				cl->dispatch(bucketize(c.gridSizeX, 15), bucketize(c.gridSizeY, 15)); // 15 is correct here.
			}
		}

		// Not necessary, since the command list ends here.
		//barrier_batcher(cl)
		//	.uav(data.skinnedVertexBuffer.positions)
		//	.uav(data.skinnedVertexBuffer.others);
	}
};









#define MAX_NUM_SKINNING_MATRICES_PER_FRAME 4096
#define MAX_NUM_SKINNED_VERTICES_PER_FRAME (1024 * 256)

static ref<dx_buffer> skinningMatricesBuffer; // Buffered frames are in a single dx_buffer.

static uint32 currentSkinnedVertexBuffer;
static vertex_buffer_group skinnedVertexBuffer[2]; // We have two of these, so that we can compute screen space velocities.


static mat4 skinningMatrices[MAX_NUM_SKINNING_MATRICES_PER_FRAME];
static volatile uint32 numSkinningMatricesThisFrame;

static skinning_call calls[1024];
static volatile uint32 numCalls;

static cloth_skinning_call clothCalls[128];
static volatile uint32 numClothCalls;


static volatile uint32 totalNumVertices;


void initializeSkinning()
{
	skinningMatricesBuffer = createUploadBuffer(sizeof(mat4), MAX_NUM_SKINNING_MATRICES_PER_FRAME * NUM_BUFFERED_FRAMES, 0);

	for (uint32 i = 0; i < 2; ++i)
	{
		skinnedVertexBuffer[i].positions = createVertexBuffer(sizeof(vec3), MAX_NUM_SKINNED_VERTICES_PER_FRAME, 0, true);
		skinnedVertexBuffer[i].others = createVertexBuffer(
			getVertexOthersSize(mesh_creation_flags_with_positions | mesh_creation_flags_with_uvs | mesh_creation_flags_with_normals | mesh_creation_flags_with_tangents), 
			MAX_NUM_SKINNED_VERTICES_PER_FRAME, 0, true);
	}

	skinningPipeline = createReloadablePipeline("skinning_cs");
	clothSkinningPipeline = createReloadablePipeline("cloth_skinning_cs");
}

std::tuple<dx_vertex_buffer_group_view, mat4*> skinObject(const dx_vertex_buffer_group_view& vertexBuffer, vertex_range range, uint32 numJoints)
{
	uint32 jointOffset = atomicAdd(numSkinningMatricesThisFrame, numJoints);
	ASSERT(jointOffset + numJoints <= MAX_NUM_SKINNING_MATRICES_PER_FRAME);

	uint32 vertexOffset = atomicAdd(totalNumVertices, range.numVertices);
	ASSERT(vertexOffset + range.numVertices <= MAX_NUM_SKINNED_VERTICES_PER_FRAME);

	uint32 callIndex = atomicIncrement(numCalls);
	ASSERT(callIndex < arraysize(calls));

	calls[callIndex] = {
		vertexBuffer,
		range,
		jointOffset,
		numJoints,
		vertexOffset
	};

	uint32 numVertices = range.numVertices;

	auto positions = skinnedVertexBuffer[currentSkinnedVertexBuffer].positions;
	auto others = skinnedVertexBuffer[currentSkinnedVertexBuffer].others;

	dx_vertex_buffer_group_view result;
	result.positions.view.BufferLocation = positions->gpuVirtualAddress + positions->elementSize * vertexOffset;
	result.positions.view.SizeInBytes = positions->elementSize * numVertices;
	result.positions.view.StrideInBytes = positions->elementSize;
	result.others.view.BufferLocation = others->gpuVirtualAddress + others->elementSize * vertexOffset;
	result.others.view.SizeInBytes = others->elementSize * numVertices;
	result.others.view.StrideInBytes = others->elementSize;

	return { result, skinningMatrices + jointOffset };
}

std::tuple<dx_vertex_buffer_group_view, mat4*> skinObject(const dx_vertex_buffer_group_view& vertexBuffer, uint32 numVertices, uint32 numJoints)
{
	auto [vb, mats] = skinObject(vertexBuffer, vertex_range{ 0, numVertices }, numJoints);
	return { vb, mats };
}

std::tuple<dx_vertex_buffer_group_view, mat4*> skinObject(const dx_vertex_buffer_group_view& vertexBuffer, submesh_info submesh, uint32 numJoints)
{
	auto [vb, mats] = skinObject(vertexBuffer, vertex_range{ submesh.baseVertex, submesh.numVertices }, numJoints);

	return { vb, mats };
}

dx_vertex_buffer_group_view skinCloth(const dx_vertex_buffer_view& inpositions, uint32 gridSizeX, uint32 gridSizeY)
{
	uint32 numVertices = gridSizeX * gridSizeY;
	uint32 vertexOffset = atomicAdd(totalNumVertices, numVertices);
	ASSERT(vertexOffset + numVertices <= MAX_NUM_SKINNED_VERTICES_PER_FRAME);

	uint32 callIndex = atomicIncrement(numClothCalls);
	ASSERT(callIndex < arraysize(clothCalls));

	clothCalls[callIndex] = {
		inpositions,
		gridSizeX,
		gridSizeY,
		vertexOffset
	};

	auto positions = skinnedVertexBuffer[currentSkinnedVertexBuffer].positions;
	auto others = skinnedVertexBuffer[currentSkinnedVertexBuffer].others;

	dx_vertex_buffer_group_view result;
	result.positions.view.BufferLocation = positions->gpuVirtualAddress + positions->elementSize * vertexOffset;
	result.positions.view.SizeInBytes = positions->elementSize * numVertices;
	result.positions.view.StrideInBytes = positions->elementSize;
	result.others.view.BufferLocation = others->gpuVirtualAddress + others->elementSize * vertexOffset;
	result.others.view.SizeInBytes = others->elementSize * numVertices;
	result.others.view.StrideInBytes = others->elementSize;
	return result;
}


void performSkinning(compute_pass* computePass)
{
	// TODO: We currently make no attempt to ensure that all draw calls have actually been written completely, if executed on another thread. 
	if (numCalls > 0 || numClothCalls > 0)
	{
		skinning_data data;
		data.skinnedVertexBuffer = skinnedVertexBuffer[currentSkinnedVertexBuffer];
		data.skinningMatricesBuffer = skinningMatricesBuffer;

		data.skinningMatrices = skinningMatrices;
		data.numSkinningMatrices = numSkinningMatricesThisFrame;
		data.matrixOffset = dxContext.bufferedFrameID * MAX_NUM_SKINNING_MATRICES_PER_FRAME;

		data.calls = calls;
		data.numCalls = numCalls;

		data.clothCalls = clothCalls;
		data.numClothCalls = numClothCalls;


		computePass->addTask<skinning_pipeline>(compute_pass_frame_start, data);


		currentSkinnedVertexBuffer = 1 - currentSkinnedVertexBuffer;
		numCalls = 0;
		numClothCalls = 0;
		numSkinningMatricesThisFrame = 0;
		totalNumVertices = 0;
	}
}



```

`src/animation/skinning.h`:

```h
#pragma once

#include "core/math.h"
#include "geometry/mesh_builder.h"

struct vertex_range
{
	uint32 firstVertex;
	uint32 numVertices;
};

struct dx_vertex_buffer_group_view;
struct dx_vertex_buffer_view;

void initializeSkinning();
std::tuple<dx_vertex_buffer_group_view, mat4*> skinObject(const dx_vertex_buffer_group_view& vertexBuffer, vertex_range range, uint32 numJoints);
std::tuple<dx_vertex_buffer_group_view, mat4*> skinObject(const dx_vertex_buffer_group_view& vertexBuffer, uint32 numVertices, uint32 numJoints);
std::tuple<dx_vertex_buffer_group_view, mat4*> skinObject(const dx_vertex_buffer_group_view& vertexBuffer, submesh_info submesh, uint32 numJoints);

dx_vertex_buffer_group_view skinCloth(const dx_vertex_buffer_view& positions, uint32 gridSizeX, uint32 gridSizeY);

void performSkinning(struct compute_pass* computePass);

```

`src/application.cpp`:

```cpp
#include "pch.h"
#include "application.h"
#include "geometry/mesh_builder.h"
#include "dx/dx_texture.h"
#include "core/random.h"
#include "core/color.h"
#include "core/imgui.h"
#include "core/log.h"
#include "dx/dx_context.h"
#include "dx/dx_profiling.h"
#include "physics/physics.h"
#include "physics/ragdoll.h"
#include "physics/vehicle.h"
#include "core/threading.h"
#include "rendering/outline.h"
#include "rendering/mesh_shader.h"
#include "rendering/shadow_map.h"
#include "rendering/debug_visualization.h"
#include "scene/scene_rendering.h"
#include "audio/audio.h"
#include "terrain/terrain.h"
#include "terrain/heightmap_collider.h"
#include "terrain/proc_placement.h"
#include "terrain/grass.h"
#include "terrain/water.h"
#include "terrain/tree.h"
#include "animation/skinning.h"
#include "asset/model_asset.h"


static raytracing_object_type defineBlasFromMesh(const ref<multi_mesh>& mesh)
{
	if (dxContext.featureSupport.raytracing())
	{
		raytracing_blas_builder blasBuilder;
		std::vector<ref<pbr_material>> raytracingMaterials;

		for (auto& sm : mesh->submeshes)
		{
			blasBuilder.push(mesh->mesh.vertexBuffer, mesh->mesh.indexBuffer, sm.info);
			raytracingMaterials.push_back(sm.material);
		}

		ref<raytracing_blas> blas = blasBuilder.finish();
		raytracing_object_type type = pbr_raytracer::defineObjectType(blas, raytracingMaterials);
		return type;
	}
	else
	{
		return {};
	}
}

static void addRaytracingComponentAsync(scene_entity entity, ref<multi_mesh> mesh)
{
	struct add_ray_tracing_data
	{
		scene_entity entity;
		ref<multi_mesh> mesh;
	};

	add_ray_tracing_data data = { entity, mesh };

	lowPriorityJobQueue.createJob<add_ray_tracing_data>([](add_ray_tracing_data& data, job_handle)
	{
		struct create_component_data
		{
			scene_entity entity;
			raytracing_object_type blas;
		};

		create_component_data createData = { data.entity, defineBlasFromMesh(data.mesh) };

		mainThreadJobQueue.createJob<create_component_data>([](create_component_data& data, job_handle)
		{
			data.entity.addComponent<raytrace_component>(data.blas);
		}, createData).submitNow();

	}, data).submitAfter(mesh->loadJob);
}

static void initializeAnimationComponentAsync(scene_entity entity, ref<multi_mesh> mesh)
{
	struct add_animation_data
	{
		scene_entity entity;
		ref<multi_mesh> mesh;
	};

	add_animation_data data = { entity, mesh };

	mainThreadJobQueue.createJob<add_animation_data>([](add_animation_data& data, job_handle job)
	{
		data.entity.getComponent<animation_component>().animation.set(&data.mesh->skeleton.clips[0]);
	}, data).submitAfter(mesh->loadJob);
}

void application::loadCustomShaders()
{
	if (dxContext.featureSupport.meshShaders())
	{
		initializeMeshShader();
	}
}

void application::initialize(main_renderer* renderer, editor_panels* editorPanels)
{
	this->renderer = renderer;

	if (dxContext.featureSupport.raytracing())
	{
		raytracingTLAS.initialize();
	}

	scene.camera.initializeIngame(vec3(0.f, 1.f, 5.f), quat::identity, deg2rad(70.f), 0.1f);
	scene.environment.setFromTexture("assets/sky/sunset_in_the_chalk_quarry_4k.hdr");
	scene.environment.lightProbeGrid.initialize(vec3(-20.f, -1.f, -20.f), vec3(40.f, 20.f, 40.f), 1.5f);

	editor.initialize(&this->scene, renderer, editorPanels);

	game_scene& scene = this->scene.getCurrentScene();

#if 1
	if (auto mesh = loadMeshFromFile("assets/sponza/sponza.obj"))
	{
		auto blas = defineBlasFromMesh(mesh);

		auto sponza = scene.createEntity("Sponza")
			.addComponent<transform_component>(vec3(0.f, 0.f, 0.f), quat::identity, 0.01f)
			.addComponent<mesh_component>(mesh)
			.addComponent<raytrace_component>(blas);
	}
#endif

	/*if (auto mesh = loadAnimatedMeshFromFileAsync("assets/stormtrooper/stormtrooper.fbx"))
	{
		auto stormtrooper = scene.createEntity("Stormtrooper 1")
			.addComponent<transform_component>(vec3(-5.f, 0.f, -1.f), quat::identity)
			.addComponent<mesh_component>(mesh)
			.addComponent<animation_component>()
			.addComponent<dynamic_transform_component>();

		initializeAnimationComponentAsync(stormtrooper, mesh);
	}

	if (auto mesh = loadAnimatedMeshFromFileAsync("assets/pilot/pilot.fbx"))
	{
		auto pilot = scene.createEntity("Pilot")
			.addComponent<transform_component>(vec3(2.5f, 0.f, -1.f), quat::identity, 0.2f)
			.addComponent<mesh_component>(mesh)
			.addComponent<animation_component>()
			.addComponent<dynamic_transform_component>();

		initializeAnimationComponentAsync(pilot, mesh);
	}

#if 1
	if (auto treeMesh = loadTreeMeshFromFileAsync("assets/tree/chestnut/chestnut.fbx"))
	{
		auto tree = scene.createEntity("Chestnut")
			.addComponent<transform_component>(vec3(2.5f, 0.f, -1.f), quat::identity, 0.2f)
			.addComponent<mesh_component>(treeMesh)
			.addComponent<tree_component>();
	}
#endif*/


#if 1
	{
		auto woodMaterial = createPBRMaterialAsync({ "assets/desert/textures/WoodenCrate2_Albedo.png", "assets/desert/textures/WoodenCrate2_Normal.png" });

		mesh_builder builder;

		auto sphereMesh = make_ref<multi_mesh>();
		builder.pushSphere({ });
		sphereMesh->submeshes.push_back({ builder.endSubmesh(), {}, trs::identity, woodMaterial });

		auto boxMesh = make_ref<multi_mesh>();
		builder.pushBox({ vec3(0.f), vec3(1.f, 1.f, 2.f) });
		boxMesh->submeshes.push_back({ builder.endSubmesh(), {}, trs::identity, woodMaterial });


		pbr_material_desc lollipopMaterialDesc;
		lollipopMaterialDesc.albedo = "assets/cc0/sphere/Tiles074_2K_Color.jpg";
		lollipopMaterialDesc.normal = "assets/cc0/sphere/Tiles074_2K_Normal.jpg";
		lollipopMaterialDesc.roughness = "assets/cc0/sphere/Tiles074_2K_Roughness.jpg";
		lollipopMaterialDesc.uvScale = 3.f;

		auto lollipopMaterial = createPBRMaterialAsync(lollipopMaterialDesc);

		auto groundMesh = make_ref<multi_mesh>();
		builder.pushBox({ vec3(0.f), vec3(30.f, 4.f, 30.f) });
		groundMesh->submeshes.push_back({ builder.endSubmesh(), {}, trs::identity, lollipopMaterial });

		random_number_generator rng = { 15681923 };
		for (uint32 i = 0; i < 3; ++i)
		{
			//float x = rng.randomFloatBetween(-90.f, 90.f);
			//float z = rng.randomFloatBetween(-90.f, 90.f);
			//float y = rng.randomFloatBetween(20.f, 60.f);

			//if (i % 2 == 0)
			//{
			//	scene.createEntity("Cube")
			//		.addComponent<transform_component>(vec3(25.f, 10.f + i * 3.f, -5.f), quat(vec3(0.f, 0.f, 1.f), deg2rad(1.f)))
			//		.addComponent<mesh_component>(boxMesh)
			//		.addComponent<collider_component>(collider_component::asAABB(bounding_box::fromCenterRadius(vec3(0.f, 0.f, 0.f), vec3(1.f, 1.f, 2.f)), { physics_material_type_wood, 0.1f, 0.5f, 1.f }))
			//		.addComponent<rigid_body_component>(false, 1.f);
			//}
			//else
			{
				scene.createEntity("Sphere")
					.addComponent<transform_component>(vec3(25.f, 10.f + i * 3.f, -5.f), quat(vec3(0.f, 0.f, 1.f), deg2rad(1.f)), vec3(1.f))
					.addComponent<mesh_component>(sphereMesh)
					.addComponent<collider_component>(collider_component::asSphere({ vec3(0.f, 0.f, 0.f), 1.f }, { physics_material_type_wood, 0.1f, 0.5f, 1.f }))
					.addComponent<rigid_body_component>(false, 1.f);
			}
		}

		auto triggerCallback = [scene = &scene](trigger_event e)
		{
			//scene->deleteEntity(e.other);
			//std::cout << ((e.type == trigger_event_enter) ? "Enter" : "Leave") << '\n';
		};

		scene.createEntity("Trigger")
			.addComponent<collider_component>(collider_component::asAABB(bounding_box::fromCenterRadius(vec3(25.f, 1.f, -5.f), vec3(5.f, 1.f, 5.f)), { physics_material_type_none, 0, 0, 0 }))
			.addComponent<trigger_component>(triggerCallback);

#if 1
		editor.physicsSettings.collisionBeginCallback = [rng = random_number_generator{ 519431 }](const collision_begin_event& e) mutable
		{
			float speed = length(e.relativeVelocity);

			sound_settings settings;
			settings.pitch = rng.randomFloatBetween(0.5f, 1.5f);
			settings.volume = saturate(remap(speed, 0.2f, 20.f, 0.f, 1.f));

			play3DSound(SOUND_ID("Collision"), e.position, settings);
		};

		//editor.physicsSettings.collisionEndCallback = [](const collision_end_event& e) mutable
		//{
		//};
#endif


		scene.createEntity("Platform")
			.addComponent<transform_component>(vec3(10, -4.f, 0.f), quat(vec3(1.f, 0.f, 0.f), deg2rad(0.f)))
			.addComponent<mesh_component>(groundMesh)
			.addComponent<collider_component>(collider_component::asAABB(bounding_box::fromCenterRadius(vec3(0.f, 0.f, 0.f), vec3(30.f, 4.f, 30.f)), { physics_material_type_metal, 0.1f, 1.f, 4.f }));


		auto chainMesh = make_ref<multi_mesh>();
#if 0
		builder.pushCapsule(capsule_mesh_desc(vec3(0.f, -1.f, 0.f), vec3(0.f, 1.f, 0.f), 0.18f));
		chainMesh->submeshes.push_back({ builder.endSubmesh(), {}, trs::identity, lollipopMaterial });

		auto fixed = scene.createEntity("Fixed")
			.addComponent<transform_component>(vec3(37.f, 15.f, -2.f), quat(vec3(0.f, 0.f, 1.f), deg2rad(90.f)))
			.addComponent<mesh_component>(chainMesh)
			.addComponent<collider_component>(collider_component::asCapsule({ vec3(0.f, -1.f, 0.f), vec3(0.f, 1.f, 0.f), 0.18f }, { 0.2f, 0.5f, 1.f }))
			.addComponent<rigid_body_component>(true, 1.f);

		//fixed.getComponent<rigid_body_component>().angularVelocity = vec3(0.f, 0.1f, 0.f);
		//fixed.getComponent<rigid_body_component>().angularDamping = 0.f;

		auto prev = fixed;

		for (uint32 i = 0; i < 10; ++i)
		{
			float xPrev = 37.f + 2.5f * i;
			float xCurr = 37.f + 2.5f * (i + 1);

			auto chain = scene.createEntity("Chain")
				.addComponent<transform_component>(vec3(xCurr, 15.f, -2.f), quat(vec3(0.f, 0.f, 1.f), deg2rad(90.f)))
				.addComponent<mesh_component>(chainMesh)
				.addComponent<collider_component>(collider_component::asCapsule({ vec3(0.f, -1.f, 0.f), vec3(0.f, 1.f, 0.f), 0.18f }, { 0.2f, 0.5f, 1.f }))
				.addComponent<rigid_body_component>(false, 1.f);

			//addHingeConstraintFromGlobalPoints(prev, chain, vec3(xPrev + 1.18f, 15.f, -2.f), vec3(0.f, 0.f, 1.f), deg2rad(5.f), deg2rad(20.f));
			addConeTwistConstraintFromGlobalPoints(prev, chain, vec3(xPrev + 1.18f, 15.f, -2.f), vec3(1.f, 0.f, 0.f), deg2rad(20.f), deg2rad(30.f));

			prev = chain;
		}
#endif


		groundMesh->mesh =
			boxMesh->mesh =
			sphereMesh->mesh =
			chainMesh->mesh =
			builder.createDXMesh();
	}
#endif




#if 1
	{
		auto sphereMesh = make_ref<multi_mesh>();
		auto boxMesh = make_ref<multi_mesh>();

		{
			mesh_builder builder;
			builder.pushSphere({ });
			sphereMesh->submeshes.push_back({ builder.endSubmesh(), {}, trs::identity });
			sphereMesh->mesh = builder.createDXMesh();
		}
		{
			mesh_builder builder;
			builder.pushBox({ vec3(0.f), vec3(1.f, 1.f, 2.f) });
			boxMesh->submeshes.push_back({ builder.endSubmesh(), {}, trs::identity });
			boxMesh->mesh = builder.createDXMesh();
		}

		uint32 numTerrainChunks = 10;
		float terrainChunkSize = 64.f;


		pbr_material_desc terrainGroundDesc;
		terrainGroundDesc.albedo = "assets/terrain/ground/Grass002_2K_Color.png";
		terrainGroundDesc.normal = "assets/terrain/ground/Grass002_2K_NormalDX.png";
		terrainGroundDesc.roughness = "assets/terrain/ground/Grass002_2K_Roughness.png";
		terrainGroundDesc.albedoFlags &= ~image_load_flags_compress;

		pbr_material_desc terrainRockDesc;
		terrainRockDesc.albedo = "assets/terrain/rock/Rock034_2K_Color.png";
		terrainRockDesc.normal = "assets/terrain/rock/Rock034_2K_NormalDX.png";
		terrainRockDesc.roughness = "assets/terrain/rock/Rock034_2K_Roughness.png";

		pbr_material_desc terrainMudDesc;
		terrainMudDesc.albedo = "assets/terrain/mud/Ground049B_2K_Color.png";
		terrainMudDesc.normal = "assets/terrain/mud/Ground049B_2K_NormalDX.png";
		terrainMudDesc.roughness = "assets/terrain/mud/Ground049B_2K_Roughness.png";


		auto terrainGroundMaterial = createPBRMaterialAsync(terrainGroundDesc);
		auto terrainRockMaterial = createPBRMaterialAsync(terrainRockDesc);
		auto terrainMudMaterial = createPBRMaterialAsync(terrainMudDesc);

		//std::vector<proc_placement_layer_desc> layers =
		//{
		//	proc_placement_layer_desc {
		//		"Trees and rocks",
		//		5.f,
		//		{ 
		//			loadMeshFromFile("assets/hoewa/hoewa1.fbx"), 
		//			loadMeshFromFile("assets/hoewa/hoewa2.fbx"),
		//			loadMeshFromFile("assets/desert/rock1.fbx"),
		//			loadMeshFromFile("assets/desert/rock4.fbx"),
		//		}
		//	}
		//};

		auto terrain = scene.createEntity("Terrain")
			.addComponent<position_component>(vec3(0.f, -64.f, 0.f))
			.addComponent<terrain_component>(numTerrainChunks, terrainChunkSize, 50.f, terrainGroundMaterial, terrainRockMaterial, terrainMudMaterial)
			.addComponent<heightmap_collider_component>(numTerrainChunks, terrainChunkSize, physics_material{ physics_material_type_metal, 0.1f, 1.f, 4.f })
			//.addComponent<proc_placement_component>(layers) // TODO: This could be deferred if we want to load the meshes asynchronously.
			.addComponent<grass_component>()
			;

		auto water = scene.createEntity("Water")
			.addComponent<position_scale_component>(vec3(-3.920f, -48.689f, -85.580f), vec3(90.f))
			.addComponent<water_component>();
	}
#endif




	random_number_generator rng = { 14878213 };

	this->scene.sun.direction = normalize(vec3(-0.6f, -1.f, -0.3f));
	this->scene.sun.color = vec3(1.f, 0.93f, 0.76f);
	this->scene.sun.intensity = 6.f;

	this->scene.sun.numShadowCascades = 3;
	this->scene.sun.shadowDimensions = 2048;
	this->scene.sun.cascadeDistances = vec4(9.f, 25.f, 50.f, 10000.f);
	this->scene.sun.bias = vec4(0.000588f, 0.000784f, 0.000824f, 0.0035f);
	this->scene.sun.blendDistances = vec4(5.f, 10.f, 10.f, 10.f);
	this->scene.sun.stabilize = true;

	for (uint32 i = 0; i < NUM_BUFFERED_FRAMES; ++i)
	{
		pointLightBuffer[i] = createUploadBuffer(sizeof(point_light_cb), 512, 0);
		spotLightBuffer[i] = createUploadBuffer(sizeof(spot_light_cb), 512, 0);
		decalBuffer[i] = createUploadBuffer(sizeof(pbr_decal_cb), 512, 0);

		spotLightShadowInfoBuffer[i] = createUploadBuffer(sizeof(spot_shadow_info), 512, 0);
		pointLightShadowInfoBuffer[i] = createUploadBuffer(sizeof(point_shadow_info), 512, 0);

		SET_NAME(pointLightBuffer[i]->resource, "Point lights");
		SET_NAME(spotLightBuffer[i]->resource, "Spot lights");
		SET_NAME(decalBuffer[i]->resource, "Decals");

		SET_NAME(spotLightShadowInfoBuffer[i]->resource, "Spot light shadow infos");
		SET_NAME(pointLightShadowInfoBuffer[i]->resource, "Point light shadow infos");
	}

#if 0
	fireParticleSystem.initialize(10000, 50.f, "assets/particles/fire_explosion.tif", 6, 6);
	smokeParticleSystem.initialize(10000, 500.f, "assets/particles/smoke1.tif", 5, 5);
	boidParticleSystem.initialize(10000, 2000.f);
	debrisParticleSystem.initialize(10000);
#endif

	stackArena.initialize();
}

#if 0
static bool editFireParticleSystem(fire_particle_system& particleSystem)
{
	bool result = false;
	if (ImGui::BeginTree("Fire particles"))
	{
		if (ImGui::BeginProperties())
		{
			result |= ImGui::PropertySlider("Emit rate", particleSystem.emitRate, 0.f, 1000.f);
			ImGui::EndProperties();
		}

		result |= ImGui::Spline("Size over lifetime", ImVec2(200, 200), particleSystem.settings.sizeOverLifetime);
		ImGui::Separator();
		result |= ImGui::Spline("Atlas progression over lifetime", ImVec2(200, 200), particleSystem.settings.atlasProgressionOverLifetime);
		ImGui::Separator();
		result |= ImGui::Spline("Intensity over lifetime", ImVec2(200, 200), particleSystem.settings.intensityOverLifetime);

		ImGui::EndTree();
	}
	return result;
}

static bool editBoidParticleSystem(boid_particle_system& particleSystem)
{
	bool result = false;
	if (ImGui::BeginTree("Boid particles"))
	{
		if (ImGui::BeginProperties())
		{
			result |= ImGui::PropertySlider("Emit rate", particleSystem.emitRate, 0.f, 5000.f);
			result |= ImGui::PropertySlider("Emit radius", particleSystem.settings.radius, 5.f, 100.f);
			ImGui::EndProperties();
		}

		ImGui::EndTree();
	}
	return result;
}
#endif

void application::resetRenderPasses()
{
	opaqueRenderPass.reset();
	transparentRenderPass.reset();
	ldrRenderPass.reset();
	sunShadowRenderPass.reset();
	computePass.reset();

	for (uint32 i = 0; i < arraysize(spotShadowRenderPasses); ++i)
	{
		spotShadowRenderPasses[i].reset();
	}

	for (uint32 i = 0; i < arraysize(pointShadowRenderPasses); ++i)
	{
		pointShadowRenderPasses[i].reset();
	}
}

void application::submitRendererParams(uint32 numSpotLightShadowPasses, uint32 numPointLightShadowPasses)
{
	{
		CPU_PROFILE_BLOCK("Sort render passes");

		opaqueRenderPass.sort();
		transparentRenderPass.sort();
		ldrRenderPass.sort();

		for (uint32 i = 0; i < sunShadowRenderPass.numCascades; ++i)
		{
			sunShadowRenderPass.cascades[i].sort();
		}

		for (uint32 i = 0; i < numSpotLightShadowPasses; ++i)
		{
			spotShadowRenderPasses[i].sort();
		}

		for (uint32 i = 0; i < numPointLightShadowPasses; ++i)
		{
			pointShadowRenderPasses[i].sort();
		}
	}

	renderer->submitRenderPass(&opaqueRenderPass);
	renderer->submitRenderPass(&transparentRenderPass);
	renderer->submitRenderPass(&ldrRenderPass);
	renderer->submitComputePass(&computePass);

	renderer->submitShadowRenderPass(&sunShadowRenderPass);

	for (uint32 i = 0; i < numSpotLightShadowPasses; ++i)
	{
		renderer->submitShadowRenderPass(&spotShadowRenderPasses[i]);
	}

	for (uint32 i = 0; i < numPointLightShadowPasses; ++i)
	{
		renderer->submitShadowRenderPass(&pointShadowRenderPasses[i]);
	}
}

void application::update(const user_input& input, float dt)
{
	resetRenderPasses();

	stackArena.reset();

	//learnedLocomotion.update(scene);

	bool objectDragged = editor.update(input, &ldrRenderPass, dt);



	render_camera& camera = scene.camera;
	directional_light& sun = scene.sun;
	pbr_environment& environment = scene.environment;

	environment.update(sun.direction);
	sun.updateMatrices(camera);
	setAudioListener(camera.position, camera.rotation, vec3(0.f));
	environment.lightProbeGrid.visualize(&opaqueRenderPass);


	game_scene& scene = this->scene.getCurrentScene();
	float unscaledDt = dt;
	dt *= this->scene.getTimestepScale();


	// Must happen before physics update.
	for (auto [entityHandle, terrain, position] : scene.group(component_group<terrain_component, position_component>).each())
	{
		scene_entity entity = { entityHandle, scene };
		heightmap_collider_component* collider = entity.getComponentIfExists<heightmap_collider_component>();

		terrain.update(position.position, collider);
	}


	static float physicsTimer = 0.f;
	physicsStep(scene, stackArena, physicsTimer, editor.physicsSettings, dt);


	// Particles.

#if 0
	if (input.keyboard['T'].pressEvent)
	{
		debrisParticleSystem.burst(camera.position + camera.rotation * vec3(0.f, 0.f, -3.f));
	}

	computePass.dt = dt;
	computePass.updateParticleSystem(&boidParticleSystem);
	computePass.updateParticleSystem(&fireParticleSystem);
	computePass.updateParticleSystem(&smokeParticleSystem);
	computePass.updateParticleSystem(&debrisParticleSystem);

	boidParticleSystem.render(&transparentRenderPass);
	fireParticleSystem.render(&transparentRenderPass);
	smokeParticleSystem.render(&transparentRenderPass);
	debrisParticleSystem.render(&transparentRenderPass);

#endif


	scene_entity selectedEntity = editor.selectedEntity;

	if (renderer->mode != renderer_mode_pathtraced)
	{
		if (dxContext.featureSupport.meshShaders())
		{
			testRenderMeshShader(&transparentRenderPass, dt);
		}

		// Update animated meshes.
		for (auto [entityHandle, anim, mesh, transform] : scene.group(component_group<animation_component, mesh_component, transform_component>).each())
		{
			anim.update(mesh.mesh, stackArena, dt, &transform);
		}

		for (auto [entityHandle, anim, raster, transform] : scene.group(component_group<animation_component, mesh_component, transform_component>).each())
		{
			anim.drawCurrentSkeleton(raster.mesh, transform, &ldrRenderPass);
		}


		scene_lighting lighting;
		lighting.spotLightBuffer = spotLightBuffer[dxContext.bufferedFrameID];
		lighting.pointLightBuffer = pointLightBuffer[dxContext.bufferedFrameID];
		lighting.spotLightShadowInfoBuffer = spotLightShadowInfoBuffer[dxContext.bufferedFrameID];
		lighting.pointLightShadowInfoBuffer = pointLightShadowInfoBuffer[dxContext.bufferedFrameID];
		lighting.spotShadowRenderPasses = spotShadowRenderPasses;
		lighting.pointShadowRenderPasses = pointShadowRenderPasses;
		lighting.maxNumSpotShadowRenderPasses = arraysize(spotShadowRenderPasses);
		lighting.maxNumPointShadowRenderPasses = arraysize(pointShadowRenderPasses);


		renderScene(this->scene.camera, scene, stackArena, selectedEntity.handle, sun, lighting, objectDragged, 
			&opaqueRenderPass, &transparentRenderPass, &ldrRenderPass, &sunShadowRenderPass, &computePass, unscaledDt);

		renderer->setSpotLights(spotLightBuffer[dxContext.bufferedFrameID], scene.numberOfComponentsOfType<spot_light_component>(), spotLightShadowInfoBuffer[dxContext.bufferedFrameID]);
		renderer->setPointLights(pointLightBuffer[dxContext.bufferedFrameID], scene.numberOfComponentsOfType<point_light_component>(), pointLightShadowInfoBuffer[dxContext.bufferedFrameID]);


		if (decals.size())
		{
			updateUploadBufferData(decalBuffer[dxContext.bufferedFrameID], decals.data(), (uint32)(sizeof(pbr_decal_cb) * decals.size()));
			renderer->setDecals(decalBuffer[dxContext.bufferedFrameID], (uint32)decals.size(), decalTexture);
		}

		if (selectedEntity)
		{
			if (point_light_component* pl = selectedEntity.getComponentIfExists<point_light_component>())
			{
				position_component& pc = selectedEntity.getComponent<position_component>();

				renderWireSphere(pc.position, pl->radius, vec4(pl->color, 1.f), &ldrRenderPass);
			}
			else if (spot_light_component* sl = selectedEntity.getComponentIfExists<spot_light_component>())
			{
				position_rotation_component& prc = selectedEntity.getComponent<position_rotation_component>();

				renderWireCone(prc.position, prc.rotation * vec3(0.f, 0.f, -1.f),
					sl->distance, sl->outerAngle * 2.f, vec4(sl->color, 1.f), &ldrRenderPass);
			}
		}

		submitRendererParams(lighting.numSpotShadowRenderPasses, lighting.numPointShadowRenderPasses);
	}

	for (auto [entityHandle, transform, dynamic] : scene.group(component_group<transform_component, dynamic_transform_component>).each())
	{
		dynamic = transform;
	}

	performSkinning(&computePass);




	if (dxContext.featureSupport.raytracing())
	{
		raytracingTLAS.reset();

		for (auto [entityHandle, transform, raytrace] : scene.group(component_group<transform_component, raytrace_component>).each())
		{
			raytracingTLAS.instantiate(raytrace.type, transform);
		}

		renderer->setRaytracingScene(&raytracingTLAS);
	}

	renderer->setEnvironment(environment);
	renderer->setSun(sun);
	renderer->setCamera(camera);

	executeMainThreadJobs();
}

void application::handleFileDrop(const fs::path& filename)
{
	fs::path path = filename;
	fs::path relative = fs::relative(path, fs::current_path());
	fs::path ext = relative.extension();

	if (isMeshExtension(ext))
	{
		if (auto mesh = loadMeshFromFile(relative.string()))
		{
			fs::path path = filename;
			path = path.stem();

			scene.getCurrentScene().createEntity(path.string().c_str())
				.addComponent<transform_component>(vec3(0.f), quat::identity)
				.addComponent<mesh_component>(mesh);
		}
	}
	else if (ext == ".hdr")
	{
		scene.environment.setFromTexture(relative);
	}
}

```

`src/application.h`:

```h
#pragma once

#include "core/input.h"
#include "core/camera.h"
#include "core/camera_controller.h"
#include "geometry/mesh.h"
#include "core/math.h"
#include "scene/scene.h"
#include "rendering/main_renderer.h"
#include "particles/fire_particle_system.h"
#include "particles/smoke_particle_system.h"
#include "particles/boid_particle_system.h"
#include "particles/debris_particle_system.h"
#include "rendering/raytracing.h"
#include "editor/editor.h"
#include "learning/learned_locomotion.h"




struct application
{
	void loadCustomShaders();
	void initialize(main_renderer* renderer, editor_panels* editorPanels);
	void update(const user_input& input, float dt);

	void handleFileDrop(const fs::path& filename);

private:

	void resetRenderPasses();
	void submitRendererParams(uint32 numSpotLightShadowPasses, uint32 numPointLightShadowPasses);


	raytracing_tlas raytracingTLAS;



	ref<dx_buffer> pointLightBuffer[NUM_BUFFERED_FRAMES];
	ref<dx_buffer> spotLightBuffer[NUM_BUFFERED_FRAMES];
	ref<dx_buffer> decalBuffer[NUM_BUFFERED_FRAMES];

	ref<dx_buffer> spotLightShadowInfoBuffer[NUM_BUFFERED_FRAMES];
	ref<dx_buffer> pointLightShadowInfoBuffer[NUM_BUFFERED_FRAMES];

	std::vector<pbr_decal_cb> decals;

	ref<dx_texture> decalTexture;

	fire_particle_system fireParticleSystem;
	smoke_particle_system smokeParticleSystem;
	boid_particle_system boidParticleSystem;
	debris_particle_system debrisParticleSystem;

	main_renderer* renderer;

	editor_scene scene;
	scene_editor editor;

	memory_arena stackArena;

	learned_locomotion learnedLocomotion;


	opaque_render_pass opaqueRenderPass;
	transparent_render_pass transparentRenderPass;
	sun_shadow_render_pass sunShadowRenderPass;
	spot_shadow_render_pass spotShadowRenderPasses[16];
	point_shadow_render_pass pointShadowRenderPasses[16];
	ldr_render_pass ldrRenderPass;
	compute_pass computePass;


};

```

`src/asset/asset.cpp`:

```cpp
#include "pch.h"
#include "asset.h"
#include "core/random.h"

static random_number_generator rng = time(0);

asset_handle asset_handle::generate()
{
	return asset_handle(rng.randomUint64());
}

```

`src/asset/asset.h`:

```h
#pragma once

#include "core/hash.h"

struct asset_handle
{
	asset_handle() : value(0) {}
	asset_handle(uint64 value) : value(value) {}

	static asset_handle generate();

	operator bool() { return value != 0; }

	uint64 value;
};

inline bool operator==(asset_handle a, asset_handle b)
{
	return a.value == b.value;
}

namespace std
{
	template<>
	struct hash<asset_handle>
	{
		size_t operator()(const asset_handle& x) const
		{
			return std::hash<uint64>()(x.value);
		}
	};
}


enum asset_load_state
{
	asset_unloaded,
	asset_loading,
	asset_loaded,

	asset_load_state_count,
};

static const char* assetLoadStateNames[] =
{
	"Unloaded",
	"Loading",
	"Loaded",
};


```

`src/asset/bin.cpp`:

```cpp
#include "pch.h"
#include "model_asset.h"
#include "io.h"

#include "core/cpu_profiling.h"

//#define PROFILE(name) CPU_PRINT_PROFILE_BLOCK(name)
#define PROFILE(name) 

static const uint32 BIN_HEADER = 'BIN ';

struct bin_header
{
	uint32 header = BIN_HEADER;
	uint32 version = 1;
	uint32 flags;
	uint32 numMeshes;
	uint32 numMaterials;
	uint32 numSkeletons;
	uint32 numAnimations;
};

struct bin_mesh_header
{
	uint32 numSubmeshes;
	int32 skeletonIndex;
	uint32 nameLength;
};

enum bin_submesh_flag
{
	bin_submesh_flag_positions = (1 << 0),
	bin_submesh_flag_uvs = (1 << 1),
	bin_submesh_flag_normals = (1 << 2),
	bin_submesh_flag_tangents = (1 << 3),
	bin_submesh_flag_colors = (1 << 4),
	bin_submesh_flag_skin = (1 << 5),
};

struct bin_submesh_header
{
	uint32 numVertices;
	uint32 numTriangles;
	int32 materialIndex;
	uint32 flags;
};

struct bin_material_header
{
	uint32 albedoPathLength;
	uint32 normalPathLength;
	uint32 roughnessPathLength;
	uint32 metallicPathLength;
};

struct bin_skeleton_header
{
	uint32 numJoints;
};

struct bin_animation_header
{
	float duration;
	uint32 numJoints;
	uint32 numPositionKeyframes;
	uint32 numRotationKeyframes;
	uint32 numScaleKeyframes;

	uint32 nameLength;
};





template <typename T>
static void writeArray(const std::vector<T>& in, FILE* file)
{
	fwrite(in.data(), sizeof(T), in.size(), file);
}

static void writeMesh(const mesh_asset& mesh, FILE* file)
{
	bin_mesh_header header;
	header.skeletonIndex = mesh.skeletonIndex;
	header.numSubmeshes = (uint32)mesh.submeshes.size();
	header.nameLength = (uint32)mesh.name.length();

	fwrite(&header, sizeof(header), 1, file);
	fwrite(mesh.name.c_str(), sizeof(char), header.nameLength, file);

	for (uint32 i = 0; i < header.numSubmeshes; ++i)
	{
		const submesh_asset& in = mesh.submeshes[i];

		bin_submesh_header subHeader;
		subHeader.materialIndex = in.materialIndex;
		subHeader.numVertices = (uint32)in.positions.size();
		subHeader.numTriangles = (uint32)in.triangles.size();

		subHeader.flags = 0;
		if (!in.positions.empty()) { subHeader.flags |= bin_submesh_flag_positions; }
		if (!in.uvs.empty()) { subHeader.flags |= bin_submesh_flag_uvs; }
		if (!in.normals.empty()) { subHeader.flags |= bin_submesh_flag_normals; }
		if (!in.tangents.empty()) { subHeader.flags |= bin_submesh_flag_tangents; }
		if (!in.colors.empty()) { subHeader.flags |= bin_submesh_flag_colors; }
		if (!in.skin.empty()) { subHeader.flags |= bin_submesh_flag_skin; }

		fwrite(&subHeader, sizeof(bin_submesh_header), 1, file);

		if (!in.positions.empty()) { writeArray(in.positions, file); }
		if (!in.uvs.empty()) { writeArray(in.uvs, file); }
		if (!in.normals.empty()) { writeArray(in.normals, file); }
		if (!in.tangents.empty()) { writeArray(in.tangents, file); }
		if (!in.colors.empty()) { writeArray(in.colors, file); }
		if (!in.skin.empty()) { writeArray(in.skin, file); }
		writeArray(in.triangles, file);
	}
}

static void writeMaterial(const pbr_material_desc& material, FILE* file)
{
	std::string albedo = material.albedo.string();
	std::string normal = material.normal.string();
	std::string roughness = material.roughness.string();
	std::string metallic = material.metallic.string();

	bin_material_header header;
	header.albedoPathLength = (uint32)albedo.length();
	header.normalPathLength = (uint32)normal.length();
	header.roughnessPathLength = (uint32)roughness.length();
	header.metallicPathLength = (uint32)metallic.length();

	fwrite(&header, sizeof(header), 1, file);
	fwrite(albedo.c_str(), sizeof(char), header.albedoPathLength, file);
	fwrite(normal.c_str(), sizeof(char), header.normalPathLength, file);
	fwrite(roughness.c_str(), sizeof(char), header.roughnessPathLength, file);
	fwrite(metallic.c_str(), sizeof(char), header.metallicPathLength, file);

	fwrite(&material.albedoFlags, sizeof(uint32), 1, file);
	fwrite(&material.normalFlags, sizeof(uint32), 1, file);
	fwrite(&material.roughnessFlags, sizeof(uint32), 1, file);
	fwrite(&material.metallicFlags, sizeof(uint32), 1, file);

	fwrite(&material.emission, sizeof(vec4), 1, file);
	fwrite(&material.albedoTint, sizeof(vec4), 1, file);
	fwrite(&material.roughnessOverride, sizeof(float), 1, file);
	fwrite(&material.metallicOverride, sizeof(float), 1, file);
	fwrite(&material.shader, sizeof(pbr_material_shader), 1, file);
	fwrite(&material.uvScale, sizeof(float), 1, file);
	fwrite(&material.translucency, sizeof(float), 1, file);
}

static void writeSkeleton(const skeleton_asset& skeleton, FILE* file)
{
	bin_skeleton_header header;
	header.numJoints = (uint32)skeleton.joints.size();

	fwrite(&header, sizeof(header), 1, file);

	for (uint32 i = 0; i < header.numJoints; ++i)
	{
		uint32 nameLength = (uint32)skeleton.joints[i].name.length();
		fwrite(&nameLength, sizeof(uint32), 1, file);
		fwrite(skeleton.joints[i].name.c_str(), sizeof(char), nameLength, file);
		fwrite(&skeleton.joints[i].limbType, sizeof(limb_type), 1, file);
		fwrite(&skeleton.joints[i].ik, sizeof(bool), 1, file);
		fwrite(&skeleton.joints[i].invBindTransform, sizeof(mat4), 1, file);
		fwrite(&skeleton.joints[i].bindTransform, sizeof(mat4), 1, file);
		fwrite(&skeleton.joints[i].parentID, sizeof(uint32), 1, file);
	}
}

static void writeAnimation(const animation_asset& animation, FILE* file)
{
	bin_animation_header header;
	header.duration = animation.duration;
	header.numJoints = (uint32)animation.joints.size();
	header.numPositionKeyframes = (uint32)animation.positionKeyframes.size();
	header.numRotationKeyframes = (uint32)animation.rotationKeyframes.size();
	header.numScaleKeyframes = (uint32)animation.scaleKeyframes.size();
	header.nameLength = (uint32)animation.name.length();

	fwrite(&header, sizeof(header), 1, file);
	fwrite(animation.name.c_str(), sizeof(char), header.nameLength, file);

	for (auto [name, joint] : animation.joints)
	{
		uint32 nameLength = (uint32)name.length();
		fwrite(&nameLength, sizeof(uint32), 1, file);
		fwrite(name.c_str(), sizeof(char), nameLength, file);

		fwrite(&joint, sizeof(animation_joint), 1, file);
	}

	writeArray(animation.positionTimestamps, file);
	writeArray(animation.rotationTimestamps, file);
	writeArray(animation.scaleTimestamps, file);
	writeArray(animation.positionKeyframes, file);
	writeArray(animation.rotationKeyframes, file);
	writeArray(animation.scaleKeyframes, file);
}

void writeBIN(const model_asset& asset, const fs::path& path)
{
	FILE* file = fopen(path.string().c_str(), "wb");

	bin_header header;
	header.flags = asset.flags;
	header.numMeshes = (uint32)asset.meshes.size();
	header.numMaterials = (uint32)asset.materials.size();
	header.numSkeletons = (uint32)asset.skeletons.size();
	header.numAnimations = (uint32)asset.animations.size();

	fwrite(&header, sizeof(header), 1, file);

	for (uint32 i = 0; i < header.numMeshes; ++i)
	{
		writeMesh(asset.meshes[i], file);
	}
	for (uint32 i = 0; i < header.numMaterials; ++i)
	{
		writeMaterial(asset.materials[i], file);
	}
	for (uint32 i = 0; i < header.numSkeletons; ++i)
	{
		writeSkeleton(asset.skeletons[i], file);
	}
	for (uint32 i = 0; i < header.numAnimations; ++i)
	{
		writeAnimation(asset.animations[i], file);
	}

	fclose(file);
}










template <typename T>
static void readArray(entire_file& file, std::vector<T>& out, uint32 count)
{
	out.resize(count);
	T* ptr = file.consume<T>(count);
	memcpy(out.data(), ptr, sizeof(T) * count);
}

static mesh_asset readMesh(entire_file& file)
{
	bin_mesh_header* header = file.consume<bin_mesh_header>();
	char* name = file.consume<char>(header->nameLength);

	mesh_asset result;
	result.name = std::string(name, header->nameLength);
	result.submeshes.resize(header->numSubmeshes);
	result.skeletonIndex = header->skeletonIndex;

	for (uint32 i = 0; i < header->numSubmeshes; ++i)
	{
		bin_submesh_header* subHeader = file.consume<bin_submesh_header>();

		submesh_asset& sub = result.submeshes[i];
		sub.materialIndex = subHeader->materialIndex;
		if (subHeader->flags & bin_submesh_flag_positions) { readArray(file, sub.positions, subHeader->numVertices); }
		if (subHeader->flags & bin_submesh_flag_uvs) { readArray(file, sub.uvs, subHeader->numVertices); }
		if (subHeader->flags & bin_submesh_flag_normals) { readArray(file, sub.normals, subHeader->numVertices); }
		if (subHeader->flags & bin_submesh_flag_tangents) { readArray(file, sub.tangents, subHeader->numVertices); }
		if (subHeader->flags & bin_submesh_flag_colors) { readArray(file, sub.colors, subHeader->numVertices); }
		if (subHeader->flags & bin_submesh_flag_skin) { readArray(file, sub.skin, subHeader->numVertices); }
		readArray(file, sub.triangles, subHeader->numTriangles);
	}

	return result;
}

static pbr_material_desc readMaterial(entire_file& file)
{
	bin_material_header* header = file.consume<bin_material_header>();

	char* albedo = file.consume<char>(header->albedoPathLength);
	char* normal = file.consume<char>(header->normalPathLength);
	char* roughness = file.consume<char>(header->roughnessPathLength);
	char* metallic = file.consume<char>(header->metallicPathLength);

	pbr_material_desc result;
	result.albedo = std::string(albedo, header->albedoPathLength);
	result.normal = std::string(normal, header->normalPathLength);
	result.roughness = std::string(roughness, header->roughnessPathLength);
	result.metallic = std::string(metallic, header->metallicPathLength);

	result.albedoFlags = *file.consume<uint32>();
	result.normalFlags = *file.consume<uint32>();
	result.roughnessFlags = *file.consume<uint32>();
	result.metallicFlags = *file.consume<uint32>();

	result.emission = *file.consume<vec4>();
	result.albedoTint = *file.consume<vec4>();
	result.roughnessOverride = *file.consume<float>();
	result.metallicOverride = *file.consume<float>();
	result.shader = *file.consume<pbr_material_shader>();
	result.uvScale = *file.consume<float>();
	result.translucency = *file.consume<float>();

	return result;
}

static skeleton_asset readSkeleton(entire_file& file)
{
	bin_skeleton_header* header = file.consume<bin_skeleton_header>();
	
	skeleton_asset result;
	result.joints.resize(header->numJoints);
	result.nameToJointID.reserve(header->numJoints);

	for (uint32 i = 0; i < header->numJoints; ++i)
	{
		uint32 nameLength = *file.consume<uint32>();
		char* name = file.consume<char>(nameLength);

		result.joints[i].name = std::string(name, nameLength);
		result.joints[i].limbType = *file.consume<limb_type>();
		result.joints[i].ik = *file.consume<bool>();
		result.joints[i].invBindTransform = *file.consume<mat4>();
		result.joints[i].bindTransform = *file.consume<mat4>();
		result.joints[i].parentID = *file.consume<uint32>();

		result.nameToJointID[result.joints[i].name] = i;
	}

	return result;
}

static animation_asset readAnimation(entire_file& file)
{
	bin_animation_header* header = file.consume<bin_animation_header>();

	animation_asset result;
	result.duration = header->duration;

	char* name = file.consume<char>(header->nameLength);
	result.name = std::string(name, header->nameLength);

	result.joints.reserve(header->numJoints);

	for (uint32 i = 0; i < header->numJoints; ++i)
	{
		uint32 nameLength = *file.consume<uint32>();
		char* name = file.consume<char>(nameLength);

		animation_joint joint = *file.consume<animation_joint>();
		result.joints[std::string(name, nameLength)] = joint;
	}

	readArray(file, result.positionTimestamps, header->numPositionKeyframes);
	readArray(file, result.rotationTimestamps, header->numRotationKeyframes);
	readArray(file, result.scaleTimestamps, header->numScaleKeyframes);
	readArray(file, result.positionKeyframes, header->numPositionKeyframes);
	readArray(file, result.rotationKeyframes, header->numRotationKeyframes);
	readArray(file, result.scaleKeyframes, header->numScaleKeyframes);


	return result;
}

model_asset loadBIN(const fs::path& path)
{
	PROFILE("Loading BIN");

	entire_file file = loadFile(path);

	bin_header* header = file.consume<bin_header>();
	if (header->header != BIN_HEADER)
	{
		freeFile(file);
		return {};
	}

	model_asset result;
	result.meshes.resize(header->numMeshes);
	result.materials.resize(header->numMaterials);
	result.skeletons.resize(header->numSkeletons);
	result.animations.resize(header->numAnimations);

	for (uint32 i = 0; i < header->numMeshes; ++i)
	{
		result.meshes[i] = readMesh(file);
	}
	for (uint32 i = 0; i < header->numMaterials; ++i)
	{
		result.materials[i] = readMaterial(file);
	}
	for (uint32 i = 0; i < header->numSkeletons; ++i)
	{
		result.skeletons[i] = readSkeleton(file);
	}
	for (uint32 i = 0; i < header->numAnimations; ++i)
	{
		result.animations[i] = readAnimation(file);
	}

	freeFile(file);

	return result;
}

```

`src/asset/deflate.cpp`:

```cpp
#include "pch.h"
#include "deflate.h"


struct bit_stream
{
	uint8* data;
	uint64 size;
	uint64 readOffset;

	uint32 bitCount;
	uint32 bitBuffer;


	template <typename T>
	T* consume(uint32 count = 1)
	{
		T* result = (T*)(data + readOffset);
		readOffset += sizeof(T) * count;
		ASSERT(readOffset <= size);
		return result;
	}

	uint32 peekBits(uint32 bitCount)
	{
		ASSERT(bitCount <= 32);

		uint32 result = 0;

		while ((this->bitCount < bitCount))
		{
			uint32 byte = *consume<uint8>();
			this->bitBuffer |= (byte << this->bitCount);
			this->bitCount += 8;
		}

		result = this->bitBuffer & ((1 << bitCount) - 1);

		return result;
	}

	void discardBits(uint32 bitCount)
	{
		this->bitCount -= bitCount;
		this->bitBuffer >>= bitCount;
	}

	uint32 consumeBits(uint32 bitCount)
	{
		uint32 result = peekBits(bitCount);
		discardBits(bitCount);
		return result;
	}

	void flushByte()
	{
		uint32 flushCount = (bitCount % 8);
		consumeBits(flushCount);
	}

	uint64 bytesRemaining()
	{
		return size - readOffset;
	}
};

static uint32 reverseBits(uint32 value, uint32 bitCount)
{
	uint32 result = 0;

	for (uint32 i = 0; i <= (bitCount / 2); ++i)
	{
		uint32 inv = (bitCount - (i + 1));
		result |= ((value >> i) & 0x1) << inv;
		result |= ((value >> inv) & 0x1) << i;
	}

	return result;
}



struct huffman_entry
{
	uint16 symbol;
	uint16 codeLength;
};

struct huffman_table
{
	uint32 maxCodeLengthInBits;
	std::vector<huffman_entry> entries;

	void initialize(uint32 maxCodeLengthInBits, uint32* symbolLengths, uint32 numSymbols, uint32 symbolOffset = 0)
	{
		ASSERT(maxCodeLengthInBits <= 16);

		this->maxCodeLengthInBits = maxCodeLengthInBits;
		uint32 entryCount = (1 << maxCodeLengthInBits);
		this->entries.resize(entryCount);


		uint32 blCount[16] = {};
		for (uint32 i = 0; i < numSymbols; ++i)
		{
			uint32 count = symbolLengths[i];
			ASSERT(count < arraysize(blCount));
			++blCount[count];
		}

		uint32 nextCode[16];
		nextCode[0] = 0;
		blCount[0] = 0;
		for (uint32 bits = 1; bits < 16; ++bits)
		{
			nextCode[bits] = ((nextCode[bits - 1] + blCount[bits - 1]) << 1);
		}

		for (uint32 n = 0; n < numSymbols; ++n)
		{
			uint32 len = symbolLengths[n];
			if (len)
			{
				uint32 code = nextCode[len]++;

				uint32 numGarbageBits = maxCodeLengthInBits - len;
				uint32 numEntries = (1 << numGarbageBits);

				for (uint32 i = 0; i < numEntries; ++i)
				{
					uint32 base = (code << numGarbageBits) | i;
					uint32 index = reverseBits(base, maxCodeLengthInBits);

					huffman_entry& entry = entries[index];

					uint32 symbol = n + symbolOffset;
					entry.codeLength = (uint16)len;
					entry.symbol = (uint16)symbol;
				}
			}
		}
	}

	uint32 decode(bit_stream& stream)
	{
		uint32 index = stream.peekBits(maxCodeLengthInBits);
		huffman_entry entry = entries[index];
		stream.discardBits(entry.codeLength);
		return entry.symbol;
	}
};

static huffman_entry lengthExtra[] =
{
	{3, 0}, {4, 0}, {5, 0}, {6, 0}, {7, 0}, {8, 0}, {9, 0}, {10, 0}, {11, 1}, {13, 1}, {15, 1}, {17, 1}, {19, 2},
	{23, 2}, {27, 2}, {31, 2}, {35, 3}, {43, 3}, {51, 3}, {59, 3}, {67, 4}, {83, 4}, {99, 4}, {115, 4}, {131, 5},
	{163, 5}, {195, 5}, {227, 5}, {258, 0}
};

static huffman_entry distExtra[] =
{
	{1, 0}, {2, 0}, {3, 0}, {4, 0}, {5, 1}, {7, 1}, {9, 2}, {13, 2}, {17, 3}, {25, 3}, {33, 4}, {49, 4}, {65, 5},
	{97, 5}, {129, 6}, {193, 6}, {257, 7}, {385, 7}, {513, 8}, {769, 8}, {1025, 9}, {1537, 9}, {2049, 10}, {3073, 10},
	{4097, 11}, {6145, 11}, {8193, 12}, {12289, 12}, {16385, 13}, {24577, 13}
};


uint64 decompress(uint8* data, uint64 compressedSize, uint8* output)
{
	bit_stream stream = { data, compressedSize };

	uint32 zlibHeader0 = *stream.consume<uint8>();
	uint32 zlibHeader1 = *stream.consume<uint8>();
	uint32 counter = (((zlibHeader0 * 256 + zlibHeader1) % 31 != 0) || (zlibHeader1 & 32) || ((zlibHeader0 & 15) != 8));
	ASSERT(counter == 0);

	uint8* outputStart = output;


	uint32 BFINAL = 0;
	while (BFINAL == 0)
	{
		BFINAL = stream.consumeBits(1);
		uint32 BTYPE = stream.consumeBits(2);

		ASSERT(BTYPE != 3);

		if (BTYPE == 0)
		{
			// No compression.
			stream.flushByte();

			uint16 LEN = (uint16)stream.consumeBits(16);
			uint16 NLEN = (uint16)stream.consumeBits(16);
			ASSERT((uint16)LEN == (uint16)~NLEN);

			while (LEN)
			{
				uint16 useLEN = LEN;
				useLEN = (uint16)min((uint64)useLEN, stream.bytesRemaining());

				uint8* source = stream.consume<uint8>(useLEN);
				uint16 copyCount = useLEN;
				while (copyCount--)
				{
					*output++ = *source++;
				}

				LEN -= useLEN;
			}
		}
		else
		{
			uint32 litlen_dist[512];

			uint32 HLIT = 0;
			uint32 HDIST = 0;
			if (BTYPE == 2)
			{
				// Compressed with dynamic Huffman codes.
				HLIT = stream.consumeBits(5) + 257;
				HDIST = stream.consumeBits(5) + 1;
				uint32 HCLEN = stream.consumeBits(4) + 4;

				uint32 HCLENSwizzle[] = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 };
				ASSERT(HCLEN <= arraysize(HCLENSwizzle));
				uint32 HCLENTable[arraysize(HCLENSwizzle)] = {};

				for (uint32 i = 0; i < HCLEN; ++i)
				{
					HCLENTable[HCLENSwizzle[i]] = stream.consumeBits(3);
				}

				huffman_table dictTable;
				dictTable.initialize(7, HCLENTable, arraysize(HCLENSwizzle));

				uint32 outIndex = 0;
				while (outIndex < HLIT + HDIST)
				{
					uint32 len = dictTable.decode(stream);
					uint32 value = 0;
					uint32 repeat = 1;
					if (len < 16)
					{
						value = len;
					}
					else if (len == 16)
					{
						repeat = stream.consumeBits(2) + 3;
						ASSERT(outIndex > 0);
						value = litlen_dist[outIndex - 1];
					}
					else if (len == 17)
					{
						repeat = stream.consumeBits(3) + 3;
					}
					else if (len == 18)
					{
						repeat = stream.consumeBits(7) + 11;
					}

					for (uint32 r = 0; r < repeat; ++r)
					{
						litlen_dist[outIndex++] = value;
					}
				}
				ASSERT(outIndex == HLIT + HDIST);
			}
			else if (BTYPE == 1)
			{
				HLIT = 288;
				HDIST = 32;

				uint32 bitCounts[][2] = { {143, 8}, {255, 9}, {279, 7}, {287, 8}, {319, 5} };

				uint32 outIndex = 0;
				for (uint32 i = 0; i < arraysize(bitCounts); ++i)
				{
					uint32 lastValue = bitCounts[i][0];
					uint32 bitCount = bitCounts[i][1];
					while (outIndex <= lastValue)
					{
						litlen_dist[outIndex++] = bitCount;
					}
				}
			}

			huffman_table litLenTable;
			litLenTable.initialize(15, litlen_dist, HLIT);

			huffman_table distTable;
			distTable.initialize(15, litlen_dist + HLIT, HDIST);

			while (true)
			{
				uint32 litLen = litLenTable.decode(stream);
				if (litLen <= 255)
				{
					*output++ = litLen;
				}
				else if (litLen >= 257)
				{
					huffman_entry lenEntry = lengthExtra[litLen - 257];
					uint32 len = lenEntry.symbol;
					if (lenEntry.codeLength)
					{
						len += stream.consumeBits(lenEntry.codeLength);
					}

					uint32 distIndex = distTable.decode(stream);
					huffman_entry distEntry = distExtra[distIndex];
					uint32 dist = distEntry.symbol;
					if (distEntry.codeLength)
					{
						dist += stream.consumeBits(distEntry.codeLength);
					}

					uint8* input = output - dist;
					for (uint32 r = 0; r < len; ++r)
					{
						*output++ = *input++;
					}
				}
				else
				{
					break;
				}
			}
		}
	}

	return output - outputStart;
}


```

`src/asset/deflate.h`:

```h
#pragma once

uint64 decompress(uint8* data, uint64 compressedSize, uint8* output);

```

`src/asset/fbx.cpp`:

```cpp
#include "pch.h"
#include "deflate.h"
#include "io.h"
#include "model_asset.h"
#include "core/math.h"
#include "core/cpu_profiling.h"
#include "core/color.h"
#include "geometry/mesh.h"

#include "mesh_postprocessing.h"

#include "core/yaml.h"

//#define PROFILE(name) CPU_PRINT_PROFILE_BLOCK(name)
#define PROFILE(name) 


void testDumpToPLY(const std::string& filename,
	const std::vector<vec3>& positions, const std::vector<vec2>& uvs, const std::vector<vec3>& normals, const std::vector<indexed_triangle16>& triangles,
	uint8 r = 255, uint8 g = 255, uint8 b = 255);


enum rotation_order
{
	rotation_order_xyz,
	rotation_order_xzy,
	rotation_order_yzx,
	rotation_order_yxz,
	rotation_order_zxy,
	rotation_order_zyx,
	rotation_order_spheric_xyz,

	rotation_order_count,
};


#pragma pack(push, 1)
struct fbx_header
{
	char magic[21];
	uint8 unknown[2];
	uint32 version;
};

struct fbx_node_record_header_32
{
	uint32 endOffset;
	uint32 numProperties;
	uint32 propertyListLength;
	uint8 nameLength;
};

struct fbx_node_record_header_64
{
	uint64 endOffset;
	uint64 numProperties;
	uint64 propertyListLength;
	uint8 nameLength;
};

struct fbx_data_array_header
{
	uint32 arrayLength;
	uint32 encoding;
	uint32 compressedLength;
};

#pragma pack(pop)


struct fbx_property;

struct fbx_node
{
	sized_string name;

	uint32 parent;
	uint32 next;
	uint32 firstChild;
	uint32 lastChild;
	uint32 level;
	uint32 numChildren;

	uint32 firstProperty;
	uint32 numProperties;


	const fbx_node* findChild(const std::vector<fbx_node>& nodes, sized_string name) const
	{
		uint32 currentNode = firstChild;
		while (currentNode != -1)
		{
			if (nodes[currentNode].name == name)
			{
				return &nodes[currentNode];
			}
			currentNode = nodes[currentNode].next;
		}
		return 0;
	}

	const fbx_node* getFirstChild(const std::vector<fbx_node>& nodes) const
	{
		return numChildren ? &nodes[firstChild] : 0;
	}

	const fbx_property* getFirstProperty(const std::vector<fbx_property>& properties) const
	{
		return numProperties ? &properties[firstProperty] : 0;
	}
};

enum fbx_property_type
{
	fbx_property_type_bool,
	fbx_property_type_float,
	fbx_property_type_double,
	fbx_property_type_int16,
	fbx_property_type_int32,
	fbx_property_type_int64,
	
	fbx_property_type_string,
	fbx_property_type_raw,
};

struct fbx_property
{
	fbx_property_type type;
	uint32 encoding;
	uint32 encodedLength;
	uint32 numElements;
	uint8* data;
};

static uint32 parseProperties(entire_file& file, std::vector<fbx_property>& outProperties, uint32 numProperties)
{
	uint32 before = (uint32)outProperties.size();

	for (uint32 propID = 0; propID < numProperties; ++propID)
	{
		char propType = *file.consume<char>();
		switch (propType)
		{
			case 'C': // bool
			{
				bool* value = file.consume<bool>();
				outProperties.push_back({ fbx_property_type_bool, 0, sizeof(bool), 1, (uint8*)value });
			} break;
			case 'F': // float
			{
				float* value = file.consume<float>();
				outProperties.push_back({ fbx_property_type_float, 0, sizeof(float), 1, (uint8*)value });
			} break;
			case 'D': // double
			{
				double* value = file.consume<double>();
				outProperties.push_back({ fbx_property_type_double, 0, sizeof(double), 1, (uint8*)value });
			} break;
			case 'Y': // int16
			{
				int16* value = file.consume<int16>();
				outProperties.push_back({ fbx_property_type_int16, 0, sizeof(int16), 1, (uint8*)value });
			} break;
			case 'I': // int32
			{
				int32* value = file.consume<int32>();
				outProperties.push_back({ fbx_property_type_int32, 0, sizeof(int32), 1, (uint8*)value });
			} break;
			case 'L': // int64
			{
				int64* value = file.consume<int64>();
				outProperties.push_back({ fbx_property_type_int64, 0, sizeof(int64), 1, (uint8*)value });
			} break;

			case 'b': // bool[]
			{
				fbx_data_array_header* header = file.consume<fbx_data_array_header>();
				uint8* data = file.consume<uint8>(header->compressedLength);
				outProperties.push_back({ fbx_property_type_bool, header->encoding, header->compressedLength, header->arrayLength, data });
			} break;
			case 'f': // float[]
			{
				fbx_data_array_header* header = file.consume<fbx_data_array_header>();
				uint8* data = file.consume<uint8>(header->compressedLength);
				outProperties.push_back({ fbx_property_type_float, header->encoding, header->compressedLength, header->arrayLength, data });
			} break;
			case 'd': // double[]
			{
				fbx_data_array_header* header = file.consume<fbx_data_array_header>();
				uint8* data = file.consume<uint8>(header->compressedLength);
				outProperties.push_back({ fbx_property_type_double, header->encoding, header->compressedLength, header->arrayLength, data });
			} break;
			case 'i': // int32[]
			{
				fbx_data_array_header* header = file.consume<fbx_data_array_header>();
				uint8* data = file.consume<uint8>(header->compressedLength);
				outProperties.push_back({ fbx_property_type_int32, header->encoding, header->compressedLength, header->arrayLength, data });
			} break;
			case 'l': // int64[]
			{
				fbx_data_array_header* header = file.consume<fbx_data_array_header>();
				uint8* data = file.consume<uint8>(header->compressedLength);
				outProperties.push_back({ fbx_property_type_int64, header->encoding, header->compressedLength, header->arrayLength, data });
			} break;

			case 'S': // String
			{
				uint32 length = *file.consume<uint32>();
				char* str = file.consume<char>(length);
				if (length)
				{
					outProperties.push_back({ fbx_property_type_string, 0, length, length, (uint8*)str });
				}
			} break;

			case 'R': // Raw
			{
				uint32 length = *file.consume<uint32>();
				uint8* data = file.consume<uint8>(length);
				if (length)
				{
					outProperties.push_back({ fbx_property_type_raw, 0, length, length, data });
				}
			} break;

			default:
			{
				ASSERT(false);
			} break;
		}
	}

	return (uint32)outProperties.size() - before;
}

static fbx_node_record_header_64 readNodeRecordHeader(uint32 version, entire_file& file)
{
	fbx_node_record_header_64 node;
	if (version >= 7500)
	{
		node = *file.consume<fbx_node_record_header_64>();
	}
	else
	{
		fbx_node_record_header_32 node32 = *file.consume<fbx_node_record_header_32>();
		node.endOffset = node32.endOffset;
		node.numProperties = node32.numProperties;
		node.propertyListLength = node32.propertyListLength;
		node.nameLength = node32.nameLength;
	}
	return node;
}

static void parseNodes(uint32 version, entire_file& file, std::vector<fbx_node>& outNodes, std::vector<fbx_property>& outProperties, uint32 level, uint32 parent)
{
	fbx_node_record_header_64 currentNode = readNodeRecordHeader(version, file);
	while (currentNode.endOffset != 0)
	{
		uint32 nodeNameLength = currentNode.nameLength;
		char* nodeName = file.consume<char>(nodeNameLength);
		
		fbx_node node;
		node.name = { nodeName, nodeNameLength };
		node.parent = parent;
		node.level = outNodes[parent].level + 1;
		node.next = -1;
		node.firstChild = -1;
		node.lastChild = -1;
		node.numChildren = 0;
		node.firstProperty = (uint32)outProperties.size();
		node.numProperties = (uint32)currentNode.numProperties;

		uint32 nodeIndex = (uint32)outNodes.size();
		if (parent != -1)
		{
			if (outNodes[parent].firstChild == -1)
			{
				outNodes[parent].firstChild = nodeIndex;
			}
			else
			{
				outNodes[outNodes[parent].lastChild].next = nodeIndex;
			}
			outNodes[parent].lastChild = nodeIndex;
			++outNodes[parent].numChildren;
		}

		node.numProperties = parseProperties(file, outProperties, (uint32)currentNode.numProperties);

		outNodes.push_back(node);


		uint64 sizeLeft = currentNode.endOffset - file.readOffset;
		if (sizeLeft > 0)
		{
			parseNodes(version, file, outNodes, outProperties, level + 1, nodeIndex);
			sizeLeft = currentNode.endOffset - file.readOffset;
		}

		ASSERT(sizeLeft == 0);
		currentNode = readNodeRecordHeader(version, file);
	}
}



static uint64 readArray(const fbx_property& prop, uint8* out)
{
	if (prop.encoding == 0)
	{
		memcpy(out, prop.data, prop.encodedLength);
		return prop.encodedLength;
	}
	else
	{
		uint64 decompressedBytes = decompress(prop.data, prop.encodedLength, out);
		return decompressedBytes;
	}
}

static std::vector<int32> readInt32Array(const fbx_property& prop)
{
	ASSERT(prop.type == fbx_property_type_int32);

	std::vector<int32> result;
	result.resize(prop.numElements);

	uint64 readBytes = readArray(prop, (uint8*)result.data());
	ASSERT(readBytes == prop.numElements * sizeof(int32));

	return result;
}

static std::vector<double> readDoubleArray(const fbx_property& prop)
{
	ASSERT(prop.type == fbx_property_type_double);

	std::vector<double> result;
	result.resize(prop.numElements);

	uint64 readBytes = readArray(prop, (uint8*)result.data());
	ASSERT(readBytes == prop.numElements * sizeof(double));

	return result;
}

static sized_string readString(const fbx_property& prop)
{
	ASSERT(prop.type == fbx_property_type_string);
	return { (const char*)prop.data, prop.numElements };
}

static int32 readInt32(const fbx_property& prop)
{
	ASSERT(prop.type == fbx_property_type_int32);
	return *(int32*)prop.data;
}

static int64 readInt64(const fbx_property& prop)
{
	ASSERT(prop.type == fbx_property_type_int64);
	return *(int64*)prop.data;
}

static double readDouble(const fbx_property& prop)
{
	ASSERT(prop.type == fbx_property_type_double);
	return *(double*)prop.data;
}

static int32 decodeIndex(int32 idx)
{
	return (idx < 0) ? ~idx : idx;
}

static bool isTriangleMesh(const std::vector<int32>& indices)
{
	if (indices.size() % 3 != 0)
	{
		return false;
	}

	for (uint32 i = 0; i < (uint32)indices.size(); i += 3)
	{
		int32 a = indices[i + 0];
		int32 b = indices[i + 1];
		int32 c = indices[i + 2];
		if (a < 0 || b < 0 || c > 0)
		{
			return false;
		}
	}

	return true;
}

static float convertTime(int64 t)
{
	return (float)((double)t / 46186158000.0);
}

struct fbx_property_iterator
{
	const fbx_node* node;
	const std::vector<fbx_property>& properties;

	struct iterator
	{
		const fbx_property* prop;

		friend bool operator!=(const iterator& a, const iterator& b) { return a.prop != b.prop; }
		iterator& operator++() { ++prop; return *this; }
		iterator operator++(int) { iterator result = *this; ++prop; return result; }
		const fbx_property& operator*() { return *prop; }
	};

	iterator begin()
	{
		return iterator{ node ? properties.data() + node->firstProperty : 0 };
	}

	iterator end()
	{
		return iterator{ node ? properties.data() + (node->firstProperty + node->numProperties) : 0 };
	}
};

struct fbx_node_iterator
{
	const fbx_node* node;
	const std::vector<fbx_node>& nodes;

	struct iterator
	{
		const fbx_node* nodes;
		uint32 child;

		friend bool operator!=(const iterator& a, const iterator& b) { return a.child != b.child; }
		iterator& operator++() { child = nodes[child].next; return *this; }
		const fbx_node& operator*() { return nodes[child]; }
	};

	iterator begin()
	{
		return iterator{ nodes.data(), node ? node->firstChild : -1 };
	}

	iterator end()
	{
		return iterator{ nodes.data(), (uint32)-1 };
	}
};


struct fbx_node_wrapper
{
	const fbx_node& node;
	const std::vector<fbx_node>& nodes;
	const std::vector<fbx_property>& properties;
};

struct fbx_prop_wrapper
{
	const fbx_property& prop;
};

namespace YAML
{
	template<>
	struct convert<fbx_property>
	{
		static Node encode(const fbx_property& prop)
		{
			Node n;
			Node dataNode;
			dataNode.SetStyle(EmitterStyle::Flow);

			fbx_property_type type = prop.type;

			switch (type)
			{
				case fbx_property_type_bool:
				{
					n["Type"] = "Bool";
					if (prop.numElements == 1) { dataNode = *(bool*)prop.data; }
					else if (prop.encoding == 0) {for (uint32 j = 0; j < prop.numElements; ++j) { dataNode.push_back(((bool*)prop.data)[j]); } }
					else { dataNode.push_back(std::to_string(prop.numElements) + " compressed elements"); }
				} break;
				case fbx_property_type_float:
				{
					n["Type"] = "Float";
					if (prop.numElements == 1) { dataNode = *(float*)prop.data; }
					else if (prop.encoding == 0) { for (uint32 j = 0; j < prop.numElements; ++j) { dataNode.push_back(((float*)prop.data)[j]); } }
					else { dataNode.push_back(std::to_string(prop.numElements) + " compressed elements"); }
				} break;
				case fbx_property_type_double:
				{
					n["Type"] = "Double";
					if (prop.numElements == 1) { dataNode = *(double*)prop.data; }
					else if (prop.encoding == 0) { for (uint32 j = 0; j < prop.numElements; ++j) { dataNode.push_back(((double*)prop.data)[j]); } }
					else { dataNode.push_back(std::to_string(prop.numElements) + " compressed elements"); }
				} break;
				case fbx_property_type_int16:
				{
					n["Type"] = "Int16";
					if (prop.numElements == 1) { dataNode = *(int16*)prop.data; }
					else if (prop.encoding == 0) { for (uint32 j = 0; j < prop.numElements; ++j) { dataNode.push_back(((int16*)prop.data)[j]); } }
					else { dataNode.push_back(std::to_string(prop.numElements) + " compressed elements"); }
				} break;
				case fbx_property_type_int32:
				{
					n["Type"] = "Int32";
					if (prop.numElements == 1) { dataNode = *(int32*)prop.data; }
					else if (prop.encoding == 0) { for (uint32 j = 0; j < prop.numElements; ++j) { dataNode.push_back(((int32*)prop.data)[j]); } }
					else { dataNode.push_back(std::to_string(prop.numElements) + " compressed elements"); }
				} break;
				case fbx_property_type_int64:
				{
					n["Type"] = "Int64";
					if (prop.numElements == 1) { dataNode = *(int64*)prop.data; }
					else if (prop.encoding == 0) { for (uint32 j = 0; j < prop.numElements; ++j) { dataNode.push_back(((int64*)prop.data)[j]); } }
					else { dataNode.push_back(std::to_string(prop.numElements) + " compressed elements"); }
				} break;
				case fbx_property_type_string:
				{
					n["Type"] = "String";
					dataNode = std::string((const char*)prop.data, prop.numElements);
				} break;
				case fbx_property_type_raw:
				{
					n["Type"] = "Raw";
				} break;
				default:
				{
					ASSERT(false);
				} break;
			}

			n["Data"] = dataNode;
			return n;
		}
	};

	template<>
	struct convert<fbx_node_wrapper>
	{
		static Node encode(const fbx_node_wrapper& c)
		{
			Node n;

			for (const fbx_property& prop : fbx_property_iterator{ &c.node, c.properties })
			{
				n.push_back(prop);
			}

			for (const fbx_node& node : fbx_node_iterator{ &c.node, c.nodes })
			{
				std::string key(node.name.str, node.name.length);

				Node nestedNode;
				nestedNode[key] = fbx_node_wrapper{ node, c.nodes, c.properties };
				n.push_back(nestedNode);
			}

			return n;
		}
	};
}

static void writeFBXContentToYAML(const std::vector<fbx_node>& nodes, const std::vector<fbx_property>& properties, const fbx_node& parent, YAML::Node& out)
{
	out = fbx_node_wrapper{ parent, nodes, properties };
}




enum mapping_info
{
	mapping_info_by_polygon_vertex,
	mapping_info_by_polygon,
	mapping_info_by_vertex,
	mapping_info_all_same,
};

enum reference_info
{
	reference_info_index_to_direct,
	reference_info_direct,
};

struct offset_count
{
	uint32 offset;
	uint32 count;
};

template <typename T>
static std::tuple<std::vector<T>, std::vector<int>, mapping_info, reference_info> readGeometryData(const fbx_node* node,
	const std::vector<fbx_node>& nodes, const std::vector<fbx_property>& properties,
	sized_string dataNodeName, sized_string indexNodeName)
{
	std::vector<T> result;
	std::vector<int32> indices;
	mapping_info mappingInfo = mapping_info_by_polygon_vertex;
	reference_info referenceInfo = reference_info_index_to_direct;

	for (const fbx_node& child : fbx_node_iterator{ node, nodes })
	{
		if (child.name == "MappingInformationType")
		{
			sized_string mappingInfoStr = readString(*child.getFirstProperty(properties));
			if (mappingInfoStr == "ByPolygonVertex") { mappingInfo = mapping_info_by_polygon_vertex; }
			else if (mappingInfoStr == "ByPolygon") { mappingInfo = mapping_info_by_polygon; }
			else if (mappingInfoStr == "ByVertice" || mappingInfoStr == "ByVertex") { mappingInfo = mapping_info_by_vertex; }
			else if (mappingInfoStr == "AllSame") { mappingInfo = mapping_info_all_same; }
		}
		else if (child.name == "ReferenceInformationType")
		{
			sized_string referenceInfoStr = readString(*child.getFirstProperty(properties));
			if (referenceInfoStr == "IndexToDirect" || referenceInfoStr == "Index") { referenceInfo = reference_info_index_to_direct; }
			else if (referenceInfoStr == "Direct") { referenceInfo = reference_info_direct; }
		}
		else if (child.name == dataNodeName)
		{
			if constexpr (std::is_same_v<T, double>)
			{
				result = readDoubleArray(*child.getFirstProperty(properties));
			}
			else if constexpr (std::is_same_v<T, int32>)
			{
				result = readInt32Array(*child.getFirstProperty(properties));
			}
		}
		else if (child.name == indexNodeName)
		{
			indices = readInt32Array(*child.getFirstProperty(properties));
		}
	}

	return { result, indices, mappingInfo, referenceInfo };
}

template <typename data_t>
static std::vector<data_t> mapDataToVertices(const std::vector<data_t>& data, const std::vector<int32>& dataIndices,
	mapping_info mapping, reference_info reference, const std::vector<offset_count>& vertexOffsetCounts, const std::vector<uint32>& originalToNewVertex,
	uint32 numVertices)
{
	// https://banexdevblog.files.wordpress.com/2014/06/example_english.png
	if (mapping == mapping_info_by_polygon_vertex)
	{
		if (reference == reference_info_direct)
		{
			ASSERT(data.size() == numVertices);
			return data;
		}
		else
		{
			ASSERT(dataIndices.size() == numVertices);
			std::vector<data_t> result(numVertices);
			for (uint32 i = 0; i < (uint32)dataIndices.size(); ++i)
			{
				int32 dataIndex = dataIndices[i];
				data_t out = (dataIndex == -1) ? data_t(0.f) : data[dataIndex];
				result[i] = out;
			}
			return result;
		}
	}
	else if (mapping == mapping_info_by_vertex)
	{
		if (reference == reference_info_direct)
		{
			ASSERT(data.size() == vertexOffsetCounts.size());
			std::vector<data_t> result(numVertices);
			for (uint32 i = 0; i < (uint32)data.size(); ++i)
			{
				data_t out = data[i];
				uint32 offset = vertexOffsetCounts[i].offset;
				uint32 count = vertexOffsetCounts[i].count;
				for (uint32 j = 0; j < count; ++j)
				{
					uint32 vertexIndex = originalToNewVertex[j + offset];
					result[vertexIndex] = out;
				}
			}
			return result;
		}
		else
		{
			ASSERT(dataIndices.size() == vertexOffsetCounts.size());
			std::vector<data_t> result(numVertices);
			for (uint32 i = 0; i < (uint32)dataIndices.size(); ++i)
			{
				int32 dataIndex = dataIndices[i];
				data_t out = (dataIndex == -1) ? data_t(0.f) : data[dataIndex];
				uint32 offset = vertexOffsetCounts[i].offset;
				uint32 count = vertexOffsetCounts[i].count;
				for (uint32 j = 0; j < count; ++j)
				{
					uint32 vertexIndex = originalToNewVertex[j + offset];
					result[vertexIndex] = out;
				}
			}
			return result;
		}
	}
	else if (mapping == mapping_info_by_polygon)
	{
		return {};
	}
	else if (mapping == mapping_info_all_same)
	{
		ASSERT(dataIndices.size() == 0);
		ASSERT(data.size() == 1);
		std::vector<data_t> result(numVertices, data[0]);
		return result;
	}

	ASSERT(false);
	return {};
}


struct fbx_object
{
	int64 id;
	sized_string name;
};

struct fbx_model;
struct fbx_mesh;
struct fbx_material;
struct fbx_texture;
struct fbx_deformer;
struct fbx_animation_stack;
struct fbx_animation_layer;
struct fbx_animation_curve_node;
struct fbx_animation_curve;

struct fbx_definitions
{
	union
	{
		struct
		{
			int32 numGlobalSettings;
			//int32 numNodeAttributes;
			int32 numModels;
			int32 numMeshes;
			//int32 numPoses;
			int32 numDeformers;
			int32 numMaterials;
			int32 numTextures;
			//int32 numVideos;
			int32 numAnimationStacks;
			int32 numAnimationLayers;
			int32 numAnimationCurveNodes;
			int32 numAnimationCurves;
		};
		int32 counts[10];
	};

	rotation_order defaultRotationOrder;
};

struct fbx_global_settings
{
	int32 upAxis;
	int32 upAxisSign;

	int32 frontAxis;
	int32 frontAxisSign;

	int32 coordAxis;
	int32 coordAxisSign;

	int32 originalUpAxis;
	int32 originalUpAxisSign;

	float frameRate;
};

static fbx_definitions readDefinitions(const fbx_node& node, const std::vector<fbx_node>& nodes, const std::vector<fbx_property>& properties)
{
	fbx_definitions result = {};

	for (const fbx_node& objectTypeNode : fbx_node_iterator{ &node, nodes })
	{
		if (objectTypeNode.name == "ObjectType")
		{
			sized_string type = readString(*objectTypeNode.getFirstProperty(properties));
			const fbx_node* countNode = objectTypeNode.findChild(nodes, "Count");
			int32 count = countNode ? readInt32(*countNode->getFirstProperty(properties)) : 0;

			const fbx_node* propTemplate = objectTypeNode.findChild(nodes, "PropertyTemplate");
			const fbx_node* properties70 = propTemplate ? propTemplate->findChild(nodes, "Properties70") : 0;

			if (type == "GlobalSettings") { result.numGlobalSettings = count; }
			//else if (type == "NodeAttribute") { result.numNodeAttributes = count; }
			//else if (type == "Pose") { result.numPoses = count; }
			else if (type == "Deformer") { result.numDeformers = count; }
			else if (type == "AnimationCurve") { result.numAnimationCurves = count; }
			else if (type == "Material") { result.numMaterials = count; }
			else if (type == "Texture") { result.numTextures = count; }
			//else if (type == "Video") { result.numVideos = count; }
			else if (type == "AnimationStack") { result.numAnimationStacks = count; }
			else if (type == "AnimationLayer") { result.numAnimationLayers = count; }
			else if (type == "AnimationCurveNode") { result.numAnimationCurveNodes = count; }
			else if (type == "Geometry") { result.numMeshes = count; }
			else if (type == "Model")
			{
				result.numModels = count;

				for (const fbx_node& P : fbx_node_iterator{ properties70, nodes })
				{
					ASSERT(P.name == "P");
					auto propIterator = fbx_property_iterator{ &P, properties }.begin();

					sized_string pType = readString(*propIterator++);
					if (pType == "RotationOrder")
					{
						sized_string e = readString(*propIterator++);
						ASSERT(e == "enum");
						result.defaultRotationOrder = (rotation_order)readInt32(*propIterator++);
					}
				}
			}
		}
	}

	return result;
}

static fbx_global_settings readGlobalSettings(const fbx_node& node, const std::vector<fbx_node>& nodes, const std::vector<fbx_property>& properties)
{
	const fbx_node* properties70 = node.findChild(nodes, "Properties70");

	fbx_global_settings result = {};

	for (const fbx_node& P : fbx_node_iterator{ properties70, nodes })
	{
		ASSERT(P.name == "P");

		auto propIterator = fbx_property_iterator{ &P, properties }.begin();
		sized_string name = readString(*propIterator++);

		auto skipTwo = [&propIterator]()
		{
			sized_string dataType = readString(*propIterator++);
			sized_string longDataType = readString(*propIterator++);
		};

		if (name == "UpAxis") { skipTwo(); result.upAxis = readInt32(*propIterator++); }
		else if (name == "UpAxisSign") { skipTwo(); result.upAxisSign = readInt32(*propIterator++); }
		else if (name == "FrontAxis") { skipTwo(); result.frontAxis = readInt32(*propIterator++); }
		else if (name == "FrontAxisSign") { skipTwo(); result.frontAxisSign = readInt32(*propIterator++); }
		else if (name == "CoordAxis") { skipTwo(); result.coordAxis = readInt32(*propIterator++); }
		else if (name == "CoordAxisSign") { skipTwo(); result.coordAxisSign = readInt32(*propIterator++); }
		else if (name == "OriginalUpAxis") { skipTwo(); result.originalUpAxis = readInt32(*propIterator++); }
		else if (name == "OriginalUpAxisSign") { skipTwo(); result.originalUpAxisSign = readInt32(*propIterator++); }
		else if (name == "CustomFrameRate") { skipTwo(); result.frameRate = (float)readDouble(*propIterator++); }
	}

	return result;
}

enum fbx_object_type
{
	fbx_object_type_unknown,

	fbx_object_type_global,
	fbx_object_type_model,
	fbx_object_type_mesh,
	fbx_object_type_material,
	fbx_object_type_texture,
	fbx_object_type_deformer,
	fbx_object_type_animation_stack,
	fbx_object_type_animation_layer,
	fbx_object_type_animation_curve_node,
	fbx_object_type_animation_curve,
};

static const char* objectTypeNames[] =
{
	"Unknown",
	"Global",
	"Model",
	"Mesh",
	"Material",
	"Texture",
	"Deformer",
	"Animation stack",
	"Animation layer",
	"Animation curve node",
	"Animation curve",
};

struct fbx_model : fbx_object
{
	quat localRotation = quat::identity;
	vec3 localTranslation = vec3(0.f);

	std::vector<fbx_mesh*> meshes;
	std::vector<fbx_material*> materials;
	std::vector<fbx_model*> children;

	fbx_model* parent;
	fbx_deformer* deformer;
};

struct fbx_mesh : fbx_object
{
	std::vector<vec3> positions;
	std::vector<vec2> uvs;
	std::vector<vec3> normals;
	std::vector<vec3> tangents;
	std::vector<uint32> colors;
	std::vector<skinning_weights> skin;
	std::vector<uint8> faceSizes;

	std::vector<offset_count> vertexOffsetCounts;
	std::vector<uint32> originalToNewVertex;

	std::vector<int32> materialIndexPerFace;

	std::vector<submesh_asset> submeshes;
	int64 skeletonID;

	fbx_model* model;
};

struct fbx_material : fbx_object
{
	vec4 emission;
	vec4 albedoTint;
	float roughnessOverride;
	float metallicOverride;
	pbr_material_shader shader;
	float uvScale;
	float translucency;

	fbx_texture* albedoTexture;
	fbx_texture* normalTexture;
	fbx_texture* roughnessTexture;
	fbx_texture* metallicTexture;
};

struct fbx_texture : fbx_object
{
	sized_string filename;
	sized_string relativeFilename;
};

struct fbx_deformer : fbx_object
{
	std::vector<int32> vertexIndices;
	std::vector<float> weights;

	fbx_model* model;
	int64 skeletonID;
	uint32 parentID = INVALID_JOINT;
	uint32 jointID = INVALID_JOINT;

	mat4 invBindMatrix;
};

struct fbx_animation_stack : fbx_object
{
	std::vector<fbx_animation_layer*> layers;
	int64 duration;
};

struct fbx_animation_layer : fbx_object
{
	std::vector<fbx_animation_curve_node*> curveNodes;
};

struct fbx_animation_curve_node : fbx_object
{
	vec3 d;

	fbx_animation_curve* xCurve;
	fbx_animation_curve* yCurve;
	fbx_animation_curve* zCurve;

	fbx_model* model;
	int32 propertyIndex = -1;
};

struct fbx_animation_curve : fbx_object
{
	float defaultValue;
	uint32 first;
	uint32 count;
	int32 flags;
};

static std::pair<int64, sized_string> readObjectIDAndName(const fbx_node& node, const std::vector<fbx_property>& properties)
{
	int64 id = 0;
	sized_string name = {};

	for (const fbx_property& prop : fbx_property_iterator{ &node, properties })
	{
		if (prop.type == fbx_property_type_int64)
		{
			id = readInt64(prop);
		}
		if (prop.type == fbx_property_type_string && name.length == 0)
		{
			name = readString(prop);
		}
	}

	return { id, name };
}

static fbx_model readModel(const fbx_node& node, const std::vector<fbx_node>& nodes, const std::vector<fbx_property>& properties)
{
	auto [id, name] = readObjectIDAndName(node, properties);

	fbx_model result = {};
	result.id = id;
	result.name = name;

	const fbx_node* propertiesNode = node.findChild(nodes, "Properties70");
	for (const fbx_node& P : fbx_node_iterator{ propertiesNode, nodes })
	{
		ASSERT(P.name == "P");

		auto propIterator = fbx_property_iterator{ &P, properties }.begin();
		sized_string type = readString(*propIterator++);
		if (type == "Lcl Translation")
		{
			++propIterator;
			++propIterator;
			float x = (float)readDouble(*propIterator++);
			float y = (float)readDouble(*propIterator++);
			float z = (float)readDouble(*propIterator++);
			result.localTranslation = vec3(x, y, z);
		}
		else if (type == "Lcl Rotation")
		{
			++propIterator;
			++propIterator;
			float x = (float)readDouble(*propIterator++);
			float y = (float)readDouble(*propIterator++);
			float z = (float)readDouble(*propIterator++);
			// TODO
		}
	}

	return result;
}

static fbx_mesh readMesh(const fbx_node& node, const std::vector<fbx_node>& nodes, const std::vector<fbx_property>& properties, uint32 flags)
{
	auto [id, name] = readObjectIDAndName(node, properties);

	fbx_mesh result = {};
	result.id = id;
	result.name = name;

	const fbx_node* positionsNode = node.findChild(nodes, "Vertices");
	std::vector<double> originalPositionsRaw = readDoubleArray(*positionsNode->getFirstProperty(properties));

	const fbx_node* indicesNode = node.findChild(nodes, "PolygonVertexIndex");
	std::vector<int32> originalIndices = readInt32Array(*indicesNode->getFirstProperty(properties));

	struct vec2d
	{
		double x, y;
	};

	struct vec3d
	{
		double x, y, z;
	};

	struct vec4d
	{
		double x, y, z, w;
	};

	vec3d* originalPositionsPtr = (vec3d*)originalPositionsRaw.data();
	uint32 numOriginalPositions = (uint32)originalPositionsRaw.size() / 3;



	result.positions.reserve(originalIndices.size());
	result.faceSizes.reserve(originalIndices.size());

	result.vertexOffsetCounts.resize(numOriginalPositions, { 0, 0 });
	result.originalToNewVertex.resize(originalIndices.size());

	uint8 faceSize = 0;
	for (int32 index : originalIndices)
	{
		int32 decodedIndex = decodeIndex(index);
		vec3d position = originalPositionsPtr[decodedIndex];
		result.positions.push_back(vec3((float)position.x, (float)position.y, (float)position.z));
		++result.vertexOffsetCounts[decodedIndex].count;

		++faceSize;
		if (index < 0)
		{
			result.faceSizes.push_back(faceSize);
			faceSize = 0;
		}
	}

	uint32 offset = 0;
	for (uint32 i = 0; i < numOriginalPositions; ++i)
	{
		result.vertexOffsetCounts[i].offset = offset;
		offset += result.vertexOffsetCounts[i].count;
		result.vertexOffsetCounts[i].count = 0;
	}

	for (uint32 i = 0; i < (uint32)originalIndices.size(); ++i)
	{
		int32 index = originalIndices[i];
		int32 decodedIndex = decodeIndex(index);
		uint32 offset = result.vertexOffsetCounts[decodedIndex].offset;
		uint32 count = result.vertexOffsetCounts[decodedIndex].count++;
		result.originalToNewVertex[offset + count] = i;
	}




	// UVs.
	if (flags & mesh_flag_load_uvs)
	{
		const fbx_node* uvNode = node.findChild(nodes, "LayerElementUV");
		auto [raw, indices, mapping, reference] = readGeometryData<double>(uvNode, nodes, properties, "UV", "UVIndex");
		ASSERT(raw.size() % 2 == 0);

		if (raw.size())
		{
			result.uvs.resize(raw.size() / 2);
			vec2d* ptr = (vec2d*)raw.data();
			for (uint32 i = 0; i < (uint32)result.uvs.size(); ++i)
			{
				result.uvs[i] = vec2((float)ptr[i].x, (float)ptr[i].y);
				if (flags & mesh_flag_flip_uvs_vertically)
				{
					result.uvs[i].y = 1.f - result.uvs[i].y;
				}
			}

			result.uvs = mapDataToVertices(result.uvs, indices, mapping, reference, result.vertexOffsetCounts, result.originalToNewVertex,
				(uint32)result.positions.size());
		}
	}


	// Normals.
	if (flags & mesh_flag_load_normals)
	{
		const fbx_node* normalsNode = node.findChild(nodes, "LayerElementNormal");
		auto [raw, indices, mapping, reference] = readGeometryData<double>(normalsNode, nodes, properties, "Normals", "NormalsIndex");
		ASSERT(raw.size() % 3 == 0);

		if (raw.size())
		{
			result.normals.resize(raw.size() / 3);
			vec3d* ptr = (vec3d*)raw.data();
			for (uint32 i = 0; i < (uint32)result.normals.size(); ++i)
			{
				result.normals[i] = vec3((float)ptr[i].x, (float)ptr[i].y, (float)ptr[i].z);
			}

			result.normals = mapDataToVertices(result.normals, indices, mapping, reference, result.vertexOffsetCounts, result.originalToNewVertex,
				(uint32)result.positions.size());
		}
	}


	// Tangents.
	if (flags & mesh_flag_load_tangents)
	{
		const fbx_node* tangentsNode = node.findChild(nodes, "LayerElementTangents");
		auto [raw, indices, mapping, reference] = readGeometryData<double>(tangentsNode, nodes, properties, "Tangents", "TangentsIndex");
		if (raw.empty())
		{
			std::tie(raw, indices, mapping, reference) = readGeometryData<double>(tangentsNode, nodes, properties, "Tangent", "TangentIndex");
		}
		ASSERT(raw.size() % 3 == 0);

		if (raw.size())
		{
			result.tangents.resize(raw.size() / 3);
			vec3d* ptr = (vec3d*)raw.data();
			for (uint32 i = 0; i < (uint32)result.tangents.size(); ++i)
			{
				result.tangents[i] = vec3((float)ptr[i].x, (float)ptr[i].y, (float)ptr[i].z);
			}

			result.tangents = mapDataToVertices(result.tangents, indices, mapping, reference, result.vertexOffsetCounts, result.originalToNewVertex,
				(uint32)result.positions.size());
		}
	}


	// Colors.
	if (flags & mesh_flag_load_colors)
	{
		const fbx_node* colorsNode = node.findChild(nodes, "LayerElementColor");
		auto [raw, indices, mapping, reference] = readGeometryData<double>(colorsNode, nodes, properties, "Colors", "ColorIndex");
		ASSERT(raw.size() % 4 == 0);

		if (raw.size())
		{
			result.colors.resize(raw.size() / 4);
			vec4d* ptr = (vec4d*)raw.data();
			for (uint32 i = 0; i < (uint32)result.colors.size(); ++i)
			{
				result.colors[i] = packColor((float)ptr[i].x, (float)ptr[i].y, (float)ptr[i].z, (float)ptr[i].w);
			}

			result.colors = mapDataToVertices(result.colors, indices, mapping, reference, result.vertexOffsetCounts, result.originalToNewVertex,
				(uint32)result.positions.size());
		}
	}



	// Materials.
	{
		const fbx_node* materialsNode = node.findChild(nodes, "LayerElementMaterial");
		auto [materials, indices, mapping, reference] = readGeometryData<int32>(materialsNode, nodes, properties, "Materials", "");

		if (materials.size() > 0)
		{
			if (mapping == mapping_info_all_same)
			{
				int32 materialIndex = !materials.empty() ? materials[0] : 0;
				result.materialIndexPerFace.resize(result.faceSizes.size(), materialIndex);
			}
			else if (mapping == mapping_info_by_polygon)
			{
				result.materialIndexPerFace = std::move(materials);
			}
			else
			{
				ASSERT(false);
			}
		}
	}
	if (result.materialIndexPerFace.empty())
	{
		result.materialIndexPerFace.resize(result.faceSizes.size(), 0);
	}

	return result;
}

static fbx_material readMaterial(const fbx_node& node, const std::vector<fbx_node>& nodes, const std::vector<fbx_property>& properties)
{
	auto [id, name] = readObjectIDAndName(node, properties);

	fbx_material result = {};
	result.id = id;
	result.name = name;

	result.albedoTint = vec4(1.f);
	result.emission = vec4(0.f);
	result.uvScale = 1.f;

	for (const fbx_node& child : fbx_node_iterator{ &node, nodes })
	{
		if (child.name == "ShadingModel")
		{
			sized_string shadingModel = readString(*child.getFirstProperty(properties));
			ASSERT(shadingModel == "Phong" || shadingModel == "phong");
		}
		else if (child.name == "MultiLayer")
		{
			int32 multiLayer = readInt32(*child.getFirstProperty(properties));
		}
		else if (child.name == "Properties70")
		{
			for (const fbx_node& P : fbx_node_iterator{ &child, nodes })
			{
				ASSERT(P.name == "P");

				auto propIterator = fbx_property_iterator{ &P, properties }.begin();
				sized_string name = readString(*propIterator++);
				sized_string type = readString(*propIterator++);
				sized_string dummy = readString(*propIterator++);

				vec3 color(0.f, 0.f, 0.f);
				float value = 0.f;

				if (type == "Color")
				{
					color.x = (float)readDouble(*propIterator++);
					color.y = (float)readDouble(*propIterator++);
					color.z = (float)readDouble(*propIterator++);
				}
				else if (type == "Number")
				{
					value = (float)readDouble(*propIterator++);
				}

				if (name == "DiffuseColor")
				{
					result.albedoTint = vec4(color, 1.f);
				}
				else if (name == "EmissiveColor")
				{
					result.emission = vec4(color, 1.f);
				}
				else if (name == "ReflectionFactor")
				{
					result.metallicOverride = value;
				}
				else if (name == "ShininessExponent")
				{
					result.roughnessOverride = 1.f - (sqrt(value) * 0.1f);
				}
				else
				{
					//printf("Material property '%.*s' not handled.\n", name.length, name.str);
				}
			}
		}
	}

	return result;
}

static fbx_texture readTexture(const fbx_node& node, const std::vector<fbx_node>& nodes, const std::vector<fbx_property>& properties)
{
	auto [id, name] = readObjectIDAndName(node, properties);

	fbx_texture result = {};
	result.id = id;
	result.name = name;

	for (const fbx_node& child : fbx_node_iterator{ &node, nodes })
	{
		if (child.name == "FileName")
		{
			result.filename = readString(*child.getFirstProperty(properties));
		}
		else if (child.name == "RelativeFilename")
		{
			result.relativeFilename = readString(*child.getFirstProperty(properties));
		}
	}

	return result;
}

static fbx_deformer readDeformer(const fbx_node& node, const std::vector<fbx_node>& nodes, const std::vector<fbx_property>& properties)
{
	auto [id, name] = readObjectIDAndName(node, properties);

	fbx_deformer result = {};
	result.id = id;
	result.name = name;
	result.invBindMatrix = mat4::identity;

	for (const fbx_node& child : fbx_node_iterator{ &node, nodes })
	{
		if (child.name == "Indexes")
		{
			result.vertexIndices = readInt32Array(*child.getFirstProperty(properties));
		}
		else if (child.name == "Weights")
		{
			std::vector<double> weights = readDoubleArray(*child.getFirstProperty(properties));
			result.weights.resize(weights.size());
			for (uint32 i = 0; i < (uint32)weights.size(); ++i)
			{
				result.weights[i] = (float)weights[i];
			}
		}
		else if (child.name == "Transform")
		{
			std::vector<double> matrix = readDoubleArray(*child.getFirstProperty(properties));
			ASSERT(matrix.size() == 16);
			for (uint32 i = 0; i < 16; ++i)
			{
				result.invBindMatrix.m[i] = (float)matrix[i];
			}
		}
	}

	ASSERT(result.vertexIndices.size() == result.weights.size());

	return result;
}

static fbx_animation_stack readAnimationStack(const fbx_node& node, const std::vector<fbx_node>& nodes, const std::vector<fbx_property>& properties)
{
	auto [id, name] = readObjectIDAndName(node, properties);
	fbx_animation_stack result = {};
	result.id = id;
	result.name = name;

	for (const fbx_node& P : fbx_node_iterator{ node.findChild(nodes, "Properties70"), nodes })
	{
		ASSERT(P.name == "P");

		sized_string type = readString(*P.getFirstProperty(properties));
		if (type == "LocalStop")
		{
			for (const fbx_property& prop : fbx_property_iterator{ &P, properties })
			{
				if (prop.type == fbx_property_type_int64)
				{
					result.duration = readInt64(prop);
				}
			}
		}
	}

	if (result.duration == 0)
	{
		printf("Animation stack has zero duration!\n");
	}

	return result;
}

static fbx_animation_layer readAnimationLayer(const fbx_node& node, const std::vector<fbx_node>& nodes, const std::vector<fbx_property>& properties)
{
	auto [id, name] = readObjectIDAndName(node, properties);
	fbx_animation_layer result = {};
	result.id = id;
	result.name = name;

	return result;
}

static fbx_animation_curve_node readAnimationCurveNode(const fbx_node& node, const std::vector<fbx_node>& nodes, const std::vector<fbx_property>& properties)
{
	auto [id, name] = readObjectIDAndName(node, properties);
	fbx_animation_curve_node result = {};
	result.id = id;
	result.name = name;

	for (const fbx_node& P : fbx_node_iterator{ node.findChild(nodes, "Properties70"), nodes })
	{
		ASSERT(P.name == "P");

		auto propIterator = fbx_property_iterator{ &P, properties }.begin();
		sized_string type = readString(*propIterator++);
		sized_string numberStr = readString(*propIterator++);
		sized_string aStr = readString(*propIterator++);

		ASSERT(numberStr == "Number");
		ASSERT(aStr == "A");

		float value = (float)readDouble(*propIterator++);
		if (type == "d|X") { result.d.x = value; }
		else if (type == "d|Y") { result.d.y = value; }
		else if (type == "d|Z") { result.d.z = value; }
	}

	return result;
}

static fbx_animation_curve readAnimationCurve(const fbx_node& node, const std::vector<fbx_node>& nodes, const std::vector<fbx_property>& properties,
	std::vector<int64>& times, std::vector<float>& values)
{
	auto [id, name] = readObjectIDAndName(node, properties);
	fbx_animation_curve result = {};
	result.id = id;
	result.name = name;

	uint32 first = (uint32)times.size();

	for (const fbx_node& child : fbx_node_iterator{ &node, nodes })
	{
		if (child.name == "Default")
		{
			result.defaultValue = (float)readDouble(*child.getFirstProperty(properties));
		}
		else if (child.name == "KeyTime")
		{
			const fbx_property& prop = *child.getFirstProperty(properties);
			ASSERT(prop.type == fbx_property_type_int64);

			uint32 count = prop.numElements;
			times.resize(times.size() + count);
			readArray(prop, (uint8*)(times.data() + first));
		}
		else if (child.name == "KeyValueFloat")
		{
			const fbx_property& prop = *child.getFirstProperty(properties);
			ASSERT(prop.type == fbx_property_type_float);

			uint32 count = prop.numElements;
			values.resize(values.size() + count);
			readArray(prop, (uint8*)(values.data() + first));
		}
		else if (child.name == "KeyAttrFlags")
		{
			result.flags = readInt32(*child.getFirstProperty(properties));
		}
	}

	ASSERT(times.size() == values.size());

	uint32 count = (uint32)times.size() - first;
	result.first = first;
	result.count = count;

	return result;
}









struct fbx_animation_joint
{
	union
	{
		struct
		{
			fbx_animation_curve_node* translation;
			fbx_animation_curve_node* rotation;
			fbx_animation_curve_node* scaling;
		};
		fbx_animation_curve_node* curveNodes[3];
	};
};

struct fbx_animation
{
	std::string name;
	std::unordered_map<int64, fbx_animation_joint> joints;
	int64 duration;
};

struct fbx_skeleton
{
	std::vector<fbx_deformer*> joints;
};

struct fbx_object_lut
{
	using fbx_object_index = std::pair<fbx_object_type, uint32>;

	std::unordered_map<int64, fbx_object_index> idToObject;

	std::vector<fbx_model> models;
	std::vector<fbx_mesh> meshes;
	std::vector<fbx_material> materials;
	std::vector<fbx_texture> textures;
	std::vector<fbx_deformer> deformers;

	std::vector<fbx_animation_stack> animationStacks;
	std::vector<fbx_animation_layer> animationLayers;
	std::vector<fbx_animation_curve_node> animationCurveNodes;
	std::vector<fbx_animation_curve> animationCurves;

	std::unordered_map<int64, fbx_skeleton> skeletons;
	std::vector<fbx_animation> animations;


	void reserve(const fbx_definitions& definitions)
	{
		models.reserve(definitions.numModels);
		meshes.reserve(definitions.numMeshes);
		materials.reserve(definitions.numMaterials);
		textures.reserve(definitions.numTextures);
		deformers.reserve(definitions.numDeformers);
		animationStacks.reserve(definitions.numAnimationStacks);
		animationLayers.reserve(definitions.numAnimationLayers);
		animationCurveNodes.reserve(definitions.numAnimationCurveNodes);
		animationCurves.reserve(definitions.numAnimationCurves);

		int32 totalCount = 0;
		for (uint32 i = 0; i < arraysize(definitions.counts); ++i)
		{
			totalCount += definitions.counts[i];
		}
		idToObject.reserve(totalCount);
	}

	template <typename T>
	void push(std::vector<T>& vec, T&& t, fbx_object_type type)
	{
		uint32 index = (uint32)vec.size();
		int64 id = t.id;
		vec.push_back(std::move(t));
		idToObject[id] = { type, index };
	}

	void push(fbx_model&& t) { push(models, std::move(t), fbx_object_type_model); }
	void push(fbx_mesh&& t) { push(meshes, std::move(t), fbx_object_type_mesh); }
	void push(fbx_material&& t) { push(materials, std::move(t), fbx_object_type_material); }
	void push(fbx_texture&& t) { push(textures, std::move(t), fbx_object_type_texture); }
	void push(fbx_deformer&& t) { push(deformers, std::move(t), fbx_object_type_deformer); }
	void push(fbx_animation_stack&& t) { push(animationStacks, std::move(t), fbx_object_type_animation_stack); }
	void push(fbx_animation_layer&& t) { push(animationLayers, std::move(t), fbx_object_type_animation_layer); }
	void push(fbx_animation_curve_node&& t) { push(animationCurveNodes, std::move(t), fbx_object_type_animation_curve_node); }
	void push(fbx_animation_curve&& t) { push(animationCurves, std::move(t), fbx_object_type_animation_curve); }

	fbx_object_index find(int64 id) 
	{ 
		auto it = idToObject.find(id);
		if (it == idToObject.end())
		{
			return { fbx_object_type_unknown, 0 };
		}
		return it->second; 
	}
};



static void resolveConnections(const fbx_node* connectionsNode, const std::vector<fbx_node>& nodes, const std::vector<fbx_property>& properties,
	fbx_object_lut& lut)
{
	for (const fbx_node& node : fbx_node_iterator{ connectionsNode, nodes })
	{
		ASSERT(node.name == "C");

		auto propIterator = fbx_property_iterator{ &node, properties }.begin();
		sized_string type = readString(*propIterator++);
		int64 idA = readInt64(*propIterator++);
		int64 idB = readInt64(*propIterator++);

		auto [typeA, indexA] = lut.find(idA);
		auto [typeB, indexB] = lut.find(idB);

		if (type == "OO")
		{
			// Object-object connection.
			if (typeA == fbx_object_type_global || typeB == fbx_object_type_global)
			{
				// Do nothing.
			}
			else if (typeA == fbx_object_type_model && typeB == fbx_object_type_model)
			{
				// Model-model connection -> A is child of B.
				fbx_model& a = lut.models[indexA];
				fbx_model& b = lut.models[indexB];
				b.children.push_back(&a);
				a.parent = &b;
			}
			else if (typeA == fbx_object_type_material && typeB == fbx_object_type_model)
			{
				// Material-model connection -> A is one of B's materials.
				fbx_material& a = lut.materials[indexA];
				fbx_model& b = lut.models[indexB];
				b.materials.push_back(&a);
			}
			else if (typeA == fbx_object_type_model && typeB == fbx_object_type_deformer)
			{
				// Model-deformer connection -> B influences A.
				fbx_model& a = lut.models[indexA];
				fbx_deformer& b = lut.deformers[indexB];
				b.model = &a;
				a.deformer = &b;
			}
			else if (typeA == fbx_object_type_mesh && typeB == fbx_object_type_model)
			{
				// Mesh-model connection -> B has mesh A.
				fbx_mesh& a = lut.meshes[indexA];
				fbx_model& b = lut.models[indexB];
				b.meshes.push_back(&a);
				a.model = &b;
			}
			else if (typeA == fbx_object_type_deformer && typeB == fbx_object_type_mesh)
			{
				// Deformer-mesh connection -> A deforms B.
				fbx_deformer& a = lut.deformers[indexA];
				fbx_mesh& b = lut.meshes[indexB];
				ASSERT(b.skeletonID == 0);
				b.skeletonID = idA;
			}
			else if (typeA == fbx_object_type_deformer && typeB == fbx_object_type_deformer)
			{
				// Deformer-deformer connection -> A is part of B's skeleton, not necessarily its direct child!.
				fbx_deformer& a = lut.deformers[indexA];
				fbx_deformer& b = lut.deformers[indexB];

				fbx_skeleton& skel = lut.skeletons[idB];
				a.jointID = (uint32)skel.joints.size();
				a.skeletonID = idB;
				skel.joints.push_back(&a);
			}
			else if (typeA == fbx_object_type_animation_layer && typeB == fbx_object_type_animation_stack)
			{
				// Layer-stack connection -> A is one of B's layers.
				fbx_animation_layer& a = lut.animationLayers[indexA];
				fbx_animation_stack& b = lut.animationStacks[indexB];
				b.layers.push_back(&a);
			}
			else if (typeA == fbx_object_type_animation_curve_node && typeB == fbx_object_type_animation_layer)
			{
				// Curvenode-layer connection -> A influences one of B's joints.
				fbx_animation_curve_node& a = lut.animationCurveNodes[indexA];
				fbx_animation_layer& b = lut.animationLayers[indexB];
				b.curveNodes.push_back(&a);
			}
			else
			{
				//printf("Unhandled OO connection: %s - %s.\n", objectTypeNames[typeA], objectTypeNames[typeB]);
			}
		}
		else if (type == "OP")
		{
			// Object-property connection.
			sized_string slot = readString(*propIterator++);

			if (typeA == fbx_object_type_texture && typeB == fbx_object_type_material)
			{
				// Texture-material connection -> B uses A.
				fbx_texture& a = lut.textures[indexA];
				fbx_material& b = lut.materials[indexB];

				if (slot == "DiffuseColor") { b.albedoTexture = &a; }
				else if (slot == "NormalMap") { b.normalTexture = &a; }
				else if (slot == "ShininessExponent") { b.roughnessTexture = &a; }
				else if (slot == "ReflectionFactor") { b.metallicTexture = &a; }
				else { printf("Unknown texture slot '%.*s'.\n", slot.length, slot.str); }
			}
			else if (typeA == fbx_object_type_animation_curve_node && typeB == fbx_object_type_model)
			{
				// Curvenode-model connection -> A influences properties of B (translation, rotation, or scale).
				fbx_animation_curve_node& a = lut.animationCurveNodes[indexA];
				fbx_model& b = lut.models[indexB];

				int32 index = -1;
				if (slot == "Lcl Translation") { index = 0; }
				else if (slot == "Lcl Rotation") { index = 1; }
				else if (slot == "Lcl Scaling") { index = 2; }
				else { printf("Unknown curve node slot '%.*s'.\n", slot.length, slot.str); }

				a.model = &b;
				a.propertyIndex = index;
			}
			else if (typeA == fbx_object_type_animation_curve && typeB == fbx_object_type_animation_curve_node)
			{
				// Curve-curvenode connection -> A describes changes in B (x, y, or z).
				fbx_animation_curve& a = lut.animationCurves[indexA];
				fbx_animation_curve_node& b = lut.animationCurveNodes[indexB];

				if (slot == "d|X") { b.xCurve = &a; }
				else if (slot == "d|Y") { b.yCurve = &a; }
				else if (slot == "d|Z") { b.zCurve = &a; }
				else { printf("Unknown curve slot '%.*s'.\n", slot.length, slot.str); }
			}
			else
			{
				//printf("Unhandled OP connection: %s - %s.\n", objectTypeNames[typeA], objectTypeNames[typeB]);
			}
		}
	}

	for (fbx_deformer& deformer : lut.deformers)
	{
		if (fbx_model* model = deformer.model)
		{
			if (fbx_model* parentModel = model->parent)
			{
				if (fbx_deformer* parentDeformer = parentModel->deformer)
				{
					deformer.parentID = parentDeformer->jointID;
				}
			}
		}
	}


	for (fbx_animation_stack& stack : lut.animationStacks)
	{
		fbx_animation& anim = lut.animations.emplace_back();
		anim.duration = stack.duration;
		anim.name = nameToString(stack.name);

		ASSERT(stack.layers.size() == 1);
		for (fbx_animation_layer* layer : stack.layers)
		{
			for (fbx_animation_curve_node* curveNode : layer->curveNodes)
			{
				if (fbx_model* model = curveNode->model)
				{
					fbx_animation_joint& joint = anim.joints[model->id];
					joint.curveNodes[curveNode->propertyIndex] = curveNode;
				}
			}
		}
	}
}

static void finishMesh(fbx_mesh& mesh, uint32 flags, std::unordered_map<int64, fbx_skeleton>& skeletons)
{
	// Assign materials and skinning weights, remove duplicate vertices and triangulate.

	if (mesh.skeletonID && flags & mesh_flag_load_skin)
	{
		PROFILE("Assigning skinning weights");

		mesh.skin.resize(mesh.positions.size(), {});
		fbx_skeleton& skeleton = skeletons[mesh.skeletonID];

		for (uint32 jointID = 0; jointID < (uint32)skeleton.joints.size(); ++jointID)
		{
			fbx_deformer* joint = skeleton.joints[jointID];

			auto& indices = joint->vertexIndices;
			auto& weights = joint->weights;
			ASSERT(indices.size() == weights.size());

			for (uint32 i = 0; i < (uint32)indices.size(); ++i)
			{
				int32 index = indices[i];
				uint8 weight = (uint8)clamp(weights[i] * 255.f, 0.f, 255.f);
				if (weight == 0)
				{
					continue;
				}

				uint32 offset = mesh.vertexOffsetCounts[index].offset;
				uint32 count = mesh.vertexOffsetCounts[index].count;
				for (uint32 j = 0; j < count; ++j)
				{
					uint32 vertexIndex = mesh.originalToNewVertex[j + offset];

					skinning_weights& skin = mesh.skin[vertexIndex];

					int32 slot = -1;
					for (int32 k = 0; k < 4; ++k)
					{
						if (skin.skinWeights[k] < weight)
						{
							slot = k;
							break;
						}
					}
					if (slot != -1)
					{
						if (skin.skinWeights[3] != 0)
						{
							//printf("Warning: Vertex is influences by more than 4 joints. Ditching joint with weight %f.\n", skin.skinWeights[3] / 255.f);
						}
						for (int32 k = 3; k > slot; --k)
						{
							skin.skinIndices[k] = skin.skinIndices[k - 1];
							skin.skinWeights[k] = skin.skinWeights[k - 1];
						}
						skin.skinIndices[slot] = (uint8)jointID;
						skin.skinWeights[slot] = weight;
					}
					else
					{
						//printf("Warning: Vertex is influences by more than 4 joints. Ditching joint with weight %f.\n", weights[i]);
					}
				}
			}
		}
	}



	std::unordered_map<int32, per_material> materialToMesh;

	{
		PROFILE("Triangulating & duplicate vertex removal");
		for (int32 faceIndex = 0, firstIndex = 0; faceIndex < (int32)mesh.faceSizes.size(); ++faceIndex)
		{
			int32 faceSize = mesh.faceSizes[faceIndex];
			int32 material = mesh.materialIndexPerFace[faceIndex];

			per_material& perMat = materialToMesh[material];
			perMat.sub.materialIndex = material;

			perMat.addTriangles(mesh.positions, mesh.uvs, mesh.normals, mesh.tangents, mesh.colors, mesh.skin, firstIndex, faceSize, mesh.submeshes);

			firstIndex += faceSize;
		}
	}

	for (auto [i, perMat] : materialToMesh)
	{
		perMat.flush(mesh.submeshes);
	}

	generateNormalsAndTangents(mesh.submeshes, flags);
}


static float sampleAnimationCurve(fbx_animation_curve* curve, int64 time, const std::vector<int64>& animationTimes, const std::vector<float>& animationValues)
{
	uint32 first = curve->first;
	uint32 count = curve->count;
	if (count == 0)
	{
		return curve->defaultValue;
	}
	else if (time >= animationTimes[first + count - 1])
	{
		return animationValues[first + count - 1];
	}
	else if (time <= 0)
	{
		return animationValues[first];
	}

	uint32 index = first;
	while (index < first + count - 1)
	{
		if (time < animationTimes[index + 1])
		{
			break;
		}

		++index;
	}

	uint32 i0 = index;
	uint32 i1 = index + 1;

	float t = (float)(time - animationTimes[i0]) / (float)(animationTimes[i1] - animationTimes[i0]);
	return lerp(animationValues[i0], animationValues[i1], t);
};

static offset_count transferAnimationCurve(fbx_animation_curve_node* curveNode, std::vector<vec3>& outValues, std::vector<float>& outTimes, int64 animationDuration,
	const std::vector<int64>& animationTimes, const std::vector<float>& animationValues)
{
	fbx_animation_curve* x = curveNode->xCurve;
	fbx_animation_curve* y = curveNode->yCurve;
	fbx_animation_curve* z = curveNode->zCurve;

	uint32 count = max(max(x->count, y->count), max(z->count, 2u));
	offset_count result = { (uint32)outValues.size(), count };

	int64 step = animationDuration / (count - 1);
	int64 time = 0;

	for (uint32 i = 0; i < count; ++i)
	{
		vec3 value;
		value.x = sampleAnimationCurve(x, time, animationTimes, animationValues);
		value.y = sampleAnimationCurve(y, time, animationTimes, animationValues);
		value.z = sampleAnimationCurve(z, time, animationTimes, animationValues);

		outValues.push_back(value);
		outTimes.push_back(convertTime(time));

		time += step;
	}

	return result;
};

static quat convertRotation(vec3 rotation, rotation_order order)
{
	quat x(vec3(1.f, 0.f, 0.f), deg2rad(rotation.x));
	quat y(vec3(0.f, 1.f, 0.f), deg2rad(rotation.y));
	quat z(vec3(0.f, 0.f, 1.f), deg2rad(rotation.z));

	switch (order)
	{
		case rotation_order_xyz: return z * y * x;
		case rotation_order_xzy: return y * z * x;
		case rotation_order_yzx: return x * z * y;
		case rotation_order_yxz: return z * x * y;
		case rotation_order_zxy: return y * x * z;
		case rotation_order_zyx: return x * y * z;
		case rotation_order_spheric_xyz: ASSERT(false); return quat::identity;
		default: ASSERT(false); return quat::identity;
	}
}

static offset_count transferAnimationCurve(fbx_animation_curve_node* curveNode, std::vector<quat>& outValues, std::vector<float>& outTimes, int64 animationDuration,
	const std::vector<int64>& animationTimes, const std::vector<float>& animationValues, rotation_order rotationOrder)
{
	fbx_animation_curve* x = curveNode->xCurve;
	fbx_animation_curve* y = curveNode->yCurve;
	fbx_animation_curve* z = curveNode->zCurve;

	uint32 count = max(max(x->count, y->count), max(z->count, 2u));
	offset_count result = { (uint32)outValues.size(), count };

	int64 step = animationDuration / (count - 1);
	int64 time = 0;

	for (uint32 i = 0; i < count; ++i)
	{
		vec3 value;
		value.x = sampleAnimationCurve(x, time, animationTimes, animationValues);
		value.y = sampleAnimationCurve(y, time, animationTimes, animationValues);
		value.z = sampleAnimationCurve(z, time, animationTimes, animationValues);

		outValues.push_back(convertRotation(value, rotationOrder));
		outTimes.push_back(convertTime(time));

		time += step;
	}

	return result;
}



static const fbx_node* findNode(const std::vector<fbx_node>& nodes, std::initializer_list<sized_string> names)
{
	uint32 currentNode = nodes[0].firstChild;
	const sized_string* currentName = names.begin();

	while (currentNode != -1)
	{
		if (nodes[currentNode].name == *currentName)
		{
			++currentName;
			if (currentName == names.end())
			{
				return &nodes[currentNode];
			}
			else
			{
				currentNode = nodes[currentNode].firstChild;
			}
		}
		else
		{
			currentNode = nodes[currentNode].next;
		}
	}
	return 0;
}

model_asset loadFBX(const fs::path& path, uint32 flags)
{
	std::string pathStr = path.string();
	const char* s = pathStr.c_str();
	entire_file file = loadFile(path);
	if (file.size < sizeof(fbx_header))
	{
		printf("File '%s' is smaller than FBX header.\n", s);
		freeFile(file);
		return {};
	}

	fbx_header* header = file.consume<fbx_header>();
	if ((strcmp(header->magic, "Kaydara FBX Binary  ") != 0) || header->unknown[0] != 0x1A || header->unknown[1] != 0x00)
	{
		printf("Header of file '%s' does not match FBX spec.\n", s);
		freeFile(file);
		return {};
	}

	uint32 version = header->version;

	std::vector<fbx_node> nodes;
	fbx_node node = {};
	node.parent = -1;
	node.level = -1;
	node.next = -1;
	node.firstChild = -1;
	node.lastChild = -1;
	node.numChildren = 0;
	nodes.push_back(node);

	std::vector<fbx_property> properties;

	{
		PROFILE("Parse FBX nodes");
		parseNodes(version, file, nodes, properties, 0, 0);
	}

#if 0
	{
		YAML::Node out;
		writeFBXContentToYAML(nodes, properties, nodes[0], out);
		std::ofstream fout("fbx.yaml");
		fout << out;
		return {};
	}
#endif

	fbx_definitions definitions = readDefinitions(*findNode(nodes, { "Definitions" }), nodes, properties);
	fbx_global_settings globalSettings = readGlobalSettings(*findNode(nodes, { "GlobalSettings" }), nodes, properties);

	
	fbx_object_lut objectLUT;
	objectLUT.reserve(definitions);

	std::vector<int64> animationTimes;
	std::vector<float> animationValues;


	{
		PROFILE("Reading FBX objects");

		const fbx_node* objectsNode = findNode(nodes, { "Objects" });
		objectLUT.idToObject.reserve(objectsNode->numChildren + 1);
		objectLUT.idToObject[0] = { fbx_object_type_global, 0 };

		for (const fbx_node& objectNode : fbx_node_iterator{ objectsNode, nodes })
		{
			if (objectNode.name == "Model")
			{
				objectLUT.push(readModel(objectNode, nodes, properties));
			}
			if (objectNode.name == "Geometry")
			{
				objectLUT.push(readMesh(objectNode, nodes, properties, flags));
			}
			else if (objectNode.name == "Material")
			{
				objectLUT.push(readMaterial(objectNode, nodes, properties));
			}
			else if (objectNode.name == "Texture")
			{
				objectLUT.push(readTexture(objectNode, nodes, properties));
			}
			else if (objectNode.name == "Deformer")
			{
				objectLUT.push(readDeformer(objectNode, nodes, properties));
			}
			else if (objectNode.name == "AnimationStack")
			{
				objectLUT.push(readAnimationStack(objectNode, nodes, properties));
			}
			else if (objectNode.name == "AnimationLayer")
			{
				objectLUT.push(readAnimationLayer(objectNode, nodes, properties));
			}
			else if (objectNode.name == "AnimationCurveNode")
			{
				objectLUT.push(readAnimationCurveNode(objectNode, nodes, properties));
			}
			else if (objectNode.name == "AnimationCurve")
			{
				objectLUT.push(readAnimationCurve(objectNode, nodes, properties, animationTimes, animationValues));
			}
		}
	}

	{
		PROFILE("Resolving FBX connections");
		resolveConnections(findNode(nodes, { "Connections" }), nodes, properties, objectLUT);
	}

	{
		PROFILE("Finishing FBX meshes");
		for (fbx_mesh& mesh : objectLUT.meshes)
		{
			finishMesh(mesh, flags, objectLUT.skeletons);
		}
	}


	std::unordered_map<fbx_material*, int32> materialToGlobalIndex;
	int32 globalMaterialIndex = 0;
	for (fbx_material& mat : objectLUT.materials)
	{
		materialToGlobalIndex[&mat] = globalMaterialIndex++;
	}

	for (fbx_mesh& mesh : objectLUT.meshes)
	{
		fbx_model* model = mesh.model;
		for (submesh_asset& sub : mesh.submeshes)
		{
			fbx_material* mat = model->materials[sub.materialIndex];
			sub.materialIndex = materialToGlobalIndex[mat];
		}
	}

	model_asset result;
	result.flags = flags;

	result.materials.reserve(objectLUT.materials.size());
	for (fbx_material& material : objectLUT.materials)
	{
		pbr_material_desc out;
		out.albedo = material.albedoTexture ? relativeFilepath(material.albedoTexture->relativeFilename, path) : std::string();
		out.normal = material.normalTexture ? relativeFilepath(material.normalTexture->relativeFilename, path) : std::string();
		out.roughness = material.roughnessTexture ? relativeFilepath(material.roughnessTexture->relativeFilename, path) : std::string();
		out.metallic = material.metallicTexture ? relativeFilepath(material.metallicTexture->relativeFilename, path) : std::string();
		out.albedoTint = material.albedoTint;
		out.emission = material.emission;
		out.metallicOverride = material.metallicOverride;
		out.roughnessOverride = material.roughnessOverride;
		out.shader = material.shader;
		out.translucency = material.translucency;
		out.uvScale = material.uvScale;

		result.materials.push_back(std::move(out));
	}
	
	result.meshes.reserve(objectLUT.meshes.size());
	for (fbx_mesh& mesh : objectLUT.meshes)
	{
		result.meshes.push_back(mesh_asset{ nameToString(mesh.model->name), std::move(mesh.submeshes), -1 });
	}

	for (auto& [id, skeleton] : objectLUT.skeletons)
	{
		uint32 numJoints = (uint32)skeleton.joints.size();

		skeleton_asset out;
		out.joints.reserve(numJoints);
		for (uint32 i = 0; i < numJoints; ++i)
		{
			fbx_deformer* joint = skeleton.joints[i];
			std::string name = nameToString(joint->model->name);

			out.nameToJointID[name] = i;
			out.joints.push_back({ std::move(name), limb_type_unknown, false, joint->invBindMatrix, invert(joint->invBindMatrix), joint->parentID });
		}

		ASSERT(out.joints.size() == out.nameToJointID.size());


		for (uint32 i = 0; i < (uint32)objectLUT.meshes.size(); ++i)
		{
			if (objectLUT.meshes[i].skeletonID == id)
			{
				result.meshes[i].skeletonIndex = (uint32)result.skeletons.size();
			}
		}

		result.skeletons.push_back(std::move(out));
	}

	for (fbx_animation& animation : objectLUT.animations)
	{
		uint32 numJoints = (uint32)animation.joints.size();

		if (numJoints)
		{
			animation_asset out;
			out.duration = convertTime(animation.duration);
			out.joints.reserve(animation.joints.size());
			out.name = animation.name;

			for (auto [id, j] : animation.joints)
			{
				auto [modelType, modelIndex] = objectLUT.find(id);
				ASSERT(modelType == fbx_object_type_model);

				fbx_model& model = objectLUT.models[modelIndex];
				std::string name = nameToString(model.name);

				animation_joint& joint = out.joints[name];
				joint.isAnimated = true;

				offset_count position = transferAnimationCurve(j.curveNodes[0], out.positionKeyframes, out.positionTimestamps, animation.duration, 
					animationTimes, animationValues);
				joint.firstPositionKeyframe = position.offset;
				joint.numPositionKeyframes = position.count;

				offset_count rotation = transferAnimationCurve(j.curveNodes[1], out.rotationKeyframes, out.rotationTimestamps, animation.duration,
					animationTimes, animationValues, definitions.defaultRotationOrder);
				joint.firstRotationKeyframe = rotation.offset;
				joint.numRotationKeyframes = rotation.count;

				offset_count scale = transferAnimationCurve(j.curveNodes[2], out.scaleKeyframes, out.scaleTimestamps, animation.duration,
					animationTimes, animationValues);
				joint.firstScaleKeyframe = scale.offset;
				joint.numScaleKeyframes = scale.count;
			}

			result.animations.push_back(std::move(out));
		}
	}

	freeFile(file);









#if 0
	for (uint32 i = 0; i < (uint32)result.meshes.size(); ++i)
	{
		const mesh_asset& mesh = result.meshes[i];
		std::string indexedName = "Mesh_" + std::to_string(i);

		for (uint32 j = 0; j < (uint32)mesh.submeshes.size(); ++j)
		{
			const submesh_asset& sub = mesh.submeshes[j];

			vec3 diffuseColor = !result.materials.empty() ? result.materials[sub.materialIndex].diffuseColor : vec3(1.f, 1.f, 1.f);

			std::string indexedName2 = indexedName + "_" + std::to_string(j) + ".ply";

			testDumpToPLY(indexedName2, sub.positions, sub.uvs, sub.normals, sub.triangles,
				(uint8)(diffuseColor.x * 255), (uint8)(diffuseColor.y * 255), (uint8)(diffuseColor.z * 255));
		}
	}
#endif






	return result;
}






```

`src/asset/file_registry.cpp`:

```cpp
#include "pch.h"
#include "file_registry.h"
#include "core/file_system.h"
#include "core/log.h"
#include "core/yaml.h"



typedef std::unordered_map<fs::path, asset_handle> path_to_handle;
typedef std::unordered_map<asset_handle, fs::path> handle_to_path;

static path_to_handle pathToHandle;
static handle_to_path handleToPath;

static std::mutex mutex;
static const fs::path registryPath = fs::path(L"resources/files.yaml").lexically_normal();


static path_to_handle loadRegistryFromDisk()
{
	path_to_handle loadedRegistry;

	std::ifstream stream(registryPath);
	YAML::Node n = YAML::Load(stream);

	for (auto entryNode : n)
	{
		asset_handle handle = 0;
		fs::path path;

		YAML_LOAD(entryNode, handle, "Handle");
		YAML_LOAD(entryNode, path, "Path");

		if (handle)
		{
			loadedRegistry[path] = handle;
		}
	}

	return loadedRegistry;
}

static void writeRegistryToDisk()
{
	YAML::Node out;

	for (const auto& [path, handle] : pathToHandle)
	{
		YAML::Node n;
		n["Handle"] = handle;
		n["Path"] = path;
		out.push_back(n);
	}

	fs::create_directories(registryPath.parent_path());
	std::ofstream fout(registryPath);
	fout << out;
}

static void readDirectory(const fs::path& path, const path_to_handle& loadedRegistry)
{
	for (const auto& dirEntry : fs::directory_iterator(path))
	{
		const auto& path = dirEntry.path();
		if (dirEntry.is_directory())
		{
			readDirectory(path, loadedRegistry);
		}
		else
		{
			auto it = loadedRegistry.find(path);

			// If already known, use the handle, otherwise generate one.
			asset_handle handle = (it != loadedRegistry.end()) ? it->second : asset_handle::generate();

			pathToHandle.insert({ path, handle });
			handleToPath.insert({ handle, path });
		}
	}
}

static void handleAssetChange(const file_system_event& e)
{
	if (!fs::is_directory(e.path) && e.path != registryPath)
	{
		mutex.lock();
		switch (e.change)
		{
			case file_system_change_add:
			{
				LOG_MESSAGE("Asset '%ws' added", e.path.c_str());

				ASSERT(pathToHandle.find(e.path) == pathToHandle.end());

				asset_handle handle = asset_handle::generate();
				pathToHandle.insert({ e.path, handle });
				handleToPath.insert({ handle, e.path });
			} break;

			case file_system_change_delete:
			{
				LOG_MESSAGE("Asset '%ws' deleted", e.path.c_str());

				auto it = pathToHandle.find(e.path);

				ASSERT(it != pathToHandle.end());

				asset_handle handle = it->second;
				pathToHandle.erase(it);
				handleToPath.erase(handle);
			} break;

			case file_system_change_modify:
			{
				LOG_MESSAGE("Asset '%ws' modified", e.path.c_str());
			} break;

			case file_system_change_rename:
			{
				LOG_MESSAGE("Asset renamed from '%ws' to '%ws'", e.oldPath.c_str(), e.path.c_str());

				auto oldIt = pathToHandle.find(e.oldPath);

				ASSERT(oldIt != pathToHandle.end()); // Old path exists.
				ASSERT(pathToHandle.find(e.path) == pathToHandle.end()); // New path does not exist.

				asset_handle handle = oldIt->second;
				pathToHandle.erase(oldIt);
				pathToHandle.insert({ e.path, handle });
				handleToPath[handle] = e.path; // Replace.
			} break;
		}
		mutex.unlock();

		// During runtime the registry is only written to in this function, so no need to protect the read with mutex.
		LOG_MESSAGE("Rewriting file registry");
		writeRegistryToDisk();
	}
}

asset_handle getAssetHandleFromPath(const fs::path& path)
{
	const std::lock_guard<std::mutex> lock(mutex);

	auto it = pathToHandle.find(path);
	if (it == pathToHandle.end())
	{
		return {};
	}
	return it->second;
}

fs::path getPathFromAssetHandle(asset_handle handle)
{
	const std::lock_guard<std::mutex> lock(mutex);

	auto it = handleToPath.find(handle);
	if (it == handleToPath.end())
	{
		return {};
	}
	return it->second;
}

void initializeFileRegistry()
{
	auto loadedRegistry = loadRegistryFromDisk();
	readDirectory(L"assets", loadedRegistry);
	writeRegistryToDisk();

	observeDirectory(L"assets", handleAssetChange);
}

```

`src/asset/file_registry.h`:

```h
#pragma once

#include "asset.h"

asset_handle getAssetHandleFromPath(const fs::path& path);
fs::path getPathFromAssetHandle(asset_handle handle);


void initializeFileRegistry();

```

`src/asset/image.cpp`:

```cpp
#include "pch.h"
#include "image.h"
#include "core/log.h"
#include "core/memory.h"


#include <DirectXTex/DirectXTex.h>

#define NANOSVG_IMPLEMENTATION
#include <nanosvg/nanosvg.h>

#define NANOSVGRAST_IMPLEMENTATION
#include <nanosvg/nanosvgrast.h>

#include <wincodec.h>


bool isImageExtension(const fs::path& extension)
{
	return extension == ".jpg" ||
		extension == ".png" ||
		extension == ".tga" ||
		extension == ".hdr" ||
		extension == ".dds";
}

bool isImageExtension(const std::string& extension)
{
	return extension == ".jpg" ||
		extension == ".png" ||
		extension == ".tga" ||
		extension == ".hdr" ||
		extension == ".dds";
}

static DXGI_FORMAT makeSRGB(DXGI_FORMAT format)
{
	return DirectX::MakeSRGB(format);
}

static DXGI_FORMAT makeLinear(DXGI_FORMAT format)
{
	switch (format)
	{
		case DXGI_FORMAT_R8G8B8A8_UNORM_SRGB:
			format = DXGI_FORMAT_R8G8B8A8_UNORM;
			break;

		case DXGI_FORMAT_BC1_UNORM_SRGB:
			format = DXGI_FORMAT_BC1_UNORM;
			break;

		case DXGI_FORMAT_BC2_UNORM_SRGB:
			format = DXGI_FORMAT_BC2_UNORM;
			break;

		case DXGI_FORMAT_BC3_UNORM_SRGB:
			format = DXGI_FORMAT_BC3_UNORM;
			break;

		case DXGI_FORMAT_B8G8R8A8_UNORM_SRGB:
			format = DXGI_FORMAT_B8G8R8A8_UNORM;
			break;

		case DXGI_FORMAT_B8G8R8X8_UNORM_SRGB:
			format = DXGI_FORMAT_B8G8R8X8_UNORM;
			break;

		case DXGI_FORMAT_BC7_UNORM_SRGB:
			format = DXGI_FORMAT_BC7_UNORM;
			break;
	}
	return format;
}

static bool tryLoadFromCache(const fs::path& filepath, uint32 flags, fs::path& cacheFilepath, DirectX::ScratchImage& scratchImage, DirectX::TexMetadata& metadata)
{
	fs::path cachedFilename = filepath;
	cachedFilename.replace_extension("." + std::to_string(flags) + ".cache.dds");

	cacheFilepath = L"asset_cache" / cachedFilename;

	bool fromCache = false;

	if (!(flags & image_load_flags_always_load_from_source))
	{
		// Look for cached.

		WIN32_FILE_ATTRIBUTE_DATA cachedData;
		if (GetFileAttributesExW(cacheFilepath.c_str(), GetFileExInfoStandard, &cachedData))
		{
			FILETIME cachedFiletime = cachedData.ftLastWriteTime;

			WIN32_FILE_ATTRIBUTE_DATA originalData;
			ASSERT(GetFileAttributesExW(filepath.c_str(), GetFileExInfoStandard, &originalData));
			FILETIME originalFiletime = originalData.ftLastWriteTime;

			if (CompareFileTime(&cachedFiletime, &originalFiletime) >= 0)
			{
				// Cached file is newer than original, so load this.
				fromCache = SUCCEEDED(DirectX::LoadFromDDSFile(cacheFilepath.c_str(), DirectX::DDS_FLAGS_NONE, &metadata, scratchImage));
			}
		}
	}

	return fromCache;
}

static void createDesc(DirectX::TexMetadata& metadata, uint32 flags, D3D12_RESOURCE_DESC& textureDesc)
{
	if (flags & image_load_flags_allocate_full_mipchain)
	{
		metadata.mipLevels = 0;
	}

	switch (metadata.dimension)
	{
		case DirectX::TEX_DIMENSION_TEXTURE1D:
			textureDesc = CD3DX12_RESOURCE_DESC::Tex1D(metadata.format, metadata.width, (uint16)metadata.arraySize, (uint16)metadata.mipLevels);
			break;
		case DirectX::TEX_DIMENSION_TEXTURE2D:
			textureDesc = CD3DX12_RESOURCE_DESC::Tex2D(metadata.format, metadata.width, (uint32)metadata.height, (uint16)metadata.arraySize, (uint16)metadata.mipLevels);
			break;
		case DirectX::TEX_DIMENSION_TEXTURE3D:
			textureDesc = CD3DX12_RESOURCE_DESC::Tex3D(metadata.format, metadata.width, (uint32)metadata.height, (uint16)metadata.depth, (uint16)metadata.mipLevels);
			break;
		default:
			ASSERT(false);
			break;
	}
}

static void postProcessImage(DirectX::ScratchImage& scratchImage, DirectX::TexMetadata& metadata, uint32 flags, const fs::path& filepath, const fs::path& cacheFilepath)
{
	if (flags & image_load_flags_noncolor)
	{
		metadata.format = makeLinear(metadata.format);
	}
	else
	{
		metadata.format = makeSRGB(metadata.format);
	}

	scratchImage.OverrideFormat(metadata.format);

	if (flags & image_load_flags_gen_mips_on_cpu && !DirectX::IsCompressed(metadata.format))
	{
		DirectX::ScratchImage mipchainImage;

		checkResult(DirectX::GenerateMipMaps(scratchImage.GetImages(), scratchImage.GetImageCount(), metadata, DirectX::TEX_FILTER_DEFAULT, 0, mipchainImage));
		scratchImage = std::move(mipchainImage);
		metadata = scratchImage.GetMetadata();
	}
	else
	{
		metadata.mipLevels = max(1u, (uint32)metadata.mipLevels);
	}

	if (flags & image_load_flags_premultiply_alpha)
	{
		DirectX::ScratchImage premultipliedAlphaImage;

		checkResult(DirectX::PremultiplyAlpha(scratchImage.GetImages(), scratchImage.GetImageCount(), metadata, DirectX::TEX_PMALPHA_DEFAULT, premultipliedAlphaImage));
		scratchImage = std::move(premultipliedAlphaImage);
		metadata = scratchImage.GetMetadata();
	}

	if (DirectX::IsCompressed(metadata.format) && metadata.width == 1 && metadata.height == 1)
	{
		ASSERT(metadata.mipLevels == 1);
		ASSERT(scratchImage.GetImageCount() == 1);

		DirectX::TexMetadata scaledMetadata = metadata;
		scaledMetadata.width = 4;
		scaledMetadata.height = 4;
		scaledMetadata.mipLevels = 1;

		DirectX::ScratchImage scaledImage;
		checkResult(scaledImage.Initialize(scaledMetadata));

		memcpy(scaledImage.GetImage(0, 0, 0)->pixels, scratchImage.GetImage(0, 0, 0)->pixels, scratchImage.GetPixelsSize());

		scratchImage = std::move(scaledImage);
		metadata = scratchImage.GetMetadata();
	}

	if (flags & image_load_flags_compress && !DirectX::IsCompressed(metadata.format))
	{
		if (metadata.width % 4 == 0 && metadata.height % 4 == 0)
		{
			uint32 numChannels = getNumberOfChannels(metadata.format);

			DXGI_FORMAT compressedFormat;

			switch (numChannels)
			{
				case 1: compressedFormat = DXGI_FORMAT_BC4_UNORM; break;
				case 2: compressedFormat = DXGI_FORMAT_BC5_UNORM; break;

				case 3:
				case 4:
				{
					if (scratchImage.IsAlphaAllOpaque())
					{
						compressedFormat = DirectX::IsSRGB(metadata.format) ? DXGI_FORMAT_BC1_UNORM_SRGB : DXGI_FORMAT_BC1_UNORM;
					}
					else
					{
						compressedFormat = DirectX::IsSRGB(metadata.format) ? DXGI_FORMAT_BC3_UNORM_SRGB : DXGI_FORMAT_BC3_UNORM;  // 7 would be better, but takes forever to compress.
					}
				} break;
			}

			DirectX::ScratchImage compressedImage;

			checkResult(DirectX::Compress(scratchImage.GetImages(), scratchImage.GetImageCount(), metadata,
				compressedFormat, DirectX::TEX_COMPRESS_PARALLEL, DirectX::TEX_THRESHOLD_DEFAULT, compressedImage));
			scratchImage = std::move(compressedImage);
			metadata = scratchImage.GetMetadata();
		}
		else
		{
			LOG_ERROR("Cannot compress texture '%ws', since its dimensions are not a multiple of 4", filepath.c_str());
			std::cerr << "Cannot compress texture '" << filepath << "', since its dimensions are not a multiple of 4.\n";
		}
	}

	if (flags & image_load_flags_cache_to_dds)
	{
		fs::create_directories(cacheFilepath.parent_path());
		checkResult(DirectX::SaveToDDSFile(scratchImage.GetImages(), scratchImage.GetImageCount(), metadata, DirectX::DDS_FLAGS_NONE, cacheFilepath.c_str()));
	}
}

bool loadImageFromMemory(const void* data, uint32 size, image_format imageFormat, const fs::path& cachingFilepath,
	uint32 flags, DirectX::ScratchImage& scratchImage, D3D12_RESOURCE_DESC& textureDesc)
{
	if (flags & image_load_flags_gen_mips_on_gpu)
	{
		flags &= ~image_load_flags_gen_mips_on_cpu;
		flags |= image_load_flags_allocate_full_mipchain;
	}


	fs::path cachedFilename = cachingFilepath.string() + std::to_string(flags) + ".cache.dds";
	fs::path cacheFilepath = L"asset_cache" / cachedFilename;

	bool fromCache = false;
	DirectX::TexMetadata metadata;

	if (!(flags & image_load_flags_always_load_from_source))
	{
		// Look for cached.

		if (fs::exists(cacheFilepath))
		{
			fromCache = SUCCEEDED(DirectX::LoadFromDDSFile(cacheFilepath.c_str(), DirectX::DDS_FLAGS_NONE, &metadata, scratchImage));
		}
	}

	if (!fromCache)
	{
		if (flags & image_load_flags_cache_to_dds)
		{
			LOG_MESSAGE("Preprocessing in-memory texture '%ws' for faster loading next time", cachingFilepath.c_str());
			std::cout << "Preprocessing in-memory texture '" << cachingFilepath.string() << "' for faster loading next time.";
#ifdef _DEBUG
			std::cout << " Consider running in a release build the first time.";
#endif
			std::cout << '\n';
		}


		if (imageFormat == image_format_dds)
		{
			if (FAILED(DirectX::LoadFromDDSMemory(data, size, DirectX::DDS_FLAGS_NONE, &metadata, scratchImage)))
			{
				return false;
			}
		}
		else if (imageFormat == image_format_hdr)
		{
			if (FAILED(DirectX::LoadFromHDRMemory(data, size, &metadata, scratchImage)))
			{
				return false;
			}
		}
		else if (imageFormat == image_format_tga)
		{
			if (FAILED(DirectX::LoadFromTGAMemory(data, size, &metadata, scratchImage)))
			{
				return false;
			}
		}
		else
		{
			ASSERT(imageFormat == image_format_wic);

			if (FAILED(DirectX::LoadFromWICMemory(data, size, DirectX::WIC_FLAGS_FORCE_RGB, &metadata, scratchImage)))
			{
				return false;
			}
		}

		postProcessImage(scratchImage, metadata, flags, cacheFilepath, cacheFilepath);
	}

	createDesc(metadata, flags, textureDesc);

	return true;
}

bool loadSVGFromFile(const fs::path& filepath, uint32 flags, DirectX::ScratchImage& scratchImage, D3D12_RESOURCE_DESC& textureDesc)
{
	fs::path cacheFilepath;
	DirectX::TexMetadata metadata;
	bool fromCache = tryLoadFromCache(filepath, flags, cacheFilepath, scratchImage, metadata);

	if (!fromCache)
	{
		if (!fs::exists(filepath))
		{
			LOG_WARNING("Could not find file '%ws'", filepath.c_str());
			std::cerr << "Could not find file '" << filepath.string() << "'.\n";
			return false;
		}

		if (flags & image_load_flags_cache_to_dds)
		{
			LOG_MESSAGE("Preprocessing asset '%ws' for faster loading next time", filepath.c_str());
			std::cout << "Preprocessing asset '" << filepath.string() << "' for faster loading next time.";
#ifdef _DEBUG
			std::cout << " Consider running in a release build the first time.";
#endif
			std::cout << '\n';
		}

		NSVGimage* svg = nsvgParseFromFile(filepath.string().c_str(), "px", 96);
		uint32 width = (uint32)ceil(svg->width);
		uint32 height = (uint32)ceil(svg->height);

		uint8* rawImage = new uint8[width * height * 4];

		NSVGrasterizer* rasterizer = nsvgCreateRasterizer();
		nsvgRasterize(rasterizer, svg, 0, 0, 1, rawImage, width, height, width * 4);
		nsvgDeleteRasterizer(rasterizer);

		nsvgDelete(svg);


		DirectX::Image dxImage = { width, height, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, width * 4, width * height * 4, rawImage };
		scratchImage.InitializeFromImage(dxImage);
		metadata = scratchImage.GetMetadata();

		postProcessImage(scratchImage, metadata, flags, filepath, cacheFilepath);

		delete[] rawImage;
	}

	createDesc(metadata, flags, textureDesc);

	return true;
}

bool loadImageFromFile(const fs::path& filepath, uint32 flags, DirectX::ScratchImage& scratchImage, D3D12_RESOURCE_DESC& textureDesc)
{
	fs::path cacheFilepath;
	DirectX::TexMetadata metadata;
	bool fromCache = tryLoadFromCache(filepath, flags, cacheFilepath, scratchImage, metadata);

	if (!fromCache)
	{
		if (!fs::exists(filepath))
		{
			LOG_WARNING("Could not find file '%ws'", filepath.c_str());
			std::cerr << "Could not find file '" << filepath.string() << "'.\n";
			return false;
		}

		if (flags & image_load_flags_cache_to_dds)
		{
			LOG_MESSAGE("Preprocessing asset '%ws' for faster loading next time", filepath.c_str());
			std::cout << "Preprocessing asset '" << filepath.string() << "' for faster loading next time.";
#ifdef _DEBUG
			std::cout << " Consider running in a release build the first time.";
#endif
			std::cout << '\n';
		}

		fs::path extension = filepath.extension();

		if (extension == ".dds")
		{
			if (FAILED(DirectX::LoadFromDDSFile(filepath.c_str(), DirectX::DDS_FLAGS_NONE, &metadata, scratchImage)))
			{
				return false;
			}
		}
		else if (extension == ".hdr")
		{
			if (FAILED(DirectX::LoadFromHDRFile(filepath.c_str(), &metadata, scratchImage)))
			{
				return false;
			}
		}
		else if (extension == ".tga")
		{
			if (FAILED(DirectX::LoadFromTGAFile(filepath.c_str(), &metadata, scratchImage)))
			{
				return false;
			}
		}
		else
		{
			if (FAILED(DirectX::LoadFromWICFile(filepath.c_str(), DirectX::WIC_FLAGS_FORCE_RGB, &metadata, scratchImage)))
			{
				return false;
			}
		}

		postProcessImage(scratchImage, metadata, flags, filepath, cacheFilepath);
	}

	createDesc(metadata, flags, textureDesc);

	return true;
}

bool saveImageToFile(const fs::path& filepath, DirectX::Image image)
{
	fs::path extension = filepath.extension();

	if (extension == ".dds")
	{
		return SUCCEEDED(DirectX::SaveToDDSFile(image, DirectX::DDS_FLAGS_NONE, filepath.c_str()));
	}
	else if (extension == ".tga")
	{
		return SUCCEEDED(DirectX::SaveToTGAFile(image, filepath.c_str()));
	}
	else
	{
		auto guid = (extension == ".png") ? GUID_ContainerFormatPng :
			(extension == ".jpg") ? GUID_ContainerFormatJpeg :
			GUID_ContainerFormatBmp;

		return SUCCEEDED(DirectX::SaveToWICFile(image, DirectX::WIC_FLAGS_NONE, GUID_ContainerFormatPng, filepath.c_str(), 0));
	}
}


```

`src/asset/image.h`:

```h
#pragma once

#include <dx/d3dx12.h>


// If the texture_load_flags_cache_to_dds flags is set, the system will cache the texture as DDS to disk for faster loading next time.
// Loading from cache is not done if the original file has a newer write time or if the cache was created with different flags.
// Therefore: If you change these flags in code, delete the texture cache!

enum image_load_flags
{
	image_load_flags_none = 0,
	image_load_flags_noncolor = (1 << 0),
	image_load_flags_compress = (1 << 1),
	image_load_flags_gen_mips_on_cpu = (1 << 2),
	image_load_flags_gen_mips_on_gpu = (1 << 3),
	image_load_flags_allocate_full_mipchain = (1 << 4), // Use if you want to create the mip chain on the GPU.
	image_load_flags_premultiply_alpha = (1 << 5),
	image_load_flags_cache_to_dds = (1 << 6),
	image_load_flags_always_load_from_source = (1 << 7), // By default the system will always try to load a cached version of the texture. You can prevent this with this flag.

	image_load_flags_default = image_load_flags_compress | image_load_flags_gen_mips_on_cpu | image_load_flags_cache_to_dds,
	image_load_flags_default_noncolor = image_load_flags_default | image_load_flags_noncolor,
};

enum image_format
{
	image_format_dds,
	image_format_hdr,
	image_format_tga,
	image_format_wic, // Other formats: png, jpeg, etc.
};


bool isImageExtension(const fs::path& extension);
bool isImageExtension(const std::string& extension);

namespace DirectX
{
	class ScratchImage;
	struct Image;
}

bool loadImageFromMemory(const void* data, uint32 size, image_format imageFormat, const fs::path& cachingFilepath,
	uint32 flags, DirectX::ScratchImage& scratchImage, D3D12_RESOURCE_DESC& textureDesc);
bool loadImageFromFile(const fs::path& filepath, uint32 flags, DirectX::ScratchImage& scratchImage, D3D12_RESOURCE_DESC& textureDesc);
bool loadSVGFromFile(const fs::path& filepath, uint32 flags, DirectX::ScratchImage& scratchImage, D3D12_RESOURCE_DESC& textureDesc);


bool saveImageToFile(const fs::path& filepath, DirectX::Image image);



static bool isUAVCompatibleFormat(DXGI_FORMAT format)
{
	switch (format)
	{
		case DXGI_FORMAT_R32G32B32A32_FLOAT:
		case DXGI_FORMAT_R32G32B32A32_UINT:
		case DXGI_FORMAT_R32G32B32A32_SINT:
		case DXGI_FORMAT_R16G16B16A16_FLOAT:
		case DXGI_FORMAT_R16G16B16A16_UINT:
		case DXGI_FORMAT_R16G16B16A16_SINT:
		case DXGI_FORMAT_R8G8B8A8_UNORM:
		case DXGI_FORMAT_R8G8B8A8_UINT:
		case DXGI_FORMAT_R8G8B8A8_SINT:
		case DXGI_FORMAT_R32_FLOAT:
		case DXGI_FORMAT_R32_UINT:
		case DXGI_FORMAT_R32_SINT:
		case DXGI_FORMAT_R16_FLOAT:
		case DXGI_FORMAT_R16_UINT:
		case DXGI_FORMAT_R16_SINT:
		case DXGI_FORMAT_R8_UNORM:
		case DXGI_FORMAT_R8_UINT:
		case DXGI_FORMAT_R8_SINT:
			return true;
		default:
			return false;
	}
}

static bool isSRGBFormat(DXGI_FORMAT format)
{
	switch (format)
	{
		case DXGI_FORMAT_R8G8B8A8_UNORM_SRGB:
		case DXGI_FORMAT_BC1_UNORM_SRGB:
		case DXGI_FORMAT_BC2_UNORM_SRGB:
		case DXGI_FORMAT_BC3_UNORM_SRGB:
		case DXGI_FORMAT_B8G8R8A8_UNORM_SRGB:
		case DXGI_FORMAT_B8G8R8X8_UNORM_SRGB:
		case DXGI_FORMAT_BC7_UNORM_SRGB:
			return true;
		default:
			return false;
	}
}

static bool isBGRFormat(DXGI_FORMAT format)
{
	switch (format)
	{
		case DXGI_FORMAT_B8G8R8A8_UNORM:
		case DXGI_FORMAT_B8G8R8X8_UNORM:
		case DXGI_FORMAT_B8G8R8A8_TYPELESS:
		case DXGI_FORMAT_B8G8R8A8_UNORM_SRGB:
		case DXGI_FORMAT_B8G8R8X8_TYPELESS:
		case DXGI_FORMAT_B8G8R8X8_UNORM_SRGB:
			return true;
		default:
			return false;
	}
}

static bool isDepthFormat(DXGI_FORMAT format)
{
	switch (format)
	{
		case DXGI_FORMAT_D32_FLOAT_S8X24_UINT:
		case DXGI_FORMAT_D32_FLOAT:
		case DXGI_FORMAT_D24_UNORM_S8_UINT:
		case DXGI_FORMAT_D16_UNORM:
			return true;
		default:
			return false;
	}
}

static bool isStencilFormat(DXGI_FORMAT format)
{
	switch (format)
	{
		case DXGI_FORMAT_D32_FLOAT_S8X24_UINT:
		case DXGI_FORMAT_D24_UNORM_S8_UINT:
			return true;
		default:
			return false;
	}
}

static DXGI_FORMAT getSRGBFormat(DXGI_FORMAT format)
{
	DXGI_FORMAT srgbFormat = format;
	switch (format)
	{
		case DXGI_FORMAT_R8G8B8A8_UNORM:
			srgbFormat = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
			break;
		case DXGI_FORMAT_BC1_UNORM:
			srgbFormat = DXGI_FORMAT_BC1_UNORM_SRGB;
			break;
		case DXGI_FORMAT_BC2_UNORM:
			srgbFormat = DXGI_FORMAT_BC2_UNORM_SRGB;
			break;
		case DXGI_FORMAT_BC3_UNORM:
			srgbFormat = DXGI_FORMAT_BC3_UNORM_SRGB;
			break;
		case DXGI_FORMAT_B8G8R8A8_UNORM:
			srgbFormat = DXGI_FORMAT_B8G8R8A8_UNORM_SRGB;
			break;
		case DXGI_FORMAT_B8G8R8X8_UNORM:
			srgbFormat = DXGI_FORMAT_B8G8R8X8_UNORM_SRGB;
			break;
		case DXGI_FORMAT_BC7_UNORM:
			srgbFormat = DXGI_FORMAT_BC7_UNORM_SRGB;
			break;
	}

	return srgbFormat;
}

static DXGI_FORMAT getUAVCompatibleFormat(DXGI_FORMAT format)
{
	DXGI_FORMAT uavFormat = format;

	switch (format)
	{
		case DXGI_FORMAT_R8G8B8A8_TYPELESS:
		case DXGI_FORMAT_R8G8B8A8_UNORM_SRGB:
		case DXGI_FORMAT_B8G8R8A8_UNORM:
		case DXGI_FORMAT_B8G8R8X8_UNORM:
		case DXGI_FORMAT_B8G8R8A8_TYPELESS:
		case DXGI_FORMAT_B8G8R8A8_UNORM_SRGB:
		case DXGI_FORMAT_B8G8R8X8_TYPELESS:
		case DXGI_FORMAT_B8G8R8X8_UNORM_SRGB:
			uavFormat = DXGI_FORMAT_R8G8B8A8_UNORM;
			break;
		case DXGI_FORMAT_R32_TYPELESS:
		case DXGI_FORMAT_D32_FLOAT:
			uavFormat = DXGI_FORMAT_R32_FLOAT;
			break;
	}

	return uavFormat;
}

static DXGI_FORMAT getDepthReadFormat(DXGI_FORMAT format)
{
	switch (format)
	{
		case DXGI_FORMAT_D32_FLOAT_S8X24_UINT: return DXGI_FORMAT_R32_FLOAT;
		case DXGI_FORMAT_D32_FLOAT: return DXGI_FORMAT_R32_FLOAT;
		case DXGI_FORMAT_D24_UNORM_S8_UINT: return DXGI_FORMAT_R24_UNORM_X8_TYPELESS;
		case DXGI_FORMAT_D16_UNORM: return DXGI_FORMAT_R16_UNORM;
	}

	return format;
}

static DXGI_FORMAT getStencilReadFormat(DXGI_FORMAT format)
{
	switch (format)
	{
		case DXGI_FORMAT_D32_FLOAT_S8X24_UINT: return DXGI_FORMAT_X32_TYPELESS_G8X24_UINT;
		case DXGI_FORMAT_D24_UNORM_S8_UINT: return DXGI_FORMAT_X24_TYPELESS_G8_UINT;
	}

	return format;
}

static uint32 getFormatSize(DXGI_FORMAT format)
{
	uint32 size = 0;

	switch (format)
	{
		case DXGI_FORMAT_R32G32B32A32_FLOAT:
		case DXGI_FORMAT_R32G32B32A32_UINT:
		case DXGI_FORMAT_R32G32B32A32_SINT:
		case DXGI_FORMAT_R32G32B32A32_TYPELESS:
			size = 4 * 4;
			break;
		case DXGI_FORMAT_R32G32B32_FLOAT:
		case DXGI_FORMAT_R32G32B32_UINT:
		case DXGI_FORMAT_R32G32B32_SINT:
		case DXGI_FORMAT_R32G32B32_TYPELESS:
			size = 3 * 4;
			break;
		case DXGI_FORMAT_R16G16B16A16_FLOAT:
		case DXGI_FORMAT_R16G16B16A16_UNORM:
		case DXGI_FORMAT_R16G16B16A16_UINT:
		case DXGI_FORMAT_R16G16B16A16_SNORM:
		case DXGI_FORMAT_R16G16B16A16_SINT:
		case DXGI_FORMAT_R16G16B16A16_TYPELESS:
			size = 4 * 2;
			break;
		case DXGI_FORMAT_R32G32_FLOAT:
		case DXGI_FORMAT_R32G32_UINT:
		case DXGI_FORMAT_R32G32_SINT:
		case DXGI_FORMAT_R32G32_TYPELESS:
		case DXGI_FORMAT_D32_FLOAT_S8X24_UINT:
		case DXGI_FORMAT_R32G8X24_TYPELESS:
			size = 2 * 4;
			break;
		case DXGI_FORMAT_R10G10B10A2_UNORM:
		case DXGI_FORMAT_R10G10B10A2_UINT:
		case DXGI_FORMAT_R10G10B10A2_TYPELESS:
		case DXGI_FORMAT_R11G11B10_FLOAT:
			size = 4;
			break;
		case DXGI_FORMAT_R8G8B8A8_UNORM:
		case DXGI_FORMAT_R8G8B8A8_UNORM_SRGB:
		case DXGI_FORMAT_R8G8B8A8_UINT:
		case DXGI_FORMAT_R8G8B8A8_SNORM:
		case DXGI_FORMAT_R8G8B8A8_SINT:
		case DXGI_FORMAT_B8G8R8A8_UNORM_SRGB:
		case DXGI_FORMAT_R8G8B8A8_TYPELESS:
			size = 4;
			break;
		case DXGI_FORMAT_R16G16_FLOAT:
		case DXGI_FORMAT_R16G16_UNORM:
		case DXGI_FORMAT_R16G16_UINT:
		case DXGI_FORMAT_R16G16_SNORM:
		case DXGI_FORMAT_R16G16_SINT:
		case DXGI_FORMAT_R16G16_TYPELESS:
			size = 2 * 2;
			break;
		case DXGI_FORMAT_D32_FLOAT:
		case DXGI_FORMAT_R32_FLOAT:
		case DXGI_FORMAT_R32_UINT:
		case DXGI_FORMAT_R32_SINT:
		case DXGI_FORMAT_R32_TYPELESS:
			size = 4;
			break;
		case DXGI_FORMAT_R8G8_UNORM:
		case DXGI_FORMAT_R8G8_UINT:
		case DXGI_FORMAT_R8G8_SNORM:
		case DXGI_FORMAT_R8G8_SINT:
		case DXGI_FORMAT_R8G8_TYPELESS:
			size = 2;
			break;
		case DXGI_FORMAT_R16_FLOAT:
		case DXGI_FORMAT_D16_UNORM:
		case DXGI_FORMAT_R16_UNORM:
		case DXGI_FORMAT_R16_UINT:
		case DXGI_FORMAT_R16_SNORM:
		case DXGI_FORMAT_R16_SINT:
		case DXGI_FORMAT_R16_TYPELESS:
			size = 2;
			break;
		case DXGI_FORMAT_R8_UNORM:
		case DXGI_FORMAT_R8_UINT:
		case DXGI_FORMAT_R8_SNORM:
		case DXGI_FORMAT_R8_SINT:
		case DXGI_FORMAT_R8_TYPELESS:
			size = 1;
			break;
			size = 4;
			break;

		default:
			ASSERT(false); // Compressed format.
	}

	return size;
}

static DXGI_FORMAT getTypelessFormat(DXGI_FORMAT format)
{
	DXGI_FORMAT typelessFormat = format;

	switch (format)
	{
		case DXGI_FORMAT_R32G32B32A32_FLOAT:
		case DXGI_FORMAT_R32G32B32A32_UINT:
		case DXGI_FORMAT_R32G32B32A32_SINT:
			typelessFormat = DXGI_FORMAT_R32G32B32A32_TYPELESS;
			break;
		case DXGI_FORMAT_R32G32B32_FLOAT:
		case DXGI_FORMAT_R32G32B32_UINT:
		case DXGI_FORMAT_R32G32B32_SINT:
			typelessFormat = DXGI_FORMAT_R32G32B32_TYPELESS;
			break;
		case DXGI_FORMAT_R16G16B16A16_FLOAT:
		case DXGI_FORMAT_R16G16B16A16_UNORM:
		case DXGI_FORMAT_R16G16B16A16_UINT:
		case DXGI_FORMAT_R16G16B16A16_SNORM:
		case DXGI_FORMAT_R16G16B16A16_SINT:
			typelessFormat = DXGI_FORMAT_R16G16B16A16_TYPELESS;
			break;
		case DXGI_FORMAT_R32G32_FLOAT:
		case DXGI_FORMAT_R32G32_UINT:
		case DXGI_FORMAT_R32G32_SINT:
			typelessFormat = DXGI_FORMAT_R32G32_TYPELESS;
			break;
		case DXGI_FORMAT_D32_FLOAT_S8X24_UINT:
			typelessFormat = DXGI_FORMAT_R32G8X24_TYPELESS;
			break;
		case DXGI_FORMAT_D24_UNORM_S8_UINT:
			typelessFormat = DXGI_FORMAT_R24G8_TYPELESS;
			break;
		case DXGI_FORMAT_R10G10B10A2_UNORM:
		case DXGI_FORMAT_R10G10B10A2_UINT:
			typelessFormat = DXGI_FORMAT_R10G10B10A2_TYPELESS;
			break;
		case DXGI_FORMAT_R8G8B8A8_UNORM:
		case DXGI_FORMAT_R8G8B8A8_UNORM_SRGB:
		case DXGI_FORMAT_R8G8B8A8_UINT:
		case DXGI_FORMAT_R8G8B8A8_SNORM:
		case DXGI_FORMAT_R8G8B8A8_SINT:
			typelessFormat = DXGI_FORMAT_R8G8B8A8_TYPELESS;
			break;
		case DXGI_FORMAT_R16G16_FLOAT:
		case DXGI_FORMAT_R16G16_UNORM:
		case DXGI_FORMAT_R16G16_UINT:
		case DXGI_FORMAT_R16G16_SNORM:
		case DXGI_FORMAT_R16G16_SINT:
			typelessFormat = DXGI_FORMAT_R16G16_TYPELESS;
			break;
		case DXGI_FORMAT_D32_FLOAT:
		case DXGI_FORMAT_R32_FLOAT:
		case DXGI_FORMAT_R32_UINT:
		case DXGI_FORMAT_R32_SINT:
			typelessFormat = DXGI_FORMAT_R32_TYPELESS;
			break;
		case DXGI_FORMAT_R8G8_UNORM:
		case DXGI_FORMAT_R8G8_UINT:
		case DXGI_FORMAT_R8G8_SNORM:
		case DXGI_FORMAT_R8G8_SINT:
			typelessFormat = DXGI_FORMAT_R8G8_TYPELESS;
			break;
		case DXGI_FORMAT_R16_FLOAT:
		case DXGI_FORMAT_D16_UNORM:
		case DXGI_FORMAT_R16_UNORM:
		case DXGI_FORMAT_R16_UINT:
		case DXGI_FORMAT_R16_SNORM:
		case DXGI_FORMAT_R16_SINT:
			typelessFormat = DXGI_FORMAT_R16_TYPELESS;
			break;
		case DXGI_FORMAT_R8_UNORM:
		case DXGI_FORMAT_R8_UINT:
		case DXGI_FORMAT_R8_SNORM:
		case DXGI_FORMAT_R8_SINT:
			typelessFormat = DXGI_FORMAT_R8_TYPELESS;
			break;
		case DXGI_FORMAT_BC1_UNORM:
		case DXGI_FORMAT_BC1_UNORM_SRGB:
			typelessFormat = DXGI_FORMAT_BC1_TYPELESS;
			break;
		case DXGI_FORMAT_BC2_UNORM:
		case DXGI_FORMAT_BC2_UNORM_SRGB:
			typelessFormat = DXGI_FORMAT_BC2_TYPELESS;
			break;
		case DXGI_FORMAT_BC3_UNORM:
		case DXGI_FORMAT_BC3_UNORM_SRGB:
			typelessFormat = DXGI_FORMAT_BC3_TYPELESS;
			break;
		case DXGI_FORMAT_BC4_UNORM:
		case DXGI_FORMAT_BC4_SNORM:
			typelessFormat = DXGI_FORMAT_BC4_TYPELESS;
			break;
		case DXGI_FORMAT_BC5_UNORM:
		case DXGI_FORMAT_BC5_SNORM:
			typelessFormat = DXGI_FORMAT_BC5_TYPELESS;
			break;
		case DXGI_FORMAT_B8G8R8A8_UNORM_SRGB:
			typelessFormat = DXGI_FORMAT_B8G8R8A8_TYPELESS;
			break;
		case DXGI_FORMAT_B8G8R8X8_UNORM_SRGB:
			typelessFormat = DXGI_FORMAT_B8G8R8X8_TYPELESS;
			break;
		case DXGI_FORMAT_BC6H_UF16:
		case DXGI_FORMAT_BC6H_SF16:
			typelessFormat = DXGI_FORMAT_BC6H_TYPELESS;
			break;
		case DXGI_FORMAT_BC7_UNORM:
		case DXGI_FORMAT_BC7_UNORM_SRGB:
			typelessFormat = DXGI_FORMAT_BC7_TYPELESS;
			break;
	}

	return typelessFormat;
}

static uint32 getNumberOfChannels(DXGI_FORMAT format)
{
	switch (format)
	{
		case DXGI_FORMAT_R32_TYPELESS:
		case DXGI_FORMAT_D32_FLOAT:
		case DXGI_FORMAT_R32_FLOAT:
		case DXGI_FORMAT_R32_UINT:
		case DXGI_FORMAT_R32_SINT:
		case DXGI_FORMAT_R16_TYPELESS:
		case DXGI_FORMAT_R16_FLOAT:
		case DXGI_FORMAT_D16_UNORM:
		case DXGI_FORMAT_R16_UNORM:
		case DXGI_FORMAT_R16_UINT:
		case DXGI_FORMAT_R16_SNORM:
		case DXGI_FORMAT_R16_SINT:
		case DXGI_FORMAT_R8_TYPELESS:
		case DXGI_FORMAT_R8_UNORM:
		case DXGI_FORMAT_R8_UINT:
		case DXGI_FORMAT_R8_SNORM:
		case DXGI_FORMAT_R8_SINT:
		case DXGI_FORMAT_A8_UNORM:
		case DXGI_FORMAT_R1_UNORM:
			return 1;
		case DXGI_FORMAT_R16G16_TYPELESS:
		case DXGI_FORMAT_R16G16_FLOAT:
		case DXGI_FORMAT_R16G16_UNORM:
		case DXGI_FORMAT_R16G16_UINT:
		case DXGI_FORMAT_R16G16_SNORM:
		case DXGI_FORMAT_R16G16_SINT:
		case DXGI_FORMAT_R8G8_TYPELESS:
		case DXGI_FORMAT_R8G8_UNORM:
		case DXGI_FORMAT_R8G8_UINT:
		case DXGI_FORMAT_R8G8_SNORM:
		case DXGI_FORMAT_R8G8_SINT:
			return 2;
		case DXGI_FORMAT_R32G32B32_TYPELESS:
		case DXGI_FORMAT_R32G32B32_FLOAT:
		case DXGI_FORMAT_R32G32B32_UINT:
		case DXGI_FORMAT_R32G32B32_SINT:
		case DXGI_FORMAT_R11G11B10_FLOAT:
			return 3;
		case DXGI_FORMAT_R32G32B32A32_TYPELESS:
		case DXGI_FORMAT_R32G32B32A32_FLOAT:
		case DXGI_FORMAT_R32G32B32A32_UINT:
		case DXGI_FORMAT_R32G32B32A32_SINT:
		case DXGI_FORMAT_R16G16B16A16_TYPELESS:
		case DXGI_FORMAT_R16G16B16A16_FLOAT:
		case DXGI_FORMAT_R16G16B16A16_UNORM:
		case DXGI_FORMAT_R16G16B16A16_UINT:
		case DXGI_FORMAT_R16G16B16A16_SNORM:
		case DXGI_FORMAT_R16G16B16A16_SINT:
		case DXGI_FORMAT_R10G10B10A2_TYPELESS:
		case DXGI_FORMAT_R10G10B10A2_UNORM:
		case DXGI_FORMAT_R10G10B10A2_UINT:
		case DXGI_FORMAT_R8G8B8A8_TYPELESS:
		case DXGI_FORMAT_R8G8B8A8_UNORM:
		case DXGI_FORMAT_R8G8B8A8_UNORM_SRGB:
		case DXGI_FORMAT_R8G8B8A8_UINT:
		case DXGI_FORMAT_R8G8B8A8_SNORM:
		case DXGI_FORMAT_R8G8B8A8_SINT:
			return 4;


		case DXGI_FORMAT_BC4_UNORM:
			return 1;
		case DXGI_FORMAT_BC5_UNORM:
			return 2;
		case DXGI_FORMAT_BC1_UNORM:
		case DXGI_FORMAT_BC1_UNORM_SRGB:
			return 3;
		case DXGI_FORMAT_BC3_UNORM:
		case DXGI_FORMAT_BC3_UNORM_SRGB:
			return 4;

		default:
			//ASSERT(false);
			return 0;
	}
}





```

`src/asset/io.h`:

```h
#pragma once




struct entire_file
{
	uint8* content;
	uint64 size;
	uint64 readOffset;

	template <typename T>
	T* consume(uint32 count = 1)
	{
		uint32 readSize = sizeof(T) * count;
		if (readSize > size - readOffset)
		{
			return 0;
		}

		T* result = (T*)(content + readOffset);
		readOffset += readSize;
		return result;
	}
};

static entire_file loadFile(const fs::path& path)
{
	FILE* f = fopen(path.string().c_str(), "rb");
	if (!f)
	{
		return {};
	}
	fseek(f, 0, SEEK_END);
	uint32 fileSize = ftell(f);
	if (fileSize == 0)
	{
		fclose(f);
		return {};
	}
	fseek(f, 0, SEEK_SET);

	uint8* buffer = (uint8*)malloc(fileSize);
	fread(buffer, fileSize, 1, f);
	fclose(f);

	return { buffer, fileSize };
}

static void freeFile(entire_file file)
{
	free(file.content);
}


struct sized_string
{
	const char* str;
	uint32 length;

	sized_string() : str(0), length(0) {}
	sized_string(const char* str, uint32 length) : str(str), length(length) {}
	template<uint32 len> sized_string(const char(&str)[len]) : str(str), length(len - 1) {}
};

static bool operator==(sized_string a, sized_string b)
{
	return a.length == b.length && strncmp(a.str, b.str, a.length) == 0;
}

static std::string nameToString(sized_string str)
{
	std::string name;
	name.reserve(str.length);
	for (uint32 j = 0; j < str.length; ++j)
	{
		if (str.str[j] == 0x0 || str.str[j] == 0x1)
		{
			break;
		}
		name.push_back(str.str[j]);
	}

	size_t posOfFirstOr = name.find_last_of('|');
	if (posOfFirstOr != std::string::npos)
	{
		name = name.substr(posOfFirstOr + 1);
	}

	return name;
}

static std::string relativeFilepath(sized_string str, const fs::path& scenePath)
{
	fs::path p = std::string(str.str, str.length);
	fs::path abs = (p.is_absolute()) ? p : scenePath.parent_path() / p;
	fs::path rel = fs::relative(abs, fs::current_path());
	return rel.string();
}


```

`src/asset/mesh_postprocessing.cpp`:

```cpp
#include "pch.h"
#include "mesh_postprocessing.h"

#include "core/cpu_profiling.h"

#include <unordered_map>



void generateNormalsAndTangents(std::vector<submesh_asset>& submeshes, uint32 flags)
{
	if (flags & mesh_flag_gen_tangents)
	{
		flags |= mesh_flag_gen_normals;
	}

	for (submesh_asset& sub : submeshes)
	{
		if (sub.normals.empty() && flags & mesh_flag_gen_normals)
		{
			printf("Generating normals\n");
			CPU_PRINT_PROFILE_BLOCK("Generating normals");

			sub.normals.resize(sub.positions.size(), vec3(0.f));
			for (indexed_triangle16 tri : sub.triangles)
			{
				vec3 a = sub.positions[tri.a];
				vec3 b = sub.positions[tri.b];
				vec3 c = sub.positions[tri.c];

				vec3 n = cross(b - a, c - a);
				sub.normals[tri.a] += n;
				sub.normals[tri.b] += n;
				sub.normals[tri.c] += n;
			}
			for (vec3& n : sub.normals)
			{
				n = normalize(n);
			}
		}

		if (sub.tangents.empty() && flags & mesh_flag_gen_tangents)
		{
			printf("Generating tangents\n");
			CPU_PRINT_PROFILE_BLOCK("Generating tangents");

			sub.tangents.resize(sub.positions.size(), vec3(0.f));
			if (!sub.uvs.empty())
			{
				// https://stackoverflow.com/a/5257471
				for (indexed_triangle16 tri : sub.triangles)
				{
					vec3 a = sub.positions[tri.a];
					vec3 b = sub.positions[tri.b];
					vec3 c = sub.positions[tri.c];

					vec2 h = sub.uvs[tri.a];
					vec2 k = sub.uvs[tri.b];
					vec2 l = sub.uvs[tri.c];

					vec3 d = b - a;
					vec3 e = c - a;

					vec2 f = k - h;
					vec2 g = l - h;

					float invDet = 1.f / (f.x * g.y - f.y * g.x);

					vec3 t;
					t.x = g.y * d.x - f.y * e.x;
					t.y = g.y * d.y - f.y * e.y;
					t.z = g.y * d.z - f.y * e.z;
					t *= invDet;
					sub.tangents[tri.a] += t;
					sub.tangents[tri.b] += t;
					sub.tangents[tri.c] += t;
				}
				for (uint32 i = 0; i < (uint32)sub.positions.size(); ++i)
				{
					vec3 t = sub.tangents[i];
					vec3 n = sub.normals[i];

					// Make sure tangent is perpendicular to normal.
					vec3 b = cross(t, n);
					t = cross(n, b);

					sub.tangents[i] = normalize(t);
				}
			}
			else
			{
				printf("Mesh has no UVs. Generating suboptimal tangents.\n");
				for (uint32 i = 0; i < (uint32)sub.positions.size(); ++i)
				{
					sub.tangents[i] = getTangent(sub.normals[i]);
				}
			}
		}
	}
}



```

`src/asset/mesh_postprocessing.h`:

```h
#pragma once

#include "core/math.h"
#include "core/hash.h"
#include "geometry/mesh.h"
#include "model_asset.h"

struct full_vertex
{
	vec3 position;
	vec2 uv;
	vec3 normal;
	vec3 tangent;
	uint32 color;
	skinning_weights skin;
};

namespace std
{
	template<>
	struct hash<full_vertex>
	{
		size_t operator()(const full_vertex& x) const
		{
			size_t seed = 0;

			hash_combine(seed, x.position);
			hash_combine(seed, x.uv);
			hash_combine(seed, x.normal);
			hash_combine(seed, x.tangent);
			hash_combine(seed, x.color);
			hash_combine(seed, *(uint32*)x.skin.skinIndices);
			hash_combine(seed, *(uint32*)x.skin.skinWeights);

			return seed;
		}
	};
}

static bool operator==(const full_vertex& a, const full_vertex& b)
{
	return memcmp(&a, &b, sizeof(full_vertex)) == 0;
}








struct per_material
{
	std::unordered_map<full_vertex, uint16> vertexToIndex;
	submesh_asset sub;

	void addTriangles(const std::vector<vec3>& positions, const std::vector<vec2>& uvs, const std::vector<vec3>& normals,
		const std::vector<vec3>& tangents, const std::vector<uint32>& colors, const std::vector<skinning_weights>& skins,
		int32 firstIndex, int32 faceSize, std::vector<submesh_asset>& outSubmeshes)
	{
		if (faceSize < 3)
		{
			// Ignore lines and points.
			return;
		}

		int32 aIndex = firstIndex++;
		int32 bIndex = firstIndex++;
		add_vertex_result a = addVertex(positions, uvs, normals, tangents, colors, skins, aIndex);
		add_vertex_result b = addVertex(positions, uvs, normals, tangents, colors, skins, bIndex);
		for (int32 i = 2; i < faceSize; ++i)
		{
			int32 cIndex = firstIndex++;
			add_vertex_result c = addVertex(positions, uvs, normals, tangents, colors, skins, cIndex);

			if (!(a.success && b.success && c.success))
			{
				flush(outSubmeshes);
				a = addVertex(positions, uvs, normals, tangents, colors, skins, aIndex);
				b = addVertex(positions, uvs, normals, tangents, colors, skins, bIndex);
				c = addVertex(positions, uvs, normals, tangents, colors, skins, cIndex);
				printf("Too many vertices for 16-bit indices. Splitting mesh!\n");
			}

			sub.triangles.push_back(indexed_triangle16{ a.index, b.index, c.index });

			b = c;
			bIndex = cIndex;
		}
	}

	void flush(std::vector<submesh_asset>& outSubmeshes)
	{
		if (vertexToIndex.size() > 0)
		{
			outSubmeshes.push_back(std::move(sub));
			vertexToIndex.clear();
		}
	}

private:

	struct add_vertex_result
	{
		uint16 index;
		bool success;
	};

	add_vertex_result addVertex(const std::vector<vec3>& positions, const std::vector<vec2>& uvs, const std::vector<vec3>& normals,
		const std::vector<vec3>& tangents, const std::vector<uint32>& colors, const std::vector<skinning_weights>& skins,
		int32 index)
	{
		vec3 position = positions[index];
		vec2 uv = !uvs.empty() ? uvs[index] : vec2(0.f, 0.f);
		vec3 normal = !normals.empty() ? normals[index] : vec3(0.f, 0.f, 0.f);
		vec3 tangent = !tangents.empty() ? tangents[index] : vec3(0.f, 0.f, 0.f);
		uint32 color = !colors.empty() ? colors[index] : 0;
		skinning_weights skin = !skins.empty() ? skins[index] : skinning_weights{};

		full_vertex vertex = { position, uv, normal, tangent, color, skin, };
		auto it = vertexToIndex.find(vertex);
		if (it == vertexToIndex.end())
		{
			uint32 vertexIndex = (uint32)sub.positions.size();
			if (vertexIndex > UINT16_MAX)
			{
				return { 0, false };
			}


			vertexToIndex.insert({ vertex, (uint16)vertexIndex });

			sub.positions.push_back(position);
			if (!uvs.empty()) { sub.uvs.push_back(uv); }
			if (!normals.empty()) { sub.normals.push_back(normal); }
			if (!tangents.empty()) { sub.tangents.push_back(tangent); }
			if (!colors.empty()) { sub.colors.push_back(color); }
			if (!skins.empty()) { sub.skin.push_back(skin); }

			return { (uint16)vertexIndex, true };
		}
		else
		{
			return { it->second, true };
		}
	}
};

void generateNormalsAndTangents(std::vector<submesh_asset>& submeshes, uint32 flags);

```

`src/asset/model_asset.cpp`:

```cpp
#include "pch.h"
#include "model_asset.h"
#include "core/log.h"

model_asset loadFBX(const fs::path& path, uint32 flags);
model_asset loadOBJ(const fs::path& path, uint32 flags);

model_asset loadBIN(const fs::path& path);
void writeBIN(const model_asset& asset, const fs::path& path);

model_asset load3DModelFromFile(const fs::path& path, uint32 meshFlags)
{
	if (!fs::exists(path))
	{
		LOG_WARNING("Could not find file '%ws'", path.c_str());
		std::cerr << "Could not find file '" << path << "'.\n";
		return {};
	}


	std::string extension = path.extension().string();

	fs::path cachedFilename = path;
	cachedFilename.replace_extension("." + std::to_string(meshFlags) + ".cache.bin");
	fs::path cacheFilepath = L"asset_cache" / cachedFilename;

	if (fs::exists(cacheFilepath))
	{
		auto lastCacheWriteTime = fs::last_write_time(cacheFilepath);
		auto lastOriginalWriteTime = fs::last_write_time(path);

		if (lastCacheWriteTime > lastOriginalWriteTime)
		{
			return loadBIN(cacheFilepath);
		}
	}


	LOG_MESSAGE("Preprocessing asset '%ws' for faster loading next time", path.c_str());
	std::cout << "Preprocessing asset '" << path << "' for faster loading next time.";
#ifdef _DEBUG
	std::cout << " Consider running in a release build the first time.";
#endif
	std::cout << '\n';


	model_asset result;

	std::transform(extension.begin(), extension.end(), extension.begin(),
		[](char c) { return std::tolower(c); });
	if (extension == ".fbx")
	{
		result = loadFBX(path, meshFlags);
	}
	else if (extension == ".obj")
	{
		result = loadOBJ(path, meshFlags);
	}

	fs::create_directories(cacheFilepath.parent_path());
	writeBIN(result, cacheFilepath);

	return result;
}

bool isMeshExtension(const fs::path& extension)
{
	return extension == ".fbx" || extension == ".obj" || extension == ".bin";
}

bool isMeshExtension(const std::string& extension)
{
	return extension == ".fbx" || extension == ".obj" || extension == ".bin";
}

```

`src/asset/model_asset.h`:

```h
#pragma once

#include "core/math.h"
#include "animation/animation.h"
#include "geometry/mesh.h"
#include "rendering/pbr_material.h"


struct skeleton_asset
{
	std::vector<skeleton_joint> joints;
	std::unordered_map<std::string, uint32> nameToJointID;
};

struct animation_asset
{
	std::string name;
	float duration;

	std::unordered_map<std::string, animation_joint> joints;

	std::vector<float> positionTimestamps;
	std::vector<float> rotationTimestamps;
	std::vector<float> scaleTimestamps;

	std::vector<vec3> positionKeyframes;
	std::vector<quat> rotationKeyframes;
	std::vector<vec3> scaleKeyframes;
};

struct submesh_asset
{
	int32 materialIndex;

	std::vector<vec3> positions;
	std::vector<vec2> uvs;
	std::vector<vec3> normals;
	std::vector<vec3> tangents;
	std::vector<uint32> colors;
	std::vector<skinning_weights> skin;

	std::vector<indexed_triangle16> triangles;
};

struct mesh_asset
{
	std::string name;
	std::vector<submesh_asset> submeshes;
	int32 skeletonIndex;
};

struct model_asset
{
	uint32 flags;
	std::vector<mesh_asset> meshes;
	std::vector<pbr_material_desc> materials;
	std::vector<skeleton_asset> skeletons;
	std::vector<animation_asset> animations;
};



enum mesh_flags
{
	mesh_flag_load_uvs				= (1 << 0),
	mesh_flag_flip_uvs_vertically	= (1 << 1),
	mesh_flag_load_normals			= (1 << 2),
	mesh_flag_load_tangents			= (1 << 3),
	mesh_flag_gen_normals			= (1 << 4), // Only if mesh has no normals.
	mesh_flag_gen_tangents			= (1 << 5), // Only if mesh has no tangents.
	mesh_flag_load_colors			= (1 << 6), // Only if mesh has no tangents.
	mesh_flag_load_skin				= (1 << 7),

	mesh_flag_default = mesh_flag_load_uvs | mesh_flag_flip_uvs_vertically | 
		mesh_flag_load_normals | mesh_flag_gen_normals | 
		mesh_flag_load_tangents | mesh_flag_gen_tangents | 
		mesh_flag_load_colors | mesh_flag_load_skin,
};


model_asset load3DModelFromFile(const fs::path& path, uint32 meshFlags = mesh_flag_default);


bool isMeshExtension(const fs::path& extension);
bool isMeshExtension(const std::string& extension);


```

`src/asset/obj.cpp`:

```cpp
#include "pch.h"
#include "io.h"
#include "model_asset.h"
#include "mesh_postprocessing.h"
#include "core/math.h"
#include "core/cpu_profiling.h"
#include "geometry/mesh.h"

//#define PROFILE(name) CPU_PRINT_PROFILE_BLOCK(name)
#define PROFILE(name) 

void testDumpToPLY(const std::string& filename,
	const std::vector<vec3>& positions, const std::vector<vec2>& uvs, const std::vector<vec3>& normals, const std::vector<indexed_triangle16>& triangles,
	uint8 r = 255, uint8 g = 255, uint8 b = 255);


static bool isEndOfLine(char c)
{
	return c == '\r' ||
		c == '\n';
}

static bool isWhitespace(char c)
{
	return c == ' ' ||
		c == '\t' ||
		isEndOfLine(c);
}

static bool isWhiteSpaceNoEndOfLine(char c)
{
	return c == ' ' ||
		c == '\t';
}

static void discardLine(entire_file& file)
{
	while (file.readOffset < file.size && file.content[file.readOffset] != '\n')
	{
		++file.readOffset;
	}
	if (file.readOffset < file.size)
	{
		++file.readOffset;
	}
}

static void discardWhitespace(entire_file& file, bool allowLineSkip = true)
{
	if (allowLineSkip)
	{
		while (file.readOffset < file.size)
		{
			while (file.readOffset < file.size && isWhitespace((char)file.content[file.readOffset]))
			{
				++file.readOffset;
			}
			if (file.readOffset < file.size && file.content[file.readOffset] == '#')
			{
				discardLine(file);
			}
			else
			{
				break;
			}
		}
	}
	else
	{
		while (file.readOffset < file.size && isWhiteSpaceNoEndOfLine((char)file.content[file.readOffset]))
		{
			++file.readOffset;
		}
	}
}

static sized_string readString(entire_file& file, bool allowLineSkip = true)
{
	discardWhitespace(file, allowLineSkip);

	sized_string result;
	result.str = (const char*)file.content + file.readOffset;
	while (file.readOffset < file.size && !isWhitespace((char)file.content[file.readOffset]))
	{
		++result.length;
		++file.readOffset;
	}

	return result;
}

static int32 readInt32(entire_file& file)
{
	sized_string str = readString(file);
	return atoi(str.str);
}

static vec3 readVec3(entire_file& file)
{
	sized_string xStr = readString(file);
	sized_string yStr = readString(file);
	sized_string zStr = readString(file);

	float x = (float)atof(xStr.str);
	float y = (float)atof(yStr.str);
	float z = (float)atof(zStr.str);

	return vec3(x, y, z);
}

static vec2 readVec2(entire_file& file)
{
	sized_string xStr = readString(file);
	sized_string yStr = readString(file);

	float x = (float)atof(xStr.str);
	float y = (float)atof(yStr.str);

	return vec2(x, y);
}

static float readFloat(entire_file& file)
{
	sized_string str = readString(file);
	float v = (float)atof(str.str);
	return v;
}

struct obj_vertex_indices
{
	int32 positionIndex;
	int32 normalIndex;
	int32 uvIndex;
};

static obj_vertex_indices readVertexIndices(sized_string vertexStr)
{
	sized_string indexStrs[3] = {};
	indexStrs[0].str = vertexStr.str;
	uint32 curr = 0;
	for (uint32 i = 0; i < vertexStr.length; ++i)
	{
		if (vertexStr.str[i] == '/')
		{
			++curr;
			indexStrs[curr].str = vertexStr.str + (i + 1);
		}
		else
		{
			++indexStrs[curr].length;
		}
	}


	int32 positionIndex = indexStrs[0].length ? atoi(indexStrs[0].str) : 0;
	int32 uvIndex = indexStrs[1].length ? atoi(indexStrs[1].str) : 0;
	int32 normalIndex = indexStrs[2].length ? atoi(indexStrs[2].str) : 0;

	if (positionIndex > 0)
	{
		--positionIndex;
	}
	if (normalIndex > 0)
	{
		--normalIndex;
	}
	if (uvIndex > 0)
	{
		--uvIndex;
	}

	return { positionIndex, normalIndex, uvIndex };
}

static std::vector<std::pair<std::string, pbr_material_desc>> loadMaterialLibrary(const fs::path& path)
{
	entire_file file = loadFile(path);

	std::vector<std::pair<std::string, pbr_material_desc>> result;
	pbr_material_desc currentMaterial = {};
	std::string currentName;

	{
		PROFILE("Parse OBJ material library");

		while (file.readOffset < file.size)
		{
			sized_string token = readString(file);
			std::transform(token.str, token.str + token.length, (char*)token.str, [](char c) { return std::tolower(c); });

			if (token == "newmtl")
			{
				if (!currentName.empty())
				{
					result.push_back({ std::move(currentName), std::move(currentMaterial) });
				}

				sized_string name = readString(file);
				currentName = nameToString(name);
			}
			else if (token == "ns")
			{
				float value = readFloat(file);
				currentMaterial.roughnessOverride = 1.f - (sqrt(value) * 0.1f);
			}
			else if (token == "pr")
			{
				float value = readFloat(file);
				currentMaterial.roughnessOverride = value;
			}
			else if (token == "pm")
			{
				float value = readFloat(file);
				currentMaterial.metallicOverride = value;
			}
			else if (token == "ni")
			{

			}
			else if (token == "d")
			{

			}
			else if (token == "tr")
			{
				float value = readFloat(file);
				float alpha = 1.f - value;
				currentMaterial.albedoTint.w = alpha;
				if (alpha < 1.f)
				{
					currentMaterial.shader = pbr_material_shader_transparent;
				}
			}
			else if (token == "tf")
			{

			}
			else if (token == "illum")
			{

			}
			else if (token == "ka")
			{

			}
			else if (token == "kd")
			{
				vec3 color = readVec3(file);
				currentMaterial.albedoTint.xyz = color;
			}
			else if (token == "ks")
			{

			}
			else if (token == "ke")
			{
				vec3 color = readVec3(file);
				currentMaterial.emission = vec4(color, 1.f);
			}
			else if (token == "map_ka" || token == "map_pm")
			{
				sized_string str = readString(file);
				currentMaterial.metallic = relativeFilepath(str, path);
			}
			else if (token == "map_kd")
			{
				sized_string str = readString(file);
				currentMaterial.albedo = relativeFilepath(str, path);
			}
			else if (token == "map_d")
			{

			}
			else if (token == "map_bump")
			{
				sized_string str = readString(file);
				currentMaterial.normal = relativeFilepath(str, path);
			}
			else if (token == "map_ns" || token == "map_pr")
			{
				sized_string str = readString(file);
				currentMaterial.roughness = relativeFilepath(str, path);
			}
			else if (token == "bump")
			{

			}
			else if (token.length == 0)
			{
				// Nothing.
			}
			else
			{
				printf("Unrecognized material start token '%.*s'\n", token.length, token.str);
			}

			discardLine(file);
		}
	}
	if (!currentName.empty())
	{
		result.push_back({ std::move(currentName), std::move(currentMaterial) });
	}

	freeFile(file);

	return result;
}

model_asset loadOBJ(const fs::path& path, uint32 flags)
{
	PROFILE("Loading OBJ");

	entire_file file = loadFile(path);

	std::vector<vec3> positions; positions.reserve(1 << 16);
	std::vector<vec2> uvs; uvs.reserve(1 << 16);
	std::vector<vec3> normals; normals.reserve(1 << 16);

	std::vector<pbr_material_desc> materials;
	std::unordered_map<std::string, int32> nameToMaterialIndex;
	int32 currentMaterialIndex = 0;

	std::vector<submesh_asset> submeshes;


	std::unordered_map<int32, per_material> materialToMesh;


	std::vector<vec3> positionCache; positionCache.reserve(16);
	std::vector<vec2> uvCache; uvCache.reserve(16);
	std::vector<vec3> normalCache; normalCache.reserve(16);

	{
		PROFILE("Parse OBJ");

		while (file.readOffset < file.size)
		{
			sized_string token = readString(file);

			if (token == "mtllib")
			{
				sized_string lib = readString(file);
				auto libMaterials = loadMaterialLibrary(relativeFilepath(lib, path));
				for (auto [name, mat] : libMaterials)
				{
					nameToMaterialIndex[std::move(name)] = (int32)materials.size();
					materials.push_back(std::move(mat));
				}
			}
			else if (token == "v")
			{
				positions.push_back(readVec3(file));
			}
			else if (token == "vn")
			{
				normals.push_back(readVec3(file));
			}
			else if (token == "vt")
			{
				vec2 uv = readVec2(file);
				if (flags & mesh_flag_flip_uvs_vertically)
				{
					uv.y = 1.f - uv.y;
				}
				uvs.push_back(uv);
			}
			else if (token == "g")
			{
				sized_string name = readString(file);
			}
			else if (token == "o")
			{
				sized_string name = readString(file);
			}
			else if (token == "s")
			{
				int32 smoothing = readInt32(file);
			}
			else if (token == "usemtl")
			{
				sized_string mtl = readString(file);
				std::string name = nameToString(mtl);

				auto it = nameToMaterialIndex.find(name);
				if (it != nameToMaterialIndex.end())
				{
					currentMaterialIndex = it->second;
				}
				else
				{
					printf("Unrecognized material '%.*s'\n", mtl.length, mtl.str);
				}
			}
			else if (token == "f")
			{
				int32 faceSize = 0;
				while (file.readOffset < file.size && !isEndOfLine((char)file.content[file.readOffset]))
				{
					sized_string vertexStr = readString(file, false);
					if (vertexStr.length == 0)
					{
						break;
					}

					obj_vertex_indices vertexIndices = readVertexIndices(vertexStr);

					int32 currNumPositions = (int32)positions.size();
					vertexIndices.positionIndex += (vertexIndices.positionIndex >= 0) ? 0 : currNumPositions;
					ASSERT(vertexIndices.positionIndex < currNumPositions);
					positionCache.push_back(positions[vertexIndices.positionIndex]);

					if (flags & mesh_flag_load_uvs)
					{
						int32 currNumUVs = (int32)uvs.size();
						vertexIndices.uvIndex += (vertexIndices.uvIndex >= 0) ? 0 : currNumUVs;
						ASSERT(vertexIndices.uvIndex < currNumUVs);
						uvCache.push_back(uvs[vertexIndices.uvIndex]);
					}

					if (flags & mesh_flag_load_normals)
					{
						int32 currNumNormals = (int32)normals.size();
						vertexIndices.normalIndex += (vertexIndices.normalIndex >= 0) ? 0 : currNumNormals;
						ASSERT(vertexIndices.normalIndex < currNumNormals);
						normalCache.push_back(normals[vertexIndices.normalIndex]);
					}

					++faceSize;
				}

				per_material& perMat = materialToMesh[currentMaterialIndex];
				perMat.sub.materialIndex = currentMaterialIndex;

				perMat.addTriangles(positionCache, uvCache, normalCache, {}, {}, {}, 0, faceSize, submeshes);

				positionCache.clear();
				uvCache.clear();
				normalCache.clear();
			}
			else if (token.length == 0)
			{
				// Nothing.
			}
			else
			{
				printf("Unrecognized start token '%.*s'\n", token.length, token.str);
			}


			discardLine(file);
		}
	}

	for (auto [i, perMat] : materialToMesh)
	{
		perMat.flush(submeshes);
	}


	freeFile(file);


	generateNormalsAndTangents(submeshes, flags);



	model_asset result;
	result.flags = flags;
	result.meshes.push_back({ path.filename().string(), std::move(submeshes), -1 });
	result.materials = std::move(materials);

#if 0
	for (uint32 i = 0; i < (uint32)submeshes.size(); ++i)
	{
		const submesh_asset& sub = submeshes[i];

		vec3 diffuseColor = vec3(1.f, 1.f, 1.f);

		std::string indexedName2 = "Mesh_" + std::to_string(i) + ".ply";

		testDumpToPLY(indexedName2, sub.positions, sub.uvs, sub.normals, sub.triangles,
			(uint8)(diffuseColor.x * 255), (uint8)(diffuseColor.y * 255), (uint8)(diffuseColor.z * 255));
	}
#endif

	return result;
}

```

`src/asset/ply.cpp`:

```cpp
#include "pch.h"
#include "geometry/mesh.h"

#include <fstream>



static void writeHeaderToFile(std::ofstream& outfile, int numPoints, bool writeUVs, bool writeNormals, bool writeColors, int numFaces)
{
	const char* format_header = "binary_little_endian 1.0";
	outfile << "ply" << std::endl
		<< "format " << format_header << std::endl
		<< "comment scan3d-capture generated" << std::endl
		<< "element vertex " << numPoints << std::endl
		<< "property float x" << std::endl
		<< "property float y" << std::endl
		<< "property float z" << std::endl;

	if (writeUVs)
	{
		outfile << "property float texture_u" << std::endl
			<< "property float texture_v" << std::endl;
	}

	if (writeNormals)
	{
		outfile << "property float nx" << std::endl
			<< "property float ny" << std::endl
			<< "property float nz" << std::endl;
	}

	if (writeColors)
	{
		outfile << "property uchar red" << std::endl
			<< "property uchar green" << std::endl
			<< "property uchar blue" << std::endl
			<< "property uchar alpha" << std::endl;
	}

	outfile << "element face " << numFaces << std::endl
		<< "property list uchar int vertex_indices" << std::endl;

	outfile << "end_header" << std::endl;
}

template <typename T>
static void write(std::ofstream& outfile, T value)
{
	outfile.write(reinterpret_cast<const char*>(&value), sizeof(T));
}

void testDumpToPLY(const std::string& filename,
	const std::vector<vec3>& positions, const std::vector<vec2>& uvs, const std::vector<vec3>& normals, const std::vector<indexed_triangle16>& triangles,
	uint8 r, uint8 g, uint8 b)
{
	std::ofstream outfile;
	std::ios::openmode mode = std::ios::out | std::ios::trunc | std::ios::binary;
	outfile.open(filename, mode);

	uint32 numPoints = (uint32)positions.size();
	uint32 numFaces = (uint32)triangles.size();
	bool writeUVs = uvs.size() > 0;
	bool writeNormals = normals.size() > 0;
	writeHeaderToFile(outfile, numPoints, writeUVs, writeNormals, true, numFaces);

	uint8 a = 255;
	for (uint32 i = 0; i < numPoints; ++i)
	{
		write(outfile, positions[i]);
		if (writeUVs) { write(outfile, uvs[i]); }
		if (writeNormals) { write(outfile, normals[i]); }
		write(outfile, r);
		write(outfile, g);
		write(outfile, b);
		write(outfile, a);
	}

	for (indexed_triangle16 tri : triangles)
	{
		uint8 count = 3;
		write(outfile, count);
		write(outfile, (int32)tri.a);
		write(outfile, (int32)tri.b);
		write(outfile, (int32)tri.c);
	}

	outfile.close();
}


```

`src/audio/audio.cpp`:

```cpp
#include "pch.h"

#define XAUDIO2_HELPER_FUNCTIONS
#include <xaudio2.h>
#include <xaudio2fx.h>


#undef M_PI

#include "audio.h"
#include "sound.h"
#include "channel.h"

#include "core/log.h"
#include "core/cpu_profiling.h"

#include <unordered_map>
#include <x3daudio.h>


master_audio_settings masterAudioSettings;
master_audio_settings oldMasterAudioSettings;

static property_fader masterVolumeFader;


float soundTypeVolumes[sound_type_count];
static float oldSoundTypeVolumes[sound_type_count];
static property_fader soundTypeVolumeFaders[sound_type_count];

static audio_context context;

typedef std::unordered_map<uint32, ref<audio_channel>> channel_map;
static channel_map channels;
static uint32 nextChannelID = 1;





static XAUDIO2FX_REVERB_I3DL2_PARAMETERS reverbPresets[] =
{
	XAUDIO2FX_I3DL2_PRESET_DEFAULT,
	XAUDIO2FX_I3DL2_PRESET_GENERIC,
	XAUDIO2FX_I3DL2_PRESET_PADDEDCELL,
	XAUDIO2FX_I3DL2_PRESET_ROOM,
	XAUDIO2FX_I3DL2_PRESET_BATHROOM,
	XAUDIO2FX_I3DL2_PRESET_LIVINGROOM,
	XAUDIO2FX_I3DL2_PRESET_STONEROOM,
	XAUDIO2FX_I3DL2_PRESET_AUDITORIUM,
	XAUDIO2FX_I3DL2_PRESET_CONCERTHALL,
	XAUDIO2FX_I3DL2_PRESET_CAVE,
	XAUDIO2FX_I3DL2_PRESET_ARENA,
	XAUDIO2FX_I3DL2_PRESET_HANGAR,
	XAUDIO2FX_I3DL2_PRESET_CARPETEDHALLWAY,
	XAUDIO2FX_I3DL2_PRESET_HALLWAY,
	XAUDIO2FX_I3DL2_PRESET_STONECORRIDOR,
	XAUDIO2FX_I3DL2_PRESET_ALLEY,
	XAUDIO2FX_I3DL2_PRESET_FOREST,
	XAUDIO2FX_I3DL2_PRESET_CITY,
	XAUDIO2FX_I3DL2_PRESET_MOUNTAINS,
	XAUDIO2FX_I3DL2_PRESET_QUARRY,
	XAUDIO2FX_I3DL2_PRESET_PLAIN,
	XAUDIO2FX_I3DL2_PRESET_PARKINGLOT,
	XAUDIO2FX_I3DL2_PRESET_SEWERPIPE,
	XAUDIO2FX_I3DL2_PRESET_UNDERWATER,
	XAUDIO2FX_I3DL2_PRESET_SMALLROOM,
	XAUDIO2FX_I3DL2_PRESET_MEDIUMROOM,
	XAUDIO2FX_I3DL2_PRESET_LARGEROOM,
	XAUDIO2FX_I3DL2_PRESET_MEDIUMHALL,
	XAUDIO2FX_I3DL2_PRESET_LARGEHALL,
	XAUDIO2FX_I3DL2_PRESET_PLATE,
};



/*
	Our audio graph looks like this:

	[Source(s)] ----> [Sound type submix] ----> [Master]
	     `-> [Sound type reverb] -^
*/



static void setReverb()
{
	bool reverbOn = masterAudioSettings.reverbEnabled && masterAudioSettings.reverbPreset != reverb_none;

	if (reverbOn)
	{
		XAUDIO2FX_REVERB_PARAMETERS reverbParameters;
		ReverbConvertI3DL2ToNative(&reverbPresets[masterAudioSettings.reverbPreset], &reverbParameters);

		for (uint32 i = 0; i < sound_type_count; ++i)
		{
			context.reverbSubmixVoices[i]->SetEffectParameters(0, &reverbParameters, sizeof(reverbParameters));
		}
	}

	for (uint32 i = 0; i < sound_type_count; ++i)
	{
		float level[16];
		float reverbLevel = reverbOn ? 1.f : 0.f;
		for (uint32 j = 0; j < context.soundTypeSubmixVoiceDetails[i].InputChannels; ++j)
		{
			level[j] = reverbLevel;
		}

		context.reverbSubmixVoices[i]->SetOutputMatrix(context.soundTypeSubmixVoices[i], 1, context.soundTypeSubmixVoiceDetails[i].InputChannels, level);
	}
}

bool initializeAudio()
{
	uint32 flags = 0;
#ifdef _DEBUG
	flags |= XAUDIO2_DEBUG_ENGINE;
#endif
	checkResult(XAudio2Create(context.xaudio.GetAddressOf(), flags));
	checkResult(context.xaudio->CreateMasteringVoice(&context.masterVoice));

	masterVolumeFader.initialize(masterAudioSettings.volume);
	context.masterVoice->SetVolume(masterAudioSettings.volume);

	DWORD channelMask;
	context.masterVoice->GetChannelMask(&channelMask);
	context.masterVoice->GetVoiceDetails(&context.masterVoiceDetails);




	X3DAudioInitialize(channelMask, X3DAUDIO_SPEED_OF_SOUND, context.xaudio3D);




	for (uint32 i = 0; i < sound_type_count; ++i)
	{
		soundTypeVolumes[i] = oldSoundTypeVolumes[i] = 1.f;
		soundTypeVolumeFaders[i].initialize(soundTypeVolumes[i]);

		checkResult(context.xaudio->CreateSubmixVoice(&context.soundTypeSubmixVoices[i], context.masterVoiceDetails.InputChannels, context.masterVoiceDetails.InputSampleRate, 0, 1));
		context.soundTypeSubmixVoices[i]->GetVoiceDetails(&context.soundTypeSubmixVoiceDetails[i]);
		context.soundTypeSubmixVoices[i]->SetVolume(soundTypeVolumes[i]);


		IUnknown* reverbXAPO;
		checkResult(XAudio2CreateReverb(&reverbXAPO));


		XAUDIO2_EFFECT_DESCRIPTOR descriptor;
		descriptor.InitialState = true;
		descriptor.OutputChannels = 1;
		descriptor.pEffect = reverbXAPO;

		XAUDIO2_EFFECT_CHAIN chain;
		chain.EffectCount = 1;
		chain.pEffectDescriptors = &descriptor;


		XAUDIO2_SEND_DESCRIPTOR sendDescriptor;
		sendDescriptor.Flags = 0;
		sendDescriptor.pOutputVoice = context.soundTypeSubmixVoices[i];

		const XAUDIO2_VOICE_SENDS sendList = { 1, &sendDescriptor };

		checkResult(context.xaudio->CreateSubmixVoice(&context.reverbSubmixVoices[i], 1, context.soundTypeSubmixVoiceDetails[i].InputSampleRate, 0, 0, &sendList, &chain));

		reverbXAPO->Release();
	}


	setReverb();



	context.listener.OrientFront = { 0.f, 0.f, 1.f };
	context.listener.OrientTop = { 0.f, 1.f, 0.f };
	context.listener.pCone = (X3DAUDIO_CONE*)&X3DAudioDefault_DirectionalCone;

	loadSoundRegistry();

	return true;
}

void shutdownAudio()
{
	channels.clear();

	if (context.xaudio)
	{
		context.xaudio->StopEngine();
		context.xaudio.Reset();
	}
}

void setAudioListener(vec3 position, quat rotation, vec3 velocity)
{
	vec3 forward = rotation * vec3(0.f, 0.f, -1.f);
	vec3 up = rotation * vec3(0.f, 1.f, 0.f);

	// XAudio2 uses a lefthanded coordinate system, which is why we need to flip the z-axis.
	context.listener.OrientFront = { forward.x, forward.y, -forward.z };
	context.listener.OrientTop = { up.x, up.y, -up.z };
	context.listener.Position = { position.x, position.y, -position.z };
	context.listener.Velocity = { velocity.x, velocity.y, -velocity.z };
}

void updateAudio(float dt)
{
	CPU_PROFILE_BLOCK("Update audio");

	masterAudioSettings.volume = max(0.f, masterAudioSettings.volume);

	if (oldMasterAudioSettings.volume != masterAudioSettings.volume)
	{
		masterVolumeFader.startFade(masterAudioSettings.volume, 0.1f);
	}

	if (oldMasterAudioSettings.reverbEnabled != masterAudioSettings.reverbEnabled || oldMasterAudioSettings.reverbPreset != masterAudioSettings.reverbPreset)
	{
		setReverb();
	}

	oldMasterAudioSettings = masterAudioSettings;

	masterVolumeFader.update(dt);
	context.masterVoice->SetVolume(masterVolumeFader.current);



	for (uint32 i = 0; i < sound_type_count; ++i)
	{
		soundTypeVolumes[i] = max(0.f, soundTypeVolumes[i]);

		if (oldSoundTypeVolumes[i] != soundTypeVolumes[i])
		{
			soundTypeVolumeFaders[i].startFade(soundTypeVolumes[i], 0.1f);
		}

		oldSoundTypeVolumes[i] = soundTypeVolumes[i];

		soundTypeVolumeFaders[i].update(dt);
		context.soundTypeSubmixVoices[i]->SetVolume(soundTypeVolumeFaders[i].current);
	}








	channel_map::iterator stoppedChannels[64];
	uint32 numStoppedChannels = 0;

	for (auto it = channels.begin(), end = channels.end(); it != end; ++it)
	{
		it->second->update(context, dt);
		if (it->second->hasStopped())
		{
			stoppedChannels[numStoppedChannels++] = it;
			//LOG_MESSAGE("Deleting channel");
		}
	}

	for (uint32 i = 0; i < numStoppedChannels; ++i)
	{
		channels.erase(stoppedChannels[i]);
	}
}


sound_handle play2DSound(const sound_id& id, const sound_settings& settings)
{
	if (settings.volume <= 0.f)
	{
		return {};
	}

	ref<audio_sound> sound = getSound(id);
	if (!sound)
	{
		// Not all sounds are file sounds, but we have no chance of creating a synth here.
		if (!loadFileSound(id))
		{
			return {};
		}

		sound = getSound(id);
	}

	uint32 channelID = nextChannelID++;
	
	ref<audio_channel> channel = make_ref<audio_channel>(context, sound, settings);
	channels.insert({ channelID, channel });

	return { channelID };
}

sound_handle play3DSound(const sound_id& id, vec3 position, const sound_settings& settings)
{
	if (settings.volume <= 0.f)
	{
		return {};
	}

	ref<audio_sound> sound = getSound(id);
	if (!sound)
	{
		if (!loadFileSound(id))
		{
			return {};
		}

		sound = getSound(id);
	}

	uint32 channelID = nextChannelID++;

	ref<audio_channel> channel = make_ref<audio_channel>(context, sound, position, settings);
	channels.insert({ channelID, channel });

	return { channelID };
}

bool soundStillPlaying(sound_handle handle)
{
	return handle && (channels.find(handle.id) != channels.end());
}

bool stop(sound_handle handle, float fadeOutTime)
{
	if (handle)
	{
		auto it = channels.find(handle.id);
		if (it != channels.end())
		{
			it->second->stop(fadeOutTime);
			return true;
		}
	}
	return false;
}

void restartAllSounds()
{
	auto channelsCopy = std::move(channels);

	for (auto it = channelsCopy.begin(), end = channelsCopy.end(); it != end; ++it)
	{
		sound_id id = it->second->sound->id;
		sound_settings settings = *it->second->getSettings();
		bool positioned = it->second->positioned;
		vec3 position = it->second->position;

		it->second->stop(0.f);

		if (positioned)
		{
			play3DSound(id, position, settings);
		}
		else
		{
			play2DSound(id, settings);
		}
	}
}

sound_settings* getSettings(sound_handle handle)
{
	if (handle)
	{
		auto it = channels.find(handle.id);
		if (it != channels.end())
		{
			return it->second->getSettings();
		}
	}
	return 0;
}

float dbToVolume(float db)
{
	return XAudio2DecibelsToAmplitudeRatio(db);
}

float volumeToDB(float volume)
{
	return XAudio2AmplitudeRatioToDecibels(volume);
}






```

`src/audio/audio.h`:

```h
#pragma once

#include "sound.h"
#include "sound_management.h"
#include "reverb.h"
#include "core/math.h"

#include <xaudio2.h>



struct master_audio_settings
{
	float volume = 0.1f;
	bool reverbEnabled = true;
	reverb_preset reverbPreset = reverb_preset_default;
};


extern master_audio_settings masterAudioSettings;
extern float soundTypeVolumes[sound_type_count];


bool initializeAudio();
void shutdownAudio();

void setAudioListener(vec3 position, quat rotation, vec3 velocity = vec3(0.f));

void updateAudio(float dt);


struct sound_handle
{
	uint32 id;
	operator bool() { return id != 0; }
};


sound_handle play2DSound(const sound_id& id, const sound_settings& settings);
sound_handle play3DSound(const sound_id& id, vec3 position, const sound_settings& settings);

void restartAllSounds();

bool soundStillPlaying(sound_handle handle);
bool stop(sound_handle handle, float fadeOutTime = 0.1f);


// Only hold on to this pointer for one frame! Retrieve each frame! Returns null, if sound has stopped already.
sound_settings* getSettings(sound_handle handle);


float dbToVolume(float db);
float volumeToDB(float volume);



```

`src/audio/channel.cpp`:

```cpp
#include "pch.h"
#include "channel.h"



#define MAX_BUFFER_COUNT 3
#define STREAMING_BUFFER_SIZE (1024 * 8 * 6)

#define UPDATE_3D_PERIOD 3 // > 0.

#define VIRTUALIZE_FADE_TIME 0.1f

DWORD WINAPI streamFileAudio(void* parameter);
DWORD WINAPI streamSynthAudio(void* parameter);

audio_channel::audio_channel(const audio_context& context, const ref<audio_sound>& sound, const sound_settings& settings)
{
	initialize(context, sound, settings, false);
}

audio_channel::audio_channel(const audio_context& context, const ref<audio_sound>& sound, vec3 position, const sound_settings& settings)
{
	initialize(context, sound, settings, true, position);
}

void audio_channel::initialize(const audio_context& context, const ref<audio_sound>& sound, const sound_settings& settings, bool positioned, vec3 position)
{
	this->sound = sound;
	this->voiceCallback.channel = this;

	userSettings = settings;

	oldUserSettings.volume = -1.f;
	oldUserSettings.pitch = -1.f;
	oldUserSettings.loop = false;

	this->positioned = positioned;
	this->position = position;

	XAUDIO2_SEND_DESCRIPTOR sendDescriptors[2];

	// Direct.
	sendDescriptors[0].Flags = XAUDIO2_SEND_USEFILTER;
	sendDescriptors[0].pOutputVoice = context.soundTypeSubmixVoices[sound->type];

	// Reverb.
	sendDescriptors[1].Flags = XAUDIO2_SEND_USEFILTER;
	sendDescriptors[1].pOutputVoice = context.reverbSubmixVoices[sound->type];

	// Reverb only for positioned voices.
	const XAUDIO2_VOICE_SENDS sendList = { positioned ? 2u : 1u, sendDescriptors };

	checkResult(context.xaudio->CreateSourceVoice(&voice, (WAVEFORMATEX*)&sound->wfx, 0, XAUDIO2_DEFAULT_FREQ_RATIO, &voiceCallback, &sendList));
	checkResult(voice->Start());

	XAUDIO2_VOICE_DETAILS voiceDetails;
	voice->GetVoiceDetails(&voiceDetails);
	srcChannels = voiceDetails.InputChannels;


	volumeFader.initialize(settings.volume);
	pitchFader.initialize(settings.pitch);

	upDownFader.initialize(1.f);
	
	updateSoundSettings(context, 0.f);

	if (sound->stream)
	{
		threadStopped = false;
		bufferEndSemaphore = CreateSemaphore(0, 0, MAX_BUFFER_COUNT, 0);

		auto func = (sound->isSynth) ? streamSynthAudio : streamFileAudio;
		threadHandle = CreateThread(0, 0, func, this, 0, 0);
	}
	else
	{
		XAUDIO2_BUFFER buffer = { 0 };
		buffer.AudioBytes = sound->chunkSize;
		buffer.pAudioData = sound->dataBuffer;
		if (settings.loop)
		{
			buffer.LoopCount = XAUDIO2_LOOP_INFINITE;
		}
		else
		{
			buffer.Flags = XAUDIO2_END_OF_STREAM;
		}

		checkResult(voice->SubmitSourceBuffer(&buffer));
	}
}

audio_channel::~audio_channel()
{
	voice->DestroyVoice();
	if (sound->stream)
	{
		CloseHandle(bufferEndSemaphore);
		CloseHandle(threadHandle);
	}
}

void audio_channel::update(const audio_context& context, float dt)
{
	switch (state)
	{
		case channel_state_to_play:
		{
			state = channel_state_playing;
			if (shouldBeVirtual())
			{
				state = channel_state_virtual;
			}
		} break;

		case channel_state_playing:
		{
			updateSoundSettings(context, dt);
			if (shouldBeVirtual())
			{
				state = channel_state_virtualizing;
				upDownFader.startFade(0.f, VIRTUALIZE_FADE_TIME);
			}
		} break;

		case channel_state_stopping:
		{
			updateSoundSettings(context, dt);
			if (upDownFader.current <= 0.f)
			{
				voice->Stop();
				state = channel_state_stopped;

				if (sound->stream)
				{
					ReleaseSemaphore(bufferEndSemaphore, 1, 0);
				}
			}
		} break;

		case channel_state_stopped:
		{
		} break;

		case channel_state_virtualizing:
		{
			updateSoundSettings(context, dt);

			if (!shouldBeVirtual())
			{
				upDownFader.startFade(1.f, VIRTUALIZE_FADE_TIME);
				state = channel_state_playing;
			}
			if (upDownFader.current <= 0.f)
			{
				state = channel_state_virtual;
			}
		} break;

		case channel_state_virtual:
		{
			if (!shouldBeVirtual())
			{
				upDownFader.startFade(1.f, VIRTUALIZE_FADE_TIME);
				state = channel_state_playing;
			}
		} break;

		default:
			break;
	}
}

void audio_channel::stop(float fadeOutTime)
{
	if (state != channel_state_stopping && state != channel_state_stopped)
	{
		state = channel_state_stopping;
		upDownFader.startFade(0.f, fadeOutTime);
	}
}

bool audio_channel::hasStopped()
{
	return state == channel_state_stopped && threadStopped;
}

void audio_channel::updateSoundSettings(const audio_context& context, float dt)
{
	userSettings.pitch = clamp(userSettings.pitch, 0.f, XAUDIO2_DEFAULT_FREQ_RATIO);

	if (userSettings.volume != oldUserSettings.volume)
	{
		volumeFader.startFade(userSettings.volume, userSettings.volumeFadeTime);
	}
	if (userSettings.pitch != oldUserSettings.pitch)
	{
		pitchFader.startFade(userSettings.pitch, userSettings.pitchFadeTime);
	}

	oldUserSettings = userSettings;

	upDownFader.update(dt);
	volumeFader.update(dt);
	pitchFader.update(dt);

	float v = volumeFader.current * upDownFader.current;
	if (v != oldVolume)
	{
		voice->SetVolume(v);
		oldVolume = v;
	}

	float p = pitchFader.current;
	if (p != oldPitch)
	{
		voice->SetFrequencyRatio(p);
		oldPitch = p;
	}


	if (positioned)
	{
		if (update3DTimer == 0)
		{
			quat rotation = quat::identity; // TODO.

			vec3 forward = rotation * vec3(0.f, 0.f, -1.f);
			vec3 up = rotation * vec3(0.f, 1.f, 0.f);

			float channelAzimuths[8] = {};

			X3DAUDIO_EMITTER emitter = { 0 };
			emitter.ChannelCount = srcChannels;
			emitter.ChannelRadius = 0.1f;
			emitter.InnerRadius = 2.f;
			emitter.InnerRadiusAngle = X3DAUDIO_PI / 4.f;
			emitter.pChannelAzimuths = channelAzimuths;



			// A physically correct model would have CurveDistanceScaler=1 and pVolumeCurve=nullptr.
			// However the default reverb curve is linear, which sounds very weird, because it just stops way before the sound stops being audible.
			// Thus we just set both curves to linear and use CurveDistanceScaler to scale the curve to the desired radius.

#if 1
			emitter.CurveDistanceScaler = userSettings.radius;
			emitter.pVolumeCurve = (X3DAUDIO_DISTANCE_CURVE*)&X3DAudioDefault_LinearCurve;
			emitter.pReverbCurve = (X3DAUDIO_DISTANCE_CURVE*)&X3DAudioDefault_LinearCurve;
#else
			emitter.CurveDistanceScaler = 1;
#endif

			emitter.OrientFront = { forward.x, forward.y, -forward.z };
			emitter.OrientTop = { up.x, up.y, -up.z };
			emitter.Position = { position.x, position.y, -position.z };

			float matrix[8] = {};


			uint32 dstChannels = context.soundTypeSubmixVoiceDetails[sound->type].InputChannels;

			X3DAUDIO_DSP_SETTINGS dspSettings = { 0 };
			dspSettings.SrcChannelCount = srcChannels;
			dspSettings.DstChannelCount = dstChannels;
			dspSettings.pMatrixCoefficients = matrix;

			UINT32 flags = 0;
			flags |= X3DAUDIO_CALCULATE_MATRIX;
			flags |= X3DAUDIO_CALCULATE_LPF_DIRECT;
			flags |= X3DAUDIO_CALCULATE_REVERB;
			flags |= X3DAUDIO_CALCULATE_LPF_REVERB;
			//flags |= X3DAUDIO_CALCULATE_DOPPLER;

			X3DAudioCalculate(context.xaudio3D, &context.listener, &emitter, flags, &dspSettings);

			checkResult(voice->SetOutputMatrix(context.soundTypeSubmixVoices[sound->type], srcChannels, dstChannels, matrix));


			for (uint32 i = 0; i < srcChannels; ++i)
			{
				matrix[i] = dspSettings.ReverbLevel;
			}

			checkResult(voice->SetOutputMatrix(context.reverbSubmixVoices[sound->type], srcChannels, 1, matrix));

			XAUDIO2_FILTER_PARAMETERS filterParametersDirect = { LowPassFilter, 2.f * sin(X3DAUDIO_PI / 6.f * dspSettings.LPFDirectCoefficient), 1.f };
			checkResult(voice->SetOutputFilterParameters(context.soundTypeSubmixVoices[sound->type], &filterParametersDirect));

			XAUDIO2_FILTER_PARAMETERS filterParametersReverb = { LowPassFilter, 2.f * sin(X3DAUDIO_PI / 6.f * dspSettings.LPFReverbCoefficient), 1.f };
			checkResult(voice->SetOutputFilterParameters(context.reverbSubmixVoices[sound->type], &filterParametersReverb));

			//std::cout << dspSettings.ReverbLevel << ", " << dspSettings.LPFDirectCoefficient << ", " << dspSettings.LPFReverbCoefficient << '\n';

			update3DTimer = UPDATE_3D_PERIOD;
		}

		--update3DTimer;
	}
}

bool audio_channel::shouldBeVirtual()
{
	return false;
}









static DWORD WINAPI streamFileAudio(void* parameter)
{
	audio_channel* channel = (audio_channel*)parameter;
	auto sound = channel->sound;
	auto voice = channel->voice;

	BYTE buffers[MAX_BUFFER_COUNT][STREAMING_BUFFER_SIZE];

	uint32 currentBufferIndex = 0;


	bool quit = false;

	while (!quit)
	{
		uint32 currentPosition = 0;

		if (SetFilePointer(sound->fileHandle, sound->chunkPosition, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
		{
			break;
		}

		while (!quit && currentPosition < sound->chunkSize)
		{
			DWORD size = STREAMING_BUFFER_SIZE;
			if (ReadFile(sound->fileHandle, buffers[currentBufferIndex], size, &size, 0) == 0)
			{
				quit = true;
				break;
			}

			currentPosition += size;

			XAUDIO2_BUFFER buffer = { 0 };
			buffer.AudioBytes = size;
			buffer.pAudioData = buffers[currentBufferIndex];
			buffer.pContext = channel->bufferEndSemaphore;

			checkResult(voice->SubmitSourceBuffer(&buffer));

			XAUDIO2_VOICE_STATE state;
			voice->GetState(&state, XAUDIO2_VOICE_NOSAMPLESPLAYED);
			while (!quit && state.BuffersQueued > MAX_BUFFER_COUNT - 1)
			{
				WaitForSingleObject(channel->bufferEndSemaphore, INFINITE);
				voice->GetState(&state, XAUDIO2_VOICE_NOSAMPLESPLAYED);

				if (channel->state == channel_state_stopped)
				{
					quit = true;
				}
			}
			currentBufferIndex++;
			currentBufferIndex %= MAX_BUFFER_COUNT;
		}

		if (!channel->userSettings.loop)
		{
			break;
		}
	}

	if (!quit)
	{
		XAUDIO2_VOICE_STATE state;
		while (voice->GetState(&state, XAUDIO2_VOICE_NOSAMPLESPLAYED), state.BuffersQueued > 0)
		{
			WaitForSingleObject(channel->bufferEndSemaphore, INFINITE);
		}
	}

	channel->stop(0.f);

	channel->threadStopped = true;

	return 0;
}

static DWORD WINAPI streamSynthAudio(void* parameter)
{
	audio_channel* channel = (audio_channel*)parameter;
	auto sound = channel->sound;
	auto voice = channel->voice;



	float buffers[MAX_BUFFER_COUNT][STREAMING_BUFFER_SIZE];

	uint32 currentBufferIndex = 0;

	bool quit = false;

	while (!quit)
	{
		uint8 synthBuffer[MAX_SYNTH_SIZE];
		audio_synth* synth = sound->createSynth(synthBuffer);

		while (true)
		{
			uint32 size = STREAMING_BUFFER_SIZE;
			size = synth->getSamples(buffers[currentBufferIndex], size);

			if (size == 0)
			{
				break;
			}

			XAUDIO2_BUFFER buffer = { 0 };
			buffer.AudioBytes = size * sizeof(float);
			buffer.pAudioData = (BYTE*)buffers[currentBufferIndex];
			buffer.pContext = channel->bufferEndSemaphore;

			checkResult(voice->SubmitSourceBuffer(&buffer));

			XAUDIO2_VOICE_STATE state;
			voice->GetState(&state, XAUDIO2_VOICE_NOSAMPLESPLAYED);
			while (!quit && state.BuffersQueued > MAX_BUFFER_COUNT - 1)
			{
				WaitForSingleObject(channel->bufferEndSemaphore, INFINITE);
				voice->GetState(&state, XAUDIO2_VOICE_NOSAMPLESPLAYED);

				if (channel->state == channel_state_stopped)
				{
					quit = true;
				}
			}
			currentBufferIndex++;
			currentBufferIndex %= MAX_BUFFER_COUNT;
		}

		if (!channel->userSettings.loop)
		{
			break;
		}
	}

	if (!quit)
	{
		XAUDIO2_VOICE_STATE state;
		while (voice->GetState(&state, XAUDIO2_VOICE_NOSAMPLESPLAYED), state.BuffersQueued > 0)
		{
			WaitForSingleObject(channel->bufferEndSemaphore, INFINITE);
		}
	}

	channel->stop(0.f);

	channel->threadStopped = true;

	return 0;
}



```

`src/audio/channel.h`:

```h
#pragma once

#include "sound.h"
#include "core/math.h"

#include <x3daudio.h>

enum channel_state
{
	channel_state_to_play,
	channel_state_playing,

	channel_state_stopping,
	channel_state_stopped,

	channel_state_virtualizing,
	channel_state_virtual,
};

struct property_fader
{
	void initialize(float start)
	{
		current = start;
		totalTime = 0.f;
	}

	void startFade(float to, float time)
	{
		this->from = current;
		this->to = to;
		this->totalTime = time;
		this->timer = 0.f;

		if (time <= 0.f)
		{
			this->current = to;
		}
	}

	void update(float dt)
	{
		if (totalTime != 0.f)
		{
			timer += dt;
			current = lerp(from, to, clamp01(timer / totalTime));
		}
	}

	float from, to;
	float totalTime;
	float timer;

	float current;
};

struct audio_context
{
	com<IXAudio2> xaudio;
	
	IXAudio2MasteringVoice* masterVoice;
	XAUDIO2_VOICE_DETAILS masterVoiceDetails;

	IXAudio2SubmixVoice* soundTypeSubmixVoices[sound_type_count];
	XAUDIO2_VOICE_DETAILS soundTypeSubmixVoiceDetails[sound_type_count];
	IXAudio2SubmixVoice* reverbSubmixVoices[sound_type_count];

	X3DAUDIO_HANDLE xaudio3D;
	X3DAUDIO_LISTENER listener;
};

struct audio_channel
{
	audio_channel(const audio_context& context, const ref<audio_sound>& sound, const sound_settings& settings);
	audio_channel(const audio_context& context, const ref<audio_sound>& sound, vec3 position, const sound_settings& settings);
	~audio_channel();

	void update(const audio_context& context, float dt);
	void stop(float fadeOutTime);

	sound_settings* getSettings() { return &userSettings; }

	bool hasStopped();

	ref<audio_sound> sound;
	bool positioned;
	vec3 position;

private:
	void initialize(const audio_context& context, const ref<audio_sound>& sound, const sound_settings& settings, bool positioned, vec3 position = vec3(0.f));

	void updateSoundSettings(const audio_context& context, float dt);

	bool shouldBeVirtual();

	uint32 update3DTimer = 0;

	volatile channel_state state = channel_state_to_play;

	property_fader upDownFader;
	property_fader volumeFader;
	property_fader pitchFader;

	IXAudio2SourceVoice* voice;

	uint32 srcChannels;
	
	sound_settings userSettings;
	sound_settings oldUserSettings;

	float oldVolume = -1.f;
	float oldPitch = -1.f;


	struct voice_callback : IXAudio2VoiceCallback
	{
		audio_channel* channel;

		virtual void __stdcall OnVoiceProcessingPassStart(uint32 bytesRequired) override {}
		virtual void __stdcall OnVoiceProcessingPassEnd() override {}
		virtual void __stdcall OnStreamEnd() override { /*std::cout << "Stream end\n";*/ channel->stop(0.f); }
		virtual void __stdcall OnVoiceError(void* bufferContext, HRESULT error) override { std::cerr << "Error!\n"; }
		virtual void __stdcall OnBufferStart(void* bufferContext) override {}
		virtual void __stdcall OnBufferEnd(void* bufferContext) override { /*std::cout << "Buffer end\n";*/ if (bufferContext) { ReleaseSemaphore((HANDLE)bufferContext, 1, 0); } }
		virtual void __stdcall OnLoopEnd(void* bufferContext) override {}
	};

	voice_callback voiceCallback;

	HANDLE threadHandle = INVALID_HANDLE_VALUE;
	friend DWORD WINAPI streamFileAudio(void* parameter);
	friend DWORD WINAPI streamSynthAudio(void* parameter);

	HANDLE bufferEndSemaphore;

	bool threadStopped = true;
};

```

`src/audio/reverb.h`:

```h
#pragma once




enum reverb_preset
{
	reverb_none = -1,

	reverb_preset_default,
	reverb_preset_generic,
	reverb_preset_padded_cell,
	reverb_preset_room,
	reverb_preset_bathroom,
	reverb_preset_livingroom,
	reverb_preset_stone_room,
	reverb_preset_auditorium,
	reverb_preset_concert_hall,
	reverb_preset_cave,
	reverb_preset_arena,
	reverb_preset_hangar,
	reverb_preset_carpeted_hallway,
	reverb_preset_hallway,
	reverb_preset_stone_corridor,
	reverb_preset_alley,
	reverb_preset_forest,
	reverb_preset_city,
	reverb_preset_mountains,
	reverb_preset_quarry,
	reverb_preset_plain,
	reverb_preset_parking_lot,
	reverb_preset_sewer_pipe,
	reverb_preset_under_water,
	reverb_preset_small_room,
	reverb_preset_medium_room,
	reverb_preset_large_room,
	reverb_preset_medium_hall,
	reverb_preset_large_hall,
	reverb_preset_plate,

	reverb_preset_count,
};

static const char* reverbPresetNames[] =
{
	"Default",
	"Generic",
	"Padded cell",
	"Room",
	"Bathroom",
	"Livingroom",
	"Stone room",
	"Auditorium",
	"Concert hall",
	"Cave",
	"Arena",
	"Hangar",
	"Carpeted hallway",
	"Hallway",
	"Stone corridor",
	"Alley",
	"Forest",
	"City",
	"Mountains",
	"Quarry",
	"Plain",
	"Parking lot",
	"Sewer pipe",
	"Under water",
	"Small room",
	"Medium room",
	"Large room",
	"Medium hall",
	"Large hall",
	"Plate",
};



```

`src/audio/sound.cpp`:

```cpp
#include "pch.h"
#include "sound.h"
#include "audio.h"
#include "sound_management.h"

#include "core/log.h"
#include "asset/file_registry.h"

#include <unordered_map>

#define fourccRIFF 'FFIR'
#define fourccDATA 'atad'
#define fourccFMT ' tmf'
#define fourccWAVE 'EVAW'
#define fourccXWMA 'AMWX'
#define fourccDPDS 'sdpd'


static HANDLE openFile(const fs::path& path);
static void closeFile(HANDLE& fileHandle);
static bool getWFX(HANDLE fileHandle, const fs::path& path, WAVEFORMATEXTENSIBLE& wfx);
static bool findChunk(HANDLE fileHandle, uint32 fourcc, uint32& chunkSize, uint32& chunkDataPosition);
static bool readChunkData(HANDLE fileHandle, void* buffer, uint32 buffersize, uint32 bufferoffset);


static std::unordered_map<uint64, ref<audio_sound>> fileSounds;
static std::unordered_map<uint64, ref<audio_sound>> synthSounds;


bool checkForExistingFileSound(sound_id id) 
{ 
    auto it = fileSounds.find(id.hash);
    return (it != fileSounds.end()) && it->second != 0;
}

bool checkForExistingSynthSound(sound_id id) 
{ 
    auto it = synthSounds.find(id.hash);
    return (it != synthSounds.end()) && it->second != 0;
}

void registerSound(sound_id id, const ref<audio_sound>& sound)
{
    if (!sound->isSynth)
    {
        fileSounds[id.hash] = sound;
    }
    else
    {
        synthSounds[id.hash] = sound;
    }
}

bool loadFileSound(sound_id id)
{
    if (checkForExistingFileSound(id))
    {
        return true;
    }
    else
    {
        const sound_spec& spec = getSoundSpec(id);

        fs::path path = getPathFromAssetHandle(spec.asset);
        if (!path.empty())
        {
            HANDLE fileHandle = openFile(path);
            if (fileHandle != INVALID_HANDLE_VALUE)
            {
                WAVEFORMATEXTENSIBLE wfx;
                uint32 chunkSize, chunkPosition;

                bool success = false;
                BYTE* dataBuffer = 0;

                // Find and retrieve format chunk.
                if (getWFX(fileHandle, path, wfx))
                {
                    // Find data chunk.
                    if (findChunk(fileHandle, fourccDATA, chunkSize, chunkPosition))
                    {
                        success = true;

                        if (!spec.stream)
                        {
                            dataBuffer = new BYTE[chunkSize];
                            success = readChunkData(fileHandle, dataBuffer, chunkSize, chunkPosition);
                            if (!success)
                            {
                                delete[] dataBuffer;
                            }

                            closeFile(fileHandle);
                        }
                    }
                }

                if (success)
                {
                    ref<audio_sound> sound = make_ref<audio_sound>();
                    sound->id = id;
                    sound->path = path;
                    sound->stream = spec.stream;
                    sound->fileHandle = fileHandle;
                    sound->wfx = wfx;
                    sound->chunkSize = chunkSize;
                    sound->chunkPosition = chunkPosition;
                    sound->dataBuffer = dataBuffer;
                    sound->isSynth = false;
                    sound->type = spec.type;

                    registerSound(id, sound);
                }
                else
                {
                    closeFile(fileHandle);
                }

                return success;
            }
        }

        return false;
    }
}

void unloadSound(sound_id id)
{
    fileSounds.erase(id.hash);
    synthSounds.erase(id.hash);
}

void unloadAllSounds()
{
    fileSounds.clear();
    synthSounds.clear();
}

ref<audio_sound> getSound(sound_id id)
{
    auto it = fileSounds.find(id.hash);
    ref<audio_sound> result = (it != fileSounds.end()) ? it->second : 0;
    if (result) { return result; }

    it = synthSounds.find(id.hash);
    result = (it != synthSounds.end()) ? it->second : 0;
    return result;
}

audio_sound::~audio_sound()
{
    closeFile(fileHandle);
    if (dataBuffer)
    {
        delete[] dataBuffer;
    }
}







static HANDLE openFile(const fs::path& path)
{
    HANDLE fileHandle = CreateFileW(
        path.c_str(),
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        0, //FILE_FLAG_NO_BUFFERING,
        NULL);

    if (fileHandle == INVALID_HANDLE_VALUE)
    {
        LOG_ERROR("Could not open file '%ws'", path.c_str());
    }

    return fileHandle;
}

static void closeFile(HANDLE& fileHandle)
{
    if (fileHandle != INVALID_HANDLE_VALUE)
    {
        CloseHandle(fileHandle);
        fileHandle = INVALID_HANDLE_VALUE;
    }
}

static bool findChunk(HANDLE fileHandle, uint32 fourcc, uint32& chunkSize, uint32& chunkDataPosition)
{
    if (SetFilePointer(fileHandle, 0, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
    {
        LOG_ERROR("Could not set file pointer");
        return false;
    }

    DWORD chunkType;
    DWORD chunkDataSize;
    DWORD riffDataSize = 0;
    DWORD fileType;
    DWORD bytesRead = 0;
    DWORD offset = 0;

    HRESULT hr = S_OK;
    while (hr == S_OK)
    {
        DWORD dwRead;
        if (ReadFile(fileHandle, &chunkType, sizeof(DWORD), &dwRead, NULL) == 0)
        {
            LOG_ERROR("Could not read chunk type");
            return false;
        }

        if (ReadFile(fileHandle, &chunkDataSize, sizeof(DWORD), &dwRead, NULL) == 0)
        {
            LOG_ERROR("Could not read chunk data size");
            return false;
        }


        if (chunkType == fourccRIFF)
        {
            riffDataSize = chunkDataSize;
            chunkDataSize = 4;
            if (ReadFile(fileHandle, &fileType, sizeof(DWORD), &dwRead, NULL) == 0)
            {
                LOG_ERROR("Could not read file type");
                return false;
            }
        }
        else
        {
            if (SetFilePointer(fileHandle, chunkDataSize, NULL, FILE_CURRENT) == INVALID_SET_FILE_POINTER)
            {
                LOG_ERROR("Could not set file pointer");
                return false;
            }
        }

        offset += sizeof(DWORD) * 2;

        if (chunkType == fourcc)
        {
            chunkSize = chunkDataSize;
            chunkDataPosition = offset;
            return true;
        }

        offset += chunkDataSize;

        if (bytesRead >= riffDataSize)
        {
            return false;
        }
    }

    return true;
}

static bool readChunkData(HANDLE fileHandle, void* buffer, uint32 buffersize, uint32 bufferoffset)
{
    if (SetFilePointer(fileHandle, bufferoffset, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
    {
        LOG_ERROR("Could not set file pointer");
        return false;
    }

    DWORD dwRead;
    if (ReadFile(fileHandle, buffer, buffersize, &dwRead, NULL) == 0)
    {
        LOG_ERROR("Could not read chunk");
        return false;
    }

    return true;
}

static bool getWFX(HANDLE fileHandle, const fs::path& path, WAVEFORMATEXTENSIBLE& wfx)
{
    uint32 chunkSize, chunkPosition;

    //Check the file type, should be fourccWAVE or 'XWMA'.
    if (!findChunk(fileHandle, fourccRIFF, chunkSize, chunkPosition))
    {
        return false;
    }

    DWORD filetype;
    if (!readChunkData(fileHandle, &filetype, sizeof(DWORD), chunkPosition))
    {
        return false;
    }

    if (filetype != fourccWAVE)
    {
        LOG_ERROR("File type of file '%ws' must be WAVE", path.c_str());
        return false;
    }

    if (!findChunk(fileHandle, fourccFMT, chunkSize, chunkPosition))
    {
        return false;
    }
    if (!readChunkData(fileHandle, &wfx, chunkSize, chunkPosition))
    {
        return false;
    }

    return true;
}


bool isSoundExtension(const fs::path& extension)
{
    return extension == ".wav";
}

bool isSoundExtension(const std::string& extension)
{
    return extension == ".wav";
}


```

`src/audio/sound.h`:

```h
#pragma once

#include "synth.h"
#include "core/string.h"
#include "asset/asset.h"

#include <xaudio2.h>
#include <functional>


struct sound_id
{
    const char* id;
    uint64 hash;
};

#define SOUND_ID(id) sound_id{ id, COMPILE_TIME_STRING_HASH_64(id) }


enum sound_type
{
    sound_type_music,
    sound_type_sfx,

    sound_type_count,
};

static const char* soundTypeNames[] =
{
    "Music",
    "Effects",
};

struct sound_spec
{
    std::string name;
    asset_handle asset;
    sound_type type;
    bool stream;
};


struct audio_sound
{
    sound_id id;

    fs::path path;
    bool stream;
    bool isSynth;

    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    WAVEFORMATEXTENSIBLE wfx = {};
    uint32 chunkSize;
    uint32 chunkPosition;
    BYTE* dataBuffer = 0;

    sound_type type;

    virtual ~audio_sound();

    virtual audio_synth* createSynth(void* buffer) const { return 0; }
};

struct sound_settings
{
    float volume = 1.f;
    float pitch = 1.f;
    float radius = 30.f;
    bool loop = false;

    float volumeFadeTime = 0.1f;
    float pitchFadeTime = 0.1f;
};

ref<audio_sound> getSound(sound_id id);


void unloadSound(sound_id id);
void unloadAllSounds();

bool loadFileSound(sound_id id);

template <typename synth_t, typename... args>
static bool loadSynthSound(const char* idStr, sound_type type, bool stream, const args&... a)
{
    static_assert(std::is_base_of_v<audio_synth, synth_t>, "Synthesizer must inherit from audio_synth");
    static_assert(sizeof(synth_t) <= MAX_SYNTH_SIZE);

    sound_id id = { idStr, hashString64(idStr) };
    sound_spec spec = { {}, type, stream };

    bool checkForExistingSynthSound(sound_id);
    void registerSound(sound_id, const ref<audio_sound>&);

    if (checkForExistingSynthSound(id))
    {
        return true;
    }
    else
    {
        struct synth_sound : audio_sound
        {
            std::function<audio_synth* (void*)> createFunc;

            virtual audio_synth* createSynth(void* buffer) const override
            {
                return createFunc(buffer);
            }
        };


        ref<audio_sound> sound;

        WAVEFORMATEX wfx = {};
        wfx.wFormatTag = WAVE_FORMAT_IEEE_FLOAT;
        wfx.nChannels = synth_t::numChannels;
        wfx.nSamplesPerSec = synth_t::sampleHz;
        wfx.wBitsPerSample = synth_t::numChannels * (uint32)sizeof(float) * 8;
        wfx.nBlockAlign = synth_t::numChannels * (uint32)sizeof(float);
        wfx.nAvgBytesPerSec = synth_t::sampleHz * synth_t::numChannels * (uint32)sizeof(float);
        wfx.cbSize = 0; // Set to zero for PCM or IEEE float.

        BYTE* dataBuffer = 0;
        uint32 dataSize = 0;

        if (!stream)
        {
            sound = make_ref<audio_sound>();

            synth_t synth(a...);
            uint32 totalNumSamples = (uint32)(synth.getDuration() * synth_t::numChannels * synth_t::sampleHz);
            uint32 size = sizeof(float) * totalNumSamples;

            dataBuffer = new BYTE[size];
            synth.getSamples((float*)dataBuffer, totalNumSamples);

            dataSize = size;
        }
        else
        {
            auto s = make_ref<synth_sound>();

            s->createFunc = [=](void* buffer)
            {
                return new(buffer) synth_t(a...);
            };

            sound = s;
        }

        sound->id = id;
        sound->stream = stream;
        sound->wfx = { wfx };
        sound->dataBuffer = dataBuffer;
        sound->chunkSize = dataSize;
        sound->isSynth = true;
        sound->type = type;

        registerSound(id, sound);

        return true;
    }
}

bool isSoundExtension(const fs::path& extension);
bool isSoundExtension(const std::string& extension);


```

`src/audio/sound_management.cpp`:

```cpp
#include "pch.h"
#include "sound_management.h"
#include "audio.h"
#include "editor/editor_icons.h"

#include "core/log.h"
#include "core/imgui.h"
#include "core/yaml.h"




static std::unordered_map<uint64, sound_spec> soundRegistry;
static const fs::path registryPath = fs::path(L"resources/sounds.yaml").lexically_normal();



void loadSoundRegistry()
{
    std::ifstream stream(registryPath);
    YAML::Node n = YAML::Load(stream);

    for (auto entryNode : n)
    {
        sound_spec spec = {};

        YAML_LOAD(entryNode, spec.asset, "Asset");
        YAML_LOAD_ENUM(entryNode, spec.type, "Type");
        YAML_LOAD(entryNode, spec.stream, "Stream");
        YAML_LOAD(entryNode, spec.name, "Tag");

        uint64 hash = hashString64(spec.name.c_str());

        soundRegistry[hash] = spec;
    }
}

static void saveSoundRegistry()
{
    YAML::Node out;

    for (auto [id, spec] : soundRegistry)
    {
        YAML::Node n;
        n["Tag"] = spec.name;
        n["Asset"] = spec.asset;
        n["Type"] = (uint32)spec.type;
        n["Stream"] = spec.stream;

        out.push_back(n);
    }

    fs::create_directories(registryPath.parent_path());

    LOG_MESSAGE("Rewriting sound registry");
    std::ofstream fout(registryPath);
    fout << out;
}

void drawSoundEditor(bool& open)
{
    if (open)
    {
        if (ImGui::Begin(EDITOR_ICON_AUDIO "  Sound Editing", &open))
        {
            static ImGuiTextFilter filter;
            filter.Draw();

            static bool dirty = false;

            if (ImGui::DisableableButton("Save registry", dirty))
            {
                saveSoundRegistry();

                unloadAllSounds(); // Unload, such that the spec gets reloaded when the sound is played the next time.
                restartAllSounds();

                dirty = false;
            }

            for (auto& [id, spec] : soundRegistry)
            {
                std::string& name = spec.name;
                if (filter.PassFilter(name.c_str()))
                {
                    if (ImGui::BeginTree(name.c_str()))
                    {
                        if (ImGui::BeginProperties())
                        {
                            dirty |= ImGui::PropertyAssetHandle("Asset", EDITOR_ICON_AUDIO, spec.asset);
                            dirty |= ImGui::PropertyDropdown("Type", soundTypeNames, sound_type_count, (uint32&)spec.type);
                            dirty |= ImGui::PropertyCheckbox("Stream", spec.stream);

                            ImGui::EndProperties();
                        }

                        ImGui::EndTree();
                    }
                }
            }

            ImGui::Separator();

            static char input[128] = "";
            ImGui::InputText("##input", input, sizeof(input));
            ImGui::SameLine();
            if (ImGui::DisableableButton("Add sound", input[0] != 0))
            {
                sound_spec spec = {};
                spec.name = input;
                
                uint64 hash = hashString64(input);
                soundRegistry.insert({ hash, spec });

                input[0] = 0;
            }
        }
        ImGui::End();
    }
}

static sound_spec nullSpec = {};

const sound_spec& getSoundSpec(const sound_id& id)
{
    auto it = soundRegistry.find(id.hash);
    return (it != soundRegistry.end()) ? it->second : nullSpec;
}


```

`src/audio/sound_management.h`:

```h
#pragma once

#include "sound.h"


void loadSoundRegistry();
void drawSoundEditor(bool& open);

const sound_spec& getSoundSpec(const sound_id& id);


```

`src/audio/synth.h`:

```h
#pragma once

#include "core/math.h"

#define C_HZ		261.63f
#define C_SHARP_HZ	277.18f
#define D_HZ		293.66f
#define D_SHARP_HZ	311.13f
#define E_HZ		329.63f
#define F_HZ		349.23f
#define F_SHARP_HZ	369.99f
#define G_HZ		392.00f
#define G_SHARP_HZ	415.30f
#define A_HZ		440.00f
#define A_SHARP_HZ	466.16f
#define B_HZ		493.88f


#define MAX_SYNTH_SIZE 1024


struct audio_synth
{
	virtual uint32 getSamples(float* buffer, uint32 numSamples) = 0;
	virtual float getDuration() const { return 0.f; } // You only need to override this, if you don't stream the audio.
};

struct sine_synth : audio_synth
{
	static const uint32 numChannels = 1;
	static const uint32 sampleHz = 44100;

	sine_synth(float duration = 10.f, float hz = C_HZ)
		: audio_synth()
	{
		this->hz = hz;

		// Round duration such that there is an integer amount of waves over the runtime. This prevents clicking for looping sounds.
		float waves = duration * hz;
		duration = floor(waves) / hz;

		this->duration = duration;
		this->totalNumSamples = (uint32)(duration * numChannels * sampleHz);
	}

	virtual uint32 getSamples(float* buffer, uint32 numSamples) override
	{
		if (offset + numSamples > totalNumSamples)
		{
			numSamples = totalNumSamples - offset;
		}

		float factor = M_TAU / sampleHz * hz;
		for (uint32 i = 0; i < numSamples; ++i, ++offset)
		{
			buffer[i] = sin(offset * factor);
		}
		return numSamples;
	}

	virtual float getDuration() const override { return duration; }

private:
	uint32 totalNumSamples;
	float hz;
	float duration;

	uint32 offset = 0;
};


```

`src/core/block_allocator.cpp`:

```cpp
#include "pch.h"
#include "block_allocator.h"


void block_allocator::initialize(uint64 capacity)
{
	availableSize = capacity;
	addNewBlock(0, capacity);
}

uint64 block_allocator::allocate(uint64 requestedSize)
{
	auto smallestBlockItIt = blocksBySize.lower_bound(requestedSize);
	if (smallestBlockItIt == blocksBySize.end())
	{
		return UINT64_MAX;
	}

	size_value sizeValue = smallestBlockItIt->second;

	uint64 offset = sizeValue.getOffset();
	uint64 size = smallestBlockItIt->first;

	uint64 newOffset = offset + requestedSize;
	uint64 newSize = size - requestedSize;

	blocksBySize.erase(smallestBlockItIt);
	blocksByOffset.erase(sizeValue.offsetIterator);

	if (newSize > 0)
	{
		addNewBlock(newOffset, newSize);
	}

	availableSize -= requestedSize;
	return offset;
}

void block_allocator::free(uint64 offset, uint64 size)
{
	auto nextBlockIt = blocksByOffset.upper_bound(offset);
	auto prevBlockIt = nextBlockIt;
	if (prevBlockIt != blocksByOffset.begin())
	{
		--prevBlockIt;
	}
	else
	{
		prevBlockIt = blocksByOffset.end();
	}

	uint64 newOffset, newSize;
	if (prevBlockIt != blocksByOffset.end() && offset == prevBlockIt->first + prevBlockIt->second.getSize())
	{
		// PrevBlock.Offset           Offset
		// |                          |
		// |<-----PrevBlock.Size----->|<------Size-------->|
		//
		newSize = prevBlockIt->second.getSize() + size;
		newOffset = prevBlockIt->first;

		if (nextBlockIt != blocksByOffset.end() && offset + size == nextBlockIt->first)
		{
			// PrevBlock.Offset           Offset               NextBlock.Offset
			// |                          |                    |
			// |<-----PrevBlock.Size----->|<------Size-------->|<-----NextBlock.Size----->|
			//
			newSize += nextBlockIt->second.getSize();
			blocksBySize.erase(prevBlockIt->second.sizeIterator);
			blocksBySize.erase(nextBlockIt->second.sizeIterator);
			// Delete the range of two blocks
			++nextBlockIt;
			blocksByOffset.erase(prevBlockIt, nextBlockIt);
		}
		else
		{
			// PrevBlock.Offset           Offset                       NextBlock.Offset
			// |                          |                            |
			// |<-----PrevBlock.Size----->|<------Size-------->| ~ ~ ~ |<-----NextBlock.Size----->|
			//
			blocksBySize.erase(prevBlockIt->second.sizeIterator);
			blocksByOffset.erase(prevBlockIt);
		}
	}
	else if (nextBlockIt != blocksByOffset.end() && offset + size == nextBlockIt->first)
	{
		// PrevBlock.Offset                   Offset               NextBlock.Offset
		// |                                  |                    |
		// |<-----PrevBlock.Size----->| ~ ~ ~ |<------Size-------->|<-----NextBlock.Size----->|
		//
		newSize = size + nextBlockIt->second.getSize();
		newOffset = offset;
		blocksBySize.erase(nextBlockIt->second.sizeIterator);
		blocksByOffset.erase(nextBlockIt);
	}
	else
	{
		// PrevBlock.Offset                   Offset                       NextBlock.Offset
		// |                                  |                            |
		// |<-----PrevBlock.Size----->| ~ ~ ~ |<------Size-------->| ~ ~ ~ |<-----NextBlock.Size----->|
		//
		newSize = size;
		newOffset = offset;
	}

	addNewBlock(newOffset, newSize);

	availableSize += size;
}


```

`src/core/block_allocator.h`:

```h
#pragma once

#include <map>


// Based on https://www.codeproject.com/Articles/1180070/Simple-Variable-Size-Memory-Block-Allocator.
struct block_allocator
{
	uint64 availableSize;

	void initialize(uint64 capacity);

	// Returns the offset.
	uint64 allocate(uint64 requestedSize);
	void free(uint64 offset, uint64 size);

private:

	struct offset_value;
	struct size_value;

	// Referencing each-other.
	using block_by_offset_map = std::map<uint64, offset_value>;
	using block_by_size_map = std::multimap<uint64, size_value>;

	struct offset_value
	{
		offset_value() {}
		offset_value(block_by_size_map::iterator sizeIterator) : sizeIterator(sizeIterator) {}
		block_by_size_map::iterator sizeIterator;
		uint64 getSize() { return sizeIterator->first; }
	};

	struct size_value
	{
		size_value() {}
		size_value(block_by_offset_map::iterator offsetIterator) : offsetIterator(offsetIterator) {}
		block_by_offset_map::iterator offsetIterator;
		uint64 getOffset() { return offsetIterator->first; }
	};

	block_by_offset_map blocksByOffset;
	block_by_size_map blocksBySize;


	void addNewBlock(uint64 offset, uint64 size)
	{
		auto newBlockIt = blocksByOffset.emplace(offset, offset_value());
		auto orderIt = blocksBySize.emplace(size, newBlockIt.first);
		newBlockIt.first->second.sizeIterator = orderIt;
	}
};


```

`src/core/camera.cpp`:

```cpp
#include "pch.h"
#include "camera.h"

void render_camera::initializeIngame(vec3 position, quat rotation, float verticalFOV, float nearPlane, float farPlane)
{
	type = camera_type_ingame;
	this->position = position;
	this->rotation = rotation;
	this->verticalFOV = verticalFOV;
	this->nearPlane = nearPlane;
	this->farPlane = farPlane;
}

void render_camera::initializeCalibrated(vec3 position, quat rotation, uint32 width, uint32 height, float fx, float fy, float cx, float cy, float nearPlane, float farPlane)
{
	type = camera_type_calibrated;
	this->position = position;
	this->rotation = rotation;
	this->fx = fx;
	this->fy = fy;
	this->cx = cx;
	this->cy = cy;
	this->width = width;
	this->height = height;
	this->nearPlane = nearPlane;
	this->farPlane = farPlane;
	this->aspect = (float)width / (float)height;
}

void render_camera::setViewport(uint32 width, uint32 height)
{
	this->width = width;
	this->height = height;
	aspect = (float)width / (float)height;
}

void render_camera::updateMatrices()
{
	if (type == camera_type_ingame)
	{
		proj = createPerspectiveProjectionMatrix(verticalFOV, aspect, nearPlane, farPlane);
	}
	else
	{
		ASSERT(type == camera_type_calibrated);
		proj = createPerspectiveProjectionMatrix((float)width, (float)height, fx, fy, cx, cy, nearPlane, farPlane);
	}

	invProj = invertPerspectiveProjectionMatrix(proj);
	view = createViewMatrix(position, rotation);
	invView = invertAffine(view);
	viewProj = proj * view;
	invViewProj = invView * invProj;
}

camera_projection_extents render_camera::getProjectionExtents() const
{
	if (type == camera_type_ingame)
	{
		float extentY = tanf(0.5f * verticalFOV);
		float extentX = extentY * aspect;

		return camera_projection_extents{ extentX, extentX, extentY, extentY };
	}
	else
	{
		ASSERT(type == camera_type_calibrated);

		vec3 topLeft = restoreViewSpacePosition(vec2(0.f, 0.f), 0.f) / nearPlane;
		vec3 bottomRight = restoreViewSpacePosition(vec2(1.f, 1.f), 0.f) / nearPlane;

		return camera_projection_extents{ -topLeft.x, bottomRight.x, topLeft.y, -bottomRight.y };
	}
}

float render_camera::getMinProjectionExtent() const
{
	camera_projection_extents extents = getProjectionExtents();
	float minHorizontalExtent = min(extents.left, extents.right);
	float minVerticalExtent = min(extents.top, extents.bottom);
	float minExtent = min(minHorizontalExtent, minVerticalExtent);
	return minExtent;
}

ray render_camera::generateWorldSpaceRay(float relX, float relY) const
{
	float ndcX = 2.f * relX - 1.f;
	float ndcY = -(2.f * relY - 1.f);
	vec4 clip(ndcX, ndcY, -1.f, 1.f);
	vec4 eye = invProj * clip;
	eye.z = -1.f; eye.w = 0.f;

	ray result;
	result.origin = position;
	result.direction = normalize((invView * eye).xyz);
	return result;
}

ray render_camera::generateViewSpaceRay(float relX, float relY) const
{
	float ndcX = 2.f * relX - 1.f;
	float ndcY = -(2.f * relY - 1.f);
	vec4 clip(ndcX, ndcY, -1.f, 1.f);
	vec4 eye = invProj * clip;
	eye.z = -1.f;

	ray result;
	result.origin = vec3(0.f, 0.f, 0.f);
	result.direction = normalize(eye.xyz);
	return result;
}

vec3 render_camera::restoreViewSpacePosition(vec2 uv, float depthBufferDepth) const
{
	uv.y = 1.f - uv.y; // Screen uvs start at the top left, so flip y.
	vec3 ndc = vec3(uv * 2.f - vec2(1.f, 1.f), depthBufferDepth);
	vec4 homPosition = invProj * vec4(ndc, 1.f);
	vec3 position = homPosition.xyz / homPosition.w;
	return position;
}

vec3 render_camera::restoreWorldSpacePosition(vec2 uv, float depthBufferDepth) const
{
	uv.y = 1.f - uv.y; // Screen uvs start at the top left, so flip y.
	vec3 ndc = vec3(uv * 2.f - vec2(1.f, 1.f), depthBufferDepth);
	vec4 homPosition = invViewProj * vec4(ndc, 1.f);
	vec3 position = homPosition.xyz / homPosition.w;
	return position;
}

float render_camera::depthBufferDepthToEyeDepth(float depthBufferDepth) const
{
	if (farPlane < 0.f) // Infinite far plane.
	{
		depthBufferDepth = clamp(depthBufferDepth, 0.f, 1.f - 1e-7f); // A depth of 1 is at infinity.
		return -nearPlane / (depthBufferDepth - 1.f);
	}
	else
	{
		const float c1 = farPlane / nearPlane;
		const float c0 = 1.f - c1;
		return farPlane / (c0 * depthBufferDepth + c1);
	}
}

float render_camera::eyeDepthToDepthBufferDepth(float eyeDepth) const
{
	return -proj.m22 + proj.m23 / eyeDepth;
}

float render_camera::linearizeDepthBuffer(float depthBufferDepth) const
{
	ASSERT(farPlane > 0.f); // This is not possible with an infinite far plane.

	float eyeDepth = depthBufferDepthToEyeDepth(depthBufferDepth);
	return (eyeDepth - nearPlane) / farPlane;
}

camera_frustum_corners render_camera::getWorldSpaceFrustumCorners(float alternativeFarPlane) const
{
	if (alternativeFarPlane <= 0.f)
	{
		alternativeFarPlane = farPlane;
	}

	float depthValue = eyeDepthToDepthBufferDepth(alternativeFarPlane);

	camera_frustum_corners result;

	result.eye = position;

	result.nearBottomLeft = restoreWorldSpacePosition(vec2(0.f, 1.f), 0.f);
	result.nearBottomRight = restoreWorldSpacePosition(vec2(1.f, 1.f), 0.f);
	result.nearTopLeft = restoreWorldSpacePosition(vec2(0.f, 0.f), 0.f);
	result.nearTopRight = restoreWorldSpacePosition(vec2(1.f, 0.f), 0.f);
	result.farBottomLeft = restoreWorldSpacePosition(vec2(0.f, 1.f), depthValue);
	result.farBottomRight = restoreWorldSpacePosition(vec2(1.f, 1.f), depthValue);
	result.farTopLeft = restoreWorldSpacePosition(vec2(0.f, 0.f), depthValue);
	result.farTopRight = restoreWorldSpacePosition(vec2(1.f, 0.f), depthValue);

	return result;
}

camera_frustum_planes getWorldSpaceFrustumPlanes(const mat4& viewProj)
{
	camera_frustum_planes result;

	vec4 c0(viewProj.m00, viewProj.m01, viewProj.m02, viewProj.m03);
	vec4 c1(viewProj.m10, viewProj.m11, viewProj.m12, viewProj.m13);
	vec4 c2(viewProj.m20, viewProj.m21, viewProj.m22, viewProj.m23);
	vec4 c3(viewProj.m30, viewProj.m31, viewProj.m32, viewProj.m33);

	result.leftPlane = c3 + c0;
	result.rightPlane = c3 - c0;
	result.topPlane = c3 - c1;
	result.bottomPlane = c3 + c1;
	result.nearPlane = c2;
	result.farPlane = c3 - c2;

	return result;
}

camera_frustum_planes render_camera::getWorldSpaceFrustumPlanes() const
{
	return ::getWorldSpaceFrustumPlanes(viewProj);
}

camera_frustum_corners render_camera::getViewSpaceFrustumCorners(float alternativeFarPlane) const
{
	if (alternativeFarPlane <= 0.f)
	{
		alternativeFarPlane = farPlane;
	}

	float depthValue = eyeDepthToDepthBufferDepth(alternativeFarPlane);

	camera_frustum_corners result;

	result.eye = position;

	result.nearBottomLeft = restoreViewSpacePosition(vec2(0.f, 1.f), 0.f);
	result.nearBottomRight = restoreViewSpacePosition(vec2(1.f, 1.f), 0.f);
	result.nearTopLeft = restoreViewSpacePosition(vec2(0.f, 0.f), 0.f);
	result.nearTopRight = restoreViewSpacePosition(vec2(1.f, 0.f), 0.f);
	result.farBottomLeft = restoreViewSpacePosition(vec2(0.f, 1.f), depthValue);
	result.farBottomRight = restoreViewSpacePosition(vec2(1.f, 1.f), depthValue);
	result.farTopLeft = restoreViewSpacePosition(vec2(0.f, 0.f), depthValue);
	result.farTopRight = restoreViewSpacePosition(vec2(1.f, 0.f), depthValue);

	return result;
}

render_camera render_camera::getJitteredVersion(vec2 offset) const
{
#if 0
	camera_projection_extents extents = getProjectionExtents();
	float texelSizeX = (extents.left + extents.right) / width;
	float texelSizeY = (extents.top + extents.bottom) / height;

	float jitterX = texelSizeX * offset.x;
	float jitterY = texelSizeY * offset.y;

	float left = jitterX - extents.left;
	float right = jitterX + extents.right;
	float bottom = jitterY - extents.bottom;
	float top = jitterY + extents.top;

	mat4 jitteredProj = createPerspectiveProjectionMatrix(right * nearPlane, left * nearPlane, top * nearPlane, bottom * nearPlane, nearPlane, farPlane);
#else
	mat4 jitteredProj = proj;

	// Since we have a right-handed coordinate system (where z is negative), this will get multiplied with a negative value.
	// By negating the offset, we counteract this.
	jitteredProj.m02 = -offset.x; 
	jitteredProj.m12 = -offset.y;
#endif
	render_camera result = *this;

	result.proj = jitteredProj;
	result.invProj = invert(jitteredProj);
	result.viewProj = jitteredProj * view;
	result.invViewProj = invView * result.invProj;

	return result;
}

bool camera_frustum_planes::cullWorldSpaceAABB(const bounding_box& aabb) const
{
	for (uint32 i = 0; i < 6; ++i)
	{
		vec4 plane = planes[i];
		vec4 vertex(
			(plane.x < 0.f) ? aabb.minCorner.x : aabb.maxCorner.x,
			(plane.y < 0.f) ? aabb.minCorner.y : aabb.maxCorner.y,
			(plane.z < 0.f) ? aabb.minCorner.z : aabb.maxCorner.z,
			1.f
		);
		if (dot(plane, vertex) < 0.f)
		{
			return true;
		}
	}
	return false;
}

bool camera_frustum_planes::cullModelSpaceAABB(const bounding_box& aabb, const trs& transform) const
{
	return cullModelSpaceAABB(aabb, trsToMat4(transform));
}

bool camera_frustum_planes::cullModelSpaceAABB(const bounding_box& aabb, const mat4& transform) const
{
	// TODO: Transform planes instead of AABB?

	vec4 worldSpaceCorners[] =
	{
		transform * vec4(aabb.minCorner.x, aabb.minCorner.y, aabb.minCorner.z, 1.f),
		transform * vec4(aabb.maxCorner.x, aabb.minCorner.y, aabb.minCorner.z, 1.f),
		transform * vec4(aabb.minCorner.x, aabb.maxCorner.y, aabb.minCorner.z, 1.f),
		transform * vec4(aabb.maxCorner.x, aabb.maxCorner.y, aabb.minCorner.z, 1.f),
		transform * vec4(aabb.minCorner.x, aabb.minCorner.y, aabb.maxCorner.z, 1.f),
		transform * vec4(aabb.maxCorner.x, aabb.minCorner.y, aabb.maxCorner.z, 1.f),
		transform * vec4(aabb.minCorner.x, aabb.maxCorner.y, aabb.maxCorner.z, 1.f),
		transform * vec4(aabb.maxCorner.x, aabb.maxCorner.y, aabb.maxCorner.z, 1.f),
	};

	for (uint32 i = 0; i < 6; ++i)
	{
		vec4 plane = planes[i];

		bool inside = false;

		for (uint32 j = 0; j < 8; ++j)
		{
			if (dot(plane, worldSpaceCorners[j]) > 0.f)
			{
				inside = true;
				break;
			}
		}

		if (!inside)
		{
			return true;
		}
	}

	return false;
}

```

`src/core/camera.h`:

```h
#pragma once

#include "math.h"
#include "physics/bounding_volumes.h"
#include "reflect.h"

union camera_frustum_corners
{
	vec3 eye;

	struct
	{
		vec3 nearTopLeft;
		vec3 nearTopRight;
		vec3 nearBottomLeft;
		vec3 nearBottomRight;
		vec3 farTopLeft;
		vec3 farTopRight;
		vec3 farBottomLeft;
		vec3 farBottomRight;
	};
	struct
	{
		vec3 corners[8];
	};

	camera_frustum_corners() {}
};

union camera_frustum_planes
{
	struct
	{
		vec4 nearPlane;
		vec4 farPlane;
		vec4 leftPlane;
		vec4 rightPlane;
		vec4 topPlane;
		vec4 bottomPlane;
	};
	vec4 planes[6];

	camera_frustum_planes() {}

	// Returns true, if object should be culled.
	bool cullWorldSpaceAABB(const bounding_box& aabb) const;
	bool cullModelSpaceAABB(const bounding_box& aabb, const trs& transform) const;
	bool cullModelSpaceAABB(const bounding_box& aabb, const mat4& transform) const;
};

enum camera_type
{
	camera_type_ingame,
	camera_type_calibrated,
};

struct camera_projection_extents
{
	float left, right, top, bottom; // Extents of frustum at distance 1.
};

struct render_camera
{
	// Camera properties.
	quat rotation;
	vec3 position;

	float nearPlane;
	float farPlane = -1.f;

	uint32 width, height;

	camera_type type;

	float verticalFOV; // For ingame cameras.
	float fx, fy, cx, cy; // For calibrated cameras.


	// Derived values.
	mat4 view;
	mat4 invView;

	mat4 proj;
	mat4 invProj;

	mat4 viewProj;
	mat4 invViewProj;
	
	float aspect;




	void initializeIngame(vec3 position, quat rotation, float verticalFOV, float nearPlane, float farPlane = -1.f);
	void initializeCalibrated(vec3 position, quat rotation, uint32 width, uint32 height, float fx, float fy, float cx, float cy, float nearPlane, float farPlane = -1.f);

	void setViewport(uint32 width, uint32 height);

	void updateMatrices();





	ray generateWorldSpaceRay(float relX, float relY) const;
	ray generateViewSpaceRay(float relX, float relY) const;

	vec3 restoreViewSpacePosition(vec2 uv, float depthBufferDepth) const;
	vec3 restoreWorldSpacePosition(vec2 uv, float depthBufferDepth) const;
	float depthBufferDepthToEyeDepth(float depthBufferDepth) const;
	float eyeDepthToDepthBufferDepth(float eyeDepth) const;
	float linearizeDepthBuffer(float depthBufferDepth) const;

	camera_frustum_corners getWorldSpaceFrustumCorners(float alternativeFarPlane = 0.f) const;
	camera_frustum_planes getWorldSpaceFrustumPlanes() const;

	camera_frustum_corners getViewSpaceFrustumCorners(float alternativeFarPlane = 0.f) const;

	camera_projection_extents getProjectionExtents() const;
	float getMinProjectionExtent() const;



	render_camera getJitteredVersion(vec2 offset) const;
};
REFLECT_STRUCT(render_camera,
	(rotation, "Rotation"),
	(position, "Position"),
	(nearPlane, "Near plane"),
	(farPlane, "Far plane"),
	(type, "Type"),
	(verticalFOV, "Vertical FOV"),
	(fx, "Fx"),
	(fy, "Fy"),
	(cx, "Cx"),
	(cy, "Cy")
);


camera_frustum_planes getWorldSpaceFrustumPlanes(const mat4& viewProj);

```

`src/core/camera_controller.cpp`:

```cpp
#include "pch.h"
#include "camera_controller.h"


bool camera_controller::centerCameraOnObject(const bounding_box& aabb)
{
	vec3 center = aabb.getCenter();
	float radius = length(aabb.getRadius());

	vec3 offsetDirection = camera->rotation * vec3(0.f, 0.f, 1.f); // Camera backward axis.

	float minExtent = camera->getMinProjectionExtent();

	float scaling = radius / minExtent;

	centeringTime = 0.f;

	centeringPositionStart = camera->position;
	centeringPositionTarget = center + scaling * offsetDirection;

	orbitRadius = scaling;

	return true;
}

bool camera_controller::update(const user_input& input, uint32 viewportWidth, uint32 viewportHeight, float dt)
{
	const float CAMERA_MOVEMENT_SPEED = 8.f;
	const float CAMERA_SENSITIVITY = 4.f;
	const float CAMERA_CENTERING_TIME = 0.1f;

	camera->setViewport(viewportWidth, viewportHeight);

	bool result = false;

	if (centeringTime >= 0.f)
	{
		centeringTime += dt;

		float relativeTime = min(centeringTime / CAMERA_CENTERING_TIME, 1.f);
		camera->position = lerp(centeringPositionStart, centeringPositionTarget, relativeTime);

		if (relativeTime == 1.f)
		{
			centeringTime = -1.f;
		}
	}
	else if (input.mouse.right.down)
	{
		// Fly camera.

		vec3 cameraInputDir = vec3(
			(input.keyboard['D'].down ? 1.f : 0.f) + (input.keyboard['A'].down ? -1.f : 0.f),
			(input.keyboard['E'].down ? 1.f : 0.f) + (input.keyboard['Q'].down ? -1.f : 0.f),
			(input.keyboard['W'].down ? -1.f : 0.f) + (input.keyboard['S'].down ? 1.f : 0.f)
		) * (input.keyboard[key_shift].down ? 3.f : 1.f) * (input.keyboard[key_ctrl].down ? 0.1f : 1.f) * CAMERA_MOVEMENT_SPEED;

		vec2 turnAngle(0.f, 0.f);
		turnAngle = vec2(-input.mouse.reldx, -input.mouse.reldy) * CAMERA_SENSITIVITY;

		quat& cameraRotation = camera->rotation;
		cameraRotation = quat(vec3(0.f, 1.f, 0.f), turnAngle.x) * cameraRotation;
		cameraRotation = cameraRotation * quat(vec3(1.f, 0.f, 0.f), turnAngle.y);

		camera->position += cameraRotation * cameraInputDir * dt;

		result = true;
	}
	else if (input.keyboard[key_alt].down)
	{
		if (input.mouse.left.down)
		{
			// Orbit camera.

			vec2 turnAngle(0.f, 0.f);
			turnAngle = vec2(-input.mouse.reldx, -input.mouse.reldy) * CAMERA_SENSITIVITY;

			quat& cameraRotation = camera->rotation;

			vec3 center = camera->position + cameraRotation * vec3(0.f, 0.f, -orbitRadius);

			// https://gamedev.stackexchange.com/questions/136174/im-rotating-an-object-on-two-axes-so-why-does-it-keep-twisting-around-the-thir
			cameraRotation = quat(vec3(0.f, 1.f, 0.f), turnAngle.x) * cameraRotation;
			cameraRotation = cameraRotation * quat(vec3(1.f, 0.f, 0.f), turnAngle.y);

			camera->position = center - cameraRotation * vec3(0.f, 0.f, -orbitRadius);
		}
		else if (input.mouse.middle.down)
		{
			// Pan camera.

			vec3 cameraInputDir = vec3(
				-input.mouse.reldx * camera->aspect,
				input.mouse.reldy,
				0.f
			) * (input.keyboard[key_shift].down ? 3.f : 1.f) * (input.keyboard[key_ctrl].down ? 0.1f : 1.f) * 1000.f * CAMERA_MOVEMENT_SPEED;

			camera->position += camera->rotation * cameraInputDir * dt;
		}

		result = true;
	}

	camera->updateMatrices();

	return result;
}

```

`src/core/camera_controller.h`:

```h
#pragma once

#include "camera.h"
#include "input.h"


struct camera_controller
{
	void initialize(render_camera* camera) { this->camera = camera; }

	// Returns true, if camera is moved, and therefore input is captured.
	bool centerCameraOnObject(const bounding_box& aabb);
	bool update(const user_input& input, uint32 viewportWidth, uint32 viewportHeight, float dt);

	render_camera* camera;

private:
	float orbitRadius = 10.f;


	float centeringTime = -1.f;

	vec3 centeringPositionStart;
	vec3 centeringPositionTarget;
};


```

`src/core/color.h`:

```h
#pragma once

#include "math.h"
#include "random.h"

#include "material.hlsli"

// RGB is in [0,1]^3.
// HSV is in [0,2pi]x[0,1]x[0,1]

static vec3 rgb2hsv(vec3 rgb)
{
	float cmax = max(max(rgb.x, rgb.y), rgb.z);
	float cmin = min(min(rgb.x, rgb.y), rgb.z);
	float delta = cmax - cmin;
	float degrees =
		(delta == 0.f) ? 0.f :
		(cmax == rgb.x) ? (60.f * fmod((rgb.y - rgb.z) / delta, 6.f)) :
		(cmax == rgb.y) ? (60.f * ((rgb.z - rgb.x) / delta + 2.f)) :
		(60.f * ((rgb.x - rgb.y) / delta + 4.f));
	float h = angleToZeroToTwoPi(deg2rad(degrees));
	float s = (cmax == 0) ? 0.f : (delta / cmax);
	float v = cmax;

	return vec3(h, s, v);
}

static vec3 hsv2rgb(vec3 hsv)
{
	float h = rad2deg(hsv.x);
	float s = hsv.y;
	float v = hsv.z;

	float c = v * s;
	float x = c * (1.f - abs(fmod(h / 60.f, 2.f) - 1.f));
	float m = v - c;

	vec3 rgb =
		(h < 60.f) ? vec3(c, x, 0.f) :
		(h < 120.f) ? vec3(x, c, 0.f) :
		(h < 180.f) ? vec3(0.f, c, x) :
		(h < 240.f) ? vec3(0.f, x, c) :
		(h < 300.f) ? vec3(x, 0.f, c) :
		vec3(c, 0.f, x);

	rgb += vec3(m, m, m);
	return rgb;
}

static vec3 randomRGB(random_number_generator& rng)
{
	vec3 hsv =
	{
		rng.randomFloatBetween(0.f, 2.f * M_PI),
		1.f,
		1.f,
	};
	return hsv2rgb(hsv);
}

static vec3 linearToSRGB(vec3 color)
{
	// Approximately pow(color, 1.0 / 2.2).
	float r = color.r < 0.0031308f ? 12.92f * color.r : 1.055f * pow(abs(color.r), 1.f / 2.4f) - 0.055f;
	float g = color.g < 0.0031308f ? 12.92f * color.g : 1.055f * pow(abs(color.g), 1.f / 2.4f) - 0.055f;
	float b = color.b < 0.0031308f ? 12.92f * color.b : 1.055f * pow(abs(color.b), 1.f / 2.4f) - 0.055f;
	return vec3(r, g, b);
}

static vec3 sRGBToLinear(vec3 color)
{
	// Approximately pow(color, 2.2).
	float r = color.r < 0.04045f ? color.r / 12.92f : pow(abs(color.r + 0.055f) / 1.055f, 2.4f);
	float g = color.g < 0.04045f ? color.g / 12.92f : pow(abs(color.g + 0.055f) / 1.055f, 2.4f);
	float b = color.b < 0.04045f ? color.b / 12.92f : pow(abs(color.b + 0.055f) / 1.055f, 2.4f);
	return vec3(r, g, b);
}

static vec3 rec709ToRec2020(vec3 color)
{
	static const mat3 conversion =
	{
		0.627402f, 0.329292f, 0.043306f,
		0.069095f, 0.919544f, 0.011360f,
		0.016394f, 0.088028f, 0.895578f
	};
	return conversion * color;
}

static vec3 rec2020ToRec709(vec3 color)
{
	static const mat3 conversion =
	{
		1.660496f, -0.587656f, -0.072840f,
		-0.124547f, 1.132895f, -0.008348f,
		-0.018154f, -0.100597f, 1.118751f
	};
	return conversion * color;
}

static vec3 linearToST2084(vec3 color)
{
	float m1 = 2610.f / 4096.f / 4.f;
	float m2 = 2523.f / 4096.f * 128.f;
	float c1 = 3424.f / 4096.f;
	float c2 = 2413.f / 4096.f * 32.f;
	float c3 = 2392.f / 4096.f * 32.f;
	vec3 cp = pow(abs(color), m1);
	return pow((c1 + c2 * cp) / (1.f + c3 * cp), m2);
}

static vec3 YxyToXYZ(vec3 Yxy)
{
	float Y = Yxy.r;
	float x = Yxy.g;
	float y = Yxy.b;

	float X = x * (Y / y);
	float Z = (1.f - x - y) * (Y / y);

	return vec3(X, Y, Z);
}

static vec3 XYZToRGB(vec3 XYZ)
{
	// CIE/E.
	static const mat3 M =
	{
		2.3706743f, -0.9000405f, -0.4706338f,
		-0.5138850f, 1.4253036f, 0.0885814f,
		0.0052982f, -0.0146949f, 1.0093968f
	};

	return M * XYZ;
}

static vec3 YxyToRGB(vec3 Yxy)
{
	vec3 XYZ = YxyToXYZ(Yxy);
	vec3 RGB = XYZToRGB(XYZ);
	return RGB;
}


```

`src/core/coroutine.h`:

```h
#pragma once


#if _MSVC_LANG >= 202002L

#include <coroutine>

template <typename param_t>
struct coroutine_return
{
	struct promise_type
	{
		param_t value;

		coroutine_return get_return_object()
		{
			return { .handle = std::coroutine_handle<promise_type>::from_promise(*this) };
		}
		std::suspend_never initial_suspend() { return {}; }
		std::suspend_always final_suspend() noexcept { return {}; } // Don't destroy after co_return. This means the caller must destroy, but he can check for .done().
		void return_void() {}
		void unhandled_exception() {}

		std::suspend_always yield_value(const param_t& value)
		{
			this->value = value;
			return {};
		}
	};

	std::coroutine_handle<promise_type> handle;
};

template <typename value_t>
struct coroutine
{
	std::coroutine_handle<typename coroutine_return<value_t>::promise_type> h;
	coroutine_return<value_t>::promise_type& promise;

	coroutine(coroutine_return<value_t> ret)
		: h(ret.handle), promise(h.promise()) {}

	const auto& value() const { return promise.value; }
	void operator()() { h(); }
	void destroy() { h.destroy(); }

	operator bool() const { return !h.done(); }
};


#if 0

	//Example:



	coroutine_return<uint32> counter()
	{
		for (uint32 i = 0; i < 3; ++i)
		{
			co_yield i;
		}
	}

	void call()
	{
		coroutine<uint32> h = counter();

		for (int i = 0; h; ++i)
		{
			std::cout << "counter3: " << h.value() << std::endl;
			h();
		}
		h.destroy();
	}

#endif



#endif

```

`src/core/cpu_profiling.cpp`:

```cpp
#include "pch.h"
#define PROFILING_INTERNAL
#include "cpu_profiling.h"
#include "dx/dx_context.h"
#include "core/imgui.h"


bool cpuProfilerWindowOpen = false;

#if ENABLE_CPU_PROFILING

std::atomic<uint32> cpuProfileIndex;
std::atomic<uint32> cpuProfileCompletelyWritten[2];
profile_event cpuProfileEvents[2][MAX_NUM_CPU_PROFILE_EVENTS];
profile_stat cpuProfileStats[2][MAX_NUM_CPU_PROFILE_STATS];


#define MAX_NUM_CPU_PROFILE_THREADS 128
#define MAX_NUM_CPU_PROFILE_FRAMES 1024


struct cpu_profile_frame : profile_frame
{
	uint16 firstTopLevelBlockPerThread[MAX_NUM_CPU_PROFILE_THREADS];

	profile_block profileBlockPool[MAX_NUM_CPU_PROFILE_BLOCKS];
	uint32 totalNumProfileBlocks;

	profile_stat stats[MAX_NUM_CPU_PROFILE_STATS];
	uint32 numStats;
};

static uint32 profileThreads[MAX_NUM_CPU_PROFILE_THREADS];
static char profileThreadNames[MAX_NUM_CPU_PROFILE_THREADS][64];
static uint32 numThreads;

static cpu_profile_frame profileFrames[MAX_NUM_CPU_PROFILE_FRAMES];
static uint32 profileFrameWriteIndex;

static cpu_profile_frame dummyFrames[2];
static uint32 dummyFrameWriteIndex;


static bool pauseRecording;


static uint16 stack[MAX_NUM_CPU_PROFILE_THREADS][1024];
static uint32 depth[MAX_NUM_CPU_PROFILE_THREADS];

static uint32 mapThreadIDToIndex(uint32 threadID)
{
	for (uint32 i = 0; i < numThreads; ++i)
	{
		if (profileThreads[i] == threadID)
		{
			return i;
		}
	}

	HANDLE handle = OpenThread(THREAD_ALL_ACCESS, false, threadID);
	ASSERT(handle);
	WCHAR* description = nullptr;
	checkResult(GetThreadDescription(handle, &description));
	CloseHandle(handle);

	if (!description || !description[0])
	{
		description = (WCHAR*)L"Main thread";
	}

	ASSERT(numThreads < MAX_NUM_CPU_PROFILE_THREADS);
	uint32 index = numThreads++;
	profileThreads[index] = threadID;
	snprintf(profileThreadNames[index], sizeof(profileThreadNames[index]), "Thread %u (%ws)", threadID, description);
	return index;
}

static void initializeNewFrame(cpu_profile_frame& oldFrame, cpu_profile_frame& newFrame)
{
	for (uint32 thread = 0; thread < MAX_NUM_CPU_PROFILE_THREADS; ++thread)
	{
		if (depth[thread] > 0)
		{
			// Some blocks are still running on this thread.
			copyProfileBlocks(oldFrame.profileBlockPool, stack[thread], depth[thread], newFrame.profileBlockPool, newFrame.totalNumProfileBlocks);
			newFrame.firstTopLevelBlockPerThread[thread] = stack[thread][0];
		}
		else
		{
			newFrame.firstTopLevelBlockPerThread[thread] = INVALID_PROFILE_BLOCK;
			stack[thread][0] = INVALID_PROFILE_BLOCK;
		}
	}
}

void cpuProfilingResolveTimeStamps()
{
	uint32 currentFrame = profileFrameWriteIndex;

	uint32 arrayIndex = _CPU_PROFILE_GET_ARRAY_INDEX(cpuProfileIndex); // We are only interested in the most significant bit here, so don't worry about thread safety.
	uint32 currentIndex = cpuProfileIndex.exchange((1 - arrayIndex) << 31); // Swap array and get current event count.

	profile_event* events = cpuProfileEvents[arrayIndex];
	uint32 numEvents = _CPU_PROFILE_GET_EVENT_INDEX(currentIndex);
	auto stats = cpuProfileStats[arrayIndex];
	uint32 numStats = _CPU_PROFILE_GET_STAT_INDEX(currentIndex);
	uint32 numWrites = numEvents + numStats;

	while (numWrites > cpuProfileCompletelyWritten[arrayIndex]) {} // Wait until all events and stats have been written completely.
	cpuProfileCompletelyWritten[arrayIndex] = 0;


	static bool initializedStack = false;

	// Initialize on the very first frame.
	if (!initializedStack)
	{
		for (uint32 thread = 0; thread < MAX_NUM_CPU_PROFILE_THREADS; ++thread)
		{
			stack[thread][0] = INVALID_PROFILE_BLOCK;
			profileFrames[0].firstTopLevelBlockPerThread[thread] = INVALID_PROFILE_BLOCK;
			depth[thread] = 0;
		}

		initializedStack = true;
	}



	
	CPU_PROFILE_BLOCK("CPU Profiling"); // Important: Must be after array swap!

	{
		CPU_PROFILE_BLOCK("Collate profile events from last frame");

		std::stable_sort(events, events + numEvents, [](const profile_event& a, const profile_event& b)
		{
			return a.timestamp < b.timestamp;
		});


		cpu_profile_frame* frame = !pauseRecording ? (profileFrames + profileFrameWriteIndex) : (dummyFrames + dummyFrameWriteIndex);

		for (uint32 i = 0; i < numEvents; ++i)
		{
			profile_event* e = events + i;
			uint32 threadID = e->threadID;
			uint32 threadIndex = mapThreadIDToIndex(threadID);

			uint32 blocksBefore = frame->totalNumProfileBlocks;

			uint64 frameEndTimestamp;
			if (handleProfileEvent(events, i, numEvents, stack[threadIndex], depth[threadIndex], frame->profileBlockPool, frame->totalNumProfileBlocks, frameEndTimestamp, false))
			{
				static uint64 clockFrequency;
				static bool performanceFrequencyQueried = QueryPerformanceFrequency((LARGE_INTEGER*)&clockFrequency);

				cpu_profile_frame* previousFrame;
				if (!pauseRecording)
				{
					uint32 previousFrameIndex = (profileFrameWriteIndex == 0) ? (MAX_NUM_CPU_PROFILE_FRAMES - 1) : (profileFrameWriteIndex - 1);
					previousFrame = profileFrames + previousFrameIndex;
				}
				else
				{
					uint32 previousFrameIndex = 1 - dummyFrameWriteIndex;
					previousFrame = dummyFrames + previousFrameIndex;
				}


				frame->startClock = (previousFrame->endClock == 0) ? frameEndTimestamp : previousFrame->endClock;
				frame->endClock = frameEndTimestamp;
				frame->globalFrameID = dxContext.frameID;

				frame->duration = (float)(frame->endClock - frame->startClock) / clockFrequency * 1000.f;

				for (uint32 i = 0; i < frame->totalNumProfileBlocks; ++i)
				{
					profile_block* block = frame->profileBlockPool + i;

					uint64 endClock = (block->endClock == 0) ? frame->endClock : block->endClock;
					ASSERT(endClock <= frame->endClock);

					if (block->startClock >= frame->startClock)
					{
						block->relStart = (float)(block->startClock - frame->startClock) / clockFrequency * 1000.f;
					}
					else
					{
						// For blocks which started in a previous frame.
						block->relStart = -(float)(frame->startClock - block->startClock) / clockFrequency * 1000.f;
					}
					block->duration = (float)(endClock - block->startClock) / clockFrequency * 1000.f;
				}

				frame->numStats = numStats;
				memcpy(frame->stats, stats, numStats * sizeof(profile_stat));


				cpu_profile_frame* oldFrame = frame;

				if (!pauseRecording)
				{
					profileFrameWriteIndex = (profileFrameWriteIndex + 1) % MAX_NUM_CPU_PROFILE_FRAMES;
					frame = profileFrames + profileFrameWriteIndex;
				}
				else
				{
					dummyFrameWriteIndex = 1 - dummyFrameWriteIndex;
					frame = dummyFrames + dummyFrameWriteIndex;
				}

				frame->totalNumProfileBlocks = 0;

				initializeNewFrame(*oldFrame, *frame);
			}
			else
			{
				// Set first top-level block if another block was added and this thread has no first top-level block yet.
				uint32 blocksAfter = frame->totalNumProfileBlocks;

				if (blocksBefore != blocksAfter && frame->firstTopLevelBlockPerThread[threadIndex] == INVALID_PROFILE_BLOCK)
				{
					frame->firstTopLevelBlockPerThread[threadIndex] = frame->totalNumProfileBlocks - 1;
				}
			}

		}
	}


	if (cpuProfilerWindowOpen)
	{
		CPU_PROFILE_BLOCK("Display profiling");

		if (ImGui::Begin(ICON_FA_CHART_LINE "  CPU Profiling", &cpuProfilerWindowOpen))
		{
			static profiler_persistent persistent;
			profiler_timeline timeline(persistent, MAX_NUM_CPU_PROFILE_FRAMES);

			if (timeline.drawHeader(pauseRecording))
			{
				// Recording has been stopped/resumed. Swap array into which is recorded.
				if (pauseRecording)
				{
					cpu_profile_frame& oldFrame = profileFrames[profileFrameWriteIndex];
					cpu_profile_frame& newFrame = dummyFrames[dummyFrameWriteIndex];
					initializeNewFrame(oldFrame, newFrame);
				}
				else
				{
					cpu_profile_frame& oldFrame = dummyFrames[dummyFrameWriteIndex];
					cpu_profile_frame& newFrame = profileFrames[profileFrameWriteIndex];
					initializeNewFrame(oldFrame, newFrame);
				}
			}

			for (uint32 frameIndex = 0; frameIndex < MAX_NUM_CPU_PROFILE_FRAMES; ++frameIndex)
			{
				timeline.drawOverviewFrame(profileFrames[frameIndex], frameIndex, currentFrame);
			}
			timeline.endOverview();



			if (persistent.highlightFrameIndex != -1)
			{
				cpu_profile_frame& frame = profileFrames[persistent.highlightFrameIndex];
				profile_block* blocks = profileFrames[persistent.highlightFrameIndex].profileBlockPool;

				if (frame.totalNumProfileBlocks)
				{
					uint32 threadIndices[MAX_NUM_CPU_PROFILE_THREADS];
					const char* threadNames[MAX_NUM_CPU_PROFILE_THREADS];
					uint32 numActiveThreadsThisFrame = 0;

					for (uint32 i = 0; i < numThreads; ++i)
					{
						if (frame.firstTopLevelBlockPerThread[i] != INVALID_PROFILE_BLOCK)
						{
							threadIndices[numActiveThreadsThisFrame] = i;
							threadNames[numActiveThreadsThisFrame] = profileThreadNames[i];
							++numActiveThreadsThisFrame;
						}
					}


					timeline.drawHighlightFrameInfo(frame);

					static uint32 threadIndex = 0;
					ImGui::SameLine();
					ImGui::Dropdown("Thread", threadNames, numActiveThreadsThisFrame, threadIndex);

					if (persistent.highlightFrameIndex != profileFrameWriteIndex)
					{
						timeline.drawCallStack(blocks, frame.firstTopLevelBlockPerThread[threadIndices[threadIndex]]);
					}

					timeline.drawMillisecondSpacings(frame);
					timeline.handleUserInteractions();

					if (frame.numStats != 0)
					{
						ImGui::Dummy(ImVec2(0, 30.f));
						if (ImGui::BeginChild("Stats"))
						{
							ImGui::Text("Frame stats");
							ImGui::Separator();
							for (uint32 i = 0; i < frame.numStats; ++i)
							{
								const profile_stat& stat = frame.stats[i];
								switch (stat.type)
								{
									case profile_stat_type_bool: ImGui::Value(stat.label, stat.boolValue); break;
									case profile_stat_type_int32: ImGui::Value(stat.label, stat.int32Value); break;
									case profile_stat_type_uint32: ImGui::Value(stat.label, stat.uint32Value); break;
									case profile_stat_type_int64: ImGui::Value(stat.label, stat.int64Value); break;
									case profile_stat_type_uint64: ImGui::Value(stat.label, stat.uint64Value); break;
									case profile_stat_type_float: ImGui::Value(stat.label, stat.floatValue); break;
									case profile_stat_type_string: ImGui::Value(stat.label, stat.stringValue); break;
								}
							}
						}
						ImGui::EndChild();
					}
				}
			}
		}
		ImGui::End();
	}
}

#endif

```

`src/core/cpu_profiling.h`:

```h
#pragma once

#include "threading.h"
#include "profiling_internal.h"

extern bool cpuProfilerWindowOpen;


// Things the CPU profiler currently doesn't support (but probably should):
// - Filtering?


#if ENABLE_CPU_PROFILING

#define _CPU_PROFILE_BLOCK_(counter, name) cpu_profile_block_recorder COMPOSITE_VARNAME(__PROFILE_BLOCK, counter)(name)
#define CPU_PROFILE_BLOCK(name) _CPU_PROFILE_BLOCK_(__COUNTER__, name)


#define MAX_NUM_CPU_PROFILE_BLOCKS 16384
#define MAX_NUM_CPU_PROFILE_EVENTS (MAX_NUM_CPU_PROFILE_BLOCKS * 2) // One for start and end.
#define MAX_NUM_CPU_PROFILE_STATS 512


// 1 bit for array index, 1 free bit, 20 bits for events, 10 bits for stats.
#define _CPU_PROFILE_GET_ARRAY_INDEX(v) ((v) >> 31)
#define _CPU_PROFILE_GET_EVENT_INDEX(v) ((v) & 0xFFFFF)
#define _CPU_PROFILE_GET_STAT_INDEX(v)	(((v) >> 20) & 0x3FF)

#define recordProfileEvent(type_, name_) \
	extern profile_event cpuProfileEvents[2][MAX_NUM_CPU_PROFILE_EVENTS]; \
	extern std::atomic<uint32> cpuProfileIndex; \
	extern std::atomic<uint32> cpuProfileCompletelyWritten[2]; \
	uint32 arrayAndEventIndex = cpuProfileIndex++; \
	uint32 eventIndex = _CPU_PROFILE_GET_EVENT_INDEX(arrayAndEventIndex); \
	uint32 arrayIndex = _CPU_PROFILE_GET_ARRAY_INDEX(arrayAndEventIndex); \
	ASSERT(eventIndex < MAX_NUM_CPU_PROFILE_EVENTS); \
	profile_event* e = cpuProfileEvents[arrayIndex] + eventIndex; \
	e->threadID = getThreadIDFast(); \
	e->name = name_; \
	e->type = type_; \
	QueryPerformanceCounter((LARGE_INTEGER*)&e->timestamp); \
	cpuProfileCompletelyWritten[arrayIndex].fetch_add(1, std::memory_order_release); // Mark this event as written. Release means that the compiler may not reorder the previous writes after this.


struct cpu_profile_block_recorder
{
	const char* name;

	cpu_profile_block_recorder(const char* name)
		: name(name)
	{
		recordProfileEvent(profile_event_begin_block, name);
	}

	~cpu_profile_block_recorder()
	{
		recordProfileEvent(profile_event_end_block, name);
	}
};

inline void cpuProfilingFrameEndMarker()
{
	recordProfileEvent(profile_event_frame_marker, 0);
}

enum profile_stat_type
{
	profile_stat_type_bool,
	profile_stat_type_int32,
	profile_stat_type_uint32,
	profile_stat_type_int64,
	profile_stat_type_uint64,
	profile_stat_type_float,
	profile_stat_type_string,
};

struct profile_stat
{
	const char* label;
	union
	{
		bool boolValue;
		int32 int32Value;
		uint32 uint32Value;
		int64 int64Value;
		uint64 uint64Value;
		float floatValue;
		const char* stringValue;
	};
	profile_stat_type type;
};

#define _CPU_PROFILE_STAT(labelValue, value, member, valueType) \
	extern std::atomic<uint32> cpuProfileIndex; \
	extern std::atomic<uint32> cpuProfileCompletelyWritten[2]; \
	extern profile_stat cpuProfileStats[2][MAX_NUM_CPU_PROFILE_STATS]; \
	uint32 arrayAndStatIndex = cpuProfileIndex.fetch_add(1 << 20); \
	uint32 statIndex = _CPU_PROFILE_GET_STAT_INDEX(arrayAndStatIndex); \
	uint32 arrayIndex = _CPU_PROFILE_GET_ARRAY_INDEX(arrayAndStatIndex); \
	ASSERT(statIndex < MAX_NUM_CPU_PROFILE_STATS); \
	profile_stat* stat = cpuProfileStats[arrayIndex] + statIndex; \
	stat->label = labelValue; \
	stat->member = value; \
	stat->type = valueType; \
	cpuProfileCompletelyWritten[arrayIndex].fetch_add(1, std::memory_order_release); // Mark this stat as written. Release means that the compiler may not reorder the previous writes after this.

inline void CPU_PROFILE_STAT(const char* label, bool value) { _CPU_PROFILE_STAT(label, value, boolValue, profile_stat_type_bool); }
inline void CPU_PROFILE_STAT(const char* label, int32 value) { _CPU_PROFILE_STAT(label, value, int32Value, profile_stat_type_int32); }
inline void CPU_PROFILE_STAT(const char* label, uint32 value) { _CPU_PROFILE_STAT(label, value, uint32Value, profile_stat_type_uint32); }
inline void CPU_PROFILE_STAT(const char* label, int64 value) { _CPU_PROFILE_STAT(label, value, int64Value, profile_stat_type_int64); }
inline void CPU_PROFILE_STAT(const char* label, uint64 value) { _CPU_PROFILE_STAT(label, value, uint64Value, profile_stat_type_uint64); }
inline void CPU_PROFILE_STAT(const char* label, float value) { _CPU_PROFILE_STAT(label, value, floatValue, profile_stat_type_float); }
inline void CPU_PROFILE_STAT(const char* label, const char* value) { _CPU_PROFILE_STAT(label, value, stringValue, profile_stat_type_string); }

// Currently there must not be any profile events between calling cpuProfilingFrameEndMarker and cpuProfilingResolveTimeStamps.

void cpuProfilingResolveTimeStamps();

#undef recordProfileEvent







#define _CPU_PRINT_PROFILE_BLOCK_(counter, name) cpu_print_profile_block_recorder COMPOSITE_VARNAME(__PROFILE_BLOCK, counter)(name)
#define CPU_PRINT_PROFILE_BLOCK(name) _CPU_PRINT_PROFILE_BLOCK_(__COUNTER__, name)

struct cpu_print_profile_block_recorder
{
	const char* name;
	uint64 start;

	cpu_print_profile_block_recorder(const char* name)
		: name(name)
	{
		QueryPerformanceCounter((LARGE_INTEGER*)&start);
	}

	~cpu_print_profile_block_recorder()
	{
		uint64 end;
		QueryPerformanceCounter((LARGE_INTEGER*)&end);

		uint64 clockFrequency;
		QueryPerformanceFrequency((LARGE_INTEGER*)&clockFrequency);

		float duration = (float)(end - start) / clockFrequency * 1000.f;
		std::cout << "Profile block '" << name << "' took " << duration << "ms.\n";
	}
};




#else

#define CPU_PROFILE_BLOCK(...)
#define CPU_PROFILE_STAT(...)

#define cpuProfilingFrameEndMarker(...)
#define cpuProfilingResolveTimeStamps(...)

#define CPU_PRINT_PROFILE_BLOCK(...)

#endif



```

`src/core/file_system.cpp`:

```cpp
#include "pch.h"
#include "file_system.h"

struct observe_params
{
	fs::path directory;
	file_system_observer callback;
	bool watchSubDirectories;
};

static DWORD observeDirectoryThread(void* inParams)
{
	observe_params* params = (observe_params*)inParams;

	uint8 buffer[1024] = {};

	HANDLE directoryHandle = CreateFileW(
		params->directory.c_str(),
		GENERIC_READ | FILE_LIST_DIRECTORY,
		FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
		NULL,
		OPEN_EXISTING,
		FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OVERLAPPED,
		NULL);

	if (directoryHandle == INVALID_HANDLE_VALUE)
	{
		std::cerr << "Monitor directory failed.\n";
		return 1;
	}

	OVERLAPPED overlapped;
	overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
	ResetEvent(overlapped.hEvent);

	DWORD eventName = 
		FILE_NOTIFY_CHANGE_LAST_WRITE |
		FILE_NOTIFY_CHANGE_FILE_NAME | 
		FILE_NOTIFY_CHANGE_DIR_NAME | 
		FILE_NOTIFY_CHANGE_SIZE;

	DWORD bytesReturned;

	fs::path lastChangedPath = "";
	fs::file_time_type lastChangedPathTimeStamp;

	while (true)
	{
		DWORD result = ReadDirectoryChangesW(directoryHandle,
			buffer, sizeof(buffer), params->watchSubDirectories,
			eventName,
			&bytesReturned, &overlapped, NULL);

		if (!result)
		{
			std::cerr << "Read directory changes failed\n";
			break;
		}

		WaitForSingleObject(overlapped.hEvent, INFINITE);



		DWORD dw;
		if (!GetOverlappedResult(directoryHandle, &overlapped, &dw, FALSE) || dw == 0)
		{
			std::cerr << "Get overlapped result failed.\n";
			break;
		}

		FILE_NOTIFY_INFORMATION* filenotify;
		DWORD offset = 0;

		fs::path oldPath;

		do
		{
			filenotify = (FILE_NOTIFY_INFORMATION*)(&buffer[offset]);

			file_system_change change = file_system_change_none;

			switch (filenotify->Action)
			{
				case FILE_ACTION_ADDED: { change = file_system_change_add; } break;
				case FILE_ACTION_REMOVED: { change = file_system_change_delete; } break;
				case FILE_ACTION_MODIFIED: { change = file_system_change_modify; } break;
				case FILE_ACTION_RENAMED_OLD_NAME: 
				{
					uint32 filenameLength = filenotify->FileNameLength / sizeof(WCHAR);
					oldPath = (params->directory / std::wstring(filenotify->FileName, filenameLength)).lexically_normal();
				} break;
				case FILE_ACTION_RENAMED_NEW_NAME: { change = file_system_change_rename; } break;
			}

			if (change != file_system_change_none)
			{
				uint32 filenameLength = filenotify->FileNameLength / sizeof(WCHAR);
				fs::path path = (params->directory / std::wstring(filenotify->FileName, filenameLength)).lexically_normal();

				if (change == file_system_change_modify)
				{
					auto writeTime = fs::last_write_time(path);

					// The filesystem usually sends multiple notifications for changed files, since the file is first written, then metadata is changed etc.
					// This check prevents these notifications if they are too close together in time.
					// This is a pretty crude fix. In this setup files should not change at the same time, since we only ever track one file.
					if (path == lastChangedPath
						&& std::chrono::duration_cast<std::chrono::milliseconds>(writeTime - lastChangedPathTimeStamp).count() < 200)
					{
						lastChangedPath = path;
						lastChangedPathTimeStamp = writeTime;
						break;
					}

					lastChangedPath = path;
					lastChangedPathTimeStamp = writeTime;
				}

				file_system_event e;
				e.change = change;
				e.path = std::move(path);
				if (change == file_system_change_rename)
				{
					e.oldPath = std::move(oldPath);
				}

				params->callback(e);
			}

			offset += filenotify->NextEntryOffset;

		} while (filenotify->NextEntryOffset != 0);


		if (!ResetEvent(overlapped.hEvent))
		{
			std::cerr << "Reset event failed.\n";
		}
	}

	CloseHandle(directoryHandle);

	delete params;

	return 0;
}

bool observeDirectory(const fs::path& directory, const file_system_observer& callback, bool watchSubDirectories)
{
	observe_params* params = new observe_params;
	params->directory = directory;
	params->callback = callback;
	params->watchSubDirectories = watchSubDirectories;

	HANDLE handle = CreateThread(0, 0, observeDirectoryThread, params, 0, 0);
	bool result = handle != INVALID_HANDLE_VALUE;
	CloseHandle(handle);

	return result;
}

```

`src/core/file_system.h`:

```h
#pragma once

#include <functional>

enum file_system_change
{
	file_system_change_none,
	file_system_change_add,
	file_system_change_delete,
	file_system_change_modify,
	file_system_change_rename,
};

struct file_system_event
{
	file_system_change change;
	fs::path path;
	fs::path oldPath; // Only set in case of a rename event.
};

typedef std::function<void(const file_system_event&)> file_system_observer;

bool observeDirectory(const fs::path& directory, const file_system_observer& callback, bool watchSubDirectories = true);

```

`src/core/hash.h`:

```h
#pragma once

#include "math.h"

#include <functional>

// Source: https://stackoverflow.com/questions/2590677/how-do-i-combine-hash-values-in-c0x
template <typename T>
inline void hash_combine(size_t& seed, const T& v)
{
	seed ^= std::hash<T>()(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
}

namespace std
{
	template<>
	struct hash<vec2>
	{
		size_t operator()(const vec2& x) const
		{
			size_t seed = 0;

			hash_combine(seed, x.x);
			hash_combine(seed, x.y);

			return seed;
		}
	};

	template<>
	struct hash<vec3>
	{
		size_t operator()(const vec3& x) const
		{
			size_t seed = 0;

			hash_combine(seed, x.x);
			hash_combine(seed, x.y);
			hash_combine(seed, x.z);

			return seed;
		}
	};

	template<>
	struct hash<vec4>
	{
		size_t operator()(const vec4& x) const
		{
			size_t seed = 0;

			hash_combine(seed, x.x);
			hash_combine(seed, x.y);
			hash_combine(seed, x.z);
			hash_combine(seed, x.w);

			return seed;
		}
	};

	template<>
	struct hash<quat>
	{
		size_t operator()(const quat& x) const
		{
			size_t seed = 0;

			hash_combine(seed, x.x);
			hash_combine(seed, x.y);
			hash_combine(seed, x.z);
			hash_combine(seed, x.w);

			return seed;
		}
	};

	template<>
	struct hash<mat4>
	{
		size_t operator()(const mat4& x) const
		{
			size_t seed = 0;

			for (uint32 i = 0; i < 16; ++i)
			{
				hash_combine(seed, x.m[i]);
			}

			return seed;
		}
	};

#if _MSC_VER < 1930
	template <>
	struct hash<fs::path>
	{
		size_t operator()(const fs::path& p) const
		{
			return std::hash<fs::path::string_type>{}(p.native());
		}
	};
#endif
}


```

`src/core/imgui.cpp`:

```cpp
#include "pch.h"
#include "imgui.h"

#define IMGUI_DEFINE_MATH_OPERATORS
#include <imgui/imgui_draw.cpp>
#include <imgui/imgui.cpp>
#include <imgui/imgui_widgets.cpp>
#include <imgui/imgui_demo.cpp>
#include <imgui/imgui_tables.cpp>
#include <imgui/imgui_internal.h>

#include <imgui/backends/imgui_impl_win32.cpp>
#include <imgui/backends/imgui_impl_dx12.cpp>

#include "input.h"
#include "dx/dx_context.h"
#include "dx/dx_command_list.h"
#include "dx/dx_profiling.h"
#include "window/dx_window.h"
#include "asset/asset.h"
#include "asset/file_registry.h"


#define MAX_NUM_IMGUI_IMAGES_PER_FRAME 128

static com<ID3D12DescriptorHeap> imguiDescriptorHeap;
static CD3DX12_CPU_DESCRIPTOR_HANDLE startCPUDescriptor;
static CD3DX12_GPU_DESCRIPTOR_HANDLE startGPUDescriptor;
static uint32 descriptorHandleIncrementSize;
static uint32 numImagesThisFrame;

static ref<dx_texture> iconsTexture;
static ImTextureID iconsTextureID;


static void setStyle()
{
	auto& colors = ImGui::GetStyle().Colors;
	colors[ImGuiCol_WindowBg] = ImVec4{ 0.1f, 0.105f, 0.11f, 1.0f };

	// Headers
	colors[ImGuiCol_Header] = ImVec4{ 0.2f, 0.205f, 0.21f, 1.0f };
	colors[ImGuiCol_HeaderHovered] = ImVec4{ 0.3f, 0.305f, 0.31f, 1.0f };
	colors[ImGuiCol_HeaderActive] = ImVec4{ 0.15f, 0.1505f, 0.151f, 1.0f };

	// Buttons
	colors[ImGuiCol_Button] = ImVec4{ 0.2f, 0.205f, 0.21f, 1.0f };
	colors[ImGuiCol_ButtonHovered] = ImVec4{ 0.3f, 0.305f, 0.31f, 1.0f };
	colors[ImGuiCol_ButtonActive] = ImVec4{ 0.15f, 0.1505f, 0.151f, 1.0f };

	// Frame BG
	colors[ImGuiCol_FrameBg] = ImVec4{ 0.2f, 0.205f, 0.21f, 1.0f };
	colors[ImGuiCol_FrameBgHovered] = ImVec4{ 0.3f, 0.305f, 0.31f, 1.0f };
	colors[ImGuiCol_FrameBgActive] = ImVec4{ 0.15f, 0.1505f, 0.151f, 1.0f };

	// Tabs
	colors[ImGuiCol_Tab] = ImVec4{ 0.15f, 0.1505f, 0.151f, 1.0f };
	colors[ImGuiCol_TabHovered] = ImVec4{ 0.38f, 0.3805f, 0.381f, 1.0f };
	colors[ImGuiCol_TabActive] = ImVec4{ 0.28f, 0.2805f, 0.281f, 1.0f };
	colors[ImGuiCol_TabUnfocused] = ImVec4{ 0.15f, 0.1505f, 0.151f, 1.0f };
	colors[ImGuiCol_TabUnfocusedActive] = ImVec4{ 0.2f, 0.205f, 0.21f, 1.0f };

	// Title
	colors[ImGuiCol_TitleBg] = ImVec4{ 0.15f, 0.1505f, 0.151f, 1.0f };
	colors[ImGuiCol_TitleBgActive] = ImVec4{ 0.15f, 0.1505f, 0.151f, 1.0f };
	colors[ImGuiCol_TitleBgCollapsed] = ImVec4{ 0.15f, 0.1505f, 0.151f, 1.0f };


	ImGuiStyle& style = ImGui::GetStyle();
	style.FrameBorderSize = 1.f;
	style.FramePadding = ImVec2(5.f, 2.f);
}


ImGuiContext* initializeImGui(struct dx_window& window)
{
	IMGUI_CHECKVERSION();
	auto imguiContext = ImGui::CreateContext();
	ImGuiIO& io = ImGui::GetIO(); (void)io;
	io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;       // Enable Keyboard Controls
	//io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;      // Enable Gamepad Controls
	io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;           // Enable Docking
	io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable;         // Enable Multi-Viewport / Platform Windows
	//io.ConfigViewportsNoAutoMerge = true;
	//io.ConfigViewportsNoTaskBarIcon = true;

	ImGui::StyleColorsDark();

	// When viewports are enabled we tweak WindowRounding/WindowBg so platform windows can look identical to regular ones.
	ImGuiStyle& style = ImGui::GetStyle();
	if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
	{
		style.WindowRounding = 0.f;
		style.Colors[ImGuiCol_WindowBg].w = 1.f;
	}

	setStyle();

	io.FontDefault = io.Fonts->AddFontFromFileTTF("resources/fonts/opensans/OpenSans-Regular.ttf", 18.f);

	// Merge in icons.
	static const ImWchar iconsRanges[] = { ICON_MIN_FA, ICON_MAX_FA, 0 };
	ImFontConfig iconsConfig;
	iconsConfig.MergeMode = true; 
	iconsConfig.PixelSnapH = true;
	io.FontDefault = io.Fonts->AddFontFromFileTTF("resources/fonts/icons/" FONT_ICON_FILE_NAME_FAS, 16.f, &iconsConfig, iconsRanges);


	D3D12_DESCRIPTOR_HEAP_DESC desc = {};
	desc.NumDescriptors = NUM_BUFFERED_FRAMES * MAX_NUM_IMGUI_IMAGES_PER_FRAME + 2;
	desc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
	desc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;

	checkResult(dxContext.device->CreateDescriptorHeap(&desc, IID_PPV_ARGS(&imguiDescriptorHeap)));

	startCPUDescriptor = imguiDescriptorHeap->GetCPUDescriptorHandleForHeapStart();
	startGPUDescriptor = imguiDescriptorHeap->GetGPUDescriptorHandleForHeapStart();
	descriptorHandleIncrementSize = dxContext.device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);

	DXGI_FORMAT screenFormat = (window.colorDepth == color_depth_8) ? DXGI_FORMAT_R8G8B8A8_UNORM : DXGI_FORMAT_R10G10B10A2_UNORM;

	ImGui_ImplWin32_Init(window.windowHandle);
	ImGui_ImplDX12_Init(dxContext.device.Get(), NUM_BUFFERED_FRAMES,
		screenFormat, imguiDescriptorHeap.Get(),
		startCPUDescriptor,
		startGPUDescriptor);

	{
		iconsTexture = loadTextureFromFile("resources/icons/icons_ui.svg", image_load_flags_gen_mips_on_cpu | image_load_flags_cache_to_dds);

		CD3DX12_CPU_DESCRIPTOR_HANDLE cpuHandle(startCPUDescriptor, 1, descriptorHandleIncrementSize);
		CD3DX12_GPU_DESCRIPTOR_HANDLE gpuHandle(startGPUDescriptor, 1, descriptorHandleIncrementSize);
		dxContext.device->CopyDescriptorsSimple(1, cpuHandle, iconsTexture->defaultSRV.cpuHandle, D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);

		iconsTextureID = (ImTextureID)gpuHandle.ptr;
	}

	return imguiContext;
}

void newImGuiFrame(float dt)
{
	ImGui_ImplDX12_NewFrame();
	ImGui_ImplWin32_NewFrame();
	ImGui::NewFrame();
}

void renderImGui(dx_command_list* cl)
{
	DX_PROFILE_BLOCK(cl, "ImGui");

	ImGui::Render();
	if (cl)
	{
		cl->setDescriptorHeap(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV, imguiDescriptorHeap);
		ImGui_ImplDX12_RenderDrawData(ImGui::GetDrawData(), cl->commandList.Get());
	}

	auto& io = ImGui::GetIO();
	if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
	{
		ImGui::UpdatePlatformWindows();
		if (cl)
		{
			ImGui::RenderPlatformWindowsDefault(0, cl->commandList.Get());
		}
	}

	numImagesThisFrame = 0;
}

LRESULT handleImGuiInput(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	return ImGui_ImplWin32_WndProcHandler(hwnd, msg, wParam, lParam);
}

static ImTextureID pushTexture(dx_cpu_descriptor_handle handle)
{
	CD3DX12_CPU_DESCRIPTOR_HANDLE cpuHandle(startCPUDescriptor, 2 + dxContext.bufferedFrameID * MAX_NUM_IMGUI_IMAGES_PER_FRAME + numImagesThisFrame, descriptorHandleIncrementSize);
	CD3DX12_GPU_DESCRIPTOR_HANDLE gpuHandle(startGPUDescriptor, 2 + dxContext.bufferedFrameID * MAX_NUM_IMGUI_IMAGES_PER_FRAME + numImagesThisFrame, descriptorHandleIncrementSize);

	dxContext.device->CopyDescriptorsSimple(1, cpuHandle, handle.cpuHandle, D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);

	++numImagesThisFrame;

	return (ImTextureID)gpuHandle.ptr;
}

namespace ImGui
{
	bool AnyModifiersDown()
	{
		return ImGui::IsKeyDown(key_ctrl) || ImGui::IsKeyDown(key_shift) || ImGui::IsKeyDown(key_alt);
	}

	bool IsItemActiveLastFrame()
	{
		ImGuiContext& g = *GImGui;
		if (g.ActiveIdPreviousFrame)
		{
			return g.ActiveIdPreviousFrame == g.LastItemData.ID;
		}
		return false;
	}

	bool BeginWindowHiddenTabBar(const char* name, bool* open, ImGuiWindowFlags flags)
	{
		ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0, 0));
		ImGuiWindowClass windowClass;
		windowClass.DockNodeFlagsOverrideSet = ImGuiDockNodeFlags_AutoHideTabBar;
		ImGui::SetNextWindowClass(&windowClass);
		bool result = ImGui::Begin(name, open, flags);
		ImGui::PopStyleVar();
		return result;
	}

	bool BeginControlsWindow(const char* name, ImVec2 parentRelativeOffset, ImVec2 parentAbsoluteOffset)
	{
		if (ImGui::GetCurrentWindow())
		{
			// Only do this if there is a parent window.

			ImVec2 parentPos = ImGui::GetWindowPos();
			ImVec2 parentSize = ImGui::GetWindowSize();

			ImGui::SetNextWindowPos(parentPos + parentSize * parentRelativeOffset + parentAbsoluteOffset);
		}

		ImGui::PushStyleVar(ImGuiStyleVar_WindowRounding, 10.f);
		ImGui::SetNextWindowSize(ImVec2(0.f, 0.f)); // Auto-resize to content.
		bool result = ImGui::Begin(name, 0, ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse | ImGuiWindowFlags_NoMove
		 | ImGuiWindowFlags_NoBringToFrontOnFocus | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoSavedSettings);
		ImGui::PopStyleVar();

		return result;
	}

	static void Image(::dx_cpu_descriptor_handle& handle, ImVec2 size, ImVec2 uv0, ImVec2 uv1)
	{
		if (numImagesThisFrame < MAX_NUM_IMGUI_IMAGES_PER_FRAME)
		{
			ImGui::Image(pushTexture(handle), size, uv0, uv1);
		}
	}

	static void Image(::dx_cpu_descriptor_handle& handle, uint32 width, uint32 height, ImVec2 uv0, ImVec2 uv1)
	{
		ImGui::Image(handle, ImVec2((float)width, (float)height), uv0, uv1);
	}

	static void Image(const ref<dx_texture>& texture, ImVec2 size, ImVec2 uv0, ImVec2 uv1)
	{
		if (texture)
		{
			if (size.x == 0)
			{
				size.x = min(ImGui::GetContentRegionAvail().x, (float)texture->width);
			}

			if (size.y == 0)
			{
				size.y = texture->height * size.x / (float)texture->width;
			}

			ImGui::Image(texture->defaultSRV, size, uv0, uv1);
		}
	}

	void Image(const ref<dx_texture>& texture, uint32 width, uint32 height, ImVec2 uv0, ImVec2 uv1)
	{
		ImGui::Image(texture, ImVec2((float)width, (float)height), uv0, uv1);
	}

	static bool ImageButton(::dx_cpu_descriptor_handle& handle, ImVec2 size, ImVec2 uvTopLeft, ImVec2 uvBottomRight)
	{
		if (numImagesThisFrame < MAX_NUM_IMGUI_IMAGES_PER_FRAME)
		{
			return ImGui::ImageButton(pushTexture(handle), size, uvTopLeft, uvBottomRight);
		}
		return false;
	}

	static bool ImageButton(::dx_cpu_descriptor_handle& handle, uint32 width, uint32 height, ImVec2 uvTopLeft, ImVec2 uvBottomRight)
	{
		return ImGui::ImageButton(handle, ImVec2((float)width, (float)height), uvTopLeft, uvBottomRight);
	}

	static bool ImageButton(const ref<dx_texture>& texture, ImVec2 size, ImVec2 uvTopLeft, ImVec2 uvBottomRight)
	{
		return ImGui::ImageButton(texture->defaultSRV, size, uvTopLeft, uvBottomRight);
	}

	bool ImageButton(const ref<dx_texture>& texture, uint32 width, uint32 height, ImVec2 uvTopLeft, ImVec2 uvBottomRight)
	{
		return ImGui::ImageButton(texture->defaultSRV, ImVec2((float)width, (float)height), uvTopLeft, uvBottomRight);
	}

	void Icon(imgui_icon icon, uint32 size)
	{
		float row = (float)(icon / IMGUI_ICON_COLS);
		float col = (float)(icon % IMGUI_ICON_COLS);

		float left = col / IMGUI_ICON_COLS;
		float right = (col + 1) / IMGUI_ICON_COLS;
		float top = row / IMGUI_ICON_ROWS;
		float bottom = (row + 1) / IMGUI_ICON_ROWS;

		ImGui::Image(iconsTextureID, ImVec2((float)size, (float)size), ImVec2(left, top), ImVec2(right, bottom));
		if (ImGui::IsItemHovered())
		{
			ImGui::SetTooltip(imguiIconNames[icon]);
		}
	}

	bool IconButton(uint32 id, imgui_icon icon, uint32 size, bool enabled)
	{
		float row = (float)(icon / IMGUI_ICON_COLS);
		float col = (float)(icon % IMGUI_ICON_COLS);

		float left = col / IMGUI_ICON_COLS;
		float right = (col + 1) / IMGUI_ICON_COLS;
		float top = row / IMGUI_ICON_ROWS;
		float bottom = (row + 1) / IMGUI_ICON_ROWS;

		ImGui::PushID(id);
		if (!enabled)
		{
			ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
			ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.2f);
		}
		bool result = ImGui::ImageButton(iconsTextureID, ImVec2((float)size, (float)size), ImVec2(left, top), ImVec2(right, bottom), 0);
		if (ImGui::IsItemHovered())
		{
			ImGui::SetTooltip(imguiIconNames[icon]);
		}
		if (!enabled)
		{
			ImGui::PopItemFlag();
			ImGui::PopStyleVar();
		}
		ImGui::PopID();
		return result;
	}

	bool IconRadioButton(imgui_icon icon, int* current, int value, uint32 size, bool enabled)
	{
		float row = (float)(icon / IMGUI_ICON_COLS);
		float col = (float)(icon % IMGUI_ICON_COLS);

		float left = col / IMGUI_ICON_COLS;
		float right = (col + 1) / IMGUI_ICON_COLS;
		float top = row / IMGUI_ICON_ROWS;
		float bottom = (row + 1) / IMGUI_ICON_ROWS;

		bool active = value == *current;

		ImGui::PushID(value);
		if (!enabled)
		{
			ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
			ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.2f);
		}
		bool clicked = ImGui::ImageButton(iconsTextureID, ImVec2((float)size, (float)size), ImVec2(left, top), ImVec2(right, bottom),
			0, active ? ImVec4(1, 1, 1, 0.4f) : ImVec4(0, 0, 0, 0));
		if (ImGui::IsItemHovered())
		{
			ImGui::SetTooltip(imguiIconNames[icon]);
		}
		if (!enabled)
		{
			ImGui::PopItemFlag();
			ImGui::PopStyleVar();
		}
		ImGui::PopID();

		int old = *current;
		if (clicked)
		{
			*current = value;
		}

		return old != *current;
	}

	bool Dropdown(const char* label, const char** names, uint32 count, uint32& current)
	{
		bool changed = false;
		if (ImGui::BeginCombo(label, names[current]))
		{
			for (uint32 i = 0; i < count; ++i)
			{
				bool selected = i == current;
				ImGui::PushID(i);
				if (ImGui::Selectable(names[i], selected))
				{
					current = i;
					changed = true;
				}
				ImGui::PopID();
			}
			ImGui::EndCombo();
		}
		return changed;
	}

	bool Dropdown(const char* label, const char* (*name_func)(uint32, void*), uint32& current, void* data)
	{
		bool changed = false;
		if (ImGui::BeginCombo(label, name_func(current, data)))
		{
			for (uint32 i = 0; ; ++i)
			{
				bool selected = i == current;
				const char* name = name_func(i, data);
				if (!name)
				{
					break;
				}
				ImGui::PushID(i);
				if (ImGui::Selectable(name, selected))
				{
					current = i;
					changed = true;
				}
				ImGui::PopID();
			}
			ImGui::EndCombo();
		}
		return changed;
	}

	bool DisableableButton(const char* label, bool enabled)
	{
		if (!enabled)
		{
			ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
			ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.2f);
		}
		bool result = ImGui::Button(label);
		if (!enabled)
		{
			ImGui::PopItemFlag();
			ImGui::PopStyleVar();
		}
		return result;
	}

	bool DisableableCheckbox(const char* label, bool& v, bool enabled)
	{
		if (!enabled)
		{
			ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
			ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.2f);
		}
		bool result = ImGui::Checkbox(label, &v);
		if (!enabled)
		{
			ImGui::PopItemFlag();
			ImGui::PopStyleVar();
		}
		return result;
	}

	bool SelectableWrapped(const char* label, int width, bool selected, ImGuiSelectableFlags flags)
	{
		ImVec2 padding = ImGui::GetStyle().FramePadding;
		float textWidth = width - padding.x * 2;

		ImVec2 textSize = ImGui::CalcTextSize(label, 0, false, textWidth);
		bool result = ImGui::Selectable("##label", selected, flags, textSize + padding * 2);
		ImGui::RenderTextWrapped(ImGui::GetItemRectMin() + padding, label, 0, textWidth);
		return result;
	}

	bool BeginTree(const char* label, bool defaultOpen)
	{
		return ImGui::TreeNodeEx(label, ImGuiTreeNodeFlags_Framed | ImGuiTreeNodeFlags_SpanAvailWidth | ImGuiTreeNodeFlags_FramePadding | (defaultOpen ? ImGuiTreeNodeFlags_DefaultOpen : ImGuiTreeNodeFlags_None));
	}

	bool BeginTreeColoredText(const char* label, vec3 color, bool defaultOpen)
	{
		ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(color.x, color.y, color.z, 1.f));
		bool result = ImGui::BeginTree(label, defaultOpen);
		ImGui::PopStyleColor();
		return result;
	}

	void EndTree()
	{
		ImGui::TreePop();
	}

	void CenteredText(const char* text)
	{
		float w = ImGui::CalcTextSize(text).x;
		ImGui::SetCursorPosX((ImGui::GetContentRegionAvail().x - w) * 0.5f);
		ImGui::Text(text);
	}

	void PopupOkButton(uint32 width)
	{
		float w = (float)width;
		ImGui::SetCursorPosX((ImGui::GetWindowSize().x - w) * 0.5f);
		if (ImGui::Button("OK", ImVec2(w, 0))) { ImGui::CloseCurrentPopup(); }
		ImGui::SetItemDefaultFocus();
	}

	template <typename tooptip_func>
	static bool AssetHandleInternal(const char* label, const char* type, asset_handle& asset, const char* clearText, tooptip_func tooltipFunc)
	{
		char buffer[512] = "";
		if (asset)
		{
			fs::path path = getPathFromAssetHandle(asset);
			snprintf(buffer, sizeof(buffer), "%s  %s", type, path.string().c_str());
		}
		else
		{
			snprintf(buffer, sizeof(buffer), "%s", type);
		}

		if (clearText)
		{
			float resetWidth = ImGui::CalcButtonWidth(clearText) + ImGui::GetStyle().ItemSpacing.x;
			ImGui::PushItemWidth(ImGui::GetContentRegionAvailWidth() - resetWidth);
		}

		ImGui::InputText("", buffer, sizeof(buffer), ImGuiInputTextFlags_ReadOnly);

		bool result = false;
		if (ImGui::BeginDragDropTarget())
		{
			if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload(type))
			{
				asset = getAssetHandleFromPath((const char*)payload->Data);
				result = true;
			}
			ImGui::EndDragDropTarget();
		}
		if (ImGui::IsItemHovered() && asset)
		{
			fs::path path = getPathFromAssetHandle(asset);
			if (!path.empty())
			{
				ImGui::BeginTooltip();
				ImGui::Text(path.string().c_str());
				ImGui::Text("Asset handle: % llu", asset.value);
				tooltipFunc();
				ImGui::EndTooltip();
			}
		}

		if (clearText)
		{
			ImGui::SameLine();
			if (ImGui::DisableableButton(clearText, asset))
			{
				asset = {};
				result = true;
			}
		}

		return result;
	}

	bool AssetHandle(const char* label, const char* type, asset_handle& asset, const char* clearText)
	{
		return AssetHandleInternal(label, type, asset, clearText, []() {});
	}

	bool TextureAssetHandle(const char* label, const char* type, asset_handle& asset, const ref<dx_texture>& texture, uint32 width, uint32 height, ImVec2 uv0, ImVec2 uv1, const char* clearText)
	{
		return AssetHandleInternal(label, type, asset, clearText, [=]() { ImGui::Image(texture, width, height, uv0, uv1); });
	}

	bool Drag(const char* label, float& f, float speed, float min, float max, const char* format)
	{
		return ImGui::DragScalar(label, ImGuiDataType_Float, &f, speed, &min, &max, format);
	}

	bool Drag(const char* label, vec2& f, float speed, float min, float max, const char* format)
	{
		return DragScalarN(label, ImGuiDataType_Float, f.data, 2, speed, &min, &max, format);
	}

	bool Drag(const char* label, vec3& f, float speed, float min, float max, const char* format)
	{
		return DragScalarN(label, ImGuiDataType_Float, f.data, 3, speed, &min, &max, format);
	}

	bool Drag(const char* label, vec4& f, float speed, float min, float max, const char* format)
	{
		return DragScalarN(label, ImGuiDataType_Float, f.data, 4, speed, &min, &max, format);
	}

	bool Drag(const char* label, int32& f, float speed, int32 min, int32 max, const char* format)
	{
		return DragScalarN(label, ImGuiDataType_S32, &f, 2, speed, &min, &max, format);
	}

	bool Drag(const char* label, uint32& f, float speed, uint32 min, uint32 max, const char* format)
	{
		return ImGui::DragScalar(label, ImGuiDataType_U32, &f, speed, &min, &max, format);
	}

	bool DragRange(const char* label, float& lo, float& hi, float speed, float min, float max, const char* format)
	{
		return ImGui::DragFloatRange2(label, &lo, &hi, speed, min, max, format, 0, ImGuiSliderFlags_AlwaysClamp);
	}

	bool DragRange(const char* label, int32& lo, int32& hi, float speed, int32 min, int32 max, const char* format)
	{
		return ImGui::DragIntRange2(label, &lo, &hi, speed, min, max, format, 0, ImGuiSliderFlags_AlwaysClamp);
	}







	static void pre(const char* label)
	{
		ImGui::TableNextColumn();
		ImGui::Text(label);
		ImGui::TableNextColumn();
		ImGui::PushItemWidth(-1);
		ImGui::PushID(label);
	}

	static void post()
	{
		ImGui::PopID();
		ImGui::PopItemWidth();
	}

	bool BeginProperties()
	{
		return ImGui::BeginTable("", 2, ImGuiTableFlags_Resizable);
	}

	void EndProperties()
	{
		ImGui::EndTable();
	}

	static void paddedTextV(const char* format, va_list args)
	{
		ImVec2 padding = ImGui::GetStyle().FramePadding;
		ImGui::SetCursorPos(ImGui::GetCursorPos() + padding);
		ImGui::TextV(format, args);
	}

	void PropertyValue(const char* label, const char* format, ...)
	{
		pre(label);
		va_list args;
		va_start(args, format);
		paddedTextV(format, args);
		va_end(args);
		post();
	}

	bool PropertyCheckbox(const char* label, bool& v)
	{
		pre(label);
		bool result = ImGui::Checkbox("", &v);
		post();
		return result;
	}

	static bool PropertySliderInternal(ImGuiDataType_ type, int32 count, const char* label, void* f, void* minValue, void* maxValue, const char* format, ImGuiSliderFlags flags = ImGuiSliderFlags_None)
	{
		pre(label);
		bool result;
		if (count == 1)
		{
			result = ImGui::SliderScalar("", type, f, minValue, maxValue, format, flags);
		}
		else
		{
			result = ImGui::SliderScalarN("", type, f, count, minValue, maxValue, format, flags);
		}
		post();
		return result;
	}

	bool PropertySlider(const char* label, float& f, float minValue, float maxValue, const char* format, ImGuiSliderFlags flags)
	{
		return ImGui::PropertySliderInternal(ImGuiDataType_Float, 1, label, &f, &minValue, &maxValue, format, flags);
	}

	bool PropertySlider(const char* label, vec2& f, float minValue, float maxValue, const char* format, ImGuiSliderFlags flags)
	{
		return ImGui::PropertySliderInternal(ImGuiDataType_Float, 2, label, f.data, &minValue, &maxValue, format, flags);
	}

	bool PropertySlider(const char* label, vec3& f, float minValue, float maxValue, const char* format, ImGuiSliderFlags flags)
	{
		return ImGui::PropertySliderInternal(ImGuiDataType_Float, 3, label, f.data, &minValue, &maxValue, format, flags);
	}

	bool PropertySlider(const char* label, vec4& f, float minValue, float maxValue, const char* format, ImGuiSliderFlags flags)
	{
		return ImGui::PropertySliderInternal(ImGuiDataType_Float, 4, label, f.data, &minValue, &maxValue, format, flags);
	}

	bool PropertySliderAngle(const char* label, float& fRad, float minValueDeg, float maxValueDeg, const char* format)
	{
		pre(label);
		bool result = ImGui::SliderAngle("", &fRad, minValueDeg, maxValueDeg, format);
		post();
		return result;
	}

	bool PropertySlider(const char* label, int32& v, int minValue, int maxValue, const char* format)
	{
		return ImGui::PropertySliderInternal(ImGuiDataType_S32, 1, label, &v, &minValue, &maxValue, format);
	}

	bool PropertySlider(const char* label, uint32& v, uint32 minValue, uint32 maxValue, const char* format)
	{
		return ImGui::PropertySliderInternal(ImGuiDataType_U32, 1, label, &v, &minValue, &maxValue, format);
	}

	static bool PropertyInputInternal(ImGuiDataType_ type, int32 count, const char* label, void* f, const char* format)
	{
		pre(label);
		bool result;
		if (count == 1)
		{
			result = ImGui::InputScalar("", type, f, 0, 0, format);
		}
		else
		{
			result = ImGui::InputScalarN("", type, f, count, 0, 0, format);
		}
		post();
		return result;
	}

	bool PropertyInput(const char* label, float& f, const char* format)
	{
		return ImGui::PropertyInputInternal(ImGuiDataType_Float, 1, label, &f, format);
	}

	bool PropertyInput(const char* label, vec2& f, const char* format)
	{
		return ImGui::PropertyInputInternal(ImGuiDataType_Float, 2, label, f.data, format);
	}

	bool PropertyInput(const char* label, vec3& f, const char* format)
	{
		return ImGui::PropertyInputInternal(ImGuiDataType_Float, 3, label, f.data, format);
	}

	bool PropertyInput(const char* label, vec4& f, const char* format)
	{
		return ImGui::PropertyInputInternal(ImGuiDataType_Float, 4, label, f.data, format);
	}
	
	bool PropertyInput(const char* label, int32& f, const char* format)
	{
		return ImGui::PropertyInputInternal(ImGuiDataType_S32, 1, label, &f, format);
	}

	bool PropertyInput(const char* label, uint32& f, const char* format)
	{
		return ImGui::PropertyInputInternal(ImGuiDataType_U32, 1, label, &f, format);
	}

	static bool PropertyDragInternal(ImGuiDataType_ type, int32 count, const char* label, void* f, float speed, void* min, void* max, const char* format)
	{
		pre(label);
		bool result;
		if (count == 1)
		{
			result = ImGui::DragScalar("", type, f, speed, min, max, format);
		}
		else
		{
			result = ImGui::DragScalarN("", type, f, count, speed, min, max, format);
		}
		post();
		return result;
	}

	bool PropertyDrag(const char* label, float& f, float speed, float min, float max, const char* format)
	{
		return ImGui::PropertyDragInternal(ImGuiDataType_Float, 1, label, &f, speed, &min, &max, format);
	}

	bool PropertyDrag(const char* label, vec2& f, float speed, float min, float max, const char* format)
	{
		return ImGui::PropertyDragInternal(ImGuiDataType_Float, 2, label, f.data, speed, &min, &max, format);
	}

	bool PropertyDrag(const char* label, vec3& f, float speed, float min, float max, const char* format)
	{
		return ImGui::PropertyDragInternal(ImGuiDataType_Float, 3, label, f.data, speed, &min, &max, format);
	}

	bool PropertyDrag(const char* label, vec4& f, float speed, float min, float max, const char* format)
	{
		return ImGui::PropertyDragInternal(ImGuiDataType_Float, 4, label, f.data, speed, &min, &max, format);
	}

	bool PropertyDrag(const char* label, int32& f, float speed, int32 min, int32 max, const char* format)
	{
		return ImGui::PropertyDragInternal(ImGuiDataType_S32, 1, label, &f, speed, &min, &max, format);
	}

	bool PropertyDrag(const char* label, uint32& f, float speed, uint32 min, uint32 max, const char* format)
	{
		return ImGui::PropertyDragInternal(ImGuiDataType_U32, 1, label, &f, speed, &min, &max, format);
	}

	bool PropertyDragRange(const char* label, float& lo, float& hi, float speed, float min, float max, const char* format)
	{
		pre(label);
		bool result = ImGui::DragRange("", lo, hi, speed, min, max, format);
		post();
		return result;
	}

	bool PropertyDragRange(const char* label, int32& lo, int32& hi, float speed, int32 min, int32 max, const char* format)
	{
		pre(label);
		bool result = ImGui::DragRange("", lo, hi, speed, min, max, format);
		post();
		return result;
	}


	bool PropertyDropdown(const char* label, const char** names, uint32 count, uint32& current)
	{
		pre(label);
		bool result = ImGui::Dropdown("", names, count, current);
		post();
		return result;
	}

	bool PropertyDropdown(const char* label, const char* (*name_func)(uint32, void*), uint32& current, void* data)
	{
		pre(label);
		bool result = ImGui::Dropdown("", name_func, current, data);
		post();
		return result;
	}

	bool PropertyDropdownPowerOfTwo(const char* label, uint32 from, uint32 to, uint32& current)
	{
		ASSERT(isPowerOfTwo(current));
		ASSERT(isPowerOfTwo(from));
		ASSERT(isPowerOfTwo(to));
		uint32 logCurrent = log2(current);
		uint32 logFrom = log2(from);
		uint32 logTo = log2(to);
		uint32 count = logTo - logFrom + 1;

		logCurrent -= logFrom;

		static const char* names[] =
		{
			"1", "2", "4", "8", "16", "32", "64", "128", "256", "512", "1,024", "2,048", "4,096", "8,192", "16,384", "32,768", "65,536",
			"131,072", "262,144", "524,288", "1,048,576", "2,097,152", "4,194,304", "8,388,608", "16,777,216", "33,554,432", 
			"67,108,864", "134,217,728", "268,435,456", "536,870,912", "1,073,741,824", "2,147,483,648"
		};

		pre(label);
		bool result = ImGui::Dropdown("", names + logFrom, count, logCurrent);
		logCurrent += logFrom;
		current = 1 << logCurrent;
		post();
		return result;
	}

	static constexpr int32 colorEditFlags = ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoLabel |
		ImGuiColorEditFlags_NoSidePreview | ImGuiColorEditFlags_NoDragDrop | ImGuiColorEditFlags_PickerHueWheel | ImGuiColorEditFlags_Float;
	
	bool PropertyColor(const char* label, vec3& f)
	{
		pre(label);
		bool result = ImGui::ColorEdit3("", f.data, colorEditFlags);
		post();
		return result;
	}

	bool PropertyColor(const char* label, vec4& f)
	{
		pre(label);
		bool result = ImGui::ColorEdit4("", f.data, colorEditFlags);
		post();
		return result;
	}

	bool PropertyColorWheel(const char* label, vec3& f)
	{
		pre(label);
		bool result = ImGui::ColorPicker3("", f.data, colorEditFlags);
		post();
		return result;
	}

	bool PropertyColorWheel(const char* label, vec4& f)
	{
		pre(label);
		bool result = ImGui::ColorPicker4("", f.data, colorEditFlags);
		post();
		return result;
	}

	bool PropertyButton(const char* label, const char* buttonText, const char* hoverText, ImVec2 size)
	{
		pre(label);
		bool result = ImGui::Button(buttonText, size);
		if (hoverText && ImGui::IsItemHovered())
		{
			ImGui::SetTooltip(hoverText);
		}
		post();
		return result;
	}

	bool PropertyInputText(const char* label, char* buffer, uint32 bufferSize, bool disableInput)
	{
		pre(label);

		if (disableInput)
		{
			ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.6f);
		}

		bool result = ImGui::InputText("", buffer, bufferSize, disableInput ? ImGuiInputTextFlags_ReadOnly : 0);

		if (disableInput)
		{
			ImGui::PopStyleVar();
		}

		post();
		return result;
	}

	bool PropertyAssetHandle(const char* label, const char* type, asset_handle& asset, const char* clearText)
	{
		pre(label);
		bool result = AssetHandle("", type, asset, clearText);
		post();
		return result;
	}

	bool PropertyTextureAssetHandle(const char* label, const char* type, asset_handle& asset, const ref<dx_texture>& texture, uint32 width, uint32 height, ImVec2 uv0, ImVec2 uv1, const char* clearText)
	{
		pre(label);
		bool result = TextureAssetHandle("", type, asset, texture, width, height, uv0, uv1, clearText);
		post();
		return result;
	}

	bool PropertyDragDropStringTarget(const char* label, const char* dragDropID, std::string& value, const char* clearLabel)
	{
		pre(label);

		bool result = false;

		ImGui::InputText("", value.data(), value.length(), ImGuiInputTextFlags_ReadOnly);
		if (ImGui::BeginDragDropTarget())
		{
			if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload(dragDropID)) 
			{ 
				value = (const char*)payload->Data; 
				result = true; 
			}

			ImGui::EndDragDropTarget();
		}

		if (clearLabel)
		{
			if (ImGui::Button(clearLabel))
			{
				value.clear();
				result = true;
			}
		}

		post();
		return result;
	}

	void PropertySeparator()
	{
		ImGui::TableNextColumn();
		ImGui::Separator();
		ImGui::TableNextColumn();
		ImGui::Separator();
	}
}



// Curve editing from https://gist.githubusercontent.com/r-lyeh-archived/40d4fd0ea157ab3a58a4/raw/b80af5cc39438aa40c0170eb2b0111faf4971fc6/curve.hpp.

namespace tween 
{
	enum TYPE
	{
		LINEAR,

		QUADIN,
		QUADOUT,
		QUADINOUT,
		CUBICIN,
		CUBICOUT,
		CUBICINOUT,
		QUARTIN,
		QUARTOUT,
		QUARTINOUT,
		QUINTIN,
		QUINTOUT,
		QUINTINOUT,
		SINEIN,
		SINEOUT,
		SINEINOUT,
		EXPOIN,
		EXPOOUT,
		EXPOINOUT,
		CIRCIN,
		CIRCOUT,
		CIRCINOUT,
		ELASTICIN,
		ELASTICOUT,
		ELASTICINOUT,
		BACKIN,
		BACKOUT,
		BACKINOUT,
		BOUNCEIN,
		BOUNCEOUT,
		BOUNCEINOUT,
	};

	static float ease(int easetype, float t)
	{
		switch (easetype)
		{
			default:
			case LINEAR: return t;
			case QUADIN: return easeInQuadratic(t);
			case QUADOUT: return easeOutQuadratic(t);
			case QUADINOUT: return easeInOutQuadratic(t);
			case CUBICIN: return easeInCubic(t);
			case CUBICOUT: return easeOutCubic(t);
			case CUBICINOUT: return easeInOutCubic(t);
			case QUARTIN: return easeInQuartic(t);
			case QUARTOUT: return easeOutQuartic(t);
			case QUARTINOUT: return easeInOutQuartic(t);
			case QUINTIN: return easeInQuintic(t);
			case QUINTOUT: return easeOutQuintic(t);
			case QUINTINOUT: return easeInOutQuintic(t);
			case SINEIN: return easeInSine(t);
			case SINEOUT: return easeOutSine(t);
			case SINEINOUT: return easeInOutSine(t);
			case CIRCIN: return easeInCircular(t);
			case CIRCOUT: return easeOutCircular(t);
			case CIRCINOUT: return easeInOutCircular(t);
			case EXPOIN: return easeInExponential(t);
			case EXPOOUT: return easeOutExponential(t);
			case EXPOINOUT: return easeInOutExponential(t);
			case ELASTICIN: return inElastic(t);
			case ELASTICOUT: return outElastic(t);
			case ELASTICINOUT: return inOutElastic(t);
			case BACKIN: return inBack(t);
			case BACKOUT: return outBack(t);
			case BACKINOUT: return inOutBack(t);
			case BOUNCEIN: return inBounce(t);
			case BOUNCEOUT: return outBounce(t);
			case BOUNCEINOUT: return inOutBounce(t);
		}
	}
}

namespace ImGui
{
	static float SplineValue(float p, const float* x, const float* y, uint32 numPoints)
	{
		if (numPoints < 2 || !x || !y)
		{
			return 0;
		}

		if (p < 0.f)
		{
			return y[0];
		}

		float output = evaluateSpline(x, y, numPoints, p);

		return output;
	}

	bool Spline(const char* label, ImVec2 size, uint32 maxpoints, float* x, float* y, uint32 drawResolution)
	{
		if (size.x == 0)
		{
			size.x = ImGui::GetContentRegionAvail().x;
		}

		if (size.y == 0)
		{
			size.y = size.x;
		}

		bool modified = false;
		if (maxpoints < 2 || !x || !y)
		{
			return false;
		}

		if (x[0] < 0)
		{
			x[0] = 0;
			y[0] = 0;
			x[1] = 1;
			y[1] = 1;
			x[2] = -1;
		}

		ImGuiWindow* window = GetCurrentWindow();
		const ImGuiStyle& style = GetStyle();
		const ImGuiID id = window->GetID(label);
		if (window->SkipItems)
		{
			return false;
		}

		ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
		ItemSize(bb);
		if (!ItemAdd(bb, NULL))
		{
			return false;
		}

		PushID(label);

		const bool hovered = IsItemHovered();

		int max = 0;
		while (max < (int)maxpoints && x[max] >= 0)
		{
			++max;
		}

		RenderFrame(bb.Min, bb.Max, GetColorU32(ImGuiCol_FrameBg, 1), true, style.FrameRounding);

		float ht = bb.Max.y - bb.Min.y;
		float wd = bb.Max.x - bb.Min.x;

		auto& io = GetIO();

		int kill = 0;

		if (hovered)
		{
			if (io.MouseDown[0])
			{
				modified = true;
				ImVec2 pos = (io.MousePos - bb.Min) / (bb.Max - bb.Min);
				pos.y = 1 - pos.y;

				int left = 0;
				while (left < max && x[left] < pos.x)
				{
					++left;
				}
				if (left)
				{
					--left;
				}

				ImVec2 p = ImVec2(x[left], y[left]) - pos;
				float p1d = sqrt(p.x * p.x + p.y * p.y);
				p = ImVec2(x[left + 1], y[left + 1]) - pos;
				float p2d = sqrt(p.x * p.x + p.y * p.y);
				int sel = -1;
				if (p1d < (1 / 10.f)) { sel = left; }
				if (p2d < (1 / 10.f)) { sel = left + 1; }

				if (sel != -1)
				{
					if (io.MouseClicked[0] && io.KeyCtrl)
					{
						kill = sel;
					}
					else
					{
						x[sel] = pos.x;
						y[sel] = pos.y;
					}
				}
				else if (io.MouseClicked[0] && !io.KeyCtrl)
				{
					if (max < (int)maxpoints)
					{
						++max;
						for (int i = max - 1; i > left; i--)
						{
							x[i] = x[i - 1];
							y[i] = y[i - 1];
						}
						x[left + 1] = pos.x;
						y[left + 1] = pos.y;
					}
					if (max < (int)maxpoints)
					{
						x[max] = -1;
					}
				}

				// Snap first/last to min/max.
				if (x[0] < x[max - 1]) 
				{
					x[0] = 0;
					x[max - 1] = 1;
				}
				else 
				{
					x[0] = 1;
					x[max - 1] = 0;
				}
			}
		}

		do
		{
			if (kill)
			{
				modified = true;
				for (int i = kill + 1; i < max; ++i)
				{
					x[i - 1] = x[i];
					y[i - 1] = y[i];
				}
				--max;
				x[max] = -1;
				kill = 0;
			}

			for (int i = 1; i < max - 1; ++i)
			{
				if (x[i] < x[i - 1])
				{
					kill = i;
				}
			}
		} while (kill);


		// Draw background grid.
		window->DrawList->AddLine(
			ImVec2(bb.Min.x, bb.Min.y + ht / 2),
			ImVec2(bb.Max.x, bb.Min.y + ht / 2),
			GetColorU32(ImGuiCol_TextDisabled), 3);

		window->DrawList->AddLine(
			ImVec2(bb.Min.x, bb.Min.y + ht / 4),
			ImVec2(bb.Max.x, bb.Min.y + ht / 4),
			GetColorU32(ImGuiCol_TextDisabled));

		window->DrawList->AddLine(
			ImVec2(bb.Min.x, bb.Min.y + ht / 4 * 3),
			ImVec2(bb.Max.x, bb.Min.y + ht / 4 * 3),
			GetColorU32(ImGuiCol_TextDisabled));

		for (int i = 0; i < 9; ++i)
		{
			window->DrawList->AddLine(
				ImVec2(bb.Min.x + (wd / 10) * (i + 1), bb.Min.y),
				ImVec2(bb.Min.x + (wd / 10) * (i + 1), bb.Max.y),
				GetColorU32(ImGuiCol_TextDisabled));
		}

		// Draw smooth curve.
		drawResolution = min(drawResolution, (uint32)size.x);
		for (uint32 i = 0; i < drawResolution; ++i)
		{
			float px = (i + 0) / float(drawResolution);
			float qx = (i + 1) / float(drawResolution);
			float py = 1 - SplineValue(px, x, y, max);
			float qy = 1 - SplineValue(qx, x, y, max);
			ImVec2 p(px * (bb.Max.x - bb.Min.x) + bb.Min.x, py * (bb.Max.y - bb.Min.y) + bb.Min.y);
			ImVec2 q(qx * (bb.Max.x - bb.Min.x) + bb.Min.x, qy * (bb.Max.y - bb.Min.y) + bb.Min.y);
			window->DrawList->AddLine(p, q, GetColorU32(ImGuiCol_PlotLines));
		}

		// Draw lines.
#if 0
		for (int i = 1; i < max; i++)
		{
			ImVec2 a = points[i - 1];
			ImVec2 b = points[i];
			a.y = 1 - a.y;
			b.y = 1 - b.y;
			a = a * (bb.Max - bb.Min) + bb.Min;
			b = b * (bb.Max - bb.Min) + bb.Min;
			window->DrawList->AddLine(a, b, GetColorU32(ImGuiCol_PlotLinesHovered));
		}
#endif

		if (hovered)
		{
			// Draw control points.
			for (int i = 0; i < max; i++)
			{
				ImVec2 p(x[i], y[i]);
				p.y = 1 - p.y;
				p = p * (bb.Max - bb.Min) + bb.Min;
				ImVec2 a = p - ImVec2(2, 2);
				ImVec2 b = p + ImVec2(2, 2);
				window->DrawList->AddRect(a, b, GetColorU32(ImGuiCol_PlotLinesHovered));
			}
		}

		if (ImGui::Button("Flip")) 
		{
			for (int i = 0; i < max; ++i)
			{
				y[i] = 1 - y[i];
			}
			modified = true;
		}
		ImGui::SameLine();

		if (ImGui::Button("Mirror"))
		{
			for (int i = 0; i < max / 2; ++i)
			{
				int j = max - 1 - i;
				x[i] = 1 - x[i];
				x[j] = 1 - x[j];
				std::swap(x[i], x[j]);
				std::swap(y[i], y[j]);
			}
			if (max % 2 == 1)
			{
				x[max / 2] = 1 - x[max / 2];
			}
			modified = true;
		}
		ImGui::SameLine();

		// Preset selector.
		const char* items[] = 
		{
			"Choose preset",

			"Linear",
			"Quadratic in",
			"Quadratic out",
			"Quadratic in out",
			"Cubic in",
			"Cubic out",
			"Cubic in out",
			"Quartic in",
			"Quartic out",
			"Quartic in out",
			"Quintic in",
			"Quintic out",
			"Quintic in out",
			"Sine in",
			"Sine out",
			"Sine in out",
			"Exponetial in",
			"Exponetial out",
			"Exponetial in out",
			"Circular in",
			"Circular out",
			"Circular in out",
			"Elastic in",
			"Elastic out",
			"Elastic in out",
			"Back in",
			"Back out",
			"Back in out",
			"Bounce in",
			"Bounce out",
			"Bounce in out",
		};
		int item = 0;
		if (ImGui::Combo("##preset", &item, items, arraysize(items))) 
		{
			max = maxpoints;
			if (item > 0) 
			{
				for (int i = 0; i < max; ++i)
				{
					x[i] = i / float(max - 1);
					y[i] = float(tween::ease(item - 1, x[i]));
				}
			}
			modified = true;
		}

		char buf[128];
		const char* str = label;

		if (hovered) 
		{
			ImVec2 pos = (io.MousePos - bb.Min) / (bb.Max - bb.Min);
			pos.y = 1 - pos.y;

			sprintf(buf, "%s (%f,%f)", label, pos.x, pos.y);
			str = buf;
		}

		RenderTextClipped(ImVec2(bb.Min.x, bb.Min.y + style.FramePadding.y), bb.Max, str, 0, 0);

		PopID();

		return modified;
	}

	bool PropertySpline(const char* label, uint32 maxNumPoints, float* x, float* y, uint32 drawResolution)
	{
		pre(label);
		float size = ImGui::GetContentRegionAvail().x;
		bool result = ImGui::Spline("", ImVec2(size, size), maxNumPoints, x, y, drawResolution);
		post();
		return result;
	}

}



```

`src/core/imgui.h`:

```h
#pragma once

#define IM_ASSERT(condition) ASSERT(condition)
#include <imgui/imgui.h>
#include <fontawesome/IconsFontAwesome5.h>

#include "dx/dx.h"
#include "math.h"

ImGuiContext* initializeImGui(struct dx_window& window);
void newImGuiFrame(float dt);
void renderImGui(struct dx_command_list* cl);

LRESULT handleImGuiInput(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

struct dx_texture;
struct asset_handle;

enum imgui_icon
{
	imgui_icon_global,
	imgui_icon_local,
	imgui_icon_translate,
	imgui_icon_rotate,
	imgui_icon_scale,
	imgui_icon_cross,
	imgui_icon_play,
	imgui_icon_stop,
	imgui_icon_pause,
};

static const char* imguiIconNames[] =
{
	"Transform in global coordinate system (G)",
	"Transform in local coordinate system (G)",
	"Translate (W)",
	"Rotate (E)",
	"Scale (R)",
	"No gizmo (Q)",
	"Play",
	"Stop",
	"Pause",
};

#define IMGUI_ICON_COLS 4
#define IMGUI_ICON_ROWS 4

#define IMGUI_ICON_DEFAULT_SIZE 35
#define IMGUI_ICON_DEFAULT_SPACING 3.f

namespace ImGui
{
	bool AnyModifiersDown();

	bool IsItemActiveLastFrame();

	bool BeginWindowHiddenTabBar(const char* name, bool* open = 0, ImGuiWindowFlags flags = 0);
	bool BeginControlsWindow(const char* name, ImVec2 parentRelativeOffset, ImVec2 parentAbsoluteOffset);

	void Image(const ref<dx_texture>& texture, uint32 width = 0, uint32 height = 0, ImVec2 uv0 = ImVec2(0.f, 0.f), ImVec2 uv1 = ImVec2(1.f, 1.f));

	inline float CalcButtonWidth(const char* text) { return CalcTextSize(text).x + (GetStyle().FramePadding.x + GetStyle().FrameBorderSize) * 2.f; }

	bool ImageButton(const ref<dx_texture>& texture, uint32 width, uint32 height, ImVec2 uvTopLeft = ImVec2(0, 0), ImVec2 uvBottomRight = ImVec2(1, 1));

	void Icon(imgui_icon icon, uint32 size);
	bool IconButton(uint32 id, imgui_icon icon, uint32 size, bool enabled = true);
	bool IconRadioButton(imgui_icon icon, int* current, int value, uint32 size, bool enabled = true);

	bool Dropdown(const char* label, const char** names, uint32 count, uint32& current);
	bool Dropdown(const char* label, const char* (*name_func)(uint32, void*), uint32& current, void* data = 0);

	bool DisableableButton(const char* label, bool enabled);
	bool DisableableCheckbox(const char* label, bool& v, bool enabled);

	bool SelectableWrapped(const char* label, int width, bool selected = false, ImGuiSelectableFlags flags = 0);

	bool BeginTree(const char* label, bool defaultOpen = false);
	bool BeginTreeColoredText(const char* label, vec3 color, bool defaultOpen = false);
	void EndTree();

	inline void Value(const char* prefix, int64 v) { ImGui::Text("%s: %lld", prefix, v); }
	inline void Value(const char* prefix, uint64 v) { ImGui::Text("%s: %llu", prefix, v); }
	inline void Value(const char* prefix, const char* v) { ImGui::Text("%s: %s", prefix, v); }

	void CenteredText(const char* text);

	void PopupOkButton(uint32 width = 120);

	bool AssetHandle(const char* label, const char* type, asset_handle& asset, const char* clearText = 0);
	bool TextureAssetHandle(const char* label, const char* type, asset_handle& asset,
		const ref<dx_texture>& texture, uint32 width = 0, uint32 height = 0, ImVec2 uv0 = ImVec2(0.f, 0.f), ImVec2 uv1 = ImVec2(1.f, 1.f), const char* clearText = 0);



	bool Drag(const char* label, float& f, float speed = 1.f, float min = -FLT_MAX, float max = FLT_MAX, const char* format = "%.3f");
	bool Drag(const char* label, vec2& f, float speed = 1.f, float min = -FLT_MAX, float max = FLT_MAX, const char* format = "%.3f");
	bool Drag(const char* label, vec3& f, float speed = 1.f, float min = -FLT_MAX, float max = FLT_MAX, const char* format = "%.3f");
	bool Drag(const char* label, vec4& f, float speed = 1.f, float min = -FLT_MAX, float max = FLT_MAX, const char* format = "%.3f");
	bool Drag(const char* label, int32& f, float speed = 1.f, int32 min = INT32_MIN, int32 max = INT32_MAX, const char* format = "%d");
	bool Drag(const char* label, uint32& f, float speed = 1.f, uint32 min = 0, uint32 max = UINT32_MAX, const char* format = "%u");
	bool DragRange(const char* label, float& lo, float& hi, float speed = 1.f, float min = -FLT_MAX, float max = FLT_MAX, const char* format = "%.3f");
	bool DragRange(const char* label, int32& lo, int32& hi, float speed = 1.f, int32 min = INT32_MIN, int32 max = INT32_MAX, const char* format = "%.3f");


	bool BeginProperties();
	void EndProperties();

	void PropertyValue(const char* label, const char* format, ...);

	inline void PropertyValue(const char* label, bool v) { ImGui::PropertyValue(label, v ? "True" : "False"); }
	inline void PropertyValue(const char* label, float v, const char* format = "%.3f") { ImGui::PropertyValue(label, format, v); }
	inline void PropertyValue(const char* label, int32 v, const char* format = "%d") { ImGui::PropertyValue(label, format, v); }
	inline void PropertyValue(const char* label, uint32 v, const char* format = "%u") { ImGui::PropertyValue(label, format, v); }
	inline void PropertyValue(const char* label, int64 v, const char* format = "%lld") { ImGui::PropertyValue(label, format, v); }
	inline void PropertyValue(const char* label, uint64 v, const char* format = "%llu") { ImGui::PropertyValue(label, format, v); }
	inline void PropertyValue(const char* label, vec2 v, const char* format = "%.3f, %.3f") { ImGui::PropertyValue(label, format, v.x, v.y); }
	inline void PropertyValue(const char* label, vec3 v, const char* format = "%.3f, %.3f, %.3f") { ImGui::PropertyValue(label, format, v.x, v.y, v.z); }
	inline void PropertyValue(const char* label, vec4 v, const char* format = "%.3f, %.3f, %.3f, %.3f") { ImGui::PropertyValue(label, format, v.x, v.y, v.z, v.w); }

	bool PropertyCheckbox(const char* label, bool& v);

	bool PropertySlider(const char* label, float& f, float minValue = 0.f, float maxValue = 1.f, const char* format = "%.3f", ImGuiSliderFlags flags = ImGuiSliderFlags_None);
	bool PropertySlider(const char* label, vec2& f, float minValue = 0.f, float maxValue = 1.f, const char* format = "%.3f", ImGuiSliderFlags flags = ImGuiSliderFlags_None);
	bool PropertySlider(const char* label, vec3& f, float minValue = 0.f, float maxValue = 1.f, const char* format = "%.3f", ImGuiSliderFlags flags = ImGuiSliderFlags_None);
	bool PropertySlider(const char* label, vec4& f, float minValue = 0.f, float maxValue = 1.f, const char* format = "%.3f", ImGuiSliderFlags flags = ImGuiSliderFlags_None);

	bool PropertySliderAngle(const char* label, float& fRad, float minValueDeg = -360.f, float maxValueDeg = 360.f, const char* format = "%.0f deg");

	bool PropertySlider(const char* label, int32& v, int minValue, int maxValue, const char* format = "%d");
	bool PropertySlider(const char* label, uint32& v, uint32 minValue, uint32 maxValue, const char* format = "%u");

	bool PropertyInput(const char* label, float& f, const char* format = "%.3f");
	bool PropertyInput(const char* label, vec2& f, const char* format = "%.3f");
	bool PropertyInput(const char* label, vec3& f, const char* format = "%.3f");
	bool PropertyInput(const char* label, vec4& f, const char* format = "%.3f");
	bool PropertyInput(const char* label, int32& f, const char* format = "%d");
	bool PropertyInput(const char* label, uint32& f, const char* format = "%u");

	bool PropertyDrag(const char* label, float& f, float speed = 1.f, float min = -FLT_MAX, float max = FLT_MAX, const char* format = "%.3f");
	bool PropertyDrag(const char* label, vec2& f, float speed = 1.f, float min = -FLT_MAX, float max = FLT_MAX, const char* format = "%.3f");
	bool PropertyDrag(const char* label, vec3& f, float speed = 1.f, float min = -FLT_MAX, float max = FLT_MAX, const char* format = "%.3f");
	bool PropertyDrag(const char* label, vec4& f, float speed = 1.f, float min = -FLT_MAX, float max = FLT_MAX, const char* format = "%.3f");
	bool PropertyDrag(const char* label, int32& f, float speed = 1.f, int32 min = INT32_MIN, int32 max = INT32_MAX, const char* format = "%d");
	bool PropertyDrag(const char* label, uint32& f, float speed = 1.f, uint32 min = 0, uint32 max = UINT32_MAX, const char* format = "%u");
	bool PropertyDragRange(const char* label, float& lo, float& hi, float speed = 1.f, float min = -FLT_MAX, float max = FLT_MAX, const char* format = "%.3f");
	bool PropertyDragRange(const char* label, int32& lo, int32& hi, float speed = 1.f, int32 min = INT32_MIN, int32 max = INT32_MAX, const char* format = "%.3f");


	bool PropertyDropdown(const char* label, const char** names, uint32 count, uint32& current);
	bool PropertyDropdown(const char* label, const char* (*name_func)(uint32, void*), uint32& current, void* data = 0);
	bool PropertyDropdownPowerOfTwo(const char* label, uint32 from, uint32 to, uint32& current);

	bool PropertyColor(const char* label, vec3& f);
	bool PropertyColor(const char* label, vec4& f);

	bool PropertyColorWheel(const char* label, vec3& f);
	bool PropertyColorWheel(const char* label, vec4& f);

	bool PropertyButton(const char* label, const char* buttonText, const char* hoverText = 0, ImVec2 size = ImVec2(0, 0));

	bool PropertyInputText(const char* label, char* buffer, uint32 bufferSize, bool disableInput = false);

	bool PropertyAssetHandle(const char* label, const char* type, asset_handle& asset, const char* clearText = 0);
	bool PropertyTextureAssetHandle(const char* label, const char* type, asset_handle& asset,
		const ref<dx_texture>& texture, uint32 width = 0, uint32 height = 0, ImVec2 uv0 = ImVec2(0.f, 0.f), ImVec2 uv1 = ImVec2(1.f, 1.f), const char* clearText = 0);

	bool PropertyDragDropStringTarget(const char* label, const char* dragDropID, std::string& value, const char* clearLabel = 0);

	void PropertySeparator();




	bool Spline(const char* label, ImVec2 size, uint32 maxNumPoints, float* x, float* y, uint32 drawResolution = 256);

	template <uint32 maxNumPoints> 
	bool Spline(const char* label, ImVec2 size, catmull_rom_spline<float, maxNumPoints>& s, uint32 drawResolution = 256)
	{
		return Spline(label, size, maxNumPoints, s.ts, s.values, drawResolution);
	}


	bool PropertySpline(const char* label, uint32 maxNumPoints, float* x, float* y, uint32 drawResolution = 256);

	template <uint32 maxNumPoints>
	bool PropertySpline(const char* label, catmull_rom_spline<float, maxNumPoints>& s, uint32 drawResolution = 256)
	{
		return PropertySpline(label, maxNumPoints, s.ts, s.values, drawResolution);
	}

	static const ImColor white(1.f, 1.f, 1.f, 1.f);
	static const ImColor yellow(1.f, 1.f, 0.f, 1.f);
	static const ImColor green(0.f, 1.f, 0.f, 1.f);
	static const ImColor red(1.f, 0.f, 0.f, 1.f);
	static const ImColor blue(0.f, 0.f, 1.f, 1.f);
}

```

`src/core/input.h`:

```h
#pragma once

enum key_code
{
	key_shift = VK_SHIFT,
	key_ctrl = VK_CONTROL,
	key_alt = VK_MENU,
	key_esc = VK_ESCAPE,
	key_caps = VK_CAPITAL,
	key_space = VK_SPACE,
	key_enter = VK_RETURN,
	key_backspace = VK_BACK,
	key_delete = VK_DELETE,
	key_tab = VK_TAB,
	key_left = VK_LEFT,
	key_right = VK_RIGHT,
	key_up = VK_UP,
	key_down = VK_DOWN,
	key_print = VK_SNAPSHOT,
	key_f1 = VK_F1,
	key_f2 = VK_F2,
	key_f3 = VK_F3,
	key_f4 = VK_F4,
	key_f5 = VK_F5,
	key_f6 = VK_F6,
	key_f7 = VK_F7,
	key_f8 = VK_F8,
	key_f9 = VK_F9,
	key_f10 = VK_F10,
	key_f11 = VK_F11,
	key_f12 = VK_F12,
};

struct input_key
{
	bool down;
	bool pressEvent;
};

struct input_mouse_button
{
	bool down;
	bool clickEvent;
	bool doubleClickEvent;
	bool padding;
};

struct mouse_input
{
	input_mouse_button left;
	input_mouse_button right;
	input_mouse_button middle;
	float scroll;

	int32 x;
	int32 y;
	int32 dx;
	int32 dy;

	float relX;
	float relY;
	float reldx;
	float reldy;
};

struct user_input
{
	input_key keyboard[128];
	mouse_input mouse;
	bool overWindow;
	bool padding[3];
};


```

`src/core/job_system.cpp`:

```cpp
#include "pch.h"
#include "job_system.h"
#include "math.h"
#include "imgui.h"


job_queue highPriorityJobQueue;
job_queue lowPriorityJobQueue;
job_queue mainThreadJobQueue;

job_queue* queues[] =
{
    &highPriorityJobQueue,
    &lowPriorityJobQueue,
    &mainThreadJobQueue,
};

void job_queue::initialize(int32 queueIndex, uint32 numThreads, uint32 threadOffset, int32 threadPriority, const wchar* description)
{
    this->queueIndex = queueIndex;
    queue = moodycamel::ConcurrentQueue<int32>(capacity);

    for (uint32 i = 0; i < numThreads; ++i)
    {
        std::thread thread([this, i]() { threadFunc(i); });

        HANDLE handle = (HANDLE)thread.native_handle();
        SetThreadPriority(handle, threadPriority);

        uint64 affinityMask = 1ull << (i + threadOffset);
        SetThreadAffinityMask(handle, affinityMask);
        SetThreadDescription(handle, description);

        thread.detach();
    }
}

void job_queue::addContinuation(int32 firstGlobalIndex, job_handle second)
{
    job_queue_entry& firstJob = allJobs[firstGlobalIndex & indexMask];
    ASSERT(firstJob.continuation.globalIndex == -1);

    int32 unfinished = firstJob.numUnfinishedJobs++;
    if (unfinished == 0)
    {
        // First job was finished before adding continuation -> just submit second.
        queues[second.queueIndex]->submit(second.globalIndex);
    }
    else
    {
        // First job hadn't finished before -> add second as continuation and then finish first (which decrements numUnfinished again).
        firstJob.continuation = second;
        finishJob(firstGlobalIndex);
    }
}

void job_queue::submit(int32 globalIndex)
{
    if (globalIndex != -1)
    {
        while (!queue.try_enqueue(globalIndex))
        {
            executeNextJob();
        }

        ++runningJobs;
        
        wakeCondition.notify_one();
    }
}

void job_queue::waitForCompletion()
{
    while (runningJobs)
    {
        executeNextJob();
    }
}

void job_queue::waitForCompletion(int32 globalIndex)
{
    if (globalIndex != -1)
    {
        job_queue_entry& job = allJobs[globalIndex & indexMask];

        while (job.numUnfinishedJobs > 0) 
        {
            executeNextJob();
        }
    }
}

bool job_queue::isComplete(int32 globalIndex)
{
    job_queue_entry& job = allJobs[globalIndex & indexMask];
    return (nextFreeJob >= (globalIndex + capacity)) 
        || (job.numUnfinishedJobs == 0);
}

void job_queue::finishJob(int32 globalIndex)
{
    job_queue_entry& job = allJobs[globalIndex & indexMask];
    int32 numUnfinishedJobs = --job.numUnfinishedJobs;
    ASSERT(numUnfinishedJobs >= 0);
    if (numUnfinishedJobs == 0)
    {
        --runningJobs;

        if (job.parentGlobalIndex != -1)
        {
            finishJob(job.parentGlobalIndex);
        }

        if (job.continuation.globalIndex != -1)
        {
            queues[job.continuation.queueIndex]->submit(job.continuation.globalIndex);
        }
    }
}

bool job_queue::executeNextJob()
{
    int32 globalIndex = -1;
    if (queue.try_dequeue(globalIndex))
    {
        job_queue_entry& job = allJobs[globalIndex & indexMask];
        job.function(job.templatedFunction, job.data, { globalIndex, queueIndex });

        finishJob(globalIndex);

        return true;
    }

    return false;
}

void job_queue::threadFunc(int32 threadIndex)
{
    while (true)
    {
        if (!executeNextJob())
        {
            std::unique_lock<std::mutex> lock(wakeMutex);
            wakeCondition.wait(lock);
        }
    }
}

void job_handle::submitNow()
{
    //std::cout << globalIndex << '\n';
    queues[queueIndex]->submit(globalIndex);
}

void job_handle::submitAfter(job_handle before)
{
    queues[before.queueIndex]->addContinuation(before.globalIndex, *this);
}

void job_handle::waitForCompletion()
{
    queues[queueIndex]->waitForCompletion(globalIndex);
}

bool job_handle::isComplete()
{
    return queues[queueIndex]->isComplete(globalIndex);
}




void initializeJobSystem()
{
    HANDLE handle = GetCurrentThread();
    SetThreadAffinityMask(handle, 1);
    SetThreadPriority(handle, THREAD_PRIORITY_HIGHEST);
    CloseHandle(handle);

    //uint32 numHardwareThreads = std::thread::hardware_concurrency();


    highPriorityJobQueue.initialize(0, 4, 1, THREAD_PRIORITY_NORMAL, L"High priority worker");
    lowPriorityJobQueue.initialize(1, 4, 5, THREAD_PRIORITY_BELOW_NORMAL, L"Low priority worker");
    mainThreadJobQueue.initialize(2, 0, 0, 0, 0);
}

void executeMainThreadJobs()
{
    mainThreadJobQueue.waitForCompletion();
}

```

`src/core/job_system.h`:

```h
#pragma once

#include <concurrentqueue/concurrentqueue.h>

struct job_handle
{
    int32 globalIndex = -1;
    int32 queueIndex = -1;

    bool valid() { return queueIndex != -1; }
    void submitNow();
    void submitAfter(job_handle before);
    void waitForCompletion();
    bool isComplete();
};

template <typename data_t>
using job_function = void (*)(data_t&, job_handle);

struct job_queue
{
    void initialize(int32 queueIndex, uint32 numThreads, uint32 threadOffset, int32 threadPriority, const wchar* description);

    template <typename data_t>
    job_handle createJob(job_function<data_t> function, const data_t& data, job_handle parent = {})
    {
        static_assert(sizeof(data_t) <= job_queue_entry::DATA_SIZE);

        int32 globalIndex = nextFreeJob++;
        auto& job = allJobs[globalIndex & indexMask];
        job.numUnfinishedJobs = 1;
        job.parentGlobalIndex = parent.globalIndex;
        job.continuation.globalIndex = -1;

        if (parent.globalIndex != -1)
        {
            ASSERT(parent.queueIndex == queueIndex);
            ++allJobs[parent.globalIndex & indexMask].numUnfinishedJobs;
        }

        job.templatedFunction = function;
        job.function = [](void* templatedFunction, void* rawData, job_handle job)
        {
            data_t& data = *(data_t*)rawData;

            auto function = (job_function<data_t>)templatedFunction;
            function(data, job);

            data.~data_t();
        };

        new(job.data) data_t(data);

        return job_handle{ globalIndex, queueIndex };
    }


    void waitForCompletion();

private:

    struct job_queue_entry
    {
        void (*function)(void*, void*, job_handle);
        void* templatedFunction;

        std::atomic<int32> numUnfinishedJobs;
        int32 parentGlobalIndex; // Always in the same queue.
        job_handle continuation;


        static constexpr uint64 SIZE = sizeof(function) + sizeof(templatedFunction) + sizeof(numUnfinishedJobs) + sizeof(parentGlobalIndex) + sizeof(continuation);
        static constexpr uint64 DATA_SIZE = (2 * 64) - SIZE;

        uint8 data[DATA_SIZE];
    };

    static_assert(sizeof(job_queue_entry) % 64 == 0);



    friend struct job_handle;

    void addContinuation(int32 firstGlobalIndex, job_handle second);
    void submit(int32 globalIndex);
    void waitForCompletion(int32 globalIndex);
    bool isComplete(int32 globalIndex);


    void finishJob(int32 globalIndex);
    bool executeNextJob();
    void threadFunc(int32 threadIndex);


    moodycamel::ConcurrentQueue<int32> queue;
    std::atomic<uint32> runningJobs = 0;

    static constexpr int32 capacity = 4096;
    static constexpr int32 indexMask = capacity - 1;

    job_queue_entry allJobs[capacity];
    std::atomic<uint32> nextFreeJob = 0;

    int32 queueIndex;

    std::condition_variable wakeCondition;
    std::mutex wakeMutex;
};

extern job_queue highPriorityJobQueue;
extern job_queue lowPriorityJobQueue;
extern job_queue mainThreadJobQueue;


void initializeJobSystem();
void executeMainThreadJobs();


```

`src/core/log.cpp`:

```cpp
#include "pch.h"
#include "log.h"
#include "imgui.h"
#include "memory.h"

bool logWindowOpen = false;

#if ENABLE_MESSAGE_LOG

struct log_message
{
	const char* text;
	message_type type;
	float lifetime;
	const char* file;
	const char* function;
	uint32 line;
};

static const ImVec4 colorPerType[] = 
{
	ImVec4(1.f, 1.f, 1.f, 1.f),
	ImVec4(1.f, 1.f, 0.f, 1.f),
	ImVec4(1.f, 0.f, 0.f, 1.f),
};

static memory_arena arena;
static std::vector<log_message> messages;
static std::mutex mutex;

void logMessageInternal(message_type type, const char* file, const char* function, uint32 line, const char* format, ...)
{
	mutex.lock();
	arena.ensureFreeSize(1024);

	char* buffer = (char*)arena.getCurrent();

	va_list args;
	va_start(args, format);
	int countWritten = vsnprintf(buffer, 1024, format, args);
	va_end(args);

	messages.push_back({ buffer, type, 5.f, file, function, line });

	arena.setCurrentTo(buffer + countWritten + 1);
	mutex.unlock();
}

void initializeMessageLog()
{
	arena.initialize(0, GB(1));
}

void updateMessageLog(float dt)
{
	dt = min(dt, 1.f); // If the app hangs, we don't want all the messages to go missing.

	ImGui::PushStyleVar(ImGuiStyleVar_WindowRounding, 10.f);
	ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0.f, 0.1f));
	ImGui::SetNextWindowSize(ImVec2(0.f, 0.f)); // Auto-resize to content.
	bool windowOpen = ImGui::Begin("##MessageLog", 0, 
		ImGuiWindowFlags_NoBackground | ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse | 
		ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_NoBringToFrontOnFocus);
	ImGui::PopStyleVar(2);

	uint32 count = (uint32)messages.size();
	uint32 startIndex = 0;

	for (uint32 i = count - 1; i != UINT32_MAX; --i)
	{
		auto& msg = messages[i];

		if (msg.lifetime <= 0.f)
		{
			startIndex = i + 1;
			break;
		}
		msg.lifetime -= dt;
	}

	uint32 numMessagesToShow = count - startIndex;
	numMessagesToShow = min(numMessagesToShow, 8u);
	startIndex = count - numMessagesToShow;

	if (windowOpen)
	{
		for (uint32 i = startIndex; i < count; ++i)
		{
			auto& msg = messages[i];
			ImGui::TextColored(colorPerType[msg.type], msg.text);
		}
	}
	ImGui::End();


	if (logWindowOpen)
	{
		if (ImGui::Begin(ICON_FA_CLIPBOARD_LIST "  Message log", &logWindowOpen))
		{
			for (uint32 i = 0; i < count; ++i)
			{
				auto& msg = messages[i];
				ImGui::TextColored(colorPerType[msg.type], "%s (%s [%u])", msg.text, msg.function, msg.line);
			}
		}
		ImGui::End();
	}
}

#endif

```

`src/core/log.h`:

```h
#pragma once

extern bool logWindowOpen;

#if ENABLE_MESSAGE_LOG

enum message_type
{
	message_type_normal,
	message_type_warning,
	message_type_error,

	message_type_count,
};

#define LOG_MESSAGE(message, ...) logMessageInternal(message_type_normal, __FILE__, __FUNCTION__, __LINE__, message, __VA_ARGS__)
#define LOG_WARNING(message, ...) logMessageInternal(message_type_warning, __FILE__, __FUNCTION__, __LINE__, message, __VA_ARGS__)
#define LOG_ERROR(message, ...) logMessageInternal(message_type_error, __FILE__, __FUNCTION__, __LINE__, message, __VA_ARGS__)

void logMessageInternal(message_type type, const char* file, const char* function, uint32 line, const char* format, ...);

void initializeMessageLog();
void updateMessageLog(float dt);


#else
#define LOG_MESSAGE(...)
#define LOG_WARNING(...)
#define LOG_ERROR(...)

#define initializeMessageLog(...)
#define updateMessageLog(...)

#endif

```

`src/core/math.cpp`:

```cpp
#include "pch.h"
#include "math.h"
#include <half/half.c>

const half half::minValue = (uint16)0b1111101111111111;
const half half::maxValue = (uint16)0b0111101111111111;

const mat2 mat2::identity =
{
	1.f, 0.f,
	0.f, 1.f,
};

const mat2 mat2::zero =
{
	0.f, 0.f,
	0.f, 0.f,
};

const mat3 mat3::identity =
{
	1.f, 0.f, 0.f,
	0.f, 1.f, 0.f,
	0.f, 0.f, 1.f,
};

const mat3 mat3::zero =
{
	0.f, 0.f, 0.f,
	0.f, 0.f, 0.f,
	0.f, 0.f, 0.f,
};

const mat4 mat4::identity =
{
	1.f, 0.f, 0.f, 0.f,
	0.f, 1.f, 0.f, 0.f,
	0.f, 0.f, 1.f, 0.f,
	0.f, 0.f, 0.f, 1.f,
};

const mat4 mat4::zero =
{
	0.f, 0.f, 0.f, 0.f,
	0.f, 0.f, 0.f, 0.f,
	0.f, 0.f, 0.f, 0.f,
	0.f, 0.f, 0.f, 0.f,
};

const vec2 vec2::zero = { 0.f, 0.f };
const vec3 vec3::zero = { 0.f, 0.f, 0.f };
const vec4 vec4::zero = { 0.f, 0.f, 0.f, 0.f };

const quat quat::identity = { 0.f, 0.f, 0.f, 1.f };
const quat quat::zero = { 0.f, 0.f, 0.f, 0.f };

const dual_quat dual_quat::identity = { { 0.f, 0.f, 0.f, 1.f }, { 0.f, 0.f, 0.f, 0.f } };
const dual_quat dual_quat::zero = { { 0.f, 0.f, 0.f, 0.f }, { 0.f, 0.f, 0.f, 0.f } };

const trs trs::identity = { vec3(0.f, 0.f, 0.f), quat(0.f, 0.f, 0.f, 1.f), vec3(1.f, 1.f, 1.f) };


half::half(float f)
{
	h = half_from_float(*(uint32*)&f);
}

half::half(uint16 i)
{
	h = i;
}

half::operator float()
{
	uint32 f = half_to_float(h);
	return *(float*)&f;
}

half operator+(half a, half b) { half result; result.h = half_add(a.h, b.h); return result; }
half& operator+=(half& a, half b) {	a = a + b; return a; }
half operator-(half a, half b) { half result; result.h = half_sub(a.h, b.h); return result; }
half& operator-=(half& a, half b) {	a = a - b; return a; }
half operator*(half a, half b) { half result; result.h = half_mul(a.h, b.h); return result; }
half& operator*=(half& a, half b) {	a = a * b; return a; }
half operator/(half a, half b) { half result; result.h = half_div(a.h, b.h); return result; }
half& operator/=(half& a, half b) { a = a / b; return a; }


mat2 operator*(const mat2& a, const mat2& b)
{
	vec2 r0 = row(a, 0);
	vec2 r1 = row(a, 1);

	vec2 c0 = col(b, 0);
	vec2 c1 = col(b, 1);

	mat2 result;
	result.m00 = dot(r0, c0); result.m01 = dot(r0, c1);
	result.m10 = dot(r1, c0); result.m11 = dot(r1, c1);
	return result;
}

mat3 operator*(const mat3& a, const mat3& b)
{
	vec3 r0 = row(a, 0);
	vec3 r1 = row(a, 1);
	vec3 r2 = row(a, 2);

	vec3 c0 = col(b, 0);
	vec3 c1 = col(b, 1);
	vec3 c2 = col(b, 2);

	mat3 result;
	result.m00 = dot(r0, c0); result.m01 = dot(r0, c1); result.m02 = dot(r0, c2);
	result.m10 = dot(r1, c0); result.m11 = dot(r1, c1); result.m12 = dot(r1, c2);
	result.m20 = dot(r2, c0); result.m21 = dot(r2, c1); result.m22 = dot(r2, c2);
	return result;
}

mat3 operator+(const mat3& a, const mat3& b)
{
	mat3 result;
	for (uint32 i = 0; i < 9; ++i)
	{
		result.m[i] = a.m[i] + b.m[i];
	}
	return result;
}

mat3& operator+=(mat3& a, const mat3& b)
{
	for (uint32 i = 0; i < 9; ++i)
	{
		a.m[i] += b.m[i];
	}
	return a;
}

mat3 operator-(const mat3& a, const mat3& b)
{
	mat3 result;
	for (uint32 i = 0; i < 9; ++i)
	{
		result.m[i] = a.m[i] - b.m[i];
	}
	return result;
}

mat4 operator*(const mat4& a, const mat4& b)
{
#ifndef SIMD_AVX_2
	mat4 result;
	vec4 r0 = row(a, 0);
	vec4 r1 = row(a, 1);
	vec4 r2 = row(a, 2);
	vec4 r3 = row(a, 3);

	vec4 c0 = col(b, 0);
	vec4 c1 = col(b, 1);
	vec4 c2 = col(b, 2);
	vec4 c3 = col(b, 3);

	result.m00 = dot(r0, c0); result.m01 = dot(r0, c1); result.m02 = dot(r0, c2); result.m03 = dot(r0, c3);
	result.m10 = dot(r1, c0); result.m11 = dot(r1, c1); result.m12 = dot(r1, c2); result.m13 = dot(r1, c3);
	result.m20 = dot(r2, c0); result.m21 = dot(r2, c1); result.m22 = dot(r2, c2); result.m23 = dot(r2, c3);
	result.m30 = dot(r3, c0); result.m31 = dot(r3, c1); result.m32 = dot(r3, c2); result.m33 = dot(r3, c3);
	return result;
#else
	w8_float a0, a1, b0, b1;

#if ROW_MAJOR
	w8_float u0 = b.m;
	w8_float u1 = b.m + 8;
	w8_float t0 = a.m;
	w8_float t1 = a.m + 8;
#else
	w8_float t0 = b.m;
	w8_float t1 = b.m + 8;
	w8_float u0 = a.m;
	w8_float u1 = a.m + 8;
#endif

	a0 = _mm256_shuffle_ps(t0, t0, _MM_SHUFFLE(0, 0, 0, 0));
	a1 = _mm256_shuffle_ps(t1, t1, _MM_SHUFFLE(0, 0, 0, 0));
	b0 = _mm256_permute2f128_ps(u0, u0, 0x00);
	w8_float c0 = a0 * b0;
	w8_float c1 = a1 * b0;

	a0 = _mm256_shuffle_ps(t0, t0, _MM_SHUFFLE(1, 1, 1, 1));
	a1 = _mm256_shuffle_ps(t1, t1, _MM_SHUFFLE(1, 1, 1, 1));
	b0 = _mm256_permute2f128_ps(u0, u0, 0x11);
	c0 = fmadd(a0, b0, c0);
	c1 = fmadd(a1, b0, c1);

	a0 = _mm256_shuffle_ps(t0, t0, _MM_SHUFFLE(2, 2, 2, 2));
	a1 = _mm256_shuffle_ps(t1, t1, _MM_SHUFFLE(2, 2, 2, 2));
	b1 = _mm256_permute2f128_ps(u1, u1, 0x00);
	c0 = fmadd(a0, b1, c0);
	c1 = fmadd(a1, b1, c1);

	a0 = _mm256_shuffle_ps(t0, t0, _MM_SHUFFLE(3, 3, 3, 3));
	a1 = _mm256_shuffle_ps(t1, t1, _MM_SHUFFLE(3, 3, 3, 3));
	b1 = _mm256_permute2f128_ps(u1, u1, 0x11);
	c0 = fmadd(a0, b1, c0);
	c1 = fmadd(a1, b1, c1);

	mat4 result;
	c0.store(result.m);
	c1.store(result.m + 8);
	return result;
#endif
}


mat2 operator*(const mat2& a, float b) { mat2 result; for (uint32 i = 0; i < 4; ++i) { result.m[i] = a.m[i] * b; } return result; }
mat3 operator*(const mat3& a, float b) { mat3 result; for (uint32 i = 0; i < 9; ++i) { result.m[i] = a.m[i] * b; } return result; }

#if ROW_MAJOR
mat4 operator*(const mat4& a, float b) { mat4 result; for (uint32 i = 0; i < 4; ++i) { result.rows[i] = a.rows[i] * b; } return result; }
#else
mat4 operator*(const mat4& a, float b) { mat4 result; for (uint32 i = 0; i < 4; ++i) { result.cols[i] = a.cols[i] * b; } return result; }
#endif

mat2 operator*(float a, const mat2& b) { return b * a; }
mat3 operator*(float a, const mat3& b) { return b * a; }
mat4 operator*(float a, const mat4& b) { return b * a; }

mat2& operator*=(mat2& a, float b) { a = a * b; return a; }
mat3& operator*=(mat3& a, float b) { a = a * b; return a; }
mat4& operator*=(mat4& a, float b) { a = a * b; return a; }


mat2 transpose(const mat2& a)
{
	mat2 result;
	result.m00 = a.m00; result.m01 = a.m10;
	result.m10 = a.m01; result.m11 = a.m11;
	return result;
}

mat3 transpose(const mat3& a)
{
	mat3 result;
	result.m00 = a.m00; result.m01 = a.m10; result.m02 = a.m20;
	result.m10 = a.m01; result.m11 = a.m11; result.m12 = a.m21;
	result.m20 = a.m02; result.m21 = a.m12; result.m22 = a.m22;
	return result;
}

mat4 transpose(const mat4& a)
{
	mat4 result = a;
	transpose(result.f40, result.f41, result.f42, result.f43);
	return result;
}

mat2 invert(const mat2& m)
{
	float det = determinant(m);
	if (det == 0.f)
	{
		return mat2();
	}

	mat2 inv;
	inv.m00 = m.m11;
	inv.m01 = -m.m01;
	inv.m10 = -m.m10;
	inv.m11 = m.m00;

	inv *= 1.f / det;

	return inv;
}

mat3 invert(const mat3& m)
{
	mat3 inv;

	inv.m00 = m.m11 * m.m22 - m.m21 * m.m12;
	inv.m01 = m.m02 * m.m21 - m.m22 * m.m01;
	inv.m02 = m.m01 * m.m12 - m.m11 * m.m02;

	inv.m10 = m.m12 * m.m20 - m.m22 * m.m10;
	inv.m11 = m.m00 * m.m22 - m.m20 * m.m02;
	inv.m12 = m.m02 * m.m10 - m.m12 * m.m00;

	inv.m20 = m.m10 * m.m21 - m.m20 * m.m11;
	inv.m21 = m.m01 * m.m20 - m.m21 * m.m00;
	inv.m22 = m.m00 * m.m11 - m.m10 * m.m01;

	float det = m.m00 * (m.m11 * m.m22 - m.m21 * m.m12)
		- m.m01 * (m.m10 * m.m22 - m.m20 * m.m12)
		+ m.m02 * (m.m10 * m.m21 - m.m20 * m.m11);

	if (det == 0.f)
	{
		return mat3();
	}

	det = 1.f / det;

	inv *= det;

	return inv;
}

mat4 invert(const mat4& m)
{
	mat4 inv;

	inv.m00 = m.m11 * m.m22 * m.m33 -
		m.m11 * m.m32 * m.m23 -
		m.m12 * m.m21 * m.m33 +
		m.m12 * m.m31 * m.m23 +
		m.m13 * m.m21 * m.m32 -
		m.m13 * m.m31 * m.m22;

	inv.m01 = -m.m01 * m.m22 * m.m33 +
		m.m01 * m.m32 * m.m23 +
		m.m02 * m.m21 * m.m33 -
		m.m02 * m.m31 * m.m23 -
		m.m03 * m.m21 * m.m32 +
		m.m03 * m.m31 * m.m22;

	inv.m02 = m.m01 * m.m12 * m.m33 -
		m.m01 * m.m32 * m.m13 -
		m.m02 * m.m11 * m.m33 +
		m.m02 * m.m31 * m.m13 +
		m.m03 * m.m11 * m.m32 -
		m.m03 * m.m31 * m.m12;

	inv.m03 = -m.m01 * m.m12 * m.m23 +
		m.m01 * m.m22 * m.m13 +
		m.m02 * m.m11 * m.m23 -
		m.m02 * m.m21 * m.m13 -
		m.m03 * m.m11 * m.m22 +
		m.m03 * m.m21 * m.m12;

	inv.m10 = -m.m10 * m.m22 * m.m33 +
		m.m10 * m.m32 * m.m23 +
		m.m12 * m.m20 * m.m33 -
		m.m12 * m.m30 * m.m23 -
		m.m13 * m.m20 * m.m32 +
		m.m13 * m.m30 * m.m22;

	inv.m11 = m.m00 * m.m22 * m.m33 -
		m.m00 * m.m32 * m.m23 -
		m.m02 * m.m20 * m.m33 +
		m.m02 * m.m30 * m.m23 +
		m.m03 * m.m20 * m.m32 -
		m.m03 * m.m30 * m.m22;

	inv.m12 = -m.m00 * m.m12 * m.m33 +
		m.m00 * m.m32 * m.m13 +
		m.m02 * m.m10 * m.m33 -
		m.m02 * m.m30 * m.m13 -
		m.m03 * m.m10 * m.m32 +
		m.m03 * m.m30 * m.m12;

	inv.m13 = m.m00 * m.m12 * m.m23 -
		m.m00 * m.m22 * m.m13 -
		m.m02 * m.m10 * m.m23 +
		m.m02 * m.m20 * m.m13 +
		m.m03 * m.m10 * m.m22 -
		m.m03 * m.m20 * m.m12;

	inv.m20 = m.m10 * m.m21 * m.m33 -
		m.m10 * m.m31 * m.m23 -
		m.m11 * m.m20 * m.m33 +
		m.m11 * m.m30 * m.m23 +
		m.m13 * m.m20 * m.m31 -
		m.m13 * m.m30 * m.m21;

	inv.m21 = -m.m00 * m.m21 * m.m33 +
		m.m00 * m.m31 * m.m23 +
		m.m01 * m.m20 * m.m33 -
		m.m01 * m.m30 * m.m23 -
		m.m03 * m.m20 * m.m31 +
		m.m03 * m.m30 * m.m21;

	inv.m22 = m.m00 * m.m11 * m.m33 -
		m.m00 * m.m31 * m.m13 -
		m.m01 * m.m10 * m.m33 +
		m.m01 * m.m30 * m.m13 +
		m.m03 * m.m10 * m.m31 -
		m.m03 * m.m30 * m.m11;

	inv.m23 = -m.m00 * m.m11 * m.m23 +
		m.m00 * m.m21 * m.m13 +
		m.m01 * m.m10 * m.m23 -
		m.m01 * m.m20 * m.m13 -
		m.m03 * m.m10 * m.m21 +
		m.m03 * m.m20 * m.m11;

	inv.m30 = -m.m10 * m.m21 * m.m32 +
		m.m10 * m.m31 * m.m22 +
		m.m11 * m.m20 * m.m32 -
		m.m11 * m.m30 * m.m22 -
		m.m12 * m.m20 * m.m31 +
		m.m12 * m.m30 * m.m21;

	inv.m31 = m.m00 * m.m21 * m.m32 -
		m.m00 * m.m31 * m.m22 -
		m.m01 * m.m20 * m.m32 +
		m.m01 * m.m30 * m.m22 +
		m.m02 * m.m20 * m.m31 -
		m.m02 * m.m30 * m.m21;

	inv.m32 = -m.m00 * m.m11 * m.m32 +
		m.m00 * m.m31 * m.m12 +
		m.m01 * m.m10 * m.m32 -
		m.m01 * m.m30 * m.m12 -
		m.m02 * m.m10 * m.m31 +
		m.m02 * m.m30 * m.m11;

	inv.m33 = m.m00 * m.m11 * m.m22 -
		m.m00 * m.m21 * m.m12 -
		m.m01 * m.m10 * m.m22 +
		m.m01 * m.m20 * m.m12 +
		m.m02 * m.m10 * m.m21 -
		m.m02 * m.m20 * m.m11;

	float det = m.m00 * inv.m00 + m.m10 * inv.m01 + m.m20 * inv.m02 + m.m30 * inv.m03;

	if (det == 0.f)
	{
		return mat4();
	}

	det = 1.f / det;

	inv *= det;

	return inv;
}

float determinant(const mat2& m)
{
	return m.m00 * m.m11 - m.m10 * m.m01;
}

float determinant(const mat3& m)
{
	return m.m00 * (m.m11 * m.m22 - m.m21 * m.m12)
		- m.m01 * (m.m10 * m.m22 - m.m20 * m.m12)
		+ m.m02 * (m.m10 * m.m21 - m.m20 * m.m11);
}

float determinant(const mat4& m)
{
	return
		m.m03 * m.m12 * m.m21 * m.m30 - m.m02 * m.m13 * m.m21 * m.m30 -
		m.m03 * m.m11 * m.m22 * m.m30 + m.m01 * m.m13 * m.m22 * m.m30 +
		m.m02 * m.m11 * m.m23 * m.m30 - m.m01 * m.m12 * m.m23 * m.m30 -
		m.m03 * m.m12 * m.m20 * m.m31 + m.m02 * m.m13 * m.m20 * m.m31 +
		m.m03 * m.m10 * m.m22 * m.m31 - m.m00 * m.m13 * m.m22 * m.m31 -
		m.m02 * m.m10 * m.m23 * m.m31 + m.m00 * m.m12 * m.m23 * m.m31 +
		m.m03 * m.m11 * m.m20 * m.m32 - m.m01 * m.m13 * m.m20 * m.m32 -
		m.m03 * m.m10 * m.m21 * m.m32 + m.m00 * m.m13 * m.m21 * m.m32 +
		m.m01 * m.m10 * m.m23 * m.m32 - m.m00 * m.m11 * m.m23 * m.m32 -
		m.m02 * m.m11 * m.m20 * m.m33 + m.m01 * m.m12 * m.m20 * m.m33 +
		m.m02 * m.m10 * m.m21 * m.m33 - m.m00 * m.m12 * m.m21 * m.m33 -
		m.m01 * m.m10 * m.m22 * m.m33 + m.m00 * m.m11 * m.m22 * m.m33;
}

float trace(const mat3& m)
{
	return m.m00 + m.m11 + m.m22;
}

float trace(const mat4& m)
{
	return m.m00 + m.m11 + m.m22 + m.m33;
}

trs operator*(const trs& a, const trs& b)
{
	//if (!isUniform(a.scale) || !isUniform(b.scale))
	//{
	//	return trsToMat4(a) * trsToMat4(b);
	//}

	trs result;
	result.rotation = a.rotation * b.rotation;
	result.position = a.rotation * (a.scale * b.position) + a.position;
	result.scale = a.scale * b.scale;
	return result;
}

trs invert(const trs& t)
{
	//if (!isUniform(t.scale))
	//{
	//	mat4 m = trsToMat4(t);
	//	mat4 invM = invert(m);
	//	trs result = invM;
	//	return result;
	//}

	quat invRotation = conjugate(t.rotation);
	vec3 invScale = 1.f / t.scale;
	vec3 invTranslation = invRotation * (invScale * -t.position);

	return trs(invTranslation, invRotation, invScale);
}

vec3 transformPosition(const mat4& m, vec3 pos)
{
	return (m * vec4(pos, 1.f)).xyz;
}

vec3 transformDirection(const mat4& m, vec3 dir)
{
	return (m * vec4(dir, 0.f)).xyz;
}

vec3 transformPosition(const trs& m, vec3 pos)
{
	return m.rotation * (m.scale * pos) + m.position;
}

vec3 transformDirection(const trs& m, vec3 dir)
{
	return m.rotation * dir;
}

vec3 inverseTransformPosition(const trs& m, vec3 pos)
{
	return (conjugate(m.rotation) * (pos - m.position)) / m.scale;
}

vec3 inverseTransformDirection(const trs& m, vec3 dir)
{
	return conjugate(m.rotation) * dir;
}

quat rotateFromTo(vec3 _from, vec3 _to)
{
	vec3 from = normalize(_from);
	vec3 to = normalize(_to);

	float d = dot(from, to);
	if (d >= 1.f)
	{
		return quat(0.f, 0.f, 0.f, 1.f);
	}

	quat q;
	if (d < (1e-6f - 1.f))
	{
		// Rotate 180° around some axis.
		vec3 axis = cross(vec3(1.f, 0.f, 0.f), from);
		if (squaredLength(axis) == 0.f) // Pick another if colinear.
		{
			axis = cross(vec3(0.f, 1.f, 0.f), from);
		}
		axis = normalize(axis);
		q = normalize(quat(axis, M_PI));
	}
	else
	{
		float s = sqrt((1.f + d) * 2.f);
		float invs = 1.f / s;

		vec3 c = cross(from, to);

		q.x = c.x * invs;
		q.y = c.y * invs;
		q.z = c.z * invs;
		q.w = s * 0.5f;
		q = normalize(q);
	}
	return q;
}

void getAxisRotation(quat q, vec3& axis, float& angle)
{
	float sqLength = squaredLength(q.v);
	if (sqLength > 0.f)
	{
		angle = 2.f * acos(q.w);
		float invLength = 1.f / sqrt(sqLength);
		axis = q.v * invLength;
	}
	else
	{
		// Angle is 0 (mod 2*pi), so any axis will do.
		angle = 0.f;
		axis = vec3(1.f, 0.f, 0.f);
	}
}

void decomposeQuaternionIntoTwistAndSwing(quat q, vec3 normalizedTwistAxis, quat& twist, quat& swing)
{
	vec3 axis(q.x, q.y, q.z);
	vec3 proj = dot(axis, normalizedTwistAxis) * normalizedTwistAxis; // This assumes that twistAxis is normalized.
	twist = normalize(quat(proj.x, proj.y, proj.z, q.w));
	swing = q * conjugate(twist);
}

quat slerp(quat from, quat to, float t)
{
	float d = dot(from.v4, to.v4);
	float absDot = d < 0.f ? -d : d;
	float scale0 = 1.f - t;
	float scale1 = t;

	if ((1.f - absDot) > 0.1f)
	{

		float angle = acosf(absDot);
		float invSinTheta = 1.f / sinf(angle);
		scale0 = (sinf((1.f - t) * angle) * invSinTheta);
		scale1 = (sinf((t * angle)) * invSinTheta);
	}

	if (d < 0.f)
	{
		scale1 = -scale1;
	}
	float newX = (scale0 * from.x) + (scale1 * to.x);
	float newY = (scale0 * from.y) + (scale1 * to.y);
	float newZ = (scale0 * from.z) + (scale1 * to.z);
	float newW = (scale0 * from.w) + (scale1 * to.w);
	return normalize(quat(newX, newY, newZ, newW));
}

quat nlerp(quat* qs, float* weights, uint32 count)
{
	vec4 v0 = qs[0].v4;
	vec4 result = v0 * weights[0];

	for (uint32 i = 1; i < count; ++i)
	{
		vec4 v1 = qs[i].v4;
		if (dot(v0, v1) < 0.f) { v1 = -v1; }
		result += v1 * weights[i];
	}

	return { result.f4 };
}

mat3 quaternionToMat3(quat q)
{
	if (q.w == 1.f)
	{
		return mat3::identity;
	}

	float qxx = q.x * q.x;
	float qyy = q.y * q.y;
	float qzz = q.z * q.z;
	float qxz = q.x * q.z;
	float qxy = q.x * q.y;
	float qyz = q.y * q.z;
	float qwx = q.w * q.x;
	float qwy = q.w * q.y;
	float qwz = q.w * q.z;

	mat3 result;

	result.m00 = 1.f - 2.f * (qyy + qzz);
	result.m10 = 2.f * (qxy + qwz);
	result.m20 = 2.f * (qxz - qwy);

	result.m01 = 2.f * (qxy - qwz);
	result.m11 = 1.f - 2.f * (qxx + qzz);
	result.m21 = 2.f * (qyz + qwx);

	result.m02 = 2.f * (qxz + qwy);
	result.m12 = 2.f * (qyz - qwx);
	result.m22 = 1.f - 2.f * (qxx + qyy);

	return result;
}

quat mat3ToQuaternion(const mat3& m)
{
#if 1
	float tr = m.m00 + m.m11 + m.m22;

	quat result;
	if (tr > 0.f)
	{
		float s = sqrtf(tr + 1.f) * 2.f; // S=4*qw 
		result.w = 0.25f * s;
		result.x = (m.m21 - m.m12) / s;
		result.y = (m.m02 - m.m20) / s;
		result.z = (m.m10 - m.m01) / s;
	}
	else if ((m.m00 > m.m11) && (m.m00 > m.m22))
	{
		float s = sqrtf(1.f + m.m00 - m.m11 - m.m22) * 2.f; // S=4*qx 
		result.w = (m.m21 - m.m12) / s;
		result.x = 0.25f * s;
		result.y = (m.m01 + m.m10) / s;
		result.z = (m.m02 + m.m20) / s;
	}
	else if (m.m11 > m.m22)
	{
		float s = sqrtf(1.f + m.m11 - m.m00 - m.m22) * 2.f; // S=4*qy
		result.w = (m.m02 - m.m20) / s;
		result.x = (m.m01 + m.m10) / s;
		result.y = 0.25f * s;
		result.z = (m.m12 + m.m21) / s;
	}
	else
	{
		float s = sqrtf(1.f + m.m22 - m.m00 - m.m11) * 2.f; // S=4*qz
		result.w = (m.m10 - m.m01) / s;
		result.x = (m.m02 + m.m20) / s;
		result.y = (m.m12 + m.m21) / s;
		result.z = 0.25f * s;
	}
#else
	quat result;
	result.w = sqrt(1.f + m.m00 + m.m11 + m.m22) * 0.5f;
	float w4 = 1.f / (4.f * result.w);
	result.x = (m.m21 - m.m12) * w4;
	result.y = (m.m02 - m.m20) * w4;
	result.z = (m.m10 - m.m02) * w4;
#endif
	return normalize(result);
}

vec3 quatToEuler(quat q)
{
	float roll, pitch, yaw;

	// Roll (x-axis rotation).
	float sinr_cosp = 2.f * (q.w * q.x + q.y * q.z);
	float cosr_cosp = 1.f - 2.f * (q.x * q.x + q.y * q.y);
	yaw = atan2(sinr_cosp, cosr_cosp);

	// Pitch (y-axis rotation).
	float sinp = 2.f * (q.w * q.y - q.z * q.x);
	if (abs(sinp) >= 1.f)
	{
		roll = copysign(M_PI / 2, sinp); // Use 90 degrees if out of range.
	}
	else
	{
		roll = asin(sinp);
	}

	// Yaw (z-axis rotation).
	float siny_cosp = 2 * (q.w * q.z + q.x * q.y);
	float cosy_cosp = 1 - 2 * (q.y * q.y + q.z * q.z);
	pitch = atan2(siny_cosp, cosy_cosp);

	return vec3(pitch, yaw, roll);
}

quat eulerToQuat(vec3 euler)
{
	float pitch = euler.x;
	float yaw = euler.y;
	float roll = euler.z;

	// Abbreviations for the various angular functions
	float cy = cos(pitch * 0.5f);
	float sy = sin(pitch * 0.5f);
	float cp = cos(roll * 0.5f);
	float sp = sin(roll * 0.5f);
	float cr = cos(yaw * 0.5f);
	float sr = sin(yaw * 0.5f);

	quat q;
	q.w = cr * cp * cy + sr * sp * sy;
	q.x = sr * cp * cy - cr * sp * sy;
	q.y = cr * sp * cy + sr * cp * sy;
	q.z = cr * cp * sy - sr * sp * cy;

	return q;
}

mat3 outerProduct(vec3 a, vec3 b)
{
	vec3 col0 = a * b.x;
	vec3 col1 = a * b.y;
	vec3 col2 = a * b.z;

	mat3 result;
	result.m00 = col0.x;
	result.m10 = col0.y;
	result.m20 = col0.z;
	result.m01 = col1.x;
	result.m11 = col1.y;
	result.m21 = col1.z;
	result.m02 = col2.x;
	result.m12 = col2.y;
	result.m22 = col2.z;
	return result;
}

mat3 getSkewMatrix(vec3 r)
{
	mat3 result;
	result.m00 = 0.f;
	result.m01 = -r.z;
	result.m02 = r.y;
	result.m10 = r.z;
	result.m11 = 0.f;
	result.m12 = -r.x;
	result.m20 = -r.y;
	result.m21 = r.x;
	result.m22 = 0.f;
	return result;
}

mat4 createPerspectiveProjectionMatrix(float fov, float aspect, float nearPlane, float farPlane)
{
	mat4 result;

	float a = 1.f / tan(0.5f * fov);

	result.m00 = a / aspect;
	result.m01 = 0.f;
	result.m02 = 0.f;
	result.m03 = 0.f;

	result.m10 = 0.f;
	result.m11 = a;
	result.m12 = 0.f;
	result.m13 = 0.f;

	result.m20 = 0.f;
	result.m21 = 0.f;

	if (farPlane > 0.f)
	{
#if DIRECTX_COORDINATE_SYSTEM
		result.m22 = -farPlane / (farPlane - nearPlane);
		result.m23 = result.m22 * nearPlane;
#else
		result.m22 = -(farPlane + nearPlane) / (farPlane - nearPlane);
		result.m23 = -2.f * farPlane * nearPlane / (farPlane - nearPlane);
#endif
	}
	else
	{
		result.m22 = -1.f;
#if DIRECTX_COORDINATE_SYSTEM
		result.m23 = -nearPlane;
#else
		result.m23 = -2.f * nearPlane;
#endif
	}

	result.m30 = 0.f;
	result.m31 = 0.f;
	result.m32 = -1.f;
	result.m33 = 0.f;

	return result;
}

mat4 createPerspectiveProjectionMatrix(float width, float height, float fx, float fy, float cx, float cy, float nearPlane, float farPlane)
{
	mat4 result;

	result.m00 = 2.f * fx / width;
	result.m01 = 0.f;
	result.m02 = 1.f - 2.f * cx / width;
	result.m03 = 0.f;

	result.m10 = 0.f;
	result.m11 = 2.f * fy / height;
	result.m12 = 2.f * cy / height - 1.f;
	result.m13 = 0.f;

	result.m20 = 0.f;
	result.m21 = 0.f;

	if (farPlane > 0.f)
	{
#if DIRECTX_COORDINATE_SYSTEM
		result.m22 = -farPlane / (farPlane - nearPlane);
		result.m23 = result.m22 * nearPlane;
#else
		result.m22 = -(farPlane + nearPlane) / (farPlane - nearPlane);
		result.m23 = -2.f * farPlane * nearPlane / (farPlane - nearPlane);
#endif
	}
	else
	{
		result.m22 = -1.f;
#if DIRECTX_COORDINATE_SYSTEM
		result.m23 = -nearPlane;
#else
		result.m23 = -2.f * nearPlane;
#endif
	}

	result.m30 = 0.f;
	result.m31 = 0.f;
	result.m32 = -1.f;
	result.m33 = 0.f;

	return result;
}

mat4 createPerspectiveProjectionMatrix(float r, float l, float t, float b, float nearPlane, float farPlane)
{
	mat4 result;

	result.m00 = (2.f * nearPlane) / (r - l);
	result.m01 = 0.f; 
	result.m02 = (r + l) / (r - l);
	result.m03 = 0.f;

	result.m10 = 0.f; 
	result.m11 = (2.f * nearPlane) / (t - b);
	result.m12 = (t + b) / (t - b);
	result.m13 = 0.f;

	result.m20 = 0; 
	result.m21 = 0;

	if (farPlane > 0.f)
	{
#if DIRECTX_COORDINATE_SYSTEM
		result.m22 = -farPlane / (farPlane - nearPlane);
		result.m23 = result.m22 * nearPlane;
#else
		result.m22 = -(farPlane + nearPlane) / (farPlane - nearPlane);
		result.m23 = -2.f * farPlane * nearPlane / (farPlane - nearPlane);
#endif
	}
	else
	{
		result.m22 = -1.f;
#if DIRECTX_COORDINATE_SYSTEM
		result.m23 = -nearPlane;
#else
		result.m23 = -2.f * nearPlane;
#endif
	}

	result.m30 = 0.f; 
	result.m31 = 0.f; 
	result.m32 = -1.f; 
	result.m33 = 0.f;

	return result;
}

mat4 createOrthographicProjectionMatrix(float r, float l, float t, float b, float nearPlane, float farPlane)
{
	mat4 result;

	result.m00 = 2.f / (r - l);
	result.m01 = 0.f;
	result.m02 = 0.f;
	result.m03 = -(r + l) / (r - l);

	result.m10 = 0.f;
	result.m11 = 2.f / (t - b);
	result.m12 = 0.f;
	result.m13 = -(t + b) / (t - b);

	result.m20 = 0.f;
	result.m21 = 0.f;

#if DIRECTX_COORDINATE_SYSTEM
	result.m22 = -1.f / (farPlane - nearPlane);
	result.m23 = result.m22 * nearPlane;
#else
	result.m22 = -2.f / (farPlane - nearPlane);
	result.m23 = -(farPlane + nearPlane) / (farPlane - nearPlane);
#endif

	result.m30 = 0.f;
	result.m31 = 0.f;
	result.m32 = 0.f;
	result.m33 = 1.f;

	return result;
}

mat4 invertPerspectiveProjectionMatrix(const mat4& m)
{
	mat4 inv;
	
	inv.m00 = 1.f / m.m00;
	inv.m01 = 0.f;
	inv.m02 = 0.f;
	inv.m03 = m.m02 / m.m00;

	inv.m10 = 0.f;
	inv.m11 = 1.f / m.m11;
	inv.m12 = 0.f;
	inv.m13 = m.m12 / m.m11;

	inv.m20 = 0.f;
	inv.m21 = 0.f;
	inv.m22 = 0.f;
	inv.m23 = -1.f;

	inv.m30 = 0.f;
	inv.m31 = 0.f;
	inv.m32 = 1.f / m.m23;
	inv.m33 = m.m22 / m.m23;

	return inv;
}

mat4 invertOrthographicProjectionMatrix(const mat4& m)
{
	mat4 inv;

	inv.m00 = 1.f / m.m00;
	inv.m01 = 0.f;
	inv.m02 = 0.f;
	inv.m03 = -m.m03 / m.m00;

	inv.m10 = 0.f;
	inv.m11 = 1.f / m.m11;
	inv.m12 = 0.f;
	inv.m13 = -m.m13 / m.m11;

	inv.m20 = 0.f;
	inv.m21 = 0.f;
	inv.m22 = 1.f / m.m22;
	inv.m23 = -m.m23 / m.m22;

	inv.m30 = 0.f;
	inv.m31 = 0.f;
	inv.m32 = 0.f;
	inv.m33 = 1.f;

	return inv;
}

mat4 createTranslationMatrix(vec3 position)
{
	mat4 result = mat4::identity;
	result.m03 = position.x;
	result.m13 = position.y;
	result.m23 = position.z;
	return result;
}

mat4 createModelMatrix(vec3 position, quat rotation, vec3 scale)
{
	mat4 result;
#if 0
	result.m03 = position.x;
	result.m13 = position.y;
	result.m23 = position.z;
	mat3 rot = quaternionToMat3(rotation);
	result.m00 = rot.m00 * scale.x;
	result.m01 = rot.m01 * scale.y;
	result.m02 = rot.m02 * scale.z;
	result.m10 = rot.m10 * scale.x;
	result.m11 = rot.m11 * scale.y;
	result.m12 = rot.m12 * scale.z;
	result.m20 = rot.m20 * scale.x;
	result.m21 = rot.m21 * scale.y;
	result.m22 = rot.m22 * scale.z;
	result.m30 = result.m31 = result.m32 = 0.f;
	result.m33 = 1.f;
#else
	result.m03 = position.x;
	result.m13 = position.y;
	result.m23 = position.z;

	const float x2 = rotation.x + rotation.x;
	const float y2 = rotation.y + rotation.y;
	const float z2 = rotation.z + rotation.z;
	{
		const float xx2 = rotation.x * x2;
		const float yy2 = rotation.y * y2;
		const float zz2 = rotation.z * z2;

		result.m00 = (1.f - (yy2 + zz2)) * scale.x;
		result.m11 = (1.f - (xx2 + zz2)) * scale.y;
		result.m22 = (1.f - (xx2 + yy2)) * scale.z;
	}
	{
		const float yz2 = rotation.y * z2;
		const float wx2 = rotation.w * x2;

		result.m12 = (yz2 - wx2) * scale.z;
		result.m21 = (yz2 + wx2) * scale.y;
	}
	{
		const float xy2 = rotation.x * y2;
		const float wz2 = rotation.w * z2;

		result.m01 = (xy2 - wz2) * scale.y;
		result.m10 = (xy2 + wz2) * scale.x;
	}
	{
		const float xz2 = rotation.x * z2;
		const float wy2 = rotation.w * y2;

		result.m02 = (xz2 + wy2) * scale.z;
		result.m20 = (xz2 - wy2) * scale.x;
	}

	result.m30 = 0.f;
	result.m31 = 0.f;
	result.m32 = 0.f;
	result.m33 = 1.f;
#endif
	return result;
}

mat4 createBillboardModelMatrix(vec3 position, vec3 eye, vec3 scale)
{
	vec3 up(0.f, 1.f, 0.f);
	vec3 forward = normalize(eye - position);
	vec3 right = normalize(cross(up, forward));
	up = cross(forward, right);

	right *= scale.x;
	up *= scale.y;
	forward *= scale.z;

	mat4 result;

	result.m00 = right.x;
	result.m10 = right.y;
	result.m20 = right.z;
	result.m30 = 0.f;

	result.m01 = up.x;
	result.m11 = up.y;
	result.m21 = up.z;
	result.m31 = 0.f;

	result.m02 = forward.x;
	result.m12 = forward.y;
	result.m22 = forward.z;
	result.m32 = 0.f;

	result.m03 = position.x;
	result.m13 = position.y;
	result.m23 = position.z;
	result.m33 = 1.f;

	return result;

}

mat4 trsToMat4(const trs& transform)
{
	return createModelMatrix(transform.position, transform.rotation, transform.scale);
}

trs mat4ToTRS(const mat4& m)
{
	trs result;

	vec3 c0(m.m00, m.m10, m.m20);
	vec3 c1(m.m01, m.m11, m.m21);
	vec3 c2(m.m02, m.m12, m.m22);
	result.scale.x = sqrt(dot(c0, c0));
	result.scale.y = sqrt(dot(c1, c1));
	result.scale.z = sqrt(dot(c2, c2));


	vec3 invScale = 1.f / result.scale;

	result.position.x = m.m03;
	result.position.y = m.m13;
	result.position.z = m.m23;

	mat3 R;

	R.m00 = m.m00 * invScale.x;
	R.m10 = m.m10 * invScale.x;
	R.m20 = m.m20 * invScale.x;

	R.m01 = m.m01 * invScale.y;
	R.m11 = m.m11 * invScale.y;
	R.m21 = m.m21 * invScale.y;

	R.m02 = m.m02 * invScale.z;
	R.m12 = m.m12 * invScale.z;
	R.m22 = m.m22 * invScale.z;

	result.rotation = mat3ToQuaternion(R);

	return result;
}

mat4 createViewMatrix(vec3 eye, float pitch, float yaw)
{
	float cosPitch = cosf(pitch);
	float sinPitch = sinf(pitch);
	float cosYaw = cosf(yaw);
	float sinYaw = sinf(yaw);

	vec3 xAxis(cosYaw, 0, -sinYaw);
	vec3 yAxis(sinYaw * sinPitch, cosPitch, cosYaw * sinPitch);
	vec3 zAxis(sinYaw * cosPitch, -sinPitch, cosPitch * cosYaw);

	mat4 result;
	result.m00 = xAxis.x; result.m10 = yAxis.x; result.m20 = zAxis.x; result.m30 = 0.f;
	result.m01 = xAxis.y; result.m11 = yAxis.y; result.m21 = zAxis.y; result.m31 = 0.f;
	result.m02 = xAxis.z; result.m12 = yAxis.z; result.m22 = zAxis.z; result.m32 = 0.f;
	result.m03 = -dot(xAxis, eye); result.m13 = -dot(yAxis, eye); result.m23 = -dot(zAxis, eye); result.m33 = 1.f;

	return result;
}

mat4 createSkyViewMatrix(const mat4& v)
{
	mat4 result = v;
	result.m03 = 0.f; result.m13 = 0.f; result.m23 = 0.f;
	return result;
}

mat4 lookAt(vec3 eye, vec3 target, vec3 up)
{
	vec3 zAxis = normalize(eye - target);
	vec3 xAxis = normalize(cross(up, zAxis));
	vec3 yAxis = normalize(cross(zAxis, xAxis));

	mat4 result;
	result.m00 = xAxis.x; result.m10 = yAxis.x; result.m20 = zAxis.x; result.m30 = 0.f;
	result.m01 = xAxis.y; result.m11 = yAxis.y; result.m21 = zAxis.y; result.m31 = 0.f;
	result.m02 = xAxis.z; result.m12 = yAxis.z; result.m22 = zAxis.z; result.m32 = 0.f;
	result.m03 = -dot(xAxis, eye); result.m13 = -dot(yAxis, eye); result.m23 = -dot(zAxis, eye); result.m33 = 1.f;

	return result;
}

quat lookAtQuaternion(vec3 forward, vec3 up)
{
	vec3 zAxis = -normalize(forward);
	vec3 xAxis = normalize(cross(up, zAxis));
	vec3 yAxis = normalize(cross(zAxis, xAxis));

	mat3 m;
	m.m00 = xAxis.x; m.m01 = yAxis.x; m.m02 = zAxis.x;
	m.m10 = xAxis.y; m.m11 = yAxis.y; m.m12 = zAxis.y;
	m.m20 = xAxis.z; m.m21 = yAxis.z; m.m22 = zAxis.z;

	return mat3ToQuaternion(m);
}

mat4 createViewMatrix(vec3 position, quat rotation)
{
	vec3 target = position + rotation * vec3(0.f, 0.f, -1.f);
	vec3 up = rotation * vec3(0.f, 1.f, 0.f);
	return lookAt(position, target, up);
}

mat4 invertAffine(const mat4& m)
{
	vec3 xAxis(m.m00, m.m10, m.m20);
	vec3 yAxis(m.m01, m.m11, m.m21);
	vec3 zAxis(m.m02, m.m12, m.m22);
	vec3 pos(m.m03, m.m13, m.m23);

	vec3 invXAxis = xAxis / squaredLength(xAxis);
	vec3 invYAxis = yAxis / squaredLength(yAxis);
	vec3 invZAxis = zAxis / squaredLength(zAxis);
	vec3 invPos(-dot(invXAxis, pos), -dot(invYAxis, pos), -dot(invZAxis, pos));

	mat4 result;
	result.m00 = invXAxis.x; result.m10 = invYAxis.x; result.m20 = invZAxis.x; result.m30 = 0.f;
	result.m01 = invXAxis.y; result.m11 = invYAxis.y; result.m21 = invZAxis.y; result.m31 = 0.f;
	result.m02 = invXAxis.z; result.m12 = invYAxis.z; result.m22 = invZAxis.z; result.m32 = 0.f;
	result.m03 = invPos.x; result.m13 = invPos.y; result.m23 = invPos.z; result.m33 = 1.f;
	return result;
}

bool pointInTriangle(vec3 point, vec3 triA, vec3 triB, vec3& triC)
{
	vec3 e10 = triB - triA;
	vec3 e20 = triC - triA;
	float a = dot(e10, e10);
	float b = dot(e10, e20);
	float c = dot(e20, e20);
	float ac_bb = (a * c) - (b * b);
	vec3 vp = point - triA;
	float d = dot(vp, e10);
	float e = dot(vp, e20);
	float x = (d * c) - (e * b);
	float y = (e * a) - (d * b);
	float z = x + y - ac_bb;
#define uintCast(a) ((uint32&) a)
	return ((uintCast(z) & ~(uintCast(x) | uintCast(y))) & 0x80000000) != 0;
#undef uintCast
}

bool pointInRectangle(vec2 p, vec2 topLeft, vec2 bottomRight)
{
	return p.x >= topLeft.x && p.y >= topLeft.y && p.x <= bottomRight.x && p.y <= bottomRight.y;
}

bool pointInBox(vec3 p, vec3 minCorner, vec3 maxCorner)
{
	return p.x >= minCorner.x && p.y >= minCorner.y && p.z >= minCorner.z && p.x <= maxCorner.x && p.y <= maxCorner.y && p.z <= maxCorner.z;
}

vec2 directionToPanoramaUV(vec3 dir)
{
	const vec2 invAtan = vec2(INV_TAU, INV_PI);

	vec2 panoUV = vec2(atan2(-dir.x, -dir.z), acos(dir.y)) * invAtan;

	while (panoUV.x < 0.f) { panoUV.x += 1.f; }
	while (panoUV.y < 0.f) { panoUV.y += 1.f; }
	while (panoUV.x > 1.f) { panoUV.x -= 1.f; }
	while (panoUV.y > 1.f) { panoUV.y -= 1.f; }

	return panoUV;
}

float angleToZeroToTwoPi(float angle)
{
	while (angle < 0)
	{
		angle += M_TAU;
	}
	while (angle > M_TAU)
	{
		angle -= M_TAU;
	}
	return angle;
}

float angleToNegPiToPi(float angle)
{
	while (angle < -M_PI)
	{
		angle += M_TAU;
	}
	while (angle > M_PI)
	{
		angle -= M_TAU;
	}
	return angle;
}

vec2 solveLinearSystem(const mat2& A, vec2 b)
{
	float a11 = A.m00, a12 = A.m01, a21 = A.m10, a22 = A.m11;
	float det = a11 * a22 - a12 * a21;
	if (det != 0.f)
	{
		det = 1.f / det;
	}
	vec2 x;
	x.x = det * (a22 * b.x - a12 * b.y);
	x.y = det * (a11 * b.y - a21 * b.x);
	return x;
}

vec3 solveLinearSystem(const mat3& A, vec3 b)
{
	vec3 ex(A.m00, A.m10, A.m20);
	vec3 ey(A.m01, A.m11, A.m21);
	vec3 ez(A.m02, A.m12, A.m22);
	float det = dot(ex, cross(ey, ez));
	if (det != 0.f)
	{
		det = 1.f / det;
	}
	vec3 x;
	x.x = det * dot(b, cross(ey, ez));
	x.y = det * dot(ex, cross(b, ez));
	x.z = det * dot(ex, cross(ey, b));
	return x;
}

vec3 getBarycentricCoordinates(vec2 a, vec2 b, vec2 c, vec2 p)
{
	vec2 v0 = b - a, v1 = c - a, v2 = p - a;
	float d00 = dot(v0, v0);
	float d01 = dot(v0, v1);
	float d11 = dot(v1, v1);
	float d20 = dot(v2, v0);
	float d21 = dot(v2, v1);
	float denom = d00 * d11 - d01 * d01;

	float v = (d11 * d20 - d01 * d21) / denom;
	float w = (d00 * d21 - d01 * d20) / denom;
	float u = 1.0f - v - w;

	return vec3(u, v, w);
}

vec3 getBarycentricCoordinates(vec3 a, vec3 b, vec3 c, vec3 p)
{
	vec3 v0 = b - a, v1 = c - a, v2 = p - a;
	float d00 = dot(v0, v0);
	float d01 = dot(v0, v1);
	float d11 = dot(v1, v1);
	float d20 = dot(v2, v0);
	float d21 = dot(v2, v1);
	float denom = d00 * d11 - d01 * d01;

	denom = (abs(denom) < EPSILON) ? 1.f : denom;

	float v = (d11 * d20 - d01 * d21) / denom;
	float w = (d00 * d21 - d01 * d20) / denom;
	float u = 1.0f - v - w;

	return vec3(u, v, w);
}

bool insideTriangle(vec3 barycentrics)
{
	return barycentrics.x >= 0.f
		&& barycentrics.y >= 0.f
		&& barycentrics.z >= 0.f;
}

vec3 getTangent(vec3 normal)
{
	vec3 tangent = (abs(normal.x) >= 0.57735f) ? vec3(normal.y, -normal.x, 0.f) : vec3(0.f, normal.z, -normal.y);
	return normalize(tangent);
}

void getTangents(vec3 normal, vec3& outTangent, vec3& outBitangent)
{
	outTangent = getTangent(normal);
	outBitangent = cross(normal, outTangent);
}

vec4 uniformSampleSphere(vec2 E)
{
	float phi = 2 * M_PI * E.x;
	float cosTheta = 1.f - 2.f * E.y;
	float sinTheta = sqrt(1.f - cosTheta * cosTheta);

	vec3 H;
	H.x = sinTheta * cos(phi);
	H.y = sinTheta * sin(phi);
	H.z = cosTheta;

	float PDF = 1.f / (4.f * M_PI);

	return vec4(H, PDF);
}



#define _gamma 5.828427124f // FOUR_GAMMA_SQUARED = sqrt(8)+3;
#define _cstar 0.923879532f // cos(pi/8)
#define _sstar 0.3826834323f // sin(p/8)

static void condSwap(bool c, float& X, float& Y)
{
	float Z = X;
	X = c ? Y : X;
	Y = c ? Z : Y;
}

static void condNegSwap(bool c, float& X, float& Y)
{
	float Z = -X;
	X = c ? Y : X;
	Y = c ? Z : Y;
}

static void approximateGivensQuaternion(float a11, float a12, float a22, float& ch, float& sh)
{
	// Given givens angle computed by approximateGivensAngles,
	// compute the corresponding rotation quaternion.
	ch = 2 * (a11 - a22);
	sh = a12;
	bool b = _gamma * sh * sh < ch* ch;
	float w = 1.f / sqrt(ch * ch + sh * sh);
	ch = b ? w * ch : _cstar;
	sh = b ? w * sh : _sstar;
}

static void QRGivensQuaternion(float a1, float a2, float& ch, float& sh)
{
	// a1 = pivot point on diagonal
	// a2 = lower triangular entry we want to annihilate
	float rho = sqrt(a1 * a1 + a2 * a2);

	sh = rho > EPSILON ? a2 : 0.f;
	ch = fabs(a1) + fmax(rho, EPSILON);
	bool b = a1 < 0;
	condSwap(b, sh, ch);
	float w = 1.f / sqrt(ch * ch + sh * sh);
	ch *= w;
	sh *= w;
}

static void jacobiConjugation(const int x, const int y, const int z,
	float& s11,
	float& s21, float& s22,
	float& s31, float& s32, float& s33,
	quat& q)
{
	float ch, sh;
	approximateGivensQuaternion(s11, s21, s22, ch, sh);

	float scale = ch * ch + sh * sh;
	float a = (ch * ch - sh * sh) / scale;
	float b = (2 * sh * ch) / scale;

	// make temp copy of S
	float _s11 = s11;
	float _s21 = s21; float _s22 = s22;
	float _s31 = s31; float _s32 = s32; float _s33 = s33;

	// perform conjugation S = Q'*S*Q
	// Q already implicitly solved from a, b
	s11 = a * (a * _s11 + b * _s21) + b * (a * _s21 + b * _s22);
	s21 = a * (-b * _s11 + a * _s21) + b * (-b * _s21 + a * _s22);	s22 = -b * (-b * _s11 + a * _s21) + a * (-b * _s21 + a * _s22);
	s31 = a * _s31 + b * _s32;								s32 = -b * _s31 + a * _s32; s33 = _s33;

	// update cumulative rotation qV
	float tmp[3];
	tmp[0] = q.x * sh;
	tmp[1] = q.y * sh;
	tmp[2] = q.z * sh;
	sh *= q.w;

	q.x *= ch;
	q.y *= ch;
	q.z *= ch;
	q.w *= ch;

	// (x,y,z) corresponds to ((0,1,2),(1,2,0),(2,0,1))
	// for (p,q) = ((0,1),(1,2),(0,2))
	q.v4.data[z] += sh;
	q.v4.w -= tmp[z]; // w
	q.v4.data[x] += tmp[y];
	q.v4.data[y] -= tmp[x];

	// re-arrange matrix for next iteration
	_s11 = s22;
	_s21 = s32; _s22 = s33;
	_s31 = s21; _s32 = s31; _s33 = s11;
	s11 = _s11;
	s21 = _s21; s22 = _s22;
	s31 = _s31; s32 = _s32; s33 = _s33;
}

static void jacobiEigenanlysis(
	float& s11,
	float& s21, float& s22,
	float& s31, float& s32, float& s33,
	// quaternion representation of V
	quat& q)
{
	q = quat::identity;
	for (int i = 0; i < 4; ++i)
	{
		// We wish to eliminate the maximum off-diagonal element
		// on every iteration, but cycling over all 3 possible rotations
		// in fixed order (p,q) = (1,2) , (2,3), (1,3) still retains
		//  asymptotic convergence.
		jacobiConjugation(0, 1, 2, s11, s21, s22, s31, s32, s33, q); // p,q = 0,1
		jacobiConjugation(1, 2, 0, s11, s21, s22, s31, s32, s33, q); // p,q = 1,2
		jacobiConjugation(2, 0, 1, s11, s21, s22, s31, s32, s33, q); // p,q = 0,2
	}
}

static float dist2(float x, float y, float z)
{
	return x * x + y * y + z * z;
}

static void sortSingularValues(mat3& B, mat3& V)
{
	float* Bm = B.m;
	float* Vm = V.m;
	float rho1 = dist2(Bm[0], Bm[1], Bm[2]);
	float rho2 = dist2(Bm[3], Bm[4], Bm[5]);
	float rho3 = dist2(Bm[6], Bm[7], Bm[8]);

	bool c = rho1 < rho2;
	condNegSwap(c, Bm[0], Bm[3]); condNegSwap(c, Vm[0], Vm[3]);
	condNegSwap(c, Bm[1], Bm[4]); condNegSwap(c, Vm[1], Vm[4]);
	condNegSwap(c, Bm[2], Bm[5]); condNegSwap(c, Vm[2], Vm[5]);
	condSwap(c, rho1, rho2);
	c = rho1 < rho3;
	condNegSwap(c, Bm[0], Bm[6]); condNegSwap(c, Vm[0], Vm[6]);
	condNegSwap(c, Bm[1], Bm[7]); condNegSwap(c, Vm[1], Vm[7]);
	condNegSwap(c, Bm[2], Bm[8]); condNegSwap(c, Vm[2], Vm[8]);
	condSwap(c, rho1, rho3);
	c = rho2 < rho3;
	condNegSwap(c, Bm[3], Bm[6]); condNegSwap(c, Vm[3], Vm[6]);
	condNegSwap(c, Bm[4], Bm[7]); condNegSwap(c, Vm[4], Vm[7]);
	condNegSwap(c, Bm[5], Bm[8]); condNegSwap(c, Vm[5], Vm[8]);
}

static void QRDecomposition(mat3& B, mat3& Q, mat3& R)
{
	float ch1, sh1, ch2, sh2, ch3, sh3;
	float a, b;

	// first givens rotation (ch,0,0,sh)
	QRGivensQuaternion(B.m00, B.m10, ch1, sh1);
	a = 1 - 2 * sh1 * sh1;
	b = 2 * ch1 * sh1;

	// Apply B = Q' * B.
	float* Rm = R.m;
	float* Bm = B.m;
	Rm[0] = a * Bm[0] + b * Bm[1];  Rm[3] = a * Bm[3] + b * Bm[4];  Rm[6] = a * Bm[6] + b * Bm[7];
	Rm[1] = -b * Bm[0] + a * Bm[1]; Rm[4] = -b * Bm[3] + a * Bm[4]; Rm[7] = -b * Bm[6] + a * Bm[7];
	Rm[2] = Bm[2];          Rm[5] = Bm[5];          Rm[8] = Bm[8];

	// Second givens rotation (ch,0,-sh,0).
	QRGivensQuaternion(Rm[0], Rm[2], ch2, sh2);
	a = 1 - 2 * sh2 * sh2;
	b = 2 * ch2 * sh2;

	// Apply B = Q' * B.
	Bm[0] = a * Rm[0] + b * Rm[2];  Bm[3] = a * Rm[3] + b * Rm[5];  Bm[6] = a * Rm[6] + b * Rm[8];
	Bm[1] = Rm[1];           Bm[4] = Rm[4];           Bm[7] = Rm[7];
	Bm[2] = -b * Rm[0] + a * Rm[2]; Bm[5] = -b * Rm[3] + a * Rm[5]; Bm[8] = -b * Rm[6] + a * Rm[8];

	// Third givens rotation (ch,sh,0,0).
	QRGivensQuaternion(Bm[4], Bm[5], ch3, sh3);
	a = 1 - 2 * sh3 * sh3;
	b = 2 * ch3 * sh3;
	// R is now set to desired value.
	Rm[0] = Bm[0];             Rm[3] = Bm[3];           Rm[6] = Bm[6];
	Rm[1] = a * Bm[1] + b * Bm[2];     Rm[4] = a * Bm[4] + b * Bm[5];   Rm[7] = a * Bm[7] + b * Bm[8];
	Rm[2] = -b * Bm[1] + a * Bm[2];    Rm[5] = -b * Bm[4] + a * Bm[5];  Rm[8] = -b * Bm[7] + a * Bm[8];

	// Construct the cumulative rotation Q=Q1 * Q2 * Q3.
	// The number of floating point operations for three quaternion multiplications
	// is more or less comparable to the explicit form of the joined matrix.
	// Certainly more memory-efficient!
	float sh12 = sh1 * sh1;
	float sh22 = sh2 * sh2;
	float sh32 = sh3 * sh3;

	float* Qm = Q.m;
	Qm[0] = (-1 + 2 * sh12) * (-1 + 2 * sh22);
	Qm[3] = 4 * ch2 * ch3 * (-1 + 2 * sh12) * sh2 * sh3 + 2 * ch1 * sh1 * (-1 + 2 * sh32);
	Qm[6] = 4 * ch1 * ch3 * sh1 * sh3 - 2 * ch2 * (-1 + 2 * sh12) * sh2 * (-1 + 2 * sh32);

	Qm[1] = 2 * ch1 * sh1 * (1 - 2 * sh22);
	Qm[4] = -8 * ch1 * ch2 * ch3 * sh1 * sh2 * sh3 + (-1 + 2 * sh12) * (-1 + 2 * sh32);
	Qm[7] = -2 * ch3 * sh3 + 4 * sh1 * (ch3 * sh1 * sh3 + ch1 * ch2 * sh2 * (-1 + 2 * sh32));

	Qm[2] = 2 * ch2 * sh2;
	Qm[5] = 2 * ch3 * (1 - 2 * sh22) * sh3;
	Qm[8] = (-1 + 2 * sh22) * (-1 + 2 * sh32);
}

singular_value_decomposition computeSVD(const mat3& A)
{
	mat3 ATA = transpose(A) * A;

	mat3 U, V;

	quat q;
	jacobiEigenanlysis(ATA.m00, ATA.m10, ATA.m11, ATA.m20, ATA.m21, ATA.m22, q);
	V = quaternionToMat3(q);

	mat3 B = A * V;

	sortSingularValues(B, V);
	mat3 S;
	QRDecomposition(B, U, S);

	return { U, V, vec3(S.m00, S.m11, S.m22) };
}









static void computeMinor(mat3& m, const mat3& from, uint32 d)
{
	for (uint32 y = 0; y < 3; ++y)
	{
		for (uint32 x = 0; x < 3; ++x)
		{
			if (x < d || y < d)
			{
				m.m[y * 3 + x] = (x == y) ? 1.f : 0.f;
			}
			else
			{
				m.m[y * 3 + x] = from.m[y * 3 + x];
			}
		}
	}
}

static void computeHouseholderFactor(mat3& mat, const vec3& v)
{
	for (uint32 i = 0; i < 3; ++i)
	{
		for (uint32 j = 0; j < 3; ++j)
		{
			mat.m[i * 3 + j] = -2.f * v.data[i] * v.data[j];
		}
	}
	for (uint32 i = 0; i < 3; ++i)
	{
		mat.m[i * 3 + i] += 1.f;
	}
}

qr_decomposition qrDecomposition(const mat3& mat)
{
	mat3 qv[2];

	// Temp array.
	mat3 z = mat;
	mat3 z1;

	for (uint32 k = 0; k < 2; ++k)
	{
		computeMinor(z1, z, k);
		vec3 x = col(z1, k);

		float a = length(x);
		if (mat.m[k * 3 + k] > 0.f)
		{
			a = -a;
		}

		vec3 e;
		for (uint32 i = 0; i < 3; ++i)
		{
			e.data[i] = (i == k) ? 1.f : 0.f;
		}

		e = x + a * e;
		e = normalize(e);

		// qv[k] = I - 2 *e*e^T
		computeHouseholderFactor(qv[k], e);

		z = qv[k] * z1;

	}

	qr_decomposition result;
	result.Q = qv[0];

	// After this loop, we will obtain Q (up to a transpose operation)
	for (uint32 i = 1; i < 2; ++i)
	{
		z1 = qv[i] * result.Q;
		result.Q = z1;
	}

	result.R = result.Q * mat;
	result.Q = transpose(result.Q);

	return result;
}

bool getEigen(const mat3& A, vec3& outEigenValues, mat3& outEigenVectors)
{
	mat3 Q = qrDecomposition(A).Q;
	mat3 Qt = transpose(Q);

	mat3 tmp = Qt * A;
	mat3 E = tmp * Q;

	mat3 U = Q;

	vec3 res = diagonal(E);
	vec3 init = diagonal(A);

	vec3 error = init - res;
	double e = dot(error, error);

	while (e > 0.001f)
	{
		init = res;

		mat3 Q = qrDecomposition(E).Q;
		mat3 Qt = transpose(Q);

		tmp = Qt * E;
		E = tmp * Q;

		tmp = U * Q;
		U = tmp;

		res = diagonal(E);
		vec3 error = init - res;
		e = dot(error, error);
	}

	outEigenValues = res;
	outEigenVectors = U;

	return true;
}




```

`src/core/math.h`:

```h
#pragma once


#define ROW_MAJOR 0
#define DIRECTX_COORDINATE_SYSTEM 1


#include <cmath>
#include <cfloat>

#include "simd.h"

#define M_PI 3.14159265359f
#define M_PI_OVER_2 (M_PI * 0.5f)
#define M_PI_OVER_180 (M_PI / 180.f)
#define M_180_OVER_PI (180.f / M_PI)
#define SQRT_PI	1.77245385090f
#define INV_PI 0.31830988618379f
#define M_TAU 6.28318530718f
#define INV_TAU 0.159154943091895335f

#define EPSILON 1e-6f

#define deg2rad(deg) ((deg) * M_PI_OVER_180)
#define rad2deg(rad) ((rad) * M_180_OVER_PI)

static constexpr float lerp(float l, float u, float t) { return l + t * (u - l); }
static constexpr float inverseLerp(float l, float u, float v) { return (v - l) / (u - l); }
static constexpr float remap(float v, float oldL, float oldU, float newL, float newU) { return lerp(newL, newU, inverseLerp(oldL, oldU, v)); }
static constexpr float clamp(float v, float l, float u) { float r = max(l, v); r = min(u, r); return r; }
static constexpr uint32 clamp(uint32 v, uint32 l, uint32 u) { uint32 r = max(l, v); r = min(u, r); return r; }
static constexpr int32 clamp(int32 v, int32 l, int32 u) { int32 r = max(l, v); r = min(u, r); return r; }
static constexpr float clamp01(float v) { return clamp(v, 0.f, 1.f); }
static constexpr float saturate(float v) { return clamp01(v); }
static constexpr float smoothstep(float t) { return t * t * (3.f - 2.f * t); }
static constexpr float smoothstep(float l, float u, float v) { return smoothstep(clamp01(inverseLerp(l, u, v))); }
static constexpr uint32 bucketize(uint32 problemSize, uint32 bucketSize) { return (problemSize + bucketSize - 1) / bucketSize; }
static constexpr uint64 bucketize(uint64 problemSize, uint64 bucketSize) { return (problemSize + bucketSize - 1) / bucketSize; }

static float frac(float v) { return fmodf(v, 1.f); }
static void copySign(float from, float& to) { to = copysign(to, from); }

static void flushDenormalsToZero() { _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON); }

// Constexpr-version of _BitScanForward. Returns -1 if mask is zero.
static constexpr uint32 indexOfLeastSignificantSetBit(uint32 i)
{
	if (i == 0)
	{
		return (uint32)-1;
	}

	uint32 count = 0;

	while ((i & 1) == 0)
	{
		i >>= 1;
		++count;
	}
	return count;
}

// Constexpr-version of _BitScanReverse. Returns -1 if mask is zero.
static constexpr uint32 indexOfMostSignificantSetBit(uint32 i)
{
	if (i == 0)
	{
		return (uint32)-1;
	}

	uint32 count = 0;

	while (i != 1)
	{
		i >>= 1;
		++count;
	}
	return count;
}

static constexpr int32 log2(int32 i)
{
	ASSERT(i >= 0);

	uint32 mssb = indexOfMostSignificantSetBit((uint32)i);
	uint32 lssb = indexOfLeastSignificantSetBit((uint32)i);

	if (mssb == (uint32)-1 || lssb == (uint32)-1)
	{
		return 0;
	}

	// If perfect power of two (only one set bit), return index of bit.  Otherwise round up
	// fractional log by adding 1 to most signicant set bit's index.
	return (int32)mssb + (mssb == lssb ? 0 : 1);
}

static constexpr uint32 log2(uint32 i) 
{ 
	uint32 mssb = indexOfMostSignificantSetBit(i);
	uint32 lssb = indexOfLeastSignificantSetBit(i);

	if (mssb == (uint32)-1 || lssb == (uint32)-1)
	{
		return 0;
	}

	// If perfect power of two (only one set bit), return index of bit.  Otherwise round up
	// fractional log by adding 1 to most signicant set bit's index.
	return mssb + (mssb == lssb ? 0 : 1);
}

static constexpr bool isPowerOfTwo(uint32 i)
{
	return (i & (i - 1)) == 0;
}

static constexpr uint32 alignToPowerOfTwo(uint32 i)
{
	return i == 0u ? 0u : 1u << log2(i);
}

static float easeInQuadratic(float t)		{ return t * t; }
static float easeOutQuadratic(float t)		{ return t * (2.f - t); }
static float easeInOutQuadratic(float t)	{ return (t < 0.5f) ? (2.f * t * t) : (-1.f + (4.f - 2.f * t) * t); }

static float easeInCubic(float t)			{ return t * t * t; }
static float easeOutCubic(float t)			{ float tmin1 = t - 1.f; return tmin1 * tmin1 * tmin1 + 1.f; }
static float easeInOutCubic(float t)		{ return (t < 0.5f) ? (4.f * t * t * t) : ((t - 1.f) * (2.f * t - 2.f) * (2.f * t - 2.f) + 1.f); }

static float easeInQuartic(float t)			{ return t * t * t * t; }
static float easeOutQuartic(float t)		{ float tmin1 = t - 1.f; return 1.f - tmin1 * tmin1 * tmin1 * tmin1; }
static float easeInOutQuartic(float t)		{ float tmin1 = t - 1.f; return (t < 0.5f) ? (8.f * t * t * t * t) : (1.f - 8.f * tmin1 * tmin1 * tmin1 * tmin1); }

static float easeInQuintic(float t)			{ return t * t * t * t * t; }
static float easeOutQuintic(float t)		{ float tmin1 = t - 1.f; return 1.f + tmin1 * tmin1 * tmin1 * tmin1 * tmin1; }
static float easeInOutQuintic(float t)		{ float tmin1 = t - 1.f; return t < 0.5 ? 16.f * t * t * t * t * t : 1.f + 16.f * tmin1 * tmin1 * tmin1 * tmin1 * tmin1; }

static float easeInSine(float t)			{ return sin((t - 1.f) * M_PI_OVER_2) + 1.f; }
static float easeOutSine(float t)			{ return sin(t * M_PI_OVER_2); }
static float easeInOutSine(float t)			{ return 0.5f * (1 - cos(t * M_PI)); }

static float easeInCircular(float t)		{ return 1.f - sqrt(1.f - (t * t)); }
static float easeOutCircular(float t)		{ return sqrt((2.f - t) * t); }
static float easeInOutCircular(float t)		{ return (t < 0.5f) ? (0.5f * (1.f - sqrt(1.f - 4.f * (t * t)))) : (0.5f * (sqrt(-((2.f * t) - 3.f) * ((2.f * t) - 1.f)) + 1.f)); }

static float easeInExponential(float t)		{ return (t == 0.f) ? t : powf(2.f, 10.f * (t - 1.f)); }
static float easeOutExponential(float t)	{ return (t == 1.f) ? t : 1.f - powf(2.f, -10.f * t); }
static float easeInOutExponential(float t)	{ if (t == 0.f || t == 1.f) { return t; } return (t < 0.5f) ? (0.5f * powf(2.f, (20.f * t) - 10.f)) : (-0.5f * powf(2.f, (-20.f * t) + 10.f) + 1.f); }

static float inElastic(float t)				{ return sin(13.f * M_PI_OVER_2 * t) * powf(2.f, 10.f * (t - 1.f)); }
static float outElastic(float t)			{ return sin(-13.f * M_PI_OVER_2 * (t + 1.f)) * powf(2.f, -10.f * t) + 1.f; }
static float inOutElastic(float t)			{ return (t < 0.5f) ? (0.5f * sin(13.f * M_PI_OVER_2 * (2.f * t)) * powf(2.f, 10.f * ((2.f * t) - 1.f))) : (0.5f * (sin(-13.f * M_PI_OVER_2 * ((2.f * t - 1.f) + 1.f)) * powf(2.f, -10.f * (2.f * t - 1.f)) + 2.f)); }

static float inBack(float t)				{ const float s = 1.70158f; return t * t * ((s + 1.f) * t - s); }
static float outBack(float t)				{ const float s = 1.70158f; return --t, 1.f * (t * t * ((s + 1.f) * t + s) + 1.f); }
static float inOutBack(float t)				{ const float s = 1.70158f * 1.525f; return (t < 0.5f) ? (t *= 2.f, 0.5f * t * t * (t * s + t - s)) : (t = t * 2.f - 2.f, 0.5f * (2.f + t * t * (t * s + t + s))); }


#define bounceout(p) ( \
    (t) < 4.f/11.f ? (121.f * (t) * (t))/16.f : \
    (t) < 8.f/11.f ? (363.f/40.f * (t) * (t)) - (99.f/10.f * (t)) + 17.f/5.f : \
    (t) < 9.f/10.f ? (4356.f/361.f * (t) * (t)) - (35442.f/1805.f * (t)) + 16061.f/1805.f \
                : (54.f/5.f * (t) * (t)) - (513.f/25.f * (t)) + 268.f/25.f )


static float inBounce(float t)				{ return 1.f - bounceout(1.f - t); }
static float outBounce(float t)				{ return bounceout(t); }
static float inOutBounce(float t)			{ return (t < 0.5f) ? (0.5f * (1.f - bounceout(1.f - t * 2.f))) : (0.5f * bounceout((t * 2.f - 1.f)) + 0.5f); }

#undef bounceout




static float getFramerateIndependentT(float speed, float dt)
{
	return 1.f - expf(-speed * dt);
}


struct half
{
	uint16 h;

	half() {}
	half(float f);
	half(uint16 i);

	operator float();

	static const half minValue; // Smallest possible half. Not the smallest positive, but the smallest total, so essentially -maxValue.
	static const half maxValue;
};

half operator+(half a, half b);
half& operator+=(half& a, half b);

half operator-(half a, half b);
half& operator-=(half& a, half b);

half operator*(half a, half b);
half& operator*=(half& a, half b);

half operator/(half a, half b);
half& operator/=(half& a, half b);



union vec2
{
	struct
	{
		float x, y;
	};
	float data[2];

	vec2() {}
	vec2(float v) : vec2(v, v) {}
	vec2(float x, float y) : x(x), y(y) {}

	static const vec2 zero;
};

union vec3
{
	struct
	{
		float x, y, z;
	};
	struct
	{
		float r, g, b;
	};
	struct
	{
		vec2 xy;
		float z;
	};
	struct
	{
		float x;
		vec2 yz;
	};
	float data[3];

	vec3() {}
	vec3(float v) : vec3(v, v, v) {}
	vec3(float x, float y, float z) : x(x), y(y), z(z) {}
	vec3(vec2 xy, float z) : x(xy.x), y(xy.y), z(z) {}

	static const vec3 zero;
};

union vec4
{
	struct
	{
		float x, y, z, w;
	};
	struct
	{
		float r, g, b, a;
	};
	struct
	{
		vec3 xyz;
		float w;
	};
	struct
	{
		vec2 xy;
		vec2 zw;
	};
	struct
	{
		float x;
		vec3 yzw;
	};
	w4_float f4;
	float data[4];

	vec4() {}
	vec4(float v) : vec4(v, v, v, v) {}
	vec4(float x, float y, float z, float w) : x(x), y(y), z(z), w(w) {}
	vec4(vec3 xyz, float w) : x(xyz.x), y(xyz.y), z(xyz.z), w(w) {}
	vec4(w4_float f4) : f4(f4) {}

	static const vec4 zero;
};

union quat
{
	struct
	{
		float x, y, z, w;
	};
	struct
	{
		vec3 v;
		float cosHalfAngle;
	};
	vec4 v4;
	w4_float f4;

	quat() {}
	quat(float x, float y, float z, float w) : x(x), y(y), z(z), w(w) {}
	quat(vec3 axis, float angle);
	quat(vec4 v4) : v4(v4) {}
	quat(w4_float f4) : f4(f4) {}

	static const quat identity;
	static const quat zero;
};

struct dual_quat
{
	quat real;
	quat dual;

	dual_quat() {}
	dual_quat(quat real, quat dual) : real(real), dual(dual) {}
	dual_quat(quat rotation, vec3 translation);

	vec3 getTranslation();
	quat getRotation();

	static const dual_quat identity;
	static const dual_quat zero;
};

union mat2
{
#if ROW_MAJOR
	struct
	{
		float
			m00, m01,
			m10, m11;
	};
	struct
	{
		vec2 row0;
		vec2 row1;
	};
	vec2 rows[2];
#else
	struct
	{
		float
			m00, m10,
			m01, m11;
	};
	struct
	{
		vec2 col0;
		vec2 col1;
	};
	vec2 cols[2];
#endif
	float m[4];

	mat2() {}
	mat2(
		float m00, float m01,
		float m10, float m11);

	static const mat2 identity;
	static const mat2 zero;
};

union mat3
{
#if ROW_MAJOR
	struct
	{
		float
			m00, m01, m02,
			m10, m11, m12,
			m20, m21, m22;
	};
	struct
	{
		vec3 row0;
		vec3 row1;
		vec3 row2;
	};
	vec3 rows[3];
#else
	struct
	{
		float
			m00, m10, m20,
			m01, m11, m21,
			m02, m12, m22;
	};
	struct
	{
		vec3 col0;
		vec3 col1;
		vec3 col2;
	};
	vec3 cols[3];
#endif
	float m[9];

	mat3() {}
	mat3(
		float m00, float m01, float m02,
		float m10, float m11, float m12,
		float m20, float m21, float m22);

	static const mat3 identity;
	static const mat3 zero;
};

union mat4
{
#if ROW_MAJOR
	struct
	{
		float
			m00, m01, m02, m03,
			m10, m11, m12, m13,
			m20, m21, m22, m23,
			m30, m31, m32, m33;
	};
	struct
	{
		vec4 row0;
		vec4 row1;
		vec4 row2;
		vec4 row3;
	};
	vec4 rows[4];
#else
	struct
	{
		float
			m00, m10, m20, m30,
			m01, m11, m21, m31,
			m02, m12, m22, m32,
			m03, m13, m23, m33;
	};
	struct
	{
		vec4 col0;
		vec4 col1;
		vec4 col2;
		vec4 col3;
	};
	vec4 cols[4];
#endif
	struct
	{
		w4_float f40;
		w4_float f41;
		w4_float f42;
		w4_float f43;
	};
	float m[16];

	mat4() {}
	mat4(
		float m00, float m01, float m02, float m03,
		float m10, float m11, float m12, float m13,
		float m20, float m21, float m22, float m23,
		float m30, float m31, float m32, float m33);

	static const mat4 identity;
	static const mat4 zero;
};

static_assert(sizeof(mat4) == 16 * sizeof(float), "");

#if ROW_MAJOR
static vec2 row(const mat2& a, uint32 r) { return a.rows[r]; }
static vec3 row(const mat3& a, uint32 r) { return a.rows[r]; }
static vec4 row(const mat4& a, uint32 r) { return a.rows[r]; }

static vec2 col(const mat2& a, uint32 c) { return { a.m[c], a.m[c + 2] }; }
static vec3 col(const mat3& a, uint32 c) { return { a.m[c], a.m[c + 3], a.m[c + 6] }; }
static vec4 col(const mat4& a, uint32 c) { return { a.m[c], a.m[c + 4], a.m[c + 8], a.m[c + 12] }; }
#else
static vec2 row(const mat2& a, uint32 r) { return { a.m[r], a.m[r + 2] }; }
static vec3 row(const mat3& a, uint32 r) { return { a.m[r], a.m[r + 3], a.m[r + 6] }; }
static vec4 row(const mat4& a, uint32 r) { return { a.m[r], a.m[r + 4], a.m[r + 8], a.m[r + 12] }; }
	   
static vec2 col(const mat2& a, uint32 c) { return a.cols[c]; }
static vec3 col(const mat3& a, uint32 c) { return a.cols[c]; }
static vec4 col(const mat4& a, uint32 c) { return a.cols[c]; }
#endif

struct trs
{
	quat rotation;
	vec3 position;
	vec3 scale;

	trs() {}
	trs(vec3 position, quat rotation = quat::identity, vec3 scale = { 1.f, 1.f, 1.f }) : position(position), rotation(rotation), scale(scale) {}

	static const trs identity;
};




// Vec2 operators.
static vec2 operator+(vec2 a, vec2 b) { vec2 result = { a.x + b.x, a.y + b.y }; return result; }
static vec2& operator+=(vec2& a, vec2 b) { a = a + b; return a; }
static vec2 operator-(vec2 a, vec2 b) { vec2 result = { a.x - b.x, a.y - b.y }; return result; }
static vec2& operator-=(vec2& a, vec2 b) { a = a - b; return a; }
static vec2 operator*(vec2 a, vec2 b) { vec2 result = { a.x * b.x, a.y * b.y }; return result; }
static vec2& operator*=(vec2& a, vec2 b) { a = a * b; return a; }
static vec2 operator/(vec2 a, vec2 b) { vec2 result = { a.x / b.x, a.y / b.y }; return result; }
static vec2& operator/=(vec2& a, vec2 b) { a = a / b; return a; }

static vec2 operator*(vec2 a, float b) { vec2 result = { a.x * b, a.y * b }; return result; }
static vec2 operator*(float a, vec2 b) { return b * a; }
static vec2& operator*=(vec2& a, float b) { a = a * b; return a; }
static vec2 operator/(vec2 a, float b) { vec2 result = { a.x / b, a.y / b }; return result; }
static vec2& operator/=(vec2& a, float b) { a = a / b; return a; }

static vec2 operator-(vec2 a) { return vec2(-a.x, -a.y); }

static bool operator==(vec2 a, vec2 b) { return a.x == b.x && a.y == b.y; }
static bool operator!=(vec2 a, vec2 b) { return !(a == b); }


// Vec3 operators.
static vec3 operator+(vec3 a, vec3 b) { vec3 result = { a.x + b.x, a.y + b.y, a.z + b.z }; return result; }
static vec3& operator+=(vec3& a, vec3 b) { a = a + b; return a; }
static vec3 operator-(vec3 a, vec3 b) { vec3 result = { a.x - b.x, a.y - b.y, a.z - b.z }; return result; }
static vec3& operator-=(vec3& a, vec3 b) { a = a - b; return a; }
static vec3 operator*(vec3 a, vec3 b) { vec3 result = { a.x * b.x, a.y * b.y, a.z * b.z }; return result; }
static vec3& operator*=(vec3& a, vec3 b) { a = a * b; return a; }
static vec3 operator/(vec3 a, vec3 b) { vec3 result = { a.x / b.x, a.y / b.y, a.z / b.z }; return result; }
static vec3& operator/=(vec3& a, vec3 b) { a = a / b; return a; }

static vec3 operator*(vec3 a, float b) { vec3 result = { a.x * b, a.y * b, a.z * b }; return result; }
static vec3 operator*(float a, vec3 b) { return b * a; }
static vec3& operator*=(vec3& a, float b) { a = a * b; return a; }
static vec3 operator/(vec3 a, float b) { vec3 result = { a.x / b, a.y / b, a.z / b }; return result; }
static vec3& operator/=(vec3& a, float b) { a = a / b; return a; }

static vec3 operator-(vec3 a) { return vec3(-a.x, -a.y, -a.z); }

static bool operator==(vec3 a, vec3 b) { return a.x == b.x && a.y == b.y && a.z == b.z; }
static bool operator!=(vec3 a, vec3 b) { return !(a == b); }


// Vec4 operators.
static vec4 operator+(vec4 a, vec4 b) { vec4 result = { a.f4 + b.f4 }; return result; }
static vec4& operator+=(vec4& a, vec4 b) { a = a + b; return a; }
static vec4 operator-(vec4 a, vec4 b) { vec4 result = { a.f4 - b.f4 }; return result; }
static vec4& operator-=(vec4& a, vec4 b) { a = a - b; return a; }
static vec4 operator*(vec4 a, vec4 b) { vec4 result = { a.f4 * b.f4 }; return result; }
static vec4& operator*=(vec4& a, vec4 b) { a = a * b; return a; }
static vec4 operator/(vec4 a, vec4 b) { vec4 result = { a.f4 / b.f4 }; return result; }
static vec4& operator/=(vec4& a, vec4 b) { a = a / b; return a; }

static vec4 operator*(vec4 a, float b) { vec4 result = { a.f4 * w4_float(b) }; return result; }
static vec4 operator*(float a, vec4 b) { return b * a; }
static vec4& operator*=(vec4& a, float b) { a = a * b; return a; }
static vec4 operator/(vec4 a, float b) { vec4 result = { a.f4 / w4_float(b) }; return result; }
static vec4& operator/=(vec4& a, float b) { a = a / b; return a; }

static vec4 operator-(vec4 a) { return vec4(-a.f4); }

static bool operator==(vec4 a, vec4 b) { return a.x == b.x && a.y == b.y && a.z == b.z && a.w == b.w; }
static bool operator!=(vec4 a, vec4 b) { return !(a == b); }


static vec2 diagonal(const mat2& m) { return vec2(m.m00, m.m11); }
static vec3 diagonal(const mat3& m) { return vec3(m.m00, m.m11, m.m22); }
static vec4 diagonal(const mat4& m) { return vec4(m.m00, m.m11, m.m22, m.m33); }

static float dot(vec2 a, vec2 b) { float result = a.x * b.x + a.y * b.y; return result; }
static float dot(vec3 a, vec3 b) { float result = a.x * b.x + a.y * b.y + a.z * b.z; return result; }
static float dot(vec4 a, vec4 b) { w4_float m = a.f4 * b.f4; return addElements(m); }

static float cross(vec2 a, vec2 b) { return a.x * b.y - a.y * b.x; }
static vec3 cross(vec3 a, vec3 b) { vec3 result = { a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x }; return result; }

static float squaredLength(vec2 a) { return dot(a, a); }
static float squaredLength(vec3 a) { return dot(a, a); }
static float squaredLength(vec4 a) { return dot(a, a); }

static float length(vec2 a) { return sqrt(squaredLength(a)); }
static float length(vec3 a) { return sqrt(squaredLength(a)); }
static float length(vec4 a) { return sqrt(squaredLength(a)); }

static vec2 noz(vec2 a) { float sl = squaredLength(a); return (sl < 1e-8f) ? vec2(0.f, 0.f) : (a * (1.f / sqrt(sl))); }
static vec3 noz(vec3 a) { float sl = squaredLength(a); return (sl < 1e-8f) ? vec3(0.f, 0.f, 0.f) : (a * (1.f / sqrt(sl))); }
static vec4 noz(vec4 a) { float sl = squaredLength(a); return (sl < 1e-8f) ? vec4(0.f, 0.f, 0.f, 0.f) : (a * (1.f / sqrt(sl))); }

static vec2 normalize(vec2 a) { float l = length(a); return a * (1.f / l); }
static vec3 normalize(vec3 a) { float l = length(a); return a * (1.f / l); }
static vec4 normalize(vec4 a) { float l = length(a); return a * (1.f / l); }

static void copySign(vec2 from, vec2& to) { copySign(from.x, to.x); copySign(from.y, to.y); }
static void copySign(vec3 from, vec3& to) { copySign(from.x, to.x); copySign(from.y, to.y); copySign(from.z, to.z); }
static void copySign(vec4 from, vec4& to) { copySign(from.x, to.x); copySign(from.y, to.y); copySign(from.z, to.z); copySign(from.w, to.w); }

static vec2 abs(vec2 a) { return vec2(abs(a.x), abs(a.y)); }
static vec3 abs(vec3 a) { return vec3(abs(a.x), abs(a.y), abs(a.z)); }
static vec4 abs(vec4 a) { return vec4(abs(a.f4)); }

static vec2 floor(vec2 a) { return vec2(floor(a.x), floor(a.y)); }
static vec3 floor(vec3 a) { return vec3(floor(a.x), floor(a.y), floor(a.z)); }
static vec4 floor(vec4 a) { return vec4(floor(a.f4)); }

static vec2 round(vec2 a) { return vec2(round(a.x), round(a.y)); }
static vec3 round(vec3 a) { return vec3(round(a.x), round(a.y), round(a.z)); }
static vec4 round(vec4 a) { return vec4(round(a.f4)); }

static vec2 frac(vec2 a) { return vec2(frac(a.x), frac(a.y)); }
static vec3 frac(vec3 a) { return vec3(frac(a.x), frac(a.y), frac(a.z)); }
static vec4 frac(vec4 a) { return vec4(frac(a.x), frac(a.y), frac(a.z), frac(a.w)); }

static quat normalize(quat a) { return { normalize(a.v4).f4 }; }
static quat conjugate(quat a) { return { -a.x, -a.y, -a.z, a.w }; }

static quat operator+(quat a, quat b) { quat result = { a.f4 + b.f4 }; return result; }

static quat operator*(quat a, quat b)
{
	quat result;
	result.w = a.w * b.w - dot(a.v, b.v);
	result.v = a.v * b.w + b.v * a.w + cross(a.v, b.v);
	return result;
}

static quat operator*(quat q, float s)
{
	quat result;
	result.v4 = q.v4 * s;
	return result;
}

static vec3 operator*(quat q, vec3 v)
{
	quat p(v.x, v.y, v.z, 0.f);
	return (q * p * conjugate(q)).v;
}

static dual_quat operator+(const dual_quat& a, const dual_quat& b) { return { a.real + b.real, a.dual + b.dual }; }
static dual_quat& operator+=(dual_quat& a, const dual_quat& b) { a = a + b; return a; }
static dual_quat operator*(const dual_quat& a, const dual_quat& b) { return { a.real * b.real, a.dual * b.real + b.dual * a.real }; }
static dual_quat operator*(const dual_quat& a, float b) { return { a.real * b, a.dual * b }; }
static dual_quat operator*(float b, const dual_quat& a) { return a * b; }
static dual_quat& operator*=(dual_quat& q, float v) { q = q * v; return q; }
static dual_quat normalize(const dual_quat& q) { float n = 1.f / length(q.real.v4); return q * n; }

static bool operator==(quat a, quat b) { return a.x == b.x && a.y == b.y && a.z == b.z && a.w == b.w; }
static bool operator!=(quat a, quat b) { return !(a == b); }

static vec2 operator*(mat2 a, vec2 b) { vec2 result = { dot(row(a, 0), b), dot(row(a, 1), b) }; return result; }
static vec3 operator*(mat3 a, vec3 b) { vec3 result = { dot(row(a, 0), b), dot(row(a, 1), b), dot(row(a, 2), b) }; return result; }

#if ROW_MAJOR
static vec4 operator*(mat4 a, vec4 b) { vec4 result = { dot(row(a, 0), b), dot(row(a, 1), b), dot(row(a, 2), b), dot(row(a, 3), b) }; return result; }
#else
static vec4 operator*(mat4 a, vec4 b) { vec4 result = col(a, 0) * b.x + col(a, 1) * b.y + col(a, 2) * b.z + col(a, 3) * b.w; return result; }
#endif



static vec2 lerp(vec2 l, vec2 u, float t) { return l + t * (u - l); }
static vec3 lerp(vec3 l, vec3 u, float t) { return l + t * (u - l); }
static vec4 lerp(vec4 l, vec4 u, float t) { return l + t * (u - l); }
static quat lerp(quat l, quat u, float t) { quat result; result.v4 = lerp(l.v4, u.v4, t); return normalize(result); }
static dual_quat lerp(const dual_quat& l, const dual_quat& u, float t) { return { quat(lerp(l.real.v4, u.real.v4, t)), quat(lerp(l.dual.v4, u.dual.v4, t)) }; }
static trs lerp(const trs& l, const trs& u, float t)
{
	trs result;
	result.position = lerp(l.position, u.position, t);
	result.rotation = lerp(l.rotation, u.rotation, t);
	result.scale = lerp(l.scale, u.scale, t);
	return result;
}

static vec2 exp(vec2 v) { return vec2(exp(v.x), exp(v.y)); }
static vec3 exp(vec3 v) { return vec3(exp(v.x), exp(v.y), exp(v.z)); }
static vec4 exp(vec4 v) { return vec4(exp(v.f4)); }

static vec2 pow(vec2 v, float e) { return vec2(pow(v.x, e), pow(v.y, e)); }
static vec3 pow(vec3 v, float e) { return vec3(pow(v.x, e), pow(v.y, e), pow(v.z, e)); }
static vec4 pow(vec4 v, float e) { return vec4(pow(v.f4, w4_float(e))); }

static vec2 min(vec2 a, vec2 b) { return vec2(min(a.x, b.x), min(a.y, b.y)); }
static vec3 min(vec3 a, vec3 b) { return vec3(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z)); }
static vec4 min(vec4 a, vec4 b) { return vec4(minimum(a.f4, b.f4)); }

static vec2 max(vec2 a, vec2 b) { return vec2(max(a.x, b.x), max(a.y, b.y)); }
static vec3 max(vec3 a, vec3 b) { return vec3(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z)); }
static vec4 max(vec4 a, vec4 b) { return vec4(maximum(a.f4, b.f4)); }

static float maxElement(vec2 a) { return max(a.x, a.y); }
static float maxElement(vec3 a) { return max(a.x, max(a.y, a.z)); }
static float maxElement(vec4 a) { return max(a.x, max(a.y, max(a.z, a.w))); }

static uint32 maxElementIndex(vec2 a) { return (a.x > a.y) ? 0 : 1; }
static uint32 maxElementIndex(vec3 a) { return (a.x > a.y) ? ((a.x > a.z) ? 0 : 2) : ((a.y > a.z) ? 1 : 2); }
static uint32 maxElementIndex(vec4 a) { return (a.x > a.y)	? ((a.x > a.z)	? ((a.x > a.w) ? 0 : 3) 
																			: ((a.z > a.w) ? 2 : 3)) 
															: ((a.y > a.z)	? ((a.y > a.w) ? 1 : 3) 
																			: ((a.z > a.w) ? 2 : 3)); }

static vec2 remap(vec2 v, vec2 oldL, vec2 oldU, vec2 newL, vec2 newU)
{
	return
	{
		remap(v.x, oldL.x, oldU.x, newL.x, newU.x),
		remap(v.y, oldL.y, oldU.y, newL.y, newU.y),
	};
}
static vec3 remap(vec3 v, vec3 oldL, vec3 oldU, vec3 newL, vec3 newU)
{
	return
	{
		remap(v.x, oldL.x, oldU.x, newL.x, newU.x),
		remap(v.y, oldL.y, oldU.y, newL.y, newU.y),
		remap(v.z, oldL.z, oldU.z, newL.z, newU.z),
	};
}
static vec4 remap(vec4 v, vec4 oldL, vec4 oldU, vec4 newL, vec4 newU)
{
	return
	{
		remap(v.x, oldL.x, oldU.x, newL.x, newU.x),
		remap(v.y, oldL.y, oldU.y, newL.y, newU.y),
		remap(v.z, oldL.z, oldU.z, newL.z, newU.z),
		remap(v.w, oldL.w, oldU.w, newL.w, newU.w),
	};
}

mat2 operator*(const mat2& a, const mat2& b);
mat3 operator*(const mat3& a, const mat3& b);
mat3 operator+(const mat3& a, const mat3& b);
mat3& operator+=(mat3& a, const mat3& b);
mat3 operator-(const mat3& a, const mat3& b);
mat4 operator*(const mat4& a, const mat4& b);
mat2 operator*(const mat2& a, float b);
mat3 operator*(const mat3& a, float b);
mat4 operator*(const mat4& a, float b);
mat2 operator*(float a, const mat2& b);
mat3 operator*(float a, const mat3& b);
mat4 operator*(float a, const mat4& b);
mat2& operator*=(mat2& a, float b);
mat3& operator*=(mat3& a, float b);
mat4& operator*=(mat4& a, float b);
trs operator*(const trs& a, const trs& b);

mat2 transpose(const mat2& a);
mat3 transpose(const mat3& a);
mat4 transpose(const mat4& a);

mat3 invert(const mat3& m);
mat4 invert(const mat4& m);
trs invert(const trs& t);

float determinant(const mat2& m);
float determinant(const mat3& m);
float determinant(const mat4& m);

float trace(const mat3& m);
float trace(const mat4& m);

vec3 transformPosition(const mat4& m, vec3 pos);
vec3 transformDirection(const mat4& m, vec3 dir);
vec3 transformPosition(const trs& m, vec3 pos);
vec3 transformDirection(const trs& m, vec3 dir);
vec3 inverseTransformPosition(const trs& m, vec3 pos);
vec3 inverseTransformDirection(const trs& m, vec3 dir);

quat rotateFromTo(vec3 from, vec3 to);
quat lookAtQuaternion(vec3 forward, vec3 up);
void getAxisRotation(quat q, vec3& axis, float& angle);
void decomposeQuaternionIntoTwistAndSwing(quat q, vec3 normalizedTwistAxis, quat& twist, quat& swing);

quat slerp(quat from, quat to, float t);
quat nlerp(quat* qs, float* weights, uint32 count);

mat3 quaternionToMat3(quat q);
quat mat3ToQuaternion(const mat3& m);

vec3 quatToEuler(quat q);
quat eulerToQuat(vec3 euler);

mat3 outerProduct(vec3 a, vec3 b);
mat3 getSkewMatrix(vec3 r);

mat4 trsToMat4(const trs& transform);
trs mat4ToTRS(const mat4& m);

mat4 createPerspectiveProjectionMatrix(float fov, float aspect, float nearPlane, float farPlane);
mat4 createPerspectiveProjectionMatrix(float width, float height, float fx, float fy, float cx, float cy, float nearPlane, float farPlane);
mat4 createPerspectiveProjectionMatrix(float r, float l, float t, float b, float nearPlane, float farPlane);
mat4 createOrthographicProjectionMatrix(float r, float l, float t, float b, float nearPlane, float farPlane);
mat4 invertPerspectiveProjectionMatrix(const mat4& m);
mat4 invertOrthographicProjectionMatrix(const mat4& m);
mat4 createTranslationMatrix(vec3 position);
mat4 createModelMatrix(vec3 position, quat rotation, vec3 scale = vec3(1.f, 1.f, 1.f));
mat4 createBillboardModelMatrix(vec3 position, vec3 eye, vec3 scale);
mat4 createViewMatrix(vec3 eye, float pitch, float yaw);
mat4 createSkyViewMatrix(const mat4& v);
mat4 lookAt(vec3 eye, vec3 target, vec3 up);
mat4 createViewMatrix(vec3 position, quat rotation);
mat4 invertAffine(const mat4& m);

bool pointInTriangle(vec3 point, vec3 triA, vec3 triB, vec3& triC);
bool pointInRectangle(vec2 p, vec2 topLeft, vec2 bottomRight);
bool pointInBox(vec3 p, vec3 minCorner, vec3 maxCorner);

vec2 directionToPanoramaUV(vec3 dir);

float angleToZeroToTwoPi(float angle);
float angleToNegPiToPi(float angle);

vec2 solveLinearSystem(const mat2& A, vec2 b);
vec3 solveLinearSystem(const mat3& A, vec3 b);

vec3 getBarycentricCoordinates(vec2 a, vec2 b, vec2 c, vec2 p);
vec3 getBarycentricCoordinates(vec3 a, vec3 b, vec3 c, vec3 p);
bool insideTriangle(vec3 barycentrics);

void getTangents(vec3 normal, vec3& outTangent, vec3& outBitangent);
vec3 getTangent(vec3 normal);

// W = PDF = 1 / 4pi
vec4 uniformSampleSphere(vec2 E);





struct singular_value_decomposition
{
	mat3 U;
	mat3 V;
	vec3 singularValues;
};

struct qr_decomposition
{
	mat3 Q, R;
};

singular_value_decomposition computeSVD(const mat3& A);
qr_decomposition qrDecomposition(const mat3& mat);
bool getEigen(const mat3& A, vec3& outEigenValues, mat3& outEigenVectors);


template <typename T>
void exclusivePrefixSum(const T* input, T* output, uint32 count)
{
	if (count > 0)
	{
		output[0] = T(0);
		for (uint32 i = 1; i < count; ++i)
		{
			output[i] = output[i - 1] + input[i - 1];
		}
	}
}

template <typename T>
T sum(const T* input, uint32 count)
{
	T result = 0;
	for (uint32 i = 0; i < count; ++i)
	{
		result += input[i];
	}
	return result;
}



static bool fuzzyEquals(float a, float b, float threshold = 1e-4f) { return abs(a - b) < threshold; }
static bool fuzzyEquals(vec2 a, vec2 b, float threshold = 1e-4f) { return fuzzyEquals(a.x, b.x, threshold) && fuzzyEquals(a.y, b.y, threshold); }
static bool fuzzyEquals(vec3 a, vec3 b, float threshold = 1e-4f) { return fuzzyEquals(a.x, b.x, threshold) && fuzzyEquals(a.y, b.y, threshold) && fuzzyEquals(a.z, b.z, threshold); }
static bool fuzzyEquals(vec4 a, vec4 b, float threshold = 1e-4f) { return fuzzyEquals(a.x, b.x, threshold) && fuzzyEquals(a.y, b.y, threshold) && fuzzyEquals(a.z, b.z, threshold) && fuzzyEquals(a.w, b.w, threshold); }
static bool fuzzyEquals(quat a, quat b, float threshold = 1e-4f) { if (dot(a.v4, b.v4) < 0.f) { a.v4 *= -1.f; } return fuzzyEquals(a.x, b.x, threshold) && fuzzyEquals(a.y, b.y, threshold) && fuzzyEquals(a.z, b.z, threshold) && fuzzyEquals(a.w, b.w, threshold); }

static bool fuzzyEquals(const mat2& a, const mat2& b, float threshold = 1e-4f)
{
	bool result = true;
	for (uint32 i = 0; i < 4; ++i)
	{
		result &= fuzzyEquals(a.m[i], b.m[i], threshold);
	}
	return result;
}

static bool fuzzyEquals(const mat3& a, const mat3& b, float threshold = 1e-4f)
{
	bool result = true;
	for (uint32 i = 0; i < 9; ++i)
	{
		result &= fuzzyEquals(a.m[i], b.m[i], threshold);
	}
	return result;
}

static bool fuzzyEquals(const mat4& a, const mat4& b, float threshold = 1e-4f)
{
	bool result = true;
	for (uint32 i = 0; i < 16; ++i)
	{
		result &= fuzzyEquals(a.m[i], b.m[i], threshold);
	}
	return result;
}

static bool fuzzyEquals(const trs& a, const trs& b, float threshold = 1e-4f)
{
	bool result = true;
	result &= fuzzyEquals(a.position, b.position, threshold);
	result &= fuzzyEquals(a.rotation, b.rotation, threshold);
	result &= fuzzyEquals(a.scale, b.scale, threshold);
	return result;
}

static bool isUniform(vec2 v) { return fuzzyEquals(v.x, v.y); }
static bool isUniform(vec3 v) { return fuzzyEquals(v.x, v.y) && fuzzyEquals(v.x, v.z); }
static bool isUniform(vec4 v) { return fuzzyEquals(v.x, v.y) && fuzzyEquals(v.x, v.z) && fuzzyEquals(v.x, v.w); }


inline quat::quat(vec3 axis, float angle)
{
	w = cos(angle * 0.5f);
	v = axis * sin(angle * 0.5f);
}

inline dual_quat::dual_quat(quat rotation, vec3 translation)
{
	float w = -0.5f * (translation.x * rotation.x + translation.y * rotation.y + translation.z * rotation.z);
	float x = 0.5f * (translation.x * rotation.w + translation.y * rotation.z - translation.z * rotation.y);
	float y = 0.5f * (-translation.x * rotation.z + translation.y * rotation.w + translation.z * rotation.x);
	float z = 0.5f * (translation.x * rotation.y - translation.y * rotation.x + translation.z * rotation.w);

	real = rotation;
	dual = quat(x, y, z, w);
}

inline vec3 dual_quat::getTranslation()
{
	quat tq = dual * conjugate(real);
	return 2.f * tq.v4.xyz;
}

inline quat dual_quat::getRotation()
{
	return real;
}

inline mat2::mat2(
	float m00, float m01,
	float m10, float m11)
	:
	m00(m00), m01(m01),
	m10(m10), m11(m11) {}

inline mat3::mat3(
	float m00, float m01, float m02,
	float m10, float m11, float m12,
	float m20, float m21, float m22)
	:
	m00(m00), m01(m01), m02(m02),
	m10(m10), m11(m11), m12(m12),
	m20(m20), m21(m21), m22(m22) {}

inline mat4::mat4(
	float m00, float m01, float m02, float m03,
	float m10, float m11, float m12, float m13,
	float m20, float m21, float m22, float m23,
	float m30, float m31, float m32, float m33)
	:
	m00(m00), m01(m01), m02(m02), m03(m03),
	m10(m10), m11(m11), m12(m12), m13(m13),
	m20(m20), m21(m21), m22(m22), m23(m23),
	m30(m30), m31(m31), m32(m32), m33(m33) {}

inline std::ostream& operator<<(std::ostream& s, vec2 v)
{
	s << "[" << v.x << ", " << v.y << "]";
	return s;
}

inline std::ostream& operator<<(std::ostream& s, vec3 v)
{
	s << "[" << v.x << ", " << v.y << ", " << v.z << "]";
	return s;
}

inline std::ostream& operator<<(std::ostream& s, vec4 v)
{
	s << "[" << v.x << ", " << v.y << ", " << v.z << ", " << v.w << "]";
	return s;
}

inline std::ostream& operator<<(std::ostream& s, quat v)
{
	s << "[" << v.x << ", " << v.y << ", " << v.z << ", " << v.w << "]";
	return s;
}

inline std::ostream& operator<<(std::ostream& s, const mat2& m)
{
	s << "[" << m.m00 << ", " << m.m01 << "]\n";
	s << "[" << m.m10 << ", " << m.m11 << "]";
	return s;
}

inline std::ostream& operator<<(std::ostream& s, const mat3& m)
{
	s << "[" << m.m00 << ", " << m.m01 << ", " << m.m02 << "]\n";
	s << "[" << m.m10 << ", " << m.m11 << ", " << m.m12 << "]\n";
	s << "[" << m.m20 << ", " << m.m21 << ", " << m.m22 << "]";
	return s;
}

inline std::ostream& operator<<(std::ostream& s, const mat4& m)
{
	s << "[" << m.m00 << ", " << m.m01 << ", " << m.m02 << ", " << m.m03 << "]\n";
	s << "[" << m.m10 << ", " << m.m11 << ", " << m.m12 << ", " << m.m13 << "]\n";
	s << "[" << m.m20 << ", " << m.m21 << ", " << m.m22 << ", " << m.m23 << "]\n";
	s << "[" << m.m30 << ", " << m.m31 << ", " << m.m32 << ", " << m.m33 << "]";
	return s;
}

inline std::ostream& operator<<(std::ostream& s, const trs& m)
{
	s << "Position: " << m.position << '\n';
	s << "Rotation: " << m.rotation << '\n';
	s << "Scale: " << m.scale << '\n';
	return s;
}





template <typename T>
static T evaluateSpline(const float* ts, const T* values, int32 num, float t)
{
	ASSERT(num >= 2);

	// Find key.
	int32 k = 0;
	while (k < num - 1 && ts[k + 1] >= 0.f && ts[k] < t)
	{
		++k;
	}

	if (ts[k + 1] < 0.f)
	{
		num = k + 1;
	}

	// Interpolant.
	const float h1 = clamp01(inverseLerp(ts[k - 1], ts[k], t));
	const float h2 = h1 * h1;
	const float h3 = h2 * h1;
	const vec4 h(h3, h2, h1, 1.f);

	T result;
	if constexpr (std::is_same_v<std::remove_cv_t<T>, quat> || std::is_same_v<std::remove_cv_t<T>, dual_quat>)
	{
		result = T::zero;
	}
	else
	{
		result = 0;
	}

	int32 m = num - 1;
	result += values[clamp(k - 2, 0, m)] * dot(vec4(-1, 2, -1, 0), h);
	result += values[k - 1] * dot(vec4(3, -5, 0, 2), h);
	result += values[k] * dot(vec4(-3, 4, 1, 0), h);
	result += values[clamp(k + 1, 0, m)] * dot(vec4(1, -1, 0, 0), h);

	result *= 0.5f;

	return result;
}

// maxNumPoints must be a multiple of 4!
// If you want to use this in a shader constant buffer, T can currently be either float or vec4.
template <typename T, uint32 maxNumPoints_>
struct alignas(16) catmull_rom_spline
{
	static_assert(maxNumPoints_ > 0 && maxNumPoints_ % 4 == 0, "Spline max num points must be divisible by 4.");

	float ts[maxNumPoints_];
	T values[maxNumPoints_];

	enum { maxNumPoints = maxNumPoints_ };

	catmull_rom_spline()
	{
		ts[0] = 0;
		ts[1] = 1;
		ts[2] = -1;

		if constexpr (std::is_same_v<std::remove_cv_t<T>, quat> || std::is_same_v<std::remove_cv_t<T>, dual_quat>)
		{
			values[0] = values[1] = T::identity;
		}
		else
		{
			values[0] = T(0);
			values[1] = T(1);
		}
	}

	catmull_rom_spline(T(*func)(float))
	{
		for (int i = 0; i < maxNumPoints; ++i)
		{
			ts[i] = i / float(maxNumPoints - 1);
			values[i] = func(ts[i]);
		}
	}

	inline T evaluate(uint32 numActualPoints, float t) const
	{
		return evaluateSpline(ts, values, numActualPoints, t);
	}
};

// Interop for shaders.
#define spline(T, maxNumPoints) catmull_rom_spline<T, maxNumPoints>
#define defineSpline(T, maxNumPoints) template struct spline(T, maxNumPoints);



```

`src/core/math_simd.h`:

```h
#pragma once

#include "simd.h"
#include "soa.h"


struct w4_float;
struct w8_float;
struct w16_float;

template <typename simd_t>
union wN_vec2
{
	struct
	{
		simd_t x, y;
	};
	simd_t data[2];

	wN_vec2() {}
	wN_vec2(simd_t v) : wN_vec2(v, v) {}
	wN_vec2(simd_t x, simd_t y) : x(x), y(y) {}
	wN_vec2(soa_vec2 v, uint32 offset) : x(v.x + offset), y(v.y + offset) {}

	void store(float* xDest, float* yDest) { x.store(xDest); y.store(yDest); }

	static wN_vec2 zero() { return wN_vec2<simd_t>(simd_t::zero()); }
};

template <typename simd_t>
union wN_vec3
{
	struct
	{
		simd_t x, y, z;
	};
	struct
	{
		simd_t r, g, b;
	};
	struct
	{
		wN_vec2<simd_t> xy;
		simd_t z;
	};
	simd_t data[3];

	wN_vec3() {}
	wN_vec3(simd_t v) : wN_vec3(v, v, v) {}
	wN_vec3(simd_t x, simd_t y, simd_t z) : x(x), y(y), z(z) {}
	wN_vec3(wN_vec2<simd_t> xy, simd_t z) : x(xy.x), y(xy.y), z(z) {}
	wN_vec3(soa_vec3 v, uint32 offset) : x(v.x + offset), y(v.y + offset), z(v.z + offset) {}

	void store(float* xDest, float* yDest, float* zDest) { x.store(xDest); y.store(yDest); z.store(zDest); }

	static wN_vec3 zero() { return wN_vec3<simd_t>(simd_t::zero()); }
};

template <typename simd_t>
union wN_vec4
{
	struct
	{
		simd_t x, y, z, w;
	};
	struct
	{
		simd_t r, g, b, a;
	};
	struct
	{
		wN_vec3<simd_t> xyz;
		simd_t w;
	};
	struct
	{
		wN_vec2<simd_t> xy;
		wN_vec2<simd_t> zw;
	};
	simd_t data[4];

	wN_vec4() {}
	wN_vec4(simd_t v) : wN_vec4(v, v, v, v) {}
	wN_vec4(simd_t x, simd_t y, simd_t z, simd_t w) : x(x), y(y), z(z), w(w) {}
	wN_vec4(wN_vec3<simd_t> xyz, simd_t w) : x(xyz.x), y(xyz.y), z(xyz.z), w(w) {}
	wN_vec4(soa_vec4 v, uint32 offset) : x(v.x + offset), y(v.y + offset), z(v.z + offset), w(v.w + offset) {}

	void store(float* xDest, float* yDest, float* zDest, float* wDest) { x.store(xDest); y.store(yDest); z.store(zDest); w.store(wDest); }

	static wN_vec4 zero() { return wN_vec4<simd_t>(simd_t::zero()); }
};

template <typename simd_t>
union wN_quat
{
	struct
	{
		simd_t x, y, z, w;
	};
	struct
	{
		wN_vec3<simd_t> v;
		simd_t cosHalfAngle;
	};
	wN_vec4<simd_t> v4;
	simd_t data[4];

	wN_quat() {}
	wN_quat(simd_t x, simd_t y, simd_t z, simd_t w) : x(x), y(y), z(z), w(w) {}
	wN_quat(wN_vec3<simd_t> axis, simd_t angle);
	wN_quat(soa_quat v, uint32 offset) : x(v.x + offset), y(v.y + offset), z(v.z + offset), w(v.w + offset) {}

	void store(float* xDest, float* yDest, float* zDest, float* wDest) { x.store(xDest); y.store(yDest); z.store(zDest); w.store(wDest); }

	static wN_quat identity() { return wN_quat<simd_t>(simd_t::zero(), simd_t::zero(), simd_t::zero(), simd_t(1.f)); }
};

template <typename simd_t>
union wN_mat2
{
	struct
	{
		simd_t
			m00, m10,
			m01, m11;
	};
	simd_t m[4];

	wN_mat2() {}
	wN_mat2(
		simd_t m00, simd_t m01,
		simd_t m10, simd_t m11);
};

template <typename simd_t>
union wN_mat3
{
	struct
	{
		simd_t
			m00, m10, m20,
			m01, m11, m21,
			m02, m12, m22;
	};
	simd_t m[9];

	wN_mat3() {}
	wN_mat3(
		simd_t m00, simd_t m01, simd_t m02,
		simd_t m10, simd_t m11, simd_t m12,
		simd_t m20, simd_t m21, simd_t m22);
};

template <typename simd_t>
union wN_mat4
{
	struct
	{
		simd_t
			m00, m10, m20, m30,
			m01, m11, m21, m31,
			m02, m12, m22, m32,
			m03, m13, m23, m33;
	};
	simd_t m[16];

	wN_mat4() {}
	wN_mat4(
		simd_t m00, simd_t m01, simd_t m02, simd_t m03,
		simd_t m10, simd_t m11, simd_t m12, simd_t m13,
		simd_t m20, simd_t m21, simd_t m22, simd_t m23,
		simd_t m30, simd_t m31, simd_t m32, simd_t m33);
};



// Vec2 operators.
template <typename simd_t> static wN_vec2<simd_t> operator+(wN_vec2<simd_t> a, wN_vec2<simd_t> b) { wN_vec2 result = { a.x + b.x, a.y + b.y }; return result; }
template <typename simd_t> static wN_vec2<simd_t>& operator+=(wN_vec2<simd_t>& a, wN_vec2<simd_t> b) { a = a + b; return a; }
template <typename simd_t> static wN_vec2<simd_t> operator-(wN_vec2<simd_t> a, wN_vec2<simd_t> b) { wN_vec2 result = { a.x - b.x, a.y - b.y }; return result; }
template <typename simd_t> static wN_vec2<simd_t>& operator-=(wN_vec2<simd_t>& a, wN_vec2<simd_t> b) { a = a - b; return a; }
template <typename simd_t> static wN_vec2<simd_t> operator*(wN_vec2<simd_t> a, wN_vec2<simd_t> b) { wN_vec2 result = { a.x * b.x, a.y * b.y }; return result; }
template <typename simd_t> static wN_vec2<simd_t>& operator*=(wN_vec2<simd_t>& a, wN_vec2<simd_t> b) { a = a * b; return a; }
template <typename simd_t> static wN_vec2<simd_t> operator/(wN_vec2<simd_t> a, wN_vec2<simd_t> b) { wN_vec2 result = { a.x / b.x, a.y / b.y }; return result; }
template <typename simd_t> static wN_vec2<simd_t>& operator/=(wN_vec2<simd_t>& a, wN_vec2<simd_t> b) { a = a / b; return a; }

template <typename simd_t> static wN_vec2<simd_t> operator*(wN_vec2<simd_t> a, simd_t b) { wN_vec2 result = { a.x * b, a.y * b }; return result; }
template <typename simd_t> static wN_vec2<simd_t> operator*(simd_t a, wN_vec2<simd_t> b) { return b * a; }
template <typename simd_t> static wN_vec2<simd_t>& operator*=(wN_vec2<simd_t>& a, simd_t b) { a = a * b; return a; }
template <typename simd_t> static wN_vec2<simd_t> operator/(wN_vec2<simd_t> a, simd_t b) { wN_vec2 result = { a.x / b, a.y / b }; return result; }
template <typename simd_t> static wN_vec2<simd_t>& operator/=(wN_vec2<simd_t>& a, simd_t b) { a = a / b; return a; }

template <typename simd_t> static wN_vec2<simd_t> operator-(wN_vec2<simd_t> a) { return wN_vec2(-a.x, -a.y); }

template <typename simd_t> static auto operator==(wN_vec2<simd_t> a, wN_vec2<simd_t> b) { return a.x == b.x & a.y == b.y; }


// Vec3 operators.
template <typename simd_t> static wN_vec3<simd_t> operator+(wN_vec3<simd_t> a, wN_vec3<simd_t> b) { wN_vec3 result = { a.x + b.x, a.y + b.y, a.z + b.z }; return result; }
template <typename simd_t> static wN_vec3<simd_t>& operator+=(wN_vec3<simd_t>& a, wN_vec3<simd_t> b) { a = a + b; return a; }
template <typename simd_t> static wN_vec3<simd_t> operator-(wN_vec3<simd_t> a, wN_vec3<simd_t> b) { wN_vec3 result = { a.x - b.x, a.y - b.y, a.z - b.z }; return result; }
template <typename simd_t> static wN_vec3<simd_t>& operator-=(wN_vec3<simd_t>& a, wN_vec3<simd_t> b) { a = a - b; return a; }
template <typename simd_t> static wN_vec3<simd_t> operator*(wN_vec3<simd_t> a, wN_vec3<simd_t> b) { wN_vec3 result = { a.x * b.x, a.y * b.y, a.z * b.z }; return result; }
template <typename simd_t> static wN_vec3<simd_t>& operator*=(wN_vec3<simd_t>& a, wN_vec3<simd_t> b) { a = a * b; return a; }
template <typename simd_t> static wN_vec3<simd_t> operator/(wN_vec3<simd_t> a, wN_vec3<simd_t> b) { wN_vec3 result = { a.x / b.x, a.y / b.y, a.z / b.z }; return result; }
template <typename simd_t> static wN_vec3<simd_t>& operator/=(wN_vec3<simd_t>& a, wN_vec3<simd_t> b) { a = a / b; return a; }

template <typename simd_t> static wN_vec3<simd_t> operator*(wN_vec3<simd_t> a, simd_t b) { wN_vec3 result = { a.x * b, a.y * b, a.z * b }; return result; }
template <typename simd_t> static wN_vec3<simd_t> operator*(simd_t a, wN_vec3<simd_t> b) { return b * a; }
template <typename simd_t> static wN_vec3<simd_t>& operator*=(wN_vec3<simd_t>& a, simd_t b) { a = a * b; return a; }
template <typename simd_t> static wN_vec3<simd_t> operator/(wN_vec3<simd_t> a, simd_t b) { wN_vec3 result = { a.x / b, a.y / b, a.z / b }; return result; }
template <typename simd_t> static wN_vec3<simd_t>& operator/=(wN_vec3<simd_t>& a, simd_t b) { a = a / b; return a; }

template <typename simd_t> static wN_vec3<simd_t> operator-(wN_vec3<simd_t> a) { return wN_vec3(-a.x, -a.y, -a.z); }

template <typename simd_t> static auto operator==(wN_vec3<simd_t> a, wN_vec3<simd_t> b) { return a.x == b.x & a.y == b.y & a.z == b.z; }


// Vec4 operators.
template <typename simd_t> static wN_vec4<simd_t> operator+(wN_vec4<simd_t> a, wN_vec4<simd_t> b) { wN_vec4 result = { a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w }; return result; }
template <typename simd_t> static wN_vec4<simd_t>& operator+=(wN_vec4<simd_t>& a, wN_vec4<simd_t> b) { a = a + b; return a; }
template <typename simd_t> static wN_vec4<simd_t> operator-(wN_vec4<simd_t> a, wN_vec4<simd_t> b) { wN_vec4 result = { a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w }; return result; }
template <typename simd_t> static wN_vec4<simd_t>& operator-=(wN_vec4<simd_t>& a, wN_vec4<simd_t> b) { a = a - b; return a; }
template <typename simd_t> static wN_vec4<simd_t> operator*(wN_vec4<simd_t> a, wN_vec4<simd_t> b) { wN_vec4 result = { a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w }; return result; }
template <typename simd_t> static wN_vec4<simd_t>& operator*=(wN_vec4<simd_t>& a, wN_vec4<simd_t> b) { a = a * b; return a; }
template <typename simd_t> static wN_vec4<simd_t> operator/(wN_vec4<simd_t> a, wN_vec4<simd_t> b) { wN_vec4 result = { a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w }; return result; }
template <typename simd_t> static wN_vec4<simd_t> operator/=(wN_vec4<simd_t>& a, wN_vec4<simd_t> b) { a = a / b; return a; }

template <typename simd_t> static wN_vec4<simd_t> operator*(wN_vec4<simd_t> a, simd_t b) { wN_vec4 result = { a.x * b, a.y * b, a.z * b, a.w * b }; return result; }
template <typename simd_t> static wN_vec4<simd_t> operator*(simd_t a, wN_vec4<simd_t> b) { return b * a; }
template <typename simd_t> static wN_vec4<simd_t>& operator*=(wN_vec4<simd_t>& a, simd_t b) { a = a * b; return a; }
template <typename simd_t> static wN_vec4<simd_t> operator/(wN_vec4<simd_t> a, simd_t b) { wN_vec4 result = { a.x / b, a.y / b, a.z / b, a.w / b }; return result; }
template <typename simd_t> static wN_vec4<simd_t>& operator/=(wN_vec4<simd_t>& a, simd_t b) { a = a / b; return a; }

template <typename simd_t> static wN_vec4<simd_t> operator-(wN_vec4<simd_t> a) { return wN_vec4(-a.x, -a.y, -a.z, -a.w); }

template <typename simd_t> static auto operator==(wN_vec4<simd_t> a, wN_vec4<simd_t> b) { return a.x == b.x & a.y == b.y & a.z == b.z & a.w == b.w; }


template <typename simd_t> static simd_t dot(wN_vec2<simd_t> a, wN_vec2<simd_t> b) { simd_t result = fmadd(a.x, b.x, a.y * b.y); return result; }
template <typename simd_t> static simd_t dot(wN_vec3<simd_t> a, wN_vec3<simd_t> b) { simd_t result = fmadd(a.x, b.x, fmadd(a.y, b.y, a.z * b.z)); return result; }
template <typename simd_t> static simd_t dot(wN_vec4<simd_t> a, wN_vec4<simd_t> b) { simd_t result = fmadd(a.x, b.x, fmadd(a.y, b.y, fmadd(a.z, b.z, a.w * b.w))); return result; }

template <typename simd_t> static simd_t cross(wN_vec2<simd_t> a, wN_vec2<simd_t> b) { return fmsub(a.x, b.y, a.y * b.x); }
template <typename simd_t> static wN_vec3<simd_t> cross(wN_vec3<simd_t> a, wN_vec3<simd_t> b) { wN_vec3 result = { fmsub(a.y, b.z, a.z * b.y), fmsub(a.z, b.x, a.x * b.z), fmsub(a.x, b.y, a.y * b.x) }; return result; }

template <typename simd_t> static simd_t squaredLength(wN_vec2<simd_t> a) { return dot(a, a); }
template <typename simd_t> static simd_t squaredLength(wN_vec3<simd_t> a) { return dot(a, a); }
template <typename simd_t> static simd_t squaredLength(wN_vec4<simd_t> a) { return dot(a, a); }

template <typename simd_t> static simd_t length(wN_vec2<simd_t> a) { return sqrt(squaredLength(a)); }
template <typename simd_t> static simd_t length(wN_vec3<simd_t> a) { return sqrt(squaredLength(a)); }
template <typename simd_t> static simd_t length(wN_vec4<simd_t> a) { return sqrt(squaredLength(a)); }

template <typename simd_t> static wN_vec2<simd_t> fmadd(wN_vec2<simd_t> a, wN_vec2<simd_t> b, wN_vec2<simd_t> c) { return { fmadd(a.x, b.x, c.x), fmadd(a.y, b.y, c.y) }; }
template <typename simd_t> static wN_vec3<simd_t> fmadd(wN_vec3<simd_t> a, wN_vec3<simd_t> b, wN_vec3<simd_t> c) { return { fmadd(a.x, b.x, c.x), fmadd(a.y, b.y, c.y), fmadd(a.z, b.z, c.z) }; }
template <typename simd_t> static wN_vec4<simd_t> fmadd(wN_vec4<simd_t> a, wN_vec4<simd_t> b, wN_vec4<simd_t> c) { return { fmadd(a.x, b.x, c.x), fmadd(a.y, b.y, c.y), fmadd(a.z, b.z, c.z), fmadd(a.w, b.w, c.w) }; }

template <typename simd_t, typename cmp_t>
static wN_vec2<simd_t> ifThen(cmp_t cond, wN_vec2<simd_t> ifCase, wN_vec2<simd_t> thenCase)
{ 
	return { ifThen(cond, ifCase.x, thenCase.x), ifThen(cond, ifCase.y, thenCase.y) }; 
}

template <typename simd_t, typename cmp_t>
static wN_vec3<simd_t> ifThen(cmp_t cond, wN_vec3<simd_t> ifCase, wN_vec3<simd_t> thenCase)
{
	return { ifThen(cond, ifCase.x, thenCase.x), ifThen(cond, ifCase.y, thenCase.y), ifThen(cond, ifCase.z, thenCase.z) };
}

template <typename simd_t, typename cmp_t>
static wN_vec4<simd_t> ifThen(cmp_t cond, wN_vec4<simd_t> ifCase, wN_vec4<simd_t> thenCase)
{
	return { ifThen(cond, ifCase.x, thenCase.x), ifThen(cond, ifCase.y, thenCase.y), ifThen(cond, ifCase.z, thenCase.z), ifThen(cond, ifCase.w, thenCase.w) };
}

template <typename simd_t, typename cmp_t>
static wN_quat<simd_t> ifThen(cmp_t cond, wN_quat<simd_t> ifCase, wN_quat<simd_t> thenCase)
{
	return { ifThen(cond, ifCase.x, thenCase.x), ifThen(cond, ifCase.y, thenCase.y), ifThen(cond, ifCase.z, thenCase.z), ifThen(cond, ifCase.w, thenCase.w) };
}

template <typename simd_t> static wN_vec2<simd_t> noz(wN_vec2<simd_t> a) { simd_t sl = squaredLength(a); return ifThen(sl < 1e-8f, wN_vec2<simd_t>::zero(), a * rsqrt(sl)); }
template <typename simd_t> static wN_vec3<simd_t> noz(wN_vec3<simd_t> a) { simd_t sl = squaredLength(a); return ifThen(sl < 1e-8f, wN_vec3<simd_t>::zero(), a * rsqrt(sl)); }
template <typename simd_t> static wN_vec4<simd_t> noz(wN_vec4<simd_t> a) { simd_t sl = squaredLength(a); return ifThen(sl < 1e-8f, wN_vec4<simd_t>::zero(), a * rsqrt(sl)); }

template <typename simd_t> static wN_vec2<simd_t> normalize(wN_vec2<simd_t> a) { simd_t l2 = squaredLength(a); return a * rsqrt(l2); }
template <typename simd_t> static wN_vec3<simd_t> normalize(wN_vec3<simd_t> a) { simd_t l2 = squaredLength(a); return a * rsqrt(l2); }
template <typename simd_t> static wN_vec4<simd_t> normalize(wN_vec4<simd_t> a) { simd_t l2 = squaredLength(a); return a * rsqrt(l2); }

template <typename simd_t> static wN_vec2<simd_t> abs(wN_vec2<simd_t> a) { return wN_vec2(abs(a.x), abs(a.y)); }
template <typename simd_t> static wN_vec3<simd_t> abs(wN_vec3<simd_t> a) { return wN_vec3(abs(a.x), abs(a.y), abs(a.z)); }
template <typename simd_t> static wN_vec4<simd_t> abs(wN_vec4<simd_t> a) { return wN_vec4(abs(a.x), abs(a.y), abs(a.z), abs(a.w)); }

template <typename simd_t> static wN_vec2<simd_t> round(wN_vec2<simd_t> a) { return wN_vec2(round(a.x), round(a.y)); }
template <typename simd_t> static wN_vec3<simd_t> round(wN_vec3<simd_t> a) { return wN_vec3(round(a.x), round(a.y), round(a.z)); }
template <typename simd_t> static wN_vec4<simd_t> round(wN_vec4<simd_t> a) { return wN_vec4(round(a.x), round(a.y), round(a.z), round(a.w)); }

template <typename simd_t> static wN_quat<simd_t> normalize(wN_quat<simd_t> a) { wN_quat<simd_t> result; result.v4 = normalize(a.v4); return result; }
template <typename simd_t> static wN_quat<simd_t> conjugate(wN_quat<simd_t> a) { return { -a.x, -a.y, -a.z, a.w }; }

template <typename simd_t> static wN_quat<simd_t> operator+(wN_quat<simd_t> a, wN_quat<simd_t> b) { wN_quat result; result.v4 = a.v4 + b.v4; return result; }

template <typename simd_t>
static wN_quat<simd_t> operator*(wN_quat<simd_t> a, wN_quat<simd_t> b)
{
	wN_quat<simd_t> result;
	result.w = fmsub(a.w, b.w, dot(a.v, b.v));
	result.v = a.v * b.w + b.v * a.w + cross(a.v, b.v);
	return result;
}

template <typename simd_t> static wN_quat<simd_t> operator*(wN_quat<simd_t> q, simd_t s) { wN_quat result; result.v4 = q.v4 * s;	return result; }
template <typename simd_t> static wN_vec3<simd_t> operator*(wN_quat<simd_t> q, wN_vec3<simd_t> v) { wN_quat p(v.x, v.y, v.z, simd_t::zero()); return (q * p * conjugate(q)).v; }

template <typename simd_t> static auto operator==(wN_quat<simd_t> a, wN_quat<simd_t> b) { return a.x == b.x & a.y == b.y & a.z == b.z & a.w == b.w; }

template <typename simd_t> static wN_vec2<simd_t> lerp(wN_vec2<simd_t> l, wN_vec2<simd_t> u, simd_t t) { return fmadd(wN_vec2<simd_t>(t), u - l, l); }
template <typename simd_t> static wN_vec3<simd_t> lerp(wN_vec3<simd_t> l, wN_vec3<simd_t> u, simd_t t) { return fmadd(wN_vec3<simd_t>(t), u - l, l); }
template <typename simd_t> static wN_vec4<simd_t> lerp(wN_vec4<simd_t> l, wN_vec4<simd_t> u, simd_t t) { return fmadd(wN_vec4<simd_t>(t), u - l, l); }
template <typename simd_t> static wN_quat<simd_t> lerp(wN_quat<simd_t> l, wN_quat<simd_t> u, simd_t t) { wN_quat result; result.v4 = lerp(l.v4, u.v4, t); return normalize(result); }

template <typename simd_t> static wN_vec2<simd_t> exp(wN_vec2<simd_t> v) { return wN_vec2(exp(v.x), exp(v.y)); }
template <typename simd_t> static wN_vec3<simd_t> exp(wN_vec3<simd_t> v) { return wN_vec3(exp(v.x), exp(v.y), exp(v.z)); }
template <typename simd_t> static wN_vec4<simd_t> exp(wN_vec4<simd_t> v) { return wN_vec4(exp(v.x), exp(v.y), exp(v.z), exp(v.w)); }

template <typename simd_t> static wN_vec2<simd_t> pow(wN_vec2<simd_t> v, simd_t e) { return wN_vec2(pow(v.x, e), pow(v.y, e)); }
template <typename simd_t> static wN_vec3<simd_t> pow(wN_vec3<simd_t> v, simd_t e) { return wN_vec3(pow(v.x, e), pow(v.y, e), pow(v.z, e)); }
template <typename simd_t> static wN_vec4<simd_t> pow(wN_vec4<simd_t> v, simd_t e) { return wN_vec4(pow(v.x, e), pow(v.y, e), pow(v.z, e), pow(v.w, e)); }


template <typename simd_t>
static wN_vec2<simd_t> operator*(const wN_mat2<simd_t>& a, wN_vec2<simd_t> b) 
{ 
	wN_vec2<simd_t> result;
	result.x = fmadd(a.m00, b.x, a.m01 * b.y);
	result.y = fmadd(a.m10, b.x, a.m11 * b.y);
	return result;
}

template <typename simd_t>
static wN_vec3<simd_t> operator*(const wN_mat3<simd_t>& a, wN_vec3<simd_t> b)
{
	wN_vec3<simd_t> result;
	result.x = fmadd(a.m00, b.x, fmadd(a.m01, b.y, a.m02 * b.z));
	result.y = fmadd(a.m10, b.x, fmadd(a.m11, b.y, a.m12 * b.z));
	result.z = fmadd(a.m20, b.x, fmadd(a.m21, b.y, a.m22 * b.z));
	return result;
}

template <typename simd_t>
static wN_vec4<simd_t> operator*(const wN_mat4<simd_t>& a, wN_vec4<simd_t> b)
{
	wN_vec4<simd_t> result;
	result.x = fmadd(a.m00, b.x, fmadd(a.m01, b.y, fmadd(a.m02, b.z, a.m03 * b.w)));
	result.y = fmadd(a.m10, b.x, fmadd(a.m11, b.y, fmadd(a.m12, b.z, a.m13 * b.w)));
	result.z = fmadd(a.m20, b.x, fmadd(a.m21, b.y, fmadd(a.m22, b.z, a.m23 * b.w)));
	result.w = fmadd(a.m30, b.x, fmadd(a.m31, b.y, fmadd(a.m32, b.z, a.m33 * b.w)));
	return result;
}

template <typename simd_t>
static wN_mat2<simd_t> operator*(const wN_mat2<simd_t>& a, const wN_mat2<simd_t>& b)
{
	wN_mat2<simd_t> result;

	result.m00 = fmadd(a.m00, b.m00, a.m01 * b.m10);
	result.m01 = fmadd(a.m00, b.m01, a.m01 * b.m11);

	result.m10 = fmadd(a.m10, b.m00, a.m11 * b.m10);
	result.m11 = fmadd(a.m10, b.m01, a.m11 * b.m11);

	return result;
}

template <typename simd_t>
static wN_mat3<simd_t> operator*(const wN_mat3<simd_t>& a, const wN_mat3<simd_t>& b)
{
	wN_mat3<simd_t> result;

	result.m00 = fmadd(a.m00, b.m00, fmadd(a.m01, b.m10, a.m02 * b.m20));
	result.m01 = fmadd(a.m00, b.m01, fmadd(a.m01, b.m11, a.m02 * b.m21));
	result.m02 = fmadd(a.m00, b.m02, fmadd(a.m01, b.m12, a.m02 * b.m22));

	result.m10 = fmadd(a.m10, b.m00, fmadd(a.m11, b.m10, a.m12 * b.m20));
	result.m11 = fmadd(a.m10, b.m01, fmadd(a.m11, b.m11, a.m12 * b.m21));
	result.m12 = fmadd(a.m10, b.m02, fmadd(a.m11, b.m12, a.m12 * b.m22));

	result.m20 = fmadd(a.m20, b.m00, fmadd(a.m21, b.m10, a.m22 * b.m20));
	result.m21 = fmadd(a.m20, b.m01, fmadd(a.m21, b.m11, a.m22 * b.m21));
	result.m22 = fmadd(a.m20, b.m02, fmadd(a.m21, b.m12, a.m22 * b.m22));
	
	return result;
}

template <typename simd_t>
static wN_mat4<simd_t> operator*(const wN_mat4<simd_t>& a, const wN_mat4<simd_t>& b)
{
	wN_mat4<simd_t> result;

	result.m00 = fmadd(a.m00, b.m00, fmadd(a.m01, b.m10, fmadd(a.m02, b.m20, a.m03 * b.m30)));
	result.m01 = fmadd(a.m00, b.m01, fmadd(a.m01, b.m11, fmadd(a.m02, b.m21, a.m03 * b.m31)));
	result.m02 = fmadd(a.m00, b.m02, fmadd(a.m01, b.m12, fmadd(a.m02, b.m22, a.m03 * b.m32)));
	result.m03 = fmadd(a.m00, b.m03, fmadd(a.m01, b.m13, fmadd(a.m02, b.m23, a.m03 * b.m33)));

	result.m10 = fmadd(a.m10, b.m00, fmadd(a.m11, b.m10, fmadd(a.m12, b.m20, a.m13 * b.m30)));
	result.m11 = fmadd(a.m10, b.m01, fmadd(a.m11, b.m11, fmadd(a.m12, b.m21, a.m13 * b.m31)));
	result.m12 = fmadd(a.m10, b.m02, fmadd(a.m11, b.m12, fmadd(a.m12, b.m22, a.m13 * b.m32)));
	result.m13 = fmadd(a.m10, b.m03, fmadd(a.m11, b.m13, fmadd(a.m12, b.m23, a.m13 * b.m33)));

	result.m20 = fmadd(a.m20, b.m00, fmadd(a.m21, b.m10, fmadd(a.m22, b.m20, a.m23 * b.m30)));
	result.m21 = fmadd(a.m20, b.m01, fmadd(a.m21, b.m11, fmadd(a.m22, b.m21, a.m23 * b.m31)));
	result.m22 = fmadd(a.m20, b.m02, fmadd(a.m21, b.m12, fmadd(a.m22, b.m22, a.m23 * b.m32)));
	result.m23 = fmadd(a.m20, b.m03, fmadd(a.m21, b.m13, fmadd(a.m22, b.m23, a.m23 * b.m33)));

	result.m30 = fmadd(a.m30, b.m00, fmadd(a.m31, b.m10, fmadd(a.m32, b.m20, a.m33 * b.m30)));
	result.m31 = fmadd(a.m30, b.m01, fmadd(a.m31, b.m11, fmadd(a.m32, b.m21, a.m33 * b.m31)));
	result.m32 = fmadd(a.m30, b.m02, fmadd(a.m31, b.m12, fmadd(a.m32, b.m22, a.m33 * b.m32)));
	result.m33 = fmadd(a.m30, b.m03, fmadd(a.m31, b.m13, fmadd(a.m32, b.m23, a.m33 * b.m33)));

	return result;
}

template <typename simd_t> static wN_mat2<simd_t> operator*(const wN_mat2<simd_t>& a, simd_t b) { wN_mat2<simd_t> result; for (uint32 i = 0; i < 4; ++i) { result.m[i] = a.m[i] * b; } return result; }
template <typename simd_t> static wN_mat3<simd_t> operator*(const wN_mat3<simd_t>& a, simd_t b) { wN_mat3<simd_t> result; for (uint32 i = 0; i < 9; ++i) { result.m[i] = a.m[i] * b; } return result; }
template <typename simd_t> static wN_mat4<simd_t> operator*(const wN_mat4<simd_t>& a, simd_t b) { wN_mat4<simd_t> result; for (uint32 i = 0; i < 16; ++i) { result.m[i] = a.m[i] * b; } return result; }

template <typename simd_t> static wN_mat2<simd_t> operator*(simd_t b, const wN_mat2<simd_t>& a) { return a * b; }
template <typename simd_t> static wN_mat3<simd_t> operator*(simd_t b, const wN_mat3<simd_t>& a) { return a * b; }
template <typename simd_t> static wN_mat4<simd_t> operator*(simd_t b, const wN_mat4<simd_t>& a) { return a * b; }

template <typename simd_t> static wN_mat2<simd_t> operator+(const wN_mat2<simd_t>& a, const wN_mat2<simd_t>& b) { wN_mat2<simd_t> result; for (uint32 i = 0; i < 4; ++i) { result.m[i] = a.m[i] + b.m[i]; } return result; }
template <typename simd_t> static wN_mat3<simd_t> operator+(const wN_mat3<simd_t>& a, const wN_mat3<simd_t>& b) { wN_mat3<simd_t> result; for (uint32 i = 0; i < 9; ++i) { result.m[i] = a.m[i] + b.m[i]; } return result; }
template <typename simd_t> static wN_mat4<simd_t> operator+(const wN_mat4<simd_t>& a, const wN_mat4<simd_t>& b) { wN_mat4<simd_t> result; for (uint32 i = 0; i < 16; ++i) { result.m[i] = a.m[i] + b.m[i]; } return result; }

template <typename simd_t>
static wN_mat2<simd_t> transpose(const wN_mat2<simd_t>& a)
{
	wN_mat2<simd_t> result;
	result.m00 = a.m00; result.m01 = a.m10;
	result.m10 = a.m01; result.m11 = a.m11;
	return result;
}

template <typename simd_t>
static wN_mat3<simd_t> transpose(const wN_mat3<simd_t>& a)
{
	wN_mat3<simd_t> result;
	result.m00 = a.m00; result.m01 = a.m10; result.m02 = a.m20;
	result.m10 = a.m01; result.m11 = a.m11; result.m12 = a.m21;
	result.m20 = a.m02; result.m21 = a.m12; result.m22 = a.m22;
	return result;
}

template <typename simd_t>
static wN_mat4<simd_t> transpose(const wN_mat4<simd_t>& a)
{
	wN_mat4<simd_t> result;
	result.m00 = a.m00; result.m01 = a.m10; result.m02 = a.m20; result.m03 = a.m30;
	result.m10 = a.m01; result.m11 = a.m11; result.m12 = a.m21; result.m13 = a.m31;
	result.m20 = a.m02; result.m21 = a.m12; result.m22 = a.m22; result.m23 = a.m32;
	result.m30 = a.m03; result.m31 = a.m13; result.m32 = a.m23; result.m33 = a.m32;
	return result;
}

template <typename simd_t>
static wN_mat3<simd_t> getSkewMatrix(wN_vec3<simd_t> r)
{
	simd_t zero = simd_t::zero();
	wN_mat3<simd_t> result;
	result.m00 = zero;
	result.m01 = -r.z;
	result.m02 = r.y;
	result.m10 = r.z;
	result.m11 = zero;
	result.m12 = -r.x;
	result.m20 = -r.y;
	result.m21 = r.x;
	result.m22 = zero;
	return result;
}

template <typename simd_t>
static wN_vec2<simd_t> solveLinearSystem(const wN_mat2<simd_t>& A, wN_vec2<simd_t> b)
{
	wN_vec2<simd_t> ex(A.m00, A.m10);
	wN_vec2<simd_t> ey(A.m01, A.m11);
	simd_t det = cross(ex, ey);
	det = ifThen(det != simd_t::zero(), 1.f / det, det);

	wN_vec2<simd_t> x;
	x.x = det * cross(b, ey);
	x.y = det * cross(ex, b);
	return x;
}

template <typename simd_t>
static wN_vec3<simd_t> solveLinearSystem(const wN_mat3<simd_t>& A, wN_vec3<simd_t> b)
{
	wN_vec3<simd_t> ex(A.m00, A.m10, A.m20);
	wN_vec3<simd_t> ey(A.m01, A.m11, A.m21);
	wN_vec3<simd_t> ez(A.m02, A.m12, A.m22);
	simd_t det = dot(ex, cross(ey, ez));
	det = ifThen(det != simd_t::zero(), 1.f / det, det);

	wN_vec3<simd_t> x;
	x.x = det * dot(b, cross(ey, ez));
	x.y = det * dot(ex, cross(b, ez));
	x.z = det * dot(ex, cross(ey, b));
	return x;
}

template <typename simd_t>
static wN_quat<simd_t> rotateFromTo(wN_vec3<simd_t> _from, wN_vec3<simd_t> _to)
{
	wN_vec3<simd_t> from = normalize(_from);
	wN_vec3<simd_t> to = normalize(_to);

	simd_t zero = simd_t::zero();
	simd_t one = 1.f;

	simd_t d = dot(from, to);
	auto same = d >= 1.f;

	auto largeRotation = d < (1e-6f - 1.f);
	wN_quat<simd_t> q0, q1;

	if (anyTrue(largeRotation))
	{
		// Rotate 180° around some axis.
		wN_vec3<simd_t> axis = cross(wN_vec3<simd_t>(one, zero, zero), from);
		axis = ifThen(squaredLength(axis) == zero, cross(wN_vec3<simd_t>(zero, one, zero), from), axis);
		axis = normalize(axis);
		q0 = normalize(wN_quat<simd_t>(axis, M_PI));
	}

	if (anyFalse(largeRotation))
	{
		simd_t s = sqrt((one + d) * simd_t(2.f));
		simd_t invs = one / s;

		wN_vec3<simd_t> c = cross(from, to);

		q1.x = c.x * invs;
		q1.y = c.y * invs;
		q1.z = c.z * invs;
		q1.w = s * simd_t(0.5f);
		q1 = normalize(q1);
	}

	wN_quat<simd_t> q = ifThen(largeRotation, q0, q1);
	q = ifThen(same, wN_quat<simd_t>(zero, zero, zero, one), q);
	return q;
}

template <typename simd_t>
void getAxisRotation(wN_quat<simd_t> q, wN_vec3<simd_t>& axis, simd_t& angle)
{
	simd_t zero = simd_t::zero();
	simd_t one = 1.f;

	angle = zero;
	axis = wN_vec3<simd_t>(one, zero, zero);

	simd_t sqLength = squaredLength(q.v);
	auto mask = sqLength > zero;
	if (anyTrue(mask))
	{
		simd_t angleOverride = simd_t(2.f) * acos(q.w);
		simd_t invLength = one / sqrt(sqLength);
		wN_vec3<simd_t> axisOverride = q.v * invLength;

		angle = ifThen(mask, angleOverride, angle);
		axis = ifThen(mask, axisOverride, axis);
	}
}

template <typename simd_t>
wN_vec3<simd_t> getTangent(wN_vec3<simd_t> normal)
{
	auto mask = abs(normal.x) > simd_t(0.57735f);
	wN_vec3<simd_t> tangent = ifThen(mask, wN_vec3<simd_t>(normal.y, -normal.x, simd_t::zero()), wN_vec3<simd_t>(simd_t::zero(), normal.z, -normal.y));
	return normalize(tangent);
}

template <typename simd_t>
void getTangents(wN_vec3<simd_t> normal, wN_vec3<simd_t>& outTangent, wN_vec3<simd_t>& outBitangent)
{
	outTangent = getTangent(normal);
	outBitangent = cross(normal, outTangent);
}


template<typename simd_t>
inline wN_quat<simd_t>::wN_quat(wN_vec3<simd_t> axis, simd_t angle)
{
	simd_t h = 0.5f;
	w = cos(angle * h);
	v = axis * sin(angle * h);
}

template<typename simd_t>
inline wN_mat2<simd_t>::wN_mat2(
	simd_t m00, simd_t m01, 
	simd_t m10, simd_t m11)
	:
	m00(m00), m01(m01),
	m10(m10), m11(m11) {}

template<typename simd_t>
inline wN_mat3<simd_t>::wN_mat3(
	simd_t m00, simd_t m01, simd_t m02, 
	simd_t m10, simd_t m11, simd_t m12, 
	simd_t m20, simd_t m21, simd_t m22)
	:
	m00(m00), m01(m01), m02(m02),
	m10(m10), m11(m11), m12(m12),
	m20(m20), m21(m21), m22(m22) {}

template<typename simd_t>
inline wN_mat4<simd_t>::wN_mat4(
	simd_t m00, simd_t m01, simd_t m02, simd_t m03, 
	simd_t m10, simd_t m11, simd_t m12, simd_t m13, 
	simd_t m20, simd_t m21, simd_t m22, simd_t m23, 
	simd_t m30, simd_t m31, simd_t m32, simd_t m33)
	:
	m00(m00), m01(m01), m02(m02), m03(m03),
	m10(m10), m11(m11), m12(m12), m13(m13),
	m20(m20), m21(m21), m22(m22), m23(m23),
	m30(m30), m31(m31), m32(m32), m33(m33) {}


#if defined(SIMD_SSE_2)
typedef wN_vec2<w4_float> w4_vec2;
typedef wN_vec3<w4_float> w4_vec3;
typedef wN_vec4<w4_float> w4_vec4;
typedef wN_quat<w4_float> w4_quat;
typedef wN_mat2<w4_float> w4_mat2;
typedef wN_mat3<w4_float> w4_mat3;
typedef wN_mat4<w4_float> w4_mat4;
#endif

#if defined(SIMD_AVX_2)
typedef wN_vec2<w8_float> w8_vec2;
typedef wN_vec3<w8_float> w8_vec3;
typedef wN_vec4<w8_float> w8_vec4;
typedef wN_quat<w8_float> w8_quat;
typedef wN_mat2<w8_float> w8_mat2;
typedef wN_mat3<w8_float> w8_mat3;
typedef wN_mat4<w8_float> w8_mat4;
#endif

#if defined(SIMD_AVX_512)
typedef wN_vec2<w16_float> w16_vec2;
typedef wN_vec3<w16_float> w16_vec3;
typedef wN_vec4<w16_float> w16_vec4;
typedef wN_quat<w16_float> w16_quat;
typedef wN_mat2<w16_float> w16_mat2;
typedef wN_mat3<w16_float> w16_mat3;
typedef wN_mat4<w16_float> w16_mat4;
#endif

```

`src/core/memory.cpp`:

```cpp
#include "pch.h"
#include "memory.h"
#include "math.h"

void memory_arena::initialize(uint64 minimumBlockSize, uint64 reserveSize)
{
	reset(true);

	memory = (uint8*)VirtualAlloc(0, reserveSize, MEM_RESERVE, PAGE_READWRITE);

	SYSTEM_INFO systemInfo;
	GetSystemInfo(&systemInfo);

	pageSize = systemInfo.dwPageSize;
	sizeLeftTotal = reserveSize;
	this->minimumBlockSize = minimumBlockSize;
	this->reserveSize = reserveSize;
}

void memory_arena::ensureFreeSize(uint64 size)
{
	mutex.lock();
	ensureFreeSizeInternal(size);
	mutex.unlock();
}

void memory_arena::ensureFreeSizeInternal(uint64 size)
{
	if (sizeLeftCurrent < size)
	{
		uint64 allocationSize = max(size, minimumBlockSize);
		allocationSize = pageSize * bucketize(allocationSize, pageSize); // Round up to next page boundary.
		VirtualAlloc(memory + committedMemory, allocationSize, MEM_COMMIT, PAGE_READWRITE);

		sizeLeftTotal += allocationSize;
		sizeLeftCurrent += allocationSize;
		committedMemory += allocationSize;
	}
}

void* memory_arena::allocate(uint64 size, uint64 alignment, bool clearToZero)
{
	if (size == 0)
	{
		return 0;
	}

	mutex.lock();

	uint64 mask = alignment - 1;
	uint64 misalignment = current & mask;
	uint64 adjustment = (misalignment == 0) ? 0 : (alignment - misalignment);
	current += adjustment;

	sizeLeftCurrent -= adjustment;
	sizeLeftTotal -= adjustment;

	ASSERT(sizeLeftTotal >= size);

	ensureFreeSizeInternal(size);

	uint8* result = memory + current;
	current += size;
	sizeLeftCurrent -= size;
	sizeLeftTotal -= size;

	mutex.unlock();

	if (clearToZero)
	{
		memset(result, 0, size);
	}

	return result;
}

void* memory_arena::getCurrent(uint64 alignment)
{
	return memory + alignTo(current, alignment);
}

void memory_arena::setCurrentTo(void* ptr)
{
	current = (uint8*)ptr - memory;
	sizeLeftCurrent = committedMemory - current;
	sizeLeftTotal = reserveSize - current;
}

void memory_arena::reset(bool freeMemory)
{
	if (memory && freeMemory)
	{
		VirtualFree(memory, 0, MEM_RELEASE);
		memory = 0;
		committedMemory = 0;
	}

	resetToMarker(memory_marker{ 0 });
}

memory_marker memory_arena::getMarker()
{
	return { current };
}

void memory_arena::resetToMarker(memory_marker marker)
{
	current = marker.before;
	sizeLeftCurrent = committedMemory - current;
	sizeLeftTotal = reserveSize - current;
}

```

`src/core/memory.h`:

```h
#pragma once

#define KB(n) (1024ull * (n))
#define MB(n) (1024ull * KB(n))
#define GB(n) (1024ull * MB(n))

#define BYTE_TO_KB(b) ((b) / 1024)
#define BYTE_TO_MB(b) ((b) / (1024 * 1024))
#define BYTE_TO_GB(b) ((b) / (1024 * 1024))

static uint32 alignTo(uint32 currentOffset, uint32 alignment)
{
	uint32 mask = alignment - 1;
	uint32 misalignment = currentOffset & mask;
	uint32 adjustment = (misalignment == 0) ? 0 : (alignment - misalignment);
	return currentOffset + adjustment;
}

static uint64 alignTo(uint64 currentOffset, uint64 alignment)
{
	uint64 mask = alignment - 1;
	uint64 misalignment = currentOffset & mask;
	uint64 adjustment = (misalignment == 0) ? 0 : (alignment - misalignment);
	return currentOffset + adjustment;
}

static void* alignTo(void* currentAddress, uint64 alignment)
{
	uint64 mask = alignment - 1;
	uint64 misalignment = (uint64)(currentAddress)&mask;
	uint64 adjustment = (misalignment == 0) ? 0 : (alignment - misalignment);
	return (uint8*)currentAddress + adjustment;
}

static bool rangesOverlap(uint64 fromA, uint64 toA, uint64 fromB, uint64 toB)
{
	if (toA <= fromB || fromA >= toA) return false;
	return true;
}

static bool rangesOverlap(void* fromA, void* toA, void* fromB, void* toB)
{
	if (toA <= fromB || fromA >= toB) return false;
	return true;
}

struct memory_marker
{
	uint64 before;
};

struct memory_arena
{
	memory_arena() {}
	memory_arena(const memory_arena&) = delete;
	memory_arena(memory_arena&&) = default;
	~memory_arena() { reset(true); }

	void initialize(uint64 minimumBlockSize = 0, uint64 reserveSize = GB(8));


	void ensureFreeSize(uint64 size);

	void* allocate(uint64 size, uint64 alignment = 1, bool clearToZero = false);

	template <typename T>
	T* allocate(uint32 count = 1, bool clearToZero = false)
	{
		return (T*)allocate(sizeof(T) * count, alignof(T), clearToZero);
	}


	// Get and set current are not thread safe.

	void* getCurrent(uint64 alignment = 1);

	template <typename T>
	T* getCurrent()
	{
		return (T*)getCurrent(alignof(T));
	}

	void setCurrentTo(void* ptr);


	void reset(bool freeMemory = false);

	memory_marker getMarker();
	void resetToMarker(memory_marker marker);

	uint8* base() { return memory; }


protected:

	void ensureFreeSizeInternal(uint64 size);

	uint8* memory = 0;
	uint64 committedMemory = 0;

	uint64 current = 0;
	uint64 sizeLeftCurrent = 0;

	uint64 sizeLeftTotal = 0;

	uint64 pageSize = 0;
	uint64 minimumBlockSize = 0;

	uint64 reserveSize = 0;

	std::mutex mutex;
};

struct scope_temp_memory
{
	memory_arena& arena;
	memory_marker marker;

	scope_temp_memory(memory_arena& arena) : arena(arena), marker(arena.getMarker()) {}
	~scope_temp_memory() { arena.resetToMarker(marker); }
};


```

`src/core/nearest_neighbor.cpp`:

```cpp
#include "pch.h"
#include "nearest_neighbor.h"

#include <nanoflann/nanoflann.hpp>


point_cloud::point_cloud(vec3* positions, uint32 numPositions)
{
    using kd_tree_t = nanoflann::KDTreeSingleIndexAdaptor<
        nanoflann::L2_Simple_Adaptor<float, point_cloud>,
        point_cloud, 3>;

    this->positions = positions;
    this->numPositions = numPositions;

    this->index = new kd_tree_t(3, *this, { 10 });
}

point_cloud::~point_cloud()
{
    using kd_tree_t = nanoflann::KDTreeSingleIndexAdaptor<
        nanoflann::L2_Simple_Adaptor<float, point_cloud>,
        point_cloud, 3>;

    kd_tree_t* index = (kd_tree_t*)this->index;

    delete index;
}

nearest_neighbor_query_result point_cloud::nearestNeighborIndex(vec3 query)
{
    using kd_tree_t = nanoflann::KDTreeSingleIndexAdaptor<
        nanoflann::L2_Simple_Adaptor<float, point_cloud>,
        point_cloud, 3>;

    kd_tree_t* index = (kd_tree_t*)this->index;

    size_t resultIndex;
    float squaredDistance;
    nanoflann::KNNResultSet<float> resultSet(1);
    resultSet.init(&resultIndex, &squaredDistance);

    index->findNeighbors(resultSet, &query.data[0]);

    return { (uint32)resultIndex, squaredDistance };
}

```

`src/core/nearest_neighbor.h`:

```h
#pragma once

#include "math.h"

struct nearest_neighbor_query_result
{
	uint32 index;
	float squaredDistance;
};

struct point_cloud
{
	vec3* positions;
	uint32 numPositions;

	void* index;

	point_cloud(vec3* positions, uint32 numPositions);
	~point_cloud();

	nearest_neighbor_query_result nearestNeighborIndex(vec3 query);





	inline size_t kdtree_get_point_count() const { return numPositions; }
	inline float kdtree_get_pt(const size_t idx, const size_t dim) const { return positions[idx].data[dim]; }
	template <typename BBOX> bool kdtree_get_bbox(BBOX& bb) const { return false; }
};

```

`src/core/perlin.cpp`:

```cpp
#include "pch.h"
#include "perlin.h"
#include "math.h"

#include <array>

// Adapted from Ken Perlin's improved reference implementation: https://cs.nyu.edu/~perlin/noise/

static float fade(float t) 
{ 
    return t * t * t * (t * (t * 6.f - 15.f) + 10.f); 
}

static float grad(int hash, float x, float y, float z) 
{
    int h = hash & 15;                      // CONVERT LO 4 BITS OF HASH CODE
    float u = h < 8 ? x : y,                 // INTO 12 GRADIENT DIRECTIONS.
        v = h < 4 ? y : h == 12 || h == 14 ? x : z;
    return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);
}

static constexpr std::array<uint8, 512> initializePerlin()
{
    constexpr uint8 permutation[] =
    {
        151,160,137,91,90,15,
        131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
        190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
        88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
        77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
        102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
        135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
        5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
        223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
        129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
        251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
        49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180
    };

    std::array<uint8, 512> result = { };
    for (uint32 i = 0; i < 256; i++)
    {
        result[256 + i] = result[i] = permutation[i];
    }
    return result;
}

static const std::array<uint8, 512> p = initializePerlin();

float perlinNoise(float x, float y, float z) 
{
    float flooredX = floor(x);
    float flooredY = floor(y);
    float flooredZ = floor(z);

    int X = (int)flooredX & 255,                  // FIND UNIT CUBE THAT
        Y = (int)flooredY & 255,                  // CONTAINS POINT.
        Z = (int)flooredZ & 255;

    x -= flooredX;                                // FIND RELATIVE X,Y,Z
    y -= flooredY;                                // OF POINT IN CUBE.
    z -= flooredZ;

    float u = fade(x),                                // COMPUTE FADE CURVES
        v = fade(y),                                // FOR EACH OF X,Y,Z.
        w = fade(z);

    int A = p[X] + Y, AA = p[A] + Z, AB = p[A + 1] + Z,      // HASH COORDINATES OF
        B = p[X + 1] + Y, BA = p[B] + Z, BB = p[B + 1] + Z;      // THE 8 CUBE CORNERS,

    return 
        lerp(
            lerp( 
                lerp(
                    grad(p[AA], x, y, z),
					grad(p[BA], x - 1, y, z),
                    u),
				lerp(
                    grad(p[AB], x, y - 1, z),
					grad(p[BB], x - 1, y - 1, z),
                    u),
                v),
			lerp( 
                lerp( 
                    grad(p[AA + 1], x, y, z - 1),
					grad(p[BA + 1], x - 1, y, z - 1),
                    u),
				lerp(
                    grad(p[AB + 1], x, y - 1, z - 1),
					grad(p[BB + 1], x - 1, y - 1, z - 1),
                    u),
                v),
            w)
        + 0.5f;
}

```

`src/core/perlin.h`:

```h
#pragma once

// Returns values between 0 and 1.
float perlinNoise(float x, float y = 0.f, float z = 0.f);

```

`src/core/preprocessor_for_each.h`:

```h
#pragma once



#define EXPAND(x) x

#define NARGS_SEQ(_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11,_12,_13,_14,_15,_16,_17,_18,_19,_20,_21,_22,_23,_24,_25,_26,_27,_28,_29,_30,N,...) N
#define NARGS(...) EXPAND(NARGS_SEQ(__VA_ARGS__, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1))

#define CHOOSE_MACRO(macro, ...) CONCATENATE(macro, NARGS(__VA_ARGS__))

#define CONCATENATE__(a, b) a##b
#define CONCATENATE_(a, b) CONCATENATE__(a, b)
#define CONCATENATE(a, b) CONCATENATE_(a, b)



#define FOR_EACH_1( macro_1, macro_n, constant, value, ...)	EXPAND(macro_1(constant, value))
#define FOR_EACH_2( macro_1, macro_n, constant, value, ...)	EXPAND(macro_n(constant, value)	EXPAND(FOR_EACH_1 (macro_1, macro_n, constant, __VA_ARGS__)))
#define FOR_EACH_3( macro_1, macro_n, constant, value, ...)	EXPAND(macro_n(constant, value)	EXPAND(FOR_EACH_2 (macro_1, macro_n, constant, __VA_ARGS__)))
#define FOR_EACH_4( macro_1, macro_n, constant, value, ...)	EXPAND(macro_n(constant, value)	EXPAND(FOR_EACH_3 (macro_1, macro_n, constant, __VA_ARGS__)))
#define FOR_EACH_5( macro_1, macro_n, constant, value, ...)	EXPAND(macro_n(constant, value)	EXPAND(FOR_EACH_4 (macro_1, macro_n, constant, __VA_ARGS__)))
#define FOR_EACH_6( macro_1, macro_n, constant, value, ...)	EXPAND(macro_n(constant, value)	EXPAND(FOR_EACH_5 (macro_1, macro_n, constant, __VA_ARGS__)))
#define FOR_EACH_7( macro_1, macro_n, constant, value, ...)	EXPAND(macro_n(constant, value)	EXPAND(FOR_EACH_6 (macro_1, macro_n, constant, __VA_ARGS__)))
#define FOR_EACH_8( macro_1, macro_n, constant, value, ...)	EXPAND(macro_n(constant, value)	EXPAND(FOR_EACH_7 (macro_1, macro_n, constant, __VA_ARGS__)))
#define FOR_EACH_9( macro_1, macro_n, constant, value, ...)	EXPAND(macro_n(constant, value)	EXPAND(FOR_EACH_8 (macro_1, macro_n, constant, __VA_ARGS__)))
#define FOR_EACH_10(macro_1, macro_n, constant, value, ...)	EXPAND(macro_n(constant, value)	EXPAND(FOR_EACH_9 (macro_1, macro_n, constant, __VA_ARGS__)))
#define FOR_EACH_11(macro_1, macro_n, constant, value, ...)	EXPAND(macro_n(constant, value)	EXPAND(FOR_EACH_10(macro_1, macro_n, constant, __VA_ARGS__)))
#define FOR_EACH_12(macro_1, macro_n, constant, value, ...)	EXPAND(macro_n(constant, value)	EXPAND(FOR_EACH_11(macro_1, macro_n, constant, __VA_ARGS__)))
#define FOR_EACH_13(macro_1, macro_n, constant, value, ...)	EXPAND(macro_n(constant, value)	EXPAND(FOR_EACH_12(macro_1, macro_n, constant, __VA_ARGS__)))
#define FOR_EACH_14(macro_1, macro_n, constant, value, ...)	EXPAND(macro_n(constant, value)	EXPAND(FOR_EACH_13(macro_1, macro_n, constant, __VA_ARGS__)))
#define FOR_EACH_15(macro_1, macro_n, constant, value, ...)	EXPAND(macro_n(constant, value)	EXPAND(FOR_EACH_14(macro_1, macro_n, constant, __VA_ARGS__)))
#define FOR_EACH_16(macro_1, macro_n, constant, value, ...)	EXPAND(macro_n(constant, value)	EXPAND(FOR_EACH_15(macro_1, macro_n, constant, __VA_ARGS__)))
#define FOR_EACH_17(macro_1, macro_n, constant, value, ...)	EXPAND(macro_n(constant, value)	EXPAND(FOR_EACH_16(macro_1, macro_n, constant, __VA_ARGS__)))
#define FOR_EACH_18(macro_1, macro_n, constant, value, ...)	EXPAND(macro_n(constant, value)	EXPAND(FOR_EACH_17(macro_1, macro_n, constant, __VA_ARGS__)))
#define FOR_EACH_19(macro_1, macro_n, constant, value, ...)	EXPAND(macro_n(constant, value)	EXPAND(FOR_EACH_18(macro_1, macro_n, constant, __VA_ARGS__)))
#define FOR_EACH_20(macro_1, macro_n, constant, value, ...)	EXPAND(macro_n(constant, value)	EXPAND(FOR_EACH_19(macro_1, macro_n, constant, __VA_ARGS__)))
#define FOR_EACH_21(macro_1, macro_n, constant, value, ...)	EXPAND(macro_n(constant, value)	EXPAND(FOR_EACH_20(macro_1, macro_n, constant, __VA_ARGS__)))
#define FOR_EACH_22(macro_1, macro_n, constant, value, ...)	EXPAND(macro_n(constant, value)	EXPAND(FOR_EACH_21(macro_1, macro_n, constant, __VA_ARGS__)))
#define FOR_EACH_23(macro_1, macro_n, constant, value, ...)	EXPAND(macro_n(constant, value)	EXPAND(FOR_EACH_22(macro_1, macro_n, constant, __VA_ARGS__)))
#define FOR_EACH_24(macro_1, macro_n, constant, value, ...)	EXPAND(macro_n(constant, value)	EXPAND(FOR_EACH_23(macro_1, macro_n, constant, __VA_ARGS__)))
#define FOR_EACH_25(macro_1, macro_n, constant, value, ...)	EXPAND(macro_n(constant, value)	EXPAND(FOR_EACH_24(macro_1, macro_n, constant, __VA_ARGS__)))
#define FOR_EACH_26(macro_1, macro_n, constant, value, ...)	EXPAND(macro_n(constant, value)	EXPAND(FOR_EACH_25(macro_1, macro_n, constant, __VA_ARGS__)))
#define FOR_EACH_27(macro_1, macro_n, constant, value, ...)	EXPAND(macro_n(constant, value)	EXPAND(FOR_EACH_26(macro_1, macro_n, constant, __VA_ARGS__)))
#define FOR_EACH_28(macro_1, macro_n, constant, value, ...)	EXPAND(macro_n(constant, value)	EXPAND(FOR_EACH_27(macro_1, macro_n, constant, __VA_ARGS__)))
#define FOR_EACH_29(macro_1, macro_n, constant, value, ...)	EXPAND(macro_n(constant, value)	EXPAND(FOR_EACH_28(macro_1, macro_n, constant, __VA_ARGS__)))
#define FOR_EACH_30(macro_1, macro_n, constant, value, ...)	EXPAND(macro_n(constant, value)	EXPAND(FOR_EACH_29(macro_1, macro_n, constant, __VA_ARGS__)))


#define MACRO_FOR_EACH(macro_1, macro_n, constant, ...) EXPAND(CHOOSE_MACRO(FOR_EACH_, __VA_ARGS__)(macro_1, macro_n, constant, __VA_ARGS__))



```

`src/core/profiling_internal.cpp`:

```cpp
#include "pch.h"
#define PROFILING_INTERNAL
#include "profiling_internal.h"
#include "core/imgui.h"
#include "core/input.h"

bool handleProfileEvent(profile_event* events, uint32 eventIndex, uint32 numEvents, uint16* stack, uint32& d, profile_block* blocks, uint32& numBlocksUsed, uint64& frameEndTimestamp, bool lookahead)
{
	profile_event* e = events + eventIndex;

	bool result = false;

	switch (e->type)
	{
		case profile_event_begin_block:
		{
		rehandleEvent:
			uint64 timestamp = e->timestamp;


			// The end event of one block often has the exact same timestamp as the begin event of the next block(s).
			// When recording events multithreaded (e.g. when rendering on multiple cores), the order of these events 
			// in the CPU-side array may not be correct.
			// We thus search for possible end blocks with the same timestamp here and - if we already saw a matching 
			// begin block earlier - process them first.

			if (lookahead && d > 0)
			{
				profile_block* currentStackTop = blocks + stack[d - 1];

				for (uint32 j = eventIndex + 1; j < numEvents && events[j].timestamp == timestamp; ++j)
				{
					if (events[j].type == profile_event_end_block
						&& events[j].threadID != e->threadID				// Event is from another thread than current event. Events on the same thread are always in the correct order.
						&& events[j].threadID == currentStackTop->threadID	// Event is from the same thread as current stack top.
						&& events[j].name == currentStackTop->name)			// Event has the same name as current stack top.
					{
						--d;
						currentStackTop->endClock = timestamp;

						events[j].type = profile_event_none; // Mark as handled.
						goto rehandleEvent;
					}
				}
			}

			uint32 index = numBlocksUsed++;
			profile_block& block = blocks[index];

			block.startClock = timestamp;
			block.endClock = 0;
			block.parent = (d == 0) ? INVALID_PROFILE_BLOCK : stack[d - 1];
			block.name = e->name;
			block.threadID = e->threadID;
			block.firstChild = INVALID_PROFILE_BLOCK;
			block.lastChild = INVALID_PROFILE_BLOCK;
			block.nextSibling = INVALID_PROFILE_BLOCK;

			if (block.parent != INVALID_PROFILE_BLOCK) // d > 0.
			{
				profile_block* parent = blocks + block.parent;

				if (parent->firstChild == INVALID_PROFILE_BLOCK)
				{
					parent->firstChild = index;
				}
				if (parent->lastChild != INVALID_PROFILE_BLOCK)
				{
					profile_block* lastChild = blocks + parent->lastChild;
					lastChild->nextSibling = index;
				}
				parent->lastChild = index;
			}
			else if (stack[d] != INVALID_PROFILE_BLOCK) // d is guaranteed to be 0 here. Therefore we can check for the validity of the stack element. This is always initialized.
			{
				profile_block* current = blocks + stack[d];
				current->nextSibling = index;
			}

			stack[d] = index;
			++d;
		} break;

		case profile_event_end_block:
		{
			--d;

			profile_block* block = blocks + stack[d];
			ASSERT(block->name == e->name);

			block->endClock = e->timestamp;
		} break;

		case profile_event_frame_marker:
		{
			frameEndTimestamp = e->timestamp;
			result = true;
		} break;
	}

	return result;
}

void copyProfileBlocks(profile_block* src, uint16* stack, uint32 depth, profile_block* dest, uint32& numDestBlocks)
{
	for (uint32 d = 0; d < depth; ++d)
	{
		uint32 index = numDestBlocks++;
		profile_block& old = src[stack[d]];
		profile_block& block = dest[index];

		block.startClock = old.startClock;
		block.endClock = 0;
		block.parent = (d == 0) ? INVALID_PROFILE_BLOCK : stack[d - 1];
		block.name = old.name;
		block.threadID = old.threadID;
		block.firstChild = INVALID_PROFILE_BLOCK;
		block.lastChild = INVALID_PROFILE_BLOCK;
		block.nextSibling = INVALID_PROFILE_BLOCK;

		if (block.parent != INVALID_PROFILE_BLOCK) // d > 0.
		{
			profile_block* parent = dest + block.parent;

			if (parent->firstChild == INVALID_PROFILE_BLOCK)
			{
				parent->firstChild = index;
			}
			parent->lastChild = index;
		}

		stack[d] = index;
	}
}





static const ImColor highlightFrameColor = ImGui::green;


static const float timelineBottom = 400.f;
static const float rightPadding = 50.f;
static const float highlightTop = timelineBottom + 150.f;
static const float verticalBarStride = 40.f;

static const ImColor colorTable[] =
{
	ImColor(107, 142, 35), 
	ImColor(220, 20, 60), 
	ImColor(128, 0, 0), 
	ImColor(124, 252, 0), 
	ImColor(60, 179, 113), 
	ImColor(250, 235, 215), 
	ImColor(0, 100, 0), 
	ImColor(0, 255, 255), 
	ImColor(143, 188, 143), 
	ImColor(233, 150, 122), 
	ImColor(255, 255, 0), 
	ImColor(147, 112, 219), 
	ImColor(255, 69, 0), 
	ImColor(255, 215, 0), 
	ImColor(221, 160, 221), 
	ImColor(25, 25, 112), 
	ImColor(138, 43, 226), 
	ImColor(0, 128, 128), 
	ImColor(0, 191, 255), 
	ImColor(189, 183, 107), 
	ImColor(176, 224, 230), 
	ImColor(65, 105, 225), 
	ImColor(255, 250, 240), 
	ImColor(139, 69, 19), 
	ImColor(245, 255, 250), 
	ImColor(188, 143, 143), 
};

profiler_timeline::profiler_timeline(profiler_persistent& persistent, uint32 numFrames)
	: persistent(persistent), numFrames(numFrames)
{
	totalWidth = ImGui::GetContentRegionAvail().x - leftPadding - rightPadding;

	barHeight16ms = 100.f;
	barHeight33ms = barHeight16ms * 2.f;

	rightEdge = leftPadding + totalWidth;
	horizontalBarStride = totalWidth / numFrames;
	barWidth = horizontalBarStride/* * 0.9f*/;

	callStackTop = highlightTop;
}

bool profiler_timeline::drawHeader(bool& pauseRecording)
{
	bool result = false;
	if (ImGui::Button(pauseRecording ? (ICON_FA_PLAY "  Resume recording") : (ICON_FA_PAUSE "  Pause recording")))
	{
		pauseRecording = !pauseRecording;
		result = true;
	}
	ImGui::SameLine();
	ImGui::Text("The last %u frames are recorded. Click on one frame to get a detailed hierarchical view of all blocks. Zoom into detail view with mouse wheel and click and drag to shift the display.", numFrames);
	return result;
}

void profiler_timeline::drawOverviewFrame(profile_frame& frame, uint32 frameIndex, uint32 currentFrame)
{
	if (frame.duration > 0.f)
	{
		float left = leftPadding + frameIndex * horizontalBarStride;
		float height = frame.duration / (1000.f / 60.f) * barHeight16ms;
		if (height > 0.f)
		{
			float top = timelineBottom - height;

			ImGui::PushID(frameIndex);

			ImGui::SetCursorPos(ImVec2(left, top));

			ImColor color = (frameIndex == persistent.highlightFrameIndex) ? highlightFrameColor : ImGui::red;
			color = (frameIndex == currentFrame) ? ImGui::yellow : color;

			bool result = ImGui::ColorButton("", color, ImGuiColorEditFlags_NoTooltip | ImGuiColorEditFlags_NoBorder, ImVec2(barWidth, height));
			if (ImGui::IsItemHovered())
			{
				ImGui::SetTooltip("Frame %llu (%fms)", frame.globalFrameID, frame.duration);
			}

			if (result)
			{
				persistent.highlightFrameIndex = frameIndex;
			}

			ImGui::PopID();
		}
	}
}

void profiler_timeline::endOverview()
{
	ImGui::SetCursorPos(ImVec2(leftPadding, timelineBottom - barHeight16ms - 1));
	ImGui::ColorButton("##60FPS", ImGui::white, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoTooltip | ImGuiColorEditFlags_NoBorder, ImVec2(totalWidth, 1));

	ImGui::SetCursorPos(ImVec2(leftPadding, timelineBottom - barHeight33ms - 1));
	ImGui::ColorButton("##30FPS", ImGui::white, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoTooltip | ImGuiColorEditFlags_NoBorder, ImVec2(totalWidth, 1));

	ImGui::SetCursorPos(ImVec2(rightEdge + 3.f, timelineBottom - barHeight16ms - 1));
	ImGui::Text("16.7ms");

	ImGui::SetCursorPos(ImVec2(rightEdge + 3.f, timelineBottom - barHeight33ms - 1));
	ImGui::Text("33.3ms");
}

void profiler_timeline::drawHighlightFrameInfo(profile_frame& frame)
{
	ImGui::SetCursorPos(ImVec2(leftPadding, highlightTop - 80.f));
	ImGui::Text("Frame %llu (%fms)", frame.globalFrameID, frame.duration);
}

void profiler_timeline::drawCallStack(profile_block* blocks, uint16 startIndex, const char* name)
{
#if 0
	ImGui::SameLine();
	if (ImGui::Button("Dump this frame to stdout"))
	{
		uint16 currentIndex = 0;
		uint32 depth = 0;

		while (currentIndex != INVALID_PROFILE_BLOCK)
		{
			profile_block* current = blocks + currentIndex;

			for (uint32 i = 0; i < depth; ++i)
			{
				std::cout << " ";
			}
			std::cout << current->name << '\n';

			// Advance.
			uint16 nextIndex = current->firstChild;
			if (nextIndex == INVALID_PROFILE_BLOCK)
			{
				nextIndex = current->nextSibling;

				if (nextIndex == INVALID_PROFILE_BLOCK)
				{
					uint16 nextAncestor = current->parent;
					while (nextAncestor != INVALID_PROFILE_BLOCK)
					{
						--depth;
						if (blocks[nextAncestor].nextSibling != INVALID_PROFILE_BLOCK)
						{
							nextIndex = blocks[nextAncestor].nextSibling;
							break;
						}
						nextAncestor = blocks[nextAncestor].parent;
					}
				}
			}
			else
			{
				++depth;
			}
			currentIndex = nextIndex;
		}
	}
#endif

	if (name)
	{
		ImGui::SetCursorPos(ImVec2(leftPadding, callStackTop - 5.f));
		ImGui::Text(name);
	}

	if (callStackTop != highlightTop)
	{
		ImGui::SetCursorPos(ImVec2(leftPadding, callStackTop - 5.f));
		ImGui::ColorButton("", ImGui::white, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoTooltip | ImGuiColorEditFlags_NoBorder, ImVec2(totalWidth + rightPadding, 1));
	}

	static const float barHeight = verticalBarStride * 0.8f;

	const float frameWidth16ms = totalWidth * persistent.frameWidthMultiplier;
	const float frameWidth33ms = frameWidth16ms * 2.f;

	// Call stack.
	uint16 currentIndex = startIndex;
	uint32 depth = 0;
	uint32 maxDepth = 0;

	while (currentIndex != INVALID_PROFILE_BLOCK)
	{
		profile_block* current = blocks + currentIndex;

		// Draw.
		float top = callStackTop + depth * verticalBarStride;
		float left = persistent.callstackLeftPadding + current->relStart / (1000.f / 60.f) * frameWidth16ms;
		float width = current->duration / (1000.f / 60.f) * frameWidth16ms;
		if (width > 0.f) // Important. ImGui renders zero-size elements with a default size (> 0).
		{
			ImGui::SetCursorPos(ImVec2(left, top));
			ImGui::ColorButton(current->name, colorTable[colorIndex++],
				ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoTooltip | ImGuiColorEditFlags_NoBorder | ImGuiColorEditFlags_NoDragDrop,
				ImVec2(width, barHeight));

			if (ImGui::IsItemHovered())
			{
				ImGui::SetTooltip("%s: %.3fms", current->name, current->duration);
			}

			ImGui::PushClipRect(ImGui::GetItemRectMin(), ImGui::GetItemRectMax(), true);
			ImGui::SetCursorPos(ImVec2(left + ImGui::GetStyle().FramePadding.x, top + ImGui::GetStyle().FramePadding.y));
			ImGui::Text("%s: %.3fms%s", current->name, current->duration, (current->endClock == 0) ? " (continues in next frame" : "");
			ImGui::PopClipRect();


			if (colorIndex >= arraysize(colorTable))
			{
				colorIndex = 0;
			}
		}



		// Advance.
		uint16 nextIndex = current->firstChild;
		if (nextIndex == INVALID_PROFILE_BLOCK)
		{
			nextIndex = current->nextSibling;

			if (nextIndex == INVALID_PROFILE_BLOCK)
			{
				uint16 nextAncestor = current->parent;
				while (nextAncestor != INVALID_PROFILE_BLOCK)
				{
					--depth;
					if (blocks[nextAncestor].nextSibling != INVALID_PROFILE_BLOCK)
					{
						nextIndex = blocks[nextAncestor].nextSibling;
						break;
					}
					nextAncestor = blocks[nextAncestor].parent;
				}
			}
		}
		else
		{
			++depth;
			maxDepth = max(depth, maxDepth);
		}
		currentIndex = nextIndex;
	}

	ASSERT(depth == 0);

	callStackTop += (maxDepth + 1) * verticalBarStride + 10.f;
}

void profiler_timeline::drawMillisecondSpacings(profile_frame& frame)
{
	const float frameWidth16ms = totalWidth * persistent.frameWidthMultiplier;
	const float frameWidth33ms = frameWidth16ms * 2.f;

	float callStackHeight = callStackTop - highlightTop;

	const float textSpacing = 30.f;
	const float lineHeight = callStackHeight + textSpacing;
	const float lineTop = highlightTop - textSpacing;

	// 0ms.
	ImGui::SetCursorPos(ImVec2(persistent.callstackLeftPadding, lineTop));
	ImGui::ColorButton("##0ms", ImGui::white, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoTooltip | ImGuiColorEditFlags_NoBorder, ImVec2(1, lineHeight));

	ImGui::SetCursorPos(ImVec2(persistent.callstackLeftPadding + 2, lineTop - 5));
	ImGui::Text("0ms");

	// 16ms.
	ImGui::SetCursorPos(ImVec2(persistent.callstackLeftPadding + frameWidth16ms, lineTop));
	ImGui::ColorButton("##16ms", ImGui::white, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoTooltip | ImGuiColorEditFlags_NoBorder, ImVec2(1, lineHeight));

	ImGui::SetCursorPos(ImVec2(persistent.callstackLeftPadding + frameWidth16ms + 2, lineTop - 5));
	ImGui::Text("16.7ms");

	// 33ms.
	ImGui::SetCursorPos(ImVec2(persistent.callstackLeftPadding + frameWidth33ms, lineTop));
	ImGui::ColorButton("##33ms", ImGui::white, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoTooltip | ImGuiColorEditFlags_NoBorder, ImVec2(1, lineHeight));

	ImGui::SetCursorPos(ImVec2(persistent.callstackLeftPadding + frameWidth33ms + 2, lineTop - 5));
	ImGui::Text("33.3ms");


	// 1ms spacings.
	const ImVec4 normalColor(0.2f, 0.2f, 0.2f, 1.f);
	const ImVec4 specialColor(0.5f, 0.5f, 0.5f, 1.f);

	const float millisecondSpacing = frameWidth33ms / (1000.f / 30.f);
	for (uint32 i = 1; i <= 33; ++i)
	{
		ImVec4 color = (i % 5 == 0) ? specialColor : normalColor;

		ImGui::SetCursorPos(ImVec2(persistent.callstackLeftPadding + i * millisecondSpacing, lineTop + 8));
		ImGui::ColorButton("", color, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoTooltip | ImGuiColorEditFlags_NoBorder, ImVec2(1, lineHeight));
	}

	// Frame end.
	ImGui::SetCursorPos(ImVec2(persistent.callstackLeftPadding + frame.duration * millisecondSpacing, lineTop));
	ImGui::ColorButton("##Frame end", ImGui::blue, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoTooltip | ImGuiColorEditFlags_NoBorder, ImVec2(1, lineHeight));

	ImGui::SetCursorPos(ImVec2(persistent.callstackLeftPadding + frame.duration * millisecondSpacing + 2, lineTop - 5));
	ImGui::Text("Frame end");
}

void profiler_timeline::handleUserInteractions()
{
	const float frameWidth16ms = totalWidth * persistent.frameWidthMultiplier;
	const float frameWidth33ms = frameWidth16ms * 2.f;

	float callStackHeight = callStackTop - highlightTop;

	const float textSpacing = 30.f;
	const float lineHeight = callStackHeight + textSpacing;
	const float lineTop = highlightTop - textSpacing;



	// Invisible widget to block window dragging in this area.
	ImGui::SetCursorPos(ImVec2(leftPadding, highlightTop));
	ImGui::InvisibleButton("Blocker", ImVec2(totalWidth + rightPadding, callStackHeight));


	ImVec2 mousePos = ImGui::GetMousePos();
	ImVec2 windowPos = ImGui::GetWindowPos();

	float relMouseX = mousePos.x - windowPos.x;

	bool overStack = false;
	if (!ImGui::IsPopupOpen("", ImGuiPopupFlags_AnyPopupId) && // If dropdown or smth is open, don't interact with call stack.
		ImGui::IsMouseHoveringRect(ImVec2(leftPadding + windowPos.x, highlightTop + windowPos.y), ImVec2(leftPadding + totalWidth + rightPadding + windowPos.x, highlightTop + callStackHeight + windowPos.y), false))
	{
		overStack = true;

		// Hover time.
		float hoveredX = ImGui::GetMousePos().x - ImGui::GetWindowPos().x;
		float hoveredTime = (hoveredX - persistent.callstackLeftPadding) / frameWidth33ms * (1000.f / 30.f);
		ImGui::SetCursorPos(ImVec2(hoveredX, lineTop));
		ImGui::ColorButton("", ImGui::yellow, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoTooltip | ImGuiColorEditFlags_NoBorder, ImVec2(1, lineHeight));

		ImGui::SetCursorPos(ImVec2(hoveredX + 2, lineTop - 5));
		ImGui::Text("%.3fms", hoveredTime);
	}


	// Horizontal scrolling.

	if (!ImGui::IsMouseDown(ImGuiPopupFlags_MouseButtonLeft))
	{
		persistent.horizontalScrolling = false;
	}
	if (overStack && ImGui::IsMouseClicked(ImGuiPopupFlags_MouseButtonLeft))
	{
		persistent.horizontalScrollAnchor = relMouseX;
		persistent.horizontalScrolling = true;
	}
	if (persistent.horizontalScrolling)
	{
		persistent.callstackLeftPadding += relMouseX - persistent.horizontalScrollAnchor;
		persistent.horizontalScrollAnchor = relMouseX;
	}


	// Zooming.

	if (overStack)
	{
		float zoom = ImGui::GetIO().MouseWheel;

		if (zoom != 0.f && ImGui::IsKeyDown(key_ctrl))
		{
			float t = inverseLerp(persistent.callstackLeftPadding, persistent.callstackLeftPadding + frameWidth16ms, relMouseX);

			persistent.frameWidthMultiplier += zoom * 0.1f;
			persistent.frameWidthMultiplier = max(persistent.frameWidthMultiplier, 0.2f);

			float newFrameWidth16ms = totalWidth * persistent.frameWidthMultiplier;
			persistent.callstackLeftPadding = relMouseX - t * newFrameWidth16ms;
		}
	}

	ImGui::SetCursorPos(ImVec2(leftPadding, highlightTop + callStackHeight));
}

```

`src/core/profiling_internal.h`:

```h
#pragma once

#define COMPOSITE_VARNAME_(a, b) a##b
#define COMPOSITE_VARNAME(a, b) COMPOSITE_VARNAME_(a, b)


enum profile_event_type : uint16
{
	profile_event_frame_marker,
	profile_event_begin_block,
	profile_event_end_block,

	profile_event_none,
};

struct profile_event
{
	profile_event_type type;
	uint16 clType; // For gpu profiler.
	uint32 threadID;
	const char* name;
	uint64 timestamp;
};


#ifdef PROFILING_INTERNAL

#define INVALID_PROFILE_BLOCK 0xFFFF

struct profile_block
{
	uint16 firstChild;
	uint16 lastChild;
	uint16 nextSibling;
	uint16 parent;

	uint64 startClock;
	uint64 endClock;

	float relStart;
	float duration;

	uint32 threadID;

	const char* name;
};

struct profile_frame
{
	uint64 startClock;
	uint64 endClock;
	uint64 globalFrameID;

	float duration;
};

static const float leftPadding = 5.f;

struct profiler_persistent
{
	uint32 highlightFrameIndex = -1;

	float frameWidthMultiplier = 1.f;
	float callstackLeftPadding = leftPadding;

	float horizontalScrollAnchor = 0;
	bool horizontalScrolling = false;
};

struct profiler_timeline
{
	uint32 numFrames;
	float totalWidth;

	float barHeight16ms;
	float barHeight33ms;

	float rightEdge;
	float horizontalBarStride;
	float barWidth;
	float callStackTop;

	uint32 colorIndex = 0;

	profiler_persistent& persistent;


	profiler_timeline(profiler_persistent& persistent, uint32 numFrames);
	bool drawHeader(bool& pauseRecording);
	void drawOverviewFrame(profile_frame& frame, uint32 frameIndex, uint32 currentFrame);
	void endOverview();

	void drawHighlightFrameInfo(profile_frame& frame);
	void drawCallStack(profile_block* blocks, uint16 startIndex, const char* name = 0);
	void drawMillisecondSpacings(profile_frame& frame);
	void handleUserInteractions();
};

// Returns true if frame-end marker is found.
bool handleProfileEvent(profile_event* events, uint32 eventIndex, uint32 numEvents, uint16* stack, uint32& d, profile_block* blocks, uint32& numBlocksUsed, uint64& frameEndTimestamp, bool lookahead);
void copyProfileBlocks(profile_block* src, uint16* stack, uint32 depth, profile_block* dest, uint32& numDestBlocks);

#endif

```

`src/core/random.h`:

```h
#pragma once

#include "math.h"

struct random_number_generator
{
	// XOR shift generator.

	uint64 state;

	random_number_generator() {}
	random_number_generator(uint64 seed) { state = seed; }

	inline uint64 randomUint64()
	{
		// https://en.wikipedia.org/wiki/Xorshift

		uint64 x = state;
		x ^= x << 13;
		x ^= x >> 7;
		x ^= x << 17;
		state = x;
		return x;
	}

	inline uint32 randomUint32()
	{
		return (uint32)randomUint64();
	}

	inline uint64 randomUint64Between(uint64 lo, uint64 hi)
	{
		return randomUint64() % (hi - lo) + lo;
	}

	inline uint32 randomUint32Between(uint32 lo, uint32 hi)
	{
		return randomUint32() % (hi - lo) + lo;
	}

	inline float randomFloat01()
	{
		return randomUint32() / (float)UINT_MAX;
	}

	inline float randomFloatBetween(float lo, float hi)
	{
		return remap(randomFloat01(), 0.f, 1.f, lo, hi);
	}

	inline vec2 randomVec2Between(float lo, float hi)
	{
		return vec2(
			randomFloatBetween(lo, hi),
			randomFloatBetween(lo, hi));
	}

	inline vec3 randomVec3Between(float lo, float hi)
	{
		return vec3(
			randomFloatBetween(lo, hi),
			randomFloatBetween(lo, hi),
			randomFloatBetween(lo, hi));
	}

	inline vec4 randomVec4Between(float lo, float hi)
	{
		return vec4(
			randomFloatBetween(lo, hi),
			randomFloatBetween(lo, hi),
			randomFloatBetween(lo, hi),
			randomFloatBetween(lo, hi));
	}

	inline vec3 randomPointOnUnitSphere()
	{
		return normalize(randomVec3Between(-1.f, 1.f));
	}

	inline quat randomRotation(float maxAngle = M_PI)
	{
		return quat(randomPointOnUnitSphere(), randomFloatBetween(-maxAngle, maxAngle));
	}
};

static float halton(uint32 index, uint32 base)
{
	float fraction = 1.f;
	float result = 0.f;
	while (index > 0)
	{
		fraction /= (float)base;
		result += fraction * (index % base);
		index = ~~(index / base);
	}
	return result;
}

static vec2 halton23(uint32 index)
{
	return vec2(halton(index, 2), halton(index, 3));
}



static uint32 hash(uint32 x)
{
	x += (x << 10u);
	x ^= (x >> 6u);
	x += (x << 3u);
	x ^= (x >> 11u);
	x += (x << 15u);
	return x;
}

// Compound versions of the hashing algorithm I whipped together.
static uint32 hash(uint32 x, uint32 y) { return hash(x ^ hash(y)); }
static uint32 hash(uint32 x, uint32 y, uint32 z) { return hash(x ^ hash(y) ^ hash(z)); }
static uint32 hash(uint32 x, uint32 y, uint32 z, uint32 w) { return hash(x ^ hash(y) ^ hash(z) ^ hash(w)); }


inline float asfloat(uint32 u) { return *(float*)&u; }
inline uint32 asuint(float f) { return *(uint32*)&f; }

// Construct a float with half-open range [0:1] using low 23 bits.
// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.
static float floatConstruct(uint32 m)
{
	const uint32 ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask
	const uint32 ieeeOne = 0x3F800000u; // 1.0 in IEEE binary32

	m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)
	m |= ieeeOne;                          // Add fractional part to 1.0

	float  f = asfloat(m);       // Range [1:2]
	return f - 1.f;              // Range [0:1]
}

// Pseudo-random value in half-open range [0:1].
static float random1(float x) { return floatConstruct(hash(asuint(x))); }
static float random1(vec2 v)  { return floatConstruct(hash(asuint(v.x), asuint(v.y))); }
static float random1(vec3 v)  { return floatConstruct(hash(asuint(v.x), asuint(v.y), asuint(v.z))); }
static float random1(vec4 v)  { return floatConstruct(hash(asuint(v.x), asuint(v.y), asuint(v.z), asuint(v.w))); }

static vec2 random2(vec2 v) { return vec2(floatConstruct(hash(asuint(v.x * 15123.6989f))), floatConstruct(hash(asuint(v.y * 6192.234f)))); }
static vec3 random3(vec3 v) { return vec3(floatConstruct(hash(asuint(v.x * 15123.6989f))), floatConstruct(hash(asuint(v.y * 6192.234f))), floatConstruct(hash(asuint(v.z * 31923.123f)))); }

static vec3 valueNoise(vec2 x)
{
	vec2 p = floor(x);
	vec2 w = frac(x);

	vec2 u = w * w * w * (w * (w * 6.f - 15.f) + 10.f);
	vec2 du = 30.f * w * w * (w * (w - 2.f) + 1.f);

	float a = random1(p);
	float b = random1(p + vec2(1, 0));
	float c = random1(p + vec2(0, 1));
	float d = random1(p + vec2(1, 1));

	float k0 = a;
	float k1 = b - a;
	float k2 = c - a;
	float k3 = a - b - c + d;

	float value = -1.f + 2.f * (k0 + k1 * u.x + k2 * u.y + k3 * u.x * u.y);
	vec2 deriv = 2.f * du *
		vec2(
			k1 + k3 * u.y,
			k2 + k3 * u.x);

	return vec3(value, deriv.x, deriv.y);
}

static vec4 valueNoise(vec3 x)
{
	vec3 p = floor(x);
	vec3 w = frac(x);

	vec3 u = w * w * w * (w * (w * 6.f - 15.f) + 10.f);
	vec3 du = 30.f * w * w * (w * (w - 2.f) + 1.f);

	float a = random1(p + vec3(0, 0, 0));
	float b = random1(p + vec3(1, 0, 0));
	float c = random1(p + vec3(0, 1, 0));
	float d = random1(p + vec3(1, 1, 0));
	float e = random1(p + vec3(0, 0, 1));
	float f = random1(p + vec3(1, 0, 1));
	float g = random1(p + vec3(0, 1, 1));
	float h = random1(p + vec3(1, 1, 1));

	float k0 = a;
	float k1 = b - a;
	float k2 = c - a;
	float k3 = e - a;
	float k4 = a - b - c + d;
	float k5 = a - c - e + g;
	float k6 = a - b - e + f;
	float k7 = -a + b + c - d + e - f - g + h;

	float value = -1.f + 2.f * (k0 + k1 * u.x + k2 * u.y + k3 * u.z + k4 * u.x * u.y + k5 * u.y * u.z + k6 * u.z * u.x + k7 * u.x * u.y * u.z);
	vec3 deriv = 2.f * du * 
		vec3(
			k1 + k4 * u.y + k6 * u.z + k7 * u.y * u.z,
			k2 + k5 * u.z + k4 * u.x + k7 * u.z * u.x,
			k3 + k6 * u.x + k5 * u.y + k7 * u.x * u.y);

	return vec4(value, deriv.x, deriv.y, deriv.z);
}

static vec3 gradientNoise(vec2 x)
{
	vec2 p = floor(x);
	vec2 w = frac(x);

	vec2 u = w * w * w * (w * (w * 6.f - 15.f) + 10.f);
	vec2 du = 30.f * w * w * (w * (w - 2.f) + 1.f);

	// Gradients
	vec2 ga = random2(p);
	vec2 gb = random2(p + vec2(1, 0));
	vec2 gc = random2(p + vec2(0, 1));
	vec2 gd = random2(p + vec2(1, 1));

	// Projections
	float va = dot(ga, w);
	float vb = dot(gb, w - vec2(1, 0));
	float vc = dot(gc, w - vec2(0, 1));
	float vd = dot(gd, w - vec2(1, 1));

	// Interpolation
	float v = va +
		u.x * (vb - va) +
		u.y * (vc - va) +
		u.x * u.y * (va - vb - vc + vd);

	float k = (va - vb - vc + vd);

	vec2 d = ga +
		u.x * (gb - ga) +
		u.y * (gc - ga) +
		u.x * u.y * (ga - gb - gc + gd) +

		du * vec2(
			vb - va + u.y * k,
			vc - va + u.x * k
		);

	return vec3(v, d.x, d.y);
}

static vec4 gradientNoise(vec3 x)
{
	vec3 p = floor(x);
	vec3 w = frac(x);

	vec3 u = w * w * w * (w * (w * 6.f - 15.f) + 10.f);
	vec3 du = 30.f * w * w * (w * (w - 2.f) + 1.f);

	// Gradients
	vec3 ga = random3(p + vec3(0, 0, 0));
	vec3 gb = random3(p + vec3(1, 0, 0));
	vec3 gc = random3(p + vec3(0, 1, 0));
	vec3 gd = random3(p + vec3(1, 1, 0));
	vec3 ge = random3(p + vec3(0, 0, 1));
	vec3 gf = random3(p + vec3(1, 0, 1));
	vec3 gg = random3(p + vec3(0, 1, 1));
	vec3 gh = random3(p + vec3(1, 1, 1));

	// Projections
	float va = dot(ga, w - vec3(0, 0, 0));
	float vb = dot(gb, w - vec3(1, 0, 0));
	float vc = dot(gc, w - vec3(0, 1, 0));
	float vd = dot(gd, w - vec3(1, 1, 0));
	float ve = dot(ge, w - vec3(0, 0, 1));
	float vf = dot(gf, w - vec3(1, 0, 1));
	float vg = dot(gg, w - vec3(0, 1, 1));
	float vh = dot(gh, w - vec3(1, 1, 1));

	// Interpolation
	float v = va +
		u.x * (vb - va) +
		u.y * (vc - va) +
		u.z * (ve - va) +
		u.x * u.y * (va - vb - vc + vd) +
		u.y * u.z * (va - vc - ve + vg) +
		u.z * u.x * (va - vb - ve + vf) +
		u.x * u.y * u.z * (-va + vb + vc - vd + ve - vf - vg + vh);

	vec3 yzx(u.y, u.z, u.x);
	vec3 zxy(u.z, u.x, u.y);

	vec3 d = ga +
		u.x * (gb - ga) +
		u.y * (gc - ga) +
		u.z * (ge - ga) +
		u.x * u.y * (ga - gb - gc + gd) +
		u.y * u.z * (ga - gc - ge + gg) +
		u.z * u.x * (ga - gb - ge + gf) +
		u.x * u.y * u.z * (-ga + gb + gc - gd + ge - gf - gg + gh) +

		du * (vec3(vb - va, vc - va, ve - va) +
			yzx * vec3(va - vb - vc + vd, va - vc - ve + vg, va - vb - ve + vf) +
			zxy * vec3(va - vb - ve + vf, va - vb - vc + vd, va - vc - ve + vg) +
			yzx * zxy * (-va + vb + vc - vd + ve - vf - vg + vh));

	return vec4(v, d.x, d.y, d.z);
}

typedef vec3(*fbm_noise_2D)(vec2);
typedef vec4(*fbm_noise_3D)(vec3);

static vec3 fbm(fbm_noise_2D noiseFunc, vec2 x, uint32 numOctaves = 6, float lacunarity = 1.98f, float gain = 0.49f)
{
	float value = 0.f;
	float amplitude = 0.5f;

	vec2 deriv(0.f);
	float m = 1.f;

	for (uint32 i = 0; i < numOctaves; ++i)
	{
		vec3 n = noiseFunc(x);

		ASSERT(n.x <= 1.f);
		ASSERT(n.x >= -1.f);

		value += amplitude * n.x;		// Accumulate values.
		deriv += amplitude * m * n.yz;  // Accumulate derivatives.

		amplitude *= gain;

		x *= lacunarity;
		m *= lacunarity;
	}
	return vec3(value, deriv.x, deriv.y);
}

static vec4 fbm(fbm_noise_3D noiseFunc, vec3 x, uint32 numOctaves = 6, float lacunarity = 1.98f, float gain = 0.49f)
{
	float value = 0.f;
	float amplitude = 0.5;

	vec3 deriv(0.f);
	float m = 1.f;

	for (uint32 i = 0; i < numOctaves; ++i)
	{
		vec4 n = noiseFunc(x);

		value += amplitude * n.x;		// Accumulate values.
		deriv += amplitude * m * n.yzw; // Accumulate derivatives.

		amplitude *= gain;

		x *= lacunarity;
		m *= lacunarity;
	}
	return vec4(value, deriv.x, deriv.y, deriv.z);
}


```

`src/core/reflect.h`:

```h
#pragma once

#include "preprocessor_for_each.h"

#include <type_traits>
#include <ostream>

template <typename T> struct type_descriptor {};

struct member_list_base {};

template <auto... member_pointers>
struct member_list : member_list_base
{
	static inline const uint32 numMembers = sizeof...(member_pointers);

	template <typename T, typename F>
	constexpr static auto applyImpl(F f, T& v, const char* memberNames[numMembers])
	{
		uint32 i = 0;
		([&]
		{
			f(memberNames[i], v.*member_pointers);
			++i;
		} (), ...);
	}
};

#define EXTRACT_MEMBER(member, ...) member			// Extract the member from the tuple.
#define EXTRACT_MEMBER_NAME_1(member) #member		// If no name is supplied, extract and stringify the member name.
#define EXTRACT_MEMBER_NAME_2(member, name) name	// Else, extract the supplied name.

// member_tuple is either (member) or (member, custom name).
// EXTRACT_MEMBER member_tuple expands to EXTRACT_MEMBER (member, name). The parentheses come from the tuple itself (ugly af).
#define MEMBER_POINTER_1(struct_name, member_tuple) &struct_name::EXTRACT_MEMBER member_tuple // Used for one-element reflection (or last loop iteration).
#define MEMBER_POINTER_N(struct_name, member_tuple) MEMBER_POINTER_1(struct_name, member_tuple),

#define MEMBER_NAME_(...) EXPAND(CHOOSE_MACRO(EXTRACT_MEMBER_NAME_, __VA_ARGS__)(__VA_ARGS__))	// Choose EXTRACT_MEMBER_NAME 1 or 2 depending on whether a name is supplied.
#define MEMBER_NAME(struct_name, member_tuple) MEMBER_NAME_ member_tuple, // Same trick with the parenthesis as above.

#define REFLECT_STRUCT(name, ...)																									\
	template<> struct type_descriptor<name> : member_list<MACRO_FOR_EACH(MEMBER_POINTER_1, MEMBER_POINTER_N, name, __VA_ARGS__)>	\
	{																																\
		static inline const char* memberNames[] = { MACRO_FOR_EACH(MEMBER_NAME, MEMBER_NAME, , __VA_ARGS__) };						\
		static inline const char* structName = #name;																				\
		template <typename T, typename F> constexpr static auto apply(F f, T& v) { return applyImpl(f, v, memberNames); }			\
    };


template <typename T> struct is_reflected : std::is_base_of<member_list_base, type_descriptor<T>> {};
template <typename T> inline constexpr bool is_reflected_v = is_reflected<T>::value;


template <typename T, typename = std::enable_if_t<is_reflected_v<T>>>
static std::ostream& operator<<(std::ostream& o, const T& v)
{
	o << type_descriptor<T>::structName << " = {\n";
	type_descriptor<T>::apply(
		[&o](const char* name, const auto& member)
		{
			o << "   " << name << " = " << member << ";\n";
		},
		v
	);
	o << "}\n";
	return o;
}


// USAGE:

#if 0

struct test_reflect
{
	float v = 1.f;
	int a = 1;
	std::string test = "asd";
	vec3 lightDirection;
};
REFLECT_STRUCT(test_reflect,
	(v), // Reflect member v.
	(a, "A"), // You can optionally supply a custom name.
	(test),
	(lightDirection, "Light direction")
);




// Printing the reflected struct.
test_reflect test = { 2.f, 6123 };
std::cout << test << '\n';



#endif



```

`src/core/simd.h`:

```h
#pragma once


#include <emmintrin.h>
#include <immintrin.h>

#define SIMD_SSE_2 // All x64 processors support SSE2.

#if defined(__AVX__)
#if defined(__AVX512F__)
#define SIMD_AVX_512
#define SIMD_AVX_2
#elif defined(__AVX2__)
#define SIMD_AVX_2
#else
#error Vanilla AVX not supported.
#endif
#endif


#define POLY0(x, c0) (c0)
#define POLY1(x, c0, c1) fmadd(POLY0(x, c1), x, (c0))
#define POLY2(x, c0, c1, c2) fmadd(POLY1(x, c1, c2), x, (c0))
#define POLY3(x, c0, c1, c2, c3) fmadd(POLY2(x, c1, c2, c3), x, (c0))
#define POLY4(x, c0, c1, c2, c3, c4) fmadd(POLY3(x, c1, c2, c3, c4), x, (c0))


template <typename float_t>
static float_t cosInternal(float_t x)
{
	const float_t tp = 1.f / (2.f * 3.14159265359f);
	const float_t q = 0.25f;
	const float_t h = 0.5f;
	const float_t o = 1.f;
	const float_t s = 16.f;
	const float_t v = 0.225f;

	x *= tp;
	x -= q + floor(x + q);
	x *= s * (abs(x) - h);
	x += v * x * (abs(x) - o);
	return x;
}

template <typename float_t> 
static float_t sinInternal(float_t x) 
{ 
	return cosInternal(x - (3.14159265359f * 0.5f)); 
}

template <typename float_t, typename int_t>
static float_t exp2Internal(float_t x)
{
	x = minimum(x, 129.00000f);
	x = maximum(x, -126.99999f);

	int_t ipart = convert(x - 0.5f);
	float_t fpart = x - convert(ipart);
	float_t expipart = reinterpret((ipart + 127) << 23);
	float_t expfpart = POLY3(fpart, 9.9992520e-1f, 6.9583356e-1f, 2.2606716e-1f, 7.8024521e-2f);
	return expipart * expfpart;
}

template <typename float_t, typename int_t>
static float_t log2Internal(float_t x)
{
	int_t exp = 0x7F800000;
	int_t mant = 0x007FFFFF;

	float_t one = 1;
	int_t i = reinterpret(x);

	float_t e = convert(((i & exp) >> 23) - 127);
	float_t m = reinterpret(i & mant) | one;
	float_t p = POLY4(m, 2.8882704548164776201f, -2.52074962577807006663f, 1.48116647521213171641f, -0.465725644288844778798f, 0.0596515482674574969533f);

	return fmadd(p, m - one, e);
}

template <typename float_t, typename int_t>
static float_t powInternal(float_t x, float_t y)
{
	return exp2Internal<float_t, int_t>(log2Internal<float_t, int_t>(x) * y);
}

template <typename float_t, typename int_t>
static float_t expInternal(float_t x)
{
	float_t a = 12102203.f; // (1 << 23) / log(2).
	int_t b = 127 * (1 << 23) - 298765;
	int_t t = convert(a * x) + b;
	return reinterpret(t);
}

template <typename float_t>
static float_t tanhInternal(float_t x)
{
	float_t a = exp(x);
	float_t b = exp(-x);
	return (a - b) / (a + b);
}

template <typename float_t, typename int_t>
static float_t atanInternal(float_t x)
{
	const int_t sign_mask = 0x80000000;
	const float_t b = 0.596227f;

	// Extract the sign bit.
	int_t ux_s = sign_mask & reinterpret(x);

	// Calculate the arctangent in the first quadrant.
	float_t bx_a = abs(b * x);
	float_t num = fmadd(x, x, bx_a);
	float_t atan_1q = num / (1.f + bx_a + num);

	// Restore the sign bit.
	int_t atan_2q = ux_s | reinterpret(atan_1q);
	return reinterpret(atan_2q) * float_t(3.14159265359f * 0.5f);
}

template <typename float_t, typename int_t>
static float_t atan2Internal(float_t y, float_t x)
{
	const int_t sign_mask = 0x80000000;
	const float_t b = 0.596227f;

	// Extract the sign bits.
	int_t ux_s = sign_mask & reinterpret(x);
	int_t uy_s = sign_mask & reinterpret(y);

	// Determine the quadrant offset.
	float_t q = convert(((~ux_s & uy_s) >> 29) | (ux_s >> 30));

	// Calculate the arctangent in the first quadrant.
	float_t bxy_a = abs(b * x * y);
	float_t num = fmadd(y, y, bxy_a);
	float_t atan_1q = num / (fmadd(x, x, bxy_a + num));

	// Translate it to the proper quadrant.
	int_t uatan_2q = (ux_s ^ uy_s) | reinterpret(atan_1q);

	float_t result04 = q + reinterpret(uatan_2q); // In the [0, 4) range for the 4 quadrants.

	auto negQuadrant = result04 >= 2.f;
	float_t result = ifThen(negQuadrant, result04 - 4.f, result04);
	return result * float_t(3.14159265359f * 0.5f);
}

template <typename float_t>
static float_t acosInternal(float_t x)
{
	// https://developer.download.nvidia.com/cg/acos.html

	float_t negate = ifThen(x < 0.f, 1.f, 0.f);
	x = abs(x);
	float_t ret = -0.0187293f;
	ret = fmadd(ret, x, 0.0742610f);
	ret = fmadd(ret, x, -0.2121144f);
	ret = fmadd(ret, x, 1.5707288f);
	ret = ret * sqrt(1.f - x);
	ret = ret - negate * ret * float_t(2.f);
	return fmadd(negate, 3.14159265359f, ret);
}


#if defined(SIMD_SSE_2)

struct w4_float
{
	__m128 f;

	w4_float() {}
	w4_float(float f_) { f = _mm_set1_ps(f_); }
	w4_float(__m128 f_) { f = f_; }
	w4_float(float a, float b, float c, float d) { f = _mm_setr_ps(a, b, c, d); }
	w4_float(const float* f_) { f = _mm_loadu_ps(f_); }

#if defined(SIMD_AVX_2)
	w4_float(const float* baseAddress, __m128i indices) { f = _mm_i32gather_ps(baseAddress, indices, 4); }
	w4_float(const float* baseAddress, int a, int b, int c, int d) : w4_float(baseAddress, _mm_setr_epi32(a, b, c, d)) {}
#else
	w4_float(const float* baseAddress, int a, int b, int c, int d) { f = _mm_setr_ps(baseAddress[a], baseAddress[b], baseAddress[c], baseAddress[d]);  }
	w4_float(const float* baseAddress, __m128i indices) : w4_float(baseAddress, indices.m128i_i32[0], indices.m128i_i32[1], indices.m128i_i32[2], indices.m128i_i32[3]) {}
#endif

	operator __m128() { return f; }
	float operator[](uint32 i) const { return this->f.m128_f32[i]; }

	void store(float* f_) const { _mm_storeu_ps(f_, f); }

#if defined(SIMD_AVX_512)
	void scatter(float* baseAddress, __m128i indices) { _mm_i32scatter_ps(baseAddress, indices, f, 4); }
	void scatter(float* baseAddress, int a, int b, int c, int d) { scatter(baseAddress, _mm_setr_epi32(a, b, c, d)); }
#else
	void scatter(float* baseAddress, int a, int b, int c, int d) const
	{
		baseAddress[a] = this->f.m128_f32[0];
		baseAddress[b] = this->f.m128_f32[1];
		baseAddress[c] = this->f.m128_f32[2];
		baseAddress[d] = this->f.m128_f32[3];
	}

	void scatter(float* baseAddress, __m128i indices) const
	{
		baseAddress[indices.m128i_i32[0]] = this->f.m128_f32[0];
		baseAddress[indices.m128i_i32[1]] = this->f.m128_f32[1];
		baseAddress[indices.m128i_i32[2]] = this->f.m128_f32[2];
		baseAddress[indices.m128i_i32[3]] = this->f.m128_f32[3];
	}
#endif

	static w4_float allOnes() { const float nnan = (const float&)0xFFFFFFFF; return nnan; }
	static w4_float zero() { return _mm_setzero_ps(); }
};

struct w4_int
{
	__m128i i;

	w4_int() {}
	w4_int(int i_) { i = _mm_set1_epi32(i_); }
	w4_int(__m128i i_) { i = i_; }
	w4_int(int a, int b, int c, int d) { i = _mm_setr_epi32(a, b, c, d); }
	w4_int(int* i_) { i = _mm_loadu_si128((const __m128i*)i_); }

#if defined(SIMD_AVX_2)
	w4_int(const int* baseAddress, __m128i indices) { i = _mm_i32gather_epi32(baseAddress, indices, 4); }
	w4_int(const int* baseAddress, int a, int b, int c, int d) : w4_int(baseAddress, _mm_setr_epi32(a, b, c, d)) {}
#else
	w4_int(const int* baseAddress, int a, int b, int c, int d) { i = _mm_setr_epi32(baseAddress[a], baseAddress[b], baseAddress[c], baseAddress[d]); }
	w4_int(const int* baseAddress, __m128i indices) : w4_int(baseAddress, indices.m128i_i32[0], indices.m128i_i32[1], indices.m128i_i32[2], indices.m128i_i32[3]) {}
#endif

	operator __m128i() { return i; }
	int operator[](uint32 i) const { return this->i.m128i_i32[i]; }

	void store(int* i_) const { _mm_storeu_si128((__m128i*)i_, i); }

#if defined(SIMD_AVX_512)
	void scatter(int* baseAddress, __m128i indices) { _mm_i32scatter_epi32(baseAddress, indices, i, 4); }
	void scatter(int* baseAddress, int a, int b, int c, int d) { scatter(baseAddress, _mm_setr_epi32(a, b, c, d)); }
#else
	void scatter(int* baseAddress, int a, int b, int c, int d) const
	{
		baseAddress[a] = this->i.m128i_i32[0];
		baseAddress[b] = this->i.m128i_i32[1];
		baseAddress[c] = this->i.m128i_i32[2];
		baseAddress[d] = this->i.m128i_i32[3];
	}

	void scatter(int* baseAddress, __m128i indices) const
	{
		baseAddress[indices.m128i_i32[0]] = this->i.m128i_i32[0];
		baseAddress[indices.m128i_i32[1]] = this->i.m128i_i32[1];
		baseAddress[indices.m128i_i32[2]] = this->i.m128i_i32[2];
		baseAddress[indices.m128i_i32[3]] = this->i.m128i_i32[3];
	}
#endif

	static w4_int allOnes() { return UINT32_MAX; }
	static w4_int zero() { return _mm_setzero_si128(); }
};

static w4_float convert(w4_int i) { return _mm_cvtepi32_ps(i); }
static w4_int convert(w4_float f) { return _mm_cvtps_epi32(f); }
static w4_float reinterpret(w4_int i) { return _mm_castsi128_ps(i); }
static w4_int reinterpret(w4_float f) { return _mm_castps_si128(f); }


// Int operators.
static w4_int andNot(w4_int a, w4_int b) { return _mm_andnot_si128(a, b); }

static w4_int operator+(w4_int a, w4_int b) { return _mm_add_epi32(a, b); }
static w4_int& operator+=(w4_int& a, w4_int b) { a = a + b; return a; }
static w4_int operator-(w4_int a, w4_int b) { return _mm_sub_epi32(a, b); }
static w4_int& operator-=(w4_int& a, w4_int b) { a = a - b; return a; }
static w4_int operator*(w4_int a, w4_int b) { return _mm_mul_epi32(a, b); }
static w4_int& operator*=(w4_int& a, w4_int b) { a = a * b; return a; }
static w4_int operator/(w4_int a, w4_int b) { return _mm_div_epi32(a, b); }
static w4_int& operator/=(w4_int& a, w4_int b) { a = a / b; return a; }
static w4_int operator&(w4_int a, w4_int b) { return _mm_and_si128(a, b); }
static w4_int& operator&=(w4_int& a, w4_int b) { a = a & b; return a; }
static w4_int operator|(w4_int a, w4_int b) { return _mm_or_si128(a, b); }
static w4_int& operator|=(w4_int& a, w4_int b) { a = a | b; return a; }
static w4_int operator^(w4_int a, w4_int b) { return _mm_xor_si128(a, b); }
static w4_int& operator^=(w4_int& a, w4_int b) { a = a ^ b; return a; }

static w4_int operator~(w4_int a) { a = andNot(a, w4_int::allOnes()); return a; }

static w4_int operator>>(w4_int a, int b) { return _mm_srli_epi32(a, b); }
static w4_int operator>>(w4_int a, w4_int b) { return _mm_srlv_epi32(a, b); }
static w4_int& operator>>=(w4_int& a, int b) { a = a >> b; return a; }
static w4_int& operator>>=(w4_int& a, w4_int b) { a = a >> b; return a; }
static w4_int operator<<(w4_int a, int b) { return _mm_slli_epi32(a, b); }
static w4_int operator<<(w4_int a, w4_int b) { return _mm_sllv_epi32(a, b); }
static w4_int& operator<<=(w4_int& a, int b) { a = a << b; return a; }
static w4_int& operator<<=(w4_int& a, w4_int b) { a = a << b; return a; }

static w4_int operator-(w4_int a) { return _mm_sub_epi32(w4_int::zero(), a); }



// Float operators.
static w4_float andNot(w4_float a, w4_float b) { return _mm_andnot_ps(a, b); }

static w4_float operator+(w4_float a, w4_float b) { return _mm_add_ps(a, b); }
static w4_float& operator+=(w4_float& a, w4_float b) { a = a + b; return a; }
static w4_float operator-(w4_float a, w4_float b) { return _mm_sub_ps(a, b); }
static w4_float& operator-=(w4_float& a, w4_float b) { a = a - b; return a; }
static w4_float operator*(w4_float a, w4_float b) { return _mm_mul_ps(a, b); }
static w4_float& operator*=(w4_float& a, w4_float b) { a = a * b; return a; }
static w4_float operator/(w4_float a, w4_float b) { return _mm_div_ps(a, b); }
static w4_float& operator/=(w4_float& a, w4_float b) { a = a / b; return a; }
static w4_float operator&(w4_float a, w4_float b) { return _mm_and_ps(a, b); }
static w4_float& operator&=(w4_float& a, w4_float b) { a = a & b; return a; }
static w4_float operator|(w4_float a, w4_float b) { return _mm_or_ps(a, b); }
static w4_float& operator|=(w4_float& a, w4_float b) { a = a | b; return a; }
static w4_float operator^(w4_float a, w4_float b) { return _mm_xor_ps(a, b); }
static w4_float& operator^=(w4_float& a, w4_float b) { a = a ^ b; return a; }

static w4_float operator~(w4_float a) { a = andNot(a, w4_float::allOnes()); return a; }


static w4_int operator==(w4_int a, w4_int b) { return _mm_cmpeq_epi32(a, b); }
static w4_int operator!=(w4_int a, w4_int b) { return ~(a == b); }
static w4_int operator>(w4_int a, w4_int b) { return _mm_cmpgt_epi32(a, b); }
static w4_int operator>=(w4_int a, w4_int b) { return (a > b) | (a == b); }
static w4_int operator<(w4_int a, w4_int b) { return _mm_cmplt_epi32(a, b); }
static w4_int operator<=(w4_int a, w4_int b) { return (a < b) | (a == b); }

static w4_float operator==(w4_float a, w4_float b) { return _mm_cmpeq_ps(a, b); }
static w4_float operator!=(w4_float a, w4_float b) { return _mm_cmpneq_ps(a, b); }
static w4_float operator>(w4_float a, w4_float b) { return _mm_cmpgt_ps(a, b); }
static w4_float operator>=(w4_float a, w4_float b) { return _mm_cmpge_ps(a, b); }
static w4_float operator<(w4_float a, w4_float b) { return _mm_cmplt_ps(a, b); }
static w4_float operator<=(w4_float a, w4_float b) { return _mm_cmple_ps(a, b); }

static w4_float operator>>(w4_float a, int b) { return reinterpret(reinterpret(a) >> b); }
static w4_float& operator>>=(w4_float& a, int b) { a = a >> b; return a; }
static w4_float operator<<(w4_float a, int b) { return reinterpret(reinterpret(a) << b); }
static w4_float& operator<<=(w4_float& a, int b) { a = a << b; return a; }

static w4_float operator-(w4_float a) { return _mm_xor_ps(a, reinterpret(w4_int(1 << 31))); }




static float addElements(w4_float a) { __m128 aa = _mm_hadd_ps(a, a); aa = _mm_hadd_ps(aa, aa); return aa.m128_f32[0]; }

static w4_float fmadd(w4_float a, w4_float b, w4_float c) { return _mm_fmadd_ps(a, b, c); }
static w4_float fmsub(w4_float a, w4_float b, w4_float c) { return _mm_fmsub_ps(a, b, c); }

static w4_float sqrt(w4_float a) { return _mm_sqrt_ps(a); }
static w4_float rsqrt(w4_float a) { return _mm_rsqrt_ps(a); }

static w4_float ifThen(w4_float cond, w4_float ifCase, w4_float elseCase) { return _mm_blendv_ps(elseCase, ifCase, cond); }
static w4_int ifThen(w4_int cond, w4_int ifCase, w4_int elseCase) { return reinterpret(ifThen(reinterpret(cond), reinterpret(ifCase), reinterpret(elseCase))); }

static int toBitMask(w4_float a) { return _mm_movemask_ps(a); }
static int toBitMask(w4_int a) { return toBitMask(reinterpret(a)); }

static bool allTrue(w4_float a) { return toBitMask(a) == (1 << 4) - 1; }
static bool allFalse(w4_float a) { return toBitMask(a) == 0; }
static bool anyTrue(w4_float a) { return toBitMask(a) > 0; }
static bool anyFalse(w4_float a) { return !allTrue(a); }

static bool allTrue(w4_int a) { return allTrue(reinterpret(a)); }
static bool allFalse(w4_int a) { return allFalse(reinterpret(a)); }
static bool anyTrue(w4_int a) { return anyTrue(reinterpret(a)); }
static bool anyFalse(w4_int a) { return anyFalse(reinterpret(a)); }

static w4_float abs(w4_float a) { w4_float result = andNot(-0.f, a); return result; }
static w4_float floor(w4_float a) { return _mm_floor_ps(a); }
static w4_float round(w4_float a) { return _mm_round_ps(a, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC); }
static w4_float minimum(w4_float a, w4_float b) { return _mm_min_ps(a, b); }
static w4_float maximum(w4_float a, w4_float b) { return _mm_max_ps(a, b); }

static w4_float lerp(w4_float l, w4_float u, w4_float t) { return fmadd(t, u - l, l); }
static w4_float inverseLerp(w4_float l, w4_float u, w4_float v) { return (v - l) / (u - l); }
static w4_float remap(w4_float v, w4_float oldL, w4_float oldU, w4_float newL, w4_float newU) { return lerp(newL, newU, inverseLerp(oldL, oldU, v)); }
static w4_float clamp(w4_float v, w4_float l, w4_float u) { return minimum(u, maximum(l, v)); }
static w4_float clamp01(w4_float v) { return clamp(v, 0.f, 1.f); }

static w4_float signOf(w4_float f) { w4_float z = w4_float::zero(); return ifThen(f < z, w4_float(-1), ifThen(f == z, z, w4_float(1))); }
static w4_float signbit(w4_float f) { return (f & -0.f) >> 31; }

static w4_float cos(w4_float x) { return cosInternal(x); }
static w4_float sin(w4_float x) { return sinInternal(x); }
static w4_float exp2(w4_float x) { return exp2Internal<w4_float, w4_int>(x); }
static w4_float log2(w4_float x) { return log2Internal<w4_float, w4_int>(x); }
static w4_float pow(w4_float x, w4_float y) { return powInternal<w4_float, w4_int>(x, y); }
static w4_float exp(w4_float x) { return expInternal<w4_float, w4_int>(x); }
static w4_float tanh(w4_float x) { return tanhInternal(x); }
static w4_float atan(w4_float x) { return atanInternal<w4_float, w4_int>(x); }
static w4_float atan2(w4_float y, w4_float x) { return atan2Internal<w4_float, w4_int>(y, x); }
static w4_float acos(w4_float x) { return acosInternal(x); }

static w4_int fillWithFirstLane(w4_int a)
{
	w4_int first = _mm_shuffle_epi32(a, _MM_SHUFFLE(0, 0, 0, 0));
	return first;
}

static w4_int popcount(w4_int i)
{
	i = i - ((i >> 1) & 0x55555555);
	i = (i & 0x33333333) + ((i >> 2) & 0x33333333);
	return (((i + (i >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;
}

static void transpose(w4_float& out0, w4_float& out1, w4_float& out2, w4_float& out3)
{
	_MM_TRANSPOSE4_PS(out0.f, out1.f, out2.f, out3.f);
}

static void load4(const float* baseAddress, const uint16* indices, uint32 stride,
	w4_float& out0, w4_float& out1, w4_float& out2, w4_float& out3)
{
	const uint32 strideInFloats = stride / sizeof(float);

	out0 = w4_float(baseAddress + strideInFloats * indices[0]);
	out1 = w4_float(baseAddress + strideInFloats * indices[1]);
	out2 = w4_float(baseAddress + strideInFloats * indices[2]);
	out3 = w4_float(baseAddress + strideInFloats * indices[3]);

	transpose(out0, out1, out2, out3);
}

static void store4(float* baseAddress, const uint16* indices, uint32 stride,
	w4_float in0, w4_float in1, w4_float in2, w4_float in3)
{
	const uint32 strideInFloats = stride / sizeof(float);

	transpose(in0, in1, in2, in3);

	in0.store(baseAddress + strideInFloats * indices[0]);
	in1.store(baseAddress + strideInFloats * indices[1]);
	in2.store(baseAddress + strideInFloats * indices[2]);
	in3.store(baseAddress + strideInFloats * indices[3]);
}

static void load8(const float* baseAddress, const uint16* indices, uint32 stride,
	w4_float& out0, w4_float& out1, w4_float& out2, w4_float& out3, w4_float& out4, w4_float& out5, w4_float& out6, w4_float& out7)
{
	const uint32 strideInFloats = stride / sizeof(float);

	out0 = w4_float(baseAddress + strideInFloats * indices[0]);
	out1 = w4_float(baseAddress + strideInFloats * indices[1]);
	out2 = w4_float(baseAddress + strideInFloats * indices[2]);
	out3 = w4_float(baseAddress + strideInFloats * indices[3]);
	out4 = w4_float(baseAddress + strideInFloats * indices[0] + 4);
	out5 = w4_float(baseAddress + strideInFloats * indices[1] + 4);
	out6 = w4_float(baseAddress + strideInFloats * indices[2] + 4);
	out7 = w4_float(baseAddress + strideInFloats * indices[3] + 4);

	transpose(out0, out1, out2, out3);
	transpose(out4, out5, out6, out7);
}

static void store8(float* baseAddress, const uint16* indices, uint32 stride,
	w4_float in0, w4_float in1, w4_float in2, w4_float in3, w4_float in4, w4_float in5, w4_float in6, w4_float in7)
{
	const uint32 strideInFloats = stride / sizeof(float);

	transpose(in0, in1, in2, in3);
	transpose(in4, in5, in6, in7);

	in0.store(baseAddress + strideInFloats * indices[0]);
	in1.store(baseAddress + strideInFloats * indices[1]);
	in2.store(baseAddress + strideInFloats * indices[2]);
	in3.store(baseAddress + strideInFloats * indices[3]);
	in4.store(baseAddress + strideInFloats * indices[0] + 4);
	in5.store(baseAddress + strideInFloats * indices[1] + 4);
	in6.store(baseAddress + strideInFloats * indices[2] + 4);
	in7.store(baseAddress + strideInFloats * indices[3] + 4);
}

#endif

#if defined(SIMD_AVX_2)

struct w8_float
{
	__m256 f;

	w8_float() {}
	w8_float(float f_) { f = _mm256_set1_ps(f_); }
	w8_float(__m256 f_) { f = f_; }
	w8_float(float a, float b, float c, float d, float e, float f, float g, float h) { this->f = _mm256_setr_ps(a, b, c, d, e, f, g, h); }
	w8_float(const float* f_) { f = _mm256_loadu_ps(f_); }

	w8_float(const float* baseAddress, __m256i indices) { f = _mm256_i32gather_ps(baseAddress, indices, 4); }
	w8_float(const float* baseAddress, int a, int b, int c, int d, int e, int f, int g, int h) : w8_float(baseAddress, _mm256_setr_epi32(a, b, c, d, e, f, g, h)) {}

	operator __m256() { return f; }
	float operator[](uint32 i) const { return this->f.m256_f32[i]; }

	void store(float* f_) const { _mm256_storeu_ps(f_, f); }

#if defined(SIMD_AVX_512)
	void scatter(float* baseAddress, __m256i indices) { _mm256_i32scatter_ps(baseAddress, indices, f, 4); }
	void scatter(float* baseAddress, int a, int b, int c, int d, int e, int f, int g, int h) { scatter(baseAddress, _mm256_setr_epi32(a, b, c, d, e, f, g, h)); }
#else
	void scatter(float* baseAddress, int a, int b, int c, int d, int e, int f, int g, int h) const
	{
		baseAddress[a] = this->f.m256_f32[0];
		baseAddress[b] = this->f.m256_f32[1];
		baseAddress[c] = this->f.m256_f32[2];
		baseAddress[d] = this->f.m256_f32[3];
		baseAddress[e] = this->f.m256_f32[4];
		baseAddress[f] = this->f.m256_f32[5];
		baseAddress[g] = this->f.m256_f32[6];
		baseAddress[h] = this->f.m256_f32[7];
	}

	void scatter(float* baseAddress, __m256i indices) const
	{
		baseAddress[indices.m256i_i32[0]] = this->f.m256_f32[0];
		baseAddress[indices.m256i_i32[1]] = this->f.m256_f32[1];
		baseAddress[indices.m256i_i32[2]] = this->f.m256_f32[2];
		baseAddress[indices.m256i_i32[3]] = this->f.m256_f32[3];
		baseAddress[indices.m256i_i32[4]] = this->f.m256_f32[4];
		baseAddress[indices.m256i_i32[5]] = this->f.m256_f32[5];
		baseAddress[indices.m256i_i32[6]] = this->f.m256_f32[6];
		baseAddress[indices.m256i_i32[7]] = this->f.m256_f32[7];
	}
#endif

	static w8_float allOnes() { const float nnan = (const float&)0xFFFFFFFF; return nnan; }
	static w8_float zero() { return _mm256_setzero_ps(); }
};

struct w8_int
{
	__m256i i;

	w8_int() {}
	w8_int(int i_) { i = _mm256_set1_epi32(i_); }
	w8_int(__m256i i_) { i = i_; }
	w8_int(int a, int b, int c, int d, int e, int f, int g, int h) { this->i = _mm256_setr_epi32(a, b, c, d, e, f, g, h); }
	w8_int(const int* i_) { i = _mm256_loadu_epi32(i_); }

	w8_int(const int* baseAddress, __m256i indices) { i = _mm256_i32gather_epi32(baseAddress, indices, 4); }
	w8_int(const int* baseAddress, int a, int b, int c, int d, int e, int f, int g, int h) : w8_int(baseAddress, _mm256_setr_epi32(a, b, c, d, e, f, g, h)) {}

	operator __m256i() { return i; }
	int operator[](uint32 i) const { return this->i.m256i_i32[i]; }

	void store(int* i_) const { _mm256_storeu_epi32(i_, i); }

#if defined(SIMD_AVX_512)
	void scatter(int* baseAddress, __m256i indices) { _mm256_i32scatter_epi32(baseAddress, indices, i, 4); }
	void scatter(int* baseAddress, int a, int b, int c, int d, int e, int f, int g, int h) { scatter(baseAddress, _mm256_setr_epi32(a, b, c, d, e, f, g, h)); }
#else
	void scatter(int* baseAddress, int a, int b, int c, int d, int e, int f, int g, int h) const
	{
		baseAddress[a] = this->i.m256i_i32[0];
		baseAddress[b] = this->i.m256i_i32[1];
		baseAddress[c] = this->i.m256i_i32[2];
		baseAddress[d] = this->i.m256i_i32[3];
		baseAddress[e] = this->i.m256i_i32[4];
		baseAddress[f] = this->i.m256i_i32[5];
		baseAddress[g] = this->i.m256i_i32[6];
		baseAddress[h] = this->i.m256i_i32[7];
	}

	void scatter(int* baseAddress, __m256i indices) const
	{
		baseAddress[indices.m256i_i32[0]] = this->i.m256i_i32[0];
		baseAddress[indices.m256i_i32[1]] = this->i.m256i_i32[1];
		baseAddress[indices.m256i_i32[2]] = this->i.m256i_i32[2];
		baseAddress[indices.m256i_i32[3]] = this->i.m256i_i32[3];
		baseAddress[indices.m256i_i32[4]] = this->i.m256i_i32[4];
		baseAddress[indices.m256i_i32[5]] = this->i.m256i_i32[5];
		baseAddress[indices.m256i_i32[6]] = this->i.m256i_i32[6];
		baseAddress[indices.m256i_i32[7]] = this->i.m256i_i32[7];
	}
#endif

	static w8_int allOnes() { return UINT32_MAX; }
	static w8_int zero() { return _mm256_setzero_si256(); }
};

static w8_float convert(w8_int i) { return _mm256_cvtepi32_ps(i); }
static w8_int convert(w8_float f) { return _mm256_cvtps_epi32(f); }
static w8_float reinterpret(w8_int i) { return _mm256_castsi256_ps(i); }
static w8_int reinterpret(w8_float f) { return _mm256_castps_si256(f); }


// Int operators.
static w8_int andNot(w8_int a, w8_int b) { return _mm256_andnot_si256(a, b); }

static w8_int operator+(w8_int a, w8_int b) { return _mm256_add_epi32(a, b); }
static w8_int& operator+=(w8_int& a, w8_int b) { a = a + b; return a; }
static w8_int operator-(w8_int a, w8_int b) { return _mm256_sub_epi32(a, b); }
static w8_int& operator-=(w8_int& a, w8_int b) { a = a - b; return a; }
static w8_int operator*(w8_int a, w8_int b) { return _mm256_mul_epi32(a, b); }
static w8_int& operator*=(w8_int& a, w8_int b) { a = a * b; return a; }
static w8_int operator/(w8_int a, w8_int b) { return _mm256_div_epi32(a, b); }
static w8_int& operator/=(w8_int& a, w8_int b) { a = a / b; return a; }
static w8_int operator&(w8_int a, w8_int b) { return _mm256_and_si256(a, b); }
static w8_int& operator&=(w8_int& a, w8_int b) { a = a & b; return a; }
static w8_int operator|(w8_int a, w8_int b) { return _mm256_or_si256(a, b); }
static w8_int& operator|=(w8_int& a, w8_int b) { a = a | b; return a; }
static w8_int operator^(w8_int a, w8_int b) { return _mm256_xor_si256(a, b); }
static w8_int& operator^=(w8_int& a, w8_int b) { a = a ^ b; return a; }

static w8_int operator~(w8_int a) { a = andNot(a, w8_int::allOnes()); return a; }

static w8_int operator>>(w8_int a, int b) { return _mm256_srli_epi32(a, b); }
static w8_int operator>>(w8_int a, w8_int b) { return _mm256_srlv_epi32(a, b); }
static w8_int& operator>>=(w8_int& a, int b) { a = a >> b; return a; }
static w8_int& operator>>=(w8_int& a, w8_int b) { a = a >> b; return a; }
static w8_int operator<<(w8_int a, int b) { return _mm256_slli_epi32(a, b); }
static w8_int operator<<(w8_int a, w8_int b) { return _mm256_sllv_epi32(a, b); }
static w8_int& operator<<=(w8_int& a, int b) { a = a << b; return a; }
static w8_int& operator<<=(w8_int& a, w8_int b) { a = a << b; return a; }

static w8_int operator-(w8_int a) { return _mm256_sub_epi32(w8_int::zero(), a); }



// Float operators.
static w8_float andNot(w8_float a, w8_float b) { return _mm256_andnot_ps(a, b); }

static w8_float operator+(w8_float a, w8_float b) { return _mm256_add_ps(a, b); }
static w8_float& operator+=(w8_float& a, w8_float b) { a = a + b; return a; }
static w8_float operator-(w8_float a, w8_float b) { return _mm256_sub_ps(a, b); }
static w8_float& operator-=(w8_float& a, w8_float b) { a = a - b; return a; }
static w8_float operator*(w8_float a, w8_float b) { return _mm256_mul_ps(a, b); }
static w8_float& operator*=(w8_float& a, w8_float b) { a = a * b; return a; }
static w8_float operator/(w8_float a, w8_float b) { return _mm256_div_ps(a, b); }
static w8_float& operator/=(w8_float& a, w8_float b) { a = a / b; return a; }
static w8_float operator&(w8_float a, w8_float b) { return _mm256_and_ps(a, b); }
static w8_float& operator&=(w8_float& a, w8_float b) { a = a & b; return a; }
static w8_float operator|(w8_float a, w8_float b) { return _mm256_or_ps(a, b); }
static w8_float& operator|=(w8_float& a, w8_float b) { a = a | b; return a; }
static w8_float operator^(w8_float a, w8_float b) { return _mm256_xor_ps(a, b); }
static w8_float& operator^=(w8_float& a, w8_float b) { a = a ^ b; return a; }

static w8_float operator~(w8_float a) { a = andNot(a, w8_float::allOnes()); return a; }


#if defined(SIMD_AVX_512)
static uint8 operator==(w8_int a, w8_int b) { return _mm256_cmp_epi32_mask(a, b, _MM_CMPINT_EQ); }
static uint8 operator!=(w8_int a, w8_int b) { return _mm256_cmp_epi32_mask(a, b, _MM_CMPINT_NE); }
static uint8 operator>(w8_int a, w8_int b) { return _mm256_cmp_epi32_mask(b, a, _MM_CMPINT_LT); }
static uint8 operator>=(w8_int a, w8_int b) { return _mm256_cmp_epi32_mask(b, a, _MM_CMPINT_LE); }
static uint8 operator<(w8_int a, w8_int b) { return _mm256_cmp_epi32_mask(a, b, _MM_CMPINT_LT); }
static uint8 operator<=(w8_int a, w8_int b) { return _mm256_cmp_epi32_mask(a, b, _MM_CMPINT_LE); }
#else
static w8_int operator==(w8_int a, w8_int b) { return _mm256_cmpeq_epi32(a, b); }
static w8_int operator!=(w8_int a, w8_int b) { return ~(a == b); }
static w8_int operator>(w8_int a, w8_int b) { return _mm256_cmpgt_epi32(a, b); }
static w8_int operator>=(w8_int a, w8_int b) { return (a > b) | (a == b); }
static w8_int operator<(w8_int a, w8_int b) { return _mm256_cmpgt_epi32(b, a); }
static w8_int operator<=(w8_int a, w8_int b) { return (a < b) | (a == b); }
#endif


#if defined(SIMD_AVX_512)
static uint8 operator==(w8_float a, w8_float b) { return _mm256_cmp_ps_mask(a, b, _CMP_EQ_OQ); }
static uint8 operator!=(w8_float a, w8_float b) { return _mm256_cmp_ps_mask(a, b, _CMP_NEQ_OQ); }
static uint8 operator>(w8_float a, w8_float b) { return _mm256_cmp_ps_mask(a, b, _CMP_GT_OQ); }
static uint8 operator>=(w8_float a, w8_float b) { return _mm256_cmp_ps_mask(a, b, _CMP_GE_OQ); }
static uint8 operator<(w8_float a, w8_float b) { return _mm256_cmp_ps_mask(a, b, _CMP_LT_OQ); }
static uint8 operator<=(w8_float a, w8_float b) { return _mm256_cmp_ps_mask(a, b, _CMP_LE_OQ); }
#else
static w8_float operator==(w8_float a, w8_float b) { return _mm256_cmp_ps(a, b, _CMP_EQ_OQ); }
static w8_float operator!=(w8_float a, w8_float b) { return _mm256_cmp_ps(a, b, _CMP_NEQ_OQ); }
static w8_float operator>(w8_float a, w8_float b) { return _mm256_cmp_ps(a, b, _CMP_GT_OQ); }
static w8_float operator>=(w8_float a, w8_float b) { return _mm256_cmp_ps(a, b, _CMP_GE_OQ); }
static w8_float operator<(w8_float a, w8_float b) { return _mm256_cmp_ps(a, b, _CMP_LT_OQ); }
static w8_float operator<=(w8_float a, w8_float b) { return _mm256_cmp_ps(a, b, _CMP_LE_OQ); }
#endif

static w8_float operator>>(w8_float a, int b) { return reinterpret(reinterpret(a) >> b); }
static w8_float& operator>>=(w8_float& a, int b) { a = a >> b; return a; }
static w8_float operator<<(w8_float a, int b) { return reinterpret(reinterpret(a) << b); }
static w8_float& operator<<=(w8_float& a, int b) { a = a << b; return a; }

static w8_float operator-(w8_float a) { return _mm256_xor_ps(a, reinterpret(w8_int(1 << 31))); }




static float addElements(w8_float a) { __m256 aa = _mm256_hadd_ps(a, a); aa = _mm256_hadd_ps(aa, aa); return aa.m256_f32[0] + aa.m256_f32[4]; }

static w8_float fmadd(w8_float a, w8_float b, w8_float c) { return _mm256_fmadd_ps(a, b, c); }
static w8_float fmsub(w8_float a, w8_float b, w8_float c) { return _mm256_fmsub_ps(a, b, c); }

static w8_float sqrt(w8_float a) { return _mm256_sqrt_ps(a); }
static w8_float rsqrt(w8_float a) { return _mm256_rsqrt_ps(a); }

static int toBitMask(w8_float a) { return _mm256_movemask_ps(a); }
static int toBitMask(w8_int a) { return toBitMask(reinterpret(a)); }

#if defined(SIMD_AVX_512)
static w8_float ifThen(uint8 cond, w8_float ifCase, w8_float elseCase) { return _mm256_mask_blend_ps(cond, elseCase, ifCase); }
static w8_int ifThen(uint8 cond, w8_int ifCase, w8_int elseCase) { return reinterpret(ifThen(cond, reinterpret(ifCase), reinterpret(elseCase))); }

static int toBitMask(uint8 a) { return a; }

static bool allTrue(uint8 a) { return a == (1 << 8) - 1; }
static bool allFalse(uint8 a) { return a == 0; }
static bool anyTrue(uint8 a) { return a > 0; }
static bool anyFalse(uint8 a) { return !allTrue(a); }
#else
static w8_float ifThen(w8_float cond, w8_float ifCase, w8_float elseCase) { return _mm256_blendv_ps(elseCase, ifCase, cond); }
static w8_int ifThen(w8_int cond, w8_int ifCase, w8_int elseCase) { return reinterpret(ifThen(reinterpret(cond), reinterpret(ifCase), reinterpret(elseCase))); }

static bool allTrue(w8_float a) { return toBitMask(a) == (1 << 8) - 1; }
static bool allFalse(w8_float a) { return toBitMask(a) == 0; }
static bool anyTrue(w8_float a) { return toBitMask(a) > 0; }
static bool anyFalse(w8_float a) { return !allTrue(a); }

static bool allTrue(w8_int a) { return allTrue(reinterpret(a)); }
static bool allFalse(w8_int a) { return allFalse(reinterpret(a)); }
static bool anyTrue(w8_int a) { return anyTrue(reinterpret(a)); }
static bool anyFalse(w8_int a) { return anyFalse(reinterpret(a)); }
#endif


static w8_float abs(w8_float a) { w8_float result = andNot(-0.f, a); return result; }
static w8_float floor(w8_float a) { return _mm256_floor_ps(a); }
static w8_float minimum(w8_float a, w8_float b) { return _mm256_min_ps(a, b); }
static w8_float maximum(w8_float a, w8_float b) { return _mm256_max_ps(a, b); }

static w8_float lerp(w8_float l, w8_float u, w8_float t) { return fmadd(t, u - l, l); }
static w8_float inverseLerp(w8_float l, w8_float u, w8_float v) { return (v - l) / (u - l); }
static w8_float remap(w8_float v, w8_float oldL, w8_float oldU, w8_float newL, w8_float newU) { return lerp(newL, newU, inverseLerp(oldL, oldU, v)); }
static w8_float clamp(w8_float v, w8_float l, w8_float u) { return minimum(u, maximum(l, v)); }
static w8_float clamp01(w8_float v) { return clamp(v, 0.f, 1.f); }

static w8_float signOf(w8_float f) { w8_float z = w8_float::zero(); return ifThen(f < z, w8_float(-1), ifThen(f == z, z, w8_float(1))); }
static w8_float signbit(w8_float f) { return (f & -0.f) >> 31; }

static w8_float cos(w8_float x) { return cosInternal(x); }
static w8_float sin(w8_float x) { return sinInternal(x); }
static w8_float exp2(w8_float x) { return exp2Internal<w8_float, w8_int>(x); }
static w8_float log2(w8_float x) { return log2Internal<w8_float, w8_int>(x); }
static w8_float pow(w8_float x, w8_float y) { return powInternal<w8_float, w8_int>(x, y); }
static w8_float exp(w8_float x) { return expInternal<w8_float, w8_int>(x); }
static w8_float tanh(w8_float x) { return tanhInternal(x); }
static w8_float atan(w8_float x) { return atanInternal<w8_float, w8_int>(x); }
static w8_float atan2(w8_float y, w8_float x) { return atan2Internal<w8_float, w8_int>(y, x); }
static w8_float acos(w8_float x) { return acosInternal(x); }

static w8_float concat(w4_float a, w4_float b)
{
	return _mm256_insertf128_ps(_mm256_castps128_ps256(a), b, 1);
}

static w8_int concat(w4_int a, w4_int b)
{
	return _mm256_inserti128_si256(_mm256_castsi128_si256(a), b, 1);
}

static w8_float concatLow(w8_float a, w8_float b)
{
	return _mm256_permute2f128_ps(a, b, 0 | (0 << 4));
}

static w8_int concatLow(w8_int a, w8_int b)
{
	return _mm256_permute2x128_si256(a, b, 0 | (0 << 4));
}

static w4_float getLower(w8_float a)
{
	return _mm256_castps256_ps128(a);
}

static w4_float getUpper(w8_float a)
{
	return _mm256_extractf128_ps(a, 1);
}

static w8_int fillWithFirstLane(w8_int a)
{
	w8_int first = _mm256_shuffle_epi32(a, _MM_SHUFFLE(0, 0, 0, 0));
	first = concatLow(first, first);
	return first;
}

static w8_int popcount(w8_int i)
{
	i = i - ((i >> 1) & 0x55555555);
	i = (i & 0x33333333) + ((i >> 2) & 0x33333333);
	return (((i + (i >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;
}

static void transpose32(w8_float& out0, w8_float& out1, w8_float& out2, w8_float& out3)
{
	w8_float t0 = _mm256_unpacklo_ps(out0, out1);
	w8_float t1 = _mm256_unpacklo_ps(out2, out3);
	w8_float t2 = _mm256_unpackhi_ps(out0, out1);
	w8_float t3 = _mm256_unpackhi_ps(out2, out3);
	out0 = _mm256_shuffle_ps(t0, t1, _MM_SHUFFLE(1, 0, 1, 0));
	out1 = _mm256_shuffle_ps(t0, t1, _MM_SHUFFLE(3, 2, 3, 2));
	out2 = _mm256_shuffle_ps(t2, t3, _MM_SHUFFLE(1, 0, 1, 0));
	out3 = _mm256_shuffle_ps(t2, t3, _MM_SHUFFLE(3, 2, 3, 2));
}

static void transpose(w8_float& out0, w8_float& out1, w8_float& out2, w8_float& out3, w8_float& out4, w8_float& out5, w8_float& out6, w8_float& out7)
{
	w8_float tmp0 = reinterpret(_mm256_permute2x128_si256(reinterpret(out0), reinterpret(out4), 0 | (2 << 4)));
	w8_float tmp1 = reinterpret(_mm256_permute2x128_si256(reinterpret(out1), reinterpret(out5), 0 | (2 << 4)));
	w8_float tmp2 = reinterpret(_mm256_permute2x128_si256(reinterpret(out2), reinterpret(out6), 0 | (2 << 4)));
	w8_float tmp3 = reinterpret(_mm256_permute2x128_si256(reinterpret(out3), reinterpret(out7), 0 | (2 << 4)));
	w8_float tmp4 = reinterpret(_mm256_permute2x128_si256(reinterpret(out0), reinterpret(out4), 1 | (3 << 4)));
	w8_float tmp5 = reinterpret(_mm256_permute2x128_si256(reinterpret(out1), reinterpret(out5), 1 | (3 << 4)));
	w8_float tmp6 = reinterpret(_mm256_permute2x128_si256(reinterpret(out2), reinterpret(out6), 1 | (3 << 4)));
	w8_float tmp7 = reinterpret(_mm256_permute2x128_si256(reinterpret(out3), reinterpret(out7), 1 | (3 << 4)));

	out0 = tmp0;
	out1 = tmp1;
	out2 = tmp2;
	out3 = tmp3;
	out4 = tmp4;
	out5 = tmp5;
	out6 = tmp6;
	out7 = tmp7;

	transpose32(out0, out1, out2, out3);
	transpose32(out4, out5, out6, out7);
}

static void load4(const float* baseAddress, const uint16* indices, uint32 stride,
	w8_float& out0, w8_float& out1, w8_float& out2, w8_float& out3)
{
	const uint32 strideInFloats = stride / sizeof(float);

	w4_float tmp0(baseAddress + strideInFloats * indices[0]);
	w4_float tmp1(baseAddress + strideInFloats * indices[1]);
	w4_float tmp2(baseAddress + strideInFloats * indices[2]);
	w4_float tmp3(baseAddress + strideInFloats * indices[3]);
	w4_float tmp4(baseAddress + strideInFloats * indices[4]);
	w4_float tmp5(baseAddress + strideInFloats * indices[5]);
	w4_float tmp6(baseAddress + strideInFloats * indices[6]);
	w4_float tmp7(baseAddress + strideInFloats * indices[7]);

	out0 = concat(tmp0, tmp4);
	out1 = concat(tmp1, tmp5);
	out2 = concat(tmp2, tmp6);
	out3 = concat(tmp3, tmp7);

	transpose32(out0, out1, out2, out3);
}

static void load8(const float* baseAddress, const uint16* indices, uint32 stride,
	w8_float& out0, w8_float& out1, w8_float& out2, w8_float& out3, w8_float& out4, w8_float& out5, w8_float& out6, w8_float& out7)
{
	const uint32 strideInFloats = stride / sizeof(float);

	out0 = w8_float(baseAddress + strideInFloats * indices[0]);
	out1 = w8_float(baseAddress + strideInFloats * indices[1]);
	out2 = w8_float(baseAddress + strideInFloats * indices[2]);
	out3 = w8_float(baseAddress + strideInFloats * indices[3]);
	out4 = w8_float(baseAddress + strideInFloats * indices[4]);
	out5 = w8_float(baseAddress + strideInFloats * indices[5]);
	out6 = w8_float(baseAddress + strideInFloats * indices[6]);
	out7 = w8_float(baseAddress + strideInFloats * indices[7]);

	transpose(out0, out1, out2, out3, out4, out5, out6, out7);
}

static void store4(float* baseAddress, const uint16* indices, uint32 stride,
	w8_float in0, w8_float in1, w8_float in2, w8_float in3)
{
	const uint32 strideInFloats = stride / sizeof(float);

	transpose32(in0, in1, in2, in3);

	w4_float tmp0 = getLower(in0);
	w4_float tmp1 = getLower(in1);
	w4_float tmp2 = getLower(in2);
	w4_float tmp3 = getLower(in3);
	w4_float tmp4 = getUpper(in0);
	w4_float tmp5 = getUpper(in1);
	w4_float tmp6 = getUpper(in2);
	w4_float tmp7 = getUpper(in3);

	tmp0.store(baseAddress + strideInFloats * indices[0]);
	tmp1.store(baseAddress + strideInFloats * indices[1]);
	tmp2.store(baseAddress + strideInFloats * indices[2]);
	tmp3.store(baseAddress + strideInFloats * indices[3]);
	tmp4.store(baseAddress + strideInFloats * indices[4]);
	tmp5.store(baseAddress + strideInFloats * indices[5]);
	tmp6.store(baseAddress + strideInFloats * indices[6]);
	tmp7.store(baseAddress + strideInFloats * indices[7]);
}

static void store8(float* baseAddress, const uint16* indices, uint32 stride,
	w8_float in0, w8_float in1, w8_float in2, w8_float in3, w8_float in4, w8_float in5, w8_float in6, w8_float in7)
{
	const uint32 strideInFloats = stride / sizeof(float);

	transpose(in0, in1, in2, in3, in4, in5, in6, in7);

	in0.store(baseAddress + strideInFloats * indices[0]);
	in1.store(baseAddress + strideInFloats * indices[1]);
	in2.store(baseAddress + strideInFloats * indices[2]);
	in3.store(baseAddress + strideInFloats * indices[3]);
	in4.store(baseAddress + strideInFloats * indices[4]);
	in5.store(baseAddress + strideInFloats * indices[5]);
	in6.store(baseAddress + strideInFloats * indices[6]);
	in7.store(baseAddress + strideInFloats * indices[7]);
}


#endif

#if defined(SIMD_AVX_512)

struct w16_float
{
	__m512 f;

	w16_float() {}
	w16_float(float f_) { f = _mm512_set1_ps(f_); }
	w16_float(__m512 f_) { f = f_; }
	w16_float(float a, float b, float c, float d, float e, float f, float g, float h, float i, float j, float k, float l, float m, float n, float o, float p) { this->f = _mm512_setr_ps(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p); }
	w16_float(const float* f_) { f = _mm512_loadu_ps(f_); }

	w16_float(const float* baseAddress, __m512i indices) { f = _mm512_i32gather_ps(indices, baseAddress, 4); }
	w16_float(const float* baseAddress, int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k, int l, int m, int n, int o, int p) : w16_float(baseAddress, _mm512_setr_epi32(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)) {}

	operator __m512() { return f; }

	void store(float* f_) const { _mm512_storeu_ps(f_, f); }

	void scatter(float* baseAddress, __m512i indices) const { _mm512_i32scatter_ps(baseAddress, indices, f, 4); }
	void scatter(float* baseAddress, int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k, int l, int m, int n, int o, int p) const { scatter(baseAddress, _mm512_setr_epi32(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)); }
};

struct w16_int
{
	__m512i i;

	w16_int() {}
	w16_int(int i_) { i = _mm512_set1_epi32(i_); }
	w16_int(__m512i i_) { i = i_; }
	w16_int(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k, int l, int m, int n, int o, int p) { this->i = _mm512_setr_epi32(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p); }
	w16_int(const int* i_) { i = _mm512_loadu_epi32(i_); }

	w16_int(const int* baseAddress, __m512i indices) { i = _mm512_i32gather_epi32(indices, baseAddress, 4); }
	w16_int(const int* baseAddress, int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k, int l, int m, int n, int o, int p) : w16_int(baseAddress, _mm512_setr_epi32(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)) {}

	operator __m512i() { return i; }

	void store(int* i_) const { _mm512_storeu_epi32(i_, i); }
};

static w16_float truex16() { const float nnan = (const float&)0xFFFFFFFF; return nnan; }
static w16_float zerox16() { return _mm512_setzero_ps(); }

static w16_float convert(w16_int i) { return _mm512_cvtepi32_ps(i); }
static w16_int convert(w16_float f) { return _mm512_cvtps_epi32(f); }
static w16_float reinterpret(w16_int i) { return _mm512_castsi512_ps(i); }
static w16_int reinterpret(w16_float f) { return _mm512_castps_si512(f); }


// Int operators.
static w16_int andNot(w16_int a, w16_int b) { return _mm512_andnot_si512(a, b); }

static w16_int operator+(w16_int a, w16_int b) { return _mm512_add_epi32(a, b); }
static w16_int& operator+=(w16_int& a, w16_int b) { a = a + b; return a; }
static w16_int operator-(w16_int a, w16_int b) { return _mm512_sub_epi32(a, b); }
static w16_int& operator-=(w16_int& a, w16_int b) { a = a - b; return a; }
static w16_int operator*(w16_int a, w16_int b) { return _mm512_mul_epi32(a, b); }
static w16_int& operator*=(w16_int& a, w16_int b) { a = a * b; return a; }
static w16_int operator/(w16_int a, w16_int b) { return _mm512_div_epi32(a, b); }
static w16_int& operator/=(w16_int& a, w16_int b) { a = a / b; return a; }
static w16_int operator&(w16_int a, w16_int b) { return _mm512_and_epi32(a, b); }
static w16_int& operator&=(w16_int& a, w16_int b) { a = a & b; return a; }
static w16_int operator|(w16_int a, w16_int b) { return _mm512_or_epi32(a, b); }
static w16_int& operator|=(w16_int& a, w16_int b) { a = a | b; return a; }
static w16_int operator^(w16_int a, w16_int b) { return _mm512_xor_epi32(a, b); }
static w16_int& operator^=(w16_int& a, w16_int b) { a = a ^ b; return a; }

static w16_int operator~(w16_int a) { a = andNot(a, reinterpret(truex16())); return a; }

static uint16 operator==(w16_int a, w16_int b) { return _mm512_cmp_epi32_mask(a, b, _MM_CMPINT_EQ); }
static uint16 operator!=(w16_int a, w16_int b) { return _mm512_cmp_epi32_mask(a, b, _MM_CMPINT_NE); }
static uint16 operator>(w16_int a, w16_int b) { return _mm512_cmp_epi32_mask(b, a, _MM_CMPINT_LT); }
static uint16 operator>=(w16_int a, w16_int b) { return _mm512_cmp_epi32_mask(b, a, _MM_CMPINT_LE); }
static uint16 operator<(w16_int a, w16_int b) { return _mm512_cmp_epi32_mask(a, b, _MM_CMPINT_LT); }
static uint16 operator<=(w16_int a, w16_int b) { return _mm512_cmp_epi32_mask(a, b, _MM_CMPINT_LE); }


static w16_int operator>>(w16_int a, int b) { return _mm512_srli_epi32(a, b); }
static w16_int& operator>>=(w16_int& a, int b) { a = a >> b; return a; }
static w16_int operator<<(w16_int a, int b) { return _mm512_slli_epi32(a, b); }
static w16_int& operator<<=(w16_int& a, int b) { a = a << b; return a; }

static w16_int operator-(w16_int a) { return _mm512_sub_epi32(_mm512_setzero_si512(), a); }



// Float operators.
static w16_float andNot(w16_float a, w16_float b) { return _mm512_andnot_ps(a, b); }

static w16_float operator+(w16_float a, w16_float b) { return _mm512_add_ps(a, b); }
static w16_float& operator+=(w16_float& a, w16_float b) { a = a + b; return a; }
static w16_float operator-(w16_float a, w16_float b) { return _mm512_sub_ps(a, b); }
static w16_float& operator-=(w16_float& a, w16_float b) { a = a - b; return a; }
static w16_float operator*(w16_float a, w16_float b) { return _mm512_mul_ps(a, b); }
static w16_float& operator*=(w16_float& a, w16_float b) { a = a * b; return a; }
static w16_float operator/(w16_float a, w16_float b) { return _mm512_div_ps(a, b); }
static w16_float& operator/=(w16_float& a, w16_float b) { a = a / b; return a; }
static w16_float operator&(w16_float a, w16_float b) { return _mm512_and_ps(a, b); }
static w16_float& operator&=(w16_float& a, w16_float b) { a = a & b; return a; }
static w16_float operator|(w16_float a, w16_float b) { return _mm512_or_ps(a, b); }
static w16_float& operator|=(w16_float& a, w16_float b) { a = a | b; return a; }
static w16_float operator^(w16_float a, w16_float b) { return _mm512_xor_ps(a, b); }
static w16_float& operator^=(w16_float& a, w16_float b) { a = a ^ b; return a; }

static w16_float operator~(w16_float a) { a = andNot(a, truex16()); return a; }

static uint16 operator==(w16_float a, w16_float b) { return _mm512_cmp_ps_mask(a, b, _CMP_EQ_OQ); }
static uint16 operator!=(w16_float a, w16_float b) { return _mm512_cmp_ps_mask(a, b, _CMP_NEQ_OQ); }
static uint16 operator>(w16_float a, w16_float b) { return _mm512_cmp_ps_mask(a, b, _CMP_GT_OQ); }
static uint16 operator>=(w16_float a, w16_float b) { return _mm512_cmp_ps_mask(a, b, _CMP_GE_OQ); }
static uint16 operator<(w16_float a, w16_float b) { return _mm512_cmp_ps_mask(a, b, _CMP_LT_OQ); }
static uint16 operator<=(w16_float a, w16_float b) { return _mm512_cmp_ps_mask(a, b, _CMP_LE_OQ); }


static w16_float operator>>(w16_float a, int b) { return reinterpret(reinterpret(a) >> b); }
static w16_float& operator>>=(w16_float& a, int b) { a = a >> b; return a; }
static w16_float operator<<(w16_float a, int b) { return reinterpret(reinterpret(a) << b); }
static w16_float& operator<<=(w16_float& a, int b) { a = a << b; return a; }

static w16_float operator-(w16_float a) { return _mm512_xor_ps(a, reinterpret(w16_int(1 << 31))); }




static float addElements(w16_float a) { return _mm512_reduce_add_ps(a); }

static w16_float fmadd(w16_float a, w16_float b, w16_float c) { return _mm512_fmadd_ps(a, b, c); }
static w16_float fmsub(w16_float a, w16_float b, w16_float c) { return _mm512_fmsub_ps(a, b, c); }

static w16_float sqrt(w16_float a) { return _mm512_sqrt_ps(a); }
static w16_float rsqrt(w16_float a) { return 1.f / _mm512_sqrt_ps(a); }

static w16_float ifThen(uint16 cond, w16_float ifCase, w16_float elseCase) { return _mm512_mask_blend_ps(cond, elseCase, ifCase); }
static w16_int ifThen(uint16 cond, w16_int ifCase, w16_int elseCase) { return reinterpret(ifThen(cond, reinterpret(ifCase), reinterpret(elseCase))); }

static bool allTrue(uint16 a) { return a == (1 << 16) - 1; }
static bool allFalse(uint16 a) { return a == 0; }
static bool anyTrue(uint16 a) { return a > 0; }
static bool anyFalse(uint16 a) { return !allTrue(a); }


static w16_float abs(w16_float a) { w16_float result = andNot(-0.f, a); return result; }
static w16_float floor(w16_float a) { return _mm512_floor_ps(a); }
static w16_float minimum(w16_float a, w16_float b) { return _mm512_min_ps(a, b); }
static w16_float maximum(w16_float a, w16_float b) { return _mm512_max_ps(a, b); }

static w16_float lerp(w16_float l, w16_float u, w16_float t) { return fmadd(t, u - l, l); }
static w16_float inverseLerp(w16_float l, w16_float u, w16_float v) { return (v - l) / (u - l); }
static w16_float remap(w16_float v, w16_float oldL, w16_float oldU, w16_float newL, w16_float newU) { return lerp(newL, newU, inverseLerp(oldL, oldU, v)); }
static w16_float clamp(w16_float v, w16_float l, w16_float u) { return minimum(u, maximum(l, v)); }
static w16_float clamp01(w16_float v) { return clamp(v, 0.f, 1.f); }

static w16_float signOf(w16_float f) { return ifThen(f < 0.f, w16_float(-1), ifThen(f == 0.f, zerox16(), w16_float(1))); }
static w16_float signbit(w16_float f) { return (f & -0.f) >> 31; }

static w16_float cos(w16_float x) { return cosInternal(x); }
static w16_float sin(w16_float x) { return sinInternal(x); }
static w16_float exp2(w16_float x) { return exp2Internal<w16_float, w16_int>(x); }
static w16_float log2(w16_float x) { return log2Internal<w16_float, w16_int>(x); }
static w16_float pow(w16_float x, w16_float y) { return powInternal<w16_float, w16_int>(x, y); }
static w16_float exp(w16_float x) { return expInternal<w16_float, w16_int>(x); }
static w16_float tanh(w16_float x) { return tanhInternal(x); }
static w16_float atan(w16_float x) { return atanInternal<w16_float, w16_int>(x); }
static w16_float atan2(w16_float y, w16_float x) { return atan2Internal<w16_float, w16_int>(y, x); }
static w16_float acos(w16_float x) { return acosInternal(x); }


#endif

static bool anyTrue(int32 mask) { return mask > 0; }
static bool anyTrue(uint32 mask) { return mask > 0; }







```

`src/core/soa.h`:

```h
#pragma once


typedef float* soa_float;
typedef int32* soa_int32;
typedef uint32* soa_uint32;
typedef uint16* soa_uint16;

struct soa_vec2
{
	float* x, y;
};

struct soa_vec3
{
	float* x, y, z;
};

struct soa_vec4
{
	float* x, y, z, w;
};

struct soa_quat
{
	float* x, y, z, w;
};

struct soa_mat2
{
	float*
		m00, m10,
		m01, m11;
};

struct soa_mat3
{
	float*
		m00, m10, m20,
		m01, m11, m21,
		m02, m12, m22;
};

struct soa_mat4
{
	float*
		m00, m10, m20, m30,
		m01, m11, m21, m31,
		m02, m12, m22, m32,
		m03, m13, m23, m33;
};

```

`src/core/string.h`:

```h
#pragma once

#include <string>

// https://codingtidbit.com/2020/02/09/c17-codecvt_utf8-is-deprecated/
static std::string wstringToString(const std::wstring_view& wstr)
{
	if (wstr.empty())
	{
		return std::string();
	}
	int size = WideCharToMultiByte(CP_UTF8, 0, &wstr[0], (int)wstr.size(), NULL, 0, NULL, NULL);
	std::string result(size, 0);
	WideCharToMultiByte(CP_UTF8, 0, &wstr[0], (int)wstr.size(), &result[0], size, NULL, NULL);
	return result;
}

static std::wstring stringToWstring(const std::string_view& str)
{
	if (str.empty())
	{
		return std::wstring();
	}
	int size = MultiByteToWideChar(CP_UTF8, 0, &str[0], (int)str.size(), NULL, 0);
	std::wstring result(size, 0);
	MultiByteToWideChar(CP_UTF8, 0, &str[0], (int)str.size(), &result[0], size);
	return result;
}

constexpr uint32 hashString32(const char* s)
{
	uint32 hash = 2166136261u;
	while (*s)
	{
		hash = 16777619u * (hash ^ (uint32)(*s++));
	}
	return hash;
}

constexpr uint64 hashString64(const char* s)
{
	uint64 hash = 14695981039346656037llu;
	while (*s)
	{
		hash = 1099511628211llu * (hash ^ (uint64)(*s++));
	}
	return hash;
}

#define COMPILE_TIME_STRING_HASH_32(str) (force_consteval<hashString32(str)>)
#define COMPILE_TIME_STRING_HASH_64(str) (force_consteval<hashString64(str)>)


static inline std::string getTimeString()
{
	time_t now = time(0);
	char nowString[100];
	ctime_s(nowString, 100, &now);
	std::string time = nowString;
	std::replace(time.begin(), time.end(), ' ', '_');
	std::replace(time.begin(), time.end(), ':', '.');
	time.pop_back(); // Pop last \n.

	return time;
}

static inline bool contains(const std::string_view& s, const char* sub)
{
	return s.find(sub) != std::string::npos;
}

static inline bool endsWith(const std::string_view& s, const std::string_view& sub)
{
	if (s.length() >= sub.length())
	{
		return s.compare(s.length() - sub.length(), sub.length(), sub) == 0;
	}
	return false;
}

```

`src/core/system.cpp`:

```cpp
#include "pch.h"
#include "system.h"
#include "string.h"

#include "dx/dx_context.h"

#include <intrin.h>

system_info getSystemInfo()
{
	system_info system;
	char cpuName[64] = "";

	int cpuInfo[4] = { -1 };
	__cpuid(cpuInfo, 0x80000000);
	uint32 nExIds = cpuInfo[0];
	// Get the information associated with each extended ID.
	for (uint32 i = 0x80000000; i <= nExIds; ++i)
	{
		__cpuid(cpuInfo, i);
		// Interpret CPU brand string and cache information.
		if (i == 0x80000002)
		{
			memcpy(cpuName,
				cpuInfo,
				sizeof(cpuInfo));
		}
		else if (i == 0x80000003)
		{
			memcpy(cpuName + 16,
				cpuInfo,
				sizeof(cpuInfo));
		}
		else if (i == 0x80000004)
		{
			memcpy(cpuName + 32, cpuInfo, sizeof(cpuInfo));
		}
	}

	MEMORYSTATUSEX memoryState;
	memoryState.dwLength = sizeof(memoryState);

	GlobalMemoryStatusEx(&memoryState);

	system.cpuName = cpuName;
	system.mainMemory = memoryState.ullTotalPhys;


	DXGI_ADAPTER_DESC1 gpuDesc;
	dxContext.adapter->GetDesc1(&gpuDesc);

	system.gpuName = wstringToString(gpuDesc.Description);
	system.videoMemory = gpuDesc.DedicatedVideoMemory;

	return system;
}

```

`src/core/system.h`:

```h
#pragma once

struct system_info
{
	std::string cpuName;
	std::string gpuName;

	// In bytes.
	uint64 mainMemory;
	uint64 videoMemory;
};

system_info getSystemInfo();


```

`src/core/threading.h`:

```h
#pragma once

#include <functional>


// All functions return the value before the operation.
static uint32 atomicAdd(volatile uint32& a, uint32 b) { return InterlockedAdd((volatile LONG*)&a, b) - b; }
static uint64 atomicAdd(volatile uint64& a, uint64 b) {	return InterlockedAdd64((volatile LONG64*)&a, b) - b; }
static uint32 atomicIncrement(volatile uint32& a) {	return InterlockedIncrement((volatile LONG*)&a) - 1; }
static uint64 atomicIncrement(volatile uint64& a) {	return InterlockedIncrement64((volatile LONG64*)&a) - 1; }
static uint32 atomicDecrement(volatile uint32& a) {	return InterlockedDecrement((volatile LONG*)&a) + 1; }
static uint64 atomicDecrement(volatile uint64& a) {	return InterlockedDecrement64((volatile LONG64*)&a) + 1; }
static uint32 atomicCompareExchange(volatile uint32& destination, uint32 exchange, uint32 compare) { return InterlockedCompareExchange((volatile LONG*)&destination, exchange, compare); }
static uint64 atomicCompareExchange(volatile uint64& destination, uint64 exchange, uint64 compare) { return InterlockedCompareExchange64((volatile LONG64*)&destination, exchange, compare); }
static uint32 atomicExchange(volatile uint32& destination, uint32 exchange) { return InterlockedExchange((volatile LONG*)&destination, exchange); }
static uint64 atomicExchange(volatile uint64& destination, uint64 exchange) { return InterlockedExchange64((volatile LONG64*)&destination, exchange); }

static uint32 getThreadIDFast()
{
	// This is what standard library functions do internally, but this function can trivially be inlined.
	uint8* threadLocalStorage = (uint8*)__readgsqword(0x30);
	uint32 threadID = *(uint32*)(threadLocalStorage + 0x48);
	return threadID;
}

```

`src/core/yaml.h`:

```h
#pragma once

#include <yaml-cpp/yaml.h>
#include <fstream>

#include "math.h"
#include "asset/asset.h"


namespace YAML
{
	template<>
	struct convert<vec2>
	{
		static Node encode(const vec2& v)
		{
			Node n; n.SetStyle(EmitterStyle::Flow); n.push_back(v.x); n.push_back(v.y); return n;
		}

		static bool decode(const Node& n, vec2& v)
		{
			if (!n.IsSequence() || n.size() != 2) { return false; } v.x = n[0].as<float>(); v.y = n[1].as<float>(); return true;
		}
	};

	template<>
	struct convert<vec3>
	{
		static Node encode(const vec3& v)
		{
			Node n; n.SetStyle(EmitterStyle::Flow); n.push_back(v.x); n.push_back(v.y); n.push_back(v.z); return n;
		}

		static bool decode(const Node& n, vec3& v)
		{
			if (!n.IsSequence() || n.size() != 3) { return false; } v.x = n[0].as<float>(); v.y = n[1].as<float>(); v.z = n[2].as<float>(); return true;
		}
	};

	template<>
	struct convert<vec4>
	{
		static Node encode(const vec4& v)
		{
			Node n; n.SetStyle(EmitterStyle::Flow); n.push_back(v.x); n.push_back(v.y); n.push_back(v.z); n.push_back(v.w);  return n;
		}

		static bool decode(const Node& n, vec4& v)
		{
			if (!n.IsSequence() || n.size() != 4) { return false; } v.x = n[0].as<float>(); v.y = n[1].as<float>(); v.z = n[2].as<float>(); v.w = n[3].as<float>(); return true;
		}
	};

	template<>
	struct convert<quat>
	{
		static Node encode(const quat& v)
		{
			Node n; n.SetStyle(EmitterStyle::Flow); n.push_back(v.x); n.push_back(v.y); n.push_back(v.z); n.push_back(v.w);  return n;
		}

		static bool decode(const Node& n, quat& v)
		{
			if (!n.IsSequence() || n.size() != 4) { return false; } v.x = n[0].as<float>(); v.y = n[1].as<float>(); v.z = n[2].as<float>(); v.w = n[3].as<float>(); return true;
		}
	};

	template<>
	struct convert<mat2>
	{
		static Node encode(const mat2& m)
		{
			Node n;
			n.SetStyle(EmitterStyle::Flow);
			n.push_back(m.m00);
			n.push_back(m.m01);
			n.push_back(m.m10);
			n.push_back(m.m11);
			return n;
		}

		static bool decode(const Node& n, mat2& m)
		{
			if (!n.IsSequence() || n.size() != 4) return false;
			m.m00 = n[0].as<float>();
			m.m01 = n[1].as<float>();
			m.m10 = n[2].as<float>();
			m.m11 = n[3].as<float>();
			return true;
		}
	};

	template<>
	struct convert<mat3>
	{
		static Node encode(const mat3& m)
		{
			Node n;
			n.SetStyle(EmitterStyle::Flow);
			n.push_back(m.m00);
			n.push_back(m.m01);
			n.push_back(m.m02);
			n.push_back(m.m10);
			n.push_back(m.m11);
			n.push_back(m.m12);
			n.push_back(m.m20);
			n.push_back(m.m21);
			n.push_back(m.m22);
			return n;
		}

		static bool decode(const Node& n, mat3& m)
		{
			if (!n.IsSequence() || n.size() != 9) return false;
			m.m00 = n[0].as<float>();
			m.m01 = n[1].as<float>();
			m.m02 = n[2].as<float>();
			m.m10 = n[3].as<float>();
			m.m11 = n[4].as<float>();
			m.m12 = n[5].as<float>();
			m.m20 = n[6].as<float>();
			m.m21 = n[7].as<float>();
			m.m22 = n[8].as<float>();
			return true;
		}
	};

	template<>
	struct convert<mat4>
	{
		static Node encode(const mat4& m)
		{
			Node n;
			n.SetStyle(EmitterStyle::Flow);
			n.push_back(m.m00);
			n.push_back(m.m01);
			n.push_back(m.m02);
			n.push_back(m.m03);
			n.push_back(m.m10);
			n.push_back(m.m11);
			n.push_back(m.m12);
			n.push_back(m.m13);
			n.push_back(m.m20);
			n.push_back(m.m21);
			n.push_back(m.m22);
			n.push_back(m.m23);
			n.push_back(m.m30);
			n.push_back(m.m31);
			n.push_back(m.m32);
			n.push_back(m.m33);
			return n;
		}

		static bool decode(const Node& n, mat4& m)
		{
			if (!n.IsSequence() || n.size() != 16) return false;
			m.m00 = n[0].as<float>();
			m.m01 = n[1].as<float>();
			m.m02 = n[2].as<float>();
			m.m03 = n[3].as<float>();
			m.m10 = n[4].as<float>();
			m.m11 = n[5].as<float>();
			m.m12 = n[6].as<float>();
			m.m13 = n[7].as<float>();
			m.m20 = n[8].as<float>();
			m.m21 = n[9].as<float>();
			m.m22 = n[10].as<float>();
			m.m23 = n[11].as<float>();
			m.m30 = n[12].as<float>();
			m.m31 = n[13].as<float>();
			m.m32 = n[14].as<float>();
			m.m33 = n[15].as<float>();
			return true;
		}
	};

	template<>
	struct convert<fs::path>
	{
		static Node encode(const fs::path& v) { Node n; n = v.string(); return n; }
		static bool decode(const Node& n, fs::path& v) { v = n.as<std::string>(); return true; }
	};

	template<>
	struct convert<asset_handle>
	{
		static Node encode(const asset_handle& v) { Node n; n = v.value; return n; }
		static bool decode(const Node& n, asset_handle& h) { h.value = n.as<uint64>(); return true; }
	};
}


#define YAML_LOAD(node, var, name) { auto nc = node[name]; if (nc) { var = nc.as<std::remove_reference_t<decltype(var)>>(); } }
#define YAML_LOAD_ENUM(node, var, name) { auto nc = node[name]; if (nc) { var = (std::remove_reference_t<decltype(var)>)(nc.as<int>()); } }



```

`src/dx/dx.h`:

```h
#pragma once

#include <dx/d3dx12.h>
#include <dxgi1_6.h>
#include <d3dcompiler.h>
#include <sdkddkver.h>


#define USE_D3D12_BLOCK_ALLOCATOR 0
namespace D3D12MA { class Allocator; class Allocation; };

#ifdef __ID3D12GraphicsCommandList6_INTERFACE_DEFINED__
#define SDK_SUPPORTS_MESH_SHADERS
#endif


typedef com<ID3D12Object> dx_object;
typedef com<IDXGIAdapter4> dx_adapter;
typedef com<ID3D12Device5> dx_device;
typedef com<IDXGIFactory4> dx_factory;
typedef com<IDXGISwapChain4> dx_swapchain;
typedef com<ID3D12Resource> dx_resource;
typedef com<ID3D12CommandAllocator> dx_command_allocator;
typedef com<ID3DBlob> dx_blob;
typedef com<ID3D12PipelineState> dx_pipeline_state;
typedef com<ID3D12Resource> dx_resource;
typedef com<ID3D12CommandSignature> dx_command_signature;
typedef com<ID3D12Heap> dx_heap;
typedef com<ID3D12StateObject> dx_raytracing_pipeline_state;
typedef com<ID3D12QueryHeap> dx_query_heap;

#ifdef SDK_SUPPORTS_MESH_SHADERS
typedef com<ID3D12GraphicsCommandList6> dx_graphics_command_list;
#else
typedef com<ID3D12GraphicsCommandList4> dx_graphics_command_list;
#endif

#define NUM_BUFFERED_FRAMES 2

#define SET_NAME(obj, name) checkResult(obj->SetName(L##name));



```

`src/dx/dx_barrier_batcher.cpp`:

```cpp
#include "pch.h"
#include "dx_barrier_batcher.h"
#include "dx_command_list.h"
#include "dx_context.h"
#include "dx_descriptor_allocation.h"


barrier_batcher::barrier_batcher(dx_command_list* cl)
{
	this->cl = cl;
}

barrier_batcher& barrier_batcher::transition(const dx_resource& res, D3D12_RESOURCE_STATES from, D3D12_RESOURCE_STATES to, uint32 subresource)
{
	if (numBarriers == arraysize(barriers))
	{
		submit();
	}

	if (from != to)
	{
		barriers[numBarriers++] = CD3DX12_RESOURCE_BARRIER::Transition(res.Get(), from, to, subresource);
	}
	return *this;
}

barrier_batcher& barrier_batcher::transition(const ref<dx_texture>& res, D3D12_RESOURCE_STATES from, D3D12_RESOURCE_STATES to, uint32 subresource)
{
	if (!res)
	{
		return *this;
	}

	return transition(res->resource, from, to, subresource);
}

barrier_batcher& barrier_batcher::transition(const ref<dx_buffer>& res, D3D12_RESOURCE_STATES from, D3D12_RESOURCE_STATES to)
{
	if (!res)
	{
		return *this;
	}

	return transition(res->resource, from, to);
}

barrier_batcher& barrier_batcher::transitionBegin(const dx_resource& res, D3D12_RESOURCE_STATES from, D3D12_RESOURCE_STATES to, uint32 subresource)
{
	if (numBarriers == arraysize(barriers))
	{
		submit();
	}

	if (from != to)
	{
		barriers[numBarriers++] = CD3DX12_RESOURCE_BARRIER::Transition(res.Get(), from, to, subresource, D3D12_RESOURCE_BARRIER_FLAG_BEGIN_ONLY);
	}
	return *this;
}

barrier_batcher& barrier_batcher::transitionBegin(const ref<dx_texture>& res, D3D12_RESOURCE_STATES from, D3D12_RESOURCE_STATES to, uint32 subresource)
{
	if (!res)
	{
		return *this;
	}

	return transitionBegin(res->resource, from, to, subresource);
}

barrier_batcher& barrier_batcher::transitionBegin(const ref<dx_buffer>& res, D3D12_RESOURCE_STATES from, D3D12_RESOURCE_STATES to)
{
	if (!res)
	{
		return *this;
	}

	return transitionBegin(res->resource, from, to);
}

barrier_batcher& barrier_batcher::transitionEnd(const dx_resource& res, D3D12_RESOURCE_STATES from, D3D12_RESOURCE_STATES to, uint32 subresource)
{
	if (numBarriers == arraysize(barriers))
	{
		submit();
	}

	if (from != to)
	{
		barriers[numBarriers++] = CD3DX12_RESOURCE_BARRIER::Transition(res.Get(), from, to, subresource, D3D12_RESOURCE_BARRIER_FLAG_END_ONLY);
	}
	return *this;
}

barrier_batcher& barrier_batcher::transitionEnd(const ref<dx_texture>& res, D3D12_RESOURCE_STATES from, D3D12_RESOURCE_STATES to, uint32 subresource)
{
	if (!res)
	{
		return *this;
	}

	return transitionEnd(res->resource, from, to, subresource);
}

barrier_batcher& barrier_batcher::transitionEnd(const ref<dx_buffer>& res, D3D12_RESOURCE_STATES from, D3D12_RESOURCE_STATES to)
{
	if (!res)
	{
		return *this;
	}

	return transitionEnd(res->resource, from, to);
}

barrier_batcher& barrier_batcher::uav(const dx_resource& resource)
{
	if (numBarriers == arraysize(barriers))
	{
		submit();
	}

	barriers[numBarriers++] = CD3DX12_RESOURCE_BARRIER::UAV(resource.Get());
	return *this;
}

barrier_batcher& barrier_batcher::uav(const ref<dx_texture>& res)
{
	if (!res)
	{
		return *this;
	}

	return uav(res->resource);
}

barrier_batcher& barrier_batcher::uav(const ref<dx_buffer>& res)
{
	if (!res)
	{
		return *this;
	}

	return uav(res->resource);
}

barrier_batcher& barrier_batcher::aliasing(const dx_resource& before, const dx_resource& after)
{
	if (numBarriers == arraysize(barriers))
	{
		submit();
	}

	barriers[numBarriers++] = CD3DX12_RESOURCE_BARRIER::Aliasing(before ? before.Get() : 0, after ? after.Get() : 0);
	return *this;
}

barrier_batcher& barrier_batcher::aliasing(const ref<dx_texture>& before, const ref<dx_texture>& after)
{
	return aliasing(before ? before->resource : 0, after ? after->resource : 0);
}

barrier_batcher& barrier_batcher::aliasing(const ref<dx_buffer>& before, const ref<dx_buffer>& after)
{
	return aliasing(before ? before->resource : 0, after ? after->resource : 0);
}

void barrier_batcher::submit()
{
	if (numBarriers)
	{
		cl->barriers(barriers, numBarriers);
		numBarriers = 0;
	}
}

```

`src/dx/dx_barrier_batcher.h`:

```h
#pragma once

#include "dx.h"

struct dx_texture;
struct dx_buffer;
struct dx_command_list;

struct barrier_batcher
{
	barrier_batcher(dx_command_list* cl);
	~barrier_batcher() { submit(); }


	barrier_batcher& transition(const dx_resource& res, D3D12_RESOURCE_STATES from, D3D12_RESOURCE_STATES to, uint32 subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES);
	barrier_batcher& transition(const ref<dx_texture>& res, D3D12_RESOURCE_STATES from, D3D12_RESOURCE_STATES to, uint32 subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES);
	barrier_batcher& transition(const ref<dx_buffer>& res, D3D12_RESOURCE_STATES from, D3D12_RESOURCE_STATES to);

	// Split barriers.
	barrier_batcher& transitionBegin(const dx_resource& res, D3D12_RESOURCE_STATES from, D3D12_RESOURCE_STATES to, uint32 subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES);
	barrier_batcher& transitionBegin(const ref<dx_texture>& res, D3D12_RESOURCE_STATES from, D3D12_RESOURCE_STATES to, uint32 subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES);
	barrier_batcher& transitionBegin(const ref<dx_buffer>& res, D3D12_RESOURCE_STATES from, D3D12_RESOURCE_STATES to);

	barrier_batcher& transitionEnd(const dx_resource& res, D3D12_RESOURCE_STATES from, D3D12_RESOURCE_STATES to, uint32 subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES);
	barrier_batcher& transitionEnd(const ref<dx_texture>& res, D3D12_RESOURCE_STATES from, D3D12_RESOURCE_STATES to, uint32 subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES);
	barrier_batcher& transitionEnd(const ref<dx_buffer>& res, D3D12_RESOURCE_STATES from, D3D12_RESOURCE_STATES to);



	barrier_batcher& uav(const dx_resource& res);
	barrier_batcher& uav(const ref<dx_texture>& res);
	barrier_batcher& uav(const ref<dx_buffer>& res);

	barrier_batcher& aliasing(const dx_resource& before, const dx_resource& after);
	barrier_batcher& aliasing(const ref<dx_texture>& before, const ref<dx_texture>& after);
	barrier_batcher& aliasing(const ref<dx_buffer>& before, const ref<dx_buffer>& after);

	void submit();

	dx_command_list* cl;
	CD3DX12_RESOURCE_BARRIER barriers[16];
	uint32 numBarriers = 0;
};



```

`src/dx/dx_buffer.cpp`:

```cpp
#include "pch.h"
#include "dx_buffer.h"
#include "dx_command_list.h"
#include "dx_context.h"

#include <d3d12memoryallocator/D3D12MemAlloc.h>

DXGI_FORMAT getIndexBufferFormat(uint32 elementSize)
{
	DXGI_FORMAT result = DXGI_FORMAT_UNKNOWN;
	if (elementSize == 1)
	{
		result = DXGI_FORMAT_R8_UINT;
	}
	else if (elementSize == 2)
	{
		result = DXGI_FORMAT_R16_UINT;
	}
	else if (elementSize == 4)
	{
		result = DXGI_FORMAT_R32_UINT;
	}
	return result;
}

void* mapBuffer(const ref<dx_buffer>& buffer, bool intentsReading, map_range readRange)
{
	D3D12_RANGE range = { 0, 0 };
	D3D12_RANGE* r = 0;

	if (intentsReading)
	{
		if (readRange.numElements != -1)
		{
			range.Begin = readRange.firstElement * buffer->elementSize;
			range.End = range.Begin + readRange.numElements * buffer->elementSize;
			r = &range;
		}
	}
	else
	{
		r = &range;
	}

	void* result;
	buffer->resource->Map(0, r, &result);
	return result;
}

void unmapBuffer(const ref<dx_buffer>& buffer, bool hasWritten, map_range writtenRange)
{
	D3D12_RANGE range = { 0, 0 };
	D3D12_RANGE* r = 0;

	if (hasWritten)
	{
		if (writtenRange.numElements != -1)
		{
			range.Begin = writtenRange.firstElement * buffer->elementSize;
			range.End = range.Begin + writtenRange.numElements * buffer->elementSize;
			r = &range;
		}
	}
	else
	{
		r = &range;
	}

	buffer->resource->Unmap(0, r);
}

void updateUploadBufferData(const ref<dx_buffer>& buffer, void* data, uint32 size)
{
	void* mapped = mapBuffer(buffer, false);
	memcpy(mapped, data, size);
	unmapBuffer(buffer, true);
}

static void uploadBufferData(ref<dx_buffer> buffer, const void* bufferData)
{
	dx_command_list* cl = dxContext.getFreeCopyCommandList();

	dx_resource intermediateResource;

	auto desc = CD3DX12_RESOURCE_DESC::Buffer(buffer->totalSize);

#if !USE_D3D12_BLOCK_ALLOCATOR

	CD3DX12_HEAP_PROPERTIES props(D3D12_HEAP_TYPE_UPLOAD);
	checkResult(dxContext.device->CreateCommittedResource(
		&props,
		D3D12_HEAP_FLAG_NONE,
		&desc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		0,
		IID_PPV_ARGS(&intermediateResource)));
#else
	D3D12MA::ALLOCATION_DESC allocationDesc = {};
	allocationDesc.HeapType = D3D12_HEAP_TYPE_UPLOAD;

	D3D12MA::Allocation* allocation;
	checkResult(dxContext.memoryAllocator->CreateResource(
		&allocationDesc,
		&desc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		0,
		&allocation,
		IID_PPV_ARGS(&intermediateResource)));

	dxContext.retire(allocation);
#endif

	D3D12_SUBRESOURCE_DATA subresourceData = {};
	subresourceData.pData = bufferData;
	subresourceData.RowPitch = buffer->totalSize;
	subresourceData.SlicePitch = subresourceData.RowPitch;

	cl->transitionBarrier(buffer, D3D12_RESOURCE_STATE_COMMON, D3D12_RESOURCE_STATE_COPY_DEST);

	UpdateSubresources(cl->commandList.Get(),
		buffer->resource.Get(), intermediateResource.Get(),
		0, 0, 1, &subresourceData);

	// We are omitting the transition to common here, since the resource automatically decays to common state after being accessed on a copy queue.

	dxContext.retire(intermediateResource);
	dxContext.executeCommandList(cl);
}

void updateBufferDataRange(ref<dx_buffer> buffer, const void* data, uint32 offset, uint32 size)
{
	ASSERT(offset + size <= buffer->totalSize);

	dx_command_list* cl = dxContext.getFreeCopyCommandList();

	dx_resource intermediateResource;

	auto desc = CD3DX12_RESOURCE_DESC::Buffer(size);

#if !USE_D3D12_BLOCK_ALLOCATOR
	
	CD3DX12_HEAP_PROPERTIES props(D3D12_HEAP_TYPE_UPLOAD);
	checkResult(dxContext.device->CreateCommittedResource(
		&props,
		D3D12_HEAP_FLAG_NONE,
		&desc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		0,
		IID_PPV_ARGS(&intermediateResource)));
#else
	D3D12MA::ALLOCATION_DESC allocationDesc = {};
	allocationDesc.HeapType = D3D12_HEAP_TYPE_UPLOAD;

	D3D12MA::Allocation* allocation;
	checkResult(dxContext.memoryAllocator->CreateResource(
		&allocationDesc,
		&desc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		0,
		&allocation,
		IID_PPV_ARGS(&intermediateResource)));

	dxContext.retire(allocation);
#endif

	cl->transitionBarrier(buffer, D3D12_RESOURCE_STATE_COMMON, D3D12_RESOURCE_STATE_COPY_DEST);

	void* mapped;
	checkResult(intermediateResource->Map(0, 0, &mapped));
	memcpy(mapped, data, size);
	intermediateResource->Unmap(0, 0);

	cl->commandList->CopyBufferRegion(buffer->resource.Get(), offset, intermediateResource.Get(), 0, size);

	// We are omitting the transition to common here, since the resource automatically decays to common state after being accessed on a copy queue.

	dxContext.retire(intermediateResource);
	dxContext.executeCommandList(cl);
}

static void initializeBuffer(ref<dx_buffer> buffer, uint32 elementSize, uint32 elementCount, void* data, bool allowUnorderedAccess, bool allowClearing, bool raytracing = false,
	D3D12_RESOURCE_STATES initialState = D3D12_RESOURCE_STATE_COMMON, D3D12_HEAP_TYPE heapType = D3D12_HEAP_TYPE_DEFAULT)
{
	D3D12_RESOURCE_FLAGS flags = allowUnorderedAccess ? D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS : D3D12_RESOURCE_FLAG_NONE;

	buffer->elementSize = elementSize;
	buffer->elementCount = elementCount;
	buffer->totalSize = elementSize * elementCount;
	buffer->heapType = heapType;
	buffer->supportsSRV = heapType != D3D12_HEAP_TYPE_READBACK;
	buffer->supportsUAV = allowUnorderedAccess;
	buffer->supportsClearing = allowClearing;
	buffer->raytracing = raytracing;

	buffer->defaultSRV = {};
	buffer->defaultUAV = {};
	buffer->cpuClearUAV = {};
	buffer->gpuClearUAV = {};
	buffer->raytracingSRV = {};

	auto desc = CD3DX12_RESOURCE_DESC::Buffer(buffer->totalSize, flags);

#if !USE_D3D12_BLOCK_ALLOCATOR

	CD3DX12_HEAP_PROPERTIES props(heapType);
	checkResult(dxContext.device->CreateCommittedResource(
		&props,
		D3D12_HEAP_FLAG_NONE,
		&desc,
		initialState,
		0,
		IID_PPV_ARGS(&buffer->resource)));
#else
	D3D12MA::ALLOCATION_DESC allocationDesc = {};
	allocationDesc.HeapType = heapType;

	D3D12MA::Allocation* allocation;
	checkResult(dxContext.memoryAllocator->CreateResource(
		&allocationDesc,
		&desc,
		initialState,
		0,
		&allocation,
		IID_PPV_ARGS(&buffer->resource)));

	buffer->allocation = allocation;
#endif

	buffer->gpuVirtualAddress = buffer->resource->GetGPUVirtualAddress();

	// Upload.
	if (data)
	{
		if (heapType == D3D12_HEAP_TYPE_DEFAULT)
		{
			uploadBufferData(buffer, data);
		}
		else if (heapType == D3D12_HEAP_TYPE_UPLOAD)
		{
			void* dataPtr = mapBuffer(buffer, false);
			memcpy(dataPtr, data, buffer->totalSize);
			unmapBuffer(buffer, true);
		}
	}

	uint32 numDescriptors = buffer->supportsSRV + buffer->supportsUAV + buffer->supportsClearing + raytracing;
	buffer->descriptorAllocation = dxContext.srvUavAllocator.allocate(numDescriptors);

	uint32 index = 0;

	if (buffer->supportsSRV)
	{
		buffer->defaultSRV = dx_cpu_descriptor_handle(buffer->descriptorAllocation.cpuAt(index++)).createBufferSRV(buffer);
	}

	if (buffer->supportsUAV)
	{
		buffer->defaultUAV = dx_cpu_descriptor_handle(buffer->descriptorAllocation.cpuAt(index++)).createBufferUAV(buffer);
	}

	if (buffer->supportsClearing)
	{
		buffer->cpuClearUAV = dx_cpu_descriptor_handle(buffer->descriptorAllocation.cpuAt(index++)).createBufferUintUAV(buffer);

		buffer->shaderVisibleDescriptorAllocation = dxContext.srvUavAllocatorShaderVisible.allocate(1);
		dx_cpu_descriptor_handle(buffer->shaderVisibleDescriptorAllocation.cpuAt(0)).createBufferUintUAV(buffer);
		buffer->gpuClearUAV = buffer->shaderVisibleDescriptorAllocation.gpuAt(0);
	}

	if (raytracing)
	{
		buffer->raytracingSRV = dx_cpu_descriptor_handle(buffer->descriptorAllocation.cpuAt(index++)).createRaytracingAccelerationStructureSRV(buffer);
	}

	ASSERT(index == numDescriptors);
}

ref<dx_buffer> createBuffer(uint32 elementSize, uint32 elementCount, void* data, bool allowUnorderedAccess, bool allowClearing, D3D12_RESOURCE_STATES initialState)
{
	ref<dx_buffer> result = make_ref<dx_buffer>();
	initializeBuffer(result, elementSize, elementCount, data, allowUnorderedAccess, allowClearing, false, initialState, D3D12_HEAP_TYPE_DEFAULT);
	return result;
}

ref<dx_buffer> createUploadBuffer(uint32 elementSize, uint32 elementCount, void* data)
{
	ref<dx_buffer> result = make_ref<dx_buffer>();
	initializeBuffer(result, elementSize, elementCount, data, false, false, false, D3D12_RESOURCE_STATE_GENERIC_READ, D3D12_HEAP_TYPE_UPLOAD);
	return result;
}

ref<dx_buffer> createReadbackBuffer(uint32 elementSize, uint32 elementCount, D3D12_RESOURCE_STATES initialState)
{
	ref<dx_buffer> result = make_ref<dx_buffer>();
	initializeBuffer(result, elementSize, elementCount, 0, false, false, false, initialState, D3D12_HEAP_TYPE_READBACK);
	return result;
}

ref<dx_vertex_buffer> createVertexBuffer(uint32 elementSize, uint32 elementCount, void* data, bool allowUnorderedAccess, bool allowClearing)
{
	ref<dx_vertex_buffer> result = make_ref<dx_vertex_buffer>();
	initializeBuffer(result, elementSize, elementCount, data, allowUnorderedAccess, allowClearing);
	result->view.BufferLocation = result->gpuVirtualAddress;
	result->view.SizeInBytes = result->totalSize;
	result->view.StrideInBytes = elementSize;
	return result;
}

ref<dx_vertex_buffer> createUploadVertexBuffer(uint32 elementSize, uint32 elementCount, void* data)
{
	ref<dx_vertex_buffer> result = make_ref<dx_vertex_buffer>();
	initializeBuffer(result, elementSize, elementCount, data, false, false, false, D3D12_RESOURCE_STATE_GENERIC_READ, D3D12_HEAP_TYPE_UPLOAD);
	result->view.BufferLocation = result->gpuVirtualAddress;
	result->view.SizeInBytes = result->totalSize;
	result->view.StrideInBytes = elementSize;
	return result;
}

ref<dx_index_buffer> createIndexBuffer(uint32 elementSize, uint32 elementCount, void* data, bool allowUnorderedAccess, bool allowClearing)
{
	ref<dx_index_buffer> result = make_ref<dx_index_buffer>();
	initializeBuffer(result, elementSize, elementCount, data, allowUnorderedAccess, allowClearing);
	result->view.BufferLocation = result->gpuVirtualAddress;
	result->view.SizeInBytes = result->totalSize;
	result->view.Format = getIndexBufferFormat(elementSize);
	return result;
}

ref<dx_buffer> createRaytracingTLASBuffer(uint32 size)
{
	ref<dx_buffer> result = make_ref<dx_buffer>();
	initializeBuffer(result, size, 1, nullptr, true, false, true, D3D12_RESOURCE_STATE_RAYTRACING_ACCELERATION_STRUCTURE);
	return result;
}

static void retire(dx_resource resource, dx_descriptor_allocation descriptorAllocation, dx_descriptor_allocation shaderVisibleDescriptorAllocation)
{
	buffer_grave grave;
	grave.resource = resource;
	grave.descriptorAllocation = descriptorAllocation;
	grave.shaderVisibleDescriptorAllocation = shaderVisibleDescriptorAllocation;
	dxContext.retire(std::move(grave));
}

dx_buffer::~dx_buffer()
{
	retire(resource, descriptorAllocation, shaderVisibleDescriptorAllocation);
	if (allocation)
	{
		dxContext.retire(allocation);
	}
}

void resizeBuffer(ref<dx_buffer> buffer, uint32 newElementCount, D3D12_RESOURCE_STATES initialState)
{
	retire(buffer->resource, buffer->descriptorAllocation, buffer->shaderVisibleDescriptorAllocation);
	if (buffer->allocation)
	{
		dxContext.retire(buffer->allocation);
	}

	buffer->elementCount = newElementCount;
	buffer->totalSize = buffer->elementCount * buffer->elementSize;

	auto desc = buffer->resource->GetDesc();

	auto bufferDesc = CD3DX12_RESOURCE_DESC::Buffer(buffer->totalSize, desc.Flags);

#if !USE_D3D12_BLOCK_ALLOCATOR

	CD3DX12_HEAP_PROPERTIES props(buffer->heapType);
	checkResult(dxContext.device->CreateCommittedResource(
		&props,
		D3D12_HEAP_FLAG_NONE,
		&bufferDesc,
		initialState,
		0,
		IID_PPV_ARGS(&buffer->resource)));
#else
	D3D12MA::ALLOCATION_DESC allocationDesc = {};
	allocationDesc.HeapType = buffer->heapType;

	D3D12MA::Allocation* allocation;
	checkResult(dxContext.memoryAllocator->CreateResource(
		&allocationDesc,
		&bufferDesc,
		initialState,
		0,
		&allocation,
		IID_PPV_ARGS(&buffer->resource)));

	buffer->allocation = allocation;
#endif

	buffer->gpuVirtualAddress = buffer->resource->GetGPUVirtualAddress();


	uint32 numDescriptors = buffer->supportsSRV + buffer->supportsUAV + buffer->supportsClearing + buffer->raytracing;
	buffer->descriptorAllocation = dxContext.srvUavAllocator.allocate(numDescriptors);

	uint32 index = 0;

	if (buffer->supportsSRV)
	{
		buffer->defaultSRV = dx_cpu_descriptor_handle(buffer->descriptorAllocation.cpuAt(index++)).createBufferSRV(buffer);
	}

	if (buffer->supportsUAV)
	{
		buffer->defaultUAV = dx_cpu_descriptor_handle(buffer->descriptorAllocation.cpuAt(index++)).createBufferUAV(buffer);
	}

	if (buffer->supportsClearing)
	{
		buffer->cpuClearUAV = dx_cpu_descriptor_handle(buffer->descriptorAllocation.cpuAt(index++)).createBufferUintUAV(buffer);

		buffer->shaderVisibleDescriptorAllocation = dxContext.srvUavAllocatorShaderVisible.allocate(1);
		dx_cpu_descriptor_handle(buffer->shaderVisibleDescriptorAllocation.cpuAt(0)).createBufferUintUAV(buffer);
		buffer->gpuClearUAV = buffer->shaderVisibleDescriptorAllocation.gpuAt(0);
	}

	if (buffer->raytracing)
	{
		buffer->raytracingSRV = dx_cpu_descriptor_handle(buffer->descriptorAllocation.cpuAt(index++)).createRaytracingAccelerationStructureSRV(buffer);
	}

	ASSERT(index == numDescriptors);
}

buffer_grave::~buffer_grave()
{
	if (resource)
	{
		dxContext.srvUavAllocator.free(descriptorAllocation);
		dxContext.srvUavAllocatorShaderVisible.free(shaderVisibleDescriptorAllocation);
	}
}

```

`src/dx/dx_buffer.h`:

```h
#pragma once

#include "dx_descriptor.h"
#include "dx_descriptor_allocation.h"

struct dx_dynamic_constant_buffer
{
	D3D12_GPU_VIRTUAL_ADDRESS gpuPtr;
};

struct dx_dynamic_vertex_buffer
{
	D3D12_VERTEX_BUFFER_VIEW view;
};

struct dx_dynamic_index_buffer
{
	D3D12_INDEX_BUFFER_VIEW view;
};

struct dx_buffer
{
	virtual ~dx_buffer();

	dx_resource resource;
	D3D12MA::Allocation* allocation = 0;


	dx_descriptor_allocation descriptorAllocation = {};
	dx_descriptor_allocation shaderVisibleDescriptorAllocation = {};


	dx_cpu_descriptor_handle defaultSRV;
	dx_cpu_descriptor_handle defaultUAV;

	dx_cpu_descriptor_handle cpuClearUAV;
	dx_gpu_descriptor_handle gpuClearUAV;

	dx_cpu_descriptor_handle raytracingSRV;

	D3D12_GPU_VIRTUAL_ADDRESS gpuVirtualAddress;

	bool supportsUAV;
	bool supportsSRV;
	bool supportsClearing;
	bool raytracing;

	uint32 elementSize = 0;
	uint32 elementCount = 0;
	uint32 totalSize = 0;
	D3D12_HEAP_TYPE heapType;
};

struct dx_vertex_buffer : dx_buffer
{
	D3D12_VERTEX_BUFFER_VIEW view;
};

struct dx_index_buffer : dx_buffer
{
	D3D12_INDEX_BUFFER_VIEW view;
};

struct vertex_buffer_group
{
	ref<dx_vertex_buffer> positions;
	ref<dx_vertex_buffer> others; // Uvs, normals, tangents, etc.
};

struct dx_vertex_buffer_view
{
	D3D12_VERTEX_BUFFER_VIEW view;

	dx_vertex_buffer_view() { view.SizeInBytes = 0; }
	dx_vertex_buffer_view(const ref<dx_vertex_buffer>& vb) : view(vb ? vb->view : D3D12_VERTEX_BUFFER_VIEW{ 0 }) {}
	dx_vertex_buffer_view(const dx_dynamic_vertex_buffer& vb) : view(vb.view) {}
	dx_vertex_buffer_view(const dx_vertex_buffer_view&) = default;
	dx_vertex_buffer_view(dx_vertex_buffer_view&&) = default;

	dx_vertex_buffer_view& operator=(const dx_vertex_buffer_view&) = default;
	dx_vertex_buffer_view& operator=(dx_vertex_buffer_view&&) = default;

	operator bool() const { return view.SizeInBytes > 0; }
	operator const D3D12_VERTEX_BUFFER_VIEW& () const { return view; }
};

struct dx_vertex_buffer_group_view
{
	dx_vertex_buffer_view positions;
	dx_vertex_buffer_view others;

	dx_vertex_buffer_group_view() { positions.view.SizeInBytes = 0; others.view.SizeInBytes = 0; }
	dx_vertex_buffer_group_view(const dx_vertex_buffer_view& positions, const dx_vertex_buffer_view& others = {}) : positions(positions), others(others) {}
	dx_vertex_buffer_group_view(const vertex_buffer_group& vb) : positions(vb.positions), others(vb.others) {}
	dx_vertex_buffer_group_view(const dx_vertex_buffer_group_view&) = default;
	dx_vertex_buffer_group_view(dx_vertex_buffer_group_view&&) = default;

	dx_vertex_buffer_group_view& operator=(const dx_vertex_buffer_group_view&) = default;
	dx_vertex_buffer_group_view& operator=(dx_vertex_buffer_group_view&&) = default;

	operator bool() const { return positions && others; }
};

struct dx_index_buffer_view
{
	D3D12_INDEX_BUFFER_VIEW view;

	dx_index_buffer_view() { view.SizeInBytes = 0; }
	dx_index_buffer_view(const ref<dx_index_buffer>& vb) : view(vb->view) {}
	dx_index_buffer_view(const dx_dynamic_index_buffer& vb) : view(vb.view) {}
	dx_index_buffer_view(const dx_index_buffer_view&) = default;
	dx_index_buffer_view(dx_index_buffer_view&&) = default;

	dx_index_buffer_view& operator=(const dx_index_buffer_view&) = default;
	dx_index_buffer_view& operator=(dx_index_buffer_view&&) = default;

	operator bool() const { return view.SizeInBytes > 0; }
	operator const D3D12_INDEX_BUFFER_VIEW& () const { return view; }
};

struct dx_mesh
{
	vertex_buffer_group vertexBuffer;
	ref<dx_index_buffer> indexBuffer;
};

struct buffer_grave
{
	dx_resource resource;

	dx_descriptor_allocation descriptorAllocation = {};
	dx_descriptor_allocation shaderVisibleDescriptorAllocation = {};

	buffer_grave() {}
	buffer_grave(const buffer_grave& o) = delete;
	buffer_grave(buffer_grave&& o) = default;

	buffer_grave& operator=(const buffer_grave& o) = delete;
	buffer_grave& operator=(buffer_grave&& o) = default;

	~buffer_grave();
};

DXGI_FORMAT getIndexBufferFormat(uint32 elementSize);

struct map_range
{
	uint32 firstElement = 0;
	uint32 numElements = (uint32)-1;
};

// I think this API could be simplified. I *think* you can only map upload and readback buffers. Upload buffers are only used for writing and readback buffers only for reading.
void* mapBuffer(const ref<dx_buffer>& buffer, bool intentsReading, map_range readRange = { });
void unmapBuffer(const ref<dx_buffer>& buffer, bool hasWritten, map_range writtenRange = { });

void updateBufferDataRange(ref<dx_buffer> buffer, const void* data, uint32 offset, uint32 size);
void updateUploadBufferData(const ref<dx_buffer>& buffer, void* data, uint32 size);

ref<dx_buffer> createBuffer(uint32 elementSize, uint32 elementCount, void* data, bool allowUnorderedAccess = false, bool allowClearing = false, D3D12_RESOURCE_STATES initialState = D3D12_RESOURCE_STATE_COMMON);
ref<dx_buffer> createUploadBuffer(uint32 elementSize, uint32 elementCount, void* data);
ref<dx_buffer> createReadbackBuffer(uint32 elementSize, uint32 elementCount, D3D12_RESOURCE_STATES initialState = D3D12_RESOURCE_STATE_COPY_DEST);
ref<dx_vertex_buffer> createVertexBuffer(uint32 elementSize, uint32 elementCount, void* data, bool allowUnorderedAccess = false, bool allowClearing = false);
ref<dx_vertex_buffer> createUploadVertexBuffer(uint32 elementSize, uint32 elementCount, void* data);
ref<dx_index_buffer> createIndexBuffer(uint32 elementSize, uint32 elementCount, void* data, bool allowUnorderedAccess = false, bool allowClearing = false);

ref<dx_buffer> createRaytracingTLASBuffer(uint32 size);

void resizeBuffer(ref<dx_buffer> buffer, uint32 newElementCount, D3D12_RESOURCE_STATES initialState = D3D12_RESOURCE_STATE_COMMON);

```

`src/dx/dx_command_list.cpp`:

```cpp
#include "pch.h"
#include "dx_command_list.h"
#include "dx_context.h"

dx_command_list::dx_command_list(D3D12_COMMAND_LIST_TYPE type)
{
	this->type = type;
	checkResult(dxContext.device->CreateCommandAllocator(type, IID_PPV_ARGS(&commandAllocator)));
	checkResult(dxContext.device->CreateCommandList(0, type, commandAllocator.Get(), 0, IID_PPV_ARGS(&commandList)));

	dynamicDescriptorHeap.initialize();
}

void dx_command_list::barriers(CD3DX12_RESOURCE_BARRIER* barriers, uint32 numBarriers)
{
	commandList->ResourceBarrier(numBarriers, barriers);
}

void dx_command_list::transitionBarrier(const ref<dx_texture>& texture, D3D12_RESOURCE_STATES from, D3D12_RESOURCE_STATES to, uint32 subresource)
{
	transitionBarrier(texture->resource, from, to, subresource);
}

void dx_command_list::transitionBarrier(const ref<dx_buffer>& buffer, D3D12_RESOURCE_STATES from, D3D12_RESOURCE_STATES to, uint32 subresource)
{
	transitionBarrier(buffer->resource, from, to, subresource);
}

void dx_command_list::transitionBarrier(dx_resource resource, D3D12_RESOURCE_STATES from, D3D12_RESOURCE_STATES to, uint32 subresource)
{
	CD3DX12_RESOURCE_BARRIER barrier = CD3DX12_RESOURCE_BARRIER::Transition(resource.Get(), from, to, subresource);
	commandList->ResourceBarrier(1, &barrier);
}

void dx_command_list::uavBarrier(const ref<dx_texture>& texture)
{
	uavBarrier(texture->resource);
}

void dx_command_list::uavBarrier(const ref<dx_buffer>& buffer)
{
	uavBarrier(buffer->resource);
}

void dx_command_list::uavBarrier(dx_resource resource)
{
	CD3DX12_RESOURCE_BARRIER barrier = CD3DX12_RESOURCE_BARRIER::UAV(resource.Get());
	commandList->ResourceBarrier(1, &barrier);
}

void dx_command_list::aliasingBarrier(const ref<dx_texture>& before, const ref<dx_texture>& after)
{
	aliasingBarrier(before->resource, after->resource);
}

void dx_command_list::aliasingBarrier(const ref<dx_buffer>& before, const ref<dx_buffer>& after)
{
	aliasingBarrier(before->resource, after->resource);
}

void dx_command_list::aliasingBarrier(dx_resource before, dx_resource after)
{
	CD3DX12_RESOURCE_BARRIER barrier = CD3DX12_RESOURCE_BARRIER::Aliasing(before.Get(), after.Get());
	commandList->ResourceBarrier(1, &barrier);
}

void dx_command_list::assertResourceState(const ref<dx_texture>& texture, D3D12_RESOURCE_STATES state, uint32 subresource)
{
	assertResourceState(texture->resource, state, subresource);
}

void dx_command_list::assertResourceState(const ref<dx_buffer>& buffer, D3D12_RESOURCE_STATES state, uint32 subresource)
{
	assertResourceState(buffer->resource, state, subresource);
}

void dx_command_list::assertResourceState(dx_resource resource, D3D12_RESOURCE_STATES state, uint32 subresource)
{
#ifdef _DEBUG
	ID3D12DebugCommandList* debugCL = 0;
	if (SUCCEEDED(commandList->QueryInterface(IID_PPV_ARGS(&debugCL))))
	{
		ASSERT(debugCL->AssertResourceState(resource.Get(), subresource, state));
	}
#endif
}

void dx_command_list::copyResource(dx_resource from, dx_resource to)
{
	commandList->CopyResource(to.Get(), from.Get());
}

void dx_command_list::copyTextureRegionToBuffer(const ref<dx_texture>& from, const ref<dx_buffer>& to, uint32 bufferElementOffset, uint32 x, uint32 y, uint32 width, uint32 height)
{
	copyTextureRegionToBuffer(from->resource, from->width, from->format, to, bufferElementOffset, x, y, width, height);
}

void dx_command_list::copyTextureRegionToBuffer(const dx_resource& from, uint32 fromWidth, DXGI_FORMAT format, const ref<dx_buffer>& to, uint32 bufferElementOffset, uint32 x, uint32 y, uint32 width, uint32 height)
{
	uint32 numPixelsToCopy = width * height;

	uint32 numRows = bucketize(numPixelsToCopy, fromWidth);
	uint32 destWidth = (numRows == 1) ? to->elementCount : fromWidth;

	D3D12_TEXTURE_COPY_LOCATION destLocation = {};
	destLocation.Type = D3D12_TEXTURE_COPY_TYPE_PLACED_FOOTPRINT;
	destLocation.pResource = to->resource.Get();
	destLocation.SubresourceIndex = 0;
	destLocation.PlacedFootprint.Offset = 0;
	destLocation.PlacedFootprint.Footprint.Format = format;
	destLocation.PlacedFootprint.Footprint.Width = destWidth;
	destLocation.PlacedFootprint.Footprint.Height = numRows;
	destLocation.PlacedFootprint.Footprint.Depth = 1;
	destLocation.PlacedFootprint.Footprint.RowPitch = alignTo(destWidth * getFormatSize(format), D3D12_TEXTURE_DATA_PITCH_ALIGNMENT);

	D3D12_TEXTURE_COPY_LOCATION srcLocation = {};
	srcLocation.Type = D3D12_TEXTURE_COPY_TYPE_SUBRESOURCE_INDEX;
	srcLocation.SubresourceIndex = 0;
	srcLocation.pResource = from.Get();

	D3D12_BOX srcBox = { x, y, 0, x + width, y + height, 1 };
	commandList->CopyTextureRegion(&destLocation, bufferElementOffset, 0, 0, &srcLocation, &srcBox);
}

void dx_command_list::copyTextureRegionToTexture(const ref<dx_texture>& from, const ref<dx_texture>& to, uint32 sourceX, uint32 sourceY, uint32 destX, uint32 destY, uint32 width, uint32 height)
{
	D3D12_TEXTURE_COPY_LOCATION destLocation = { to->resource.Get(), D3D12_TEXTURE_COPY_TYPE_SUBRESOURCE_INDEX, 0 };
	D3D12_TEXTURE_COPY_LOCATION srcLocation = { from->resource.Get(), D3D12_TEXTURE_COPY_TYPE_SUBRESOURCE_INDEX, 0 };

	D3D12_BOX srcBox = { sourceX, sourceY, 0, sourceX + width, sourceY + height, 1 };
	commandList->CopyTextureRegion(&destLocation, destX, destY, 0, &srcLocation, &srcBox);
}

void dx_command_list::copyBufferRegionToBuffer(const ref<dx_buffer>& from, const ref<dx_buffer>& to, uint32 fromElementOffset, uint32 numElements, uint32 toElementOffset)
{
	commandList->CopyBufferRegion(to->resource.Get(), toElementOffset * to->elementSize, from->resource.Get(), fromElementOffset * from->elementSize, numElements * from->elementSize);
}

void dx_command_list::copyBufferRegionToBuffer_ByteOffset(const ref<dx_buffer>& from, const ref<dx_buffer>& to, uint32 fromByteOffset, uint32 numBytes, uint32 toByteOffset)
{
	commandList->CopyBufferRegion(to->resource.Get(), toByteOffset, from->resource.Get(), fromByteOffset, numBytes);
}

void dx_command_list::setPipelineState(dx_pipeline_state pipelineState)
{
	commandList->SetPipelineState(pipelineState.Get());
}

void dx_command_list::setPipelineState(dx_raytracing_pipeline_state pipelineState)
{
	commandList->SetPipelineState1(pipelineState.Get());
}

void dx_command_list::setGraphicsRootSignature(const dx_root_signature& rootSignature)
{
	dynamicDescriptorHeap.parseRootSignature(rootSignature);
	commandList->SetGraphicsRootSignature(rootSignature.rootSignature.Get());
}

void dx_command_list::setGraphics32BitConstants(uint32 rootParameterIndex, uint32 numConstants, const void* constants)
{
	commandList->SetGraphicsRoot32BitConstants(rootParameterIndex, numConstants, constants, 0);
}

void dx_command_list::setComputeRootSignature(const dx_root_signature& rootSignature)
{
	dynamicDescriptorHeap.parseRootSignature(rootSignature);
	commandList->SetComputeRootSignature(rootSignature.rootSignature.Get());
}

void dx_command_list::setCompute32BitConstants(uint32 rootParameterIndex, uint32 numConstants, const void* constants)
{
	commandList->SetComputeRoot32BitConstants(rootParameterIndex, numConstants, constants, 0);
}

void dx_command_list::setGraphicsDynamicConstantBuffer(uint32 rootParameterIndex, dx_dynamic_constant_buffer address)
{
	commandList->SetGraphicsRootConstantBufferView(rootParameterIndex, address.gpuPtr);
}

void dx_command_list::setComputeDynamicConstantBuffer(uint32 rootParameterIndex, dx_dynamic_constant_buffer address)
{
	commandList->SetComputeRootConstantBufferView(rootParameterIndex, address.gpuPtr);
}

void dx_command_list::setRootGraphicsUAV(uint32 rootParameterIndex, const ref<dx_buffer>& buffer)
{
	commandList->SetGraphicsRootUnorderedAccessView(rootParameterIndex, buffer->gpuVirtualAddress);
}

void dx_command_list::setRootGraphicsUAV(uint32 rootParameterIndex, D3D12_GPU_VIRTUAL_ADDRESS address)
{
	commandList->SetGraphicsRootUnorderedAccessView(rootParameterIndex, address);
}

void dx_command_list::setRootComputeUAV(uint32 rootParameterIndex, const ref<dx_buffer>& buffer)
{
	commandList->SetComputeRootUnorderedAccessView(rootParameterIndex, buffer->gpuVirtualAddress);
}

void dx_command_list::setRootComputeUAV(uint32 rootParameterIndex, D3D12_GPU_VIRTUAL_ADDRESS address)
{
	commandList->SetComputeRootUnorderedAccessView(rootParameterIndex, address);
}

void dx_command_list::setRootGraphicsSRV(uint32 rootParameterIndex, const ref<dx_buffer>& buffer)
{
	commandList->SetGraphicsRootShaderResourceView(rootParameterIndex, buffer->gpuVirtualAddress);
}

void dx_command_list::setRootGraphicsSRV(uint32 rootParameterIndex, D3D12_GPU_VIRTUAL_ADDRESS address)
{
	commandList->SetGraphicsRootShaderResourceView(rootParameterIndex, address);
}

void dx_command_list::setRootComputeSRV(uint32 rootParameterIndex, const ref<dx_buffer>& buffer)
{
	commandList->SetComputeRootShaderResourceView(rootParameterIndex, buffer->gpuVirtualAddress);
}

void dx_command_list::setRootComputeSRV(uint32 rootParameterIndex, D3D12_GPU_VIRTUAL_ADDRESS address)
{
	commandList->SetComputeRootShaderResourceView(rootParameterIndex, address);
}

void dx_command_list::setDescriptorHeapResource(uint32 rootParameterIndex, uint32 offset, uint32 count, dx_cpu_descriptor_handle handle)
{
	dynamicDescriptorHeap.stageDescriptors(rootParameterIndex, offset, count, handle);
}

void dx_command_list::setDescriptorHeap(dx_descriptor_range& descriptorRange)
{
	descriptorHeaps[D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV] = descriptorRange.descriptorHeap.Get();

	uint32 numDescriptorHeaps = 0;
	ID3D12DescriptorHeap* heaps[D3D12_DESCRIPTOR_HEAP_TYPE_NUM_TYPES] = {};

	for (uint32_t i = 0; i < D3D12_DESCRIPTOR_HEAP_TYPE_NUM_TYPES; ++i)
	{
		ID3D12DescriptorHeap* heap = descriptorHeaps[i];
		if (heap)
		{
			heaps[numDescriptorHeaps++] = heap;
		}
	}

	commandList->SetDescriptorHeaps(numDescriptorHeaps, heaps);
}

void dx_command_list::setDescriptorHeap(D3D12_DESCRIPTOR_HEAP_TYPE type, com<ID3D12DescriptorHeap> descriptorHeap)
{
	descriptorHeaps[type] = descriptorHeap.Get();

	uint32 numDescriptorHeaps = 0;
	ID3D12DescriptorHeap* heaps[D3D12_DESCRIPTOR_HEAP_TYPE_NUM_TYPES] = {};

	for (uint32_t i = 0; i < D3D12_DESCRIPTOR_HEAP_TYPE_NUM_TYPES; ++i)
	{
		ID3D12DescriptorHeap* heap = descriptorHeaps[i];
		if (heap)
		{
			heaps[numDescriptorHeaps++] = heap;
		}
	}

	commandList->SetDescriptorHeaps(numDescriptorHeaps, heaps);
}

void dx_command_list::resetToDynamicDescriptorHeap()
{
	dynamicDescriptorHeap.setCurrentDescriptorHeap(this);
}

void dx_command_list::setGraphicsDescriptorTable(uint32 rootParameterIndex, CD3DX12_GPU_DESCRIPTOR_HANDLE handle)
{
	commandList->SetGraphicsRootDescriptorTable(rootParameterIndex, handle);
}

void dx_command_list::setComputeDescriptorTable(uint32 rootParameterIndex, CD3DX12_GPU_DESCRIPTOR_HANDLE handle)
{
	commandList->SetComputeRootDescriptorTable(rootParameterIndex, handle);
}

void dx_command_list::clearUAV(const ref<dx_buffer>& buffer, float val)
{
	clearUAV(buffer->resource, buffer->cpuClearUAV, buffer->gpuClearUAV, val);
}

void dx_command_list::clearUAV(const ref<dx_buffer>& buffer, uint32 val)
{
	clearUAV(buffer->resource, buffer->cpuClearUAV, buffer->gpuClearUAV, val);
}

void dx_command_list::clearUAV(dx_resource resource, dx_cpu_descriptor_handle cpuHandle, dx_gpu_descriptor_handle gpuHandle, float val)
{
	float vals[] = { val, val, val, val };
	commandList->ClearUnorderedAccessViewFloat(gpuHandle, cpuHandle, resource.Get(), vals, 0, 0);
}

void dx_command_list::clearUAV(dx_resource resource, dx_cpu_descriptor_handle cpuHandle, dx_gpu_descriptor_handle gpuHandle, uint32 val)
{
	uint32 vals[] = { val, val, val, val };
	commandList->ClearUnorderedAccessViewUint(gpuHandle, cpuHandle, resource.Get(), vals, 0, 0);
}

void dx_command_list::setPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY topology)
{
	commandList->IASetPrimitiveTopology(topology);
}

void dx_command_list::setVertexBuffer(uint32 slot, const ref<dx_vertex_buffer>& buffer)
{
	commandList->IASetVertexBuffers(slot, 1, &buffer->view);
}

void dx_command_list::setVertexBuffer(uint32 slot, const dx_dynamic_vertex_buffer& buffer)
{
	commandList->IASetVertexBuffers(slot, 1, &buffer.view);
}

void dx_command_list::setVertexBuffer(uint32 slot, const D3D12_VERTEX_BUFFER_VIEW& buffer)
{
	commandList->IASetVertexBuffers(slot, 1, &buffer);
}

void dx_command_list::setIndexBuffer(const ref<dx_index_buffer>& buffer)
{
	commandList->IASetIndexBuffer(&buffer->view);
}

void dx_command_list::setIndexBuffer(const dx_dynamic_index_buffer& buffer)
{
	commandList->IASetIndexBuffer(&buffer.view);
}

void dx_command_list::setIndexBuffer(const D3D12_INDEX_BUFFER_VIEW& buffer)
{
	commandList->IASetIndexBuffer(&buffer);
}

void dx_command_list::setViewport(const D3D12_VIEWPORT& viewport)
{
	commandList->RSSetViewports(1, &viewport);
}

void dx_command_list::setViewport(float x, float y, float width, float height, float minDepth, float maxDepth)
{
	D3D12_VIEWPORT viewport = { x, y, width, height, minDepth, maxDepth };
	setViewport(viewport);
}

void dx_command_list::setScissor(const D3D12_RECT& scissor)
{
	commandList->RSSetScissorRects(1, &scissor);
}

void dx_command_list::setRenderTarget(const dx_rtv_descriptor_handle* rtvs, uint32 numRTVs, const dx_dsv_descriptor_handle* dsv)
{
	commandList->OMSetRenderTargets(numRTVs, (D3D12_CPU_DESCRIPTOR_HANDLE*)rtvs, FALSE, (D3D12_CPU_DESCRIPTOR_HANDLE*)dsv);
}

void dx_command_list::setRenderTarget(const dx_render_target& renderTarget)
{
	setRenderTarget(renderTarget.rtv, renderTarget.numAttachments, renderTarget.dsv ? &renderTarget.dsv : 0);
}

static void getD3D12Rects(D3D12_RECT* d3rects, const clear_rect* rects, uint32 numRects)
{
	for (uint32 i = 0; i < numRects; ++i)
	{
		d3rects[i] = { (LONG)rects[i].x, (LONG)rects[i].y, (LONG)rects[i].x + (LONG)rects[i].width, (LONG)rects[i].y + (LONG)rects[i].height };
	}
}

void dx_command_list::clearRTV(dx_rtv_descriptor_handle rtv, float r, float g, float b, float a, const clear_rect* rects, uint32 numRects)
{
	float clearColor[] = { r, g, b, a };
	clearRTV(rtv, clearColor, rects, numRects);
}

void dx_command_list::clearRTV(dx_rtv_descriptor_handle rtv, const float* clearColor, const clear_rect* rects, uint32 numRects)
{
	D3D12_RECT* d3rects = 0;
	if (numRects)
	{
		d3rects = (D3D12_RECT*)alloca(sizeof(D3D12_RECT) * numRects);
		getD3D12Rects(d3rects, rects, numRects);
	}

	commandList->ClearRenderTargetView(rtv, clearColor, numRects, d3rects);
}

void dx_command_list::clearRTV(const ref<dx_texture>& texture, float r, float g, float b, float a, const clear_rect* rects, uint32 numRects)
{
	clearRTV(texture->defaultRTV, r, g, b, a, rects, numRects);
}

void dx_command_list::clearRTV(const ref<dx_texture>& texture, const float* clearColor, const clear_rect* rects, uint32 numRects)
{
	clearRTV(texture->defaultRTV, clearColor, rects, numRects);
}

void dx_command_list::clearRTV(const dx_render_target& renderTarget, uint32 attachment, const float* clearColor, const clear_rect* rects, uint32 numRects)
{
	clearRTV(renderTarget.rtv[attachment], clearColor, rects, numRects);
}

void dx_command_list::clearRTV(const dx_render_target& renderTarget, uint32 attachment, float r, float g, float b, float a, const clear_rect* rects, uint32 numRects)
{
	clearRTV(renderTarget.rtv[attachment], r, g, b, a, rects, numRects);
}

void dx_command_list::clearDepth(dx_dsv_descriptor_handle dsv, float depth, const clear_rect* rects, uint32 numRects)
{
	D3D12_RECT* d3rects = 0;
	if (numRects)
	{
		d3rects = (D3D12_RECT*)alloca(sizeof(D3D12_RECT) * numRects);
		getD3D12Rects(d3rects, rects, numRects);
	}

	commandList->ClearDepthStencilView(dsv, D3D12_CLEAR_FLAG_DEPTH, depth, 0, numRects, d3rects);
}

void dx_command_list::clearDepth(const ref<dx_texture>& texture, float depth, const clear_rect* rects, uint32 numRects)
{
	clearDepth(texture->defaultDSV, depth, rects, numRects);
}

void dx_command_list::clearDepth(const dx_render_target& renderTarget, float depth, const clear_rect* rects, uint32 numRects)
{
	clearDepth(renderTarget.dsv, depth, rects, numRects);
}

void dx_command_list::clearStencil(dx_dsv_descriptor_handle dsv, uint32 stencil, const clear_rect* rects, uint32 numRects)
{
	D3D12_RECT* d3rects = 0;
	if (numRects)
	{
		d3rects = (D3D12_RECT*)alloca(sizeof(D3D12_RECT) * numRects);
		getD3D12Rects(d3rects, rects, numRects);
	}

	commandList->ClearDepthStencilView(dsv, D3D12_CLEAR_FLAG_STENCIL, 0.f, stencil, numRects, d3rects);
}

void dx_command_list::clearStencil(const ref<dx_texture>& texture, uint32 stencil, const clear_rect* rects, uint32 numRects)
{
	clearStencil(texture->defaultDSV, stencil, rects, numRects);
}

void dx_command_list::clearStencil(const dx_render_target& renderTarget, uint32 stencil, const clear_rect* rects, uint32 numRects)
{
	clearStencil(renderTarget.dsv, stencil, rects, numRects);
}

void dx_command_list::clearDepthAndStencil(dx_dsv_descriptor_handle dsv, float depth, uint32 stencil, const clear_rect* rects, uint32 numRects)
{
	D3D12_RECT* d3rects = 0;
	if (numRects)
	{
		d3rects = (D3D12_RECT*)alloca(sizeof(D3D12_RECT) * numRects);
		getD3D12Rects(d3rects, rects, numRects);
	}

	commandList->ClearDepthStencilView(dsv, D3D12_CLEAR_FLAG_DEPTH | D3D12_CLEAR_FLAG_STENCIL, depth, stencil, numRects, d3rects);
}

void dx_command_list::clearDepthAndStencil(const ref<dx_texture>& texture, float depth, uint32 stencil, const clear_rect* rects, uint32 numRects)
{
	clearDepthAndStencil(texture->defaultDSV, depth, stencil, rects, numRects);
}

void dx_command_list::clearDepthAndStencil(const dx_render_target& renderTarget, float depth, uint32 stencil, const clear_rect* rects, uint32 numRects)
{
	clearDepthAndStencil(renderTarget.dsv, depth, stencil, rects, numRects);
}

void dx_command_list::setStencilReference(uint32 stencilReference)
{
	commandList->OMSetStencilRef(stencilReference);
}

void dx_command_list::setBlendFactor(float blendR, float blendG, float blendB, float blendA)
{
	const float blendFactor[] = { blendR, blendG, blendB, blendA };
	commandList->OMSetBlendFactor(blendFactor);
}

void dx_command_list::draw(uint32 vertexCount, uint32 instanceCount, uint32 startVertex, uint32 startInstance)
{
	dynamicDescriptorHeap.commitStagedDescriptorsForDraw(this);
	commandList->DrawInstanced(vertexCount, instanceCount, startVertex, startInstance);
}

void dx_command_list::drawIndexed(uint32 indexCount, uint32 instanceCount, uint32 startIndex, int32 baseVertex, uint32 startInstance)
{
	dynamicDescriptorHeap.commitStagedDescriptorsForDraw(this);
	commandList->DrawIndexedInstanced(indexCount, instanceCount, startIndex, baseVertex, startInstance);
}

void dx_command_list::drawIndirect(dx_command_signature commandSignature, uint32 numCommands, const dx_resource& commandBuffer, uint32 commandBufferOffset)
{
	dynamicDescriptorHeap.commitStagedDescriptorsForDraw(this);
	commandList->ExecuteIndirect(
		commandSignature.Get(),
		numCommands,
		commandBuffer.Get(),
		commandBufferOffset,
		0,
		0);
}

void dx_command_list::drawIndirect(dx_command_signature commandSignature, uint32 maxNumCommands, const dx_resource& numDrawsBuffer, const dx_resource& commandBuffer, uint32 commandBufferOffset)
{
	dynamicDescriptorHeap.commitStagedDescriptorsForDraw(this);
	commandList->ExecuteIndirect(
		commandSignature.Get(),
		maxNumCommands,
		commandBuffer.Get(),
		commandBufferOffset,
		numDrawsBuffer.Get(),
		0);
}

void dx_command_list::drawIndirect(dx_command_signature commandSignature, uint32 numCommands, const ref<dx_buffer>& commandBuffer, uint32 commandBufferOffset)
{
	drawIndirect(commandSignature, numCommands, commandBuffer->resource, commandBufferOffset);
}

void dx_command_list::drawIndirect(dx_command_signature commandSignature, uint32 maxNumCommands, const ref<dx_buffer>& numDrawsBuffer, const ref<dx_buffer>& commandBuffer, uint32 commandBufferOffset)
{
	drawIndirect(commandSignature, maxNumCommands, numDrawsBuffer->resource, commandBuffer->resource, commandBufferOffset);
}

void dx_command_list::drawFullscreenTriangle()
{
	dynamicDescriptorHeap.commitStagedDescriptorsForDraw(this);
	setPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
	draw(3, 1, 0, 0);
}

void dx_command_list::drawCubeTriangleStrip()
{
	dynamicDescriptorHeap.commitStagedDescriptorsForDraw(this);
	setPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
	draw(14, 1, 0, 0);
}

void dx_command_list::dispatch(uint32 numGroupsX, uint32 numGroupsY, uint32 numGroupsZ)
{
	dynamicDescriptorHeap.commitStagedDescriptorsForDispatch(this);
	commandList->Dispatch(numGroupsX, numGroupsY, numGroupsZ);
}

void dx_command_list::dispatchIndirect(dx_command_signature commandSignature, uint32 numCommands, const ref<dx_buffer>& commandBuffer, uint32 commandBufferOffset)
{
	dynamicDescriptorHeap.commitStagedDescriptorsForDispatch(this);
	commandList->ExecuteIndirect(
		commandSignature.Get(),
		numCommands,
		commandBuffer->resource.Get(),
		commandBufferOffset,
		0,
		0);
}

void dx_command_list::dispatchIndirect(dx_command_signature commandSignature, uint32 maxNumCommands, const ref<dx_buffer>& numDispatchesBuffer, const ref<dx_buffer>& commandBuffer, uint32 commandBufferOffset)
{
	dynamicDescriptorHeap.commitStagedDescriptorsForDispatch(this);
	commandList->ExecuteIndirect(
		commandSignature.Get(),
		maxNumCommands,
		commandBuffer->resource.Get(),
		commandBufferOffset,
		numDispatchesBuffer->resource.Get(),
		0);
}

void dx_command_list::dispatchIndirect(uint32 numCommands, const ref<dx_buffer>& commandBuffer, uint32 commandBufferOffset)
{
	dispatchIndirect(dxContext.defaultDispatchCommandSignature, numCommands, commandBuffer, commandBufferOffset);
}

void dx_command_list::dispatchIndirect(uint32 maxNumCommands, const ref<dx_buffer>& numDispatchesBuffer, const ref<dx_buffer>& commandBuffer, uint32 commandBufferOffset)
{
	dispatchIndirect(dxContext.defaultDispatchCommandSignature, maxNumCommands, numDispatchesBuffer, commandBuffer, commandBufferOffset);
}

void dx_command_list::dispatchMesh(uint32 numGroupsX, uint32 numGroupsY, uint32 numGroupsZ)
{
#ifdef SDK_SUPPORTS_MESH_SHADERS
	dynamicDescriptorHeap.commitStagedDescriptorsForDraw(this);
	commandList->DispatchMesh(numGroupsX, numGroupsY, numGroupsZ);
#else
	ASSERT(!"Mesh shaders are not supported with your Windows SDK version.");
#endif
}

void dx_command_list::raytrace(D3D12_DISPATCH_RAYS_DESC& raytraceDesc)
{
	dynamicDescriptorHeap.commitStagedDescriptorsForDispatch(this);
	commandList->DispatchRays(&raytraceDesc);
}

void dx_command_list::queryTimestamp(uint32 index)
{
	commandList->EndQuery(timeStampQueryHeap.Get(), D3D12_QUERY_TYPE_TIMESTAMP, index);
}

void dx_command_list::reset()
{
	commandAllocator->Reset();
	checkResult(commandList->Reset(commandAllocator.Get(), 0));

	for (uint32 i = 0; i < D3D12_DESCRIPTOR_HEAP_TYPE_NUM_TYPES; ++i)
	{
		descriptorHeaps[i] = 0;
	}

	dynamicDescriptorHeap.reset();
}

```

`src/dx/dx_command_list.h`:

```h
#pragma once

#include "dx.h"
#include "dx_upload_buffer.h"
#include "dx_dynamic_descriptor_heap.h"
#include "dx_descriptor_allocation.h"
#include "dx_texture.h"
#include "dx_buffer.h"
#include "dx_render_target.h"
#include "dx_pipeline.h"


struct clear_rect
{
	uint32 x, y, width, height;
};

struct dx_command_list
{
	dx_command_list(D3D12_COMMAND_LIST_TYPE type);

	D3D12_COMMAND_LIST_TYPE type;
	dx_command_allocator commandAllocator;
	dx_graphics_command_list commandList;
	uint64 lastExecutionFenceValue;
	dx_command_list* next;

	dx_dynamic_descriptor_heap dynamicDescriptorHeap;

	dx_query_heap timeStampQueryHeap;


	ID3D12DescriptorHeap* descriptorHeaps[D3D12_DESCRIPTOR_HEAP_TYPE_NUM_TYPES] = {};


	// Barriers.
	void barriers(CD3DX12_RESOURCE_BARRIER* barriers, uint32 numBarriers);

	// Avoid calling these. Instead, use the dx_barrier_batcher interface to batch multiple barriers into a single submission.
	void transitionBarrier(const ref<dx_texture>& texture, D3D12_RESOURCE_STATES from, D3D12_RESOURCE_STATES to, uint32 subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES);
	void transitionBarrier(const ref<dx_buffer>& buffer, D3D12_RESOURCE_STATES from, D3D12_RESOURCE_STATES to, uint32 subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES);
	void transitionBarrier(dx_resource resource, D3D12_RESOURCE_STATES from, D3D12_RESOURCE_STATES to, uint32 subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES);

	void uavBarrier(const ref<dx_texture>& texture);
	void uavBarrier(const ref<dx_buffer>& buffer);
	void uavBarrier(dx_resource resource);

	void aliasingBarrier(const ref<dx_texture>& before, const ref<dx_texture>& after);
	void aliasingBarrier(const ref<dx_buffer>& before, const ref<dx_buffer>& after);
	void aliasingBarrier(dx_resource before, dx_resource after);

	void assertResourceState(const ref<dx_texture>& texture, D3D12_RESOURCE_STATES state, uint32 subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES);
	void assertResourceState(const ref<dx_buffer>& buffer, D3D12_RESOURCE_STATES state, uint32 subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES);
	void assertResourceState(dx_resource resource, D3D12_RESOURCE_STATES state, uint32 subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES);


	// Copy.
	void copyResource(dx_resource from, dx_resource to);
	void copyTextureRegionToBuffer(const ref<dx_texture>& from, const ref<dx_buffer>& to, uint32 bufferElementOffset, uint32 x, uint32 y, uint32 width, uint32 height);
	void copyTextureRegionToBuffer(const dx_resource& from, uint32 fromWidth, DXGI_FORMAT format, const ref<dx_buffer>& to, uint32 bufferElementOffset, uint32 x, uint32 y, uint32 width, uint32 height);
	void copyTextureRegionToTexture(const ref<dx_texture>& from, const ref<dx_texture>& to, uint32 sourceX, uint32 sourceY, uint32 destX, uint32 destY, uint32 width, uint32 height);
	void copyBufferRegionToBuffer(const ref<dx_buffer>& from, const ref<dx_buffer>& to, uint32 fromElementOffset, uint32 numElements, uint32 toElementOffset);
	void copyBufferRegionToBuffer_ByteOffset(const ref<dx_buffer>& from, const ref<dx_buffer>& to, uint32 fromByteOffset, uint32 numBytes, uint32 toByteOffset);


	// Pipeline.
	void setPipelineState(dx_pipeline_state pipelineState);
	void setPipelineState(dx_raytracing_pipeline_state pipelineState);


	// Uniforms.
	void setGraphicsRootSignature(const dx_root_signature& rootSignature);
	void setGraphics32BitConstants(uint32 rootParameterIndex, uint32 numConstants, const void* constants);
	template<typename T> void setGraphics32BitConstants(uint32 rootParameterIndex, const T& constants);

	void setComputeRootSignature(const dx_root_signature& rootSignature);
	void setCompute32BitConstants(uint32 rootParameterIndex, uint32 numConstants, const void* constants);
	template<typename T> void setCompute32BitConstants(uint32 rootParameterIndex, const T& constants);

	void setGraphicsDynamicConstantBuffer(uint32 rootParameterIndex, dx_dynamic_constant_buffer address);
	void setComputeDynamicConstantBuffer(uint32 rootParameterIndex, dx_dynamic_constant_buffer address);

	void setRootGraphicsUAV(uint32 rootParameterIndex, const ref<dx_buffer>& buffer);
	void setRootGraphicsUAV(uint32 rootParameterIndex, D3D12_GPU_VIRTUAL_ADDRESS address);
	void setRootComputeUAV(uint32 rootParameterIndex, const ref<dx_buffer>& buffer);
	void setRootComputeUAV(uint32 rootParameterIndex, D3D12_GPU_VIRTUAL_ADDRESS address);
	
	void setRootGraphicsSRV(uint32 rootParameterIndex, const ref<dx_buffer>& buffer);
	void setRootGraphicsSRV(uint32 rootParameterIndex, D3D12_GPU_VIRTUAL_ADDRESS address);
	void setRootComputeSRV(uint32 rootParameterIndex, const ref<dx_buffer>& buffer);
	void setRootComputeSRV(uint32 rootParameterIndex, D3D12_GPU_VIRTUAL_ADDRESS address);

	void setDescriptorHeapResource(uint32 rootParameterIndex, uint32 offset, uint32 count, dx_cpu_descriptor_handle handle);
	void setDescriptorHeapSRV(uint32 rootParameterIndex, uint32 offset, dx_cpu_descriptor_handle handle) { setDescriptorHeapResource(rootParameterIndex, offset, 1, handle); }
	void setDescriptorHeapSRV(uint32 rootParameterIndex, uint32 offset, const ref<dx_texture>& texture) { setDescriptorHeapResource(rootParameterIndex, offset, 1, texture->defaultSRV); }
	void setDescriptorHeapSRV(uint32 rootParameterIndex, uint32 offset, const ref<dx_buffer>& buffer) { setDescriptorHeapResource(rootParameterIndex, offset, 1, buffer->defaultSRV); }
	void setDescriptorHeapUAV(uint32 rootParameterIndex, uint32 offset, dx_cpu_descriptor_handle handle) { setDescriptorHeapResource(rootParameterIndex, offset, 1, handle); }
	void setDescriptorHeapUAV(uint32 rootParameterIndex, uint32 offset, const ref<dx_texture>& texture) { setDescriptorHeapResource(rootParameterIndex, offset, 1, texture->defaultUAV); }
	void setDescriptorHeapUAV(uint32 rootParameterIndex, uint32 offset, const ref<dx_buffer>& buffer) { setDescriptorHeapResource(rootParameterIndex, offset, 1, buffer->defaultUAV); }


	// Shader resources.
	void setDescriptorHeap(dx_descriptor_range& descriptorRange);
	void setDescriptorHeap(D3D12_DESCRIPTOR_HEAP_TYPE type, com<ID3D12DescriptorHeap> descriptorHeap);
	void resetToDynamicDescriptorHeap();
	void setGraphicsDescriptorTable(uint32 rootParameterIndex, CD3DX12_GPU_DESCRIPTOR_HANDLE handle);
	void setComputeDescriptorTable(uint32 rootParameterIndex, CD3DX12_GPU_DESCRIPTOR_HANDLE handle);

	void clearUAV(const ref<dx_buffer>& buffer, float val = 0.f);
	void clearUAV(const ref<dx_buffer>& buffer, uint32 val = 0);
	void clearUAV(dx_resource resource, dx_cpu_descriptor_handle cpuHandle, dx_gpu_descriptor_handle gpuHandle, float val = 0.f);
	void clearUAV(dx_resource resource, dx_cpu_descriptor_handle cpuHandle, dx_gpu_descriptor_handle gpuHandle, uint32 val = 0);


	// Input assembly.
	void setPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY topology);
	void setVertexBuffer(uint32 slot, const ref<dx_vertex_buffer>& buffer);
	void setVertexBuffer(uint32 slot, const dx_dynamic_vertex_buffer& buffer);
	void setVertexBuffer(uint32 slot, const D3D12_VERTEX_BUFFER_VIEW& buffer);
	void setIndexBuffer(const ref<dx_index_buffer>& buffer);
	void setIndexBuffer(const dx_dynamic_index_buffer& buffer);
	void setIndexBuffer(const D3D12_INDEX_BUFFER_VIEW& buffer);


	// Rasterizer.
	void setViewport(const D3D12_VIEWPORT& viewport);
	void setViewport(float x, float y, float width, float height, float minDepth = 0.f, float maxDepth = 1.f);
	void setScissor(const D3D12_RECT& scissor);


	// Render targets.
	void setRenderTarget(const dx_rtv_descriptor_handle* rtvs, uint32 numRTVs, const dx_dsv_descriptor_handle* dsv);
	void setRenderTarget(const dx_render_target& renderTarget);

	void clearRTV(dx_rtv_descriptor_handle rtv, float r, float g, float b, float a = 1.f, const clear_rect* rects = 0, uint32 numRects = 0);
	void clearRTV(dx_rtv_descriptor_handle rtv, const float* clearColor, const clear_rect* rects = 0, uint32 numRects = 0);
	void clearRTV(const ref<dx_texture>& texture, float r, float g, float b, float a = 1.f, const clear_rect* rects = 0, uint32 numRects = 0);
	void clearRTV(const ref<dx_texture>& texture, const float* clearColor, const clear_rect* rects = 0, uint32 numRects = 0);
	void clearRTV(const dx_render_target& renderTarget, uint32 attachment, const float* clearColor, const clear_rect* rects = 0, uint32 numRects = 0);
	void clearRTV(const dx_render_target& renderTarget, uint32 attachment, float r, float g, float b, float a = 1.f, const clear_rect* rects = 0, uint32 numRects = 0);

	void clearDepth(dx_dsv_descriptor_handle dsv, float depth = 1.f, const clear_rect* rects = 0, uint32 numRects = 0);
	void clearDepth(const ref<dx_texture>& texture, float depth = 1.f, const clear_rect* rects = 0, uint32 numRects = 0);
	void clearDepth(const dx_render_target& renderTarget, float depth = 1.f, const clear_rect* rects = 0, uint32 numRects = 0);

	void clearStencil(dx_dsv_descriptor_handle dsv, uint32 stencil = 0, const clear_rect* rects = 0, uint32 numRects = 0);
	void clearStencil(const ref<dx_texture>& texture, uint32 stencil = 0, const clear_rect* rects = 0, uint32 numRects = 0);
	void clearStencil(const dx_render_target& renderTarget, uint32 stencil = 0, const clear_rect* rects = 0, uint32 numRects = 0);

	void clearDepthAndStencil(dx_dsv_descriptor_handle dsv, float depth = 1.f, uint32 stencil = 0, const clear_rect* rects = 0, uint32 numRects = 0);
	void clearDepthAndStencil(const ref<dx_texture>& texture, float depth = 1.f, uint32 stencil = 0, const clear_rect* rects = 0, uint32 numRects = 0);
	void clearDepthAndStencil(const dx_render_target& renderTarget, float depth = 1.f, uint32 stencil = 0, const clear_rect* rects = 0, uint32 numRects = 0);

	void setStencilReference(uint32 stencilReference);
	void setBlendFactor(float blendR, float blendG, float blendB, float blendA);


	// Draw.
	void draw(uint32 vertexCount, uint32 instanceCount, uint32 startVertex, uint32 startInstance);
	void drawIndexed(uint32 indexCount, uint32 instanceCount, uint32 startIndex, int32 baseVertex, uint32 startInstance);
	void drawIndirect(dx_command_signature commandSignature, uint32 numCommands, const dx_resource& commandBuffer, uint32 commandBufferOffset = 0);
	void drawIndirect(dx_command_signature commandSignature, uint32 maxNumCommands, const dx_resource& numDrawsBuffer, const dx_resource& commandBuffer, uint32 commandBufferOffset = 0);
	void drawIndirect(dx_command_signature commandSignature, uint32 numCommands, const ref<dx_buffer>& commandBuffer, uint32 commandBufferOffset = 0);
	void drawIndirect(dx_command_signature commandSignature, uint32 maxNumCommands, const ref<dx_buffer>& numDrawsBuffer, const ref<dx_buffer>& commandBuffer, uint32 commandBufferOffset = 0);
	void drawFullscreenTriangle();
	void drawCubeTriangleStrip();


	// Dispatch.
	void dispatch(uint32 numGroupsX, uint32 numGroupsY = 1, uint32 numGroupsZ = 1);
	void dispatchIndirect(dx_command_signature commandSignature, uint32 numCommands, const ref<dx_buffer>& commandBuffer, uint32 commandBufferOffset = 0);
	void dispatchIndirect(dx_command_signature commandSignature, uint32 maxNumCommands, const ref<dx_buffer>& numDispatchesBuffer, const ref<dx_buffer>& commandBuffer, uint32 commandBufferOffset = 0);
	void dispatchIndirect(uint32 numCommands, const ref<dx_buffer>& commandBuffer, uint32 commandBufferOffset = 0);
	void dispatchIndirect(uint32 maxNumCommands, const ref<dx_buffer>& numDispatchesBuffer, const ref<dx_buffer>& commandBuffer, uint32 commandBufferOffset = 0);


	// Mesh shaders.
	void dispatchMesh(uint32 numGroupsX, uint32 numGroupsY = 1, uint32 numGroupsZ = 1);


	// Raytracing.
	void raytrace(D3D12_DISPATCH_RAYS_DESC& raytraceDesc);


	// Queries.
	void queryTimestamp(uint32 index);

	void reset();
};

template<typename T>
void dx_command_list::setGraphics32BitConstants(uint32 rootParameterIndex, const T& constants)
{
	static_assert(sizeof(T) % 4 == 0, "Size of type must be a multiple of 4 bytes.");
	setGraphics32BitConstants(rootParameterIndex, sizeof(T) / 4, &constants);
}

template<typename T>
void dx_command_list::setCompute32BitConstants(uint32 rootParameterIndex, const T& constants)
{
	static_assert(sizeof(T) % 4 == 0, "Size of type must be a multiple of 4 bytes.");
	setCompute32BitConstants(rootParameterIndex, sizeof(T) / 4, &constants);
}

```

`src/dx/dx_command_queue.cpp`:

```cpp
#include "pch.h"
#include "dx_command_queue.h"
#include "dx_command_list.h"
#include "dx_context.h"
#include "core/threading.h"

static DWORD processRunningCommandLists(void* data);

void dx_command_queue::initialize(dx_device device, D3D12_COMMAND_LIST_TYPE type)
{
	fenceValue = 0;
	commandListType = type;

	D3D12_COMMAND_QUEUE_DESC desc = {};
	desc.Type = type;
	desc.Priority = D3D12_COMMAND_QUEUE_PRIORITY_NORMAL;
	desc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;
	desc.NodeMask = 0;

	checkResult(device->CreateCommandQueue(&desc, IID_PPV_ARGS(&commandQueue)));
	checkResult(device->CreateFence(fenceValue, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&fence)));

	timeStampFrequency = 0; // Default value, if timing is not supported on this queue.
	timeStampToCPU = 0;
	if (SUCCEEDED(commandQueue->GetTimestampFrequency(&timeStampFrequency)))
	{
		uint64 gpuTimestamp, cpuTimestamp;
		if (SUCCEEDED(commandQueue->GetClockCalibration(&gpuTimestamp, &cpuTimestamp)))
		{
			if (gpuTimestamp > cpuTimestamp)
			{
				timeStampToCPU = (int64)(gpuTimestamp - cpuTimestamp);
			}
			else
			{
				timeStampToCPU = -(int64)(cpuTimestamp - gpuTimestamp);
			}
		}
	}

	processThreadHandle = CreateThread(0, 0, processRunningCommandLists, this, 0, 0);

	switch (type)
	{
		case D3D12_COMMAND_LIST_TYPE_DIRECT: SET_NAME(commandQueue, "Render command queue"); break;
		case D3D12_COMMAND_LIST_TYPE_COMPUTE: SET_NAME(commandQueue, "Compute command queue"); break;
		case D3D12_COMMAND_LIST_TYPE_COPY: SET_NAME(commandQueue, "Copy command queue"); break;
	}
}

uint64 dx_command_queue::signal()
{
	uint64 fenceValueForSignal = atomicIncrement(fenceValue) + 1;
	checkResult(commandQueue->Signal(fence.Get(), fenceValueForSignal));

	return fenceValueForSignal;
}

bool dx_command_queue::isFenceComplete(uint64 fenceValue)
{
	return fence->GetCompletedValue() >= fenceValue;
}

void dx_command_queue::waitForFence(uint64 fenceValue)
{
	if (!isFenceComplete(fenceValue))
	{
		HANDLE fenceEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		ASSERT(fenceEvent);

		fence->SetEventOnCompletion(fenceValue, fenceEvent);
		WaitForSingleObject(fenceEvent, DWORD_MAX);

		CloseHandle(fenceEvent);
	}
}

void dx_command_queue::waitForOtherQueue(dx_command_queue& other)
{
	commandQueue->Wait(other.fence.Get(), other.signal());
}

void dx_command_queue::waitForOtherQueue(dx_command_queue& other, uint64 fenceValue)
{
	commandQueue->Wait(other.fence.Get(), fenceValue);
}

void dx_command_queue::flush()
{
	while (numRunningCommandLists) {}

	waitForFence(signal());
}

static DWORD processRunningCommandLists(void* data)
{
	dx_command_queue& queue = *(dx_command_queue*)data;

	while (dxContext.running)
	{
		while (true)
		{
			queue.commandListMutex.lock();
			dx_command_list* list = queue.runningCommandLists;
			if (list)
			{
				queue.runningCommandLists = list->next;
				if (list == queue.newestRunningCommandList)
				{
					ASSERT(list->next == 0);
					queue.newestRunningCommandList = 0;
				}
			}
			queue.commandListMutex.unlock();

			if (list)
			{
				queue.waitForFence(list->lastExecutionFenceValue);
				list->reset();

				queue.commandListMutex.lock();

				list->next = queue.freeCommandLists;
				queue.freeCommandLists = list;

				atomicDecrement(queue.numRunningCommandLists);

				queue.commandListMutex.unlock();
			}
			else
			{
				break;
			}
		}

		SwitchToThread(); // Yield.
	}

	return 0;
}


```

`src/dx/dx_command_queue.h`:

```h
#pragma once

#include "dx.h"

struct dx_command_list;

struct dx_command_queue
{
	void initialize(dx_device device, D3D12_COMMAND_LIST_TYPE type);

	uint64 signal();
	bool isFenceComplete(uint64 fenceValue);
	void waitForFence(uint64 fenceValue);
	void waitForOtherQueue(dx_command_queue& other);
	void waitForOtherQueue(dx_command_queue& other, uint64 fenceValue);
	void flush();


	uint64 timeStampFrequency; // In Hz.
	int64 timeStampToCPU; // GPU queue - CPU.

	D3D12_COMMAND_LIST_TYPE commandListType;
	com<ID3D12CommandQueue>	commandQueue;
	com<ID3D12Fence> fence;
	volatile uint64 fenceValue;

	dx_command_list* runningCommandLists;
	dx_command_list* newestRunningCommandList;
	dx_command_list* freeCommandLists;

	volatile uint32 numRunningCommandLists;
	volatile uint32 totalNumCommandLists; // Used only for validation.

	HANDLE processThreadHandle;

	std::mutex commandListMutex;
};

```

`src/dx/dx_context.cpp`:

```cpp
#include "pch.h"
#include "dx_context.h"
#include "dx_command_list.h"
#include "dx_texture.h"
#include "dx_buffer.h"
#include "dx_profiling.h"
#include "core/string.h"

#include <d3d12memoryallocator/D3D12MemAlloc.cpp>

extern "C"
{
	__declspec(dllexport) unsigned long NvOptimusEnablement = 0x00000001;
	__declspec(dllexport) int AmdPowerXpressRequestHighPerformance = 1;
}

// Allocate dynamically on the heap to ensure that this thing never gets destroyed before anything else. This is quite a hack.
dx_context& dxContext = *new dx_context{};


LONG NTAPI handleVectoredException(PEXCEPTION_POINTERS exceptionInfo)
{
	PEXCEPTION_RECORD exceptionRecord = exceptionInfo->ExceptionRecord;

	switch (exceptionRecord->ExceptionCode)
	{
		case DBG_PRINTEXCEPTION_WIDE_C:
		case DBG_PRINTEXCEPTION_C:

			if (exceptionRecord->NumberParameters >= 2)
			{
				ULONG len = (ULONG)exceptionRecord->ExceptionInformation[0];

				union
				{
					ULONG_PTR up;
					PCWSTR pwz;
					PCSTR psz;
				};

				up = exceptionRecord->ExceptionInformation[1];

				HANDLE hOut = GetStdHandle(STD_ERROR_HANDLE);

				if (exceptionRecord->ExceptionCode == DBG_PRINTEXCEPTION_C)
				{
					// Localized text will be incorrect displayed, if used not CP_OEMCP encoding.
					// WriteConsoleA(hOut, psz, len, &len, 0);

					// assume CP_ACP encoding
					if (ULONG n = MultiByteToWideChar(CP_ACP, 0, psz, len, 0, 0))
					{
						PWSTR wz = (PWSTR)alloca(n * sizeof(WCHAR));

						if (len = MultiByteToWideChar(CP_ACP, 0, psz, len, wz, n))
						{
							pwz = wz;
						}
					}
				}

				if (len)
				{
					WriteConsoleW(hOut, pwz, len - 1, &len, 0);
				}

			}
			return EXCEPTION_CONTINUE_EXECUTION;
	}

	return EXCEPTION_CONTINUE_SEARCH;
}

static void enableDebugLayer()
{
#if defined(_DEBUG)
	com<ID3D12Debug3> debugInterface;
	checkResult(D3D12GetDebugInterface(IID_PPV_ARGS(&debugInterface)));
	debugInterface->EnableDebugLayer();
	//debugInterface->SetEnableAutoDebugName(true);
	//debugInterface->SetEnableGPUBasedValidation(true);
#endif
}

static dx_factory createFactory()
{
	dx_factory dxgiFactory;
	uint32 createFactoryFlags = 0;
#if defined(_DEBUG)
	createFactoryFlags = DXGI_CREATE_FACTORY_DEBUG;
#endif

	checkResult(CreateDXGIFactory2(createFactoryFlags, IID_PPV_ARGS(&dxgiFactory)));

	return dxgiFactory;
}

struct adapter_desc
{
	dx_adapter adapter;
	D3D_FEATURE_LEVEL featureLevel;
};

static adapter_desc getAdapter(dx_factory factory, D3D_FEATURE_LEVEL minimumFeatureLevel = D3D_FEATURE_LEVEL_11_0)
{
	com<IDXGIAdapter1> dxgiAdapter1;
	dx_adapter dxgiAdapter;
	DXGI_ADAPTER_DESC1 desc;

	D3D_FEATURE_LEVEL featureLevel = D3D_FEATURE_LEVEL_9_1;

	D3D_FEATURE_LEVEL possibleFeatureLevels[] = 
	{
		D3D_FEATURE_LEVEL_9_1,
		D3D_FEATURE_LEVEL_9_2,
		D3D_FEATURE_LEVEL_9_3,
		D3D_FEATURE_LEVEL_10_0,
		D3D_FEATURE_LEVEL_10_1,
		D3D_FEATURE_LEVEL_11_0,
		D3D_FEATURE_LEVEL_11_1,
		D3D_FEATURE_LEVEL_12_0,
		D3D_FEATURE_LEVEL_12_1
	};

	uint32 firstFeatureLevel = 0;
	for (uint32 i = 0; i < arraysize(possibleFeatureLevels); ++i)
	{
		if (possibleFeatureLevels[i] == minimumFeatureLevel)
		{
			firstFeatureLevel = i;
			break;
		}
	}

	uint64 maxDedicatedVideoMemory = 0;
	for (uint32 i = 0; factory->EnumAdapters1(i, &dxgiAdapter1) != DXGI_ERROR_NOT_FOUND; ++i)
	{
		DXGI_ADAPTER_DESC1 dxgiAdapterDesc1;
		dxgiAdapter1->GetDesc1(&dxgiAdapterDesc1);

		// Check to see if the adapter can create a D3D12 device without actually 
		// creating it. Out of all adapters which support the minimum feature level,
		// the adapter with the largest dedicated video memory is favored.
		if ((dxgiAdapterDesc1.Flags & DXGI_ADAPTER_FLAG_SOFTWARE) == 0)
		{
			D3D_FEATURE_LEVEL adapterFeatureLevel = D3D_FEATURE_LEVEL_9_1;
			bool supportsFeatureLevel = false;

			for (uint32 fl = firstFeatureLevel; fl < arraysize(possibleFeatureLevels); ++fl)
			{
				if (SUCCEEDED(D3D12CreateDevice(dxgiAdapter1.Get(),
					possibleFeatureLevels[fl], __uuidof(ID3D12Device), 0)))
				{
					adapterFeatureLevel = possibleFeatureLevels[fl];
					supportsFeatureLevel = true;
				}
			}

			if (supportsFeatureLevel && dxgiAdapterDesc1.DedicatedVideoMemory > maxDedicatedVideoMemory)
			{
				checkResult(dxgiAdapter1.As(&dxgiAdapter));
				maxDedicatedVideoMemory = dxgiAdapterDesc1.DedicatedVideoMemory;
				featureLevel = adapterFeatureLevel;
				desc = dxgiAdapterDesc1;
			}
		}
	}

	return { dxgiAdapter, featureLevel };
}

static dx_device createDevice(dx_adapter adapter, D3D_FEATURE_LEVEL featureLevel)
{
	dx_device device;
	checkResult(D3D12CreateDevice(adapter.Get(), featureLevel, IID_PPV_ARGS(&device)));

#if defined(_DEBUG)
	com<ID3D12InfoQueue> infoQueue;
	if (SUCCEEDED(device.As(&infoQueue)))
	{
		infoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_CORRUPTION, TRUE);
		infoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_ERROR, TRUE);
		infoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_WARNING, TRUE);

		// Suppress whole categories of messages.
		//D3D12_MESSAGE_CATEGORY categories[] = {};

		// Suppress messages based on their severity level.
		D3D12_MESSAGE_SEVERITY severities[] =
		{
			D3D12_MESSAGE_SEVERITY_INFO
		};

		// Suppress individual messages by their ID.
		D3D12_MESSAGE_ID ids[] = {
			D3D12_MESSAGE_ID_CLEARRENDERTARGETVIEW_MISMATCHINGCLEARVALUE,   // I'm really not sure how to avoid this message.
			D3D12_MESSAGE_ID_MAP_INVALID_NULLRANGE,                         // This warning occurs when using capture frame while graphics debugging.
			D3D12_MESSAGE_ID_UNMAP_INVALID_NULLRANGE,                       // This warning occurs when using capture frame while graphics debugging.
			D3D12_MESSAGE_ID_OBJECT_ACCESSED_WHILE_STILL_IN_USE,			// Disabled to allow OBS to capture the window.
		};

		D3D12_INFO_QUEUE_FILTER filter = {};
		//filter.DenyList.NumCategories = arraysize(categories);
		//filter.DenyList.pCategoryList = categories;
		filter.DenyList.NumSeverities = arraysize(severities);
		filter.DenyList.pSeverityList = severities;
		filter.DenyList.NumIDs = arraysize(ids);
		filter.DenyList.pIDList = ids;

		checkResult(infoQueue->PushStorageFilter(&filter));
	}
#endif

	return device;
}

static dx_feature_support checkFeatureSupport(dx_device device)
{
	dx_feature_support result = {};

	D3D12_FEATURE_DATA_D3D12_OPTIONS5 options5 = {};
	if (SUCCEEDED(device->CheckFeatureSupport(D3D12_FEATURE_D3D12_OPTIONS5, &options5, sizeof(options5))))
	{
		result.raytracingTier = (dx_raytracing_tier)options5.RaytracingTier;
	}

#ifdef SDK_SUPPORTS_MESH_SHADERS
	D3D12_FEATURE_DATA_D3D12_OPTIONS7 options7 = {};
	if (SUCCEEDED(device->CheckFeatureSupport(D3D12_FEATURE_D3D12_OPTIONS7, &options7, sizeof(options7))))
	{
		result.meshShaderTier = (dx_mesh_shader_tier)options7.MeshShaderTier;
	}
	else
	{
		std::cerr << "Checking support for mesh shader feature failed. Maybe you need to update your Windows version.\n";
	}
#endif

	D3D12_FEATURE_DATA_D3D12_OPTIONS options1 = {};
	if (SUCCEEDED(device->CheckFeatureSupport(D3D12_FEATURE_D3D12_OPTIONS, &options1, sizeof(options1))))
	{
		result.tilingTier = (dx_tiling_tier)options1.TiledResourcesTier;
	}

	return result;
}

bool dx_context::initialize()
{
	SetThreadDpiAwarenessContext(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2);
	AddVectoredExceptionHandler(TRUE, handleVectoredException);

	checkResult(CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE));


	enableDebugLayer();

	factory = createFactory();
	adapter_desc adapterDesc = getAdapter(factory);
	this->adapter = adapterDesc.adapter;
	if (!adapter)
	{
		std::cerr << "No DX12 capable GPU found.\n";
		return false;
	}

	device = createDevice(adapter, adapterDesc.featureLevel);

#if USE_D3D12_BLOCK_ALLOCATOR
	D3D12MA::ALLOCATOR_DESC allocatorDesc = {};
	allocatorDesc.pDevice = device.Get();
	allocatorDesc.pAdapter = adapter.Get();
	checkResult(D3D12MA::CreateAllocator(&allocatorDesc, &memoryAllocator));
#endif

	featureSupport = checkFeatureSupport(device);

	bufferedFrameID = NUM_BUFFERED_FRAMES - 1;

	descriptorHandleIncrementSize = device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);


	srvUavAllocator.initialize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV, false, 4096);
	srvUavAllocatorShaderVisible.initialize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV, true, 128);
	rtvAllocator.initialize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV, false, 1024);
	dsvAllocator.initialize(D3D12_DESCRIPTOR_HEAP_TYPE_DSV, false, 1024);
	frameDescriptorAllocator.initialize();

	for (uint32 i = 0; i < NUM_BUFFERED_FRAMES; ++i)
	{
		pagePools[i].initialize(MB(32));

#if ENABLE_DX_PROFILING
		timestampHeaps[i].initialize(MAX_NUM_DX_PROFILE_EVENTS);
		resolvedTimestampBuffers[i] = createReadbackBuffer(sizeof(uint64), MAX_NUM_DX_PROFILE_EVENTS);
#endif
	}

	frameUploadBuffer.reset();
	frameUploadBuffer.pagePool = &pagePools[bufferedFrameID];

	pagePools[bufferedFrameID].reset();


	renderQueue.initialize(device, D3D12_COMMAND_LIST_TYPE_DIRECT);
	computeQueue.initialize(device, D3D12_COMMAND_LIST_TYPE_COMPUTE);
	copyQueue.initialize(device, D3D12_COMMAND_LIST_TYPE_COPY);


	D3D12_INDIRECT_ARGUMENT_DESC argumentDesc;
	argumentDesc.Type = D3D12_INDIRECT_ARGUMENT_TYPE_DISPATCH;
	defaultDispatchCommandSignature = createCommandSignature({}, &argumentDesc, 1, sizeof(D3D12_DISPATCH_ARGUMENTS));

	return true;
}

void dx_context::flushApplication()
{
	renderQueue.flush();
	computeQueue.flush();
	copyQueue.flush();
}

void dx_context::quit()
{
#if ENABLE_DX_PROFILING
	for (uint32 b = 0; b < NUM_BUFFERED_FRAMES; ++b)
	{
		resolvedTimestampBuffers[b].reset();
	}
#endif

	running = false;
	flushApplication();
	WaitForSingleObject(renderQueue.processThreadHandle, INFINITE);
	WaitForSingleObject(computeQueue.processThreadHandle, INFINITE);
	WaitForSingleObject(copyQueue.processThreadHandle, INFINITE);

	for (uint32 b = 0; b < NUM_BUFFERED_FRAMES; ++b)
	{
		textureGraveyard[b].clear();
		bufferGraveyard[b].clear();
		objectGraveyard[b].clear();

		for (auto allocation : allocationGraveyard[b])
		{
			allocation->Release();
		}
		allocationGraveyard[b].clear();
	}
}

void dx_context::retire(texture_grave&& texture)
{
	mutex.lock();
	textureGraveyard[bufferedFrameID].push_back(std::move(texture));
	mutex.unlock();
}

void dx_context::retire(buffer_grave&& buffer)
{
	mutex.lock();
	bufferGraveyard[bufferedFrameID].push_back(std::move(buffer));
	mutex.unlock();
}

void dx_context::retire(dx_object obj)
{
	mutex.lock();
	objectGraveyard[bufferedFrameID].push_back(obj);
	mutex.unlock();
}

void dx_context::retire(D3D12MA::Allocation* allocation)
{
	mutex.lock();
	allocationGraveyard[bufferedFrameID].push_back(allocation);
	mutex.unlock();
}

dx_command_queue& dx_context::getQueue(D3D12_COMMAND_LIST_TYPE type)
{
	return type == D3D12_COMMAND_LIST_TYPE_DIRECT ? renderQueue :
		type == D3D12_COMMAND_LIST_TYPE_COMPUTE ? computeQueue :
		copyQueue;
}

dx_command_list* dx_context::getFreeCommandList(dx_command_queue& queue)
{
	queue.commandListMutex.lock();
	dx_command_list* result = queue.freeCommandLists;
	if (result)
	{
		queue.freeCommandLists = result->next;
	}
	queue.commandListMutex.unlock();

	if (!result)
	{
		result = new dx_command_list(queue.commandListType);
		atomicIncrement(queue.totalNumCommandLists);
	}

#if ENABLE_DX_PROFILING
	result->timeStampQueryHeap = timestampHeaps[bufferedFrameID].heap;
#endif

	return result;
}

dx_command_list* dx_context::getFreeCopyCommandList()
{
	return getFreeCommandList(copyQueue);
}

dx_command_list* dx_context::getFreeComputeCommandList(bool async)
{
	return getFreeCommandList(async ? computeQueue : renderQueue);
}

dx_command_list* dx_context::getFreeRenderCommandList()
{
	dx_command_list* cl = getFreeCommandList(renderQueue);
	CD3DX12_RECT scissorRect(0, 0, LONG_MAX, LONG_MAX);
	cl->setScissor(scissorRect);
	return cl;
}

static void enqueueRunningCommandList(dx_command_queue& queue, dx_command_list* commandList)
{
	commandList->next = 0;
	if (queue.newestRunningCommandList)
	{
		ASSERT(queue.newestRunningCommandList->next == 0);
		queue.newestRunningCommandList->next = commandList;
	}
	queue.newestRunningCommandList = commandList;
	if (!queue.runningCommandLists)
	{
		queue.runningCommandLists = commandList;
	}
}

uint64 dx_context::executeCommandList(dx_command_list* commandList)
{
	dx_command_queue& queue = getQueue(commandList->type);

	checkResult(commandList->commandList->Close());

	ID3D12CommandList* d3d12List = commandList->commandList.Get();
	queue.commandQueue->ExecuteCommandLists(1, &d3d12List);

	uint64 fenceValue = queue.signal();

	commandList->lastExecutionFenceValue = fenceValue;

	queue.commandListMutex.lock();
	enqueueRunningCommandList(queue, commandList);
	atomicIncrement(queue.numRunningCommandLists);
	queue.commandListMutex.unlock();

	return fenceValue;
}

uint64 dx_context::executeCommandLists(dx_command_list** commandLists, uint32 count)
{
	dx_command_queue& queue = getQueue(commandLists[0]->type);

	ID3D12CommandList* d3d12Lists[16];

	for (uint32 i = 0; i < count; ++i)
	{
		checkResult(commandLists[i]->commandList->Close());
		d3d12Lists[i] = commandLists[i]->commandList.Get();
	}

	queue.commandQueue->ExecuteCommandLists(count, d3d12Lists);

	uint64 fenceValue = queue.signal();

	for (uint32 i = 0; i < count; ++i)
	{
		commandLists[i]->lastExecutionFenceValue = fenceValue;
	}

	queue.commandListMutex.lock();
	for (uint32 i = 0; i < count; ++i)
	{
		enqueueRunningCommandList(queue, commandLists[i]);
	}
	atomicAdd(queue.numRunningCommandLists, count);

	queue.commandListMutex.unlock();

	return fenceValue;
}

dx_allocation dx_context::allocateDynamicBuffer(uint32 sizeInBytes, uint32 alignment)
{
	dx_allocation allocation = frameUploadBuffer.allocate(sizeInBytes, alignment);
	return allocation;
}

std::pair<dx_dynamic_constant_buffer, void*> dx_context::uploadDynamicConstantBuffer(uint32 sizeInBytes, const void* data)
{
	dx_allocation allocation = allocateDynamicBuffer(sizeInBytes, D3D12_CONSTANT_BUFFER_DATA_PLACEMENT_ALIGNMENT);
	memcpy(allocation.cpuPtr, data, sizeInBytes);
	return { { allocation.gpuPtr }, allocation.cpuPtr };
}

std::pair<dx_dynamic_vertex_buffer, void*> dx_context::createDynamicVertexBuffer(uint32 elementSize, uint32 elementCount)
{
	uint32 sizeInBytes = elementSize * elementCount;
	dx_allocation allocation = allocateDynamicBuffer(sizeInBytes, elementSize);

	D3D12_VERTEX_BUFFER_VIEW vertexBufferView = {};
	vertexBufferView.BufferLocation = allocation.gpuPtr;
	vertexBufferView.SizeInBytes = sizeInBytes;
	vertexBufferView.StrideInBytes = elementSize;

	return { { vertexBufferView }, allocation.cpuPtr };
}

std::pair<dx_dynamic_index_buffer, void*> dx_context::createDynamicIndexBuffer(uint32 elementSize, uint32 elementCount)
{
	uint32 sizeInBytes = elementSize * elementCount;
	dx_allocation allocation = allocateDynamicBuffer(sizeInBytes, elementSize);

	D3D12_INDEX_BUFFER_VIEW indexBufferView = {};
	indexBufferView.BufferLocation = allocation.gpuPtr;
	indexBufferView.SizeInBytes = sizeInBytes;
	indexBufferView.Format = getIndexBufferFormat(elementSize);

	return { { indexBufferView }, allocation.cpuPtr };
}

dx_memory_usage dx_context::getMemoryUsage()
{
	DXGI_QUERY_VIDEO_MEMORY_INFO memoryInfo;
	checkResult(adapter->QueryVideoMemoryInfo(0, DXGI_MEMORY_SEGMENT_GROUP_LOCAL, &memoryInfo));
	
	return { (uint32)BYTE_TO_MB(memoryInfo.CurrentUsage), (uint32)BYTE_TO_MB(memoryInfo.Budget) };
}

void dx_context::endFrame(dx_command_list* cl)
{
#if ENABLE_DX_PROFILING
	dxProfilingFrameEndMarker(cl);
	cl->commandList->ResolveQueryData(timestampHeaps[bufferedFrameID].heap.Get(), D3D12_QUERY_TYPE_TIMESTAMP, 0, timestampQueryIndex[bufferedFrameID], resolvedTimestampBuffers[bufferedFrameID]->resource.Get(), 0);
#endif
}

void dx_context::newFrame(uint64 frameID)
{
	this->frameID = frameID;

	mutex.lock();
	bufferedFrameID = (uint32)(frameID % NUM_BUFFERED_FRAMES);

#if ENABLE_DX_PROFILING
	uint64* timestamps = (uint64*)mapBuffer(resolvedTimestampBuffers[bufferedFrameID], true);
	dxProfilingResolveTimeStamps(timestamps);
	unmapBuffer(resolvedTimestampBuffers[bufferedFrameID], false);

	timestampQueryIndex[bufferedFrameID] = 0;
#endif


	textureGraveyard[bufferedFrameID].clear();
	bufferGraveyard[bufferedFrameID].clear();
	objectGraveyard[bufferedFrameID].clear();
	for (auto allocation : allocationGraveyard[bufferedFrameID])
	{
		allocation->Release();
	}
	allocationGraveyard[bufferedFrameID].clear();


	frameUploadBuffer.reset();
	frameUploadBuffer.pagePool = &pagePools[bufferedFrameID];

	pagePools[bufferedFrameID].reset();
	frameDescriptorAllocator.newFrame(bufferedFrameID);

	mutex.unlock();
}



```

`src/dx/dx_context.h`:

```h
#pragma once

#include "dx.h"
#include "dx_command_queue.h"
#include "dx_upload_buffer.h"
#include "dx_descriptor_allocation.h"
#include "dx_buffer.h"
#include "dx_query.h"
#include "core/threading.h"


struct dx_memory_usage
{
	// In MB.
	uint32 currentlyUsed;
	uint32 available;
};

enum dx_raytracing_tier
{
	dx_raytracing_not_available,
	dx_raytracing_1_0,
	dx_raytracing_1_1,
};

enum dx_mesh_shader_tier
{
	dx_mesh_shader_not_available,
	dx_mesh_shader_1_0,
};

enum dx_tiling_tier
{
	dx_tiling_not_available,
	dx_tiling_1,
	dx_tiling_2,
	dx_tiling_3,
	dx_tiling_4,
};

struct dx_feature_support
{
	dx_raytracing_tier raytracingTier = dx_raytracing_not_available;
	dx_mesh_shader_tier meshShaderTier = dx_mesh_shader_not_available;
	dx_tiling_tier tilingTier = dx_tiling_not_available;

	bool raytracing() { return raytracingTier >= dx_raytracing_1_0; }
	bool meshShaders() { return meshShaderTier >= dx_mesh_shader_1_0; }
	bool tiling() { return tilingTier >= dx_tiling_1; }
};

struct dx_context
{
	bool initialize();
	void quit();

	void newFrame(uint64 frameID);
	void endFrame(dx_command_list* cl);
	void flushApplication();

	dx_command_list* getFreeCopyCommandList();
	dx_command_list* getFreeComputeCommandList(bool async);
	dx_command_list* getFreeRenderCommandList();
	uint64 executeCommandList(dx_command_list* commandList);
	uint64 executeCommandLists(dx_command_list** commandLists, uint32 count);

	// Careful with these functions. They are not thread safe.
	dx_allocation allocateDynamicBuffer(uint32 sizeInBytes, uint32 alignment = D3D12_CONSTANT_BUFFER_DATA_PLACEMENT_ALIGNMENT);
	
	std::pair<dx_dynamic_constant_buffer, void*> uploadDynamicConstantBuffer(uint32 sizeInBytes, const void* data);
	template <typename T> dx_dynamic_constant_buffer uploadDynamicConstantBuffer(const T& data)
	{
		return uploadDynamicConstantBuffer(sizeof(T), &data).first;
	}

	std::pair<dx_dynamic_vertex_buffer, void*> createDynamicVertexBuffer(uint32 elementSize, uint32 elementCount);
	std::pair<dx_dynamic_index_buffer, void*> createDynamicIndexBuffer(uint32 elementSize, uint32 elementCount);

	dx_memory_usage getMemoryUsage();


	dx_factory factory;
	dx_adapter adapter;
	dx_device device;

	dx_command_queue renderQueue;
	dx_command_queue computeQueue;
	dx_command_queue copyQueue;

	dx_feature_support featureSupport;

	uint64 frameID;
	uint32 bufferedFrameID;

	dx_descriptor_heap srvUavAllocator;
	dx_descriptor_heap srvUavAllocatorShaderVisible; // Used for resources, which can be UAV cleared.

	dx_descriptor_heap rtvAllocator;
	dx_descriptor_heap dsvAllocator;

#if ENABLE_DX_PROFILING
	volatile uint32 timestampQueryIndex[NUM_BUFFERED_FRAMES];
#endif

	dx_upload_buffer frameUploadBuffer;

	dx_frame_descriptor_allocator frameDescriptorAllocator;

	volatile bool running = true;

	uint32 descriptorHandleIncrementSize;

	D3D12MA::Allocator* memoryAllocator;


	void retire(struct texture_grave&& texture);
	void retire(struct buffer_grave&& buffer);
	void retire(dx_object obj);
	void retire(D3D12MA::Allocation* allocation);

	dx_command_signature defaultDispatchCommandSignature;

private:
#if ENABLE_DX_PROFILING
	dx_timestamp_query_heap timestampHeaps[NUM_BUFFERED_FRAMES];
	ref<dx_buffer> resolvedTimestampBuffers[NUM_BUFFERED_FRAMES];
#endif

	dx_page_pool pagePools[NUM_BUFFERED_FRAMES];

	std::mutex mutex;

	std::vector<struct texture_grave> textureGraveyard[NUM_BUFFERED_FRAMES];
	std::vector<struct buffer_grave> bufferGraveyard[NUM_BUFFERED_FRAMES];
	std::vector<dx_object> objectGraveyard[NUM_BUFFERED_FRAMES];
	std::vector<D3D12MA::Allocation*> allocationGraveyard[NUM_BUFFERED_FRAMES];

	dx_command_queue& getQueue(D3D12_COMMAND_LIST_TYPE type);
	dx_command_list* getFreeCommandList(dx_command_queue& queue);
};

extern dx_context& dxContext;

```

`src/dx/dx_descriptor.cpp`:

```cpp
#include "pch.h"
#include "dx_descriptor.h"
#include "dx_context.h"
#include "dx_texture.h"
#include "dx_buffer.h"

static uint32 getShader4ComponentMapping(DXGI_FORMAT format)
{
	switch (getNumberOfChannels(format))
	{
		case 1:
			return D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(
				D3D12_SHADER_COMPONENT_MAPPING_FROM_MEMORY_COMPONENT_0,
				D3D12_SHADER_COMPONENT_MAPPING_FROM_MEMORY_COMPONENT_0,
				D3D12_SHADER_COMPONENT_MAPPING_FROM_MEMORY_COMPONENT_0,
				D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_1);
		case 2:
			return D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(
				D3D12_SHADER_COMPONENT_MAPPING_FROM_MEMORY_COMPONENT_0,
				D3D12_SHADER_COMPONENT_MAPPING_FROM_MEMORY_COMPONENT_1,
				D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_0,
				D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_1);
		case 3:
			return D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(
				D3D12_SHADER_COMPONENT_MAPPING_FROM_MEMORY_COMPONENT_0,
				D3D12_SHADER_COMPONENT_MAPPING_FROM_MEMORY_COMPONENT_1,
				D3D12_SHADER_COMPONENT_MAPPING_FROM_MEMORY_COMPONENT_2,
				D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_1);
		case 4:
			return D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(
				D3D12_SHADER_COMPONENT_MAPPING_FROM_MEMORY_COMPONENT_0,
				D3D12_SHADER_COMPONENT_MAPPING_FROM_MEMORY_COMPONENT_1,
				D3D12_SHADER_COMPONENT_MAPPING_FROM_MEMORY_COMPONENT_2,
				D3D12_SHADER_COMPONENT_MAPPING_FROM_MEMORY_COMPONENT_3);
	}
	return D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
}

dx_cpu_descriptor_handle& dx_cpu_descriptor_handle::create2DTextureSRV(const ref<dx_texture>& texture, texture_mip_range mipRange, DXGI_FORMAT overrideFormat)
{
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {};
	srvDesc.Format = (overrideFormat == DXGI_FORMAT_UNKNOWN) ? texture->resource->GetDesc().Format : overrideFormat;
	srvDesc.Shader4ComponentMapping = getShader4ComponentMapping(srvDesc.Format);
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
	srvDesc.Texture2D.MostDetailedMip = mipRange.first;
	srvDesc.Texture2D.MipLevels = mipRange.count;

	dxContext.device->CreateShaderResourceView(texture->resource.Get(), &srvDesc, cpuHandle);

	return *this;
}

dx_cpu_descriptor_handle& dx_cpu_descriptor_handle::createCubemapSRV(const ref<dx_texture>& texture, texture_mip_range mipRange, DXGI_FORMAT overrideFormat)
{
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {};
	srvDesc.Format = (overrideFormat == DXGI_FORMAT_UNKNOWN) ? texture->resource->GetDesc().Format : overrideFormat;
	srvDesc.Shader4ComponentMapping = getShader4ComponentMapping(srvDesc.Format);
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURECUBE;
	srvDesc.TextureCube.MostDetailedMip = mipRange.first;
	srvDesc.TextureCube.MipLevels = mipRange.count;

	dxContext.device->CreateShaderResourceView(texture->resource.Get(), &srvDesc, cpuHandle);

	return *this;
}

dx_cpu_descriptor_handle& dx_cpu_descriptor_handle::createCubemapArraySRV(const ref<dx_texture>& texture, texture_mip_range mipRange, uint32 firstCube, uint32 numCubes, DXGI_FORMAT overrideFormat)
{
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {};
	srvDesc.Format = (overrideFormat == DXGI_FORMAT_UNKNOWN) ? texture->resource->GetDesc().Format : overrideFormat;
	srvDesc.Shader4ComponentMapping = getShader4ComponentMapping(srvDesc.Format);
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURECUBEARRAY;
	srvDesc.TextureCubeArray.MostDetailedMip = mipRange.first;
	srvDesc.TextureCubeArray.MipLevels = mipRange.count;
	srvDesc.TextureCubeArray.NumCubes = numCubes;
	srvDesc.TextureCubeArray.First2DArrayFace = firstCube * 6;

	dxContext.device->CreateShaderResourceView(texture->resource.Get(), &srvDesc, cpuHandle);

	return *this;
}

dx_cpu_descriptor_handle& dx_cpu_descriptor_handle::createVolumeTextureSRV(const ref<dx_texture>& texture, texture_mip_range mipRange, DXGI_FORMAT overrideFormat)
{
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {};
	srvDesc.Format = (overrideFormat == DXGI_FORMAT_UNKNOWN) ? texture->resource->GetDesc().Format : overrideFormat;
	srvDesc.Shader4ComponentMapping = getShader4ComponentMapping(srvDesc.Format);
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE3D;
	srvDesc.Texture3D.MostDetailedMip = mipRange.first;
	srvDesc.Texture3D.MipLevels = mipRange.count;
	srvDesc.Texture3D.ResourceMinLODClamp = 0;

	dxContext.device->CreateShaderResourceView(texture->resource.Get(), &srvDesc, cpuHandle);

	return *this;
}

dx_cpu_descriptor_handle& dx_cpu_descriptor_handle::createDepthTextureSRV(const ref<dx_texture>& texture)
{
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {};
	srvDesc.Format = getDepthReadFormat(texture->format);
	srvDesc.Shader4ComponentMapping = D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(0, 0, 0, 0);
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
	srvDesc.Texture2D.MipLevels = 1;

	dxContext.device->CreateShaderResourceView(texture->resource.Get(), &srvDesc, cpuHandle);

	return *this;
}

dx_cpu_descriptor_handle& dx_cpu_descriptor_handle::createDepthTextureArraySRV(const ref<dx_texture>& texture)
{
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {};
	srvDesc.Format = getDepthReadFormat(texture->format);
	srvDesc.Shader4ComponentMapping = D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(0, 0, 0, 0);
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2DARRAY;
	srvDesc.Texture2DArray.MipLevels = 1;
	srvDesc.Texture2DArray.FirstArraySlice = 0;
	srvDesc.Texture2DArray.ArraySize = texture->resource->GetDesc().DepthOrArraySize;

	dxContext.device->CreateShaderResourceView(texture->resource.Get(), &srvDesc, cpuHandle);

	return *this;
}

dx_cpu_descriptor_handle& dx_cpu_descriptor_handle::createStencilTextureSRV(const ref<dx_texture>& texture)
{
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {};
	srvDesc.Format = getStencilReadFormat(texture->format);
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
	srvDesc.Texture2D.MipLevels = 1;
	srvDesc.Texture2D.PlaneSlice = 1;

	dxContext.device->CreateShaderResourceView(texture->resource.Get(), &srvDesc, cpuHandle);

	return *this;
}

dx_cpu_descriptor_handle& dx_cpu_descriptor_handle::createNullTextureSRV()
{
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {};
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
	srvDesc.Format = DXGI_FORMAT_R32_FLOAT;
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.Texture2D.MipLevels = 0;

	dxContext.device->CreateShaderResourceView(0, &srvDesc, cpuHandle);

	return *this;
}

dx_cpu_descriptor_handle& dx_cpu_descriptor_handle::createBufferSRV(const ref<dx_buffer>& buffer, buffer_range bufferRange)
{
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {};
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.Format = DXGI_FORMAT_UNKNOWN;
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_BUFFER;
	srvDesc.Buffer.FirstElement = bufferRange.firstElement;
	srvDesc.Buffer.NumElements = (bufferRange.numElements != -1) ? bufferRange.numElements : (buffer->elementCount - bufferRange.firstElement);
	srvDesc.Buffer.StructureByteStride = buffer->elementSize;
	srvDesc.Buffer.Flags = D3D12_BUFFER_SRV_FLAG_NONE;

	dxContext.device->CreateShaderResourceView(buffer->resource.Get(), &srvDesc, cpuHandle);

	return *this;
}

dx_cpu_descriptor_handle& dx_cpu_descriptor_handle::createRawBufferSRV(const ref<dx_buffer>& buffer, buffer_range bufferRange)
{
	uint32 firstElementByteOffset = bufferRange.firstElement * buffer->elementSize;
	ASSERT(firstElementByteOffset % 16 == 0);

	uint32 count = (bufferRange.numElements != -1) ? bufferRange.numElements : (buffer->elementCount - bufferRange.firstElement);
	uint32 totalSize = count * buffer->elementSize;

	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {};
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.Format = DXGI_FORMAT_R32_TYPELESS;
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_BUFFER;
	srvDesc.Buffer.FirstElement = firstElementByteOffset / 4;
	srvDesc.Buffer.NumElements = totalSize / 4;
	srvDesc.Buffer.StructureByteStride = 0;
	srvDesc.Buffer.Flags = D3D12_BUFFER_SRV_FLAG_RAW;

	dxContext.device->CreateShaderResourceView(buffer->resource.Get(), &srvDesc, cpuHandle);

	return *this;
}

dx_cpu_descriptor_handle& dx_cpu_descriptor_handle::createNullBufferSRV()
{
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {};
	srvDesc.Format = DXGI_FORMAT_R32_TYPELESS;
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_BUFFER;
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.Buffer.FirstElement = 0;
	srvDesc.Buffer.NumElements = 1;
	srvDesc.Buffer.StructureByteStride = 0;
	srvDesc.Buffer.Flags = D3D12_BUFFER_SRV_FLAG_RAW;

	dxContext.device->CreateShaderResourceView(0, &srvDesc, cpuHandle);

	return *this;
}

dx_cpu_descriptor_handle& dx_cpu_descriptor_handle::create2DTextureUAV(const ref<dx_texture>& texture, uint32 mipSlice, DXGI_FORMAT overrideFormat)
{
	D3D12_UNORDERED_ACCESS_VIEW_DESC uavDesc = {};
	uavDesc.ViewDimension = D3D12_UAV_DIMENSION_TEXTURE2D;
	uavDesc.Format = overrideFormat;
	uavDesc.Texture2D.MipSlice = mipSlice;
	dxContext.device->CreateUnorderedAccessView(texture->resource.Get(), 0, &uavDesc, cpuHandle);

	return *this;
}

dx_cpu_descriptor_handle& dx_cpu_descriptor_handle::create2DTextureArrayUAV(const ref<dx_texture>& texture, uint32 mipSlice, DXGI_FORMAT overrideFormat)
{
	D3D12_UNORDERED_ACCESS_VIEW_DESC uavDesc = {};
	uavDesc.ViewDimension = D3D12_UAV_DIMENSION_TEXTURE2DARRAY;
	uavDesc.Format = overrideFormat;
	uavDesc.Texture2DArray.FirstArraySlice = 0;
	uavDesc.Texture2DArray.ArraySize = texture->resource->GetDesc().DepthOrArraySize;
	uavDesc.Texture2DArray.MipSlice = mipSlice;
	dxContext.device->CreateUnorderedAccessView(texture->resource.Get(), 0, &uavDesc, cpuHandle);

	return *this;
}

dx_cpu_descriptor_handle& dx_cpu_descriptor_handle::createCubemapUAV(const ref<dx_texture>& texture, uint32 mipSlice, DXGI_FORMAT overrideFormat)
{
	D3D12_UNORDERED_ACCESS_VIEW_DESC uavDesc = {};
	uavDesc.ViewDimension = D3D12_UAV_DIMENSION_TEXTURE2DARRAY;
	uavDesc.Format = overrideFormat;
	uavDesc.Texture2DArray.FirstArraySlice = 0;
	uavDesc.Texture2DArray.ArraySize = texture->resource->GetDesc().DepthOrArraySize;
	uavDesc.Texture2DArray.MipSlice = mipSlice;
	dxContext.device->CreateUnorderedAccessView(texture->resource.Get(), 0, &uavDesc, cpuHandle);

	return *this;
}

dx_cpu_descriptor_handle& dx_cpu_descriptor_handle::createVolumeTextureUAV(const ref<dx_texture>& texture, uint32 mipSlice, DXGI_FORMAT overrideFormat)
{
	D3D12_UNORDERED_ACCESS_VIEW_DESC uavDesc = {};
	uavDesc.ViewDimension = D3D12_UAV_DIMENSION_TEXTURE3D;
	uavDesc.Format = overrideFormat;
	uavDesc.Texture3D.MipSlice = mipSlice;
	uavDesc.Texture3D.FirstWSlice = 0;
	uavDesc.Texture3D.WSize = texture->depth;
	dxContext.device->CreateUnorderedAccessView(texture->resource.Get(), 0, &uavDesc, cpuHandle);

	return *this;
}

dx_cpu_descriptor_handle& dx_cpu_descriptor_handle::createNullTextureUAV()
{
	D3D12_UNORDERED_ACCESS_VIEW_DESC uavDesc = {};
	uavDesc.ViewDimension = D3D12_UAV_DIMENSION_TEXTURE2D;
	uavDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;

	dxContext.device->CreateUnorderedAccessView(0, 0, &uavDesc, cpuHandle);

	return *this;
}

dx_cpu_descriptor_handle& dx_cpu_descriptor_handle::createBufferUAV(const ref<dx_buffer>& buffer, buffer_range bufferRange)
{
	D3D12_UNORDERED_ACCESS_VIEW_DESC uavDesc = {};
	uavDesc.ViewDimension = D3D12_UAV_DIMENSION_BUFFER;
	uavDesc.Buffer.CounterOffsetInBytes = 0;
	uavDesc.Buffer.FirstElement = bufferRange.firstElement;
	uavDesc.Buffer.NumElements = (bufferRange.numElements != -1) ? bufferRange.numElements : (buffer->elementCount - bufferRange.firstElement);
	uavDesc.Buffer.StructureByteStride = buffer->elementSize;
	uavDesc.Buffer.Flags = D3D12_BUFFER_UAV_FLAG_NONE;

	dxContext.device->CreateUnorderedAccessView(buffer->resource.Get(), 0, &uavDesc, cpuHandle);

	return *this;
}

dx_cpu_descriptor_handle& dx_cpu_descriptor_handle::createBufferUintUAV(const ref<dx_buffer>& buffer, buffer_range bufferRange)
{
	uint32 firstElementByteOffset = bufferRange.firstElement * buffer->elementSize;
	ASSERT(firstElementByteOffset % 16 == 0);

	uint32 count = (bufferRange.numElements != -1) ? bufferRange.numElements : (buffer->elementCount - bufferRange.firstElement);
	uint32 totalSize = count * buffer->elementSize;

	D3D12_UNORDERED_ACCESS_VIEW_DESC uavDesc = {};
	uavDesc.Format = DXGI_FORMAT_R32_UINT;
	uavDesc.ViewDimension = D3D12_UAV_DIMENSION_BUFFER;
	uavDesc.Buffer.CounterOffsetInBytes = 0;
	uavDesc.Buffer.FirstElement = firstElementByteOffset / 4;
	uavDesc.Buffer.NumElements = totalSize / 4;
	uavDesc.Buffer.StructureByteStride = 0;
	uavDesc.Buffer.Flags = D3D12_BUFFER_UAV_FLAG_NONE;

	dxContext.device->CreateUnorderedAccessView(buffer->resource.Get(), 0, &uavDesc, cpuHandle);

	return *this;
}

dx_cpu_descriptor_handle& dx_cpu_descriptor_handle::createRawBufferUAV(const ref<dx_buffer>& buffer, buffer_range bufferRange)
{
	uint32 firstElementByteOffset = bufferRange.firstElement * buffer->elementSize;
	ASSERT(firstElementByteOffset % 16 == 0);

	uint32 count = (bufferRange.numElements != -1) ? bufferRange.numElements : (buffer->elementCount - bufferRange.firstElement);
	uint32 totalSize = count * buffer->elementSize;

	D3D12_UNORDERED_ACCESS_VIEW_DESC uavDesc = {};
	uavDesc.Format = DXGI_FORMAT_R32_TYPELESS;
	uavDesc.ViewDimension = D3D12_UAV_DIMENSION_BUFFER;
	uavDesc.Buffer.FirstElement = firstElementByteOffset / 4;
	uavDesc.Buffer.NumElements = totalSize / 4;
	uavDesc.Buffer.StructureByteStride = 0;
	uavDesc.Buffer.Flags = D3D12_BUFFER_UAV_FLAG_RAW;

	dxContext.device->CreateUnorderedAccessView(buffer->resource.Get(), 0, &uavDesc, cpuHandle);

	return *this;
}

dx_cpu_descriptor_handle& dx_cpu_descriptor_handle::createNullBufferUAV()
{
	D3D12_UNORDERED_ACCESS_VIEW_DESC uavDesc = {};
	uavDesc.ViewDimension = D3D12_UAV_DIMENSION_BUFFER;
	uavDesc.Format = DXGI_FORMAT_UNKNOWN;

	dxContext.device->CreateUnorderedAccessView(0, 0, &uavDesc, cpuHandle);

	return *this;
}

dx_cpu_descriptor_handle& dx_cpu_descriptor_handle::createRaytracingAccelerationStructureSRV(const ref<dx_buffer>& tlas)
{
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {};
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_RAYTRACING_ACCELERATION_STRUCTURE;
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.RaytracingAccelerationStructure.Location = tlas->gpuVirtualAddress;

	dxContext.device->CreateShaderResourceView(nullptr, &srvDesc, cpuHandle);

	return *this;
}

dx_cpu_descriptor_handle dx_cpu_descriptor_handle::operator+(uint32 i)
{
	return { CD3DX12_CPU_DESCRIPTOR_HANDLE(cpuHandle, i, dxContext.descriptorHandleIncrementSize) };
}

dx_cpu_descriptor_handle& dx_cpu_descriptor_handle::operator+=(uint32 i)
{
	cpuHandle.Offset(i, dxContext.descriptorHandleIncrementSize);
	return *this;
}

dx_cpu_descriptor_handle& dx_cpu_descriptor_handle::operator++()
{
	cpuHandle.Offset(dxContext.descriptorHandleIncrementSize);
	return *this;
}

dx_cpu_descriptor_handle dx_cpu_descriptor_handle::operator++(int)
{
	dx_cpu_descriptor_handle result = *this;
	cpuHandle.Offset(dxContext.descriptorHandleIncrementSize);
	return result;
}

dx_gpu_descriptor_handle dx_gpu_descriptor_handle::operator+(uint32 i)
{
	return { CD3DX12_GPU_DESCRIPTOR_HANDLE(gpuHandle, i, dxContext.descriptorHandleIncrementSize) };
}

dx_gpu_descriptor_handle& dx_gpu_descriptor_handle::operator+=(uint32 i)
{
	gpuHandle.Offset(i, dxContext.descriptorHandleIncrementSize);
	return *this;
}

dx_gpu_descriptor_handle& dx_gpu_descriptor_handle::operator++()
{
	gpuHandle.Offset(dxContext.descriptorHandleIncrementSize);
	return *this;
}

dx_gpu_descriptor_handle dx_gpu_descriptor_handle::operator++(int)
{
	dx_gpu_descriptor_handle result = *this;
	gpuHandle.Offset(dxContext.descriptorHandleIncrementSize);
	return result;
}

dx_rtv_descriptor_handle& dx_rtv_descriptor_handle::create2DTextureRTV(const ref<dx_texture>& texture, uint32 arraySlice, uint32 mipSlice)
{
	ASSERT(texture->supportsRTV);

	D3D12_RENDER_TARGET_VIEW_DESC rtvDesc;
	rtvDesc.Format = texture->format;

	if (texture->depth == 1)
	{
		rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2D;
		rtvDesc.Texture2D.MipSlice = mipSlice;
		rtvDesc.Texture2D.PlaneSlice = 0;

		dxContext.device->CreateRenderTargetView(texture->resource.Get(), &rtvDesc, cpuHandle);
	}
	else
	{
		rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2DARRAY;
		rtvDesc.Texture2DArray.FirstArraySlice = arraySlice;
		rtvDesc.Texture2DArray.ArraySize = 1;
		rtvDesc.Texture2DArray.MipSlice = mipSlice;
		rtvDesc.Texture2DArray.PlaneSlice = 0;

		dxContext.device->CreateRenderTargetView(texture->resource.Get(), &rtvDesc, cpuHandle);
	}
	return *this;
}

dx_rtv_descriptor_handle& dx_rtv_descriptor_handle::createNullTextureRTV(DXGI_FORMAT format)
{
	D3D12_RENDER_TARGET_VIEW_DESC rtvDesc = {};
	rtvDesc.Format = format;
	rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2D;

	dxContext.device->CreateRenderTargetView(0, &rtvDesc, cpuHandle);

	return *this;
}

dx_dsv_descriptor_handle& dx_dsv_descriptor_handle::create2DTextureDSV(const ref<dx_texture>& texture, uint32 arraySlice, uint32 mipSlice)
{
	ASSERT(texture->supportsDSV);
	ASSERT(isDepthFormat(texture->format));

	D3D12_DEPTH_STENCIL_VIEW_DESC dsvDesc = {};
	dsvDesc.Format = texture->format;

	if (texture->depth == 1)
	{
		dsvDesc.ViewDimension = D3D12_DSV_DIMENSION_TEXTURE2D;
		dsvDesc.Texture2D.MipSlice = mipSlice;

		dxContext.device->CreateDepthStencilView(texture->resource.Get(), &dsvDesc, cpuHandle);
	}
	else
	{
		dsvDesc.ViewDimension = D3D12_DSV_DIMENSION_TEXTURE2DARRAY;
		dsvDesc.Texture2DArray.FirstArraySlice = arraySlice;
		dsvDesc.Texture2DArray.ArraySize = 1;
		dsvDesc.Texture2DArray.MipSlice = mipSlice;

		dxContext.device->CreateDepthStencilView(texture->resource.Get(), &dsvDesc, cpuHandle);
	}
	return *this;
}

```

`src/dx/dx_descriptor.h`:

```h
#pragma once

#include "dx.h"

struct dx_texture;
struct dx_buffer;


struct texture_mip_range
{
	uint32 first = 0;
	uint32 count = (uint32)-1; // Use all mips.
};

struct buffer_range
{
	uint32 firstElement = 0;
	uint32 numElements = (uint32)-1; // Use all elements.
};

struct dx_cpu_descriptor_handle
{
	dx_cpu_descriptor_handle() = default;
	dx_cpu_descriptor_handle(CD3DX12_CPU_DESCRIPTOR_HANDLE handle) : cpuHandle(handle) {}
	dx_cpu_descriptor_handle(D3D12_CPU_DESCRIPTOR_HANDLE handle) : cpuHandle(handle) {}
	dx_cpu_descriptor_handle(CD3DX12_DEFAULT) : cpuHandle(D3D12_DEFAULT) {}

	CD3DX12_CPU_DESCRIPTOR_HANDLE cpuHandle;

	inline operator CD3DX12_CPU_DESCRIPTOR_HANDLE() const { return cpuHandle; }
	inline operator bool() const { return cpuHandle.ptr != 0; }

	dx_cpu_descriptor_handle& create2DTextureSRV(const ref<dx_texture>& texture, texture_mip_range mipRange = {}, DXGI_FORMAT overrideFormat = DXGI_FORMAT_UNKNOWN);
	dx_cpu_descriptor_handle& createCubemapSRV(const ref<dx_texture>& texture, texture_mip_range mipRange = {}, DXGI_FORMAT overrideFormat = DXGI_FORMAT_UNKNOWN);
	dx_cpu_descriptor_handle& createCubemapArraySRV(const ref<dx_texture>& texture, texture_mip_range mipRange = {}, uint32 firstCube = 0, uint32 numCubes = 1, DXGI_FORMAT overrideFormat = DXGI_FORMAT_UNKNOWN);
	dx_cpu_descriptor_handle& createVolumeTextureSRV(const ref<dx_texture>& texture, texture_mip_range mipRange = {}, DXGI_FORMAT overrideFormat = DXGI_FORMAT_UNKNOWN);
	dx_cpu_descriptor_handle& createDepthTextureSRV(const ref<dx_texture>& texture);
	dx_cpu_descriptor_handle& createDepthTextureArraySRV(const ref<dx_texture>& texture);
	dx_cpu_descriptor_handle& createStencilTextureSRV(const ref<dx_texture>& texture);
	dx_cpu_descriptor_handle& createNullTextureSRV();
	dx_cpu_descriptor_handle& createBufferSRV(const ref<dx_buffer>& buffer, buffer_range bufferRange = {});
	dx_cpu_descriptor_handle& createRawBufferSRV(const ref<dx_buffer>& buffer, buffer_range bufferRange = {});
	dx_cpu_descriptor_handle& createNullBufferSRV();
	dx_cpu_descriptor_handle& create2DTextureUAV(const ref<dx_texture>& texture, uint32 mipSlice = 0, DXGI_FORMAT overrideFormat = DXGI_FORMAT_UNKNOWN);
	dx_cpu_descriptor_handle& create2DTextureArrayUAV(const ref<dx_texture>& texture, uint32 mipSlice = 0, DXGI_FORMAT overrideFormat = DXGI_FORMAT_UNKNOWN);
	dx_cpu_descriptor_handle& createCubemapUAV(const ref<dx_texture>& texture, uint32 mipSlice = 0, DXGI_FORMAT overrideFormat = DXGI_FORMAT_UNKNOWN);
	dx_cpu_descriptor_handle& createVolumeTextureUAV(const ref<dx_texture>& texture, uint32 mipSlice = 0, DXGI_FORMAT overrideFormat = DXGI_FORMAT_UNKNOWN);
	dx_cpu_descriptor_handle& createNullTextureUAV();
	dx_cpu_descriptor_handle& createBufferUAV(const ref<dx_buffer>& buffer, buffer_range bufferRange = {});
	dx_cpu_descriptor_handle& createBufferUintUAV(const ref<dx_buffer>& buffer, buffer_range bufferRange = {});
	dx_cpu_descriptor_handle& createRawBufferUAV(const ref<dx_buffer>& buffer, buffer_range bufferRange = {});
	dx_cpu_descriptor_handle& createNullBufferUAV();
	dx_cpu_descriptor_handle& createRaytracingAccelerationStructureSRV(const ref<dx_buffer>& tlas);


	dx_cpu_descriptor_handle operator+(uint32 i);
	dx_cpu_descriptor_handle& operator+=(uint32 i);
	dx_cpu_descriptor_handle& operator++();
	dx_cpu_descriptor_handle operator++(int);
};

struct dx_gpu_descriptor_handle
{
	dx_gpu_descriptor_handle() = default;
	dx_gpu_descriptor_handle(CD3DX12_GPU_DESCRIPTOR_HANDLE handle) : gpuHandle(handle) {}
	dx_gpu_descriptor_handle(D3D12_GPU_DESCRIPTOR_HANDLE handle) : gpuHandle(handle) {}
	dx_gpu_descriptor_handle(CD3DX12_DEFAULT) : gpuHandle(D3D12_DEFAULT) {}

	CD3DX12_GPU_DESCRIPTOR_HANDLE gpuHandle;

	inline operator CD3DX12_GPU_DESCRIPTOR_HANDLE() const { return gpuHandle; }
	inline operator bool() const { return gpuHandle.ptr != 0; }


	dx_gpu_descriptor_handle operator+(uint32 i);
	dx_gpu_descriptor_handle& operator+=(uint32 i);
	dx_gpu_descriptor_handle& operator++();
	dx_gpu_descriptor_handle operator++(int);
};

struct dx_double_descriptor_handle : dx_cpu_descriptor_handle, dx_gpu_descriptor_handle
{
};

struct dx_rtv_descriptor_handle
{
	dx_rtv_descriptor_handle() = default;
	dx_rtv_descriptor_handle(CD3DX12_CPU_DESCRIPTOR_HANDLE handle) : cpuHandle(handle) {}
	dx_rtv_descriptor_handle(D3D12_CPU_DESCRIPTOR_HANDLE handle) : cpuHandle(handle) {}
	dx_rtv_descriptor_handle(CD3DX12_DEFAULT) : cpuHandle(D3D12_DEFAULT) {}

	CD3DX12_CPU_DESCRIPTOR_HANDLE cpuHandle;

	inline operator CD3DX12_CPU_DESCRIPTOR_HANDLE() const { return cpuHandle; }
	inline operator bool() const { return cpuHandle.ptr != 0; }


	dx_rtv_descriptor_handle& create2DTextureRTV(const ref<dx_texture>& texture, uint32 arraySlice = 0, uint32 mipSlice = 0);
	dx_rtv_descriptor_handle& createNullTextureRTV(DXGI_FORMAT format);
};

struct dx_dsv_descriptor_handle
{
	dx_dsv_descriptor_handle() = default;
	dx_dsv_descriptor_handle(CD3DX12_CPU_DESCRIPTOR_HANDLE handle) : cpuHandle(handle) {}
	dx_dsv_descriptor_handle(D3D12_CPU_DESCRIPTOR_HANDLE handle) : cpuHandle(handle) {}
	dx_dsv_descriptor_handle(CD3DX12_DEFAULT) : cpuHandle(D3D12_DEFAULT) {}

	CD3DX12_CPU_DESCRIPTOR_HANDLE cpuHandle;

	inline operator CD3DX12_CPU_DESCRIPTOR_HANDLE() const { return cpuHandle; }
	inline operator bool() const { return cpuHandle.ptr != 0; }


	dx_dsv_descriptor_handle& create2DTextureDSV(const ref<dx_texture>& texture, uint32 arraySlice = 0, uint32 mipSlice = 0);
};

```

`src/dx/dx_descriptor_allocation.cpp`:

```cpp
#include "pch.h"
#include "dx_descriptor_allocation.h"
#include "dx_command_list.h"
#include "dx_context.h"
#include "dx_texture.h"
#include "core/block_allocator.h"


struct dx_descriptor_page
{
	dx_descriptor_page(D3D12_DESCRIPTOR_HEAP_TYPE type, uint64 capacity, bool shaderVisible);

	std::pair<dx_descriptor_allocation, bool> allocate(uint64 count);
	void free(dx_descriptor_allocation allocation);

	D3D12_DESCRIPTOR_HEAP_TYPE type;
	com<ID3D12DescriptorHeap> descriptorHeap;

	CD3DX12_CPU_DESCRIPTOR_HANDLE cpuBase;
	CD3DX12_GPU_DESCRIPTOR_HANDLE gpuBase;

	uint32 descriptorSize;

	block_allocator allocator;
};

dx_descriptor_page::dx_descriptor_page(D3D12_DESCRIPTOR_HEAP_TYPE type, uint64 capacity, bool shaderVisible)
{
	allocator.initialize(capacity);

	D3D12_DESCRIPTOR_HEAP_DESC desc = {};
	desc.NumDescriptors = (uint32)capacity;
	desc.Type = type;
	if (shaderVisible)
	{
		desc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
	}

	checkResult(dxContext.device->CreateDescriptorHeap(&desc, IID_PPV_ARGS(&descriptorHeap)));

	cpuBase = descriptorHeap->GetCPUDescriptorHandleForHeapStart();
	gpuBase = shaderVisible ? descriptorHeap->GetGPUDescriptorHandleForHeapStart() : CD3DX12_GPU_DESCRIPTOR_HANDLE{};
	descriptorSize = dxContext.device->GetDescriptorHandleIncrementSize(type);
}

std::pair<dx_descriptor_allocation, bool> dx_descriptor_page::allocate(uint64 count)
{
	uint64 offset = allocator.allocate(count);
	if (offset == UINT64_MAX)
	{
		return { dx_descriptor_allocation{}, false };
	}

	dx_descriptor_allocation result;
	result.count = count;
	result.cpuBase.InitOffsetted(cpuBase, (uint32)offset, descriptorSize);
	result.gpuBase.InitOffsetted(gpuBase, (uint32)offset, descriptorSize);
	result.descriptorSize = descriptorSize;

	return { result, true };
}

void dx_descriptor_page::free(dx_descriptor_allocation allocation)
{
	uint64 offset = (allocation.cpuBase.ptr - cpuBase.ptr) / descriptorSize;
	allocator.free(offset, allocation.count);
}





void dx_descriptor_heap::initialize(D3D12_DESCRIPTOR_HEAP_TYPE type, bool shaderVisible, uint64 pageSize)
{
	this->type = type;
	this->pageSize = pageSize;
	this->shaderVisible = shaderVisible;
}

dx_descriptor_allocation dx_descriptor_heap::allocate(uint64 count)
{
	if (count == 0)
	{
		return {};
	}

	ASSERT(count <= pageSize);

	mutex.lock();

	for (uint32 i = 0; i < (uint32)allPages.size(); ++i)
	{
		auto [allocation, success] = allPages[i]->allocate(count);
		if (success)
		{
			allocation.pageIndex = i;
			mutex.unlock();
			return allocation;
		}
	}

	uint32 pageIndex = (uint32)allPages.size();
	allPages.push_back(new dx_descriptor_page(type, pageSize, shaderVisible));
	
	auto [allocation, success] = allPages.back()->allocate(count);
	ASSERT(success);
	allocation.pageIndex = pageIndex;
	
	mutex.unlock();

	return allocation;
}

void dx_descriptor_heap::free(dx_descriptor_allocation allocation)
{
	if (allocation.valid())
	{
		mutex.lock();
		allPages[allocation.pageIndex]->free(allocation);
		mutex.unlock();
	}
}

com<ID3D12DescriptorHeap> dx_descriptor_heap::getHeap(int index) const
{
	return allPages[index]->descriptorHeap;
}










struct dx_frame_descriptor_page
{
	com<ID3D12DescriptorHeap> descriptorHeap;
	dx_double_descriptor_handle base;
	uint32 usedDescriptors;
	uint32 maxNumDescriptors;
	uint32 descriptorHandleIncrementSize;

	dx_frame_descriptor_page* next;
};


void dx_frame_descriptor_allocator::initialize()
{
	currentFrame = NUM_BUFFERED_FRAMES - 1;
}

void dx_frame_descriptor_allocator::newFrame(uint32 bufferedFrameID)
{
	mutex.lock();

	currentFrame = bufferedFrameID;

	while (usedPages[currentFrame])
	{
		dx_frame_descriptor_page* page = usedPages[currentFrame];
		usedPages[currentFrame] = page->next;
		page->next = freePages;
		freePages = page;
	}

	mutex.unlock();
}

dx_descriptor_range dx_frame_descriptor_allocator::allocateContiguousDescriptorRange(uint32 count)
{
	mutex.lock();

	dx_frame_descriptor_page* current = usedPages[currentFrame];
	if (!current || (current->maxNumDescriptors - current->usedDescriptors < count))
	{
		dx_frame_descriptor_page* freePage = freePages;
		if (!freePage)
		{
			freePage = (dx_frame_descriptor_page*)calloc(1, sizeof(dx_frame_descriptor_page));

			D3D12_DESCRIPTOR_HEAP_DESC desc = {};
			desc.NumDescriptors = 1024;
			desc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
			desc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;

			checkResult(dxContext.device->CreateDescriptorHeap(&desc, IID_PPV_ARGS(&freePage->descriptorHeap)));

			freePage->maxNumDescriptors = desc.NumDescriptors;
			freePage->descriptorHandleIncrementSize = dxContext.device->GetDescriptorHandleIncrementSize(desc.Type);
			freePage->base.cpuHandle = freePage->descriptorHeap->GetCPUDescriptorHandleForHeapStart();
			freePage->base.gpuHandle = freePage->descriptorHeap->GetGPUDescriptorHandleForHeapStart();
		}

		freePages = freePage->next;
		freePage->usedDescriptors = 0;
		freePage->next = current;
		usedPages[currentFrame] = freePage;
		current = freePage;
	}

	uint32 index = current->usedDescriptors;
	current->usedDescriptors += count;

	mutex.unlock();

	dx_descriptor_range result;

	result.base.cpuHandle = CD3DX12_CPU_DESCRIPTOR_HANDLE(current->base.cpuHandle, index, current->descriptorHandleIncrementSize);
	result.base.gpuHandle = CD3DX12_GPU_DESCRIPTOR_HANDLE(current->base.gpuHandle, index, current->descriptorHandleIncrementSize);
	result.descriptorHandleIncrementSize = current->descriptorHandleIncrementSize;
	result.descriptorHeap = current->descriptorHeap;
	result.maxNumDescriptors = count;
	result.pushIndex = 0;

	return result;
}

void dx_pushable_descriptor_heap::initialize(uint32 maxSize, bool shaderVisible)
{
	D3D12_DESCRIPTOR_HEAP_DESC desc = {};
	desc.NumDescriptors = maxSize;
	desc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
	if (shaderVisible)
	{
		desc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
	}

	checkResult(dxContext.device->CreateDescriptorHeap(&desc, IID_PPV_ARGS(&descriptorHeap)));

	reset();
}

void dx_pushable_descriptor_heap::reset()
{
	currentCPU = descriptorHeap->GetCPUDescriptorHandleForHeapStart();
	currentGPU = descriptorHeap->GetGPUDescriptorHandleForHeapStart();
}

dx_cpu_descriptor_handle dx_pushable_descriptor_heap::push()
{
	++currentGPU;
	return currentCPU++;
}

```

`src/dx/dx_descriptor_allocation.h`:

```h
#pragma once

#include "dx.h"
#include "dx_descriptor.h"
#include "core/threading.h"



struct dx_descriptor_page;

struct dx_descriptor_allocation
{
	inline CD3DX12_CPU_DESCRIPTOR_HANDLE cpuAt(uint32 index = 0) { ASSERT(index < count); return CD3DX12_CPU_DESCRIPTOR_HANDLE(cpuBase, index, descriptorSize); }
	inline CD3DX12_GPU_DESCRIPTOR_HANDLE gpuAt(uint32 index = 0) { ASSERT(index < count); return CD3DX12_GPU_DESCRIPTOR_HANDLE(gpuBase, index, descriptorSize); }

	inline bool valid() { return count > 0; }
	uint64 count = 0;

private:
	CD3DX12_CPU_DESCRIPTOR_HANDLE cpuBase;
	CD3DX12_GPU_DESCRIPTOR_HANDLE gpuBase;
	uint32 descriptorSize;
	uint32 pageIndex;

	friend struct dx_descriptor_page;
	friend struct dx_descriptor_heap;
};

struct dx_descriptor_heap
{
	void initialize(D3D12_DESCRIPTOR_HEAP_TYPE type, bool shaderVisible, uint64 pageSize = 4096);

	dx_descriptor_allocation allocate(uint64 count = 1);
	void free(dx_descriptor_allocation allocation);

	D3D12_DESCRIPTOR_HEAP_TYPE type;

	com<ID3D12DescriptorHeap> getHeap(int index) const;

private:
	std::mutex mutex;
	uint64 pageSize;
	bool shaderVisible;
	std::vector<dx_descriptor_page*> allPages;
};


struct dx_descriptor_range
{
	inline dx_double_descriptor_handle pushHandle()
	{
		dx_double_descriptor_handle result =
		{
			CD3DX12_CPU_DESCRIPTOR_HANDLE(base.cpuHandle, pushIndex, descriptorHandleIncrementSize) ,
			CD3DX12_GPU_DESCRIPTOR_HANDLE(base.gpuHandle, pushIndex, descriptorHandleIncrementSize) ,
		};
		++pushIndex;
		return result;
	}
	com<ID3D12DescriptorHeap> descriptorHeap;
	D3D12_DESCRIPTOR_HEAP_TYPE type;
	uint32 descriptorHandleIncrementSize;

private:
	dx_double_descriptor_handle base;

	uint32 maxNumDescriptors;

	uint32 pushIndex;

	friend struct dx_frame_descriptor_allocator;
};

struct dx_frame_descriptor_page;

struct dx_frame_descriptor_allocator
{
	dx_frame_descriptor_page* usedPages[NUM_BUFFERED_FRAMES];
	dx_frame_descriptor_page* freePages;
	uint32 currentFrame;

	std::mutex mutex;

	void initialize();
	void newFrame(uint32 bufferedFrameID);
	dx_descriptor_range allocateContiguousDescriptorRange(uint32 count);
};



struct dx_pushable_descriptor_heap
{
	void initialize(uint32 maxSize, bool shaderVisible = true);
	void reset();
	dx_cpu_descriptor_handle push();

	com<ID3D12DescriptorHeap> descriptorHeap;
	dx_cpu_descriptor_handle currentCPU;
	dx_gpu_descriptor_handle currentGPU;
};

```

`src/dx/dx_dynamic_descriptor_heap.cpp`:

```cpp
#include "pch.h"
#include "dx_dynamic_descriptor_heap.h"
#include "dx_command_list.h"
#include "dx_context.h"

void dx_dynamic_descriptor_heap::initialize(uint32 numDescriptorsPerHeap)
{
	this->numDescriptorsPerHeap = numDescriptorsPerHeap;
	descriptorTableBitMask = 0;
	staleDescriptorTableBitMask = 0;
	currentCPUDescriptorHandle = D3D12_DEFAULT;
	currentGPUDescriptorHandle = D3D12_DEFAULT;
	numFreeHandles = 0;

	descriptorHandleCache.resize(numDescriptorsPerHeap);
}

void dx_dynamic_descriptor_heap::stageDescriptors(uint32 rootParameterIndex, uint32 offset, uint32 numDescriptors, dx_cpu_descriptor_handle srcDescriptor)
{
	ASSERT(numDescriptors <= numDescriptorsPerHeap && rootParameterIndex < maxDescriptorTables);

	descriptor_table_cache& cache = descriptorTableCache[rootParameterIndex];

	ASSERT((offset + numDescriptors) <= cache.numDescriptors);

	D3D12_CPU_DESCRIPTOR_HANDLE* dstDescriptor = (cache.baseDescriptor + offset);
	for (uint32 i = 0; i < numDescriptors; ++i)
	{
		dstDescriptor[i] = srcDescriptor + i;
	}

	setBit(staleDescriptorTableBitMask, rootParameterIndex);
}

void dx_dynamic_descriptor_heap::commitStagedDescriptors(dx_command_list* commandList, bool graphics)
{
	uint32 numDescriptorsToCommit = computeStaleDescriptorCount();

	if (numDescriptorsToCommit > 0)
	{
		if (!currentDescriptorHeap || numFreeHandles < numDescriptorsToCommit)
		{
			currentDescriptorHeap = requestDescriptorHeap();
			currentCPUDescriptorHandle = currentDescriptorHeap->GetCPUDescriptorHandleForHeapStart();
			currentGPUDescriptorHandle = currentDescriptorHeap->GetGPUDescriptorHandleForHeapStart();
			numFreeHandles = numDescriptorsPerHeap;

			commandList->setDescriptorHeap(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV, currentDescriptorHeap);

			// When updating the descriptor heap on the command list, all descriptor
			// tables must be (re)recopied to the new descriptor heap (not just
			// the stale descriptor tables).
			staleDescriptorTableBitMask = descriptorTableBitMask;
		}

		DWORD rootIndex;
		while (_BitScanForward(&rootIndex, staleDescriptorTableBitMask))
		{
			uint32 numSrcDescriptors = descriptorTableCache[rootIndex].numDescriptors;
			D3D12_CPU_DESCRIPTOR_HANDLE* srcDescriptorHandles = descriptorTableCache[rootIndex].baseDescriptor;
			D3D12_CPU_DESCRIPTOR_HANDLE destDescriptorRangeStart = currentCPUDescriptorHandle;

			dxContext.device->CopyDescriptors(
				1, &destDescriptorRangeStart, &numSrcDescriptors,
				numSrcDescriptors, srcDescriptorHandles, nullptr, 
				D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);

			if (graphics)
			{
				commandList->setGraphicsDescriptorTable(rootIndex, currentGPUDescriptorHandle);
			}
			else
			{
				commandList->setComputeDescriptorTable(rootIndex, currentGPUDescriptorHandle);
			}

			currentCPUDescriptorHandle += numSrcDescriptors;
			currentGPUDescriptorHandle += numSrcDescriptors;
			numFreeHandles -= numSrcDescriptors;

			unsetBit(staleDescriptorTableBitMask, rootIndex);
		}
	}
}

void dx_dynamic_descriptor_heap::commitStagedDescriptorsForDraw(dx_command_list* commandList)
{
	commitStagedDescriptors(commandList, true);
}

void dx_dynamic_descriptor_heap::commitStagedDescriptorsForDispatch(dx_command_list* commandList)
{
	commitStagedDescriptors(commandList, false);
}

void dx_dynamic_descriptor_heap::setCurrentDescriptorHeap(dx_command_list* commandList)
{
	commandList->setDescriptorHeap(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV, currentDescriptorHeap);
}

void dx_dynamic_descriptor_heap::parseRootSignature(const dx_root_signature& rootSignature)
{
	staleDescriptorTableBitMask = 0;

	descriptorTableBitMask = rootSignature.tableRootParameterMask;
	uint32 numDescriptorTables = rootSignature.numDescriptorTables;

	uint32 bitmask = descriptorTableBitMask;
	uint32 currentOffset = 0;
	DWORD rootIndex;
	uint32 descriptorTableIndex = 0;
	while (_BitScanForward(&rootIndex, bitmask))
	{
		uint32 numDescriptors = rootSignature.descriptorTableSizes[descriptorTableIndex++];

		descriptor_table_cache& cache = descriptorTableCache[rootIndex];
		cache.numDescriptors = numDescriptors;
		cache.baseDescriptor = &descriptorHandleCache[currentOffset];

		currentOffset += numDescriptors;

		// Flip the descriptor table bit so it's not scanned again for the current index.
		unsetBit(bitmask, rootIndex);
	}

	ASSERT(currentOffset <= numDescriptorsPerHeap); // The root signature requires more than the maximum number of descriptors per descriptor heap. Consider increasing the maximum number of descriptors per descriptor heap.
}

void dx_dynamic_descriptor_heap::reset()
{
	freeDescriptorHeaps = descriptorHeapPool;
	currentDescriptorHeap.Reset();
	currentCPUDescriptorHandle = CD3DX12_CPU_DESCRIPTOR_HANDLE(D3D12_DEFAULT);
	currentGPUDescriptorHandle = CD3DX12_GPU_DESCRIPTOR_HANDLE(D3D12_DEFAULT);
	numFreeHandles = 0;
	descriptorTableBitMask = 0;
	staleDescriptorTableBitMask = 0;

	// Reset the table cache.
	for (int i = 0; i < maxDescriptorTables; ++i)
	{
		descriptorTableCache[i].reset();
	}
}

com<ID3D12DescriptorHeap> dx_dynamic_descriptor_heap::requestDescriptorHeap()
{
	com<ID3D12DescriptorHeap> descriptorHeap;
	if (freeDescriptorHeaps.size() > 0)
	{
		descriptorHeap = freeDescriptorHeaps.back();
		freeDescriptorHeaps.pop_back();
	}
	else
	{
		descriptorHeap = createDescriptorHeap();
		descriptorHeapPool.push_back(descriptorHeap);
	}

	return descriptorHeap;
}

com<ID3D12DescriptorHeap> dx_dynamic_descriptor_heap::createDescriptorHeap()
{
	D3D12_DESCRIPTOR_HEAP_DESC descriptorHeapDesc = {};
	descriptorHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
	descriptorHeapDesc.NumDescriptors = numDescriptorsPerHeap;
	descriptorHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;

	com<ID3D12DescriptorHeap> descriptorHeap;
	checkResult(dxContext.device->CreateDescriptorHeap(&descriptorHeapDesc, IID_PPV_ARGS(&descriptorHeap)));

	return descriptorHeap;
}

uint32 dx_dynamic_descriptor_heap::computeStaleDescriptorCount() const
{
	uint32 numStaleDescriptors = 0;
	DWORD i;
	DWORD staleDescriptorsBitMask = staleDescriptorTableBitMask;

	while (_BitScanForward(&i, staleDescriptorsBitMask))
	{
		numStaleDescriptors += descriptorTableCache[i].numDescriptors;
		unsetBit(staleDescriptorsBitMask, i);
	}

	return numStaleDescriptors;
}

```

`src/dx/dx_dynamic_descriptor_heap.h`:

```h
#pragma once

#include "dx.h"
#include "dx_descriptor.h"

#include <deque>


struct dx_command_list;
struct dx_root_signature;


struct dx_dynamic_descriptor_heap
{
public:
	void initialize(uint32 numDescriptorsPerHeap = 1024);

	void stageDescriptors(uint32 rootParameterIndex, uint32 offset, uint32 numDescriptors, dx_cpu_descriptor_handle srcDescriptor);

	void commitStagedDescriptorsForDraw(dx_command_list* commandList);
	void commitStagedDescriptorsForDispatch(dx_command_list* commandList);

	void setCurrentDescriptorHeap(dx_command_list* commandList);

	void parseRootSignature(const dx_root_signature& rootSignature);

	void reset();

private:
	com<ID3D12DescriptorHeap> requestDescriptorHeap();
	com<ID3D12DescriptorHeap> createDescriptorHeap();

	uint32 computeStaleDescriptorCount() const;

	void commitStagedDescriptors(dx_command_list* commandList, bool graphics);

	static const uint32 maxDescriptorTables = 32;


	struct descriptor_table_cache
	{
		descriptor_table_cache()
			: numDescriptors(0)
			, baseDescriptor(nullptr)
		{}

		// Reset the table cache.
		void reset()
		{
			numDescriptors = 0;
			baseDescriptor = nullptr;
		}

		uint32 numDescriptors;
		D3D12_CPU_DESCRIPTOR_HANDLE* baseDescriptor;
	};

	uint32 numDescriptorsPerHeap;

	std::vector<D3D12_CPU_DESCRIPTOR_HANDLE> descriptorHandleCache;
	descriptor_table_cache descriptorTableCache[maxDescriptorTables];

	// Each bit in the bit mask represents the index in the root signature that contains a descriptor table.
	uint32 descriptorTableBitMask;
	uint32 staleDescriptorTableBitMask;

	std::vector<com<ID3D12DescriptorHeap>> descriptorHeapPool;
	std::vector<com<ID3D12DescriptorHeap>> freeDescriptorHeaps;


	com<ID3D12DescriptorHeap> currentDescriptorHeap;
	dx_gpu_descriptor_handle currentGPUDescriptorHandle;
	dx_cpu_descriptor_handle currentCPUDescriptorHandle;

	uint32 numFreeHandles;
};
```

`src/dx/dx_pipeline.cpp`:

```cpp
#include "pch.h"
#include "dx_pipeline.h"
#include "core/string.h"
#include "core/file_system.h"
#include "core/log.h"

#include <unordered_map>
#include <set>
#include <deque>

static void handlePipelineChanges(const file_system_event& e);
static void loadRootSignature(struct reloadable_root_signature& r);
static void loadPipeline(struct reloadable_pipeline_state& p);

struct shader_file
{
	dx_blob blob;
	std::set<struct reloadable_pipeline_state*> usedByPipelines;

	struct reloadable_root_signature* rootSignature;
};

enum desc_type
{
	desc_type_struct,
	desc_type_stream,
};

union graphics_pipeline_desc
{
	D3D12_GRAPHICS_PIPELINE_STATE_DESC structDesc;
	D3D12_PIPELINE_STATE_STREAM_DESC streamDesc;

	graphics_pipeline_desc() = default;
};

enum pipeline_type
{
	pipeline_type_graphics,
	pipeline_type_compute,
};

struct reloadable_pipeline_state
{
	pipeline_type pipelineType;
	desc_type descriptionType;

	union
	{
		struct
		{
			D3D12_GRAPHICS_PIPELINE_STATE_DESC graphicsDesc;

			D3D12_PIPELINE_STATE_STREAM_DESC streamDesc;
			dx_pipeline_stream_base* stream;

			graphics_pipeline_files graphicsFiles;
		};

		struct
		{
			D3D12_COMPUTE_PIPELINE_STATE_DESC computeDesc;
			const char* computeFile;
		};
	};

	dx_pipeline_state pipeline;
	dx_root_signature* rootSignature;

	D3D12_INPUT_ELEMENT_DESC inputLayout[16];

	reloadable_pipeline_state() {}


	void initialize(const D3D12_GRAPHICS_PIPELINE_STATE_DESC& desc, const graphics_pipeline_files& files, dx_root_signature* rootSignature)
	{
		this->pipelineType = pipeline_type_graphics;
		this->descriptionType = desc_type_struct;
		this->graphicsDesc = desc;
		this->graphicsFiles = files;
		this->rootSignature = rootSignature;

		ASSERT(desc.InputLayout.NumElements <= arraysize(inputLayout));

		memcpy(inputLayout, desc.InputLayout.pInputElementDescs, sizeof(D3D12_INPUT_ELEMENT_DESC) * desc.InputLayout.NumElements);
		this->graphicsDesc.InputLayout.pInputElementDescs = inputLayout;

		if (desc.InputLayout.NumElements == 0)
		{
			this->graphicsDesc.InputLayout.pInputElementDescs = nullptr;
		}
	}

	void initialize(const D3D12_PIPELINE_STATE_STREAM_DESC& desc, dx_pipeline_stream_base* stream, const graphics_pipeline_files& files, dx_root_signature* rootSignature)
	{
		this->pipelineType = pipeline_type_graphics;
		this->descriptionType = desc_type_stream;
		this->streamDesc = desc;
		this->stream = stream;
		this->graphicsFiles = files;
		this->rootSignature = rootSignature;

		// TODO: Handle input layout. For now we expect the user to use one of the globally defined formats.
	}

	void initialize(const char* file, dx_root_signature* rootSignature)
	{
		this->pipelineType = pipeline_type_compute;
		this->computeDesc = {};
		this->computeFile = file;
		this->rootSignature = rootSignature;
	}
};

struct reloadable_root_signature
{
	const char* file;
	dx_root_signature rootSignature;
};


static std::unordered_map<std::string, shader_file> shaderBlobs;
static std::deque<reloadable_pipeline_state> pipelines;
static std::deque<reloadable_root_signature> rootSignaturesFromFiles;
static std::deque<dx_root_signature> userRootSignatures;


static std::vector<reloadable_pipeline_state*> dirtyPipelines;
static std::vector<reloadable_root_signature*> dirtyRootSignatures;
static std::mutex mutex;


static reloadable_root_signature* pushBlob(const char* filename, reloadable_pipeline_state* pipelineIndex, bool isRootSignature = false)
{
	reloadable_root_signature* result = 0;

	if (filename)
	{
		auto it = shaderBlobs.find(filename);
		if (it == shaderBlobs.end())
		{
			// New file.

			std::wstring filepath = SHADER_BIN_DIR + stringToWstring(filename) + L".cso";

			dx_blob blob;
			checkResult(D3DReadFileToBlob(filepath.c_str(), &blob));

			if (isRootSignature)
			{
				rootSignaturesFromFiles.push_back({ filename, nullptr });
				result = &rootSignaturesFromFiles.back();
			}

			mutex.lock();
			shaderBlobs[filename] = { blob, { pipelineIndex }, result };
			mutex.unlock();
		}
		else
		{
			// Already used.

			mutex.lock();
			it->second.usedByPipelines.insert(pipelineIndex);
			mutex.unlock();

			if (isRootSignature)
			{
				if (!it->second.rootSignature)
				{
					rootSignaturesFromFiles.push_back({ filename, nullptr });
					it->second.rootSignature = &rootSignaturesFromFiles.back();
				}

				result = it->second.rootSignature;
			}
		}
	}

	return result;
}

dx_pipeline createReloadablePipeline(const D3D12_GRAPHICS_PIPELINE_STATE_DESC& desc, const graphics_pipeline_files& files,
	dx_root_signature userRootSignature, bool loadImmediately)
{
	auto& state = pipelines.emplace_back();

	pushBlob(files.vs, &state);
	pushBlob(files.ps, &state);
	pushBlob(files.gs, &state);
	pushBlob(files.ds, &state);
	pushBlob(files.hs, &state);

	ASSERT(!files.ms);
	ASSERT(!files.as);

	userRootSignatures.push_back(userRootSignature);
	dx_root_signature* rootSignature = &userRootSignatures.back();
	userRootSignatures.back() = userRootSignature; // Fuck. You.

	state.initialize(desc, files, rootSignature);

	dx_pipeline result = { &state.pipeline, rootSignature };

	if (loadImmediately)
	{
		loadPipeline(state);
	}

	return result;
}

dx_pipeline createReloadablePipeline(const D3D12_GRAPHICS_PIPELINE_STATE_DESC& desc, const graphics_pipeline_files& files, rs_file rootSignatureFile, bool loadImmediately)
{
	auto& state = pipelines.emplace_back();

	reloadable_root_signature* reloadableRS = pushBlob(files.shaders[rootSignatureFile], &state, true);
	pushBlob(files.vs, &state);
	pushBlob(files.ps, &state);
	pushBlob(files.gs, &state);
	pushBlob(files.ds, &state);
	pushBlob(files.hs, &state);

	ASSERT(!files.ms);
	ASSERT(!files.as);

	dx_root_signature* rootSignature = &reloadableRS->rootSignature;

	state.initialize(desc, files, rootSignature);

	dx_pipeline result = { &state.pipeline, rootSignature };

	if (loadImmediately)
	{
		loadRootSignature(*reloadableRS);
		loadPipeline(state);
	}

	return result;
}

dx_pipeline createReloadablePipeline(const char* csFile, dx_root_signature userRootSignature, bool loadImmediately)
{
	auto& state = pipelines.emplace_back();

	pushBlob(csFile, &state);

	userRootSignatures.push_back(userRootSignature);
	dx_root_signature* rootSignature = &userRootSignatures.back();
	userRootSignatures.back() = userRootSignature; // Fuck. You.

	state.initialize(csFile, rootSignature);

	dx_pipeline result = { &state.pipeline, rootSignature };

	if (loadImmediately)
	{
		loadPipeline(state);
	}

	return result;
}

dx_pipeline createReloadablePipeline(const char* csFile, bool loadImmediately)
{
	auto& state = pipelines.emplace_back();

	reloadable_root_signature* reloadableRS = pushBlob(csFile, &state, true);

	dx_root_signature* rootSignature = &reloadableRS->rootSignature;

	state.initialize(csFile, rootSignature);

	dx_pipeline result = { &state.pipeline, rootSignature };

	if (loadImmediately)
	{
		loadRootSignature(*reloadableRS);
		loadPipeline(state);
	}

	return result;
}

dx_pipeline createReloadablePipeline(const D3D12_PIPELINE_STATE_STREAM_DESC& desc, dx_pipeline_stream_base* stream, const graphics_pipeline_files& files, 
	dx_root_signature userRootSignature, bool loadImmediately)
{
	auto& state = pipelines.emplace_back();

	pushBlob(files.vs, &state);
	pushBlob(files.ps, &state);
	pushBlob(files.gs, &state);
	pushBlob(files.ds, &state);
	pushBlob(files.hs, &state);
	pushBlob(files.ms, &state);
	pushBlob(files.as, &state);

	userRootSignatures.push_back(userRootSignature);
	dx_root_signature* rootSignature = &userRootSignatures.back();
	userRootSignatures.back() = userRootSignature; // Fuck. You.

	state.initialize(desc, stream, files, rootSignature);

	dx_pipeline result = { &state.pipeline, rootSignature };

	if (loadImmediately)
	{
		loadPipeline(state);
	}

	return result;
}

dx_pipeline createReloadablePipeline(const D3D12_PIPELINE_STATE_STREAM_DESC& desc, dx_pipeline_stream_base* stream, const graphics_pipeline_files& files, 
	rs_file rootSignatureFile, bool loadImmediately)
{
	pipelines.emplace_back();
	auto& state = pipelines.back();

	reloadable_root_signature* reloadableRS = pushBlob(files.shaders[rootSignatureFile], &state, true);
	pushBlob(files.vs, &state);
	pushBlob(files.ps, &state);
	pushBlob(files.gs, &state);
	pushBlob(files.ds, &state);
	pushBlob(files.hs, &state);
	pushBlob(files.ms, &state);
	pushBlob(files.as, &state);

	dx_root_signature* rootSignature = &reloadableRS->rootSignature;

	state.initialize(desc, stream, files, rootSignature);

	dx_pipeline result = { &state.pipeline, rootSignature };

	if (loadImmediately)
	{
		loadRootSignature(*reloadableRS);
		loadPipeline(state);
	}

	return result;
}

static void loadRootSignature(reloadable_root_signature& r)
{
	dx_blob rs = shaderBlobs[r.file].blob;

	dxContext.retire(r.rootSignature.rootSignature); 
	freeRootSignature(r.rootSignature);
	r.rootSignature = createRootSignature(rs);
}

static void loadPipeline(reloadable_pipeline_state& p)
{
	dxContext.retire(p.pipeline);

	if (p.pipelineType == pipeline_type_graphics)
	{
		if (p.descriptionType == desc_type_struct)
		{
			if (p.graphicsFiles.vs) { dx_blob shader = shaderBlobs[p.graphicsFiles.vs].blob; p.graphicsDesc.VS = CD3DX12_SHADER_BYTECODE(shader.Get()); }
			if (p.graphicsFiles.ps) { dx_blob shader = shaderBlobs[p.graphicsFiles.ps].blob; p.graphicsDesc.PS = CD3DX12_SHADER_BYTECODE(shader.Get()); }
			if (p.graphicsFiles.gs) { dx_blob shader = shaderBlobs[p.graphicsFiles.gs].blob; p.graphicsDesc.GS = CD3DX12_SHADER_BYTECODE(shader.Get()); }
			if (p.graphicsFiles.ds) { dx_blob shader = shaderBlobs[p.graphicsFiles.ds].blob; p.graphicsDesc.DS = CD3DX12_SHADER_BYTECODE(shader.Get()); }
			if (p.graphicsFiles.hs) { dx_blob shader = shaderBlobs[p.graphicsFiles.hs].blob; p.graphicsDesc.HS = CD3DX12_SHADER_BYTECODE(shader.Get()); }

			p.graphicsDesc.pRootSignature = p.rootSignature->rootSignature.Get();
			checkResult(dxContext.device->CreateGraphicsPipelineState(&p.graphicsDesc, IID_PPV_ARGS(&p.pipeline)));
		}
		else
		{
			if (p.graphicsFiles.vs) { dx_blob shader = shaderBlobs[p.graphicsFiles.vs].blob; p.stream->setVertexShader(shader); }
			if (p.graphicsFiles.ps) { dx_blob shader = shaderBlobs[p.graphicsFiles.ps].blob; p.stream->setPixelShader(shader); }
			if (p.graphicsFiles.gs) { dx_blob shader = shaderBlobs[p.graphicsFiles.gs].blob; p.stream->setGeometryShader(shader); }
			if (p.graphicsFiles.ds) { dx_blob shader = shaderBlobs[p.graphicsFiles.ds].blob; p.stream->setDomainShader(shader); }
			if (p.graphicsFiles.hs) { dx_blob shader = shaderBlobs[p.graphicsFiles.hs].blob; p.stream->setHullShader(shader); }
			if (p.graphicsFiles.ms) { dx_blob shader = shaderBlobs[p.graphicsFiles.ms].blob; p.stream->setMeshShader(shader); }
			if (p.graphicsFiles.as) { dx_blob shader = shaderBlobs[p.graphicsFiles.as].blob; p.stream->setAmplificationShader(shader); }

			p.stream->setRootSignature(*p.rootSignature);
			checkResult(dxContext.device->CreatePipelineState(&p.streamDesc, IID_PPV_ARGS(&p.pipeline)));
		}
	}
	else
	{
		dx_blob shader = shaderBlobs[p.computeFile].blob; p.computeDesc.CS = CD3DX12_SHADER_BYTECODE(shader.Get());

		p.computeDesc.pRootSignature = p.rootSignature->rootSignature.Get();
		checkResult(dxContext.device->CreateComputePipelineState(&p.computeDesc, IID_PPV_ARGS(&p.pipeline)));
	}
}

void createAllPendingReloadablePipelines()
{
	for (uint32 i = 0; i < (uint32)rootSignaturesFromFiles.size(); ++i)
	{
		if (!rootSignaturesFromFiles[i].rootSignature.rootSignature)
		{
			loadRootSignature(rootSignaturesFromFiles[i]);
		}
	}

	for (uint32 i = 0; i < (uint32)pipelines.size(); ++i)
	{
		if (!pipelines[i].pipeline)
		{
			loadPipeline(pipelines[i]);
		}
	}

	//static HANDLE thread = CreateThread(0, 0, checkForFileChanges, 0, 0, 0); // Static, so that we only do this once.
	static bool observing = observeDirectory(SHADER_BIN_DIR, handlePipelineChanges); // Static, so that we only do this once.
}

static bool fileIsLocked(const wchar* filename)
{
	HANDLE fileHandle = CreateFileW(filename, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (fileHandle == INVALID_HANDLE_VALUE)
	{
		return true;
	}
	CloseHandle(fileHandle);
	return false;
}

static void handlePipelineChanges(const file_system_event& e)
{
	if (e.change == file_system_change_modify)
	{
		bool isFile = !fs::is_directory(e.path);

		if (isFile)
		{
			mutex.lock();
			auto it = shaderBlobs.find(e.path.stem().string());
			if (it != shaderBlobs.end())
			{
				mutex.unlock();
				auto wPath = e.path.wstring();
				while (fileIsLocked(wPath.c_str()))
				{
					// Wait.
				}

				uint32 numDirtyPipelines = (uint32)it->second.usedByPipelines.size();
				LOG_MESSAGE("Reloading shader blob '%ws'. Updating %u pipeline%s.", e.path.stem().c_str(), numDirtyPipelines, (numDirtyPipelines > 1 ? "s" : ""));

				dx_blob blob;
				checkResult(D3DReadFileToBlob(e.path.c_str(), &blob));

				mutex.lock();
				it->second.blob = blob;
				dirtyPipelines.insert(dirtyPipelines.end(), it->second.usedByPipelines.begin(), it->second.usedByPipelines.end());
				if (it->second.rootSignature)
				{
					dirtyRootSignatures.push_back(it->second.rootSignature);
				}
				mutex.unlock();
			}
			else
			{
				mutex.unlock();
			}
		}
	}
}

void checkForChangedPipelines()
{
	mutex.lock();

	for (uint32 i = 0; i < (uint32)dirtyRootSignatures.size(); ++i)
	{
		loadRootSignature(*dirtyRootSignatures[i]);
	}

	for (uint32 i = 0; i < (uint32)dirtyPipelines.size(); ++i)
	{
		loadPipeline(*dirtyPipelines[i]);
	}

	dirtyRootSignatures.clear();
	dirtyPipelines.clear();
	mutex.unlock();
}

static void copyRootSignatureDesc(const D3D12_ROOT_SIGNATURE_DESC* desc, dx_root_signature& result)
{
	result.totalNumParameters = desc->NumParameters;

	uint32 numDescriptorTables = 0;
	for (uint32 i = 0; i < desc->NumParameters; ++i)
	{
		if (desc->pParameters[i].ParameterType == D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE)
		{
			++numDescriptorTables;
			setBit(result.tableRootParameterMask, i);
		}
	}

	result.descriptorTableSizes = new uint32[numDescriptorTables];
	result.numDescriptorTables = numDescriptorTables;

	uint32 index = 0;
	for (uint32 i = 0; i < desc->NumParameters; ++i)
	{
		if (desc->pParameters[i].ParameterType == D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE)
		{
			uint32 numRanges = desc->pParameters[i].DescriptorTable.NumDescriptorRanges;
			result.descriptorTableSizes[index] = 0;
			for (uint32 r = 0; r < numRanges; ++r)
			{
				result.descriptorTableSizes[index] += desc->pParameters[i].DescriptorTable.pDescriptorRanges[r].NumDescriptors;
			}
			++index;
		}
	}
}

static void copyRootSignatureDesc(const D3D12_ROOT_SIGNATURE_DESC1* desc, dx_root_signature& result)
{
	result.totalNumParameters = desc->NumParameters;

	uint32 numDescriptorTables = 0;
	for (uint32 i = 0; i < desc->NumParameters; ++i)
	{
		if (desc->pParameters[i].ParameterType == D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE)
		{
			++numDescriptorTables;
			setBit(result.tableRootParameterMask, i);
		}
	}

	result.descriptorTableSizes = new uint32[numDescriptorTables];
	result.numDescriptorTables = numDescriptorTables;

	uint32 index = 0;
	for (uint32 i = 0; i < desc->NumParameters; ++i)
	{
		if (desc->pParameters[i].ParameterType == D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE)
		{
			uint32 numRanges = desc->pParameters[i].DescriptorTable.NumDescriptorRanges;
			result.descriptorTableSizes[index] = 0;
			for (uint32 r = 0; r < numRanges; ++r)
			{
				result.descriptorTableSizes[index] += desc->pParameters[i].DescriptorTable.pDescriptorRanges[r].NumDescriptors;
			}
			++index;
		}
	}
}

dx_root_signature createRootSignature(dx_blob rootSignatureBlob)
{
	dx_root_signature result = {};

	checkResult(dxContext.device->CreateRootSignature(0, rootSignatureBlob->GetBufferPointer(),
		rootSignatureBlob->GetBufferSize(), IID_PPV_ARGS(&result.rootSignature)));

	com<ID3D12RootSignatureDeserializer> deserializer;
	checkResult(D3D12CreateRootSignatureDeserializer(rootSignatureBlob->GetBufferPointer(), rootSignatureBlob->GetBufferSize(), IID_PPV_ARGS(&deserializer)));
	D3D12_ROOT_SIGNATURE_DESC* desc = (D3D12_ROOT_SIGNATURE_DESC*)deserializer->GetRootSignatureDesc();

	copyRootSignatureDesc(desc, result);

	return result;
}

dx_root_signature createRootSignature(const wchar* path)
{
	dx_blob rootSignatureBlob;
	checkResult(D3DReadFileToBlob(path, &rootSignatureBlob));
	return createRootSignature(rootSignatureBlob);
}

dx_root_signature createRootSignature(const D3D12_ROOT_SIGNATURE_DESC1& desc)
{
	D3D12_FEATURE_DATA_ROOT_SIGNATURE featureData = {};
	featureData.HighestVersion = D3D_ROOT_SIGNATURE_VERSION_1_1;
	if (FAILED(dxContext.device->CheckFeatureSupport(D3D12_FEATURE_ROOT_SIGNATURE, &featureData, sizeof(featureData))))
	{
		featureData.HighestVersion = D3D_ROOT_SIGNATURE_VERSION_1_0;
	}

	CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC rootSignatureDescription;
	rootSignatureDescription.Init_1_1(desc.NumParameters, desc.pParameters, desc.NumStaticSamplers, desc.pStaticSamplers, desc.Flags);

	dx_blob rootSignatureBlob;
	dx_blob errorBlob;
	checkResult(D3DX12SerializeVersionedRootSignature(&rootSignatureDescription, featureData.HighestVersion, &rootSignatureBlob, &errorBlob));

	dx_root_signature rootSignature = {};

	checkResult(dxContext.device->CreateRootSignature(0, rootSignatureBlob->GetBufferPointer(),
		rootSignatureBlob->GetBufferSize(), IID_PPV_ARGS(&rootSignature.rootSignature)));

	copyRootSignatureDesc(&desc, rootSignature);

	return rootSignature;
}

dx_root_signature createRootSignature(CD3DX12_ROOT_PARAMETER1* rootParameters, uint32 numRootParameters, CD3DX12_STATIC_SAMPLER_DESC* samplers, uint32 numSamplers,
	D3D12_ROOT_SIGNATURE_FLAGS flags)
{
	D3D12_ROOT_SIGNATURE_DESC1 rootSignatureDesc = {};
	rootSignatureDesc.Flags = flags;
	rootSignatureDesc.pParameters = rootParameters;
	rootSignatureDesc.NumParameters = numRootParameters;
	rootSignatureDesc.pStaticSamplers = samplers;
	rootSignatureDesc.NumStaticSamplers = numSamplers;
	return createRootSignature(rootSignatureDesc);
}

dx_root_signature createRootSignature(const D3D12_ROOT_SIGNATURE_DESC& desc)
{
	dx_blob rootSignatureBlob;
	dx_blob errorBlob;
	checkResult(D3D12SerializeRootSignature(&desc, D3D_ROOT_SIGNATURE_VERSION_1, &rootSignatureBlob, &errorBlob));

	dx_root_signature rootSignature = {};

	checkResult(dxContext.device->CreateRootSignature(0, rootSignatureBlob->GetBufferPointer(),
		rootSignatureBlob->GetBufferSize(), IID_PPV_ARGS(&rootSignature.rootSignature)));

	copyRootSignatureDesc(&desc, rootSignature);

	return rootSignature;
}

dx_root_signature createRootSignature(CD3DX12_ROOT_PARAMETER* rootParameters, uint32 numRootParameters, CD3DX12_STATIC_SAMPLER_DESC* samplers, uint32 numSamplers,
	D3D12_ROOT_SIGNATURE_FLAGS flags)
{
	D3D12_ROOT_SIGNATURE_DESC rootSignatureDesc = {};
	rootSignatureDesc.Flags = flags;
	rootSignatureDesc.pParameters = rootParameters;
	rootSignatureDesc.NumParameters = numRootParameters;
	rootSignatureDesc.pStaticSamplers = samplers;
	rootSignatureDesc.NumStaticSamplers = numSamplers;
	return createRootSignature(rootSignatureDesc);
}

dx_root_signature createRootSignature(D3D12_ROOT_SIGNATURE_FLAGS flags)
{
	D3D12_ROOT_SIGNATURE_DESC rootSignatureDesc = {};
	rootSignatureDesc.Flags = flags;
	return createRootSignature(rootSignatureDesc);
}

void freeRootSignature(dx_root_signature& rs)
{
	if (rs.descriptorTableSizes)
	{
		delete[] rs.descriptorTableSizes;
	}
}

dx_command_signature createCommandSignature(dx_root_signature rootSignature, const D3D12_COMMAND_SIGNATURE_DESC& commandSignatureDesc)
{
	dx_command_signature commandSignature;
	checkResult(dxContext.device->CreateCommandSignature(&commandSignatureDesc,
		commandSignatureDesc.NumArgumentDescs == 1 ? 0 : rootSignature.rootSignature.Get(),
		IID_PPV_ARGS(&commandSignature)));
	return commandSignature;
}

dx_command_signature createCommandSignature(dx_root_signature rootSignature, D3D12_INDIRECT_ARGUMENT_DESC* argumentDescs, uint32 numArgumentDescs, uint32 commandStructureSize)
{
	D3D12_COMMAND_SIGNATURE_DESC commandSignatureDesc;
	commandSignatureDesc.pArgumentDescs = argumentDescs;
	commandSignatureDesc.NumArgumentDescs = numArgumentDescs;
	commandSignatureDesc.ByteStride = commandStructureSize;
	commandSignatureDesc.NodeMask = 0;

	return createCommandSignature(rootSignature, commandSignatureDesc);
}



```

`src/dx/dx_pipeline.h`:

```h
#pragma once

#include "dx.h"
#include "dx_context.h"

#define CREATE_GRAPHICS_PIPELINE dx_graphics_pipeline_generator()

#define UNBOUNDED_DESCRIPTOR_RANGE -1




struct dx_root_signature
{
	com<ID3D12RootSignature> rootSignature;
	uint32* descriptorTableSizes;
	uint32 numDescriptorTables;
	uint32 tableRootParameterMask;
	uint32 totalNumParameters;
};

dx_root_signature createRootSignature(dx_blob rootSignatureBlob);
dx_root_signature createRootSignature(const wchar* path);
dx_root_signature createRootSignature(const D3D12_ROOT_SIGNATURE_DESC1& desc);
dx_root_signature createRootSignature(CD3DX12_ROOT_PARAMETER1* rootParameters, uint32 numRootParameters, CD3DX12_STATIC_SAMPLER_DESC* samplers, uint32 numSamplers,
	D3D12_ROOT_SIGNATURE_FLAGS flags);
dx_root_signature createRootSignature(const D3D12_ROOT_SIGNATURE_DESC& desc);
dx_root_signature createRootSignature(CD3DX12_ROOT_PARAMETER* rootParameters, uint32 numRootParameters, CD3DX12_STATIC_SAMPLER_DESC* samplers, uint32 numSamplers,
	D3D12_ROOT_SIGNATURE_FLAGS flags);
dx_command_signature createCommandSignature(dx_root_signature rootSignature, const D3D12_COMMAND_SIGNATURE_DESC& commandSignatureDesc);
dx_root_signature createRootSignature(D3D12_ROOT_SIGNATURE_FLAGS flags);
void freeRootSignature(dx_root_signature& rs);

dx_command_signature createCommandSignature(dx_root_signature rootSignature, D3D12_INDIRECT_ARGUMENT_DESC* argumentDescs, uint32 numArgumentDescs, uint32 commandStructureSize);





struct dx_graphics_pipeline_generator
{
	D3D12_GRAPHICS_PIPELINE_STATE_DESC desc;

	operator const D3D12_GRAPHICS_PIPELINE_STATE_DESC& () const
	{
		return desc;
	}

	dx_graphics_pipeline_generator()
	{
		desc = {};
		desc.BlendState = CD3DX12_BLEND_DESC(D3D12_DEFAULT);
		desc.RasterizerState = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT);
		desc.RasterizerState.FrontCounterClockwise = true;
		desc.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC(D3D12_DEFAULT);
		desc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
		desc.SampleDesc = { 1, 0 };
		desc.SampleMask = 0xFFFFFFFF;
	}

	dx_graphics_pipeline_generator& rootSignature(const dx_root_signature& rootSignature)
	{
		desc.pRootSignature = rootSignature.rootSignature.Get();
		return *this;
	}

	dx_graphics_pipeline_generator& vs(dx_blob shader)
	{
		desc.VS = CD3DX12_SHADER_BYTECODE(shader.Get());
		return *this;
	}

	dx_graphics_pipeline_generator& ps(dx_blob shader)
	{
		desc.PS = CD3DX12_SHADER_BYTECODE(shader.Get());
		return *this;
	}

	dx_graphics_pipeline_generator& gs(dx_blob shader)
	{
		desc.GS = CD3DX12_SHADER_BYTECODE(shader.Get());
		return *this;
	}

	dx_graphics_pipeline_generator& ds(dx_blob shader)
	{
		desc.DS = CD3DX12_SHADER_BYTECODE(shader.Get());
		return *this;
	}

	dx_graphics_pipeline_generator& hs(dx_blob shader)
	{
		desc.HS = CD3DX12_SHADER_BYTECODE(shader.Get());
		return *this;
	}

	dx_graphics_pipeline_generator& alphaToCoverage(bool enable)
	{
		desc.BlendState.AlphaToCoverageEnable = enable;
		return *this;
	}

	dx_graphics_pipeline_generator& independentRenderTargetBlending(bool enable)
	{
		desc.BlendState.IndependentBlendEnable = enable;
		return *this;
	}

	dx_graphics_pipeline_generator& blendState(uint32 renderTargetIndex, D3D12_BLEND srcBlend, D3D12_BLEND destBlend, D3D12_BLEND_OP op)
	{
		ASSERT(!desc.BlendState.RenderTarget[renderTargetIndex].LogicOpEnable);
		desc.BlendState.RenderTarget[renderTargetIndex].BlendEnable = true;
		desc.BlendState.RenderTarget[renderTargetIndex].SrcBlend = srcBlend;
		desc.BlendState.RenderTarget[renderTargetIndex].DestBlend = destBlend;
		desc.BlendState.RenderTarget[renderTargetIndex].BlendOp = op;
		return *this;
	}

	dx_graphics_pipeline_generator& alphaBlending(uint32 renderTargetIndex)
	{
		return blendState(renderTargetIndex, D3D12_BLEND_SRC_ALPHA, D3D12_BLEND_INV_SRC_ALPHA, D3D12_BLEND_OP_ADD);
	}

	dx_graphics_pipeline_generator& additiveBlending(uint32 renderTargetIndex)
	{
		return blendState(renderTargetIndex, D3D12_BLEND_ONE, D3D12_BLEND_ONE, D3D12_BLEND_OP_ADD);
	}

	dx_graphics_pipeline_generator& wireframe()
	{
		desc.RasterizerState.FillMode = D3D12_FILL_MODE_WIREFRAME;
		return *this;
	}

	dx_graphics_pipeline_generator& cullFrontFaces()
	{
		desc.RasterizerState.CullMode = D3D12_CULL_MODE_FRONT;
		return *this;
	}

	dx_graphics_pipeline_generator& cullingOff()
	{
		desc.RasterizerState.CullMode = D3D12_CULL_MODE_NONE;
		return *this;
	}

	dx_graphics_pipeline_generator& rasterizeClockwise()
	{
		desc.RasterizerState.FrontCounterClockwise = false;
		return *this;
	}

	dx_graphics_pipeline_generator& depthBias(int bias = D3D12_DEFAULT_DEPTH_BIAS, float biasClamp = D3D12_DEFAULT_DEPTH_BIAS_CLAMP, float slopeScaledBias = D3D12_DEFAULT_SLOPE_SCALED_DEPTH_BIAS)
	{
		desc.RasterizerState.DepthBias = bias;
		desc.RasterizerState.DepthBiasClamp = biasClamp;
		desc.RasterizerState.SlopeScaledDepthBias = slopeScaledBias;
		return *this;
	}

	dx_graphics_pipeline_generator& antialiasing(bool multisampling = false, bool antialiasedlines = false, uint32 forcedSampleCount = 0)
	{
		desc.RasterizerState.MultisampleEnable = multisampling;
		desc.RasterizerState.AntialiasedLineEnable = antialiasedlines;
		desc.RasterizerState.ForcedSampleCount = forcedSampleCount;
		return *this;
	}

	dx_graphics_pipeline_generator& rasterizeConvervative()
	{
		desc.RasterizerState.ConservativeRaster = D3D12_CONSERVATIVE_RASTERIZATION_MODE_ON;
		return *this;
	}

	dx_graphics_pipeline_generator& depthSettings(bool depthTest = true, bool depthWrite = true, D3D12_COMPARISON_FUNC func = D3D12_COMPARISON_FUNC_LESS)
	{
		desc.DepthStencilState.DepthEnable = depthTest;
		desc.DepthStencilState.DepthWriteMask = depthWrite ? D3D12_DEPTH_WRITE_MASK_ALL : D3D12_DEPTH_WRITE_MASK_ZERO;
		desc.DepthStencilState.DepthFunc = func;
		return *this;
	}

	dx_graphics_pipeline_generator& stencilSettings(
		D3D12_COMPARISON_FUNC func = D3D12_COMPARISON_FUNC_ALWAYS,
		D3D12_STENCIL_OP onPass = D3D12_STENCIL_OP_KEEP, 
		D3D12_STENCIL_OP onStencilPassAndDepthFail = D3D12_STENCIL_OP_KEEP, 
		D3D12_STENCIL_OP onFail = D3D12_STENCIL_OP_KEEP, 
		uint8 readMask = D3D12_DEFAULT_STENCIL_READ_MASK, uint8 writeMask = D3D12_DEFAULT_STENCIL_WRITE_MASK)
	{
		desc.DepthStencilState.StencilEnable = true;
		desc.DepthStencilState.StencilReadMask = readMask;
		desc.DepthStencilState.StencilWriteMask = writeMask;

		desc.DepthStencilState.FrontFace.StencilFailOp = onFail;
		desc.DepthStencilState.FrontFace.StencilDepthFailOp = onStencilPassAndDepthFail;
		desc.DepthStencilState.FrontFace.StencilPassOp = onPass;
		desc.DepthStencilState.FrontFace.StencilFunc = func;

		desc.DepthStencilState.BackFace.StencilFailOp = onFail;
		desc.DepthStencilState.BackFace.StencilDepthFailOp = onStencilPassAndDepthFail;
		desc.DepthStencilState.BackFace.StencilPassOp = onPass;
		desc.DepthStencilState.BackFace.StencilFunc = func;
		return *this;
	}

	template <uint32 numElements>
	dx_graphics_pipeline_generator& inputLayout(D3D12_INPUT_ELEMENT_DESC (&elements)[numElements])
	{
		desc.InputLayout = { elements, numElements };
		return *this;
	}

	dx_graphics_pipeline_generator& inputLayout(D3D12_INPUT_ELEMENT_DESC* elements, uint32 numElements)
	{
		desc.InputLayout = { elements, numElements };
		return *this;
	}

	dx_graphics_pipeline_generator& primitiveTopology(D3D12_PRIMITIVE_TOPOLOGY_TYPE type)
	{
		desc.PrimitiveTopologyType = type;
		return *this;
	}

	dx_graphics_pipeline_generator& renderTargets(DXGI_FORMAT rtFormat, DXGI_FORMAT dsvFormat = DXGI_FORMAT_UNKNOWN)
	{
		return renderTargets(&rtFormat, 1, dsvFormat);
	}

	dx_graphics_pipeline_generator& renderTargets(const DXGI_FORMAT* rtFormats, uint32 numRenderTargets, DXGI_FORMAT dsvFormat = DXGI_FORMAT_UNKNOWN)
	{
		memcpy(desc.RTVFormats, rtFormats, sizeof(DXGI_FORMAT) * numRenderTargets);
		desc.NumRenderTargets = numRenderTargets;
		desc.DSVFormat = dsvFormat;
		return *this;
	}

	dx_graphics_pipeline_generator& renderTargets(const D3D12_RT_FORMAT_ARRAY& rtFormats, DXGI_FORMAT dsvFormat = DXGI_FORMAT_UNKNOWN)
	{
		return renderTargets(rtFormats.RTFormats, rtFormats.NumRenderTargets, dsvFormat);
	}

	dx_graphics_pipeline_generator& multisampling(uint32 count = 1, uint32 quality = 0)
	{
		desc.SampleDesc = { count, quality };
		return *this;
	}
};



struct root_descriptor_table : CD3DX12_ROOT_PARAMETER
{
	root_descriptor_table(uint32 numDescriptorRanges,
		const D3D12_DESCRIPTOR_RANGE* descriptorRanges,
		D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL)
	{
		InitAsDescriptorTable(numDescriptorRanges, descriptorRanges, visibility);
	}
};

template <typename T>
struct root_constants : CD3DX12_ROOT_PARAMETER
{
	root_constants(uint32 shaderRegister,
		uint32 space = 0,
		D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL)
	{
		InitAsConstants(sizeof(T) / 4, shaderRegister, space, visibility);
	}
};

struct root_cbv : CD3DX12_ROOT_PARAMETER
{
	root_cbv(uint32 shaderRegister,
		uint32 space = 0,
		D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL)
	{
		InitAsConstantBufferView(shaderRegister, space, visibility);
	}
};

struct root_srv : CD3DX12_ROOT_PARAMETER
{
	root_srv(uint32 shaderRegister,
		uint32 space = 0,
		D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL)
	{
		InitAsShaderResourceView(shaderRegister, space, visibility);
	}
};

struct root_uav : CD3DX12_ROOT_PARAMETER
{
	root_uav(uint32 shaderRegister,
		uint32 space = 0,
		D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL)
	{
		InitAsUnorderedAccessView(shaderRegister, space, visibility);
	}
};




struct indirect_vertex_buffer : D3D12_INDIRECT_ARGUMENT_DESC
{
	indirect_vertex_buffer(uint32 slot)
	{
		Type = D3D12_INDIRECT_ARGUMENT_TYPE_VERTEX_BUFFER_VIEW;
		VertexBuffer.Slot = slot;
	}
};

struct indirect_index_buffer : D3D12_INDIRECT_ARGUMENT_DESC
{
	indirect_index_buffer()
	{
		Type = D3D12_INDIRECT_ARGUMENT_TYPE_INDEX_BUFFER_VIEW;
	}
};

template <typename T>
struct indirect_root_constants : D3D12_INDIRECT_ARGUMENT_DESC
{
	indirect_root_constants(uint32 rootParameterIndex, uint32 destOffsetIn32BitValues = 0)
	{
		Type = D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT;
		Constant.Num32BitValuesToSet = sizeof(T) / 4;
		Constant.RootParameterIndex = rootParameterIndex;
		Constant.DestOffsetIn32BitValues = destOffsetIn32BitValues;
	}
};

struct indirect_cbv : D3D12_INDIRECT_ARGUMENT_DESC
{
	indirect_cbv(uint32 rootParameterIndex)
	{
		Type = D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT_BUFFER_VIEW;
		ConstantBufferView.RootParameterIndex = rootParameterIndex;
	}
};

struct indirect_srv : D3D12_INDIRECT_ARGUMENT_DESC
{
	indirect_srv(uint32 rootParameterIndex)
	{
		Type = D3D12_INDIRECT_ARGUMENT_TYPE_SHADER_RESOURCE_VIEW;
		ConstantBufferView.RootParameterIndex = rootParameterIndex;
	}
};

struct indirect_uav : D3D12_INDIRECT_ARGUMENT_DESC
{
	indirect_uav(uint32 rootParameterIndex)
	{
		Type = D3D12_INDIRECT_ARGUMENT_TYPE_UNORDERED_ACCESS_VIEW;
		ConstantBufferView.RootParameterIndex = rootParameterIndex;
	}
};

struct indirect_draw : D3D12_INDIRECT_ARGUMENT_DESC
{
	indirect_draw()
	{
		Type = D3D12_INDIRECT_ARGUMENT_TYPE_DRAW;
	}
};

struct indirect_draw_indexed : D3D12_INDIRECT_ARGUMENT_DESC
{
	indirect_draw_indexed()
	{
		Type = D3D12_INDIRECT_ARGUMENT_TYPE_DRAW_INDEXED;
	}
};

struct indirect_dispatch : D3D12_INDIRECT_ARGUMENT_DESC
{
	indirect_dispatch()
	{
		Type = D3D12_INDIRECT_ARGUMENT_TYPE_DISPATCH;
	}
};

struct dx_pipeline_stream_base
{
	virtual void setVertexShader(dx_blob blob) {}
	virtual void setPixelShader(dx_blob blob) {}
	virtual void setDomainShader(dx_blob blob) {}
	virtual void setHullShader(dx_blob blob) {}
	virtual void setGeometryShader(dx_blob blob) {}
	virtual void setMeshShader(dx_blob blob) {}
	virtual void setAmplificationShader(dx_blob blob) {}

	virtual void setRootSignature(dx_root_signature rs) = 0;
};


struct dx_pipeline
{
	dx_pipeline_state* pipeline;
	dx_root_signature* rootSignature;
};

union graphics_pipeline_files
{
	struct
	{
		const char* vs;
		const char* ps;
		const char* ds;
		const char* hs;
		const char* gs;
		const char* ms;
		const char* as;
	};
	const char* shaders[7] = {};
};

enum rs_file
{
	rs_in_vertex_shader,
	rs_in_pixel_shader,
	rs_in_domain_shader,
	rs_in_hull_shader,
	rs_in_geometry_shader,
	rs_in_mesh_shader,
	rs_in_amplification_shader,
};

dx_pipeline createReloadablePipeline(const D3D12_GRAPHICS_PIPELINE_STATE_DESC& desc, const graphics_pipeline_files& files, dx_root_signature userRootSignature, bool loadImmediately = false);
dx_pipeline createReloadablePipeline(const D3D12_GRAPHICS_PIPELINE_STATE_DESC& desc, const graphics_pipeline_files& files, rs_file rootSignatureFile = rs_in_pixel_shader, bool loadImmediately = false);

dx_pipeline createReloadablePipeline(const char* csFile, dx_root_signature userRootSignature, bool loadImmediately = false);
dx_pipeline createReloadablePipeline(const char* csFile, bool loadImmediately = false);


template <typename stream_t>
inline dx_pipeline createReloadablePipelineFromStream(const stream_t& stream, const graphics_pipeline_files& files, dx_root_signature userRootSignature)
{
	static_assert(std::is_base_of_v<dx_pipeline_stream_base, stream_t>, "Stream must inherit from dx_pipeline_stream_base.");

	stream_t* streamCopy = new stream_t(stream); // Dynamically allocated for permanent storage.
	D3D12_PIPELINE_STATE_STREAM_DESC desc = {
		sizeof(stream_t) - 8, (uint8*)streamCopy + 8 // Offset for vTable. This seems very broken. TODO: Verify that this always works.
	};

	dx_pipeline createReloadablePipeline(const D3D12_PIPELINE_STATE_STREAM_DESC& desc, dx_pipeline_stream_base* stream, const graphics_pipeline_files& files, dx_root_signature userRootSignature, bool loadImmediately);
	return createReloadablePipeline(desc, streamCopy, files, userRootSignature, false);
}

template <typename stream_t>
inline dx_pipeline createReloadablePipelineFromStream(const stream_t& stream, const graphics_pipeline_files& files, rs_file rootSignatureFile = rs_in_pixel_shader)
{
	static_assert(std::is_base_of_v<dx_pipeline_stream_base, stream_t>, "Stream must inherit from dx_pipeline_stream_base.");

	stream_t* streamCopy = new stream_t(stream); // Dynamically allocated for permanent storage.
	D3D12_PIPELINE_STATE_STREAM_DESC desc = {
		sizeof(stream_t) - 8, (uint8*)streamCopy + 8 // Offset for vTable. This seems very broken. TODO: Verify that this always works.
	};

	dx_pipeline createReloadablePipeline(const D3D12_PIPELINE_STATE_STREAM_DESC& desc, dx_pipeline_stream_base* stream, const graphics_pipeline_files& files, rs_file rootSignatureFile, bool loadImmediately);
	return createReloadablePipeline(desc, streamCopy, files, rootSignatureFile, false);
}

void createAllPendingReloadablePipelines();

void checkForChangedPipelines();


```

`src/dx/dx_profiling.cpp`:

```cpp
#include "pch.h"
#define PROFILING_INTERNAL
#include "dx_profiling.h"
#include "core/imgui.h"
#include "core/math.h"


bool dxProfilerWindowOpen = false;

#if ENABLE_DX_PROFILING

#include <algorithm>
#include <fontawesome/IconsFontAwesome5.h>

profile_event dxProfileEvents[NUM_BUFFERED_FRAMES][MAX_NUM_DX_PROFILE_EVENTS];

#define MAX_NUM_DX_PROFILE_FRAMES 1024

struct dx_profile_frame : profile_frame
{
	profile_block blocks[profile_cl_count][MAX_NUM_DX_PROFILE_BLOCKS];
	uint32 count[profile_cl_count];
};

static dx_profile_frame profileFrames[MAX_NUM_DX_PROFILE_FRAMES];
static uint32 profileFrameWriteIndex;
static bool pauseRecording;

void dxProfilingFrameEndMarker(dx_command_list* cl)
{
	ASSERT(cl->type == D3D12_COMMAND_LIST_TYPE_DIRECT);

	uint32 queryIndex = atomicIncrement(dxContext.timestampQueryIndex[dxContext.bufferedFrameID]);
	cl->queryTimestamp(queryIndex);

	dxProfileEvents[dxContext.bufferedFrameID][queryIndex] = 
	{ 
		profile_event_frame_marker,
		profile_cl_graphics,
		getThreadIDFast(),
		"Frame End" };
}

void dxProfilingResolveTimeStamps(uint64* timestamps)
{
	uint32 currentFrame = profileFrameWriteIndex;

	if (!pauseRecording)
	{
		uint32 numQueries = dxContext.timestampQueryIndex[dxContext.bufferedFrameID];
		if (numQueries == 0)
		{
			return;
		}

		profile_event* events = dxProfileEvents[dxContext.bufferedFrameID];
		for (uint32 i = 0; i < numQueries; ++i)
		{
			events[i].timestamp = timestamps[i];
		}

		// Stable sort is important here, since occasionally two time stamps will have the exact same value.
		std::stable_sort(events, events + numQueries, [](const profile_event& a, const profile_event& b)
		{
			return a.timestamp < b.timestamp;
		});


		uint16 stack[profile_cl_count][1024];
		uint32 depth[profile_cl_count] = {};
		uint32 count[profile_cl_count] = {};

		for (uint32 cl = 0; cl < profile_cl_count; ++cl)
		{
			stack[cl][0] = INVALID_PROFILE_BLOCK;
		}


		dx_profile_frame& frame = profileFrames[profileFrameWriteIndex];

		uint64 frequencies[] =
		{
			dxContext.renderQueue.timeStampFrequency,
			dxContext.computeQueue.timeStampFrequency
		};

		for (uint32 i = 0; i < numQueries; ++i)
		{
			profile_event* e = events + i;
			profile_cl_type clType = (profile_cl_type)e->clType;

			uint64 frameEndTimestamp;
			if (handleProfileEvent(events, i, numQueries, stack[clType], depth[clType], frame.blocks[clType], count[clType], frameEndTimestamp, true))
			{
				uint32 previousFrameIndex = (profileFrameWriteIndex == 0) ? (MAX_NUM_DX_PROFILE_FRAMES - 1) : (profileFrameWriteIndex - 1);
				dx_profile_frame& previousFrame = profileFrames[previousFrameIndex];

				frame.startClock = (previousFrame.endClock == 0) ? frameEndTimestamp : previousFrame.endClock;
				frame.endClock = frameEndTimestamp;
				frame.globalFrameID = dxContext.frameID;

				frame.duration = (float)(frame.endClock - frame.startClock) / dxContext.renderQueue.timeStampFrequency * 1000.f;

				for (uint32 cl = 0; cl < profile_cl_count; ++cl)
				{
					frame.count[cl] = count[cl];

					uint64 freq = frequencies[cl];

					for (uint32 i = 0; i < frame.count[cl]; ++i)
					{
						profile_block& block = frame.blocks[cl][i];
						block.relStart = (float)(block.startClock - frame.startClock) / freq * 1000.f;
						block.duration = (float)(block.endClock - block.startClock) / freq * 1000.f;
					}
				}


				++profileFrameWriteIndex;
				if (profileFrameWriteIndex >= MAX_NUM_DX_PROFILE_FRAMES)
				{
					profileFrameWriteIndex = 0;
				}
			}
		}
	}



	if (dxProfilerWindowOpen)
	{
		if (ImGui::Begin(ICON_FA_CHART_BAR "  GPU Profiling", &dxProfilerWindowOpen))
		{
			static profiler_persistent persistent;
			profiler_timeline timeline(persistent, MAX_NUM_DX_PROFILE_FRAMES);

			timeline.drawHeader(pauseRecording);

			for (uint32 frameIndex = 0; frameIndex < MAX_NUM_DX_PROFILE_FRAMES; ++frameIndex)
			{
				timeline.drawOverviewFrame(profileFrames[frameIndex], frameIndex, currentFrame);
			}
			timeline.endOverview();


			if (persistent.highlightFrameIndex != -1)
			{
				uint32 colorIndex = 0;

				dx_profile_frame& frame = profileFrames[persistent.highlightFrameIndex];

				timeline.drawHighlightFrameInfo(frame);

				for (uint32 clIndex = 0; clIndex < profile_cl_count; ++clIndex)
				{
					profile_block* blocks = frame.blocks[clIndex];
					uint32 count = frame.count[clIndex];

					if (count > 0)
					{
						timeline.drawCallStack(blocks, 0, clIndex == profile_cl_graphics ? "GRAPHICS" : "COMPUTE");
					}
				}

				timeline.drawMillisecondSpacings(frame);
				timeline.handleUserInteractions();
			}

		}
		ImGui::End();
	}
}

#endif

```

`src/dx/dx_profiling.h`:

```h
#pragma once

#include "dx_command_list.h"
#include "core/profiling_internal.h"
#include "core/cpu_profiling.h"


extern bool dxProfilerWindowOpen;


#if ENABLE_DX_PROFILING


#if __has_include(<pix/pix3.h>)
#define USE_PIX
#include <pix/pix3.h>
#pragma comment( lib, "WinPixEventRuntime" )
#else
#define PIXScopedEvent(...)
#define PIX_COLOR(...)
#endif



#define _DX_PROFILE_BLOCK_(counter, cl, name) dx_profile_block_recorder COMPOSITE_VARNAME(__DX_PROFILE_BLOCK, counter)(cl, name)
#define DX_PROFILE_BLOCK(cl, name) \
	_DX_PROFILE_BLOCK_(__COUNTER__, cl, name); \
	PIXScopedEvent(cl->commandList.Get(), PIX_COLOR(255, 255, 0), name);


#define MAX_NUM_DX_PROFILE_BLOCKS 2048
#define MAX_NUM_DX_PROFILE_EVENTS (MAX_NUM_DX_PROFILE_BLOCKS * 2) // One for start and end.


enum profile_cl_type
{
	profile_cl_graphics,
	profile_cl_compute,

	profile_cl_count,
};

extern profile_event dxProfileEvents[NUM_BUFFERED_FRAMES][MAX_NUM_DX_PROFILE_EVENTS];

struct dx_profile_block_recorder
{
	dx_command_list* cl;
	const char* name;

	dx_profile_block_recorder(dx_command_list* cl, const char* name)
		: cl(cl), name(name)
	{
		uint32 queryIndex = atomicIncrement(dxContext.timestampQueryIndex[dxContext.bufferedFrameID]);
		cl->queryTimestamp(queryIndex);

		dxProfileEvents[dxContext.bufferedFrameID][queryIndex] = 
		{ 
			profile_event_begin_block,
			(uint16)((cl->type == D3D12_COMMAND_LIST_TYPE_DIRECT) ? profile_cl_graphics : profile_cl_compute),
			getThreadIDFast(),
			name 
		};
	}

	~dx_profile_block_recorder()
	{
		uint32 queryIndex = atomicIncrement(dxContext.timestampQueryIndex[dxContext.bufferedFrameID]);
		cl->queryTimestamp(queryIndex);

		dxProfileEvents[dxContext.bufferedFrameID][queryIndex] = 
		{ 
			profile_event_end_block,
			(uint16)((cl->type == D3D12_COMMAND_LIST_TYPE_DIRECT) ? profile_cl_graphics : profile_cl_compute),
			getThreadIDFast(),
			name 
		};
	}
};

void dxProfilingFrameEndMarker(dx_command_list* cl);
void dxProfilingResolveTimeStamps(uint64* timestamps);

#else

#define DX_PROFILE_BLOCK(...)

#define dxProfilingFrameEndMarker(...)
#define dxProfilingResolveTimeStamps(...)

#endif


#define PROFILE_ALL(cl, name) DX_PROFILE_BLOCK(cl, name); CPU_PROFILE_BLOCK(name)



```

`src/dx/dx_query.cpp`:

```cpp
#include "pch.h"
#include "dx_query.h"
#include "dx_context.h"

void dx_timestamp_query_heap::initialize(uint32 maxCount)
{
	D3D12_QUERY_HEAP_DESC desc;
	desc.Type = D3D12_QUERY_HEAP_TYPE_TIMESTAMP;
	desc.Count = maxCount;
	desc.NodeMask = 0;

	checkResult(dxContext.device->CreateQueryHeap(&desc, IID_PPV_ARGS(&heap)));
}

```

`src/dx/dx_query.h`:

```h
#pragma once

#include "dx.h"

struct dx_timestamp_query_heap
{
	void initialize(uint32 maxCount);

	dx_query_heap heap;
};


```

`src/dx/dx_render_target.h`:

```h
#pragma once

#include "dx.h"
#include "dx_descriptor.h"
#include "dx_texture.h"

struct dx_texture;

struct dx_render_target
{
	uint32 numAttachments = 0;
	D3D12_VIEWPORT viewport;

	dx_rtv_descriptor_handle rtv[8];
	dx_dsv_descriptor_handle dsv = CD3DX12_DEFAULT();


	dx_render_target(uint32 width, uint32 height)
	{
		viewport = { 0.f, 0.f, (float)width, (float)height, 0.f, 1.f };
	}

	dx_render_target& colorAttachment(const ref<dx_texture>& attachment, dx_rtv_descriptor_handle useIfNull = CD3DX12_DEFAULT())
	{
		ASSERT(pushIndex < arraysize(rtv));
		rtv[pushIndex++] = attachment ? attachment->defaultRTV : useIfNull;

		if (attachment)
		{
			// Change numAttachments only, if attachment is valid. This way the invalid attachments at the end are ignored, when the render target is bound to the command list.
			numAttachments = pushIndex;
		}

		return *this;
	}

	dx_render_target& depthAttachment(const ref<dx_texture>& attachment, dx_dsv_descriptor_handle useIfNull = CD3DX12_DEFAULT())
	{
		ASSERT(!dsv);
		dsv = attachment ? attachment->defaultDSV : useIfNull;
		return *this;
	}

private:
	uint32 pushIndex = 0;
};

```

`src/dx/dx_texture.cpp`:

```cpp
#include "pch.h"
#include "dx_texture.h"
#include "dx_context.h"
#include "dx_command_list.h"
#include "core/hash.h"
#include "asset/file_registry.h"
#include "rendering/texture_preprocessing.h"
#include "rendering/render_resources.h"

#include <d3d12memoryallocator/D3D12MemAlloc.h>
#include <DirectXTex/DirectXTex.h>

static void initializeTexture(ref<dx_texture> result, D3D12_RESOURCE_DESC textureDesc, D3D12_SUBRESOURCE_DATA* subresourceData, uint32 numSubresources, D3D12_RESOURCE_STATES initialState = D3D12_RESOURCE_STATE_COMMON, bool mipUAVs = false);

static void uploadImageToGPU(ref<dx_texture> result, DirectX::ScratchImage& scratchImage, D3D12_RESOURCE_DESC& textureDesc, uint32 flags)
{
	const DirectX::Image* images = scratchImage.GetImages();
	uint32 numImages = (uint32)scratchImage.GetImageCount();

	D3D12_SUBRESOURCE_DATA subresources[128];
	for (uint32 i = 0; i < numImages; ++i)
	{
		D3D12_SUBRESOURCE_DATA& subresource = subresources[i];
		subresource.RowPitch = images[i].rowPitch;
		subresource.SlicePitch = images[i].slicePitch;
		subresource.pData = images[i].pixels;
	}

	initializeTexture(result, textureDesc, subresources, numImages);
	SET_NAME(result->resource, "Loaded from file");

	if (flags & image_load_flags_gen_mips_on_gpu)
	{
		dxContext.renderQueue.waitForOtherQueue(dxContext.copyQueue);
		dx_command_list* cl = dxContext.getFreeRenderCommandList();
		generateMipMapsOnGPU(cl, result);
		dxContext.executeCommandList(cl);
	}
}

static ref<dx_texture> uploadImageToGPU(DirectX::ScratchImage& scratchImage, D3D12_RESOURCE_DESC& textureDesc, uint32 flags)
{
	ref<dx_texture> result = make_ref<dx_texture>();
	uploadImageToGPU(result, scratchImage, textureDesc, flags);
	return result;
}

static void textureLoaderThread(ref<dx_texture> result, const fs::path& path, uint32 flags)
{
	DirectX::ScratchImage scratchImage;
	D3D12_RESOURCE_DESC textureDesc;

	if (path.extension() == ".svg")
	{
		if (!loadSVGFromFile(path, flags, scratchImage, textureDesc))
		{
			return;
		}
	}
	else if (!loadImageFromFile(path, flags, scratchImage, textureDesc))
	{
		return;
	}

	uploadImageToGPU(result, scratchImage, textureDesc, flags);

	result->loadState.store(asset_loaded, std::memory_order_release);
}

static ref<dx_texture> loadTextureInternal(const fs::path& path, asset_handle handle, uint32 flags,
	bool async, job_handle parentJob)
{
	if (flags & image_load_flags_gen_mips_on_gpu)
	{
		flags &= ~image_load_flags_gen_mips_on_cpu;
		flags |= image_load_flags_allocate_full_mipchain;
	}

	if (!async)
	{
		DirectX::ScratchImage scratchImage;
		D3D12_RESOURCE_DESC textureDesc;

		if (path.extension() == ".svg")
		{
			if (!loadSVGFromFile(path, flags, scratchImage, textureDesc))
			{
				return 0;
			}
		}
		else if (!loadImageFromFile(path, flags, scratchImage, textureDesc))
		{
			return 0;
		}

		ref<dx_texture> result = uploadImageToGPU(scratchImage, textureDesc, flags);
		result->handle = handle;
		result->flags = flags;
		result->loadJob = {};

		return result;
	}
	else
	{
		ref<dx_texture> result = make_ref<dx_texture>();
		result->width = 1;
		result->height = 1;
		result->depth = 1;
		result->format = DXGI_FORMAT_R8G8B8A8_UNORM;
		result->defaultSRV = render_resources::nullTextureSRV;
		result->handle = handle;
		result->flags = flags;
		result->loadState = asset_loading;

		struct texture_loading_data
		{
			ref<dx_texture> texture;
			fs::path path;
			uint32 flags;
		};

		texture_loading_data data = { result, path, flags };

		job_handle job = lowPriorityJobQueue.createJob<texture_loading_data>([](texture_loading_data& data, job_handle)
		{
			textureLoaderThread(data.texture, data.path, data.flags);
		}, data, parentJob);
		job.submitNow();

		result->loadJob = job;

		return result;
	}
}

static ref<dx_texture> loadTextureFromMemoryInternal(const void* ptr, uint32 size, image_format imageFormat, const fs::path& cachePath, uint32 flags)
{
	DirectX::ScratchImage scratchImage;
	D3D12_RESOURCE_DESC textureDesc;

	if (!loadImageFromMemory(ptr, size, imageFormat, cachePath, flags, scratchImage, textureDesc))
	{
		return nullptr;
	}

	ref<dx_texture> result = uploadImageToGPU(scratchImage, textureDesc, flags);
	result->flags = flags;
	return result;
}

static ref<dx_texture> loadVolumeTextureInternal(const fs::path& dirname, uint32 flags)
{
	// No mip maps allowed for now!
	ASSERT(!(flags & image_load_flags_allocate_full_mipchain));
	ASSERT(!(flags & image_load_flags_gen_mips_on_cpu));
	ASSERT(!(flags & image_load_flags_gen_mips_on_gpu));

	std::vector<DirectX::ScratchImage> scratchImages;
	D3D12_RESOURCE_DESC textureDesc = {};

	uint32 totalSize = 0;

	for (auto& p : fs::directory_iterator(dirname))
	{
		auto& path = p.path();
		DirectX::ScratchImage& s = scratchImages.emplace_back();
		if (!loadImageFromFile(p, flags, s, textureDesc))
		{
			return nullptr;
		}

		ASSERT(s.GetImageCount() == 1);
		const auto& image = s.GetImages()[0];

		if (scratchImages.size() > 1)
		{
			ASSERT(image.width == scratchImages.begin()->GetImages()[0].width);
			ASSERT(image.height == scratchImages.begin()->GetImages()[0].height);
			ASSERT(image.slicePitch == scratchImages.begin()->GetImages()[0].slicePitch);
		}

		totalSize += (uint32)image.slicePitch;
	}

	uint32 width = (uint32)textureDesc.Width;
	uint32 height = textureDesc.Height;
	uint32 depth = (uint32)scratchImages.size();

	uint8* allPixels = new uint8[totalSize];

	for (uint32 i = 0; i < depth; ++i)
	{
		DirectX::ScratchImage& s = scratchImages[i];
		const auto& image = s.GetImages()[0];

		memcpy(allPixels + i * image.slicePitch, image.pixels, image.slicePitch);
	}

	D3D12_SUBRESOURCE_DATA subresource;
	subresource.RowPitch = scratchImages.begin()->GetImages()[0].rowPitch;
	subresource.SlicePitch = scratchImages.begin()->GetImages()[0].slicePitch;
	subresource.pData = allPixels;

	ref<dx_texture> result = createVolumeTexture(0, width, height, depth, textureDesc.Format, false);
	uploadTextureSubresourceData(result, &subresource, 0, 1);

	delete[] allPixels;

	return result;
}

struct texture_key
{
	asset_handle handle;
	uint32 flags;
};

namespace std
{
	template<>
	struct hash<texture_key>
	{
		size_t operator()(const texture_key& x) const
		{
			size_t seed = 0;
			hash_combine(seed, x.handle);
			hash_combine(seed, x.flags);
			return seed;
		}
	};
}

static bool operator==(const texture_key& a, const texture_key& b)
{
	return a.handle == b.handle && a.flags == b.flags;
}

static std::unordered_map<texture_key, weakref<dx_texture>> textureCache;
static std::mutex mutex;

static ref<dx_texture> loadTextureFromFileAndHandle(const fs::path& filename, asset_handle handle, uint32 flags,
	bool async = false, job_handle parentJob = {})
{
	if (!fs::exists(filename))
	{
		return 0;
	}

	texture_key key = { handle, flags };

	mutex.lock();

	ref<dx_texture> result = textureCache[key].lock();
	if (!result)
	{
		result = loadTextureInternal(filename, handle, flags, async, parentJob);
		textureCache[key] = result;
	}

	mutex.unlock();
	return result;
}

ref<dx_texture> loadTextureFromFile(const fs::path& filename, uint32 flags)
{
	fs::path path = filename.lexically_normal().make_preferred();

	asset_handle handle = getAssetHandleFromPath(path);
	return loadTextureFromFileAndHandle(path, handle, flags);
}

ref<dx_texture> loadTextureFromHandle(asset_handle handle, uint32 flags)
{
	fs::path sceneFilename = getPathFromAssetHandle(handle);
	return loadTextureFromFileAndHandle(sceneFilename, handle, flags);
}

ref<dx_texture> loadTextureFromFileAsync(const fs::path& filename, uint32 flags, job_handle parentJob)
{
	fs::path path = filename.lexically_normal().make_preferred();

	asset_handle handle = getAssetHandleFromPath(path);
	return loadTextureFromFileAndHandle(path, handle, flags, true, parentJob);
}

ref<dx_texture> loadTextureFromHandleAsync(asset_handle handle, uint32 flags, job_handle parentJob)
{
	fs::path sceneFilename = getPathFromAssetHandle(handle);
	return loadTextureFromFileAndHandle(sceneFilename, handle, flags, true, parentJob);
}

ref<dx_texture> loadTextureFromMemory(const void* ptr, uint32 size, image_format imageFormat, const fs::path& cacheFilename, uint32 flags)
{
	return loadTextureFromMemoryInternal(ptr, size, imageFormat, cacheFilename, flags);
}

ref<dx_texture> loadVolumeTextureFromDirectory(const fs::path& dirname, uint32 flags)
{
	return loadVolumeTextureInternal(dirname, flags);
}

static bool checkFormatSupport(D3D12_FEATURE_DATA_FORMAT_SUPPORT formatSupport, D3D12_FORMAT_SUPPORT1 support)
{
	return (formatSupport.Support1 & support) != 0;
}

static bool checkFormatSupport(D3D12_FEATURE_DATA_FORMAT_SUPPORT formatSupport, D3D12_FORMAT_SUPPORT2 support)
{
	return (formatSupport.Support2 & support) != 0;
}

static bool formatSupportsRTV(D3D12_FEATURE_DATA_FORMAT_SUPPORT formatSupport)
{
	return checkFormatSupport(formatSupport, D3D12_FORMAT_SUPPORT1_RENDER_TARGET);
}

static bool formatSupportsDSV(D3D12_FEATURE_DATA_FORMAT_SUPPORT formatSupport)
{
	return checkFormatSupport(formatSupport, D3D12_FORMAT_SUPPORT1_DEPTH_STENCIL);
}

static bool formatSupportsSRV(D3D12_FEATURE_DATA_FORMAT_SUPPORT formatSupport)
{
	return checkFormatSupport(formatSupport, D3D12_FORMAT_SUPPORT1_SHADER_SAMPLE);
}

static bool formatSupportsUAV(D3D12_FEATURE_DATA_FORMAT_SUPPORT formatSupport)
{
	return checkFormatSupport(formatSupport, D3D12_FORMAT_SUPPORT1_TYPED_UNORDERED_ACCESS_VIEW) &&
		checkFormatSupport(formatSupport, D3D12_FORMAT_SUPPORT2_UAV_TYPED_LOAD) &&
		checkFormatSupport(formatSupport, D3D12_FORMAT_SUPPORT2_UAV_TYPED_STORE);
}

D3D12_RESOURCE_ALLOCATION_INFO getTextureAllocationInfo(uint32 width, uint32 height, DXGI_FORMAT format, bool allocateMips, D3D12_RESOURCE_FLAGS flags)
{
	uint32 numMips = allocateMips ? 0 : 1;
	auto desc = CD3DX12_RESOURCE_DESC::Tex2D(format, width, height, 1, numMips, 1, 0, flags);
	return dxContext.device->GetResourceAllocationInfo(0, 1, &desc);
}

void uploadTextureSubresourceData(ref<dx_texture> texture, D3D12_SUBRESOURCE_DATA* subresourceData, uint32 firstSubresource, uint32 numSubresources)
{
	dx_command_list* cl = dxContext.getFreeCopyCommandList();
	cl->transitionBarrier(texture, D3D12_RESOURCE_STATE_COMMON, D3D12_RESOURCE_STATE_COPY_DEST);

	uint64 requiredSize = GetRequiredIntermediateSize(texture->resource.Get(), firstSubresource, numSubresources);

	dx_resource intermediateResource;

	auto bufferDesc = CD3DX12_RESOURCE_DESC::Buffer(requiredSize);

#if !USE_D3D12_BLOCK_ALLOCATOR

	auto heapDesc = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	checkResult(dxContext.device->CreateCommittedResource(
		&heapDesc,
		D3D12_HEAP_FLAG_NONE,
		&bufferDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		0,
		IID_PPV_ARGS(&intermediateResource)
	));
#else
	D3D12MA::ALLOCATION_DESC allocationDesc = {};
	allocationDesc.HeapType = D3D12_HEAP_TYPE_UPLOAD;

	D3D12MA::Allocation* allocation;
	checkResult(dxContext.memoryAllocator->CreateResource(
		&allocationDesc,
		&bufferDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		0,
		&allocation,
		IID_PPV_ARGS(&intermediateResource)));
	dxContext.retire(allocation);
#endif

	UpdateSubresources<128>(cl->commandList.Get(), texture->resource.Get(), intermediateResource.Get(), 0, firstSubresource, numSubresources, subresourceData);
	dxContext.retire(intermediateResource);

	// We are omitting the transition to common here, since the resource automatically decays to common state after being accessed on a copy queue.
	//cl->transitionBarrier(texture, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_COMMON);

	dxContext.executeCommandList(cl);
}

static void initializeTexture(ref<dx_texture> result, D3D12_RESOURCE_DESC textureDesc, D3D12_SUBRESOURCE_DATA* subresourceData, uint32 numSubresources, D3D12_RESOURCE_STATES initialState, bool mipUAVs)
{
	result->requestedNumMipLevels = textureDesc.MipLevels;

	uint32 maxNumMipLevels = (uint32)log2((float)max((uint32)textureDesc.Width, textureDesc.Height)) + 1;
	textureDesc.MipLevels = min(maxNumMipLevels, result->requestedNumMipLevels);

	D3D12_FEATURE_DATA_FORMAT_SUPPORT formatSupport;
	formatSupport.Format = textureDesc.Format;
	checkResult(dxContext.device->CheckFeatureSupport(
		D3D12_FEATURE_FORMAT_SUPPORT,
		&formatSupport,
		sizeof(D3D12_FEATURE_DATA_FORMAT_SUPPORT)));

	result->supportsRTV = (textureDesc.Flags & D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET) && formatSupportsRTV(formatSupport);
	result->supportsDSV = (textureDesc.Flags & D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL) && formatSupportsDSV(formatSupport);
	result->supportsUAV = (textureDesc.Flags & D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS) && formatSupportsUAV(formatSupport);
	result->supportsSRV = formatSupportsSRV(formatSupport);

	if (textureDesc.Flags & D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET && !result->supportsRTV)
	{
		std::cerr << "Warning. Requested RTV, but not supported by format.\n";
		__debugbreak();
	}

	if (textureDesc.Flags & D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL && !result->supportsDSV)
	{
		std::cerr << "Warning. Requested DSV, but not supported by format.\n";
		__debugbreak();
	}

	if (textureDesc.Flags & D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS && !result->supportsUAV)
	{
		std::cerr << "Warning. Requested UAV, but not supported by format.\n";
		__debugbreak();
	}


	// Create.


#if !USE_D3D12_BLOCK_ALLOCATOR

	auto heapDesc = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT);
	checkResult(dxContext.device->CreateCommittedResource(&heapDesc,
		D3D12_HEAP_FLAG_NONE,
		&textureDesc,
		initialState,
		0,
		IID_PPV_ARGS(&result->resource)));
#else
	D3D12MA::ALLOCATION_DESC allocationDesc = {};
	allocationDesc.HeapType = D3D12_HEAP_TYPE_DEFAULT;

	D3D12MA::Allocation* allocation;
	checkResult(dxContext.memoryAllocator->CreateResource(
		&allocationDesc,
		&textureDesc,
		initialState,
		0,
		&allocation,
		IID_PPV_ARGS(&result->resource)));

	result->allocation = allocation;
#endif


	result->numMipLevels = result->resource->GetDesc().MipLevels;

	result->format = textureDesc.Format;
	result->width = (uint32)textureDesc.Width;
	result->height = textureDesc.Height;
	result->depth = textureDesc.DepthOrArraySize;


	result->initialState = initialState;


	// Upload.
	if (subresourceData)
	{
		uploadTextureSubresourceData(result, subresourceData, 0, numSubresources);
	}

	uint32 numUAVMips = 0;
	if (result->supportsUAV)
	{
		numUAVMips = (mipUAVs ? result->numMipLevels : 1);
	}
	result->srvUavAllocation = dxContext.srvUavAllocator.allocate(1 + numUAVMips);

	// SRV.
	if (textureDesc.Dimension == D3D12_RESOURCE_DIMENSION_TEXTURE3D)
	{
		result->defaultSRV = dx_cpu_descriptor_handle(result->srvUavAllocation.cpuAt(0)).createVolumeTextureSRV(result);
	}
	else if (textureDesc.DepthOrArraySize == 6)
	{
		result->defaultSRV = dx_cpu_descriptor_handle(result->srvUavAllocation.cpuAt(0)).createCubemapSRV(result);
	}
	else
	{
		result->defaultSRV = dx_cpu_descriptor_handle(result->srvUavAllocation.cpuAt(0)).create2DTextureSRV(result);
	}

	// RTV.
	if (result->supportsRTV)
	{
		result->rtvAllocation = dxContext.rtvAllocator.allocate(textureDesc.DepthOrArraySize);
		for (uint32 i = 0; i < textureDesc.DepthOrArraySize; ++i)
		{
			dx_rtv_descriptor_handle(result->rtvAllocation.cpuAt(i)).create2DTextureRTV(result, i);
		}
		result->defaultRTV = result->rtvAllocation.cpuAt(0);
	}

	// UAV.
	if (result->supportsUAV)
	{
		result->defaultUAV = result->srvUavAllocation.cpuAt(1);

		for (uint32 i = 0; i < numUAVMips; ++i)
		{
			if (textureDesc.Dimension == D3D12_RESOURCE_DIMENSION_TEXTURE3D)
			{
				dx_cpu_descriptor_handle(result->srvUavAllocation.cpuAt(1 + i)).createVolumeTextureUAV(result, i);
			}
			else if (textureDesc.DepthOrArraySize == 6)
			{
				dx_cpu_descriptor_handle(result->srvUavAllocation.cpuAt(1 + i)).createCubemapUAV(result, i);
			}
			else
			{
				dx_cpu_descriptor_handle(result->srvUavAllocation.cpuAt(1 + i)).create2DTextureUAV(result, i);
			}
		}
	}
}

ref<dx_texture> createTexture(D3D12_RESOURCE_DESC textureDesc, D3D12_SUBRESOURCE_DATA* subresourceData, uint32 numSubresources, D3D12_RESOURCE_STATES initialState, bool mipUAVs)
{
	ref<dx_texture> result = make_ref<dx_texture>();
	initializeTexture(result, textureDesc, subresourceData, numSubresources, initialState, mipUAVs);
	return result;
}

ref<dx_texture> createTexture(const void* data, uint32 width, uint32 height, DXGI_FORMAT format, bool allocateMips, bool allowRenderTarget, bool allowUnorderedAccess, D3D12_RESOURCE_STATES initialState, bool mipUAVs)
{
	D3D12_RESOURCE_FLAGS flags = D3D12_RESOURCE_FLAG_NONE
		| (allowRenderTarget ? D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET : D3D12_RESOURCE_FLAG_NONE)
		| (allowUnorderedAccess ? D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS : D3D12_RESOURCE_FLAG_NONE)
		;

	uint32 numMips = allocateMips ? 0 : 1;
	CD3DX12_RESOURCE_DESC textureDesc = CD3DX12_RESOURCE_DESC::Tex2D(format, width, height, 1, numMips, 1, 0, flags);

	if (data)
	{
		uint32 formatSize = getFormatSize(textureDesc.Format);

		D3D12_SUBRESOURCE_DATA subresource;
		subresource.RowPitch = width * formatSize;
		subresource.SlicePitch = width * height * formatSize;
		subresource.pData = data;

		return createTexture(textureDesc, &subresource, 1, initialState, mipUAVs);
	}
	else
	{
		return createTexture(textureDesc, 0, 0, initialState, mipUAVs);
	}
}

dx_tiled_texture createTiledTexture(D3D12_RESOURCE_DESC textureDesc, D3D12_RESOURCE_STATES initialState, bool mipUAVs)
{
	ref<dx_texture> result = make_ref<dx_texture>();

	result->requestedNumMipLevels = textureDesc.MipLevels;

	uint32 maxNumMipLevels = (uint32)log2((float)max((uint32)textureDesc.Width, textureDesc.Height)) + 1;
	textureDesc.MipLevels = min(maxNumMipLevels, result->requestedNumMipLevels);
	textureDesc.Layout = D3D12_TEXTURE_LAYOUT_64KB_UNDEFINED_SWIZZLE;

	D3D12_FEATURE_DATA_FORMAT_SUPPORT formatSupport;
	formatSupport.Format = textureDesc.Format;
	checkResult(dxContext.device->CheckFeatureSupport(
		D3D12_FEATURE_FORMAT_SUPPORT,
		&formatSupport,
		sizeof(D3D12_FEATURE_DATA_FORMAT_SUPPORT)));

	result->supportsRTV = (textureDesc.Flags & D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET) && formatSupportsRTV(formatSupport);
	result->supportsDSV = (textureDesc.Flags & D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL) && formatSupportsDSV(formatSupport);
	result->supportsUAV = (textureDesc.Flags & D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS) && formatSupportsUAV(formatSupport);
	result->supportsSRV = formatSupportsSRV(formatSupport);

	if (textureDesc.Flags & D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET && !result->supportsRTV)
	{
		std::cerr << "Warning. Requested RTV, but not supported by format.\n";
		__debugbreak();
	}

	if (textureDesc.Flags & D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL && !result->supportsDSV)
	{
		std::cerr << "Warning. Requested DSV, but not supported by format.\n";
		__debugbreak();
	}

	if (textureDesc.Flags & D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS && !result->supportsUAV)
	{
		std::cerr << "Warning. Requested UAV, but not supported by format.\n";
		__debugbreak();
	}


	// Create.

	checkResult(dxContext.device->CreateReservedResource(
		&textureDesc,
		initialState,
		0,
		IID_PPV_ARGS(&result->resource)));

	result->numMipLevels = result->resource->GetDesc().MipLevels;

	result->format = textureDesc.Format;
	result->width = (uint32)textureDesc.Width;
	result->height = textureDesc.Height;
	result->depth = textureDesc.DepthOrArraySize;


	result->initialState = initialState;


	uint32 numUAVMips = 0;
	if (result->supportsUAV)
	{
		numUAVMips = (mipUAVs ? result->numMipLevels : 1);
	}
	result->srvUavAllocation = dxContext.srvUavAllocator.allocate(1 + numUAVMips);

	// SRV.
	if (textureDesc.Dimension == D3D12_RESOURCE_DIMENSION_TEXTURE3D)
	{
		result->defaultSRV = dx_cpu_descriptor_handle(result->srvUavAllocation.cpuAt(0)).createVolumeTextureSRV(result);
	}
	else if (textureDesc.DepthOrArraySize == 6)
	{
		result->defaultSRV = dx_cpu_descriptor_handle(result->srvUavAllocation.cpuAt(0)).createCubemapSRV(result);
	}
	else
	{
		result->defaultSRV = dx_cpu_descriptor_handle(result->srvUavAllocation.cpuAt(0)).create2DTextureSRV(result);
	}

	// RTV.
	if (result->supportsRTV)
	{
		result->rtvAllocation = dxContext.rtvAllocator.allocate(textureDesc.DepthOrArraySize);
		for (uint32 i = 0; i < textureDesc.DepthOrArraySize; ++i)
		{
			dx_rtv_descriptor_handle(result->rtvAllocation.cpuAt(i)).create2DTextureRTV(result, i);
		}
		result->defaultRTV = result->rtvAllocation.cpuAt(0);
	}

	// UAV.
	if (result->supportsUAV)
	{
		result->defaultUAV = result->srvUavAllocation.cpuAt(1);

		for (uint32 i = 0; i < numUAVMips; ++i)
		{
			if (textureDesc.Dimension == D3D12_RESOURCE_DIMENSION_TEXTURE3D)
			{
				dx_cpu_descriptor_handle(result->srvUavAllocation.cpuAt(1 + i)).createVolumeTextureUAV(result, i);
			}
			else if (textureDesc.DepthOrArraySize == 6)
			{
				dx_cpu_descriptor_handle(result->srvUavAllocation.cpuAt(1 + i)).createCubemapUAV(result, i);
			}
			else
			{
				dx_cpu_descriptor_handle(result->srvUavAllocation.cpuAt(1 + i)).create2DTextureUAV(result, i);
			}
		}
	}



	dx_tiled_texture tiled;
	tiled.texture = result;


	uint32 numTiles = 0;
	D3D12_TILE_SHAPE tileShape = {};
	uint32 subresourceCount = result->numMipLevels;
	std::vector<D3D12_SUBRESOURCE_TILING> tilings(subresourceCount);
	D3D12_PACKED_MIP_INFO packedMipInfo;

	dxContext.device->GetResourceTiling(result->resource.Get(), &numTiles, &packedMipInfo, &tileShape, &subresourceCount, 0, &tilings[0]);

	tiled.tileShape = tileShape;
	tiled.mipDescs.resize(result->numMipLevels);
	tiled.numStandard = packedMipInfo.NumStandardMips;
	tiled.numPacked = packedMipInfo.NumPackedMips;

	ASSERT(tiled.numStandard + tiled.numPacked == result->numMipLevels);

	for (uint32 i = 0; i < result->numMipLevels; ++i)
	{
		auto& mip = tiled.mipDescs[i];

		mip.startCoordinate = CD3DX12_TILED_RESOURCE_COORDINATE(0, 0, 0, i);
		mip.regionSize.Width = tilings[i].WidthInTiles;
		mip.regionSize.Height = tilings[i].HeightInTiles;
		mip.regionSize.Depth = tilings[i].DepthInTiles;
		mip.regionSize.NumTiles = tilings[i].WidthInTiles * tilings[i].HeightInTiles * tilings[i].DepthInTiles;
		mip.regionSize.UseBox = true;

		// Handle packed mips.
		if (i >= packedMipInfo.NumStandardMips)
		{
			// All packed mips have the same start coordinate and size.
			mip.startCoordinate.Subresource = packedMipInfo.NumStandardMips;
			mip.regionSize.NumTiles = packedMipInfo.NumTilesForPackedMips;
			mip.regionSize.UseBox = false;
		}
	}

	return tiled;
}

dx_tiled_texture createTiledTexture(uint32 width, uint32 height, DXGI_FORMAT format, bool allocateMips, bool allowRenderTarget, bool allowUnorderedAccess, D3D12_RESOURCE_STATES initialState, bool mipUAVs)
{
	D3D12_RESOURCE_FLAGS flags = D3D12_RESOURCE_FLAG_NONE
		| (allowRenderTarget ? D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET : D3D12_RESOURCE_FLAG_NONE)
		| (allowUnorderedAccess ? D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS : D3D12_RESOURCE_FLAG_NONE)
		;

	uint32 numMips = allocateMips ? 0 : 1;
	CD3DX12_RESOURCE_DESC textureDesc = CD3DX12_RESOURCE_DESC::Tex2D(format, width, height, 1, numMips, 1, 0, flags, D3D12_TEXTURE_LAYOUT_64KB_UNDEFINED_SWIZZLE);

	return createTiledTexture(textureDesc, initialState, mipUAVs);
}

static void initializeDepthTexture(ref<dx_texture> result, uint32 width, uint32 height, DXGI_FORMAT format, uint32 arrayLength, D3D12_RESOURCE_STATES initialState, bool allocateDescriptors)
{
	result->numMipLevels = 1;
	result->requestedNumMipLevels = 1;
	result->format = format;
	result->width = width;
	result->height = height;
	result->depth = arrayLength;

	D3D12_FEATURE_DATA_FORMAT_SUPPORT formatSupport;
	formatSupport.Format = format;
	checkResult(dxContext.device->CheckFeatureSupport(
		D3D12_FEATURE_FORMAT_SUPPORT,
		&formatSupport,
		sizeof(D3D12_FEATURE_DATA_FORMAT_SUPPORT)));

	result->supportsRTV = false;
	result->supportsDSV = allocateDescriptors && formatSupportsDSV(formatSupport);
	result->supportsUAV = false;
	result->supportsSRV = allocateDescriptors && formatSupportsSRV(formatSupport);


	result->initialState = initialState;

	if (allocateDescriptors)
	{
		ASSERT(result->supportsDSV);

		result->dsvAllocation = dxContext.dsvAllocator.allocate();
		result->defaultDSV = dx_dsv_descriptor_handle(result->dsvAllocation.cpuAt(0)).create2DTextureDSV(result);

		if (arrayLength == 1)
		{
			result->srvUavAllocation = dxContext.srvUavAllocator.allocate(1 + isStencilFormat(format));
			result->defaultSRV = dx_cpu_descriptor_handle(result->srvUavAllocation.cpuAt(0)).createDepthTextureSRV(result);

			if (isStencilFormat(format))
			{
				result->stencilSRV = dx_cpu_descriptor_handle(result->srvUavAllocation.cpuAt(1)).createStencilTextureSRV(result);
			}
		}
		else
		{
			result->srvUavAllocation = dxContext.srvUavAllocator.allocate();
			result->defaultSRV = dx_cpu_descriptor_handle(result->srvUavAllocation.cpuAt(0)).createDepthTextureArraySRV(result);
		}
	}
}

ref<dx_texture> createDepthTexture(uint32 width, uint32 height, DXGI_FORMAT format, uint32 arrayLength, D3D12_RESOURCE_STATES initialState)
{
	ref<dx_texture> result = make_ref<dx_texture>();

	D3D12_CLEAR_VALUE optimizedClearValue = {};
	optimizedClearValue.Format = format;
	optimizedClearValue.DepthStencil = { 1.f, 0 };

	D3D12_RESOURCE_DESC desc = CD3DX12_RESOURCE_DESC::Tex2D(getTypelessFormat(format), width, height,
		arrayLength, 1, 1, 0, D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL);

#if !USE_D3D12_BLOCK_ALLOCATOR

	auto heapDesc = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT);
	checkResult(dxContext.device->CreateCommittedResource(
		&heapDesc,
		D3D12_HEAP_FLAG_NONE,
		&desc,
		initialState,
		&optimizedClearValue,
		IID_PPV_ARGS(&result->resource)
	));
#else
	D3D12MA::ALLOCATION_DESC allocationDesc = {};
	allocationDesc.HeapType = D3D12_HEAP_TYPE_DEFAULT;

	D3D12MA::Allocation* allocation;
	checkResult(dxContext.memoryAllocator->CreateResource(
		&allocationDesc,
		&desc,
		initialState,
		&optimizedClearValue,
		&allocation,
		IID_PPV_ARGS(&result->resource)));

	result->allocation = allocation;
#endif

	initializeDepthTexture(result, width, height, format, arrayLength, initialState, true);

	return result;
}

ref<dx_texture> createCubeTexture(const void* data, uint32 width, uint32 height, DXGI_FORMAT format, bool allocateMips, bool allowRenderTarget, bool allowUnorderedAccess, D3D12_RESOURCE_STATES initialState, bool mipUAVs)
{
	D3D12_RESOURCE_FLAGS flags = D3D12_RESOURCE_FLAG_NONE
		| (allowRenderTarget ? D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET : D3D12_RESOURCE_FLAG_NONE)
		| (allowUnorderedAccess ? D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS : D3D12_RESOURCE_FLAG_NONE)
		;

	uint32 numMips = allocateMips ? 0 : 1;
	CD3DX12_RESOURCE_DESC textureDesc = CD3DX12_RESOURCE_DESC::Tex2D(format, width, height, 6, numMips, 1, 0, flags);

	if (data)
	{
		uint32 formatSize = getFormatSize(textureDesc.Format);

		D3D12_SUBRESOURCE_DATA subresources[6];
		for (uint32 i = 0; i < 6; ++i)
		{
			auto& subresource = subresources[i];
			subresource.RowPitch = width * formatSize;
			subresource.SlicePitch = width * height * formatSize;
			subresource.pData = data;
		}

		return createTexture(textureDesc, subresources, 6, initialState, mipUAVs);
	}
	else
	{
		return createTexture(textureDesc, 0, 0, initialState, mipUAVs);
	}
}

ref<dx_texture> createVolumeTexture(const void* data, uint32 width, uint32 height, uint32 depth, DXGI_FORMAT format, bool allowUnorderedAccess, D3D12_RESOURCE_STATES initialState)
{
	D3D12_RESOURCE_FLAGS flags = D3D12_RESOURCE_FLAG_NONE
		| (allowUnorderedAccess ? D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS : D3D12_RESOURCE_FLAG_NONE)
		;

	CD3DX12_RESOURCE_DESC textureDesc = CD3DX12_RESOURCE_DESC::Tex3D(format, width, height, depth, 1, flags);

	if (data)
	{
		uint32 formatSize = getFormatSize(textureDesc.Format);

		D3D12_SUBRESOURCE_DATA* subresources = (D3D12_SUBRESOURCE_DATA*)alloca(sizeof(D3D12_SUBRESOURCE_DATA) * depth);
		for (uint32 i = 0; i < depth; ++i)
		{
			auto& subresource = subresources[i];
			subresource.RowPitch = width * formatSize;
			subresource.SlicePitch = width * height * formatSize;
			subresource.pData = data;
		}

		return createTexture(textureDesc, subresources, depth, initialState);
	}
	else
	{
		return createTexture(textureDesc, 0, 0, initialState);
	}
}

void dx_texture::setName(const wchar* name)
{
	checkResult(resource->SetName(name));
}

std::wstring dx_texture::getName() const
{
	if (!resource)
	{
		return L"";
	}

	wchar name[128];
	uint32 size = sizeof(name); 
	resource->GetPrivateData(WKPDID_D3DDebugObjectNameW, &size, name); 
	name[min((uint32)arraysize(name) - 1, size)] = 0;

	return name;
}

ref<dx_texture> createPlacedTexture(dx_heap heap, uint64 offset, uint32 width, uint32 height, DXGI_FORMAT format, bool allocateMips, bool allowRenderTarget, bool allowUnorderedAccess, D3D12_RESOURCE_STATES initialState, bool mipUAVs)
{
	D3D12_RESOURCE_FLAGS flags = D3D12_RESOURCE_FLAG_NONE
		| (allowRenderTarget ? D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET : D3D12_RESOURCE_FLAG_NONE)
		| (allowUnorderedAccess ? D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS : D3D12_RESOURCE_FLAG_NONE)
		;

	uint32 numMips = allocateMips ? 0 : 1;
	CD3DX12_RESOURCE_DESC textureDesc = CD3DX12_RESOURCE_DESC::Tex2D(format, width, height, 1, numMips, 1, 0, flags);
	
	return createPlacedTexture(heap, offset, textureDesc, initialState, mipUAVs);
}

ref<dx_texture> createPlacedTexture(dx_heap heap, uint64 offset, D3D12_RESOURCE_DESC textureDesc, D3D12_RESOURCE_STATES initialState, bool mipUAVs)
{
	ref<dx_texture> result = make_ref<dx_texture>();

	result->requestedNumMipLevels = textureDesc.MipLevels;

	uint32 maxNumMipLevels = (uint32)log2((float)max((uint32)textureDesc.Width, textureDesc.Height)) + 1;
	textureDesc.MipLevels = min(maxNumMipLevels, result->requestedNumMipLevels);

	D3D12_FEATURE_DATA_FORMAT_SUPPORT formatSupport;
	formatSupport.Format = textureDesc.Format;
	checkResult(dxContext.device->CheckFeatureSupport(
		D3D12_FEATURE_FORMAT_SUPPORT,
		&formatSupport,
		sizeof(D3D12_FEATURE_DATA_FORMAT_SUPPORT)));

	result->supportsRTV = (textureDesc.Flags & D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET) && formatSupportsRTV(formatSupport);
	result->supportsDSV = (textureDesc.Flags & D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL) && formatSupportsDSV(formatSupport);
	result->supportsUAV = (textureDesc.Flags & D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS) && formatSupportsUAV(formatSupport);
	result->supportsSRV = formatSupportsSRV(formatSupport);

	if (textureDesc.Flags & D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET && !result->supportsRTV)
	{
		std::cerr << "Warning. Requested RTV, but not supported by format.\n";
		__debugbreak();
	}

	if (textureDesc.Flags & D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL && !result->supportsDSV)
	{
		std::cerr << "Warning. Requested DSV, but not supported by format.\n";
		__debugbreak();
	}

	if (textureDesc.Flags & D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS && !result->supportsUAV)
	{
		std::cerr << "Warning. Requested UAV, but not supported by format.\n";
		__debugbreak();
	}


	// Create.
	checkResult(dxContext.device->CreatePlacedResource(
		heap.Get(),
		offset,
		&textureDesc,
		initialState,
		0,
		IID_PPV_ARGS(&result->resource)
	));


	result->numMipLevels = result->resource->GetDesc().MipLevels;

	result->format = textureDesc.Format;
	result->width = (uint32)textureDesc.Width;
	result->height = textureDesc.Height;
	result->depth = textureDesc.DepthOrArraySize;

	result->initialState = initialState;


	uint32 numUAVMips = 0;
	if (result->supportsUAV)
	{
		numUAVMips = (mipUAVs ? result->numMipLevels : 1);
	}
	result->srvUavAllocation = dxContext.srvUavAllocator.allocate(1 + numUAVMips);

	// SRV.
	if (textureDesc.Dimension == D3D12_RESOURCE_DIMENSION_TEXTURE3D)
	{
		result->defaultSRV = dx_cpu_descriptor_handle(result->srvUavAllocation.cpuAt(0)).createVolumeTextureSRV(result);
	}
	else if (textureDesc.DepthOrArraySize == 6)
	{
		result->defaultSRV = dx_cpu_descriptor_handle(result->srvUavAllocation.cpuAt(0)).createCubemapSRV(result);
	}
	else
	{
		result->defaultSRV = dx_cpu_descriptor_handle(result->srvUavAllocation.cpuAt(0)).create2DTextureSRV(result);
	}

	// RTV.
	if (result->supportsRTV)
	{
		result->rtvAllocation = dxContext.rtvAllocator.allocate(textureDesc.DepthOrArraySize);
		for (uint32 i = 0; i < textureDesc.DepthOrArraySize; ++i)
		{
			dx_rtv_descriptor_handle(result->rtvAllocation.cpuAt(i)).create2DTextureRTV(result, i);
		}
		result->defaultRTV = result->rtvAllocation.cpuAt(0);
	}

	// UAV.
	if (result->supportsUAV)
	{
		result->defaultUAV = result->srvUavAllocation.cpuAt(1);

		for (uint32 i = 0; i < numUAVMips; ++i)
		{
			if (textureDesc.Dimension == D3D12_RESOURCE_DIMENSION_TEXTURE3D)
			{
				dx_cpu_descriptor_handle(result->srvUavAllocation.cpuAt(1 + i)).createVolumeTextureUAV(result, i);
			}
			else if (textureDesc.DepthOrArraySize == 6)
			{
				dx_cpu_descriptor_handle(result->srvUavAllocation.cpuAt(1 + i)).createCubemapUAV(result, i);
			}
			else
			{
				dx_cpu_descriptor_handle(result->srvUavAllocation.cpuAt(1 + i)).create2DTextureUAV(result, i);
			}
		}
	}

	return result;
}

ref<dx_texture> createPlacedDepthTexture(dx_heap heap, uint64 offset, uint32 width, uint32 height, DXGI_FORMAT format, uint32 arrayLength, D3D12_RESOURCE_STATES initialState, bool allowDepthStencil)
{
	ref<dx_texture> result = make_ref<dx_texture>();

	D3D12_CLEAR_VALUE optimizedClearValue = {};
	optimizedClearValue.Format = format;
	optimizedClearValue.DepthStencil = { 1.f, 0 };

	D3D12_RESOURCE_DESC desc = CD3DX12_RESOURCE_DESC::Tex2D(getTypelessFormat(format), width, height,
		arrayLength, 1, 1, 0, allowDepthStencil ? D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL : D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET);

	checkResult(dxContext.device->CreatePlacedResource(
		heap.Get(),
		offset,
		&desc,
		initialState,
		allowDepthStencil ? &optimizedClearValue : 0,
		IID_PPV_ARGS(&result->resource)
	));

	initializeDepthTexture(result, width, height, format, arrayLength, initialState, allowDepthStencil);

	return result;
}

ref<dx_texture> createPlacedDepthTexture(dx_heap heap, uint64 offset, D3D12_RESOURCE_DESC textureDesc, D3D12_RESOURCE_STATES initialState)
{
	ref<dx_texture> result = make_ref<dx_texture>();

	D3D12_CLEAR_VALUE optimizedClearValue = {};
	optimizedClearValue.Format = textureDesc.Format;
	optimizedClearValue.DepthStencil = { 1.f, 0 };

	checkResult(dxContext.device->CreatePlacedResource(
		heap.Get(),
		offset,
		&textureDesc,
		initialState,
		&optimizedClearValue,
		IID_PPV_ARGS(&result->resource)
	));

	initializeDepthTexture(result, (uint32)textureDesc.Width, textureDesc.Height, textureDesc.Format, textureDesc.DepthOrArraySize, initialState, true);

	return result;
}

static void retire(dx_resource resource, dx_descriptor_allocation srvUavAllocation, dx_descriptor_allocation rtvAllocation, dx_descriptor_allocation dsvAllocation)
{
	texture_grave grave;
	grave.resource = resource;
	grave.srvUavAllocation = srvUavAllocation;
	grave.rtvAllocation = rtvAllocation;
	grave.dsvAllocation = dsvAllocation;
	dxContext.retire(std::move(grave));
}

dx_texture::~dx_texture()
{
	retire(resource, srvUavAllocation, rtvAllocation, dsvAllocation);
	if (allocation)
	{
		dxContext.retire(allocation);
	}
}

void resizeTexture(ref<dx_texture> texture, uint32 newWidth, uint32 newHeight, D3D12_RESOURCE_STATES initialState)
{
	if (!texture)
	{
		return;
	}

	wchar name[128];
	uint32 size = sizeof(name);
	texture->resource->GetPrivateData(WKPDID_D3DDebugObjectNameW, &size, name);
	name[min((uint32)arraysize(name) - 1, size)] = 0;

	bool hasMipUAVs = texture->srvUavAllocation.count > 2;

	retire(texture->resource, texture->srvUavAllocation, texture->rtvAllocation, texture->dsvAllocation);
	if (texture->allocation)
	{
		dxContext.retire(texture->allocation);
	}

	D3D12_RESOURCE_DESC desc = texture->resource->GetDesc();
	texture->resource.Reset();


	D3D12_RESOURCE_STATES state = (initialState == -1) ? texture->initialState : initialState;
	D3D12_CLEAR_VALUE optimizedClearValue = {};
	D3D12_CLEAR_VALUE* clearValue = 0;

	if (desc.Flags & D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL)
	{
		optimizedClearValue.Format = texture->format;
		optimizedClearValue.DepthStencil = { 1.f, 0 };
		clearValue = &optimizedClearValue;
	}

	uint32 maxNumMipLevels = (uint32)log2((float)max(newWidth, newHeight)) + 1;
	desc.MipLevels = min(maxNumMipLevels, texture->requestedNumMipLevels);

	desc.Width = newWidth;
	desc.Height = newHeight;
	texture->width = newWidth;
	texture->height = newHeight;

#if !USE_D3D12_BLOCK_ALLOCATOR

	auto heapDesc = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT);
	checkResult(dxContext.device->CreateCommittedResource(
		&heapDesc,
		D3D12_HEAP_FLAG_NONE,
		&desc,
		state,
		clearValue,
		IID_PPV_ARGS(&texture->resource)
	));
#else
	D3D12MA::ALLOCATION_DESC allocationDesc = {};
	allocationDesc.HeapType = D3D12_HEAP_TYPE_DEFAULT;

	D3D12MA::Allocation* allocation;
	checkResult(dxContext.memoryAllocator->CreateResource(
		&allocationDesc,
		&desc,
		state,
		clearValue,
		&allocation,
		IID_PPV_ARGS(&texture->resource)));

	texture->allocation = allocation;
#endif

	texture->numMipLevels = texture->resource->GetDesc().MipLevels;


	uint32 numUAVMips = 0;
	if (texture->supportsUAV)
	{
		numUAVMips = (hasMipUAVs ? texture->numMipLevels : 1);
	}



	// RTV.
	if (texture->supportsRTV)
	{
		texture->rtvAllocation = dxContext.rtvAllocator.allocate();
		texture->defaultRTV = dx_rtv_descriptor_handle(texture->rtvAllocation.cpuAt(0)).create2DTextureRTV(texture);
	}

	// DSV & SRV.
	if (texture->supportsDSV)
	{
		texture->dsvAllocation = dxContext.dsvAllocator.allocate(1);
		texture->defaultDSV = dx_dsv_descriptor_handle(texture->dsvAllocation.cpuAt(0)).create2DTextureDSV(texture);

		texture->srvUavAllocation = dxContext.srvUavAllocator.allocate(1 + isStencilFormat(texture->format));
		if (texture->depth == 1)
		{
			texture->defaultSRV = dx_cpu_descriptor_handle(texture->srvUavAllocation.cpuAt(0)).createDepthTextureSRV(texture);
		}
		else
		{
			texture->defaultSRV = dx_cpu_descriptor_handle(texture->srvUavAllocation.cpuAt(0)).createDepthTextureArraySRV(texture);
		}

		if (isStencilFormat(texture->format))
		{
			texture->stencilSRV = dx_cpu_descriptor_handle(texture->srvUavAllocation.cpuAt(1)).createStencilTextureSRV(texture);
		}
	}
	else
	{
		texture->srvUavAllocation = dxContext.srvUavAllocator.allocate(1 + numUAVMips);

		if (desc.Dimension == D3D12_RESOURCE_DIMENSION_TEXTURE3D)
		{
			texture->defaultSRV = dx_cpu_descriptor_handle(texture->srvUavAllocation.cpuAt(0)).createVolumeTextureSRV(texture);
		}
		else if (texture->depth == 6)
		{
			texture->defaultSRV = dx_cpu_descriptor_handle(texture->srvUavAllocation.cpuAt(0)).createCubemapSRV(texture);
		}
		else
		{
			texture->defaultSRV = dx_cpu_descriptor_handle(texture->srvUavAllocation.cpuAt(0)).create2DTextureSRV(texture);
		}


		// UAV.
		if (texture->supportsUAV)
		{
			texture->defaultUAV = texture->srvUavAllocation.cpuAt(1);

			for (uint32 i = 0; i < numUAVMips; ++i)
			{
				if (desc.Dimension == D3D12_RESOURCE_DIMENSION_TEXTURE3D)
				{
					dx_cpu_descriptor_handle(texture->srvUavAllocation.cpuAt(1 + i)).createVolumeTextureUAV(texture, i);
				}
				else if (desc.DepthOrArraySize == 6)
				{
					dx_cpu_descriptor_handle(texture->srvUavAllocation.cpuAt(1 + i)).createCubemapUAV(texture, i);
				}
				else
				{
					dx_cpu_descriptor_handle(texture->srvUavAllocation.cpuAt(1 + i)).create2DTextureUAV(texture, i);
				}
			}
		}
	}

	texture->setName(name);
}

texture_grave::~texture_grave()
{
	wchar name[128];

	if (resource)
	{
		uint32 size = sizeof(name);
		resource->GetPrivateData(WKPDID_D3DDebugObjectNameW, &size, name);
		name[min((uint32)arraysize(name) - 1, size)] = 0;

		dxContext.srvUavAllocator.free(srvUavAllocation);
		dxContext.rtvAllocator.free(rtvAllocation);
		dxContext.dsvAllocator.free(dsvAllocation);
	}
}

void saveTextureToFile(const ref<dx_texture>& texture, const fs::path& path)
{
	saveTextureToFile(texture->resource, texture->width, texture->height, texture->format, path);
}

void saveTextureToFile(dx_resource texture, uint32 width, uint32 height, DXGI_FORMAT format, const fs::path& path)
{
	ASSERT(format == DXGI_FORMAT_R8G8B8A8_UNORM);
	uint32 outputSize = 4;

	uint32 readbackPitch = alignTo(width, D3D12_TEXTURE_DATA_PITCH_ALIGNMENT);
	ref<dx_buffer> readbackBuffer = createReadbackBuffer(outputSize, readbackPitch * height);

	dx_command_list* cl = dxContext.getFreeRenderCommandList();

	cl->transitionBarrier(texture, D3D12_RESOURCE_STATE_COMMON, D3D12_RESOURCE_STATE_GENERIC_READ);
	cl->copyTextureRegionToBuffer(texture, width, format, readbackBuffer, 0, 0, 0, width, height);
	cl->transitionBarrier(texture, D3D12_RESOURCE_STATE_GENERIC_READ, D3D12_RESOURCE_STATE_COMMON);

	uint64 fence = dxContext.executeCommandList(cl);

	dxContext.renderQueue.waitForFence(fence);

	uint8* output = new uint8[width * height * outputSize];

	uint8* dest = output;
	uint32 destPitch = outputSize * width;

	uint8* result = (uint8*)mapBuffer(readbackBuffer, true);
	uint32 resultPitch = (uint32)alignTo(outputSize * width, D3D12_TEXTURE_DATA_PITCH_ALIGNMENT);

	for (uint32 h = 0; h < height; ++h)
	{
		memcpy(dest, result, destPitch);
		result += resultPitch;
		dest += destPitch;
	}

	unmapBuffer(readbackBuffer, false);



	DirectX::Image image;
	image.width = width;
	image.height = height;
	image.format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
	image.rowPitch = width * getFormatSize(image.format);
	image.slicePitch = image.rowPitch * height;
	image.pixels = output;

	saveImageToFile(path, image);


	delete[] output;
}

void copyTextureToCPUBuffer(const ref<dx_texture>& texture, void* buffer, D3D12_RESOURCE_STATES beforeAndAfterState)
{
	uint32 outputSize = getFormatSize(texture->format);

	uint32 readbackPitch = alignTo(texture->width, D3D12_TEXTURE_DATA_PITCH_ALIGNMENT);
	ref<dx_buffer> readbackBuffer = createReadbackBuffer(outputSize, readbackPitch * texture->height);

	dx_command_list* cl = dxContext.getFreeRenderCommandList();

	bool transition = false;
	if ((beforeAndAfterState & D3D12_RESOURCE_STATE_COPY_SOURCE) == 0)
	{
		cl->transitionBarrier(texture, beforeAndAfterState, D3D12_RESOURCE_STATE_GENERIC_READ);
		transition = true;
	}
	cl->copyTextureRegionToBuffer(texture->resource, texture->width, texture->format, readbackBuffer, 0, 0, 0, texture->width, texture->height);
	if (transition)
	{
		cl->transitionBarrier(texture, D3D12_RESOURCE_STATE_GENERIC_READ, beforeAndAfterState);
	}

	uint64 fence = dxContext.executeCommandList(cl);

	dxContext.renderQueue.waitForFence(fence);

	uint8* dest = (uint8*)buffer;
	uint32 destPitch = outputSize * texture->width;

	uint8* result = (uint8*)mapBuffer(readbackBuffer, true);
	uint32 resultPitch = (uint32)alignTo(outputSize * texture->width, D3D12_TEXTURE_DATA_PITCH_ALIGNMENT);

	for (uint32 h = 0; h < texture->height; ++h)
	{
		memcpy(dest, result, destPitch);
		result += resultPitch;
		dest += destPitch;
	}

	unmapBuffer(readbackBuffer, false);
}


```

`src/dx/dx_texture.h`:

```h
#pragma once

#include "dx_descriptor.h"
#include "dx_descriptor_allocation.h"
#include "core/math.h"
#include "core/job_system.h"
#include "asset/asset.h"
#include "asset/image.h"

#include <string>


struct dx_texture
{
	virtual ~dx_texture();

	dx_resource resource;
	D3D12MA::Allocation* allocation = 0;


	dx_descriptor_allocation srvUavAllocation = {};
	dx_descriptor_allocation rtvAllocation = {};
	dx_descriptor_allocation dsvAllocation = {};



	dx_cpu_descriptor_handle defaultSRV; // SRV for the whole texture (all mip levels).
	dx_cpu_descriptor_handle defaultUAV; // UAV for the first mip level.
	dx_cpu_descriptor_handle uavAt(uint32 index) { return srvUavAllocation.cpuAt(1 + index); }

	dx_cpu_descriptor_handle stencilSRV; // For depth stencil textures.


	dx_rtv_descriptor_handle defaultRTV;
	dx_rtv_descriptor_handle rtvAt(uint32 index) { return rtvAllocation.cpuAt(index); }

	dx_dsv_descriptor_handle defaultDSV;


	uint32 width, height, depth;
	DXGI_FORMAT format;

	D3D12_RESOURCE_STATES initialState;

	bool supportsRTV;
	bool supportsDSV;
	bool supportsUAV;
	bool supportsSRV;

	uint32 requestedNumMipLevels;
	uint32 numMipLevels;

	asset_handle handle;
	uint32 flags = 0;

	std::atomic<asset_load_state> loadState = asset_loaded;
	job_handle loadJob;

	void setName(const wchar* name);
	std::wstring getName() const;
};

struct dx_texture_atlas
{
	ref<dx_texture> texture;

	uint32 cols;
	uint32 rows;

	std::pair<vec2, vec2> getUVs(uint32 x, uint32 y)
	{
		ASSERT(x < cols);
		ASSERT(y < rows);

		float width = 1.f / cols;
		float height = 1.f / rows;
		vec2 uv0 = vec2(x * width, y * height);
		vec2 uv1 = vec2((x + 1) * width, (y + 1) * height);

		return { uv0, uv1 };
	}

	std::pair<vec2, vec2> getUVs(uint32 i)
	{
		uint32 x = i % cols;
		uint32 y = i / cols;
		return getUVs(x, y);
	}
};

struct dx_tiled_texture
{
	struct tiled_texture_mip_desc
	{
		CD3DX12_TILED_RESOURCE_COORDINATE startCoordinate;
		D3D12_TILE_REGION_SIZE regionSize;
	};

	ref<dx_texture> texture;
	std::vector<tiled_texture_mip_desc> mipDescs;
	D3D12_TILE_SHAPE tileShape;

	uint32 numStandard;
	uint32 numPacked;



	inline bool isMipPacked(uint32 index) { return index >= numStandard; }
};

struct texture_grave
{
	dx_resource resource;

	dx_descriptor_allocation srvUavAllocation = {};
	dx_descriptor_allocation rtvAllocation = {};
	dx_descriptor_allocation dsvAllocation = {};

	texture_grave() {}
	texture_grave(const texture_grave& o) = delete;
	texture_grave(texture_grave&& o) = default;

	texture_grave& operator=(const texture_grave& o) = delete;
	texture_grave& operator=(texture_grave&& o) = default;

	~texture_grave();
};

D3D12_RESOURCE_ALLOCATION_INFO getTextureAllocationInfo(uint32 width, uint32 height, DXGI_FORMAT format, bool allocateMips, D3D12_RESOURCE_FLAGS flags);

void uploadTextureSubresourceData(ref<dx_texture> texture, D3D12_SUBRESOURCE_DATA* subresourceData, uint32 firstSubresource, uint32 numSubresources);
ref<dx_texture> createTexture(D3D12_RESOURCE_DESC textureDesc, D3D12_SUBRESOURCE_DATA* subresourceData, uint32 numSubresources, D3D12_RESOURCE_STATES initialState = D3D12_RESOURCE_STATE_COMMON, bool mipUAVs = false);
ref<dx_texture> createTexture(const void* data, uint32 width, uint32 height, DXGI_FORMAT format, bool allocateMips = false, bool allowRenderTarget = false, bool allowUnorderedAccess = false, D3D12_RESOURCE_STATES initialState = D3D12_RESOURCE_STATE_COMMON, bool mipUAVs = false);
ref<dx_texture> createDepthTexture(uint32 width, uint32 height, DXGI_FORMAT format, uint32 arrayLength = 1, D3D12_RESOURCE_STATES initialState = D3D12_RESOURCE_STATE_DEPTH_WRITE);
ref<dx_texture> createCubeTexture(const void* data, uint32 width, uint32 height, DXGI_FORMAT format, bool allocateMips = false, bool allowRenderTarget = false, bool allowUnorderedAccess = false, D3D12_RESOURCE_STATES initialState = D3D12_RESOURCE_STATE_COMMON, bool mipUAVs = false);
ref<dx_texture> createVolumeTexture(const void* data, uint32 width, uint32 height, uint32 depth, DXGI_FORMAT format, bool allowUnorderedAccess = false, D3D12_RESOURCE_STATES initialState = D3D12_RESOURCE_STATE_COMMON);
void resizeTexture(ref<dx_texture> texture, uint32 newWidth, uint32 newHeight, D3D12_RESOURCE_STATES initialState = (D3D12_RESOURCE_STATES )-1);

ref<dx_texture> createPlacedTexture(dx_heap heap, uint64 offset, uint32 width, uint32 height, DXGI_FORMAT format, bool allocateMips = false, bool allowRenderTarget = false, bool allowUnorderedAccess = false, D3D12_RESOURCE_STATES initialState = D3D12_RESOURCE_STATE_COMMON, bool mipUAVs = false);
ref<dx_texture> createPlacedTexture(dx_heap heap, uint64 offset, D3D12_RESOURCE_DESC textureDesc, D3D12_RESOURCE_STATES initialState = D3D12_RESOURCE_STATE_COMMON, bool mipUAVs = false);

ref<dx_texture> createPlacedDepthTexture(dx_heap heap, uint64 offset, uint32 width, uint32 height, DXGI_FORMAT format, uint32 arrayLength = 1, D3D12_RESOURCE_STATES initialState = D3D12_RESOURCE_STATE_DEPTH_WRITE, bool allowDepthStencil = true);
ref<dx_texture> createPlacedDepthTexture(dx_heap heap, uint64 offset, D3D12_RESOURCE_DESC textureDesc, D3D12_RESOURCE_STATES initialState = D3D12_RESOURCE_STATE_DEPTH_WRITE);

dx_tiled_texture createTiledTexture(D3D12_RESOURCE_DESC textureDesc, D3D12_RESOURCE_STATES initialState = D3D12_RESOURCE_STATE_COMMON, bool mipUAVs = false);
dx_tiled_texture createTiledTexture(uint32 width, uint32 height, DXGI_FORMAT format, bool allocateMips = false, bool allowRenderTarget = false, bool allowUnorderedAccess = false, D3D12_RESOURCE_STATES initialState = D3D12_RESOURCE_STATE_COMMON, bool mipUAVs = false);

// This system caches textures. It does not keep the resource alive (we store weak ptrs).
// So if no one else has a reference, the texture gets deleted.
// This means you should keep a reference to your textures yourself and not call this every frame.
// TODO: Maybe we want to keep the texture around for a couple more frames?

ref<dx_texture> loadTextureFromFile(const fs::path& filename, uint32 flags = image_load_flags_default);
ref<dx_texture> loadTextureFromHandle(asset_handle handle, uint32 flags = image_load_flags_default);
ref<dx_texture> loadTextureFromFileAsync(const fs::path& filename, uint32 flags = image_load_flags_default, job_handle parentJob = {});
ref<dx_texture> loadTextureFromHandleAsync(asset_handle handle, uint32 flags = image_load_flags_default, job_handle parentJob = {});

ref<dx_texture> loadTextureFromMemory(const void* ptr, uint32 size, image_format imageFormat, const fs::path& cacheFilename, uint32 flags = image_load_flags_default);
ref<dx_texture> loadVolumeTextureFromDirectory(const fs::path& dirname, uint32 flags = image_load_flags_compress | image_load_flags_cache_to_dds | image_load_flags_noncolor);

void copyTextureToCPUBuffer(const ref<dx_texture>& texture, void* buffer, D3D12_RESOURCE_STATES beforeAndAfterState = D3D12_RESOURCE_STATE_COMMON);
void saveTextureToFile(const ref<dx_texture>& texture, const fs::path& path);
void saveTextureToFile(dx_resource texture, uint32 width, uint32 height, DXGI_FORMAT format, const fs::path& path);

```

`src/dx/dx_upload_buffer.cpp`:

```cpp
#include "pch.h"
#include "dx_upload_buffer.h"
#include "core/memory.h"
#include "dx_context.h"

dx_page* dx_page_pool::allocateNewPage()
{
	mutex.lock();
	dx_page* result = arena.allocate<dx_page>(1, true);
	mutex.unlock();

	auto desc = CD3DX12_RESOURCE_DESC::Buffer(pageSize);
	CD3DX12_HEAP_PROPERTIES props(D3D12_HEAP_TYPE_UPLOAD);
	checkResult(dxContext.device->CreateCommittedResource(
		&props,
		D3D12_HEAP_FLAG_NONE,
		&desc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&result->buffer)
	));

	result->gpuBasePtr = result->buffer->GetGPUVirtualAddress();
	result->buffer->Map(0, 0, (void**)&result->cpuBasePtr);
	result->pageSize = pageSize;

	return result;
}

dx_page* dx_page_pool::getFreePage()
{
	mutex.lock();
	dx_page* result = freePages;
	if (result)
	{
		freePages = result->next;
	}
	mutex.unlock();

	if (!result)
	{
		result = allocateNewPage();
	}

	result->currentOffset = 0;

	return result;
}

void dx_page_pool::returnPage(dx_page* page)
{
	mutex.lock();
	page->next = usedPages;
	usedPages = page;
	if (!lastUsedPage)
	{
		lastUsedPage = page;
	}
	mutex.unlock();
}

void dx_page_pool::reset()
{
	if (lastUsedPage)
	{
		lastUsedPage->next = freePages;
	}
	freePages = usedPages;
	usedPages = 0;
	lastUsedPage = 0;
}




dx_allocation dx_upload_buffer::allocate(uint64 size, uint64 alignment)
{
	ASSERT(size <= pagePool->pageSize);

	uint64 alignedOffset = currentPage ? alignTo(currentPage->currentOffset, alignment) : 0;

	dx_page* page = currentPage;
	if (!page || alignedOffset + size > page->pageSize)
	{
		page = pagePool->getFreePage();
		alignedOffset = 0;

		if (currentPage)
		{
			pagePool->returnPage(currentPage);
		}
		currentPage = page;
	}

	dx_allocation result;
	result.cpuPtr = page->cpuBasePtr + alignedOffset;
	result.gpuPtr = page->gpuBasePtr + alignedOffset;
	result.resource = page->buffer;
	result.offsetInResource = (uint32)alignedOffset;

	page->currentOffset = alignedOffset + size;

	return result;
}

void dx_upload_buffer::reset()
{
	if (currentPage && pagePool)
	{
		pagePool->returnPage(currentPage);
	}
	currentPage = 0;
}

void dx_page_pool::initialize(uint32 sizeInBytes)
{
	pageSize = sizeInBytes;
	arena.initialize(0, sizeof(dx_page) * 512);
}


```

`src/dx/dx_upload_buffer.h`:

```h
#pragma once

#include "dx.h"
#include "core/memory.h"

struct dx_allocation
{
	void* cpuPtr;
	D3D12_GPU_VIRTUAL_ADDRESS gpuPtr;

	dx_resource resource;
	uint32 offsetInResource;
};

struct dx_page
{
	dx_resource buffer;
	dx_page* next;

	uint8* cpuBasePtr;
	D3D12_GPU_VIRTUAL_ADDRESS gpuBasePtr;

	uint64 pageSize;
	uint64 currentOffset;
};

struct dx_page_pool
{
	void initialize(uint32 sizeInBytes);

	memory_arena arena;

	std::mutex mutex;

	uint64 pageSize;
	dx_page* freePages;
	dx_page* usedPages;
	dx_page* lastUsedPage;

	dx_page* getFreePage();
	void returnPage(dx_page* page);
	void reset();

private:
	dx_page* allocateNewPage();
};

struct dx_upload_buffer
{
	dx_page_pool* pagePool = 0;
	dx_page* currentPage = 0;

	dx_allocation allocate(uint64 size, uint64 alignment);
	void reset();
};

```

`src/editor/asset_editor_panel.cpp`:

```cpp
#include "pch.h"
#include "asset_editor_panel.h"
#include "core/imgui.h"
#include "geometry/mesh.h"
#include "animation/animation.h"
#include "editor_icons.h"

void asset_editor_panel::beginFrame()
{
	windowOpen = windowOpenInternal;

	if (windowOpen)
	{
		ImGui::SetNextWindowSize(ImVec2(1280, 800), ImGuiCond_FirstUseEver);
		if (ImGui::Begin(title, &windowOpenInternal, ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse))
		{
			if (ImGui::BeginTable("##table", 2, ImGuiTableFlags_BordersInnerV | ImGuiTableFlags_Resizable))
			{
				ImGui::TableSetupColumn("ViewportColumn");
				ImGui::TableSetupColumn("SettingsColumn", ImGuiTableColumnFlags_WidthFixed, 300);

				ImVec2 contentSize;

				if (ImGui::TableNextColumn())
				{
					contentSize = ImGui::GetContentRegionAvail();
					ref<dx_texture> rendering = getRendering();
					if (rendering)
					{
						ImVec2 minCorner = ImGui::GetCursorPos();
						ImGui::Image(rendering, (uint32)contentSize.x, (uint32)contentSize.y);

						ImGui::SetCursorPos(ImVec2(minCorner.x + 4.5f, minCorner.y + 4.5f));
						ImGui::Dummy(ImVec2(contentSize.x - 9.f, contentSize.y - 9.f));

						if (dragDropTarget && ImGui::BeginDragDropTarget())
						{
							if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload(dragDropTarget)) { setDragDropData(payload->Data, payload->DataSize); }
							ImGui::EndDragDropTarget();
						}
					}
				}

				if (ImGui::TableNextColumn())
				{
					edit((uint32)contentSize.x, (uint32)contentSize.y);
				}

				ImGui::EndTable();
			}
		}
		ImGui::End();
	}
}

void asset_editor_panel::open()
{
	windowOpenInternal = true;
}

void asset_editor_panel::close()
{
	windowOpenInternal = false;
}


mesh_editor_panel::mesh_editor_panel()
{
	title = EDITOR_ICON_MESH "  Mesh editor";
	dragDropTarget = EDITOR_ICON_MESH;

	renderer_spec spec = { false, false, false, false, false, false };

	renderer.initialize(color_depth_8, 1280, 800, spec);

	camera.initializeIngame(vec3(0.f, 0.f, 25.f), quat::identity, deg2rad(70.f), 0.01f);
}

void mesh_editor_panel::edit(uint32 renderWidth, uint32 renderHeight)
{
	renderer.beginFrame(renderWidth, renderHeight);
	camera.setViewport(renderWidth, renderHeight);
	camera.updateMatrices();

	renderPass.reset();


	if (this->mesh)
	{
		const dx_mesh& mesh = this->mesh->mesh;

		for (auto& sm : this->mesh->submeshes)
		{
			submesh_info submesh = sm.info;
			const ref<pbr_material>& material = sm.material;

			//renderPass.renderStaticObject(mat4::identity, mesh.vertexBuffer, mesh.indexBuffer, submesh, material);
		}
	}



	renderer.submitRenderPass(&renderPass);
	renderer.setCamera(camera);


	if (ImGui::BeginTabBar("Tabs"))
	{
		if (ImGui::BeginTabItem("Geometry"))
		{
			if (ImGui::BeginChild("GeometrySettings"))
			{
				ImGui::Text("Geometry settings will go here");
			}
			ImGui::EndChild();

			ImGui::EndTabItem();
		}

		if (ImGui::BeginTabItem("Animations"))
		{
			if (ImGui::BeginChild("AnimationSettings"))
			{
				ImGui::Text("Animation settings will go here");
			}
			ImGui::EndChild();

			ImGui::EndTabItem();
		}

		ImGui::EndTabBar();
	}
}

void mesh_editor_panel::endFrame()
{
	if (isOpen())
	{
		renderer.endFrame(0);
	}
}

ref<dx_texture> mesh_editor_panel::getRendering()
{
	return renderer.frameResult;
}

void mesh_editor_panel::setDragDropData(void* data, uint32 size)
{
	const char* filename = (const char*)data;

	fs::path path = filename;
	fs::path relative = fs::relative(path, fs::current_path());

	this->mesh = loadMeshFromFile(relative.string());
}


```

`src/editor/asset_editor_panel.h`:

```h
#pragma once

#include "dx/dx_texture.h"
#include "core/camera.h"
#include "rendering/main_renderer.h"


struct asset_editor_panel
{
	void beginFrame();
	virtual void endFrame() {}

	bool isOpen() const { return windowOpen; }
	void open();
	void close();

protected:
	const char* title;
	const char* dragDropTarget;

private:
	virtual void edit(uint32 renderWidth, uint32 renderHeight) = 0;
	virtual ref<dx_texture> getRendering() = 0;
	virtual void setDragDropData(void* data, uint32 size) {}
	
	bool windowOpen = false;
	bool windowOpenInternal = false;
};

struct mesh_editor_panel : asset_editor_panel
{
	mesh_editor_panel();

	virtual void endFrame() override;

private:
	virtual void edit(uint32 renderWidth, uint32 renderHeight) override;
	virtual ref<dx_texture> getRendering() override;
	virtual void setDragDropData(void* data, uint32 size) override;

	render_camera camera;
	ref<multi_mesh> mesh;
	main_renderer renderer;

	opaque_render_pass renderPass;
};


struct editor_panels
{
	mesh_editor_panel meshEditor;
};



```

`src/editor/editor.cpp`:

```cpp
#include "pch.h"
#include "editor.h"
#include "editor_icons.h"
#include "core/cpu_profiling.h"
#include "core/log.h"
#include "asset/file_registry.h"
#include "core/imgui.h"
#include "dx/dx_profiling.h"
#include "scene/components.h"
#include "animation/animation.h"
#include "geometry/mesh.h"
#include "physics/ragdoll.h"
#include "physics/vehicle.h"
#include "scene/serialization_yaml.h"
#include "scene/serialization_binary.h"
#include "audio/audio.h"
#include "rendering/debug_visualization.h"
#include "terrain/terrain.h"
#include "terrain/proc_placement.h"
#include "terrain/grass.h"
#include "terrain/water.h"

#include <fontawesome/list.h>
#include <sstream>



static vec3 getEuler(quat q)
{
	vec3 euler = quatToEuler(q);
	euler.x = rad2deg(angleToZeroToTwoPi(euler.x));
	euler.y = rad2deg(angleToZeroToTwoPi(euler.y));
	euler.z = rad2deg(angleToZeroToTwoPi(euler.z));
	return euler;
}

static quat getQuat(vec3 euler)
{
	euler.x = deg2rad(euler.x);
	euler.y = deg2rad(euler.y);
	euler.z = deg2rad(euler.z);
	return eulerToQuat(euler);
}



template <typename component_t, typename member_t>
struct component_member_undo
{
	component_member_undo(member_t& member, member_t before, scene_entity entity, void (*callback)(component_t&, member_t, void*) = 0, void* userData = 0)
	{
		this->entity = entity;
		this->byteOffset = (uint8*)&member - (uint8*)&entity.getComponent<component_t>();
		this->before = before;
		this->callback = callback;
		this->userData = userData;
	}

	void toggle()
	{
		if (entity.valid())
		{
			component_t& comp = entity.getComponent<component_t>();
			auto& member = *(member_t*)((uint8*)&comp + byteOffset);
			std::swap(member, before);

			if (callback)
			{
				callback(comp, member, userData);
			}
		}
	}

private:
	scene_entity entity;
	uint64 byteOffset;

	member_t before;

	void (*callback)(component_t&, member_t, void*) = 0;
	void* userData = 0;
};

template <typename... component_t>
struct component_undo
{
	component_undo(scene_entity entity, component_t... before)
	{
		this->entity = entity;
		this->before = std::make_tuple(before...);
	}

	void toggle()
	{
		if (entity.valid())
		{
			std::apply([this](auto&... c) { (set(c), ...); }, before);
		}
	}

private:
	template <typename T>
	void set(T& c)
	{
		std::swap(entity.getComponent<T>(), c);
	}

	scene_entity entity;

	std::tuple<component_t...> before;
};

template <typename value_t>
struct settings_undo
{
	settings_undo(value_t& value, value_t before)
		: value(value), before(before) {}

	void toggle() { std::swap(value, before); }

private:
	value_t& value;

	value_t before;
};

struct entity_existence_undo
{
	entity_existence_undo(game_scene& scene, scene_entity entity)
		: scene(scene), entity(entity)
	{
		size = serializeEntityToMemory(entity, buffer, sizeof(buffer));
	}

	void toggle()
	{
		if (entity.valid()) { deleteEntity(); }
		else { restoreEntity(); }
	}

private:
	void deleteEntity()
	{
		size = serializeEntityToMemory(entity, buffer, sizeof(buffer));
		scene.deleteEntity(entity);
	}

	void restoreEntity()
	{
		entity_handle place = entity.handle;
		entity = scene.tryCreateEntityInPlace(entity, "");
		ASSERT(entity.handle == place);

		bool success = deserializeEntityFromMemory(entity, buffer, size);
		ASSERT(success);
	}

	game_scene& scene;
	scene_entity entity;
	uint8 buffer[1024];
	uint64 size;
};



template <typename value_t, typename action_t, typename... args_t>
void scene_editor::undoable(const char* undoLabel, value_t before, value_t& value, 
	args_t... args)
{
	if (ImGui::IsItemActive() && !ImGui::IsItemActiveLastFrame())
	{
		currentUndoBuffer->as<value_t>() = before;
	}

	bool changed = ImGui::IsItemDeactivatedAfterEdit();
	if constexpr (std::is_enum_v<value_t> || std::is_integral_v<value_t>)
	{
		changed |= (!ImGui::IsItemActive() && (before != value));
	}

	if (changed)
	{
		std::stringstream s;
		s << std::setprecision(4) << std::boolalpha;
		s << undoLabel << " from " << currentUndoBuffer->as<value_t>() << " to " << value;
		action_t action(value, currentUndoBuffer->as<value_t>(), std::forward<args_t>(args)...);
		currentUndoStack->pushAction(s.str().c_str(), action);
	}
}

#define UNDOABLE_COMPONENT_SETTING(undoLabel, val, command, ...)					\
	{																				\
		using value_t = std::decay_t<decltype(val)>;								\
		value_t before = val;														\
		command;																	\
		undoable<value_t, component_member_undo<component_t, value_t>>(undoLabel,	\
			before, val, selectedEntity, __VA_ARGS__);								\
	}

#define UNDOABLE_SETTING(undoLabel, val, command)									\
	{																				\
		using value_t = std::decay_t<decltype(val)>;								\
		value_t before = val;														\
		command;																	\
		undoable<value_t, settings_undo<value_t>>(undoLabel,						\
			before, val);															\
	}


void scene_editor::updateSelectedEntityUIRotation()
{
	if (selectedEntity)
	{
		quat rotation = quat::identity;

		if (transform_component* transform = selectedEntity.getComponentIfExists<transform_component>())
		{
			rotation = transform->rotation;
		}
		else if (position_rotation_component* prc = selectedEntity.getComponentIfExists<position_rotation_component>())
		{
			rotation = prc->rotation;
		}

		selectedEntityEulerRotation = getEuler(rotation);
	}
}

void scene_editor::setSelectedEntity(scene_entity entity)
{
	selectedEntity = entity;
	updateSelectedEntityUIRotation();
	selectedColliderEntity = {};
	selectedConstraintEntity = {};
}

void scene_editor::initialize(editor_scene* scene, main_renderer* renderer, editor_panels* editorPanels)
{
	this->scene = scene;
	this->renderer = renderer;
	this->editorPanels = editorPanels;
	cameraController.initialize(&scene->camera);

	systemInfo = getSystemInfo();
}

bool scene_editor::update(const user_input& input, ldr_render_pass* ldrRenderPass, float dt)
{
	CPU_PROFILE_BLOCK("Update editor");

	currentUndoStack = &undoStacks[this->scene->mode > 0];
	currentUndoBuffer = &undoBuffers[this->scene->mode > 0];

	auto selectedEntityBefore = selectedEntity;

	auto& scene = this->scene->getCurrentScene();

	// Clear selected entity, if it became invalid (e.g. if it was deleted).
	if (selectedEntity && !scene.isEntityValid(selectedEntity))
	{
		setSelectedEntity({});
	}

	bool objectChanged = false;
	objectChanged |= handleUserInput(input, ldrRenderPass, dt);
	objectChanged |= drawSceneHierarchy();
	objectChanged |= drawMainMenuBar();
	drawSettings(dt);

	if (objectChanged)
	{
		onObjectMoved();
	}

	// This is triggered on undo.
	if (selectedEntity != selectedEntityBefore)
	{
		setSelectedEntity(selectedEntity);
	}


	if (selectedConstraintEntity)
	{
		if (auto* ref = selectedConstraintEntity.getComponentIfExists<constraint_entity_reference_component>())
		{
			scene_entity entityA = { ref->entityA, scene };
			scene_entity entityB = { ref->entityB, scene };

			const trs& transformA = entityA.getComponent<transform_component>();
			const trs& transformB = entityB.getComponent<transform_component>();

			const vec4 constraintColor(1.f, 1.f, 0.f, 1.f);

			if (distance_constraint* c = selectedConstraintEntity.getComponentIfExists<distance_constraint>())
			{
				vec3 a = transformPosition(transformA, c->localAnchorA);
				vec3 b = transformPosition(transformB, c->localAnchorB);
				vec3 center = 0.5f * (a + b);
				vec3 d = normalize(b - a);
				a -= d * (c->globalLength * 0.5f);
				b += d * (c->globalLength * 0.5f);

				renderLine(a, b, constraintColor, ldrRenderPass, true);
			}
			else if (ball_constraint* c = selectedConstraintEntity.getComponentIfExists<ball_constraint>())
			{

			}
			else if (fixed_constraint* c = selectedConstraintEntity.getComponentIfExists<fixed_constraint>())
			{

			}
			else if (hinge_constraint* c = selectedConstraintEntity.getComponentIfExists<hinge_constraint>())
			{
				vec3 pos = transformPosition(transformA, c->localAnchorA);
				vec3 hingeAxis = transformDirection(transformA, c->localHingeAxisA);
				vec3 zeroDegAxis = transformDirection(transformB, c->localHingeTangentB);
				vec3 localHingeCompareA = conjugate(transformA.rotation) * (transformB.rotation * c->localHingeTangentB);
				float curAngle = atan2(dot(localHingeCompareA, c->localHingeBitangentA), dot(localHingeCompareA, c->localHingeTangentA));
				float minAngle = c->minRotationLimit - curAngle;
				float maxAngle = c->maxRotationLimit - curAngle;

				renderAngleRing(pos, hingeAxis, 0.2f, 0.17f, zeroDegAxis, minAngle, maxAngle, constraintColor, ldrRenderPass, true);
				renderLine(pos, pos + hingeAxis * 0.2f, constraintColor, ldrRenderPass, true);
			}
			else if (cone_twist_constraint* c = selectedConstraintEntity.getComponentIfExists<cone_twist_constraint>())
			{

			}
			else if (slider_constraint* c = selectedConstraintEntity.getComponentIfExists<slider_constraint>())
			{

			}
		}
	}

	return objectChanged;
}

static void drawIconsWindow(bool& open)
{
	if (open)
	{
		if (ImGui::Begin(ICON_FA_ICONS "  Icons", &open))
		{
			static ImGuiTextFilter filter;
			filter.Draw();

			if (ImGui::BeginChild("Icons List"))
			{
				for (uint32 i = 0; i < arraysize(awesomeIcons); ++i)
				{
					ImGui::PushID(i);
					if (filter.PassFilter(awesomeIconNames[i]))
					{
						ImGui::Text("%s: %s", awesomeIconNames[i], awesomeIcons[i]);
						ImGui::SameLine();
						if (ImGui::Button("Copy to clipboard"))
						{
							ImGui::SetClipboardText(awesomeIconNames[i]);
						}
					}
					ImGui::PopID();
				}
			}
			ImGui::EndChild();
		}
		ImGui::End();
	}
}

bool scene_editor::drawMainMenuBar()
{
	static bool iconsWindowOpen = false;
	static bool demoWindowOpen = false;
	static bool undoWindowOpen = false;
	static bool soundEditorWindowOpen = false;

	bool objectPotentiallyMoved = false;

	bool controlsClicked = false;
	bool aboutClicked = false;
	bool systemClicked = false;

	if (ImGui::BeginMainMenuBar())
	{
		if (ImGui::BeginMenu(ICON_FA_FILE "  File"))
		{
			char textBuffer[128];
			auto [undoPossible, undoName] = currentUndoStack->undoPossible();
			snprintf(textBuffer, sizeof(textBuffer), ICON_FA_UNDO " Undo %s", undoPossible ? undoName : "");
			if (ImGui::MenuItem(textBuffer, "Ctrl+Z", false, undoPossible))
			{
				currentUndoStack->undo();
				objectPotentiallyMoved = true;
			}

			auto [redoPossible, redoName] = currentUndoStack->redoPossible();
			snprintf(textBuffer, sizeof(textBuffer), ICON_FA_REDO " Redo %s", redoPossible ? redoName : "");
			if (ImGui::MenuItem(textBuffer, "Ctrl+Y", false, redoPossible))
			{
				currentUndoStack->redo();
				objectPotentiallyMoved = true;
			}

			if (ImGui::MenuItem(undoWindowOpen ? (ICON_FA_HISTORY "  Hide undo history") : (ICON_FA_HISTORY "  Show undo history")))
			{
				undoWindowOpen = !undoWindowOpen;
			}
			ImGui::Separator();

			if (ImGui::MenuItem(ICON_FA_SAVE "  Save scene", "Ctrl+S"))
			{
				serializeToFile();
			}

			if (ImGui::MenuItem(ICON_FA_FOLDER_OPEN "  Load scene", "Ctrl+O"))
			{
				deserializeFromFile();
			}

			ImGui::Separator();
			if (ImGui::MenuItem(ICON_FA_TIMES "  Exit", "Esc"))
			{
				PostQuitMessage(0);
			}
			ImGui::EndMenu();
		}

		if (ImGui::BeginMenu(ICON_FA_TOOLS "  Developer"))
		{
			if (ImGui::MenuItem(iconsWindowOpen ? (ICON_FA_ICONS "  Hide available icons") : (ICON_FA_ICONS "  Show available icons")))
			{
				iconsWindowOpen = !iconsWindowOpen;
			}

			if (ImGui::MenuItem(demoWindowOpen ? (ICON_FA_PUZZLE_PIECE "  Hide demo window") : (ICON_FA_PUZZLE_PIECE "  Show demo window")))
			{
				demoWindowOpen = !demoWindowOpen;
			}

			ImGui::Separator();

			if (ImGui::MenuItem(dxProfilerWindowOpen ? (ICON_FA_CHART_BAR "  Hide GPU profiler") : (ICON_FA_CHART_BAR "  Show GPU profiler"), nullptr, nullptr, ENABLE_DX_PROFILING))
			{
				dxProfilerWindowOpen = !dxProfilerWindowOpen;
			}

			if (ImGui::MenuItem(cpuProfilerWindowOpen ? (ICON_FA_CHART_LINE "  Hide CPU profiler") : (ICON_FA_CHART_LINE "  Show CPU profiler"), nullptr, nullptr, ENABLE_CPU_PROFILING))
			{
				cpuProfilerWindowOpen = !cpuProfilerWindowOpen;
			}

			ImGui::Separator();

			if (ImGui::MenuItem(logWindowOpen ? (ICON_FA_CLIPBOARD_LIST "  Hide message log") : (ICON_FA_CLIPBOARD_LIST "  Show message log"), "Ctrl+L", nullptr, ENABLE_MESSAGE_LOG))
			{
				logWindowOpen = !logWindowOpen;
			}

			ImGui::Separator();

			if (ImGui::MenuItem(soundEditorWindowOpen ? (EDITOR_ICON_AUDIO "  Hide sound editor") : (EDITOR_ICON_AUDIO "  Show sound editor")))
			{
				soundEditorWindowOpen = !soundEditorWindowOpen;
			}

			if (ImGui::MenuItem(editorPanels->meshEditor.isOpen() ? (EDITOR_ICON_MESH "  Hide mesh editor") : (EDITOR_ICON_MESH "  Show mesh editor")))
			{
				editorPanels->meshEditor.isOpen() ? editorPanels->meshEditor.close() : editorPanels->meshEditor.open();
			}

			ImGui::Separator();

			if (ImGui::MenuItem(ICON_FA_DESKTOP "  System"))
			{
				systemClicked = true;
			}

			ImGui::EndMenu();
		}

		if (ImGui::BeginMenu(ICON_FA_CHILD "  Help"))
		{
			if (ImGui::MenuItem(ICON_FA_COMPASS "  Controls"))
			{
				controlsClicked = true;
			}

			if (ImGui::MenuItem(ICON_FA_QUESTION "  About"))
			{
				aboutClicked = true;
			}

			ImGui::EndMenu();
		}

		ImGui::EndMainMenuBar();
	}

	ImVec2 center = ImGui::GetMainViewport()->GetCenter();

	if (systemClicked)
	{
		ImGui::OpenPopup(ICON_FA_DESKTOP "  System");
	}

	ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
	if (ImGui::BeginPopupModal(ICON_FA_DESKTOP "  System", 0, ImGuiWindowFlags_AlwaysAutoResize))
	{
		ImGui::Value("CPU", systemInfo.cpuName.c_str());
		ImGui::Value("GPU", systemInfo.gpuName.c_str());

		ImGui::Separator();

		ImGui::PopupOkButton();
		ImGui::EndPopup();
	}

	if (controlsClicked)
	{
		ImGui::OpenPopup(ICON_FA_COMPASS "  Controls");
	}

	ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
	if (ImGui::BeginPopupModal(ICON_FA_COMPASS "  Controls", 0, ImGuiWindowFlags_AlwaysAutoResize))
	{
		ImGui::Text("The camera can be controlled in two modes:");
		ImGui::BulletText(
			"Free flying: Hold the right mouse button and move the mouse to turn.\n"
			"Move with WASD (while holding right mouse). Q & E let you move down and up.\n"
			"Holding Shift will make you fly faster, Ctrl will make you slower."
		);
		ImGui::BulletText(
			"Orbit: While holding Alt, press and hold the left mouse button to\n"
			"orbit around a point in front of the camera. Hold the middle mouse button \n"
			"to pan."
		);
		ImGui::Separator();
		ImGui::Text(
			"Left-click on objects to select them. Toggle through gizmos using\n"
			"Q (no gizmo), W (translate), E (rotate), R (scale).\n"
			"Press G to toggle between global and local coordinate system.\n"
			"You can also change the object's transform in the Scene Hierarchy window."
		);
		ImGui::Separator();
		ImGui::Text(
			"Press F to focus the camera on the selected object. This automatically\n"
			"sets the orbit distance such that you now orbit around this object (with alt, see above)."
		);
		ImGui::Separator();
		ImGui::Text(
			"Press V to toggle Vsync on or off."
		);
		ImGui::Separator();
		ImGui::Text(
			"You can drag and drop meshes from the asset window at the bottom into the scene\n"
			"window to add it to the scene."
		);
		ImGui::Separator();
		ImGui::Text(
			"Press the Print key to capture a screenshot of the scene viewport or Ctrl+Print to capture\n"
			"one including the editor UI."
		);
		ImGui::Separator();

		ImGui::PopupOkButton();
		ImGui::EndPopup();
	}

	if (aboutClicked)
	{
		ImGui::OpenPopup(ICON_FA_QUESTION "  About");
	}

	ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
	if (ImGui::BeginPopupModal(ICON_FA_QUESTION "  About", 0, ImGuiWindowFlags_AlwaysAutoResize))
	{
		ImGui::Dummy(ImVec2(300.f, 1.f));
		ImGui::CenteredText("Direct3D renderer");
		ImGui::CenteredText("written from scratch by Philipp Kurth");

		ImGui::Separator();

		ImGui::PopupOkButton();
		ImGui::EndPopup();
	}

	if (demoWindowOpen)
	{
		ImGui::ShowDemoWindow(&demoWindowOpen);
	}

	drawIconsWindow(iconsWindowOpen);
	drawSoundEditor(soundEditorWindowOpen);
	objectPotentiallyMoved |= currentUndoStack->showHistory(undoWindowOpen);

	return objectPotentiallyMoved;
}

template<typename component_t, typename ui_func>
static void drawComponent(scene_entity entity, const char* componentName, ui_func func)
{
	const ImGuiTreeNodeFlags treeNodeFlags = ImGuiTreeNodeFlags_DefaultOpen | ImGuiTreeNodeFlags_Framed | ImGuiTreeNodeFlags_SpanAvailWidth | ImGuiTreeNodeFlags_AllowItemOverlap | ImGuiTreeNodeFlags_FramePadding;
	if (auto* component = entity.getComponentIfExists<component_t>())
	{
		ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2{ 4, 4 });
		bool open = ImGui::TreeNodeEx(componentName, treeNodeFlags, componentName);
		ImGui::PopStyleVar();

		if (open)
		{
			func(*component);
			ImGui::TreePop();
		}
	}
}

static bounding_box getObjectBoundingBox(scene_entity entity, bool applyPosition)
{
	bounding_box aabb = entity.hasComponent<mesh_component>() ? entity.getComponent<mesh_component>().mesh->aabb : bounding_box::fromCenterRadius(0.f, 1.f);

	if (transform_component* transform = entity.getComponentIfExists<transform_component>())
	{
		aabb.minCorner *= transform->scale;
		aabb.maxCorner *= transform->scale;

		if (applyPosition)
		{
			aabb.minCorner += transform->position;
			aabb.maxCorner += transform->position;
		}
	}
	else if (position_component* transform = entity.getComponentIfExists<position_component>())
	{
		if (applyPosition)
		{
			aabb.minCorner += transform->position;
			aabb.maxCorner += transform->position;
		}
	}
	else if (position_rotation_component* transform = entity.getComponentIfExists<position_rotation_component>())
	{
		if (applyPosition)
		{
			aabb.minCorner += transform->position;
			aabb.maxCorner += transform->position;
		}
	}

	return aabb;
}

static void editTexture(const char* name, ref<dx_texture>& tex, uint32 loadFlags)
{
	asset_handle asset = {};
	if (tex)
	{
		asset = tex->handle;
	}
	if (ImGui::PropertyTextureAssetHandle(name, EDITOR_ICON_IMAGE, asset, tex))
	{
		fs::path path = getPathFromAssetHandle(asset);
		fs::path relative = fs::relative(path, fs::current_path());
		if (auto newTex = loadTextureFromFileAsync(relative.string(), loadFlags))
		{
			tex = newTex;
		}
	}
}

static void editMesh(const char* name, ref<multi_mesh>& mesh, uint32 loadFlags)
{
	asset_handle asset = {};
	if (mesh)
	{
		asset = mesh->handle;
	}
	if (ImGui::PropertyAssetHandle(name, EDITOR_ICON_MESH, asset))
	{
		fs::path path = getPathFromAssetHandle(asset);
		fs::path relative = fs::relative(path, fs::current_path());
		if (auto newMesh = loadMeshFromFile(relative.string(), loadFlags))
		{
			mesh = newMesh;
		}
	}
}

static void editMaterial(const ref<pbr_material>& material)
{
	if (ImGui::BeginProperties())
	{
		asset_handle dummy = {};

		editTexture("Albedo", material->albedo, image_load_flags_default);
		editTexture("Normal", material->normal, image_load_flags_default_noncolor);
		editTexture("Roughness", material->roughness, image_load_flags_default_noncolor);
		editTexture("Metallic", material->metallic, image_load_flags_default_noncolor);

		ImGui::PropertyColor("Emission", material->emission);
		ImGui::PropertyColor("Albedo tint", material->albedoTint);
		ImGui::PropertyDropdown("Shader", pbrMaterialShaderNames, pbr_material_shader_count, (uint32&)material->shader);
		ImGui::PropertySlider("UV scale", material->uvScale);
		ImGui::PropertySlider("Translucency", material->translucency);

		if (!material->roughness)
		{
			ImGui::PropertySlider("Roughness override", material->roughnessOverride);
		}
		if (!material->metallic)
		{
			ImGui::PropertySlider("Metallic override", material->metallicOverride);
		}

		ImGui::EndProperties();
	}
}

bool scene_editor::drawSceneHierarchy()
{
	game_scene& scene = this->scene->getCurrentScene();

	bool objectMovedByWidget = false;

	if (ImGui::Begin("Scene Hierarchy"))
	{
		if (ImGui::BeginChild("Outliner", ImVec2(0, 250)))
		{
			scene.view<tag_component>()
				.each([this, &scene](auto entityHandle, tag_component& tag)
			{
				ImGui::PushID((uint32)entityHandle);
				const char* name = tag.name;
				scene_entity entity = { entityHandle, scene };

				if (ImGui::Selectable(name, entity == selectedEntity))
				{
					setSelectedEntity(entity);
				}

				bool entityDeleted = false;
				if (ImGui::BeginPopupContextItem(name))
				{
					if (ImGui::MenuItem("Delete"))
					{
						entityDeleted = true;
					}

					ImGui::EndPopup();
				}

				if (entityDeleted)
				{
					if (entity == selectedEntity)
					{
						setSelectedEntity({});
					}
					currentUndoStack->pushAction("entity deletion", entity_existence_undo(scene, entity));
					scene.deleteEntity(entity);
				}
				ImGui::PopID();
			});
		}
		ImGui::EndChild();
		ImGui::Separator();

		if (selectedEntity)
		{
			ImGui::Dummy(ImVec2(0, 20));
			ImGui::Separator();
			ImGui::Separator();
			ImGui::Separator();

			if (ImGui::BeginChild("Components"))
			{
				ImGui::AlignTextToFramePadding();

				ImGui::PushID((uint32)selectedEntity);

				{
					tag_component& tag = selectedEntity.getComponent<tag_component>();
					tag_component tagBefore = tag;
					ImGui::InputText("Name", tag.name, sizeof(tag_component::name));

					if (ImGui::IsItemActive() && !ImGui::IsItemActiveLastFrame())
					{
						currentUndoBuffer->as<tag_component>() = tagBefore;
					}
					if (ImGui::IsItemDeactivatedAfterEdit())
					{
						currentUndoStack->pushAction("entity name", component_undo<tag_component>(selectedEntity, currentUndoBuffer->as<tag_component>()));
					}
				}

				ImGui::PopID();



				ImGui::SameLine();
				if (ImGui::Button(ICON_FA_TRASH_ALT))
				{
					currentUndoStack->pushAction("entity deletion", entity_existence_undo(scene, selectedEntity));
					scene.deleteEntity(selectedEntity);
					setSelectedEntity({});
					objectMovedByWidget = true;
				}
				if (ImGui::IsItemHovered())
				{
					ImGui::SetTooltip("Delete entity");
				}
				if (selectedEntity)
				{
					drawComponent<transform_component>(selectedEntity, "TRANSFORM", [this, &objectMovedByWidget](transform_component& transform)
					{
						using component_t = transform_component;

						UNDOABLE_COMPONENT_SETTING("entity position", transform.position,
							objectMovedByWidget |= ImGui::Drag("Position", transform.position, 0.1f));
						UNDOABLE_COMPONENT_SETTING("entity rotation", transform.rotation,
							if (ImGui::Drag("Rotation", selectedEntityEulerRotation, 0.1f))
							{
								transform.rotation = getQuat(selectedEntityEulerRotation);
								objectMovedByWidget = true;
							}, [](transform_component&, quat rot, void* userData) { *(vec3*)userData = getEuler(rot); }, &selectedEntityEulerRotation);
						UNDOABLE_COMPONENT_SETTING("entity scale", transform.scale,
							objectMovedByWidget |= ImGui::Drag("Scale", transform.scale, 0.1f));
					});

					drawComponent<position_component>(selectedEntity, "TRANSFORM", [this, &objectMovedByWidget](position_component& transform)
					{
						using component_t = position_component;

						UNDOABLE_COMPONENT_SETTING("entity position", transform.position,
							objectMovedByWidget |= ImGui::Drag("Position", transform.position, 0.1f));
					});

					drawComponent<position_rotation_component>(selectedEntity, "TRANSFORM", [this, &objectMovedByWidget](position_rotation_component& transform)
					{
						using component_t = position_rotation_component;

						UNDOABLE_COMPONENT_SETTING("entity position", transform.position,
							objectMovedByWidget |= ImGui::Drag("Position", transform.position, 0.1f));
						UNDOABLE_COMPONENT_SETTING("entity rotation", transform.rotation,
							if (ImGui::Drag("Rotation", selectedEntityEulerRotation, 0.1f))
							{
								transform.rotation = getQuat(selectedEntityEulerRotation);
								objectMovedByWidget = true;
							}, [](position_rotation_component&, quat rot, void* userData) { *(vec3*)userData = getEuler(rot); }, & selectedEntityEulerRotation);
					});

					drawComponent<position_scale_component>(selectedEntity, "TRANSFORM", [this, &objectMovedByWidget](position_scale_component& transform)
					{
						using component_t = position_scale_component;

						UNDOABLE_COMPONENT_SETTING("entity position", transform.position,
							objectMovedByWidget |= ImGui::Drag("Position", transform.position, 0.1f));
						UNDOABLE_COMPONENT_SETTING("entity scale", transform.scale,
							objectMovedByWidget |= ImGui::Drag("Scale", transform.scale, 0.1f));
					});

					drawComponent<dynamic_transform_component>(selectedEntity, "DYNAMIC", [](dynamic_transform_component& dynamic)
					{
						ImGui::Text("Dynamic");
					});

					drawComponent<mesh_component>(selectedEntity, "MESH", [this](mesh_component& raster)
					{
						using component_t = mesh_component;

						if (ImGui::BeginProperties())
						{
							ImGui::PropertyValue("Load state", assetLoadStateNames[raster.mesh->loadState.load()]);
							editMesh("Mesh", raster.mesh, mesh_creation_flags_default);
							ImGui::EndProperties();
						}
						if (ImGui::BeginTree("Submeshes"))
						{
							for (const auto& sub : raster.mesh->submeshes)
							{
								ImGui::PushID(&sub);
								if (ImGui::BeginTree(sub.name.c_str()))
								{
									editMaterial(sub.material);

									ImGui::EndTree();
								}
								ImGui::PopID();
							}

							ImGui::EndTree();
						}
					});

					drawComponent<terrain_component>(selectedEntity, "TERRAIN", [this, &objectMovedByWidget](terrain_component& terrain)
					{
						using component_t = terrain_component;

						if (ImGui::BeginProperties())
						{
							UNDOABLE_COMPONENT_SETTING("terrain amplitude scale", terrain.amplitudeScale,
								objectMovedByWidget |= ImGui::PropertyDrag("Amplitude scale", terrain.amplitudeScale, 0.1f, 0.f));

							auto& settings = terrain.genSettings;
							UNDOABLE_COMPONENT_SETTING("terrain noise scale", settings.scale,
								objectMovedByWidget |= ImGui::PropertyDrag("Noise scale", settings.scale, 0.001f));
							UNDOABLE_COMPONENT_SETTING("terrain domain warp strength", settings.domainWarpStrength,
								objectMovedByWidget |= ImGui::PropertyDrag("Domain warp strength", settings.domainWarpStrength, 0.05f, 0.f));
							UNDOABLE_COMPONENT_SETTING("terrain domain warp octaves", settings.domainWarpOctaves,
								objectMovedByWidget |= ImGui::PropertySlider("Domain warp octaves", settings.domainWarpOctaves, 1, 16));
							UNDOABLE_COMPONENT_SETTING("terrain noise octaves", settings.noiseOctaves,
								objectMovedByWidget |= ImGui::PropertySlider("Noise octaves", settings.noiseOctaves, 1, 32));

							ImGui::EndProperties();
						}

						if (ImGui::BeginTree("Ground"))
						{
							editMaterial(terrain.groundMaterial);
							ImGui::EndTree();
						}

						if (ImGui::BeginTree("Rock"))
						{
							editMaterial(terrain.rockMaterial);
							ImGui::EndTree();
						}
					});

					drawComponent<proc_placement_component>(selectedEntity, "PROCEDURAL PLACEMENT", [this](proc_placement_component& placement)
					{
						using component_t = proc_placement_component;

						for (auto& layer : placement.layers)
						{
							if (ImGui::BeginTree(layer.name))
							{
								if (ImGui::BeginProperties())
								{
									UNDOABLE_COMPONENT_SETTING("proc placement layer footprint", layer.footprint,
										ImGui::PropertyDrag("Footprint", layer.footprint, 0.05f, 0.01f));
									for (uint32 i = 0; i < layer.numMeshes; ++i)
									{
										ImGui::PushID(i);
										UNDOABLE_COMPONENT_SETTING("proc placement layer density", layer.densities[i],
											ImGui::PropertySlider("Density", layer.densities[i]));
										ImGui::PopID();
									}
									ImGui::EndProperties();
								}
								ImGui::EndTree();
							}
						}
					});

					drawComponent<grass_component>(selectedEntity, "GRASS", [this](grass_component& grass)
					{
						using component_t = grass_component;

						if (ImGui::BeginProperties())
						{
							UNDOABLE_SETTING("grass depth prepass", grass_settings::depthPrepass,
								ImGui::PropertyCheckbox("Depth prepass", grass_settings::depthPrepass));

							grass_settings& settings = grass.settings;

							UNDOABLE_COMPONENT_SETTING("grass blades per chunk dim", settings.numGrassBladesPerChunkDim,
								ImGui::PropertyDrag("Blades per chunk dim", settings.numGrassBladesPerChunkDim, 2));
							UNDOABLE_COMPONENT_SETTING("grass blade height", settings.bladeHeight,
								ImGui::PropertySlider("Blade height", settings.bladeHeight, 0.f, 2.f));
							UNDOABLE_COMPONENT_SETTING("grass blade width", settings.bladeWidth,
								ImGui::PropertySlider("Blade width", settings.bladeWidth, 0.f, 1.f));

							UNDOABLE_COMPONENT_SETTING("grass LOD change start distance", settings.lodChangeStartDistance,
								ImGui::PropertyDrag("LOD change start distance", settings.lodChangeStartDistance, 0.5f, 0.f));
							UNDOABLE_COMPONENT_SETTING("grass LOD change transition distance", settings.lodChangeTransitionDistance,
								ImGui::PropertyDrag("LOD change transition distance", settings.lodChangeTransitionDistance, 0.5f, 0.f));

							UNDOABLE_COMPONENT_SETTING("grass cull start distance", settings.cullStartDistance,
								ImGui::PropertyDrag("Cull start distance", settings.cullStartDistance, 0.5f, 0.f));
							UNDOABLE_COMPONENT_SETTING("grass cull transition distance", settings.cullTransitionDistance,
								ImGui::PropertyDrag("Cull transition distance", settings.cullTransitionDistance, 0.5f, 0.f));

							ImGui::EndProperties();
						}
					});

					drawComponent<water_component>(selectedEntity, "WATER", [this](water_component& water)
					{
						using component_t = water_component;

						if (ImGui::BeginProperties())
						{
							water_settings& settings = water.settings;

							UNDOABLE_COMPONENT_SETTING("deep water color", settings.deepWaterColor,
								ImGui::PropertyColor("Deep color", settings.deepWaterColor));
							UNDOABLE_COMPONENT_SETTING("shallow water color", settings.shallowWaterColor,
								ImGui::PropertyColor("Shallow color", settings.shallowWaterColor));

							UNDOABLE_COMPONENT_SETTING("shallow water depth", settings.shallowDepth,
								ImGui::PropertyDrag("Shallow depth", settings.shallowDepth, 0.05f, 0.f));
							UNDOABLE_COMPONENT_SETTING("water transition strength", settings.transitionStrength,
								ImGui::PropertySlider("Transition strength", settings.transitionStrength, 0.f, 2.f));
							UNDOABLE_COMPONENT_SETTING("water normal map strength", settings.normalStrength,
								ImGui::PropertySlider("Normal map strength", settings.normalStrength));
							UNDOABLE_COMPONENT_SETTING("water UV scale", settings.uvScale,
								ImGui::PropertyDrag("UV scale", settings.uvScale, 0.05f, 0.f));

							ImGui::EndProperties();
						}
					});

					drawComponent<animation_component>(selectedEntity, "ANIMATION", [this](animation_component& anim)
					{
						if (mesh_component* mesh = selectedEntity.getComponentIfExists<mesh_component>())
						{
							if (ImGui::BeginProperties())
							{
								uint32 animationIndex = anim.animation.clip ? (uint32)(anim.animation.clip - mesh->mesh->skeleton.clips.data()) : -1;

								bool animationChanged = ImGui::PropertyDropdown("Currently playing", [](uint32 index, void* data)
								{
									if (index == -1) { return "---"; }

									animation_skeleton& skeleton = *(animation_skeleton*)data;
									const char* result = 0;
									if (index < (uint32)skeleton.clips.size())
									{
										result = skeleton.clips[index].name.c_str();
									}
									return result;
								}, animationIndex, & mesh->mesh->skeleton);

								if (animationChanged)
								{
									anim.animation.set(&mesh->mesh->skeleton.clips[animationIndex]);
								}

								ImGui::EndProperties();
							}

							animation_skeleton& skeleton = mesh->mesh->skeleton;
							if (skeleton.joints.size() > 0)
							{
								if (ImGui::BeginTree("Skeleton"))
								{
									if (ImGui::BeginTree("Joints"))
									{
										for (uint32 i = 0; i < (uint32)skeleton.joints.size(); ++i)
										{
											const skeleton_joint& j = skeleton.joints[i];
											vec3 c = limbTypeColors[j.limbType];
											ImGui::TextColored(ImVec4(c.x, c.y, c.z, 1.f), j.name.c_str());
										}

										ImGui::EndTree();
									}

									if (ImGui::BeginTree("Limbs"))
									{
										for (uint32 i = 0; i < limb_type_count; ++i)
										{
											if (i != limb_type_unknown)
											{
												skeleton_limb& l = skeleton.limbs[i];
												vec3 c = limbTypeColors[i];
												if (ImGui::BeginTreeColoredText(limbTypeNames[i], c))
												{
													if (ImGui::BeginProperties())
													{
														limb_dimensions& d = l.dimensions;
														ImGui::PropertyDrag("Min Y", d.minY, 0.01f);
														ImGui::PropertyDrag("Max Y", d.maxY, 0.01f);
														ImGui::PropertyDrag("Radius", d.radius, 0.01f);

														ImGui::PropertyDrag("Offset X", d.xOffset, 0.01f);
														ImGui::PropertyDrag("Offset Z", d.zOffset, 0.01f);

														ImGui::EndProperties();
													}

													ImGui::EndTree();
												}
											}
										}

										ImGui::EndTree();
									}

									ImGui::EndTree();
								}
							}
						}
					});

					drawComponent<rigid_body_component>(selectedEntity, "RIGID BODY", [this, &scene](rigid_body_component& rb)
					{
						using component_t = rigid_body_component;

						if (ImGui::BeginProperties())
						{
							if (rb.invMass != 0)
							{
								ImGui::PropertyValue("Mass", 1.f / rb.invMass, "%.3fkg");
							}
							UNDOABLE_COMPONENT_SETTING("rigid body linear velocity damping", rb.linearDamping,
								ImGui::PropertySlider("Linear velocity damping", rb.linearDamping));
							UNDOABLE_COMPONENT_SETTING("rigid body angular velocity damping", rb.angularDamping,
								ImGui::PropertySlider("Angular velocity damping", rb.angularDamping));
							UNDOABLE_COMPONENT_SETTING("rigid body gravity factor", rb.gravityFactor,
								ImGui::PropertySlider("Gravity factor", rb.gravityFactor));

							//ImGui::PropertyValue("Linear velocity", rb.linearVelocity);
							//ImGui::PropertyValue("Angular velocity", rb.angularVelocity);

							ImGui::EndProperties();
						}
					});

					drawComponent<physics_reference_component>(selectedEntity, "COLLIDERS", [this, &scene](physics_reference_component& reference)
					{
						// TODO UNDO
						bool dirty = false;

						for (scene_entity colliderEntity : collider_entity_iterator(selectedEntity))
						{
							ImGui::PushID((int)colliderEntity.handle);

							drawComponent<collider_component>(colliderEntity, "Collider", [&colliderEntity, &dirty, this](collider_component& collider)
							{
								switch (collider.type)
								{
									case collider_type_sphere:
									{
										if (ImGui::BeginTree("Shape: Sphere"))
										{
											if (ImGui::BeginProperties())
											{
												dirty |= ImGui::PropertyDrag("Local center", collider.sphere.center, 0.05f);
												dirty |= ImGui::PropertyDrag("Radius", collider.sphere.radius, 0.05f, 0.f);
												ImGui::EndProperties();
											}
											ImGui::EndTree();
										}
									} break;
									case collider_type_capsule:
									{
										if (ImGui::BeginTree("Shape: Capsule"))
										{
											if (ImGui::BeginProperties())
											{
												dirty |= ImGui::PropertyDrag("Local point A", collider.capsule.positionA, 0.05f);
												dirty |= ImGui::PropertyDrag("Local point B", collider.capsule.positionB, 0.05f);
												dirty |= ImGui::PropertyDrag("Radius", collider.capsule.radius, 0.05f, 0.f);
												ImGui::EndProperties();
											}
											ImGui::EndTree();
										}
									} break;
									case collider_type_cylinder:
									{
										if (ImGui::BeginTree("Shape: Cylinder"))
										{
											if (ImGui::BeginProperties())
											{
												dirty |= ImGui::PropertyDrag("Local point A", collider.cylinder.positionA, 0.05f);
												dirty |= ImGui::PropertyDrag("Local point B", collider.cylinder.positionB, 0.05f);
												dirty |= ImGui::PropertyDrag("Radius", collider.cylinder.radius, 0.05f, 0.f);
												ImGui::EndProperties();
											}
											ImGui::EndTree();
										}
									} break;
									case collider_type_aabb:
									{
										if (ImGui::BeginTree("Shape: AABB"))
										{
											if (ImGui::BeginProperties())
											{
												dirty |= ImGui::PropertyDrag("Local min", collider.aabb.minCorner, 0.05f);
												dirty |= ImGui::PropertyDrag("Local max", collider.aabb.maxCorner, 0.05f);
												ImGui::EndProperties();
											}
											ImGui::EndTree();
										}
									} break;
									case collider_type_obb:
									{
										if (ImGui::BeginTree("Shape: OBB"))
										{
											if (ImGui::BeginProperties())
											{
												ImGui::EndProperties();
											}
											ImGui::EndTree();
										}
									} break;
									case collider_type_hull:
									{
										if (ImGui::BeginTree("Shape: Hull"))
										{
											if (ImGui::BeginProperties())
											{
												ImGui::EndProperties();
											}
											ImGui::EndTree();
										}
									} break;
								}

								if (ImGui::BeginProperties())
								{
									ImGui::PropertySlider("Restitution", collider.material.restitution);
									ImGui::PropertySlider("Friction", collider.material.friction);
									dirty |= ImGui::PropertyDrag("Density", collider.material.density, 0.05f, 0.f);

									bool editCollider = selectedColliderEntity == colliderEntity;
									if (ImGui::PropertyCheckbox("Edit", editCollider))
									{
										selectedColliderEntity = editCollider ? colliderEntity : scene_entity{};
									}

									ImGui::EndProperties();
								}
							});

							ImGui::PopID();
						}

						if (dirty)
						{
							if (rigid_body_component* rb = selectedEntity.getComponentIfExists<rigid_body_component>())
							{
								rb->recalculateProperties(&scene.registry, reference);
							}
						}
					});

					drawComponent<physics_reference_component>(selectedEntity, "CONSTRAINTS", [this](physics_reference_component& reference)
					{
						// TODO UNDO
						for (auto [constraintEntity, constraintType] : constraint_entity_iterator(selectedEntity))
						{
							ImGui::PushID((int)constraintEntity.handle);

							switch (constraintType)
							{
								case constraint_type_distance:
								{
									drawComponent<distance_constraint>(constraintEntity, "Distance constraint", [this, constraintEntity = constraintEntity](distance_constraint& constraint)
									{
										if (ImGui::BeginProperties())
										{
											scene_entity otherEntity = getOtherEntity(constraintEntity.getComponent<constraint_entity_reference_component>(), selectedEntity);
											if (ImGui::PropertyButton("Connected entity", ICON_FA_CUBE, otherEntity.getComponent<tag_component>().name))
											{
												setSelectedEntity(otherEntity);
											}

											bool visConstraint = selectedConstraintEntity == constraintEntity;
											if (ImGui::PropertyCheckbox("Visualize", visConstraint))
											{
												selectedConstraintEntity = visConstraint ? constraintEntity : scene_entity{};
											}

											ImGui::PropertySlider("Length", constraint.globalLength);
											ImGui::EndProperties();
										}
									});
								} break;

								case constraint_type_ball:
								{
									drawComponent<ball_constraint>(constraintEntity, "Ball constraint", [this, constraintEntity = constraintEntity](ball_constraint& constraint)
									{
										if (ImGui::BeginProperties())
										{
											scene_entity otherEntity = getOtherEntity(constraintEntity.getComponent<constraint_entity_reference_component>(), selectedEntity);
											if (ImGui::PropertyButton("Connected entity", ICON_FA_CUBE, otherEntity.getComponent<tag_component>().name))
											{
												setSelectedEntity(otherEntity);
											}

											bool visConstraint = selectedConstraintEntity == constraintEntity;
											if (ImGui::PropertyCheckbox("Visualize", visConstraint))
											{
												selectedConstraintEntity = visConstraint ? constraintEntity : scene_entity{};
											}

											ImGui::EndProperties();
										}
									});
								} break;

								case constraint_type_fixed:
								{
									drawComponent<fixed_constraint>(constraintEntity, "Fixed constraint", [this, constraintEntity = constraintEntity](fixed_constraint& constraint)
									{
										if (ImGui::BeginProperties())
										{
											scene_entity otherEntity = getOtherEntity(constraintEntity.getComponent<constraint_entity_reference_component>(), selectedEntity);
											if (ImGui::PropertyButton("Connected entity", ICON_FA_CUBE, otherEntity.getComponent<tag_component>().name))
											{
												setSelectedEntity(otherEntity);
											}

											bool visConstraint = selectedConstraintEntity == constraintEntity;
											if (ImGui::PropertyCheckbox("Visualize", visConstraint))
											{
												selectedConstraintEntity = visConstraint ? constraintEntity : scene_entity{};
											}

											ImGui::EndProperties();
										}
									});
								} break;

								case constraint_type_hinge:
								{
									drawComponent<hinge_constraint>(constraintEntity, "Hinge constraint", [this, constraintEntity = constraintEntity](hinge_constraint& constraint)
									{
										if (ImGui::BeginProperties())
										{
											scene_entity otherEntity = getOtherEntity(constraintEntity.getComponent<constraint_entity_reference_component>(), selectedEntity);
											if (ImGui::PropertyButton("Connected entity", ICON_FA_CUBE, otherEntity.getComponent<tag_component>().name))
											{
												setSelectedEntity(otherEntity);
											}

											bool minLimitActive = constraint.minRotationLimit <= 0.f;
											if (ImGui::PropertyCheckbox("Lower limit active", minLimitActive))
											{
												constraint.minRotationLimit = -constraint.minRotationLimit;
											}
											if (minLimitActive)
											{
												float minLimit = -constraint.minRotationLimit;
												ImGui::PropertySliderAngle("Lower limit", minLimit, 0.f, 180.f, "-%.0f deg");
												constraint.minRotationLimit = -minLimit;
											}

											bool maxLimitActive = constraint.maxRotationLimit >= 0.f;
											if (ImGui::PropertyCheckbox("Upper limit active", maxLimitActive))
											{
												constraint.maxRotationLimit = -constraint.maxRotationLimit;
											}
											if (maxLimitActive)
											{
												ImGui::PropertySliderAngle("Upper limit", constraint.maxRotationLimit, 0.f, 180.f);
											}

											bool motorActive = constraint.maxMotorTorque > 0.f;
											if (ImGui::PropertyCheckbox("Motor active", motorActive))
											{
												constraint.maxMotorTorque = -constraint.maxMotorTorque;
											}
											if (motorActive)
											{
												ImGui::PropertyDropdown("Motor type", constraintMotorTypeNames, arraysize(constraintMotorTypeNames), (uint32&)constraint.motorType);

												if (constraint.motorType == constraint_velocity_motor)
												{
													ImGui::PropertySliderAngle("Motor velocity", constraint.motorVelocity, -1000.f, 1000.f);
												}
												else
												{
													float lo = minLimitActive ? constraint.minRotationLimit : -M_PI;
													float hi = maxLimitActive ? constraint.maxRotationLimit : M_PI;
													ImGui::PropertySliderAngle("Motor target angle", constraint.motorTargetAngle, rad2deg(lo), rad2deg(hi));
												}

												ImGui::PropertySlider("Max motor torque", constraint.maxMotorTorque, 0.001f, 10000.f);
											}

											bool visConstraint = selectedConstraintEntity == constraintEntity;
											if (ImGui::PropertyCheckbox("Visualize", visConstraint))
											{
												selectedConstraintEntity = visConstraint ? constraintEntity : scene_entity{};
											}
											ImGui::EndProperties();
										}
									});
								} break;

								case constraint_type_cone_twist:
								{
									drawComponent<cone_twist_constraint>(constraintEntity, "Cone twist constraint", [this, constraintEntity = constraintEntity](cone_twist_constraint& constraint)
									{
										if (ImGui::BeginProperties())
										{
											scene_entity otherEntity = getOtherEntity(constraintEntity.getComponent<constraint_entity_reference_component>(), selectedEntity);
											if (ImGui::PropertyButton("Connected entity", ICON_FA_CUBE, otherEntity.getComponent<tag_component>().name))
											{
												setSelectedEntity(otherEntity);
											}

											bool swingLimitActive = constraint.swingLimit >= 0.f;
											if (ImGui::PropertyCheckbox("Swing limit active", swingLimitActive))
											{
												constraint.swingLimit = -constraint.swingLimit;
											}
											if (swingLimitActive)
											{
												ImGui::PropertySliderAngle("Swing limit", constraint.swingLimit, 0.f, 180.f);
											}

											bool twistLimitActive = constraint.twistLimit >= 0.f;
											if (ImGui::PropertyCheckbox("Twist limit active", twistLimitActive))
											{
												constraint.twistLimit = -constraint.twistLimit;
											}
											if (twistLimitActive)
											{
												ImGui::PropertySliderAngle("Twist limit", constraint.twistLimit, 0.f, 180.f);
											}

											bool twistMotorActive = constraint.maxTwistMotorTorque > 0.f;
											if (ImGui::PropertyCheckbox("Twist motor active", twistMotorActive))
											{
												constraint.maxTwistMotorTorque = -constraint.maxTwistMotorTorque;
											}
											if (twistMotorActive)
											{
												ImGui::PropertyDropdown("Twist motor type", constraintMotorTypeNames, arraysize(constraintMotorTypeNames), (uint32&)constraint.twistMotorType);

												if (constraint.twistMotorType == constraint_velocity_motor)
												{
													ImGui::PropertySliderAngle("Twist motor velocity", constraint.twistMotorVelocity, -360.f, 360.f);
												}
												else
												{
													float li = twistLimitActive ? constraint.twistLimit : -M_PI;
													ImGui::PropertySliderAngle("Twist motor target angle", constraint.twistMotorTargetAngle, rad2deg(-li), rad2deg(li));
												}

												ImGui::PropertySlider("Max twist motor torque", constraint.maxTwistMotorTorque, 0.001f, 1000.f);
											}

											bool swingMotorActive = constraint.maxSwingMotorTorque > 0.f;
											if (ImGui::PropertyCheckbox("Swing motor active", swingMotorActive))
											{
												constraint.maxSwingMotorTorque = -constraint.maxSwingMotorTorque;
											}
											if (swingMotorActive)
											{
												ImGui::PropertyDropdown("Swing motor type", constraintMotorTypeNames, arraysize(constraintMotorTypeNames), (uint32&)constraint.swingMotorType);

												if (constraint.swingMotorType == constraint_velocity_motor)
												{
													ImGui::PropertySliderAngle("Swing motor velocity", constraint.swingMotorVelocity, -360.f, 360.f);
												}
												else
												{
													float li = swingLimitActive ? constraint.swingLimit : -M_PI;
													ImGui::PropertySliderAngle("Swing motor target angle", constraint.swingMotorTargetAngle, rad2deg(-li), rad2deg(li));
												}

												ImGui::PropertySliderAngle("Swing motor axis angle", constraint.swingMotorAxis, -180.f, 180.f);
												ImGui::PropertySlider("Max swing motor torque", constraint.maxSwingMotorTorque, 0.001f, 1000.f);
											}

											bool visConstraint = selectedConstraintEntity == constraintEntity;
											if (ImGui::PropertyCheckbox("Visualize", visConstraint))
											{
												selectedConstraintEntity = visConstraint ? constraintEntity : scene_entity{};
											}
											ImGui::EndProperties();
										}
									});
								} break;

								case constraint_type_slider:
								{
									drawComponent<slider_constraint>(constraintEntity, "Slider constraint", [this, constraintEntity = constraintEntity](slider_constraint& constraint)
									{
										if (ImGui::BeginProperties())
										{
											scene_entity otherEntity = getOtherEntity(constraintEntity.getComponent<constraint_entity_reference_component>(), selectedEntity);
											if (ImGui::PropertyButton("Connected entity", ICON_FA_CUBE, otherEntity.getComponent<tag_component>().name))
											{
												setSelectedEntity(otherEntity);
											}

											bool minLimitActive = constraint.negDistanceLimit <= 0.f;
											if (ImGui::PropertyCheckbox("Lower limit active", minLimitActive))
											{
												constraint.negDistanceLimit = -constraint.negDistanceLimit;
											}
											if (minLimitActive)
											{
												float minLimit = -constraint.negDistanceLimit;
												ImGui::PropertySlider("Lower limit", minLimit, 0.f, 1000.f, "-%.3f");
												constraint.negDistanceLimit = -minLimit;
											}

											bool maxLimitActive = constraint.posDistanceLimit >= 0.f;
											if (ImGui::PropertyCheckbox("Upper limit active", maxLimitActive))
											{
												constraint.posDistanceLimit = -constraint.posDistanceLimit;
											}
											if (maxLimitActive)
											{
												ImGui::PropertySlider("Upper limit", constraint.posDistanceLimit, 0.f, 1000.f);
											}

											bool motorActive = constraint.maxMotorForce > 0.f;
											if (ImGui::PropertyCheckbox("Motor active", motorActive))
											{
												constraint.maxMotorForce = -constraint.maxMotorForce;
											}
											if (motorActive)
											{
												ImGui::PropertyDropdown("Motor type", constraintMotorTypeNames, arraysize(constraintMotorTypeNames), (uint32&)constraint.motorType);

												if (constraint.motorType == constraint_velocity_motor)
												{
													ImGui::PropertySlider("Motor velocity", constraint.motorVelocity, -10.f, 10.f);
												}
												else
												{
													float lo = minLimitActive ? constraint.negDistanceLimit : -100.f;
													float hi = maxLimitActive ? constraint.posDistanceLimit : 100.f;
													ImGui::PropertySlider("Motor target distance", constraint.motorTargetDistance, lo, hi);
												}

												ImGui::PropertySlider("Max motor force", constraint.maxMotorForce, 0.001f, 1000.f);
											}

											bool visConstraint = selectedConstraintEntity == constraintEntity;
											if (ImGui::PropertyCheckbox("Visualize", visConstraint))
											{
												selectedConstraintEntity = visConstraint ? constraintEntity : scene_entity{};
											}
											ImGui::EndProperties();
										}
									});
								} break;
							}

							ImGui::PopID();
						}
					});

					drawComponent<cloth_component>(selectedEntity, "CLOTH", [this](cloth_component& cloth)
					{
						using component_t = cloth_component;

						if (ImGui::BeginProperties())
						{
							UNDOABLE_COMPONENT_SETTING("cloth total mass", cloth.totalMass,
								ImGui::PropertyDrag("Total mass", cloth.totalMass, 0.1f, 0.f));
							UNDOABLE_COMPONENT_SETTING("cloth stiffness", cloth.stiffness,
								ImGui::PropertySlider("Stiffness", cloth.stiffness, 0.01f, 0.7f));
							UNDOABLE_COMPONENT_SETTING("cloth velocity damping", cloth.damping,
								ImGui::PropertySlider("Velocity damping", cloth.damping, 0.f, 1.f));
							UNDOABLE_COMPONENT_SETTING("cloth gravity factor", cloth.gravityFactor,
								ImGui::PropertySlider("Gravity factor", cloth.gravityFactor, 0.f, 1.f));

							ImGui::EndProperties();
						}
					});

					drawComponent<point_light_component>(selectedEntity, "POINT LIGHT", [this](point_light_component& pl)
					{
						using component_t = point_light_component;

						if (ImGui::BeginProperties())
						{
							UNDOABLE_COMPONENT_SETTING("point light color", pl.color,
								ImGui::PropertyColorWheel("Color", pl.color));
							UNDOABLE_COMPONENT_SETTING("point light intensity", pl.intensity,
								ImGui::PropertySlider("Intensity", pl.intensity, 0.f, 10.f));
							UNDOABLE_COMPONENT_SETTING("point light radius", pl.radius,
								ImGui::PropertySlider("Radius", pl.radius, 0.f, 100.f));
							UNDOABLE_COMPONENT_SETTING("point light casts shadow", pl.castsShadow,
								ImGui::PropertyCheckbox("Casts shadow", pl.castsShadow));
							if (pl.castsShadow)
							{
								UNDOABLE_COMPONENT_SETTING("point light shadow resolution", pl.shadowMapResolution,
									ImGui::PropertyDropdownPowerOfTwo("Shadow resolution", 128, 2048, pl.shadowMapResolution));
							}

							ImGui::EndProperties();
						}
					});

					drawComponent<spot_light_component>(selectedEntity, "SPOT LIGHT", [this](spot_light_component& sl)
					{
						using component_t = spot_light_component;

						if (ImGui::BeginProperties())
						{
							UNDOABLE_COMPONENT_SETTING("spot light color", sl.color,
								ImGui::PropertyColorWheel("Color", sl.color));
							UNDOABLE_COMPONENT_SETTING("spot light intensity", sl.intensity,
								ImGui::PropertySlider("Intensity", sl.intensity, 0.f, 10.f));
							UNDOABLE_COMPONENT_SETTING("spot light distance", sl.distance,
								ImGui::PropertySlider("Distance", sl.distance, 0.f, 100.f));
							UNDOABLE_COMPONENT_SETTING("spot light inner angle", sl.innerAngle,
								ImGui::PropertySliderAngle("Inner angle", sl.innerAngle, 0.1f, 80.f));
							UNDOABLE_COMPONENT_SETTING("spot light outer angle", sl.outerAngle,
								ImGui::PropertySliderAngle("Outer angle", sl.outerAngle, 0.2f, 85.f));
							UNDOABLE_COMPONENT_SETTING("spot light casts shadow", sl.castsShadow,
								ImGui::PropertyCheckbox("Casts shadow", sl.castsShadow));
							if (sl.castsShadow)
							{
								UNDOABLE_COMPONENT_SETTING("spot light shadow resolution", sl.shadowMapResolution,
									ImGui::PropertyDropdownPowerOfTwo("Shadow resolution", 128, 2048, sl.shadowMapResolution));
							}

							ImGui::EndProperties();
						}
					});
				}


				if (ImGui::IsWindowHovered() && ImGui::IsMouseClicked(ImGuiMouseButton_Right) && !ImGui::IsAnyItemHovered())
				{
					ImGui::OpenPopup("CreateComponentPopup");
				}

				if (ImGui::BeginPopup("CreateComponentPopup"))
				{
					ImGui::Text("Create component");
					ImGui::Separator();

					if (ImGui::MenuItem("Rigid body"))
					{
						selectedEntity.addComponent<rigid_body_component>(false);
					}
					if (ImGui::BeginMenu("Collider"))
					{
						bounding_box aabb = getObjectBoundingBox(selectedEntity, false);
						physics_material material = { physics_material_type_wood, 0.1f, 0.5f, 1.f };

						if (ImGui::MenuItem("Sphere"))
						{
							selectedEntity.addComponent<collider_component>(collider_component::asSphere({ aabb.getCenter(), maxElement(aabb.getRadius()) }, material));
						}
						if (ImGui::MenuItem("Capsule"))
						{
							vec3 r = aabb.getRadius();
							uint32 axis = maxElementIndex(r);
							uint32 axisA = (axis + 1) % 3;
							uint32 axisB = (axis + 2) % 3;
							float cRadius = max(r.data[axisA], r.data[axisB]);
							vec3 a = aabb.minCorner; a.data[axisA] += r.data[axisA]; a.data[axisB] += r.data[axisB]; a.data[axis] += cRadius;
							vec3 b = aabb.maxCorner; b.data[axisA] -= r.data[axisA]; b.data[axisB] -= r.data[axisB]; b.data[axis] -= cRadius;
							selectedEntity.addComponent<collider_component>(collider_component::asCapsule({ a, b, cRadius }, material));
						}
						if (ImGui::MenuItem("Cylinder"))
						{
							vec3 r = aabb.getRadius();
							uint32 axis = maxElementIndex(r);
							uint32 axisA = (axis + 1) % 3;
							uint32 axisB = (axis + 2) % 3;
							float cRadius = max(r.data[axisA], r.data[axisB]);
							vec3 a = aabb.minCorner; a.data[axisA] += r.data[axisA]; a.data[axisB] += r.data[axisB];
							vec3 b = aabb.maxCorner; b.data[axisA] -= r.data[axisA]; b.data[axisB] -= r.data[axisB];
							selectedEntity.addComponent<collider_component>(collider_component::asCylinder({ a, b, cRadius }, material));
						}
						if (ImGui::MenuItem("AABB"))
						{
							selectedEntity.addComponent<collider_component>(collider_component::asAABB(aabb, material));
						}
						if (ImGui::MenuItem("OBB"))
						{
							selectedEntity.addComponent<collider_component>(collider_component::asOBB({ quat::identity, aabb.getCenter(), aabb.getRadius() }, material));
						}

						ImGui::EndMenu();
					}

					ImGui::EndPopup();
				}


			}
			ImGui::EndChild();
		}
	}
	ImGui::End();

	return objectMovedByWidget;
}

void scene_editor::onObjectMoved()
{
	if (selectedEntity)
	{
		if (cloth_component* cloth = selectedEntity.getComponentIfExists<cloth_component>())
		{
			cloth->setWorldPositionOfFixedVertices(selectedEntity.getComponent<transform_component>(), false);
		}
	}
}

bool scene_editor::handleUserInput(const user_input& input, ldr_render_pass* ldrRenderPass, float dt)
{
	game_scene* scene = &this->scene->getCurrentScene();


	// Returns true, if the user dragged an object using a gizmo.

	if (input.keyboard['F'].pressEvent && selectedEntity)
	{
		bounding_box aabb = getObjectBoundingBox(selectedEntity, true);
		cameraController.centerCameraOnObject(aabb);
	}

	bool inputCaptured = cameraController.update(input, renderer->renderWidth, renderer->renderHeight, dt);

	if (inputCaptured)
	{
		renderer->pathTracer.resetRendering();
	}

	bool objectMovedByGizmo = false;


	render_camera& camera = this->scene->camera;

	bool gizmoDrawn = false;


	if (!inputCaptured && !ImGui::IsAnyItemActive() && ImGui::IsKeyDown(key_shift) && ImGui::IsKeyPressed('A'))
	{
		ImGui::OpenPopup("CreateEntityPopup");
		inputCaptured = true;
	}

	inputCaptured |= drawEntityCreationPopup();

	if (ImGui::BeginControlsWindow("##EntityControls", ImVec2(0.f, 0.f), ImVec2(20.f, 90.f)))
	{
		ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0, 0, 0, 0));

		if (ImGui::Button(ICON_FA_PLUS)) { ImGui::OpenPopup("CreateEntityPopup"); }
		if (ImGui::IsItemHovered()) { ImGui::SetTooltip("Create entity (Shift+A)"); }
		inputCaptured |= drawEntityCreationPopup();

		ImGui::PopStyleColor();
	}
	ImGui::End();



	collider_component* selectedCollider = selectedColliderEntity ? selectedColliderEntity.getComponentIfExists<collider_component>() : 0;

	bool draggingBefore = gizmo.dragging;

	if (selectedCollider)
	{
		const trs& transform = selectedEntity.hasComponent<transform_component>() ? selectedEntity.getComponent<transform_component>() : trs::identity;
		auto& c = *selectedCollider;
		const vec4 volumeColor(1.f, 1.f, 0.f, 1.f);
		if (c.type == collider_type_sphere)
		{
			if (gizmo.manipulateBoundingSphere(c.sphere, transform, camera, input, !inputCaptured, ldrRenderPass))
			{
				inputCaptured = true;
				objectMovedByGizmo = true;
			}
#if 0
			else if (draggingBefore)
			{
				const trs& origWorldTransform = gizmo.originalTransform;
				bounding_sphere before =
				{
					conjugate(transform.rotation) * (origWorldTransform.position - transform.position),
					origWorldTransform.scale.x
				};
				undoStack.pushAction("sphere collider", component_member_undo<collider_component, bounding_sphere>(selectedColliderEntity, c.sphere, before));
			}
#endif
			gizmoDrawn = true;
			renderWireSphere(transform.rotation * c.sphere.center + transform.position, c.sphere.radius, volumeColor, ldrRenderPass, true);
		}
		else if (c.type == collider_type_capsule)
		{
			if (gizmo.manipulateBoundingCapsule(c.capsule, transform, camera, input, !inputCaptured, ldrRenderPass))
			{
				inputCaptured = true;
				objectMovedByGizmo = true;
			}
#if 0
			else if (draggingBefore)
			{
				const trs& origWorldTransform = gizmo.originalTransform;
				vec3 a = transform.position + transform.rotation * c.capsule.positionA;
				vec3 b = transform.position + transform.rotation * c.capsule.positionB;
				bounding_capsule before =
				{
					conjugate(transform.rotation) * (transformPosition(origWorldTransform, a) - transform.position),
					conjugate(transform.rotation) * (transformPosition(origWorldTransform, b) - transform.position),
					origWorldTransform.scale.x
				};
				undoStack.pushAction("capsule collider", component_member_undo<collider_component, bounding_capsule>(selectedColliderEntity, c.capsule, before));
			}
#endif
			gizmoDrawn = true;
			renderWireCapsule(transform.rotation * c.capsule.positionA + transform.position, transform.rotation * c.capsule.positionB + transform.position,
				c.capsule.radius, volumeColor, ldrRenderPass, true);
		}
		else if (c.type == collider_type_cylinder)
		{
			if (gizmo.manipulateBoundingCylinder(c.cylinder, transform, camera, input, !inputCaptured, ldrRenderPass))
			{
				inputCaptured = true;
				objectMovedByGizmo = true;
			}
			gizmoDrawn = true;
			renderWireCylinder(transform.rotation * c.cylinder.positionA + transform.position, transform.rotation * c.cylinder.positionB + transform.position,
				c.cylinder.radius, volumeColor, ldrRenderPass, true);
		}
		else if (c.type == collider_type_aabb)
		{
			if (gizmo.manipulateBoundingBox(c.aabb, transform, camera, input, !inputCaptured, ldrRenderPass))
			{
				inputCaptured = true;
				objectMovedByGizmo = true;
			}
			gizmoDrawn = true;
			renderWireBox(transform.rotation * c.aabb.getCenter() + transform.position, c.aabb.getRadius(), transform.rotation, volumeColor, ldrRenderPass, true);
		}
		else if (c.type == collider_type_obb)
		{
			if (gizmo.manipulateOrientedBoundingBox(c.obb, transform, camera, input, !inputCaptured, ldrRenderPass))
			{
				inputCaptured = true;
				objectMovedByGizmo = true;
			}
			gizmoDrawn = true;
			renderWireBox(transform.rotation * c.obb.center + transform.position, c.obb.radius, transform.rotation * c.obb.rotation, volumeColor, ldrRenderPass, true);
		}
		if (!gizmoDrawn)
		{
			gizmo.manipulateNothing(camera, input, !inputCaptured, ldrRenderPass);
		}
	}
	else if (selectedEntity)
	{
		if (physics_transform1_component* transform = selectedEntity.getComponentIfExists<physics_transform1_component>())
		{
			// Saved rigid-body properties. When an RB is dragged, we make it kinematic.
			static bool saved = false;
			static float invMass;

			if (gizmo.manipulateTransformation(*transform, camera, input, !inputCaptured, ldrRenderPass))
			{
				updateSelectedEntityUIRotation();
				inputCaptured = true;
				objectMovedByGizmo = true;

				if (!saved && selectedEntity.hasComponent<rigid_body_component>())
				{
					rigid_body_component& rb = selectedEntity.getComponent<rigid_body_component>();
					invMass = rb.invMass;

					rb.invMass = 0.f;
					rb.linearVelocity = 0.f;

					saved = true;
				}

				selectedEntity.getComponent<physics_transform0_component>() = *transform;
				selectedEntity.getComponent<transform_component>() = *transform;
			}
			else
			{
				if (draggingBefore)
				{
					currentUndoStack->pushAction("object transform",
						component_undo<transform_component, physics_transform0_component, physics_transform1_component>(selectedEntity,
							gizmo.originalTransform,
							gizmo.originalTransform,
							gizmo.originalTransform
							));
				}

				if (saved)
				{
					ASSERT(selectedEntity.hasComponent<rigid_body_component>());
					rigid_body_component& rb = selectedEntity.getComponent<rigid_body_component>();

					rb.invMass = invMass;
					saved = false;
				}
			}
		}
		else if (transform_component* transform = selectedEntity.getComponentIfExists<transform_component>())
		{
			if (gizmo.manipulateTransformation(*transform, camera, input, !inputCaptured, ldrRenderPass))
			{
				updateSelectedEntityUIRotation();
				inputCaptured = true;
				objectMovedByGizmo = true;
			}
			else if (draggingBefore)
			{
				currentUndoStack->pushAction("object transform",
					component_undo<transform_component>(selectedEntity, transform_component(gizmo.originalTransform)));
			}
		}
		else if (position_component* pc = selectedEntity.getComponentIfExists<position_component>())
		{
			if (gizmo.manipulatePosition(pc->position, camera, input, !inputCaptured, ldrRenderPass))
			{
				inputCaptured = true;
				objectMovedByGizmo = true;
			}
			else if (draggingBefore)
			{
				currentUndoStack->pushAction("object transform",
					component_undo<position_component>(selectedEntity, position_component{ gizmo.originalTransform.position }));
			}
		}
		else if (position_rotation_component* prc = selectedEntity.getComponentIfExists<position_rotation_component>())
		{
			if (gizmo.manipulatePositionRotation(prc->position, prc->rotation, camera, input, !inputCaptured, ldrRenderPass))
			{
				updateSelectedEntityUIRotation();
				inputCaptured = true;
				objectMovedByGizmo = true;
			}
			else if (draggingBefore)
			{
				currentUndoStack->pushAction("object transform",
					component_undo<position_rotation_component>(selectedEntity, position_rotation_component{ gizmo.originalTransform.position, gizmo.originalTransform.rotation }));
			}
		}
		else if (position_scale_component* psc = selectedEntity.getComponentIfExists<position_scale_component>())
		{
			if (gizmo.manipulatePositionScale(psc->position, psc->scale, camera, input, !inputCaptured, ldrRenderPass))
			{
				inputCaptured = true;
				objectMovedByGizmo = true;
			}
			else if (draggingBefore)
			{
				currentUndoStack->pushAction("object transform",
					component_undo<position_scale_component>(selectedEntity, position_scale_component{ gizmo.originalTransform.position, gizmo.originalTransform.scale }));
			}
		}
		else
		{
			gizmo.manipulateNothing(camera, input, !inputCaptured, ldrRenderPass);
		}

		if (!inputCaptured && !ImGui::IsAnyItemActive())
		{
			if (ImGui::IsKeyPressed(key_backspace) || ImGui::IsKeyPressed(key_delete))
			{
				// Delete entity.
				currentUndoStack->pushAction("entity deletion", entity_existence_undo(*scene, selectedEntity));
				scene->deleteEntity(selectedEntity);
				setSelectedEntity({});
				inputCaptured = true;
				objectMovedByGizmo = true;
			}
			else if (ImGui::IsKeyDown(key_ctrl) && ImGui::IsKeyPressed('D'))
			{
				// Duplicate entity.
				scene_entity newEntity = scene->copyEntity(selectedEntity);
				setSelectedEntity(newEntity);
				inputCaptured = true;
				objectMovedByGizmo = true;
			}
		}
	}
	else
	{
		gizmo.manipulateNothing(camera, input, !inputCaptured, ldrRenderPass);
	}


	float simControlsWidth = IMGUI_ICON_DEFAULT_SIZE * 3 + IMGUI_ICON_DEFAULT_SPACING * 2 + ImGui::GetStyle().WindowPadding.x * 2;

	if (ImGui::BeginControlsWindow("##SimulationControls", ImVec2(0.5f, 0.f), ImVec2(-simControlsWidth * 0.5f, 20.f)))
	{
		ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0, 0, 0, 0));

		if (ImGui::IconButton(imgui_icon_play, imgui_icon_play, IMGUI_ICON_DEFAULT_SIZE, this->scene->isPlayable()))
		{
			this->scene->play();
			undoStacks[1].reset();
			setSelectedEntity({});
		}
		ImGui::SameLine(0.f, IMGUI_ICON_DEFAULT_SPACING);
		if (ImGui::IconButton(imgui_icon_pause, imgui_icon_pause, IMGUI_ICON_DEFAULT_SIZE, this->scene->isPausable()))
		{
			this->scene->pause();
		}
		ImGui::SameLine(0.f, IMGUI_ICON_DEFAULT_SPACING);
		if (ImGui::IconButton(imgui_icon_stop, imgui_icon_stop, IMGUI_ICON_DEFAULT_SIZE, this->scene->isStoppable()))
		{
			this->scene->stop();
			this->scene->environment.forceUpdate(this->scene->sun.direction);
			setSelectedEntity({});
		}

		scene = &this->scene->getCurrentScene();
		cameraController.camera = &camera;

		currentUndoStack = &undoStacks[this->scene->mode > 0];
		currentUndoBuffer = &undoBuffers[this->scene->mode > 0];

		ImGui::PopStyleColor();
	}
	ImGui::End();


	if (!ImGui::IsAnyItemActive())
	{
		if (!inputCaptured && ImGui::IsKeyDown(key_ctrl) && ImGui::IsKeyPressed('Z'))
		{
			currentUndoStack->undo();
			inputCaptured = true;
			objectMovedByGizmo = true;
		}
		if (!inputCaptured && ImGui::IsKeyDown(key_ctrl) && ImGui::IsKeyPressed('Y'))
		{
			currentUndoStack->redo();
			inputCaptured = true;
			objectMovedByGizmo = true;
		}
		if (!inputCaptured && ImGui::IsKeyDown(key_ctrl) && ImGui::IsKeyPressed('S'))
		{
			serializeToFile();
			inputCaptured = true;
			ImGui::GetIO().KeysDown['S'] = false; // Hack: Window does not get notified of inputs due to the file dialog.
		}
		if (!inputCaptured && ImGui::IsKeyDown(key_ctrl) && ImGui::IsKeyPressed('O'))
		{
			deserializeFromFile();
			inputCaptured = true;
			ImGui::GetIO().KeysDown['O'] = false; // Hack: Window does not get notified of inputs due to the file dialog.
		}
		if (!inputCaptured && ImGui::IsKeyDown(key_ctrl) && ImGui::IsKeyPressed('L'))
		{
			logWindowOpen = !logWindowOpen;
			inputCaptured = true;
		}
	}

	if (!inputCaptured && input.mouse.left.clickEvent)
	{
		// Temporary.
		if (input.keyboard[key_shift].down)
		{
			testPhysicsInteraction(*scene, camera.generateWorldSpaceRay(input.mouse.relX, input.mouse.relY), physicsTestForce);
		}
		else if (input.keyboard[key_ctrl].down)
		{
			vec3 dir = -camera.generateWorldSpaceRay(input.mouse.relX, input.mouse.relY).direction;
			vec3 beforeDir = this->scene->sun.direction;
			this->scene->sun.direction = dir;
			currentUndoStack->pushAction("sun direction", settings_undo<vec3>(this->scene->sun.direction, beforeDir));
			inputCaptured = true;
		}
		else
		{
			if (renderer->hoveredObjectID != -1)
			{
				setSelectedEntity({ renderer->hoveredObjectID, *scene });
			}
			else
			{
				setSelectedEntity({});
			}
		}
		inputCaptured = true;
	}

	return objectMovedByGizmo;
}

bool scene_editor::drawEntityCreationPopup()
{
	game_scene* scene = &this->scene->getCurrentScene();
	render_camera& camera = this->scene->camera;

	bool clicked = false;

	if (ImGui::BeginPopup("CreateEntityPopup"))
	{
		if (ImGui::MenuItem("Point light", "P") || ImGui::IsKeyPressed('P'))
		{
			auto pl = scene->createEntity("Point light")
				.addComponent<position_component>(camera.position + camera.rotation * vec3(0.f, 0.f, -3.f))
				.addComponent<point_light_component>(
					vec3(1.f, 1.f, 1.f),
					1.f,
					10.f,
					false,
					512u
					);

			currentUndoStack->pushAction("entity creation", entity_existence_undo(*scene, pl));

			setSelectedEntity(pl);
			clicked = true;
		}

		if (ImGui::MenuItem("Spot light", "S") || ImGui::IsKeyPressed('S'))
		{
			auto sl = scene->createEntity("Spot light")
				.addComponent<position_rotation_component>(camera.position + camera.rotation * vec3(0.f, 0.f, -3.f), quat::identity)
				.addComponent<spot_light_component>(
					vec3(1.f, 1.f, 1.f),
					1.f,
					25.f,
					deg2rad(20.f),
					deg2rad(30.f),
					false,
					512u
					);

			currentUndoStack->pushAction("entity creation", entity_existence_undo(*scene, sl));

			setSelectedEntity(sl);
			clicked = true;
		}

		ImGui::Separator();

		if (ImGui::MenuItem("Cloth", "C") || ImGui::IsKeyPressed('C'))
		{
			auto cloth = scene->createEntity("Cloth")
				.addComponent<transform_component>(camera.position + camera.rotation * vec3(0.f, 0.f, -3.f), camera.rotation)
				.addComponent<cloth_component>(10.f, 10.f, 20u, 20u, 8.f)
				.addComponent<cloth_render_component>();

			currentUndoStack->pushAction("entity creation", entity_existence_undo(*scene, cloth));

			setSelectedEntity(cloth);
			clicked = true;
		}

		if (ImGui::MenuItem("Humanoid ragdoll", "R") || ImGui::IsKeyPressed('R'))
		{
			auto ragdoll = humanoid_ragdoll::create(*scene, camera.position + camera.rotation * vec3(0.f, 0.f, -3.f));
			setSelectedEntity(ragdoll.torso);
			clicked = true;
		}

		if (ImGui::MenuItem("Vehicle", "V") || ImGui::IsKeyPressed('V'))
		{
			auto vehicle = vehicle::create(*scene, camera.position + camera.rotation * vec3(0.f, 0.f, -4.f));
			setSelectedEntity(vehicle.motor);
			clicked = true;
		}

		if (clicked)
		{
			ImGui::CloseCurrentPopup();
		}

		ImGui::EndPopup();
	}

	return clicked;
}

void scene_editor::serializeToFile()
{
	serializeSceneToYAMLFile(*scene, renderer->settings);
}

bool scene_editor::deserializeFromFile()
{
	std::string environmentName;
	if (deserializeSceneFromYAMLFile(*scene, renderer->settings, environmentName))
	{
		scene->stop();

		setSelectedEntity({});
		scene->environment.setFromTexture(environmentName);
		scene->environment.forceUpdate(this->scene->sun.direction);
		renderer->pathTracer.resetRendering();

		return true;
	}
	return false;
}

bool scene_editor::editCamera(render_camera& camera)
{
	bool result = false;
	if (ImGui::BeginTree("Camera"))
	{
		if (ImGui::BeginProperties())
		{
			UNDOABLE_SETTING("field of view", camera.verticalFOV,
				result |= ImGui::PropertySliderAngle("Field of view", camera.verticalFOV, 1.f, 150.f));
			UNDOABLE_SETTING("near plane", camera.nearPlane,
				result |= ImGui::PropertyDrag("Near plane", camera.nearPlane, 0.01f, 0.f));

			bool infiniteFarplane = camera.farPlane < 0.f;
			UNDOABLE_SETTING("infinite far plane", camera.farPlane,
				if (ImGui::PropertyCheckbox("Infinite far plane", infiniteFarplane))
				{
					if (!infiniteFarplane)
					{
						camera.farPlane = (camera.farPlane == -1.f) ? 500.f : -camera.farPlane;
					}
					else
					{
						camera.farPlane = -camera.farPlane;
					}
					result = true;
				});
			if (!infiniteFarplane)
			{
				UNDOABLE_SETTING("far plane", camera.farPlane,
					result |= ImGui::PropertyDrag("Far plane", camera.farPlane, 0.1f, 0.f));
			}

			ImGui::EndProperties();
		}

		ImGui::EndTree();
	}
	return result;
}

bool scene_editor::editTonemapping(tonemap_settings& tonemap)
{
	bool result = false;
	if (ImGui::BeginTree("Tonemapping"))
	{
		ImGui::PlotLines("",
			[](void* data, int idx)
		{
			float t = idx * 0.01f;
			tonemap_settings& aces = *(tonemap_settings*)data;
			return aces.tonemap(t);
		},
			&tonemap, 100, 0, 0, 0.f, 1.f, ImVec2(250.f, 250.f));

		if (ImGui::BeginProperties())
		{
			UNDOABLE_SETTING("shoulder strength", tonemap.A,
				result |= ImGui::PropertySlider("Shoulder strength", tonemap.A, 0.f, 1.f));
			UNDOABLE_SETTING("linear strength", tonemap.B,
				result |= ImGui::PropertySlider("Linear strength", tonemap.B, 0.f, 1.f));
			UNDOABLE_SETTING("linear angle", tonemap.C,
				result |= ImGui::PropertySlider("Linear angle", tonemap.C, 0.f, 1.f));
			UNDOABLE_SETTING("toe strength", tonemap.D,
				result |= ImGui::PropertySlider("Toe strength", tonemap.D, 0.f, 1.f));
			UNDOABLE_SETTING("tone numerator", tonemap.E,
				result |= ImGui::PropertySlider("Tone numerator", tonemap.E, 0.f, 1.f));
			UNDOABLE_SETTING("toe denominator", tonemap.F,
				result |= ImGui::PropertySlider("Toe denominator", tonemap.F, 0.f, 1.f));
			UNDOABLE_SETTING("linear white", tonemap.linearWhite,
				result |= ImGui::PropertySlider("Linear white", tonemap.linearWhite, 0.f, 100.f));
			UNDOABLE_SETTING("exposure", tonemap.exposure,
				result |= ImGui::PropertySlider("Exposure", tonemap.exposure, -3.f, 3.f));
			ImGui::EndProperties();
		}

		ImGui::EndTree();
	}
	return result;
}

bool scene_editor::editSunShadowParameters(directional_light& sun)
{
	bool result = false;
	if (ImGui::BeginTree("Sun"))
	{
		if (ImGui::BeginProperties())
		{
			UNDOABLE_SETTING("sun intensity", sun.intensity,
				result |= ImGui::PropertySlider("Intensity", sun.intensity, 0.f, 1000.f));
			UNDOABLE_SETTING("sun color", sun.color,
				result |= ImGui::PropertyColorWheel("Color", sun.color));

			UNDOABLE_SETTING("sun shadow resolution", sun.shadowDimensions,
				result |= ImGui::PropertyDropdownPowerOfTwo("Shadow resolution", 128, 2048, sun.shadowDimensions));
			UNDOABLE_SETTING("stabilize", sun.stabilize,
				result |= ImGui::PropertyCheckbox("Stabilize", sun.stabilize));
			UNDOABLE_SETTING("negative z-offset", sun.negativeZOffset,
				result |= ImGui::PropertyDrag("Negative z-offset", sun.negativeZOffset, 0.5f, 0.f));

			UNDOABLE_SETTING("cascade count", sun.numShadowCascades,
				result |= ImGui::PropertySlider("Cascade count", sun.numShadowCascades, 1, 4));

			const float minCascadeDistance = 0.f, maxCascadeDistance = 300.f;
			const float minBias = 0.f, maxBias = 0.0015f;
			const float minBlend = 0.f, maxBlend = 10.f;
			if (sun.numShadowCascades == 1)
			{
				UNDOABLE_SETTING("cascade distance", sun.cascadeDistances.x,
					result |= ImGui::PropertySlider("Distance", sun.cascadeDistances.x, minCascadeDistance, maxCascadeDistance));
				UNDOABLE_SETTING("cascade bias", sun.bias.x,
					result |= ImGui::PropertySlider("Bias", sun.bias.x, minBias, maxBias, "%.6f"));
				UNDOABLE_SETTING("cascade blend distances", sun.blendDistances.x,
					result |= ImGui::PropertySlider("Blend distances", sun.blendDistances.x, minBlend, maxBlend, "%.6f"));
			}
			else if (sun.numShadowCascades == 2)
			{
				UNDOABLE_SETTING("cascade distance", sun.cascadeDistances.xy,
					result |= ImGui::PropertySlider("Distance", sun.cascadeDistances.xy, minCascadeDistance, maxCascadeDistance));
				UNDOABLE_SETTING("cascade bias", sun.bias.xy,
					result |= ImGui::PropertySlider("Bias", sun.bias.xy, minBias, maxBias, "%.6f"));
				UNDOABLE_SETTING("cascade blend distances", sun.blendDistances.xy,
					result |= ImGui::PropertySlider("Blend distances", sun.blendDistances.xy, minBlend, maxBlend, "%.6f"));
			}
			else if (sun.numShadowCascades == 3)
			{
				UNDOABLE_SETTING("cascade distance", sun.cascadeDistances.xyz,
					result |= ImGui::PropertySlider("Distance", sun.cascadeDistances.xyz, minCascadeDistance, maxCascadeDistance));
				UNDOABLE_SETTING("cascade bias", sun.bias.xyz,
					result |= ImGui::PropertySlider("Bias", sun.bias.xyz, minBias, maxBias, "%.6f"));
				UNDOABLE_SETTING("cascade blend distances", sun.blendDistances.xyz,
					result |= ImGui::PropertySlider("Blend distances", sun.blendDistances.xyz, minBlend, maxBlend, "%.6f"));
			}
			else if (sun.numShadowCascades == 4)
			{
				UNDOABLE_SETTING("cascade distance", sun.cascadeDistances,
					result |= ImGui::PropertySlider("Distance", sun.cascadeDistances, minCascadeDistance, maxCascadeDistance));
				UNDOABLE_SETTING("cascade bias", sun.bias,
					result |= ImGui::PropertySlider("Bias", sun.bias, minBias, maxBias, "%.6f"));
				UNDOABLE_SETTING("cascade blend distances", sun.blendDistances,
					result |= ImGui::PropertySlider("Blend distances", sun.blendDistances, minBlend, maxBlend, "%.6f"));
			}

			ImGui::EndProperties();
		}

		if (ImGui::BeginTree("Show##ShowShadowMaps"))
		{
			for (uint32 i = 0; i < sun.numShadowCascades; ++i)
			{
				auto vp = sun.shadowMapViewports[i];
				ImGui::Image(render_resources::shadowMap, 0, 0, ImVec2(vp.x, vp.y), ImVec2(vp.x + vp.z, vp.y + vp.w));
			}
			ImGui::EndTree();
		}

		ImGui::EndTree();
	}
	return result;
}

bool scene_editor::editAO(bool& enable, hbao_settings& settings, const ref<dx_texture>& aoTexture)
{
	bool result = false;
	if (ImGui::BeginProperties())
	{
		UNDOABLE_SETTING("enable HBAO", enable,
			result |= ImGui::PropertyCheckbox("Enable HBAO", enable));
		if (enable)
		{
			UNDOABLE_SETTING("num AO rays", settings.numRays,
				result |= ImGui::PropertySlider("Num rays", settings.numRays, 1, 16));
			UNDOABLE_SETTING("max num steps per AO ray", settings.maxNumStepsPerRay,
				result |= ImGui::PropertySlider("Max num steps per ray", settings.maxNumStepsPerRay, 1, 16));
			UNDOABLE_SETTING("AO radius", settings.radius,
				result |= ImGui::PropertySlider("Radius", settings.radius, 0.f, 1.f, "%.3fm"));
			UNDOABLE_SETTING("AO strength", settings.strength,
				result |= ImGui::PropertySlider("Strength", settings.strength, 0.f, 2.f));
		}
		ImGui::EndProperties();
	}
	if (enable && aoTexture && ImGui::BeginTree("Show##ShowAO"))
	{
		ImGui::Image(aoTexture);
		ImGui::EndTree();
	}
	return result;
}

bool scene_editor::editSSS(bool& enable, sss_settings& settings, const ref<dx_texture>& sssTexture)
{
	bool result = false;
	if (ImGui::BeginProperties())
	{
		UNDOABLE_SETTING("enable SSS", enable,
			result |= ImGui::PropertyCheckbox("Enable SSS", enable));
		if (enable)
		{
			UNDOABLE_SETTING("num SSS iterations", settings.numSteps,
				result |= ImGui::PropertySlider("Num iterations", settings.numSteps, 1, 64));
			UNDOABLE_SETTING("SSS ray distance", settings.rayDistance,
				result |= ImGui::PropertySlider("Ray distance", settings.rayDistance, 0.05f, 3.f, "%.3fm"));
			UNDOABLE_SETTING("SSS thickness", settings.thickness,
				result |= ImGui::PropertySlider("Thickness", settings.thickness, 0.05f, 1.f, "%.3fm"));
			UNDOABLE_SETTING("SSS max distance from camera", settings.maxDistanceFromCamera,
				result |= ImGui::PropertySlider("Max distance from camera", settings.maxDistanceFromCamera, 5.f, 1000.f, "%.3fm"));
			UNDOABLE_SETTING("SSS distance fadeout range", settings.distanceFadeoutRange,
				result |= ImGui::PropertySlider("Distance fadeout range", settings.distanceFadeoutRange, 1.f, 5.f, "%.3fm"));
			UNDOABLE_SETTING("SSS border fadeout", settings.borderFadeout,
				result |= ImGui::PropertySlider("Border fadeout", settings.borderFadeout, 0.f, 0.5f));
		}
		ImGui::EndProperties();
	}
	if (enable && sssTexture && ImGui::BeginTree("Show##ShowSSS"))
	{
		ImGui::Image(sssTexture);
		ImGui::EndTree();
	}
	return result;
}

bool scene_editor::editSSR(bool& enable, ssr_settings& settings, const ref<dx_texture>& ssrTexture)
{
	bool result = false;
	if (ImGui::BeginProperties())
	{
		UNDOABLE_SETTING("enable SSR", enable,
			result |= ImGui::PropertyCheckbox("Enable SSR", enable));
		if (enable)
		{
			UNDOABLE_SETTING("num SSR iterations", settings.numSteps,
				result |= ImGui::PropertySlider("Num iterations", settings.numSteps, 1, 1024));
			UNDOABLE_SETTING("SSR max distance", settings.maxDistance,
				result |= ImGui::PropertySlider("Max distance", settings.maxDistance, 5.f, 1000.f, "%.3fm"));
			UNDOABLE_SETTING("SSR min stride", settings.minStride,
				result |= ImGui::PropertySlider("Min stride", settings.minStride, 1.f, 50.f, "%.3fm"));
			UNDOABLE_SETTING("SSR max stride", settings.maxStride,
				result |= ImGui::PropertySlider("Max stride", settings.maxStride, settings.minStride, 50.f, "%.3fm"));
		}
		ImGui::EndProperties();
	}
	if (enable && ssrTexture && ImGui::BeginTree("Show##ShowSSR"))
	{
		ImGui::Image(ssrTexture);
		ImGui::EndTree();
	}
	return result;
}

bool scene_editor::editTAA(bool& enable, taa_settings& settings, const ref<dx_texture>& velocityTexture)
{
	bool result = false;
	if (ImGui::BeginProperties())
	{
		UNDOABLE_SETTING("enable TAA", enable,
			result |= ImGui::PropertyCheckbox("Enable TAA", enable));
		if (enable)
		{
			UNDOABLE_SETTING("TAA jitter strength", settings.cameraJitterStrength,
				result |= ImGui::PropertySlider("Jitter strength", settings.cameraJitterStrength));
		}
		ImGui::EndProperties();
	}
	if (enable && velocityTexture && ImGui::BeginTree("Show##ShowTAA"))
	{
		ImGui::Image(velocityTexture);
		ImGui::EndTree();
	}
	return result;
}

bool scene_editor::editBloom(bool& enable, bloom_settings& settings, const ref<dx_texture>& bloomTexture)
{
	bool result = false;
	if (ImGui::BeginProperties())
	{
		UNDOABLE_SETTING("enable bloom", enable,
			result |= ImGui::PropertyCheckbox("Enable bloom", enable));
		if (enable)
		{
			UNDOABLE_SETTING("bloom threshold", settings.threshold,
				result |= ImGui::PropertySlider("Bloom threshold", settings.threshold, 0.5f, 100.f));
			UNDOABLE_SETTING("bloom strength", settings.strength,
				result |= ImGui::PropertySlider("Bloom strength", settings.strength));
		}
		ImGui::EndProperties();
	}
	if (enable && bloomTexture && ImGui::BeginTree("Show##ShowBloom"))
	{
		ImGui::Image(bloomTexture);
		ImGui::EndTree();
	}
	return result;
}

bool scene_editor::editSharpen(bool& enable, sharpen_settings& settings)
{
	bool result = false;
	if (ImGui::BeginProperties())
	{
		UNDOABLE_SETTING("enable sharpen", enable,
			result |= ImGui::PropertyCheckbox("Enable sharpen", enable));
		if (enable)
		{
			UNDOABLE_SETTING("sharpen strength", settings.strength,
				result |= ImGui::PropertySlider("Sharpen strength", settings.strength));
		}
		ImGui::EndProperties();
	}
	return result;
}

void scene_editor::drawSettings(float dt)
{
	game_scene* scene = &this->scene->getCurrentScene();

	if (ImGui::Begin("Settings"))
	{
		path_tracer& pathTracer = renderer->pathTracer;

		ImGui::Text("%.3f ms, %u FPS", dt * 1000.f, (uint32)(1.f / dt));

		if (ImGui::BeginProperties())
		{
			UNDOABLE_SETTING("time scale", this->scene->timestepScale,
				ImGui::PropertySlider("Time scale", this->scene->timestepScale));

			UNDOABLE_SETTING("renderer mode", renderer->mode,
				if (ImGui::PropertyDropdown("Renderer mode", rendererModeNames, renderer_mode_count, (uint32&)renderer->mode))
				{
					pathTracer.resetRendering();
				});

			dx_memory_usage memoryUsage = dxContext.getMemoryUsage();

			ImGui::PropertyValue("Video memory usage", "%u / %uMB", memoryUsage.currentlyUsed, memoryUsage.available);
			//ImGui::PropertyValue("Running command lists", "%u", dxContext.renderQueue.numRunningCommandLists);

			UNDOABLE_SETTING("aspect ratio", renderer->aspectRatioMode,
				ImGui::PropertyDropdown("Aspect ratio", aspectRatioNames, aspect_ratio_mode_count, (uint32&)renderer->aspectRatioMode));

			UNDOABLE_SETTING("static shadow map caching", enableStaticShadowMapCaching,
				ImGui::PropertyCheckbox("Static shadow map caching", enableStaticShadowMapCaching));

			ImGui::EndProperties();
		}

		editCamera(this->scene->camera);
		editTonemapping(renderer->settings.tonemapSettings);
		editSunShadowParameters(this->scene->sun);

		if (ImGui::BeginTree("Post processing"))
		{
			if (renderer->spec.allowAO) { editAO(renderer->settings.enableAO, renderer->settings.aoSettings, renderer->getAOResult()); ImGui::Separator(); }
			if (renderer->spec.allowSSS) { editSSS(renderer->settings.enableSSS, renderer->settings.sssSettings, renderer->getSSSResult()); ImGui::Separator(); }
			if (renderer->spec.allowSSR) { editSSR(renderer->settings.enableSSR, renderer->settings.ssrSettings, renderer->getSSRResult()); ImGui::Separator(); }
			if (renderer->spec.allowTAA) { editTAA(renderer->settings.enableTAA, renderer->settings.taaSettings, renderer->getScreenVelocities()); ImGui::Separator(); }
			if (renderer->spec.allowBloom) { editBloom(renderer->settings.enableBloom, renderer->settings.bloomSettings, renderer->getBloomResult()); ImGui::Separator(); }
			editSharpen(renderer->settings.enableSharpen, renderer->settings.sharpenSettings);

			ImGui::EndTree();
		}

		if (ImGui::BeginTree("Environment"))
		{
			auto& environment = this->scene->environment;

			if (ImGui::BeginProperties())
			{
				asset_handle handle = (environment.sky) ? environment.sky->handle : asset_handle{};
				if (ImGui::PropertyAssetHandle("Texture source", EDITOR_ICON_IMAGE_HDR, handle, "Make proc"))
				{
					if (handle)
					{
						environment.setFromTexture(getPathFromAssetHandle(handle));
					}
					else
					{
						environment.setToProcedural(this->scene->sun.direction);
					}
				}

				UNDOABLE_SETTING("sky intensity", environment.skyIntensity,
					ImGui::PropertySlider("Sky intensity", environment.skyIntensity, 0.f, 2.f));
				UNDOABLE_SETTING("GI intensity", environment.globalIlluminationIntensity,
					ImGui::PropertySlider("GI intensity", environment.globalIlluminationIntensity, 0.f, 2.f));

				UNDOABLE_SETTING("GI mode", environment.giMode,
					ImGui::PropertyDropdown("GI mode", environmentGIModeNames, 1 + dxContext.featureSupport.raytracing(), (uint32&)environment.giMode));

				ImGui::EndProperties();
			}

			if (environment.giMode == environment_gi_raytraced)
			{
				if (ImGui::BeginTree("Light probe"))
				{
					auto& grid = environment.lightProbeGrid;

					if (ImGui::BeginProperties())
					{
						UNDOABLE_SETTING("visualize probes", grid.visualizeProbes,
							ImGui::PropertyCheckbox("Visualize probes", grid.visualizeProbes));
						UNDOABLE_SETTING("visualize rays", grid.visualizeRays,
							ImGui::PropertyCheckbox("Visualize rays", grid.visualizeRays));

						UNDOABLE_SETTING("auto rotate rays", grid.autoRotateRays,
							ImGui::PropertyCheckbox("Auto rotate rays", grid.autoRotateRays));
						if (!grid.autoRotateRays)
						{
							grid.rotateRays = ImGui::PropertyButton("Rotate", "Go");
						}

						ImGui::EndProperties();
					}

					if (ImGui::BeginTree("Irradiance"))
					{
						if (ImGui::BeginProperties())
						{
							UNDOABLE_SETTING("irradiance UI scale", grid.irradianceUIScale,
								ImGui::PropertySlider("Scale", grid.irradianceUIScale, 0.1f, 20.f));
							ImGui::EndProperties();
						}
						ImGui::Image(grid.irradiance, (uint32)(grid.irradiance->width * grid.irradianceUIScale));
						ImGui::EndTree();
					}
					if (ImGui::BeginTree("Depth"))
					{
						if (ImGui::BeginProperties())
						{
							UNDOABLE_SETTING("depth UI scale", grid.depthUIScale,
								ImGui::PropertySlider("Scale", grid.depthUIScale, 0.1f, 20.f));
							ImGui::EndProperties();
						}
						ImGui::Image(grid.depth, (uint32)(grid.depth->width * grid.depthUIScale));
						ImGui::EndTree();
					}
					if (ImGui::BeginTree("Raytraced radiance"))
					{
						if (ImGui::BeginProperties())
						{
							UNDOABLE_SETTING("raytraced radiance UI scale", grid.raytracedRadianceUIScale,
								ImGui::PropertySlider("Scale", grid.raytracedRadianceUIScale, 0.1f, 20.f));
							ImGui::EndProperties();
						}
						ImGui::Image(grid.raytracedRadiance, (uint32)(grid.raytracedRadiance->width * grid.raytracedRadianceUIScale));
						ImGui::EndTree();
					}

					ImGui::EndTree();
				}
			}


			ImGui::EndTree();
		}

		if (ImGui::BeginTree("Physics"))
		{
			if (ImGui::BeginProperties())
			{
				UNDOABLE_SETTING("fixed frame rate", physicsSettings.fixedFrameRate,
					ImGui::PropertyCheckbox("Fixed frame rate (deterministic)", physicsSettings.fixedFrameRate));

				if (physicsSettings.fixedFrameRate)
				{
					UNDOABLE_SETTING("frame rate", physicsSettings.frameRate,
						ImGui::PropertyInput("Frame rate", physicsSettings.frameRate));
					if (physicsSettings.frameRate < 30)
					{
						ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.f, 0.f, 0.f, 1.f));
						ImGui::PropertyValue("", "Low frame rate");
						ImGui::PopStyleColor();
					}

					UNDOABLE_SETTING("max physics steps per frame", physicsSettings.maxPhysicsIterationsPerFrame,
						ImGui::PropertyDrag("Max physics steps per frame", physicsSettings.maxPhysicsIterationsPerFrame));
				}

				UNDOABLE_SETTING("rigid solver iterations", physicsSettings.numRigidSolverIterations,
					ImGui::PropertySlider("Rigid solver iterations", physicsSettings.numRigidSolverIterations, 1, 200));

				UNDOABLE_SETTING("cloth velocity iterations", physicsSettings.numClothVelocityIterations,
					ImGui::PropertySlider("Cloth velocity iterations", physicsSettings.numClothVelocityIterations, 0, 10));
				UNDOABLE_SETTING("cloth position iterations", physicsSettings.numClothPositionIterations,
					ImGui::PropertySlider("Cloth position iterations", physicsSettings.numClothPositionIterations, 0, 10));
				UNDOABLE_SETTING("cloth drift iterations", physicsSettings.numClothDriftIterations,
					ImGui::PropertySlider("Cloth drift iterations", physicsSettings.numClothDriftIterations, 0, 10));

				UNDOABLE_SETTING("test force", physicsTestForce,
					ImGui::PropertySlider("Test force", physicsTestForce, 1.f, 10000.f));

				UNDOABLE_SETTING("SIMD broad phase", physicsSettings.simdBroadPhase,
					ImGui::PropertyCheckbox("SIMD broad phase", physicsSettings.simdBroadPhase));
				UNDOABLE_SETTING("SIMD narrow phase", physicsSettings.simdNarrowPhase,
					ImGui::PropertyCheckbox("SIMD narrow phase", physicsSettings.simdNarrowPhase));
				UNDOABLE_SETTING("SIMD constraint solver", physicsSettings.simdConstraintSolver,
					ImGui::PropertyCheckbox("SIMD constraint solver", physicsSettings.simdConstraintSolver));

				ImGui::EndProperties();
			}
			ImGui::EndTree();
		}

		if (ImGui::BeginTree("Audio"))
		{
			bool change = false;
			if (ImGui::BeginProperties())
			{
				const float maxVolume = 3.f;
				UNDOABLE_SETTING("master volume", masterAudioSettings.volume,
					change |= ImGui::PropertySlider("Master volume", masterAudioSettings.volume, 0.f, maxVolume));

				ImGui::PropertySeparator();

				for (uint32 i = 0; i < sound_type_count; ++i)
				{
					UNDOABLE_SETTING(soundTypeNames[i], soundTypeVolumes[i],
						change |= ImGui::PropertySlider(soundTypeNames[i], soundTypeVolumes[i], 0.f, 1.f));
				}

				ImGui::PropertySeparator();

				UNDOABLE_SETTING("toggle reverb", masterAudioSettings.reverbEnabled,
					ImGui::PropertyCheckbox("Reverb enabled", masterAudioSettings.reverbEnabled));

				if (masterAudioSettings.reverbEnabled)
				{
					UNDOABLE_SETTING("reverb preset", masterAudioSettings.reverbPreset,
						change |= ImGui::PropertyDropdown("Reverb preset", reverbPresetNames, reverb_preset_count, (uint32&)masterAudioSettings.reverbPreset));
				}

				ImGui::EndProperties();
			}
			ImGui::EndTree();
		}

		if (renderer->mode == renderer_mode_pathtraced)
		{
			if (ImGui::BeginProperties())
			{
				auto& settings = pathTracer.settings;

				UNDOABLE_SETTING("max recursion depth", settings.recursionDepth,
					ImGui::PropertySlider("Max recursion depth", settings.recursionDepth, 0, settings.maxRecursionDepth - 1));
				UNDOABLE_SETTING("start russion roulette after", settings.startRussianRouletteAfter,
					ImGui::PropertySlider("Start russian roulette after", settings.startRussianRouletteAfter, 0, settings.recursionDepth));
				UNDOABLE_SETTING("use thin lens camera", settings.useThinLensCamera,
					ImGui::PropertyCheckbox("Use thin lens camera", settings.useThinLensCamera));
				if (settings.useThinLensCamera)
				{
					UNDOABLE_SETTING("focal length", settings.focalLength,
						ImGui::PropertySlider("Focal length", settings.focalLength, 0.5f, 50.f));
					UNDOABLE_SETTING("f-number", settings.fNumber,
						ImGui::PropertySlider("F-Number", settings.fNumber, 1.f, 128.f));
				}
				UNDOABLE_SETTING("use real materials", settings.useRealMaterials,
					ImGui::PropertyCheckbox("Use real materials", settings.useRealMaterials));
				UNDOABLE_SETTING("enable direct lighting", settings.enableDirectLighting,
					ImGui::PropertyCheckbox("Enable direct lighting", settings.enableDirectLighting));
				if (settings.enableDirectLighting)
				{
					UNDOABLE_SETTING("light intensity scale", settings.lightIntensityScale,
						ImGui::PropertySlider("Light intensity scale", settings.lightIntensityScale, 0.f, 50.f));
					UNDOABLE_SETTING("point light radius", settings.pointLightRadius,
						ImGui::PropertySlider("Point light radius", settings.pointLightRadius, 0.01f, 1.f));

					UNDOABLE_SETTING("multiple importance sampling", settings.multipleImportanceSampling,
						ImGui::PropertyCheckbox("Multiple importance sampling", settings.multipleImportanceSampling));
				}

				ImGui::EndProperties();
			}
		}
		else
		{
			//if (ImGui::BeginTree("Particle systems"))
			//{
			//	editFireParticleSystem(fireParticleSystem);
			//	editBoidParticleSystem(boidParticleSystem);
			//
			//	ImGui::EndTree();
			//}
		}
	}

	ImGui::End();
}





```

`src/editor/editor.h`:

```h
#pragma once

#include "scene/scene.h"
#include "core/camera_controller.h"
#include "core/system.h"
#include "undo_stack.h"
#include "transformation_gizmo.h"
#include "asset_editor_panel.h"
#include "rendering/main_renderer.h"
#include "physics/physics.h"

struct scene_editor
{
	void initialize(editor_scene* scene, main_renderer* renderer, editor_panels* editorPanels);

	bool update(const user_input& input, ldr_render_pass* ldrRenderPass, float dt);

	scene_entity selectedEntity;
	physics_settings physicsSettings;

private:
	struct undo_buffer
	{
		uint8 before[128];
		template <typename T> inline T& as() { return *(T*)before; }
	};


	scene_entity selectedColliderEntity;
	scene_entity selectedConstraintEntity;

	void drawSettings(float dt);
	bool drawMainMenuBar();
	bool drawSceneHierarchy();
	bool handleUserInput(const user_input& input, ldr_render_pass* ldrRenderPass, float dt);
	bool drawEntityCreationPopup();

	void updateSelectedEntityUIRotation();

	void setSelectedEntity(scene_entity entity);


	bool editCamera(render_camera& camera);
	bool editTonemapping(tonemap_settings& tonemap);
	bool editSunShadowParameters(directional_light& sun);
	bool editAO(bool& enable, hbao_settings& settings, const ref<dx_texture>& aoTexture);
	bool editSSS(bool& enable, sss_settings& settings, const ref<dx_texture>& sssTexture);
	bool editSSR(bool& enable, ssr_settings& settings, const ref<dx_texture>& ssrTexture);
	bool editTAA(bool& enable, taa_settings& settings, const ref<dx_texture>& velocityTexture);
	bool editBloom(bool& enable, bloom_settings& settings, const ref<dx_texture>& bloomTexture);
	bool editSharpen(bool& enable, sharpen_settings& settings);

	void onObjectMoved();

	void serializeToFile();
	bool deserializeFromFile();


	template <typename value_t, typename action_t, typename... args_t>
	void undoable(const char* undoLabel, value_t before, value_t& now, args_t... args);



	editor_scene* scene;
	main_renderer* renderer;
	editor_panels* editorPanels;

	undo_stack undoStacks[2];
	undo_buffer undoBuffers[2];

	undo_stack* currentUndoStack;
	undo_buffer* currentUndoBuffer;

	transformation_gizmo gizmo;

	float physicsTestForce = 1000.f;

	camera_controller cameraController;

	vec3 selectedEntityEulerRotation;

	system_info systemInfo;

	friend struct selection_undo;
};

```

`src/editor/editor_icons.h`:

```h
#pragma once

#include <fontawesome/IconsFontAwesome5.h>

#define EDITOR_ICON_MESH		ICON_FA_CUBE
#define EDITOR_ICON_IMAGE		ICON_FA_FILE_IMAGE
#define EDITOR_ICON_IMAGE_HDR	ICON_FA_CLOUD_SUN
#define EDITOR_ICON_FONT		ICON_FA_FONT
#define EDITOR_ICON_AUDIO		ICON_FA_VOLUME_UP


```

`src/editor/file_browser.cpp`:

```cpp
#include "pch.h"
#include "file_browser.h"
#include "editor_icons.h"
#include "core/imgui.h"
#include "audio/sound.h"
#include "asset/image.h"
#include "asset/model_asset.h"

#include <shellapi.h>
#include <imgui/imgui_internal.h>

file_browser::file_browser()
{
	changeCurrentPath("assets");
}

static const char* getTypeIcon(file_browser::dir_entry_type type)
{
	if (type == file_browser::dir_entry_type_directory) return ICON_FA_FOLDER_OPEN;
	if (type == file_browser::dir_entry_type_empty_directory) return ICON_FA_FOLDER;

	if (type == file_browser::dir_entry_type_mesh) return EDITOR_ICON_MESH;
	if (type == file_browser::dir_entry_type_image) return EDITOR_ICON_IMAGE;
	if (type == file_browser::dir_entry_type_image_hdr) return EDITOR_ICON_IMAGE_HDR;
	if (type == file_browser::dir_entry_type_font) return EDITOR_ICON_FONT;
	if (type == file_browser::dir_entry_type_audio) return EDITOR_ICON_AUDIO;

	return ICON_FA_FILE;
}

static bool isDirectory(file_browser::dir_entry_type type)
{
	return type == file_browser::dir_entry_type_directory || type == file_browser::dir_entry_type_empty_directory;
}

static bool isFile(file_browser::dir_entry_type type)
{
	return !isDirectory(type);
}

void file_browser::draw()
{
	static ImGuiTextFilter filter;
	static bool showOnlyPassingItems = true;

	if (ImGui::Begin("Assets"))
	{
		if (ImGui::DisableableButton(ICON_FA_LEVEL_UP_ALT, currentPath.has_parent_path())) { changeCurrentPath(currentPath.parent_path()); }
		if (ImGui::IsItemHovered()) { ImGui::SetTooltip("Up"); }
		ImGui::SameLine();

		if (ImGui::Button(ICON_FA_REDO_ALT)) { refresh(); }
		if (ImGui::IsItemHovered()) { ImGui::SetTooltip("Refresh"); }
		ImGui::SameLine();

		ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0, 0, 0, 0));
		ImGui::Text("Current path: ");
		fs::path accPath;
		for (auto p : currentPath)
		{
			accPath = accPath.empty() ? p : (accPath / p);
			ImGui::SameLine(0, 0);
			if (ImGui::SmallButton(p.string().c_str()))
			{
				changeCurrentPath(accPath);
				break;
			}
			if (ImGui::IsItemHovered()) { ImGui::SetTooltip("Change to '%s'", accPath.u8string().c_str()); }
			ImGui::SameLine(0, 0);
			ImGui::Text("/");
		}
		ImGui::PopStyleColor();

		// Some attempts to align the selectable and the text input vertically.
		ImGui::Dummy(ImVec2(0.f, ImGui::GetStyle().FramePadding.y));
		ImGui::Selectable(ICON_FA_FILTER, &showOnlyPassingItems, 0, ImGui::CalcTextSize(ICON_FA_FILTER));
		if (ImGui::IsItemHovered()) { ImGui::SetTooltip("Show only items passing the filter search"); }
		ImGui::SameLine();
		ImGui::SetCursorPosY(ImGui::GetCursorPosY() - ImGui::GetStyle().FramePadding.y);
		filter.Draw("Search...");

		ImGui::Separator();

		int width = (int)ImGui::GetContentRegionAvail().x;
		int entryWidth = 256;
		int numColumns = max(1, width / entryWidth);

		if (ImGui::BeginTable("#direntries", numColumns))
		{
			bool skipNextTableColumn = false;

			for (auto& p : currentPathEntries)
			{
				ImGui::PushID(&p);

				if (skipNextTableColumn || ImGui::TableNextColumn())
				{
					std::string filename = p.filename.string();

					bool passesSearch = filter.PassFilter(filename.c_str());
					bool shouldDisplay = passesSearch || !showOnlyPassingItems;

					if (!shouldDisplay)
					{
						skipNextTableColumn = true;
						ImGui::PopID();
						continue;
					}
					skipNextTableColumn = false;

					if (!passesSearch)
					{
						ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
						ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.2f);
					}

					char buffer[256];
					snprintf(buffer, sizeof(buffer), "%s  %s", getTypeIcon(p.type), filename.c_str());
					ImGui::SelectableWrapped(buffer, entryWidth, false);

					if (!passesSearch)
					{
						ImGui::PopItemFlag();
						ImGui::PopStyleVar();
					}

					if (passesSearch)
					{
						// Tooltip and directory navigation.
						if (ImGui::IsItemHovered())
						{
							if (isDirectory(p.type) && ImGui::IsMouseDoubleClicked(ImGuiMouseButton_Left))
							{
								changeCurrentPath(currentPath / p.filename);
								ImGui::PopID();
								break;
							}
							else if (p.type == dir_entry_type_mesh || p.type == dir_entry_type_image_hdr)
							{
								ImGui::SetTooltip("Drag&drop into scene to instantiate.");
							}
						}

						// Context menu.
						if (ImGui::BeginPopupContextItem(0, ImGuiPopupFlags_MouseButtonRight))
						{
							if (ImGui::MenuItem("Reveal in Windows Explorer"))
							{
								fs::path fullPath = currentPath / p.filename;
								ShellExecuteW(0, 0, L"explorer.exe", (L"/select," + fullPath.wstring()).c_str(), 0, SW_SHOWNORMAL);
							}

							if (isFile(p.type) && ImGui::MenuItem("Open in default program"))
							{
								fs::path fullPath = currentPath / p.filename;
								ShellExecuteW(0, 0, fullPath.c_str(), 0, 0, SW_SHOWNORMAL);
							}
							ImGui::EndPopup();
						}

						// Drag&drop.
						if (p.type == dir_entry_type_mesh)
						{
							if (ImGui::BeginDragDropSource())
							{
								fs::path fullPath = currentPath / p.filename;
								std::string str = fullPath.string();
								ImGui::SetDragDropPayload(EDITOR_ICON_MESH, str.c_str(), str.length() + 1, ImGuiCond_Once);
								ImGui::Text("Drop into scene to instantiate.");
								ImGui::EndDragDropSource();
							}
						}
						if (p.type == dir_entry_type_image)
						{
							if (ImGui::BeginDragDropSource())
							{
								fs::path fullPath = currentPath / p.filename;
								std::string str = fullPath.string();
								ImGui::SetDragDropPayload(EDITOR_ICON_IMAGE, str.c_str(), str.length() + 1, ImGuiCond_Once);
								ImGui::EndDragDropSource();
							}
						}
						if (p.type == dir_entry_type_audio)
						{
							if (ImGui::BeginDragDropSource())
							{
								fs::path fullPath = currentPath / p.filename;
								std::string str = fullPath.string();
								ImGui::SetDragDropPayload(EDITOR_ICON_AUDIO, str.c_str(), str.length() + 1, ImGuiCond_Once);
								ImGui::EndDragDropSource();
							}
						}
						if (p.type == dir_entry_type_image_hdr)
						{
							if (ImGui::BeginDragDropSource())
							{
								fs::path fullPath = currentPath / p.filename;
								std::string str = fullPath.string();
								ImGui::SetDragDropPayload(EDITOR_ICON_IMAGE_HDR, str.c_str(), str.length() + 1, ImGuiCond_Once);
								ImGui::Text("Drop into scene to instantiate.");
								ImGui::EndDragDropSource();
							}
						}
					}
				}

				ImGui::PopID();
			}

			ImGui::EndTable();
		}
	}
	ImGui::End();
}

void file_browser::refresh()
{
	currentPathEntries.clear();
	for (auto p : fs::directory_iterator(currentPath))
	{
		dir_entry_type type = dir_entry_type_unknown;

		if (fs::is_directory(p.path()))
		{
			uint32 numChildren = (uint32)(std::distance(std::filesystem::directory_iterator{ p.path() }, std::filesystem::directory_iterator{}));
			type = numChildren ? dir_entry_type_directory : dir_entry_type_empty_directory;
		}
		else
		{
			fs::path extension = p.path().extension();
			if (isMeshExtension(extension))
			{
				type = dir_entry_type_mesh;
			}
			else if (isImageExtension(extension))
			{
				type = dir_entry_type_image;
				if (extension == ".hdr")
				{
					type = dir_entry_type_image_hdr;
				}
			}
			else if (extension == ".ttf")
			{
				type = dir_entry_type_font;
			}
			else if (isSoundExtension(extension))
			{
				type = dir_entry_type_audio;
			}
		}

		currentPathEntries.push_back({ p.path().filename(), type });
	}

	std::sort(currentPathEntries.begin(), currentPathEntries.end(), [](const dir_entry& a, const dir_entry& b)
	{
		if (isDirectory(a.type) == isDirectory(b.type))
		{
			return a.filename < b.filename;
		}
		return isDirectory(a.type);
	});
}

void file_browser::changeCurrentPath(const fs::path& path)
{
	currentPath = path;
	refresh();
}


```

`src/editor/file_browser.h`:

```h
#pragma once

#include "asset_editor_panel.h"

struct file_browser
{
	file_browser();
	void draw();

	enum dir_entry_type
	{
		dir_entry_type_unknown,

		dir_entry_type_directory,
		dir_entry_type_empty_directory,
		dir_entry_type_mesh,
		dir_entry_type_image,
		dir_entry_type_image_hdr,
		dir_entry_type_font,
		dir_entry_type_audio,
	};

private:
	struct dir_entry
	{
		fs::path filename;
		dir_entry_type type;
	};

	fs::path currentPath;
	std::vector<dir_entry> currentPathEntries;

	void changeCurrentPath(const fs::path& path);
	void refresh();
};

```

`src/editor/file_dialog.cpp`:

```cpp
#include "pch.h"
#include "file_dialog.h"

#include <commdlg.h>
#include <shlobj_core.h>

static void createFilter(char* filter, const std::string& fileDescription, const std::string& extension)
{
	int offset = sprintf(filter, "%s (*.%s)", fileDescription.c_str(), extension.c_str());
	filter[offset] = 0;
	++offset;
	offset += sprintf(filter + offset, "*.%s", extension.c_str());
}

static bool endsWith(std::string const& value, std::string const& ending)
{
	if (ending.size() > value.size()) return false;
	return std::equal(ending.rbegin(), ending.rend(), value.rbegin());
}

std::string openFileDialog(const std::string& fileDescription, const std::string& extension)
{
	char filter[128];
	createFilter(filter, fileDescription, extension);

	OPENFILENAMEA ofn = {};
	char szFile[MAX_PATH] = "";

	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = GetActiveWindow();
	ofn.lpstrFile = szFile;
	ofn.nMaxFile = sizeof(szFile);
	ofn.lpstrFilter = filter;
	ofn.nFilterIndex = 1;
	ofn.lpstrInitialDir = ".";
	ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_NOCHANGEDIR;
	if (GetOpenFileNameA(&ofn) == TRUE)
	{
		std::string result = ofn.lpstrFile;
		if (!endsWith(result, "." + extension))
		{
			result += "." + extension;
		}
		return result;
	}
	return std::string();
}

std::string saveFileDialog(const std::string& fileDescription, const std::string& extension)
{
	char filter[128];
	createFilter(filter, fileDescription, extension);

	OPENFILENAMEA ofn = {};
	char szFile[MAX_PATH] = "";

	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = GetActiveWindow();
	ofn.lpstrFile = szFile;
	ofn.nMaxFile = sizeof(szFile);
	ofn.lpstrFilter = filter;
	ofn.nFilterIndex = 1;
	ofn.lpstrInitialDir = ".";
	ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_NOCHANGEDIR;
	if (GetSaveFileNameA(&ofn) == TRUE)
	{
		std::string result = ofn.lpstrFile;
		if (!endsWith(result, "." + extension))
		{
			result += "." + extension;
		}
		return result;
	}
	return std::string();
}

#pragma warning( disable : 4244 )

std::string directoryDialog()
{
	IFileDialog* pFileOpen;

	// Create the FileOpenDialog object.
	auto hr = CoCreateInstance(CLSID_FileOpenDialog, NULL, CLSCTX_ALL,
		IID_IFileOpenDialog, reinterpret_cast<void**>(&pFileOpen));

	pFileOpen->SetOptions(FOS_PICKFOLDERS | FOS_NOCHANGEDIR | FOS_PATHMUSTEXIST);

	std::string result;

	if (SUCCEEDED(hr))
	{
		// Show the Open dialog box.
		hr = pFileOpen->Show(NULL);

		// Get the file name from the dialog box.
		if (SUCCEEDED(hr))
		{
			IShellItem* pItem;
			hr = pFileOpen->GetResult(&pItem);
			if (SUCCEEDED(hr))
			{
				PWSTR pszFilePath;
				hr = pItem->GetDisplayName(SIGDN_FILESYSPATH, &pszFilePath);

				// Display the file name to the user.
				if (SUCCEEDED(hr))
				{
					std::wstring wresult(pszFilePath);
					result = std::string(wresult.begin(), wresult.end());
					CoTaskMemFree(pszFilePath);
				}
				pItem->Release();
			}
		}
		pFileOpen->Release();
	}

	return result;
}

```

`src/editor/file_dialog.h`:

```h
#pragma once

#include <string>

std::string openFileDialog(const std::string& fileDescription, const std::string& extension);
std::string saveFileDialog(const std::string& fileDescription, const std::string& extension);
std::string directoryDialog();

```

`src/editor/transformation_gizmo.cpp`:

```cpp
#include "pch.h"
#include "transformation_gizmo.h"
#include "dx/dx_command_list.h"
#include "dx/dx_pipeline.h"
#include "geometry/mesh_builder.h"
#include "physics/bounding_volumes.h"
#include "rendering/render_utils.h"
#include "rendering/debug_visualization.h"
#include "core/imgui.h"


enum gizmo_axis
{
	gizmo_axis_x,
	gizmo_axis_y,
	gizmo_axis_z,
};

static union
{
	struct
	{
		submesh_info translationSubmesh;
		submesh_info rotationSubmesh;
		submesh_info scaleSubmesh;
		submesh_info planeSubmesh;
		submesh_info boxSubmesh;
	};

	submesh_info submeshes[5];
};

static bounding_cylinder cylinders[3] =
{
	bounding_cylinder{ vec3(0.f), vec3(1.f, 0.f, 0.f), 1.f },
	bounding_cylinder{ vec3(0.f), vec3(0.f, 1.f, 0.f), 1.f },
	bounding_cylinder{ vec3(0.f), vec3(0.f, 0.f, 1.f), 1.f },
};

static bounding_torus tori[3] =
{
	bounding_torus{ vec3(0.f), vec3(1.f, 0.f, 0.f), 1.f, 1.f },
	bounding_torus{ vec3(0.f), vec3(0.f, 1.f, 0.f), 1.f, 1.f },
	bounding_torus{ vec3(0.f), vec3(0.f, 0.f, 1.f), 1.f, 1.f },
};

struct gizmo_rectangle
{
	vec3 position;
	vec3 tangent;
	vec3 bitangent;
	vec2 radius;
};

static gizmo_rectangle rectangles[] =
{
	gizmo_rectangle{ vec3(1.f, 0.f, 1.f), vec3(1.f, 0.f, 0.f), vec3(0.f, 0.f, 1.f), vec2(1.f) },
	gizmo_rectangle{ vec3(1.f, 1.f, 0.f), vec3(1.f, 0.f, 0.f), vec3(0.f, 1.f, 0.f), vec2(1.f) },
	gizmo_rectangle{ vec3(0.f, 1.f, 1.f), vec3(0.f, 1.f, 0.f), vec3(0.f, 0.f, 1.f), vec2(1.f) },
};

static dx_mesh mesh;


void initializeTransformationGizmos()
{
	mesh_builder mesh(mesh_creation_flags_with_positions | mesh_creation_flags_with_normals);
	float shaftLength = 1.f;
	float headLength = 0.2f;
	float radius = 0.03f;
	float headRadius = 0.065f;

	arrow_mesh_desc arrowMesh;
	arrowMesh.slices = 6;
	arrowMesh.shaftRadius = radius;
	arrowMesh.headRadius = headRadius;
	arrowMesh.shaftLength = shaftLength;
	arrowMesh.headLength = headLength;
	mesh.pushArrow(arrowMesh);
	translationSubmesh = mesh.endSubmesh();

	torus_mesh_desc torusMesh;
	torusMesh.slices = 6;
	torusMesh.segments = 64;
	torusMesh.torusRadius = shaftLength;
	torusMesh.tubeRadius = radius;
	mesh.pushTorus(torusMesh);
	rotationSubmesh = mesh.endSubmesh();

	mace_mesh_desc maceMesh;
	maceMesh.slices = 6;
	maceMesh.shaftRadius = radius;
	maceMesh.headRadius = headRadius;
	maceMesh.shaftLength = shaftLength;
	maceMesh.headLength = headLength;
	mesh.pushMace(maceMesh);
	scaleSubmesh = mesh.endSubmesh();

	box_mesh_desc planeMesh;
	planeMesh.radius = vec3(shaftLength, 0.01f, shaftLength) * 0.2f;
	planeMesh.center = vec3(shaftLength, 0.f, shaftLength) * 0.35f;
	mesh.pushBox(planeMesh);
	planeSubmesh = mesh.endSubmesh();

	box_mesh_desc boxMesh;
	boxMesh.radius = (shaftLength + headLength) * 0.3f;
	mesh.pushBox(boxMesh);
	boxSubmesh = mesh.endSubmesh();

	::mesh = mesh.createDXMesh();

	for (uint32 i = 0; i < 3; ++i)
	{
		cylinders[i].positionB *= shaftLength + headLength;
		cylinders[i].radius *= radius * 1.1f;

		tori[i].majorRadius *= shaftLength;
		tori[i].tubeRadius *= radius * 1.1f;

		rectangles[i].position *= shaftLength * 0.35f;
		rectangles[i].radius *= shaftLength * 0.2f;
	}
}


uint32 transformation_gizmo::handleTranslation(trs& transform, ray r, const user_input& input, float snapping, float scaling)
{
	quat rot = (space == transformation_global) ? quat::identity : transform.rotation;

	uint32 hoverAxisIndex = -1;
	float minT = FLT_MAX;
	for (uint32 i = 0; i < 3; ++i)
	{
		float t;
		bounding_cylinder cylinder = { rot * cylinders[i].positionA * scaling + transform.position, rot * cylinders[i].positionB * scaling + transform.position, cylinders[i].radius * scaling };
		if (r.intersectCylinder(cylinder, t) && t < minT)
		{
			hoverAxisIndex = i;
			minT = t;
		}

		if (r.intersectRectangle(rot * rectangles[i].position * scaling + transform.position, rot * rectangles[i].tangent, rot * rectangles[i].bitangent, rectangles[i].radius * scaling, t) && t < minT)
		{
			hoverAxisIndex = i + 3;
			minT = t;
		}
	}

	if (input.mouse.left.clickEvent && hoverAxisIndex != -1)
	{
		dragging = true;
		axisIndex = hoverAxisIndex;

		if (hoverAxisIndex < 3)
		{
			vec3 candidate0(0.f); candidate0.data[(axisIndex + 1) % 3] = 1.f;
			vec3 candidate1(0.f); candidate1.data[(axisIndex + 2) % 3] = 1.f;

			const vec4 axisPlanes[] =
			{
				createPlane(transform.position, rot * candidate0),
				createPlane(transform.position, rot * candidate1),
			};

			float a = abs(dot(r.direction, axisPlanes[0].xyz));
			float b = abs(dot(r.direction, axisPlanes[1].xyz));

			plane = (a > b) ? axisPlanes[0] : axisPlanes[1];

			vec3 axis(0.f); axis.data[axisIndex] = 1.f;
			axis = rot * axis;

			float t;
			r.intersectPlane(plane.xyz, plane.w, t);
			anchor = dot(r.origin + t * r.direction - transform.position, axis);
		}
		else
		{
			plane = createPlane(rot * rectangles[axisIndex - 3].position + transform.position, rot * cross(rectangles[axisIndex - 3].tangent, rectangles[axisIndex - 3].bitangent));
			anchor3 = r.origin + minT * r.direction - transform.position;
		}
		originalPosition = transform.position;

		originalTransform = transform;
	}

	if (dragging)
	{
		float t;
		r.intersectPlane(plane.xyz, plane.w, t);

		if (axisIndex < 3)
		{
			vec3 axis(0.f); axis.data[axisIndex] = 1.f;
			axis = rot * axis;

			float amount = (dot(r.origin + t * r.direction - originalPosition, axis) - anchor);

			if (snapping > 0.f)
			{
				amount = round(amount / snapping) * snapping;
			}

			transform.position = originalPosition + amount * axis;
		}
		else
		{
			vec3 amount = r.origin + t * r.direction - originalPosition - anchor3;

			if (snapping > 0.f)
			{
				vec3 tangent = rot * rectangles[axisIndex - 3].tangent;
				vec3 bitangent = rot * rectangles[axisIndex - 3].bitangent;

				float tangentAmount = round(dot(tangent, amount) / snapping) * snapping;
				float bitangentAmount = round(dot(bitangent, amount) / snapping)* snapping;

				amount = tangent * tangentAmount + bitangent * bitangentAmount;
			}

			transform.position = originalPosition + amount;
		}
	}

	return dragging ? axisIndex : hoverAxisIndex;
}

uint32 transformation_gizmo::handleRotation(trs& transform, ray r, const user_input& input, float snapping, float scaling)
{
	quat rot = (space == transformation_global) ? quat::identity : transform.rotation;

	uint32 hoverAxisIndex = -1;
	float minT = FLT_MAX;
	for (uint32 i = 0; i < 3; ++i)
	{
		float t;
		bounding_torus torus = { rot * tori[i].position * scaling + transform.position, rot * tori[i].upAxis, tori[i].majorRadius * scaling, tori[i].tubeRadius * scaling };
		if (r.intersectTorus(torus, t) && t < minT)
		{
			hoverAxisIndex = i;
			minT = t;
		}
	}

	if (input.mouse.left.clickEvent && hoverAxisIndex != -1)
	{
		dragging = true;
		axisIndex = hoverAxisIndex;

		vec3 planeNormal(0.f); planeNormal.data[axisIndex] = 1.f;
		planeNormal = rot * planeNormal;
		plane = createPlane(transform.position, planeNormal);

		float t;
		r.intersectPlane(plane.xyz, plane.w, t);

		vec3 p = r.origin + t * r.direction - transform.position;
		p = conjugate(rot) * p;
		float x = p.data[(axisIndex + 1) % 3];
		float y = p.data[(axisIndex + 2) % 3];

		anchor = atan2(y, x);
		originalRotation = quat(planeNormal, anchor);

		originalTransform = transform;
	}

	if (dragging)
	{
		float t;
		r.intersectPlane(plane.xyz, plane.w, t);

		vec3 p = r.origin + t * r.direction - transform.position;
		p = conjugate(rot) * p;
		float x = p.data[(axisIndex + 1) % 3];
		float y = p.data[(axisIndex + 2) % 3];

		float angle = atan2(y, x);

		if (snapping > 0.f)
		{
			angle = round((angle - anchor) / snapping) * snapping + anchor;
		}

		quat currentRotation(plane.xyz, angle);
		quat deltaRotation = currentRotation * conjugate(originalRotation);
		transform.rotation = normalize(deltaRotation * transform.rotation);
		if (space == transformation_global)
		{
			originalRotation = currentRotation;
		}
	}

	return dragging ? axisIndex : hoverAxisIndex;
}

uint32 transformation_gizmo::handleScaling(trs& transform, ray r, const user_input& input, float scaling, const render_camera& camera, bool allowNonUniform)
{
	// We only allow scaling in local space.
	quat rot = transform.rotation;

	const float cylinderHeight = cylinders[0].positionB.x;
	const float uniformRadius = cylinderHeight * 0.3f * scaling;

	bounding_box uniformBox = bounding_box::fromCenterRadius(vec3(0.f), uniformRadius);

	ray localRay = r;
	localRay.origin = inverseTransformPosition(transform, r.origin) * transform.scale; // inverseTransformPosition applies scale, but we don't want this.
	localRay.direction = inverseTransformDirection(transform, r.direction);

	uint32 hoverAxisIndex = -1;
	float minT = FLT_MAX;
	if (localRay.intersectAABB(uniformBox, minT))
	{
		hoverAxisIndex = 3;
	}
	else if (allowNonUniform)
	{
		float minT = FLT_MAX;
		for (uint32 i = 0; i < 3; ++i)
		{
			float t;
			bounding_cylinder cylinder = { rot * cylinders[i].positionA * scaling + transform.position, rot * cylinders[i].positionB * scaling + transform.position, cylinders[i].radius * scaling };
			if (r.intersectCylinder(cylinder, t) && t < minT)
			{
				hoverAxisIndex = i;
				minT = t;
			}
		}
	}


	if (input.mouse.left.clickEvent && hoverAxisIndex != -1)
	{
		if (hoverAxisIndex < 3)
		{
			// Non-uniform scaling.
			vec3 candidate0(0.f); candidate0.data[(hoverAxisIndex + 1) % 3] = 1.f;
			vec3 candidate1(0.f); candidate1.data[(hoverAxisIndex + 2) % 3] = 1.f;

			const vec4 axisPlanes[] =
			{
				createPlane(transform.position, rot * candidate0),
				createPlane(transform.position, rot * candidate1),
			};

			dragging = true;
			axisIndex = hoverAxisIndex;

			float a = abs(dot(r.direction, axisPlanes[0].xyz));
			float b = abs(dot(r.direction, axisPlanes[1].xyz));

			plane = (a > b) ? axisPlanes[0] : axisPlanes[1];

			vec3 axis(0.f); axis.data[axisIndex] = 1.f;
			axis = rot * axis;

			float t;
			r.intersectPlane(plane.xyz, plane.w, t);
			anchor = dot(r.origin + t * r.direction - transform.position, axis);
			anchor = max(anchor, 0.0001f);
			originalScale = transform.scale;
		}
		else
		{
			// Uniform scaling.
			ASSERT(hoverAxisIndex == 3);

			dragging = true;
			axisIndex = hoverAxisIndex;

			plane = createPlane(transform.position, camera.rotation * vec3(0.f, 0.f, 1.f)); // Backward axis.

			float t;
			r.intersectPlane(plane.xyz, plane.w, t);
			anchor = dot(r.origin + t * r.direction - transform.position, camera.rotation * vec3(1.f, 1.f, 0.f));
			anchor = max(anchor, 0.0001f);
			originalScale = transform.scale;
		}

		originalTransform = transform;
	}

	if (dragging)
	{
		if (axisIndex < 3)
		{
			float t;
			r.intersectPlane(plane.xyz, plane.w, t);

			vec3 axis(0.f); axis.data[axisIndex] = 1.f;
			axis = rot * axis;

			vec3 d = (dot(r.origin + t * r.direction - transform.position, axis) / anchor) * axis;

			d = conjugate(rot) * d;
			transform.scale.data[axisIndex] = originalScale.data[axisIndex] * d.data[axisIndex];
		}
		else
		{
			ASSERT(axisIndex == 3);

			float t;
			r.intersectPlane(plane.xyz, plane.w, t);

			float d = (dot(r.origin + t * r.direction - transform.position, camera.rotation * vec3(1.f, 1.f, 0.f)) / anchor);
			
			transform.scale = originalScale * d;
		}
	}

	return dragging ? axisIndex : hoverAxisIndex;
}

bool transformation_gizmo::handleUserInput(bool allowKeyboardInput, 
	bool allowTranslation, bool allowRotation, bool allowScaling, bool allowSpaceChange)
{
	bool keyboardInteraction = false;
	bool uiInteraction = false;

	if (allowKeyboardInput && !ImGui::IsAnyItemActive() && !ImGui::AnyModifiersDown())
	{
		if (type != transformation_type_scale)
		{
			if (ImGui::IsKeyPressed('G') && allowSpaceChange)
			{
				space = (transformation_space)(1 - space);
				dragging = false;
				keyboardInteraction = true;
			}
		}
		if (ImGui::IsKeyPressed('Q'))
		{
			type = transformation_type_none;
			dragging = false;
			keyboardInteraction = true;
		}
		if (ImGui::IsKeyPressed('W') && allowTranslation)
		{
			type = transformation_type_translation;
			dragging = false;
			keyboardInteraction = true;
		}
		if (ImGui::IsKeyPressed('E') && allowRotation)
		{
			type = transformation_type_rotation;
			dragging = false;
			keyboardInteraction = true;
		}
		if (ImGui::IsKeyPressed('R') && allowScaling)
		{
			type = transformation_type_scale;
			dragging = false;
			keyboardInteraction = true;
		}
	}

	if (ImGui::BeginControlsWindow("##GizmoControls", ImVec2(0.f, 0.f), ImVec2(20.f, 20.f)))
	{
		transformation_space constantLocal = transformation_local;
		transformation_space& space = (type == transformation_type_scale) ? constantLocal : this->space;

		ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0, 0, 0, 0));

		bool allowGlobal = space == transformation_global || allowSpaceChange;
		bool allowLocal = space == transformation_local || allowSpaceChange;
		if (type == transformation_type_scale)
		{
			allowGlobal = false;
		}

		ImGui::PushID(&this->space);
		uiInteraction |= ImGui::IconRadioButton(imgui_icon_global, (int*)&space, transformation_global, IMGUI_ICON_DEFAULT_SIZE, allowGlobal);
		ImGui::SameLine(0.f, IMGUI_ICON_DEFAULT_SPACING);
		uiInteraction |= ImGui::IconRadioButton(imgui_icon_local, (int*)&space, transformation_local, IMGUI_ICON_DEFAULT_SIZE, allowLocal);
		ImGui::PopID();

		ImGui::SameLine(0.f, (float)IMGUI_ICON_DEFAULT_SIZE);


		ImGui::PushID(&type);
		uiInteraction |= ImGui::IconRadioButton(imgui_icon_cross, (int*)&type, transformation_type_none, IMGUI_ICON_DEFAULT_SIZE, true);
		ImGui::SameLine(0.f, IMGUI_ICON_DEFAULT_SPACING);
		uiInteraction |= ImGui::IconRadioButton(imgui_icon_translate, (int*)&type, transformation_type_translation, IMGUI_ICON_DEFAULT_SIZE, allowTranslation);
		ImGui::SameLine(0.f, IMGUI_ICON_DEFAULT_SPACING);
		uiInteraction |= ImGui::IconRadioButton(imgui_icon_rotate, (int*)&type, transformation_type_rotation, IMGUI_ICON_DEFAULT_SIZE, allowRotation);
		ImGui::SameLine(0.f, IMGUI_ICON_DEFAULT_SPACING);
		uiInteraction |= ImGui::IconRadioButton(imgui_icon_scale, (int*)&type, transformation_type_scale, IMGUI_ICON_DEFAULT_SIZE, allowScaling);
		ImGui::PopID();

		ImGui::SameLine(0.f, (float)IMGUI_ICON_DEFAULT_SIZE);

		ImGui::PopStyleColor();
	}

	ImGui::End();

	return keyboardInteraction || uiInteraction;
}

void transformation_gizmo::manipulateInternal(trs& transform, const render_camera& camera, const user_input& input, bool allowInput, ldr_render_pass* ldrRenderPass, bool allowNonUniformScale)
{
	if (!input.mouse.left.down || !allowInput)
	{
		dragging = false;
	}

	if (type == transformation_type_none)
	{
		return;
	}

	uint32 highlightAxis = -1;


	// Scale gizmos based on distance to camera.
	float scaling = length(transform.position - camera.position) / camera.getMinProjectionExtent() * 0.1f;

	if (allowInput)
	{
		float snapping = input.keyboard[key_ctrl].down ? (type == transformation_type_rotation ? deg2rad(45.f) : 0.5f) : 0.f;

		ray r = camera.generateWorldSpaceRay(input.mouse.relX, input.mouse.relY);

		switch (type)
		{
			case transformation_type_translation: highlightAxis = handleTranslation(transform, r, input, snapping, scaling); break;
			case transformation_type_rotation: highlightAxis = handleRotation(transform, r, input, snapping, scaling); break;
			case transformation_type_scale: highlightAxis = handleScaling(transform, r, input, scaling, camera, allowNonUniformScale); break; // TODO: Snapping for scale.
		}
	}


	// Render.

	quat rot = (space == transformation_global && type != transformation_type_scale) ? quat::identity : transform.rotation;

	{
		const quat rotations[] =
		{
			rot * quat(vec3(0.f, 0.f, -1.f), deg2rad(90.f)),
			rot,
			rot * quat(vec3(1.f, 0.f, 0.f), deg2rad(90.f)),
		};

		const vec4 colors[] =
		{
			vec4(1.f, 0.f, 0.f, 1.f),
			vec4(0.f, 1.f, 0.f, 1.f),
			vec4(0.f, 0.f, 1.f, 1.f),
		};

		if (type != transformation_type_scale || allowNonUniformScale)
		{
			for (uint32 i = 0; i < 3; ++i)
			{
				debug_render_data data = {
					createModelMatrix(transform.position, rotations[i], scaling),
					mesh.vertexBuffer, mesh.indexBuffer,
					submeshes[type],
					colors[i] * (highlightAxis == i ? 0.5f : 1.f)
				};

				ldrRenderPass->renderOverlay<debug_simple_pipeline>(data);
			}
		}

		if (type == transformation_type_scale)
		{
			debug_render_data data = {
				createModelMatrix(transform.position, rot, scaling),
				mesh.vertexBuffer, mesh.indexBuffer,
				boxSubmesh,
				vec4(0.5f) * (highlightAxis == 3 ? 0.5f : 1.f)
			};

			ldrRenderPass->renderOverlay<debug_simple_pipeline>(data);
		}
	}

	if (type == transformation_type_translation)
	{
		const quat rotations[] =
		{
			rot,
			rot * quat(vec3(1.f, 0.f, 0.f), deg2rad(-90.f)),
			rot * quat(vec3(0.f, 0.f, 1.f), deg2rad(90.f)),
		};

		const vec4 colors[] =
		{
			vec4(1.f, 0.f, 1.f, 1.f),
			vec4(1.f, 1.f, 0.f, 1.f),
			vec4(0.f, 1.f, 1.f, 1.f),
		};

		for (uint32 i = 0; i < 3; ++i)
		{
			debug_render_data data = {
				createModelMatrix(transform.position, rotations[i], scaling),
				mesh.vertexBuffer, mesh.indexBuffer,
				planeSubmesh,
				colors[i] * (highlightAxis == i + 3 ? 0.5f : 1.f)
			};

			ldrRenderPass->renderOverlay<debug_simple_pipeline>(data);
		}
	}
}

bool transformation_gizmo::manipulateTransformation(trs& transform, const render_camera& camera, const user_input& input, bool allowInput, ldr_render_pass* ldrRenderPass)
{
	bool inputCaptured = handleUserInput(allowInput, true, true, true, true);
	manipulateInternal(transform, camera, input, allowInput, ldrRenderPass);
	return dragging;
}

bool transformation_gizmo::manipulatePosition(vec3& position, const render_camera& camera, const user_input& input, bool allowInput, ldr_render_pass* ldrRenderPass)
{
	if (type == transformation_type_rotation || type == transformation_type_scale)
	{
		type = transformation_type_translation;
	}
	space = transformation_global;

	bool inputCaptured = handleUserInput(allowInput, true, false, false, false);
	trs transform = { position, quat::identity, vec3(1.f, 1.f, 1.f) };
	manipulateInternal(transform, camera, input, allowInput, ldrRenderPass);
	position = transform.position;
	return dragging;
}

bool transformation_gizmo::manipulatePositionRotation(vec3& position, quat& rotation, const render_camera& camera, const user_input& input, bool allowInput, ldr_render_pass* ldrRenderPass)
{
	if (type == transformation_type_scale)
	{
		type = transformation_type_translation;
	}

	bool inputCaptured = handleUserInput(allowInput, true, true, false, true);
	trs transform = { position, rotation, vec3(1.f, 1.f, 1.f) };
	manipulateInternal(transform, camera, input, allowInput, ldrRenderPass);
	position = transform.position;
	rotation = transform.rotation;
	return dragging;
}

bool transformation_gizmo::manipulatePositionScale(vec3& position, vec3& scale, const render_camera& camera, const user_input& input, bool allowInput, ldr_render_pass* ldrRenderPass)
{
	if (type == transformation_type_rotation)
	{
		type = transformation_type_translation;
	}

	bool inputCaptured = handleUserInput(allowInput, true, false, true, false);
	trs transform = { position, quat::identity, scale };
	manipulateInternal(transform, camera, input, allowInput, ldrRenderPass);
	position = transform.position;
	scale = transform.scale;
	return dragging;
}

bool transformation_gizmo::manipulateNothing(const render_camera& camera, const user_input& input, bool allowInput, ldr_render_pass* ldrRenderPass)
{
	dragging = false;
	bool inputCaptured = handleUserInput(allowInput, true, true, true, true);
	return false;
}

bool transformation_gizmo::manipulateBoundingSphere(bounding_sphere& sphere, const trs& parentTransform, const render_camera& camera, const user_input& input, bool allowInput, ldr_render_pass* ldrRenderPass)
{
	if (type == transformation_type_rotation)
	{
		type = transformation_type_translation;
	}

	bool inputCaptured = handleUserInput(allowInput, true, false, true, true);
	trs transform = { parentTransform.rotation * sphere.center + parentTransform.position, parentTransform.rotation, vec3(sphere.radius) };
	manipulateInternal(transform, camera, input, allowInput, ldrRenderPass, false);
	sphere.center = conjugate(parentTransform.rotation) * (transform.position - parentTransform.position);
	sphere.radius = transform.scale.x;
	return dragging;
}

bool transformation_gizmo::manipulateBoundingCapsule(bounding_capsule& capsule, const trs& parentTransform, const render_camera& camera, const user_input& input, bool allowInput, ldr_render_pass* ldrRenderPass)
{
	bool inputCaptured = handleUserInput(allowInput, true, true, true, true);
	
	vec3 a = parentTransform.position + parentTransform.rotation * capsule.positionA;
	vec3 b = parentTransform.position + parentTransform.rotation * capsule.positionB;

	vec3 center = 0.5f * (a + b);
	
	trs transform = { center, parentTransform.rotation, capsule.radius };

	a = inverseTransformPosition(transform, a);
	b = inverseTransformPosition(transform, b);

	manipulateInternal(transform, camera, input, allowInput, ldrRenderPass, false);

	a = transformPosition(transform, a);
	b = transformPosition(transform, b);

	capsule.positionA = conjugate(parentTransform.rotation) * (a - parentTransform.position);
	capsule.positionB = conjugate(parentTransform.rotation) * (b - parentTransform.position);

	capsule.radius = transform.scale.x;
	return dragging;
}

bool transformation_gizmo::manipulateBoundingCylinder(bounding_cylinder& cylinder, const trs& parentTransform, const render_camera& camera, const user_input& input, bool allowInput, ldr_render_pass* ldrRenderPass)
{
	bounding_capsule c = { cylinder.positionA, cylinder.positionB, cylinder.radius };
	bool result = manipulateBoundingCapsule(c, parentTransform, camera, input, allowInput, ldrRenderPass);
	cylinder = { c.positionA, c.positionB, c.radius };
	return result;
}

bool transformation_gizmo::manipulateBoundingBox(bounding_box& aabb, const trs& parentTransform, const render_camera& camera, const user_input& input, bool allowInput, ldr_render_pass* ldrRenderPass)
{
	if (type == transformation_type_rotation)
	{
		type = transformation_type_translation;
	}

	bool inputCaptured = handleUserInput(allowInput, true, false, true, true);
	trs transform = { parentTransform.rotation * aabb.getCenter() + parentTransform.position, parentTransform.rotation, aabb.getRadius() };
	manipulateInternal(transform, camera, input, allowInput, ldrRenderPass);
	vec3 center = conjugate(parentTransform.rotation) * (transform.position - parentTransform.position);
	vec3 radius = transform.scale;
	aabb = bounding_box::fromCenterRadius(center, radius);
	return dragging;
}

bool transformation_gizmo::manipulateOrientedBoundingBox(bounding_oriented_box& obb, const trs& parentTransform, const render_camera& camera, const user_input& input, bool allowInput, ldr_render_pass* ldrRenderPass)
{
	bool inputCaptured = handleUserInput(allowInput, true, true, true, true);
	trs transform = { parentTransform.rotation * obb.center + parentTransform.position, parentTransform.rotation, obb.radius };
	manipulateInternal(transform, camera, input, allowInput, ldrRenderPass);
	obb.center = conjugate(parentTransform.rotation) * (transform.position - parentTransform.position);
	obb.rotation = conjugate(parentTransform.rotation) * transform.rotation * obb.rotation;
	obb.radius = transform.scale;
	return dragging;
}


```

`src/editor/transformation_gizmo.h`:

```h
#pragma once

#include "core/math.h"
#include "core/input.h"
#include "core/camera.h"
#include "rendering/render_pass.h"

#include "physics/bounding_volumes.h"

struct transformation_gizmo
{
	bool manipulateTransformation(trs& transform, const render_camera& camera, const user_input& input, bool allowInput, ldr_render_pass* ldrRenderPass);
	bool manipulatePosition(vec3& position, const render_camera& camera, const user_input& input, bool allowInput, ldr_render_pass* ldrRenderPass);
	bool manipulatePositionRotation(vec3& position, quat& rotation, const render_camera& camera, const user_input& input, bool allowInput, ldr_render_pass* ldrRenderPass);
	bool manipulatePositionScale(vec3& position, vec3& scale, const render_camera& camera, const user_input& input, bool allowInput, ldr_render_pass* ldrRenderPass);
	bool manipulateNothing(const render_camera& camera, const user_input& input, bool allowInput, ldr_render_pass* ldrRenderPass);

	bool manipulateBoundingSphere(bounding_sphere& sphere, const trs& parentTransform, const render_camera& camera, const user_input& input, bool allowInput, ldr_render_pass* ldrRenderPass);
	bool manipulateBoundingCapsule(bounding_capsule& capsule, const trs& parentTransform, const render_camera& camera, const user_input& input, bool allowInput, ldr_render_pass* ldrRenderPass);
	bool manipulateBoundingCylinder(bounding_cylinder& cylinder, const trs& parentTransform, const render_camera& camera, const user_input& input, bool allowInput, ldr_render_pass* ldrRenderPass);
	bool manipulateBoundingBox(bounding_box& aabb, const trs& parentTransform, const render_camera& camera, const user_input& input, bool allowInput, ldr_render_pass* ldrRenderPass);
	bool manipulateOrientedBoundingBox(bounding_oriented_box& obb, const trs& parentTransform, const render_camera& camera, const user_input& input, bool allowInput, ldr_render_pass* ldrRenderPass);

	// Transform before start of dragging. Only valid if object was dragged.
	trs originalTransform;

	bool dragging = false;

private:
	bool handleUserInput(bool allowKeyboardInput, bool allowTranslation, bool allowRotation, bool allowScaling, bool allowSpaceChange);
	void manipulateInternal(trs& transform, const render_camera& camera, const user_input& input, bool allowInput, ldr_render_pass* ldrRenderPass, bool allowNonUniformScale = true);
	void manipulateHandles(vec3* handles, uint32 numHandles);

	enum transformation_type
	{
		transformation_type_none = -1,
		transformation_type_translation,
		transformation_type_rotation,
		transformation_type_scale,
	};

	enum transformation_space
	{
		transformation_global,
		transformation_local,
	};

	transformation_type type = transformation_type_translation;
	transformation_space space = transformation_global;

	uint32 handleTranslation(trs& transform, ray r, const user_input& input, float snapping, float scaling);
	uint32 handleRotation(trs& transform, ray r, const user_input& input, float snapping, float scaling);
	uint32 handleScaling(trs& transform, ray r, const user_input& input, float scaling, const render_camera& camera, bool allowNonUniform);

	uint32 axisIndex;
	float anchor;
	vec3 anchor3;
	vec4 plane;

	vec3 originalPosition;
	quat originalRotation;
	vec3 originalScale;
};

void initializeTransformationGizmos();


```

`src/editor/undo_stack.cpp`:

```cpp
#include "pch.h"
#include "undo_stack.h"
#include "core/imgui.h"

undo_stack::undo_stack()
{
	memorySize = MB(2);
	memory = (uint8*)malloc(memorySize);
	reset();
}

void undo_stack::pushAction(const char* name, const void* entry, uint64 entrySize, toggle_func toggle)
{
	uint64 nameLength = strlen(name) + 1;
	uint64 alignedNameLength = alignTo(nameLength, 16);
	uint64 requiredSpace = sizeof(entry_header) + alignedNameLength + entrySize;
	uint64 availableSpaceAtEnd = memory + memorySize - nextToWrite;

	uint8* address;

	if (!newest) // Stack is empty.
	{
		nextToWrite = memory;
		address = nextToWrite;
		oldest = 0;
	}
	else
	{
		ASSERT(oldest);
		address = (requiredSpace <= availableSpaceAtEnd) ? nextToWrite : memory;
	}

	uint8* end = (uint8*)alignTo(address + requiredSpace, 16);

	// Clean up blocks which are overriden by the new block.
	oldest = newest;
	if (oldest)
	{
		while (true)
		{
			void* oldestBegin = oldest;
			void* oldestEnd = oldest->getOneAfterEnd();

			if (rangesOverlap(address, end, oldestBegin, oldestEnd))
			{
				oldest = oldest->newer;
				break;
			}
			if (!oldest->older) { break; }

			oldest = oldest->older;
		}
	}

	if (oldest)
	{
		oldest->older = 0;
	}


	entry_header* header = (entry_header*)address;
	header->nameLength = alignedNameLength;
	
	char* thisName = header->getName();
	memcpy(thisName, name, nameLength);

	header->older = newest;
	if (newest)
	{
		newest->newer = header;
	}
	if (!oldest)
	{
		oldest = header;
	}
	newest = header;

	header->newer = 0;

	header->toggle = toggle;
	header->entrySize = entrySize;

	void* data = header->getData();
	memcpy(data, entry, entrySize);

	nextToWrite = end;
}

std::pair<bool, const char*> undo_stack::undoPossible()
{
	return 
	{ 
		newest != 0, 
		newest ? newest->getName() : 0 
	};
}

std::pair<bool, const char*> undo_stack::redoPossible()
{
	return 
	{ 
		newest && newest->newer || !newest && oldest,
		(newest && newest->newer) ? newest->newer->getName() : (!newest && oldest) ? oldest->getName() : 0
	};
}

void undo_stack::undo()
{
	if (newest)
	{
		void* data = newest->getData();
		newest->toggle(data);

		newest = newest->older;
		if (newest)
		{
			nextToWrite = (uint8*)alignTo(((uint8*)data + newest->entrySize), 16);
		}
		else
		{
			nextToWrite = memory;
		}

		// Keep link to newer.
	}
}

void undo_stack::redo()
{
	if (newest && newest->newer)
	{
		newest = newest->newer;

		void* data = newest->getData();
		newest->toggle(data);

		nextToWrite = (uint8*)alignTo(((uint8*)data + newest->entrySize), 16);
	}

	if (!newest && oldest)
	{
		void* data = oldest->getData();
		oldest->toggle(data);

		nextToWrite = (uint8*)alignTo(((uint8*)data + oldest->entrySize), 16);
		newest = oldest;
	}
}

void undo_stack::reset()
{
	nextToWrite = memory;
	oldest = 0;
	newest = 0;
}

bool undo_stack::showHistory(bool& open)
{
	bool result = false;

	if (open)
	{
		if (ImGui::Begin(ICON_FA_HISTORY "  Undo history", &open))
		{
			if (ImGui::DisableableButton("Clear history", oldest != 0))
			{
				reset();
			}

			ImGui::Separator();

			bool currentFound = false;

			bool clicked = false;
			entry_header* target = 0;
			int32 direction = 0;

			bool current = !newest;
			currentFound |= current;
			if (ImGui::Selectable("no changes##UndoHistory", current) && !current)
			{
				clicked = true;
				target = 0;
				direction = -1;
			}


			for (entry_header* entry = oldest; entry; entry = entry->newer)
			{
				ImGui::PushID(entry);

				bool current = entry == newest;
				currentFound |= current;
				if (ImGui::Selectable(entry->getName(), current) && !current)
				{
					clicked = true;
					target = entry;
					direction = currentFound ? 1 : -1;
				}

				ImGui::PopID();
			}

			ASSERT(currentFound);

			if (clicked)
			{
				ASSERT(direction != 0);

				while (newest != target)
				{
					(direction == 1) ? redo() : undo();
				}

				result = true;
			}
		}
		ImGui::End();
	}

	return result;
}

void undo_stack::verify()
{
	for (auto entry = oldest; entry; entry = entry->newer)
	{
		if (entry->older)
		{
			ASSERT(entry->older->newer == entry);
		}
		if (entry->newer)
		{
			ASSERT(entry->newer->older == entry);
		}
	}
}

```

`src/editor/undo_stack.h`:

```h
#pragma once

#include "core/memory.h"


struct undo_stack
{
	undo_stack();

	template <typename T>
	void pushAction(const char* name, const T& entry); // Type T must have member function void toggle().


	std::pair<bool, const char*> undoPossible();
	std::pair<bool, const char*> redoPossible();

	void undo();
	void redo();

	void reset();
	bool showHistory(bool& open);
	void verify();

private:
	typedef void (*toggle_func)(void*);

	void pushAction(const char* name, const void* entry, uint64 entrySize, toggle_func toggle);
	struct alignas(16) entry_header
	{
		toggle_func toggle;

		entry_header* newer;
		entry_header* older;

		uint64 nameLength; // Includes null-terminator.
		uint64 entrySize;

		char* getName() const
		{
			return (char*)(this + 1);
		}

		void* getData()
		{
			return (uint8*)getName() + nameLength;
		}

		void* getOneAfterEnd()
		{
			return (uint8*)getData() + entrySize;
		}
	};

	uint8* memory;
	uint32 memorySize;

	uint8* nextToWrite;
	entry_header* oldest;
	entry_header* newest;
};

template<typename T>
inline void undo_stack::pushAction(const char* name, const T& entry)
{
	//satic_assert(std::is_trivially_copyable_v<T>, "Undo entries must be trivially copyable.");
	static_assert(std::is_trivially_destructible_v<T>, "Undo entries must be trivially destructible.");

	toggle_func toggle = [](void* data)
	{
		T* t = (T*)data;
		t->toggle();
	};

	pushAction(name, &entry, sizeof(T), toggle);
}

```

`src/geometry/mesh.cpp`:

```cpp
#include "pch.h"
#include "mesh.h"
#include "mesh_builder.h"
#include "rendering/pbr.h"
#include "core/hash.h"
#include "asset/file_registry.h"
#include "asset/model_asset.h"


static void meshLoaderThread(ref<multi_mesh> result, asset_handle handle, uint32 flags, mesh_load_callback cb,
	bool async, job_handle parentJob)
{
	result->aabb = bounding_box::negativeInfinity();

	fs::path sceneFilename = getPathFromAssetHandle(handle);
	model_asset asset = load3DModelFromFile(sceneFilename);
	mesh_builder builder(flags);
	for (auto& mesh : asset.meshes)
	{
		for (auto& sub : mesh.submeshes)
		{
			const pbr_material_desc& materialDesc = asset.materials[sub.materialIndex];
			ref<pbr_material> material;
			if (!async)
			{
				material = createPBRMaterial(materialDesc);
			}
			else
			{
				material = createPBRMaterialAsync(materialDesc, parentJob);
			}

			bounding_box aabb;
			builder.pushMesh(sub, 1.f, &aabb);
			result->submeshes.push_back({ builder.endSubmesh(), aabb, trs::identity, material, mesh.name });

			result->aabb.grow(aabb.minCorner);
			result->aabb.grow(aabb.maxCorner);
		}
	}


	animation_skeleton& skeleton = result->skeleton;

	// Load skeleton.
	if (!asset.skeletons.empty() && flags & mesh_creation_flags_with_skin)
	{
		skeleton_asset& in = asset.skeletons.front();

		skeleton.joints = std::move(in.joints);
		skeleton.nameToJointID = std::move(in.nameToJointID);
		skeleton.analyzeJoints(builder.getPositions(), (uint8*)builder.getOthers() + builder.getSkinOffset(), builder.getOthersSize(), builder.getNumVertices());
	}

	// Load animations.
	if (!asset.animations.empty())
	{
		animation_asset& in = asset.animations.front();

		animation_clip& clip = skeleton.clips.emplace_back();
		clip.name = std::move(in.name);
		clip.filename = sceneFilename;
		clip.lengthInSeconds = in.duration;
		clip.joints.resize(skeleton.joints.size(), {});

		clip.positionKeyframes = std::move(in.positionKeyframes);
		clip.positionTimestamps = std::move(in.positionTimestamps);
		clip.rotationKeyframes = std::move(in.rotationKeyframes);
		clip.rotationTimestamps = std::move(in.rotationTimestamps);
		clip.scaleKeyframes = std::move(in.scaleKeyframes);
		clip.scaleTimestamps = std::move(in.scaleTimestamps);

		for (auto [name, joint] : in.joints)
		{
			auto it = skeleton.nameToJointID.find(name);
			if (it != skeleton.nameToJointID.end())
			{
				animation_joint& j = clip.joints[it->second];
				j = joint;
			}
		}
	}

	if (cb)
	{
		cb(builder, result->submeshes, result->aabb);
	}

	result->mesh = builder.createDXMesh();

	result->loadState.store(asset_loaded, std::memory_order_release);
}


static ref<multi_mesh> loadMeshFromFileInternal(const fs::path& sceneFilename, asset_handle handle, uint32 flags, mesh_load_callback cb,
	bool async, job_handle parentJob)
{
	ref<multi_mesh> result = make_ref<multi_mesh>();
	result->handle = handle;
	result->flags = flags;
	result->loadState = asset_loading;

	if (!async)
	{
		meshLoaderThread(result, handle, flags, cb, false, {});
		result->loadJob = {};
		return result;
	}
	else
	{
		struct mesh_loading_data
		{
			ref<multi_mesh> mesh;
			asset_handle handle;
			uint32 flags;
			mesh_load_callback cb;
		};

		mesh_loading_data data = { result, handle, flags, cb };

		job_handle job = lowPriorityJobQueue.createJob<mesh_loading_data>([](mesh_loading_data& data, job_handle job)
		{
			meshLoaderThread(data.mesh, data.handle, data.flags, data.cb, true, job);
		}, data, parentJob);
		job.submitNow();

		result->loadJob = job;

		return result;
	}
}

struct mesh_key
{
	asset_handle handle;
	uint32 flags;
};

namespace std
{
	template<>
	struct hash<mesh_key>
	{
		size_t operator()(const mesh_key& x) const
		{
			size_t seed = 0;
			hash_combine(seed, x.handle);
			hash_combine(seed, x.flags);
			return seed;
		}
	};
}

static bool operator==(const mesh_key& a, const mesh_key& b)
{
	return a.handle == b.handle && a.flags == b.flags;
}

static std::unordered_map<mesh_key, weakref<multi_mesh>> meshCache;
static std::mutex mutex;


static ref<multi_mesh> loadMeshFromFileAndHandle(const fs::path& filename, asset_handle handle, uint32 flags, mesh_load_callback cb,
	bool async = false, job_handle parentJob = {})
{
	if (!fs::exists(filename))
	{
		return 0;
	}

	mesh_key key = { handle, flags };

	mutex.lock();

	ref<multi_mesh> result = meshCache[key].lock();
	if (!result)
	{
		result = loadMeshFromFileInternal(filename, handle, flags, cb, async, parentJob);
		meshCache[key] = result;
	}
	else
	{
		if (async)
		{
			if (!result->loadJob.valid())
			{
				// Generate new job, which waits on asset completion.

				struct wait_data
				{
					ref<multi_mesh> mesh;
				};

				wait_data data = { result };

				job_handle job = lowPriorityJobQueue.createJob<wait_data>([](wait_data& data, job_handle job)
				{
					while (data.mesh->loadState != asset_loaded)
					{
						std::this_thread::yield();
					}
				}, data, parentJob);
				job.submitNow();

				result->loadJob = job;
			}
		}
		else
		{

		}
	}

	mutex.unlock();

	return result;
}

ref<multi_mesh> loadMeshFromFile(const fs::path& filename, uint32 flags, mesh_load_callback cb)
{
	fs::path path = filename.lexically_normal().make_preferred();

	asset_handle handle = getAssetHandleFromPath(path);
	return loadMeshFromFileAndHandle(path, handle, flags, cb);
}

ref<multi_mesh> loadMeshFromHandle(asset_handle handle, uint32 flags, mesh_load_callback cb)
{
	fs::path sceneFilename = getPathFromAssetHandle(handle);
	return loadMeshFromFileAndHandle(sceneFilename, handle, flags, cb);
}

ref<multi_mesh> loadMeshFromFileAsync(const fs::path& filename, uint32 flags, job_handle parentJob, mesh_load_callback cb)
{
	fs::path path = filename.lexically_normal().make_preferred();

	asset_handle handle = getAssetHandleFromPath(path);
	return loadMeshFromFileAndHandle(path, handle, flags, cb, true, parentJob);
}

ref<multi_mesh> loadMeshFromHandleAsync(asset_handle handle, uint32 flags, job_handle parentJob, mesh_load_callback cb)
{
	fs::path sceneFilename = getPathFromAssetHandle(handle);
	return loadMeshFromFileAndHandle(sceneFilename, handle, flags, cb, true, parentJob);
}

```

`src/geometry/mesh.h`:

```h
#pragma once

#include "asset/asset.h"
#include "physics/bounding_volumes.h"
#include "dx/dx_buffer.h"
#include "animation/animation.h"
#include "mesh_builder.h"
#include "core/job_system.h"

struct pbr_material;


struct submesh
{
	submesh_info info;
	bounding_box aabb; // In multi's local space.
	trs transform;

	ref<pbr_material> material;
	std::string name;
};

struct multi_mesh
{
	std::vector<submesh> submeshes;
	animation_skeleton skeleton;
	dx_mesh mesh;
	bounding_box aabb = { vec3(0.f), vec3(0.f) };

	asset_handle handle;
	uint32 flags;

	std::atomic<asset_load_state> loadState = asset_loaded;
	job_handle loadJob;
};


using mesh_load_callback = std::function<void(mesh_builder& builder, std::vector<submesh>& submeshes, const bounding_box& boundingBox)>;

ref<multi_mesh> loadMeshFromFile(const fs::path& filename, uint32 flags = mesh_creation_flags_default, mesh_load_callback cb = nullptr);
ref<multi_mesh> loadMeshFromHandle(asset_handle handle, uint32 flags = mesh_creation_flags_default, mesh_load_callback cb = nullptr);
ref<multi_mesh> loadMeshFromFileAsync(const fs::path& filename, uint32 flags = mesh_creation_flags_default, job_handle parentJob = {}, mesh_load_callback cb = nullptr);
ref<multi_mesh> loadMeshFromHandleAsync(asset_handle handle, uint32 flags = mesh_creation_flags_default, job_handle parentJob = {}, mesh_load_callback cb = nullptr);

// Same functions but with different default flags (includes skin).
inline ref<multi_mesh> loadAnimatedMeshFromFile(const fs::path& filename, uint32 flags = mesh_creation_flags_animated, mesh_load_callback cb = nullptr)
{
	return loadMeshFromFile(filename, flags, cb);
}
inline ref<multi_mesh> loadAnimatedMeshFromHandle(asset_handle handle, uint32 flags = mesh_creation_flags_animated, mesh_load_callback cb = nullptr)
{
	return loadMeshFromHandle(handle, flags, cb);
}
inline ref<multi_mesh> loadAnimatedMeshFromFileAsync(const fs::path& filename, uint32 flags = mesh_creation_flags_animated, job_handle parentJob = {}, mesh_load_callback cb = nullptr)
{
	return loadMeshFromFileAsync(filename, flags, parentJob, cb);
}
inline ref<multi_mesh> loadAnimatedMeshFromHandleAsync(asset_handle handle, uint32 flags = mesh_creation_flags_animated, job_handle parentJob = {}, mesh_load_callback cb = nullptr)
{
	return loadMeshFromHandleAsync(handle, flags, parentJob, cb);
}

struct mesh_component
{
	ref<multi_mesh> mesh;
};

```

`src/geometry/mesh_builder.cpp`:

```cpp
#include "pch.h"
#include "mesh_builder.h"
#include "core/color.h"

#include "asset/model_asset.h"

struct vertex_info
{
	uint32 othersSize;
	uint32 skinOffset;
};

static vertex_info getVertexInfo(uint32 flags)
{
	vertex_info result = {};
	if (flags & mesh_creation_flags_with_uvs) { result.othersSize += sizeof(vec2); }
	if (flags & mesh_creation_flags_with_normals) { result.othersSize += sizeof(vec3); }
	if (flags & mesh_creation_flags_with_tangents) { result.othersSize += sizeof(vec3); }
	if (flags & mesh_creation_flags_with_skin) { result.skinOffset = result.othersSize;	result.othersSize += sizeof(skinning_weights); }
	if (flags & mesh_creation_flags_with_colors) { result.othersSize += sizeof(uint32); }
	return result;
}

mesh_builder::mesh_builder(uint32 vertexFlags, mesh_index_type indexType)
{
	positionArena.initialize(0, GB(2));
	othersArena.initialize(0, GB(2));
	indexArena.initialize(0, GB(2));

	this->vertexFlags = vertexFlags;
	this->indexType = indexType;
	indexSize = (indexType == mesh_index_uint16) ? sizeof(uint16) : sizeof(uint32);

	vertex_info info = getVertexInfo(vertexFlags);
	othersSize = info.othersSize;
	skinOffset = info.skinOffset;
}

mesh_builder::~mesh_builder()
{
}

#define pushVertex(pos, uv, nor, tan, skin, col) \
	if (vertexFlags & mesh_creation_flags_with_positions) { *positionPtr++ = pos; }														\
	if (vertexFlags & mesh_creation_flags_with_uvs) { *(vec2*)othersPtr = uv; othersPtr += sizeof(vec2); }								\
	if (vertexFlags & mesh_creation_flags_with_normals) { *(vec3*)othersPtr = nor; othersPtr += sizeof(vec3); }							\
	if (vertexFlags & mesh_creation_flags_with_tangents) { *(vec3*)othersPtr = tan; othersPtr += sizeof(vec3); }						\
	if (vertexFlags & mesh_creation_flags_with_skin) { *(skinning_weights*)othersPtr = skin; othersPtr += sizeof(skinning_weights); }	\
	if (vertexFlags & mesh_creation_flags_with_colors) { *(uint32*)othersPtr = col; othersPtr += sizeof(uint32); }

#define triangle(triangle_type, index_type, a, b, c) *(triangle_type*)indexPtr = flipWindingOrder \
	? triangle_type{ (index_type)((a) + indexOffset), (index_type)((c) + indexOffset), (index_type)((b) + indexOffset) } \
	: triangle_type{ (index_type)((a) + indexOffset), (index_type)((b) + indexOffset), (index_type)((c) + indexOffset) }; \
	indexPtr += sizeof(triangle_type);

#define pushTriangle(a, b, c) \
	if (indexType == mesh_index_uint16) { triangle(indexed_triangle16, uint16, (a), (b), (c)); } \
	else { triangle(indexed_triangle32, uint32, (a), (b), (c)); }


void mesh_builder::pushQuad(const quad_mesh_desc& desc, bool flipWindingOrder)
{
	vec3 center = desc.center;
	vec2 radius = desc.radius;
	quat rotation = desc.rotation;

	auto [positionPtr, othersPtr, indexPtr, indexOffset] = beginPrimitive(4, 2);

	vec3 xAxis = rotation * vec3(1.f, 0.f, 0.f);
	vec3 yAxis = rotation * vec3(0.f, 1.f, 0.f);
	vec3 zAxis = rotation * vec3(0.f, 0.f, 1.f);

	vec3 x = xAxis * radius.x;
	vec3 y = yAxis * radius.y;

	pushVertex(center - x - y, vec2(0.f, 0.f), zAxis, yAxis, {}, 0);
	pushVertex(center + x - y, vec2(1.f, 0.f), zAxis, yAxis, {}, 0);
	pushVertex(center - x + y, vec2(0.f, 1.f), zAxis, yAxis, {}, 0);
	pushVertex(center + x + y, vec2(1.f, 1.f), zAxis, yAxis, {}, 0);

	pushTriangle(0, 1, 2);
	pushTriangle(1, 3, 2);
}

void mesh_builder::pushBox(const box_mesh_desc& desc, bool flipWindingOrder)
{
	vec3 center = desc.center;
	vec3 radius = desc.radius;
	quat rotation = desc.rotation;

	vec3 xAxis = rotation * vec3(1.f, 0.f, 0.f);
	vec3 yAxis = rotation * vec3(0.f, 1.f, 0.f);
	vec3 zAxis = rotation * vec3(0.f, 0.f, 1.f);

	vec3 x = xAxis * radius.x;
	vec3 y = yAxis * radius.y;
	vec3 z = zAxis * radius.z;

	if ((vertexFlags & mesh_creation_flags_with_positions)
		&& !(vertexFlags & mesh_creation_flags_with_uvs)
		&& !(vertexFlags & mesh_creation_flags_with_normals)
		&& !(vertexFlags & mesh_creation_flags_with_tangents))
	{
		auto [positionPtr, othersPtr, indexPtr, indexOffset] = beginPrimitive(8, 12);

		pushVertex(center - x - y + z, {}, {}, {}, {}, 0); // 0
		pushVertex(center + x - y + z, {}, {}, {}, {}, 0);	// x
		pushVertex(center - x + y + z, {}, {}, {}, {}, 0); // y
		pushVertex(center + x + y + z, {}, {}, {}, {}, 0);	// xy
		pushVertex(center - x - y - z, {}, {}, {}, {}, 0); // z
		pushVertex(center + x - y - z, {}, {}, {}, {}, 0); // xz
		pushVertex(center - x + y - z, {}, {}, {}, {}, 0); // yz
		pushVertex(center + x + y - z, {}, {}, {}, {}, 0); // xyz

		pushTriangle(0, 1, 2);
		pushTriangle(1, 3, 2);
		pushTriangle(1, 5, 3);
		pushTriangle(5, 7, 3);
		pushTriangle(5, 4, 7);
		pushTriangle(4, 6, 7);
		pushTriangle(4, 0, 6);
		pushTriangle(0, 2, 6);
		pushTriangle(2, 3, 6);
		pushTriangle(3, 7, 6);
		pushTriangle(4, 5, 0);
		pushTriangle(5, 1, 0);
	}
	else
	{
		auto [positionPtr, othersPtr, indexPtr, indexOffset] = beginPrimitive(24, 12);

		pushVertex(center - x - y + z, vec2(0.f, 0.f), zAxis, yAxis, {}, 0);
		pushVertex(center + x - y + z, vec2(1.f, 0.f), zAxis, yAxis, {}, 0);
		pushVertex(center - x + y + z, vec2(0.f, 1.f), zAxis, yAxis, {}, 0);
		pushVertex(center + x + y + z, vec2(1.f, 1.f), zAxis, yAxis, {}, 0);
		pushVertex(center + x - y + z, vec2(0.f, 0.f), xAxis, yAxis, {}, 0);
		pushVertex(center + x - y - z, vec2(1.f, 0.f), xAxis, yAxis, {}, 0);
		pushVertex(center + x + y + z, vec2(0.f, 1.f), xAxis, yAxis, {}, 0);
		pushVertex(center + x + y - z, vec2(1.f, 1.f), xAxis, yAxis, {}, 0);
		pushVertex(center + x - y - z, vec2(0.f, 0.f), -zAxis, yAxis, {}, 0);
		pushVertex(center - x - y - z, vec2(1.f, 0.f), -zAxis, yAxis, {}, 0);
		pushVertex(center + x + y - z, vec2(0.f, 1.f), -zAxis, yAxis, {}, 0);
		pushVertex(center - x + y - z, vec2(1.f, 1.f), -zAxis, yAxis, {}, 0);
		pushVertex(center - x - y - z, vec2(0.f, 0.f), -xAxis, yAxis, {}, 0);
		pushVertex(center - x - y + z, vec2(1.f, 0.f), -xAxis, yAxis, {}, 0);
		pushVertex(center - x + y - z, vec2(0.f, 1.f), -xAxis, yAxis, {}, 0);
		pushVertex(center - x + y + z, vec2(1.f, 1.f), -xAxis, yAxis, {}, 0);
		pushVertex(center - x + y + z, vec2(0.f, 0.f), yAxis, xAxis, {}, 0);
		pushVertex(center + x + y + z, vec2(1.f, 0.f), yAxis, xAxis, {}, 0);
		pushVertex(center - x + y - z, vec2(0.f, 1.f), yAxis, xAxis, {}, 0);
		pushVertex(center + x + y - z, vec2(1.f, 1.f), yAxis, xAxis, {}, 0);
		pushVertex(center - x - y - z, vec2(0.f, 0.f), -yAxis, xAxis, {}, 0);
		pushVertex(center + x - y - z, vec2(1.f, 0.f), -yAxis, xAxis, {}, 0);
		pushVertex(center - x - y + z, vec2(0.f, 1.f), -yAxis, xAxis, {}, 0);
		pushVertex(center + x - y + z, vec2(1.f, 1.f), -yAxis, xAxis, {}, 0);

		pushTriangle(0, 1, 2);
		pushTriangle(1, 3, 2);
		pushTriangle(4, 5, 6);
		pushTriangle(5, 7, 6);
		pushTriangle(8, 9, 10);
		pushTriangle(9, 11, 10);
		pushTriangle(12, 13, 14);
		pushTriangle(13, 15, 14);
		pushTriangle(16, 17, 18);
		pushTriangle(17, 19, 18);
		pushTriangle(20, 21, 22);
		pushTriangle(21, 23, 22);
	}
}

void mesh_builder::pushTesselatedBox(const tesselated_box_mesh_desc& desc, bool flipWindingOrder)
{
	const uint32 numVerticesPerEdge = desc.numIntervals + 1;
	const uint32 numVertices = 6 * numVerticesPerEdge * numVerticesPerEdge - 12 * numVerticesPerEdge + 8;
	const uint32 numTriangles = desc.numIntervals * desc.numIntervals * 2 * 6;

	auto [positionPtr, othersPtr, indexPtr, indexOffset] = beginPrimitive(numVertices, numTriangles);

	float distanceBetweenVertices = 1.f / desc.numIntervals;

	uint32 vertexIndex = 0;
	uint32 triangleIndex = 0;

	vec3 center = desc.center;
	quat rotation = desc.rotation;
	vec3 radius = desc.radius;

	// Upper face.
	for (uint32 z = 0; z < numVerticesPerEdge; ++z)
	{
		for (uint32 x = 0; x < numVerticesPerEdge; ++x)
		{
			ASSERT(vertexIndex < numVertices);
			pushVertex(center + rotation * (radius * vec3(x * distanceBetweenVertices, 1.f, z * distanceBetweenVertices)), {}, {}, {}, {}, 0);

			if (z < numVerticesPerEdge - 1 && x < numVerticesPerEdge - 1)
			{
				ASSERT(triangleIndex < numTriangles);
				pushTriangle(z * numVerticesPerEdge + x, (z + 1) * numVerticesPerEdge + x, (z + 1) * numVerticesPerEdge + (x + 1));
				ASSERT(triangleIndex < numTriangles);
				pushTriangle((z + 1) * numVerticesPerEdge + (x + 1), z * numVerticesPerEdge + (x + 1), z * numVerticesPerEdge + x);

				triangleIndex += 2;
			}

			++vertexIndex;
		}
	}

	const uint32 ringSize = (numVerticesPerEdge - 1) * 4;

	// Sides.
	uint32 y = 1;

	vec3 directions[] = { vec3(1.f, 0.f, 0.f), vec3(0.f, 0.f, 1.f), vec3(-1.f, 0.f, 0.f), vec3(0.f, 0.f, -1.f) };
	uint32 directionIndex = 0;

	vec3 currentPos(0.f, 1.f - y * distanceBetweenVertices, 0.f);

	uint32 ringStart = vertexIndex;

	while (y < numVerticesPerEdge)
	{
		vec3 direction = directions[directionIndex];
		for (uint32 i = 0; i < numVerticesPerEdge - 1; ++i)
		{
			ASSERT(vertexIndex < numVertices);
			pushVertex(desc.center + desc.rotation * (radius * currentPos), {}, {}, {}, {}, 0);
			currentPos += distanceBetweenVertices * direction;

			uint32 top, topLeft;
			if (y == 1)
			{
				switch (directionIndex)
				{
				case 0:
					top = i;
					topLeft = top + 1;
					break;
				case 1:
					top = i * numVerticesPerEdge + (numVerticesPerEdge - 1);
					topLeft = top + numVerticesPerEdge;
					break;
				case 2:
					top = numVerticesPerEdge * numVerticesPerEdge - 1 - i;
					topLeft = top - 1;
					break;
				case 3:
					top = (numVerticesPerEdge - 1 - i) * numVerticesPerEdge;
					topLeft = top - numVerticesPerEdge;
					break;
				}
			}
			else
			{
				top = vertexIndex - ringSize;
				topLeft = top + 1;
				if (ringStart == topLeft)
				{
					topLeft -= ringSize;
				}
			}

			uint32 left = vertexIndex + 1;
			if (ringStart + ringSize == left)
			{
				left -= ringSize;
			}

			ASSERT(triangleIndex < numTriangles);
			pushTriangle(topLeft, left, vertexIndex);
			ASSERT(triangleIndex < numTriangles);
			pushTriangle(vertexIndex, top, topLeft);

			triangleIndex += 2;

			++vertexIndex;
		}

		directionIndex = (directionIndex + 1) % 4;
		if (directionIndex == 0)
		{
			++y;
			ringStart = vertexIndex;
			currentPos.y = 1.f - y * distanceBetweenVertices;
		}
	}

	// Bottom face.
	uint32 firstOfLastRing = vertexIndex - ringSize;
	for (uint32 z = 1; z < numVerticesPerEdge - 1; ++z)
	{
		for (uint32 x = 1; x < numVerticesPerEdge - 1; ++x)
		{
			ASSERT(vertexIndex < numVertices);
			pushVertex(desc.center + desc.rotation * (radius * vec3(x * distanceBetweenVertices, 0.f, z * distanceBetweenVertices)), {}, {}, {}, {}, 0);

			uint32 top = vertexIndex - (numVerticesPerEdge - 2);
			if (z == 1)
			{
				top = firstOfLastRing + x;
			}

			uint32 right = vertexIndex + 1;
			uint32 topRight = vertexIndex + 1 - (numVerticesPerEdge - 2);
			if (x == numVerticesPerEdge - 2)
			{
				right = firstOfLastRing + numVerticesPerEdge - 1 + z;
				topRight = right - 1;
			}
			else if (z == 1)
			{
				topRight = top + 1;
			}

			// Only valid if x == 1.
			uint32 left = firstOfLastRing + ringSize - z;

			if (x == 1)
			{
				uint32 topLeft = left + 1;
				if (firstOfLastRing + ringSize == topLeft)
				{
					topLeft -= ringSize;
				}
				ASSERT(triangleIndex < numTriangles);
				pushTriangle(topLeft, top, vertexIndex);
				ASSERT(triangleIndex < numTriangles);
				pushTriangle(vertexIndex, left, topLeft);

				triangleIndex += 2;
			}

			ASSERT(triangleIndex < numTriangles);
			pushTriangle(top, topRight, right);
			ASSERT(triangleIndex < numTriangles);
			pushTriangle(right, vertexIndex, top);

			triangleIndex += 2;

			if (z == numVerticesPerEdge - 2)
			{
				uint32 bottom = firstOfLastRing + (numVerticesPerEdge - 1) * 3 - x;
				uint32 bottomLeft = bottom + 1;
				uint32 bottomRight = bottom - 1;

				if (x == 1)
				{
					ASSERT(triangleIndex < numTriangles);
					pushTriangle(left, vertexIndex, bottom);
					ASSERT(triangleIndex < numTriangles);
					pushTriangle(bottom, bottomLeft, left);

					triangleIndex += 2;
				}

				ASSERT(triangleIndex < numTriangles);
				pushTriangle(vertexIndex, right, bottomRight);
				ASSERT(triangleIndex < numTriangles);
				pushTriangle(bottomRight, bottom, vertexIndex);

				triangleIndex += 2;
			}

			++vertexIndex;
		}
	}

	if (desc.numIntervals == 1)
	{
		// Connect last two faces.

		ASSERT(numVertices == 8);

		pushTriangle(4, 5, 7);
		pushTriangle(5, 6, 7);

		triangleIndex += 2;
	}

	ASSERT(vertexIndex == numVertices);
	ASSERT(triangleIndex == numTriangles);
}

void mesh_builder::pushSphere(const sphere_mesh_desc& desc, bool flipWindingOrder)
{
	uint32 slices = desc.slices;
	uint32 rows = desc.rows;
	vec3 center = desc.center;
	float radius = desc.radius;

	ASSERT(slices > 2);
	ASSERT(rows > 0);

	float vertDeltaAngle = M_PI / (rows + 1);
	float horzDeltaAngle = 2.f * M_PI / slices;

	auto [positionPtr, othersPtr, indexPtr, indexOffset] = beginPrimitive(slices * rows + 2, 2 * rows * slices);

	// Vertices.
	pushVertex(center + vec3(0.f, -radius, 0.f), directionToPanoramaUV(vec3(0.f, -1.f, 0.f)), vec3(0.f, -1.f, 0.f), vec3(1.f, 0.f, 0.f), {}, 0);

	for (uint32 y = 0; y < rows; ++y)
	{
		float vertAngle = (y + 1) * vertDeltaAngle - M_PI;
		float vertexY = cos(vertAngle);
		float currentCircleRadius = sin(vertAngle);
		for (uint32 x = 0; x < slices; ++x)
		{
			float horzAngle = x * horzDeltaAngle;
			float vertexX = cos(horzAngle) * currentCircleRadius;
			float vertexZ = sin(horzAngle) * currentCircleRadius;
			vec3 pos(vertexX * radius, vertexY * radius, vertexZ * radius);
			vec3 nor(vertexX, vertexY, vertexZ);

			pushVertex(center + pos, directionToPanoramaUV(nor), normalize(nor), normalize(cross(vec3(0.f, 1.f, 0.f), nor)), {}, 0);
		}
	}

	pushVertex(center + vec3(0.f, radius, 0.f), directionToPanoramaUV(vec3(0.f, 1.f, 0.f)), vec3(0.f, 1.f, 0.f), vec3(1.f, 0.f, 0.f), {}, 0);

	uint32 lastVertex = slices * rows + 2;

	// Indices.
	for (uint32 x = 0; x < slices - 1; ++x)
	{
		pushTriangle(0, x + 1, x + 2);
	}
	pushTriangle(0, slices, 1);

	for (uint32 y = 0; y < rows - 1; ++y)
	{
		for (uint32 x = 0; x < slices - 1; ++x)
		{
			pushTriangle(y * slices + 1 + x, (y + 1) * slices + 2 + x, y * slices + 2 + x);
			pushTriangle(y * slices + 1 + x, (y + 1) * slices + 1 + x, (y + 1) * slices + 2 + x);
		}
		pushTriangle((uint32)(y * slices + slices), (uint32)((y + 1) * slices + 1), (uint32)(y * slices + 1));
		pushTriangle((uint32)(y * slices + slices), (uint32)((y + 1) * slices + slices), (uint32)((y + 1) * slices + 1));
	}
	for (uint32 x = 0; x < slices - 1; ++x)
	{
		pushTriangle(lastVertex - 2 - x, lastVertex - 3u - x, lastVertex - 1);
	}
	pushTriangle(lastVertex - 1 - slices, lastVertex - 2, lastVertex - 1);
}

void mesh_builder::pushIcoSphere(const icosphere_mesh_desc& desc, bool flipWindingOrder)
{
	vec3 center = desc.center;
	float radius = desc.radius;
	uint32 refinement = desc.refinement;

	struct vert
	{
		vec3 p;
		vec3 n;
		vec3 t;
	};

	std::vector<vert> vertices;
	std::vector<indexed_triangle32> triangles;

	const float t = (1.f + sqrt(5.f)) / 2.f;

#define push_ico_vertex(p) { vec3 nor = normalize(p); vec3 px = nor * radius; vec3 tan = normalize(cross(vec3(0.f, 1.f, 0.f), nor)); vertices.push_back({px, nor, tan}); }

	push_ico_vertex(vec3(-1.f, t, 0));
	push_ico_vertex(vec3(1.f, t, 0));
	push_ico_vertex(vec3(-1.f, -t, 0));
	push_ico_vertex(vec3(1.f, -t, 0));

	push_ico_vertex(vec3(0, -1.f, t));
	push_ico_vertex(vec3(0, 1.f, t));
	push_ico_vertex(vec3(0, -1.f, -t));
	push_ico_vertex(vec3(0, 1.f, -t));

	push_ico_vertex(vec3(t, 0, -1.f));
	push_ico_vertex(vec3(t, 0, 1.f));
	push_ico_vertex(vec3(-t, 0, -1.f));
	push_ico_vertex(vec3(-t, 0, 1.f));

	triangles.push_back({ 0, 11, 5 });
	triangles.push_back({ 0, 5, 1 });
	triangles.push_back({ 0, 1, 7 });
	triangles.push_back({ 0, 7, 10 });
	triangles.push_back({ 0, 10, 11 });
	triangles.push_back({ 1, 5, 9 });
	triangles.push_back({ 5, 11, 4 });
	triangles.push_back({ 11, 10, 2 });
	triangles.push_back({ 10, 7, 6 });
	triangles.push_back({ 7, 1, 8 });
	triangles.push_back({ 3, 9, 4 });
	triangles.push_back({ 3, 4, 2 });
	triangles.push_back({ 3, 2, 6 });
	triangles.push_back({ 3, 6, 8 });
	triangles.push_back({ 3, 8, 9 });
	triangles.push_back({ 4, 9, 5 });
	triangles.push_back({ 2, 4, 11 });
	triangles.push_back({ 6, 2, 10 });
	triangles.push_back({ 8, 6, 7 });
	triangles.push_back({ 9, 8, 1 });

	std::unordered_map<uint32, uint32> midpoints;

	auto getMiddlePoint = [&midpoints, &vertices, radius](uint32 a, uint32 b)
	{
		uint32 edge = (min(a, b) << 16) | (max(a, b));
		auto it = midpoints.find(edge);
		if (it == midpoints.end())
		{
			vec3 point1 = vertices[a].p;
			vec3 point2 = vertices[b].p;

			vec3 center = 0.5f * (point1 + point2);
			push_ico_vertex(center);

			uint32 index = (uint32)vertices.size() - 1;

			midpoints.insert({ edge, index });
			return index;
		}

		return it->second;
	};

	for (uint32 r = 0; r < refinement; ++r)
	{
		std::vector<indexed_triangle32> refinedTriangles;

		for (uint32 tri = 0; tri < (uint32)triangles.size(); ++tri)
		{
			indexed_triangle32& t = triangles[tri];

			uint32 a = getMiddlePoint(t.a, t.b);
			uint32 b = getMiddlePoint(t.b, t.c);
			uint32 c = getMiddlePoint(t.c, t.a);

			refinedTriangles.push_back({ t.a, a, c });
			refinedTriangles.push_back({ t.b, b, a });
			refinedTriangles.push_back({ t.c, c, b });
			refinedTriangles.push_back({ a, b, c });
		}

		triangles = refinedTriangles;
	}

	auto [positionPtr, othersPtr, indexPtr, indexOffset] = beginPrimitive((uint32)vertices.size(), (uint32)triangles.size());

	for (const vert& v : vertices)
	{
		pushVertex(v.p + center, {}, v.n, v.t, {}, 0);
	}

	for (auto t : triangles)
	{
		pushTriangle(t.a, t.b, t.c);
	}

#undef push_ico_vertex
}

void mesh_builder::pushCapsule(const capsule_mesh_desc& desc, bool flipWindingOrder)
{
	uint32 slices = desc.slices;
	uint32 rows = desc.rows;
	float height = desc.height;
	float radius = desc.radius;
	quat rotation = desc.rotation;
	vec3 center = desc.center;

	ASSERT(slices > 2);
	ASSERT(rows > 0);
	ASSERT(rows % 2 == 1);

	float vertDeltaAngle = M_PI / (rows + 1);
	float horzDeltaAngle = 2.f * M_PI / slices;
	float halfHeight = 0.5f * height;
	float texStretch = radius / (radius + halfHeight);

	auto [positionPtr, othersPtr, indexPtr, indexOffset] = beginPrimitive(slices * (rows + 1) + 2, 2 * (rows + 1) * slices);

	// Vertices.
	pushVertex(rotation * vec3(0.f, -radius - halfHeight, 0.f) + center, 
		directionToPanoramaUV(vec3(0.f, -1.f, 0.f)), 
		rotation * vec3(0.f, -1.f, 0.f), 
		rotation * vec3(1.f, 0.f, 0.f), {}, 0);

	for (uint32 y = 0; y < rows / 2 + 1; ++y)
	{
		float vertAngle = (y + 1) * vertDeltaAngle - M_PI;
		float vertexY = cosf(vertAngle);
		float currentCircleRadius = sinf(vertAngle);
		for (uint32 x = 0; x < slices; ++x)
		{
			float horzAngle = x * horzDeltaAngle;
			float vertexX = cosf(horzAngle) * currentCircleRadius;
			float vertexZ = sinf(horzAngle) * currentCircleRadius;
			vec3 pos(vertexX * radius, vertexY * radius - halfHeight, vertexZ * radius);
			vec3 nor(vertexX, vertexY, vertexZ);

			vec2 uv = directionToPanoramaUV(nor);
			uv.y *= texStretch;
			pushVertex(rotation * pos + center, uv, rotation * normalize(nor), rotation * normalize(cross(vec3(0.f, 1.f, 0.f), nor)), {}, 0);
		}
	}
	for (uint32 y = 0; y < rows / 2 + 1; ++y)
	{
		float vertAngle = (y + rows / 2 + 1) * vertDeltaAngle - M_PI;
		float vertexY = cosf(vertAngle);
		float currentCircleRadius = sinf(vertAngle);
		for (uint32 x = 0; x < slices; ++x)
		{
			float horzAngle = x * horzDeltaAngle;
			float vertexX = cosf(horzAngle) * currentCircleRadius;
			float vertexZ = sinf(horzAngle) * currentCircleRadius;
			vec3 pos(vertexX * radius, vertexY * radius + halfHeight, vertexZ * radius);
			vec3 nor(vertexX, vertexY, vertexZ);

			vec2 uv = directionToPanoramaUV(nor);
			uv.y *= texStretch;
			pushVertex(rotation * pos + center, uv, rotation * normalize(nor), rotation * normalize(cross(vec3(0.f, 1.f, 0.f), nor)), {}, 0);
		}
	}
	pushVertex(rotation * vec3(0.f, radius + halfHeight, 0.f) + center, 
		directionToPanoramaUV(vec3(0.f, 1.f, 0.f)), 
		rotation * vec3(0.f, 1.f, 0.f), 
		rotation * vec3(1.f, 0.f, 0.f), {}, 0);

	uint32 lastVertex = slices * (rows + 1) + 2;

	// Indices.
	for (uint32 x = 0; x < slices - 1; ++x)
	{
		pushTriangle(0, x + 1, x + 2);
	}
	pushTriangle(0, slices, 1);
	for (uint32 y = 0; y < rows; ++y)
	{
		for (uint32 x = 0; x < slices - 1; ++x)
		{
			pushTriangle(y * slices + 1 + x, (y + 1) * slices + 2 + x, y * slices + 2 + x);
			pushTriangle(y * slices + 1 + x, (y + 1) * slices + 1 + x, (y + 1) * slices + 2 + x);
		}
		pushTriangle(y * slices + slices, (y + 1) * slices + 1, y * slices + 1);
		pushTriangle(y * slices + slices, (y + 1) * slices + slices, (y + 1) * slices + 1);
	}
	for (uint32 x = 0; x < slices - 1; ++x)
	{
		pushTriangle(lastVertex - 2 - x, lastVertex - 3 - x, lastVertex - 1);
	}
	pushTriangle(lastVertex - 1 - slices, lastVertex - 2, lastVertex - 1);
}

struct sincos
{
	float sin, cos;
};

void mesh_builder::pushCylinder(const cylinder_mesh_desc& desc, bool flipWindingOrder)
{
	uint32 slices = desc.slices;
	float height = desc.height;
	float radius = desc.radius;
	quat rotation = desc.rotation;
	vec3 center = desc.center;

	ASSERT(slices > 2);

	float horzDeltaAngle = 2.f * M_PI / slices;
	float halfHeight = height * 0.5f;
	
	auto [positionPtr, othersPtr, indexPtr, indexOffset] = beginPrimitive(4 * slices + 2, 4 * slices);

	sincos* angles = (sincos*)alloca(sizeof(sincos) * slices);
	for (uint32 x = 0; x < slices; ++x)
	{
		float horzAngle = x * horzDeltaAngle;
		angles[x] = { sinf(horzAngle), cosf(horzAngle) };
	}

	pushVertex(center + rotation * vec3(0.f, -halfHeight, 0.f), vec2(0.25f, 0.75f), rotation * vec3(0.f, -1.f, 0.f), rotation * vec3(1.f, 0.f, 0.f), {}, 0);

	// Bottom row, normal down.
	for (uint32 x = 0; x < slices; ++x)
	{
		float horzAngle = x * horzDeltaAngle;
		float vertexX = angles[x].cos;
		float vertexZ = angles[x].sin;
		vec3 pos(vertexX * radius, -halfHeight, vertexZ * radius);
		vec3 nor(0.f, -1.f, 0.f);

		pushVertex(center + rotation * pos, remap(vec2(vertexX, vertexZ), -1.f, 1.f, vec2(0.f, 0.5f), vec2(0.5f, 1.f)), rotation * nor, rotation * vec3(1.f, 0.f, 0.f), {}, 0);
	}

	// Bottom row, normal around.
	for (uint32 x = 0; x < slices; ++x)
	{
		float horzAngle = x * horzDeltaAngle;
		float vertexX = angles[x].cos;
		float vertexZ = angles[x].sin;
		vec3 pos(vertexX * radius, -halfHeight, vertexZ * radius);
		vec3 nor(vertexX, 0.f, vertexZ);

		pushVertex(center + rotation * pos, vec2(x / (float)(slices - 1), 0.5f), rotation * nor, rotation * normalize(cross(vec3(0.f, 1.f, 0.f), nor)), {}, 0);
	}

	// Top row, normal around.
	for (uint32 x = 0; x < slices; ++x)
	{
		float horzAngle = x * horzDeltaAngle;
		float vertexX = angles[x].cos;
		float vertexZ = angles[x].sin;
		vec3 pos(vertexX * radius, halfHeight, vertexZ * radius);
		vec3 nor(vertexX, 0.f, vertexZ);

		pushVertex(center + rotation * pos, vec2(x / (float)(slices - 1), 0.f), rotation * nor, rotation * normalize(cross(vec3(0.f, 1.f, 0.f), nor)), {}, 0);
	}

	// Top row, normal up.
	for (uint32 x = 0; x < slices; ++x)
	{
		float horzAngle = x * horzDeltaAngle;
		float vertexX = angles[x].cos;
		float vertexZ = angles[x].sin;
		vec3 pos(vertexX * radius, halfHeight, vertexZ * radius);
		vec3 nor(0.f, 1.f, 0.f);

		pushVertex(center + rotation * pos, remap(vec2(vertexX, vertexZ), -1.f, 1.f, vec2(0.5f, 0.5f), vec2(1.f, 1.f)), rotation * nor, rotation * vec3(1.f, 0.f, 0.f), {}, 0);
	}

	pushVertex(center + rotation * vec3(0.f, halfHeight, 0.f), vec2(0.75f, 0.75f), rotation * vec3(0.f, 1.f, 0.f), rotation * vec3(1.f, 0.f, 0.f), {}, 0);

	uint32 lastVertex = 4 * slices + 2;

	// Indices.
	for (uint32 x = 0; x < slices - 1u; ++x)
	{
		pushTriangle(0, x + 1, x + 2);
	}
	pushTriangle(0, slices, 1);

	for (uint32 x = 0; x < slices - 1u; ++x)
	{
		pushTriangle(slices + 1 + x, 2 * slices + 2 + x, slices + 2 + x);
		pushTriangle(slices + 1 + x, 2 * slices + 1 + x, 2 * slices + 2 + x);
	}
	pushTriangle(slices + slices, 2 * slices + 1, slices + 1);
	pushTriangle(slices + slices, 2 * slices + slices, 2 * slices + 1);

	for (uint32 x = 0; x < slices - 1u; ++x)
	{
		pushTriangle(lastVertex - 2 - x, lastVertex - 3 - x, lastVertex - 1);
	}
	pushTriangle(lastVertex - 1 - slices, lastVertex - 2, lastVertex - 1);
}

void mesh_builder::pushHollowCylinder(const hollow_cylinder_mesh_desc& desc, bool flipWindingOrder)
{
	uint32 slices = desc.slices;
	float height = desc.height;
	float radius = desc.radius;
	float innerRadius = desc.innerRadius;
	quat rotation = desc.rotation;
	vec3 center = desc.center;

	ASSERT(slices > 2);

	float horzDeltaAngle = 2.f * M_PI / slices;
	float halfHeight = height * 0.5f;

	auto [positionPtr, othersPtr, indexPtr, indexOffset] = beginPrimitive(8 * slices, 8 * slices);

	sincos* angles = (sincos*)alloca(sizeof(sincos) * slices);
	for (uint32 x = 0; x < slices; ++x)
	{
		float horzAngle = x * horzDeltaAngle;
		angles[x] = { sinf(horzAngle), cosf(horzAngle) };
	}

	float radiusRelation = innerRadius / radius;

	// Bottom outer row, normal down.
	for (uint32 x = 0; x < slices; ++x)
	{
		float vertexX = angles[x].cos;
		float vertexZ = angles[x].sin;
		vec3 pos(vertexX * radius, -halfHeight, vertexZ * radius);
		vec3 nor(0.f, -1.f, 0.f);

		pushVertex(center + rotation * pos, remap(vec2(vertexX, vertexZ), -1.f, 1.f, vec2(0.f, 0.5f), vec2(0.5f, 1.f)), rotation * nor, rotation * vec3(1.f, 0.f, 0.f), {}, 0);
	}

	// Bottom row, normal around.
	for (uint32 x = 0; x < slices; ++x)
	{
		float vertexX = angles[x].cos;
		float vertexZ = angles[x].sin;
		vec3 pos(vertexX * radius, -halfHeight, vertexZ * radius);
		vec3 nor(vertexX, 0.f, vertexZ);

		pushVertex(center + rotation * pos, vec2(x / (float)(slices - 1), 0.5f), rotation * nor, rotation * normalize(cross(vec3(0.f, 1.f, 0.f), nor)), {}, 0);
	}

	// Top row, normal around.
	for (uint32 x = 0; x < slices; ++x)
	{
		float vertexX = angles[x].cos;
		float vertexZ = angles[x].sin;
		vec3 pos(vertexX * radius, halfHeight, vertexZ * radius);
		vec3 nor(vertexX, 0.f, vertexZ);

		pushVertex(center + rotation * pos, vec2(x / (float)(slices - 1), 0.f), rotation * nor, rotation * normalize(cross(vec3(0.f, 1.f, 0.f), nor)), {}, 0);
	}

	// Top row, normal up.
	for (uint32 x = 0; x < slices; ++x)
	{
		float horzAngle = x * horzDeltaAngle;
		float vertexX = cosf(horzAngle);
		float vertexZ = sinf(horzAngle);
		vec3 pos(vertexX * radius, halfHeight, vertexZ * radius);
		vec3 nor(0.f, 1.f, 0.f);

		pushVertex(center + rotation * pos, remap(vec2(vertexX, vertexZ), -1.f, 1.f, vec2(0.5f, 0.5f), vec2(1.f, 1.f)), rotation * nor, rotation * vec3(1.f, 0.f, 0.f), {}, 0);
	}

	vec2 innerUVMin = vec2(0.25f, 0.75f) - 0.25f * radiusRelation;
	vec2 innerUVMax = vec2(0.25f, 0.75f) + 0.25f * radiusRelation;

	// Bottom inner row, normal down.
	for (uint32 x = 0; x < slices; ++x)
	{
		float vertexX = angles[x].cos;
		float vertexZ = angles[x].sin;
		vec3 pos(vertexX * innerRadius, -halfHeight, vertexZ * innerRadius);
		vec3 nor(0.f, -1.f, 0.f);

		pushVertex(center + rotation * pos, remap(vec2(vertexX, vertexZ), -1.f, 1.f, innerUVMin, innerUVMax), rotation * nor, rotation * vec3(1.f, 0.f, 0.f), {}, 0);
	}

	// Bottom inner row, normal inside.
	for (uint32 x = 0; x < slices; ++x)
	{
		float vertexX = angles[x].cos;
		float vertexZ = angles[x].sin;
		vec3 pos(vertexX * innerRadius, -halfHeight, vertexZ * innerRadius);
		vec3 nor(-vertexX, 0.f, -vertexZ);

		pushVertex(center + rotation * pos, vec2(x / (float)(slices - 1), 0.5f), rotation * nor, rotation * vec3(1.f, 0.f, 0.f), {}, 0);
	}

	// Top inner row, normal inside.
	for (uint32 x = 0; x < slices; ++x)
	{
		float vertexX = angles[x].cos;
		float vertexZ = angles[x].sin;
		vec3 pos(vertexX * innerRadius, halfHeight, vertexZ * innerRadius);
		vec3 nor(-vertexX, 0.f, -vertexZ);

		pushVertex(center + rotation * pos, vec2(x / (float)(slices - 1), 0.f), rotation * nor, rotation * normalize(cross(vec3(0.f, 1.f, 0.f), nor)), {}, 0);
	}

	// Top inner row, normal up.
	for (uint32 x = 0; x < slices; ++x)
	{
		float vertexX = angles[x].cos;
		float vertexZ = angles[x].sin;
		vec3 pos(vertexX * innerRadius, halfHeight, vertexZ * innerRadius);
		vec3 nor(0.f, 1.f, 0.f);

		pushVertex(center + rotation * pos, remap(vec2(vertexX, vertexZ), -1.f, 1.f, innerUVMin + vec2(0.5f, 0.f), innerUVMax + vec2(0.5f, 0.f)), rotation * nor, rotation * vec3(1.f, 0.f, 0.f), {}, 0);
	}


	// Indices.

	uint32 firstInnerBottomVertex = 4 * slices;

	for (uint32 x = 0; x < slices - 1u; ++x)
	{
		pushTriangle(firstInnerBottomVertex + x, x, x + 1);
		pushTriangle(firstInnerBottomVertex + x, x + 1, firstInnerBottomVertex + x + 1);
	}
	pushTriangle(firstInnerBottomVertex + slices - 1u, slices - 1u, 0);
	pushTriangle(firstInnerBottomVertex + slices - 1u, 0, firstInnerBottomVertex);

	for (uint32 x = 0; x < slices - 1u; ++x)
	{
		pushTriangle(slices + x, 2 * slices + 1 + x, slices + 1 + x);
		pushTriangle(slices + x, 2 * slices + x, 2 * slices + 1 + x);
	}
	pushTriangle(slices + slices - 1, 2 * slices, slices);
	pushTriangle(slices + slices - 1, 2 * slices + slices - 1, 2 * slices);

	uint32 firstInnerTopVertex = 7 * slices;
	uint32 firstOuterTopVertex = 3 * slices;

	for (uint32 x = 0; x < slices - 1u; ++x)
	{
		pushTriangle(firstInnerTopVertex + x, firstOuterTopVertex + x + 1, firstOuterTopVertex + x);
		pushTriangle(firstInnerTopVertex + x, firstInnerTopVertex + x + 1, firstOuterTopVertex + x + 1);
	}
	pushTriangle(firstInnerTopVertex + slices - 1u, firstOuterTopVertex + 0, firstOuterTopVertex + slices - 1u);
	pushTriangle(firstInnerTopVertex + slices - 1u, firstInnerTopVertex, firstOuterTopVertex + 0);

	firstInnerBottomVertex = 5 * slices;
	firstInnerTopVertex = 6 * slices;

	for (uint32 x = 0; x < slices - 1u; ++x)
	{
		pushTriangle(firstInnerBottomVertex + x, firstInnerBottomVertex + 1 + x, firstInnerTopVertex + 1 + x);
		pushTriangle(firstInnerBottomVertex + x, firstInnerTopVertex + 1 + x, firstInnerTopVertex + x);
	}
	pushTriangle(firstInnerBottomVertex + slices - 1, firstInnerBottomVertex, firstInnerTopVertex);
	pushTriangle(firstInnerBottomVertex + slices - 1, firstInnerTopVertex, firstInnerTopVertex + slices - 1);
}

void mesh_builder::pushArrow(const arrow_mesh_desc& desc, bool flipWindingOrder)
{
	float shaftLength = desc.shaftLength;
	float shaftRadius = desc.shaftRadius;
	float headLength = desc.headLength;
	float headRadius = desc.headRadius;
	quat rotation = desc.rotation;
	vec3 base = desc.base;
	uint32 slices = desc.slices;

	ASSERT(slices > 2);

	float horzDeltaAngle = 2.f * M_PI / slices;

	auto [positionPtr, othersPtr, indexPtr, indexOffset] = beginPrimitive(7 * slices + 1, 7 * slices);

	vec2 uv(0.f, 0.f);
	pushVertex(base, uv, rotation * vec3(0.f, -1.f, 0.f), rotation * vec3(1.f, 0.f, 0.f), {}, 0);

	// Bottom row, normal down.
	for (uint32 x = 0; x < slices; ++x)
	{
		float horzAngle = x * horzDeltaAngle;
		float vertexX = cosf(horzAngle);
		float vertexZ = sinf(horzAngle);
		vec3 pos(vertexX * shaftRadius, 0.f, vertexZ * shaftRadius);
		vec3 nor(0.f, -1.f, 0.f);

		pushVertex(base + rotation * pos, uv, rotation * nor, rotation * vec3(1.f, 0.f, 0.f), {}, 0);
	}

	// Bottom row, normal around.
	for (uint32 x = 0; x < slices; ++x)
	{
		float horzAngle = x * horzDeltaAngle;
		float vertexX = cosf(horzAngle);
		float vertexZ = sinf(horzAngle);
		vec3 pos(vertexX * shaftRadius, 0.f, vertexZ * shaftRadius);
		vec3 nor(vertexX, 0.f, vertexZ);

		pushVertex(base + rotation * pos, uv, rotation * nor, rotation * normalize(cross(vec3(0.f, 1.f, 0.f), nor)), {}, 0);
	}

	// Top row, normal around.
	for (uint32 x = 0; x < slices; ++x)
	{
		float horzAngle = x * horzDeltaAngle;
		float vertexX = cosf(horzAngle);
		float vertexZ = sinf(horzAngle);
		vec3 pos(vertexX * shaftRadius, shaftLength, vertexZ * shaftRadius);
		vec3 nor(vertexX, 0.f, vertexZ);

		pushVertex(base + rotation * pos, uv, rotation * nor, rotation * normalize(cross(vec3(0.f, 1.f, 0.f), nor)), {}, 0);
	}

	// Top row, normal down.
	for (uint32 x = 0; x < slices; ++x)
	{
		float horzAngle = x * horzDeltaAngle;
		float vertexX = cosf(horzAngle);
		float vertexZ = sinf(horzAngle);
		vec3 pos(vertexX * shaftRadius, shaftLength, vertexZ * shaftRadius);
		vec3 nor(0.f, -1.f, 0.f);

		pushVertex(base + rotation * pos, uv, rotation * nor, rotation * vec3(1.f, 0.f, 0.f), {}, 0);
	}

	// Top outer row, normal down.
	for (uint32 x = 0; x < slices; ++x)
	{
		float horzAngle = x * horzDeltaAngle;
		float vertexX = cosf(horzAngle);
		float vertexZ = sinf(horzAngle);
		vec3 pos(vertexX * headRadius, shaftLength, vertexZ * headRadius);
		vec3 nor(0.f, -1.f, 0.f);

		pushVertex(base + rotation * pos, uv, rotation * nor, rotation * vec3(1.f, 0.f, 0.f), {}, 0);
	}

	vec2 normal2D = normalize(vec2(headLength, headRadius));

	// Top outer row, normal around.
	for (uint32 x = 0; x < slices; ++x)
	{
		float horzAngle = x * horzDeltaAngle;
		float vertexX = cosf(horzAngle);
		float vertexZ = sinf(horzAngle);
		vec3 pos(vertexX * headRadius, shaftLength, vertexZ * headRadius);
		vec3 nor(vertexX * normal2D.x, normal2D.y, vertexZ * normal2D.x);

		pushVertex(base + rotation * pos, uv, rotation * nor, rotation * vec3(1.f, 0.f, 0.f), {}, 0);
	}

	// Top vertex.
	for (uint32 x = 0; x < slices; ++x)
	{
		float horzAngle = x * horzDeltaAngle;
		float vertexX = cosf(horzAngle);
		float vertexZ = sinf(horzAngle);
		vec3 pos(0.f, shaftLength + headLength, 0.f);
		vec3 nor(vertexX * normal2D.x, normal2D.y, vertexZ * normal2D.x);

		pushVertex(base + rotation * pos, uv, rotation * nor, rotation * vec3(1.f, 0.f, 0.f), {}, 0);
	}

	// Indices.
	for (uint32 x = 0; x < slices - 1; ++x)
	{
		pushTriangle(0, x + 1, x + 2);
	}
	pushTriangle(0, slices, 1);

	for (uint32 y = 1; y < 7; y += 2)
	{
		for (uint32 x = 0; x < slices - 1; ++x)
		{
			pushTriangle(y * slices + 1 + x, (y + 1) * slices + 2 + x, y * slices + 2 + x);
			pushTriangle(y * slices + 1 + x, (y + 1) * slices + 1 + x, (y + 1) * slices + 2 + x);
		}
		pushTriangle(y * slices + slices, (y + 1) * slices + 1, y * slices + 1);
		pushTriangle(y * slices + slices, (y + 1) * slices + slices, (y + 1) * slices + 1);
	}
}

void mesh_builder::pushTorus(const torus_mesh_desc& desc, bool flipWindingOrder)
{
	float torusRadius = desc.torusRadius;
	float tubeRadius = desc.tubeRadius;
	uint32 slices = desc.slices;
	uint32 segments = desc.segments;
	vec3 center = desc.center;
	quat rotation = desc.rotation * quat(vec3(1.f, 0.f, 0.f), deg2rad(90.f));

	ASSERT(slices > 2);
	ASSERT(segments > 2);

	float tubeDeltaAngle = 2.f * M_PI / slices;
	float torusDeltaAngle = 2.f * M_PI / segments;

	auto [positionPtr, othersPtr, indexPtr, indexOffset] = beginPrimitive(segments * slices, segments * slices * 2);
	
	vec2 uv(0.f, 0.f);

	for (uint32 s = 0; s < segments; ++s)
	{
		float segmentAngle = s * torusDeltaAngle;
		quat segmentRotation(vec3(0.f, 0.f, 1.f), segmentAngle);

		vec3 segmentOffset = segmentRotation * vec3(torusRadius, 0.f, 0.f);

		for (uint32 x = 0; x < slices; ++x)
		{
			float horzAngle = x * tubeDeltaAngle;
			float vertexX = cosf(horzAngle);
			float vertexZ = sinf(horzAngle);
			vec3 pos = segmentRotation * vec3(vertexX * tubeRadius, 0.f, vertexZ * tubeRadius) + segmentOffset;
			vec3 nor = segmentRotation * vec3(vertexX, 0.f, vertexZ);

			pushVertex(center + rotation * pos, uv, rotation * nor, rotation * vec3(1.f, 0.f, 0.f), {}, 0);
		}
	}

	for (uint32 y = 0; y < segments - 1u; ++y)
	{
		for (uint32 x = 0; x < slices - 1u; ++x)
		{
			pushTriangle(y * slices + x, (y + 1) * slices + 1 + x, y * slices + 1 + x);
			pushTriangle(y * slices + x, (y + 1) * slices + x, (y + 1) * slices + 1 + x);
		}
		pushTriangle(y * slices + slices - 1, (y + 1) * slices, y * slices);
		pushTriangle(y * slices + slices - 1, (y + 1) * slices + slices - 1, (y + 1) * slices);
	}

	uint32 y = segments - 1u;
	for (uint32 x = 0; x < slices - 1u; ++x)
	{
		pushTriangle(y * slices + x, 1 + x, y * slices + 1 + x);
		pushTriangle(y * slices + x, x, 1 + x);
	}
	pushTriangle(y * slices + slices - 1, 0, y * slices);
	pushTriangle(y * slices + slices - 1, slices - 1, 0);
}

void mesh_builder::pushMace(const mace_mesh_desc& desc, bool flipWindingOrder)
{
	float shaftLength = desc.shaftLength;
	float shaftRadius = desc.shaftRadius;
	float headLength = desc.headLength;
	float headRadius = desc.headRadius;
	quat rotation = desc.rotation;
	vec3 base = desc.base;
	uint32 slices = desc.slices;

	ASSERT(slices > 2);

	float horzDeltaAngle = 2.f * M_PI / slices;
	
	auto [positionPtr, othersPtr, indexPtr, indexOffset] = beginPrimitive(8 * slices + 2, 8 * slices);

	vec2 uv(0.f, 0.f);
	pushVertex(base, uv, rotation * vec3(0.f, -1.f, 0.f), rotation * vec3(1.f, 0.f, 0.f), {}, 0);

	// Bottom row, normal down.
	for (uint32 x = 0; x < slices; ++x)
	{
		float horzAngle = x * horzDeltaAngle;
		float vertexX = cosf(horzAngle);
		float vertexZ = sinf(horzAngle);
		vec3 pos(vertexX * shaftRadius, 0.f, vertexZ * shaftRadius);
		vec3 nor(0.f, -1.f, 0.f);

		pushVertex(base + rotation * pos, uv, rotation * nor, rotation * vec3(1.f, 0.f, 0.f), {}, 0);
	}

	// Bottom row, normal around.
	for (uint32 x = 0; x < slices; ++x)
	{
		float horzAngle = x * horzDeltaAngle;
		float vertexX = cosf(horzAngle);
		float vertexZ = sinf(horzAngle);
		vec3 pos(vertexX * shaftRadius, 0.f, vertexZ * shaftRadius);
		vec3 nor(vertexX, 0.f, vertexZ);

		pushVertex(base + rotation * pos, uv, rotation * nor, rotation * normalize(cross(vec3(0.f, 1.f, 0.f), nor)), {}, 0);
	}

	// Top row, normal around.
	for (uint32 x = 0; x < slices; ++x)
	{
		float horzAngle = x * horzDeltaAngle;
		float vertexX = cosf(horzAngle);
		float vertexZ = sinf(horzAngle);
		vec3 pos(vertexX * shaftRadius, shaftLength, vertexZ * shaftRadius);
		vec3 nor(vertexX, 0.f, vertexZ);

		pushVertex(base + rotation * pos, uv, rotation * nor, rotation * normalize(cross(vec3(0.f, 1.f, 0.f), nor)), {}, 0);
	}

	// Top row, normal down.
	for (uint32 x = 0; x < slices; ++x)
	{
		float horzAngle = x * horzDeltaAngle;
		float vertexX = cosf(horzAngle);
		float vertexZ = sinf(horzAngle);
		vec3 pos(vertexX * shaftRadius, shaftLength, vertexZ * shaftRadius);
		vec3 nor(0.f, -1.f, 0.f);

		pushVertex(base + rotation * pos, uv, rotation * nor, rotation * vec3(1.f, 0.f, 0.f), {}, 0);
	}

	// Top outer row, normal down.
	for (uint32 x = 0; x < slices; ++x)
	{
		float horzAngle = x * horzDeltaAngle;
		float vertexX = cosf(horzAngle);
		float vertexZ = sinf(horzAngle);
		vec3 pos(vertexX * headRadius, shaftLength, vertexZ * headRadius);
		vec3 nor(0.f, -1.f, 0.f);

		pushVertex(base + rotation * pos, uv, rotation * nor, rotation * normalize(cross(vec3(0.f, 1.f, 0.f), nor)), {}, 0);
	}

	// Top outer row, normal around.
	for (uint32 x = 0; x < slices; ++x)
	{
		float horzAngle = x * horzDeltaAngle;
		float vertexX = cosf(horzAngle);
		float vertexZ = sinf(horzAngle);
		vec3 pos(vertexX * headRadius, shaftLength, vertexZ * headRadius);
		vec3 nor(vertexX, 0.f, vertexZ);

		pushVertex(base + rotation * pos, uv, rotation * nor, rotation * normalize(cross(vec3(0.f, 1.f, 0.f), nor)), {}, 0);
	}

	// Top top outer row, normal around.
	for (uint32 x = 0; x < slices; ++x)
	{
		float horzAngle = x * horzDeltaAngle;
		float vertexX = cosf(horzAngle);
		float vertexZ = sinf(horzAngle);
		vec3 pos(vertexX * headRadius, shaftLength + headLength, vertexZ * headRadius);
		vec3 nor(vertexX, 0.f, vertexZ);

		pushVertex(base + rotation * pos, uv, rotation * nor, rotation * normalize(cross(vec3(0.f, 1.f, 0.f), nor)), {}, 0);
	}

	// Top top outer row, normal up.
	for (uint32 x = 0; x < slices; ++x)
	{
		float horzAngle = x * horzDeltaAngle;
		float vertexX = cosf(horzAngle);
		float vertexZ = sinf(horzAngle);
		vec3 pos(vertexX * headRadius, shaftLength + headLength, vertexZ * headRadius);
		vec3 nor(0.f, 1.f, 0.f);

		pushVertex(base + rotation * pos, uv, rotation * nor, rotation * vec3(1.f, 0.f, 0.f), {}, 0);
	}

	pushVertex(base + rotation * vec3(0.f, shaftLength + headLength, 0.f), uv, rotation * vec3(0.f, 1.f, 0.f), rotation * vec3(1.f, 0.f, 0.f), {}, 0);

	uint32 lastVertex = 8 * slices + 2;

	// Indices.
	for (uint32 x = 0; x < slices - 1u; ++x)
	{
		pushTriangle(0, x + 1, x + 2);
	}
	pushTriangle(0, slices, 1);

	for (uint32 y = 1; y < 7; y += 2)
	{
		for (uint32 x = 0; x < slices - 1u; ++x)
		{
			pushTriangle(y * slices + 1 + x, (y + 1) * slices + 2 + x, y * slices + 2 + x);
			pushTriangle(y * slices + 1 + x, (y + 1) * slices + 1 + x, (y + 1) * slices + 2 + x);
		}
		pushTriangle(y * slices + slices, (y + 1) * slices + 1, y * slices + 1);
		pushTriangle(y * slices + slices, (y + 1) * slices + slices, (y + 1) * slices + 1);
	}

	for (uint32 x = 0; x < slices - 1u; ++x)
	{
		pushTriangle(lastVertex - 2 - x, lastVertex - 3 - x, lastVertex - 1);
	}
	pushTriangle(lastVertex - 1 - slices, lastVertex - 2, lastVertex - 1);
}

void mesh_builder::pushMesh(const submesh_asset& mesh, float scale, bounding_box* aabb)
{
	uint32 numVertices = (uint32)mesh.positions.size();
	uint32 numFaces = (uint32)mesh.triangles.size();

	if (indexType == mesh_index_uint16)
	{
		ASSERT(numVertices <= UINT16_MAX);
	}

	auto [positionPtr, othersPtr, indexPtr, indexOffset] = beginPrimitive(numVertices, numFaces);
	auto vertexOthers = othersPtr;

	vec3 position(0.f, 0.f, 0.f);
	vec3 normal(0.f, 0.f, 0.f);
	vec3 tangent(0.f, 0.f, 0.f);
	vec2 uv(0.f, 0.f);
	uint32 vertexColor = 0;
	skinning_weights skin = {};

	bool hasPositions = true;
	bool hasUVs = !mesh.uvs.empty();
	bool hasNormals = !mesh.normals.empty();
	bool hasTangents = !mesh.tangents.empty();
	bool hasVertexColors = !mesh.colors.empty();;
	bool hasSkin = !mesh.skin.empty();

	if (aabb)
	{
		*aabb = bounding_box::negativeInfinity();
	}

	for (uint32 i = 0; i < numVertices; ++i)
	{
		position = mesh.positions[i] * scale;
		if (aabb)
		{
			aabb->grow(position);
		}

		if (hasUVs)
		{
			uv = mesh.uvs[i];
		}
		if (hasNormals)
		{
			normal = mesh.normals[i];
		}
		if (hasTangents)
		{
			tangent = mesh.tangents[i];
		}
		if (hasVertexColors)
		{
			vertexColor = mesh.colors[i];
		}
		if (hasSkin)
		{
			skin = mesh.skin[i];
		}

		pushVertex(position, uv, normal, tangent, skin, vertexColor);
	}

	const bool flipWindingOrder = false;
	for (uint32 i = 0; i < numFaces; ++i)
	{
		const indexed_triangle16& tri = mesh.triangles[i];
		pushTriangle(tri.a, tri.b, tri.c);
	}
}

submesh_info mesh_builder::endSubmesh()
{
	uint32 firstVertex = totalNumVertices;
	uint32 firstTriangle = totalNumTriangles;

	submesh_info result;
	result.firstIndex = firstTriangle * 3;
	result.numIndices = numTrianglesInCurrentSubmesh * 3;
	result.baseVertex = firstVertex;
	result.numVertices = numVerticesInCurrentSubmesh;


	totalNumVertices += numVerticesInCurrentSubmesh;
	totalNumTriangles += numTrianglesInCurrentSubmesh;

	// Align the next index to a 16-byte boundary.
	uint32 alignedNumTriangles = alignTo(totalNumTriangles, 8); // 8 triangles are 48 bytes, which is divisible by 16.
	uint32 missing = alignedNumTriangles - totalNumTriangles;
	if (missing > 0)
	{
		indexArena.allocate(indexSize * 3 * missing); // Push arena forward.
	}
	totalNumTriangles = alignedNumTriangles;

	// Reset next submesh.
	numVerticesInCurrentSubmesh = 0;
	numTrianglesInCurrentSubmesh = 0;

	++numSubmeshes;

	return result;
}

dx_mesh mesh_builder::createDXMesh()
{
	if (numVerticesInCurrentSubmesh > 0)
	{
		endSubmesh();
	}

	dx_mesh result;
	result.vertexBuffer.positions = createVertexBuffer(sizeof(vec3), totalNumVertices, positionArena.base());
	if (vertexFlags != mesh_creation_flags_with_positions)
	{
		result.vertexBuffer.others = createVertexBuffer(othersSize, totalNumVertices, othersArena.base());
	}
	result.indexBuffer = createIndexBuffer(indexSize, totalNumTriangles * 3, indexArena.base());
	return result;
}

std::tuple<vec3*, uint8*, uint8*, uint32> mesh_builder::beginPrimitive(uint32 numVertices, uint32 numTriangles)
{
	vec3* positionPtr = (vec3*)positionArena.allocate(sizeof(vec3) * numVertices);
	uint8* othersPtr = (uint8*)othersArena.allocate(othersSize * numVertices);
	uint8* indexPtr = (uint8*)indexArena.allocate(indexSize * 3 * numTriangles);

	uint32 indexOffset = numVerticesInCurrentSubmesh;

	numVerticesInCurrentSubmesh += numVertices;
	numTrianglesInCurrentSubmesh += numTriangles;

	uint32 maxNumVertices = (indexType == mesh_index_uint16) ? UINT16_MAX : UINT32_MAX;
	ASSERT(numVerticesInCurrentSubmesh <= maxNumVertices);

	return { positionPtr, othersPtr, indexPtr, indexOffset };
}


```

`src/geometry/mesh_builder.h`:

```h
#pragma once

#include "core/memory.h"
#include "physics/bounding_volumes.h"
#include "animation/animation.h"
#include "dx/dx_buffer.h"



struct submesh_info
{
	uint32 numIndices;
	uint32 firstIndex;
	uint32 baseVertex;
	uint32 numVertices;
};


// Members are always pushed in this order!
enum mesh_creation_flags
{
	mesh_creation_flags_none = 0,
	mesh_creation_flags_with_positions = (1 << 0),
	mesh_creation_flags_with_uvs = (1 << 1),
	mesh_creation_flags_with_normals = (1 << 2),
	mesh_creation_flags_with_tangents = (1 << 3),
	mesh_creation_flags_with_skin = (1 << 4),
	mesh_creation_flags_with_colors = (1 << 5),

	mesh_creation_flags_default = mesh_creation_flags_with_positions | mesh_creation_flags_with_uvs | mesh_creation_flags_with_normals | mesh_creation_flags_with_tangents,
	mesh_creation_flags_animated = mesh_creation_flags_default | mesh_creation_flags_with_skin,
};


enum mesh_index_type
{
	mesh_index_uint16,
	mesh_index_uint32,
};

struct quad_mesh_desc
{
	vec3 center = 0.f;
	vec2 radius = 1.f;
	quat rotation = quat::identity;
};

struct box_mesh_desc
{
	vec3 center = 0.f;
	vec3 radius = 1.f;
	quat rotation = quat::identity;
};

struct tesselated_box_mesh_desc
{
	vec3 center = 0.f;
	vec3 radius = 1.f;
	uint32 numIntervals = 1;
	quat rotation = quat::identity;
};

struct sphere_mesh_desc
{
	vec3 center = 0.f;
	float radius = 1.f;
	uint32 slices = 15;
	uint32 rows = 15;
};

struct icosphere_mesh_desc
{
	vec3 center = 0.f;
	float radius = 1.f;
	uint32 refinement = 0;
};

// All meshes are standing upright by default.
struct capsule_mesh_desc
{
	vec3 center = 0.f;
	float height = 1.f;
	float radius = 0.4f;
	quat rotation = quat::identity;
	uint32 slices = 15;
	uint32 rows = 15;

	capsule_mesh_desc() {}
	capsule_mesh_desc(vec3 posA, vec3 posB, float radius)
	{
		center = (posA + posB) * 0.5f;
		height = length(posA - posB);
		this->radius = radius;
		rotation = rotateFromTo(vec3(0.f, 1.f, 0.f), posB - posA);
	}
};

struct cylinder_mesh_desc
{
	vec3 center = 0.f;
	float height = 1.f;
	float radius = 0.4f;
	quat rotation = quat::identity;
	uint32 slices = 15;
};

struct hollow_cylinder_mesh_desc
{
	vec3 center = 0.f;
	float height = 1.f;
	float radius = 0.4f;
	float innerRadius = 0.3f;
	quat rotation = quat::identity;
	uint32 slices = 15;
};

struct arrow_mesh_desc
{
	vec3 base = 0.f;
	float shaftLength = 1.f;
	float shaftRadius = 0.1f;
	float headLength = 0.3f;
	float headRadius = 0.2f;
	quat rotation = quat::identity;
	uint32 slices = 15;
};

struct torus_mesh_desc
{
	vec3 center = 0.f;
	float torusRadius = 1.f;
	float tubeRadius = 0.1f;
	quat rotation = quat::identity;
	uint32 slices = 15;
	uint32 segments = 15;
};

struct mace_mesh_desc
{
	vec3 base = 0.f;
	float shaftLength = 1.f;
	float shaftRadius = 0.1f;
	float headLength = 0.3f;
	float headRadius = 0.2f;
	quat rotation = quat::identity;
	uint32 slices = 15;
};


static uint32 getVertexOthersSize(uint32 meshFlags)
{
	uint32 size = 0;
	if (meshFlags & mesh_creation_flags_with_uvs) { size += sizeof(vec2); }
	if (meshFlags & mesh_creation_flags_with_normals) { size += sizeof(vec3); }
	if (meshFlags & mesh_creation_flags_with_tangents) { size += sizeof(vec3); }
	if (meshFlags & mesh_creation_flags_with_skin) { size += sizeof(skinning_weights); }
	if (meshFlags & mesh_creation_flags_with_colors) { size += sizeof(uint32); }
	return size;
}

struct mesh_builder
{
	mesh_builder(uint32 vertexFlags = mesh_creation_flags_default, mesh_index_type indexType = mesh_index_uint16);
	mesh_builder(const mesh_builder& mesh) = delete;
	mesh_builder(mesh_builder&& mesh) = default;
	~mesh_builder();


	void pushQuad(const quad_mesh_desc& desc, bool flipWindingOrder = false);
	void pushBox(const box_mesh_desc& desc, bool flipWindingOrder = false);
	void pushTesselatedBox(const tesselated_box_mesh_desc& desc, bool flipWindingOrder = false);
	void pushSphere(const sphere_mesh_desc& desc, bool flipWindingOrder = false);
	void pushIcoSphere(const icosphere_mesh_desc& desc, bool flipWindingOrder = false);
	void pushCapsule(const capsule_mesh_desc& desc, bool flipWindingOrder = false);
	void pushCylinder(const cylinder_mesh_desc& desc, bool flipWindingOrder = false);
	void pushHollowCylinder(const hollow_cylinder_mesh_desc& desc, bool flipWindingOrder = false);
	void pushArrow(const arrow_mesh_desc& desc, bool flipWindingOrder = false);
	void pushTorus(const torus_mesh_desc& desc, bool flipWindingOrder = false);
	void pushMace(const mace_mesh_desc& desc, bool flipWindingOrder = false);

	void pushMesh(const struct submesh_asset& mesh, float scale, bounding_box* aabb = 0);

	submesh_info endSubmesh();

	dx_mesh createDXMesh();

	vec3* getPositions() { return (vec3*)positionArena.base(); }
	void* getOthers() { return othersArena.base(); }
	void* getTriangles() { return indexArena.base(); }

	uint32 getNumVertices() { return totalNumVertices; }
	uint32 getNumTriangles() { return totalNumTriangles; }
	uint32 getSkinOffset() { return skinOffset; }
	uint32 getOthersSize() { return othersSize; }

private:

	std::tuple<vec3*, uint8*, uint8*, uint32> beginPrimitive(uint32 numVertices, uint32 numTriangles);

	memory_arena positionArena;
	memory_arena othersArena;
	memory_arena indexArena;

	uint32 vertexFlags;
	mesh_index_type indexType;
	uint32 othersSize;
	uint32 indexSize;
	uint32 skinOffset;

	uint32 totalNumVertices = 0;
	uint32 totalNumTriangles = 0;

	uint32 numVerticesInCurrentSubmesh = 0;
	uint32 numTrianglesInCurrentSubmesh = 0;

	uint32 numSubmeshes = 0;
};


struct vertex_uv_normal_tangent
{
	vec2 uv;
	vec3 normal;
	vec3 tangent;
};

static D3D12_INPUT_ELEMENT_DESC inputLayout_position[] = {
	{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D12_APPEND_ALIGNED_ELEMENT, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
};

static D3D12_INPUT_ELEMENT_DESC inputLayout_position_uv[] = {
	{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D12_APPEND_ALIGNED_ELEMENT, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
	{ "TEXCOORDS", 0, DXGI_FORMAT_R32G32_FLOAT, 1, D3D12_APPEND_ALIGNED_ELEMENT, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
};

static D3D12_INPUT_ELEMENT_DESC inputLayout_position_normal[] = {
	{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D12_APPEND_ALIGNED_ELEMENT, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
	{ "NORMAL", 0, DXGI_FORMAT_R32G32B32_FLOAT, 1, D3D12_APPEND_ALIGNED_ELEMENT, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
};

static D3D12_INPUT_ELEMENT_DESC inputLayout_position_uv_normal[] = {
	{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D12_APPEND_ALIGNED_ELEMENT, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
	{ "TEXCOORDS", 0, DXGI_FORMAT_R32G32_FLOAT, 1, D3D12_APPEND_ALIGNED_ELEMENT, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
	{ "NORMAL", 0, DXGI_FORMAT_R32G32B32_FLOAT, 1, D3D12_APPEND_ALIGNED_ELEMENT, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
};

static D3D12_INPUT_ELEMENT_DESC inputLayout_position_uv_normal_tangent[] = {
	{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D12_APPEND_ALIGNED_ELEMENT, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
	{ "TEXCOORDS", 0, DXGI_FORMAT_R32G32_FLOAT, 1, D3D12_APPEND_ALIGNED_ELEMENT, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
	{ "NORMAL", 0, DXGI_FORMAT_R32G32B32_FLOAT, 1, D3D12_APPEND_ALIGNED_ELEMENT, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
	{ "TANGENT", 0, DXGI_FORMAT_R32G32B32_FLOAT, 1, D3D12_APPEND_ALIGNED_ELEMENT, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
};

static D3D12_INPUT_ELEMENT_DESC inputLayout_position_uv_normal_tangent_colors[] = {
	{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D12_APPEND_ALIGNED_ELEMENT, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
	{ "TEXCOORDS", 0, DXGI_FORMAT_R32G32_FLOAT, 1, D3D12_APPEND_ALIGNED_ELEMENT, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
	{ "NORMAL", 0, DXGI_FORMAT_R32G32B32_FLOAT, 1, D3D12_APPEND_ALIGNED_ELEMENT, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
	{ "TANGENT", 0, DXGI_FORMAT_R32G32B32_FLOAT, 1, D3D12_APPEND_ALIGNED_ELEMENT, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
	{ "COLOR", 0, DXGI_FORMAT_R8G8B8A8_UNORM, 1, D3D12_APPEND_ALIGNED_ELEMENT, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
};


```

`src/learning/learned_locomotion.cpp`:

```cpp
#include "pch.h"
#include "learned_locomotion.h"
#include "core/random.h"


#if __has_include("../tmp/network.h")
#define INFERENCE_POSSIBLE
#include "../tmp/network.h"


template <uint32 inputSize, uint32 outputSize>
static void applyLayer(const float(&weights)[outputSize][inputSize], const float(&bias)[outputSize], const float* from, float* to, bool activation)
{
	for (uint32 y = 0; y < outputSize; ++y)
	{
		const float* row = weights[y];

		float sum = 0.f;
		for (uint32 x = 0; x < inputSize; ++x)
		{
			sum += row[x] * from[x];
		}
		sum += bias[y];
		to[y] = activation ? tanh(sum) : sum;
	}
}
#endif

void learned_locomotion::initialize(game_scene& scene, const humanoid_ragdoll& ragdoll)
{
	this->ragdoll = ragdoll;
	reset(scene);
}

void learned_locomotion::reset(game_scene& scene)
{
	lastSmoothedAction = {};
	applyAction(scene, {});

	headTargetHeight = ragdoll.head.getComponent<transform_component>().position.y;
	torsoVelocityTarget = vec3(0.f);
}

void learned_locomotion::update(game_scene& scene)
{
#ifdef INFERENCE_POSSIBLE
	learning_state state;
	getState(state);

	learning_action action;

	float* buffers = (float*)alloca(sizeof(float) * HIDDEN_LAYER_SIZE * 2);

	float* a = buffers;
	float* b = buffers + HIDDEN_LAYER_SIZE;

	// State to a.
	applyLayer(policyWeights1, policyBias1, (const float*)&state, a, true);

	// a to b.
	applyLayer(policyWeights2, policyBias2, a, b, true);

	// b to action.
	applyLayer(actionWeights, actionBias, b, (float*)&action, false);

	applyAction(scene, action);
#endif
}




void learned_locomotion::updateConstraint(game_scene& scene, hinge_constraint_handle handle, hinge_action action) const
{
	hinge_constraint& c = getConstraint(scene, handle);
	c.maxMotorTorque = 200.f;
	c.motorType = constraint_position_motor;
	c.motorTargetAngle = action.targetAngle;
}

void learned_locomotion::updateConstraint(game_scene& scene, cone_twist_constraint_handle handle, cone_twist_action action) const
{
	cone_twist_constraint& c = getConstraint(scene, handle);
	c.maxSwingMotorTorque = 200.f;
	c.maxTwistMotorTorque = 200.f;
	c.swingMotorType = constraint_position_motor;
	c.twistMotorType = constraint_position_motor;
	c.swingMotorTargetAngle = action.swingTargetAngle;
	c.twistMotorTargetAngle = action.twistTargetAngle;
	c.swingMotorAxis = action.swingAxisAngle;
}

void learned_locomotion::applyAction(game_scene& scene, const learning_action& action)
{
	const float beta = 0.1f;

	const float* in = (float*)&action;
	float* out = (float*)&lastSmoothedAction;
	for (uint32 i = 0; i < (uint32)sizeof(learning_action) / 4; ++i)
	{
		out[i] = lerp(out[i], in[i], beta);
	}

	for (uint32 i = 0; i < NUM_CONE_TWIST_CONSTRAINTS; ++i)
	{
		updateConstraint(scene, ragdoll.coneTwistConstraints[i], lastSmoothedAction.coneTwistActions[i]);
	}
	for (uint32 i = 0; i < NUM_HINGE_CONSTRAINTS; ++i)
	{
		updateConstraint(scene, ragdoll.hingeConstraints[i], lastSmoothedAction.hingeActions[i]);
	}
}

trs learned_locomotion::getCoordinateSystem() const
{
	const transform_component& torsoTransform = ragdoll.torso.getComponent<transform_component>();
	vec3 cog = ragdoll.torso.getComponent<rigid_body_component>().getGlobalCOGPosition(torsoTransform);
	cog.y = 0;

	trs transform(cog, quat::identity);
	return transform;
}

void learned_locomotion::readBodyPartState(const trs& transform, scene_entity entity, vec3& position, vec3& velocity) const
{
	transform_component& bodyPartTransform = entity.getComponent<transform_component>();
	rigid_body_component& rb = entity.getComponent<rigid_body_component>();

	position = inverseTransformPosition(transform, rb.getGlobalCOGPosition(bodyPartTransform));
	velocity = inverseTransformDirection(transform, rb.linearVelocity);
}

void learned_locomotion::getState(learning_state& outState) const
{
	trs transform = getCoordinateSystem();

	readBodyPartState(transform, ragdoll.head, outState.headPosition, outState.headVelocity);

	outState.cogVelocity = inverseTransformDirection(transform, ragdoll.torso.getComponent<rigid_body_component>().linearVelocity);

	readBodyPartState(transform, ragdoll.leftToes, outState.leftToesPosition, outState.leftToesVelocity);
	readBodyPartState(transform, ragdoll.rightToes, outState.rightToesPosition, outState.rightToesVelocity);
	readBodyPartState(transform, ragdoll.torso, outState.torsoPosition, outState.torsoVelocity);
	readBodyPartState(transform, ragdoll.leftLowerArm, outState.leftLowerArmPosition, outState.leftLowerArmVelocity);
	readBodyPartState(transform, ragdoll.rightLowerArm, outState.rightLowerArmPosition, outState.rightLowerArmVelocity);

	outState.lastSmoothedAction = lastSmoothedAction;
}

bool learned_locomotion::hasFallen(const learning_state& state) const
{
	return (state.headPosition.y < 1.f);
}





// --------------------------------
// TRAINING
// --------------------------------


struct training_locomotion : learned_locomotion
{
	void reset(game_scene& scene);

	void applyAction(game_scene& scene, const learning_action& action);
	bool getState(learning_state& outState) const;
	float getReward() const;

private:

	struct learning_positions
	{
		vec3 p[6];
	};

	struct body_part_error
	{
		float positionError;
		float velocityError;
		float rotationError;
	};

	void getLocalPositions(scene_entity entity, learning_positions& outPositions) const;
	void getBodyPartTarget(scene_entity entity, scene_entity parent, learning_target& outTarget, const learning_positions& localPositions, const transform_component& torsoTransform) const;
	body_part_error readPartDifference(scene_entity entity, scene_entity parent, const learning_target& target, const learning_positions& localPositions, const transform_component& torsoTransform) const;


	learning_positions localPositions[NUM_BODY_PARTS];
	learning_target targets[NUM_BODY_PARTS];
};

void training_locomotion::getLocalPositions(scene_entity entity, learning_positions& outPositions) const
{
	physics_reference_component& reference = entity.getComponent<physics_reference_component>();

	scene_entity colliderEntity = { reference.firstColliderEntity, entity.registry };

	bounding_box aabb = bounding_box::negativeInfinity();

	while (colliderEntity)
	{
		collider_component& collider = colliderEntity.getComponent<collider_component>();

		bounding_box bb;
		switch (collider.type)
		{
		case collider_type_sphere:
		{
			bb = bounding_box::fromCenterRadius(collider.sphere.center, collider.sphere.radius);
		} break;
		case collider_type_capsule:
		{
			float radius = collider.capsule.radius;
			vec3 radius3(radius);

			bb = bounding_box::negativeInfinity();
			bb.grow(collider.capsule.positionA + radius3);
			bb.grow(collider.capsule.positionA - radius3);
			bb.grow(collider.capsule.positionB + radius3);
			bb.grow(collider.capsule.positionB - radius3);
		} break;
		case collider_type_aabb:
		{
			bb = collider.aabb;
		} break;
		case collider_type_obb:
		{
			bb = collider.obb.transformToAABB(quat::identity, vec3(0.f));
		} break;
		case collider_type_hull:
		{
			ASSERT(false);
			bb = bounding_box::negativeInfinity();
		} break;
		}
		aabb.grow(bb.minCorner);
		aabb.grow(bb.maxCorner);

		colliderEntity = { collider.nextEntity, entity.registry };
	}

	vec3 c = aabb.getCenter();
	vec3 r = aabb.getRadius();
	outPositions.p[0] = c - vec3(r.x, 0.f, 0.f);
	outPositions.p[1] = c - vec3(0.f, r.y, 0.f);
	outPositions.p[2] = c - vec3(0.f, 0.f, r.z);
	outPositions.p[3] = c + vec3(r.x, 0.f, 0.f);
	outPositions.p[4] = c + vec3(0.f, r.y, 0.f);
	outPositions.p[5] = c + vec3(0.f, 0.f, r.z);
}

void training_locomotion::getBodyPartTarget(scene_entity entity, scene_entity parent, learning_target& outTarget, const learning_positions& localPositions, const transform_component& torsoTransform) const
{
	transform_component& transform = entity.getComponent<transform_component>();
	rigid_body_component& rb = entity.getComponent<rigid_body_component>();

	for (uint32 i = 0; i < 6; ++i)
	{
		vec3 pos = transformPosition(transform, localPositions.p[i]);
		//pos = inverseTransformPosition(torsoTransform, pos);
		outTarget.targetPositions[i] = pos;

		vec3 vel = rb.getGlobalPointVelocity(transform, localPositions.p[i]);
		//vel = inverseTransformDirection(torsoTransform, vel);
		outTarget.targetVelocities[i] = vel;
	}

	quat parentRotation = parent ? parent.getComponent<transform_component>().rotation : quat::identity;
	quat localRotation = transform.rotation * conjugate(parentRotation);
	outTarget.localTargetRotation = localRotation;
}

training_locomotion::body_part_error training_locomotion::readPartDifference(scene_entity entity, scene_entity parent, const learning_target& target, const learning_positions& localPositions, const transform_component& torsoTransform) const
{
	transform_component& transform = entity.getComponent<transform_component>();
	rigid_body_component& rb = entity.getComponent<rigid_body_component>();

	float positionError = 0.f;
	float velocityError = 0.f;

	for (uint32 i = 0; i < 6; ++i)
	{
		vec3 pos = transformPosition(transform, localPositions.p[i]);
		//pos = inverseTransformPosition(torsoTransform, pos);
		positionError += length(pos - target.targetPositions[i]);

		vec3 vel = rb.getGlobalPointVelocity(transform, localPositions.p[i]);
		//vel = inverseTransformDirection(torsoTransform, vel);
		velocityError += length(vel - target.targetVelocities[i]);
	}

	quat parentRotation = parent ? parent.getComponent<transform_component>().rotation : quat::identity;
	quat localRotation = transform.rotation * conjugate(parentRotation);
	quat rotationDifference = target.localTargetRotation * conjugate(localRotation);

	float rotationError = 2.f * acos(clamp(rotationDifference.cosHalfAngle, -1.f, 1.f));

	return { positionError, velocityError, rotationError };
}

void training_locomotion::reset(game_scene& scene)
{
	transform_component torsoTransform = getCoordinateSystem();

	for (uint32 i = 0; i < NUM_BODY_PARTS; ++i)
	{
		getLocalPositions(ragdoll.bodyParts[i], localPositions[i]);
		getBodyPartTarget(ragdoll.bodyParts[i], ragdoll.bodyPartParents[i], targets[i], localPositions[i], torsoTransform);
	}

	learned_locomotion::reset(scene);
}

void training_locomotion::applyAction(game_scene& scene, const learning_action& action)
{
	learned_locomotion::applyAction(scene, action);
}

bool training_locomotion::getState(learning_state& outState) const
{
	learned_locomotion::getState(outState);
	bool fallen = hasFallen(outState);
	return fallen;
}

float training_locomotion::getReward() const
{
	float positionError = 0.f;
	float velocityError = 0.f;
	float rotationError = 0.f;

	transform_component torsoTransform = getCoordinateSystem();

	for (uint32 i = 0; i < NUM_BODY_PARTS; ++i)
	{
		body_part_error err = readPartDifference(ragdoll.bodyParts[i], ragdoll.bodyPartParents[i], targets[i], localPositions[i], torsoTransform);
		positionError += err.positionError;
		velocityError += err.velocityError;
		rotationError += err.rotationError;
	}

	float vcmError = length(ragdoll.torso.getComponent<rigid_body_component>().linearVelocity - torsoVelocityTarget);

	float rp = exp(-10.f / NUM_BODY_PARTS * positionError);
	float rv = exp(-1.f / NUM_BODY_PARTS * velocityError);
	float rlocal = exp(-10.f / NUM_BODY_PARTS * rotationError);
	float rvcm = exp(-vcmError);

	float headHeight = ragdoll.head.getComponent<transform_component>().position.y;
	float fall = clamp01(1.3f - 1.4f * (headTargetHeight - headHeight));

	float result = fall * (rp + rv + rlocal + rvcm);
	return result;
}







static void getLimits(game_scene& scene, hinge_constraint_handle handle, float* minPtr, uint32& minPushIndex, float* maxPtr, uint32& maxPushIndex)
{
	hinge_constraint& c = getConstraint(scene, handle);
	minPtr[minPushIndex++] = c.minRotationLimit <= 0.f ? c.minRotationLimit : -M_PI;
	maxPtr[maxPushIndex++] = c.maxRotationLimit >= 0.f ? c.maxRotationLimit : M_PI;
}

static void getLimits(game_scene& scene, cone_twist_constraint_handle handle, float* minPtr, uint32& minPushIndex, float* maxPtr, uint32& maxPushIndex)
{
	cone_twist_constraint& c = getConstraint(scene, handle);

	minPtr[minPushIndex++] = c.twistLimit >= 0.f ? -c.twistLimit : -M_PI;
	minPtr[minPushIndex++] = c.swingLimit >= 0.f ? -c.swingLimit : -M_PI;
	minPtr[minPushIndex++] = -M_PI;

	maxPtr[maxPushIndex++] = c.twistLimit >= 0.f ? c.twistLimit : M_PI;
	maxPtr[maxPushIndex++] = c.swingLimit >= 0.f ? c.swingLimit : M_PI;
	maxPtr[maxPushIndex++] = M_PI;
}





static training_locomotion* trainingEnv = 0;
static memory_arena stackArena;
static game_scene trainingScene;
static float totalReward;
static random_number_generator rng = { (uint32)time(0) };

extern "C" __declspec(dllexport) int getPhysicsStateSize() { return sizeof(learned_locomotion::learning_state) / 4; }
extern "C" __declspec(dllexport) int getPhysicsActionSize() { return sizeof(learned_locomotion::learning_action) / 4; }

extern "C" __declspec(dllexport) void getPhysicsRanges(float* stateMin, float* stateMax, float* actionMin, float* actionMax)
{
	game_scene tmpScene;
	humanoid_ragdoll tmpRagdoll;
	tmpRagdoll.initialize(tmpScene, vec3(0.f));

	// No limits for state.
	for (uint32 i = 0; i < (uint32)getPhysicsStateSize(); ++i)
	{
		stateMin[i] = -FLT_MAX;
		stateMax[i] = FLT_MAX;
	}

	uint32 minPushIndex = 0;
	uint32 maxPushIndex = 0;

	for (uint32 i = 0; i < learned_locomotion::NUM_CONE_TWIST_CONSTRAINTS; ++i)
	{
		getLimits(tmpScene, tmpRagdoll.coneTwistConstraints[i], actionMin, minPushIndex, actionMax, maxPushIndex);
	}
	for (uint32 i = 0; i < learned_locomotion::NUM_HINGE_CONSTRAINTS; ++i)
	{
		getLimits(tmpScene, tmpRagdoll.hingeConstraints[i], actionMin, minPushIndex, actionMax, maxPushIndex);
	}

	ASSERT(minPushIndex == getPhysicsActionSize());
	ASSERT(maxPushIndex == getPhysicsActionSize());

	tmpScene.clearAll();
}

extern "C" __declspec(dllexport) void resetPhysics(float* outState)
{
	if (!trainingEnv)
	{
		trainingEnv = new training_locomotion;
		stackArena.initialize();
	}

	totalReward = 0.f;
	trainingScene.clearAll();

	physics_material groundMaterial = { physics_material_type_metal, 0.1f, 1.f, 4.f };

	trainingScene.createEntity("Test ground")
		.addComponent<transform_component>(vec3(0.f, -4.f, 0.f), quat(vec3(1.f, 0.f, 0.f), deg2rad(0.f)))
		.addComponent<collider_component>(collider_component::asAABB(bounding_box::fromCenterRadius(vec3(0.f, 0.f, 0.f), vec3(20.f, 4.f, 20.f)), groundMaterial));

	humanoid_ragdoll ragdoll = humanoid_ragdoll::create(trainingScene, vec3(0.f, 1.25f, 0.f));

	trainingEnv->ragdoll = ragdoll;
	trainingEnv->reset(trainingScene);
}

extern "C" __declspec(dllexport) int updatePhysics(float* action, float* outState, float* outReward)
{
	stackArena.reset();

	trainingEnv->applyAction(trainingScene, *(learned_locomotion::learning_action*)action);

	if (rng.randomFloat01() < 0.02f)
	{
		uint32 bodyPartIndex = rng.randomUint32Between(0, learned_locomotion::NUM_BODY_PARTS - 1);

		vec3 part = trainingEnv->ragdoll.bodyParts[bodyPartIndex].getComponent<transform_component>().position + vec3(0.f, 0.2f, 0.f);
		vec3 direction = normalize(vec3(rng.randomFloatBetween(-1.f, 1.f), 0.f, rng.randomFloatBetween(-1.f, 1.f)));
		vec3 origin = part - direction * 5.f;

		testPhysicsInteraction(trainingScene, ray{ origin, direction });
	}

	physics_settings physicsSettings;
	physicsSettings.frameRate = 60;

	const float physicsFixedTimeStep = 1.f / (float)physicsSettings.frameRate;
	float physicsTimer = 0.f;
	physicsStep(trainingScene, stackArena, physicsTimer, physicsSettings, physicsFixedTimeStep);

	bool failure = trainingEnv->getState(*(learned_locomotion::learning_state*)outState);
	*outReward = 0.f;
	if (!failure)
	{
		*outReward = trainingEnv->getReward();
		totalReward += *outReward;
	}
	else
	{
		//std::string out = "Rew: " + std::to_string(learningEnv->totalReward) + ",  EpLen: " + std::to_string(learningEnv->episodeLength) + '\n';
		//std::cout << out;
	}
	return failure;
}

```

`src/learning/learned_locomotion.h`:

```h
#pragma once

#include "physics/ragdoll.h"

struct learned_locomotion
{
	void initialize(game_scene& scene, const humanoid_ragdoll& ragdoll);
	void reset(game_scene& scene);

	void update(game_scene& scene);


	static const uint32 NUM_CONE_TWIST_CONSTRAINTS =  arraysize(humanoid_ragdoll::coneTwistConstraints);
	static const uint32 NUM_HINGE_CONSTRAINTS = arraysize(humanoid_ragdoll::hingeConstraints);
	static const uint32 NUM_BODY_PARTS = arraysize(humanoid_ragdoll::bodyParts);

	struct hinge_action
	{
		float targetAngle;
	};

	struct cone_twist_action
	{
		float twistTargetAngle;
		float swingTargetAngle;
		float swingAxisAngle;
	};

	struct learning_action
	{
		cone_twist_action coneTwistActions[NUM_CONE_TWIST_CONSTRAINTS];
		hinge_action hingeActions[NUM_HINGE_CONSTRAINTS];
	};

	struct learning_target
	{
		vec3 targetPositions[6];
		vec3 targetVelocities[6];
		quat localTargetRotation;
	};

	struct learning_state
	{
		vec3 cogVelocity;

		vec3 leftToesPosition;
		vec3 leftToesVelocity;

		vec3 rightToesPosition;
		vec3 rightToesVelocity;

		vec3 torsoPosition;
		vec3 torsoVelocity;

		vec3 headPosition;
		vec3 headVelocity;

		vec3 leftLowerArmPosition;
		vec3 leftLowerArmVelocity;

		vec3 rightLowerArmPosition;
		vec3 rightLowerArmVelocity;

		learning_action lastSmoothedAction;
	};

	humanoid_ragdoll ragdoll;

protected:
	void updateConstraint(game_scene& scene, hinge_constraint_handle handle, hinge_action action = {}) const;
	void updateConstraint(game_scene& scene, cone_twist_constraint_handle handle, cone_twist_action action = {}) const;
	void applyAction(game_scene& scene, const learning_action& action);

	trs getCoordinateSystem() const;
	void readBodyPartState(const trs& transform, scene_entity entity, vec3& position, vec3& velocity) const;
	void getState(learning_state& outState) const;
	bool hasFallen(const learning_state& state) const;


	learning_action lastSmoothedAction;
	float headTargetHeight;
	vec3 torsoVelocityTarget;

};


```

`src/main.cpp`:

```cpp
#include "pch.h"
#include "dx/dx_context.h"
#include "window/dx_window.h"
#include "dx/dx_command_list.h"
#include "dx/dx_profiling.h"
#include "core/input.h"
#include "core/imgui.h"
#include "core/log.h"
#include "core/cpu_profiling.h"
#include "core/job_system.h"
#include "asset/file_registry.h"
#include "editor/file_browser.h"
#include "application.h"
#include "editor/editor_icons.h"
#include "rendering/render_utils.h"
#include "rendering/main_renderer.h"
#include "audio/audio.h"
#include "editor/asset_editor_panel.h"

#define IMGUI_DEFINE_MATH_OPERATORS
#include <imgui/imgui_internal.h>


bool handleWindowsMessages();

static uint64 fenceValues[NUM_BUFFERED_FRAMES];
static uint64 frameID;


static bool newFrame(float& dt, dx_window& window)
{
	static bool first = true;
	static float perfFreq;
	static LARGE_INTEGER lastTime;

	if (first)
	{
		LARGE_INTEGER perfFreqResult;
		QueryPerformanceFrequency(&perfFreqResult);
		perfFreq = (float)perfFreqResult.QuadPart;

		QueryPerformanceCounter(&lastTime);

		first = false;
	}

	LARGE_INTEGER currentTime;
	QueryPerformanceCounter(&currentTime);
	dt = ((float)(currentTime.QuadPart - lastTime.QuadPart) / perfFreq);
	lastTime = currentTime;

	bool result = handleWindowsMessages();

	newImGuiFrame(dt);
	ImGui::DockSpaceOverViewport();

	cpuProfilingResolveTimeStamps();

	{
		CPU_PROFILE_BLOCK("Wait for queued frame to finish rendering");
		dxContext.renderQueue.waitForFence(fenceValues[window.currentBackbufferIndex]);
	}

	dxContext.newFrame(frameID);

	return result;
}

static void renderToMainWindow(dx_window& window)
{
	dx_resource backbuffer = window.backBuffers[window.currentBackbufferIndex];
	dx_rtv_descriptor_handle rtv = window.backBufferRTVs[window.currentBackbufferIndex];

	dx_command_list* cl = dxContext.getFreeRenderCommandList();

	{
		DX_PROFILE_BLOCK(cl, "Blit to backbuffer");

		CD3DX12_VIEWPORT viewport = CD3DX12_VIEWPORT(0.f, 0.f, (float)window.clientWidth, (float)window.clientHeight);
		cl->setViewport(viewport);

		cl->transitionBarrier(backbuffer, D3D12_RESOURCE_STATE_COMMON, D3D12_RESOURCE_STATE_RENDER_TARGET);

		cl->clearRTV(rtv, 0.f, 0.f, 0.f);
		cl->setRenderTarget(&rtv, 1, 0);

		renderImGui(cl);

		cl->transitionBarrier(backbuffer, D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT);
	}
	dxContext.endFrame(cl);

	uint64 result = dxContext.executeCommandList(cl);

	window.swapBuffers();

	fenceValues[window.currentBackbufferIndex] = result;
}

int main(int argc, char** argv)
{
	if (!dxContext.initialize())
	{
		return EXIT_FAILURE;
	}

	initializeJobSystem();
	initializeMessageLog();
	initializeFileRegistry();
	initializeAudio();

	{
		sound_settings soundSettings;
		soundSettings.loop = true;

		play2DSound(SOUND_ID("Music"), soundSettings);
	}


	dx_window window;
	window.initialize(TEXT("D3D12 Renderer"), 1920, 1080);
	window.setIcon("resources/icons/project_icon.png");
	window.setCustomWindowStyle();
	window.maximize();

	application app = {};
	app.loadCustomShaders();

	window.setFileDropCallback([&app](const fs::path& s) { app.handleFileDrop(s); });

	initializeTransformationGizmos();
	initializeRenderUtils();

	initializeImGui(window);

	renderer_spec spec;
	spec.allowObjectPicking = true;
	spec.allowAO = true;
	spec.allowSSS = true;
	spec.allowSSR = true;
	spec.allowTAA = true;
	spec.allowBloom = true;

	main_renderer renderer;
	renderer.initialize(window.colorDepth, window.clientWidth, window.clientHeight, spec);

	editor_panels editorPanels;

	app.initialize(&renderer, &editorPanels);

	file_browser fileBrowser;


	// Wait for initialization to finish.
	fenceValues[NUM_BUFFERED_FRAMES - 1] = dxContext.renderQueue.signal();
	dxContext.flushApplication();


	user_input input = {};
	bool appFocusedLastFrame = true;

	float dt;
	while (newFrame(dt, window))
	{
		ImGui::BeginWindowHiddenTabBar("Scene Viewport");
		uint32 renderWidth = (uint32)ImGui::GetContentRegionAvail().x;
		uint32 renderHeight = (uint32)ImGui::GetContentRegionAvail().y;
		ImGui::Image(renderer.frameResult, renderWidth, renderHeight);

		{
			CPU_PROFILE_BLOCK("Collect user input");

			ImGuiIO& io = ImGui::GetIO();
			if (ImGui::IsItemHovered())
			{
				ImVec2 relativeMouse = ImGui::GetMousePos() - ImGui::GetItemRectMin();
				vec2 mousePos = { relativeMouse.x, relativeMouse.y };
				if (appFocusedLastFrame)
				{
					input.mouse.dx = (int32)(mousePos.x - input.mouse.x);
					input.mouse.dy = (int32)(mousePos.y - input.mouse.y);
					input.mouse.reldx = (float)input.mouse.dx / (renderWidth - 1);
					input.mouse.reldy = (float)input.mouse.dy / (renderHeight - 1);
				}
				else
				{
					input.mouse.dx = 0;
					input.mouse.dy = 0;
					input.mouse.reldx = 0.f;
					input.mouse.reldy = 0.f;
				}
				input.mouse.x = (int32)mousePos.x;
				input.mouse.y = (int32)mousePos.y;
				input.mouse.relX = mousePos.x / (renderWidth - 1);
				input.mouse.relY = mousePos.y / (renderHeight - 1);
				input.mouse.left = { ImGui::IsMouseDown(ImGuiMouseButton_Left), ImGui::IsMouseClicked(ImGuiMouseButton_Left), ImGui::IsMouseDoubleClicked(ImGuiMouseButton_Left) };
				input.mouse.right = { ImGui::IsMouseDown(ImGuiMouseButton_Right), ImGui::IsMouseClicked(ImGuiMouseButton_Right), ImGui::IsMouseDoubleClicked(ImGuiMouseButton_Right) };
				input.mouse.middle = { ImGui::IsMouseDown(ImGuiMouseButton_Middle), ImGui::IsMouseClicked(ImGuiMouseButton_Middle), ImGui::IsMouseDoubleClicked(ImGuiMouseButton_Middle) };

				for (uint32 i = 0; i < arraysize(user_input::keyboard); ++i)
				{
					input.keyboard[i] = { ImGui::IsKeyDown(i), ImGui::IsKeyPressed(i, false) };
				}

				input.overWindow = true;
			}
			else
			{
				input.mouse.dx = 0;
				input.mouse.dy = 0;
				input.mouse.reldx = 0.f;
				input.mouse.reldy = 0.f;

				if (input.mouse.left.down && !ImGui::IsMouseDown(ImGuiMouseButton_Left)) { input.mouse.left.down = false; }
				if (input.mouse.right.down && !ImGui::IsMouseDown(ImGuiMouseButton_Right)) { input.mouse.right.down = false; }
				if (input.mouse.middle.down && !ImGui::IsMouseDown(ImGuiMouseButton_Middle)) { input.mouse.middle.down = false; }

				input.mouse.left.clickEvent = input.mouse.left.doubleClickEvent = false;
				input.mouse.right.clickEvent = input.mouse.right.doubleClickEvent = false;
				input.mouse.middle.clickEvent = input.mouse.middle.doubleClickEvent = false;

				for (uint32 i = 0; i < arraysize(user_input::keyboard); ++i)
				{
					if (!ImGui::IsKeyDown(i)) { input.keyboard[i].down = false; }
					input.keyboard[i].pressEvent = false;
				}

				input.overWindow = false;
			}
		}

		// The drag&drop outline is rendered around the drop target. Since the image fills the frame, the outline is outside the window 
		// and thus invisible. So instead this (slightly smaller) Dummy acts as the drop target.
		// Important: This is below the input processing, so that we don't override the current element id.
		ImGui::SetCursorPos(ImVec2(4.5f, 4.5f));
		ImGui::Dummy(ImVec2(renderWidth - 9.f, renderHeight - 9.f));

		if (ImGui::BeginDragDropTarget())
		{
			if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload(EDITOR_ICON_MESH)) { app.handleFileDrop((const char*)payload->Data); }
			if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload(EDITOR_ICON_IMAGE_HDR)) { app.handleFileDrop((const char*)payload->Data); }
			ImGui::EndDragDropTarget();
		}

		appFocusedLastFrame = ImGui::IsMousePosValid();

		if (input.keyboard['V'].pressEvent && !(input.keyboard[key_ctrl].down || input.keyboard[key_shift].down || input.keyboard[key_alt].down)) { window.toggleVSync(); }
		if (ImGui::IsKeyPressed(key_esc)) { break; } // Also allowed if not focused on main window.
		if (ImGui::IsKeyPressed(key_enter) && ImGui::IsKeyDown(key_alt)) { window.toggleFullscreen(); } // Also allowed if not focused on main window.


		if (ImGui::IsKeyPressed(key_enter))
		{
			sound_settings soundSettings;
			play3DSound(SOUND_ID("Explosion"), vec3(0.f), soundSettings);
		}

		// Update and render.

		renderer.beginFrame(renderWidth, renderHeight);

		editorPanels.meshEditor.beginFrame();
		
		app.update(input, dt);

		endFrameCommon();
		renderer.endFrame(&input);

		editorPanels.meshEditor.endFrame();

		if (ImGui::IsKeyPressed(key_print))
		{
			const fs::path dir = "captures";
			fs::create_directories(dir);

			fs::path path = dir / (getTimeString() + ".png");

			if (ImGui::IsKeyDown(key_ctrl))
			{
				saveTextureToFile(window.backBuffers[window.currentBackbufferIndex], window.clientWidth, window.clientHeight, DXGI_FORMAT_R8G8B8A8_UNORM, path);
			}
			else
			{
				//saveTextureToFile(window.backBuffers[window.currentBackbufferIndex], window.clientWidth, window.clientHeight, DXGI_FORMAT_R8G8B8A8_UNORM, path);
				saveTextureToFile(renderer.frameResult, path);
			}

			LOG_MESSAGE("Saved screenshot to '%ws'", path.c_str());
		}

		fileBrowser.draw();

		updateMessageLog(dt);

		updateAudio(dt);

		

		ImGui::End();

		renderToMainWindow(window);

		cpuProfilingFrameEndMarker();

		++frameID;
	}

	dxContext.flushApplication();

	dxContext.quit();

	shutdownAudio();

	return EXIT_SUCCESS;
}

```

`src/particles/boid_particle_system.cpp`:

```cpp
#include "pch.h"
#include "boid_particle_system.h"
#include "dx/dx_pipeline.h"
#include "rendering/render_resources.h"
#include "rendering/render_utils.h"
#include "animation/skinning.h"
#include "core/log.h"


dx_pipeline boid_particle_system::emitPipeline;
dx_pipeline boid_particle_system::simulatePipeline;
dx_pipeline boid_particle_system::renderPipeline;


void boid_particle_system::initializePipeline()
{
#define name "boid_particle_system"

	emitPipeline = createReloadablePipeline(EMIT_PIPELINE_NAME(name));
	simulatePipeline = createReloadablePipeline(SIMULATE_PIPELINE_NAME(name));

	auto desc = CREATE_GRAPHICS_PIPELINE
		.inputLayout(inputLayout_position_uv_normal_tangent)
		.renderTargets(transparentLightPassFormats, arraysize(transparentLightPassFormats), depthStencilFormat)
		.depthSettings(true, true);

	renderPipeline = createReloadablePipeline(desc, { VERTEX_SHADER_NAME(name), PIXEL_SHADER_NAME(name) });

#undef name
}

boid_particle_system::boid_particle_system(uint32 maxNumParticles, float emitRate)
{
	initialize(maxNumParticles, emitRate);
}

void boid_particle_system::initialize(uint32 maxNumParticles, float emitRate)
{
	this->emitRate = emitRate;
	cartoonMesh = loadAnimatedMeshFromFile("assets/cartoon/cartoon.fbx");
	if (cartoonMesh)
	{
		particle_system::initializeAsMesh(sizeof(boid_particle_data), cartoonMesh->mesh, cartoonMesh->submeshes[0].info, maxNumParticles, sort_mode_none);

		settings.radius = 15.f;
	}
	else
	{
		LOG_ERROR("Cannot create particle system, since mesh was not found");
		std::cerr << "Cannot create particle system, since mesh was not found\n";
	}
}

void boid_particle_system::update(struct dx_command_list* cl, const common_particle_simulation_data& common, float dt)
{
	if (cartoonMesh)
	{
		const dx_mesh& mesh = cartoonMesh->mesh;
		animation_skeleton& skeleton = cartoonMesh->skeleton;

		time += dt;
		time = fmod(time, skeleton.clips[0].lengthInSeconds);

		auto [skinnedVertexBuffer, skinningMatrices] = skinObject(mesh.vertexBuffer, cartoonMesh->submeshes[0].info, (uint32)skeleton.joints.size());

		trs localTransforms[128];
		skeleton.sampleAnimation(0, time, localTransforms);
		skeleton.getSkinningMatricesFromLocalTransforms(localTransforms, skinningMatrices);

		this->skinnedVertexBuffer = skinnedVertexBuffer;
		this->submesh.baseVertex = 0;


		struct setter : public particle_parameter_setter
		{
			boid_simulation_cb cb;

			virtual void setRootParameters(dx_command_list* cl) override
			{
				cl->setCompute32BitConstants(BOID_PARTICLE_SYSTEM_COMPUTE_RS_CBV, cb);
			}
		};

		setter s;
		s.cb.emitPosition = vec3(-30.f, 20.f, -10.f); // TEMPORARY.
		s.cb.frameIndex = (uint32)dxContext.frameID;
		s.cb.radius = settings.radius;

		updateInternal(cl, emitRate * dt, dt, emitPipeline, simulatePipeline, &s);
	}
}

void boid_particle_system::render(transparent_render_pass* renderPass)
{
	if (cartoonMesh)
	{
		boid_material material;

		renderPass->renderParticles<boid_pipeline>(skinnedVertexBuffer, cartoonMesh->mesh.indexBuffer,
			getDrawInfo(renderPipeline),
			material);
	}
}

PIPELINE_SETUP_IMPL(boid_particle_system::boid_pipeline)
{
	cl->setPipelineState(*renderPipeline.pipeline);
	cl->setGraphicsRootSignature(*renderPipeline.rootSignature);
	cl->setGraphicsDynamicConstantBuffer(BOID_PARTICLE_SYSTEM_RENDERING_RS_CAMERA, common.cameraCBV);
	cl->setPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

	cl->setDescriptorHeapSRV(BOID_PARTICLE_SYSTEM_RENDERING_RS_PBR, 0, common.irradiance);
	cl->setDescriptorHeapSRV(BOID_PARTICLE_SYSTEM_RENDERING_RS_PBR, 1, common.prefilteredRadiance);
	cl->setDescriptorHeapSRV(BOID_PARTICLE_SYSTEM_RENDERING_RS_PBR, 2, render_resources::brdfTex);
}

PARTICLE_PIPELINE_RENDER_IMPL(boid_particle_system::boid_pipeline, boid_particle_system::boid_material)
{
	particle_render_pipeline::render(cl, viewProj, rc);
}



```

`src/particles/boid_particle_system.h`:

```h
#pragma once

#include "particles.h"
#include "boid_particle_system.hlsli"
#include "dx/dx_texture.h"
#include "rendering/material.h"


struct boid_particle_system : particle_system
{
	static void initializePipeline();

	boid_particle_system() {}
	boid_particle_system(uint32 maxNumParticles, float emitRate);
	void initialize(uint32 maxNumParticles, float emitRate);

	virtual void update(struct dx_command_list* cl, const common_particle_simulation_data& common, float dt) override;
	void render(transparent_render_pass* renderPass);

	float emitRate;
	boid_particle_settings settings;

private:
	static dx_pipeline emitPipeline;
	static dx_pipeline simulatePipeline;
	static dx_pipeline renderPipeline;

	ref<multi_mesh> cartoonMesh;
	dx_vertex_buffer_group_view skinnedVertexBuffer;
	float time = 0.f;

	struct boid_material
	{
		
	};

	struct boid_pipeline : particle_render_pipeline<boid_material>
	{
		PIPELINE_SETUP_DECL;
		PARTICLE_PIPELINE_RENDER_DECL(boid_material);
	};
};


```

`src/particles/debris_particle_system.cpp`:

```cpp
#include "pch.h"
#include "debris_particle_system.h"
#include "dx/dx_pipeline.h"
#include "rendering/render_resources.h"
#include "rendering/render_utils.h"
#include "dx/dx_profiling.h"


dx_pipeline debris_particle_system::emitPipeline;
dx_pipeline debris_particle_system::simulatePipeline;
dx_pipeline debris_particle_system::renderPipeline;


void debris_particle_system::initializePipeline()
{
#define name "debris_particle_system"

	emitPipeline = createReloadablePipeline(EMIT_PIPELINE_NAME(name));
	simulatePipeline = createReloadablePipeline(SIMULATE_PIPELINE_NAME(name));

	auto desc = CREATE_GRAPHICS_PIPELINE
		.inputLayout(inputLayout_position)
		.renderTargets(transparentLightPassFormats, arraysize(transparentLightPassFormats), depthStencilFormat)
		.alphaBlending(0)
		.depthSettings(true, false);

	renderPipeline = createReloadablePipeline(desc, { VERTEX_SHADER_NAME(name), PIXEL_SHADER_NAME(name) });

#undef name
}

debris_particle_system::debris_particle_system(uint32 maxNumParticles)
{
	initialize(maxNumParticles);
}

void debris_particle_system::initialize(uint32 maxNumParticles)
{
	particle_system::initializeAsBillboard(sizeof(debris_particle_data), maxNumParticles, sort_mode_back_to_front);
}

void debris_particle_system::burst(vec3 position)
{
	bursts.push_back({ position });
}

void debris_particle_system::update(struct dx_command_list* cl, const common_particle_simulation_data& common, float dt)
{
	struct setter : public particle_parameter_setter
	{
		dx_dynamic_constant_buffer cbv;
		ref<dx_texture> depthBuffer;
		ref<dx_texture> normals;

		virtual void setRootParameters(dx_command_list* cl) override
		{
			cl->setComputeDynamicConstantBuffer(DEBRIS_PARTICLE_SYSTEM_COMPUTE_RS_CBV, cbv);
			cl->setDescriptorHeapSRV(DEBRIS_PARTICLE_SYSTEM_COMPUTE_RS_TEXTURES, 0, depthBuffer);
			cl->setDescriptorHeapSRV(DEBRIS_PARTICLE_SYSTEM_COMPUTE_RS_TEXTURES, 1, normals);
		}
	};

	const float linearDamping = 0.4f;

	debris_simulation_cb cb;
	cb.cameraVP = common.prevFrameCameraViewProj;
	cb.cameraProjectionParams = common.cameraProjectionParams;
	cb.cameraPosition = common.cameraPosition;
	cb.frameIndex = (uint32)dxContext.frameID;
	cb.drag = 1.f / (1.f + dt * linearDamping);

	uint32 numBursts = (uint32)min(arraysize(cb.emitPositions), bursts.size());
	uint32 numNewParticles = numBursts * 256;
	for (uint32 i = 0; i < numBursts; ++i)
	{
		cb.emitPositions[i] = vec4(bursts[i].position, 1.f);
	}

	setter s;
	s.cbv = dxContext.uploadDynamicConstantBuffer(cb);
	s.depthBuffer = common.prevFrameDepthBuffer;
	s.normals = common.prevFrameNormals;

	updateInternal(cl, (float)numNewParticles, dt, emitPipeline, simulatePipeline, &s);

	bursts.clear();
}

void debris_particle_system::render(transparent_render_pass* renderPass)
{
	debris_material material;

	renderPass->renderParticles<debris_pipeline>(billboardMesh.vertexBuffer, billboardMesh.indexBuffer,
		getDrawInfo(renderPipeline),
		material);
}

PIPELINE_SETUP_IMPL(debris_particle_system::debris_pipeline)
{
	cl->setPipelineState(*renderPipeline.pipeline);
	cl->setGraphicsRootSignature(*renderPipeline.rootSignature);
	cl->setPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
	cl->setGraphicsDynamicConstantBuffer(DEBRIS_PARTICLE_SYSTEM_RENDERING_RS_CAMERA, common.cameraCBV);
}

PARTICLE_PIPELINE_RENDER_IMPL(debris_particle_system::debris_pipeline, debris_particle_system::debris_material)
{
	particle_render_pipeline::render(cl, viewProj, rc);
}





```

`src/particles/debris_particle_system.h`:

```h
#pragma once

#include "particles.h"
#include "debris_particle_system.hlsli"
#include "dx/dx_texture.h"
#include "rendering/material.h"


struct debris_particle_system : particle_system
{
	static void initializePipeline();

	debris_particle_system() {}
	debris_particle_system(uint32 maxNumParticles);
	void initialize(uint32 maxNumParticles);

	void burst(vec3 position);

	virtual void update(struct dx_command_list* cl, const common_particle_simulation_data& common, float dt) override;
	void render(transparent_render_pass* renderPass);

private:
	static dx_pipeline emitPipeline;
	static dx_pipeline simulatePipeline;
	static dx_pipeline renderPipeline;


	struct debris_material
	{
	};

	struct debris_pipeline : particle_render_pipeline<debris_material>
	{
		PIPELINE_SETUP_DECL;
		PARTICLE_PIPELINE_RENDER_DECL(debris_material);
	};


	struct debris_burst
	{
		vec3 position;
	};

	std::vector<debris_burst> bursts;
};

```

`src/particles/fire_particle_system.cpp`:

```cpp
#include "pch.h"
#include "fire_particle_system.h"
#include "dx/dx_pipeline.h"
#include "rendering/render_resources.h"
#include "rendering/render_utils.h"
#include "dx/dx_profiling.h"


dx_pipeline fire_particle_system::emitPipeline;
dx_pipeline fire_particle_system::simulatePipeline;
dx_pipeline fire_particle_system::renderPipeline;


void fire_particle_system::initializePipeline()
{
#define name "fire_particle_system"

	emitPipeline = createReloadablePipeline(EMIT_PIPELINE_NAME(name));
	simulatePipeline = createReloadablePipeline(SIMULATE_PIPELINE_NAME(name));

	auto desc = CREATE_GRAPHICS_PIPELINE
		.inputLayout(inputLayout_position)
		.renderTargets(transparentLightPassFormats, arraysize(transparentLightPassFormats), depthStencilFormat)
		//.additiveBlending(0)
		.alphaBlending(0)
		.depthSettings(true, false);

	renderPipeline = createReloadablePipeline(desc, { VERTEX_SHADER_NAME(name), PIXEL_SHADER_NAME(name) });

#undef name
}

fire_particle_system::fire_particle_system(uint32 maxNumParticles, float emitRate, const std::string& textureFilename, uint32 cols, uint32 rows)
{
	initialize(maxNumParticles, emitRate, textureFilename, cols, rows);
}

void fire_particle_system::initialize(uint32 maxNumParticles, float emitRate, const std::string& textureFilename, uint32 cols, uint32 rows)
{
	this->emitRate = emitRate;
	auto tex = loadTextureFromFileAsync(textureFilename);

	if (!tex)
	{
		tex = render_resources::whiteTexture;
	}

	particle_system::initializeAsBillboard(sizeof(fire_particle_data), maxNumParticles, sort_mode_back_to_front);

	atlas.texture = tex;
	atlas.cols = cols;
	atlas.rows = rows;

	atlasCB.initialize(rows, cols);

	settings.sizeOverLifetime.values[0] = 0.25f;
	settings.sizeOverLifetime.values[1] = 0.7f;

	settings.intensityOverLifetime.ts[0] = 0.f;
	settings.intensityOverLifetime.ts[1] = 0.1f;
	settings.intensityOverLifetime.ts[2] = 0.25f;
	settings.intensityOverLifetime.ts[3] = 1.f;
	settings.intensityOverLifetime.values[0] = 0.f;
	settings.intensityOverLifetime.values[1] = 0.8f;
	settings.intensityOverLifetime.values[2] = 0.9f;
	settings.intensityOverLifetime.values[3] = 1.f;
}

void fire_particle_system::update(struct dx_command_list* cl, const common_particle_simulation_data& common, float dt)
{
	struct setter : public particle_parameter_setter
	{
		fire_simulation_cb cb;

		virtual void setRootParameters(dx_command_list* cl) override
		{
			cl->setCompute32BitConstants(FIRE_PARTICLE_SYSTEM_COMPUTE_RS_CBV, cb);
		}
	};

	setter s;
	s.cb.cameraPosition = common.cameraPosition;
	s.cb.emitPosition = vec3(0.f, 20.f, -10.f); // TEMPORARY.
	s.cb.frameIndex = (uint32)dxContext.frameID;

	updateInternal(cl, emitRate * dt, dt, emitPipeline, simulatePipeline, &s);
}

void fire_particle_system::render(transparent_render_pass* renderPass)
{
	fire_rendering_cb cb;
	cb.atlas = atlasCB;
	cb.settings = settings;

	fire_material material;
	material.atlas = atlas;
	material.cbv = dxContext.uploadDynamicConstantBuffer(cb);


	renderPass->renderParticles<fire_pipeline>(billboardMesh.vertexBuffer, billboardMesh.indexBuffer,
		getDrawInfo(renderPipeline),
		material);
}

PIPELINE_SETUP_IMPL(fire_particle_system::fire_pipeline)
{
	cl->setPipelineState(*renderPipeline.pipeline);
	cl->setGraphicsRootSignature(*renderPipeline.rootSignature);
	cl->setGraphicsDynamicConstantBuffer(FIRE_PARTICLE_SYSTEM_RENDERING_RS_CAMERA, common.cameraCBV);
	cl->setPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
}

PARTICLE_PIPELINE_RENDER_IMPL(fire_particle_system::fire_pipeline, fire_particle_system::fire_material)
{
	cl->setGraphicsDynamicConstantBuffer(FIRE_PARTICLE_SYSTEM_RENDERING_RS_CBV, rc.data.cbv);
	cl->setDescriptorHeapSRV(FIRE_PARTICLE_SYSTEM_RENDERING_RS_TEXTURE, 0, rc.data.atlas.texture);

	particle_render_pipeline::render(cl, viewProj, rc);
}





```

`src/particles/fire_particle_system.h`:

```h
#pragma once

#include "particles.h"
#include "fire_particle_system.hlsli"
#include "dx/dx_texture.h"
#include "rendering/material.h"


struct fire_particle_system : particle_system
{
	static void initializePipeline();

	fire_particle_system() {}
	fire_particle_system(uint32 maxNumParticles, float emitRate, const std::string& textureFilename, uint32 cols, uint32 rows);
	void initialize(uint32 maxNumParticles, float emitRate, const std::string& textureFilename, uint32 cols, uint32 rows);

	virtual void update(struct dx_command_list* cl, const common_particle_simulation_data& common, float dt) override;
	void render(transparent_render_pass* renderPass);

	float emitRate;
	fire_particle_settings settings;

private:
	dx_texture_atlas atlas;
	texture_atlas_cb atlasCB;

	static dx_pipeline emitPipeline;
	static dx_pipeline simulatePipeline;
	static dx_pipeline renderPipeline;


	struct fire_material
	{
		dx_texture_atlas atlas;
		dx_dynamic_constant_buffer cbv;
	};

	struct fire_pipeline : particle_render_pipeline<fire_material>
	{
		PIPELINE_SETUP_DECL;
		PARTICLE_PIPELINE_RENDER_DECL(fire_material);
	};
};

```

`src/particles/particle_systems.cpp`:

```cpp
#include "pch.h"
#include "particle_systems.h"

#include "fire_particle_system.h"
#include "smoke_particle_system.h"
#include "boid_particle_system.h"
#include "debris_particle_system.h"

void loadAllParticleSystemPipelines()
{
	fire_particle_system::initializePipeline();
	smoke_particle_system::initializePipeline();
	boid_particle_system::initializePipeline();
	debris_particle_system::initializePipeline();
}

```

`src/particles/particle_systems.h`:

```h
#pragma once

void loadAllParticleSystemPipelines();

```

`src/particles/particles.cpp`:

```cpp
#include "pch.h"
#include "particles.h"
#include "core/camera.h"
#include "geometry/mesh_builder.h"
#include "dx/dx_context.h"
#include "dx/dx_command_list.h"
#include "dx/dx_barrier_batcher.h"
#include "dx/dx_profiling.h"
#include "rendering/bitonic_sort.h"


ref<dx_buffer> particle_system::particleDrawCommandBuffer;
dx_command_signature particle_system::particleCommandSignature;
dx_mesh particle_system::billboardMesh;

static dx_pipeline startPipeline;

static volatile uint32 particleSystemCounter = 0;


void particle_system::initializePipeline()
{
	startPipeline = createReloadablePipeline("particle_start_cs");

	particleDrawCommandBuffer = createBuffer(sizeof(particle_draw), 1024, 0, true);

	D3D12_INDIRECT_ARGUMENT_DESC argumentDesc;
	argumentDesc.Type = D3D12_INDIRECT_ARGUMENT_TYPE_DRAW_INDEXED;
	particleCommandSignature = createCommandSignature({}, &argumentDesc, 1, sizeof(particle_draw));

	mesh_builder builder(mesh_creation_flags_with_positions);
	builder.pushQuad({ });
	billboardMesh = builder.createDXMesh();
}

void particle_system::initializeInternal(uint32 particleStructSize, uint32 maxNumParticles, submesh_info submesh, sort_mode sortMode)
{
	this->maxNumParticles = maxNumParticles;
	this->index = atomicIncrement(particleSystemCounter);
	this->submesh = submesh;
	this->sortMode = sortMode;


	std::vector<uint32> dead(maxNumParticles);

	for (uint32 i = 0; i < maxNumParticles; ++i)
	{
		dead[i] = i;
	}

	particle_counters counters = {};
	counters.numDeadParticles = maxNumParticles;


	particlesBuffer = createBuffer(particleStructSize, maxNumParticles, 0, true);


	// Lists.
	listBuffer = createBuffer(1, 
		sizeof(particle_counters)
		+ maxNumParticles * 3 * sizeof(uint32),
		0, true);
	updateBufferDataRange(listBuffer, &counters, 0, sizeof(particle_counters));
	updateBufferDataRange(listBuffer, dead.data(), getDeadListOffset(), maxNumParticles * sizeof(uint32));


	// Dispatch.
	dispatchBuffer = createBuffer((uint32)sizeof(particle_dispatch), 1, 0, true);


	if (sortMode != sort_mode_none)
	{
		sortBuffer = createBuffer(sizeof(float), maxNumParticles, 0, true);
	}

	
	particle_draw draw = {};
	draw.arguments.BaseVertexLocation = submesh.baseVertex;
	draw.arguments.IndexCountPerInstance = submesh.numIndices;
	draw.arguments.StartIndexLocation = submesh.firstIndex;
	updateBufferDataRange(particleDrawCommandBuffer, &draw, (uint32)sizeof(particle_draw) * index, (uint32)sizeof(particle_draw));
}

void particle_system::initializeAsBillboard(uint32 particleStructSize, uint32 maxNumParticles, sort_mode sortMode)
{
	submesh_info submesh = { 6, 0, 0, 4 };
	initializeInternal(particleStructSize, maxNumParticles, submesh, sortMode);
}

void particle_system::initializeAsMesh(uint32 particleStructSize, dx_mesh mesh, submesh_info submesh, uint32 maxNumParticles, sort_mode sortMode)
{
	initializeInternal(particleStructSize, maxNumParticles, submesh, sortMode);
}

particle_draw_info particle_system::getDrawInfo(const struct dx_pipeline& renderPipeline)
{
	particle_draw_info result;
	result.particleBuffer = particlesBuffer;
	result.aliveList = listBuffer;
	result.aliveListOffset = getAliveListOffset(currentAlive);
	result.commandBuffer = particleDrawCommandBuffer;
	result.commandBufferOffset = index * particleDrawCommandBuffer->elementSize;
	result.rootParameterOffset = renderPipeline.rootSignature->totalNumParameters - PARTICLE_RENDERING_RS_COUNT;
	return result;
}

void particle_system::updateInternal(struct dx_command_list* cl, float newParticles, float dt, const dx_pipeline& emitPipeline, const dx_pipeline& simulatePipeline, particle_parameter_setter* parameterSetter)
{
	{
		DX_PROFILE_BLOCK(cl, "Particle system update");

		// Buffers get promoted to D3D12_RESOURCE_STATE_UNORDERED_ACCESS implicitly, so we can omit this.
		//cl->transitionBarrier(dispatchBuffer, D3D12_RESOURCE_STATE_COMMON, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);

		particle_start_cb startCB = { newParticles, submesh.numIndices, submesh.firstIndex, submesh.baseVertex };

		// ----------------------------------------
		// START
		// ----------------------------------------

		{
			DX_PROFILE_BLOCK(cl, "Start emit");

			cl->setPipelineState(*startPipeline.pipeline);
			cl->setComputeRootSignature(*startPipeline.rootSignature);

			cl->setRootComputeUAV(PARTICLE_COMPUTE_RS_DISPATCH_INFO, dispatchBuffer);
			setResources(cl, startCB, 0, 0);

			cl->dispatch(1);
			barrier_batcher(cl)
				//.uav(dispatchBuffer)
				.uav(listBuffer)
				.transition(dispatchBuffer, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT);
		}

		// ----------------------------------------
		// EMIT
		// ----------------------------------------

		{
			DX_PROFILE_BLOCK(cl, "Emit");

			cl->setPipelineState(*emitPipeline.pipeline);
			cl->setComputeRootSignature(*emitPipeline.rootSignature);

			uint32 numUserRootParameters = getNumUserRootParameters(emitPipeline);
			setResources(cl, startCB, numUserRootParameters, parameterSetter);

			cl->dispatchIndirect(1, dispatchBuffer, 0);
			barrier_batcher(cl)
				.uav(particleDrawCommandBuffer)
				.uav(particlesBuffer)
				.uav(listBuffer);
		}

		particle_sim_cb simCB = { dt };

		// ----------------------------------------
		// SIMULATE
		// ----------------------------------------

		{
			DX_PROFILE_BLOCK(cl, "Simulate");

			cl->setPipelineState(*simulatePipeline.pipeline);
			cl->setComputeRootSignature(*simulatePipeline.rootSignature);

			uint32 numUserRootParameters = getNumUserRootParameters(simulatePipeline);
			setResources(cl, simCB, numUserRootParameters, parameterSetter);

			cl->dispatchIndirect(1, dispatchBuffer, sizeof(D3D12_DISPATCH_ARGUMENTS));
			barrier_batcher(cl)
				.uav(particleDrawCommandBuffer)
				.uav(particlesBuffer)
				.uav(listBuffer)
				.uav(sortBuffer);
		}

		currentAlive = 1 - currentAlive;

		// ----------------------------------------
		// SORT
		// ----------------------------------------

		auto drawState = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;

		if (sortMode != sort_mode_none)
		{
			barrier_batcher(cl)
				.transition(particleDrawCommandBuffer, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE);

			drawState = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;

			bitonicSortFloat(cl,
				sortBuffer, 0,
				listBuffer, getAliveListOffset(currentAlive),
				maxNumParticles,
				particleDrawCommandBuffer, sizeof(particle_draw) * index + offsetof(particle_draw, arguments) + offsetof(D3D12_DRAW_INDEXED_ARGUMENTS, InstanceCount),
				sortMode == sort_mode_front_to_back);
		}

		barrier_batcher(cl)
			.transition(particleDrawCommandBuffer, drawState, D3D12_RESOURCE_STATE_COMMON);

		// Buffers decay to D3D12_RESOURCE_STATE_COMMON implicitly, so we can omit this.
		//cl->transitionBarrier(dispatchBuffer, D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT, D3D12_RESOURCE_STATE_COMMON);
	}
}

void particle_system::setResources(dx_command_list* cl, uint32 offset, particle_parameter_setter* parameterSetter)
{
	uint32 nextAlive = 1 - currentAlive;

	cl->setRootComputeUAV(offset + PARTICLE_COMPUTE_RS_DRAW_INFO, particleDrawCommandBuffer->gpuVirtualAddress + sizeof(particle_draw) * index);
	cl->setRootComputeUAV(offset + PARTICLE_COMPUTE_RS_COUNTERS, listBuffer->gpuVirtualAddress);
	cl->setRootComputeUAV(offset + PARTICLE_COMPUTE_RS_PARTICLES, particlesBuffer);
	cl->setRootComputeUAV(offset + PARTICLE_COMPUTE_RS_DEAD_LIST, listBuffer->gpuVirtualAddress + getDeadListOffset());
	cl->setRootComputeUAV(offset + PARTICLE_COMPUTE_RS_CURRENT_ALIVE, listBuffer->gpuVirtualAddress + getAliveListOffset(currentAlive));
	cl->setRootComputeUAV(offset + PARTICLE_COMPUTE_RS_NEW_ALIVE, listBuffer->gpuVirtualAddress + getAliveListOffset(nextAlive));

	if (sortBuffer)
	{
		cl->setRootComputeUAV(offset + PARTICLE_COMPUTE_RS_SORT_KEY, sortBuffer);
	}

	if (parameterSetter)
	{
		parameterSetter->setRootParameters(cl);
	}
}

uint32 particle_system::getAliveListOffset(uint32 alive)
{
	ASSERT(alive == 0 || alive == 1);

	return getDeadListOffset() +
		(1 + alive) * maxNumParticles * (uint32)sizeof(uint32);
}

uint32 particle_system::getDeadListOffset()
{
	return (uint32)sizeof(particle_counters);
}

uint32 particle_system::getNumUserRootParameters(const dx_pipeline& pipeline)
{
	uint32 numSimulationRootParameters = PARTICLE_COMPUTE_RS_COUNT;
	uint32 numUserRootParameters = pipeline.rootSignature->totalNumParameters - numSimulationRootParameters;
	return numUserRootParameters;
}

```

`src/particles/particles.h`:

```h
#pragma once

#include "core/math.h"
#include "rendering/render_pass.h"
#include "dx/dx_command_list.h"

#include "particles_rs.hlsli"

struct dx_command_list;

enum sort_mode
{
	sort_mode_none,
	sort_mode_front_to_back,
	sort_mode_back_to_front,
};

struct common_particle_simulation_data
{
	mat4 prevFrameCameraView;
	mat4 prevFrameCameraViewProj;

	vec4 cameraProjectionParams;

	vec3 cameraPosition;

	ref<dx_texture> prevFrameDepthBuffer;
	ref<dx_texture> prevFrameNormals;
};

struct particle_system
{
	virtual ~particle_system() {}

	virtual void update(struct dx_command_list* cl, const common_particle_simulation_data& common, float dt) = 0;

protected:

	struct particle_parameter_setter
	{
		virtual void setRootParameters(dx_command_list* cl) = 0;
	};

	void initializeAsBillboard(uint32 particleStructSize, uint32 maxNumParticles, sort_mode sortMode = sort_mode_none);
	void initializeAsMesh(uint32 particleStructSize, dx_mesh mesh, submesh_info submesh, uint32 maxNumParticles, sort_mode sortMode = sort_mode_none);

	particle_draw_info getDrawInfo(const struct dx_pipeline& renderPipeline);

	static dx_mesh billboardMesh;
	submesh_info submesh;

protected:
	void updateInternal(struct dx_command_list* cl, float newParticles, float dt, const dx_pipeline& emitPipeline, const dx_pipeline& simulatePipeline, particle_parameter_setter* parameterSetter);

private:
	static void initializePipeline();

	void initializeInternal(uint32 particleStructSize, uint32 maxNumParticles, submesh_info submesh, sort_mode sortMode);

	template <typename T>
	void setResources(dx_command_list* cl, const T& cb, uint32 offset, particle_parameter_setter* parameterSetter)
	{
		cl->setCompute32BitConstants(offset + PARTICLE_COMPUTE_RS_CB, cb);
		setResources(cl, offset, parameterSetter);
	}

	void setResources(dx_command_list* cl, uint32 offset, particle_parameter_setter* parameterSetter);

	uint32 getAliveListOffset(uint32 alive);
	uint32 getDeadListOffset();
	uint32 getNumUserRootParameters(const struct dx_pipeline& pipeline);

	uint32 maxNumParticles;
	uint32 currentAlive = 0;

	ref<dx_buffer> particlesBuffer;
	ref<dx_buffer> listBuffer; // Counters, dead, alive 0, alive 1.
	ref<dx_buffer> dispatchBuffer;
	ref<dx_buffer> sortBuffer;

	sort_mode sortMode;

	uint32 index;

	static ref<dx_buffer> particleDrawCommandBuffer;
	static dx_command_signature particleCommandSignature;

	friend void initializeRenderUtils();
	template <typename T> friend struct particle_render_pipeline;
};

template <typename render_data_t>
struct particle_render_pipeline
{
	static void render(dx_command_list* cl, const mat4& viewProj, const particle_render_command<render_data_t>& rc);
};

template<typename render_data_t>
inline void particle_render_pipeline<render_data_t>::render(dx_command_list* cl, const mat4& viewProj, const particle_render_command<render_data_t>& rc)
{
	const particle_draw_info& info = rc.drawInfo;

	cl->setRootGraphicsSRV(info.rootParameterOffset + PARTICLE_RENDERING_RS_PARTICLES, info.particleBuffer->gpuVirtualAddress);
	cl->setRootGraphicsSRV(info.rootParameterOffset + PARTICLE_RENDERING_RS_ALIVE_LIST, info.aliveList->gpuVirtualAddress + info.aliveListOffset);

	cl->setVertexBuffer(0, rc.vertexBuffer.positions);
	if (rc.vertexBuffer.others)
	{
		cl->setVertexBuffer(1, rc.vertexBuffer.others);
	}
	cl->setIndexBuffer(rc.indexBuffer);

	cl->drawIndirect(particle_system::particleCommandSignature, 1, info.commandBuffer, info.commandBufferOffset);
}

#define BUILD_PARTICLE_SHADER_NAME(name, suffix) name##suffix

#define EMIT_PIPELINE_NAME(name) BUILD_PARTICLE_SHADER_NAME(name, "_emit_cs")
#define SIMULATE_PIPELINE_NAME(name) BUILD_PARTICLE_SHADER_NAME(name, "_sim_cs")
#define VERTEX_SHADER_NAME(name) BUILD_PARTICLE_SHADER_NAME(name, "_vs")
#define PIXEL_SHADER_NAME(name) BUILD_PARTICLE_SHADER_NAME(name, "_ps")



```

`src/particles/smoke_particle_system.cpp`:

```cpp
#include "pch.h"
#include "smoke_particle_system.h"
#include "dx/dx_pipeline.h"
#include "rendering/render_resources.h"
#include "rendering/render_utils.h"


dx_pipeline smoke_particle_system::emitPipeline;
dx_pipeline smoke_particle_system::simulatePipeline;
dx_pipeline smoke_particle_system::renderPipeline;


void smoke_particle_system::initializePipeline()
{
#define name "smoke_particle_system"

	emitPipeline = createReloadablePipeline(EMIT_PIPELINE_NAME(name));
	simulatePipeline = createReloadablePipeline(SIMULATE_PIPELINE_NAME(name));

	auto desc = CREATE_GRAPHICS_PIPELINE
		.inputLayout(inputLayout_position)
		.renderTargets(transparentLightPassFormats, arraysize(transparentLightPassFormats), depthStencilFormat)
		.alphaBlending(0)
		.depthSettings(true, false);

	renderPipeline = createReloadablePipeline(desc, { VERTEX_SHADER_NAME(name), PIXEL_SHADER_NAME(name) });

#undef name
}

smoke_particle_system::smoke_particle_system(uint32 maxNumParticles, float emitRate, const std::string& textureFilename, uint32 cols, uint32 rows)
{
	initialize(maxNumParticles, emitRate, textureFilename, cols, rows);
}

void smoke_particle_system::initialize(uint32 maxNumParticles, float emitRate, const std::string& textureFilename, uint32 cols, uint32 rows)
{
	this->emitRate = emitRate;
	auto tex = loadTextureFromFileAsync(textureFilename);

	if (!tex)
	{
		tex = render_resources::whiteTexture;
	}

	particle_system::initializeAsBillboard(sizeof(smoke_particle_data), maxNumParticles, sort_mode_back_to_front);

	atlas.texture = tex;
	atlas.cols = cols;
	atlas.rows = rows;

	atlasCB.initialize(rows, cols);
}

void smoke_particle_system::update(struct dx_command_list* cl, const common_particle_simulation_data& common, float dt)
{
	struct setter : public particle_parameter_setter
	{
		dx_dynamic_constant_buffer cb;

		virtual void setRootParameters(dx_command_list* cl) override
		{
			cl->setComputeDynamicConstantBuffer(SMOKE_PARTICLE_SYSTEM_COMPUTE_RS_CBV, cb);
		}
	};

	smoke_simulation_cb cb;
	cb.cameraPosition = common.cameraPosition;
	cb.emitPosition = vec3(20.f, 20.f, -10.f); // TEMPORARY.
	cb.frameIndex = (uint32)dxContext.frameID;
	cb.lifeScaleFromDistance = settings.lifeScaleFromDistance;

	setter s;
	s.cb = dxContext.uploadDynamicConstantBuffer(cb);

	updateInternal(cl, emitRate * dt, dt, emitPipeline, simulatePipeline, &s);
}

void smoke_particle_system::render(transparent_render_pass* renderPass)
{
	smoke_rendering_cb cb;
	cb.atlas = atlasCB;
	cb.intensityOverLifetime = settings.intensityOverLifetime;
	cb.atlasProgressionOverLifetime = settings.atlasProgressionOverLifetime;

	smoke_material material;
	material.atlas = atlas;
	material.cbv = dxContext.uploadDynamicConstantBuffer(cb);

	renderPass->renderParticles<smoke_pipeline>(billboardMesh.vertexBuffer, billboardMesh.indexBuffer,
		getDrawInfo(renderPipeline),
		material);
}

PIPELINE_SETUP_IMPL(smoke_particle_system::smoke_pipeline)
{
	cl->setPipelineState(*renderPipeline.pipeline);
	cl->setGraphicsRootSignature(*renderPipeline.rootSignature);
	cl->setGraphicsDynamicConstantBuffer(SMOKE_PARTICLE_SYSTEM_RENDERING_RS_CAMERA, common.cameraCBV);
	cl->setPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
}

PARTICLE_PIPELINE_RENDER_IMPL(smoke_particle_system::smoke_pipeline, smoke_particle_system::smoke_material)
{
	cl->setGraphicsDynamicConstantBuffer(SMOKE_PARTICLE_SYSTEM_RENDERING_RS_CBV, rc.data.cbv);
	cl->setDescriptorHeapSRV(SMOKE_PARTICLE_SYSTEM_RENDERING_RS_TEXTURE, 0, rc.data.atlas.texture);

	particle_render_pipeline::render(cl, viewProj, rc);
}


```

`src/particles/smoke_particle_system.h`:

```h
#pragma once

#include "particles.h"
#include "smoke_particle_system.hlsli"
#include "dx/dx_texture.h"
#include "rendering/material.h"


struct smoke_particle_system : particle_system
{
	static void initializePipeline();

	smoke_particle_system() {}
	smoke_particle_system(uint32 maxNumParticles, float emitRate, const std::string& textureFilename, uint32 cols, uint32 rows);
	void initialize(uint32 maxNumParticles, float emitRate, const std::string& textureFilename, uint32 cols, uint32 rows);

	virtual void update(struct dx_command_list* cl, const common_particle_simulation_data& common, float dt) override;
	void render(transparent_render_pass* renderPass);

	float emitRate;
	smoke_particle_settings settings;

private:
	texture_atlas_cb atlasCB;
	dx_texture_atlas atlas;

	static dx_pipeline emitPipeline;
	static dx_pipeline simulatePipeline;
	static dx_pipeline renderPipeline;


	struct smoke_material
	{
		dx_texture_atlas atlas;
		dx_dynamic_constant_buffer cbv;
	};

	struct smoke_pipeline : particle_render_pipeline<smoke_material>
	{
		PIPELINE_SETUP_DECL;
		PARTICLE_PIPELINE_RENDER_DECL(smoke_material);
	};
};


```

`src/pch.cpp`:

```cpp
#include "pch.h"

```

`src/pch.h`:

```h
#pragma once

#define NOMINMAX
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <windowsx.h>
#include <tchar.h>

#include <limits>
#include <array>
#include <string>
#include <vector>
#include <iostream>
#include <memory>

#include <filesystem>
namespace fs = std::filesystem;

#include <mutex>

#include <wrl.h> 

typedef int8_t int8;
typedef uint8_t uint8;
typedef int16_t int16;
typedef uint16_t uint16;
typedef int32_t int32;
typedef uint32_t uint32;
typedef int64_t int64;
typedef uint64_t uint64;
typedef wchar_t wchar;

#define ASSERT(cond) \
	(void)((!!(cond)) || (std::cout << "Assertion '" << #cond "' failed [" __FILE__ " : " << __LINE__ << "].\n", ::__debugbreak(), 0))

template <typename T> using ref = std::shared_ptr<T>;
template <typename T> using weakref = std::weak_ptr<T>;

template <typename T, typename... Args>
inline ref<T> make_ref(Args&&... args) 
{ 
	return std::make_shared<T>(std::forward<Args>(args)...); 
}

template <typename T> struct is_ref : std::false_type {};
template <typename T> struct is_ref<ref<T>> : std::true_type {};

template <typename T> inline constexpr bool is_ref_v = is_ref<T>::value;


template <typename T>
using com = Microsoft::WRL::ComPtr<T>;

#define arraysize(arr) (sizeof(arr) / sizeof((arr)[0]))


template <typename T>
constexpr inline auto min(T a, T b)
{
	return (a < b) ? a : b;
}

template <typename T>
constexpr inline auto max(T a, T b)
{
	return (a < b) ? b : a;
}

template <auto V> static constexpr auto force_consteval = V;

#define setBit(mask, bit) (mask) |= (1 << (bit))
#define unsetBit(mask, bit) (mask) ^= (1 << (bit))


static void checkResultInternal(HRESULT hr, char* file, int32 line)
{
	if (FAILED(hr))
	{
		char buffer[128];

		FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM,
			NULL, hr,
			MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
			buffer,
			sizeof(buffer),
			NULL);

		std::cout << "Command failed [" << file << " : " << line << "]: " << buffer << ".\n";

		__debugbreak();
	}
}

#define checkResult(hr) checkResultInternal(hr, __FILE__, __LINE__)





```

`src/physics/bounding_volumes.cpp`:

```cpp
#include "pch.h"
#include "bounding_volumes.h"
#include "collision_gjk.h"

#include <unordered_map>

static bool pointInAABB(vec3 point, bounding_box aabb)
{
	return point.x >= aabb.minCorner.x
		&& point.y >= aabb.minCorner.y
		&& point.z >= aabb.minCorner.z
		&& point.x <= aabb.maxCorner.x
		&& point.y <= aabb.maxCorner.y
		&& point.z <= aabb.maxCorner.z;
}

static float closestPointOnLineSegment(vec3 point, vec3 lineA, vec3 lineB)
{
	vec3 ab = lineB - lineA;
	float t = dot(point - lineA, ab) / squaredLength(ab);
	t = clamp(t, 0.f, 1.f);
	return t;
}

void bounding_box::grow(vec3 o)
{
	minCorner.x = min(minCorner.x, o.x);
	minCorner.y = min(minCorner.y, o.y);
	minCorner.z = min(minCorner.z, o.z);
	maxCorner.x = max(maxCorner.x, o.x);
	maxCorner.y = max(maxCorner.y, o.y);
	maxCorner.z = max(maxCorner.z, o.z);
}

void bounding_box::pad(vec3 p)
{
	minCorner -= p;
	maxCorner += p;
}

vec3 bounding_box::getCenter() const
{
	return (minCorner + maxCorner) * 0.5f;
}

vec3 bounding_box::getRadius() const
{
	return (maxCorner - minCorner) * 0.5f;
}

bool bounding_box::contains(vec3 p) const
{
	return p.x >= minCorner.x && p.x <= maxCorner.x
		&& p.y >= minCorner.y && p.y <= maxCorner.y
		&& p.z >= minCorner.z && p.z <= maxCorner.z;
}

bounding_box bounding_box::transformToAABB(quat rotation, vec3 translation) const
{
	bounding_box result = bounding_box::negativeInfinity();
	result.grow(rotation * minCorner + translation);
	result.grow(rotation * vec3(maxCorner.x, minCorner.y, minCorner.z) + translation);
	result.grow(rotation * vec3(minCorner.x, maxCorner.y, minCorner.z) + translation);
	result.grow(rotation * vec3(maxCorner.x, maxCorner.y, minCorner.z) + translation);
	result.grow(rotation * vec3(minCorner.x, minCorner.y, maxCorner.z) + translation);
	result.grow(rotation * vec3(maxCorner.x, minCorner.y, maxCorner.z) + translation);
	result.grow(rotation * vec3(minCorner.x, maxCorner.y, maxCorner.z) + translation);
	result.grow(rotation * maxCorner + translation);
	return result;
}

bounding_oriented_box bounding_box::transformToOBB(quat rotation, vec3 translation) const
{
	bounding_oriented_box obb;
	obb.center = rotation * getCenter() + translation;
	obb.radius = getRadius();
	obb.rotation = rotation;
	return obb;
}

bounding_box_corners bounding_box::getCorners() const
{
	bounding_box_corners result;
	result.i = minCorner;
	result.x = vec3(maxCorner.x, minCorner.y, minCorner.z);
	result.y = vec3(minCorner.x, maxCorner.y, minCorner.z);
	result.xy = vec3(maxCorner.x, maxCorner.y, minCorner.z);
	result.z = vec3(minCorner.x, minCorner.y, maxCorner.z);
	result.xz = vec3(maxCorner.x, minCorner.y, maxCorner.z);
	result.yz = vec3(minCorner.x, maxCorner.y, maxCorner.z);
	result.xyz = maxCorner;
	return result;
}

bounding_box_corners bounding_box::getCorners(quat rotation, vec3 translation) const
{
	bounding_box_corners result;
	result.i = rotation * minCorner + translation;
	result.x = rotation * vec3(maxCorner.x, minCorner.y, minCorner.z) + translation;
	result.y = rotation * vec3(minCorner.x, maxCorner.y, minCorner.z) + translation;
	result.xy = rotation * vec3(maxCorner.x, maxCorner.y, minCorner.z) + translation;
	result.z = rotation * vec3(minCorner.x, minCorner.y, maxCorner.z) + translation;
	result.xz = rotation * vec3(maxCorner.x, minCorner.y, maxCorner.z) + translation;
	result.yz = rotation * vec3(minCorner.x, maxCorner.y, maxCorner.z) + translation;
	result.xyz = rotation * maxCorner + translation;
	return result;
}

bounding_box bounding_box::everything()
{
	return bounding_box{ vec3(-FLT_MAX, -FLT_MAX, -FLT_MAX), vec3(FLT_MAX, FLT_MAX, FLT_MAX) };
}

bounding_box bounding_box::negativeInfinity()
{
	return bounding_box{ vec3(FLT_MAX, FLT_MAX, FLT_MAX), vec3(-FLT_MAX, -FLT_MAX, -FLT_MAX) };
}

bounding_box bounding_box::fromMinMax(vec3 minCorner, vec3 maxCorner)
{
	return bounding_box{ minCorner, maxCorner };
}

bounding_box bounding_box::fromCenterRadius(vec3 center, vec3 radius)
{
	return bounding_box{ center - radius, center + radius };
}

bounding_box bounding_oriented_box::getAABB() const
{
	bounding_box bb = { -radius, radius };
	return bb.transformToAABB(rotation, center);
}

bounding_box bounding_oriented_box::transformToAABB(quat rotation, vec3 translation) const
{
	bounding_box bb = { -radius, radius };
	return bb.transformToAABB(rotation * this->rotation, rotation * center + translation);
}

bounding_oriented_box bounding_oriented_box::transformToOBB(quat rotation, vec3 translation) const
{
	return bounding_oriented_box{ rotation * this->rotation, rotation * center + translation, radius };
}

bounding_box_corners bounding_oriented_box::getCorners() const
{
	bounding_box bb = { -radius, radius };
	return bb.getCorners(rotation, center);
}

void bounding_rectangle::grow(vec2 o)
{
	minCorner.x = min(minCorner.x, o.x);
	minCorner.y = min(minCorner.y, o.y);
	maxCorner.x = max(maxCorner.x, o.x);
	maxCorner.y = max(maxCorner.y, o.y);
}

void bounding_rectangle::pad(vec2 p)
{
	minCorner -= p;
	maxCorner += p;
}

vec2 bounding_rectangle::getCenter() const
{
	return (minCorner + maxCorner) * 0.5f;
}

vec2 bounding_rectangle::getRadius() const
{
	return (maxCorner - minCorner) * 0.5f;
}

bool bounding_rectangle::contains(vec2 p) const
{
	return p.x >= minCorner.x && p.x <= maxCorner.x
		&& p.y >= minCorner.y && p.y <= maxCorner.y;
}

bounding_rectangle bounding_rectangle::negativeInfinity()
{
	return bounding_rectangle{ vec2(FLT_MAX, FLT_MAX), vec2(-FLT_MAX, -FLT_MAX) };
}

bounding_rectangle bounding_rectangle::fromMinMax(vec2 minCorner, vec2 maxCorner)
{
	return bounding_rectangle{ minCorner, maxCorner };
}

bounding_rectangle bounding_rectangle::fromCenterRadius(vec2 center, vec2 radius)
{
	return bounding_rectangle{ center - radius, center + radius };
}

bool ray::intersectPlane(vec3 normal, float d, float& outT) const
{
	float ndotd = dot(direction, normal);
	if (abs(ndotd) < 1e-6f)
	{
		return false;
	}

	outT = -(dot(origin, normal) + d) / ndotd;
	return true;
}

bool ray::intersectPlane(vec3 normal, vec3 point, float& outT) const
{
	float d = -dot(normal, point);
	return intersectPlane(normal, d, outT);
}

bool ray::intersectAABB(const bounding_box& a, float& outT) const
{
	vec3 invDir = vec3(1.f / direction.x, 1.f / direction.y, 1.f / direction.z); // This can be Inf (when one direction component is 0) but still works.

	float tx1 = (a.minCorner.x - origin.x) * invDir.x;
	float tx2 = (a.maxCorner.x - origin.x) * invDir.x;

	outT = min(tx1, tx2);
	float tmax = max(tx1, tx2);

	float ty1 = (a.minCorner.y - origin.y) * invDir.y;
	float ty2 = (a.maxCorner.y - origin.y) * invDir.y;

	outT = max(outT, min(ty1, ty2));
	tmax = min(tmax, max(ty1, ty2));

	float tz1 = (a.minCorner.z - origin.z) * invDir.z;
	float tz2 = (a.maxCorner.z - origin.z) * invDir.z;

	outT = max(outT, min(tz1, tz2));
	tmax = min(tmax, max(tz1, tz2));

	bool result = tmax >= outT && outT > 0.f;

	return result;
}

bool ray::intersectOBB(const bounding_oriented_box& a, float& outT) const
{
	//return (conjugate(m.rotation) * (pos - m.position)) / m.scale;
	ray localR = { conjugate(a.rotation) * (origin - a.center), conjugate(a.rotation) * direction };
	return localR.intersectAABB(bounding_box::fromCenterRadius(0.f, a.radius), outT);
}

bool ray::intersectTriangle(vec3 a, vec3 b, vec3 c, float& outT, bool& outFrontFacing) const
{
	vec3 normal = noz(cross(b - a, c - a));
	float d = -dot(normal, a);

	float nDotR = dot(direction, normal);
	if (fabsf(nDotR) <= 1e-6f)
	{
		return false;
	}

	outT = -(dot(origin, normal) + d) / nDotR;

	vec3 q = origin + outT * direction;
	outFrontFacing = nDotR < 0.f;
	return outT >= 0.f && pointInTriangle(q, a, b, c);
}

bool ray::intersectSphere(vec3 center, float radius, float& outT) const
{
	vec3 m = origin - center;
	float b = dot(m, direction);
	float c = dot(m, m) - radius * radius;

	if (c > 0.f && b > 0.f)
	{
		return false;
	}

	float discr = b * b - c;

	if (discr < 0.f)
	{
		return false;
	}

	outT = -b - sqrt(discr);

	if (outT < 0.f)
	{
		outT = 0.f;
	}

	return true;
}

bool ray::intersectCylinder(const bounding_cylinder& cylinder, float& outT) const
{
	vec3 d = direction;
	vec3 o = origin;

	vec3 axis = cylinder.positionB - cylinder.positionA;
	float height = length(axis);

	quat q = rotateFromTo(axis, vec3(0.f, 1.f, 0.f));

	// Cylinder base is at 0,0,0. Second point is above it.
	o = q * (o - cylinder.positionA);
	d = q * d;


	float epsilon = 1e-6f;

	float y = -1.f;
	if (squaredLength(vec2(o.x, o.z)) > cylinder.radius * cylinder.radius)
	{
		// We are outside the infinite cylinder. Only in this case it is possible to hit the sides.

		float a = d.x * d.x + d.z * d.z;
		float b = d.x * o.x + d.z * o.z;
		float c = o.x * o.x + o.z * o.z - cylinder.radius * cylinder.radius;

		float delta = b * b - a * c;

		if (delta < epsilon)
		{
			return false;
		}

		outT = (-b - sqrt(delta)) / a;
		if (outT <= epsilon)
		{
			return false; // Behind ray.
		}

		y = o.y + outT * d.y;
	}

	// Check bases. Always true if the above if is not taken.
	if (y > height + epsilon || y < -epsilon) 
	{
		vec3 posA = vec3(0.f, 0.f, 0.f);
		vec3 posB = vec3(0.f, height, 0.f);

		ray localRay = { o, d };

		float dist;
		bool b1 = d.y < 0.f && localRay.intersectDisk(posB, vec3(0.f, 1.f, 0.f), cylinder.radius, dist);
		if (b1)
		{
			outT = dist;
		}
		bool b2 = d.y > 0.f && localRay.intersectDisk(posA, vec3(0.f, -1.f, 0.f), cylinder.radius, dist);
		if (b2)
		{
			outT = dist;
		}

		y = o.y + outT * d.y;
	}

	return y > -epsilon && y < height + epsilon;
}

bool ray::intersectCapsule(const bounding_capsule& capsule, float& outT) const
{
	outT = FLT_MAX;
	float t;
	bool result = false;
	if (intersectCylinder(bounding_cylinder{ capsule.positionA, capsule.positionB, capsule.radius }, t))
	{
		outT = t;
		result = true;
	}
	if (intersectSphere(bounding_sphere{ capsule.positionA, capsule.radius }, t))
	{
		outT = min(outT, t);
		result = true;
	}
	if (intersectSphere(bounding_sphere{ capsule.positionB, capsule.radius }, t))
	{
		outT = min(outT, t);
		result = true;
	}
	return result;
}

bool ray::intersectDisk(vec3 pos, vec3 normal, float radius, float& outT) const
{
	bool intersectsPlane = intersectPlane(normal, pos, outT);
	if (intersectsPlane)
	{
		return length(origin + outT * direction - pos) <= radius;
	}
	return false;
}

bool ray::intersectRectangle(vec3 pos, vec3 tangent, vec3 bitangent, vec2 radius, float& outT) const
{
	vec3 normal = cross(tangent, bitangent);
	bool intersectsPlane = intersectPlane(normal, pos, outT);
	if (intersectsPlane)
	{
		vec3 offset = origin + outT * direction - pos;
		vec2 projected(dot(offset, tangent), dot(offset, bitangent));
		projected = abs(projected);
		if (projected.x <= radius.x && projected.y <= radius.y)
		{
			return true;
		}
	}
	return false;
}

static bool isZero(float x) 
{
	return abs(x) < 1e-6f;
}

struct solve_2_result
{
	uint32 numResults;
	float results[2];
};

struct solve_3_result
{
	uint32 numResults;
	float results[3];
};

struct solve_4_result
{
	uint32 numResults;
	float results[4];
};

static solve_2_result solve2(float c0, float c1, float c2)
{
	float p = c1 / (2 * c2);
	float q = c0 / c2;

	float D = p * p - q;

	if (isZero(D)) 
	{
		return { 1, -p };
	}
	else if (D < 0) 
	{
		return { 0 };
	}
	else /* if (D > 0) */ 
	{
		float sqrt_D = sqrt(D);

		return { 2, sqrt_D - p, -sqrt_D - p };
	}
}

static solve_3_result solve3(float c0, float c1, float c2, float c3)
{
	float A = c2 / c3;
	float B = c1 / c3;
	float C = c0 / c3;

	float sq_A = A * A;
	float p = 1.f / 3 * (-1.f / 3 * sq_A + B);
	float q = 1.f / 2 * (2.f / 27 * A * sq_A - 1.f / 3 * A * B + C);

	/* use Cardano's formula */

	float cb_p = p * p * p;
	float D = q * q + cb_p;

	solve_3_result s = {};

	if (isZero(D))
	{
		if (isZero(q))
		{
			s = { 1, 0.f };
		}
		else
		{
			float u = cbrt(-q);
			s = { 2, 2.f * u, -u };
		}
	}
	else if (D < 0) /* Casus irreducibilis: three real solutions */ 
	{
		float phi = 1.f / 3.f * acos(-q / sqrt(-cb_p));
		float t = 2.f * sqrt(-p);

		s = { 3,
			t * cos(phi),
			-t * cos(phi + M_PI / 3),
			-t * cos(phi - M_PI / 3) };

	}
	else /* one real solution */ 
	{
		float sqrt_D = sqrt(D);
		float u = cbrt(sqrt_D - q);
		float v = -cbrt(sqrt_D + q);

		s = { 1, u + v };

	}

	/* resubstitute */

	float sub = 1.f / 3.f * A;

	for (uint32 i = 0; i < s.numResults; ++i)
	{
		s.results[i] -= sub;
	}

	return s;
}

/**
 *  Solves equation:
 *
 *      c[0] + c[1]*x + c[2]*x^2 + c[3]*x^3 + c[4]*x^4 = 0
 *
 */
static solve_4_result solve4(float c0, float c1, float c2, float c3, float c4)
{
	/* normal form: x^4 + Ax^3 + Bx^2 + Cx + D = 0 */

	float A = c3 / c4;
	float B = c2 / c4;
	float C = c1 / c4;
	float D = c0 / c4;

	/*  substitute x = y - A/4 to eliminate cubic term:
	x^4 + px^2 + qx + r = 0 */

	float sq_A = A * A;
	float p = -3.f / 8 * sq_A + B;
	float q = 1.f / 8 * sq_A * A - 1.f / 2 * A * B + C;
	float r = -3.f / 256 * sq_A * sq_A + 1.f / 16 * sq_A * B - 1.f / 4 * A * C + D;
	solve_4_result s = {};

	if (isZero(r)) 
	{
		/* no absolute term: y(y^3 + py + q) = 0 */

		auto s3 = solve3(q, p, 0, 1);
		for (uint32 i = 0; i < s3.numResults; ++i)
		{
			s.results[s.numResults++] = s3.results[i];
		}

		s.results[s.numResults++] = 0.f;
	}
	else 
	{
		/* solve the resolvent cubic ... */
		
		auto s3 = solve3(1.f / 2 * r * p - 1.f / 8 * q * q, -r, -0.5f * p, 1.f);
		for (uint32 i = 0; i < s3.numResults; ++i)
		{
			s.results[s.numResults++] = s3.results[i];
		}

		/* ... and take the one real solution ... */

		float z = s.results[0];

		/* ... to build two quadric equations */

		float u = z * z - r;
		float v = 2.f * z - p;

		if (isZero(u))
		{
			u = 0;
		}
		else if (u > 0)
		{
			u = sqrt(u);
		}
		else
		{
			return {};
		}

		if (isZero(v))
		{
			v = 0;
		}
		else if (v > 0)
		{
			v = sqrt(v);
		}
		else
		{
			return {};
		}

		auto s2 = solve2(z - u, q < 0 ? -v : v, 1);
		s = {};
		for (uint32 i = 0; i < s2.numResults; ++i)
		{
			s.results[s.numResults++] = s2.results[i];
		}

		s2 = solve2(z + u, q < 0 ? v : -v, 1);
		for (uint32 i = 0; i < s2.numResults; ++i)
		{
			s.results[s.numResults++] = s2.results[i];
		}
	}

	/* resubstitute */

	float sub = 1.f / 4 * A;

	for (uint32 i = 0; i < s.numResults; ++i)
	{
		s.results[i] -= sub;
	}

	return s;
}

bool ray::intersectTorus(const bounding_torus& torus, float& outT) const
{
	vec3 d = direction;
	vec3 o = origin;

	vec3 axis = torus.upAxis;

	quat q = rotateFromTo(axis, vec3(0.f, 1.f, 0.f));

	o = q * (o - torus.position);
	d = q * d;



	// define the coefficients of the quartic equation
	float sum_d_sqrd = dot(d, d);

	float e = dot(o, o) - torus.majorRadius * torus.majorRadius - torus.tubeRadius * torus.tubeRadius;
	float f = dot(o, d);
	float four_a_sqrd = 4.f * torus.majorRadius * torus.majorRadius;

	auto solution = solve4(
		e * e - four_a_sqrd * (torus.tubeRadius * torus.tubeRadius - o.y * o.y),
		4.f * f * e + 2.f * four_a_sqrd * o.y * d.y,
		2.f * sum_d_sqrd * e + 4.f * f * f + four_a_sqrd * d.y * d.y,
		4.f * sum_d_sqrd * f,
		sum_d_sqrd * sum_d_sqrd
	);

	// ray misses the torus
	if (solution.numResults == 0)
	{
		return false;
	}

	// find the smallest root greater than kEpsilon, if any
	// the roots array is not sorted
	float minT = FLT_MAX;
	for (uint32 i = 0; i < solution.numResults; ++i) 
	{
		float t = solution.results[i];
		if ((t > 1e-6f) && (t < minT)) {
			minT = t;
		}
	}
	outT = minT;
	return true;
}

bool ray::intersectHull(const bounding_hull& hull, const bounding_hull_geometry& geometry, float& outT) const
{
	ray localR = { conjugate(hull.rotation) * (origin - hull.position), conjugate(hull.rotation) * direction };

	float minT = FLT_MAX;
	bool result = false;

	for (uint32 i = 0; i < (uint32)geometry.faces.size(); ++i)
	{
		auto tri = geometry.faces[i];
		vec3 a = geometry.vertices[tri.a];
		vec3 b = geometry.vertices[tri.b];
		vec3 c = geometry.vertices[tri.c];

		float t;
		bool ff;
		if (localR.intersectTriangle(a, b, c, t, ff) && t < minT)
		{
			minT = t;
			result = true;
		}
	}

	outT = minT;
	return result;
}

bool sphereVsCylinder(const bounding_sphere& s, const bounding_cylinder& c)
{
	vec3 ab = c.positionB - c.positionA;
	float t = dot(s.center - c.positionA, ab) / squaredLength(ab);
	if (t >= 0.f && t <= 1.f)
	{
		return sphereVsSphere(s, bounding_sphere{ lerp(c.positionA, c.positionB, t), c.radius });
	}

	vec3 p = (t <= 0.f) ? c.positionA : c.positionB;
	vec3 up = (t <= 0.f) ? -ab : ab;

	vec3 projectedDirToCenter = normalize(cross(cross(up, s.center - p), up));
	vec3 endA = p + projectedDirToCenter * c.radius;
	vec3 endB = p - projectedDirToCenter * c.radius;

	vec3 closestToSphere = closestPoint_PointSegment(s.center, line_segment{ endA, endB });
	float sqDistance = squaredLength(closestToSphere - s.center);

	return sqDistance <= s.radius;
}

bool sphereVsHull(const bounding_sphere& s, const bounding_hull& h)
{
	sphere_support_fn sphereSupport{ s };
	hull_support_fn hullSupport{ h };

	gjk_simplex gjkSimplex;
	return gjkIntersectionTest(sphereSupport, hullSupport, gjkSimplex);
}

bool sphereVsTriangle(const bounding_sphere& s, vec3 a, vec3 b, vec3 c)
{
	vec3 p = closestPoint_PointTriangle(s.center, a, b, c);
	vec3 v = p - s.center;
	return dot(v, v) <= s.radius * s.radius;
}

bool capsuleVsAABB(const bounding_capsule& c, const bounding_box& b)
{
	capsule_support_fn capsuleSupport{ c };
	aabb_support_fn boxSupport{ b };

	gjk_simplex gjkSimplex;
	return gjkIntersectionTest(capsuleSupport, boxSupport, gjkSimplex);
}

bool capsuleVsOBB(const bounding_capsule& c, const bounding_oriented_box& o)
{
	bounding_box aabb = bounding_box::fromCenterRadius(o.center, o.radius);
	bounding_capsule c_ = {
		conjugate(o.rotation) * (c.positionA - o.center) + o.center,
		conjugate(o.rotation) * (c.positionB - o.center) + o.center,
		c.radius };

	return capsuleVsAABB(c_, aabb);
}

bool capsuleVsHull(const bounding_capsule& c, const bounding_hull& h)
{
	capsule_support_fn capsuleSupport{ c };
	hull_support_fn hullSupport{ h };

	gjk_simplex gjkSimplex;
	return gjkIntersectionTest(capsuleSupport, hullSupport, gjkSimplex);
}

bool capsuleVsTriangle(const bounding_capsule& capsule, vec3 a, vec3 b, vec3 c)
{
	ray r = { capsule.positionA, normalize(capsule.positionB - capsule.positionA) };

	vec3 triNormal = normalize(cross(b - a, c - a));
	float d = -dot(triNormal, a);

	float ndotd = dot(r.direction, triNormal);

	float t = -(dot(r.origin, triNormal) + d) / ndotd;

	vec3 trace = r.origin + t * r.direction;
	vec3 closest = closestPoint_PointTriangle(trace, a, b, c);

	vec3 reference = closestPoint_PointSegment(closest, { capsule.positionA, capsule.positionB });

	return sphereVsTriangle(bounding_sphere{ reference, capsule.radius }, a, b, c);
}

bool cylinderVsCylinder(const bounding_cylinder& a, const bounding_cylinder& b)
{
	cylinder_support_fn cylinderSupportA{ a };
	cylinder_support_fn cylinderSupportB{ b };

	gjk_simplex gjkSimplex;
	return gjkIntersectionTest(cylinderSupportA, cylinderSupportB, gjkSimplex);
}

bool cylinderVsAABB(const bounding_cylinder& c, const bounding_box& b)
{
	cylinder_support_fn cylinderSupport{ c };
	aabb_support_fn boxSupport{ b };

	gjk_simplex gjkSimplex;
	return gjkIntersectionTest(cylinderSupport, boxSupport, gjkSimplex);
}

bool cylinderVsOBB(const bounding_cylinder& c, const bounding_oriented_box& o)
{
	bounding_box aabb = bounding_box::fromCenterRadius(o.center, o.radius);
	bounding_cylinder c_ = {
		conjugate(o.rotation) * (c.positionA - o.center) + o.center,
		conjugate(o.rotation) * (c.positionB - o.center) + o.center,
		c.radius };

	return cylinderVsAABB(c_, aabb);
}

bool cylinderVsHull(const bounding_cylinder& c, const bounding_hull& h)
{
	cylinder_support_fn cylinderSupport{ c };
	hull_support_fn hullSupport{ h };

	gjk_simplex gjkSimplex;
	return gjkIntersectionTest(cylinderSupport, hullSupport, gjkSimplex);
}

bool aabbVsHull(const bounding_box& a, const bounding_hull& h)
{
	aabb_support_fn aabbSupport{ a };
	hull_support_fn hullSupport{ h };

	gjk_simplex gjkSimplex;
	return gjkIntersectionTest(aabbSupport, hullSupport, gjkSimplex);
}

bool aabbVsPlane(const bounding_box& a, vec4 plane)
{
	vec3 center = a.getCenter();
	vec3 radius = a.getRadius();

	float r = dot(radius, abs(plane.xyz));
	float s = abs(signedDistanceToPlane(center, plane));

	return s <= r;
}

bool aabbVsTriangle(const bounding_box& aabb, vec3 a, vec3 b, vec3 c)
{
	vec3 radius = aabb.getRadius();
	vec3 center = aabb.getCenter();

	a -= center;
	b -= center;
	c -= center;

	vec3 f0 = b - a;
	vec3 f1 = c - b;
	vec3 f2 = a - c;

	// Test axis (1, 0, 0) x f0 = (0, -f0.z, f0.y)
	{
		// p0	= dot(a, axis)
		//		= (-a.y * f0.z) + (a.z * f0.y)
		//		= -a.y * (b.z - a.z) + a.z * (b.y - a.y)
		//		= (-a.y * b.z) + (a.y * a.z) + (a.z * b.y) - (a.z * a.y)
		//		= (-a.y * b.z) + (a.z * b.y)

		// p1	= dot(b, axis)
		//		= (-b.y * f0.z) + (b.z * f0.y)
		//		= -b.y * (b.z - a.z) + b.z * (b.y - a.y)
		//		= (-b.y * b.z) + (b.y - a.z) + (b.z * b.y) - (b.z * a.y)
		//		= (b.y - a.z) - (b.z * a.y)
		//		= p0

		// p2	= dot(c, axis)
		//		= (-c.y * f0.z) + (c.z * f0.y)

		float p0 = (a.z * f0.y) - (a.y * f0.z);
		float p2 = (c.z * f0.y) - (c.y * f0.z);
		float r = radius.y * abs(f0.z) + radius.z * abs(f0.y);
		if (max(-max(p0, p2), min(p0, p2)) > r) return false;
	}

	// Test axis (1, 0, 0) x f1 = (0, -f1.z, f1.y)
	{
		// p0	= dot(a, axis)
		//		= (-a.y * f1.z) + (a.z * f1.y)
		//		= -a.y * (c.z - b.z) + a.z * (c.y - b.y)
		//		= (-a.y * c.z) + (a.y * b.z) + (a.z * c.y) - (a.z * b.y)

		// p1	= dot(b, axis)
		//		= (-b.y * f1.z) + (b.z * f1.y)
		//		= -b.y * (c.z - b.z) + b.z * (c.y - b.y)
		//		= (-b.y * c.z) + (b.y * b.z) + (b.z * c.y) - (b.z * b.y)
		//		= (-b.y * c.z) + (b.z * c.y)

		// p2	= dot(c, axis)
		//		= (-c.y * f1.z) + (c.z * f1.y)
		//		= -c.y * (c.z - b.z) + c.z * (c.y - b.y)
		//		= (-c.y * c.z) + (c.y * b.z) + (c.z * c.y) - (c.z * b.y)
		//		= (c.y * b.z) - (c.z * b.y)
		//		= p1

		float p0 = (a.z * f1.y) - (a.y * f1.z);
		float p1 = (b.z * f1.y) - (b.y * f1.z);
		float r = radius.y * abs(f1.z) + radius.z * abs(f1.y);
		if (max(-max(p0, p1), min(p0, p1)) > r) return false;
	}

	// Test axis (1, 0, 0) x f2 = (0, -f2.z, f2.y)
	{
		// p0	= dot(a, axis)
		//		= (-a.y * f2.z) + (a.z * f2.y)
		//		= -a.y * (a.z - c.z) + a.z * (a.y - c.y)
		//		= (-a.y * a.z) + (a.y * c.z) + (a.z * a.y) - (a.z * c.y)
		//		= (a.y * c.z) - (a.z * c.y)

		// p1	= dot(b, axis)
		//		= (-b.y * f2.z) + (b.z * f2.y)
		//		= -b.y * (a.z - c.z) + b.z * (a.y - c.y)
		//		= (-b.y * a.z) + (b.y * c.z) + (b.z * a.y) - (b.z * c.y)

		// p2	= dot(c, axis)
		//		= (-c.y * f2.z) + (c.z * f2.y)
		//		= -c.y * (a.z - c.z) + c.z * (a.y - c.y)
		//		= (-c.y * a.z) + (c.y * c.z) + (c.z * a.y) - (c.z * c.y)
		//		= (-c.y * a.z) + (c.z * a.y)
		//		= p0

		float p0 = (a.z * f2.y) - (a.y * f2.z);
		float p1 = (b.z * f2.y) - (b.y * f2.z);
		float r = radius.y * abs(f2.z) + radius.z * abs(f2.y);
		if (max(-max(p0, p1), min(p0, p1)) > r) return false;
	}


	// Test axis (0, 1, 0) x f0 = (f0.z, 0, -f0.x)
	{
		// p0	= dot(a, axis)
		//		= (a.x * f0.z) - (a.z * f0.x)
		//		= a.x * (b.z - a.z) - a.z * (b.x - a.x)
		//		= (a.x * b.z) - (a.x * a.z) - (a.z * b.x) + (a.z * a.x)
		//		= (a.x * b.z) - (a.z * b.x)

		// p1	= dot(b, axis)
		//		= (b.x * f0.z) - (b.z * f0.x)
		//		= b.x * (b.z - a.z) - b.z * (b.x - a.x)
		//		= (b.x * b.z) - (b.x * a.z) - (b.z * b.x) + (b.z * a.x)
		//		= (b.z * a.x) - (b.x * a.z)
		//		= p0

		// p2	= dot(c, axis)
		//		= (c.x * f0.z) - (c.z * f0.x)

		float p0 = (a.x * f0.z) - (a.z * f0.x);
		float p2 = (c.x * f0.z) - (c.z * f0.x);
		float r = radius.x * abs(f0.z) + radius.z * abs(f0.x);
		if (max(-max(p0, p2), min(p0, p2)) > r) return false;
	}

	// Test axis (0, 1, 0) x f1 = (f1.z, 0, -f1.x)
	{
		// p0	= dot(a, axis)
		//		= (a.x * f1.z) - (a.z * f1.x)

		// p1	= dot(b, axis)
		//		= (b.x * f1.z) - (b.z * f1.x)

		// p2	= dot(c, axis)
		//		= (c.x * f1.z) - (c.z * f1.x)
		//		= p1

		float p0 = (a.x * f1.z) - (a.z * f1.x);
		float p1 = (b.x * f1.z) - (b.z * f1.x);
		float r = radius.x * abs(f1.z) + radius.z * abs(f1.x);
		if (max(-max(p0, p1), min(p0, p1)) > r) return false;
	}

	// Test axis (0, 1, 0) x f2 = (f2.z, 0, -f2.x)
	{
		// p0	= dot(a, axis)
		//		= (a.x * f2.z) - (a.z * f2.x)

		// p1	= dot(b, axis)
		//		= (b.x * f2.z) - (b.z * f2.x)

		// p2	= dot(c, axis)
		//		= (c.x * f2.z) - (c.z * f2.x)
		//		= p0

		float p0 = (a.x * f2.z) - (a.z * f2.x);
		float p1 = (b.x * f2.z) - (b.z * f2.x);
		float r = radius.x * abs(f2.z) + radius.z * abs(f2.x);
		if (max(-max(p0, p1), min(p0, p1)) > r) return false;
	}


	// Test axis (0, 0, 1) x f0 = (-f0.y, f0.x, 0)
	{
		// p0	= dot(a, axis)
		//		= (-a.x * f0.y) + (a.y * f0.x)

		// p1	= dot(b, axis)
		//		= (-b.x * f0.y) + (b.y * f0.x)
		//		= p0

		// p2	= dot(c, axis)
		//		= (-c.x * f0.y) + (c.y * f0.x)

		float p0 = (a.y * f0.x) - (a.x * f0.y);
		float p2 = (c.y * f0.x) - (c.x * f0.y);
		float r = radius.x * abs(f0.y) + radius.y * abs(f0.x);
		if (max(-max(p0, p2), min(p0, p2)) > r) return false;
	}

	// Test axis (0, 0, 1) x f1 = (-f1.y, f1.x, 0)
	{
		// p0	= dot(a, axis)
		//		= (-a.x * f1.y) + (a.y * f1.x)

		// p1	= dot(b, axis)
		//		= (-b.x * f1.y) + (b.y * f1.x)

		// p2	= dot(c, axis)
		//		= (-c.x * f1.y) + (c.y * f1.x)
		//		= p1

		float p0 = (a.y * f1.x) - (a.x * f1.y);
		float p1 = (b.y * f1.x) - (b.x * f1.y);
		float r = radius.x * abs(f1.y) + radius.y * abs(f1.x);
		if (max(-max(p0, p1), min(p0, p1)) > r) return false;
	}

	// Test axis (0, 0, 1) x f2 = (-f2.y, f2.x, 0)
	{
		// p0	= dot(a, axis)
		//		= (-a.x * f2.y) + (a.y * f2.x)

		// p1	= dot(b, axis)
		//		= (-b.x * f2.y) + (b.y * f2.x)

		// p2	= dot(c, axis)
		//		= (-c.x * f2.y) + (c.y * f2.x)
		//		= p0

		float p0 = (a.y * f2.x) - (a.x * f2.y);
		float p1 = (b.y * f2.x) - (b.x * f2.y);
		float r = radius.x * abs(f2.y) + radius.y * abs(f2.x);
		if (max(-max(p0, p1), min(p0, p1)) > r) return false;
	}


	// Test face normals of AABB. Exit if...
	// ... [-radius.x, radius.x] and [min(a.x,b.x,c.x), max(a.x,b.x,c.x)] do not overlap
	if (max(a.x, max(b.x, c.x)) < -radius.x || min(a.x, min(b.x, c.x)) > radius.x) return false;
	// ... [-radius.y, radius.y] and [min(a.y,b.y,c.y), max(a.y,b.y,c.y)] do not overlap
	if (max(a.y, max(b.y, c.y)) < -radius.y || min(a.y, min(b.y, c.y)) > radius.y) return false;
	// ... [-radius.z, radius.z] and [min(a.z,b.z,c.z), max(a.z,b.z,c.z)] do not overlap
	if (max(a.z, max(b.z, c.z)) < -radius.z || min(a.z, min(b.z, c.z)) > radius.z) return false;


	{
		vec3 triNormal = cross(f0, f1);
		float triD = dot(triNormal, a);

		float r = dot(radius, abs(triNormal));
		float s = abs(triD);

		if (s > r)
		{
			return false;
		}
	}

	return true;
}

bool obbVsOBB(const bounding_oriented_box& a, const bounding_oriented_box& b)
{
	union obb_axes
	{
		struct
		{
			vec3 x, y, z;
		};
		vec3 u[3];
	};

	float ra, rb, penetration;

	obb_axes axesA = {
		a.rotation * vec3(1.f, 0.f, 0.f),
		a.rotation * vec3(0.f, 1.f, 0.f),
		a.rotation * vec3(0.f, 0.f, 1.f),
	};

	obb_axes axesB = {
		b.rotation * vec3(1.f, 0.f, 0.f),
		b.rotation * vec3(0.f, 1.f, 0.f),
		b.rotation * vec3(0.f, 0.f, 1.f),
	};

	mat3 r;
	r.m00 = dot(axesA.x, axesB.x);
	r.m10 = dot(axesA.y, axesB.x);
	r.m20 = dot(axesA.z, axesB.x);
	r.m01 = dot(axesA.x, axesB.y);
	r.m11 = dot(axesA.y, axesB.y);
	r.m21 = dot(axesA.z, axesB.y);
	r.m02 = dot(axesA.x, axesB.z);
	r.m12 = dot(axesA.y, axesB.z);
	r.m22 = dot(axesA.z, axesB.z);

	vec3 tw = b.center - a.center;
	vec3 t = conjugate(a.rotation) * tw;

	mat3 absR;
	for (uint32 i = 0; i < 9; ++i)
	{
		absR.m[i] = abs(r.m[i]) + EPSILON; // Add in an epsilon term to counteract arithmetic errors when two edges are parallel and their cross product is (near) 0.
	}

	// Test a's faces.
	for (uint32 i = 0; i < 3; ++i)
	{
		ra = a.radius.data[i];
		rb = dot(row(absR, i), b.radius);
		float d = t.data[i];
		penetration = ra + rb - abs(d);
		if (penetration < 0.f) { return false; }
	}

	// Test b's faces.
	for (uint32 i = 0; i < 3; ++i)
	{
		ra = dot(col(absR, i), a.radius);
		rb = b.radius.data[i];
		float d = dot(col(r, i), t);
		penetration = ra + rb - abs(d);
		if (penetration < 0.f) { return false; }
	}

	// Test a.x x b.x.
	ra = a.radius.y * absR.m20 + a.radius.z * absR.m10;
	rb = b.radius.y * absR.m02 + b.radius.z * absR.m01;
	penetration = ra + rb - abs(t.z * r.m10 - t.y * r.m20);
	if (penetration < 0.f) { return false; }

	// Test a.x x b.y.
	ra = a.radius.y * absR.m21 + a.radius.z * absR.m11;
	rb = b.radius.x * absR.m02 + b.radius.z * absR.m00;
	penetration = ra + rb - abs(t.z * r.m11 - t.y * r.m21);
	if (penetration < 0.f) { return false; }

	// Test a.x x b.z.
	ra = a.radius.y * absR.m22 + a.radius.z * absR.m12;
	rb = b.radius.x * absR.m01 + b.radius.y * absR.m00;
	penetration = ra + rb - abs(t.z * r.m12 - t.y * r.m22);
	if (penetration < 0.f) { return false; }

	// Test a.y x b.x.
	ra = a.radius.x * absR.m20 + a.radius.z * absR.m00;
	rb = b.radius.y * absR.m12 + b.radius.z * absR.m11;
	penetration = ra + rb - abs(t.x * r.m20 - t.z * r.m00);
	if (penetration < 0.f) { return false; }

	// Test a.y x b.y.
	ra = a.radius.x * absR.m21 + a.radius.z * absR.m01;
	rb = b.radius.x * absR.m12 + b.radius.z * absR.m10;
	penetration = ra + rb - abs(t.x * r.m21 - t.z * r.m01);
	if (penetration < 0.f) { return false; }

	// Test a.y x b.z.
	ra = a.radius.x * absR.m22 + a.radius.z * absR.m02;
	rb = b.radius.x * absR.m11 + b.radius.y * absR.m10;
	penetration = ra + rb - abs(t.x * r.m22 - t.z * r.m02);
	if (penetration < 0.f) { return false; }

	// Test a.z x b.x.
	ra = a.radius.x * absR.m10 + a.radius.y * absR.m00;
	rb = b.radius.y * absR.m22 + b.radius.z * absR.m21;
	penetration = ra + rb - abs(t.y * r.m00 - t.x * r.m10);
	if (penetration < 0.f) { return false; }

	// Test a.z x b.y.
	ra = a.radius.x * absR.m11 + a.radius.y * absR.m01;
	rb = b.radius.x * absR.m22 + b.radius.z * absR.m20;
	penetration = ra + rb - abs(t.y * r.m01 - t.x * r.m11);
	if (penetration < 0.f) { return false; }

	// Test a.z x b.z.
	ra = a.radius.x * absR.m12 + a.radius.y * absR.m02;
	rb = b.radius.x * absR.m21 + b.radius.y * absR.m20;
	penetration = ra + rb - abs(t.y * r.m02 - t.x * r.m12);
	if (penetration < 0.f) { return false; }

	return true;
}

bool obbVsHull(const bounding_oriented_box& o, const bounding_hull& h)
{
	obb_support_fn obbSupport{ o };
	hull_support_fn hullSupport{ h };

	gjk_simplex gjkSimplex;
	return gjkIntersectionTest(obbSupport, hullSupport, gjkSimplex);
}

bool obbVsPlane(const bounding_oriented_box& a, vec4 plane)
{
	vec3 center = a.center;
	vec3 radius = a.radius;

	vec3 e0 = a.rotation * vec3(1.f, 0.f, 0.f);
	vec3 e1 = a.rotation * vec3(0.f, 1.f, 0.f);
	vec3 e2 = a.rotation * vec3(0.f, 0.f, 1.f);

	float r = radius.x * abs(dot(plane.xyz, e0))
			+ radius.y * abs(dot(plane.xyz, e1))
			+ radius.z * abs(dot(plane.xyz, e2));

	float s = abs(signedDistanceToPlane(center, plane));

	return s <= r;
}

bool obbVsTriangle(const bounding_oriented_box& obb, vec3 a, vec3 b, vec3 c)
{
	a = conjugate(obb.rotation) * (a - obb.center);
	b = conjugate(obb.rotation) * (b - obb.center);
	c = conjugate(obb.rotation) * (c - obb.center);

	return aabbVsTriangle({ -obb.radius, obb.radius }, a, b, c);
}

bool hullVsHull(const bounding_hull& a, const bounding_hull& b)
{
	hull_support_fn hullSupport1{ a };
	hull_support_fn hullSupport2{ b };

	gjk_simplex gjkSimplex;
	return gjkIntersectionTest(hullSupport1, hullSupport2, gjkSimplex);
}






float closestPoint_SegmentSegment(const line_segment& l1, const line_segment& l2, vec3& c1, vec3& c2)
{
	float s, t;
	vec3 d1 = l1.b - l1.a; // Direction vector of segment S1
	vec3 d2 = l2.b - l2.a; // Direction vector of segment S2
	vec3 r = l1.a - l2.a;
	float a = dot(d1, d1); // Squared length of segment S1, always nonnegative
	float e = dot(d2, d2); // Squared length of segment S2, always nonnegative
	float f = dot(d2, r);
	// Check if either or both segments degenerate into points
	if (a <= EPSILON && e <= EPSILON)
	{
		// Both segments degenerate into points
		s = t = 0.0f;
		c1 = l1.a;
		c2 = l2.a;
		return dot(c1 - c2, c1 - c2);
	}
	if (a <= EPSILON)
	{
		// First segment degenerates into a point
		s = 0.0f;
		t = f / e; // s = 0 => t = (b*s + f) / e = f / e
		t = clamp(t, 0.f, 1.f);
	}
	else 
	{
		float c = dot(d1, r);
		if (e <= EPSILON)
		{
			// Second segment degenerates into a point
			t = 0.0f;
			s = clamp(-c / a, 0.f, 1.f); // t = 0 => s = (b*t - c) / a = -c / a
		}
		else
		{
			// The general nondegenerate case starts here
			float b = dot(d1, d2);
			float denom = a * e - b * b; // Always nonnegative
			// If segments not parallel, compute closest point on L1 to L2 and
			// clamp to segment S1. Else pick arbitrary s (here 0)
			if (denom != 0.f)
				s = clamp((b * f - c * e) / denom, 0.f, 1.f);
			else
				s = 0.0f;
			// Compute point on L2 closest to S1(s) using
			// t = dot((l1.a + D1*s) - l2.a,D2) / dot(D2,D2) = (b*s + f) / e
			t = (b * s + f) / e;
			// If t in [0,1] done. Else clamp t, recompute s for the new value
			// of t using s = dot((l2.a + D2*t) - l1.a,D1) / dot(D1,D1)= (t*b - c) / a
			// and clamp s to [0, 1]
			if (t < 0.f) {
				t = 0.f;
				s = clamp(-c / a, 0.f, 1.f);
			}
			else if (t > 1.0f) {
				t = 1.f;
				s = clamp((b - c) / a, 0.f, 1.f);
			}
		}
	}
	c1 = l1.a + d1 * s;
	c2 = l2.a + d2 * t;
	return squaredLength(c1 - c2);
}

vec3 closestPoint_PointTriangle(const vec3& p, const vec3& a, const vec3& b, const vec3& c)
{
	vec3 ab = b - a;
	vec3 ac = c - a;
	vec3 ap = p - a;
	float d1 = dot(ab, ap);
	float d2 = dot(ac, ap);
	if (d1 <= 0.f && d2 <= 0.f) return a; // Barycentric coordinates (1,0,0)

	// Check if P in vertex region outside B
	vec3 bp = p - b;
	float d3 = dot(ab, bp);
	float d4 = dot(ac, bp);
	if (d3 >= 0.f && d4 <= d3) return b; // Barycentric coordinates (0,1,0)

	// Check if P in edge region of AB, if so return projection of P onto AB
	float vc = d1 * d4 - d3 * d2;
	if (vc <= 0.f && d1 >= 0.f && d3 <= 0.f) 
	{
		float v = d1 / (d1 - d3);
		return a + v * ab; // Barycentric coordinates (1-v,v,0)
	}

	// Check if P in vertex region outside C
	vec3 cp = p - c;
	float d5 = dot(ab, cp);
	float d6 = dot(ac, cp);
	if (d6 >= 0.f && d5 <= d6) return c; // Barycentric coordinates (0,0,1)

	// Check if P in edge region of AC, if so return projection of P onto AC
	float vb = d5 * d2 - d1 * d6;
	if (vb <= 0.f && d2 >= 0.f && d6 <= 0.f) 
	{
		float w = d2 / (d2 - d6);
		return a + w * ac; // Barycentric coordinates (1-w,0,w)
	}

	// Check if P in edge region of BC, if so return projection of P onto BC
	float va = d3 * d6 - d5 * d4;
	if (va <= 0.f && (d4 - d3) >= 0.f && (d5 - d6) >= 0.f) 
	{
		float w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
		return b + w * (c - b); // Barycentric coordinates (0,1-w,w)
	}

	// P inside face region. Compute Q through its barycentric coordinates (u,v,w)
	float denom = 1.f / (va + vb + vc);
	float v = vb * denom;
	float w = vc * denom;
	return a + ab * v + ac * w; // = u*a + v*b + w*c, u = va * denom = 1.0f - v - w
}

static void addBoundingHullEdge(uint32 a, uint32 b, uint32 face, std::unordered_map<uint32, bounding_hull_edge*>& edgeMap, std::vector<bounding_hull_edge>& edges, uint32& edgeIndex)
{
	uint32 from = min(a, b);
	uint32 to = max(a, b);
	uint32 edge = (from << 16) | to;

	auto it = edgeMap.find(edge);
	if (it == edgeMap.end())
	{
		auto& newEdge = edges[edgeIndex++];
		newEdge.from = from;
		newEdge.to = to;
		newEdge.faceA = face;
		edgeMap.insert({ edge, &newEdge });
	}
	else
	{
		ASSERT(it->second->from == from);
		ASSERT(it->second->to == to);
		ASSERT(it->second->faceA != UINT16_MAX);
		ASSERT(it->second->faceB == UINT16_MAX);
		it->second->faceB = face;
	}
}

template <typename triangle_t>
static bounding_hull_geometry hullFromMesh(vec3* vertices, uint32 numVertices, triangle_t* triangles, uint32 numTriangles)
{
	bounding_hull_geometry hull;

	uint32 numEdges = numVertices + numTriangles - 2; // Euler characteristic for convex polyhedra.

	hull.vertices.resize(numVertices);
	hull.faces.resize(numTriangles);
	hull.edges.resize(numEdges, { UINT16_MAX, UINT16_MAX, UINT16_MAX, UINT16_MAX });
	hull.aabb = bounding_box::negativeInfinity();

	for (uint32 i = 0; i < numVertices; ++i)
	{
		hull.vertices[i] = vertices[i];
		hull.aabb.grow(vertices[i]);
	}

	std::unordered_map<uint32, bounding_hull_edge*> edgeMap;

	uint32 edgeIndex = 0;

	for (uint32 i = 0; i < numTriangles; ++i)
	{
		triangle_t tri = triangles[i];

		uint32 a = tri.a;
		uint32 b = tri.b;
		uint32 c = tri.c;

		vec3 va = vertices[a];
		vec3 vb = vertices[b];
		vec3 vc = vertices[c];
		vec3 normal = cross(vb - va, vc - va);

		hull.faces[i].a = a;
		hull.faces[i].b = b;
		hull.faces[i].c = c;
		hull.faces[i].normal = normal;

		addBoundingHullEdge(a, b, i, edgeMap, hull.edges, edgeIndex);
		addBoundingHullEdge(b, c, i, edgeMap, hull.edges, edgeIndex);
		addBoundingHullEdge(a, c, i, edgeMap, hull.edges, edgeIndex);
	}

	ASSERT(edgeIndex == numEdges);

	return hull;
}

bounding_hull_geometry bounding_hull_geometry::fromMesh(vec3* vertices, uint32 numVertices, indexed_triangle16* triangles, uint32 numTriangles)
{
	return hullFromMesh(vertices, numVertices, triangles, numTriangles);
}

bounding_hull_geometry bounding_hull_geometry::fromMesh(vec3* vertices, uint32 numVertices, indexed_triangle32* triangles, uint32 numTriangles)
{
	return hullFromMesh(vertices, numVertices, triangles, numTriangles);
}

```

`src/physics/bounding_volumes.h`:

```h
#pragma once

#include "core/math.h"

struct indexed_triangle16
{
	uint16 a, b, c;
};

struct indexed_triangle32
{
	uint32 a, b, c;
};

struct indexed_line16
{
	uint16 a, b;
};

struct indexed_line32
{
	uint32 a, b;
};

struct line_segment
{
	vec3 a, b;
};

struct bounding_sphere
{
	vec3 center;
	float radius;

	float volume()
	{
		float sqRadius = radius * radius;
		float sqRadiusPI = M_PI * sqRadius;
		float sphereVolume = 4.f / 3.f * sqRadiusPI * radius;
		return sphereVolume;
	}
};

struct bounding_capsule
{
	vec3 positionA;
	vec3 positionB;
	float radius;

	float volume()
	{
		float sqRadius = radius * radius;
		float sqRadiusPI = M_PI * sqRadius;
		float sphereVolume = 4.f / 3.f * sqRadiusPI * radius;
		float height = length(positionA - positionB);
		float cylinderVolume = sqRadiusPI * height;
		return sphereVolume + cylinderVolume;
	}
};

struct bounding_cylinder
{
	vec3 positionA;
	vec3 positionB;
	float radius;

	float volume()
	{
		float sqRadiusPI = M_PI * radius * radius;
		float height = length(positionA - positionB);
		float cylinderVolume = sqRadiusPI * height;
		return cylinderVolume;
	}
};

struct bounding_torus
{
	vec3 position;
	vec3 upAxis;
	float majorRadius;
	float tubeRadius;
};

union bounding_box_corners
{
	struct
	{
		vec3 i;
		vec3 x;
		vec3 y;
		vec3 xy;
		vec3 z;
		vec3 xz;
		vec3 yz;
		vec3 xyz;
	};
	vec3 corners[8];

	bounding_box_corners() {}
};

struct bounding_oriented_box;

struct bounding_box
{
	vec3 minCorner;
	vec3 maxCorner;

	void grow(vec3 o);
	void pad(vec3 p);
	vec3 getCenter() const;
	vec3 getRadius() const;
	bool contains(vec3 p) const;

	bounding_box transformToAABB(quat rotation, vec3 translation) const;
	bounding_oriented_box transformToOBB(quat rotation, vec3 translation) const;
	bounding_box_corners getCorners() const;
	bounding_box_corners getCorners(quat rotation, vec3 translation) const;

	static bounding_box everything();
	static bounding_box negativeInfinity();
	static bounding_box fromMinMax(vec3 minCorner, vec3 maxCorner);
	static bounding_box fromCenterRadius(vec3 center, vec3 radius);

	float volume()
	{
		vec3 diameter = maxCorner - minCorner;
		return diameter.x * diameter.y * diameter.z;
	}
};

struct bounding_oriented_box
{
	quat rotation;
	vec3 center;
	vec3 radius;

	float volume()
	{
		vec3 diameter = radius * 2.f;
		return diameter.x * diameter.y * diameter.z;
	}

	bounding_box getAABB() const;
	bounding_box transformToAABB(quat rotation, vec3 translation) const;
	bounding_oriented_box transformToOBB(quat rotation, vec3 translation) const;
	bounding_box_corners getCorners() const;
};

struct bounding_rectangle
{
	vec2 minCorner;
	vec2 maxCorner;

	void grow(vec2 o);
	void pad(vec2 p);
	vec2 getCenter() const;
	vec2 getRadius() const;
	bool contains(vec2 p) const;

	static bounding_rectangle negativeInfinity();
	static bounding_rectangle fromMinMax(vec2 minCorner, vec2 maxCorner);
	static bounding_rectangle fromCenterRadius(vec2 center, vec2 radius);
};

inline vec4 createPlane(vec3 point, vec3 normal)
{
	float d = -dot(normal, point);
	return vec4(normal, d);
}

inline vec3 createLine(vec2 point, vec2 normal)
{
	float d = -dot(normal, point);
	return vec3(normal, d);
}

float signedDistanceToPlane(const vec3& p, const vec4& plane);

struct bounding_plane
{
	vec4 plane;

	bounding_plane() {}
	bounding_plane(vec3 point, vec3 normal)
	{
		plane = createPlane(point, normal);
	}

	float signedDistance(vec3 p)
	{
		return signedDistanceToPlane(p, plane);
	}
};

struct bounding_hull_edge
{
	uint16 from, to;
	uint16 faceA, faceB;
};

struct bounding_hull_face
{
	uint16 a, b, c;
	vec3 normal;
};

struct bounding_hull_geometry
{
	std::vector<vec3> vertices;
	std::vector<bounding_hull_edge> edges;
	std::vector<bounding_hull_face> faces;

	bounding_box aabb;

	static bounding_hull_geometry fromMesh(vec3* vertices, uint32 numVertices, indexed_triangle16* triangles, uint32 numTriangles);
	static bounding_hull_geometry fromMesh(vec3* vertices, uint32 numVertices, indexed_triangle32* triangles, uint32 numTriangles);
};

// MUST be convex.
struct bounding_hull
{
	quat rotation;
	vec3 position;

	union
	{
		uint32 geometryIndex;						// For permanent colliders.
		const bounding_hull_geometry* geometryPtr;	// For world space colliders, which only exist for one frame.
	};
};

struct ray
{
	vec3 origin;
	vec3 direction;

	bool intersectPlane(vec3 normal, float d, float& outT) const;
	bool intersectPlane(vec3 normal, vec3 point, float& outT) const;
	bool intersectAABB(const bounding_box& a, float& outT) const;
	bool intersectOBB(const bounding_oriented_box& a, float& outT) const;
	bool intersectTriangle(vec3 a, vec3 b, vec3 c, float& outT, bool& outFrontFacing) const;
	bool intersectSphere(vec3 center, float radius, float& outT) const;
	bool intersectSphere(const bounding_sphere& sphere, float& outT) const { return intersectSphere(sphere.center, sphere.radius, outT); }
	bool intersectCylinder(const bounding_cylinder& cylinder, float& outT) const;
	bool intersectCapsule(const bounding_capsule& capsule, float& outT) const;
	bool intersectDisk(vec3 pos, vec3 normal, float radius, float& outT) const;
	bool intersectRectangle(vec3 pos, vec3 tangent, vec3 bitangent, vec2 radius, float& outT) const;
	bool intersectTorus(const bounding_torus& torus, float& outT) const;
	bool intersectHull(const bounding_hull& hull, const bounding_hull_geometry& geometry, float& outT) const;
};

bool sphereVsSphere(const bounding_sphere& a, const bounding_sphere& b);
bool sphereVsPlane(const bounding_sphere& s, const vec4& p);
bool sphereVsCapsule(const bounding_sphere& s, const bounding_capsule& c);
bool sphereVsCylinder(const bounding_sphere& s, const bounding_cylinder& c);
bool sphereVsAABB(const bounding_sphere& s, const bounding_box& a);
bool sphereVsOBB(const bounding_sphere& s, const bounding_oriented_box& o);
bool sphereVsHull(const bounding_sphere& s, const bounding_hull& h);
bool sphereVsTriangle(const bounding_sphere& s, vec3 a, vec3 b, vec3 c);

bool capsuleVsCapsule(const bounding_capsule& a, const bounding_capsule& b);
bool capsuleVsCylinder(const bounding_capsule& a, const bounding_cylinder& b);
bool capsuleVsAABB(const bounding_capsule& c, const bounding_box& b);
bool capsuleVsOBB(const bounding_capsule& c, const bounding_oriented_box& o);
bool capsuleVsHull(const bounding_capsule& c, const bounding_hull& h);
bool capsuleVsTriangle(const bounding_capsule& capsule, vec3 a, vec3 b, vec3 c);

bool cylinderVsCylinder(const bounding_cylinder& a, const bounding_cylinder& b);
bool cylinderVsAABB(const bounding_cylinder& c, const bounding_box& b);
bool cylinderVsOBB(const bounding_cylinder& c, const bounding_oriented_box& o);
bool cylinderVsHull(const bounding_cylinder& c, const bounding_hull& h);

bool aabbVsAABB(const bounding_box& a, const bounding_box& b);
bool aabbVsOBB(const bounding_box& a, const bounding_oriented_box& o);
bool aabbVsHull(const bounding_box& a, const bounding_hull& h);
bool aabbVsPlane(const bounding_box& a, vec4 plane);
bool aabbVsTriangle(const bounding_box& aabb, vec3 a, vec3 b, vec3 c);

bool obbVsOBB(const bounding_oriented_box& a, const bounding_oriented_box& b);
bool obbVsHull(const bounding_oriented_box& o, const bounding_hull& h);
bool obbVsPlane(const bounding_oriented_box& a, vec4 plane);
bool obbVsTriangle(const bounding_oriented_box& obb, vec3 a, vec3 b, vec3 c);

bool hullVsHull(const bounding_hull& a, const bounding_hull& b);

vec3 closestPoint_PointSegment(const vec3& q, const line_segment& l);
vec3 closestPoint_PointAABB(const vec3& q, const bounding_box& aabb);
float closestPoint_SegmentSegment(const line_segment& l1, const line_segment& l2, vec3& c1, vec3& c2);
vec3 closestPoint_PointTriangle(const vec3& q, const vec3& a, const vec3& b, const vec3& c);



// Inline functions:

inline float signedDistanceToPlane(const vec3& p, const vec4& plane)
{
	return dot(vec4(p, 1.f), plane);
}

inline bool sphereVsSphere(const bounding_sphere& a, const bounding_sphere& b)
{
	vec3 d = a.center - b.center;
	float dist2 = dot(d, d);
	float radiusSum = a.radius + b.radius;
	return dist2 <= radiusSum * radiusSum;
}

inline bool sphereVsPlane(const bounding_sphere& s, const vec4& p)
{
	return abs(signedDistanceToPlane(s.center, p)) <= s.radius;
}

inline bool sphereVsCapsule(const bounding_sphere& s, const bounding_capsule& c)
{
	vec3 closestPoint = closestPoint_PointSegment(s.center, line_segment{ c.positionA, c.positionB });
	return sphereVsSphere(s, bounding_sphere{ closestPoint, c.radius });
}

inline bool sphereVsAABB(const bounding_sphere& s, const bounding_box& a)
{
	vec3 p = closestPoint_PointAABB(s.center, a);
	vec3 n = p - s.center;
	float sqDistance = squaredLength(n);
	return sqDistance <= s.radius * s.radius;
}

inline bool sphereVsOBB(const bounding_sphere& s, const bounding_oriented_box& o)
{
	bounding_box aabb = bounding_box::fromCenterRadius(o.center, o.radius);
	bounding_sphere s_ = {
		conjugate(o.rotation) * (s.center - o.center) + o.center,
		s.radius };

	return sphereVsAABB(s_, aabb);
}

inline bool capsuleVsCapsule(const bounding_capsule& a, const bounding_capsule& b)
{
	vec3 closestPoint1, closestPoint2;
	closestPoint_SegmentSegment(line_segment{ a.positionA, a.positionB }, line_segment{ b.positionA, b.positionB }, closestPoint1, closestPoint2);
	return sphereVsSphere(bounding_sphere{ closestPoint1, a.radius }, bounding_sphere{ closestPoint2, b.radius });
}

inline bool capsuleVsCylinder(const bounding_capsule& a, const bounding_cylinder& b)
{
	vec3 closestPoint1, closestPoint2;
	closestPoint_SegmentSegment(line_segment{ a.positionA, a.positionB }, line_segment{ b.positionA, b.positionB }, closestPoint1, closestPoint2);
	return sphereVsCylinder(bounding_sphere{ closestPoint1, a.radius }, b);
}

inline bool aabbVsAABB(const bounding_box& a, const bounding_box& b)
{
	if (a.maxCorner.x < b.minCorner.x || a.minCorner.x > b.maxCorner.x) return false;
	if (a.maxCorner.y < b.minCorner.y || a.minCorner.y > b.maxCorner.y) return false;
	if (a.maxCorner.z < b.minCorner.z || a.minCorner.z > b.maxCorner.z) return false;
	return true;
}

inline bool aabbVsOBB(const bounding_box& a, const bounding_oriented_box& o)
{
	return obbVsOBB(bounding_oriented_box{ quat::identity, a.getCenter(), a.getRadius() }, o);
}

inline vec3 closestPoint_PointSegment(const vec3& q, const line_segment& l)
{
	vec3 ab = l.b - l.a;
	float t = dot(q - l.a, ab) / squaredLength(ab);
	t = clamp(t, 0.f, 1.f);
	return l.a + t * ab;
}

inline vec3 closestPoint_PointAABB(const vec3& q, const bounding_box& aabb)
{
	vec3 result;
	for (uint32 i = 0; i < 3; ++i)
	{
		float v = q.data[i];
		if (v < aabb.minCorner.data[i]) v = aabb.minCorner.data[i];
		if (v > aabb.maxCorner.data[i]) v = aabb.maxCorner.data[i];
		result.data[i] = v;
	}
	return result;
}



```

`src/physics/bounding_volumes_simd.h`:

```h
#pragma once

#include "core/math_simd.h"

template <typename simd_t>
struct wN_bounding_sphere
{
	wN_vec3<simd_t> center;
	simd_t radius;
};

template <typename simd_t>
struct wN_bounding_capsule
{
	wN_vec3<simd_t> positionA;
	wN_vec3<simd_t> positionB;
	simd_t radius;
};

template <typename simd_t>
struct wN_bounding_cylinder
{
	wN_vec3<simd_t> positionA;
	wN_vec3<simd_t> positionB;
	simd_t radius;
};

template <typename simd_t>
struct wN_bounding_box
{
	wN_vec3<simd_t> minCorner;
	wN_vec3<simd_t> maxCorner;

	static wN_bounding_box wN_bounding_box::fromMinMax(wN_vec3<simd_t> minCorner, wN_vec3<simd_t> maxCorner)
	{
		return wN_bounding_box{ minCorner, maxCorner };
	}

	static wN_bounding_box wN_bounding_box::fromCenterRadius(wN_vec3<simd_t> center, wN_vec3<simd_t> radius)
	{
		return wN_bounding_box{ center - radius, center + radius };
	}
};

template <typename simd_t>
struct wN_bounding_oriented_box
{
	wN_vec3<simd_t> center;
	wN_vec3<simd_t> radius;
	wN_quat<simd_t> rotation;
};

template <typename simd_t>
struct wN_line_segment
{
	wN_vec3<simd_t> a, b;
};

template <typename simd_t>
inline auto aabbVsAABB(const wN_bounding_box<simd_t>& a, const wN_bounding_box<simd_t>& b)
{
	return
		(a.maxCorner.x >= b.minCorner.x) & (a.minCorner.x <= b.maxCorner.x) &
		(a.maxCorner.y >= b.minCorner.y) & (a.minCorner.y <= b.maxCorner.y) &
		(a.maxCorner.z >= b.minCorner.z) & (a.minCorner.z <= b.maxCorner.z);
}

template <typename simd_t>
inline wN_vec3<simd_t> closestPoint_PointSegment(const wN_vec3<simd_t>& q, const wN_line_segment<simd_t>& l)
{
	wN_vec3<simd_t> ab = l.b - l.a;
	simd_t t = dot(q - l.a, ab) / squaredLength(ab);
	t = clamp01(t);
	return l.a + t * ab;
}

template <typename simd_t>
inline wN_vec3<simd_t> closestPoint_PointAABB(const wN_vec3<simd_t>& q, const wN_bounding_box<simd_t>& aabb)
{
	wN_vec3<simd_t> result;
	for (uint32 i = 0; i < 3; ++i)
	{
		simd_t v = q.data[i];
		v = ifThen(v < aabb.minCorner.data[i], aabb.minCorner.data[i], v);
		v = ifThen(v > aabb.maxCorner.data[i], aabb.maxCorner.data[i], v);
		result.data[i] = v;
	}
	return result;
}

template <typename simd_t>
inline simd_t closestPoint_SegmentSegment(const wN_line_segment<simd_t>& l1, const wN_line_segment<simd_t>& l2, wN_vec3<simd_t>& c1, wN_vec3<simd_t>& c2)
{
	w_vec3 d1 = l1.b - l1.a;
	w_vec3 d2 = l2.b - l2.a;
	w_vec3 r = l1.a - l2.a;
	w_float a = dot(d1, d1);
	w_float e = dot(d2, d2);
	w_float f = dot(d2, r);

	w_float s, t;

	w_float c = dot(d1, r);

	w_float b = dot(d1, d2);
	w_float denom = a * e - b * b;

	s = ifThen(denom != 0.f, clamp01((b * f - c * e) / denom), 0.f);

	t = (b * s + f) / e;

	s = ifThen(t < 0.f, clamp01(-c / a), ifThen(t > 1.f, clamp01((b - c) / a), s));
	t = clamp01(t);


	auto eSmall = e <= EPSILON;
	auto aSmall = a <= EPSILON;

	s = ifThen(eSmall, clamp01(-c / a), s);
	t = ifThen(eSmall, 0.f, t);


	s = ifThen(aSmall, 0.f, s);
	t = ifThen(aSmall, clamp01(f / e), t);


	s = ifThen(aSmall & eSmall, 0.f, s);
	t = ifThen(aSmall & eSmall, 0.f, t);


	c1 = l1.a + d1 * s;
	c2 = l2.a + d2 * t;

	return squaredLength(c1 - c2);
}


```

`src/physics/cloth.cpp`:

```cpp
#include "pch.h"
#include "cloth.h"
#include "physics.h"
#include "core/random.h"
#include "core/cpu_profiling.h"

cloth_component::cloth_component(float width, float height, uint32 gridSizeX, uint32 gridSizeY, float totalMass, float stiffness, float damping, float gravityFactor)
	: gridSizeX(gridSizeX), gridSizeY(gridSizeY), width(width), height(height)
{
	this->gravityFactor = gravityFactor;
	this->damping = damping;
	this->totalMass = totalMass;
	this->stiffness = stiffness;

	uint32 numParticles = gridSizeX * gridSizeY;

	float invMassPerParticle = numParticles / totalMass;

	positions.reserve(numParticles);
	prevPositions.reserve(numParticles);
	invMasses.reserve(numParticles);
	velocities.resize(numParticles, vec3(0.f));
	forceAccumulators.resize(numParticles, vec3(0.f));

	random_number_generator rng = { 1578123 };

	for (uint32 y = 0; y < gridSizeY; ++y)
	{
		float invMass = (y == 0) ? 0.f : invMassPerParticle; // Lock upper row.

		for (uint32 x = 0; x < gridSizeX; ++x)
		{
			float relX = x / (float)(gridSizeX - 1);
			float relY = y / (float)(gridSizeY - 1);
			
			vec3 position = getParticlePosition(relX, relY);
			positions.push_back(position);
			prevPositions.push_back(position);
			invMasses.push_back(invMass);
		}
	}

	for (uint32 y = 0; y < gridSizeY; ++y)
	{
		for (uint32 x = 0; x < gridSizeX; ++x)
		{
			uint32 index = y * gridSizeX + x;

			// Stretch constraints: direct right and bottom neighbor.
			if (x < gridSizeX - 1)
			{
				addConstraint(index, index + 1);
			}
			if (y < gridSizeY - 1)
			{
				addConstraint(index, index + gridSizeX);
			}

			// Shear constraints: direct diagonal neighbor.
			if (x < gridSizeX - 1 && y < gridSizeY - 1)
			{
				addConstraint(index, index + gridSizeX + 1);
				addConstraint(index + gridSizeX, index + 1);
			}

			// Bend constraints: neighbor right and bottom two places away.
			if (x < gridSizeX - 2)
			{
				addConstraint(index, index + 2);
			}
			if (y < gridSizeY - 2)
			{
				addConstraint(index, index + gridSizeX * 2);
			}
		}
	}

	oldTotalMass = totalMass;
	oldStiffness = stiffness;
}

void cloth_component::setWorldPositionOfFixedVertices(const trs& transform, bool moveRigid)
{
	if (moveRigid)
	{
		vec3 pivot;
		if (gridSizeX % 2 == 1)
		{
			pivot = positions[gridSizeX / 2];
		}
		else
		{
			pivot = (positions[gridSizeX / 2] + positions[gridSizeX / 2 - 1]) * 0.5f;
		}

		vec3 currentAxis = normalize(positions[gridSizeX - 1] - positions[0]);
		vec3 newAxis = normalize(transformPosition(transform, getParticlePosition(1.f, 0.f)) - transformPosition(transform, getParticlePosition(0.f, 0.f)));

		vec3 newPivot = transformPosition(transform, getParticlePosition(0.5f, 0.f));

		quat deltaRotation = rotateFromTo(currentAxis, newAxis);
		vec3 deltaTranslation = newPivot - pivot;

		for (uint32 y = 1; y < gridSizeY; ++y)
		{
			for (uint32 x = 0; x < gridSizeX; ++x)
			{
				vec3& position = positions[y * gridSizeX + x];
				position = deltaRotation * (position - pivot) + newPivot;
			}
		}
	}

	// Currently the top row is fixed, so transform this.
	for (uint32 x = 0; x < gridSizeX; ++x)
	{
		float relX = x / (float)(gridSizeX - 1);
		float relY = 0.f;
		vec3 localPosition = getParticlePosition(relX, relY);
		positions[x] = transformPosition(transform, localPosition);
	}
}

vec3 cloth_component::getParticlePosition(float relX, float relY)
{
	vec3 position = vec3(relX * width, -relY * height, 0.f);
	position.x -= width * 0.5f;
	std::swap(position.y, position.z);
	return position;
}

static vec3 calculateNormal(vec3 a, vec3 b, vec3 c)
{
	return cross(b - a, c - a);
}

void cloth_component::applyWindForce(vec3 force)
{
	for (uint32 y = 0; y < gridSizeY - 1; ++y)
	{
		for (uint32 x = 0; x < gridSizeX - 1; ++x)
		{
			uint32 tlIndex = y * gridSizeX + x;
			uint32 trIndex = tlIndex + 1;
			uint32 blIndex = tlIndex + gridSizeX;
			uint32 brIndex = blIndex + 1;

			vec3& tlForce = forceAccumulators[tlIndex];
			vec3& trForce = forceAccumulators[trIndex];
			vec3& blForce = forceAccumulators[blIndex];
			vec3& brForce = forceAccumulators[brIndex];

			{
				vec3 normal = calculateNormal(positions[tlIndex], positions[blIndex], positions[trIndex]);
				vec3 forceInNormalDir = normal * dot(normalize(normal), force);
				forceInNormalDir *= 1.f / 3.f;
				tlForce += forceInNormalDir;
				trForce += forceInNormalDir;
				blForce += forceInNormalDir;
			}

			{
				vec3 normal = calculateNormal(positions[brIndex], positions[trIndex], positions[blIndex]);
				vec3 forceInNormalDir = normal * dot(normalize(normal), force);
				forceInNormalDir *= 1.f / 3.f;
				brForce += forceInNormalDir;
				trForce += forceInNormalDir;
				blForce += forceInNormalDir;
			}
		}
	}
}

struct cloth_constraint_temp
{
	vec3 gradient;
	float inverseScaledGradientSquared;
};

void cloth_component::simulate(uint32 velocityIterations, uint32 positionIterations, uint32 driftIterations, float dt)
{
	CPU_PROFILE_BLOCK("Simulate cloth");

	if (totalMass != oldTotalMass || stiffness != oldStiffness)
	{
		recalculateProperties();

		oldTotalMass = totalMass;
		oldStiffness = stiffness;
	}


	float gravityVelocity = GRAVITY * dt * gravityFactor;
	uint32 numParticles = gridSizeX * gridSizeY;

	for (uint32 i = 0; i < numParticles; ++i)
	{
		vec3& position = positions[i];
		vec3& prevPosition = prevPositions[i];
		float invMass = invMasses[i];
		vec3& velocity = velocities[i];
		vec3& force = forceAccumulators[i];

		if (invMass > 0.f)
		{
			velocity.y += gravityVelocity;
		}

		velocity += force * (invMass * dt);

		prevPosition = position;
		position += velocity * dt;
		force = vec3(0.f);
	}

	float invDt = (dt > 1e-5f) ? (1.f / dt) : 1.f;
	
	// Solve velocities.
	if (velocityIterations > 0)
	{
		std::vector<cloth_constraint_temp> constraintsTemp;
		constraintsTemp.reserve(constraints.size());

		for (cloth_constraint& c : constraints)
		{
			vec3 prevPositionA = prevPositions[c.a];
			vec3 prevPositionB = prevPositions[c.b];

			cloth_constraint_temp temp;
			temp.gradient = prevPositionB - prevPositionA;
			temp.inverseScaledGradientSquared = (c.inverseMassSum == 0.f) ? 0.f : (1.f / (squaredLength(temp.gradient) * c.inverseMassSum));
			constraintsTemp.push_back(temp);
		}


		for (uint32 it = 0; it < velocityIterations; ++it)
		{
			solveVelocities(constraintsTemp);
		}

		for (uint32 i = 0; i < numParticles; ++i)
		{
			positions[i] = prevPositions[i] + velocities[i] * dt;
		}
	}

	// Solve positions.
	if (positionIterations > 0)
	{
		for (uint32 it = 0; it < positionIterations; ++it)
		{
			solvePositions();
		}

		for (uint32 i = 0; i < numParticles; ++i)
		{
			velocities[i] = (positions[i] - prevPositions[i]) * invDt;
		}
	}

	// Solve drift.
	if (driftIterations > 0)
	{
		for (uint32 i = 0; i < numParticles; ++i)
		{
			prevPositions[i] = positions[i];
		}

		for (uint32 it = 0; it < driftIterations; ++it)
		{
			solvePositions();
		}

		for (uint32 i = 0; i < numParticles; ++i)
		{
			velocities[i] += (positions[i] - prevPositions[i]) * invDt;
		}
	}

	// Damping.
	float dampingFactor = 1.f / (1.f + dt * damping);
	for (uint32 i = 0; i < numParticles; ++i)
	{
		velocities[i] *= dampingFactor;
	}
}

void cloth_component::solveVelocities(const std::vector<cloth_constraint_temp>& constraintsTemp)
{
	for (uint32 i = 0; i < (uint32)constraints.size(); ++i)
	{
		cloth_constraint& c = constraints[i];
		const cloth_constraint_temp& temp = constraintsTemp[i];
		float j = -dot(temp.gradient, velocities[c.a] - velocities[c.b]) * temp.inverseScaledGradientSquared;
		velocities[c.a] += temp.gradient * (j * invMasses[c.a]);
		velocities[c.b] -= temp.gradient * (j * invMasses[c.b]);
	}
}

void cloth_component::solvePositions()
{
	for (cloth_constraint& c : constraints)
	{
		if (c.inverseMassSum > 0.f)
		{
			vec3 delta = positions[c.b] - positions[c.a];
			float len = squaredLength(delta);

			float sqRestDistance = c.restDistance * c.restDistance;
			if (sqRestDistance + len > 1e-5f)
			{
				float k = ((sqRestDistance - len) / (c.inverseMassSum * (sqRestDistance + len)));
				positions[c.a] -= delta * (k * invMasses[c.a]);
				positions[c.b] += delta * (k * invMasses[c.b]);
			}
		}
	}
}

void cloth_component::addConstraint(uint32 indexA, uint32 indexB)
{
	constraints.push_back(cloth_constraint
		{ 
			indexA, 
			indexB, 
			length(positions[indexA] - positions[indexB]),
			(invMasses[indexA] + invMasses[indexB]) / stiffness,
		});
}

void cloth_component::recalculateProperties()
{
	uint32 numParticles = gridSizeX * gridSizeY;
	float invMassPerParticle = numParticles / totalMass;
	for (float& invMass : invMasses)
	{
		invMass = (invMass != 0.f) ? invMassPerParticle : 0.f;
	}

	stiffness = clamp(stiffness, 0.01f, 1.f);
	float invStiffness = 1.f / stiffness;
	for (cloth_constraint& c : constraints)
	{
		c.inverseMassSum = (invMasses[c.a] + invMasses[c.b]) * invStiffness;
	}
}





#ifndef PHYSICS_ONLY
#include "animation/skinning.h"

std::tuple<dx_vertex_buffer_group_view, dx_vertex_buffer_group_view, dx_index_buffer_view, submesh_info> cloth_render_component::getRenderData(const cloth_component& cloth)
{
	CPU_PROFILE_BLOCK("Get cloth render data");

	uint32 numVertices = cloth.gridSizeX * cloth.gridSizeY;
	uint32 numTriangles = (cloth.gridSizeX - 1) * (cloth.gridSizeY - 1) * 2;

	auto [positionVertexBuffer, positionPtr] = dxContext.createDynamicVertexBuffer(sizeof(vec3), numVertices);
	memcpy(positionPtr, cloth.positions.data(), numVertices * sizeof(vec3));

	dx_vertex_buffer_group_view vb = skinCloth(positionVertexBuffer, cloth.gridSizeX, cloth.gridSizeY);
	submesh_info sm;
	sm.baseVertex = 0;
	sm.firstIndex = 0;
	sm.numIndices = numTriangles * 3;
	sm.numVertices = numVertices;

	dx_vertex_buffer_group_view prev = prevFrameVB;
	prevFrameVB = vb;



	if (!indexBuffer)
	{
		std::vector<indexed_triangle16> triangles;
		triangles.reserve(numTriangles);
		for (uint32 y = 0; y < cloth.gridSizeY - 1; ++y)
		{
			for (uint32 x = 0; x < cloth.gridSizeX - 1; ++x)
			{
				uint16 tlIndex = y * cloth.gridSizeX + x;
				uint16 trIndex = tlIndex + 1;
				uint16 blIndex = tlIndex + cloth.gridSizeX;
				uint16 brIndex = blIndex + 1;

				triangles.push_back({ tlIndex, blIndex, brIndex });
				triangles.push_back({ tlIndex, brIndex, trIndex });
			}
		}

		indexBuffer = createIndexBuffer(sizeof(uint16), (uint32)triangles.size() * 3, triangles.data());
	}


	return { vb, prev, indexBuffer, sm };
}

#endif


```

`src/physics/cloth.h`:

```h
#pragma once

#include "bounding_volumes.h"

struct cloth_component
{
	cloth_component() {}
	cloth_component(float width, float height, uint32 gridSizeX, uint32 gridSizeY, 
		float totalMass, float stiffness = 0.5f, float damping = 0.3f, float gravityFactor = 1.f);
	cloth_component(const cloth_component&) = default;
	cloth_component(cloth_component&&) = default;

	cloth_component& operator=(const cloth_component&) = default;
	cloth_component& operator=(cloth_component&&) = default;

	void setWorldPositionOfFixedVertices(const trs& transform, bool moveRigid = false);
	void applyWindForce(vec3 force);
	void simulate(uint32 velocityIterations, uint32 positionIterations, uint32 driftIterations, float dt);

	float totalMass;
	float gravityFactor;
	float damping;
	float stiffness;

	uint32 gridSizeX, gridSizeY;
	float width, height;

private:
	float oldTotalMass;
	float oldStiffness;

	void recalculateProperties();

	struct cloth_constraint
	{
		uint32 a, b;
		float restDistance;
		float inverseMassSum;
	};

	std::vector<vec3> positions;
	std::vector<vec3> prevPositions;
	std::vector<vec3> velocities;
	std::vector<vec3> forceAccumulators;
	std::vector<float> invMasses;
	std::vector<cloth_constraint> constraints;

	void solveVelocities(const std::vector<struct cloth_constraint_temp>& constraintsTemp);
	void solvePositions();

	vec3 getParticlePosition(float relX, float relY);

	void addConstraint(uint32 a, uint32 b);

	friend struct cloth_render_component;
};


#ifndef PHYSICS_ONLY

#include "geometry/mesh_builder.h"
#include "dx/dx_buffer.h"
#include "dx/dx_context.h"

struct cloth_render_component
{
	std::tuple<dx_vertex_buffer_group_view, dx_vertex_buffer_group_view, dx_index_buffer_view, submesh_info> getRenderData(const cloth_component& cloth);

	ref<dx_index_buffer> indexBuffer;
	dx_vertex_buffer_group_view prevFrameVB;
};
#endif

```

`src/physics/collision_broad.cpp`:

```cpp
#include "pch.h"
#include "collision_broad.h"
#include "scene/scene.h"
#include "physics.h"
#include "core/cpu_profiling.h"

#include "bounding_volumes_simd.h"

struct sap_endpoint
{
	float value;
	entity_handle entity = entt::null;
	bool start;
	uint16 colliderIndex; // Set each frame.

	sap_endpoint(entity_handle entity, bool start) : entity(entity), start(start) { }
	sap_endpoint(const sap_endpoint&) = default;
};

struct sap_context
{
	std::vector<sap_endpoint> endpoints;
	uint32 sortingAxis = 0;
};


void addColliderToBroadphase(scene_entity entity)
{
	sap_context& context = createOrGetContextVariable<sap_context>(*entity.registry);

	sap_endpoint_indirection_component endpointIndirection;

	endpointIndirection.startEndpoint = (uint16)context.endpoints.size();
	context.endpoints.emplace_back(entity.handle, true);

	endpointIndirection.endEndpoint = (uint16)context.endpoints.size();
	context.endpoints.emplace_back(entity.handle, false);

	entity.addComponent<sap_endpoint_indirection_component>(endpointIndirection);
}

static void removeEndpoint(uint16 endpointIndex, entt::registry& registry, sap_context& context)
{
	sap_endpoint last = context.endpoints.back();
	context.endpoints[endpointIndex] = last;

	// Point moved entity to correct slot.
	sap_endpoint_indirection_component& in = registry.get<sap_endpoint_indirection_component>(last.entity);
		
	if (last.start) 
	{ 
		in.startEndpoint = endpointIndex; 
	}
	else 
	{ 
		in.endEndpoint = endpointIndex; 
	}

	context.endpoints.pop_back();
}

void removeColliderFromBroadphase(scene_entity entity)
{
	sap_endpoint_indirection_component& endpointIndirection = entity.getComponent<sap_endpoint_indirection_component>();

	sap_context& context = getContextVariable<sap_context>(*entity.registry);

	removeEndpoint(endpointIndirection.startEndpoint, *entity.registry, context);
	removeEndpoint(endpointIndirection.endEndpoint, *entity.registry, context);

	if (entity.hasComponent<sap_endpoint_indirection_component>())
	{
		entity.removeComponent<sap_endpoint_indirection_component>();
	}
}

void clearBroadphase(game_scene& scene)
{
	auto c = scene.registry.ctx();
	if (sap_context* context = c.find<sap_context>())
	{
		context->endpoints.clear();
		context->sortingAxis = 0;
	}
}

static uint32 determineOverlapsScalar(const sap_endpoint* endpoints, uint32 numEndpoints, const bounding_box* worldSpaceAABBs, uint32 numColliders, memory_arena& arena,
	collider_pair* outCollisions)
{
	CPU_PROFILE_BLOCK("Determine overlaps");

	uint32 numCollisions = 0;

#define CACHE_AABBS 1


	uint32 activeListCapacity = numColliders; // Conservative estimate.

	uint32 numActive = 0;
	uint16* activeList = arena.allocate<uint16>(activeListCapacity);

#if CACHE_AABBS
	bounding_box* activeBBs = arena.allocate<bounding_box>(activeListCapacity);
#endif

	uint16* positionInActiveList = arena.allocate<uint16>(numColliders);

	uint32 maxNumActive = 0;

	for (uint32 i = 0; i < numEndpoints; ++i)
	{
		sap_endpoint ep = endpoints[i];
		if (ep.start)
		{
			const bounding_box& a = worldSpaceAABBs[ep.colliderIndex];

			for (uint32 active = 0; active < numActive; ++active)
			{
#if CACHE_AABBS
				const bounding_box& b = activeBBs[active];
#else
				const bounding_box& b = worldSpaceAABBs[activeList[active]];
#endif

				if (aabbVsAABB(a, b))
				{
					outCollisions[numCollisions++] = { ep.colliderIndex, activeList[active] };
				}
			}

			ASSERT(ep.colliderIndex < numColliders);
			positionInActiveList[ep.colliderIndex] = numActive;

#if CACHE_AABBS
			activeBBs[numActive] = worldSpaceAABBs[ep.colliderIndex];
#endif

			activeList[numActive++] = ep.colliderIndex;

			maxNumActive = max(maxNumActive, numActive);
		}
		else
		{
			uint16 pos = positionInActiveList[ep.colliderIndex];

			--numActive;

			uint16 lastColliderInActiveList = activeList[numActive];
			positionInActiveList[lastColliderInActiveList] = pos;

			activeList[pos] = activeList[numActive];

#if CACHE_AABBS
			activeBBs[pos] = activeBBs[numActive];
#endif
		}
	}

	ASSERT(numActive == 0);

	CPU_PROFILE_STAT("Max num active in SAP", maxNumActive);

	return numCollisions;

#undef CACHE_AABBS
}

static uint32 determineOverlapsSIMD(const sap_endpoint* endpoints, uint32 numEndpoints, const bounding_box* worldSpaceAABBs, uint32 numColliders, memory_arena& arena,
	collider_pair* outCollisions)
{
	CPU_PROFILE_BLOCK("Determine overlaps SIMD");

#define COLLISION_SIMD_WIDTH 8u

#if COLLISION_SIMD_WIDTH == 4
	typedef w4_float w_float;
	typedef w4_int w_int;
#elif COLLISION_SIMD_WIDTH == 8 && defined(SIMD_AVX_2)
	typedef w8_float w_float;
	typedef w8_int w_int;
#endif

	typedef wN_vec2<w_float> w_vec2;
	typedef wN_vec3<w_float> w_vec3;
	typedef wN_vec4<w_float> w_vec4;
	typedef wN_quat<w_float> w_quat;
	typedef wN_mat2<w_float> w_mat2;
	typedef wN_mat3<w_float> w_mat3;

	typedef wN_bounding_box<w_float> w_bounding_box;

	struct soa_bounding_box
	{
		float minX[COLLISION_SIMD_WIDTH];
		float minY[COLLISION_SIMD_WIDTH];
		float minZ[COLLISION_SIMD_WIDTH];
		float maxX[COLLISION_SIMD_WIDTH];
		float maxY[COLLISION_SIMD_WIDTH];
		float maxZ[COLLISION_SIMD_WIDTH];
	};

	uint32 numCollisions = 0;


	uint32 activeListCapacity = alignTo(numColliders, COLLISION_SIMD_WIDTH); // Conservative estimate.

	uint32 numActive = 0;
	uint16* activeList = arena.allocate<uint16>(activeListCapacity);

	soa_bounding_box* activeBBs = arena.allocate<soa_bounding_box>(activeListCapacity / COLLISION_SIMD_WIDTH);

	uint16* positionInActiveList = arena.allocate<uint16>(numColliders);

	uint32 maxNumActive = 0;

	for (uint32 i = 0; i < numEndpoints; ++i)
	{
		sap_endpoint ep = endpoints[i];
		if (ep.start)
		{
			const bounding_box& a = worldSpaceAABBs[ep.colliderIndex];

			w_bounding_box wA = { w_vec3(a.minCorner.x, a.minCorner.y, a.minCorner.z), w_vec3(a.maxCorner.x, a.maxCorner.y, a.maxCorner.z) };
			uint32 count = bucketize(numActive, COLLISION_SIMD_WIDTH);

			for (uint32 active = 0; active < count; ++active)
			{
				const soa_bounding_box& soaBB = activeBBs[active];
				const w_bounding_box& wB = { w_vec3(soaBB.minX, soaBB.minY, soaBB.minZ), w_vec3(soaBB.maxX, soaBB.maxY, soaBB.maxZ) };

				uint32 numValidLanes = clamp(numActive - active * COLLISION_SIMD_WIDTH, 0u, COLLISION_SIMD_WIDTH);
				uint32 validLanesMask = (1 << numValidLanes) - 1;

				auto overlap = aabbVsAABB(wA, wB);
				int32 mask = toBitMask(overlap) & validLanesMask;

				for (uint32 k = 0; k < COLLISION_SIMD_WIDTH; ++k)
				{
					if (mask & (1 << k))
					{
						outCollisions[numCollisions++] = { ep.colliderIndex, activeList[active * COLLISION_SIMD_WIDTH + k] };
					}
				}
			}

			ASSERT(ep.colliderIndex < numColliders);
			positionInActiveList[ep.colliderIndex] = numActive;

			soa_bounding_box& outBB = activeBBs[numActive / COLLISION_SIMD_WIDTH];
			uint32 outBBSlot = numActive % COLLISION_SIMD_WIDTH;
			outBB.minX[outBBSlot] = a.minCorner.x;
			outBB.minY[outBBSlot] = a.minCorner.y;
			outBB.minZ[outBBSlot] = a.minCorner.z;
			outBB.maxX[outBBSlot] = a.maxCorner.x;
			outBB.maxY[outBBSlot] = a.maxCorner.y;
			outBB.maxZ[outBBSlot] = a.maxCorner.z;


			activeList[numActive++] = ep.colliderIndex;

			maxNumActive = max(maxNumActive, numActive);
		}
		else
		{
			uint16 pos = positionInActiveList[ep.colliderIndex];

			--numActive;

			uint16 lastColliderInActiveList = activeList[numActive];
			positionInActiveList[lastColliderInActiveList] = pos;

			activeList[pos] = activeList[numActive];

			soa_bounding_box& outBB = activeBBs[pos / COLLISION_SIMD_WIDTH];
			uint32 outBBSlot = pos % COLLISION_SIMD_WIDTH;
			const soa_bounding_box& fromBB = activeBBs[numActive / COLLISION_SIMD_WIDTH];
			uint32 fromBBSlot = numActive % COLLISION_SIMD_WIDTH;

			outBB.minX[outBBSlot] = fromBB.minX[fromBBSlot];
			outBB.minY[outBBSlot] = fromBB.minY[fromBBSlot];
			outBB.minZ[outBBSlot] = fromBB.minZ[fromBBSlot];
			outBB.maxX[outBBSlot] = fromBB.maxX[fromBBSlot];
			outBB.maxY[outBBSlot] = fromBB.maxY[fromBBSlot];
			outBB.maxZ[outBBSlot] = fromBB.maxZ[fromBBSlot];
		}
	}

	ASSERT(numActive == 0);

	CPU_PROFILE_STAT("Max num active in SAP", maxNumActive);

	return numCollisions;

#undef COLLISION_SIMD_WIDTH
}

uint32 broadphase(game_scene& scene, bounding_box* worldSpaceAABBs, memory_arena& arena, collider_pair* outCollisions, bool simd)
{
	CPU_PROFILE_BLOCK("Broad phase");

	uint32 numColliders = scene.numberOfComponentsOfType<collider_component>();
	if (numColliders == 0)
	{
		return 0;
	}

	sap_context& context = scene.getContextVariable<sap_context>();
	auto& endpoints = context.endpoints;

	uint32 numEndpoints = numColliders * 2;

	ASSERT(numEndpoints == endpoints.size());

	uint32 numCollisions = 0;

#if 0
	// Disable broadphase.

	uint16 collider0Index = 0;
	for (auto [entityHandle0, collider0] : scene.view<collider_component>().each())
	{
		uint16 collider1Index = 0;
		for (auto [entityHandle1, collider1] : scene.view<collider_component>().each())
		{
			if (entityHandle0 == entityHandle1)
			{
				break;
			}
			if (collider0.parentEntity != collider1.parentEntity)
			{
				outCollisions[numCollisions++] = { collider0Index, collider1Index };
			}

			++collider1Index;
		}
		++collider0Index;
	}
	return numCollisions;

#endif

	vec3 s(0.f, 0.f, 0.f);
	vec3 s2(0.f, 0.f, 0.f);

	uint32 sortingAxis = context.sortingAxis;

	CPU_PROFILE_STAT("Broadphase sorting axis", sortingAxis);

	{
		CPU_PROFILE_BLOCK("Update endpoints");

		// Index of each collider in the scene. 
		// We iterate over the endpoint indirections, which are sorted the exact same way as the colliders.
		uint16 index = 0;

		for (auto [entityHandle, indirection] : scene.view<sap_endpoint_indirection_component>().each())
		{
			const bounding_box& aabb = worldSpaceAABBs[index];

			uint16 start = indirection.startEndpoint;
			uint16 end = indirection.endEndpoint;

			float lo = aabb.minCorner.data[sortingAxis];
			float hi = aabb.maxCorner.data[sortingAxis];
			endpoints[start].value = lo;
			endpoints[end].value = hi;

			endpoints[start].colliderIndex = index;
			endpoints[end].colliderIndex = index;

			ASSERT(endpoints[start].entity == entityHandle);
			ASSERT(endpoints[end].entity == entityHandle);

			vec3 center = aabb.getCenter();
			s += center;
			s2 += center * center;

			++index;
		}
	}

	{
		CPU_PROFILE_BLOCK("Sort endpoints");

#if 1
		// Insertion sort.
		for (uint32 i = 1; i < numEndpoints; ++i)
		{
			sap_endpoint key = endpoints[i];
			uint32 j = i - 1;

			while (j != UINT32_MAX && endpoints[j].value > key.value)
			{
				endpoints[j + 1] = endpoints[j];
				j = j - 1;
			}
			endpoints[j + 1] = key;
		}
#else
		std::sort(endpoints, endpoints + numEndpoints, [](sap_endpoint a, sap_endpoint b) { return a.value < b.value; });
#endif
	}


	memory_marker marker = arena.getMarker();


	if (simd)
	{
		numCollisions = determineOverlapsSIMD(endpoints.data(), numEndpoints, worldSpaceAABBs, numColliders, arena, outCollisions);
	}
	else
	{
		numCollisions = determineOverlapsScalar(endpoints.data(), numEndpoints, worldSpaceAABBs, numColliders, arena, outCollisions);
	}

	
	arena.resetToMarker(marker);


	// Fix up indirections.
	{
		CPU_PROFILE_BLOCK("Fix up indirections");

		for (uint32 i = 0; i < numEndpoints; ++i)
		{
			sap_endpoint ep = endpoints[i];
			scene_entity entity = { ep.entity, scene };
			sap_endpoint_indirection_component& in = entity.getComponent<sap_endpoint_indirection_component>();

			if (ep.start)
			{
				in.startEndpoint = i;
			}
			else
			{
				in.endEndpoint = i;
			}
		}
	}


	vec3 variance = s2 - s * s / (float)numColliders;
	context.sortingAxis = (variance.x > variance.y) ? ((variance.x > variance.z) ? 0 : 2) : ((variance.y > variance.z) ? 1 : 2);

	return numCollisions;
}

```

`src/physics/collision_broad.h`:

```h
#pragma once

#include "bounding_volumes.h"
#include "scene/scene.h"
#include "core/memory.h"


struct collider_pair
{
	// Indices of the colliders in the scene.
	uint16 colliderA;
	uint16 colliderB;
};

uint32 broadphase(struct game_scene& scene, bounding_box* worldSpaceAABBs, memory_arena& arena, collider_pair* outOverlaps, bool simd);






// Internal.
struct sap_endpoint_indirection_component
{
	uint16 startEndpoint;
	uint16 endEndpoint;
};

```

`src/physics/collision_epa.cpp`:

```cpp
#include "pch.h"
#include "collision_epa.h"


epa_triangle_info epa_simplex::getTriangleInfo(const gjk_support_point& a, const gjk_support_point& b, const gjk_support_point& c)
{
	epa_triangle_info result;
	result.normal = normalize(cross(b.minkowski - a.minkowski, c.minkowski - a.minkowski));
	result.distanceToOrigin = dot(result.normal, a.minkowski);
	return result;
}

bool epa_simplex::isTriangleActive(uint32 index)
{
	uint32 wordIndex = index / 32;
	uint32 bitIndex = index % 32;

	return (activeTrianglesMask[wordIndex] & (1 << bitIndex)) != 0;
}

void epa_simplex::setTriangleActive(uint32 index)
{
	ASSERT(!isTriangleActive(index));

	uint32 wordIndex = index / 32;
	uint32 bitIndex = index % 32;

	activeTrianglesMask[wordIndex] |= (1 << bitIndex);
}

void epa_simplex::setTriangleInactive(uint32 index)
{
	ASSERT(isTriangleActive(index));

	uint32 wordIndex = index / 32;
	uint32 bitIndex = index % 32;

	activeTrianglesMask[wordIndex] &= ~(1 << bitIndex);
}

uint16 epa_simplex::pushPoint(const gjk_support_point& a)
{
	if (numPoints >= arraysize(points))
	{
		return UINT16_MAX;
	}

	uint16 index = numPoints++;
	points[index] = a;
	return index;
}

uint16 epa_simplex::pushTriangle(uint16 a, uint16 b, uint16 c, uint16 edgeOppositeA, uint16 edgeOppositeB, uint16 edgeOppositeC, epa_triangle_info info)
{
	if (numTriangles >= arraysize(triangles))
	{
		return UINT16_MAX;
	}

	uint16 index = numTriangles++;
	setTriangleActive(index);

	epa_triangle& tri = triangles[index];
	tri.a = a;
	tri.b = b;
	tri.c = c;
	tri.edgeOppositeA = edgeOppositeA;
	tri.edgeOppositeB = edgeOppositeB;
	tri.edgeOppositeC = edgeOppositeC;
	tri.normal = info.normal;
	tri.distanceToOrigin = info.distanceToOrigin;
		
	return index;
}

uint16 epa_simplex::pushEdge(uint16 a, uint16 b, uint16 triangleA, uint16 triangleB)
{
	if (numEdges >= arraysize(edges))
	{
		return UINT16_MAX;
	}

	uint16 index = numEdges++;
	epa_edge& edge = edges[index];
	edge.a = a;
	edge.b = b;
	edge.triangleA = triangleA;
	edge.triangleB = triangleB;
	return index;
}

uint32 epa_simplex::findTriangleClosestToOrigin()
{
	uint32 closest = -1;
	float minDistance = FLT_MAX;
	for (uint32 i = 0; i < numTriangles; ++i)
	{
		if (isTriangleActive(i))
		{
			epa_triangle& tri = triangles[i];
			if (tri.distanceToOrigin < minDistance)
			{
				minDistance = tri.distanceToOrigin;
				closest = i;
			}
		}
	}

	ASSERT(closest != -1);

	return closest;
}

bool epa_simplex::addNewPointAndUpdate(const gjk_support_point& newPoint)
{
	// This function removes all triangles which point towards the new point and replaces them with a triangle fan connecting the new point to the simplex.

	uint8 edgeReferences[arraysize(edges)] = { 0 };

	for (uint32 i = 0; i < numTriangles; ++i)
	{
		if (isTriangleActive(i))
		{
			epa_triangle& tri = triangles[i];
			float d = dot(tri.normal, newPoint.minkowski - points[tri.a].minkowski);
			if (d > 0.f)
			{
				// Remove triangle and mark edges.
#define REFERENCE_EDGE(e) ASSERT(e < numEdges); ++edgeReferences[e];

				REFERENCE_EDGE(tri.edgeOppositeA);
				REFERENCE_EDGE(tri.edgeOppositeB);
				REFERENCE_EDGE(tri.edgeOppositeC);

				setTriangleInactive(i);
#undef REFERENCE_EDGE
			}
		}
	}

	uint16 borderEdgeIndices[128];
	uint32 numBorderEdges = 0;

	for (uint32 i = 0; i < numEdges; ++i)
	{
		ASSERT(edgeReferences[i] <= 2);

		if (edgeReferences[i] == 1)
		{
			if (numBorderEdges >= arraysize(borderEdgeIndices))
			{
				return false;
			}
			borderEdgeIndices[numBorderEdges++] = i;
		}
	}

	ASSERT(numBorderEdges > 0);

	uint16 newEdgePerPoint[arraysize(points)];

	uint16 newPointIndex = pushPoint(newPoint);
	if (newPointIndex == UINT16_MAX)
	{
		return false;
	}

	uint16 triangleOffset = numTriangles;

	for (uint32 i = 0; i < numBorderEdges; ++i)
	{
		// Add a triangle for each border edge connecting it to the new point.

		uint16 edgeIndex = borderEdgeIndices[i];
		epa_edge& edge = edges[edgeIndex];

		bool triAActive = isTriangleActive(edge.triangleA);
		bool triBActive = isTriangleActive(edge.triangleB);
		ASSERT(triAActive != triBActive);

		uint16 pointToConnect = triBActive ? edge.a : edge.b;

		uint16 triangleIndex = numTriangles;

		// Push edge from border edge start to new point. The other edge will be added later, which is why we set its index to -1 here temporarily.
		uint16 newEdgeIndex = pushEdge(pointToConnect, newPointIndex, -1, numTriangles);
		if (newEdgeIndex == UINT16_MAX)
		{
			return false;
		}
		newEdgePerPoint[pointToConnect] = newEdgeIndex;


		uint16 bIndex = pointToConnect;
		uint16 cIndex = triBActive ? edge.b : edge.a;

		const gjk_support_point& b = points[bIndex];
		const gjk_support_point& c = points[cIndex];

		// Index of edge opposite B is again -1.
		uint16 triangleIndexTest = pushTriangle(newPointIndex, bIndex, cIndex, edgeIndex, -1, newEdgeIndex, getTriangleInfo(newPoint, b, c));
		if (triangleIndexTest == UINT16_MAX)
		{
			return false;
		}
		ASSERT(triangleIndex == triangleIndexTest);

		// Set edge's new neighbor triangle.
		uint16& edgeInactiveTriangle = triAActive ? edge.triangleB : edge.triangleA;
		edgeInactiveTriangle = triangleIndex;
	}

	// Fix up missing indices.
	for (uint32 i = 0; i < numBorderEdges; ++i)
	{
		uint16 edgeIndex = borderEdgeIndices[i];
		epa_edge& edge = edges[edgeIndex];

		bool triangleANew = edge.triangleA >= triangleOffset;
		bool triangleBNew = edge.triangleB >= triangleOffset;
		ASSERT(triangleANew != triangleBNew);

		uint16 pointToConnect = triangleBNew ? edge.a : edge.b; // Other way around than above. This is the point which was connected by another loop iteration above.

		uint16 otherEdgeIndex = newEdgePerPoint[pointToConnect];
		epa_edge& otherEdge = edges[otherEdgeIndex];

		uint16 triangleIndex = i + triangleOffset;
		epa_triangle& tri = triangles[triangleIndex];

		ASSERT(tri.edgeOppositeB == UINT16_MAX);
		ASSERT(otherEdge.triangleA == UINT16_MAX);

		tri.edgeOppositeB = otherEdgeIndex;
		otherEdge.triangleA = triangleIndex;
	}

	return true;
}


```

`src/physics/collision_epa.h`:

```h
#pragma once

#include "collision_gjk.h"

struct epa_triangle
{
	uint16 a;
	uint16 b;
	uint16 c;

	uint16 edgeOppositeA;
	uint16 edgeOppositeB;
	uint16 edgeOppositeC;

	vec3 normal;
	float distanceToOrigin;
};

struct epa_edge
{
	// Edge points from a to b.
	// The triangles are sorted such that triangleA is on the "left" and triangleB is on the "right", seen from the outside of the simplex.

	uint16 a;
	uint16 b;

	union
	{
		struct
		{
			uint16 triangleA;
			uint16 triangleB;
		};
		uint16 triangles[2];
	};
};

struct epa_triangle_info
{
	vec3 normal;
	float distanceToOrigin;
};


struct epa_simplex
{
	// TODO: Find better array sizes.
	gjk_support_point points[1024];
	epa_triangle triangles[1024];
	epa_edge edges[1024];

	uint32 activeTrianglesMask[1024 / 32];
	uint16 numTriangles;
	uint16 numPoints;
	uint16 numEdges;

	bool isTriangleActive(uint32 index);
	void setTriangleActive(uint32 index);
	void setTriangleInactive(uint32 index);
	uint16 pushPoint(const gjk_support_point& a);
	uint16 pushTriangle(uint16 a, uint16 b, uint16 c, uint16 edgeOppositeA, uint16 edgeOppositeB, uint16 edgeOppositeC, epa_triangle_info info);
	uint16 pushEdge(uint16 a, uint16 b, uint16 triangleA, uint16 triangleB);
	uint32 findTriangleClosestToOrigin();
	bool addNewPointAndUpdate(const gjk_support_point& newPoint);

	static epa_triangle_info getTriangleInfo(const gjk_support_point& a, const gjk_support_point& b, const gjk_support_point& c);
};



struct epa_result
{
	vec3 point;
	vec3 normal;
	float penetrationDepth;
};

enum epa_status
{
	epa_none, // Not returned from EPA. Only for debug output (signals that function was not called).
	epa_success,
	epa_out_of_memory,
	epa_max_num_iterations_reached,
};

static const char* epaReturnNames[] =
{
	"None",
	"Success",
	"Out of memory",
	"Max num iterations reached",
};

// Regardless of the return type, this function always returns the best approximation of the collision info in outResult.
// The caller can decide whether to use the result or not.
template <typename shapeA_t, typename shapeB_t>
static epa_status epaCollisionInfo(const gjk_simplex& gjkSimplex, const shapeA_t& shapeA, const shapeB_t& shapeB, epa_result& outResult, uint32 maxNumIterations = 20)
{
	// http://www.dyn4j.org/2010/05/epa-expanding-polytope-algorithm/
	// http://uu.diva-portal.org/smash/get/diva2:343820/FULLTEXT01 page 23+

	ASSERT(gjkSimplex.numPoints == 4);

	epa_simplex epaSimplex;
	epaSimplex.numTriangles = 0;
	epaSimplex.numPoints = 0;
	epaSimplex.numEdges = 0;
	memset(epaSimplex.activeTrianglesMask, 0, sizeof(epaSimplex.activeTrianglesMask));

	epaSimplex.pushPoint(gjkSimplex.a);
	epaSimplex.pushPoint(gjkSimplex.b);
	epaSimplex.pushPoint(gjkSimplex.c);
	epaSimplex.pushPoint(gjkSimplex.d);

	epaSimplex.pushTriangle(0, 1, 3, 4, 3, 0, epa_simplex::getTriangleInfo(gjkSimplex.a, gjkSimplex.b, gjkSimplex.d));
	epaSimplex.pushTriangle(1, 2, 3, 5, 4, 1, epa_simplex::getTriangleInfo(gjkSimplex.b, gjkSimplex.c, gjkSimplex.d));
	epaSimplex.pushTriangle(2, 0, 3, 3, 5, 2, epa_simplex::getTriangleInfo(gjkSimplex.c, gjkSimplex.a, gjkSimplex.d));
	epaSimplex.pushTriangle(0, 2, 1, 1, 0, 2, epa_simplex::getTriangleInfo(gjkSimplex.a, gjkSimplex.c, gjkSimplex.b));

	epaSimplex.pushEdge(0, 1, 0, 3);
	epaSimplex.pushEdge(1, 2, 1, 3);
	epaSimplex.pushEdge(2, 0, 2, 3);
	epaSimplex.pushEdge(0, 3, 2, 0);
	epaSimplex.pushEdge(1, 3, 0, 1);
	epaSimplex.pushEdge(2, 3, 1, 2);

	uint32 closestIndex = 0;

	epa_status returnCode = epa_max_num_iterations_reached;

	for (uint32 iteration = 0; iteration < maxNumIterations; ++iteration)
	{
		closestIndex = epaSimplex.findTriangleClosestToOrigin();
		epa_triangle& tri = epaSimplex.triangles[closestIndex];

		gjk_support_point a = support(shapeA, shapeB, tri.normal);

		float d = dot(a.minkowski, tri.normal);
		if (d - tri.distanceToOrigin < 0.01f)
		{
			// Success.
			returnCode = epa_success;
			break;
		}

		if (!epaSimplex.addNewPointAndUpdate(a))
		{
			//std::cout << "EPA out of memory.\n";
			returnCode = epa_out_of_memory;
			break;
		}
	}

	epa_triangle& tri = epaSimplex.triangles[closestIndex];

	gjk_support_point& a = epaSimplex.points[tri.a];
	gjk_support_point& b = epaSimplex.points[tri.b];
	gjk_support_point& c = epaSimplex.points[tri.c];

	vec3 barycentricCoords = getBarycentricCoordinates(a.minkowski, b.minkowski, c.minkowski, tri.normal * tri.distanceToOrigin);
	vec3 pointA = barycentricCoords.x * a.shapeAPoint + barycentricCoords.y * b.shapeAPoint + barycentricCoords.z * c.shapeAPoint;
	vec3 pointB = barycentricCoords.x * a.shapeBPoint + barycentricCoords.y * b.shapeBPoint + barycentricCoords.z * c.shapeBPoint;

	outResult.point = 0.5f * (pointA + pointB);
	outResult.normal = tri.normal;
	outResult.penetrationDepth = tri.distanceToOrigin;
	return returnCode;
}



```

`src/physics/collision_gjk.cpp`:

```cpp
#include "pch.h"
#include "collision_gjk.h"



gjk_internal_success updateGJKSimplex(gjk_simplex& s, const gjk_support_point& a, vec3& dir)
{
	if (s.numPoints == 2)
	{
		// Triangle case.
		vec3 ao = -a.minkowski;
		vec3 ab = s.b.minkowski - a.minkowski;
		vec3 ac = s.c.minkowski - a.minkowski;
		vec3 abc = cross(ab, ac);

		vec3 abp = cross(ab, abc);
		if (dot(ao, abp) > 0.f)
		{
			s.c = a;
			dir = crossABA(ab, ao);
			return gjk_dont_stop;
		}
		vec3 acp = cross(abc, ac);
		if (dot(ao, acp) > 0.f)
		{
			s.b = a;
			dir = crossABA(ac, ao);
			return gjk_dont_stop;
		}

		// Sort so that normal abc of triangle points outside (negative new search dir).
		if (dot(ao, abc) >= 0.f)
		{
			s.d = s.b;
			s.b = a;
			s.numPoints = 3;
			dir = abc;
			return gjk_dont_stop;
		}
		if (dot(ao, -abc) >= 0.f)
		{
			s.d = s.c;
			s.c = s.b;
			s.b = a;
			s.numPoints = 3;
			dir = -abc;
			return gjk_dont_stop;
		}

		//ASSERT(false);
		std::cerr << "GJK ERROR 0\n";
		return gjk_unexpected_error;
	}
	if (s.numPoints == 3)
	{
		// Tetrahedron case.
		vec3 ao = -a.minkowski;
		vec3 ab = s.b.minkowski - a.minkowski;
		vec3 ac = s.c.minkowski - a.minkowski;
		vec3 ad = s.d.minkowski - a.minkowski;

		vec3 bcd = cross(s.c.minkowski - s.b.minkowski, s.d.minkowski - s.b.minkowski);
		if (dot(bcd, dir) > 0.00001f || dot(bcd, s.b.minkowski) < -0.00001f)
		{
			std::cerr << "GJK ERROR 0\n";
			return gjk_unexpected_error;
		}

		// Normals of faces (point outside).
		vec3 abc = cross(ac, ab);
		vec3 abd = cross(ab, ad);
		vec3 adc = cross(ad, ac);

		int32 flags = 0;
		const int32 overABCFlag = 1;
		const int32 overABDFlag = 2;
		const int32 overADCFlag = 4;

		flags |= (dot(abc, ao) > 0.f) ? overABCFlag : 0;
		flags |= (dot(abd, ao) > 0.f) ? overABDFlag : 0;
		flags |= (dot(adc, ao) > 0.f) ? overADCFlag : 0;

		if (flags == (overABCFlag | overABDFlag | overADCFlag))
		{
			std::cerr << "GJK ERROR 0\n";
			return gjk_unexpected_error;
		}

		if (flags == 0)
		{
			return gjk_stop;
		}

		if (flags == overABCFlag)
		{
		overABC1:
			if (dot(cross(abc, ab), ao) > 0.f)
			{
				// New line: ab
				s.c = a;
				s.numPoints = 2;
				dir = crossABA(ab, ao);
				return gjk_dont_stop;
			}
		overABC2:
			if (dot(cross(ac, abc), ao) > 0.f)
			{
				// New line: ac
				s.b = a;
				s.numPoints = 2;
				dir = crossABA(ac, ao);
				return gjk_dont_stop;
			}

			// Stay in triangle case: bca
			s.d = a;
			dir = abc;
			return gjk_dont_stop;
		}

		if (flags == overABDFlag)
		{
		overABD1:
			if (dot(cross(abd, ad), ao) > 0.f)
			{
				// New line: ad
				s.b = s.d;
				s.c = a;
				s.numPoints = 2;
				dir = crossABA(ad, ao);
				return gjk_dont_stop;
			}
		overABD2:
			if (dot(cross(ab, abd), ao) > 0.f)
			{
				// New line: ab
				s.c = a;
				s.numPoints = 2;
				dir = crossABA(ab, ao);
				return gjk_dont_stop;
			}

			// Stay in triangle case: bad
			s.c = a;
			dir = abd;
			return gjk_dont_stop;
		}

		if (flags == overADCFlag)
		{
		overADC1:
			if (dot(cross(adc, ac), ao) > 0.f)
			{
				// New line: ac
				s.b = a;
				s.numPoints = 2;
				dir = crossABA(ac, ao);
				return gjk_dont_stop;
			}
		overADC2:
			if (dot(cross(ad, adc), ao) > 0.f)
			{
				// New line: ad
				s.b = a;
				s.c = s.d;
				s.numPoints = 2;
				dir = crossABA(ad, ao);
				return gjk_dont_stop;
			}

			// Stay in triangle case: acd
			s.b = a;
			dir = adc;
			return gjk_dont_stop;
		}

		if (flags == (overABCFlag | overABDFlag))
		{
			if (dot(cross(abc, ab), ao) > 0.f)
			{
				goto overABD1;
			}
			goto overABC2;
		}

		if (flags == (overABDFlag | overADCFlag))
		{
			if (dot(cross(abd, ad), ao) > 0.f)
			{
				goto overADC1;
			}
			goto overABD2;
		}

		if (flags == (overADCFlag | overABCFlag))
		{
			if (dot(cross(adc, ac), ao) > 0.f)
			{
				goto overABC1;
			}
			goto overADC2;
		}

		//ASSERT(false);
		std::cerr << "GJK ERROR 1\n";
		return gjk_unexpected_error;
	}

	//ASSERT(false);
	std::cerr << "GJK ERROR 2\n";
	return gjk_unexpected_error;
}


```

`src/physics/collision_gjk.h`:

```h
#pragma once

#include "bounding_volumes.h"


struct sphere_support_fn
{
	const bounding_sphere& s;

	vec3 operator()(vec3 dir) const
	{
		return normalize(dir) * s.radius + s.center;
	}
};

struct capsule_support_fn
{
	const bounding_capsule& c;

	vec3 operator()(const vec3& dir) const
	{
		float distA = dot(dir, c.positionA);
		float distB = dot(dir, c.positionB);
		vec3 fartherPoint = distA > distB ? c.positionA : c.positionB;
		return normalize(dir) * c.radius + fartherPoint;
	}
};

struct cylinder_support_fn
{
	const bounding_cylinder& c;

	vec3 operator()(const vec3& dir) const
	{
		float distA = dot(dir, c.positionA);
		float distB = dot(dir, c.positionB);
		vec3 fartherPoint = distA > distB ? c.positionA : c.positionB;

		vec3 n = c.positionA - c.positionB;

		vec3 projectedDir = noz(cross(cross(n, dir), n));
		return fartherPoint + projectedDir * c.radius;
	}
};

struct aabb_support_fn
{
	const bounding_box& b;

	vec3 operator()(vec3 dir) const
	{
		return vec3(
			(dir.x < 0.f) ? b.minCorner.x : b.maxCorner.x,
			(dir.y < 0.f) ? b.minCorner.y : b.maxCorner.y,
			(dir.z < 0.f) ? b.minCorner.z : b.maxCorner.z
		);
	}
};

struct obb_support_fn
{
	const bounding_oriented_box& b;

	vec3 operator()(vec3 dir) const
	{
		dir = conjugate(b.rotation) * dir;
		vec3 r(
			dir.x < 0.f ? -b.radius.x : b.radius.x,
			dir.y < 0.f ? -b.radius.y : b.radius.y,
			dir.z < 0.f ? -b.radius.z : b.radius.z
		);

		return b.center + b.rotation * r;
	}
};

struct hull_support_fn
{
	const bounding_hull& h;

	vec3 operator()(vec3 dir) const
	{
		dir = conjugate(h.rotation) * dir;
		vec3 result;

		float maxDist = -FLT_MAX;

		for (const vec3& v : h.geometryPtr->vertices)
		{
			float d = dot(dir, v);
			if (d > maxDist)
			{
				maxDist = d;
				result = v;
			}
		}

		return h.position + h.rotation * result;
	};
};

union extruded_triangle_support_fn
{
	struct
	{
		vec3 a, b, c;
		vec3 d, e, f;
	};
	vec3 points[6];

	extruded_triangle_support_fn(vec3 a, vec3 b, vec3 c, float extrusion = 10.f)
		: a(a), b(b), c(c),
		d(a.x, a.y - extrusion, a.z),
		e(b.x, b.y - extrusion, b.z),
		f(c.x, c.y - extrusion, c.z)
	{}

	vec3 operator()(vec3 dir) const
	{
		float maxD = dot(a, dir);
		vec3 result = a;

		for (uint32 i = 1; i < 6; ++i)
		{
			float d = dot(points[i], dir);
			if (d > maxD)
			{
				maxD = d;
				result = points[i];
			}
		}

		return result;
	}
};


struct gjk_support_point
{
	vec3 shapeAPoint;
	vec3 shapeBPoint;
	vec3 minkowski;

	gjk_support_point()
	{
	}

	gjk_support_point(const vec3& a, const vec3& b)
	{
		shapeAPoint = a;
		shapeBPoint = b;
		minkowski = a - b;
	}
};

struct gjk_simplex
{
	gjk_support_point a; // This is only used for the epa.
	gjk_support_point b, c, d;
	uint32 numPoints = 0;
};

template <typename shapeA_t, typename shapeB_t>
static gjk_support_point support(const shapeA_t& a, const shapeB_t& b, const vec3& dir)
{
	vec3 farthestInA = a(dir);
	vec3 farthestInB = b(-dir);
	return gjk_support_point(farthestInA, farthestInB);
}

static inline vec3 crossABA(const vec3& a, const vec3& b)
{
	return cross(cross(a, b), a);
}

enum gjk_internal_success
{
	gjk_stop,
	gjk_dont_stop,
	gjk_unexpected_error, // Happens very very seldom. I don't know the reason yet, but instead of asserting we return this. I figure it's better than crashing.
};

template <typename shapeA_t, typename shapeB_t>
static bool gjkIntersectionTest(const shapeA_t& shapeA, const shapeB_t& shapeB, gjk_simplex& outSimplex)
{
	// http://www.dyn4j.org/2010/04/gjk-gilbert-johnson-keerthi/

	gjk_internal_success updateGJKSimplex(gjk_simplex& s, const gjk_support_point& a, vec3& dir);

	vec3 dir(1.f, 0.1f, -0.2f); // Arbitrary.

	// First point.
	outSimplex.c = support(shapeA, shapeB, dir);
	if (dot(outSimplex.c.minkowski, dir) < 0.f)
	{
		return false;
	}

	// Second point.
	dir = -outSimplex.c.minkowski;
	outSimplex.b = support(shapeA, shapeB, dir);
	if (dot(outSimplex.b.minkowski, dir) < 0.f)
	{
		return false;
	}

	dir = crossABA(outSimplex.c.minkowski - outSimplex.b.minkowski, -outSimplex.b.minkowski);
	outSimplex.numPoints = 2;

	while (true)
	{
		if (squaredLength(dir) < 0.0001f)
		{
			return false;
		}

		gjk_support_point a = support(shapeA, shapeB, dir);
		if (dot(a.minkowski, dir) < 0.f)
		{
			return false;
		}

		gjk_internal_success success = updateGJKSimplex(outSimplex, a, dir);
		if (success == gjk_stop)
		{
			ASSERT(outSimplex.numPoints == 3);
			outSimplex.a = a;
			outSimplex.numPoints = 4;
			break;
		}
		else if (success == gjk_unexpected_error)
		{
			return false; // Return 'no collision' in the case of an unexpected error.
		}
	}

	return true;
}



```

`src/physics/collision_narrow.cpp`:

```cpp
#include "pch.h"
#include "collision_narrow.h"
#include "physics.h"
#include "collision_broad.h"
#include "collision_gjk.h"
#include "collision_epa.h"
#include "collision_sat.h"
#include "core/cpu_profiling.h"

#include "bounding_volumes_simd.h"

#define COLLISION_SIMD_WIDTH 8u


#if COLLISION_SIMD_WIDTH == 4
typedef w4_float w_float;
typedef w4_int w_int;
#elif COLLISION_SIMD_WIDTH == 8 && defined(SIMD_AVX_2)
typedef w8_float w_float;
typedef w8_int w_int;
#endif

typedef wN_vec2<w_float> w_vec2;
typedef wN_vec3<w_float> w_vec3;
typedef wN_vec4<w_float> w_vec4;
typedef wN_quat<w_float> w_quat;
typedef wN_mat2<w_float> w_mat2;
typedef wN_mat3<w_float> w_mat3;

typedef wN_bounding_sphere<w_float> w_bounding_sphere;
typedef wN_bounding_capsule<w_float> w_bounding_capsule;
typedef wN_bounding_cylinder<w_float> w_bounding_cylinder;
typedef wN_bounding_box<w_float> w_bounding_box;
typedef wN_bounding_oriented_box<w_float> w_bounding_oriented_box;
typedef wN_line_segment<w_float> w_line_segment;




struct contact_manifold
{
	contact_info contacts[4];

	vec3 collisionNormal; // From a to b.
	uint32 numContacts;
};

static bool intersection(const bounding_oriented_box& a, const bounding_oriented_box& b, contact_manifold& outContact);

struct vertex_penetration_pair
{
	vec3 vertex;
	float penetrationDepth;
};

static void findStableContactManifold(vertex_penetration_pair* vertices, uint32 numVertices, vec3 normal, contact_manifold& outContact)
{
	// http://media.steampowered.com/apps/valve/2015/DirkGregorius_Contacts.pdf slide 103ff.

	if (numVertices > 4)
	{
		// Find first vertex along some fixed distance.
		vec3 searchDir = getTangent(normal);
		float bestDistance = dot(searchDir, vertices[0].vertex);
		uint32 resultIndex = 0;
		for (uint32 i = 1; i < numVertices; ++i)
		{
			float distance = dot(searchDir, vertices[i].vertex);
			if (distance > bestDistance)
			{
				resultIndex = i;
				bestDistance = distance;
			}
		}

		outContact.contacts[0].penetrationDepth = vertices[resultIndex].penetrationDepth;
		outContact.contacts[0].point = vertices[resultIndex].vertex;

		// Find second point which is furthest away from first.
		bestDistance = 0.f;
		resultIndex = 0;
		for (uint32 i = 0; i < numVertices; ++i)
		{
			float sqDistance = squaredLength(vertices[i].vertex - outContact.contacts[0].point);
			if (sqDistance > bestDistance)
			{
				resultIndex = i;
				bestDistance = sqDistance;
			}
		}

		outContact.contacts[1].penetrationDepth = vertices[resultIndex].penetrationDepth;
		outContact.contacts[1].point = vertices[resultIndex].vertex;

		// Find third point which maximizes the area of the resulting triangle.
		float bestArea = 0.f;
		resultIndex = 0;
		for (uint32 i = 0; i < numVertices; ++i)
		{
			vec3 qa = outContact.contacts[0].point - vertices[i].vertex;
			vec3 qb = outContact.contacts[1].point - vertices[i].vertex;
			float area = 0.5f * dot(cross(qa, qb), normal);
			if (area > bestArea)
			{
				resultIndex = i;
				bestArea = area;
			}
		}

		outContact.contacts[2].penetrationDepth = vertices[resultIndex].penetrationDepth;
		outContact.contacts[2].point = vertices[resultIndex].vertex;

		// Find fourth point.
		bestArea = 0.f;
		resultIndex = 0;
		for (uint32 i = 0; i < numVertices; ++i)
		{
			vec3 qa = outContact.contacts[0].point - vertices[i].vertex;
			vec3 qb = outContact.contacts[1].point - vertices[i].vertex;
			vec3 qc = outContact.contacts[2].point - vertices[i].vertex;
			float area1 = 0.5f * dot(cross(qa, qb), normal);
			float area2 = 0.5f * dot(cross(qb, qc), normal);
			float area3 = 0.5f * dot(cross(qc, qa), normal);
			float area = max(max(area1, area2), area3);
			if (area > bestArea)
			{
				resultIndex = i;
				bestArea = area;
			}
		}

		outContact.contacts[3].penetrationDepth = vertices[resultIndex].penetrationDepth;
		outContact.contacts[3].point = vertices[resultIndex].vertex;

		outContact.numContacts = 4;
	}
	else
	{
		outContact.numContacts = numVertices;
		for (uint32 i = 0; i < numVertices; ++i)
		{
			outContact.contacts[i].penetrationDepth = vertices[i].penetrationDepth;
			outContact.contacts[i].point = vertices[i].vertex;
		}
	}
}

struct clipping_polygon
{
	vertex_penetration_pair points[16];
	uint32 numPoints = 0;
};

static vertex_penetration_pair clipAgainstPlane(vertex_penetration_pair a, vertex_penetration_pair b, float aDist, float bDist)
{
	aDist = abs(aDist);
	bDist = abs(bDist);
	
	float total = aDist + bDist;
	float t = aDist / total;

	return { lerp(a.vertex, b.vertex, t), lerp(a.penetrationDepth, b.penetrationDepth, t) };
}

// Planes must point inside.
static void sutherlandHodgmanClipping(clipping_polygon& input, const vec4* clipPlanes, uint32 numClipPlanes, clipping_polygon& output)
{
	clipping_polygon* in = &input;
	clipping_polygon* out = &output;

	uint32 clipIndex = 0;
	for (; clipIndex < numClipPlanes; ++clipIndex)
	{
		vec4 clipPlane = clipPlanes[clipIndex];
		out->numPoints = 0;

		if (in->numPoints == 0)
		{
			break;
		}

		vertex_penetration_pair startPoint = in->points[in->numPoints - 1];
		for (uint32 i = 0; i < in->numPoints; ++i)
		{
			vertex_penetration_pair endPoint = in->points[i];

			float startDist = signedDistanceToPlane(startPoint.vertex, clipPlane);
			float endDist = signedDistanceToPlane(endPoint.vertex, clipPlane);
			bool startInside = startDist > 0.f;
			bool endInside = endDist > 0.f;

			if (startInside && endInside)
			{
				out->points[out->numPoints++] = endPoint;
			}
			else if (startInside)
			{
				out->points[out->numPoints++] = clipAgainstPlane(startPoint, endPoint, startDist, endDist);
			}
			else if (!startInside && endInside)
			{
				out->points[out->numPoints++] = clipAgainstPlane(startPoint, endPoint, startDist, endDist);
				out->points[out->numPoints++] = endPoint;
			}

			startPoint = endPoint;
		}

		clipping_polygon* tmp = in;
		in = out;
		out = tmp;
	}

	if (clipIndex % 2 == 0)
	{
		for (uint32 i = 0; i < input.numPoints; ++i)
		{
			output.points[i] = input.points[i];
		}
		output.numPoints = input.numPoints;
	}
}

// Returns points and normals in AABB's local space. The caller must transform them to world space if needed.
static void getAABBClippingPlanes(vec3 aabbRadius, vec3 normal, vec3* clipPlanePoints, vec3* clipPlaneNormals)
{
	vec3 p = abs(normal);

	uint32 maxElement = (p.x > p.y) ? ((p.x > p.z) ? 0 : 2) : ((p.y > p.z) ? 1 : 2);

	uint32 axis0 = (maxElement + 1) % 3;
	uint32 axis1 = (maxElement + 2) % 3;

	{
		vec3 planeNormal(0.f); planeNormal.data[axis0] = 1.f;
		clipPlaneNormals[0] = planeNormal;
		clipPlanePoints[0] = -aabbRadius;
	}
	{
		vec3 planeNormal(0.f); planeNormal.data[axis1] = 1.f;
		clipPlaneNormals[1] = planeNormal;
		clipPlanePoints[1] = -aabbRadius;
	}
	{
		vec3 planeNormal(0.f); planeNormal.data[axis0] = -1.f;
		clipPlaneNormals[2] = planeNormal;
		clipPlanePoints[2] = aabbRadius;
	}
	{
		vec3 planeNormal(0.f); planeNormal.data[axis1] = -1.f;
		clipPlaneNormals[3] = planeNormal;
		clipPlanePoints[3] = aabbRadius;
	}
}

// Returns points in AABB's local space. The caller must transform them to world space if needed.
static void getAABBIncidentVertices(vec3 aabbRadius, vec3 normal, clipping_polygon& polygon)
{
	vec3 p = abs(normal);

	uint32 maxElement = (p.x > p.y) ? ((p.x > p.z) ? 0 : 2) : ((p.y > p.z) ? 1 : 2);
	float s = normal.data[maxElement] < 0.f ? 1.f : -1.f; // Flipped sign.

	uint32 axis0 = (maxElement + 1) % 3;
	uint32 axis1 = (maxElement + 2) % 3;

	float d = aabbRadius.data[maxElement] * s;
	float min0 = -aabbRadius.data[axis0];
	float min1 = -aabbRadius.data[axis1];
	float max0 = aabbRadius.data[axis0];
	float max1 = aabbRadius.data[axis1];

	polygon.numPoints = 4;
	polygon.points[0].vertex.data[maxElement] = d;
	polygon.points[0].vertex.data[axis0] = min0;
	polygon.points[0].vertex.data[axis1] = min1;

	polygon.points[1].vertex.data[maxElement] = d;
	polygon.points[1].vertex.data[axis0] = max0;
	polygon.points[1].vertex.data[axis1] = min1;

	polygon.points[2].vertex.data[maxElement] = d;
	polygon.points[2].vertex.data[axis0] = max0;
	polygon.points[2].vertex.data[axis1] = max1;

	polygon.points[3].vertex.data[maxElement] = d;
	polygon.points[3].vertex.data[axis0] = min0;
	polygon.points[3].vertex.data[axis1] = max1;
}

static vec4 getAABBReferencePlane(const bounding_box& b, vec3 normal)
{
	vec3 point(
		(normal.x < 0.f) ? b.minCorner.x : b.maxCorner.x,
		(normal.y < 0.f) ? b.minCorner.y : b.maxCorner.y,
		(normal.z < 0.f) ? b.minCorner.z : b.maxCorner.z
	);
	return createPlane(point, normal);
}

static void getAABBIncidentEdge(vec3 aabbRadius, vec3 normal, vec3& outA, vec3& outB)
{
	vec3 p = abs(normal);

	outA = vec3(aabbRadius.x, aabbRadius.y, aabbRadius.z);

	if (p.x > p.y)
	{
		if (p.y > p.z)
		{
			outB = vec3(aabbRadius.x, aabbRadius.y, -aabbRadius.z);
		}
		else
		{
			outB = vec3(aabbRadius.x, -aabbRadius.y, aabbRadius.z);
		}
	}
	else
	{
		if (p.x > p.z)
		{
			outB = vec3(aabbRadius.x, aabbRadius.y, -aabbRadius.z);
		}
		else
		{
			outB = vec3(-aabbRadius.x, aabbRadius.y, aabbRadius.z);
		}
	}

	float sx = normal.x < 0.f ? -1.f : 1.f;
	float sy = normal.y < 0.f ? -1.f : 1.f;
	float sz = normal.z < 0.f ? -1.f : 1.f;

	outA *= vec3(sx, sy, sz);
	outB *= vec3(sx, sy, sz);
}

// Expects that normal and tangents are already set in contact.
static bool clipPointsAndBuildContact(clipping_polygon& polygon, const vec4* clipPlanes, uint32 numClipPlanes, const vec4& referencePlane, contact_manifold& outContact)
{
	clipping_polygon clippedPolygon;
	sutherlandHodgmanClipping(polygon, clipPlanes, numClipPlanes, clippedPolygon);

	if (clippedPolygon.numPoints > 0)
	{
		// Project onto plane and remove everything below plane.
		for (uint32 i = 0; i < clippedPolygon.numPoints; ++i)
		{
			if (clippedPolygon.points[i].penetrationDepth < 0.f)
			{
				clippedPolygon.points[i] = clippedPolygon.points[clippedPolygon.numPoints - 1];
				--clippedPolygon.numPoints;
				--i;
			}
			else
			{
				clippedPolygon.points[i].vertex += referencePlane.xyz * clippedPolygon.points[i].penetrationDepth;
			}
		}

		if (clippedPolygon.numPoints > 0)
		{
			findStableContactManifold(clippedPolygon.points, clippedPolygon.numPoints, outContact.collisionNormal, outContact);
			return true;
		}
	}

	return false;
}



// Sphere tests.
static bool intersection(const bounding_sphere& s1, const bounding_sphere& s2, contact_manifold& outContact)
{
	vec3 n = s2.center - s1.center;
	float radiusSum = s2.radius + s1.radius;
	float sqDistance = squaredLength(n);
	if (sqDistance <= radiusSum * radiusSum)
	{
		float distance;
		if (sqDistance == 0.f) // Degenerate case.
		{
			distance = 0.f;
			outContact.collisionNormal = vec3(0.f, 1.f, 0.f); // Up.
		}
		else
		{
			distance = sqrt(sqDistance);
			outContact.collisionNormal = n / distance;
		}

		outContact.numContacts = 1;
		outContact.contacts[0].penetrationDepth = radiusSum - distance; // Flipped to change sign.
		ASSERT(outContact.contacts[0].penetrationDepth >= 0.f);
		outContact.contacts[0].point = 0.5f * (s1.center + s1.radius * outContact.collisionNormal + s2.center - s2.radius * outContact.collisionNormal);
		return true;
	}
	return false;
}

static bool intersection(const bounding_sphere& s, const bounding_capsule& c, contact_manifold& outContact)
{
	vec3 closestPoint = closestPoint_PointSegment(s.center, line_segment{ c.positionA, c.positionB });
	return intersection(s, bounding_sphere{ closestPoint, c.radius }, outContact);
}

static bool intersection(const bounding_sphere& s, const bounding_cylinder& c, contact_manifold& outContact)
{
	vec3 ab = c.positionB - c.positionA;
	float t = dot(s.center - c.positionA, ab) / squaredLength(ab);
	if (t >= 0.f && t <= 1.f)
	{
		return intersection(s, bounding_sphere{ lerp(c.positionA, c.positionB, t), c.radius }, outContact);
	}

	vec3 p = (t <= 0.f) ? c.positionA : c.positionB;
	vec3 up = (t <= 0.f) ? -ab : ab;

	vec3 projectedDirToCenter = normalize(cross(cross(up, s.center - p), up));
	vec3 endA = p + projectedDirToCenter * c.radius;
	vec3 endB = p - projectedDirToCenter * c.radius;

	vec3 closestToSphere = closestPoint_PointSegment(s.center, line_segment{ endA, endB });
	vec3 normal = closestToSphere - s.center; // From sphere to cylinder.
	float sqDistance = squaredLength(normal);

	if (sqDistance <= s.radius * s.radius)
	{
		float distance;
		if (sqDistance == 0.f) // Degenerate case.
		{
			distance = 0.f;
			outContact.collisionNormal = -normalize(up); // Flipped, so that from sphere to cylinder.
		}
		else
		{
			distance = sqrt(sqDistance);
			outContact.collisionNormal = normal / distance;
		}

		outContact.numContacts = 1;
		outContact.contacts[0].penetrationDepth = s.radius - distance;
		ASSERT(outContact.contacts[0].penetrationDepth >= 0.f);
		outContact.contacts[0].point = closestToSphere + 0.5f * outContact.contacts[0].penetrationDepth * normal;
		return true;
	}
	return false;
}

static bool intersection(const bounding_sphere& s, const bounding_box& a, contact_manifold& outContact)
{
	vec3 p = closestPoint_PointAABB(s.center, a);
	vec3 n = p - s.center;
	float sqDistance = squaredLength(n);
	if (sqDistance <= s.radius * s.radius)
	{
		float dist = 0.f;
		if (sqDistance > 0.f)
		{
			dist = sqrt(sqDistance);
			n /= dist;
		}
		else
		{
			n = vec3(0.f, 1.f, 0.f);
		}

		outContact.numContacts = 1;

		outContact.collisionNormal = n;
		outContact.contacts[0].penetrationDepth = s.radius - dist; // Flipped to change sign.
		outContact.contacts[0].point = 0.5f * (p + s.center + n * s.radius);

		return true;
	}
	return false;
}

static bool intersection(const bounding_sphere& s, const bounding_oriented_box& o, contact_manifold& outContact)
{
	bounding_box aabb = bounding_box::fromCenterRadius(o.center, o.radius);
	bounding_sphere s_ = { 
		conjugate(o.rotation)* (s.center - o.center) + o.center,
		s.radius };
	
	if (intersection(s_, aabb, outContact))
	{
		outContact.collisionNormal = o.rotation * outContact.collisionNormal;
		outContact.contacts[0].point = o.rotation * (outContact.contacts[0].point - o.center) + o.center;
		return true;
	}
	return false;
}

static bool intersection(const bounding_sphere& s, const bounding_hull& h, contact_manifold& outContact)
{
	sphere_support_fn sphereSupport{ s };
	hull_support_fn hullSupport{ h };

	gjk_simplex gjkSimplex;
	if (!gjkIntersectionTest(sphereSupport, hullSupport, gjkSimplex))
	{
		return false;
	}

	epa_result epa;
	auto epaSuccess = epaCollisionInfo(gjkSimplex, sphereSupport, hullSupport, epa);
	if (epaSuccess != epa_success)
	{
		//return false;
	}

	outContact.collisionNormal = epa.normal;
	outContact.numContacts = 1;
	outContact.contacts[0].penetrationDepth = epa.penetrationDepth;
	outContact.contacts[0].point = epa.point;

	return true;
}

// Capsule tests.
static bool intersection(const bounding_capsule& a, const bounding_capsule& b, contact_manifold& outContact)
{
	vec3 aDir = a.positionB - a.positionA;
	vec3 bDir = normalize(b.positionB - b.positionA);

	float aDirLength = length(aDir);
	aDir *= 1.f / aDirLength;

	float parallel = dot(aDir, bDir);
	if (abs(parallel) > 0.99f)
	{
		// Parallel case.

		vec3 pAa = a.positionA;
		vec3 pAb = a.positionB;
		vec3 pBa = b.positionA;
		vec3 pBb = b.positionB;

		if (parallel < 0.f)
		{
			std::swap(pBa, pBb);
		}

		vec3 referencePoint = a.positionA;

		float a0 = 0.f;
		float a1 = aDirLength;

		float b0 = dot(aDir, pBa - referencePoint);
		float b1 = dot(aDir, pBb - referencePoint);
		ASSERT(b1 > b0);

		float left = max(a0, b0);
		float right = min(a1, b1);

		if (right < left)
		{
			if (a0 > b1)
			{
				return intersection(bounding_sphere{ pAa, a.radius }, bounding_sphere{ pBb, b.radius }, outContact);
			}
			else
			{
				return intersection(bounding_sphere{ pAb, a.radius }, bounding_sphere{ pBa, b.radius }, outContact);
			}
		}

		vec3 contactA0 = referencePoint + left * aDir;
		vec3 contactA1 = referencePoint + right * aDir;

		vec3 contactB0 = closestPoint_PointSegment(contactA0, line_segment{ pBa, pBb });
		vec3 contactB1 = contactB0 + (right - left) * aDir;

		vec3 normal = contactB0 - contactA0;
		float d = length(normal);

		if (d < EPSILON)
		{
			d = 0.f;
			normal = vec3(0.f, 1.f, 0.f);
		}
		else
		{
			normal /= d;
		}

		float radiusSum = a.radius + b.radius;

		float penetration = radiusSum - d;
		if (penetration < 0.f)
		{
			return false;
		}

		outContact.collisionNormal = normal;
		outContact.numContacts = 2;
		outContact.contacts[0].penetrationDepth = penetration;
		outContact.contacts[0].point = (contactA0 + contactB0) * 0.5f;
		outContact.contacts[1].penetrationDepth = penetration;
		outContact.contacts[1].point = (contactA1 + contactB1) * 0.5f;

		return true;
	}
	else
	{
		vec3 closestPoint1, closestPoint2;
		closestPoint_SegmentSegment(line_segment{ a.positionA, a.positionB }, line_segment{ b.positionA, b.positionB }, closestPoint1, closestPoint2);
		return intersection(bounding_sphere{ closestPoint1, a.radius }, bounding_sphere{ closestPoint2, b.radius }, outContact);
	}
}

static bool intersection(const bounding_capsule& a, const bounding_cylinder& b, contact_manifold& outContact)
{
	vec3 aDir = a.positionB - a.positionA;
	vec3 bDir = normalize(b.positionB - b.positionA);

	float aDirLength = length(aDir);
	aDir *= 1.f / aDirLength;

	float parallel = dot(aDir, bDir);
	if (abs(parallel) > 0.99f)
	{
		// Parallel case.

		vec3 pAa = a.positionA;
		vec3 pAb = a.positionB;
		vec3 pBa = b.positionA;
		vec3 pBb = b.positionB;

		if (parallel < 0.f)
		{
			std::swap(pBa, pBb);
		}

		vec3 referencePoint = a.positionA;

		float a0 = 0.f;
		float a1 = aDirLength;

		float b0 = dot(aDir, pBa - referencePoint);
		float b1 = dot(aDir, pBb - referencePoint);
		ASSERT(b1 > b0);

		float left = max(a0, b0);
		float right = min(a1, b1);

		if (right < left)
		{
			if (a0 > b1)
			{
				return intersection(bounding_sphere{ pAa, a.radius }, b, outContact);
			}
			else
			{
				return intersection(bounding_sphere{ pAb, a.radius }, b, outContact);
			}
		}

		vec3 contactA0 = referencePoint + left * aDir;
		vec3 contactA1 = referencePoint + right * aDir;

		vec3 contactB0 = closestPoint_PointSegment(contactA0, line_segment{ pBa, pBb });
		vec3 contactB1 = contactB0 + (right - left) * aDir;

		vec3 normal = contactB0 - contactA0;
		float d = length(normal);

		if (d < EPSILON)
		{
			d = 0.f;
			normal = vec3(0.f, 1.f, 0.f);
		}
		else
		{
			normal /= d;
		}

		float radiusSum = a.radius + b.radius;

		float penetration = radiusSum - d;
		if (penetration < 0.f)
		{
			return false;
		}

		outContact.collisionNormal = normal;
		outContact.numContacts = 2;
		outContact.contacts[0].penetrationDepth = penetration;
		outContact.contacts[0].point = (contactA0 + contactB0) * 0.5f;
		outContact.contacts[1].penetrationDepth = penetration;
		outContact.contacts[1].point = (contactA1 + contactB1) * 0.5f;

		return true;
	}
	else
	{
		vec3 closestPoint1, closestPoint2;
		closestPoint_SegmentSegment(line_segment{ a.positionA, a.positionB }, line_segment{ b.positionA, b.positionB }, closestPoint1, closestPoint2);
		return intersection(bounding_sphere{ closestPoint1, a.radius }, b, outContact);
	}
}

static bool intersection(const bounding_capsule& c, const bounding_box& a, contact_manifold& outContact)
{
	capsule_support_fn capsuleSupport{ c };
	aabb_support_fn boxSupport{ a };

	gjk_simplex gjkSimplex;
	if (!gjkIntersectionTest(capsuleSupport, boxSupport, gjkSimplex))
	{
		return false;
	}

	epa_result epa;
	auto epaSuccess = epaCollisionInfo(gjkSimplex, capsuleSupport, boxSupport, epa);
	if (epaSuccess != epa_success)
	{
		//return false;
	}

	vec3 normal = epa.normal;
	vec3 point = epa.point;

	outContact.collisionNormal = normal;
	outContact.numContacts = 1;
	outContact.contacts[0].penetrationDepth = epa.penetrationDepth;
	outContact.contacts[0].point = point;

	if (abs(normal.x) > 0.99f || abs(normal.y) > 0.99f || abs(normal.z) > 0.99f)
	{
		// Probably AABB face.

		vec3 axis = normalize(c.positionB - c.positionA);
		if (abs(dot(normal, axis)) < 0.01f)
		{
			// Capsule is parallel to AABB face (perpendicular to normal).

			vec3 clipPlanePoints[4];
			vec3 clipPlaneNormals[4];
			vec4 clipPlanes[4];

			vec3 aabbNormal = -normal;

			vec4 referencePlane = getAABBReferencePlane(a, aabbNormal);

			clipping_polygon polygon;
			polygon.numPoints = 2;
			vec3 pa = c.positionA + normal * c.radius;
			vec3 pb = c.positionB + normal * c.radius;
			polygon.points[0] = { pa, -signedDistanceToPlane(pa, referencePlane) };
			polygon.points[1] = { pb, -signedDistanceToPlane(pb, referencePlane) };

			vec3 aCenter = a.getCenter();
			getAABBClippingPlanes(a.getRadius(), aabbNormal, clipPlanePoints, clipPlaneNormals);
			for (uint32 i = 0; i < 4; ++i)
			{
				clipPlanePoints[i] = clipPlanePoints[i] + aCenter;
				clipPlaneNormals[i] = clipPlaneNormals[i];
				clipPlanes[i] = createPlane(clipPlanePoints[i], clipPlaneNormals[i]);
			}

			clipPointsAndBuildContact(polygon, clipPlanes, 4, referencePlane, outContact);
		}
	}

	return true;
}

static bool intersection(const bounding_capsule& c, const bounding_oriented_box& o, contact_manifold& outContact)
{
	bounding_box aabb = bounding_box::fromCenterRadius(o.center, o.radius);
	bounding_capsule c_ = { 
		conjugate(o.rotation) * (c.positionA - o.center) + o.center, 
		conjugate(o.rotation) * (c.positionB - o.center) + o.center,
		c.radius };

	if (intersection(c_, aabb, outContact))
	{
		outContact.collisionNormal = o.rotation * outContact.collisionNormal;

		for (uint32 i = 0; i < outContact.numContacts; ++i)
		{
			outContact.contacts[i].point = o.rotation * (outContact.contacts[i].point - o.center) + o.center;
		}
		return true;
	}
	return false;
}

static bool intersection(const bounding_capsule& c, const bounding_hull& h, contact_manifold& outContact)
{
	// TODO: Handle multiple-contact-points case.

	capsule_support_fn capsuleSupport{ c };
	hull_support_fn hullSupport{ h };

	gjk_simplex gjkSimplex;
	if (!gjkIntersectionTest(capsuleSupport, hullSupport, gjkSimplex))
	{
		return false;
	}

	epa_result epa;
	auto epaSuccess = epaCollisionInfo(gjkSimplex, capsuleSupport, hullSupport, epa);
	if (epaSuccess != epa_success)
	{
		//return false;
	}

	outContact.collisionNormal = epa.normal;
	outContact.numContacts = 1;
	outContact.contacts[0].penetrationDepth = epa.penetrationDepth;
	outContact.contacts[0].point = epa.point;

	return true;
}

// Cylinder tests.
static bool intersection(const bounding_cylinder& a, const bounding_cylinder& b, contact_manifold& outContact)
{
	vec3 aDir = a.positionB - a.positionA;
	vec3 bDir = normalize(b.positionB - b.positionA);

	float aDirLength = length(aDir);
	aDir *= 1.f / aDirLength;

	float parallel = dot(aDir, bDir);
	if (abs(parallel) > 0.99f)
	{
		// Parallel case.

		vec3 pAa = a.positionA;
		vec3 pAb = a.positionB;
		vec3 pBa = b.positionA;
		vec3 pBb = b.positionB;

		if (parallel < 0.f)
		{
			std::swap(pBa, pBb);
		}

		vec3 referencePoint = a.positionA;

		float a0 = 0.f;
		float a1 = aDirLength;

		float b0 = dot(aDir, pBa - referencePoint);
		float b1 = dot(aDir, pBb - referencePoint);
		ASSERT(b1 > b0);

		float left = max(a0, b0);
		float right = min(a1, b1);

		if (right < left)
		{
			return false;
		}

		vec3 contactA0 = referencePoint + left * aDir;
		vec3 contactA1 = referencePoint + right * aDir;

		vec3 contactB0 = closestPoint_PointSegment(contactA0, line_segment{ pBa, pBb });
		vec3 contactB1 = contactB0 + (right - left) * aDir;

		vec3 normal = contactB0 - contactA0;
		float d = length(normal);

		float radiusSum = a.radius + b.radius;
		float penetration = radiusSum - d;
		if (penetration < 0.f)
		{
			return false;
		}


		float capPenetration = right - left;
		ASSERT(capPenetration > 0.f);

		if (capPenetration < penetration)
		{
			// Cylinders touch cap to cap. TODO: Find stable contact manifold.
			outContact.numContacts = 1;
			outContact.contacts[0].penetrationDepth = capPenetration;

			if (b0 > a0)
			{ 
				// B is "right" of A.
				outContact.collisionNormal = aDir;
				outContact.contacts[0].point = a.positionB - capPenetration * 0.5f;
			}
			else
			{
				// B is "left" of A.
				outContact.collisionNormal = -aDir;
				outContact.contacts[0].point = a.positionA + capPenetration * 0.5f;
			}
		}
		else
		{
			// Cylinders touch tube to tube.

			if (d < EPSILON)
			{
				d = 0.f;
				normal = vec3(0.f, 1.f, 0.f);
			}
			else
			{
				normal /= d;
			}

			outContact.collisionNormal = normal;
			outContact.numContacts = 2;
			outContact.contacts[0].penetrationDepth = penetration;
			outContact.contacts[0].point = (contactA0 + contactB0) * 0.5f;
			outContact.contacts[1].penetrationDepth = penetration;
			outContact.contacts[1].point = (contactA1 + contactB1) * 0.5f;
		}

		return true;
	}
	else
	{
		// TODO: Implement a less generic collision test.

		cylinder_support_fn cylinderSupportA{ a };
		cylinder_support_fn cylinderSupportB{ b };

		gjk_simplex gjkSimplex;
		if (!gjkIntersectionTest(cylinderSupportA, cylinderSupportB, gjkSimplex))
		{
			return false;
		}

		epa_result epa;
		auto epaSuccess = epaCollisionInfo(gjkSimplex, cylinderSupportA, cylinderSupportB, epa);
		if (epaSuccess != epa_success)
		{
			//return false;
		}

		outContact.collisionNormal = epa.normal;
		outContact.numContacts = 1;
		outContact.contacts[0].penetrationDepth = epa.penetrationDepth;
		outContact.contacts[0].point = epa.point;

		return true;
	}
}

static bool intersection(const bounding_cylinder& c, const bounding_box& a, contact_manifold& outContact)
{
	cylinder_support_fn cylinderSupport{ c };
	aabb_support_fn boxSupport{ a };

	gjk_simplex gjkSimplex;
	if (!gjkIntersectionTest(cylinderSupport, boxSupport, gjkSimplex))
	{
		return false;
	}

	epa_result epa;
	auto epaSuccess = epaCollisionInfo(gjkSimplex, cylinderSupport, boxSupport, epa);
	if (epaSuccess != epa_success)
	{
		//return false;
	}

	vec3 normal = epa.normal;
	vec3 point = epa.point;

	outContact.collisionNormal = normal;
	outContact.numContacts = 1;
	outContact.contacts[0].penetrationDepth = epa.penetrationDepth;
	outContact.contacts[0].point = point;

	if (abs(normal.x) > 0.99f || abs(normal.y) > 0.99f || abs(normal.z) > 0.99f)
	{
		// Probably AABB face.

		vec3 axis = normalize(c.positionB - c.positionA);
		float cosAngle = abs(dot(normal, axis));
		if (cosAngle < 0.01f)
		{
			// Cylinder is parallel to AABB face (perpendicular to normal).

			vec3 clipPlanePoints[4];
			vec3 clipPlaneNormals[4];
			vec4 clipPlanes[4];

			vec3 aabbNormal = -normal;

			vec4 referencePlane = getAABBReferencePlane(a, aabbNormal);

			clipping_polygon polygon;
			polygon.numPoints = 2;
			vec3 pa = c.positionA + normal * c.radius;
			vec3 pb = c.positionB + normal * c.radius;
			polygon.points[0] = { pa, -signedDistanceToPlane(pa, referencePlane) };
			polygon.points[1] = { pb, -signedDistanceToPlane(pb, referencePlane) };

			vec3 aCenter = a.getCenter();
			getAABBClippingPlanes(a.getRadius(), aabbNormal, clipPlanePoints, clipPlaneNormals);
			for (uint32 i = 0; i < 4; ++i)
			{
				clipPlanePoints[i] = clipPlanePoints[i] + aCenter;
				clipPlaneNormals[i] = clipPlaneNormals[i];
				clipPlanes[i] = createPlane(clipPlanePoints[i], clipPlaneNormals[i]);
			}

			clipPointsAndBuildContact(polygon, clipPlanes, 4, referencePlane, outContact);
		}
		else if (cosAngle > 0.99f)
		{
			// Cylinder touches AABB with cap. TODO: Find stable contact manifold.
		}
	}

	return true;
}

static bool intersection(const bounding_cylinder& c, const bounding_oriented_box& o, contact_manifold& outContact)
{
	bounding_box aabb = bounding_box::fromCenterRadius(o.center, o.radius);
	bounding_cylinder c_ = {
		conjugate(o.rotation) * (c.positionA - o.center) + o.center,
		conjugate(o.rotation) * (c.positionB - o.center) + o.center,
		c.radius };

	if (intersection(c_, aabb, outContact))
	{
		outContact.collisionNormal = o.rotation * outContact.collisionNormal;

		for (uint32 i = 0; i < outContact.numContacts; ++i)
		{
			outContact.contacts[i].point = o.rotation * (outContact.contacts[i].point - o.center) + o.center;
		}
		return true;
	}
	return false;
}

static bool intersection(const bounding_cylinder& c, const bounding_hull& h, contact_manifold& outContact)
{
	// TODO: Handle multiple-contact-points case.

	cylinder_support_fn cylinderSupport{ c };
	hull_support_fn hullSupport{ h };

	gjk_simplex gjkSimplex;
	if (!gjkIntersectionTest(cylinderSupport, hullSupport, gjkSimplex))
	{
		return false;
	}

	epa_result epa;
	auto epaSuccess = epaCollisionInfo(gjkSimplex, cylinderSupport, hullSupport, epa);
	if (epaSuccess != epa_success)
	{
		//return false;
	}

	outContact.collisionNormal = epa.normal;
	outContact.numContacts = 1;
	outContact.contacts[0].penetrationDepth = epa.penetrationDepth;
	outContact.contacts[0].point = epa.point;

	return true;
}

// AABB tests.
static bool intersection(const bounding_box& a, const bounding_box& b, contact_manifold& outContact)
{
	vec3 centerA = a.getCenter();
	vec3 centerB = b.getCenter();

	vec3 radiusA = a.getRadius();
	vec3 radiusB = b.getRadius();

	vec3 d = centerB - centerA;
	vec3 p = (radiusB + radiusA) - abs(d);

	if (p.x < 0.f || p.y < 0.f || p.z < 0.f)
	{
		return false;
	}

	uint32 minElement = (p.x < p.y) ? ((p.x < p.z) ? 0 : 2) : ((p.y < p.z) ? 1 : 2);

	float s = d.data[minElement] < 0.f ? -1.f : 1.f;
	float penetration = p.data[minElement] * s;
	vec3 normal(0.f);
	normal.data[minElement] = s;

	outContact.collisionNormal = normal;
	outContact.numContacts = 4;

	uint32 axis0 = (minElement + 1) % 3;
	uint32 axis1 = (minElement + 2) % 3;

	float min0 = max(a.minCorner.data[axis0], b.minCorner.data[axis0]);
	float min1 = max(a.minCorner.data[axis1], b.minCorner.data[axis1]);
	float max0 = min(a.maxCorner.data[axis0], b.maxCorner.data[axis0]);
	float max1 = min(a.maxCorner.data[axis1], b.maxCorner.data[axis1]);

	float depth = centerA.data[minElement] + radiusA.data[minElement] - penetration * 0.5f;

	outContact.contacts[0].penetrationDepth = penetration;
	outContact.contacts[0].point = vec3(0.f);
	outContact.contacts[0].point.data[axis0] = min0;
	outContact.contacts[0].point.data[axis1] = min1;
	outContact.contacts[0].point.data[minElement] = depth;

	outContact.contacts[1].penetrationDepth = penetration;
	outContact.contacts[1].point = vec3(0.f);
	outContact.contacts[1].point.data[axis0] = min0;
	outContact.contacts[1].point.data[axis1] = max1;
	outContact.contacts[1].point.data[minElement] = depth;

	outContact.contacts[2].penetrationDepth = penetration;
	outContact.contacts[2].point = vec3(0.f);
	outContact.contacts[2].point.data[axis0] = max0;
	outContact.contacts[2].point.data[axis1] = min1;
	outContact.contacts[2].point.data[minElement] = depth;

	outContact.contacts[3].penetrationDepth = penetration;
	outContact.contacts[3].point = vec3(0.f);
	outContact.contacts[3].point.data[axis0] = max0;
	outContact.contacts[3].point.data[axis1] = max1;
	outContact.contacts[3].point.data[minElement] = depth;

	//debugSphere(outContact.contacts[0].point, 0.1f, { 0.f, 0.f, 1.f, 0.f });
	//debugSphere(outContact.contacts[1].point, 0.1f, { 0.f, 0.f, 1.f, 0.f });
	//debugSphere(outContact.contacts[2].point, 0.1f, { 0.f, 0.f, 1.f, 0.f });
	//debugSphere(outContact.contacts[3].point, 0.1f, { 0.f, 0.f, 1.f, 0.f });

	return true;
}

static bool intersection(const bounding_box& a, const bounding_oriented_box& b, contact_manifold& outContact)
{
	// We forward to the more general case OBB vs OBB here. This is not ideal, since this test then again transforms to a space local
	// to one OOB.
	// However, I don't expect this function to be called very often, as AABBs are uncommon, so this is probably fine.
	return intersection(bounding_oriented_box{ quat::identity, a.getCenter(), a.getRadius() }, b, outContact);
}

static bool intersection(const bounding_box& a, const bounding_hull& h, contact_manifold& outContact)
{
	// TODO: Handle multiple-contact-points case.

	aabb_support_fn aabbSupport{ a };
	hull_support_fn hullSupport{ h };

	gjk_simplex gjkSimplex;
	if (!gjkIntersectionTest(aabbSupport, hullSupport, gjkSimplex))
	{
		return false;
	}

	epa_result epa;
	auto epaSuccess = epaCollisionInfo(gjkSimplex, aabbSupport, hullSupport, epa);
	if (epaSuccess != epa_success)
	{
		//return false;
	}

	outContact.collisionNormal = epa.normal;
	outContact.numContacts = 1;
	outContact.contacts[0].penetrationDepth = epa.penetrationDepth;
	outContact.contacts[0].point = epa.point;

	return true;
}

// OBB tests.
static bool intersection(const bounding_oriented_box& a, const bounding_oriented_box& b, contact_manifold& outContact)
{
	union obb_axes
	{
		struct
		{
			vec3 x, y, z;
		};
		vec3 u[3];
	};

	obb_axes axesA = {
		a.rotation * vec3(1.f, 0.f, 0.f),
		a.rotation * vec3(0.f, 1.f, 0.f),
		a.rotation * vec3(0.f, 0.f, 1.f),
	};

	obb_axes axesB = {
		b.rotation * vec3(1.f, 0.f, 0.f),
		b.rotation * vec3(0.f, 1.f, 0.f),
		b.rotation * vec3(0.f, 0.f, 1.f),
	};

	mat3 r;
	r.m00 = dot(axesA.x, axesB.x);
	r.m10 = dot(axesA.y, axesB.x);
	r.m20 = dot(axesA.z, axesB.x);
	r.m01 = dot(axesA.x, axesB.y);
	r.m11 = dot(axesA.y, axesB.y);
	r.m21 = dot(axesA.z, axesB.y);
	r.m02 = dot(axesA.x, axesB.z);
	r.m12 = dot(axesA.y, axesB.z);
	r.m22 = dot(axesA.z, axesB.z);

	vec3 tw = b.center - a.center;
	vec3 t = conjugate(a.rotation) * tw;

	bool parallel = false;

	mat3 absR;
	for (uint32 i = 0; i < 9; ++i)
	{
		absR.m[i] = abs(r.m[i]) + EPSILON; // Add in an epsilon term to counteract arithmetic errors when two edges are parallel and their cross product is (near) 0.
		if (absR.m[i] >= 0.99f)
		{
			parallel = true;
		}
	}

	float ra, rb;

	float minPenetration = FLT_MAX;
	vec3 normal;
	bool bFace = false;


	// Test a's faces.
	for (uint32 i = 0; i < 3; ++i)
	{
		ra = a.radius.data[i];
		rb = dot(row(absR, i), b.radius);
		float d = t.data[i];
		float penetration = ra + rb - abs(d);
		if (penetration < 0.f) { return false; }
		if (penetration < minPenetration)
		{
			minPenetration = penetration;
			normal = vec3(0.f); normal.data[i] = 1.f;
		}
	}

	// Test b's faces.
	for (uint32 i = 0; i < 3; ++i)
	{
		ra = dot(col(absR, i), a.radius);
		rb = b.radius.data[i];
		float d = dot(col(r, i), t);
		float penetration = ra + rb - abs(d);
		if (penetration < 0.f) { return false; }
		if (penetration < minPenetration)
		{
			minPenetration = penetration;
			normal = vec3(0.f); normal.data[i] = 1.f;
			bFace = true;
		}
	}

	bool edgeCollision = false;
	vec3 edgeNormal;

	if (!parallel)
	{
		float penetration;
		vec3 normal;
		float l;

		// Test a.x x b.x.
		ra = a.radius.y * absR.m20 + a.radius.z * absR.m10;
		rb = b.radius.y * absR.m02 + b.radius.z * absR.m01;
		penetration = ra + rb - abs(t.z * r.m10 - t.y * r.m20);
		if (penetration < 0.f) { return false; }
		normal = vec3(0.f, -r.m20, r.m10);
		l = 1.f / length(normal);
		penetration *= l;
		if (penetration < minPenetration)
		{
			minPenetration = penetration;
			edgeNormal = normal * l;
			edgeCollision = true;
		}

		// Test a.x x b.y.
		ra = a.radius.y * absR.m21 + a.radius.z * absR.m11;
		rb = b.radius.x * absR.m02 + b.radius.z * absR.m00;
		penetration = ra + rb - abs(t.z * r.m11 - t.y * r.m21);
		if (penetration < 0.f) { return false; }
		normal = vec3(0.f, -r.m21, r.m11);
		l = 1.f / length(normal);
		penetration *= l;
		if (penetration < minPenetration)
		{
			minPenetration = penetration;
			edgeNormal = normal * l;
			edgeCollision = true;
		}

		// Test a.x x b.z.
		ra = a.radius.y * absR.m22 + a.radius.z * absR.m12;
		rb = b.radius.x * absR.m01 + b.radius.y * absR.m00;
		penetration = ra + rb - abs(t.z * r.m12 - t.y * r.m22);
		if (penetration < 0.f) { return false; }
		normal = vec3(0.f, -r.m22, r.m12);
		l = 1.f / length(normal);
		penetration *= l;
		if (penetration < minPenetration)
		{
			minPenetration = penetration;
			edgeNormal = normal * l;
			edgeCollision = true;
		}

		// Test a.y x b.x.
		ra = a.radius.x * absR.m20 + a.radius.z * absR.m00;
		rb = b.radius.y * absR.m12 + b.radius.z * absR.m11;
		penetration = ra + rb - abs(t.x * r.m20 - t.z * r.m00);
		if (penetration < 0.f) { return false; }
		normal = vec3(r.m20, 0.f, -r.m00);
		l = 1.f / length(normal);
		penetration *= l;
		if (penetration < minPenetration)
		{
			minPenetration = penetration;
			edgeNormal = normal * l;
			edgeCollision = true;
		}

		// Test a.y x b.y.
		ra = a.radius.x * absR.m21 + a.radius.z * absR.m01;
		rb = b.radius.x * absR.m12 + b.radius.z * absR.m10;
		penetration = ra + rb - abs(t.x * r.m21 - t.z * r.m01);
		if (penetration < 0.f) { return false; }
		normal = vec3(r.m21, 0.f, -r.m01);
		l = 1.f / length(normal);
		penetration *= l;
		if (penetration < minPenetration)
		{
			minPenetration = penetration;
			edgeNormal = normal * l;
			edgeCollision = true;
		}

		// Test a.y x b.z.
		ra = a.radius.x * absR.m22 + a.radius.z * absR.m02;
		rb = b.radius.x * absR.m11 + b.radius.y * absR.m10;
		penetration = ra + rb - abs(t.x * r.m22 - t.z * r.m02);
		if (penetration < 0.f) { return false; }
		normal = vec3(r.m22, 0.f, -r.m02);
		l = 1.f / length(normal);
		penetration *= l;
		if (penetration < minPenetration)
		{
			minPenetration = penetration;
			edgeNormal = normal * l;
			edgeCollision = true;
		}

		// Test a.z x b.x.
		ra = a.radius.x * absR.m10 + a.radius.y * absR.m00;
		rb = b.radius.y * absR.m22 + b.radius.z * absR.m21;
		penetration = ra + rb - abs(t.y * r.m00 - t.x * r.m10);
		if (penetration < 0.f) { return false; }
		normal = vec3(-r.m10, r.m00, 0.f);
		l = 1.f / length(normal);
		penetration *= l;
		if (penetration < minPenetration)
		{
			minPenetration = penetration;
			edgeNormal = normal * l;
			edgeCollision = true;
		}

		// Test a.z x b.y.
		ra = a.radius.x * absR.m11 + a.radius.y * absR.m01;
		rb = b.radius.x * absR.m22 + b.radius.z * absR.m20;
		penetration = ra + rb - abs(t.y * r.m01 - t.x * r.m11);
		if (penetration < 0.f) { return false; }
		normal = vec3(-r.m11, r.m01, 0.f);
		l = 1.f / length(normal);
		penetration *= l;
		if (penetration < minPenetration)
		{
			minPenetration = penetration;
			edgeNormal = normal * l;
			edgeCollision = true;
		}

		// Test a.z x b.z.
		ra = a.radius.x * absR.m12 + a.radius.y * absR.m02;
		rb = b.radius.x * absR.m21 + b.radius.y * absR.m20;
		penetration = ra + rb - abs(t.y * r.m02 - t.x * r.m12);
		if (penetration < 0.f) { return false; }
		normal = vec3(-r.m12, r.m02, 0.f);
		l = 1.f / length(normal);
		penetration *= l;
		if (penetration < minPenetration)
		{
			minPenetration = penetration;
			edgeNormal = normal * l;
			edgeCollision = true;
		}
	}


	bool faceCollision = !edgeCollision;
	if (faceCollision)
	{
		if (bFace)
		{
			normal = r * normal;
		}
	}
	else
	{
		normal = edgeNormal;
	}

	normal = a.rotation * normal;

	//normal = normalize(normal);

	if (dot(normal, tw) < 0.f)
	{
		normal = -normal;
	}

	// Normal is now in world space and points from a to b.

	outContact.collisionNormal = normal;

	if (faceCollision)
	{
		vec3 clipPlanePoints[4];
		vec3 clipPlaneNormals[4];

		clipping_polygon polygon;

		vec4 plane;

		if (!bFace)
		{
			// A's face -> A is reference and B is incidence.

			getAABBClippingPlanes(a.radius, conjugate(a.rotation) * normal, clipPlanePoints, clipPlaneNormals);
			getAABBIncidentVertices(b.radius, conjugate(b.rotation) * normal, polygon);

			for (uint32 i = 0; i < 4; ++i)
			{
				clipPlanePoints[i] = a.rotation * clipPlanePoints[i] + a.center;
				clipPlaneNormals[i] = a.rotation * clipPlaneNormals[i];
				polygon.points[i].vertex = b.rotation * polygon.points[i].vertex + b.center;
			}

			obb_support_fn support{ a };
			vec3 referencePlanePoint = support(normal);
			plane = createPlane(referencePlanePoint, normal);
		}
		else
		{
			// B's face -> B is reference and A is incidence.

			getAABBClippingPlanes(b.radius, conjugate(b.rotation) * -normal, clipPlanePoints, clipPlaneNormals);
			getAABBIncidentVertices(a.radius, conjugate(a.rotation) * -normal, polygon);

			for (uint32 i = 0; i < 4; ++i)
			{
				clipPlanePoints[i] = b.rotation * clipPlanePoints[i] + b.center;
				clipPlaneNormals[i] = b.rotation * clipPlaneNormals[i];
				polygon.points[i].vertex = a.rotation * polygon.points[i].vertex + a.center;
			}

			obb_support_fn support{ b };
			vec3 referencePlanePoint = support(-normal);
			plane = createPlane(referencePlanePoint, -normal);
		}

		vec4 clipPlanes[4];
		for (uint32 i = 0; i < 4; ++i)
		{
			clipPlanes[i] = createPlane(clipPlanePoints[i], clipPlaneNormals[i]);
			polygon.points[i].penetrationDepth = -signedDistanceToPlane(polygon.points[i].vertex, plane);
		}

		if (!clipPointsAndBuildContact(polygon, clipPlanes, 4, plane, outContact))
		{
			return false;
		}
	}
	else
	{
		vec3 a0, a1, b0, b1;
		getAABBIncidentEdge(a.radius, conjugate(a.rotation) * normal, a0, a1);
		getAABBIncidentEdge(b.radius, conjugate(b.rotation) * -normal, b0, b1);

		a0 = a.rotation * a0 + a.center;
		a1 = a.rotation * a1 + a.center;
		b0 = b.rotation * b0 + b.center;
		b1 = b.rotation * b1 + b.center;

		//debugSphere(a0, 0.1f, { 0.f, 1.f, 0.f, 1.f });
		//debugSphere(a1, 0.1f, { 0.f, 1.f, 0.f, 1.f });
		//debugSphere(b0, 0.1f, { 1.f, 0.f, 0.f, 1.f });
		//debugSphere(b1, 0.1f, { 1.f, 0.f, 0.f, 1.f });

		vec3 pa, pb;
		float sqDistance = closestPoint_SegmentSegment(line_segment{ a0, a1 }, line_segment{ b0, b1 }, pa, pb);

		outContact.numContacts = 1;
		outContact.contacts[0].penetrationDepth = sqrt(sqDistance);
		outContact.contacts[0].point = (pa + pb) * 0.5f;
	}


	//for (uint32 i = 0; i < outContact.numContacts; ++i)
	//{
	//	debugSphere(outContact.contacts[i].point, 0.1f, { 0.f, 0.f, 1.f, 0.f });
	//}

	return true;
}

static bool intersection(const bounding_oriented_box& o, const bounding_hull& h, contact_manifold& outContact)
{
	// TODO: Handle multiple-contact-points case.

	obb_support_fn obbSupport{ o };
	hull_support_fn hullSupport{ h };

	gjk_simplex gjkSimplex;
	if (!gjkIntersectionTest(obbSupport, hullSupport, gjkSimplex))
	{
		return false;
	}

	epa_result epa;
	auto epaSuccess = epaCollisionInfo(gjkSimplex, obbSupport, hullSupport, epa);
	if (epaSuccess != epa_success)
	{
		//return false;
	}

	outContact.collisionNormal = epa.normal;
	outContact.numContacts = 1;
	outContact.contacts[0].penetrationDepth = epa.penetrationDepth;
	outContact.contacts[0].point = epa.point;

	return true;
}

// Hull tests.
static bool intersection(const bounding_hull& a, const bounding_hull& b, contact_manifold& outContact)
{
	// TODO: Handle multiple-contact-points case.

	hull_support_fn hullSupport1{ a };
	hull_support_fn hullSupport2{ b };

	gjk_simplex gjkSimplex;
	if (!gjkIntersectionTest(hullSupport1, hullSupport2, gjkSimplex))
	{
		return false;
	}

	epa_result epa;
	auto epaSuccess = epaCollisionInfo(gjkSimplex, hullSupport1, hullSupport2, epa);
	if (epaSuccess != epa_success)
	{
		//return false;
	}

	outContact.collisionNormal = epa.normal;
	outContact.numContacts = 1;
	outContact.contacts[0].penetrationDepth = epa.penetrationDepth;
	outContact.contacts[0].point = epa.point;

	return true;
}








static bool overlapCheck(const collider_union* worldSpaceColliders, collider_pair pair, non_collision_interaction& interaction)
{
	const collider_union* colliderA = worldSpaceColliders + pair.colliderA;
	const collider_union* colliderB = worldSpaceColliders + pair.colliderB;

	ASSERT(colliderA->objectType == physics_object_type_rigid_body || colliderB->objectType == physics_object_type_rigid_body);
	ASSERT(colliderA->objectType != physics_object_type_rigid_body || colliderB->objectType != physics_object_type_rigid_body);

	if (colliderA->objectType == physics_object_type_rigid_body)
	{
		interaction.rigidBodyIndex = colliderA->objectIndex;
		interaction.otherIndex = colliderB->objectIndex;
		interaction.otherType = colliderB->objectType;
	}
	else
	{
		interaction.rigidBodyIndex = colliderB->objectIndex;
		interaction.otherIndex = colliderA->objectIndex;
		interaction.otherType = colliderA->objectType;
	}

	bool overlaps = false;

	switch (colliderA->type)
	{
		// Sphere tests.
		case collider_type_sphere:
		{
			switch (colliderB->type)
			{
				case collider_type_sphere: overlaps = sphereVsSphere(colliderA->sphere, colliderB->sphere); break;
				case collider_type_capsule: overlaps = sphereVsCapsule(colliderA->sphere, colliderB->capsule); break;
				case collider_type_cylinder: overlaps = sphereVsCylinder(colliderA->sphere, colliderB->cylinder); break;
				case collider_type_aabb: overlaps = sphereVsAABB(colliderA->sphere, colliderB->aabb); break;
				case collider_type_obb: overlaps = sphereVsOBB(colliderA->sphere, colliderB->obb); break;
				case collider_type_hull: overlaps = sphereVsHull(colliderA->sphere, colliderB->hull); break;
			}
		} break;

		// Capsule tests.
		case collider_type_capsule:
		{
			switch (colliderB->type)
			{
				case collider_type_capsule: overlaps = capsuleVsCapsule(colliderA->capsule, colliderB->capsule); break;
				case collider_type_cylinder: overlaps = capsuleVsCylinder(colliderA->capsule, colliderB->cylinder); break;
				case collider_type_aabb: overlaps = capsuleVsAABB(colliderA->capsule, colliderB->aabb); break;
				case collider_type_obb: overlaps = capsuleVsOBB(colliderA->capsule, colliderB->obb); break;
				case collider_type_hull: overlaps = capsuleVsHull(colliderA->capsule, colliderB->hull); break;
			}
		} break;

		// Cylinder tests.
		case collider_type_cylinder:
		{
			switch (colliderB->type)
			{
				case collider_type_cylinder: overlaps = cylinderVsCylinder(colliderA->cylinder, colliderB->cylinder); break;
				case collider_type_aabb: overlaps = cylinderVsAABB(colliderA->cylinder, colliderB->aabb); break;
				case collider_type_obb: overlaps = cylinderVsOBB(colliderA->cylinder, colliderB->obb); break;
				case collider_type_hull: overlaps = cylinderVsHull(colliderA->cylinder, colliderB->hull); break;
			}
		} break;

		// AABB tests.
		case collider_type_aabb:
		{
			switch (colliderB->type)
			{
				case collider_type_aabb: overlaps = aabbVsAABB(colliderA->aabb, colliderB->aabb); break;
				case collider_type_obb: overlaps = aabbVsOBB(colliderA->aabb, colliderB->obb); break;
				case collider_type_hull: overlaps = aabbVsHull(colliderA->aabb, colliderB->hull); break;
			}
		} break;

		// OBB tests.
		case collider_type_obb:
		{
			switch (colliderB->type)
			{
				case collider_type_obb: overlaps = obbVsOBB(colliderA->obb, colliderB->obb); break;
				case collider_type_hull: overlaps = obbVsHull(colliderA->obb, colliderB->hull); break;
			}
		} break;

		// Hull tests.
		case collider_type_hull:
		{
			switch (colliderB->type)
			{
				case collider_type_hull: overlaps = hullVsHull(colliderA->hull, colliderB->hull); break;
			}
		} break;
	}

	return overlaps;
}










template <typename collider_t>
static collider_t loadBoundingVolumeSIMD(const collider_union* worldSpaceColliders, uint16* indices) { static_assert(false); }

template <>
static w_bounding_sphere loadBoundingVolumeSIMD<w_bounding_sphere>(const collider_union* worldSpaceColliders, uint16* indices)
{
	w_bounding_sphere result;
	load4((float*)&worldSpaceColliders->sphere, indices, sizeof(collider_union),
		result.center.x, result.center.y, result.center.z, result.radius);
	return result;
}

template <>
static w_bounding_capsule loadBoundingVolumeSIMD<w_bounding_capsule>(const collider_union* worldSpaceColliders, uint16* indices)
{
	w_bounding_capsule result;
	w_float dummy;
	load8((float*)&worldSpaceColliders->capsule, indices, sizeof(collider_union),
		result.positionA.x, result.positionA.y, result.positionA.z,
		result.positionB.x, result.positionB.y, result.positionB.z,
		result.radius, dummy);
	return result;
}

template <>
static w_bounding_cylinder loadBoundingVolumeSIMD<w_bounding_cylinder>(const collider_union* worldSpaceColliders, uint16* indices)
{
	w_bounding_cylinder result;
	w_float dummy;
	load8((float*)&worldSpaceColliders->cylinder, indices, sizeof(collider_union),
		result.positionA.x, result.positionA.y, result.positionA.z,
		result.positionB.x, result.positionB.y, result.positionB.z,
		result.radius, dummy);
	return result;
}

template <>
static w_bounding_box loadBoundingVolumeSIMD<w_bounding_box>(const collider_union* worldSpaceColliders, uint16* indices)
{
	w_bounding_box result;
	w_float dummy0, dummy1;
	load8((float*)&worldSpaceColliders->aabb, indices, sizeof(collider_union),
		result.minCorner.x, result.minCorner.y, result.minCorner.z,
		result.maxCorner.x, result.maxCorner.y, result.maxCorner.z,
		dummy0, dummy1);
	return result;
}

template <>
static w_bounding_oriented_box loadBoundingVolumeSIMD<w_bounding_oriented_box>(const collider_union* worldSpaceColliders, uint16* indices)
{
	w_bounding_oriented_box result;
	w_float dummy0, dummy1;
	load8(&worldSpaceColliders->obb.rotation.x, indices, sizeof(collider_union),
		result.rotation.x, result.rotation.y, result.rotation.z, result.rotation.w,
		result.center.x, result.center.y, result.center.z,
		result.radius.x);
	load4(&worldSpaceColliders->obb.radius.y, indices, sizeof(collider_union),
		result.radius.y, result.radius.z,
		dummy0, dummy1);
	return result;
}

template <typename collider_t> static const collider_t& loadBoundingVolumeScalar(const collider_union* worldSpaceColliders, uint32 index) { static_assert(false); }
template <> static const bounding_sphere& loadBoundingVolumeScalar<bounding_sphere>(const collider_union* worldSpaceColliders, uint32 index) { return worldSpaceColliders[index].sphere; }
template <> static const bounding_capsule& loadBoundingVolumeScalar<bounding_capsule>(const collider_union* worldSpaceColliders, uint32 index) { return worldSpaceColliders[index].capsule; }
template <> static const bounding_cylinder& loadBoundingVolumeScalar<bounding_cylinder>(const collider_union* worldSpaceColliders, uint32 index) { return worldSpaceColliders[index].cylinder; }
template <> static const bounding_box& loadBoundingVolumeScalar<bounding_box>(const collider_union* worldSpaceColliders, uint32 index) { return worldSpaceColliders[index].aabb; }
template <> static const bounding_oriented_box& loadBoundingVolumeScalar<bounding_oriented_box>(const collider_union* worldSpaceColliders, uint32 index) { return worldSpaceColliders[index].obb; }
template <> static const bounding_hull& loadBoundingVolumeScalar<bounding_hull>(const collider_union* worldSpaceColliders, uint32 index) { return worldSpaceColliders[index].hull; }


struct w_collision_contact
{
	w_vec3 point;
	w_float penetrationDepth;
	w_vec3 normal;
	uint32 mask;
};


// Sphere tests.
static uint32 intersectionSIMD(const w_bounding_sphere& s1, const w_bounding_sphere& s2, w_collision_contact* outContacts)
{
	w_vec3 n = s2.center - s1.center;
	w_float radiusSum = s2.radius + s1.radius;
	w_float sqDistance = squaredLength(n);

	auto intersects = (sqDistance <= radiusSum * radiusSum);
	
	uint32 mask = toBitMask(intersects);

	if (anyTrue(mask))
	{
		auto degenerate = (sqDistance == 0.f);
		w_float distance = ifThen(degenerate, 0.f, sqrt(sqDistance));
		w_vec3 collisionNormal = ifThen(degenerate, w_vec3(0.f, 1.f, 0.f), n / distance);

		w_float penetrationDepth = radiusSum - distance; // Flipped to change sign.
		w_vec3 point = w_float(0.5f) * (s1.center + s1.radius * collisionNormal + s2.center - s2.radius * collisionNormal);

		outContacts[0].point = point;
		outContacts[0].penetrationDepth = penetrationDepth;
		outContacts[0].normal = collisionNormal;
		outContacts[0].mask = mask;

		return 1;
	}

	return 0;
}

static uint32 intersectionSIMD(const w_bounding_sphere& s, const w_bounding_capsule& c, w_collision_contact* outContacts)
{
	w_vec3 closestPoint = closestPoint_PointSegment(s.center, w_line_segment{ c.positionA, c.positionB });
	return intersectionSIMD(s, w_bounding_sphere{ closestPoint, c.radius }, outContacts);
}

static uint32 intersectionSIMD(const w_bounding_sphere& s, const w_bounding_cylinder& c, w_collision_contact* outContacts)
{
	w_vec3 ab = c.positionB - c.positionA;
	w_float t = dot(s.center - c.positionA, ab) / squaredLength(ab);

	auto tSaturated = t >= 0.f & t <= 1.f;

	int32 tSaturatedMask = toBitMask(tSaturated);

	uint32 sphereSphereTest = 0;
	if (anyTrue(tSaturatedMask))
	{
		sphereSphereTest = intersectionSIMD(s, w_bounding_sphere{ lerp(c.positionA, c.positionB, t), c.radius }, outContacts);

		if (allTrue(tSaturated))
		{
			return sphereSphereTest;
		}
	}



	w_vec3 p = ifThen(t <= 0.f, c.positionA, c.positionB);
	w_vec3 up = ifThen(t <= 0.f, -ab, ab);

	w_vec3 projectedDirToCenter = normalize(cross(cross(up, s.center - p), up));
	w_vec3 endA = p + projectedDirToCenter * c.radius;
	w_vec3 endB = p - projectedDirToCenter * c.radius;

	w_vec3 closestToSphere = closestPoint_PointSegment(s.center, w_line_segment{ endA, endB });
	w_vec3 normal = closestToSphere - s.center; // From sphere to cylinder.
	w_float sqDistance = squaredLength(normal);

	auto intersects = (sqDistance <= s.radius * s.radius);

	uint32 mask = toBitMask(intersects);

	if (mask)
	{
		auto degenerate = sqDistance == 0.f;

		w_float distance = ifThen(degenerate, 0.f, sqrt(sqDistance));
		normal = ifThen(degenerate, -normalize(up), normal / distance);
		
		w_float penetrationDepth = s.radius - distance;
		w_vec3 point = closestToSphere + 0.5f * penetrationDepth * normal;

		if (anyTrue(tSaturatedMask))
		{
			point = ifThen(tSaturated, outContacts[0].point, point);
			penetrationDepth = ifThen(tSaturated, outContacts[0].penetrationDepth, penetrationDepth);
			normal = ifThen(tSaturated, outContacts[0].normal, normal);

			mask |= tSaturatedMask;
		}

		outContacts[0].point = point;
		outContacts[0].penetrationDepth = penetrationDepth;
		outContacts[0].normal = normal;
		outContacts[0].mask = mask;
		
		return 1;
	}

	return sphereSphereTest;
}

static uint32 intersectionSIMD(const w_bounding_sphere& s, const w_bounding_box& a, w_collision_contact* outContacts)
{
	w_vec3 p = closestPoint_PointAABB(s.center, a);
	w_vec3 n = p - s.center;
	w_float sqDistance = squaredLength(n);

	auto intersects = sqDistance <= s.radius * s.radius;

	uint32 mask = toBitMask(intersects);

	if (anyTrue(mask))
	{
		auto valid = (sqDistance > 0.f);
		w_float dist = ifThen(valid, sqrt(sqDistance), 0.f);
		n = ifThen(valid, n / dist, w_vec3(0.f, 1.f, 0.f));

		outContacts[0].point = w_float(0.5f) * (p + s.center + n * s.radius);
		outContacts[0].penetrationDepth = s.radius - dist; // Flipped to change sign.
		outContacts[0].normal = n;
		outContacts[0].mask = mask;

		return 1;
	}
	return 0;
}

static uint32 intersectionSIMD(const w_bounding_sphere& s, const w_bounding_oriented_box& o, w_collision_contact* outContacts)
{
	w_bounding_box aabb = w_bounding_box::fromCenterRadius(o.center, o.radius);
	w_bounding_sphere s_ = {
		conjugate(o.rotation) * (s.center - o.center) + o.center,
		s.radius };

	uint32 result = intersectionSIMD(s_, aabb, outContacts);

	if (result)
	{
		outContacts[0].normal = o.rotation * outContacts[0].normal;
		outContacts[0].point = o.rotation * (outContacts[0].point - o.center) + o.center;
		return 1;
	}
	return 0;
}

// Capsule tests.
static uint32 intersectionSIMD(const w_bounding_capsule& a, const w_bounding_capsule& b, w_collision_contact* outContacts)
{
	w_vec3 aDir = a.positionB - a.positionA;
	w_vec3 bDir = normalize(b.positionB - b.positionA);

	w_float aDirLength = length(aDir);
	aDir *= 1.f / aDirLength;

	w_float alignment = dot(aDir, bDir);

	auto valid = (abs(alignment) <= 0.99f);

	uint32 result = 0;

	int32 validMask = toBitMask(valid);

	if (anyTrue(validMask))
	{
		w_vec3 closestPoint1, closestPoint2;
		closestPoint_SegmentSegment(w_line_segment{ a.positionA, a.positionB }, w_line_segment{ b.positionA, b.positionB }, closestPoint1, closestPoint2);
		result = intersectionSIMD(w_bounding_sphere{ closestPoint1, a.radius }, w_bounding_sphere{ closestPoint2, b.radius }, outContacts);

		if (allTrue(valid))
		{
			return result;
		}
	}

	// Parallel case.

	w_vec3 pAa = a.positionA;
	w_vec3 pAb = a.positionB;
	w_vec3 pBa = b.positionA;
	w_vec3 pBb = b.positionB;

	auto swap = alignment < 0.f;
	
	if (anyTrue(swap))
	{
		w_vec3 tmp = pBa;
		pBa = ifThen(swap, pBb, pBa);
		pBb = ifThen(swap, tmp, pBb);
	}

	w_vec3 referencePoint = a.positionA;

	w_float a0 = 0.f;
	w_float a1 = aDirLength;

	w_float b0 = dot(aDir, pBa - referencePoint);
	w_float b1 = dot(aDir, pBb - referencePoint);

	w_float left = maximum(a0, b0);
	w_float right = minimum(a1, b1);

	auto endToEnd = right < left;
	if (anyTrue(endToEnd))
	{
		auto mask = a0 > b1;
		w_vec3 refA = ifThen(mask, pAa, pAb);
		w_vec3 refB = ifThen(mask, pBb, pBa);

		w_collision_contact contact;
		uint32 endToEndTest = intersectionSIMD(w_bounding_sphere{ refA, a.radius }, w_bounding_sphere{ refB, b.radius }, &contact);

		if (endToEndTest)
		{
			outContacts[0].point = ifThen(valid, outContacts[0].point, contact.point);
			outContacts[0].penetrationDepth = ifThen(valid, outContacts[0].penetrationDepth, contact.penetrationDepth);
			outContacts[0].normal = ifThen(valid, outContacts[0].normal, contact.normal);
			outContacts[0].mask |= contact.mask;
			valid |= mask;
		}

		result = max(endToEndTest, result);

		if (allTrue(valid))
		{
			return result;
		}
	}

	w_vec3 contactA0 = referencePoint + left * aDir;
	w_vec3 contactA1 = referencePoint + right * aDir;

	w_vec3 contactB0 = closestPoint_PointSegment(contactA0, w_line_segment{ pBa, pBb });
	w_vec3 contactB1 = contactB0 + (right - left) * aDir;

	w_vec3 normal = contactB0 - contactA0;
	w_float d = length(normal);

	auto degenerate = (d < EPSILON);

	d = ifThen(degenerate, 0.f, d);
	normal = ifThen(degenerate, w_vec3(0.f, 1.f, 0.f), normal / d);

	w_float radiusSum = a.radius + b.radius;

	w_float penetration = radiusSum - d;
	auto collision = (penetration >= 0.f);

	int32 mask = toBitMask(collision);

	if (!mask)
	{
		return result;
	}

	w_vec3 point0 = (contactA0 + contactB0) * w_float(0.5f);
	w_float penetration0 = penetration;
	w_vec3 normal0 = normal;
	int32 mask0 = mask;

	if (anyTrue(validMask))
	{
		point0 = ifThen(valid, outContacts[0].point, point0);
		penetration0 = ifThen(valid, outContacts[0].penetrationDepth, penetration0);
		normal0 = ifThen(valid, outContacts[0].normal, normal0);

		mask0 |= validMask;
	}

	outContacts[0].point = point0;
	outContacts[0].penetrationDepth = penetration0;
	outContacts[0].normal = normal0;
	outContacts[0].mask = mask0;

	outContacts[1].point = (contactA1 + contactB1) * w_float(0.5f);
	outContacts[1].penetrationDepth = penetration;
	outContacts[1].normal = normal;
	outContacts[1].mask = mask;

	return 2;
}









template <typename collider_a, typename collider_b, typename = void>
struct simd_intersection_available : std::false_type {};

template <typename collider_a, typename collider_b>
struct simd_intersection_available<collider_a, collider_b,
	std::void_t<decltype(intersectionSIMD(std::declval<const collider_a&>(), std::declval<const collider_b&>())) >> : std::true_type {};

template <typename collider_t> struct scalar_to_wide { using type = void; };
template <> struct scalar_to_wide<bounding_sphere> { using type = w_bounding_sphere; };
template <> struct scalar_to_wide<bounding_capsule> { using type = w_bounding_capsule; };
template <> struct scalar_to_wide<bounding_cylinder> { using type = w_bounding_cylinder; };
template <> struct scalar_to_wide<bounding_box> { using type = w_bounding_box; };
template <> struct scalar_to_wide<bounding_oriented_box> { using type = w_bounding_oriented_box; };


struct collision_write_context
{
	collision_contact* outContacts;
	constraint_body_pair* outBodyPairs;

	collider_pair* outColliderPairs;
	uint8* outContactCountPerCollision;

	uint32 numContacts;
	uint32 numCollisions;

	std::pair<collision_contact&, constraint_body_pair&> pushContact()
	{
		std::pair<collision_contact&, constraint_body_pair&> result = { outContacts[numContacts], outBodyPairs[numContacts] };
		++numContacts;
		return result;
	}

	void pushCollision(uint16 colliderA, uint16 colliderB, uint32 numContacts)
	{
		outColliderPairs[numCollisions] = { colliderA, colliderB };
		outContactCountPerCollision[numCollisions] = (uint8)numContacts;
		++numCollisions;
	}
};

static void writeWideContact(const collider_union* worldSpaceColliders, const w_collision_contact* wideContacts, uint32 numWideContacts,
	uint16* aIndices, uint16* bIndices, uint32 numValidLanes,
	collision_write_context& writeContext)
{
	if (numWideContacts > 0)
	{
		uint32 validLanesMask = (1 << numValidLanes) - 1;

		w_float restitutionA, frictionA, densityA;
		w_float restitutionB, frictionB, densityB;
		w_float rbA, rbB;

		load4(&worldSpaceColliders->material.restitution, aIndices, sizeof(collider_union),
			restitutionA, frictionA, densityA, rbA);
		load4(&worldSpaceColliders->material.restitution, bIndices, sizeof(collider_union),
			restitutionB, frictionB, densityB, rbB);

		w_float friction = clamp01(sqrt(frictionA * frictionB));
		w_float restitution = clamp01(maximum(restitutionA, restitutionB));

		w_float friction_restitution = reinterpret((convert(friction * 0xFFFF) << 16) | convert(restitution * 0xFFFF));

		rbA >>= 16;
		rbB >>= 16;
		w_int bodyPairs = reinterpret((rbB << 16) | rbA);


		uint32 numContactsPerLane[COLLISION_SIMD_WIDTH] = {};
		for (uint32 j = 0; j < numWideContacts; ++j)
		{
			uint32 mask = wideContacts[j].mask;
			ASSERT(mask != 0);

			mask &= validLanesMask;

			for (uint32 k = 0; k < numValidLanes; ++k)
			{
				if (mask & (1 << k))
				{
					++numContactsPerLane[k];
				}
			}
		}
		uint32 offsetPerLane[COLLISION_SIMD_WIDTH];
		exclusivePrefixSum(numContactsPerLane, offsetPerLane, numValidLanes);

		for (uint32 k = 0; k < numValidLanes; ++k)
		{
			if (numContactsPerLane[k] > 0)
			{
				writeContext.pushCollision(aIndices[k], bIndices[k], numContactsPerLane[k]);
			}
		}

		for (uint32 j = 0; j < numWideContacts; ++j)
		{
			const w_collision_contact& c = wideContacts[j];

			uint32 mask = c.mask;
			ASSERT(mask != 0);

			mask &= validLanesMask;

			if (mask)
			{
				w_float v[] =
				{
					c.point.x,
					c.point.y,
					c.point.z,
					c.penetrationDepth,
					c.normal.x,
					c.normal.y,
					c.normal.z,
					friction_restitution,
				};

#if COLLISION_SIMD_WIDTH == 4
				transpose(v[0], v[1], v[2], v[3]);
				transpose(v[4], v[5], v[6], v[7]);
#elif COLLISION_SIMD_WIDTH == 8
				transpose(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7]);
#endif

				for (uint32 k = 0; k < numValidLanes; ++k)
				{
					if (mask & (1 << k))
					{
						uint32 offset = offsetPerLane[k];

						auto& [outContact, outBodyPair] = writeContext.pushContact();

						v[k].store((float*)&outContact);
#if COLLISION_SIMD_WIDTH == 4
						v[k + 4].store((float*)&outContact + 4);
#endif

						*(int*)&outBodyPair = bodyPairs[k];
						
						++offsetPerLane[k];
					}
				}
			}
		}
	}
}

static void writeScalarContact(const collider_union* worldSpaceColliders, const contact_manifold& contact,
	uint16 aIndex, uint16 bIndex,
	collision_write_context& writeContext)
{
	const collider_union* colliderA = worldSpaceColliders + aIndex;
	const collider_union* colliderB = worldSpaceColliders + bIndex;

	uint16 rbA = colliderA->objectIndex;
	uint16 rbB = colliderB->objectIndex;

	physics_material propsA = colliderA->material;
	physics_material propsB = colliderB->material;

	float friction = clamp01(sqrt(propsA.friction * propsB.friction));
	float restitution = clamp01(max(propsA.restitution, propsB.restitution));

	uint32 friction_restitution = ((uint32)(friction * 0xFFFF) << 16) | (uint32)(restitution * 0xFFFF);

	writeContext.pushCollision(aIndex, bIndex, contact.numContacts);

	for (uint32 contactIndex = 0; contactIndex < contact.numContacts; ++contactIndex)
	{
		auto& [outContact, outBodyPair] = writeContext.pushContact();

		outContact.normal = contact.collisionNormal;
		outContact.penetrationDepth = contact.contacts[contactIndex].penetrationDepth;
		outContact.point = contact.contacts[contactIndex].point;
		outContact.friction_restitution = friction_restitution;

		outBodyPair.rbA = rbA;
		outBodyPair.rbB = rbB;
	}
}

template <typename collider_a, typename collider_b>
static void collisionSIMD(const collider_union* worldSpaceColliders, collider_pair* colliderPairs, uint32 numColliderPairs,
	collision_write_context& writeContext)
{
	for (uint32 i = 0; i < numColliderPairs; i += COLLISION_SIMD_WIDTH)
	{
		uint32 numValidLanes = clamp(numColliderPairs - i, 0u, COLLISION_SIMD_WIDTH);

		uint16 aIndices[COLLISION_SIMD_WIDTH] = {};
		uint16 bIndices[COLLISION_SIMD_WIDTH] = {};

		// TODO: This could be done with SIMD.
		for (uint32 j = 0; j < numValidLanes; ++j)
		{
			collider_pair pair = colliderPairs[i + j];
			aIndices[j] = pair.colliderA;
			bIndices[j] = pair.colliderB;
		}

		collider_a bvA = loadBoundingVolumeSIMD<collider_a>(worldSpaceColliders, aIndices);
		collider_b bvB = loadBoundingVolumeSIMD<collider_b>(worldSpaceColliders, bIndices);

		w_collision_contact wideContacts[4];
		uint32 numWideContacts = intersectionSIMD(bvA, bvB, wideContacts);

		writeWideContact(worldSpaceColliders, wideContacts, numWideContacts, aIndices, bIndices, numValidLanes, writeContext);
	}
}

template <typename collider_a, typename collider_b>
static void collisionScalar(const collider_union* worldSpaceColliders, collider_pair* colliderPairs, uint32 numColliderPairs,
	collision_write_context& writeContext)
{
	for (uint32 i = 0; i < numColliderPairs; ++i)
	{
		collider_pair pair = colliderPairs[i];

		const collider_a& bvA = loadBoundingVolumeScalar<collider_a>(worldSpaceColliders, pair.colliderA);
		const collider_b& bvB = loadBoundingVolumeScalar<collider_b>(worldSpaceColliders, pair.colliderB);

		contact_manifold contact;

		if (intersection(bvA, bvB, contact))
		{
			writeScalarContact(worldSpaceColliders, contact, pair.colliderA, pair.colliderB, writeContext);
		}
	}
}

template <typename collider_a, typename collider_b>
static void collision(const collider_union* worldSpaceColliders, collider_pair* colliderPairs, uint32 numColliderPairs, 
	collision_write_context& writeContext, bool simd)
{
	if (simd)
	{
		using wide_collider_a = scalar_to_wide<collider_a>::type;
		using wide_collider_b = scalar_to_wide<collider_b>::type;

		if constexpr (simd_intersection_available<wide_collider_a, wide_collider_b>::value)
		{
			collisionSIMD<wide_collider_a, wide_collider_b>(worldSpaceColliders, colliderPairs, numColliderPairs, writeContext);
		}
		else
		{
			collisionScalar<collider_a, collider_b>(worldSpaceColliders, colliderPairs, numColliderPairs, writeContext);
		}
	}
	else
	{
		collisionScalar<collider_a, collider_b>(worldSpaceColliders, colliderPairs, numColliderPairs, writeContext);
	}
}

narrowphase_result narrowphase(const collider_union* worldSpaceColliders, collider_pair* colliderPairs, uint32 numCollisionPairs, memory_arena& arena,
	collision_contact* outContacts, constraint_body_pair* outBodyPairs, 
	collider_pair* outColliderPairs, uint8* outContactCountPerCollision,
	non_collision_interaction* outNonCollisionInteractions,
	bool simd)
{
	CPU_PROFILE_BLOCK("Narrow phase");

	uint32 numNonCollisionInteractions = 0;

	uint32 numCollisionChecks = 0;
	uint32 numIntersectionChecks = 0;
	
	memory_marker marker = arena.getMarker();

	uint32 collisionCountMatrix[collider_type_count][collider_type_count] = {};
	uint32 intersectionCountMatrix[collider_type_count][collider_type_count] = {};

	{
		CPU_PROFILE_BLOCK("Prune, classify and count");

		// Prune collision pairs based on type and RB index.

		uint32 count = numCollisionPairs;
		for (uint32 i = 0; i < count; ++i)
		{
			collider_pair pair = colliderPairs[i];
			const collider_union* colliderA = worldSpaceColliders + pair.colliderA;
			const collider_union* colliderB = worldSpaceColliders + pair.colliderB;

			if (colliderA->objectType != physics_object_type_rigid_body && colliderB->objectType != physics_object_type_rigid_body)
			{
				// If none of the objects is a rigid body, no collision is generated.
				continue;
			}

			if (colliderA->objectType == physics_object_type_rigid_body && colliderB->objectType == physics_object_type_rigid_body
				&& colliderA->objectIndex == colliderB->objectIndex)
			{
				// If both colliders belong to the same rigid body, no collision is generated.
				continue;
			}


			// At this point, either one or both colliders belong to a rigid body. One of them could be a force field, trigger or a solo collider still.

			pair = (colliderA->type < colliderB->type) ? pair : collider_pair{ pair.colliderB, pair.colliderA };
			colliderA = worldSpaceColliders + pair.colliderA;
			colliderB = worldSpaceColliders + pair.colliderB;

			if (colliderA->objectType == physics_object_type_rigid_body && colliderB->objectType == physics_object_type_rigid_body // Both rigid bodies.
				|| colliderA->objectType == physics_object_type_static_collider || colliderB->objectType == physics_object_type_static_collider) // One is a static collider.
			{
				++collisionCountMatrix[colliderA->type][colliderB->type];

				colliderPairs[numCollisionChecks++] = pair;
			}
			else
			{
				++intersectionCountMatrix[colliderA->type][colliderB->type];

				uint32 lastIndex = numCollisionPairs - 1 - numIntersectionChecks++;
				colliderPairs[i] = colliderPairs[lastIndex];
				colliderPairs[lastIndex] = pair;

				--i;
				--count;
			}
		}
	}

	collider_pair* intersectionPairs = colliderPairs + (numCollisionPairs - numIntersectionChecks);

	collider_pair* collisionPairMatrix[collider_type_count][collider_type_count];
	collider_pair* intersectionPairMatrix[collider_type_count][collider_type_count];

	{
		collider_pair* sortedCollisionPairs = arena.allocate<collider_pair>(numCollisionChecks);
		collider_pair* sortedIntersectionPairs = arena.allocate<collider_pair>(numIntersectionChecks);

		uint32 collisionTotal = 0;
		uint32 intersectionTotal = 0;

		for (uint32 i = 0; i < collider_type_count; ++i)
		{
			for (uint32 j = i; j < collider_type_count; ++j)
			{
				collisionPairMatrix[i][j] = sortedCollisionPairs + collisionTotal;
				collisionTotal += collisionCountMatrix[i][j];

				intersectionPairMatrix[i][j] = sortedIntersectionPairs + intersectionTotal;
				intersectionTotal += intersectionCountMatrix[i][j];
			}
		}
	}


	{
		CPU_PROFILE_BLOCK("Sort into buckets");

		uint32 collisionWriteIndexMatrix[collider_type_count][collider_type_count] = {};
		uint32 intersectionWriteIndexMatrix[collider_type_count][collider_type_count] = {};

		for (uint32 i = 0; i < numCollisionChecks; ++i)
		{
			collider_pair pair = colliderPairs[i];

			const collider_union* colliderA = worldSpaceColliders + pair.colliderA;
			const collider_union* colliderB = worldSpaceColliders + pair.colliderB;

			uint32& writeIndex = collisionWriteIndexMatrix[colliderA->type][colliderB->type];
			collisionPairMatrix[colliderA->type][colliderB->type][writeIndex++] = pair;
		}


		for (uint32 i = 0; i < numIntersectionChecks; ++i)
		{
			collider_pair pair = intersectionPairs[i];

			const collider_union* colliderA = worldSpaceColliders + pair.colliderA;
			const collider_union* colliderB = worldSpaceColliders + pair.colliderB;

			uint32& writeIndex = intersectionWriteIndexMatrix[colliderA->type][colliderB->type];
			intersectionPairMatrix[colliderA->type][colliderB->type][writeIndex++] = pair;
		}
	}



	// Collision checks.


	// SPHERE.

	collision_write_context writeContext;
	writeContext.numCollisions = 0;
	writeContext.numContacts = 0;
	writeContext.outContacts = outContacts;
	writeContext.outBodyPairs = outBodyPairs;
	writeContext.outColliderPairs = outColliderPairs;
	writeContext.outContactCountPerCollision = outContactCountPerCollision;

	{
		CPU_PROFILE_BLOCK("Check for collisions");

		collision<bounding_sphere, bounding_sphere>(worldSpaceColliders,
			collisionPairMatrix[collider_type_sphere][collider_type_sphere], collisionCountMatrix[collider_type_sphere][collider_type_sphere],
			writeContext, simd);

		collision<bounding_sphere, bounding_capsule>(worldSpaceColliders,
			collisionPairMatrix[collider_type_sphere][collider_type_capsule], collisionCountMatrix[collider_type_sphere][collider_type_capsule],
			writeContext, simd);

		collision<bounding_sphere, bounding_cylinder>(worldSpaceColliders,
			collisionPairMatrix[collider_type_sphere][collider_type_cylinder], collisionCountMatrix[collider_type_sphere][collider_type_cylinder],
			writeContext, simd);

		collision<bounding_sphere, bounding_box>(worldSpaceColliders,
			collisionPairMatrix[collider_type_sphere][collider_type_aabb], collisionCountMatrix[collider_type_sphere][collider_type_aabb],
			writeContext, simd);

		collision<bounding_sphere, bounding_oriented_box>(worldSpaceColliders,
			collisionPairMatrix[collider_type_sphere][collider_type_obb], collisionCountMatrix[collider_type_sphere][collider_type_obb],
			writeContext, simd);

		collision<bounding_sphere, bounding_hull>(worldSpaceColliders,
			collisionPairMatrix[collider_type_sphere][collider_type_hull], collisionCountMatrix[collider_type_sphere][collider_type_hull],
			writeContext, simd);


		// CAPSULE.

		collision<bounding_capsule, bounding_capsule>(worldSpaceColliders,
			collisionPairMatrix[collider_type_capsule][collider_type_capsule], collisionCountMatrix[collider_type_capsule][collider_type_capsule],
			writeContext, simd);

		collision<bounding_capsule, bounding_cylinder>(worldSpaceColliders,
			collisionPairMatrix[collider_type_capsule][collider_type_cylinder], collisionCountMatrix[collider_type_capsule][collider_type_cylinder],
			writeContext, simd);

		collision<bounding_capsule, bounding_box>(worldSpaceColliders,
			collisionPairMatrix[collider_type_capsule][collider_type_aabb], collisionCountMatrix[collider_type_capsule][collider_type_aabb],
			writeContext, simd);

		collision<bounding_capsule, bounding_oriented_box>(worldSpaceColliders,
			collisionPairMatrix[collider_type_capsule][collider_type_obb], collisionCountMatrix[collider_type_capsule][collider_type_obb],
			writeContext, simd);

		collision<bounding_capsule, bounding_hull>(worldSpaceColliders,
			collisionPairMatrix[collider_type_capsule][collider_type_hull], collisionCountMatrix[collider_type_capsule][collider_type_hull],
			writeContext, simd);


		// CYLINDER.

		collision<bounding_cylinder, bounding_cylinder>(worldSpaceColliders,
			collisionPairMatrix[collider_type_cylinder][collider_type_cylinder], collisionCountMatrix[collider_type_cylinder][collider_type_cylinder],
			writeContext, simd);

		collision<bounding_cylinder, bounding_box>(worldSpaceColliders,
			collisionPairMatrix[collider_type_cylinder][collider_type_aabb], collisionCountMatrix[collider_type_cylinder][collider_type_aabb],
			writeContext, simd);

		collision<bounding_cylinder, bounding_oriented_box>(worldSpaceColliders,
			collisionPairMatrix[collider_type_cylinder][collider_type_obb], collisionCountMatrix[collider_type_cylinder][collider_type_obb],
			writeContext, simd);

		collision<bounding_cylinder, bounding_hull>(worldSpaceColliders,
			collisionPairMatrix[collider_type_cylinder][collider_type_hull], collisionCountMatrix[collider_type_cylinder][collider_type_hull],
			writeContext, simd);


		// AABB.

		collision<bounding_box, bounding_box>(worldSpaceColliders,
			collisionPairMatrix[collider_type_aabb][collider_type_aabb], collisionCountMatrix[collider_type_aabb][collider_type_aabb],
			writeContext, simd);

		collision<bounding_box, bounding_oriented_box>(worldSpaceColliders,
			collisionPairMatrix[collider_type_aabb][collider_type_obb], collisionCountMatrix[collider_type_aabb][collider_type_obb],
			writeContext, simd);

		collision<bounding_box, bounding_hull>(worldSpaceColliders,
			collisionPairMatrix[collider_type_aabb][collider_type_hull], collisionCountMatrix[collider_type_aabb][collider_type_hull],
			writeContext, simd);


		// OBB.

		collision<bounding_oriented_box, bounding_oriented_box>(worldSpaceColliders,
			collisionPairMatrix[collider_type_obb][collider_type_obb], collisionCountMatrix[collider_type_obb][collider_type_obb],
			writeContext, simd);

		collision<bounding_oriented_box, bounding_hull>(worldSpaceColliders,
			collisionPairMatrix[collider_type_obb][collider_type_hull], collisionCountMatrix[collider_type_obb][collider_type_hull],
			writeContext, simd);


		// HULL.

		collision<bounding_hull, bounding_hull>(worldSpaceColliders,
			collisionPairMatrix[collider_type_hull][collider_type_hull], collisionCountMatrix[collider_type_hull][collider_type_hull],
			writeContext, simd);
	}

	{
		CPU_PROFILE_BLOCK("Check for overlaps");

		for (uint32 i = 0; i < collider_type_count; ++i)
		{
			for (uint32 j = i; j < collider_type_count; ++j)
			{
				uint32 count = intersectionCountMatrix[i][j];
				collider_pair* pairs = intersectionPairMatrix[i][j];

				for (uint32 k = 0; k < count; ++k)
				{
					non_collision_interaction interaction;
					if (overlapCheck(worldSpaceColliders, pairs[k], interaction))
					{
						outNonCollisionInteractions[numNonCollisionInteractions++] = interaction;
					}
				}
			}
		}
	}


	// TODO: Write valid collision pairs and numCollisions.


	arena.resetToMarker(marker);


	return narrowphase_result{ writeContext.numCollisions, writeContext.numContacts, numNonCollisionInteractions };
}



```

`src/physics/collision_narrow.h`:

```h
#pragma once

#include "core/math.h"
#include "physics.h"

struct collider_union;
struct collider_pair;

struct non_collision_interaction
{
	uint16 rigidBodyIndex;
	uint16 otherIndex;
	physics_object_type otherType;
};

struct narrowphase_result
{
	uint32 numCollisions;
	uint32 numContacts;						// Number of contacts between colliders. Each collision may have up to 4 contacts for a stable contact.
	uint32 numNonCollisionInteractions;		// Number of interactions between RBs and triggers, force fields etc.
};

// outColliderPairs may be the same as colliderPairs
narrowphase_result narrowphase(const collider_union* worldSpaceColliders, collider_pair* colliderPairs, uint32 numCollisionPairs, memory_arena& arena,
	collision_contact* outContacts, constraint_body_pair* outBodyPairs, // result.numContacts many.
	collider_pair* outColliderPairs, uint8* outContactCountPerCollision, // result.numCollisions many.
	non_collision_interaction* outNonCollisionInteractions,			// result.numNonCollisionInteractions many.
	bool simd);


```

`src/physics/collision_sat.h`:

```h
#pragma once

#include "collision_gjk.h"

struct sat_result
{
	float minPenetration = FLT_MAX;
	vec4 plane;

	uint32 faceIndex;
	uint32 edgeIndexA;
	uint32 edgeIndexB;
};

enum sat_status
{
	sat_none,
	sat_no_intersection,
	sat_better_intersection,
	sat_worse_intersection,
};

struct sat_edge
{
	vec3 start;
	vec3 direction;
};

template <typename shape_t>
static sat_status satFaceIntersectionTest(vec4* planes, uint32 numPlanes, const shape_t& otherShape, sat_result& outResult)
{
	float minPenetration = outResult.minPenetration;
	uint32 faceIndex = 0;

	for (uint32 i = 0; i < numPlanes; ++i)
	{
		vec4 plane = planes[i];
		vec3 normal = plane.xyz;

		vec3 farthest = otherShape(-normal);

		float sd = signedDistanceToPlane(farthest, plane);
		if (sd > 0.f)
		{
			return sat_no_intersection;
		}

		float penetration = -sd;
		if (penetration < minPenetration)
		{
			minPenetration = penetration;
			faceIndex = i;
		}
	}

	if (minPenetration < outResult.minPenetration)
	{
		outResult.minPenetration = minPenetration;
		outResult.plane = planes[faceIndex];
		outResult.faceIndex = faceIndex;
		return sat_better_intersection;
	}
	return sat_worse_intersection;
}

static bool isMinkowskiFace(vec3 a, vec3 b, vec3 c, vec3 d)
{
	vec3 bxa = cross(b, a);
	vec3 dxc = cross(d, c);

	float cba = dot(c, bxa);
	float dba = dot(d, bxa);
	float adc = dot(a, dxc);
	float bdc = dot(b, dxc);

	return cba * dba < 0.f && adc * bdc < 0.f && cba * bdc > 0.f;
}

template <typename shape_t>
static sat_status satEdgeIntersectionTest(sat_edge* edgesA, uint32 numEdgesA, vec3 centerA, sat_edge* edgesB, uint32 numEdgesB, const shape_t& shapeB, sat_result& outResult)
{
	float minPenetration = outResult.minPenetration;
	vec4 minPlane;
	uint32 edgeIndexA = 0;
	uint32 edgeIndexB = 0;

	for (uint32 aEdgeIndex = 0; aEdgeIndex < numEdgesA; ++aEdgeIndex)
	{
		sat_edge& aEdge = edgesA[aEdgeIndex];
		vec3 fromCenterA = aEdge.start - centerA;

		for (uint32 bEdgeIndex = 0; bEdgeIndex < numEdgesB; ++bEdgeIndex)
		{
			sat_edge& bEdge = edgesB[bEdgeIndex];

			vec3 axis = cross(aEdge.direction, bEdge.direction);
			if (dot(axis, fromCenterA) < 0.f)
			{
				axis = -axis;
			}

			float sqLength = squaredLength(axis);
			if (sqLength < 0.001f)
			{
				continue;
			}

			vec4 plane = createPlane(aEdge.start, axis / sqrt(sqLength));
			vec3 normal = plane.xyz;

			vec3 farthest = shapeB(-normal);

			float sd = signedDistanceToPlane(farthest, plane);
			if (sd > 0.f)
			{
				return sat_no_intersection;
			}

			float penetration = -sd;
			if (penetration < minPenetration)
			{
				minPenetration = penetration;
				minPlane = plane;
				edgeIndexA = aEdgeIndex;
				edgeIndexB = bEdgeIndex;
			}
		}
	}

	if (minPenetration < outResult.minPenetration)
	{
		outResult.minPenetration = minPenetration;
		outResult.plane = minPlane;
		outResult.edgeIndexA = edgeIndexA;
		outResult.edgeIndexB = edgeIndexB;
		return sat_better_intersection;
	}
	return sat_worse_intersection;
}


```

`src/physics/constraints.cpp`:

```cpp
#include "pch.h"
#include "constraints.h"
#include "physics.h"
#include "collision_narrow.h"
#include "core/cpu_profiling.h"
#include "core/math_simd.h"


#define DISTANCE_CONSTRAINT_BETA 0.1f
#define BALL_CONSTRAINT_BETA 0.1f
#define SLIDER_CONSTRAINT_BETA 0.1f
#define HINGE_ROTATION_CONSTRAINT_BETA 0.3f
#define HINGE_LIMIT_CONSTRAINT_BETA 0.1f
#define TWIST_LIMIT_CONSTRAINT_BETA 0.1f
#define SLIDER_LIMIT_CONSTRAINT_BETA 0.1f

#define DT_THRESHOLD 1e-5f


#if CONSTRAINT_SIMD_WIDTH == 4
typedef w4_float w_float;
typedef w4_int w_int;
#elif CONSTRAINT_SIMD_WIDTH == 8 && defined(SIMD_AVX_2)
typedef w8_float w_float;
typedef w8_int w_int;
#elif CONSTRAINT_SIMD_WIDTH == 16 && defined(SIMD_AVX_512)
typedef w16_float w_float;
typedef w16_int w_int;
#endif

typedef wN_vec2<w_float> w_vec2;
typedef wN_vec3<w_float> w_vec3;
typedef wN_vec4<w_float> w_vec4;
typedef wN_quat<w_float> w_quat;
typedef wN_mat2<w_float> w_mat2;
typedef wN_mat3<w_float> w_mat3;




struct alignas(32) simd_constraint_body_pair
{
	uint32 ab[CONSTRAINT_SIMD_WIDTH];
};

struct alignas(32) simd_constraint_slot
{
	uint32 indices[CONSTRAINT_SIMD_WIDTH];
};

static uint32 scheduleConstraintsSIMD(memory_arena& arena, const constraint_body_pair* bodyPairs, uint32 numBodyPairs, uint16 dummyRigidBodyIndex, simd_constraint_slot* outConstraintSlots)
{
	CPU_PROFILE_BLOCK("Schedule constraints SIMD");

	uint32 numConstraintSlots = 0;

	static const uint32 numBuckets = 4;
	simd_constraint_body_pair* pairBuckets[numBuckets];
	simd_constraint_slot* slotBuckets[numBuckets];
	uint32 numEntriesPerBucket[numBuckets] = {};

	w_int invalid = ~0;

	uint32 numAllocationsPerBucket = bucketize(numBodyPairs, numBuckets);

	memory_marker marker = arena.getMarker();

	for (unsigned i = 0; i < numBuckets; ++i)
	{
		pairBuckets[i] = arena.allocate<simd_constraint_body_pair>(numAllocationsPerBucket + 1);
		slotBuckets[i] = arena.allocate<simd_constraint_slot>(numAllocationsPerBucket);

		// Add padding with invalid data so we don't have to range check.
		invalid.store((int*)pairBuckets[i]->ab);
	}

	for (uint32 i = 0; i < numBodyPairs; ++i)
	{
		constraint_body_pair bodyPair = bodyPairs[i];

		// If one of the bodies is the dummy, just set it to the other for the comparison below.
		uint16 rbA = (bodyPair.rbA == dummyRigidBodyIndex) ? bodyPair.rbB : bodyPair.rbA;
		uint16 rbB = (bodyPair.rbB == dummyRigidBodyIndex) ? bodyPair.rbA : bodyPair.rbB;

		uint32 bucket = i % numBuckets;
		simd_constraint_body_pair* pairs = pairBuckets[bucket];
		simd_constraint_slot* slots = slotBuckets[bucket];


#if CONSTRAINT_SIMD_WIDTH == 4
		w_int a = _mm_set1_epi16(rbA);
		w_int b = _mm_set1_epi16(rbB);
		w_int scheduled;

		uint32 j = 0;
		for (;; ++j)
		{
			scheduled = _mm_load_si128((const __m128i*)pairs[j].ab);

			__m128i conflictsWithThisSlot = _mm_packs_epi16(_mm_cmpeq_epi16(a, scheduled), _mm_cmpeq_epi16(b, scheduled));
			if (!_mm_movemask_epi8(conflictsWithThisSlot))
			{
				break;
			}
		}
#else
		w_int a = _mm256_set1_epi16(rbA);
		w_int b = _mm256_set1_epi16(rbB);
		w_int scheduled;

		uint32 j = 0;
		for (;; ++j)
		{
			scheduled = _mm256_load_si256((const __m256i*)pairs[j].ab);

			__m256i conflictsWithThisSlot = _mm256_packs_epi16(_mm256_cmpeq_epi16(a, scheduled), _mm256_cmpeq_epi16(b, scheduled));
			if (!_mm256_movemask_epi8(conflictsWithThisSlot))
			{
				break;
			}
		}

#endif


		uint32 lane = indexOfLeastSignificantSetBit(toBitMask(reinterpret(scheduled == invalid)));

		simd_constraint_body_pair* pair = pairs + j;
		simd_constraint_slot* slot = slots + j;

		slot->indices[lane] = i;
		pair->ab[lane] = ((uint32)bodyPair.rbA << 16) | bodyPair.rbB; // Use the original indices here.

		uint32& count = numEntriesPerBucket[bucket];
		if (j == count)
		{
			// We used a new entry.
			++count;

			// Set entry at end to invalid.
			invalid.store((int*)pairs[count].ab);
		}
		else if (lane == CONSTRAINT_SIMD_WIDTH - 1)
		{
			// This entry is full -> commit it.
			w_int indices = (int32*)slot->indices;

			// Swap and pop.
			--count;
			*pair = pairs[count];
			*slot = slots[count];

			indices.store((int32*)outConstraintSlots[numConstraintSlots++].indices);

			// Set entry at end to invalid.
			invalid.store((int*)pairs[count].ab);
		}
	}

	// There are still entries left, where not all lanes are filled. We replace these indices with the first in this entry.

	for (uint32 bucket = 0; bucket < numBuckets; ++bucket)
	{
		simd_constraint_body_pair* pairs = pairBuckets[bucket];
		simd_constraint_slot* slots = slotBuckets[bucket];
		uint32 count = numEntriesPerBucket[bucket];

		for (uint32 i = 0; i < count; ++i)
		{
			w_int ab = (int32*)pairs[i].ab;
			w_int indices = (int32_t*)slots[i].indices;

			w_int firstIndex = fillWithFirstLane(indices);

			auto mask = ab == invalid;
			indices = ifThen(mask, firstIndex, indices);
			indices.store((int32*)outConstraintSlots[numConstraintSlots++].indices);
		}
	}

	arena.resetToMarker(marker);

	return numConstraintSlots;
}




distance_constraint_solver initializeDistanceVelocityConstraints(memory_arena& arena, const rigid_body_global_state* rbs, const distance_constraint* input, const constraint_body_pair* bodyPairs, uint32 count, float dt)
{
	CPU_PROFILE_BLOCK("Initialize distance constraints");

	float invDt = 1.f / dt;

	distance_constraint_update* constraints = arena.allocate<distance_constraint_update>(count);

	for (uint32 i = 0; i < count; ++i)
	{
		const distance_constraint& in = input[i];
		distance_constraint_update& out = constraints[i];

		out.rigidBodyIndexA = bodyPairs[i].rbA;
		out.rigidBodyIndexB = bodyPairs[i].rbB;

		const rigid_body_global_state& globalA = rbs[out.rigidBodyIndexA];
		const rigid_body_global_state& globalB = rbs[out.rigidBodyIndexB];

		// Relative to COG.
		out.relGlobalAnchorA = globalA.rotation * (in.localAnchorA - globalA.localCOGPosition);
		out.relGlobalAnchorB = globalB.rotation * (in.localAnchorB - globalB.localCOGPosition);

		// Global.
		vec3 globalAnchorA = globalA.position + out.relGlobalAnchorA;
		vec3 globalAnchorB = globalB.position + out.relGlobalAnchorB;

		out.u = globalAnchorB - globalAnchorA;
		float l = length(out.u);
		out.u = (l > 0.001f) ? (out.u * (1.f / l)) : vec3(0.f);

		vec3 crAu = cross(out.relGlobalAnchorA, out.u);
		vec3 crBu = cross(out.relGlobalAnchorB, out.u);
		float invMass = globalA.invMass + dot(crAu, globalA.invInertia * crAu)
					  + globalB.invMass + dot(crBu, globalB.invInertia * crBu);
		out.effectiveMass = (invMass != 0.f) ? (1.f / invMass) : 0.f;

		out.bias = 0.f;
		if (dt > DT_THRESHOLD)
		{
			out.bias = (l - in.globalLength) * (DISTANCE_CONSTRAINT_BETA * invDt);
		}

		out.impulseToAngularVelocityA = globalA.invInertia * cross(out.relGlobalAnchorA, crAu);
		out.impulseToAngularVelocityB = globalB.invInertia * cross(out.relGlobalAnchorB, crBu);
	}

	distance_constraint_solver result;
	result.constraints = constraints;
	result.count = count;
	return result;
}

void solveDistanceVelocityConstraints(distance_constraint_solver constraints, rigid_body_global_state* rbs)
{
	CPU_PROFILE_BLOCK("Solve distance constraints");

	for (uint32 i = 0; i < constraints.count; ++i)
	{
		distance_constraint_update& con = constraints.constraints[i];

		rigid_body_global_state& rbA = rbs[con.rigidBodyIndexA];
		rigid_body_global_state& rbB = rbs[con.rigidBodyIndexB];

		vec3 anchorVelocityA = rbA.linearVelocity + cross(rbA.angularVelocity, con.relGlobalAnchorA);
		vec3 anchorVelocityB = rbB.linearVelocity + cross(rbB.angularVelocity, con.relGlobalAnchorB);
		float Cdot = dot(con.u, anchorVelocityB - anchorVelocityA) + con.bias;

		float lambda = -con.effectiveMass * Cdot;
		vec3 P = lambda * con.u;
		rbA.linearVelocity -= rbA.invMass * P;
		rbA.angularVelocity -= con.impulseToAngularVelocityA * lambda;
		rbB.linearVelocity += rbB.invMass * P;
		rbB.angularVelocity += con.impulseToAngularVelocityB * lambda;
	}
}

simd_distance_constraint_solver initializeDistanceVelocityConstraintsSIMD(memory_arena& arena, const rigid_body_global_state* rbs, const distance_constraint* input, const constraint_body_pair* bodyPairs, uint32 count, float dt)
{
	CPU_PROFILE_BLOCK("Initialize distance constraints SIMD");

	simd_constraint_slot* contactSlots = arena.allocate<simd_constraint_slot>(count);
	uint32 numBatches = scheduleConstraintsSIMD(arena, bodyPairs, count, UINT16_MAX, contactSlots);

	simd_distance_constraint_batch* batches = arena.allocate<simd_distance_constraint_batch>(numBatches);

	const w_float zero = w_float::zero();
	const w_float invDt = 1.f / dt;

	for (uint32 i = 0; i < numBatches; ++i)
	{
		const simd_constraint_slot& slot = contactSlots[i];
		simd_distance_constraint_batch& batch = batches[i];

		uint16 constraintIndices[CONSTRAINT_SIMD_WIDTH];
		for (uint32 j = 0; j < CONSTRAINT_SIMD_WIDTH; ++j)
		{
			constraintIndices[j] = (uint16)slot.indices[j];
			batch.rbAIndices[j] = bodyPairs[slot.indices[j]].rbA;
			batch.rbBIndices[j] = bodyPairs[slot.indices[j]].rbB;
		}


		w_vec3 localAnchorA, localAnchorB;
		w_float globalLength;
		w_float dummy;
		load8((float*)input, constraintIndices, (uint32)sizeof(*input),
			localAnchorA.x, localAnchorA.y, localAnchorA.z, localAnchorB.x, localAnchorB.y, localAnchorB.z, globalLength, dummy);


		// Load body A.
		w_vec3 localCOGPositionA;
		w_quat rotationA;
		w_vec3 positionA;
		w_mat3 invInertiaA;
		w_float invMassA;

		load8(&rbs->rotation.x, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			rotationA.x, rotationA.y, rotationA.z, rotationA.w,
			localCOGPositionA.x, localCOGPositionA.y, localCOGPositionA.z,
			positionA.x);

		load8(&rbs->position.y, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			positionA.y, positionA.z,
			invInertiaA.m00, invInertiaA.m10, invInertiaA.m20,
			invInertiaA.m01, invInertiaA.m11, invInertiaA.m21);

		load4(&rbs->invInertia.m02, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaA.m02, invInertiaA.m12, invInertiaA.m22,
			invMassA);


		// Load body B.
		w_quat rotationB;
		w_vec3 positionB;
		w_vec3 localCOGPositionB;
		w_mat3 invInertiaB;
		w_float invMassB;

		load8(&rbs->rotation.x, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			rotationB.x, rotationB.y, rotationB.z, rotationB.w,
			localCOGPositionB.x, localCOGPositionB.y, localCOGPositionB.z,
			positionB.x);

		load8(&rbs->position.y, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			positionB.y, positionB.z,
			invInertiaB.m00, invInertiaB.m10, invInertiaB.m20,
			invInertiaB.m01, invInertiaB.m11, invInertiaB.m21);

		load4(&rbs->invInertia.m02, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaB.m02, invInertiaB.m12, invInertiaB.m22,
			invMassB);


		// Relative to COG.
		w_vec3 relGlobalAnchorA = rotationA * (localAnchorA - localCOGPositionA);
		w_vec3 relGlobalAnchorB = rotationB * (localAnchorB - localCOGPositionB);

		// Global.
		w_vec3 globalAnchorA = positionA + relGlobalAnchorA;
		w_vec3 globalAnchorB = positionB + relGlobalAnchorB;

		w_vec3 u = globalAnchorB - globalAnchorA;
		w_float l = length(u);
		u = ifThen(l > 0.001f, u * (1.f / l), w_vec3::zero());

		w_vec3 crAu = cross(relGlobalAnchorA, u);
		w_vec3 crBu = cross(relGlobalAnchorB, u);
		w_float invMass = invMassA + dot(crAu, invInertiaA * crAu)
					   + invMassB + dot(crBu, invInertiaB * crBu);
		w_float effectiveMass = ifThen(invMass != zero, 1.f / invMass, zero);

		w_float bias = zero;
		if (dt > DT_THRESHOLD)
		{
			bias = (l - globalLength) * (w_float(DISTANCE_CONSTRAINT_BETA) * invDt);
		}

		w_vec3 impulseToAngularVelocityA = invInertiaA * cross(relGlobalAnchorA, crAu);
		w_vec3 impulseToAngularVelocityB = invInertiaB * cross(relGlobalAnchorB, crBu);


		relGlobalAnchorA.x.store(batch.relGlobalAnchorA[0]);
		relGlobalAnchorA.y.store(batch.relGlobalAnchorA[1]);
		relGlobalAnchorA.z.store(batch.relGlobalAnchorA[2]);

		relGlobalAnchorB.x.store(batch.relGlobalAnchorB[0]);
		relGlobalAnchorB.y.store(batch.relGlobalAnchorB[1]);
		relGlobalAnchorB.z.store(batch.relGlobalAnchorB[2]);

		impulseToAngularVelocityA.x.store(batch.impulseToAngularVelocityA[0]);
		impulseToAngularVelocityA.y.store(batch.impulseToAngularVelocityA[1]);
		impulseToAngularVelocityA.z.store(batch.impulseToAngularVelocityA[2]);

		impulseToAngularVelocityB.x.store(batch.impulseToAngularVelocityB[0]);
		impulseToAngularVelocityB.y.store(batch.impulseToAngularVelocityB[1]);
		impulseToAngularVelocityB.z.store(batch.impulseToAngularVelocityB[2]);

		u.x.store(batch.u[0]);
		u.y.store(batch.u[1]);
		u.z.store(batch.u[2]);

		bias.store(batch.bias);
		effectiveMass.store(batch.effectiveMass);
	}

	simd_distance_constraint_solver result;
	result.batches = batches;
	result.numBatches = numBatches;
	return result;
}

void solveDistanceVelocityConstraintsSIMD(simd_distance_constraint_solver constraints, rigid_body_global_state* rbs)
{
	CPU_PROFILE_BLOCK("Solve distance constraints SIMD");

	for (uint32 i = 0; i < constraints.numBatches; ++i)
	{
		simd_distance_constraint_batch& batch = constraints.batches[i];


		// Load body A.
		w_vec3 vA, wA;
		w_float invMassA;
		w_float dummyA;

		load8(&rbs->invInertia.m22, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			dummyA, invMassA, vA.x, vA.y, vA.z, wA.x, wA.y, wA.z);


		// Load body B.
		w_vec3 vB, wB;
		w_float invMassB;
		w_float dummyB;

		load8(&rbs->invInertia.m22, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			dummyB, invMassB, vB.x, vB.y, vB.z, wB.x, wB.y, wB.z);


		// Load constraint.
		w_vec3 relGlobalAnchorA(batch.relGlobalAnchorA[0], batch.relGlobalAnchorA[1], batch.relGlobalAnchorA[2]);
		w_vec3 relGlobalAnchorB(batch.relGlobalAnchorB[0], batch.relGlobalAnchorB[1], batch.relGlobalAnchorB[2]);
		w_vec3 impulseToAngularVelocityA(batch.impulseToAngularVelocityA[0], batch.impulseToAngularVelocityA[1], batch.impulseToAngularVelocityA[2]);
		w_vec3 impulseToAngularVelocityB(batch.impulseToAngularVelocityB[0], batch.impulseToAngularVelocityB[1], batch.impulseToAngularVelocityB[2]);
		w_vec3 u(batch.u[0], batch.u[1], batch.u[2]);
		w_float bias(batch.bias);
		w_float effectiveMass(batch.effectiveMass);

		w_vec3 anchorVelocityA = vA + cross(wA, relGlobalAnchorA);
		w_vec3 anchorVelocityB = vB + cross(wB, relGlobalAnchorB);
		w_float Cdot = dot(u, anchorVelocityB - anchorVelocityA) + bias;

		w_float lambda = -effectiveMass * Cdot;
		w_vec3 P = lambda * u;
		vA -= invMassA * P;
		wA -= impulseToAngularVelocityA * lambda;
		vB += invMassB * P;
		wB += impulseToAngularVelocityB * lambda;


		store8(&rbs->invInertia.m22, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			dummyA, invMassA, vA.x, vA.y, vA.z, wA.x, wA.y, wA.z);

		store8(&rbs->invInertia.m22, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			dummyB, invMassB, vB.x, vB.y, vB.z, wB.x, wB.y, wB.z);
	}
}




ball_constraint_solver initializeBallVelocityConstraints(memory_arena& arena, const rigid_body_global_state* rbs, const ball_constraint* input, const constraint_body_pair* bodyPairs, uint32 count, float dt)
{
	CPU_PROFILE_BLOCK("Initialize ball constraints");

	float invDt = 1.f / dt;

	ball_constraint_update* constraints = arena.allocate<ball_constraint_update>(count);

	for (uint32 i = 0; i < count; ++i)
	{
		const ball_constraint& in = input[i];
		ball_constraint_update& out = constraints[i];

		out.rigidBodyIndexA = bodyPairs[i].rbA;
		out.rigidBodyIndexB = bodyPairs[i].rbB;

		const rigid_body_global_state& globalA = rbs[out.rigidBodyIndexA];
		const rigid_body_global_state& globalB = rbs[out.rigidBodyIndexB];

		// Relative to COG.
		out.relGlobalAnchorA = globalA.rotation * (in.localAnchorA - globalA.localCOGPosition);
		out.relGlobalAnchorB = globalB.rotation * (in.localAnchorB - globalB.localCOGPosition);

		// Global.
		vec3 globalAnchorA = globalA.position + out.relGlobalAnchorA;
		vec3 globalAnchorB = globalB.position + out.relGlobalAnchorB;

		mat3 skewMatA = getSkewMatrix(out.relGlobalAnchorA);
		mat3 skewMatB = getSkewMatrix(out.relGlobalAnchorB);
		
		out.invEffectiveMass = skewMatA * globalA.invInertia * transpose(skewMatA)
							 + skewMatB * globalB.invInertia * transpose(skewMatB)
							 + mat3::identity * (globalA.invMass + globalB.invMass);

		out.bias = 0.f;
		if (dt > DT_THRESHOLD)
		{
			out.bias = (globalAnchorB - globalAnchorA) * (BALL_CONSTRAINT_BETA * invDt);
		}
	}

	ball_constraint_solver result;
	result.constraints = constraints;
	result.count = count;
	return result;
}

void solveBallVelocityConstraints(ball_constraint_solver constraints, rigid_body_global_state* rbs)
{
	CPU_PROFILE_BLOCK("Solve ball constraints");

	for (uint32 i = 0; i < constraints.count; ++i)
	{
		ball_constraint_update& con = constraints.constraints[i];

		rigid_body_global_state& rbA = rbs[con.rigidBodyIndexA];
		rigid_body_global_state& rbB = rbs[con.rigidBodyIndexB];

		vec3 anchorVelocityA = rbA.linearVelocity + cross(rbA.angularVelocity, con.relGlobalAnchorA);
		vec3 anchorVelocityB = rbB.linearVelocity + cross(rbB.angularVelocity, con.relGlobalAnchorB);
		vec3 Cdot = anchorVelocityB - anchorVelocityA + con.bias;

		vec3 P = solveLinearSystem(con.invEffectiveMass, -Cdot);
		rbA.linearVelocity -= rbA.invMass * P;
		rbA.angularVelocity -= rbA.invInertia * cross(con.relGlobalAnchorA, P);
		rbB.linearVelocity += rbB.invMass * P;
		rbB.angularVelocity += rbB.invInertia * cross(con.relGlobalAnchorB, P);
	}
}

simd_ball_constraint_solver initializeBallVelocityConstraintsSIMD(memory_arena& arena, const rigid_body_global_state* rbs, const ball_constraint* input, const constraint_body_pair* bodyPairs, uint32 count, float dt)
{
	CPU_PROFILE_BLOCK("Initialize distance constraints SIMD");

	simd_constraint_slot* contactSlots = arena.allocate<simd_constraint_slot>(count);
	uint32 numBatches = scheduleConstraintsSIMD(arena, bodyPairs, count, UINT16_MAX, contactSlots);

	simd_ball_constraint_batch* batches = arena.allocate<simd_ball_constraint_batch>(numBatches);

	const w_float zero = w_float::zero();
	const w_float invDt = 1.f / dt;
	const w_float one = 1.f;

	const w_mat3 identity(one, zero, zero,
		zero, one, zero,
		zero, zero, one);

	for (uint32 i = 0; i < numBatches; ++i)
	{
		const simd_constraint_slot& slot = contactSlots[i];
		simd_ball_constraint_batch& batch = batches[i];

		uint16 constraintIndices[CONSTRAINT_SIMD_WIDTH];
		for (uint32 j = 0; j < CONSTRAINT_SIMD_WIDTH; ++j)
		{
			constraintIndices[j] = (uint16)slot.indices[j];
			batch.rbAIndices[j] = bodyPairs[slot.indices[j]].rbA;
			batch.rbBIndices[j] = bodyPairs[slot.indices[j]].rbB;
		}

		// Load body A.
		w_vec3 localCOGPositionA;
		w_quat rotationA;
		w_vec3 positionA;
		w_mat3 invInertiaA;
		w_float invMassA;

		load8(&rbs->rotation.x, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			rotationA.x, rotationA.y, rotationA.z, rotationA.w,
			localCOGPositionA.x, localCOGPositionA.y, localCOGPositionA.z,
			positionA.x);

		load8(&rbs->position.y, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			positionA.y, positionA.z,
			invInertiaA.m00, invInertiaA.m10, invInertiaA.m20,
			invInertiaA.m01, invInertiaA.m11, invInertiaA.m21);

		load4(&rbs->invInertia.m02, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaA.m02, invInertiaA.m12, invInertiaA.m22,
			invMassA);


		// Load body B.
		w_quat rotationB;
		w_vec3 positionB;
		w_vec3 localCOGPositionB;
		w_mat3 invInertiaB;
		w_float invMassB;

		load8(&rbs->rotation.x, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			rotationB.x, rotationB.y, rotationB.z, rotationB.w,
			localCOGPositionB.x, localCOGPositionB.y, localCOGPositionB.z,
			positionB.x);

		load8(&rbs->position.y, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			positionB.y, positionB.z,
			invInertiaB.m00, invInertiaB.m10, invInertiaB.m20,
			invInertiaB.m01, invInertiaB.m11, invInertiaB.m21);

		load4(&rbs->invInertia.m02, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaB.m02, invInertiaB.m12, invInertiaB.m22,
			invMassB);



		w_vec3 localAnchorA, localAnchorB;
		w_float dummy0, dummy1;
		load8((float*)input, constraintIndices, (uint32)sizeof(*input),
			localAnchorA.x, localAnchorA.y, localAnchorA.z, localAnchorB.x, localAnchorB.y, localAnchorB.z, dummy0, dummy1);


		// Relative to COG.
		w_vec3 relGlobalAnchorA = rotationA * (localAnchorA - localCOGPositionA);
		w_vec3 relGlobalAnchorB = rotationB * (localAnchorB - localCOGPositionB);

		// Global.
		w_vec3 globalAnchorA = positionA + relGlobalAnchorA;
		w_vec3 globalAnchorB = positionB + relGlobalAnchorB;

		w_mat3 skewMatA = getSkewMatrix(relGlobalAnchorA);
		w_mat3 skewMatB = getSkewMatrix(relGlobalAnchorB);
		
		w_mat3 invEffectiveMass = skewMatA * invInertiaA * transpose(skewMatA)
							   + skewMatB * invInertiaB * transpose(skewMatB);
		w_float invMassSum = invMassA + invMassB;
		invEffectiveMass.m00 += invMassSum;
		invEffectiveMass.m11 += invMassSum;
		invEffectiveMass.m22 += invMassSum;

		w_vec3 bias = zero;
		if (dt > DT_THRESHOLD)
		{
			bias = (globalAnchorB - globalAnchorA) * (w_float(BALL_CONSTRAINT_BETA) * invDt);
		}

		relGlobalAnchorA.x.store(batch.relGlobalAnchorA[0]);
		relGlobalAnchorA.y.store(batch.relGlobalAnchorA[1]);
		relGlobalAnchorA.z.store(batch.relGlobalAnchorA[2]);

		relGlobalAnchorB.x.store(batch.relGlobalAnchorB[0]);
		relGlobalAnchorB.y.store(batch.relGlobalAnchorB[1]);
		relGlobalAnchorB.z.store(batch.relGlobalAnchorB[2]);

		bias.x.store(batch.bias[0]);
		bias.y.store(batch.bias[1]);
		bias.z.store(batch.bias[2]);

		invEffectiveMass.m[0].store(batch.invEffectiveMass[0]);
		invEffectiveMass.m[1].store(batch.invEffectiveMass[1]);
		invEffectiveMass.m[2].store(batch.invEffectiveMass[2]);
		invEffectiveMass.m[3].store(batch.invEffectiveMass[3]);
		invEffectiveMass.m[4].store(batch.invEffectiveMass[4]);
		invEffectiveMass.m[5].store(batch.invEffectiveMass[5]);
		invEffectiveMass.m[6].store(batch.invEffectiveMass[6]);
		invEffectiveMass.m[7].store(batch.invEffectiveMass[7]);
		invEffectiveMass.m[8].store(batch.invEffectiveMass[8]);
	}

	simd_ball_constraint_solver result;
	result.batches = batches;
	result.numBatches = numBatches;
	return result;
}

void solveBallVelocityConstraintsSIMD(simd_ball_constraint_solver constraints, rigid_body_global_state* rbs)
{
	CPU_PROFILE_BLOCK("Solve ball constraints SIMD");

	for (uint32 i = 0; i < constraints.numBatches; ++i)
	{
		simd_ball_constraint_batch& batch = constraints.batches[i];


		// Load body A.
		w_vec3 vA, wA;
		w_float invMassA;
		w_mat3 invInertiaA;

		load8(&rbs->invInertia.m00, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaA.m00, invInertiaA.m10, invInertiaA.m20,
			invInertiaA.m01, invInertiaA.m11, invInertiaA.m21,
			invInertiaA.m02, invInertiaA.m12);

		load8(&rbs->invInertia.m22, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaA.m22, invMassA, vA.x, vA.y, vA.z, wA.x, wA.y, wA.z);


		// Load body B.
		w_vec3 vB, wB;
		w_float invMassB;
		w_mat3 invInertiaB;

		load8(&rbs->invInertia.m00, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaB.m00, invInertiaB.m10, invInertiaB.m20,
			invInertiaB.m01, invInertiaB.m11, invInertiaB.m21,
			invInertiaB.m02, invInertiaB.m12);

		load8(&rbs->invInertia.m22, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaB.m22, invMassB, vB.x, vB.y, vB.z, wB.x, wB.y, wB.z);


		// Load constraint.
		w_vec3 relGlobalAnchorA(batch.relGlobalAnchorA[0], batch.relGlobalAnchorA[1], batch.relGlobalAnchorA[2]);
		w_vec3 relGlobalAnchorB(batch.relGlobalAnchorB[0], batch.relGlobalAnchorB[1], batch.relGlobalAnchorB[2]);
		w_vec3 bias(batch.bias[0], batch.bias[1], batch.bias[2]);
		w_mat3 invEffectiveMass;
		invEffectiveMass.m[0] = w_float(batch.invEffectiveMass[0]);
		invEffectiveMass.m[1] = w_float(batch.invEffectiveMass[1]);
		invEffectiveMass.m[2] = w_float(batch.invEffectiveMass[2]);
		invEffectiveMass.m[3] = w_float(batch.invEffectiveMass[3]);
		invEffectiveMass.m[4] = w_float(batch.invEffectiveMass[4]);
		invEffectiveMass.m[5] = w_float(batch.invEffectiveMass[5]);
		invEffectiveMass.m[6] = w_float(batch.invEffectiveMass[6]);
		invEffectiveMass.m[7] = w_float(batch.invEffectiveMass[7]);
		invEffectiveMass.m[8] = w_float(batch.invEffectiveMass[8]);

		w_vec3 anchorVelocityA = vA + cross(wA, relGlobalAnchorA);
		w_vec3 anchorVelocityB = vB + cross(wB, relGlobalAnchorB);
		w_vec3 Cdot = anchorVelocityB - anchorVelocityA + bias;

		w_vec3 P = solveLinearSystem(invEffectiveMass, -Cdot);
		vA -= invMassA * P;
		wA -= invInertiaA * cross(relGlobalAnchorA, P);
		vB += invMassB * P;
		wB += invInertiaB * cross(relGlobalAnchorB, P);


		store8(&rbs->invInertia.m22, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaA.m22, invMassA, vA.x, vA.y, vA.z, wA.x, wA.y, wA.z);

		store8(&rbs->invInertia.m22, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaB.m22, invMassB, vB.x, vB.y, vB.z, wB.x, wB.y, wB.z);
	}
}


fixed_constraint_solver initializeFixedVelocityConstraints(memory_arena& arena, const rigid_body_global_state* rbs, const fixed_constraint* input, const constraint_body_pair* bodyPairs, uint32 count, float dt)
{
	CPU_PROFILE_BLOCK("Initialize fixed constraints");

	float invDt = 1.f / dt;

	fixed_constraint_update* constraints = arena.allocate<fixed_constraint_update>(count);

	for (uint32 i = 0; i < count; ++i)
	{
		const fixed_constraint& in = input[i];
		fixed_constraint_update& out = constraints[i];

		out.rigidBodyIndexA = bodyPairs[i].rbA;
		out.rigidBodyIndexB = bodyPairs[i].rbB;

		const rigid_body_global_state& globalA = rbs[out.rigidBodyIndexA];
		const rigid_body_global_state& globalB = rbs[out.rigidBodyIndexB];

		// Relative to COG.
		out.relGlobalAnchorA = globalA.rotation * (in.localAnchorA - globalA.localCOGPosition);
		out.relGlobalAnchorB = globalB.rotation * (in.localAnchorB - globalB.localCOGPosition);

		// Global.
		vec3 globalAnchorA = globalA.position + out.relGlobalAnchorA;
		vec3 globalAnchorB = globalB.position + out.relGlobalAnchorB;

		mat3 skewMatA = getSkewMatrix(out.relGlobalAnchorA);
		mat3 skewMatB = getSkewMatrix(out.relGlobalAnchorB);

		out.invEffectiveTranslationMass = skewMatA * globalA.invInertia * transpose(skewMatA)
										+ skewMatB * globalB.invInertia * transpose(skewMatB)
										+ mat3::identity * (globalA.invMass + globalB.invMass);

		out.invEffectiveRotationMass = globalA.invInertia + globalB.invInertia;

		out.translationBias = vec3(0.f, 0.f, 0.f);
		out.rotationBias = vec3(0.f, 0.f, 0.f);

		if (dt > DT_THRESHOLD)
		{
			out.translationBias = (globalAnchorB - globalAnchorA) * (BALL_CONSTRAINT_BETA * invDt);

			quat rotationError = globalB.rotation * in.initialInvRotationDifference * conjugate(globalA.rotation);
			out.rotationBias = rotationError.v * (SLIDER_CONSTRAINT_BETA * invDt * 2.f);
		}
	}

	fixed_constraint_solver result;
	result.constraints = constraints;
	result.count = count;
	return result;
}

void solveFixedVelocityConstraints(fixed_constraint_solver constraints, rigid_body_global_state* rbs)
{
	CPU_PROFILE_BLOCK("Solve fixed constraints");

	for (uint32 i = 0; i < constraints.count; ++i)
	{
		fixed_constraint_update& con = constraints.constraints[i];

		rigid_body_global_state& rbA = rbs[con.rigidBodyIndexA];
		rigid_body_global_state& rbB = rbs[con.rigidBodyIndexB];

		// Rotation part.
		{
			vec3 Cdot = rbB.angularVelocity - rbA.angularVelocity;

			vec3 rotationLambda = solveLinearSystem(con.invEffectiveRotationMass, -(Cdot + con.rotationBias));
			rbA.angularVelocity -= rbA.invInertia * rotationLambda;
			rbB.angularVelocity += rbB.invInertia * rotationLambda;
		}

		// Position part.
		{
			vec3 anchorVelocityA = rbA.linearVelocity + cross(rbA.angularVelocity, con.relGlobalAnchorA);
			vec3 anchorVelocityB = rbB.linearVelocity + cross(rbB.angularVelocity, con.relGlobalAnchorB);
			vec3 Cdot = anchorVelocityB - anchorVelocityA + con.translationBias;

			vec3 P = solveLinearSystem(con.invEffectiveTranslationMass, -Cdot);
			rbA.linearVelocity -= rbA.invMass * P;
			rbA.angularVelocity -= rbA.invInertia * cross(con.relGlobalAnchorA, P);
			rbB.linearVelocity += rbB.invMass * P;
			rbB.angularVelocity += rbB.invInertia * cross(con.relGlobalAnchorB, P);
		}
	}
}

simd_fixed_constraint_solver initializeFixedVelocityConstraintsSIMD(memory_arena& arena, const rigid_body_global_state* rbs, const fixed_constraint* input, const constraint_body_pair* bodyPairs, uint32 count, float dt)
{
	CPU_PROFILE_BLOCK("Initialize fixed constraints SIMD");

	simd_constraint_slot* contactSlots = arena.allocate<simd_constraint_slot>(count);
	uint32 numBatches = scheduleConstraintsSIMD(arena, bodyPairs, count, UINT16_MAX, contactSlots);

	simd_fixed_constraint_batch* batches = arena.allocate<simd_fixed_constraint_batch>(numBatches);

	const w_float zero = w_float::zero();
	const w_float invDt = 1.f / dt;
	const w_float one = 1.f;

	for (uint32 i = 0; i < numBatches; ++i)
	{
		const simd_constraint_slot& slot = contactSlots[i];
		simd_fixed_constraint_batch& batch = batches[i];

		uint16 constraintIndices[CONSTRAINT_SIMD_WIDTH];
		for (uint32 j = 0; j < CONSTRAINT_SIMD_WIDTH; ++j)
		{
			constraintIndices[j] = (uint16)slot.indices[j];
			batch.rbAIndices[j] = bodyPairs[slot.indices[j]].rbA;
			batch.rbBIndices[j] = bodyPairs[slot.indices[j]].rbB;
		}


		// Load body A.
		w_vec3 localCOGPositionA;
		w_quat rotationA;
		w_vec3 positionA;
		w_mat3 invInertiaA;
		w_float invMassA;

		load8(&rbs->rotation.x, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			rotationA.x, rotationA.y, rotationA.z, rotationA.w,
			localCOGPositionA.x, localCOGPositionA.y, localCOGPositionA.z,
			positionA.x);

		load8(&rbs->position.y, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			positionA.y, positionA.z,
			invInertiaA.m00, invInertiaA.m10, invInertiaA.m20,
			invInertiaA.m01, invInertiaA.m11, invInertiaA.m21);

		load4(&rbs->invInertia.m02, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaA.m02, invInertiaA.m12, invInertiaA.m22,
			invMassA);


		// Load body B.
		w_quat rotationB;
		w_vec3 positionB;
		w_vec3 localCOGPositionB;
		w_mat3 invInertiaB;
		w_float invMassB;

		load8(&rbs->rotation.x, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			rotationB.x, rotationB.y, rotationB.z, rotationB.w,
			localCOGPositionB.x, localCOGPositionB.y, localCOGPositionB.z,
			positionB.x);

		load8(&rbs->position.y, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			positionB.y, positionB.z,
			invInertiaB.m00, invInertiaB.m10, invInertiaB.m20,
			invInertiaB.m01, invInertiaB.m11, invInertiaB.m21);

		load4(&rbs->invInertia.m02, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaB.m02, invInertiaB.m12, invInertiaB.m22,
			invMassB);


		w_quat initialInvRotationDifference;
		w_vec3 localAnchorA, localAnchorB;
		w_float dummy0, dummy1;
		load8((float*)input, constraintIndices, (uint32)sizeof(*input),
			initialInvRotationDifference.x, initialInvRotationDifference.y, initialInvRotationDifference.z, initialInvRotationDifference.w,
			localAnchorA.x, localAnchorA.y, localAnchorA.z, localAnchorB.x);

		load4(&input->localAnchorB.y, constraintIndices, (uint32)sizeof(*input),
			localAnchorB.y, localAnchorB.z, dummy0, dummy1);


		// Relative to COG.
		w_vec3 relGlobalAnchorA = rotationA * (localAnchorA - localCOGPositionA);
		w_vec3 relGlobalAnchorB = rotationB * (localAnchorB - localCOGPositionB);

		// Global.
		w_vec3 globalAnchorA = positionA + relGlobalAnchorA;
		w_vec3 globalAnchorB = positionB + relGlobalAnchorB;

		w_mat3 skewMatA = getSkewMatrix(relGlobalAnchorA);
		w_mat3 skewMatB = getSkewMatrix(relGlobalAnchorB);

		w_mat3 invEffectiveTranslationMass = skewMatA * invInertiaA * transpose(skewMatA)
										  + skewMatB * invInertiaB * transpose(skewMatB);
		w_float invMassSum = invMassA + invMassB;
		invEffectiveTranslationMass.m00 += invMassSum;
		invEffectiveTranslationMass.m11 += invMassSum;
		invEffectiveTranslationMass.m22 += invMassSum;

		w_mat3 invEffectiveRotationMass = invInertiaA + invInertiaB;

		w_vec3 translationBias = zero;
		w_vec3 rotationBias = zero;

		if (dt > DT_THRESHOLD)
		{
			translationBias = (globalAnchorB - globalAnchorA) * (w_float(BALL_CONSTRAINT_BETA) * invDt);

			w_quat rotationError = rotationB * initialInvRotationDifference * conjugate(rotationA);
			rotationBias = rotationError.v * (SLIDER_CONSTRAINT_BETA * 2.f * invDt);
		}

		relGlobalAnchorA.x.store(batch.relGlobalAnchorA[0]);
		relGlobalAnchorA.y.store(batch.relGlobalAnchorA[1]);
		relGlobalAnchorA.z.store(batch.relGlobalAnchorA[2]);

		relGlobalAnchorB.x.store(batch.relGlobalAnchorB[0]);
		relGlobalAnchorB.y.store(batch.relGlobalAnchorB[1]);
		relGlobalAnchorB.z.store(batch.relGlobalAnchorB[2]);

		invEffectiveTranslationMass.m[0].store(batch.invEffectiveTranslationMass[0]);
		invEffectiveTranslationMass.m[1].store(batch.invEffectiveTranslationMass[1]);
		invEffectiveTranslationMass.m[2].store(batch.invEffectiveTranslationMass[2]);
		invEffectiveTranslationMass.m[3].store(batch.invEffectiveTranslationMass[3]);
		invEffectiveTranslationMass.m[4].store(batch.invEffectiveTranslationMass[4]);
		invEffectiveTranslationMass.m[5].store(batch.invEffectiveTranslationMass[5]);
		invEffectiveTranslationMass.m[6].store(batch.invEffectiveTranslationMass[6]);
		invEffectiveTranslationMass.m[7].store(batch.invEffectiveTranslationMass[7]);
		invEffectiveTranslationMass.m[8].store(batch.invEffectiveTranslationMass[8]);

		translationBias.x.store(batch.translationBias[0]);
		translationBias.y.store(batch.translationBias[1]);
		translationBias.z.store(batch.translationBias[2]);

		invEffectiveRotationMass.m[0].store(batch.invEffectiveRotationMass[0]);
		invEffectiveRotationMass.m[1].store(batch.invEffectiveRotationMass[1]);
		invEffectiveRotationMass.m[2].store(batch.invEffectiveRotationMass[2]);
		invEffectiveRotationMass.m[3].store(batch.invEffectiveRotationMass[3]);
		invEffectiveRotationMass.m[4].store(batch.invEffectiveRotationMass[4]);
		invEffectiveRotationMass.m[5].store(batch.invEffectiveRotationMass[5]);
		invEffectiveRotationMass.m[6].store(batch.invEffectiveRotationMass[6]);
		invEffectiveRotationMass.m[7].store(batch.invEffectiveRotationMass[7]);
		invEffectiveRotationMass.m[8].store(batch.invEffectiveRotationMass[8]);

		rotationBias.x.store(batch.rotationBias[0]);
		rotationBias.y.store(batch.rotationBias[1]);
		rotationBias.z.store(batch.rotationBias[2]);
	}

	simd_fixed_constraint_solver result;
	result.batches = batches;
	result.numBatches = numBatches;
	return result;
}

void solveFixedVelocityConstraintsSIMD(simd_fixed_constraint_solver constraints, rigid_body_global_state* rbs)
{
	CPU_PROFILE_BLOCK("Solve fixed constraints SIMD");

	for (uint32 i = 0; i < constraints.numBatches; ++i)
	{
		simd_fixed_constraint_batch& batch = constraints.batches[i];


		// Load body A.
		w_vec3 vA, wA;
		w_float invMassA;
		w_mat3 invInertiaA;

		load8(&rbs->invInertia.m00, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaA.m00, invInertiaA.m10, invInertiaA.m20,
			invInertiaA.m01, invInertiaA.m11, invInertiaA.m21,
			invInertiaA.m02, invInertiaA.m12);

		load8(&rbs->invInertia.m22, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaA.m22, invMassA, vA.x, vA.y, vA.z, wA.x, wA.y, wA.z);


		// Load body B.
		w_vec3 vB, wB;
		w_float invMassB;
		w_mat3 invInertiaB;

		load8(&rbs->invInertia.m00, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaB.m00, invInertiaB.m10, invInertiaB.m20,
			invInertiaB.m01, invInertiaB.m11, invInertiaB.m21,
			invInertiaB.m02, invInertiaB.m12);

		load8(&rbs->invInertia.m22, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaB.m22, invMassB, vB.x, vB.y, vB.z, wB.x, wB.y, wB.z);


		// Rotation part.
		{
			w_vec3 rotationBias(batch.rotationBias[0], batch.rotationBias[1], batch.rotationBias[2]);
			w_mat3 invEffectiveRotationMass;
			invEffectiveRotationMass.m[0] = w_float(batch.invEffectiveRotationMass[0]);
			invEffectiveRotationMass.m[1] = w_float(batch.invEffectiveRotationMass[1]);
			invEffectiveRotationMass.m[2] = w_float(batch.invEffectiveRotationMass[2]);
			invEffectiveRotationMass.m[3] = w_float(batch.invEffectiveRotationMass[3]);
			invEffectiveRotationMass.m[4] = w_float(batch.invEffectiveRotationMass[4]);
			invEffectiveRotationMass.m[5] = w_float(batch.invEffectiveRotationMass[5]);
			invEffectiveRotationMass.m[6] = w_float(batch.invEffectiveRotationMass[6]);
			invEffectiveRotationMass.m[7] = w_float(batch.invEffectiveRotationMass[7]);
			invEffectiveRotationMass.m[8] = w_float(batch.invEffectiveRotationMass[8]);

			w_vec3 Cdot = wB - wA;

			w_vec3 rotationLambda = solveLinearSystem(invEffectiveRotationMass, -(Cdot + rotationBias));
			wA -= invInertiaA * rotationLambda;
			wB += invInertiaB * rotationLambda;
		}


		// Position part.
		{
			w_vec3 relGlobalAnchorA(batch.relGlobalAnchorA[0], batch.relGlobalAnchorA[1], batch.relGlobalAnchorA[2]);
			w_vec3 relGlobalAnchorB(batch.relGlobalAnchorB[0], batch.relGlobalAnchorB[1], batch.relGlobalAnchorB[2]);
			w_vec3 translationBias(batch.translationBias[0], batch.translationBias[1], batch.translationBias[2]);
			w_mat3 invEffectiveTranslationMass;
			invEffectiveTranslationMass.m[0] = w_float(batch.invEffectiveTranslationMass[0]);
			invEffectiveTranslationMass.m[1] = w_float(batch.invEffectiveTranslationMass[1]);
			invEffectiveTranslationMass.m[2] = w_float(batch.invEffectiveTranslationMass[2]);
			invEffectiveTranslationMass.m[3] = w_float(batch.invEffectiveTranslationMass[3]);
			invEffectiveTranslationMass.m[4] = w_float(batch.invEffectiveTranslationMass[4]);
			invEffectiveTranslationMass.m[5] = w_float(batch.invEffectiveTranslationMass[5]);
			invEffectiveTranslationMass.m[6] = w_float(batch.invEffectiveTranslationMass[6]);
			invEffectiveTranslationMass.m[7] = w_float(batch.invEffectiveTranslationMass[7]);
			invEffectiveTranslationMass.m[8] = w_float(batch.invEffectiveTranslationMass[8]);


			w_vec3 anchorVelocityA = vA + cross(wA, relGlobalAnchorA);
			w_vec3 anchorVelocityB = vB + cross(wB, relGlobalAnchorB);
			w_vec3 Cdot = anchorVelocityB - anchorVelocityA + translationBias;

			w_vec3 P = solveLinearSystem(invEffectiveTranslationMass, -Cdot);
			vA -= invMassA * P;
			wA -= invInertiaA * cross(relGlobalAnchorA, P);
			vB += invMassB * P;
			wB += invInertiaB * cross(relGlobalAnchorB, P);
		}


		store8(&rbs->invInertia.m22, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaA.m22, invMassA, vA.x, vA.y, vA.z, wA.x, wA.y, wA.z);

		store8(&rbs->invInertia.m22, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaB.m22, invMassB, vB.x, vB.y, vB.z, wB.x, wB.y, wB.z);
	}
}



hinge_constraint_solver initializeHingeVelocityConstraints(memory_arena& arena, const rigid_body_global_state* rbs, const hinge_constraint* input, const constraint_body_pair* bodyPairs, uint32 count, float dt)
{
	CPU_PROFILE_BLOCK("Initialize hinge constraints");

	float invDt = 1.f / dt;

	hinge_constraint_update* constraints = arena.allocate<hinge_constraint_update>(count);

	for (uint32 i = 0; i < count; ++i)
	{
		const hinge_constraint& in = input[i];
		hinge_constraint_update& out = constraints[i];

		out.rigidBodyIndexA = bodyPairs[i].rbA;
		out.rigidBodyIndexB = bodyPairs[i].rbB;

		const rigid_body_global_state& globalA = rbs[out.rigidBodyIndexA];
		const rigid_body_global_state& globalB = rbs[out.rigidBodyIndexB];

		// Relative to COG.
		out.relGlobalAnchorA = globalA.rotation * (in.localAnchorA - globalA.localCOGPosition);
		out.relGlobalAnchorB = globalB.rotation * (in.localAnchorB - globalB.localCOGPosition);

		// Global.
		vec3 globalAnchorA = globalA.position + out.relGlobalAnchorA;
		vec3 globalAnchorB = globalB.position + out.relGlobalAnchorB;




		// Position part. Identical to ball.

		mat3 skewMatA = getSkewMatrix(out.relGlobalAnchorA);
		mat3 skewMatB = getSkewMatrix(out.relGlobalAnchorB);

		out.invEffectiveTranslationMass = skewMatA * globalA.invInertia * transpose(skewMatA)
										+ skewMatB * globalB.invInertia * transpose(skewMatB)
										+ mat3::identity * (globalA.invMass + globalB.invMass);

		out.translationBias = 0.f;
		if (dt > DT_THRESHOLD)
		{
			out.translationBias = (globalAnchorB - globalAnchorA) * (BALL_CONSTRAINT_BETA * invDt);
		}



		// Rotation part.
		vec3 globalHingeAxisA = globalA.rotation * in.localHingeAxisA;
		vec3 globalHingeAxisB = globalB.rotation * in.localHingeAxisB;

		vec3 globalTangentB, globalBitangentB;
		getTangents(globalHingeAxisB, globalTangentB, globalBitangentB);

		vec3 bxa = cross(globalTangentB, globalHingeAxisA);
		vec3 cxa = cross(globalBitangentB, globalHingeAxisA);
		vec3 iAbxa = globalA.invInertia * bxa;
		vec3 iBbxa = globalB.invInertia * bxa;
		vec3 iAcxa = globalA.invInertia * cxa;
		vec3 iBcxa = globalB.invInertia * cxa;

		out.invEffectiveRotationMass.m00 = dot(bxa, iAbxa) + dot(bxa, iBbxa);
		out.invEffectiveRotationMass.m01 = dot(bxa, iAcxa) + dot(bxa, iBcxa);
		out.invEffectiveRotationMass.m10 = dot(cxa, iAbxa) + dot(cxa, iBbxa);
		out.invEffectiveRotationMass.m11 = dot(cxa, iAcxa) + dot(cxa, iBcxa);

		out.bxa = bxa;
		out.cxa = cxa;

		out.rotationBias = vec2(0.f, 0.f);
		if (dt > DT_THRESHOLD)
		{
			out.rotationBias = vec2(dot(globalHingeAxisA, globalTangentB), dot(globalHingeAxisA, globalBitangentB)) * (HINGE_ROTATION_CONSTRAINT_BETA * invDt);
		}


		// Limits and motor.
		out.solveLimit = false;
		out.solveMotor = false;

		if (in.minRotationLimit <= 0.f || in.maxRotationLimit >= 0.f || in.maxMotorTorque > 0.f)
		{
			vec3 localHingeCompareA = conjugate(globalA.rotation) * (globalB.rotation * in.localHingeTangentB);
			float angle = atan2(dot(localHingeCompareA, in.localHingeBitangentA), dot(localHingeCompareA, in.localHingeTangentA));

			bool minLimitViolated = in.minRotationLimit <= 0.f && angle <= in.minRotationLimit;
			bool maxLimitViolated = in.maxRotationLimit >= 0.f && angle >= in.maxRotationLimit;

			ASSERT(!(minLimitViolated && maxLimitViolated));

			out.solveLimit = minLimitViolated || maxLimitViolated;
			out.solveMotor = in.maxMotorTorque > 0.f;
			if (out.solveLimit || out.solveMotor)
			{
				out.globalRotationAxis = globalHingeAxisA;
				out.limitImpulse = 0.f;

				float invEffectiveAxialMass = dot(globalHingeAxisA, globalA.invInertia * globalHingeAxisA)
											+ dot(globalHingeAxisA, globalB.invInertia * globalHingeAxisA);

				out.effectiveAxialMass = (invEffectiveAxialMass != 0.f) ? (1.f / invEffectiveAxialMass) : 0.f;
				out.limitSign = minLimitViolated ? 1.f : -1.f;

				out.maxMotorImpulse = in.maxMotorTorque * dt;
				out.motorImpulse = 0.f;

				out.motorAndLimitImpulseToAngularVelocityA = globalA.invInertia * out.globalRotationAxis;
				out.motorAndLimitImpulseToAngularVelocityB = globalB.invInertia * out.globalRotationAxis;

				out.motorVelocity = in.motorVelocity;
				if (in.motorType == constraint_position_motor)
				{
					// Inspired by Bullet Engine. We set the velocity such that the target angle is reached within one frame.
					// This will later get clamped to the maximum motor impulse.
					float minLimit = (in.minRotationLimit <= 0.f) ? in.minRotationLimit : -M_PI;
					float maxLimit = (in.maxRotationLimit >= 0.f) ? in.maxRotationLimit : M_PI;
					float targetAngle = clamp(in.motorTargetAngle, minLimit, maxLimit);
					out.motorVelocity = (dt > DT_THRESHOLD) ? ((targetAngle - angle) * invDt) : 0.f;
				}

				out.limitBias = 0.f;
				if (dt > DT_THRESHOLD)
				{
					float d = minLimitViolated ? (angle - in.minRotationLimit) : (in.maxRotationLimit - angle);
					out.limitBias = d * HINGE_LIMIT_CONSTRAINT_BETA * invDt;
				}
			}
		}
	}

	hinge_constraint_solver result;
	result.constraints = constraints;
	result.count = count;
	return result;
}

void solveHingeVelocityConstraints(hinge_constraint_solver constraints, rigid_body_global_state* rbs)
{
	CPU_PROFILE_BLOCK("Solve hinge constraints");

	for (uint32 i = 0; i < constraints.count; ++i)
	{
		hinge_constraint_update& con = constraints.constraints[i];

		rigid_body_global_state& rbA = rbs[con.rigidBodyIndexA];
		rigid_body_global_state& rbB = rbs[con.rigidBodyIndexB];

		vec3 vA = rbA.linearVelocity;
		vec3 wA = rbA.angularVelocity;
		vec3 vB = rbB.linearVelocity;
		vec3 wB = rbB.angularVelocity;

		// Solve in order of importance (most important last): Motor -> Limits -> Rotation -> Position.

		vec3 globalRotationAxis = con.globalRotationAxis;

		// Motor.
		if (con.solveMotor)
		{
			float aDotWA = dot(globalRotationAxis, wA); // How fast are we turning about the axis.
			float aDotWB = dot(globalRotationAxis, wB);

			float relAngularVelocity = (aDotWB - aDotWA);
			float motorCdot = relAngularVelocity - con.motorVelocity;

			float motorLambda = -con.effectiveAxialMass * motorCdot;
			float oldImpulse = con.motorImpulse;
			con.motorImpulse = clamp(con.motorImpulse + motorLambda, -con.maxMotorImpulse, con.maxMotorImpulse);
			motorLambda = con.motorImpulse - oldImpulse;

			wA -= con.motorAndLimitImpulseToAngularVelocityA * motorLambda;
			wB += con.motorAndLimitImpulseToAngularVelocityB * motorLambda;
		}

		// Limits.
		if (con.solveLimit)
		{
			float limitSign = con.limitSign;

			float aDotWA = dot(globalRotationAxis, wA); // How fast are we turning about the axis.
			float aDotWB = dot(globalRotationAxis, wB);
			float relAngularVelocity = limitSign * (aDotWB - aDotWA);

			float limitCdot = relAngularVelocity + con.limitBias;
			float limitLambda = -con.effectiveAxialMass * limitCdot;

			float impulse = max(con.limitImpulse + limitLambda, 0.f);
			limitLambda = impulse - con.limitImpulse;
			con.limitImpulse = impulse;

			limitLambda *= limitSign;

			wA -= con.motorAndLimitImpulseToAngularVelocityA * limitLambda;
			wB += con.motorAndLimitImpulseToAngularVelocityB * limitLambda;
		}

		// Rotation part.
		{
			vec3 deltaAngularVelocity = wB - wA;

			vec2 rotationCdot(dot(con.bxa, deltaAngularVelocity), dot(con.cxa, deltaAngularVelocity));
			vec2 rotLambda = solveLinearSystem(con.invEffectiveRotationMass, -(rotationCdot + con.rotationBias));

			vec3 rotationP = con.bxa * rotLambda.x + con.cxa * rotLambda.y;

			wA -= rbA.invInertia * rotationP;
			wB += rbB.invInertia * rotationP;
		}

		// Position part.
		{
			vec3 anchorVelocityA = vA + cross(wA, con.relGlobalAnchorA);
			vec3 anchorVelocityB = vB + cross(wB, con.relGlobalAnchorB);
			vec3 translationCdot = anchorVelocityB - anchorVelocityA + con.translationBias;

			vec3 translationP = solveLinearSystem(con.invEffectiveTranslationMass, -translationCdot);

			vA -= rbA.invMass * translationP;
			wA -= rbA.invInertia * cross(con.relGlobalAnchorA, translationP);
			vB += rbB.invMass * translationP;
			wB += rbB.invInertia * cross(con.relGlobalAnchorB, translationP);
		}

		rbA.linearVelocity = vA;
		rbA.angularVelocity = wA;
		rbB.linearVelocity = vB;
		rbB.angularVelocity = wB;
	}
}

simd_hinge_constraint_solver initializeHingeVelocityConstraintsSIMD(memory_arena& arena, const rigid_body_global_state* rbs, const hinge_constraint* input, const constraint_body_pair* bodyPairs, uint32 count, float dt)
{
	CPU_PROFILE_BLOCK("Initialize hinge constraints SIMD");

	simd_constraint_slot* contactSlots = arena.allocate<simd_constraint_slot>(count);
	uint32 numBatches = scheduleConstraintsSIMD(arena, bodyPairs, count, UINT16_MAX, contactSlots);

	simd_hinge_constraint_batch* batches = arena.allocate<simd_hinge_constraint_batch>(numBatches);

	const w_float zero = w_float::zero();
	const w_float invDt = 1.f / dt;
	const w_float one = 1.f;

	for (uint32 i = 0; i < numBatches; ++i)
	{
		const simd_constraint_slot& slot = contactSlots[i];
		simd_hinge_constraint_batch& batch = batches[i];

		uint16 constraintIndices[CONSTRAINT_SIMD_WIDTH];
		for (uint32 j = 0; j < CONSTRAINT_SIMD_WIDTH; ++j)
		{
			constraintIndices[j] = (uint16)slot.indices[j];
			batch.rbAIndices[j] = bodyPairs[slot.indices[j]].rbA;
			batch.rbBIndices[j] = bodyPairs[slot.indices[j]].rbB;
		}


		// Load body A.
		w_vec3 localCOGPositionA;
		w_quat rotationA;
		w_vec3 positionA;
		w_mat3 invInertiaA;
		w_float invMassA;

		load8(&rbs->rotation.x, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			rotationA.x, rotationA.y, rotationA.z, rotationA.w,
			localCOGPositionA.x, localCOGPositionA.y, localCOGPositionA.z,
			positionA.x);

		load8(&rbs->position.y, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			positionA.y, positionA.z,
			invInertiaA.m00, invInertiaA.m10, invInertiaA.m20,
			invInertiaA.m01, invInertiaA.m11, invInertiaA.m21);

		load4(&rbs->invInertia.m02, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaA.m02, invInertiaA.m12, invInertiaA.m22,
			invMassA);


		// Load body B.
		w_quat rotationB;
		w_vec3 positionB;
		w_vec3 localCOGPositionB;
		w_mat3 invInertiaB;
		w_float invMassB;

		load8(&rbs->rotation.x, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			rotationB.x, rotationB.y, rotationB.z, rotationB.w,
			localCOGPositionB.x, localCOGPositionB.y, localCOGPositionB.z,
			positionB.x);

		load8(&rbs->position.y, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			positionB.y, positionB.z,
			invInertiaB.m00, invInertiaB.m10, invInertiaB.m20,
			invInertiaB.m01, invInertiaB.m11, invInertiaB.m21);

		load4(&rbs->invInertia.m02, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaB.m02, invInertiaB.m12, invInertiaB.m22,
			invMassB);



		w_vec3 localAnchorA;
		w_vec3 localAnchorB;
		w_vec3 localHingeAxisA;
		w_vec3 localHingeAxisB;

		w_float minRotationLimit;
		w_float maxRotationLimit;

		w_float maxMotorTorque;
		w_float motorTypeF;



		load8((float*)input, constraintIndices, (uint32)sizeof(*input),
			localAnchorA.x, localAnchorA.y, localAnchorA.z,
			localAnchorB.x, localAnchorB.y, localAnchorB.z,
			localHingeAxisA.x, localHingeAxisA.y);

		load8(&input->localHingeAxisA.z, constraintIndices, (uint32)sizeof(*input),
			localHingeAxisA.z, 
			localHingeAxisB.x, localHingeAxisB.y, localHingeAxisB.z,
			minRotationLimit, maxRotationLimit,
			maxMotorTorque, motorTypeF);

		w_int motorType = reinterpret(motorTypeF);


		// Relative to COG.
		w_vec3 relGlobalAnchorA = rotationA * (localAnchorA - localCOGPositionA);
		w_vec3 relGlobalAnchorB = rotationB * (localAnchorB - localCOGPositionB);

		// Global.
		w_vec3 globalAnchorA = positionA + relGlobalAnchorA;
		w_vec3 globalAnchorB = positionB + relGlobalAnchorB;




		// Position part. Identical to ball.

		w_mat3 skewMatA = getSkewMatrix(relGlobalAnchorA);
		w_mat3 skewMatB = getSkewMatrix(relGlobalAnchorB);

		w_mat3 invEffectiveTranslationMass = skewMatA * invInertiaA * transpose(skewMatA)
										  + skewMatB * invInertiaB * transpose(skewMatB);
		w_float invMassSum = invMassA + invMassB;
		invEffectiveTranslationMass.m00 += invMassSum;
		invEffectiveTranslationMass.m11 += invMassSum;
		invEffectiveTranslationMass.m22 += invMassSum;

		w_vec3 translationBias = zero;
		if (dt > DT_THRESHOLD)
		{
			translationBias = (globalAnchorB - globalAnchorA) * (w_float(BALL_CONSTRAINT_BETA) * invDt);
		}

		relGlobalAnchorA.x.store(batch.relGlobalAnchorA[0]);
		relGlobalAnchorA.y.store(batch.relGlobalAnchorA[1]);
		relGlobalAnchorA.z.store(batch.relGlobalAnchorA[2]);

		relGlobalAnchorB.x.store(batch.relGlobalAnchorB[0]);
		relGlobalAnchorB.y.store(batch.relGlobalAnchorB[1]);
		relGlobalAnchorB.z.store(batch.relGlobalAnchorB[2]);

		translationBias.x.store(batch.translationBias[0]);
		translationBias.y.store(batch.translationBias[1]);
		translationBias.z.store(batch.translationBias[2]);

		invEffectiveTranslationMass.m[0].store(batch.invEffectiveTranslationMass[0]);
		invEffectiveTranslationMass.m[1].store(batch.invEffectiveTranslationMass[1]);
		invEffectiveTranslationMass.m[2].store(batch.invEffectiveTranslationMass[2]);
		invEffectiveTranslationMass.m[3].store(batch.invEffectiveTranslationMass[3]);
		invEffectiveTranslationMass.m[4].store(batch.invEffectiveTranslationMass[4]);
		invEffectiveTranslationMass.m[5].store(batch.invEffectiveTranslationMass[5]);
		invEffectiveTranslationMass.m[6].store(batch.invEffectiveTranslationMass[6]);
		invEffectiveTranslationMass.m[7].store(batch.invEffectiveTranslationMass[7]);
		invEffectiveTranslationMass.m[8].store(batch.invEffectiveTranslationMass[8]);



		// Rotation part.
		w_vec3 globalHingeAxisA = rotationA * localHingeAxisA;
		w_vec3 globalHingeAxisB = rotationB * localHingeAxisB;

		w_vec3 globalTangentB, globalBitangentB;
		getTangents(globalHingeAxisB, globalTangentB, globalBitangentB);

		w_vec3 bxa = cross(globalTangentB, globalHingeAxisA);
		w_vec3 cxa = cross(globalBitangentB, globalHingeAxisA);
		w_vec3 iAbxa = invInertiaA * bxa;
		w_vec3 iBbxa = invInertiaB * bxa;
		w_vec3 iAcxa = invInertiaA * cxa;
		w_vec3 iBcxa = invInertiaB * cxa;

		w_mat2 invEffectiveRotationMass;
		invEffectiveRotationMass.m00 = dot(bxa, iAbxa) + dot(bxa, iBbxa);
		invEffectiveRotationMass.m01 = dot(bxa, iAcxa) + dot(bxa, iBcxa);
		invEffectiveRotationMass.m10 = dot(cxa, iAbxa) + dot(cxa, iBbxa);
		invEffectiveRotationMass.m11 = dot(cxa, iAcxa) + dot(cxa, iBcxa);

		w_vec2 rotationBias = zero;
		if (dt > DT_THRESHOLD)
		{
			rotationBias = w_vec2(dot(globalHingeAxisA, globalTangentB), dot(globalHingeAxisA, globalBitangentB)) * (w_float(HINGE_ROTATION_CONSTRAINT_BETA) * invDt);
		}

		rotationBias.x.store(batch.rotationBias[0]);
		rotationBias.y.store(batch.rotationBias[1]);

		invEffectiveRotationMass.m[0].store(batch.invEffectiveRotationMass[0]);
		invEffectiveRotationMass.m[1].store(batch.invEffectiveRotationMass[1]);
		invEffectiveRotationMass.m[2].store(batch.invEffectiveRotationMass[2]);
		invEffectiveRotationMass.m[3].store(batch.invEffectiveRotationMass[3]);

		bxa.x.store(batch.bxa[0]);
		bxa.y.store(batch.bxa[1]);
		bxa.z.store(batch.bxa[2]);

		cxa.x.store(batch.cxa[0]);
		cxa.y.store(batch.cxa[1]);
		cxa.z.store(batch.cxa[2]);


		// Limits and motor.
		batch.solveLimit = false;
		batch.solveMotor = false;

		auto minLimitActive = minRotationLimit <= zero;
		auto maxLimitActive = maxRotationLimit >= zero;
		auto motorActive = maxMotorTorque > zero;
		auto cond = minLimitActive | maxLimitActive | motorActive;

		if (anyTrue(cond))
		{
			w_float motorVelocity;

			w_vec3 localHingeTangentA;
			w_vec3 localHingeBitangentA;
			w_vec3 localHingeTangentB;

			w_float dummy0, dummy1;

			load8(&input->motorVelocity, constraintIndices, (uint32)sizeof(*input),
				motorVelocity,
				localHingeTangentA.x, localHingeTangentA.y, localHingeTangentA.z,
				localHingeBitangentA.x, localHingeBitangentA.y, localHingeBitangentA.z,
				localHingeTangentB.x);

			load4(&input->localHingeTangentB.y, constraintIndices, (uint32)sizeof(*input),
				localHingeTangentB.y, localHingeTangentB.z,
				dummy0, dummy1);



			w_vec3 localHingeCompareA = conjugate(rotationA) * (rotationB * localHingeTangentB);
			w_float angle = atan2(dot(localHingeCompareA, localHingeBitangentA), dot(localHingeCompareA, localHingeTangentA));

			auto minLimitViolated = minLimitActive & (angle <= minRotationLimit);
			auto maxLimitViolated = maxLimitActive & (angle >= maxRotationLimit);

			auto limitViolated = minLimitViolated | maxLimitViolated;

			batch.solveLimit = anyTrue(limitViolated);
			batch.solveMotor = anyTrue(motorActive);
			if (batch.solveLimit || batch.solveMotor)
			{
				w_vec3 globalRotationAxis = globalHingeAxisA;

				w_float invEffectiveAxialMass = dot(globalRotationAxis, invInertiaA * globalRotationAxis)
											 + dot(globalRotationAxis, invInertiaB * globalRotationAxis);

				w_float effectiveAxialMass = ifThen(invEffectiveAxialMass != zero, 1.f / invEffectiveAxialMass, zero);
				w_float effectiveLimitAxialMass = ifThen(limitViolated, effectiveAxialMass, zero);
				w_float effectiveMotorAxialMass = ifThen(motorActive, effectiveAxialMass, zero);

				w_float limitSign = ifThen(minLimitViolated, 1.f, -1.f);

				w_float maxMotorImpulse = maxMotorTorque * w_float(dt);
				maxMotorImpulse = ifThen(motorActive, maxMotorImpulse, zero);

				w_vec3 motorAndLimitImpulseToAngularVelocityA = invInertiaA * globalRotationAxis;
				w_vec3 motorAndLimitImpulseToAngularVelocityB = invInertiaB * globalRotationAxis;

				if (batch.solveMotor)
				{
					auto isVelocityMotor = motorType == constraint_velocity_motor;

					if (anyFalse(isVelocityMotor))
					{
						// Inspired by Bullet Engine. We set the velocity such that the target angle is reached within one frame.
						// This will later get clamped to the maximum motor impulse.

						w_float motorTargetAngle = motorVelocity; // This is a union.

						w_float minLimit = ifThen(minLimitActive, minRotationLimit, -M_PI);
						w_float maxLimit = ifThen(maxLimitActive, maxRotationLimit, M_PI);
						w_float targetAngle = clamp(motorTargetAngle, minLimit, maxLimit);

						w_float motorVelocityOverride = (dt > DT_THRESHOLD) ? ((targetAngle - angle) * invDt) : zero;
						motorVelocity = ifThen(reinterpret(isVelocityMotor), motorVelocity, motorVelocityOverride);
					}
				}

				w_float limitBias = zero;
				if (batch.solveLimit && dt > DT_THRESHOLD)
				{
					w_float d = ifThen(minLimitViolated, angle - minRotationLimit, maxRotationLimit - angle);
					limitBias = d * w_float(HINGE_LIMIT_CONSTRAINT_BETA) * invDt;
				}
				
				globalRotationAxis.x.store(batch.globalRotationAxis[0]);
				globalRotationAxis.y.store(batch.globalRotationAxis[1]);
				globalRotationAxis.z.store(batch.globalRotationAxis[2]);

				effectiveLimitAxialMass.store(batch.effectiveLimitAxialMass);
				effectiveMotorAxialMass.store(batch.effectiveMotorAxialMass);

				zero.store(batch.limitImpulse);
				limitBias.store(batch.limitBias);
				limitSign.store(batch.limitSign);

				zero.store(batch.motorImpulse);
				maxMotorImpulse.store(batch.maxMotorImpulse);
				motorVelocity.store(batch.motorVelocity);

				motorAndLimitImpulseToAngularVelocityA.x.store(batch.motorAndLimitImpulseToAngularVelocityA[0]);
				motorAndLimitImpulseToAngularVelocityA.y.store(batch.motorAndLimitImpulseToAngularVelocityA[1]);
				motorAndLimitImpulseToAngularVelocityA.z.store(batch.motorAndLimitImpulseToAngularVelocityA[2]);

				motorAndLimitImpulseToAngularVelocityB.x.store(batch.motorAndLimitImpulseToAngularVelocityB[0]);
				motorAndLimitImpulseToAngularVelocityB.y.store(batch.motorAndLimitImpulseToAngularVelocityB[1]);
				motorAndLimitImpulseToAngularVelocityB.z.store(batch.motorAndLimitImpulseToAngularVelocityB[2]);
			}
		}

	}

	simd_hinge_constraint_solver result;
	result.batches = batches;
	result.numBatches = numBatches;
	return result;
}

void solveHingeVelocityConstraintsSIMD(simd_hinge_constraint_solver constraints, rigid_body_global_state* rbs)
{
	CPU_PROFILE_BLOCK("Solve hinge constraints SIMD");

	for (uint32 i = 0; i < constraints.numBatches; ++i)
	{
		simd_hinge_constraint_batch& batch = constraints.batches[i];


		// Load body A.
		w_vec3 vA, wA;
		w_float invMassA;
		w_mat3 invInertiaA;

		load8(&rbs->invInertia.m00, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaA.m00, invInertiaA.m10, invInertiaA.m20,
			invInertiaA.m01, invInertiaA.m11, invInertiaA.m21,
			invInertiaA.m02, invInertiaA.m12);

		load8(&rbs->invInertia.m22, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaA.m22, invMassA, vA.x, vA.y, vA.z, wA.x, wA.y, wA.z);


		// Load body B.
		w_vec3 vB, wB;
		w_float invMassB;
		w_mat3 invInertiaB;

		load8(&rbs->invInertia.m00, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaB.m00, invInertiaB.m10, invInertiaB.m20,
			invInertiaB.m01, invInertiaB.m11, invInertiaB.m21,
			invInertiaB.m02, invInertiaB.m12);

		load8(&rbs->invInertia.m22, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaB.m22, invMassB, vB.x, vB.y, vB.z, wB.x, wB.y, wB.z);


		// Solve in order of importance (most important last): Motor -> Limits -> Rotation -> Position.

		w_vec3 globalRotationAxis(batch.globalRotationAxis[0], batch.globalRotationAxis[1], batch.globalRotationAxis[2]);
		w_vec3 motorAndLimitImpulseToAngularVelocityA(batch.motorAndLimitImpulseToAngularVelocityA[0], batch.motorAndLimitImpulseToAngularVelocityA[1], batch.motorAndLimitImpulseToAngularVelocityA[2]);
		w_vec3 motorAndLimitImpulseToAngularVelocityB(batch.motorAndLimitImpulseToAngularVelocityB[0], batch.motorAndLimitImpulseToAngularVelocityB[1], batch.motorAndLimitImpulseToAngularVelocityB[2]);

		// Motor.
		if (batch.solveMotor)
		{
			w_float motorVelocity(batch.motorVelocity);
			w_float effectiveMotorAxialMass(batch.effectiveMotorAxialMass);
			w_float motorImpulse(batch.motorImpulse);
			w_float maxMotorImpulse(batch.maxMotorImpulse);

			w_float aDotWA = dot(globalRotationAxis, wA); // How fast are we turning about the axis.
			w_float aDotWB = dot(globalRotationAxis, wB);

			w_float relAngularVelocity = (aDotWB - aDotWA);
			w_float motorCdot = relAngularVelocity - motorVelocity;

			w_float motorLambda = -effectiveMotorAxialMass * motorCdot;
			w_float oldImpulse = motorImpulse;
			motorImpulse = clamp(motorImpulse + motorLambda, -maxMotorImpulse, maxMotorImpulse);
			motorLambda = motorImpulse - oldImpulse;

			wA -= motorAndLimitImpulseToAngularVelocityA * motorLambda;
			wB += motorAndLimitImpulseToAngularVelocityB * motorLambda;

			motorImpulse.store(batch.motorImpulse);
		}

		// Limits.
		if (batch.solveLimit)
		{
			w_float limitSign(batch.limitSign);
			w_float limitBias(batch.limitBias);
			w_float limitImpulse(batch.limitImpulse);
			w_float effectiveLimitAxialMass(batch.effectiveLimitAxialMass);

			w_float aDotWA = dot(globalRotationAxis, wA); // How fast are we turning about the axis.
			w_float aDotWB = dot(globalRotationAxis, wB);
			w_float relAngularVelocity = limitSign * (aDotWB - aDotWA);

			w_float limitCdot = relAngularVelocity + limitBias;
			w_float limitLambda = -effectiveLimitAxialMass * limitCdot;

			w_float impulse = maximum(limitImpulse + limitLambda, 0.f);
			limitLambda = impulse - limitImpulse;
			limitImpulse = impulse;

			limitLambda *= limitSign;

			wA -= motorAndLimitImpulseToAngularVelocityA * limitLambda;
			wB += motorAndLimitImpulseToAngularVelocityB * limitLambda;

			limitImpulse.store(batch.limitImpulse);
		}

		// Rotation part.
		{
			w_vec3 bxa(batch.bxa[0], batch.bxa[1], batch.bxa[2]);
			w_vec3 cxa(batch.cxa[0], batch.cxa[1], batch.cxa[2]);
			w_vec2 rotationBias(batch.rotationBias[0], batch.rotationBias[1]);
			w_mat2 invEffectiveRotationMass;
			invEffectiveRotationMass.m[0] = w_float(batch.invEffectiveRotationMass[0]);
			invEffectiveRotationMass.m[1] = w_float(batch.invEffectiveRotationMass[1]);
			invEffectiveRotationMass.m[2] = w_float(batch.invEffectiveRotationMass[2]);
			invEffectiveRotationMass.m[3] = w_float(batch.invEffectiveRotationMass[3]);

			w_vec3 deltaAngularVelocity = wB - wA;

			w_vec2 rotationCdot(dot(bxa, deltaAngularVelocity), dot(cxa, deltaAngularVelocity));
			w_vec2 rotLambda = solveLinearSystem(invEffectiveRotationMass, -(rotationCdot + rotationBias));

			w_vec3 rotationP = bxa * rotLambda.x + cxa * rotLambda.y;

			wA -= invInertiaA * rotationP;
			wB += invInertiaB * rotationP;
		}

		// Position part.
		{
			w_vec3 relGlobalAnchorA(batch.relGlobalAnchorA[0], batch.relGlobalAnchorA[1], batch.relGlobalAnchorA[2]);
			w_vec3 relGlobalAnchorB(batch.relGlobalAnchorB[0], batch.relGlobalAnchorB[1], batch.relGlobalAnchorB[2]);
			w_vec3 translationBias(batch.translationBias[0], batch.translationBias[1], batch.translationBias[2]);

			w_mat3 invEffectiveTranslationMass;
			invEffectiveTranslationMass.m[0] = w_float(batch.invEffectiveTranslationMass[0]);
			invEffectiveTranslationMass.m[1] = w_float(batch.invEffectiveTranslationMass[1]);
			invEffectiveTranslationMass.m[2] = w_float(batch.invEffectiveTranslationMass[2]);
			invEffectiveTranslationMass.m[3] = w_float(batch.invEffectiveTranslationMass[3]);
			invEffectiveTranslationMass.m[4] = w_float(batch.invEffectiveTranslationMass[4]);
			invEffectiveTranslationMass.m[5] = w_float(batch.invEffectiveTranslationMass[5]);
			invEffectiveTranslationMass.m[6] = w_float(batch.invEffectiveTranslationMass[6]);
			invEffectiveTranslationMass.m[7] = w_float(batch.invEffectiveTranslationMass[7]);
			invEffectiveTranslationMass.m[8] = w_float(batch.invEffectiveTranslationMass[8]);

			w_vec3 anchorVelocityA = vA + cross(wA, relGlobalAnchorA);
			w_vec3 anchorVelocityB = vB + cross(wB, relGlobalAnchorB);
			w_vec3 translationCdot = anchorVelocityB - anchorVelocityA + translationBias;

			w_vec3 translationP = solveLinearSystem(invEffectiveTranslationMass, -translationCdot);

			vA -= invMassA * translationP;
			wA -= invInertiaA * cross(relGlobalAnchorA, translationP);
			vB += invMassB * translationP;
			wB += invInertiaB * cross(relGlobalAnchorB, translationP);
		}


		store8(&rbs->invInertia.m22, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaA.m22, invMassA, vA.x, vA.y, vA.z, wA.x, wA.y, wA.z);

		store8(&rbs->invInertia.m22, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaB.m22, invMassB, vB.x, vB.y, vB.z, wB.x, wB.y, wB.z);
	}
}




cone_twist_constraint_solver initializeConeTwistVelocityConstraints(memory_arena& arena, const rigid_body_global_state* rbs, const cone_twist_constraint* input, const constraint_body_pair* bodyPairs, uint32 count, float dt)
{
	CPU_PROFILE_BLOCK("Initialize cone twist constraints");

	float invDt = 1.f / dt;

	cone_twist_constraint_update* constraints = arena.allocate<cone_twist_constraint_update>(count);

	for (uint32 i = 0; i < count; ++i)
	{
		const cone_twist_constraint& in = input[i];
		cone_twist_constraint_update& out = constraints[i];

		out.rigidBodyIndexA = bodyPairs[i].rbA;
		out.rigidBodyIndexB = bodyPairs[i].rbB;

		const rigid_body_global_state& globalA = rbs[out.rigidBodyIndexA];
		const rigid_body_global_state& globalB = rbs[out.rigidBodyIndexB];

		// Relative to COG.
		out.relGlobalAnchorA = globalA.rotation * (in.localAnchorA - globalA.localCOGPosition);
		out.relGlobalAnchorB = globalB.rotation * (in.localAnchorB - globalB.localCOGPosition);

		// Global.
		vec3 globalAnchorA = globalA.position + out.relGlobalAnchorA;
		vec3 globalAnchorB = globalB.position + out.relGlobalAnchorB;

		mat3 skewMatA = getSkewMatrix(out.relGlobalAnchorA);
		mat3 skewMatB = getSkewMatrix(out.relGlobalAnchorB);

		out.invEffectiveMass = skewMatA * globalA.invInertia * transpose(skewMatA)
							 + skewMatB * globalB.invInertia * transpose(skewMatB)
							 + mat3::identity * (globalA.invMass + globalB.invMass);

		out.bias = 0.f;
		if (dt > DT_THRESHOLD)
		{
			out.bias = (globalAnchorB - globalAnchorA) * (BALL_CONSTRAINT_BETA * invDt);
		}


		// Limits and motors.

		quat btoa = conjugate(globalA.rotation) * globalB.rotation;

		vec3 localLimitAxisA = in.localLimitAxisA;
		vec3 localLimitAxisCompareA = btoa * in.localLimitAxisB;

		quat swingRotation = rotateFromTo(localLimitAxisA, localLimitAxisCompareA);

		vec3 twistTangentA = swingRotation * in.localLimitTangentA;
		vec3 twistBitangentA = swingRotation * in.localLimitBitangentA;
		vec3 localLimitTangentCompareA = btoa * in.localLimitTangentB;
		float twistAngle = atan2(dot(localLimitTangentCompareA, twistBitangentA), dot(localLimitTangentCompareA, twistTangentA));



		// Swing limit.
		vec3 swingAxis; float swingAngle;
		getAxisRotation(swingRotation, swingAxis, swingAngle);
		if (swingAngle < 0.f)
		{
			swingAngle *= -1.f;
			swingAxis *= -1.f;
		}

		out.solveSwingLimit = in.swingLimit >= 0.f && swingAngle >= in.swingLimit;
		if (out.solveSwingLimit)
		{
			out.swingImpulse = 0.f;
			out.globalSwingAxis = globalA.rotation * swingAxis;
			float invEffectiveLimitMass = dot(out.globalSwingAxis, globalA.invInertia * out.globalSwingAxis)
										+ dot(out.globalSwingAxis, globalB.invInertia * out.globalSwingAxis);
			out.effectiveSwingLimitMass = (invEffectiveLimitMass != 0.f) ? (1.f / invEffectiveLimitMass) : 0.f;

			out.swingLimitBias = 0.f;
			if (dt > DT_THRESHOLD)
			{
				out.swingLimitBias = (in.swingLimit - swingAngle) * (HINGE_LIMIT_CONSTRAINT_BETA * invDt);
			}

			out.swingLimitImpulseToAngularVelocityA = globalA.invInertia * out.globalSwingAxis;
			out.swingLimitImpulseToAngularVelocityB = globalB.invInertia * out.globalSwingAxis;
		}

		// Swing motor.
		out.solveSwingMotor = in.maxSwingMotorTorque > 0.f;
		if (out.solveSwingMotor)
		{
			out.maxSwingMotorImpulse = in.maxSwingMotorTorque * dt;
			out.swingMotorImpulse = 0.f;

			float axisX = cos(in.swingMotorAxis), axisY = sin(in.swingMotorAxis);
			vec3 localSwingMotorAxis = axisX * in.localLimitTangentA + axisY * in.localLimitBitangentA;

			if (in.swingMotorType == constraint_velocity_motor)
			{
				out.globalSwingMotorAxis = globalA.rotation * localSwingMotorAxis;
				out.swingMotorVelocity = in.swingMotorVelocity;
			}
			else
			{
				float targetAngle = in.swingMotorTargetAngle;
				if (in.swingLimit >= 0.f)
				{
					targetAngle = clamp(targetAngle, -in.swingLimit, in.swingLimit);
				}

				vec3 localTargetDirection = quat(localSwingMotorAxis, targetAngle) * localLimitAxisA;
				vec3 localSwingMotorAxis = noz(cross(localLimitAxisCompareA, localTargetDirection));
				out.globalSwingMotorAxis = globalA.rotation * localSwingMotorAxis;

				float cosAngle = dot(localTargetDirection, localLimitAxisCompareA);
				float deltaAngle = acos(clamp01(cosAngle));
				out.swingMotorVelocity = (dt > DT_THRESHOLD) ? (deltaAngle * invDt * 0.2f) : 0.f;
			}

			out.swingMotorImpulseToAngularVelocityA = globalA.invInertia * out.globalSwingMotorAxis;
			out.swingMotorImpulseToAngularVelocityB = globalB.invInertia * out.globalSwingMotorAxis;

			float invEffectiveMotorMass = dot(out.globalSwingMotorAxis, globalA.invInertia * out.globalSwingMotorAxis)
										+ dot(out.globalSwingMotorAxis, globalB.invInertia * out.globalSwingMotorAxis);
			out.effectiveSwingMotorMass = (invEffectiveMotorMass != 0.f) ? (1.f / invEffectiveMotorMass) : 0.f;
		}

		// Twist limit and motor.
		bool mw_intistLimitViolated = in.twistLimit >= 0.f && twistAngle <= -in.twistLimit;
		bool maxTwistLimitViolated = in.twistLimit >= 0.f && twistAngle >= in.twistLimit; 
		ASSERT(!(mw_intistLimitViolated && maxTwistLimitViolated));

		out.solveTwistLimit = mw_intistLimitViolated || maxTwistLimitViolated;
		out.solveTwistMotor = in.maxTwistMotorTorque > 0.f;
		if (out.solveTwistLimit || out.solveTwistMotor)
		{
			out.twistImpulse = 0.f;
			out.globalTwistAxis = globalA.rotation * localLimitAxisA;
			float invEffectiveMass = dot(out.globalTwistAxis, globalA.invInertia * out.globalTwistAxis)
								   + dot(out.globalTwistAxis, globalB.invInertia * out.globalTwistAxis);
			out.effectiveTwistMass = (invEffectiveMass != 0.f) ? (1.f / invEffectiveMass) : 0.f;

			out.twistLimitSign = mw_intistLimitViolated ? 1.f : -1.f;

			out.maxTwistMotorImpulse = in.maxTwistMotorTorque * dt;
			out.twistMotorImpulse = 0.f;

			out.twistMotorAndLimitImpulseToAngularVelocityA = globalA.invInertia * out.globalTwistAxis;
			out.twistMotorAndLimitImpulseToAngularVelocityB = globalB.invInertia * out.globalTwistAxis;

			out.twistMotorVelocity = in.twistMotorVelocity;
			if (in.twistMotorType == constraint_position_motor)
			{
				// Inspired by Bullet Engine. We set the velocity such that the target angle is reached within one frame.
				// This will later get clamped to the maximum motor impulse.
				float limit = (in.twistLimit >= 0.f) ? in.twistLimit : M_PI;
				float targetAngle = clamp(in.twistMotorTargetAngle, -limit, limit);
				out.twistMotorVelocity = (dt > DT_THRESHOLD) ? ((targetAngle - twistAngle) * invDt) : 0.f;
			}

			out.twistLimitBias = 0.f;
			if (dt > DT_THRESHOLD)
			{
				float d = mw_intistLimitViolated ? (in.twistLimit + twistAngle) : (in.twistLimit - twistAngle);
				out.twistLimitBias = d * TWIST_LIMIT_CONSTRAINT_BETA * invDt;
			}
		}
	}

	cone_twist_constraint_solver result;
	result.constraints = constraints;
	result.count = count;
	return result;
}

void solveConeTwistVelocityConstraints(cone_twist_constraint_solver constraints, rigid_body_global_state* rbs)
{
	CPU_PROFILE_BLOCK("Solve cone twist constraints");

	for (uint32 i = 0; i < constraints.count; ++i)
	{
		cone_twist_constraint_update& con = constraints.constraints[i];

		rigid_body_global_state& rbA = rbs[con.rigidBodyIndexA];
		rigid_body_global_state& rbB = rbs[con.rigidBodyIndexB];

		vec3 vA = rbA.linearVelocity;
		vec3 wA = rbA.angularVelocity;
		vec3 vB = rbB.linearVelocity;
		vec3 wB = rbB.angularVelocity;

		// Solve in order of importance (most important last): Motors -> Limits -> Position.

		vec3 globalTwistAxis = con.globalTwistAxis;

		// Motor.
		if (con.solveTwistMotor)
		{
			float aDotWA = dot(globalTwistAxis, wA);
			float aDotWB = dot(globalTwistAxis, wB);
			float relAngularVelocity = (aDotWB - aDotWA);

			float motorCdot = relAngularVelocity - con.twistMotorVelocity;

			float motorLambda = -con.effectiveTwistMass * motorCdot;
			float oldImpulse = con.twistMotorImpulse;
			con.twistMotorImpulse = clamp(con.twistMotorImpulse + motorLambda, -con.maxTwistMotorImpulse, con.maxTwistMotorImpulse);
			motorLambda = con.twistMotorImpulse - oldImpulse;

			wA -= con.twistMotorAndLimitImpulseToAngularVelocityA * motorLambda;
			wB += con.twistMotorAndLimitImpulseToAngularVelocityB * motorLambda;
		}

		if (con.solveSwingMotor)
		{
			vec3 globalSwingMotorAxis = con.globalSwingMotorAxis;

			float aDotWA = dot(globalSwingMotorAxis, wA);
			float aDotWB = dot(globalSwingMotorAxis, wB);
			float relAngularVelocity = (aDotWB - aDotWA);

			float motorCdot = relAngularVelocity - con.swingMotorVelocity;

			float motorLambda = -con.effectiveSwingMotorMass * motorCdot;
			float oldImpulse = con.swingMotorImpulse;
			con.swingMotorImpulse = clamp(con.swingMotorImpulse + motorLambda, -con.maxSwingMotorImpulse, con.maxSwingMotorImpulse);
			motorLambda = con.swingMotorImpulse - oldImpulse;

			wA -= con.swingMotorImpulseToAngularVelocityA * motorLambda;
			wB += con.swingMotorImpulseToAngularVelocityB * motorLambda;
		}

		// Twist.
		if (con.solveTwistLimit)
		{
			float limitSign = con.twistLimitSign;

			float aDotWA = dot(globalTwistAxis, wA);
			float aDotWB = dot(globalTwistAxis, wB);
			float relAngularVelocity = limitSign * (aDotWB - aDotWA);

			float limitCdot = relAngularVelocity + con.twistLimitBias;
			float limitLambda = -con.effectiveTwistMass * limitCdot;

			float impulse = max(con.twistImpulse + limitLambda, 0.f);
			limitLambda = impulse - con.twistImpulse;
			con.twistImpulse = impulse;

			limitLambda *= limitSign;

			wA -= con.twistMotorAndLimitImpulseToAngularVelocityA * limitLambda;
			wB += con.twistMotorAndLimitImpulseToAngularVelocityB * limitLambda;
		}

		// Cone.
		if (con.solveSwingLimit)
		{
			float aDotWA = dot(con.globalSwingAxis, wA);
			float aDotWB = dot(con.globalSwingAxis, wB);
			float swingLimitCdot = aDotWA - aDotWB + con.swingLimitBias;
			float limitLambda = -con.effectiveSwingLimitMass * swingLimitCdot;

			float impulse = max(con.swingImpulse + limitLambda, 0.f);
			limitLambda = impulse - con.swingImpulse;
			con.swingImpulse = impulse;

			wA += con.swingLimitImpulseToAngularVelocityA * limitLambda;
			wB -= con.swingLimitImpulseToAngularVelocityB * limitLambda;
		}


		// Position part.
		{
			vec3 anchorVelocityA = vA + cross(wA, con.relGlobalAnchorA);
			vec3 anchorVelocityB = vB + cross(wB, con.relGlobalAnchorB);
			vec3 translationCdot = anchorVelocityB - anchorVelocityA + con.bias;

			vec3 translationP = solveLinearSystem(con.invEffectiveMass, -translationCdot);

			vA -= rbA.invMass * translationP;
			wA -= rbA.invInertia * cross(con.relGlobalAnchorA, translationP);
			vB += rbB.invMass * translationP;
			wB += rbB.invInertia * cross(con.relGlobalAnchorB, translationP);
		}

		rbA.linearVelocity = vA;
		rbA.angularVelocity = wA;
		rbB.linearVelocity = vB;
		rbB.angularVelocity = wB;
	}
}

simd_cone_twist_constraint_solver initializeConeTwistVelocityConstraintsSIMD(memory_arena& arena, const rigid_body_global_state* rbs, const cone_twist_constraint* input, const constraint_body_pair* bodyPairs, uint32 count, float dt)
{
	CPU_PROFILE_BLOCK("Initialize cone twist constraints SIMD");

	simd_constraint_slot* contactSlots = arena.allocate<simd_constraint_slot>(count);
	uint32 numBatches = scheduleConstraintsSIMD(arena, bodyPairs, count, UINT16_MAX, contactSlots);

	simd_cone_twist_constraint_batch* batches = arena.allocate<simd_cone_twist_constraint_batch>(numBatches);

	const w_float zero = w_float::zero();
	const w_float invDt = 1.f / dt;
	const w_float one = 1.f;

	for (uint32 i = 0; i < numBatches; ++i)
	{
		const simd_constraint_slot& slot = contactSlots[i];
		simd_cone_twist_constraint_batch& batch = batches[i];

		uint16 constraintIndices[CONSTRAINT_SIMD_WIDTH];
		for (uint32 j = 0; j < CONSTRAINT_SIMD_WIDTH; ++j)
		{
			constraintIndices[j] = (uint16)slot.indices[j];
			batch.rbAIndices[j] = bodyPairs[slot.indices[j]].rbA;
			batch.rbBIndices[j] = bodyPairs[slot.indices[j]].rbB;
		}


		// Load body A.
		w_vec3 localCOGPositionA;
		w_quat rotationA;
		w_vec3 positionA;
		w_mat3 invInertiaA;
		w_float invMassA;

		load8(&rbs->rotation.x, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			rotationA.x, rotationA.y, rotationA.z, rotationA.w,
			localCOGPositionA.x, localCOGPositionA.y, localCOGPositionA.z,
			positionA.x);

		load8(&rbs->position.y, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			positionA.y, positionA.z,
			invInertiaA.m00, invInertiaA.m10, invInertiaA.m20,
			invInertiaA.m01, invInertiaA.m11, invInertiaA.m21);

		load4(&rbs->invInertia.m02, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaA.m02, invInertiaA.m12, invInertiaA.m22,
			invMassA);


		// Load body B.
		w_quat rotationB;
		w_vec3 positionB;
		w_vec3 localCOGPositionB;
		w_mat3 invInertiaB;
		w_float invMassB;

		load8(&rbs->rotation.x, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			rotationB.x, rotationB.y, rotationB.z, rotationB.w,
			localCOGPositionB.x, localCOGPositionB.y, localCOGPositionB.z,
			positionB.x);

		load8(&rbs->position.y, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			positionB.y, positionB.z,
			invInertiaB.m00, invInertiaB.m10, invInertiaB.m20,
			invInertiaB.m01, invInertiaB.m11, invInertiaB.m21);

		load4(&rbs->invInertia.m02, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaB.m02, invInertiaB.m12, invInertiaB.m22,
			invMassB);






		w_vec3 localAnchorA;
		w_vec3 localAnchorB;

		w_vec3 localLimitAxisA;
		w_vec3 localLimitAxisB;

		w_vec3 localLimitTangentA;
		w_vec3 localLimitBitangentA;
		w_vec3 localLimitTangentB;

		w_float swingLimit;
		w_float twistLimit;

		w_float swingMotorTypeF;
		w_float swingMotorVelocity;
		w_float maxSwingMotorTorque;
		w_float swingMotorAxis;

		w_float twistMotorTypeF;
		w_float twistMotorVelocity;
		w_float maxTwistMotorTorque;

		w_float dummy0, dummy1;


		load8((float*)input, constraintIndices, (uint32)sizeof(*input),
			localAnchorA.x, localAnchorA.y, localAnchorA.z, 
			localAnchorB.x, localAnchorB.y, localAnchorB.z, 
			localLimitAxisA.x, localLimitAxisA.y);

		load8(&input->localLimitAxisA.z, constraintIndices, (uint32)sizeof(*input),
			localLimitAxisA.z,
			localLimitAxisB.x, localLimitAxisB.y, localLimitAxisB.z,
			localLimitTangentA.x, localLimitTangentA.y, localLimitTangentA.z, 
			localLimitBitangentA.x);

		load8(&input->localLimitBitangentA.y, constraintIndices, (uint32)sizeof(*input),
			localLimitBitangentA.y, localLimitBitangentA.z,
			localLimitTangentB.x, localLimitTangentB.y, localLimitTangentB.z,
			swingLimit, twistLimit, swingMotorTypeF);

		load8(&input->swingMotorVelocity, constraintIndices, (uint32)sizeof(*input),
			swingMotorVelocity, maxSwingMotorTorque, swingMotorAxis,
			twistMotorTypeF, twistMotorVelocity, maxTwistMotorTorque,
			dummy0, dummy1);


		w_int swingMotorType = reinterpret(swingMotorTypeF);
		w_int twistMotorType = reinterpret(twistMotorTypeF);






		// Relative to COG.
		w_vec3 relGlobalAnchorA = rotationA * (localAnchorA - localCOGPositionA);
		w_vec3 relGlobalAnchorB = rotationB * (localAnchorB - localCOGPositionB);

		// Global.
		w_vec3 globalAnchorA = positionA + relGlobalAnchorA;
		w_vec3 globalAnchorB = positionB + relGlobalAnchorB;

		w_mat3 skewMatA = getSkewMatrix(relGlobalAnchorA);
		w_mat3 skewMatB = getSkewMatrix(relGlobalAnchorB);

		w_mat3 invEffectiveMass = skewMatA * invInertiaA * transpose(skewMatA)
							   + skewMatB * invInertiaB * transpose(skewMatB);
		w_float invMassSum = invMassA + invMassB;
		invEffectiveMass.m00 += invMassSum;
		invEffectiveMass.m11 += invMassSum;
		invEffectiveMass.m22 += invMassSum;

		w_vec3 bias = zero;
		if (dt > DT_THRESHOLD)
		{
			bias = (globalAnchorB - globalAnchorA) * (w_float(BALL_CONSTRAINT_BETA) * invDt);
		}

		relGlobalAnchorA.x.store(batch.relGlobalAnchorA[0]);
		relGlobalAnchorA.y.store(batch.relGlobalAnchorA[1]);
		relGlobalAnchorA.z.store(batch.relGlobalAnchorA[2]);

		relGlobalAnchorB.x.store(batch.relGlobalAnchorB[0]);
		relGlobalAnchorB.y.store(batch.relGlobalAnchorB[1]);
		relGlobalAnchorB.z.store(batch.relGlobalAnchorB[2]);

		bias.x.store(batch.bias[0]);
		bias.y.store(batch.bias[1]);
		bias.z.store(batch.bias[2]);

		invEffectiveMass.m[0].store(batch.invEffectiveMass[0]);
		invEffectiveMass.m[1].store(batch.invEffectiveMass[1]);
		invEffectiveMass.m[2].store(batch.invEffectiveMass[2]);
		invEffectiveMass.m[3].store(batch.invEffectiveMass[3]);
		invEffectiveMass.m[4].store(batch.invEffectiveMass[4]);
		invEffectiveMass.m[5].store(batch.invEffectiveMass[5]);
		invEffectiveMass.m[6].store(batch.invEffectiveMass[6]);
		invEffectiveMass.m[7].store(batch.invEffectiveMass[7]);
		invEffectiveMass.m[8].store(batch.invEffectiveMass[8]);


		// Limits and motors.

		w_quat btoa = conjugate(rotationA) * rotationB;

		w_vec3 localLimitAxisCompareA = btoa * localLimitAxisB;

		w_quat swingRotation = rotateFromTo(localLimitAxisA, localLimitAxisCompareA);

		w_vec3 twistTangentA = swingRotation * localLimitTangentA;
		w_vec3 twistBitangentA = swingRotation * localLimitBitangentA;
		w_vec3 localLimitTangentCompareA = btoa * localLimitTangentB;
		w_float twistAngle = atan2(dot(localLimitTangentCompareA, twistBitangentA), dot(localLimitTangentCompareA, twistTangentA));



		// Swing limit.
		w_vec3 swingAxis; w_float swingAngle;
		getAxisRotation(swingRotation, swingAxis, swingAngle);
		auto swingAngleNegative = swingAngle < zero;
		swingAngle = ifThen(swingAngleNegative, -swingAngle, swingAngle);
		swingAxis = ifThen(swingAngleNegative, -swingAxis, swingAxis);

		auto solveSwingLimit = (swingLimit >= zero) & (swingAngle >= swingLimit);
		batch.solveSwingLimit = anyTrue(solveSwingLimit);
		if (batch.solveSwingLimit)
		{
			w_vec3 globalSwingAxis = rotationA * swingAxis;
			w_float invEffectiveLimitMass = dot(globalSwingAxis, invInertiaA * globalSwingAxis)
										 + dot(globalSwingAxis, invInertiaB * globalSwingAxis);
			w_float effectiveSwingLimitMass = ifThen(invEffectiveLimitMass != zero, 1.f / invEffectiveLimitMass, zero);
			effectiveSwingLimitMass = ifThen(solveSwingLimit, effectiveSwingLimitMass, zero); // Set to zero for constraints, which aren't at the limit.

			w_float swingLimitBias = zero;
			if (dt > DT_THRESHOLD)
			{
				swingLimitBias = (swingLimit - swingAngle) * (w_float(HINGE_LIMIT_CONSTRAINT_BETA) * invDt);
			}

			w_vec3 swingLimitImpulseToAngularVelocityA = invInertiaA * globalSwingAxis;
			w_vec3 swingLimitImpulseToAngularVelocityB = invInertiaB * globalSwingAxis;

			globalSwingAxis.x.store(batch.globalSwingAxis[0]);
			globalSwingAxis.y.store(batch.globalSwingAxis[1]);
			globalSwingAxis.z.store(batch.globalSwingAxis[2]);

			zero.store(batch.swingImpulse);
			effectiveSwingLimitMass.store(batch.effectiveSwingLimitMass);
			swingLimitBias.store(batch.swingLimitBias);

			swingLimitImpulseToAngularVelocityA.x.store(batch.swingLimitImpulseToAngularVelocityA[0]);
			swingLimitImpulseToAngularVelocityA.y.store(batch.swingLimitImpulseToAngularVelocityA[1]);
			swingLimitImpulseToAngularVelocityA.z.store(batch.swingLimitImpulseToAngularVelocityA[2]);

			swingLimitImpulseToAngularVelocityB.x.store(batch.swingLimitImpulseToAngularVelocityB[0]);
			swingLimitImpulseToAngularVelocityB.y.store(batch.swingLimitImpulseToAngularVelocityB[1]);
			swingLimitImpulseToAngularVelocityB.z.store(batch.swingLimitImpulseToAngularVelocityB[2]);
		}

		// Swing motor.
		auto solveSwingMotor = maxSwingMotorTorque > zero;
		batch.solveSwingMotor = anyTrue(solveSwingMotor);
		if (batch.solveSwingMotor)
		{
			w_float maxSwingMotorImpulse = maxSwingMotorTorque * w_float(dt);
			maxSwingMotorTorque = ifThen(solveSwingMotor, maxSwingMotorTorque, zero);

			w_float axisX = cos(swingMotorAxis), axisY = sin(swingMotorAxis);
			w_vec3 localSwingMotorAxis = axisX * localLimitTangentA + axisY * localLimitBitangentA;

			auto isVelocityMotor = swingMotorType == constraint_velocity_motor;
			w_vec3 globalSwingMotorAxis = rotationA * localSwingMotorAxis;

			if (anyFalse(isVelocityMotor)) // At least one position motor.
			{
				w_float targetAngle = swingMotorVelocity; // This is a union.
				targetAngle = ifThen(swingLimit >= zero, clamp(targetAngle, -swingLimit, swingLimit), targetAngle);

				w_vec3 localTargetDirection = w_quat(localSwingMotorAxis, targetAngle) * localLimitAxisA;
				w_vec3 localSwingMotorAxis = noz(cross(localLimitAxisCompareA, localTargetDirection));
				w_vec3 globalSwingMotorAxisOverride = rotationA * localSwingMotorAxis;

				w_float cosAngle = dot(localTargetDirection, localLimitAxisCompareA);
				w_float deltaAngle = acos(clamp01(cosAngle));
				w_float swingMotorVelocityOverride = (dt > DT_THRESHOLD) ? (deltaAngle * invDt * w_float(0.2f)) : zero;

				swingMotorVelocity = ifThen(reinterpret(isVelocityMotor), swingMotorVelocity, swingMotorVelocityOverride);
				globalSwingMotorAxis = ifThen(reinterpret(isVelocityMotor), globalSwingMotorAxis, globalSwingMotorAxisOverride);
			}

			w_vec3 swingMotorImpulseToAngularVelocityA = invInertiaA * globalSwingMotorAxis;
			w_vec3 swingMotorImpulseToAngularVelocityB = invInertiaB * globalSwingMotorAxis;

			w_float invEffectiveMotorMass = dot(globalSwingMotorAxis, invInertiaA * globalSwingMotorAxis)
										 + dot(globalSwingMotorAxis, invInertiaB * globalSwingMotorAxis);
			w_float effectiveSwingMotorMass = ifThen(invEffectiveMotorMass != zero, 1.f / invEffectiveMotorMass, zero);
			effectiveSwingMotorMass = ifThen(solveSwingMotor, effectiveSwingMotorMass, zero); // Set to zero for constraints, which have no motor.

			
			zero.store(batch.swingMotorImpulse);
			maxSwingMotorImpulse.store(batch.maxSwingMotorImpulse);
			swingMotorVelocity.store(batch.swingMotorVelocity);

			globalSwingMotorAxis.x.store(batch.globalSwingMotorAxis[0]);
			globalSwingMotorAxis.y.store(batch.globalSwingMotorAxis[1]);
			globalSwingMotorAxis.z.store(batch.globalSwingMotorAxis[2]);

			swingMotorImpulseToAngularVelocityA.x.store(batch.swingMotorImpulseToAngularVelocityA[0]);
			swingMotorImpulseToAngularVelocityA.y.store(batch.swingMotorImpulseToAngularVelocityA[1]);
			swingMotorImpulseToAngularVelocityA.z.store(batch.swingMotorImpulseToAngularVelocityA[2]);

			swingMotorImpulseToAngularVelocityB.x.store(batch.swingMotorImpulseToAngularVelocityB[0]);
			swingMotorImpulseToAngularVelocityB.y.store(batch.swingMotorImpulseToAngularVelocityB[1]);
			swingMotorImpulseToAngularVelocityB.z.store(batch.swingMotorImpulseToAngularVelocityB[2]);

			effectiveSwingMotorMass.store(batch.effectiveSwingMotorMass);
		}

		// Twist limit and motor.
		auto mw_intistLimitViolated = (twistLimit >= zero) & (twistAngle <= -twistLimit);
		auto maxTwistLimitViolated = (twistLimit >= zero) & (twistAngle >= twistLimit);

		auto solveTwistLimit = mw_intistLimitViolated | maxTwistLimitViolated;
		auto solveTwistMotor = maxTwistMotorTorque > zero;
		batch.solveTwistLimit = anyTrue(solveTwistLimit);
		batch.solveTwistMotor = anyTrue(solveTwistMotor);
		if (batch.solveTwistLimit || batch.solveTwistMotor)
		{
			w_vec3 globalTwistAxis = rotationA * localLimitAxisA;
			w_float invEffectiveMass = dot(globalTwistAxis, invInertiaA * globalTwistAxis)
									+ dot(globalTwistAxis, invInertiaB * globalTwistAxis);
			w_float effectiveTwistMass = ifThen(invEffectiveMass != zero, 1.f / invEffectiveMass, zero);

			w_float effectiveTwistLimitMass = ifThen(solveTwistLimit, effectiveTwistMass, zero); // Set to zero for constraints, which aren't at the limit.
			w_float effectiveTwistMotorMass = ifThen(solveTwistMotor, effectiveTwistMass, zero); // Set to zero for constraints, which have no motor.

			w_float twistLimitSign = ifThen(mw_intistLimitViolated, 1.f, -1.f);

			w_float maxTwistMotorImpulse = maxTwistMotorTorque * w_float(dt);
			maxTwistMotorImpulse = ifThen(solveTwistMotor, maxTwistMotorImpulse, zero);

			w_vec3 twistMotorAndLimitImpulseToAngularVelocityA = invInertiaA * globalTwistAxis;
			w_vec3 twistMotorAndLimitImpulseToAngularVelocityB = invInertiaB * globalTwistAxis;

			if (batch.solveTwistMotor)
			{
				auto isVelocityMotor = twistMotorType == constraint_velocity_motor;

				if (anyFalse(isVelocityMotor)) // At least one position motor.
				{
					// Inspired by Bullet Engine. We set the velocity such that the target angle is reached within one frame.
					// This will later get clamped to the maximum motor impulse.
					w_float limit = ifThen(twistLimit >= zero, twistLimit, M_PI);
					w_float twistMotorTargetAngle = twistMotorVelocity; // This is a union.
					w_float targetAngle = clamp(twistMotorTargetAngle, -limit, limit);

					w_float twistMotorVelocityOverride = (dt > DT_THRESHOLD) ? ((targetAngle - twistAngle) * invDt) : zero;
					twistMotorVelocity = ifThen(reinterpret(isVelocityMotor), twistMotorVelocity, twistMotorVelocityOverride);
				}
			}

			w_float twistLimitBias = zero;
			if (batch.solveTwistLimit && dt > DT_THRESHOLD)
			{
				w_float d = ifThen(mw_intistLimitViolated, twistLimit + twistAngle, twistLimit - twistAngle);
				twistLimitBias = d * (w_float(TWIST_LIMIT_CONSTRAINT_BETA) * invDt);
			}

			globalTwistAxis.x.store(batch.globalTwistAxis[0]);
			globalTwistAxis.y.store(batch.globalTwistAxis[1]);
			globalTwistAxis.z.store(batch.globalTwistAxis[2]);

			zero.store(batch.twistImpulse);
			twistLimitSign.store(batch.twistLimitSign);
			effectiveTwistLimitMass.store(batch.effectiveTwistLimitMass);
			effectiveTwistMotorMass.store(batch.effectiveTwistMotorMass);
			twistLimitBias.store(batch.twistLimitBias);

			maxTwistMotorImpulse.store(batch.maxTwistMotorImpulse);
			zero.store(batch.twistMotorImpulse);
			twistMotorVelocity.store(batch.twistMotorVelocity);

			twistMotorAndLimitImpulseToAngularVelocityA.x.store(batch.twistMotorAndLimitImpulseToAngularVelocityA[0]);
			twistMotorAndLimitImpulseToAngularVelocityA.y.store(batch.twistMotorAndLimitImpulseToAngularVelocityA[1]);
			twistMotorAndLimitImpulseToAngularVelocityA.z.store(batch.twistMotorAndLimitImpulseToAngularVelocityA[2]);

			twistMotorAndLimitImpulseToAngularVelocityB.x.store(batch.twistMotorAndLimitImpulseToAngularVelocityB[0]);
			twistMotorAndLimitImpulseToAngularVelocityB.y.store(batch.twistMotorAndLimitImpulseToAngularVelocityB[1]);
			twistMotorAndLimitImpulseToAngularVelocityB.z.store(batch.twistMotorAndLimitImpulseToAngularVelocityB[2]);
		}

	}

	simd_cone_twist_constraint_solver result;
	result.batches = batches;
	result.numBatches = numBatches;
	return result;
}

void solveConeTwistVelocityConstraintsSIMD(simd_cone_twist_constraint_solver constraints, rigid_body_global_state* rbs)
{
	CPU_PROFILE_BLOCK("Solve cone twist constraints SIMD");

	for (uint32 i = 0; i < constraints.numBatches; ++i)
	{
		simd_cone_twist_constraint_batch& batch = constraints.batches[i];


		// Load body A.
		w_vec3 vA, wA;
		w_float invMassA;
		w_mat3 invInertiaA;

		load8(&rbs->invInertia.m00, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaA.m00, invInertiaA.m10, invInertiaA.m20,
			invInertiaA.m01, invInertiaA.m11, invInertiaA.m21,
			invInertiaA.m02, invInertiaA.m12);

		load8(&rbs->invInertia.m22, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaA.m22, invMassA, vA.x, vA.y, vA.z, wA.x, wA.y, wA.z);


		// Load body B.
		w_vec3 vB, wB;
		w_float invMassB;
		w_mat3 invInertiaB;

		load8(&rbs->invInertia.m00, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaB.m00, invInertiaB.m10, invInertiaB.m20,
			invInertiaB.m01, invInertiaB.m11, invInertiaB.m21,
			invInertiaB.m02, invInertiaB.m12);

		load8(&rbs->invInertia.m22, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaB.m22, invMassB, vB.x, vB.y, vB.z, wB.x, wB.y, wB.z);


		// Solve in order of importance (most important last): Motors -> Limits -> Position.

		w_vec3 globalTwistAxis(batch.globalTwistAxis[0], batch.globalTwistAxis[1], batch.globalTwistAxis[2]);
		w_vec3 twistMotorAndLimitImpulseToAngularVelocityA(batch.twistMotorAndLimitImpulseToAngularVelocityA[0], batch.twistMotorAndLimitImpulseToAngularVelocityA[1], batch.twistMotorAndLimitImpulseToAngularVelocityA[2]);
		w_vec3 twistMotorAndLimitImpulseToAngularVelocityB(batch.twistMotorAndLimitImpulseToAngularVelocityB[0], batch.twistMotorAndLimitImpulseToAngularVelocityB[1], batch.twistMotorAndLimitImpulseToAngularVelocityB[2]);

		// Motor.
		if (batch.solveTwistMotor)
		{
			w_float twistMotorVelocity(batch.twistMotorVelocity);
			w_float effectiveTwistMotorMass(batch.effectiveTwistMotorMass);
			w_float twistMotorImpulse(batch.twistMotorImpulse);
			w_float maxTwistMotorImpulse(batch.maxTwistMotorImpulse);

			w_float aDotWA = dot(globalTwistAxis, wA);
			w_float aDotWB = dot(globalTwistAxis, wB);
			w_float relAngularVelocity = (aDotWB - aDotWA);

			w_float motorCdot = relAngularVelocity - twistMotorVelocity;

			w_float motorLambda = -effectiveTwistMotorMass * motorCdot;
			w_float oldImpulse = twistMotorImpulse;
			twistMotorImpulse = clamp(twistMotorImpulse + motorLambda, -maxTwistMotorImpulse, maxTwistMotorImpulse);
			motorLambda = twistMotorImpulse - oldImpulse;

			wA -= twistMotorAndLimitImpulseToAngularVelocityA * motorLambda;
			wB += twistMotorAndLimitImpulseToAngularVelocityB * motorLambda;

			twistMotorImpulse.store(batch.twistMotorImpulse);
		}

		if (batch.solveSwingMotor)
		{
			w_float swingMotorVelocity(batch.swingMotorVelocity);
			w_float effectiveSwingMotorMass(batch.effectiveSwingMotorMass);
			w_vec3 globalSwingMotorAxis(batch.globalSwingMotorAxis[0], batch.globalSwingMotorAxis[1], batch.globalSwingMotorAxis[2]);
			w_float swingMotorImpulse(batch.swingMotorImpulse);
			w_float maxSwingMotorImpulse(batch.maxSwingMotorImpulse);

			w_vec3 swingMotorImpulseToAngularVelocityA(batch.swingMotorImpulseToAngularVelocityA[0], batch.swingMotorImpulseToAngularVelocityA[1], batch.swingMotorImpulseToAngularVelocityA[2]);
			w_vec3 swingMotorImpulseToAngularVelocityB(batch.swingMotorImpulseToAngularVelocityB[0], batch.swingMotorImpulseToAngularVelocityB[1], batch.swingMotorImpulseToAngularVelocityB[2]);

			w_float aDotWA = dot(globalSwingMotorAxis, wA);
			w_float aDotWB = dot(globalSwingMotorAxis, wB);
			w_float relAngularVelocity = (aDotWB - aDotWA);

			w_float motorCdot = relAngularVelocity - swingMotorVelocity;

			w_float motorLambda = -effectiveSwingMotorMass * motorCdot;
			w_float oldImpulse = swingMotorImpulse;
			swingMotorImpulse = clamp(swingMotorImpulse + motorLambda, -maxSwingMotorImpulse, maxSwingMotorImpulse);
			motorLambda = swingMotorImpulse - oldImpulse;

			wA -= swingMotorImpulseToAngularVelocityA * motorLambda;
			wB += swingMotorImpulseToAngularVelocityB * motorLambda;

			swingMotorImpulse.store(batch.swingMotorImpulse);
		}

		// Twist.
		if (batch.solveTwistLimit)
		{
			w_float limitSign(batch.twistLimitSign);
			w_float twistLimitBias(batch.twistLimitBias);
			w_float effectiveTwistLimitMass(batch.effectiveTwistLimitMass);
			w_float twistImpulse(batch.twistImpulse);

			w_float aDotWA = dot(globalTwistAxis, wA);
			w_float aDotWB = dot(globalTwistAxis, wB);
			w_float relAngularVelocity = limitSign * (aDotWB - aDotWA);

			w_float limitCdot = relAngularVelocity + twistLimitBias;
			w_float limitLambda = -effectiveTwistLimitMass * limitCdot;

			w_float impulse = maximum(twistImpulse + limitLambda, w_float::zero());
			limitLambda = impulse - twistImpulse;
			twistImpulse = impulse;

			limitLambda *= limitSign;

			wA -= twistMotorAndLimitImpulseToAngularVelocityA * limitLambda;
			wB += twistMotorAndLimitImpulseToAngularVelocityB * limitLambda;

			twistImpulse.store(batch.twistImpulse);
		}

		// Cone.
		if (batch.solveSwingLimit)
		{
			w_vec3 globalSwingAxis(batch.globalSwingAxis[0], batch.globalSwingAxis[1], batch.globalSwingAxis[2]);
			w_float swingLimitBias(batch.swingLimitBias);
			w_float effectiveSwingLimitMass(batch.effectiveSwingLimitMass);
			w_float swingImpulse(batch.swingImpulse);

			w_vec3 swingLimitImpulseToAngularVelocityA(batch.swingLimitImpulseToAngularVelocityA[0], batch.swingLimitImpulseToAngularVelocityA[1], batch.swingLimitImpulseToAngularVelocityA[2]);
			w_vec3 swingLimitImpulseToAngularVelocityB(batch.swingLimitImpulseToAngularVelocityB[0], batch.swingLimitImpulseToAngularVelocityB[1], batch.swingLimitImpulseToAngularVelocityB[2]);

			w_float aDotWA = dot(globalSwingAxis, wA);
			w_float aDotWB = dot(globalSwingAxis, wB);
			w_float swingLimitCdot = aDotWA - aDotWB + swingLimitBias;
			w_float limitLambda = -effectiveSwingLimitMass * swingLimitCdot;

			w_float impulse = maximum(swingImpulse + limitLambda, w_float::zero());
			limitLambda = impulse - swingImpulse;
			swingImpulse = impulse;

			wA += swingLimitImpulseToAngularVelocityA * limitLambda;
			wB -= swingLimitImpulseToAngularVelocityB * limitLambda;

			swingImpulse.store(batch.swingImpulse);
		}


		// Position part.
		{
			w_vec3 relGlobalAnchorA(batch.relGlobalAnchorA[0], batch.relGlobalAnchorA[1], batch.relGlobalAnchorA[2]);
			w_vec3 relGlobalAnchorB(batch.relGlobalAnchorB[0], batch.relGlobalAnchorB[1], batch.relGlobalAnchorB[2]);
			w_vec3 bias(batch.bias[0], batch.bias[1], batch.bias[2]);

			w_mat3 invEffectiveMass;
			invEffectiveMass.m[0] = w_float(batch.invEffectiveMass[0]);
			invEffectiveMass.m[1] = w_float(batch.invEffectiveMass[1]);
			invEffectiveMass.m[2] = w_float(batch.invEffectiveMass[2]);
			invEffectiveMass.m[3] = w_float(batch.invEffectiveMass[3]);
			invEffectiveMass.m[4] = w_float(batch.invEffectiveMass[4]);
			invEffectiveMass.m[5] = w_float(batch.invEffectiveMass[5]);
			invEffectiveMass.m[6] = w_float(batch.invEffectiveMass[6]);
			invEffectiveMass.m[7] = w_float(batch.invEffectiveMass[7]);
			invEffectiveMass.m[8] = w_float(batch.invEffectiveMass[8]);

			w_vec3 anchorVelocityA = vA + cross(wA, relGlobalAnchorA);
			w_vec3 anchorVelocityB = vB + cross(wB, relGlobalAnchorB);
			w_vec3 translationCdot = anchorVelocityB - anchorVelocityA + bias;

			w_vec3 translationP = solveLinearSystem(invEffectiveMass, -translationCdot);

			vA -= invMassA * translationP;
			wA -= invInertiaA * cross(relGlobalAnchorA, translationP);
			vB += invMassB * translationP;
			wB += invInertiaB * cross(relGlobalAnchorB, translationP);
		}



		store8(&rbs->invInertia.m22, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaA.m22, invMassA, vA.x, vA.y, vA.z, wA.x, wA.y, wA.z);

		store8(&rbs->invInertia.m22, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaB.m22, invMassB, vB.x, vB.y, vB.z, wB.x, wB.y, wB.z);
	}
}



slider_constraint_solver initializeSliderVelocityConstraints(memory_arena& arena, const rigid_body_global_state* rbs, const slider_constraint* input, const constraint_body_pair* bodyPairs, uint32 count, float dt)
{
	CPU_PROFILE_BLOCK("Initialize slider constraints");

	float invDt = 1.f / dt;

	slider_constraint_update* constraints = arena.allocate<slider_constraint_update>(count);

	for (uint32 i = 0; i < count; ++i)
	{
		const slider_constraint& in = input[i];
		slider_constraint_update& out = constraints[i];

		out.rigidBodyIndexA = bodyPairs[i].rbA;
		out.rigidBodyIndexB = bodyPairs[i].rbB;

		const rigid_body_global_state& globalA = rbs[out.rigidBodyIndexA];
		const rigid_body_global_state& globalB = rbs[out.rigidBodyIndexB];

		// Relative to COG.
		vec3 relGlobalAnchorA = globalA.rotation * (in.localAnchorA - globalA.localCOGPosition);
		vec3 relGlobalAnchorB = globalB.rotation * (in.localAnchorB - globalB.localCOGPosition);

		// Global.
		vec3 globalAnchorA = globalA.position + relGlobalAnchorA;
		vec3 globalAnchorB = globalB.position + relGlobalAnchorB;

		
		vec3 globalSliderAxis = globalA.rotation * in.localAxisA;
		getTangents(globalSliderAxis, out.tangent, out.bitangent);
		vec3 u = globalAnchorB - globalAnchorA;

		vec3 rAu = relGlobalAnchorA + u;
		out.rBxt = cross(relGlobalAnchorB, out.tangent);
		out.rBxb = cross(relGlobalAnchorB, out.bitangent);
		out.rAuxt = cross(rAu, out.tangent);
		out.rAuxb = cross(rAu, out.bitangent);

		vec3 iArAuxt = globalA.invInertia * out.rAuxt;
		vec3 iArAuxb = globalA.invInertia * out.rAuxb;
		vec3 iBrBxt = globalB.invInertia * out.rBxt;
		vec3 iBrBxb = globalB.invInertia * out.rBxb;
		float invMassSum = globalA.invMass + globalB.invMass;

		out.invEffectiveTranslationMass.m00 = dot(out.rAuxt, iArAuxt) + dot(out.rBxt, iBrBxt) + invMassSum;
		out.invEffectiveTranslationMass.m01 = dot(out.rAuxt, iArAuxb) + dot(out.rBxt, iBrBxb);
		out.invEffectiveTranslationMass.m10 = dot(out.rAuxb, iArAuxt) + dot(out.rBxb, iBrBxt);
		out.invEffectiveTranslationMass.m11 = dot(out.rAuxb, iArAuxb) + dot(out.rBxb, iBrBxb) + invMassSum;

		out.invEffectiveRotationMass = globalA.invInertia + globalB.invInertia;
		out.translationBias = vec2(0.f, 0.f);
		out.rotationBias = vec3(0.f, 0.f, 0.f);

		if (dt > DT_THRESHOLD)
		{
			float a = dot(u, out.tangent);
			float b = dot(u, out.bitangent);
			out.translationBias = vec2(a, b) * (SLIDER_CONSTRAINT_BETA * invDt);

			quat rotationError = globalB.rotation * in.initialInvRotationDifference * conjugate(globalA.rotation);
			out.rotationBias = rotationError.v * (SLIDER_CONSTRAINT_BETA * invDt * 2.f);
		}

		out.globalSliderAxis = globalSliderAxis;
		float distanceAlongSlider = dot(u, globalSliderAxis);

		out.solveLimit = false;
		if (in.negDistanceLimit <= 0.f || in.posDistanceLimit >= 0.f)
		{
			bool minLimitViolated = (in.negDistanceLimit <= 0.f) && (distanceAlongSlider < in.negDistanceLimit);
			bool maxLimitViolated = (in.posDistanceLimit >= 0.f) && (distanceAlongSlider > in.posDistanceLimit);

			ASSERT(!(minLimitViolated && maxLimitViolated));

			if (minLimitViolated || maxLimitViolated)
			{
				out.solveLimit = true;
				out.limitImpulse = 0.f;

				out.rAuxs = cross(rAu, globalSliderAxis);
				out.rBxs = cross(relGlobalAnchorB, globalSliderAxis);
				float invEffectiveAxialMass = invMassSum + dot(out.rAuxs, globalA.invInertia * out.rAuxs) + dot(out.rBxs, globalB.invInertia * out.rBxs);
				out.effectiveAxialMass = (invEffectiveAxialMass != 0.f) ? (1.f / invEffectiveAxialMass) : 0.f;
				out.limitSign = minLimitViolated ? 1.f : -1.f;

				out.limitBias = 0.f;
				if (dt > DT_THRESHOLD)
				{
					float error = minLimitViolated ? (distanceAlongSlider - in.negDistanceLimit) : (in.posDistanceLimit - distanceAlongSlider);
					out.limitBias = error * (SLIDER_LIMIT_CONSTRAINT_BETA * invDt);
				}

				out.limitImpulseToAngularVelocityA = globalA.invInertia * out.rAuxs;
				out.limitImpulseToAngularVelocityB = globalB.invInertia * out.rBxs;
			}
		}

		out.solveMotor = false;
		if (in.maxMotorForce > 0.f)
		{
			out.solveMotor = true;
			out.maxMotorImpulse = in.maxMotorForce * dt;
			out.motorImpulse = 0.f;

			out.motorVelocity = in.motorVelocity;
			if (in.motorType == constraint_position_motor)
			{
				// Inspired by Bullet Engine. We set the velocity such that the target angle is reached within one frame.
				// This will later get clamped to the maximum motor impulse.
				float minLimit = (in.negDistanceLimit <= 0.f) ? in.negDistanceLimit : -INFINITY;
				float maxLimit = (in.posDistanceLimit >= 0.f) ? in.posDistanceLimit : INFINITY;
				float targetDistance = clamp(in.motorTargetDistance, minLimit, maxLimit);
				out.motorVelocity = (dt > DT_THRESHOLD) ? ((targetDistance - distanceAlongSlider) * invDt) : 0.f;
			}
		}
	}

	slider_constraint_solver result;
	result.constraints = constraints;
	result.count = count;
	return result;
}

void solveSliderVelocityConstraints(slider_constraint_solver constraints, rigid_body_global_state* rbs)
{
	CPU_PROFILE_BLOCK("Solve slider constraints");

	for (uint32 i = 0; i < constraints.count; ++i)
	{
		slider_constraint_update& con = constraints.constraints[i];

		rigid_body_global_state& rbA = rbs[con.rigidBodyIndexA];
		rigid_body_global_state& rbB = rbs[con.rigidBodyIndexB];

		vec3 vA = rbA.linearVelocity;
		vec3 wA = rbA.angularVelocity;
		vec3 vB = rbB.linearVelocity;
		vec3 wB = rbB.angularVelocity;


		// Motor.
		if (con.solveMotor)
		{
			float Cdot = dot(vB, con.globalSliderAxis) - dot(vA, con.globalSliderAxis) - con.motorVelocity;
			float mass = 1.f / (rbA.invMass + rbB.invMass);

			float motorLambda = -mass * Cdot;
			float oldImpulse = con.motorImpulse;
			con.motorImpulse = clamp(con.motorImpulse + motorLambda, -con.maxMotorImpulse, con.maxMotorImpulse);
			motorLambda = con.motorImpulse - oldImpulse;

			vec3 P = motorLambda * con.globalSliderAxis;

			vA -= rbA.invMass * P;
			vB += rbB.invMass * P;
		}

		// Limit.
		if (con.solveLimit)
		{
			float Cdot = dot(vB, con.globalSliderAxis) + dot(wB, con.rBxs) - dot(vA, con.globalSliderAxis) - dot(wA, con.rAuxs);
			float limitLambda = -con.effectiveAxialMass * (con.limitSign * Cdot + con.limitBias);

			float impulse = max(con.limitImpulse + limitLambda, 0.f);
			limitLambda = impulse - con.limitImpulse;
			con.limitImpulse = impulse;

			limitLambda *= con.limitSign;

			vec3 P = limitLambda * con.globalSliderAxis;

			vA -= rbA.invMass * P;
			wA -= con.limitImpulseToAngularVelocityA * limitLambda;
			vB += rbB.invMass * P;
			wB += con.limitImpulseToAngularVelocityB * limitLambda;
		}
		
		// Rotation part.
		{
			vec3 Cdot = wB - wA;

			vec3 rotationLambda = solveLinearSystem(con.invEffectiveRotationMass, -(Cdot + con.rotationBias));
			wA -= rbA.invInertia * rotationLambda;
			wB += rbB.invInertia * rotationLambda;
		}

		// Position part.
		{
			vec2 Cdot;
			Cdot.x = dot(con.tangent, vB) + dot(con.rBxt, wB) - dot(con.tangent, vA) - dot(con.rAuxt, wA);
			Cdot.y = dot(con.bitangent, vB) + dot(con.rBxb, wB) - dot(con.bitangent, vA) - dot(con.rAuxb, wA);

			vec2 translationLambda = solveLinearSystem(con.invEffectiveTranslationMass, -(Cdot + con.translationBias));

			vec3 tb = con.tangent * translationLambda.x + con.bitangent * translationLambda.y;

			vA -= rbA.invMass * tb;
			wA -= rbA.invInertia * (con.rAuxt * translationLambda.x + con.rAuxb * translationLambda.y);
			vB += rbB.invMass * tb;
			wB += rbB.invInertia * (con.rBxt * translationLambda.x + con.rBxb * translationLambda.y);
		}


		rbA.linearVelocity = vA;
		rbA.angularVelocity = wA;
		rbB.linearVelocity = vB;
		rbB.angularVelocity = wB;
	}
}

simd_slider_constraint_solver initializeSliderVelocityConstraintsSIMD(memory_arena& arena, const rigid_body_global_state* rbs, const slider_constraint* input, const constraint_body_pair* bodyPairs, uint32 count, float dt)
{
	CPU_PROFILE_BLOCK("Initialize slider constraints SIMD");

	simd_constraint_slot* contactSlots = arena.allocate<simd_constraint_slot>(count);
	uint32 numBatches = scheduleConstraintsSIMD(arena, bodyPairs, count, UINT16_MAX, contactSlots);

	simd_slider_constraint_batch* batches = arena.allocate<simd_slider_constraint_batch>(numBatches);

	const w_float zero = w_float::zero();
	const w_float invDt = 1.f / dt;
	const w_float one = 1.f;

	for (uint32 i = 0; i < numBatches; ++i)
	{
		const simd_constraint_slot& slot = contactSlots[i];
		simd_slider_constraint_batch& batch = batches[i];

		uint16 constraintIndices[CONSTRAINT_SIMD_WIDTH];
		for (uint32 j = 0; j < CONSTRAINT_SIMD_WIDTH; ++j)
		{
			constraintIndices[j] = (uint16)slot.indices[j];
			batch.rbAIndices[j] = bodyPairs[slot.indices[j]].rbA;
			batch.rbBIndices[j] = bodyPairs[slot.indices[j]].rbB;
		}


		// Load body A.
		w_vec3 localCOGPositionA;
		w_quat rotationA;
		w_vec3 positionA;
		w_mat3 invInertiaA;
		w_float invMassA;

		load8(&rbs->rotation.x, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			rotationA.x, rotationA.y, rotationA.z, rotationA.w,
			localCOGPositionA.x, localCOGPositionA.y, localCOGPositionA.z,
			positionA.x);

		load8(&rbs->position.y, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			positionA.y, positionA.z,
			invInertiaA.m00, invInertiaA.m10, invInertiaA.m20,
			invInertiaA.m01, invInertiaA.m11, invInertiaA.m21);

		load4(&rbs->invInertia.m02, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaA.m02, invInertiaA.m12, invInertiaA.m22,
			invMassA);


		// Load body B.
		w_quat rotationB;
		w_vec3 positionB;
		w_vec3 localCOGPositionB;
		w_mat3 invInertiaB;
		w_float invMassB;

		load8(&rbs->rotation.x, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			rotationB.x, rotationB.y, rotationB.z, rotationB.w,
			localCOGPositionB.x, localCOGPositionB.y, localCOGPositionB.z,
			positionB.x);

		load8(&rbs->position.y, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			positionB.y, positionB.z,
			invInertiaB.m00, invInertiaB.m10, invInertiaB.m20,
			invInertiaB.m01, invInertiaB.m11, invInertiaB.m21);

		load4(&rbs->invInertia.m02, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaB.m02, invInertiaB.m12, invInertiaB.m22,
			invMassB);


		w_quat initialInvRotationDifference;
		w_vec3 localAnchorA;
		w_vec3 localAnchorB;
		w_vec3 localAxisA;

		w_float negDistanceLimit;
		w_float posDistanceLimit;
		w_float maxMotorForce;

		load8((float*)input, constraintIndices, (uint32)sizeof(*input),
			initialInvRotationDifference.x, initialInvRotationDifference.y, initialInvRotationDifference.z, initialInvRotationDifference.w,
			localAnchorA.x, localAnchorA.y, localAnchorA.z,
			localAnchorB.x);

		load8(&input->localAnchorB.y, constraintIndices, (uint32)sizeof(*input),
			localAnchorB.y, localAnchorB.z,
			localAxisA.x, localAxisA.y, localAxisA.z,
			negDistanceLimit, posDistanceLimit, 
			maxMotorForce);



		// Relative to COG.
		w_vec3 relGlobalAnchorA = rotationA * (localAnchorA - localCOGPositionA);
		w_vec3 relGlobalAnchorB = rotationB * (localAnchorB - localCOGPositionB);

		// Global.
		w_vec3 globalAnchorA = positionA + relGlobalAnchorA;
		w_vec3 globalAnchorB = positionB + relGlobalAnchorB;

		w_vec3 globalSliderAxis = rotationA * localAxisA;

		w_vec3 tangent, bitangent;
		getTangents(globalSliderAxis, tangent, bitangent);
		w_vec3 u = globalAnchorB - globalAnchorA;

		w_vec3 rAu = relGlobalAnchorA + u;
		w_vec3 rBxt = cross(relGlobalAnchorB, tangent);
		w_vec3 rBxb = cross(relGlobalAnchorB, bitangent);
		w_vec3 rAuxt = cross(rAu, tangent);
		w_vec3 rAuxb = cross(rAu, bitangent);

		w_vec3 iArAuxt = invInertiaA * rAuxt;
		w_vec3 iArAuxb = invInertiaA * rAuxb;
		w_vec3 iBrBxt = invInertiaB * rBxt;
		w_vec3 iBrBxb = invInertiaB * rBxb;
		w_float invMassSum = invMassA + invMassB;

		w_mat2 invEffectiveTranslationMass;
		invEffectiveTranslationMass.m00 = dot(rAuxt, iArAuxt) + dot(rBxt, iBrBxt) + invMassSum;
		invEffectiveTranslationMass.m01 = dot(rAuxt, iArAuxb) + dot(rBxt, iBrBxb);
		invEffectiveTranslationMass.m10 = dot(rAuxb, iArAuxt) + dot(rBxb, iBrBxt);
		invEffectiveTranslationMass.m11 = dot(rAuxb, iArAuxb) + dot(rBxb, iBrBxb) + invMassSum;

		w_mat3 invEffectiveRotationMass = invInertiaA + invInertiaB;
		w_vec2 translationBias = zero;
		w_vec3 rotationBias = zero;

		if (dt > DT_THRESHOLD)
		{
			w_float a = dot(u, tangent);
			w_float b = dot(u, bitangent);
			translationBias = w_vec2(a, b) * (SLIDER_CONSTRAINT_BETA * invDt);

			w_quat rotationError = rotationB * initialInvRotationDifference * conjugate(rotationA);
			rotationBias = rotationError.v * (SLIDER_CONSTRAINT_BETA * 2.f * invDt);
		}

		rAuxt.x.store(batch.rAuxt[0]);
		rAuxt.y.store(batch.rAuxt[1]);
		rAuxt.z.store(batch.rAuxt[2]);

		rAuxb.x.store(batch.rAuxb[0]);
		rAuxb.y.store(batch.rAuxb[1]);
		rAuxb.z.store(batch.rAuxb[2]);

		rBxt.x.store(batch.rBxt[0]);
		rBxt.y.store(batch.rBxt[1]);
		rBxt.z.store(batch.rBxt[2]);

		rBxb.x.store(batch.rBxb[0]);
		rBxb.y.store(batch.rBxb[1]);
		rBxb.z.store(batch.rBxb[2]);

		tangent.x.store(batch.tangent[0]);
		tangent.y.store(batch.tangent[1]);
		tangent.z.store(batch.tangent[2]);

		bitangent.x.store(batch.bitangent[0]);
		bitangent.y.store(batch.bitangent[1]);
		bitangent.z.store(batch.bitangent[2]);

		invEffectiveTranslationMass.m[0].store(batch.invEffectiveTranslationMass[0]);
		invEffectiveTranslationMass.m[1].store(batch.invEffectiveTranslationMass[1]);
		invEffectiveTranslationMass.m[2].store(batch.invEffectiveTranslationMass[2]);
		invEffectiveTranslationMass.m[3].store(batch.invEffectiveTranslationMass[3]);

		translationBias.x.store(batch.translationBias[0]);
		translationBias.y.store(batch.translationBias[1]);

		invEffectiveRotationMass.m[0].store(batch.invEffectiveRotationMass[0]);
		invEffectiveRotationMass.m[1].store(batch.invEffectiveRotationMass[1]);
		invEffectiveRotationMass.m[2].store(batch.invEffectiveRotationMass[2]);
		invEffectiveRotationMass.m[3].store(batch.invEffectiveRotationMass[3]);
		invEffectiveRotationMass.m[4].store(batch.invEffectiveRotationMass[4]);
		invEffectiveRotationMass.m[5].store(batch.invEffectiveRotationMass[5]);
		invEffectiveRotationMass.m[6].store(batch.invEffectiveRotationMass[6]);
		invEffectiveRotationMass.m[7].store(batch.invEffectiveRotationMass[7]);
		invEffectiveRotationMass.m[8].store(batch.invEffectiveRotationMass[8]);

		rotationBias.x.store(batch.rotationBias[0]);
		rotationBias.y.store(batch.rotationBias[1]);
		rotationBias.z.store(batch.rotationBias[2]);

		globalSliderAxis.x.store(batch.globalSliderAxis[0]);
		globalSliderAxis.y.store(batch.globalSliderAxis[1]);
		globalSliderAxis.z.store(batch.globalSliderAxis[2]);


		w_float distanceAlongSlider = dot(u, globalSliderAxis);


		auto minLimitActive = negDistanceLimit <= zero;
		auto maxLimitActive = posDistanceLimit >= zero;

		if (anyTrue(minLimitActive | maxLimitActive))
		{
			auto minLimitViolated = minLimitActive & (distanceAlongSlider < negDistanceLimit);
			auto maxLimitViolated = maxLimitActive & (distanceAlongSlider > posDistanceLimit);

			auto limitViolated = minLimitViolated | maxLimitViolated;
			batch.solveLimit = anyTrue(limitViolated);

			if (batch.solveLimit)
			{
				w_vec3 rAuxs = cross(rAu, globalSliderAxis);
				w_vec3 rBxs = cross(relGlobalAnchorB, globalSliderAxis);
				w_float invEffectiveAxialMass = invMassSum + dot(rAuxs, invInertiaA * rAuxs) + dot(rBxs, invInertiaB * rBxs);
				w_float effectiveAxialMass = ifThen(invEffectiveAxialMass != zero, one / invEffectiveAxialMass, zero);
				effectiveAxialMass = ifThen(limitViolated, effectiveAxialMass, zero);
				w_float limitSign = ifThen(minLimitViolated, one, -one);

				w_float limitBias = zero;
				if (dt > DT_THRESHOLD)
				{
					w_float error = ifThen(minLimitViolated, distanceAlongSlider - negDistanceLimit, posDistanceLimit - distanceAlongSlider);
					limitBias = error * (SLIDER_LIMIT_CONSTRAINT_BETA * invDt);
				}

				w_vec3 limitImpulseToAngularVelocityA = invInertiaA * rAuxs;
				w_vec3 limitImpulseToAngularVelocityB = invInertiaB * rBxs;

				rAuxs.x.store(batch.rAuxs[0]);
				rAuxs.y.store(batch.rAuxs[1]);
				rAuxs.z.store(batch.rAuxs[2]);

				rBxs.x.store(batch.rBxs[0]);
				rBxs.y.store(batch.rBxs[1]);
				rBxs.z.store(batch.rBxs[2]);

				zero.store(batch.limitImpulse);
				effectiveAxialMass.store(batch.effectiveAxialMass);
				limitSign.store(batch.limitSign);
				limitBias.store(batch.limitBias);

				limitImpulseToAngularVelocityA.x.store(batch.limitImpulseToAngularVelocityA[0]);
				limitImpulseToAngularVelocityA.y.store(batch.limitImpulseToAngularVelocityA[1]);
				limitImpulseToAngularVelocityA.z.store(batch.limitImpulseToAngularVelocityA[2]);

				limitImpulseToAngularVelocityB.x.store(batch.limitImpulseToAngularVelocityB[0]);
				limitImpulseToAngularVelocityB.y.store(batch.limitImpulseToAngularVelocityB[1]);
				limitImpulseToAngularVelocityB.z.store(batch.limitImpulseToAngularVelocityB[2]);
			}

		}




		auto motorActive = maxMotorForce > zero;
		batch.solveMotor = anyTrue(motorActive);
		if (batch.solveMotor)
		{
			w_float motorTypeF;
			w_float motorVelocity;
			w_float dummy0, dummy1;

			load4((float*)&input->motorType, constraintIndices, (uint32)sizeof(*input),
				motorTypeF, motorVelocity,
				dummy0, dummy1);

			w_int motorType = reinterpret(motorTypeF);

			w_float maxMotorImpulse = maxMotorForce * dt;
			maxMotorImpulse = ifThen(motorActive, maxMotorImpulse, zero);

			auto isVelocityMotor = motorType == constraint_velocity_motor;

			if (anyFalse(isVelocityMotor))
			{
				// Inspired by Bullet Engine. We set the velocity such that the target angle is reached within one frame.
				// This will later get clamped to the maximum motor impulse.

				w_float motorTargetDistance = motorVelocity; // This is a union.

				w_float minLimit = ifThen(negDistanceLimit <= zero, negDistanceLimit, -INFINITY);
				w_float maxLimit = ifThen(posDistanceLimit >= zero, posDistanceLimit, INFINITY);
				w_float targetDistance = clamp(motorTargetDistance, minLimit, maxLimit);
				w_float motorVelocityOverride = (dt > DT_THRESHOLD) ? ((targetDistance - distanceAlongSlider) * invDt) : 0.f;
				motorVelocity = ifThen(reinterpret(isVelocityMotor), motorVelocity, motorVelocityOverride);
			}

			w_float effectiveMotorMass = one / invMassSum;
			effectiveMotorMass = ifThen(motorActive, effectiveMotorMass, zero);

			zero.store(batch.motorImpulse);
			maxMotorImpulse.store(batch.maxMotorImpulse);
			motorVelocity.store(batch.motorVelocity);
			effectiveMotorMass.store(batch.effectiveMotorMass);
		}

	}

	simd_slider_constraint_solver result;
	result.batches = batches;
	result.numBatches = numBatches;
	return result;
}

void solveSliderVelocityConstraintsSIMD(simd_slider_constraint_solver constraints, rigid_body_global_state* rbs)
{
	CPU_PROFILE_BLOCK("Solve slider constraints SIMD");

	for (uint32 i = 0; i < constraints.numBatches; ++i)
	{
		simd_slider_constraint_batch& batch = constraints.batches[i];


		// Load body A.
		w_vec3 vA, wA;
		w_float invMassA;
		w_mat3 invInertiaA;

		load8(&rbs->invInertia.m00, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaA.m00, invInertiaA.m10, invInertiaA.m20,
			invInertiaA.m01, invInertiaA.m11, invInertiaA.m21,
			invInertiaA.m02, invInertiaA.m12);

		load8(&rbs->invInertia.m22, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaA.m22, invMassA, vA.x, vA.y, vA.z, wA.x, wA.y, wA.z);


		// Load body B.
		w_vec3 vB, wB;
		w_float invMassB;
		w_mat3 invInertiaB;

		load8(&rbs->invInertia.m00, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaB.m00, invInertiaB.m10, invInertiaB.m20,
			invInertiaB.m01, invInertiaB.m11, invInertiaB.m21,
			invInertiaB.m02, invInertiaB.m12);

		load8(&rbs->invInertia.m22, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaB.m22, invMassB, vB.x, vB.y, vB.z, wB.x, wB.y, wB.z);


		w_vec3 globalSliderAxis(batch.globalSliderAxis[0], batch.globalSliderAxis[1], batch.globalSliderAxis[2]);

		// Motor.
		if (batch.solveMotor)
		{
			w_float motorVelocity(batch.motorVelocity);
			w_float motorImpulse(batch.motorImpulse);
			w_float maxMotorImpulse(batch.maxMotorImpulse);
			w_float effectiveMotorMass(batch.effectiveMotorMass);

			w_float Cdot = dot(vB, globalSliderAxis) - dot(vA, globalSliderAxis) - motorVelocity;

			w_float motorLambda = -effectiveMotorMass * Cdot;
			w_float oldImpulse = motorImpulse;
			motorImpulse = clamp(motorImpulse + motorLambda, -maxMotorImpulse, maxMotorImpulse);
			motorLambda = motorImpulse - oldImpulse;

			w_vec3 P = motorLambda * globalSliderAxis;

			vA -= invMassA * P;
			vB += invMassB * P;

			motorImpulse.store(batch.motorImpulse);
		}

		// Limit.
		if (batch.solveLimit)
		{
			w_float limitSign(batch.limitSign);
			w_float limitBias(batch.limitBias);
			w_float effectiveAxialMass(batch.effectiveAxialMass);
			w_float limitImpulse(batch.limitImpulse);

			w_vec3 rAuxs(batch.rAuxs[0], batch.rAuxs[1], batch.rAuxs[2]);
			w_vec3 rBxs(batch.rBxs[0], batch.rBxs[1], batch.rBxs[2]);

			w_vec3 limitImpulseToAngularVelocityA(batch.limitImpulseToAngularVelocityA[0], batch.limitImpulseToAngularVelocityA[1], batch.limitImpulseToAngularVelocityA[2]);
			w_vec3 limitImpulseToAngularVelocityB(batch.limitImpulseToAngularVelocityB[0], batch.limitImpulseToAngularVelocityB[1], batch.limitImpulseToAngularVelocityB[2]);

			w_float Cdot = dot(vB, globalSliderAxis) + dot(wB, rBxs) - dot(vA, globalSliderAxis) - dot(wA, rAuxs);
			w_float limitLambda = -effectiveAxialMass * (limitSign * Cdot + limitBias);

			w_float impulse = maximum(limitImpulse + limitLambda, 0.f);
			limitLambda = impulse - limitImpulse;
			limitImpulse = impulse;

			limitLambda *= limitSign;

			w_vec3 P = limitLambda * globalSliderAxis;

			vA -= invMassA * P;
			wA -= limitImpulseToAngularVelocityA * limitLambda;
			vB += invMassB * P;
			wB += limitImpulseToAngularVelocityB * limitLambda;

			limitImpulse.store(batch.limitImpulse);
		}


		// Rotation part.
		{
			w_mat3 invEffectiveRotationMass;
			invEffectiveRotationMass.m[0] = w_float(batch.invEffectiveRotationMass[0]);
			invEffectiveRotationMass.m[1] = w_float(batch.invEffectiveRotationMass[1]);
			invEffectiveRotationMass.m[2] = w_float(batch.invEffectiveRotationMass[2]);
			invEffectiveRotationMass.m[3] = w_float(batch.invEffectiveRotationMass[3]);
			invEffectiveRotationMass.m[4] = w_float(batch.invEffectiveRotationMass[4]);
			invEffectiveRotationMass.m[5] = w_float(batch.invEffectiveRotationMass[5]);
			invEffectiveRotationMass.m[6] = w_float(batch.invEffectiveRotationMass[6]);
			invEffectiveRotationMass.m[7] = w_float(batch.invEffectiveRotationMass[7]);
			invEffectiveRotationMass.m[8] = w_float(batch.invEffectiveRotationMass[8]);

			w_vec3 rotationBias(batch.rotationBias[0], batch.rotationBias[1], batch.rotationBias[2]);

			w_vec3 Cdot = wB - wA;

			w_vec3 rotationLambda = solveLinearSystem(invEffectiveRotationMass, -(Cdot + rotationBias));
			wA -= invInertiaA * rotationLambda;
			wB += invInertiaB * rotationLambda;
		}

		// Position part.
		{
			w_vec3 tangent(batch.tangent[0], batch.tangent[1], batch.tangent[2]);
			w_vec3 bitangent(batch.bitangent[0], batch.bitangent[1], batch.bitangent[2]);
			w_vec3 rAuxt(batch.rAuxt[0], batch.rAuxt[1], batch.rAuxt[2]);
			w_vec3 rAuxb(batch.rAuxb[0], batch.rAuxb[1], batch.rAuxb[2]);
			w_vec3 rBxt(batch.rBxt[0], batch.rBxt[1], batch.rBxt[2]);
			w_vec3 rBxb(batch.rBxb[0], batch.rBxb[1], batch.rBxb[2]);

			w_mat2 invEffectiveTranslationMass;
			invEffectiveTranslationMass.m[0] = w_float(batch.invEffectiveTranslationMass[0]);
			invEffectiveTranslationMass.m[1] = w_float(batch.invEffectiveTranslationMass[1]);
			invEffectiveTranslationMass.m[2] = w_float(batch.invEffectiveTranslationMass[2]);
			invEffectiveTranslationMass.m[3] = w_float(batch.invEffectiveTranslationMass[3]);

			w_vec2 translationBias(batch.translationBias[0], batch.translationBias[1]);

			w_vec2 Cdot;
			Cdot.x = dot(tangent, vB) + dot(rBxt, wB) - dot(tangent, vA) - dot(rAuxt, wA);
			Cdot.y = dot(bitangent, vB) + dot(rBxb, wB) - dot(bitangent, vA) - dot(rAuxb, wA);

			w_vec2 translationLambda = solveLinearSystem(invEffectiveTranslationMass, -(Cdot + translationBias));

			w_vec3 tb = tangent * translationLambda.x + bitangent * translationLambda.y;

			vA -= invMassA * tb;
			wA -= invInertiaA * (rAuxt * translationLambda.x + rAuxb * translationLambda.y);
			vB += invMassB * tb;
			wB += invInertiaB * (rBxt * translationLambda.x + rBxb * translationLambda.y);
		}


		store8(&rbs->invInertia.m22, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaA.m22, invMassA, vA.x, vA.y, vA.z, wA.x, wA.y, wA.z);

		store8(&rbs->invInertia.m22, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaB.m22, invMassB, vB.x, vB.y, vB.z, wB.x, wB.y, wB.z);
	}
}


collision_constraint_solver initializeCollisionVelocityConstraints(memory_arena& arena, const rigid_body_global_state* rbs, const collision_contact* contacts, const constraint_body_pair* bodyPairs, uint32 numContacts, float dt)
{
	CPU_PROFILE_BLOCK("Initialize collision constraints");

	float invDt = 1.f / dt;

	collision_constraint* constraints = arena.allocate<collision_constraint>(numContacts);

	for (uint32 contactID = 0; contactID < numContacts; ++contactID)
	{
		collision_constraint& constraint = constraints[contactID];
		const collision_contact& contact = contacts[contactID];
		constraint_body_pair pair = bodyPairs[contactID];

		auto& rbA = rbs[pair.rbA];
		auto& rbB = rbs[pair.rbB];

		constraint.impulseInNormalDir = 0.f;
		constraint.impulseInTangentDir = 0.f;

		constraint.relGlobalAnchorA = contact.point - rbA.position;
		constraint.relGlobalAnchorB = contact.point - rbB.position;

		vec3 anchorVelocityA = rbA.linearVelocity + cross(rbA.angularVelocity, constraint.relGlobalAnchorA);
		vec3 anchorVelocityB = rbB.linearVelocity + cross(rbB.angularVelocity, constraint.relGlobalAnchorB);

		vec3 relVelocity = anchorVelocityB - anchorVelocityA;
		constraint.tangent = relVelocity - dot(contact.normal, relVelocity) * contact.normal;
		constraint.tangent = noz(constraint.tangent);

		{ // Tangent direction.
			vec3 crAt = cross(constraint.relGlobalAnchorA, constraint.tangent);
			vec3 crBt = cross(constraint.relGlobalAnchorB, constraint.tangent);
			float invMassInTangentDir = rbA.invMass + dot(crAt, rbA.invInertia * crAt)
									  + rbB.invMass + dot(crBt, rbB.invInertia * crBt);
			constraint.effectiveMassInTangentDir = (invMassInTangentDir != 0.f) ? (1.f / invMassInTangentDir) : 0.f;

			constraint.tangentImpulseToAngularVelocityA = rbA.invInertia * crAt;
			constraint.tangentImpulseToAngularVelocityB = rbB.invInertia * crBt;
		}

		{ // Normal direction.
			vec3 crAn = cross(constraint.relGlobalAnchorA, contact.normal);
			vec3 crBn = cross(constraint.relGlobalAnchorB, contact.normal);
			float invMassInNormalDir = rbA.invMass + dot(crAn, rbA.invInertia * crAn)
									 + rbB.invMass + dot(crBn, rbB.invInertia * crBn);
			constraint.effectiveMassInNormalDir = (invMassInNormalDir != 0.f) ? (1.f / invMassInNormalDir) : 0.f;

			constraint.bias = 0.f;

			if (dt > DT_THRESHOLD)
			{
				float vRel = dot(contact.normal, relVelocity);
				const float slop = -0.001f;
				if (-contact.penetrationDepth < slop && vRel < 0.f)
				{
					float restitution = (float)(contact.friction_restitution & 0xFFFF) / (float)0xFFFF;
					constraint.bias = -restitution * vRel - 0.1f * (-contact.penetrationDepth - slop) * invDt;
				}
			}

			constraint.normalImpulseToAngularVelocityA = rbA.invInertia * crAn;
			constraint.normalImpulseToAngularVelocityB = rbB.invInertia * crBn;
		}
	}

	collision_constraint_solver result;
	result.constraints = constraints;
	result.bodyPairs = bodyPairs;
	result.contacts = contacts;
	result.count = numContacts;
	return result;
}

void solveCollisionVelocityConstraints(collision_constraint_solver constraints, rigid_body_global_state* rbs)
{
	CPU_PROFILE_BLOCK("Solve collision constraints");

	for (uint32 i = 0; i < constraints.count; ++i)
	{
		const collision_contact& contact = constraints.contacts[i];
		collision_constraint& constraint = constraints.constraints[i];
		constraint_body_pair pair = constraints.bodyPairs[i];

		auto& rbA = rbs[pair.rbA];
		auto& rbB = rbs[pair.rbB];

		if (rbA.invMass == 0.f && rbB.invMass == 0.f)
		{
			continue;
		}

		vec3 vA = rbA.linearVelocity;
		vec3 wA = rbA.angularVelocity;
		vec3 vB = rbB.linearVelocity;
		vec3 wB = rbB.angularVelocity;

		{ // Tangent dir.
			vec3 anchorVelocityA = vA + cross(wA, constraint.relGlobalAnchorA);
			vec3 anchorVelocityB = vB + cross(wB, constraint.relGlobalAnchorB);

			vec3 relVelocity = anchorVelocityB - anchorVelocityA;
			float vt = dot(relVelocity, constraint.tangent);
			float lambda = -constraint.effectiveMassInTangentDir * vt;

			float friction = (float)(contact.friction_restitution >> 16) / (float)0xFFFF;
			float maxFriction = friction * constraint.impulseInNormalDir;
			ASSERT(maxFriction >= 0.f);
			float newImpulse = clamp(constraint.impulseInTangentDir + lambda, -maxFriction, maxFriction);
			lambda = newImpulse - constraint.impulseInTangentDir;
			constraint.impulseInTangentDir = newImpulse;

			vec3 P = lambda * constraint.tangent;
			vA -= rbA.invMass * P;
			wA -= constraint.tangentImpulseToAngularVelocityA * lambda;
			vB += rbB.invMass * P;
			wB += constraint.tangentImpulseToAngularVelocityB * lambda;
		}

		{ // Normal dir.
			vec3 anchorVelocityA = vA + cross(wA, constraint.relGlobalAnchorA);
			vec3 anchorVelocityB = vB + cross(wB, constraint.relGlobalAnchorB);

			vec3 relVelocity = anchorVelocityB - anchorVelocityA;
			float vn = dot(relVelocity, contact.normal);
			float lambda = -constraint.effectiveMassInNormalDir * (vn - constraint.bias);
			float impulse = max(constraint.impulseInNormalDir + lambda, 0.f);
			lambda = impulse - constraint.impulseInNormalDir;
			constraint.impulseInNormalDir = impulse;

			vec3 P = lambda * contact.normal;
			vA -= rbA.invMass * P;
			wA -= constraint.normalImpulseToAngularVelocityA * lambda;
			vB += rbB.invMass * P;
			wB += constraint.normalImpulseToAngularVelocityB * lambda;
		}

		rbA.linearVelocity = vA;
		rbA.angularVelocity = wA;
		rbB.linearVelocity = vB;
		rbB.angularVelocity = wB;
	}
}

simd_collision_constraint_solver initializeCollisionVelocityConstraintsSIMD(memory_arena& arena, const rigid_body_global_state* rbs, const collision_contact* contacts, const constraint_body_pair* bodyPairs, uint32 numContacts, uint16 dummyRigidBodyIndex, float dt)
{
	CPU_PROFILE_BLOCK("Initialize collision constraints SIMD");

	simd_constraint_slot* contactSlots = arena.allocate<simd_constraint_slot>(numContacts);
	uint32 numBatches = scheduleConstraintsSIMD(arena, bodyPairs, numContacts, dummyRigidBodyIndex, contactSlots);

	simd_collision_constraint_batch* batches = arena.allocate<simd_collision_constraint_batch>(numBatches);

	const w_float zero = w_float::zero();
	const w_float slop = -0.001f;
	const w_float scale = 0.1f;
	const w_float invDt = 1.f / dt;

	for (uint32 i = 0; i < numBatches; ++i)
	{
		const simd_constraint_slot& slot = contactSlots[i];
		simd_collision_constraint_batch& batch = batches[i];

		uint16 contactIndices[CONSTRAINT_SIMD_WIDTH];
		for (uint32 j = 0; j < CONSTRAINT_SIMD_WIDTH; ++j)
		{
			contactIndices[j] = (uint16)slot.indices[j];
			batch.rbAIndices[j] = bodyPairs[slot.indices[j]].rbA;
			batch.rbBIndices[j] = bodyPairs[slot.indices[j]].rbB;
		}

		w_vec3 point, normal;
		w_float penetrationDepth, friction_restitutionF;
		load8((float*)contacts, contactIndices, (uint32)sizeof(collision_contact),
			point.x, point.y, point.z, penetrationDepth, normal.x, normal.y, normal.z, friction_restitutionF);
		w_int friction_restitution = reinterpret(friction_restitutionF);

		w_float friction = convert(friction_restitution >> 16) / w_float(0xFFFF);
		w_float restitution = convert(friction_restitution & 0xFFFF) / w_float(0xFFFF);


		// Load body A.
		w_vec3 vA, wA;
		w_mat3 invInertiaA;
		w_float invMassA;
		w_vec3 positionA;
		w_float unused;

		load8(&rbs->invInertia.m00, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaA.m00, invInertiaA.m10, invInertiaA.m20, 
			invInertiaA.m01, invInertiaA.m11, invInertiaA.m21, 
			invInertiaA.m02, invInertiaA.m12);

		load8(&rbs->invInertia.m22, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaA.m22, invMassA, vA.x, vA.y, vA.z, wA.x, wA.y, wA.z);

		load4(&rbs->position.x, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			positionA.x, positionA.y, positionA.z, unused);


		// Load body B.
		w_vec3 vB, wB;
		w_mat3 invInertiaB;
		w_float invMassB;
		w_vec3 positionB;

		load8(&rbs->invInertia.m00, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaB.m00, invInertiaB.m10, invInertiaB.m20,
			invInertiaB.m01, invInertiaB.m11, invInertiaB.m21,
			invInertiaB.m02, invInertiaB.m12);

		load8(&rbs->invInertia.m22, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			invInertiaB.m22, invMassB, vB.x, vB.y, vB.z, wB.x, wB.y, wB.z);

		load4(&rbs->position.x, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			positionB.x, positionB.y, positionB.z, unused);





		w_vec3 relGlobalAnchorA = point - positionA;
		w_vec3 relGlobalAnchorB = point - positionB;

		w_vec3 anchorVelocityA = vA + cross(wA, relGlobalAnchorA);
		w_vec3 anchorVelocityB = vB + cross(wB, relGlobalAnchorB);

		w_vec3 relVelocity = anchorVelocityB - anchorVelocityA;
		w_vec3 tangent = relVelocity - dot(normal, relVelocity) * normal;
		tangent = noz(tangent);

		relGlobalAnchorA.x.store(batch.relGlobalAnchorA[0]);
		relGlobalAnchorA.y.store(batch.relGlobalAnchorA[1]);
		relGlobalAnchorA.z.store(batch.relGlobalAnchorA[2]);

		relGlobalAnchorB.x.store(batch.relGlobalAnchorB[0]);
		relGlobalAnchorB.y.store(batch.relGlobalAnchorB[1]);
		relGlobalAnchorB.z.store(batch.relGlobalAnchorB[2]);

		normal.x.store(batch.normal[0]);
		normal.y.store(batch.normal[1]);
		normal.z.store(batch.normal[2]);

		tangent.x.store(batch.tangent[0]);
		tangent.y.store(batch.tangent[1]);
		tangent.z.store(batch.tangent[2]);

		zero.store(batch.impulseInNormalDir);
		zero.store(batch.impulseInTangentDir);
		friction.store(batch.friction);



		{ // Tangent direction.
			w_vec3 crAt = cross(relGlobalAnchorA, tangent);
			w_vec3 crBt = cross(relGlobalAnchorB, tangent);
			w_float invMassInTangentDir = invMassA + dot(crAt, invInertiaA * crAt)
				+ invMassB + dot(crBt, invInertiaB * crBt);
			w_float effectiveMassInTangentDir = ifThen(invMassInTangentDir != zero, 1.f / invMassInTangentDir, zero);
			effectiveMassInTangentDir.store(batch.effectiveMassInTangentDir);

			w_vec3 tangentImpulseToAngularVelocityA = invInertiaA * crAt;
			tangentImpulseToAngularVelocityA.x.store(batch.tangentImpulseToAngularVelocityA[0]);
			tangentImpulseToAngularVelocityA.y.store(batch.tangentImpulseToAngularVelocityA[1]);
			tangentImpulseToAngularVelocityA.z.store(batch.tangentImpulseToAngularVelocityA[2]);

			w_vec3 tangentImpulseToAngularVelocityB = invInertiaB * crBt;
			tangentImpulseToAngularVelocityB.x.store(batch.tangentImpulseToAngularVelocityB[0]);
			tangentImpulseToAngularVelocityB.y.store(batch.tangentImpulseToAngularVelocityB[1]);
			tangentImpulseToAngularVelocityB.z.store(batch.tangentImpulseToAngularVelocityB[2]);
		}


		{ // Normal direction.
			w_vec3 crAn = cross(relGlobalAnchorA, normal);
			w_vec3 crBn = cross(relGlobalAnchorB, normal);
			w_float invMassInNormalDir = invMassA + dot(crAn, invInertiaA * crAn)
				+ invMassB + dot(crBn, invInertiaB * crBn);
			w_float effectiveMassInNormalDir = ifThen(invMassInNormalDir != zero, 1.f / invMassInNormalDir, zero);

			w_float bias = zero;

			if (dt > DT_THRESHOLD)
			{
				w_float vRel = dot(normal, relVelocity);

				w_float bounceBias = -restitution * vRel - scale * (-penetrationDepth - slop) * invDt;
				bias = ifThen((-penetrationDepth < slop) & (vRel < zero), bounceBias, bias);
			}

			effectiveMassInNormalDir.store(batch.effectiveMassInNormalDir);
			bias.store(batch.bias);

			w_vec3 normalImpulseToAngularVelocityA = invInertiaA * crAn;
			normalImpulseToAngularVelocityA.x.store(batch.normalImpulseToAngularVelocityA[0]);
			normalImpulseToAngularVelocityA.y.store(batch.normalImpulseToAngularVelocityA[1]);
			normalImpulseToAngularVelocityA.z.store(batch.normalImpulseToAngularVelocityA[2]);

			w_vec3 normalImpulseToAngularVelocityB = invInertiaB * crBn;
			normalImpulseToAngularVelocityB.x.store(batch.normalImpulseToAngularVelocityB[0]);
			normalImpulseToAngularVelocityB.y.store(batch.normalImpulseToAngularVelocityB[1]);
			normalImpulseToAngularVelocityB.z.store(batch.normalImpulseToAngularVelocityB[2]);
		}
	}

	simd_collision_constraint_solver result;
	result.batches = batches;
	result.numBatches = numBatches;
	return result;
}

void solveCollisionVelocityConstraintsSIMD(simd_collision_constraint_solver constraints, rigid_body_global_state* rbs)
{
	CPU_PROFILE_BLOCK("Solve collision constraints SIMD");

	for (uint32 i = 0; i < constraints.numBatches; ++i)
	{
		simd_collision_constraint_batch& batch = constraints.batches[i];

		// Load body A.
		w_vec3 vA, wA;
		w_float invMassA;
		w_float dummyA;

		load8(&rbs->invInertia.m22, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			dummyA, invMassA, vA.x, vA.y, vA.z, wA.x, wA.y, wA.z);


		// Load body B.
		w_vec3 vB, wB;
		w_float invMassB;
		w_float dummyB;

		load8(&rbs->invInertia.m22, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			dummyB, invMassB, vB.x, vB.y, vB.z, wB.x, wB.y, wB.z);


		// Load constraint.
		w_vec3 relGlobalAnchorA(batch.relGlobalAnchorA[0], batch.relGlobalAnchorA[1], batch.relGlobalAnchorA[2]);
		w_vec3 relGlobalAnchorB(batch.relGlobalAnchorB[0], batch.relGlobalAnchorB[1], batch.relGlobalAnchorB[2]);
		w_vec3 normal(batch.normal[0], batch.normal[1], batch.normal[2]);
		w_vec3 tangent(batch.tangent[0], batch.tangent[1], batch.tangent[2]);
		w_float effectiveMassInNormalDir(batch.effectiveMassInNormalDir);
		w_float effectiveMassInTangentDir(batch.effectiveMassInTangentDir);
		w_float friction(batch.friction);
		w_float impulseInNormalDir(batch.impulseInNormalDir);
		w_float impulseInTangentDir(batch.impulseInTangentDir);
		w_float bias(batch.bias);

		w_vec3 tangentImpulseToAngularVelocityA(batch.tangentImpulseToAngularVelocityA[0], batch.tangentImpulseToAngularVelocityA[1], batch.tangentImpulseToAngularVelocityA[2]);
		w_vec3 tangentImpulseToAngularVelocityB(batch.tangentImpulseToAngularVelocityB[0], batch.tangentImpulseToAngularVelocityB[1], batch.tangentImpulseToAngularVelocityB[2]);

		{ // Tangent dir.
			w_vec3 anchorVelocityA = vA + cross(wA, relGlobalAnchorA);
			w_vec3 anchorVelocityB = vB + cross(wB, relGlobalAnchorB);

			w_vec3 relVelocity = anchorVelocityB - anchorVelocityA;
			w_float vt = dot(relVelocity, tangent);
			w_float lambda = -effectiveMassInTangentDir * vt;

			w_float maxFriction = friction * impulseInNormalDir;
			w_float newImpulse = clamp(impulseInTangentDir + lambda, -maxFriction, maxFriction);
			lambda = newImpulse - impulseInTangentDir;
			impulseInTangentDir = newImpulse;

			w_vec3 P = lambda * tangent;
			vA -= invMassA * P;
			wA -= tangentImpulseToAngularVelocityA * lambda;
			vB += invMassB * P;
			wB += tangentImpulseToAngularVelocityB * lambda;
		}

		w_vec3 normalImpulseToAngularVelocityA(batch.normalImpulseToAngularVelocityA[0], batch.normalImpulseToAngularVelocityA[1], batch.normalImpulseToAngularVelocityA[2]);
		w_vec3 normalImpulseToAngularVelocityB(batch.normalImpulseToAngularVelocityB[0], batch.normalImpulseToAngularVelocityB[1], batch.normalImpulseToAngularVelocityB[2]);

		{ // Normal dir.
			w_vec3 anchorVelocityA = vA + cross(wA, relGlobalAnchorA);
			w_vec3 anchorVelocityB = vB + cross(wB, relGlobalAnchorB);

			w_vec3 relVelocity = anchorVelocityB - anchorVelocityA;
			w_float vn = dot(relVelocity, normal);
			w_float lambda = -effectiveMassInNormalDir * (vn - bias);
			w_float impulse = maximum(impulseInNormalDir + lambda, w_float::zero());
			lambda = impulse - impulseInNormalDir;
			impulseInNormalDir = impulse;

			w_vec3 P = lambda * normal;
			vA -= invMassA * P;
			wA -= normalImpulseToAngularVelocityA * lambda;
			vB += invMassB * P;
			wB += normalImpulseToAngularVelocityB * lambda;
		}

		impulseInNormalDir.store(batch.impulseInNormalDir);
		impulseInTangentDir.store(batch.impulseInTangentDir);

		store8(&rbs->invInertia.m22, batch.rbAIndices, (uint32)sizeof(rigid_body_global_state),
			dummyA, invMassA, vA.x, vA.y, vA.z, wA.x, wA.y, wA.z);

		store8(&rbs->invInertia.m22, batch.rbBIndices, (uint32)sizeof(rigid_body_global_state),
			dummyB, invMassB, vB.x, vB.y, vB.z, wB.x, wB.y, wB.z);
	}
}

void constraint_solver::initialize(memory_arena& arena, rigid_body_global_state* rbs,
	distance_constraint* distanceConstraints, constraint_body_pair* distanceConstraintBodyPairs, uint32 numDistanceConstraints,
	ball_constraint* ballConstraints, constraint_body_pair* ballConstraintBodyPairs, uint32 numBallConstraints,
	fixed_constraint* fixedConstraints, constraint_body_pair* fixedConstraintBodyPairs, uint32 numFixedConstraints,
	hinge_constraint* hingeConstraints, constraint_body_pair* hingeConstraintBodyPairs, uint32 numHingeConstraints,
	cone_twist_constraint* coneTwistConstraints, constraint_body_pair* coneTwistConstraintBodyPairs, uint32 numConeTwistConstraints,
	slider_constraint* sliderConstraints, constraint_body_pair* sliderConstraintBodyPairs, uint32 numSliderConstraints,
	collision_contact* contacts, constraint_body_pair* collisionBodyPairs, uint32 numContacts, 
	uint32 dummyRigidBodyIndex, bool simd, float dt)
{
	CPU_PROFILE_BLOCK("Initialize constraints");

	if (simd)
	{
		distanceConstraintSolverSIMD = initializeDistanceVelocityConstraintsSIMD(arena, rbs, distanceConstraints, distanceConstraintBodyPairs, numDistanceConstraints, dt);
		ballConstraintSolverSIMD = initializeBallVelocityConstraintsSIMD(arena, rbs, ballConstraints, ballConstraintBodyPairs, numBallConstraints, dt);
		fixedConstraintSolverSIMD = initializeFixedVelocityConstraintsSIMD(arena, rbs, fixedConstraints, fixedConstraintBodyPairs, numFixedConstraints, dt);
		hingeConstraintSolverSIMD = initializeHingeVelocityConstraintsSIMD(arena, rbs, hingeConstraints, hingeConstraintBodyPairs, numHingeConstraints, dt);
		coneTwistConstraintSolverSIMD = initializeConeTwistVelocityConstraintsSIMD(arena, rbs, coneTwistConstraints, coneTwistConstraintBodyPairs, numConeTwistConstraints, dt);
		sliderConstraintSolverSIMD = initializeSliderVelocityConstraintsSIMD(arena, rbs, sliderConstraints, sliderConstraintBodyPairs, numSliderConstraints, dt);
		collisionConstraintSolverSIMD = initializeCollisionVelocityConstraintsSIMD(arena, rbs, contacts, collisionBodyPairs, numContacts, dummyRigidBodyIndex, dt);
	}
	else
	{
		distanceConstraintSolver = initializeDistanceVelocityConstraints(arena, rbs, distanceConstraints, distanceConstraintBodyPairs, numDistanceConstraints, dt);
		ballConstraintSolver = initializeBallVelocityConstraints(arena, rbs, ballConstraints, ballConstraintBodyPairs, numBallConstraints, dt);
		fixedConstraintSolver = initializeFixedVelocityConstraints(arena, rbs, fixedConstraints, fixedConstraintBodyPairs, numFixedConstraints, dt);
		hingeConstraintSolver = initializeHingeVelocityConstraints(arena, rbs, hingeConstraints, hingeConstraintBodyPairs, numHingeConstraints, dt);
		coneTwistConstraintSolver = initializeConeTwistVelocityConstraints(arena, rbs, coneTwistConstraints, coneTwistConstraintBodyPairs, numConeTwistConstraints, dt);
		sliderConstraintSolver = initializeSliderVelocityConstraints(arena, rbs, sliderConstraints, sliderConstraintBodyPairs, numSliderConstraints, dt);
		collisionConstraintSolver = initializeCollisionVelocityConstraints(arena, rbs, contacts, collisionBodyPairs, numContacts, dt);
	}

	this->rbs = rbs;
	this->simd = simd;
}

void constraint_solver::solveOneIteration()
{
	CPU_PROFILE_BLOCK("Solve constraints one iteration");

	if (simd)
	{
		solveDistanceVelocityConstraintsSIMD(distanceConstraintSolverSIMD, rbs);
		solveBallVelocityConstraintsSIMD(ballConstraintSolverSIMD, rbs);
		solveFixedVelocityConstraintsSIMD(fixedConstraintSolverSIMD, rbs);
		solveHingeVelocityConstraintsSIMD(hingeConstraintSolverSIMD, rbs);
		solveConeTwistVelocityConstraintsSIMD(coneTwistConstraintSolverSIMD, rbs);
		solveSliderVelocityConstraintsSIMD(sliderConstraintSolverSIMD, rbs);
		solveCollisionVelocityConstraintsSIMD(collisionConstraintSolverSIMD, rbs);
	}
	else
	{
		solveDistanceVelocityConstraints(distanceConstraintSolver, rbs);
		solveBallVelocityConstraints(ballConstraintSolver, rbs);
		solveFixedVelocityConstraints(fixedConstraintSolver, rbs);
		solveHingeVelocityConstraints(hingeConstraintSolver, rbs);
		solveConeTwistVelocityConstraints(coneTwistConstraintSolver, rbs);
		solveSliderVelocityConstraints(sliderConstraintSolver, rbs);
		solveCollisionVelocityConstraints(collisionConstraintSolver, rbs);
	}
}

```

`src/physics/constraints.h`:

```h
#pragma once

#include "core/math.h"
#include "core/memory.h"
#include "scene/scene.h"



struct rigid_body_global_state;
struct collision_contact;

#define CONSTRAINT_SIMD_WIDTH 8

enum constraint_type
{
	constraint_type_none = -1,

	constraint_type_distance,
	constraint_type_ball,
	constraint_type_fixed,
	constraint_type_hinge,
	constraint_type_cone_twist,
	constraint_type_slider,

	constraint_type_collision, // This is a bit of a special case, because it is generated in each frame.

	constraint_type_count,
};

#define INVALID_CONSTRAINT_EDGE UINT16_MAX

struct constraint_edge
{
	entity_handle constraintEntity;
	constraint_type type;
	uint16 prevConstraintEdge;
	uint16 nextConstraintEdge;
};


enum constraint_motor_type
{
	constraint_velocity_motor,
	constraint_position_motor,
};

static const char* constraintMotorTypeNames[] =
{
	"Velocity",
	"Position",
};

struct constraint_body_pair
{
	uint16 rbA, rbB;
};


struct constraint_entity_reference_component
{
	entity_handle entityA = entt::null;
	entity_handle entityB = entt::null;
	uint16 edgeA = INVALID_CONSTRAINT_EDGE;
	uint16 edgeB = INVALID_CONSTRAINT_EDGE;
};


#define CONSTRAINT_CAPACITY (2 * 1024)


// Distance constraint.

struct distance_constraint
{
	static constexpr std::size_t page_size = CONSTRAINT_CAPACITY;

	vec3 localAnchorA;
	vec3 localAnchorB;
	float globalLength;
};

struct distance_constraint_update
{
	uint16 rigidBodyIndexA;
	uint16 rigidBodyIndexB;

	vec3 relGlobalAnchorA;
	vec3 relGlobalAnchorB;

	vec3 impulseToAngularVelocityA;
	vec3 impulseToAngularVelocityB;

	vec3 u;
	float bias;
	float effectiveMass;
};

struct distance_constraint_solver
{
	distance_constraint_update* constraints;
	uint32 count;
};

struct simd_distance_constraint_batch
{
	uint16 rbAIndices[CONSTRAINT_SIMD_WIDTH];
	uint16 rbBIndices[CONSTRAINT_SIMD_WIDTH];

	float relGlobalAnchorA[3][CONSTRAINT_SIMD_WIDTH];
	float relGlobalAnchorB[3][CONSTRAINT_SIMD_WIDTH];

	float impulseToAngularVelocityA[3][CONSTRAINT_SIMD_WIDTH];
	float impulseToAngularVelocityB[3][CONSTRAINT_SIMD_WIDTH];

	float u[3][CONSTRAINT_SIMD_WIDTH];
	float bias[CONSTRAINT_SIMD_WIDTH];
	float effectiveMass[CONSTRAINT_SIMD_WIDTH];
};

struct simd_distance_constraint_solver
{
	simd_distance_constraint_batch* batches;
	uint32 numBatches;
};


// Ball constraint.

struct ball_constraint
{
	static constexpr std::size_t page_size = CONSTRAINT_CAPACITY;

	vec3 localAnchorA;
	vec3 localAnchorB;
};

struct ball_constraint_update
{
	uint16 rigidBodyIndexA;
	uint16 rigidBodyIndexB;
	vec3 relGlobalAnchorA;
	vec3 relGlobalAnchorB;

	vec3 bias;
	mat3 invEffectiveMass;
};

struct ball_constraint_solver
{
	ball_constraint_update* constraints;
	uint32 count;
};

struct simd_ball_constraint_batch
{
	uint16 rbAIndices[CONSTRAINT_SIMD_WIDTH];
	uint16 rbBIndices[CONSTRAINT_SIMD_WIDTH];

	float relGlobalAnchorA[3][CONSTRAINT_SIMD_WIDTH];
	float relGlobalAnchorB[3][CONSTRAINT_SIMD_WIDTH];

	float bias[3][CONSTRAINT_SIMD_WIDTH];
	float invEffectiveMass[9][CONSTRAINT_SIMD_WIDTH];
};

struct simd_ball_constraint_solver
{
	simd_ball_constraint_batch* batches;
	uint32 numBatches;
};


// Fixed constraint.

struct fixed_constraint
{
	static constexpr std::size_t page_size = CONSTRAINT_CAPACITY;

	quat initialInvRotationDifference;

	vec3 localAnchorA;
	vec3 localAnchorB;
};

struct fixed_constraint_update
{
	uint16 rigidBodyIndexA;
	uint16 rigidBodyIndexB;
	vec3 relGlobalAnchorA;
	vec3 relGlobalAnchorB;

	vec3 translationBias;
	mat3 invEffectiveTranslationMass;

	vec3 rotationBias;
	mat3 invEffectiveRotationMass;
};

struct fixed_constraint_solver
{
	fixed_constraint_update* constraints;
	uint32 count;
};

struct simd_fixed_constraint_batch
{
	uint16 rbAIndices[CONSTRAINT_SIMD_WIDTH];
	uint16 rbBIndices[CONSTRAINT_SIMD_WIDTH];

	float relGlobalAnchorA[3][CONSTRAINT_SIMD_WIDTH];
	float relGlobalAnchorB[3][CONSTRAINT_SIMD_WIDTH];

	float translationBias[3][CONSTRAINT_SIMD_WIDTH];
	float invEffectiveTranslationMass[9][CONSTRAINT_SIMD_WIDTH];

	float rotationBias[3][CONSTRAINT_SIMD_WIDTH];
	float invEffectiveRotationMass[9][CONSTRAINT_SIMD_WIDTH];
};

struct simd_fixed_constraint_solver
{
	simd_fixed_constraint_batch* batches;
	uint32 numBatches;
};


// Hinge constraint.

struct hinge_constraint
{
	static constexpr std::size_t page_size = CONSTRAINT_CAPACITY;

	vec3 localAnchorA;
	vec3 localAnchorB;
	vec3 localHingeAxisA;
	vec3 localHingeAxisB;

	// Limits. The rotation limits are the allowed deviations in radians from the initial relative rotation.
	// If the limits are not in the specified range, they are disabled.
	float minRotationLimit; // [-pi, 0]
	float maxRotationLimit; // [0, pi]

	// Motor.
	float maxMotorTorque;
	constraint_motor_type motorType;
	union
	{
		float motorVelocity;
		float motorTargetAngle;
	};


	// Used for limits and motor.
	vec3 localHingeTangentA;
	vec3 localHingeBitangentA;
	vec3 localHingeTangentB;
};

struct hinge_constraint_update
{
	uint16 rigidBodyIndexA;
	uint16 rigidBodyIndexB;

	vec3 relGlobalAnchorA;
	vec3 relGlobalAnchorB;

	vec3 translationBias;
	mat3 invEffectiveTranslationMass;

	vec2 rotationBias;
	mat2 invEffectiveRotationMass;
	vec3 bxa;
	vec3 cxa;

	vec3 globalRotationAxis;
	float effectiveAxialMass; // Same for min and max limit and for motor.

	bool solveLimit;
	bool solveMotor;

	// Since at a single time, only one limit constraint can be violated, we only store this stuff once. 
	// 'limitSign' is positive for min- and negative for max-limit-violations.
	float limitImpulse;
	float limitBias;
	float limitSign;

	float motorImpulse;
	float maxMotorImpulse;
	float motorVelocity;

	vec3 motorAndLimitImpulseToAngularVelocityA;
	vec3 motorAndLimitImpulseToAngularVelocityB;
};

struct hinge_constraint_solver
{
	hinge_constraint_update* constraints;
	uint32 count;
};

struct simd_hinge_constraint_batch
{
	uint16 rbAIndices[CONSTRAINT_SIMD_WIDTH];
	uint16 rbBIndices[CONSTRAINT_SIMD_WIDTH];

	float relGlobalAnchorA[3][CONSTRAINT_SIMD_WIDTH];
	float relGlobalAnchorB[3][CONSTRAINT_SIMD_WIDTH];

	float translationBias[3][CONSTRAINT_SIMD_WIDTH];
	float invEffectiveTranslationMass[9][CONSTRAINT_SIMD_WIDTH];


	float rotationBias[2][CONSTRAINT_SIMD_WIDTH];
	float invEffectiveRotationMass[4][CONSTRAINT_SIMD_WIDTH];
	float bxa[3][CONSTRAINT_SIMD_WIDTH];
	float cxa[3][CONSTRAINT_SIMD_WIDTH];

	bool solveLimit;
	bool solveMotor;

	float globalRotationAxis[3][CONSTRAINT_SIMD_WIDTH];
	float effectiveLimitAxialMass[CONSTRAINT_SIMD_WIDTH];
	float effectiveMotorAxialMass[CONSTRAINT_SIMD_WIDTH];

	float limitImpulse[CONSTRAINT_SIMD_WIDTH];
	float limitBias[CONSTRAINT_SIMD_WIDTH];
	float limitSign[CONSTRAINT_SIMD_WIDTH];

	float motorImpulse[CONSTRAINT_SIMD_WIDTH];
	float maxMotorImpulse[CONSTRAINT_SIMD_WIDTH];
	float motorVelocity[CONSTRAINT_SIMD_WIDTH];

	float motorAndLimitImpulseToAngularVelocityA[3][CONSTRAINT_SIMD_WIDTH];
	float motorAndLimitImpulseToAngularVelocityB[3][CONSTRAINT_SIMD_WIDTH];
};

struct simd_hinge_constraint_solver
{
	simd_hinge_constraint_batch* batches;
	uint32 numBatches;
};


// Cone-twist constraint.

struct cone_twist_constraint
{
	static constexpr std::size_t page_size = CONSTRAINT_CAPACITY;

	vec3 localAnchorA;
	vec3 localAnchorB;

	vec3 localLimitAxisA;
	vec3 localLimitAxisB;

	vec3 localLimitTangentA;
	vec3 localLimitBitangentA;
	vec3 localLimitTangentB;

	float swingLimit;
	float twistLimit;

	// Motor.
	constraint_motor_type swingMotorType;
	union
	{
		float swingMotorVelocity;
		float swingMotorTargetAngle;
	};
	float maxSwingMotorTorque;
	float swingMotorAxis;

	constraint_motor_type twistMotorType;
	union
	{
		float twistMotorVelocity;
		float twistMotorTargetAngle;
	};
	float maxTwistMotorTorque;
};

struct cone_twist_constraint_update
{
	uint16 rigidBodyIndexA;
	uint16 rigidBodyIndexB;
	vec3 relGlobalAnchorA;
	vec3 relGlobalAnchorB;

	vec3 bias;
	mat3 invEffectiveMass;

	bool solveSwingLimit;
	bool solveTwistLimit;
	bool solveSwingMotor;
	bool solveTwistMotor;

	// Limits.
	vec3 globalSwingAxis;
	float swingImpulse;
	float effectiveSwingLimitMass;
	float swingLimitBias;
	
	vec3 globalTwistAxis;
	float twistImpulse;
	float twistLimitSign;
	float effectiveTwistMass;
	float twistLimitBias;

	// Motors.
	float swingMotorImpulse;
	float maxSwingMotorImpulse;
	float swingMotorVelocity;
	vec3 globalSwingMotorAxis;
	float effectiveSwingMotorMass;

	float twistMotorImpulse;
	float maxTwistMotorImpulse;
	float twistMotorVelocity;

	vec3 twistMotorAndLimitImpulseToAngularVelocityA;
	vec3 twistMotorAndLimitImpulseToAngularVelocityB;

	vec3 swingMotorImpulseToAngularVelocityA;
	vec3 swingMotorImpulseToAngularVelocityB;
	vec3 swingLimitImpulseToAngularVelocityA;
	vec3 swingLimitImpulseToAngularVelocityB;
};

struct cone_twist_constraint_solver
{
	cone_twist_constraint_update* constraints;
	uint32 count;
};

struct simd_cone_twist_constraint_batch
{
	uint16 rbAIndices[CONSTRAINT_SIMD_WIDTH];
	uint16 rbBIndices[CONSTRAINT_SIMD_WIDTH];

	float relGlobalAnchorA[3][CONSTRAINT_SIMD_WIDTH];
	float relGlobalAnchorB[3][CONSTRAINT_SIMD_WIDTH];

	float bias[3][CONSTRAINT_SIMD_WIDTH];
	float invEffectiveMass[9][CONSTRAINT_SIMD_WIDTH];

	bool solveSwingLimit;
	bool solveTwistLimit;
	bool solveSwingMotor;
	bool solveTwistMotor;

	// Limits.
	float globalSwingAxis[3][CONSTRAINT_SIMD_WIDTH];
	float swingImpulse[CONSTRAINT_SIMD_WIDTH];
	float effectiveSwingLimitMass[CONSTRAINT_SIMD_WIDTH];
	float swingLimitBias[CONSTRAINT_SIMD_WIDTH];

	float swingLimitImpulseToAngularVelocityA[3][CONSTRAINT_SIMD_WIDTH];
	float swingLimitImpulseToAngularVelocityB[3][CONSTRAINT_SIMD_WIDTH];


	float globalTwistAxis[3][CONSTRAINT_SIMD_WIDTH];
	float twistImpulse[CONSTRAINT_SIMD_WIDTH];
	float twistLimitSign[CONSTRAINT_SIMD_WIDTH];
	float effectiveTwistLimitMass[CONSTRAINT_SIMD_WIDTH];
	float twistLimitBias[CONSTRAINT_SIMD_WIDTH];



	// Motors.
	float swingMotorImpulse[CONSTRAINT_SIMD_WIDTH];
	float maxSwingMotorImpulse[CONSTRAINT_SIMD_WIDTH];
	float swingMotorVelocity[CONSTRAINT_SIMD_WIDTH];
	float globalSwingMotorAxis[3][CONSTRAINT_SIMD_WIDTH];
	float effectiveSwingMotorMass[CONSTRAINT_SIMD_WIDTH];

	float swingMotorImpulseToAngularVelocityA[3][CONSTRAINT_SIMD_WIDTH];
	float swingMotorImpulseToAngularVelocityB[3][CONSTRAINT_SIMD_WIDTH];

	float twistMotorImpulse[CONSTRAINT_SIMD_WIDTH];
	float maxTwistMotorImpulse[CONSTRAINT_SIMD_WIDTH];
	float twistMotorVelocity[CONSTRAINT_SIMD_WIDTH];
	float effectiveTwistMotorMass[CONSTRAINT_SIMD_WIDTH];

	float twistMotorAndLimitImpulseToAngularVelocityA[3][CONSTRAINT_SIMD_WIDTH];
	float twistMotorAndLimitImpulseToAngularVelocityB[3][CONSTRAINT_SIMD_WIDTH];
};

struct simd_cone_twist_constraint_solver
{
	simd_cone_twist_constraint_batch* batches;
	uint32 numBatches;
};


// Slider constraint

struct slider_constraint
{
	static constexpr std::size_t page_size = CONSTRAINT_CAPACITY;

	quat initialInvRotationDifference;
	vec3 localAnchorA;
	vec3 localAnchorB;

	vec3 localAxisA;


	// Limit.
	float negDistanceLimit; // Body b cannot go farther to the "left" (negative slider axis) than this value. [-inf, 0] if active, positive if no limit.
	float posDistanceLimit; // Body b cannot go farther to the "right" (positive slider axis) than this value. [0, inf] if active, negative if no limit.

	// Motor.
	float maxMotorForce;
	constraint_motor_type motorType;
	union
	{
		float motorVelocity;
		float motorTargetDistance;
	};
};

struct slider_constraint_update
{
	uint16 rigidBodyIndexA;
	uint16 rigidBodyIndexB;

	vec3 rAuxt;
	vec3 rAuxb;
	vec3 rBxt;
	vec3 rBxb;

	vec3 tangent;
	vec3 bitangent;

	mat2 invEffectiveTranslationMass;
	vec2 translationBias;

	mat3 invEffectiveRotationMass;
	vec3 rotationBias;

	bool solveLimit;
	bool solveMotor;

	vec3 globalSliderAxis;
	float effectiveAxialMass;
	float limitBias;
	float limitImpulse;
	float limitSign;
	vec3 rAuxs;
	vec3 rBxs;

	vec3 limitImpulseToAngularVelocityA;
	vec3 limitImpulseToAngularVelocityB;

	float motorVelocity;
	float motorImpulse;
	float maxMotorImpulse;
};

struct slider_constraint_solver
{
	slider_constraint_update* constraints;
	uint32 count;
};

struct simd_slider_constraint_batch
{
	uint16 rbAIndices[CONSTRAINT_SIMD_WIDTH];
	uint16 rbBIndices[CONSTRAINT_SIMD_WIDTH];

	float rAuxt[3][CONSTRAINT_SIMD_WIDTH];
	float rAuxb[3][CONSTRAINT_SIMD_WIDTH];
	float rBxt[3][CONSTRAINT_SIMD_WIDTH];
	float rBxb[3][CONSTRAINT_SIMD_WIDTH];

	float tangent[3][CONSTRAINT_SIMD_WIDTH];
	float bitangent[3][CONSTRAINT_SIMD_WIDTH];

	float invEffectiveTranslationMass[4][CONSTRAINT_SIMD_WIDTH];
	float translationBias[2][CONSTRAINT_SIMD_WIDTH];

	float invEffectiveRotationMass[9][CONSTRAINT_SIMD_WIDTH];
	float rotationBias[3][CONSTRAINT_SIMD_WIDTH];

	float globalSliderAxis[3][CONSTRAINT_SIMD_WIDTH];

	bool solveLimit;
	bool solveMotor;

	float effectiveAxialMass[CONSTRAINT_SIMD_WIDTH];
	float limitBias[CONSTRAINT_SIMD_WIDTH];
	float limitImpulse[CONSTRAINT_SIMD_WIDTH];
	float limitSign[CONSTRAINT_SIMD_WIDTH];
	float rAuxs[3][CONSTRAINT_SIMD_WIDTH];
	float rBxs[3][CONSTRAINT_SIMD_WIDTH];

	float limitImpulseToAngularVelocityA[3][CONSTRAINT_SIMD_WIDTH];
	float limitImpulseToAngularVelocityB[3][CONSTRAINT_SIMD_WIDTH];

	float motorVelocity[CONSTRAINT_SIMD_WIDTH];
	float motorImpulse[CONSTRAINT_SIMD_WIDTH];
	float maxMotorImpulse[CONSTRAINT_SIMD_WIDTH];
	float effectiveMotorMass[CONSTRAINT_SIMD_WIDTH];
};

struct simd_slider_constraint_solver
{
	simd_slider_constraint_batch* batches;
	uint32 numBatches;
};


// Collision constraint.

struct collision_constraint
{
	vec3 relGlobalAnchorA;
	vec3 relGlobalAnchorB;
	vec3 tangent;

	vec3 tangentImpulseToAngularVelocityA;
	vec3 tangentImpulseToAngularVelocityB;
	vec3 normalImpulseToAngularVelocityA;
	vec3 normalImpulseToAngularVelocityB;

	float impulseInNormalDir;
	float impulseInTangentDir;
	float effectiveMassInNormalDir;
	float effectiveMassInTangentDir;
	float bias;
};

struct collision_constraint_solver
{
	collision_constraint* constraints;
	const collision_contact* contacts;
	const constraint_body_pair* bodyPairs;
	uint32 count;
};

struct simd_collision_constraint_batch
{
	float relGlobalAnchorA[3][CONSTRAINT_SIMD_WIDTH];
	float relGlobalAnchorB[3][CONSTRAINT_SIMD_WIDTH];
	float normal[3][CONSTRAINT_SIMD_WIDTH];
	float tangent[3][CONSTRAINT_SIMD_WIDTH];

	float normalImpulseToAngularVelocityA[3][CONSTRAINT_SIMD_WIDTH];
	float tangentImpulseToAngularVelocityA[3][CONSTRAINT_SIMD_WIDTH];
	float normalImpulseToAngularVelocityB[3][CONSTRAINT_SIMD_WIDTH];
	float tangentImpulseToAngularVelocityB[3][CONSTRAINT_SIMD_WIDTH];

	float effectiveMassInNormalDir[CONSTRAINT_SIMD_WIDTH];
	float effectiveMassInTangentDir[CONSTRAINT_SIMD_WIDTH];
	float friction[CONSTRAINT_SIMD_WIDTH];
	float impulseInNormalDir[CONSTRAINT_SIMD_WIDTH];
	float impulseInTangentDir[CONSTRAINT_SIMD_WIDTH];
	float bias[CONSTRAINT_SIMD_WIDTH];

	uint16 rbAIndices[CONSTRAINT_SIMD_WIDTH];
	uint16 rbBIndices[CONSTRAINT_SIMD_WIDTH];
};

struct simd_collision_constraint_solver
{
	simd_collision_constraint_batch* batches;
	uint32 numBatches;
};




distance_constraint_solver initializeDistanceVelocityConstraints(memory_arena& arena, const rigid_body_global_state* rbs, const distance_constraint* input, const constraint_body_pair* bodyPairs, uint32 count, float dt);
void solveDistanceVelocityConstraints(distance_constraint_solver constraints, rigid_body_global_state* rbs);

ball_constraint_solver initializeBallVelocityConstraints(memory_arena& arena, const rigid_body_global_state* rbs, const ball_constraint* input, const constraint_body_pair* bodyPairs, uint32 count, float dt);
void solveBallVelocityConstraints(ball_constraint_solver constraints, rigid_body_global_state* rbs);

fixed_constraint_solver initializeFixedVelocityConstraints(memory_arena& arena, const rigid_body_global_state* rbs, const fixed_constraint* input, const constraint_body_pair* bodyPairs, uint32 count, float dt);
void solveFixedVelocityConstraints(fixed_constraint_solver constraints, rigid_body_global_state* rbs);

hinge_constraint_solver initializeHingeVelocityConstraints(memory_arena& arena, const rigid_body_global_state* rbs, const hinge_constraint* input, const constraint_body_pair* bodyPairs, uint32 count, float dt);
void solveHingeVelocityConstraints(hinge_constraint_solver constraints, rigid_body_global_state* rbs);

cone_twist_constraint_solver initializeConeTwistVelocityConstraints(memory_arena& arena, const rigid_body_global_state* rbs, const cone_twist_constraint* input, const constraint_body_pair* bodyPairs, uint32 count, float dt);
void solveConeTwistVelocityConstraints(cone_twist_constraint_solver constraints, rigid_body_global_state* rbs);

slider_constraint_solver initializeSliderVelocityConstraints(memory_arena& arena, const rigid_body_global_state* rbs, const slider_constraint* input, const constraint_body_pair* bodyPairs, uint32 count, float dt);
void solveSliderVelocityConstraints(slider_constraint_solver constraints, rigid_body_global_state* rbs);

collision_constraint_solver initializeCollisionVelocityConstraints(memory_arena& arena, const rigid_body_global_state* rbs, const collision_contact* contacts, const constraint_body_pair* bodyPairs, uint32 numContacts, float dt);
void solveCollisionVelocityConstraints(collision_constraint_solver constraints, rigid_body_global_state* rbs);




// SIMD.

simd_distance_constraint_solver initializeDistanceVelocityConstraintsSIMD(memory_arena& arena, const rigid_body_global_state* rbs, const distance_constraint* input, const constraint_body_pair* bodyPairs, uint32 count, float dt);
void solveDistanceVelocityConstraintsSIMD(simd_distance_constraint_solver constraints, rigid_body_global_state* rbs);

simd_ball_constraint_solver initializeBallVelocityConstraintsSIMD(memory_arena& arena, const rigid_body_global_state* rbs, const ball_constraint* input, const constraint_body_pair* bodyPairs, uint32 count, float dt);
void solveBallVelocityConstraintsSIMD(simd_ball_constraint_solver constraints, rigid_body_global_state* rbs);

simd_fixed_constraint_solver initializeFixedVelocityConstraintsSIMD(memory_arena& arena, const rigid_body_global_state* rbs, const fixed_constraint* input, const constraint_body_pair* bodyPairs, uint32 count, float dt);
void solveFixedVelocityConstraintsSIMD(simd_fixed_constraint_solver constraints, rigid_body_global_state* rbs);

simd_hinge_constraint_solver initializeHingeVelocityConstraintsSIMD(memory_arena& arena, const rigid_body_global_state* rbs, const hinge_constraint* input, const constraint_body_pair* bodyPairs, uint32 count, float dt);
void solveHingeVelocityConstraintsSIMD(simd_hinge_constraint_solver constraints, rigid_body_global_state* rbs);

simd_cone_twist_constraint_solver initializeConeTwistVelocityConstraintsSIMD(memory_arena& arena, const rigid_body_global_state* rbs, const cone_twist_constraint* input, const constraint_body_pair* bodyPairs, uint32 count, float dt);
void solveConeTwistVelocityConstraintsSIMD(simd_cone_twist_constraint_solver constraints, rigid_body_global_state* rbs);

simd_slider_constraint_solver initializeSliderVelocityConstraintsSIMD(memory_arena& arena, const rigid_body_global_state* rbs, const slider_constraint* input, const constraint_body_pair* bodyPairs, uint32 count, float dt);
void solveSliderVelocityConstraintsSIMD(simd_slider_constraint_solver constraints, rigid_body_global_state* rbs);

simd_collision_constraint_solver initializeCollisionVelocityConstraintsSIMD(memory_arena& arena, const rigid_body_global_state* rbs, const collision_contact* contacts, const constraint_body_pair* bodyPairs, uint32 numContacts, uint16 dummyRigidBodyIndex, float dt);
void solveCollisionVelocityConstraintsSIMD(simd_collision_constraint_solver constraints, rigid_body_global_state* rbs);



struct constraint_solver
{
	void initialize(memory_arena& arena, rigid_body_global_state* rbs,
		distance_constraint* distanceConstraints, constraint_body_pair* distanceConstraintBodyPairs, uint32 numDistanceConstraints,
		ball_constraint* ballConstraints, constraint_body_pair* ballConstraintBodyPairs, uint32 numBallConstraints,
		fixed_constraint* fixedConstraints, constraint_body_pair* fixedConstraintBodyPairs, uint32 numFixedConstraints,
		hinge_constraint* hingeConstraints, constraint_body_pair* hingeConstraintBodyPairs, uint32 numHingeConstraints,
		cone_twist_constraint* coneTwistConstraints, constraint_body_pair* coneTwistConstraintBodyPairs, uint32 numConeTwistConstraints,
		slider_constraint* sliderConstraints, constraint_body_pair* sliderConstraintBodyPairs, uint32 numSliderConstraints,
		collision_contact* contacts, constraint_body_pair* collisionBodyPairs, uint32 numContacts, 
		uint32 dummyRigidBodyIndex,	bool simd, float dt);

	void solveOneIteration();

private:

	rigid_body_global_state* rbs;
	bool simd;

	distance_constraint_solver distanceConstraintSolver;
	simd_distance_constraint_solver distanceConstraintSolverSIMD;

	ball_constraint_solver ballConstraintSolver;
	simd_ball_constraint_solver ballConstraintSolverSIMD;

	fixed_constraint_solver fixedConstraintSolver;
	simd_fixed_constraint_solver fixedConstraintSolverSIMD;

	hinge_constraint_solver hingeConstraintSolver;
	simd_hinge_constraint_solver hingeConstraintSolverSIMD;

	cone_twist_constraint_solver coneTwistConstraintSolver;
	simd_cone_twist_constraint_solver coneTwistConstraintSolverSIMD;

	slider_constraint_solver sliderConstraintSolver;
	simd_slider_constraint_solver sliderConstraintSolverSIMD;

	collision_constraint_solver collisionConstraintSolver;
	simd_collision_constraint_solver collisionConstraintSolverSIMD;
};







```

`src/physics/heightmap_collision.cpp`:

```cpp
#include "pch.h"
#include "heightmap_collision.h"
#include "core/cpu_profiling.h"
#include "collision_gjk.h"

static void getAABBIncidentEdge(vec3 aabbRadius, vec3 normal, vec3& outA, vec3& outB)
{
	vec3 p = abs(normal);

	outA = vec3(aabbRadius.x, aabbRadius.y, aabbRadius.z);

	if (p.x > p.y)
	{
		if (p.y > p.z)
		{
			outB = vec3(aabbRadius.x, aabbRadius.y, -aabbRadius.z);
		}
		else
		{
			outB = vec3(aabbRadius.x, -aabbRadius.y, aabbRadius.z);
		}
	}
	else
	{
		if (p.x > p.z)
		{
			outB = vec3(aabbRadius.x, aabbRadius.y, -aabbRadius.z);
		}
		else
		{
			outB = vec3(-aabbRadius.x, aabbRadius.y, aabbRadius.z);
		}
	}

	float sx = normal.x < 0.f ? -1.f : 1.f;
	float sy = normal.y < 0.f ? -1.f : 1.f;
	float sz = normal.z < 0.f ? -1.f : 1.f;

	outA *= vec3(sx, sy, sz);
	outB *= vec3(sx, sy, sz);
}

static uint32 collideSphereVsTriangle(vec3 center, float radius, vec3 a, vec3 b, vec3 c, collision_contact* outContacts)
{
	vec3 closestPoint = closestPoint_PointTriangle(center, a, b, c);
	
	vec3 n = closestPoint - center;

	float sqDistance = squaredLength(n);
	if (sqDistance <= radius * radius)
	{
		float distance;
		if (sqDistance == 0.f)
		{
			vec3 triNormal = cross(b - a, c - a);
			n = -triNormal;
			distance = 0.f;
		}
		else
		{
			distance = sqrt(sqDistance);
			n *= 1.f / distance;
		}


		float penetrationDepth = radius - distance;
		ASSERT(penetrationDepth >= 0.f);

		collision_contact& contact = outContacts[0];
		contact.point = closestPoint;
		contact.normal = n;
		contact.penetrationDepth = penetrationDepth;

		return 1;
	}

	return 0;
}

static uint32 collideAABBvsTriangle(vec3 center, vec3 radius, vec3 a, vec3 b, vec3 c, collision_contact* outContacts)
{
	a -= center;
	b -= center;
	c -= center;

	vec3 f0 = b - a;
	vec3 f1 = c - b;
	vec3 f2 = a - c;

	// See aabbVsTriangle for more detailed comments.

	float minPenetration = FLT_MAX;
	vec3 minNormal;

	enum intersection_category
	{
		category0_edge0,
		category0_edge1,
		category0_edge2,

		category1,
		category2,
	};

	intersection_category category = category0_edge0;

	{
		float p0 = (a.z * f0.y) - (a.y * f0.z);
		float p2 = (c.z * f0.y) - (c.y * f0.z);
		float r = radius.y * abs(f0.z) + radius.z * abs(f0.y);

		float penetration = r - max(-max(p0, p2), min(p0, p2));
		if (penetration < 0.f) return 0;

		vec3 normal = vec3(0.f, -f0.z, f0.y);
		float l = length(normal);
		penetration *= 1.f / l;
		if (penetration < minPenetration)
		{
			minPenetration = penetration;
			minNormal = normal * (1.f / l);
			category = category0_edge0;
		}
	}

	{
		float p0 = (a.z * f1.y) - (a.y * f1.z);
		float p1 = (b.z * f1.y) - (b.y * f1.z);
		float r = radius.y * abs(f1.z) + radius.z * abs(f1.y);

		float penetration = r - max(-max(p0, p1), min(p0, p1));
		if (penetration < 0.f) return 0;

		vec3 normal = vec3(0.f, -f1.z, f1.y);
		float l = length(normal);
		penetration *= 1.f / l;
		if (penetration < minPenetration)
		{
			minPenetration = penetration;
			minNormal = normal * (1.f / l);
			category = category0_edge1;
		}
	}

	{
		float p0 = (a.z * f2.y) - (a.y * f2.z);
		float p1 = (b.z * f2.y) - (b.y * f2.z);
		float r = radius.y * abs(f2.z) + radius.z * abs(f2.y);

		float penetration = r - max(-max(p0, p1), min(p0, p1));
		if (penetration < 0.f) return 0;

		vec3 normal = vec3(0.f, -f2.z, f2.y);
		float l = length(normal);
		penetration *= 1.f / l;
		if (penetration < minPenetration)
		{
			minPenetration = penetration;
			minNormal = normal * (1.f / l);
			category = category0_edge2;
		}
	}


	{
		float p0 = (a.x * f0.z) - (a.z * f0.x);
		float p2 = (c.x * f0.z) - (c.z * f0.x);
		float r = radius.x * abs(f0.z) + radius.z * abs(f0.x);

		float penetration = r - max(-max(p0, p2), min(p0, p2));
		if (penetration < 0.f) return 0;

		vec3 normal = vec3(f0.z, 0.f, -f0.x);
		float l = length(normal);
		penetration *= 1.f / l;
		if (penetration < minPenetration)
		{
			minPenetration = penetration;
			minNormal = normal * (1.f / l);
			category = category0_edge0;
		}
	}

	{
		float p0 = (a.x * f1.z) - (a.z * f1.x);
		float p1 = (b.x * f1.z) - (b.z * f1.x);
		float r = radius.x * abs(f1.z) + radius.z * abs(f1.x);

		float penetration = r - max(-max(p0, p1), min(p0, p1));
		if (penetration < 0.f) return 0;

		vec3 normal = vec3(f1.z, 0.f, -f1.x);
		float l = length(normal);
		penetration *= 1.f / l;
		if (penetration < minPenetration)
		{
			minPenetration = penetration;
			minNormal = normal * (1.f / l);
			category = category0_edge1;
		}
	}

	{
		float p0 = (a.x * f2.z) - (a.z * f2.x);
		float p1 = (b.x * f2.z) - (b.z * f2.x);
		float r = radius.x * abs(f2.z) + radius.z * abs(f2.x);

		float penetration = r - max(-max(p0, p1), min(p0, p1));
		if (penetration < 0.f) return 0;

		vec3 normal = vec3(f2.z, 0.f, -f2.x);
		float l = length(normal);
		penetration *= 1.f / l;
		if (penetration < minPenetration)
		{
			minPenetration = penetration;
			minNormal = normal * (1.f / l);
			category = category0_edge2;
		}
	}


	{
		float p0 = (a.y * f0.x) - (a.x * f0.y);
		float p2 = (c.y * f0.x) - (c.x * f0.y);
		float r = radius.x * abs(f0.y) + radius.y * abs(f0.x);

		float penetration = r - max(-max(p0, p2), min(p0, p2));
		if (penetration < 0.f) return 0;

		vec3 normal = vec3(-f0.y, f0.x, 0.f);
		float l = length(normal);
		penetration *= 1.f / l;
		if (penetration < minPenetration)
		{
			minPenetration = penetration;
			minNormal = normal * (1.f / l);
			category = category0_edge0;
		}
	}

	{
		float p0 = (a.y * f1.x) - (a.x * f1.y);
		float p1 = (b.y * f1.x) - (b.x * f1.y);
		float r = radius.x * abs(f1.y) + radius.y * abs(f1.x);

		float penetration = r - max(-max(p0, p1), min(p0, p1));
		if (penetration < 0.f) return 0;

		vec3 normal = vec3(-f1.y, f1.x, 0.f);
		float l = length(normal);
		penetration *= 1.f / l;
		if (penetration < minPenetration)
		{
			minPenetration = penetration;
			minNormal = normal * (1.f / l);
			category = category0_edge1;
		}
	}

	{
		float p0 = (a.y * f2.x) - (a.x * f2.y);
		float p1 = (b.y * f2.x) - (b.x * f2.y);
		float r = radius.x * abs(f2.y) + radius.y * abs(f2.x);

		float penetration = r - max(-max(p0, p1), min(p0, p1));
		if (penetration < 0.f) return 0;

		vec3 normal = vec3(-f2.y, f2.x, 0.f);
		float l = length(normal);
		penetration *= 1.f / l;
		if (penetration < minPenetration)
		{
			minPenetration = penetration;
			minNormal = normal * (1.f / l);
			category = category0_edge2;
		}
	}


	{
		float penetration = max(a.x, max(b.x, c.x)) + radius.x;
		if (penetration < 0.f) return 0;

		if (penetration < minPenetration)
		{
			minPenetration = penetration;
			minNormal = vec3(-1.f, 0.f, 0.f);
			category = category1;
		}
	}
	{
		float penetration = radius.x - min(a.x, min(b.x, c.x));
		if (penetration < 0.f) return 0;

		if (penetration < minPenetration)
		{
			minPenetration = penetration;
			minNormal = vec3(1.f, 0.f, 0.f);
			category = category1;
		}
	}
	{
		float penetration = max(a.y, max(b.y, c.y)) + radius.y;
		if (penetration < 0.f) return 0;

		if (penetration < minPenetration)
		{
			minPenetration = penetration;
			minNormal = vec3(0.f, -1.f, 0.f);
			category = category1;
		}
	}
	{
		float penetration = radius.y - min(a.y, min(b.y, c.y));
		if (penetration < 0.f) return 0;

		if (penetration < minPenetration)
		{
			minPenetration = penetration;
			minNormal = vec3(0.f, 1.f, 0.f);
			category = category1;
		}
	}
	{
		float penetration = max(a.z, max(b.z, c.z)) + radius.z;
		if (penetration < 0.f) return 0;

		if (penetration < minPenetration)
		{
			minPenetration = penetration;
			minNormal = vec3(0.f, 0.f, -1.f);
			category = category1;
		}
	}
	{
		float penetration = radius.z - min(a.z, min(b.z, c.z));
		if (penetration < 0.f) return 0;

		if (penetration < minPenetration)
		{
			minPenetration = penetration;
			minNormal = vec3(0.f, 0.f, 1.f);
			category = category1;
		}
	}

	{
		vec3 triNormal = normalize(cross(f0, f1));
		float triD = dot(triNormal, a);

		float r = dot(radius, abs(triNormal));
		float s = abs(triD);

		float penetration = r - s;
		if (penetration < 0.f) return 0;

		if (penetration < minPenetration)
		{
			minPenetration = penetration;
			minNormal = triNormal;
			category = category2;
		}
	}


	vec3 triCenter = (a + b + c) * (1.f / 3.f);
	if (dot(minNormal, triCenter) < 0.f)
	{
		minNormal = -minNormal;
	}


	vec3 point;

	if (category < 3)
	{
		vec3 a0, a1;
		getAABBIncidentEdge(radius, minNormal, a0, a1);

		vec3 triA = (category == category0_edge0) ? a : (category == category0_edge1) ? b : c;
		vec3 triB = (category == category0_edge0) ? b : (category == category0_edge1) ? c : a;

		vec3 pa, pb;
		float sqDistance = closestPoint_SegmentSegment(line_segment{ a0, a1 }, line_segment{ triA, triB }, pa, pb);

		point = (pa + pb) * 0.5f;
	}
	else if (category == category1)
	{
		float da = dot(minNormal, a);
		float db = dot(minNormal, b);
		float dc = dot(minNormal, c);

		vec3 p = (da < db) ? (da < dc) ? a : c : (db < dc) ? b : c;
		point = p + minNormal * (minPenetration * 0.5f);
	}
	else
	{
		vec3 p = vec3(
			(minNormal.x < 0.f) ? -radius.x : radius.x,
			(minNormal.y < 0.f) ? -radius.y : radius.y,
			(minNormal.z < 0.f) ? -radius.z : radius.z
		);

		point = p - minNormal * (minPenetration * 0.5f);
	}

	ASSERT(minPenetration >= 0.f);

	point += center;


	collision_contact& contact = outContacts[0];
	contact.point = point;
	contact.normal = minNormal;
	contact.penetrationDepth = minPenetration;

	return 1;
}

static uint32 intersection(const bounding_sphere& s, const bounding_box& aabb, const heightmap_collider_component& heightmap, memory_arena& arena,
	collision_contact* outContacts)
{
	uint32 numContacts = 0;

	heightmap.iterateTrianglesInVolume(aabb, arena, [s, outContacts, &numContacts](vec3 a, vec3 b, vec3 c)
	{
		numContacts += collideSphereVsTriangle(s.center, s.radius, a, b, c, outContacts + numContacts);
	});

	// TODO: De-duplicate contacts (for if we hit triangle edges or vertices).

	return numContacts;
}

static uint32 intersection(const bounding_capsule& capsule, const bounding_box& aabb, const heightmap_collider_component& heightmap, memory_arena& arena,
	collision_contact* outContacts)
{
	uint32 numContacts = 0;

	ray r = { capsule.positionA, normalize(capsule.positionB - capsule.positionA) };

	heightmap.iterateTrianglesInVolume(aabb, arena, [r, capsule, outContacts, &numContacts](vec3 a, vec3 b, vec3 c)
	{
		vec3 triNormal = normalize(cross(b - a, c - a));
		float d = -dot(triNormal, a);

		float ndotd = dot(r.direction, triNormal);

		float t = -(dot(r.origin, triNormal) + d) / ndotd;

		vec3 trace = r.origin + t * r.direction;
		vec3 closest = closestPoint_PointTriangle(trace, a, b, c);

		vec3 reference = closestPoint_PointSegment(closest, { capsule.positionA, capsule.positionB });

		numContacts += collideSphereVsTriangle(reference, capsule.radius, a, b, c, outContacts + numContacts);
	});

	// TODO: De-duplicate contacts (for if we hit triangle edges or vertices).

	return numContacts;
}

static uint32 intersection(const bounding_box& box, const bounding_box& aabb, const heightmap_collider_component& heightmap, memory_arena& arena,
	collision_contact* outContacts)
{
	uint32 numContacts = 0;

	vec3 center = box.getCenter();
	vec3 radius = box.getRadius();

	heightmap.iterateTrianglesInVolume(aabb, arena, [center, radius, outContacts, &numContacts](vec3 a, vec3 b, vec3 c)
	{
		numContacts += collideAABBvsTriangle(center, radius, a, b, c, outContacts + numContacts);
	});

	// TODO: De-duplicate contacts (for if we hit triangle edges or vertices).

	return numContacts;
}

static uint32 intersection(const bounding_oriented_box& obb, const bounding_box& aabb, const heightmap_collider_component& heightmap, memory_arena& arena,
	collision_contact* outContacts)
{
	uint32 numContacts = 0;

	heightmap.iterateTrianglesInVolume(aabb, arena, [obb, outContacts, &numContacts](vec3 a, vec3 b, vec3 c)
	{
		a = conjugate(obb.rotation) * (a - obb.center);
		b = conjugate(obb.rotation) * (b - obb.center);
		c = conjugate(obb.rotation) * (c - obb.center);

		numContacts += collideAABBvsTriangle(vec3(0.f, 0.f, 0.f), obb.radius, a, b, c, outContacts + numContacts);
	});

	// TODO: De-duplicate contacts (for if we hit triangle edges or vertices).

	for (uint32 i = 0; i < numContacts; ++i)
	{
		outContacts[i].normal = obb.rotation * outContacts[i].normal;
		outContacts[i].point = obb.rotation * outContacts[i].point + obb.center;
	}

	return numContacts;
}

narrowphase_result heightmapCollision(const heightmap_collider_component& heightmap, 
	const collider_union* worldSpaceColliders, const bounding_box* worldSpaceAABBs, uint32 numColliders, 
	collision_contact* outContacts, constraint_body_pair* outBodyPairs, collider_pair* outColliderPairs, uint8* outContactCountPerCollision, 
	memory_arena& arena, uint16 dummyRigidBodyIndex)
{
	CPU_PROFILE_BLOCK("Heightmap collisions");

	uint32 totalNumContacts = 0;
	uint32 totalNumCollisions = 0;

	for (uint32 i = 0; i < numColliders; ++i)
	{
		const collider_union& collider = worldSpaceColliders[i];

		if (collider.objectType != physics_object_type_rigid_body)
		{
			continue;
		}


		bounding_box aabb = worldSpaceAABBs[i];
		aabb.maxCorner.y += 10.f;

		uint32 numContacts = 0;

		collision_contact* contactPtr = outContacts + totalNumContacts;


		vec3 lowestPoint;

		switch (collider.type)
		{
			case collider_type_sphere:
			{
				numContacts = intersection(collider.sphere, aabb, heightmap, arena, contactPtr);
				lowestPoint = sphere_support_fn{ collider.sphere }(vec3(0.f, -1.f, 0.f));
			} break;
			case collider_type_capsule:
			{
				numContacts = intersection(collider.capsule, aabb, heightmap, arena, contactPtr);
				lowestPoint = capsule_support_fn{ collider.capsule }(vec3(0.f, -1.f, 0.f));
			} break;
			case collider_type_aabb:
			{
				numContacts = intersection(collider.aabb, aabb, heightmap, arena, contactPtr);
				lowestPoint = aabb_support_fn{ collider.aabb }(vec3(0.f, -1.f, 0.f));
			} break;
			case collider_type_obb:
			{
				numContacts = intersection(collider.obb, aabb, heightmap, arena, contactPtr);
				lowestPoint = obb_support_fn{ collider.obb }(vec3(0.f, -1.f, 0.f));
			} break;
		}

		float heightAtLowestPoint = heightmap.getHeightAt(vec2(lowestPoint.x, lowestPoint.z));
		if (lowestPoint.y < heightAtLowestPoint)
		{
			collision_contact& contact = contactPtr[numContacts++];
			contact.normal = vec3(0.f, -1.f, 0.f);
			contact.point = lowestPoint;
			contact.penetrationDepth = heightAtLowestPoint - lowestPoint.y;
		}


		if (numContacts > 0)
		{
			constraint_body_pair* bodyPairPtr = outBodyPairs + totalNumContacts;

			float friction = clamp01(sqrt(collider.material.friction * heightmap.material.friction));
			float restitution = clamp01(max(collider.material.restitution, heightmap.material.restitution));

			uint32 friction_restitution = ((uint32)(friction * 0xFFFF) << 16) | (uint32)(restitution * 0xFFFF);

			for (uint32 j = 0; j < numContacts; ++j)
			{
				contactPtr[j].friction_restitution = friction_restitution;
				bodyPairPtr[j] = { collider.objectIndex, dummyRigidBodyIndex };
			}

			ASSERT(numContacts < 256);
			outContactCountPerCollision[totalNumCollisions] = (uint8)numContacts;
			outColliderPairs[totalNumCollisions++] = { (uint16)i, UINT16_MAX };
		}

#if 0
		for (uint32 j = 0; j < numContacts; ++j)
		{
			float px = contactPtr[j].point.x;
			float py = contactPtr[j].point.y;
			float pz = contactPtr[j].point.z;
			float nx = contactPtr[j].normal.x;
			float ny = contactPtr[j].normal.y;
			float nz = contactPtr[j].normal.z;
			float pen = contactPtr[j].penetrationDepth;

			if (isnan(px)) { __debugbreak(); }
			if (isnan(py)) { __debugbreak(); }
			if (isnan(pz)) { __debugbreak(); }
			if (isnan(nx)) { __debugbreak(); }
			if (isnan(ny)) { __debugbreak(); }
			if (isnan(nz)) { __debugbreak(); }
			if (isnan(pen)) { __debugbreak(); }
		}
#endif

		totalNumContacts += numContacts;
	}

	return narrowphase_result{ totalNumCollisions, totalNumContacts, 0 };
}

```

`src/physics/heightmap_collision.h`:

```h
#pragma once

#include "collision_narrow.h"
#include "collision_broad.h"
#include "terrain/heightmap_collider.h"


narrowphase_result heightmapCollision(const heightmap_collider_component& heightmap, 
	const collider_union* worldSpaceColliders, const bounding_box* worldSpaceAABBs, uint32 numColliders,
	collision_contact* outContacts, constraint_body_pair* outBodyPairs, // result.numContacts many.
	collider_pair* outColliderPairs, uint8* outContactCountPerCollision, // result.numCollisions many.
	memory_arena& arena, uint16 dummyRigidBodyIndex);


```

`src/physics/island.cpp`:

```cpp
#include "pch.h"
#include "island.h"
#include "core/cpu_profiling.h"

void buildIslands(memory_arena& arena, constraint_body_pair* bodyPairs, uint32 numBodyPairs, uint32 numRigidBodies, uint16 dummyRigidBodyIndex, const constraint_offsets& offsets)
{
	CPU_PROFILE_BLOCK("Build islands");

	uint32 islandCapacity = numBodyPairs;
	uint16* allIslands = arena.allocate<uint16>(islandCapacity);

	memory_marker marker = arena.getMarker();

	uint32 count = numRigidBodies + 1; // 1 for the dummy.

	uint16* numConstraintsPerBody = arena.allocate<uint16>(count, true);

	for (uint32 i = 0; i < numBodyPairs; ++i)
	{
		constraint_body_pair pair = bodyPairs[i];
		++numConstraintsPerBody[pair.rbA];
		++numConstraintsPerBody[pair.rbB];
	}

	uint16* offsetToFirstConstraintPerBody = arena.allocate<uint16>(count);

	uint16 currentOffset = 0;
	for (uint32 i = 0; i < count; ++i)
	{
		offsetToFirstConstraintPerBody[i] = currentOffset;
		currentOffset += numConstraintsPerBody[i];
	}

	struct body_pair_reference
	{
		uint16 otherBody;
		uint16 pairIndex;
	};

	body_pair_reference* pairReferences = arena.allocate<body_pair_reference>(numBodyPairs * 2);
	uint16* counter = arena.allocate<uint16>(count);
	memcpy(counter, offsetToFirstConstraintPerBody, sizeof(uint16) * count);

	for (uint32 i = 0; i < numBodyPairs; ++i)
	{
		constraint_body_pair pair = bodyPairs[i];
		pairReferences[counter[pair.rbA]++] = { pair.rbB, (uint16)i };
		pairReferences[counter[pair.rbB]++] = { pair.rbA, (uint16)i };
	}


	uint16* rbStack = arena.allocate<uint16>(count);
	uint32 stackPtr;

	bool* alreadyVisited = arena.allocate<bool>(count, true);
	bool* alreadyOnStack = arena.allocate<bool>(count, true);

	uint32 islandPtr = 0;

	for (uint16 rbIndexOuter = 0; rbIndexOuter < (uint16)numRigidBodies; ++rbIndexOuter)
	{
		if (alreadyVisited[rbIndexOuter] || rbIndexOuter == dummyRigidBodyIndex)
		{
			continue;
		}

		// Reset island.
		uint32 islandStart = islandPtr;

		rbStack[0] = rbIndexOuter;
		alreadyOnStack[rbIndexOuter] = true;

		stackPtr = 1;


		while (stackPtr != 0)
		{
			uint16 rbIndex = rbStack[--stackPtr];

			ASSERT(rbIndex != dummyRigidBodyIndex);
			ASSERT(!alreadyVisited[rbIndex]);
			alreadyVisited[rbIndex] = true;


			// Push connected bodies.
			uint32 startIndex = offsetToFirstConstraintPerBody[rbIndex];
			uint32 count = numConstraintsPerBody[rbIndex];
			for (uint32 i = startIndex; i < startIndex + count; ++i)
			{
				body_pair_reference ref = pairReferences[i];
				uint16 other = ref.otherBody;
				if (!alreadyOnStack[other] && other != dummyRigidBodyIndex) // Don't push dummy to stack. We don't want to grow islands over the dummy.
				{
					alreadyOnStack[other] = true;
					rbStack[stackPtr++] = other;
				}

				if (!alreadyVisited[other])
				{
					// Add constraint to island.
					ASSERT(islandPtr < islandCapacity);
					allIslands[islandPtr++] = ref.pairIndex;
				}

			}
		}

		// Process island.
		uint32 islandSize = islandPtr - islandStart;
		if (islandSize > 0)
		{
			uint16* islandPairs = allIslands + islandStart;
			std::sort(islandPairs, islandPairs + islandSize);


		}
	}


#if 0
	ASSERT(islandPtr == islandCapacity);
	for (uint32 i = 0; i < numRigidBodies; ++i)
	{
		ASSERT(alreadyVisited[i]);
	}
#endif

	arena.resetToMarker(marker);
}

```

`src/physics/island.h`:

```h
#pragma once

#include "constraints.h"

struct constraint_offsets
{
	// Must be in order.
	uint32 constraintOffsets[constraint_type_count];
};

void buildIslands(memory_arena& arena, constraint_body_pair* bodyPairs, uint32 numBodyPairs, uint32 numRigidBodies, uint16 dummyRigidBodyIndex, const constraint_offsets& offsets);

```

`src/physics/physics.cpp`:

```cpp
#include "pch.h"
#include "physics.h"
#include "collision_broad.h"
#include "collision_narrow.h"
#include "heightmap_collision.h"
#include "core/cpu_profiling.h"

#ifndef PHYSICS_ONLY
#include "core/log.h"
#endif

#include <unordered_set>

static std::vector<bounding_hull_geometry> boundingHullGeometries;

struct constraint_context
{
	std::vector<constraint_edge> constraintEdges;
	uint16 firstFreeConstraintEdge = INVALID_CONSTRAINT_EDGE; // Free-list in constraintEdges array.


	constraint_edge& getFreeConstraintEdge()
	{
		if (firstFreeConstraintEdge == INVALID_CONSTRAINT_EDGE)
		{
			firstFreeConstraintEdge = (uint16)constraintEdges.size();
			constraintEdges.push_back(constraint_edge{ entt::null, constraint_type_none, INVALID_CONSTRAINT_EDGE, INVALID_CONSTRAINT_EDGE });
		}

		constraint_edge& edge = constraintEdges[firstFreeConstraintEdge];

		firstFreeConstraintEdge = edge.nextConstraintEdge;

		// Edge will be initialized by caller.

		return edge;
	}

	void freeConstraintEdge(constraint_edge& edge)
	{
		uint16 index = (uint16)(&edge - constraintEdges.data());
		edge.nextConstraintEdge = firstFreeConstraintEdge;
		firstFreeConstraintEdge = index;
	}
};

struct force_field_global_state
{
	vec3 force;
};

#ifndef PHYSICS_ONLY
// This is a bit dirty. PHYSICS_ONLY is defined when building the learning DLL, where we don't need bounding hulls.

#include "geometry/mesh_builder.h"
#include "asset/model_asset.h"

uint32 allocateBoundingHullGeometry(const std::string& meshFilepath)
{
	model_asset asset = load3DModelFromFile(meshFilepath);

	if (asset.meshes.empty())
	{
		return INVALID_BOUNDING_HULL_INDEX;
	}

	mesh_builder builder(mesh_creation_flags_with_positions);

	for (auto& mesh : asset.meshes)
	{
		for (auto& sub : mesh.submeshes)
		{
			builder.pushMesh(sub, 1.f);
		}
	}

	uint32 index = (uint32)boundingHullGeometries.size();
	boundingHullGeometries.push_back(bounding_hull_geometry::fromMesh(
		builder.getPositions(),
		builder.getNumVertices(),
		(indexed_triangle16*)builder.getTriangles(),
		builder.getNumTriangles()));
	return index;
}
#endif

static void addConstraintEdge(scene_entity& e, constraint_entity_reference_component& constraintEntityReference, entity_handle constraintEntity, constraint_type type)
{
	if (!e.hasComponent<physics_reference_component>())
	{
		e.addComponent<physics_reference_component>();
	}

	physics_reference_component& reference = e.getComponent<physics_reference_component>();

	constraint_context& context = createOrGetContextVariable<constraint_context>(*e.registry);

	constraint_edge& edge = context.getFreeConstraintEdge();
	uint16 edgeIndex = (uint16)(&edge - context.constraintEdges.data());

	edge.constraintEntity = constraintEntity;
	edge.type = type;
	edge.prevConstraintEdge = INVALID_CONSTRAINT_EDGE;
	edge.nextConstraintEdge = reference.firstConstraintEdge;

	if (reference.firstConstraintEdge != INVALID_CONSTRAINT_EDGE)
	{
		context.constraintEdges[reference.firstConstraintEdge].prevConstraintEdge = edgeIndex;
	}

	reference.firstConstraintEdge = edgeIndex;

	if (constraintEntityReference.edgeA == INVALID_CONSTRAINT_EDGE)
	{
		constraintEntityReference.edgeA = edgeIndex;
		constraintEntityReference.entityA = e.handle;
	}
	else
	{
		ASSERT(constraintEntityReference.edgeB == INVALID_CONSTRAINT_EDGE);
		constraintEntityReference.edgeB = edgeIndex;
		constraintEntityReference.entityB = e.handle;
	}

	++reference.numConstraints;
}

distance_constraint_handle addDistanceConstraintFromLocalPoints(scene_entity& a, scene_entity& b, vec3 localAnchorA, vec3 localAnchorB, float distance)
{
	ASSERT(a.registry == b.registry);

	entt::registry& registry = *a.registry;
	entity_handle constraintEntity = registry.create();
	distance_constraint& constraint = registry.emplace<distance_constraint>(constraintEntity);
	constraint_entity_reference_component& ref = registry.emplace<constraint_entity_reference_component>(constraintEntity);

	constraint.localAnchorA = localAnchorA;
	constraint.localAnchorB = localAnchorB;
	constraint.globalLength = distance;

	addConstraintEdge(a, ref, constraintEntity, constraint_type_distance);
	addConstraintEdge(b, ref, constraintEntity, constraint_type_distance);

	return { constraintEntity };
}

distance_constraint_handle addDistanceConstraintFromGlobalPoints(scene_entity& a, scene_entity& b, vec3 globalAnchorA, vec3 globalAnchorB)
{
	ASSERT(a.registry == b.registry);

	vec3 localAnchorA = inverseTransformPosition(a.getComponent<transform_component>(), globalAnchorA);
	vec3 localAnchorB = inverseTransformPosition(b.getComponent<transform_component>(), globalAnchorB);
	float distance = length(globalAnchorA - globalAnchorB);

	return addDistanceConstraintFromLocalPoints(a, b, localAnchorA, localAnchorB, distance);
}

ball_constraint_handle addBallConstraintFromLocalPoints(scene_entity& a, scene_entity& b, vec3 localAnchorA, vec3 localAnchorB)
{
	ASSERT(a.registry == b.registry);

	entt::registry& registry = *a.registry;
	entity_handle constraintEntity = registry.create();
	ball_constraint& constraint = registry.emplace<ball_constraint>(constraintEntity);
	constraint_entity_reference_component& ref = registry.emplace<constraint_entity_reference_component>(constraintEntity);

	constraint.localAnchorA = localAnchorA;
	constraint.localAnchorB = localAnchorB;

	addConstraintEdge(a, ref, constraintEntity, constraint_type_ball);
	addConstraintEdge(b, ref, constraintEntity, constraint_type_ball);

	return { constraintEntity };
}

ball_constraint_handle addBallConstraintFromGlobalPoints(scene_entity& a, scene_entity& b, vec3 globalAnchor)
{
	ASSERT(a.registry == b.registry);

	vec3 localAnchorA = inverseTransformPosition(a.getComponent<transform_component>(), globalAnchor);
	vec3 localAnchorB = inverseTransformPosition(b.getComponent<transform_component>(), globalAnchor);

	return addBallConstraintFromLocalPoints(a, b, localAnchorA, localAnchorB);
}

fixed_constraint_handle addFixedConstraintFromLocalPoints(scene_entity& a, scene_entity& b, vec3 localAnchorA, vec3 localAnchorB)
{
	ASSERT(a.registry == b.registry);

	entt::registry& registry = *a.registry;
	entity_handle constraintEntity = registry.create();
	fixed_constraint& constraint = registry.emplace<fixed_constraint>(constraintEntity);
	constraint_entity_reference_component& ref = registry.emplace<constraint_entity_reference_component>(constraintEntity);

	constraint.localAnchorA = localAnchorA;
	constraint.localAnchorB = localAnchorB;

	addConstraintEdge(a, ref, constraintEntity, constraint_type_fixed);
	addConstraintEdge(b, ref, constraintEntity, constraint_type_fixed);

	return { constraintEntity };
}

fixed_constraint_handle addFixedConstraintFromGlobalPoints(scene_entity& a, scene_entity& b, vec3 globalAnchor)
{
	ASSERT(a.registry == b.registry);

	entt::registry& registry = *a.registry;
	entity_handle constraintEntity = registry.create();
	fixed_constraint& constraint = registry.emplace<fixed_constraint>(constraintEntity);
	constraint_entity_reference_component& ref = registry.emplace<constraint_entity_reference_component>(constraintEntity);

	const transform_component& transformA = a.getComponent<transform_component>();
	const transform_component& transformB = b.getComponent<transform_component>();

	constraint.localAnchorA = inverseTransformPosition(transformA, globalAnchor);
	constraint.localAnchorB = inverseTransformPosition(transformB, globalAnchor);

	constraint.initialInvRotationDifference = conjugate(transformB.rotation) * transformA.rotation;

	addConstraintEdge(a, ref, constraintEntity, constraint_type_fixed);
	addConstraintEdge(b, ref, constraintEntity, constraint_type_fixed);

	return { constraintEntity };
}

hinge_constraint_handle addHingeConstraintFromGlobalPoints(scene_entity& a, scene_entity& b, vec3 globalAnchor, vec3 globalHingeAxis,
	float minLimit, float maxLimit)
{
	ASSERT(a.registry == b.registry);

	entt::registry& registry = *a.registry;
	entity_handle constraintEntity = registry.create();
	hinge_constraint& constraint = registry.emplace<hinge_constraint>(constraintEntity);
	constraint_entity_reference_component& ref = registry.emplace<constraint_entity_reference_component>(constraintEntity);

	const transform_component& transformA = a.getComponent<transform_component>();
	const transform_component& transformB = b.getComponent<transform_component>();

	constraint.localAnchorA = inverseTransformPosition(transformA, globalAnchor);
	constraint.localAnchorB = inverseTransformPosition(transformB, globalAnchor);
	constraint.localHingeAxisA = inverseTransformDirection(transformA, globalHingeAxis);
	constraint.localHingeAxisB = inverseTransformDirection(transformB, globalHingeAxis);

	getTangents(constraint.localHingeAxisA, constraint.localHingeTangentA, constraint.localHingeBitangentA);
	constraint.localHingeTangentB = conjugate(transformB.rotation) * (transformA.rotation * constraint.localHingeTangentA);

	// Limits.
	constraint.minRotationLimit = minLimit;
	constraint.maxRotationLimit = maxLimit;

	// Motor.
	constraint.motorType = constraint_velocity_motor;
	constraint.motorVelocity = 0.f;
	constraint.maxMotorTorque = -1.f; // Disabled by default.

	addConstraintEdge(a, ref, constraintEntity, constraint_type_hinge);
	addConstraintEdge(b, ref, constraintEntity, constraint_type_hinge);

	return { constraintEntity };
}

cone_twist_constraint_handle addConeTwistConstraintFromGlobalPoints(scene_entity& a, scene_entity& b, vec3 globalAnchor, vec3 globalAxis, 
	float swingLimit, float twistLimit)
{
	ASSERT(a.registry == b.registry);

	entt::registry& registry = *a.registry;
	entity_handle constraintEntity = registry.create();
	cone_twist_constraint& constraint = registry.emplace<cone_twist_constraint>(constraintEntity);
	constraint_entity_reference_component& ref = registry.emplace<constraint_entity_reference_component>(constraintEntity);

	const transform_component& transformA = a.getComponent<transform_component>();
	const transform_component& transformB = b.getComponent<transform_component>();

	constraint.localAnchorA = inverseTransformPosition(transformA, globalAnchor);
	constraint.localAnchorB = inverseTransformPosition(transformB, globalAnchor);

	// Limits.
	constraint.swingLimit = swingLimit;
	constraint.twistLimit = twistLimit;
	constraint.localLimitAxisA = inverseTransformDirection(transformA, globalAxis);
	constraint.localLimitAxisB = inverseTransformDirection(transformB, globalAxis);

	getTangents(constraint.localLimitAxisA, constraint.localLimitTangentA, constraint.localLimitBitangentA);
	constraint.localLimitTangentB = conjugate(transformB.rotation) * (transformA.rotation * constraint.localLimitTangentA);

	// Motor.
	constraint.swingMotorType = constraint_velocity_motor;
	constraint.swingMotorVelocity = 0.f;
	constraint.maxSwingMotorTorque = -1.f; // Disabled by default.
	constraint.swingMotorAxis = 0.f;

	constraint.twistMotorType = constraint_velocity_motor;
	constraint.twistMotorVelocity = 0.f;
	constraint.maxTwistMotorTorque = -1.f; // Disabled by default.

	addConstraintEdge(a, ref, constraintEntity, constraint_type_cone_twist);
	addConstraintEdge(b, ref, constraintEntity, constraint_type_cone_twist);

	return { constraintEntity };
}

slider_constraint_handle addSliderConstraintFromGlobalPoints(scene_entity& a, scene_entity& b, vec3 globalAnchor, vec3 globalAxis, float minLimit, float maxLimit)
{
	ASSERT(a.registry == b.registry);

	entt::registry& registry = *a.registry;
	entity_handle constraintEntity = registry.create();
	slider_constraint& constraint = registry.emplace<slider_constraint>(constraintEntity);
	constraint_entity_reference_component& ref = registry.emplace<constraint_entity_reference_component>(constraintEntity);

	const transform_component& transformA = a.getComponent<transform_component>();
	const transform_component& transformB = b.getComponent<transform_component>();

	constraint.localAnchorA = inverseTransformPosition(transformA, globalAnchor);
	constraint.localAnchorB = inverseTransformPosition(transformB, globalAnchor);

	constraint.localAxisA = inverseTransformDirection(transformA, globalAxis);
	constraint.initialInvRotationDifference = conjugate(transformB.rotation) * transformA.rotation;

	constraint.negDistanceLimit = minLimit;
	constraint.posDistanceLimit = maxLimit;

	constraint.motorType = constraint_velocity_motor;
	constraint.motorVelocity = 0.f;
	constraint.maxMotorForce = -1.f; // Disabled by default.

	addConstraintEdge(a, ref, constraintEntity, constraint_type_slider);
	addConstraintEdge(b, ref, constraintEntity, constraint_type_slider);

	return { constraintEntity };
}

distance_constraint_handle addConstraint(scene_entity& a, scene_entity& b, const distance_constraint& c)
{
	entt::registry& registry = *a.registry;
	entity_handle constraintEntity = registry.create();
	registry.emplace<distance_constraint>(constraintEntity, c);
	constraint_entity_reference_component& ref = registry.emplace<constraint_entity_reference_component>(constraintEntity);

	addConstraintEdge(a, ref, constraintEntity, constraint_type_distance);
	addConstraintEdge(b, ref, constraintEntity, constraint_type_distance);

	return { constraintEntity };
}

ball_constraint_handle addConstraint(scene_entity& a, scene_entity& b, const ball_constraint& c)
{
	entt::registry& registry = *a.registry;
	entity_handle constraintEntity = registry.create();
	registry.emplace<ball_constraint>(constraintEntity, c);
	constraint_entity_reference_component& ref = registry.emplace<constraint_entity_reference_component>(constraintEntity);

	addConstraintEdge(a, ref, constraintEntity, constraint_type_ball);
	addConstraintEdge(b, ref, constraintEntity, constraint_type_ball);

	return { constraintEntity };
}

fixed_constraint_handle addConstraint(scene_entity& a, scene_entity& b, const fixed_constraint& c)
{
	entt::registry& registry = *a.registry;
	entity_handle constraintEntity = registry.create();
	registry.emplace<fixed_constraint>(constraintEntity, c);
	constraint_entity_reference_component& ref = registry.emplace<constraint_entity_reference_component>(constraintEntity);

	addConstraintEdge(a, ref, constraintEntity, constraint_type_fixed);
	addConstraintEdge(b, ref, constraintEntity, constraint_type_fixed);

	return { constraintEntity };
}

hinge_constraint_handle addConstraint(scene_entity& a, scene_entity& b, const hinge_constraint& c)
{
	entt::registry& registry = *a.registry;
	entity_handle constraintEntity = registry.create();
	registry.emplace<hinge_constraint>(constraintEntity, c);
	constraint_entity_reference_component& ref = registry.emplace<constraint_entity_reference_component>(constraintEntity);

	addConstraintEdge(a, ref, constraintEntity, constraint_type_hinge);
	addConstraintEdge(b, ref, constraintEntity, constraint_type_hinge);

	return { constraintEntity };
}

cone_twist_constraint_handle addConstraint(scene_entity& a, scene_entity& b, const cone_twist_constraint& c)
{
	entt::registry& registry = *a.registry;
	entity_handle constraintEntity = registry.create();
	registry.emplace<cone_twist_constraint>(constraintEntity, c);
	constraint_entity_reference_component& ref = registry.emplace<constraint_entity_reference_component>(constraintEntity);

	addConstraintEdge(a, ref, constraintEntity, constraint_type_cone_twist);
	addConstraintEdge(b, ref, constraintEntity, constraint_type_cone_twist);

	return { constraintEntity };
}

slider_constraint_handle addConstraint(scene_entity& a, scene_entity& b, const slider_constraint& c)
{
	entt::registry& registry = *a.registry;
	entity_handle constraintEntity = registry.create();
	registry.emplace<slider_constraint>(constraintEntity, c);
	constraint_entity_reference_component& ref = registry.emplace<constraint_entity_reference_component>(constraintEntity);

	addConstraintEdge(a, ref, constraintEntity, constraint_type_slider);
	addConstraintEdge(b, ref, constraintEntity, constraint_type_slider);

	return { constraintEntity };
}

distance_constraint& getConstraint(game_scene& scene, distance_constraint_handle handle)
{
	return scene_entity{ handle.entity, scene }.getComponent<distance_constraint>();
}

ball_constraint& getConstraint(game_scene& scene, ball_constraint_handle handle)
{
	return scene_entity{ handle.entity, scene }.getComponent<ball_constraint>();
}

fixed_constraint& getConstraint(game_scene& scene, fixed_constraint_handle handle)
{
	return scene_entity{ handle.entity, scene }.getComponent<fixed_constraint>();
}

hinge_constraint& getConstraint(game_scene& scene, hinge_constraint_handle handle)
{
	return scene_entity{ handle.entity, scene }.getComponent<hinge_constraint>();
}

cone_twist_constraint& getConstraint(game_scene& scene, cone_twist_constraint_handle handle)
{
	return scene_entity{ handle.entity, scene }.getComponent<cone_twist_constraint>();
}

slider_constraint& getConstraint(game_scene& scene, slider_constraint_handle handle)
{
	return scene_entity{ handle.entity, scene }.getComponent<slider_constraint>();
}

void deleteAllConstraints(game_scene& scene)
{
	scene.deleteAllComponents<distance_constraint>();
	scene.deleteAllComponents<ball_constraint>();
	scene.deleteAllComponents<fixed_constraint>();
	scene.deleteAllComponents<hinge_constraint>();
	scene.deleteAllComponents<cone_twist_constraint>();
	scene.deleteAllComponents<slider_constraint>();
}

static void removeConstraintEdge(scene_entity entity, constraint_edge& edge, constraint_context& context)
{
	physics_reference_component& ref = entity.getComponent<physics_reference_component>();
	if (edge.prevConstraintEdge != INVALID_CONSTRAINT_EDGE)
	{
		context.constraintEdges[edge.prevConstraintEdge].nextConstraintEdge = edge.nextConstraintEdge;
	}
	else
	{
		ref.firstConstraintEdge = edge.nextConstraintEdge;
	}
	--ref.numConstraints;

	if (edge.nextConstraintEdge != INVALID_CONSTRAINT_EDGE)
	{
		context.constraintEdges[edge.nextConstraintEdge].prevConstraintEdge = edge.prevConstraintEdge;
	}

	context.freeConstraintEdge(edge);
}

static void deleteConstraint(entt::registry* registry, entity_handle constraintEntityHandle)
{
	scene_entity constraintEntity = { constraintEntityHandle, registry };
	constraint_entity_reference_component& constraint = constraintEntity.getComponent<constraint_entity_reference_component>();

	scene_entity parentEntityA = { constraint.entityA, registry };
	scene_entity parentEntityB = { constraint.entityB, registry };

	constraint_context& context = getContextVariable<constraint_context>(*registry);

	constraint_edge& edgeA = context.constraintEdges[constraint.edgeA];
	constraint_edge& edgeB = context.constraintEdges[constraint.edgeB];

	removeConstraintEdge(parentEntityA, edgeA, context);
	removeConstraintEdge(parentEntityB, edgeB, context);

	registry->destroy(constraintEntity.handle);
}

void deleteConstraint(game_scene& scene, distance_constraint_handle handle)
{
	deleteConstraint(&scene.registry, handle.entity);
}

void deleteConstraint(game_scene& scene, ball_constraint_handle handle)
{
	deleteConstraint(&scene.registry, handle.entity);
}

void deleteConstraint(game_scene& scene, fixed_constraint_handle handle)
{
	deleteConstraint(&scene.registry, handle.entity);
}

void deleteConstraint(game_scene& scene, hinge_constraint_handle handle)
{
	deleteConstraint(&scene.registry, handle.entity);
}

void deleteConstraint(game_scene& scene, cone_twist_constraint_handle handle)
{
	deleteConstraint(&scene.registry, handle.entity);
}

void deleteConstraint(game_scene& scene, slider_constraint_handle handle)
{
	deleteConstraint(&scene.registry, handle.entity);
}

void deleteAllConstraintsFromEntity(scene_entity& entity)
{
	entt::registry* registry = entity.registry;
	if (constraint_context* context = tryGetContextVariable<constraint_context>(*registry))
	{
		if (physics_reference_component* ref = entity.getComponentIfExists<physics_reference_component>())
		{
			for (auto edgeIndex = ref->firstConstraintEdge; edgeIndex != INVALID_CONSTRAINT_EDGE; )
			{
				constraint_edge& edge = context->constraintEdges[edgeIndex];
				edgeIndex = edge.nextConstraintEdge;

				deleteConstraint(registry, edge.constraintEntity);
			}
		}
	}
}

constraint_entity_iterator::iterator& constraint_entity_iterator::iterator::operator++()
{
	constraint_context& context = getContextVariable<constraint_context>(*registry);
	constraintEdgeIndex = context.constraintEdges[constraintEdgeIndex].nextConstraintEdge;
	return *this;
}

std::pair<scene_entity, constraint_type> constraint_entity_iterator::iterator::operator*()
{
	constraint_context& context = getContextVariable<constraint_context>(*registry);
	return { { context.constraintEdges[constraintEdgeIndex].constraintEntity, registry }, context.constraintEdges[constraintEdgeIndex].type };
}


void testPhysicsInteraction(game_scene& scene, ray r, float strength)
{
	float minT = FLT_MAX;
	rigid_body_component* minRB = 0;
	vec3 force;
	vec3 torque;

	for (auto [entityHandle, collider] : scene.view<collider_component>().each())
	{
		scene_entity entity = { collider.parentEntity, scene };
		if (rigid_body_component* rb = entity.getComponentIfExists<rigid_body_component>())
		{
			physics_transform1_component* physicsTransformComponent = entity.getComponentIfExists<physics_transform1_component>();
			transform_component* transformComponent = entity.getComponentIfExists<transform_component>();
			const trs& transform = physicsTransformComponent ? *physicsTransformComponent : transformComponent ? *transformComponent : trs::identity;

			ray localR = { conjugate(transform.rotation) * (r.origin - transform.position), conjugate(transform.rotation) * r.direction };
			float t;
			bool hit = false;

			switch (collider.type)
			{
				case collider_type_sphere:
				{
					hit = localR.intersectSphere(collider.sphere, t);
				} break;

				case collider_type_capsule:
				{
					hit = localR.intersectCapsule(collider.capsule, t);
				} break;

				case collider_type_cylinder:
				{
					hit = localR.intersectCylinder(collider.cylinder, t);
				} break;

				case collider_type_aabb:
				{
					hit = localR.intersectAABB(collider.aabb, t);
				} break;

				case collider_type_obb:
				{
					hit = localR.intersectOBB(collider.obb, t);
				} break;

				case collider_type_hull:
				{
					hit = localR.intersectHull(collider.hull, boundingHullGeometries[collider.hull.geometryIndex], t);
				} break;
			}

			if (hit && t < minT)
			{
				minT = t;
				minRB = rb;

				vec3 localHit = localR.origin + t * localR.direction;
				vec3 globalHit = transformPosition(transform, localHit);

				vec3 cogPosition = rb->getGlobalCOGPosition(transform);

				force = r.direction * strength;
				torque = cross(globalHit - cogPosition, force);
			}
		}
	}

	if (minRB)
	{
		minRB->torqueAccumulator += torque;
		minRB->forceAccumulator += force;
	}
}

static void getWorldSpaceColliders(game_scene& scene, bounding_box* outWorldspaceAABBs, collider_union* outWorldSpaceColliders, uint16 dummyRigidBodyIndex)
{
	CPU_PROFILE_BLOCK("Get world space colliders");

	uint32 pushIndex = 0;

	for (auto [entityHandle, collider] : scene.view<collider_component>().each())
	{
		bounding_box& bb = outWorldspaceAABBs[pushIndex];
		collider_union& col = outWorldSpaceColliders[pushIndex];
		++pushIndex;

		scene_entity entity = { collider.parentEntity, scene };

		physics_transform1_component* physicsTransformComponent = entity.getComponentIfExists<physics_transform1_component>();
		transform_component* transformComponent = entity.getComponentIfExists<transform_component>();
		const trs& transform = physicsTransformComponent ? *physicsTransformComponent : transformComponent ? *transformComponent : trs::identity;

		col.type = collider.type;
		col.material = collider.material;

		if (entity.hasComponent<rigid_body_component>())
		{
			col.objectIndex = (uint16)entity.getComponentIndex<rigid_body_component>();
			col.objectType = physics_object_type_rigid_body;
		}
		else if (entity.hasComponent<force_field_component>())
		{
			col.objectIndex = (uint16)entity.getComponentIndex<force_field_component>();
			col.objectType = physics_object_type_force_field;
		}
		else if (entity.hasComponent<trigger_component>())
		{
			col.objectIndex = (uint16)entity.getComponentIndex<trigger_component>();
			col.objectType = physics_object_type_trigger;
		}
		else
		{
			col.objectIndex = dummyRigidBodyIndex;
			col.objectType = physics_object_type_static_collider;
		}

		switch (collider.type)
		{
			case collider_type_sphere:
			{
				vec3 center = transform.position + transform.rotation * collider.sphere.center;
				bb = bounding_box::fromCenterRadius(center, collider.sphere.radius);
				col.sphere = { center, collider.sphere.radius };
			} break;

			case collider_type_capsule:
			{
				vec3 posA = transform.rotation * collider.capsule.positionA + transform.position;
				vec3 posB = transform.rotation * collider.capsule.positionB + transform.position;

				float radius = collider.capsule.radius;
				vec3 radius3(radius);

				bb = bounding_box::negativeInfinity();
				bb.grow(posA + radius3);
				bb.grow(posA - radius3);
				bb.grow(posB + radius3);
				bb.grow(posB - radius3);

				col.capsule = { posA, posB, radius };
			} break;

			case collider_type_cylinder:
			{
				vec3 posA = transform.rotation * collider.cylinder.positionA + transform.position;
				vec3 posB = transform.rotation * collider.cylinder.positionB + transform.position;
				float radius = collider.cylinder.radius;

				vec3 a = posB - posA;
				float aa = dot(a, a);

				float x = 1.f - a.x * a.x / aa;
				float y = 1.f - a.y * a.y / aa;
				float z = 1.f - a.z * a.z / aa;
				x = sqrt(max(0.f, x));
				y = sqrt(max(0.f, y));
				z = sqrt(max(0.f, z));

				vec3 e = radius * vec3(x, y, z);

				bb = bounding_box::fromMinMax(min(posA - e, posB - e), max(posA + e, posB + e));

				col.cylinder = { posA, posB, radius };
			} break;

			case collider_type_aabb:
			{
				bb = collider.aabb.transformToAABB(transform.rotation, transform.position);
				if (transform.rotation == quat::identity)
				{
					col.aabb = bb;
				}
				else
				{
					col.type = collider_type_obb;
					col.obb = collider.aabb.transformToOBB(transform.rotation, transform.position);
				}
			} break;

			case collider_type_obb:
			{
				bb = collider.obb.transformToAABB(transform.rotation, transform.position);
				col.obb = collider.obb.transformToOBB(transform.rotation, transform.position);
			} break;

			case collider_type_hull:
			{
				const bounding_hull_geometry& geometry = boundingHullGeometries[collider.hull.geometryIndex];

				quat rotation = transform.rotation * collider.hull.rotation;
				vec3 position = transform.rotation * collider.hull.position + transform.position;

				bb = geometry.aabb.transformToAABB(rotation, position);
				col.hull.rotation = rotation;
				col.hull.position = position;
				col.hull.geometryPtr = &geometry;
			} break;
		}
	}
}

// Returns the accumulated force from all global force fields and writes localized forces (from force fields with colliders) in outLocalizedForceFields.
static vec3 getForceFieldStates(game_scene& scene, force_field_global_state* outLocalForceFields)
{
	vec3 globalForceField(0.f);

	for (auto [entityHandle, forceField] : scene.view<force_field_component>().each())
	{
		scene_entity entity = { entityHandle, scene };

		vec3 force = forceField.force; 
		if (transform_component* transform = entity.getComponentIfExists<transform_component>())
		{
			force = transform->rotation * force;
		}

		if (entity.hasComponent<collider_component>())
		{
			// Localized force field.
			uint16 index = (uint16)entity.getComponentIndex<force_field_component>();
			outLocalForceFields[index].force = force;
		}
		else
		{
			// Global force field.
			globalForceField += force;
		}
	}

	return globalForceField;
}

template <typename constraint_t>
static void getConstraintBodyPairs(game_scene& scene, constraint_body_pair* bodyPairs)
{
	uint32 i = scene.numberOfComponentsOfType<constraint_t>() - 1;
	for (auto [entityHandle, _] : scene.view<constraint_t>().each())
	{
		scene_entity entity = { entityHandle, scene };
		constraint_entity_reference_component& reference = entity.getComponent<constraint_entity_reference_component>();

		constraint_body_pair& pair = bodyPairs[i--];

		scene_entity rbAEntity = { reference.entityA, scene };
		scene_entity rbBEntity = { reference.entityB, scene };
		pair.rbA = (uint16)rbAEntity.getComponentIndex<rigid_body_component>();
		pair.rbB = (uint16)rbBEntity.getComponentIndex<rigid_body_component>();
	}
}

#if 0
#define VALIDATE1(line, prefix, value) if (!isfinite(value)) { bool nan = isnan(value); std::cout << prefix << "(" << line << "): " << #value << " is " << (nan ? "NaN" : "Inf") << '\n'; }
#define VALIDATE3(line, prefix, value) VALIDATE1(line, prefix, value.x); VALIDATE1(line, prefix, value.y); VALIDATE1(line, prefix, value.z);
#define VALIDATE4(line, prefix, value) VALIDATE1(line, prefix, value.x); VALIDATE1(line, prefix, value.y); VALIDATE1(line, prefix, value.z); VALIDATE1(line, prefix, value.w);

void validate(uint32 line, collider_union* colliders, uint32 count)
{
	for (uint32 i = 0; i < count; ++i)
	{
		collider_union& c = colliders[i];
		switch (c.type)
		{
			case collider_type_sphere: VALIDATE3(line, "Collider", c.sphere.center); VALIDATE1(line, "Collider", c.sphere.radius); break;
			case collider_type_capsule: VALIDATE3(line, "Collider", c.capsule.positionA); VALIDATE3(line, "Collider", c.capsule.positionB); VALIDATE1(line, "Collider", c.capsule.radius); break;
			case collider_type_aabb: VALIDATE3(line, "Collider", c.aabb.minCorner); VALIDATE3(line, "Collider", c.aabb.maxCorner); break;
			case collider_type_obb: VALIDATE3(line, "Collider", c.obb.center); VALIDATE3(line, "Collider", c.obb.radius); VALIDATE4(line, "Collider", c.obb.rotation); break;
			case collider_type_hull: break;
		}
	}
}
void validate(uint32 line, bounding_box* colliders, uint32 count)
{
	for (uint32 i = 0; i < count; ++i)
	{
		bounding_box& c = colliders[i];
		VALIDATE3(line, "World space BB", c.minCorner);
		VALIDATE3(line, "World space BB", c.maxCorner);
	}
}
void validate(uint32 line, rigid_body_global_state* rbs, uint32 count)
{
	for (uint32 i = 0; i < count; ++i)
	{
		rigid_body_global_state& r = rbs[i];
		VALIDATE4(line, "RB update", r.rotation);
		VALIDATE3(line, "RB update", r.localCOGPosition);
		VALIDATE3(line, "RB update", r.position);
		VALIDATE3(line, "RB update", r.invInertia.col0);
		VALIDATE3(line, "RB update", r.invInertia.col1);
		VALIDATE3(line, "RB update", r.invInertia.col2);
		VALIDATE1(line, "RB update", r.invMass);
		VALIDATE3(line, "RB update", r.linearVelocity);
		VALIDATE3(line, "RB update", r.angularVelocity);
	}
}
void validate(uint32 line, collision_contact* contacts, uint32 count)
{
	for (uint32 i = 0; i < count; ++i)
	{
		collision_contact& c = contacts[i];
		VALIDATE3(line, "Contact", c.point);
		VALIDATE1(line, "Contact", c.penetrationDepth);
		VALIDATE3(line, "Contact", c.normal);
	}
}
void validate(uint32 line, collision_constraint* constraints, uint32 count)
{
	for (uint32 i = 0; i < count; ++i)
	{
		collision_constraint& c = constraints[i];
		VALIDATE3(line, "Collision", c.relGlobalAnchorA);
		VALIDATE3(line, "Collision", c.relGlobalAnchorB);
		VALIDATE3(line, "Collision", c.tangent);
		VALIDATE3(line, "Collision", c.tangentImpulseToAngularVelocityA);
		VALIDATE3(line, "Collision", c.tangentImpulseToAngularVelocityB);
		VALIDATE3(line, "Collision", c.normalImpulseToAngularVelocityA);
		VALIDATE3(line, "Collision", c.normalImpulseToAngularVelocityB);
		VALIDATE1(line, "Collision", c.impulseInNormalDir);
		VALIDATE1(line, "Collision", c.impulseInTangentDir);
		VALIDATE1(line, "Collision", c.effectiveMassInNormalDir);
		VALIDATE1(line, "Collision", c.effectiveMassInTangentDir);
		VALIDATE1(line, "Collision", c.bias);
	}
}
void validate(uint32 line, simd_collision_constraint_batch* constraints, uint32 count)
{
	for (uint32 i = 0; i < count; ++i)
	{
		simd_collision_constraint_batch& c = constraints[i];
		for (uint32 j = 0; j < CONSTRAINT_SIMD_WIDTH; ++j)
		{
			VALIDATE1(line, "Collision", c.relGlobalAnchorA[0][j]);
			VALIDATE1(line, "Collision", c.relGlobalAnchorA[1][j]);
			VALIDATE1(line, "Collision", c.relGlobalAnchorA[2][j]);
			VALIDATE1(line, "Collision", c.relGlobalAnchorB[0][j]);
			VALIDATE1(line, "Collision", c.relGlobalAnchorB[1][j]);
			VALIDATE1(line, "Collision", c.relGlobalAnchorB[2][j]);
			VALIDATE1(line, "Collision", c.normal[0][j]);
			VALIDATE1(line, "Collision", c.normal[1][j]);
			VALIDATE1(line, "Collision", c.normal[2][j]);
			VALIDATE1(line, "Collision", c.tangent[0][j]);
			VALIDATE1(line, "Collision", c.tangent[1][j]);
			VALIDATE1(line, "Collision", c.tangent[2][j]);
			VALIDATE1(line, "Collision", c.normalImpulseToAngularVelocityA[0][j]);
			VALIDATE1(line, "Collision", c.normalImpulseToAngularVelocityA[1][j]);
			VALIDATE1(line, "Collision", c.normalImpulseToAngularVelocityA[2][j]);
			VALIDATE1(line, "Collision", c.tangentImpulseToAngularVelocityA[0][j]);
			VALIDATE1(line, "Collision", c.tangentImpulseToAngularVelocityA[1][j]);
			VALIDATE1(line, "Collision", c.tangentImpulseToAngularVelocityA[2][j]);
			VALIDATE1(line, "Collision", c.normalImpulseToAngularVelocityB[0][j]);
			VALIDATE1(line, "Collision", c.normalImpulseToAngularVelocityB[1][j]);
			VALIDATE1(line, "Collision", c.normalImpulseToAngularVelocityB[2][j]);
			VALIDATE1(line, "Collision", c.tangentImpulseToAngularVelocityB[0][j]);
			VALIDATE1(line, "Collision", c.tangentImpulseToAngularVelocityB[1][j]);
			VALIDATE1(line, "Collision", c.tangentImpulseToAngularVelocityB[2][j]);
			VALIDATE1(line, "Collision", c.effectiveMassInNormalDir[j]);
			VALIDATE1(line, "Collision", c.effectiveMassInTangentDir[j]);
			VALIDATE1(line, "Collision", c.friction[j]);
			VALIDATE1(line, "Collision", c.impulseInNormalDir[j]);
			VALIDATE1(line, "Collision", c.impulseInTangentDir[j]);
			VALIDATE1(line, "Collision", c.bias[j]);
		}
	}
}

#define VALIDATE(arr, count) validate(__LINE__, arr, count)

#else
#define VALIDATE(...)
#endif


struct entity_pair
{
	entity_handle a;
	entity_handle b;

	operator uint64() const { return ((uint64)a << 32) | (uint64)b; }
	bool operator<(entity_pair o) const { return (uint64)*this < (uint64)o; }
	bool operator==(entity_pair o) const { return a == o.a && b == o.b; }
	bool operator!=(entity_pair o) const { return !(*this == o); }
};

struct collision_entity_pair : entity_pair
{
	uint16 contactOffset;
	uint16 numContacts;
};

struct event_context
{
	std::vector<entity_pair> prevFrameTriggerOverlaps;
	std::vector<collision_entity_pair> prevFrameCollisions;
};

static void handleNonCollisionInteractions(game_scene& scene, 
	const force_field_global_state* ffGlobal, const non_collision_interaction* nonCollisionInteractions, uint32 numNonCollisionInteractions,
	uint32 numRigidBodies, uint32 numTriggers)
{
	std::vector<entity_pair> triggerOverlaps;

	for (uint32 i = 0; i < numNonCollisionInteractions; ++i)
	{
		non_collision_interaction interaction = nonCollisionInteractions[i];
		rigid_body_component& rb = scene.getComponentAtIndex<rigid_body_component>(numRigidBodies - 1 - interaction.rigidBodyIndex);

		if (interaction.otherType == physics_object_type_force_field)
		{
			const force_field_global_state& ff = ffGlobal[interaction.otherIndex];
			rb.forceAccumulator += ff.force;
		}
		else if (interaction.otherType == physics_object_type_trigger)
		{
			scene_entity triggerEntity = scene.getEntityFromComponentAtIndex<trigger_component>(numTriggers - 1 - interaction.otherIndex);
			scene_entity rbEntity = scene.getEntityFromComponent(rb);

			entity_pair overlap = { triggerEntity.handle, rbEntity.handle };

			triggerOverlaps.push_back(overlap);
		}
	}

	std::sort(triggerOverlaps.begin(), triggerOverlaps.end());

	// De-duplicate. Since we operate on entities here, multiple colliders may report the same overlap.
	triggerOverlaps.erase(std::unique(triggerOverlaps.begin(), triggerOverlaps.end()), triggerOverlaps.end());

	event_context& context = scene.createOrGetContextVariable<event_context>();

	auto prevIterator = context.prevFrameTriggerOverlaps.begin();
	auto thisIterator = triggerOverlaps.begin();

	auto prevEnd = context.prevFrameTriggerOverlaps.end();
	auto thisEnd = triggerOverlaps.end();

	auto triggerEvent = [&scene](entity_pair pair, trigger_event_type type)
	{
		scene_entity triggerEntity = { pair.a, scene };
		scene_entity otherEntity = { pair.b, scene };
		const trigger_component& triggerComp = triggerEntity.getComponent<trigger_component>();
		triggerComp.callback(trigger_event{ triggerEntity, otherEntity, type });
	};

	while (prevIterator != prevEnd && thisIterator != thisEnd)
	{
		entity_pair p = *prevIterator;
		entity_pair t = *thisIterator;

		if (p == t)
		{
			++prevIterator;
			++thisIterator;
			continue;
		}

		if (p < t)
		{
			triggerEvent(p, trigger_event_leave);
			++prevIterator;
		}
		else
		{
			triggerEvent(t, trigger_event_enter);
			++thisIterator;
		}
	}

	while (prevIterator != prevEnd)
	{
		triggerEvent(*(prevIterator++), trigger_event_leave);
	}

	while (thisIterator != thisEnd)
	{
		triggerEvent(*(thisIterator++), trigger_event_enter);
	}

	context.prevFrameTriggerOverlaps = std::move(triggerOverlaps);
}

static void handleCollisionCallbacks(game_scene& scene, const collider_pair* colliderPairs, uint8* contactCountPerCollision, uint32 numColliderPairs,
	uint32 numColliders, const collision_contact* contacts, const rigid_body_global_state* rbGlobal, uint32 dummyRigidBodyIndex,
	const collision_begin_event_func& collisionBeginCallback, const collision_end_event_func& collisionEndCallback)
{
	std::vector<collision_entity_pair> collisions;

	uint16 contactOffset = 0;

	for (uint32 i = 0; i < numColliderPairs; ++i)
	{
		collider_pair colliderPair = colliderPairs[i];

		if (colliderPair.colliderB < numColliders)
		{
			uint16 numContacts = contactCountPerCollision[i];

			scene_entity aEntity = scene.getEntityFromComponentAtIndex<collider_component>(numColliders - 1 - colliderPair.colliderA);
			scene_entity bEntity = scene.getEntityFromComponentAtIndex<collider_component>(numColliders - 1 - colliderPair.colliderB);

			collision_entity_pair overlap = { aEntity.handle, bEntity.handle, contactOffset, numContacts };

			collisions.push_back(overlap);
			contactOffset += numContacts;
		}
	}

	std::sort(collisions.begin(), collisions.end());

	event_context& context = scene.createOrGetContextVariable<event_context>();

	if (collisionBeginCallback || collisionEndCallback)
	{
		auto prevIterator = context.prevFrameCollisions.begin();
		auto thisIterator = collisions.begin();

		auto prevEnd = context.prevFrameCollisions.end();
		auto thisEnd = collisions.end();

		auto beginEvent = [contacts, rbGlobal, &collisionBeginCallback, &scene, dummyRigidBodyIndex](collision_entity_pair pair)
		{
			if (collisionBeginCallback)
			{
				scene_entity colliderAEntity = { pair.a, scene };
				scene_entity colliderBEntity = { pair.b, scene };

				const collider_component& colliderA = colliderAEntity.getComponent<collider_component>();
				const collider_component& colliderB = colliderBEntity.getComponent<collider_component>();

				scene_entity rbAEntity = { colliderA.parentEntity, scene };
				scene_entity rbBEntity = { colliderB.parentEntity, scene };


				const collision_contact* c = contacts + pair.contactOffset;
				uint32 numContacts = pair.numContacts;
				ASSERT(numContacts > 0);

				float norm = 1.f / numContacts;

				vec3 point(0.f);
				vec3 normal(0.f);
				for (uint32 i = 0; i < numContacts; ++i)
				{
					point += c[i].point;
					normal += c[i].normal;
				}

				point *= norm;
				normal *= norm;


				auto& rbAGlobal = rbGlobal[rbAEntity.hasComponent<rigid_body_component>() ? rbAEntity.getComponentIndex<rigid_body_component>() : dummyRigidBodyIndex];
				auto& rbBGlobal = rbGlobal[rbBEntity.hasComponent<rigid_body_component>() ? rbBEntity.getComponentIndex<rigid_body_component>() : dummyRigidBodyIndex];

				vec3 velA = rbAGlobal.linearVelocity + cross(rbAGlobal.angularVelocity, point - rbAGlobal.position);
				vec3 velB = rbBGlobal.linearVelocity + cross(rbBGlobal.angularVelocity, point - rbBGlobal.position);

				collision_begin_event e = { rbAEntity, rbBEntity, colliderA, colliderB, point, normal, velB - velA };
				collisionBeginCallback(e);
			}
		};

		auto endEvent = [&collisionEndCallback, &scene](collision_entity_pair pair)
		{
			if (collisionEndCallback)
			{
				scene_entity colliderAEntity = { pair.a, scene };
				scene_entity colliderBEntity = { pair.b, scene };

				const collider_component& colliderA = colliderAEntity.getComponent<collider_component>();
				const collider_component& colliderB = colliderBEntity.getComponent<collider_component>();

				scene_entity rbAEntity = { colliderA.parentEntity, scene };
				scene_entity rbBEntity = { colliderB.parentEntity, scene };

				collision_end_event e = { rbAEntity, rbBEntity, colliderA, colliderB };
				collisionEndCallback(e);
			}
		};

		while (prevIterator != prevEnd && thisIterator != thisEnd)
		{
			collision_entity_pair p = *prevIterator;
			collision_entity_pair t = *thisIterator;

			if (p == t)
			{
				++prevIterator;
				++thisIterator;
				continue;
			}

			if (p < t)
			{
				endEvent(p);
				++prevIterator;
			}
			else
			{
				beginEvent(t);
				++thisIterator;
			}
		}

		if (collisionEndCallback)
		{
			while (prevIterator != prevEnd)
			{
				endEvent(*(prevIterator++));
			}
		}

		if (collisionBeginCallback)
		{
			while (thisIterator != thisEnd)
			{
				beginEvent(*(thisIterator++));
			}
		}
	}

	context.prevFrameCollisions = std::move(collisions);
}

static void physicsStepInternal(game_scene& scene, memory_arena& arena, const physics_settings& settings, float dt)
{
	CPU_PROFILE_BLOCK("Physics step");

	uint32 numRigidBodies = scene.numberOfComponentsOfType<rigid_body_component>();
	uint32 numCloths = scene.numberOfComponentsOfType<cloth_component>();
	if (numRigidBodies == 0 && numCloths == 0)
	{
		return;
	}

	uint32 numForceFields = scene.numberOfComponentsOfType<force_field_component>();
	uint32 numTriggers = scene.numberOfComponentsOfType<trigger_component>();
	uint32 numColliders = scene.numberOfComponentsOfType<collider_component>();

	uint32 numDistanceConstraints = scene.numberOfComponentsOfType<distance_constraint>();
	uint32 numBallConstraints = scene.numberOfComponentsOfType<ball_constraint>();
	uint32 numFixedConstraints = scene.numberOfComponentsOfType<fixed_constraint>();
	uint32 numHingeConstraints = scene.numberOfComponentsOfType<hinge_constraint>();
	uint32 numConeTwistConstraints = scene.numberOfComponentsOfType<cone_twist_constraint>();
	uint32 numSliderConstraints = scene.numberOfComponentsOfType<slider_constraint>();
	uint32 numConstraints = numDistanceConstraints + numBallConstraints + numFixedConstraints + numHingeConstraints + numConeTwistConstraints + numSliderConstraints;



	memory_marker marker = arena.getMarker();

	rigid_body_global_state* rbGlobal = arena.allocate<rigid_body_global_state>(numRigidBodies + 1); // Reserve one slot for dummy.
	force_field_global_state* ffGlobal = arena.allocate<force_field_global_state>(numForceFields);
	bounding_box* worldSpaceAABBs = arena.allocate<bounding_box>(numColliders);
	collider_union* worldSpaceColliders = arena.allocate<collider_union>(numColliders);

	collider_pair* overlappingColliderPairs = arena.allocate<collider_pair>(numColliders * numColliders + 5000); // Conservative estimate.

	uint32 dummyRigidBodyIndex = numRigidBodies;

	// Collision detection.
	getWorldSpaceColliders(scene, worldSpaceAABBs, worldSpaceColliders, dummyRigidBodyIndex);
	VALIDATE(worldSpaceColliders, numColliders);
	VALIDATE(worldSpaceAABBs, numColliders);

	// Broad phase.
	uint32 numBroadphaseOverlaps = broadphase(scene, worldSpaceAABBs, arena, overlappingColliderPairs, settings.simdBroadPhase);

	non_collision_interaction* nonCollisionInteractions = arena.allocate<non_collision_interaction>(numBroadphaseOverlaps);
	collision_contact* contacts = arena.allocate<collision_contact>(numBroadphaseOverlaps * 4 + 5000); // Each collision can have up to 4 contact points.
	constraint_body_pair* allConstraintBodyPairs = arena.allocate<constraint_body_pair>(numConstraints + numBroadphaseOverlaps * 4 + 5000);
	collider_pair* collidingColliderPairs = overlappingColliderPairs; // We reuse this buffer.
	uint8* contactCountPerCollision = arena.allocate<uint8>(numColliders * numColliders + 5000);

	constraint_body_pair* collisionBodyPairs = allConstraintBodyPairs + numConstraints;

	// Narrow phase.
	narrowphase_result narrowPhaseResult = narrowphase(worldSpaceColliders, overlappingColliderPairs, numBroadphaseOverlaps, arena,
		contacts, collisionBodyPairs, collidingColliderPairs, contactCountPerCollision, nonCollisionInteractions, settings.simdNarrowPhase);
	

	// Heightmap collisions.
	for (auto [entityHandle, heightmap] : scene.view<heightmap_collider_component>().each())
	{
		narrowphase_result heightmapCollisionResult = heightmapCollision(heightmap, worldSpaceColliders, worldSpaceAABBs, numColliders,
			contacts + narrowPhaseResult.numContacts, collisionBodyPairs + narrowPhaseResult.numContacts,
			collidingColliderPairs + narrowPhaseResult.numCollisions, contactCountPerCollision + narrowPhaseResult.numCollisions,
			arena, (uint16)dummyRigidBodyIndex);

		narrowPhaseResult.numCollisions += heightmapCollisionResult.numCollisions;
		narrowPhaseResult.numContacts += heightmapCollisionResult.numContacts;
		narrowPhaseResult.numNonCollisionInteractions += heightmapCollisionResult.numNonCollisionInteractions;
	}

	VALIDATE(contacts, narrowPhaseResult.numContacts);


	vec3 globalForceField = getForceFieldStates(scene, ffGlobal);

	handleNonCollisionInteractions(scene, ffGlobal, nonCollisionInteractions, narrowPhaseResult.numNonCollisionInteractions,
		numRigidBodies, numTriggers);

	CPU_PROFILE_STAT("Num rigid bodies", numRigidBodies);
	CPU_PROFILE_STAT("Num colliders", numColliders);
	CPU_PROFILE_STAT("Num broadphase overlaps", numBroadphaseOverlaps);
	CPU_PROFILE_STAT("Num narrowphase collisions", narrowPhaseResult.numCollisions);
	CPU_PROFILE_STAT("Num narrowphase contacts", narrowPhaseResult.numContacts);


	//  Apply global forces (including gravity) and air drag and integrate forces.
	{
		CPU_PROFILE_BLOCK("Integrate rigid body forces");

		uint32 rbIndex = numRigidBodies - 1; // EnTT iterates back to front.
		for (auto [entityHandle, rb, transform] : scene.group<rigid_body_component, physics_transform1_component>().each())
		{
			rigid_body_global_state& global = rbGlobal[rbIndex--];
			rb.forceAccumulator += globalForceField;
			rb.applyGravityAndIntegrateForces(global, transform, dt);
		}
	}

	// Kinematic rigid body. This is used in collision constraint solving, when a collider has no rigid body.
	memset(&rbGlobal[dummyRigidBodyIndex], 0, sizeof(rigid_body_global_state));

	VALIDATE(rbGlobal, numRigidBodies);


	handleCollisionCallbacks(scene, collidingColliderPairs, contactCountPerCollision, narrowPhaseResult.numCollisions, numColliders, contacts, rbGlobal, dummyRigidBodyIndex,
		settings.collisionBeginCallback, settings.collisionEndCallback);




	// Collect constraints.
	uint32 numContacts = narrowPhaseResult.numContacts;

	distance_constraint* distanceConstraints = scene.raw<distance_constraint>();
	ball_constraint* ballConstraints = scene.raw<ball_constraint>();
	fixed_constraint* fixedConstraints = scene.raw<fixed_constraint>();
	hinge_constraint* hingeConstraints = scene.raw<hinge_constraint>();
	cone_twist_constraint* coneTwistConstraints = scene.raw<cone_twist_constraint>();
	slider_constraint* sliderConstraints = scene.raw<slider_constraint>();

	constraint_body_pair* distanceConstraintBodyPairs = allConstraintBodyPairs + 0;
	constraint_body_pair* ballConstraintBodyPairs = distanceConstraintBodyPairs + numDistanceConstraints;
	constraint_body_pair* fixedConstraintBodyPairs = ballConstraintBodyPairs + numBallConstraints;
	constraint_body_pair* hingeConstraintBodyPairs = fixedConstraintBodyPairs + numFixedConstraints;
	constraint_body_pair* coneTwistConstraintBodyPairs = hingeConstraintBodyPairs + numHingeConstraints;
	constraint_body_pair* sliderConstraintBodyPairs = coneTwistConstraintBodyPairs + numConeTwistConstraints;

	getConstraintBodyPairs<distance_constraint>(scene, distanceConstraintBodyPairs);
	getConstraintBodyPairs<ball_constraint>(scene, ballConstraintBodyPairs);
	getConstraintBodyPairs<fixed_constraint>(scene, fixedConstraintBodyPairs);
	getConstraintBodyPairs<hinge_constraint>(scene, hingeConstraintBodyPairs);
	getConstraintBodyPairs<cone_twist_constraint>(scene, coneTwistConstraintBodyPairs);
	getConstraintBodyPairs<slider_constraint>(scene, sliderConstraintBodyPairs);


	// Solve constraints.
	constraint_solver constraintSolver;
	constraintSolver.initialize(arena, rbGlobal,
		distanceConstraints, distanceConstraintBodyPairs, numDistanceConstraints,
		ballConstraints, ballConstraintBodyPairs, numBallConstraints,
		fixedConstraints, fixedConstraintBodyPairs, numFixedConstraints,
		hingeConstraints, hingeConstraintBodyPairs, numHingeConstraints,
		coneTwistConstraints, coneTwistConstraintBodyPairs, numConeTwistConstraints,
		sliderConstraints, sliderConstraintBodyPairs, numSliderConstraints,
		contacts, collisionBodyPairs, numContacts,
		dummyRigidBodyIndex, settings.simdConstraintSolver, dt);

	{
		CPU_PROFILE_BLOCK("Solve constraints");

		for (uint32 it = 0; it < settings.numRigidSolverIterations; ++it)
		{
			constraintSolver.solveOneIteration();
		}
	}


	// Integrate velocities.
	{
		CPU_PROFILE_BLOCK("Integrate rigid body velocities");

		uint32 rbIndex = numRigidBodies - 1; // EnTT iterates back to front.
		for (auto [entityHandle, rb, transform] : scene.group<rigid_body_component, physics_transform1_component>().each())
		{
			rigid_body_global_state& global = rbGlobal[rbIndex--];

			rb.integrateVelocity(global, transform, dt);
		}
	}

	VALIDATE(rbGlobal, numRigidBodies);

	// Cloth. This needs to get integrated with the rest of the system.

	for (auto [entityHandle, cloth] : scene.view<cloth_component>().each())
	{
		cloth.applyWindForce(globalForceField);
		cloth.simulate(settings.numClothVelocityIterations, settings.numClothPositionIterations, settings.numClothDriftIterations, dt);
	}


	arena.resetToMarker(marker);
}

void physicsStep(game_scene& scene, memory_arena& arena, float& timer, const physics_settings& settings, float dt)
{
	if (settings.fixedFrameRate)
	{
		const float physicsFixedTimeStep = 1.f / (float)settings.frameRate;
		const uint32 maxPhysicsIterationsPerFrame = settings.maxPhysicsIterationsPerFrame;

		timer += dt;
		uint32 physicsIterations = 0;
		if (timer >= physicsFixedTimeStep)
		{
			for (auto [entityHandle, transform0, transform1] : scene.group(component_group<physics_transform0_component, physics_transform1_component>).each())
			{
				transform0 = transform1;
			}

			while (timer >= physicsFixedTimeStep && physicsIterations++ < maxPhysicsIterationsPerFrame)
			{
				physicsStepInternal(scene, arena, settings, physicsFixedTimeStep);
				timer -= physicsFixedTimeStep;
			}
		}

		if (timer >= physicsFixedTimeStep)
		{
			timer = fmod(timer, physicsFixedTimeStep);

#ifndef PHYSICS_ONLY
			LOG_WARNING("Dropping physics frames");
#endif
		}

		float physicsInterpolationT = timer / physicsFixedTimeStep;
		ASSERT(physicsInterpolationT >= 0.f && physicsInterpolationT <= 1.f);

		for (auto [entityHandle, transform, physicsTransform0, physicsTransform1] : scene.group(component_group<transform_component, physics_transform0_component, physics_transform1_component>).each())
		{
			transform = lerp(physicsTransform0, physicsTransform1, physicsInterpolationT);
		}
	}
	else
	{
		physicsStepInternal(scene, arena, settings, dt);

		for (auto [entityHandle, transform, physicsTransform1] : scene.group(component_group<transform_component, physics_transform1_component>).each())
		{
			transform = physicsTransform1;
		}
	}
}

// This function returns the inertia tensors with respect to the center of gravity, so with a coordinate system centered at the COG.
physics_properties collider_union::calculatePhysicsProperties()
{
	physics_properties result;
	switch (type)
	{
		case collider_type_sphere:
		{
			result.mass = sphere.volume() * material.density;
			result.cog = sphere.center;
			result.inertia = mat3::identity * (2.f / 5.f * result.mass * sphere.radius * sphere.radius);
		} break;

		case collider_type_capsule:
		{
			vec3 axis = capsule.positionA - capsule.positionB;
			if (axis.y < 0.f)
			{
				axis *= -1.f;
			}
			float height = length(axis);
			axis *= (1.f / height);

			quat rotation = rotateFromTo(vec3(0.f, 1.f, 0.f), axis);
			mat3 rot = quaternionToMat3(rotation);

			result.mass = capsule.volume() * material.density;
			result.cog = (capsule.positionA + capsule.positionB) * 0.5f;
			
			// Inertia.
			float sqRadius = capsule.radius * capsule.radius;
			float sqRadiusPI = M_PI * sqRadius;

			float cylinderMass = material.density * sqRadiusPI * height;
			float hemiSphereMass = material.density * 2.f / 3.f * sqRadiusPI * capsule.radius;

			float sqCapsuleHeight = height * height;

			result.inertia.m11 = sqRadius * cylinderMass * 0.5f;
			result.inertia.m00 = result.inertia.m22 = result.inertia.m11 * 0.5f + cylinderMass * sqCapsuleHeight / 12.f;
			float temp0 = hemiSphereMass * 2.f * sqRadius / 5.f;
			result.inertia.m11 += temp0 * 2.f;
			float temp1 = height * 0.5f;
			float temp2 = temp0 + hemiSphereMass * (temp1 * temp1 + 3.f / 8.f * sqCapsuleHeight);
			result.inertia.m00 += temp2 * 2.f;
			result.inertia.m22 += temp2 * 2.f;
			result.inertia.m01 = result.inertia.m02 = result.inertia.m10 = result.inertia.m12 = result.inertia.m20 = result.inertia.m21 = 0.f;

			result.inertia = transpose(rot) * result.inertia * rot;
		} break;

		case collider_type_cylinder:
		{
			vec3 axis = cylinder.positionA - cylinder.positionB;
			if (axis.y < 0.f)
			{
				axis *= -1.f;
			}
			float height = length(axis);
			axis *= (1.f / height);

			quat rotation = rotateFromTo(vec3(0.f, 1.f, 0.f), axis);
			mat3 rot = quaternionToMat3(rotation);

			result.mass = cylinder.volume() * material.density;
			result.cog = (cylinder.positionA + cylinder.positionB) * 0.5f;

			// Inertia.
			float sqRadius = cylinder.radius * cylinder.radius;
			float sqHeight = height * height;

			result.inertia.m11 = sqRadius * result.mass * 0.5f;
			result.inertia.m00 = result.inertia.m22 = 1.f / 12.f * result.mass * (3.f * sqRadius + sqHeight);
			result.inertia.m01 = result.inertia.m02 = result.inertia.m10 = result.inertia.m12 = result.inertia.m20 = result.inertia.m21 = 0.f;

			result.inertia = transpose(rot) * result.inertia * rot;
		} break;

		case collider_type_aabb:
		{
			result.mass = aabb.volume() * material.density;
			result.cog = aabb.getCenter();

			vec3 diameter = aabb.getRadius() * 2.f;
			result.inertia = mat3::zero;
			result.inertia.m00 = 1.f / 12.f * result.mass * (diameter.y * diameter.y + diameter.z * diameter.z);
			result.inertia.m11 = 1.f / 12.f * result.mass * (diameter.x * diameter.x + diameter.z * diameter.z);
			result.inertia.m22 = 1.f / 12.f * result.mass * (diameter.x * diameter.x + diameter.y * diameter.y);
		} break;

		case collider_type_obb:
		{
			result.mass = obb.volume() * material.density;
			result.cog = obb.center;

			vec3 diameter = obb.radius * 2.f;
			result.inertia = mat3::zero;
			result.inertia.m00 = 1.f / 12.f * result.mass * (diameter.y * diameter.y + diameter.z * diameter.z);
			result.inertia.m11 = 1.f / 12.f * result.mass * (diameter.x * diameter.x + diameter.z * diameter.z);
			result.inertia.m22 = 1.f / 12.f * result.mass * (diameter.x * diameter.x + diameter.y * diameter.y);

			mat3 rot = quaternionToMat3(obb.rotation);
			result.inertia = transpose(rot) * result.inertia * rot;
		} break;

		case collider_type_hull:
		{
			// http://number-none.com/blow/inertia/
			// http://number-none.com/blow/inertia/bb_inertia.doc

			const bounding_hull_geometry& geom = boundingHullGeometries[hull.geometryIndex];

			const float s60 = 1.f / 60.f;
			const float s120 = 1.f / 120.f;

			// Covariance-matrix of a tetrahedron with v0 = (0, 0, 0), v1 = (1, 0, 0), v2 = (0, 1, 0), v3 = (0, 0, 1).
			const mat3 Ccanonical(
				s60, s120, s120,
				s120, s60, s120,
				s120, s120, s60
			);

			uint32 numFaces = (uint32)geom.faces.size();

			float totalMass = 0.f;
			mat3 totalCovariance = mat3::zero;
			vec3 totalCOG(0.f);

			for (uint32 i = 0; i < numFaces; ++i)
			{
				auto& face = geom.faces[i];

				//vec3 w0 = 0.f;
				vec3 w1 = hull.position + hull.rotation * geom.vertices[face.a];
				vec3 w2 = hull.position + hull.rotation * geom.vertices[face.b];
				vec3 w3 = hull.position + hull.rotation * geom.vertices[face.c];

				mat3 A(
					w1.x, w2.x, w3.x,
					w1.y, w2.y, w3.y,
					w1.z, w2.z, w3.z
				);


				float detA = determinant(A);
				mat3 covariance = detA * A * Ccanonical * transpose(A);

				float volume = 1.f / 6.f * detA;
				float mass = volume;
				vec3 cog = (w1 + w2 + w3) * 0.25f;

				totalMass += mass;
				totalCovariance += covariance;
				totalCOG += cog * mass;
			}

			totalCOG /= totalMass;

			// This is actually different in the Blow-paper, but this one is correct.
			mat3 CprimeTotal = totalCovariance - totalMass * outerProduct(totalCOG, totalCOG);

			result.cog = totalCOG;
			result.mass = totalMass * material.density;
			result.inertia = mat3::identity * trace(CprimeTotal) - CprimeTotal;
			result.inertia *= material.density;
		} break;

		default:
		{
			ASSERT(false);
		} break;
	}
	return result;
}

```

`src/physics/physics.h`:

```h
#pragma once

#include "core/math.h"
#include "core/memory.h"
#include "bounding_volumes.h"
#include "scene/scene.h"
#include "constraints.h"
#include "rigid_body.h"
#include "cloth.h"

#define GRAVITY -9.81f

struct physics_properties
{
	mat3 inertia;
	vec3 cog;
	float mass;
};

enum physics_material_type
{
	physics_material_type_none = -1,

	physics_material_type_metal,
	physics_material_type_wood,
	physics_material_type_flesh,

	physics_material_type_count,
};

static const char* physicsMaterialTypeNames[] =
{
	"Metal",
	"Wood",
	"Flesh",
};

static_assert(arraysize(physicsMaterialTypeNames) == physics_material_type_count);

struct physics_material
{
	physics_material_type type; // Currently only used for sound selection.

	float restitution;
	float friction;
	float density;
};

enum physics_object_type : uint8
{
	physics_object_type_rigid_body,
	physics_object_type_static_collider,
	physics_object_type_force_field,
	physics_object_type_trigger,

	physics_object_type_count,
};

enum collider_type : uint8
{
	// The order here is important. See collision_narrow.cpp.
	collider_type_sphere,
	collider_type_capsule,
	collider_type_cylinder,
	collider_type_aabb,
	collider_type_obb,
	collider_type_hull,

	collider_type_count,
};

static const char* colliderTypeNames[] =
{
	"Sphere",
	"Capsule",
	"Cylinder",
	"AABB",
	"OBB",
	"Hull",
};

static_assert(arraysize(colliderTypeNames) == collider_type_count, "Missing collider name");

struct collider_union
{
	collider_union() {}
	physics_properties calculatePhysicsProperties();

	union
	{
		bounding_sphere sphere;
		bounding_capsule capsule;
		bounding_cylinder cylinder;
		bounding_box aabb;
		bounding_oriented_box obb;
		bounding_hull hull;
	};

	physics_material material;

	collider_type type;

	// These two are only used internally and should not be read outside.
	physics_object_type objectType;
	uint16 objectIndex; // Depending on objectType: Rigid body index, force field index, ...
};

struct collider_component : collider_union
{
	static collider_component asSphere(bounding_sphere s, physics_material material)
	{
		collider_component result;
		result.sphere = s;
		result.type = collider_type_sphere;
		result.material = material;
		return result;
	}
	static collider_component asCapsule(bounding_capsule c, physics_material material)
	{
		collider_component result;
		result.capsule = c;
		result.type = collider_type_capsule;
		result.material = material;
		return result;
	}
	static collider_component asCylinder(bounding_cylinder c, physics_material material)
	{
		collider_component result;
		result.cylinder = c;
		result.type = collider_type_cylinder;
		result.material = material;
		return result;
	}
	static collider_component asAABB(bounding_box b, physics_material material)
	{
		collider_component result;
		result.aabb = b;
		result.type = collider_type_aabb;
		result.material = material;
		return result;
	}
	static collider_component asOBB(bounding_oriented_box b, physics_material material)
	{
		collider_component result;
		result.obb = b;
		result.type = collider_type_obb;
		result.material = material;
		return result;
	}
	static collider_component asHull(bounding_hull h, physics_material material)
	{
		collider_component result;
		result.hull = h;
		result.type = collider_type_hull;
		result.material = material;
		return result;
	}

	static collider_component fromUnion(const collider_union& u)
	{
		collider_component result;
		memcpy(&result, &u, sizeof(u));
		return result;
	}

	collider_component() = default;

	// Set by scene on component creation.
	entity_handle parentEntity;
	entity_handle nextEntity;
};

struct physics_reference_component
{
	uint32 numColliders = 0;
	entity_handle firstColliderEntity = entt::null;

	uint32 numConstraints = 0;
	uint16 firstConstraintEdge = INVALID_CONSTRAINT_EDGE;
};

struct force_field_component
{
	vec3 force;
};

enum trigger_event_type
{
	trigger_event_enter,
	trigger_event_leave,
};

struct trigger_event
{
	scene_entity trigger;
	scene_entity other;
	trigger_event_type type;
};

struct trigger_component
{
	std::function<void(trigger_event)> callback;
};

#define INVALID_BOUNDING_HULL_INDEX -1

uint32 allocateBoundingHullGeometry(const std::string& meshFilepath);

struct distance_constraint_handle { entity_handle entity; };
struct ball_constraint_handle { entity_handle entity; };
struct fixed_constraint_handle { entity_handle entity; };
struct hinge_constraint_handle { entity_handle entity; };
struct cone_twist_constraint_handle { entity_handle entity; };
struct slider_constraint_handle { entity_handle entity; };

// Local anchors are always in the space of the entities.
distance_constraint_handle addDistanceConstraintFromLocalPoints(scene_entity& a, scene_entity& b, vec3 localAnchorA, vec3 localAnchorB, float distance);
distance_constraint_handle addDistanceConstraintFromGlobalPoints(scene_entity& a, scene_entity& b, vec3 globalAnchorA, vec3 globalAnchorB); // Calculates distance from current configuration.

ball_constraint_handle addBallConstraintFromLocalPoints(scene_entity& a, scene_entity& b, vec3 localAnchorA, vec3 localAnchorB);
ball_constraint_handle addBallConstraintFromGlobalPoints(scene_entity& a, scene_entity& b, vec3 globalAnchor); // Calculates local anchors from current configuration.

fixed_constraint_handle addFixedConstraintFromGlobalPoints(scene_entity& a, scene_entity& b, vec3 globalAnchor); // Calculates local anchors from current configuration.

// The min limit is in the range [-pi, 0], the max limit in the range [0, pi]. 
// If the specified values are not in this range, the limits are disabled.
// Limits are specified as allowed deviations from the initial relative rotation.
// Usually the absolute of each limit should be a lot smaller than pi.
hinge_constraint_handle addHingeConstraintFromGlobalPoints(scene_entity& a, scene_entity& b, vec3 globalAnchor, vec3 globalHingeAxis,
	float minLimit = 1.f, float maxLimit = -1.f);

cone_twist_constraint_handle addConeTwistConstraintFromGlobalPoints(scene_entity& a, scene_entity& b, vec3 globalAnchor, vec3 globalAxis, 
	float swingLimit, float twistLimit);

slider_constraint_handle addSliderConstraintFromGlobalPoints(scene_entity& a, scene_entity& b, vec3 globalAnchor, vec3 globalAxis, float minLimit = 1.f, float maxLimit = -1.f);



distance_constraint_handle addConstraint(scene_entity& a, scene_entity& b, const distance_constraint& c);
ball_constraint_handle addConstraint(scene_entity& a, scene_entity& b, const ball_constraint& c);
fixed_constraint_handle addConstraint(scene_entity& a, scene_entity& b, const fixed_constraint& c);
hinge_constraint_handle addConstraint(scene_entity& a, scene_entity& b, const hinge_constraint& c);
cone_twist_constraint_handle addConstraint(scene_entity& a, scene_entity& b, const cone_twist_constraint& c);
slider_constraint_handle addConstraint(scene_entity& a, scene_entity& b, const slider_constraint& c);



distance_constraint& getConstraint(game_scene& scene, distance_constraint_handle handle);
ball_constraint& getConstraint(game_scene& scene, ball_constraint_handle handle);
fixed_constraint& getConstraint(game_scene& scene, fixed_constraint_handle handle);
hinge_constraint& getConstraint(game_scene& scene, hinge_constraint_handle handle);
cone_twist_constraint& getConstraint(game_scene& scene, cone_twist_constraint_handle handle);
slider_constraint& getConstraint(game_scene& scene, slider_constraint_handle handle);

void deleteAllConstraints(game_scene& scene);

void deleteConstraint(game_scene& scene, distance_constraint_handle handle);
void deleteConstraint(game_scene& scene, ball_constraint_handle handle);
void deleteConstraint(game_scene& scene, fixed_constraint_handle handle);
void deleteConstraint(game_scene& scene, hinge_constraint_handle handle);
void deleteConstraint(game_scene& scene, cone_twist_constraint_handle handle);
void deleteConstraint(game_scene& scene, slider_constraint_handle handle);

void deleteAllConstraintsFromEntity(scene_entity& entity);

static scene_entity getOtherEntity(const constraint_entity_reference_component& constraint, scene_entity first)
{
	entity_handle result = (first == constraint.entityA) ? constraint.entityB : constraint.entityA;
	return { result, first.registry };
}


struct collider_entity_iterator
{
	collider_entity_iterator(scene_entity entity)
	{
		if (physics_reference_component* ref = entity.getComponentIfExists<physics_reference_component>())
		{
			firstColliderEntity = { ref->firstColliderEntity, entity.registry };
		}
	}

	struct iterator
	{
		scene_entity entity;

		friend bool operator!=(const iterator& a, const iterator& b) { return a.entity != b.entity; }
		iterator& operator++() { entity = { entity.getComponent<collider_component>().nextEntity, entity.registry }; return *this; }
		scene_entity operator*() { return entity; }
	};

	iterator begin() { return iterator{ firstColliderEntity }; }
	iterator end() { return iterator{ scene_entity{ entity_handle(entt::null), firstColliderEntity.registry } }; }

	scene_entity firstColliderEntity = {};
};

struct collider_component_iterator : collider_entity_iterator
{
	collider_component_iterator(scene_entity entity) : collider_entity_iterator(entity) {}

	struct iterator : collider_entity_iterator::iterator 
	{
		collider_component& operator*() { return entity.getComponent<collider_component>(); }
	};

	iterator begin() { return iterator{ firstColliderEntity }; }
	iterator end() { return iterator{ scene_entity{ entity_handle(entt::null), firstColliderEntity.registry } }; }
};

struct constraint_entity_iterator
{
	constraint_entity_iterator(scene_entity entity)
		: registry(entity.registry)
	{
		if (physics_reference_component* ref = entity.getComponentIfExists<physics_reference_component>())
		{
			firstConstraintEdgeIndex = ref->firstConstraintEdge;
		}
	}

	struct iterator
	{
		uint16 constraintEdgeIndex;
		entt::registry* registry;

		friend bool operator!=(const iterator& a, const iterator& b) { return a.constraintEdgeIndex != b.constraintEdgeIndex; }
		iterator& operator++();
		std::pair<scene_entity, constraint_type> operator*();
	};

	iterator begin() { return iterator{ firstConstraintEdgeIndex, registry }; }
	iterator end() { return iterator{ INVALID_CONSTRAINT_EDGE, registry }; }

	uint16 firstConstraintEdgeIndex = INVALID_CONSTRAINT_EDGE;
	entt::registry* registry;
};



struct contact_info
{
	vec3 point;
	float penetrationDepth; // Positive.
};

struct collision_contact
{
	// Don't change the order here.
	vec3 point;
	float penetrationDepth;
	vec3 normal;
	uint32 friction_restitution; // Packed as 16 bit int each. The packing makes it more convenient for the SIMD code to load the contact data.
};

struct collision_begin_event
{
	scene_entity entityA;
	scene_entity entityB;

	const collider_component& colliderA;
	const collider_component& colliderB;

	vec3 position;
	vec3 normal;
	vec3 relativeVelocity;
};

struct collision_end_event
{
	scene_entity entityA;
	scene_entity entityB;

	const collider_component& colliderA;
	const collider_component& colliderB;
};


typedef std::function<void(const collision_begin_event&)> collision_begin_event_func;
typedef std::function<void(const collision_end_event&)> collision_end_event_func;

struct physics_settings
{
	bool fixedFrameRate = true;
	uint32 frameRate = 120;
	uint32 maxPhysicsIterationsPerFrame = 4;

	uint32 numRigidSolverIterations = 30;

	uint32 numClothVelocityIterations = 0;
	uint32 numClothPositionIterations = 1;
	uint32 numClothDriftIterations = 0;

	bool simdBroadPhase = true;
	bool simdNarrowPhase = true;
	bool simdConstraintSolver = true;

	collision_begin_event_func collisionBeginCallback;
	collision_end_event_func collisionEndCallback;
};



void testPhysicsInteraction(game_scene& scene, ray r, float strength = 1000.f);
void physicsStep(game_scene& scene, memory_arena& arena, float& timer, const physics_settings& settings, float dt);

```

`src/physics/ragdoll.cpp`:

```cpp
#include "pch.h"
#include "ragdoll.h"

#ifndef PHYSICS_ONLY
#include "rendering/pbr.h"
#include "geometry/mesh.h"
#include "geometry/mesh_builder.h"
#endif

void humanoid_ragdoll::initialize(game_scene& scene, vec3 initialHipPosition, float initialRotation)
{
	float scale = 0.42f; // This file is completely hardcoded. I initially screwed up the scaling a bit, so this factor brings everything to the correct scale (and therefore weight).

	bool ragdollKinematic = false;
	float ragdollGravityFactor = 1.f;
	float ragdollDensity = 985.f; // Average density of human body in kg/m3.
	float ragdollFriction = 1.f;

	physics_material material = { physics_material_type_flesh, 0.2f, ragdollFriction, ragdollDensity };

	trs torsoTransform(scale * vec3(0.f, 0.f, 0.f), quat::identity);
	trs headTransform(scale * vec3(0.f, 1.45f, 0.f), quat::identity);
	trs leftUpperArmTransform(scale * vec3(-0.6f, 0.75f, 0.f), quat(vec3(0.f, 0.f, 1.f), deg2rad(-30.f)));
	trs leftLowerArmTransform(scale * vec3(-0.884f, 0.044f, -0.043f), quat(vec3(0.f, 0.f, 1.f), deg2rad(-20.f)));
	trs rightUpperArmTransform(scale * vec3(0.6f, 0.75f, 0.f), quat(vec3(0.f, 0.f, 1.f), deg2rad(30.f)));
	trs rightLowerArmTransform(scale * vec3(0.884f, 0.044f, -0.043f), quat(vec3(0.f, 0.f, 1.f), deg2rad(20.f)));
	trs leftUpperLegTransform(scale * vec3(-0.371f, -0.812f, 0.f), quat(vec3(0.f, 0.f, 1.f), deg2rad(-10.f)));
	trs leftLowerLegTransform(scale * vec3(-0.452f, -1.955f, 0.f), quat(vec3(0.f, 0.f, 1.f), deg2rad(-3.5f)));
	trs leftFootTransform(scale * vec3(-0.498f, -2.585f, -0.18f), quat::identity);
	trs leftToesTransform(scale * vec3(-0.498f, -2.585f, -0.637f), quat::identity);
	trs rightUpperLegTransform(scale * vec3(0.371f, -0.812f, 0.f), quat(vec3(0.f, 0.f, 1.f), deg2rad(10.f)));
	trs rightLowerLegTransform(scale * vec3(0.452f, -1.955f, 0.f), quat(vec3(0.f, 0.f, 1.f), deg2rad(3.5f)));
	trs rightFootTransform(scale * vec3(0.498f, -2.585f, -0.18f), quat::identity);
	trs rightToesTransform(scale * vec3(0.498f, -2.585f, -0.637f), quat::identity);

	torso = scene.createEntity("Torso")
		.addComponent<transform_component>(torsoTransform)
		.addComponent<collider_component>(collider_component::asCapsule({ scale * vec3(-0.2f, 0.f, 0.f),    scale *  vec3(0.2f, 0.f, 0.f),    scale * 0.25f }, material))
		.addComponent<collider_component>(collider_component::asCapsule({ scale * vec3(-0.16f, 0.32f, 0.f), scale *  vec3(0.16f, 0.32f, 0.f), scale * 0.2f }, material))
		.addComponent<collider_component>(collider_component::asCapsule({ scale * vec3(-0.14f, 0.62f, 0.f), scale *  vec3(0.14f, 0.62f, 0.f), scale * 0.22f }, material))
		.addComponent<collider_component>(collider_component::asCapsule({ scale * vec3(-0.14f, 0.92f, 0.f), scale *  vec3(0.14f, 0.92f, 0.f), scale * 0.2f }, material))
		.addComponent<rigid_body_component>(ragdollKinematic, ragdollGravityFactor);

	head = scene.createEntity("Head")
		.addComponent<transform_component>(headTransform)
		.addComponent<collider_component>(collider_component::asCapsule({ scale * vec3(0.f, -0.075f, 0.f), scale * vec3(0.f, 0.075f, 0.f), scale * 0.25f }, material))
		.addComponent<rigid_body_component>(ragdollKinematic, ragdollGravityFactor);

	leftUpperArm = scene.createEntity("Left upper arm")
		.addComponent<transform_component>(leftUpperArmTransform)
		.addComponent<collider_component>(collider_component::asCapsule({ scale * vec3(0.f, -0.2f, 0.f), scale * vec3(0.f, 0.2f, 0.f), scale * 0.15f }, material))
		.addComponent<rigid_body_component>(ragdollKinematic, ragdollGravityFactor);

	leftLowerArm = scene.createEntity("Left lower arm")
		.addComponent<transform_component>(leftLowerArmTransform)
		.addComponent<collider_component>(collider_component::asCapsule({ scale * vec3(0.f, -0.2f, 0.f), scale * vec3(0.f, 0.2f, 0.f), scale * 0.15f }, material))
		.addComponent<rigid_body_component>(ragdollKinematic, ragdollGravityFactor);

	rightUpperArm = scene.createEntity("Right upper arm")
		.addComponent<transform_component>(rightUpperArmTransform)
		.addComponent<collider_component>(collider_component::asCapsule({ scale * vec3(0.f, -0.2f, 0.f), scale * vec3(0.f, 0.2f, 0.f), scale * 0.15f }, material))
		.addComponent<rigid_body_component>(ragdollKinematic, ragdollGravityFactor);

	rightLowerArm = scene.createEntity("Right lower arm")
		.addComponent<transform_component>(rightLowerArmTransform)
		.addComponent<collider_component>(collider_component::asCapsule({ scale * vec3(0.f, -0.2f, 0.f), scale * vec3(0.f, 0.2f, 0.f), scale * 0.15f }, material))
		.addComponent<rigid_body_component>(ragdollKinematic, ragdollGravityFactor);

	leftUpperLeg = scene.createEntity("Left upper leg")
		.addComponent<transform_component>(leftUpperLegTransform)
		.addComponent<collider_component>(collider_component::asCapsule({ scale * vec3(0.f, -0.3f, 0.f), scale * vec3(0.f, 0.3f, 0.f), scale * 0.25f }, material))
		.addComponent<rigid_body_component>(ragdollKinematic, ragdollGravityFactor);

	leftLowerLeg = scene.createEntity("Left lower leg")
		.addComponent<transform_component>(leftLowerLegTransform)
		.addComponent<collider_component>(collider_component::asCapsule({ scale * vec3(0.f, -0.3f, 0.f), scale * vec3(0.f, 0.3f, 0.f), scale * 0.18f }, material))
		.addComponent<rigid_body_component>(ragdollKinematic, ragdollGravityFactor);

	leftFoot = scene.createEntity("Left foot")
		.addComponent<transform_component>(leftFootTransform)
		.addComponent<collider_component>(collider_component::asAABB(bounding_box::fromCenterRadius(scale * vec3(0.f), scale * vec3(0.1587f, 0.1f, 0.3424f)), material))
		.addComponent<rigid_body_component>(ragdollKinematic, ragdollGravityFactor);

	leftToes = scene.createEntity("Left toes")
		.addComponent<transform_component>(leftToesTransform)
		.addComponent<collider_component>(collider_component::asCapsule({ scale * vec3(-0.0587f, 0.f, 0.f), scale * vec3(0.0587f, 0.f, 0.f), scale * 0.1f }, material))
		.addComponent<rigid_body_component>(ragdollKinematic, ragdollGravityFactor);

	rightUpperLeg = scene.createEntity("Right upper leg")
		.addComponent<transform_component>(rightUpperLegTransform)
		.addComponent<collider_component>(collider_component::asCapsule({ scale * vec3(0.f, -0.3f, 0.f), scale * vec3(0.f, 0.3f, 0.f), scale * 0.25f }, material))
		.addComponent<rigid_body_component>(ragdollKinematic, ragdollGravityFactor);

	rightLowerLeg = scene.createEntity("Right lower leg")
		.addComponent<transform_component>(rightLowerLegTransform)
		.addComponent<collider_component>(collider_component::asCapsule({ scale * vec3(0.f, -0.3f, 0.f), scale * vec3(0.f, 0.3f, 0.f), scale * 0.18f }, material))
		.addComponent<rigid_body_component>(ragdollKinematic, ragdollGravityFactor);

	rightFoot = scene.createEntity("Right foot")
		.addComponent<transform_component>(rightFootTransform)
		.addComponent<collider_component>(collider_component::asAABB(bounding_box::fromCenterRadius(scale * vec3(0.f), scale * vec3(0.1587f, 0.1f, 0.3424f)), material))
		.addComponent<rigid_body_component>(ragdollKinematic, ragdollGravityFactor);

	rightToes = scene.createEntity("Right toes")
		.addComponent<transform_component>(rightToesTransform)
		.addComponent<collider_component>(collider_component::asCapsule({ scale * vec3(-0.0587f, 0.f, 0.f), scale * vec3(0.0587f, 0.f, 0.f), scale * 0.1f }, material))
		.addComponent<rigid_body_component>(ragdollKinematic, ragdollGravityFactor);

	neckConstraint = addConeTwistConstraintFromGlobalPoints(torso, head, transformPosition(torsoTransform, scale * vec3(0.f, 1.2f, 0.f)), vec3(0.f, 1.f, 0.f), deg2rad(50.f), deg2rad(90.f));
	leftShoulderConstraint = addConeTwistConstraintFromGlobalPoints(torso, leftUpperArm, transformPosition(torsoTransform, scale * vec3(-0.4f, 1.f, 0.f)), vec3(-1.f, 0.f, 0.f), deg2rad(130.f), deg2rad(90.f));
	leftElbowConstraint = addHingeConstraintFromGlobalPoints(leftUpperArm, leftLowerArm, transformPosition(leftUpperArmTransform, scale * vec3(0.f, -0.42f, 0.f)), normalize(vec3(1.f, 0.f, 1.f)), deg2rad(-5.f), deg2rad(85.f));
	rightShoulderConstraint = addConeTwistConstraintFromGlobalPoints(torso, rightUpperArm, transformPosition(torsoTransform, scale * vec3(0.4f, 1.f, 0.f)), vec3(1.f, 0.f, 0.f), deg2rad(130.f), deg2rad(90.f));
	rightElbowConstraint = addHingeConstraintFromGlobalPoints(rightUpperArm, rightLowerArm, transformPosition(rightUpperArmTransform, scale * vec3(0.f, -0.42f, 0.f)), normalize(vec3(1.f, 0.f, -1.f)), deg2rad(-5.f), deg2rad(85.f));
	
	leftHipConstraint = addConeTwistConstraintFromGlobalPoints(torso, leftUpperLeg, transformPosition(torsoTransform, scale * vec3(-0.3f, -0.25f, 0.f)), transformDirection(leftUpperLegTransform, vec3(0.f, -1.f, 0.f)), -1.f, deg2rad(30.f));
	leftKneeConstraint = addHingeConstraintFromGlobalPoints(leftUpperLeg, leftLowerLeg, transformPosition(leftUpperLegTransform, scale * vec3(0.f, -0.6f, 0.f)), vec3(1.f, 0.f, 0.f), deg2rad(-90.f), deg2rad(5.f));
	leftAnkleConstraint = addConeTwistConstraintFromGlobalPoints(leftLowerLeg, leftFoot, transformPosition(leftLowerLegTransform, scale * vec3(0.f, -0.52f, 0.f)), transformDirection(leftLowerLegTransform, vec3(0.f, -1.f, 0.f)), deg2rad(75.f), deg2rad(20.f));
	leftToesConstraint = addHingeConstraintFromGlobalPoints(leftFoot, leftToes, transformPosition(leftFootTransform, scale * vec3(0.f, 0.f, -0.36f)), vec3(1.f, 0.f, 0.f), deg2rad(-45.f), deg2rad(45.f));

	rightHipConstraint = addConeTwistConstraintFromGlobalPoints(torso, rightUpperLeg, transformPosition(torsoTransform, scale * vec3(0.3f, -0.25f, 0.f)), transformDirection(rightUpperLegTransform, vec3(0.f, -1.f, 0.f)), -1.f, deg2rad(30.f));
	rightKneeConstraint = addHingeConstraintFromGlobalPoints(rightUpperLeg, rightLowerLeg, transformPosition(rightUpperLegTransform, scale * vec3(0.f, -0.6f, 0.f)), vec3(1.f, 0.f, 0.f), deg2rad(-90.f), deg2rad(5.f));
	rightAnkleConstraint = addConeTwistConstraintFromGlobalPoints(rightLowerLeg, rightFoot, transformPosition(rightLowerLegTransform, scale * vec3(0.f, -0.52f, 0.f)), transformDirection(rightLowerLegTransform, vec3(0.f, -1.f, 0.f)), deg2rad(75.f), deg2rad(20.f));
	rightToesConstraint = addHingeConstraintFromGlobalPoints(rightFoot, rightToes, transformPosition(rightFootTransform, scale * vec3(0.f, 0.f, -0.36f)), vec3(1.f, 0.f, 0.f), deg2rad(-45.f), deg2rad(45.f));


	quat rotation(vec3(0.f, 1.f, 0.f), initialRotation);
	for (uint32 i = 0; i < arraysize(bodyParts); ++i)
	{
		transform_component& transform = bodyParts[i].getComponent<transform_component>();
		transform.rotation = rotation * transform.rotation;
		transform.position = rotation * transform.position + initialHipPosition;

		bodyParts[i].getComponent<physics_transform0_component>() = bodyParts[i].getComponent<physics_transform1_component>() = transform;
	}

#if 0
	float totalMass = 1.f / torso.getComponent<rigid_body_component>().invMass +
		1.f / head.getComponent<rigid_body_component>().invMass +
		1.f / leftUpperArm.getComponent<rigid_body_component>().invMass +
		1.f / leftLowerArm.getComponent<rigid_body_component>().invMass +
		1.f / rightUpperArm.getComponent<rigid_body_component>().invMass +
		1.f / rightLowerArm.getComponent<rigid_body_component>().invMass +
		1.f / leftUpperLeg.getComponent<rigid_body_component>().invMass +
		1.f / leftLowerLeg.getComponent<rigid_body_component>().invMass +
		1.f / leftFoot.getComponent<rigid_body_component>().invMass +
		1.f / leftToes.getComponent<rigid_body_component>().invMass +
		1.f / rightUpperLeg.getComponent<rigid_body_component>().invMass +
		1.f / rightLowerLeg.getComponent<rigid_body_component>().invMass +
		1.f / rightFoot.getComponent<rigid_body_component>().invMass +
		1.f / rightToes.getComponent<rigid_body_component>().invMass;

	std::cout << totalMass << '\n';
#endif


	torsoParent = {};
	headParent = torso;
	leftUpperArmParent = torso;
	leftLowerArmParent = leftUpperArm;
	rightUpperArmParent = torso;
	rightLowerArmParent = rightUpperArm;
	leftUpperLegParent = torso;
	leftLowerLegParent = leftUpperLeg;
	leftFootParent = leftLowerLeg;
	leftToesParent = leftFoot;
	rightUpperLegParent = torso;
	rightLowerLegParent = rightUpperLeg;
	rightFootParent = rightLowerLeg;
	rightToesParent = rightFoot;


	// Graphics.


#ifndef PHYSICS_ONLY

	mesh_builder builder(mesh_creation_flags_with_positions | mesh_creation_flags_with_uvs | mesh_creation_flags_with_normals | mesh_creation_flags_with_tangents);

	pbr_material_desc desc;
	desc.albedoTint = vec4(161.f, 102.f, 94.f, 255.f) / 255.f;

	auto ragdollMaterial = createPBRMaterial(desc);
	//auto ragdollMaterial = lollipopMaterial;

	auto ragdollTorsoMesh = make_ref<multi_mesh>();
	{
		builder.pushCapsule(capsule_mesh_desc(scale * vec3(-0.2f, 0.f, 0.f), scale * vec3(0.2f, 0.f, 0.f), scale * 0.25f));
		builder.pushCapsule(capsule_mesh_desc(scale * vec3(-0.16f, 0.32f, 0.f), scale * vec3(0.16f, 0.32f, 0.f), scale * 0.2f));
		builder.pushCapsule(capsule_mesh_desc(scale * vec3(-0.14f, 0.62f, 0.f), scale * vec3(0.14f, 0.62f, 0.f), scale * 0.22f));
		builder.pushCapsule(capsule_mesh_desc(scale * vec3(-0.14f, 0.92f, 0.f), scale * vec3(0.14f, 0.92f, 0.f), scale * 0.2f));
		ragdollTorsoMesh->submeshes.push_back({ builder.endSubmesh(), {}, trs::identity, ragdollMaterial });
	}
	
	auto ragdollHeadMesh = make_ref<multi_mesh>();
	{
		builder.pushCapsule(capsule_mesh_desc(scale * vec3(0.f, -0.075f, 0.f), scale * vec3(0.f, 0.075f, 0.f), scale * 0.25f));
		ragdollHeadMesh->submeshes.push_back({ builder.endSubmesh(), {}, trs::identity, ragdollMaterial });
	}

	auto ragdollArmMesh = make_ref<multi_mesh>();
	{
		builder.pushCapsule(capsule_mesh_desc(scale * vec3(0.f, -0.2f, 0.f), scale * vec3(0.f, 0.2f, 0.f), scale * 0.15f));
		ragdollArmMesh->submeshes.push_back({ builder.endSubmesh(), {}, trs::identity, ragdollMaterial });
	}

	auto ragdollUpperLegMesh = make_ref<multi_mesh>();
	{
		builder.pushCapsule(capsule_mesh_desc(scale * vec3(0.f, -0.3f, 0.f), scale * vec3(0.f, 0.3f, 0.f), scale * 0.25f));
		ragdollUpperLegMesh->submeshes.push_back({ builder.endSubmesh(), {}, trs::identity, ragdollMaterial });
	}

	auto ragdollLowerLegMesh = make_ref<multi_mesh>();
	{
		builder.pushCapsule(capsule_mesh_desc(scale * vec3(0.f, -0.3f, 0.f), scale * vec3(0.f, 0.3f, 0.f), scale * 0.18f));
		ragdollLowerLegMesh->submeshes.push_back({ builder.endSubmesh(), {}, trs::identity, ragdollMaterial });
	}

	auto ragdollFootMesh = make_ref<multi_mesh>();
	{
		builder.pushBox(box_mesh_desc{ vec3(0.f), scale * vec3(0.1587f, 0.1f, 0.3424f) });
		ragdollFootMesh->submeshes.push_back({ builder.endSubmesh(), {}, trs::identity, ragdollMaterial });
	}

	auto ragdollToesMesh = make_ref<multi_mesh>();
	{
		builder.pushCapsule(capsule_mesh_desc(scale * vec3(-0.0587f, 0.f, 0.f), scale * vec3(0.0587f, 0.f, 0.f), scale * 0.1f));
		ragdollToesMesh->submeshes.push_back({ builder.endSubmesh(), {}, trs::identity, ragdollMaterial });
	}

	torso.addComponent<mesh_component>(ragdollTorsoMesh);
	head.addComponent<mesh_component>(ragdollHeadMesh);
	leftUpperArm.addComponent<mesh_component>(ragdollArmMesh);
	leftLowerArm.addComponent<mesh_component>(ragdollArmMesh);
	rightUpperArm.addComponent<mesh_component>(ragdollArmMesh);
	rightLowerArm.addComponent<mesh_component>(ragdollArmMesh);
	leftUpperLeg.addComponent<mesh_component>(ragdollUpperLegMesh);
	leftLowerLeg.addComponent<mesh_component>(ragdollLowerLegMesh);
	leftFoot.addComponent<mesh_component>(ragdollFootMesh);
	leftToes.addComponent<mesh_component>(ragdollToesMesh);
	rightUpperLeg.addComponent<mesh_component>(ragdollUpperLegMesh);
	rightLowerLeg.addComponent<mesh_component>(ragdollLowerLegMesh);
	rightFoot.addComponent<mesh_component>(ragdollFootMesh);
	rightToes.addComponent<mesh_component>(ragdollToesMesh);

	ragdollTorsoMesh->mesh =
		ragdollHeadMesh->mesh =
		ragdollArmMesh->mesh =
		ragdollUpperLegMesh->mesh =
		ragdollLowerLegMesh->mesh =
		ragdollFootMesh->mesh =
		ragdollToesMesh->mesh =
		builder.createDXMesh();

#endif
}

humanoid_ragdoll humanoid_ragdoll::create(game_scene& scene, vec3 initialHipPosition, float initialRotation)
{
	humanoid_ragdoll ragdoll;
	ragdoll.initialize(scene, initialHipPosition, initialRotation);
	return ragdoll;
}

```

`src/physics/ragdoll.h`:

```h
#pragma once

#include "physics.h"
#include "scene/scene.h"

struct humanoid_ragdoll
{
	humanoid_ragdoll() {}

	void initialize(game_scene& scene, vec3 initialHipPosition, float initialRotation = 0.f);
	static humanoid_ragdoll create(game_scene& scene, vec3 initialHipPosition, float initialRotation = 0.f);

	union
	{
		struct
		{
			scene_entity torso;
			scene_entity head;
			scene_entity leftUpperArm;
			scene_entity leftLowerArm;
			scene_entity rightUpperArm;
			scene_entity rightLowerArm;
			scene_entity leftUpperLeg;
			scene_entity leftLowerLeg;
			scene_entity leftFoot;
			scene_entity leftToes;
			scene_entity rightUpperLeg;
			scene_entity rightLowerLeg;
			scene_entity rightFoot;
			scene_entity rightToes;
		};
		scene_entity bodyParts[14];
	};

	union
	{
		struct
		{
			scene_entity torsoParent;
			scene_entity headParent;
			scene_entity leftUpperArmParent;
			scene_entity leftLowerArmParent;
			scene_entity rightUpperArmParent;
			scene_entity rightLowerArmParent;
			scene_entity leftUpperLegParent;
			scene_entity leftLowerLegParent;
			scene_entity leftFootParent;
			scene_entity leftToesParent;
			scene_entity rightUpperLegParent;
			scene_entity rightLowerLegParent;
			scene_entity rightFootParent;
			scene_entity rightToesParent;
		};
		scene_entity bodyPartParents[14];
	};

	union
	{
		struct
		{
			cone_twist_constraint_handle neckConstraint;
			cone_twist_constraint_handle leftShoulderConstraint;
			cone_twist_constraint_handle rightShoulderConstraint;
			cone_twist_constraint_handle leftHipConstraint;
			cone_twist_constraint_handle leftAnkleConstraint;
			cone_twist_constraint_handle rightHipConstraint;
			cone_twist_constraint_handle rightAnkleConstraint;

			hinge_constraint_handle leftElbowConstraint;
			hinge_constraint_handle rightElbowConstraint;
			hinge_constraint_handle leftKneeConstraint;
			hinge_constraint_handle leftToesConstraint;
			hinge_constraint_handle rightKneeConstraint;
			hinge_constraint_handle rightToesConstraint;
		};
		struct
		{
			cone_twist_constraint_handle coneTwistConstraints[7];
			hinge_constraint_handle hingeConstraints[6];
		};
	};
};

```

`src/physics/rigid_body.cpp`:

```cpp
#include "pch.h"
#include "rigid_body.h"
#include "physics.h"


rigid_body_component::rigid_body_component(bool kinematic, float gravityFactor, float linearDamping, float angularDamping)
{
	if (kinematic)
	{
		invMass = 0.f;
		invInertia = mat3::zero;
	}
	else
	{
		invMass = 1.f;
		invInertia = mat3::identity;
	}

	this->gravityFactor = gravityFactor;
	this->linearDamping = linearDamping;
	this->angularDamping = angularDamping;
	this->localCOGPosition = vec3(0.f);
	this->linearVelocity = vec3(0.f);
	this->angularVelocity = vec3(0.f);
	this->forceAccumulator = vec3(0.f);
	this->torqueAccumulator = vec3(0.f);
}

void rigid_body_component::recalculateProperties(entt::registry* registry, const physics_reference_component& reference)
{
	if (invMass == 0.f)
	{
		return; // Kinematic.
	}

	uint32 numColliders = reference.numColliders;
	if (!numColliders)
	{
		return;
	}

	physics_properties* properties = (physics_properties*)alloca(numColliders * (sizeof(physics_properties)));

	uint32 i = 0;

	scene_entity colliderEntity = { reference.firstColliderEntity, registry };
	while (colliderEntity)
	{
		collider_component& collider = colliderEntity.getComponent<collider_component>();
		properties[i++] = collider.calculatePhysicsProperties();
		colliderEntity = { collider.nextEntity, registry };
	}

	ASSERT(i == numColliders);

	mat3 inertia = mat3::zero;
	vec3 cog(0.f);
	float mass = 0.f;

	for (uint32 i = 0; i < numColliders; ++i)
	{
		mass += properties[i].mass;
		cog += properties[i].cog * properties[i].mass;
	}

	invMass = 1.f / mass;
	localCOGPosition = cog = cog * invMass; // TODO: Update linear velocity, since thats given at the COG.

	// Combine inertia tensors: https://pybullet.org/Bullet/phpBB3/viewtopic.php?t=246
	// This assumes that all shapes have the same orientation, which is true in our case, since all shapes are given 
	// in the entity's local coordinate system.
	for (uint32 i = 0; i < numColliders; ++i)
	{
		vec3& localCOG = properties[i].cog;
		mat3& localInertia = properties[i].inertia;
		vec3 r = localCOG - cog;
		inertia += localInertia + (dot(r, r) * mat3::identity - outerProduct(r, r)) * properties[i].mass;
	}

	invInertia = invert(inertia);
}

vec3 rigid_body_component::getGlobalCOGPosition(const trs& transform) const
{
	return transform.position + transform.rotation * localCOGPosition;
}

vec3 rigid_body_component::getGlobalPointVelocity(const trs& transform, vec3 localP) const
{
	vec3 globalP = transformPosition(transform, localP);
	vec3 globalCOG = getGlobalCOGPosition(transform);
	return linearVelocity + cross(angularVelocity, globalP - globalCOG);
}

void rigid_body_component::applyGravityAndIntegrateForces(rigid_body_global_state& global, const trs& transform, float dt)
{
	global.rotation = transform.rotation;
	global.position = transform.position + transform.rotation * localCOGPosition;

	mat3 rot = quaternionToMat3(global.rotation);
	global.invInertia = rot * invInertia * transpose(rot);
	global.invMass = invMass;


	if (invMass > 0.f)
	{
		forceAccumulator.y += (GRAVITY / invMass * gravityFactor);
	}

	vec3 linearAcceleration = forceAccumulator * invMass;
	vec3 angularAcceleration = global.invInertia * torqueAccumulator;

	// Semi-implicit Euler integration.
	linearVelocity += linearAcceleration * dt;
	angularVelocity += angularAcceleration * dt;

	linearVelocity *= 1.f / (1.f + dt * linearDamping);
	angularVelocity *= 1.f / (1.f + dt * angularDamping);


	global.linearVelocity = linearVelocity;
	global.angularVelocity = angularVelocity;
	global.localCOGPosition = localCOGPosition;
}

void rigid_body_component::integrateVelocity(const rigid_body_global_state& global, trs& transform, float dt)
{
	linearVelocity = global.linearVelocity;
	angularVelocity = global.angularVelocity;

	quat deltaRot(0.5f * angularVelocity.x, 0.5f * angularVelocity.y, 0.5f * angularVelocity.z, 0.f);
	deltaRot = deltaRot * global.rotation;

	quat rotation = normalize(global.rotation + (deltaRot * dt));
	vec3 position = global.position + linearVelocity * dt;

	forceAccumulator = vec3(0.f, 0.f, 0.f);
	torqueAccumulator = vec3(0.f, 0.f, 0.f);

	transform.rotation = rotation;
	transform.position = position - rotation * localCOGPosition;
}

```

`src/physics/rigid_body.h`:

```h
#pragma once

#include "core/math.h"
#include "scene/scene.h"

struct rigid_body_global_state
{
	// Don't change the order here. It's currently required by the SIMD code.
	quat rotation;
	vec3 localCOGPosition;
	vec3 position;
	mat3 invInertia;
	float invMass;
	vec3 linearVelocity;
	vec3 angularVelocity;
};

struct rigid_body_component
{
	rigid_body_component() : rigid_body_component(true, 1.f) {}
	rigid_body_component(bool kinematic, float gravityFactor = 1.f, float linearDamping = 0.4f, float angularDamping = 0.4f);
	void recalculateProperties(entt::registry* registry, const struct physics_reference_component& reference);
	vec3 getGlobalCOGPosition(const trs& transform) const;
	vec3 getGlobalPointVelocity(const trs& transform, vec3 localP) const;


	void applyGravityAndIntegrateForces(rigid_body_global_state& global, const trs& transform, float dt);
	void integrateVelocity(const rigid_body_global_state& global, trs& transform, float dt);


	// In entity's local space.
	vec3 localCOGPosition;
	float invMass;
	mat3 invInertia;

	float gravityFactor;
	float linearDamping;
	float angularDamping;

	// In global space.
	vec3 linearVelocity;
	vec3 angularVelocity;

	vec3 forceAccumulator;
	vec3 torqueAccumulator;
};

struct physics_transform0_component : trs 
{
	physics_transform0_component() {}
	physics_transform0_component(const trs& t) : trs(t) {}
};

struct physics_transform1_component : trs
{
	physics_transform1_component() {}
	physics_transform1_component(const trs& t) : trs(t) {}
};

```

`src/physics/vehicle.cpp`:

```cpp
#include "pch.h"
#include "vehicle.h"


struct gear_description
{
	float height; 
	float cylinderRadius;
	float cylinderInnerRadius;
	uint32 numTeeth; 
	float toothLength; 
	float toothWidth;

	float friction; 
	float density;
};

struct wheel_description
{
	float height;
	float radius;
	float innerRadius;

	float friction;
	float density;
};

enum attachment_type
{
	attachment_type_none,
	attachment_type_gear,
	attachment_type_wheel,
};

struct axis_attachment
{
	attachment_type type;
	float rodLength;
	float rodThickness;

	union
	{
		gear_description gear;
		wheel_description wheel;
	};

	axis_attachment(float rodLength, float rodThickness)
		: type(attachment_type_none), rodLength(rodLength), rodThickness(rodThickness) {}
	axis_attachment(float rodLength, float rodThickness, gear_description gear)
		: type(attachment_type_gear), rodLength(rodLength), rodThickness(rodThickness), gear(gear) {}
	axis_attachment(float rodLength, float rodThickness, wheel_description wheel)
		: type(attachment_type_wheel), rodLength(rodLength), rodThickness(rodThickness), wheel(wheel) {}
};

static void attach(mesh_builder& builder, ref<pbr_material> material, scene_entity axis, axis_attachment& attachment, float sign)
{
	float rodOffset = attachment.rodLength * sign;

	switch (attachment.type)
	{
		case attachment_type_gear: 
		{
			gear_description desc = attachment.gear;

			if (desc.cylinderInnerRadius > 0.f)
			{
				hollow_cylinder_mesh_desc m;
				m.center = vec3(0.f, rodOffset, 0.f);
				m.height = desc.height;
				m.radius = desc.cylinderRadius;
				m.innerRadius = desc.cylinderInnerRadius;
				m.slices = 21;

				builder.pushHollowCylinder(m);
			}
			else
			{
				cylinder_mesh_desc m;
				m.center = vec3(0.f, rodOffset, 0.f);
				m.height = desc.height;
				m.radius = desc.cylinderRadius;
				m.slices = 21;

				builder.pushCylinder(m);
			}

			for (uint32 i = 0; i < desc.numTeeth; ++i)
			{
				float angle = i * M_TAU / desc.numTeeth;
				quat localRotation(vec3(0.f, 1.f, 0.f), angle);
				vec3 center = localRotation * vec3(desc.cylinderRadius + desc.toothLength * 0.5f, 0.f, 0.f);
				vec3 radius(desc.toothLength * 0.5f, desc.height * 0.5f, desc.toothWidth * 0.5f);
				
				capsule_mesh_desc m;
				m.center = center + vec3(0.f, rodOffset, 0.f);
				m.height = desc.toothLength;
				m.radius = desc.toothWidth * 0.5f;
				m.rotation = localRotation * quat(vec3(0.f, 0.f, 1.f), deg2rad(90.f));
				builder.pushCapsule(m);

				bounding_capsule capsule;
				capsule.positionA = center + vec3(0.f, rodOffset, 0.f) - localRotation * vec3(desc.toothLength * 0.5f, 0.f, 0.f);
				capsule.positionB = center + vec3(0.f, rodOffset, 0.f) + localRotation * vec3(desc.toothLength * 0.5f, 0.f, 0.f);

				capsule.radius = desc.toothWidth * 0.5f;

				axis.addComponent<collider_component>(collider_component::asCapsule(capsule, { physics_material_type_wood, 0.2f, desc.friction, desc.density }));
			}
		} break;

		case attachment_type_wheel:
		{
			wheel_description desc = attachment.wheel;

			hollow_cylinder_mesh_desc m;
			m.center = vec3(0.f, rodOffset, 0.f);
			m.height = desc.height;
			m.radius = desc.radius;
			m.innerRadius = desc.innerRadius;
			m.slices = 21;
			builder.pushHollowCylinder(m);

			bounding_cylinder cylinder;
			cylinder.positionA = vec3(0.f, rodOffset - desc.height * 0.5f, 0.f);
			cylinder.positionB = vec3(0.f, rodOffset + desc.height * 0.5f, 0.f);
			cylinder.radius = desc.radius;
			
			axis.addComponent<collider_component>(collider_component::asCylinder(cylinder, { physics_material_type_wood, 0.2f, desc.friction, desc.density }));
		} break;
	}

	if (attachment.rodLength > 0.f)
	{
		box_mesh_desc m;
		m.radius = vec3(attachment.rodThickness * 0.5f, attachment.rodLength * 0.5f, attachment.rodThickness * 0.5f);
		m.center = vec3(0.f, rodOffset * 0.5f, 0.f);
		builder.pushBox(m);
	}
}

static scene_entity createAxis(game_scene& scene, mesh_builder& builder, ref<pbr_material> material,
	vec3 position, quat rotation, gear_description desc, axis_attachment* firstAttachment = 0, axis_attachment* secondAttachment = 0)
{
	scene_entity axis = scene.createEntity("Axis")
		.addComponent<transform_component>(position, rotation);

	auto mesh = make_ref<multi_mesh>();

	axis_attachment centerGearAttachment(0.f, 0.f, desc);
	attach(builder, material, axis, centerGearAttachment, 1.f);

	if (firstAttachment)
	{
		attach(builder, material, axis, *firstAttachment, 1.f);

	}
	if (secondAttachment)
	{
		attach(builder, material, axis, *secondAttachment, -1.f);
	}

	mesh->submeshes.push_back({ builder.endSubmesh(), {}, trs::identity, material });

	axis.addComponent<mesh_component>(mesh);
	axis.addComponent<rigid_body_component>(false);

	return axis;
}

static scene_entity createGearAxis(game_scene& scene, mesh_builder& builder, ref<pbr_material> material,
	vec3 position, quat rotation, float length, uint32 numTeeth, float toothLength, float toothWidth, 
	float friction, float density)
{
	scene_entity axis = scene.createEntity("Gear Axis")
		.addComponent<transform_component>(position, rotation);

	auto mesh = make_ref<multi_mesh>();

	box_mesh_desc m;
	m.radius = vec3(length * 0.5f, toothWidth * 0.5f, toothWidth * 0.5f);
	builder.pushBox(m);


	float distance = length - toothWidth;
	float stride = distance / (numTeeth - 1);

	float leftOffset = -0.5f * length + 0.5f * toothWidth;

	for (uint32 i = 0; i < numTeeth; ++i)
	{
		float x = leftOffset + i * stride;

		vec3 center(x, toothWidth * 0.5f, 0.f);

		bounding_capsule capsule;
		capsule.positionA = center + vec3(0.f, toothLength * 0.5f, 0.f);
		capsule.positionB = center - vec3(0.f, toothLength * 0.5f, 0.f);
		capsule.radius = toothWidth * 0.5f;

		axis.addComponent<collider_component>(collider_component::asCapsule(capsule, { physics_material_type_wood, 0.2f, friction, density }));

		capsule_mesh_desc m;
		m.center = center;
		m.height = toothLength;
		m.radius = toothWidth * 0.5f;
		builder.pushCapsule(m);
	}

	axis.addComponent<mesh_component>(mesh);
	axis.addComponent<rigid_body_component>(false);

	mesh->submeshes.push_back({ builder.endSubmesh(), {}, trs::identity, material });

	return axis;
}

static scene_entity createWheel(game_scene& scene, mesh_builder& builder, ref<pbr_material> material,
	vec3 position, quat rotation, wheel_description desc)
{
	scene_entity result = scene.createEntity("Wheel")
		.addComponent<transform_component>(position, rotation);

	auto mesh = make_ref<multi_mesh>();

	hollow_cylinder_mesh_desc m;
	m.height = desc.height;
	m.radius = desc.radius;
	m.innerRadius = desc.innerRadius;
	m.slices = 21;
	builder.pushHollowCylinder(m);

	bounding_cylinder cylinder;
	cylinder.positionA = vec3(0.f, -desc.height * 0.5f, 0.f);
	cylinder.positionB = vec3(0.f, desc.height * 0.5f, 0.f);
	cylinder.radius = desc.radius;

	result.addComponent<collider_component>(collider_component::asCylinder(cylinder, { physics_material_type_wood, 0.2f, desc.friction, desc.density }));

	result.addComponent<mesh_component>(mesh);
	result.addComponent<rigid_body_component>(false);

	mesh->submeshes.push_back({ builder.endSubmesh(), {}, trs::identity, material });

	return result;
}

static scene_entity createWheelSuspension(game_scene& scene, mesh_builder& builder, ref<pbr_material> material,
	vec3 position, quat rotation, float axisLength, float thickness, bool right)
{
	scene_entity result = scene.createEntity("Wheel suspension")
		.addComponent<transform_component>(position, rotation);

	auto mesh = make_ref<multi_mesh>();

	float xSign = right ? 1.f : -1.f;

	cylinder_mesh_desc m;
	m.height = axisLength;
	m.center = vec3(axisLength * 0.5f * xSign, 0.f, 0.f);
	m.radius = thickness * 0.5f;
	m.rotation = quat(vec3(0.f, 0.f, 1.f), deg2rad(90.f));
	builder.pushCylinder(m);

	m.center = vec3(0.f, 0.f, axisLength * 0.5f);
	m.rotation = quat(vec3(1.f, 0.f, 0.f), deg2rad(90.f));
	builder.pushCylinder(m);

	// These rigid bodies don't have colliders, since they penetrate the wheels.

	result.addComponent<mesh_component>(mesh);
	result.addComponent<rigid_body_component>(false);

	mesh->submeshes.push_back({ builder.endSubmesh(), {}, trs::identity, material });

	return result;
}

static scene_entity createRod(game_scene& scene, mesh_builder& builder, ref<pbr_material> material, 
	vec3 from, vec3 to, float thickness)
{
	vec3 position = (from + to) * 0.5f;
	vec3 axis = normalize(to - from);
	float len = length(to - from);
	quat rotation = rotateFromTo(vec3(0.f, 1.f, 0.f), axis);

	scene_entity result = scene.createEntity("Rod")
		.addComponent<transform_component>(position, rotation);

	auto mesh = make_ref<multi_mesh>();

	box_mesh_desc m;
	m.radius = vec3(thickness * 0.5f, len * 0.5f, thickness * 0.5f);
	builder.pushBox(m);

	result.addComponent<mesh_component>(mesh);
	result.addComponent<rigid_body_component>(false);

	mesh->submeshes.push_back({ builder.endSubmesh(), {}, trs::identity, material });

	return result;
}

void vehicle::initialize(game_scene& scene, vec3 initialMotorPosition, float initialRotation)
{
	float density = 2000.f;


	mesh_builder builder;


	auto material = createPBRMaterial({ "assets/desert/textures/WoodenCrate2_Albedo.png", "assets/desert/textures/WoodenCrate2_Normal.png" });


	motor = scene.createEntity("Motor")
		.addComponent<transform_component>(vec3(0.f, 0.f, 0.f), quat::identity)
		.addComponent<collider_component>(collider_component::asAABB(bounding_box::fromCenterRadius(vec3(0.f), vec3(0.6f, 0.1f, 1.f)), { physics_material_type_wood, 0.2f, 0.f, density }))
		.addComponent<rigid_body_component>(false);

	{	
		auto motorMesh = make_ref<multi_mesh>();

		box_mesh_desc m;
		m.radius = vec3(0.6f, 0.1f, 1.f);
		builder.pushBox(m);

		motorMesh->submeshes.push_back({ builder.endSubmesh(), {}, trs::identity, material });

		motor.addComponent<mesh_component>(motorMesh);
	}

	gear_description motorGearDesc;
	motorGearDesc.height = 0.1f;
	motorGearDesc.cylinderRadius = 0.2f;
	motorGearDesc.cylinderInnerRadius = 0.f;
	motorGearDesc.numTeeth = 8;
	motorGearDesc.toothLength = 0.07f;
	motorGearDesc.toothWidth = 0.1f;
	motorGearDesc.friction = 0.f;
	motorGearDesc.density = density;

	float rodThickness = 0.05f;

	gear_description steeringWheelDesc;
	steeringWheelDesc.height = 0.1f;
	steeringWheelDesc.cylinderRadius = 0.4f;
	steeringWheelDesc.cylinderInnerRadius = 0.2f;
	steeringWheelDesc.numTeeth = 0;
	steeringWheelDesc.toothLength = 0.07f;
	steeringWheelDesc.toothWidth = 0.1f;
	steeringWheelDesc.friction = 0.f;
	steeringWheelDesc.density = density;

	wheel_description wheelDesc;
	wheelDesc.height = 0.3f;
	wheelDesc.radius = 0.7f;
	wheelDesc.innerRadius = wheelDesc.radius * 0.4f;
	wheelDesc.friction = 1.f;
	wheelDesc.density = 50.f;


	float motorGearY = 0.25f;
	float gearOffset = 0.26f;

	// Motor gear.
	motorGear = createAxis(scene, builder, material, vec3(0.f, motorGearY, 0.f), quat::identity, motorGearDesc);
	auto motorConstraintHandle = addHingeConstraintFromGlobalPoints(motor, motorGear, vec3(0.f, motorGearY, 0.f), vec3(0.f, 1.f, 0.f));

	auto& motorConstraint = getConstraint(scene, motorConstraintHandle);
	motorConstraint.maxMotorTorque = 500.f;
	motorConstraint.motorVelocity = 0.f;

	// Drive axis.
	float driveAxisLength = 4.5f;
	axis_attachment driveAxisAttachment(driveAxisLength * 0.57f - 1.1f, rodThickness, motorGearDesc);
	driveAxis = createAxis(scene, builder, material, vec3(0.f, motorGearY + gearOffset, gearOffset), quat(vec3(-1.f, 0.f, 0.f), deg2rad(90.f)),
		motorGearDesc, 0, &driveAxisAttachment);
	addHingeConstraintFromGlobalPoints(motor, driveAxis, vec3(0.f, motorGearY + gearOffset, gearOffset), vec3(0.f, 0.f, 1.f));

	// Front axis.
	float axisLength = 1.5f;
	float suspensionLength = 0.4f;

	float frontAxisOffsetZ = -driveAxisLength * 0.5f + gearOffset * 2.f;
	vec3 frontAxisPos(0.f, motorGearY + gearOffset, frontAxisOffsetZ);
	frontAxis = createRod(scene, builder, material, frontAxisPos + vec3(axisLength, 0.f, 0.f), frontAxisPos - vec3(axisLength, 0.f, 0.f), 0.05f);
	addFixedConstraintFromGlobalPoints(motor, frontAxis, frontAxisPos);

	// Steering wheel.
	axis_attachment steeringWheelAttachment(2.f, rodThickness, motorGearDesc);
	quat steeringWheelRot(vec3(-1.f, 0.f, 0.f), deg2rad(-80.f));
	vec3 steeringWheelPos(0.f, 1.12f, 0.81f);
	steeringWheel = createAxis(scene, builder, material, steeringWheelPos,
		steeringWheelRot, steeringWheelDesc, 0, &steeringWheelAttachment);
	auto steeringWheelConstraintHandle = addHingeConstraintFromGlobalPoints(motor, steeringWheel, steeringWheelPos, steeringWheelRot * vec3(0.f, -1.f, 0.f));

	auto& steeringWheelConstraint = getConstraint(scene, steeringWheelConstraintHandle);
	steeringWheelConstraint.motorType = constraint_position_motor;
	steeringWheelConstraint.maxMotorTorque = 1000.f;
	steeringWheelConstraint.motorTargetAngle = 0.f;

	// Steering axis.
	vec3 steeringAxisPos(0.f, motorGearY + gearOffset + 0.06f, frontAxisOffsetZ + 0.49f);
	float steeringAxisLength = axisLength * 1.05f;
	steeringAxis = createGearAxis(scene, builder, material, steeringAxisPos, steeringWheelRot, steeringAxisLength, 8,
		motorGearDesc.toothLength, motorGearDesc.toothWidth, motorGearDesc.friction, motorGearDesc.density);
	addSliderConstraintFromGlobalPoints(motor, steeringAxis, steeringAxisPos, vec3(1.f, 0.f, 0.f), -4.f, 4.f);

	vec3 leftSteeringAxisAttachmentPos = steeringAxisPos - vec3(steeringAxisLength * 0.5f, 0.f, 0.f);
	vec3 rightSteeringAxisAttachmentPos = steeringAxisPos + vec3(steeringAxisLength * 0.5f, 0.f, 0.f);

	// Left wheel suspension.
	vec3 leftWheelSuspensionPos = frontAxisPos - vec3(axisLength, 0.f, 0.f);
	vec3 leftWheelSuspensionAttachmentPos = leftWheelSuspensionPos + vec3(0.f, 0.f, suspensionLength);
	leftWheelSuspension = createWheelSuspension(scene, builder, material, leftWheelSuspensionPos, quat::identity, suspensionLength, 0.1f, false);
	addHingeConstraintFromGlobalPoints(motor, leftWheelSuspension, leftWheelSuspensionPos, vec3(0.f, 1.f, 0.f), deg2rad(-45.f), deg2rad(45.f));

	// Right wheel suspension.
	vec3 rightWheelSuspensionPos = frontAxisPos + vec3(axisLength, 0.f, 0.f);
	vec3 rightWheelSuspensionAttachmentPos = rightWheelSuspensionPos + vec3(0.f, 0.f, suspensionLength);
	rightWheelSuspension = createWheelSuspension(scene, builder, material, rightWheelSuspensionPos, quat::identity, suspensionLength, 0.1f, true);
	addHingeConstraintFromGlobalPoints(motor, rightWheelSuspension, rightWheelSuspensionPos, vec3(0.f, 1.f, 0.f), deg2rad(-45.f), deg2rad(45.f));


	// Left front wheel.
	vec3 leftFrontWheelPos = leftWheelSuspensionPos - vec3(suspensionLength * 0.5f, 0.f, 0.f);
	leftFrontWheel = createWheel(scene, builder, material, leftFrontWheelPos, quat(vec3(0.f, 0.f, 1.f), deg2rad(90.f)), wheelDesc);

	// Right front wheel.
	vec3 rightFrontWheelPos = rightWheelSuspensionPos + vec3(suspensionLength * 0.5f, 0.f, 0.f);
	rightFrontWheel = createWheel(scene, builder, material, rightFrontWheelPos, quat(vec3(0.f, 0.f, 1.f), deg2rad(90.f)), wheelDesc);

	addHingeConstraintFromGlobalPoints(leftFrontWheel, leftWheelSuspension, leftFrontWheelPos, vec3(1.f, 0.f, 0.f));
	addHingeConstraintFromGlobalPoints(rightFrontWheel, rightWheelSuspension, rightFrontWheelPos, vec3(1.f, 0.f, 0.f));


	leftWheelArm = createRod(scene, builder, material, leftSteeringAxisAttachmentPos, leftWheelSuspensionAttachmentPos, 0.05f);
	rightWheelArm = createRod(scene, builder, material, rightSteeringAxisAttachmentPos, rightWheelSuspensionAttachmentPos, 0.05f);

	addBallConstraintFromGlobalPoints(leftWheelSuspension, leftWheelArm, leftWheelSuspensionAttachmentPos);
	addBallConstraintFromGlobalPoints(steeringAxis, leftWheelArm, leftSteeringAxisAttachmentPos);

	addBallConstraintFromGlobalPoints(rightWheelSuspension, rightWheelArm, rightWheelSuspensionAttachmentPos);
	addBallConstraintFromGlobalPoints(steeringAxis, rightWheelArm, rightSteeringAxisAttachmentPos);





	gear_description rearAxisGearDesc = motorGearDesc;
	rearAxisGearDesc.cylinderRadius = 0.5f;
	rearAxisGearDesc.cylinderInnerRadius = 0.4f;
	rearAxisGearDesc.numTeeth = 17;


	// Rear axis.
	float rearAxisOffsetZ = driveAxisLength * 0.505f;
	float rearAxisOffsetX = -gearOffset;
	differentialSunGear = createAxis(scene, builder, material, vec3(rearAxisOffsetX, motorGearY + gearOffset, rearAxisOffsetZ), quat(vec3(0.f, 0.f, -1.f), deg2rad(90.f)), rearAxisGearDesc);
	addHingeConstraintFromGlobalPoints(motor, differentialSunGear, vec3(rearAxisOffsetX, motorGearY + gearOffset, rearAxisOffsetZ), vec3(1.f, 0.f, 0.f));

	{
		box_mesh_desc m;
		m.radius = vec3(0.01f, gearOffset * 0.5f + 0.05f, 0.01f);
		m.center = vec3(-rearAxisGearDesc.cylinderRadius * 0.9f, gearOffset * 0.5f + 0.05f, 0.f);
		builder.pushBox(m);
		differentialSunGear.getComponent<mesh_component>().mesh->submeshes.push_back({ builder.endSubmesh(), {}, trs::identity, material });
	}

	// Differential.
	vec3 differentialSpiderGearPos(0.11f, motorGearY + gearOffset * 2.f, rearAxisOffsetZ);
	axis_attachment spiderGearAttachment(0.2f, 0.02f);
	differentialSpiderGear = createAxis(scene, builder, material, differentialSpiderGearPos, quat::identity, motorGearDesc, &spiderGearAttachment);
	addHingeConstraintFromGlobalPoints(differentialSunGear, differentialSpiderGear, differentialSpiderGearPos, vec3(0.f, 1.f, 0.f));

	vec3 leftRearWheelPos = differentialSpiderGearPos + vec3(-gearOffset, -gearOffset, 0.f);
	vec3 rightRearWheelPos = differentialSpiderGearPos + vec3(gearOffset, -gearOffset, 0.f);

	axis_attachment leftWheelAttachment(axisLength + differentialSpiderGearPos.x, rodThickness, wheelDesc);
	axis_attachment rightWheelAttachment(axisLength - differentialSpiderGearPos.x, rodThickness, wheelDesc);

	leftRearWheel = createAxis(scene, builder, material, leftRearWheelPos, quat(vec3(0.f, 0.f, -1.f), deg2rad(90.f)), motorGearDesc, 0, &leftWheelAttachment);
	rightRearWheel = createAxis(scene, builder, material, rightRearWheelPos, quat(vec3(0.f, 0.f, -1.f), deg2rad(90.f)), motorGearDesc, &rightWheelAttachment, 0);

	addHingeConstraintFromGlobalPoints(motor, leftRearWheel, leftRearWheelPos, vec3(1.f, 0.f, 0.f));
	addHingeConstraintFromGlobalPoints(motor, rightRearWheel, rightRearWheelPos, vec3(1.f, 0.f, 0.f));


	quat rotation(vec3(0.f, 1.f, 0.f), initialRotation);

	auto mesh = builder.createDXMesh();
	for (uint32 i = 0; i < arraysize(parts); ++i)
	{
		parts[i].getComponent<mesh_component>().mesh->mesh = mesh;

		auto& transform = parts[i].getComponent<transform_component>();
		transform.position = rotation * transform.position + initialMotorPosition;
		transform.rotation = rotation * transform.rotation;
	}
}

vehicle vehicle::create(game_scene& scene, vec3 initialMotorPosition, float initialRotation)
{
	vehicle v;
	v.initialize(scene, initialMotorPosition, initialRotation);
	return v;
}

```

`src/physics/vehicle.h`:

```h
#pragma once

#include "physics.h"

struct vehicle
{
	vehicle() {}

	void initialize(game_scene& scene, vec3 initialMotorPosition, float initialRotation = 0.f);
	static vehicle create(game_scene& scene, vec3 initialMotorPosition, float initialRotation = 0.f);

	union
	{
		struct
		{
			scene_entity motor;
			scene_entity motorGear;
			scene_entity driveAxis;
			scene_entity frontAxis;
			scene_entity steeringWheel;
			scene_entity steeringAxis;

			scene_entity leftWheelSuspension;
			scene_entity rightWheelSuspension;

			scene_entity leftFrontWheel;
			scene_entity rightFrontWheel;

			scene_entity leftWheelArm;
			scene_entity rightWheelArm;

			scene_entity differentialSunGear;
			scene_entity differentialSpiderGear;

			scene_entity leftRearWheel;
			scene_entity rightRearWheel;
		};
		scene_entity parts[16];
	};
};

```

`src/rendering/bitonic_sort.cpp`:

```cpp
#include "pch.h"
#include "bitonic_sort.h"
#include "dx/dx_pipeline.h"
#include "dx/dx_command_list.h"
#include "dx/dx_barrier_batcher.h"
#include "dx/dx_profiling.h"
#include "core/random.h"

#include "bitonic_sort_rs.hlsli"

// Adapted from MiniEngine.

//
// Copyright(c) 2013 - 2015 Microsoft
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files(the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
// Developed by Minigraph
//
// Author:  James Stanard 
//


static dx_pipeline startSortPipeline;

// Uint.
static dx_pipeline preSortUintPipeline;
static dx_pipeline innerSortUintPipeline;
static dx_pipeline outerSortUintPipeline;

// Float.
static dx_pipeline preSortFloatPipeline;
static dx_pipeline innerSortFloatPipeline;
static dx_pipeline outerSortFloatPipeline;

static ref<dx_buffer> dispatchBuffer;

void initializeBitonicSort()
{
	startSortPipeline = createReloadablePipeline("bitonic_start_sort_cs");

	// Uint.
	preSortUintPipeline = createReloadablePipeline("bitonic_pre_sort_uint_cs");
	innerSortUintPipeline = createReloadablePipeline("bitonic_inner_sort_uint_cs");
	outerSortUintPipeline = createReloadablePipeline("bitonic_outer_sort_uint_cs");

	// Float.
	preSortFloatPipeline = createReloadablePipeline("bitonic_pre_sort_float_cs");
	innerSortFloatPipeline = createReloadablePipeline("bitonic_inner_sort_float_cs");
	outerSortFloatPipeline = createReloadablePipeline("bitonic_outer_sort_float_cs");

	dispatchBuffer = createBuffer(sizeof(D3D12_DISPATCH_ARGUMENTS), 22 * 23 / 2, 0, true, false);
}

static std::pair<uint32, uint32> getAlignedMaxNumElementsAndNumIterations(uint32 maxNumElements)
{
	uint32 alignedMaxNumElements = alignToPowerOfTwo(maxNumElements);
	uint32 maxNumIterations = log2(max(2048u, alignedMaxNumElements)) - 10;

	return { alignedMaxNumElements, maxNumIterations };
}

static void bitonicSortInternal(dx_command_list* cl,
	const ref<dx_buffer>& sortBuffer, uint32 sortBufferOffset,
	const ref<dx_buffer>& comparisonBuffer, uint32 comparisonBufferOffset, 
	const ref<dx_buffer>& counterBuffer, bitonic_sort_cb cb, uint32 alignedMaxNumElements,
	const dx_pipeline& preSortPipeline, const dx_pipeline& outerSortPipeline, const dx_pipeline& innerSortPipeline)
{
	DX_PROFILE_BLOCK(cl, "Bitonic sort");

	// ----------------------------------------
	// START
	// ----------------------------------------

	{
		DX_PROFILE_BLOCK(cl, "Start");

		cl->setPipelineState(*startSortPipeline.pipeline);
		cl->setComputeRootSignature(*startSortPipeline.rootSignature);

		cl->setCompute32BitConstants(BITONIC_SORT_RS_CB, cb);
		cl->setRootComputeUAV(BITONIC_SORT_RS_DISPATCH, dispatchBuffer);
		cl->setRootComputeSRV(BITONIC_SORT_RS_COUNTER_BUFFER, counterBuffer);

		cl->dispatch(1);
		barrier_batcher(cl)
			//.uav(dispatchBuffer)
			.transition(dispatchBuffer, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT);
	}


	// ----------------------------------------
	// PRE-SORT
	// ----------------------------------------

	// Pre-sort the buffer up to k = 2048. This also pads the list with invalid indices
	// that will drift to the end of the sorted list.

	// Since the root signatures between all stages are identical, we don't need to switch between them and don't need to rebind the root arguments.
	// The only thing we need to bind here is the sort buffer, since this is not needed in the start stage.

	{
		DX_PROFILE_BLOCK(cl, "Pre sort");

		cl->setPipelineState(*preSortPipeline.pipeline);

		cl->setRootComputeUAV(BITONIC_SORT_RS_SORT_BUFFER, sortBuffer->gpuVirtualAddress + sortBufferOffset);
		if (comparisonBuffer)
		{
			cl->setRootComputeUAV(BITONIC_SORT_RS_COMPARISON_BUFFER, comparisonBuffer->gpuVirtualAddress + comparisonBufferOffset);
		}

		cl->dispatchIndirect(1, dispatchBuffer, 0);

		barrier_batcher(cl)
			.uav(sortBuffer)
			.uav(comparisonBuffer);
	}



	// ----------------------------------------
	// SORT
	// ----------------------------------------

	uint32 indirectArgsOffset = 12;

	for (uint32 k = 4096; k <= alignedMaxNumElements; k *= 2)
	{
		DX_PROFILE_BLOCK(cl, "Outer sort");

		cl->setPipelineState(*outerSortPipeline.pipeline);

		for (uint32 j = k / 2; j >= 2048; j /= 2)
		{
			cl->setCompute32BitConstants(BITONIC_SORT_RS_KJ, bitonic_sort_kj_cb{ k, j });
			cl->dispatchIndirect(1, dispatchBuffer, indirectArgsOffset);
			
			barrier_batcher(cl)
				.uav(sortBuffer)
				.uav(comparisonBuffer);

			indirectArgsOffset += 12;
		}


		DX_PROFILE_BLOCK(cl, "Inner sort");

		cl->setPipelineState(*innerSortPipeline.pipeline);

		cl->dispatchIndirect(1, dispatchBuffer, indirectArgsOffset);

		barrier_batcher(cl)
			.uav(sortBuffer)
			.uav(comparisonBuffer);

		indirectArgsOffset += 12;
	}

	cl->transitionBarrier(dispatchBuffer, D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);
}

void bitonicSortUint(dx_command_list* cl,
	const ref<dx_buffer>& sortKeysAndValues, uint32 sortOffset, uint32 maxNumElements,
	const ref<dx_buffer>& counterBuffer, uint32 counterBufferOffset, bool sortAscending)
{
	ASSERT(sortOffset % sizeof(uint32) == 0);
	ASSERT(counterBufferOffset % sizeof(uint32) == 0);

	auto [alignedMaxNumElements, maxNumIterations] = getAlignedMaxNumElementsAndNumIterations(maxNumElements);
	bitonic_sort_cb cb;
	cb.maxNumIterations = maxNumIterations;
	cb.counterOffset = counterBufferOffset / sizeof(uint32);
	cb.nullUint = sortAscending ? 0xffffffff : 0;

	bitonicSortInternal(cl, sortKeysAndValues, sortOffset, 0, 0, 
		counterBuffer, cb, alignedMaxNumElements, preSortUintPipeline, outerSortUintPipeline, innerSortUintPipeline);
}

void bitonicSortFloat(dx_command_list* cl,
	const ref<dx_buffer>& sortKeys, uint32 sortKeyOffset,
	const ref<dx_buffer>& sortValues, uint32 sortValueOffset, uint32 maxNumElements,
	const ref<dx_buffer>& counterBuffer, uint32 counterBufferOffset, bool sortAscending)
{
	ASSERT(sortKeyOffset % sizeof(float) == 0);
	ASSERT(sortValueOffset % sizeof(uint32) == 0);
	ASSERT(counterBufferOffset % sizeof(uint32) == 0);

	auto [alignedMaxNumElements, maxNumIterations] = getAlignedMaxNumElementsAndNumIterations(maxNumElements);
	bitonic_sort_cb cb;
	cb.maxNumIterations = maxNumIterations;
	cb.counterOffset = counterBufferOffset / sizeof(uint32);
	cb.nullFloat = sortAscending ? FLT_MAX : -FLT_MAX;

	bitonicSortInternal(cl, sortValues, sortValueOffset, sortKeys, sortKeyOffset, 
		counterBuffer, cb, alignedMaxNumElements, preSortFloatPipeline, outerSortFloatPipeline, innerSortFloatPipeline);
}

void testBitonicSortUint(uint32 numElements, bool ascending)
{
	uint32 mask = alignToPowerOfTwo(numElements) - 1;

	random_number_generator rng = { 125912842 };

	uint32* values = new uint32[numElements];
	for (uint32 i = 0; i < numElements; ++i)
	{
		values[i] = (rng.randomUint32() & ~mask) | i;
	}

	ref<dx_buffer> list = createBuffer(sizeof(uint32), numElements, values, true);
	ref<dx_buffer> counter = createBuffer(sizeof(uint32), 1, &numElements);

	delete[] values;

	ref<dx_buffer> dispatchReadback = createReadbackBuffer(sizeof(D3D12_DISPATCH_ARGUMENTS), 22 * 23 / 2);
	ref<dx_buffer> listReadback = createReadbackBuffer(sizeof(uint32), numElements);

	dx_command_list* cl = dxContext.getFreeRenderCommandList();
	
	bitonicSortUint(cl, list, 0, numElements, counter, 0, ascending);
	cl->transitionBarrier(list, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_COPY_SOURCE);
	cl->transitionBarrier(dispatchBuffer, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_COPY_SOURCE);
	cl->copyResource(dispatchBuffer->resource, dispatchReadback->resource);
	cl->copyResource(list->resource, listReadback->resource);

	dxContext.executeCommandList(cl);
	dxContext.flushApplication();

	uint32* sortedValues = (uint32*)mapBuffer(listReadback, true);
	D3D12_DISPATCH_ARGUMENTS* args = (D3D12_DISPATCH_ARGUMENTS*)mapBuffer(dispatchReadback, true);

	for (uint32 i = 0; i < numElements - 1; ++i)
	{
		if ((sortedValues[i] & mask) >= numElements)
		{
			std::cerr << "Corrupted list index detected.\n";
		}

		if (ascending)
		{
			if (sortedValues[i] > sortedValues[i + 1])
			{
				std::cerr << "Invalid sort order:  non-ascending.\n";
			}
		}
		else
		{
			if (sortedValues[i] < sortedValues[i + 1])
			{
				std::cerr << "Invalid sort order:  non-descending.\n";
			}
		}
	}

	if ((sortedValues[numElements - 1] & mask) >= numElements)
	{
		std::cerr << "Corrupted list index detected.\n";
	}

	unmapBuffer(dispatchReadback, false);
	unmapBuffer(listReadback, false);
}

void testBitonicSortFloat(uint32 numElements, bool ascending)
{
	random_number_generator rng = { 125912842 };

	uint32* values = new uint32[numElements];
	float* keys = new float[numElements];
	for (uint32 i = 0; i < numElements; ++i)
	{
		values[i] = i;
		keys[i] = rng.randomFloatBetween(-10000.f, 10000.f);
	}

	ref<dx_buffer> valuesList = createBuffer(sizeof(uint32), numElements, values, true);
	ref<dx_buffer> keysList = createBuffer(sizeof(float), numElements, keys, true);
	ref<dx_buffer> counter = createBuffer(sizeof(uint32), 1, &numElements);


	ref<dx_buffer> dispatchReadback = createReadbackBuffer(sizeof(D3D12_DISPATCH_ARGUMENTS), 22 * 23 / 2);
	ref<dx_buffer> valuesListReadback = createReadbackBuffer(sizeof(uint32), numElements);
	ref<dx_buffer> keysListReadback = createReadbackBuffer(sizeof(float), numElements);

	dx_command_list* cl = dxContext.getFreeRenderCommandList();

	bitonicSortFloat(cl, keysList, 0, valuesList, 0, numElements, counter, 0, ascending);
	cl->transitionBarrier(valuesList, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_COPY_SOURCE);
	cl->transitionBarrier(keysList, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_COPY_SOURCE);
	cl->transitionBarrier(dispatchBuffer, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_COPY_SOURCE);
	cl->copyResource(dispatchBuffer->resource, dispatchReadback->resource);
	cl->copyResource(valuesList->resource, valuesListReadback->resource);
	cl->copyResource(keysList->resource, keysListReadback->resource);

	dxContext.executeCommandList(cl);
	dxContext.flushApplication();

	uint32* sortedValues = (uint32*)mapBuffer(valuesListReadback, true);
	float* sortedKeys = (float*)mapBuffer(keysListReadback, true);
	D3D12_DISPATCH_ARGUMENTS* args = (D3D12_DISPATCH_ARGUMENTS*)mapBuffer(dispatchReadback, true);

	for (uint32 i = 0; i < numElements - 1; ++i)
	{
		if (ascending)
		{
			if (sortedKeys[i] > sortedKeys[i + 1])
			{
				std::cerr << "Invalid sort order:  non-ascending.\n";
			}
		}
		else
		{
			if (sortedKeys[i] < sortedKeys[i + 1])
			{
				std::cerr << "Invalid sort order:  non-descending.\n";
			}
		}

		uint32 value = sortedValues[i];
		float key = sortedKeys[i];
		float compKey = keys[value];

		if (key != compKey)
		{
			std::cerr << "Invalid pairing.\n";
		}
	}

	unmapBuffer(dispatchReadback, false);
	unmapBuffer(keysListReadback, false);
	unmapBuffer(valuesListReadback, false);

	delete[] values;
	delete[] keys;
}

```

`src/rendering/bitonic_sort.h`:

```h
#pragma once

struct dx_command_list;
struct dx_buffer;

void initializeBitonicSort();

// These functions sort a buffer of values based on a key. The currently supported variants are:
// - bitonicSortUint: Key and value are packed into a single uint. The sorting algorithm will simply sort this buffer. The user must pack the key into
//	 the most significant and the value into the least significant bits (how many bits the two take is up to you). 
//   Since the values are sorted as uints, you have to make sure that your key is sortable when interpreted as a uint.
// - bitonicSortFloat: Here you provide two buffers, one with the values (32 bit indices) and one with the keys (32 bit floats). The buffers will be sorted
//   based on the keys.
// 
// The input buffers for keys and values are expected to be in the resource state D3D12_RESOURCE_STATE_UNORDERED_ACCESS. They also return in this state.
// It is expected that you have a GPU-visible buffer containing the number of elements to sort (counterBuffer). counterBufferOffset is a byte-offset into this
// buffer to the location where the count sits.
// The count does not need to be a power of two.

void bitonicSortUint(dx_command_list* cl, 
	const ref<dx_buffer>& sortKeysAndValues, uint32 sortOffset, uint32 maxNumElements, 
	const ref<dx_buffer>& counterBuffer, uint32 counterBufferOffset, bool sortAscending);
void bitonicSortFloat(dx_command_list* cl, 
	const ref<dx_buffer>& sortKeys, uint32 sortKeyOffset, 
	const ref<dx_buffer>& sortValues, uint32 sortValueOffset, uint32 maxNumElements, 
	const ref<dx_buffer>& counterBuffer, uint32 counterBufferOffset, bool sortAscending);

// Internal test functions.
void testBitonicSortUint(uint32 numElements, bool ascending);
void testBitonicSortFloat(uint32 numElements, bool ascending);

```

`src/rendering/debug_visualization.cpp`:

```cpp
#include "pch.h"
#include "debug_visualization.h"
#include "core/cpu_profiling.h"
#include "render_utils.h"
#include "render_resources.h"
#include "transform.hlsli"

static dx_pipeline simplePipeline;
static dx_pipeline unlitPositionPipeline;
static dx_pipeline unlitPositionColorPipeline;
static dx_pipeline unlitLinePositionPipeline;
static dx_pipeline unlitLinePositionColorPipeline;




static D3D12_INPUT_ELEMENT_DESC inputLayout_position_color[] = {
	{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D12_APPEND_ALIGNED_ELEMENT, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
	{ "COLOR", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D12_APPEND_ALIGNED_ELEMENT, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
};



void debug_simple_pipeline::initialize()
{
	auto desc = CREATE_GRAPHICS_PIPELINE
		.inputLayout(inputLayout_position_normal)
		.renderTargets(ldrFormat, depthStencilFormat);

	simplePipeline = createReloadablePipeline(desc, { "flat_simple_vs", "flat_simple_ps" });
}

PIPELINE_SETUP_IMPL(debug_simple_pipeline)
{
	cl->setPipelineState(*simplePipeline.pipeline);
	cl->setGraphicsRootSignature(*simplePipeline.rootSignature);
	cl->setPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

	cl->setGraphicsDynamicConstantBuffer(FLAT_SIMPLE_RS_CAMERA, common.cameraCBV);
}

PIPELINE_RENDER_IMPL(debug_simple_pipeline, debug_render_data)
{
	cl->setGraphics32BitConstants(FLAT_SIMPLE_RS_TRANFORM, transform_cb{ viewProj * data.transform, data.transform });
	cl->setGraphics32BitConstants(FLAT_SIMPLE_RS_CB, visualization_cb{ data.color });
	cl->setVertexBuffer(0, data.vertexBuffer.positions);
	cl->setVertexBuffer(1, data.vertexBuffer.others);
	cl->setIndexBuffer(data.indexBuffer);
	cl->drawIndexed(data.submesh.numIndices, 1, data.submesh.firstIndex, data.submesh.baseVertex, 0);
}





void debug_unlit_pipeline::initialize()
{
	auto desc = CREATE_GRAPHICS_PIPELINE
		.inputLayout(inputLayout_position)
		.cullingOff()
		.renderTargets(ldrFormat, depthStencilFormat);
	unlitPositionPipeline = createReloadablePipeline(desc, { "flat_unlit_position_vs", "flat_unlit_ps" });

	desc.inputLayout(inputLayout_position_color);
	unlitPositionColorPipeline = createReloadablePipeline(desc, { "flat_unlit_position_color_vs", "flat_unlit_ps" });
}

PIPELINE_SETUP_IMPL(debug_unlit_pipeline::position)
{
	cl->setPipelineState(*unlitPositionPipeline.pipeline);
	cl->setGraphicsRootSignature(*unlitPositionPipeline.rootSignature);
	cl->setPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
}

PIPELINE_SETUP_IMPL(debug_unlit_pipeline::position_color)
{
	cl->setPipelineState(*unlitPositionColorPipeline.pipeline);
	cl->setGraphicsRootSignature(*unlitPositionColorPipeline.rootSignature);
	cl->setPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
}

PIPELINE_RENDER_IMPL(debug_unlit_pipeline, debug_render_data)
{
	cl->setGraphics32BitConstants(FLAT_UNLIT_RS_TRANFORM, viewProj * data.transform);
	cl->setGraphics32BitConstants(FLAT_UNLIT_RS_CB, visualization_cb{ data.color });
	cl->setVertexBuffer(0, data.vertexBuffer.positions);
	cl->setIndexBuffer(data.indexBuffer);
	cl->drawIndexed(data.submesh.numIndices, 1, data.submesh.firstIndex, data.submesh.baseVertex, 0);
}




void debug_unlit_line_pipeline::initialize()
{
	auto desc = CREATE_GRAPHICS_PIPELINE
		.inputLayout(inputLayout_position)
		.renderTargets(ldrFormat, depthStencilFormat)
		.primitiveTopology(D3D12_PRIMITIVE_TOPOLOGY_TYPE_LINE);
	unlitLinePositionPipeline = createReloadablePipeline(desc, { "flat_unlit_position_vs", "flat_unlit_ps" });

	desc.inputLayout(inputLayout_position_color);
	unlitLinePositionColorPipeline = createReloadablePipeline(desc, { "flat_unlit_position_color_vs", "flat_unlit_ps" });
}

PIPELINE_SETUP_IMPL(debug_unlit_line_pipeline::position)
{
	cl->setPipelineState(*unlitLinePositionPipeline.pipeline);
	cl->setGraphicsRootSignature(*unlitLinePositionPipeline.rootSignature);
	cl->setPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_LINELIST);
}

PIPELINE_SETUP_IMPL(debug_unlit_line_pipeline::position_color)
{
	cl->setPipelineState(*unlitLinePositionColorPipeline.pipeline);
	cl->setGraphicsRootSignature(*unlitLinePositionColorPipeline.rootSignature);
	cl->setPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_LINELIST);
}

PIPELINE_RENDER_IMPL(debug_unlit_line_pipeline, debug_render_data)
{
	cl->setGraphics32BitConstants(FLAT_UNLIT_RS_TRANFORM, viewProj * data.transform);
	cl->setGraphics32BitConstants(FLAT_UNLIT_RS_CB, data.color);
	cl->setVertexBuffer(0, data.vertexBuffer.positions);
	cl->setIndexBuffer(data.indexBuffer);
	cl->drawIndexed(data.submesh.numIndices, 1, data.submesh.firstIndex, data.submesh.baseVertex, 0);
}




void renderTriangle(vec3 a, vec3 b, vec3 c, vec4 color, ldr_render_pass* renderPass, bool overlay)
{
	auto [vb, vertexPtr] = dxContext.createDynamicVertexBuffer(sizeof(vec3), 3);
	auto [ib, indexPtr] = dxContext.createDynamicIndexBuffer(sizeof(uint16), 3);

	vec3* vertices = (vec3*)vertexPtr;
	indexed_triangle16* triangles = (indexed_triangle16*)indexPtr;

	*vertices++ = a;
	*vertices++ = b;
	*vertices++ = c;

	*triangles = { 0, 1, 2 };

	renderDebug<debug_unlit_pipeline::position>(mat4::identity, vb, ib, color, renderPass, overlay);
}

void renderDisk(vec3 position, vec3 upAxis, float radius, vec4 color, ldr_render_pass* renderPass, bool overlay)
{
	const uint32 numSegments = 32;

	uint32 numTriangles = numSegments;
	uint32 numVertices = numSegments + 1;

	auto [vb, vertexPtr] = dxContext.createDynamicVertexBuffer(sizeof(vec3), numVertices);
	auto [ib, indexPtr] = dxContext.createDynamicIndexBuffer(sizeof(uint16), numTriangles * 3);

	vec3* vertices = (vec3*)vertexPtr;
	indexed_triangle16* triangles = (indexed_triangle16*)indexPtr;

	float deltaRot = M_TAU / numSegments;
	float rot = 0.f;
	for (uint32 i = 0; i < numSegments; ++i)
	{
		*vertices++ = vec3(cos(rot), sin(rot), 0.f) * radius;
		rot += deltaRot;
	}

	*vertices++ = vec3(0.f, 0.f, 0.f);

	uint16 center = (uint16)numVertices - 1;

	for (uint16 i = 0; i < numSegments; ++i)
	{
		uint16 next = i + 1;
		if (i == numSegments - 1)
		{
			next = 0;
		}
		*triangles++ = { center, i, next };
	}

	renderDebug<debug_unlit_pipeline::position>(createModelMatrix(position, rotateFromTo(vec3(0.f, 0.f, 1.f), upAxis)), vb, ib, color, renderPass, overlay);
}

void renderRing(vec3 position, vec3 upAxis, float outerRadius, float innerRadius, vec4 color, ldr_render_pass* renderPass, bool overlay)
{
	const uint32 numSegments = 32;

	uint32 numTriangles = numSegments * 2;
	uint32 numVertices = numSegments * 2;

	auto [vb, vertexPtr] = dxContext.createDynamicVertexBuffer(sizeof(vec3), numVertices);
	auto [ib, indexPtr] = dxContext.createDynamicIndexBuffer(sizeof(uint16), numTriangles * 3);

	vec3* outer = (vec3*)vertexPtr;
	vec3* inner = outer + numSegments;
	indexed_triangle16* triangles = (indexed_triangle16*)indexPtr;

	float deltaRot = M_TAU / numSegments;
	float rot = 0.f;
	for (uint32 i = 0; i < numSegments; ++i)
	{
		vec3 p = vec3(cos(rot), sin(rot), 0.f);
		*outer++ = p * outerRadius;
		*inner++ = p * innerRadius;
		rot += deltaRot;
	}

	uint16 offset = (uint16)numSegments;
	for (uint16 i = 0; i < numSegments; ++i)
	{
		uint16 next = i + 1;
		if (i == numSegments - 1)
		{
			next = 0;
		}
		*triangles++ = { i, next, (uint16)(i + offset) };
		*triangles++ = { next, (uint16)(i + offset), (uint16)(next + offset) };
	}

	renderDebug<debug_unlit_pipeline::position>(createModelMatrix(position, rotateFromTo(vec3(0.f, 0.f, 1.f), upAxis)), vb, ib, color, renderPass, overlay);
}

void renderAngleRing(vec3 position, vec3 upAxis, float outerRadius, float innerRadius, 
	vec3 zeroDegAxis, float minAngle, float maxAngle, vec4 color, ldr_render_pass* renderPass, bool overlay)
{
	const uint32 numSegments360 = 32;

	const float deltaRot = M_TAU / numSegments360;
	float angleRange = maxAngle - minAngle;
	const uint32 numSegments = (uint32)ceil(angleRange / deltaRot);

	uint32 numTriangles = numSegments * 2;
	uint32 numVertices = (numSegments + 1) * 2;

	auto [vb, vertexPtr] = dxContext.createDynamicVertexBuffer(sizeof(vec3), numVertices);
	auto [ib, indexPtr] = dxContext.createDynamicIndexBuffer(sizeof(uint16), numTriangles * 3);

	vec3* outer = (vec3*)vertexPtr;
	vec3* inner = outer + (numSegments + 1);
	indexed_triangle16* triangles = (indexed_triangle16*)indexPtr;

	vec3 x = zeroDegAxis;
	vec3 z = cross(upAxis, x);

	float rot = minAngle;
	for (uint32 i = 0; i < numSegments + 1; ++i)
	{
		vec3 p = cos(rot) * x + sin(rot) * z;
		*outer++ = p * outerRadius + position;
		*inner++ = p * innerRadius + position;
		rot += deltaRot;
		rot = min(rot, maxAngle);
	}

	uint16 offset = (uint16)(numSegments + 1);
	for (uint16 i = 0; i < numSegments; ++i)
	{
		uint16 next = i + 1;
		*triangles++ = { i, next, (uint16)(i + offset) };
		*triangles++ = { next, (uint16)(i + offset), (uint16)(next + offset) };
	}

	renderDebug<debug_unlit_pipeline::position>(mat4::identity, vb, ib, color, renderPass, overlay);
}












static std::tuple<dx_dynamic_vertex_buffer, dx_dynamic_index_buffer> getWireRing()
{
	const uint32 numSegments = 32;

	uint32 numLines = numSegments;
	uint32 numVertices = numSegments;

	auto [vb, vertexPtr] = dxContext.createDynamicVertexBuffer(sizeof(vec3), numVertices);
	auto [ib, indexPtr] = dxContext.createDynamicIndexBuffer(sizeof(uint16), numLines * 2);

	vec3* vertices = (vec3*)vertexPtr;
	indexed_line16* lines = (indexed_line16*)indexPtr;

	float deltaRot = M_TAU / numSegments;
	float rot = 0.f;
	for (uint32 i = 0; i < numSegments; ++i)
	{
		*vertices++ = vec3(cos(rot), sin(rot), 0.f);
		rot += deltaRot;
	}

	for (uint16 i = 0; i < numSegments; ++i)
	{
		uint16 next = i + 1;
		if (i == numSegments - 1)
		{
			next = 0;
		}
		*lines++ = { i, next };
	}

	return { vb, ib };
}

static std::tuple<dx_dynamic_vertex_buffer, dx_dynamic_index_buffer> getWireCapsuleCrossSection(float length, float radius)
{
	const uint32 numSegmentsPerHalf = 16;

	uint32 numVertices = numSegmentsPerHalf * 2 + 2;
	uint32 numLines = numVertices;

	auto [vb, vertexPtr] = dxContext.createDynamicVertexBuffer(sizeof(vec3), numVertices);
	auto [ib, indexPtr] = dxContext.createDynamicIndexBuffer(sizeof(uint16), numLines * 2);

	vec3* verticesA = (vec3*)vertexPtr;
	vec3* verticesB = verticesA + (numSegmentsPerHalf + 1);
	indexed_line16* lines = (indexed_line16*)indexPtr;


	float deltaRot = M_PI / numSegmentsPerHalf;
	float rot = 0.f;
	float halfLength = length * 0.5f;
	for (uint32 i = 0; i < numSegmentsPerHalf + 1; ++i)
	{
		float x = cos(rot), y = sin(rot);
		*verticesA++ =  vec3(radius * x, radius * y + halfLength, 0.f);
		*verticesB++ = -vec3(radius * x, radius * y + halfLength, 0.f);
		rot += deltaRot;
	}

	for (uint16 i = 0; i < numLines; ++i)
	{
		uint16 next = i + 1;
		if (i == numLines - 1)
		{
			next = 0;
		}
		*lines++ = { i, next };
	}

	return { vb, ib };
}

void renderLine(vec3 positionA, vec3 positionB, vec4 color, ldr_render_pass* renderPass, bool overlay)
{
	CPU_PROFILE_BLOCK("Render line");

	auto [vb, vertexPtr] = dxContext.createDynamicVertexBuffer(sizeof(vec3), 2);
	auto [ib, indexPtr] = dxContext.createDynamicIndexBuffer(sizeof(uint16), 2);

	vec3* vertices = (vec3*)vertexPtr;
	indexed_line16* lines = (indexed_line16*)indexPtr;

	*vertices++ = positionA;
	*vertices++ = positionB;

	*lines++ = { 0, 1 };

	renderDebug<debug_unlit_line_pipeline::position>(mat4::identity, vb, ib, color, renderPass, overlay);
}

void renderWireTriangle(vec3 a, vec3 b, vec3 c, vec4 color, ldr_render_pass* renderPass, bool overlay)
{
	auto [vb, vertexPtr] = dxContext.createDynamicVertexBuffer(sizeof(vec3), 3);
	auto [ib, indexPtr] = dxContext.createDynamicIndexBuffer(sizeof(uint16), 3);

	vec3* vertices = (vec3*)vertexPtr;
	indexed_triangle16* triangles = (indexed_triangle16*)indexPtr;

	*vertices++ = a;
	*vertices++ = b;
	*vertices++ = c;

	*triangles = { 0, 1, 2 };

	renderDebug<debug_unlit_line_pipeline::position>(mat4::identity, vb, ib, color, renderPass, overlay);
}

void renderWireSphere(vec3 position, float radius, vec4 color, ldr_render_pass* renderPass, bool overlay)
{
	CPU_PROFILE_BLOCK("Render wire sphere");

	auto [vb, ib] = getWireRing();

	renderDebug<debug_unlit_line_pipeline::position>(createModelMatrix(position, quat::identity, radius), vb, ib, color, renderPass, overlay);
	renderDebug<debug_unlit_line_pipeline::position>(createModelMatrix(position, quat(vec3(0.f, 1.f, 0.f), deg2rad(90.f)), radius), vb, ib, color, renderPass, overlay);
	renderDebug<debug_unlit_line_pipeline::position>(createModelMatrix(position, quat(vec3(1.f, 0.f, 0.f), deg2rad(90.f)), radius), vb, ib, color, renderPass, overlay);
}

void renderWireCapsule(vec3 positionA, vec3 positionB, float radius, vec4 color, ldr_render_pass* renderPass, bool overlay)
{
	CPU_PROFILE_BLOCK("Render wire capsule");

	vec3 center = 0.5f * (positionA + positionB);
	quat rotation = rotateFromTo(vec3(0.f, 1.f, 0.f), positionA - positionB);
	auto [vb, ib] = getWireCapsuleCrossSection(length(positionA - positionB), radius);

	renderDebug<debug_unlit_line_pipeline::position>(createModelMatrix(center, rotation * quat::identity, 1.f), vb, ib, color, renderPass, overlay);
	renderDebug<debug_unlit_line_pipeline::position>(createModelMatrix(center, rotation * quat(vec3(0.f, 1.f, 0.f), deg2rad(90.f)), 1.f), vb, ib, color, renderPass, overlay);
}

void renderWireCylinder(vec3 positionA, vec3 positionB, float radius, vec4 color, ldr_render_pass* renderPass, bool overlay)
{
	CPU_PROFILE_BLOCK("Render wire cylinder");

	quat rotation = rotateFromTo(vec3(0.f, 1.f, 0.f), positionA - positionB);

	{
		auto [vb, ib] = getWireRing();
		quat rotate90deg(vec3(1.f, 0.f, 0.f), deg2rad(90.f));
		renderDebug<debug_unlit_line_pipeline::position>(createModelMatrix(positionA, rotation * rotate90deg, radius), vb, ib, color, renderPass, overlay);
		renderDebug<debug_unlit_line_pipeline::position>(createModelMatrix(positionB, rotation * rotate90deg, radius), vb, ib, color, renderPass, overlay);
	}

	{
		auto [vb, vertexPtr] = dxContext.createDynamicVertexBuffer(sizeof(vec3), 8);
		auto [ib, indexPtr] = dxContext.createDynamicIndexBuffer(sizeof(uint16), 8);

		vec3* vertices = (vec3*)vertexPtr;
		indexed_line16* lines = (indexed_line16*)indexPtr;

		vec3 xAxis = rotation * vec3(radius, 0.f, 0.f);
		vec3 zAxis = rotation * vec3(0.f, 0.f, radius);

		*vertices++ = positionA + xAxis;
		*vertices++ = positionB + xAxis;

		*vertices++ = positionA + zAxis;
		*vertices++ = positionB + zAxis;

		*vertices++ = positionA - xAxis;
		*vertices++ = positionB - xAxis;

		*vertices++ = positionA - zAxis;
		*vertices++ = positionB - zAxis;

		*lines++ = { 0, 1 };
		*lines++ = { 2, 3 };
		*lines++ = { 4, 5 };
		*lines++ = { 6, 7 };

		renderDebug<debug_unlit_line_pipeline::position>(mat4::identity, vb, ib, color, renderPass, overlay);
	}
}

void renderWireCone(vec3 position, vec3 direction, float distance, float angle, vec4 color, ldr_render_pass* renderPass, bool overlay)
{
	CPU_PROFILE_BLOCK("Render wire cone");

	const uint32 numSegments = 32;
	const uint32 numConeLines = 8;
	static_assert(numSegments % numConeLines == 0, "");

	uint32 numLines = numConeLines + numSegments;
	uint32 numVertices = 1 + numSegments;

	auto [vb, vertexPtr] = dxContext.createDynamicVertexBuffer(sizeof(vec3), numVertices);
	auto [ib, indexPtr] = dxContext.createDynamicIndexBuffer(sizeof(uint16), numLines * 2);

	vec3* vertices = (vec3*)vertexPtr;
	indexed_line16* lines = (indexed_line16*)indexPtr;

	float halfAngle = angle * 0.5f;
	float axisLength = tan(halfAngle);

	vec3 xAxis, yAxis;
	getTangents(direction, xAxis, yAxis);
	vec3 zAxis = direction * distance;
	xAxis *= distance * axisLength;
	yAxis *= distance * axisLength;

	*vertices++ = position;

	float deltaRot = M_TAU / numSegments;
	float rot = 0.f;
	for (uint32 i = 0; i < numSegments; ++i)
	{
		*vertices++ = position + zAxis + xAxis * cos(rot) + yAxis * sin(rot);
		rot += deltaRot;
	}

	const uint16 step = numSegments / numConeLines;

	for (uint16 i = 0; i < numConeLines; ++i)
	{
		uint16 next = 1u + i * step;
		*lines++ = { 0, next };
	}

	for (uint16 i = 0; i < numSegments; ++i)
	{
		uint16 cur = i + 1;
		uint16 next = i + 2;
		if (i == numSegments - 1)
		{
			next = 1;
		}
		*lines++ = { cur, next };
	}

	renderDebug<debug_unlit_line_pipeline::position>(mat4::identity, vb, ib, color, renderPass, overlay);
}

void renderWireBox(vec3 position, vec3 radius, quat rotation, vec4 color, ldr_render_pass* renderPass, bool overlay)
{
	CPU_PROFILE_BLOCK("Render wire box");

	auto [vb, vertexPtr] = dxContext.createDynamicVertexBuffer(sizeof(vec3), 8);
	auto [ib, indexPtr] = dxContext.createDynamicIndexBuffer(sizeof(uint16), 12 * 2);

	vec3* vertices = (vec3*)vertexPtr;
	*vertices++ = vec3(-1.f, 1.f, -1.f);
	*vertices++ = vec3(1.f, 1.f, -1.f);
	*vertices++ = vec3(-1.f, -1.f, -1.f);
	*vertices++ = vec3(1.f, -1.f, -1.f);
	*vertices++ = vec3(-1.f, 1.f, 1.f);
	*vertices++ = vec3(1.f, 1.f, 1.f);
	*vertices++ = vec3(-1.f, -1.f, 1.f);
	*vertices++ = vec3(1.f, -1.f, 1.f);

	indexed_line16* lines = (indexed_line16*)indexPtr;
	*lines++ = { 0, 1 };
	*lines++ = { 1, 3 };
	*lines++ = { 3, 2 };
	*lines++ = { 2, 0 };

	*lines++ = { 4, 5 };
	*lines++ = { 5, 7 };
	*lines++ = { 7, 6 };
	*lines++ = { 6, 4 };

	*lines++ = { 0, 4 };
	*lines++ = { 1, 5 };
	*lines++ = { 2, 6 };
	*lines++ = { 3, 7 };

	renderDebug<debug_unlit_line_pipeline::position>(createModelMatrix(position, rotation, radius), vb, ib, color, renderPass, overlay);
}

void renderCameraFrustum(const render_camera& frustum, vec4 color, ldr_render_pass* renderPass, float alternativeFarPlane, bool overlay)
{
	CPU_PROFILE_BLOCK("Render camera frustum");

	auto [vb, vertexPtr] = dxContext.createDynamicVertexBuffer(sizeof(vec3), 8);
	auto [ib, indexPtr] = dxContext.createDynamicIndexBuffer(sizeof(uint16), 12 * 2);

	vec3* vertices = (vec3*)vertexPtr;
	camera_frustum_corners corners = frustum.getWorldSpaceFrustumCorners(alternativeFarPlane);
	for (uint32 i = 0; i < 8; ++i)
	{
		*vertices++ = corners.corners[i];
	}

	indexed_line16* lines = (indexed_line16*)indexPtr;
	*lines++ = { 0, 1 };
	*lines++ = { 1, 3 };
	*lines++ = { 3, 2 };
	*lines++ = { 2, 0 };

	*lines++ = { 4, 5 };
	*lines++ = { 5, 7 };
	*lines++ = { 7, 6 };
	*lines++ = { 6, 4 };

	*lines++ = { 0, 4 };
	*lines++ = { 1, 5 };
	*lines++ = { 2, 6 };
	*lines++ = { 3, 7 };

	renderDebug<debug_unlit_line_pipeline::position>(mat4::identity, vb, ib, color, renderPass, overlay);
}

```

`src/rendering/debug_visualization.h`:

```h
#pragma once

#include "render_pass.h"
#include "dx/dx_command_list.h"
#include "core/camera.h"

#include "visualization_rs.hlsli"


struct position_color
{
	vec3 position;
	vec3 color;
};

struct debug_render_data
{
	mat4 transform;
	dx_vertex_buffer_group_view vertexBuffer;
	dx_index_buffer_view indexBuffer;
	submesh_info submesh;

	vec4 color;
};

struct debug_simple_pipeline
{
	// Layout: position, normal.

	static void initialize();

	PIPELINE_SETUP_DECL;
	PIPELINE_RENDER_DECL(debug_render_data);
};

struct debug_unlit_pipeline
{
	static void initialize();

	struct position;
	struct position_color;

	PIPELINE_RENDER_DECL(debug_render_data);
};

struct debug_unlit_pipeline::position : debug_unlit_pipeline { PIPELINE_SETUP_DECL; };
struct debug_unlit_pipeline::position_color : debug_unlit_pipeline { PIPELINE_SETUP_DECL; };

struct debug_unlit_line_pipeline
{
	static void initialize();

	struct position;
	struct position_color;

	PIPELINE_RENDER_DECL(debug_render_data);
};

struct debug_unlit_line_pipeline::position : debug_unlit_line_pipeline { PIPELINE_SETUP_DECL; };
struct debug_unlit_line_pipeline::position_color : debug_unlit_line_pipeline { PIPELINE_SETUP_DECL; };



template <typename pipeline_t>
static void renderDebug(const mat4& transform, const struct dx_dynamic_vertex_buffer& vb, const struct dx_dynamic_index_buffer& ib, vec4 color, 
	ldr_render_pass* renderPass, bool overlay = false)
{
	submesh_info sm;
	sm.baseVertex = 0;
	sm.numVertices = vb.view.SizeInBytes / vb.view.StrideInBytes;
	sm.firstIndex = 0;
	sm.numIndices = ib.view.SizeInBytes / getFormatSize(ib.view.Format);

	debug_render_data data = {
		transform, dx_vertex_buffer_group_view(vb), ib, sm, color
	};

	if (overlay)
	{
		renderPass->renderOverlay<pipeline_t>(data);
	}
	else
	{
		renderPass->renderObject<pipeline_t>(data);
	}
}


void renderTriangle(vec3 a, vec3 b, vec3 c, vec4 color, ldr_render_pass* renderPass, bool overlay = false);
void renderDisk(vec3 position, vec3 upAxis, float radius, vec4 color, ldr_render_pass* renderPass, bool overlay = false);
void renderRing(vec3 position, vec3 upAxis, float outerRadius, float innerRadius, vec4 color, ldr_render_pass* renderPass, bool overlay = false);
void renderAngleRing(vec3 position, vec3 upAxis, float outerRadius, float innerRadius,
	vec3 zeroDegAxis, float minAngle, float maxAngle, vec4 color, ldr_render_pass* renderPass, bool overlay = false);


void renderLine(vec3 positionA, vec3 positionB, vec4 color, ldr_render_pass* renderPass, bool overlay = false);
void renderWireTriangle(vec3 a, vec3 b, vec3 c, vec4 color, ldr_render_pass* renderPass, bool overlay = false);
void renderWireSphere(vec3 position, float radius, vec4 color, ldr_render_pass* renderPass, bool overlay = false);
void renderWireCapsule(vec3 positionA, vec3 positionB, float radius, vec4 color, ldr_render_pass* renderPass, bool overlay = false);
void renderWireCylinder(vec3 positionA, vec3 positionB, float radius, vec4 color, ldr_render_pass* renderPass, bool overlay = false);
void renderWireCone(vec3 position, vec3 direction, float distance, float angle, vec4 color, ldr_render_pass* renderPass, bool overlay = false);
void renderWireBox(vec3 position, vec3 radius, quat rotation, vec4 color, ldr_render_pass* renderPass, bool overlay = false);
void renderCameraFrustum(const render_camera& frustum, vec4 color, ldr_render_pass* renderPass, float alternativeFarPlane = -1.f, bool overlay = false);

```

`src/rendering/depth_prepass.cpp`:

```cpp
#include "pch.h"
#include "depth_prepass.h"
#include "render_utils.h"
#include "render_resources.h"

#include "dx/dx_command_list.h"

#include "depth_only_rs.hlsli"


static dx_pipeline defaultPipeline;
static dx_pipeline doubleSidedDefaultPipeline;
static dx_pipeline alphaCutoutPipeline;


static D3D12_INPUT_ELEMENT_DESC layout[] = {
	{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D12_APPEND_ALIGNED_ELEMENT, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
	{ "PREV_POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 1, D3D12_APPEND_ALIGNED_ELEMENT, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
};

static D3D12_INPUT_ELEMENT_DESC alphaCutoutLayout[] = {
	{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D12_APPEND_ALIGNED_ELEMENT, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
	{ "PREV_POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 1, D3D12_APPEND_ALIGNED_ELEMENT, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
	{ "TEXCOORDS", 0, DXGI_FORMAT_R32G32_FLOAT, 2, D3D12_APPEND_ALIGNED_ELEMENT, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
};


void initializeDepthPrepassPipelines()
{
	auto desc = CREATE_GRAPHICS_PIPELINE
		.renderTargets(depthOnlyFormat, arraysize(depthOnlyFormat), depthStencilFormat)
		.inputLayout(layout);

	defaultPipeline = createReloadablePipeline(desc, { "depth_only_vs", "depth_only_ps" }, rs_in_vertex_shader);

	desc.cullingOff();
	doubleSidedDefaultPipeline = createReloadablePipeline(desc, { "depth_only_vs", "depth_only_ps" }, rs_in_vertex_shader);

	desc.inputLayout(alphaCutoutLayout);
	alphaCutoutPipeline = createReloadablePipeline(desc, { "depth_only_alpha_cutout_vs", "depth_only_alpha_cutout_ps" }, rs_in_vertex_shader);
}

static void setupDepthPrepassCommon(dx_command_list* cl, const dx_pipeline& pipeline, dx_dynamic_constant_buffer cameraCBV)
{
	cl->setPipelineState(*pipeline.pipeline);
	cl->setGraphicsRootSignature(*pipeline.rootSignature);

	cl->setPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
	cl->setGraphicsDynamicConstantBuffer(DEPTH_ONLY_RS_CAMERA, cameraCBV);
}


PIPELINE_SETUP_IMPL(depth_prepass_pipeline::single_sided)
{
	setupDepthPrepassCommon(cl, defaultPipeline, common.cameraCBV);
}

PIPELINE_SETUP_IMPL(depth_prepass_pipeline::double_sided)
{
	setupDepthPrepassCommon(cl, doubleSidedDefaultPipeline, common.cameraCBV);
}

PIPELINE_SETUP_IMPL(depth_prepass_pipeline::alpha_cutout)
{
	setupDepthPrepassCommon(cl, alphaCutoutPipeline, common.cameraCBV);
}

static void render(dx_command_list* cl, const depth_prepass_data& data)
{
	cl->setRootGraphicsSRV(DEPTH_ONLY_RS_TRANSFORM, data.transformPtr);
	cl->setRootGraphicsSRV(DEPTH_ONLY_RS_PREV_FRAME_TRANSFORM, data.prevFrameTransformPtr);
	cl->setRootGraphicsSRV(DEPTH_ONLY_RS_OBJECT_ID, data.objectIDPtr);

	cl->setVertexBuffer(0, data.vertexBuffer.positions);
	cl->setVertexBuffer(1, data.prevFrameVertexBuffer);
	cl->setIndexBuffer(data.indexBuffer);
	cl->drawIndexed(data.submesh.numIndices, data.numInstances, data.submesh.firstIndex, data.submesh.baseVertex, 0);
}

DEPTH_ONLY_RENDER_IMPL(depth_prepass_pipeline, depth_prepass_data)
{
	::render(cl, data);
}

DEPTH_ONLY_RENDER_IMPL(depth_prepass_pipeline::alpha_cutout, depth_prepass_data)
{
	cl->setDescriptorHeapSRV(DEPTH_ONLY_RS_ALPHA_TEXTURE, 0, data.alphaCutoutTextureSRV ? data.alphaCutoutTextureSRV : render_resources::whiteTexture->defaultSRV);
	cl->setVertexBuffer(2, data.vertexBuffer.others);
	::render(cl, data);
}














```

`src/rendering/depth_prepass.h`:

```h
#pragma once

#include "material.h"
#include "render_command.h"





struct depth_prepass_data
{
	D3D12_GPU_VIRTUAL_ADDRESS transformPtr;
	D3D12_GPU_VIRTUAL_ADDRESS prevFrameTransformPtr;
	D3D12_GPU_VIRTUAL_ADDRESS objectIDPtr;

	dx_vertex_buffer_group_view vertexBuffer;
	dx_vertex_buffer_view prevFrameVertexBuffer;
	dx_index_buffer_view indexBuffer;

	submesh_info submesh;

	uint32 numInstances;

	dx_cpu_descriptor_handle alphaCutoutTextureSRV = {};
};

struct depth_prepass_pipeline
{
	DEPTH_ONLY_RENDER_DECL(depth_prepass_data);

	struct single_sided;
	struct double_sided;
	struct alpha_cutout;
};

struct depth_prepass_pipeline::single_sided : depth_prepass_pipeline
{
	PIPELINE_SETUP_DECL;
};

struct depth_prepass_pipeline::double_sided : depth_prepass_pipeline
{
	PIPELINE_SETUP_DECL;
};

struct depth_prepass_pipeline::alpha_cutout : depth_prepass_pipeline
{
	PIPELINE_SETUP_DECL;
	DEPTH_ONLY_RENDER_DECL(depth_prepass_data);
};



void initializeDepthPrepassPipelines();

```

`src/rendering/light_probe.cpp`:

```cpp
#include "pch.h"
#include "light_probe.h"
#include "render_utils.h"
#include "render_resources.h"
#include "pbr_raytracer.h"

#include "core/imgui.h"

#include "dx/dx_pipeline.h"
#include "dx/dx_command_list.h"
#include "dx/dx_context.h"
#include "dx/dx_barrier_batcher.h"
#include "dx/dx_profiling.h"

#include "geometry/mesh_builder.h"

#include "light_probe_rs.hlsli"
#include "transform.hlsli"


static dx_pipeline visualizeGridPipeline;
static dx_pipeline visualizeRaysPipeline;

static dx_pipeline probeUpdateIrradiancePipeline;
static dx_pipeline probeUpdateDepthPipeline;

static dx_pipeline testSamplePipeline;

static dx_mesh sphereMesh;
static submesh_info sphereSubmesh;


static const DXGI_FORMAT irradianceFormat = DXGI_FORMAT_R16G16B16A16_FLOAT;// DXGI_FORMAT_R11G11B10_FLOAT;
static const DXGI_FORMAT depthFormat = DXGI_FORMAT_R16G16_FLOAT;
static const DXGI_FORMAT raytracedRadianceFormat = DXGI_FORMAT_R11G11B10_FLOAT;
static const DXGI_FORMAT raytracedDirectionAndDistanceFormat = DXGI_FORMAT_R16G16B16A16_FLOAT;





struct light_probe_tracer : pbr_raytracer
{
	void initialize();

	void render(dx_command_list* cl, const raytracing_tlas& tlas,
		const light_probe_grid& grid,
		const common_render_data& common);

private:

	const uint32 maxRecursionDepth = 2;
	const uint32 maxPayloadSize = 4 * sizeof(float); // Radiance-payload is 1 x float3, 1 x float.


	// Only descriptors in here!
	struct input_resources
	{
		dx_cpu_descriptor_handle tlas;
		dx_cpu_descriptor_handle sky;
		dx_cpu_descriptor_handle irradiance;
		dx_cpu_descriptor_handle depth;
	};

	struct output_resources
	{
		dx_cpu_descriptor_handle radiance;
		dx_cpu_descriptor_handle directionAndDistance;
	};
};




static light_probe_tracer lightProbeTracer;



void initializeLightProbePipelines()
{
	if (!dxContext.featureSupport.raytracing())
	{
		return;
	}

	{
		auto desc = CREATE_GRAPHICS_PIPELINE
			.inputLayout(inputLayout_position)
			.renderTargets(hdrFormat, depthStencilFormat);

		visualizeGridPipeline = createReloadablePipeline(desc, { "light_probe_grid_visualization_vs", "light_probe_grid_visualization_ps" });
	}

	{
		auto desc = CREATE_GRAPHICS_PIPELINE
			.primitiveTopology(D3D12_PRIMITIVE_TOPOLOGY_TYPE_LINE)
			.renderTargets(hdrFormat, depthStencilFormat);

		visualizeRaysPipeline = createReloadablePipeline(desc, { "light_probe_ray_visualization_vs", "light_probe_ray_visualization_ps" });
	}

	{
		auto desc = CREATE_GRAPHICS_PIPELINE
			.inputLayout(inputLayout_position)
			.renderTargets(hdrFormat, depthStencilFormat);

		testSamplePipeline = createReloadablePipeline(desc, { "light_probe_test_sample_vs", "light_probe_test_sample_ps" });
	}

	mesh_builder builder(mesh_creation_flags_with_positions);
	builder.pushSphere({});
	sphereSubmesh = builder.endSubmesh();
	sphereMesh = builder.createDXMesh();
	
	probeUpdateIrradiancePipeline = createReloadablePipeline("light_probe_update_irradiance_cs");
	probeUpdateDepthPipeline = createReloadablePipeline("light_probe_update_depth_cs");

	lightProbeTracer.initialize();
}








void light_probe_grid::initialize(vec3 minCorner, vec3 dimensions, float cellSize)
{
	if (!dxContext.featureSupport.raytracing())
	{
		return;
	}

	uint32 gridSizeX = (uint32)(ceilf(dimensions.x / cellSize));
	uint32 gridSizeY = (uint32)(ceilf(dimensions.y / cellSize));
	uint32 gridSizeZ = (uint32)(ceilf(dimensions.z / cellSize));

	vec3 oldDimensions = dimensions;

	dimensions = vec3((float)gridSizeX, (float)gridSizeY, (float)gridSizeZ) * cellSize;
	minCorner -= (dimensions - oldDimensions) * 0.5f;

	this->minCorner = minCorner;
	this->cellSize = cellSize;

	this->numNodesX = gridSizeX + 1;
	this->numNodesY = gridSizeY + 1;
	this->numNodesZ = gridSizeZ + 1;
	this->totalNumNodes = numNodesX * numNodesY * numNodesZ;

	uint32 irradianceYSliceWidth = numNodesX * LIGHT_PROBE_TOTAL_RESOLUTION;
	uint32 irradianceTexWidth = numNodesY * irradianceYSliceWidth;
	uint32 irradianceTexHeight = numNodesZ * LIGHT_PROBE_TOTAL_RESOLUTION;

	uint32 depthYSliceWidth = numNodesX * LIGHT_PROBE_TOTAL_DEPTH_RESOLUTION;
	uint32 depthTexWidth = numNodesY * depthYSliceWidth;
	uint32 depthTexHeight = numNodesZ * LIGHT_PROBE_TOTAL_DEPTH_RESOLUTION;

#if 0
	struct color_rgba
	{
		uint8 r, g, b, a;
	};

	color_rgba* testBuffer = new color_rgba[irradianceTexWidth * irradianceTexHeight];


	color_rgba testProbe[LIGHT_PROBE_TOTAL_RESOLUTION][LIGHT_PROBE_TOTAL_RESOLUTION] = {};

	for (uint32 ly = 1; ly < LIGHT_PROBE_TOTAL_RESOLUTION - 1; ++ly)
	{
		for (uint32 lx = 1; lx < LIGHT_PROBE_TOTAL_RESOLUTION - 1; ++lx)
		{
			// Subtract the border.
			float x = (float)(lx - 1);
			float y = (float)(ly - 1);

			vec2 uv = (vec2(x, y) + 0.5f) / LIGHT_PROBE_RESOLUTION;
			vec2 oct = uv * 2.f - 1.f;

			vec3 dir = decodeOctahedral(oct);

			vec3 c = lerp(vec3(0.f, 0.f, 1.f), vec3(1.f, 0.f, 0.f), dir.x * 0.5f + 0.5f);
			//vec3 c = vec3(dir.x, 0.f, 0.f);
			testProbe[ly][lx] = { (uint8)(clamp01(c.x) * 255.f), (uint8)(clamp01(c.y) * 255.f), (uint8)(clamp01(c.z) * 255.f), 255 };
			int a = 0;
		}
	}

	// Copy border.
	testProbe[0][0] = testProbe[6][6];
	testProbe[0][7] = testProbe[6][1];
	testProbe[7][0] = testProbe[1][6];
	testProbe[7][7] = testProbe[1][1];

	testProbe[0][1] = testProbe[1][6];
	testProbe[0][2] = testProbe[1][5];
	testProbe[0][3] = testProbe[1][4];
	testProbe[0][4] = testProbe[1][3];
	testProbe[0][5] = testProbe[1][2];
	testProbe[0][6] = testProbe[1][1];

	testProbe[7][1] = testProbe[6][6];
	testProbe[7][2] = testProbe[6][5];
	testProbe[7][3] = testProbe[6][4];
	testProbe[7][4] = testProbe[6][3];
	testProbe[7][5] = testProbe[6][2];
	testProbe[7][6] = testProbe[6][1];
	
	testProbe[1][0] = testProbe[6][1];
	testProbe[2][0] = testProbe[5][1];
	testProbe[3][0] = testProbe[4][1];
	testProbe[4][0] = testProbe[3][1];
	testProbe[5][0] = testProbe[2][1];
	testProbe[6][0] = testProbe[1][1];
	
	testProbe[1][7] = testProbe[6][6];
	testProbe[2][7] = testProbe[5][6];
	testProbe[3][7] = testProbe[4][6];
	testProbe[4][7] = testProbe[3][6];
	testProbe[5][7] = testProbe[2][6];
	testProbe[6][7] = testProbe[1][6];


	for (uint32 z = 0; z < numNodesZ; ++z)
	{
		for (uint32 y = 0; y < numNodesY; ++y)
		{
			for (uint32 x = 0; x < numNodesX; ++x)
			{
				uint32 texStartX = irradianceYSliceWidth * y + x * LIGHT_PROBE_TOTAL_RESOLUTION;
				uint32 texStartY = z * LIGHT_PROBE_TOTAL_RESOLUTION;

				for (uint32 ly = 0; ly < LIGHT_PROBE_TOTAL_RESOLUTION; ++ly)
				{
					for (uint32 lx = 0; lx < LIGHT_PROBE_TOTAL_RESOLUTION; ++lx)
					{
						uint32 gx = texStartX + lx;
						uint32 gy = texStartY + ly;

						uint32 c = irradianceTexWidth * gy + gx;

						testBuffer[c] = testProbe[ly][lx];
					}
				}
			}
		}
	}

	this->irradiance = createTexture(testBuffer, irradianceTexWidth, irradianceTexHeight, DXGI_FORMAT_R8G8B8A8_UNORM, false, false, true, D3D12_RESOURCE_STATE_GENERIC_READ);

	delete[] testBuffer;
#else
	this->irradiance = createTexture(0, irradianceTexWidth, irradianceTexHeight, irradianceFormat, false, false, true);
#endif

	this->depth = createTexture(0, depthTexWidth, depthTexHeight, depthFormat, false, false, true);

	this->raytracedRadiance = createTexture(0, NUM_RAYS_PER_PROBE, totalNumNodes, raytracedRadianceFormat, 0, 0, true, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);
	this->raytracedDirectionAndDistance = createTexture(0, NUM_RAYS_PER_PROBE, totalNumNodes, raytracedDirectionAndDistanceFormat, false, false, true, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);
}


struct visualize_grid_render_data
{
	mat4 transform;
	dx_vertex_buffer_group_view vertexBuffer;
	dx_index_buffer_view indexBuffer;
	submesh_info submesh;

	float cellSize;
	uint32 countX;
	uint32 countY;
	uint32 countZ;
	uint32 total;

	ref<dx_texture> texture0;
	ref<dx_texture> texture1;
};

struct visualize_grid_pipeline
{
	PIPELINE_SETUP_DECL;
	PIPELINE_RENDER_DECL(visualize_grid_render_data);
};


PIPELINE_SETUP_IMPL(visualize_grid_pipeline)
{
	cl->setPipelineState(*visualizeGridPipeline.pipeline);
	cl->setGraphicsRootSignature(*visualizeGridPipeline.rootSignature);
	cl->setPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
}

PIPELINE_RENDER_IMPL(visualize_grid_pipeline, visualize_grid_render_data)
{
	vec2 uvScale = 1.f / vec2((float)(data.countX * data.countY), (float)data.countZ);
	cl->setGraphics32BitConstants(LIGHT_PROBE_GRID_VISUALIZATION_RS_CB, light_probe_grid_visualization_cb{ viewProj * data.transform, uvScale, data.cellSize, data.countX, data.countY });
	cl->setDescriptorHeapSRV(LIGHT_PROBE_GRID_VISUALIZATION_RS_IRRADIANCE, 0, data.texture0);

	cl->setVertexBuffer(0, data.vertexBuffer.positions);
	cl->setVertexBuffer(1, data.vertexBuffer.others);
	cl->setIndexBuffer(data.indexBuffer);
	cl->drawIndexed(data.submesh.numIndices, data.total, data.submesh.firstIndex, data.submesh.baseVertex, 0);
}


struct visualize_rays_render_data
{
	mat4 transform;

	float cellSize;
	uint32 countX;
	uint32 countY;
	uint32 countZ;
	uint32 total;

	ref<dx_texture> texture0;
	ref<dx_texture> texture1;
};

struct visualize_rays_pipeline
{
	PIPELINE_SETUP_DECL;
	PIPELINE_RENDER_DECL(visualize_rays_render_data);
};


PIPELINE_SETUP_IMPL(visualize_rays_pipeline)
{
	cl->setPipelineState(*visualizeRaysPipeline.pipeline);
	cl->setGraphicsRootSignature(*visualizeRaysPipeline.rootSignature);
	cl->setPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_LINELIST);
}

PIPELINE_RENDER_IMPL(visualize_rays_pipeline, visualize_rays_render_data)
{
	cl->setGraphics32BitConstants(LIGHT_PROBE_RAY_VISUALIZATION_RS_CB, light_probe_ray_visualization_cb{ viewProj * data.transform, data.cellSize, data.countX, data.countY });
	cl->setDescriptorHeapSRV(LIGHT_PROBE_RAY_VISUALIZATION_RS_RAYS, 0, data.texture0);
	cl->setDescriptorHeapSRV(LIGHT_PROBE_RAY_VISUALIZATION_RS_RAYS, 1, data.texture1);

	cl->transitionBarrier(data.texture0, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_GENERIC_READ);
	cl->transitionBarrier(data.texture1, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_GENERIC_READ);
	cl->draw(2, NUM_RAYS_PER_PROBE * data.total, 0, 0);
	cl->transitionBarrier(data.texture0, D3D12_RESOURCE_STATE_GENERIC_READ, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);
	cl->transitionBarrier(data.texture1, D3D12_RESOURCE_STATE_GENERIC_READ, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);
}

void light_probe_grid::visualize(opaque_render_pass* renderPass)
{
	if (!dxContext.featureSupport.raytracing() || totalNumNodes == 0)
	{
		return;
	}

	
	if (visualizeProbes)
	{
		mat4 transform = createTranslationMatrix(minCorner);
		visualize_grid_render_data data = 
		{ 
			transform, sphereMesh.vertexBuffer, sphereMesh.indexBuffer, sphereSubmesh, cellSize, numNodesX, numNodesY, numNodesZ, totalNumNodes, irradiance 
		};

		renderPass->renderObject<visualize_grid_pipeline>(data);
	}
	if (visualizeRays)
	{
		mat4 transform = createTranslationMatrix(minCorner);
		visualize_rays_render_data data = { transform, cellSize, numNodesX, numNodesY, numNodesZ, totalNumNodes, raytracedRadiance, raytracedDirectionAndDistance };

		renderPass->renderObject<visualize_rays_pipeline>(data);
	}
}

void light_probe_grid::updateProbes(dx_command_list* cl, const raytracing_tlas& lightProbeTlas, const common_render_data& common) const
{
	if (!dxContext.featureSupport.raytracing() || totalNumNodes == 0)
	{
		return;
	}

	if (autoRotateRays || rotateRays)
	{
		rayRotation = rng.randomRotation();
		rotateRays = false;
	}


	lightProbeTracer.finalizeForRender();
	lightProbeTracer.render(cl, lightProbeTlas, *this, common);
}




#define LIGHT_PROBE_TRACING_RS_RESOURCES	0
#define LIGHT_PROBE_TRACING_RS_CB			1
#define LIGHT_PROBE_TRACING_RS_SUN			2


void light_probe_tracer::initialize()
{
	const wchar* shaderPath = L"shaders/light_probe/light_probe_trace_rts.hlsl";


	const uint32 numInputResources = sizeof(input_resources) / sizeof(dx_cpu_descriptor_handle);
	const uint32 numOutputResources = sizeof(output_resources) / sizeof(dx_cpu_descriptor_handle);

	CD3DX12_DESCRIPTOR_RANGE resourceRanges[] =
	{
		// Must be input first, then output.
		CD3DX12_DESCRIPTOR_RANGE(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, numInputResources, 0),
		CD3DX12_DESCRIPTOR_RANGE(D3D12_DESCRIPTOR_RANGE_TYPE_UAV, numOutputResources, 0),
	};

	CD3DX12_ROOT_PARAMETER globalRootParameters[] =
	{
		root_descriptor_table(arraysize(resourceRanges), resourceRanges),
		root_constants<light_probe_trace_cb>(0),
		root_cbv(1),
	};

	CD3DX12_STATIC_SAMPLER_DESC globalStaticSampler(0, D3D12_FILTER_MIN_MAG_MIP_LINEAR);

	D3D12_ROOT_SIGNATURE_DESC globalDesc =
	{
		arraysize(globalRootParameters), globalRootParameters,
		1, &globalStaticSampler
	};
	
	pbr_raytracer::initialize(shaderPath, maxPayloadSize, maxRecursionDepth, globalDesc);

	allocateDescriptorHeapSpaceForGlobalResources<input_resources, output_resources>(descriptorHeap);
}

void light_probe_tracer::render(dx_command_list* cl, const raytracing_tlas& tlas, const light_probe_grid& grid, const common_render_data& common)
{
	if (!tlas.tlas || grid.totalNumNodes == 0)
	{
		return;
	}

	{
		PROFILE_ALL(cl, "Raytrace probes");

		input_resources in;
		in.tlas = tlas.tlas->raytracingSRV;
		in.sky = common.sky->defaultSRV;
		in.irradiance = grid.irradiance->defaultSRV;
		in.depth = grid.depth->defaultSRV;

		output_resources out;
		out.radiance = grid.raytracedRadiance->defaultUAV;
		out.directionAndDistance = grid.raytracedDirectionAndDistance->defaultUAV;


		dx_gpu_descriptor_handle gpuHandle = copyGlobalResourcesToDescriptorHeap(in, out);


		// Fill out description.
		D3D12_DISPATCH_RAYS_DESC raytraceDesc;
		fillOutRayTracingRenderDesc(bindingTable.getBuffer(), raytraceDesc,
			NUM_RAYS_PER_PROBE, grid.totalNumNodes, 1,
			numRayTypes, bindingTable.getNumberOfHitGroups());


		// Set up pipeline.
		cl->setDescriptorHeap(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV, descriptorHeap.descriptorHeap);

		cl->setPipelineState(pipeline.pipeline);
		cl->setComputeRootSignature(pipeline.rootSignature);

		light_probe_trace_cb cb;
		cb.rayRotation = createModelMatrix(0.f, grid.rayRotation);
		cb.grid = grid.getCB();
		cb.sampleSkyFromTexture = !common.proceduralSky;

		cl->setComputeDescriptorTable(LIGHT_PROBE_TRACING_RS_RESOURCES, gpuHandle);
		cl->setCompute32BitConstants(LIGHT_PROBE_TRACING_RS_CB, cb);
		cl->setComputeDynamicConstantBuffer(LIGHT_PROBE_TRACING_RS_SUN, common.lightingCBV);

		cl->raytrace(raytraceDesc);

		cl->resetToDynamicDescriptorHeap();
	}

	barrier_batcher(cl)
		.transition(grid.raytracedRadiance, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE)
		.transition(grid.raytracedDirectionAndDistance, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE)
		.transition(grid.irradiance, D3D12_RESOURCE_STATE_COMMON, D3D12_RESOURCE_STATE_UNORDERED_ACCESS)
		.transition(grid.depth, D3D12_RESOURCE_STATE_COMMON, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);

	{
		PROFILE_ALL(cl, "Update irradiance");

		cl->setPipelineState(*probeUpdateIrradiancePipeline.pipeline);
		cl->setComputeRootSignature(*probeUpdateIrradiancePipeline.rootSignature);

		light_probe_update_cb cb;
		cb.countX = grid.numNodesX;
		cb.countY = grid.numNodesY;
		
		cl->setCompute32BitConstants(LIGHT_PROBE_UPDATE_RS_CB, cb);
		cl->setDescriptorHeapSRV(LIGHT_PROBE_UPDATE_RS_RAYTRACE_RESULTS, 0, grid.raytracedRadiance);
		cl->setDescriptorHeapSRV(LIGHT_PROBE_UPDATE_RS_RAYTRACE_RESULTS, 1, grid.raytracedDirectionAndDistance);
		cl->setDescriptorHeapUAV(LIGHT_PROBE_UPDATE_RS_RAYTRACE_RESULTS, 2, grid.irradiance);

		cl->dispatch(bucketize(grid.irradiance->width, LIGHT_PROBE_BLOCK_SIZE), bucketize(grid.irradiance->height, LIGHT_PROBE_BLOCK_SIZE));
	}

#if 0
	{
		PROFILE_ALL(cl, "Update depth");

		cl->setPipelineState(*probeUpdateDepthPipeline.pipeline);
		cl->setComputeRootSignature(*probeUpdateDepthPipeline.rootSignature);

		light_probe_update_cb cb;
		cb.countX = grid.numNodesX;
		cb.countY = grid.numNodesY;

		cl->setCompute32BitConstants(LIGHT_PROBE_UPDATE_RS_CB, cb);
		cl->setDescriptorHeapSRV(LIGHT_PROBE_UPDATE_RS_RAYTRACE_RESULTS, 0, grid.raytracedRadiance);
		cl->setDescriptorHeapSRV(LIGHT_PROBE_UPDATE_RS_RAYTRACE_RESULTS, 1, grid.raytracedDirectionAndDistance);
		cl->setDescriptorHeapUAV(LIGHT_PROBE_UPDATE_RS_RAYTRACE_RESULTS, 2, grid.depth);

		cl->dispatch(bucketize(grid.depth->width, LIGHT_PROBE_BLOCK_SIZE), bucketize(grid.depth->height, LIGHT_PROBE_BLOCK_SIZE));
	}
#endif

	barrier_batcher(cl)
		.transition(grid.raytracedRadiance, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_UNORDERED_ACCESS)
		.transition(grid.raytracedDirectionAndDistance, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_UNORDERED_ACCESS)
		.transition(grid.irradiance, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_COMMON)
		.transition(grid.depth, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_COMMON);

}

```

`src/rendering/light_probe.h`:

```h
#pragma once

#include "core/math.h"
#include "core/random.h"
#include "dx/dx_texture.h"

#include "render_pass.h"

#include "light_probe.hlsli"

struct light_probe_grid
{
	vec3 minCorner;
	float cellSize;

	uint32 numNodesX;
	uint32 numNodesY;
	uint32 numNodesZ;
	uint32 totalNumNodes = 0;

	ref<dx_texture> irradiance;
	ref<dx_texture> depth;

	ref<dx_texture> raytracedRadiance;
	ref<dx_texture> raytracedDirectionAndDistance;

	void initialize(vec3 minCorner, vec3 dimensions, float cellSize);
	void visualize(opaque_render_pass* renderPass);

	void updateProbes(dx_command_list* cl, const struct raytracing_tlas& lightProbeTlas, const common_render_data& common) const;

	light_probe_grid_cb getCB() const { return { minCorner, cellSize, numNodesX, numNodesY, numNodesZ }; }


private:
	bool visualizeProbes = false;
	bool visualizeRays = false;
	bool autoRotateRays = true;

	mutable bool rotateRays = false;

	float irradianceUIScale = 1.f;
	float depthUIScale = 1.f;
	float raytracedRadianceUIScale = 1.f;

	mutable quat rayRotation = quat::identity;
	mutable random_number_generator rng = { 61913 };

	friend struct light_probe_tracer;
	friend struct scene_editor;
};

void initializeLightProbePipelines();



```

`src/rendering/light_source.cpp`:

```cpp
#include "pch.h"
#include "light_source.h"


void directional_light::updateMatrices(const render_camera& camera)
{
	camera_frustum_corners worldFrustum = camera.getWorldSpaceFrustumCorners(cascadeDistances.w);

	vec3 bottomLeftRay = worldFrustum.farBottomLeft - worldFrustum.nearBottomLeft;
	vec3 bottomRightRay = worldFrustum.farBottomRight - worldFrustum.nearBottomRight;
	vec3 topLeftRay = worldFrustum.farTopLeft - worldFrustum.nearTopLeft;
	vec3 topRightRay = worldFrustum.farTopRight - worldFrustum.nearTopRight;

	vec3 cameraForward = camera.rotation * vec3(0.f, 0.f, -1.f);

	bottomLeftRay /= dot(bottomLeftRay, cameraForward);
	bottomRightRay /= dot(bottomRightRay, cameraForward);
	topLeftRay /= dot(topLeftRay, cameraForward);
	topRightRay /= dot(topRightRay, cameraForward);


	for (uint32 cascade = 0; cascade < numShadowCascades; ++cascade)
	{
		float prevDistance = (cascade == 0) ? camera.nearPlane : (cascadeDistances.data[cascade - 1] - blendDistances.data[cascade - 1]);
		float distance = cascadeDistances.data[cascade];

		vec3 corners[8];
		corners[0] = camera.position + bottomLeftRay * prevDistance;
		corners[1] = camera.position + bottomRightRay * prevDistance;
		corners[2] = camera.position + topLeftRay * prevDistance;
		corners[3] = camera.position + topRightRay * prevDistance;
		corners[4] = camera.position + bottomLeftRay * distance;
		corners[5] = camera.position + bottomRightRay * distance;
		corners[6] = camera.position + topLeftRay * distance;
		corners[7] = camera.position + topRightRay * distance;

		vec3 center(0.f);
		for (uint32 i = 0; i < 8; ++i)
		{
			center += corners[i];
		}
		center /= 8.f;

		vec3 upDir = vec3(0.f, 1.f, 0.f);
		if (abs(dot(upDir, direction)) > 1.f - EPSILON)
		{
			upDir = vec3(0.f, 0.f, 1.f);
		}

		mat4 viewMatrix = lookAt(center, center + direction, upDir);

		vec3 minExtents, maxExtents;
		if (stabilize)
		{
			vec3 viewCenter = transformPosition(viewMatrix, center);

			float sphereRadius = 0.f;
			for (uint32 i = 0; i < 8; ++i)
			{
				float d = length(transformPosition(viewMatrix, corners[i]) - viewCenter);
				sphereRadius = max(sphereRadius, d);
			}

			sphereRadius = ceil(sphereRadius * 16.f) / 16.f;
			minExtents = -sphereRadius;
			maxExtents = sphereRadius;
		}
		else
		{
			bounding_box extents = bounding_box::negativeInfinity();
			for (uint32 i = 0; i < 8; ++i)
			{
				vec3 c = transformPosition(viewMatrix, corners[i]);
				extents.grow(c);
			}

			minExtents = extents.minCorner;
			maxExtents = extents.maxCorner;

			//float scale = (shadowDimensions + 9.f) / shadowDimensions;
			//minExtents.xy *= scale;
			//maxExtents.xy *= scale;
		}

		vec3 cascadeExtents = maxExtents - minExtents;
		vec3 shadowCamPos = center + direction * minExtents.z;

		//viewMatrix = lookAt(shadowCamPos, shadowCamPos + direction, upDir);

		mat4 projMatrix = createOrthographicProjectionMatrix(maxExtents.x, minExtents.x, maxExtents.y, minExtents.y, -negativeZOffset, cascadeExtents.z);

		//if (stabilize)
		{
			mat4 matrix = projMatrix * viewMatrix;
			vec3 shadowOrigin(0.f);
			shadowOrigin = (matrix * vec4(shadowOrigin, 1.f)).xyz;
			shadowOrigin *= (shadowDimensions * 0.5f);

			vec3 roundedOrigin = round(shadowOrigin);
			vec3 roundOffset = roundedOrigin - shadowOrigin;
			roundOffset = roundOffset * (2.f / shadowDimensions);

			projMatrix.m03 += roundOffset.x;
			projMatrix.m13 += roundOffset.y;
		}

		viewProjs[cascade] = projMatrix * viewMatrix;
	}
}

mat4 getSpotLightViewProjectionMatrix(const spot_light_cb& sl)
{
	mat4 viewMatrix = lookAt(sl.position, sl.position + sl.direction, vec3(0.f, 1.f, 0.f));
	mat4 projMatrix = createPerspectiveProjectionMatrix(acos(sl.getOuterCutoff()) * 2.f, 1.f, 0.01f, sl.maxDistance);
	return projMatrix * viewMatrix;
}

```

`src/rendering/light_source.h`:

```h
#pragma once

#include "core/math.h"
#include "core/camera.h"
#include "core/reflect.h"

#include "light_source.hlsli"

struct directional_light
{
	vec3 color;
	float intensity; // Final radiance is color * intensity.

	vec3 direction;
	uint32 numShadowCascades;

	vec4 cascadeDistances;
	vec4 bias;

	vec4 shadowMapViewports[MAX_NUM_SUN_SHADOW_CASCADES];
	mat4 viewProjs[MAX_NUM_SUN_SHADOW_CASCADES];

	vec4 blendDistances;
	uint32 shadowDimensions = 2048;

	float negativeZOffset = 500.f;

	bool stabilize;

	void updateMatrices(const render_camera& camera);
};
REFLECT_STRUCT(directional_light,
	(color, "Color"),
	(intensity, "Intensity"),
	(direction, "Direction"),
	(numShadowCascades, "Cascades"),
	(cascadeDistances, "Cascade distances"),
	(bias, "Bias"),
	(blendDistances, "Blend distances"),
	(shadowDimensions, "Shadow dimensions"),
	(stabilize, "Stabilize")
);

struct point_light_component
{
	vec3 color;
	float intensity; // Final radiance is color * intensity.
	float radius;
	bool castsShadow;
	uint32 shadowMapResolution;

	point_light_component() {}
	point_light_component(vec3 color, float intensity, float radius, bool castsShadow = false, uint32 shadowMapResolution = 512)
		: color(color), intensity(intensity), radius(radius), castsShadow(castsShadow), shadowMapResolution(shadowMapResolution) {}
	point_light_component(const point_light_component&) = default;
};
REFLECT_STRUCT(point_light_component,
	(color, "Color"),
	(intensity, "Intensity"),
	(radius, "Radius"),
	(castsShadow, "Casts shadow"),
	(shadowMapResolution, "Shadow resolution")
);

struct spot_light_component
{
	vec3 color;
	float intensity; // Final radiance is color * intensity.
	float distance;
	float innerAngle;
	float outerAngle;
	bool castsShadow;
	uint32 shadowMapResolution;

	spot_light_component() {}
	spot_light_component(vec3 color, float intensity, float distance, float innerAngle, float outerAngle, bool castsShadow = false, uint32 shadowMapResolution = 512)
		: color(color), intensity(intensity), distance(distance), innerAngle(innerAngle), outerAngle(outerAngle), castsShadow(castsShadow), shadowMapResolution(shadowMapResolution) {}
	spot_light_component(const spot_light_component&) = default;
};
REFLECT_STRUCT(spot_light_component,
	(color, "Color"),
	(intensity, "Intensity"),
	(distance, "Distance"),
	(innerAngle, "Inner angle"),
	(outerAngle, "Outer angle"),
	(castsShadow, "Casts shadow"),
	(shadowMapResolution, "Shadow resolution")
);

mat4 getSpotLightViewProjectionMatrix(const spot_light_cb& sl);


```

`src/rendering/main_renderer.cpp`:

```cpp
#include "pch.h"
#include "main_renderer.h"
#include "dx/dx_command_list.h"
#include "dx/dx_render_target.h"
#include "dx/dx_pipeline.h"
#include "dx/dx_texture.h"
#include "dx/dx_barrier_batcher.h"
#include "dx/dx_profiling.h"

#include "raytracing.h"
#include "raytraced_reflections.h"
#include "particles/particles.h"

#include "core/job_system.h"

#include "light_source.hlsli"



#define SSR_RAYCAST_WIDTH (renderWidth / 2)
#define SSR_RAYCAST_HEIGHT (renderHeight / 2)

#define SSR_RESOLVE_WIDTH (renderWidth / 2)
#define SSR_RESOLVE_HEIGHT (renderHeight / 2)



void main_renderer::initialize(color_depth colorDepth, uint32 windowWidth, uint32 windowHeight, renderer_spec spec)
{
	this->windowWidth = windowWidth;
	this->windowHeight = windowHeight;
	const_cast<renderer_spec&>(this->spec) = spec;

	settings.enableSharpen = spec.allowTAA;
	spec.allowSSR |= dxContext.featureSupport.raytracing(); // For now, since raytraced reflections use the same intermediate textures.

	recalculateViewport(false);

	hdrColorTexture = createTexture(0, renderWidth, renderHeight, hdrFormat, false, true, true, D3D12_RESOURCE_STATE_RENDER_TARGET);
	SET_NAME(hdrColorTexture->resource, "HDR Color");

	if (spec.allowSSR)
	{
		D3D12_RESOURCE_DESC prevFrameHDRColorDesc = CD3DX12_RESOURCE_DESC::Tex2D(hdrFormat, renderWidth / 2, renderHeight / 2, 1,
			8, 1, 0, D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS);
		prevFrameHDRColorTexture = createTexture(prevFrameHDRColorDesc, 0, 0, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, true);
		prevFrameHDRColorTempTexture = createTexture(prevFrameHDRColorDesc, 0, 0, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, true);

		SET_NAME(prevFrameHDRColorTexture->resource, "Prev frame HDR Color");
		SET_NAME(prevFrameHDRColorTempTexture->resource, "Prev frame HDR Color Temp");
	}

	// If object picking is allowed, but none of the others, we still have to allocate screen velocities due to dumb internal reasons with our render targets.
	if (spec.allowSSR || spec.allowTAA || spec.allowAO || spec.allowObjectPicking)
	{
		screenVelocitiesTexture = createTexture(0, renderWidth, renderHeight, screenVelocitiesFormat, false, true, false, D3D12_RESOURCE_STATE_RENDER_TARGET);
		SET_NAME(screenVelocitiesTexture->resource, "Screen velocities");
	}


	worldNormalsRoughnessTexture = createTexture(0, renderWidth, renderHeight, worldNormalsRoughnessFormat, false, true, false, D3D12_RESOURCE_STATE_GENERIC_READ);
	SET_NAME(worldNormalsRoughnessTexture->resource, "World normals / roughness");



	depthStencilBuffer = createDepthTexture(renderWidth, renderHeight, depthStencilFormat);
	opaqueDepthBuffer = createDepthTexture(renderWidth, renderHeight, depthStencilFormat, 1, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE | D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE);
	D3D12_RESOURCE_DESC linearDepthDesc = CD3DX12_RESOURCE_DESC::Tex2D(linearDepthFormat, renderWidth, renderHeight, 1,
		6, 1, 0, D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS);
	linearDepthBuffer = createTexture(linearDepthDesc, 0, 0, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, true);
	SET_NAME(depthStencilBuffer->resource, "Depth buffer");
	SET_NAME(opaqueDepthBuffer->resource, "Opaque depth buffer");
	SET_NAME(linearDepthBuffer->resource, "Linear depth buffer");


	if (spec.allowAO)
	{
		aoCalculationTexture = createTexture(0, renderWidth / 2, renderHeight / 2, aoFormat, false, false, true, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);
		aoBlurTempTexture = createTexture(0, renderWidth, renderHeight, aoFormat, false, false, true, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);
		aoTextures[aoHistoryIndex] = createTexture(0, renderWidth, renderHeight, aoFormat, false, false, true, D3D12_RESOURCE_STATE_GENERIC_READ);
		aoTextures[1 - aoHistoryIndex] = createTexture(0, renderWidth, renderHeight, aoFormat, false, false, true, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);

		SET_NAME(aoCalculationTexture->resource, "AO Calculation");
		SET_NAME(aoBlurTempTexture->resource, "AO Temp");
		SET_NAME(aoTextures[0]->resource, "AO 0");
		SET_NAME(aoTextures[1]->resource, "AO 1");
	}

	if (spec.allowSSS)
	{
		sssCalculationTexture = createTexture(0, renderWidth / 2, renderHeight / 2, sssFormat, false, false, true, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);
		sssBlurTempTexture = createTexture(0, renderWidth, renderHeight, sssFormat, false, false, true, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);
		sssTextures[sssHistoryIndex] = createTexture(0, renderWidth, renderHeight, sssFormat, false, false, true, D3D12_RESOURCE_STATE_GENERIC_READ);
		sssTextures[1 - sssHistoryIndex] = createTexture(0, renderWidth, renderHeight, sssFormat, false, false, true, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);

		SET_NAME(sssCalculationTexture->resource, "SSS Calculation");
		SET_NAME(sssBlurTempTexture->resource, "SSS Temp");
		SET_NAME(sssTextures[0]->resource, "SSS 0");
		SET_NAME(sssTextures[1]->resource, "SSS 1");
	}

	if (spec.allowSSR)
	{
		ssrRaycastTexture = createTexture(0, SSR_RAYCAST_WIDTH, SSR_RAYCAST_HEIGHT, hdrFormat, false, false, true, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);
		ssrResolveTexture = createTexture(0, SSR_RESOLVE_WIDTH, SSR_RESOLVE_HEIGHT, hdrFormat, false, false, true, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);
		ssrTemporalTextures[ssrHistoryIndex] = createTexture(0, SSR_RESOLVE_WIDTH, SSR_RESOLVE_HEIGHT, hdrFormat, false, false, true, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE);
		ssrTemporalTextures[1 - ssrHistoryIndex] = createTexture(0, SSR_RESOLVE_WIDTH, SSR_RESOLVE_HEIGHT, hdrFormat, false, false, true, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);

		SET_NAME(ssrRaycastTexture->resource, "SSR Raycast");
		SET_NAME(ssrResolveTexture->resource, "SSR Resolve");
		SET_NAME(ssrTemporalTextures[0]->resource, "SSR Temporal 0");
		SET_NAME(ssrTemporalTextures[1]->resource, "SSR Temporal 1");
	}


	hdrPostProcessingTexture = createTexture(0, renderWidth, renderHeight, hdrFormat, false, true, true, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE);
	SET_NAME(hdrPostProcessingTexture->resource, "HDR Post processing");


	ldrPostProcessingTexture = createTexture(0, renderWidth, renderHeight, ldrFormat, false, true, true, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);
	SET_NAME(ldrPostProcessingTexture->resource, "LDR Post processing");


	if (spec.allowTAA)
	{
		taaTextures[taaHistoryIndex] = createTexture(0, renderWidth, renderHeight, hdrFormat, false, true, true, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE);
		taaTextures[1 - taaHistoryIndex] = createTexture(0, renderWidth, renderHeight, hdrFormat, false, true, true, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);

		SET_NAME(taaTextures[0]->resource, "TAA 0");
		SET_NAME(taaTextures[1]->resource, "TAA 1");
	}

	if (spec.allowBloom)
	{
		D3D12_RESOURCE_DESC bloomDesc = CD3DX12_RESOURCE_DESC::Tex2D(hdrFormat, renderWidth / 4, renderHeight / 4, 1,
			5, 1, 0, D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS);
		bloomTexture = createTexture(bloomDesc, 0, 0, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, true);
		bloomTempTexture = createTexture(bloomDesc, 0, 0, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, true);

		SET_NAME(bloomTexture->resource, "Bloom");
		SET_NAME(bloomTempTexture->resource, "Bloom Temp");
	}


	frameResult = createTexture(0, windowWidth, windowHeight, colorDepthToFormat(colorDepth), false, true, true);
	SET_NAME(frameResult->resource, "Frame result");



	if (spec.allowObjectPicking)
	{
		hoveredObjectIDReadbackBuffer = createReadbackBuffer(getFormatSize(objectIDsFormat), NUM_BUFFERED_FRAMES);

		objectIDsTexture = createTexture(0, renderWidth, renderHeight, objectIDsFormat, false, true, false, D3D12_RESOURCE_STATE_RENDER_TARGET);
		SET_NAME(objectIDsTexture->resource, "Object IDs");
	}

	if (dxContext.featureSupport.raytracing())
	{
		pathTracer.initialize();
	}
}

void main_renderer::beginFrame(uint32 windowWidth, uint32 windowHeight)
{
	if (this->windowWidth != windowWidth || this->windowHeight != windowHeight)
	{
		this->windowWidth = windowWidth;
		this->windowHeight = windowHeight;

		// Frame result.
		resizeTexture(frameResult, windowWidth, windowHeight);

		recalculateViewport(true);
	}

	if (objectIDsTexture && windowHovered)
	{
		uint32* id = (uint32*)mapBuffer(hoveredObjectIDReadbackBuffer, true, map_range{ dxContext.bufferedFrameID, 1 });
		hoveredObjectID = *id;
		unmapBuffer(hoveredObjectIDReadbackBuffer, false);
	}
	else
	{
		hoveredObjectID = -1;
	}

	opaqueRenderPass = 0;
	transparentRenderPass = 0;
	ldrRenderPass = 0;
	computePass = 0;


	numSunLightShadowRenderPasses = 0;
	numSpotLightShadowRenderPasses = 0;
	numPointLightShadowRenderPasses = 0;

	environment = 0;
	tlas = 0;

	pointLights = 0;
	spotLights = 0;
	numPointLights = 0;
	numSpotLights = 0;
	decals = 0;
	numDecals = 0;
	decalTextureAtlas = 0;
}

void main_renderer::recalculateViewport(bool resizeTextures)
{
	if (aspectRatioMode == aspect_ratio_free)
	{
		renderWidth = windowWidth;
		renderHeight = windowHeight;
		windowXOffset = 0;
		windowYOffset = 0;
	}
	else
	{
		const float targetAspect = aspectRatioMode == aspect_ratio_fix_16_9 ? (16.f / 9.f) : (16.f / 10.f);

		float aspect = (float)windowWidth / (float)windowHeight;
		if (aspect > targetAspect)
		{
			renderWidth = (uint32)(windowHeight * targetAspect);
			renderHeight = windowHeight;
			windowXOffset = (int32)(windowWidth - renderWidth) / 2;
			windowYOffset = 0;
		}
		else
		{
			renderWidth = windowWidth;
			renderHeight = (uint32)(windowWidth / targetAspect);
			windowXOffset = 0;
			windowYOffset = (int32)(windowHeight - renderHeight) / 2;
		}
	}


	if (resizeTextures)
	{
		resizeTexture(hdrColorTexture, renderWidth, renderHeight);
		resizeTexture(prevFrameHDRColorTexture, renderWidth / 2, renderHeight / 2);
		resizeTexture(prevFrameHDRColorTempTexture, renderWidth / 2, renderHeight / 2);
		resizeTexture(worldNormalsRoughnessTexture, renderWidth, renderHeight);
		resizeTexture(screenVelocitiesTexture, renderWidth, renderHeight);
		resizeTexture(depthStencilBuffer, renderWidth, renderHeight);
		resizeTexture(opaqueDepthBuffer, renderWidth, renderHeight);
		resizeTexture(linearDepthBuffer, renderWidth, renderHeight);

		resizeTexture(aoCalculationTexture, renderWidth / 2, renderHeight / 2);
		resizeTexture(aoBlurTempTexture, renderWidth, renderHeight);
		resizeTexture(aoTextures[aoHistoryIndex], renderWidth, renderHeight, D3D12_RESOURCE_STATE_GENERIC_READ);
		resizeTexture(aoTextures[1 - aoHistoryIndex], renderWidth, renderHeight, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);

		resizeTexture(sssCalculationTexture, renderWidth / 2, renderHeight / 2);
		resizeTexture(sssBlurTempTexture, renderWidth, renderHeight);
		resizeTexture(sssTextures[sssHistoryIndex], renderWidth, renderHeight, D3D12_RESOURCE_STATE_GENERIC_READ);
		resizeTexture(sssTextures[1 - sssHistoryIndex], renderWidth, renderHeight, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);

		resizeTexture(objectIDsTexture, renderWidth, renderHeight);

		resizeTexture(ssrRaycastTexture, SSR_RAYCAST_WIDTH, SSR_RAYCAST_HEIGHT);
		resizeTexture(ssrResolveTexture, SSR_RESOLVE_WIDTH, SSR_RESOLVE_HEIGHT);
		resizeTexture(ssrTemporalTextures[ssrHistoryIndex], SSR_RESOLVE_WIDTH, SSR_RESOLVE_HEIGHT, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE);
		resizeTexture(ssrTemporalTextures[1 - ssrHistoryIndex], SSR_RESOLVE_WIDTH, SSR_RESOLVE_HEIGHT, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);

		resizeTexture(hdrPostProcessingTexture, renderWidth, renderHeight);

		resizeTexture(taaTextures[taaHistoryIndex], renderWidth, renderHeight, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE);
		resizeTexture(taaTextures[1 - taaHistoryIndex], renderWidth, renderHeight, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);

		resizeTexture(bloomTexture, renderWidth / 4, renderHeight / 4);
		resizeTexture(bloomTempTexture, renderWidth / 4, renderHeight / 4);

		resizeTexture(ldrPostProcessingTexture, renderWidth, renderHeight);
	}

	culling.allocateIfNecessary(renderWidth, renderHeight);
}

void main_renderer::setCamera(const render_camera& camera)
{
	buildCameraConstantBuffer(camera, settings.taaSettings.cameraJitterStrength * settings.enableTAA, this->jitteredCamera);
	buildCameraConstantBuffer(camera, 0.f, this->unjitteredCamera);
}

void main_renderer::setEnvironment(const pbr_environment& environment)
{
	main_renderer::environment = &environment;
}

void main_renderer::setSun(const directional_light& light)
{
	sun.cascadeDistances = light.cascadeDistances;
	sun.bias = light.bias;
	sun.direction = light.direction;
	sun.blendDistances = light.blendDistances;
	sun.radiance = light.color * light.intensity;
	sun.numShadowCascades = light.numShadowCascades;

	memcpy(sun.viewProjs, light.viewProjs, sizeof(mat4) * light.numShadowCascades);
	memcpy(sun.viewports, light.shadowMapViewports, sizeof(vec4) * light.numShadowCascades);
}

void main_renderer::setPointLights(const ref<dx_buffer>& lights, uint32 numLights, const ref<dx_buffer>& shadowInfoBuffer)
{
	pointLights = lights;
	numPointLights = numLights;
	pointLightShadowInfoBuffer = shadowInfoBuffer;
}

void main_renderer::setSpotLights(const ref<dx_buffer>& lights, uint32 numLights, const ref<dx_buffer>& shadowInfoBuffer)
{
	spotLights = lights;
	numSpotLights = numLights;
	spotLightShadowInfoBuffer = shadowInfoBuffer;
}

void main_renderer::setDecals(const ref<dx_buffer>& decals, uint32 numDecals, const ref<dx_texture>& textureAtlas)
{
	ASSERT(numDecals < MAX_NUM_TOTAL_DECALS);
	main_renderer::decals = decals;
	main_renderer::numDecals = numDecals;
	main_renderer::decalTextureAtlas = textureAtlas;
}

template <typename func_t>
uint64 main_renderer::executeComputeTasks(compute_pass_event eventTime, const func_t& additionalTasksCallback)
{
	uint64 result = 0;

	bool hasComputePassEvents = computePass && computePass->passes[eventTime].size() > 0;
	bool hasAdditionalTasks = !std::is_null_pointer_v<func_t>;

	if (hasComputePassEvents || hasAdditionalTasks)
	{
		dx_command_list* cl = dxContext.getFreeComputeCommandList(true);

		if (hasComputePassEvents)
		{
			for (const auto& dc : computePass->passes[eventTime])
			{
				dc.compute(cl, dc.data);
			}
		}

		if constexpr (!std::is_null_pointer_v<func_t>)
		{
			additionalTasksCallback(cl);
		}

		result = dxContext.executeCommandList(cl);
	}

	return result;
}

dx_command_list* main_renderer::renderThread0(const common_render_data& commonRenderData)
{
	dx_command_list* cl = dxContext.getFreeRenderCommandList();
	PROFILE_ALL(cl, "Render thread 0");

	{
		PROFILE_ALL(cl, "Shadow maps");

		cl->setPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

		cl->transitionBarrier(render_resources::shadowMap, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_DEPTH_WRITE);

		shadowPasses(cl, sunShadowRenderPasses, numSunLightShadowRenderPasses,
			spotLightShadowRenderPasses, numSpotLightShadowRenderPasses,
			pointLightShadowRenderPasses, numPointLightShadowRenderPasses,
			commonRenderData);

		cl->transitionBarrier(render_resources::shadowMap, D3D12_RESOURCE_STATE_DEPTH_WRITE, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE);
	}

	return cl;
}

dx_command_list* main_renderer::renderThread1(const common_render_data& commonRenderData, bool aspectRatioModeChanged)
{
	dx_command_list* cl = dxContext.getFreeRenderCommandList();
	PROFILE_ALL(cl, "Render thread 1");

	if (aspectRatioModeChanged)
	{
		cl->transitionBarrier(frameResult, D3D12_RESOURCE_STATE_COMMON, D3D12_RESOURCE_STATE_RENDER_TARGET);
		cl->clearRTV(frameResult, 0.f, 0.f, 0.f);
		cl->transitionBarrier(frameResult, D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_COMMON);
	}



	cl->clearDepthAndStencil(depthStencilBuffer);


	// ----------------------------------------
	// DEPTH-ONLY PASS
	// ----------------------------------------

	auto depthOnlyRenderTarget = dx_render_target(renderWidth, renderHeight)
		.colorAttachment(screenVelocitiesTexture, render_resources::nullScreenVelocitiesRTV)
		.colorAttachment(objectIDsTexture, render_resources::nullObjectIDsRTV)
		.depthAttachment(depthStencilBuffer);

	depthPrePass(cl, depthOnlyRenderTarget, opaqueRenderPass,
		jitteredCamera.viewProj, jitteredCamera.prevFrameViewProj, commonRenderData);


	barrier_batcher(cl)
		.transition(depthStencilBuffer, D3D12_RESOURCE_STATE_DEPTH_WRITE, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE);


	// ----------------------------------------
	// LIGHT & DECAL CULLING
	// ----------------------------------------

	lightAndDecalCulling(cl, depthStencilBuffer, pointLights, spotLights, decals, culling, numPointLights, numSpotLights, numDecals, commonRenderData.cameraCBV);


	// ----------------------------------------
	// LINEAR DEPTH PYRAMID
	// ----------------------------------------

	linearDepthPyramid(cl, depthStencilBuffer, linearDepthBuffer, jitteredCamera.projectionParams);


	barrier_batcher(cl)
		//.uav(linearDepthBuffer)
		.transition(linearDepthBuffer, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE)
		.transition(depthStencilBuffer, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_DEPTH_WRITE);

	return cl;
}

dx_command_list* main_renderer::renderThread2(const common_render_data& commonRenderData, const user_input* input)
{
	dx_command_list* cl = dxContext.getFreeRenderCommandList();
	PROFILE_ALL(cl, "Render thread 2");


	// ----------------------------------------
	// SKY PASS
	// ----------------------------------------

	auto skyRenderTarget = dx_render_target(renderWidth, renderHeight)
		.colorAttachment(hdrColorTexture)
		.colorAttachment(screenVelocitiesTexture, render_resources::nullScreenVelocitiesRTV)
		.colorAttachment(objectIDsTexture, render_resources::nullObjectIDsRTV)
		.depthAttachment(depthStencilBuffer);

	if (environment && !environment->isProcedural())
	{
		ASSERT(environment->sky);

		texturedSky(cl, skyRenderTarget, jitteredCamera.proj, jitteredCamera.view, jitteredCamera.prevFrameView, environment->sky, environment->skyIntensity,
			jitteredCamera.jitter, jitteredCamera.prevFrameJitter);
	}
	else
	{
		proceduralSky(cl, skyRenderTarget, jitteredCamera.proj, jitteredCamera.view, jitteredCamera.prevFrameView, sun.direction, environment ? environment->skyIntensity : 1.f,
			jitteredCamera.jitter, jitteredCamera.prevFrameJitter);
	}


	barrier_batcher(cl)
		.transition(screenVelocitiesTexture, D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_GENERIC_READ);


	// ----------------------------------------
	// AMBIENT OCCLUSION
	// ----------------------------------------

	if (settings.enableAO)
	{
		uint32 aoResultIndex = 1 - aoHistoryIndex;
		ref<dx_texture> aoHistory = aoWasOnLastFrame ? aoTextures[aoHistoryIndex] : render_resources::whiteTexture;
		ref<dx_texture> aoResult = aoTextures[aoResultIndex];
		ambientOcclusion(cl, linearDepthBuffer, screenVelocitiesTexture, aoCalculationTexture, aoBlurTempTexture, aoHistory, aoResult, settings.aoSettings, commonRenderData.cameraCBV);

		barrier_batcher(cl)
			// UAV barrier is done by hbao-function.
			.transition(aoTextures[aoResultIndex], D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_GENERIC_READ) // Read by opaque pass and next frame as history.
			.transition(aoTextures[aoHistoryIndex], D3D12_RESOURCE_STATE_GENERIC_READ, D3D12_RESOURCE_STATE_UNORDERED_ACCESS); // For next frame.

		aoHistoryIndex = aoResultIndex;
	}


	// ----------------------------------------
	// SCREEN SPACE REFLECTIONS
	// ----------------------------------------

	if (environment && environment->giMode == environment_gi_raytraced)
	{
		barrier_batcher(cl)
			.transition(depthStencilBuffer, D3D12_RESOURCE_STATE_DEPTH_WRITE, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE);

		PROFILE_ALL(cl, "Specular reflections");
		raytraceRTReflections(cl, *tlas, depthStencilBuffer, worldNormalsRoughnessTexture,
			screenVelocitiesTexture, ssrRaycastTexture, ssrResolveTexture, ssrTemporalTextures[ssrHistoryIndex],
			ssrTemporalTextures[1 - ssrHistoryIndex], commonRenderData);

		ssrHistoryIndex = 1 - ssrHistoryIndex;

		barrier_batcher(cl)
			.transition(depthStencilBuffer, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_DEPTH_WRITE);
	}
	else if (settings.enableSSR)
	{
		barrier_batcher(cl)
			.transition(depthStencilBuffer, D3D12_RESOURCE_STATE_DEPTH_WRITE, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE);

		screenSpaceReflections(cl, prevFrameHDRColorTexture, depthStencilBuffer, linearDepthBuffer, worldNormalsRoughnessTexture,
			screenVelocitiesTexture, ssrRaycastTexture, ssrResolveTexture, ssrTemporalTextures[ssrHistoryIndex],
			ssrTemporalTextures[1 - ssrHistoryIndex], settings.ssrSettings, commonRenderData.cameraCBV);

		ssrHistoryIndex = 1 - ssrHistoryIndex;

		barrier_batcher(cl)
			.transition(depthStencilBuffer, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_DEPTH_WRITE);
	}


	// ----------------------------------------
	// SCREEN SPACE SHADOWS
	// ----------------------------------------

	if (settings.enableSSS)
	{
		uint32 sssResultIndex = 1 - sssHistoryIndex;
		ref<dx_texture> sssHistory = sssWasOnLastFrame ? sssTextures[sssHistoryIndex] : render_resources::whiteTexture;
		ref<dx_texture> sssResult = sssTextures[sssResultIndex];
		screenSpaceShadows(cl, linearDepthBuffer, screenVelocitiesTexture, sssCalculationTexture, sssBlurTempTexture, sssHistory, sssResult, sun.direction, settings.sssSettings, jitteredCamera.view, commonRenderData.cameraCBV);

		barrier_batcher(cl)
			// UAV barrier is done by sss-function.
			.transition(sssTextures[sssResultIndex], D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_GENERIC_READ) // Read by opaque pass and next frame as history.
			.transition(sssTextures[sssHistoryIndex], D3D12_RESOURCE_STATE_GENERIC_READ, D3D12_RESOURCE_STATE_UNORDERED_ACCESS); // For next frame.

		sssHistoryIndex = sssResultIndex;
	}


	// ----------------------------------------
	// OPAQUE LIGHT PASS
	// ----------------------------------------

	barrier_batcher(cl)
		.transition(worldNormalsRoughnessTexture, D3D12_RESOURCE_STATE_GENERIC_READ, D3D12_RESOURCE_STATE_RENDER_TARGET)
		.transition(screenVelocitiesTexture, D3D12_RESOURCE_STATE_GENERIC_READ, D3D12_RESOURCE_STATE_RENDER_TARGET);


	auto hdrOpaqueRenderTarget = dx_render_target(renderWidth, renderHeight)
		.colorAttachment(hdrColorTexture)
		.colorAttachment(worldNormalsRoughnessTexture)
		.colorAttachment(screenVelocitiesTexture, render_resources::nullScreenVelocitiesRTV)
		.colorAttachment(objectIDsTexture, render_resources::nullObjectIDsRTV)
		.depthAttachment(depthStencilBuffer);

	opaqueLightPass(cl, hdrOpaqueRenderTarget, opaqueRenderPass, commonRenderData, jitteredCamera.viewProj);


	barrier_batcher(cl)
		.transition(hdrColorTexture, D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE)
		.transition(depthStencilBuffer, D3D12_RESOURCE_STATE_DEPTH_WRITE, D3D12_RESOURCE_STATE_GENERIC_READ)
		.transition(worldNormalsRoughnessTexture, D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_GENERIC_READ)
		.transition(screenVelocitiesTexture, D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_GENERIC_READ)
		.transition(frameResult, D3D12_RESOURCE_STATE_COMMON, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);




	// Copy hovered object id to readback buffer.
	if (objectIDsTexture && input)
	{
		windowHovered = input->overWindow
			&& (input->mouse.x - windowXOffset >= 0)
			&& (input->mouse.x - windowXOffset < (int32)renderWidth)
			&& (input->mouse.y - windowYOffset >= 0)
			&& (input->mouse.y - windowYOffset < (int32)renderHeight);

		if (windowHovered)
		{
			PROFILE_ALL(cl, "Copy hovered object ID");

			cl->transitionBarrier(objectIDsTexture, D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_COPY_SOURCE);
			cl->copyTextureRegionToBuffer(objectIDsTexture, hoveredObjectIDReadbackBuffer, dxContext.bufferedFrameID, input->mouse.x - windowXOffset, input->mouse.y - windowYOffset, 1, 1);
			cl->transitionBarrier(objectIDsTexture, D3D12_RESOURCE_STATE_COPY_SOURCE, D3D12_RESOURCE_STATE_RENDER_TARGET);
		}
	}

	return cl;
}

dx_command_list* main_renderer::renderThread3(common_render_data commonRenderData, dx_dynamic_constant_buffer unjitteredCameraCBV)
{
	// After this there is no more camera jittering!
	commonRenderData.cameraCBV = unjitteredCameraCBV;



	dx_command_list* cl = dxContext.getFreeRenderCommandList();
	PROFILE_ALL(cl, "Render thread 3");

	barrier_batcher(cl)
		.transition(opaqueDepthBuffer, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE | D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_COPY_DEST);

	{
		PROFILE_ALL(cl, "Copy depth buffer");
		cl->copyResource(depthStencilBuffer->resource, opaqueDepthBuffer->resource);
	}

	barrier_batcher(cl)
		.transition(opaqueDepthBuffer, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE | D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE);



	ref<dx_texture> hdrResult = hdrColorTexture; // Read state.


	// ----------------------------------------
	// TRANSPARENT LIGHT PASS
	// ----------------------------------------


	if (transparentRenderPass && transparentRenderPass->pass.size() > 0)
	{
		// There are some really ugly barriers in this scope.

		barrier_batcher(cl)
			.transition(hdrPostProcessingTexture, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_COPY_DEST)
			.transition(hdrResult, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_COPY_SOURCE);

		{
			DX_PROFILE_BLOCK(cl, "Copy opaque color");
			cl->copyResource(hdrResult->resource, hdrPostProcessingTexture->resource);
		}

		barrier_batcher(cl)
			.transition(hdrPostProcessingTexture, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE)
			.transition(hdrResult, D3D12_RESOURCE_STATE_COPY_SOURCE, D3D12_RESOURCE_STATE_RENDER_TARGET)
			.transition(depthStencilBuffer, D3D12_RESOURCE_STATE_GENERIC_READ, D3D12_RESOURCE_STATE_DEPTH_WRITE);

		auto hdrTransparentRenderTarget = dx_render_target(renderWidth, renderHeight)
			.colorAttachment(hdrResult)
			.depthAttachment(depthStencilBuffer);

		transparentLightPass(cl, hdrTransparentRenderTarget, transparentRenderPass, commonRenderData, unjitteredCamera.viewProj);

		barrier_batcher(cl)
			.transition(hdrPostProcessingTexture, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE)
			.transition(hdrResult, D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE)
			.transition(depthStencilBuffer, D3D12_RESOURCE_STATE_DEPTH_WRITE, D3D12_RESOURCE_STATE_GENERIC_READ);
	}



	if ((environment && environment->giMode == environment_gi_raytraced) || settings.enableSSR)
	{
		barrier_batcher(cl)
			.transition(ssrResolveTexture, D3D12_RESOURCE_STATE_GENERIC_READ, D3D12_RESOURCE_STATE_UNORDERED_ACCESS); // For next frame.
	}

	// ----------------------------------------
	// POST PROCESSING
	// ----------------------------------------


	// TAA.
	if (settings.enableTAA)
	{
		uint32 taaOutputIndex = 1 - taaHistoryIndex;
		temporalAntiAliasing(cl, hdrResult, screenVelocitiesTexture, opaqueDepthBuffer, taaTextures[taaHistoryIndex], taaTextures[taaOutputIndex], jitteredCamera.projectionParams);
		hdrResult = taaTextures[taaOutputIndex];
		taaHistoryIndex = taaOutputIndex;
	}

	// At this point hdrResult is either the TAA result or the hdrResult. Either one is in read state.


	// Downsample scene. This is also the copy used in SSR next frame.
	if (prevFrameHDRColorTexture)
	{
		downsample(cl, hdrResult, prevFrameHDRColorTexture, prevFrameHDRColorTempTexture);
	}



	// Bloom.
	if (settings.enableBloom)
	{
		barrier_batcher(cl)
			.transition(hdrPostProcessingTexture, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);

		bloom(cl, hdrResult, hdrPostProcessingTexture, bloomTexture, bloomTempTexture, settings.bloomSettings); // Bloom returns result in read state.
		hdrResult = hdrPostProcessingTexture;
	}

	// At this point hdrResult is either the TAA result, the hdrColorTexture, or the hdrPostProcessingTexture. Either one is in read state.



	tonemap(cl, hdrResult, ldrPostProcessingTexture, settings.tonemapSettings);


	// ----------------------------------------
	// LDR RENDERING
	// ----------------------------------------

	bool renderingLDR = ldrRenderPass && ldrRenderPass->ldrPass.size();
	bool renderingOverlays = ldrRenderPass && ldrRenderPass->overlays.size();
	bool renderingOutlines = ldrRenderPass && ldrRenderPass->outlines.size();
	if (renderingLDR || renderingOverlays || renderingOutlines)
	{
		barrier_batcher(cl)
			//.uav(ldrPostProcessingTexture)
			.transition(ldrPostProcessingTexture, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_RENDER_TARGET)
			.transition(depthStencilBuffer, D3D12_RESOURCE_STATE_GENERIC_READ, D3D12_RESOURCE_STATE_DEPTH_WRITE);

		auto ldrRenderTarget = dx_render_target(renderWidth, renderHeight)
			.colorAttachment(ldrPostProcessingTexture)
			.depthAttachment(depthStencilBuffer);

		ldrPass(cl, ldrRenderTarget, depthStencilBuffer, ldrRenderPass, commonRenderData, unjitteredCamera.viewProj);

		barrier_batcher(cl)
			.transition(ldrPostProcessingTexture, D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE);
	}
	else
	{
		barrier_batcher(cl)
			.transition(ldrPostProcessingTexture, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE)
			.transition(depthStencilBuffer, D3D12_RESOURCE_STATE_GENERIC_READ, D3D12_RESOURCE_STATE_DEPTH_WRITE);
	}


	// TODO: If we really care we should sharpen before rendering overlays and outlines.

	present(cl, ldrPostProcessingTexture, frameResult, settings.enableSharpen ? settings.sharpenSettings : sharpen_settings{ 0.f });



	barrier_batcher(cl)
		//.uav(frameResult)
		.transition(hdrColorTexture, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_RENDER_TARGET)
		.transition(screenVelocitiesTexture, D3D12_RESOURCE_STATE_GENERIC_READ, D3D12_RESOURCE_STATE_RENDER_TARGET)
		.transition(ldrPostProcessingTexture, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_UNORDERED_ACCESS)
		.transition(frameResult, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_COMMON)
		.transition(linearDepthBuffer, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);

	return cl;
}

void main_renderer::endFrame(const user_input* input)
{
	bool aspectRatioModeChanged = aspectRatioMode != oldAspectRatioMode;
	oldAspectRatioMode = aspectRatioMode;

	if (aspectRatioModeChanged)
	{
		recalculateViewport(true);
	}

	auto jitteredCameraCBV = dxContext.uploadDynamicConstantBuffer(jitteredCamera);
	auto unjitteredCameraCBV = dxContext.uploadDynamicConstantBuffer(unjitteredCamera);


	settings.enableAO &= spec.allowAO;
	settings.enableSSS &= spec.allowSSS;
	settings.enableSSR &= spec.allowSSR;
	settings.enableBloom &= spec.allowBloom;
	settings.enableTAA &= spec.allowTAA;


	lighting_cb lightingCB = {
		sun,
		environment->lightProbeGrid.getCB(),
		vec2(1.f / SHADOW_MAP_WIDTH, 1.f / SHADOW_MAP_HEIGHT),
		environment ? environment->globalIlluminationIntensity : 1.f, 
		(environment && environment->giMode == environment_gi_raytraced),
	};

	dx_dynamic_constant_buffer lightingCBV = dxContext.uploadDynamicConstantBuffer(lightingCB);


	common_render_data commonRenderData;

	commonRenderData.proceduralSky = !(environment && environment->sky);
	commonRenderData.sky = (environment && environment->sky) ? environment->sky : render_resources::blackCubeTexture;
	commonRenderData.irradiance = (environment && environment->irradiance) ? environment->irradiance : render_resources::blackCubeTexture;
	commonRenderData.prefilteredRadiance = (environment && environment->prefilteredRadiance) ? environment->prefilteredRadiance : render_resources::blackCubeTexture;

	commonRenderData.globalIlluminationIntensity = environment ? environment->globalIlluminationIntensity : 1.f;
	commonRenderData.skyIntensity = environment ? environment->skyIntensity : 1.f;
	commonRenderData.aoTexture = settings.enableAO ? aoTextures[1 - aoHistoryIndex] : render_resources::whiteTexture;
	commonRenderData.sssTexture = settings.enableSSS ? sssTextures[1 - sssHistoryIndex] : render_resources::whiteTexture;
	commonRenderData.ssrTexture = settings.enableSSR ? ssrResolveTexture : 0;
	commonRenderData.tiledCullingGrid = culling.tiledCullingGrid;
	commonRenderData.tiledObjectsIndexList = culling.tiledObjectsIndexList;
	commonRenderData.pointLightBuffer = pointLights;
	commonRenderData.spotLightBuffer = spotLights;
	commonRenderData.decalBuffer = decals;
	commonRenderData.shadowMap = render_resources::shadowMap;
	commonRenderData.decalTextureAtlas = decalTextureAtlas;
	commonRenderData.pointLightShadowInfoBuffer = pointLightShadowInfoBuffer;
	commonRenderData.spotLightShadowInfoBuffer = spotLightShadowInfoBuffer;
	commonRenderData.volumetricsTexture = 0;
	commonRenderData.cameraCBV = jitteredCameraCBV;
	commonRenderData.lightingCBV = lightingCBV;
	commonRenderData.lightProbeIrradiance = (environment && environment->giMode == environment_gi_raytraced) ? environment->lightProbeGrid.irradiance : 0;
	commonRenderData.lightProbeDepth = (environment && environment->giMode == environment_gi_raytraced) ? environment->lightProbeGrid.depth : 0;
	commonRenderData.opaqueColor = hdrPostProcessingTexture;
	commonRenderData.opaqueDepth = opaqueDepthBuffer;
	commonRenderData.worldNormalsAndRoughness = worldNormalsRoughnessTexture;

	commonRenderData.cameraJitter = jitteredCamera.jitter;
	commonRenderData.prevFrameCameraJitter = jitteredCamera.prevFrameJitter;



	common_particle_simulation_data commonParticleData;

	commonParticleData.cameraPosition = unjitteredCamera.position.xyz;
	commonParticleData.prevFrameCameraView = unjitteredCamera.prevFrameView;
	commonParticleData.prevFrameCameraViewProj = unjitteredCamera.prevFrameViewProj;
	commonParticleData.cameraProjectionParams = unjitteredCamera.projectionParams;
	commonParticleData.prevFrameDepthBuffer = opaqueDepthBuffer;
	commonParticleData.prevFrameNormals = worldNormalsRoughnessTexture;





	


	if (mode == renderer_mode_rasterized)
	{
		dx_command_list* cl0 = 0;
		dx_command_list* cl1 = 0;
		dx_command_list* cl2 = 0;
		dx_command_list* cl3 = 0;

		struct render_job_data
		{
			main_renderer* renderer;
			const common_render_data& commonRenderData;

			bool aspectRatioModeChanged;
			const user_input* input;
			dx_dynamic_constant_buffer unjitteredCameraCBV;

			dx_command_list*& cl0;
			dx_command_list*& cl1;
			dx_command_list*& cl2;
			dx_command_list*& cl3;
		};

		render_job_data jobData = 
		{
			this,
			commonRenderData,
			aspectRatioModeChanged,
			input,
			unjitteredCameraCBV,
			cl0,
			cl1,
			cl2,
			cl3,
		};

		job_handle parentJob = highPriorityJobQueue.createJob<render_job_data>([](render_job_data& data, job_handle parent)
		{
			highPriorityJobQueue.createJob<render_job_data>([](render_job_data& data, job_handle)
			{
				 data.cl0 = data.renderer->renderThread0(data.commonRenderData);
			}, data, parent).submitNow();

			highPriorityJobQueue.createJob<render_job_data>([](render_job_data& data, job_handle)
			{
				data.cl1 = data.renderer->renderThread1(data.commonRenderData, data.aspectRatioModeChanged);
			}, data, parent).submitNow();

			highPriorityJobQueue.createJob<render_job_data>([](render_job_data& data, job_handle)
			{
				data.cl2 = data.renderer->renderThread2(data.commonRenderData, data.input);
			}, data, parent).submitNow();

			highPriorityJobQueue.createJob<render_job_data>([](render_job_data& data, job_handle)
			{
				data.cl3 = data.renderer->renderThread3(data.commonRenderData, data.unjitteredCameraCBV);
			}, data, parent).submitNow();

		}, jobData);

		parentJob.submitNow();
		parentJob.waitForCompletion();

		ASSERT(cl0);
		ASSERT(cl1);
		ASSERT(cl2);
		ASSERT(cl3);

		dxContext.renderQueue.waitForOtherQueue(dxContext.computeQueue, executeComputeTasks(compute_pass_frame_start));
		dxContext.executeCommandList(cl0);

		dxContext.renderQueue.waitForOtherQueue(dxContext.computeQueue, executeComputeTasks(compute_pass_before_depth_prepass));
		dxContext.executeCommandList(cl1);

		dxContext.renderQueue.waitForOtherQueue(dxContext.computeQueue, executeComputeTasks(compute_pass_before_opaque, 
			[this, &commonRenderData, &commonParticleData](dx_command_list* cl)
		{
			if (dxContext.featureSupport.raytracing() && tlas)
			{
				tlas->build(cl);

				if (environment && environment->giMode == environment_gi_raytraced)
				{
					PROFILE_ALL(cl, "Update light probes");
					environment->lightProbeGrid.updateProbes(cl, *tlas, commonRenderData);
				}
			}

			if (computePass && computePass->particleSystemUpdates.size() > 0)
			{
				for (auto& cc : computePass->particleSystemUpdates)
				{
					cc->update(cl, commonParticleData, computePass->dt);
				}
			}
		}));
		dxContext.executeCommandList(cl2);

		dxContext.renderQueue.waitForOtherQueue(dxContext.computeQueue, executeComputeTasks(compute_pass_before_transparent_and_post_processing));
		dxContext.executeCommandList(cl3);

	}
	else if (mode == renderer_mode_visualize_sun_shadow_cascades)
	{
		uint64 maxFence = 0;
		for (uint32 i = 0; i < compute_pass_event_count; ++i)
		{
			uint64 fence = executeComputeTasks((compute_pass_event)i);
			maxFence = max(maxFence, fence);
		}

		dxContext.renderQueue.waitForOtherQueue(dxContext.computeQueue, maxFence);

		dx_command_list* cl = dxContext.getFreeRenderCommandList();

		if (aspectRatioModeChanged)
		{
			cl->transitionBarrier(frameResult, D3D12_RESOURCE_STATE_COMMON, D3D12_RESOURCE_STATE_RENDER_TARGET);
			cl->clearRTV(frameResult, 0.f, 0.f, 0.f);
			cl->transitionBarrier(frameResult, D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_COMMON);
		}

		cl->clearDepthAndStencil(depthStencilBuffer);

		auto depthOnlyRenderTarget = dx_render_target(renderWidth, renderHeight)
			// No screen space velocities or object IDs needed.
			.depthAttachment(depthStencilBuffer);

		depthPrePass(cl, depthOnlyRenderTarget, opaqueRenderPass,
			unjitteredCamera.viewProj, unjitteredCamera.prevFrameViewProj, commonRenderData);


		barrier_batcher(cl)
			.transition(depthStencilBuffer, D3D12_RESOURCE_STATE_DEPTH_WRITE, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE)
			.transition(frameResult, D3D12_RESOURCE_STATE_COMMON, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);

		visualizeSunShadowCascades(cl, depthStencilBuffer, frameResult, lightingCBV, unjitteredCamera.invViewProj, unjitteredCamera.position.xyz, unjitteredCamera.forward.xyz);

		barrier_batcher(cl)
			//.uav(frameResult)
			.transition(depthStencilBuffer, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_DEPTH_WRITE)
			.transition(frameResult, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_COMMON);

		dxContext.executeCommandList(cl);
	}
	else if (mode == renderer_mode_pathtraced && dxContext.featureSupport.raytracing() && tlas)
	{
		uint64 tlasRebuildFence;
		{
			dx_command_list* cl = dxContext.getFreeComputeCommandList(true);
			tlas->build(cl);
			tlasRebuildFence = dxContext.executeCommandList(cl);
		}

		dxContext.renderQueue.waitForOtherQueue(dxContext.computeQueue, tlasRebuildFence);

		pathTracer.finalizeForRender();

		dx_command_list* cl = dxContext.getFreeRenderCommandList();


		D3D12_RESOURCE_STATES frameResultState = D3D12_RESOURCE_STATE_COMMON;

		if (aspectRatioModeChanged)
		{
			cl->transitionBarrier(frameResult, D3D12_RESOURCE_STATE_COMMON, D3D12_RESOURCE_STATE_RENDER_TARGET);
			cl->clearRTV(frameResult, 0.f, 0.f, 0.f);
			frameResultState = D3D12_RESOURCE_STATE_RENDER_TARGET;
		}

		barrier_batcher(cl)
			.transition(hdrColorTexture, D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_UNORDERED_ACCESS)
			.transition(frameResult, frameResultState, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);

		{
			PROFILE_ALL(cl, "Raytracing");

			pathTracer.render(cl, *tlas, hdrColorTexture, commonRenderData);
		}

		cl->resetToDynamicDescriptorHeap();

		barrier_batcher(cl)
			//.uav(hdrColorTexture)
			.transition(hdrColorTexture, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE);

		tonemap(cl, hdrColorTexture, ldrPostProcessingTexture, settings.tonemapSettings);

		barrier_batcher(cl)
			.transition(ldrPostProcessingTexture, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE);

		present(cl, ldrPostProcessingTexture, frameResult, { 0.f });

		barrier_batcher(cl)
			.transition(hdrColorTexture, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_RENDER_TARGET)
			.transition(ldrPostProcessingTexture, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_UNORDERED_ACCESS)
			.transition(frameResult, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_COMMON);


		dxContext.executeCommandList(cl);
	}

	aoWasOnLastFrame = settings.enableAO;
	sssWasOnLastFrame = settings.enableSSS;
}


```

`src/rendering/main_renderer.h`:

```h
#pragma once

#include "core/math.h"
#include "core/camera.h"
#include "render_pass.h"
#include "light_source.h"
#include "pbr.h"
#include "core/input.h"
#include "raytracer.h"
#include "render_algorithms.h"
#include "render_resources.h"
#include "render_utils.h"
#include "path_tracing.h"
#include "light_probe.h"
#include "pbr_environment.h"

#include "light_source.hlsli"
#include "camera.hlsli"

#define MAX_NUM_SUN_LIGHT_SHADOW_PASSES 16
#define MAX_NUM_SPOT_LIGHT_SHADOW_PASSES 16
#define MAX_NUM_POINT_LIGHT_SHADOW_PASSES 16





struct renderer_settings
{
	tonemap_settings tonemapSettings;

	bool enableAO = true;
	hbao_settings aoSettings;

	bool enableSSS = true;
	sss_settings sssSettings;

	bool enableSSR = true;
	ssr_settings ssrSettings;

	bool enableTAA = true;
	taa_settings taaSettings;

	bool enableBloom = true;
	bloom_settings bloomSettings;

	bool enableSharpen = true;
	sharpen_settings sharpenSettings;
};
REFLECT_STRUCT(renderer_settings,
	(tonemapSettings, "Tonemap"),
	(enableAO, "Enable AO"),
	(aoSettings, "AO"),
	(enableSSS, "Enable SSS"),
	(sssSettings, "SSS"),
	(enableSSR, "Enable SSR"),
	(ssrSettings, "SSR"),
	(enableTAA, "Enable TAA"),
	(taaSettings, "TAA"),
	(enableBloom, "Enable Bloom"),
	(bloomSettings, "Bloom"),
	(enableSharpen, "Enable sharpen"),
	(sharpenSettings, "Sharpen")
);


enum aspect_ratio_mode
{
	aspect_ratio_free,
	aspect_ratio_fix_16_9,
	aspect_ratio_fix_16_10,

	aspect_ratio_mode_count,
};

static const char* aspectRatioNames[] =
{
	"Free",
	"16:9",
	"16:10",
};

enum renderer_mode
{
	renderer_mode_rasterized,
	renderer_mode_visualize_sun_shadow_cascades,
	renderer_mode_pathtraced,

	renderer_mode_count,
};

static const char* rendererModeNames[] =
{
	"Rasterized",
	"Visualize sun shadow cascades",
	"Path-traced",
};


struct renderer_spec
{
	bool allowObjectPicking = true;
	bool allowAO = true;
	bool allowSSS = true;
	bool allowSSR = true;
	bool allowTAA = true;
	bool allowBloom = true;
};

struct main_renderer
{
	main_renderer() {}
	void initialize(color_depth colorDepth, uint32 windowWidth, uint32 windowHeight, renderer_spec spec);

	void beginFrame(uint32 windowWidth, uint32 windowHeight);
	void endFrame(const user_input* input);


	// Set these with your application.
	void setCamera(const render_camera& camera);

	void submitRenderPass(opaque_render_pass* renderPass) {	ASSERT(!opaqueRenderPass); opaqueRenderPass = renderPass; }
	void submitRenderPass(transparent_render_pass* renderPass) { ASSERT(!transparentRenderPass); transparentRenderPass = renderPass; }
	void submitRenderPass(ldr_render_pass* renderPass) { ASSERT(!ldrRenderPass); ldrRenderPass = renderPass; }
	void submitComputePass(compute_pass* computePass) { ASSERT(!this->computePass); this->computePass = computePass; }

	void submitShadowRenderPass(sun_shadow_render_pass* renderPass) { ASSERT(numSunLightShadowRenderPasses < MAX_NUM_SUN_LIGHT_SHADOW_PASSES); sunShadowRenderPasses[numSunLightShadowRenderPasses++] = renderPass; }
	void submitShadowRenderPass(spot_shadow_render_pass* renderPass) { ASSERT(numSpotLightShadowRenderPasses < MAX_NUM_SPOT_LIGHT_SHADOW_PASSES);	spotLightShadowRenderPasses[numSpotLightShadowRenderPasses++] = renderPass; }
	void submitShadowRenderPass(point_shadow_render_pass* renderPass) { ASSERT(numPointLightShadowRenderPasses < MAX_NUM_POINT_LIGHT_SHADOW_PASSES); pointLightShadowRenderPasses[numPointLightShadowRenderPasses++] = renderPass; }

	void setRaytracingScene(raytracing_tlas* tlas) { this->tlas = tlas; }

	void setEnvironment(const pbr_environment& environment);
	void setSun(const directional_light& light);

	void setPointLights(const ref<dx_buffer>& lights, uint32 numLights, const ref<dx_buffer>& shadowInfoBuffer);
	void setSpotLights(const ref<dx_buffer>& lights, uint32 numLights, const ref<dx_buffer>& shadowInfoBuffer);
	void setDecals(const ref<dx_buffer>& decals, uint32 numDecals, const ref<dx_texture>& textureAtlas);



	// Settings.
	renderer_mode mode = renderer_mode_rasterized;
	aspect_ratio_mode aspectRatioMode = aspect_ratio_free;


	renderer_settings settings;


	uint32 renderWidth;
	uint32 renderHeight;
	ref<dx_texture> frameResult;

	uint32 hoveredObjectID = -1;

	const renderer_spec spec;

	path_tracer pathTracer;


	const ref<dx_texture>& getAOResult() const { return aoTextures[aoHistoryIndex]; }
	const ref<dx_texture>& getSSSResult() const { return sssTextures[sssHistoryIndex]; }
	const ref<dx_texture>& getSSRResult() const { return ssrResolveTexture; }
	const ref<dx_texture>& getBloomResult() const { return bloomTexture; }
	const ref<dx_texture>& getScreenVelocities() const { return screenVelocitiesTexture; }


private:
	template <typename func_t = std::nullptr_t>
	uint64 executeComputeTasks(compute_pass_event eventTime, const func_t& additionalTasksCallback = nullptr);


	dx_command_list* renderThread0(const common_render_data& commonRenderData);
	dx_command_list* renderThread1(const common_render_data& commonRenderData, bool aspectRatioModeChanged);
	dx_command_list* renderThread2(const common_render_data& commonRenderData, const user_input* input);
	dx_command_list* renderThread3(common_render_data commonRenderData, dx_dynamic_constant_buffer unjitteredCameraCBV);



	const sun_shadow_render_pass* sunShadowRenderPasses[MAX_NUM_SUN_LIGHT_SHADOW_PASSES];
	const spot_shadow_render_pass* spotLightShadowRenderPasses[MAX_NUM_SPOT_LIGHT_SHADOW_PASSES];
	const point_shadow_render_pass* pointLightShadowRenderPasses[MAX_NUM_POINT_LIGHT_SHADOW_PASSES];
	uint32 numSunLightShadowRenderPasses;
	uint32 numSpotLightShadowRenderPasses;
	uint32 numPointLightShadowRenderPasses;

	raytracing_tlas* tlas;

	const pbr_environment* environment;
	directional_light_cb sun;


	ref<dx_buffer> pointLights;
	ref<dx_buffer> spotLights;
	ref<dx_buffer> pointLightShadowInfoBuffer;
	ref<dx_buffer> spotLightShadowInfoBuffer;
	ref<dx_buffer> decals;
	uint32 numPointLights;
	uint32 numSpotLights;
	uint32 numDecals;
	
	ref<dx_texture> decalTextureAtlas;


	const opaque_render_pass* opaqueRenderPass;
	const transparent_render_pass* transparentRenderPass;
	const ldr_render_pass* ldrRenderPass;
	const compute_pass* computePass;


	uint32 windowWidth;
	uint32 windowHeight;
	int32 windowXOffset = 0;
	int32 windowYOffset = 0;

	bool windowHovered = false;

	ref<dx_texture> hdrColorTexture;
	ref<dx_texture> worldNormalsRoughnessTexture;
	ref<dx_texture> screenVelocitiesTexture;
	ref<dx_texture> objectIDsTexture;
	ref<dx_texture> depthStencilBuffer;
	ref<dx_texture> linearDepthBuffer;
	ref<dx_texture> opaqueDepthBuffer; // The depth-stencil buffer gets copied to this texture after the opaque pass.

	ref<dx_texture> aoCalculationTexture;
	ref<dx_texture> aoBlurTempTexture;
	ref<dx_texture> aoTextures[2]; // These get flip-flopped from frame to frame.
	volatile uint32 aoHistoryIndex = 0;
	bool aoWasOnLastFrame = false;

	ref<dx_texture> sssCalculationTexture;
	ref<dx_texture> sssBlurTempTexture;
	ref<dx_texture> sssTextures[2]; // These get flip-flopped from frame to frame.
	uint32 sssHistoryIndex = 0;
	bool sssWasOnLastFrame = false;

	ref<dx_texture> ssrRaycastTexture;
	ref<dx_texture> ssrResolveTexture;
	ref<dx_texture> ssrTemporalTextures[2]; // These get flip-flopped from frame to frame.
	uint32 ssrHistoryIndex = 0;

	ref<dx_texture> prevFrameHDRColorTexture; // This is downsampled by a factor of 2 and contains up to 8 mip levels.
	ref<dx_texture> prevFrameHDRColorTempTexture;

	ref<dx_texture> hdrPostProcessingTexture;
	ref<dx_texture> ldrPostProcessingTexture;
	ref<dx_texture> taaTextures[2]; // These get flip-flopped from frame to frame.
	uint32 taaHistoryIndex = 0;

	ref<dx_texture> bloomTexture;
	ref<dx_texture> bloomTempTexture;

	ref<dx_buffer> hoveredObjectIDReadbackBuffer;

	camera_cb jitteredCamera;
	camera_cb unjitteredCamera;


	light_culling culling;


	aspect_ratio_mode oldAspectRatioMode = aspect_ratio_free;
	renderer_mode oldMode = renderer_mode_rasterized;

	void recalculateViewport(bool resizeTextures);
};


```

`src/rendering/material.h`:

```h
#pragma once

#include "light_source.h"
#include "dx/dx_buffer.h"
#include "dx/dx_texture.h"
#include "render_command.h"

struct dx_command_list;

struct common_render_data
{
	ref<dx_texture> sky;
	ref<dx_texture> irradiance;
	ref<dx_texture> prefilteredRadiance;

	ref<dx_texture> aoTexture;
	ref<dx_texture> sssTexture;
	ref<dx_texture> ssrTexture;

	ref<dx_texture> lightProbeIrradiance;
	ref<dx_texture> lightProbeDepth;

	ref<dx_texture> tiledCullingGrid;
	ref<dx_buffer> tiledObjectsIndexList;
	ref<dx_buffer> tiledSpotLightIndexList;
	ref<dx_buffer> pointLightBuffer;
	ref<dx_buffer> spotLightBuffer;
	ref<dx_buffer> decalBuffer;
	ref<dx_buffer> pointLightShadowInfoBuffer;
	ref<dx_buffer> spotLightShadowInfoBuffer;

	ref<dx_texture> decalTextureAtlas;

	ref<dx_texture> shadowMap;

	ref<dx_texture> volumetricsTexture;

	// These two are only set, if the material is rendered after the opaque pass.
	ref<dx_texture> opaqueColor;
	ref<dx_texture> opaqueDepth;
	ref<dx_texture> worldNormalsAndRoughness;

	dx_dynamic_constant_buffer cameraCBV;
	dx_dynamic_constant_buffer lightingCBV;

	float globalIlluminationIntensity;
	float skyIntensity;
	bool proceduralSky;

	vec2 cameraJitter;
	vec2 prevFrameCameraJitter;
};



#define _PIPELINE_SETUP_DECL(name)					void name(dx_command_list* cl, const common_render_data& common)
#define PIPELINE_SETUP_DECL							static _PIPELINE_SETUP_DECL(setup)
#define PIPELINE_SETUP_IMPL(name)					_PIPELINE_SETUP_DECL(name::setup)
using pipeline_setup_func = _PIPELINE_SETUP_DECL((*));

#define _DEPTH_ONLY_RENDER_FUNC(name, data_t)		void name(dx_command_list* cl, const mat4& viewProj, const mat4& prevFrameViewProj, const data_t& data)
#define DEPTH_ONLY_RENDER_DECL(data_t)				static _DEPTH_ONLY_RENDER_FUNC(render, data_t)
#define DEPTH_ONLY_RENDER_IMPL(name, data_t)		_DEPTH_ONLY_RENDER_FUNC(name::render, data_t)
template <typename data_t> using depth_only_pipeline_render_func = _DEPTH_ONLY_RENDER_FUNC((*), data_t);

#define _RENDER_FUNC(name, data_t)					void name(dx_command_list* cl, const mat4& viewProj, const data_t& data)
#define PIPELINE_RENDER_DECL(data_t)				static _RENDER_FUNC(render, data_t)
#define PIPELINE_RENDER_IMPL(name, data_t)			_RENDER_FUNC(name::render, data_t)
template <typename data_t> using pipeline_render_func = _RENDER_FUNC((*), data_t);

#define _PARTICLE_RENDER_FUNC(name, data_t)			void name(dx_command_list* cl, const mat4& viewProj, const particle_render_command<data_t>& rc)
#define PARTICLE_PIPELINE_RENDER_DECL(data_t)		static _PARTICLE_RENDER_FUNC(render, data_t)
#define PARTICLE_PIPELINE_RENDER_IMPL(name, data_t)	_PARTICLE_RENDER_FUNC(name::render, data_t)
template <typename data_t> using particle_pipeline_render_func = _PARTICLE_RENDER_FUNC((*), data_t);

#define _COMPUTE_FUNC(name, data_t)					void name(dx_command_list* cl, const data_t& data)
#define PIPELINE_COMPUTE_DECL(data_t)				static _COMPUTE_FUNC(compute, data_t)
#define PIPELINE_COMPUTE_IMPL(name, data_t)			_COMPUTE_FUNC(name::compute, data_t)
template <typename data_t> using pipeline_compute_func = _COMPUTE_FUNC((*), data_t);


```

`src/rendering/mesh_shader.cpp`:

```cpp
#include "pch.h"
#include "mesh_shader.h"
#include "dx/dx_pipeline.h"
#include "dx/dx_command_list.h"
#include "dx/dx_profiling.h"
#include "material.h"
#include "render_utils.h"

#if defined(SDK_SUPPORTS_MESH_SHADERS) && defined(MESH_SHADER_SUPPORTED)

static dx_pipeline meshletPipeline;
static dx_pipeline blobPipeline;
static dx_pipeline kochPipeline;

static ref<dx_buffer> marchingCubesBuffer;

struct marching_cubes_lookup
{
	uint32 indices[4];
	uint8 vertices[12];
	uint16 triangleCount;
	uint16 vertexCount;
};

extern const marching_cubes_lookup marchingCubesLookup[256];

struct subset
{
	uint32 offset;
	uint32 count;
};

struct mesh_shader_submesh_info
{
	uint32 firstVertex;
	uint32 numVertices;

	uint32 firstMeshlet;
	uint32 numMeshlets;

	uint32 firstUniqueVertexIndex;
	uint32 numUniqueVertexIndices;

	uint32 firstPackedTriangle;
	uint32 numPackedTriangles;

	uint32 firstMeshletSubset;
	uint32 numMeshletSubsets;
};

struct mesh_shader_mesh
{
	std::vector<mesh_shader_submesh_info> submeshes;
	std::vector<subset> subsets;

	ref<dx_buffer> vertices;
	ref<dx_buffer> meshlets;
	ref<dx_buffer> uniqueVertexIndices;
	ref<dx_buffer> primitiveIndices;
};

static ref<mesh_shader_mesh> loadMeshShaderMeshFromFile(const char* filename);



struct meta_ball
{
	vec3 pos;
	vec3 dir;
	float radius;
};

static const uint32 DEFAULT_SHIFT = 7;
static const uint32 DEFAULT_BALL_COUNT = 32;
static const uint32 MAX_BALL_COUNT = 128;
static const uint32 BALL_COUNT = DEFAULT_BALL_COUNT;
static const uint32 SHIFT = DEFAULT_SHIFT;

struct mesh_shader_blob_render_data
{
	meta_ball balls[MAX_BALL_COUNT];

	mesh_shader_blob_render_data()
	{
		for (uint32 i = 0; i < BALL_COUNT; ++i)
		{
			// Random positions in [0.25, 0.75]
			balls[i].pos.x = float(rand() % RAND_MAX) / float(RAND_MAX - 1) * 0.5f + 0.25f;
			balls[i].pos.y = float(rand() % RAND_MAX) / float(RAND_MAX - 1) * 0.5f + 0.25f;
			balls[i].pos.z = float(rand() % RAND_MAX) / float(RAND_MAX - 1) * 0.5f + 0.25f;

			// Random directions in [-0.6, 0.6]
			balls[i].dir.x = (float(rand() % RAND_MAX) / float(RAND_MAX - 1) - 0.5f) * 1.2f;
			balls[i].dir.y = (float(rand() % RAND_MAX) / float(RAND_MAX - 1) - 0.5f) * 1.2f;
			balls[i].dir.z = (float(rand() % RAND_MAX) / float(RAND_MAX - 1) - 0.5f) * 1.2f;

			// Random radius in [0.02, 0.06]
			balls[i].radius = float(rand() % RAND_MAX) / float(RAND_MAX - 1) * 0.04f + 0.02f;
		}
	}
};

struct mesh_shader_blob_pipeline
{
	using render_data_t = mesh_shader_blob_render_data;

	PIPELINE_SETUP_DECL;
	PIPELINE_RENDER_DECL(mesh_shader_blob_render_data);
};

PIPELINE_SETUP_IMPL(mesh_shader_blob_pipeline)
{
	cl->setPipelineState(*blobPipeline.pipeline);
	cl->setGraphicsRootSignature(*blobPipeline.rootSignature);

	cl->setGraphicsDynamicConstantBuffer(1, common.cameraCBV);
	cl->setRootGraphicsSRV(2, marchingCubesBuffer);

	cl->setDescriptorHeapSRV(3, 0, common.sky);
}

PIPELINE_RENDER_IMPL(mesh_shader_blob_pipeline, mesh_shader_blob_render_data)
{
	DX_PROFILE_BLOCK(cl, "Mesh shader blob");

	struct constant_cb
	{
		vec4 balls[MAX_BALL_COUNT];
	};

	constant_cb cb;

	for (uint32 i = 0; i < BALL_COUNT; ++i)
	{
		float radius = data.balls[i].radius;
		cb.balls[i] = vec4(data.balls[i].pos, radius * radius);
	}

	auto b = dxContext.uploadDynamicConstantBuffer(cb);

	cl->setGraphicsDynamicConstantBuffer(0, b);


	const uint32 gridSize = (1 << SHIFT);
	cl->dispatchMesh((gridSize / 4)* (gridSize / 4)* (gridSize / 4), 1, 1);
};



struct mesh_shader_koch_pipeline
{
	PIPELINE_SETUP_DECL;
	PIPELINE_RENDER_DECL(void*);
};

PIPELINE_SETUP_IMPL(mesh_shader_koch_pipeline)
{
	cl->setPipelineState(*kochPipeline.pipeline);
	cl->setGraphicsRootSignature(*kochPipeline.rootSignature);

	cl->setGraphicsDynamicConstantBuffer(0, common.cameraCBV);
	cl->setRootGraphicsSRV(1, marchingCubesBuffer);

	cl->setDescriptorHeapSRV(2, 0, common.sky);
}

PIPELINE_RENDER_IMPL(mesh_shader_koch_pipeline, void*)
{
	DX_PROFILE_BLOCK(cl, "Mesh shader koch");

	const uint32 gridSize = (1 << SHIFT);
	cl->dispatchMesh((gridSize / 4) * (gridSize / 4) * (gridSize / 4), 1, 1);
};


void initializeMeshShader()
{
	D3D12_RT_FORMAT_ARRAY renderTargetFormat = {};
	renderTargetFormat.NumRenderTargets = 1;
	renderTargetFormat.RTFormats[0] = hdrFormat;

	{
		struct pipeline_state_stream : dx_pipeline_stream_base
		{
			// Will be set by reloader.
			CD3DX12_PIPELINE_STATE_STREAM_ROOT_SIGNATURE rootSignature;
			CD3DX12_PIPELINE_STATE_STREAM_MS ms;
			CD3DX12_PIPELINE_STATE_STREAM_PS ps;

			// Initialized here.
			CD3DX12_PIPELINE_STATE_STREAM_DEPTH_STENCIL_FORMAT dsvFormat;
			CD3DX12_PIPELINE_STATE_STREAM_RENDER_TARGET_FORMATS rtvFormats;

			void setRootSignature(dx_root_signature rs) override { rootSignature = rs.rootSignature.Get(); }
			void setMeshShader(dx_blob blob) override { ms = CD3DX12_SHADER_BYTECODE(blob.Get()); }
			void setPixelShader(dx_blob blob) override { ps = CD3DX12_SHADER_BYTECODE(blob.Get()); }
		};

		pipeline_state_stream stream;
		stream.dsvFormat = depthStencilFormat;
		stream.rtvFormats = renderTargetFormat;

		graphics_pipeline_files files = {};
		files.ms = "meshlet_ms";
		files.ps = "mesh_shader_ps";
		meshletPipeline = createReloadablePipelineFromStream(stream, files, rs_in_mesh_shader);
	}
	{
		struct pipeline_state_stream : dx_pipeline_stream_base
		{
			// Will be set by reloader.
			CD3DX12_PIPELINE_STATE_STREAM_ROOT_SIGNATURE rootSignature;
			CD3DX12_PIPELINE_STATE_STREAM_AS as;
			CD3DX12_PIPELINE_STATE_STREAM_MS ms;
			CD3DX12_PIPELINE_STATE_STREAM_PS ps;

			// Initialized here.
			CD3DX12_PIPELINE_STATE_STREAM_DEPTH_STENCIL_FORMAT dsvFormat;
			CD3DX12_PIPELINE_STATE_STREAM_RENDER_TARGET_FORMATS rtvFormats;
			CD3DX12_PIPELINE_STATE_STREAM_RASTERIZER rasterizer;

			void setRootSignature(dx_root_signature rs) override { rootSignature = rs.rootSignature.Get(); }
			void setAmplificationShader(dx_blob blob) override { as = CD3DX12_SHADER_BYTECODE(blob.Get()); }
			void setMeshShader(dx_blob blob) override { ms = CD3DX12_SHADER_BYTECODE(blob.Get()); }
			void setPixelShader(dx_blob blob) override { ps = CD3DX12_SHADER_BYTECODE(blob.Get()); }
		};

		auto rasterizerDesc = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT);
		//rasterizerDesc.FillMode = D3D12_FILL_MODE_WIREFRAME;
		rasterizerDesc.FrontCounterClockwise = TRUE; // Righthanded coordinate system.

		pipeline_state_stream stream;
		stream.dsvFormat = depthStencilFormat;
		stream.rtvFormats = renderTargetFormat;
		stream.rasterizer = rasterizerDesc;

		graphics_pipeline_files files = {};
		files.as = "meta_ball_as";
		files.ms = "meta_ball_ms";
		files.ps = "glass_ps";
		blobPipeline = createReloadablePipelineFromStream(stream, files, rs_in_mesh_shader);


		files.as = "koch_as";
		files.ms = "koch_ms";
		kochPipeline = createReloadablePipelineFromStream(stream, files, rs_in_mesh_shader);


		marchingCubesBuffer = createBuffer(sizeof(marching_cubes_lookup), arraysize(marchingCubesLookup), (void*)marchingCubesLookup);

	}
}

void testRenderMeshShader(transparent_render_pass* ldrRenderPass, float dt)
{
	/*overlayRenderPass->renderObjectWithMeshShader(1, 1, 1,
		cubeMaterial,
		createModelMatrix(vec3(0.f, 30.f, 0.f), quat::identity, 1.f),
		true
	);*/


	/*if (meshMaterial->mesh)
	{
		auto& sm = meshMaterial->mesh->submeshes[0];
		overlayRenderPass->renderObjectWithMeshShader(sm.numMeshlets, 1, 1,
			meshMaterial,
			createModelMatrix(vec3(0.f, 30.f, 0.f), quat::identity, 0.3f),
			true
		);
	}*/




	static mesh_shader_blob_render_data blobData;

	const float animationSpeed = 0.25f;
	const float frameTime = animationSpeed * dt;
	for (uint32 i = 0; i < BALL_COUNT; ++i)
	{
		vec3 d = vec3(0.5f, 0.5f, 0.5f) - blobData.balls[i].pos;
		blobData.balls[i].dir += d * (5.f * frameTime / (2.f + dot(d, d)));
		blobData.balls[i].pos += blobData.balls[i].dir * frameTime;
	}


	ldrRenderPass->renderObject<mesh_shader_blob_pipeline>(blobData);
	//ldrRenderPass->renderObject<mesh_shader_koch_pipeline>(0);
}







#include <fstream>

enum attribute_type
{
	attribute_type_position,
	attribute_type_normal,
	attribute_type_texCoord,
	attribute_type_tangent,
	attribute_type_bitangent,
	attribute_type_count,
};

struct mesh_header
{
	uint32 indices;
	uint32 indexSubsets;
	uint32 attributes[attribute_type_count];

	uint32 meshlets;
	uint32 meshletSubsets;
	uint32 uniqueVertexIndices;
	uint32 primitiveIndices;
	uint32 cullData;
};

struct buffer_view
{
	uint32 offset;
	uint32 size;
};

struct buffer_accessor
{
	uint32 bufferView;
	uint32 offset;
	uint32 size;
	uint32 stride;
	uint32 count;
};

struct file_header
{
	uint32 prolog;
	uint32 version;

	uint32 meshCount;
	uint32 accessorCount;
	uint32 bufferViewCount;
	uint32 bufferSize;
};

enum FileVersion
{
	FILE_VERSION_INITIAL = 0,
	CURRENT_FILE_VERSION = FILE_VERSION_INITIAL
};

// Meshlet stuff.

struct meshlet_info
{
	uint32 numVertices;
	uint32 firstVertex;
	uint32 numPrimitives;
	uint32 firstPrimitive;
};

struct packed_triangle
{
	uint32 i0 : 10;
	uint32 i1 : 10;
	uint32 i2 : 10;
};

struct mesh_vertex
{
	vec3 position;
	vec3 normal;
};

static ref<mesh_shader_mesh> loadMeshShaderMeshFromFile(const char* filename)
{
	std::ifstream stream(filename, std::ios::binary);
	if (!stream.is_open())
	{
		std::cerr << "Could not find file '" << filename << "'.\n";
		return 0;
	}

	std::vector<mesh_header> meshHeaders;
	std::vector<buffer_view> bufferViews;
	std::vector<buffer_accessor> accessors;

	file_header header;
	stream.read((char*)&header, sizeof(header));

	const uint32 prolog = 'MSHL';
	if (header.prolog != prolog)
	{
		return 0; // Incorrect file format.
	}

	if (header.version != CURRENT_FILE_VERSION)
	{
		return 0; // Version mismatch between export and import serialization code.
	}

	// Read mesh metdata.
	meshHeaders.resize(header.meshCount);
	stream.read((char*)meshHeaders.data(), meshHeaders.size() * sizeof(meshHeaders[0]));

	accessors.resize(header.accessorCount);
	stream.read((char*)accessors.data(), accessors.size() * sizeof(accessors[0]));

	bufferViews.resize(header.bufferViewCount);
	stream.read((char*)bufferViews.data(), bufferViews.size() * sizeof(bufferViews[0]));

	std::vector<uint8> m_buffer;
	m_buffer.resize(header.bufferSize);
	stream.read((char*)m_buffer.data(), header.bufferSize);

	char eofbyte;
	stream.read(&eofbyte, 1); // Read last byte to hit the eof bit.
	ASSERT(stream.eof()); // There's a problem if we didn't completely consume the file contents..

	stream.close();

	std::vector<mesh_shader_submesh_info> submeshes(meshHeaders.size());

	//std::vector<uint32> indices;
	//std::vector<subset> indexSubsets;
	std::vector<mesh_vertex> vertices;
	std::vector<meshlet_info> meshlets;
	std::vector<uint32> uniqueVertexIndices;
	std::vector<packed_triangle> primitiveIndices;
	std::vector<subset> meshletSubsets;

	for (uint32_t i = 0; i < (uint32)meshHeaders.size(); ++i)
	{
		mesh_header& meshView = meshHeaders[i];
		mesh_shader_submesh_info& sm = submeshes[i];

#if 0
		// Index data.
		{
			buffer_accessor& accessor = accessors[meshView.indices];
			buffer_view& bufferView = bufferViews[accessor.bufferView];

			ASSERT(accessor.size == sizeof(uint32));
			ASSERT(accessor.count * accessor.size == bufferView.size);

			uint32* start = (uint32*)(m_buffer.data() + bufferView.offset);

			sm.firstIndex = (uint32)indices.size();
			sm.numIndices = accessor.count;

			indices.insert(indices.end(), start, start + sm.numIndices);
		}
#endif

#if 0
		// Index Subset data.
		{
			buffer_accessor& accessor = accessors[meshView.indexSubsets];
			buffer_view& bufferView = bufferViews[accessor.bufferView];

			ASSERT(accessor.count * accessor.size == bufferView.size);

			subset* start = (subset*)(m_buffer.data() + bufferView.offset);

			sm.firstIndexSubset = (uint32)indexSubsets.size();
			sm.numIndexSubsets = accessor.count;

			indexSubsets.insert(indexSubsets.end(), start, start + sm.numIndexSubsets);
		}
#endif

		// Vertex data & layout metadata

		bool first = true;

		for (uint32 j = 0; j < attribute_type_count; ++j)
		{
			if (meshView.attributes[j] == -1)
			{
				continue;
			}

			buffer_accessor& accessor = accessors[meshView.attributes[j]];

			buffer_view& bufferView = bufferViews[accessor.bufferView];

			if (first)
			{
				sm.firstVertex = (uint32)vertices.size();
				sm.numVertices = accessor.count;
				vertices.resize(vertices.size() + sm.numVertices);
				first = false;
			}
			else
			{
				ASSERT(sm.numVertices == accessor.count);
			}

			uint8* data = m_buffer.data() + bufferView.offset + accessor.offset;

			for (uint32 vertexID = 0; vertexID < sm.numVertices; ++vertexID)
			{
				mesh_vertex& v = vertices[sm.firstVertex + vertexID];

				uint8* attributeData = data + accessor.stride * vertexID;

				if (j == attribute_type_position)
				{
					v.position = *(vec3*)attributeData;
				}
				else if (j == attribute_type_normal)
				{
					v.normal = *(vec3*)attributeData;
				}
			}
		}

		// Meshlet data
		{
			buffer_accessor& accessor = accessors[meshView.meshlets];
			buffer_view& bufferView = bufferViews[accessor.bufferView];

			meshlet_info* start = (meshlet_info*)(m_buffer.data() + bufferView.offset);

			ASSERT(accessor.count * accessor.size == bufferView.size);

			sm.firstMeshlet = (uint32)meshlets.size();
			sm.numMeshlets = accessor.count;

			meshlets.insert(meshlets.end(), start, start + sm.numMeshlets);
		}

		// Meshlet Subset data
		{
			buffer_accessor& accessor = accessors[meshView.meshletSubsets];
			buffer_view& bufferView = bufferViews[accessor.bufferView];

			subset* start = (subset*)(m_buffer.data() + bufferView.offset);

			ASSERT(accessor.count * accessor.size == bufferView.size);

			sm.firstMeshletSubset = (uint32)meshletSubsets.size();
			sm.numMeshletSubsets = accessor.count;

			meshletSubsets.insert(meshletSubsets.end(), start, start + sm.numMeshletSubsets);
		}

		// Unique Vertex Index data
		{
			buffer_accessor& accessor = accessors[meshView.uniqueVertexIndices];
			buffer_view& bufferView = bufferViews[accessor.bufferView];

			ASSERT(accessor.count * accessor.size == bufferView.size);

			sm.firstUniqueVertexIndex = (uint32)uniqueVertexIndices.size();
			sm.numUniqueVertexIndices = accessor.count;

			if (accessor.size == sizeof(uint32))
			{
				uint32* start = (uint32*)(m_buffer.data() + bufferView.offset);
				uniqueVertexIndices.insert(uniqueVertexIndices.end(), start, start + sm.numUniqueVertexIndices);
			}
			else
			{
				ASSERT(accessor.size == sizeof(uint16));

				uint16* start = (uint16*)(m_buffer.data() + bufferView.offset);

				std::vector<uint16> temp;
				temp.insert(temp.end(), start, start + sm.numUniqueVertexIndices);

				for (uint16 t : temp)
				{
					uniqueVertexIndices.push_back((uint32)t);
				}
			}
		}

		// Primitive Index data
		{
			buffer_accessor& accessor = accessors[meshView.primitiveIndices];
			buffer_view& bufferView = bufferViews[accessor.bufferView];

			packed_triangle* start = (packed_triangle*)(m_buffer.data() + bufferView.offset);

			ASSERT(accessor.count * accessor.size == bufferView.size);

			sm.firstPackedTriangle = (uint32)primitiveIndices.size();
			sm.numPackedTriangles = accessor.count;

			primitiveIndices.insert(primitiveIndices.end(), start, start + sm.numPackedTriangles);
		}

#if 0
		// Cull data
		{
			buffer_accessor& accessor = accessors[meshView.CullData];
			buffer_view& bufferView = bufferViews[accessor.BufferView];

			mesh.CullingData = MakeSpan(reinterpret_cast<CullData*>(m_buffer.data() + bufferView.Offset), accessor.Count);
		}
#endif
	}

#if 0
	// Build bounding spheres for each mesh
	for (uint32_t i = 0; i < static_cast<uint32_t>(m_meshes.size()); ++i)
	{
		auto& m = m_meshes[i];

		uint32_t vbIndexPos = 0;

		// Find the index of the vertex buffer of the position attribute
		for (uint32_t j = 1; j < m.LayoutDesc.NumElements; ++j)
		{
			auto& desc = m.LayoutElems[j];
			if (strcmp(desc.SemanticName, "POSITION") == 0)
			{
				vbIndexPos = j;
				break;
			}
		}

		// Find the byte offset of the position attribute with its vertex buffer
		uint32_t positionOffset = 0;

		for (uint32_t j = 0; j < m.LayoutDesc.NumElements; ++j)
		{
			auto& desc = m.LayoutElems[j];
			if (strcmp(desc.SemanticName, "POSITION") == 0)
			{
				break;
			}

			if (desc.InputSlot == vbIndexPos)
			{
				positionOffset += GetFormatSize(m.LayoutElems[j].Format);
			}
		}

		XMFLOAT3* v0 = reinterpret_cast<XMFLOAT3*>(m.Vertices[vbIndexPos].data() + positionOffset);
		uint32_t stride = m.VertexStrides[vbIndexPos];

		BoundingSphere::CreateFromPoints(m.BoundingSphere, m.VertexCount, v0, stride);

		if (i == 0)
		{
			m_boundingSphere = m.BoundingSphere;
		}
		else
		{
			BoundingSphere::CreateMerged(m_boundingSphere, m_boundingSphere, m.BoundingSphere);
		}
	}
#endif

	ref<mesh_shader_mesh> result = make_ref<mesh_shader_mesh>();
	result->submeshes = std::move(submeshes);
	result->subsets = std::move(meshletSubsets);
	result->vertices = createBuffer(sizeof(mesh_vertex), (uint32)vertices.size(), vertices.data());
	result->meshlets = createBuffer(sizeof(meshlet_info), (uint32)meshlets.size(), meshlets.data());
	result->uniqueVertexIndices = createBuffer(sizeof(uint32), (uint32)uniqueVertexIndices.size(), uniqueVertexIndices.data());
	result->primitiveIndices = createBuffer(sizeof(packed_triangle), (uint32)primitiveIndices.size(), primitiveIndices.data());

	return result;
}




const marching_cubes_lookup marchingCubesLookup[256] =
{
	/*  Packed 8bit indices                                 Two 3bit (octal) corner indices defining the edge                 */
	{ { 0x00000000, 0x00000000, 0x00000000, 0x00000000 }, { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 }, 0, 0 },
	{ { 0x00020100, 0x00000000, 0x00000000, 0x00000000 }, { 010, 020, 040, 000, 000, 000, 000, 000, 000, 000, 000, 000 }, 1, 3 },
	{ { 0x00020100, 0x00000000, 0x00000000, 0x00000000 }, { 010, 051, 031, 000, 000, 000, 000, 000, 000, 000, 000, 000 }, 1, 3 },
	{ { 0x03020100, 0x00000200, 0x00000000, 0x00000000 }, { 031, 020, 040, 051, 000, 000, 000, 000, 000, 000, 000, 000 }, 2, 4 },
	{ { 0x00020100, 0x00000000, 0x00000000, 0x00000000 }, { 020, 032, 062, 000, 000, 000, 000, 000, 000, 000, 000, 000 }, 1, 3 },
	{ { 0x03020100, 0x00000200, 0x00000000, 0x00000000 }, { 010, 032, 062, 040, 000, 000, 000, 000, 000, 000, 000, 000 }, 2, 4 },
	{ { 0x03020100, 0x00000504, 0x00000000, 0x00000000 }, { 031, 010, 051, 032, 062, 020, 000, 000, 000, 000, 000, 000 }, 2, 6 },
	{ { 0x00020100, 0x02030302, 0x00000004, 0x00000000 }, { 031, 032, 062, 051, 040, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x00020100, 0x00000000, 0x00000000, 0x00000000 }, { 031, 073, 032, 000, 000, 000, 000, 000, 000, 000, 000, 000 }, 1, 3 },
	{ { 0x03020100, 0x00000504, 0x00000000, 0x00000000 }, { 010, 020, 040, 031, 073, 032, 000, 000, 000, 000, 000, 000 }, 2, 6 },
	{ { 0x03020100, 0x00000200, 0x00000000, 0x00000000 }, { 051, 073, 032, 010, 000, 000, 000, 000, 000, 000, 000, 000 }, 2, 4 },
	{ { 0x00020100, 0x02030302, 0x00000004, 0x00000000 }, { 032, 020, 040, 073, 051, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x03020100, 0x00000200, 0x00000000, 0x00000000 }, { 020, 031, 073, 062, 000, 000, 000, 000, 000, 000, 000, 000 }, 2, 4 },
	{ { 0x00020100, 0x02030302, 0x00000004, 0x00000000 }, { 010, 031, 073, 040, 062, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x00020100, 0x02030302, 0x00000004, 0x00000000 }, { 020, 010, 051, 062, 073, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x01020100, 0x00000203, 0x00000000, 0x00000000 }, { 051, 073, 040, 062, 000, 000, 000, 000, 000, 000, 000, 000 }, 2, 4 },
	{ { 0x00020100, 0x00000000, 0x00000000, 0x00000000 }, { 054, 040, 064, 000, 000, 000, 000, 000, 000, 000, 000, 000 }, 1, 3 },
	{ { 0x03020100, 0x00000200, 0x00000000, 0x00000000 }, { 054, 010, 020, 064, 000, 000, 000, 000, 000, 000, 000, 000 }, 2, 4 },
	{ { 0x03020100, 0x00000504, 0x00000000, 0x00000000 }, { 010, 051, 031, 040, 064, 054, 000, 000, 000, 000, 000, 000 }, 2, 6 },
	{ { 0x00020100, 0x02030302, 0x00000004, 0x00000000 }, { 054, 051, 031, 064, 020, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x03020100, 0x00000504, 0x00000000, 0x00000000 }, { 040, 064, 054, 020, 032, 062, 000, 000, 000, 000, 000, 000 }, 2, 6 },
	{ { 0x00020100, 0x02030302, 0x00000004, 0x00000000 }, { 062, 064, 054, 032, 010, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x03020100, 0x07060504, 0x00000008, 0x00000000 }, { 051, 031, 010, 040, 064, 054, 032, 062, 020, 000, 000, 000 }, 3, 9 },
	{ { 0x03020100, 0x04030001, 0x04050301, 0x00000000 }, { 054, 062, 064, 051, 032, 031, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x03020100, 0x00000504, 0x00000000, 0x00000000 }, { 031, 073, 032, 040, 064, 054, 000, 000, 000, 000, 000, 000 }, 2, 6 },
	{ { 0x00020100, 0x05040302, 0x00000006, 0x00000000 }, { 020, 064, 054, 010, 031, 073, 032, 000, 000, 000, 000, 000 }, 3, 7 },
	{ { 0x00020100, 0x05040302, 0x00000006, 0x00000000 }, { 051, 073, 032, 010, 040, 064, 054, 000, 000, 000, 000, 000 }, 3, 7 },
	{ { 0x00020100, 0x04000103, 0x01050303, 0x00000000 }, { 032, 051, 073, 064, 020, 054, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x00020100, 0x05040302, 0x00000006, 0x00000000 }, { 020, 031, 073, 062, 064, 054, 040, 000, 000, 000, 000, 000 }, 3, 7 },
	{ { 0x00020100, 0x03000302, 0x02030504, 0x00000000 }, { 031, 073, 062, 054, 010, 064, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x03020100, 0x06030504, 0x05070404, 0x00000000 }, { 054, 040, 064, 051, 062, 010, 073, 020, 000, 000, 000, 000 }, 4, 8 },
	{ { 0x00020100, 0x04030103, 0x00000001, 0x00000000 }, { 054, 062, 064, 051, 073, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x00020100, 0x00000000, 0x00000000, 0x00000000 }, { 051, 054, 075, 000, 000, 000, 000, 000, 000, 000, 000, 000 }, 1, 3 },
	{ { 0x03020100, 0x00000504, 0x00000000, 0x00000000 }, { 051, 054, 075, 010, 020, 040, 000, 000, 000, 000, 000, 000 }, 2, 6 },
	{ { 0x03020100, 0x00000200, 0x00000000, 0x00000000 }, { 010, 054, 075, 031, 000, 000, 000, 000, 000, 000, 000, 000 }, 2, 4 },
	{ { 0x00020100, 0x02030302, 0x00000004, 0x00000000 }, { 040, 054, 075, 020, 031, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x03020100, 0x00000504, 0x00000000, 0x00000000 }, { 051, 054, 075, 032, 062, 020, 000, 000, 000, 000, 000, 000 }, 2, 6 },
	{ { 0x00020100, 0x05040302, 0x00000006, 0x00000000 }, { 010, 032, 062, 040, 054, 075, 051, 000, 000, 000, 000, 000 }, 3, 7 },
	{ { 0x00020100, 0x05040302, 0x00000006, 0x00000000 }, { 010, 054, 075, 031, 032, 062, 020, 000, 000, 000, 000, 000 }, 3, 7 },
	{ { 0x00020100, 0x04000103, 0x03010503, 0x00000000 }, { 032, 075, 031, 040, 062, 054, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x03020100, 0x00000504, 0x00000000, 0x00000000 }, { 031, 073, 032, 051, 054, 075, 000, 000, 000, 000, 000, 000 }, 2, 6 },
	{ { 0x03020100, 0x07060504, 0x00000008, 0x00000000 }, { 020, 040, 010, 031, 073, 032, 054, 075, 051, 000, 000, 000 }, 3, 9 },
	{ { 0x00020100, 0x02030302, 0x00000004, 0x00000000 }, { 075, 073, 032, 054, 010, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x03020100, 0x04030001, 0x04050301, 0x00000000 }, { 032, 075, 073, 020, 054, 040, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x00020100, 0x05040302, 0x00000006, 0x00000000 }, { 073, 062, 020, 031, 051, 054, 075, 000, 000, 000, 000, 000 }, 3, 7 },
	{ { 0x03020100, 0x04050504, 0x07060506, 0x00000000 }, { 054, 075, 051, 010, 031, 040, 073, 062, 000, 000, 000, 000 }, 4, 8 },
	{ { 0x00020100, 0x04000103, 0x01050303, 0x00000000 }, { 075, 010, 054, 062, 073, 020, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x00020100, 0x04030103, 0x00000001, 0x00000000 }, { 075, 040, 054, 073, 062, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x03020100, 0x00000200, 0x00000000, 0x00000000 }, { 051, 040, 064, 075, 000, 000, 000, 000, 000, 000, 000, 000 }, 2, 4 },
	{ { 0x00020100, 0x02030302, 0x00000004, 0x00000000 }, { 051, 010, 020, 075, 064, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x00020100, 0x02030302, 0x00000004, 0x00000000 }, { 010, 040, 064, 031, 075, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x01020100, 0x00000203, 0x00000000, 0x00000000 }, { 031, 020, 075, 064, 000, 000, 000, 000, 000, 000, 000, 000 }, 2, 4 },
	{ { 0x00020100, 0x05040302, 0x00000006, 0x00000000 }, { 064, 075, 051, 040, 020, 032, 062, 000, 000, 000, 000, 000 }, 3, 7 },
	{ { 0x00020100, 0x04000103, 0x01050303, 0x00000000 }, { 051, 064, 075, 032, 010, 062, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x03020100, 0x04050504, 0x07060506, 0x00000000 }, { 032, 062, 020, 010, 040, 031, 064, 075, 000, 000, 000, 000 }, 4, 8 },
	{ { 0x00020100, 0x04030103, 0x00000001, 0x00000000 }, { 062, 031, 032, 064, 075, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x00020100, 0x05040302, 0x00000006, 0x00000000 }, { 051, 040, 064, 075, 073, 032, 031, 000, 000, 000, 000, 000 }, 3, 7 },
	{ { 0x03020100, 0x04050504, 0x07060506, 0x00000000 }, { 073, 032, 031, 051, 010, 075, 020, 064, 000, 000, 000, 000 }, 4, 8 },
	{ { 0x00020100, 0x04000103, 0x03010503, 0x00000000 }, { 040, 032, 010, 075, 064, 073, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x00020100, 0x04030103, 0x00000001, 0x00000000 }, { 032, 075, 073, 020, 064, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x01020100, 0x05040203, 0x05070406, 0x00000000 }, { 051, 040, 075, 064, 073, 020, 031, 062, 000, 000, 000, 000 }, 4, 8 },
	{ { 0x00020100, 0x01020103, 0x01060504, 0x00060104 }, { 075, 010, 064, 051, 062, 031, 073, 000, 000, 000, 000, 000 }, 5, 7 },
	{ { 0x00020100, 0x01020103, 0x01060504, 0x00060104 }, { 062, 010, 073, 020, 075, 040, 064, 000, 000, 000, 000, 000 }, 5, 7 },
	{ { 0x03020100, 0x00000001, 0x00000000, 0x00000000 }, { 062, 075, 073, 064, 000, 000, 000, 000, 000, 000, 000, 000 }, 2, 4 },
	{ { 0x00020100, 0x00000000, 0x00000000, 0x00000000 }, { 064, 062, 076, 000, 000, 000, 000, 000, 000, 000, 000, 000 }, 1, 3 },
	{ { 0x03020100, 0x00000504, 0x00000000, 0x00000000 }, { 020, 040, 010, 062, 076, 064, 000, 000, 000, 000, 000, 000 }, 2, 6 },
	{ { 0x03020100, 0x00000504, 0x00000000, 0x00000000 }, { 010, 051, 031, 062, 076, 064, 000, 000, 000, 000, 000, 000 }, 2, 6 },
	{ { 0x00020100, 0x05040302, 0x00000006, 0x00000000 }, { 040, 051, 031, 020, 062, 076, 064, 000, 000, 000, 000, 000 }, 3, 7 },
	{ { 0x03020100, 0x00000200, 0x00000000, 0x00000000 }, { 064, 020, 032, 076, 000, 000, 000, 000, 000, 000, 000, 000 }, 2, 4 },
	{ { 0x00020100, 0x02030302, 0x00000004, 0x00000000 }, { 064, 040, 010, 076, 032, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x00020100, 0x05040302, 0x00000006, 0x00000000 }, { 032, 076, 064, 020, 010, 051, 031, 000, 000, 000, 000, 000 }, 3, 7 },
	{ { 0x00020100, 0x03000302, 0x05020304, 0x00000000 }, { 031, 032, 076, 040, 051, 064, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x03020100, 0x00000504, 0x00000000, 0x00000000 }, { 073, 032, 031, 076, 064, 062, 000, 000, 000, 000, 000, 000 }, 2, 6 },
	{ { 0x03020100, 0x07060504, 0x00000008, 0x00000000 }, { 031, 073, 032, 020, 040, 010, 076, 064, 062, 000, 000, 000 }, 3, 9 },
	{ { 0x00020100, 0x05040302, 0x00000006, 0x00000000 }, { 032, 010, 051, 073, 076, 064, 062, 000, 000, 000, 000, 000 }, 3, 7 },
	{ { 0x03020100, 0x04050504, 0x07060506, 0x00000000 }, { 076, 064, 062, 032, 020, 073, 040, 051, 000, 000, 000, 000 }, 4, 8 },
	{ { 0x00020100, 0x02030302, 0x00000004, 0x00000000 }, { 073, 076, 064, 031, 020, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x03020100, 0x02030200, 0x05040304, 0x00000000 }, { 073, 076, 064, 031, 040, 010, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x00020100, 0x04000103, 0x03010503, 0x00000000 }, { 010, 064, 020, 073, 051, 076, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x00020100, 0x04030103, 0x00000001, 0x00000000 }, { 064, 073, 076, 040, 051, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x03020100, 0x00000200, 0x00000000, 0x00000000 }, { 076, 054, 040, 062, 000, 000, 000, 000, 000, 000, 000, 000 }, 2, 4 },
	{ { 0x00020100, 0x02030302, 0x00000004, 0x00000000 }, { 020, 062, 076, 010, 054, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x00020100, 0x05040302, 0x00000006, 0x00000000 }, { 040, 062, 076, 054, 051, 031, 010, 000, 000, 000, 000, 000 }, 3, 7 },
	{ { 0x00020100, 0x04000103, 0x03010503, 0x00000000 }, { 051, 076, 054, 020, 031, 062, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x00020100, 0x02030302, 0x00000004, 0x00000000 }, { 040, 020, 032, 054, 076, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x02020100, 0x00000301, 0x00000000, 0x00000000 }, { 010, 032, 054, 076, 000, 000, 000, 000, 000, 000, 000, 000 }, 2, 4 },
	{ { 0x03020100, 0x06030504, 0x05070404, 0x00000000 }, { 031, 010, 051, 032, 054, 020, 076, 040, 000, 000, 000, 000 }, 4, 8 },
	{ { 0x00020100, 0x04030103, 0x00000001, 0x00000000 }, { 031, 054, 051, 032, 076, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x00020100, 0x05040302, 0x00000006, 0x00000000 }, { 076, 054, 040, 062, 032, 031, 073, 000, 000, 000, 000, 000 }, 3, 7 },
	{ { 0x03020100, 0x04050504, 0x07060506, 0x00000000 }, { 031, 073, 032, 020, 062, 010, 076, 054, 000, 000, 000, 000 }, 4, 8 },
	{ { 0x00020100, 0x05040302, 0x07050606, 0x00000000 }, { 054, 040, 062, 076, 010, 051, 032, 073, 000, 000, 000, 000 }, 4, 8 },
	{ { 0x00020100, 0x01020103, 0x01060504, 0x00060104 }, { 073, 020, 051, 032, 054, 062, 076, 000, 000, 000, 000, 000 }, 5, 7 },
	{ { 0x00020100, 0x03000302, 0x05020304, 0x00000000 }, { 040, 020, 031, 076, 054, 073, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x00020100, 0x04030103, 0x00000001, 0x00000000 }, { 073, 010, 031, 076, 054, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x00020100, 0x01020103, 0x01060504, 0x00060104 }, { 054, 020, 076, 040, 073, 010, 051, 000, 000, 000, 000, 000 }, 5, 7 },
	{ { 0x03020100, 0x00000001, 0x00000000, 0x00000000 }, { 073, 054, 051, 076, 000, 000, 000, 000, 000, 000, 000, 000 }, 2, 4 },
	{ { 0x03020100, 0x00000504, 0x00000000, 0x00000000 }, { 054, 075, 051, 064, 062, 076, 000, 000, 000, 000, 000, 000 }, 2, 6 },
	{ { 0x03020100, 0x07060504, 0x00000008, 0x00000000 }, { 010, 020, 040, 054, 075, 051, 062, 076, 064, 000, 000, 000 }, 3, 9 },
	{ { 0x00020100, 0x05040302, 0x00000006, 0x00000000 }, { 075, 031, 010, 054, 064, 062, 076, 000, 000, 000, 000, 000 }, 3, 7 },
	{ { 0x03020100, 0x04050504, 0x07060506, 0x00000000 }, { 062, 076, 064, 040, 054, 020, 075, 031, 000, 000, 000, 000 }, 4, 8 },
	{ { 0x00020100, 0x05040302, 0x00000006, 0x00000000 }, { 064, 020, 032, 076, 075, 051, 054, 000, 000, 000, 000, 000 }, 3, 7 },
	{ { 0x03020100, 0x06030504, 0x05070404, 0x00000000 }, { 051, 054, 075, 010, 076, 040, 032, 064, 000, 000, 000, 000 }, 4, 8 },
	{ { 0x00020100, 0x05040302, 0x07050606, 0x00000000 }, { 020, 032, 076, 064, 031, 010, 075, 054, 000, 000, 000, 000 }, 4, 8 },
	{ { 0x00020100, 0x01020103, 0x01060504, 0x00060104 }, { 076, 040, 032, 064, 031, 054, 075, 000, 000, 000, 000, 000 }, 5, 7 },
	{ { 0x03020100, 0x07060504, 0x00000008, 0x00000000 }, { 051, 054, 075, 073, 032, 031, 064, 062, 076, 000, 000, 000 }, 3, 9 },
	{ { 0x03020100, 0x07060504, 0x0B0A0908, 0x00000000 }, { 076, 064, 062, 031, 073, 032, 010, 020, 040, 054, 075, 051 }, 4, 12},
	{ { 0x03020100, 0x04050504, 0x07060506, 0x00000000 }, { 064, 062, 076, 075, 073, 054, 032, 010, 000, 000, 000, 000 }, 4, 8 },
	{ { 0x00020100, 0x03000302, 0x03040504, 0x00080706 }, { 020, 040, 054, 075, 032, 073, 062, 076, 064, 000, 000, 000 }, 5, 9 },
	{ { 0x03020100, 0x04050504, 0x07060506, 0x00000000 }, { 051, 054, 075, 073, 076, 031, 064, 020, 000, 000, 000, 000 }, 4, 8 },
	{ { 0x00020100, 0x03000302, 0x03040504, 0x00080706 }, { 031, 073, 076, 064, 010, 040, 051, 054, 075, 000, 000, 000 }, 5, 9 },
	{ { 0x00020100, 0x01020103, 0x01060504, 0x00060104 }, { 054, 073, 010, 075, 020, 076, 064, 000, 000, 000, 000, 000 }, 5, 7 },
	{ { 0x00020100, 0x01040103, 0x03010505, 0x00000000 }, { 064, 073, 076, 040, 075, 054, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x00020100, 0x02030302, 0x00000004, 0x00000000 }, { 076, 075, 051, 062, 040, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x03020100, 0x02030200, 0x05040304, 0x00000000 }, { 020, 062, 076, 010, 075, 051, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x00020100, 0x03000302, 0x05020304, 0x00000000 }, { 010, 040, 062, 075, 031, 076, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x00020100, 0x04030103, 0x00000001, 0x00000000 }, { 076, 020, 062, 075, 031, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x00020100, 0x03000302, 0x02030504, 0x00000000 }, { 075, 051, 040, 032, 076, 020, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x00020100, 0x04030103, 0x00000001, 0x00000000 }, { 051, 076, 075, 010, 032, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x00020100, 0x01020103, 0x01060504, 0x00060104 }, { 031, 040, 075, 010, 076, 020, 032, 000, 000, 000, 000, 000 }, 5, 7 },
	{ { 0x03020100, 0x00000001, 0x00000000, 0x00000000 }, { 031, 076, 075, 032, 000, 000, 000, 000, 000, 000, 000, 000 }, 2, 4 },
	{ { 0x03020100, 0x06030504, 0x05070404, 0x00000000 }, { 031, 073, 032, 051, 062, 075, 040, 076, 000, 000, 000, 000 }, 4, 8 },
	{ { 0x00020100, 0x03000302, 0x03040504, 0x00080706 }, { 010, 020, 062, 076, 051, 075, 031, 073, 032, 000, 000, 000 }, 5, 9 },
	{ { 0x00020100, 0x01020103, 0x01060504, 0x00060104 }, { 062, 075, 040, 076, 010, 073, 032, 000, 000, 000, 000, 000 }, 5, 7 },
	{ { 0x00020100, 0x01040103, 0x03010505, 0x00000000 }, { 076, 020, 062, 075, 032, 073, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x00020100, 0x01020103, 0x01060504, 0x00060104 }, { 031, 076, 020, 073, 040, 075, 051, 000, 000, 000, 000, 000 }, 5, 7 },
	{ { 0x00020100, 0x01040103, 0x03010505, 0x00000000 }, { 073, 010, 031, 076, 051, 075, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x03020100, 0x00000504, 0x00000000, 0x00000000 }, { 010, 040, 020, 075, 073, 076, 000, 000, 000, 000, 000, 000 }, 2, 6 },
	{ { 0x00020100, 0x00000000, 0x00000000, 0x00000000 }, { 073, 076, 075, 000, 000, 000, 000, 000, 000, 000, 000, 000 }, 1, 3 },
	{ { 0x00020100, 0x00000000, 0x00000000, 0x00000000 }, { 073, 075, 076, 000, 000, 000, 000, 000, 000, 000, 000, 000 }, 1, 3 },
	{ { 0x03020100, 0x00000504, 0x00000000, 0x00000000 }, { 010, 020, 040, 075, 076, 073, 000, 000, 000, 000, 000, 000 }, 2, 6 },
	{ { 0x03020100, 0x00000504, 0x00000000, 0x00000000 }, { 051, 031, 010, 075, 076, 073, 000, 000, 000, 000, 000, 000 }, 2, 6 },
	{ { 0x00020100, 0x05040302, 0x00000006, 0x00000000 }, { 031, 020, 040, 051, 075, 076, 073, 000, 000, 000, 000, 000 }, 3, 7 },
	{ { 0x03020100, 0x00000504, 0x00000000, 0x00000000 }, { 032, 062, 020, 073, 075, 076, 000, 000, 000, 000, 000, 000 }, 2, 6 },
	{ { 0x00020100, 0x05040302, 0x00000006, 0x00000000 }, { 062, 040, 010, 032, 073, 075, 076, 000, 000, 000, 000, 000 }, 3, 7 },
	{ { 0x03020100, 0x07060504, 0x00000008, 0x00000000 }, { 010, 051, 031, 032, 062, 020, 075, 076, 073, 000, 000, 000 }, 3, 9 },
	{ { 0x03020100, 0x04050504, 0x07060506, 0x00000000 }, { 075, 076, 073, 031, 032, 051, 062, 040, 000, 000, 000, 000 }, 4, 8 },
	{ { 0x03020100, 0x00000200, 0x00000000, 0x00000000 }, { 031, 075, 076, 032, 000, 000, 000, 000, 000, 000, 000, 000 }, 2, 4 },
	{ { 0x00020100, 0x05040302, 0x00000006, 0x00000000 }, { 031, 075, 076, 032, 020, 040, 010, 000, 000, 000, 000, 000 }, 3, 7 },
	{ { 0x00020100, 0x02030302, 0x00000004, 0x00000000 }, { 051, 075, 076, 010, 032, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x00020100, 0x04000103, 0x03010503, 0x00000000 }, { 075, 040, 051, 032, 076, 020, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x00020100, 0x02030302, 0x00000004, 0x00000000 }, { 076, 062, 020, 075, 031, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x00020100, 0x04000103, 0x01050303, 0x00000000 }, { 010, 062, 040, 075, 031, 076, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x03020100, 0x04030001, 0x04050301, 0x00000000 }, { 020, 076, 062, 010, 075, 051, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x00020100, 0x04030103, 0x00000001, 0x00000000 }, { 076, 051, 075, 062, 040, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x03020100, 0x00000504, 0x00000000, 0x00000000 }, { 075, 076, 073, 054, 040, 064, 000, 000, 000, 000, 000, 000 }, 2, 6 },
	{ { 0x00020100, 0x05040302, 0x00000006, 0x00000000 }, { 054, 010, 020, 064, 076, 073, 075, 000, 000, 000, 000, 000 }, 3, 7 },
	{ { 0x03020100, 0x07060504, 0x00000008, 0x00000000 }, { 031, 010, 051, 075, 076, 073, 040, 064, 054, 000, 000, 000 }, 3, 9 },
	{ { 0x03020100, 0x06030504, 0x05070404, 0x00000000 }, { 073, 075, 076, 031, 064, 051, 020, 054, 000, 000, 000, 000 }, 4, 8 },
	{ { 0x03020100, 0x07060504, 0x00000008, 0x00000000 }, { 020, 032, 062, 064, 054, 040, 073, 075, 076, 000, 000, 000 }, 3, 9 },
	{ { 0x03020100, 0x06030504, 0x05070404, 0x00000000 }, { 075, 076, 073, 054, 032, 064, 010, 062, 000, 000, 000, 000 }, 4, 8 },
	{ { 0x03020100, 0x07060504, 0x0B0A0908, 0x00000000 }, { 010, 051, 031, 054, 040, 064, 032, 062, 020, 075, 076, 073 }, 4, 12},
	{ { 0x00020100, 0x03000302, 0x03040504, 0x00080706 }, { 051, 031, 032, 062, 054, 064, 075, 076, 073, 000, 000, 000 }, 5, 9 },
	{ { 0x00020100, 0x05040302, 0x00000006, 0x00000000 }, { 076, 032, 031, 075, 054, 040, 064, 000, 000, 000, 000, 000 }, 3, 7 },
	{ { 0x01020100, 0x05040203, 0x05070406, 0x00000000 }, { 031, 075, 032, 076, 020, 054, 010, 064, 000, 000, 000, 000 }, 4, 8 },
	{ { 0x03020100, 0x04050504, 0x07060506, 0x00000000 }, { 040, 064, 054, 051, 075, 010, 076, 032, 000, 000, 000, 000 }, 4, 8 },
	{ { 0x00020100, 0x01020103, 0x01060504, 0x00060104 }, { 064, 051, 020, 054, 032, 075, 076, 000, 000, 000, 000, 000 }, 5, 7 },
	{ { 0x03020100, 0x06030504, 0x05070404, 0x00000000 }, { 040, 064, 054, 020, 075, 062, 031, 076, 000, 000, 000, 000 }, 4, 8 },
	{ { 0x00020100, 0x01020103, 0x01060504, 0x00060104 }, { 075, 062, 031, 076, 010, 064, 054, 000, 000, 000, 000, 000 }, 5, 7 },
	{ { 0x00020100, 0x03000302, 0x03040504, 0x00080706 }, { 010, 051, 075, 076, 020, 062, 040, 064, 054, 000, 000, 000 }, 5, 9 },
	{ { 0x00020100, 0x01040103, 0x03010505, 0x00000000 }, { 076, 051, 075, 062, 054, 064, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x03020100, 0x00000200, 0x00000000, 0x00000000 }, { 073, 051, 054, 076, 000, 000, 000, 000, 000, 000, 000, 000 }, 2, 4 },
	{ { 0x00020100, 0x05040302, 0x00000006, 0x00000000 }, { 054, 076, 073, 051, 010, 020, 040, 000, 000, 000, 000, 000 }, 3, 7 },
	{ { 0x00020100, 0x02030302, 0x00000004, 0x00000000 }, { 073, 031, 010, 076, 054, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x00020100, 0x04000103, 0x01050303, 0x00000000 }, { 040, 031, 020, 076, 054, 073, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x00020100, 0x05040302, 0x00000006, 0x00000000 }, { 073, 051, 054, 076, 062, 020, 032, 000, 000, 000, 000, 000 }, 3, 7 },
	{ { 0x01020100, 0x05040203, 0x05070406, 0x00000000 }, { 010, 032, 040, 062, 054, 073, 051, 076, 000, 000, 000, 000 }, 4, 8 },
	{ { 0x03020100, 0x06030504, 0x05070404, 0x00000000 }, { 020, 032, 062, 010, 076, 031, 054, 073, 000, 000, 000, 000 }, 4, 8 },
	{ { 0x00020100, 0x01020103, 0x01060504, 0x00060104 }, { 076, 031, 054, 073, 040, 032, 062, 000, 000, 000, 000, 000 }, 5, 7 },
	{ { 0x00020100, 0x02030302, 0x00000004, 0x00000000 }, { 031, 051, 054, 032, 076, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x03020100, 0x04050504, 0x07060506, 0x00000000 }, { 020, 040, 010, 031, 051, 032, 054, 076, 000, 000, 000, 000 }, 4, 8 },
	{ { 0x01020100, 0x00000203, 0x00000000, 0x00000000 }, { 010, 054, 032, 076, 000, 000, 000, 000, 000, 000, 000, 000 }, 2, 4 },
	{ { 0x00020100, 0x04030103, 0x00000001, 0x00000000 }, { 040, 032, 020, 054, 076, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x00020100, 0x03000302, 0x02030504, 0x00000000 }, { 051, 054, 076, 020, 031, 062, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x00020100, 0x01020103, 0x01060504, 0x00060104 }, { 040, 031, 062, 010, 076, 051, 054, 000, 000, 000, 000, 000 }, 5, 7 },
	{ { 0x00020100, 0x04030103, 0x00000001, 0x00000000 }, { 020, 076, 062, 010, 054, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x03020100, 0x00000001, 0x00000000, 0x00000000 }, { 076, 040, 054, 062, 000, 000, 000, 000, 000, 000, 000, 000 }, 2, 4 },
	{ { 0x00020100, 0x02030302, 0x00000004, 0x00000000 }, { 064, 076, 073, 040, 051, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x00020100, 0x03000302, 0x02030504, 0x00000000 }, { 010, 020, 064, 073, 051, 076, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x03020100, 0x04030001, 0x04050301, 0x00000000 }, { 073, 064, 076, 031, 040, 010, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x00020100, 0x04030103, 0x00000001, 0x00000000 }, { 073, 064, 076, 031, 020, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x03020100, 0x06030504, 0x05070404, 0x00000000 }, { 032, 062, 020, 073, 040, 076, 051, 064, 000, 000, 000, 000 }, 4, 8 },
	{ { 0x00020100, 0x01020103, 0x01060504, 0x00060104 }, { 032, 064, 010, 062, 051, 076, 073, 000, 000, 000, 000, 000 }, 5, 7 },
	{ { 0x00020100, 0x03000302, 0x03040504, 0x00080706 }, { 031, 010, 040, 064, 073, 076, 032, 062, 020, 000, 000, 000 }, 5, 9 },
	{ { 0x00020100, 0x01040103, 0x03010505, 0x00000000 }, { 062, 031, 032, 064, 073, 076, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x00020100, 0x04000103, 0x01050303, 0x00000000 }, { 031, 076, 032, 040, 051, 064, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x00020100, 0x01020103, 0x01060504, 0x00060104 }, { 032, 051, 076, 031, 064, 010, 020, 000, 000, 000, 000, 000 }, 5, 7 },
	{ { 0x00020100, 0x04030103, 0x00000001, 0x00000000 }, { 064, 010, 040, 076, 032, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x03020100, 0x00000001, 0x00000000, 0x00000000 }, { 064, 032, 020, 076, 000, 000, 000, 000, 000, 000, 000, 000 }, 2, 4 },
	{ { 0x00020100, 0x01020103, 0x01060504, 0x00060104 }, { 040, 076, 051, 064, 031, 062, 020, 000, 000, 000, 000, 000 }, 5, 7 },
	{ { 0x03020100, 0x00000504, 0x00000000, 0x00000000 }, { 010, 031, 051, 062, 064, 076, 000, 000, 000, 000, 000, 000 }, 2, 6 },
	{ { 0x00020100, 0x01040103, 0x03010505, 0x00000000 }, { 064, 010, 040, 076, 020, 062, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x00020100, 0x00000000, 0x00000000, 0x00000000 }, { 064, 076, 062, 000, 000, 000, 000, 000, 000, 000, 000, 000 }, 1, 3 },
	{ { 0x03020100, 0x00000200, 0x00000000, 0x00000000 }, { 062, 073, 075, 064, 000, 000, 000, 000, 000, 000, 000, 000 }, 2, 4 },
	{ { 0x00020100, 0x05040302, 0x00000006, 0x00000000 }, { 062, 073, 075, 064, 040, 010, 020, 000, 000, 000, 000, 000 }, 3, 7 },
	{ { 0x00020100, 0x05040302, 0x00000006, 0x00000000 }, { 075, 064, 062, 073, 031, 010, 051, 000, 000, 000, 000, 000 }, 3, 7 },
	{ { 0x00020100, 0x05040302, 0x07050606, 0x00000000 }, { 073, 075, 064, 062, 051, 031, 040, 020, 000, 000, 000, 000 }, 4, 8 },
	{ { 0x00020100, 0x02030302, 0x00000004, 0x00000000 }, { 032, 073, 075, 020, 064, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x00020100, 0x03000302, 0x02030504, 0x00000000 }, { 040, 010, 032, 075, 064, 073, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x03020100, 0x06030504, 0x05070404, 0x00000000 }, { 051, 031, 010, 075, 020, 073, 064, 032, 000, 000, 000, 000 }, 4, 8 },
	{ { 0x00020100, 0x01020103, 0x01060504, 0x00060104 }, { 051, 032, 040, 031, 064, 073, 075, 000, 000, 000, 000, 000 }, 5, 7 },
	{ { 0x00020100, 0x02030302, 0x00000004, 0x00000000 }, { 062, 032, 031, 064, 075, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x03020100, 0x06030504, 0x05070404, 0x00000000 }, { 010, 020, 040, 031, 064, 032, 075, 062, 000, 000, 000, 000 }, 4, 8 },
	{ { 0x00020100, 0x03000302, 0x05020304, 0x00000000 }, { 051, 075, 064, 032, 010, 062, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x00020100, 0x01020103, 0x01060504, 0x00060104 }, { 064, 032, 075, 062, 051, 020, 040, 000, 000, 000, 000, 000 }, 5, 7 },
	{ { 0x02020100, 0x00000301, 0x00000000, 0x00000000 }, { 031, 075, 020, 064, 000, 000, 000, 000, 000, 000, 000, 000 }, 2, 4 },
	{ { 0x00020100, 0x04030103, 0x00000001, 0x00000000 }, { 010, 064, 040, 031, 075, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x00020100, 0x04030103, 0x00000001, 0x00000000 }, { 051, 020, 010, 075, 064, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x03020100, 0x00000001, 0x00000000, 0x00000000 }, { 051, 064, 040, 075, 000, 000, 000, 000, 000, 000, 000, 000 }, 2, 4 },
	{ { 0x00020100, 0x02030302, 0x00000004, 0x00000000 }, { 075, 054, 040, 073, 062, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x00020100, 0x03000302, 0x05020304, 0x00000000 }, { 075, 054, 010, 062, 073, 020, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x03020100, 0x06030504, 0x05070404, 0x00000000 }, { 010, 051, 031, 040, 073, 054, 062, 075, 000, 000, 000, 000 }, 4, 8 },
	{ { 0x00020100, 0x01020103, 0x01060504, 0x00060104 }, { 073, 054, 062, 075, 020, 051, 031, 000, 000, 000, 000, 000 }, 5, 7 },
	{ { 0x03020100, 0x02030200, 0x05040304, 0x00000000 }, { 032, 073, 075, 020, 054, 040, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x00020100, 0x04030103, 0x00000001, 0x00000000 }, { 075, 032, 073, 054, 010, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x00020100, 0x03000302, 0x03040504, 0x00080706 }, { 020, 032, 073, 075, 040, 054, 010, 051, 031, 000, 000, 000 }, 5, 9 },
	{ { 0x00020100, 0x01040103, 0x03010505, 0x00000000 }, { 075, 032, 073, 054, 031, 051, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x00020100, 0x03000302, 0x02030504, 0x00000000 }, { 032, 031, 075, 040, 062, 054, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x00020100, 0x01020103, 0x01060504, 0x00060104 }, { 010, 062, 054, 020, 075, 032, 031, 000, 000, 000, 000, 000 }, 5, 7 },
	{ { 0x00020100, 0x01020103, 0x01060504, 0x00060104 }, { 010, 075, 032, 051, 062, 054, 040, 000, 000, 000, 000, 000 }, 5, 7 },
	{ { 0x03020100, 0x00000504, 0x00000000, 0x00000000 }, { 051, 075, 054, 032, 020, 062, 000, 000, 000, 000, 000, 000 }, 2, 6 },
	{ { 0x00020100, 0x04030103, 0x00000001, 0x00000000 }, { 040, 075, 054, 020, 031, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x03020100, 0x00000001, 0x00000000, 0x00000000 }, { 010, 075, 054, 031, 000, 000, 000, 000, 000, 000, 000, 000 }, 2, 4 },
	{ { 0x00020100, 0x01040103, 0x03010505, 0x00000000 }, { 040, 075, 054, 020, 051, 010, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x00020100, 0x00000000, 0x00000000, 0x00000000 }, { 051, 075, 054, 000, 000, 000, 000, 000, 000, 000, 000, 000 }, 1, 3 },
	{ { 0x00020100, 0x02030302, 0x00000004, 0x00000000 }, { 054, 064, 062, 051, 073, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x03020100, 0x04050504, 0x07060506, 0x00000000 }, { 010, 020, 040, 054, 064, 051, 062, 073, 000, 000, 000, 000 }, 4, 8 },
	{ { 0x00020100, 0x04000103, 0x03010503, 0x00000000 }, { 031, 062, 073, 054, 010, 064, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x00020100, 0x01020103, 0x01060504, 0x00060104 }, { 020, 054, 031, 040, 073, 064, 062, 000, 000, 000, 000, 000 }, 5, 7 },
	{ { 0x00020100, 0x03000302, 0x05020304, 0x00000000 }, { 032, 073, 051, 064, 020, 054, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x00020100, 0x01020103, 0x01060504, 0x00060104 }, { 051, 064, 073, 054, 032, 040, 010, 000, 000, 000, 000, 000 }, 5, 7 },
	{ { 0x00020100, 0x01020103, 0x01060504, 0x00060104 }, { 020, 073, 064, 032, 054, 031, 010, 000, 000, 000, 000, 000 }, 5, 7 },
	{ { 0x03020100, 0x00000504, 0x00000000, 0x00000000 }, { 031, 032, 073, 040, 054, 064, 000, 000, 000, 000, 000, 000 }, 2, 6 },
	{ { 0x03020100, 0x02030200, 0x05040304, 0x00000000 }, { 054, 064, 062, 051, 032, 031, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x00020100, 0x03000302, 0x03040504, 0x00080706 }, { 051, 054, 064, 062, 031, 032, 010, 020, 040, 000, 000, 000 }, 5, 9 },
	{ { 0x00020100, 0x04030103, 0x00000001, 0x00000000 }, { 062, 054, 064, 032, 010, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x00020100, 0x01040103, 0x03010505, 0x00000000 }, { 062, 054, 064, 032, 040, 020, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x00020100, 0x04030103, 0x00000001, 0x00000000 }, { 054, 031, 051, 064, 020, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x00020100, 0x01040103, 0x03010505, 0x00000000 }, { 054, 031, 051, 064, 010, 040, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x03020100, 0x00000001, 0x00000000, 0x00000000 }, { 054, 020, 010, 064, 000, 000, 000, 000, 000, 000, 000, 000 }, 2, 4 },
	{ { 0x00020100, 0x00000000, 0x00000000, 0x00000000 }, { 054, 064, 040, 000, 000, 000, 000, 000, 000, 000, 000, 000 }, 1, 3 },
	{ { 0x02020100, 0x00000301, 0x00000000, 0x00000000 }, { 051, 040, 073, 062, 000, 000, 000, 000, 000, 000, 000, 000 }, 2, 4 },
	{ { 0x00020100, 0x04030103, 0x00000001, 0x00000000 }, { 020, 051, 010, 062, 073, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x00020100, 0x04030103, 0x00000001, 0x00000000 }, { 010, 073, 031, 040, 062, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x03020100, 0x00000001, 0x00000000, 0x00000000 }, { 020, 073, 031, 062, 000, 000, 000, 000, 000, 000, 000, 000 }, 2, 4 },
	{ { 0x00020100, 0x04030103, 0x00000001, 0x00000000 }, { 032, 040, 020, 073, 051, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x03020100, 0x00000001, 0x00000000, 0x00000000 }, { 051, 032, 073, 010, 000, 000, 000, 000, 000, 000, 000, 000 }, 2, 4 },
	{ { 0x00020100, 0x01040103, 0x03010505, 0x00000000 }, { 032, 040, 020, 073, 010, 031, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x00020100, 0x00000000, 0x00000000, 0x00000000 }, { 031, 032, 073, 000, 000, 000, 000, 000, 000, 000, 000, 000 }, 1, 3 },
	{ { 0x00020100, 0x04030103, 0x00000001, 0x00000000 }, { 031, 062, 032, 051, 040, 000, 000, 000, 000, 000, 000, 000 }, 3, 5 },
	{ { 0x00020100, 0x01040103, 0x03010505, 0x00000000 }, { 020, 051, 010, 062, 031, 032, 000, 000, 000, 000, 000, 000 }, 4, 6 },
	{ { 0x03020100, 0x00000001, 0x00000000, 0x00000000 }, { 010, 062, 032, 040, 000, 000, 000, 000, 000, 000, 000, 000 }, 2, 4 },
	{ { 0x00020100, 0x00000000, 0x00000000, 0x00000000 }, { 020, 062, 032, 000, 000, 000, 000, 000, 000, 000, 000, 000 }, 1, 3 },
	{ { 0x03020100, 0x00000001, 0x00000000, 0x00000000 }, { 031, 040, 020, 051, 000, 000, 000, 000, 000, 000, 000, 000 }, 2, 4 },
	{ { 0x00020100, 0x00000000, 0x00000000, 0x00000000 }, { 010, 031, 051, 000, 000, 000, 000, 000, 000, 000, 000, 000 }, 1, 3 },
	{ { 0x00020100, 0x00000000, 0x00000000, 0x00000000 }, { 010, 040, 020, 000, 000, 000, 000, 000, 000, 000, 000, 000 }, 1, 3 },
	{ { 0x00000000, 0x00000000, 0x00000000, 0x00000000 }, { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 }, 0, 0 },
};


#else

void initializeMeshShader() {}
void testRenderMeshShader(transparent_render_pass* ldrRenderPass, float dt) {}

#endif


```

`src/rendering/mesh_shader.h`:

```h
#pragma once

#include "render_pass.h"

void initializeMeshShader();
void testRenderMeshShader(transparent_render_pass* ldrRenderPass, float dt);

```

`src/rendering/outline.cpp`:

```cpp
#include "pch.h"
#include "outline.h"

#include "render_pass.h"
#include "material.h"
#include "render_resources.h"
#include "render_algorithms.h"

#include "dx/dx_pipeline.h"

#include "outline_rs.hlsli"


static dx_pipeline outlinePipeline;

void initializeOutlinePipelines()
{
	auto markerDesc = CREATE_GRAPHICS_PIPELINE
		.inputLayout(inputLayout_position)
		.renderTargets(0, 0, depthStencilFormat)
		.stencilSettings(D3D12_COMPARISON_FUNC_ALWAYS,
			D3D12_STENCIL_OP_REPLACE,
			D3D12_STENCIL_OP_REPLACE,
			D3D12_STENCIL_OP_KEEP,
			D3D12_DEFAULT_STENCIL_READ_MASK,
			stencil_flag_selected_object) // Mark selected object.
		.depthSettings(false, false)
		.cullingOff(); // Since this is fairly light-weight, we only render double sided.

	outlinePipeline = createReloadablePipeline(markerDesc, { "outline_vs" }, rs_in_vertex_shader);
}

struct outline_render_data
{
	mat4 transform;
	dx_vertex_buffer_view vertexBuffer;
	dx_index_buffer_view indexBuffer;
	submesh_info submesh;
};

struct outline_pipeline
{
	PIPELINE_SETUP_DECL
	{
		cl->setPipelineState(*outlinePipeline.pipeline);
		cl->setGraphicsRootSignature(*outlinePipeline.rootSignature);

		cl->setPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
	}

	PIPELINE_RENDER_DECL(outline_render_data)
	{
		cl->setGraphics32BitConstants(OUTLINE_RS_MVP, outline_marker_cb{ viewProj * data.transform });

		cl->setVertexBuffer(0, data.vertexBuffer);
		cl->setIndexBuffer(data.indexBuffer);
		cl->drawIndexed(data.submesh.numIndices, 1, data.submesh.firstIndex, data.submesh.baseVertex, 0);
	}
};

void renderOutline(ldr_render_pass* renderPass, const mat4& transform, dx_vertex_buffer_view vertexBuffer, dx_index_buffer_view indexBuffer, submesh_info submesh)
{
	outline_render_data data = {
		transform,
		vertexBuffer,
		indexBuffer,
		submesh,
	};

	renderPass->renderOutline<outline_pipeline>(data);
}

void renderOutline(ldr_render_pass* renderPass, const mat4& transform, dx_vertex_buffer_group_view vertexBuffer, dx_index_buffer_view indexBuffer, submesh_info submesh)
{
	renderOutline(renderPass, transform, vertexBuffer.positions, indexBuffer, submesh);
}

```

`src/rendering/outline.h`:

```h
#pragma once

#include "core/math.h"
#include "geometry/mesh.h"

void initializeOutlinePipelines();
void renderOutline(struct ldr_render_pass* renderPass, const mat4& transform, dx_vertex_buffer_view vertexBuffer, dx_index_buffer_view indexBuffer, submesh_info submesh);
void renderOutline(struct ldr_render_pass* renderPass, const mat4& transform, dx_vertex_buffer_group_view vertexBuffer, dx_index_buffer_view indexBuffer, submesh_info submesh);

```

`src/rendering/path_tracing.cpp`:

```cpp
#include "pch.h"
#include "path_tracing.h"
#include "core/color.h"

#include "raytracing.hlsli"

#define PATH_TRACING_RS_RESOURCES   0
#define PATH_TRACING_RS_CAMERA      1
#define PATH_TRACING_RS_CB          2

void path_tracer::initialize()
{
    const wchar* shaderPath = L"shaders/raytracing/path_tracing_rts.hlsl";


    const uint32 numInputResources = sizeof(input_resources) / sizeof(dx_cpu_descriptor_handle);
    const uint32 numOutputResources = sizeof(output_resources) / sizeof(dx_cpu_descriptor_handle);

    CD3DX12_DESCRIPTOR_RANGE resourceRanges[] =
    {
        // Must be input first, then output.
        CD3DX12_DESCRIPTOR_RANGE(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, numInputResources, 0),
        CD3DX12_DESCRIPTOR_RANGE(D3D12_DESCRIPTOR_RANGE_TYPE_UAV, numOutputResources, 0),
    };

    CD3DX12_ROOT_PARAMETER globalRootParameters[] =
    {
        root_descriptor_table(arraysize(resourceRanges), resourceRanges),
        root_cbv(0), // Camera.
        root_constants<path_tracing_cb>(1),
    };

    CD3DX12_STATIC_SAMPLER_DESC globalStaticSampler(0, D3D12_FILTER_MIN_MAG_MIP_LINEAR);

    D3D12_ROOT_SIGNATURE_DESC globalDesc =
    {
        arraysize(globalRootParameters), globalRootParameters,
        1, &globalStaticSampler
    };

    pbr_raytracer::initialize(shaderPath, settings.maxPayloadSize, settings.maxRecursionDepth, globalDesc);

    allocateDescriptorHeapSpaceForGlobalResources<input_resources, output_resources>(descriptorHeap);

    oldSettings = settings;
}

void path_tracer::render(dx_command_list* cl, const raytracing_tlas& tlas,
    const ref<dx_texture>& output,
    const common_render_data& common)
{
    if (memcmp(&settings, &oldSettings, sizeof(path_tracer_settings)) != 0)
    {
        resetRendering();
        oldSettings = settings;
    }

    input_resources in;
    in.tlas = tlas.tlas->raytracingSRV;
    in.sky = common.sky->defaultSRV;

    output_resources out;
    out.output = output->defaultUAV;


    dx_gpu_descriptor_handle gpuHandle = copyGlobalResourcesToDescriptorHeap(in, out);


    // Fill out description.
    D3D12_DISPATCH_RAYS_DESC raytraceDesc;
    fillOutRayTracingRenderDesc(bindingTable.getBuffer(), raytraceDesc,
        output->width, output->height, 1,
        numRayTypes, bindingTable.getNumberOfHitGroups());


    // Set up pipeline.
    cl->setDescriptorHeap(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV, descriptorHeap.descriptorHeap);

    cl->setPipelineState(pipeline.pipeline);
    cl->setComputeRootSignature(pipeline.rootSignature);

    uint32 depth = min(settings.recursionDepth, settings.maxRecursionDepth - 1);

    cl->setComputeDescriptorTable(PATH_TRACING_RS_RESOURCES, gpuHandle);
    cl->setComputeDynamicConstantBuffer(PATH_TRACING_RS_CAMERA, common.cameraCBV);
    cl->setCompute32BitConstants(PATH_TRACING_RS_CB, 
        path_tracing_cb
        { 
            (uint32)dxContext.frameID, 
            numAveragedFrames,
            depth,
            clamp(settings.startRussianRouletteAfter, 0u, depth),
            (uint32)settings.useThinLensCamera,
            settings.focalLength,
            settings.focalLength / (2.f * settings.fNumber),
            (uint32)settings.useRealMaterials,
            (uint32)settings.enableDirectLighting,
            settings.lightIntensityScale,
            settings.pointLightRadius,
            (uint32)settings.multipleImportanceSampling,
        });

    cl->raytrace(raytraceDesc);

    ++numAveragedFrames;
}

void path_tracer::resetRendering()
{
    numAveragedFrames = 0;
}



```

`src/rendering/path_tracing.h`:

```h
#pragma once

#include "pbr_raytracer.h"

struct path_tracer_settings
{
    static const uint32 maxRecursionDepth = 4;
    static const uint32 maxPayloadSize = 5 * sizeof(float); // Radiance-payload is 1 x float3, 2 x uint.

    // Parameters.

    uint32 recursionDepth = maxRecursionDepth - 1; // [0, maxRecursionDepth - 1]. 0 and 1 don't really make sense. 0 means, that no primary ray is shot. 1 means that no bounce is computed, which leads to 0 light reaching the primary hit.
    uint32 startRussianRouletteAfter = recursionDepth; // [0, recursionDepth].

    bool useThinLensCamera = false;
    float fNumber = 32.f;
    float focalLength = 1.f;

    bool useRealMaterials = false;
    bool enableDirectLighting = false;
    float lightIntensityScale = 1.f;
    float pointLightRadius = 0.1f;

    bool multipleImportanceSampling = true;
};

struct path_tracer : pbr_raytracer
{
    void initialize();

    void render(dx_command_list* cl, const raytracing_tlas& tlas,
        const ref<dx_texture>& output,
        const common_render_data& common);

    void resetRendering();

    path_tracer_settings settings;

private:
    uint32 numAveragedFrames = 0;
    path_tracer_settings oldSettings;

    // Only descriptors in here!
    struct input_resources
    {
        dx_cpu_descriptor_handle tlas;
        dx_cpu_descriptor_handle sky;
    };

    struct output_resources
    {
        dx_cpu_descriptor_handle output;
    };
};

```

`src/rendering/pbr.cpp`:

```cpp
#include "pch.h"
#include "pbr.h"
#include "dx/dx_texture.h"
#include "texture_preprocessing.h"
#include "dx/dx_context.h"
#include "dx/dx_command_list.h"
#include "geometry/mesh_builder.h"
#include "core/color.h"
#include "core/hash.h"
#include "render_resources.h"
#include "render_utils.h"

#include "default_pbr_rs.hlsli"
#include "material.hlsli"
#include "light_source.hlsli"

#include <unordered_map>
#include <memory>

static_assert(sizeof(pbr_material_cb) == 24);

static dx_pipeline opaquePBRPipeline;
static dx_pipeline opaqueDoubleSidedPBRPipeline;
static dx_pipeline transparentPBRPipeline;

void pbr_pipeline::initialize()
{
	{
		auto desc = CREATE_GRAPHICS_PIPELINE
			.inputLayout(inputLayout_position_uv_normal_tangent)
			.renderTargets(opaqueLightPassFormats, OPQAUE_LIGHT_PASS_NO_VELOCITIES_NO_OBJECT_ID, depthStencilFormat)
			.depthSettings(true, false, D3D12_COMPARISON_FUNC_EQUAL);

		opaquePBRPipeline = createReloadablePipeline(desc, { "default_vs", "default_pbr_ps" });

		desc.cullingOff();
		opaqueDoubleSidedPBRPipeline = createReloadablePipeline(desc, { "default_vs", "default_pbr_ps" });
	}

	{
		auto desc = CREATE_GRAPHICS_PIPELINE
			.inputLayout(inputLayout_position_uv_normal_tangent)
			.renderTargets(transparentLightPassFormats, arraysize(transparentLightPassFormats), depthStencilFormat)
			.alphaBlending(0);

		transparentPBRPipeline = createReloadablePipeline(desc, { "default_vs", "default_pbr_transparent_ps" });
	}
}



void pbr_pipeline::setupPBRCommon(dx_command_list* cl, const common_render_data& common)
{
	cl->setPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

	dx_cpu_descriptor_handle nullTexture = render_resources::nullTextureSRV;
	dx_cpu_descriptor_handle nullBuffer = render_resources::nullBufferSRV;

	cl->setDescriptorHeapSRV(DEFAULT_PBR_RS_FRAME_CONSTANTS, 0, common.irradiance ? common.irradiance->defaultSRV : nullTexture);
	cl->setDescriptorHeapSRV(DEFAULT_PBR_RS_FRAME_CONSTANTS, 1, common.prefilteredRadiance ? common.prefilteredRadiance->defaultSRV : nullTexture);
	cl->setDescriptorHeapSRV(DEFAULT_PBR_RS_FRAME_CONSTANTS, 2, render_resources::brdfTex);
	cl->setDescriptorHeapSRV(DEFAULT_PBR_RS_FRAME_CONSTANTS, 3, common.tiledCullingGrid ? common.tiledCullingGrid->defaultSRV : nullTexture);
	cl->setDescriptorHeapSRV(DEFAULT_PBR_RS_FRAME_CONSTANTS, 4, common.tiledObjectsIndexList ? common.tiledObjectsIndexList->defaultSRV : nullBuffer);
	cl->setDescriptorHeapSRV(DEFAULT_PBR_RS_FRAME_CONSTANTS, 5, common.pointLightBuffer ? common.pointLightBuffer->defaultSRV : nullBuffer);
	cl->setDescriptorHeapSRV(DEFAULT_PBR_RS_FRAME_CONSTANTS, 6, common.spotLightBuffer ? common.spotLightBuffer->defaultSRV : nullBuffer);
	cl->setDescriptorHeapSRV(DEFAULT_PBR_RS_FRAME_CONSTANTS, 7, common.decalBuffer ? common.decalBuffer->defaultSRV : nullBuffer);
	cl->setDescriptorHeapSRV(DEFAULT_PBR_RS_FRAME_CONSTANTS, 8, common.shadowMap ? common.shadowMap->defaultSRV : nullTexture);
	cl->setDescriptorHeapSRV(DEFAULT_PBR_RS_FRAME_CONSTANTS, 9, common.pointLightShadowInfoBuffer ? common.pointLightShadowInfoBuffer->defaultSRV : nullBuffer);
	cl->setDescriptorHeapSRV(DEFAULT_PBR_RS_FRAME_CONSTANTS, 10, common.spotLightShadowInfoBuffer ? common.spotLightShadowInfoBuffer->defaultSRV : nullBuffer);
	cl->setDescriptorHeapSRV(DEFAULT_PBR_RS_FRAME_CONSTANTS, 11, common.decalTextureAtlas ? common.decalTextureAtlas->defaultSRV : nullTexture);
	cl->setDescriptorHeapSRV(DEFAULT_PBR_RS_FRAME_CONSTANTS, 12, common.aoTexture ? common.aoTexture : render_resources::whiteTexture);
	cl->setDescriptorHeapSRV(DEFAULT_PBR_RS_FRAME_CONSTANTS, 13, common.sssTexture ? common.sssTexture : render_resources::whiteTexture);
	cl->setDescriptorHeapSRV(DEFAULT_PBR_RS_FRAME_CONSTANTS, 14, common.ssrTexture ? common.ssrTexture->defaultSRV : nullTexture);
	cl->setDescriptorHeapSRV(DEFAULT_PBR_RS_FRAME_CONSTANTS, 15, common.lightProbeIrradiance ? common.lightProbeIrradiance->defaultSRV : nullTexture);
	cl->setDescriptorHeapSRV(DEFAULT_PBR_RS_FRAME_CONSTANTS, 16, common.lightProbeDepth ? common.lightProbeDepth->defaultSRV : nullTexture);

	cl->setGraphicsDynamicConstantBuffer(DEFAULT_PBR_RS_CAMERA, common.cameraCBV);
	cl->setGraphicsDynamicConstantBuffer(DEFAULT_PBR_RS_LIGHTING, common.lightingCBV);


	// Default material properties. This is JUST to make the dynamic descriptor heap happy.
	// These textures will NEVER be read.

	cl->setDescriptorHeapSRV(DEFAULT_PBR_RS_PBR_TEXTURES, 0, nullTexture);
	cl->setDescriptorHeapSRV(DEFAULT_PBR_RS_PBR_TEXTURES, 1, nullTexture);
	cl->setDescriptorHeapSRV(DEFAULT_PBR_RS_PBR_TEXTURES, 2, nullTexture);
	cl->setDescriptorHeapSRV(DEFAULT_PBR_RS_PBR_TEXTURES, 3, nullTexture);
}


PIPELINE_SETUP_IMPL(pbr_pipeline::opaque)
{
	cl->setPipelineState(*opaquePBRPipeline.pipeline);
	cl->setGraphicsRootSignature(*opaquePBRPipeline.rootSignature);

	setupPBRCommon(cl, common);
}

PIPELINE_SETUP_IMPL(pbr_pipeline::opaque_double_sided)
{
	cl->setPipelineState(*opaqueDoubleSidedPBRPipeline.pipeline);
	cl->setGraphicsRootSignature(*opaqueDoubleSidedPBRPipeline.rootSignature);

	setupPBRCommon(cl, common);
}

PIPELINE_SETUP_IMPL(pbr_pipeline::transparent)
{
	cl->setPipelineState(*transparentPBRPipeline.pipeline);
	cl->setGraphicsRootSignature(*transparentPBRPipeline.rootSignature);

	setupPBRCommon(cl, common);
}

PIPELINE_RENDER_IMPL(pbr_pipeline, pbr_render_data)
{
	const auto& mat = data.material;

	uint32 flags = 0;

	if (mat->albedo)
	{
		cl->setDescriptorHeapSRV(DEFAULT_PBR_RS_PBR_TEXTURES, 0, mat->albedo);
		flags |= MATERIAL_USE_ALBEDO_TEXTURE;
	}
	if (mat->normal)
	{
		cl->setDescriptorHeapSRV(DEFAULT_PBR_RS_PBR_TEXTURES, 1, mat->normal);
		flags |= MATERIAL_USE_NORMAL_TEXTURE;
	}
	if (mat->roughness)
	{
		cl->setDescriptorHeapSRV(DEFAULT_PBR_RS_PBR_TEXTURES, 2, mat->roughness);
		flags |= MATERIAL_USE_ROUGHNESS_TEXTURE;
	}
	if (mat->metallic)
	{
		cl->setDescriptorHeapSRV(DEFAULT_PBR_RS_PBR_TEXTURES, 3, mat->metallic);
		flags |= MATERIAL_USE_METALLIC_TEXTURE;
	}
	if (mat->shader != pbr_material_shader_default)
	{
		flags |= MATERIAL_DOUBLE_SIDED;
	}

	cl->setGraphics32BitConstants(DEFAULT_PBR_RS_MATERIAL,
		pbr_material_cb(mat->albedoTint, mat->emission.xyz, mat->roughnessOverride, mat->metallicOverride, flags, 1.f, mat->translucency, mat->uvScale)
	);


	const submesh_info& submesh = data.submesh;

	cl->setRootGraphicsSRV(DEFAULT_PBR_RS_TRANSFORM, data.transformPtr);

	cl->setVertexBuffer(0, data.vertexBuffer.positions);
	cl->setVertexBuffer(1, data.vertexBuffer.others);
	cl->setIndexBuffer(data.indexBuffer);
	cl->drawIndexed(submesh.numIndices, data.numInstances, submesh.firstIndex, submesh.baseVertex, 0);
}


```

`src/rendering/pbr.h`:

```h
#pragma once

#include "pbr_material.h"
#include "render_command.h"

struct dx_command_list;

struct pbr_render_data
{
	D3D12_GPU_VIRTUAL_ADDRESS transformPtr;
	dx_vertex_buffer_group_view vertexBuffer;
	dx_index_buffer_view indexBuffer;
	submesh_info submesh;

	ref<pbr_material> material;

	uint32 numInstances;
};

struct pbr_pipeline
{
	static void initialize();

	PIPELINE_RENDER_DECL(pbr_render_data);

	struct opaque;
	struct opaque_double_sided;
	struct transparent;

protected:
	static void setupPBRCommon(dx_command_list* cl, const common_render_data& common);
};

struct pbr_pipeline::opaque : pbr_pipeline
{
	PIPELINE_SETUP_DECL;
};

struct pbr_pipeline::opaque_double_sided : pbr_pipeline
{
	PIPELINE_SETUP_DECL;
};

struct pbr_pipeline::transparent : pbr_pipeline
{
	PIPELINE_SETUP_DECL;
};



```

`src/rendering/pbr_environment.cpp`:

```cpp
#include "pch.h"
#include "pbr_environment.h"
#include "texture_preprocessing.h"
#include "render_resources.h"
#include "dx/dx_context.h"
#include "asset/file_registry.h"
#include "core/job_system.h"

void pbr_environment::setFromTexture(const fs::path& filename)
{
	allocate();

	ref<dx_texture> equiSky = loadTextureFromFileAsync(filename,
		image_load_flags_noncolor | image_load_flags_cache_to_dds | image_load_flags_gen_mips_on_cpu);

	if (equiSky)
	{
		struct post_process_sky_data
		{
			ref<dx_texture> equiSky;
			ref<dx_texture>& sky;
			ref<dx_texture>& irradiance;
			ref<dx_texture>& prefilteredRadiance;
		};

		post_process_sky_data data =
		{
			equiSky,
			sky,
			irradiance,
			prefilteredRadiance,
		};

		lowPriorityJobQueue.createJob<post_process_sky_data>([](post_process_sky_data& data, job_handle)
		{
			dxContext.renderQueue.waitForOtherQueue(dxContext.copyQueue);
			dx_command_list* cl = dxContext.getFreeRenderCommandList();

			//generateMipMapsOnGPU(cl, data.equiSky);

			data.sky = equirectangularToCubemap(cl, data.equiSky, skyResolution, 0, DXGI_FORMAT_R16G16B16A16_FLOAT);
			data.sky->handle = data.equiSky->handle;
			texturedSkyToIrradiance(cl, data.sky, data.irradiance);
			texturedSkyToPrefilteredRadiance(cl, data.sky, data.prefilteredRadiance);

			SET_NAME(data.sky->resource, "Sky");

			dxContext.executeCommandList(cl);
		}, data).submitAfter(equiSky->loadJob);
	}
}

void pbr_environment::setToProcedural(vec3 sunDirection)
{
	dx_command_list* cl = dxContext.getFreeRenderCommandList();

	allocate();

	sky = 0;
	proceduralSkyToIrradiance(cl, sunDirection, irradiance);
	// TODO: Prefiltered radiance.

	dxContext.executeCommandList(cl);

	lastSunDirection = sunDirection;
}

void pbr_environment::update(vec3 sunDirection)
{
	if (isProcedural() && lastSunDirection != sunDirection)
	{
		setToProcedural(sunDirection);
	}
}

void pbr_environment::forceUpdate(vec3 sunDirection)
{
	if (isProcedural())
	{
		setToProcedural(sunDirection);
	}
}

void pbr_environment::allocate()
{
	if (!irradiance)
	{
		irradiance = createCubeTexture(0, irradianceResolution, irradianceResolution, DXGI_FORMAT_R16G16B16A16_FLOAT, false, false, true);
		SET_NAME(irradiance->resource, "Irradiance");
	}

	if (!prefilteredRadiance)
	{
		prefilteredRadiance = createCubeTexture(0, prefilteredRadianceResolution, prefilteredRadianceResolution, DXGI_FORMAT_R16G16B16A16_FLOAT,
			true, false, true, D3D12_RESOURCE_STATE_COMMON, true);
		SET_NAME(prefilteredRadiance->resource, "Prefiltered Radiance");
	}
}

```

`src/rendering/pbr_environment.h`:

```h
#pragma once

#include "dx/dx_texture.h"
#include "rendering/light_probe.h"
#include "asset/asset.h"

enum environment_gi_mode
{
	environment_gi_baked,
	environment_gi_raytraced,
};

static const char* environmentGIModeNames[] =
{
	"Baked",
	"Raytraced",
};

struct pbr_environment
{
	environment_gi_mode giMode = environment_gi_baked;

	ref<dx_texture> sky;
	ref<dx_texture> irradiance;
	ref<dx_texture> prefilteredRadiance;

	bool isProcedural() const { return sky == 0; }

	void setFromTexture(const fs::path& filename);
	void setToProcedural(vec3 sunDirection);

	void update(vec3 sunDirection);
	void forceUpdate(vec3 sunDirection);

	float globalIlluminationIntensity = 1.f;
	float skyIntensity = 1.f;

	light_probe_grid lightProbeGrid;



	static const uint32 skyResolution = 2048;
	static const uint32 irradianceResolution = 32;
	static const uint32 prefilteredRadianceResolution = 128;

	vec3 lastSunDirection = { -1, -1, -1 };

	void allocate();
};


```

`src/rendering/pbr_material.cpp`:

```cpp
#include "pch.h"
#include "pbr_material.h"


namespace std
{
	template<>
	struct hash<pbr_material_desc>
	{
		size_t operator()(const pbr_material_desc& x) const
		{
			size_t seed = 0;

			hash_combine(seed, x.albedo);
			hash_combine(seed, x.normal);
			hash_combine(seed, x.roughness);
			hash_combine(seed, x.metallic);
			hash_combine(seed, x.emission);
			hash_combine(seed, x.albedoTint);
			hash_combine(seed, x.roughnessOverride);
			hash_combine(seed, x.metallicOverride);
			hash_combine(seed, (uint32)x.shader);
			hash_combine(seed, x.uvScale);
			hash_combine(seed, x.translucency);

			return seed;
		}
	};
}

static bool operator==(const pbr_material_desc& a, const pbr_material_desc& b)
{
	return a.albedo == b.albedo
		&& a.normal == b.normal
		&& a.roughness == b.roughness
		&& a.metallic == b.metallic
		&& a.emission == b.emission
		&& a.albedoTint == b.albedoTint
		&& a.roughnessOverride == b.roughnessOverride
		&& a.metallicOverride == b.metallicOverride
		&& a.shader == b.shader
		&& a.uvScale == b.uvScale
		&& a.translucency == b.translucency;
}

static std::unordered_map<pbr_material_desc, weakref<pbr_material>> materialCache;
static std::mutex mutex;

ref<pbr_material> createPBRMaterial(const pbr_material_desc& desc)
{
	mutex.lock();

	auto sp = materialCache[desc].lock();
	if (!sp)
	{
		ref<pbr_material> material = make_ref<pbr_material>();

		if (!desc.albedo.empty()) material->albedo = loadTextureFromFile(desc.albedo, desc.albedoFlags);
		if (!desc.normal.empty()) material->normal = loadTextureFromFile(desc.normal, desc.normalFlags);
		if (!desc.roughness.empty()) material->roughness = loadTextureFromFile(desc.roughness, desc.roughnessFlags);
		if (!desc.metallic.empty()) material->metallic = loadTextureFromFile(desc.metallic, desc.metallicFlags);
		material->emission = desc.emission;
		material->albedoTint = desc.albedoTint;
		material->roughnessOverride = desc.roughnessOverride;
		material->metallicOverride = desc.metallicOverride;
		material->shader = desc.shader;
		material->uvScale = desc.uvScale;
		material->translucency = desc.translucency;

		materialCache[desc] = sp = material;
	}

	mutex.unlock();
	return sp;
}

ref<pbr_material> createPBRMaterialAsync(const pbr_material_desc& desc, job_handle parentJob)
{
	mutex.lock();

	auto sp = materialCache[desc].lock();
	if (!sp)
	{
		ref<pbr_material> material = make_ref<pbr_material>();

		if (!desc.albedo.empty()) material->albedo = loadTextureFromFileAsync(desc.albedo, desc.albedoFlags, parentJob);
		if (!desc.normal.empty()) material->normal = loadTextureFromFileAsync(desc.normal, desc.normalFlags, parentJob);
		if (!desc.roughness.empty()) material->roughness = loadTextureFromFileAsync(desc.roughness, desc.roughnessFlags, parentJob);
		if (!desc.metallic.empty()) material->metallic = loadTextureFromFileAsync(desc.metallic, desc.metallicFlags, parentJob);
		material->emission = desc.emission;
		material->albedoTint = desc.albedoTint;
		material->roughnessOverride = desc.roughnessOverride;
		material->metallicOverride = desc.metallicOverride;
		material->shader = desc.shader;
		material->uvScale = desc.uvScale;
		material->translucency = desc.translucency;

		materialCache[desc] = sp = material;
	}

	mutex.unlock();
	return sp;
}

ref<pbr_material> getDefaultPBRMaterial()
{
	static ref<pbr_material> material = createPBRMaterial({});
	return material;
}


```

`src/rendering/pbr_material.h`:

```h
#pragma once

#include "core/math.h"
#include "core/job_system.h"
#include "material.h"

enum pbr_material_shader
{
	pbr_material_shader_default,
	pbr_material_shader_double_sided,
	pbr_material_shader_alpha_cutout,
	pbr_material_shader_transparent,

	pbr_material_shader_count,
};

static const char* pbrMaterialShaderNames[] =
{
	"Default",
	"Double sided",
	"Alpha cutout",
	"Transparent",
};

struct pbr_material_desc
{
	fs::path albedo;
	fs::path normal;
	fs::path roughness;
	fs::path metallic;

	uint32 albedoFlags = image_load_flags_default;
	uint32 normalFlags = image_load_flags_default_noncolor;
	uint32 roughnessFlags = image_load_flags_default_noncolor;
	uint32 metallicFlags = image_load_flags_default_noncolor;

	vec4 emission = vec4(0.f);
	vec4 albedoTint = vec4(1.f);
	float roughnessOverride = 1.f;
	float metallicOverride = 0.f;
	pbr_material_shader shader = pbr_material_shader_default;
	float uvScale = 1.f;
	float translucency = 0.f;
};

struct pbr_material
{
	ref<dx_texture> albedo;
	ref<dx_texture> normal;
	ref<dx_texture> roughness;
	ref<dx_texture> metallic;

	vec4 emission;
	vec4 albedoTint;
	float roughnessOverride;
	float metallicOverride;
	pbr_material_shader shader;
	float uvScale;
	float translucency;
};

ref<pbr_material> createPBRMaterial(const pbr_material_desc& desc);
ref<pbr_material> createPBRMaterialAsync(const pbr_material_desc& desc, job_handle parentJob = {});
ref<pbr_material> getDefaultPBRMaterial();


```

`src/rendering/pbr_raytracer.cpp`:

```cpp
#include "pch.h"
#include "pbr_raytracer.h"


void pbr_raytracer::initialize(const wchar* shaderPath, uint32 maxPayloadSize, uint32 maxRecursionDepth, const D3D12_ROOT_SIGNATURE_DESC& globalDesc)
{
    // 6 Elements: Vertex buffer, index buffer, albedo texture, normal map, roughness texture, metallic texture.
    CD3DX12_DESCRIPTOR_RANGE hitSRVRange(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 6, 0, 1);
    CD3DX12_ROOT_PARAMETER hitRootParameters[] =
    {
        root_constants<pbr_material_cb>(0, 1),
        root_descriptor_table(1, &hitSRVRange),
    };

    D3D12_ROOT_SIGNATURE_DESC hitDesc =
    {
        arraysize(hitRootParameters), hitRootParameters
    };


    raytracing_mesh_hitgroup radianceHitgroup = { L"radianceClosestHit" };
    raytracing_mesh_hitgroup shadowHitgroup = { };

    pipeline =
        raytracing_pipeline_builder(shaderPath, maxPayloadSize, maxRecursionDepth, true, false)
        .globalRootSignature(globalDesc)
        .raygen(L"rayGen")
        .hitgroup(L"RADIANCE", L"radianceMiss", radianceHitgroup, hitDesc)
        .hitgroup(L"SHADOW", L"shadowMiss", shadowHitgroup)
        .finish();

    ASSERT(numRayTypes == 0 || numRayTypes == (uint32)pipeline.shaderBindingTableDesc.hitGroups.size());
    numRayTypes = (uint32)pipeline.shaderBindingTableDesc.hitGroups.size();

    bindingTable.initialize(&pipeline);



    // Common stuff.

    if (!descriptorHeap.descriptorHeap)
    {
        descriptorHeap.initialize(2048); // TODO.
    }

    registeredPBRRaytracers.push_back(this);
}

void pbr_raytracer::pushTexture(const ref<dx_texture>& tex, uint32& flags, uint32 flag)
{
    if (tex)
    {
        descriptorHeap.push().create2DTextureSRV(tex);
        flags |= flag;
    }
    else
    {
        descriptorHeap.push().createNullTextureSRV();
    }
}

raytracing_object_type pbr_raytracer::defineObjectType(const ref<raytracing_blas>& blas, const std::vector<ref<pbr_material>>& materials)
{
    /*
    HitGroupRecordAddress = D3D12_DISPATCH_RAYS_DESC.HitGroupTable.StartAddress +
            D3D12_DISPATCH_RAYS_DESC.HitGroupTable.StrideInBytes *
                (RayContributionToHitGroupIndex +
                (MultiplierForGeometryContributionToHitGroupIndex * GeometryContributionToHitGroupIndex) + D3D12_RAYTRACING_INSTANCE_DESC.InstanceContributionToHitGroupIndex)
    */


    uint32 numGeometries = (uint32)blas->geometries.size();

    shader_data* hitData = (shader_data*)alloca(sizeof(shader_data) * numRayTypes);

    mutex.lock();

    for (uint32 i = 0; i < numGeometries; ++i)
    {
        ASSERT(blas->geometries[i].type == raytracing_mesh_geometry); // For now we only support meshes, not procedurals.

        submesh_info submesh = blas->geometries[i].submesh;
        const ref<pbr_material>& material = materials[i];

        dx_gpu_descriptor_handle base = descriptorHeap.currentGPU;

        descriptorHeap.push().createBufferSRV(blas->geometries[i].vertexBuffer.others, { submesh.baseVertex, submesh.numVertices });
        descriptorHeap.push().createRawBufferSRV(blas->geometries[i].indexBuffer, { submesh.firstIndex, submesh.numIndices });

        uint32 flags = 0;
        pushTexture(material->albedo, flags, MATERIAL_USE_ALBEDO_TEXTURE);
        pushTexture(material->normal, flags, MATERIAL_USE_NORMAL_TEXTURE);
        pushTexture(material->roughness, flags, MATERIAL_USE_ROUGHNESS_TEXTURE);
        pushTexture(material->metallic, flags, MATERIAL_USE_METALLIC_TEXTURE);

        if (blas->geometries[i].indexBuffer->elementSize == 4)
        {
            flags |= MATERIAL_USE_32_BIT_INDICES;
        }

        hitData[0].materialCB.initialize(
            material->albedoTint,
            material->emission.xyz,
            material->roughnessOverride,
            material->metallicOverride,
            flags
        );
        hitData[0].resources = base;

        // The other shader types don't need any data, so we don't set it here.

        for (auto rt : registeredPBRRaytracers)
        {
            rt->bindingTable.push(hitData);
        }
    }


    raytracing_object_type result = { blas, instanceContributionToHitGroupIndex };

    instanceContributionToHitGroupIndex += numGeometries * numRayTypes;

    for (auto rt : registeredPBRRaytracers)
    {
        rt->dirty = true;
    }

    mutex.unlock();

    return result;
}

void pbr_raytracer::finalizeForRender()
{
    if (dirty)
    {
        bindingTable.build();
        dirty = false;
    }
}

```

`src/rendering/pbr_raytracer.h`:

```h
#pragma once

#include "raytracer.h"
#include "material.hlsli"
#include "pbr.h"


struct pbr_raytracer : dx_raytracer
{
    static raytracing_object_type defineObjectType(const ref<raytracing_blas>& blas, const std::vector<ref<pbr_material>>& materials);
    void finalizeForRender();

protected:

    void initialize(const wchar* shaderPath, uint32 maxPayloadSize, uint32 maxRecursionDepth, const D3D12_ROOT_SIGNATURE_DESC& globalDesc);
 
    struct shader_data // This struct is 32 bytes large, which together with the 32 byte shader identifier is a nice multiple of the required 32-byte-alignment of the binding table entries.
    {
        pbr_material_cb materialCB;
        dx_gpu_descriptor_handle resources; // Vertex buffer, index buffer, PBR textures.
    };

    static_assert(sizeof(pbr_material_cb) == 24);
    static_assert(sizeof(shader_data) == 32);


    static inline uint32 numRayTypes = 0;

    raytracing_binding_table<shader_data> bindingTable;

    static inline dx_pushable_descriptor_heap descriptorHeap;

private:
    static void pushTexture(const ref<dx_texture>& tex, uint32& flags, uint32 flag);

    static inline uint32 instanceContributionToHitGroupIndex = 0;
    static inline std::mutex mutex;

    bool dirty = true;
    static inline std::vector<pbr_raytracer*> registeredPBRRaytracers;
};

```

`src/rendering/raytraced_reflections.cpp`:

```cpp
#include "pch.h"
#include "raytraced_reflections.h"
#include "core/color.h"
#include "render_resources.h"
#include "pbr_raytracer.h"

#include "dx/dx_profiling.h"
#include "dx/dx_barrier_batcher.h"

#include "rt_reflections_rs.hlsli"


struct rt_reflections_raytracer : pbr_raytracer
{
    void initialize();

    void render(dx_command_list* cl, const raytracing_tlas& tlas,
        ref<dx_texture> depthStencilBuffer,
        ref<dx_texture> worldNormalsRoughnessTexture,
        ref<dx_texture> screenVelocitiesTexture,
        ref<dx_texture> raycastTexture,
        ref<dx_texture> resolveTexture,
        ref<dx_texture> temporalHistory,
        ref<dx_texture> temporalOutput,
        const common_render_data& common);

private:

    const uint32 maxRecursionDepth = 2;

    // Only descriptors in here!
    struct input_resources
    {
        dx_cpu_descriptor_handle tlas;
        dx_cpu_descriptor_handle sky;
        dx_cpu_descriptor_handle probeIrradiance;
        dx_cpu_descriptor_handle probeDepth;
        dx_cpu_descriptor_handle depthBuffer;
        dx_cpu_descriptor_handle worldNormalsAndRoughness;
        dx_cpu_descriptor_handle noise;
        dx_cpu_descriptor_handle screenVelocitiesTexture;
    };

    struct output_resources
    {
        dx_cpu_descriptor_handle output;
    };
};




static rt_reflections_raytracer rtReflectionsTracer;


void initializeRTReflectionsPipelines()
{
    if (!dxContext.featureSupport.raytracing())
    {
        return;
    }

    rtReflectionsTracer.initialize();
}

void raytraceRTReflections(dx_command_list* cl, const raytracing_tlas& tlas, 
    ref<dx_texture> depthStencilBuffer,
    ref<dx_texture> worldNormalsRoughnessTexture,
    ref<dx_texture> screenVelocitiesTexture,
    ref<dx_texture> raycastTexture,
    ref<dx_texture> resolveTexture,
    ref<dx_texture> temporalHistory,	
    ref<dx_texture> temporalOutput,
    const common_render_data& common)
{
    if (!dxContext.featureSupport.raytracing())
    {
        return;
    }

    rtReflectionsTracer.finalizeForRender();
    rtReflectionsTracer.render(cl, tlas, depthStencilBuffer, worldNormalsRoughnessTexture, screenVelocitiesTexture, 
        raycastTexture, resolveTexture, temporalHistory, temporalOutput, common);
}

void rt_reflections_raytracer::initialize()
{
    const wchar* shaderPath = L"shaders/reflections/rt_reflections_rts.hlsl";


    const uint32 numInputResources = sizeof(input_resources) / sizeof(dx_cpu_descriptor_handle);
    const uint32 numOutputResources = sizeof(output_resources) / sizeof(dx_cpu_descriptor_handle);

    CD3DX12_DESCRIPTOR_RANGE resourceRanges[] =
    {
        // Must be input first, then output.
        CD3DX12_DESCRIPTOR_RANGE(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, numInputResources, 0),
        CD3DX12_DESCRIPTOR_RANGE(D3D12_DESCRIPTOR_RANGE_TYPE_UAV, numOutputResources, 0),
    };

    CD3DX12_ROOT_PARAMETER globalRootParameters[] =
    {
        root_descriptor_table(arraysize(resourceRanges), resourceRanges),
        root_constants<rt_reflections_cb>(0),
        root_cbv(1), // Camera.
        root_cbv(2), // Sun.
    };

    CD3DX12_STATIC_SAMPLER_DESC globalStaticSamplers[] =
    {
       CD3DX12_STATIC_SAMPLER_DESC(0, D3D12_FILTER_MIN_MAG_MIP_LINEAR),
       CD3DX12_STATIC_SAMPLER_DESC(1, D3D12_FILTER_MIN_MAG_MIP_POINT, D3D12_TEXTURE_ADDRESS_MODE_CLAMP, D3D12_TEXTURE_ADDRESS_MODE_CLAMP, D3D12_TEXTURE_ADDRESS_MODE_CLAMP),
    };

    D3D12_ROOT_SIGNATURE_DESC globalDesc =
    {
        arraysize(globalRootParameters), globalRootParameters,
        arraysize(globalStaticSamplers), globalStaticSamplers
    };

    pbr_raytracer::initialize(shaderPath, 3 * sizeof(float), maxRecursionDepth, globalDesc);

    allocateDescriptorHeapSpaceForGlobalResources<input_resources, output_resources>(descriptorHeap);
}

void rt_reflections_raytracer::render(dx_command_list* cl, const raytracing_tlas& tlas,
    ref<dx_texture> depthStencilBuffer,
    ref<dx_texture> worldNormalsRoughnessTexture,
    ref<dx_texture> screenVelocitiesTexture,
    ref<dx_texture> raycastTexture,
    ref<dx_texture> resolveTexture,
    ref<dx_texture> temporalHistory,
    ref<dx_texture> temporalOutput,
    const common_render_data& common)
{
    if (!tlas.tlas)
    {
        return;
    }

    {
        PROFILE_ALL(cl, "Raytrace reflections");

        input_resources in;
        in.tlas = tlas.tlas->raytracingSRV;
        in.sky = common.sky->defaultSRV;
        in.probeIrradiance = common.lightProbeIrradiance->defaultSRV;
        in.probeDepth = common.lightProbeDepth->defaultSRV;
        in.depthBuffer = depthStencilBuffer->defaultSRV;
        in.worldNormalsAndRoughness = worldNormalsRoughnessTexture->defaultSRV;
        in.noise = render_resources::noiseTexture->defaultSRV;
        in.screenVelocitiesTexture = screenVelocitiesTexture->defaultSRV;

        output_resources out;
        out.output = resolveTexture->defaultUAV;


        dx_gpu_descriptor_handle gpuHandle = copyGlobalResourcesToDescriptorHeap(in, out);


        // Fill out description.
        D3D12_DISPATCH_RAYS_DESC raytraceDesc;
        fillOutRayTracingRenderDesc(bindingTable.getBuffer(), raytraceDesc,
            resolveTexture->width, resolveTexture->height, 1,
            numRayTypes, bindingTable.getNumberOfHitGroups());

        rt_reflections_cb cb;
        cb.sampleSkyFromTexture = !common.proceduralSky;
        cb.frameIndex = (uint32)dxContext.frameID;


        // Set up pipeline.
        cl->setDescriptorHeap(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV, descriptorHeap.descriptorHeap);

        cl->setPipelineState(pipeline.pipeline);
        cl->setComputeRootSignature(pipeline.rootSignature);

        cl->setComputeDescriptorTable(RT_REFLECTIONS_RS_RESOURCES, gpuHandle);
        cl->setCompute32BitConstants(RT_REFLECTIONS_RS_CB, cb);
        cl->setComputeDynamicConstantBuffer(RT_REFLECTIONS_RS_CAMERA, common.cameraCBV);
        cl->setComputeDynamicConstantBuffer(RT_REFLECTIONS_RS_LIGHTING, common.lightingCBV);

        cl->raytrace(raytraceDesc);

        cl->resetToDynamicDescriptorHeap();
    }

    {
        void ssrTemporal(dx_command_list* cl,
            ref<dx_texture> screenVelocitiesTexture,
            ref<dx_texture> resolveTexture,
            ref<dx_texture> ssrTemporalHistory,
            ref<dx_texture> ssrTemporalOutput);

        barrier_batcher(cl)
            //.uav(resolveTexture)
            .transition(resolveTexture, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE);

        ssrTemporal(cl, screenVelocitiesTexture, resolveTexture, temporalHistory, temporalOutput);
    }
}

```

`src/rendering/raytraced_reflections.h`:

```h
#pragma once

#include "dx/dx_texture.h"

void initializeRTReflectionsPipelines();
void raytraceRTReflections(struct dx_command_list* cl, const struct raytracing_tlas& tlas, 
	ref<dx_texture> depthStencilBuffer,				// NON_PIXEL_SHADER_RESOURCE
	ref<dx_texture> worldNormalsRoughnessTexture,	// NON_PIXEL_SHADER_RESOURCE
	ref<dx_texture> screenVelocitiesTexture,		// NON_PIXEL_SHADER_RESOURCE
	ref<dx_texture> raycastTexture,					// UNORDERED_ACCESS
	ref<dx_texture> resolveTexture,					// UNORDERED_ACCESS. After call D3D12_RESOURCE_STATE_GENERIC_READ. Also output of this algorithm.
	ref<dx_texture> temporalHistory,				// NON_PIXEL_SHADER_RESOURCE. After call UNORDERED_ACCESS.
	ref<dx_texture> temporalOutput,					// UNORDERED_ACCESS. After call NON_PIXEL_SHADER_RESOURCE.
	const struct common_render_data& common);



```

`src/rendering/raytracer.cpp`:

```cpp
#include "pch.h"
#include "raytracer.h"


void dx_raytracer::fillOutRayTracingRenderDesc(const ref<dx_buffer>& bindingTableBuffer,
    D3D12_DISPATCH_RAYS_DESC& raytraceDesc,
    uint32 renderWidth, uint32 renderHeight, uint32 renderDepth,
    uint32 numRayTypes, uint32 numHitGroups)
{
    raytraceDesc.Width = renderWidth;
    raytraceDesc.Height = renderHeight;
    raytraceDesc.Depth = renderDepth;

    uint32 numHitShaders = numHitGroups * numRayTypes;

    // Pointer to the entry point of the ray-generation shader.
    raytraceDesc.RayGenerationShaderRecord.StartAddress = bindingTableBuffer->gpuVirtualAddress + pipeline.shaderBindingTableDesc.raygenOffset;
    raytraceDesc.RayGenerationShaderRecord.SizeInBytes = pipeline.shaderBindingTableDesc.entrySize;

    // Pointer to the entry point(s) of the miss shader.
    raytraceDesc.MissShaderTable.StartAddress = bindingTableBuffer->gpuVirtualAddress + pipeline.shaderBindingTableDesc.missOffset;
    raytraceDesc.MissShaderTable.StrideInBytes = pipeline.shaderBindingTableDesc.entrySize;
    raytraceDesc.MissShaderTable.SizeInBytes = pipeline.shaderBindingTableDesc.entrySize * numRayTypes;

    // Pointer to the entry point(s) of the hit shader.
    raytraceDesc.HitGroupTable.StartAddress = bindingTableBuffer->gpuVirtualAddress + pipeline.shaderBindingTableDesc.hitOffset;
    raytraceDesc.HitGroupTable.StrideInBytes = pipeline.shaderBindingTableDesc.entrySize;
    raytraceDesc.HitGroupTable.SizeInBytes = pipeline.shaderBindingTableDesc.entrySize * numHitShaders;

    raytraceDesc.CallableShaderTable = {};
}

```

`src/rendering/raytracer.h`:

```h
#pragma once

#include "raytracing.h"
#include "raytracing_tlas.h"
#include "raytracing_binding_table.h"
#include "dx/dx_descriptor_allocation.h"

#include "dx/dx_command_list.h"

#include "material.h"

struct dx_raytracer
{

protected:
	void fillOutRayTracingRenderDesc(const ref<dx_buffer>& bindingTableBuffer,
		D3D12_DISPATCH_RAYS_DESC& raytraceDesc,
		uint32 renderWidth, uint32 renderHeight, uint32 renderDepth,
		uint32 numRayTypes, uint32 numHitGroups);

	template <typename input_resources, typename output_resources>
	dx_gpu_descriptor_handle copyGlobalResourcesToDescriptorHeap(const input_resources& in, const output_resources& out);

	template <typename input_resources, typename output_resources>
	void allocateDescriptorHeapSpaceForGlobalResources(dx_pushable_descriptor_heap& descriptorHeap);

	dx_raytracing_pipeline pipeline;

	
	dx_cpu_descriptor_handle resourceCPUBase[NUM_BUFFERED_FRAMES];
	dx_gpu_descriptor_handle resourceGPUBase[NUM_BUFFERED_FRAMES];
};

template<typename input_resources, typename output_resources>
inline dx_gpu_descriptor_handle dx_raytracer::copyGlobalResourcesToDescriptorHeap(const input_resources& in, const output_resources& out)
{
	dx_cpu_descriptor_handle cpuHandle = resourceCPUBase[dxContext.bufferedFrameID];
	dx_gpu_descriptor_handle gpuHandle = resourceGPUBase[dxContext.bufferedFrameID];

	const uint32 numInputResources = sizeof(input_resources) / sizeof(dx_cpu_descriptor_handle);
	const uint32 numOutputResources = sizeof(output_resources) / sizeof(dx_cpu_descriptor_handle);
	const uint32 totalNumResources = numInputResources + numOutputResources;

	D3D12_CPU_DESCRIPTOR_HANDLE handles[totalNumResources];
	memcpy(handles, &in, sizeof(input_resources));
	memcpy((D3D12_CPU_DESCRIPTOR_HANDLE*)handles + numInputResources, &out, sizeof(output_resources));

	dxContext.device->CopyDescriptors(
		1, (D3D12_CPU_DESCRIPTOR_HANDLE*)&cpuHandle, &totalNumResources,
		totalNumResources, handles, nullptr,
		D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV
	);

	return gpuHandle;
}

template<typename input_resources, typename output_resources>
inline void dx_raytracer::allocateDescriptorHeapSpaceForGlobalResources(dx_pushable_descriptor_heap& descriptorHeap)
{
	const uint32 numInputResources = sizeof(input_resources) / sizeof(dx_cpu_descriptor_handle);
	const uint32 numOutputResources = sizeof(output_resources) / sizeof(dx_cpu_descriptor_handle);
	const uint32 totalNumResources = numInputResources + numOutputResources;

	for (uint32 i = 0; i < NUM_BUFFERED_FRAMES; ++i)
	{
		resourceCPUBase[i] = descriptorHeap.currentCPU;
		resourceGPUBase[i] = descriptorHeap.currentGPU;

		for (uint32 j = 0; j < totalNumResources; ++j)
		{
			descriptorHeap.push();
		}
	}
}

```

`src/rendering/raytracing.cpp`:

```cpp
#include "pch.h"
#include "raytracing.h"
#include "dx/dx_context.h"
#include "dx/dx_command_list.h"

#include "core/string.h"

#include <dxcapi.h>
#include <fstream>
#include <sstream>

raytracing_blas_builder& raytracing_blas_builder::push(vertex_buffer_group vertexBuffer, ref<dx_index_buffer> indexBuffer, submesh_info submesh, bool opaque, const trs& localTransform)
{
	D3D12_RAYTRACING_GEOMETRY_DESC geomDesc;

	geomDesc.Type = D3D12_RAYTRACING_GEOMETRY_TYPE_TRIANGLES;
	geomDesc.Flags = opaque ? D3D12_RAYTRACING_GEOMETRY_FLAG_OPAQUE : D3D12_RAYTRACING_GEOMETRY_FLAG_NONE;

	if (&localTransform == &trs::identity)
	{
		geomDesc.Triangles.Transform3x4 = UINT64_MAX;
	}
	else
	{
		geomDesc.Triangles.Transform3x4 = localTransforms.size();
		localTransforms.push_back(transpose(trsToMat4(localTransform)));
	}

	geomDesc.Triangles.VertexBuffer.StartAddress = vertexBuffer.positions->gpuVirtualAddress + (vertexBuffer.positions->elementSize * submesh.baseVertex);
	geomDesc.Triangles.VertexBuffer.StrideInBytes = vertexBuffer.positions->elementSize;
	geomDesc.Triangles.VertexFormat = DXGI_FORMAT_R32G32B32_FLOAT;
	geomDesc.Triangles.VertexCount = submesh.numVertices;

	geomDesc.Triangles.IndexBuffer = indexBuffer->gpuVirtualAddress + (indexBuffer->elementSize * submesh.firstIndex);
	geomDesc.Triangles.IndexFormat = getIndexBufferFormat(indexBuffer->elementSize);
	geomDesc.Triangles.IndexCount = submesh.numIndices;

	geometryDescs.push_back(geomDesc);
	geometries.push_back({ raytracing_mesh_geometry, vertexBuffer, indexBuffer, submesh });

	return *this;
}

raytracing_blas_builder& raytracing_blas_builder::push(const std::vector<bounding_box>& boundingBoxes, bool opaque)
{
	D3D12_RAYTRACING_GEOMETRY_DESC geomDesc;

	geomDesc.Type = D3D12_RAYTRACING_GEOMETRY_TYPE_PROCEDURAL_PRIMITIVE_AABBS;
	geomDesc.Flags = opaque ? D3D12_RAYTRACING_GEOMETRY_FLAG_OPAQUE : D3D12_RAYTRACING_GEOMETRY_FLAG_NONE;

	for (uint32 i = 0; i < (uint32)boundingBoxes.size(); ++i)
	{
		D3D12_RAYTRACING_AABB& w = aabbDescs.emplace_back();
		const bounding_box& r = boundingBoxes[i];

		w.MinX = r.minCorner.x;
		w.MinY = r.minCorner.y;
		w.MinZ = r.minCorner.z;

		w.MaxX = r.maxCorner.x;
		w.MaxY = r.maxCorner.y;
		w.MaxZ = r.maxCorner.z;
	}

	geomDesc.AABBs.AABBCount = boundingBoxes.size();

	geometryDescs.push_back(geomDesc);
	geometries.push_back({ raytracing_procedural_geometry });

	return *this;
}

ref<raytracing_blas> raytracing_blas_builder::finish(bool keepScratch)
{	
	dx_dynamic_constant_buffer localTransformsBuffer = {};
	if (localTransforms.size() > 0)
	{
		localTransformsBuffer = dxContext.uploadDynamicConstantBuffer(sizeof(mat4) * (uint32)localTransforms.size(), localTransforms.data()).first;
	}

	dx_dynamic_constant_buffer aabbBuffer = {};
	if (aabbDescs.size())
	{
		aabbBuffer = dxContext.uploadDynamicConstantBuffer(sizeof(D3D12_RAYTRACING_AABB) * (uint32)aabbDescs.size(), aabbDescs.data()).first;
	}

	uint64 aabbOffset = 0;

	for (auto& desc : geometryDescs)
	{
		if (desc.Type == D3D12_RAYTRACING_GEOMETRY_TYPE_TRIANGLES)
		{
			if (desc.Triangles.Transform3x4 == UINT64_MAX)
			{
				desc.Triangles.Transform3x4 = 0;
			}
			else
			{
				desc.Triangles.Transform3x4 = localTransformsBuffer.gpuPtr + sizeof(mat4) * desc.Triangles.Transform3x4;
			}
		}
		else if (desc.Type == D3D12_RAYTRACING_GEOMETRY_TYPE_PROCEDURAL_PRIMITIVE_AABBS)
		{
			desc.AABBs.AABBs.StartAddress = aabbBuffer.gpuPtr + sizeof(D3D12_RAYTRACING_AABB) * aabbOffset;
			desc.AABBs.AABBs.StrideInBytes = sizeof(D3D12_RAYTRACING_AABB);
			aabbOffset += desc.AABBs.AABBCount;
		}
	}




	D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS inputs = {};
	inputs.DescsLayout = D3D12_ELEMENTS_LAYOUT_ARRAY;
	inputs.Flags = D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_NONE;

	inputs.NumDescs = (uint32)geometryDescs.size();
	inputs.pGeometryDescs = geometryDescs.data();

	inputs.Type = D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL;



	// Allocate.
	D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO info = {};
	dxContext.device->GetRaytracingAccelerationStructurePrebuildInfo(&inputs, &info);

	info.ScratchDataSizeInBytes = alignTo(info.ScratchDataSizeInBytes, D3D12_CONSTANT_BUFFER_DATA_PLACEMENT_ALIGNMENT);
	info.ResultDataMaxSizeInBytes = alignTo(info.ResultDataMaxSizeInBytes, D3D12_CONSTANT_BUFFER_DATA_PLACEMENT_ALIGNMENT);

	ref<raytracing_blas> blas = make_ref<raytracing_blas>();
	blas->scratch = createBuffer((uint32)info.ScratchDataSizeInBytes, 1, 0, true, false);
	blas->blas = createBuffer((uint32)info.ResultDataMaxSizeInBytes, 1, 0, true, false, D3D12_RESOURCE_STATE_RAYTRACING_ACCELERATION_STRUCTURE);

	SET_NAME(blas->scratch->resource, "BLAS Scratch");
	SET_NAME(blas->blas->resource, "BLAS Result");

	blas->geometries = std::move(geometries);

	D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC asDesc = {};
	asDesc.Inputs = inputs;
	asDesc.DestAccelerationStructureData = blas->blas->gpuVirtualAddress;
	asDesc.ScratchAccelerationStructureData = blas->scratch->gpuVirtualAddress;

	dx_command_list* cl = dxContext.getFreeComputeCommandList(true);
	cl->commandList->BuildRaytracingAccelerationStructure(&asDesc, 0, 0);
	cl->uavBarrier(blas->blas);
	dxContext.executeCommandList(cl);

	if (!keepScratch)
	{
		blas->scratch = 0;
	}

	return blas;
}


static void reportShaderCompileError(com<IDxcBlobEncoding> blob)
{
	char infoLog[2048];
	memcpy(infoLog, blob->GetBufferPointer(), sizeof(infoLog) - 1);
	infoLog[sizeof(infoLog) - 1] = 0;
	std::cerr << "Error:\n" << infoLog << '\n';
}

static com<IDxcBlob> compileLibrary(const std::wstring& filename, const std::vector<const wchar*>& shaderNameDefines)
{
	com<IDxcCompiler> compiler;
	com<IDxcLibrary> library;
	com<IDxcIncludeHandler> includeHandler;
	checkResult(DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(&compiler)));
	checkResult(DxcCreateInstance(CLSID_DxcLibrary, IID_PPV_ARGS(&library)));
	checkResult(library->CreateIncludeHandler(&includeHandler));


	std::string source = "#include \"" + wstringToString(filename) + "\"\n";

	//std::ifstream stream(filename);
	//if (!stream.is_open())
	//{
	//	//std::cerr <<  "File " << filename << " not found." << '\n';
	//	return 0;
	//}
	//std::stringstream ss; ss << stream.rdbuf();
	//std::string source = ss.str();


	// Create blob from the string.
	com<IDxcBlobEncoding> textBlob;
	checkResult(library->CreateBlobWithEncodingFromPinned((LPBYTE)source.c_str(), (uint32)source.length(), 0, &textBlob));

	std::vector<DxcDefine> defines;

	std::vector<std::wstring> valueStrings;
	valueStrings.reserve(1 + shaderNameDefines.size()); // Important. We pull out raw char pointers from these, so the vector should not reallocate.

	valueStrings.push_back(std::to_wstring(shaderNameDefines.size()));
	defines.push_back({ L"NUM_RAY_TYPES", valueStrings.back().c_str() });

	for (uint32 i = 0; i < shaderNameDefines.size(); ++i)
	{
		valueStrings.push_back(std::to_wstring(i));
		defines.push_back({ shaderNameDefines[i], valueStrings.back().c_str() });
	}


	defines.push_back({ L"HLSL" });
	defines.push_back({ L"mat4",	L"float4x4" });
	defines.push_back({ L"vec2",	L"float2" });
	defines.push_back({ L"vec3",	L"float3" });
	defines.push_back({ L"vec4",	L"float4" });
	defines.push_back({ L"uint32",	L"uint" });


	// Compile.
	com<IDxcOperationResult> operationResult;
	checkResult(compiler->Compile(textBlob.Get(), 0, L"", L"lib_6_3", 0, 0, defines.data(), (uint32)defines.size(), includeHandler.Get(), &operationResult));

	// Verify the result.
	HRESULT resultCode;
	checkResult(operationResult->GetStatus(&resultCode));
	if (FAILED(resultCode))
	{
		com<IDxcBlobEncoding> error;
		checkResult(operationResult->GetErrorBuffer(&error));
		reportShaderCompileError(error);
		ASSERT(false);
		return 0;
	}

	com<IDxcBlob> blob;
	checkResult(operationResult->GetResult(&blob));

	return blob;
}





raytracing_pipeline_builder::raytracing_pipeline_builder(const wchar* shaderFilename, uint32 payloadSize, uint32 maxRecursionDepth, bool hasMeshGeometry, bool hasProceduralGeometry)
{
	this->shaderFilename = shaderFilename;
	this->payloadSize = payloadSize;
	this->maxRecursionDepth = maxRecursionDepth;
	this->hasMeshGeometry = hasMeshGeometry;
	this->hasProceduralGeometry = hasProceduralGeometry;

	ASSERT(hasMeshGeometry || hasProceduralGeometry);
}

raytracing_pipeline_builder::raytracing_root_signature raytracing_pipeline_builder::createRaytracingRootSignature(const D3D12_ROOT_SIGNATURE_DESC& desc)
{
	raytracing_root_signature result;
	result.rootSignature = createRootSignature(desc);
	result.rootSignaturePtr = result.rootSignature.rootSignature.Get();
	return result;
}

raytracing_pipeline_builder& raytracing_pipeline_builder::globalRootSignature(D3D12_ROOT_SIGNATURE_DESC rootSignatureDesc)
{
	ASSERT(!globalRS.rootSignature.rootSignature);

	globalRS = createRaytracingRootSignature(rootSignatureDesc);
	SET_NAME(globalRS.rootSignature.rootSignature, "Global raytracing root signature");

	auto& so = subobjects[numSubobjects++];
	so.pDesc = &globalRS.rootSignaturePtr;
	so.Type = D3D12_STATE_SUBOBJECT_TYPE_GLOBAL_ROOT_SIGNATURE;

	return *this;
}

static uint32 getShaderBindingTableSize(const D3D12_ROOT_SIGNATURE_DESC& rootSignatureDesc)
{
	uint32 size = 0;
	for (uint32 i = 0; i < rootSignatureDesc.NumParameters; ++i)
	{
		if (rootSignatureDesc.pParameters[i].ParameterType == D3D12_ROOT_PARAMETER_TYPE_32BIT_CONSTANTS)
		{
			size += alignTo(rootSignatureDesc.pParameters[i].Constants.Num32BitValues * 4, 8);
		} 
		else
		{
			size += 8;
		}
	}
	return size;
}

raytracing_pipeline_builder& raytracing_pipeline_builder::raygen(const wchar* entryPoint, D3D12_ROOT_SIGNATURE_DESC rootSignatureDesc)
{
	ASSERT(!raygenRS.rootSignature.rootSignature);

	D3D12_EXPORT_DESC& exp = exports[numExports++];
	exp.Name = entryPoint;
	exp.Flags = D3D12_EXPORT_FLAG_NONE;
	exp.ExportToRename = 0;

	raygenEntryPoint = entryPoint;


	rootSignatureDesc.Flags |= D3D12_ROOT_SIGNATURE_FLAG_LOCAL_ROOT_SIGNATURE;
	raygenRS = createRaytracingRootSignature(rootSignatureDesc);
	SET_NAME(raygenRS.rootSignature.rootSignature, "Local raytracing root signature");

	{
		auto& so = subobjects[numSubobjects++];
		so.pDesc = &raygenRS.rootSignaturePtr;
		so.Type = D3D12_STATE_SUBOBJECT_TYPE_LOCAL_ROOT_SIGNATURE;
	}

	{
		auto& so = subobjects[numSubobjects++];
		auto& as = associations[numAssociations++];

		stringBuffer[numStrings++] = entryPoint;

		as.NumExports = 1;
		as.pExports = &stringBuffer[numStrings - 1];
		as.pSubobjectToAssociate = &subobjects[numSubobjects - 2];

		so.Type = D3D12_STATE_SUBOBJECT_TYPE_SUBOBJECT_TO_EXPORTS_ASSOCIATION;
		so.pDesc = &as;
	}

	allExports.push_back(entryPoint);

	uint32 size = getShaderBindingTableSize(rootSignatureDesc);
	tableEntrySize = max(size, tableEntrySize);

	return *this;
}

raytracing_pipeline_builder& raytracing_pipeline_builder::hitgroup(const wchar* groupName, const wchar* miss,
	raytracing_mesh_hitgroup mesh, D3D12_ROOT_SIGNATURE_DESC meshRootSignatureDesc,
	raytracing_procedural_hitgroup procedural, D3D12_ROOT_SIGNATURE_DESC proceduralRootSignatureDesc)
{
	auto exportEntryPoint = [this](const wchar* entryPoint)
	{
		D3D12_EXPORT_DESC& exp = exports[numExports++];
		exp.Name = entryPoint;
		exp.Flags = D3D12_EXPORT_FLAG_NONE;
		exp.ExportToRename = 0;

		allExports.push_back(entryPoint);
	};

	auto createLocalRootSignature = [this](D3D12_ROOT_SIGNATURE_DESC rootSignatureDesc, const wchar* closestHit, const wchar* anyHit, const wchar* intersection)
	{
		if (rootSignatureDesc.NumParameters > 0)
		{
			rootSignatureDesc.Flags |= D3D12_ROOT_SIGNATURE_FLAG_LOCAL_ROOT_SIGNATURE;
			rootSignatures[numRootSignatures++] = createRaytracingRootSignature(rootSignatureDesc);

			{
				auto& so = subobjects[numSubobjects++];
				so.pDesc = &rootSignatures[numRootSignatures - 1].rootSignaturePtr;
				so.Type = D3D12_STATE_SUBOBJECT_TYPE_LOCAL_ROOT_SIGNATURE;
			}

			{
				auto& so = subobjects[numSubobjects++];
				auto& as = associations[numAssociations++];

				const wchar** entryPoints = &stringBuffer[numStrings];
				uint32 numEntryPoints = 0;

				if (closestHit) { entryPoints[numEntryPoints++] = closestHit; }
				if (anyHit) { entryPoints[numEntryPoints++] = anyHit; }
				if (intersection) { entryPoints[numEntryPoints++] = intersection; }

				numStrings += numEntryPoints;

				as.NumExports = numEntryPoints;
				as.pExports = entryPoints;
				as.pSubobjectToAssociate = &subobjects[numSubobjects - 2];

				so.Type = D3D12_STATE_SUBOBJECT_TYPE_SUBOBJECT_TO_EXPORTS_ASSOCIATION;
				so.pDesc = &as;
			}

			uint32 size = getShaderBindingTableSize(rootSignatureDesc);
			tableEntrySize = max(size, tableEntrySize);
		}
	};

	if (hasMeshGeometry)
	{
		groupNameStorage[groupNameStoragePtr++] = std::wstring(groupName) + L"_MESH";
		const wchar* name = groupNameStorage[groupNameStoragePtr - 1].c_str();

		D3D12_HIT_GROUP_DESC& hitGroup = hitGroups[numHitGroups++];

		hitGroup.Type = D3D12_HIT_GROUP_TYPE_TRIANGLES;
		hitGroup.AnyHitShaderImport = mesh.anyHit;
		hitGroup.ClosestHitShaderImport = mesh.closestHit;
		hitGroup.IntersectionShaderImport = 0;
		hitGroup.HitGroupExport = name;

		auto& so = subobjects[numSubobjects++];
		so.Type = D3D12_STATE_SUBOBJECT_TYPE_HIT_GROUP;
		so.pDesc = &hitGroup;

		if (mesh.closestHit) { exportEntryPoint(mesh.closestHit); }
		if (mesh.anyHit) { exportEntryPoint(mesh.anyHit); }

		createLocalRootSignature(meshRootSignatureDesc, mesh.closestHit, mesh.anyHit, 0);
	}

	if (hasProceduralGeometry)
	{
		groupNameStorage[groupNameStoragePtr++] = std::wstring(groupName) + L"_PROC";
		const wchar* name = groupNameStorage[groupNameStoragePtr - 1].c_str();

		D3D12_HIT_GROUP_DESC& hitGroup = hitGroups[numHitGroups++];

		hitGroup.Type = D3D12_HIT_GROUP_TYPE_PROCEDURAL_PRIMITIVE;
		hitGroup.AnyHitShaderImport = procedural.anyHit;
		hitGroup.ClosestHitShaderImport = procedural.closestHit;
		hitGroup.IntersectionShaderImport = procedural.intersection;
		hitGroup.HitGroupExport = name;

		auto& so = subobjects[numSubobjects++];
		so.Type = D3D12_STATE_SUBOBJECT_TYPE_HIT_GROUP;
		so.pDesc = &hitGroup;

		ASSERT(procedural.intersection);

		if (procedural.closestHit) { exportEntryPoint(procedural.closestHit); }
		if (procedural.intersection) { exportEntryPoint(procedural.intersection); }
		if (procedural.anyHit) { exportEntryPoint(procedural.anyHit); }

		createLocalRootSignature(meshRootSignatureDesc, procedural.closestHit, procedural.anyHit, procedural.intersection);
	}

	exportEntryPoint(miss);
	emptyAssociations.push_back(miss);
	missEntryPoints.push_back(miss);

	shaderNameDefines.push_back(groupName);

	return *this;
}

dx_raytracing_pipeline raytracing_pipeline_builder::finish()
{
	ASSERT(raygenRS.rootSignature.rootSignature);
	ASSERT(globalRS.rootSignature.rootSignature);

	auto shaderBlob = compileLibrary(shaderFilename, shaderNameDefines);

	D3D12_DXIL_LIBRARY_DESC dxilLibDesc;
	dxilLibDesc.DXILLibrary.pShaderBytecode = shaderBlob->GetBufferPointer();
	dxilLibDesc.DXILLibrary.BytecodeLength = shaderBlob->GetBufferSize();
	dxilLibDesc.NumExports = numExports;
	dxilLibDesc.pExports = exports;

	D3D12_ROOT_SIGNATURE_DESC emptyRootSignatureDesc = {};
	emptyRootSignatureDesc.Flags = D3D12_ROOT_SIGNATURE_FLAG_LOCAL_ROOT_SIGNATURE;
	raytracing_root_signature emptyRootSignature = createRaytracingRootSignature(emptyRootSignatureDesc);

	D3D12_RAYTRACING_SHADER_CONFIG shaderConfig;
	D3D12_RAYTRACING_PIPELINE_CONFIG pipelineConfig;

	{
		D3D12_STATE_SUBOBJECT& so = subobjects[numSubobjects++];
		so.Type = D3D12_STATE_SUBOBJECT_TYPE_DXIL_LIBRARY;
		so.pDesc = &dxilLibDesc;
	}

	{
		D3D12_STATE_SUBOBJECT& so = subobjects[numSubobjects++];
		so.pDesc = &emptyRootSignature.rootSignaturePtr;
		so.Type = D3D12_STATE_SUBOBJECT_TYPE_LOCAL_ROOT_SIGNATURE;
	}

	{
		auto& so = subobjects[numSubobjects++];
		auto& as = associations[numAssociations++];

		as.NumExports = (uint32)emptyAssociations.size();
		as.pExports = emptyAssociations.data();
		as.pSubobjectToAssociate = &subobjects[numSubobjects - 2];

		so.Type = D3D12_STATE_SUBOBJECT_TYPE_SUBOBJECT_TO_EXPORTS_ASSOCIATION;
		so.pDesc = &as;
	}

	{
		shaderConfig.MaxAttributeSizeInBytes = sizeof(float) * 2; // 2 floats for the BuiltInTriangleIntersectionAttributes.
		shaderConfig.MaxPayloadSizeInBytes = payloadSize;

		auto& so = subobjects[numSubobjects++];
		so.Type = D3D12_STATE_SUBOBJECT_TYPE_RAYTRACING_SHADER_CONFIG;
		so.pDesc = &shaderConfig;
	}

	{
		auto& so = subobjects[numSubobjects++];
		auto& as = associations[numAssociations++];

		as.NumExports = (uint32)allExports.size();
		as.pExports = allExports.data();
		as.pSubobjectToAssociate = &subobjects[numSubobjects - 2];

		so.Type = D3D12_STATE_SUBOBJECT_TYPE_SUBOBJECT_TO_EXPORTS_ASSOCIATION;
		so.pDesc = &as;
	}

	{
		pipelineConfig.MaxTraceRecursionDepth = maxRecursionDepth;

		auto& so = subobjects[numSubobjects++];
		so.Type = D3D12_STATE_SUBOBJECT_TYPE_RAYTRACING_PIPELINE_CONFIG;
		so.pDesc = &pipelineConfig;
	}


	D3D12_STATE_OBJECT_DESC desc;
	desc.NumSubobjects = numSubobjects;
	desc.pSubobjects = subobjects;
	desc.Type = D3D12_STATE_OBJECT_TYPE_RAYTRACING_PIPELINE;

	dx_raytracing_pipeline result;
	checkResult(dxContext.device->CreateStateObject(&desc, IID_PPV_ARGS(&result.pipeline)));
	result.rootSignature = globalRS.rootSignature;


	for (uint32 i = 0; i < numRootSignatures; ++i)
	{
		freeRootSignature(rootSignatures[i].rootSignature);
	}
	freeRootSignature(raygenRS.rootSignature);


	com<ID3D12StateObjectProperties> rtsoProps;
	result.pipeline->QueryInterface(IID_PPV_ARGS(&rtsoProps));


	{
		auto& shaderBindingTableDesc = result.shaderBindingTableDesc;
		tableEntrySize += D3D12_SHADER_IDENTIFIER_SIZE_IN_BYTES;
		shaderBindingTableDesc.entrySize = (uint32)alignTo(tableEntrySize, D3D12_RAYTRACING_SHADER_RECORD_BYTE_ALIGNMENT);

		uint32 numGeometryTypes = hasMeshGeometry + hasProceduralGeometry;

		uint32 numRaygenShaderEntries = 1;
		uint32 numMissShaderEntries = numHitGroups / numGeometryTypes;

		shaderBindingTableDesc.raygen = rtsoProps->GetShaderIdentifier(raygenEntryPoint);

		uint32 numUniqueGroups = (uint32)missEntryPoints.size();
		ASSERT(numUniqueGroups * numGeometryTypes == numHitGroups);

		for (uint32 i = 0; i < numUniqueGroups; ++i)
		{
			shaderBindingTableDesc.miss.push_back(rtsoProps->GetShaderIdentifier(missEntryPoints[i]));

			raytracing_shader& shader = shaderBindingTableDesc.hitGroups.emplace_back();
			shader = { };
			if (hasMeshGeometry)
			{
				shader.mesh = rtsoProps->GetShaderIdentifier(hitGroups[numGeometryTypes * i].HitGroupExport);
			}
			if (hasProceduralGeometry)
			{
				shader.procedural = rtsoProps->GetShaderIdentifier(hitGroups[numGeometryTypes * i + numGeometryTypes - 1].HitGroupExport);
			}
		}


		shaderBindingTableDesc.raygenOffset = 0;
		shaderBindingTableDesc.missOffset = shaderBindingTableDesc.raygenOffset + (uint32)alignTo(numRaygenShaderEntries * tableEntrySize, D3D12_RAYTRACING_SHADER_TABLE_BYTE_ALIGNMENT);
		shaderBindingTableDesc.hitOffset = shaderBindingTableDesc.missOffset + (uint32)alignTo(numMissShaderEntries * tableEntrySize, D3D12_RAYTRACING_SHADER_TABLE_BYTE_ALIGNMENT);
	}

	return result;
}


```

`src/rendering/raytracing.h`:

```h
#pragma once

#include "geometry/mesh.h"
#include "dx/dx_buffer.h"
#include "core/math.h"
#include "dx/dx_pipeline.h"

// Formula for hit shader index calculation: https://microsoft.github.io/DirectX-Specs/d3d/Raytracing.html#hit-group-table-indexing


enum raytracing_as_rebuild_mode
{
	raytracing_as_rebuild,
	raytracing_as_refit,
};

enum raytracing_geometry_type
{
	raytracing_mesh_geometry,
	raytracing_procedural_geometry,
};

struct raytracing_blas_geometry
{
	raytracing_geometry_type type;

	// Only valid for mesh geometry.
	vertex_buffer_group vertexBuffer;
	ref<dx_index_buffer> indexBuffer;
	submesh_info submesh;
};

struct raytracing_blas
{
	ref<dx_buffer> scratch;
	ref<dx_buffer> blas;

	std::vector<raytracing_blas_geometry> geometries;
};

struct raytracing_blas_builder
{
	raytracing_blas_builder& push(vertex_buffer_group vertexBuffer, ref<dx_index_buffer> indexBuffer, submesh_info submesh, bool opaque = true, const trs& localTransform = trs::identity);
	raytracing_blas_builder& push(const std::vector<bounding_box>& boundingBoxes, bool opaque);
	ref<raytracing_blas> finish(bool keepScratch = false);

private:
	std::vector<D3D12_RAYTRACING_GEOMETRY_DESC> geometryDescs;

	std::vector<raytracing_blas_geometry> geometries;

	std::vector<mat4> localTransforms;				// For meshes.
	std::vector<D3D12_RAYTRACING_AABB> aabbDescs;	// For procedurals.
};

struct raytracing_object_type
{
	ref<raytracing_blas> blas;
	uint32 instanceContributionToHitGroupIndex;
};

struct raytrace_component
{
	raytracing_object_type type;
};


struct raytracing_shader
{
	void* mesh;
	void* procedural;
};

struct raytracing_shader_binding_table_desc
{
	uint32 entrySize;

	void* raygen;
	std::vector<void*> miss;
	std::vector<raytracing_shader> hitGroups;

	uint32 raygenOffset;
	uint32 missOffset;
	uint32 hitOffset;
};

struct dx_raytracing_pipeline
{
	dx_raytracing_pipeline_state pipeline;
	dx_root_signature rootSignature;

	raytracing_shader_binding_table_desc shaderBindingTableDesc;
};







struct raytracing_mesh_hitgroup
{
	const wchar* closestHit;	// Optional.
	const wchar* anyHit;		// Optional.
};

struct raytracing_procedural_hitgroup
{
	const wchar* intersection;
	const wchar* closestHit;	// Optional.
	const wchar* anyHit;		// Optional.
};


struct raytracing_pipeline_builder
{
	raytracing_pipeline_builder(const wchar* shaderFilename, uint32 payloadSize, uint32 maxRecursionDepth, bool hasMeshGeometry, bool hasProceduralGeometry);

	raytracing_pipeline_builder& globalRootSignature(D3D12_ROOT_SIGNATURE_DESC rootSignatureDesc);
	raytracing_pipeline_builder& raygen(const wchar* entryPoint, D3D12_ROOT_SIGNATURE_DESC rootSignatureDesc = {});

	// The root signature describes parameters for both hit shaders. Miss will not get any arguments for now.
	raytracing_pipeline_builder& hitgroup(const wchar* groupName, const wchar* miss, 
		raytracing_mesh_hitgroup mesh, D3D12_ROOT_SIGNATURE_DESC meshRootSignatureDesc = {}, 
		raytracing_procedural_hitgroup procedural = {}, D3D12_ROOT_SIGNATURE_DESC proceduralRootSignatureDesc = {});

	dx_raytracing_pipeline finish();


private:
	struct raytracing_root_signature
	{
		dx_root_signature rootSignature;
		ID3D12RootSignature* rootSignaturePtr;
	};

	raytracing_root_signature createRaytracingRootSignature(const D3D12_ROOT_SIGNATURE_DESC& desc);


	raytracing_root_signature globalRS;
	raytracing_root_signature raygenRS;

	std::vector<const wchar*> emptyAssociations;
	std::vector<const wchar*> allExports;

	const wchar* raygenEntryPoint;
	std::vector<const wchar*> missEntryPoints;

	std::vector<const wchar*> shaderNameDefines;

	uint32 payloadSize;
	uint32 maxRecursionDepth;

	bool hasMeshGeometry; 
	bool hasProceduralGeometry;

	uint32 tableEntrySize = 0;

	const wchar* shaderFilename;

	// Since these store pointers to each other, they are not resizable arrays.
	D3D12_STATE_SUBOBJECT subobjects[512];
	uint32 numSubobjects = 0;

	D3D12_SUBOBJECT_TO_EXPORTS_ASSOCIATION associations[16];
	uint32 numAssociations = 0;

	D3D12_HIT_GROUP_DESC hitGroups[8];
	uint32 numHitGroups = 0;

	D3D12_EXPORT_DESC exports[24];
	uint32 numExports = 0;

	const wchar* stringBuffer[128];
	uint32 numStrings = 0;

	raytracing_root_signature rootSignatures[8];
	uint32 numRootSignatures = 0;

	std::wstring groupNameStorage[8];
	uint32 groupNameStoragePtr = 0;
};

```

`src/rendering/raytracing_binding_table.h`:

```h
#pragma once

#include "raytracing.h"

template <typename shader_data>
struct raytracing_binding_table
{
    void initialize(const dx_raytracing_pipeline* pipeline);

    // This expects an array of length numRayTypes, i.e. shader data for all hit groups.
    void push(const shader_data* sd);

    void build();

    ref<dx_buffer> getBuffer() { return bindingTableBuffer; }
    uint32 getNumberOfHitGroups() { return currentHitGroup; }

private:

    struct alignas(D3D12_RAYTRACING_SHADER_RECORD_BYTE_ALIGNMENT) binding_table_entry
    {
        uint8 identifier[D3D12_SHADER_IDENTIFIER_SIZE_IN_BYTES];

        shader_data shaderData;
    };

    void allocate();

    void* bindingTable = 0;
    uint32 totalBindingTableSize;

    uint32 maxNumHitGroups;
    uint32 currentHitGroup = 0;

    uint32 numRayTypes;

    binding_table_entry* raygen;
    binding_table_entry* miss;
    binding_table_entry* hit;

    const dx_raytracing_pipeline* pipeline;

    ref<dx_buffer> bindingTableBuffer;
};


template<typename shader_data>
inline void raytracing_binding_table<shader_data>::initialize(const dx_raytracing_pipeline* pipeline)
{
    this->pipeline = pipeline;

    ASSERT(pipeline->shaderBindingTableDesc.entrySize == sizeof(binding_table_entry));

    numRayTypes = (uint32)pipeline->shaderBindingTableDesc.hitGroups.size();
    maxNumHitGroups = 1024;
    allocate();

    memcpy(raygen->identifier, pipeline->shaderBindingTableDesc.raygen, D3D12_SHADER_IDENTIFIER_SIZE_IN_BYTES);
    for (uint32 i = 0; i < numRayTypes; ++i)
    {
        binding_table_entry* m = miss + i;
        memcpy(m->identifier, pipeline->shaderBindingTableDesc.miss[i], D3D12_SHADER_IDENTIFIER_SIZE_IN_BYTES);
    }
}

template<typename shader_data>
inline void raytracing_binding_table<shader_data>::allocate()
{
    totalBindingTableSize = (uint32)
        (alignTo(sizeof(binding_table_entry), D3D12_RAYTRACING_SHADER_TABLE_BYTE_ALIGNMENT)
            + alignTo(sizeof(binding_table_entry) * numRayTypes, D3D12_RAYTRACING_SHADER_TABLE_BYTE_ALIGNMENT)
            + alignTo(sizeof(binding_table_entry) * numRayTypes * maxNumHitGroups, D3D12_RAYTRACING_SHADER_TABLE_BYTE_ALIGNMENT));

    if (!bindingTable)
    {
        bindingTable = _aligned_malloc(totalBindingTableSize, D3D12_RAYTRACING_SHADER_TABLE_BYTE_ALIGNMENT);
    }
    else
    {
        bindingTable = _aligned_realloc(bindingTable, totalBindingTableSize, D3D12_RAYTRACING_SHADER_TABLE_BYTE_ALIGNMENT);
    }

    ASSERT(pipeline->shaderBindingTableDesc.raygenOffset == 0);
    ASSERT(pipeline->shaderBindingTableDesc.missOffset == alignTo(sizeof(binding_table_entry), D3D12_RAYTRACING_SHADER_TABLE_BYTE_ALIGNMENT));
    ASSERT(pipeline->shaderBindingTableDesc.hitOffset == alignTo((1 + numRayTypes) * sizeof(binding_table_entry), D3D12_RAYTRACING_SHADER_TABLE_BYTE_ALIGNMENT));

    raygen = (binding_table_entry*)bindingTable;
    miss = (binding_table_entry*)alignTo(raygen + 1, D3D12_RAYTRACING_SHADER_TABLE_BYTE_ALIGNMENT);
    hit = (binding_table_entry*)alignTo(miss + numRayTypes, D3D12_RAYTRACING_SHADER_TABLE_BYTE_ALIGNMENT);
}

template<typename shader_data>
inline void raytracing_binding_table<shader_data>::push(const shader_data* sd)
{
    if (currentHitGroup >= maxNumHitGroups)
    {
        maxNumHitGroups *= 2;
        allocate();
    }

    binding_table_entry* base = hit + (numRayTypes * currentHitGroup);
    ++currentHitGroup;

    for (uint32 i = 0; i < numRayTypes; ++i)
    {
        binding_table_entry* h = base + i;

        memcpy(h->identifier, pipeline->shaderBindingTableDesc.hitGroups[i].mesh, D3D12_SHADER_IDENTIFIER_SIZE_IN_BYTES);
        h->shaderData = sd[i];
    }
}

template<typename shader_data>
inline void raytracing_binding_table<shader_data>::build()
{
    bindingTableBuffer = createBuffer(1, max(totalBindingTableSize, 1u), bindingTable);
}

```

`src/rendering/raytracing_tlas.cpp`:

```cpp
#include "pch.h"
#include "raytracing_tlas.h"

#include "dx/dx_command_list.h"
#include "dx/dx_barrier_batcher.h"

void raytracing_tlas::initialize(raytracing_as_rebuild_mode rebuildMode)
{
    this->rebuildMode = rebuildMode;
    allInstances.reserve(4096); // TODO
}

void raytracing_tlas::reset()
{
    allInstances.clear();
}

raytracing_instance_handle raytracing_tlas::instantiate(raytracing_object_type type, const trs& transform)
{
    uint32 result = (uint32)allInstances.size();
    D3D12_RAYTRACING_INSTANCE_DESC& instance = allInstances.emplace_back();

    instance.Flags = 0;// D3D12_RAYTRACING_INSTANCE_FLAG_TRIANGLE_FRONT_COUNTERCLOCKWISE;
    instance.InstanceContributionToHitGroupIndex = type.instanceContributionToHitGroupIndex;

    mat4 m = transpose(trsToMat4(transform));
    memcpy(instance.Transform, &m, sizeof(instance.Transform));
    instance.AccelerationStructure = type.blas->blas->gpuVirtualAddress;
    instance.InstanceMask = 0xFF;
    instance.InstanceID = 0; // This value will be exposed to the shader via InstanceID().

    return { result };
}

void raytracing_tlas::build(dx_command_list* cl)
{
    uint32 totalNumInstances = (uint32)allInstances.size();

    D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS inputs = {};
    inputs.DescsLayout = D3D12_ELEMENTS_LAYOUT_ARRAY;
    inputs.Flags = D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_NONE;
    inputs.NumDescs = totalNumInstances;
    inputs.Type = D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL;

    if (rebuildMode == raytracing_as_refit)
    {
        inputs.Flags |= D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_ALLOW_UPDATE;
    }

    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO info;
    dxContext.device->GetRaytracingAccelerationStructurePrebuildInfo(&inputs, &info);
    info.ScratchDataSizeInBytes = alignTo(info.ScratchDataSizeInBytes, D3D12_CONSTANT_BUFFER_DATA_PLACEMENT_ALIGNMENT);
    info.ResultDataMaxSizeInBytes = alignTo(info.ResultDataMaxSizeInBytes, D3D12_CONSTANT_BUFFER_DATA_PLACEMENT_ALIGNMENT);

    bool fromScratch = false;

    // Allocate.
    if (!tlas || tlas->totalSize < info.ResultDataMaxSizeInBytes)
    {
        if (tlas)
        {
            resizeBuffer(tlas, (uint32)info.ResultDataMaxSizeInBytes, D3D12_RESOURCE_STATE_RAYTRACING_ACCELERATION_STRUCTURE);
        }
        else
        {
            tlas = createRaytracingTLASBuffer((uint32)info.ResultDataMaxSizeInBytes);
            SET_NAME(tlas->resource, "TLAS Result");
        }

        fromScratch = true;
    }

    if (!scratch || scratch->totalSize < info.ScratchDataSizeInBytes)
    {
        if (scratch)
        {
            resizeBuffer(scratch, (uint32)info.ScratchDataSizeInBytes);
        }
        else
        {
            scratch = createBuffer(1, (uint32)info.ScratchDataSizeInBytes, 0, true, false);
            SET_NAME(scratch->resource, "TLAS Scratch");
        }
    }



    dx_dynamic_constant_buffer gpuInstances = dxContext.uploadDynamicConstantBuffer(sizeof(D3D12_RAYTRACING_INSTANCE_DESC) * totalNumInstances, allInstances.data()).first;

    inputs.InstanceDescs = gpuInstances.gpuPtr;

    D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC asDesc = {};
    asDesc.Inputs = inputs;
    asDesc.DestAccelerationStructureData = tlas->gpuVirtualAddress;
    asDesc.ScratchAccelerationStructureData = scratch->gpuVirtualAddress;

    if (!fromScratch)
    {
        barrier_batcher(cl)
            .uav(tlas)
            .uav(scratch);

        if (rebuildMode == raytracing_as_refit)
        {
            asDesc.Inputs.Flags |= D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_PERFORM_UPDATE;
            asDesc.SourceAccelerationStructureData = tlas->gpuVirtualAddress;
        }
    }


    cl->commandList->BuildRaytracingAccelerationStructure(&asDesc, 0, 0);
    cl->uavBarrier(tlas);
}

```

`src/rendering/raytracing_tlas.h`:

```h
#pragma once

#include "raytracing.h"

struct raytracing_instance_handle
{
	uint32 instanceIndex;
};

struct raytracing_tlas
{
	void initialize(raytracing_as_rebuild_mode rebuildMode = raytracing_as_rebuild);

	// Call these each frame to rebuild the structure.
	void reset();
	raytracing_instance_handle instantiate(raytracing_object_type type, const trs& transform);
	void build(struct dx_command_list* cl);


	std::vector<D3D12_RAYTRACING_INSTANCE_DESC> allInstances;

	raytracing_as_rebuild_mode rebuildMode;

	ref<dx_buffer> scratch;
	ref<dx_buffer> tlas;
};

```

`src/rendering/render_algorithms.cpp`:

```cpp
#include "pch.h"
#include "render_algorithms.h"
#include "dx/dx_profiling.h"
#include "dx/dx_barrier_batcher.h"
#include "core/cpu_profiling.h"

#include "render_resources.h"
#include "render_utils.h"

#include "post_processing_rs.hlsli"
#include "ssr_rs.hlsli"
#include "light_culling_rs.hlsli"
#include "depth_only_rs.hlsli"
#include "sky_rs.hlsli"
#include "outline_rs.hlsli"
#include "transform.hlsli"
#include "visualization_rs.hlsli"


static dx_pipeline textureSkyPipeline;
static dx_pipeline proceduralSkyPipeline;

static dx_pipeline outlineDrawerPipeline;

static dx_pipeline shadowMapCopyPipeline;

static dx_pipeline worldSpaceFrustaPipeline;
static dx_pipeline lightCullingPipeline;

static dx_pipeline ssrRaycastPipeline;
static dx_pipeline ssrResolvePipeline;
static dx_pipeline ssrTemporalPipeline;
static dx_pipeline ssrMedianBlurPipeline;

static dx_pipeline specularAmbientPipeline;

static dx_pipeline hierarchicalLinearDepthPipeline;

static dx_pipeline gaussianBlurFloatPipelines[gaussian_blur_kernel_size_count];
static dx_pipeline gaussianBlurFloat4Pipelines[gaussian_blur_kernel_size_count];

static dx_pipeline dilationPipeline;
static dx_pipeline erosionPipeline;

static dx_pipeline taaPipeline;

static dx_pipeline blitPipeline;

static dx_pipeline bloomThresholdPipeline;
static dx_pipeline bloomCombinePipeline;

static dx_pipeline hbaoPipeline;
static dx_pipeline sssPipeline;

static dx_pipeline shadowBlurXPipeline;
static dx_pipeline shadowBlurYPipeline;

static dx_pipeline tonemapPipeline;
static dx_pipeline presentPipeline;

static dx_pipeline depthSobelPipeline;

static dx_pipeline visualizeSunShadowCascadesPipeline;


#pragma pack(push, 1)
struct indirect_rigid_depth_prepass_command
{
	D3D12_VERTEX_BUFFER_VIEW vertexBufferView;		// 16 bytes.
	D3D12_INDEX_BUFFER_VIEW indexBufferView;		// 16 bytes -> 32 bytes total.
	depth_only_transform_cb transform;				// 128 bytes -> 160 bytes total.
	uint32 objectID;								// 4 bytes -> 164 bytes total.
	D3D12_DRAW_INDEXED_ARGUMENTS drawArguments;		// 20 bytes -> 184 bytes total.
	uint32 padding[2];								// 8 bytes -> 192 bytes total (divisible by 16).
};

struct indirect_animated_depth_prepass_command
{
	D3D12_VERTEX_BUFFER_VIEW vertexBufferView;		// 16 bytes.
	D3D12_INDEX_BUFFER_VIEW indexBufferView;		// 16 bytes -> 32 bytes total.
	depth_only_transform_cb transform;				// 128 bytes -> 160 bytes total.
	uint32 objectID;								// 4 bytes -> 164 bytes total.
	D3D12_GPU_VIRTUAL_ADDRESS prevFramePositions;	// 8 bytes -> 172 bytes total.
	D3D12_DRAW_INDEXED_ARGUMENTS drawArguments;		// 20 bytes -> 192 bytes total (divisible by 16).
};
#pragma pack(pop)


void loadCommonShaders()
{
	// Sky.
	{
		auto desc = CREATE_GRAPHICS_PIPELINE
			.renderTargets(skyPassFormats, arraysize(skyPassFormats), depthStencilFormat)
			.depthSettings(true, false)
			.cullFrontFaces();

		textureSkyPipeline = createReloadablePipeline(desc, { "sky_vs", "sky_texture_ps" });
		proceduralSkyPipeline = createReloadablePipeline(desc, { "sky_vs", "sky_procedural_ps" });
	}

	// Outline.
	{
		auto drawerDesc = CREATE_GRAPHICS_PIPELINE
			.renderTargets(ldrFormat, depthStencilFormat)
			.stencilSettings(D3D12_COMPARISON_FUNC_EQUAL,
				D3D12_STENCIL_OP_KEEP,
				D3D12_STENCIL_OP_KEEP,
				D3D12_STENCIL_OP_KEEP,
				stencil_flag_selected_object, // Read only selected object bit.
				0)
			.depthSettings(false, false);

		outlineDrawerPipeline = createReloadablePipeline(drawerDesc, { "fullscreen_triangle_vs", "outline_ps" });
	}

	// Shadow map copy.
	{
		auto desc = CREATE_GRAPHICS_PIPELINE
			.renderTargets(0, 0, shadowDepthFormat)
			.depthSettings(true, true, D3D12_COMPARISON_FUNC_ALWAYS)
			.cullingOff();

		shadowMapCopyPipeline = createReloadablePipeline(desc, { "fullscreen_triangle_vs", "shadow_map_copy_ps" });
	}

	worldSpaceFrustaPipeline = createReloadablePipeline("world_space_tiled_frusta_cs");
	lightCullingPipeline = createReloadablePipeline("light_culling_cs");

	ssrRaycastPipeline = createReloadablePipeline("ssr_raycast_cs");
	ssrResolvePipeline = createReloadablePipeline("ssr_resolve_cs");
	ssrTemporalPipeline = createReloadablePipeline("ssr_temporal_cs");
	ssrMedianBlurPipeline = createReloadablePipeline("ssr_median_blur_cs");

	specularAmbientPipeline = createReloadablePipeline("specular_ambient_cs");

	hierarchicalLinearDepthPipeline = createReloadablePipeline("hierarchical_linear_depth_cs");

	gaussianBlurFloatPipelines[gaussian_blur_5x5] = createReloadablePipeline("gaussian_blur_5x5_float_cs");
	gaussianBlurFloatPipelines[gaussian_blur_9x9] = createReloadablePipeline("gaussian_blur_9x9_float_cs");
	gaussianBlurFloatPipelines[gaussian_blur_13x13] = createReloadablePipeline("gaussian_blur_13x13_float_cs");

	gaussianBlurFloat4Pipelines[gaussian_blur_5x5] = createReloadablePipeline("gaussian_blur_5x5_float4_cs");
	gaussianBlurFloat4Pipelines[gaussian_blur_9x9] = createReloadablePipeline("gaussian_blur_9x9_float4_cs");
	gaussianBlurFloat4Pipelines[gaussian_blur_13x13] = createReloadablePipeline("gaussian_blur_13x13_float4_cs");

	dilationPipeline = createReloadablePipeline("dilation_cs");
	erosionPipeline = createReloadablePipeline("erosion_cs");

	taaPipeline = createReloadablePipeline("taa_cs");

	blitPipeline = createReloadablePipeline("blit_cs");

	bloomThresholdPipeline = createReloadablePipeline("bloom_threshold_cs");
	bloomCombinePipeline = createReloadablePipeline("bloom_combine_cs");

	hbaoPipeline = createReloadablePipeline("hbao_cs");
	sssPipeline = createReloadablePipeline("sss_cs");

	shadowBlurXPipeline = createReloadablePipeline("shadow_blur_x_cs");
	shadowBlurYPipeline = createReloadablePipeline("shadow_blur_y_cs");

	tonemapPipeline = createReloadablePipeline("tonemap_cs");
	presentPipeline = createReloadablePipeline("present_cs");

	depthSobelPipeline = createReloadablePipeline("depth_sobel_cs");


	visualizeSunShadowCascadesPipeline = createReloadablePipeline("sun_shadow_cascades_cs");
}

void depthPrePass(dx_command_list* cl,
	const dx_render_target& depthOnlyRenderTarget,
	const opaque_render_pass* opaqueRenderPass,
	const mat4& viewProj, const mat4& prevFrameViewProj,
	const common_render_data& common)
{
	if (opaqueRenderPass)
	{
		PROFILE_ALL(cl, "Depth pre-pass");

		cl->setRenderTarget(depthOnlyRenderTarget);
		cl->setViewport(depthOnlyRenderTarget.viewport);

		pipeline_setup_func lastSetupFunc = 0;

		for (const auto& dc : opaqueRenderPass->depthPrepass)
		{
			if (dc.setup != lastSetupFunc)
			{
				dc.setup(cl, common);
				lastSetupFunc = dc.setup;
			}
			dc.render(cl, viewProj, prevFrameViewProj, dc.data);
		}
	}
}

void texturedSky(dx_command_list* cl,
	const dx_render_target& skyRenderTarget,
	const mat4& proj, const mat4& view, const mat4& prevFrameView,
	ref<dx_texture> sky,
	float skyIntensity,
	vec2 jitter, vec2 prevFrameJitter)
{
	PROFILE_ALL(cl, "Sky");

	cl->setRenderTarget(skyRenderTarget);
	cl->setViewport(skyRenderTarget.viewport);

	cl->setPipelineState(*textureSkyPipeline.pipeline);
	cl->setGraphicsRootSignature(*textureSkyPipeline.rootSignature);

	cl->setGraphics32BitConstants(SKY_RS_TRANSFORM, sky_transform_cb{ proj * createSkyViewMatrix(view), proj * createSkyViewMatrix(prevFrameView) });
	cl->setGraphics32BitConstants(SKY_RS_CB, sky_cb{ jitter, prevFrameJitter, skyIntensity });
	cl->setDescriptorHeapSRV(SKY_RS_TEX, 0, sky);

	cl->drawCubeTriangleStrip();
}

void proceduralSky(dx_command_list* cl,
	const dx_render_target& skyRenderTarget,
	const mat4& proj, const mat4& view, const mat4& prevFrameView,
	vec3 sunDirection, float skyIntensity,
	vec2 jitter, vec2 prevFrameJitter)
{
	PROFILE_ALL(cl, "Sky");

	cl->setRenderTarget(skyRenderTarget);
	cl->setViewport(skyRenderTarget.viewport);

	cl->setPipelineState(*proceduralSkyPipeline.pipeline);
	cl->setGraphicsRootSignature(*proceduralSkyPipeline.rootSignature);

	cl->setGraphics32BitConstants(SKY_RS_TRANSFORM, sky_transform_cb{ proj * createSkyViewMatrix(view), proj * createSkyViewMatrix(prevFrameView) });
	cl->setGraphics32BitConstants(SKY_RS_CB, sky_cb{ jitter, prevFrameJitter, skyIntensity, sunDirection });

	cl->drawCubeTriangleStrip();
}


static void renderShadow(dx_command_list* cl, const default_render_command_buffer<uint64>& pass, const mat4& viewProj, const common_render_data& common)
{
	pipeline_setup_func lastSetupFunc = 0;

	for (const auto& dc : pass)
	{
		if (dc.setup != lastSetupFunc)
		{
			dc.setup(cl, common);
			lastSetupFunc = dc.setup;
		}
		dc.render(cl, viewProj, dc.data);
	}
}

static void renderSunShadows(dx_command_list* cl, const sun_shadow_render_pass* pass, const common_render_data& common, bool dynamic)
{
	for (uint32 renderCascadeIndex = 0; renderCascadeIndex < pass->numCascades; ++renderCascadeIndex)
	{
		const sun_cascade_render_pass& cascade = pass->cascades[renderCascadeIndex];

		shadow_map_viewport vp = cascade.viewport;
		cl->setViewport(vp.x, vp.y, vp.size, vp.size);

		for (uint32 i = 0; i <= renderCascadeIndex; ++i)
		{
			renderShadow(cl, (!dynamic) ? pass->cascades[i].staticPass : pass->cascades[i].dynamicPass, cascade.viewProj, common);
		}
	}
}

static void renderSpotShadows(dx_command_list* cl, const spot_shadow_render_pass* pass, const common_render_data& common, bool dynamic)
{
	shadow_map_viewport vp = pass->viewport;
	cl->setViewport(vp.x, vp.y, vp.size, vp.size);

	renderShadow(cl, (!dynamic) ? pass->staticPass : pass->dynamicPass, pass->viewProjMatrix, common);
}

static void renderPointShadows(dx_command_list* cl, const point_shadow_render_pass* pass, const common_render_data& common, bool dynamic)
{
	for (uint32 v = 0; v < 2; ++v)
	{
		PROFILE_ALL(cl, (v == 0) ? "First hemisphere" : "Second hemisphere");

		shadow_map_viewport vp = (v == 0) ? pass->viewport0 : pass->viewport1;
		cl->setViewport(vp.x, vp.y, vp.size, vp.size);

		pipeline_setup_func lastSetupFunc = 0;

		for (const auto& dc : (!dynamic) ? pass->staticPass : pass->dynamicPass)
		{
			if (dc.setup != lastSetupFunc)
			{
				dc.setup(cl, common);
				lastSetupFunc = dc.setup;

				point_shadow_cb cb =
				{
					pass->lightPosition,
					pass->maxDistance,
					(v == 0) ? 1.f : -1.f
				};

				cl->setGraphics32BitConstants(POINT_SHADOW_RS_CB, cb);
			}
			dc.render(cl, mat4::identity, dc.data);
		}
	}
}

void shadowPasses(dx_command_list* cl,
	const sun_shadow_render_pass** sunShadowRenderPasses, uint32 numSunLightShadowRenderPasses,
	const spot_shadow_render_pass** spotLightShadowRenderPasses, uint32 numSpotLightShadowRenderPasses,
	const point_shadow_render_pass** pointLightShadowRenderPasses, uint32 numPointLightShadowRenderPasses,
	const common_render_data& common)
{
	if (numSunLightShadowRenderPasses || numSpotLightShadowRenderPasses || numPointLightShadowRenderPasses)
	{
		PROFILE_ALL(cl, "Shadow map pass");

		clear_rect clearRects[128];
		uint32 numClearRects = 0;

		shadow_map_viewport copiesFromStaticCache[128];
		uint32 numCopiesFromStaticCache = 0;

		shadow_map_viewport copiesToStaticCache[128];
		uint32 numCopiesToStaticCache = 0;

		{
			for (uint32 passIndex = 0; passIndex < numSunLightShadowRenderPasses; ++passIndex)
			{
				auto pass = sunShadowRenderPasses[passIndex];

				for (uint32 cascadeIndex = 0; cascadeIndex < pass->numCascades; ++cascadeIndex)
				{
					const sun_cascade_render_pass& cascade = pass->cascades[cascadeIndex];
					shadow_map_viewport vp = cascade.viewport;

					if (pass->copyFromStaticCache)
					{
						copiesFromStaticCache[numCopiesFromStaticCache++] = vp;
					}
					else
					{
						clearRects[numClearRects++] = { vp.x, vp.y, vp.size, vp.size };
						copiesToStaticCache[numCopiesToStaticCache++] = vp;
					}
				}
			}

			for (uint32 i = 0; i < numSpotLightShadowRenderPasses; ++i)
			{
				shadow_map_viewport vp = spotLightShadowRenderPasses[i]->viewport;
				if (spotLightShadowRenderPasses[i]->copyFromStaticCache)
				{
					copiesFromStaticCache[numCopiesFromStaticCache++] = vp;
				}
				else
				{
					clearRects[numClearRects++] = { vp.x, vp.y, vp.size, vp.size };
					copiesToStaticCache[numCopiesToStaticCache++] = vp;
				}
			}

			for (uint32 i = 0; i < numPointLightShadowRenderPasses; ++i)
			{
				for (uint32 j = 0; j < 2; ++j)
				{
					shadow_map_viewport vp = (j == 0) ? pointLightShadowRenderPasses[i]->viewport0 : pointLightShadowRenderPasses[i]->viewport1;
					bool copy = (j == 0) ? pointLightShadowRenderPasses[i]->copyFromStaticCache0 : pointLightShadowRenderPasses[i]->copyFromStaticCache1;

					if (copy)
					{
						copiesFromStaticCache[numCopiesFromStaticCache++] = vp;
					}
					else
					{
						clearRects[numClearRects++] = { vp.x, vp.y, vp.size, vp.size };
						copiesToStaticCache[numCopiesToStaticCache++] = vp;
					}
				}
			}
		}

		if (!enableStaticShadowMapCaching)
		{
			numCopiesToStaticCache = 0;
		}

		if (numCopiesFromStaticCache)
		{
			PROFILE_ALL(cl, "Copy from static shadow map cache");
			copyShadowMapParts(cl, render_resources::staticShadowMapCache, render_resources::shadowMap, copiesFromStaticCache, numCopiesFromStaticCache);
		}

		if (numClearRects)
		{
			cl->clearDepth(render_resources::shadowMap->defaultDSV, 1.f, clearRects, numClearRects);
		}

		if (numCopiesToStaticCache)
		{
			barrier_batcher(cl)
				.transitionBegin(render_resources::staticShadowMapCache, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_DEPTH_WRITE);
		}



		auto shadowRenderTarget = dx_render_target(SHADOW_MAP_WIDTH, SHADOW_MAP_HEIGHT)
			.depthAttachment(render_resources::shadowMap);

		cl->setRenderTarget(shadowRenderTarget);

		{
			PROFILE_ALL(cl, "Static geometry");

			for (uint32 passIndex = 0; passIndex < numSunLightShadowRenderPasses; ++passIndex)
			{
				renderSunShadows(cl, sunShadowRenderPasses[passIndex], common, false);
			}
			for (uint32 passIndex = 0; passIndex < numSpotLightShadowRenderPasses; ++passIndex)
			{
				renderSpotShadows(cl, spotLightShadowRenderPasses[passIndex], common, false);
			}
			for (uint32 passIndex = 0; passIndex < numPointLightShadowRenderPasses; ++passIndex)
			{
				renderPointShadows(cl, pointLightShadowRenderPasses[passIndex], common, false);
			}
		}

		if (numCopiesToStaticCache)
		{
			PROFILE_ALL(cl, "Copy to static shadow map cache");

			barrier_batcher(cl)
				.transition(render_resources::shadowMap, D3D12_RESOURCE_STATE_DEPTH_WRITE, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE)
				.transitionEnd(render_resources::staticShadowMapCache, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_DEPTH_WRITE);

			copyShadowMapParts(cl, render_resources::shadowMap, render_resources::staticShadowMapCache, copiesToStaticCache, numCopiesToStaticCache);

			barrier_batcher(cl)
				.transition(render_resources::shadowMap, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_DEPTH_WRITE)
				.transition(render_resources::staticShadowMapCache, D3D12_RESOURCE_STATE_DEPTH_WRITE, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE);
		}


		cl->setRenderTarget(shadowRenderTarget);

		{
			PROFILE_ALL(cl, "Dynamic geometry");

			for (uint32 passIndex = 0; passIndex < numSunLightShadowRenderPasses; ++passIndex)
			{
				renderSunShadows(cl, sunShadowRenderPasses[passIndex], common, true);
			}
			for (uint32 passIndex = 0; passIndex < numSpotLightShadowRenderPasses; ++passIndex)
			{
				renderSpotShadows(cl, spotLightShadowRenderPasses[passIndex], common, true);
			}
			for (uint32 passIndex = 0; passIndex < numPointLightShadowRenderPasses; ++passIndex)
			{
				renderPointShadows(cl, pointLightShadowRenderPasses[passIndex], common, true);
			}
		}
	}
}

void opaqueLightPass(dx_command_list* cl,
	const dx_render_target& renderTarget,
	const opaque_render_pass* opaqueRenderPass,
	const common_render_data& common,
	const mat4& viewProj)
{
	if (opaqueRenderPass && opaqueRenderPass->pass.size() > 0)
	{
		PROFILE_ALL(cl, "Main opaque light pass");

		cl->setRenderTarget(renderTarget);
		cl->setViewport(renderTarget.viewport);

		pipeline_setup_func lastSetupFunc = 0;

		for (const auto& dc : opaqueRenderPass->pass)
		{
			if (dc.setup != lastSetupFunc)
			{
				dc.setup(cl, common);
				lastSetupFunc = dc.setup;
			}
			dc.render(cl, viewProj, dc.data);
		}
	}
}

void transparentLightPass(dx_command_list* cl,
	const dx_render_target& renderTarget,
	const transparent_render_pass* transparentRenderPass,
	const common_render_data& common,
	const mat4& viewProj)
{
	if (transparentRenderPass && transparentRenderPass->pass.size() > 0)
	{
		PROFILE_ALL(cl, "Transparent light pass");

		cl->setRenderTarget(renderTarget);
		cl->setViewport(renderTarget.viewport);

		pipeline_setup_func lastSetupFunc = 0;

		for (const auto& dc : transparentRenderPass->pass)
		{
			if (dc.setup != lastSetupFunc)
			{
				dc.setup(cl, common);
				lastSetupFunc = dc.setup;
			}
			dc.render(cl, viewProj, dc.data);
		}
	}
}

void ldrPass(dx_command_list* cl,
	const dx_render_target& ldrRenderTarget,
	ref<dx_texture> depthStencilBuffer,
	const ldr_render_pass* ldrRenderPass,
	const common_render_data& common,
	const mat4& viewProj)
{
	if (ldrRenderPass)
	{
		PROFILE_ALL(cl, "LDR pass");

		cl->setRenderTarget(ldrRenderTarget);
		cl->setViewport(ldrRenderTarget.viewport);


		if (ldrRenderPass->ldrPass.size())
		{
			PROFILE_ALL(cl, "LDR Objects");

			pipeline_setup_func lastSetupFunc = 0;

			for (const auto& dc : ldrRenderPass->ldrPass)
			{
				if (dc.setup != lastSetupFunc)
				{
					dc.setup(cl, common);
					lastSetupFunc = dc.setup;
				}
				dc.render(cl, viewProj, dc.data);
			}
		}

		if (ldrRenderPass->overlays.size())
		{
			PROFILE_ALL(cl, "3D Overlays");

			cl->clearDepth(ldrRenderTarget.dsv);

			pipeline_setup_func lastSetupFunc = 0;

			for (const auto& dc : ldrRenderPass->overlays)
			{
				if (dc.setup != lastSetupFunc)
				{
					dc.setup(cl, common);
					lastSetupFunc = dc.setup;
				}
				dc.render(cl, viewProj, dc.data);
			}
		}

		if (ldrRenderPass->outlines.size())
		{
			PROFILE_ALL(cl, "Outlines");

			cl->setPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
			cl->setStencilReference(stencil_flag_selected_object);

			pipeline_setup_func lastSetupFunc = 0;

			for (const auto& dc : ldrRenderPass->outlines)
			{
				if (dc.setup != lastSetupFunc)
				{
					dc.setup(cl, common);
					lastSetupFunc = dc.setup;
				}
				dc.render(cl, viewProj, dc.data);
			}


			// Draw outline.
			cl->transitionBarrier(depthStencilBuffer, D3D12_RESOURCE_STATE_DEPTH_WRITE, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE | D3D12_RESOURCE_STATE_DEPTH_READ);

			cl->setPipelineState(*outlineDrawerPipeline.pipeline);
			cl->setGraphicsRootSignature(*outlineDrawerPipeline.rootSignature);

			cl->setGraphics32BitConstants(OUTLINE_RS_CB, outline_drawer_cb{ (int)depthStencilBuffer->width, (int)depthStencilBuffer->height });
			cl->setDescriptorHeapResource(OUTLINE_RS_STENCIL, 0, 1, depthStencilBuffer->stencilSRV);

			cl->drawFullscreenTriangle();

			cl->transitionBarrier(depthStencilBuffer, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE | D3D12_RESOURCE_STATE_DEPTH_READ, D3D12_RESOURCE_STATE_DEPTH_WRITE);
		}
	}
}

void copyShadowMapParts(dx_command_list* cl,
	ref<dx_texture> from,
	ref<dx_texture> to,
	shadow_map_viewport* copies, uint32 numCopies)
{
	// Since copies from or to parts of a depth-stencil texture are not allowed (even though they work on at least some hardware),
	// we copy to and from the static shadow map cache via a shader, and not via CopyTextureRegion.

	auto shadowRenderTarget = dx_render_target(to->width, to->height)
		.depthAttachment(to);

	cl->setRenderTarget(shadowRenderTarget);

	cl->setPipelineState(*shadowMapCopyPipeline.pipeline);
	cl->setGraphicsRootSignature(*shadowMapCopyPipeline.rootSignature);

	cl->setDescriptorHeapSRV(1, 0, from);

	for (uint32 i = 0; i < numCopies; ++i)
	{
		shadow_map_viewport vp = copies[i];
		cl->setGraphics32BitConstants(0, vec4((float)vp.x / SHADOW_MAP_WIDTH, (float)vp.y / SHADOW_MAP_HEIGHT, (float)vp.size / SHADOW_MAP_WIDTH, (float)vp.size / SHADOW_MAP_HEIGHT));
		cl->setViewport(vp.x, vp.y, vp.size, vp.size);
		cl->drawFullscreenTriangle();
	}
}


void lightAndDecalCulling(dx_command_list* cl,
	ref<dx_texture> depthStencilBuffer,
	ref<dx_buffer> pointLights,
	ref<dx_buffer> spotLights,
	ref<dx_buffer> decals,
	light_culling culling,
	uint32 numPointLights, uint32 numSpotLights, uint32 numDecals,
	dx_dynamic_constant_buffer cameraCBV)
{
	//if (numPointLights || numSpotLights || numDecals)
	{
		PROFILE_ALL(cl, "Cull lights & decals");

		// Tiled frusta.
		{
			PROFILE_ALL(cl, "Create world space frusta");

			cl->setPipelineState(*worldSpaceFrustaPipeline.pipeline);
			cl->setComputeRootSignature(*worldSpaceFrustaPipeline.rootSignature);
			cl->setComputeDynamicConstantBuffer(WORLD_SPACE_TILED_FRUSTA_RS_CAMERA, cameraCBV);
			cl->setCompute32BitConstants(WORLD_SPACE_TILED_FRUSTA_RS_CB, frusta_cb{ culling.numCullingTilesX, culling.numCullingTilesY });
			cl->setRootComputeUAV(WORLD_SPACE_TILED_FRUSTA_RS_FRUSTA_UAV, culling.tiledWorldSpaceFrustaBuffer);
			cl->dispatch(bucketize(culling.numCullingTilesX, 16), bucketize(culling.numCullingTilesY, 16));
		}

		barrier_batcher(cl)
			.uav(culling.tiledWorldSpaceFrustaBuffer);

		// Culling.
		{
			PROFILE_ALL(cl, "Sort objects into tiles");

			cl->setDescriptorHeap(dxContext.srvUavAllocator.type, dxContext.srvUavAllocatorShaderVisible.getHeap(0).Get());
			cl->clearUAV(culling.tiledCullingIndexCounter, 0u);
			cl->resetToDynamicDescriptorHeap();
			//cl->uavBarrier(tiledCullingIndexCounter);
			cl->setPipelineState(*lightCullingPipeline.pipeline);
			cl->setComputeRootSignature(*lightCullingPipeline.rootSignature);
			cl->setComputeDynamicConstantBuffer(LIGHT_CULLING_RS_CAMERA, cameraCBV);
			cl->setCompute32BitConstants(LIGHT_CULLING_RS_CB, light_culling_cb{ culling.numCullingTilesX, numPointLights, numSpotLights, numDecals });
			cl->setDescriptorHeapSRV(LIGHT_CULLING_RS_SRV_UAV, 0, depthStencilBuffer);
			cl->setDescriptorHeapSRV(LIGHT_CULLING_RS_SRV_UAV, 1, culling.tiledWorldSpaceFrustaBuffer);
			cl->setDescriptorHeapSRV(LIGHT_CULLING_RS_SRV_UAV, 2, pointLights ? pointLights->defaultSRV : render_resources::nullBufferSRV);
			cl->setDescriptorHeapSRV(LIGHT_CULLING_RS_SRV_UAV, 3, spotLights ? spotLights->defaultSRV : render_resources::nullBufferSRV);
			cl->setDescriptorHeapSRV(LIGHT_CULLING_RS_SRV_UAV, 4, decals ? decals->defaultSRV : render_resources::nullBufferSRV);
			cl->setDescriptorHeapUAV(LIGHT_CULLING_RS_SRV_UAV, 5, culling.tiledCullingGrid);
			cl->setDescriptorHeapUAV(LIGHT_CULLING_RS_SRV_UAV, 6, culling.tiledCullingIndexCounter);
			cl->setDescriptorHeapUAV(LIGHT_CULLING_RS_SRV_UAV, 7, culling.tiledObjectsIndexList);
			cl->dispatch(culling.numCullingTilesX, culling.numCullingTilesY);
		}

		barrier_batcher(cl)
			.uav(culling.tiledCullingGrid)
			.uav(culling.tiledObjectsIndexList);
	}
}

void linearDepthPyramid(dx_command_list* cl,
	ref<dx_texture> depthStencilBuffer,
	ref<dx_texture> linearDepthBuffer,
	vec4 projectionParams)
{
	PROFILE_ALL(cl, "Linear depth pyramid");

	cl->setPipelineState(*hierarchicalLinearDepthPipeline.pipeline);
	cl->setComputeRootSignature(*hierarchicalLinearDepthPipeline.rootSignature);

	float width = ceilf(depthStencilBuffer->width * 0.5f);
	float height = ceilf(depthStencilBuffer->height * 0.5f);

	cl->setCompute32BitConstants(HIERARCHICAL_LINEAR_DEPTH_RS_CB, hierarchical_linear_depth_cb{ projectionParams, vec2(1.f / width, 1.f / height) });
	cl->setDescriptorHeapUAV(HIERARCHICAL_LINEAR_DEPTH_RS_TEXTURES, 0, linearDepthBuffer->uavAt(0));
	cl->setDescriptorHeapUAV(HIERARCHICAL_LINEAR_DEPTH_RS_TEXTURES, 1, linearDepthBuffer->uavAt(1));
	cl->setDescriptorHeapUAV(HIERARCHICAL_LINEAR_DEPTH_RS_TEXTURES, 2, linearDepthBuffer->uavAt(2));
	cl->setDescriptorHeapUAV(HIERARCHICAL_LINEAR_DEPTH_RS_TEXTURES, 3, linearDepthBuffer->uavAt(3));
	cl->setDescriptorHeapUAV(HIERARCHICAL_LINEAR_DEPTH_RS_TEXTURES, 4, linearDepthBuffer->uavAt(4));
	cl->setDescriptorHeapUAV(HIERARCHICAL_LINEAR_DEPTH_RS_TEXTURES, 5, linearDepthBuffer->uavAt(5));
	cl->setDescriptorHeapSRV(HIERARCHICAL_LINEAR_DEPTH_RS_TEXTURES, 6, depthStencilBuffer);

	cl->dispatch(bucketize((uint32)width, POST_PROCESSING_BLOCK_SIZE), bucketize((uint32)height, POST_PROCESSING_BLOCK_SIZE));
}

void gaussianBlur(dx_command_list* cl,
	ref<dx_texture> inputOutput,
	ref<dx_texture> temp,
	uint32 inputMip, uint32 outputMip, gaussian_blur_kernel_size kernel, uint32 numIterations)
{
	PROFILE_ALL(cl, "Gaussian Blur");

	ASSERT(inputOutput->format == temp->format);

	uint32 numChannels = getNumberOfChannels(inputOutput->format);

	// Maybe we could add more specializations for 2 and 3 channels.
	dx_pipeline& pipeline = ((numChannels == 1) ? gaussianBlurFloatPipelines : gaussianBlurFloat4Pipelines)[kernel];

	cl->setPipelineState(*pipeline.pipeline);
	cl->setComputeRootSignature(*pipeline.rootSignature);

	uint32 outputWidth = max(1u, inputOutput->width >> outputMip);
	uint32 outputHeight = max(1u, inputOutput->height >> outputMip);

	uint32 widthBuckets = bucketize(outputWidth, POST_PROCESSING_BLOCK_SIZE);
	uint32 heightBuckets = bucketize(outputHeight, POST_PROCESSING_BLOCK_SIZE);

	ASSERT(inputMip <= outputMip); // Currently only downsampling supported.

	float scale = 1.f / (1 << (outputMip - inputMip));

	uint32 sourceMip = inputMip;
	gaussian_blur_cb cb = { vec2(1.f / outputWidth, 1.f / outputHeight), scale };

	for (uint32 i = 0; i < numIterations; ++i)
	{
		PROFILE_ALL(cl, "Iteration");

		{
			PROFILE_ALL(cl, "Vertical");

			dx_cpu_descriptor_handle tempUAV = temp->uavAt(outputMip);

			// Vertical pass.
			cb.directionAndSourceMipLevel = (1 << 16) | sourceMip;
			cl->setCompute32BitConstants(GAUSSIAN_BLUR_RS_CB, cb);
			cl->setDescriptorHeapUAV(GAUSSIAN_BLUR_RS_TEXTURES, 0, tempUAV);
			cl->setDescriptorHeapSRV(GAUSSIAN_BLUR_RS_TEXTURES, 1, inputOutput);

			cl->dispatch(widthBuckets, heightBuckets);

			barrier_batcher(cl)
				//.uav(temp)
				.transition(temp, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE)
				.transition(inputOutput, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);
		}

		cb.stepScale = 1.f;
		sourceMip = outputMip; // From here on we sample from the output mip.

		{
			PROFILE_ALL(cl, "Horizontal");

			dx_cpu_descriptor_handle outputUAV = inputOutput->uavAt(outputMip);

			// Horizontal pass.
			cb.directionAndSourceMipLevel = (0 << 16) | sourceMip;
			cl->setCompute32BitConstants(GAUSSIAN_BLUR_RS_CB, cb);
			cl->setDescriptorHeapUAV(GAUSSIAN_BLUR_RS_TEXTURES, 0, outputUAV);
			cl->setDescriptorHeapSRV(GAUSSIAN_BLUR_RS_TEXTURES, 1, temp);

			cl->dispatch(widthBuckets, heightBuckets);

			barrier_batcher(cl)
				//.uav(inputOutput)
				.transition(temp, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_UNORDERED_ACCESS)
				.transition(inputOutput, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE);
		}
	}
}

static void morphologyCommon(dx_command_list* cl, dx_pipeline& pipeline, ref<dx_texture> inputOutput, ref<dx_texture> temp, uint32 radius, uint32 numIterations)
{
	if (radius == 0 || numIterations == 0)
	{
		return;
	}

	ASSERT(inputOutput->width == temp->width);
	ASSERT(inputOutput->height == temp->height);

	radius = min(radius, (uint32)MORPHOLOGY_MAX_RADIUS);

	cl->setPipelineState(*pipeline.pipeline);
	cl->setComputeRootSignature(*pipeline.rootSignature);

	for (uint32 i = 0; i < numIterations; ++i)
	{
		DX_PROFILE_BLOCK(cl, "Iteration");

		{
			DX_PROFILE_BLOCK(cl, "Vertical");

			cl->setCompute32BitConstants(MORPHOLOGY_RS_CB, morphology_cb{ radius, 1, inputOutput->height });
			cl->setDescriptorHeapUAV(MORPHOLOGY_RS_TEXTURES, 0, temp);
			cl->setDescriptorHeapSRV(MORPHOLOGY_RS_TEXTURES, 1, inputOutput);

			cl->dispatch(bucketize(inputOutput->height, MORPHOLOGY_BLOCK_SIZE), inputOutput->width);

			barrier_batcher(cl)
				//.uav(temp)
				.transition(temp, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE)
				.transition(inputOutput, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);
		}

		{
			DX_PROFILE_BLOCK(cl, "Horizontal");

			cl->setCompute32BitConstants(MORPHOLOGY_RS_CB, morphology_cb{ radius, 0, inputOutput->width });
			cl->setDescriptorHeapUAV(MORPHOLOGY_RS_TEXTURES, 0, inputOutput);
			cl->setDescriptorHeapSRV(MORPHOLOGY_RS_TEXTURES, 1, temp);

			cl->dispatch(bucketize(inputOutput->width, MORPHOLOGY_BLOCK_SIZE), inputOutput->height);

			barrier_batcher(cl)
				//.uav(inputOutput)
				.transition(temp, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_UNORDERED_ACCESS)
				.transition(inputOutput, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE);
		}
	}
}

void dilate(dx_command_list* cl, ref<dx_texture> inputOutput, ref<dx_texture> temp, uint32 radius, uint32 numIterations)
{
	DX_PROFILE_BLOCK(cl, "Dilate");
	morphologyCommon(cl, dilationPipeline, inputOutput, temp, radius, numIterations);
}

void erode(dx_command_list* cl, ref<dx_texture> inputOutput, ref<dx_texture> temp, uint32 radius, uint32 numIterations)
{
	DX_PROFILE_BLOCK(cl, "Erode");
	morphologyCommon(cl, erosionPipeline, inputOutput, temp, radius, numIterations);
}

void depthSobel(dx_command_list* cl, ref<dx_texture> input, ref<dx_texture> output, vec4 projectionParams, float threshold)
{
	DX_PROFILE_BLOCK(cl, "Depth sobel");

	cl->setPipelineState(*depthSobelPipeline.pipeline);
	cl->setComputeRootSignature(*depthSobelPipeline.rootSignature);

	cl->setCompute32BitConstants(DEPTH_SOBEL_RS_CB, depth_sobel_cb{ projectionParams, threshold });
	cl->setDescriptorHeapUAV(DEPTH_SOBEL_RS_TEXTURES, 0, output);
	cl->setDescriptorHeapSRV(DEPTH_SOBEL_RS_TEXTURES, 1, input);

	cl->dispatch(bucketize(input->width, POST_PROCESSING_BLOCK_SIZE), bucketize(input->height, POST_PROCESSING_BLOCK_SIZE));
}


void ssrTemporal(dx_command_list* cl, 
	ref<dx_texture> screenVelocitiesTexture,
	ref<dx_texture> resolveTexture,
	ref<dx_texture> ssrTemporalHistory,
	ref<dx_texture> ssrTemporalOutput)
{
	uint32 resolveWidth = resolveTexture->width;
	uint32 resolveHeight = resolveTexture->height;

	{
		PROFILE_ALL(cl, "Temporal");

		cl->setPipelineState(*ssrTemporalPipeline.pipeline);
		cl->setComputeRootSignature(*ssrTemporalPipeline.rootSignature);

		cl->setCompute32BitConstants(SSR_TEMPORAL_RS_CB, ssr_temporal_cb{ vec2(1.f / resolveWidth, 1.f / resolveHeight) });

		cl->setDescriptorHeapUAV(SSR_TEMPORAL_RS_TEXTURES, 0, ssrTemporalOutput);
		cl->setDescriptorHeapSRV(SSR_TEMPORAL_RS_TEXTURES, 1, resolveTexture);
		cl->setDescriptorHeapSRV(SSR_TEMPORAL_RS_TEXTURES, 2, ssrTemporalHistory);
		cl->setDescriptorHeapSRV(SSR_TEMPORAL_RS_TEXTURES, 3, screenVelocitiesTexture);

		cl->dispatch(bucketize(resolveWidth, SSR_BLOCK_SIZE), bucketize(resolveHeight, SSR_BLOCK_SIZE));

		barrier_batcher(cl)
			//.uav(ssrOutput)
			.transition(ssrTemporalOutput, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE)
			.transition(ssrTemporalHistory, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_UNORDERED_ACCESS)
			.transition(resolveTexture, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);
	}

	{
		PROFILE_ALL(cl, "Median Blur");

		cl->setPipelineState(*ssrMedianBlurPipeline.pipeline);
		cl->setComputeRootSignature(*ssrMedianBlurPipeline.rootSignature);

		cl->setCompute32BitConstants(SSR_MEDIAN_BLUR_RS_CB, ssr_median_blur_cb{ vec2(1.f / resolveWidth, 1.f / resolveHeight) });

		cl->setDescriptorHeapUAV(SSR_MEDIAN_BLUR_RS_TEXTURES, 0, resolveTexture); // We reuse the resolve texture here.
		cl->setDescriptorHeapSRV(SSR_MEDIAN_BLUR_RS_TEXTURES, 1, ssrTemporalOutput);

		cl->dispatch(bucketize(resolveWidth, SSR_BLOCK_SIZE), bucketize(resolveHeight, SSR_BLOCK_SIZE));

		barrier_batcher(cl)
			//.uav(resolveTexture)
			.transition(resolveTexture, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_GENERIC_READ);
	}
}

void screenSpaceReflections(dx_command_list* cl,
	ref<dx_texture> prevFrameHDR,
	ref<dx_texture> depthStencilBuffer,
	ref<dx_texture> linearDepthBuffer,
	ref<dx_texture> worldNormalsRoughnessTexture,
	ref<dx_texture> screenVelocitiesTexture,
	ref<dx_texture> raycastTexture,
	ref<dx_texture> resolveTexture,
	ref<dx_texture> ssrTemporalHistory,
	ref<dx_texture> ssrTemporalOutput,
	ssr_settings settings,
	dx_dynamic_constant_buffer cameraCBV)
{
	PROFILE_ALL(cl, "Screen space reflections");

	uint32 raycastWidth = raycastTexture->width;
	uint32 raycastHeight = raycastTexture->height;

	uint32 resolveWidth = resolveTexture->width;
	uint32 resolveHeight = resolveTexture->height;

	{
		PROFILE_ALL(cl, "Raycast");

		cl->setPipelineState(*ssrRaycastPipeline.pipeline);
		cl->setComputeRootSignature(*ssrRaycastPipeline.rootSignature);

		ssr_raycast_cb raycastSettings;
		raycastSettings.numSteps = settings.numSteps;
		raycastSettings.maxDistance = settings.maxDistance;
		raycastSettings.strideCutoff = settings.strideCutoff;
		raycastSettings.minStride = settings.minStride;
		raycastSettings.maxStride = settings.maxStride;
		raycastSettings.dimensions = vec2((float)raycastWidth, (float)raycastHeight);
		raycastSettings.invDimensions = vec2(1.f / raycastWidth, 1.f / raycastHeight);
		raycastSettings.frameIndex = (uint32)dxContext.frameID;

		cl->setCompute32BitConstants(SSR_RAYCAST_RS_CB, raycastSettings);
		cl->setComputeDynamicConstantBuffer(SSR_RAYCAST_RS_CAMERA, cameraCBV);
		cl->setDescriptorHeapUAV(SSR_RAYCAST_RS_TEXTURES, 0, raycastTexture);
		cl->setDescriptorHeapSRV(SSR_RAYCAST_RS_TEXTURES, 1, depthStencilBuffer);
		cl->setDescriptorHeapSRV(SSR_RAYCAST_RS_TEXTURES, 2, linearDepthBuffer);
		cl->setDescriptorHeapSRV(SSR_RAYCAST_RS_TEXTURES, 3, worldNormalsRoughnessTexture);
		cl->setDescriptorHeapSRV(SSR_RAYCAST_RS_TEXTURES, 4, render_resources::noiseTexture);
		cl->setDescriptorHeapSRV(SSR_RAYCAST_RS_TEXTURES, 5, screenVelocitiesTexture);

		cl->dispatch(bucketize(raycastWidth, SSR_BLOCK_SIZE), bucketize(raycastHeight, SSR_BLOCK_SIZE));

		barrier_batcher(cl)
			//.uav(raycastTexture)
			.transition(raycastTexture, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE);
	}

	{
		PROFILE_ALL(cl, "Resolve");

		cl->setPipelineState(*ssrResolvePipeline.pipeline);
		cl->setComputeRootSignature(*ssrResolvePipeline.rootSignature);

		cl->setCompute32BitConstants(SSR_RESOLVE_RS_CB, ssr_resolve_cb{ vec2((float)resolveWidth, (float)resolveHeight), vec2(1.f / resolveWidth, 1.f / resolveHeight) });
		cl->setComputeDynamicConstantBuffer(SSR_RESOLVE_RS_CAMERA, cameraCBV);

		cl->setDescriptorHeapUAV(SSR_RESOLVE_RS_TEXTURES, 0, resolveTexture);
		cl->setDescriptorHeapSRV(SSR_RESOLVE_RS_TEXTURES, 1, depthStencilBuffer);
		cl->setDescriptorHeapSRV(SSR_RESOLVE_RS_TEXTURES, 2, worldNormalsRoughnessTexture);
		cl->setDescriptorHeapSRV(SSR_RESOLVE_RS_TEXTURES, 3, raycastTexture);
		cl->setDescriptorHeapSRV(SSR_RESOLVE_RS_TEXTURES, 4, prevFrameHDR);
		cl->setDescriptorHeapSRV(SSR_RESOLVE_RS_TEXTURES, 5, screenVelocitiesTexture);

		cl->dispatch(bucketize(resolveWidth, SSR_BLOCK_SIZE), bucketize(resolveHeight, SSR_BLOCK_SIZE));

		barrier_batcher(cl)
			//.uav(resolveTexture)
			.transition(resolveTexture, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE)
			.transition(raycastTexture, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);
	}

	ssrTemporal(cl, screenVelocitiesTexture, resolveTexture, ssrTemporalHistory, ssrTemporalOutput);
}

void specularAmbient(dx_command_list* cl,
	ref<dx_texture> hdrInput,
	ref<dx_texture> ssr,
	ref<dx_texture> worldNormalsTexture,
	ref<dx_texture> reflectanceTexture,
	ref<dx_texture> environment,
	ref<dx_texture> ao,
	ref<dx_texture> output,
	dx_dynamic_constant_buffer cameraCBV)
{
	PROFILE_ALL(cl, "Specular ambient");

	cl->setPipelineState(*specularAmbientPipeline.pipeline);
	cl->setComputeRootSignature(*specularAmbientPipeline.rootSignature);

	cl->setCompute32BitConstants(SPECULAR_AMBIENT_RS_CB, specular_ambient_cb{ vec2(1.f / output->width, 1.f / output->height) });
	cl->setComputeDynamicConstantBuffer(SPECULAR_AMBIENT_RS_CAMERA, cameraCBV);

	cl->setDescriptorHeapUAV(SPECULAR_AMBIENT_RS_TEXTURES, 0, output);
	cl->setDescriptorHeapSRV(SPECULAR_AMBIENT_RS_TEXTURES, 1, hdrInput);
	cl->setDescriptorHeapSRV(SPECULAR_AMBIENT_RS_TEXTURES, 2, worldNormalsTexture);
	cl->setDescriptorHeapSRV(SPECULAR_AMBIENT_RS_TEXTURES, 3, reflectanceTexture);
	cl->setDescriptorHeapSRV(SPECULAR_AMBIENT_RS_TEXTURES, 4, ssr ? ssr->defaultSRV : render_resources::nullTextureSRV);
	cl->setDescriptorHeapSRV(SPECULAR_AMBIENT_RS_TEXTURES, 5, environment ? environment : render_resources::blackCubeTexture);
	cl->setDescriptorHeapSRV(SPECULAR_AMBIENT_RS_TEXTURES, 6, render_resources::brdfTex);
	cl->setDescriptorHeapSRV(SPECULAR_AMBIENT_RS_TEXTURES, 7, ao ? ao : render_resources::whiteTexture);

	cl->dispatch(bucketize(output->width, POST_PROCESSING_BLOCK_SIZE), bucketize(output->height, POST_PROCESSING_BLOCK_SIZE));
}


void temporalAntiAliasing(dx_command_list* cl,
	ref<dx_texture> hdrInput,
	ref<dx_texture> screenVelocitiesTexture,
	ref<dx_texture> depthStencilBuffer,
	ref<dx_texture> history,
	ref<dx_texture> output,
	vec4 jitteredCameraProjectionParams)
{
	PROFILE_ALL(cl, "Temporal anti-aliasing");

	cl->setPipelineState(*taaPipeline.pipeline);
	cl->setComputeRootSignature(*taaPipeline.rootSignature);

	cl->setDescriptorHeapUAV(TAA_RS_TEXTURES, 0, output);
	cl->setDescriptorHeapSRV(TAA_RS_TEXTURES, 1, hdrInput);
	cl->setDescriptorHeapSRV(TAA_RS_TEXTURES, 2, history);
	cl->setDescriptorHeapSRV(TAA_RS_TEXTURES, 3, screenVelocitiesTexture);
	cl->setDescriptorHeapSRV(TAA_RS_TEXTURES, 4, depthStencilBuffer);

	uint32 renderWidth = depthStencilBuffer->width;
	uint32 renderHeight = depthStencilBuffer->height;
	cl->setCompute32BitConstants(TAA_RS_CB, taa_cb{ jitteredCameraProjectionParams, vec2((float)renderWidth, (float)renderHeight) });

	cl->dispatch(bucketize(renderWidth, POST_PROCESSING_BLOCK_SIZE), bucketize(renderHeight, POST_PROCESSING_BLOCK_SIZE));

	barrier_batcher(cl)
		//.uav(taaTextures[taaOutputIndex])
		.transition(output, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE) // Will be read by rest of post processing stack. Can stay in read state, since it is read as history next frame.
		.transition(history, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_UNORDERED_ACCESS); // Will be used as UAV next frame.
}

void downsample(dx_command_list* cl,
	ref<dx_texture> input,
	ref<dx_texture> output,
	ref<dx_texture> temp)
{
	PROFILE_ALL(cl, "Downsample");

	barrier_batcher(cl)
		.transition(output, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);

	blit(cl, input, output);

	barrier_batcher(cl)
		//.uav(prevFrameHDRColorTexture)
		.transition(output, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE);

	for (uint32 i = 0; i < output->numMipLevels - 1; ++i)
	{
		gaussianBlur(cl, output, temp, i, i + 1, gaussian_blur_5x5);
	}
}

void bloom(dx_command_list* cl,
	ref<dx_texture> hdrInput,
	ref<dx_texture> output,
	ref<dx_texture> bloomTexture,
	ref<dx_texture> bloomTempTexture,
	bloom_settings settings)
{
	PROFILE_ALL(cl, "Bloom");

	{
		PROFILE_ALL(cl, "Threshold");

		cl->setPipelineState(*bloomThresholdPipeline.pipeline);
		cl->setComputeRootSignature(*bloomThresholdPipeline.rootSignature);

		cl->setDescriptorHeapUAV(BLOOM_THRESHOLD_RS_TEXTURES, 0, bloomTexture);
		cl->setDescriptorHeapSRV(BLOOM_THRESHOLD_RS_TEXTURES, 1, hdrInput);

		cl->setCompute32BitConstants(BLOOM_THRESHOLD_RS_CB, bloom_threshold_cb{ vec2(1.f / bloomTexture->width, 1.f / bloomTexture->height), settings.threshold });

		cl->dispatch(bucketize(bloomTexture->width, POST_PROCESSING_BLOCK_SIZE), bucketize(bloomTexture->height, POST_PROCESSING_BLOCK_SIZE));
	}

	barrier_batcher(cl)
		.transition(bloomTexture, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE);

	for (uint32 i = 0; i < bloomTexture->numMipLevels - 1; ++i)
	{
		gaussianBlur(cl, bloomTexture, bloomTempTexture, i, i + 1, gaussian_blur_9x9);
	}

	{
		PROFILE_ALL(cl, "Combine");

		cl->setPipelineState(*bloomCombinePipeline.pipeline);
		cl->setComputeRootSignature(*bloomCombinePipeline.rootSignature);

		cl->setDescriptorHeapUAV(BLOOM_COMBINE_RS_TEXTURES, 0, output);
		cl->setDescriptorHeapSRV(BLOOM_COMBINE_RS_TEXTURES, 1, hdrInput);
		cl->setDescriptorHeapSRV(BLOOM_COMBINE_RS_TEXTURES, 2, bloomTexture);

		cl->setCompute32BitConstants(BLOOM_COMBINE_RS_CB, bloom_combine_cb{ vec2(1.f / hdrInput->width, 1.f / hdrInput->height), settings.strength });

		cl->dispatch(bucketize(hdrInput->width, POST_PROCESSING_BLOCK_SIZE), bucketize(hdrInput->height, POST_PROCESSING_BLOCK_SIZE));
	}

	barrier_batcher(cl)
		//.uav(bloomResult)
		.transition(output, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE) // Will be read by rest of post processing stack. 
		.transition(bloomTexture, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_UNORDERED_ACCESS); // For next frame.
}

static void bilateralBlurShadows(dx_command_list* cl,
	ref<dx_texture> input,
	ref<dx_texture> tempTexture,
	ref<dx_texture> linearDepth,
	ref<dx_texture> screenVelocitiesTexture,
	ref<dx_texture> history,
	ref<dx_texture> output)
{
	PROFILE_ALL(cl, "Bilateral blur");

	{
		PROFILE_ALL(cl, "Horizontal");

		shadow_blur_cb cb;
		cb.dimensions.x = (float)tempTexture->width;
		cb.dimensions.y = (float)tempTexture->height;
		cb.invDimensions.x = 1.f / cb.dimensions.x;
		cb.invDimensions.y = 1.f / cb.dimensions.y;

		cl->setPipelineState(*shadowBlurXPipeline.pipeline);
		cl->setComputeRootSignature(*shadowBlurXPipeline.rootSignature);

		cl->setDescriptorHeapUAV(SHADOW_BLUR_RS_TEXTURES, 0, tempTexture);
		cl->setDescriptorHeapSRV(SHADOW_BLUR_RS_TEXTURES, 1, input);
		cl->setDescriptorHeapSRV(SHADOW_BLUR_RS_TEXTURES, 2, linearDepth);

		cl->setCompute32BitConstants(SHADOW_BLUR_RS_CB, cb);

		cl->dispatch(bucketize(tempTexture->width, POST_PROCESSING_BLOCK_SIZE), bucketize(tempTexture->height, POST_PROCESSING_BLOCK_SIZE));

		barrier_batcher(cl)
			//.uav(tempTexture)
			.transition(tempTexture, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE)
			.transitionBegin(input, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);
	}

	{
		PROFILE_ALL(cl, "Vertical");

		shadow_blur_cb cb;
		cb.dimensions.x = (float)output->width;
		cb.dimensions.y = (float)output->height;
		cb.invDimensions.x = 1.f / cb.dimensions.x;
		cb.invDimensions.y = 1.f / cb.dimensions.y;

		cl->setPipelineState(*shadowBlurYPipeline.pipeline);
		cl->setComputeRootSignature(*shadowBlurYPipeline.rootSignature);

		cl->setDescriptorHeapUAV(SHADOW_BLUR_RS_TEXTURES, 0, output);
		cl->setDescriptorHeapSRV(SHADOW_BLUR_RS_TEXTURES, 1, tempTexture);
		cl->setDescriptorHeapSRV(SHADOW_BLUR_RS_TEXTURES, 2, linearDepth);
		cl->setDescriptorHeapSRV(SHADOW_BLUR_RS_TEXTURES, 3, screenVelocitiesTexture);
		cl->setDescriptorHeapSRV(SHADOW_BLUR_RS_TEXTURES, 4, history);

		cl->setCompute32BitConstants(SHADOW_BLUR_RS_CB, cb);

		cl->dispatch(bucketize(output->width, POST_PROCESSING_BLOCK_SIZE), bucketize(output->height, POST_PROCESSING_BLOCK_SIZE));

		barrier_batcher(cl)
			.uav(output)
			.transition(tempTexture, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_UNORDERED_ACCESS)
			.transitionEnd(input, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);
	}
}

void ambientOcclusion(dx_command_list* cl,
	ref<dx_texture> linearDepth,
	ref<dx_texture> screenVelocitiesTexture,
	ref<dx_texture> aoCalculationTexture,
	ref<dx_texture> aoBlurTempTexture,
	ref<dx_texture> history,
	ref<dx_texture> output,
	hbao_settings settings,
	dx_dynamic_constant_buffer cameraCBV)
{
	PROFILE_ALL(cl, "HBAO");

	{
		PROFILE_ALL(cl, "Calculate AO");

		hbao_cb cb;
		cb.screenWidth = aoCalculationTexture->width;
		cb.screenHeight = aoCalculationTexture->height;
		cb.depthBufferMipLevel = log2((float)linearDepth->width / aoCalculationTexture->width);
		cb.numRays = settings.numRays;
		cb.maxNumStepsPerRay = settings.maxNumStepsPerRay;
		cb.strength = settings.strength;
		cb.radius = settings.radius;
		cb.seed = (float)(dxContext.frameID & 0xFFFFFFFF);

		float alpha = M_TAU / settings.numRays;
		cb.rayDeltaRotation = vec2(cos(alpha), sin(alpha));

		cl->setPipelineState(*hbaoPipeline.pipeline);
		cl->setComputeRootSignature(*hbaoPipeline.rootSignature);

		cl->setDescriptorHeapUAV(HBAO_RS_TEXTURES, 0, aoCalculationTexture);
		cl->setDescriptorHeapSRV(HBAO_RS_TEXTURES, 1, linearDepth);

		cl->setCompute32BitConstants(HBAO_RS_CB, cb);
		cl->setComputeDynamicConstantBuffer(HBAO_RS_CAMERA, cameraCBV);

		cl->dispatch(bucketize(aoCalculationTexture->width, POST_PROCESSING_BLOCK_SIZE), bucketize(aoCalculationTexture->height, POST_PROCESSING_BLOCK_SIZE));

		barrier_batcher(cl)
			//.uav(aoCalculationTexture)
			.transition(aoCalculationTexture, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE);
	}

	bilateralBlurShadows(cl, aoCalculationTexture, aoBlurTempTexture, linearDepth, screenVelocitiesTexture, history, output);
}

void screenSpaceShadows(dx_command_list* cl, 
	ref<dx_texture> linearDepth, 
	ref<dx_texture> screenVelocitiesTexture, 
	ref<dx_texture> sssCalculationTexture, 
	ref<dx_texture> sssBlurTempTexture, 
	ref<dx_texture> history, 
	ref<dx_texture> output, 
	vec3 sunDirection, 
	sss_settings settings, 
	const mat4& view, 
	dx_dynamic_constant_buffer cameraCBV)
{
	PROFILE_ALL(cl, "Screen space shadows");

	{
		PROFILE_ALL(cl, "Calculate SSS");

		cl->setPipelineState(*sssPipeline.pipeline);
		cl->setComputeRootSignature(*sssPipeline.rootSignature);

		sss_cb cb;
		cb.invDimensions = vec2(1.f / (float)sssCalculationTexture->width, 1.f / (float)sssCalculationTexture->height);
		cb.lightDirection = -normalize(transformDirection(view, sunDirection));
		cb.rayDistance = settings.rayDistance;
		cb.numSteps = settings.numSteps;
		cb.thickness = settings.thickness;
		cb.maxDistanceFromCamera = settings.maxDistanceFromCamera;
		cb.distanceFadeoutRange = settings.distanceFadeoutRange;
		cb.invBorderFadeout = 1.f / settings.borderFadeout;
		cb.seed = (float)(dxContext.frameID & 0xFFFFFFFF);

		cl->setCompute32BitConstants(SSS_RS_CB, cb);
		cl->setComputeDynamicConstantBuffer(SSS_RS_CAMERA, cameraCBV);
		cl->setDescriptorHeapUAV(SSS_RS_TEXTURES, 0, sssCalculationTexture);
		cl->setDescriptorHeapSRV(SSS_RS_TEXTURES, 1, linearDepth);

		cl->dispatch(bucketize(sssCalculationTexture->width, POST_PROCESSING_BLOCK_SIZE), bucketize(sssCalculationTexture->height, POST_PROCESSING_BLOCK_SIZE));

		barrier_batcher(cl)
			//.uav(sssCalculationTexture)
			.transition(sssCalculationTexture, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE);
	}

	bilateralBlurShadows(cl, sssCalculationTexture, sssBlurTempTexture, linearDepth, screenVelocitiesTexture, history, output);
}

void tonemap(dx_command_list* cl,
	ref<dx_texture> hdrInput,
	ref<dx_texture> ldrOutput,
	const tonemap_settings& settings)
{
	PROFILE_ALL(cl, "Tonemapping");

	tonemap_cb cb;
	cb.A = settings.A;
	cb.B = settings.B;
	cb.C = settings.C;
	cb.D = settings.D;
	cb.E = settings.E;
	cb.F = settings.F;
	cb.invEvaluatedLinearWhite = 1.f / settings.evaluate(settings.linearWhite);
	cb.expExposure = exp2(settings.exposure);

	cl->setPipelineState(*tonemapPipeline.pipeline);
	cl->setComputeRootSignature(*tonemapPipeline.rootSignature);

	cl->setDescriptorHeapUAV(TONEMAP_RS_TEXTURES, 0, ldrOutput);
	cl->setDescriptorHeapSRV(TONEMAP_RS_TEXTURES, 1, hdrInput);
	cl->setCompute32BitConstants(TONEMAP_RS_CB, cb);

	cl->dispatch(bucketize(ldrOutput->width, POST_PROCESSING_BLOCK_SIZE), bucketize(ldrOutput->height, POST_PROCESSING_BLOCK_SIZE));
}

void blit(dx_command_list* cl, ref<dx_texture> input, ref<dx_texture> output)
{
	DX_PROFILE_BLOCK(cl, "Blit");

	cl->setPipelineState(*blitPipeline.pipeline);
	cl->setComputeRootSignature(*blitPipeline.rootSignature);

	cl->setCompute32BitConstants(BLIT_RS_CB, blit_cb{ vec2(1.f / output->width, 1.f / output->height) });
	cl->setDescriptorHeapUAV(BLIT_RS_TEXTURES, 0, output);
	cl->setDescriptorHeapSRV(BLIT_RS_TEXTURES, 1, input);

	cl->dispatch(bucketize(output->width, POST_PROCESSING_BLOCK_SIZE), bucketize(output->height, POST_PROCESSING_BLOCK_SIZE));
}

void present(dx_command_list* cl,
	ref<dx_texture> ldrInput,
	ref<dx_texture> output,
	sharpen_settings sharpenSettings)
{
	PROFILE_ALL(cl, "Present");

	uint32 xOffset = (output->width - ldrInput->width) / 2;
	uint32 yOffset = (output->height - ldrInput->height) / 2;

	cl->setPipelineState(*presentPipeline.pipeline);
	cl->setComputeRootSignature(*presentPipeline.rootSignature);

	cl->setDescriptorHeapUAV(PRESENT_RS_TEXTURES, 0, output);
	cl->setDescriptorHeapSRV(PRESENT_RS_TEXTURES, 1, ldrInput);
	cl->setCompute32BitConstants(PRESENT_RS_CB, present_cb{ present_sdr, 0.f, sharpenSettings.strength, (xOffset << 16) | yOffset });

	cl->dispatch(bucketize(output->width, POST_PROCESSING_BLOCK_SIZE), bucketize(output->height, POST_PROCESSING_BLOCK_SIZE));
}

void visualizeSunShadowCascades(dx_command_list* cl, 
	ref<dx_texture> depthBuffer, 
	ref<dx_texture> output, 
	dx_dynamic_constant_buffer sunCBV, 
	const mat4& invViewProj, 
	vec3 cameraPosition, 
	vec3 cameraForward)
{
	PROFILE_ALL(cl, "Visualize sun shadow cascades");

	cl->setPipelineState(*visualizeSunShadowCascadesPipeline.pipeline);
	cl->setComputeRootSignature(*visualizeSunShadowCascadesPipeline.rootSignature);

	visualize_sun_shadow_cascades_cb cb;
	cb.invViewProj = invViewProj;
	cb.cameraPosition = vec4(cameraPosition, 1.f);
	cb.cameraForward = vec4(cameraForward, 0.f);

	cl->setDescriptorHeapUAV(VISUALIZE_SUN_SHADOW_CASCADES_RS_TEXTURES, 0, output);
	cl->setDescriptorHeapSRV(VISUALIZE_SUN_SHADOW_CASCADES_RS_TEXTURES, 1, depthBuffer);
	cl->setComputeDynamicConstantBuffer(VISUALIZE_SUN_SHADOW_CASCADES_RS_SUN, sunCBV);
	cl->setCompute32BitConstants(VISUALIZE_SUN_SHADOW_CASCADES_RS_CB, cb);

	cl->dispatch(bucketize(output->width, 16), bucketize(output->height, 16));
}

void light_culling::allocateIfNecessary(uint32 renderWidth, uint32 renderHeight)
{
	uint32 oldNumCullingTilesX = numCullingTilesX;
	uint32 oldNumCullingTilesY = numCullingTilesY;

	numCullingTilesX = bucketize(renderWidth, LIGHT_CULLING_TILE_SIZE);
	numCullingTilesY = bucketize(renderHeight, LIGHT_CULLING_TILE_SIZE);

	bool firstAllocation = tiledCullingGrid == nullptr;

	if (firstAllocation)
	{
		tiledCullingGrid = createTexture(0, numCullingTilesX, numCullingTilesY,
			DXGI_FORMAT_R32G32B32A32_UINT, false, false, true);

		tiledCullingIndexCounter = createBuffer(sizeof(uint32), 1, 0, true, true);
		tiledObjectsIndexList = createBuffer(sizeof(uint32),
			numCullingTilesX * numCullingTilesY * MAX_NUM_INDICES_PER_TILE * 2, 0, true);
		tiledWorldSpaceFrustaBuffer = createBuffer(sizeof(light_culling_view_frustum), numCullingTilesX * numCullingTilesY, 0, true);

		SET_NAME(tiledCullingGrid->resource, "Tiled culling grid");
		SET_NAME(tiledCullingIndexCounter->resource, "Tiled index counter");
		SET_NAME(tiledObjectsIndexList->resource, "Tiled index list");
		SET_NAME(tiledWorldSpaceFrustaBuffer->resource, "Tiled frusta");
	}
	else if (numCullingTilesX != oldNumCullingTilesX || numCullingTilesY != oldNumCullingTilesY)
	{
		resizeTexture(tiledCullingGrid, numCullingTilesX, numCullingTilesY);
		resizeBuffer(tiledObjectsIndexList, numCullingTilesX * numCullingTilesY * MAX_NUM_INDICES_PER_TILE * 2);
		resizeBuffer(tiledWorldSpaceFrustaBuffer, numCullingTilesX * numCullingTilesY);
	}
}

```

`src/rendering/render_algorithms.h`:

```h
#pragma once

#include "dx/dx_command_list.h"
#include "dx/dx_texture.h"
#include "dx/dx_render_target.h"
#include "shadow_map_cache.h"
#include "render_pass.h"
#include "material.h"
#include "light_source.h"
#include "core/reflect.h"

#define MAX_NUM_TOTAL_DECALS 256   // Total per frame (not per tile). MUST MATCH light_culling_rs.hlsli

enum gaussian_blur_kernel_size
{
	gaussian_blur_5x5,
	gaussian_blur_9x9,
	gaussian_blur_13x13,

	gaussian_blur_kernel_size_count,
};

struct ssr_settings
{
	uint32 numSteps = 400;
	float maxDistance = 1000.f;
	float strideCutoff = 100.f;
	float minStride = 5.f;
	float maxStride = 30.f;
};
REFLECT_STRUCT(ssr_settings,
	(numSteps, "Num steps"),
	(maxDistance, "Max distance"),
	(strideCutoff, "Stride cutoff"),
	(minStride, "Min stride"),
	(maxStride, "Max stride")
);

struct taa_settings
{
	float cameraJitterStrength = 1.f;
};
REFLECT_STRUCT(taa_settings,
	(cameraJitterStrength, "Camera jitter strength")
);

struct bloom_settings
{
	float threshold = 100.f;
	float strength = 0.05f;
};
REFLECT_STRUCT(bloom_settings,
	(threshold, "Threshold"),
	(strength, "Strength")
);

struct hbao_settings
{
	float radius = 0.5f; // In meters.
	uint32 numRays = 4;
	uint32 maxNumStepsPerRay = 10;
	float strength = 1.f;
};
REFLECT_STRUCT(hbao_settings,
	(radius, "Threshold"),
	(numRays, "Num rays"),
	(maxNumStepsPerRay, "Max num steps per ray"),
	(strength, "Strength")
);

struct sharpen_settings
{
	float strength = 0.5f;
};
REFLECT_STRUCT(sharpen_settings,
	(strength, "Strength")
);

struct sss_settings
{
	uint32 numSteps = 16;
    float rayDistance = 0.5f; // In meters.
    float thickness = 0.05f; // In meters.
	float maxDistanceFromCamera = 15.f; // In meters.
	float distanceFadeoutRange = 2.f; // In meters.
	float borderFadeout = 0.1f; // In UV-space.
};
REFLECT_STRUCT(sss_settings,
	(numSteps, "Num steps"),
	(rayDistance, "Ray distance"),
	(thickness, "Thickness"),
	(maxDistanceFromCamera, "Max distance from camera"),
	(distanceFadeoutRange, "Distance fadeout range"),
	(borderFadeout, "Border fadeout")
);

struct tonemap_settings
{
	float A = 0.22f; // Shoulder strength.
	float B = 0.3f; // Linear strength.
	float C = 0.1f; // Linear angle.
	float D = 0.2f; // Toe strength.
	float E = 0.01f; // Toe Numerator.
	float F = 0.3f; // Toe denominator.
	// Note E/F = Toe angle.
	float linearWhite = 11.2f;

	float exposure = 0.2f;

	float tonemap(float color) const
	{
		color *= exp2(exposure);
		return evaluate(color) / evaluate(linearWhite);
	}

	float evaluate(float x) const
	{
		return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - (E / F);
	}
};
REFLECT_STRUCT(tonemap_settings,
	(A),
	(B),
	(C),
	(D),
	(E),
	(F),
	(linearWhite, "Linear white"),
	(exposure, "Exposure")
);

struct light_culling
{
	ref<dx_buffer> tiledWorldSpaceFrustaBuffer;

	ref<dx_buffer> tiledCullingIndexCounter;
	ref<dx_buffer> tiledObjectsIndexList;

	// DXGI_FORMAT_R32G32B32A32_UINT. 
	// The R&B channel contains the offset into tiledObjectsIndexList. 
	// The G&A channel contains the number of point lights and spot lights in 10 bit each, so there is space for more info.
	// Opaque is in R,G.
	// Transparent is in B,A.
	// For more info, see light_culling_cs.hlsl.
	ref<dx_texture> tiledCullingGrid;

	uint32 numCullingTilesX;
	uint32 numCullingTilesY;

	void allocateIfNecessary(uint32 renderWidth, uint32 renderHeight);
};



enum stencil_flags
{
	stencil_flag_selected_object = (1 << 0),
};



void depthPrePass(dx_command_list* cl,
	const dx_render_target& depthOnlyRenderTarget,
	const opaque_render_pass* opaqueRenderPass,
	const mat4& viewProj, const mat4& prevFrameViewProj,
	const common_render_data& common);

void texturedSky(dx_command_list* cl,
	const dx_render_target& skyRenderTarget,
	const mat4& proj, const mat4& view, const mat4& prevFrameView,
	ref<dx_texture> sky,
	float skyIntensity, 
	vec2 jitter, vec2 prevFrameJitter);

void proceduralSky(dx_command_list* cl,
	const dx_render_target& skyRenderTarget,
	const mat4& proj, const mat4& view, const mat4& prevFrameView,
	vec3 sunDirection, float skyIntensity,
	vec2 jitter, vec2 prevFrameJitter);

void shadowPasses(dx_command_list* cl,
	const sun_shadow_render_pass** sunShadowRenderPasses, uint32 numSunLightShadowRenderPasses,
	const spot_shadow_render_pass** spotLightShadowRenderPasses, uint32 numSpotLightShadowRenderPasses,
	const point_shadow_render_pass** pointLightShadowRenderPasses, uint32 numPointLightShadowRenderPasses,
	const common_render_data& common);

void opaqueLightPass(dx_command_list* cl,
	const dx_render_target& renderTarget,
	const opaque_render_pass* opaqueRenderPass,
	const common_render_data& common,
	const mat4& viewProj);

void transparentLightPass(dx_command_list* cl,
	const dx_render_target& renderTarget,
	const transparent_render_pass* transparentRenderPass,
	const common_render_data& common,
	const mat4& viewProj);

void ldrPass(dx_command_list* cl,
	const dx_render_target& ldrRenderTarget,
	ref<dx_texture> depthStencilBuffer,			// DEPTH_WRITE. Must be same as DSV bound to render-target.
	const ldr_render_pass* ldrRenderPass,
	const common_render_data& common,
	const mat4& viewProj);

void copyShadowMapParts(dx_command_list* cl,
	ref<dx_texture> from,						// PIXEL_SHADER_RESOURCE
	ref<dx_texture> to,							// DEPTH_WRITE
	shadow_map_viewport* copies, uint32 numCopies);





void lightAndDecalCulling(dx_command_list* cl,
	ref<dx_texture> depthStencilBuffer,				// NON_PIXEL_SHADER_RESOURCE
	ref<dx_buffer> pointLights,
	ref<dx_buffer> spotLights,
	ref<dx_buffer> decals,
	light_culling culling,
	uint32 numPointLights, uint32 numSpotLights, uint32 numDecals,
	dx_dynamic_constant_buffer cameraCBV);

void linearDepthPyramid(dx_command_list* cl,
	ref<dx_texture> depthStencilBuffer,				// NON_PIXEL_SHADER_RESOURCE
	ref<dx_texture> linearDepthBuffer,				// UNORDERED_ACCESS
	vec4 projectionParams);

void gaussianBlur(dx_command_list* cl,
	ref<dx_texture> inputOutput,					// NON_PIXEL_SHADER_RESOURCE
	ref<dx_texture> temp,							// UNORDERED_ACCESS
	uint32 inputMip, uint32 outputMip, gaussian_blur_kernel_size kernel, uint32 numIterations = 1);

void dilate(dx_command_list* cl,
	ref<dx_texture> inputOutput,					// NON_PIXEL_SHADER_RESOURCE
	ref<dx_texture> temp,							// UNORDERED_ACCESS
	uint32 radius, uint32 numIterations = 1);

void erode(dx_command_list* cl,
	ref<dx_texture> inputOutput,					// NON_PIXEL_SHADER_RESOURCE
	ref<dx_texture> temp,							// UNORDERED_ACCESS
	uint32 radius, uint32 numIterations = 1);

void depthSobel(dx_command_list* cl,
	ref<dx_texture> input,							// NON_PIXEL_SHADER_RESOURCE
	ref<dx_texture> output,							// UNORDERED_ACCESS
	vec4 projectionParams, float threshold);

void screenSpaceReflections(dx_command_list* cl,
	ref<dx_texture> prevFrameHDR,					// NON_PIXEL_SHADER_RESOURCE
	ref<dx_texture> depthStencilBuffer,				// NON_PIXEL_SHADER_RESOURCE
	ref<dx_texture> linearDepthBuffer,				// NON_PIXEL_SHADER_RESOURCE
	ref<dx_texture> worldNormalsRoughnessTexture,	// NON_PIXEL_SHADER_RESOURCE
	ref<dx_texture> screenVelocitiesTexture,		// NON_PIXEL_SHADER_RESOURCE
	ref<dx_texture> raycastTexture,					// UNORDERED_ACCESS
	ref<dx_texture> resolveTexture,					// UNORDERED_ACCESS. After call D3D12_RESOURCE_STATE_GENERIC_READ. Also output of this algorithm.
	ref<dx_texture> ssrTemporalHistory,				// NON_PIXEL_SHADER_RESOURCE. After call UNORDERED_ACCESS.
	ref<dx_texture> ssrTemporalOutput,				// UNORDERED_ACCESS. After call NON_PIXEL_SHADER_RESOURCE.
	ssr_settings settings,
	dx_dynamic_constant_buffer cameraCBV);

void specularAmbient(dx_command_list* cl,
	ref<dx_texture> hdrInput,						// NON_PIXEL_SHADER_RESOURCE
	ref<dx_texture> ssr,							// NON_PIXEL_SHADER_RESOURCE. Can be null.
	ref<dx_texture> worldNormalsTexture,			// NON_PIXEL_SHADER_RESOURCE
	ref<dx_texture> reflectanceTexture,				// NON_PIXEL_SHADER_RESOURCE
	ref<dx_texture> environment,					// NON_PIXEL_SHADER_RESOURCE. Can be null.
	ref<dx_texture> ao,								// NON_PIXEL_SHADER_RESOURCE. Can be null.
	ref<dx_texture> output,							// UNORDERED_ACCESS
	dx_dynamic_constant_buffer cameraCBV);

void temporalAntiAliasing(dx_command_list* cl,
	ref<dx_texture> hdrInput,						// NON_PIXEL_SHADER_RESOURCE
	ref<dx_texture> screenVelocitiesTexture,		// NON_PIXEL_SHADER_RESOURCE
	ref<dx_texture> depthStencilBuffer,				// NON_PIXEL_SHADER_RESOURCE
	ref<dx_texture> history,						// NON_PIXEL_SHADER_RESOURCE. After call UNORDERED_ACCESS.
	ref<dx_texture> output,							// UNORDERED_ACCESS. After call NON_PIXEL_SHADER_RESOURCE.
	vec4 jitteredCameraProjectionParams);

void downsample(dx_command_list* cl,
	ref<dx_texture> input,							// NON_PIXEL_SHADER_RESOURCE
	ref<dx_texture> output,							// NON_PIXEL_SHADER_RESOURCE
	ref<dx_texture> temp);							// UNORDERED_ACCESS

void bloom(dx_command_list* cl,
	ref<dx_texture> hdrInput,						// NON_PIXEL_SHADER_RESOURCE
	ref<dx_texture> output,							// Input as UNORDERED_ACCESS. After call NON_PIXEL_SHADER_RESOURCE.
	ref<dx_texture> bloomTexture,					// UNORDERED_ACCESS
	ref<dx_texture> bloomTempTexture,				// UNORDERED_ACCESS
	bloom_settings settings);

void ambientOcclusion(dx_command_list* cl,
	ref<dx_texture> linearDepth,					// NON_PIXEL_SHADER_RESOURCE
	ref<dx_texture> screenVelocitiesTexture,		// NON_PIXEL_SHADER_RESOURCE
	ref<dx_texture> aoCalculationTexture,			// UNORDERED_ACCESS
	ref<dx_texture> aoBlurTempTexture,				// UNORDERED_ACCESS
	ref<dx_texture> history,						// NON_PIXEL_SHADER_RESOURCE
	ref<dx_texture> output,							// UNORDERED_ACCESS
	hbao_settings settings,
	dx_dynamic_constant_buffer cameraCBV);

void screenSpaceShadows(dx_command_list* cl,
	ref<dx_texture> linearDepth,					// NON_PIXEL_SHADER_RESOURCE
	ref<dx_texture> screenVelocitiesTexture,		// NON_PIXEL_SHADER_RESOURCE
	ref<dx_texture> sssCalculationTexture,			// UNORDERED_ACCESS
	ref<dx_texture> sssBlurTempTexture,				// UNORDERED_ACCESS
	ref<dx_texture> history,						// NON_PIXEL_SHADER_RESOURCE
	ref<dx_texture> output,							// UNORDERED_ACCESS
	vec3 sunDirection,
	sss_settings settings,
	const mat4& view,
	dx_dynamic_constant_buffer cameraCBV);

void tonemap(dx_command_list* cl,
	ref<dx_texture> hdrInput,						// NON_PIXEL_SHADER_RESOURCE
	ref<dx_texture> ldrOutput,						// UNORDERED_ACCESS
	const tonemap_settings& settings);

void blit(dx_command_list* cl,
	ref<dx_texture> input,							// NON_PIXEL_SHADER_RESOURCE
	ref<dx_texture> output);						// UNORDERED_ACCESS

void present(dx_command_list* cl,
	ref<dx_texture> ldrInput,						// NON_PIXEL_SHADER_RESOURCE
	ref<dx_texture> output,							// UNORDERED_ACCESS
	sharpen_settings sharpenSettings);

void visualizeSunShadowCascades(dx_command_list* cl,
	ref<dx_texture> depthBuffer,					// NON_PIXEL_SHADER_RESOURCE
	ref<dx_texture> output,							// UNORDERED_ACCESS
	dx_dynamic_constant_buffer sunCBV,
	const mat4& invViewProj, vec3 cameraPosition, vec3 cameraForward);

```

`src/rendering/render_command.h`:

```h
#pragma once

#include "geometry/mesh.h"
#include "shadow_map_cache.h"

struct particle_draw_info
{
	ref<dx_buffer> particleBuffer;
	ref<dx_buffer> aliveList;
	ref<dx_buffer> commandBuffer;
	uint32 aliveListOffset;
	uint32 commandBufferOffset;
	uint32 rootParameterOffset;
};

template <typename render_data_t>
struct particle_render_command
{
	dx_vertex_buffer_group_view vertexBuffer;
	dx_index_buffer_view indexBuffer;
	particle_draw_info drawInfo;

	render_data_t data;
};





```

`src/rendering/render_command_buffer.h`:

```h
#pragma once

#include "core/memory.h"
#include "material.h"

struct dx_command_list;
struct common_render_data;

template <typename key_t, typename command_header>
struct render_command_buffer
{
private:
	struct command_key
	{
		key_t key;
		void* data;
	};

	struct command_wrapper_base
	{
		command_header header;

		virtual ~command_wrapper_base() {}
	};

	std::vector<command_key> keys;
	memory_arena arena;

	template <typename pipeline_t, typename command_t>
	command_t& pushInternal(key_t sortKey)
	{
		struct command_wrapper : command_wrapper_base
		{
			command_t command;
		};

		command_wrapper* commandWrapper = arena.allocate<command_wrapper>();
		new (commandWrapper) command_wrapper;

		commandWrapper->header.initialize<pipeline_t, command_wrapper>();

		command_key key;
		key.key = sortKey;
		key.data = commandWrapper;

		keys.push_back(key);
		return commandWrapper->command;
	}

public:
	render_command_buffer()
	{
		arena.initialize(0, GB(4));
		keys.reserve(128);
	}

	uint64 size() const { return keys.size(); }
	void sort() { std::sort(keys.begin(), keys.end(), [](command_key a, command_key b) { return a.key < b.key; }); }

	template <typename pipeline_t, typename command_t, typename... args_t>
	command_t& emplace_back(key_t sortKey, args_t&&... args)
	{
		command_t& command = pushInternal<pipeline_t, command_t>(sortKey);
		new (&command) command_t(std::forward<args_t>(args)...);
		return command;
	}

	template <typename pipeline_t, typename command_t>
	void push_back(key_t sortKey, const command_t& commandToPush)
	{
		command_t& command = pushInternal<pipeline_t, command_t>(sortKey);
		new (&command) command_t(commandToPush);
	}

	template <typename pipeline_t, typename command_t>
	void push_back(key_t sortKey, command_t&& commandToPush)
	{
		command_t& command = pushInternal<pipeline_t, command_t>(sortKey);
		new (&command) command_t(std::move(commandToPush));
	}

	void clear()
	{
		for (auto& key : keys)
		{
			command_wrapper_base* wrapperBase = (command_wrapper_base*)key.data;
			wrapperBase->~command_wrapper_base();
		}

		arena.reset();
		keys.clear();
	}

	struct iterator_return : command_header
	{
		void* data;
	};

	struct iterator
	{
		typename std::vector<command_key>::const_iterator keyIterator;

		friend bool operator==(const iterator& a, const iterator& b) { return a.keyIterator == b.keyIterator; }
		friend bool operator!=(const iterator& a, const iterator& b) { return !(a == b); }
		iterator& operator++() { ++keyIterator; return *this; }

		iterator_return operator*() 
		{ 
			command_wrapper_base* wrapperBase = (command_wrapper_base*)keyIterator->data;
			void* data = keyIterator->data;
			return iterator_return{ wrapperBase->header, data };
		}
	};

	iterator begin() { return iterator{ keys.begin() }; }
	iterator end() { return iterator{ keys.end() }; }

	iterator begin() const { return iterator{ keys.begin() }; }
	iterator end() const { return iterator{ keys.end() }; }

};



struct default_command_header
{
	typedef void (*generic_pipeline_render_func)(dx_command_list*, const mat4&, void*);

	pipeline_setup_func setup;
	generic_pipeline_render_func render;

	template <typename pipeline_t, typename command_wrapper>
	void initialize()
	{
		setup = pipeline_t::setup;
		render = [](dx_command_list* cl, const mat4& viewProj, void* data)
		{
			command_wrapper* wrapper = (command_wrapper*)data;
			pipeline_t::render(cl, viewProj, wrapper->command);
		};
	}
};

template <typename key_t>
struct default_render_command_buffer : render_command_buffer<key_t, default_command_header> {};





struct depth_prepass_command_header
{
	typedef void (*generic_pipeline_render_func)(dx_command_list*, const mat4&, const mat4&, void*);

	pipeline_setup_func setup;
	generic_pipeline_render_func render;

	template <typename pipeline_t, typename command_wrapper>
	void initialize()
	{
		setup = pipeline_t::setup;
		render = [](dx_command_list* cl, const mat4& viewProj, const mat4& prevFrameViewProj, void* data)
		{
			command_wrapper* wrapper = (command_wrapper*)data;
			pipeline_t::render(cl, viewProj, prevFrameViewProj, wrapper->command);
		};
	}
};

template <typename key_t>
struct depth_prepass_render_command_buffer : render_command_buffer<key_t, depth_prepass_command_header> {};





struct compute_command_header
{
	typedef void (*generic_compute_func)(dx_command_list*, void*);

	generic_compute_func compute;

	template <typename pipeline_t, typename command_wrapper>
	void initialize()
	{
		compute = [](dx_command_list* cl, void* data)
		{
			command_wrapper* wrapper = (command_wrapper*)data;
			pipeline_t::compute(cl, wrapper->command);
		};
	}
};

template <typename key_t>
struct compute_command_buffer : render_command_buffer<key_t, compute_command_header> {};



```

`src/rendering/render_pass.h`:

```h
#pragma once

#include "core/math.h"
#include "core/cpu_profiling.h"
#include "material.h"
#include "render_command.h"
#include "render_command_buffer.h"
#include "depth_prepass.h"


struct opaque_render_pass
{
	void sort()
	{
		CPU_PROFILE_BLOCK("Sort opaque render passes");

		pass.sort();
		depthPrepass.sort();
	}

	void reset()
	{
		pass.clear();
		depthPrepass.clear();
	}



	template <typename pipeline_t, typename render_data_t>
	void renderObject(const render_data_t& renderData)
	{
		uint64 sortKey = (uint64)pipeline_t::setup;
		pass.emplace_back<pipeline_t, render_data_t>(sortKey, renderData);
	}

	template <typename pipeline_t, typename render_data_t,
		class = typename std::enable_if_t<!std::is_lvalue_reference_v<render_data_t>>>
		void renderObject(render_data_t&& renderData)
	{
		uint64 sortKey = (uint64)pipeline_t::setup;
		pass.emplace_back<pipeline_t, render_data_t>(sortKey, std::move(renderData));
	}


	template <typename pipeline_t, typename render_data_t>
	void renderDepthOnly(const render_data_t& renderData)
	{
		uint64 sortKey = (uint64)pipeline_t::setup;
		depthPrepass.emplace_back<pipeline_t, render_data_t>(sortKey, renderData);
	}

	template <typename pipeline_t, typename render_data_t,
		class = typename std::enable_if_t<!std::is_lvalue_reference_v<render_data_t>>>
		void renderDepthOnly(render_data_t&& renderData)
	{
		uint64 sortKey = (uint64)pipeline_t::setup;
		depthPrepass.emplace_back<pipeline_t, render_data_t>(sortKey, std::move(renderData));
	}


	template <typename pipeline_t, typename depth_prepass_pipeline_t, typename render_data_t, typename depth_prepass_render_data_t>
	void renderObject(const render_data_t& renderData, 
		const depth_prepass_render_data_t& depthPrepassRenderData)
	{
		renderObject<pipeline_t, render_data_t>(renderData);
		renderDepthOnly<depth_prepass_pipeline_t, depth_prepass_render_data_t>(depthPrepassRenderData);
	}

	template <typename pipeline_t, typename depth_prepass_pipeline_t, typename render_data_t, typename depth_prepass_render_data_t,
		class = typename std::enable_if_t<!std::is_lvalue_reference_v<render_data_t> && !std::is_lvalue_reference_v<depth_prepass_render_data_t>>>
	void renderObject(render_data_t&& renderData,
		depth_prepass_render_data_t&& depthPrepassRenderData)
	{
		renderObject<pipeline_t, render_data_t>(std::move(renderData));
		renderDepthOnly<depth_prepass_pipeline_t, depth_prepass_render_data_t>(std::move(depthPrepassRenderData));
	}

	default_render_command_buffer<uint64> pass;
	depth_prepass_render_command_buffer<uint64> depthPrepass;
};

struct transparent_render_pass
{
	void sort()
	{
		CPU_PROFILE_BLOCK("Sort transparent render pass");

		pass.sort();
	}

	void reset()
	{
		pass.clear();
	}

	template <typename pipeline_t, typename render_data_t>
	void renderObject(const render_data_t& data)
	{
		float depth = 0.f; // TODO
		pass.emplace_back<pipeline_t, render_data_t>(-depth, data); // Negative depth -> sort from back to front.
	}

	template <typename pipeline_t, typename render_data_t>
	void renderParticles(const dx_vertex_buffer_group_view& vertexBuffer,
		const dx_index_buffer_view& indexBuffer,
		const particle_draw_info& drawInfo,
		const render_data_t& data)
	{
		float depth = 0.f; // TODO
		auto& command = pass.emplace_back<pipeline_t, particle_render_command<render_data_t>>(-depth); // Negative depth -> sort from back to front.
		command.vertexBuffer = vertexBuffer;
		command.indexBuffer = indexBuffer;
		command.drawInfo = drawInfo;
		command.data = data;
	}

	default_render_command_buffer<float> pass;
};

struct ldr_render_pass
{
	void sort()
	{
		CPU_PROFILE_BLOCK("Sort LDR render passes");

		ldrPass.sort();
		overlays.sort();
		outlines.sort();
	}

	void reset()
	{
		ldrPass.clear();
		overlays.clear();
		outlines.clear();
	}

	template <typename pipeline_t, typename render_data_t>
	void renderObject(const render_data_t& data)
	{
		uint64 sortKey = (uint64)pipeline_t::setup;
		ldrPass.emplace_back<pipeline_t, render_data_t>(sortKey, data);
	}

	template <typename pipeline_t, typename render_data_t,
		class = typename std::enable_if_t<!std::is_lvalue_reference_v<render_data_t>>>
	void renderObject(render_data_t&& data)
	{
		uint64 sortKey = (uint64)pipeline_t::setup;
		ldrPass.emplace_back<pipeline_t, render_data_t>(sortKey, std::move(data));
	}

	template <typename pipeline_t, typename render_data_t>
	void renderOverlay(const render_data_t& data)
	{
		uint64 sortKey = (uint64)pipeline_t::setup;
		overlays.emplace_back<pipeline_t, render_data_t>(sortKey, data);
	}

	template <typename pipeline_t, typename render_data_t,
		class = typename std::enable_if_t<!std::is_lvalue_reference_v<render_data_t>>>
	void renderOverlay(render_data_t&& data)
	{
		uint64 sortKey = (uint64)pipeline_t::setup;
		overlays.emplace_back<pipeline_t, render_data_t>(sortKey, std::move(data));
	}

	template <typename pipeline_t, typename render_data_t>
	void renderOutline(const render_data_t& data)
	{
		uint64 sortKey = (uint64)pipeline_t::setup;
		outlines.emplace_back<pipeline_t, render_data_t>(sortKey, data);
	}

	template <typename pipeline_t, typename render_data_t,
		class = typename std::enable_if_t<!std::is_lvalue_reference_v<render_data_t>>>
	void renderOutline(render_data_t&& data)
	{
		uint64 sortKey = (uint64)pipeline_t::setup;
		outlines.emplace_back<pipeline_t, render_data_t>(sortKey, std::move(data));
	}

	default_render_command_buffer<uint64> ldrPass;
	default_render_command_buffer<uint64> overlays;
	default_render_command_buffer<uint64> outlines;
};





struct shadow_render_pass_base
{
	void sort()
	{
		staticPass.sort();
		dynamicPass.sort();
	}

	void reset()
	{
		staticPass.clear();
		dynamicPass.clear();
	}


	template <typename pipeline_t, typename render_data_t>
	void renderStaticObject(const render_data_t& renderData)
	{
		uint64 sortKey = (uint64)pipeline_t::setup;
		staticPass.emplace_back<pipeline_t, render_data_t>(sortKey, renderData);
	}

	template <typename pipeline_t, typename render_data_t,
		class = typename std::enable_if_t<!std::is_lvalue_reference_v<render_data_t>>>
	void renderStaticObject(render_data_t&& renderData)
	{
		uint64 sortKey = (uint64)pipeline_t::setup;
		staticPass.emplace_back<pipeline_t, render_data_t>(sortKey, std::move(renderData));
	}

	template <typename pipeline_t, typename render_data_t>
	void renderDynamicObject(const render_data_t& renderData)
	{
		uint64 sortKey = (uint64)pipeline_t::setup;
		dynamicPass.emplace_back<pipeline_t, render_data_t>(sortKey, renderData);
	}

	template <typename pipeline_t, typename render_data_t,
		class = typename std::enable_if_t<!std::is_lvalue_reference_v<render_data_t>>>
	void renderDynamicObject(render_data_t&& renderData)
	{
		uint64 sortKey = (uint64)pipeline_t::setup;
		dynamicPass.emplace_back<pipeline_t, render_data_t>(sortKey, std::move(renderData));
	}

	default_render_command_buffer<uint64> staticPass;
	default_render_command_buffer<uint64> dynamicPass;
};

struct sun_cascade_render_pass : shadow_render_pass_base
{
	mat4 viewProj;
	shadow_map_viewport viewport;
};

struct sun_shadow_render_pass
{
	// Since each cascade includes the next lower one, if you submit a draw to cascade N, it will also be rendered in N-1 automatically. No need to add it to the lower one.

	template <typename pipeline_t, typename render_data_t>
	void renderStaticObject(uint32 cascadeIndex, const render_data_t& renderData)
	{
		cascades[cascadeIndex].renderStaticObject<pipeline_t>(renderData);
	}

	template <typename pipeline_t, typename render_data_t,
		class = typename std::enable_if_t<!std::is_lvalue_reference_v<render_data_t>>>
	void renderStaticObject(uint32 cascadeIndex, render_data_t&& renderData)
	{
		cascades[cascadeIndex].renderStaticObject<pipeline_t>(std::move(renderData));
	}

	template <typename pipeline_t, typename render_data_t>
	void renderDynamicObject(uint32 cascadeIndex, const render_data_t& renderData)
	{
		cascades[cascadeIndex].renderDynamicObject<pipeline_t>(renderData);
	}

	template <typename pipeline_t, typename render_data_t,
		class = typename std::enable_if_t<!std::is_lvalue_reference_v<render_data_t>>>
	void renderDynamicObject(uint32 cascadeIndex, render_data_t&& renderData)
	{
		cascades[cascadeIndex].renderDynamicObject<pipeline_t>(std::move(renderData));
	}

	void reset()
	{
		for (uint32 i = 0; i < MAX_NUM_SUN_SHADOW_CASCADES; ++i)
		{
			cascades[i].reset();
		}

		copyFromStaticCache = false;
	}

	sun_cascade_render_pass cascades[MAX_NUM_SUN_SHADOW_CASCADES];
	uint32 numCascades;
	bool copyFromStaticCache;
};

struct spot_shadow_render_pass : shadow_render_pass_base
{
	mat4 viewProjMatrix;
	shadow_map_viewport viewport;
	bool copyFromStaticCache;

	void reset()
	{
		shadow_render_pass_base::reset();
		copyFromStaticCache = false;
	}
};

// TODO: Split this into positive and negative direction for frustum culling.
struct point_shadow_render_pass : shadow_render_pass_base
{
	shadow_map_viewport viewport0;
	shadow_map_viewport viewport1;
	vec3 lightPosition;
	float maxDistance;
	bool copyFromStaticCache0;
	bool copyFromStaticCache1;

	void reset()
	{
		shadow_render_pass_base::reset();

		copyFromStaticCache0 = false;
		copyFromStaticCache1 = false;
	}
};



enum compute_pass_event
{
	compute_pass_frame_start,
	compute_pass_before_depth_prepass,
	compute_pass_before_opaque,
	compute_pass_before_transparent_and_post_processing,

	compute_pass_event_count,
};

struct compute_pass
{
	void reset()
	{
		particleSystemUpdates.clear();

		for (uint32 i = 0; i < compute_pass_event_count; ++i)
		{
			passes[i].clear();
		}
	}

	void updateParticleSystem(struct particle_system* p)
	{
		particleSystemUpdates.push_back(p);
	}

	template <typename pipeline_t, typename render_data_t>
	void addTask(compute_pass_event eventTime, const render_data_t& data)
	{
		passes[eventTime].emplace_back<pipeline_t, render_data_t>(eventTime, data);
	}

	template <typename pipeline_t, typename render_data_t,
		class = typename std::enable_if_t<!std::is_lvalue_reference_v<render_data_t>>>
	void addTask(compute_pass_event eventTime, render_data_t&& data)
	{
		passes[eventTime].emplace_back<pipeline_t, render_data_t>(eventTime, std::move(data));
	}


	float dt;
	std::vector<struct particle_system*> particleSystemUpdates;

	compute_command_buffer<uint64> passes[compute_pass_event_count];
};



```

`src/rendering/render_resources.cpp`:

```cpp
#include "pch.h"
#include "render_resources.h"
#include "dx/dx_context.h"
#include "dx/dx_barrier_batcher.h"
#include "texture_preprocessing.h"
#include "core/hash.h"
#include "render_algorithms.h"


ref<dx_texture> render_resources::brdfTex;
ref<dx_texture> render_resources::whiteTexture;
ref<dx_texture> render_resources::blackTexture;
ref<dx_texture> render_resources::blackCubeTexture;
ref<dx_texture> render_resources::noiseTexture;
ref<dx_texture> render_resources::defaultNormalMap;
				
ref<dx_texture> render_resources::shadowMap;
ref<dx_texture> render_resources::staticShadowMapCache;

dx_cpu_descriptor_handle render_resources::nullTextureSRV;
dx_cpu_descriptor_handle render_resources::nullBufferSRV;

dx_rtv_descriptor_handle render_resources::nullScreenVelocitiesRTV;
dx_rtv_descriptor_handle render_resources::nullObjectIDsRTV;

dx_heap render_resources::resourceHeap;
std::unordered_map<uint64, render_resources::temporary_render_resources> render_resources::resourceMap;

bool render_resources::dirty = false;

void render_resources::initializeGlobalResources()
{
	{
		uint8 white[] = { 255, 255, 255, 255 };
		whiteTexture = createTexture(white, 1, 1, DXGI_FORMAT_R8G8B8A8_UNORM);
		SET_NAME(whiteTexture->resource, "White");
	}
	{
		uint8 black[] = { 0, 0, 0, 255 };
		blackTexture = createTexture(black, 1, 1, DXGI_FORMAT_R8G8B8A8_UNORM);
		SET_NAME(blackTexture->resource, "Black");

		blackCubeTexture = createCubeTexture(black, 1, 1, DXGI_FORMAT_R8G8B8A8_UNORM);
		SET_NAME(blackCubeTexture->resource, "Black cube");
	}
	{
		uint8 up[] = { 128, 128, 255, 255 };
		defaultNormalMap = createTexture(up, 1, 1, DXGI_FORMAT_R8G8B8A8_UNORM);
		SET_NAME(defaultNormalMap->resource, "Default normal map");
	}

	noiseTexture = loadTextureFromFile("resources/noise/blue_noise.dds", image_load_flags_noncolor); // Already compressed and in DDS format.

	shadowMap = createDepthTexture(SHADOW_MAP_WIDTH, SHADOW_MAP_HEIGHT, shadowDepthFormat, 1, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE);
	SET_NAME(shadowMap->resource, "Shadow map");

	staticShadowMapCache = createDepthTexture(SHADOW_MAP_WIDTH, SHADOW_MAP_HEIGHT, shadowDepthFormat, 1, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE);
	SET_NAME(staticShadowMapCache->resource, "Static shadow map cache");

	{
		dx_command_list* cl = dxContext.getFreeRenderCommandList();
		brdfTex = integrateBRDF(cl);
		dxContext.executeCommandList(cl);
	}

	nullTextureSRV = dx_cpu_descriptor_handle(dxContext.srvUavAllocator.allocate(1).cpuAt(0)).createNullTextureSRV();
	nullBufferSRV = dx_cpu_descriptor_handle(dxContext.srvUavAllocator.allocate(1).cpuAt(0)).createNullBufferSRV();

	nullScreenVelocitiesRTV = dx_rtv_descriptor_handle(dxContext.rtvAllocator.allocate(1).cpuAt(0)).createNullTextureRTV(screenVelocitiesFormat);
	nullObjectIDsRTV = dx_rtv_descriptor_handle(dxContext.rtvAllocator.allocate(1).cpuAt(0)).createNullTextureRTV(objectIDsFormat);
}

void render_resources::declareTemporaryResourceNeeds(uint64 id, const std::vector<render_resource_desc>& descs)
{
	uint64 hash = hashResourceRequirements(descs);

	auto it = resourceMap.find(id);
	if (it == resourceMap.end() || it->second.hash != hash)
	{
		dirty = true;

		temporary_render_resources resources;
		resources.hash = hash;
		resources.descs = descs;
		getAllocationInfo(resources);
		resourceMap[id] = std::move(resources);
	}
}

void render_resources::evaluate()
{
	if (dirty)
	{
		if (resourceHeap)
		{
			dxContext.retire(resourceHeap);
		}

		uint64 maxAlignment = 0;
		uint64 maxSize = 0;
		for (auto it : resourceMap)
		{
			maxAlignment = max(maxAlignment, it.second.alignment);
			maxSize = max(maxSize, it.second.totalAllocationSize);
		}

		D3D12_HEAP_DESC heapDesc = {};
		heapDesc.SizeInBytes = maxSize;
		heapDesc.Alignment = maxAlignment;
		heapDesc.Flags = D3D12_HEAP_FLAG_ALLOW_ALL_BUFFERS_AND_TEXTURES;
		heapDesc.Properties.CPUPageProperty = D3D12_CPU_PAGE_PROPERTY_UNKNOWN;
		heapDesc.Properties.MemoryPoolPreference = D3D12_MEMORY_POOL_UNKNOWN;
		heapDesc.Properties.Type = D3D12_HEAP_TYPE_DEFAULT;

		checkResult(dxContext.device->CreateHeap(&heapDesc, IID_PPV_ARGS(&resourceHeap)));


		for (auto it : resourceMap)
		{
			temporary_render_resources& resources = it.second;
			allocateResources(resources);
		}

		dirty = false;
	}
}

const std::vector<ref<dx_texture>>& render_resources::getTemporaryResources(uint64 id, dx_command_list* cl)
{
	ASSERT(!dirty);

	std::vector<ref<dx_texture>>& textures = resourceMap[id].textures;
	
	barrier_batcher batcher(cl);
	for (const ref<dx_texture>& texture : textures)
	{
		batcher.aliasing(0, texture);
	}

	return textures;
}

void render_resources::getAllocationInfo(temporary_render_resources& resources)
{
	resources.offsetsInBytes.clear();

	uint64 offset = 0;
	for (const render_resource_desc& desc : resources.descs)
	{
		D3D12_RESOURCE_ALLOCATION_INFO allocationInfo = dxContext.device->GetResourceAllocationInfo(0, 1, &desc.desc);

		if (offset == 0)
		{
			resources.alignment = allocationInfo.Alignment;
		}

		offset = alignTo(offset, allocationInfo.Alignment);

		resources.offsetsInBytes.push_back(offset);

		offset += allocationInfo.SizeInBytes;
	}

	resources.totalAllocationSize = offset;
}

uint64 render_resources::hashResourceRequirements(const std::vector<render_resource_desc>& descs)
{
	uint64 hash = 0;
	for (const render_resource_desc& desc : descs)
	{
		hash_combine(hash, (uint32)desc.desc.Dimension);
		hash_combine(hash, desc.desc.Alignment);
		hash_combine(hash, desc.desc.Width);
		hash_combine(hash, desc.desc.Height);
		hash_combine(hash, desc.desc.DepthOrArraySize);
		hash_combine(hash, desc.desc.MipLevels);
		hash_combine(hash, desc.desc.Format);
		hash_combine(hash, desc.desc.SampleDesc.Count);
		hash_combine(hash, desc.desc.SampleDesc.Quality);
		hash_combine(hash, (uint32)desc.desc.Layout);
		hash_combine(hash, (uint32)desc.desc.Flags);
	}
	return hash;
}

void render_resources::allocateResources(temporary_render_resources& resources)
{
	resources.textures.clear();

	for (uint32 i = 0; i < (uint32)resources.descs.size(); ++i)
	{
		uint64 offset = resources.offsetsInBytes[i];
		auto& desc = resources.descs[i];

		ref<dx_texture> texture =
			isDepthFormat(desc.desc.Format)
			? createPlacedDepthTexture(resourceHeap, offset, desc.desc, desc.initialState)
			: createPlacedTexture(resourceHeap, offset, desc.desc, desc.initialState);
		texture->setName(desc.name);

		resources.textures.push_back(texture);
	}
}

```

`src/rendering/render_resources.h`:

```h
#pragma once

#include "dx/dx.h"
#include "dx/dx_texture.h"
#include "dx/dx_command_list.h"
#include "render_utils.h"

#include <unordered_map>


#define SHADOW_MAP_WIDTH 6144
#define SHADOW_MAP_HEIGHT 6144

struct render_resource_desc
{
	const wchar* name;
	D3D12_RESOURCE_DESC desc;
	D3D12_RESOURCE_STATES initialState;
};

struct render_resources
{
	static void initializeGlobalResources();

	// Call from renderer in beginFrame().
	static void declareTemporaryResourceNeeds(uint64 id, const std::vector<render_resource_desc>& descs);

	// Call from central place after all renderers have declared their needs.
	static void evaluate();

	// Call from renderer in endFrame().
	static const std::vector<ref<dx_texture>>& getTemporaryResources(uint64 id, dx_command_list* cl);

	static dx_cpu_descriptor_handle nullTextureSRV;
	static dx_cpu_descriptor_handle nullBufferSRV;

	static dx_rtv_descriptor_handle nullScreenVelocitiesRTV;
	static dx_rtv_descriptor_handle nullObjectIDsRTV;

	static ref<dx_texture> brdfTex;
	static ref<dx_texture> whiteTexture;
	static ref<dx_texture> blackTexture;
	static ref<dx_texture> blackCubeTexture;
	static ref<dx_texture> noiseTexture;
	static ref<dx_texture> defaultNormalMap;

	static ref<dx_texture> shadowMap;
	static ref<dx_texture> staticShadowMapCache;

private:
	struct temporary_render_resources
	{
		uint64 hash;
		uint64 alignment;
		uint64 totalAllocationSize;
		std::vector<uint64> offsetsInBytes;
		std::vector<render_resource_desc> descs;
		std::vector<ref<dx_texture>> textures;
	};

	static void getAllocationInfo(temporary_render_resources& resources);
	static uint64 hashResourceRequirements(const std::vector<render_resource_desc>& descs);

	static void allocateResources(temporary_render_resources& resources);

	static dx_heap resourceHeap;
	static std::unordered_map<uint64, temporary_render_resources> resourceMap;

	static bool dirty;
};

```

`src/rendering/render_utils.cpp`:

```cpp
#include "pch.h"
#include "render_utils.h"
#include "core/random.h"
#include "dx/dx_context.h"
#include "animation/skinning.h"
#include "texture_preprocessing.h"
#include "render_resources.h"
#include "render_algorithms.h"
#include "outline.h"
#include "pbr.h"
#include "particles/particles.h"
#include "particles/particle_systems.h"
#include "bitonic_sort.h"
#include "debug_visualization.h"
#include "light_probe.h"
#include "raytraced_reflections.h"
#include "shadow_map.h"
#include "terrain/terrain.h"
#include "terrain/proc_placement.h"
#include "terrain/grass.h"
#include "terrain/water.h"
#include "terrain/tree.h"


// Defined in render_algorithms.cpp.
void loadCommonShaders();


static vec2 haltonSequence[128];

void initializeRenderUtils()
{
	initializeTexturePreprocessing();
	initializeDepthPrepassPipelines();
	initializeOutlinePipelines();
	initializeSkinning();
	initializeShadowPipelines();
	initializeTerrainPipelines();
	initializeLightProbePipelines();
	initializeRTReflectionsPipelines();
	initializeProceduralPlacementPipelines();
	initializeGrassPipelines();
	initializeWaterPipelines();
	initializeTreePipelines();
	loadCommonShaders();

	debug_simple_pipeline::initialize();
	debug_unlit_pipeline::initialize();
	debug_unlit_line_pipeline::initialize();
	pbr_pipeline::initialize();
	particle_system::initializePipeline();
	initializeBitonicSort();
	loadAllParticleSystemPipelines();


	createAllPendingReloadablePipelines();
	render_resources::initializeGlobalResources();

	for (uint32 i = 0; i < arraysize(haltonSequence); ++i)
	{
		haltonSequence[i] = halton23(i) * 2.f - vec2(1.f);
	}
}

void endFrameCommon()
{
	checkForChangedPipelines();
}

void buildCameraConstantBuffer(const render_camera& camera, float cameraJitterStrength, camera_cb& outCB)
{
	if (cameraJitterStrength > 0.f)
	{
		vec2 jitter = haltonSequence[dxContext.frameID % arraysize(haltonSequence)] / vec2((float)camera.width, (float)camera.height) * cameraJitterStrength;
		buildCameraConstantBuffer(camera.getJitteredVersion(jitter), jitter, outCB);
	}
	else
	{
		buildCameraConstantBuffer(camera, vec2(0.f, 0.f), outCB);
	}
}

void buildCameraConstantBuffer(const render_camera& camera, vec2 jitter, camera_cb& outCB)
{
	outCB.prevFrameView = outCB.view;
	outCB.prevFrameViewProj = outCB.viewProj;
	outCB.viewProj = camera.viewProj;
	outCB.view = camera.view;
	outCB.proj = camera.proj;
	outCB.invViewProj = camera.invViewProj;
	outCB.invView = camera.invView;
	outCB.invProj = camera.invProj;
	outCB.position = vec4(camera.position, 1.f);
	outCB.forward = vec4(camera.rotation * vec3(0.f, 0.f, -1.f), 0.f);
	outCB.right = vec4(camera.rotation * vec3(1.f, 0.f, 0.f), 0.f);
	outCB.up = vec4(camera.rotation * vec3(0.f, 1.f, 0.f), 0.f);
	outCB.projectionParams = vec4(camera.nearPlane, camera.farPlane, camera.farPlane / camera.nearPlane, 1.f - camera.farPlane / camera.nearPlane);
	outCB.viewSpaceTopLeftFrustumVector = vec4(camera.restoreViewSpacePosition(vec2(0.f, 0.f), 0.f) / camera.nearPlane, 0.f);
	outCB.extentAtDistanceOne = abs(camera.restoreViewSpacePosition(vec2(1.f, 1.f), 0.f).xy / camera.nearPlane - outCB.viewSpaceTopLeftFrustumVector.xy);
	outCB.screenDims = vec2((float)camera.width, (float)camera.height);
	outCB.invScreenDims = vec2(1.f / camera.width, 1.f / camera.height);
	outCB.prevFrameJitter = outCB.jitter;
	outCB.jitter = jitter;
}

```

`src/rendering/render_utils.h`:

```h
#pragma once

#include "dx/dx_pipeline.h"
#include "core/camera.h"
#include "light_source.h"
#include "render_pass.h"
#include "camera.hlsli"




void initializeRenderUtils();
void endFrameCommon();

void buildCameraConstantBuffer(const render_camera& camera, float cameraJitterStrength, camera_cb& outCB);
void buildCameraConstantBuffer(const render_camera& camera, vec2 jitter, camera_cb& outCB);


static constexpr DXGI_FORMAT hdrFormat = DXGI_FORMAT_R16G16B16A16_FLOAT;
static constexpr DXGI_FORMAT ldrFormat = DXGI_FORMAT_R10G10B10A2_UNORM; // Not really LDR. But I don't like the idea of converting to 8 bit and then to sRGB in separate passes.

static constexpr DXGI_FORMAT worldNormalsRoughnessFormat = DXGI_FORMAT_R16G16B16A16_FLOAT; // Alpha channel not used right now.
static constexpr DXGI_FORMAT screenVelocitiesFormat = DXGI_FORMAT_R16G16_FLOAT;
static constexpr DXGI_FORMAT depthStencilFormat = DXGI_FORMAT_D24_UNORM_S8_UINT;
static constexpr DXGI_FORMAT linearDepthFormat = DXGI_FORMAT_R32_FLOAT;
static constexpr DXGI_FORMAT objectIDsFormat = DXGI_FORMAT_R32_UINT;

static constexpr DXGI_FORMAT aoFormat = DXGI_FORMAT_R8_UNORM;
static constexpr DXGI_FORMAT sssFormat = DXGI_FORMAT_R8_UNORM;

static constexpr DXGI_FORMAT shadowDepthFormat = DXGI_FORMAT_D16_UNORM;


static constexpr DXGI_FORMAT opaqueLightPassFormats[] = { hdrFormat, worldNormalsRoughnessFormat, screenVelocitiesFormat, objectIDsFormat };
static constexpr uint32 OPQAUE_LIGHT_PASS_FULL = arraysize(opaqueLightPassFormats);
static constexpr uint32 OPQAUE_LIGHT_PASS_NO_VELOCITIES_NO_OBJECT_ID = 2;

static constexpr DXGI_FORMAT transparentLightPassFormats[] = { hdrFormat };
static constexpr DXGI_FORMAT skyPassFormats[] = { hdrFormat, screenVelocitiesFormat, objectIDsFormat };
static constexpr DXGI_FORMAT depthOnlyFormat[] = { screenVelocitiesFormat, objectIDsFormat };


enum color_depth
{
	color_depth_8,
	color_depth_10,
};

static constexpr DXGI_FORMAT colorDepthToFormat(color_depth colorDepth)
{
	return (colorDepth == color_depth_8) ? DXGI_FORMAT_R8G8B8A8_UNORM : DXGI_FORMAT_R10G10B10A2_UNORM;
}



```

`src/rendering/shadow_map.cpp`:

```cpp
#include "pch.h"
#include "shadow_map.h"
#include "render_resources.h"
#include "shadow_map_cache.h"

#include "depth_only_rs.hlsli"


shadow_render_command determineSunShadowInfo(directional_light& sun, bool invalidateCache)
{
	bool staticCacheAvailable = !invalidateCache;

	uint64 movementHash = getLightMovementHash(sun);

	shadow_render_command result;

	for (uint32 i = 0; i < sun.numShadowCascades; ++i)
	{
		auto [vp, cache] = assignShadowMapViewport(i, movementHash, sun.shadowDimensions);

		sun.shadowMapViewports[i] = vec4(vp.x, vp.y, vp.size, vp.size) / vec4((float)SHADOW_MAP_WIDTH, (float)SHADOW_MAP_HEIGHT, (float)SHADOW_MAP_WIDTH, (float)SHADOW_MAP_HEIGHT);
		result.viewports[i] = vp;

		staticCacheAvailable &= cache;
	}

	result.renderStaticGeometry = !staticCacheAvailable;
	result.renderDynamicGeometry = true;

	return result;
}

std::pair<shadow_render_command, spot_shadow_info> determineSpotShadowInfo(const spot_light_cb& spotLight, uint32 lightID, uint32 resolution, bool invalidateCache)
{
	uint64 uniqueID = ((uint64)(lightID + 1) << 32);

	uint64 movementHash = getLightMovementHash(spotLight);

	shadow_render_command result;

	auto [vp, staticCacheAvailable] = assignShadowMapViewport(uniqueID, movementHash, resolution);
	result.viewports[0] = vp;

	result.renderStaticGeometry = !staticCacheAvailable || invalidateCache;
	result.renderDynamicGeometry = true;

	spot_shadow_info si;
	si.viewport = vec4(vp.x, vp.y, vp.size, vp.size) / vec4((float)SHADOW_MAP_WIDTH, (float)SHADOW_MAP_HEIGHT, (float)SHADOW_MAP_WIDTH, (float)SHADOW_MAP_HEIGHT);
	si.viewProj = getSpotLightViewProjectionMatrix(spotLight);
	si.bias = 0.00002f;
	return { result, si };
}

std::pair<shadow_render_command, point_shadow_info> determinePointShadowInfo(const point_light_cb& pointLight, uint32 lightID, uint32 resolution, bool invalidateCache)
{
	uint64 uniqueID = ((uint64)(lightID + 1) << 32);

	uint64 movementHash = getLightMovementHash(pointLight);

	shadow_render_command result;

	auto [vp0, staticCacheAvailable0] = assignShadowMapViewport(uniqueID, movementHash, resolution);
	auto [vp1, staticCacheAvailable1] = assignShadowMapViewport(uniqueID + 1, movementHash, resolution);
	result.viewports[0] = vp0;
	result.viewports[1] = vp1;

	result.renderStaticGeometry = !staticCacheAvailable0 || !staticCacheAvailable1 || invalidateCache;
	result.renderDynamicGeometry = true;

	point_shadow_info si;
	si.viewport0 = vec4(vp0.x, vp0.y, vp0.size, vp0.size) / vec4((float)SHADOW_MAP_WIDTH, (float)SHADOW_MAP_HEIGHT, (float)SHADOW_MAP_WIDTH, (float)SHADOW_MAP_HEIGHT);
	si.viewport1 = vec4(vp1.x, vp1.y, vp1.size, vp1.size) / vec4((float)SHADOW_MAP_WIDTH, (float)SHADOW_MAP_HEIGHT, (float)SHADOW_MAP_WIDTH, (float)SHADOW_MAP_HEIGHT);
	return { result, si };
}












static dx_pipeline shadowPipeline;
static dx_pipeline doubleSidedShadowPipeline;

static dx_pipeline pointLightShadowPipeline;
static dx_pipeline doubleSidedPointLightShadowPipeline;

void initializeShadowPipelines()
{
	auto desc = CREATE_GRAPHICS_PIPELINE
		.renderTargets(0, 0, shadowDepthFormat)
		.inputLayout(inputLayout_position)
		//.cullFrontFaces()
		;

	shadowPipeline = createReloadablePipeline(desc, { "shadow_vs" }, rs_in_vertex_shader);
	pointLightShadowPipeline = createReloadablePipeline(desc, { "shadow_point_light_vs", "shadow_point_light_ps" }, rs_in_vertex_shader);

	desc.cullingOff();
	doubleSidedShadowPipeline = createReloadablePipeline(desc, { "shadow_vs" }, rs_in_vertex_shader);
	doubleSidedPointLightShadowPipeline = createReloadablePipeline(desc, { "shadow_point_light_vs", "shadow_point_light_ps" }, rs_in_vertex_shader);
}

PIPELINE_SETUP_IMPL(shadow_pipeline::single_sided)
{
	cl->setPipelineState(*shadowPipeline.pipeline);
	cl->setGraphicsRootSignature(*shadowPipeline.rootSignature);

	cl->setPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
}

PIPELINE_SETUP_IMPL(shadow_pipeline::double_sided)
{
	cl->setPipelineState(*doubleSidedShadowPipeline.pipeline);
	cl->setGraphicsRootSignature(*doubleSidedShadowPipeline.rootSignature);

	cl->setPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
}

PIPELINE_RENDER_IMPL(shadow_pipeline, shadow_render_data)
{
	cl->setRootGraphicsSRV(SHADOW_RS_TRANSFORMS, data.transformPtr);
	cl->setGraphics32BitConstants(SHADOW_RS_VIEWPROJ, viewProj);

	cl->setVertexBuffer(0, data.vertexBuffer);
	cl->setIndexBuffer(data.indexBuffer);

	cl->drawIndexed(data.submesh.numIndices, data.numInstances, data.submesh.firstIndex, data.submesh.baseVertex, 0);
}




PIPELINE_SETUP_IMPL(point_shadow_pipeline::single_sided)
{
	cl->setPipelineState(*pointLightShadowPipeline.pipeline);
	cl->setGraphicsRootSignature(*pointLightShadowPipeline.rootSignature);

	cl->setPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
}

PIPELINE_SETUP_IMPL(point_shadow_pipeline::double_sided)
{
	cl->setPipelineState(*doubleSidedPointLightShadowPipeline.pipeline);
	cl->setGraphicsRootSignature(*doubleSidedPointLightShadowPipeline.rootSignature);

	cl->setPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
}

PIPELINE_RENDER_IMPL(point_shadow_pipeline, shadow_render_data)
{
	cl->setRootGraphicsSRV(SHADOW_RS_TRANSFORMS, data.transformPtr);

	cl->setVertexBuffer(0, data.vertexBuffer);
	cl->setIndexBuffer(data.indexBuffer);

	cl->drawIndexed(data.submesh.numIndices, data.numInstances, data.submesh.firstIndex, data.submesh.baseVertex, 0);
}








```

`src/rendering/shadow_map.h`:

```h
#pragma once

#include "scene/scene.h"
#include "light_source.h"
#include "render_pass.h"



struct shadow_render_command
{
	bool renderStaticGeometry;
	bool renderDynamicGeometry;

	shadow_map_viewport viewports[4];
};


shadow_render_command determineSunShadowInfo(directional_light& sun, bool invalidateCache);
std::pair<shadow_render_command, spot_shadow_info> determineSpotShadowInfo(const spot_light_cb& spotLight, uint32 lightID, uint32 resolution, bool invalidateCache);
std::pair<shadow_render_command, point_shadow_info> determinePointShadowInfo(const point_light_cb& pointLight, uint32 lightID, uint32 resolution, bool invalidateCache);

struct shadow_render_data
{
	D3D12_GPU_VIRTUAL_ADDRESS transformPtr;
	dx_vertex_buffer_view vertexBuffer;
	dx_index_buffer_view indexBuffer;
	submesh_info submesh;

	uint32 numInstances;
};

struct shadow_pipeline
{
	PIPELINE_RENDER_DECL(shadow_render_data);

	struct single_sided;
	struct double_sided;
};

struct shadow_pipeline::single_sided : shadow_pipeline
{
	PIPELINE_SETUP_DECL;
};

struct shadow_pipeline::double_sided : shadow_pipeline
{
	PIPELINE_SETUP_DECL;
};



struct point_shadow_pipeline
{
	PIPELINE_RENDER_DECL(shadow_render_data);

	struct single_sided;
	struct double_sided;
};

struct point_shadow_pipeline::single_sided : point_shadow_pipeline
{
	PIPELINE_SETUP_DECL;
};

struct point_shadow_pipeline::double_sided : point_shadow_pipeline
{
	PIPELINE_SETUP_DECL;
};


void initializeShadowPipelines();

```

`src/rendering/shadow_map_cache.cpp`:

```cpp
#include "pch.h"
#include "shadow_map_cache.h"
#include "dx/dx_texture.h"
#include "dx/dx_command_list.h"
#include "core/hash.h"
#include "render_resources.h"

#include "light_source.h"
#include "core/camera.h"

#include "core/imgui.h"


#define DEBUG_VISUALIZATION 0


bool enableStaticShadowMapCaching = true;


static constexpr uint16 maximumSize = 2048;
static constexpr uint16 minimumSize = 128;
static_assert(SHADOW_MAP_WIDTH % maximumSize == 0, "");
static_assert(SHADOW_MAP_HEIGHT % maximumSize == 0, "");
static_assert(isPowerOfTwo(maximumSize), "");
static_assert(isPowerOfTwo(minimumSize), "");

static constexpr uint32 numBuckets = indexOfLeastSignificantSetBit(maximumSize) - indexOfLeastSignificantSetBit(minimumSize) + 1;
static std::vector<shadow_map_viewport> nodes[numBuckets];

struct shadow_map_cache
{
	shadow_map_viewport viewport;
	uint64 lightMovementHash;
};

static std::unordered_map<uint64, shadow_map_cache> cachedAllocations;

static ref<dx_texture> visTexture;

static void initialize()
{
	for (uint32 y = 0; y < SHADOW_MAP_HEIGHT / maximumSize; ++y)
	{
		for (uint32 x = 0; x < SHADOW_MAP_WIDTH / maximumSize; ++x)
		{
			nodes[0].push_back({ (uint16)(x * maximumSize), (uint16)(y * maximumSize), maximumSize });
		}
	}
}

static uint32 getIndex(uint32 size)
{
	uint32 index = indexOfLeastSignificantSetBit(size) - indexOfLeastSignificantSetBit(minimumSize);
	index = numBuckets - index - 1;
	return index;
}

static shadow_map_viewport allocateShadowViewport(uint32 size)
{
	ASSERT(size <= maximumSize);
	ASSERT(size >= minimumSize);
	ASSERT(isPowerOfTwo(size));

	uint32 index = getIndex(size);

	uint32 insertIndex = index;
	for (; insertIndex != -1 && nodes[insertIndex].size() == 0; --insertIndex);

	ASSERT(insertIndex != -1); // TODO: Handle error.
	ASSERT(nodes[insertIndex].size() > 0);


	for (uint32 i = insertIndex; i < index; ++i)
	{
		uint16 nodeSize = 1u << (indexOfLeastSignificantSetBit(maximumSize) - i);
		uint16 halfSize = nodeSize / 2;

		shadow_map_viewport n = nodes[i].back();
		nodes[i].pop_back();

		nodes[i + 1].push_back({ n.x, n.y, halfSize });
		nodes[i + 1].push_back({ (uint16)(n.x + halfSize), n.y, halfSize });
		nodes[i + 1].push_back({ n.x, (uint16)(n.y + halfSize), halfSize });
		nodes[i + 1].push_back({ (uint16)(n.x + halfSize), (uint16)(n.y + halfSize), halfSize });
	}

	shadow_map_viewport result = nodes[index].back();
	nodes[index].pop_back();
	return result;
}

static void freeShadowViewport(shadow_map_viewport remove)
{
	if (remove.size == maximumSize)
	{
		nodes[0].push_back(remove);
		return;
	}


	uint32 index = getIndex(remove.size);
	std::vector<shadow_map_viewport>& list = nodes[index];
	if (list.size() == 0)
	{
		list.push_back(remove);
		return;
	}


	uint32 doubleSize = remove.size * 2;
	uint32 shift = indexOfLeastSignificantSetBit(doubleSize);

	uint32 parentX = remove.x >> shift;
	uint32 parentY = remove.y >> shift;
	uint32 parentWidth = SHADOW_MAP_WIDTH >> shift;
	uint32 parentIndex = parentY * parentWidth + parentX;


	uint32 nodesWithThisParent = 0;
	auto insertIt = list.end();

	for (auto it = list.begin(); it != list.end(); ++it)
	{
		shadow_map_viewport node = *it;

		uint32 pX = node.x >> shift;
		uint32 pY = node.y >> shift;
		uint32 pi = pY * parentWidth + pX;

		if (pi == parentIndex)
		{
			++nodesWithThisParent;
		}
		else if (pi > parentIndex)
		{
			insertIt = it;
			break;
		}
	}

	ASSERT(nodesWithThisParent < 4);

	if (nodesWithThisParent == 3)
	{
		auto eraseIt = insertIt - 3;
		list.erase(eraseIt, insertIt);
		freeShadowViewport(shadow_map_viewport{ (uint16)(parentX * doubleSize), (uint16)(parentY * doubleSize), (uint16)doubleSize });
	}
	else
	{
		list.insert(insertIt, remove);
	}
}

static void visualize(dx_command_list* cl, ref<dx_texture> texture)
{
	for (uint32 i = 0; i < numBuckets; ++i)
	{
		std::vector<shadow_map_viewport>& nodesInLevel = nodes[i];

		for (shadow_map_viewport vp : nodesInLevel)
		{
			clear_rect rect = { vp.x, vp.y, vp.size, vp.size };
			cl->clearRTV(texture, 0.f, 1.f, 0.f, 1.f, &rect, 1);
		}
	}

	for (auto a : cachedAllocations)
	{
		auto vp = a.second.viewport;
		clear_rect rect = { vp.x, vp.y, vp.size, vp.size };
		cl->clearRTV(texture, 1.f, 0.f, 0.f, 1.f, &rect, 1);
	}
}


static bool init = false;

std::pair<shadow_map_viewport, bool> assignShadowMapViewport(uint64 uniqueLightID, uint64 lightMovementHash, uint32 size)
{
	if (!init)
	{
		initialize();
#if DEBUG_VISUALIZATION
		visTexture = createTexture(0, SHADOW_MAP_WIDTH, SHADOW_MAP_HEIGHT, DXGI_FORMAT_R8G8B8A8_UNORM, false, true, false);
#endif
		init = true;
	}


	bool staticCacheAvailable = false;
	shadow_map_viewport vp;

	auto it = cachedAllocations.find(uniqueLightID);
	if (it == cachedAllocations.end())
	{
		// New light.
		vp = allocateShadowViewport(size);
		it = cachedAllocations.insert({ uniqueLightID, { vp, lightMovementHash } }).first;
	}
	else
	{
		if (it->second.viewport.size != size)
		{
			// Reallocate.
			freeShadowViewport(it->second.viewport);
			vp = allocateShadowViewport(size);
			it->second.viewport = vp;
		}
		else
		{
			if (it->second.lightMovementHash == lightMovementHash)
			{
				staticCacheAvailable = true;
			}

			vp = it->second.viewport;
		}

		it->second.lightMovementHash = lightMovementHash;
	}

	staticCacheAvailable &= enableStaticShadowMapCaching;

	return { vp, staticCacheAvailable };
}

uint64 getLightMovementHash(const directional_light& dl)
{
	size_t seed = 0;
	for (uint32 i = 0; i < dl.numShadowCascades; ++i)
	{
		hash_combine(seed, dl.viewProjs[i]);
	}
	return seed;
}

uint64 getLightMovementHash(const spot_light_cb& sl)
{
	size_t seed = 0;
	hash_combine(seed, sl.direction);
	hash_combine(seed, sl.position);
	hash_combine(seed, sl.getOuterCutoff());
	hash_combine(seed, sl.maxDistance);
	return seed;
}

uint64 getLightMovementHash(const point_light_cb& pl)
{
	size_t seed = 0;
	hash_combine(seed, pl.position);
	hash_combine(seed, pl.radius);
	return seed;
}

void updateShadowMapAllocationVisualization()
{
#if DEBUG_VISUALIZATION
	if (updateVisualization)
	{
		dx_command_list* cl = dxContext.getFreeRenderCommandList();
		visualize(cl, visTexture);
		dxContext.executeCommandList(cl);

		ImGui::Begin("Settings");
		ImGui::Image(visTexture, 512, 512);
		ImGui::End();
	}
#endif
}

```

`src/rendering/shadow_map_cache.h`:

```h
#pragma once

#include "core/math.h"

struct shadow_map_viewport
{
	uint16 x, y;
	uint16 size;
};

extern bool enableStaticShadowMapCaching;

// Call after light view-projection-matrices are computed.
uint64 getLightMovementHash(const struct directional_light& dl); // Whole light.
uint64 getLightMovementHash(const struct spot_light_cb& sl);
uint64 getLightMovementHash(const struct point_light_cb& pl);


// Returns true, if static cache is available.
std::pair<shadow_map_viewport, bool> assignShadowMapViewport(uint64 uniqueLightID, uint64 lightMovementHash, uint32 size);
void updateShadowMapAllocationVisualization();

```

`src/rendering/texture_preprocessing.cpp`:

```cpp
#include "pch.h"
#include "texture_preprocessing.h"
#include "dx/dx_context.h"
#include "core/math.h"
#include "dx/dx_command_list.h"
#include "dx/dx_pipeline.h"
#include "dx/dx_barrier_batcher.h"



static dx_pipeline mipmapPipeline;
static dx_pipeline equirectangularToCubemapPipeline;

static dx_pipeline texturedSkyToIrradiancePipeline;
static dx_pipeline texturedSkyToIrradianceSHPipeline;
static dx_pipeline texturedSkyToPrefilteredRadiancePipeline;

static dx_pipeline proceduralSkyToIrradiancePipeline;
//static dx_pipeline proceduralSkyToPrefilteredRadiancePipeline;

static dx_pipeline integrateBRDFPipeline;



struct mipmap_cb
{
	uint32 srcMipLevel;				// Texture level of source mip
	uint32 numMipLevelsToGenerate;	// The shader can generate up to 4 mips at once.
	uint32 srcDimensionFlags;		// Flags specifying whether width and height are even or odd (see above).
	uint32 isSRGB;					// Must apply gamma correction to sRGB textures.
	vec2 texelSize;					// 1.0 / OutMip1.Dimensions
};

struct equirectangular_to_cubemap_cb
{
	uint32 cubemapSize;				// Size of the cubemap face in pixels at the current mipmap level.
	uint32 firstMip;				// The first mip level to generate.
	uint32 numMipLevelsToGenerate;	// The number of mips to generate.
	uint32 isSRGB;
};

struct textured_sky_to_irradiance_cb
{
	uint32 irradianceMapSize;
};

struct textured_sky_to_irradiance_sh_cb
{
	uint32 mipLevel;
};

struct procedural_sky_to_irradiance_cb
{
	vec3 sunDirection;
	uint32 irradianceMapSize;
};

struct textured_sky_to_prefiltered_radiance_cb
{
	uint32 cubemapSize;				// Size of the cubemap face in pixels at the current mipmap level.
	uint32 firstMip;				// The first mip level to generate.
	uint32 numMipLevelsToGenerate;	// The number of mips to generate.
	uint32 totalNumMipLevels;
};

struct integrate_brdf_cb
{
	uint32 textureDim;
};

void initializeTexturePreprocessing()
{
	mipmapPipeline = createReloadablePipeline("generate_mips_cs");
	equirectangularToCubemapPipeline = createReloadablePipeline("equirectangular_to_cubemap_cs");

	texturedSkyToIrradiancePipeline = createReloadablePipeline("textured_sky_to_irradiance_cs");
	texturedSkyToIrradianceSHPipeline = createReloadablePipeline("textured_sky_to_irradiance_sh_cs");
	texturedSkyToPrefilteredRadiancePipeline = createReloadablePipeline("textured_sky_to_prefiltered_radiance_cs");

	proceduralSkyToIrradiancePipeline = createReloadablePipeline("procedural_sky_to_irradiance_cs");
	//proceduralSkyToPrefilteredRadiancePipeline = createReloadablePipeline("procedural_sky_to_prefiltered_radiance_cs");

	integrateBRDFPipeline = createReloadablePipeline("integrate_brdf_cs");
}

void generateMipMapsOnGPU(dx_command_list* cl, ref<dx_texture>& texture)
{
	dx_resource resource = texture->resource;
	if (!resource)
	{
		return;
	}

	D3D12_RESOURCE_DESC resourceDesc = resource->GetDesc();

	uint32 numMips = resourceDesc.MipLevels;
	if (numMips == 1)
	{
		return;
	}

	if (resourceDesc.Dimension != D3D12_RESOURCE_DIMENSION_TEXTURE2D ||
		resourceDesc.DepthOrArraySize != 1 ||
		resourceDesc.SampleDesc.Count > 1)
	{
		std::cerr << "GenerateMips is only supported for non-multi-sampled 2D Textures.\n";
		return;
	}

	dx_resource uavResource = resource;
	dx_resource aliasResource; // In case the format of our texture does not support UAVs.

	if (!texture->supportsUAV)
	{
		D3D12_RESOURCE_DESC aliasDesc = resourceDesc;
		// Placed resources can't be render targets or depth-stencil views.
		aliasDesc.Flags |= D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS;
		aliasDesc.Flags &= ~(D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET | D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL);

		// Describe a UAV compatible resource that is used to perform
		// mipmapping of the original texture.
		D3D12_RESOURCE_DESC uavDesc = aliasDesc;   // The flags for the UAV description must match that of the alias description.
		uavDesc.Format = getUAVCompatibleFormat(resourceDesc.Format);

		D3D12_RESOURCE_DESC resourceDescs[] = {
			aliasDesc,
			uavDesc
		};

		// Create a heap that is large enough to store a copy of the original resource.
		D3D12_RESOURCE_ALLOCATION_INFO allocationInfo = dxContext.device->GetResourceAllocationInfo(0, arraysize(resourceDescs), resourceDescs);

		D3D12_HEAP_DESC heapDesc = {};
		heapDesc.SizeInBytes = allocationInfo.SizeInBytes;
		heapDesc.Alignment = allocationInfo.Alignment;
		heapDesc.Flags = D3D12_HEAP_FLAG_ALLOW_ONLY_NON_RT_DS_TEXTURES;
		heapDesc.Properties.CPUPageProperty = D3D12_CPU_PAGE_PROPERTY_UNKNOWN;
		heapDesc.Properties.MemoryPoolPreference = D3D12_MEMORY_POOL_UNKNOWN;
		heapDesc.Properties.Type = D3D12_HEAP_TYPE_DEFAULT;

		dx_heap heap;
		checkResult(dxContext.device->CreateHeap(&heapDesc, IID_PPV_ARGS(&heap)));
		dxContext.retire(heap);

		checkResult(dxContext.device->CreatePlacedResource(
			heap.Get(),
			0,
			&aliasDesc,
			D3D12_RESOURCE_STATE_COMMON,
			0,
			IID_PPV_ARGS(&aliasResource)
		));

		SET_NAME(aliasResource, "Alias resource for mip map generation");

		dxContext.retire(aliasResource);

		checkResult(dxContext.device->CreatePlacedResource(
			heap.Get(),
			0,
			&uavDesc,
			D3D12_RESOURCE_STATE_COMMON,
			0,
			IID_PPV_ARGS(&uavResource)
		));

		SET_NAME(uavResource, "UAV resource for mip map generation");

		dxContext.retire(uavResource);

		cl->aliasingBarrier(0, aliasResource);

		// Copy the original resource to the alias resource.
		cl->copyResource(resource, aliasResource);

		// Add an aliasing barrier for the UAV compatible resource.
		cl->aliasingBarrier(aliasResource, uavResource);
	}

	bool isSRGB = isSRGBFormat(resourceDesc.Format);
	cl->setPipelineState(*mipmapPipeline.pipeline);
	cl->setComputeRootSignature(*mipmapPipeline.rootSignature);

	mipmap_cb cb;
	cb.isSRGB = isSRGB;

	resourceDesc = uavResource->GetDesc();

	DXGI_FORMAT overrideFormat = isSRGB ? getSRGBFormat(resourceDesc.Format) : resourceDesc.Format;

	ref<dx_texture> tmpTexture = make_ref<dx_texture>();
	tmpTexture->resource = uavResource;

	uint32 numSrcMipLevels = resourceDesc.MipLevels - 1;
	uint32 numDstMipLevels = resourceDesc.MipLevels - 1;
	uint32 numDescriptors = numSrcMipLevels + numDstMipLevels;

	dx_descriptor_range descriptors = dxContext.frameDescriptorAllocator.allocateContiguousDescriptorRange(numDescriptors);

	dx_double_descriptor_handle srvOffset;
	for (uint32 i = 0; i < numSrcMipLevels; ++i)
	{
		dx_double_descriptor_handle h = descriptors.pushHandle();
		h.create2DTextureSRV(tmpTexture, { i, 1 }, overrideFormat);
		if (i == 0)
		{
			srvOffset = h;
		}
	}

	dx_double_descriptor_handle uavOffset;
	for (uint32 i = 0; i < numDstMipLevels; ++i)
	{
		uint32 mip = i + 1;
		dx_double_descriptor_handle h = descriptors.pushHandle();
		h.create2DTextureUAV(tmpTexture, mip);
		if (i == 0)
		{
			uavOffset = h;
		}
	}

	cl->setDescriptorHeap(descriptors);

	for (uint32 srcMip = 0; srcMip < resourceDesc.MipLevels - 1u; )
	{
		uint64 srcWidth = resourceDesc.Width >> srcMip;
		uint32 srcHeight = resourceDesc.Height >> srcMip;
		uint32 dstWidth = (uint32)(srcWidth >> 1);
		uint32 dstHeight = srcHeight >> 1;

		// 0b00(0): Both width and height are even.
		// 0b01(1): Width is odd, height is even.
		// 0b10(2): Width is even, height is odd.
		// 0b11(3): Both width and height are odd.
		cb.srcDimensionFlags = (srcHeight & 1) << 1 | (srcWidth & 1);

		DWORD mipCount;

		// The number of times we can half the size of the texture and get
		// exactly a 50% reduction in size.
		// A 1 bit in the width or height indicates an odd dimension.
		// The case where either the width or the height is exactly 1 is handled
		// as a special case (as the dimension does not require reduction).
		_BitScanForward(&mipCount, (dstWidth == 1 ? dstHeight : dstWidth) | (dstHeight == 1 ? dstWidth : dstHeight));

		// Maximum number of mips to generate is 4.
		mipCount = min(4, (int)mipCount + 1);
		// Clamp to total number of mips left over.
		mipCount = (srcMip + mipCount) >= resourceDesc.MipLevels ?
			resourceDesc.MipLevels - srcMip - 1 : mipCount;

		// Dimensions should not reduce to 0.
		// This can happen if the width and height are not the same.
		dstWidth = max(1u, dstWidth);
		dstHeight = max(1u, dstHeight);

		cb.srcMipLevel = srcMip;
		cb.numMipLevelsToGenerate = mipCount;
		cb.texelSize.x = 1.f / (float)dstWidth;
		cb.texelSize.y = 1.f / (float)dstHeight;

		cl->setCompute32BitConstants(0, cb);

		cl->setComputeDescriptorTable(1, CD3DX12_GPU_DESCRIPTOR_HANDLE(srvOffset.gpuHandle, srcMip, descriptors.descriptorHandleIncrementSize));
		cl->setComputeDescriptorTable(2, CD3DX12_GPU_DESCRIPTOR_HANDLE(uavOffset.gpuHandle, srcMip, descriptors.descriptorHandleIncrementSize));

		cl->dispatch(bucketize(dstWidth, 8), bucketize(dstHeight, 8));

		cl->uavBarrier(uavResource);

		srcMip += mipCount;
	}

	if (aliasResource)
	{
		cl->aliasingBarrier(uavResource, aliasResource);
		// Copy the alias resource back to the original resource.
		barrier_batcher(cl)
			.transition(aliasResource, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_COPY_SOURCE)
			.transition(resource, D3D12_RESOURCE_STATE_COPY_SOURCE, D3D12_RESOURCE_STATE_COPY_DEST);
		cl->copyResource(aliasResource, resource);
		cl->transitionBarrier(resource, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_COMMON);
	}

	cl->resetToDynamicDescriptorHeap();
}

ref<dx_texture> equirectangularToCubemap(dx_command_list* cl, const ref<dx_texture>& equirectangular, uint32 resolution, uint32 numMips, DXGI_FORMAT format)
{
	ASSERT(equirectangular->resource);

	CD3DX12_RESOURCE_DESC cubemapDesc(equirectangular->resource->GetDesc());
	cubemapDesc.Width = cubemapDesc.Height = resolution;
	cubemapDesc.DepthOrArraySize = 6;
	cubemapDesc.MipLevels = numMips;
	if (format != DXGI_FORMAT_UNKNOWN)
	{
		cubemapDesc.Format = format;
	}
	if (isUAVCompatibleFormat(cubemapDesc.Format))
	{
		cubemapDesc.Flags |= D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS;
	}

	ref<dx_texture> cubemap = createTexture(cubemapDesc, 0, 0);

	cubemapDesc = CD3DX12_RESOURCE_DESC(cubemap->resource->GetDesc());
	numMips = cubemapDesc.MipLevels;

	dx_resource cubemapResource = cubemap->resource;
	SET_NAME(cubemapResource, "Cubemap");
	dx_resource stagingResource = cubemapResource;

	ref<dx_texture> stagingTexture = make_ref<dx_texture>();
	stagingTexture->resource = cubemapResource;


	if ((cubemapDesc.Flags & D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS) == 0)
	{
		CD3DX12_RESOURCE_DESC stagingDesc = cubemapDesc;
		stagingDesc.Format = getUAVCompatibleFormat(cubemapDesc.Format);
		stagingDesc.Flags |= D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS;

		auto heapDesc = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT);
		checkResult(dxContext.device->CreateCommittedResource(
			&heapDesc,
			D3D12_HEAP_FLAG_NONE,
			&stagingDesc,
			D3D12_RESOURCE_STATE_COMMON,
			0,
			IID_PPV_ARGS(&stagingResource)
		));

		SET_NAME(stagingResource, "Staging resource for equirectangular to cubemap");

		stagingTexture->resource = stagingResource;
	}

	cl->setPipelineState(*equirectangularToCubemapPipeline.pipeline);
	cl->setComputeRootSignature(*equirectangularToCubemapPipeline.rootSignature);

	bool isSRGB = isSRGBFormat(cubemapDesc.Format);

	equirectangular_to_cubemap_cb equirectangularToCubemapCB;
	equirectangularToCubemapCB.isSRGB = isSRGB;


	dx_descriptor_range descriptors = dxContext.frameDescriptorAllocator.allocateContiguousDescriptorRange(numMips + 1);

	dx_double_descriptor_handle srvOffset = descriptors.pushHandle();
	srvOffset.create2DTextureSRV(equirectangular);

	cl->setDescriptorHeap(descriptors);
	cl->setComputeDescriptorTable(1, srvOffset);


	for (uint32 mipSlice = 0; mipSlice < numMips; )
	{
		// Maximum number of mips to generate per pass is 5.
		uint32 numMips = min(5u, cubemapDesc.MipLevels - mipSlice);

		equirectangularToCubemapCB.firstMip = mipSlice;
		equirectangularToCubemapCB.cubemapSize = max((uint32)cubemapDesc.Width, cubemapDesc.Height) >> mipSlice;
		equirectangularToCubemapCB.numMipLevelsToGenerate = numMips;

		cl->setCompute32BitConstants(0, equirectangularToCubemapCB);


		for (uint32 mip = 0; mip < numMips; ++mip)
		{
			dx_double_descriptor_handle h = descriptors.pushHandle();
			h.create2DTextureArrayUAV(stagingTexture, mipSlice + mip, getUAVCompatibleFormat(cubemapDesc.Format));
			if (mip == 0)
			{
				cl->setComputeDescriptorTable(2, h.gpuHandle);
			}
		}

		cl->dispatch(bucketize(equirectangularToCubemapCB.cubemapSize, 16), bucketize(equirectangularToCubemapCB.cubemapSize, 16), 6);

		mipSlice += numMips;
	}

	cl->uavBarrier(stagingResource);

	if (stagingResource != cubemapResource)
	{
		cl->copyResource(stagingTexture->resource, cubemap->resource);
		cl->transitionBarrier(cubemap->resource, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_COMMON);
	}

	return cubemap;
}

void texturedSkyToIrradiance(dx_command_list* cl, const ref<dx_texture>& sky, ref<dx_texture>& outIrradiance)
{
	ASSERT(sky && sky->resource);
	ASSERT(outIrradiance && outIrradiance->resource);

	ASSERT(outIrradiance->supportsUAV);
	ASSERT(outIrradiance->depth == 6);
	ASSERT(outIrradiance->width == outIrradiance->height);

	cl->setPipelineState(*texturedSkyToIrradiancePipeline.pipeline);
	cl->setComputeRootSignature(*texturedSkyToIrradiancePipeline.rootSignature);

	textured_sky_to_irradiance_cb cb;
	cb.irradianceMapSize = outIrradiance->width;

	cl->setCompute32BitConstants(0, cb);
	cl->setDescriptorHeapSRV(1, 0, sky);
	cl->setDescriptorHeapUAV(1, 1, outIrradiance);

	cl->dispatch(bucketize(cb.irradianceMapSize, 16), bucketize(cb.irradianceMapSize, 16), 6);

	cl->uavBarrier(outIrradiance);
}

void texturedSkyToPrefilteredRadiance(dx_command_list* cl, const ref<dx_texture>& sky, ref<dx_texture>& outPrefilteredRadiance)
{
	ASSERT(sky && sky->resource);
	ASSERT(outPrefilteredRadiance && outPrefilteredRadiance->resource);

	ASSERT(outPrefilteredRadiance->supportsUAV);
	ASSERT(outPrefilteredRadiance->depth == 6);
	ASSERT(outPrefilteredRadiance->width == outPrefilteredRadiance->height);

	cl->setPipelineState(*texturedSkyToPrefilteredRadiancePipeline.pipeline);
	cl->setComputeRootSignature(*texturedSkyToPrefilteredRadiancePipeline.rootSignature);

	textured_sky_to_prefiltered_radiance_cb cb;
	cb.totalNumMipLevels = outPrefilteredRadiance->numMipLevels;

	cl->setDescriptorHeapSRV(1, 0, sky);

	uint32 dimensions = outPrefilteredRadiance->width;

	for (uint32 mipSlice = 0; mipSlice < outPrefilteredRadiance->numMipLevels; )
	{
		// Maximum number of mips to generate per pass is 5.
		uint32 numMips = min(5u, outPrefilteredRadiance->numMipLevels - mipSlice);

		cb.firstMip = mipSlice;
		cb.cubemapSize = dimensions >> mipSlice;
		cb.numMipLevelsToGenerate = numMips;

		cl->setCompute32BitConstants(0, cb);

		for (uint32 mip = 0; mip < numMips; ++mip)
		{
			cl->setDescriptorHeapUAV(1, 1 + mip, outPrefilteredRadiance->uavAt(mipSlice + mip));
		}

		cl->dispatch(bucketize(cb.cubemapSize, 16), bucketize(cb.cubemapSize, 16), 6);

		mipSlice += numMips;
	}

	cl->uavBarrier(outPrefilteredRadiance);
}

void proceduralSkyToIrradiance(dx_command_list* cl, vec3 sunDirection, ref<dx_texture>& outIrradiance)
{
	ASSERT(outIrradiance && outIrradiance->resource);

	ASSERT(outIrradiance->supportsUAV);
	ASSERT(outIrradiance->depth == 6);
	ASSERT(outIrradiance->width == outIrradiance->height);

	cl->setPipelineState(*proceduralSkyToIrradiancePipeline.pipeline);
	cl->setComputeRootSignature(*proceduralSkyToIrradiancePipeline.rootSignature);

	procedural_sky_to_irradiance_cb cb;
	cb.sunDirection = -sunDirection;
	cb.irradianceMapSize = outIrradiance->width;

	cl->setCompute32BitConstants(0, cb);
	cl->setDescriptorHeapUAV(1, 0, outIrradiance);

	cl->dispatch(bucketize(cb.irradianceMapSize, 16), bucketize(cb.irradianceMapSize, 16), 6);

	cl->uavBarrier(outIrradiance);
}

#if 0
void proceduralSkyToPrefilteredRadiance(dx_command_list* cl, vec3 sunDirection, ref<dx_texture>& outPrefilteredRadiance)
{
	ASSERT(outPrefilteredRadiance && outPrefilteredRadiance->resource);

	ASSERT(outPrefilteredRadiance->supportsUAV);
	ASSERT(outPrefilteredRadiance->depth == 6);
	ASSERT(outPrefilteredRadiance->width == outPrefilteredRadiance->height);

	cl->setPipelineState(*proceduralSkyToPrefilteredRadiancePipeline.pipeline);
	cl->setComputeRootSignature(*proceduralSkyToPrefilteredRadiancePipeline.rootSignature);

	textured_sky_to_prefiltered_radiance_cb cb;
	cb.totalNumMipLevels = outPrefilteredRadiance->numMipLevels;

	uint32 dimensions = outPrefilteredRadiance->width;

	for (uint32 mipSlice = 0; mipSlice < outPrefilteredRadiance->numMipLevels; )
	{
		// Maximum number of mips to generate per pass is 5.
		uint32 numMips = min(5u, outPrefilteredRadiance->numMipLevels - mipSlice);

		cb.firstMip = mipSlice;
		cb.cubemapSize = dimensions >> mipSlice;
		cb.numMipLevelsToGenerate = numMips;

		cl->setCompute32BitConstants(0, cb);

		for (uint32 mip = 0; mip < numMips; ++mip)
		{
			cl->setDescriptorHeapUAV(1, mip, outPrefilteredRadiance->uavAt(mipSlice + mip));
		}

		cl->dispatch(bucketize(cb.cubemapSize, 16), bucketize(cb.cubemapSize, 16), 6);

		mipSlice += numMips;
	}

	cl->uavBarrier(outPrefilteredRadiance);
}
#endif

ref<dx_texture> integrateBRDF(dx_command_list* cl, uint32 resolution)
{
	CD3DX12_RESOURCE_DESC desc = CD3DX12_RESOURCE_DESC::Tex2D(
		DXGI_FORMAT_R16G16_FLOAT,
		resolution, resolution, 1, 1);

	desc.Flags = D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS;

	ref<dx_texture> brdf = createTexture(desc, 0, 0);
	desc = CD3DX12_RESOURCE_DESC(brdf->resource->GetDesc());

	// TODO: Technically R16G16 is not guaranteed to be UAV compatible.
	// If we ever run on hardware, which does not support this, we need to find a solution.
	// https://docs.microsoft.com/en-us/windows/win32/direct3d11/typed-unordered-access-view-loads

	SET_NAME(brdf->resource, "BRDF");

	cl->setPipelineState(*integrateBRDFPipeline.pipeline);
	cl->setComputeRootSignature(*integrateBRDFPipeline.rootSignature);

	integrate_brdf_cb integrateBrdfCB;
	integrateBrdfCB.textureDim = resolution;

	cl->setCompute32BitConstants(0, integrateBrdfCB);

	cl->resetToDynamicDescriptorHeap();
	cl->setDescriptorHeapUAV(1, 0, brdf);

	cl->dispatch(bucketize(resolution, 16), bucketize(resolution, 16), 1);

	cl->uavBarrier(brdf);

	return brdf;
}

void texturedSkyToIrradianceSH(dx_command_list* cl, const ref<dx_texture>& environment, ref<dx_buffer> shBuffer, uint32 shIndex)
{
	cl->setPipelineState(*texturedSkyToIrradianceSHPipeline.pipeline);
	cl->setComputeRootSignature(*texturedSkyToIrradianceSHPipeline.rootSignature);

	ASSERT(environment->width == environment->height);
	ASSERT(environment->width >= 64);
	ASSERT(environment->depth == 6);
	ASSERT(shBuffer->elementCount > shIndex);

	textured_sky_to_irradiance_sh_cb cb;
	cb.mipLevel = environment->numMipLevels == 1 ? 0 : (environment->numMipLevels - 6);

	cl->setCompute32BitConstants(0, cb);
	cl->setDescriptorHeapSRV(1, 0, environment);
	cl->setRootComputeUAV(2, shBuffer->gpuVirtualAddress + sizeof(spherical_harmonics) * shIndex);

	cl->dispatch(1, 1);
	cl->uavBarrier(shBuffer);
}

ref<dx_buffer> texturedSkyToIrradianceSH(dx_command_list* cl, const ref<dx_texture>& environment)
{
	ref<dx_buffer> buffer = createBuffer(sizeof(spherical_harmonics), 1, 0, true);
	texturedSkyToIrradianceSH(cl, environment, buffer, 0);
	return buffer;
}


```

`src/rendering/texture_preprocessing.h`:

```h
#pragma once

#include "dx/dx.h"
#include "light_source.h"

struct dx_command_list;
struct dx_texture;
struct dx_buffer;

void initializeTexturePreprocessing();

void generateMipMapsOnGPU(dx_command_list* cl, ref<dx_texture>& texture);
ref<dx_texture> equirectangularToCubemap(dx_command_list* cl, const ref<dx_texture>& equirectangular, uint32 resolution, uint32 numMips = 0, DXGI_FORMAT format = DXGI_FORMAT_UNKNOWN);

void texturedSkyToIrradiance(dx_command_list* cl, const ref<dx_texture>& sky, ref<dx_texture>& outIrradiance);
void texturedSkyToPrefilteredRadiance(dx_command_list* cl, const ref<dx_texture>& sky, ref<dx_texture>& outPrefilteredRadiance);

void proceduralSkyToIrradiance(dx_command_list* cl, vec3 sunDirection, ref<dx_texture>& outIrradiance);
//void proceduralSkyToPrefilteredRadiance(dx_command_list* cl, vec3 sunDirection, ref<dx_texture>& outPrefilteredRadiance);

ref<dx_texture> integrateBRDF(dx_command_list* cl, uint32 resolution = 512);

void texturedSkyToIrradianceSH(dx_command_list* cl, const ref<dx_texture>& environment, ref<dx_buffer> shBuffer, uint32 shIndex);
ref<dx_buffer> texturedSkyToIrradianceSH(dx_command_list* cl, const ref<dx_texture>& environment); // Creates buffer with one spherical harmonics set.

```

`src/scene/components.h`:

```h
#pragma once

#include "core/math.h"
#include "core/reflect.h"

struct tag_component
{
	char name[16];

	tag_component() {}

	tag_component(const char* n)
	{
		strncpy(name, n, sizeof(name));
		name[sizeof(name) - 1] = 0;
	}
};
REFLECT_STRUCT(tag_component,
	(name, "Name")
);

struct transform_component : trs
{
	transform_component() {}
	transform_component(const trs& t) : trs(t) {}
	transform_component(vec3 position, quat rotation, vec3 scale = vec3(1.f, 1.f, 1.f)) : trs(position, rotation, scale) {}
	transform_component& operator=(const trs& t) { trs::operator=(t); return *this; }
};
REFLECT_STRUCT(transform_component,
	(position, "Position"),
	(rotation, "Rotation"),
	(scale, "Scale")
);

struct dynamic_transform_component : trs
{
	dynamic_transform_component() {}
	dynamic_transform_component(const trs& t) : trs(t) {}
	dynamic_transform_component(vec3 position, quat rotation, vec3 scale = vec3(1.f, 1.f, 1.f)) : trs(position, rotation, scale) {}
	dynamic_transform_component& operator=(const trs& t) { trs::operator=(t); return *this; }
};

struct position_component
{
	vec3 position;
};
REFLECT_STRUCT(position_component,
	(position, "Position")
);

struct position_rotation_component
{
	vec3 position;
	quat rotation;
};
REFLECT_STRUCT(position_rotation_component,
	(position, "Position"),
	(rotation, "Rotation")
);

struct position_scale_component
{
	vec3 position;
	vec3 scale;
};
REFLECT_STRUCT(position_scale_component,
	(position, "Position"),
	(scale, "Scale")
);


template <typename... component_t>
struct component_group_t {};

template<typename... Type>
inline constexpr component_group_t<Type...> component_group{};

```

`src/scene/scene.cpp`:

```cpp
#include "pch.h"
#include "scene.h"
#include "physics/physics.h"
#include "physics/collision_broad.h"
#include "terrain/heightmap_collider.h"
#include "rendering/raytracing.h"


game_scene::game_scene()
{
	// Construct groups early. Ignore the return types.
	(void)registry.group<collider_component, sap_endpoint_indirection_component>(); // Colliders and SAP endpoints are always sorted in the same order.
	(void)registry.group<transform_component, dynamic_transform_component, rigid_body_component, physics_transform0_component, physics_transform1_component>();
	(void)registry.group<transform_component, rigid_body_component, physics_transform0_component, physics_transform1_component>();

#ifndef PHYSICS_ONLY
	(void)registry.group<position_component, point_light_component>();
	(void)registry.group<position_rotation_component, spot_light_component>();
#endif
}

void game_scene::clearAll()
{
	void clearBroadphase(game_scene & scene);
	clearBroadphase(*this);

	deleteAllConstraints(*this);
	registry.clear();
}

void game_scene::cloneTo(game_scene& target)
{
	target.registry.assign(registry.data(), registry.data() + registry.size(), registry.released());


	using copy_components = component_group_t<
		tag_component,
		transform_component,
		position_component,
		position_rotation_component,
		position_scale_component,
		dynamic_transform_component,

#ifndef PHYSICS_ONLY
		point_light_component,
		spot_light_component,
		cloth_render_component,

		terrain_component,
		grass_component,
		proc_placement_component,
		water_component,
		tree_component,
#endif
		heightmap_collider_component,

		mesh_component,

		raytrace_component,

		animation_component,

		collider_component,
		rigid_body_component,
		force_field_component,
		trigger_component,
		cloth_component,
		physics_reference_component,
		sap_endpoint_indirection_component,
		constraint_entity_reference_component,

		physics_transform0_component,
		physics_transform1_component,

		distance_constraint,
		ball_constraint,
		fixed_constraint,
		hinge_constraint,
		cone_twist_constraint,
		slider_constraint
	>;

	copyComponentPoolsTo(copy_components{}, target);

	target.registry.ctx() = registry.ctx();
}

scene_entity game_scene::copyEntity(scene_entity src)
{
	ASSERT(src.hasComponent<tag_component>());

	tag_component& tag = src.getComponent<tag_component>();
	scene_entity dest = createEntity(tag.name);

	if (auto* c = src.getComponentIfExists<transform_component>()) { dest.addComponent<transform_component>(*c); }
	if (auto* c = src.getComponentIfExists<position_component>()) { dest.addComponent<position_component>(*c); }
	if (auto* c = src.getComponentIfExists<position_rotation_component>()) { dest.addComponent<position_rotation_component>(*c); }
	if (auto* c = src.getComponentIfExists<dynamic_transform_component>()) { dest.addComponent<dynamic_transform_component>(*c); }

#ifndef PHYSICS_ONLY
	if (auto* c = src.getComponentIfExists<point_light_component>()) { dest.addComponent<point_light_component>(*c); }
	if (auto* c = src.getComponentIfExists<spot_light_component>()) { dest.addComponent<spot_light_component>(*c); }
	if (auto* c = src.getComponentIfExists<cloth_render_component>()) { dest.addComponent<cloth_render_component>(*c); }

	if (auto* c = src.getComponentIfExists<terrain_component>()) { dest.addComponent<terrain_component>(*c); }
#endif

	if (auto* c = src.getComponentIfExists<animation_component>()) { dest.addComponent<animation_component>(*c); }
	if (auto* c = src.getComponentIfExists<mesh_component>()) { dest.addComponent<mesh_component>(*c); }
	if (auto* c = src.getComponentIfExists<raytrace_component>()) { dest.addComponent<raytrace_component>(*c); }

	for (collider_component& collider : collider_component_iterator(src))
	{
		dest.addComponent<collider_component>(collider);
	}

	if (auto* c = src.getComponentIfExists<rigid_body_component>()) { dest.addComponent<rigid_body_component>(*c); }
	if (auto* c = src.getComponentIfExists<force_field_component>()) { dest.addComponent<force_field_component>(*c); }
	if (auto* c = src.getComponentIfExists<trigger_component>()) { dest.addComponent<trigger_component>(*c); }
	if (auto* c = src.getComponentIfExists<cloth_component>()) { dest.addComponent<cloth_component>(*c); }

	// We don't copy physics constraints (because I cannot think of a good way to do this).

	return dest;
}

void game_scene::deleteEntity(scene_entity e)
{
	void removeColliderFromBroadphase(scene_entity entity);

	if (physics_reference_component* reference = e.getComponentIfExists<physics_reference_component>())
	{
		scene_entity colliderEntity = { reference->firstColliderEntity, &registry };
		while (colliderEntity)
		{
			collider_component& collider = colliderEntity.getComponent<collider_component>();
			entity_handle next = collider.nextEntity;

			removeColliderFromBroadphase(colliderEntity);
		
			registry.destroy(colliderEntity.handle);
		
			colliderEntity = { next, &registry };
		}

		deleteAllConstraintsFromEntity(e);
	}

	registry.destroy(e.handle);
}

```

`src/scene/scene.h`:

```h
#pragma once

#define ENTT_ASSERT(condition, ...) ASSERT(condition)

#include <entt/entity/entity.hpp>
#include <entt/entity/registry.hpp>
#include <entt/entity/helper.hpp>
#include "components.h"
#ifndef PHYSICS_ONLY
#include "rendering/light_source.h"
#include "rendering/pbr.h"
#include "rendering/pbr_environment.h"
#include "core/camera.h"
#include "terrain/terrain.h"
#include "terrain/proc_placement.h"
#include "terrain/grass.h"
#include "terrain/water.h"
#include "terrain/tree.h"
#endif

struct game_scene;

using entity_handle = entt::entity;
static const auto null_entity = entt::null;

struct scene_entity
{
	scene_entity() = default;
	inline scene_entity(entity_handle handle, game_scene& scene);
	inline scene_entity(uint32 id, game_scene& scene);
	scene_entity(entity_handle handle, entt::registry* registry) : handle(handle), registry(registry) {}
	scene_entity(uint32 id, entt::registry* reg) : handle((entity_handle)id), registry(reg) {}
	scene_entity(const scene_entity&) = default;

	template <typename component_t, typename... args>
	scene_entity& addComponent(args&&... a)
	{
		if constexpr (std::is_same_v<component_t, struct collider_component>)
		{
			void addColliderToBroadphase(scene_entity entity);

			if (!hasComponent<struct physics_reference_component>())
			{
				addComponent<struct physics_reference_component>();
			}

			struct physics_reference_component& reference = getComponent<struct physics_reference_component>();
			++reference.numColliders;

			entity_handle child = registry->create();
			struct collider_component& collider = registry->emplace<struct collider_component>(child, std::forward<args>(a)...);
			addColliderToBroadphase(scene_entity(child, registry));

			collider.parentEntity = handle;
			collider.nextEntity = reference.firstColliderEntity;
			reference.firstColliderEntity = child;


			if (struct rigid_body_component* rb = getComponentIfExists<struct rigid_body_component>())
			{
				rb->recalculateProperties(registry, reference);
			}
		}
		else
		{
			auto& component = registry->emplace_or_replace<component_t>(handle, std::forward<args>(a)...);

			// If component is rigid body, calculate properties.
			if constexpr (std::is_same_v<component_t, struct rigid_body_component>)
			{
				if (struct physics_reference_component* ref = getComponentIfExists<struct physics_reference_component>())
				{
					component.recalculateProperties(registry, *ref);
				}
				if (!hasComponent<dynamic_transform_component>())
				{
					addComponent<dynamic_transform_component>();
				}
				if (auto* transform = getComponentIfExists<transform_component>())
				{
					addComponent<struct physics_transform0_component>(*transform);
					addComponent<struct physics_transform1_component>(*transform);
				}
			}


			// If component is cloth, transform to correct position.
			if constexpr (std::is_same_v<component_t, struct cloth_component>)
			{
				if (transform_component* transform = getComponentIfExists<transform_component>())
				{
					component.setWorldPositionOfFixedVertices(*transform, true);
				}
			}

			if constexpr (std::is_same_v<component_t, struct transform_component>)
			{
				if (struct cloth_component* cloth = getComponentIfExists<struct cloth_component>())
				{
					cloth->setWorldPositionOfFixedVertices(component, true);
				}

				if (hasComponent<struct rigid_body_component>())
				{
					addComponent<struct physics_transform0_component>(component);
					addComponent<struct physics_transform1_component>(component);
				}
			}
		}

		return *this;
	}

	template <typename component_t>
	bool hasComponent()
	{
		return registry->any_of<component_t>(handle);
	}

	template <typename component_t>
	component_t& getComponent()
	{
		return registry->get<component_t>(handle);
	}

	template <typename component_t>
	const component_t& getComponent() const
	{
		return registry->get<component_t>(handle);
	}

	template <typename component_t>
	component_t* getComponentIfExists()
	{
		return registry->try_get<component_t>(handle);
	}

	template <typename component_t>
	const component_t* getComponentIfExists() const
	{
		return registry->try_get<component_t>(handle);
	}

	template <typename component_t>
	uint32 getComponentIndex() const
	{
		auto& s = registry->storage<component_t>();
		return (uint32)s.index(handle);
	}

	template <typename component_t>
	void removeComponent()
	{
		registry->remove<component_t>(handle);
	}

	inline operator uint32() const
	{
		return (uint32)handle;
	}

	inline operator bool() const
	{
		return handle != entt::null;
	}

	inline bool valid() const
	{
		return registry->valid(handle);
	}

	inline bool operator==(const scene_entity& o) const
	{
		return handle == o.handle && registry == o.registry;
	}

	inline bool operator!=(const scene_entity& o) const
	{
		return !(*this == o);
	}

	inline bool operator==(entity_handle o) const
	{
		return handle == o;
	}

	entity_handle handle = entt::null;
	entt::registry* registry;
};

template <typename context_t, typename... args>
inline context_t& createOrGetContextVariable(entt::registry& registry, args&&... a)
{
	auto& c = registry.ctx();
	context_t* context = c.find<context_t>();
	if (!context)
	{
		context = &c.emplace<context_t>(std::forward<args>(a)...);
	}
	return *context;
}

template <typename context_t>
inline context_t& getContextVariable(entt::registry& registry)
{
	auto& c = registry.ctx();
	return *c.find<context_t>();
}

template <typename context_t>
inline context_t* tryGetContextVariable(entt::registry& registry)
{
	auto& c = registry.ctx();
	return c.find<context_t>();
}

template <typename context_t>
inline bool doesContextVariableExist(entt::registry& registry)
{
	auto& c = registry.ctx();
	return c.contains<context_t>();
}

template <typename context_t>
inline void deleteContextVariable(entt::registry& registry)
{
	auto& c = registry.ctx();
	c.erase<context_t>();
}

struct game_scene
{
	game_scene();

	scene_entity createEntity(const char* name)
	{
		return scene_entity(registry.create(), &registry)
			.addComponent<tag_component>(name);
	}

	scene_entity tryCreateEntityInPlace(scene_entity place, const char* name)
	{
		return scene_entity(registry.create(place.handle), &registry)
			.addComponent<tag_component>(name);
	}

	scene_entity copyEntity(scene_entity src); // Source can be either from the same scene or from another.

	void deleteEntity(scene_entity e);
	void clearAll();

	template <typename component_t>
	void deleteAllComponents()
	{
		registry.clear<component_t>();
	}

	bool isEntityValid(scene_entity e)
	{
		return &registry == e.registry && registry.valid(e.handle);
	}

	template <typename component_t>
	scene_entity getEntityFromComponent(const component_t& c)
	{
		entity_handle e = entt::to_entity(registry, c);
		return { e, &registry };
	}

	template <typename component_t>
	void copyComponentIfExists(scene_entity src, scene_entity dst)
	{
		if (component_t* comp = src.getComponentIfExists<component_t>())
		{
			dst.addComponent<component_t>(*comp);
		}
	}

	template <typename first_component_t, typename... tail_component_t>
	void copyComponentsIfExists(scene_entity src, scene_entity dst)
	{
		copyComponentIfExists<first_component_t>(src, dst);
		if constexpr (sizeof...(tail_component_t) > 0)
		{
			copyComponentsIfExists<tail_component_t...>(src, dst);
		}
	}

	template <typename... component_t>
	auto view() 
	{ 
		return registry.view<component_t...>(); 
	}

	template<typename... owned_component_t, typename... non_owned_component_t, typename... excluded_components>
	auto group(component_group_t<non_owned_component_t...> = {}, component_group_t<excluded_components...> = {})
	{
		return registry.group<owned_component_t...>(entt::get<non_owned_component_t...>, entt::exclude<excluded_components...>);
	}

	template <typename component_t>
	auto raw()
	{
		auto& s = registry.storage<component_t>();
		component_t** r = s.raw();
		return r ? *r : 0;
	}

	template <typename func_t>
	void forEachEntity(func_t func)
	{
		registry.each(func);
	}

	template <typename component_t>
	uint32 numberOfComponentsOfType()
	{
		auto v = view<component_t>();
		return (uint32)v.size();
	}

	template <typename component_t>
	component_t& getComponentAtIndex(uint32 index)
	{
		auto& s = registry.storage<component_t>();
		return s.element_at(index);
	}

	template <typename component_t>
	scene_entity getEntityFromComponentAtIndex(uint32 index)
	{
		return getEntityFromComponent(getComponentAtIndex<component_t>(index));
	}

	template <typename context_t, typename... args>
	context_t& createOrGetContextVariable(args&&... a)
	{
		return ::createOrGetContextVariable<context_t, args...>(registry, std::forward<args>(a)...);
	}

	template <typename context_t>
	context_t& getContextVariable()
	{
		return ::getContextVariable<context_t>(registry);
	}

	template <typename context_t>
	bool doesContextVariableExist()
	{
		return ::doesContextVariableExist<context_t>(registry);
	}

	template <typename context_t>
	void deleteContextVariable()
	{
		return ::deleteContextVariable<context_t>(registry);
	}

	void cloneTo(game_scene& target);

	entt::registry registry;


private:

	template <typename component_t>
	void copyComponentPoolTo(game_scene& target)
	{
		auto v = view<component_t>();
		auto& s = registry.storage<component_t>();
		target.registry.insert<component_t>(v.begin(), v.end(), s.cbegin());
	}

	template <typename... component_t>
	void copyComponentPoolsTo(game_scene& target)
	{
		(copyComponentPoolTo<component_t>(target), ...);
	}

	template <typename... component_t>
	void copyComponentPoolsTo(component_group_t<component_t...>, game_scene& target)
	{
		(copyComponentPoolTo<component_t>(target), ...);
	}
};

inline scene_entity::scene_entity(entity_handle handle, game_scene& scene) : handle(handle), registry(&scene.registry) {}
inline scene_entity::scene_entity(uint32 id, game_scene& scene) : handle((entity_handle)id), registry(&scene.registry) {}



enum scene_mode
{
	scene_mode_editor,
	scene_mode_runtime_playing,
	scene_mode_runtime_paused,
};

struct editor_scene
{
	game_scene& getCurrentScene()
	{
		return (mode == scene_mode_editor) ? editorScene : runtimeScene;
	}

	float getTimestepScale()
	{
		return (mode == scene_mode_editor || mode == scene_mode_runtime_paused) ? 0.f : timestepScale;
	}

	void play()
	{
		if (mode == scene_mode_editor)
		{
			runtimeScene = game_scene();
			editorScene.cloneTo(runtimeScene);
		}
		mode = scene_mode_runtime_playing;
	}

	void pause()
	{
		if (mode == scene_mode_runtime_playing)
		{
			mode = scene_mode_runtime_paused;
		}
	}

	void stop()
	{
		mode = scene_mode_editor;
	}

	bool isPlayable()
	{
		return mode == scene_mode_editor || mode == scene_mode_runtime_paused;
	}

	bool isPausable()
	{
		return mode == scene_mode_runtime_playing;
	}

	bool isStoppable()
	{
		return mode == scene_mode_runtime_playing || mode == scene_mode_runtime_paused;
	}

	game_scene editorScene;
	game_scene runtimeScene;

	scene_mode mode = scene_mode_editor;
	float timestepScale = 1.f;

#ifndef PHYSICS_ONLY
	render_camera camera;
	directional_light sun;
	pbr_environment environment;
#endif

	fs::path savePath;

};


```

`src/scene/scene_rendering.cpp`:

```cpp
#include "pch.h"

#include "scene_rendering.h"

#include "rendering/pbr.h"
#include "rendering/depth_prepass.h"
#include "rendering/outline.h"
#include "rendering/shadow_map.h"

#include "geometry/mesh.h"

#include "dx/dx_context.h"

#include "physics/cloth.h"

#include "core/cpu_profiling.h"


struct offset_count
{
	uint32 offset;
	uint32 count;
};

enum light_frustum_type
{
	light_frustum_standard,
	light_frustum_sphere,
};

struct light_frustum
{
	union
	{
		camera_frustum_planes frustum;
		bounding_sphere sphere;
	};

	light_frustum_type type;
};

struct shadow_pass
{
	light_frustum frustum;
	shadow_render_pass_base* pass;
	bool isPointLight;
};

struct shadow_passes
{
	shadow_pass* shadowRenderPasses;
	uint32 numShadowRenderPasses;
};


static bool shouldRender(bounding_sphere s, bounding_box aabb, const trs& transform)
{
	s.center = conjugate(transform.rotation) * (s.center - transform.position) + transform.position;
	aabb.minCorner *= transform.scale;
	aabb.maxCorner *= transform.scale;
	return aabb.contains(s.center) || sphereVsAABB(s, aabb);
}

static bool shouldRender(const camera_frustum_planes& frustum, const mesh_component& mesh, const transform_component& transform)
{
	return mesh.mesh && (mesh.mesh->loadState.load() == asset_loaded) && ((mesh.mesh->aabb.maxCorner.x == mesh.mesh->aabb.minCorner.x) || !frustum.cullModelSpaceAABB(mesh.mesh->aabb, transform));
}

static bool shouldRender(const bounding_sphere& frustum, const mesh_component& mesh, const transform_component& transform)
{
	return mesh.mesh && (mesh.mesh->loadState.load() == asset_loaded) && ((mesh.mesh->aabb.maxCorner.x == mesh.mesh->aabb.minCorner.x) || shouldRender(frustum, mesh.mesh->aabb, transform));
}

static bool shouldRender(const light_frustum& frustum, const mesh_component& mesh, const transform_component& transform)
{
	return (frustum.type == light_frustum_standard) ? shouldRender(frustum.frustum, mesh, transform) : shouldRender(frustum.sphere, mesh, transform);
}

template <typename group_t>
std::unordered_map<multi_mesh*, offset_count> getOffsetsPerMesh(group_t group)
{
	uint32 groupSize = (uint32)group.size();

	std::unordered_map<multi_mesh*, offset_count> ocPerMesh;

	uint32 index = 0;
	for (entity_handle entityHandle : group)
	{
		mesh_component& mesh = group.get<mesh_component>(entityHandle);
		++ocPerMesh[mesh.mesh.get()].count;
	}

	uint32 offset = 0;
	for (auto& [mesh, oc] : ocPerMesh)
	{
		oc.offset = offset;
		offset += oc.count;
		oc.count = 0;
	}

	ocPerMesh.erase(nullptr);

	return ocPerMesh;
}

static void addToRenderPass(pbr_material_shader shader, const pbr_render_data& data, const depth_prepass_data& depthPrepassData,
	opaque_render_pass* opaqueRenderPass, transparent_render_pass* transparentRenderPass)
{
	switch (shader)
	{
		case pbr_material_shader_default:
		case pbr_material_shader_double_sided:
		{
			if (shader == pbr_material_shader_default)
			{
				opaqueRenderPass->renderObject<pbr_pipeline::opaque>(data);
				opaqueRenderPass->renderDepthOnly<depth_prepass_pipeline::single_sided>(depthPrepassData);
			}
			else
			{
				opaqueRenderPass->renderObject<pbr_pipeline::opaque_double_sided>(data);
				opaqueRenderPass->renderDepthOnly<depth_prepass_pipeline::double_sided>(depthPrepassData);
			}
		} break;
		case pbr_material_shader_alpha_cutout:
		{
			opaqueRenderPass->renderObject<pbr_pipeline::opaque_double_sided>(data);
			opaqueRenderPass->renderDepthOnly<depth_prepass_pipeline::alpha_cutout>(depthPrepassData);
		} break;
		case pbr_material_shader_transparent:
		{
			transparentRenderPass->renderObject<pbr_pipeline::transparent>(data);
		} break;
	}
}

static void addToStaticRenderPass(pbr_material_shader shader, const shadow_render_data& shadowData, shadow_render_pass_base* shadowRenderPass, bool isPointLight)
{
	switch (shader)
	{
		case pbr_material_shader_default:
		{
			if (isPointLight)
			{
				shadowRenderPass->renderStaticObject<point_shadow_pipeline::single_sided>(shadowData);
			}
			else
			{
				shadowRenderPass->renderStaticObject<shadow_pipeline::single_sided>(shadowData);
			}
		} break;
		case pbr_material_shader_double_sided:
		case pbr_material_shader_alpha_cutout:
		{
			if (isPointLight)
			{
				shadowRenderPass->renderStaticObject<point_shadow_pipeline::double_sided>(shadowData);
			}
			else
			{
				shadowRenderPass->renderStaticObject<shadow_pipeline::double_sided>(shadowData);
			}
		} break;
		case pbr_material_shader_transparent:
		{
			// Do nothing.
		} break;
	}
}

static void addToDynamicRenderPass(pbr_material_shader shader, const shadow_render_data& shadowData, shadow_render_pass_base* shadowRenderPass, bool isPointLight)
{
	switch (shader)
	{
		case pbr_material_shader_default:
		{
			if (isPointLight)
			{
				shadowRenderPass->renderDynamicObject<point_shadow_pipeline::single_sided>(shadowData);
			}
			else
			{
				shadowRenderPass->renderDynamicObject<shadow_pipeline::single_sided>(shadowData);
			}
		} break;
		case pbr_material_shader_double_sided:
		case pbr_material_shader_alpha_cutout:
		{
			if (isPointLight)
			{
				shadowRenderPass->renderDynamicObject<point_shadow_pipeline::double_sided>(shadowData);
			}
			else
			{
				shadowRenderPass->renderDynamicObject<shadow_pipeline::double_sided>(shadowData);
			}
		} break;
		case pbr_material_shader_transparent:
		{
			// Do nothing.
		} break;
	}
}


template <typename group_t>
static void renderStaticObjectsToMainCamera(group_t group, std::unordered_map<multi_mesh*, offset_count> ocPerMesh,
	const camera_frustum_planes& frustum, memory_arena& arena, entity_handle selectedObjectID,
	opaque_render_pass* opaqueRenderPass, transparent_render_pass* transparentRenderPass, ldr_render_pass* ldrRenderPass)
{
	uint32 groupSize = (uint32)group.size();

	dx_allocation transformAllocation = dxContext.allocateDynamicBuffer(groupSize * sizeof(mat4), 4);
	mat4* transforms = (mat4*)transformAllocation.cpuPtr;

	dx_allocation objectIDAllocation = dxContext.allocateDynamicBuffer(groupSize * sizeof(uint32), 4);
	uint32* objectIDs = (uint32*)objectIDAllocation.cpuPtr;

	for (auto [entityHandle, transform, mesh] : group.each())
	{
		if (!shouldRender(frustum, mesh, transform))
		{
			continue;
		}

		const dx_mesh& dxMesh = mesh.mesh->mesh;

		offset_count& oc = ocPerMesh.at(mesh.mesh.get());

		uint32 index = oc.offset + oc.count;
		transforms[index] = trsToMat4(transform);
		objectIDs[index] = (uint32)entityHandle;

		++oc.count;


		if (entityHandle == selectedObjectID)
		{
			for (auto& sm : mesh.mesh->submeshes)
			{
				renderOutline(ldrRenderPass, transforms[index], dxMesh.vertexBuffer, dxMesh.indexBuffer, sm.info);
			}
		}
	}


	D3D12_GPU_VIRTUAL_ADDRESS transformsAddress = transformAllocation.gpuPtr;
	D3D12_GPU_VIRTUAL_ADDRESS objectIDAddress = objectIDAllocation.gpuPtr;

	uint32 numDrawCalls = 0;

	for (auto& [mesh, oc] : ocPerMesh)
	{
		if (oc.count == 0)
		{
			continue;
		}

		D3D12_GPU_VIRTUAL_ADDRESS baseM = transformsAddress + (oc.offset * sizeof(mat4));
		D3D12_GPU_VIRTUAL_ADDRESS baseObjectID = objectIDAddress + (oc.offset * sizeof(uint32));

		const dx_mesh& dxMesh = mesh->mesh;

		pbr_render_data data;
		data.transformPtr = baseM;
		data.vertexBuffer = dxMesh.vertexBuffer;
		data.indexBuffer = dxMesh.indexBuffer;
		data.numInstances = oc.count;

		depth_prepass_data depthPrepassData;
		depthPrepassData.transformPtr = baseM;
		depthPrepassData.prevFrameTransformPtr = baseM;
		depthPrepassData.objectIDPtr = baseObjectID;
		depthPrepassData.vertexBuffer = dxMesh.vertexBuffer;
		depthPrepassData.prevFrameVertexBuffer = dxMesh.vertexBuffer.positions;
		depthPrepassData.indexBuffer = dxMesh.indexBuffer;
		depthPrepassData.numInstances = oc.count;

		for (auto& sm : mesh->submeshes)
		{
			data.submesh = sm.info;
			data.material = sm.material;

			depthPrepassData.submesh = data.submesh;
			depthPrepassData.alphaCutoutTextureSRV = (sm.material && sm.material->albedo) ? sm.material->albedo->defaultSRV : dx_cpu_descriptor_handle{};

			addToRenderPass(sm.material->shader, data, depthPrepassData, opaqueRenderPass, transparentRenderPass);

			++numDrawCalls;
		}
	}

	CPU_PROFILE_STAT("Static draw calls", numDrawCalls);
}

template <typename group_t>
static void renderStaticObjectsToShadowMap(group_t group, std::unordered_map<multi_mesh*, offset_count> ocPerMesh, 
	const light_frustum& frustum, memory_arena& arena, shadow_render_pass_base* shadowRenderPass)
{
	uint32 groupSize = (uint32)group.size();

	dx_allocation transformAllocation = dxContext.allocateDynamicBuffer(groupSize * sizeof(mat4), 4);
	mat4* transforms = (mat4*)transformAllocation.cpuPtr;

	for (auto [entityHandle, transform, mesh] : group.each())
	{
		if (!shouldRender(frustum, mesh, transform))
		{
			continue;
		}

		const dx_mesh& dxMesh = mesh.mesh->mesh;

		offset_count& oc = ocPerMesh.at(mesh.mesh.get());

		uint32 index = oc.offset + oc.count;
		transforms[index] = trsToMat4(transform);

		++oc.count;
	}


	D3D12_GPU_VIRTUAL_ADDRESS transformsAddress = transformAllocation.gpuPtr;

	for (auto& [mesh, oc] : ocPerMesh)
	{
		if (oc.count == 0)
		{
			continue;
		}

		D3D12_GPU_VIRTUAL_ADDRESS baseM = transformsAddress + (oc.offset * sizeof(mat4));

		const dx_mesh& dxMesh = mesh->mesh;

		shadow_render_data data;
		data.transformPtr = baseM;
		data.vertexBuffer = dxMesh.vertexBuffer.positions;
		data.indexBuffer = dxMesh.indexBuffer;
		data.numInstances = oc.count;

		for (auto& sm : mesh->submeshes)
		{
			data.submesh = sm.info;
			addToStaticRenderPass(sm.material->shader, data, shadowRenderPass, frustum.type == light_frustum_sphere);
		}
	}
}

static void renderStaticObjects(game_scene& scene, const camera_frustum_planes& frustum, memory_arena& arena, entity_handle selectedObjectID,
	opaque_render_pass* opaqueRenderPass, transparent_render_pass* transparentRenderPass, ldr_render_pass* ldrRenderPass, shadow_passes& shadow)
{
	CPU_PROFILE_BLOCK("Static objects");

	using specialized_components = component_group_t<
		animation_component,
		dynamic_transform_component,
		tree_component
	>;

	auto group = scene.group(
		component_group<transform_component, mesh_component>,
		specialized_components{});

	std::unordered_map<multi_mesh*, offset_count> ocPerMesh = getOffsetsPerMesh(group);
	

	renderStaticObjectsToMainCamera(group, ocPerMesh, frustum, arena, selectedObjectID, opaqueRenderPass, transparentRenderPass, ldrRenderPass);

	for (uint32 i = 0; i < shadow.numShadowRenderPasses; ++i)
	{
		auto& pass = shadow.shadowRenderPasses[i];
		renderStaticObjectsToShadowMap(group, ocPerMesh, pass.frustum, arena, pass.pass);
	}
}




template <typename group_t>
static void renderDynamicObjectsToMainCamera(group_t group, std::unordered_map<multi_mesh*, offset_count> ocPerMesh,
	const camera_frustum_planes& frustum, memory_arena& arena, entity_handle selectedObjectID,
	opaque_render_pass* opaqueRenderPass, transparent_render_pass* transparentRenderPass, ldr_render_pass* ldrRenderPass)
{
	uint32 groupSize = (uint32)group.size();

	dx_allocation transformAllocation = dxContext.allocateDynamicBuffer(groupSize * sizeof(mat4) * 2, 4);
	mat4* transforms = (mat4*)transformAllocation.cpuPtr;
	mat4* prevFrameTransforms = transforms + groupSize;

	dx_allocation objectIDAllocation = dxContext.allocateDynamicBuffer(groupSize * sizeof(uint32), 4);
	uint32* objectIDs = (uint32*)objectIDAllocation.cpuPtr;

	for (auto [entityHandle, transform, dynamicTransform, mesh] : group.each())
	{
		if (!shouldRender(frustum, mesh, transform))
		{
			continue;
		}

		const dx_mesh& dxMesh = mesh.mesh->mesh;

		offset_count& oc = ocPerMesh.at(mesh.mesh.get());

		uint32 index = oc.offset + oc.count;
		transforms[index] = trsToMat4(transform);
		prevFrameTransforms[index] = trsToMat4(dynamicTransform);
		objectIDs[index] = (uint32)entityHandle;

		++oc.count;


		if (entityHandle == selectedObjectID)
		{
			for (auto& sm : mesh.mesh->submeshes)
			{
				renderOutline(ldrRenderPass, transforms[index], dxMesh.vertexBuffer, dxMesh.indexBuffer, sm.info);
			}
		}
	}


	D3D12_GPU_VIRTUAL_ADDRESS transformsAddress = transformAllocation.gpuPtr;
	D3D12_GPU_VIRTUAL_ADDRESS prevFrameTransformsAddress = transformAllocation.gpuPtr + (groupSize * sizeof(mat4));
	D3D12_GPU_VIRTUAL_ADDRESS objectIDAddress = objectIDAllocation.gpuPtr;

	uint32 numDrawCalls = 0;

	for (auto& [mesh, oc] : ocPerMesh)
	{
		if (oc.count == 0)
		{
			continue;
		}

		D3D12_GPU_VIRTUAL_ADDRESS baseM = transformsAddress + (oc.offset * sizeof(mat4));
		D3D12_GPU_VIRTUAL_ADDRESS prevBaseM = prevFrameTransformsAddress + (oc.offset * sizeof(mat4));
		D3D12_GPU_VIRTUAL_ADDRESS baseObjectID = objectIDAddress + (oc.offset * sizeof(uint32));

		const dx_mesh& dxMesh = mesh->mesh;

		pbr_render_data data;
		data.transformPtr = baseM;
		data.vertexBuffer = dxMesh.vertexBuffer;
		data.indexBuffer = dxMesh.indexBuffer;
		data.numInstances = oc.count;

		depth_prepass_data depthPrepassData;
		depthPrepassData.transformPtr = baseM;
		depthPrepassData.prevFrameTransformPtr = prevBaseM;
		depthPrepassData.objectIDPtr = baseObjectID;
		depthPrepassData.vertexBuffer = dxMesh.vertexBuffer;
		depthPrepassData.prevFrameVertexBuffer = dxMesh.vertexBuffer.positions;
		depthPrepassData.indexBuffer = dxMesh.indexBuffer;
		depthPrepassData.numInstances = oc.count;

		for (auto& sm : mesh->submeshes)
		{
			data.submesh = sm.info;
			data.material = sm.material;

			depthPrepassData.submesh = data.submesh;
			depthPrepassData.alphaCutoutTextureSRV = (sm.material && sm.material->albedo) ? sm.material->albedo->defaultSRV : dx_cpu_descriptor_handle{};

			addToRenderPass(sm.material->shader, data, depthPrepassData, opaqueRenderPass, transparentRenderPass);

			++numDrawCalls;
		}
	}

	CPU_PROFILE_STAT("Dynamic draw calls", numDrawCalls);
}

template <typename group_t>
static void renderDynamicObjectsToShadowMap(group_t group, std::unordered_map<multi_mesh*, offset_count> ocPerMesh,
	const light_frustum& frustum, memory_arena& arena, shadow_render_pass_base* shadowRenderPass)
{
	uint32 groupSize = (uint32)group.size();

	dx_allocation transformAllocation = dxContext.allocateDynamicBuffer(groupSize * sizeof(mat4), 4);
	mat4* transforms = (mat4*)transformAllocation.cpuPtr;

	for (auto [entityHandle, transform, dynamicTransform, mesh] : group.each())
	{
		if (!shouldRender(frustum, mesh, transform))
		{
			continue;
		}

		const dx_mesh& dxMesh = mesh.mesh->mesh;

		offset_count& oc = ocPerMesh.at(mesh.mesh.get());

		uint32 index = oc.offset + oc.count;
		transforms[index] = trsToMat4(transform);

		++oc.count;
	}


	D3D12_GPU_VIRTUAL_ADDRESS transformsAddress = transformAllocation.gpuPtr;

	for (auto& [mesh, oc] : ocPerMesh)
	{
		if (oc.count == 0)
		{
			continue;
		}

		D3D12_GPU_VIRTUAL_ADDRESS baseM = transformsAddress + (oc.offset * sizeof(mat4));

		const dx_mesh& dxMesh = mesh->mesh;

		shadow_render_data data;
		data.transformPtr = baseM;
		data.vertexBuffer = dxMesh.vertexBuffer.positions;
		data.indexBuffer = dxMesh.indexBuffer;
		data.numInstances = oc.count;

		for (auto& sm : mesh->submeshes)
		{
			data.submesh = sm.info;
			addToDynamicRenderPass(sm.material->shader, data, shadowRenderPass, frustum.type == light_frustum_sphere);
		}
	}
}

static void renderDynamicObjects(game_scene& scene, const camera_frustum_planes& frustum, memory_arena& arena, entity_handle selectedObjectID,
	opaque_render_pass* opaqueRenderPass, transparent_render_pass* transparentRenderPass, ldr_render_pass* ldrRenderPass, shadow_passes& shadow)
{
	CPU_PROFILE_BLOCK("Dynamic objects");

	auto group = scene.group(
		component_group<transform_component, dynamic_transform_component, mesh_component>,
		component_group<animation_component>);


	std::unordered_map<multi_mesh*, offset_count> ocPerMesh = getOffsetsPerMesh(group);
	renderDynamicObjectsToMainCamera(group, ocPerMesh, frustum, arena, selectedObjectID, opaqueRenderPass, transparentRenderPass, ldrRenderPass);

	for (uint32 i = 0; i < shadow.numShadowRenderPasses; ++i)
	{
		auto& pass = shadow.shadowRenderPasses[i];
		renderDynamicObjectsToShadowMap(group, ocPerMesh, pass.frustum, arena, pass.pass);
	}
}

static void renderAnimatedObjects(game_scene& scene, const camera_frustum_planes& frustum, memory_arena& arena, entity_handle selectedObjectID,
	opaque_render_pass* opaqueRenderPass, transparent_render_pass* transparentRenderPass, ldr_render_pass* ldrRenderPass, shadow_passes& shadow)
{
	CPU_PROFILE_BLOCK("Animated objects");

	auto group = scene.group(
		component_group<transform_component, dynamic_transform_component, mesh_component, animation_component>);


	uint32 groupSize = (uint32)group.size();

	dx_allocation transformAllocation = dxContext.allocateDynamicBuffer(groupSize * sizeof(mat4) * 2, 4);
	mat4* transforms = (mat4*)transformAllocation.cpuPtr;
	mat4* prevFrameTransforms = transforms + groupSize;

	dx_allocation objectIDAllocation = dxContext.allocateDynamicBuffer(groupSize * sizeof(uint32), 4);
	uint32* objectIDs = (uint32*)objectIDAllocation.cpuPtr;

	D3D12_GPU_VIRTUAL_ADDRESS transformsAddress = transformAllocation.gpuPtr;
	D3D12_GPU_VIRTUAL_ADDRESS prevFrameTransformsAddress = transformAllocation.gpuPtr + (groupSize * sizeof(mat4));
	D3D12_GPU_VIRTUAL_ADDRESS objectIDAddress = objectIDAllocation.gpuPtr;


	uint32 index = 0;
	for (auto [entityHandle, transform, dynamicTransform, mesh, anim] : group.each())
	{
		if (!mesh.mesh || (mesh.mesh->loadState.load() != asset_loaded))
		{
			continue;
		}

		transforms[index] = trsToMat4(transform);
		prevFrameTransforms[index] = trsToMat4(dynamicTransform);
		objectIDs[index] = (uint32)entityHandle;

		D3D12_GPU_VIRTUAL_ADDRESS baseM = transformsAddress + (index * sizeof(mat4));
		D3D12_GPU_VIRTUAL_ADDRESS prevBaseM = prevFrameTransformsAddress + (index * sizeof(mat4));
		D3D12_GPU_VIRTUAL_ADDRESS baseObjectID = objectIDAddress + (index * sizeof(uint32));


		const dx_mesh& dxMesh = mesh.mesh->mesh;

		pbr_render_data data;
		data.transformPtr = baseM;
		data.vertexBuffer = anim.currentVertexBuffer;
		data.indexBuffer = dxMesh.indexBuffer;
		data.numInstances = 1;

		depth_prepass_data depthPrepassData;
		depthPrepassData.transformPtr = baseM;
		depthPrepassData.prevFrameTransformPtr = prevBaseM;
		depthPrepassData.objectIDPtr = baseObjectID;
		depthPrepassData.vertexBuffer = anim.currentVertexBuffer;
		depthPrepassData.prevFrameVertexBuffer = anim.prevFrameVertexBuffer.positions ? anim.prevFrameVertexBuffer.positions : anim.currentVertexBuffer.positions;
		depthPrepassData.indexBuffer = dxMesh.indexBuffer;
		depthPrepassData.numInstances = 1;

		for (auto& sm : mesh.mesh->submeshes)
		{
			data.submesh = sm.info;
			data.material = sm.material;

			data.submesh.baseVertex -= mesh.mesh->submeshes[0].info.baseVertex; // Vertex buffer from skinning already points to first vertex.

			depthPrepassData.submesh = data.submesh;
			depthPrepassData.alphaCutoutTextureSRV = (sm.material && sm.material->albedo) ? sm.material->albedo->defaultSRV : dx_cpu_descriptor_handle{};

			addToRenderPass(sm.material->shader, data, depthPrepassData, opaqueRenderPass, transparentRenderPass);

			shadow_render_data shadowData;
			shadowData.transformPtr = baseM;
			shadowData.vertexBuffer = anim.currentVertexBuffer.positions;
			shadowData.indexBuffer = dxMesh.indexBuffer;
			shadowData.submesh = data.submesh;
			shadowData.numInstances = 1;

			for (uint32 i = 0; i < shadow.numShadowRenderPasses; ++i)
			{
				auto& pass = shadow.shadowRenderPasses[i];
				addToDynamicRenderPass(sm.material->shader, shadowData, pass.pass, pass.frustum.type == light_frustum_sphere);
			}

			if (entityHandle == selectedObjectID)
			{
				renderOutline(ldrRenderPass, transforms[index], anim.currentVertexBuffer, dxMesh.indexBuffer, data.submesh);
			}
		}
		
		++index;
	}
}

static void renderTerrain(const render_camera& camera, game_scene& scene, memory_arena& arena, entity_handle selectedObjectID,
	opaque_render_pass* opaqueRenderPass, transparent_render_pass* transparentRenderPass, ldr_render_pass* ldrRenderPass, sun_shadow_render_pass* sunShadowRenderPass,
	compute_pass* computePass, float dt)
{
	CPU_PROFILE_BLOCK("Terrain");

	memory_marker tempMemoryMarker = arena.getMarker();
	position_scale_component* waterPlaneTransforms = arena.allocate<position_scale_component>(scene.numberOfComponentsOfType<water_component>());
	uint32 numWaterPlanes = 0;

	for (auto [entityHandle, water, transform] : scene.group(component_group<water_component, position_scale_component>).each())
	{
		water.render(camera, transparentRenderPass, transform.position, vec2(transform.scale.x, transform.scale.z), dt, (uint32)entityHandle);

		waterPlaneTransforms[numWaterPlanes++] = transform;
	}

	for (auto [entityHandle, terrain, position] : scene.group(component_group<terrain_component, position_component>).each())
	{
		terrain.render(camera, opaqueRenderPass, sunShadowRenderPass, ldrRenderPass,
			position.position, (uint32)entityHandle, selectedObjectID == entityHandle, waterPlaneTransforms, numWaterPlanes);
	}
	arena.resetToMarker(tempMemoryMarker);






	for (auto [entityHandle, terrain, position, placement] : scene.group(component_group<terrain_component, position_component, proc_placement_component>).each())
	{
		placement.generate(camera, terrain, position.position);
		placement.render(ldrRenderPass);
	}

	for (auto [entityHandle, terrain, position, grass] : scene.group(component_group<terrain_component, position_component, grass_component>).each())
	{
		grass.generate(computePass, camera, terrain, position.position, dt);
		grass.render(opaqueRenderPass, (uint32)entityHandle);
	}
}

static void renderTrees(game_scene& scene, const camera_frustum_planes& frustum, memory_arena& arena, entity_handle selectedObjectID,
	opaque_render_pass* opaqueRenderPass, transparent_render_pass* transparentRenderPass, ldr_render_pass* ldrRenderPass, sun_shadow_render_pass* sunShadowRenderPass,
	float dt)
{
	CPU_PROFILE_BLOCK("Trees");

	auto group = scene.group(
		component_group<transform_component, mesh_component, tree_component>);

	uint32 groupSize = (uint32)group.size();

	std::unordered_map<multi_mesh*, offset_count> ocPerMesh = getOffsetsPerMesh(group);

	dx_allocation transformAllocation = dxContext.allocateDynamicBuffer(groupSize * sizeof(mat4), 4);
	mat4* transforms = (mat4*)transformAllocation.cpuPtr;

	dx_allocation objectIDAllocation = dxContext.allocateDynamicBuffer(groupSize * sizeof(uint32), 4);
	uint32* objectIDs = (uint32*)objectIDAllocation.cpuPtr;

	for (auto [entityHandle, transform, mesh, tree] : group.each())
	{
		if (!shouldRender(frustum, mesh, transform))
		{
			continue;
		}

		const dx_mesh& dxMesh = mesh.mesh->mesh;

		offset_count& oc = ocPerMesh.at(mesh.mesh.get());

		uint32 index = oc.offset + oc.count;
		transforms[index] = trsToMat4(transform);
		objectIDs[index] = (uint32)entityHandle;

		++oc.count;


		if (entityHandle == selectedObjectID)
		{
			for (auto& sm : mesh.mesh->submeshes)
			{
				renderOutline(ldrRenderPass, transforms[index], dxMesh.vertexBuffer, dxMesh.indexBuffer, sm.info);
			}
		}
	}


	D3D12_GPU_VIRTUAL_ADDRESS transformsAddress = transformAllocation.gpuPtr;
	D3D12_GPU_VIRTUAL_ADDRESS objectIDAddress = objectIDAllocation.gpuPtr;

	for (auto& [mesh, oc] : ocPerMesh)
	{
		if (oc.count == 0)
		{
			continue;
		}

		D3D12_GPU_VIRTUAL_ADDRESS baseM = transformsAddress + (oc.offset * sizeof(mat4));
		D3D12_GPU_VIRTUAL_ADDRESS baseObjectID = objectIDAddress + (oc.offset * sizeof(uint32));

		renderTree(opaqueRenderPass, baseM, oc.count, mesh, dt);
	}
}

static void renderCloth(game_scene& scene, entity_handle selectedObjectID, 
	opaque_render_pass* opaqueRenderPass, transparent_render_pass* transparentRenderPass, ldr_render_pass* ldrRenderPass, sun_shadow_render_pass* sunShadowRenderPass)
{
	CPU_PROFILE_BLOCK("Cloth");

	auto group = scene.group(
		component_group<cloth_component, cloth_render_component>);

	uint32 groupSize = (uint32)group.size();

	dx_allocation transformAllocation = dxContext.allocateDynamicBuffer(1 * sizeof(mat4), 4);
	*(mat4*)transformAllocation.cpuPtr = mat4::identity;

	dx_allocation objectIDAllocation = dxContext.allocateDynamicBuffer(groupSize * sizeof(uint32), 4);
	uint32* objectIDs = (uint32*)objectIDAllocation.cpuPtr;

	D3D12_GPU_VIRTUAL_ADDRESS objectIDAddress = objectIDAllocation.gpuPtr;

	uint32 index = 0;
	for (auto [entityHandle, cloth, render] : scene.group<cloth_component, cloth_render_component>().each())
	{
		pbr_material_desc desc;
		desc.albedo = "assets/sponza/textures/Sponza_Curtain_Red_diffuse.tga";
		desc.normal = "assets/sponza/textures/Sponza_Curtain_Red_normal.tga";
		desc.roughness = "assets/sponza/textures/Sponza_Curtain_roughness.tga";
		desc.metallic = "assets/sponza/textures/Sponza_Curtain_metallic.tga";
		desc.shader = pbr_material_shader_double_sided;

		static auto clothMaterial = createPBRMaterial(desc);

		objectIDs[index] = (uint32)entityHandle;
		D3D12_GPU_VIRTUAL_ADDRESS baseObjectID = objectIDAddress + (index * sizeof(uint32));

		auto [vb, prevFrameVB, ib, sm] = render.getRenderData(cloth);

		pbr_render_data data;
		data.transformPtr = transformAllocation.gpuPtr;
		data.vertexBuffer = vb;
		data.indexBuffer = ib;
		data.submesh = sm;
		data.material = clothMaterial;
		data.numInstances = 1;

		depth_prepass_data depthPrepassData;
		depthPrepassData.transformPtr = transformAllocation.gpuPtr;
		depthPrepassData.prevFrameTransformPtr = transformAllocation.gpuPtr;
		depthPrepassData.objectIDPtr = baseObjectID;
		depthPrepassData.vertexBuffer = vb;
		depthPrepassData.prevFrameVertexBuffer = prevFrameVB.positions ? prevFrameVB.positions : vb.positions;
		depthPrepassData.indexBuffer = ib;
		depthPrepassData.submesh = sm;
		depthPrepassData.numInstances = 1;
		depthPrepassData.alphaCutoutTextureSRV = (clothMaterial && clothMaterial->albedo) ? clothMaterial->albedo->defaultSRV : dx_cpu_descriptor_handle{};

		addToRenderPass(clothMaterial->shader, data, depthPrepassData, opaqueRenderPass, transparentRenderPass);

		if (sunShadowRenderPass)
		{
			shadow_render_data shadowData;
			shadowData.transformPtr = transformAllocation.gpuPtr;
			shadowData.vertexBuffer = vb.positions;
			shadowData.indexBuffer = ib;
			shadowData.numInstances = 1;
			shadowData.submesh = data.submesh;

			addToDynamicRenderPass(clothMaterial->shader, shadowData, &sunShadowRenderPass->cascades[0], false);
		}

		if (entityHandle == selectedObjectID)
		{
			renderOutline(ldrRenderPass, mat4::identity, vb, ib, sm);
		}

		++index;
	}
}

static void setupSunShadowPass(directional_light& sun, sun_shadow_render_pass* sunShadowRenderPass, bool invalidateShadowMapCache)
{
	shadow_render_command command = determineSunShadowInfo(sun, invalidateShadowMapCache);
	sunShadowRenderPass->numCascades = sun.numShadowCascades;
	for (uint32 i = 0; i < sun.numShadowCascades; ++i)
	{
		sun_cascade_render_pass& cascadePass = sunShadowRenderPass->cascades[i];
		cascadePass.viewport = command.viewports[i];
		cascadePass.viewProj = sun.viewProjs[i];
	}
	sunShadowRenderPass->copyFromStaticCache = !command.renderStaticGeometry;
}

static void setupSpotShadowPasses(game_scene& scene, scene_lighting& lighting, bool invalidateShadowMapCache)
{
	uint32 numSpotLights = scene.numberOfComponentsOfType<spot_light_component>();
	if (numSpotLights)
	{
		auto* slPtr = (spot_light_cb*)mapBuffer(lighting.spotLightBuffer, false);
		auto* siPtr = (spot_shadow_info*)mapBuffer(lighting.spotLightShadowInfoBuffer, false);

		for (auto [entityHandle, transform, sl] : scene.group<position_rotation_component, spot_light_component>().each())
		{
			spot_light_cb cb(transform.position, transform.rotation * vec3(0.f, 0.f, -1.f), sl.color * sl.intensity, sl.innerAngle, sl.outerAngle, sl.distance);

			if (sl.castsShadow && lighting.numSpotShadowRenderPasses < lighting.maxNumSpotShadowRenderPasses)
			{
				cb.shadowInfoIndex = lighting.numSpotShadowRenderPasses++;

				auto [command, si] = determineSpotShadowInfo(cb, (uint32)entityHandle, sl.shadowMapResolution, invalidateShadowMapCache);
				spot_shadow_render_pass& pass = lighting.spotShadowRenderPasses[cb.shadowInfoIndex];

				pass.copyFromStaticCache = !command.renderStaticGeometry;
				pass.viewport = command.viewports[0];
				pass.viewProjMatrix = si.viewProj;

				*siPtr++ = si;
			}

			*slPtr++ = cb;
		}

		unmapBuffer(lighting.spotLightBuffer, true, { 0, numSpotLights });
		unmapBuffer(lighting.spotLightShadowInfoBuffer, true, { 0, lighting.numSpotShadowRenderPasses });
	}
}

static void setupPointShadowPasses(game_scene& scene, scene_lighting& lighting, bool invalidateShadowMapCache)
{
	uint32 numPointLights = scene.numberOfComponentsOfType<point_light_component>();
	if (numPointLights)
	{
		auto* plPtr = (point_light_cb*)mapBuffer(lighting.pointLightBuffer, false);
		auto* siPtr = (point_shadow_info*)mapBuffer(lighting.pointLightShadowInfoBuffer, false);

		for (auto [entityHandle, position, pl] : scene.group<position_component, point_light_component>().each())
		{
			point_light_cb cb(position.position, pl.color * pl.intensity, pl.radius);

			if (pl.castsShadow && lighting.numPointShadowRenderPasses < lighting.maxNumPointShadowRenderPasses)
			{
				cb.shadowInfoIndex = lighting.numPointShadowRenderPasses++;

				auto [command, si] = determinePointShadowInfo(cb, (uint32)entityHandle, pl.shadowMapResolution, invalidateShadowMapCache);
				point_shadow_render_pass& pass = lighting.pointShadowRenderPasses[cb.shadowInfoIndex];

				pass.copyFromStaticCache0 = !command.renderStaticGeometry;
				pass.copyFromStaticCache1 = !command.renderStaticGeometry;
				pass.viewport0 = command.viewports[0];
				pass.viewport1 = command.viewports[1];
				pass.lightPosition = cb.position;
				pass.maxDistance = cb.radius;

				*siPtr++ = si;
			}

			*plPtr++ = cb;
		}

		unmapBuffer(lighting.pointLightBuffer, true, { 0, numPointLights });
		unmapBuffer(lighting.pointLightShadowInfoBuffer, true, { 0, lighting.numPointShadowRenderPasses });
	}
}

void renderScene(const render_camera& camera, game_scene& scene, memory_arena& arena, entity_handle selectedObjectID,
	directional_light& sun, scene_lighting& lighting, bool invalidateShadowMapCache,
	opaque_render_pass* opaqueRenderPass, transparent_render_pass* transparentRenderPass, ldr_render_pass* ldrRenderPass, sun_shadow_render_pass* sunShadowRenderPass,
	compute_pass* computePass, float dt)
{
	CPU_PROFILE_BLOCK("Submit scene render commands");

	setupSunShadowPass(sun, sunShadowRenderPass, invalidateShadowMapCache);
	setupSpotShadowPasses(scene, lighting, invalidateShadowMapCache);
	setupPointShadowPasses(scene, lighting, invalidateShadowMapCache);

	shadow_passes staticShadowPasses = {};
	shadow_passes dynamicShadowPasses = {};

	memory_marker tempMemoryMarker = arena.getMarker();
	uint32 numShadowCastingLights = 1 + lighting.numSpotShadowRenderPasses + lighting.numPointShadowRenderPasses;
	staticShadowPasses.shadowRenderPasses = arena.allocate<shadow_pass>(numShadowCastingLights);
	dynamicShadowPasses.shadowRenderPasses = arena.allocate<shadow_pass>(numShadowCastingLights);

	{
		auto& outPass = dynamicShadowPasses.shadowRenderPasses[dynamicShadowPasses.numShadowRenderPasses++];
		outPass.frustum.frustum = getWorldSpaceFrustumPlanes(sunShadowRenderPass->cascades[sunShadowRenderPass->numCascades - 1].viewProj);
		outPass.frustum.type = light_frustum_standard;
		outPass.pass = &sunShadowRenderPass->cascades[0];

		if (!sunShadowRenderPass->copyFromStaticCache)
		{
			staticShadowPasses.shadowRenderPasses[staticShadowPasses.numShadowRenderPasses++] = outPass;
		}
	}

	for (uint32 i = 0; i < lighting.numSpotShadowRenderPasses; ++i)
	{
		auto pass = &lighting.spotShadowRenderPasses[i];
		auto& outPass = dynamicShadowPasses.shadowRenderPasses[dynamicShadowPasses.numShadowRenderPasses++];
		outPass.frustum.frustum = getWorldSpaceFrustumPlanes(pass->viewProjMatrix);
		outPass.frustum.type = light_frustum_standard;
		outPass.pass = pass;

		if (!pass->copyFromStaticCache)
		{
			staticShadowPasses.shadowRenderPasses[staticShadowPasses.numShadowRenderPasses++] = outPass;
		}
	}

	for (uint32 i = 0; i < lighting.numPointShadowRenderPasses; ++i)
	{
		auto pass = &lighting.pointShadowRenderPasses[i];
		auto& outPass = dynamicShadowPasses.shadowRenderPasses[dynamicShadowPasses.numShadowRenderPasses++];
		outPass.frustum.sphere = { pass->lightPosition, pass->maxDistance };
		outPass.frustum.type = light_frustum_sphere;
		outPass.pass = pass;

		if (!pass->copyFromStaticCache0)
		{
			staticShadowPasses.shadowRenderPasses[staticShadowPasses.numShadowRenderPasses++] = outPass;
		}
	}

	bool sunRenderStaticGeometry = !sunShadowRenderPass->copyFromStaticCache;


	camera_frustum_planes frustum = camera.getWorldSpaceFrustumPlanes();

	renderStaticObjects(scene, frustum, arena, selectedObjectID, opaqueRenderPass, transparentRenderPass, ldrRenderPass, staticShadowPasses);
	renderDynamicObjects(scene, frustum, arena, selectedObjectID, opaqueRenderPass, transparentRenderPass, ldrRenderPass, dynamicShadowPasses);
	renderAnimatedObjects(scene, frustum, arena, selectedObjectID, opaqueRenderPass, transparentRenderPass, ldrRenderPass, dynamicShadowPasses);
	renderTerrain(camera, scene, arena, selectedObjectID, opaqueRenderPass, transparentRenderPass, ldrRenderPass, sunRenderStaticGeometry ? sunShadowRenderPass : 0,
		computePass, dt);
	renderTrees(scene, frustum, arena, selectedObjectID, opaqueRenderPass, transparentRenderPass, ldrRenderPass, sunShadowRenderPass, dt);
	renderCloth(scene, selectedObjectID, opaqueRenderPass, transparentRenderPass, ldrRenderPass, sunShadowRenderPass);

	arena.resetToMarker(tempMemoryMarker);
}


```

`src/scene/scene_rendering.h`:

```h
#pragma once

#include "scene.h"
#include "core/memory.h"
#include "rendering/render_pass.h"


struct scene_lighting
{
	ref<dx_buffer> spotLightBuffer;
	ref<dx_buffer> pointLightBuffer;

	ref<dx_buffer> spotLightShadowInfoBuffer;
	ref<dx_buffer> pointLightShadowInfoBuffer;

	spot_shadow_render_pass* spotShadowRenderPasses;
	point_shadow_render_pass* pointShadowRenderPasses;

	uint32 maxNumSpotShadowRenderPasses;
	uint32 maxNumPointShadowRenderPasses;

	uint32 numSpotShadowRenderPasses = 0;
	uint32 numPointShadowRenderPasses = 0;
};

void renderScene(const render_camera& camera, game_scene& scene, memory_arena& arena, entity_handle selectedObjectID, 
	directional_light& sun, scene_lighting& lighting, bool invalidateShadowMapCache,
	opaque_render_pass* opaqueRenderPass, transparent_render_pass* transparentRenderPass, ldr_render_pass* ldrRenderPass, sun_shadow_render_pass* sunShadowRenderPass,
	compute_pass* computePass, float dt);


```

`src/scene/serialization_binary.cpp`:

```cpp
#include "pch.h"
#include "serialization_binary.h"
#include "asset/file_registry.h"

#include "physics/physics.h"
#include "terrain/heightmap_collider.h"

struct write_stream
{
	uint8* buffer;
	uint64 size;
	uint64 writeOffset = 0;


	template <typename T>
	void write(T t)
	{
		if (check(sizeof(T)))
		{
			memcpy(buffer + writeOffset, &t, sizeof(T));
			writeOffset += sizeof(T);
		}
	}

	template <typename T, uint32 size>
	void write(T(&s)[size])
	{
		if (check(size * sizeof(T)))
		{
			memcpy(buffer + writeOffset, s, size * sizeof(T));
			writeOffset += size * sizeof(T);
		}
	}

private:
	bool check(uint64 s)
	{
		if (writeOffset + s >= size)
		{
			size = 0;
			return false;
		}
		return true;
	}
};

struct read_stream
{
	uint8* buffer;
	uint64 size;
	uint64 readOffset = 0;
	
	template <typename T>
	void peek(T& out)
	{
		if (check(sizeof(T)))
		{
			memcpy(&out, buffer + readOffset, sizeof(T));
		}
	}

	template <typename T>
	void read(T& out)
	{
		if (check(sizeof(T)))
		{
			peek(out);
			readOffset += sizeof(T);
		}
	}

	template <typename T, uint32 size>
	void read(T(&s)[size])
	{
		if (check(size * sizeof(T)))
		{
			memcpy(s, buffer + readOffset, size * sizeof(T));
			readOffset += size * sizeof(T);
		}
	}

private:
	bool check(uint64 s)
	{
		if (size < readOffset + s)
		{
			size = 0;
			return false;
		}
		return true;
	}
};











using serialized_components = component_group_t<

	tag_component,

	// Transforms.
	transform_component,
	position_component,
	position_rotation_component,
	position_scale_component,
	dynamic_transform_component,

	// Rendering.
	mesh_component,
	point_light_component,
	spot_light_component,

	// Physics.
	rigid_body_component,
	force_field_component,
	cloth_component,
	cloth_render_component,
	physics_reference_component,

	// Terrain.
	terrain_component,
	heightmap_collider_component,
	grass_component,
	proc_placement_component,
	water_component
>;


template <typename component_t>
void serializeToMemoryStream(scene_entity entity, const component_t& component, write_stream& stream)
{
	stream.write(component);
}

template <typename component_t>
void deserializeFromMemoryStream(scene_entity entity, read_stream& stream)
{
	entity.addComponent<component_t>();
	component_t& component = entity.getComponent<component_t>();

	stream.read(component);
}

#define READ(type, var) type var; stream.read(var);

template <> void serializeToMemoryStream(scene_entity entity, const dynamic_transform_component& component, write_stream& stream) {}
template <> void deserializeFromMemoryStream<dynamic_transform_component>(scene_entity entity, read_stream& stream) { entity.addComponent<dynamic_transform_component>(); }

template <>
void serializeToMemoryStream(scene_entity entity, const mesh_component& component, write_stream& stream)
{
	asset_handle handle = component.mesh ? component.mesh->handle : 0;
	uint32 flags = component.mesh ? component.mesh->flags : 0;
	stream.write(handle);
	stream.write(flags);
}

template <>
void deserializeFromMemoryStream<mesh_component>(scene_entity entity, read_stream& stream)
{
	READ(asset_handle, handle);
	READ(uint32, flags);

	auto mesh = loadMeshFromHandle(handle, flags);
	entity.addComponent<mesh_component>(mesh);
}

template <>
void serializeToMemoryStream(scene_entity entity, const cloth_component& component, write_stream& stream)
{
	stream.write(component.width);
	stream.write(component.height);
	stream.write(component.gridSizeX);
	stream.write(component.gridSizeY);
	stream.write(component.totalMass);
	stream.write(component.stiffness);
	stream.write(component.damping);
	stream.write(component.gravityFactor);
}

template <>
void deserializeFromMemoryStream<cloth_component>(scene_entity entity, read_stream& stream)
{
	READ(float, width);
	READ(float, height);
	READ(uint32, gridSizeX);
	READ(uint32, gridSizeY);
	READ(float, totalMass);
	READ(float, stiffness);
	READ(float, damping);
	READ(float, gravityFactor);

	entity.addComponent<cloth_component>(width, height, gridSizeX, gridSizeY, totalMass, stiffness, damping, gravityFactor);
}

template <> void serializeToMemoryStream(scene_entity entity, const cloth_render_component& component, write_stream& stream) {}
template <> void deserializeFromMemoryStream<cloth_render_component>(scene_entity entity, read_stream& stream) { entity.addComponent<cloth_render_component>(); }

template <>
void serializeToMemoryStream(scene_entity entity, const physics_reference_component& component, write_stream& stream)
{
	stream.write(component.numColliders);
	for (collider_component& collider : collider_component_iterator(entity))
	{
		stream.write<collider_union>(collider);
	}

	stream.write(component.numConstraints);
	for (auto [constraintEntity, constraintType] : constraint_entity_iterator(entity))
	{
		auto& ref = constraintEntity.getComponent<constraint_entity_reference_component>();

		stream.write(constraintType);
		stream.write(ref.entityA);
		stream.write(ref.entityB);

		switch (constraintType)
		{
			case constraint_type_distance: stream.write(constraintEntity.getComponent<distance_constraint>()); break;
			case constraint_type_ball: stream.write(constraintEntity.getComponent<ball_constraint>()); break;
			case constraint_type_fixed: stream.write(constraintEntity.getComponent<fixed_constraint>()); break;
			case constraint_type_hinge: stream.write(constraintEntity.getComponent<hinge_constraint>()); break;
			case constraint_type_cone_twist: stream.write(constraintEntity.getComponent<cone_twist_constraint>()); break;
			case constraint_type_slider: stream.write(constraintEntity.getComponent<slider_constraint>()); break;
		}
	}
}

template <>
void deserializeFromMemoryStream<physics_reference_component>(scene_entity entity, read_stream& stream)
{
	READ(uint32, numColliders);
	for (uint32 i = 0; i < numColliders; ++i)
	{
		READ(collider_union, u);
		entity.addComponent<collider_component>(collider_component::fromUnion(u));
	}

	READ(uint32, numConstraints);
	for (uint32 i = 0; i < numConstraints; ++i)
	{
		READ(constraint_type, constraintType);

		READ(entity_handle, entityHandleA);
		READ(entity_handle, entityHandleB);

		ASSERT(entity.handle == entityHandleA || entity.handle == entityHandleB);

		scene_entity a = { entityHandleA, entity.registry };
		scene_entity b = { entityHandleB, entity.registry };

		switch (constraintType)
		{
			case constraint_type_distance: { READ(distance_constraint, c); addConstraint(a, b, c); break; }
			case constraint_type_ball: { READ(ball_constraint, c); addConstraint(a, b, c); break; }
			case constraint_type_fixed: { READ(fixed_constraint, c); addConstraint(a, b, c); break; }
			case constraint_type_hinge: { READ(hinge_constraint, c); addConstraint(a, b, c); break; }
			case constraint_type_cone_twist: { READ(cone_twist_constraint, c); addConstraint(a, b, c); break; }
			case constraint_type_slider: { READ(slider_constraint, c); addConstraint(a, b, c); break; }
		}
	}
}

static void serializeTexture(const ref<dx_texture>& tex, write_stream& stream)
{
	stream.write(tex ? tex->handle : asset_handle{ 0 });
	stream.write(tex ? tex->flags : 0u);
}

static void serializeMaterial(const ref<pbr_material>& mat, write_stream& stream)
{
	stream.write(mat != nullptr);
	if (mat)
	{
		serializeTexture(mat->albedo, stream);
		serializeTexture(mat->normal, stream);
		serializeTexture(mat->roughness, stream);
		serializeTexture(mat->metallic, stream);

		stream.write(mat->emission);
		stream.write(mat->albedoTint);
		stream.write(mat->roughnessOverride);
		stream.write(mat->metallicOverride);
		stream.write(mat->shader);
		stream.write(mat->uvScale);
		stream.write(mat->translucency);
	}
}

static std::pair<asset_handle, uint32> deserializeTexture(read_stream& stream)
{
	READ(asset_handle, handle);
	READ(uint32, flags);
	return { handle, flags };
}

static ref<pbr_material> deserializeMaterial(read_stream& stream)
{
	ref<pbr_material> result = 0;

	READ(bool, exists);
	if (exists)
	{
		pbr_material_desc desc;

		auto [albedoHandle, albedoFlags] = deserializeTexture(stream);
		auto [normalHandle, normalFlags] = deserializeTexture(stream);
		auto [roughnessHandle, roughnessFlags] = deserializeTexture(stream);
		auto [metallicHandle, metallicFlags] = deserializeTexture(stream);

		desc.albedo = getPathFromAssetHandle(albedoHandle);
		desc.albedoFlags = albedoFlags;
		desc.normal = getPathFromAssetHandle(normalHandle);
		desc.normalFlags = normalFlags;
		desc.roughness = getPathFromAssetHandle(roughnessHandle);
		desc.roughnessFlags = roughnessFlags;
		desc.metallic = getPathFromAssetHandle(metallicHandle);
		desc.metallicFlags = metallicFlags;

		READ(vec4, emission);
		READ(vec4, albedoTint);
		READ(float, roughnessOverride);
		READ(float, metallicOverride);
		READ(pbr_material_shader, shader);
		READ(float, uvScale);
		READ(float, translucency);

		desc.emission = emission;
		desc.albedoTint = albedoTint;
		desc.roughnessOverride = roughnessOverride;
		desc.metallicOverride = metallicOverride;
		desc.shader = shader;
		desc.uvScale = uvScale;
		desc.translucency = translucency;

		result = createPBRMaterial(desc);
	}

	return result;
}

template <>
void serializeToMemoryStream(scene_entity entity, const terrain_component& component, write_stream& stream)
{
	stream.write(component.chunksPerDim);
	stream.write(component.chunkSize);
	stream.write(component.amplitudeScale);
	stream.write(component.genSettings);

	serializeMaterial(component.groundMaterial, stream);
	serializeMaterial(component.rockMaterial, stream);
	serializeMaterial(component.mudMaterial, stream);
}

template <>
void deserializeFromMemoryStream<terrain_component>(scene_entity entity, read_stream& stream)
{
	READ(uint32, chunksPerDim);
	READ(float, chunkSize);
	READ(float, amplitudeScale);
	READ(terrain_generation_settings, genSettings);

	auto ground = deserializeMaterial(stream);
	auto rock = deserializeMaterial(stream);
	auto mud = deserializeMaterial(stream);

	entity.addComponent<terrain_component>(chunksPerDim, chunkSize, amplitudeScale, ground, rock, mud, genSettings);
}

template <>
void serializeToMemoryStream(scene_entity entity, const heightmap_collider_component& component, write_stream& stream)
{
	stream.write(component.chunksPerDim);
	stream.write(component.chunkSize);
	stream.write(component.material);
}

template <>
void deserializeFromMemoryStream<heightmap_collider_component>(scene_entity entity, read_stream& stream)
{
	READ(uint32, chunksPerDim);
	READ(float, chunkSize);
	READ(physics_material, material);

	entity.addComponent<heightmap_collider_component>(chunksPerDim, chunkSize, material);
}

template <>
void serializeToMemoryStream(scene_entity entity, const grass_component& component, write_stream& stream)
{
	stream.write(component.settings);
}

template <>
void deserializeFromMemoryStream<grass_component>(scene_entity entity, read_stream& stream)
{
	READ(grass_settings, settings);
	entity.addComponent<grass_component>(settings);
}

template <>
void serializeToMemoryStream(scene_entity entity, const proc_placement_component& component, write_stream& stream)
{
	// TODO
}

template <>
void deserializeFromMemoryStream<proc_placement_component>(scene_entity entity, read_stream& stream)
{
	// TODO
}




























template <typename component_t>
void serializeComponentToMemoryStream(scene_entity entity, write_stream& stream)
{
	if (component_t* component = entity.getComponentIfExists<component_t>())
	{
		stream.write(true);
		serializeToMemoryStream(entity, *component, stream);
	}
	else
	{
		stream.write(false);
	}
}

template <typename component_t>
void deserializeComponentFromMemoryStream(scene_entity entity, read_stream& stream)
{
	READ(bool, hasComponent);

	if (hasComponent)
	{
		deserializeFromMemoryStream<component_t>(entity, stream);
	}
}

template <typename... component_t>
static void serializeComponentsToMemoryStream(component_group_t<component_t...>, scene_entity entity, write_stream& stream)
{
	(serializeComponentToMemoryStream<component_t>(entity, stream), ...);
}

template <typename... component_t>
static void deserializeComponentsFromMemoryStream(component_group_t<component_t...>, scene_entity entity, read_stream& stream)
{
	(deserializeComponentFromMemoryStream<component_t>(entity, stream), ...);
}




uint64 serializeEntityToMemory(scene_entity entity, void* memory, uint64 maxSize)
{
	write_stream stream = { (uint8*)memory, maxSize };
	serializeComponentsToMemoryStream(serialized_components{}, entity, stream);
	return stream.writeOffset;
}

bool deserializeEntityFromMemory(scene_entity entity, void* memory, uint64 size)
{
	read_stream stream = { (uint8*)memory, size };
	deserializeComponentsFromMemoryStream(serialized_components{}, entity, stream);
	return stream.readOffset == size;
}















```

`src/scene/serialization_binary.h`:

```h
#pragma once

#include "scene.h"

uint64 serializeEntityToMemory(scene_entity entity, void* memory, uint64 maxSize);
bool deserializeEntityFromMemory(scene_entity entity, void* memory, uint64 size);


```

`src/scene/serialization_yaml.cpp`:

```cpp
#include "pch.h"
#include "serialization_yaml.h"

#include "editor/file_dialog.h"
#include "core/yaml.h"
#include "core/log.h"

#include "asset/file_registry.h"

#include "physics/physics.h"
#include "physics/cloth.h"

#include "terrain/terrain.h"
#include "terrain/grass.h"
#include "terrain/water.h"
#include "terrain/proc_placement.h"

namespace YAML
{
	template<typename T>
	struct convert
	{
		template <typename = std::enable_if_t<is_reflected_v<T>>>
		static Node encode(const T& v)
		{
			Node n;
			type_descriptor<T>::apply(
				[&n](const char* name, auto& member)
				{
					using T = std::decay_t<decltype(member)>;
					if constexpr (std::is_enum_v<T>)
					{
						n[name] = (int)member;
					}
					else
					{
						n[name] = member;
					}
				},
				v
			);
			return n;
		}

		template <typename = std::enable_if_t<is_reflected_v<T>>>
		static bool decode(const Node& n, T& v)
		{
			if (!n.IsMap()) { return false; }

			type_descriptor<T>::apply(
				[&n](const char* name, auto& member)
				{
					using T = std::decay_t<decltype(member)>;
					if constexpr (std::is_enum_v<T>)
					{
						YAML_LOAD_ENUM(n, member, name);
					}
					else
					{
						YAML_LOAD(n, member, name);
					}
				},
				v
			);

			return true;
		}
	};
}

namespace YAML
{
	template<>
	struct convert<rigid_body_component>
	{
		static Node encode(const rigid_body_component& c)
		{
			Node n;
			n["Local COG"] = c.localCOGPosition;
			n["Inv mass"] = c.invMass;
			n["Inv inertia"] = c.invInertia;
			n["Gravity factor"] = c.gravityFactor;
			n["Linear damping"] = c.linearDamping;
			n["Angular damping"] = c.angularDamping;
			return n;
		}

		static bool decode(const Node& n, rigid_body_component& c)
		{
			if (!n.IsMap()) { return false; }

			YAML_LOAD(n, c.localCOGPosition, "Local COG");
			YAML_LOAD(n, c.invMass, "Inv mass");
			YAML_LOAD(n, c.invInertia, "Inv inertia");
			YAML_LOAD(n, c.gravityFactor, "Gravity factor");
			YAML_LOAD(n, c.linearDamping, "Linear damping");
			YAML_LOAD(n, c.angularDamping, "Angular damping");

			return true;
		}
	};

	template<>
	struct convert<force_field_component>
	{
		static Node encode(const force_field_component& c)
		{
			Node n;
			n["Force"] = c.force;
			return n;
		}

		static bool decode(const Node& n, force_field_component& c)
		{
			if (!n.IsMap()) { return false; }

			YAML_LOAD(n, c.force, "Force");

			return true;
		}
	};

	template<>
	struct convert<collider_component>
	{
		static Node encode(const collider_component& c)
		{
			Node n;
			n["Type"] = colliderTypeNames[c.type];

			switch (c.type)
			{
				case collider_type_sphere:
				{
					n["Center"] = c.sphere.center;
					n["Radius"] = c.sphere.radius;
				} break;

				case collider_type_capsule:
				{
					n["Position A"] = c.capsule.positionA;
					n["Position B"] = c.capsule.positionB;
					n["Radius"] = c.capsule.radius;
				} break;

				case collider_type_aabb:
				{
					n["Min corner"] = c.aabb.minCorner;
					n["Max corner"] = c.aabb.maxCorner;
				} break;

				case collider_type_obb:
				{
					n["Center"] = c.obb.center;
					n["Radius"] = c.obb.radius;
					n["Rotation"] = c.obb.rotation;
				} break;

				case collider_type_hull:
				{
				} break;
			}

			n["Restitution"] = c.material.restitution;
			n["Friction"] = c.material.friction;
			n["Density"] = c.material.density;
			return n;
		}

		static bool decode(const Node& n, collider_component& c)
		{
			if (!n.IsMap())
			{
				return false;
			}

			std::string typeString;
			YAML_LOAD(n, typeString, "Type");
			for (uint32 i = 0; i < collider_type_count; ++i)
			{
				if (typeString == colliderTypeNames[i])
				{
					c.type = (collider_type)i;
					break;
				}
			}

			physics_material material;
			YAML_LOAD(n, material.restitution, "Restitution");
			YAML_LOAD(n, material.friction, "Friction");
			YAML_LOAD(n, material.density, "Density");

			switch (c.type)
			{
				case collider_type_sphere:
				{
					vec3 center;
					float radius;
					YAML_LOAD(n, center, "Center");
					YAML_LOAD(n, radius, "Radius");
					c = collider_component::asSphere({ center, radius }, material);
				} break;

				case collider_type_capsule:
				{
					vec3 positionA, positionB;
					float radius;
					YAML_LOAD(n, positionA, "Position A");
					YAML_LOAD(n, positionB, "Position B");
					YAML_LOAD(n, radius, "Radius");
					c = collider_component::asCapsule({ positionA, positionB, radius }, material);
				} break;

				case collider_type_aabb:
				{
					vec3 minCorner, maxCorner;
					YAML_LOAD(n, minCorner, "Min corner");
					YAML_LOAD(n, maxCorner, "Max corner");
					c = collider_component::asAABB(bounding_box::fromMinMax(minCorner, maxCorner), material);
				} break;

				case collider_type_obb:
				{
					vec3 center, radius;
					quat rotation;
					YAML_LOAD(n, center, "Center");
					YAML_LOAD(n, radius, "Radius");
					YAML_LOAD(n, rotation, "Rotation");

					c = collider_component::asOBB({ rotation, center, radius }, material);
				} break;

				case collider_type_hull:
				{
					return false;
				} break;

				default: ASSERT(false); break;
			}

			return true;
		}
	};

	template<>
	struct convert<cloth_component>
	{
		static Node encode(const cloth_component& c)
		{
			Node n;
			n["Width"] = c.width;
			n["Height"] = c.height;
			n["Grid size x"] = c.gridSizeX;
			n["Grid size y"] = c.gridSizeY;
			n["Total mass"] = c.totalMass;
			n["Stiffness"] = c.stiffness;
			n["Damping"] = c.damping;
			n["Gravity factor"] = c.gravityFactor;
			return n;
		}

		static bool decode(const Node& n, cloth_component& c)
		{
			if (!n.IsMap()) { return false; }

			uint32 gridSizeX, gridSizeY;
			float width, height, totalMass, stiffness, damping, gravityFactor;

			YAML_LOAD(n, width, "Width");
			YAML_LOAD(n, height, "Height");
			YAML_LOAD(n, gridSizeX, "Grid size x");
			YAML_LOAD(n, gridSizeY, "Grid size y");
			YAML_LOAD(n, totalMass, "Total mass");
			YAML_LOAD(n, stiffness, "Stiffness");
			YAML_LOAD(n, damping, "Damping");
			YAML_LOAD(n, gravityFactor, "Gravity factor");

			c = cloth_component(width, height, gridSizeX, gridSizeY, totalMass, stiffness, damping, gravityFactor);

			return true;
		}
	};

	template<>
	struct convert<mesh_component>
	{
		static Node encode(const mesh_component& c)
		{
			Node n;
			n["Handle"] = c.mesh->handle;
			n["Flags"] = c.mesh->flags;
			return n;
		}

		static bool decode(const Node& n, mesh_component& c)
		{
			if (!n.IsMap()) { return false; }

			asset_handle handle;
			uint32 flags;

			YAML_LOAD(n, handle, "Handle");
			YAML_LOAD(n, flags, "Flags");

			c.mesh = loadMeshFromHandle(handle, flags);

			return true;
		}
	};

	template<>
	struct convert<pbr_environment>
	{
		static Node encode(const pbr_environment& c)
		{
			Node n;
			if (!c.isProcedural())
			{
				n["Type"] = "Texture";
				n["Handle"] = c.sky->handle;
			}
			else
			{
				n["Type"] = "Procedural";
				n["Sun direction"] = c.lastSunDirection;
			}
			n["GI mode"] = (int)c.giMode;
			n["GI intensity"] = c.globalIlluminationIntensity;
			n["Sky intensity"] = c.skyIntensity;

			return n;
		}

		static bool decode(const Node& n, pbr_environment& c)
		{
			if (!n.IsMap()) { return false; }

			std::string type = n["Type"].as<std::string>();
			if (type == "Texture")
			{
				asset_handle handle;
				YAML_LOAD(n, handle, "Handle");

				c.setFromTexture(getPathFromAssetHandle(handle));
			}
			else
			{
				vec3 sunDirection;
				YAML_LOAD(n, sunDirection, "Sun direction");

				c.setToProcedural(sunDirection);
			}

			YAML_LOAD_ENUM(n, c.giMode, "GI mode");
			YAML_LOAD(n, c.globalIlluminationIntensity, "GI intensity");
			YAML_LOAD(n, c.skyIntensity, "Sky intensity");

			return true;
		}
	};
}

void serializeSceneToYAMLFile(editor_scene& scene, const renderer_settings& rendererSettings)
{
	if (scene.savePath.empty())
	{
		fs::path filename = saveFileDialog("Scene files", "sc");
		if (filename.empty())
		{
			return;
		}

		scene.savePath = filename;
	}

	YAML::Node out;
	out["Scene"] = "My scene";
	out["Camera"] = scene.camera;
	out["Rendering"] = rendererSettings;
	out["Sun"] = scene.sun;
	out["Environment"] = scene.environment;

	YAML::Node entityNode;

	scene.editorScene.forEachEntity([&entityNode, &scene = scene.editorScene](entity_handle entityID)
	{
		scene_entity entity = { entityID, scene };

		// Only entities with tags are valid top level entities. All others are helpers like colliders and constraints.
		if (tag_component* tag = entity.getComponentIfExists<tag_component>())
		{
			YAML::Node n;
			n["Tag"] = tag->name;

			// Transforms.
			if (auto* c = entity.getComponentIfExists<transform_component>()) { n["Transform"] = *c; }
			if (auto* c = entity.getComponentIfExists<position_component>()) { n["Position"] = *c; }
			if (auto* c = entity.getComponentIfExists<position_rotation_component>()) { n["Position/Rotation"] = *c; }
			if (auto* c = entity.getComponentIfExists<position_scale_component>()) { n["Position/Scale"] = *c; }
			if (auto* c = entity.getComponentIfExists<dynamic_transform_component>()) { n["Dynamic"] = true; }

			// Rendering.
			if (auto* c = entity.getComponentIfExists<mesh_component>()) { n["Mesh"] = *c; }
			if (auto* c = entity.getComponentIfExists<point_light_component>()) { n["Point light"] = *c; }
			if (auto* c = entity.getComponentIfExists<spot_light_component>()) { n["Spot light"] = *c; }

			// Physics.
			if (auto* c = entity.getComponentIfExists<rigid_body_component>()) { n["Rigid body"] = *c; }
			if (auto* c = entity.getComponentIfExists<force_field_component>()) { n["Force field"] = *c; }
			if (auto* c = entity.getComponentIfExists<cloth_component>()) { n["Cloth"] = *c; }
			if (auto* c = entity.getComponentIfExists<cloth_render_component>()) { n["Cloth render"] = true; }
			if (auto* c = entity.getComponentIfExists<physics_reference_component>())
			{
				if (c->numColliders)
				{
					YAML::Node c;
					for (collider_component& collider : collider_component_iterator(entity))
					{
						c.push_back(collider);
					}
					n["Colliders"] = c;
				}
			}

			// Terrain.
			//if (auto* c = entity.getComponentIfExists<terrain_component>()) { n["Terrain"] = *c; }
			//if (auto* c = entity.getComponentIfExists<grass_component>()) { n["Grass"] = *c; }
			//if (auto* c = entity.getComponentIfExists<proc_placement_component>()) { n["Procedural placement"] = *c; }
			//if (auto* c = entity.getComponentIfExists<water_component>()) { n["Water"] = *c; }


			/*
			TODO:
				- Animation
				- Raytrace
				- Constraints
			*/

			entityNode.push_back(n);
		}
	});

	out["Entities"] = entityNode;


	fs::create_directories(scene.savePath.parent_path());

	std::ofstream fout(scene.savePath);
	fout << out;

	LOG_MESSAGE("Scene saved to '%ws'", scene.savePath.c_str());
}

bool deserializeSceneFromYAMLFile(editor_scene& scene, renderer_settings& rendererSettings, std::string& environmentName)
{
	fs::path filename = openFileDialog("Scene files", "sc");
	if (filename.empty())
	{
		return false;
	}

	std::ifstream stream(filename);
	YAML::Node n = YAML::Load(stream);
	if (!n["Scene"])
	{
		return false;
	}

	scene.editorScene = game_scene();
	scene.savePath = std::move(filename);

	std::string sceneName = n["Scene"].as<std::string>();

	YAML_LOAD(n, scene.camera, "Camera");
	YAML_LOAD(n, rendererSettings, "Rendering");
	YAML_LOAD(n, scene.sun, "Sun");

	YAML_LOAD(n, environmentName, "Environment");

	auto entitiesNode = n["Entities"];
	for (auto entityNode : entitiesNode)
	{
		std::string name = entityNode["Tag"].as<std::string>();
		scene_entity entity = scene.editorScene.createEntity(name.c_str());

#define LOAD_COMPONENT(type, name) if (auto node = entityNode[name]) { entity.addComponent<type>(node.as<type>()); }

		// Transforms.
		LOAD_COMPONENT(transform_component, "Transform");
		LOAD_COMPONENT(position_component, "Position");
		LOAD_COMPONENT(position_rotation_component, "Position/Rotation");
		LOAD_COMPONENT(position_scale_component, "Position/Scale");
		if (entityNode["Dynamic"]) { entity.addComponent<dynamic_transform_component>(); }

		// Rendering.
		LOAD_COMPONENT(mesh_component, "Mesh");
		LOAD_COMPONENT(point_light_component, "Point light");
		LOAD_COMPONENT(spot_light_component, "Spot light");

		// Physics.
		LOAD_COMPONENT(rigid_body_component, "Rigid body");
		LOAD_COMPONENT(force_field_component, "Force field");
		LOAD_COMPONENT(cloth_component, "Cloth");
		if (entityNode["Cloth render"]) { entity.addComponent<cloth_render_component>(); }
		if (auto collidersNode = entityNode["Colliders"])
		{
			for (uint32 i = 0; i < collidersNode.size(); ++i)
			{
				entity.addComponent<collider_component>(collidersNode[i].as<collider_component>());
			}
		}

		// Terrain.
		//LOAD_COMPONENT(terrain_component, "Terrain");
		//LOAD_COMPONENT(grass_component, "Grass");
		//LOAD_COMPONENT(proc_placement_component, "Procedural placement");
		//LOAD_COMPONENT(water_component, "Water");
	}

	LOG_MESSAGE("Scene loaded from '%ws'", scene.savePath.c_str());

	return true;
}


```

`src/scene/serialization_yaml.h`:

```h
#pragma once

#include "scene.h"
#include "core/camera.h"
#include "rendering/main_renderer.h"

void serializeSceneToYAMLFile(editor_scene& scene, const renderer_settings& rendererSettings);
bool deserializeSceneFromYAMLFile(editor_scene& scene, renderer_settings& rendererSettings, std::string& environmentName);

```

`src/terrain/grass.cpp`:

```cpp
#include "pch.h"
#include "grass.h"

#include "core/math.h"
#include "core/log.h"

#include "rendering/render_command.h"
#include "rendering/material.h"
#include "rendering/render_utils.h"
#include "rendering/render_resources.h"

#include "dx/dx_command_list.h"
#include "dx/dx_profiling.h"
#include "dx/dx_barrier_batcher.h"

#include "grass_rs.hlsli"
#include "depth_only_rs.hlsli"


static const uint32 numSegmentsLOD0 = 4;


static dx_pipeline grassPipeline;
static dx_pipeline grassDepthOnlyPipeline;

static dx_pipeline grassNoDepthPrepassPipeline;

static dx_pipeline grassGenerationPipeline;
static dx_pipeline grassCreateDrawCallsPipeline;

static dx_command_signature grassCommandSignature;

void initializeGrassPipelines()
{
	{
		auto desc = CREATE_GRAPHICS_PIPELINE
			.depthSettings(true, false, D3D12_COMPARISON_FUNC_EQUAL)
			.cullingOff()
			.renderTargets(opaqueLightPassFormats, OPQAUE_LIGHT_PASS_NO_VELOCITIES_NO_OBJECT_ID, depthStencilFormat);

		grassPipeline = createReloadablePipeline(desc, { "grass_vs", "grass_ps" });
	}
	{
		auto desc = CREATE_GRAPHICS_PIPELINE
			.cullingOff()
			.renderTargets(depthOnlyFormat, arraysize(depthOnlyFormat), depthStencilFormat);

		grassDepthOnlyPipeline = createReloadablePipeline(desc, { "grass_depth_only_vs", "depth_only_ps" }, rs_in_vertex_shader);
	}
	{
		auto desc = CREATE_GRAPHICS_PIPELINE
			.cullingOff()
			.renderTargets(opaqueLightPassFormats, OPQAUE_LIGHT_PASS_FULL, depthStencilFormat);

		grassNoDepthPrepassPipeline = createReloadablePipeline(desc, { "grass_no_depth_prepass_vs", "grass_no_depth_prepass_ps" });
	}

	grassGenerationPipeline = createReloadablePipeline("grass_generation_cs");
	grassCreateDrawCallsPipeline = createReloadablePipeline("grass_create_draw_calls_cs");


	D3D12_INDIRECT_ARGUMENT_DESC argumentDesc;
	argumentDesc.Type = D3D12_INDIRECT_ARGUMENT_TYPE_DRAW;
	grassCommandSignature = createCommandSignature({}, &argumentDesc, 1, sizeof(grass_draw));
}

static grass_cb createGrassCB(const grass_settings& settings, vec2 windDirection, uint32 numVertices)
{
	grass_cb cb;
	cb.numVertices = numVertices;
	cb.halfWidth = settings.bladeWidth * 0.5f;
	cb.windDirection = windDirection;
	return cb;
}

static grass_cb createGrassCB_LOD0(const grass_settings& settings, vec2 windDirection)
{
	const uint32 numVerticesLOD0 = numSegmentsLOD0 * 2 + 1;
	return createGrassCB(settings, windDirection, numVerticesLOD0);
}

static grass_cb createGrassCB_LOD1(const grass_settings& settings, vec2 windDirection)
{
	const uint32 numVerticesLOD0 = numSegmentsLOD0 * 2 + 1;
	const uint32 numVerticesLOD1 = numVerticesLOD0 / 2 + 1;
	return createGrassCB(settings, windDirection, numVerticesLOD1);
}

struct grass_render_data
{
	grass_settings settings;
	ref<dx_buffer> drawBuffer;
	ref<dx_buffer> bladeBufferLOD0;
	ref<dx_buffer> bladeBufferLOD1;

	vec2 windDirection;

	uint32 objectID;
};

static void setup(dx_command_list* cl, const common_render_data& common, const dx_pipeline& pipeline)
{
	cl->setPipelineState(*pipeline.pipeline);
	cl->setGraphicsRootSignature(*pipeline.rootSignature);
	cl->setPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
	cl->setGraphicsDynamicConstantBuffer(GRASS_RS_CAMERA, common.cameraCBV);
	cl->setGraphicsDynamicConstantBuffer(GRASS_RS_LIGHTING, common.lightingCBV);


	dx_cpu_descriptor_handle nullTexture = render_resources::nullTextureSRV;

	cl->setDescriptorHeapSRV(GRASS_RS_FRAME_CONSTANTS, 0, common.irradiance);
	cl->setDescriptorHeapSRV(GRASS_RS_FRAME_CONSTANTS, 1, common.prefilteredRadiance);
	cl->setDescriptorHeapSRV(GRASS_RS_FRAME_CONSTANTS, 2, render_resources::brdfTex);
	cl->setDescriptorHeapSRV(GRASS_RS_FRAME_CONSTANTS, 3, common.shadowMap);
	cl->setDescriptorHeapSRV(GRASS_RS_FRAME_CONSTANTS, 4, common.aoTexture ? common.aoTexture : render_resources::whiteTexture);
	cl->setDescriptorHeapSRV(GRASS_RS_FRAME_CONSTANTS, 5, common.sssTexture ? common.sssTexture : render_resources::whiteTexture);
	cl->setDescriptorHeapSRV(GRASS_RS_FRAME_CONSTANTS, 6, common.ssrTexture ? common.ssrTexture->defaultSRV : nullTexture);
}

static void render(dx_command_list* cl, const grass_render_data& data, uint32 cbRootParameterIndex, uint32 bladeRootParameterIndex)
{
	{
		grass_cb cb = createGrassCB_LOD0(data.settings, data.windDirection);

		cl->setRootGraphicsSRV(bladeRootParameterIndex, data.bladeBufferLOD0);
		cl->setGraphics32BitConstants(cbRootParameterIndex, cb);

		cl->drawIndirect(grassCommandSignature, 1, data.drawBuffer, 0 * sizeof(grass_draw));
	}

	{
		grass_cb cb = createGrassCB_LOD1(data.settings, data.windDirection);

		cl->setRootGraphicsSRV(bladeRootParameterIndex, data.bladeBufferLOD1);
		cl->setGraphics32BitConstants(cbRootParameterIndex, cb);

		cl->drawIndirect(grassCommandSignature, 1, data.drawBuffer, 1 * sizeof(grass_draw));
	}
}

struct grass_pipeline
{
	PIPELINE_SETUP_DECL
	{
		::setup(cl, common, grassPipeline);
	}

	PIPELINE_RENDER_DECL(grass_render_data)
	{
		PROFILE_ALL(cl, "Grass");
		::render(cl, data, GRASS_RS_CB, GRASS_RS_BLADES);
	}
};

struct grass_depth_prepass_pipeline
{
	PIPELINE_SETUP_DECL
	{
		cl->setPipelineState(*grassDepthOnlyPipeline.pipeline);
		cl->setGraphicsRootSignature(*grassDepthOnlyPipeline.rootSignature);
		cl->setPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);

		cl->setGraphicsDynamicConstantBuffer(GRASS_DEPTH_ONLY_RS_CAMERA, common.cameraCBV);
	}

	DEPTH_ONLY_RENDER_DECL(grass_render_data)
	{
		PROFILE_ALL(cl, "Grass depth prepass");

		cl->setGraphics32BitConstants(GRASS_DEPTH_ONLY_RS_OBJECT_ID, data.objectID);
		::render(cl, data, GRASS_DEPTH_ONLY_RS_CB, GRASS_DEPTH_ONLY_RS_BLADES);
	}
};

struct grass_no_depth_prepass_pipeline
{
	PIPELINE_SETUP_DECL
	{
		::setup(cl, common, grassNoDepthPrepassPipeline);
	}

	PIPELINE_RENDER_DECL(grass_render_data)
	{
		PROFILE_ALL(cl, "Grass");
		
		cl->setGraphics32BitConstants(GRASS_RS_OBJECT_ID, data.objectID);
		::render(cl, data, GRASS_RS_CB, GRASS_RS_BLADES);
	}
};


struct grass_update_data
{
	struct grass_update_terrain_chunk
	{
		ref<dx_texture> heightmap;
		ref<dx_texture> normalmap;
	};

	std::vector<grass_update_terrain_chunk> chunks;
	
	grass_settings settings;

	camera_frustum_planes cameraFrustum;
	vec3 cameraPosition;
	
	vec3 minCorner;
	uint32 chunksPerDim;
	float chunkSize;
	float amplitudeScale;

	float time;
	float prevTime;

	ref<dx_buffer> drawBuffer;
	ref<dx_buffer> countBuffer;
	ref<dx_buffer> bladeBufferLOD0;
	ref<dx_buffer> bladeBufferLOD1;
};

struct grass_update_pipeline
{
	PIPELINE_COMPUTE_DECL(grass_update_data)
	{
		PROFILE_ALL(cl, "Grass generation");

		{
			PROFILE_ALL(cl, "Generate blades");

			cl->setPipelineState(*grassGenerationPipeline.pipeline);
			cl->setComputeRootSignature(*grassGenerationPipeline.rootSignature);

			vec3 minCorner = data.minCorner;
			vec3 chunkSize(data.chunkSize, data.amplitudeScale, data.chunkSize);

			cl->setDescriptorHeap(dxContext.srvUavAllocator.type, dxContext.srvUavAllocatorShaderVisible.getHeap(0).Get());
			cl->clearUAV(data.countBuffer, 0u);
			cl->resetToDynamicDescriptorHeap();


			uint32 numGrassBladesPerDim = data.settings.numGrassBladesPerChunkDim & (~1); // Make sure this is an even number.
			numGrassBladesPerDim = min(numGrassBladesPerDim, 1024u);
			const float lodChangeEndDistance = data.settings.lodChangeStartDistance + data.settings.lodChangeTransitionDistance;
			const float cullEndDistance = data.settings.cullStartDistance + data.settings.cullTransitionDistance;

			grass_generation_common_cb common;
			memcpy(common.frustumPlanes, data.cameraFrustum.planes, sizeof(vec4) * 6);
			common.amplitudeScale = data.amplitudeScale;
			common.chunkSize = data.chunkSize;
			common.cameraPosition = data.cameraPosition;
			common.lodChangeStartDistance = data.settings.lodChangeStartDistance;
			common.lodChangeEndDistance = lodChangeEndDistance;
			common.cullStartDistance = data.settings.cullStartDistance;
			common.cullEndDistance = cullEndDistance;
			common.uvScale = 1.f / numGrassBladesPerDim;
			common.baseHeight = data.settings.bladeHeight;
			common.time = data.time;
			common.prevFrameTime = data.prevTime;

			auto commonCBV = dxContext.uploadDynamicConstantBuffer(common);
			cl->setComputeDynamicConstantBuffer(GRASS_GENERATION_RS_COMMON, commonCBV);


			for (uint32 z = 0; z < data.chunksPerDim; ++z)
			{
				for (uint32 x = 0; x < data.chunksPerDim; ++x)
				{
					auto& chunk = data.chunks[z * data.chunksPerDim + x];
					vec3 chunkMinCorner = minCorner + vec3(x * data.chunkSize, 0.f, z * data.chunkSize);
					vec3 chunkMaxCorner = chunkMinCorner + chunkSize;

					bounding_box aabb = { chunkMinCorner, chunkMaxCorner };
					if (!data.cameraFrustum.cullWorldSpaceAABB(aabb))
					{
						uint32 chunkNumGrassBladesPerDim = numGrassBladesPerDim;
						uint32 lodIndex = 0;

						float sqDistance = pointInBox(data.cameraPosition, aabb.minCorner, aabb.maxCorner)
							? 0.f
							: squaredLength(data.cameraPosition - closestPoint_PointAABB(data.cameraPosition, aabb));
						if (sqDistance > lodChangeEndDistance * lodChangeEndDistance)
						{
							chunkNumGrassBladesPerDim /= 2;
							lodIndex = 1;
						}
						if (sqDistance > cullEndDistance * cullEndDistance)
						{
							continue;
						}

						cl->setDescriptorHeapSRV(GRASS_GENERATION_RS_RESOURCES, 0, chunk.heightmap);
						cl->setDescriptorHeapSRV(GRASS_GENERATION_RS_RESOURCES, 1, chunk.normalmap);
						cl->setDescriptorHeapUAV(GRASS_GENERATION_RS_RESOURCES, 2, data.bladeBufferLOD0);
						cl->setDescriptorHeapUAV(GRASS_GENERATION_RS_RESOURCES, 3, data.bladeBufferLOD1);
						cl->setDescriptorHeapUAV(GRASS_GENERATION_RS_RESOURCES, 4, data.countBuffer);

						cl->setCompute32BitConstants(GRASS_GENERATION_RS_CB, grass_generation_cb{ chunkMinCorner, lodIndex });

						cl->dispatch(bucketize(chunkNumGrassBladesPerDim, GRASS_GENERATION_BLOCK_SIZE), bucketize(chunkNumGrassBladesPerDim, GRASS_GENERATION_BLOCK_SIZE), 1);

						//barrier_batcher(cl)
						//	.uav(data.bladeBufferLOD0)
						//	.uav(data.bladeBufferLOD1)
						//	.uav(data.countBuffer);
					}
				}
			}
		}

		cl->transitionBarrier(data.countBuffer, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE);

		{
			PROFILE_ALL(cl, "Create draw calls");

			cl->setPipelineState(*grassCreateDrawCallsPipeline.pipeline);
			cl->setComputeRootSignature(*grassCreateDrawCallsPipeline.rootSignature);

			cl->setCompute32BitConstants(GRASS_CREATE_DRAW_CALLS_RS_CB, grass_create_draw_calls_cb{ data.bladeBufferLOD0->elementCount });
			cl->setRootComputeUAV(GRASS_CREATE_DRAW_CALLS_RS_OUTPUT, data.drawBuffer);
			cl->setRootComputeSRV(GRASS_CREATE_DRAW_CALLS_RS_MESH_COUNTS, data.countBuffer);

			cl->dispatch(bucketize(data.drawBuffer->elementCount, GRASS_CREATE_DRAW_CALLS_BLOCK_SIZE));
		}
	}
};


grass_component::grass_component(grass_settings settings)
{
	this->settings = settings;

	uint32 numVerticesLOD0 = numSegmentsLOD0 * 2 + 1;
	uint32 numVerticesLOD1 = numVerticesLOD0 / 2 + 1;

	grass_draw draw[2] = {};
	draw[0].draw.VertexCountPerInstance = numVerticesLOD0;
	draw[1].draw.VertexCountPerInstance = numVerticesLOD1;

	drawBuffer = createBuffer(sizeof(grass_draw), 2, &draw, true);
	countBuffer = createBuffer(sizeof(uint32), 2, 0, true, true);
	bladeBufferLOD0 = createBuffer(sizeof(grass_blade), 1000000, 0, true);
	bladeBufferLOD1 = createBuffer(sizeof(grass_blade), 1000000, 0, true);
}

void grass_component::generate(compute_pass* computePass, const render_camera& camera, const terrain_component& terrain, vec3 positionOffset, float dt)
{
	prevTime = time;
	time += dt;

	grass_update_data data;
	data.chunks.reserve(terrain.chunks.size());
	for (const auto& chunk : terrain.chunks)
	{
		data.chunks.push_back({ chunk.heightmap, chunk.normalmap });
	}

	data.settings = settings;
	data.cameraFrustum = camera.getWorldSpaceFrustumPlanes();
	data.cameraPosition = camera.position;

	data.minCorner = terrain.getMinCorner(positionOffset);
	data.chunksPerDim = terrain.chunksPerDim;
	data.chunkSize = terrain.chunkSize;
	data.amplitudeScale = terrain.amplitudeScale;

	data.time = time;
	data.prevTime = prevTime;

	data.drawBuffer = drawBuffer;
	data.countBuffer = countBuffer;
	data.bladeBufferLOD0 = bladeBufferLOD0;
	data.bladeBufferLOD1 = bladeBufferLOD1;

	compute_pass_event eventTime = grass_settings::depthPrepass ? compute_pass_before_depth_prepass : compute_pass_before_opaque;
	computePass->addTask<grass_update_pipeline>(eventTime, std::move(data));
}

void grass_component::render(opaque_render_pass* renderPass, uint32 entityID)
{
	grass_render_data data = { settings, drawBuffer, bladeBufferLOD0, bladeBufferLOD1, windDirection, entityID };
	if (grass_settings::depthPrepass)
	{
		renderPass->renderObject<grass_pipeline, grass_depth_prepass_pipeline>(data, data);
	}
	else
	{
		renderPass->renderObject<grass_no_depth_prepass_pipeline>(data);
	}
}

```

`src/terrain/grass.h`:

```h
#pragma once

#include "rendering/render_pass.h"
#include "terrain/terrain.h"

struct grass_settings
{
	static inline bool depthPrepass = true;

	float bladeHeight = 1.f;
	float bladeWidth = 0.05f; 
	uint32 numGrassBladesPerChunkDim = 350;

	float lodChangeStartDistance = 50.f;
	float lodChangeTransitionDistance = 75.f;

	float cullStartDistance = 350.f;
	float cullTransitionDistance = 50.f;
};

struct grass_component
{
	grass_component(grass_settings settings = {});

	void generate(struct compute_pass* computePass, const render_camera& camera, const terrain_component& terrain, vec3 positionOffset, float dt);
	void render(struct opaque_render_pass* renderPass, uint32 entityID = -1);

	grass_settings settings;

private:
	ref<dx_buffer> drawBuffer;
	ref<dx_buffer> countBuffer;
	ref<dx_buffer> bladeBufferLOD0;
	ref<dx_buffer> bladeBufferLOD1;

	float time = 0.f;
	float prevTime = 0.f;
	vec2 windDirection = normalize(vec2(1.f, 1.f));
};

void initializeGrassPipelines();

```

`src/terrain/heightmap_collider.cpp`:

```cpp
#include "pch.h"
#include "heightmap_collider.h"


heightmap_collider_component::heightmap_collider_component(uint32 chunksPerDim, float chunkSize, physics_material material)
	: chunksPerDim(chunksPerDim), chunkSize(chunkSize), invChunkSize(1.f / chunkSize), material(material)
{
	colliders.resize(chunksPerDim * chunksPerDim);

	uint32 numSegmentsPerDim = (TERRAIN_LOD_0_VERTICES_PER_DIMENSION - 1);
	chunkScale = chunkSize / numSegmentsPerDim;
}

void heightmap_collider_component::update(vec3 minCorner, float amplitudeScale)
{
	this->minCorner = minCorner;
	this->invAmplitudeScale = 1.f / amplitudeScale;
	this->heightScale = amplitudeScale / UINT16_MAX;
}

float heightmap_collider_component::getHeightAt(vec2 coord) const
{
	coord -= vec2(this->minCorner.x, this->minCorner.z);

	coord *= invChunkSize;

	if (coord.x < 0.f || coord.y < 0.f || coord.x >= chunksPerDim || coord.y >= chunksPerDim)
	{
		return -FLT_MAX;
	}

	uint32 chunkX = (uint32)coord.x;
	uint32 chunkZ = (uint32)coord.y;

	auto& col = collider(chunkX, chunkZ);

	coord = frac(coord);
	coord *= (TERRAIN_LOD_0_VERTICES_PER_DIMENSION - 1);

	return col.getHeightAt(coord, heightScale, this->minCorner.y);
}

void heightmap_collider_chunk::setHeights(uint16* heights)
{
	this->heights = heights;

	uint32 numSegments = TERRAIN_LOD_0_VERTICES_PER_DIMENSION - 1;
	uint32 numMips = log2(numSegments) + 1;

	mips.resize(numMips);




	{
		uint32 readStride = TERRAIN_LOD_0_VERTICES_PER_DIMENSION;

		auto& mip = mips.front();
		mip.resize(numSegments * numSegments);
		for (uint32 z = 0; z < numSegments; ++z)
		{
			for (uint32 x = 0; x < numSegments; ++x)
			{
				uint32 aIndex = (readStride * z + x);
				uint32 bIndex = (readStride * (z + 1) + x);
				uint32 cIndex = (readStride * z + x + 1);
				uint32 dIndex = (readStride * (z + 1) + x + 1);

				uint16 a = heights[aIndex];
				uint16 b = heights[bIndex];
				uint16 c = heights[cIndex];
				uint16 d = heights[dIndex];

				heightmap_min_max v =
				{
					min(a, min(b, min(c, d))),
					max(a, max(b, max(c, d))),
				};

				mip[numSegments * z + x] = v;
			}
		}
	}

	for (uint32 i = 1; i < numMips; ++i)
	{
		uint32 readStride = numSegments;

		numSegments >>= 1;

		auto& readMip = mips[i - 1];
		auto& writeMip = mips[i];
		writeMip.resize(numSegments * numSegments);
		for (uint32 z = 0; z < numSegments; ++z)
		{
			for (uint32 x = 0; x < numSegments; ++x)
			{
				uint32 x0 = x * 2;
				uint32 x1 = x * 2 + 1;
				uint32 z0 = z * 2;
				uint32 z1 = z * 2 + 1;

				heightmap_min_max a = readMip[readStride * z0 + x0];
				heightmap_min_max b = readMip[readStride * z1 + x0];
				heightmap_min_max c = readMip[readStride * z0 + x1];
				heightmap_min_max d = readMip[readStride * z1 + x1];

				heightmap_min_max v =
				{
					min(a.min, min(b.min, min(c.min, d.min))),
					max(a.max, max(b.max, max(c.max, d.max))),
				};

				writeMip[numSegments * z + x] = v;
			}
		}
	}

	ASSERT(mips.back().size() == 1);
}

float heightmap_collider_chunk::getHeightAt(vec2 coord, float heightScale, float heightOffset) const
{
	if (!heights)
	{
		return -FLT_MAX;
	}

	ASSERT(coord.x >= 0.f && coord.x <= TERRAIN_LOD_0_VERTICES_PER_DIMENSION && coord.y >= 0.f && coord.y <= TERRAIN_LOD_0_VERTICES_PER_DIMENSION);

	uint32 x = (uint32)coord.x;
	uint32 z = (uint32)coord.y;

	float relX = coord.x - x;
	float relZ = coord.y - z;


	uint32 stride = TERRAIN_LOD_0_VERTICES_PER_DIMENSION;

	uint32 aIndex = (stride * z + x);
	uint32 bIndex = (stride * (z + 1) + x);
	uint32 cIndex = (stride * z + x + 1);
	uint32 dIndex = (stride * (z + 1) + x + 1);

	float a = heights[aIndex] * heightScale;
	float b = heights[bIndex] * heightScale;
	float c = heights[cIndex] * heightScale;
	float d = heights[dIndex] * heightScale;

	float h = lerp(lerp(a, c, relX), lerp(b, d, relX), relZ) + heightOffset;

	return h;
}

```

`src/terrain/heightmap_collider.h`:

```h
#pragma once

#include "core/math.h"
#include "core/memory.h"
#include "physics/bounding_volumes.h"
#include "physics/physics.h"

#ifndef TERRAIN_LOD_0_VERTICES_PER_DIMENSION
// Must match terrain_rs.hlsli
#define TERRAIN_LOD_0_VERTICES_PER_DIMENSION 129u
#endif

struct heightmap_collider_chunk
{
	void setHeights(uint16* heights);

	template <typename callback_func>
	void iterateTrianglesInVolume(uint32 volMinX, uint32 volMinZ, uint32 volMaxX, uint32 volMaxZ,
		uint32 volMinY, uint32 volMaxY, float chunkScale, float heightScale, vec3 chunkMinCorner, memory_arena& arena, const callback_func& func) const;

	float getHeightAt(vec2 coord, float heightScale, float heightOffset) const;

private:
	uint16* heights = 0;


	struct heightmap_min_max
	{
		uint16 min, max;
	};

	std::vector<std::vector<heightmap_min_max>> mips;
};

template <typename callback_func>
void heightmap_collider_chunk::iterateTrianglesInVolume(uint32 volMinX, uint32 volMinZ, uint32 volMaxX, uint32 volMaxZ,
	uint32 volMinY, uint32 volMaxY, float chunkScale, float heightScale, vec3 chunkMinCorner, memory_arena& arena, const callback_func& func) const
{
	if (!heights)
	{
		return;
	}

	memory_marker marker = arena.getMarker();

	struct stack_entry
	{
		uint16 mipLevel;
		uint16 x, z;
	};

	stack_entry* stack = arena.allocate<stack_entry>(1024);
	uint32 stackSize = 0;


	uint32 numMips = (uint32)mips.size();

	stack[stackSize++] = { (uint16)(numMips - 1), 0, 0 };

	while (stackSize > 0)
	{
		stack_entry entry = stack[--stackSize];

		uint32 minX = entry.x << entry.mipLevel;
		uint32 minZ = entry.z << entry.mipLevel;
		uint32 maxX = ((entry.x + 1) << entry.mipLevel) - 1;
		uint32 maxZ = ((entry.z + 1) << entry.mipLevel) - 1;

		if (maxX < volMinX || minX > volMaxX) continue;
		if (maxZ < volMinZ || minZ > volMaxZ) continue;


		uint32 numSegmentsPerDim = (TERRAIN_LOD_0_VERTICES_PER_DIMENSION - 1) >> entry.mipLevel;
		heightmap_min_max minmax = mips[entry.mipLevel][entry.z * numSegmentsPerDim + entry.x];
		if (minmax.max < volMinY || minmax.min > volMaxY) continue;


		if (entry.mipLevel == 0)
		{
			uint32 stride = TERRAIN_LOD_0_VERTICES_PER_DIMENSION;

			uint32 aIndex = (stride * entry.z + entry.x);
			uint32 bIndex = (stride * (entry.z + 1) + entry.x);
			uint32 cIndex = (stride * entry.z + entry.x + 1);
			uint32 dIndex = (stride * (entry.z + 1) + entry.x + 1);

			vec2 a = vec2((float)(entry.x), (float)(entry.z)) * chunkScale;
			vec2 b = vec2((float)(entry.x), (float)(entry.z + 1)) * chunkScale;
			vec2 c = vec2((float)(entry.x + 1), (float)(entry.z)) * chunkScale;
			vec2 d = vec2((float)(entry.x + 1), (float)(entry.z + 1)) * chunkScale;

			float heightA = heights[aIndex] * heightScale;
			float heightB = heights[bIndex] * heightScale;
			float heightC = heights[cIndex] * heightScale;
			float heightD = heights[dIndex] * heightScale;

			vec3 posA = vec3(a.x, heightA, a.y) + chunkMinCorner;
			vec3 posB = vec3(b.x, heightB, b.y) + chunkMinCorner;
			vec3 posC = vec3(c.x, heightC, c.y) + chunkMinCorner;
			vec3 posD = vec3(d.x, heightD, d.y) + chunkMinCorner;


			func(posA, posB, posC);
			func(posC, posB, posD);
		}
		else
		{
			stack[stackSize++] = { (uint16)(entry.mipLevel - 1), (uint16)(2 * entry.x + 0), (uint16)(2 * entry.z + 0) };
			stack[stackSize++] = { (uint16)(entry.mipLevel - 1), (uint16)(2 * entry.x + 0), (uint16)(2 * entry.z + 1) };
			stack[stackSize++] = { (uint16)(entry.mipLevel - 1), (uint16)(2 * entry.x + 1), (uint16)(2 * entry.z + 0) };
			stack[stackSize++] = { (uint16)(entry.mipLevel - 1), (uint16)(2 * entry.x + 1), (uint16)(2 * entry.z + 1) };
		}
	}

	arena.resetToMarker(marker);
}






struct heightmap_collider_component
{
	heightmap_collider_component(uint32 chunksPerDim, float chunkSize, physics_material material);

	void update(vec3 minCorner, float amplitudeScale);

	template <typename callback_func>
	void iterateTrianglesInVolume(bounding_box volume, memory_arena& arena, const callback_func& func) const;

	float getHeightAt(vec2 coord) const; // Returns -FLT_MAX if outside bounds.

	heightmap_collider_chunk& collider(uint32 x, uint32 z) { return colliders[z * chunksPerDim + x]; }
	const heightmap_collider_chunk& collider(uint32 x, uint32 z) const { return colliders[z * chunksPerDim + x]; }

	uint32 chunksPerDim;
	float chunkSize;
	physics_material material;

private:
	vec3 minCorner;
	float invAmplitudeScale = 1.f;
	float invChunkSize;
	float chunkScale;
	float heightScale = 0.f;

	std::vector<heightmap_collider_chunk> colliders;
};



template<typename callback_func>
inline void heightmap_collider_component::iterateTrianglesInVolume(bounding_box volume, memory_arena& arena, const callback_func& func) const
{
	volume.minCorner -= this->minCorner;
	volume.maxCorner -= this->minCorner;

	volume.minCorner.x *= invChunkSize;
	volume.minCorner.z *= invChunkSize;
	volume.maxCorner.x *= invChunkSize;
	volume.maxCorner.z *= invChunkSize;

	// volume.xz is now in chunk space, i.e. [0, 1] for chunk 0, [1, 2] for chunk 1 and so on.
	// volume.y is still in meters, but relative to minCorner.

	uint32 minX = max((int32)volume.minCorner.x, 0);
	uint32 minZ = max((int32)volume.minCorner.z, 0);
	uint32 maxX = (uint32)clamp((int32)volume.maxCorner.x, 0, (int32)chunksPerDim - 1);
	uint32 maxZ = (uint32)clamp((int32)volume.maxCorner.z, 0, (int32)chunksPerDim - 1);

	// Convert y to uint16

	volume.minCorner.y *= invAmplitudeScale;
	volume.maxCorner.y *= invAmplitudeScale;

	uint16 minHeight = (uint16)(saturate(volume.minCorner.y) * UINT16_MAX);
	uint16 maxHeight = (uint16)(saturate(volume.maxCorner.y) * UINT16_MAX);


	for (uint32 z = minZ; z <= maxZ; ++z)
	{
		for (uint32 x = minX; x <= maxX; ++x)
		{
			float relMinX = max(volume.minCorner.x - x, 0.f);
			float relMinZ = max(volume.minCorner.z - z, 0.f);

			ASSERT(relMinX <= 1.f);
			ASSERT(relMinZ <= 1.f);

			float relMaxX = (volume.maxCorner.x > (x + 1)) ? 1.f : frac(volume.maxCorner.x);
			float relMaxZ = (volume.maxCorner.z > (z + 1)) ? 1.f : frac(volume.maxCorner.z);


			uint32 chunkSpaceMinX = (uint32)(relMinX * TERRAIN_LOD_0_VERTICES_PER_DIMENSION);
			uint32 chunkSpaceMinZ = (uint32)(relMinZ * TERRAIN_LOD_0_VERTICES_PER_DIMENSION);
			uint32 chunkSpaceMaxX = (uint32)(relMaxX * TERRAIN_LOD_0_VERTICES_PER_DIMENSION);
			uint32 chunkSpaceMaxZ = (uint32)(relMaxZ * TERRAIN_LOD_0_VERTICES_PER_DIMENSION);

			vec3 chunkMinCorner = vec3(x * chunkSize, 0.f, z * chunkSize) + this->minCorner;

			collider(x, z).iterateTrianglesInVolume(chunkSpaceMinX, chunkSpaceMinZ, chunkSpaceMaxX, chunkSpaceMaxZ, 
				minHeight, maxHeight, chunkScale, heightScale, chunkMinCorner, arena, func);
		}
	}
}

```

`src/terrain/proc_placement.cpp`:

```cpp
#include "pch.h"
#include "proc_placement.h"

#include "core/log.h"

#include "dx/dx_command_list.h"
#include "dx/dx_pipeline.h"
#include "dx/dx_barrier_batcher.h"
#include "dx/dx_profiling.h"

#include "geometry/mesh_builder.h"

#include "rendering/render_utils.h"
#include "rendering/material.h"
#include "rendering/render_pass.h"
#include "rendering/pbr.h"

#include "proc_placement_rs.hlsli"

static dx_pipeline generatePointsPipeline;
static dx_pipeline prefixSumPipeline;
static dx_pipeline createDrawCallsPipeline;
static dx_pipeline createTransformsPipeline;

static dx_pipeline visualizePointsPipeline;

static dx_mesh visualizePointsMesh;
static submesh_info visualizePointsSubmesh;
static dx_command_signature visualizePointsCommandSignature;


void initializeProceduralPlacementPipelines()
{
	generatePointsPipeline = createReloadablePipeline("proc_placement_generate_points_cs");
	prefixSumPipeline = createReloadablePipeline("proc_placement_prefix_sum_cs");
	createDrawCallsPipeline = createReloadablePipeline("proc_placement_create_draw_calls_cs");
	createTransformsPipeline = createReloadablePipeline("proc_placement_create_transforms_cs");

	{
		auto desc = CREATE_GRAPHICS_PIPELINE
			.inputLayout(inputLayout_position_uv_normal_tangent)
			.renderTargets(ldrFormat, depthStencilFormat);

		visualizePointsPipeline = createReloadablePipeline(desc, { "proc_placement_points_vs", "proc_placement_points_ps" }, rs_in_pixel_shader, true);
	}


	mesh_builder builder(mesh_creation_flags_with_positions);
	//builder.pushSphere({});
	builder.pushArrow({});
	visualizePointsSubmesh = builder.endSubmesh();
	visualizePointsMesh = builder.createDXMesh();


	D3D12_INDIRECT_ARGUMENT_DESC argumentDescs[2] = {};
	argumentDescs[0].Type = D3D12_INDIRECT_ARGUMENT_TYPE_SHADER_RESOURCE_VIEW;
	argumentDescs[0].ShaderResourceView.RootParameterIndex = 1;
	argumentDescs[1].Type = D3D12_INDIRECT_ARGUMENT_TYPE_DRAW_INDEXED;
	visualizePointsCommandSignature = createCommandSignature(*visualizePointsPipeline.rootSignature, argumentDescs, arraysize(argumentDescs), sizeof(placement_draw));
}



struct render_proc_placement_layer_data
{
	ref<dx_buffer> commandBuffer;
	uint32 commandBufferOffset;

	dx_vertex_buffer_group_view vertexBuffer;
	dx_index_buffer_view indexBuffer;

	ref<dx_texture> albedo;
};

struct render_proc_placement_layer_pipeline
{
	PIPELINE_SETUP_DECL;
	PIPELINE_RENDER_DECL(render_proc_placement_layer_data);
};

PIPELINE_SETUP_IMPL(render_proc_placement_layer_pipeline)
{
	cl->setPipelineState(*visualizePointsPipeline.pipeline);
	cl->setGraphicsRootSignature(*visualizePointsPipeline.rootSignature);
	cl->setPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
	cl->setGraphicsDynamicConstantBuffer(0, common.cameraCBV);
}

PIPELINE_RENDER_IMPL(render_proc_placement_layer_pipeline, render_proc_placement_layer_data)
{
	cl->setVertexBuffer(0, data.vertexBuffer.positions);
	cl->setVertexBuffer(1, data.vertexBuffer.others);
	cl->setIndexBuffer(data.indexBuffer);
	cl->setDescriptorHeapSRV(2, 0, data.albedo);
	cl->drawIndirect(visualizePointsCommandSignature, 1, data.commandBuffer, data.commandBufferOffset * sizeof(placement_draw));
}



#define READBACK 0

#if READBACK
static ref<dx_buffer> readbackIndirect;
static ref<dx_buffer> readbackMeshCounts;
static ref<dx_buffer> readbackMeshOffsets;
#endif

proc_placement_component::proc_placement_component(const std::vector<proc_placement_layer_desc>& layers)
{
	std::vector<placement_draw> drawArgs;

	{
		placement_draw draw;
		draw.draw.BaseVertexLocation = visualizePointsSubmesh.baseVertex;
		draw.draw.IndexCountPerInstance = visualizePointsSubmesh.numIndices;
		draw.draw.StartIndexLocation = visualizePointsSubmesh.firstIndex;
		draw.draw.InstanceCount = 0;
		draw.draw.StartInstanceLocation = 0;
		drawArgs.push_back(draw);

		submeshToMesh.push_back(0);
	}


	uint32 globalMeshOffset = 1;

	for (const auto& layerDesc : layers)
	{
		placement_layer layer;
		layer.name = layerDesc.name;
		layer.footprint = layerDesc.footprint;
		layer.globalMeshOffset = globalMeshOffset;
		layer.numMeshes = 0;

		for (uint32 i = 0; i < 4; ++i)
		{
			const ref<multi_mesh>& mesh = layerDesc.meshes[i];
			layer.meshes[i] = mesh;

			if (mesh)
			{
				++layer.numMeshes;

				for (const auto& sub : mesh->submeshes)
				{
					placement_draw draw;
					draw.draw.BaseVertexLocation = sub.info.baseVertex;
					draw.draw.IndexCountPerInstance = sub.info.numIndices;
					draw.draw.StartIndexLocation = sub.info.firstIndex;
					draw.draw.InstanceCount = 0;
					draw.draw.StartInstanceLocation = 0;
					drawArgs.push_back(draw);

					submeshToMesh.push_back(globalMeshOffset + i);

					hasValidMeshes = true;
				}
			}
		}

		globalMeshOffset += layer.numMeshes;

		this->layers.push_back(layer);
	}

	ASSERT(globalMeshOffset <= 512); // Prefix sum currently only supports up to 512 points.

	placementPointBuffer = createBuffer(sizeof(placement_point), 100000, 0, true);
	transformBuffer = createBuffer(sizeof(placement_transform), 100000, 0, true);
	meshCountBuffer = createBuffer(sizeof(uint32), globalMeshOffset, 0, true, true);
	meshOffsetBuffer = createBuffer(sizeof(uint32), globalMeshOffset, 0, true, true);
	submeshToMeshBuffer = createBuffer(sizeof(uint32), (uint32)submeshToMesh.size(), submeshToMesh.data());
	drawIndirectBuffer = createBuffer(sizeof(placement_draw), (uint32)drawArgs.size(), drawArgs.data(), true);


#if READBACK
	readbackIndirect = createReadbackBuffer(sizeof(placement_draw), (uint32)drawArgs.size());
	readbackMeshCounts = createReadbackBuffer(sizeof(uint32), globalMeshOffset);
	readbackMeshOffsets = createReadbackBuffer(sizeof(uint32), globalMeshOffset);
#endif
}

void proc_placement_component::generate(const render_camera& camera, const terrain_component& terrain, vec3 positionOffset)
{
	if (!hasValidMeshes)
	{
		return;
	}

	dx_command_list* cl = dxContext.getFreeComputeCommandList(false);

	{
		PROFILE_ALL(cl, "Procedural placement");

		{
			PROFILE_ALL(cl, "Generate points");

			camera_frustum_planes frustum = camera.getWorldSpaceFrustumPlanes();

			const float radiusInUVSpace = sqrt(1.f / (2.f * sqrt(3.f) * arraysize(POISSON_SAMPLES)));
			float diameterInUVSpace = radiusInUVSpace * 2.f;
			float diameterInWorldSpace = diameterInUVSpace * terrain.chunkSize;

			cl->setPipelineState(*generatePointsPipeline.pipeline);
			cl->setComputeRootSignature(*generatePointsPipeline.rootSignature);

			vec3 minCorner = terrain.getMinCorner(positionOffset);
			vec3 chunkSize(terrain.chunkSize, terrain.amplitudeScale, terrain.chunkSize);

			cl->clearUAV(meshCountBuffer, 0u);

			for (uint32 z = 0; z < terrain.chunksPerDim; ++z)
			{
				for (uint32 x = 0; x < terrain.chunksPerDim; ++x)
				{
					auto& chunk = terrain.chunk(x, z);
					vec3 chunkMinCorner = minCorner + vec3(x * terrain.chunkSize, 0.f, z * terrain.chunkSize);
					vec3 chunkMaxCorner = chunkMinCorner + chunkSize;

					bounding_box aabb = { chunkMinCorner, chunkMaxCorner };
					if (!frustum.cullWorldSpaceAABB(aabb))
					{
						cl->setDescriptorHeapSRV(PROC_PLACEMENT_GENERATE_POINTS_RS_RESOURCES, 0, chunk.heightmap);
						cl->setDescriptorHeapSRV(PROC_PLACEMENT_GENERATE_POINTS_RS_RESOURCES, 1, chunk.normalmap);
						cl->setDescriptorHeapUAV(PROC_PLACEMENT_GENERATE_POINTS_RS_RESOURCES, 2, placementPointBuffer);
						cl->setDescriptorHeapUAV(PROC_PLACEMENT_GENERATE_POINTS_RS_RESOURCES, 3, meshCountBuffer);


						proc_placement_generate_points_cb cb;
						cb.amplitudeScale = terrain.amplitudeScale;
						cb.chunkCorner = chunkMinCorner;
						cb.chunkSize = terrain.chunkSize;

						for (const auto& layer : layers)
						{
							float footprint = layer.footprint;

							float scaling = diameterInWorldSpace / footprint;
							uint32 numGroupsPerDim = (uint32)ceil(scaling);

							cb.densities = vec4(0.f);
							for (uint32 i = 0; i < layer.numMeshes; ++i)
							{
								cb.densities.data[i] = layer.densities[i];
							}

							
							cb.uvScale = 1.f / scaling;
							cb.numMeshes = layer.numMeshes;
							cb.globalMeshOffset = layer.globalMeshOffset;

							cl->setCompute32BitConstants(PROC_PLACEMENT_GENERATE_POINTS_RS_CB, cb);

							cl->dispatch(numGroupsPerDim, numGroupsPerDim, 1);

							barrier_batcher(cl)
								.uav(placementPointBuffer)
								.uav(meshCountBuffer);
						}
					}
				}
			}
		}

		barrier_batcher(cl)
			.transition(meshCountBuffer, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_GENERIC_READ)
			.transition(placementPointBuffer, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_GENERIC_READ);

		{
			PROFILE_ALL(cl, "Prefix sum");
		
			cl->setPipelineState(*prefixSumPipeline.pipeline);
			cl->setComputeRootSignature(*prefixSumPipeline.rootSignature);
		
			cl->setCompute32BitConstants(PROC_PLACEMENT_PREFIX_SUM_RS_CB, prefix_sum_cb{ meshCountBuffer->elementCount - 1 });
		
			// Offset by 1 element, since that is the point count.
			cl->setRootComputeUAV(PROC_PLACEMENT_PREFIX_SUM_RS_OUTPUT, meshOffsetBuffer->gpuVirtualAddress + meshOffsetBuffer->elementSize);
			cl->setRootComputeSRV(PROC_PLACEMENT_PREFIX_SUM_RS_INPUT, meshCountBuffer->gpuVirtualAddress + meshCountBuffer->elementSize);
		
			cl->dispatch(1);
		}

		barrier_batcher(cl)
			.transition(meshOffsetBuffer, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_GENERIC_READ);
		
		{
			PROFILE_ALL(cl, "Create draw calls");
		
			cl->setPipelineState(*createDrawCallsPipeline.pipeline);
			cl->setComputeRootSignature(*createDrawCallsPipeline.rootSignature);
		
			proc_placement_create_draw_calls_cb cb;
			cb.transformAddressHigh = (uint32)(transformBuffer->gpuVirtualAddress >> 32);
			cb.transformAddressLow = (uint32)(transformBuffer->gpuVirtualAddress & 0xFFFFFFFF);
			cb.stride = transformBuffer->elementSize;
			cl->setCompute32BitConstants(PROC_PLACEMENT_CREATE_DRAW_CALLS_RS_CB, cb);
			cl->setRootComputeUAV(PROC_PLACEMENT_CREATE_DRAW_CALLS_RS_OUTPUT, drawIndirectBuffer);
			cl->setRootComputeSRV(PROC_PLACEMENT_CREATE_DRAW_CALLS_RS_MESH_COUNTS, meshCountBuffer);
			cl->setRootComputeSRV(PROC_PLACEMENT_CREATE_DRAW_CALLS_RS_MESH_OFFSETS, meshOffsetBuffer);
			cl->setRootComputeSRV(PROC_PLACEMENT_CREATE_DRAW_CALLS_RS_SUBMESH_TO_MESH, submeshToMeshBuffer);
		
			cl->dispatch(bucketize(drawIndirectBuffer->elementCount, PROC_PLACEMENT_CREATE_DRAW_CALLS_BLOCK_SIZE));
		}

#if READBACK
		cl->copyBufferRegionToBuffer(meshCountBuffer, readbackMeshCounts, 0, meshCountBuffer->elementCount, 0);
#endif

		barrier_batcher(cl)
			.transition(meshCountBuffer, D3D12_RESOURCE_STATE_GENERIC_READ, D3D12_RESOURCE_STATE_UNORDERED_ACCESS)
			.uav(drawIndirectBuffer);

		{
			PROFILE_ALL(cl, "Create transforms");
		
			cl->setPipelineState(*createTransformsPipeline.pipeline);
			cl->setComputeRootSignature(*createTransformsPipeline.rootSignature);
		
			cl->setRootComputeUAV(PROC_PLACEMENT_CREATE_TRANSFORMS_RS_TRANSFORMS, transformBuffer);
			cl->setRootComputeUAV(PROC_PLACEMENT_CREATE_TRANSFORMS_RS_MESH_COUNTS, meshCountBuffer);
			cl->setRootComputeSRV(PROC_PLACEMENT_CREATE_TRANSFORMS_RS_POINTS, placementPointBuffer);
			cl->setRootComputeSRV(PROC_PLACEMENT_CREATE_TRANSFORMS_RS_MESH_OFFSETS, meshOffsetBuffer);
		
			cl->dispatch(bucketize(placementPointBuffer->elementCount, PROC_PLACEMENT_CREATE_TRANSFORMS_BLOCK_SIZE)); // TODO
			cl->uavBarrier(transformBuffer);
			cl->uavBarrier(meshCountBuffer);
		}
	}

#if READBACK
	cl->transitionBarrier(drawIndirectBuffer, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_GENERIC_READ);
	cl->copyBufferRegionToBuffer(drawIndirectBuffer, readbackIndirect, 0, drawIndirectBuffer->elementCount, 0);
	cl->copyBufferRegionToBuffer(meshOffsetBuffer, readbackMeshOffsets, 0, meshOffsetBuffer->elementCount, 0);
#endif

	dxContext.executeCommandList(cl);


#if READBACK
	dxContext.flushApplication();

	{	
		placement_draw* draw = (placement_draw*)mapBuffer(readbackIndirect, true);
		uint32* offsets = (uint32*)mapBuffer(readbackMeshOffsets, true);
		uint32* counts = (uint32*)mapBuffer(readbackMeshCounts, true);

		for (uint32 i = 0; i < readbackIndirect->elementCount; ++i)
		{
			uint32 meshID = submeshToMesh[i];

			D3D12_GPU_VIRTUAL_ADDRESS expectedAddress = transformBuffer->gpuVirtualAddress + offsets[meshID] * transformBuffer->elementSize;
			uint32 expectedHigh = (uint32)(expectedAddress >> 32);
			uint32 expectedLow = (uint32)(expectedAddress & 0xFFFFFFFF);

			ASSERT(draw[i].transformSRVHigh == expectedHigh);
			ASSERT(draw[i].transformSRVLow == expectedLow);
		}

		LOG_MESSAGE("%u vs %u (%u), %u vs %u (%u), %u vs %u (%u)", 
			draw[0].draw.InstanceCount, counts[0], offsets[0], 
			draw[1].draw.InstanceCount, counts[1], offsets[1],
			draw[2].draw.InstanceCount, counts[2], offsets[2]);

		unmapBuffer(readbackMeshCounts, false);
		unmapBuffer(readbackMeshOffsets, false);
		unmapBuffer(readbackIndirect, false);
	}
#endif
}

void proc_placement_component::render(ldr_render_pass* renderPass)
{
#if 0
	render_proc_placement_layer_data data = { transformBuffer, drawIndirectBuffer, 0, visualizePointsMesh.vertexBuffer, visualizePointsMesh.indexBuffer };
	renderPass->renderObject<render_proc_placement_layer_pipeline>(data);
#else
	
	uint32 drawCallOffset = 1;

	for (const auto& layer : layers)
	{
		for (uint32 i = 0; i < layer.numMeshes; ++i)
		{
			for (uint32 j = 0; j < (uint32)layer.meshes[i]->submeshes.size(); ++j)
			{
				// TODO: We could pack the vertex and index buffer into the indirect call, but I'm not sure if that fits well with stuff like procedural objects.
				render_proc_placement_layer_data data = { drawIndirectBuffer, drawCallOffset,
					layer.meshes[i]->mesh.vertexBuffer, layer.meshes[i]->mesh.indexBuffer, layer.meshes[i]->submeshes[j].material->albedo };

				renderPass->renderObject<render_proc_placement_layer_pipeline>(data);

				++drawCallOffset;
			}
		}
	}

#endif
}

```

`src/terrain/proc_placement.h`:

```h
#pragma once

#include "terrain/terrain.h"


struct proc_placement_layer_desc
{
	const char* name;
	float footprint;
	ref<multi_mesh> meshes[4] = {};
};

struct proc_placement_component
{
	proc_placement_component(const std::vector<proc_placement_layer_desc>& layers);
	void generate(const render_camera& camera, const terrain_component& terrain, vec3 positionOffset);
	void render(struct ldr_render_pass* renderPass);


	struct placement_layer
	{
		const char* name;

		float footprint;

		uint32 globalMeshOffset;
		uint32 numMeshes;

		ref<multi_mesh> meshes[4];
		float densities[4] = { 0.25f, 0.25f, 0.25f, 0.25f };
	};


	std::vector<placement_layer> layers;

private:

	bool hasValidMeshes = false;

	std::vector<uint32> submeshToMesh;

	ref<dx_buffer> placementPointBuffer;
	ref<dx_buffer> transformBuffer;
	ref<dx_buffer> meshCountBuffer;
	ref<dx_buffer> meshOffsetBuffer;
	ref<dx_buffer> submeshToMeshBuffer;
	ref<dx_buffer> drawIndirectBuffer;
};


void initializeProceduralPlacementPipelines();


```

`src/terrain/terrain.cpp`:

```cpp
#include "pch.h"
#include "terrain.h"

#include "heightmap_collider.h"

#include "dx/dx_context.h"
#include "dx/dx_command_list.h"
#include "dx/dx_barrier_batcher.h"
#include "dx/dx_profiling.h"

#include "rendering/render_utils.h"
#include "rendering/render_pass.h"
#include "rendering/render_resources.h"
#include "rendering/texture_preprocessing.h"
#include "rendering/render_algorithms.h"

#include "core/random.h"
#include "core/job_system.h"
#include "scene/components.h"

#include "terrain_rs.hlsli"
#include "depth_only_rs.hlsli"


static dx_pipeline terrainGenerationPipeline;
static dx_pipeline terrainPipeline;
static dx_pipeline terrainDepthOnlyPipeline;
static dx_pipeline terrainShadowPipeline;
static dx_pipeline terrainOutlinePipeline;
static ref<dx_index_buffer> terrainIndexBuffers[TERRAIN_MAX_LOD + 1];




struct terrain_render_data_common
{
	vec3 minCorner;
	int32 lod;
	float chunkSize;
	float amplitudeScale;

	int32 lod_negX;
	int32 lod_posX;
	int32 lod_negZ;
	int32 lod_posZ;

	ref<dx_texture> heightmap;

	uint32 objectID;
};

struct terrain_render_data
{
	terrain_render_data_common common;

	ref<dx_texture> normalmap;

	ref<pbr_material> groundMaterial;
	ref<pbr_material> rockMaterial;
	ref<pbr_material> mudMaterial;

	dx_dynamic_constant_buffer waterPlanesCBV;
};

struct terrain_pipeline
{
	PIPELINE_SETUP_DECL;
	PIPELINE_RENDER_DECL(terrain_render_data);
};

struct terrain_depth_prepass_pipeline
{
	PIPELINE_SETUP_DECL;
	DEPTH_ONLY_RENDER_DECL(terrain_render_data_common);
};

struct terrain_shadow_pipeline
{
	PIPELINE_SETUP_DECL;
	PIPELINE_RENDER_DECL(terrain_render_data_common);
};

struct terrain_outline_pipeline
{
	PIPELINE_SETUP_DECL;
	PIPELINE_RENDER_DECL(terrain_render_data_common);
};





void initializeTerrainPipelines()
{
	terrainGenerationPipeline = createReloadablePipeline("terrain_generation_cs");

	{
		auto desc = CREATE_GRAPHICS_PIPELINE
			//.wireframe()
			.renderTargets(opaqueLightPassFormats, OPQAUE_LIGHT_PASS_NO_VELOCITIES_NO_OBJECT_ID, depthStencilFormat)
			.depthSettings(true, false, D3D12_COMPARISON_FUNC_EQUAL);

		terrainPipeline = createReloadablePipeline(desc, { "terrain_vs", "terrain_ps" });
	}
	{
		auto desc = CREATE_GRAPHICS_PIPELINE
			.renderTargets(depthOnlyFormat, arraysize(depthOnlyFormat), depthStencilFormat);

		terrainDepthOnlyPipeline = createReloadablePipeline(desc, { "terrain_depth_only_vs", "depth_only_ps" }, rs_in_vertex_shader);
	}
	{
		auto desc = CREATE_GRAPHICS_PIPELINE
			.renderTargets(0, 0, shadowDepthFormat);

		terrainShadowPipeline = createReloadablePipeline(desc, { "terrain_shadow_vs" }, rs_in_vertex_shader);
		//pointLightShadowPipeline = createReloadablePipeline(desc, { "shadow_point_light_vs", "shadow_point_light_ps" }, rs_in_vertex_shader);
	}
	{
		auto desc = CREATE_GRAPHICS_PIPELINE
			.renderTargets(0, 0, depthStencilFormat)
			.stencilSettings(D3D12_COMPARISON_FUNC_ALWAYS,
				D3D12_STENCIL_OP_REPLACE,
				D3D12_STENCIL_OP_REPLACE,
				D3D12_STENCIL_OP_KEEP,
				D3D12_DEFAULT_STENCIL_READ_MASK,
				stencil_flag_selected_object) // Mark selected object.
			.depthSettings(false, false);

		terrainOutlinePipeline = createReloadablePipeline(desc, { "terrain_outline_vs" }, rs_in_vertex_shader);
	}



	uint32 numSegmentsPerDim = TERRAIN_LOD_0_VERTICES_PER_DIMENSION - 1;
	uint32 numTrisLod0 = numSegmentsPerDim * numSegmentsPerDim * 2;

	indexed_triangle16* tris = new indexed_triangle16[numTrisLod0];

	for (uint32 lod = 0; lod < TERRAIN_MAX_LOD + 1; ++lod)
	{
		uint32 numSegmentsPerDim = (TERRAIN_LOD_0_VERTICES_PER_DIMENSION - 1) >> lod;
		uint32 stride = numSegmentsPerDim + 1;
		uint32 numTris = numSegmentsPerDim * numSegmentsPerDim * 2;

		uint32 i = 0;
		for (uint32 z = 0; z < numSegmentsPerDim; ++z)
		{
			for (uint32 x = 0; x < numSegmentsPerDim; ++x)
			{
				tris[i++] = { (uint16)(stride * z + x),		(uint16)(stride * (z + 1) + x), (uint16)(stride * z + x + 1) };
				tris[i++] = { (uint16)(stride * z + x + 1), (uint16)(stride * (z + 1) + x), (uint16)(stride * (z + 1) + x + 1) };
			}
		}

		terrainIndexBuffers[lod] = createIndexBuffer(sizeof(uint16), numTris * 3, tris);
	}

	delete[] tris;
}

PIPELINE_SETUP_IMPL(terrain_pipeline)
{
	cl->setPipelineState(*terrainPipeline.pipeline);
	cl->setGraphicsRootSignature(*terrainPipeline.rootSignature);

	cl->setPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

	cl->setGraphicsDynamicConstantBuffer(TERRAIN_RS_CAMERA, common.cameraCBV);
	cl->setGraphicsDynamicConstantBuffer(TERRAIN_RS_LIGHTING, common.lightingCBV);

	dx_cpu_descriptor_handle nullTexture = render_resources::nullTextureSRV;

	cl->setDescriptorHeapSRV(TERRAIN_RS_FRAME_CONSTANTS, 0, common.irradiance);
	cl->setDescriptorHeapSRV(TERRAIN_RS_FRAME_CONSTANTS, 1, common.prefilteredRadiance);
	cl->setDescriptorHeapSRV(TERRAIN_RS_FRAME_CONSTANTS, 2, render_resources::brdfTex);
	cl->setDescriptorHeapSRV(TERRAIN_RS_FRAME_CONSTANTS, 3, common.shadowMap);
	cl->setDescriptorHeapSRV(TERRAIN_RS_FRAME_CONSTANTS, 4, common.aoTexture ? common.aoTexture : render_resources::whiteTexture);
	cl->setDescriptorHeapSRV(TERRAIN_RS_FRAME_CONSTANTS, 5, common.sssTexture ? common.sssTexture : render_resources::whiteTexture);
	cl->setDescriptorHeapSRV(TERRAIN_RS_FRAME_CONSTANTS, 6, common.ssrTexture ? common.ssrTexture->defaultSRV : nullTexture);
}

static terrain_cb getTerrainCB(const terrain_render_data_common& common)
{
	uint32 lod_negX = max(0, common.lod_negX - common.lod);
	uint32 lod_posX = max(0, common.lod_posX - common.lod);
	uint32 lod_negZ = max(0, common.lod_negZ - common.lod);
	uint32 lod_posZ = max(0, common.lod_posZ - common.lod);

	uint32 scaleDownByLODs = SCALE_DOWN_BY_LODS(lod_negX, lod_posX, lod_negZ, lod_posZ);

	return terrain_cb{ common.minCorner, (uint32)common.lod, common.chunkSize, common.amplitudeScale, scaleDownByLODs };
}

PIPELINE_RENDER_IMPL(terrain_pipeline, terrain_render_data)
{
	PROFILE_ALL(cl, "Terrain");

	uint32 numSegmentsPerDim = (TERRAIN_LOD_0_VERTICES_PER_DIMENSION - 1) >> data.common.lod;
	uint32 numTris = numSegmentsPerDim * numSegmentsPerDim * 2;

	auto cb = getTerrainCB(data.common);

	cl->setGraphics32BitConstants(TERRAIN_RS_TRANSFORM, viewProj);
	cl->setGraphics32BitConstants(TERRAIN_RS_CB, cb);
	cl->setGraphicsDynamicConstantBuffer(TERRAIN_RS_WATER, data.waterPlanesCBV);
	cl->setDescriptorHeapSRV(TERRAIN_RS_HEIGHTMAP, 0, data.common.heightmap);
	cl->setDescriptorHeapSRV(TERRAIN_RS_NORMALMAP, 0, data.normalmap);

	cl->setDescriptorHeapSRV(TERRAIN_RS_TEXTURES, 0, data.groundMaterial->albedo ? data.groundMaterial->albedo : render_resources::blackTexture);
	cl->setDescriptorHeapSRV(TERRAIN_RS_TEXTURES, 1, data.groundMaterial->normal ? data.groundMaterial->normal : render_resources::defaultNormalMap);
	cl->setDescriptorHeapSRV(TERRAIN_RS_TEXTURES, 2, data.groundMaterial->roughness ? data.groundMaterial->roughness : render_resources::whiteTexture);

	cl->setDescriptorHeapSRV(TERRAIN_RS_TEXTURES, 3, data.rockMaterial->albedo ? data.rockMaterial->albedo : render_resources::blackTexture);
	cl->setDescriptorHeapSRV(TERRAIN_RS_TEXTURES, 4, data.rockMaterial->normal ? data.rockMaterial->normal : render_resources::defaultNormalMap);
	cl->setDescriptorHeapSRV(TERRAIN_RS_TEXTURES, 5, data.rockMaterial->roughness ? data.rockMaterial->roughness : render_resources::whiteTexture);

	cl->setDescriptorHeapSRV(TERRAIN_RS_TEXTURES, 6, data.mudMaterial->albedo ? data.mudMaterial->albedo : render_resources::blackTexture);
	cl->setDescriptorHeapSRV(TERRAIN_RS_TEXTURES, 7, data.mudMaterial->normal ? data.mudMaterial->normal : render_resources::defaultNormalMap);
	cl->setDescriptorHeapSRV(TERRAIN_RS_TEXTURES, 8, data.mudMaterial->roughness ? data.mudMaterial->roughness : render_resources::whiteTexture);

	cl->setIndexBuffer(terrainIndexBuffers[data.common.lod]);
	cl->drawIndexed(numTris * 3, 1, 0, 0, 0);
}


PIPELINE_SETUP_IMPL(terrain_depth_prepass_pipeline)
{
	cl->setPipelineState(*terrainDepthOnlyPipeline.pipeline);
	cl->setGraphicsRootSignature(*terrainDepthOnlyPipeline.rootSignature);

	cl->setPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
	
	cl->setGraphicsDynamicConstantBuffer(TERRAIN_DEPTH_ONLY_RS_CAMERA, common.cameraCBV);
}

DEPTH_ONLY_RENDER_IMPL(terrain_depth_prepass_pipeline, terrain_render_data_common)
{
	PROFILE_ALL(cl, "Terrain depth prepass");

	uint32 numSegmentsPerDim = (TERRAIN_LOD_0_VERTICES_PER_DIMENSION - 1) >> data.lod;
	uint32 numTris = numSegmentsPerDim * numSegmentsPerDim * 2;

	cl->setGraphics32BitConstants(TERRAIN_DEPTH_ONLY_RS_OBJECT_ID, data.objectID);
	cl->setGraphics32BitConstants(TERRAIN_DEPTH_ONLY_RS_TRANSFORM, depth_only_transform_cb{ viewProj, prevFrameViewProj });

	auto cb = getTerrainCB(data);
	cl->setGraphics32BitConstants(TERRAIN_DEPTH_ONLY_RS_CB, cb);
	cl->setDescriptorHeapSRV(TERRAIN_DEPTH_ONLY_RS_HEIGHTMAP, 0, data.heightmap);

	cl->setIndexBuffer(terrainIndexBuffers[data.lod]);
	cl->drawIndexed(numTris * 3, 1, 0, 0, 0);
}


PIPELINE_SETUP_IMPL(terrain_shadow_pipeline)
{
	cl->setPipelineState(*terrainShadowPipeline.pipeline);
	cl->setGraphicsRootSignature(*terrainShadowPipeline.rootSignature);

	cl->setPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
}

PIPELINE_RENDER_IMPL(terrain_shadow_pipeline, terrain_render_data_common)
{
	PROFILE_ALL(cl, "Terrain shadow");

	uint32 numSegmentsPerDim = (TERRAIN_LOD_0_VERTICES_PER_DIMENSION - 1) >> data.lod;
	uint32 numTris = numSegmentsPerDim * numSegmentsPerDim * 2;

	cl->setGraphics32BitConstants(TERRAIN_SHADOW_RS_TRANSFORM, viewProj);
	auto cb = getTerrainCB(data);
	cl->setGraphics32BitConstants(TERRAIN_SHADOW_RS_CB, cb);
	cl->setDescriptorHeapSRV(TERRAIN_SHADOW_RS_HEIGHTMAP, 0, data.heightmap);

	cl->setIndexBuffer(terrainIndexBuffers[data.lod]);
	cl->drawIndexed(numTris * 3, 1, 0, 0, 0);
}


PIPELINE_SETUP_IMPL(terrain_outline_pipeline)
{
	cl->setPipelineState(*terrainOutlinePipeline.pipeline);
	cl->setGraphicsRootSignature(*terrainOutlinePipeline.rootSignature);

	cl->setPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
}

PIPELINE_RENDER_IMPL(terrain_outline_pipeline, terrain_render_data_common)
{
	PROFILE_ALL(cl, "Terrain outline");

	uint32 numSegmentsPerDim = (TERRAIN_LOD_0_VERTICES_PER_DIMENSION - 1) >> data.lod;
	uint32 numTris = numSegmentsPerDim * numSegmentsPerDim * 2;

	cl->setGraphics32BitConstants(TERRAIN_OUTLINE_RS_TRANSFORM, terrain_transform_cb{ viewProj });

	auto cb = getTerrainCB(data);
	cl->setGraphics32BitConstants(TERRAIN_OUTLINE_RS_CB, cb);
	cl->setDescriptorHeapSRV(TERRAIN_OUTLINE_RS_HEIGHTMAP, 0, data.heightmap);

	cl->setIndexBuffer(terrainIndexBuffers[data.lod]);
	cl->drawIndexed(numTris * 3, 1, 0, 0, 0);
}















struct height_generator
{
	fbm_noise_2D noiseFunc = valueNoise;

	virtual float height(vec2 position) const = 0;
	virtual vec2 grad(vec2 position) const = 0;
};

struct height_generator_warped : height_generator
{
	terrain_generation_settings settings;

	virtual float height(vec2 position) const override
	{
		vec2 fbmPosition = position * settings.scale;

		vec3 domainWarpValue = fbm(noiseFunc, fbmPosition + settings.domainWarpNoiseOffset, settings.domainWarpOctaves);

		vec2 warpedFbmPosition = fbmPosition + vec2(domainWarpValue.x * settings.domainWarpStrength) + settings.noiseOffset + vec2(1000.f);
		vec3 value = fbm(noiseFunc, warpedFbmPosition); // We are using a lower number of noise octaves here, since the heightmap is lowres anyway.
		float height = value.x;

		height = height * 0.5f + 0.5f;

		return height;
	}

	virtual vec2 grad(vec2 position) const override
	{
		vec2 fbmPosition = position * settings.scale;
		float J_fbmPosition_position = settings.scale;

		vec3 domainWarpValue = fbm(noiseFunc, fbmPosition + settings.domainWarpNoiseOffset, settings.domainWarpOctaves);
		float domainWarpHeight = domainWarpValue.x;
		vec2 J_domainWarpHeight_fbmPosition = domainWarpValue.yz;

		vec2 warpedFbmPosition = fbmPosition + vec2(domainWarpHeight * settings.domainWarpStrength) + settings.noiseOffset + vec2(1000.f);
		float J_warpedFbmPosition_fbmPosition = 1.f;
		float J_warpedFbmPosition_domainWarpHeight = settings.domainWarpStrength;

		vec3 value = fbm(noiseFunc, warpedFbmPosition, settings.noiseOctaves);
		float height = value.x;
		vec2 J_height_warpedFbmPosition = value.yz;

		float scaledHeight = height * 0.5f + 0.5f;
		float J_scaledHeight_height = 0.5f;

		vec2 grad = J_scaledHeight_height * J_height_warpedFbmPosition *
			(J_warpedFbmPosition_fbmPosition + J_warpedFbmPosition_domainWarpHeight * J_domainWarpHeight_fbmPosition) * J_fbmPosition_position;

		return grad;
	}
};

struct height_generator_layered : height_generator
{
	float largeScaleWeight = 0.2f;
	float smallScaleWeight = 0.8f;

	virtual float height(vec2 position) const override
	{
		vec2 fbmPosition = position * 0.01f;

		vec2 largeScaleFbmPosition = position * 0.0001f;

		vec3 value = fbm(noiseFunc, fbmPosition);
		float height = value.x;

		vec3 largeScaleValue = fbm(noiseFunc, largeScaleFbmPosition, 3);
		float largeScaleHeight = largeScaleValue.x;

		height = largeScaleHeight * largeScaleWeight + height * smallScaleWeight;

		height = abs(height);

		height = 1.f - height;
		height = height * height;

		return height;
	}

	virtual vec2 grad(vec2 position) const override
	{
		vec2 fbmPosition = position * 0.01f;
		float J_fbmPosition_position = 0.01f;

		vec2 largeScaleFbmPosition = position * 0.0001f;
		float J_largeScaleFbmPosition_position = 0.0001f;

		vec3 value = fbm(noiseFunc, fbmPosition);
		float height = value.x;
		vec2 J_height_fbmPosition = value.yz;

		vec3 largeScaleValue = fbm(noiseFunc, largeScaleFbmPosition, 3);
		float largeScaleHeight = largeScaleValue.x;
		vec2 J_largeScaleHeight_largeScaleFbmPosition = largeScaleValue.yz;

		float combinedHeight = largeScaleHeight * largeScaleWeight + height * smallScaleWeight;
		vec2 J_combinedHeight_height = smallScaleWeight;
		vec2 J_combinedHeight_largeScaleHeight = largeScaleWeight;

		float absHeight = (combinedHeight < 0.f) ? -combinedHeight : combinedHeight;
		float J_absHeight_combinedHeight = (combinedHeight < 0.f) ? -1.f : 1.f;

		float oneMinusHeight = 1.f - absHeight;
		float J_oneMinusHeight_absHeight = -1.f;

		float powHeight = oneMinusHeight * oneMinusHeight;
		float J_powHeight_oneMinusHeight = 2.f * oneMinusHeight;

		vec2 J_combinedHeight_position =
			J_combinedHeight_height * J_height_fbmPosition * J_fbmPosition_position
			+ J_combinedHeight_largeScaleHeight * J_largeScaleHeight_largeScaleFbmPosition * J_largeScaleFbmPosition_position;

		vec2 grad =
			J_powHeight_oneMinusHeight
			* J_oneMinusHeight_absHeight
			* J_absHeight_combinedHeight
			* J_combinedHeight_position;

		return grad;
	}
};



const uint32 normalMapDimension = 2048;


terrain_component::terrain_component(uint32 chunksPerDim, float chunkSize, float amplitudeScale, 
	ref<pbr_material> groundMaterial, ref<pbr_material> rockMaterial, ref<pbr_material> mudMaterial,
	terrain_generation_settings genSettings)
	: chunksPerDim(chunksPerDim), 
	chunkSize(chunkSize), 
	genSettings(genSettings)
{
	oldGenSettings.scale = -FLT_MAX; // Set to garbage so that it is updated in the first frame.

	this->amplitudeScale = amplitudeScale;
	this->chunks.resize(chunksPerDim * chunksPerDim);

	this->groundMaterial = groundMaterial;
	this->rockMaterial = rockMaterial;
	this->mudMaterial = mudMaterial;
}

void terrain_component::generateChunksCPU()
{
	height_generator_warped generator;
	generator.settings = genSettings;

	struct terrain_gen_job_data
	{
		terrain_component& terrain;
		height_generator_warped generator;
	};

	terrain_gen_job_data data =
	{
		*this,
		generator,
	};

	job_handle parentJob = highPriorityJobQueue.createJob<terrain_gen_job_data>([](terrain_gen_job_data& data, job_handle parent)
	{
		for (int32 cz = 0; cz < (int32)data.terrain.chunksPerDim; ++cz)
		{
			for (int32 cx = 0; cx < (int32)data.terrain.chunksPerDim; ++cx)
			{
				struct chunk_gen_job_data
				{
					terrain_component& terrain;
					height_generator_warped generator;
					int32 cx, cz;
				};

				chunk_gen_job_data chunkData = 
				{
					data.terrain,
					data.generator,
					cx, cz,
				};

				job_handle job = highPriorityJobQueue.createJob<chunk_gen_job_data>([](chunk_gen_job_data& data, job_handle)
				{
					float chunkSize = data.terrain.chunkSize;
					uint32 numSegmentsPerDim = TERRAIN_LOD_0_VERTICES_PER_DIMENSION - 1;
					float positionScale = chunkSize / (float)numSegmentsPerDim;
					float normalScale = chunkSize / (float)(normalMapDimension - 1);

					int32 cx = data.cx;
					int32 cz = data.cz;
					height_generator_warped& generator = data.generator;
					float amplitudeScale = data.terrain.amplitudeScale;


					vec2 minCorner = vec2(cx * chunkSize, cz * chunkSize);

					auto& c = data.terrain.chunk(cx, cz);

					c.heights.resize(TERRAIN_LOD_0_VERTICES_PER_DIMENSION* TERRAIN_LOD_0_VERTICES_PER_DIMENSION);
					uint16* heights = c.heights.data();
					vec2* normals = new vec2[normalMapDimension * normalMapDimension];

					float minHeight = FLT_MAX;
					float maxHeight = -FLT_MAX;

					for (uint32 z = 0; z < TERRAIN_LOD_0_VERTICES_PER_DIMENSION; ++z)
					{
						for (uint32 x = 0; x < TERRAIN_LOD_0_VERTICES_PER_DIMENSION; ++x)
						{
							vec2 position = vec2(x * positionScale, z * positionScale) + minCorner;

							float height = generator.height(position);

							minHeight = min(minHeight, height * amplitudeScale);
							maxHeight = max(maxHeight, height * amplitudeScale);

							ASSERT(height >= 0.f);
							ASSERT(height <= 1.f);

							heights[z * TERRAIN_LOD_0_VERTICES_PER_DIMENSION + x] = (uint16)(height * UINT16_MAX);
						}
					}

					c.heightmap = createTexture(heights, TERRAIN_LOD_0_VERTICES_PER_DIMENSION, TERRAIN_LOD_0_VERTICES_PER_DIMENSION, DXGI_FORMAT_R16_UNORM, false, false, true, D3D12_RESOURCE_STATE_GENERIC_READ);


					for (uint32 z = 0; z < normalMapDimension; ++z)
					{
						for (uint32 x = 0; x < normalMapDimension; ++x)
						{
							vec2 position = vec2(x * normalScale, z * normalScale) + minCorner;

							vec2 grad = generator.grad(position);

							normals[z * normalMapDimension + x] = -grad;
						}
					}

					c.normalmap = createTexture(normals, normalMapDimension, normalMapDimension, DXGI_FORMAT_R32G32_FLOAT);

					delete[] normals;
				}, chunkData, parent);
			}
		}
	}, data);

	parentJob.submitNow();
	parentJob.waitForCompletion();
}

void terrain_component::generateChunksGPU()
{
	uint32 numSegmentsPerDim = TERRAIN_LOD_0_VERTICES_PER_DIMENSION - 1;
	float positionScale = chunkSize / (float)numSegmentsPerDim;
	float normalScale = chunkSize / (float)(normalMapDimension - 1);

	terrain_generation_settings_cb settings;
	settings.heightWidth = TERRAIN_LOD_0_VERTICES_PER_DIMENSION;
	settings.heightHeight = TERRAIN_LOD_0_VERTICES_PER_DIMENSION;
	settings.normalWidth = normalMapDimension;
	settings.normalHeight = normalMapDimension;
	settings.positionScale = positionScale;
	settings.normalScale = normalScale;

	settings.scale = genSettings.scale;
	settings.domainWarpStrength = genSettings.domainWarpStrength;
	settings.domainWarpNoiseOffset = genSettings.domainWarpNoiseOffset;
	settings.domainWarpOctaves = genSettings.domainWarpOctaves;
	settings.noiseOffset = genSettings.noiseOffset;
	settings.noiseOctaves = genSettings.noiseOctaves;

	auto settingsCBV = dxContext.uploadDynamicConstantBuffer(settings);


	bool mipmaps = true;


	dx_command_list* cl = dxContext.getFreeRenderCommandList();

	{
		PROFILE_ALL(cl, "Generate terrain chunks");

		for (int32 cz = 0; cz < (int32)chunksPerDim; ++cz)
		{
			for (int32 cx = 0; cx < (int32)chunksPerDim; ++cx)
			{
				cl->setPipelineState(*terrainGenerationPipeline.pipeline);
				cl->setComputeRootSignature(*terrainGenerationPipeline.rootSignature);
				cl->setComputeDynamicConstantBuffer(TERRAIN_GENERATION_RS_SETTINGS, settingsCBV);


				vec2 minCorner = vec2(cx * chunkSize, cz * chunkSize);

				auto& c = chunk(cx, cz);

				if (!c.heightmap)
				{
					c.heightmap = createTexture(0, TERRAIN_LOD_0_VERTICES_PER_DIMENSION, TERRAIN_LOD_0_VERTICES_PER_DIMENSION, DXGI_FORMAT_R16_UNORM, false, false, true, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);
					c.normalmap = createTexture(0, normalMapDimension, normalMapDimension, DXGI_FORMAT_R32G32_FLOAT, mipmaps, false, true, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);
				}
				else
				{
					barrier_batcher(cl)
						.transition(c.heightmap, D3D12_RESOURCE_STATE_GENERIC_READ, D3D12_RESOURCE_STATE_UNORDERED_ACCESS)
						.transition(c.normalmap, D3D12_RESOURCE_STATE_GENERIC_READ, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);
				}

				terrain_generation_cb cb;
				cb.minCorner = minCorner;

				cl->setCompute32BitConstants(TERRAIN_GENERATION_RS_CB, cb);
				cl->setDescriptorHeapUAV(TERRAIN_GENERATION_RS_TEXTURES, 0, c.heightmap);
				cl->setDescriptorHeapUAV(TERRAIN_GENERATION_RS_TEXTURES, 1, c.normalmap);

				cl->dispatch(bucketize(normalMapDimension, 16), bucketize(normalMapDimension, 16));






				barrier_batcher(cl)
					.transition(c.heightmap, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_GENERIC_READ)
					.transition(c.normalmap, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_GENERIC_READ);

				if (mipmaps)
				{
					generateMipMapsOnGPU(cl, c.normalmap);
				}

			}
		}

	}

	dxContext.executeCommandList(cl);


	{
		CPU_PROFILE_BLOCK("Copy heights to CPU");

		for (int32 cz = 0; cz < (int32)chunksPerDim; ++cz)
		{
			for (int32 cx = 0; cx < (int32)chunksPerDim; ++cx)
			{
				auto& c = chunk(cx, cz);

				c.heights.resize(TERRAIN_LOD_0_VERTICES_PER_DIMENSION * TERRAIN_LOD_0_VERTICES_PER_DIMENSION);
				copyTextureToCPUBuffer(c.heightmap, c.heights.data(), D3D12_RESOURCE_STATE_GENERIC_READ);
			}
		}
	}
}

void terrain_component::update(vec3 positionOffset, heightmap_collider_component* collider)
{
	if (memcmp(&genSettings, &oldGenSettings, sizeof(terrain_generation_settings)) != 0)
	{
		generateChunksGPU();

		oldGenSettings = genSettings;

		if (collider)
		{
			for (int32 cz = 0; cz < (int32)chunksPerDim; ++cz)
			{
				for (int32 cx = 0; cx < (int32)chunksPerDim; ++cx)
				{
					auto& terrainChunk = chunk(cx, cz);
					auto& terrainCollider = collider->collider(cx, cz);

					terrainCollider.setHeights(terrainChunk.heights.data());
				}
			}
		}
	}

	if (collider)
	{
		collider->update(getMinCorner(positionOffset), amplitudeScale);
	}
}

void terrain_component::render(const render_camera& camera, struct opaque_render_pass* renderPass, struct sun_shadow_render_pass* shadowPass, struct ldr_render_pass* ldrPass,
	vec3 positionOffset, uint32 entityID, bool selected,
	struct position_scale_component* waterPlaneTransforms, uint32 numWaters)
{
	camera_frustum_planes frustum = camera.getWorldSpaceFrustumPlanes();
	camera_frustum_planes sunFrustum = {};
	if (shadowPass)
	{
		sunFrustum = getWorldSpaceFrustumPlanes(shadowPass->cascades[shadowPass->numCascades - 1].viewProj);
	}

	positionOffset = getMinCorner(positionOffset);

	int32 lodStride = (chunksPerDim + 2);
	uint32 paddedNumChunks = (chunksPerDim + 2) * (chunksPerDim + 2);
	int32* lodBuffer = (int32*)alloca(sizeof(int32) * paddedNumChunks);
	int32* lods = lodBuffer + lodStride + 1;

	vec3 chunkCenterOffset = vec3(chunkSize, 0.f, chunkSize) * 0.5f;

	for (int32 z = -1; z < (int32)chunksPerDim + 1; ++z)
	{
		for (int32 x = -1; x < (int32)chunksPerDim + 1; ++x)
		{
			vec3 localMinCorner(x * chunkSize, 0.f, z * chunkSize);
			vec3 minCorner = localMinCorner + positionOffset;
			vec3 chunkCenter = minCorner + chunkCenterOffset;

			float distance = length(chunkCenter - camera.position);
			int32 lod = (int32)(saturate(distance / 500.f) * TERRAIN_MAX_LOD);
			lods[z * lodStride + x] = lod;
		}
	}

	terrain_water_plane_cb waterPlanes;
	waterPlanes.numWaterPlanes = min(numWaters, 4u);
	for (uint32 i = 0; i < waterPlanes.numWaterPlanes; ++i)
	{
		vec3 pos = waterPlaneTransforms[i].position;
		vec3 scale = waterPlaneTransforms[i].scale;
		waterPlanes.waterMinMaxXZ[i] = vec4(pos.x, pos.z, pos.x, pos.z) + vec4(-scale.x, -scale.z, scale.x, scale.z);
		waterPlanes.waterHeights.data[i] = pos.y;
	}

	auto waterCBV = dxContext.uploadDynamicConstantBuffer(waterPlanes);

	for (int32 z = 0; z < (int32)chunksPerDim; ++z)
	{
		for (int32 x = 0; x < (int32)chunksPerDim; ++x)
		{
			const terrain_chunk& c = chunk(x, z);

			int32 lod = lods[z * lodStride + x];

			vec3 localMinCorner(x * chunkSize, 0.f, z * chunkSize);
			vec3 minCorner = localMinCorner + positionOffset;
			vec3 maxCorner = minCorner + vec3(chunkSize, amplitudeScale, chunkSize);

			terrain_render_data_common common =
			{
				minCorner,
				lod,
				chunkSize,
				amplitudeScale,
				lods[(z)*lodStride + (x - 1)],
				lods[(z)*lodStride + (x + 1)],
				lods[(z - 1) * lodStride + (x)],
				lods[(z + 1) * lodStride + (x)],
				c.heightmap,
				entityID,
			};

			bounding_box aabb = { minCorner, maxCorner };
			if (!frustum.cullWorldSpaceAABB(aabb))
			{
				terrain_render_data data = {
					common,
					c.normalmap,
					groundMaterial, rockMaterial, mudMaterial,
					waterCBV
				};
				renderPass->renderObject<terrain_pipeline, terrain_depth_prepass_pipeline>(data, common);
			}

			if (shadowPass)
			{
				if (!sunFrustum.cullWorldSpaceAABB(aabb))
				{
					shadowPass->renderStaticObject<terrain_shadow_pipeline>(0, common);
				}
			}

			if (ldrPass && selected)
			{
				ldrPass->renderOutline<terrain_outline_pipeline>(common);
			}
		}
	}
}
















```

`src/terrain/terrain.h`:

```h
#pragma once

#include "core/math.h"
#include "core/camera.h"

#include "dx/dx_texture.h"

#include "rendering/material.h"
#include "rendering/render_command.h"

struct terrain_chunk
{
	ref<dx_texture> heightmap;
	ref<dx_texture> normalmap;

	std::vector<uint16> heights;
};

struct terrain_generation_settings
{
	float scale = 0.01f;
	
	float domainWarpStrength = 1.2f;
	vec2 domainWarpNoiseOffset = vec2(0.f, 0.f);
	uint32 domainWarpOctaves = 3;
	
	vec2 noiseOffset = vec2(0.f, 0.f);
	uint32 noiseOctaves = 15;
};

struct terrain_component
{
	terrain_component(uint32 chunksPerDim, float chunkSize, float amplitudeScale, 
		ref<pbr_material> groundMaterial, ref<pbr_material> rockMaterial, ref<pbr_material> mudMaterial,
		terrain_generation_settings genSettings = {});
	terrain_component(const terrain_component&) = default;
	terrain_component(terrain_component&&) = default;
	terrain_component& operator=(const terrain_component&) = default;
	terrain_component& operator=(terrain_component&&) = default;

	terrain_chunk& chunk(uint32 x, uint32 z) { return chunks[z * chunksPerDim + x]; }
	const terrain_chunk& chunk(uint32 x, uint32 z) const { return chunks[z * chunksPerDim + x]; }

	uint32 chunksPerDim;
	float chunkSize;
	float amplitudeScale;

	terrain_generation_settings genSettings;

	ref<pbr_material> groundMaterial;
	ref<pbr_material> rockMaterial;
	ref<pbr_material> mudMaterial;


	vec3 getMinCorner(vec3 positionOffset) const
	{
		float xzOffset = -(chunkSize * chunksPerDim) * 0.5f; // Offsets entire terrain by half.
		return positionOffset + vec3(xzOffset, 0.f, xzOffset);
	}

	void update(vec3 positionOffset, struct heightmap_collider_component* collider = 0);
	void render(const render_camera& camera, struct opaque_render_pass* renderPass, struct sun_shadow_render_pass* shadowPass, struct ldr_render_pass* ldrPass,
		vec3 positionOffset, uint32 entityID = -1, bool selected = false,
		struct position_scale_component* waterPlaneTransforms = 0, uint32 numWaters = 0);

private:
	void generateChunksCPU();
	void generateChunksGPU();

	terrain_generation_settings oldGenSettings;

	std::vector<terrain_chunk> chunks;

	friend struct grass_component;
};


void initializeTerrainPipelines();







```

`src/terrain/tree.cpp`:

```cpp
#include "pch.h"
#include "tree.h"

#include "core/color.h"
#include "core/nearest_neighbor.h"

#include "dx/dx_pipeline.h"

#include "rendering/render_resources.h"
#include "rendering/pbr.h"
#include "rendering/render_pass.h"

#include "tree_rs.hlsli"



static dx_pipeline treePipeline;


void initializeTreePipelines()
{
    {
        auto desc = CREATE_GRAPHICS_PIPELINE
            .inputLayout(inputLayout_position_uv_normal_tangent_colors)
            //.depthSettings(true, false, D3D12_COMPARISON_FUNC_EQUAL)
            .cullingOff()
            .renderTargets(opaqueLightPassFormats, OPQAUE_LIGHT_PASS_NO_VELOCITIES_NO_OBJECT_ID, depthStencilFormat);

        treePipeline = createReloadablePipeline(desc, { "tree_vs", "tree_ps" });
    }
}


struct tree_render_data
{
    D3D12_GPU_VIRTUAL_ADDRESS transformPtr;
    dx_vertex_buffer_group_view vertexBuffer;
    dx_index_buffer_view indexBuffer;
    submesh_info submesh;

    ref<pbr_material> material;

    float time;

    uint32 numInstances;
};

struct tree_pipeline
{
    PIPELINE_SETUP_DECL
    {
        cl->setPipelineState(*treePipeline.pipeline);
        cl->setGraphicsRootSignature(*treePipeline.rootSignature);

        cl->setPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

        dx_cpu_descriptor_handle nullTexture = render_resources::nullTextureSRV;
        dx_cpu_descriptor_handle nullBuffer = render_resources::nullBufferSRV;

        cl->setDescriptorHeapSRV(TREE_RS_FRAME_CONSTANTS, 0, common.irradiance ? common.irradiance->defaultSRV : nullTexture);
        cl->setDescriptorHeapSRV(TREE_RS_FRAME_CONSTANTS, 1, common.prefilteredRadiance ? common.prefilteredRadiance->defaultSRV : nullTexture);
        cl->setDescriptorHeapSRV(TREE_RS_FRAME_CONSTANTS, 2, render_resources::brdfTex);
        cl->setDescriptorHeapSRV(TREE_RS_FRAME_CONSTANTS, 3, common.tiledCullingGrid ? common.tiledCullingGrid->defaultSRV : nullTexture);
        cl->setDescriptorHeapSRV(TREE_RS_FRAME_CONSTANTS, 4, common.tiledObjectsIndexList ? common.tiledObjectsIndexList->defaultSRV : nullBuffer);
        cl->setDescriptorHeapSRV(TREE_RS_FRAME_CONSTANTS, 5, common.pointLightBuffer ? common.pointLightBuffer->defaultSRV : nullBuffer);
        cl->setDescriptorHeapSRV(TREE_RS_FRAME_CONSTANTS, 6, common.spotLightBuffer ? common.spotLightBuffer->defaultSRV : nullBuffer);
        cl->setDescriptorHeapSRV(TREE_RS_FRAME_CONSTANTS, 7, common.decalBuffer ? common.decalBuffer->defaultSRV : nullBuffer);
        cl->setDescriptorHeapSRV(TREE_RS_FRAME_CONSTANTS, 8, common.shadowMap ? common.shadowMap->defaultSRV : nullTexture);
        cl->setDescriptorHeapSRV(TREE_RS_FRAME_CONSTANTS, 9, common.pointLightShadowInfoBuffer ? common.pointLightShadowInfoBuffer->defaultSRV : nullBuffer);
        cl->setDescriptorHeapSRV(TREE_RS_FRAME_CONSTANTS, 10, common.spotLightShadowInfoBuffer ? common.spotLightShadowInfoBuffer->defaultSRV : nullBuffer);
        cl->setDescriptorHeapSRV(TREE_RS_FRAME_CONSTANTS, 11, common.decalTextureAtlas ? common.decalTextureAtlas->defaultSRV : nullTexture);
        cl->setDescriptorHeapSRV(TREE_RS_FRAME_CONSTANTS, 12, common.aoTexture ? common.aoTexture : render_resources::whiteTexture);
        cl->setDescriptorHeapSRV(TREE_RS_FRAME_CONSTANTS, 13, common.sssTexture ? common.sssTexture : render_resources::whiteTexture);
        cl->setDescriptorHeapSRV(TREE_RS_FRAME_CONSTANTS, 14, common.ssrTexture ? common.ssrTexture->defaultSRV : nullTexture);
        cl->setDescriptorHeapSRV(TREE_RS_FRAME_CONSTANTS, 15, common.lightProbeIrradiance ? common.lightProbeIrradiance->defaultSRV : nullTexture);
        cl->setDescriptorHeapSRV(TREE_RS_FRAME_CONSTANTS, 16, common.lightProbeDepth ? common.lightProbeDepth->defaultSRV : nullTexture);

        cl->setGraphicsDynamicConstantBuffer(TREE_RS_CAMERA, common.cameraCBV);
        cl->setGraphicsDynamicConstantBuffer(TREE_RS_LIGHTING, common.lightingCBV);
    }

    PIPELINE_RENDER_DECL(tree_render_data)
    {
        const auto& mat = data.material;

        uint32 flags = 0;

        if (mat->albedo)
        {
            cl->setDescriptorHeapSRV(TREE_RS_PBR_TEXTURES, 0, mat->albedo);
            flags |= MATERIAL_USE_ALBEDO_TEXTURE;
        }
        if (mat->normal)
        {
            cl->setDescriptorHeapSRV(TREE_RS_PBR_TEXTURES, 1, mat->normal);
            flags |= MATERIAL_USE_NORMAL_TEXTURE;
        }
        if (mat->roughness)
        {
            cl->setDescriptorHeapSRV(TREE_RS_PBR_TEXTURES, 2, mat->roughness);
            flags |= MATERIAL_USE_ROUGHNESS_TEXTURE;
        }
        if (mat->metallic)
        {
            cl->setDescriptorHeapSRV(TREE_RS_PBR_TEXTURES, 3, mat->metallic);
            flags |= MATERIAL_USE_METALLIC_TEXTURE;
        }
        flags |= MATERIAL_DOUBLE_SIDED; // Always double sided.

        cl->setGraphics32BitConstants(TREE_RS_MATERIAL,
            pbr_material_cb(mat->albedoTint, mat->emission.xyz, mat->roughnessOverride, mat->metallicOverride, flags, 1.f, mat->translucency, mat->uvScale)
        );



        const submesh_info& submesh = data.submesh;

        cl->setRootGraphicsSRV(TREE_RS_TRANSFORM, data.transformPtr);
        cl->setGraphics32BitConstants(TREE_RS_CB, tree_cb{ data.time });

        cl->setVertexBuffer(0, data.vertexBuffer.positions);
        cl->setVertexBuffer(1, data.vertexBuffer.others);
        cl->setIndexBuffer(data.indexBuffer);
        cl->drawIndexed(submesh.numIndices, data.numInstances, submesh.firstIndex, submesh.baseVertex, 0);
    }
};

void renderTree(opaque_render_pass* renderPass, D3D12_GPU_VIRTUAL_ADDRESS transforms, uint32 numInstances, const multi_mesh* mesh, float dt)
{
    static float time = 0.f;
    time += dt;


    const dx_mesh& dxMesh = mesh->mesh;

    for (auto& sm : mesh->submeshes)
    {
        submesh_info submesh = sm.info;
        const ref<pbr_material>& material = sm.material;

        tree_render_data data;
        data.transformPtr = transforms;
        data.vertexBuffer = dxMesh.vertexBuffer;
        data.indexBuffer = dxMesh.indexBuffer;
        data.submesh = submesh;
        data.material = material;
        data.time = time;
        data.numInstances = numInstances;

        renderPass->renderObject<tree_pipeline>(data);
    }
}




struct tree_mesh_others
{
    vec2 uv;
    vec3 normal;
    vec3 tangent;
    uint32 color;
};

static uint32 countVertices(std::vector<submesh>& submeshes, const tree_mesh_others* others, uint32 color)
{
    uint32 count = 0;

    for (auto& sub : submeshes)
    {
        for (uint32 i = 0; i < sub.info.numVertices; ++i)
        {
            uint32 vertexID = i + sub.info.baseVertex;
            uint32 c = others[vertexID].color;

            count += c == color;
        }
    }

    return count;
}

static void fillVertices(std::vector<submesh>& submeshes, const vec3* positions, const tree_mesh_others* others, uint32 color, vec3* outPositions)
{
    for (auto& sub : submeshes)
    {
        for (uint32 i = 0; i < sub.info.numVertices; ++i)
        {
            uint32 vertexID = i + sub.info.baseVertex;
            uint32 c = others[vertexID].color;

            if (c == color)
            {
                *outPositions++ = positions[vertexID];
            }
        }
    }
}

static void analyzeTreeMesh(mesh_builder& builder, std::vector<submesh>& submeshes, const bounding_box& boundingBox)
{
    const uint32 trunkVertexColor = 0xFF000000;  // Black.
    const uint32 branchVertexColor = 0xFFFFFFFF; // White.

    vec3* positions = builder.getPositions();
    tree_mesh_others* others = (tree_mesh_others*)builder.getOthers();

    uint32 numTrunkVertices = countVertices(submeshes, others, trunkVertexColor);
    uint32 numBranchVertices = countVertices(submeshes, others, branchVertexColor);

    vec3* trunkPositions = new vec3[numTrunkVertices];
    vec3* branchPositions = new vec3[numBranchVertices];

    fillVertices(submeshes, positions, others, trunkVertexColor, trunkPositions);
    fillVertices(submeshes, positions, others, branchVertexColor, branchPositions);

    point_cloud trunkPC(trunkPositions, numTrunkVertices);
    point_cloud branchPC(branchPositions, numBranchVertices);


    float scale = 1.f / (boundingBox.maxCorner.y - boundingBox.minCorner.y);

    for (auto& sub : submeshes)
    {
        for (uint32 i = 0; i < sub.info.numVertices; ++i)
        {
            uint32 vertexID = i + sub.info.baseVertex;

            vec3 query = positions[vertexID];

            float distanceToTrunk = sqrt(trunkPC.nearestNeighborIndex(query).squaredDistance);
            float distanceToBranch = sqrt(branchPC.nearestNeighborIndex(query).squaredDistance);

            distanceToBranch = min(distanceToTrunk, distanceToBranch);

            others[vertexID].color = packColor(
                saturate(inverseLerp(boundingBox.minCorner.y, boundingBox.maxCorner.y, query.y)),
                distanceToTrunk * scale,
                distanceToBranch * scale,
                1.f);

            int a = 0;
        }
    }

    delete[] trunkPositions;
    delete[] branchPositions;
}

ref<multi_mesh> loadTreeMeshFromFile(const fs::path& sceneFilename)
{
    return loadMeshFromFile(sceneFilename, mesh_creation_flags_default | mesh_creation_flags_with_colors, analyzeTreeMesh);
}

ref<multi_mesh> loadTreeMeshFromHandle(asset_handle handle)
{
    return loadMeshFromHandle(handle, mesh_creation_flags_default | mesh_creation_flags_with_colors, analyzeTreeMesh);
}

ref<multi_mesh> loadTreeMeshFromFileAsync(const fs::path& sceneFilename, job_handle parentJob)
{
    return loadMeshFromFileAsync(sceneFilename, mesh_creation_flags_default | mesh_creation_flags_with_colors, parentJob, analyzeTreeMesh);
}

ref<multi_mesh> loadTreeMeshFromHandleAsync(asset_handle handle, job_handle parentJob)
{
    return loadMeshFromHandleAsync(handle, mesh_creation_flags_default | mesh_creation_flags_with_colors, parentJob, analyzeTreeMesh);
}


```

`src/terrain/tree.h`:

```h
#pragma once

#include "geometry/mesh.h"
#include "rendering/material.h"
#include "rendering/pbr.h"
#include "core/job_system.h"

struct tree_settings
{
	float bendStrength;
};

struct tree_component
{
	tree_settings settings;
};

void renderTree(struct opaque_render_pass* renderPass, D3D12_GPU_VIRTUAL_ADDRESS transforms, uint32 numInstances, const multi_mesh* mesh, float dt);


void initializeTreePipelines();

ref<multi_mesh> loadTreeMeshFromFile(const fs::path& sceneFilename);
ref<multi_mesh> loadTreeMeshFromHandle(asset_handle handle);

ref<multi_mesh> loadTreeMeshFromFileAsync(const fs::path& sceneFilename, job_handle parentJob = {});
ref<multi_mesh> loadTreeMeshFromHandleAsync(asset_handle handle, job_handle parentJob = {});


```

`src/terrain/water.cpp`:

```cpp
#include "pch.h"
#include "water.h"

#include "dx/dx_buffer.h"
#include "dx/dx_pipeline.h"
#include "dx/dx_profiling.h"

#include "rendering/render_utils.h"
#include "rendering/render_pass.h"
#include "rendering/render_resources.h"

#include "geometry/mesh_builder.h"

#include "water_rs.hlsli"
#include "transform.hlsli"


static dx_pipeline waterPipeline;

static ref<dx_texture> normalmap1;
static ref<dx_texture> normalmap2;
static ref<dx_texture> foamTexture;
static ref<dx_texture> noiseTexture;

void initializeWaterPipelines()
{
	{
		auto desc = CREATE_GRAPHICS_PIPELINE
			.cullingOff()
			.renderTargets(transparentLightPassFormats, arraysize(transparentLightPassFormats), depthStencilFormat);

		waterPipeline = createReloadablePipeline(desc, { "water_vs", "water_ps" });
	}

	normalmap1 = loadTextureFromFileAsync("assets/water/waterNM1.png", image_load_flags_noncolor | image_load_flags_gen_mips_on_cpu | image_load_flags_cache_to_dds);
	normalmap2 = loadTextureFromFileAsync("assets/water/waterNM2.png", image_load_flags_noncolor | image_load_flags_gen_mips_on_cpu | image_load_flags_cache_to_dds);
	foamTexture = loadTextureFromFileAsync("assets/water/waterFoam.dds", image_load_flags_noncolor | image_load_flags_gen_mips_on_cpu | image_load_flags_cache_to_dds);
	noiseTexture = loadTextureFromFileAsync("assets/water/waterNoise.dds", image_load_flags_noncolor | image_load_flags_gen_mips_on_cpu | image_load_flags_cache_to_dds);
}


struct water_render_data
{
	mat4 m;

	water_settings settings;
	float time;
};

struct water_pipeline
{
	PIPELINE_SETUP_DECL;
	PIPELINE_RENDER_DECL(water_render_data);
};

PIPELINE_SETUP_IMPL(water_pipeline)
{
	cl->setPipelineState(*waterPipeline.pipeline);
	cl->setGraphicsRootSignature(*waterPipeline.rootSignature);

	cl->setPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
	
	cl->setGraphicsDynamicConstantBuffer(WATER_RS_CAMERA, common.cameraCBV);
	cl->setGraphicsDynamicConstantBuffer(WATER_RS_LIGHTING, common.lightingCBV);
	cl->setDescriptorHeapSRV(WATER_RS_TEXTURES, 0, common.opaqueColor);
	cl->setDescriptorHeapSRV(WATER_RS_TEXTURES, 1, common.opaqueDepth);
	cl->setDescriptorHeapSRV(WATER_RS_TEXTURES, 2, normalmap1 ? normalmap1 : render_resources::defaultNormalMap);
	cl->setDescriptorHeapSRV(WATER_RS_TEXTURES, 3, normalmap2 ? normalmap2 : render_resources::defaultNormalMap);
	cl->setDescriptorHeapSRV(WATER_RS_TEXTURES, 4, foamTexture ? foamTexture : render_resources::blackTexture);
	cl->setDescriptorHeapSRV(WATER_RS_TEXTURES, 5, noiseTexture ? noiseTexture : render_resources::blackTexture);

	dx_cpu_descriptor_handle nullTexture = render_resources::nullTextureSRV;

	cl->setDescriptorHeapSRV(WATER_RS_FRAME_CONSTANTS, 0, common.irradiance);
	cl->setDescriptorHeapSRV(WATER_RS_FRAME_CONSTANTS, 1, common.prefilteredRadiance);
	cl->setDescriptorHeapSRV(WATER_RS_FRAME_CONSTANTS, 2, render_resources::brdfTex);
	cl->setDescriptorHeapSRV(WATER_RS_FRAME_CONSTANTS, 3, common.shadowMap);
	cl->setDescriptorHeapSRV(WATER_RS_FRAME_CONSTANTS, 4, common.aoTexture ? common.aoTexture : render_resources::whiteTexture);
	cl->setDescriptorHeapSRV(WATER_RS_FRAME_CONSTANTS, 5, common.sssTexture ? common.sssTexture : render_resources::whiteTexture);
	cl->setDescriptorHeapSRV(WATER_RS_FRAME_CONSTANTS, 6, common.ssrTexture ? common.ssrTexture->defaultSRV : nullTexture);
}

PIPELINE_RENDER_IMPL(water_pipeline, water_render_data)
{
	PROFILE_ALL(cl, "Water");

	water_cb cb;
	cb.deepColor = data.settings.deepWaterColor;
	cb.shallowColor = data.settings.shallowWaterColor;
	cb.shallowDepth = data.settings.shallowDepth;
	cb.transitionStrength = data.settings.transitionStrength;
	cb.uvOffset = normalize(vec2(1.f, 1.f)) * data.time * 0.05f;
	cb.uvScale = data.settings.uvScale;
	cb.normalmapStrength = data.settings.normalStrength;

	cl->setGraphics32BitConstants(WATER_RS_TRANSFORM, transform_cb{ viewProj * data.m, data.m });
	cl->setGraphics32BitConstants(WATER_RS_SETTINGS, cb);
	cl->draw(4, 1, 0, 0);
}

void water_component::render(const render_camera& camera, transparent_render_pass* renderPass, vec3 positionOffset, vec2 scale, float dt, uint32 entityID)
{
	time += dt;
	renderPass->renderObject<water_pipeline, water_render_data>({ createModelMatrix(positionOffset, quat::identity, vec3(scale.x, 1.f, scale.y)), settings, time });
}

```

`src/terrain/water.h`:

```h
#pragma once

#include "core/math.h"
#include "core/camera.h"

struct water_settings
{
	vec4 deepWaterColor = vec4(0.f, 0.241f, 0.799f, 0.76f);
	vec4 shallowWaterColor = vec4(0.120f, 0.546f, 0.941f, 0.176f);
	float uvScale = 0.5f;
	float shallowDepth = 3.f;
	float transitionStrength = 0.07f;
	float normalStrength = 1.f;
};

struct water_component
{
	void render(const render_camera& camera, struct transparent_render_pass* renderPass, vec3 positionOffset, vec2 scale, float dt, uint32 entityID = -1);

	water_settings settings;

private:
	float time = 0.f;
};

void initializeWaterPipelines();

```

`src/window/dx_window.cpp`:

```cpp
#include "pch.h"
#include "dx_window.h"
#include "dx/dx_context.h"



static bool checkTearingSupport(dx_factory factory)
{
	BOOL allowTearing = FALSE;

	// Rather than create the DXGI 1.5 factory interface directly, we create the
	// DXGI 1.4 interface and query for the 1.5 interface. This is to enable the 
	// graphics debugging tools which will not support the 1.5 factory interface 
	// until a future update.
	com<IDXGIFactory5> factory5;
	if (SUCCEEDED(factory.As(&factory5)))
	{
		if (FAILED(factory5->CheckFeatureSupport(
			DXGI_FEATURE_PRESENT_ALLOW_TEARING,
			&allowTearing, sizeof(allowTearing))))
		{
			allowTearing = FALSE;
		}
	}

	return allowTearing == TRUE;
}

static dx_swapchain createSwapChain(HWND windowHandle,
	dx_factory factory, const dx_command_queue& commandQueue,
	uint32 width, uint32 height, uint32 bufferCount, bool tearingSupported, color_depth colorDepth, bool exclusiveFullscreen)
{
	dx_swapchain dxgiSwapChain;

	DXGI_SWAP_CHAIN_DESC1 swapChainDesc = {};
	swapChainDesc.Width = width;
	swapChainDesc.Height = height;
	swapChainDesc.Format = colorDepthToFormat(colorDepth);
	swapChainDesc.Stereo = FALSE;
	swapChainDesc.SampleDesc = { 1, 0 };
	swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
	swapChainDesc.BufferCount = bufferCount;
	swapChainDesc.Scaling = DXGI_SCALING_STRETCH;
	swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;
	swapChainDesc.AlphaMode = DXGI_ALPHA_MODE_UNSPECIFIED;

	// It is recommended to always allow tearing if tearing support is available.
	swapChainDesc.Flags = tearingSupported ? DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING : 0;

	com<IDXGISwapChain1> swapChain1;
	checkResult(factory->CreateSwapChainForHwnd(
		commandQueue.commandQueue.Get(),
		windowHandle,
		&swapChainDesc,
		0,
		0,
		&swapChain1));

	UINT flags = 0;
	if (!exclusiveFullscreen)
	{
		// Disable the Alt+Enter fullscreen toggle feature. Switching to fullscreen
		// will be handled manually.
		flags = DXGI_MWA_NO_ALT_ENTER;
	}
	checkResult(factory->MakeWindowAssociation(windowHandle, flags));

	checkResult(swapChain1.As(&dxgiSwapChain));

	return dxgiSwapChain;
}

static int32 computeIntersectionArea(int32 ax1, int32 ay1, int32 ax2, int32 ay2, int32 bx1, int32 by1, int32 bx2, int32 by2)
{
	return max(0, min(ax2, bx2) - max(ax1, bx1)) * max(0, min(ay2, by2) - max(ay1, by1));
}

static bool checkForHDRSupport(dx_factory factory, RECT windowRect, color_depth colorDepth)
{
	if (colorDepth == color_depth_8)
	{
		return false;
	}

	com<IDXGIAdapter1> dxgiAdapter;
	checkResult(factory->EnumAdapters1(0, &dxgiAdapter));

	uint32 i = 0;
	com<IDXGIOutput> currentOutput;
	com<IDXGIOutput> bestOutput;
	int32 bestIntersectArea = -1;

	while (dxgiAdapter->EnumOutputs(i, &currentOutput) != DXGI_ERROR_NOT_FOUND)
	{
		// Get the retangle bounds of the app window.
		int ax1 = windowRect.left;
		int ay1 = windowRect.top;
		int ax2 = windowRect.right;
		int ay2 = windowRect.bottom;

		// Get the rectangle bounds of current output.
		DXGI_OUTPUT_DESC desc;
		checkResult(currentOutput->GetDesc(&desc));
		RECT r = desc.DesktopCoordinates;
		int bx1 = r.left;
		int by1 = r.top;
		int bx2 = r.right;
		int by2 = r.bottom;

		// Compute the intersection.
		int32 intersectArea = computeIntersectionArea(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2);
		if (intersectArea > bestIntersectArea)
		{
			bestOutput = currentOutput;
			bestIntersectArea = intersectArea;
		}

		++i;
	}

	com<IDXGIOutput6> output6;
	checkResult(bestOutput.As(&output6));

	DXGI_OUTPUT_DESC1 desc1;
	checkResult(output6->GetDesc1(&desc1));

	return desc1.ColorSpace == DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020;
}

static void setSwapChainColorSpace(dx_swapchain swapchain, color_depth colorDepth, bool hdrSupport)
{
	// Rec2020 is the standard for UHD displays. The tonemap shader needs to apply the ST2084 curve before display.
	// Rec709 is the same as sRGB, just without the gamma curve. The tonemap shader needs to apply the gamma curve before display.
	DXGI_COLOR_SPACE_TYPE colorSpace = (hdrSupport && colorDepth == color_depth_10) ? DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020 : DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709;
	UINT colorSpaceSupport = 0;
	if (SUCCEEDED(swapchain->CheckColorSpaceSupport(colorSpace, &colorSpaceSupport)) &&
		((colorSpaceSupport & DXGI_SWAP_CHAIN_COLOR_SPACE_SUPPORT_FLAG_PRESENT) == DXGI_SWAP_CHAIN_COLOR_SPACE_SUPPORT_FLAG_PRESENT))
	{
		checkResult(swapchain->SetColorSpace1(colorSpace));
	}

	if (!hdrSupport)
	{
		checkResult(swapchain->SetHDRMetaData(DXGI_HDR_METADATA_TYPE_NONE, 0, 0));
		return;
	}

	struct display_chromaticities
	{
		float redX;
		float redY;
		float greenX;
		float greenY;
		float blueX;
		float blueY;
		float whiteX;
		float whiteY;
	};

	static const display_chromaticities chroma =
	{
		0.70800f, 0.29200f, 0.17000f, 0.79700f, 0.13100f, 0.04600f, 0.31270f, 0.32900f // Display Gamut Rec2020
	};

	float maxOutputNits = 1000.f;
	float minOutputNits = 0.001f;
	float maxCLL = 2000.f;
	float maxFALL = 500.f;

	DXGI_HDR_METADATA_HDR10 hdr10MetaData = {};
	hdr10MetaData.RedPrimary[0] = (uint16)(chroma.redX * 50000.f);
	hdr10MetaData.RedPrimary[1] = (uint16)(chroma.redY * 50000.f);
	hdr10MetaData.GreenPrimary[0] = (uint16)(chroma.greenX * 50000.f);
	hdr10MetaData.GreenPrimary[1] = (uint16)(chroma.greenY * 50000.f);
	hdr10MetaData.BluePrimary[0] = (uint16)(chroma.blueX * 50000.f);
	hdr10MetaData.BluePrimary[1] = (uint16)(chroma.blueY * 50000.f);
	hdr10MetaData.WhitePoint[0] = (uint16)(chroma.whiteX * 50000.f);
	hdr10MetaData.WhitePoint[1] = (uint16)(chroma.whiteY * 50000.f);
	hdr10MetaData.MaxMasteringLuminance = (uint32)(maxOutputNits * 10000.f);
	hdr10MetaData.MinMasteringLuminance = (uint32)(minOutputNits * 10000.f);
	hdr10MetaData.MaxContentLightLevel = (uint16)(maxCLL);
	hdr10MetaData.MaxFrameAverageLightLevel = (uint16)(maxFALL);

	checkResult(swapchain->SetHDRMetaData(DXGI_HDR_METADATA_TYPE_HDR10, sizeof(DXGI_HDR_METADATA_HDR10), &hdr10MetaData));
}

void dx_window::updateRenderTargetViews()
{
	uint32 rtvDescriptorSize = dxContext.device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);

	CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(rtvDescriptorHeap->GetCPUDescriptorHandleForHeapStart());

	for (int i = 0; i < NUM_BUFFERED_FRAMES; ++i)
	{
		dx_resource backBuffer;
		checkResult(swapchain->GetBuffer(i, IID_PPV_ARGS(&backBuffer)));

		dxContext.device->CreateRenderTargetView(backBuffer.Get(), 0, rtvHandle);

		backBuffers[i] = backBuffer;
		backBufferRTVs[i] = rtvHandle;

		SET_NAME(backBuffers[i], "Backbuffer");

		rtvHandle.Offset(rtvDescriptorSize);
	}
}

dx_window::~dx_window()
{
	dxContext.flushApplication();

	shutdown();
}

bool dx_window::initialize(const TCHAR* name, uint32 requestedClientWidth, uint32 requestedClientHeight, color_depth colorDepth, bool exclusiveFullscreen)
{
	if (!win32_window::initialize(name, requestedClientWidth, requestedClientHeight))
	{
		return false;
	}

	this->colorDepth = colorDepth;
	this->exclusiveFullscreen = exclusiveFullscreen;
	tearingSupported = checkTearingSupport(dxContext.factory);


	swapchain = createSwapChain(windowHandle, dxContext.factory, dxContext.renderQueue, clientWidth, clientHeight, NUM_BUFFERED_FRAMES, tearingSupported, colorDepth, exclusiveFullscreen);
	currentBackbufferIndex = swapchain->GetCurrentBackBufferIndex();

	D3D12_DESCRIPTOR_HEAP_DESC descriptorHeapDesc = {};
	descriptorHeapDesc.NumDescriptors = NUM_BUFFERED_FRAMES;
	descriptorHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;

	checkResult(dxContext.device->CreateDescriptorHeap(&descriptorHeapDesc, IID_PPV_ARGS(&rtvDescriptorHeap)));

	RECT windowRect = { 0, 0, (LONG)clientWidth, (LONG)clientHeight };
	AdjustWindowRect(&windowRect, WS_OVERLAPPEDWINDOW, FALSE);
	GetWindowRect(windowHandle, &windowRect);
	hdrSupport = checkForHDRSupport(dxContext.factory, windowRect, colorDepth);
	setSwapChainColorSpace(swapchain, colorDepth, hdrSupport);

	updateRenderTargetViews();

	initialized = true;

	return true;
}

void dx_window::shutdown()
{
	// Flush the GPU queue to make sure the swap chain's back buffers
	// are not being referenced by an in-flight command list.
	dxContext.flushApplication();

	for (uint32 i = 0; i < NUM_BUFFERED_FRAMES; ++i)
	{
		backBuffers[i].Reset();
	}
	rtvDescriptorHeap.Reset();
	swapchain.Reset();

	initialized = false;
	win32_window::shutdown();
}

void dx_window::onResize()
{
	if (initialized)
	{
		// Flush the GPU queue to make sure the swap chain's back buffers
		// are not being referenced by an in-flight command list.
		dxContext.flushApplication();

		for (uint32 i = 0; i < NUM_BUFFERED_FRAMES; ++i)
		{
			backBuffers[i].Reset();
		}

		DXGI_SWAP_CHAIN_DESC swapChainDesc = {};
		checkResult(swapchain->GetDesc(&swapChainDesc));
		checkResult(swapchain->ResizeBuffers(NUM_BUFFERED_FRAMES, clientWidth, clientHeight,
			swapChainDesc.BufferDesc.Format, swapChainDesc.Flags));

		RECT windowRect;
		GetWindowRect(windowHandle, &windowRect);
		hdrSupport = checkForHDRSupport(dxContext.factory, windowRect, colorDepth);
		setSwapChainColorSpace(swapchain, colorDepth, hdrSupport);

		currentBackbufferIndex = swapchain->GetCurrentBackBufferIndex();

		updateRenderTargetViews();
	}
}

void dx_window::onMove()
{
	if (initialized)
	{
		RECT windowRect;
		GetWindowRect(windowHandle, &windowRect);
		hdrSupport = checkForHDRSupport(dxContext.factory, windowRect, colorDepth);
		setSwapChainColorSpace(swapchain, colorDepth, hdrSupport);
	}
}

void dx_window::onWindowDisplayChange()
{
	if (initialized)
	{
		RECT windowRect;
		GetWindowRect(windowHandle, &windowRect);
		hdrSupport = checkForHDRSupport(dxContext.factory, windowRect, colorDepth);
		setSwapChainColorSpace(swapchain, colorDepth, hdrSupport);
	}
}

void dx_window::swapBuffers()
{
	if (initialized)
	{
		uint32 syncInterval = vSync ? 1 : 0;
		uint32 presentFlags = tearingSupported && !vSync && !exclusiveFullscreen ? DXGI_PRESENT_ALLOW_TEARING : 0;
		checkResult(swapchain->Present(syncInterval, presentFlags));

		currentBackbufferIndex = swapchain->GetCurrentBackBufferIndex();
	}
}

void dx_window::toggleFullscreen()
{
	if (exclusiveFullscreen)
	{
		fullscreen = !fullscreen;
		swapchain->SetFullscreenState(fullscreen, 0);
	}
	else
	{
		win32_window::toggleFullscreen();
	}
}

void dx_window::toggleVSync()
{
	vSync = !vSync;
}

```

`src/window/dx_window.h`:

```h
#pragma once

#include "dx/dx.h"
#include "dx/dx_descriptor.h"
#include "rendering/render_utils.h"
#include "window.h"

struct dx_window : win32_window
{
	dx_window() = default;
	dx_window(dx_window&) = delete;
	dx_window(dx_window&&) = default;

	virtual ~dx_window();

	bool initialize(const TCHAR* name, uint32 requestedClientWidth, uint32 requestedClientHeight, color_depth colorDepth = color_depth_8, bool exclusiveFullscreen = false);

	virtual void shutdown();

	virtual void swapBuffers();
	virtual void toggleFullscreen();
	void toggleVSync();

	virtual void onResize();
	virtual void onMove();
	virtual void onWindowDisplayChange();


	dx_resource backBuffers[NUM_BUFFERED_FRAMES];
	dx_rtv_descriptor_handle backBufferRTVs[NUM_BUFFERED_FRAMES];
	uint32 currentBackbufferIndex;

	color_depth colorDepth;

private:
	void updateRenderTargetViews();

	dx_swapchain swapchain;
	com<ID3D12DescriptorHeap> rtvDescriptorHeap;


	bool tearingSupported;
	bool exclusiveFullscreen;
	bool hdrSupport;
	bool vSync = false;
	bool initialized = false;
};

```

`src/window/software_window.cpp`:

```cpp
#include "pch.h"
#include "software_window.h"


software_window::software_window(software_window&& o) noexcept
	: win32_window(std::move(o))
{
	bitmapInfo = o.bitmapInfo;
	o.bitmapInfo = 0;

	buffer = o.buffer;
	o.buffer = 0;
}

bool software_window::initialize(const TCHAR* name, uint32 requestedClientWidth, uint32 requestedClientHeight, 
	uint8* buffer, uint32 numChannels, uint32 bufferWidth, uint32 bufferHeight)
{
	ASSERT(numChannels == 1 || numChannels == 3 || numChannels == 4);

	if (!win32_window::initialize(name, requestedClientWidth, requestedClientHeight))
	{
		return false;
	}

	if (!bitmapInfo)
	{
		bitmapInfo = (BITMAPINFO*)malloc(sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD) * 256);
		if (!bitmapInfo)
		{
			return false;
		}

		bitmapInfo->bmiHeader.biSize = sizeof(bitmapInfo->bmiHeader);
		bitmapInfo->bmiHeader.biCompression = BI_RGB;
		bitmapInfo->bmiHeader.biSizeImage = 0;
		bitmapInfo->bmiHeader.biXPelsPerMeter = 0;
		bitmapInfo->bmiHeader.biYPelsPerMeter = 0;
		bitmapInfo->bmiHeader.biClrUsed = 0;
		bitmapInfo->bmiHeader.biClrImportant = 0;

		for (int i = 0; i < 256; ++i)
		{
			bitmapInfo->bmiColors[i].rgbRed = i;
			bitmapInfo->bmiColors[i].rgbGreen = i;
			bitmapInfo->bmiColors[i].rgbBlue = i;
			bitmapInfo->bmiColors[i].rgbReserved = 0;
		}
	}

	bitmapInfo->bmiHeader.biWidth = bufferWidth == 0 ? clientWidth : bufferWidth;
	bitmapInfo->bmiHeader.biHeight = bufferHeight == 0 ? clientHeight : bufferHeight;
	bitmapInfo->bmiHeader.biPlanes = 1;
	bitmapInfo->bmiHeader.biBitCount = 8 * numChannels;

	blitX = 0;
	blitY = 0;
	blitWidth = bufferWidth == 0 ? clientWidth : bufferWidth;
	blitHeight = bufferHeight == 0 ? clientHeight : bufferHeight;

	this->buffer = buffer;

	return true;
}

void software_window::changeBlitRegion(uint32 x, uint32 y, uint32 width, uint32 height)
{
	blitX = x;
	blitY = y;
	blitWidth = width;
	blitHeight = height;
}

void software_window::shutdown()
{
	if (bitmapInfo)
	{
		free(bitmapInfo);
		bitmapInfo = 0;
	}
	win32_window::shutdown();
}

software_window::~software_window()
{
	shutdown();
}

void software_window::swapBuffers()
{
	RECT r = { 0, 0, (LONG)clientWidth, (LONG)clientHeight };
	InvalidateRect(windowHandle, &r, TRUE);
	UpdateWindow(windowHandle);
}

```

`src/window/software_window.h`:

```h
#pragma once

#include "window.h"

struct software_window : win32_window
{
	software_window() = default;
	software_window(software_window&) = delete;
	software_window(software_window&& o) noexcept;

	bool initialize(const TCHAR* name, uint32 requestedClientWidth, uint32 requestedClientHeight, 
		uint8* buffer, uint32 numChannels, uint32 bufferWidth = 0, uint32 bufferHeight = 0);

	void changeBlitRegion(uint32 x, uint32 y, uint32 width, uint32 height);

	virtual void shutdown();

	~software_window();

	void swapBuffers() override;


	BITMAPINFO* bitmapInfo = 0;
	const uint8* buffer = 0;

	uint32 blitX;
	uint32 blitY;
	uint32 blitWidth;
	uint32 blitHeight;
};

```

`src/window/window.cpp`:

```cpp
#include "pch.h"
#include "window.h"
#include <Windowsx.h>
#include <shellapi.h>
#include <uxtheme.h>
#include <vssym32.h>

#include <algorithm>

#include "software_window.h"
#include "core/imgui.h"
#include "core/string.h"
#include "asset/image.h"

#include <DirectXTex/DirectXTex.h>

bool handleWindowsMessages();

static bool running = true;
win32_window* win32_window::mainWindow = 0;

static bool windowClassInitialized;
static const TCHAR* windowClassName = TEXT("APP WINDOW");

static bool atLeastOneWindowWasOpened;
static uint32 numOpenWindows;

static LRESULT CALLBACK windowCallBack(
	_In_ HWND   hwnd,
	_In_ UINT   msg,
	_In_ WPARAM wParam,
	_In_ LPARAM lParam
);

static void setFullscreen(HWND windowHandle, bool fullscreen, WINDOWPLACEMENT& windowPosition)
{
	DWORD style = GetWindowLong(windowHandle, GWL_STYLE);

	if (fullscreen)
	{
		if (style & WS_OVERLAPPEDWINDOW)
		{
			MONITORINFO monitorInfo = { sizeof(MONITORINFO) };
			if (GetWindowPlacement(windowHandle, &windowPosition) &&
				GetMonitorInfo(MonitorFromWindow(windowHandle, MONITOR_DEFAULTTOPRIMARY), &monitorInfo))
			{
				SetWindowLong(windowHandle, GWL_STYLE, style & ~WS_OVERLAPPEDWINDOW);
				SetWindowPos(windowHandle, HWND_TOP,
					monitorInfo.rcMonitor.left, monitorInfo.rcMonitor.top,
					monitorInfo.rcMonitor.right - monitorInfo.rcMonitor.left,
					monitorInfo.rcMonitor.bottom - monitorInfo.rcMonitor.top,
					SWP_NOOWNERZORDER | SWP_FRAMECHANGED);
			}
		}
	}
	else
	{
		if (!(style & WS_OVERLAPPEDWINDOW))
		{
			SetWindowLong(windowHandle, GWL_STYLE, style | WS_OVERLAPPEDWINDOW);
			SetWindowPlacement(windowHandle, &windowPosition);
			SetWindowPos(windowHandle, 0, 0, 0, 0, 0,
				SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER |
				SWP_NOOWNERZORDER | SWP_FRAMECHANGED);
		}
	}
}

static int dpiScale(int value, UINT dpi) 
{
	return (int)((float)value * dpi / 96);
}

static int getDefaultTitleBarHeight(HWND handle)
{
	SIZE titleBarSize = { };
	const int topAndBottomBorders = 2;
	HTHEME theme = OpenThemeData(handle, L"WINDOW");
	UINT dpi = GetDpiForWindow(handle);
	GetThemePartSize(theme, NULL, WP_CAPTION, CS_ACTIVE, NULL, TS_TRUE, &titleBarSize);
	CloseThemeData(theme);

	int height = dpiScale(titleBarSize.cy, dpi) + topAndBottomBorders;
	
	return height;
}

static RECT getTitleBarRect(HWND handle, int32 titleBarHeight)
{
	RECT rect;
	GetClientRect(handle, &rect);
	rect.bottom = rect.top + titleBarHeight;
	return rect;
}

static void centerRectInRect(RECT& to_center, const RECT& outer_rect) 
{
	int toWidth = to_center.right - to_center.left;
	int toHeight = to_center.bottom - to_center.top;
	int outerWidth = outer_rect.right - outer_rect.left;
	int outerHeight = outer_rect.bottom - outer_rect.top;

	int paddingX = (outerWidth - toWidth) / 2;
	int paddingY = (outerHeight - toHeight) / 2;

	to_center.left = outer_rect.left + paddingX;
	to_center.top = outer_rect.top + paddingY;
	to_center.right = to_center.left + toWidth;
	to_center.bottom = to_center.top + toHeight;
}

struct custom_titlebar_button_rects 
{
	RECT close;
	RECT maximize;
	RECT minimize;
};

enum titlebar_button_name
{
	titlebar_button_none = -1,
	titlebar_button_close,
	titlebar_button_minimize,
	titlebar_button_maximize,
};

static custom_titlebar_button_rects getTitleBarButtonRects(HWND handle, int32 buttonHeight) 
{
	UINT dpi = GetDpiForWindow(handle);
	custom_titlebar_button_rects result;
	int buttonWidth = dpiScale(47, dpi);
	result.close = getTitleBarRect(handle, buttonHeight);

	result.close.left = result.close.right - buttonWidth;
	result.maximize = result.close;
	result.maximize.left -= buttonWidth;
	result.maximize.right -= buttonWidth;
	result.minimize = result.maximize;
	result.minimize.left -= buttonWidth;
	result.minimize.right -= buttonWidth;
	return result;
}

static int hitTest(POINT point, win32_window* window)
{
	if (!window->fullscreen)
	{
		RECT frameRect;
		GetWindowRect(window->windowHandle, &frameRect);

		int32 border = 5;
		int32 corner = 10;

		if (point.x < frameRect.left + border)
		{
			if (point.y < frameRect.top + corner) { return HTTOPLEFT; }
			if (point.y > frameRect.bottom - corner) { return HTBOTTOMLEFT; }
			return HTLEFT;
		}
		if (point.x > frameRect.right - border)
		{
			if (point.y < frameRect.top + corner) { return HTTOPRIGHT; }
			if (point.y > frameRect.bottom - corner) { return HTBOTTOMRIGHT; }
			return HTRIGHT;
		}
		if (point.y < frameRect.top + border)
		{
			if (point.x < frameRect.left + corner) { return HTTOPLEFT; }
			if (point.x > frameRect.right - corner) { return HTTOPRIGHT; }
			return HTTOP;
		}
		if (point.y > frameRect.bottom - border)
		{
			if (point.x < frameRect.left + corner) { return HTBOTTOMLEFT; }
			if (point.x > frameRect.right - corner) { return HTBOTTOMRIGHT; }
			return HTBOTTOM;
		}

		custom_titlebar_button_rects buttonRects = getTitleBarButtonRects(window->windowHandle, window->style.buttonHeight);
		OffsetRect(&buttonRects.close, frameRect.left, frameRect.top);
		OffsetRect(&buttonRects.minimize, frameRect.left, frameRect.top);
		OffsetRect(&buttonRects.maximize, frameRect.left, frameRect.top);

		if (PtInRect(&buttonRects.close, point))
		{
			return HTCLOSE;
		}
		else if (PtInRect(&buttonRects.maximize, point))
		{
			return HTMAXBUTTON;
		}
		else if (PtInRect(&buttonRects.minimize, point))
		{
			return HTMINBUTTON;
		}

		if (point.y < frameRect.top + window->style.titleBarHeight)
		{
			int32 iconPadding = window->style.iconPadding;
			int32 iconSize = window->style.titleBarHeight - iconPadding * 2;

			RECT iconRect = { iconPadding, iconPadding, iconPadding + iconSize, iconPadding + iconSize };
			OffsetRect(&iconRect, frameRect.left, frameRect.top);
			if (PtInRect(&iconRect, point))
			{
				return HTSYSMENU;
			}

			return HTCAPTION;
		}
	}

	return HTCLIENT;
}

static HICON createIcon(const uint8* image, uint32 width, uint32 height)
{
	BITMAPV5HEADER bi;

	ZeroMemory(&bi, sizeof(bi));
	bi.bV5Size = sizeof(bi);
	bi.bV5Width = width;
	bi.bV5Height = -(int32)height;
	bi.bV5Planes = 1;
	bi.bV5BitCount = 32;
	bi.bV5Compression = BI_BITFIELDS;
	bi.bV5RedMask = 0x00ff0000;
	bi.bV5GreenMask = 0x0000ff00;
	bi.bV5BlueMask = 0x000000ff;
	bi.bV5AlphaMask = 0xff000000;

	uint8* target = NULL;
	HDC dc = GetDC(NULL);
	HBITMAP color = CreateDIBSection(dc,
		(BITMAPINFO*)&bi,
		DIB_RGB_COLORS,
		(void**)&target,
		NULL,
		(DWORD)0);
	ReleaseDC(NULL, dc);

	if (!color)
	{
		std::cerr << "Win32: Failed to create RGBA bitmap.\n";
		return NULL;
	}

	HBITMAP mask = CreateBitmap(width, height, 1, 1, NULL);
	if (!mask)
	{
		std::cerr << "Failed to create mask bitmap.\n";
		DeleteObject(color);
		return NULL;
	}

	for (uint32 i = 0; i < width * height; ++i)
	{
		target[0] = image[2];
		target[1] = image[1];
		target[2] = image[0];
		target[3] = image[3];
		target += 4;
		image += 4;
	}

	ICONINFO ii = {};
	ii.fIcon = true;
	ii.hbmMask = mask;
	ii.hbmColor = color;

	HICON handle = CreateIconIndirect(&ii);

	DeleteObject(color);
	DeleteObject(mask);

	if (!handle)
	{
		std::cerr << "Failed to create icon.\n";
	}

	return handle;
}

bool win32_window::initialize(const TCHAR* name, uint32 clientWidth, uint32 clientHeight, bool visible)
{
	if (!windowClassInitialized)
	{
		WNDCLASSEX wndClass;
		ZeroMemory(&wndClass, sizeof(WNDCLASSEX));
		wndClass.cbSize = sizeof(WNDCLASSEX);
		wndClass.style = CS_OWNDC | CS_HREDRAW | CS_VREDRAW;
		wndClass.lpfnWndProc = windowCallBack;
		wndClass.hInstance = GetModuleHandle(NULL);
		wndClass.hCursor = LoadCursor(NULL, IDC_ARROW);
		wndClass.lpszClassName = windowClassName;

		if (!RegisterClassEx(&wndClass))
		{
			std::cerr << "Failed to create window class.\n";
			return false;
		}

		RegisterHotKey(0, 0, 0, VK_SNAPSHOT);
		RegisterHotKey(0, 1, MOD_CONTROL, VK_SNAPSHOT);

		windowClassInitialized = true;
	}

	if (!windowHandle)
	{
		++numOpenWindows;

		this->clientWidth = clientWidth;
		this->clientHeight = clientHeight;

		DWORD windowStyle = WS_OVERLAPPEDWINDOW;

		RECT r = { 0, 0, (LONG)clientWidth, (LONG)clientHeight };
		AdjustWindowRect(&r, windowStyle, FALSE);
		int width = r.right - r.left;
		int height = r.bottom - r.top;

		windowHandle = CreateWindowEx(0, windowClassName, name, windowStyle,
#if 1
			CW_USEDEFAULT, CW_USEDEFAULT,
#else
			0, 0
#endif
			width, height,
			0, 0, 0, 0);

		fullscreen = false;

		SetWindowLongPtr(windowHandle, GWLP_USERDATA, (LONG_PTR)this);

		if (!windowHandle)
		{
			std::cerr << "Failed to create window.\n";
			return false;
		}

		atLeastOneWindowWasOpened = true;
	}

	if (!mainWindow)
	{
		mainWindow = this;
	}

	open = true;
	this->visible = visible;
	if (visible)
	{
		ShowWindow(windowHandle, SW_SHOW);
	}

	return true;
}

void win32_window::shutdown()
{
	if (windowHandle)
	{
		HWND handle = windowHandle;
		windowHandle = 0;
		DestroyWindow(handle);
	}

	fullscreen = false;
	open = false;
	visible = false;
}

void win32_window::toggleFullscreen()
{
	fullscreen = !fullscreen;
	setFullscreen(windowHandle, fullscreen, windowPosition);
}

void win32_window::setFileDropCallback(std::function<void(const fs::path&)> cb)
{
	if (!fileDropCallback)
	{
		DragAcceptFiles(windowHandle, true);
	}
	fileDropCallback = cb;
}

win32_window::win32_window(win32_window&& o) noexcept
{
	open = o.open;
	windowHandle = o.windowHandle;
	clientWidth = o.clientWidth;
	clientHeight = o.clientHeight;
	windowPosition = o.windowPosition;
	fullscreen = o.fullscreen;

	o.windowHandle = 0;

	if (windowHandle && open)
	{
		SetWindowLongPtr(windowHandle, GWLP_USERDATA, (LONG_PTR)this);
	}

	if (mainWindow == &o)
	{
		mainWindow = this;
	}
}

win32_window::~win32_window()
{
	shutdown();
}

void win32_window::makeActive()
{
	SetForegroundWindow(windowHandle);
}

static void redrawWindowFrame(HWND windowHandle)
{
	RECT rect;
	GetClientRect(windowHandle, &rect);

	AdjustWindowRectExForDpi(&rect, GetWindowLong(windowHandle, GWL_STYLE), FALSE,
		0,
		GetDpiForWindow(windowHandle));

	ClientToScreen(windowHandle, (POINT*)&rect.left);
	ClientToScreen(windowHandle, (POINT*)&rect.right);
	SetWindowPos(windowHandle, HWND_TOP,
		rect.left, rect.top,
		rect.right - rect.left, rect.bottom - rect.top,
		SWP_FRAMECHANGED | SWP_NOACTIVATE | SWP_NOZORDER);

	handleWindowsMessages(); // Handle messages, so that frame is custom right from the start.
}

void win32_window::setCustomWindowStyle(custom_window_style style)
{
	customWindowStyle = true;

	if (style.titleBarHeight == -1)
	{
		style.titleBarHeight = getDefaultTitleBarHeight(windowHandle);
	}
	if (style.buttonHeight == -1)
	{
		style.buttonHeight = style.titleBarHeight;
	}
	if (style.borderWidthLeftAndRight == -1)
	{
		UINT dpi = GetDpiForWindow(windowHandle);
		style.borderWidthLeftAndRight = GetSystemMetricsForDpi(SM_CXFRAME, dpi);
	}
	if (style.borderWidthBottom == -1)
	{
		UINT dpi = GetDpiForWindow(windowHandle);
		style.borderWidthBottom = GetSystemMetricsForDpi(SM_CYFRAME, dpi);
	}
	this->style = style;

	redrawWindowFrame(windowHandle);
}

void win32_window::resetToDefaultWindowStyle()
{
	customWindowStyle = false;
	redrawWindowFrame(windowHandle);
}

void win32_window::setIcon(const fs::path& filepath)
{
	DirectX::ScratchImage scratchImage;
	D3D12_RESOURCE_DESC desc;

	if (loadImageFromFile(filepath, image_load_flags_cache_to_dds, scratchImage, desc) && scratchImage.GetImageCount() > 0)
	{
		const auto& image = scratchImage.GetImages()[0];
		ASSERT(getNumberOfChannels(image.format) == 4);
		uint8* pixels = image.pixels;
		uint32 width = (uint32)image.width;
		uint32 height = (uint32)image.height;

		HICON icon = createIcon(pixels, width, height);

		if (customIcon)
			DestroyIcon(customIcon);
		customIcon = icon;

		SendMessage(windowHandle, WM_SETICON, ICON_BIG, (LPARAM)icon);
		SendMessage(windowHandle, WM_SETICON, ICON_SMALL, (LPARAM)icon);
	}
}

void win32_window::changeTitle(const TCHAR* format, ...)
{
	TCHAR titleBuffer[128];

	va_list arg;
	va_start(arg, format);
	_vstprintf_s(titleBuffer, format, arg);
	va_end(arg);

	SetWindowText(windowHandle, titleBuffer);
}

void win32_window::toggleVisibility()
{
	visible = !visible;
	if (visible)
	{
		ShowWindow(windowHandle, SW_SHOW);
	}
	else
	{
		ShowWindow(windowHandle, SW_HIDE);
	}
}

void win32_window::maximize()
{
	ShowWindow(windowHandle, SW_MAXIMIZE);
}

void win32_window::setMinimumSize(int32 minimumWidth, int32 minimumHeight)
{
	this->minimumWidth = minimumWidth;
	this->minimumHeight = minimumHeight;
}

void win32_window::moveTo(int x, int y)
{
	SetWindowPos(windowHandle, HWND_TOP, x, y, clientWidth, clientHeight, SWP_NOSIZE);
}

void win32_window::moveToScreenID(int screenID)
{
	DISPLAY_DEVICEA dispDevice = { 0 };
	dispDevice.cb = sizeof(dispDevice);

	DEVMODEA devMode = { 0 };
	devMode.dmSize = sizeof(devMode);

	if (EnumDisplayDevicesA(NULL, screenID, &dispDevice, 0))
	{
		if (EnumDisplaySettingsExA(dispDevice.DeviceName, ENUM_CURRENT_SETTINGS, &devMode, NULL))
		{
			moveTo(devMode.dmPosition.x, devMode.dmPosition.y);
		}
	}
}

struct monitor_iterator
{
	DISPLAY_DEVICEA dispDevice;
	DEVMODEA devMode;
	DWORD screenID;

	monitor_iterator();

	bool step(monitor_info& info);
};

void win32_window::moveToMonitor(const std::string& uniqueID)
{
	monitor_iterator it;
	monitor_info monitor;
	while (it.step(monitor))
	{
		if (monitor.uniqueID == uniqueID)
		{
			moveTo(monitor.x, monitor.y);
			return;
		}
	}
}

void win32_window::moveToMonitor(const monitor_info& monitor)
{
	moveTo(monitor.x, monitor.y);
}

monitor_iterator::monitor_iterator()
{
	ZeroMemory(&dispDevice, sizeof(dispDevice));
	ZeroMemory(&devMode, sizeof(devMode));
	dispDevice.cb = sizeof(dispDevice);
	devMode.dmSize = sizeof(devMode);
	screenID = 0;
}

static std::string convertUniqueIDToFolderFriendlyName(const std::string& uniqueID)
{
	std::string result = uniqueID;
	std::replace(result.begin(), result.end(), '\\', '_');
	std::replace(result.begin(), result.end(), '?', '_');
	return result;
}

bool monitor_iterator::step(monitor_info& info)
{
	bool result = false;

	if (EnumDisplayDevicesA(NULL, screenID, &dispDevice, 0))
	{
		char name[sizeof(dispDevice.DeviceName)];
		strcpy_s(name, dispDevice.DeviceName);
		if (EnumDisplayDevicesA(name, 0, &dispDevice, EDD_GET_DEVICE_INTERFACE_NAME))
		{
			if (EnumDisplaySettingsExA(name, ENUM_CURRENT_SETTINGS, &devMode, NULL))
			{
				info.x = devMode.dmPosition.x;
				info.y = devMode.dmPosition.y;
				info.width = devMode.dmPelsWidth;
				info.height = devMode.dmPelsHeight;
				info.screenID = screenID;
				info.uniqueID = convertUniqueIDToFolderFriendlyName(dispDevice.DeviceID);
				info.name = dispDevice.DeviceString;
				result = true;
			}
		}
	}

	++screenID;

	return result;
}

std::vector<monitor_info> getAllDisplayDevices()
{
	std::vector<monitor_info> result;

	monitor_iterator it;
	monitor_info monitor;
	while (it.step(monitor))
	{
		result.push_back(monitor);
	}

	return result;
}

std::vector<monitor_info> getAllDisplayDevices(uint32 width, uint32 height)
{
	std::vector<monitor_info> result;

	for (monitor_info& monitor : getAllDisplayDevices())
	{
		if (width == monitor.width && height == monitor.height)
		{
			result.push_back(monitor);
		}
	}

	return result;
}

void setMainWindow(win32_window* window)
{
	win32_window::mainWindow = window;
}

static LRESULT CALLBACK windowCallBack(
	_In_ HWND   hwnd,
	_In_ UINT   msg,
	_In_ WPARAM wParam,
	_In_ LPARAM lParam
)
{
	LRESULT result = 0;

	win32_window* window = (win32_window*)GetWindowLongPtr(hwnd, GWLP_USERDATA);

	if ((msg == WM_MOUSELEAVE || msg == WM_NCMOUSELEAVE || msg == WM_MOUSEMOVE) 
		&& window && window->customWindowStyle)
	{
		if (window->hoveredButton != titlebar_button_none)
		{
			window->hoveredButton = titlebar_button_none;
			//InvalidateRect(0, 0, FALSE);
			RedrawWindow(hwnd, 0, 0, RDW_INVALIDATE | RDW_FRAME);
		}

		window->trackingMouse = false;
	}

	if (handleImGuiInput(hwnd, msg, wParam, lParam))
	{
		return true;
	}

	switch (msg)
	{
		// The default window procedure will play a system notification sound 
		// when pressing the Alt+Enter keyboard combination if this message is 
		// not handled.
		case WM_SYSCHAR:
			break;
		case WM_SIZE:
		{
			if (window && window->open)
			{
				window->clientWidth = LOWORD(lParam);
				window->clientHeight = HIWORD(lParam);
				window->onResize();

				if (window->customWindowStyle)
				{
					if (IsZoomed(hwnd))
					{
						SetWindowRgn(hwnd, 0, true);
					}
					else
					{
						RECT frameRect;
						GetWindowRect(hwnd, &frameRect);

						HRGN region = CreateRectRgn(0, 0, frameRect.right - frameRect.left, frameRect.bottom - frameRect.top);
						SetWindowRgn(hwnd, region, true);
						DeleteObject(region);
					}
				}
			}
		} break;
		case WM_CLOSE:
		{
			DestroyWindow(hwnd);
		} break;
		case WM_DESTROY:
		{
			if (window && window->windowHandle && window->open)
			{
				window->open = false;
				--numOpenWindows;
				window->shutdown();
			}
		} break;

		case WM_ACTIVATEAPP:
		{
			if (wParam)
			{
				//std::cout << "Activated\n";
			}
			else
			{
				//std::cout << "Deactivated\n";
			}
			if (window && window->customWindowStyle)
			{
				//InvalidateRect(0, 0, FALSE);
				RedrawWindow(hwnd, 0, 0, RDW_INVALIDATE | RDW_FRAME);
			}
		} break;

		case WM_PAINT:
		{
			if (window)
			{
				// For software windows, we draw the content in the client area.
				software_window* sWindow = dynamic_cast<software_window*>(window);

				if (sWindow)
				{
					const uint8* image = sWindow->buffer;
					if (image)
					{
						PAINTSTRUCT ps;
						HDC hdc = BeginPaint(hwnd, &ps);
						StretchDIBits(hdc,
#if 0
							0, 0, window->clientWidth, window->clientHeight,
							0, 0, sWindow->bitmapInfo->bmiHeader.biWidth, abs(sWindow->bitmapInfo->bmiHeader.biHeight),
#else
							0, window->clientHeight - 1, window->clientWidth, -(int)window->clientHeight,
							sWindow->blitX, sWindow->blitY, sWindow->blitWidth, sWindow->blitHeight,
#endif
							image, sWindow->bitmapInfo, DIB_RGB_COLORS, SRCCOPY);
						EndPaint(hwnd, &ps);
					}
					else
					{
						result = DefWindowProc(hwnd, msg, wParam, lParam);
					}
				}
				else
				{
					result = DefWindowProc(hwnd, msg, wParam, lParam);
				}
			}
		} break;


		// Custom window rendering is inspired by Allen Webster's video: https://www.youtube.com/watch?v=qZZePCNLBuQ
		// and Dmitriy Kubyshkin's blog post: https://kubyshkin.name/posts/win32-window-custom-title-bar-caption/

		case WM_GETMINMAXINFO:
		{
			MINMAXINFO* info = (MINMAXINFO*)lParam;
		
			if (window)
			{
				if (window->minimumWidth != -1) { info->ptMinTrackSize.x = window->minimumWidth; }
				if (window->minimumHeight != -1) { info->ptMinTrackSize.y = window->minimumHeight; }
			}
			return 0;
		} break;

		case WM_NCACTIVATE:
		case WM_NCPAINT:
		{
			if (!window || !window->customWindowStyle)
			{
				return DefWindowProc(hwnd, msg, wParam, lParam);
			}

			HDC hdc = GetDCEx(hwnd, 0, DCX_WINDOW);

			// Render bars and buttons.
			RECT frameRect;
			GetWindowRect(hwnd, &frameRect);

			RECT clientRect;
			GetClientRect(hwnd, &clientRect);

			ClientToScreen(hwnd, (POINT*)&clientRect.left);
			ClientToScreen(hwnd, (POINT*)&clientRect.right);

			OffsetRect(&clientRect, -frameRect.left, -frameRect.top);
			OffsetRect(&frameRect, -frameRect.left, -frameRect.top);

			bool hasFocus = GetActiveWindow() == hwnd;
			bool isMaximized = IsZoomed(hwnd);

			COLORREF titleBarColor = hasFocus
				? RGB(window->style.titleBarRGB[0], window->style.titleBarRGB[1], window->style.titleBarRGB[2])
				: RGB(window->style.titleBarUnfocusedRGB[0], window->style.titleBarUnfocusedRGB[1], window->style.titleBarUnfocusedRGB[2]);
			HBRUSH titleBarBrush = CreateSolidBrush(titleBarColor);
			HPEN titleBarPen = CreatePen(PS_SOLID, 0, titleBarColor);

			SelectObject(hdc, titleBarBrush);
			SelectObject(hdc, titleBarPen);

			Rectangle(hdc, frameRect.left, frameRect.top, frameRect.right, clientRect.top);			// Top bar.
			Rectangle(hdc, frameRect.left, clientRect.top, clientRect.left, clientRect.bottom);		// Left bar.
			Rectangle(hdc, clientRect.right, clientRect.top, frameRect.right, clientRect.bottom);	// Right bar.
			Rectangle(hdc, frameRect.left, clientRect.bottom, frameRect.right, frameRect.bottom);	// Bottom bar.

			COLORREF itemColor = RGB(window->style.titleTextRGB[0], window->style.titleTextRGB[1], window->style.titleTextRGB[2]);

			HBRUSH buttonIconBrush = CreateSolidBrush(itemColor);
			HPEN buttonIconPen = CreatePen(PS_SOLID, 1, itemColor);

			HBRUSH hoverBrush = CreateSolidBrush(RGB(window->style.buttonHoverRGB[0], window->style.buttonHoverRGB[1], window->style.buttonHoverRGB[2]));

			custom_titlebar_button_rects buttonRects = getTitleBarButtonRects(hwnd, window->style.buttonHeight);

			UINT dpi = GetDpiForWindow(hwnd);
			int iconDimension = dpiScale(10, dpi);

			// Minimize button.
			{
				if (window->hoveredButton == titlebar_button_minimize) 
				{
					FillRect(hdc, &buttonRects.minimize, hoverBrush);
				}
				RECT iconRect = { 0 };
				iconRect.right = iconDimension;
				iconRect.bottom = 1;
				centerRectInRect(iconRect, buttonRects.minimize);
				FillRect(hdc, &iconRect, buttonIconBrush);
			}

			// Maximize button.
			{
				HBRUSH frontBrush = titleBarBrush;
				if (window->hoveredButton == titlebar_button_maximize) 
				{
					FillRect(hdc, &buttonRects.maximize, hoverBrush);
					frontBrush = hoverBrush;
				}
				RECT iconRect = { 0 };
				iconRect.right = iconDimension;
				iconRect.bottom = iconDimension;
				centerRectInRect(iconRect, buttonRects.maximize);
				SelectObject(hdc, buttonIconPen);
				SelectObject(hdc, GetStockObject(HOLLOW_BRUSH));
				Rectangle(hdc, iconRect.left, iconRect.top, iconRect.right, iconRect.bottom);

				if (isMaximized)
				{
					SelectObject(hdc, frontBrush);
					Rectangle(hdc, iconRect.left - 2, iconRect.top + 2, iconRect.right - 2, iconRect.bottom + 2);
				}
			}

			// Close button.
			{
				HPEN customPen = 0;
				if (window->hoveredButton == titlebar_button_close)
				{
					// Highlight button on hover.
					HBRUSH fillBrush = CreateSolidBrush(RGB(window->style.closeButtonHoverRGB[0], window->style.closeButtonHoverRGB[1], window->style.closeButtonHoverRGB[2]));
					FillRect(hdc, &buttonRects.close, fillBrush);
					DeleteObject(fillBrush);
					customPen = CreatePen(PS_SOLID, 1, RGB(window->style.closeButtonHoverStrokeRGB[0], window->style.closeButtonHoverStrokeRGB[1], window->style.closeButtonHoverStrokeRGB[2]));
					SelectObject(hdc, customPen);
				}
				RECT iconRect = { 0, 0, iconDimension, iconDimension };
				centerRectInRect(iconRect, buttonRects.close);
				MoveToEx(hdc, iconRect.left, iconRect.top, NULL);
				LineTo(hdc, iconRect.right + 1, iconRect.bottom + 1);
				MoveToEx(hdc, iconRect.left, iconRect.bottom, NULL);
				LineTo(hdc, iconRect.right + 1, iconRect.top - 1);
				if (customPen)
				{
					DeleteObject(customPen);
				}
			}

			DeleteObject(titleBarBrush);
			DeleteObject(titleBarPen);

			DeleteObject(hoverBrush);
			DeleteObject(buttonIconPen);
			DeleteObject(buttonIconBrush);


			// Extra padding for title and icon if window is maximized.
			int32 leftAndTopPadding = 0;
			if (isMaximized)
			{
				leftAndTopPadding = 5;
			}


			HTHEME theme = OpenThemeData(hwnd, L"WINDOW");

			// Draw window title.
			LOGFONT logicalFont;
			HFONT oldFont = NULL;
			if (SUCCEEDED(GetThemeSysFont(theme, TMT_CAPTIONFONT, &logicalFont))) 
			{
				HFONT themeFont = CreateFontIndirect(&logicalFont);
				oldFont = (HFONT)SelectObject(hdc, themeFont);
			}

			wchar_t titleTextBuffer[255] = { 0 };
			GetWindowTextW(hwnd, titleTextBuffer, arraysize(titleTextBuffer));
			RECT titleBarTextRect = { window->style.titleLeftOffset + leftAndTopPadding, leftAndTopPadding, buttonRects.minimize.left - 10 + leftAndTopPadding, window->style.titleBarHeight };
			DTTOPTS drawThemeOptions = { sizeof(drawThemeOptions) };
			drawThemeOptions.dwFlags = DTT_TEXTCOLOR;
			drawThemeOptions.crText = itemColor;
			DrawThemeTextEx(
				theme,
				hdc,
				0, 0,
				titleTextBuffer,
				-1,
				DT_VCENTER | DT_SINGLELINE | DT_WORD_ELLIPSIS,
				&titleBarTextRect,
				&drawThemeOptions
			);

			if (oldFont)
			{
				SelectObject(hdc, oldFont);
			}
			CloseThemeData(theme);




			// Draw window icon.
			HICON icon = window->customIcon;
			if (!icon) 
			{ 
				icon = LoadIcon(NULL, IDI_APPLICATION); 
			}

			if (icon)
			{
				int32 iconPadding = window->style.iconPadding;
				int32 iconSize = window->style.titleBarHeight - iconPadding * 2;

				DrawIconEx(hdc, iconPadding + leftAndTopPadding, iconPadding + leftAndTopPadding, icon, iconSize, iconSize, 0, NULL, DI_NORMAL);
			}



			ReleaseDC(hwnd, hdc);

			return true;
		} break;

		case WM_NCHITTEST:
		{
			if (!window || !window->customWindowStyle)
			{
				return DefWindowProc(hwnd, msg, wParam, lParam);
			}

			POINT point = { LOWORD(lParam), HIWORD(lParam) };
			return hitTest(point, window);
		} break;

		case WM_NCCALCSIZE: 
		{
			if (!window || !window->customWindowStyle)
			{
				return DefWindowProc(hwnd, msg, wParam, lParam);
			}
			
			RECT* rect = (RECT*)lParam;
			if (rect->top > -10000) // Minimized windows seem to have a top of -32000.
			{
				rect->left += window->style.borderWidthLeftAndRight;
				rect->right -= window->style.borderWidthLeftAndRight;
				rect->bottom -= window->style.borderWidthBottom;

				if (!window->fullscreen)
				{
					rect->top += window->style.titleBarHeight;
				}
				else
				{
					rect->top += window->style.borderWidthBottom;
				}
			}
		} break;

		case WM_NCMOUSEMOVE: 
		{
			if (window && window->customWindowStyle)
			{
				POINT cursorPoint = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };

				int hoveredButton = titlebar_button_none;
				int hit = hitTest(cursorPoint, window);

				if (hit == HTCLOSE)
				{
					hoveredButton = titlebar_button_close;
				}
				else if (hit == HTMAXBUTTON)
				{
					hoveredButton = titlebar_button_maximize;
				}
				else if (hit == HTMINBUTTON)
				{
					hoveredButton = titlebar_button_minimize;
				}
				
				if (hoveredButton != window->hoveredButton)
				{
					window->hoveredButton = hoveredButton;
					//InvalidateRect(0, 0, FALSE);
					RedrawWindow(hwnd, 0, 0, RDW_INVALIDATE | RDW_FRAME);
				}

				if (!window->trackingMouse)
				{
					TRACKMOUSEEVENT eventTrack = { sizeof(TRACKMOUSEEVENT) };
					eventTrack.dwFlags = TME_NONCLIENT;
					eventTrack.hwndTrack = hwnd;
					eventTrack.dwHoverTime = HOVER_DEFAULT;

					TrackMouseEvent(&eventTrack);

					window->trackingMouse = true;
				}
				return 0;
			}
			return DefWindowProc(hwnd, msg, wParam, lParam);
		}

		case WM_NCLBUTTONDOWN: 
		{
			// Clicks on buttons will be handled in WM_NCLBUTTONUP, but we still need
			// to remove default handling of the click to avoid it counting as drag.
			if (window && window->customWindowStyle && window->hoveredButton != titlebar_button_none) 
			{
				return 0;
			}
			// Default handling allows for dragging and double click to maximize
			return DefWindowProc(hwnd, msg, wParam, lParam);
		}

		case WM_NCLBUTTONUP: 
		{
			if (window && window->customWindowStyle)
			{
				if (window->hoveredButton == titlebar_button_close) 
				{
					window->hoveredButton = titlebar_button_none;
					PostMessage(hwnd, WM_CLOSE, 0, 0);
					return 0;
				}
				else if (window->hoveredButton == titlebar_button_minimize) 
				{
					window->hoveredButton = titlebar_button_none;
					ShowWindow(hwnd, SW_MINIMIZE);
					return 0;
				}
				else if (window->hoveredButton == titlebar_button_maximize) 
				{
					window->hoveredButton = titlebar_button_none;
					int mode = IsZoomed(hwnd) ? SW_NORMAL : SW_MAXIMIZE;
					ShowWindow(hwnd, mode);
					return 0;
				}
			}
			return DefWindowProc(hwnd, msg, wParam, lParam);
		}

		case WM_CREATE:
		{
			RECT rect;
			GetWindowRect(hwnd, &rect);

			// Inform the application of the frame change to force redrawing with the new
			// client area that is extended into the title bar
			SetWindowPos(
				hwnd, NULL,
				rect.left, rect.top,
				rect.right - rect.left, rect.bottom - rect.top,
				SWP_FRAMECHANGED | SWP_NOMOVE | SWP_NOSIZE
			);
		} break;

		case WM_DROPFILES:
		{
			if (window && window->fileDropCallback)
			{
				HDROP hdrop = (HDROP)wParam;

				wchar nextFile[MAX_PATH];
				uint32 numFiles = DragQueryFileW(hdrop, -1, NULL, 0);

				for (uint32 i = 0; i < numFiles; ++i)
				{
					if (DragQueryFileW(hdrop, i, nextFile, MAX_PATH) > 0)
					{
						window->fileDropCallback(nextFile);
					}
				}

				DragFinish(hdrop);
			}
		} break;

		default:
		{
			result = DefWindowProc(hwnd, msg, wParam, lParam);
		} break;
	}


	return result;
}

bool handleWindowsMessages()
{
	MSG msg = { 0 };
	while (PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
	{
		if (msg.message == WM_HOTKEY)
		{
			ImGui::GetIO().KeysDown[VK_SNAPSHOT] = true;
		}
		if (msg.message == WM_QUIT)
		{
			running = false;
			break;
		}

		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}

	if (atLeastOneWindowWasOpened && numOpenWindows == 0)
	{
		running = false;
	}

	if (win32_window::mainWindow && !win32_window::mainWindow->open)
	{
		running = false;
	}

	return running;
}

```

`src/window/window.h`:

```h
#pragma once

#include <functional>

struct custom_window_style
{
	// Default values match the current ImGui style.

	uint8 titleBarRGB[3] = { 25, 27, 28 };
	uint8 titleBarUnfocusedRGB[3] = { 45, 47, 48 };
	uint8 titleTextRGB[3] = { 255, 255, 255 };
	uint8 buttonHoverRGB[3] = { 80, 80, 80 };

	uint8 closeButtonHoverRGB[3] = { 0xCC, 0, 0 };
	uint8 closeButtonHoverStrokeRGB[3] = { 255, 255, 255 };

	int32 titleLeftOffset = 30;
	int32 titleBarHeight = -1; // Set to -1 for default title bar height.
	int32 buttonHeight = -1; // Set to -1 for buttons as tall as the title bar.
	int32 iconPadding = 5; // Padding around icon. Size of icon will be titleBarHeight - iconPadding * 2.
	int32 borderWidthLeftAndRight = 0; // Set to -1 for default border width.
	int32 borderWidthBottom = 0; // Set to -1 for default border width. Will be used for top when window is full-screen.

	bool preventRoundedTopCorners = true;
};

struct win32_window
{
	win32_window() = default;
	win32_window(win32_window&) = delete;
	win32_window(win32_window&& o) noexcept;

	bool initialize(const TCHAR* name, uint32 clientWidth, uint32 clientHeight, bool visible = true);
	virtual void shutdown();

	virtual ~win32_window();

	virtual void swapBuffers() = 0;
	virtual void toggleFullscreen();
	void setFileDropCallback(std::function<void(const fs::path&)> cb);

	void toggleVisibility();

	void maximize();

	void setMinimumSize(int32 minimumWidth = -1, int32 minimumHeight = -1); // -1 means default Windows limits.

	void moveTo(int x, int y);
	void moveToScreenID(int screenID);
	void moveToMonitor(const std::string& uniqueID);
	void moveToMonitor(const struct monitor_info& monitor);

	void makeActive();

	void setCustomWindowStyle(custom_window_style style = {});
	void resetToDefaultWindowStyle();
	void setIcon(const fs::path& filepath);
	void changeTitle(const TCHAR* format, ...);

	uint32 clientWidth, clientHeight;
	HWND windowHandle = 0;

protected:
	// Internal callbacks.
	virtual void onResize() {}
	virtual void onMove() {}
	virtual void onWindowDisplayChange() {}

	WINDOWPLACEMENT windowPosition;

	bool fullscreen = false;
	bool open = false;
	bool visible = false;

	bool customWindowStyle = false;
	custom_window_style style;
	HICON customIcon = 0;

	int32 minimumWidth = -1;
	int32 minimumHeight = -1;

	std::function<void(const fs::path&)> fileDropCallback;

	int hoveredButton = -1; // Only used for custom window styles.
	bool trackingMouse = false;

	static win32_window* mainWindow;

	friend static int hitTest(POINT point, win32_window* window);
	friend static LRESULT CALLBACK windowCallBack(_In_ HWND hwnd, _In_ UINT msg, _In_ WPARAM wParam, _In_ LPARAM lParam);
	friend void setMainWindow(win32_window* window);
	friend bool handleWindowsMessages();
};


struct monitor_info
{
	// This is specific for the actual physical monitor / projector.
	std::string name;
	std::string uniqueID;

	// This can change from run to run!
	int screenID;
	int x, y;
	uint32 width, height;
};

std::vector<monitor_info> getAllDisplayDevices();
std::vector<monitor_info> getAllDisplayDevices(uint32 width, uint32 height);

void setMainWindow(win32_window* window);

```