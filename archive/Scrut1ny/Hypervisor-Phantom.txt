Project Path: arc_Scrut1ny_Hypervisor-Phantom_6qp4htlt

Source Tree:

```txt
arc_Scrut1ny_Hypervisor-Phantom_6qp4htlt
â”œâ”€â”€ LICENSE
â”œâ”€â”€ README.md
â”œâ”€â”€ main.sh
â”œâ”€â”€ modules
â”‚   â”œâ”€â”€ README.md
â”‚   â”œâ”€â”€ deploy.sh
â”‚   â”œâ”€â”€ edk2.sh
â”‚   â”œâ”€â”€ kernel.sh
â”‚   â”œâ”€â”€ lg.sh
â”‚   â”œâ”€â”€ qemu.sh
â”‚   â”œâ”€â”€ vfio.sh
â”‚   â””â”€â”€ virtualization.sh
â”œâ”€â”€ patches
â”‚   â”œâ”€â”€ EDK2
â”‚   â”‚   â”œâ”€â”€ AMD-edk2-stable202602.patch
â”‚   â”‚   â”œâ”€â”€ Archive
â”‚   â”‚   â”‚   â”œâ”€â”€ AMD-edk2-stable202511.patch
â”‚   â”‚   â”‚   â”œâ”€â”€ Intel-edk2-stable202511.patch
â”‚   â”‚   â”‚   â”œâ”€â”€ amd-edk2-stable202505.patch
â”‚   â”‚   â”‚   â”œâ”€â”€ amd-edk2-stable202508.patch
â”‚   â”‚   â”‚   â”œâ”€â”€ intel-edk2-stable202505.patch
â”‚   â”‚   â”‚   â””â”€â”€ intel-edk2-stable202508.patch
â”‚   â”‚   â””â”€â”€ Intel-edk2-stable202602.patch
â”‚   â”œâ”€â”€ Guest
â”‚   â”‚   â””â”€â”€ Kernel
â”‚   â”‚       â”œâ”€â”€ amd-linux-6.0.0-rc6.patch
â”‚   â”‚       â””â”€â”€ intel-linux-6.0.0-rc6.patch
â”‚   â”œâ”€â”€ Kernel
â”‚   â”‚   â”œâ”€â”€ Archive
â”‚   â”‚   â”‚   â””â”€â”€ zen-6.14.10-vmx.patch
â”‚   â”‚   â””â”€â”€ linux-6.18.8-svm.patch
â”‚   â”œâ”€â”€ QEMU
â”‚   â”‚   â”œâ”€â”€ AMD-v10.2.0.patch
â”‚   â”‚   â”œâ”€â”€ Archive
â”‚   â”‚   â”‚   â”œâ”€â”€ amd-qemu-10.0.2.patch
â”‚   â”‚   â”‚   â”œâ”€â”€ amd-qemu-10.1.0.patch
â”‚   â”‚   â”‚   â”œâ”€â”€ amd-qemu-10.1.1.patch
â”‚   â”‚   â”‚   â”œâ”€â”€ amd-qemu-10.1.3.patch
â”‚   â”‚   â”‚   â”œâ”€â”€ amd-qemu-9.2.4.patch
â”‚   â”‚   â”‚   â”œâ”€â”€ intel-qemu-10.0.2.patch
â”‚   â”‚   â”‚   â”œâ”€â”€ intel-qemu-10.1.0.patch
â”‚   â”‚   â”‚   â”œâ”€â”€ intel-qemu-10.1.1.patch
â”‚   â”‚   â”‚   â”œâ”€â”€ intel-qemu-9.2.4.patch
â”‚   â”‚   â”‚   â””â”€â”€ libnfs6-qemu-10.1.1.patch
â”‚   â”‚   â”œâ”€â”€ Intel-v10.2.0.patch
â”‚   â”‚   â”œâ”€â”€ fake_battery.dsl
â”‚   â”‚   â”œâ”€â”€ spoofed_devices.aml
â”‚   â”‚   â””â”€â”€ spoofed_devices.dsl
â”‚   â””â”€â”€ README.md
â”œâ”€â”€ resources
â”‚   â”œâ”€â”€ README.md
â”‚   â”œâ”€â”€ media
â”‚   â”‚   â””â”€â”€ diagram.png
â”‚   â””â”€â”€ scripts
â”‚       â”œâ”€â”€ Linux
â”‚       â”‚   â”œâ”€â”€ OnVUE-Gen.sh
â”‚       â”‚   â”œâ”€â”€ arch_kernel_downgrade.sh
â”‚       â”‚   â”œâ”€â”€ evdev-auto.sh
â”‚       â”‚   â”œâ”€â”€ msr_check.py
â”‚       â”‚   â”œâ”€â”€ smbios_spoofer_cli.py
â”‚       â”‚   â””â”€â”€ vbios-dumper.sh
â”‚       â””â”€â”€ Windows
â”‚           â”œâ”€â”€ edid-spoofer.ps1
â”‚           â”œâ”€â”€ identifier-spoofer.ps1
â”‚           â””â”€â”€ qemu-cleanup.ps1
â””â”€â”€ utils.sh

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`README.md`:

```md
<div align="center">

# AutoVirt

This tool provides automated setups for linux virtualization related stuff.

[![](https://dcbadge.limes.pink/api/server/https://discord.gg/hNVHChp7PX)](https://discord.gg/hNVHChp7PX)

</div>





---





## ðŸ“– Setup Instruction Guide

<details>
<summary>Expand for details...</summary>

#### 1. Clone Git repository
```
git clone --single-branch --depth=1 https://github.com/Scrut1ny/AutoVirt
```

#### 2. Change directory
```
cd AutoVirt/
```

#### 3. Execute
```
./main.sh
```

---

### 4. Update repository
- ***Make sure you're in the `AutoVirt/` root directory when running the command below!***
```
git fetch --all && git reset --hard origin/main
```

</details>





---

<a href="https://www.star-history.com/#Scrut1ny/AutoVirt&type=date&legend=bottom-right">
 <picture>
   <source media="(prefers-color-scheme: dark)" srcset="https://api.star-history.com/svg?repos=Scrut1ny/AutoVirt&type=date&theme=dark&legend=bottom-right" />
   <source media="(prefers-color-scheme: light)" srcset="https://api.star-history.com/svg?repos=Scrut1ny/AutoVirt&type=date&legend=bottom-right" />
   <img alt="Star History Chart" src="https://api.star-history.com/svg?repos=Scrut1ny/AutoVirt&type=date&legend=bottom-right" />
 </picture>
</a>

```

`main.sh`:

```sh
#!/usr/bin/env bash

source ./utils.sh || { echo "Failed to load utilities module!"; exit 1; }

check_non_root() {
  if [[ $EUID -eq 0 ]]; then
    fmtr::fatal "Do not run as root.\n"
    exit 1
  fi
}

detect_distro() {
  local id

  # Try reading /etc/os-release first
  if [[ -r /etc/os-release ]]; then
    . /etc/os-release
    id=${ID,,}
  fi

  # Map known distro IDs to canonical names
  case "$id" in
    arch|manjaro|endeavouros|arcolinux|garuda|artix) DISTRO="Arch" ;;
    opensuse-*|sles) DISTRO="openSUSE" ;;
    debian|ubuntu|linuxmint|kali|pureos|pop|elementary|zorin|mx|parrot|deepin|peppermint|trisquel|bodhi|linuxlite|neon) DISTRO="Debian" ;;
    fedora|centos|rhel|rocky|alma|oracle) DISTRO="Fedora" ;;
    *)
      # Fallback: detect by package manager
      if command -v pacman >/dev/null 2>&1; then
        DISTRO="Arch"
      elif command -v apt >/dev/null 2>&1; then
        DISTRO="Debian"
      elif command -v zypper >/dev/null 2>&1; then
        DISTRO="openSUSE"
      elif command -v dnf >/dev/null 2>&1; then
        DISTRO="Fedora"
      else
        fmtr::fatal "${id:-Unknown} distro isn't supported yet."
      fi
      ;;
  esac

  export DISTRO
  readonly DISTRO
}

cpu_detect() {
  local vendor
  vendor=$(awk -F': +' '/^vendor_id/ {print $2; exit}' /proc/cpuinfo)

  [[ -n $vendor ]] || fmtr::fatal "Unable to determine CPU vendor from /proc/cpuinfo"

  case "$vendor" in
    *AuthenticAMD*)
      CPU_VENDOR_ID="AuthenticAMD"
      CPU_VIRTUALIZATION="svm"
      CPU_MANUFACTURER="AMD"
      ;;
    *GenuineIntel*)
      CPU_VENDOR_ID="GenuineIntel"
      CPU_VIRTUALIZATION="vmx"
      CPU_MANUFACTURER="Intel"
      ;;
    *)
      fmtr::fatal "Unsupported CPU vendor: $vendor"
      ;;
  esac

  export CPU_VENDOR_ID CPU_VIRTUALIZATION CPU_MANUFACTURER
  readonly CPU_VENDOR_ID CPU_VIRTUALIZATION CPU_MANUFACTURER
}

main_menu() {
  local options=(
    "Exit"
    "Virtualization Setup"
    "QEMU (Patched) Setup"
    "EDK2 (Patched) Setup"
    "GPU Passthrough Setup"
    "Kernel (Patched) Setup"
    "Looking Glass Setup"
    "Deploy Auto/Unattended XML"
  )
  readonly options

  while :; do
    clear
    fmtr::box_text " >> AutoVirt << "; echo ""

    for ((i=1; i<${#options[@]}; i++)); do
      printf '  %b[%d]%b %s\n' "$TEXT_BRIGHT_YELLOW" "$i" "$RESET" "${options[i]}"
    done
    printf '\n  %b[%d]%b %s\n\n' "$TEXT_BRIGHT_RED" 0 "$RESET" "${options[0]}"

    local choice
    choice="$(prmt::quick_prompt '  Enter your choice [0-7]: ')" || continue
    clear

    case $choice in
      1) fmtr::box_text "${options[1]}"; ./modules/virtualization.sh ;;
      2) fmtr::box_text "${options[2]}"; ./modules/qemu.sh ;;
      3) fmtr::box_text "${options[3]}"; ./modules/edk2.sh ;;
      4) fmtr::box_text "${options[4]}"; ./modules/vfio.sh ;;
      5) fmtr::box_text "${options[5]}"; fmtr::warn "This module isn't ready yet." ;; #./modules/kernel.sh ;;
      6) fmtr::box_text "${options[6]}"; fmtr::warn "This module isn't ready yet." ;; #./modules/lg.sh ;;
      7) fmtr::box_text "${options[7]}"; ./modules/deploy.sh ;;
      0)
        prmt::yes_or_no "$(fmtr::ask 'Do you want to clear the logs directory?')" &&
          rm -f -- "${LOG_PATH}"/*.log
        exit 0
        ;;
      *) fmtr::error "Invalid option, please try again." ;;
    esac

    prmt::quick_prompt "$(fmtr::info 'Press any key to continue...')"
  done
}

main() {
  check_non_root
  detect_distro
  cpu_detect
  main_menu
}

main

```

`modules/README.md`:

```md
# Linux Kernel

<details>
<summary>Expand for details...</summary>

- Kernel Paramaters:
  - https://github.com/torvalds/linux/blob/master/Documentation/admin-guide/kernel-parameters.txt
 
- KVM MSRs
  - https://docs.kernel.org/virt/kvm/x86/msr.html
  - https://github.com/torvalds/linux/blob/master/arch/x86/include/uapi/asm/kvm_para.h

</details>

---






# EDK2 (OVMF) / UEFI / Firmware

<details>
<summary>Expand for details...</summary>





- https://github.com/tianocore/tianocore.github.io/wiki/Common-instructions
- https://github.com/tianocore/tianocore.github.io/wiki/How-to-build-OVMF
- https://github.com/tianocore/edk2/tree/master/OvmfPkg

## NVRAM Template:

```
sudo pacman -S edk2-ovmf
```

```
/usr/share/edk2/x64/MICROVM.4m.fd
/usr/share/edk2/x64/OVMF.4m.fd
/usr/share/edk2/x64/OVMF_CODE.4m.fd
/usr/share/edk2/x64/OVMF_CODE.secboot.4m.fd
/usr/share/edk2/x64/OVMF_VARS.4m.fd
```

## BmpImageDecoder (BMP Validator)
- https://github.com/tianocore/edk2/blob/master/BaseTools/Source/Python/AutoGen/GenC.py#L1892
  - File Type: Bytes `0â€“1` must be `0x42 0x4D`
  - Bit Depth: Must be `1`, `4`, `8`, or `24`
  - Compression: Must be `0`
  - Width/Height: `â‰¤65535x65535`




## VMMBootOrderNNNN (L"BootOrder%04x")
- OvmfPkg/Library/QemuBootOrderLib/QemuBootOrderLib.c






## OVMF PK/KEK Vendor String & EnrollDefaultKeys
- EnrollDefaultKeys
  - https://github.com/tianocore/edk2/tree/master/OvmfPkg#readme
  - OvmfPkg/EnrollDefaultKeys/EnrollDefaultKeys.c
  - OvmfPkg/EnrollDefaultKeys/EnrollDefaultKeys.h
  - OvmfPkg/EnrollDefaultKeys/EnrollDefaultKeys.inf
- OvmfPkg/OvmfPkg.dec
- OvmfPkg/Include/Guid/OvmfPkKek1AppPrefix.h





## Old script for reference
```bash
################################################################################
# Compile OVMF and inject Secure Boot certs into template VARS
################################################################################
compile_and_inject_ovmf() {
  local WORKSPACE EDK_TOOLS_PATH CONF_PATH TEMP_DIR URL UUID

  fmtr::info "Configuring build environment..."

  export WORKSPACE="$(pwd)"
  export EDK_TOOLS_PATH="$WORKSPACE/BaseTools"
  export CONF_PATH="$WORKSPACE/Conf"

  [ -d BaseTools/Build ] || { make -C BaseTools -j"$(nproc)" && source edksetup.sh; } &>>"$LOG_FILE" || { fmtr::fatal "Failed to build BaseTools"; return 1; }

  build -a X64 -p OvmfPkg/OvmfPkgX64.dsc -b RELEASE -t GCC5 -n 0 -s \
    --define SECURE_BOOT_ENABLE=TRUE \
    --define TPM1_ENABLE=TRUE \
    --define TPM2_ENABLE=TRUE \
    --define SMM_REQUIRE=TRUE &>>"$LOG_FILE" || { fmtr::fatal "Failed to build OVMF"; return 1; }

  $ROOT_ESC mkdir -p "$OUT_DIR/firmware"

  for f in CODE VARS; do
    $ROOT_ESC "$OUT_DIR/emulator/bin/qemu-img" convert -f raw -O qcow2 "Build/OvmfX64/RELEASE_GCC5/FV/OVMF_${f}.fd" "$OUT_DIR/firmware/OVMF_${f}.qcow2" || return 1
  done

  TEMP_DIR="$(mktemp -d)" || return 1
  trap 'rm -rf "$TEMP_DIR"' RETURN

  URL="https://raw.githubusercontent.com/microsoft/secureboot_objects/main"
  UUID="77fa9abd-0359-4d32-bd60-28f4e78f784b"

  local -A certs=(
    # PK (Platform Key)
    ["ms_pk_oem.der"]="$URL/PreSignedObjects/PK/Certificate/WindowsOEMDevicesPK.der"
    # KEK (Key Exchange Key)
    ["ms_kek_2011.der"]="$URL/PreSignedObjects/KEK/Certificates/MicCorKEKCA2011_2011-06-24.der"
    ["ms_kek_2023.der"]="$URL/PreSignedObjects/KEK/Certificates/microsoft%20corporation%20kek%202k%20ca%202023.der"
    # DB (Signature Database)
    ["ms_db_uefi_2011.der"]="$URL/PreSignedObjects/DB/Certificates/MicCorUEFCA2011_2011-06-27.der"
    ["ms_db_pro_2011.der"]="$URL/PreSignedObjects/DB/Certificates/MicWinProPCA2011_2011-10-19.der"
    ["ms_db_optionrom_2023.der"]="$URL/PreSignedObjects/DB/Certificates/microsoft%20option%20rom%20uefi%20ca%202023.der"
    ["ms_db_uefi_2023.der"]="$URL/PreSignedObjects/DB/Certificates/microsoft%20uefi%20ca%202023.der"
    ["ms_db_windows_2023.der"]="$URL/PreSignedObjects/DB/Certificates/windows%20uefi%20ca%202023.der"
    # DBX (Forbidden Signatures Database)
    ["dbxupdate.bin"]="$URL/PostSignedObjects/DBX/amd64/DBXUpdate.bin"
  )

  for c in "${!certs[@]}"; do
    wget -q -O "$TEMP_DIR/$c" "${certs[$c]}" &
  done
  wait || { fmtr::fatal "Failed to download one or more certificates"; return 1; }

  # Generate efivars.json
  local efivars_json="$TEMP_DIR/efivars.json"
  local -A guids=(
    ["dbDefault"]="8be4df61-93ca-11d2-aa0d-00e098032b8c"
    ["dbxDefault"]="8be4df61-93ca-11d2-aa0d-00e098032b8c"
    ["KEKDefault"]="8be4df61-93ca-11d2-aa0d-00e098032b8c"
    ["PKDefault"]="8be4df61-93ca-11d2-aa0d-00e098032b8c"
  )

  {
    local entries=() var path hex attr data entry

    for var in "${!guids[@]}"; do
      path="/sys/firmware/efi/efivars/${var}-${guids[$var]}"
      [[ -f "$path" ]] || continue

      hex=$(hexdump -ve '1/1 "%.2x"' "$path" 2>/dev/null)
      [[ ${#hex} -ge 8 ]] || continue

      # Parse attribute (little-endian 4 bytes) and data
      attr=$(( 16#${hex:6:2}${hex:4:2}${hex:2:2}${hex:0:2} ))
      data=${hex:8}

      # Build JSON entry
      entry=$(printf '        {
              "name": "%s",
              "guid": "%s",
              "attr": %d,' "$var" "${guids[$var]}" "$attr")

      # Handle EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS (0x20)
      if (( attr & 0x20 )) && [[ ${#data} -ge 32 ]]; then
        entry+=$(printf '
              "data": "%s",
              "time": "%s"
          }' "${data:32}" "${data:0:32}")
      else
        entry+=$(printf '
              "data": "%s"
          }' "$data")
      fi

      entries+=("$entry")
    done

    # Output complete JSON
    printf '{\n    "version": 2,\n    "variables": [\n'
    local IFS=','$'\n'
    echo "${entries[*]}"
    printf '    ]\n}\n'
  } > "$efivars_json"

  $ROOT_ESC virt-fw-vars --input "$OUT_DIR/firmware/OVMF_VARS.qcow2" --output "$OUT_DIR/firmware/OVMF_VARS.qcow2" \
    --secure-boot \
    --set-pk "$UUID" "$TEMP_DIR/ms_pk_oem.der" \
    --add-kek "$UUID" "$TEMP_DIR/ms_kek_2011.der" \
    --add-kek "$UUID" "$TEMP_DIR/ms_kek_2023.der" \
    --add-db "$UUID" "$TEMP_DIR/ms_db_uefi_2011.der" \
    --add-db "$UUID" "$TEMP_DIR/ms_db_pro_2011.der" \
    --add-db "$UUID" "$TEMP_DIR/ms_db_optionrom_2023.der" \
    --add-db "$UUID" "$TEMP_DIR/ms_db_uefi_2023.der" \
    --add-db "$UUID" "$TEMP_DIR/ms_db_windows_2023.der" \
    --set-dbx "$TEMP_DIR/dbxupdate.bin" \
    --set-json "$efivars_json" &>>"$LOG_FILE" || { fmtr::fatal "Failed to inject"; return 1; }
}
```





## OVMF MOR/MORLock support:
- https://github.com/tianocore/edk2/blob/master/OvmfPkg/README#L160
- https://github.com/tianocore/tianocore.github.io/wiki/How-to-Enable-Security
- https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/MemoryOverwriteControl
- https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/MemoryOverwriteRequestControlLock
- https://github.com/tianocore/edk2/blob/master/OvmfPkg/Include/Dsc/MorLock.dsc.inc
- https://github.com/tianocore/edk2/blob/master/OvmfPkg/Include/Fdf/MorLock.fdf.inc

## OVMF TPM support:
- https://github.com/tianocore/edk2/blob/master/OvmfPkg/OvmfPkgX64.dsc#L39
- https://github.com/tianocore/edk2/blob/master/OvmfPkg/Include/Dsc/OvmfTpmDefines.dsc.inc

OVMF Build Args:
```
build -a X64 -p OvmfPkg/OvmfPkgX64.dsc -b RELEASE -t GCC5 -n 0 -s \
  --define SECURE_BOOT_ENABLE=TRUE \
  --define SMM_REQUIRE=TRUE \
  --define TPM1_ENABLE=TRUE \
  --define TPM2_ENABLE=TRUE \
```

QEMU XML:
```xml
  <features>
    <smm state="on"/>
  </features>
...
    <tpm model="tpm-crb">
      <backend type="emulator" version="2.0"/>
    </tpm>
```

## Last BIOS time: 0.0
#### Add FPDT module to OVMF
- ```MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableDxe/FirmwarePerformanceDxe.c```
- ```OvmfPkg/OvmfPkgX64.dsc```
```
  #
  # ACPI Support
  #
  MdeModulePkg/Universal/Acpi/AcpiTableDxe/AcpiTableDxe.inf
  OvmfPkg/AcpiPlatformDxe/AcpiPlatformDxe.inf
!if $(STANDALONE_MM_ENABLE) != TRUE
  MdeModulePkg/Universal/Acpi/S3SaveStateDxe/S3SaveStateDxe.inf
  MdeModulePkg/Universal/Acpi/BootScriptExecutorDxe/BootScriptExecutorDxe.inf
!endif
  MdeModulePkg/Universal/Acpi/BootGraphicsResourceTableDxe/BootGraphicsResourceTableDxe.inf
  MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableDxe/FirmwarePerformanceDxe.inf     <---- Add
```
- ```OvmfPkg/Library/QemuBootOrderLib/QemuBootOrderLib.c```
  - Search for function: `GetFrontPageTimeoutFromQemu`

## Secure Boot

- [https://github.com/microsoft/secureboot_objects](https://github.com/microsoft/secureboot_objects)
  - PostSignedObjects
    - [DBXUpdate.bin](https://github.com/microsoft/secureboot_objects/blob/main/PostSignedObjects/DBX/amd64/DBXUpdate.bin)
  - PreSignedObjects
    - [PK,KEK,DB.der](https://github.com/microsoft/secureboot_objects/blob/main/PreSignedObjects)

## virt-fw-vars
- [uefi-variable-store](https://www.qemu.org/docs/master/interop/qemu-qmp-ref.html#uefi-variable-store)
- [virt-fw-vars - man page](https://man.archlinux.org/man/extra/virt-firmware/virt-fw-vars.1.en)
- [json support for efi - python script](https://gitlab.com/kraxel/virt-firmware/-/blob/master/virt/firmware/efi/efijson.py)

## Generated firmware from template that is writable:

```
/var/lib/libvirt/qemu/nvram
```

## STORAGE:

```
/var/lib/libvirt/images/
```



## Firmware Specifications

- https://uefi.org/specifications
  - [ACPI Specification](https://uefi.org/sites/default/files/resources/ACPI_Spec_6.6.pdf)
  - [UEFI Specification](https://uefi.org/sites/default/files/resources/UEFI_Spec_Final_2.11.pdf)

| Variable Name | Variable GUID |
|-|-|
| EFI_GLOBAL_VARIABLE | 8be4df61-93ca-11d2-aa0d-00e098032b8c |
| EFI_IMAGE_SECURITY_DATABASE_GUID | d719b2cb-3d3a-4596-a3bc-dad00e67656f |





</details>












---

# QEMU / Emulator

<details>
<summary>Expand for details...</summary>

## KVM-specific Custom MSR/Signatures

> Reference: [`kvm_para.h`](https://gitlab.com/qemu-project/qemu/-/blob/master/include/standard-headers/asm-x86/kvm_para.h)

### Hypervisor Bit

Clears `CPUID.1.ECX[31]` â€” the universal "hypervisor present" indicator.

```xml
  <cpu>
    <feature policy="disable" name="hypervisor"/>
  </cpu>
```

### KVM Signature & Feature Bits

Hides `CPUID 0x40000000` (`KVMKVMKVM` signature) and `CPUID 0x40000001` (KVM feature bits).

```xml
<features>
  <kvm>
    <hidden state="on"/>
  </kvm>
</features>
```

### KVM paravirtualization features

Disables all KVM paravirtualization features

```patch
diff --git a/target/i386/kvm/kvm-cpu.c b/target/i386/kvm/kvm-cpu.c
index 9c25b55..af64a32 100644
--- a/target/i386/kvm/kvm-cpu.c
+++ b/target/i386/kvm/kvm-cpu.c
@@ -174,12 +174,12 @@ static void kvm_cpu_xsave_init(void)
  *       docs/system/target-i386.rst)
  */
 static PropValue kvm_default_props[] = {
-    { "kvmclock", "on" },
-    { "kvm-nopiodelay", "on" },
-    { "kvm-asyncpf", "on" },
-    { "kvm-steal-time", "on" },
-    { "kvm-pv-eoi", "on" },
-    { "kvmclock-stable-bit", "on" },
+    { "kvmclock", "off" },
+    { "kvm-nopiodelay", "off" },
+    { "kvm-asyncpf", "off" },
+    { "kvm-steal-time", "off" },
+    { "kvm-pv-eoi", "off" },
+    { "kvmclock-stable-bit", "off" },
     { "x2apic", "on" },
     { "kvm-msi-ext-dest-id", "off" },
     { "acpi", "off" },
```

</details>








---

# XML

<details>
<summary>Expand for details...</summary>

### AMD Libvirt XML Reference:

<details>
<summary>Expand for XML...</summary>

```xml
<!--
  ******************************************************************************
  *                              IMPORTANT NOTICE                              *
  ******************************************************************************
  *                                                                            *
  *  DO NOT BLINDLY COPY AND PASTE THIS CONFIGURATION.                         *
  *                                                                            *
  *  This XML configuration is provided as a template and should be carefully  *
  *  reviewed and adjusted to match your specific system requirements.         *
  *                                                                            *
  *  Always work section by section, ensuring that each parameter is           *
  *  appropriate for your environment. Blindly copying and pasting may lead    *
  *  to misconfigurations, security vulnerabilities, or system instability.    *
  *                                                                            *
  *  Take the time to understand each setting and modify it as needed.         *
  *                                                                            *
  ******************************************************************************
-->

<domain xmlns:qemu="http://libvirt.org/schemas/domain/qemu/1.0" type="kvm"> <!-- Don't forget XMLNS! -->
  <uuid>XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX</uuid> <!-- FYI: This is NOT the guest system's UUID in SMBIOS! -->

  <memory unit="G">16</memory>  <!-- Utilize realistic memory amounts, such as 8, 16, 32, and 64. -->
  <currentMemory unit="G">16</currentMemory>





  <!--
  <> https://libvirt.org/formatdomain.html#operating-system-booting



  -->
  <os>
    <type arch="x86_64" machine="pc-q35-10.2">hvm</type>
    <loader readonly="yes" secure="yes" type="pflash" format="qcow2">/opt/Hypervisor-Phantom/firmware/OVMF_CODE.qcow2</loader>
    <nvram template="/opt/Hypervisor-Phantom/firmware/OVMF_VARS.qcow2" format="qcow2"></nvram>
    <bootmenu enable="yes"/>
    <smbios mode="host"/> <!-- Remove if 'smbios.bin' is being passed through -->
  </os>





  <!-- 
  <> https://libvirt.org/formatdomain.html#hypervisor-features


 
  -->
  <features>
    <acpi/>
    <apic/>
    <!-- Disable all enlightenments if Hyper-V method is NOT used.
    Enlightenments on "bare-metal" are flagged / extremely suspicious! -->
    <hyperv mode="custom">
      <relaxed state="off"/>
      <vapic state="off"/>
      <spinlocks state="off"/>
      <vpindex state="off"/>
      <runtime state="off"/>
      <synic state="off"/>
      <stimer state="off"/>
      <reset state="off"/>
      <vendor_id state="on" value="AuthenticAMD"/> <!-- KVM patch NOT present | Apply to fix NVIDIA (Code 43) error -->
      <vendor_id state="off"/>                     <!-- KVM patch IS present -->
      <frequencies state="off"/>
      <reenlightenment state="off"/>
      <tlbflush state="off"/>
      <ipi state="off"/>
      <evmcs state="off"/>
      <avic state="off"/>
      <emsr_bitmap state="off"/>
      <xmm_input state="off"/>
    </hyperv>
    <kvm>
      <hidden state="on"/> <!-- CONCEALMENT: Hide the KVM hypervisor from standard MSR based discovery (CPUID Bitset) -->
    </kvm>
    <pmu state="off"/> <!-- CONCEALMENT: Disables the Performance Monitoring Unit (PMU) -->
    <vmport state="off"/> <!-- CONCEALMENT: Disables the VMware I/O port backdoor (VMPort, 0x5658) in the guest | FYI: ACE AC looks for this -->
    <smm state="on"/>
    <msrs unknown="fault"/> <!-- CONCEALMENT: Injects a #GP(0) into the guest on RDMSR/WRMSR to an unhandled/unknown MSR -->
  </features>





  <!--
  <> https://libvirt.org/formatdomain.html#cpu-model-and-topology


 
  -->
  <cpu mode="host-passthrough" check="none" migratable="off">
    <topology sockets="1" dies="1" clusters="1" cores="8" threads="2"/>
    <cache mode="passthrough"/>
    <maxphysaddr mode="passthrough"/>
   
    <!-- Performance Features -->
    <feature policy="require" name="svm"/>        <!-- OPTIMIZATION: Requires AMD SVM (hardware virtualization) to be exposed to the guest (needed for nested virtualization) -->
    <feature policy="require" name="topoext"/>    <!-- OPTIMIZATION: Requires AMD topology extensions (more accurate core/thread/cache topology reporting to the guest) -->
    <feature policy="require" name="invtsc"/>     <!-- OPTIMIZATION: Requires invariant TSC (stable time-stamp counter rate across P-states/C-states) for more consistent guest timekeeping -->
   
    <!-- Hypervisor Detection -->
    <feature policy="disable" name="hypervisor"/> <!-- CONCEALMENT: Clears CPUID.1:ECX[31] (Hypervisor Present bit) -->
   
    <!-- Speculative Execution Mitigations -->
    <feature policy="disable" name="ssbd"/>       <!-- CONCEALMENT: Disables Speculative Store Bypass Disable flag -->
    <feature policy="disable" name="amd-ssbd"/>   <!-- CONCEALMENT: Disables AMD's Speculative Store Bypass Disable flag -->
    <feature policy="disable" name="virt-ssbd"/>  <!-- CONCEALMENT: Disables virtualized speculative store bypass mitigation -->
   
    <!-- Timing Features -->
    <feature policy="disable" name="rdtscp"/>     <!-- Disables the RDTSCP instruction (Use if using patched kernel) -->
  </cpu>





  <!--
  <> https://libvirt.org/formatdomain.html#time-keeping

 
 
  -->
  <clock offset="localtime">
    <timer name="tsc" present="yes" mode="native"/>
    <timer name="kvmclock" present="no"/>    <!-- CONCEALMENT: Disable KVM paravirtual clock source -->
    <timer name="hypervclock" present="no"/> <!-- CONCEALMENT: Disable Hyper-V paravirtual clock source -->
  </clock>





  <!--
  <> https://libvirt.org/formatdomain.html#power-management

  Guest power-management sleep states
  -->
  <pm>
    <suspend-to-mem enabled="yes"/>  <!-- CONCEALMENT: Enables S3 ACPI sleep state (suspend-to-RAM) support in the guest -->
    <suspend-to-disk enabled="yes"/> <!-- CONCEALMENT: Enables S4 ACPI sleep state (suspend-to-disk/hibernate) support in the guest -->
  </pm>





  <devices>
    <emulator>/opt/Hypervisor-Phantom/emulator/bin/qemu-system-x86_64</emulator> <!-- 'qemu-system-x86_64' binary location. -->
    




    <!--
    <> https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms

    If you have a spare physical NVMe SSD, use that instead by doing PCI passthrough via libvirt.
    -->
    <disk type="file" device="disk"> <!-- Use block devices (partitons) for better performance -->
      <driver name="qemu" type="raw" cache="none" io="native" discard="unmap"/> <!-- use io="threads" in block mode -->
      <source file="/var/lib/libvirt/images/win10.img"/>
      <target dev="sdd" bus="nvme"/> <!-- Switch to '<source dev="/dev/sdb"/>' for using a host SATA drive. -->
      <serial>????????????????????</serial> <!-- Serial number -->
      <boot order="1"/>
      <address type="drive" controller="0" bus="0" target="0" unit="0"/>
    </disk>




 
    <!--
    <> https://libvirt.org/formatdomain.html#network-interfaces

   
    -->
    <interface type="network">
      <mac address="XX:XX:XX:XX:XX:XX"/> <!-- Randomize MAC address! -->
      <source network="default"/> <!-- DO NOT USE "VirtIO" -->
    </interface>





    <!--
    <> https://libvirt.org/formatdomain.html#tpm-device

    TPM emulation requires the 'swtpm' package to function properly.
    -->
    <tpm model="tpm-crb">
      <backend type="emulator" version="2.0"/>
    </tpm>





    <!--
    <> https://libvirt.org/formatdomain.html#memory-balloon-device

    Disables the virtio memory balloon device (no ballooning / dynamic RAM adjustment)
    -->
    <memballoon model="none"/>





    <!--
    <> https://libvirt.org/formatdomain.html#video-devices

    Set the video model to "none" to prevent detection of a virtualized environment.
    Virtualized video devices can be a giveaway of a hypervisor, especially if the vendor ID is not spoofed.
    
    Setting the video model to "none" ensures that no virtual video device is presented to the guest, which
    can help avoid detection of the underlying hypervisor.
    
    Additionally, if you're using the Looking Glass shared-memory-device program, setting the video model to
    "none" is necessary to ensure proper functionality, as Looking Glass relies on a direct framebuffer access method.
    -->
    <video>
      <model type="none"/>
    </video>





    <!--
    <> https://libvirt.org/formatdomain.html#shared-memory-device
    <> https://looking-glass.io/docs/B7/install/#ivshmem

    +----------------------+------------------------+----------------------------+
    | Resolution           | Standard Dynamic Range | High Dynamic Range (HDR) * |
    +----------------------+------------------------+----------------------------+
    | 1920x1080 (1080p)    | 32                     | 64                         |
    | 1920x1200 (1200p)    | 32                     | 64                         |
    | 2560x1440 (1440p)    | 64                     | 128                        |
    | 3840x2160 (2160p/4K) | 128                    | 256                        |
    +----------------------+------------------------+----------------------------+
    -->
    <shmem name="looking-glass">
      <model type="ivshmem-plain"/>
      <size unit="M">32</size>
    </shmem>
  </devices>





  <!--
  <> https://www.qemu.org/docs/master/system/qemu-manpage.html#hxtool-4
  <> https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.9.0.pdf

  
  -->
  <qemu:commandline>

    <!-- Spoofs ACPI table data (Battery) -->
    <qemu:arg value="-acpitable"/>
    <qemu:arg value="file=/opt/Hypervisor-Phantom/firmware/SSDT*-battery.aml"/>
   
    <!-- Spoofs the entire SMBIOS using a host dump -->
    <qemu:arg value="-smbios"/>
    <qemu:arg value="file=/opt/Hypervisor-Phantom/firmware/smbios.bin"/>
   
    <!-- Spoofs the SMBIOS DMI Type 1, 2, 3, 4 and 17 HWIDs
    Type 0 (BIOS / Firmware) <> https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.2.0.pdf#%5B%7B%22num%22%3A74%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C260%2C0%5D
    Type 1 (System Information) <> https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.2.0.pdf#%5B%7B%22num%22%3A85%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C212%2C0%5D
    Type 2 (Baseboard / Motherboard) <> https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.2.0.pdf#%5B%7B%22num%22%3A91%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C206%2C0%5D
    Type 3 (Chassis / Computer Case) <> https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.2.0.pdf#%5B%7B%22num%22%3A99%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C178%2C0%5D
    Type 4 (Processor / CPU) <> https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.2.0.pdf#%5B%7B%22num%22%3A114%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C583%2C0%5D
    Type 17 (Memory / RAM) <> https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.2.0.pdf#%5B%7B%22num%22%3A258%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C597%2C0%5D
    -->
    <qemu:arg value="-smbios"/>
    <qemu:arg value="type=0,version=XXXXXXX,date=XX/XX/XXXX,uefi=true"/> <!-- Explicitly marks the BIOS as UEFI-compliant -->
    <qemu:arg value="-smbios"/>
    <qemu:arg value="type=1,serial=To be filled by O.E.M.,uuid=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX"/>  <!-- UUID Spoofer; You can spoof this UUID to any UUID -->
    <qemu:arg value="-smbios"/>
    <qemu:arg value="type=2,serial=To be filled by O.E.M."/>
    <qemu:arg value="-smbios"/>
    <qemu:arg value="type=3,serial=To be filled by O.E.M."/>
    <qemu:arg value="-smbios"/>
    <qemu:arg value="type=4,sock_pfx={Your socket designation},manufacturer=Advanced Micro Devices,, Inc.,version={Your CPU model name},max-speed={X},current-speed={X}"/>
    <qemu:arg value="-smbios"/>
    <qemu:arg value="type=17,loc_pfx=Controller0-ChannelA-DIMM0,bank=BANK 0,manufacturer=Samsung,serial=Unknown,asset=Not Specified,part=Not Specified,speed=4800"/>

    <!-- IVSHMEM with the KVMFR module
    The kernel module implements a basic interface to the IVSHMEM device for Looking Glass allowing DMA GPU transfers.
    -->
    <qemu:arg value="-device"/>
    <qemu:arg value="{'driver':'ivshmem-plain','id':'shmem0','memdev':'looking-glass'}"/>
    <qemu:arg value="-object"/>
    <qemu:arg value="{'qom-type':'memory-backend-file','id':'looking-glass','mem-path':'/dev/kvmfr0','size':33554432,'share':true}"/>
   
  </qemu:commandline>





  <!--
  <> https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms
  <> https://libvirt.org/drvqemu.html#overriding-properties-of-qemu-devices

  TL;DR - Only use this if your host is SSD-backed and you're using virtual storage (Ex. .qcow) for guest.
 
  Use override for SATA device properties to optimize discard handling and rotation settings for SSD-backed qcow virtual storage.
  This configuration allows you to specify advanced disk properties that help optimize performance for SSD-backed virtual disks,
  particularly with regard to discard operations and rotation rate. The properties below control specific QEMU disk device features:

  - `rotation_rate`: Sets the rotation rate of the virtual disk. A value of `1` indicates that the disk is an
                     SSD (solid-state drive), optimizing I/O behavior for non-rotational storage.

  - `discard_granularity`: Controls the granularity of discard operations. Setting this value to `0` can optimize how the
                           guest OS handles the discard requests, affecting the performance of SSD-backed virtual disks.

  This setup is recommended for systems using SSD-backed virtual storage in qcow format, as it improves compatibility and
  performance when using discard operations and better reflects the behavior of SSD storage.
  -->
  <qemu:override>
    <qemu:device alias="sata0-0-0">
      <qemu:frontend>
        <qemu:property name="rotation_rate" type="unsigned" value="1"/>
        <qemu:property name="discard_granularity" type="unsigned" value="0"/>
      </qemu:frontend>
    </qemu:device>
  </qemu:override>
</domain>
```

</details>


### Intel Libvirt XML Reference:

<details>
<summary>Expand for XML...</summary>

```xml
<!--
  ******************************************************************************
  *                              IMPORTANT NOTICE                              *
  ******************************************************************************
  *                                                                            *
  *  DO NOT BLINDLY COPY AND PASTE THIS CONFIGURATION.                         *
  *                                                                            *
  *  This XML configuration is provided as a template and should be carefully  *
  *  reviewed and adjusted to match your specific system requirements.         *
  *                                                                            *
  *  Always work section by section, ensuring that each parameter is           *
  *  appropriate for your environment. Blindly copying and pasting may lead    *
  *  to misconfigurations, security vulnerabilities, or system instability.    *
  *                                                                            *
  *  Take the time to understand each setting and modify it as needed.         *
  *                                                                            *
  ******************************************************************************
-->

<domain xmlns:qemu="http://libvirt.org/schemas/domain/qemu/1.0" type="kvm"> <!-- Don't forget XMLNS! -->
  <uuid>XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX</uuid> <!-- FYI: This is NOT the guest system's UUID in SMBIOS! -->

  <memory unit="G">16</memory>  <!-- Utilize realistic memory amounts, such as 8, 16, 32, and 64. -->
  <currentMemory unit="G">16</currentMemory>





  <!--
  <> https://libvirt.org/formatdomain.html#operating-system-booting

 
  -->
  <os>
    <type arch="x86_64" machine="pc-q35-10.2">hvm</type>
    <loader readonly="yes" secure="yes" type="pflash" format="qcow2">/opt/Hypervisor-Phantom/firmware/OVMF_CODE.qcow2</loader>
    <nvram template="/opt/Hypervisor-Phantom/firmware/OVMF_VARS.qcow2" format="qcow2"></nvram>
    <bootmenu enable="yes"/>
    <smbios mode="host"/> <!-- Remove if 'smbios.bin' is being passed through -->
  </os>





  <!-- 
  <> https://libvirt.org/formatdomain.html#hypervisor-features

 
  -->
  <features>
    <acpi/>
    <apic/>
    <!-- Disable all enlightenments, if Hyper-V method is not used.
    Enlightenments on "bare-metal" are extremely suspicious -->
    <hyperv mode="custom">
      <relaxed state="off"/>
      <vapic state="off"/>
      <spinlocks state="off"/>
      <vpindex state="off"/>
      <runtime state="off"/>
      <synic state="off"/>
      <stimer state="off"/>
      <reset state="off"/>
      <vendor_id state="on" value="GenuineIntel"/> <!-- KVM patch NOT present | Apply to fix NVIDIA (Code 43) error -->
      <vendor_id state="off"/>                     <!-- KVM patch IS present -->
      <frequencies state="off"/>
      <reenlightenment state="off"/>
      <tlbflush state="off"/>
      <ipi state="off"/>
      <evmcs state="off"/>
      <avic state="off"/>
      <emsr_bitmap state="off"/>
      <xmm_input state="off"/>
    </hyperv>
    <kvm>
      <hidden state="on"/> <!-- CONCEALMENT: Hide the KVM hypervisor from standard MSR based discovery (CPUID Bitset) -->
    </kvm>
    <pmu state="off"/> <!-- CONCEALMENT: Disables the Performance Monitoring Unit (PMU) -->
    <vmport state="off"/> <!-- CONCEALMENT: Disables the VMware I/O port backdoor (VMPort, 0x5658) in the guest | FYI: ACE AC looks for this -->
    <smm state="on"/>
    <msrs unknown="fault"/> <!-- CONCEALMENT: Injects a #GP(0) into the guest on RDMSR/WRMSR to an unhandled/unknown MSR -->
  </features>





  <!--
  <> https://libvirt.org/formatdomain.html#cpu-model-and-topology

 
  -->
  <cpu mode="host-passthrough" check="none" migratable="off">
    <topology sockets="1" dies="1" clusters="1" cores="8" threads="2"/>
    <cache mode="passthrough"/>
    <maxphysaddr mode="passthrough"/>
    
    <!-- Performance Features -->
    <feature policy="require" name="vmx"/>        <!-- OPTIMIZATION: Requires Intel VT-x (hardware virtualization) to be exposed to the guest (needed for nested virtualization) -->
    <feature policy="require" name="invtsc"/>     <!-- OPTIMIZATION: Requires invariant TSC (stable time-stamp counter rate across P-states/C-states) for more consistent guest timekeeping -->
  
    <!-- Hypervisor Detection -->
    <feature policy="disable" name="hypervisor"/> <!-- CONCEALMENT: Clears CPUID.1:ECX[31] (Hypervisor Present bit) -->
   
    <!-- Speculative Execution Mitigations -->
    <feature policy="disable" name="ssbd"/>       <!-- CONCEALMENT: Disables Speculative Store Bypass Disable flag -->
    <feature policy="disable" name="virt-ssbd"/>  <!-- CONCEALMENT: Disables virtualized speculative store bypass mitigation -->
   
    <!-- Timing Features -->
    <feature policy="disable" name="rdtscp"/>     <!-- Disables the RDTSCP instruction (Use if using patched kernel) -->
  </cpu>





  <!--
  <> https://libvirt.org/formatdomain.html#time-keeping

 
  -->
  <clock offset="localtime">
    <timer name="tsc" present="yes" mode="native"/>
    <timer name="kvmclock" present="no"/>    <!-- CONCEALMENT: Disable KVM paravirtual clock source -->
    <timer name="hypervclock" present="no"/> <!-- CONCEALMENT: Disable Hyper-V paravirtual clock source -->
  </clock>





  <!--
  <> https://libvirt.org/formatdomain.html#power-management

  Guest power-management sleep states
  -->
  <pm>
    <suspend-to-mem enabled="yes"/>  <!-- CONCEALMENT: Enables S3 ACPI sleep state (suspend-to-RAM) support in the guest -->
    <suspend-to-disk enabled="yes"/> <!-- CONCEALMENT: Enables S4 ACPI sleep state (suspend-to-disk/hibernate) support in the guest -->
  </pm>





  <devices>
    <emulator>/opt/Hypervisor-Phantom/emulator/bin/qemu-system-x86_64</emulator> <!-- 'qemu-system-x86_64' binary location. -->





    <!--
    <> https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms

    If you have a spare physical NVMe SSD, use that instead by doing PCI passthrough via libvirt.
    -->
    <disk type="file" device="disk"> <!-- Use block devices (partitons) for better performance -->
      <driver name="qemu" type="raw" cache="none" io="native" discard="unmap"/> <!-- use io="threads" in block mode -->
      <source file="/var/lib/libvirt/images/win10.img"/>
      <target dev="sdd" bus="nvme"/> <!-- Switch to '<source dev="/dev/sdb"/>' for using a host SATA drive. -->
      <serial>????????????????????</serial> <!-- Serial number -->
      <boot order="1"/>
      <address type="drive" controller="0" bus="0" target="0" unit="0"/>
    </disk>





    <!--
    <> https://libvirt.org/formatdomain.html#network-interfaces

   
    -->
    <interface type="network">
      <mac address="XX:XX:XX:XX:XX:XX"/> <!-- Randomize MAC address! -->
      <source network="default"/> <!-- DO NOT USE "VirtIO" -->
    </interface>





    <!--
    <> https://libvirt.org/formatdomain.html#tpm-device

    TPM emulation requires the 'swtpm' package to function properly.
    -->
    <tpm model="tpm-crb">
      <backend type="emulator" version="2.0"/>
    </tpm>





    <!--
    <> https://libvirt.org/formatdomain.html#memory-balloon-device

    Disables the virtio memory balloon device (no ballooning / dynamic RAM adjustment)
    -->
    <memballoon model="none"/>





    <!--
    <> https://libvirt.org/formatdomain.html#video-devices

    Set the video model to "none" to prevent detection of a virtualized environment.
    Virtualized video devices can be a giveaway of a hypervisor, especially if the vendor ID is not spoofed.
    
    Setting the video model to "none" ensures that no virtual video device is presented to the guest, which
    can help avoid detection of the underlying hypervisor.
    
    Additionally, if you're using the Looking Glass shared-memory-device program, setting the video model to
    "none" is necessary to ensure proper functionality, as Looking Glass relies on a direct framebuffer access method.
    -->
    <video>
      <model type="none"/>
    </video>





    <!--
    <> https://libvirt.org/formatdomain.html#shared-memory-device
    <> https://looking-glass.io/docs/B7/install/#ivshmem

    +----------------------+------------------------+----------------------------+
    | Resolution           | Standard Dynamic Range | High Dynamic Range (HDR) * |
    +----------------------+------------------------+----------------------------+
    | 1920x1080 (1080p)    | 32                     | 64                         |
    | 1920x1200 (1200p)    | 32                     | 64                         |
    | 2560x1440 (1440p)    | 64                     | 128                        |
    | 3840x2160 (2160p/4K) | 128                    | 256                        |
    +----------------------+------------------------+----------------------------+
    -->
    <shmem name="looking-glass">
      <model type="ivshmem-plain"/>
      <size unit="M">32</size>
    </shmem>
  </devices>





  <!--
  <> https://www.qemu.org/docs/master/system/qemu-manpage.html#hxtool-4
  <> https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.9.0.pdf

 
  -->
  <qemu:commandline>

    <!-- Spoofs ACPI table data (Battery) -->
    <qemu:arg value="-acpitable"/>
    <qemu:arg value="file=/opt/Hypervisor-Phantom/firmware/SSDT*-battery.aml"/>
   
    <!-- Spoofs the entire SMBIOS using a host dump -->
    <qemu:arg value="-smbios"/>
    <qemu:arg value="file=/opt/Hypervisor-Phantom/firmware/smbios.bin"/>
   
    <!-- Spoofs the SMBIOS DMI Type 1, 2, 3, 4 and 17 HWIDs
    Type 0 (BIOS / Firmware) <> https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.2.0.pdf#%5B%7B%22num%22%3A74%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C260%2C0%5D
    Type 1 (System Information) <> https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.2.0.pdf#%5B%7B%22num%22%3A85%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C212%2C0%5D
    Type 2 (Baseboard / Motherboard) <> https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.2.0.pdf#%5B%7B%22num%22%3A91%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C206%2C0%5D
    Type 3 (Chassis / Computer Case) <> https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.2.0.pdf#%5B%7B%22num%22%3A99%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C178%2C0%5D
    Type 4 (Processor / CPU) <> https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.2.0.pdf#%5B%7B%22num%22%3A114%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C583%2C0%5D
    Type 17 (Memory / RAM) <> https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.2.0.pdf#%5B%7B%22num%22%3A258%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C597%2C0%5D
    -->
    <qemu:arg value="-smbios"/>
    <qemu:arg value="type=0,version=XXXXXXX,date=XX/XX/XXXX,uefi=true"/> <!-- Explicitly marks the BIOS as UEFI-compliant -->
    <qemu:arg value="-smbios"/>
    <qemu:arg value="type=1,serial=To be filled by O.E.M.,uuid=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX"/>  <!-- UUID Spoofer; You can spoof this UUID to any UUID -->
    <qemu:arg value="-smbios"/>
    <qemu:arg value="type=2,serial=To be filled by O.E.M."/>
    <qemu:arg value="-smbios"/>
    <qemu:arg value="type=3,serial=To be filled by O.E.M."/>
    <qemu:arg value="-smbios"/>
    <qemu:arg value="type=4,sock_pfx={Your socket designation},manufacturer=Intel(R) Corporation,version={Your CPU model name},max-speed={X},current-speed={X}"/>
    <qemu:arg value="-smbios"/>
    <qemu:arg value="type=17,loc_pfx=Controller0-ChannelA-DIMM0,bank=BANK 0,manufacturer=Samsung,serial=Unknown,asset=Not Specified,part=Not Specified,speed=4800"/>

    <!-- IVSHMEM with the KVMFR module
    The kernel module implements a basic interface to the IVSHMEM device for Looking Glass allowing DMA GPU transfers.
    -->
    <qemu:arg value="-device"/>
    <qemu:arg value="{'driver':'ivshmem-plain','id':'shmem0','memdev':'looking-glass'}"/>
    <qemu:arg value="-object"/>
    <qemu:arg value="{'qom-type':'memory-backend-file','id':'looking-glass','mem-path':'/dev/kvmfr0','size':33554432,'share':true}"/>
   
  </qemu:commandline>





  <!--
  <> https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms
  <> https://libvirt.org/drvqemu.html#overriding-properties-of-qemu-devices

  TL;DR - Only use this if your host is SSD-backed and you're using virtual storage (Ex. .qcow) for guest.
 
  Use override for SATA device properties to optimize discard handling and rotation settings for SSD-backed qcow virtual storage.
  This configuration allows you to specify advanced disk properties that help optimize performance for SSD-backed virtual disks,
  particularly with regard to discard operations and rotation rate. The properties below control specific QEMU disk device features:

  - `rotation_rate`: Sets the rotation rate of the virtual disk. A value of `1` indicates that the disk is an
                     SSD (solid-state drive), optimizing I/O behavior for non-rotational storage.

  - `discard_granularity`: Controls the granularity of discard operations. Setting this value to `0` can optimize how the
                           guest OS handles the discard requests, affecting the performance of SSD-backed virtual disks.

  This setup is recommended for systems using SSD-backed virtual storage in qcow format, as it improves compatibility and
  performance when using discard operations and better reflects the behavior of SSD storage.
  -->
  <qemu:override>
    <qemu:device alias="sata0-0-0">
      <qemu:frontend>
        <qemu:property name="rotation_rate" type="unsigned" value="1"/>
        <qemu:property name="discard_granularity" type="unsigned" value="0"/>
      </qemu:frontend>
    </qemu:device>
  </qemu:override>
</domain>
```

</details>




</details>

---













# Looking Glass

<details>
<summary>Expand for details...</summary>

- https://looking-glass.io/
- https://github.com/gnif/LookingGlass

- Building
  - https://looking-glass.io/docs/B7/build/#building-the-windows-installer

## Unique Identifiers:

- GUID
  - vendor/ivshmem/ivshmem.h
- Windows driver/package
  - host/platform/Windows/installer.nsi
  - idd/installer.nsi
- Vendor/Device IDs
  - module/kvmfr.c

#### GUID_DEVINTERFACE_IVSHMEM
```
LookingGlass/vendor/ivshmem/ivshmem.h
```
```h
DEFINE_GUID (GUID_DEVINTERFACE_IVSHMEM,
    0xdf576976,0x569d,0x4672,0x95,0xa0,0xf5,0x7e,0x4e,0xa0,0xb2,0x10);
// {df576976-569d-4672-95a0-f57e4ea0b210}
```

#### Windows Driver Interface GUID
```
idd/LGIdd/Public.h
```
```h
// {997b0b66-b74c-4017-9a89-e4aad41d3780}
DEFINE_GUID (GUID_DEVINTERFACE_LGIdd, 0x997b0b66,0xb74c,0x4017,0x9a,0x89,0xe4,0xaa,0xd4,0x1d,0x37,0x80);
```

#### Driver Tracing GUID
```
idd/LGIdd/Trace.h
```
```h
  WPP_DEFINE_CONTROL_GUID(                                      \
    MyDriver1TraceGuid, (58bf0aac,4a52,4560,9873,693b645c0a47), \
```

#### Hardware ID and Registry Key
```
idd/LGIddInstall/LGIddInstall.c
```
```
#define LGIDD_CLASS_GUID GUID_DEVCLASS_DISPLAY
#define LGIDD_CLASS_NAME L"Display"
#define LGIDD_HWID L"Root\\LGIdd"
#define LGIDD_HWID_MULTI_SZ (LGIDD_HWID "\0")
#define LGIDD_INF_NAME L"LGIdd.inf"
#define LGIDD_REGKEY L"Software\\LookingGlass\\IDD"
```

#### KVMFR Protocol Magic & Version
```
common/include/common/KVMFR.h
```
```
#define KVMFR_MAGIC   "KVMFR---"
#define KVMFR_VERSION 20
```

#### PCI_KVMFR_{VENDOR,DEVICE}_ID
```
module/kvmfr.c
```
```c
#define PCI_KVMFR_VENDOR_ID 0x1af4 //Red Hat Inc,
#define PCI_KVMFR_DEVICE_ID 0x1110 //Inter-VM shared memory
...
#define KVMFR_DEV_NAME    "kvmfr"
```

</details>

```

`modules/deploy.sh`:

```sh
#!/usr/bin/env bash

source ./utils.sh || { echo "Failed to load utilities module!"; exit 1; }

system_info() {
    # Domain Name
    DOMAIN_NAME="AutoVirt"

    # CPU Topology
    HOST_LOGICAL_CPUS=$(nproc --all 2>/dev/null || nproc 2>/dev/null)
    HOST_CORES_PER_SOCKET=$(LC_ALL=C lscpu | sed -n 's/^Core(s) per socket:[[:space:]]*//p')
    HOST_THREADS_PER_CORE=$(LC_ALL=C lscpu | sed -n 's/^Thread(s) per core:[[:space:]]*//p')

    # MAC Address (Uses host's OUI)
    UPLINK_IFACE=$(nmcli -t device show | awk -F: '
    /^GENERAL.DEVICE/ {dev=$2}
    /^GENERAL.TYPE/   {type=$2}
    /^IP4.GATEWAY/ && $2!="" && type!="wireguard" {print dev; exit}
    ')
    OUI=$(cat /sys/class/net/"$UPLINK_IFACE"/address | awk -F: '{print $1 ":" $2 ":" $3}')
    RANDOM_MAC="$OUI:$(printf '%02x:%02x:%02x' $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256)))"

    # Random 20-char hex serial (A-F0-9)
    DRIVE_SERIAL="$(LC_ALL=C tr -dc 'A-F0-9' </dev/urandom | head -c 20)"

    # Random WWN (World Wide Name) - 16 hex chars, typically starts with 5 for NAA
    # DRIVE_WWN="0x5$(LC_ALL=C tr -dc '0-9a-f' </dev/urandom | head -c 15)"

    # Memory selection (MiB)
    local mem_choice
    while :; do
        fmtr::log "Memory allocation:

  1) 8  GiB  (8192  MiB)
  2) 12 GiB  (12288 MiB)
  3) 16 GiB  (16384 MiB)
  4) 24 GiB  (24576 MiB)
  5) 32 GiB  (32768 MiB)
  6) 64 GiB  (65536 MiB)"

        read -r -p "$(fmtr::ask_inline "Choose an option [1-6]: ")" mem_choice
        printf '%s\n' "$mem_choice" >>"$LOG_FILE"

        case "$mem_choice" in
            1) HOST_MEMORY_MIB=8192  ;;
            2) HOST_MEMORY_MIB=12288 ;;
            3) HOST_MEMORY_MIB=16384 ;;
            4) HOST_MEMORY_MIB=24576 ;;
            5) HOST_MEMORY_MIB=32768 ;;
            6) HOST_MEMORY_MIB=65536 ;;
            *) fmtr::warn "Invalid option. Please choose 1â€“6."; continue ;;
        esac

        fmtr::info "Selected #$mem_choice ($HOST_MEMORY_MIB MiB)"
        break
    done

    # ISO Selection
    DOWNLOADS_DIR="/home/$USER/Downloads"
    ISO_PATH=""

    ensure_permissions() {
        local target_path="$1"
        local username="libvirt-qemu"
        local dirs_to_check=()

        local current_dir="$target_path"
        while [[ "$current_dir" != "/" && "$current_dir" != "/home" ]]; do
            dirs_to_check+=("$current_dir")
            current_dir="$(dirname "$current_dir")"
        done

        for ((i=${#dirs_to_check[@]}-1; i>=0; i--)); do
            local dir="${dirs_to_check[$i]}"

            # Check if libvirt-qemu already has access via ACL
            if getfacl "$dir" 2>/dev/null | grep -q "user:$username:.*x"; then
                continue
            fi

            # Check if directory is already world-executable
            if [[ -x "$dir" ]]; then
                continue
            fi

            # Try setting ACL first (preferred - more granular)
            if command -v setfacl &> /dev/null; then
                if $ROOT_ESC setfacl --modify "user:$username:x" "$dir" 2>/dev/null; then
                    fmtr::info "Set ACL execute permission for $username on $dir"
                    continue
                fi
            fi

            # Fallback to chmod o+x
            if $ROOT_ESC chmod o+x "$dir" 2>/dev/null; then
                fmtr::info "Set world-execute permission on $dir"
                continue
            fi

            fmtr::warn "Failed to set permissions on $dir"
            return 1
        done

        return 0
    }

    if ! ensure_permissions "$DOWNLOADS_DIR"; then
        fmtr::fatal "Failed to set proper permissions for libvirt-qemu on $DOWNLOADS_DIR or its parent directories."
        exit 1
    fi

    mapfile -d '' -t ISO_FILES < <(find "$DOWNLOADS_DIR" -maxdepth 1 -type f -iname '*.iso' -print0 | sort -z)

    if (( ${#ISO_FILES[@]} == 0 )); then
        fmtr::fatal "No .iso files found in $DOWNLOADS_DIR"
        exit 1
    fi

    while :; do
        menu="Available ISOs ($DOWNLOADS_DIR):\n"
        for i in "${!ISO_FILES[@]}"; do
            menu+="\n  $((i+1))) $(basename -- "${ISO_FILES[$i]}")"
        done
        fmtr::log "$menu"

        read -r -p "$(fmtr::ask_inline "Choose an ISO [1-${#ISO_FILES[@]}]: ")" ISO_CHOICE
        printf '%s\n' "$ISO_CHOICE" >>"$LOG_FILE"

        [[ "$ISO_CHOICE" =~ ^[0-9]+$ ]] || { fmtr::warn "Please enter a number."; continue; }
        (( ISO_CHOICE >= 1 && ISO_CHOICE <= ${#ISO_FILES[@]} )) || { fmtr::warn "Choice out of range."; continue; }

        ISO_PATH="${ISO_FILES[$((ISO_CHOICE-1))]}"
        fmtr::info "Selected ISO #$ISO_CHOICE: $(basename -- "$ISO_PATH")"
        break
    done

    if grep -a -m1 -q '10\.0\.2[2-9]' "$ISO_PATH"; then
        WIN_VERSION="win11"
    else
        WIN_VERSION="win10"
    fi
    fmtr::info "Detected Windows ISO version: $WIN_VERSION"
}

configure_xml() {
    if $ROOT_ESC virsh dominfo "$DOMAIN_NAME" >/dev/null 2>&1; then
        fmtr::fatal "Domain '$DOMAIN_NAME' already exists. Please delete it before running this script."
        return 1
    fi

    ################################################################################
    #
    # Hyper-V
    #

    local HYPERV_ARGS=()
    local enable_hyperv=""

    while :; do
        read -r -p "$(fmtr::ask_inline "Enable Hyper-V? [y/n]: ")" enable_hyperv
        printf '%s\n' "$enable_hyperv" >>"$LOG_FILE"

        case "$enable_hyperv" in
            [Yy]*)
                HYPERV_ARGS=('--xml' "./features/hyperv/@mode=passthrough")
                HYPERV_CLOCK_STATUS="yes"
                CPU_FEATURE_HYPERVISOR="optional"
                fmtr::info "Setting Hyper-V to passthrough mode."
                break
                ;;
            [Nn]*)
                HYPERV_ARGS=('--xml' "xpath.delete=./features/hyperv")
                HYPERV_CLOCK_STATUS="no"
                CPU_FEATURE_HYPERVISOR="disable"
                fmtr::info "Disabling all Hyper-V related settings."
                break
                ;;
            *)
                fmtr::warn "Please answer y or n."
                continue
                ;;
        esac
    done

    ################################################################################
    #
    # EVDEV
    #

    local EVDEV_ARGS=()
    local enable_evdev=""

    while :; do
        read -r -p "$(fmtr::ask_inline "Configure evdev? [y/n]: ")" enable_evdev
        printf '%s\n' "$enable_evdev" >>"$LOG_FILE"

        case "$enable_evdev" in
            [Yy]*)
                local grab_toggle=""
                while :; do
                    fmtr::log "Available grabToggle combinations:

  1) ctrl-ctrl    4) meta-meta
  2) alt-alt      5) scrolllock
  3) shift-shift  6) ctrl-scrolllock"

                    read -r -p "$(fmtr::ask_inline "Choose an option [1-6]: ")" grab_toggle
                    printf '%s\n' "$grab_toggle" >>"$LOG_FILE"

                    case "$grab_toggle" in
                        1) grab_toggle="ctrl-ctrl" ;;
                        2) grab_toggle="alt-alt" ;;
                        3) grab_toggle="shift-shift" ;;
                        4) grab_toggle="meta-meta" ;;
                        5) grab_toggle="scrolllock" ;;
                        6) grab_toggle="ctrl-scrolllock" ;;
                        *) fmtr::warn "Invalid option. Please choose 1-6."; continue ;;
                    esac
                    break
                done

                declare -A seen_devices

                for dev in /dev/input/by-{id,path}/*-event-{kbd,mouse}; do
                    # Deduplicate by real path
                    real_dev=$(readlink -f "$dev") || continue
                    [[ -n "${seen_devices[$real_dev]}" ]] && continue
                    seen_devices["$real_dev"]=1

                    # Keyboard specific config
                    extra_config=""
                    [[ "$dev" == *"-event-kbd" ]] && extra_config=",source.grab=all,source.repeat=on"

                    # Single append operation
                    EVDEV_ARGS+=('--input' "type=evdev,source.dev=$dev,source.grabToggle=$grab_toggle${extra_config}")
                done

                fmtr::info "Evdev passthrough enabled."
                break
                ;;
            [Nn]*)
                fmtr::info "Evdev input passthrough disabled."
                break
                ;;
            *)
                fmtr::warn "Please answer y or n."
                ;;
        esac
    done

    ################################################################################
    #
    # Audio
    #

    local AUDIO_ARGS=()
    local enable_audio=""

    while :; do
        read -r -p "$(fmtr::ask_inline "Enable PipeWire audio passthrough (input + output)? [y/n]: ")" enable_audio
        printf '%s\n' "$enable_audio" >>"$LOG_FILE"

        case "$enable_audio" in
            [Yy]*)
                AUDIO_ARGS=(
                    '--sound' 'model=ich9,audio.id=1'
                    '--xml' './devices/audio/@id=1'
                    '--xml' './devices/audio/@type=pipewire'
                    '--xml' "./devices/audio/@runtimeDir=/run/user/$(id -u)"
                    '--xml' './devices/audio/input/@mixingEngine=no'
                    '--xml' './devices/audio/output/@mixingEngine=no'
                )
                fmtr::info "PipeWire audio enabled (low-latency mode)."
                break
                ;;
            [Nn]*)
                fmtr::info "Audio passthrough disabled."
                break
                ;;
            *)
                fmtr::warn "Please answer y or n."
                ;;
        esac
    done

    local -a args=(
        ################################################################################
        #
        # Documentation:
        #   - https://libvirt.org/formatdomain.html#element-and-attribute-overview
        #

        --connect qemu:///system
        --name "$DOMAIN_NAME"
        --osinfo "$WIN_VERSION"





        ################################################################################
        #
        # Documentation:
        #   - https://libvirt.org/formatdomain.html#memory-allocation
        #
        # Allocate realistic memory amounts, such as 8, 16, 32, and 64.
        #

        --memory "$HOST_MEMORY_MIB"





        ################################################################################
        #
        # Documentation:
        #   - https://libvirt.org/formatdomain.html#operating-system-booting
        #

        # Boot order & menu | Loader/OVMF_CODE | NVRAM/OVMF_VARS
        --boot "cdrom,hd,menu=on,loader=/opt/AutoVirt/firmware/OVMF_CODE.fd,loader.readonly=yes,loader.secure=yes,loader.type=pflash,nvram.template=/opt/AutoVirt/firmware/OVMF_VARS.fd"





        ################################################################################
        #
        # Documentation:
        #   - https://libvirt.org/formatdomain.html#hypervisor-features
        #

        "${HYPERV_ARGS[@]}"

        --features "kvm.hidden.state=on"  # CONCEALMENT: Hide the KVM hypervisor from standard MSR based discovery (CPUID Bitset)
        --features "pmu.state=off"        # CONCEALMENT: Disables the Performance Monitoring Unit (PMU)
        --features "vmport.state=off"     # CONCEALMENT: Disables the VMware I/O port backdoor (VMPort, 0x5658) in the guest | FYI: ACE AC looks for this
        --features "smm.state=on"         # Secure boot requires SMM feature enabled
        --features "msrs.unknown=fault"   # CONCEALMENT: Injects a #GP(0) into the guest on RDMSR/WRMSR to an unhandled/unknown MSR
        --xml "./features/ps2/@state=off" # CONCEALMENT: Disable PS/2 controller emulation





        ################################################################################
        #
        # Documentation:
        #   - https://libvirt.org/formatdomain.html#cpu-model-and-topology
        #

        --cpu "host-passthrough,topology.sockets=1,topology.cores=$HOST_CORES_PER_SOCKET,topology.threads=$HOST_THREADS_PER_CORE"

        --xml "./cpu/@check=none"
        --xml "./cpu/@migratable=off"
        --xml "./cpu/topology/@dies=1"
        --xml "./cpu/topology/@clusters=1"
        --xml "./cpu/cache/@mode=passthrough"
        --xml "./cpu/maxphysaddr/@mode=passthrough"

        # TODO: Make this change based on if user is on AMD or Intel

        --xml "./cpu/feature[@name='$CPU_VIRTUALIZATION']/@policy=optional"       # OPTIMIZATION: Enables AMD SVM (CPUID.80000001:ECX[2])
        --xml "./cpu/feature[@name='topoext']/@policy=optional"                   # OPTIMIZATION: Exposes extended topology (CPUID.80000001:ECX[22], CPUID.8000001E)
        --xml "./cpu/feature[@name='invtsc']/@policy=optional"                    # OPTIMIZATION: Provides invariant TSC (CPUID.80000007:EDX[8])
        --xml "./cpu/feature[@name='hypervisor']/@policy=$CPU_FEATURE_HYPERVISOR" # CONCEALMENT: Clears Hypervisor Present bit (CPUID.1:ECX[31])
        --xml "./cpu/feature[@name='ssbd']/@policy=disable"                       # CONCEALMENT: Clears Speculative Store Bypass Disable (CPUID.7.0:EDX[31])
        --xml "./cpu/feature[@name='amd-ssbd']/@policy=disable"                   # CONCEALMENT: Clears AMD SSBD flag (CPUID.80000008:EBX[25])
        --xml "./cpu/feature[@name='virt-ssbd']/@policy=disable"                  # CONCEALMENT: Clears virtual SSBD exposure (CPUID.7.0:EDX[31])





        ################################################################################
        #
        # Documentation:
        #   - https://libvirt.org/formatdomain.html#time-keeping
        #

        --xml "./clock/@offset=localtime"
        --xml "./clock/timer[@name='tsc']/@present=yes"
        --xml "./clock/timer[@name='tsc']/@mode=native"
        #--xml "./clock/timer[@name='hpet']/@present=yes"
        --xml "./clock/timer[@name='kvmclock']/@present=no"                      # CONCEALMENT: Disable KVM paravirtual clock source
        --xml "./clock/timer[@name='hypervclock']/@present=$HYPERV_CLOCK_STATUS" # CONCEALMENT: Disable Hyper-V paravirtual clock source





        ################################################################################
        #
        # Documentation:
        #   - https://libvirt.org/formatdomain.html#power-management
        #

        --xml "./pm/suspend-to-mem/@enabled=yes"  # CONCEALMENT: Enables S3 ACPI sleep state (suspend-to-RAM) support in the guest
        --xml "./pm/suspend-to-disk/@enabled=yes" # CONCEALMENT: Enables S4 ACPI sleep state (suspend-to-disk/hibernate) support in the guest





        ################################################################################
        #
        # Documentation:
        #   - https://libvirt.org/formatdomain.html#devices
        #
        # 'qemu-system-x86_64' binary path
        #

        --xml "./devices/emulator=/opt/AutoVirt/emulator/bin/qemu-system-x86_64"





        ################################################################################
        #
        # Documentation:
        #   - https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms
        #   - https://www.qemu.org/docs/master/system/devices/nvme.html
        #

        # TODO: Add user choice of using virtual drive, virtual drive + passthrough, complete PCI passthrough.
        # TODO: passthrough physical drive
        # --disk type=block,device=disk,source=/dev/nvme0n1,driver.name=qemu,driver.type=raw,driver.cache=none,driver.io=native,target.dev=nvme0,target.bus=nvme,serial=1233659 \

        # set & spoof eui64
        --disk "size=500,bus=nvme,serial=$DRIVE_SERIAL,driver.cache=none,driver.io=native,driver.discard=unmap,blockio.logical_block_size=4096,blockio.physical_block_size=4096"
        --check "disk_size=off"

        --cdrom "$ISO_PATH"





        ################################################################################
        #
        # Documentation:
        #   - https://libvirt.org/formatdomain.html#network-interfaces
        #

        --network "network=default,model=e1000e,mac=$RANDOM_MAC"





        ################################################################################
        #
        # Documentation:
        #   - https://libvirt.org/formatdomain.html#input-devices
        #

        --input "mouse,bus=usb"    # USB mouse instead of PS2
        --input "keyboard,bus=usb" # USB keyboard instead of PS2

        "${EVDEV_ARGS[@]}"         # Evdev configuration





        ################################################################################
        #
        # Documentation:
        #   - https://libvirt.org/formatdomain.html#sound-devices
        #   - https://libvirt.org/formatdomain.html#audio-devices
        #   - https://wiki.archlinux.org/title/PCI_passthrough_via_OVMF#Passing_audio_from_virtual_machine_to_host_via_PipeWire_directly
        #

        "${AUDIO_ARGS[@]}"





        ################################################################################
        #
        # Documentation:
        #   - https://libvirt.org/formatdomain.html#tpm-device
        #
        # TPM emulation requires the 'swtpm' package to function properly.
        #
        # TODO: Add option for user to passthrough TPM or emulate it
        #

        --tpm "backend.type=emulator,model=tpm-crb"





        ################################################################################
        #
        # Documentation:
        #   - https://libvirt.org/formatdomain.html#graphical-framebuffers
        #
        # TODO: Set to 'none' once using external display method.
        #

        --graphics "spice"





        ################################################################################
        #
        # Documentation:
        #   - https://libvirt.org/formatdomain.html#video-devices
        #
        # TODO: Set to 'none' once using external display method.
        #

        --video "vga"





        ################################################################################
        #
        # Documentation:
        #   - https://libvirt.org/formatdomain.html#memory-balloon-device
        #
        # The VirtIO memballoon device enables the host to dynamically reclaim memory from your VM by growing the
        # balloon inside the guest, reserving reclaimed memory. Libvirt adds this device to guests by default.
        #
        # However, this device causes major performance issues with VFIO passthrough setups, and should be disabled.
        #

        --memballoon "none"





        ################################################################################
        #
        # Documentation:
        #   - https://libvirt.org/formatdomain.html#consoles-serial-parallel-channel-devices
        #

        --console "none" # Removed because added by default
        --channel "none" # Removed because added by default





        ################################################################################
        #
        # Documentation:
        #   - https://www.libvirt.org/kbase/qemu-passthrough-security.html
        #   - https://www.qemu.org/docs/master/system/qemu-manpage.html#hxtool-4
        #

        --qemu-commandline="-smbios file=/opt/AutoVirt/firmware/smbios.bin"





        ################################################################################
        #
        # Miscellaneous Options:
        #

        --noautoconsole
        --wait
    )
    # https://man.archlinux.org/man/virt-install.1
    # sudo virt-install --features help

    # TODO: Figure out weird boot hang freeze

    $ROOT_ESC virt-install "${args[@]}" &>> "$LOG_FILE"

    # $ROOT_ESC virt-install "${args[@]}" --print-xml > /tmp/AutoVirt.xml &>> "$LOG_FILE"

    # virt-manager --connect qemu:///system --show-domain-console "$DOMAIN_NAME" &>> "$LOG_FILE"
}

system_info
configure_xml

```

`modules/edk2.sh`:

```sh
#!/usr/bin/env bash

source ./utils.sh || { echo "Failed to load utilities module!"; exit 1; }





readonly SRC_DIR="$(pwd)/src"
readonly OUT_DIR="/opt/AutoVirt"

readonly EDK2_TAG="edk2-stable202602"
readonly EDK2_URL="https://github.com/tianocore/edk2.git"

readonly OVMF_PATCH="$(pwd)/patches/EDK2/${CPU_MANUFACTURER}-${EDK2_TAG}.patch"





REQUIRED_PKGS_Arch=(base-devel acpica git nasm python patch virt-firmware)
REQUIRED_PKGS_Debian=(build-essential uuid-dev acpica-tools git nasm python-is-python3 patch python3-virt-firmware)
REQUIRED_PKGS_openSUSE=(gcc gcc-c++ make acpica git nasm python3 libuuid-devel patch virt-firmware)
REQUIRED_PKGS_Fedora=(gcc gcc-c++ make acpica-tools git nasm python3 libuuid-devel patch python3-virt-firmware)





################################################################################
# Acquire EDK2 source
################################################################################
acquire_edk2_source() {
  $ROOT_ESC mkdir -p "$OUT_DIR/firmware"
  mkdir -p "$SRC_DIR" && cd "$SRC_DIR" || { fmtr::fatal "Failed to enter source dir: $SRC_DIR"; exit 1; }

  clone_repo() {
    fmtr::info "Cloning '$EDK2_TAG' from '$EDK2_URL'..."
    git clone --depth=1 --branch="$EDK2_TAG" "$EDK2_URL" "$EDK2_TAG" &>>"$LOG_FILE" \
    || { fmtr::fatal "Clone failed!"; exit 1; }

    cd "$EDK2_TAG" || { fmtr::fatal "Missing '$EDK2_TAG' directory!"; exit 1; }

    fmtr::info "Initializing submodules..."
    git submodule update --init --depth=1 --jobs="$(nproc)" &>>"$LOG_FILE" \
      || { fmtr::fatal "Submodule update failed!"; exit 1; }

    patch_ovmf
  }

  if [ -d "$EDK2_TAG" ]; then
    fmtr::warn "Repository directory '$EDK2_TAG' found."
    if prmt::yes_or_no "$(fmtr::ask "Purge '$EDK2_TAG' directory?")"; then
      rm -rf "$EDK2_TAG" || { fmtr::fatal "Failed to purge '$EDK2_TAG' directory!"; exit 1; }
      fmtr::info "Directory purged successfully."
      if prmt::yes_or_no "$(fmtr::ask "Clone '$EDK2_URL' repository again?")"; then
        clone_repo
      else
        fmtr::info "Skipping..."
      fi
    else
      fmtr::info "Skipping..."
      cd "$EDK2_TAG" || { fmtr::fatal "Missing '$EDK2_TAG' directory!"; exit 1; }
    fi
  else
    clone_repo
  fi
}





################################################################################
# Patch OVMF
################################################################################
patch_ovmf() {
  local BIOS_VENDOR BIOS_VERSION BIOS_DATE
  local logo_choice custom_bmp width height bit_depth compression





  # --- Phase 1: Source Patching ---
  [ -f "$OVMF_PATCH" ] || { fmtr::error "Patch file missing"; return 1; }

  git apply < "$OVMF_PATCH" &>>"$LOG_FILE" || {
    fmtr::error "Patch application failed"; return 1;
  }
  fmtr::log "Source code patched."





  # --- Phase 2: Firmware Spoofing ---
  fmtr::info "Modifying firmware metadata..."

  uhex() {
    local bytes="$1" v="$2" width=$((bytes * 2))
    case "$v" in
      0x*|0X*) printf "0x%0${width}X" "$((v))" ;;
      *.*)     IFS='.' read -r a b _ <<< "$v"; b="${b:-0}"
              if (( bytes == 4 )); then printf "0x%0${width}X" "$(( (a << 16) | b ))"
              else                      printf "0x%0${width}X" "$(( (a << 48) | (b << 32) ))"
              fi ;;
      [0-9]*)  printf "0x%0${width}X" "$v" ;;
      *)       printf "%-${bytes}s" "$v" | LC_ALL=C od -An -t x1 -v \
                | awk '{for(i=NF;i>=1;i--) printf $i} END{print ""}' \
                | sed 's/^/0x/' ;;
    esac
  }

  BIOS_VENDOR="$(</sys/class/dmi/id/bios_vendor)"
  BIOS_VERSION="$(</sys/class/dmi/id/bios_version)"
  BIOS_DATE="$(</sys/class/dmi/id/bios_date)"
  BIOS_REVISION="$(uhex 4 "$($ROOT_ESC dmidecode --string bios-revision)")"

  t=/sys/firmware/acpi/tables/FACP

  OEM_Revision="$(uhex 4 "$(LC_ALL=C $ROOT_ESC od -An -t u4 -j 24 -N4 "$t" | tr -d ' ')")"
  Creator_Revision="$(uhex 4 "$(LC_ALL=C $ROOT_ESC od -An -t u4 -j 32 -N4 "$t" | tr -d ' ')")"

  OEM_Table_ID="$(uhex 8 "$(LC_ALL=C $ROOT_ESC dd if="$t" bs=1 skip=16 count=8 status=none | tr '\0' ' ')")"
  Creator_ID="$(uhex 4 "$(LC_ALL=C $ROOT_ESC dd if="$t" bs=1 skip=28 count=4 status=none | tr '\0' ' ')")"
  OEMID="$(LC_ALL=C $ROOT_ESC dd if="$t" bs=1 skip=10 count=6 status=none | tr '\0' ' ')"

  sed -i \
    -e 's@VendStr = L"unknown";@VendStr = L"'"$BIOS_VENDOR"'";@' \
    -e 's@VersStr = L"unknown";@VersStr = L"'"$BIOS_VERSION"'";@' \
    -e 's@DateStr = L"02/02/2022";@DateStr = L"'"$BIOS_DATE"'";@' \
    OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c

  sed -E -i \
    -e 's@(PcdFirmwareVendor)\|L"EDK II"\|@\1|L"'"$BIOS_VENDOR"'"|@' \
    -e 's@(PcdFirmwareRevision)\|0x00010000\|@\1|'"$BIOS_REVISION"'|@' \
    -e 's@(PcdFirmwareVersionString)\|L""\|@\1|L"'"$BIOS_VERSION"'"|@' \
    -e 's@(PcdFirmwareReleaseDateString)\|L""\|@\1|L"'"$BIOS_DATE"'"|@' \
    -e 's@(PcdAcpiDefaultOemId)\|"INTEL "\|@\1|"'$OEMID'"|@' \
    -e 's@(PcdAcpiDefaultOemTableId)\|0x20202020324B4445\|@\1|'"$OEM_Table_ID"'|@' \
    -e 's@(PcdAcpiDefaultOemRevision)\|0x00000002\|@\1|'"$OEM_Revision"'|@' \
    -e 's@(PcdAcpiDefaultCreatorId)\|0x20202020\|@\1|'"$Creator_ID"'|@' \
    -e 's@(PcdAcpiDefaultCreatorRevision)\|0x01000013\|@\1|'"$Creator_Revision"'|@' \
    MdeModulePkg/MdeModulePkg.dec





  # --- Phase 3: Boot Logo Replacement ---
  fmtr::info "Select boot logo source:"
  printf '\n  %b[%d]%b %s\n' "$TEXT_BRIGHT_YELLOW" 1 "$RESET" "Host System (Default)"
  printf '  %b[%d]%b %s\n' "$TEXT_BRIGHT_YELLOW" 2 "$RESET" "Custom Image (BMP)"

  validate_bmp() {
    local -a h
    readarray -t h < <(od -An -v -j0 -N54 -t u1 -w1 "$1")

    # Parse Little Endian headers
    width=$(( h[18] + (h[19]<<8) + (h[20]<<16) + (h[21]<<24) ))
    height=$(( h[22] + (h[23]<<8) + (h[24]<<16) + (h[25]<<24) ))
    bit_depth=$(( h[28] + (h[29]<<8) ))
    compression=$(( h[30] + (h[31]<<8) + (h[32]<<16) + (h[33]<<24) ))

    # Validate: Magic BM, Depth 1/4/8/24, No Compression, Max 65535px
    if (( h[0] != 66 || h[1] != 77 || (bit_depth != 1 && bit_depth != 4 && bit_depth != 8 && bit_depth != 24) || compression != 0 || width > 65535 || height > 65535 )); then
      fmtr::error "Invalid BMP: ${width}x${height} @ ${bit_depth}bpp (Comp: ${compression})"
      return 1
    fi
  }

  while :; do
    read -rp "$(fmtr::ask 'Enter choice [1-2]: ')" logo_choice && : "${logo_choice:=1}"

    case "$logo_choice" in
      1)
        if [ -f /sys/firmware/acpi/bgrt/image ]; then
          cp /sys/firmware/acpi/bgrt/image MdeModulePkg/Logo/Logo.bmp \
            && fmtr::log "Host logo injected." \
            || fmtr::error "Copy failed."
        else
          fmtr::error "Host BGRT image missing."
        fi
        break
        ;;
      2)
        while :; do
          read -rp "$(fmtr::ask 'Path to BMP: ')" custom_bmp
          [ -f "$custom_bmp" ] || { fmtr::error "File not found."; continue; }

          if validate_bmp "$custom_bmp"; then
            fmtr::info "Valid BMP detected (${width}x${height})."
            cp "$custom_bmp" MdeModulePkg/Logo/Logo.bmp \
              && fmtr::log "Custom logo injected." \
              || fmtr::error "Copy failed."
            break 2
          fi
        done
        ;;
      *)
        fmtr::error "Invalid selection."
        ;;
    esac
  done
}





################################################################################
# Build OVMF w/SB & TPM
################################################################################
build_ovmf() {
  # --- Phase 1: Build Environment & Compilation ---
  fmtr::info "Initializing build environment..."

  export WORKSPACE="$(pwd)"
  export EDK_TOOLS_PATH="$WORKSPACE/BaseTools"
  export CONF_PATH="$WORKSPACE/Conf"

  if [ ! -d "BaseTools/Build" ]; then
    { make -C BaseTools -j"$(nproc)" && source edksetup.sh; } &>>"$LOG_FILE" || {
      fmtr::fatal "BaseTools build failed"; return 1;
    }
  fi

  build -p OvmfPkg/OvmfPkgX64.dsc -a X64 -t GCC5 -b RELEASE -n 0 -s \
    -D SECURE_BOOT_ENABLE=TRUE -D SMM_REQUIRE=TRUE \
    -D TPM1_ENABLE=TRUE        -D TPM2_ENABLE=TRUE &>>"$LOG_FILE" || {
      fmtr::fatal "OVMF build failed"; return 1;
    }

  # --- Phase 2: Variable Extraction & NVRAM Injection ---
  local efivars_json
  local -r EFI_GLOBAL_VARIABLE=8be4df61-93ca-11d2-aa0d-00e098032b8c
  local -r EFI_IMAGE_SECURITY_DATABASE_GUID=d719b2cb-3d3a-4596-a3bc-dad00e67656f

  efivars_json="$(mktemp)" || return 1
  trap 'rm -f "$efivars_json"' RETURN

  fmtr::info "Extracting host EFI keys..."

  local -a keys=(
    "PK:${EFI_GLOBAL_VARIABLE}"               "KEK:${EFI_GLOBAL_VARIABLE}"
    "db:${EFI_IMAGE_SECURITY_DATABASE_GUID}"  "dbx:${EFI_IMAGE_SECURITY_DATABASE_GUID}"
    "PKDefault:${EFI_GLOBAL_VARIABLE}"        "KEKDefault:${EFI_GLOBAL_VARIABLE}"
    "dbDefault:${EFI_GLOBAL_VARIABLE}"        "dbxDefault:${EFI_GLOBAL_VARIABLE}"
  )

  {
    printf '{\n    "version": 2,\n    "variables": [\n'
    local first=true name guid path full_hex attr
    for entry in "${keys[@]}"; do
      IFS=: read -r name guid <<< "$entry"
      path="/sys/firmware/efi/efivars/${name}-${guid}"
      [ -f "$path" ] || continue

      full_hex=$(hexdump -ve '1/1 "%.2x"' "$path" 2>/dev/null) || continue
      attr=$(printf '%d' "0x${full_hex:6:2}${full_hex:4:2}${full_hex:2:2}${full_hex:0:2}")

      "$first" && first=false || printf ',\n'
      printf '        { "name": "%s", "guid": "%s", "attr": %d, "data": "%s" }' \
        "$name" "$guid" "$attr" "${full_hex:8}"
    done
    printf '\n    ]\n}\n'
  } > "$efivars_json"

  fmtr::info "Populating OVMF NVRAM..."

  $ROOT_ESC cp "Build/OvmfX64/RELEASE_GCC5/FV/OVMF_CODE.fd" "$OUT_DIR/firmware/OVMF_CODE.fd" || return 1

  $ROOT_ESC virt-fw-vars \
    --input "Build/OvmfX64/RELEASE_GCC5/FV/OVMF_VARS.fd" \
    --output "$OUT_DIR/firmware/OVMF_VARS.fd" \
    --secure-boot \
    --set-json "$efivars_json" &>>"$LOG_FILE" || {
      fmtr::fatal "NVRAM injection failed"; return 1;
    }

  fmtr::log "Secure Boot provisioning complete."
}





################################################################################
# Cleanup
################################################################################
cleanup() {
  fmtr::info "Cleaning up..."
  rm -rf "$SRC_DIR/$EDK2_TAG"
  rmdir --ignore-fail-on-non-empty "$SRC_DIR" 2>/dev/null || true
}





################################################################################
# Main menu
################################################################################
main() {
  install_req_pkgs "EDK2"
  acquire_edk2_source
  prmt::yes_or_no "$(fmtr::ask "Build & install OVMF?")" && build_ovmf
  ! prmt::yes_or_no "$(fmtr::ask "Keep repository directory?")" && cleanup
}

main

```

`modules/kernel.sh`:

```sh
#!/usr/bin/env bash

source ./utils.sh || { echo "Failed to load utilities module!"; exit 1; }





readonly SRC_DIR="$(pwd)/src"

readonly TKG_URL="https://github.com/Frogging-Family/linux-tkg.git"
readonly TKG_DIR="linux-tkg"

readonly KERNEL_MAJOR="6"
readonly KERNEL_MINOR="18"
readonly KERNEL_PATCH="latest"
readonly KERNEL_VERSION="${KERNEL_MAJOR}.${KERNEL_MINOR}-${KERNEL_PATCH}"

readonly REQUIRED_DISK_SPACE_GB="35"





check_disk_space() {
    local build_path="${1:-$(pwd)}"
    local required_kb=$((REQUIRED_DISK_SPACE_GB * 1024 * 1024))

    local available_kb
    available_kb=$(df --output=avail "$build_path" | tail -1)

    if (( available_kb < required_kb )); then
        fmtr::error "Insufficient disk space on $(pwd)."
        fmtr::error "Available: $((available_kb/1024/1024))GB, Required: ${REQUIRED_DISK_SPACE_GB}GB"
        exit 1
    fi
    fmtr::info "Disk space check passed."
}





acquire_tkg_source() {
    mkdir -p "$SRC_DIR" && cd "$SRC_DIR" || { fmtr::fatal "Failed to enter source dir: $SRC_DIR"; exit 1; }

    clone_repo() {
        fmtr::info "Cloning '$TKG_DIR' from '$TKG_URL'..."
        git clone --depth=1 "$TKG_URL" "$TKG_DIR" &>>"$LOG_FILE" \
        || { fmtr::fatal "Failed to clone repository!"; exit 1; }
        cd "$TKG_DIR" || { fmtr::fatal "Missing '$TKG_DIR' directory!"; exit 1; }

        # Disable -Werror to prevent build failures on newer compilers
        fmtr::info "Patching -Werror..."
        grep -RIl '\-Werror' . | xargs -r sed -i 's/-Werror=/-W/g; s/-Werror-/-W/g; s/-Werror/-W/g'
    }

    if [ -d "$TKG_DIR" ]; then
        fmtr::warn "Repository directory '$TKG_DIR' found."
        if prmt::yes_or_no "$(fmtr::ask "Purge '$TKG_DIR' directory?")"; then
        rm -rf "$TKG_DIR" || { fmtr::fatal "Failed to purge '$TKG_DIR' directory!"; exit 1; }
        fmtr::info "Directory purged successfully."
        if prmt::yes_or_no "$(fmtr::ask "Clone '$TKG_URL' again?")"; then
            clone_repo
        else
            fmtr::info "Skipping..."
        fi
        else
        fmtr::info "Skipping..."
        cd "$TKG_DIR" || { fmtr::fatal "Missing '$TKG_DIR' directory!"; exit 1; }
        fi
    else
        clone_repo
    fi
}





select_distro() {
    local options=("Arch" "Ubuntu" "Debian" "Fedora" "Suse" "Gentoo" "Generic")

    while true; do
        clear
        fmtr::info "Select Linux Distribution:\n"
        local i=1
        for opt in "${options[@]}"; do echo "  $i) $opt"; ((i++)); done

        local choice
        echo "" && read -p "  Enter choice [1-7]: " choice

        if [[ "$choice" -ge 1 && "$choice" -le 7 ]]; then
            _SELECTED_DISTRO="${options[$((choice-1))]}"
            echo "" && fmtr::info "Selected: $_SELECTED_DISTRO"
            break
        fi

        fmtr::error "Invalid option."
        prmt::quick_prompt "  Press any key to retry..." >/dev/null
    done
}





detect_and_select_cpu() {
    local -a architectures

    clear && fmtr::info "Detected CPU Manufacturer: $CPU_MANUFACTURER"

    case "$CPU_MANUFACTURER" in
        "AMD")
            architectures=(
                "k8" "k8sse3" "k10" "barcelona" "bobcat" "jaguar" "bulldozer" "piledriver"
                "steamroller" "excavator" "znver1" "znver2" "znver3" "znver4" "znver5" "native_amd"
            )
            ;;
        "Intel")
            architectures=(
                "mpsc" "atom" "core2" "nehalem" "westmere" "silvermont" "sandybridge" "ivybridge"
                "haswell" "broadwell" "skylake" "skylakex" "cannonlake" "icelake" "icelake_server"
                "goldmont" "goldmontplus" "cascadelake" "cooperlake" "tigerlake" "sapphirerapids"
                "rocketlake" "alderlake" "raptorlake" "meteorlake" "native_intel"
            )
            ;;
        *)
            fmtr::warn "Unsupported CPU Manufacturer: $CPU_MANUFACTURER. Defaulting to generic."
            _SELECTED_CPU_OPT="generic"
            return
            ;;
    esac

    while true; do
        fmtr::info "Select CPU Î¼arch:\n\n  https://wikipedia.org/wiki/List_of_${CPU_MANUFACTURER}_CPU_microarchitectures\n"
        local i=1
        for arch in "${architectures[@]}"; do
            printf "  %2d) %s\n" "$i" "$arch"
            ((i++))
        done

        local choice
        echo "" && read -p "  Enter choice [1-${#architectures[@]}]: " choice

        if [[ "$choice" -ge 1 && "$choice" -le "${#architectures[@]}" ]]; then
            _SELECTED_CPU_OPT="${architectures[$((choice-1))]}"
            break
        fi

        fmtr::error "Invalid selection."
        prmt::quick_prompt "  Press any key to retry..." >/dev/null
    done
}





apply_tkg_config() {
    local acs_override="false"
    if prmt::yes_or_no "$(fmtr::ask_inline 'Enable ACS override patch (for IOMMU groups)?')"; then
        acs_override="true"
    fi

    declare -A config=(
        [_distro]="$_SELECTED_DISTRO"
        [_version]="$KERNEL_VERSION"
        [_EXT_CONFIG_PATH]=""
        [_menunconfig]="false"
        [_diffconfig]="false"
        [_cpusched]="eevdf"
        [_compiler]="gcc"
        [_sched_yield_type]="0"
        [_rr_interval]="2"
        [_tickless]="1"
        [_acs_override]="$acs_override"
        [_processor_opt]="$_SELECTED_CPU_OPT"
        [_timer_freq]="1000"
        [_user_patches_no_confirm]="true"
        [_force_all_threads]="true"
        [_modprobeddb]="false"
    )

    local sed_script=""
    for key in "${!config[@]}"; do
        sed_script+="s|^$key=.*|$key=\"${config[$key]}\"|;"
    done

    sed -i "$sed_script" "customization.cfg" || { fmtr::fatal "Failed to write configuration."; exit 1; }

    fmtr::info "Applied configuration to 'customization.cfg'"
}





patch_kernel_files() {
    local patch_name="zen-kernel-${KERNEL_MAJOR}.${KERNEL_MINOR}-${KERNEL_PATCH}-${CPU_MANUFACTURER}.mypatch"
    local user_patch_dir="linux${KERNEL_MAJOR}${KERNEL_MINOR}-tkg-userpatches"
    local source_patch="../../patches/Kernel/$patch_name"

    if [[ -f "$source_patch" ]]; then
        mkdir -p "$user_patch_dir"
        cp "$source_patch" "$user_patch_dir/"
        fmtr::info "Copied user patch: $patch_name"
    else
        fmtr::warn "Patch file not found: $source_patch"
    fi
}





create_systemd_boot_entry() {
    if ! prmt::yes_or_no "$(fmtr::ask_inline 'Create systemd-boot entry?')"; then
        return
    fi

    local kernel_tag="linux${KERNEL_MAJOR}${KERNEL_MINOR}-tkg-eevdf"
    local entry_name="HvP-RDTSC"
    local timestamp
    timestamp=$(date +"%Y-%m-%d_%H-%M-%S")

    # Find boot entry location
    local entry_dir=""
    for dir in "/boot/loader/entries" "/boot/efi/loader/entries" "/efi/loader/entries"; do
        if [[ -d "$dir" ]]; then entry_dir="$dir"; break; fi
    done
    [[ -z "$entry_dir" ]] && { fmtr::error "No systemd-boot directory found."; return 1; }

    local root_dev=$(findmnt -n -o SOURCE /)
    local partuuid=$(blkid -s PARTUUID -o value "${root_dev%\[*}")
    local fstype=$(findmnt -n -o FSTYPE /)
    local options="options root=PARTUUID=${partuuid} rw rootfstype=${fstype}"

    fmtr::info "Writing boot entries to $entry_dir (requires privileges)..."

    cat <<EOF | $ROOT_ESC tee "$entry_dir/$entry_name.conf" >/dev/null
# Created by: HvP-Script ($timestamp)
title   HvP (RDTSC Patch)
linux   /vmlinuz-$kernel_tag
initrd  /initramfs-$kernel_tag.img
$options
EOF

    cat <<EOF | $ROOT_ESC tee "$entry_dir/$entry_name-fallback.conf" >/dev/null
# Created by: HvP-Script ($timestamp)
title   HvP (RDTSC Patch - Fallback)
linux   /vmlinuz-$kernel_tag
initrd  /initramfs-$kernel_tag-fallback.img
$options
EOF

    fmtr::info "Boot entries created successfully."
}

build_arch() {
    fmtr::info "Starting Arch Linux build (makepkg)..."
    makepkg -C -si --noconfirm
    create_systemd_boot_entry
}

build_generic() {
    fmtr::info "Starting Generic build (install.sh)..."
    ./install.sh install
    create_systemd_boot_entry
}

# ==============================================================================
# Main Execution
# ==============================================================================

main() {
    check_disk_space
    acquire_tkg_source
    select_distro
    detect_and_select_cpu
    apply_tkg_config
    # patch_kernel_files TODO

    if [[ "$_SELECTED_DISTRO" == "Arch" ]]; then
        build_arch
    else
        build_generic
    fi
}

main "$@"

```

`modules/lg.sh`:

```sh
#!/usr/bin/env bash

source ./utils.sh || { echo "Failed to load utilities module!"; exit 1; }

readonly SRC_DIR="$(pwd)/src"
readonly LG_URL="https://looking-glass.io/artifact/stable/source"
readonly LG_VERSION="B7"
readonly LG_ARCHIVE="looking-glass-$LG_VERSION.tar.gz"

# https://looking-glass.io/docs/B7/build/#host
# https://looking-glass.io/wiki/Installation_on_other_distributions

REQUIRED_PKGS_Arch=(
  cmake gcc libgl libegl fontconfig spice-protocol make nettle pkgconf binutils libxi libxinerama
  libxss libxcursor libxpresent libxkbcommon wayland-protocols ttf-dejavu libsamplerate curl
)

REQUIRED_PKGS_Debian=(
  # https://looking-glass.io/docs/B7/build/#fetching-with-apt
  
  binutils-dev cmake fonts-dejavu-core libfontconfig-dev curl
  gcc g++ pkg-config libegl-dev libgl-dev libgles-dev libspice-protocol-dev
  nettle-dev libx11-dev libxcursor-dev libxi-dev libxinerama-dev
  libxpresent-dev libxss-dev libxkbcommon-dev libwayland-dev wayland-protocols
  libpipewire-0.3-dev libsamplerate0-dev

  # Add "libpulse-devel" and remove "pipewire-devel" if you use PulseAudio!
  # Not recommended though because LG doesn't support PulseAudio.
)

REQUIRED_PKGS_openSUSE=(
  binutils-devel clang cmake dejavu-fonts fontconfig-devel gcc gcc-c++ glibc-locale 
  libdecor-devel libglvnd-devel libnettle-devel libsamplerate-devel libSDL2-2_0-0
  libSDL2_ttf-2_0-0 libvulkan1 libwayland-egl1 libxkbcommon-devel libXpresent-devel
  libXrandr-devel libXss-devel libXss-devel make Mesa-libGLESv3-devel pipewire-devel
  pkgconf-pkg-config pkgconf spice-protocol-devel vulkan-devel wayland-devel
  zlib-devel-static libXi-devel libXinerama-devel libXcursor-devel dkms Mesa-libGL-devel
  Mesa-libGLESv2-devel libzstd-devel-static libconfig++-devel SDL2-devel curl

  # Add "libpulse-devel" and remove "pipewire-devel" if you use PulseAudio!
  # Not recommended though because LG doesn't support PulseAudio.
)

REQUIRED_PKGS_Fedora=(
  cmake gcc gcc-c++ libglvnd-devel fontconfig-devel spice-protocol make nettle-devel
  pkgconf-pkg-config binutils-devel libXi-devel libXinerama-devel libXcursor-devel
  libXpresent-devel libxkbcommon-x11-devel wayland-devel wayland-protocols-devel
  libXScrnSaver-devel libXrandr-devel dejavu-sans-mono-fonts libdecor-devel
  pipewire-devel libsamplerate-devel dkms kernel-devel kernel-headers curl

  # Add "pulseaudio-libs-devel" and remove "pipewire-devel" if you use PulseAudio!
  # Not recommended though because LG doesn't support PulseAudio.
)

install_looking_glass() {

  # openSUSE specific thing
  if [[ "$DISTRO" == "openSUSE" && ! -e /usr/lib64/libbfd.so ]]; then
    fmtr::log "Configuring packages to ensure LG build completion"
    {
      LIBBFD_OLD=$(find /usr -name "libbfd*.so*" 2>/dev/null | head -n 1)
      if [[ -n "$LIBBFD_OLD" ]]; then
        ln -sv "$LIBBFD_OLD" /usr/lib64/libbfd.so
      else
        fmtr::log "libbfd library not found in /usr"
      fi
    } &>> "$LOG_FILE"
  fi
  
  mkdir -p "$SRC_DIR" && cd "$SRC_DIR"

  fmtr::info "Downloading 'looking-glass-$LG_VERSION.tar.gz' archive..."
  curl -sSo "$LG_ARCHIVE" "$LG_URL" && tar -zxf "$LG_ARCHIVE" && rm -f "$LG_ARCHIVE"

  fmtr::info "Building, compiling, and installing LG..."
  cd looking-glass-$LG_VERSION && mkdir client/build && cd client/build

  if [[ "$CPU_VENDOR_ID" == "GenuineIntel" ]]; then
      NEW_VENDOR_ID="0x8086"
      NEW_DEVICE_ID="0x8086"
  elif [[ "$CPU_VENDOR_ID" == "AuthenticAMD" ]]; then
      NEW_VENDOR_ID="0x1022"
      NEW_DEVICE_ID="0x1022"
  else
      fmtr::error "Unknown CPU Vendor ID."; exit 1
  fi

  sed -i "s/0x1af4/$NEW_VENDOR_ID/" "../../module/kvmfr.c"
  sed -i "s/0x1110/$NEW_DEVICE_ID/" "../../module/kvmfr.c"

  {
    cmake ../ && $ROOT_ESC make install -j"$(nproc)"
  } &>> "$LOG_FILE"

  fmtr::info "Cleaning up..."
  cd ../../../ && rm -rf looking-glass-$LG_VERSION/

}

configure_ivshmem_shmem() {

    local conf_file="/etc/tmpfiles.d/10-looking-glass.conf"
    local username=$(whoami)

    if [ ! -f "$conf_file" ]; then
      fmtr::info "Creating '10-looking-glass.conf'..."
      echo "f /dev/shm/looking-glass 0660 ${username} kvm -" | $ROOT_ESC tee "$conf_file" &>> "$LOG_FILE"
    else
      fmtr::log "'10-looking-glass.conf' already exists; skipping creation."
    fi

    if [ ! -e /dev/shm/looking-glass ]; then
      fmtr::info "Creating '/dev/shm/looking-glass' and setting permissions..."
      $ROOT_ESC touch /dev/shm/looking-glass
      $ROOT_ESC chown "${username}:kvm" /dev/shm/looking-glass
      $ROOT_ESC chmod 660 /dev/shm/looking-glass
    else
      fmtr::log "'/dev/shm/looking-glass' already exists; skipping creation."
    fi

    local entry_to_add="$(cat <<- 'EOF'
# Alias lg for Looking Glass shared memory setup
alias lg='if [ ! -e /dev/shm/looking-glass ]; then \
  touch /dev/shm/looking-glass; \
  sudo chown $USER:kvm /dev/shm/looking-glass; \
  chmod 660 /dev/shm/looking-glass; \
  /usr/local/bin/looking-glass-client -S -K -1; \
else \
  /usr/local/bin/looking-glass-client -S -K -1; \
fi'
EOF
    )"

    if ! grep -q "alias lg=" ~/.bashrc; then
      fmtr::info "Adding LG alias to '~/.bashrc'..."
      echo "$entry_to_add" >> ~/.bashrc
    else
      fmtr::log "The LG alias already exists in '~/.bashrc'; skipping creation."
    fi

    source "${HOME}/.bashrc"
    fmtr::warn "TIP: Just enter 'lg' in a fresh terminal to launch LG."

}

configure_ivshmem_kvmfr() {

  # The kernel module implements a basic interface to the IVSHMEM device for Looking Glass allowing DMA GPU transfers.

  local MEMORY_SIZE_MB="32"

  # Temporary
  $ROOT_ESC modprobe kvmfr static_size_mb=$MEMORY_SIZE_MB

  # Permanent
  echo "options kvmfr static_size_mb=$MEMORY_SIZE_MB" | $ROOT_ESC tee /etc/modprobe.d/kvmfr.conf

  # Automatic (w/systemd)
  echo -e "# KVMFR Looking Glass module\nkvmfr" | $ROOT_ESC tee /etc/modules-load.d/kvmfr.conf

  # Permissions
  $ROOT_ESC chown $(whoami):kvm /dev/kvmfr0

}

main() {

  install_req_pkgs "LG"
  install_looking_glass
  configure_ivshmem_shmem
  
}

main

```

`modules/qemu.sh`:

```sh
#!/usr/bin/env bash

source ./utils.sh || { echo "Failed to load utilities module!"; exit 1; }

readonly SRC_DIR="$(pwd)/src"
readonly OUT_DIR="/opt/AutoVirt"

readonly QEMU_TAG="v10.2.0"
readonly QEMU_URL="https://gitlab.com/qemu-project/qemu.git"

readonly QEMU_PATCH="$(pwd)/patches/QEMU/${CPU_MANUFACTURER}-${QEMU_TAG}.patch"

REQUIRED_PKGS_Arch=(
  # Basic Build Dependencie(s)
  acpica base-devel dmidecode glib2 ninja python-packaging
  python-sphinx python-sphinx_rtd_theme gnupg libevdev

  # Spice Dependencie(s)
  spice gtk3

  # USB passthrough Dependencie(s)
  libusb

  # USB redirection Dependencie(s)
  usbredir
)

REQUIRED_PKGS_Debian=(
  # Basic Build Dependencie(s)
  acpica-tools build-essential libfdt-dev libglib2.0-dev
  libpixman-1-dev ninja-build python3-venv zlib1g-dev gnupg
  python3-sphinx python3-sphinx-rtd-theme

  # Spice Dependencie(s)
  libspice-server-dev

  # USB passthrough Dependencie(s)
  libusb-1.0-0-dev

  # USB redirection Dependencie(s)
  libusbredirhost-dev libusbredirparser-dev
)

REQUIRED_PKGS_openSUSE=(
  # Basic Build Dependencie(s)
  acpica bzip2 gcc-c++ gpg2 glib2-devel make qemu
  libpixman-1-0-devel python3-Sphinx ninja

  # Spice Dependencie(s)
  spice-server

  # USB passthrough Dependencie(s)
  libusb-1_0-devel

  # USB redirection Dependencie(s)
  libusbredir-devel
)

REQUIRED_PKGS_Fedora=(
  # Basic Build Dependencie(s)
  acpica-tools bzip2 glib2-devel libfdt-devel ninja-build
  pixman-devel python3 zlib-ng-devel gnupg2

  # Spice Dependencie(s)
  spice-server-devel

  # USB passthrough Dependencie(s)
  libusb1-devel

  # USB redirection Dependencie(s)
  usbredir-devel
)

################################################################################
# Acquire QEMU source
################################################################################
acquire_qemu_source() {
  $ROOT_ESC mkdir -p "$OUT_DIR"/{emulator,firmware}
  mkdir -p "$SRC_DIR" && cd "$SRC_DIR" || { fmtr::fatal "Failed to enter source dir: $SRC_DIR"; exit 1; }

  clone_repo() {
    fmtr::info "Cloning '$QEMU_TAG' from '$QEMU_URL'..."
    git clone --depth=1 --branch "$QEMU_TAG" "$QEMU_URL" "$QEMU_TAG" &>>"$LOG_FILE" \
      || { fmtr::fatal "Failed to clone repository!"; exit 1; }
    cd "$QEMU_TAG" || { fmtr::fatal "Missing '$QEMU_TAG' directory!"; exit 1; }
    patch_qemu
  }

  if [ -d "$QEMU_TAG" ]; then
    fmtr::warn "Repository directory '$QEMU_TAG' found."
    if prmt::yes_or_no "$(fmtr::ask "Purge '$QEMU_TAG' directory?")"; then
      rm -rf "$QEMU_TAG" || { fmtr::fatal "Failed to purge '$QEMU_TAG' directory!"; exit 1; }
      fmtr::info "Directory purged successfully."
      if prmt::yes_or_no "$(fmtr::ask "Clone '$QEMU_URL' repository again?")"; then
        clone_repo
      else
        fmtr::info "Skipping..."
      fi
    else
      fmtr::info "Skipping..."
      cd "$QEMU_TAG" || { fmtr::fatal "Missing '$QEMU_TAG' directory!"; exit 1; }
    fi
  else
    clone_repo
  fi
}

patch_qemu() {
  [ -f "$QEMU_PATCH" ] || { fmtr::error "Missing '$QEMU_PATCH' patch file!"; return 1; }
  git apply < "$QEMU_PATCH" &>>"$LOG_FILE" || { fmtr::error "Failed to apply '$QEMU_PATCH'!"; return 1; }
  fmtr::log "Applied '${CPU_MANUFACTURER}-${QEMU_TAG}.patch' successfully."

  fmtr::info "Applying dynamic modifications..."
  #spoof_serials
  spoof_models
  spoof_acpi
  spoof_smbios
}












spoof_serials() {
  local patterns=(STRING_SERIALNUMBER STR_SERIALNUMBER STR_SERIAL_MOUSE \
                    STR_SERIAL_TABLET STR_SERIAL_KEYBOARD STR_SERIAL_COMPAT)

  for file in ./hw/usb/*.c; do
    for pat in "${patterns[@]}"; do
      grep -n "\[\s*${pat}\s*\]\s*=\s*\"[^\"]*\"" "$file" | cut -d: -f1 | while read -r lineno; do
        serial=$(tr -dc 'A-Z0-9' </dev/urandom | head -c10)
        sed -r -i "${lineno}s/(\[\s*${pat}\s*\]\s*=\s*\")[^\"]*(\")/\1${serial}\2/" "$file"
      done
    done
  done
}











spoof_models() {
    local ide="hw/ide/core.c"
    local nvme="hw/nvme/ctrl.c"

    local ide_cd_models=(
      "HL-DT-ST BD-RE WH16NS60" "HL-DT-ST DVDRAM GH24NSC0"
      "HL-DT-ST BD-RE BH16NS40" "HL-DT-ST DVD+-RW GT80N"
      "HL-DT-ST DVD-RAM GH22NS30" "HL-DT-ST DVD+RW GCA-4040N"
      "Pioneer BDR-XD07B" "Pioneer DVR-221LBK" "Pioneer BDR-209DBK"
      "Pioneer DVR-S21WBK" "Pioneer BDR-XD05B" "ASUS BW-16D1HT"
      "ASUS DRW-24B1ST" "ASUS SDRW-08D2S-U" "ASUS BC-12D2HT"
      "ASUS SBW-06D2X-U" "Samsung SH-224FB" "Samsung SE-506BB"
      "Samsung SH-B123L" "Samsung SE-208GB" "Samsung SN-208DB"
      "Sony NEC Optiarc AD-5280S" "Sony DRU-870S" "Sony BWU-500S"
      "Sony NEC Optiarc AD-7261S" "Sony AD-7200S" "Lite-On iHAS124-14"
      "Lite-On iHBS112-04" "Lite-On eTAU108" "Lite-On iHAS324-17"
      "Lite-On eBAU108" "HP DVD1260i" "HP DVD640"
      "HP BD-RE BH30L" "HP DVD Writer 300n" "HP DVD Writer 1265i"
    )

    local ide_cfata_models=(
      "SanDisk Ultra microSDXC UHS-I" "SanDisk Extreme microSDXC UHS-I"
      "SanDisk High Endurance microSDXC" "SanDisk Industrial microSD"
      "SanDisk Mobile Ultra microSDHC" "Samsung EVO Select microSDXC"
      "Samsung PRO Endurance microSDHC" "Samsung PRO Plus microSDXC"
      "Samsung EVO Plus microSDXC" "Samsung PRO Ultimate microSDHC"
      "Kingston Canvas React Plus microSD" "Kingston Canvas Go! Plus microSD"
      "Kingston Canvas Select Plus microSD" "Kingston Industrial microSD"
      "Kingston Endurance microSD" "Lexar Professional 1066x microSDXC"
      "Lexar High-Performance 633x microSDHC" "Lexar PLAY microSDXC"
      "Lexar Endurance microSD" "Lexar Professional 1000x microSDHC"
      "PNY Elite-X microSD" "PNY PRO Elite microSD"
      "PNY High Performance microSD" "PNY Turbo Performance microSD"
      "PNY Premier-X microSD" "Transcend High Endurance microSDXC"
      "Transcend Ultimate microSDXC" "Transcend Industrial Temp microSD"
      "Transcend Premium microSDHC" "Transcend Superior microSD"
      "ADATA Premier Pro microSDXC" "ADATA XPG microSDXC"
      "ADATA High Endurance microSDXC" "ADATA Premier microSDHC"
      "ADATA Industrial microSD" "Toshiba Exceria Pro microSDXC"
      "Toshiba Exceria microSDHC" "Toshiba M203 microSD"
      "Toshiba N203 microSD" "Toshiba High Endurance microSD"
    )

    local default_models=(
      "Samsung SSD 970 EVO 1TB" "Samsung SSD 860 QVO 1TB"
      "Samsung SSD 850 PRO 1TB" "Samsung SSD T7 Touch 1TB"
      "Samsung SSD 840 EVO 1TB" "WD Blue SN570 NVMe SSD 1TB"
      "WD Black SN850 NVMe SSD 1TB" "WD Green 1TB SSD"
      "WD Blue 3D NAND 1TB SSD" "Crucial P3 1TB PCIe 3.0 3D NAND NVMe SSD"
      "Seagate BarraCuda SSD 1TB" "Seagate FireCuda 520 SSD 1TB"
      "Seagate IronWolf 110 SSD 1TB" "SanDisk Ultra 3D NAND SSD 1TB"
      "Seagate Fast SSD 1TB" "Crucial MX500 1TB 3D NAND SSD"
      "Crucial P5 Plus NVMe SSD 1TB" "Crucial BX500 1TB 3D NAND SSD"
      "Crucial P3 1TB PCIe 3.0 3D NAND NVMe SSD"
      "Kingston A2000 NVMe SSD 1TB" "Kingston KC2500 NVMe SSD 1TB"
      "Kingston A400 SSD 1TB" "Kingston HyperX Savage SSD 1TB"
      "SanDisk SSD PLUS 1TB" "SanDisk Ultra 3D 1TB NAND SSD"
    )

    get_random_element() {
      local array=("$@")
      echo "${array[RANDOM % ${#array[@]}]}"
    }

    local new_ide_cd_model=$(get_random_element "${ide_cd_models[@]}")
    local new_ide_cfata_model=$(get_random_element "${ide_cfata_models[@]}")
    local new_default_model=$(get_random_element "${default_models[@]}")

    sed -i "$ide" -Ee "s/\"HL-DT-ST BD-RE WH16NS60\"/\"${new_ide_cd_model}\"/"
    sed -i "$ide" -Ee "s/\"Hitachi HMS360404D5CF00\"/\"${new_ide_cfata_model}\"/"
    sed -i "$ide" -Ee "s/\"Samsung SSD 980 500GB\"/\"${new_default_model}\"/"
    sed -i "$nvme" -Ee "s/\"NVMe Ctrl\"/\"${new_default_model}\"/"
}








spoof_acpi() {
  # Fixed ACPI Description Table (FADT) - https://uefi.org/sites/default/files/resources/ACPI_Spec_6.6.pdf#subsection.5.2.9
  # Preferred PM Profile System Types   - https://uefi.org/sites/default/files/resources/ACPI_Spec_6.6.pdf#subsubsection.5.2.9.1

  local t=/sys/firmware/acpi/tables/FACP
  local h=include/hw/acpi/aml-build.h
  local c=hw/acpi/aml-build.c

  local OEMID OEM_Table_ID Creator_ID Preferred_PM_Profile Battery_SSDT out

  OEMID="$(LC_ALL=C $ROOT_ESC dd if=$t bs=1 skip=10 count=6 status=none | tr '\0' ' ')"
  OEM_Table_ID="$(LC_ALL=C $ROOT_ESC dd if=$t bs=1 skip=16 count=8 status=none | tr '\0' ' ')"
  Creator_ID="$(LC_ALL=C $ROOT_ESC dd if=$t bs=1 skip=28 count=4 status=none | tr '\0' ' ')"
  Preferred_PM_Profile=$(LC_ALL=C $ROOT_ESC dd if=$t bs=1 skip=45 count=1 status=none | od -An -tu1)

  sed -i \
    -e "s/\(#define ACPI_BUILD_APPNAME6 \)\"[^\"]*\"/\1\"$OEMID\"/" \
    -e "s/\(#define ACPI_BUILD_APPNAME8 \)\"[^\"]*\"/\1\"$OEM_Table_ID\"/" \
    $h

  sed -i 's/"ACPI"/"'"$Creator_ID"'"/g' $c

  if [[ $Preferred_PM_Profile -eq 2 ]]; then
    fmtr::warn "Host FADT: Preferred_PM_Profile equals '2' (Mobile)"

    sed -i 's/1 \/\* Desktop \*\/, 1/2 \/\* Mobile \*\/, 1/' "$c"

    Battery_SSDT=$($ROOT_ESC grep -aliE 'Battery|Capacity|Discharge|Charge' /sys/firmware/acpi/tables/SSDT* 2>/dev/null | head -n 1)

    if [[ -n "$Battery_SSDT" ]]; then
      out="$OUT_DIR/firmware/$(basename "$Battery_SSDT")-battery.aml"

      if $ROOT_ESC cp -- "$Battery_SSDT" "$out" && \
         $ROOT_ESC chmod 0644 -- "$out" && \
         $ROOT_ESC chown -- "${SUDO_USER:-$USER}:${SUDO_USER:-$USER}" "$out" 2>/dev/null; then

         fmtr::info "Copied '$Battery_SSDT' to '$out'"
      else
         fmtr::error "Failed to copy or set permissions for battery SSDT"
      fi
    else
      fmtr::warn "No SSDT containing battery info found; skipping battery SSDT copy."
    fi
  fi
}











spoof_smbios() {
  local chipset_file

  case "$QEMU_TAG" in
    "v8.2.6")
      chipset_file="hw/i386/pc_q35.c"
      ;;
    v9.*|v10.*.*)
      chipset_file="hw/i386/fw_cfg.c"
      ;;
    *)
      fmtr::warn "Unsupported QEMU version: $QEMU_TAG"
      ;;
  esac

  local manufacturer=$($ROOT_ESC dmidecode --string processor-manufacturer)
  sed -i "$chipset_file" -e "s/smbios_set_defaults(\"[^\"]*\",/smbios_set_defaults(\"${manufacturer}\",/"

  # TODO: Implement smbios.bin spoofer
}
















compile_qemu() {
  fmtr::info "Configuring QEMU..."

  ./configure --target-list=x86_64-softmmu \
              --prefix="$OUT_DIR/emulator" \
              --enable-libusb \
              --enable-usb-redir \
              --enable-spice \
              --enable-spice-protocol \
              --disable-werror \
              --disable-docs &>> "$LOG_FILE"

  if [[ $? -ne 0 ]]; then
    fmtr::error "Configuration failed; Check $LOG_FILE"
    return 1
  fi

  fmtr::info "Compiling QEMU..."
  make -j"$(nproc)" &>> "$LOG_FILE"
  if [[ $? -ne 0 ]]; then
    fmtr::error "Compilation failed; Check $LOG_FILE"
    return 1
  fi

  $ROOT_ESC make install &>> "$LOG_FILE"
  if [[ $? -ne 0 ]]; then
    fmtr::error "Install failed; Check $LOG_FILE"
    return 1
  fi
  fmtr::log "Installed QEMU at '$OUT_DIR/emulator'"
}











cleanup() {
  fmtr::info "Cleaning up..."
  rm -rf "$SRC_DIR/$QEMU_TAG"
  rmdir --ignore-fail-on-non-empty "$SRC_DIR" 2>/dev/null || true
}











main() {
  install_req_pkgs "QEMU"
  acquire_qemu_source
  prmt::yes_or_no "$(fmtr::ask "Build & install QEMU?")" && compile_qemu
  ! prmt::yes_or_no "$(fmtr::ask "Keep repository directory?")" && cleanup
}

main

```

`modules/vfio.sh`:

```sh
#!/usr/bin/env bash

source ./utils.sh || { echo "Failed to load utilities module!"; exit 1; }

readonly VFIO_CONF_PATH="/etc/modprobe.d/vfio.conf"
readonly VFIO_KERNEL_OPTS_REGEX='(intel_iommu=[^ ]*|iommu=[^ ]*)'

readonly -a SDBOOT_CONF_LOCATIONS=(
    /boot/loader/entries
    /boot/efi/loader/entries
    /efi/loader/entries
)

declare -A GPU_DRIVERS=(
    ["0x10de"]="nouveau nvidia nvidia_drm"
    ["0x1002"]="amdgpu radeon"
    ["0x8086"]="i915"
)

################################################################################
# Bootloader Detection
################################################################################
detect_bootloader() {
    [[ -f /etc/default/grub ]] && BOOTLOADER_TYPE=grub || {
        for dir in "${SDBOOT_CONF_LOCATIONS[@]}"; do
            [[ -d $dir ]] || continue
            BOOTLOADER_TYPE=systemd-boot SYSTEMD_BOOT_ENTRY_DIR=$dir
            break
        done
        [[ $SYSTEMD_BOOT_ENTRY_DIR ]] || { fmtr::error "No supported bootloader detected (GRUB or systemd-boot). Exiting."; exit 1; }
    }
}

################################################################################
# Revert VFIO Configurations
################################################################################
revert_vfio() {
    if [[ -f $VFIO_CONF_PATH ]]; then
        $ROOT_ESC rm -v "$VFIO_CONF_PATH" &>>"$LOG_FILE"
        fmtr::log "Removed VFIO Config: $VFIO_CONF_PATH"
    else
        fmtr::log "$VFIO_CONF_PATH doesn't exist; nothing to remove."
    fi

    if [[ $BOOTLOADER_TYPE == grub ]]; then
        $ROOT_ESC sed -E -i '/^GRUB_CMDLINE_LINUX_DEFAULT=/{
            s/'"$VFIO_KERNEL_OPTS_REGEX"'//g
            s/[[:space:]]+/ /g
            s/"[[:space:]]+/"
            s/[[:space:]]+"/"/
        }' /etc/default/grub
        fmtr::log "Removed VFIO kernel opts from GRUB config."

    elif [[ $BOOTLOADER_TYPE == systemd-boot && $SYSTEMD_BOOT_ENTRY_DIR ]]; then
        local config_file
        config_file=$(
            find "$SYSTEMD_BOOT_ENTRY_DIR" -maxdepth 1 \
                -name '*.conf' ! -name '*-fallback.conf' -print -quit
        )

        if [[ -z $config_file ]]; then
            fmtr::warn "No configuration file found in $SYSTEMD_BOOT_ENTRY_DIR"
            return
        fi

        $ROOT_ESC sed -E -i "/^options / {
            s/$VFIO_KERNEL_OPTS_REGEX//g;
            s/[[:space:]]+/ /g;
            s/[[:space:]]+$//;
        }" "$config_file"
        fmtr::log "Removed VFIO kernel opts from: $config_file"
    fi
}

################################################################################
# Configure VFIO
################################################################################
configure_vfio() {
    local dev bdf desc sel target_bdf iommu_group vendor_id device_id pci_vendor bad=0
    local -a gpus=() badf=() ids=()

    # Discover GPUs
    for dev in /sys/bus/pci/devices/*; do
        [[ $(<"$dev/class") == 0x03* ]] || continue
        bdf=${dev##*/}
        desc=$(lspci -s "$bdf" 2>/dev/null) || continue
        desc=${desc##*[}; desc=${desc%%]*}
        gpus+=("$bdf|$desc")
    done

    (( ${#gpus[@]} )) || { fmtr::error "No GPUs detected!"; exit 1; }
    (( ${#gpus[@]} == 1 )) && fmtr::warn "Only one GPU detected! Passing it through will leave the host without display output."

    # GPU selection
    while :; do
        for dev in "${!gpus[@]}"; do printf '\n  %d) %s\n' "$((dev+1))" "${gpus[dev]#*|}"; done
        read -rp "$(fmtr::ask 'Select device number: ')" sel
        (( sel >= 1 && sel <= ${#gpus[@]} )) 2>/dev/null && break
        fmtr::error "Invalid selection. Please choose a valid number."
    done

    target_bdf=${gpus[sel-1]%%|*}
    iommu_group=$(readlink -f "/sys/bus/pci/devices/$target_bdf/iommu_group")
    iommu_group=${iommu_group##*/}

    # Collect device IDs & validate IOMMU group isolation
    for dev in "/sys/kernel/iommu_groups/$iommu_group/devices/"*; do
        bdf=${dev##*/}
        read -r vendor_id < "$dev/vendor"
        read -r device_id < "$dev/device"
        ids+=("${vendor_id#0x}:${device_id#0x}")
        [[ $bdf == "${target_bdf%.*}".* ]] || { bad=1; badf+=("$bdf"); }
    done

    if (( bad )); then
        fmtr::error "Detected poor IOMMU grouping! IOMMU group #$iommu_group contains:\n
$(printf '  [%s]\n' "${badf[@]}")"
        fmtr::warn "VFIO PT requires full group isolation. Possible solutions:
      BIOS update, ACS override kernel patch, or new motherboard."
        return 1
    fi

    # Write VFIO config
    fmtr::log "Modifying VFIO config: $VFIO_CONF_PATH"
    read -r pci_vendor < "/sys/bus/pci/devices/$target_bdf/vendor" || return 1

    {
        printf 'options vfio-pci ids=%s disable_vga=1\n' "$(IFS=,; echo "${ids[*]}")"
        for soft in ${GPU_DRIVERS[$pci_vendor]:-}; do printf 'softdep %s pre: vfio-pci\n' "$soft"; done
    } | $ROOT_ESC tee "$VFIO_CONF_PATH" >> "$LOG_FILE"

    # sudo sed -i 's/^MODULES=()$/MODULES=(vfio vfio_iommu_type1 vfio_pci)/' /etc/mkinitcpio.conf
    # sudo mkinitcpio -P
}

################################################################################
# Bootloader Configuration
################################################################################
configure_bootloader() {
    local -a kernel_opts
    kernel_opts=( "iommu=pt" )
    [[ "$CPU_VENDOR_ID" == "GenuineIntel" ]] && kernel_opts=( "intel_iommu=on" "${kernel_opts[@]}" )

    local kernel_opts_str="${kernel_opts[*]}"

    if [[ "$BOOTLOADER_TYPE" == "grub" ]]; then
        fmtr::log "Configuring GRUB config: /etc/default/grub"

        $ROOT_ESC sed -E -i "/^GRUB_CMDLINE_LINUX_DEFAULT=/ {
            s/^GRUB_CMDLINE_LINUX_DEFAULT=//;
            s/^\"//; s/\"$//;
            s/$VFIO_KERNEL_OPTS_REGEX//g;
            s/[[:space:]]+/ /g;
            s/[[:space:]]+$//;
            s|^|GRUB_CMDLINE_LINUX_DEFAULT=\"|;
            s|$| ${kernel_opts_str}\"|;
        }" /etc/default/grub

        export BOOTLOADER_CHANGED=1

    elif [[ "$BOOTLOADER_TYPE" == "systemd-boot" ]]; then
        [[ -z "$SYSTEMD_BOOT_ENTRY_DIR" || ! -d "$SYSTEMD_BOOT_ENTRY_DIR" ]] && {
            fmtr::error "Systemd-boot entry directory is not set or doesn't exist."
            return 1
        }

        local config_file
        config_file=$(find "$SYSTEMD_BOOT_ENTRY_DIR" -maxdepth 1 -type f -name '*.conf' ! -name '*-fallback.conf' -print -quit)

        [[ -z "$config_file" ]] && {
            fmtr::warn "No configuration file found in $SYSTEMD_BOOT_ENTRY_DIR"
            return 0
        }

        fmtr::log "Configuring systemd-boot config: $config_file"

        $ROOT_ESC sed -E -i "/^options / {
            s/$VFIO_KERNEL_OPTS_REGEX//g;
            s/[[:space:]]+/ /g;
            s/[[:space:]]+$//;
            s/$/ ${kernel_opts_str}/;
        }" "$config_file"
    fi
}

################################################################################
# Rebuild Bootloader Configuration
################################################################################
rebuild_bootloader() {
    fmtr::log "Updating bootloader configuration for GRUB."

    local cmd prefix
    for prefix in "" 2; do
        cmd="grub${prefix}-mkconfig"
        command -v "$cmd" &>>"$LOG_FILE" || continue
        $ROOT_ESC "$cmd" -o "/boot/grub${prefix}/grub.cfg" &>>"$LOG_FILE" && { fmtr::log "Bootloader configuration updated."; return; }
    done

    fmtr::error "No known GRUB configuration command found on this system."
    return 1
}

################################################################################
# Main Script
################################################################################
detect_bootloader

# Prompt 1 - Remove VFIO config?
prmt::yes_or_no "$(fmtr::ask 'Remove GPU PT/VFIO configs?')" && revert_vfio

# Prompt 2 - Configure VFIO config?
if prmt::yes_or_no "$(fmtr::ask 'Configure GPU PT/VFIO now?')"; then
    configure_vfio || { fmtr::log "Configuration aborted during device selection."; exit 1; }
    configure_bootloader || { fmtr::log "Bootloader configuration aborted."; exit 1; }
fi

# Prompt 3 - Rebuild bootloader config?
if [[ "$BOOTLOADER_TYPE" == "grub" && "$BOOTLOADER_CHANGED" == "1" ]]; then
    if prmt::yes_or_no "$(fmtr::ask 'Proceed with rebuilding GRUB bootloader config?')"; then
        rebuild_bootloader || { fmtr::log "Failed to update GRUB configuration."; exit 1; }
        fmtr::warn "REBOOT required for changes to take effect"
    else
        fmtr::warn "Proceeding without updating GRUB bootloader."
    fi
elif [[ "$BOOTLOADER_TYPE" == "grub" ]]; then
    fmtr::log "No changes detected in GRUB config; skipping rebuild prompt."
else
    fmtr::log "Detected systemd-boot; no bootloader rebuild required."
fi

```

`modules/virtualization.sh`:

```sh
#!/usr/bin/env bash

source ./utils.sh || { echo "Failed to load utilities module!"; exit 1; }

REQUIRED_PKGS_Arch=(
  qemu-base edk2-ovmf libvirt dnsmasq virt-manager swtpm
)

REQUIRED_PKGS_Debian=(
  qemu-system-x86 ovmf virt-manager libvirt-clients swtpm
  libvirt-daemon-system libvirt-daemon-config-network
)

REQUIRED_PKGS_openSUSE=(
  libvirt libvirt-client libvirt-daemon virt-manager
  qemu qemu-kvm ovmf qemu-tools swtpm
)

REQUIRED_PKGS_Fedora=(
  @virtualization swtpm
)

configure_system_installation() {
  local target_user="${SUDO_USER:-$USER}"
  local user_groups=" $(id -nG "$target_user") "

  # Groups: input, kvm, and libvirt
  for grp in input kvm libvirt; do
    if [[ "$user_groups" == *" $grp "* ]]; then
      fmtr::info "User $target_user already in $grp group"
    else
      $ROOT_ESC usermod -aG "$grp" "$target_user"
      fmtr::info "Added $target_user to $grp group"
    fi
  done
  
  # Modify defaults for default (virbr0) libvirt network
  # *IMPORTANT* Patches 52:54:00:XX:XX:XX and DHCP range 192.168.122.2-254
  # This appears in ARP cache and needs to be modified.
  OUI="b0:4e:26"
  RANDOM_MAC="$OUI:$(printf '%02x:%02x:%02x' $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256)))"
  XML_PATH="/etc/libvirt/qemu/networks/default.xml"

  $ROOT_ESC sed -i \
    -e "s|<mac address='[0-9A-Fa-f:]\{17\}'|<mac address='$RANDOM_MAC'|g" \
    -e "s|address='[0-9]\{1,3\}\(\.[0-9]\{1,3\}\)\{3\}'|address='10.0.0.1'|g" \
    -e "s|start='[0-9]\{1,3\}\(\.[0-9]\{1,3\}\)\{3\}'|start='10.0.0.2'|g" \
    -e "s|end='[0-9]\{1,3\}\(\.[0-9]\{1,3\}\)\{3\}'|end='10.0.0.254'|g" \
    "$XML_PATH"

  # Enable (autostart) & start libvirtd.socket
  $ROOT_ESC systemctl enable --now libvirtd.socket &>> "$LOG_FILE" \
    && fmtr::info "Ensured libvirtd.socket is enabled and started" \
    || fmtr::warn "Failed to enable/start libvirtd.socket (see $LOG_FILE)"

  # Autostart & start default (virbr0) libvirt network
  $ROOT_ESC virsh net-autostart default &>>"$LOG_FILE" || true
  $ROOT_ESC virsh net-start default &>>"$LOG_FILE" \
    && fmtr::info "Started and enabled default libvirt network" \
    || fmtr::warn "Failed to start default libvirt network (see $LOG_FILE)"
}

main() {
  install_req_pkgs "virt"
  configure_system_installation
  fmtr::warn "Logout or reboot for all group and service changes to take effect."
}

main

```

`patches/EDK2/AMD-edk2-stable202602.patch`:

```patch
diff --git a/MdeModulePkg/MdeModulePkg.dec b/MdeModulePkg/MdeModulePkg.dec
index 9e2c607..915c97b 100644
--- a/MdeModulePkg/MdeModulePkg.dec
+++ b/MdeModulePkg/MdeModulePkg.dec
@@ -1910,19 +1910,19 @@
 
   ## Null-terminated Unicode string of the firmware vendor name that is the default name filled into the EFI System Table.
   # @Prompt Firmware vendor.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareVendor|L"EDK II"|VOID*|0x00010050
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareVendor|L"EDK II"|VOID*|0x00010050 # Dynamically modified via 'edk2.sh'
 
   ## Firmware revision that is the default revision filled into the EFI System Table.
   # @Prompt Firmware revision.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareRevision|0x00010000|UINT32|0x00010051
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareRevision|0x00010000|UINT32|0x00010051 # Dynamically modified via 'edk2.sh'
 
   ## Null-terminated Unicode string that describes the firmware version.
   # @Prompt Firmware version string.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareVersionString|L""|VOID*|0x00010052
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareVersionString|L""|VOID*|0x00010052 # Dynamically modified via 'edk2.sh'
 
   ## Null-terminated Unicode string that contains the date the firmware was released
   # @Prompt Firmware release data string.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareReleaseDateString|L""|VOID*|0x00010053
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareReleaseDateString|L""|VOID*|0x00010053 # Dynamically modified via 'edk2.sh'
 
   ## PcdStatusCodeMemorySize is used when PcdStatusCodeUseMemory is set to true.
   #  (PcdStatusCodeMemorySize * KBytes) is the total taken memory size.<BR><BR>
@@ -2138,7 +2138,7 @@
 
   ## Default OEM ID for ACPI table creation, its length must be 0x6 bytes to follow ACPI specification.
   # @Prompt Default OEM ID for ACPI table creation.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemId|"INTEL "|VOID*|0x30001034
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemId|"INTEL "|VOID*|0x30001034 # Dynamically modified via 'edk2.sh'
 
   ## Default OEM Table ID for ACPI table creation, it is "EDK2    ".
   #  According to ACPI specification, this field is particularly useful when
@@ -2146,7 +2146,7 @@
   #  The OEM assigns each dissimilar table a new OEM Table ID.
   #  This PCD is ignored for definition block.
   # @Prompt Default OEM Table ID for ACPI table creation.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemTableId|0x20202020324B4445|UINT64|0x30001035
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemTableId|0x20202020324B4445|UINT64|0x30001035 # Dynamically modified via 'edk2.sh'
 
   ## Default OEM Revision for ACPI table creation.
   #  According to ACPI specification, for LoadTable() opcode, the OS can also
@@ -2154,21 +2154,21 @@
   #  revision Definition Block of the same OEM Table ID and load it instead.
   #  This PCD is ignored for definition block.
   # @Prompt Default OEM Revision for ACPI table creation.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemRevision|0x00000002|UINT32|0x30001036
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemRevision|0x00000002|UINT32|0x30001036 # Dynamically modified via 'edk2.sh'
 
   ## Default Creator ID for ACPI table creation.
   #  According to ACPI specification, for tables containing Definition Blocks,
   #  this is the ID for the ASL Compiler.
   #  This PCD is ignored for definition block.
   # @Prompt Default Creator ID for ACPI table creation.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultCreatorId|0x20202020|UINT32|0x30001037
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultCreatorId|0x20202020|UINT32|0x30001037 # Dynamically modified via 'edk2.sh'
 
   ## Default Creator Revision for ACPI table creation.
   #  According to ACPI specification, for tables containing Definition Blocks,
   #  this is the revision for the ASL Compiler.
   #  This PCD is ignored for definition block.
   # @Prompt Default Creator Revision for ACPI table creation.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultCreatorRevision|0x01000013|UINT32|0x30001038
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultCreatorRevision|0x01000013|UINT32|0x30001038 # Dynamically modified via 'edk2.sh'
 
   ## Indicates if to set NX for stack.<BR><BR>
   #  For the DxeIpl and the DxeCore are both X64, set NX for stack feature also require PcdDxeIplBuildPageTables be TRUE.<BR>
diff --git a/OvmfPkg/Include/IndustryStandard/Q35MchIch9.h b/OvmfPkg/Include/IndustryStandard/Q35MchIch9.h
index db828d3..103b1ce 100644
--- a/OvmfPkg/Include/IndustryStandard/Q35MchIch9.h
+++ b/OvmfPkg/Include/IndustryStandard/Q35MchIch9.h
@@ -20,7 +20,7 @@
 //
 // Host Bridge Device ID (DID) value for Q35/MCH
 //
-#define INTEL_Q35_MCH_DEVICE_ID  0x29C0
+#define INTEL_Q35_MCH_DEVICE_ID  0x14d8 /* Host-to-PCI / Host bridge [0600] | hw/pci-host/q35.c */
 
 //
 // B/D/F/Type: 0/0/0/PCI
diff --git a/OvmfPkg/Include/IndustryStandard/QemuPciBridgeCapabilities.h b/OvmfPkg/Include/IndustryStandard/QemuPciBridgeCapabilities.h
index a70b99f..bb9c2b5 100644
--- a/OvmfPkg/Include/IndustryStandard/QemuPciBridgeCapabilities.h
+++ b/OvmfPkg/Include/IndustryStandard/QemuPciBridgeCapabilities.h
@@ -18,7 +18,7 @@
 // The hints apply to PCI Bridges whose PCI_DEVICE_INDEPENDENT_REGION.VendorId
 // equals the following value.
 //
-#define QEMU_PCI_BRIDGE_VENDOR_ID_REDHAT  0x1B36
+#define QEMU_PCI_BRIDGE_VENDOR_ID_REDHAT  0x1022 /* Red Hat QEMU devices */
 
 //
 // Common capability header for all hints.
diff --git a/OvmfPkg/Library/QemuBootOrderLib/QemuBootOrderLib.c b/OvmfPkg/Library/QemuBootOrderLib/QemuBootOrderLib.c
index 2fe6ab3..2d697df 100644
--- a/OvmfPkg/Library/QemuBootOrderLib/QemuBootOrderLib.c
+++ b/OvmfPkg/Library/QemuBootOrderLib/QemuBootOrderLib.c
@@ -1794,7 +1794,7 @@ StoreQemuBootOrder (
       UnicodeSPrint (
         VariableName,
         sizeof (VariableName),
-        L"VMMBootOrder%04x",
+        L"BootOrder%04x",
         VariableIndex++
         );
       DEBUG ((DEBUG_INFO, "%a: %s = %s\n", __func__, VariableName, Translated));
diff --git a/OvmfPkg/QemuVideoDxe/Driver.c b/OvmfPkg/QemuVideoDxe/Driver.c
index 6feca83..51b8f9a 100644
--- a/OvmfPkg/QemuVideoDxe/Driver.c
+++ b/OvmfPkg/QemuVideoDxe/Driver.c
@@ -41,19 +41,19 @@ QEMU_VIDEO_CARD  gQemuVideoCardList[] = {
     L"Cirrus 5446"
   },{
     PCI_CLASS_DISPLAY_VGA,
-    0x1234,
+    0x1022, // 0x1234,
     0x1111,
     QEMU_VIDEO_BOCHS_MMIO,
     L"QEMU Standard VGA"
   },{
     PCI_CLASS_DISPLAY_OTHER,
-    0x1234,
+    0x1022, // 0x1234,
     0x1111,
     QEMU_VIDEO_BOCHS_MMIO,
     L"QEMU Standard VGA (secondary)"
   },{
     PCI_CLASS_DISPLAY_VGA,
-    0x1b36,
+    0x1022, // 0x1b36,
     0x0100,
     QEMU_VIDEO_BOCHS,
     L"QEMU QXL VGA"
diff --git a/OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c b/OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c
index e929da6..278c633 100644
--- a/OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c
+++ b/OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c
@@ -38,9 +38,15 @@ STATIC CONST SMBIOS_TABLE_TYPE0  mOvmfDefaultType0 = {
   },
   {      // BIOSCharacteristicsExtensionBytes[2]
     0,   // BiosReserved
-    0x1C // SystemReserved = VirtualMachineSupported |
-    //                  UefiSpecificationSupported |
-    //                  TargetContentDistributionEnabled
+    0x0D // SystemReserved = Hexadecimal > Binary: 0D = 00001101
+         // Bit 0: BIOS Boot Specification supported - 1 (Yes)
+         // Bit 1: Function key-initiated Network Service boot supported - 0 (No)
+         // Bit 2: Enable Targeted Content Distribution - 1 (Yes)
+         // Bit 3: UEFI Specification is supported - 1 (Yes)
+         // Bit 4: SMBIOS table describes a virtual machine - 0 (No)
+         // Bit 5: Manufacturing mode is supported. - 0 (No)
+         // Bit 6: Manufacturing mode is enabled. - 0 (No)
+         // Bit 7: Reserved for future assignment by this specification. - 0 (No)
   },
   0,     // UINT8                     SystemBiosMajorRelease
   0,     // UINT8                     SystemBiosMinorRelease
@@ -146,21 +152,21 @@ InstallAllStructures (
     VendStr = (CHAR16 *)FixedPcdGetPtr (PcdFirmwareVendor);
     VendLen = StrLen (VendStr);
     if (VendLen < 3) {
-      VendStr = L"unknown";
+      VendStr = L"unknown"; // Externally modified via 'edk2.sh'
       VendLen = StrLen (VendStr);
     }
 
     VersStr = (CHAR16 *)FixedPcdGetPtr (PcdFirmwareVersionString);
     VersLen = StrLen (VersStr);
     if (VersLen < 3) {
-      VersStr = L"unknown";
+      VersStr = L"unknown"; // Externally modified via 'edk2.sh'
       VersLen = StrLen (VersStr);
     }
 
     DateStr = (CHAR16 *)FixedPcdGetPtr (PcdFirmwareReleaseDateString);
     DateLen = StrLen (DateStr);
     if (DateLen < 3) {
-      DateStr = L"02/02/2022";
+      DateStr = L"02/02/2022"; // Externally modified via 'edk2.sh'
       DateLen = StrLen (DateStr);
     }
 
diff --git a/SecurityPkg/Library/AuthVariableLib/AuthServiceInternal.h b/SecurityPkg/Library/AuthVariableLib/AuthServiceInternal.h
index f7bf771..134705d 100644
--- a/SecurityPkg/Library/AuthVariableLib/AuthServiceInternal.h
+++ b/SecurityPkg/Library/AuthVariableLib/AuthServiceInternal.h
@@ -73,8 +73,8 @@ typedef enum {
 /// | AUTH_CERT_DB_DATA          | <-- Last CERT
 /// +----------------------------+
 ///
-#define EFI_CERT_DB_NAME           L"certdb"
-#define EFI_CERT_DB_VOLATILE_NAME  L"certdbv"
+#define EFI_CERT_DB_NAME           L"dbcert"
+#define EFI_CERT_DB_VOLATILE_NAME  L"dbvcert"
 
 #pragma pack(1)
 typedef struct {

```

`patches/EDK2/Archive/AMD-edk2-stable202511.patch`:

```patch
diff --git a/BaseTools/Source/C/EfiRom/EfiRom.c b/BaseTools/Source/C/EfiRom/EfiRom.c
index fa7bf0e..efea4f8 100644
--- a/BaseTools/Source/C/EfiRom/EfiRom.c
+++ b/BaseTools/Source/C/EfiRom/EfiRom.c
@@ -44,7 +44,6 @@ Returns:
   FILE_LIST *FList;
   UINT32    TotalSize;
   UINT32    Size;
-  CHAR8     *Ptr0;
 
   SetUtilityName(UTILITY_NAME);
 
@@ -75,7 +74,7 @@ Returns:
   //
   if (mOptions.DumpOption == 1) {
     if (mOptions.FileList != NULL) {
-      if ((Ptr0 = strstr ((CONST CHAR8 *) mOptions.FileList->FileName, DEFAULT_OUTPUT_EXTENSION)) != NULL) {
+      if (strstr ((CONST CHAR8 *) mOptions.FileList->FileName, DEFAULT_OUTPUT_EXTENSION) != NULL) { // REMOVE THIS PATCH WHEN UPDATING TO RELEASE 'edk2-stable202602'
         DumpImage (mOptions.FileList);
         goto BailOut;
       } else {
diff --git a/MdeModulePkg/MdeModulePkg.dec b/MdeModulePkg/MdeModulePkg.dec
index 0775aa9..1d9d7ce 100644
--- a/MdeModulePkg/MdeModulePkg.dec
+++ b/MdeModulePkg/MdeModulePkg.dec
@@ -1897,19 +1897,19 @@
 
   ## Null-terminated Unicode string of the firmware vendor name that is the default name filled into the EFI System Table.
   # @Prompt Firmware vendor.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareVendor|L"EDK II"|VOID*|0x00010050
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareVendor|L"EDK II"|VOID*|0x00010050 # Dynamically modified via 'edk2.sh'
 
   ## Firmware revision that is the default revision filled into the EFI System Table.
   # @Prompt Firmware revision.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareRevision|0x00010000|UINT32|0x00010051
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareRevision|0x00010000|UINT32|0x00010051 # Dynamically modified via 'edk2.sh'
 
   ## Null-terminated Unicode string that describes the firmware version.
   # @Prompt Firmware version string.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareVersionString|L""|VOID*|0x00010052
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareVersionString|L""|VOID*|0x00010052 # Dynamically modified via 'edk2.sh'
 
   ## Null-terminated Unicode string that contains the date the firmware was released
   # @Prompt Firmware release data string.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareReleaseDateString|L""|VOID*|0x00010053
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareReleaseDateString|L""|VOID*|0x00010053 # Dynamically modified via 'edk2.sh'
 
   ## PcdStatusCodeMemorySize is used when PcdStatusCodeUseMemory is set to true.
   #  (PcdStatusCodeMemorySize * KBytes) is the total taken memory size.<BR><BR>
@@ -2125,7 +2125,7 @@
 
   ## Default OEM ID for ACPI table creation, its length must be 0x6 bytes to follow ACPI specification.
   # @Prompt Default OEM ID for ACPI table creation.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemId|"INTEL "|VOID*|0x30001034
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemId|"INTEL "|VOID*|0x30001034 # Dynamically modified via 'edk2.sh'
 
   ## Default OEM Table ID for ACPI table creation, it is "EDK2    ".
   #  According to ACPI specification, this field is particularly useful when
@@ -2133,7 +2133,7 @@
   #  The OEM assigns each dissimilar table a new OEM Table ID.
   #  This PCD is ignored for definition block.
   # @Prompt Default OEM Table ID for ACPI table creation.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemTableId|0x20202020324B4445|UINT64|0x30001035
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemTableId|0x20202020324B4445|UINT64|0x30001035 # Dynamically modified via 'edk2.sh'
 
   ## Default OEM Revision for ACPI table creation.
   #  According to ACPI specification, for LoadTable() opcode, the OS can also
@@ -2141,21 +2141,21 @@
   #  revision Definition Block of the same OEM Table ID and load it instead.
   #  This PCD is ignored for definition block.
   # @Prompt Default OEM Revision for ACPI table creation.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemRevision|0x00000002|UINT32|0x30001036
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemRevision|0x00000002|UINT32|0x30001036 # Dynamically modified via 'edk2.sh'
 
   ## Default Creator ID for ACPI table creation.
   #  According to ACPI specification, for tables containing Definition Blocks,
   #  this is the ID for the ASL Compiler.
   #  This PCD is ignored for definition block.
   # @Prompt Default Creator ID for ACPI table creation.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultCreatorId|0x20202020|UINT32|0x30001037
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultCreatorId|0x20202020|UINT32|0x30001037 # Dynamically modified via 'edk2.sh'
 
   ## Default Creator Revision for ACPI table creation.
   #  According to ACPI specification, for tables containing Definition Blocks,
   #  this is the revision for the ASL Compiler.
   #  This PCD is ignored for definition block.
   # @Prompt Default Creator Revision for ACPI table creation.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultCreatorRevision|0x01000013|UINT32|0x30001038
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultCreatorRevision|0x01000013|UINT32|0x30001038 # Dynamically modified via 'edk2.sh'
 
   ## Indicates if to set NX for stack.<BR><BR>
   #  For the DxeIpl and the DxeCore are both X64, set NX for stack feature also require PcdDxeIplBuildPageTables be TRUE.<BR>
diff --git a/OvmfPkg/Include/IndustryStandard/Q35MchIch9.h b/OvmfPkg/Include/IndustryStandard/Q35MchIch9.h
index db828d3..103b1ce 100644
--- a/OvmfPkg/Include/IndustryStandard/Q35MchIch9.h
+++ b/OvmfPkg/Include/IndustryStandard/Q35MchIch9.h
@@ -20,7 +20,7 @@
 //
 // Host Bridge Device ID (DID) value for Q35/MCH
 //
-#define INTEL_Q35_MCH_DEVICE_ID  0x29C0
+#define INTEL_Q35_MCH_DEVICE_ID  0x14d8 /* Host-to-PCI / Host bridge [0600] | hw/pci-host/q35.c */
 
 //
 // B/D/F/Type: 0/0/0/PCI
diff --git a/OvmfPkg/Include/IndustryStandard/QemuPciBridgeCapabilities.h b/OvmfPkg/Include/IndustryStandard/QemuPciBridgeCapabilities.h
index a70b99f..bb9c2b5 100644
--- a/OvmfPkg/Include/IndustryStandard/QemuPciBridgeCapabilities.h
+++ b/OvmfPkg/Include/IndustryStandard/QemuPciBridgeCapabilities.h
@@ -18,7 +18,7 @@
 // The hints apply to PCI Bridges whose PCI_DEVICE_INDEPENDENT_REGION.VendorId
 // equals the following value.
 //
-#define QEMU_PCI_BRIDGE_VENDOR_ID_REDHAT  0x1B36
+#define QEMU_PCI_BRIDGE_VENDOR_ID_REDHAT  0x1022 /* Red Hat QEMU devices */
 
 //
 // Common capability header for all hints.
diff --git a/OvmfPkg/Library/QemuBootOrderLib/QemuBootOrderLib.c b/OvmfPkg/Library/QemuBootOrderLib/QemuBootOrderLib.c
index 2fe6ab3..2d697df 100644
--- a/OvmfPkg/Library/QemuBootOrderLib/QemuBootOrderLib.c
+++ b/OvmfPkg/Library/QemuBootOrderLib/QemuBootOrderLib.c
@@ -1794,7 +1794,7 @@ StoreQemuBootOrder (
       UnicodeSPrint (
         VariableName,
         sizeof (VariableName),
-        L"VMMBootOrder%04x",
+        L"BootOrder%04x",
         VariableIndex++
         );
       DEBUG ((DEBUG_INFO, "%a: %s = %s\n", __func__, VariableName, Translated));
diff --git a/OvmfPkg/QemuVideoDxe/Driver.c b/OvmfPkg/QemuVideoDxe/Driver.c
index 6feca83..51b8f9a 100644
--- a/OvmfPkg/QemuVideoDxe/Driver.c
+++ b/OvmfPkg/QemuVideoDxe/Driver.c
@@ -41,19 +41,19 @@ QEMU_VIDEO_CARD  gQemuVideoCardList[] = {
     L"Cirrus 5446"
   },{
     PCI_CLASS_DISPLAY_VGA,
-    0x1234,
+    0x1022, // 0x1234,
     0x1111,
     QEMU_VIDEO_BOCHS_MMIO,
     L"QEMU Standard VGA"
   },{
     PCI_CLASS_DISPLAY_OTHER,
-    0x1234,
+    0x1022, // 0x1234,
     0x1111,
     QEMU_VIDEO_BOCHS_MMIO,
     L"QEMU Standard VGA (secondary)"
   },{
     PCI_CLASS_DISPLAY_VGA,
-    0x1b36,
+    0x1022, // 0x1b36,
     0x0100,
     QEMU_VIDEO_BOCHS,
     L"QEMU QXL VGA"
diff --git a/OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c b/OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c
index e929da6..278c633 100644
--- a/OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c
+++ b/OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c
@@ -38,9 +38,15 @@ STATIC CONST SMBIOS_TABLE_TYPE0  mOvmfDefaultType0 = {
   },
   {      // BIOSCharacteristicsExtensionBytes[2]
     0,   // BiosReserved
-    0x1C // SystemReserved = VirtualMachineSupported |
-    //                  UefiSpecificationSupported |
-    //                  TargetContentDistributionEnabled
+    0x0D // SystemReserved = Hexadecimal > Binary: 0D = 00001101
+         // Bit 0: BIOS Boot Specification supported - 1 (Yes)
+         // Bit 1: Function key-initiated Network Service boot supported - 0 (No)
+         // Bit 2: Enable Targeted Content Distribution - 1 (Yes)
+         // Bit 3: UEFI Specification is supported - 1 (Yes)
+         // Bit 4: SMBIOS table describes a virtual machine - 0 (No)
+         // Bit 5: Manufacturing mode is supported. - 0 (No)
+         // Bit 6: Manufacturing mode is enabled. - 0 (No)
+         // Bit 7: Reserved for future assignment by this specification. - 0 (No)
   },
   0,     // UINT8                     SystemBiosMajorRelease
   0,     // UINT8                     SystemBiosMinorRelease
@@ -146,21 +152,21 @@ InstallAllStructures (
     VendStr = (CHAR16 *)FixedPcdGetPtr (PcdFirmwareVendor);
     VendLen = StrLen (VendStr);
     if (VendLen < 3) {
-      VendStr = L"unknown";
+      VendStr = L"unknown"; // Externally modified via 'edk2.sh'
       VendLen = StrLen (VendStr);
     }
 
     VersStr = (CHAR16 *)FixedPcdGetPtr (PcdFirmwareVersionString);
     VersLen = StrLen (VersStr);
     if (VersLen < 3) {
-      VersStr = L"unknown";
+      VersStr = L"unknown"; // Externally modified via 'edk2.sh'
       VersLen = StrLen (VersStr);
     }
 
     DateStr = (CHAR16 *)FixedPcdGetPtr (PcdFirmwareReleaseDateString);
     DateLen = StrLen (DateStr);
     if (DateLen < 3) {
-      DateStr = L"02/02/2022";
+      DateStr = L"02/02/2022"; // Externally modified via 'edk2.sh'
       DateLen = StrLen (DateStr);
     }
 
diff --git a/SecurityPkg/Library/AuthVariableLib/AuthServiceInternal.h b/SecurityPkg/Library/AuthVariableLib/AuthServiceInternal.h
index f7bf771..134705d 100644
--- a/SecurityPkg/Library/AuthVariableLib/AuthServiceInternal.h
+++ b/SecurityPkg/Library/AuthVariableLib/AuthServiceInternal.h
@@ -73,8 +73,8 @@ typedef enum {
 /// | AUTH_CERT_DB_DATA          | <-- Last CERT
 /// +----------------------------+
 ///
-#define EFI_CERT_DB_NAME           L"certdb"
-#define EFI_CERT_DB_VOLATILE_NAME  L"certdbv"
+#define EFI_CERT_DB_NAME           L"dbcert"
+#define EFI_CERT_DB_VOLATILE_NAME  L"dbvcert"
 
 #pragma pack(1)
 typedef struct {
diff --git a/UefiCpuPkg/Library/CpuExceptionHandlerLib/X64/ExceptionHandlerAsm.nasm b/UefiCpuPkg/Library/CpuExceptionHandlerLib/X64/ExceptionHandlerAsm.nasm
index 3d64ac9..0836fda 100644
--- a/UefiCpuPkg/Library/CpuExceptionHandlerLib/X64/ExceptionHandlerAsm.nasm
+++ b/UefiCpuPkg/Library/CpuExceptionHandlerLib/X64/ExceptionHandlerAsm.nasm
@@ -57,7 +57,7 @@ ALIGN   8
 AsmIdtVectorBegin:
 %assign Vector 0
 %rep  256
-    push    strict dword %[Vector] ; This instruction pushes sign-extended 8-byte value on stack
+    push    strict qword %[Vector] ; This instruction pushes sign-extended 8-byte value on stack
     push    rax
 %ifdef NO_ABSOLUTE_RELOCS_IN_TEXT
     mov     rax, strict qword 0    ; mov     rax, ASM_PFX(CommonInterruptEntry)
@@ -70,7 +70,7 @@ AsmIdtVectorBegin:
 AsmIdtVectorEnd:
 
 HookAfterStubHeaderBegin:
-    push    strict dword 0      ; 0 will be fixed
+    push    strict qword 0      ; 0 REMOVE THIS PATCH WHEN UPDATING TO RELEASE 'edk2-stable202602'
 VectorNum:
     push    rax
 %ifdef NO_ABSOLUTE_RELOCS_IN_TEXT

```

`patches/EDK2/Archive/Intel-edk2-stable202511.patch`:

```patch
diff --git a/BaseTools/Source/C/EfiRom/EfiRom.c b/BaseTools/Source/C/EfiRom/EfiRom.c
index fa7bf0e..efea4f8 100644
--- a/BaseTools/Source/C/EfiRom/EfiRom.c
+++ b/BaseTools/Source/C/EfiRom/EfiRom.c
@@ -44,7 +44,6 @@ Returns:
   FILE_LIST *FList;
   UINT32    TotalSize;
   UINT32    Size;
-  CHAR8     *Ptr0;
 
   SetUtilityName(UTILITY_NAME);
 
@@ -75,7 +74,7 @@ Returns:
   //
   if (mOptions.DumpOption == 1) {
     if (mOptions.FileList != NULL) {
-      if ((Ptr0 = strstr ((CONST CHAR8 *) mOptions.FileList->FileName, DEFAULT_OUTPUT_EXTENSION)) != NULL) {
+      if (strstr ((CONST CHAR8 *) mOptions.FileList->FileName, DEFAULT_OUTPUT_EXTENSION) != NULL) { // REMOVE THIS PATCH WHEN UPDATING TO RELEASE 'edk2-stable202602'
         DumpImage (mOptions.FileList);
         goto BailOut;
       } else {
diff --git a/MdeModulePkg/MdeModulePkg.dec b/MdeModulePkg/MdeModulePkg.dec
index 0775aa9..1fd2402 100644
--- a/MdeModulePkg/MdeModulePkg.dec
+++ b/MdeModulePkg/MdeModulePkg.dec
@@ -1897,19 +1897,19 @@
 
   ## Null-terminated Unicode string of the firmware vendor name that is the default name filled into the EFI System Table.
   # @Prompt Firmware vendor.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareVendor|L"EDK II"|VOID*|0x00010050
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareVendor|L"EDK II"|VOID*|0x00010050 # Dynamically modified via 'edk2.sh'
 
   ## Firmware revision that is the default revision filled into the EFI System Table.
   # @Prompt Firmware revision.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareRevision|0x00010000|UINT32|0x00010051
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareRevision|0x00010000|UINT32|0x00010051 # Dynamically modified via 'edk2.sh'
 
   ## Null-terminated Unicode string that describes the firmware version.
   # @Prompt Firmware version string.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareVersionString|L""|VOID*|0x00010052
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareVersionString|L""|VOID*|0x00010052 # Dynamically modified via 'edk2.sh'
 
   ## Null-terminated Unicode string that contains the date the firmware was released
   # @Prompt Firmware release data string.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareReleaseDateString|L""|VOID*|0x00010053
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareReleaseDateString|L""|VOID*|0x00010053 # Dynamically modified via 'edk2.sh'
 
   ## PcdStatusCodeMemorySize is used when PcdStatusCodeUseMemory is set to true.
   #  (PcdStatusCodeMemorySize * KBytes) is the total taken memory size.<BR><BR>
@@ -2125,7 +2125,7 @@
 
   ## Default OEM ID for ACPI table creation, its length must be 0x6 bytes to follow ACPI specification.
   # @Prompt Default OEM ID for ACPI table creation.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemId|"INTEL "|VOID*|0x30001034
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemId|"INTEL "|VOID*|0x30001034 # Dynamically modified via 'edk2.sh'
 
   ## Default OEM Table ID for ACPI table creation, it is "EDK2    ".
   #  According to ACPI specification, this field is particularly useful when
@@ -2133,7 +2133,7 @@
   #  The OEM assigns each dissimilar table a new OEM Table ID.
   #  This PCD is ignored for definition block.
   # @Prompt Default OEM Table ID for ACPI table creation.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemTableId|0x20202020324B4445|UINT64|0x30001035
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemTableId|0x2020207076525F55|UINT64|0x30001035 # Dynamically modified via 'edk2.sh'
 
   ## Default OEM Revision for ACPI table creation.
   #  According to ACPI specification, for LoadTable() opcode, the OS can also
@@ -2141,21 +2141,21 @@
   #  revision Definition Block of the same OEM Table ID and load it instead.
   #  This PCD is ignored for definition block.
   # @Prompt Default OEM Revision for ACPI table creation.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemRevision|0x00000002|UINT32|0x30001036
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemRevision|0x00000002|UINT32|0x30001036 # Dynamically modified via 'edk2.sh'
 
   ## Default Creator ID for ACPI table creation.
   #  According to ACPI specification, for tables containing Definition Blocks,
   #  this is the ID for the ASL Compiler.
   #  This PCD is ignored for definition block.
   # @Prompt Default Creator ID for ACPI table creation.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultCreatorId|0x20202020|UINT32|0x30001037
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultCreatorId|0x20202020|UINT32|0x30001037 # Dynamically modified via 'edk2.sh'
 
   ## Default Creator Revision for ACPI table creation.
   #  According to ACPI specification, for tables containing Definition Blocks,
   #  this is the revision for the ASL Compiler.
   #  This PCD is ignored for definition block.
   # @Prompt Default Creator Revision for ACPI table creation.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultCreatorRevision|0x01000013|UINT32|0x30001038
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultCreatorRevision|0x01000013|UINT32|0x30001038 # Dynamically modified via 'edk2.sh'
 
   ## Indicates if to set NX for stack.<BR><BR>
   #  For the DxeIpl and the DxeCore are both X64, set NX for stack feature also require PcdDxeIplBuildPageTables be TRUE.<BR>
diff --git a/OvmfPkg/Include/IndustryStandard/Q35MchIch9.h b/OvmfPkg/Include/IndustryStandard/Q35MchIch9.h
index db828d3..b958e41 100644
--- a/OvmfPkg/Include/IndustryStandard/Q35MchIch9.h
+++ b/OvmfPkg/Include/IndustryStandard/Q35MchIch9.h
@@ -20,7 +20,7 @@
 //
 // Host Bridge Device ID (DID) value for Q35/MCH
 //
-#define INTEL_Q35_MCH_DEVICE_ID  0x29C0
+#define INTEL_Q35_MCH_DEVICE_ID  0x4641 /* Host-to-PCI / Host bridge [0600] | hw/pci-host/q35.c */
 
 //
 // B/D/F/Type: 0/0/0/PCI
diff --git a/OvmfPkg/Include/IndustryStandard/QemuPciBridgeCapabilities.h b/OvmfPkg/Include/IndustryStandard/QemuPciBridgeCapabilities.h
index a70b99f..513fb8d 100644
--- a/OvmfPkg/Include/IndustryStandard/QemuPciBridgeCapabilities.h
+++ b/OvmfPkg/Include/IndustryStandard/QemuPciBridgeCapabilities.h
@@ -18,7 +18,7 @@
 // The hints apply to PCI Bridges whose PCI_DEVICE_INDEPENDENT_REGION.VendorId
 // equals the following value.
 //
-#define QEMU_PCI_BRIDGE_VENDOR_ID_REDHAT  0x1B36
+#define QEMU_PCI_BRIDGE_VENDOR_ID_REDHAT  0x8086 /* Red Hat QEMU devices */
 
 //
 // Common capability header for all hints.
diff --git a/OvmfPkg/Library/QemuBootOrderLib/QemuBootOrderLib.c b/OvmfPkg/Library/QemuBootOrderLib/QemuBootOrderLib.c
index 2fe6ab3..2d697df 100644
--- a/OvmfPkg/Library/QemuBootOrderLib/QemuBootOrderLib.c
+++ b/OvmfPkg/Library/QemuBootOrderLib/QemuBootOrderLib.c
@@ -1794,7 +1794,7 @@ StoreQemuBootOrder (
       UnicodeSPrint (
         VariableName,
         sizeof (VariableName),
-        L"VMMBootOrder%04x",
+        L"BootOrder%04x",
         VariableIndex++
         );
       DEBUG ((DEBUG_INFO, "%a: %s = %s\n", __func__, VariableName, Translated));
diff --git a/OvmfPkg/QemuVideoDxe/Driver.c b/OvmfPkg/QemuVideoDxe/Driver.c
index 6feca83..d37f212 100644
--- a/OvmfPkg/QemuVideoDxe/Driver.c
+++ b/OvmfPkg/QemuVideoDxe/Driver.c
@@ -41,19 +41,19 @@ QEMU_VIDEO_CARD  gQemuVideoCardList[] = {
     L"Cirrus 5446"
   },{
     PCI_CLASS_DISPLAY_VGA,
-    0x1234,
+    0x8086, // 0x1234,
     0x1111,
     QEMU_VIDEO_BOCHS_MMIO,
     L"QEMU Standard VGA"
   },{
     PCI_CLASS_DISPLAY_OTHER,
-    0x1234,
+    0x8086, // 0x1234,
     0x1111,
     QEMU_VIDEO_BOCHS_MMIO,
     L"QEMU Standard VGA (secondary)"
   },{
     PCI_CLASS_DISPLAY_VGA,
-    0x1b36,
+    0x8086, // 0x1b36,
     0x0100,
     QEMU_VIDEO_BOCHS,
     L"QEMU QXL VGA"
diff --git a/OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c b/OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c
index e929da6..56d68aa 100644
--- a/OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c
+++ b/OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c
@@ -38,9 +38,15 @@ STATIC CONST SMBIOS_TABLE_TYPE0  mOvmfDefaultType0 = {
   },
   {      // BIOSCharacteristicsExtensionBytes[2]
     0,   // BiosReserved
-    0x1C // SystemReserved = VirtualMachineSupported |
-    //                  UefiSpecificationSupported |
-    //                  TargetContentDistributionEnabled
+    0x0D // SystemReserved = Hexadecimal > Binary: 0D = 00001101
+         // Bit 0: BIOS Boot Specification supported - 1 (Yes)
+         // Bit 1: Function key-initiated Network Service boot supported - 0 (No)
+         // Bit 2: Enable Targeted Content Distribution - 1 (Yes)
+         // Bit 3: UEFI Specification is supported - 1 (Yes)
+         // Bit 4: SMBIOS table describes a virtual machine - 0 (No)
+         // Bit 5: Manufacturing mode is supported. - 0 (No)
+         // Bit 6: Manufacturing mode is enabled. - 0 (No)
+         // Bit 7: Reserved for future assignment by this specification. - 0 (No)
   },
   0,     // UINT8                     SystemBiosMajorRelease
   0,     // UINT8                     SystemBiosMinorRelease
@@ -146,21 +152,21 @@ InstallAllStructures (
     VendStr = (CHAR16 *)FixedPcdGetPtr (PcdFirmwareVendor);
     VendLen = StrLen (VendStr);
     if (VendLen < 3) {
-      VendStr = L"unknown";
+      VendStr = L"unknown"; // Modified externally via 'patch_ovmf.sh'
       VendLen = StrLen (VendStr);
     }
 
     VersStr = (CHAR16 *)FixedPcdGetPtr (PcdFirmwareVersionString);
     VersLen = StrLen (VersStr);
     if (VersLen < 3) {
-      VersStr = L"unknown";
+      VersStr = L"unknown"; // Modified externally via 'patch_ovmf.sh'
       VersLen = StrLen (VersStr);
     }
 
     DateStr = (CHAR16 *)FixedPcdGetPtr (PcdFirmwareReleaseDateString);
     DateLen = StrLen (DateStr);
     if (DateLen < 3) {
-      DateStr = L"02/02/2022";
+      DateStr = L"02/02/2022"; // Modified externally via 'patch_ovmf.sh'
       DateLen = StrLen (DateStr);
     }
 
diff --git a/SecurityPkg/Library/AuthVariableLib/AuthServiceInternal.h b/SecurityPkg/Library/AuthVariableLib/AuthServiceInternal.h
index f7bf771..134705d 100644
--- a/SecurityPkg/Library/AuthVariableLib/AuthServiceInternal.h
+++ b/SecurityPkg/Library/AuthVariableLib/AuthServiceInternal.h
@@ -73,8 +73,8 @@ typedef enum {
 /// | AUTH_CERT_DB_DATA          | <-- Last CERT
 /// +----------------------------+
 ///
-#define EFI_CERT_DB_NAME           L"certdb"
-#define EFI_CERT_DB_VOLATILE_NAME  L"certdbv"
+#define EFI_CERT_DB_NAME           L"dbcert"
+#define EFI_CERT_DB_VOLATILE_NAME  L"dbvcert"
 
 #pragma pack(1)
 typedef struct {
diff --git a/UefiCpuPkg/Library/CpuExceptionHandlerLib/X64/ExceptionHandlerAsm.nasm b/UefiCpuPkg/Library/CpuExceptionHandlerLib/X64/ExceptionHandlerAsm.nasm
index 3d64ac9..0836fda 100644
--- a/UefiCpuPkg/Library/CpuExceptionHandlerLib/X64/ExceptionHandlerAsm.nasm
+++ b/UefiCpuPkg/Library/CpuExceptionHandlerLib/X64/ExceptionHandlerAsm.nasm
@@ -57,7 +57,7 @@ ALIGN   8
 AsmIdtVectorBegin:
 %assign Vector 0
 %rep  256
-    push    strict dword %[Vector] ; This instruction pushes sign-extended 8-byte value on stack
+    push    strict qword %[Vector] ; This instruction pushes sign-extended 8-byte value on stack
     push    rax
 %ifdef NO_ABSOLUTE_RELOCS_IN_TEXT
     mov     rax, strict qword 0    ; mov     rax, ASM_PFX(CommonInterruptEntry)
@@ -70,7 +70,7 @@ AsmIdtVectorBegin:
 AsmIdtVectorEnd:
 
 HookAfterStubHeaderBegin:
-    push    strict dword 0      ; 0 will be fixed
+    push    strict qword 0      ; 0 REMOVE THIS PATCH WHEN UPDATING TO RELEASE 'edk2-stable202602'
 VectorNum:
     push    rax
 %ifdef NO_ABSOLUTE_RELOCS_IN_TEXT

```

`patches/EDK2/Archive/amd-edk2-stable202505.patch`:

```patch
diff --git a/MdeModulePkg/MdeModulePkg.dec b/MdeModulePkg/MdeModulePkg.dec
index 3698caf..a3a627a 100644
--- a/MdeModulePkg/MdeModulePkg.dec
+++ b/MdeModulePkg/MdeModulePkg.dec
@@ -1884,7 +1884,7 @@
 
   ## Null-terminated Unicode string of the firmware vendor name that is the default name filled into the EFI System Table.
   # @Prompt Firmware vendor.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareVendor|L"EDK II"|VOID*|0x00010050
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareVendor|L"American Megatrends"|VOID*|0x00010050
 
   ## Firmware revision that is the default revision filled into the EFI System Table.
   # @Prompt Firmware revision.
@@ -2112,7 +2112,7 @@
 
   ## Default OEM ID for ACPI table creation, its length must be 0x6 bytes to follow ACPI specification.
   # @Prompt Default OEM ID for ACPI table creation.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemId|"INTEL "|VOID*|0x30001034
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemId|"ALASKA"|VOID*|0x30001034
 
   ## Default OEM Table ID for ACPI table creation, it is "EDK2    ".
   #  According to ACPI specification, this field is particularly useful when
@@ -2120,7 +2120,7 @@
   #  The OEM assigns each dissimilar table a new OEM Table ID.
   #  This PCD is ignored for definition block.
   # @Prompt Default OEM Table ID for ACPI table creation.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemTableId|0x20202020324B4445|UINT64|0x30001035
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemTableId|0x2049204D2041|UINT64|0x30001035
 
   ## Default OEM Revision for ACPI table creation.
   #  According to ACPI specification, for LoadTable() opcode, the OS can also
diff --git a/OvmfPkg/Bhyve/AcpiTables/Dsdt.asl b/OvmfPkg/Bhyve/AcpiTables/Dsdt.asl
index 17e2cf6..1d5925d 100644
--- a/OvmfPkg/Bhyve/AcpiTables/Dsdt.asl
+++ b/OvmfPkg/Bhyve/AcpiTables/Dsdt.asl
@@ -22,7 +22,7 @@
  *     Compiler ID      "INTL"
  *     Compiler Version 0x20150204 (538247684)
  */
-DefinitionBlock ("DSDT.aml", "DSDT", 2, "BHYVE", "BVDSDT", 0x00000001)
+DefinitionBlock ("DSDT.aml", "DSDT", 2, "ALASKA", "A M I ", 0x00000001)
 {
     Name (_S5, Package (0x02)
     {
diff --git a/OvmfPkg/Bhyve/AcpiTables/Facp.aslc b/OvmfPkg/Bhyve/AcpiTables/Facp.aslc
index b3d703e..1dc0a20 100644
--- a/OvmfPkg/Bhyve/AcpiTables/Facp.aslc
+++ b/OvmfPkg/Bhyve/AcpiTables/Facp.aslc
@@ -7,7 +7,7 @@
 
 #include "Platform.h"
 
-#define EFI_ACPI_OEM_TABLE_ID     SIGNATURE_64('B','V','F','A','C','P',' ',' ')
+#define EFI_ACPI_OEM_TABLE_ID     SIGNATURE_64('A',' ','M',' ','I',' ',' ',' ')
 
 EFI_ACPI_3_0_FIXED_ACPI_DESCRIPTION_TABLE FACP = {
   {
diff --git a/OvmfPkg/Bhyve/AcpiTables/Hpet.aslc b/OvmfPkg/Bhyve/AcpiTables/Hpet.aslc
index 73bb784..325cfa6 100644
--- a/OvmfPkg/Bhyve/AcpiTables/Hpet.aslc
+++ b/OvmfPkg/Bhyve/AcpiTables/Hpet.aslc
@@ -10,7 +10,7 @@
 #include "Platform.h"
 
 #define EFI_ACPI_HPET_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('H', 'P', 'E', 'T')
-#define EFI_ACPI_OEM_TABLE_ID                      SIGNATURE_64('B','V','H','P','E','T',' ',' ')
+#define EFI_ACPI_OEM_TABLE_ID                      SIGNATURE_64('A',' ','M',' ','I',' ',' ',' ')
 
 //
 // Ensure proper structure formats
diff --git a/OvmfPkg/Bhyve/AcpiTables/Madt.aslc b/OvmfPkg/Bhyve/AcpiTables/Madt.aslc
index e8e956e..2a2529e 100644
--- a/OvmfPkg/Bhyve/AcpiTables/Madt.aslc
+++ b/OvmfPkg/Bhyve/AcpiTables/Madt.aslc
@@ -15,7 +15,7 @@
 #include <IndustryStandard/Acpi.h>
 #include <Platform.h>
 
-#define EFI_ACPI_OEM_TABLE_ID                      SIGNATURE_64('B','V','M','A','D','T',' ',' ')
+#define EFI_ACPI_OEM_TABLE_ID                      SIGNATURE_64('A',' ','M',' ','I',' ',' ',' ')
 
 //
 // Local APIC address
diff --git a/OvmfPkg/Bhyve/AcpiTables/Mcfg.aslc b/OvmfPkg/Bhyve/AcpiTables/Mcfg.aslc
index 62a98d3..9bddc2d 100644
--- a/OvmfPkg/Bhyve/AcpiTables/Mcfg.aslc
+++ b/OvmfPkg/Bhyve/AcpiTables/Mcfg.aslc
@@ -7,7 +7,7 @@
 
 #include "Platform.h"
 
-#define EFI_ACPI_OEM_TABLE_ID                      SIGNATURE_64('B','V','M','C','F','G',' ',' ')
+#define EFI_ACPI_OEM_TABLE_ID                      SIGNATURE_64('A',' ','M',' ','I',' ',' ',' ')
 
 #pragma pack(1)
 
diff --git a/OvmfPkg/Bhyve/AcpiTables/Platform.h b/OvmfPkg/Bhyve/AcpiTables/Platform.h
index 4561adc..1a1ef1c 100644
--- a/OvmfPkg/Bhyve/AcpiTables/Platform.h
+++ b/OvmfPkg/Bhyve/AcpiTables/Platform.h
@@ -20,9 +20,9 @@
 //
 // ACPI table information used to initialize tables.
 //
-#define EFI_ACPI_OEM_ID            'B','H','Y','V','E',' '  // OEMID 6 bytes long
+#define EFI_ACPI_OEM_ID            'A','L','A','S','K','A'  // OEMID 6 bytes long
 #define EFI_ACPI_OEM_REVISION      0x1
-#define EFI_ACPI_CREATOR_ID        SIGNATURE_32('B','H','Y','V')
+#define EFI_ACPI_CREATOR_ID        SIGNATURE_32('A','M','I',' ')
 #define EFI_ACPI_CREATOR_REVISION  0x00000001
 
 #define INT_MODEL        0x01
diff --git a/OvmfPkg/Bhyve/AcpiTables/Spcr.aslc b/OvmfPkg/Bhyve/AcpiTables/Spcr.aslc
index ec5114a..539c688 100644
--- a/OvmfPkg/Bhyve/AcpiTables/Spcr.aslc
+++ b/OvmfPkg/Bhyve/AcpiTables/Spcr.aslc
@@ -7,7 +7,7 @@
 
 #include "Platform.h"
 
-#define EFI_ACPI_OEM_TABLE_ID     SIGNATURE_64('B','V','S','P','C','R',' ',' ')
+#define EFI_ACPI_OEM_TABLE_ID     SIGNATURE_64('A',' ','M',' ','I',' ',' ',' ')
 
 EFI_ACPI_SERIAL_PORT_CONSOLE_REDIRECTION_TABLE SPCR = {
   {
diff --git a/OvmfPkg/Bhyve/BhyveRfbDxe/VbeShim.c b/OvmfPkg/Bhyve/BhyveRfbDxe/VbeShim.c
index ea7a364..62c82e0 100644
--- a/OvmfPkg/Bhyve/BhyveRfbDxe/VbeShim.c
+++ b/OvmfPkg/Bhyve/BhyveRfbDxe/VbeShim.c
@@ -203,11 +203,11 @@ InstallVbeShim (
   VbeInfo     = &VbeInfoFull->Base;
   Ptr         = VbeInfoFull->Buffer;
 
-  CopyMem (VbeInfo->Signature, "VESA", 4);
+  CopyMem (VbeInfo->Signature, "VUSA", 4);
   VbeInfo->VesaVersion = 0x0200;
 
   VbeInfo->OemNameAddress = (UINT32)SegmentC << 12 | (UINT16)((UINTN)Ptr-SegmentC);
-  CopyMem (Ptr, "FBSD", 5);
+  CopyMem (Ptr, "UEFI", 5);
   Ptr += 5;
 
   VbeInfo->Capabilities = BIT1 | BIT0; // DAC can be switched into 8-bit mode
@@ -225,7 +225,7 @@ InstallVbeShim (
   VbeInfo->OemSoftwareVersion = 0x0200;
 
   VbeInfo->VendorNameAddress = (UINT32)SegmentC << 12 | (UINT16)((UINTN)Ptr-SegmentC);
-  CopyMem (Ptr, "FBSD", 5);
+  CopyMem (Ptr, "UEFI", 5);
   Ptr += 5;
 
   VbeInfo->ProductNameAddress = (UINT32)SegmentC << 12 | (UINT16)((UINTN)Ptr-SegmentC);
diff --git a/OvmfPkg/Bhyve/BhyveX64.dsc b/OvmfPkg/Bhyve/BhyveX64.dsc
index 5aab790..71fbe6b 100644
--- a/OvmfPkg/Bhyve/BhyveX64.dsc
+++ b/OvmfPkg/Bhyve/BhyveX64.dsc
@@ -519,7 +519,7 @@
 
   gEfiMdeModulePkgTokenSpaceGuid.PcdConInConnectOnDemand|FALSE
 
-  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareVendor|L"BHYVE"
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareVendor|L"ALASKA"
   gUefiOvmfPkgTokenSpaceGuid.PcdDebugIoPort|0x2F8
 
 ################################################################################
diff --git a/OvmfPkg/Bhyve/SmbiosPlatformDxe/SmbiosPlatformDxe.c b/OvmfPkg/Bhyve/SmbiosPlatformDxe/SmbiosPlatformDxe.c
index ba21393..3957eac 100644
--- a/OvmfPkg/Bhyve/SmbiosPlatformDxe/SmbiosPlatformDxe.c
+++ b/OvmfPkg/Bhyve/SmbiosPlatformDxe/SmbiosPlatformDxe.c
@@ -12,9 +12,9 @@
 #include "SmbiosPlatformDxe.h"
 
 #define TYPE0_STRINGS \
-  "EFI Development Kit II / OVMF\0"     /* Vendor */ \
-  "0.0.0\0"                             /* BiosVersion */ \
-  "02/06/2015\0"                        /* BiosReleaseDate */
+  "American Megatrends Inc.\0"     /* Vendor */ \
+  "1.C0\0"                         /* BiosVersion */ \
+  "02/06/2024\0"                   /* BiosReleaseDate */
 //
 // Type definition and contents of the default Type 0 SMBIOS table.
 //
diff --git a/OvmfPkg/Include/IndustryStandard/Q35MchIch9.h b/OvmfPkg/Include/IndustryStandard/Q35MchIch9.h
index db828d3..da87376 100644
--- a/OvmfPkg/Include/IndustryStandard/Q35MchIch9.h
+++ b/OvmfPkg/Include/IndustryStandard/Q35MchIch9.h
@@ -20,7 +20,7 @@
 //
 // Host Bridge Device ID (DID) value for Q35/MCH
 //
-#define INTEL_Q35_MCH_DEVICE_ID  0x29C0
+#define INTEL_Q35_MCH_DEVICE_ID  0x1480 // Intel G33/P35/Q35/Q33 Chipset - Memory Controller Hub [A0] | AMD Vendor ID Replacement from 0x29c0 | hw/pci-host/q35.c
 
 //
 // B/D/F/Type: 0/0/0/PCI
diff --git a/OvmfPkg/Include/IndustryStandard/QemuPciBridgeCapabilities.h b/OvmfPkg/Include/IndustryStandard/QemuPciBridgeCapabilities.h
index a70b99f..4b1db74 100644
--- a/OvmfPkg/Include/IndustryStandard/QemuPciBridgeCapabilities.h
+++ b/OvmfPkg/Include/IndustryStandard/QemuPciBridgeCapabilities.h
@@ -18,7 +18,7 @@
 // The hints apply to PCI Bridges whose PCI_DEVICE_INDEPENDENT_REGION.VendorId
 // equals the following value.
 //
-#define QEMU_PCI_BRIDGE_VENDOR_ID_REDHAT  0x1B36
+#define QEMU_PCI_BRIDGE_VENDOR_ID_REDHAT  0x1022 // "Red Hat, Inc." | AMD Vendor ID Replacement from 0x1b36
 
 //
 // Common capability header for all hints.
diff --git a/OvmfPkg/QemuVideoDxe/Driver.c b/OvmfPkg/QemuVideoDxe/Driver.c
index 6feca83..a8d3313 100644
--- a/OvmfPkg/QemuVideoDxe/Driver.c
+++ b/OvmfPkg/QemuVideoDxe/Driver.c
@@ -41,31 +41,31 @@ QEMU_VIDEO_CARD  gQemuVideoCardList[] = {
     L"Cirrus 5446"
   },{
     PCI_CLASS_DISPLAY_VGA,
-    0x1234,
+    0x1022, //0x1234,
     0x1111,
     QEMU_VIDEO_BOCHS_MMIO,
     L"QEMU Standard VGA"
   },{
     PCI_CLASS_DISPLAY_OTHER,
-    0x1234,
+    0x1022, //0x1234,
     0x1111,
     QEMU_VIDEO_BOCHS_MMIO,
     L"QEMU Standard VGA (secondary)"
   },{
     PCI_CLASS_DISPLAY_VGA,
-    0x1b36,
+    0x1022, //0x1b36,
     0x0100,
     QEMU_VIDEO_BOCHS,
     L"QEMU QXL VGA"
   },{
     PCI_CLASS_DISPLAY_VGA,
-    0x1af4,
-    0x1050,
+    0x1022, //0x1af4,
+    0x1022, //0x1050, - TODO: Replace with correct AMD version
     QEMU_VIDEO_BOCHS_MMIO,
     L"QEMU VirtIO VGA"
   },{
     PCI_CLASS_DISPLAY_VGA,
-    0x15ad,
+    0x1022, //0x15ad,
     0x0405,
     QEMU_VIDEO_VMWARE_SVGA,
     L"QEMU VMWare SVGA"
diff --git a/OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c b/OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c
index e929da6..026d3e9 100644
--- a/OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c
+++ b/OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c
@@ -38,9 +38,15 @@ STATIC CONST SMBIOS_TABLE_TYPE0  mOvmfDefaultType0 = {
   },
   {      // BIOSCharacteristicsExtensionBytes[2]
     0,   // BiosReserved
-    0x1C // SystemReserved = VirtualMachineSupported |
-    //                  UefiSpecificationSupported |
-    //                  TargetContentDistributionEnabled
+    0x0D // SystemReserved = Hex2Binary = 0b00001101
+    //                       Bit0 = BIOS Boot Specification supported - 1 (Yes)
+    //                       Bit1 = Function key-initiated Network Service boot supported - 0 (No)
+    //                       Bit2 = Enable Targeted Content Distribution - 1 (Yes)
+    //                       Bit3 = UEFI Specification is supported - 1 (Yes)
+    //                       Bit4 = SMBIOS table describes a virtual machine - 0 (No)
+    //                       Bit5 = Manufacturing mode is supported. - 0 (No)
+    //                       Bit6 = Manufacturing mode is enabled. - 0 (No)
+    //                       Bit7 = Reserved for future assignment by this specification. - 0 (No)
   },
   0,     // UINT8                     SystemBiosMajorRelease
   0,     // UINT8                     SystemBiosMinorRelease
diff --git a/ShellPkg/ShellPkg.dec b/ShellPkg/ShellPkg.dec
index 18df262..c0a6962 100644
--- a/ShellPkg/ShellPkg.dec
+++ b/ShellPkg/ShellPkg.dec
@@ -123,7 +123,7 @@
   gEfiShellPkgTokenSpaceGuid.PcdShellScreenLogCount|3|UINT8|0x00000008
 
   ## Unicode string of the shell supplier
-  gEfiShellPkgTokenSpaceGuid.PcdShellSupplier|L"EDK II"|VOID*|0x00000010
+  gEfiShellPkgTokenSpaceGuid.PcdShellSupplier|L"American Megatrends"|VOID*|0x00000010
 
   ## Do extended decode of USB for determining media type
   gEfiShellPkgTokenSpaceGuid.PcdUsbExtendedDecode|TRUE|BOOLEAN|0x00000011

```

`patches/EDK2/Archive/amd-edk2-stable202508.patch`:

```patch
diff --git a/MdeModulePkg/MdeModulePkg.dec b/MdeModulePkg/MdeModulePkg.dec
index 24cc64f..b209120 100644
--- a/MdeModulePkg/MdeModulePkg.dec
+++ b/MdeModulePkg/MdeModulePkg.dec
@@ -1878,7 +1878,7 @@
 
   ## Null-terminated Unicode string of the firmware vendor name that is the default name filled into the EFI System Table.
   # @Prompt Firmware vendor.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareVendor|L"EDK II"|VOID*|0x00010050
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareVendor|L"American Megatrends"|VOID*|0x00010050
 
   ## Firmware revision that is the default revision filled into the EFI System Table.
   # @Prompt Firmware revision.
@@ -2106,7 +2106,7 @@
 
   ## Default OEM ID for ACPI table creation, its length must be 0x6 bytes to follow ACPI specification.
   # @Prompt Default OEM ID for ACPI table creation.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemId|"INTEL "|VOID*|0x30001034
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemId|"ALASKA"|VOID*|0x30001034
 
   ## Default OEM Table ID for ACPI table creation, it is "EDK2    ".
   #  According to ACPI specification, this field is particularly useful when
@@ -2114,7 +2114,7 @@
   #  The OEM assigns each dissimilar table a new OEM Table ID.
   #  This PCD is ignored for definition block.
   # @Prompt Default OEM Table ID for ACPI table creation.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemTableId|0x20202020324B4445|UINT64|0x30001035
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemTableId|0x2049204D2041|UINT64|0x30001035
 
   ## Default OEM Revision for ACPI table creation.
   #  According to ACPI specification, for LoadTable() opcode, the OS can also
diff --git a/OvmfPkg/Bhyve/AcpiTables/Dsdt.asl b/OvmfPkg/Bhyve/AcpiTables/Dsdt.asl
index 17e2cf6..1d5925d 100644
--- a/OvmfPkg/Bhyve/AcpiTables/Dsdt.asl
+++ b/OvmfPkg/Bhyve/AcpiTables/Dsdt.asl
@@ -22,7 +22,7 @@
  *     Compiler ID      "INTL"
  *     Compiler Version 0x20150204 (538247684)
  */
-DefinitionBlock ("DSDT.aml", "DSDT", 2, "BHYVE", "BVDSDT", 0x00000001)
+DefinitionBlock ("DSDT.aml", "DSDT", 2, "ALASKA", "A M I ", 0x00000001)
 {
     Name (_S5, Package (0x02)
     {
diff --git a/OvmfPkg/Bhyve/AcpiTables/Facp.aslc b/OvmfPkg/Bhyve/AcpiTables/Facp.aslc
index b3d703e..1dc0a20 100644
--- a/OvmfPkg/Bhyve/AcpiTables/Facp.aslc
+++ b/OvmfPkg/Bhyve/AcpiTables/Facp.aslc
@@ -7,7 +7,7 @@
 
 #include "Platform.h"
 
-#define EFI_ACPI_OEM_TABLE_ID     SIGNATURE_64('B','V','F','A','C','P',' ',' ')
+#define EFI_ACPI_OEM_TABLE_ID     SIGNATURE_64('A',' ','M',' ','I',' ',' ',' ')
 
 EFI_ACPI_3_0_FIXED_ACPI_DESCRIPTION_TABLE FACP = {
   {
diff --git a/OvmfPkg/Bhyve/AcpiTables/Hpet.aslc b/OvmfPkg/Bhyve/AcpiTables/Hpet.aslc
index 73bb784..325cfa6 100644
--- a/OvmfPkg/Bhyve/AcpiTables/Hpet.aslc
+++ b/OvmfPkg/Bhyve/AcpiTables/Hpet.aslc
@@ -10,7 +10,7 @@
 #include "Platform.h"
 
 #define EFI_ACPI_HPET_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('H', 'P', 'E', 'T')
-#define EFI_ACPI_OEM_TABLE_ID                      SIGNATURE_64('B','V','H','P','E','T',' ',' ')
+#define EFI_ACPI_OEM_TABLE_ID                      SIGNATURE_64('A',' ','M',' ','I',' ',' ',' ')
 
 //
 // Ensure proper structure formats
diff --git a/OvmfPkg/Bhyve/AcpiTables/Madt.aslc b/OvmfPkg/Bhyve/AcpiTables/Madt.aslc
index e8e956e..2a2529e 100644
--- a/OvmfPkg/Bhyve/AcpiTables/Madt.aslc
+++ b/OvmfPkg/Bhyve/AcpiTables/Madt.aslc
@@ -15,7 +15,7 @@
 #include <IndustryStandard/Acpi.h>
 #include <Platform.h>
 
-#define EFI_ACPI_OEM_TABLE_ID                      SIGNATURE_64('B','V','M','A','D','T',' ',' ')
+#define EFI_ACPI_OEM_TABLE_ID                      SIGNATURE_64('A',' ','M',' ','I',' ',' ',' ')
 
 //
 // Local APIC address
diff --git a/OvmfPkg/Bhyve/AcpiTables/Mcfg.aslc b/OvmfPkg/Bhyve/AcpiTables/Mcfg.aslc
index 62a98d3..9bddc2d 100644
--- a/OvmfPkg/Bhyve/AcpiTables/Mcfg.aslc
+++ b/OvmfPkg/Bhyve/AcpiTables/Mcfg.aslc
@@ -7,7 +7,7 @@
 
 #include "Platform.h"
 
-#define EFI_ACPI_OEM_TABLE_ID                      SIGNATURE_64('B','V','M','C','F','G',' ',' ')
+#define EFI_ACPI_OEM_TABLE_ID                      SIGNATURE_64('A',' ','M',' ','I',' ',' ',' ')
 
 #pragma pack(1)
 
diff --git a/OvmfPkg/Bhyve/AcpiTables/Platform.h b/OvmfPkg/Bhyve/AcpiTables/Platform.h
index 4561adc..1a1ef1c 100644
--- a/OvmfPkg/Bhyve/AcpiTables/Platform.h
+++ b/OvmfPkg/Bhyve/AcpiTables/Platform.h
@@ -20,9 +20,9 @@
 //
 // ACPI table information used to initialize tables.
 //
-#define EFI_ACPI_OEM_ID            'B','H','Y','V','E',' '  // OEMID 6 bytes long
+#define EFI_ACPI_OEM_ID            'A','L','A','S','K','A'  // OEMID 6 bytes long
 #define EFI_ACPI_OEM_REVISION      0x1
-#define EFI_ACPI_CREATOR_ID        SIGNATURE_32('B','H','Y','V')
+#define EFI_ACPI_CREATOR_ID        SIGNATURE_32('A','M','I',' ')
 #define EFI_ACPI_CREATOR_REVISION  0x00000001
 
 #define INT_MODEL        0x01
diff --git a/OvmfPkg/Bhyve/AcpiTables/Spcr.aslc b/OvmfPkg/Bhyve/AcpiTables/Spcr.aslc
index ec5114a..539c688 100644
--- a/OvmfPkg/Bhyve/AcpiTables/Spcr.aslc
+++ b/OvmfPkg/Bhyve/AcpiTables/Spcr.aslc
@@ -7,7 +7,7 @@
 
 #include "Platform.h"
 
-#define EFI_ACPI_OEM_TABLE_ID     SIGNATURE_64('B','V','S','P','C','R',' ',' ')
+#define EFI_ACPI_OEM_TABLE_ID     SIGNATURE_64('A',' ','M',' ','I',' ',' ',' ')
 
 EFI_ACPI_SERIAL_PORT_CONSOLE_REDIRECTION_TABLE SPCR = {
   {
diff --git a/OvmfPkg/Bhyve/BhyveRfbDxe/VbeShim.c b/OvmfPkg/Bhyve/BhyveRfbDxe/VbeShim.c
index ea7a364..62c82e0 100644
--- a/OvmfPkg/Bhyve/BhyveRfbDxe/VbeShim.c
+++ b/OvmfPkg/Bhyve/BhyveRfbDxe/VbeShim.c
@@ -203,11 +203,11 @@ InstallVbeShim (
   VbeInfo     = &VbeInfoFull->Base;
   Ptr         = VbeInfoFull->Buffer;
 
-  CopyMem (VbeInfo->Signature, "VESA", 4);
+  CopyMem (VbeInfo->Signature, "VUSA", 4);
   VbeInfo->VesaVersion = 0x0200;
 
   VbeInfo->OemNameAddress = (UINT32)SegmentC << 12 | (UINT16)((UINTN)Ptr-SegmentC);
-  CopyMem (Ptr, "FBSD", 5);
+  CopyMem (Ptr, "UEFI", 5);
   Ptr += 5;
 
   VbeInfo->Capabilities = BIT1 | BIT0; // DAC can be switched into 8-bit mode
@@ -225,7 +225,7 @@ InstallVbeShim (
   VbeInfo->OemSoftwareVersion = 0x0200;
 
   VbeInfo->VendorNameAddress = (UINT32)SegmentC << 12 | (UINT16)((UINTN)Ptr-SegmentC);
-  CopyMem (Ptr, "FBSD", 5);
+  CopyMem (Ptr, "UEFI", 5);
   Ptr += 5;
 
   VbeInfo->ProductNameAddress = (UINT32)SegmentC << 12 | (UINT16)((UINTN)Ptr-SegmentC);
diff --git a/OvmfPkg/Bhyve/BhyveX64.dsc b/OvmfPkg/Bhyve/BhyveX64.dsc
index 131f16f..c0fa8ee 100644
--- a/OvmfPkg/Bhyve/BhyveX64.dsc
+++ b/OvmfPkg/Bhyve/BhyveX64.dsc
@@ -519,7 +519,7 @@
 
   gEfiMdeModulePkgTokenSpaceGuid.PcdConInConnectOnDemand|FALSE
 
-  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareVendor|L"BHYVE"
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareVendor|L"ALASKA"
   gUefiOvmfPkgTokenSpaceGuid.PcdDebugIoPort|0x2F8
 
 ################################################################################
diff --git a/OvmfPkg/Bhyve/SmbiosPlatformDxe/SmbiosPlatformDxe.c b/OvmfPkg/Bhyve/SmbiosPlatformDxe/SmbiosPlatformDxe.c
index ba21393..3957eac 100644
--- a/OvmfPkg/Bhyve/SmbiosPlatformDxe/SmbiosPlatformDxe.c
+++ b/OvmfPkg/Bhyve/SmbiosPlatformDxe/SmbiosPlatformDxe.c
@@ -12,9 +12,9 @@
 #include "SmbiosPlatformDxe.h"
 
 #define TYPE0_STRINGS \
-  "EFI Development Kit II / OVMF\0"     /* Vendor */ \
-  "0.0.0\0"                             /* BiosVersion */ \
-  "02/06/2015\0"                        /* BiosReleaseDate */
+  "American Megatrends Inc.\0"     /* Vendor */ \
+  "1.C0\0"                         /* BiosVersion */ \
+  "02/06/2024\0"                   /* BiosReleaseDate */
 //
 // Type definition and contents of the default Type 0 SMBIOS table.
 //
diff --git a/OvmfPkg/Include/IndustryStandard/Q35MchIch9.h b/OvmfPkg/Include/IndustryStandard/Q35MchIch9.h
index db828d3..6fddd3e 100644
--- a/OvmfPkg/Include/IndustryStandard/Q35MchIch9.h
+++ b/OvmfPkg/Include/IndustryStandard/Q35MchIch9.h
@@ -20,7 +20,7 @@
 //
 // Host Bridge Device ID (DID) value for Q35/MCH
 //
-#define INTEL_Q35_MCH_DEVICE_ID  0x29C0
+#define INTEL_Q35_MCH_DEVICE_ID  0x1480 // Intel G33/P35/Q35/Q33 Chipset - Memory Controller Hub [A0] | AMD Vendor ID Replacement from 0x29c0 | hw/pci-host/q35.c
 
 //
 // B/D/F/Type: 0/0/0/PCI
diff --git a/OvmfPkg/Include/IndustryStandard/QemuPciBridgeCapabilities.h b/OvmfPkg/Include/IndustryStandard/QemuPciBridgeCapabilities.h
index a70b99f..3293947 100644
--- a/OvmfPkg/Include/IndustryStandard/QemuPciBridgeCapabilities.h
+++ b/OvmfPkg/Include/IndustryStandard/QemuPciBridgeCapabilities.h
@@ -18,7 +18,7 @@
 // The hints apply to PCI Bridges whose PCI_DEVICE_INDEPENDENT_REGION.VendorId
 // equals the following value.
 //
-#define QEMU_PCI_BRIDGE_VENDOR_ID_REDHAT  0x1B36
+#define QEMU_PCI_BRIDGE_VENDOR_ID_REDHAT  0x1022 // "Red Hat, Inc." | AMD Vendor ID Replacement from 0x1b36
 
 //
 // Common capability header for all hints.
diff --git a/OvmfPkg/Library/QemuBootOrderLib/QemuBootOrderLib.c b/OvmfPkg/Library/QemuBootOrderLib/QemuBootOrderLib.c
index 2fe6ab3..2d697df 100644
--- a/OvmfPkg/Library/QemuBootOrderLib/QemuBootOrderLib.c
+++ b/OvmfPkg/Library/QemuBootOrderLib/QemuBootOrderLib.c
@@ -1794,7 +1794,7 @@ StoreQemuBootOrder (
       UnicodeSPrint (
         VariableName,
         sizeof (VariableName),
-        L"VMMBootOrder%04x",
+        L"BootOrder%04x",
         VariableIndex++
         );
       DEBUG ((DEBUG_INFO, "%a: %s = %s\n", __func__, VariableName, Translated));
diff --git a/OvmfPkg/QemuVideoDxe/Driver.c b/OvmfPkg/QemuVideoDxe/Driver.c
index 6feca83..a8d3313 100644
--- a/OvmfPkg/QemuVideoDxe/Driver.c
+++ b/OvmfPkg/QemuVideoDxe/Driver.c
@@ -41,31 +41,31 @@ QEMU_VIDEO_CARD  gQemuVideoCardList[] = {
     L"Cirrus 5446"
   },{
     PCI_CLASS_DISPLAY_VGA,
-    0x1234,
+    0x1022, //0x1234,
     0x1111,
     QEMU_VIDEO_BOCHS_MMIO,
     L"QEMU Standard VGA"
   },{
     PCI_CLASS_DISPLAY_OTHER,
-    0x1234,
+    0x1022, //0x1234,
     0x1111,
     QEMU_VIDEO_BOCHS_MMIO,
     L"QEMU Standard VGA (secondary)"
   },{
     PCI_CLASS_DISPLAY_VGA,
-    0x1b36,
+    0x1022, //0x1b36,
     0x0100,
     QEMU_VIDEO_BOCHS,
     L"QEMU QXL VGA"
   },{
     PCI_CLASS_DISPLAY_VGA,
-    0x1af4,
-    0x1050,
+    0x1022, //0x1af4,
+    0x1022, //0x1050, - TODO: Replace with correct AMD version
     QEMU_VIDEO_BOCHS_MMIO,
     L"QEMU VirtIO VGA"
   },{
     PCI_CLASS_DISPLAY_VGA,
-    0x15ad,
+    0x1022, //0x15ad,
     0x0405,
     QEMU_VIDEO_VMWARE_SVGA,
     L"QEMU VMWare SVGA"
diff --git a/OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c b/OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c
index e929da6..026d3e9 100644
--- a/OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c
+++ b/OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c
@@ -38,9 +38,15 @@ STATIC CONST SMBIOS_TABLE_TYPE0  mOvmfDefaultType0 = {
   },
   {      // BIOSCharacteristicsExtensionBytes[2]
     0,   // BiosReserved
-    0x1C // SystemReserved = VirtualMachineSupported |
-    //                  UefiSpecificationSupported |
-    //                  TargetContentDistributionEnabled
+    0x0D // SystemReserved = Hex2Binary = 0b00001101
+    //                       Bit0 = BIOS Boot Specification supported - 1 (Yes)
+    //                       Bit1 = Function key-initiated Network Service boot supported - 0 (No)
+    //                       Bit2 = Enable Targeted Content Distribution - 1 (Yes)
+    //                       Bit3 = UEFI Specification is supported - 1 (Yes)
+    //                       Bit4 = SMBIOS table describes a virtual machine - 0 (No)
+    //                       Bit5 = Manufacturing mode is supported. - 0 (No)
+    //                       Bit6 = Manufacturing mode is enabled. - 0 (No)
+    //                       Bit7 = Reserved for future assignment by this specification. - 0 (No)
   },
   0,     // UINT8                     SystemBiosMajorRelease
   0,     // UINT8                     SystemBiosMinorRelease
diff --git a/ShellPkg/ShellPkg.dec b/ShellPkg/ShellPkg.dec
index 45954fc..08c4315 100644
--- a/ShellPkg/ShellPkg.dec
+++ b/ShellPkg/ShellPkg.dec
@@ -120,7 +120,7 @@
   gEfiShellPkgTokenSpaceGuid.PcdShellScreenLogCount|3|UINT8|0x00000008
 
   ## Unicode string of the shell supplier
-  gEfiShellPkgTokenSpaceGuid.PcdShellSupplier|L"EDK II"|VOID*|0x00000010
+  gEfiShellPkgTokenSpaceGuid.PcdShellSupplier|L"American Megatrends"|VOID*|0x00000010
 
   ## Do extended decode of USB for determining media type
   gEfiShellPkgTokenSpaceGuid.PcdUsbExtendedDecode|TRUE|BOOLEAN|0x00000011
diff --git a/UefiCpuPkg/Library/CpuExceptionHandlerLib/X64/ExceptionHandlerAsm.nasm b/UefiCpuPkg/Library/CpuExceptionHandlerLib/X64/ExceptionHandlerAsm.nasm
index 3d64ac9..9c3f01a 100644
--- a/UefiCpuPkg/Library/CpuExceptionHandlerLib/X64/ExceptionHandlerAsm.nasm
+++ b/UefiCpuPkg/Library/CpuExceptionHandlerLib/X64/ExceptionHandlerAsm.nasm
@@ -57,7 +57,7 @@ ALIGN   8
 AsmIdtVectorBegin:
 %assign Vector 0
 %rep  256
-    push    strict dword %[Vector] ; This instruction pushes sign-extended 8-byte value on stack
+    push    strict qword %[Vector] ; This instruction pushes sign-extended 8-byte value on stack
     push    rax
 %ifdef NO_ABSOLUTE_RELOCS_IN_TEXT
     mov     rax, strict qword 0    ; mov     rax, ASM_PFX(CommonInterruptEntry)
@@ -70,7 +70,7 @@ AsmIdtVectorBegin:
 AsmIdtVectorEnd:
 
 HookAfterStubHeaderBegin:
-    push    strict dword 0      ; 0 will be fixed
+    push    strict qword 0      ; 0 will be fixed
 VectorNum:
     push    rax
 %ifdef NO_ABSOLUTE_RELOCS_IN_TEXT

```

`patches/EDK2/Archive/intel-edk2-stable202505.patch`:

```patch
diff --git a/MdeModulePkg/MdeModulePkg.dec b/MdeModulePkg/MdeModulePkg.dec
index 3698caf..16201f1 100644
--- a/MdeModulePkg/MdeModulePkg.dec
+++ b/MdeModulePkg/MdeModulePkg.dec
@@ -1884,7 +1884,7 @@
 
   ## Null-terminated Unicode string of the firmware vendor name that is the default name filled into the EFI System Table.
   # @Prompt Firmware vendor.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareVendor|L"EDK II"|VOID*|0x00010050
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareVendor|L"Intel Corporation"|VOID*|0x00010050
 
   ## Firmware revision that is the default revision filled into the EFI System Table.
   # @Prompt Firmware revision.
@@ -2120,7 +2120,7 @@
   #  The OEM assigns each dissimilar table a new OEM Table ID.
   #  This PCD is ignored for definition block.
   # @Prompt Default OEM Table ID for ACPI table creation.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemTableId|0x20202020324B4445|UINT64|0x30001035
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemTableId|0x2020207076525F55|UINT64|0x30001035
 
   ## Default OEM Revision for ACPI table creation.
   #  According to ACPI specification, for LoadTable() opcode, the OS can also
diff --git a/OvmfPkg/Bhyve/AcpiTables/Dsdt.asl b/OvmfPkg/Bhyve/AcpiTables/Dsdt.asl
index 17e2cf6..d5399e2 100644
--- a/OvmfPkg/Bhyve/AcpiTables/Dsdt.asl
+++ b/OvmfPkg/Bhyve/AcpiTables/Dsdt.asl
@@ -22,7 +22,7 @@
  *     Compiler ID      "INTL"
  *     Compiler Version 0x20150204 (538247684)
  */
-DefinitionBlock ("DSDT.aml", "DSDT", 2, "BHYVE", "BVDSDT", 0x00000001)
+DefinitionBlock ("DSDT.aml", "DSDT", 2, "INTEL ", "U Rvp   ", 0x00000001)
 {
     Name (_S5, Package (0x02)
     {
diff --git a/OvmfPkg/Bhyve/AcpiTables/Facp.aslc b/OvmfPkg/Bhyve/AcpiTables/Facp.aslc
index b3d703e..aa96ef7 100644
--- a/OvmfPkg/Bhyve/AcpiTables/Facp.aslc
+++ b/OvmfPkg/Bhyve/AcpiTables/Facp.aslc
@@ -7,7 +7,7 @@
 
 #include "Platform.h"
 
-#define EFI_ACPI_OEM_TABLE_ID     SIGNATURE_64('B','V','F','A','C','P',' ',' ')
+#define EFI_ACPI_OEM_TABLE_ID     SIGNATURE_64('U',' ','R','v','p',' ',' ',' ')
 
 EFI_ACPI_3_0_FIXED_ACPI_DESCRIPTION_TABLE FACP = {
   {
diff --git a/OvmfPkg/Bhyve/AcpiTables/Hpet.aslc b/OvmfPkg/Bhyve/AcpiTables/Hpet.aslc
index 73bb784..c9fb296 100644
--- a/OvmfPkg/Bhyve/AcpiTables/Hpet.aslc
+++ b/OvmfPkg/Bhyve/AcpiTables/Hpet.aslc
@@ -10,7 +10,7 @@
 #include "Platform.h"
 
 #define EFI_ACPI_HPET_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('H', 'P', 'E', 'T')
-#define EFI_ACPI_OEM_TABLE_ID                      SIGNATURE_64('B','V','H','P','E','T',' ',' ')
+#define EFI_ACPI_OEM_TABLE_ID                      SIGNATURE_64('U',' ','R','v','p',' ',' ',' ')
 
 //
 // Ensure proper structure formats
diff --git a/OvmfPkg/Bhyve/AcpiTables/Madt.aslc b/OvmfPkg/Bhyve/AcpiTables/Madt.aslc
index e8e956e..7defe23 100644
--- a/OvmfPkg/Bhyve/AcpiTables/Madt.aslc
+++ b/OvmfPkg/Bhyve/AcpiTables/Madt.aslc
@@ -15,7 +15,7 @@
 #include <IndustryStandard/Acpi.h>
 #include <Platform.h>
 
-#define EFI_ACPI_OEM_TABLE_ID                      SIGNATURE_64('B','V','M','A','D','T',' ',' ')
+#define EFI_ACPI_OEM_TABLE_ID                      SIGNATURE_64('U',' ','R','v','p',' ',' ',' ')
 
 //
 // Local APIC address
diff --git a/OvmfPkg/Bhyve/AcpiTables/Mcfg.aslc b/OvmfPkg/Bhyve/AcpiTables/Mcfg.aslc
index 62a98d3..048f043 100644
--- a/OvmfPkg/Bhyve/AcpiTables/Mcfg.aslc
+++ b/OvmfPkg/Bhyve/AcpiTables/Mcfg.aslc
@@ -7,7 +7,7 @@
 
 #include "Platform.h"
 
-#define EFI_ACPI_OEM_TABLE_ID                      SIGNATURE_64('B','V','M','C','F','G',' ',' ')
+#define EFI_ACPI_OEM_TABLE_ID                      SIGNATURE_64('U',' ','R','v','p',' ',' ',' ')
 
 #pragma pack(1)
 
diff --git a/OvmfPkg/Bhyve/AcpiTables/Platform.h b/OvmfPkg/Bhyve/AcpiTables/Platform.h
index 4561adc..e515642 100644
--- a/OvmfPkg/Bhyve/AcpiTables/Platform.h
+++ b/OvmfPkg/Bhyve/AcpiTables/Platform.h
@@ -20,9 +20,9 @@
 //
 // ACPI table information used to initialize tables.
 //
-#define EFI_ACPI_OEM_ID            'B','H','Y','V','E',' '  // OEMID 6 bytes long
+#define EFI_ACPI_OEM_ID            'I','N','T','E','L',' '  // OEMID 6 bytes long
 #define EFI_ACPI_OEM_REVISION      0x1
-#define EFI_ACPI_CREATOR_ID        SIGNATURE_32('B','H','Y','V')
+#define EFI_ACPI_CREATOR_ID        SIGNATURE_32('I','N','T','L')
 #define EFI_ACPI_CREATOR_REVISION  0x00000001
 
 #define INT_MODEL        0x01
diff --git a/OvmfPkg/Bhyve/AcpiTables/Spcr.aslc b/OvmfPkg/Bhyve/AcpiTables/Spcr.aslc
index ec5114a..24e1a21 100644
--- a/OvmfPkg/Bhyve/AcpiTables/Spcr.aslc
+++ b/OvmfPkg/Bhyve/AcpiTables/Spcr.aslc
@@ -7,7 +7,7 @@
 
 #include "Platform.h"
 
-#define EFI_ACPI_OEM_TABLE_ID     SIGNATURE_64('B','V','S','P','C','R',' ',' ')
+#define EFI_ACPI_OEM_TABLE_ID     SIGNATURE_64('U',' ','R','v','p',' ',' ',' ')
 
 EFI_ACPI_SERIAL_PORT_CONSOLE_REDIRECTION_TABLE SPCR = {
   {
diff --git a/OvmfPkg/Bhyve/BhyveRfbDxe/VbeShim.c b/OvmfPkg/Bhyve/BhyveRfbDxe/VbeShim.c
index ea7a364..b355725 100644
--- a/OvmfPkg/Bhyve/BhyveRfbDxe/VbeShim.c
+++ b/OvmfPkg/Bhyve/BhyveRfbDxe/VbeShim.c
@@ -203,11 +203,11 @@ InstallVbeShim (
   VbeInfo     = &VbeInfoFull->Base;
   Ptr         = VbeInfoFull->Buffer;
 
-  CopyMem (VbeInfo->Signature, "VESA", 4);
+  CopyMem (VbeInfo->Signature, "VUSA", 4);
   VbeInfo->VesaVersion = 0x0200;
 
   VbeInfo->OemNameAddress = (UINT32)SegmentC << 12 | (UINT16)((UINTN)Ptr-SegmentC);
-  CopyMem (Ptr, "FBSD", 5);
+  CopyMem (Ptr, "UEFI", 5);
   Ptr += 5;
 
   VbeInfo->Capabilities = BIT1 | BIT0; // DAC can be switched into 8-bit mode
diff --git a/OvmfPkg/Bhyve/BhyveX64.dsc b/OvmfPkg/Bhyve/BhyveX64.dsc
index 5aab790..2271032 100644
--- a/OvmfPkg/Bhyve/BhyveX64.dsc
+++ b/OvmfPkg/Bhyve/BhyveX64.dsc
@@ -519,7 +519,7 @@
 
   gEfiMdeModulePkgTokenSpaceGuid.PcdConInConnectOnDemand|FALSE
 
-  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareVendor|L"BHYVE"
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareVendor|L"INTEL "
   gUefiOvmfPkgTokenSpaceGuid.PcdDebugIoPort|0x2F8
 
 ################################################################################
diff --git a/OvmfPkg/Bhyve/SmbiosPlatformDxe/SmbiosPlatformDxe.c b/OvmfPkg/Bhyve/SmbiosPlatformDxe/SmbiosPlatformDxe.c
index ba21393..ae21b82 100644
--- a/OvmfPkg/Bhyve/SmbiosPlatformDxe/SmbiosPlatformDxe.c
+++ b/OvmfPkg/Bhyve/SmbiosPlatformDxe/SmbiosPlatformDxe.c
@@ -12,9 +12,9 @@
 #include "SmbiosPlatformDxe.h"
 
 #define TYPE0_STRINGS \
-  "EFI Development Kit II / OVMF\0"     /* Vendor */ \
-  "0.0.0\0"                             /* BiosVersion */ \
-  "02/06/2015\0"                        /* BiosReleaseDate */
+  "Intel Corporation\0"   /* Vendor */ \
+  "1.C0\0"                /* BiosVersion */ \
+  "02/06/2024\0"          /* BiosReleaseDate */
 //
 // Type definition and contents of the default Type 0 SMBIOS table.
 //
diff --git a/OvmfPkg/Include/IndustryStandard/Q35MchIch9.h b/OvmfPkg/Include/IndustryStandard/Q35MchIch9.h
index db828d3..ad00b17 100644
--- a/OvmfPkg/Include/IndustryStandard/Q35MchIch9.h
+++ b/OvmfPkg/Include/IndustryStandard/Q35MchIch9.h
@@ -20,7 +20,7 @@
 //
 // Host Bridge Device ID (DID) value for Q35/MCH
 //
-#define INTEL_Q35_MCH_DEVICE_ID  0x29C0
+#define INTEL_Q35_MCH_DEVICE_ID  0x4641 // Intel G33/P35/Q35/Q33 Chipset - Memory Controller Hub [A0] | Intel Vendor ID Replacement from 0x29c0 | hw/pci-host/q35.c
 
 //
 // B/D/F/Type: 0/0/0/PCI
diff --git a/OvmfPkg/Include/IndustryStandard/QemuPciBridgeCapabilities.h b/OvmfPkg/Include/IndustryStandard/QemuPciBridgeCapabilities.h
index a70b99f..4b1db74 100644
--- a/OvmfPkg/Include/IndustryStandard/QemuPciBridgeCapabilities.h
+++ b/OvmfPkg/Include/IndustryStandard/QemuPciBridgeCapabilities.h
@@ -18,7 +18,7 @@
 // The hints apply to PCI Bridges whose PCI_DEVICE_INDEPENDENT_REGION.VendorId
 // equals the following value.
 //
-#define QEMU_PCI_BRIDGE_VENDOR_ID_REDHAT  0x1B36
+#define QEMU_PCI_BRIDGE_VENDOR_ID_REDHAT  0x8086 // "Red Hat, Inc." | AMD Vendor ID Replacement from 0x1b36
 
 //
 // Common capability header for all hints.
diff --git a/OvmfPkg/QemuVideoDxe/Driver.c b/OvmfPkg/QemuVideoDxe/Driver.c
index 6feca83..94dfb3e 100644
--- a/OvmfPkg/QemuVideoDxe/Driver.c
+++ b/OvmfPkg/QemuVideoDxe/Driver.c
@@ -41,31 +41,31 @@ QEMU_VIDEO_CARD  gQemuVideoCardList[] = {
     L"Cirrus 5446"
   },{
     PCI_CLASS_DISPLAY_VGA,
-    0x1234,
+    0x8086, // 0x1234,
     0x1111,
     QEMU_VIDEO_BOCHS_MMIO,
     L"QEMU Standard VGA"
   },{
     PCI_CLASS_DISPLAY_OTHER,
-    0x1234,
+    0x8086, // 0x1234,
     0x1111,
     QEMU_VIDEO_BOCHS_MMIO,
     L"QEMU Standard VGA (secondary)"
   },{
     PCI_CLASS_DISPLAY_VGA,
-    0x1b36,
+    0x8086, // 0x1b36,
     0x0100,
     QEMU_VIDEO_BOCHS,
     L"QEMU QXL VGA"
   },{
     PCI_CLASS_DISPLAY_VGA,
-    0x1af4,
-    0x1050,
+    0x8086, // 0x1af4,
+    0x0416, // 0x1050,
     QEMU_VIDEO_BOCHS_MMIO,
     L"QEMU VirtIO VGA"
   },{
     PCI_CLASS_DISPLAY_VGA,
-    0x15ad,
+    0x8086, // 0x15ad,
     0x0405,
     QEMU_VIDEO_VMWARE_SVGA,
     L"QEMU VMWare SVGA"
diff --git a/OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c b/OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c
index e929da6..026d3e9 100644
--- a/OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c
+++ b/OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c
@@ -38,9 +38,15 @@ STATIC CONST SMBIOS_TABLE_TYPE0  mOvmfDefaultType0 = {
   },
   {      // BIOSCharacteristicsExtensionBytes[2]
     0,   // BiosReserved
-    0x1C // SystemReserved = VirtualMachineSupported |
-    //                  UefiSpecificationSupported |
-    //                  TargetContentDistributionEnabled
+    0x0D // SystemReserved = Hex2Binary = 0b00001101
+    //                       Bit0 = BIOS Boot Specification supported - 1 (Yes)
+    //                       Bit1 = Function key-initiated Network Service boot supported - 0 (No)
+    //                       Bit2 = Enable Targeted Content Distribution - 1 (Yes)
+    //                       Bit3 = UEFI Specification is supported - 1 (Yes)
+    //                       Bit4 = SMBIOS table describes a virtual machine - 0 (No)
+    //                       Bit5 = Manufacturing mode is supported. - 0 (No)
+    //                       Bit6 = Manufacturing mode is enabled. - 0 (No)
+    //                       Bit7 = Reserved for future assignment by this specification. - 0 (No)
   },
   0,     // UINT8                     SystemBiosMajorRelease
   0,     // UINT8                     SystemBiosMinorRelease
diff --git a/ShellPkg/ShellPkg.dec b/ShellPkg/ShellPkg.dec
index 18df262..1b26ff0 100644
--- a/ShellPkg/ShellPkg.dec
+++ b/ShellPkg/ShellPkg.dec
@@ -123,7 +123,7 @@
   gEfiShellPkgTokenSpaceGuid.PcdShellScreenLogCount|3|UINT8|0x00000008
 
   ## Unicode string of the shell supplier
-  gEfiShellPkgTokenSpaceGuid.PcdShellSupplier|L"EDK II"|VOID*|0x00000010
+  gEfiShellPkgTokenSpaceGuid.PcdShellSupplier|L"Intel Corporation"|VOID*|0x00000010
 
   ## Do extended decode of USB for determining media type
   gEfiShellPkgTokenSpaceGuid.PcdUsbExtendedDecode|TRUE|BOOLEAN|0x00000011

```

`patches/EDK2/Archive/intel-edk2-stable202508.patch`:

```patch
diff --git a/MdeModulePkg/MdeModulePkg.dec b/MdeModulePkg/MdeModulePkg.dec
index 24cc64f..92653fa 100644
--- a/MdeModulePkg/MdeModulePkg.dec
+++ b/MdeModulePkg/MdeModulePkg.dec
@@ -1878,7 +1878,7 @@
 
   ## Null-terminated Unicode string of the firmware vendor name that is the default name filled into the EFI System Table.
   # @Prompt Firmware vendor.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareVendor|L"EDK II"|VOID*|0x00010050
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareVendor|L"Intel Corporation"|VOID*|0x00010050
 
   ## Firmware revision that is the default revision filled into the EFI System Table.
   # @Prompt Firmware revision.
@@ -2114,7 +2114,7 @@
   #  The OEM assigns each dissimilar table a new OEM Table ID.
   #  This PCD is ignored for definition block.
   # @Prompt Default OEM Table ID for ACPI table creation.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemTableId|0x20202020324B4445|UINT64|0x30001035
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemTableId|0x2020207076525F55|UINT64|0x30001035
 
   ## Default OEM Revision for ACPI table creation.
   #  According to ACPI specification, for LoadTable() opcode, the OS can also
diff --git a/OvmfPkg/Bhyve/AcpiTables/Dsdt.asl b/OvmfPkg/Bhyve/AcpiTables/Dsdt.asl
index 17e2cf6..d5399e2 100644
--- a/OvmfPkg/Bhyve/AcpiTables/Dsdt.asl
+++ b/OvmfPkg/Bhyve/AcpiTables/Dsdt.asl
@@ -22,7 +22,7 @@
  *     Compiler ID      "INTL"
  *     Compiler Version 0x20150204 (538247684)
  */
-DefinitionBlock ("DSDT.aml", "DSDT", 2, "BHYVE", "BVDSDT", 0x00000001)
+DefinitionBlock ("DSDT.aml", "DSDT", 2, "INTEL ", "U Rvp   ", 0x00000001)
 {
     Name (_S5, Package (0x02)
     {
diff --git a/OvmfPkg/Bhyve/AcpiTables/Facp.aslc b/OvmfPkg/Bhyve/AcpiTables/Facp.aslc
index b3d703e..aa96ef7 100644
--- a/OvmfPkg/Bhyve/AcpiTables/Facp.aslc
+++ b/OvmfPkg/Bhyve/AcpiTables/Facp.aslc
@@ -7,7 +7,7 @@
 
 #include "Platform.h"
 
-#define EFI_ACPI_OEM_TABLE_ID     SIGNATURE_64('B','V','F','A','C','P',' ',' ')
+#define EFI_ACPI_OEM_TABLE_ID     SIGNATURE_64('U',' ','R','v','p',' ',' ',' ')
 
 EFI_ACPI_3_0_FIXED_ACPI_DESCRIPTION_TABLE FACP = {
   {
diff --git a/OvmfPkg/Bhyve/AcpiTables/Hpet.aslc b/OvmfPkg/Bhyve/AcpiTables/Hpet.aslc
index 73bb784..c9fb296 100644
--- a/OvmfPkg/Bhyve/AcpiTables/Hpet.aslc
+++ b/OvmfPkg/Bhyve/AcpiTables/Hpet.aslc
@@ -10,7 +10,7 @@
 #include "Platform.h"
 
 #define EFI_ACPI_HPET_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('H', 'P', 'E', 'T')
-#define EFI_ACPI_OEM_TABLE_ID                      SIGNATURE_64('B','V','H','P','E','T',' ',' ')
+#define EFI_ACPI_OEM_TABLE_ID                      SIGNATURE_64('U',' ','R','v','p',' ',' ',' ')
 
 //
 // Ensure proper structure formats
diff --git a/OvmfPkg/Bhyve/AcpiTables/Madt.aslc b/OvmfPkg/Bhyve/AcpiTables/Madt.aslc
index e8e956e..7defe23 100644
--- a/OvmfPkg/Bhyve/AcpiTables/Madt.aslc
+++ b/OvmfPkg/Bhyve/AcpiTables/Madt.aslc
@@ -15,7 +15,7 @@
 #include <IndustryStandard/Acpi.h>
 #include <Platform.h>
 
-#define EFI_ACPI_OEM_TABLE_ID                      SIGNATURE_64('B','V','M','A','D','T',' ',' ')
+#define EFI_ACPI_OEM_TABLE_ID                      SIGNATURE_64('U',' ','R','v','p',' ',' ',' ')
 
 //
 // Local APIC address
diff --git a/OvmfPkg/Bhyve/AcpiTables/Mcfg.aslc b/OvmfPkg/Bhyve/AcpiTables/Mcfg.aslc
index 62a98d3..048f043 100644
--- a/OvmfPkg/Bhyve/AcpiTables/Mcfg.aslc
+++ b/OvmfPkg/Bhyve/AcpiTables/Mcfg.aslc
@@ -7,7 +7,7 @@
 
 #include "Platform.h"
 
-#define EFI_ACPI_OEM_TABLE_ID                      SIGNATURE_64('B','V','M','C','F','G',' ',' ')
+#define EFI_ACPI_OEM_TABLE_ID                      SIGNATURE_64('U',' ','R','v','p',' ',' ',' ')
 
 #pragma pack(1)
 
diff --git a/OvmfPkg/Bhyve/AcpiTables/Platform.h b/OvmfPkg/Bhyve/AcpiTables/Platform.h
index 4561adc..e515642 100644
--- a/OvmfPkg/Bhyve/AcpiTables/Platform.h
+++ b/OvmfPkg/Bhyve/AcpiTables/Platform.h
@@ -20,9 +20,9 @@
 //
 // ACPI table information used to initialize tables.
 //
-#define EFI_ACPI_OEM_ID            'B','H','Y','V','E',' '  // OEMID 6 bytes long
+#define EFI_ACPI_OEM_ID            'I','N','T','E','L',' '  // OEMID 6 bytes long
 #define EFI_ACPI_OEM_REVISION      0x1
-#define EFI_ACPI_CREATOR_ID        SIGNATURE_32('B','H','Y','V')
+#define EFI_ACPI_CREATOR_ID        SIGNATURE_32('I','N','T','L')
 #define EFI_ACPI_CREATOR_REVISION  0x00000001
 
 #define INT_MODEL        0x01
diff --git a/OvmfPkg/Bhyve/AcpiTables/Spcr.aslc b/OvmfPkg/Bhyve/AcpiTables/Spcr.aslc
index ec5114a..24e1a21 100644
--- a/OvmfPkg/Bhyve/AcpiTables/Spcr.aslc
+++ b/OvmfPkg/Bhyve/AcpiTables/Spcr.aslc
@@ -7,7 +7,7 @@
 
 #include "Platform.h"
 
-#define EFI_ACPI_OEM_TABLE_ID     SIGNATURE_64('B','V','S','P','C','R',' ',' ')
+#define EFI_ACPI_OEM_TABLE_ID     SIGNATURE_64('U',' ','R','v','p',' ',' ',' ')
 
 EFI_ACPI_SERIAL_PORT_CONSOLE_REDIRECTION_TABLE SPCR = {
   {
diff --git a/OvmfPkg/Bhyve/BhyveRfbDxe/VbeShim.c b/OvmfPkg/Bhyve/BhyveRfbDxe/VbeShim.c
index ea7a364..b355725 100644
--- a/OvmfPkg/Bhyve/BhyveRfbDxe/VbeShim.c
+++ b/OvmfPkg/Bhyve/BhyveRfbDxe/VbeShim.c
@@ -203,11 +203,11 @@ InstallVbeShim (
   VbeInfo     = &VbeInfoFull->Base;
   Ptr         = VbeInfoFull->Buffer;
 
-  CopyMem (VbeInfo->Signature, "VESA", 4);
+  CopyMem (VbeInfo->Signature, "VUSA", 4);
   VbeInfo->VesaVersion = 0x0200;
 
   VbeInfo->OemNameAddress = (UINT32)SegmentC << 12 | (UINT16)((UINTN)Ptr-SegmentC);
-  CopyMem (Ptr, "FBSD", 5);
+  CopyMem (Ptr, "UEFI", 5);
   Ptr += 5;
 
   VbeInfo->Capabilities = BIT1 | BIT0; // DAC can be switched into 8-bit mode
diff --git a/OvmfPkg/Bhyve/BhyveX64.dsc b/OvmfPkg/Bhyve/BhyveX64.dsc
index 131f16f..e4817c2 100644
--- a/OvmfPkg/Bhyve/BhyveX64.dsc
+++ b/OvmfPkg/Bhyve/BhyveX64.dsc
@@ -519,7 +519,7 @@
 
   gEfiMdeModulePkgTokenSpaceGuid.PcdConInConnectOnDemand|FALSE
 
-  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareVendor|L"BHYVE"
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareVendor|L"INTEL "
   gUefiOvmfPkgTokenSpaceGuid.PcdDebugIoPort|0x2F8
 
 ################################################################################
diff --git a/OvmfPkg/Bhyve/SmbiosPlatformDxe/SmbiosPlatformDxe.c b/OvmfPkg/Bhyve/SmbiosPlatformDxe/SmbiosPlatformDxe.c
index ba21393..ae21b82 100644
--- a/OvmfPkg/Bhyve/SmbiosPlatformDxe/SmbiosPlatformDxe.c
+++ b/OvmfPkg/Bhyve/SmbiosPlatformDxe/SmbiosPlatformDxe.c
@@ -12,9 +12,9 @@
 #include "SmbiosPlatformDxe.h"
 
 #define TYPE0_STRINGS \
-  "EFI Development Kit II / OVMF\0"     /* Vendor */ \
-  "0.0.0\0"                             /* BiosVersion */ \
-  "02/06/2015\0"                        /* BiosReleaseDate */
+  "Intel Corporation\0"   /* Vendor */ \
+  "1.C0\0"                /* BiosVersion */ \
+  "02/06/2024\0"          /* BiosReleaseDate */
 //
 // Type definition and contents of the default Type 0 SMBIOS table.
 //
diff --git a/OvmfPkg/Include/IndustryStandard/Q35MchIch9.h b/OvmfPkg/Include/IndustryStandard/Q35MchIch9.h
index db828d3..86a9e0b 100644
--- a/OvmfPkg/Include/IndustryStandard/Q35MchIch9.h
+++ b/OvmfPkg/Include/IndustryStandard/Q35MchIch9.h
@@ -20,7 +20,7 @@
 //
 // Host Bridge Device ID (DID) value for Q35/MCH
 //
-#define INTEL_Q35_MCH_DEVICE_ID  0x29C0
+#define INTEL_Q35_MCH_DEVICE_ID  0x4641 // Intel G33/P35/Q35/Q33 Chipset - Memory Controller Hub [A0] | Intel Vendor ID Replacement from 0x29c0 | hw/pci-host/q35.c
 
 //
 // B/D/F/Type: 0/0/0/PCI
diff --git a/OvmfPkg/Include/IndustryStandard/QemuPciBridgeCapabilities.h b/OvmfPkg/Include/IndustryStandard/QemuPciBridgeCapabilities.h
index a70b99f..21b697e 100644
--- a/OvmfPkg/Include/IndustryStandard/QemuPciBridgeCapabilities.h
+++ b/OvmfPkg/Include/IndustryStandard/QemuPciBridgeCapabilities.h
@@ -18,7 +18,7 @@
 // The hints apply to PCI Bridges whose PCI_DEVICE_INDEPENDENT_REGION.VendorId
 // equals the following value.
 //
-#define QEMU_PCI_BRIDGE_VENDOR_ID_REDHAT  0x1B36
+#define QEMU_PCI_BRIDGE_VENDOR_ID_REDHAT  0x8086 // "Red Hat, Inc." | AMD Vendor ID Replacement from 0x1b36
 
 //
 // Common capability header for all hints.
diff --git a/OvmfPkg/Library/QemuBootOrderLib/QemuBootOrderLib.c b/OvmfPkg/Library/QemuBootOrderLib/QemuBootOrderLib.c
index 2fe6ab3..2d697df 100644
--- a/OvmfPkg/Library/QemuBootOrderLib/QemuBootOrderLib.c
+++ b/OvmfPkg/Library/QemuBootOrderLib/QemuBootOrderLib.c
@@ -1794,7 +1794,7 @@ StoreQemuBootOrder (
       UnicodeSPrint (
         VariableName,
         sizeof (VariableName),
-        L"VMMBootOrder%04x",
+        L"BootOrder%04x",
         VariableIndex++
         );
       DEBUG ((DEBUG_INFO, "%a: %s = %s\n", __func__, VariableName, Translated));
diff --git a/OvmfPkg/QemuVideoDxe/Driver.c b/OvmfPkg/QemuVideoDxe/Driver.c
index 6feca83..94dfb3e 100644
--- a/OvmfPkg/QemuVideoDxe/Driver.c
+++ b/OvmfPkg/QemuVideoDxe/Driver.c
@@ -41,31 +41,31 @@ QEMU_VIDEO_CARD  gQemuVideoCardList[] = {
     L"Cirrus 5446"
   },{
     PCI_CLASS_DISPLAY_VGA,
-    0x1234,
+    0x8086, // 0x1234,
     0x1111,
     QEMU_VIDEO_BOCHS_MMIO,
     L"QEMU Standard VGA"
   },{
     PCI_CLASS_DISPLAY_OTHER,
-    0x1234,
+    0x8086, // 0x1234,
     0x1111,
     QEMU_VIDEO_BOCHS_MMIO,
     L"QEMU Standard VGA (secondary)"
   },{
     PCI_CLASS_DISPLAY_VGA,
-    0x1b36,
+    0x8086, // 0x1b36,
     0x0100,
     QEMU_VIDEO_BOCHS,
     L"QEMU QXL VGA"
   },{
     PCI_CLASS_DISPLAY_VGA,
-    0x1af4,
-    0x1050,
+    0x8086, // 0x1af4,
+    0x0416, // 0x1050,
     QEMU_VIDEO_BOCHS_MMIO,
     L"QEMU VirtIO VGA"
   },{
     PCI_CLASS_DISPLAY_VGA,
-    0x15ad,
+    0x8086, // 0x15ad,
     0x0405,
     QEMU_VIDEO_VMWARE_SVGA,
     L"QEMU VMWare SVGA"
diff --git a/OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c b/OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c
index e929da6..026d3e9 100644
--- a/OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c
+++ b/OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c
@@ -38,9 +38,15 @@ STATIC CONST SMBIOS_TABLE_TYPE0  mOvmfDefaultType0 = {
   },
   {      // BIOSCharacteristicsExtensionBytes[2]
     0,   // BiosReserved
-    0x1C // SystemReserved = VirtualMachineSupported |
-    //                  UefiSpecificationSupported |
-    //                  TargetContentDistributionEnabled
+    0x0D // SystemReserved = Hex2Binary = 0b00001101
+    //                       Bit0 = BIOS Boot Specification supported - 1 (Yes)
+    //                       Bit1 = Function key-initiated Network Service boot supported - 0 (No)
+    //                       Bit2 = Enable Targeted Content Distribution - 1 (Yes)
+    //                       Bit3 = UEFI Specification is supported - 1 (Yes)
+    //                       Bit4 = SMBIOS table describes a virtual machine - 0 (No)
+    //                       Bit5 = Manufacturing mode is supported. - 0 (No)
+    //                       Bit6 = Manufacturing mode is enabled. - 0 (No)
+    //                       Bit7 = Reserved for future assignment by this specification. - 0 (No)
   },
   0,     // UINT8                     SystemBiosMajorRelease
   0,     // UINT8                     SystemBiosMinorRelease
diff --git a/ShellPkg/ShellPkg.dec b/ShellPkg/ShellPkg.dec
index 45954fc..e521908 100644
--- a/ShellPkg/ShellPkg.dec
+++ b/ShellPkg/ShellPkg.dec
@@ -120,7 +120,7 @@
   gEfiShellPkgTokenSpaceGuid.PcdShellScreenLogCount|3|UINT8|0x00000008
 
   ## Unicode string of the shell supplier
-  gEfiShellPkgTokenSpaceGuid.PcdShellSupplier|L"EDK II"|VOID*|0x00000010
+  gEfiShellPkgTokenSpaceGuid.PcdShellSupplier|L"Intel Corporation"|VOID*|0x00000010
 
   ## Do extended decode of USB for determining media type
   gEfiShellPkgTokenSpaceGuid.PcdUsbExtendedDecode|TRUE|BOOLEAN|0x00000011
diff --git a/UefiCpuPkg/Library/CpuExceptionHandlerLib/X64/ExceptionHandlerAsm.nasm b/UefiCpuPkg/Library/CpuExceptionHandlerLib/X64/ExceptionHandlerAsm.nasm
index 3d64ac9..9c3f01a 100644
--- a/UefiCpuPkg/Library/CpuExceptionHandlerLib/X64/ExceptionHandlerAsm.nasm
+++ b/UefiCpuPkg/Library/CpuExceptionHandlerLib/X64/ExceptionHandlerAsm.nasm
@@ -57,7 +57,7 @@ ALIGN   8
 AsmIdtVectorBegin:
 %assign Vector 0
 %rep  256
-    push    strict dword %[Vector] ; This instruction pushes sign-extended 8-byte value on stack
+    push    strict qword %[Vector] ; This instruction pushes sign-extended 8-byte value on stack
     push    rax
 %ifdef NO_ABSOLUTE_RELOCS_IN_TEXT
     mov     rax, strict qword 0    ; mov     rax, ASM_PFX(CommonInterruptEntry)
@@ -70,7 +70,7 @@ AsmIdtVectorBegin:
 AsmIdtVectorEnd:
 
 HookAfterStubHeaderBegin:
-    push    strict dword 0      ; 0 will be fixed
+    push    strict qword 0      ; 0 will be fixed
 VectorNum:
     push    rax
 %ifdef NO_ABSOLUTE_RELOCS_IN_TEXT

```

`patches/EDK2/Intel-edk2-stable202602.patch`:

```patch
diff --git a/MdeModulePkg/MdeModulePkg.dec b/MdeModulePkg/MdeModulePkg.dec
index 9e2c607..c02f63e 100644
--- a/MdeModulePkg/MdeModulePkg.dec
+++ b/MdeModulePkg/MdeModulePkg.dec
@@ -1910,19 +1910,19 @@
 
   ## Null-terminated Unicode string of the firmware vendor name that is the default name filled into the EFI System Table.
   # @Prompt Firmware vendor.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareVendor|L"EDK II"|VOID*|0x00010050
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareVendor|L"EDK II"|VOID*|0x00010050 # Dynamically modified via 'edk2.sh'
 
   ## Firmware revision that is the default revision filled into the EFI System Table.
   # @Prompt Firmware revision.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareRevision|0x00010000|UINT32|0x00010051
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareRevision|0x00010000|UINT32|0x00010051 # Dynamically modified via 'edk2.sh'
 
   ## Null-terminated Unicode string that describes the firmware version.
   # @Prompt Firmware version string.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareVersionString|L""|VOID*|0x00010052
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareVersionString|L""|VOID*|0x00010052 # Dynamically modified via 'edk2.sh'
 
   ## Null-terminated Unicode string that contains the date the firmware was released
   # @Prompt Firmware release data string.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareReleaseDateString|L""|VOID*|0x00010053
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareReleaseDateString|L""|VOID*|0x00010053 # Dynamically modified via 'edk2.sh'
 
   ## PcdStatusCodeMemorySize is used when PcdStatusCodeUseMemory is set to true.
   #  (PcdStatusCodeMemorySize * KBytes) is the total taken memory size.<BR><BR>
@@ -2138,7 +2138,7 @@
 
   ## Default OEM ID for ACPI table creation, its length must be 0x6 bytes to follow ACPI specification.
   # @Prompt Default OEM ID for ACPI table creation.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemId|"INTEL "|VOID*|0x30001034
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemId|"INTEL "|VOID*|0x30001034 # Dynamically modified via 'edk2.sh'
 
   ## Default OEM Table ID for ACPI table creation, it is "EDK2    ".
   #  According to ACPI specification, this field is particularly useful when
@@ -2146,7 +2146,7 @@
   #  The OEM assigns each dissimilar table a new OEM Table ID.
   #  This PCD is ignored for definition block.
   # @Prompt Default OEM Table ID for ACPI table creation.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemTableId|0x20202020324B4445|UINT64|0x30001035
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemTableId|0x2020207076525F55|UINT64|0x30001035 # Dynamically modified via 'edk2.sh'
 
   ## Default OEM Revision for ACPI table creation.
   #  According to ACPI specification, for LoadTable() opcode, the OS can also
@@ -2154,21 +2154,21 @@
   #  revision Definition Block of the same OEM Table ID and load it instead.
   #  This PCD is ignored for definition block.
   # @Prompt Default OEM Revision for ACPI table creation.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemRevision|0x00000002|UINT32|0x30001036
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemRevision|0x00000002|UINT32|0x30001036 # Dynamically modified via 'edk2.sh'
 
   ## Default Creator ID for ACPI table creation.
   #  According to ACPI specification, for tables containing Definition Blocks,
   #  this is the ID for the ASL Compiler.
   #  This PCD is ignored for definition block.
   # @Prompt Default Creator ID for ACPI table creation.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultCreatorId|0x20202020|UINT32|0x30001037
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultCreatorId|0x20202020|UINT32|0x30001037 # Dynamically modified via 'edk2.sh'
 
   ## Default Creator Revision for ACPI table creation.
   #  According to ACPI specification, for tables containing Definition Blocks,
   #  this is the revision for the ASL Compiler.
   #  This PCD is ignored for definition block.
   # @Prompt Default Creator Revision for ACPI table creation.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultCreatorRevision|0x01000013|UINT32|0x30001038
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultCreatorRevision|0x01000013|UINT32|0x30001038 # Dynamically modified via 'edk2.sh'
 
   ## Indicates if to set NX for stack.<BR><BR>
   #  For the DxeIpl and the DxeCore are both X64, set NX for stack feature also require PcdDxeIplBuildPageTables be TRUE.<BR>
diff --git a/OvmfPkg/Include/IndustryStandard/Q35MchIch9.h b/OvmfPkg/Include/IndustryStandard/Q35MchIch9.h
index db828d3..b958e41 100644
--- a/OvmfPkg/Include/IndustryStandard/Q35MchIch9.h
+++ b/OvmfPkg/Include/IndustryStandard/Q35MchIch9.h
@@ -20,7 +20,7 @@
 //
 // Host Bridge Device ID (DID) value for Q35/MCH
 //
-#define INTEL_Q35_MCH_DEVICE_ID  0x29C0
+#define INTEL_Q35_MCH_DEVICE_ID  0x4641 /* Host-to-PCI / Host bridge [0600] | hw/pci-host/q35.c */
 
 //
 // B/D/F/Type: 0/0/0/PCI
diff --git a/OvmfPkg/Include/IndustryStandard/QemuPciBridgeCapabilities.h b/OvmfPkg/Include/IndustryStandard/QemuPciBridgeCapabilities.h
index a70b99f..513fb8d 100644
--- a/OvmfPkg/Include/IndustryStandard/QemuPciBridgeCapabilities.h
+++ b/OvmfPkg/Include/IndustryStandard/QemuPciBridgeCapabilities.h
@@ -18,7 +18,7 @@
 // The hints apply to PCI Bridges whose PCI_DEVICE_INDEPENDENT_REGION.VendorId
 // equals the following value.
 //
-#define QEMU_PCI_BRIDGE_VENDOR_ID_REDHAT  0x1B36
+#define QEMU_PCI_BRIDGE_VENDOR_ID_REDHAT  0x8086 /* Red Hat QEMU devices */
 
 //
 // Common capability header for all hints.
diff --git a/OvmfPkg/Library/QemuBootOrderLib/QemuBootOrderLib.c b/OvmfPkg/Library/QemuBootOrderLib/QemuBootOrderLib.c
index 2fe6ab3..2d697df 100644
--- a/OvmfPkg/Library/QemuBootOrderLib/QemuBootOrderLib.c
+++ b/OvmfPkg/Library/QemuBootOrderLib/QemuBootOrderLib.c
@@ -1794,7 +1794,7 @@ StoreQemuBootOrder (
       UnicodeSPrint (
         VariableName,
         sizeof (VariableName),
-        L"VMMBootOrder%04x",
+        L"BootOrder%04x",
         VariableIndex++
         );
       DEBUG ((DEBUG_INFO, "%a: %s = %s\n", __func__, VariableName, Translated));
diff --git a/OvmfPkg/QemuVideoDxe/Driver.c b/OvmfPkg/QemuVideoDxe/Driver.c
index 6feca83..d37f212 100644
--- a/OvmfPkg/QemuVideoDxe/Driver.c
+++ b/OvmfPkg/QemuVideoDxe/Driver.c
@@ -41,19 +41,19 @@ QEMU_VIDEO_CARD  gQemuVideoCardList[] = {
     L"Cirrus 5446"
   },{
     PCI_CLASS_DISPLAY_VGA,
-    0x1234,
+    0x8086, // 0x1234,
     0x1111,
     QEMU_VIDEO_BOCHS_MMIO,
     L"QEMU Standard VGA"
   },{
     PCI_CLASS_DISPLAY_OTHER,
-    0x1234,
+    0x8086, // 0x1234,
     0x1111,
     QEMU_VIDEO_BOCHS_MMIO,
     L"QEMU Standard VGA (secondary)"
   },{
     PCI_CLASS_DISPLAY_VGA,
-    0x1b36,
+    0x8086, // 0x1b36,
     0x0100,
     QEMU_VIDEO_BOCHS,
     L"QEMU QXL VGA"
diff --git a/OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c b/OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c
index e929da6..56d68aa 100644
--- a/OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c
+++ b/OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c
@@ -38,9 +38,15 @@ STATIC CONST SMBIOS_TABLE_TYPE0  mOvmfDefaultType0 = {
   },
   {      // BIOSCharacteristicsExtensionBytes[2]
     0,   // BiosReserved
-    0x1C // SystemReserved = VirtualMachineSupported |
-    //                  UefiSpecificationSupported |
-    //                  TargetContentDistributionEnabled
+    0x0D // SystemReserved = Hexadecimal > Binary: 0D = 00001101
+         // Bit 0: BIOS Boot Specification supported - 1 (Yes)
+         // Bit 1: Function key-initiated Network Service boot supported - 0 (No)
+         // Bit 2: Enable Targeted Content Distribution - 1 (Yes)
+         // Bit 3: UEFI Specification is supported - 1 (Yes)
+         // Bit 4: SMBIOS table describes a virtual machine - 0 (No)
+         // Bit 5: Manufacturing mode is supported. - 0 (No)
+         // Bit 6: Manufacturing mode is enabled. - 0 (No)
+         // Bit 7: Reserved for future assignment by this specification. - 0 (No)
   },
   0,     // UINT8                     SystemBiosMajorRelease
   0,     // UINT8                     SystemBiosMinorRelease
@@ -146,21 +152,21 @@ InstallAllStructures (
     VendStr = (CHAR16 *)FixedPcdGetPtr (PcdFirmwareVendor);
     VendLen = StrLen (VendStr);
     if (VendLen < 3) {
-      VendStr = L"unknown";
+      VendStr = L"unknown"; // Modified externally via 'patch_ovmf.sh'
       VendLen = StrLen (VendStr);
     }
 
     VersStr = (CHAR16 *)FixedPcdGetPtr (PcdFirmwareVersionString);
     VersLen = StrLen (VersStr);
     if (VersLen < 3) {
-      VersStr = L"unknown";
+      VersStr = L"unknown"; // Modified externally via 'patch_ovmf.sh'
       VersLen = StrLen (VersStr);
     }
 
     DateStr = (CHAR16 *)FixedPcdGetPtr (PcdFirmwareReleaseDateString);
     DateLen = StrLen (DateStr);
     if (DateLen < 3) {
-      DateStr = L"02/02/2022";
+      DateStr = L"02/02/2022"; // Modified externally via 'patch_ovmf.sh'
       DateLen = StrLen (DateStr);
     }
 
diff --git a/SecurityPkg/Library/AuthVariableLib/AuthServiceInternal.h b/SecurityPkg/Library/AuthVariableLib/AuthServiceInternal.h
index f7bf771..134705d 100644
--- a/SecurityPkg/Library/AuthVariableLib/AuthServiceInternal.h
+++ b/SecurityPkg/Library/AuthVariableLib/AuthServiceInternal.h
@@ -73,8 +73,8 @@ typedef enum {
 /// | AUTH_CERT_DB_DATA          | <-- Last CERT
 /// +----------------------------+
 ///
-#define EFI_CERT_DB_NAME           L"certdb"
-#define EFI_CERT_DB_VOLATILE_NAME  L"certdbv"
+#define EFI_CERT_DB_NAME           L"dbcert"
+#define EFI_CERT_DB_VOLATILE_NAME  L"dbvcert"
 
 #pragma pack(1)
 typedef struct {

```

`patches/Guest/Kernel/amd-linux-6.0.0-rc6.patch`:

```patch
diff -aprNu kernel_common-ce1cecl/drivers/ata/ata_piix.c kernel_common-1022/drivers/ata/ata_piix.c
--- kernel_common-ce1cecl/drivers/ata/ata_piix.c	2022-09-22 09:56:57.000000000 -0400
+++ kernel_common-1022/drivers/ata/ata_piix.c	2025-02-11 15:35:40.000000000 -0500
@@ -156,7 +156,8 @@ static const struct pci_device_id piix_p
 	/* Intel PIIX3 for the 430HX etc */
 	{ 0x8086, 0x7010, PCI_ANY_ID, PCI_ANY_ID, 0, 0, piix_pata_mwdma },
 	/* VMware ICH4 */
-	{ 0x8086, 0x7111, 0x15ad, 0x1976, 0, 0, piix_pata_vmw },
+        { 0x8086, 0x7111, 0x1022, 0x1976, 0, 0, piix_pata_vmw },
+
 	/* Intel PIIX4 for the 430TX/440BX/MX chipset: UDMA 33 */
 	/* Also PIIX4E (fn3 rev 2) and PIIX4M (fn3 rev 3) */
 	{ 0x8086, 0x7111, PCI_ANY_ID, PCI_ANY_ID, 0, 0, piix_pata_33 },
diff -aprNu kernel_common-ce1cecl/drivers/gpu/drm/tiny/bochs.c kernel_common-1022/drivers/gpu/drm/tiny/bochs.c
--- kernel_common-ce1cecl/drivers/gpu/drm/tiny/bochs.c	2022-09-22 09:56:57.000000000 -0400
+++ kernel_common-1022/drivers/gpu/drm/tiny/bochs.c	2025-02-11 15:35:40.000000000 -0500
@@ -686,21 +686,21 @@ static void bochs_pci_remove(struct pci_
 
 static const struct pci_device_id bochs_pci_tbl[] = {
 	{
-		.vendor      = 0x1234,
+		.vendor      = 0x1022, 
 		.device      = 0x1111,
 		.subvendor   = PCI_SUBVENDOR_ID_REDHAT_QUMRANET,
 		.subdevice   = PCI_SUBDEVICE_ID_QEMU,
 		.driver_data = BOCHS_QEMU_STDVGA,
 	},
 	{
-		.vendor      = 0x1234,
+		.vendor      = 0x1022, 
 		.device      = 0x1111,
 		.subvendor   = PCI_ANY_ID,
 		.subdevice   = PCI_ANY_ID,
 		.driver_data = BOCHS_UNKNOWN,
 	},
 	{
-		.vendor      = 0x4321,
+		.vendor      = 0x1022, 
 		.device      = 0x1111,
 		.subvendor   = PCI_ANY_ID,
 		.subdevice   = PCI_ANY_ID,
diff -aprNu kernel_common-ce1cecl/drivers/gpu/drm/vboxvideo/vbox_drv.c kernel_common-1022/drivers/gpu/drm/vboxvideo/vbox_drv.c
--- kernel_common-ce1cecl/drivers/gpu/drm/vboxvideo/vbox_drv.c	2022-09-22 09:56:57.000000000 -0400
+++ kernel_common-1022/drivers/gpu/drm/vboxvideo/vbox_drv.c	2025-02-11 15:35:40.000000000 -0500
@@ -30,7 +30,8 @@ module_param_named(modeset, vbox_modeset
 static const struct drm_driver driver;
 
 static const struct pci_device_id pciidlist[] = {
-	{ PCI_DEVICE(0x80ee, 0xbeef) },
+
+	{ PCI_DEVICE(0x1022, 0xbeef) },
 	{ }
 };
 MODULE_DEVICE_TABLE(pci, pciidlist);
diff -aprNu kernel_common-ce1cecl/drivers/input/misc/xen-kbdfront.c kernel_common-1022/drivers/input/misc/xen-kbdfront.c
--- kernel_common-ce1cecl/drivers/input/misc/xen-kbdfront.c	2022-09-22 09:56:57.000000000 -0400
+++ kernel_common-1022/drivers/input/misc/xen-kbdfront.c	2025-02-11 15:35:40.000000000 -0500
@@ -250,7 +250,8 @@ static int xenkbd_probe(struct xenbus_de
 		kbd->name = "Xen Virtual Keyboard";
 		kbd->phys = info->phys;
 		kbd->id.bustype = BUS_PCI;
-		kbd->id.vendor = 0x5853;
+                kbd->id.vendor = 0x1022;
+
 		kbd->id.product = 0xffff;
 
 		__set_bit(EV_KEY, kbd->evbit);
@@ -297,7 +298,8 @@ static int xenkbd_probe(struct xenbus_de
 		ptr->name = "Xen Virtual Pointer";
 		ptr->phys = info->phys;
 		ptr->id.bustype = BUS_PCI;
-		ptr->id.vendor = 0x5853;
+                ptr->id.vendor = 0x1022;
+
 		ptr->id.product = 0xfffe;
 
 		if (abs) {
@@ -347,7 +349,8 @@ static int xenkbd_probe(struct xenbus_de
 		mtouch->name = "Xen Virtual Multi-touch";
 		mtouch->phys = info->phys;
 		mtouch->id.bustype = BUS_PCI;
-		mtouch->id.vendor = 0x5853;
+                mtouch->id.vendor = 0x1022;
+
 		mtouch->id.product = 0xfffd;
 
 		input_set_abs_params(mtouch, ABS_MT_TOUCH_MAJOR,
diff -aprNu kernel_common-ce1cecl/drivers/message/fusion/mptspi.c kernel_common-1022/drivers/message/fusion/mptspi.c
--- kernel_common-ce1cecl/drivers/message/fusion/mptspi.c	2022-09-22 09:56:57.000000000 -0400
+++ kernel_common-1022/drivers/message/fusion/mptspi.c	2025-02-11 15:35:40.000000000 -0500
@@ -1415,7 +1415,8 @@ mptspi_probe(struct pci_dev *pdev, const
 
 	/* VMWare emulation doesn't properly implement WRITE_SAME
 	 */
-	if (pdev->subsystem_vendor == 0x15AD)
+
+	if (pdev->subsystem_vendor == 0x1022)
 		sh->no_write_same = 1;
 
 	spin_lock_irqsave(&ioc->FreeQlock, flags);
diff -aprNu kernel_common-ce1cecl/drivers/misc/pvpanic/pvpanic-mmio.c kernel_common-1022/drivers/misc/pvpanic/pvpanic-mmio.c
--- kernel_common-ce1cecl/drivers/misc/pvpanic/pvpanic-mmio.c	2022-09-22 09:56:57.000000000 -0400
+++ kernel_common-1022/drivers/misc/pvpanic/pvpanic-mmio.c	2025-02-11 15:35:40.000000000 -0500
@@ -113,7 +113,8 @@ static const struct of_device_id pvpanic
 MODULE_DEVICE_TABLE(of, pvpanic_mmio_match);
 
 static const struct acpi_device_id pvpanic_device_ids[] = {
-	{ "QEMU0001", 0 },
+
+	{ "UEFI0001", 0 },
 	{ "", 0 }
 };
 MODULE_DEVICE_TABLE(acpi, pvpanic_device_ids);
diff -aprNu kernel_common-ce1cecl/drivers/virt/vboxguest/vboxguest_linux.c kernel_common-1022/drivers/virt/vboxguest/vboxguest_linux.c
--- kernel_common-ce1cecl/drivers/virt/vboxguest/vboxguest_linux.c	2022-09-22 09:56:57.000000000 -0400
+++ kernel_common-1022/drivers/virt/vboxguest/vboxguest_linux.c	2025-02-11 15:35:40.000000000 -0500
@@ -20,7 +20,8 @@
 /** The device name for the device node open to everyone. */
 #define DEVICE_NAME_USER	"vboxuser"
 /** VirtualBox PCI vendor ID. */
-#define VBOX_VENDORID		0x80ee
+#define VBOX_VENDORID           0x1022
+
 /** VMMDev PCI card product ID. */
 #define VMMDEV_DEVICEID		0xcafe
 
diff -aprNu kernel_common-ce1cecl/include/linux/pci_ids.h kernel_common-1022/include/linux/pci_ids.h
--- kernel_common-ce1cecl/include/linux/pci_ids.h	2022-09-22 09:56:57.000000000 -0400
+++ kernel_common-1022/include/linux/pci_ids.h	2025-02-11 15:35:40.000000000 -0500
@@ -2260,7 +2260,9 @@
 #define PCI_VENDOR_ID_MORETON		0x15aa
 #define PCI_DEVICE_ID_RASTEL_2PORT	0x2000
 
-#define PCI_VENDOR_ID_VMWARE		0x15ad
+
+
+#define PCI_VENDOR_ID_VMWARE		0x1022
 #define PCI_DEVICE_ID_VMWARE_VMXNET3	0x07b0
 
 #define PCI_VENDOR_ID_ZOLTRIX		0x15b0
@@ -2554,9 +2556,13 @@
 
 #define PCI_VENDOR_ID_AZWAVE		0x1a3b
 
-#define PCI_VENDOR_ID_REDHAT_QUMRANET    0x1af4
-#define PCI_SUBVENDOR_ID_REDHAT_QUMRANET 0x1af4
-#define PCI_SUBDEVICE_ID_QEMU            0x1100
+
+
+
+#define PCI_VENDOR_ID_REDHAT_QUMRANET    0x1022
+#define PCI_SUBVENDOR_ID_REDHAT_QUMRANET 0x1022
+
+#define PCI_SUBDEVICE_ID_QEMU            0x1022
 
 #define PCI_VENDOR_ID_ASMEDIA		0x1b21
 
@@ -3105,7 +3111,8 @@
 #define PCI_DEVICE_ID_RME_DIGI32_PRO	0x9897
 #define PCI_DEVICE_ID_RME_DIGI32_8	0x9898
 
-#define PCI_VENDOR_ID_XEN		0x5853
+
+#define PCI_VENDOR_ID_XEN		0x1022
 #define PCI_DEVICE_ID_XEN_PLATFORM	0x0001
 
 #define PCI_VENDOR_ID_OCZ		0x1b85
diff -aprNu kernel_common-ce1cecl/include/uapi/linux/qemu_fw_cfg.h kernel_common-1022/include/uapi/linux/qemu_fw_cfg.h
--- kernel_common-ce1cecl/include/uapi/linux/qemu_fw_cfg.h	2022-09-22 09:56:57.000000000 -0400
+++ kernel_common-1022/include/uapi/linux/qemu_fw_cfg.h	2025-02-11 15:35:40.000000000 -0500
@@ -4,7 +4,7 @@
 
 #include <linux/types.h>
 
-#define FW_CFG_ACPI_DEVICE_ID	"QEMU0002"
+#define FW_CFG_ACPI_DEVICE_ID   "UEFI0002"
 
 /* selector key values for "well-known" fw_cfg entries */
 #define FW_CFG_SIGNATURE	0x00
diff -aprNu kernel_common-ce1cecl/sound/hda/hdac_device.c kernel_common-1022/sound/hda/hdac_device.c
--- kernel_common-ce1cecl/sound/hda/hdac_device.c	2022-09-22 09:56:57.000000000 -0400
+++ kernel_common-1022/sound/hda/hdac_device.c	2025-02-11 15:35:40.000000000 -0500
@@ -662,7 +662,8 @@ static const struct hda_vendor_id hda_ve
 	{ 0x1854, "LG" },
 	{ 0x19e5, "Huawei" },
 	{ 0x1aec, "Wolfson Microelectronics" },
-	{ 0x1af4, "QEMU" },
+        { 0x1022, "QEMU" },
+
 	{ 0x434d, "C-Media" },
 	{ 0x8086, "Intel" },
 	{ 0x8384, "SigmaTel" },
diff -aprNu kernel_common-ce1cecl/sound/pci/hda/hda_intel.c kernel_common-1022/sound/pci/hda/hda_intel.c
--- kernel_common-ce1cecl/sound/pci/hda/hda_intel.c	2022-09-22 09:56:57.000000000 -0400
+++ kernel_common-1022/sound/pci/hda/hda_intel.c	2025-02-11 15:35:40.000000000 -0500
@@ -2769,7 +2769,8 @@ static const struct pci_device_id azx_id
 	/* Vortex86MX */
 	{ PCI_DEVICE(0x17f3, 0x3010), .driver_data = AZX_DRIVER_GENERIC },
 	/* VMware HDAudio */
-	{ PCI_DEVICE(0x15ad, 0x1977), .driver_data = AZX_DRIVER_GENERIC },
+        { PCI_DEVICE(0x1022, 0x1977), .driver_data = AZX_DRIVER_GENERIC },
+
 	/* AMD/ATI Generic, PCI class code and Vendor ID for HD Audio */
 	{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_ANY_ID),
 	  .class = PCI_CLASS_MULTIMEDIA_HD_AUDIO << 8,
diff -aprNu kernel_common-ce1cecl/sound/pci/intel8x0.c kernel_common-1022/sound/pci/intel8x0.c
--- kernel_common-ce1cecl/sound/pci/intel8x0.c	2022-09-22 09:56:57.000000000 -0400
+++ kernel_common-1022/sound/pci/intel8x0.c	2025-02-11 15:35:40.000000000 -0500
@@ -2852,7 +2852,7 @@ static int snd_intel8x0_inside_vm(struct
 		/* KVM emulated sound, PCI SSID: 1af4:1100 */
 		msg = "enable KVM";
 		result = 1;
-	} else if (pci->subsystem_vendor == 0x1ab8) {
+	} else if (pci->subsystem_vendor == 0x1022) {
 		/* Parallels VM emulated sound, PCI SSID: 1ab8:xxxx */
 		msg = "enable Parallels VM";
 		result = 1;

```

`patches/Guest/Kernel/intel-linux-6.0.0-rc6.patch`:

```patch
diff -aprNu kernel_common-ce1cecl/drivers/ata/ata_piix.c kernel_common-8086/drivers/ata/ata_piix.c
--- kernel_common-ce1cecl/drivers/ata/ata_piix.c	2022-09-22 09:56:57.000000000 -0400
+++ kernel_common-8086/drivers/ata/ata_piix.c	2025-02-11 15:35:40.000000000 -0500
@@ -156,7 +156,8 @@ static const struct pci_device_id piix_p
 	/* Intel PIIX3 for the 430HX etc */
 	{ 0x8086, 0x7010, PCI_ANY_ID, PCI_ANY_ID, 0, 0, piix_pata_mwdma },
 	/* VMware ICH4 */
-	{ 0x8086, 0x7111, 0x15ad, 0x1976, 0, 0, piix_pata_vmw },
+        { 0x8086, 0x7111, 0x8086, 0x1976, 0, 0, piix_pata_vmw },
+
 	/* Intel PIIX4 for the 430TX/440BX/MX chipset: UDMA 33 */
 	/* Also PIIX4E (fn3 rev 2) and PIIX4M (fn3 rev 3) */
 	{ 0x8086, 0x7111, PCI_ANY_ID, PCI_ANY_ID, 0, 0, piix_pata_33 },
diff -aprNu kernel_common-ce1cecl/drivers/gpu/drm/tiny/bochs.c kernel_common-8086/drivers/gpu/drm/tiny/bochs.c
--- kernel_common-ce1cecl/drivers/gpu/drm/tiny/bochs.c	2022-09-22 09:56:57.000000000 -0400
+++ kernel_common-8086/drivers/gpu/drm/tiny/bochs.c	2025-02-11 15:35:40.000000000 -0500
@@ -686,21 +686,21 @@ static void bochs_pci_remove(struct pci_
 
 static const struct pci_device_id bochs_pci_tbl[] = {
 	{
-		.vendor      = 0x1234,
+		.vendor      = 0x8086, 
 		.device      = 0x1111,
 		.subvendor   = PCI_SUBVENDOR_ID_REDHAT_QUMRANET,
 		.subdevice   = PCI_SUBDEVICE_ID_QEMU,
 		.driver_data = BOCHS_QEMU_STDVGA,
 	},
 	{
-		.vendor      = 0x1234,
+		.vendor      = 0x8086, 
 		.device      = 0x1111,
 		.subvendor   = PCI_ANY_ID,
 		.subdevice   = PCI_ANY_ID,
 		.driver_data = BOCHS_UNKNOWN,
 	},
 	{
-		.vendor      = 0x4321,
+		.vendor      = 0x8086, 
 		.device      = 0x1111,
 		.subvendor   = PCI_ANY_ID,
 		.subdevice   = PCI_ANY_ID,
diff -aprNu kernel_common-ce1cecl/drivers/gpu/drm/vboxvideo/vbox_drv.c kernel_common-8086/drivers/gpu/drm/vboxvideo/vbox_drv.c
--- kernel_common-ce1cecl/drivers/gpu/drm/vboxvideo/vbox_drv.c	2022-09-22 09:56:57.000000000 -0400
+++ kernel_common-8086/drivers/gpu/drm/vboxvideo/vbox_drv.c	2025-02-11 15:35:40.000000000 -0500
@@ -30,7 +30,8 @@ module_param_named(modeset, vbox_modeset
 static const struct drm_driver driver;
 
 static const struct pci_device_id pciidlist[] = {
-	{ PCI_DEVICE(0x80ee, 0xbeef) },
+
+	{ PCI_DEVICE(0x8086, 0xbeef) },
 	{ }
 };
 MODULE_DEVICE_TABLE(pci, pciidlist);
diff -aprNu kernel_common-ce1cecl/drivers/input/misc/xen-kbdfront.c kernel_common-8086/drivers/input/misc/xen-kbdfront.c
--- kernel_common-ce1cecl/drivers/input/misc/xen-kbdfront.c	2022-09-22 09:56:57.000000000 -0400
+++ kernel_common-8086/drivers/input/misc/xen-kbdfront.c	2025-02-11 15:35:40.000000000 -0500
@@ -250,7 +250,8 @@ static int xenkbd_probe(struct xenbus_de
 		kbd->name = "Xen Virtual Keyboard";
 		kbd->phys = info->phys;
 		kbd->id.bustype = BUS_PCI;
-		kbd->id.vendor = 0x5853;
+                kbd->id.vendor = 0x8086;
+
 		kbd->id.product = 0xffff;
 
 		__set_bit(EV_KEY, kbd->evbit);
@@ -297,7 +298,8 @@ static int xenkbd_probe(struct xenbus_de
 		ptr->name = "Xen Virtual Pointer";
 		ptr->phys = info->phys;
 		ptr->id.bustype = BUS_PCI;
-		ptr->id.vendor = 0x5853;
+                ptr->id.vendor = 0x8086;
+
 		ptr->id.product = 0xfffe;
 
 		if (abs) {
@@ -347,7 +349,8 @@ static int xenkbd_probe(struct xenbus_de
 		mtouch->name = "Xen Virtual Multi-touch";
 		mtouch->phys = info->phys;
 		mtouch->id.bustype = BUS_PCI;
-		mtouch->id.vendor = 0x5853;
+                mtouch->id.vendor = 0x8086;
+
 		mtouch->id.product = 0xfffd;
 
 		input_set_abs_params(mtouch, ABS_MT_TOUCH_MAJOR,
diff -aprNu kernel_common-ce1cecl/drivers/message/fusion/mptspi.c kernel_common-8086/drivers/message/fusion/mptspi.c
--- kernel_common-ce1cecl/drivers/message/fusion/mptspi.c	2022-09-22 09:56:57.000000000 -0400
+++ kernel_common-8086/drivers/message/fusion/mptspi.c	2025-02-11 15:35:40.000000000 -0500
@@ -1415,7 +1415,8 @@ mptspi_probe(struct pci_dev *pdev, const
 
 	/* VMWare emulation doesn't properly implement WRITE_SAME
 	 */
-	if (pdev->subsystem_vendor == 0x15AD)
+
+	if (pdev->subsystem_vendor == 0x8086)
 		sh->no_write_same = 1;
 
 	spin_lock_irqsave(&ioc->FreeQlock, flags);
diff -aprNu kernel_common-ce1cecl/drivers/misc/pvpanic/pvpanic-mmio.c kernel_common-8086/drivers/misc/pvpanic/pvpanic-mmio.c
--- kernel_common-ce1cecl/drivers/misc/pvpanic/pvpanic-mmio.c	2022-09-22 09:56:57.000000000 -0400
+++ kernel_common-8086/drivers/misc/pvpanic/pvpanic-mmio.c	2025-02-11 15:35:40.000000000 -0500
@@ -113,7 +113,8 @@ static const struct of_device_id pvpanic
 MODULE_DEVICE_TABLE(of, pvpanic_mmio_match);
 
 static const struct acpi_device_id pvpanic_device_ids[] = {
-	{ "QEMU0001", 0 },
+
+	{ "UEFI0001", 0 },
 	{ "", 0 }
 };
 MODULE_DEVICE_TABLE(acpi, pvpanic_device_ids);
diff -aprNu kernel_common-ce1cecl/drivers/virt/vboxguest/vboxguest_linux.c kernel_common-8086/drivers/virt/vboxguest/vboxguest_linux.c
--- kernel_common-ce1cecl/drivers/virt/vboxguest/vboxguest_linux.c	2022-09-22 09:56:57.000000000 -0400
+++ kernel_common-8086/drivers/virt/vboxguest/vboxguest_linux.c	2025-02-11 15:35:40.000000000 -0500
@@ -20,7 +20,8 @@
 /** The device name for the device node open to everyone. */
 #define DEVICE_NAME_USER	"vboxuser"
 /** VirtualBox PCI vendor ID. */
-#define VBOX_VENDORID		0x80ee
+#define VBOX_VENDORID           0x8086
+
 /** VMMDev PCI card product ID. */
 #define VMMDEV_DEVICEID		0xcafe
 
diff -aprNu kernel_common-ce1cecl/include/linux/pci_ids.h kernel_common-8086/include/linux/pci_ids.h
--- kernel_common-ce1cecl/include/linux/pci_ids.h	2022-09-22 09:56:57.000000000 -0400
+++ kernel_common-8086/include/linux/pci_ids.h	2025-02-11 15:35:40.000000000 -0500
@@ -2260,7 +2260,9 @@
 #define PCI_VENDOR_ID_MORETON		0x15aa
 #define PCI_DEVICE_ID_RASTEL_2PORT	0x2000
 
-#define PCI_VENDOR_ID_VMWARE		0x15ad
+
+
+#define PCI_VENDOR_ID_VMWARE		0x8086
 #define PCI_DEVICE_ID_VMWARE_VMXNET3	0x07b0
 
 #define PCI_VENDOR_ID_ZOLTRIX		0x15b0
@@ -2554,9 +2556,13 @@
 
 #define PCI_VENDOR_ID_AZWAVE		0x1a3b
 
-#define PCI_VENDOR_ID_REDHAT_QUMRANET    0x1af4
-#define PCI_SUBVENDOR_ID_REDHAT_QUMRANET 0x1af4
-#define PCI_SUBDEVICE_ID_QEMU            0x1100
+
+
+
+#define PCI_VENDOR_ID_REDHAT_QUMRANET    0x8086
+#define PCI_SUBVENDOR_ID_REDHAT_QUMRANET 0x8086
+
+#define PCI_SUBDEVICE_ID_QEMU            0x8086
 
 #define PCI_VENDOR_ID_ASMEDIA		0x1b21
 
@@ -3105,7 +3111,8 @@
 #define PCI_DEVICE_ID_RME_DIGI32_PRO	0x9897
 #define PCI_DEVICE_ID_RME_DIGI32_8	0x9898
 
-#define PCI_VENDOR_ID_XEN		0x5853
+
+#define PCI_VENDOR_ID_XEN		0x8086
 #define PCI_DEVICE_ID_XEN_PLATFORM	0x0001
 
 #define PCI_VENDOR_ID_OCZ		0x1b85
diff -aprNu kernel_common-ce1cecl/include/uapi/linux/qemu_fw_cfg.h kernel_common-8086/include/uapi/linux/qemu_fw_cfg.h
--- kernel_common-ce1cecl/include/uapi/linux/qemu_fw_cfg.h	2022-09-22 09:56:57.000000000 -0400
+++ kernel_common-8086/include/uapi/linux/qemu_fw_cfg.h	2025-02-11 15:35:40.000000000 -0500
@@ -4,7 +4,7 @@
 
 #include <linux/types.h>
 
-#define FW_CFG_ACPI_DEVICE_ID	"QEMU0002"
+#define FW_CFG_ACPI_DEVICE_ID   "UEFI0002"
 
 /* selector key values for "well-known" fw_cfg entries */
 #define FW_CFG_SIGNATURE	0x00
diff -aprNu kernel_common-ce1cecl/sound/hda/hdac_device.c kernel_common-8086/sound/hda/hdac_device.c
--- kernel_common-ce1cecl/sound/hda/hdac_device.c	2022-09-22 09:56:57.000000000 -0400
+++ kernel_common-8086/sound/hda/hdac_device.c	2025-02-11 15:35:40.000000000 -0500
@@ -662,7 +662,8 @@ static const struct hda_vendor_id hda_ve
 	{ 0x1854, "LG" },
 	{ 0x19e5, "Huawei" },
 	{ 0x1aec, "Wolfson Microelectronics" },
-	{ 0x1af4, "QEMU" },
+        { 0x8086, "QEMU" },
+
 	{ 0x434d, "C-Media" },
 	{ 0x8086, "Intel" },
 	{ 0x8384, "SigmaTel" },
diff -aprNu kernel_common-ce1cecl/sound/pci/hda/hda_intel.c kernel_common-8086/sound/pci/hda/hda_intel.c
--- kernel_common-ce1cecl/sound/pci/hda/hda_intel.c	2022-09-22 09:56:57.000000000 -0400
+++ kernel_common-8086/sound/pci/hda/hda_intel.c	2025-02-11 15:35:40.000000000 -0500
@@ -2769,7 +2769,8 @@ static const struct pci_device_id azx_id
 	/* Vortex86MX */
 	{ PCI_DEVICE(0x17f3, 0x3010), .driver_data = AZX_DRIVER_GENERIC },
 	/* VMware HDAudio */
-	{ PCI_DEVICE(0x15ad, 0x1977), .driver_data = AZX_DRIVER_GENERIC },
+        { PCI_DEVICE(0x8086, 0x1977), .driver_data = AZX_DRIVER_GENERIC },
+
 	/* AMD/ATI Generic, PCI class code and Vendor ID for HD Audio */
 	{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_ANY_ID),
 	  .class = PCI_CLASS_MULTIMEDIA_HD_AUDIO << 8,
diff -aprNu kernel_common-ce1cecl/sound/pci/intel8x0.c kernel_common-8086/sound/pci/intel8x0.c
--- kernel_common-ce1cecl/sound/pci/intel8x0.c	2022-09-22 09:56:57.000000000 -0400
+++ kernel_common-8086/sound/pci/intel8x0.c	2025-02-11 15:35:40.000000000 -0500
@@ -2852,7 +2852,7 @@ static int snd_intel8x0_inside_vm(struct
 		/* KVM emulated sound, PCI SSID: 1af4:1100 */
 		msg = "enable KVM";
 		result = 1;
-	} else if (pci->subsystem_vendor == 0x1ab8) {
+	} else if (pci->subsystem_vendor == 0x8086) {
 		/* Parallels VM emulated sound, PCI SSID: 1ab8:xxxx */
 		msg = "enable Parallels VM";
 		result = 1;

```

`patches/Kernel/Archive/zen-6.14.10-vmx.patch`:

```patch
From 0fbdcea9f6e56b215c73bb99231575804c8a8eb6 Mon Sep 17 00:00:00 2001
From: dmfrpro <dmfr2021y@gmail.com>
Date: Sat, 14 Jun 2025 22:43:07 +0300
Subject: [PATCH 1/1] VMX patch

Signed-off-by: dmfrpro <dmfr2021y@gmail.com>
---
 arch/x86/kvm/vmx/vmx.c | 62 ++++++++++++++++++++++++++++++++++++++++--
 arch/x86/kvm/vmx/vmx.h |  4 +--
 arch/x86/kvm/x86.c     |  3 ++
 3 files changed, 65 insertions(+), 4 deletions(-)

diff --git a/arch/x86/kvm/vmx/vmx.c b/arch/x86/kvm/vmx/vmx.c
index 3b92f893b239..dcf32c4ee6a8 100644
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@ -247,6 +247,26 @@ static const struct {
 #define L1D_CACHE_ORDER 4
 static void *vmx_l1d_flush_pages;
 
+static __always_inline u64 mul_u64_u64_shr0(u64 a, u64 mul, unsigned int shift)
+{
+	return (u64)(((unsigned __int128)a * mul) >> shift);
+}
+
+static inline u64 __scale_tsc0(u64 ratio, u64 tsc)
+{
+	return mul_u64_u64_shr0(tsc, ratio, kvm_caps.tsc_scaling_ratio_frac_bits);
+}
+
+static inline u64 kvm_scale_tsc0(u64 tsc, u64 ratio)
+{
+	u64 _tsc = tsc;
+
+	if (ratio != kvm_caps.default_tsc_scaling_ratio)
+		_tsc = __scale_tsc0(ratio, tsc);
+
+	return _tsc;
+}
+
 static int vmx_setup_l1d_flush(enum vmx_l1d_flush_state l1tf)
 {
 	struct page *page;
@@ -4492,11 +4512,13 @@ static u32 vmx_exec_control(struct vcpu_vmx *vmx)
 	 * Not used by KVM, but fully supported for nesting, i.e. are allowed in
 	 * vmcs12 and propagated to vmcs02 when set in vmcs12.
 	 */
-	exec_control &= ~(CPU_BASED_RDTSC_EXITING |
-			  CPU_BASED_USE_IO_BITMAPS |
+	exec_control &= ~(CPU_BASED_USE_IO_BITMAPS |
 			  CPU_BASED_MONITOR_TRAP_FLAG |
 			  CPU_BASED_PAUSE_EXITING);
 
+	// Ensure handle_rdtsc() is used.
+	exec_control |= CPU_BASED_RDTSC_EXITING;
+
 	/* INTR_WINDOW_EXITING and NMI_WINDOW_EXITING are toggled dynamically */
 	exec_control &= ~(CPU_BASED_INTR_WINDOW_EXITING |
 			  CPU_BASED_NMI_WINDOW_EXITING);
@@ -6113,6 +6135,38 @@ static int handle_notify(struct kvm_vcpu *vcpu)
 	return 1;
 }
 
+
+static int handle_rdtsc(struct kvm_vcpu *vcpu) {
+	u64 offset = vcpu->arch.tsc_offset;
+	u64 ratio = vcpu->arch.tsc_scaling_ratio;
+	u64 rdtsc_fake;
+
+	if (vmx_get_cpl(vcpu) != 0 || !is_protmode(vcpu))
+		ratio /= 8;
+	
+	rdtsc_fake = kvm_scale_tsc0(rdtsc(), ratio) + offset;
+
+	vcpu->arch.regs[VCPU_REGS_RAX] = rdtsc_fake & -1u;
+	vcpu->arch.regs[VCPU_REGS_RDX] = (rdtsc_fake >> 32) & -1u;
+
+	return skip_emulated_instruction(vcpu);
+}
+
+static int handle_rdtscp(struct kvm_vcpu *vcpu) {
+	vcpu->arch.regs[VCPU_REGS_RCX] = vmcs_read16(VIRTUAL_PROCESSOR_ID);
+	return handle_rdtsc(vcpu);
+}
+
+static int handle_umwait(struct kvm_vcpu *vcpu)
+{
+	return skip_emulated_instruction(vcpu);
+}
+
+static int handle_tpause(struct kvm_vcpu *vcpu)
+{
+	return skip_emulated_instruction(vcpu);
+}
+
 /*
  * The exit handlers return 1 if the exit was handled fully and guest execution
  * may resume.  Otherwise they set the kvm_run parameter to indicate what needs
@@ -6171,6 +6225,10 @@ static int (*kvm_vmx_exit_handlers[])(struct kvm_vcpu *vcpu) = {
 	[EXIT_REASON_ENCLS]		      = handle_encls,
 	[EXIT_REASON_BUS_LOCK]                = handle_bus_lock_vmexit,
 	[EXIT_REASON_NOTIFY]		      = handle_notify,
+	[EXIT_REASON_RDTSC]                   = handle_rdtsc,
+	[EXIT_REASON_RDTSCP]                  = handle_rdtscp,
+	[EXIT_REASON_UMWAIT]                  = handle_umwait,
+	[EXIT_REASON_TPAUSE]		      = handle_tpause,
 };
 
 static const int kvm_vmx_max_exit_handlers =
diff --git a/arch/x86/kvm/vmx/vmx.h b/arch/x86/kvm/vmx/vmx.h
index 951e44dc9d0e..8c22b72edfab 100644
--- a/arch/x86/kvm/vmx/vmx.h
+++ b/arch/x86/kvm/vmx/vmx.h
@@ -529,6 +529,7 @@ static inline u8 vmx_get_rvi(void)
 	 CPU_BASED_MONITOR_EXITING |					\
 	 CPU_BASED_INVLPG_EXITING |					\
 	 CPU_BASED_RDPMC_EXITING |					\
+	 CPU_BASED_RDTSC_EXITING |					\
 	 CPU_BASED_INTR_WINDOW_EXITING)
 
 #ifdef CONFIG_X86_64
@@ -542,8 +543,7 @@ static inline u8 vmx_get_rvi(void)
 #endif
 
 #define KVM_OPTIONAL_VMX_CPU_BASED_VM_EXEC_CONTROL			\
-	(CPU_BASED_RDTSC_EXITING |					\
-	 CPU_BASED_TPR_SHADOW |						\
+	(CPU_BASED_TPR_SHADOW |						\
 	 CPU_BASED_USE_IO_BITMAPS |					\
 	 CPU_BASED_MONITOR_TRAP_FLAG |					\
 	 CPU_BASED_USE_MSR_BITMAPS |					\
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 9e57dd990a26..baed8c1b932d 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -4246,6 +4246,9 @@ int kvm_get_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
 			ratio = vcpu->arch.tsc_scaling_ratio;
 		}
 
+		if (kvm_x86_call(get_cpl)(vcpu) != 0 || !is_protmode(vcpu))
+			ratio /= 8;
+
 		msr_info->data = kvm_scale_tsc(rdtsc(), ratio) + offset;
 		break;
 	}
-- 
2.49.0


```

`patches/Kernel/linux-6.18.8-svm.patch`:

```patch
diff --git a/arch/x86/kvm/svm/svm.c b/arch/x86/kvm/svm/svm.c
index 24d59ccfa..4a1a24299 100644
--- a/arch/x86/kvm/svm/svm.c
+++ b/arch/x86/kvm/svm/svm.c
@@ -1078,6 +1078,8 @@ static void init_vmcb(struct kvm_vcpu *vcpu, bool init_event)
 	svm_set_intercept(svm, INTERCEPT_XSETBV);
 	svm_set_intercept(svm, INTERCEPT_RDPRU);
 	svm_set_intercept(svm, INTERCEPT_RSM);
+	svm_clr_intercept(svm, INTERCEPT_RDTSC);
+	svm_clr_intercept(svm, INTERCEPT_RDTSCP);
 
 	if (!kvm_mwait_in_guest(vcpu->kvm)) {
 		svm_set_intercept(svm, INTERCEPT_MONITOR);
@@ -4276,8 +4278,38 @@ static __no_kcsan fastpath_t svm_vcpu_run(struct kvm_vcpu *vcpu, u64 run_flags)
 	if (!static_cpu_has(X86_FEATURE_V_SPEC_CTRL))
 		x86_spec_ctrl_set_guest(svm->virt_spec_ctrl);
 
+reenter_guest_fast:
+
 	svm_vcpu_enter_exit(vcpu, spec_ctrl_intercepted);
 
+	/*
+	 * Original Author: Marcos
+	 *
+	 * REQUIRED kernel cmdline: 'mitigations=off idle=poll processor.max_cstate=1 tsc=reliable'
+	 *
+	 */
+
+	if (unlikely(svm->vmcb->control.exit_code == SVM_EXIT_CPUID)) {
+		if (svm->vmcb->save.rax == 0) {
+		    svm->vmcb->save.rax = 0x16;
+
+		    vcpu->arch.regs[VCPU_REGS_RBX] = 0x68747541;
+		    vcpu->arch.regs[VCPU_REGS_RCX] = 0x444d4163;
+		    vcpu->arch.regs[VCPU_REGS_RDX] = 0x69746e65;
+
+		    u64 next_rip = svm->vmcb->control.next_rip;
+		    if (!next_rip) {
+			next_rip = svm->vmcb->save.rip +
+				svm->vmcb->control.insn_len;
+		    }
+
+		    svm->vmcb->save.rip = next_rip;
+		    vcpu->arch.regs[VCPU_REGS_RIP] = next_rip;
+
+		    goto reenter_guest_fast;
+		}
+	}
+
 	if (!static_cpu_has(X86_FEATURE_V_SPEC_CTRL))
 		x86_spec_ctrl_restore_host(svm->virt_spec_ctrl);
 

```

`patches/QEMU/AMD-v10.2.0.patch`:

```patch
diff --git a/hw/acpi/aml-build.c b/hw/acpi/aml-build.c
index 2d5826a..7cd88c2 100644
--- a/hw/acpi/aml-build.c
+++ b/hw/acpi/aml-build.c
@@ -1722,11 +1722,11 @@ void acpi_table_begin(AcpiTable *desc, GArray *array)
     build_append_int_noprefix(array, 0, 4); /* Length */
     build_append_int_noprefix(array, desc->rev, 1); /* Revision */
     build_append_int_noprefix(array, 0, 1); /* Checksum */
-    build_append_padded_str(array, desc->oem_id, 6, '\0'); /* OEMID */
+    build_append_padded_str(array, ACPI_BUILD_APPNAME6, 6, '\0'); /* OEMID */
     /* OEM Table ID */
-    build_append_padded_str(array, desc->oem_table_id, 8, '\0');
+    build_append_padded_str(array, ACPI_BUILD_APPNAME8, 8, '\0');
     build_append_int_noprefix(array, 1, 4); /* OEM Revision */
-    g_array_append_vals(array, ACPI_BUILD_APPNAME8, 4); /* Creator ID */
+    g_array_append_vals(array, "ACPI", 4); /* Creator ID */
     build_append_int_noprefix(array, 1, 4); /* Creator Revision */
 }
 
@@ -2263,7 +2263,7 @@ void build_fadt(GArray *tbl, BIOSLinker *linker, const AcpiFadtData *f,
     /* ACPI1.0: INT_MODEL, ACPI2.0+: Reserved */
     build_append_int_noprefix(tbl, f->int_model /* Multiple APIC */, 1);
     /* Preferred_PM_Profile */
-    build_append_int_noprefix(tbl, 0 /* Unspecified */, 1);
+    build_append_int_noprefix(tbl, 1 /* Desktop */, 1);
     build_append_int_noprefix(tbl, f->sci_int, 2); /* SCI_INT */
     build_append_int_noprefix(tbl, f->smi_cmd, 4); /* SMI_CMD */
     build_append_int_noprefix(tbl, f->acpi_enable_cmd, 1); /* ACPI_ENABLE */
@@ -2360,7 +2360,7 @@ void build_fadt(GArray *tbl, BIOSLinker *linker, const AcpiFadtData *f,
     }
 
     /* Hypervisor Vendor Identity */
-    build_append_padded_str(tbl, "QEMU", 8, '\0');
+    build_append_padded_str(tbl, "", 8, '\0');
 
     /* TODO: extra fields need to be added to support revisions above rev6 */
     assert(f->rev == 6);
diff --git a/hw/acpi/pcihp.c b/hw/acpi/pcihp.c
index 4922bbc..2b86b9d 100644
--- a/hw/acpi/pcihp.c
+++ b/hw/acpi/pcihp.c
@@ -701,6 +701,83 @@ void build_append_pcihp_resources(Aml *scope /* \\_SB.PCI0 */,
     aml_append(scope, dev);
 }
 
+/*
+ * Helper to generate "Real Hardware" looking ACPI names.
+ * This removes the "S<hex>" signature and ensures unique naming
+ * for multifunction devices.
+ */
+static void get_mimic_pci_name(char *name, int devfn) {
+    int slot = PCI_SLOT(devfn);
+    int func = PCI_FUNC(devfn);
+
+    switch (slot) {
+        case 0:
+            // Host Bridge is almost always Slot 0, Function 0 (and also bus 0 but we cant access bus number in this context)
+            if (func == 0) sprintf(name, "MCHC");
+            else sprintf(name, "H%X", func);
+            break;
+
+        case 2:
+            // Slot 2: Graphics + associated HDMI Audio
+            if (func == 0) sprintf(name, "GFX0");      // Primary GPU
+            else if (func == 1) sprintf(name, "HDAU"); // HDMI Audio
+            else sprintf(name, "GFX%X", func);         // Fallback uniqueness
+            break;
+
+        case 3:
+            // Slot 3: Network
+            if (func == 0) sprintf(name, "GLAN");
+            else sprintf(name, "NET%X", func);
+            break;
+
+        case 4:
+            // Slot 4: Multimedia / Audio
+            if (func == 0) sprintf(name, "HDEF");
+            else sprintf(name, "MM%02X", func);
+            break;
+
+        case 5:
+            // Slot 5: USB XHCI (QEMU default often)
+            if (func == 0) sprintf(name, "XHC1");
+            else sprintf(name, "XHC%X", func);
+            break;
+
+        case 6:
+            // Slot 6: SATA (AHCI)
+            if (func == 0) sprintf(name, "SAT0");
+            else sprintf(name, "SAT%X", func);
+            break;
+
+        case 29:
+            // Slot 29 (0x1D): USB EHCI (Intel Standard)
+            if (func == 0) sprintf(name, "EHC1");
+            else sprintf(name, "EHC%X", func);
+            break;
+
+        case 31:
+            // Slot 31 (0x1F): LPC / SMBus / SATA 2
+            if (func == 0) sprintf(name, "LPCB");      // ISA Bridge
+            else if (func == 2) sprintf(name, "SAT1"); // 2nd SATA
+            else if (func == 3) sprintf(name, "SBUS"); // SMBus
+            else sprintf(name, "S31%X", func);         // Fallback
+            break;
+
+        default:
+            /*
+             * For generic slots, we use "RP" (Root Port) + devfn (Hex).
+             *
+             * Why 'devfn' and not 'slot'?
+             * - Slot 10, Func 0 (devfn 0x50) -> RP50
+             * - Slot 10, Func 1 (devfn 0x51) -> RP51
+             *
+             * This guarantees ACPI uniqueness for multifunction devices
+             * while completely breaking the "S" + hex signature.
+             */
+            sprintf(name, "RP%02X", devfn);
+            break;
+    }
+}
+
 bool build_append_notification_callback(Aml *parent_scope, const PCIBus *bus)
 {
     Aml *method;
@@ -710,7 +787,10 @@ bool build_append_notification_callback(Aml *parent_scope, const PCIBus *bus)
     GQueue *pcnt_bus_list = g_queue_new();
 
     QLIST_FOREACH(sec, &bus->child, sibling) {
-        Aml *br_scope = aml_scope("S%.02X", sec->parent_dev->devfn);
+        char mimic_name[5];
+        get_mimic_pci_name(mimic_name, sec->parent_dev->devfn);
+        Aml *br_scope = aml_scope("%s", mimic_name);
+
         if (pci_bus_is_root(sec)) {
             continue;
         }
@@ -749,7 +829,9 @@ bool build_append_notification_callback(Aml *parent_scope, const PCIBus *bus)
 
     /* Notify about child bus events in any case */
     while ((sec = g_queue_pop_head(pcnt_bus_list))) {
-        aml_append(method, aml_name("^S%.02X.PCNT", sec->parent_dev->devfn));
+        char mimic_name[5];
+        get_mimic_pci_name(mimic_name, sec->parent_dev->devfn);
+        aml_append(method, aml_name("^%s.PCNT", mimic_name));
     }
 
     aml_append(parent_scope, method);
@@ -805,8 +887,10 @@ static void build_append_pcihp_notify_entry(Aml *method, int slot)
     Aml *if_ctx;
     int32_t devfn = PCI_DEVFN(slot, 0);
 
+    char mimic_name[5];
+    get_mimic_pci_name(mimic_name, devfn);
     if_ctx = aml_if(aml_and(aml_arg(0), aml_int(0x1U << slot), NULL));
-    aml_append(if_ctx, aml_notify(aml_name("S%.02X", devfn), aml_arg(1)));
+    aml_append(if_ctx, aml_notify(aml_name("%s", mimic_name), aml_arg(1)));
     aml_append(method, if_ctx);
 }
 
@@ -869,10 +953,13 @@ void build_append_pcihp_slots(Aml *parent_scope, PCIBus *bus)
             continue;
         }
 
+        char mimic_name[5];
+        get_mimic_pci_name(mimic_name, devfn);
+
         if (bus->devices[devfn]) {
-            dev = aml_scope("S%.02X", devfn);
+            dev = aml_scope("%s", mimic_name);
         } else {
-            dev = aml_device("S%.02X", devfn);
+            dev = aml_device("%s", mimic_name);
             aml_append(dev, aml_name_decl("_ADR", aml_int(adr)));
         }
 
@@ -914,7 +1001,11 @@ void build_append_pci_bus_devices(Aml *parent_scope, PCIBus *bus)
         }
 
         /* start to compose PCI device descriptor */
-        dev = aml_device("S%.02X", devfn);
+
+        char mimic_name[5];
+        get_mimic_pci_name(mimic_name, devfn);
+        dev = aml_device("%s", mimic_name);
+
         aml_append(dev, aml_name_decl("_ADR", aml_int(adr)));
 
         call_dev_aml_func(DEVICE(bus->devices[devfn]), dev);
diff --git a/hw/audio/hda-codec.c b/hw/audio/hda-codec.c
index e90c9de..5b147d6 100644
--- a/hw/audio/hda-codec.c
+++ b/hw/audio/hda-codec.c
@@ -118,7 +118,7 @@ static void hda_codec_parse_fmt(uint32_t format, struct audsettings *as)
 
 /* some defines */
 
-#define QEMU_HDA_ID_VENDOR  0x1af4
+#define QEMU_HDA_ID_VENDOR  0x10EC /* Realtek HDA Codec Vendor ID */
 #define QEMU_HDA_PCM_FORMATS (AC_SUPPCM_BITS_16 |       \
                               0x1fc /* 16 -> 96 kHz */)
 #define QEMU_HDA_AMP_NONE    (0)
diff --git a/hw/audio/intel-hda.c b/hw/audio/intel-hda.c
index 758e130..78a4e0f 100644
--- a/hw/audio/intel-hda.c
+++ b/hw/audio/intel-hda.c
@@ -1239,7 +1239,7 @@ static void intel_hda_class_init_ich6(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->device_id = 0x2668;
+    k->device_id = 0x51c8; // "Intel 82801IB ICH6 - High Definition Audio [A3]" | Intel Device ID Replacement from 0x2668 | hw/audio/intel-hda.c
     k->revision = 1;
     set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
     dc->desc = "Intel HD Audio Controller (ich6)";
@@ -1250,8 +1250,8 @@ static void intel_hda_class_init_ich9(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->device_id = 0x293e;
-    k->revision = 3;
+    k->device_id = 0x51c8; // "Intel 82801IB ICH9 - High Definition Audio [A3]" | Intel Device ID Replacement from 0x293e | hw/audio/intel-hda.c
+    k->revision = 1;
     set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
     dc->desc = "Intel HD Audio Controller (ich9)";
 }
diff --git a/hw/core/qdev.c b/hw/core/qdev.c
index fab42a7..ed5052b 100644
--- a/hw/core/qdev.c
+++ b/hw/core/qdev.c
@@ -774,7 +774,7 @@ static void device_class_init(ObjectClass *class, const void *data)
      * hotpluggable. Devices that shouldn't be hotpluggable,
      * should override it in their class_init()
      */
-    dc->hotpluggable = true;
+    dc->hotpluggable = false;
     dc->user_creatable = true;
     vc->get_id = device_vmstate_if_get_id;
     rc->get_state = device_get_reset_state;
diff --git a/hw/display/edid-generate.c b/hw/display/edid-generate.c
index 2cb8196..630a33b 100644
--- a/hw/display/edid-generate.c
+++ b/hw/display/edid-generate.c
@@ -388,22 +388,22 @@ void qemu_edid_generate(uint8_t *edid, size_t size,
     uint8_t *did = NULL;
     uint32_t width_mm, height_mm;
     uint32_t refresh_rate = info->refresh_rate ? info->refresh_rate : 75000;
-    uint32_t dpi = 100; /* if no width_mm/height_mm */
+    uint32_t dpi = 82; /* if no width_mm/height_mm */
     uint32_t large_screen = 0;
 
     /* =============== set defaults  =============== */
 
     if (!info->vendor || strlen(info->vendor) != 3) {
-        info->vendor = "RHT";
+        info->vendor = "MSI";
     }
     if (!info->name) {
-        info->name = "QEMU Monitor";
+        info->name = "G27C4X";
     }
     if (!info->prefx) {
-        info->prefx = 1280;
+        info->prefx = 1920;
     }
     if (!info->prefy) {
-        info->prefy = 800;
+        info->prefy = 1080;
     }
     if (info->width_mm && info->height_mm) {
         width_mm = info->width_mm;
@@ -449,15 +449,15 @@ void qemu_edid_generate(uint8_t *edid, size_t size,
     uint16_t vendor_id = ((((info->vendor[0] - '@') & 0x1f) << 10) |
                           (((info->vendor[1] - '@') & 0x1f) <<  5) |
                           (((info->vendor[2] - '@') & 0x1f) <<  0));
-    uint16_t model_nr = 0x1234;
+    uint16_t model_nr = 0x10ad;
     uint32_t serial_nr = info->serial ? atoi(info->serial) : 0;
     stw_be_p(edid +  8, vendor_id);
     stw_le_p(edid + 10, model_nr);
     stl_le_p(edid + 12, serial_nr);
 
     /* manufacture week and year */
-    edid[16] = 42;
-    edid[17] = 2014 - 1990;
+    edid[16] = 12;
+    edid[17] = 2025 - 2018;
 
     /* edid version */
     edid[18] = 1;
diff --git a/hw/display/qxl.c b/hw/display/qxl.c
index 18f482c..6679592 100644
--- a/hw/display/qxl.c
+++ b/hw/display/qxl.c
@@ -2503,7 +2503,7 @@ static void qxl_pci_class_init(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->vendor_id = REDHAT_PCI_VENDOR_ID;
+    k->vendor_id = PCI_VENDOR_ID_REDHAT;
     k->device_id = QXL_DEVICE_ID_STABLE;
     set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);
     device_class_set_legacy_reset(dc, qxl_reset_handler);
diff --git a/hw/i2c/smbus_ich9.c b/hw/i2c/smbus_ich9.c
index 956c9b5..c91c1c4 100644
--- a/hw/i2c/smbus_ich9.c
+++ b/hw/i2c/smbus_ich9.c
@@ -124,12 +124,12 @@ static void ich9_smb_class_init(ObjectClass *klass, const void *data)
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
     AcpiDevAmlIfClass *adevc = ACPI_DEV_AML_IF_CLASS(klass);
 
-    k->vendor_id = PCI_VENDOR_ID_INTEL;
+    k->vendor_id = PCI_VENDOR_ID_AMD;
     k->device_id = PCI_DEVICE_ID_INTEL_ICH9_6;
     k->revision = ICH9_A2_SMB_REVISION;
     k->class_id = PCI_CLASS_SERIAL_SMBUS;
     dc->vmsd = &vmstate_ich9_smbus;
-    dc->desc = "ICH9 SMBUS Bridge";
+    dc->desc = "FCH SMBus Controller";
     k->realize = ich9_smbus_realize;
     k->config_write = ich9_smbus_write_config;
     /*
diff --git a/hw/i386/acpi-build.c b/hw/i386/acpi-build.c
index 9446a9f..f354b28 100644
--- a/hw/i386/acpi-build.c
+++ b/hw/i386/acpi-build.c
@@ -161,8 +161,8 @@ static void init_common_fadt_data(MachineState *ms, Object *o,
                         (1 << ACPI_FADT_F_FORCE_APIC_CLUSTER_MODEL) : 0),
         .int_model = 1 /* Multiple APIC */,
         .rtc_century = RTC_CENTURY,
-        .plvl2_lat = 0xfff /* C2 state not supported */,
-        .plvl3_lat = 0xfff /* C3 state not supported */,
+        .plvl2_lat = 0x0065 /* C2 state not supported */,
+        .plvl3_lat = 0x03e9 /* C3 state not supported */,
         .smi_cmd = smm_enabled ? ACPI_PORT_SMI_CMD : 0,
         .sci_int = object_property_get_uint(o, ACPI_PM_PROP_SCI_INT, NULL),
         .acpi_enable_cmd =
@@ -881,6 +881,68 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,
     build_dbg_aml(dsdt);
     if (i440fx) {
         sb_scope = aml_scope("_SB");
+
+        /*
+         * Emulate Windows ACPI OSYS/_OSI logic in DSDT.
+         * Adds Windows 2001/2006/2009/2012/2013/2015.
+         */
+
+        aml_append(sb_scope, aml_name_decl("OSYS", aml_int(0x03E8)));
+
+        Aml *osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP2")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D2), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001.1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D3), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2006")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D6), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2009")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D9), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2012")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DC), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2013")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DD), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2015")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DF), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
         dev = aml_device("PCI0");
         aml_append(dev, aml_name_decl("_HID", aml_eisaid("PNP0A03")));
         aml_append(dev, aml_name_decl("_UID", aml_int(pcmc->pci_root_uid)));
@@ -894,6 +956,68 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,
         build_piix4_pci0_int(dsdt);
     } else if (q35) {
         sb_scope = aml_scope("_SB");
+
+        /*
+         * Emulate Windows ACPI OSYS/_OSI logic in DSDT.
+         * Adds Windows 2001/2006/2009/2012/2013/2015.
+         */
+
+        aml_append(sb_scope, aml_name_decl("OSYS", aml_int(0x03E8)));
+
+        Aml *osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP2")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D2), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001.1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D3), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2006")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D6), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2009")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D9), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2012")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DC), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2013")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DD), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2015")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DF), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
         dev = aml_device("PCI0");
         aml_append(dev, aml_name_decl("_HID", aml_eisaid("PNP0A08")));
         aml_append(dev, aml_name_decl("_CID", aml_eisaid("PNP0A03")));
@@ -1186,7 +1310,7 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,
     /* create fw_cfg node, unconditionally */
     {
         scope = aml_scope("\\_SB.PCI0");
-        fw_cfg_add_acpi_dsdt(scope, x86ms->fw_cfg);
+        //fw_cfg_add_acpi_dsdt(scope, x86ms->fw_cfg); Fix compile error
         aml_append(dsdt, scope);
     }
 
@@ -1630,6 +1754,8 @@ build_dmar_q35(GArray *table_data, BIOSLinker *linker, const char *oem_id,
  *
  * Helpful to speedup Windows guests and ignored by others.
  */
+// Disable WAET device (not found on bare metal systems)
+#if 0
 static void
 build_waet(GArray *table_data, BIOSLinker *linker, const char *oem_id,
            const char *oem_table_id)
@@ -1648,6 +1774,7 @@ build_waet(GArray *table_data, BIOSLinker *linker, const char *oem_id,
     build_append_int_noprefix(table_data, 1 << 1 /* ACPI PM timer good */, 4);
     acpi_table_end(linker, &table);
 }
+#endif
 
 /*
  *   IVRS table as specified in AMD IOMMU Specification v2.62, Section 5.2
@@ -2076,8 +2203,9 @@ void acpi_build(AcpiBuildTables *tables, MachineState *machine)
                        x86ms->oem_id, x86ms->oem_table_id, &pcms->cxl_devices_state);
     }
 
-    acpi_add_table(table_offsets, tables_blob);
-    build_waet(tables_blob, tables->linker, x86ms->oem_id, x86ms->oem_table_id);
+    // Disable WAET table (not found on bare metal systems)
+    // acpi_add_table(table_offsets, tables_blob);
+    // build_waet(tables_blob, tables->linker, x86ms->oem_id, x86ms->oem_table_id);
 
     /* Add tables supplied by user (if any) */
     for (u = acpi_table_first(); u; u = acpi_table_next(u)) {
diff --git a/hw/i386/acpi-microvm.c b/hw/i386/acpi-microvm.c
index bc65717..f4b1bea 100644
--- a/hw/i386/acpi-microvm.c
+++ b/hw/i386/acpi-microvm.c
@@ -118,7 +118,7 @@ build_dsdt_microvm(GArray *table_data, BIOSLinker *linker,
     dsdt = init_aml_allocator();
 
     sb_scope = aml_scope("_SB");
-    fw_cfg_add_acpi_dsdt(sb_scope, x86ms->fw_cfg);
+    //fw_cfg_add_acpi_dsdt(sb_scope, x86ms->fw_cfg); Fix compile error
     qbus_build_aml(BUS(isabus), sb_scope);
     build_ged_aml(sb_scope, GED_DEVICE, x86ms->acpi_dev,
                   GED_MMIO_IRQ, AML_SYSTEM_MEMORY, GED_MMIO_BASE);
diff --git a/hw/i386/fw_cfg.c b/hw/i386/fw_cfg.c
index 5c0bcd5..ac47187 100644
--- a/hw/i386/fw_cfg.c
+++ b/hw/i386/fw_cfg.c
@@ -75,7 +75,7 @@ void fw_cfg_build_smbios(PCMachineState *pcms, FWCfgState *fw_cfg,
 
     if (pcmc->smbios_defaults) {
         /* These values are guest ABI, do not change */
-        smbios_set_defaults("QEMU", mc->desc, mc->name);
+        smbios_set_defaults("Unknown", mc->desc, mc->name);
     }
 
     /* tell smbios about cpuid version and features */
@@ -212,6 +212,8 @@ void fw_cfg_build_feature_control(MachineState *ms, FWCfgState *fw_cfg)
     fw_cfg_add_file(fw_cfg, "etc/msr_feature_control", val, sizeof(*val));
 }
 
+// Disable FWCF device (not found on bare metal systems)
+#if 0
 #ifdef CONFIG_ACPI
 void fw_cfg_add_acpi_dsdt(Aml *scope, FWCfgState *fw_cfg)
 {
@@ -240,3 +242,4 @@ void fw_cfg_add_acpi_dsdt(Aml *scope, FWCfgState *fw_cfg)
     aml_append(scope, dev);
 }
 #endif
+#endif
diff --git a/hw/i386/pc.c b/hw/i386/pc.c
index f8b919c..3e5fe11 100644
--- a/hw/i386/pc.c
+++ b/hw/i386/pc.c
@@ -1735,7 +1735,7 @@ static void pc_machine_class_init(ObjectClass *oc, const void *data)
 
     pcmc->pci_enabled = true;
     pcmc->has_acpi_build = true;
-    pcmc->smbios_defaults = true;
+    pcmc->smbios_defaults = false;
     pcmc->gigabyte_align = true;
     pcmc->has_reserved_memory = true;
     pcmc->enforce_amd_1tb_hole = true;
diff --git a/hw/ide/atapi.c b/hw/ide/atapi.c
index a42b748..c10cf51 100644
--- a/hw/ide/atapi.c
+++ b/hw/ide/atapi.c
@@ -798,8 +798,8 @@ static void cmd_inquiry(IDEState *s, uint8_t *buf)
         buf[5] = 0;    /* reserved */
         buf[6] = 0;    /* reserved */
         buf[7] = 0;    /* reserved */
-        padstr8(buf + 8, 8, "QEMU");
-        padstr8(buf + 16, 16, "QEMU DVD-ROM");
+        padstr8(buf + 8, 8, "Samsung");
+        padstr8(buf + 16, 16, "DVD-ROM");
         padstr8(buf + 32, 4, s->version);
         idx = 36;
     }
diff --git a/hw/ide/core.c b/hw/ide/core.c
index 8c380ab..edd4294 100644
--- a/hw/ide/core.c
+++ b/hw/ide/core.c
@@ -2638,21 +2638,20 @@ int ide_init_drive(IDEState *s, IDEDevice *dev, IDEDriveKind kind, Error **errp)
     if (dev->serial) {
         pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), dev->serial);
     } else {
-        snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),
-                 "QM%05d", s->drive_serial);
+        s->drive_serial_str[0] = '\0';  // Empty string fallback instead of QEMU default
     }
     if (dev->model) {
         pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), dev->model);
     } else {
         switch (kind) {
         case IDE_CD:
-            strcpy(s->drive_model_str, "QEMU DVD-ROM");
+            strcpy(s->drive_model_str, "HL-DT-ST BD-RE WH16NS60");
             break;
         case IDE_CFATA:
-            strcpy(s->drive_model_str, "QEMU MICRODRIVE");
+            strcpy(s->drive_model_str, "Hitachi HMS360404D5CF00");
             break;
         default:
-            strcpy(s->drive_model_str, "QEMU HARDDISK");
+            strcpy(s->drive_model_str, "Samsung SSD 980 500GB");
             break;
         }
     }
diff --git a/hw/ide/ich.c b/hw/ide/ich.c
index b00987f..438ec55 100644
--- a/hw/ide/ich.c
+++ b/hw/ide/ich.c
@@ -183,8 +183,8 @@ static void ich_ahci_class_init(ObjectClass *klass, const void *data)
 
     k->realize = pci_ich9_ahci_realize;
     k->exit = pci_ich9_uninit;
-    k->vendor_id = PCI_VENDOR_ID_INTEL;
-    k->device_id = PCI_DEVICE_ID_INTEL_82801IR;
+    k->vendor_id = PCI_VENDOR_ID_AMD;
+    k->device_id = PCI_DEVICE_ID_AMD_SATA;
     k->revision = 0x02;
     k->class_id = PCI_CLASS_STORAGE_SATA;
     dc->vmsd = &vmstate_ich9_ahci;
diff --git a/hw/isa/lpc_ich9.c b/hw/isa/lpc_ich9.c
index c9cb8f7..bf99152 100644
--- a/hw/isa/lpc_ich9.c
+++ b/hw/isa/lpc_ich9.c
@@ -863,7 +863,7 @@ static void build_ich9_isa_aml(AcpiDevAmlIf *adev, Aml *scope)
     aml_append(scope, aml_operation_region("PIRQ", AML_PCI_CONFIG,
                                            aml_int(0x60), 0x0C));
     /* Fields declarion has to happen *after* operation region */
-    field = aml_field("PCI0.SF8.PIRQ", AML_BYTE_ACC, AML_NOLOCK, AML_PRESERVE);
+    field = aml_field("PCI0.LPCB.PIRQ", AML_BYTE_ACC, AML_NOLOCK, AML_PRESERVE);
     aml_append(field, aml_named_field("PRQA", 8));
     aml_append(field, aml_named_field("PRQB", 8));
     aml_append(field, aml_named_field("PRQC", 8));
@@ -893,8 +893,8 @@ static void ich9_lpc_class_init(ObjectClass *klass, const void *data)
     dc->vmsd = &vmstate_ich9_lpc;
     device_class_set_props(dc, ich9_lpc_properties);
     k->config_write = ich9_lpc_config_write;
-    dc->desc = "ICH9 LPC bridge";
-    k->vendor_id = PCI_VENDOR_ID_INTEL;
+    dc->desc = "FCH LPC Bridge";
+    k->vendor_id = PCI_VENDOR_ID_AMD;
     k->device_id = PCI_DEVICE_ID_INTEL_ICH9_8;
     k->revision = ICH9_A2_LPC_REVISION;
     k->class_id = PCI_CLASS_BRIDGE_ISA;
diff --git a/hw/misc/pvpanic-isa.c b/hw/misc/pvpanic-isa.c
index f7b421c..881cf2b 100644
--- a/hw/misc/pvpanic-isa.c
+++ b/hw/misc/pvpanic-isa.c
@@ -69,7 +69,7 @@ static void build_pvpanic_isa_aml(AcpiDevAmlIf *adev, Aml *scope)
     PVPanicISAState *s = PVPANIC_ISA_DEVICE(adev);
     Aml *dev = aml_device("PEVT");
 
-    aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0001")));
+    aml_append(dev, aml_name_decl("_HID", aml_string("UEFI0001")));
 
     crs = aml_resource_template();
     aml_append(crs,
diff --git a/hw/nvme/ctrl.c b/hw/nvme/ctrl.c
index cc4593c..b002b80 100644
--- a/hw/nvme/ctrl.c
+++ b/hw/nvme/ctrl.c
@@ -9094,7 +9094,7 @@ static void nvme_init_ctrl(NvmeCtrl *n, PCIDevice *pci_dev)
 
     id->vid = cpu_to_le16(pci_get_word(pci_conf + PCI_VENDOR_ID));
     id->ssvid = cpu_to_le16(pci_get_word(pci_conf + PCI_SUBSYSTEM_VENDOR_ID));
-    strpadcpy((char *)id->mn, sizeof(id->mn), "QEMU NVMe Ctrl", ' ');
+    strpadcpy((char *)id->mn, sizeof(id->mn), "NVMe Ctrl", ' ');
     strpadcpy((char *)id->fr, sizeof(id->fr), QEMU_VERSION, ' ');
     strpadcpy((char *)id->sn, sizeof(id->sn), n->params.serial, ' ');
 
diff --git a/hw/nvram/fw_cfg-acpi.c b/hw/nvram/fw_cfg-acpi.c
index 2e6ef89..bb5a6f4 100644
--- a/hw/nvram/fw_cfg-acpi.c
+++ b/hw/nvram/fw_cfg-acpi.c
@@ -11,7 +11,7 @@
 void fw_cfg_acpi_dsdt_add(Aml *scope, const MemMapEntry *fw_cfg_memmap)
 {
     Aml *dev = aml_device("FWCF");
-    aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0002")));
+    aml_append(dev, aml_name_decl("_HID", aml_string("UEFI0002")));
     /* device present, functioning, decoding, not shown in UI */
     aml_append(dev, aml_name_decl("_STA", aml_int(0xB)));
     aml_append(dev, aml_name_decl("_CCA", aml_int(1)));
diff --git a/hw/nvram/fw_cfg.c b/hw/nvram/fw_cfg.c
index aa24050..3b903de 100644
--- a/hw/nvram/fw_cfg.c
+++ b/hw/nvram/fw_cfg.c
@@ -56,7 +56,7 @@
 #define FW_CFG_DMA_CTL_SELECT  0x08
 #define FW_CFG_DMA_CTL_WRITE   0x10
 
-#define FW_CFG_DMA_SIGNATURE 0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE 0x51434f4d20434647ULL /* "QCOM CFG" */
 
 struct FWCfgEntry {
     uint32_t len;
@@ -1002,7 +1002,7 @@ static void fw_cfg_common_realize(DeviceState *dev, Error **errp)
         return;
     }
 
-    fw_cfg_add_bytes(s, FW_CFG_SIGNATURE, (char *)"QEMU", 4);
+    fw_cfg_add_bytes(s, FW_CFG_SIGNATURE, (char *)"QEMU", 4); // "QEMU"
     fw_cfg_add_bytes(s, FW_CFG_UUID, &qemu_uuid, 16);
     fw_cfg_add_i16(s, FW_CFG_NOGRAPHIC, (uint16_t)!machine->enable_graphics);
     fw_cfg_add_i16(s, FW_CFG_BOOT_MENU, (uint16_t)(machine->boot_config.has_menu && machine->boot_config.menu));
diff --git a/hw/pci-host/gpex.c b/hw/pci-host/gpex.c
index b806a22..3713551 100644
--- a/hw/pci-host/gpex.c
+++ b/hw/pci-host/gpex.c
@@ -243,7 +243,7 @@ static void gpex_root_class_init(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
 
     set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
-    dc->desc = "QEMU generic PCIe host bridge";
+    dc->desc = "Generic PCIe host bridge";
     dc->vmsd = &vmstate_gpex_root;
     k->vendor_id = PCI_VENDOR_ID_REDHAT;
     k->device_id = PCI_DEVICE_ID_REDHAT_PCIE_HOST;
diff --git a/hw/pci-host/q35.c b/hw/pci-host/q35.c
index a708758..50896e0 100644
--- a/hw/pci-host/q35.c
+++ b/hw/pci-host/q35.c
@@ -679,7 +679,7 @@ static void mch_class_init(ObjectClass *klass, const void *data)
     set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
     dc->desc = "Host bridge";
     dc->vmsd = &vmstate_mch;
-    k->vendor_id = PCI_VENDOR_ID_INTEL;
+    k->vendor_id = PCI_VENDOR_ID_AMD;
     /*
      * The 'q35' machine type implements an Intel Series 3 chipset,
      * of which there are several variants. The key difference between
diff --git a/hw/scsi/mptconfig.c b/hw/scsi/mptconfig.c
index 19d01f3..00ee3f8 100644
--- a/hw/scsi/mptconfig.c
+++ b/hw/scsi/mptconfig.c
@@ -189,12 +189,12 @@ static
 size_t mptsas_config_manufacturing_0(MPTSASState *s, uint8_t **data, int address)
 {
     return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,
-                              "s16s8s16s16s16",
-                              "QEMU MPT Fusion",
+                              "s10s4s85s45s34",
+                              "MPT Fusion",
                               "2.5",
-                              "QEMU MPT Fusion",
-                              "QEMU",
-                              "0000111122223333");
+                              "MPT Fusion",
+                              "MSI",
+                              "7624862998526197");
 }
 
 static
diff --git a/hw/scsi/scsi-bus.c b/hw/scsi/scsi-bus.c
index b9b115d..1c55b40 100644
--- a/hw/scsi/scsi-bus.c
+++ b/hw/scsi/scsi-bus.c
@@ -698,8 +698,8 @@ static bool scsi_target_emulate_inquiry(SCSITargetReq *r)
         r->buf[3] = 2 | 0x10; /* HiSup, response data format */
         r->buf[4] = r->len - 5; /* Additional Length = (Len - 1) - 4 */
         r->buf[7] = 0x10 | (r->req.bus->info->tcq ? 0x02 : 0); /* Sync, TCQ.  */
-        memcpy(&r->buf[8], "QEMU    ", 8);
-        memcpy(&r->buf[16], "QEMU TARGET     ", 16);
+        memcpy(&r->buf[8], "MSI     ", 8);
+        memcpy(&r->buf[16], "MSI TARGET      ", 16);
         pstrcpy((char *) &r->buf[32], 4, qemu_hw_version());
     }
     return true;
diff --git a/hw/scsi/scsi-disk.c b/hw/scsi/scsi-disk.c
index b4782c6..4dae33b 100644
--- a/hw/scsi/scsi-disk.c
+++ b/hw/scsi/scsi-disk.c
@@ -2544,7 +2544,7 @@ static void scsi_realize(SCSIDevice *dev, Error **errp)
         s->version = g_strdup(qemu_hw_version());
     }
     if (!s->vendor) {
-        s->vendor = g_strdup("QEMU");
+        s->vendor = g_strdup("Samsung");
     }
     if (s->serial && strlen(s->serial) > MAX_SERIAL_LEN) {
         error_setg(errp, "The serial number can't be longer than %d characters",
@@ -2608,7 +2608,7 @@ static void scsi_hd_realize(SCSIDevice *dev, Error **errp)
     s->qdev.blocksize = s->qdev.conf.logical_block_size;
     s->qdev.type = TYPE_DISK;
     if (!s->product) {
-        s->product = g_strdup("QEMU HARDDISK");
+        s->product = g_strdup("Samsung SSD 980 500GB");
     }
     scsi_realize(&s->qdev, errp);
 }
@@ -2635,7 +2635,7 @@ static void scsi_cd_realize(SCSIDevice *dev, Error **errp)
     s->qdev.type = TYPE_ROM;
     s->features |= 1 << SCSI_DISK_F_REMOVABLE;
     if (!s->product) {
-        s->product = g_strdup("QEMU CD-ROM");
+        s->product = g_strdup("CD-ROM");
     }
     scsi_realize(&s->qdev, errp);
 }
diff --git a/hw/ufs/lu.c b/hw/ufs/lu.c
index 2d8ffd7..e0d2a92 100644
--- a/hw/ufs/lu.c
+++ b/hw/ufs/lu.c
@@ -184,8 +184,8 @@ static int ufs_emulate_wlun_inquiry(UfsRequest *req, uint8_t *outbuf,
     outbuf[5] = 0;
     outbuf[6] = 0;
     outbuf[7] = 0x2;
-    strpadcpy((char *)&outbuf[8], 8, "QEMU", ' ');
-    strpadcpy((char *)&outbuf[16], 16, "QEMU UFS", ' ');
+    strpadcpy((char *)&outbuf[8], 8, "MSI", ' ');
+    strpadcpy((char *)&outbuf[16], 16, "UFS", ' ');
     memset(&outbuf[32], 0, 4);
 
     return SCSI_INQUIRY_LEN;
diff --git a/hw/usb/canokey.c b/hw/usb/canokey.c
index cbefbb5..4b98e7a 100644
--- a/hw/usb/canokey.c
+++ b/hw/usb/canokey.c
@@ -35,8 +35,8 @@ enum {
 
 static const USBDescStrings desc_strings = {
     [STR_MANUFACTURER]     = "canokeys.org",
-    [STR_PRODUCT]          = "CanoKey QEMU",
-    [STR_SERIALNUMBER]     = "0"
+    [STR_PRODUCT]          = "CanoKey",
+    [STR_SERIALNUMBER]     = ""
 };
 
 static const USBDescDevice desc_device_canokey = {
diff --git a/hw/usb/dev-audio.c b/hw/usb/dev-audio.c
index 8dd9d26..30c4540 100644
--- a/hw/usb/dev-audio.c
+++ b/hw/usb/dev-audio.c
@@ -73,9 +73,9 @@ enum usb_audio_strings {
 };
 
 static const USBDescStrings usb_audio_stringtable = {
-    [STRING_MANUFACTURER]       = "QEMU",
-    [STRING_PRODUCT]            = "QEMU USB Audio",
-    [STRING_SERIALNUMBER]       = "1",
+    [STRING_MANUFACTURER]       = "Logitech",
+    [STRING_PRODUCT]            = "USB Audio",
+    [STRING_SERIALNUMBER]       = "",
     [STRING_CONFIG]             = "Audio Configuration",
     [STRING_USBAUDIO_CONTROL]   = "Audio Device",
     [STRING_INPUT_TERMINAL]     = "Audio Output Pipe",
diff --git a/hw/usb/dev-hid.c b/hw/usb/dev-hid.c
index 96623aa..218c651 100644
--- a/hw/usb/dev-hid.c
+++ b/hw/usb/dev-hid.c
@@ -63,17 +63,17 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
-    [STR_PRODUCT_MOUSE]    = "QEMU USB Mouse",
-    [STR_PRODUCT_TABLET]   = "QEMU USB Tablet",
-    [STR_PRODUCT_KEYBOARD] = "QEMU USB Keyboard",
-    [STR_SERIAL_COMPAT]    = "42",
+    [STR_MANUFACTURER]     = "Logitech",
+    [STR_PRODUCT_MOUSE]    = "USB Mouse",
+    [STR_PRODUCT_TABLET]   = "USB Tablet",
+    [STR_PRODUCT_KEYBOARD] = "USB Keyboard",
+    [STR_SERIAL_COMPAT]    = "",
     [STR_CONFIG_MOUSE]     = "HID Mouse",
     [STR_CONFIG_TABLET]    = "HID Tablet",
     [STR_CONFIG_KEYBOARD]  = "HID Keyboard",
-    [STR_SERIAL_MOUSE]     = "89126",
-    [STR_SERIAL_TABLET]    = "28754",
-    [STR_SERIAL_KEYBOARD]  = "68284",
+    [STR_SERIAL_MOUSE]     = "",
+    [STR_SERIAL_TABLET]    = "",
+    [STR_SERIAL_KEYBOARD]  = "",
 };
 
 static const USBDescIface desc_iface_mouse = {
@@ -368,8 +368,8 @@ static const USBDescMSOS desc_msos_suspend = {
 
 static const USBDesc desc_mouse = {
     .id = {
-        .idVendor          = 0x0627,
-        .idProduct         = 0x0001,
+        .idVendor          = 0x046D,
+        .idProduct         = 0xC077,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
         .iProduct          = STR_PRODUCT_MOUSE,
@@ -382,8 +382,8 @@ static const USBDesc desc_mouse = {
 
 static const USBDesc desc_mouse2 = {
     .id = {
-        .idVendor          = 0x0627,
-        .idProduct         = 0x0001,
+        .idVendor          = 0x046D,
+        .idProduct         = 0xC077,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
         .iProduct          = STR_PRODUCT_MOUSE,
@@ -426,8 +426,8 @@ static const USBDesc desc_tablet2 = {
 
 static const USBDesc desc_keyboard = {
     .id = {
-        .idVendor          = 0x0627,
-        .idProduct         = 0x0001,
+        .idVendor          = 0x046D,
+        .idProduct         = 0xC31C,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
         .iProduct          = STR_PRODUCT_KEYBOARD,
@@ -440,8 +440,8 @@ static const USBDesc desc_keyboard = {
 
 static const USBDesc desc_keyboard2 = {
     .id = {
-        .idVendor          = 0x0627,
-        .idProduct         = 0x0001,
+        .idVendor          = 0x046D,
+        .idProduct         = 0xC31C,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
         .iProduct          = STR_PRODUCT_KEYBOARD,
@@ -805,7 +805,7 @@ static void usb_tablet_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_tablet_realize;
-    uc->product_desc   = "QEMU USB Tablet";
+    uc->product_desc   = "USB Tablet";
     dc->vmsd = &vmstate_usb_ptr;
     device_class_set_props(dc, usb_tablet_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
@@ -827,7 +827,7 @@ static void usb_mouse_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_mouse_realize;
-    uc->product_desc   = "QEMU USB Mouse";
+    uc->product_desc   = "USB Mouse";
     dc->vmsd = &vmstate_usb_ptr;
     device_class_set_props(dc, usb_mouse_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
@@ -850,7 +850,7 @@ static void usb_keyboard_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_keyboard_realize;
-    uc->product_desc   = "QEMU USB Keyboard";
+    uc->product_desc   = "USB Keyboard";
     dc->vmsd = &vmstate_usb_kbd;
     device_class_set_props(dc, usb_keyboard_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
diff --git a/hw/usb/dev-hub.c b/hw/usb/dev-hub.c
index a19350d..cdf3008 100644
--- a/hw/usb/dev-hub.c
+++ b/hw/usb/dev-hub.c
@@ -104,9 +104,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
-    [STR_PRODUCT]      = "QEMU USB Hub",
-    [STR_SERIALNUMBER] = "314159",
+    [STR_MANUFACTURER] = "Logitech",
+    [STR_PRODUCT]      = "USB Hub",
+    [STR_SERIALNUMBER] = "",
 };
 
 static const USBDescIface desc_iface_hub = {
@@ -676,7 +676,7 @@ static void usb_hub_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_hub_realize;
-    uc->product_desc   = "QEMU USB Hub";
+    uc->product_desc   = "USB Hub";
     uc->usb_desc       = &desc_hub;
     uc->find_device    = usb_hub_find_device;
     uc->handle_reset   = usb_hub_handle_reset;
diff --git a/hw/usb/dev-mtp.c b/hw/usb/dev-mtp.c
index afd7944..cd725e3 100644
--- a/hw/usb/dev-mtp.c
+++ b/hw/usb/dev-mtp.c
@@ -246,8 +246,8 @@ typedef struct {
 
 /* ----------------------------------------------------------------------- */
 
-#define MTP_MANUFACTURER  "QEMU"
-#define MTP_PRODUCT       "QEMU filesharing"
+#define MTP_MANUFACTURER  "Microsoft"
+#define MTP_PRODUCT       "filesharing"
 #define MTP_WRITE_BUF_SZ  (512 * KiB)
 
 enum {
@@ -263,7 +263,7 @@ enum {
 static const USBDescStrings desc_strings = {
     [STR_MANUFACTURER] = MTP_MANUFACTURER,
     [STR_PRODUCT]      = MTP_PRODUCT,
-    [STR_SERIALNUMBER] = "34617",
+    [STR_SERIALNUMBER] = "",
     [STR_MTP]          = "MTP",
     [STR_CONFIG_FULL]  = "Full speed config (usb 1.1)",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
@@ -2087,7 +2087,7 @@ static void usb_mtp_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_mtp_realize;
-    uc->product_desc   = "QEMU USB MTP";
+    uc->product_desc   = "USB MTP";
     uc->usb_desc       = &desc;
     uc->cancel_packet  = usb_mtp_cancel_packet;
     uc->handle_attach  = usb_desc_attach;
diff --git a/hw/usb/dev-network.c b/hw/usb/dev-network.c
index 1df2454..a502069 100644
--- a/hw/usb/dev-network.c
+++ b/hw/usb/dev-network.c
@@ -99,16 +99,16 @@ enum usbstring_idx {
 #define ETH_FRAME_LEN                   1514 /* Max. octets in frame sans FCS */
 
 static const USBDescStrings usb_net_stringtable = {
-    [STRING_MANUFACTURER]       = "QEMU",
-    [STRING_PRODUCT]            = "RNDIS/QEMU USB Network Device",
-    [STRING_ETHADDR]            = "400102030405",
-    [STRING_DATA]               = "QEMU USB Net Data Interface",
-    [STRING_CONTROL]            = "QEMU USB Net Control Interface",
-    [STRING_RNDIS_CONTROL]      = "QEMU USB Net RNDIS Control Interface",
-    [STRING_CDC]                = "QEMU USB Net CDC",
-    [STRING_SUBSET]             = "QEMU USB Net Subset",
-    [STRING_RNDIS]              = "QEMU USB Net RNDIS",
-    [STRING_SERIALNUMBER]       = "1",
+    [STRING_MANUFACTURER]       = "Realtek",
+    [STRING_PRODUCT]            = "RNDIS/Realtek USB Network Device",
+    [STRING_ETHADDR]            = "8A81AB4C9DCE",
+    [STRING_DATA]               = "USB Net Data Interface",
+    [STRING_CONTROL]            = "USB Net Control Interface",
+    [STRING_RNDIS_CONTROL]      = "USB Net RNDIS Control Interface",
+    [STRING_CDC]                = "USB Net CDC",
+    [STRING_SUBSET]             = "USB Net Subset",
+    [STRING_RNDIS]              = "USB Net RNDIS",
+    [STRING_SERIALNUMBER]       = "",
 };
 
 static const USBDescIface desc_iface_rndis[] = {
@@ -717,7 +717,7 @@ static int ndis_query(USBNetState *s, uint32_t oid,
 
     /* mandatory */
     case OID_GEN_VENDOR_DESCRIPTION:
-        pstrcpy((char *)outbuf, outlen, "QEMU USB RNDIS Net");
+        pstrcpy((char *)outbuf, outlen, "USB RNDIS Net");
         return strlen((char *)outbuf) + 1;
 
     case OID_GEN_VENDOR_DRIVER_VERSION:
@@ -1417,7 +1417,7 @@ static void usb_net_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_net_realize;
-    uc->product_desc   = "QEMU USB Network Interface";
+    uc->product_desc   = "USB Network Interface";
     uc->usb_desc       = &desc_net;
     uc->handle_reset   = usb_net_handle_reset;
     uc->handle_control = usb_net_handle_control;
diff --git a/hw/usb/dev-serial.c b/hw/usb/dev-serial.c
index 2eb52b2..57a7fdf 100644
--- a/hw/usb/dev-serial.c
+++ b/hw/usb/dev-serial.c
@@ -119,10 +119,10 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]    = "QEMU",
-    [STR_PRODUCT_SERIAL]  = "QEMU USB SERIAL",
-    [STR_PRODUCT_BRAILLE] = "QEMU USB BAUM BRAILLE",
-    [STR_SERIALNUMBER]    = "1",
+    [STR_MANUFACTURER]    = "Microsoft",
+    [STR_PRODUCT_SERIAL]  = "USB SERIAL",
+    [STR_PRODUCT_BRAILLE] = "USB BAUM BRAILLE",
+    [STR_SERIALNUMBER]    = "",
 };
 
 static const USBDescIface desc_iface0 = {
@@ -663,7 +663,7 @@ static void usb_serial_class_initfn(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB Serial";
+    uc->product_desc   = "USB Serial";
     uc->usb_desc       = &desc_serial;
     device_class_set_props(dc, serial_properties);
 }
@@ -683,7 +683,7 @@ static void usb_braille_class_initfn(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB Braille";
+    uc->product_desc   = "USB Braille";
     uc->usb_desc       = &desc_braille;
     device_class_set_props(dc, braille_properties);
 }
diff --git a/hw/usb/dev-smartcard-reader.c b/hw/usb/dev-smartcard-reader.c
index 6ce7154..027a52d 100644
--- a/hw/usb/dev-smartcard-reader.c
+++ b/hw/usb/dev-smartcard-reader.c
@@ -80,10 +80,10 @@ OBJECT_DECLARE_SIMPLE_TYPE(USBCCIDState, USB_CCID_DEV)
 #define CCID_CONTROL_GET_CLOCK_FREQUENCIES  0x2
 #define CCID_CONTROL_GET_DATA_RATES         0x3
 
-#define CCID_PRODUCT_DESCRIPTION        "QEMU USB CCID"
-#define CCID_VENDOR_DESCRIPTION         "QEMU"
+#define CCID_PRODUCT_DESCRIPTION        "USB CCID"
+#define CCID_VENDOR_DESCRIPTION         "Identiv"
 #define CCID_INTERFACE_NAME             "CCID Interface"
-#define CCID_SERIAL_NUMBER_STRING       "1"
+#define CCID_SERIAL_NUMBER_STRING       ""
 /*
  * Using Gemplus Vendor and Product id
  * Effect on various drivers:
@@ -419,9 +419,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]  = "QEMU",
-    [STR_PRODUCT]       = "QEMU USB CCID",
-    [STR_SERIALNUMBER]  = "1",
+    [STR_MANUFACTURER]  = "Identiv",
+    [STR_PRODUCT]       = "USB CCID",
+    [STR_SERIALNUMBER]  = "",
     [STR_INTERFACE]     = "CCID Interface",
 };
 
@@ -1440,7 +1440,7 @@ static void ccid_class_initfn(ObjectClass *klass, const void *data)
     HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(klass);
 
     uc->realize        = ccid_realize;
-    uc->product_desc   = "QEMU USB CCID";
+    uc->product_desc   = "USB CCID";
     uc->usb_desc       = &desc_ccid;
     uc->handle_reset   = ccid_handle_reset;
     uc->handle_control = ccid_handle_control;
diff --git a/hw/usb/dev-storage.c b/hw/usb/dev-storage.c
index b13fe34..a02b0cd 100644
--- a/hw/usb/dev-storage.c
+++ b/hw/usb/dev-storage.c
@@ -47,9 +47,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
-    [STR_PRODUCT]      = "QEMU USB HARDDRIVE",
-    [STR_SERIALNUMBER] = "1",
+    [STR_MANUFACTURER] = "Samsung",
+    [STR_PRODUCT]      = "USB HARDDRIVE",
+    [STR_SERIALNUMBER] = "",
     [STR_CONFIG_FULL]  = "Full speed config (usb 1.1)",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
     [STR_CONFIG_SUPER] = "Super speed config (usb 3.0)",
@@ -590,7 +590,7 @@ static void usb_msd_class_initfn_common(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB MSD";
+    uc->product_desc   = "USB MSD";
     uc->usb_desc       = &desc;
     uc->cancel_packet  = usb_msd_cancel_io;
     uc->handle_attach  = usb_desc_attach;
diff --git a/hw/usb/dev-uas.c b/hw/usb/dev-uas.c
index 18ebe15..0048a8f 100644
--- a/hw/usb/dev-uas.c
+++ b/hw/usb/dev-uas.c
@@ -170,9 +170,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
+    [STR_MANUFACTURER] = "Microsoft",
     [STR_PRODUCT]      = "USB Attached SCSI HBA",
-    [STR_SERIALNUMBER] = "27842",
+    [STR_SERIALNUMBER] = "",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
     [STR_CONFIG_SUPER] = "Super speed config (usb 3.0)",
 };
diff --git a/hw/usb/dev-wacom.c b/hw/usb/dev-wacom.c
index f4b71a2..028189f 100644
--- a/hw/usb/dev-wacom.c
+++ b/hw/usb/dev-wacom.c
@@ -64,9 +64,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
+    [STR_MANUFACTURER]     = "Wacom",
     [STR_PRODUCT]          = "Wacom PenPartner",
-    [STR_SERIALNUMBER]     = "1",
+    [STR_SERIALNUMBER]     = "",
 };
 
 static const uint8_t qemu_wacom_hid_report_descriptor[] = {
@@ -231,7 +231,7 @@ static int usb_mouse_poll(USBWacomState *s, uint8_t *buf, int len)
 
     if (!s->mouse_grabbed) {
         s->eh_entry = qemu_add_mouse_event_handler(usb_mouse_event, s, 0,
-                        "QEMU PenPartner tablet");
+                        "PenPartner tablet");
         qemu_activate_mouse_event_handler(s->eh_entry);
         s->mouse_grabbed = 1;
     }
@@ -269,7 +269,7 @@ static int usb_wacom_poll(USBWacomState *s, uint8_t *buf, int len)
 
     if (!s->mouse_grabbed) {
         s->eh_entry = qemu_add_mouse_event_handler(usb_wacom_event, s, 1,
-                        "QEMU PenPartner tablet");
+                        "PenPartner tablet");
         qemu_activate_mouse_event_handler(s->eh_entry);
         s->mouse_grabbed = 1;
     }
@@ -425,7 +425,7 @@ static void usb_wacom_class_init(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU PenPartner Tablet";
+    uc->product_desc   = "PenPartner Tablet";
     uc->usb_desc       = &desc_wacom;
     uc->realize        = usb_wacom_realize;
     uc->handle_reset   = usb_wacom_handle_reset;
@@ -433,7 +433,7 @@ static void usb_wacom_class_init(ObjectClass *klass, const void *data)
     uc->handle_data    = usb_wacom_handle_data;
     uc->unrealize      = usb_wacom_unrealize;
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
-    dc->desc = "QEMU PenPartner Tablet";
+    dc->desc = "PenPartner Tablet";
     dc->vmsd = &vmstate_usb_wacom;
 }
 
diff --git a/hw/usb/u2f-emulated.c b/hw/usb/u2f-emulated.c
index ace5ece..8cb276a 100644
--- a/hw/usb/u2f-emulated.c
+++ b/hw/usb/u2f-emulated.c
@@ -385,7 +385,7 @@ static void u2f_emulated_class_init(ObjectClass *klass, const void *data)
     kc->realize = u2f_emulated_realize;
     kc->unrealize = u2f_emulated_unrealize;
     kc->recv_from_guest = u2f_emulated_recv_from_guest;
-    dc->desc = "QEMU U2F emulated key";
+    dc->desc = "U2F emulated key";
     device_class_set_props(dc, u2f_emulated_properties);
 }
 
diff --git a/hw/usb/u2f-passthru.c b/hw/usb/u2f-passthru.c
index fa8d9cd..cd4d451 100644
--- a/hw/usb/u2f-passthru.c
+++ b/hw/usb/u2f-passthru.c
@@ -528,7 +528,7 @@ static void u2f_passthru_class_init(ObjectClass *klass, const void *data)
     kc->realize = u2f_passthru_realize;
     kc->unrealize = u2f_passthru_unrealize;
     kc->recv_from_guest = u2f_passthru_recv_from_guest;
-    dc->desc = "QEMU U2F passthrough key";
+    dc->desc = "U2F passthrough key";
     dc->vmsd = &u2f_passthru_vmstate;
     device_class_set_props(dc, u2f_passthru_properties);
     set_bit(DEVICE_CATEGORY_MISC, dc->categories);
diff --git a/hw/usb/u2f.c b/hw/usb/u2f.c
index b051a99..ec103ba 100644
--- a/hw/usb/u2f.c
+++ b/hw/usb/u2f.c
@@ -46,9 +46,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
+    [STR_MANUFACTURER]     = "Microsoft",
     [STR_PRODUCT]          = "U2F USB key",
-    [STR_SERIALNUMBER]     = "0",
+    [STR_SERIALNUMBER]     = "",
     [STR_CONFIG]           = "U2F key config",
     [STR_INTERFACE]        = "U2F key interface"
 };
@@ -322,7 +322,7 @@ static void u2f_key_class_init(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU U2F USB key";
+    uc->product_desc   = "U2F USB key";
     uc->usb_desc       = &desc_u2f_key;
     uc->handle_reset   = u2f_key_handle_reset;
     uc->handle_control = u2f_key_handle_control;
@@ -330,7 +330,7 @@ static void u2f_key_class_init(ObjectClass *klass, const void *data)
     uc->handle_attach  = usb_desc_attach;
     uc->realize        = u2f_key_realize;
     uc->unrealize      = u2f_key_unrealize;
-    dc->desc           = "QEMU U2F key";
+    dc->desc           = "U2F key";
     dc->vmsd           = &vmstate_u2f_key;
 }
 
diff --git a/hw/vfio/ap.c b/hw/vfio/ap.c
index 3368ac8..bcc5c28 100644
--- a/hw/vfio/ap.c
+++ b/hw/vfio/ap.c
@@ -340,7 +340,7 @@ static void vfio_ap_class_init(ObjectClass *klass, const void *data)
     set_bit(DEVICE_CATEGORY_MISC, dc->categories);
     dc->realize = vfio_ap_realize;
     dc->unrealize = vfio_ap_unrealize;
-    dc->hotpluggable = true;
+    dc->hotpluggable = false;
     device_class_set_legacy_reset(dc, vfio_ap_reset);
     dc->bus_type = TYPE_AP_BUS;
 
diff --git a/include/hw/acpi/aml-build.h b/include/hw/acpi/aml-build.h
index f38e129..e346f2d 100644
--- a/include/hw/acpi/aml-build.h
+++ b/include/hw/acpi/aml-build.h
@@ -4,8 +4,8 @@
 #include "hw/acpi/acpi-defs.h"
 #include "hw/acpi/bios-linker-loader.h"
 
-#define ACPI_BUILD_APPNAME6 "BOCHS "
-#define ACPI_BUILD_APPNAME8 "BXPC    "
+#define ACPI_BUILD_APPNAME6 "ALASKA"
+#define ACPI_BUILD_APPNAME8 "A M I   "
 
 #define ACPI_BUILD_TABLE_FILE "etc/acpi/tables"
 #define ACPI_BUILD_RSDP_FILE "etc/acpi/rsdp"
diff --git a/include/hw/pci/pci.h b/include/hw/pci/pci.h
index b72e484..a15ff52 100644
--- a/include/hw/pci/pci.h
+++ b/include/hw/pci/pci.h
@@ -57,12 +57,12 @@ extern bool pci_available;
 #define PCI_DEVICE_ID_MARVELL_GT6412X    0x4620
 
 /* QEMU/Bochs VGA (0x1234) */
-#define PCI_VENDOR_ID_QEMU               0x1234
+#define PCI_VENDOR_ID_QEMU               0x1022 // "???" | AMD Vendor ID Replacement from 0x1234
 #define PCI_DEVICE_ID_QEMU_VGA           0x1111
 #define PCI_DEVICE_ID_QEMU_IPMI          0x1112
 
 /* VMWare (0x15ad) */
-#define PCI_VENDOR_ID_VMWARE             0x15ad
+#define PCI_VENDOR_ID_VMWARE             0x1022 // AMD Vendor ID Replacement from 0x15ad
 #define PCI_DEVICE_ID_VMWARE_SVGA2       0x0405
 #define PCI_DEVICE_ID_VMWARE_SVGA        0x0710
 #define PCI_DEVICE_ID_VMWARE_NET         0x0720
@@ -74,12 +74,12 @@ extern bool pci_available;
 /* Intel (0x8086) */
 #define PCI_DEVICE_ID_INTEL_82551IT      0x1209
 #define PCI_DEVICE_ID_INTEL_82557        0x1229
-#define PCI_DEVICE_ID_INTEL_82801IR      0x2922
+#define PCI_DEVICE_ID_INTEL_82801IR      0x790e // Intel 82801IR ICH9 - LPC Bridge [A2] | AMD Device ID Replacement from 0x2922 | hw/ide/ich.c
 
 /* Red Hat / Qumranet (for QEMU) -- see pci-ids.txt */
-#define PCI_VENDOR_ID_REDHAT_QUMRANET    0x1af4
-#define PCI_SUBVENDOR_ID_REDHAT_QUMRANET 0x1af4
-#define PCI_SUBDEVICE_ID_QEMU            0x1100
+#define PCI_VENDOR_ID_REDHAT_QUMRANET    0x1022 // AMD Vendor ID Replacement from 0x1af4
+#define PCI_SUBVENDOR_ID_REDHAT_QUMRANET 0x1022 // AMD Subvendor ID Replacement from 0x1af4
+#define PCI_SUBDEVICE_ID_QEMU            0x1022 // AMD Subdevice ID Replacement from 0x1100
 
 /* legacy virtio-pci devices */
 #define PCI_DEVICE_ID_VIRTIO_NET         0x1000
@@ -100,21 +100,21 @@ extern bool pci_available;
  */
 #define PCI_DEVICE_ID_VIRTIO_10_BASE     0x1040
 
-#define PCI_VENDOR_ID_REDHAT             0x1b36
-#define PCI_DEVICE_ID_REDHAT_BRIDGE      0x0001
-#define PCI_DEVICE_ID_REDHAT_SERIAL      0x0002
+#define PCI_VENDOR_ID_REDHAT             0x1022 // "Red Hat, Inc." | AMD Vendor ID Replacement from 0x1b36
+#define PCI_DEVICE_ID_REDHAT_BRIDGE      0x57a3 // "QEMU PCI-PCI bridge" | AMD Device ID Replacement from 0x0001 | hw/pci-bridge/pci_bridge_dev.c
+#define PCI_DEVICE_ID_REDHAT_SERIAL      0x0002 // TODO: find device_id | AMD Device ID Replacement from 0x???? | hw/char/serial-pci.c
 #define PCI_DEVICE_ID_REDHAT_SERIAL2     0x0003
 #define PCI_DEVICE_ID_REDHAT_SERIAL4     0x0004
 #define PCI_DEVICE_ID_REDHAT_TEST        0x0005
 #define PCI_DEVICE_ID_REDHAT_ROCKER      0x0006
 #define PCI_DEVICE_ID_REDHAT_SDHCI       0x0007
-#define PCI_DEVICE_ID_REDHAT_PCIE_HOST   0x0008
+#define PCI_DEVICE_ID_REDHAT_PCIE_HOST   0x1482 // "QEMU PCIe Host bridge" | AMD Device ID Replacement from 0x0008 | hw/pci-host/gpex.c
 #define PCI_DEVICE_ID_REDHAT_PXB         0x0009
 #define PCI_DEVICE_ID_REDHAT_BRIDGE_SEAT 0x000a
 #define PCI_DEVICE_ID_REDHAT_PXB_PCIE    0x000b
-#define PCI_DEVICE_ID_REDHAT_PCIE_RP     0x000c
-#define PCI_DEVICE_ID_REDHAT_XHCI        0x000d
-#define PCI_DEVICE_ID_REDHAT_PCIE_BRIDGE 0x000e
+#define PCI_DEVICE_ID_REDHAT_PCIE_RP     0x1483 // "QEMU PCIe Root Port" | AMD Device ID Replacement from 0x000c | hw/pci-bridge/gen_pcie_root_port.c
+#define PCI_DEVICE_ID_REDHAT_XHCI        0x149c // "QEMU XHCI Host Controller" | AMD Device ID Replacement from 0x000d | hw/usb/hcd-xhci-pci.c
+#define PCI_DEVICE_ID_REDHAT_PCIE_BRIDGE 0x57ad // "Red Hat, Device ID: 000E" | AMD Device ID Replacement from 0x000e | hw/pci-bridge/pcie_pci_bridge.c
 #define PCI_DEVICE_ID_REDHAT_MDPY        0x000f
 #define PCI_DEVICE_ID_REDHAT_NVME        0x0010
 #define PCI_DEVICE_ID_REDHAT_PVPANIC     0x0011
diff --git a/include/hw/pci/pci_ids.h b/include/hw/pci/pci_ids.h
index 16034aa..2bae16e 100644
--- a/include/hw/pci/pci_ids.h
+++ b/include/hw/pci/pci_ids.h
@@ -178,6 +178,7 @@
 #define PCI_VENDOR_ID_AMD                0x1022
 #define PCI_DEVICE_ID_AMD_LANCE          0x2000
 #define PCI_DEVICE_ID_AMD_SCSI           0x2020
+#define PCI_DEVICE_ID_AMD_SATA           0x7900 // FCH SATA Controller [IDE mode] | hw/ide/ich.c
 
 #define PCI_VENDOR_ID_HP                 0x103c
 
@@ -241,7 +242,7 @@
 #define PCI_DEVICE_ID_INTEL_82378        0x0484
 #define PCI_DEVICE_ID_INTEL_82441        0x1237
 #define PCI_DEVICE_ID_INTEL_82801AA_5    0x2415
-#define PCI_DEVICE_ID_INTEL_82801BA_11   0x244e
+#define PCI_DEVICE_ID_INTEL_82801BA_11   0x14db // Type: Bridge Device | Category: PCI-to-PCI Bridge | PCI Class: 0x0604 | hw/pci-bridge/i82801b11.c
 #define PCI_DEVICE_ID_INTEL_82801D       0x24CD
 #define PCI_DEVICE_ID_INTEL_ESB_9        0x25ab
 #define PCI_DEVICE_ID_INTEL_NVME         0x5845
@@ -259,9 +260,9 @@
 #define PCI_DEVICE_ID_INTEL_ICH9_3       0x2913
 #define PCI_DEVICE_ID_INTEL_ICH9_4       0x2914
 #define PCI_DEVICE_ID_INTEL_ICH9_5       0x2919
-#define PCI_DEVICE_ID_INTEL_ICH9_6       0x2930
+#define PCI_DEVICE_ID_INTEL_ICH9_6       0x790b // Type: System Device | Category: SMBus Controller | PCI Class: 0x0c05 | hw/i2c/smbus_ich9.c
 #define PCI_DEVICE_ID_INTEL_ICH9_7       0x2916
-#define PCI_DEVICE_ID_INTEL_ICH9_8       0x2918
+#define PCI_DEVICE_ID_INTEL_ICH9_8       0x790e // Type: Bridge Device | Category: LPC Controller   | PCI Class: 0x0601 | hw/isa/lpc_ich9.c
 
 #define PCI_DEVICE_ID_INTEL_82801I_UHCI1 0x2934
 #define PCI_DEVICE_ID_INTEL_82801I_UHCI2 0x2935
@@ -273,7 +274,7 @@
 #define PCI_DEVICE_ID_INTEL_82801I_EHCI2 0x293c
 #define PCI_DEVICE_ID_INTEL_82599_SFP_VF 0x10ed
 
-#define PCI_DEVICE_ID_INTEL_P35_MCH      0x29c0
+#define PCI_DEVICE_ID_INTEL_P35_MCH      0x14d8 // Type: Bridge Device | Category: Host Bridge | PCI Class: 0x0600 | hw/pci-host/q35.c
 
 #define PCI_VENDOR_ID_XEN                0x5853
 #define PCI_DEVICE_ID_XEN_PLATFORM       0x0001
diff --git a/include/standard-headers/linux/qemu_fw_cfg.h b/include/standard-headers/linux/qemu_fw_cfg.h
index cb93f66..fe34590 100644
--- a/include/standard-headers/linux/qemu_fw_cfg.h
+++ b/include/standard-headers/linux/qemu_fw_cfg.h
@@ -4,7 +4,7 @@
 
 #include "standard-headers/linux/types.h"
 
-#define FW_CFG_ACPI_DEVICE_ID	"QEMU0002"
+#define FW_CFG_ACPI_DEVICE_ID	"UEFI0002"
 
 /* selector key values for "well-known" fw_cfg entries */
 #define FW_CFG_SIGNATURE	0x00
@@ -71,7 +71,7 @@ struct fw_cfg_file {
 #define FW_CFG_DMA_CTL_SELECT	0x08
 #define FW_CFG_DMA_CTL_WRITE	0x10
 
-#define FW_CFG_DMA_SIGNATURE    0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE    0x51434f4d20434647ULL /* "QCOM CFG" */
 
 /* Control as first field allows for different structures selected by this
  * field, which might be useful in the future
diff --git a/pc-bios/optionrom/optionrom.h b/pc-bios/optionrom/optionrom.h
index 7bcdf0e..02dd06e 100644
--- a/pc-bios/optionrom/optionrom.h
+++ b/pc-bios/optionrom/optionrom.h
@@ -43,7 +43,7 @@
 #define FW_CFG_DMA_CTL_SELECT  0x08
 #define FW_CFG_DMA_CTL_WRITE   0x10
 
-#define FW_CFG_DMA_SIGNATURE 0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE 0x51434f4d20434647ULL /* "QCOM CFG" */
 
 #define BIOS_CFG_DMA_ADDR_HIGH  0x514
 #define BIOS_CFG_DMA_ADDR_LOW   0x518
diff --git a/target/i386/kvm/kvm-cpu.c b/target/i386/kvm/kvm-cpu.c
index 9c25b55..af64a32 100644
--- a/target/i386/kvm/kvm-cpu.c
+++ b/target/i386/kvm/kvm-cpu.c
@@ -174,12 +174,12 @@ static void kvm_cpu_xsave_init(void)
  *       docs/system/target-i386.rst)
  */
 static PropValue kvm_default_props[] = {
-    { "kvmclock", "on" },
-    { "kvm-nopiodelay", "on" },
-    { "kvm-asyncpf", "on" },
-    { "kvm-steal-time", "on" },
-    { "kvm-pv-eoi", "on" },
-    { "kvmclock-stable-bit", "on" },
+    { "kvmclock", "off" },
+    { "kvm-nopiodelay", "off" },
+    { "kvm-asyncpf", "off" },
+    { "kvm-steal-time", "off" },
+    { "kvm-pv-eoi", "off" },
+    { "kvmclock-stable-bit", "off" },
     { "x2apic", "on" },
     { "kvm-msi-ext-dest-id", "off" },
     { "acpi", "off" },

```

`patches/QEMU/Archive/amd-qemu-10.0.2.patch`:

```patch
diff --git a/block/vhdx.c b/block/vhdx.c
index b2a4b813a0..dffe9f8cd8 100644
--- a/block/vhdx.c
+++ b/block/vhdx.c
@@ -2020,7 +2020,7 @@ vhdx_co_create(BlockdevCreateOptions *opts, Error **errp)
 
     /* The creator field is optional, but may be useful for
      * debugging / diagnostics */
-    creator = g_utf8_to_utf16("QEMU v" QEMU_VERSION, -1, NULL,
+    creator = g_utf8_to_utf16("Microsoft v" QEMU_VERSION, -1, NULL,
                               &creator_items, NULL);
     signature = cpu_to_le64(VHDX_FILE_SIGNATURE);
     ret = blk_co_pwrite(blk, VHDX_FILE_ID_OFFSET, sizeof(signature), &signature,
diff --git a/block/vvfat.c b/block/vvfat.c
index 91d69b3cc8..d905d7ef0a 100644
--- a/block/vvfat.c
+++ b/block/vvfat.c
@@ -1176,7 +1176,7 @@ static int vvfat_open(BlockDriverState *bs, QDict *options, int flags,
         }
         memcpy(s->volume_label, label, label_length);
     } else {
-        memcpy(s->volume_label, "QEMU VVFAT", 10);
+        memcpy(s->volume_label, "ASUS VVFAT", 10);
     }
 
     if (floppy) {
diff --git a/chardev/msmouse.c b/chardev/msmouse.c
index 2279694cfa..33cea79a15 100644
--- a/chardev/msmouse.c
+++ b/chardev/msmouse.c
@@ -172,7 +172,7 @@ static int msmouse_chr_write(struct Chardev *s, const uint8_t *buf, int len)
 }
 
 static const QemuInputHandler msmouse_handler = {
-    .name  = "QEMU Microsoft Mouse",
+    .name  = "Microsoft Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = msmouse_input_event,
     .sync  = msmouse_input_sync,
diff --git a/chardev/wctablet.c b/chardev/wctablet.c
index f4008bf35b..6aeccdb2b1 100644
--- a/chardev/wctablet.c
+++ b/chardev/wctablet.c
@@ -179,7 +179,7 @@ static void wctablet_input_sync(DeviceState *dev)
 }
 
 static const QemuInputHandler wctablet_handler = {
-    .name  = "QEMU Wacom Pen Tablet",
+    .name  = "Wacom Pen Tablet",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_ABS,
     .event = wctablet_input_event,
     .sync  = wctablet_input_sync,
diff --git a/contrib/vhost-user-gpu/vhost-user-gpu.c b/contrib/vhost-user-gpu/vhost-user-gpu.c
index bb41758e34..dbd27773c2 100644
--- a/contrib/vhost-user-gpu/vhost-user-gpu.c
+++ b/contrib/vhost-user-gpu/vhost-user-gpu.c
@@ -1254,7 +1254,7 @@ main(int argc, char *argv[])
     QTAILQ_INIT(&g.reslist);
     QTAILQ_INIT(&g.fenceq);
 
-    context = g_option_context_new("QEMU vhost-user-gpu");
+    context = g_option_context_new("vhost-user-gpu");
     g_option_context_add_main_entries(context, entries, NULL);
     if (!g_option_context_parse(context, &argc, &argv, &error)) {
         g_printerr("Option parsing failed: %s\n", error->message);
diff --git a/hw/acpi/aml-build.c b/hw/acpi/aml-build.c
index f8f93a9f66..c39d50d23a 100644
--- a/hw/acpi/aml-build.c
+++ b/hw/acpi/aml-build.c
@@ -1723,11 +1723,11 @@ void acpi_table_begin(AcpiTable *desc, GArray *array)
     build_append_int_noprefix(array, 0, 4); /* Length */
     build_append_int_noprefix(array, desc->rev, 1); /* Revision */
     build_append_int_noprefix(array, 0, 1); /* Checksum */
-    build_append_padded_str(array, desc->oem_id, 6, '\0'); /* OEMID */
+    build_append_padded_str(array, ACPI_BUILD_APPNAME6, 6, '\0'); /* OEMID */
     /* OEM Table ID */
-    build_append_padded_str(array, desc->oem_table_id, 8, '\0');
+    build_append_padded_str(array, ACPI_BUILD_APPNAME8, 8, '\0');
     build_append_int_noprefix(array, 1, 4); /* OEM Revision */
-    g_array_append_vals(array, ACPI_BUILD_APPNAME8, 4); /* Creator ID */
+    g_array_append_vals(array, "ACPI", 4); /* Creator ID */
     build_append_int_noprefix(array, 1, 4); /* Creator Revision */
 }
 
@@ -2248,7 +2248,7 @@ void build_fadt(GArray *tbl, BIOSLinker *linker, const AcpiFadtData *f,
     /* ACPI1.0: INT_MODEL, ACPI2.0+: Reserved */
     build_append_int_noprefix(tbl, f->int_model /* Multiple APIC */, 1);
     /* Preferred_PM_Profile */
-    build_append_int_noprefix(tbl, 0 /* Unspecified */, 1);
+    build_append_int_noprefix(tbl, 1 /* Desktop */, 1);
     build_append_int_noprefix(tbl, f->sci_int, 2); /* SCI_INT */
     build_append_int_noprefix(tbl, f->smi_cmd, 4); /* SMI_CMD */
     build_append_int_noprefix(tbl, f->acpi_enable_cmd, 1); /* ACPI_ENABLE */
@@ -2345,7 +2345,7 @@ void build_fadt(GArray *tbl, BIOSLinker *linker, const AcpiFadtData *f,
     }
 
     /* Hypervisor Vendor Identity */
-    build_append_padded_str(tbl, "QEMU", 8, '\0');
+    build_append_padded_str(tbl, "", 8, '\0');
 
     /* TODO: extra fields need to be added to support revisions above rev6 */
     assert(f->rev == 6);
diff --git a/hw/arm/sbsa-ref.c b/hw/arm/sbsa-ref.c
index aa09d7a091..d249beb694 100644
--- a/hw/arm/sbsa-ref.c
+++ b/hw/arm/sbsa-ref.c
@@ -894,7 +894,7 @@ static void sbsa_ref_class_init(ObjectClass *oc, void *data)
     };
 
     mc->init = sbsa_ref_init;
-    mc->desc = "QEMU 'SBSA Reference' ARM Virtual Machine";
+    mc->desc = "Qualcomm 'Reference' ARM SoC";
     mc->default_cpu_type = ARM_CPU_TYPE_NAME("neoverse-n2");
     mc->valid_cpu_types = valid_cpu_types;
     mc->max_cpus = 512;
diff --git a/hw/arm/virt.c b/hw/arm/virt.c
index a96452f17a..fbb5bc1cd4 100644
--- a/hw/arm/virt.c
+++ b/hw/arm/virt.c
@@ -112,7 +112,7 @@ static void arm_virt_compat_set(MachineClass *mc)
         MachineClass *mc = MACHINE_CLASS(oc); \
         arm_virt_compat_set(mc); \
         MACHINE_VER_SYM(options, virt, __VA_ARGS__)(mc); \
-        mc->desc = "QEMU " MACHINE_VER_STR(__VA_ARGS__) " ARM Virtual Machine"; \
+        mc->desc = "AMD  " MACHINE_VER_STR(__VA_ARGS__) " ARM Machine"; \
         MACHINE_VER_DEPRECATION(__VA_ARGS__); \
         if (latest) { \
             mc->alias = "virt"; \
@@ -1708,13 +1708,13 @@ static void virt_build_smbios(VirtMachineState *vms)
     uint8_t *smbios_tables, *smbios_anchor;
     size_t smbios_tables_len, smbios_anchor_len;
     struct smbios_phys_mem_area mem_array;
-    const char *product = "QEMU Virtual Machine";
+    const char *product = "AMD Machine";
 
     if (kvm_enabled()) {
-        product = "KVM Virtual Machine";
+        product = "AMD Machine";
     }
 
-    smbios_set_defaults("QEMU", product,
+    smbios_set_defaults("Unknown", product,
                         vmc->smbios_old_sys_ver ? "1.0" : mc->name);
 
     /* build the array of physical mem area from base_memmap */
diff --git a/hw/audio/hda-codec.c b/hw/audio/hda-codec.c
index 6f3a8f691b..4af156bf00 100644
--- a/hw/audio/hda-codec.c
+++ b/hw/audio/hda-codec.c
@@ -118,7 +118,7 @@ static void hda_codec_parse_fmt(uint32_t format, struct audsettings *as)
 
 /* some defines */
 
-#define QEMU_HDA_ID_VENDOR  0x1af4
+#define QEMU_HDA_ID_VENDOR  0x10EC
 #define QEMU_HDA_PCM_FORMATS (AC_SUPPCM_BITS_16 |       \
                               0x1fc /* 16 -> 96 kHz */)
 #define QEMU_HDA_AMP_NONE    (0)
diff --git a/hw/audio/intel-hda.c b/hw/audio/intel-hda.c
index 3214992ddc..25b07ae45f 100644
--- a/hw/audio/intel-hda.c
+++ b/hw/audio/intel-hda.c
@@ -1239,7 +1239,7 @@ static void intel_hda_class_init_ich6(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->device_id = 0x2668;
+    k->device_id = 0x51c8; // "Intel 82801IB ICH6 - High Definition Audio [A3]" | Intel Device ID Replacement from 0x2668 | hw/audio/intel-hda.c
     k->revision = 1;
     set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
     dc->desc = "Intel HD Audio Controller (ich6)";
@@ -1250,8 +1250,8 @@ static void intel_hda_class_init_ich9(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->device_id = 0x293e;
-    k->revision = 3;
+    k->device_id = 0x51c8; // "Intel 82801IB ICH9 - High Definition Audio [A3]" | Intel Device ID Replacement from 0x293e | hw/audio/intel-hda.c
+    k->revision = 1;
     set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
     dc->desc = "Intel HD Audio Controller (ich9)";
 }
diff --git a/hw/char/escc.c b/hw/char/escc.c
index a5fdd8f698..0a161a92dc 100644
--- a/hw/char/escc.c
+++ b/hw/char/escc.c
@@ -1037,7 +1037,7 @@ static void sunmouse_sync(DeviceState *dev)
 }
 
 static const QemuInputHandler sunmouse_handler = {
-    .name  = "QEMU Sun Mouse",
+    .name  = "Sun Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = sunmouse_handle_event,
     .sync  = sunmouse_sync,
diff --git a/hw/core/qdev.c b/hw/core/qdev.c
index 2745b5e092..3580cc0902 100644
--- a/hw/core/qdev.c
+++ b/hw/core/qdev.c
@@ -745,7 +745,7 @@ static void device_class_init(ObjectClass *class, void *data)
      * hotpluggable. Devices that shouldn't be hotpluggable,
      * should override it in their class_init()
      */
-    dc->hotpluggable = true;
+    dc->hotpluggable = false;
     dc->user_creatable = true;
     vc->get_id = device_vmstate_if_get_id;
     rc->get_state = device_get_reset_state;
diff --git a/hw/display/edid-generate.c b/hw/display/edid-generate.c
index 2cb819675e..630a33b703 100644
--- a/hw/display/edid-generate.c
+++ b/hw/display/edid-generate.c
@@ -388,22 +388,22 @@ void qemu_edid_generate(uint8_t *edid, size_t size,
     uint8_t *did = NULL;
     uint32_t width_mm, height_mm;
     uint32_t refresh_rate = info->refresh_rate ? info->refresh_rate : 75000;
-    uint32_t dpi = 100; /* if no width_mm/height_mm */
+    uint32_t dpi = 82; /* if no width_mm/height_mm */
     uint32_t large_screen = 0;
 
     /* =============== set defaults  =============== */
 
     if (!info->vendor || strlen(info->vendor) != 3) {
-        info->vendor = "RHT";
+        info->vendor = "MSI";
     }
     if (!info->name) {
-        info->name = "QEMU Monitor";
+        info->name = "G27C4X";
     }
     if (!info->prefx) {
-        info->prefx = 1280;
+        info->prefx = 1920;
     }
     if (!info->prefy) {
-        info->prefy = 800;
+        info->prefy = 1080;
     }
     if (info->width_mm && info->height_mm) {
         width_mm = info->width_mm;
@@ -449,15 +449,15 @@ void qemu_edid_generate(uint8_t *edid, size_t size,
     uint16_t vendor_id = ((((info->vendor[0] - '@') & 0x1f) << 10) |
                           (((info->vendor[1] - '@') & 0x1f) <<  5) |
                           (((info->vendor[2] - '@') & 0x1f) <<  0));
-    uint16_t model_nr = 0x1234;
+    uint16_t model_nr = 0x10ad;
     uint32_t serial_nr = info->serial ? atoi(info->serial) : 0;
     stw_be_p(edid +  8, vendor_id);
     stw_le_p(edid + 10, model_nr);
     stl_le_p(edid + 12, serial_nr);
 
     /* manufacture week and year */
-    edid[16] = 42;
-    edid[17] = 2014 - 1990;
+    edid[16] = 12;
+    edid[17] = 2025 - 2018;
 
     /* edid version */
     edid[18] = 1;
diff --git a/hw/display/qxl.c b/hw/display/qxl.c
index da14da5209..6f9698d777 100644
--- a/hw/display/qxl.c
+++ b/hw/display/qxl.c
@@ -2503,7 +2503,7 @@ static void qxl_pci_class_init(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->vendor_id = REDHAT_PCI_VENDOR_ID;
+    k->vendor_id = PCI_VENDOR_ID_REDHAT;
     k->device_id = QXL_DEVICE_ID_STABLE;
     set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);
     device_class_set_legacy_reset(dc, qxl_reset_handler);
diff --git a/hw/i386/acpi-build.c b/hw/i386/acpi-build.c
index 3fffa4a332..827a5fc0ce 100644
--- a/hw/i386/acpi-build.c
+++ b/hw/i386/acpi-build.c
@@ -1386,6 +1386,68 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,
     build_dbg_aml(dsdt);
     if (i440fx) {
         sb_scope = aml_scope("_SB");
+
+        /*
+         * Emulate Windows ACPI OSYS/_OSI logic in DSDT.
+         * Adds Windows 2001/2006/2009/2012/2013/2015.
+         */
+
+        aml_append(sb_scope, aml_name_decl("OSYS", aml_int(0x03E8)));
+
+        Aml *osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP2")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D2), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001.1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D3), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2006")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D6), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2009")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D9), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2012")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DC), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2013")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DD), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2015")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DF), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
         dev = aml_device("PCI0");
         aml_append(dev, aml_name_decl("_HID", aml_eisaid("PNP0A03")));
         aml_append(dev, aml_name_decl("_UID", aml_int(pcmc->pci_root_uid)));
@@ -1399,6 +1461,68 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,
         build_piix4_pci0_int(dsdt);
     } else if (q35) {
         sb_scope = aml_scope("_SB");
+
+        /*
+         * Emulate Windows ACPI OSYS/_OSI logic in DSDT.
+         * Adds Windows 2001/2006/2009/2012/2013/2015.
+         */
+
+        aml_append(sb_scope, aml_name_decl("OSYS", aml_int(0x03E8)));
+
+        Aml *osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP2")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D2), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001.1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D3), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2006")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D6), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2009")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D9), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2012")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DC), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2013")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DD), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2015")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DF), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
         dev = aml_device("PCI0");
         aml_append(dev, aml_name_decl("_HID", aml_eisaid("PNP0A08")));
         aml_append(dev, aml_name_decl("_CID", aml_eisaid("PNP0A03")));
@@ -1702,7 +1702,7 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,
     /* create fw_cfg node, unconditionally */
     {
         scope = aml_scope("\\_SB.PCI0");
-        fw_cfg_add_acpi_dsdt(scope, x86ms->fw_cfg);
+        //fw_cfg_add_acpi_dsdt(scope, x86ms->fw_cfg); Fix compile error
         aml_append(dsdt, scope);
     }
 
@@ -2146,6 +2166,8 @@ build_dmar_q35(GArray *table_data, BIOSLinker *linker, const char *oem_id,
  *
  * Helpful to speedup Windows guests and ignored by others.
  */
+// Disable WAET device (not found on bare metal systems)
+#if 0
 static void
 build_waet(GArray *table_data, BIOSLinker *linker, const char *oem_id,
            const char *oem_table_id)
@@ -2164,6 +2186,7 @@ build_waet(GArray *table_data, BIOSLinker *linker, const char *oem_id,
     build_append_int_noprefix(table_data, 1 << 1 /* ACPI PM timer good */, 4);
     acpi_table_end(linker, &table);
 }
+#endif
 
 /*
  *   IVRS table as specified in AMD IOMMU Specification v2.62, Section 5.2
@@ -2588,8 +2588,9 @@ void acpi_build(AcpiBuildTables *tables, MachineState *machine)
                        x86ms->oem_id, x86ms->oem_table_id, &pcms->cxl_devices_state);
     }
 
-    acpi_add_table(table_offsets, tables_blob);
-    build_waet(tables_blob, tables->linker, x86ms->oem_id, x86ms->oem_table_id);
+    // Disable WAET table (not found on bare metal systems)
+    // acpi_add_table(table_offsets, tables_blob);
+    // build_waet(tables_blob, tables->linker, x86ms->oem_id, x86ms->oem_table_id);
 
     /* Add tables supplied by user (if any) */
     for (u = acpi_table_first(); u; u = acpi_table_next(u)) {
diff --git a/hw/i386/acpi-microvm.c b/hw/i386/acpi-microvm.c
index 279da6b4aa..8150997210 100644
--- a/hw/i386/acpi-microvm.c
+++ b/hw/i386/acpi-microvm.c
@@ -118,7 +118,7 @@ build_dsdt_microvm(GArray *table_data, BIOSLinker *linker,
     dsdt = init_aml_allocator();
 
     sb_scope = aml_scope("_SB");
-    fw_cfg_add_acpi_dsdt(sb_scope, x86ms->fw_cfg);
+    //fw_cfg_add_acpi_dsdt(sb_scope, x86ms->fw_cfg); Fix compile error
     qbus_build_aml(BUS(isabus), sb_scope);
     build_ged_aml(sb_scope, GED_DEVICE, x86ms->acpi_dev,
                   GED_MMIO_IRQ, AML_SYSTEM_MEMORY, GED_MMIO_BASE);
diff --git a/hw/i386/fw_cfg.c b/hw/i386/fw_cfg.c
index 5c0bcd5f8a..ac471871b5 100644
--- a/hw/i386/fw_cfg.c
+++ b/hw/i386/fw_cfg.c
@@ -75,7 +75,7 @@ void fw_cfg_build_smbios(PCMachineState *pcms, FWCfgState *fw_cfg,
 
     if (pcmc->smbios_defaults) {
         /* These values are guest ABI, do not change */
-        smbios_set_defaults("QEMU", mc->desc, mc->name);
+        smbios_set_defaults("Unknown", mc->desc, mc->name);
     }
 
     /* tell smbios about cpuid version and features */
@@ -212,6 +212,8 @@ void fw_cfg_build_feature_control(MachineState *ms, FWCfgState *fw_cfg)
     fw_cfg_add_file(fw_cfg, "etc/msr_feature_control", val, sizeof(*val));
 }
 
+// Disable FWCF device (not found on bare metal systems)
+#if 0
 #ifdef CONFIG_ACPI
 void fw_cfg_add_acpi_dsdt(Aml *scope, FWCfgState *fw_cfg)
 {
@@ -240,3 +242,4 @@ void fw_cfg_add_acpi_dsdt(Aml *scope, FWCfgState *fw_cfg)
     aml_append(scope, dev);
 }
 #endif
+#endif
diff --git a/hw/i386/multiboot.c b/hw/i386/multiboot.c
index cd07a05861..9ca77b873a 100644
--- a/hw/i386/multiboot.c
+++ b/hw/i386/multiboot.c
@@ -102,7 +102,7 @@ typedef struct {
     int mb_mods_count;
 } MultibootState;
 
-const char *bootloader_name = "qemu";
+const char *bootloader_name = "Windows Boot Manager";
 
 static uint32_t mb_add_cmdline(MultibootState *s, const char *cmdline)
 {
diff --git a/hw/i386/pc.c b/hw/i386/pc.c
index 01d0581f62..ab00078708 100644
--- a/hw/i386/pc.c
+++ b/hw/i386/pc.c
@@ -75,9 +75,9 @@
  * depending on QEMU versions up to QEMU 2.4.
  */
 #define PC_CPU_MODEL_IDS(v) \
-    { "qemu32-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },\
-    { "qemu64-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },\
-    { "athlon-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },
+    { "qemu32-" TYPE_X86_CPU, "model-id", "CPU version " v, },\
+    { "qemu64-" TYPE_X86_CPU, "model-id", "CPU version " v, },\
+    { "athlon-" TYPE_X86_CPU, "model-id", "CPU version " v, },
 
 GlobalProperty pc_compat_9_2[] = {};
 const size_t pc_compat_9_2_len = G_N_ELEMENTS(pc_compat_9_2);
@@ -1771,7 +1771,7 @@ static void pc_machine_class_init(ObjectClass *oc, void *data)
 
     pcmc->pci_enabled = true;
     pcmc->has_acpi_build = true;
-    pcmc->smbios_defaults = true;
+    pcmc->smbios_defaults = false;
     pcmc->gigabyte_align = true;
     pcmc->has_reserved_memory = true;
     pcmc->enforce_amd_1tb_hole = true;
diff --git a/hw/i386/pc_piix.c b/hw/i386/pc_piix.c
index 6c91e2d292..dfa897c8fb 100644
--- a/hw/i386/pc_piix.c
+++ b/hw/i386/pc_piix.c
@@ -460,12 +460,12 @@ static void pc_i440fx_machine_options(MachineClass *m)
     pcmc->pci_root_uid = 0;
     pcmc->default_cpu_version = 1;
 
-    m->family = "pc_piix";
-    m->desc = "Standard PC (i440FX + PIIX, 1996)";
+    m->family = "pc_x570";
+    m->desc = "AMD Ryzen 7 7700X 8-Core Processor";
     m->default_machine_opts = "firmware=bios-256k.bin";
-    m->default_display = "std";
-    m->default_nic = "e1000";
-    m->no_floppy = !module_object_class_by_name(TYPE_ISA_FDC);
+    m->default_display = "none";
+    m->default_nic = "rtl8139"; // Realtek PCI Express Gigabit Ethernet Controller
+    m->no_floppy = 1;
     m->no_parallel = !module_object_class_by_name(TYPE_ISA_PARALLEL);
     machine_class_allow_dynamic_sysbus_dev(m, TYPE_RAMFB_DEVICE);
     machine_class_allow_dynamic_sysbus_dev(m, TYPE_VMBUS_BRIDGE);
@@ -509,7 +509,7 @@ static void pc_i440fx_machine_9_0_options(MachineClass *m)
     PCMachineClass *pcmc = PC_MACHINE_CLASS(m);
 
     pc_i440fx_machine_9_1_options(m);
-    m->smbios_memory_device_size = 16 * GiB;
+    m->smbios_memory_device_size = 8 * GiB; // Default is 16GB per stick; Change to more common 8 GB per stick instead.
 
     compat_props_add(m->compat_props, hw_compat_9_0, hw_compat_9_0_len);
     compat_props_add(m->compat_props, pc_compat_9_0, pc_compat_9_0_len);
diff --git a/hw/i386/pc_q35.c b/hw/i386/pc_q35.c
index fd96d0345c..3ff65e93bb 100644
--- a/hw/i386/pc_q35.c
+++ b/hw/i386/pc_q35.c
@@ -342,12 +342,12 @@ static void pc_q35_machine_options(MachineClass *m)
     pcmc->pci_root_uid = 0;
     pcmc->default_cpu_version = 1;
 
-    m->family = "pc_q35";
-    m->desc = "Standard PC (Q35 + ICH9, 2009)";
+    m->family = "pc_x570";
+    m->desc = "AMD Ryzen 7 7700X 8-Core Processor";
     m->units_per_default_bus = 1;
     m->default_machine_opts = "firmware=bios-256k.bin";
-    m->default_display = "std";
-    m->default_nic = "e1000e";
+    m->default_display = "none";
+    m->default_nic = "rtl8139"; // Realtek PCI Express Gigabit Ethernet Controller
     m->default_kernel_irqchip_split = false;
     m->no_floppy = 1;
     m->max_cpus = 4096;
@@ -390,7 +390,7 @@ static void pc_q35_machine_9_0_options(MachineClass *m)
 {
     PCMachineClass *pcmc = PC_MACHINE_CLASS(m);
     pc_q35_machine_9_1_options(m);
-    m->smbios_memory_device_size = 16 * GiB;
+    m->smbios_memory_device_size = 8 * GiB; // Default is 16GB per stick; Change to more common 8 GB per stick instead.
     compat_props_add(m->compat_props, hw_compat_9_0, hw_compat_9_0_len);
     compat_props_add(m->compat_props, pc_compat_9_0, pc_compat_9_0_len);
     pcmc->isa_bios_alias = false;
diff --git a/hw/ide/atapi.c b/hw/ide/atapi.c
index a42b748521..c10cf51347 100644
--- a/hw/ide/atapi.c
+++ b/hw/ide/atapi.c
@@ -798,8 +798,8 @@ static void cmd_inquiry(IDEState *s, uint8_t *buf)
         buf[5] = 0;    /* reserved */
         buf[6] = 0;    /* reserved */
         buf[7] = 0;    /* reserved */
-        padstr8(buf + 8, 8, "QEMU");
-        padstr8(buf + 16, 16, "QEMU DVD-ROM");
+        padstr8(buf + 8, 8, "Samsung");
+        padstr8(buf + 16, 16, "DVD-ROM");
         padstr8(buf + 32, 4, s->version);
         idx = 36;
     }
diff --git a/hw/ide/core.c b/hw/ide/core.c
index b14983ec54..3d824d3e21 100644
--- a/hw/ide/core.c
+++ b/hw/ide/core.c
@@ -2638,21 +2638,20 @@ int ide_init_drive(IDEState *s, IDEDevice *dev, IDEDriveKind kind, Error **errp)
     if (dev->serial) {
         pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), dev->serial);
     } else {
-        snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),
-                 "QM%05d", s->drive_serial);
+        s->drive_serial_str[0] = '\0';  // Empty string fallback instead of QEMU default
     }
     if (dev->model) {
         pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), dev->model);
     } else {
         switch (kind) {
         case IDE_CD:
-            strcpy(s->drive_model_str, "QEMU DVD-ROM");
+            strcpy(s->drive_model_str, "HL-DT-ST BD-RE WH16NS60");
             break;
         case IDE_CFATA:
-            strcpy(s->drive_model_str, "QEMU MICRODRIVE");
+            strcpy(s->drive_model_str, "Hitachi HMS360404D5CF00");
             break;
         default:
-            strcpy(s->drive_model_str, "QEMU HARDDISK");
+            strcpy(s->drive_model_str, "Samsung SSD 980 500GB");
             break;
         }
     }
diff --git a/hw/input/adb-kbd.c b/hw/input/adb-kbd.c
index 3649d03ef2..6eec61f547 100644
--- a/hw/input/adb-kbd.c
+++ b/hw/input/adb-kbd.c
@@ -356,7 +356,7 @@ static void adb_kbd_reset(DeviceState *dev)
 }
 
 static const QemuInputHandler adb_keyboard_handler = {
-    .name  = "QEMU ADB Keyboard",
+    .name  = "ADB Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = adb_keyboard_event,
 };
diff --git a/hw/input/adb-mouse.c b/hw/input/adb-mouse.c
index 77b280d242..7dc777f6e1 100644
--- a/hw/input/adb-mouse.c
+++ b/hw/input/adb-mouse.c
@@ -94,7 +94,7 @@ static void adb_mouse_handle_event(DeviceState *dev, QemuConsole *src,
 }
 
 static const QemuInputHandler adb_mouse_handler = {
-    .name  = "QEMU ADB Mouse",
+    .name  = "ADB Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = adb_mouse_handle_event,
     /*
diff --git a/hw/input/hid.c b/hw/input/hid.c
index 76bedc1844..7fc2f72819 100644
--- a/hw/input/hid.c
+++ b/hw/input/hid.c
@@ -511,20 +511,20 @@ void hid_free(HIDState *hs)
 }
 
 static const QemuInputHandler hid_keyboard_handler = {
-    .name  = "QEMU HID Keyboard",
+    .name  = "HID Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = hid_keyboard_event,
 };
 
 static const QemuInputHandler hid_mouse_handler = {
-    .name  = "QEMU HID Mouse",
+    .name  = "HID Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = hid_pointer_event,
     .sync  = hid_pointer_sync,
 };
 
 static const QemuInputHandler hid_tablet_handler = {
-    .name  = "QEMU HID Tablet",
+    .name  = "HID Tablet",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_ABS,
     .event = hid_pointer_event,
     .sync  = hid_pointer_sync,
diff --git a/hw/input/ps2.c b/hw/input/ps2.c
index 6a41b024c8..7f60d25494 100644
--- a/hw/input/ps2.c
+++ b/hw/input/ps2.c
@@ -1232,7 +1232,7 @@ static const VMStateDescription vmstate_ps2_mouse = {
 };
 
 static const QemuInputHandler ps2_keyboard_handler = {
-    .name  = "QEMU PS/2 Keyboard",
+    .name  = "PS/2 Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = ps2_keyboard_event,
 };
@@ -1243,7 +1243,7 @@ static void ps2_kbd_realize(DeviceState *dev, Error **errp)
 }
 
 static const QemuInputHandler ps2_mouse_handler = {
-    .name  = "QEMU PS/2 Mouse",
+    .name  = "PS/2 Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = ps2_mouse_event,
     .sync  = ps2_mouse_sync,
diff --git a/hw/input/virtio-input-hid.c b/hw/input/virtio-input-hid.c
index 812faaef8f..4d38dc0597 100644
--- a/hw/input/virtio-input-hid.c
+++ b/hw/input/virtio-input-hid.c
@@ -16,10 +16,10 @@
 
 #include "standard-headers/linux/input.h"
 
-#define VIRTIO_ID_NAME_KEYBOARD     "QEMU Virtio Keyboard"
-#define VIRTIO_ID_NAME_MOUSE        "QEMU Virtio Mouse"
-#define VIRTIO_ID_NAME_TABLET       "QEMU Virtio Tablet"
-#define VIRTIO_ID_NAME_MULTITOUCH   "QEMU Virtio MultiTouch"
+#define VIRTIO_ID_NAME_KEYBOARD     "Keyboard"
+#define VIRTIO_ID_NAME_MOUSE        "Mouse"
+#define VIRTIO_ID_NAME_TABLET       "Tablet"
+#define VIRTIO_ID_NAME_MULTITOUCH   "MultiTouch"
 
 /* ----------------------------------------------------------------- */
 
@@ -281,7 +281,7 @@ static struct virtio_input_config virtio_keyboard_config[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x046d), /* same we use for usb hid devices */
             .product = const_le16(0x0001),
             .version = const_le16(0x0001),
         },
@@ -338,7 +338,7 @@ static struct virtio_input_config virtio_mouse_config_v1[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x046d), /* same we use for usb hid devices */
             .product = const_le16(0x0002),
             .version = const_le16(0x0001),
         },
@@ -363,7 +363,7 @@ static struct virtio_input_config virtio_mouse_config_v2[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x046d), /* same we use for usb hid devices */
             .product = const_le16(0x0002),
             .version = const_le16(0x0002),
         },
@@ -431,7 +431,7 @@ static struct virtio_input_config virtio_tablet_config_v1[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x056a), /* same we use for usb hid devices */
             .product = const_le16(0x0003),
             .version = const_le16(0x0001),
         },
@@ -468,7 +468,7 @@ static struct virtio_input_config virtio_tablet_config_v2[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x056a), /* same we use for usb hid devices */
             .product = const_le16(0x0003),
             .version = const_le16(0x0002),
         },
@@ -555,7 +555,7 @@ static struct virtio_input_config virtio_multitouch_config[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x056a), /* same we use for usb hid devices */
             .product = const_le16(0x0003),
             .version = const_le16(0x0001),
         },
diff --git a/hw/loongarch/virt.c b/hw/loongarch/virt.c
index 65c9027feb..173a74095d 100644
--- a/hw/loongarch/virt.c
+++ b/hw/loongarch/virt.c
@@ -129,13 +129,13 @@ static void virt_build_smbios(LoongArchVirtMachineState *lvms)
     MachineClass *mc = MACHINE_GET_CLASS(lvms);
     uint8_t *smbios_tables, *smbios_anchor;
     size_t smbios_tables_len, smbios_anchor_len;
-    const char *product = "QEMU Virtual Machine";
+    const char *product = "AMD Machine";
 
     if (!lvms->fw_cfg) {
         return;
     }
 
-    smbios_set_defaults("QEMU", product, mc->name);
+    smbios_set_defaults("Unknown", product, mc->name);
 
     smbios_get_tables(ms, SMBIOS_ENTRY_POINT_TYPE_64,
                       NULL, 0,
diff --git a/hw/m68k/virt.c b/hw/m68k/virt.c
index d967bdd743..8214be2554 100644
--- a/hw/m68k/virt.c
+++ b/hw/m68k/virt.c
@@ -312,7 +312,7 @@ static void virt_init(MachineState *machine)
 static void virt_machine_class_init(ObjectClass *oc, void *data)
 {
     MachineClass *mc = MACHINE_CLASS(oc);
-    mc->desc = "QEMU M68K Virtual Machine";
+    mc->desc = "AMD M68K Machine";
     mc->init = virt_init;
     mc->default_cpu_type = M68K_CPU_TYPE_NAME("m68040");
     mc->max_cpus = 1;
@@ -342,7 +342,7 @@ type_init(virt_machine_register_types)
     { \
         MachineClass *mc = MACHINE_CLASS(oc); \
         MACHINE_VER_SYM(options, virt, __VA_ARGS__)(mc); \
-        mc->desc = "QEMU " MACHINE_VER_STR(__VA_ARGS__) " M68K Virtual Machine"; \
+        mc->desc = "AMD  " MACHINE_VER_STR(__VA_ARGS__) " M68K Machine"; \
         MACHINE_VER_DEPRECATION(__VA_ARGS__); \
         if (latest) { \
             mc->alias = "virt"; \
diff --git a/hw/misc/applesmc.c b/hw/misc/applesmc.c
index 97ea842d60..e38ab7ac5d 100644
--- a/hw/misc/applesmc.c
+++ b/hw/misc/applesmc.c
@@ -85,8 +85,7 @@ enum {
 #define smc_debug(...) do { } while (0)
 #endif
 
-static char default_osk[64] = "This is a dummy key. Enter the real key "
-                              "using the -osk parameter";
+static char default_osk[64] = "ourhardworkbythesewordsguardedpleasedontsteal(c)AppleComputerInc";
 
 struct AppleSMCData {
     uint8_t len;
diff --git a/hw/misc/pvpanic-isa.c b/hw/misc/pvpanic-isa.c
index c3713dc5c4..26aeab2b2a 100644
--- a/hw/misc/pvpanic-isa.c
+++ b/hw/misc/pvpanic-isa.c
@@ -69,7 +69,7 @@ static void build_pvpanic_isa_aml(AcpiDevAmlIf *adev, Aml *scope)
     PVPanicISAState *s = PVPANIC_ISA_DEVICE(adev);
     Aml *dev = aml_device("PEVT");
 
-    aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0001")));
+    aml_append(dev, aml_name_decl("_HID", aml_string("UEFI0001")));
 
     crs = aml_resource_template();
     aml_append(crs,
diff --git a/hw/nvme/ctrl.c b/hw/nvme/ctrl.c
index d6b77d4fbc..8d43136df4 100644
--- a/hw/nvme/ctrl.c
+++ b/hw/nvme/ctrl.c
@@ -8786,7 +8786,7 @@ static void nvme_init_ctrl(NvmeCtrl *n, PCIDevice *pci_dev)
 
     id->vid = cpu_to_le16(pci_get_word(pci_conf + PCI_VENDOR_ID));
     id->ssvid = cpu_to_le16(pci_get_word(pci_conf + PCI_SUBSYSTEM_VENDOR_ID));
-    strpadcpy((char *)id->mn, sizeof(id->mn), "QEMU NVMe Ctrl", ' ');
+    strpadcpy((char *)id->mn, sizeof(id->mn), "NVMe Ctrl", ' ');
     strpadcpy((char *)id->fr, sizeof(id->fr), QEMU_VERSION, ' ');
     strpadcpy((char *)id->sn, sizeof(id->sn), n->params.serial, ' ');
 
diff --git a/hw/nvram/fw_cfg-acpi.c b/hw/nvram/fw_cfg-acpi.c
index 2e6ef89b98..bb5a6f46b0 100644
--- a/hw/nvram/fw_cfg-acpi.c
+++ b/hw/nvram/fw_cfg-acpi.c
@@ -11,7 +11,7 @@
 void fw_cfg_acpi_dsdt_add(Aml *scope, const MemMapEntry *fw_cfg_memmap)
 {
     Aml *dev = aml_device("FWCF");
-    aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0002")));
+    aml_append(dev, aml_name_decl("_HID", aml_string("UEFI0002")));
     /* device present, functioning, decoding, not shown in UI */
     aml_append(dev, aml_name_decl("_STA", aml_int(0xB)));
     aml_append(dev, aml_name_decl("_CCA", aml_int(1)));
diff --git a/hw/nvram/fw_cfg.c b/hw/nvram/fw_cfg.c
index a757939cfb..234068884a 100644
--- a/hw/nvram/fw_cfg.c
+++ b/hw/nvram/fw_cfg.c
@@ -56,7 +56,7 @@
 #define FW_CFG_DMA_CTL_SELECT  0x08
 #define FW_CFG_DMA_CTL_WRITE   0x10
 
-#define FW_CFG_DMA_SIGNATURE 0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE 0x51434f4d20434647ULL /* "QCOM CFG" */
 
 struct FWCfgEntry {
     uint32_t len;
@@ -1096,7 +1096,7 @@ static void fw_cfg_common_realize(DeviceState *dev, Error **errp)
         return;
     }
 
-    fw_cfg_add_bytes(s, FW_CFG_SIGNATURE, (char *)"QEMU", 4);
+    fw_cfg_add_bytes(s, FW_CFG_SIGNATURE, (char *)"QEMU", 4); // "QEMU"
     fw_cfg_add_bytes(s, FW_CFG_UUID, &qemu_uuid, 16);
     fw_cfg_add_i16(s, FW_CFG_NOGRAPHIC, (uint16_t)!machine->enable_graphics);
     fw_cfg_add_i16(s, FW_CFG_BOOT_MENU, (uint16_t)(machine->boot_config.has_menu && machine->boot_config.menu));
diff --git a/hw/pci-host/gpex.c b/hw/pci-host/gpex.c
index 9fcedd7fc5..4634d13e27 100644
--- a/hw/pci-host/gpex.c
+++ b/hw/pci-host/gpex.c
@@ -243,7 +243,7 @@ static void gpex_root_class_init(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
 
     set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
-    dc->desc = "QEMU generic PCIe host bridge";
+    dc->desc = "Generic PCIe host bridge";
     dc->vmsd = &vmstate_gpex_root;
     k->vendor_id = PCI_VENDOR_ID_REDHAT;
     k->device_id = PCI_DEVICE_ID_REDHAT_PCIE_HOST;
diff --git a/hw/ppc/e500plat.c b/hw/ppc/e500plat.c
index 70a8033373..57192459f5 100644
--- a/hw/ppc/e500plat.c
+++ b/hw/ppc/e500plat.c
@@ -22,7 +22,7 @@
 
 static void e500plat_fixup_devtree(void *fdt)
 {
-    const char model[] = "QEMU ppce500";
+    const char model[] = "ppce500";
     const char compatible[] = "fsl,qemu-e500";
 
     qemu_fdt_setprop(fdt, "/", "model", model, sizeof(model));
diff --git a/hw/ppc/pnv.c b/hw/ppc/pnv.c
index 63f2232f32..6ef698562f 100644
--- a/hw/ppc/pnv.c
+++ b/hw/ppc/pnv.c
@@ -652,7 +652,7 @@ static void *pnv_dt_create(MachineState *machine)
     _FDT((fdt_create_empty_tree(fdt, FDT_MAX_SIZE)));
 
     /* /qemu node */
-    _FDT((fdt_add_subnode(fdt, 0, "qemu")));
+    _FDT((fdt_add_subnode(fdt, 0, "qemu"))); // "qemu"
 
     /* Root node */
     _FDT((fdt_setprop_cell(fdt, 0, "#address-cells", 0x2)));
diff --git a/hw/scsi/mptconfig.c b/hw/scsi/mptconfig.c
index 19d01f39fa..00ee3f80e5 100644
--- a/hw/scsi/mptconfig.c
+++ b/hw/scsi/mptconfig.c
@@ -189,12 +189,12 @@ static
 size_t mptsas_config_manufacturing_0(MPTSASState *s, uint8_t **data, int address)
 {
     return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,
-                              "s16s8s16s16s16",
-                              "QEMU MPT Fusion",
+                              "s10s4s85s45s34",
+                              "MPT Fusion",
                               "2.5",
-                              "QEMU MPT Fusion",
-                              "QEMU",
-                              "0000111122223333");
+                              "MPT Fusion",
+                              "MSI",
+                              "7624862998526197");
 }
 
 static
diff --git a/hw/scsi/scsi-bus.c b/hw/scsi/scsi-bus.c
index ece1107ee8..466ee7b439 100644
--- a/hw/scsi/scsi-bus.c
+++ b/hw/scsi/scsi-bus.c
@@ -698,8 +698,8 @@ static bool scsi_target_emulate_inquiry(SCSITargetReq *r)
         r->buf[3] = 2 | 0x10; /* HiSup, response data format */
         r->buf[4] = r->len - 5; /* Additional Length = (Len - 1) - 4 */
         r->buf[7] = 0x10 | (r->req.bus->info->tcq ? 0x02 : 0); /* Sync, TCQ.  */
-        memcpy(&r->buf[8], "QEMU    ", 8);
-        memcpy(&r->buf[16], "QEMU TARGET     ", 16);
+        memcpy(&r->buf[8], "MSI     ", 8);
+        memcpy(&r->buf[16], "MSI TARGET      ", 16);
         pstrcpy((char *) &r->buf[32], 4, qemu_hw_version());
     }
     return true;
diff --git a/hw/scsi/scsi-disk.c b/hw/scsi/scsi-disk.c
index e59632e9b1..79937fb6a5 100644
--- a/hw/scsi/scsi-disk.c
+++ b/hw/scsi/scsi-disk.c
@@ -2568,7 +2568,7 @@ static void scsi_realize(SCSIDevice *dev, Error **errp)
         s->version = g_strdup(qemu_hw_version());
     }
     if (!s->vendor) {
-        s->vendor = g_strdup("QEMU");
+        s->vendor = g_strdup("Samsung");
     }
     if (s->serial && strlen(s->serial) > MAX_SERIAL_LEN) {
         error_setg(errp, "The serial number can't be longer than %d characters",
@@ -2632,7 +2632,7 @@ static void scsi_hd_realize(SCSIDevice *dev, Error **errp)
     s->qdev.blocksize = s->qdev.conf.logical_block_size;
     s->qdev.type = TYPE_DISK;
     if (!s->product) {
-        s->product = g_strdup("QEMU HARDDISK");
+        s->product = g_strdup("Samsung SSD 980 500GB");
     }
     scsi_realize(&s->qdev, errp);
 }
@@ -2659,7 +2659,7 @@ static void scsi_cd_realize(SCSIDevice *dev, Error **errp)
     s->qdev.type = TYPE_ROM;
     s->features |= 1 << SCSI_DISK_F_REMOVABLE;
     if (!s->product) {
-        s->product = g_strdup("QEMU CD-ROM");
+        s->product = g_strdup("CD-ROM");
     }
     scsi_realize(&s->qdev, errp);
 }
diff --git a/hw/scsi/spapr_vscsi.c b/hw/scsi/spapr_vscsi.c
index 6962194eaa..fc69916d84 100644
--- a/hw/scsi/spapr_vscsi.c
+++ b/hw/scsi/spapr_vscsi.c
@@ -713,8 +713,8 @@ static void vscsi_inquiry_no_target(VSCSIState *s, vscsi_req *req)
     resp_data[3] = 0x02;   /* Resp data format */
     resp_data[4] = 36 - 5; /* Additional length */
     resp_data[7] = 0x10;   /* Sync transfers */
-    memcpy(&resp_data[16], "QEMU EMPTY      ", 16);
-    memcpy(&resp_data[8], "QEMU    ", 8);
+    memcpy(&resp_data[16], "MSI EMPTY       ", 16);
+    memcpy(&resp_data[8], "MSI     ", 8);
 
     req->writing = 0;
     vscsi_preprocess_desc(req);
@@ -971,7 +971,7 @@ static int vscsi_send_adapter_info(VSCSIState *s, vscsi_req *req)
 #endif
     memset(&info, 0, sizeof(info));
     strcpy(info.srp_version, SRP_VERSION);
-    memcpy(info.partition_name, "qemu", sizeof("qemu"));
+    memcpy(info.partition_name, "msi", sizeof("msi"));
     info.partition_number = cpu_to_be32(0);
     info.mad_version = cpu_to_be32(1);
     info.os_type = cpu_to_be32(2);
diff --git a/hw/smbios/smbios.c b/hw/smbios/smbios.c
index ad4cd6721e..597000923a 100644
--- a/hw/smbios/smbios.c
+++ b/hw/smbios/smbios.c
@@ -68,7 +68,8 @@ static struct {
  * 0 which counts as unknown (SMBIOS 3.1.0/Table 21). Set the
  * default value to 2000MHz as we did before.
  */
-#define DEFAULT_CPU_SPEED 2000
+#define DEFAULT_CPU_SPEED 3600
+#define DEFAULT_BOOST_CPU_SPEED 4400
 
 static struct {
     uint16_t processor_family;
@@ -77,7 +78,7 @@ static struct {
     uint64_t current_speed;
     uint64_t processor_id;
 } type4 = {
-    .max_speed = DEFAULT_CPU_SPEED,
+    .max_speed = DEFAULT_BOOST_CPU_SPEED,
     .current_speed = DEFAULT_CPU_SPEED,
     .processor_id = 0,
     .processor_family = 0x01, /* Other */
@@ -565,18 +566,91 @@ static void smbios_build_type_0_table(void)
     SMBIOS_TABLE_SET_STR(0, vendor_str, smbios_type0.vendor);
     SMBIOS_TABLE_SET_STR(0, bios_version_str, smbios_type0.version);
 
-    t->bios_starting_address_segment = cpu_to_le16(0xE800); /* from SeaBIOS */
+    t->bios_starting_address_segment = cpu_to_le16(0xE000); /* from SeaBIOS */
 
     SMBIOS_TABLE_SET_STR(0, bios_release_date_str, smbios_type0.date);
 
-    t->bios_rom_size = 0; /* hardcoded in SeaBIOS with FIXME comment */
-
-    t->bios_characteristics = cpu_to_le64(0x08); /* Not supported */
-    t->bios_characteristics_extension_bytes[0] = 0;
-    t->bios_characteristics_extension_bytes[1] = 0x14; /* TCD/SVVP | VM */
+    t->bios_rom_size = 0xFF; /* hardcoded in SeaBIOS with FIXME comment */
+
+    t->bios_characteristics = cpu_to_le64(0x001A00004BF99880); /*
+
+    Table 7 â€“ Firmware Characteristics: https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A238%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C150%2C0%5D
+
+    Hex    = 0x001A00004BF99880
+    Binary = 0b0000000000011010000000000000000001001011111110011001100010000000
+
+    Bit0  = Reserved - 0 (No)
+    Bit1  = Reserved - 0 (No)
+    Bit2  = Unknown - 0 (No)
+    Bit3  = BIOS Characteristics Not Supported - 0 (No)
+    Bit4  = ISA is supported - 0 (No)
+    Bit5  = MCA is supported - 0 (No)
+    Bit6  = EISA is supported - 0 (No)
+    Bit7  = PCI is supported - 1 (Yes)
+    Bit8  = PC Card (PCMCIA) is supported - 0 (No)
+    Bit9  = Plug and Play is supported - 0 (No)
+    Bit10 = APM is supported - 0 (No)
+    Bit11 = BIOS is Upgradeable (Flash) - 1 (Yes)
+    Bit12 = BIOS shadowing is allowed - 1 (Yes)
+    Bit13 = VL-VESA is supported - 0 (No)
+    Bit14 = ESCD support is available - 0 (No)
+    Bit15 = Boot from CD is supported - 1 (Yes)
+    Bit16 = Selectable Boot is supported - 1 (Yes)
+    Bit17 = BIOS ROM is socketed - 0 (No)
+    Bit18 = Boot From PC Card (PCMCIA) is supported - 0 (No)
+    Bit19 = EDD (Enhanced Disk Drive) Specification is supported - 1 (Yes)
+    Bit20 = Int 13h - Japanese Floppy for NEC 9800 1.2mb (3.5", 1k Bytes/Sector, 360 RPM) is supported - 1 (Yes)
+    Bit21 = Int 13h - Japanese Floppy for Toshiba 1.2mb (3.5", 360 RPM) is supported - 1 (Yes)
+    Bit22 = Int 13h - 5.25" / 360 KB Floppy Services are supported - 1 (Yes)
+    Bit23 = Int 13h - 5.25" / 1.2MB Floppy Services are supported - 1 (Yes)
+    Bit24 = Int 13h - 3.5" / 720 KB Floppy Services are supported - 1 (Yes)
+    Bit25 = Int 13h - 3.5" / 2.88 MB Floppy Services are supported - 1 (Yes)
+    Bit26 = Int 5h, Print Screen Service is supported - 0 (No)
+    Bit27 = Int 9h, 8042 Keyboard services are supported - 1 (Yes)
+    Bit28 = Int 14h, Serial Services are supported - 0 (No)
+    Bit29 = Int 17h, Printer Services are supported - 0 (No)
+    Bit30 = Int 10h, CGA/Mono Video Services are supported - 1 (Yes)
+    Bit31 = NEC PC-98 - 0 (No)
+
+    */
+
+    t->bios_characteristics_extension_bytes[0] = 0x03; /*
+
+    Table 8 â€“ Firmware Characteristics Extension Byte 1
+    https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A244%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C720%2C0%5D
+
+    Hex    = 0x03
+    Binary = 0b00000011
+
+    Bit0 = ACPI supported - 1 (Yes)
+    Bit1 = USB Legacy is supported - 1 (Yes)
+    Bit2 = AGP is supported - 0 (No)
+    Bit3 = I2O boot is supported - 0 (No)
+    Bit4 = LS-120 boot is supported - 0 (No)
+    Bit5 = ATAPI ZIP Drive boot is supported - 0 (No)
+    Bit6 = 1394 boot is supported - 0 (No)
+    Bit7 = Smart Battery supported - 0 (No)
+
+    */
+
+    t->bios_characteristics_extension_bytes[1] = 0x0D; /*  */
     if (smbios_type0.uefi) {
-        t->bios_characteristics_extension_bytes[1] |= 0x08; /* |= UEFI */
-    }
+        t->bios_characteristics_extension_bytes[1] |= 0x0D; /* |= UEFI */
+    } /*
+
+    Table 9 â€“ Firmware Characteristics Extension Byte 2
+    https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A244%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C483%2C0%5D
+
+    Hex    = 0x0D
+    Binary = 0b00001101
+
+    Bit0 = BIOS Boot Specification supported - 1 (Yes)
+    Bit1 = Function key-initiated Network Service boot supported - 0 (No)
+    Bit2 = Enable Targeted Content Distribution - 1 (Yes)
+    Bit3 = UEFI Specification is supported - 1 (Yes)
+    Bit4 = SMBIOS table describes a virtual machine - 0 (No)
+
+    */
 
     if (smbios_type0.have_major_minor) {
         t->system_bios_major_release = smbios_type0.major;
@@ -633,9 +707,9 @@ static void smbios_build_type_2_table(void)
     SMBIOS_TABLE_SET_STR(2, version_str, type2.version);
     SMBIOS_TABLE_SET_STR(2, serial_number_str, type2.serial);
     SMBIOS_TABLE_SET_STR(2, asset_tag_number_str, type2.asset);
-    t->feature_flags = 0x01; /* Motherboard */
+    t->feature_flags = 0x09; /* Motherboard */
     SMBIOS_TABLE_SET_STR(2, location_str, type2.location);
-    t->chassis_handle = cpu_to_le16(0x300); /* Type 3 (System enclosure) */
+    t->chassis_handle = cpu_to_le16(0x0003); /* Type 3 (System enclosure) */
     t->board_type = 0x0A; /* Motherboard */
     t->contained_element_count = 0;
 
@@ -665,7 +739,7 @@ static void smbios_build_type_3_table(void)
     SMBIOS_BUILD_TABLE_POST;
 }
 
-static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
+static void smbios_build_type_4_table(MachineState *ms, unsigned instance, unsigned socket_count,
                                       SmbiosEntryPointType ep_type,
                                       Error **errp)
 {
@@ -681,10 +755,13 @@ static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
     SMBIOS_BUILD_TABLE_PRE_SIZE(4, T4_BASE + instance,
                                 true, tbl_len); /* required */
 
-    snprintf(sock_str, sizeof(sock_str), "%s%2x", type4.sock_pfx, instance);
+    if (socket_count > 1)
+        snprintf(sock_str, sizeof(sock_str), "%s%2x", type4.sock_pfx, instance);
+    else
+        snprintf(sock_str, sizeof(sock_str), "%s", type4.sock_pfx);
     SMBIOS_TABLE_SET_STR(4, socket_designation_str, sock_str);
-    t->processor_type = 0x03; /* CPU */
-    t->processor_family = 0xfe; /* use Processor Family 2 field */
+    t->processor_type = 0x03; /* Central Processor */
+    t->processor_family = 0xCB; /* AMD Ryzen 5 processor */
     SMBIOS_TABLE_SET_STR(4, processor_manufacturer_str, type4.manufacturer);
     if (type4.processor_id == 0) {
         t->processor_id[0] = cpu_to_le32(smbios_cpuid_version);
@@ -694,15 +771,15 @@ static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
         t->processor_id[1] = cpu_to_le32(type4.processor_id >> 32);
     }
     SMBIOS_TABLE_SET_STR(4, processor_version_str, type4.version);
-    t->voltage = 0;
-    t->external_clock = cpu_to_le16(0); /* Unknown */
+    t->voltage = 0x8B; // Bit 7 is set for modern cpus, the last bits indicate the current cpu voltage * 10.
+    t->external_clock = cpu_to_le16(0x0064); /* Unknown */
     t->max_speed = cpu_to_le16(type4.max_speed);
     t->current_speed = cpu_to_le16(type4.current_speed);
     t->status = 0x41; /* Socket populated, CPU enabled */
-    t->processor_upgrade = 0x01; /* Other */
-    t->l1_cache_handle = cpu_to_le16(0xFFFF); /* N/A */
-    t->l2_cache_handle = cpu_to_le16(0xFFFF); /* N/A */
-    t->l3_cache_handle = cpu_to_le16(0xFFFF); /* N/A */
+    t->processor_upgrade = 0x31; /* 0x31 = AM4 Socket | 0x49 = AM5 Socket | https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A305%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C318%2C0%5D */
+    t->l1_cache_handle = cpu_to_le16(0x0014); /* N/A */
+    t->l2_cache_handle = cpu_to_le16(0x0015); /* N/A */
+    t->l3_cache_handle = cpu_to_le16(0x0016); /* N/A */
     SMBIOS_TABLE_SET_STR(4, serial_number_str, type4.serial);
     SMBIOS_TABLE_SET_STR(4, asset_tag_number_str, type4.asset);
     SMBIOS_TABLE_SET_STR(4, part_number_str, type4.part);
@@ -715,8 +792,27 @@ static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
 
     t->thread_count = (threads_per_socket > 255) ? 0xFF : threads_per_socket;
 
-    t->processor_characteristics = cpu_to_le16(0x02); /* Unknown */
-    t->processor_family2 = cpu_to_le16(type4.processor_family);
+    t->processor_characteristics = cpu_to_le16(0x00FC); /*
+
+    Table 27 â€“ Processor Characteristics
+    https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A315%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C214%2C0%5D
+
+    Hex    = 0x00FC
+    Binary = 0b0000000011111100
+
+    Bit1 = Unknown - 0 (No)
+    Bit2 = 64-bit Capable - 1 (Yes)
+    Bit3 = Multi-Core - 1 (Yes)
+    Bit4 = Hardware Thread - 1 (Yes)
+    Bit5 = Execute Protection - 1 (Yes)
+    Bit6 = Enhanced Virtualization - 1 (Yes)
+    Bit7 = Power/Performance Control - 1 (Yes)
+
+    */
+
+    t->processor_family2 = cpu_to_le16(0x006B); /* AMD Zen Processor Family */
+    if (type4.processor_family != 0x01)
+        t->processor_family2 = cpu_to_le16(type4.processor_family);
 
     if (tbl_len == SMBIOS_TYPE_4_LEN_V30) {
         t->core_count2 = t->core_enabled2 = cpu_to_le16(cores_per_socket);
@@ -837,15 +933,15 @@ static void smbios_build_type_11_table(void)
 
 #define MAX_T16_STD_SZ 0x80000000 /* 2T in Kilobytes */
 
-static void smbios_build_type_16_table(unsigned dimm_cnt)
+static void smbios_build_type_16_table_with_slots(unsigned dimm_cnt, unsigned slot_cnt)
 {
     uint64_t size_kb;
 
     SMBIOS_BUILD_TABLE_PRE(16, T16_BASE, true); /* required */
 
-    t->location = 0x01; /* Other */
+    t->location = 0x03; /* System Board/Motherboard */
     t->use = 0x03; /* System memory */
-    t->error_correction = 0x06; /* Multi-bit ECC (for Microsoft, per SeaBIOS) */
+    t->error_correction = 0x03; /* Multi-bit ECC (for Microsoft, per SeaBIOS) */
     size_kb = QEMU_ALIGN_UP(current_machine->ram_size, KiB) / KiB;
     if (size_kb < MAX_T16_STD_SZ) {
         t->maximum_capacity = cpu_to_le32(size_kb);
@@ -855,7 +951,10 @@ static void smbios_build_type_16_table(unsigned dimm_cnt)
         t->extended_maximum_capacity = cpu_to_le64(current_machine->ram_size);
     }
     t->memory_error_information_handle = cpu_to_le16(0xFFFE); /* Not provided */
-    t->number_of_memory_devices = cpu_to_le16(dimm_cnt);
+    if (dimm_cnt > slot_cnt)
+        t->number_of_memory_devices = cpu_to_le16(dimm_cnt);
+    else
+        t->number_of_memory_devices = cpu_to_le16(slot_cnt);
 
     SMBIOS_BUILD_TABLE_POST;
 }
@@ -863,7 +962,7 @@ static void smbios_build_type_16_table(unsigned dimm_cnt)
 #define MAX_T17_STD_SZ 0x7FFF /* (32G - 1M), in Megabytes */
 #define MAX_T17_EXT_SZ 0x80000000 /* 2P, in Megabytes */
 
-static void smbios_build_type_17_table(unsigned instance, uint64_t size)
+static void smbios_build_type_17_table_empty(unsigned instance, uint64_t size)
 {
     char loc_str[128];
     uint64_t size_mb;
@@ -872,8 +971,8 @@ static void smbios_build_type_17_table(unsigned instance, uint64_t size)
 
     t->physical_memory_array_handle = cpu_to_le16(0x1000); /* Type 16 above */
     t->memory_error_information_handle = cpu_to_le16(0xFFFE); /* Not provided */
-    t->total_width = cpu_to_le16(0xFFFF); /* Unknown */
-    t->data_width = cpu_to_le16(0xFFFF); /* Unknown */
+    t->total_width = cpu_to_le16(0x0040); // No ECC 64-bit
+    t->data_width = cpu_to_le16(0x0040); // No ECC 64-bit
     size_mb = QEMU_ALIGN_UP(size, MiB) / MiB;
     if (size_mb < MAX_T17_STD_SZ) {
         t->size = cpu_to_le16(size_mb);
@@ -883,23 +982,47 @@ static void smbios_build_type_17_table(unsigned instance, uint64_t size)
         t->size = cpu_to_le16(MAX_T17_STD_SZ);
         t->extended_size = cpu_to_le32(size_mb);
     }
-    t->form_factor = 0x09; /* DIMM */
+    t->form_factor = 0x09; /* DIMM and 0x0D for SODIMM */
     t->device_set = 0; /* Not in a set */
     snprintf(loc_str, sizeof(loc_str), "%s %d", type17.loc_pfx, instance);
     SMBIOS_TABLE_SET_STR(17, device_locator_str, loc_str);
     SMBIOS_TABLE_SET_STR(17, bank_locator_str, type17.bank);
-    t->memory_type = 0x07; /* RAM */
-    t->type_detail = cpu_to_le16(0x02); /* Other */
+    t->memory_type = 0x22; /* RAM */
+    t->type_detail = cpu_to_le16(0x0080); /*
+
+    Table 78 â€“ Memory Device: Type Detail field
+    https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A448%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C318%2C0%5D
+
+    Hex    = 0x0080
+    Binary = 0b0000000010000000
+
+    Bit0  = Reserved - 0 (No)
+    Bit1  = Other - 0 (No)
+    Bit2  = Unknown - 0 (No)
+    Bit3  = Fast-paged - 0 (No)
+    Bit4  = Static column - 0 (No)
+    Bit5  = Pseudo-static - 0 (No)
+    Bit6  = RAMBUS - 0 (No)
+    Bit7  = Synchronous - 1 (Yes)
+    Bit8  = CMOS - 0 (No)
+    Bit9  = EDO - 0 (No)
+    Bit10 = Window DRAM - 0 (No)
+    Bit11 = Cache DRAM - 0 (No)
+    Bit12 = Non-volatile - 0 (No)
+
+    */
     t->speed = cpu_to_le16(type17.speed);
     SMBIOS_TABLE_SET_STR(17, manufacturer_str, type17.manufacturer);
     SMBIOS_TABLE_SET_STR(17, serial_number_str, type17.serial);
     SMBIOS_TABLE_SET_STR(17, asset_tag_number_str, type17.asset);
     SMBIOS_TABLE_SET_STR(17, part_number_str, type17.part);
-    t->attributes = 0; /* Unknown */
+    t->attributes = 0x01; /* SINGLE RANK MODULE */
     t->configured_clock_speed = t->speed; /* reuse value for max speed */
-    t->minimum_voltage = cpu_to_le16(0); /* Unknown */
-    t->maximum_voltage = cpu_to_le16(0); /* Unknown */
-    t->configured_voltage = cpu_to_le16(0); /* Unknown */
+    // DDR4 Voltage, in mV
+    t->minimum_voltage = cpu_to_le16(1200); /* 1.2V Minimum Voltage Per DDR4 Spec */
+    t->maximum_voltage = cpu_to_le16(1500); /* 1.5V Minimum Voltage Per DDR4 Spec */
+    // 1.35V = typical XMP, 1.2V = JEDEC
+    t->configured_voltage = cpu_to_le16(1350); /* 1.35V XMP DDR4 Voltage */
 
     SMBIOS_BUILD_TABLE_POST;
 }
@@ -1016,8 +1139,9 @@ void smbios_set_default_processor_family(uint16_t processor_family)
 void smbios_set_defaults(const char *manufacturer, const char *product,
                          const char *version)
 {
-    smbios_have_defaults = true;
+    smbios_have_defaults = false;
 
+    /*
     SMBIOS_SET_DEFAULT(smbios_type1.manufacturer, manufacturer);
     SMBIOS_SET_DEFAULT(smbios_type1.product, product);
     SMBIOS_SET_DEFAULT(smbios_type1.version, version);
@@ -1031,6 +1155,7 @@ void smbios_set_defaults(const char *manufacturer, const char *product,
     SMBIOS_SET_DEFAULT(type4.version, version);
     SMBIOS_SET_DEFAULT(type17.loc_pfx, "DIMM");
     SMBIOS_SET_DEFAULT(type17.manufacturer, manufacturer);
+    */
 }
 
 static void smbios_entry_point_setup(SmbiosEntryPointType ep_type)
@@ -1092,7 +1217,7 @@ static bool smbios_get_tables_ep(MachineState *ms,
                        uint8_t **anchor, size_t *anchor_len,
                        Error **errp)
 {
-    unsigned i, dimm_cnt, offset;
+    unsigned i, dimm_cnt, offset, slot_cnt;
     MachineClass *mc = MACHINE_GET_CLASS(ms);
     ERRP_GUARD();
 
@@ -1114,7 +1239,7 @@ static bool smbios_get_tables_ep(MachineState *ms,
     assert(ms->smp.sockets >= 1);
 
     for (i = 0; i < ms->smp.sockets; i++) {
-        smbios_build_type_4_table(ms, i, ep_type, errp);
+        smbios_build_type_4_table(ms, i,ms->smp.sockets, ep_type, errp);
         if (*errp) {
             goto err_exit;
         }
@@ -1130,6 +1255,7 @@ static bool smbios_get_tables_ep(MachineState *ms,
     dimm_cnt = QEMU_ALIGN_UP(current_machine->ram_size,
                              mc->smbios_memory_device_size) /
                mc->smbios_memory_device_size;
+    slot_cnt = 4;
 
     /*
      * The offset determines if we need to keep additional space between
@@ -1138,13 +1264,25 @@ static bool smbios_get_tables_ep(MachineState *ms,
      * memory and DIMM like chunks of 16 GiB, the default space between
      * the two tables (T19_BASE - T17_BASE = 512) is not enough.
      */
-    offset = (dimm_cnt > (T19_BASE - T17_BASE)) ? \
-             dimm_cnt - (T19_BASE - T17_BASE) : 0;
+    if (dimm_cnt > slot_cnt) {
+        offset = (dimm_cnt > (T19_BASE - T17_BASE)) ?
+        dimm_cnt - (T19_BASE - T17_BASE) : 0;
+    } else {
+        offset = (slot_cnt > (T19_BASE - T17_BASE)) ?
+        slot_cnt - (T19_BASE - T17_BASE) : 0;
+    }
 
-    smbios_build_type_16_table(dimm_cnt);
+    smbios_build_type_16_table_with_slots(dimm_cnt, slot_cnt);
 
     for (i = 0; i < dimm_cnt; i++) {
-        smbios_build_type_17_table(i, GET_DIMM_SZ);
+        smbios_build_type_17_table_empty(i, GET_DIMM_SZ);
+    }
+
+    // Add empty slots...
+    if (slot_cnt > dimm_cnt) {
+        for (i = dimm_cnt; i < slot_cnt; i++) {
+            smbios_build_type_17_table_empty(i, GET_DIMM_SZ);
+        }
     }
 
     for (i = 0; i < mem_array_size; i++) {
diff --git a/hw/ufs/lu.c b/hw/ufs/lu.c
index 1c3794b2d4..64f4612435 100644
--- a/hw/ufs/lu.c
+++ b/hw/ufs/lu.c
@@ -184,8 +184,8 @@ static int ufs_emulate_wlun_inquiry(UfsRequest *req, uint8_t *outbuf,
     outbuf[5] = 0;
     outbuf[6] = 0;
     outbuf[7] = 0x2;
-    strpadcpy((char *)&outbuf[8], 8, "QEMU", ' ');
-    strpadcpy((char *)&outbuf[16], 16, "QEMU UFS", ' ');
+    strpadcpy((char *)&outbuf[8], 8, "MSI", ' ');
+    strpadcpy((char *)&outbuf[16], 16, "UFS", ' ');
     memset(&outbuf[32], 0, 4);
 
     return SCSI_INQUIRY_LEN;
diff --git a/hw/usb/canokey.c b/hw/usb/canokey.c
index e2d66179e0..9eaa29863e 100644
--- a/hw/usb/canokey.c
+++ b/hw/usb/canokey.c
@@ -35,8 +35,8 @@ enum {
 
 static const USBDescStrings desc_strings = {
     [STR_MANUFACTURER]     = "canokeys.org",
-    [STR_PRODUCT]          = "CanoKey QEMU",
-    [STR_SERIALNUMBER]     = "0"
+    [STR_PRODUCT]          = "CanoKey",
+    [STR_SERIALNUMBER]     = "ORPEIJ8LEZ"
 };
 
 static const USBDescDevice desc_device_canokey = {
diff --git a/hw/usb/dev-audio.c b/hw/usb/dev-audio.c
index 40f031252a..49f5515455 100644
--- a/hw/usb/dev-audio.c
+++ b/hw/usb/dev-audio.c
@@ -73,9 +73,9 @@ enum usb_audio_strings {
 };
 
 static const USBDescStrings usb_audio_stringtable = {
-    [STRING_MANUFACTURER]       = "QEMU",
-    [STRING_PRODUCT]            = "QEMU USB Audio",
-    [STRING_SERIALNUMBER]       = "1",
+    [STRING_MANUFACTURER]       = "Logitech",
+    [STRING_PRODUCT]            = "USB Audio",
+    [STRING_SERIALNUMBER]       = "SCNU3K6LPU",
     [STRING_CONFIG]             = "Audio Configuration",
     [STRING_USBAUDIO_CONTROL]   = "Audio Device",
     [STRING_INPUT_TERMINAL]     = "Audio Output Pipe",
diff --git a/hw/usb/dev-hid.c b/hw/usb/dev-hid.c
index accdd460e3..16ca572af1 100644
--- a/hw/usb/dev-hid.c
+++ b/hw/usb/dev-hid.c
@@ -63,17 +63,17 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
-    [STR_PRODUCT_MOUSE]    = "QEMU USB Mouse",
-    [STR_PRODUCT_TABLET]   = "QEMU USB Tablet",
-    [STR_PRODUCT_KEYBOARD] = "QEMU USB Keyboard",
-    [STR_SERIAL_COMPAT]    = "42",
+    [STR_MANUFACTURER]     = "Logitech",
+    [STR_PRODUCT_MOUSE]    = "USB Mouse",
+    [STR_PRODUCT_TABLET]   = "USB Tablet",
+    [STR_PRODUCT_KEYBOARD] = "USB Keyboard",
+    [STR_SERIAL_COMPAT]    = "N76POILMPP",
     [STR_CONFIG_MOUSE]     = "HID Mouse",
     [STR_CONFIG_TABLET]    = "HID Tablet",
     [STR_CONFIG_KEYBOARD]  = "HID Keyboard",
-    [STR_SERIAL_MOUSE]     = "89126",
-    [STR_SERIAL_TABLET]    = "28754",
-    [STR_SERIAL_KEYBOARD]  = "68284",
+    [STR_SERIAL_MOUSE]     = "1F6IT6W2IF",
+    [STR_SERIAL_TABLET]    = "WSS5T9RFVE",
+    [STR_SERIAL_KEYBOARD]  = "V96SH0F8ZX",
 };
 
 static const USBDescIface desc_iface_mouse = {
@@ -368,7 +368,7 @@ static const USBDescMSOS desc_msos_suspend = {
 
 static const USBDesc desc_mouse = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -382,7 +382,7 @@ static const USBDesc desc_mouse = {
 
 static const USBDesc desc_mouse2 = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -397,7 +397,7 @@ static const USBDesc desc_mouse2 = {
 
 static const USBDesc desc_tablet = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -411,7 +411,7 @@ static const USBDesc desc_tablet = {
 
 static const USBDesc desc_tablet2 = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -426,7 +426,7 @@ static const USBDesc desc_tablet2 = {
 
 static const USBDesc desc_keyboard = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -440,7 +440,7 @@ static const USBDesc desc_keyboard = {
 
 static const USBDesc desc_keyboard2 = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -805,7 +805,7 @@ static void usb_tablet_class_initfn(ObjectClass *klass, void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_tablet_realize;
-    uc->product_desc   = "QEMU USB Tablet";
+    uc->product_desc   = "USB Tablet";
     dc->vmsd = &vmstate_usb_ptr;
     device_class_set_props(dc, usb_tablet_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
@@ -827,7 +827,7 @@ static void usb_mouse_class_initfn(ObjectClass *klass, void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_mouse_realize;
-    uc->product_desc   = "QEMU USB Mouse";
+    uc->product_desc   = "USB Mouse";
     dc->vmsd = &vmstate_usb_ptr;
     device_class_set_props(dc, usb_mouse_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
@@ -850,7 +850,7 @@ static void usb_keyboard_class_initfn(ObjectClass *klass, void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_keyboard_realize;
-    uc->product_desc   = "QEMU USB Keyboard";
+    uc->product_desc   = "USB Keyboard";
     dc->vmsd = &vmstate_usb_kbd;
     device_class_set_props(dc, usb_keyboard_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
diff --git a/hw/usb/dev-hub.c b/hw/usb/dev-hub.c
index 3880e2aca8..d6c9a3a657 100644
--- a/hw/usb/dev-hub.c
+++ b/hw/usb/dev-hub.c
@@ -104,9 +104,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
-    [STR_PRODUCT]      = "QEMU USB Hub",
-    [STR_SERIALNUMBER] = "314159",
+    [STR_MANUFACTURER] = "Logitech",
+    [STR_PRODUCT]      = "USB Hub",
+    [STR_SERIALNUMBER] = "EPCEFDU54X",
 };
 
 static const USBDescIface desc_iface_hub = {
@@ -676,7 +676,7 @@ static void usb_hub_class_initfn(ObjectClass *klass, void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_hub_realize;
-    uc->product_desc   = "QEMU USB Hub";
+    uc->product_desc   = "USB Hub";
     uc->usb_desc       = &desc_hub;
     uc->find_device    = usb_hub_find_device;
     uc->handle_reset   = usb_hub_handle_reset;
diff --git a/hw/usb/dev-mtp.c b/hw/usb/dev-mtp.c
index 326c92a43d..29c3b988cc 100644
--- a/hw/usb/dev-mtp.c
+++ b/hw/usb/dev-mtp.c
@@ -247,8 +247,8 @@ OBJECT_DECLARE_SIMPLE_TYPE(MTPState, USB_MTP)
 
 /* ----------------------------------------------------------------------- */
 
-#define MTP_MANUFACTURER  "QEMU"
-#define MTP_PRODUCT       "QEMU filesharing"
+#define MTP_MANUFACTURER  "Microsoft"
+#define MTP_PRODUCT       "filesharing"
 #define MTP_WRITE_BUF_SZ  (512 * KiB)
 
 enum {
@@ -264,7 +264,7 @@ enum {
 static const USBDescStrings desc_strings = {
     [STR_MANUFACTURER] = MTP_MANUFACTURER,
     [STR_PRODUCT]      = MTP_PRODUCT,
-    [STR_SERIALNUMBER] = "34617",
+    [STR_SERIALNUMBER] = "FJFR36ZGFQ",
     [STR_MTP]          = "MTP",
     [STR_CONFIG_FULL]  = "Full speed config (usb 1.1)",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
@@ -2090,7 +2090,7 @@ static void usb_mtp_class_initfn(ObjectClass *klass, void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_mtp_realize;
-    uc->product_desc   = "QEMU USB MTP";
+    uc->product_desc   = "USB MTP";
     uc->usb_desc       = &desc;
     uc->cancel_packet  = usb_mtp_cancel_packet;
     uc->handle_attach  = usb_desc_attach;
diff --git a/hw/usb/dev-network.c b/hw/usb/dev-network.c
index a87a0ffb95..afd4529728 100644
--- a/hw/usb/dev-network.c
+++ b/hw/usb/dev-network.c
@@ -99,16 +99,16 @@ enum usbstring_idx {
 #define ETH_FRAME_LEN                   1514 /* Max. octets in frame sans FCS */
 
 static const USBDescStrings usb_net_stringtable = {
-    [STRING_MANUFACTURER]       = "QEMU",
-    [STRING_PRODUCT]            = "RNDIS/QEMU USB Network Device",
-    [STRING_ETHADDR]            = "400102030405",
-    [STRING_DATA]               = "QEMU USB Net Data Interface",
-    [STRING_CONTROL]            = "QEMU USB Net Control Interface",
-    [STRING_RNDIS_CONTROL]      = "QEMU USB Net RNDIS Control Interface",
-    [STRING_CDC]                = "QEMU USB Net CDC",
-    [STRING_SUBSET]             = "QEMU USB Net Subset",
-    [STRING_RNDIS]              = "QEMU USB Net RNDIS",
-    [STRING_SERIALNUMBER]       = "1",
+    [STRING_MANUFACTURER]       = "Realtek",
+    [STRING_PRODUCT]            = "RNDIS/Realtek USB Network Device",
+    [STRING_ETHADDR]            = "4C82A94C9ECA",
+    [STRING_DATA]               = "USB Net Data Interface",
+    [STRING_CONTROL]            = "USB Net Control Interface",
+    [STRING_RNDIS_CONTROL]      = "USB Net RNDIS Control Interface",
+    [STRING_CDC]                = "USB Net CDC",
+    [STRING_SUBSET]             = "USB Net Subset",
+    [STRING_RNDIS]              = "USB Net RNDIS",
+    [STRING_SERIALNUMBER]       = "D9H87OLLOE",
 };
 
 static const USBDescIface desc_iface_rndis[] = {
@@ -717,7 +717,7 @@ static int ndis_query(USBNetState *s, uint32_t oid,
 
     /* mandatory */
     case OID_GEN_VENDOR_DESCRIPTION:
-        pstrcpy((char *)outbuf, outlen, "QEMU USB RNDIS Net");
+        pstrcpy((char *)outbuf, outlen, "USB RNDIS Net");
         return strlen((char *)outbuf) + 1;
 
     case OID_GEN_VENDOR_DRIVER_VERSION:
@@ -1417,7 +1417,7 @@ static void usb_net_class_initfn(ObjectClass *klass, void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_net_realize;
-    uc->product_desc   = "QEMU USB Network Interface";
+    uc->product_desc   = "USB Network Interface";
     uc->usb_desc       = &desc_net;
     uc->handle_reset   = usb_net_handle_reset;
     uc->handle_control = usb_net_handle_control;
diff --git a/hw/usb/dev-serial.c b/hw/usb/dev-serial.c
index aa50a92e26..285be475e6 100644
--- a/hw/usb/dev-serial.c
+++ b/hw/usb/dev-serial.c
@@ -119,10 +119,10 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]    = "QEMU",
-    [STR_PRODUCT_SERIAL]  = "QEMU USB SERIAL",
-    [STR_PRODUCT_BRAILLE] = "QEMU USB BAUM BRAILLE",
-    [STR_SERIALNUMBER]    = "1",
+    [STR_MANUFACTURER]    = "Microsoft",
+    [STR_PRODUCT_SERIAL]  = "USB SERIAL",
+    [STR_PRODUCT_BRAILLE] = "USB BAUM BRAILLE",
+    [STR_SERIALNUMBER]    = "6KCP6OG5KL",
 };
 
 static const USBDescIface desc_iface0 = {
@@ -665,7 +665,7 @@ static void usb_serial_class_initfn(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB Serial";
+    uc->product_desc   = "USB Serial";
     uc->usb_desc       = &desc_serial;
     device_class_set_props(dc, serial_properties);
 }
@@ -685,7 +685,7 @@ static void usb_braille_class_initfn(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB Braille";
+    uc->product_desc   = "USB Braille";
     uc->usb_desc       = &desc_braille;
     device_class_set_props(dc, braille_properties);
 }
diff --git a/hw/usb/dev-smartcard-reader.c b/hw/usb/dev-smartcard-reader.c
index 73deb3ce83..32a8b51430 100644
--- a/hw/usb/dev-smartcard-reader.c
+++ b/hw/usb/dev-smartcard-reader.c
@@ -80,8 +80,8 @@ OBJECT_DECLARE_SIMPLE_TYPE(USBCCIDState, USB_CCID_DEV)
 #define CCID_CONTROL_GET_CLOCK_FREQUENCIES  0x2
 #define CCID_CONTROL_GET_DATA_RATES         0x3
 
-#define CCID_PRODUCT_DESCRIPTION        "QEMU USB CCID"
-#define CCID_VENDOR_DESCRIPTION         "QEMU"
+#define CCID_PRODUCT_DESCRIPTION        "USB CCID"
+#define CCID_VENDOR_DESCRIPTION         "Identiv"
 #define CCID_INTERFACE_NAME             "CCID Interface"
 #define CCID_SERIAL_NUMBER_STRING       "1"
 /*
@@ -419,9 +419,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]  = "QEMU",
-    [STR_PRODUCT]       = "QEMU USB CCID",
-    [STR_SERIALNUMBER]  = "1",
+    [STR_MANUFACTURER]  = "Identiv",
+    [STR_PRODUCT]       = "USB CCID",
+    [STR_SERIALNUMBER]  = "L9Z3ZM8CDP",
     [STR_INTERFACE]     = "CCID Interface",
 };
 
@@ -1441,7 +1441,7 @@ static void ccid_class_initfn(ObjectClass *klass, void *data)
     HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(klass);
 
     uc->realize        = ccid_realize;
-    uc->product_desc   = "QEMU USB CCID";
+    uc->product_desc   = "USB CCID";
     uc->usb_desc       = &desc_ccid;
     uc->handle_reset   = ccid_handle_reset;
     uc->handle_control = ccid_handle_control;
diff --git a/hw/usb/dev-storage.c b/hw/usb/dev-storage.c
index 4f1e8b7f6c..e1af6a9221 100644
--- a/hw/usb/dev-storage.c
+++ b/hw/usb/dev-storage.c
@@ -47,9 +47,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
-    [STR_PRODUCT]      = "QEMU USB HARDDRIVE",
-    [STR_SERIALNUMBER] = "1",
+    [STR_MANUFACTURER] = "Samsung",
+    [STR_PRODUCT]      = "USB HARDDRIVE",
+    [STR_SERIALNUMBER] = "HLN8ILM0SH",
     [STR_CONFIG_FULL]  = "Full speed config (usb 1.1)",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
     [STR_CONFIG_SUPER] = "Super speed config (usb 3.0)",
@@ -590,7 +590,7 @@ static void usb_msd_class_initfn_common(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB MSD";
+    uc->product_desc   = "USB MSD";
     uc->usb_desc       = &desc;
     uc->cancel_packet  = usb_msd_cancel_io;
     uc->handle_attach  = usb_desc_attach;
diff --git a/hw/usb/dev-uas.c b/hw/usb/dev-uas.c
index 44e30013d7..51b9accc1d 100644
--- a/hw/usb/dev-uas.c
+++ b/hw/usb/dev-uas.c
@@ -171,9 +171,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
+    [STR_MANUFACTURER] = "Microsoft",
     [STR_PRODUCT]      = "USB Attached SCSI HBA",
-    [STR_SERIALNUMBER] = "27842",
+    [STR_SERIALNUMBER] = "E5DEMH2Y7X",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
     [STR_CONFIG_SUPER] = "Super speed config (usb 3.0)",
 };
diff --git a/hw/usb/dev-wacom.c b/hw/usb/dev-wacom.c
index 7177c17f03..6a0420d110 100644
--- a/hw/usb/dev-wacom.c
+++ b/hw/usb/dev-wacom.c
@@ -64,9 +64,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
+    [STR_MANUFACTURER]     = "Wacom",
     [STR_PRODUCT]          = "Wacom PenPartner",
-    [STR_SERIALNUMBER]     = "1",
+    [STR_SERIALNUMBER]     = "718H83W0T4",
 };
 
 static const uint8_t qemu_wacom_hid_report_descriptor[] = {
@@ -231,7 +231,7 @@ static int usb_mouse_poll(USBWacomState *s, uint8_t *buf, int len)
 
     if (!s->mouse_grabbed) {
         s->eh_entry = qemu_add_mouse_event_handler(usb_mouse_event, s, 0,
-                        "QEMU PenPartner tablet");
+                        "PenPartner tablet");
         qemu_activate_mouse_event_handler(s->eh_entry);
         s->mouse_grabbed = 1;
     }
@@ -269,7 +269,7 @@ static int usb_wacom_poll(USBWacomState *s, uint8_t *buf, int len)
 
     if (!s->mouse_grabbed) {
         s->eh_entry = qemu_add_mouse_event_handler(usb_wacom_event, s, 1,
-                        "QEMU PenPartner tablet");
+                        "PenPartner tablet");
         qemu_activate_mouse_event_handler(s->eh_entry);
         s->mouse_grabbed = 1;
     }
@@ -425,7 +425,7 @@ static void usb_wacom_class_init(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU PenPartner Tablet";
+    uc->product_desc   = "PenPartner Tablet";
     uc->usb_desc       = &desc_wacom;
     uc->realize        = usb_wacom_realize;
     uc->handle_reset   = usb_wacom_handle_reset;
@@ -433,7 +433,7 @@ static void usb_wacom_class_init(ObjectClass *klass, void *data)
     uc->handle_data    = usb_wacom_handle_data;
     uc->unrealize      = usb_wacom_unrealize;
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
-    dc->desc = "QEMU PenPartner Tablet";
+    dc->desc = "PenPartner Tablet";
     dc->vmsd = &vmstate_usb_wacom;
 }
 
diff --git a/hw/usb/u2f-emulated.c b/hw/usb/u2f-emulated.c
index e1dd19ee92..803b227813 100644
--- a/hw/usb/u2f-emulated.c
+++ b/hw/usb/u2f-emulated.c
@@ -385,7 +385,7 @@ static void u2f_emulated_class_init(ObjectClass *klass, void *data)
     kc->realize = u2f_emulated_realize;
     kc->unrealize = u2f_emulated_unrealize;
     kc->recv_from_guest = u2f_emulated_recv_from_guest;
-    dc->desc = "QEMU U2F emulated key";
+    dc->desc = "U2F emulated key";
     device_class_set_props(dc, u2f_emulated_properties);
 }
 
diff --git a/hw/usb/u2f-passthru.c b/hw/usb/u2f-passthru.c
index 8df5215a1f..9f5e9d0eb8 100644
--- a/hw/usb/u2f-passthru.c
+++ b/hw/usb/u2f-passthru.c
@@ -528,7 +528,7 @@ static void u2f_passthru_class_init(ObjectClass *klass, void *data)
     kc->realize = u2f_passthru_realize;
     kc->unrealize = u2f_passthru_unrealize;
     kc->recv_from_guest = u2f_passthru_recv_from_guest;
-    dc->desc = "QEMU U2F passthrough key";
+    dc->desc = "U2F passthrough key";
     dc->vmsd = &u2f_passthru_vmstate;
     device_class_set_props(dc, u2f_passthru_properties);
     set_bit(DEVICE_CATEGORY_MISC, dc->categories);
diff --git a/hw/usb/u2f.c b/hw/usb/u2f.c
index 1fb59cf404..53da8be63e 100644
--- a/hw/usb/u2f.c
+++ b/hw/usb/u2f.c
@@ -46,9 +46,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
+    [STR_MANUFACTURER]     = "Microsoft",
     [STR_PRODUCT]          = "U2F USB key",
-    [STR_SERIALNUMBER]     = "0",
+    [STR_SERIALNUMBER]     = "JFX4J5OICR",
     [STR_CONFIG]           = "U2F key config",
     [STR_INTERFACE]        = "U2F key interface"
 };
@@ -322,7 +322,7 @@ static void u2f_key_class_init(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU U2F USB key";
+    uc->product_desc   = "U2F USB key";
     uc->usb_desc       = &desc_u2f_key;
     uc->handle_reset   = u2f_key_handle_reset;
     uc->handle_control = u2f_key_handle_control;
@@ -330,7 +330,7 @@ static void u2f_key_class_init(ObjectClass *klass, void *data)
     uc->handle_attach  = usb_desc_attach;
     uc->realize        = u2f_key_realize;
     uc->unrealize      = u2f_key_unrealize;
-    dc->desc           = "QEMU U2F key";
+    dc->desc           = "U2F key";
     dc->vmsd           = &vmstate_u2f_key;
 }
 
diff --git a/pc-bios/optionrom/optionrom.h b/pc-bios/optionrom/optionrom.h
index 7bcdf0e..9c2a417 100644
--- a/pc-bios/optionrom/optionrom.h
+++ b/pc-bios/optionrom/optionrom.h
@@ -43,7 +43,7 @@
 #define FW_CFG_DMA_CTL_SELECT  0x08
 #define FW_CFG_DMA_CTL_WRITE   0x10
 
-#define FW_CFG_DMA_SIGNATURE 0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE 0x51434f4d20434647ULL /* "QCOM CFG" */
 
 #define BIOS_CFG_DMA_ADDR_HIGH  0x514
 #define BIOS_CFG_DMA_ADDR_LOW   0x518
diff --git a/hw/vfio/ap.c b/hw/vfio/ap.c
index c7ab4ff57a..9bb3cf437e 100644
--- a/hw/vfio/ap.c
+++ b/hw/vfio/ap.c
@@ -254,7 +254,7 @@ static void vfio_ap_class_init(ObjectClass *klass, void *data)
     set_bit(DEVICE_CATEGORY_MISC, dc->categories);
     dc->realize = vfio_ap_realize;
     dc->unrealize = vfio_ap_unrealize;
-    dc->hotpluggable = true;
+    dc->hotpluggable = false;
     device_class_set_legacy_reset(dc, vfio_ap_reset);
     dc->bus_type = TYPE_AP_BUS;
 
diff --git a/include/hw/acpi/aml-build.h b/include/hw/acpi/aml-build.h
index c18f681342..e3656c173a 100644
--- a/include/hw/acpi/aml-build.h
+++ b/include/hw/acpi/aml-build.h
@@ -4,8 +4,8 @@
 #include "hw/acpi/acpi-defs.h"
 #include "hw/acpi/bios-linker-loader.h"
 
-#define ACPI_BUILD_APPNAME6 "BOCHS "
-#define ACPI_BUILD_APPNAME8 "BXPC    "
+#define ACPI_BUILD_APPNAME6 "ALASKA"
+#define ACPI_BUILD_APPNAME8 "A M I   "
 
 #define ACPI_BUILD_TABLE_FILE "etc/acpi/tables"
 #define ACPI_BUILD_RSDP_FILE "etc/acpi/rsdp"
diff --git a/include/hw/pci/pci.h b/include/hw/pci/pci.h
index 822fbacdf0..141f4c180c 100644
--- a/include/hw/pci/pci.h
+++ b/include/hw/pci/pci.h
@@ -57,7 +57,7 @@ extern bool pci_available;
 #define PCI_DEVICE_ID_MARVELL_GT6412X    0x4620
 
 /* QEMU/Bochs VGA (0x1234) */
-#define PCI_VENDOR_ID_QEMU               0x1234
+#define PCI_VENDOR_ID_QEMU               0x1022 // "???" | AMD Vendor ID Replacement from 0x1234
 #define PCI_DEVICE_ID_QEMU_VGA           0x1111
 #define PCI_DEVICE_ID_QEMU_IPMI          0x1112
 
@@ -74,12 +74,12 @@ extern bool pci_available;
 /* Intel (0x8086) */
 #define PCI_DEVICE_ID_INTEL_82551IT      0x1209
 #define PCI_DEVICE_ID_INTEL_82557        0x1229
-#define PCI_DEVICE_ID_INTEL_82801IR      0x2922
+#define PCI_DEVICE_ID_INTEL_82801IR      0x790e // Intel 82801IR ICH9 - LPC Bridge [A2] | AMD Device ID Replacement from 0x2922 | hw/ide/ich.c
 
 /* Red Hat / Qumranet (for QEMU) -- see pci-ids.txt */
-#define PCI_VENDOR_ID_REDHAT_QUMRANET    0x1af4
-#define PCI_SUBVENDOR_ID_REDHAT_QUMRANET 0x1af4
-#define PCI_SUBDEVICE_ID_QEMU            0x1100
+#define PCI_VENDOR_ID_REDHAT_QUMRANET    0x1022 // AMD Vendor ID Replacement from 0x1af4
+#define PCI_SUBVENDOR_ID_REDHAT_QUMRANET 0x1022 // AMD Subvendor ID Replacement from 0x1af4
+#define PCI_SUBDEVICE_ID_QEMU            0x1022 // AMD Subdevice ID Replacement from 0x1100
 
 /* legacy virtio-pci devices */
 #define PCI_DEVICE_ID_VIRTIO_NET         0x1000
@@ -100,21 +100,21 @@ extern bool pci_available;
  */
 #define PCI_DEVICE_ID_VIRTIO_10_BASE     0x1040
 
-#define PCI_VENDOR_ID_REDHAT             0x1b36
-#define PCI_DEVICE_ID_REDHAT_BRIDGE      0x0001
-#define PCI_DEVICE_ID_REDHAT_SERIAL      0x0002
+#define PCI_VENDOR_ID_REDHAT             0x1022 // "Red Hat, Inc." | AMD Vendor ID Replacement from 0x1b36
+#define PCI_DEVICE_ID_REDHAT_BRIDGE      0x1480 // "QEMU PCI-PCI bridge" | AMD Device ID Replacement from 0x0001 | hw/pci-bridge/pci_bridge_dev.c
+#define PCI_DEVICE_ID_REDHAT_SERIAL      0x0002 // TODO: find device_id | AMD Device ID Replacement from 0x???? | hw/char/serial-pci.c
 #define PCI_DEVICE_ID_REDHAT_SERIAL2     0x0003
 #define PCI_DEVICE_ID_REDHAT_SERIAL4     0x0004
 #define PCI_DEVICE_ID_REDHAT_TEST        0x0005
 #define PCI_DEVICE_ID_REDHAT_ROCKER      0x0006
 #define PCI_DEVICE_ID_REDHAT_SDHCI       0x0007
-#define PCI_DEVICE_ID_REDHAT_PCIE_HOST   0x0008
+#define PCI_DEVICE_ID_REDHAT_PCIE_HOST   0x1482 // "QEMU PCIe Host bridge" | AMD Device ID Replacement from 0x0008 | hw/pci-host/gpex.c
 #define PCI_DEVICE_ID_REDHAT_PXB         0x0009
 #define PCI_DEVICE_ID_REDHAT_BRIDGE_SEAT 0x000a
 #define PCI_DEVICE_ID_REDHAT_PXB_PCIE    0x000b
-#define PCI_DEVICE_ID_REDHAT_PCIE_RP     0x000c
-#define PCI_DEVICE_ID_REDHAT_XHCI        0x000d
-#define PCI_DEVICE_ID_REDHAT_PCIE_BRIDGE 0x000e
+#define PCI_DEVICE_ID_REDHAT_PCIE_RP     0x1483 // "QEMU PCIe Root Port" | AMD Device ID Replacement from 0x000c | hw/pci-bridge/gen_pcie_root_port.c
+#define PCI_DEVICE_ID_REDHAT_XHCI        0x43d5 // "QEMU XHCI Host Controller" | AMD Device ID Replacement from 0x000d | hw/usb/hcd-xhci-pci.c
+#define PCI_DEVICE_ID_REDHAT_PCIE_BRIDGE 0x1483 // "Red Hat, Device ID: 000E" | AMD Device ID Replacement from 0x000e | hw/pci-bridge/pcie_pci_bridge.c
 #define PCI_DEVICE_ID_REDHAT_MDPY        0x000f
 #define PCI_DEVICE_ID_REDHAT_NVME        0x0010
 #define PCI_DEVICE_ID_REDHAT_PVPANIC     0x0011
diff --git a/include/hw/pci/pci_ids.h b/include/hw/pci/pci_ids.h
index 33e2898be9..0a4e198958 100644
--- a/include/hw/pci/pci_ids.h
+++ b/include/hw/pci/pci_ids.h
@@ -237,6 +237,8 @@
 #define PCI_VENDOR_ID_BAIDU              0x1d22
 #define PCI_DEVICE_ID_KUNLUN_VF          0x3685
 
+/* https://www.pcilookup.com/ */
+
 #define PCI_VENDOR_ID_INTEL              0x8086
 #define PCI_DEVICE_ID_INTEL_82378        0x0484
 #define PCI_DEVICE_ID_INTEL_82441        0x1237
@@ -246,8 +248,8 @@
 #define PCI_DEVICE_ID_INTEL_ESB_9        0x25ab
 #define PCI_DEVICE_ID_INTEL_NVME         0x5845
 #define PCI_DEVICE_ID_INTEL_82371SB_0    0x7000
-#define PCI_DEVICE_ID_INTEL_82371SB_1    0x7010
-#define PCI_DEVICE_ID_INTEL_82371SB_2    0x7020
+#define PCI_DEVICE_ID_INTEL_82371SB_1    0x7010 // TODO: | Intel 82371SB_1 - ??? | AMD Vendor ID Replacement from 0x???? | hw/ide/piix.c
+#define PCI_DEVICE_ID_INTEL_82371SB_2    0x7020 // TODO: | Intel 82371SB_2 - ??? | AMD Vendor ID Replacement from 0x???? | hw/usb/hcd-uhci.c
 #define PCI_DEVICE_ID_INTEL_82371AB_0    0x7110
 #define PCI_DEVICE_ID_INTEL_82371AB      0x7111
 #define PCI_DEVICE_ID_INTEL_82371AB_2    0x7112
@@ -259,9 +261,9 @@
 #define PCI_DEVICE_ID_INTEL_ICH9_3       0x2913
 #define PCI_DEVICE_ID_INTEL_ICH9_4       0x2914
 #define PCI_DEVICE_ID_INTEL_ICH9_5       0x2919
-#define PCI_DEVICE_ID_INTEL_ICH9_6       0x2930
+#define PCI_DEVICE_ID_INTEL_ICH9_6       0x790b // Intel 82801IB ICH9 - SMBus Controller [A2] | AMD Vendor ID Replacement from 0x2930 | hw/i2c/smbus_ich9.c
 #define PCI_DEVICE_ID_INTEL_ICH9_7       0x2916
-#define PCI_DEVICE_ID_INTEL_ICH9_8       0x2918
+#define PCI_DEVICE_ID_INTEL_ICH9_8       0x790e // Intel 82801IR ICH9 - LPC Bridge [A2] | AMD Vendor ID Replacement from 0x2918 | hw/isa/lpc_ich9.c
 
 #define PCI_DEVICE_ID_INTEL_82801I_UHCI1 0x2934
 #define PCI_DEVICE_ID_INTEL_82801I_UHCI2 0x2935
@@ -273,7 +275,7 @@
 #define PCI_DEVICE_ID_INTEL_82801I_EHCI2 0x293c
 #define PCI_DEVICE_ID_INTEL_82599_SFP_VF 0x10ed
 
-#define PCI_DEVICE_ID_INTEL_P35_MCH      0x29c0
+#define PCI_DEVICE_ID_INTEL_P35_MCH      0x1480 // Intel G33/P35/Q35/Q33 Chipset - Memory Controller Hub [A0] | AMD Vendor ID Replacement from 0x29c0 | hw/pci-host/q35.c
 
 #define PCI_VENDOR_ID_XEN                0x5853
 #define PCI_DEVICE_ID_XEN_PLATFORM       0x0001
diff --git a/include/standard-headers/linux/qemu_fw_cfg.h b/include/standard-headers/linux/qemu_fw_cfg.h
index cb93f6678d..fe34590061 100644
--- a/include/standard-headers/linux/qemu_fw_cfg.h
+++ b/include/standard-headers/linux/qemu_fw_cfg.h
@@ -4,7 +4,7 @@
 
 #include "standard-headers/linux/types.h"
 
-#define FW_CFG_ACPI_DEVICE_ID	"QEMU0002"
+#define FW_CFG_ACPI_DEVICE_ID	"UEFI0002"
 
 /* selector key values for "well-known" fw_cfg entries */
 #define FW_CFG_SIGNATURE	0x00
@@ -71,7 +71,7 @@ struct fw_cfg_file {
 #define FW_CFG_DMA_CTL_SELECT	0x08
 #define FW_CFG_DMA_CTL_WRITE	0x10
 
-#define FW_CFG_DMA_SIGNATURE    0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE    0x51434f4d20434647ULL /* "QCOM CFG" */
 
 /* Control as first field allows for different structures selected by this
  * field, which might be useful in the future
diff --git a/migration/rdma.c b/migration/rdma.c
index 76fb034923..badc49ef9f 100644
--- a/migration/rdma.c
+++ b/migration/rdma.c
@@ -220,7 +220,7 @@ static const char *control_desc(unsigned int rdma_control)
         [RDMA_CONTROL_NONE] = "NONE",
         [RDMA_CONTROL_ERROR] = "ERROR",
         [RDMA_CONTROL_READY] = "READY",
-        [RDMA_CONTROL_QEMU_FILE] = "QEMU FILE",
+        [RDMA_CONTROL_QEMU_FILE] = "FILE",
         [RDMA_CONTROL_RAM_BLOCKS_REQUEST] = "RAM BLOCKS REQUEST",
         [RDMA_CONTROL_RAM_BLOCKS_RESULT] = "RAM BLOCKS RESULT",
         [RDMA_CONTROL_COMPRESS] = "COMPRESS",
diff --git a/pc-bios/s390-ccw/virtio-scsi.h b/pc-bios/s390-ccw/virtio-scsi.h
index c5612e16a2..048cb93d3d 100644
--- a/pc-bios/s390-ccw/virtio-scsi.h
+++ b/pc-bios/s390-ccw/virtio-scsi.h
@@ -25,7 +25,7 @@
 #define VIRTIO_SCSI_S_OK                     0x00
 #define VIRTIO_SCSI_S_BAD_TARGET             0x03
 
-#define QEMU_CDROM_SIGNATURE "QEMU CD-ROM     "
+#define QEMU_CDROM_SIGNATURE "ASUS CD-ROM     "
 
 enum virtio_scsi_vq_id {
     VR_CONTROL  = 0,
diff --git a/qapi/ui.json b/qapi/ui.json
index c536d4e524..c856182887 100644
--- a/qapi/ui.json
+++ b/qapi/ui.json
@@ -831,13 +831,13 @@
 #     -> { "execute": "query-mice" }
 #     <- { "return": [
 #              {
-#                 "name":"QEMU Microsoft Mouse",
+#                 "name":"Microsoft Mouse",
 #                 "index":0,
 #                 "current":false,
 #                 "absolute":false
 #              },
 #              {
-#                 "name":"QEMU PS/2 Mouse",
+#                 "name":"PS/2 Mouse",
 #                 "index":1,
 #                 "current":true,
 #                 "absolute":true
diff --git a/target/i386/cpu.c b/target/i386/cpu.c
index 5e12cba1b8..78e4fb8259 100644
--- a/target/i386/cpu.c
+++ b/target/i386/cpu.c
@@ -2502,7 +2502,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
         .features[FEAT_8000_0001_ECX] =
             CPUID_EXT3_LAHF_LM | CPUID_EXT3_SVM,
         .xlevel = 0x8000000A,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "AMD CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "phenom",
@@ -2617,7 +2617,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
              VMX_CPU_BASED_UNCOND_IO_EXITING | VMX_CPU_BASED_USE_IO_BITMAPS |
              VMX_CPU_BASED_MONITOR_EXITING | VMX_CPU_BASED_PAUSE_EXITING,
         .xlevel = 0x80000008,
-        .model_id = "Common KVM processor"
+        .model_id = "Common AMD processor"
     },
     {
         .name = "qemu32",
@@ -2631,7 +2631,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
         .features[FEAT_1_ECX] =
             CPUID_EXT_SSE3,
         .xlevel = 0x80000004,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "AMD CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "kvm32",
@@ -2661,7 +2661,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
              VMX_CPU_BASED_USE_IO_BITMAPS | VMX_CPU_BASED_MONITOR_EXITING |
              VMX_CPU_BASED_PAUSE_EXITING | VMX_CPU_BASED_USE_MSR_BITMAPS,
         .xlevel = 0x80000008,
-        .model_id = "Common 32-bit KVM processor"
+        .model_id = "Common 32-bit AMD processor"
     },
     {
         .name = "coreduo",
@@ -2757,7 +2757,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
         .features[FEAT_8000_0001_EDX] =
             CPUID_EXT2_MMXEXT | CPUID_EXT2_3DNOW | CPUID_EXT2_3DNOWEXT,
         .xlevel = 0x80000008,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "AMD CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "n270",
@@ -5734,7 +5734,7 @@ static void max_x86_cpu_initfn(Object *obj)
     object_property_set_str(OBJECT(cpu), "vendor", CPUID_VENDOR_AMD,
                             &error_abort);
     object_property_set_str(OBJECT(cpu), "model-id",
-                            "QEMU TCG CPU version " QEMU_HW_VERSION,
+                            "TCG CPU version " QEMU_HW_VERSION,
                             &error_abort);
 }
 
@@ -8022,7 +8022,7 @@ static void x86_cpu_hyperv_realize(X86CPU *cpu)
 
     /* Hyper-V vendor id */
     if (!cpu->hyperv_vendor) {
-        object_property_set_str(OBJECT(cpu), "hv-vendor-id", "Microsoft Hv",
+        object_property_set_str(OBJECT(cpu), "hv-vendor-id", "",
                                 &error_abort);
     }
     len = strlen(cpu->hyperv_vendor);
diff --git a/target/i386/kvm/kvm.c b/target/i386/kvm/kvm.c
index 6c749d4ee8..1a265dc748 100644
--- a/target/i386/kvm/kvm.c
+++ b/target/i386/kvm/kvm.c
@@ -1618,7 +1618,7 @@ static int hyperv_fill_cpuids(CPUState *cs,
         c->function = HV_CPUID_SYNDBG_VENDOR_AND_MAX_FUNCTIONS;
         c->eax = hyperv_feat_enabled(cpu, HYPERV_FEAT_EVMCS) ?
             HV_CPUID_NESTED_FEATURES : HV_CPUID_IMPLEMENT_LIMITS;
-        memcpy(signature, "Microsoft VS", 12);
+        memset(signature, 0, 12);
         c->eax = 0;
         c->ebx = signature[0];
         c->ecx = signature[1];
@@ -1626,7 +1626,7 @@ static int hyperv_fill_cpuids(CPUState *cs,
 
         c = &cpuid_ent[cpuid_i++];
         c->function = HV_CPUID_SYNDBG_INTERFACE;
-        memcpy(signature, "VS#1\0\0\0\0\0\0\0\0", 12);
+        memset(signature, 0, 12);
         c->eax = signature[0];
         c->ebx = 0;
         c->ecx = 0;
@@ -2130,7 +2130,7 @@ int kvm_arch_init_vcpu(CPUState *cs)
 #ifdef CONFIG_XEN_EMU
         struct kvm_cpuid_entry2 *xen_max_leaf;
 
-        memcpy(signature, "XenVMMXenVMM", 12);
+        memset(signature, 0, 12);
 
         xen_max_leaf = c = &cpuid_data.entries[cpuid_i++];
         c->function = kvm_base + XEN_CPUID_SIGNATURE;
@@ -2206,7 +2206,7 @@ int kvm_arch_init_vcpu(CPUState *cs)
         abort();
 #endif
     } else if (cpu->expose_kvm) {
-        memcpy(signature, "KVMKVMKVM\0\0\0", 12);
+        memset(signature, 0, 12);
         c = &cpuid_data.entries[cpuid_i++];
         c->function = KVM_CPUID_SIGNATURE | kvm_base;
         c->eax = KVM_CPUID_FEATURES | kvm_base;
diff --git a/target/s390x/cpu_models.c b/target/s390x/cpu_models.c
index 93a05e43d7..f3eaa1c1a8 100644
--- a/target/s390x/cpu_models.c
+++ b/target/s390x/cpu_models.c
@@ -955,7 +955,7 @@ static void s390_qemu_cpu_model_class_init(ObjectClass *oc, void *data)
     S390CPUClass *xcc = S390_CPU_CLASS(oc);
 
     xcc->is_migration_safe = true;
-    xcc->desc = g_strdup_printf("QEMU Virtual CPU version %s",
+    xcc->desc = g_strdup_printf("CPU version %s",
                                 qemu_hw_version());
 }
 
diff --git a/target/s390x/tcg/misc_helper.c b/target/s390x/tcg/misc_helper.c
index 31266aeda4..aafcbc791b 100644
--- a/target/s390x/tcg/misc_helper.c
+++ b/target/s390x/tcg/misc_helper.c
@@ -331,18 +331,18 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
             /* Basic Machine Configuration */
             char type[5] = {};
 
-            ebcdic_put(sysib.sysib_111.manuf, "QEMU            ", 16);
+            ebcdic_put(sysib.sysib_111.manuf, "AMD             ", 16);
             /* same as machine type number in STORE CPU ID, but in EBCDIC */
             snprintf(type, ARRAY_SIZE(type), "%X", cpu->model->def->type);
             ebcdic_put(sysib.sysib_111.type, type, 4);
             /* model number (not stored in STORE CPU ID for z/Architecture) */
-            ebcdic_put(sysib.sysib_111.model, "QEMU            ", 16);
-            ebcdic_put(sysib.sysib_111.sequence, "QEMU            ", 16);
-            ebcdic_put(sysib.sysib_111.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_111.model, "AMD             ", 16);
+            ebcdic_put(sysib.sysib_111.sequence, "AMD             ", 16);
+            ebcdic_put(sysib.sysib_111.plant, "AMD ", 4);
         } else if ((sel1 == 2) && (sel2 == 1)) {
             /* Basic Machine CPU */
-            ebcdic_put(sysib.sysib_121.sequence, "QEMUQEMUQEMUQEMU", 16);
-            ebcdic_put(sysib.sysib_121.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_121.sequence, "AMDAMDAMDAMDAMDA", 16);
+            ebcdic_put(sysib.sysib_121.plant, "AMD ", 4);
             sysib.sysib_121.cpu_addr = cpu_to_be16(env->core_id);
         } else if ((sel1 == 2) && (sel2 == 2)) {
             /* Basic Machine CPUs */
@@ -357,8 +357,8 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
     case STSI_R0_FC_LEVEL_2:
         if ((sel1 == 2) && (sel2 == 1)) {
             /* LPAR CPU */
-            ebcdic_put(sysib.sysib_221.sequence, "QEMUQEMUQEMUQEMU", 16);
-            ebcdic_put(sysib.sysib_221.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_221.sequence, "AMDAMDAMDAMDAMDA", 16);
+            ebcdic_put(sysib.sysib_221.plant, "AMD ", 4);
             sysib.sysib_221.cpu_addr = cpu_to_be16(env->core_id);
         } else if ((sel1 == 2) && (sel2 == 2)) {
             /* LPAR CPUs */
@@ -366,7 +366,7 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
             sysib.sysib_222.total_cpus = cpu_to_be16(total_cpus);
             sysib.sysib_222.conf_cpus = cpu_to_be16(conf_cpus);
             sysib.sysib_222.reserved_cpus = cpu_to_be16(reserved_cpus);
-            ebcdic_put(sysib.sysib_222.name, "QEMU    ", 8);
+            ebcdic_put(sysib.sysib_222.name, "AMD     ", 8);
             sysib.sysib_222.caf = cpu_to_be32(1000);
             sysib.sysib_222.dedicated_cpus = cpu_to_be16(conf_cpus);
         } else {
@@ -382,7 +382,7 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
             sysib.sysib_322.vm[0].reserved_cpus = cpu_to_be16(reserved_cpus);
             sysib.sysib_322.vm[0].caf = cpu_to_be32(1000);
             /* Linux kernel uses this to distinguish us from z/VM */
-            ebcdic_put(sysib.sysib_322.vm[0].cpi, "KVM/Linux       ", 16);
+            ebcdic_put(sysib.sysib_322.vm[0].cpi, "AMD             ", 16);
             sysib.sysib_322.vm[0].ext_name_encoding = 2; /* UTF-8 */
 
             /* If our VM has a name, use the real name */

```

`patches/QEMU/Archive/amd-qemu-10.1.0.patch`:

```patch
diff --git a/block/vhdx.c b/block/vhdx.c
index b2a4b81..dffe9f8 100644
--- a/block/vhdx.c
+++ b/block/vhdx.c
@@ -2020,7 +2020,7 @@ vhdx_co_create(BlockdevCreateOptions *opts, Error **errp)
 
     /* The creator field is optional, but may be useful for
      * debugging / diagnostics */
-    creator = g_utf8_to_utf16("QEMU v" QEMU_VERSION, -1, NULL,
+    creator = g_utf8_to_utf16("Microsoft v" QEMU_VERSION, -1, NULL,
                               &creator_items, NULL);
     signature = cpu_to_le64(VHDX_FILE_SIGNATURE);
     ret = blk_co_pwrite(blk, VHDX_FILE_ID_OFFSET, sizeof(signature), &signature,
diff --git a/block/vvfat.c b/block/vvfat.c
index 814796d..a584383 100644
--- a/block/vvfat.c
+++ b/block/vvfat.c
@@ -1176,7 +1176,7 @@ static int vvfat_open(BlockDriverState *bs, QDict *options, int flags,
         }
         memcpy(s->volume_label, label, label_length);
     } else {
-        memcpy(s->volume_label, "QEMU VVFAT", 10);
+        memcpy(s->volume_label, "ASUS VVFAT", 10);
     }
 
     if (floppy) {
diff --git a/chardev/msmouse.c b/chardev/msmouse.c
index 1a55755..49b979b 100644
--- a/chardev/msmouse.c
+++ b/chardev/msmouse.c
@@ -172,7 +172,7 @@ static int msmouse_chr_write(struct Chardev *s, const uint8_t *buf, int len)
 }
 
 static const QemuInputHandler msmouse_handler = {
-    .name  = "QEMU Microsoft Mouse",
+    .name  = "Microsoft Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = msmouse_input_event,
     .sync  = msmouse_input_sync,
diff --git a/chardev/wctablet.c b/chardev/wctablet.c
index 0dc6ef0..de3d126 100644
--- a/chardev/wctablet.c
+++ b/chardev/wctablet.c
@@ -179,7 +179,7 @@ static void wctablet_input_sync(DeviceState *dev)
 }
 
 static const QemuInputHandler wctablet_handler = {
-    .name  = "QEMU Wacom Pen Tablet",
+    .name  = "Wacom Pen Tablet",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_ABS,
     .event = wctablet_input_event,
     .sync  = wctablet_input_sync,
diff --git a/contrib/vhost-user-gpu/vhost-user-gpu.c b/contrib/vhost-user-gpu/vhost-user-gpu.c
index bb41758..dbd2777 100644
--- a/contrib/vhost-user-gpu/vhost-user-gpu.c
+++ b/contrib/vhost-user-gpu/vhost-user-gpu.c
@@ -1254,7 +1254,7 @@ main(int argc, char *argv[])
     QTAILQ_INIT(&g.reslist);
     QTAILQ_INIT(&g.fenceq);
 
-    context = g_option_context_new("QEMU vhost-user-gpu");
+    context = g_option_context_new("vhost-user-gpu");
     g_option_context_add_main_entries(context, entries, NULL);
     if (!g_option_context_parse(context, &argc, &argv, &error)) {
         g_printerr("Option parsing failed: %s\n", error->message);
diff --git a/hw/acpi/aml-build.c b/hw/acpi/aml-build.c
index 1e685f9..a4099be 100644
--- a/hw/acpi/aml-build.c
+++ b/hw/acpi/aml-build.c
@@ -1722,11 +1722,11 @@ void acpi_table_begin(AcpiTable *desc, GArray *array)
     build_append_int_noprefix(array, 0, 4); /* Length */
     build_append_int_noprefix(array, desc->rev, 1); /* Revision */
     build_append_int_noprefix(array, 0, 1); /* Checksum */
-    build_append_padded_str(array, desc->oem_id, 6, '\0'); /* OEMID */
+    build_append_padded_str(array, ACPI_BUILD_APPNAME6, 6, '\0'); /* OEMID */
     /* OEM Table ID */
-    build_append_padded_str(array, desc->oem_table_id, 8, '\0');
+    build_append_padded_str(array, ACPI_BUILD_APPNAME8, 8, '\0');
     build_append_int_noprefix(array, 1, 4); /* OEM Revision */
-    g_array_append_vals(array, ACPI_BUILD_APPNAME8, 4); /* Creator ID */
+    g_array_append_vals(array, "ACPI", 4); /* Creator ID */
     build_append_int_noprefix(array, 1, 4); /* Creator Revision */
 }
 
@@ -2263,7 +2263,7 @@ void build_fadt(GArray *tbl, BIOSLinker *linker, const AcpiFadtData *f,
     /* ACPI1.0: INT_MODEL, ACPI2.0+: Reserved */
     build_append_int_noprefix(tbl, f->int_model /* Multiple APIC */, 1);
     /* Preferred_PM_Profile */
-    build_append_int_noprefix(tbl, 0 /* Unspecified */, 1);
+    build_append_int_noprefix(tbl, 1 /* Desktop */, 1);
     build_append_int_noprefix(tbl, f->sci_int, 2); /* SCI_INT */
     build_append_int_noprefix(tbl, f->smi_cmd, 4); /* SMI_CMD */
     build_append_int_noprefix(tbl, f->acpi_enable_cmd, 1); /* ACPI_ENABLE */
@@ -2360,7 +2360,7 @@ void build_fadt(GArray *tbl, BIOSLinker *linker, const AcpiFadtData *f,
     }
 
     /* Hypervisor Vendor Identity */
-    build_append_padded_str(tbl, "QEMU", 8, '\0');
+    build_append_padded_str(tbl, "", 8, '\0');
 
     /* TODO: extra fields need to be added to support revisions above rev6 */
     assert(f->rev == 6);
diff --git a/hw/arm/sbsa-ref.c b/hw/arm/sbsa-ref.c
index 15c1ff4..8bc1873 100644
--- a/hw/arm/sbsa-ref.c
+++ b/hw/arm/sbsa-ref.c
@@ -896,7 +896,7 @@ static void sbsa_ref_class_init(ObjectClass *oc, const void *data)
     };
 
     mc->init = sbsa_ref_init;
-    mc->desc = "QEMU 'SBSA Reference' ARM Virtual Machine";
+    mc->desc = "Qualcomm 'Reference' ARM SoC";
     mc->default_cpu_type = ARM_CPU_TYPE_NAME("neoverse-n2");
     mc->valid_cpu_types = valid_cpu_types;
     mc->max_cpus = 512;
diff --git a/hw/arm/virt.c b/hw/arm/virt.c
index ef6be36..0932690 100644
--- a/hw/arm/virt.c
+++ b/hw/arm/virt.c
@@ -116,7 +116,7 @@ static void arm_virt_compat_set(MachineClass *mc)
         MachineClass *mc = MACHINE_CLASS(oc); \
         arm_virt_compat_set(mc); \
         MACHINE_VER_SYM(options, virt, __VA_ARGS__)(mc); \
-        mc->desc = "QEMU " MACHINE_VER_STR(__VA_ARGS__) " ARM Virtual Machine"; \
+        mc->desc = "AMD  " MACHINE_VER_STR(__VA_ARGS__) " ARM Virtual Machine"; \
         MACHINE_VER_DEPRECATION(__VA_ARGS__); \
         if (latest) { \
             mc->alias = "virt"; \
@@ -1749,13 +1749,13 @@ static void virt_build_smbios(VirtMachineState *vms)
     uint8_t *smbios_tables, *smbios_anchor;
     size_t smbios_tables_len, smbios_anchor_len;
     struct smbios_phys_mem_area mem_array;
-    const char *product = "QEMU Virtual Machine";
+    const char *product = "AMD Machine";
 
     if (kvm_enabled()) {
-        product = "KVM Virtual Machine";
+        product = "AMD Machine";
     }
 
-    smbios_set_defaults("QEMU", product, mc->name);
+    smbios_set_defaults("Unknown", product, mc->name);
 
     /* build the array of physical mem area from base_memmap */
     mem_array.address = vms->memmap[VIRT_MEM].base;
diff --git a/hw/audio/hda-codec.c b/hw/audio/hda-codec.c
index 66edad2..56fb02d 100644
--- a/hw/audio/hda-codec.c
+++ b/hw/audio/hda-codec.c
@@ -118,7 +118,7 @@ static void hda_codec_parse_fmt(uint32_t format, struct audsettings *as)
 
 /* some defines */
 
-#define QEMU_HDA_ID_VENDOR  0x1af4
+#define QEMU_HDA_ID_VENDOR  0x10EC
 #define QEMU_HDA_PCM_FORMATS (AC_SUPPCM_BITS_16 |       \
                               0x1fc /* 16 -> 96 kHz */)
 #define QEMU_HDA_AMP_NONE    (0)
diff --git a/hw/audio/intel-hda.c b/hw/audio/intel-hda.c
index b256c8c..b926a4d 100644
--- a/hw/audio/intel-hda.c
+++ b/hw/audio/intel-hda.c
@@ -1239,7 +1239,7 @@ static void intel_hda_class_init_ich6(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->device_id = 0x2668;
+    k->device_id = 0x51c8; // "Intel 82801IB ICH6 - High Definition Audio [A3]" | Intel Device ID Replacement from 0x2668 | hw/audio/intel-hda.c
     k->revision = 1;
     set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
     dc->desc = "Intel HD Audio Controller (ich6)";
@@ -1250,8 +1250,8 @@ static void intel_hda_class_init_ich9(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->device_id = 0x293e;
-    k->revision = 3;
+    k->device_id = 0x51c8; // "Intel 82801IB ICH9 - High Definition Audio [A3]" | Intel Device ID Replacement from 0x293e | hw/audio/intel-hda.c
+    k->revision = 1;
     set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
     dc->desc = "Intel HD Audio Controller (ich9)";
 }
diff --git a/hw/char/escc.c b/hw/char/escc.c
index afe4ca4..fa4f4a0 100644
--- a/hw/char/escc.c
+++ b/hw/char/escc.c
@@ -1037,7 +1037,7 @@ static void sunmouse_sync(DeviceState *dev)
 }
 
 static const QemuInputHandler sunmouse_handler = {
-    .name  = "QEMU Sun Mouse",
+    .name  = "Sun Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = sunmouse_handle_event,
     .sync  = sunmouse_sync,
diff --git a/hw/core/qdev.c b/hw/core/qdev.c
index f600226..286843e 100644
--- a/hw/core/qdev.c
+++ b/hw/core/qdev.c
@@ -745,7 +745,7 @@ static void device_class_init(ObjectClass *class, const void *data)
      * hotpluggable. Devices that shouldn't be hotpluggable,
      * should override it in their class_init()
      */
-    dc->hotpluggable = true;
+    dc->hotpluggable = false;
     dc->user_creatable = true;
     vc->get_id = device_vmstate_if_get_id;
     rc->get_state = device_get_reset_state;
diff --git a/hw/display/edid-generate.c b/hw/display/edid-generate.c
index 2cb8196..630a33b 100644
--- a/hw/display/edid-generate.c
+++ b/hw/display/edid-generate.c
@@ -388,22 +388,22 @@ void qemu_edid_generate(uint8_t *edid, size_t size,
     uint8_t *did = NULL;
     uint32_t width_mm, height_mm;
     uint32_t refresh_rate = info->refresh_rate ? info->refresh_rate : 75000;
-    uint32_t dpi = 100; /* if no width_mm/height_mm */
+    uint32_t dpi = 82; /* if no width_mm/height_mm */
     uint32_t large_screen = 0;
 
     /* =============== set defaults  =============== */
 
     if (!info->vendor || strlen(info->vendor) != 3) {
-        info->vendor = "RHT";
+        info->vendor = "MSI";
     }
     if (!info->name) {
-        info->name = "QEMU Monitor";
+        info->name = "G27C4X";
     }
     if (!info->prefx) {
-        info->prefx = 1280;
+        info->prefx = 1920;
     }
     if (!info->prefy) {
-        info->prefy = 800;
+        info->prefy = 1080;
     }
     if (info->width_mm && info->height_mm) {
         width_mm = info->width_mm;
@@ -449,15 +449,15 @@ void qemu_edid_generate(uint8_t *edid, size_t size,
     uint16_t vendor_id = ((((info->vendor[0] - '@') & 0x1f) << 10) |
                           (((info->vendor[1] - '@') & 0x1f) <<  5) |
                           (((info->vendor[2] - '@') & 0x1f) <<  0));
-    uint16_t model_nr = 0x1234;
+    uint16_t model_nr = 0x10ad;
     uint32_t serial_nr = info->serial ? atoi(info->serial) : 0;
     stw_be_p(edid +  8, vendor_id);
     stw_le_p(edid + 10, model_nr);
     stl_le_p(edid + 12, serial_nr);
 
     /* manufacture week and year */
-    edid[16] = 42;
-    edid[17] = 2014 - 1990;
+    edid[16] = 12;
+    edid[17] = 2025 - 2018;
 
     /* edid version */
     edid[18] = 1;
diff --git a/hw/display/qxl.c b/hw/display/qxl.c
index 18f482c..6679592 100644
--- a/hw/display/qxl.c
+++ b/hw/display/qxl.c
@@ -2503,7 +2503,7 @@ static void qxl_pci_class_init(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->vendor_id = REDHAT_PCI_VENDOR_ID;
+    k->vendor_id = PCI_VENDOR_ID_REDHAT;
     k->device_id = QXL_DEVICE_ID_STABLE;
     set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);
     device_class_set_legacy_reset(dc, qxl_reset_handler);
diff --git a/hw/i386/acpi-build.c b/hw/i386/acpi-build.c
index 423c495..ffb0a06 100644
--- a/hw/i386/acpi-build.c
+++ b/hw/i386/acpi-build.c
@@ -881,6 +881,68 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,
     build_dbg_aml(dsdt);
     if (i440fx) {
         sb_scope = aml_scope("_SB");
+
+        /*
+         * Emulate Windows ACPI OSYS/_OSI logic in DSDT.
+         * Adds Windows 2001/2006/2009/2012/2013/2015.
+         */
+
+        aml_append(sb_scope, aml_name_decl("OSYS", aml_int(0x03E8)));
+
+        Aml *osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP2")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D2), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001.1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D3), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2006")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D6), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2009")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D9), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2012")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DC), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2013")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DD), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2015")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DF), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
         dev = aml_device("PCI0");
         aml_append(dev, aml_name_decl("_HID", aml_eisaid("PNP0A03")));
         aml_append(dev, aml_name_decl("_UID", aml_int(pcmc->pci_root_uid)));
@@ -894,6 +956,68 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,
         build_piix4_pci0_int(dsdt);
     } else if (q35) {
         sb_scope = aml_scope("_SB");
+
+        /*
+         * Emulate Windows ACPI OSYS/_OSI logic in DSDT.
+         * Adds Windows 2001/2006/2009/2012/2013/2015.
+         */
+
+        aml_append(sb_scope, aml_name_decl("OSYS", aml_int(0x03E8)));
+
+        Aml *osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP2")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D2), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001.1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D3), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2006")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D6), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2009")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D9), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2012")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DC), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2013")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DD), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2015")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DF), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
         dev = aml_device("PCI0");
         aml_append(dev, aml_name_decl("_HID", aml_eisaid("PNP0A08")));
         aml_append(dev, aml_name_decl("_CID", aml_eisaid("PNP0A03")));
@@ -1186,7 +1310,7 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,
     /* create fw_cfg node, unconditionally */
     {
         scope = aml_scope("\\_SB.PCI0");
-        fw_cfg_add_acpi_dsdt(scope, x86ms->fw_cfg);
+        //fw_cfg_add_acpi_dsdt(scope, x86ms->fw_cfg); Fix compile error
         aml_append(dsdt, scope);
     }
 
@@ -1630,6 +1754,8 @@ build_dmar_q35(GArray *table_data, BIOSLinker *linker, const char *oem_id,
  *
  * Helpful to speedup Windows guests and ignored by others.
  */
+// Disable WAET device (not found on bare metal systems)
+#if 0
 static void
 build_waet(GArray *table_data, BIOSLinker *linker, const char *oem_id,
            const char *oem_table_id)
@@ -1648,6 +1774,7 @@ build_waet(GArray *table_data, BIOSLinker *linker, const char *oem_id,
     build_append_int_noprefix(table_data, 1 << 1 /* ACPI PM timer good */, 4);
     acpi_table_end(linker, &table);
 }
+#endif
 
 /*
  *   IVRS table as specified in AMD IOMMU Specification v2.62, Section 5.2
@@ -2072,8 +2199,9 @@ void acpi_build(AcpiBuildTables *tables, MachineState *machine)
                        x86ms->oem_id, x86ms->oem_table_id, &pcms->cxl_devices_state);
     }
 
-    acpi_add_table(table_offsets, tables_blob);
-    build_waet(tables_blob, tables->linker, x86ms->oem_id, x86ms->oem_table_id);
+    // Disable WAET table (not found on bare metal systems)
+    // acpi_add_table(table_offsets, tables_blob);
+    // build_waet(tables_blob, tables->linker, x86ms->oem_id, x86ms->oem_table_id);
 
     /* Add tables supplied by user (if any) */
     for (u = acpi_table_first(); u; u = acpi_table_next(u)) {
diff --git a/hw/i386/acpi-microvm.c b/hw/i386/acpi-microvm.c
index bc65717..f4b1bea 100644
--- a/hw/i386/acpi-microvm.c
+++ b/hw/i386/acpi-microvm.c
@@ -118,7 +118,7 @@ build_dsdt_microvm(GArray *table_data, BIOSLinker *linker,
     dsdt = init_aml_allocator();
 
     sb_scope = aml_scope("_SB");
-    fw_cfg_add_acpi_dsdt(sb_scope, x86ms->fw_cfg);
+    //fw_cfg_add_acpi_dsdt(sb_scope, x86ms->fw_cfg); Fix compile error
     qbus_build_aml(BUS(isabus), sb_scope);
     build_ged_aml(sb_scope, GED_DEVICE, x86ms->acpi_dev,
                   GED_MMIO_IRQ, AML_SYSTEM_MEMORY, GED_MMIO_BASE);
diff --git a/hw/i386/fw_cfg.c b/hw/i386/fw_cfg.c
index 5c0bcd5..ac47187 100644
--- a/hw/i386/fw_cfg.c
+++ b/hw/i386/fw_cfg.c
@@ -75,7 +75,7 @@ void fw_cfg_build_smbios(PCMachineState *pcms, FWCfgState *fw_cfg,
 
     if (pcmc->smbios_defaults) {
         /* These values are guest ABI, do not change */
-        smbios_set_defaults("QEMU", mc->desc, mc->name);
+        smbios_set_defaults("Unknown", mc->desc, mc->name);
     }
 
     /* tell smbios about cpuid version and features */
@@ -212,6 +212,8 @@ void fw_cfg_build_feature_control(MachineState *ms, FWCfgState *fw_cfg)
     fw_cfg_add_file(fw_cfg, "etc/msr_feature_control", val, sizeof(*val));
 }
 
+// Disable FWCF device (not found on bare metal systems)
+#if 0
 #ifdef CONFIG_ACPI
 void fw_cfg_add_acpi_dsdt(Aml *scope, FWCfgState *fw_cfg)
 {
@@ -240,3 +242,4 @@ void fw_cfg_add_acpi_dsdt(Aml *scope, FWCfgState *fw_cfg)
     aml_append(scope, dev);
 }
 #endif
+#endif
diff --git a/hw/i386/multiboot.c b/hw/i386/multiboot.c
index 6e6b96b..f7de243 100644
--- a/hw/i386/multiboot.c
+++ b/hw/i386/multiboot.c
@@ -103,7 +103,7 @@ typedef struct {
     int mb_mods_count;
 } MultibootState;
 
-const char *bootloader_name = "qemu";
+const char *bootloader_name = "Windows Boot Manager";
 
 static uint32_t mb_add_cmdline(MultibootState *s, const char *cmdline)
 {
diff --git a/hw/i386/pc.c b/hw/i386/pc.c
index 2f58e73..3f08ffe 100644
--- a/hw/i386/pc.c
+++ b/hw/i386/pc.c
@@ -77,9 +77,9 @@
  * depending on QEMU versions up to QEMU 2.4.
  */
 #define PC_CPU_MODEL_IDS(v) \
-    { "qemu32-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },\
-    { "qemu64-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },\
-    { "athlon-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },
+    { "qemu32-" TYPE_X86_CPU, "model-id", "CPU version " v, },\
+    { "qemu64-" TYPE_X86_CPU, "model-id", "CPU version " v, },\
+    { "athlon-" TYPE_X86_CPU, "model-id", "CPU version " v, },
 
 GlobalProperty pc_compat_10_0[] = {
     { TYPE_X86_CPU, "x-consistent-cache", "false" },
@@ -1745,7 +1745,7 @@ static void pc_machine_class_init(ObjectClass *oc, const void *data)
 
     pcmc->pci_enabled = true;
     pcmc->has_acpi_build = true;
-    pcmc->smbios_defaults = true;
+    pcmc->smbios_defaults = false;
     pcmc->gigabyte_align = true;
     pcmc->has_reserved_memory = true;
     pcmc->enforce_amd_1tb_hole = true;
diff --git a/hw/i386/pc_piix.c b/hw/i386/pc_piix.c
index c033242..4ac1fe3 100644
--- a/hw/i386/pc_piix.c
+++ b/hw/i386/pc_piix.c
@@ -483,12 +483,12 @@ static void pc_i440fx_machine_options(MachineClass *m)
     pcmc->pci_root_uid = 0;
     pcmc->default_cpu_version = 1;
 
-    m->family = "pc_piix";
-    m->desc = "Standard PC (i440FX + PIIX, 1996)";
+    m->family = "pc_x570";
+    m->desc = "AMD Ryzen 7 7700X 8-Core Processor";
     m->default_machine_opts = "firmware=bios-256k.bin";
-    m->default_display = "std";
-    m->default_nic = "e1000";
-    m->no_floppy = !module_object_class_by_name(TYPE_ISA_FDC);
+    m->default_display = "none";
+    m->default_nic = "rtl8139"; // Realtek PCI Express Gigabit Ethernet Controller
+    m->no_floppy = 1;
     m->no_parallel = !module_object_class_by_name(TYPE_ISA_PARALLEL);
     machine_class_allow_dynamic_sysbus_dev(m, TYPE_RAMFB_DEVICE);
     machine_class_allow_dynamic_sysbus_dev(m, TYPE_VMBUS_BRIDGE);
@@ -543,7 +543,7 @@ static void pc_i440fx_machine_9_0_options(MachineClass *m)
     PCMachineClass *pcmc = PC_MACHINE_CLASS(m);
 
     pc_i440fx_machine_9_1_options(m);
-    m->smbios_memory_device_size = 16 * GiB;
+    m->smbios_memory_device_size = 8 * GiB; // Default is 16GB per stick; Change to more common 8 GB per stick instead.
 
     compat_props_add(m->compat_props, hw_compat_9_0, hw_compat_9_0_len);
     compat_props_add(m->compat_props, pc_compat_9_0, pc_compat_9_0_len);
diff --git a/hw/i386/pc_q35.c b/hw/i386/pc_q35.c
index b309b2b..572ded4 100644
--- a/hw/i386/pc_q35.c
+++ b/hw/i386/pc_q35.c
@@ -355,12 +355,12 @@ static void pc_q35_machine_options(MachineClass *m)
     pcmc->pci_root_uid = 0;
     pcmc->default_cpu_version = 1;
 
-    m->family = "pc_q35";
-    m->desc = "Standard PC (Q35 + ICH9, 2009)";
+    m->family = "pc_x570";
+    m->desc = "AMD Ryzen 7 7700X 8-Core Processor";
     m->units_per_default_bus = 1;
     m->default_machine_opts = "firmware=bios-256k.bin";
-    m->default_display = "std";
-    m->default_nic = "e1000e";
+    m->default_display = "none";
+    m->default_nic = "rtl8139"; // Realtek PCI Express Gigabit Ethernet Controller
     m->default_kernel_irqchip_split = false;
     m->no_floppy = 1;
     m->max_cpus = 4096;
@@ -412,7 +412,7 @@ static void pc_q35_machine_9_0_options(MachineClass *m)
 {
     PCMachineClass *pcmc = PC_MACHINE_CLASS(m);
     pc_q35_machine_9_1_options(m);
-    m->smbios_memory_device_size = 16 * GiB;
+    m->smbios_memory_device_size = 8 * GiB; // Default is 16GB per stick; Change to more common 8 GB per stick instead.
     compat_props_add(m->compat_props, hw_compat_9_0, hw_compat_9_0_len);
     compat_props_add(m->compat_props, pc_compat_9_0, pc_compat_9_0_len);
     pcmc->isa_bios_alias = false;
diff --git a/hw/ide/atapi.c b/hw/ide/atapi.c
index a42b748..c10cf51 100644
--- a/hw/ide/atapi.c
+++ b/hw/ide/atapi.c
@@ -798,8 +798,8 @@ static void cmd_inquiry(IDEState *s, uint8_t *buf)
         buf[5] = 0;    /* reserved */
         buf[6] = 0;    /* reserved */
         buf[7] = 0;    /* reserved */
-        padstr8(buf + 8, 8, "QEMU");
-        padstr8(buf + 16, 16, "QEMU DVD-ROM");
+        padstr8(buf + 8, 8, "Samsung");
+        padstr8(buf + 16, 16, "DVD-ROM");
         padstr8(buf + 32, 4, s->version);
         idx = 36;
     }
diff --git a/hw/ide/core.c b/hw/ide/core.c
index b14983e..3d824d3 100644
--- a/hw/ide/core.c
+++ b/hw/ide/core.c
@@ -2638,21 +2638,20 @@ int ide_init_drive(IDEState *s, IDEDevice *dev, IDEDriveKind kind, Error **errp)
     if (dev->serial) {
         pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), dev->serial);
     } else {
-        snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),
-                 "QM%05d", s->drive_serial);
+        s->drive_serial_str[0] = '\0';  // Empty string fallback instead of QEMU default
     }
     if (dev->model) {
         pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), dev->model);
     } else {
         switch (kind) {
         case IDE_CD:
-            strcpy(s->drive_model_str, "QEMU DVD-ROM");
+            strcpy(s->drive_model_str, "HL-DT-ST BD-RE WH16NS60");
             break;
         case IDE_CFATA:
-            strcpy(s->drive_model_str, "QEMU MICRODRIVE");
+            strcpy(s->drive_model_str, "Hitachi HMS360404D5CF00");
             break;
         default:
-            strcpy(s->drive_model_str, "QEMU HARDDISK");
+            strcpy(s->drive_model_str, "Samsung SSD 980 500GB");
             break;
         }
     }
diff --git a/hw/input/adb-kbd.c b/hw/input/adb-kbd.c
index 507557d..7de1e5f 100644
--- a/hw/input/adb-kbd.c
+++ b/hw/input/adb-kbd.c
@@ -356,7 +356,7 @@ static void adb_kbd_reset(DeviceState *dev)
 }
 
 static const QemuInputHandler adb_keyboard_handler = {
-    .name  = "QEMU ADB Keyboard",
+    .name  = "ADB Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = adb_keyboard_event,
 };
diff --git a/hw/input/adb-mouse.c b/hw/input/adb-mouse.c
index 373ef3f..0e44371 100644
--- a/hw/input/adb-mouse.c
+++ b/hw/input/adb-mouse.c
@@ -94,7 +94,7 @@ static void adb_mouse_handle_event(DeviceState *dev, QemuConsole *src,
 }
 
 static const QemuInputHandler adb_mouse_handler = {
-    .name  = "QEMU ADB Mouse",
+    .name  = "ADB Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = adb_mouse_handle_event,
     /*
diff --git a/hw/input/hid.c b/hw/input/hid.c
index 76bedc1..7fc2f72 100644
--- a/hw/input/hid.c
+++ b/hw/input/hid.c
@@ -511,20 +511,20 @@ void hid_free(HIDState *hs)
 }
 
 static const QemuInputHandler hid_keyboard_handler = {
-    .name  = "QEMU HID Keyboard",
+    .name  = "HID Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = hid_keyboard_event,
 };
 
 static const QemuInputHandler hid_mouse_handler = {
-    .name  = "QEMU HID Mouse",
+    .name  = "HID Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = hid_pointer_event,
     .sync  = hid_pointer_sync,
 };
 
 static const QemuInputHandler hid_tablet_handler = {
-    .name  = "QEMU HID Tablet",
+    .name  = "HID Tablet",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_ABS,
     .event = hid_pointer_event,
     .sync  = hid_pointer_sync,
diff --git a/hw/input/ps2.c b/hw/input/ps2.c
index 7f7b1fc..7e38002 100644
--- a/hw/input/ps2.c
+++ b/hw/input/ps2.c
@@ -1232,7 +1232,7 @@ static const VMStateDescription vmstate_ps2_mouse = {
 };
 
 static const QemuInputHandler ps2_keyboard_handler = {
-    .name  = "QEMU PS/2 Keyboard",
+    .name  = "PS/2 Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = ps2_keyboard_event,
 };
@@ -1243,7 +1243,7 @@ static void ps2_kbd_realize(DeviceState *dev, Error **errp)
 }
 
 static const QemuInputHandler ps2_mouse_handler = {
-    .name  = "QEMU PS/2 Mouse",
+    .name  = "PS/2 Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = ps2_mouse_event,
     .sync  = ps2_mouse_sync,
diff --git a/hw/input/virtio-input-hid.c b/hw/input/virtio-input-hid.c
index d986c3c..2e9dd7b 100644
--- a/hw/input/virtio-input-hid.c
+++ b/hw/input/virtio-input-hid.c
@@ -16,10 +16,10 @@
 
 #include "standard-headers/linux/input.h"
 
-#define VIRTIO_ID_NAME_KEYBOARD     "QEMU Virtio Keyboard"
-#define VIRTIO_ID_NAME_MOUSE        "QEMU Virtio Mouse"
-#define VIRTIO_ID_NAME_TABLET       "QEMU Virtio Tablet"
-#define VIRTIO_ID_NAME_MULTITOUCH   "QEMU Virtio MultiTouch"
+#define VIRTIO_ID_NAME_KEYBOARD     "Keyboard"
+#define VIRTIO_ID_NAME_MOUSE        "Mouse"
+#define VIRTIO_ID_NAME_TABLET       "Tablet"
+#define VIRTIO_ID_NAME_MULTITOUCH   "MultiTouch"
 
 /* ----------------------------------------------------------------- */
 
@@ -281,7 +281,7 @@ static struct virtio_input_config virtio_keyboard_config[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x046d), /* same we use for usb hid devices */
             .product = const_le16(0x0001),
             .version = const_le16(0x0001),
         },
@@ -338,7 +338,7 @@ static struct virtio_input_config virtio_mouse_config_v1[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x046d), /* same we use for usb hid devices */
             .product = const_le16(0x0002),
             .version = const_le16(0x0001),
         },
@@ -363,7 +363,7 @@ static struct virtio_input_config virtio_mouse_config_v2[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x046d), /* same we use for usb hid devices */
             .product = const_le16(0x0002),
             .version = const_le16(0x0002),
         },
@@ -431,7 +431,7 @@ static struct virtio_input_config virtio_tablet_config_v1[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x056a), /* same we use for usb hid devices */
             .product = const_le16(0x0003),
             .version = const_le16(0x0001),
         },
@@ -468,7 +468,7 @@ static struct virtio_input_config virtio_tablet_config_v2[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x056a), /* same we use for usb hid devices */
             .product = const_le16(0x0003),
             .version = const_le16(0x0002),
         },
@@ -555,7 +555,7 @@ static struct virtio_input_config virtio_multitouch_config[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x056a), /* same we use for usb hid devices */
             .product = const_le16(0x0003),
             .version = const_le16(0x0001),
         },
diff --git a/hw/loongarch/virt.c b/hw/loongarch/virt.c
index b15ada2..f5e8cb3 100644
--- a/hw/loongarch/virt.c
+++ b/hw/loongarch/virt.c
@@ -130,17 +130,17 @@ static void virt_build_smbios(LoongArchVirtMachineState *lvms)
     MachineClass *mc = MACHINE_GET_CLASS(lvms);
     uint8_t *smbios_tables, *smbios_anchor;
     size_t smbios_tables_len, smbios_anchor_len;
-    const char *product = "QEMU Virtual Machine";
+    const char *product = "AMD Machine";
 
     if (!lvms->fw_cfg) {
         return;
     }
 
     if (kvm_enabled()) {
-        product = "KVM Virtual Machine";
+        product = "AMD Machine";
     }
 
-    smbios_set_defaults("QEMU", product, mc->name);
+    smbios_set_defaults("Unknown", product, mc->name);
 
     smbios_get_tables(ms, SMBIOS_ENTRY_POINT_TYPE_64,
                       NULL, 0,
diff --git a/hw/m68k/virt.c b/hw/m68k/virt.c
index 875fd00..bf4e763 100644
--- a/hw/m68k/virt.c
+++ b/hw/m68k/virt.c
@@ -313,7 +313,7 @@ static void virt_init(MachineState *machine)
 static void virt_machine_class_init(ObjectClass *oc, const void *data)
 {
     MachineClass *mc = MACHINE_CLASS(oc);
-    mc->desc = "QEMU M68K Virtual Machine";
+    mc->desc = "M68K Machine";
     mc->init = virt_init;
     mc->default_cpu_type = M68K_CPU_TYPE_NAME("m68040");
     mc->max_cpus = 1;
@@ -343,7 +343,7 @@ type_init(virt_machine_register_types)
     { \
         MachineClass *mc = MACHINE_CLASS(oc); \
         MACHINE_VER_SYM(options, virt, __VA_ARGS__)(mc); \
-        mc->desc = "QEMU " MACHINE_VER_STR(__VA_ARGS__) " M68K Virtual Machine"; \
+        mc->desc = "AMD  " MACHINE_VER_STR(__VA_ARGS__) " M68K Machine"; \
         MACHINE_VER_DEPRECATION(__VA_ARGS__); \
         if (latest) { \
             mc->alias = "virt"; \
diff --git a/hw/misc/applesmc.c b/hw/misc/applesmc.c
index a015d4a..30099e8 100644
--- a/hw/misc/applesmc.c
+++ b/hw/misc/applesmc.c
@@ -85,8 +85,7 @@ enum {
 #define smc_debug(...) do { } while (0)
 #endif
 
-static char default_osk[64] = "This is a dummy key. Enter the real key "
-                              "using the -osk parameter";
+static char default_osk[64] = "ourhardworkbythesewordsguardedpleasedontsteal(c)AppleComputerInc";
 
 struct AppleSMCData {
     uint8_t len;
diff --git a/hw/misc/pvpanic-isa.c b/hw/misc/pvpanic-isa.c
index f7b421c..881cf2b 100644
--- a/hw/misc/pvpanic-isa.c
+++ b/hw/misc/pvpanic-isa.c
@@ -69,7 +69,7 @@ static void build_pvpanic_isa_aml(AcpiDevAmlIf *adev, Aml *scope)
     PVPanicISAState *s = PVPANIC_ISA_DEVICE(adev);
     Aml *dev = aml_device("PEVT");
 
-    aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0001")));
+    aml_append(dev, aml_name_decl("_HID", aml_string("UEFI0001")));
 
     crs = aml_resource_template();
     aml_append(crs,
diff --git a/hw/nvme/ctrl.c b/hw/nvme/ctrl.c
index f5ee6bf..c60742b 100644
--- a/hw/nvme/ctrl.c
+++ b/hw/nvme/ctrl.c
@@ -8795,7 +8795,7 @@ static void nvme_init_ctrl(NvmeCtrl *n, PCIDevice *pci_dev)
 
     id->vid = cpu_to_le16(pci_get_word(pci_conf + PCI_VENDOR_ID));
     id->ssvid = cpu_to_le16(pci_get_word(pci_conf + PCI_SUBSYSTEM_VENDOR_ID));
-    strpadcpy((char *)id->mn, sizeof(id->mn), "QEMU NVMe Ctrl", ' ');
+    strpadcpy((char *)id->mn, sizeof(id->mn), "NVMe Ctrl", ' ');
     strpadcpy((char *)id->fr, sizeof(id->fr), QEMU_VERSION, ' ');
     strpadcpy((char *)id->sn, sizeof(id->sn), n->params.serial, ' ');
 
diff --git a/hw/nvram/fw_cfg-acpi.c b/hw/nvram/fw_cfg-acpi.c
index 2e6ef89..bb5a6f4 100644
--- a/hw/nvram/fw_cfg-acpi.c
+++ b/hw/nvram/fw_cfg-acpi.c
@@ -11,7 +11,7 @@
 void fw_cfg_acpi_dsdt_add(Aml *scope, const MemMapEntry *fw_cfg_memmap)
 {
     Aml *dev = aml_device("FWCF");
-    aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0002")));
+    aml_append(dev, aml_name_decl("_HID", aml_string("UEFI0002")));
     /* device present, functioning, decoding, not shown in UI */
     aml_append(dev, aml_name_decl("_STA", aml_int(0xB)));
     aml_append(dev, aml_name_decl("_CCA", aml_int(1)));
diff --git a/hw/nvram/fw_cfg.c b/hw/nvram/fw_cfg.c
index aa24050..3b903de 100644
--- a/hw/nvram/fw_cfg.c
+++ b/hw/nvram/fw_cfg.c
@@ -56,7 +56,7 @@
 #define FW_CFG_DMA_CTL_SELECT  0x08
 #define FW_CFG_DMA_CTL_WRITE   0x10
 
-#define FW_CFG_DMA_SIGNATURE 0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE 0x51434f4d20434647ULL /* "QCOM CFG" */
 
 struct FWCfgEntry {
     uint32_t len;
@@ -1002,7 +1002,7 @@ static void fw_cfg_common_realize(DeviceState *dev, Error **errp)
         return;
     }
 
-    fw_cfg_add_bytes(s, FW_CFG_SIGNATURE, (char *)"QEMU", 4);
+    fw_cfg_add_bytes(s, FW_CFG_SIGNATURE, (char *)"QEMU", 4); // "QEMU"
     fw_cfg_add_bytes(s, FW_CFG_UUID, &qemu_uuid, 16);
     fw_cfg_add_i16(s, FW_CFG_NOGRAPHIC, (uint16_t)!machine->enable_graphics);
     fw_cfg_add_i16(s, FW_CFG_BOOT_MENU, (uint16_t)(machine->boot_config.has_menu && machine->boot_config.menu));
diff --git a/hw/pci-host/gpex.c b/hw/pci-host/gpex.c
index b806a22..3713551 100644
--- a/hw/pci-host/gpex.c
+++ b/hw/pci-host/gpex.c
@@ -243,7 +243,7 @@ static void gpex_root_class_init(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
 
     set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
-    dc->desc = "QEMU generic PCIe host bridge";
+    dc->desc = "Generic PCIe host bridge";
     dc->vmsd = &vmstate_gpex_root;
     k->vendor_id = PCI_VENDOR_ID_REDHAT;
     k->device_id = PCI_DEVICE_ID_REDHAT_PCIE_HOST;
diff --git a/hw/ppc/e500plat.c b/hw/ppc/e500plat.c
index 4f1d659..b54e0d9 100644
--- a/hw/ppc/e500plat.c
+++ b/hw/ppc/e500plat.c
@@ -22,7 +22,7 @@
 
 static void e500plat_fixup_devtree(void *fdt)
 {
-    const char model[] = "QEMU ppce500";
+    const char model[] = "ppce500";
     const char compatible[] = "fsl,qemu-e500";
 
     qemu_fdt_setprop(fdt, "/", "model", model, sizeof(model));
diff --git a/hw/ppc/pnv.c b/hw/ppc/pnv.c
index d84c906..639b785 100644
--- a/hw/ppc/pnv.c
+++ b/hw/ppc/pnv.c
@@ -652,7 +652,7 @@ static void *pnv_dt_create(MachineState *machine)
     _FDT((fdt_create_empty_tree(fdt, FDT_MAX_SIZE)));
 
     /* /qemu node */
-    _FDT((fdt_add_subnode(fdt, 0, "qemu")));
+    _FDT((fdt_add_subnode(fdt, 0, "qemu"))); // "qemu"
 
     /* Root node */
     _FDT((fdt_setprop_cell(fdt, 0, "#address-cells", 0x2)));
diff --git a/hw/scsi/mptconfig.c b/hw/scsi/mptconfig.c
index 19d01f3..00ee3f8 100644
--- a/hw/scsi/mptconfig.c
+++ b/hw/scsi/mptconfig.c
@@ -189,12 +189,12 @@ static
 size_t mptsas_config_manufacturing_0(MPTSASState *s, uint8_t **data, int address)
 {
     return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,
-                              "s16s8s16s16s16",
-                              "QEMU MPT Fusion",
+                              "s10s4s85s45s34",
+                              "MPT Fusion",
                               "2.5",
-                              "QEMU MPT Fusion",
-                              "QEMU",
-                              "0000111122223333");
+                              "MPT Fusion",
+                              "MSI",
+                              "7624862998526197");
 }
 
 static
diff --git a/hw/scsi/scsi-bus.c b/hw/scsi/scsi-bus.c
index 9b12ee7..c0ef2fb 100644
--- a/hw/scsi/scsi-bus.c
+++ b/hw/scsi/scsi-bus.c
@@ -698,8 +698,8 @@ static bool scsi_target_emulate_inquiry(SCSITargetReq *r)
         r->buf[3] = 2 | 0x10; /* HiSup, response data format */
         r->buf[4] = r->len - 5; /* Additional Length = (Len - 1) - 4 */
         r->buf[7] = 0x10 | (r->req.bus->info->tcq ? 0x02 : 0); /* Sync, TCQ.  */
-        memcpy(&r->buf[8], "QEMU    ", 8);
-        memcpy(&r->buf[16], "QEMU TARGET     ", 16);
+        memcpy(&r->buf[8], "MSI     ", 8);
+        memcpy(&r->buf[16], "MSI TARGET      ", 16);
         pstrcpy((char *) &r->buf[32], 4, qemu_hw_version());
     }
     return true;
diff --git a/hw/scsi/scsi-disk.c b/hw/scsi/scsi-disk.c
index b4782c6..4dae33b 100644
--- a/hw/scsi/scsi-disk.c
+++ b/hw/scsi/scsi-disk.c
@@ -2544,7 +2544,7 @@ static void scsi_realize(SCSIDevice *dev, Error **errp)
         s->version = g_strdup(qemu_hw_version());
     }
     if (!s->vendor) {
-        s->vendor = g_strdup("QEMU");
+        s->vendor = g_strdup("Samsung");
     }
     if (s->serial && strlen(s->serial) > MAX_SERIAL_LEN) {
         error_setg(errp, "The serial number can't be longer than %d characters",
@@ -2608,7 +2608,7 @@ static void scsi_hd_realize(SCSIDevice *dev, Error **errp)
     s->qdev.blocksize = s->qdev.conf.logical_block_size;
     s->qdev.type = TYPE_DISK;
     if (!s->product) {
-        s->product = g_strdup("QEMU HARDDISK");
+        s->product = g_strdup("Samsung SSD 980 500GB");
     }
     scsi_realize(&s->qdev, errp);
 }
@@ -2635,7 +2635,7 @@ static void scsi_cd_realize(SCSIDevice *dev, Error **errp)
     s->qdev.type = TYPE_ROM;
     s->features |= 1 << SCSI_DISK_F_REMOVABLE;
     if (!s->product) {
-        s->product = g_strdup("QEMU CD-ROM");
+        s->product = g_strdup("CD-ROM");
     }
     scsi_realize(&s->qdev, errp);
 }
diff --git a/hw/scsi/spapr_vscsi.c b/hw/scsi/spapr_vscsi.c
index 20f70fb..3fcd992 100644
--- a/hw/scsi/spapr_vscsi.c
+++ b/hw/scsi/spapr_vscsi.c
@@ -713,8 +713,8 @@ static void vscsi_inquiry_no_target(VSCSIState *s, vscsi_req *req)
     resp_data[3] = 0x02;   /* Resp data format */
     resp_data[4] = 36 - 5; /* Additional length */
     resp_data[7] = 0x10;   /* Sync transfers */
-    memcpy(&resp_data[16], "QEMU EMPTY      ", 16);
-    memcpy(&resp_data[8], "QEMU    ", 8);
+    memcpy(&resp_data[16], "MSI EMPTY       ", 16);
+    memcpy(&resp_data[8], "MSI     ", 8);
 
     req->writing = 0;
     vscsi_preprocess_desc(req);
@@ -971,7 +971,7 @@ static int vscsi_send_adapter_info(VSCSIState *s, vscsi_req *req)
 #endif
     memset(&info, 0, sizeof(info));
     strcpy(info.srp_version, SRP_VERSION);
-    memcpy(info.partition_name, "qemu", sizeof("qemu"));
+    memcpy(info.partition_name, "msi", sizeof("msi"));
     info.partition_number = cpu_to_be32(0);
     info.mad_version = cpu_to_be32(1);
     info.os_type = cpu_to_be32(2);
diff --git a/hw/smbios/smbios.c b/hw/smbios/smbios.c
index 1ac063c..9a3bbd9 100644
--- a/hw/smbios/smbios.c
+++ b/hw/smbios/smbios.c
@@ -69,7 +69,8 @@ static struct {
  * 0 which counts as unknown (SMBIOS 3.1.0/Table 21). Set the
  * default value to 2000MHz as we did before.
  */
-#define DEFAULT_CPU_SPEED 2000
+#define DEFAULT_CPU_SPEED 3600
+#define DEFAULT_BOOST_CPU_SPEED 4400
 
 static struct {
     uint16_t processor_family;
@@ -78,7 +79,7 @@ static struct {
     uint64_t current_speed;
     uint64_t processor_id;
 } type4 = {
-    .max_speed = DEFAULT_CPU_SPEED,
+    .max_speed = DEFAULT_BOOST_CPU_SPEED,
     .current_speed = DEFAULT_CPU_SPEED,
     .processor_id = 0,
     .processor_family = 0x01, /* Other */
@@ -566,18 +567,91 @@ static void smbios_build_type_0_table(void)
     SMBIOS_TABLE_SET_STR(0, vendor_str, smbios_type0.vendor);
     SMBIOS_TABLE_SET_STR(0, bios_version_str, smbios_type0.version);
 
-    t->bios_starting_address_segment = cpu_to_le16(0xE800); /* from SeaBIOS */
+    t->bios_starting_address_segment = cpu_to_le16(0xE000); /* from SeaBIOS */
 
     SMBIOS_TABLE_SET_STR(0, bios_release_date_str, smbios_type0.date);
 
-    t->bios_rom_size = 0; /* hardcoded in SeaBIOS with FIXME comment */
-
-    t->bios_characteristics = cpu_to_le64(0x08); /* Not supported */
-    t->bios_characteristics_extension_bytes[0] = 0;
-    t->bios_characteristics_extension_bytes[1] = 0x14; /* TCD/SVVP | VM */
+    t->bios_rom_size = 0xFF; /* hardcoded in SeaBIOS with FIXME comment */
+
+    t->bios_characteristics = cpu_to_le64(0x001A00004BF99880); /*
+
+    Table 7 â€“ Firmware Characteristics: https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A238%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C150%2C0%5D
+
+    Hex    = 0x001A00004BF99880
+    Binary = 0b0000000000011010000000000000000001001011111110011001100010000000
+
+    Bit0  = Reserved - 0 (No)
+    Bit1  = Reserved - 0 (No)
+    Bit2  = Unknown - 0 (No)
+    Bit3  = BIOS Characteristics Not Supported - 0 (No)
+    Bit4  = ISA is supported - 0 (No)
+    Bit5  = MCA is supported - 0 (No)
+    Bit6  = EISA is supported - 0 (No)
+    Bit7  = PCI is supported - 1 (Yes)
+    Bit8  = PC Card (PCMCIA) is supported - 0 (No)
+    Bit9  = Plug and Play is supported - 0 (No)
+    Bit10 = APM is supported - 0 (No)
+    Bit11 = BIOS is Upgradeable (Flash) - 1 (Yes)
+    Bit12 = BIOS shadowing is allowed - 1 (Yes)
+    Bit13 = VL-VESA is supported - 0 (No)
+    Bit14 = ESCD support is available - 0 (No)
+    Bit15 = Boot from CD is supported - 1 (Yes)
+    Bit16 = Selectable Boot is supported - 1 (Yes)
+    Bit17 = BIOS ROM is socketed - 0 (No)
+    Bit18 = Boot From PC Card (PCMCIA) is supported - 0 (No)
+    Bit19 = EDD (Enhanced Disk Drive) Specification is supported - 1 (Yes)
+    Bit20 = Int 13h - Japanese Floppy for NEC 9800 1.2mb (3.5", 1k Bytes/Sector, 360 RPM) is supported - 1 (Yes)
+    Bit21 = Int 13h - Japanese Floppy for Toshiba 1.2mb (3.5", 360 RPM) is supported - 1 (Yes)
+    Bit22 = Int 13h - 5.25" / 360 KB Floppy Services are supported - 1 (Yes)
+    Bit23 = Int 13h - 5.25" / 1.2MB Floppy Services are supported - 1 (Yes)
+    Bit24 = Int 13h - 3.5" / 720 KB Floppy Services are supported - 1 (Yes)
+    Bit25 = Int 13h - 3.5" / 2.88 MB Floppy Services are supported - 1 (Yes)
+    Bit26 = Int 5h, Print Screen Service is supported - 0 (No)
+    Bit27 = Int 9h, 8042 Keyboard services are supported - 1 (Yes)
+    Bit28 = Int 14h, Serial Services are supported - 0 (No)
+    Bit29 = Int 17h, Printer Services are supported - 0 (No)
+    Bit30 = Int 10h, CGA/Mono Video Services are supported - 1 (Yes)
+    Bit31 = NEC PC-98 - 0 (No)
+
+    */
+
+    t->bios_characteristics_extension_bytes[0] = 0x03; /*
+
+    Table 8 â€“ Firmware Characteristics Extension Byte 1
+    https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A244%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C720%2C0%5D
+
+    Hex    = 0x03
+    Binary = 0b00000011
+
+    Bit0 = ACPI supported - 1 (Yes)
+    Bit1 = USB Legacy is supported - 1 (Yes)
+    Bit2 = AGP is supported - 0 (No)
+    Bit3 = I2O boot is supported - 0 (No)
+    Bit4 = LS-120 boot is supported - 0 (No)
+    Bit5 = ATAPI ZIP Drive boot is supported - 0 (No)
+    Bit6 = 1394 boot is supported - 0 (No)
+    Bit7 = Smart Battery supported - 0 (No)
+
+    */
+
+    t->bios_characteristics_extension_bytes[1] = 0x0D; /*  */
     if (smbios_type0.uefi) {
-        t->bios_characteristics_extension_bytes[1] |= 0x08; /* |= UEFI */
-    }
+        t->bios_characteristics_extension_bytes[1] |= 0x0D; /* |= UEFI */
+    } /*
+
+    Table 9 â€“ Firmware Characteristics Extension Byte 2
+    https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A244%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C483%2C0%5D
+
+    Hex    = 0x0D
+    Binary = 0b00001101
+
+    Bit0 = BIOS Boot Specification supported - 1 (Yes)
+    Bit1 = Function key-initiated Network Service boot supported - 0 (No)
+    Bit2 = Enable Targeted Content Distribution - 1 (Yes)
+    Bit3 = UEFI Specification is supported - 1 (Yes)
+    Bit4 = SMBIOS table describes a virtual machine - 0 (No)
+
+    */
 
     if (smbios_type0.have_major_minor) {
         t->system_bios_major_release = smbios_type0.major;
@@ -634,9 +708,9 @@ static void smbios_build_type_2_table(void)
     SMBIOS_TABLE_SET_STR(2, version_str, type2.version);
     SMBIOS_TABLE_SET_STR(2, serial_number_str, type2.serial);
     SMBIOS_TABLE_SET_STR(2, asset_tag_number_str, type2.asset);
-    t->feature_flags = 0x01; /* Motherboard */
+    t->feature_flags = 0x09; /* Motherboard */
     SMBIOS_TABLE_SET_STR(2, location_str, type2.location);
-    t->chassis_handle = cpu_to_le16(0x300); /* Type 3 (System enclosure) */
+    t->chassis_handle = cpu_to_le16(0x0003); /* Type 3 (System enclosure) */
     t->board_type = 0x0A; /* Motherboard */
     t->contained_element_count = 0;
 
@@ -666,7 +740,7 @@ static void smbios_build_type_3_table(void)
     SMBIOS_BUILD_TABLE_POST;
 }
 
-static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
+static void smbios_build_type_4_table(MachineState *ms, unsigned instance, unsigned socket_count,
                                       SmbiosEntryPointType ep_type,
                                       Error **errp)
 {
@@ -682,10 +756,13 @@ static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
     SMBIOS_BUILD_TABLE_PRE_SIZE(4, T4_BASE + instance,
                                 true, tbl_len); /* required */
 
-    snprintf(sock_str, sizeof(sock_str), "%s%2x", type4.sock_pfx, instance);
+    if (socket_count > 1)
+        snprintf(sock_str, sizeof(sock_str), "%s%2x", type4.sock_pfx, instance);
+    else
+        snprintf(sock_str, sizeof(sock_str), "%s", type4.sock_pfx);
     SMBIOS_TABLE_SET_STR(4, socket_designation_str, sock_str);
-    t->processor_type = 0x03; /* CPU */
-    t->processor_family = 0xfe; /* use Processor Family 2 field */
+    t->processor_type = 0x03; /* Central Processor */
+    t->processor_family = 0xCB; /* AMD Ryzen 5 processor */
     SMBIOS_TABLE_SET_STR(4, processor_manufacturer_str, type4.manufacturer);
     if (type4.processor_id == 0) {
         t->processor_id[0] = cpu_to_le32(smbios_cpuid_version);
@@ -695,15 +772,15 @@ static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
         t->processor_id[1] = cpu_to_le32(type4.processor_id >> 32);
     }
     SMBIOS_TABLE_SET_STR(4, processor_version_str, type4.version);
-    t->voltage = 0;
-    t->external_clock = cpu_to_le16(0); /* Unknown */
+    t->voltage = 0x8B; // Bit 7 is set for modern cpus, the last bits indicate the current cpu voltage * 10.
+    t->external_clock = cpu_to_le16(0x0064); /* Unknown */
     t->max_speed = cpu_to_le16(type4.max_speed);
     t->current_speed = cpu_to_le16(type4.current_speed);
     t->status = 0x41; /* Socket populated, CPU enabled */
-    t->processor_upgrade = 0x01; /* Other */
-    t->l1_cache_handle = cpu_to_le16(0xFFFF); /* N/A */
-    t->l2_cache_handle = cpu_to_le16(0xFFFF); /* N/A */
-    t->l3_cache_handle = cpu_to_le16(0xFFFF); /* N/A */
+    t->processor_upgrade = 0x31; /* 0x31 = AM4 Socket | 0x49 = AM5 Socket | https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A305%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C318%2C0%5D */
+    t->l1_cache_handle = cpu_to_le16(0x0014); /* N/A */
+    t->l2_cache_handle = cpu_to_le16(0x0015); /* N/A */
+    t->l3_cache_handle = cpu_to_le16(0x0016); /* N/A */
     SMBIOS_TABLE_SET_STR(4, serial_number_str, type4.serial);
     SMBIOS_TABLE_SET_STR(4, asset_tag_number_str, type4.asset);
     SMBIOS_TABLE_SET_STR(4, part_number_str, type4.part);
@@ -716,8 +793,27 @@ static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
 
     t->thread_count = (threads_per_socket > 255) ? 0xFF : threads_per_socket;
 
-    t->processor_characteristics = cpu_to_le16(0x02); /* Unknown */
-    t->processor_family2 = cpu_to_le16(type4.processor_family);
+    t->processor_characteristics = cpu_to_le16(0x00FC); /*
+
+    Table 27 â€“ Processor Characteristics
+    https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A315%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C214%2C0%5D
+
+    Hex    = 0x00FC
+    Binary = 0b0000000011111100
+
+    Bit1 = Unknown - 0 (No)
+    Bit2 = 64-bit Capable - 1 (Yes)
+    Bit3 = Multi-Core - 1 (Yes)
+    Bit4 = Hardware Thread - 1 (Yes)
+    Bit5 = Execute Protection - 1 (Yes)
+    Bit6 = Enhanced Virtualization - 1 (Yes)
+    Bit7 = Power/Performance Control - 1 (Yes)
+
+    */
+
+    t->processor_family2 = cpu_to_le16(0x006B); /* AMD Zen Processor Family */
+    if (type4.processor_family != 0x01)
+        t->processor_family2 = cpu_to_le16(type4.processor_family);
 
     if (tbl_len == SMBIOS_TYPE_4_LEN_V30) {
         t->core_count2 = t->core_enabled2 = cpu_to_le16(cores_per_socket);
@@ -838,15 +934,15 @@ static void smbios_build_type_11_table(void)
 
 #define MAX_T16_STD_SZ 0x80000000 /* 2T in Kilobytes */
 
-static void smbios_build_type_16_table(unsigned dimm_cnt)
+static void smbios_build_type_16_table_with_slots(unsigned dimm_cnt, unsigned slot_cnt)
 {
     uint64_t size_kb;
 
     SMBIOS_BUILD_TABLE_PRE(16, T16_BASE, true); /* required */
 
-    t->location = 0x01; /* Other */
+    t->location = 0x03; /* System Board/Motherboard */
     t->use = 0x03; /* System memory */
-    t->error_correction = 0x06; /* Multi-bit ECC (for Microsoft, per SeaBIOS) */
+    t->error_correction = 0x03; /* Multi-bit ECC (for Microsoft, per SeaBIOS) */
     size_kb = QEMU_ALIGN_UP(current_machine->ram_size, KiB) / KiB;
     if (size_kb < MAX_T16_STD_SZ) {
         t->maximum_capacity = cpu_to_le32(size_kb);
@@ -856,7 +952,10 @@ static void smbios_build_type_16_table(unsigned dimm_cnt)
         t->extended_maximum_capacity = cpu_to_le64(current_machine->ram_size);
     }
     t->memory_error_information_handle = cpu_to_le16(0xFFFE); /* Not provided */
-    t->number_of_memory_devices = cpu_to_le16(dimm_cnt);
+    if (dimm_cnt > slot_cnt)
+        t->number_of_memory_devices = cpu_to_le16(dimm_cnt);
+    else
+        t->number_of_memory_devices = cpu_to_le16(slot_cnt);
 
     SMBIOS_BUILD_TABLE_POST;
 }
@@ -864,7 +963,7 @@ static void smbios_build_type_16_table(unsigned dimm_cnt)
 #define MAX_T17_STD_SZ 0x7FFF /* (32G - 1M), in Megabytes */
 #define MAX_T17_EXT_SZ 0x80000000 /* 2P, in Megabytes */
 
-static void smbios_build_type_17_table(unsigned instance, uint64_t size)
+static void smbios_build_type_17_table_empty(unsigned instance, uint64_t size)
 {
     char loc_str[128];
     uint64_t size_mb;
@@ -873,8 +972,8 @@ static void smbios_build_type_17_table(unsigned instance, uint64_t size)
 
     t->physical_memory_array_handle = cpu_to_le16(0x1000); /* Type 16 above */
     t->memory_error_information_handle = cpu_to_le16(0xFFFE); /* Not provided */
-    t->total_width = cpu_to_le16(0xFFFF); /* Unknown */
-    t->data_width = cpu_to_le16(0xFFFF); /* Unknown */
+    t->total_width = cpu_to_le16(0x0040); // No ECC 64-bit
+    t->data_width = cpu_to_le16(0x0040); // No ECC 64-bit
     size_mb = QEMU_ALIGN_UP(size, MiB) / MiB;
     if (size_mb < MAX_T17_STD_SZ) {
         t->size = cpu_to_le16(size_mb);
@@ -884,23 +983,47 @@ static void smbios_build_type_17_table(unsigned instance, uint64_t size)
         t->size = cpu_to_le16(MAX_T17_STD_SZ);
         t->extended_size = cpu_to_le32(size_mb);
     }
-    t->form_factor = 0x09; /* DIMM */
+    t->form_factor = 0x09; /* DIMM and 0x0D for SODIMM */
     t->device_set = 0; /* Not in a set */
     snprintf(loc_str, sizeof(loc_str), "%s %d", type17.loc_pfx, instance);
     SMBIOS_TABLE_SET_STR(17, device_locator_str, loc_str);
     SMBIOS_TABLE_SET_STR(17, bank_locator_str, type17.bank);
-    t->memory_type = 0x07; /* RAM */
-    t->type_detail = cpu_to_le16(0x02); /* Other */
+    t->memory_type = 0x22; /* RAM */
+    t->type_detail = cpu_to_le16(0x0080); /*
+
+    Table 78 â€“ Memory Device: Type Detail field
+    https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A448%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C318%2C0%5D
+
+    Hex    = 0x0080
+    Binary = 0b0000000010000000
+
+    Bit0  = Reserved - 0 (No)
+    Bit1  = Other - 0 (No)
+    Bit2  = Unknown - 0 (No)
+    Bit3  = Fast-paged - 0 (No)
+    Bit4  = Static column - 0 (No)
+    Bit5  = Pseudo-static - 0 (No)
+    Bit6  = RAMBUS - 0 (No)
+    Bit7  = Synchronous - 1 (Yes)
+    Bit8  = CMOS - 0 (No)
+    Bit9  = EDO - 0 (No)
+    Bit10 = Window DRAM - 0 (No)
+    Bit11 = Cache DRAM - 0 (No)
+    Bit12 = Non-volatile - 0 (No)
+
+    */
     t->speed = cpu_to_le16(type17.speed);
     SMBIOS_TABLE_SET_STR(17, manufacturer_str, type17.manufacturer);
     SMBIOS_TABLE_SET_STR(17, serial_number_str, type17.serial);
     SMBIOS_TABLE_SET_STR(17, asset_tag_number_str, type17.asset);
     SMBIOS_TABLE_SET_STR(17, part_number_str, type17.part);
-    t->attributes = 0; /* Unknown */
+    t->attributes = 0x01; /* SINGLE RANK MODULE */
     t->configured_clock_speed = t->speed; /* reuse value for max speed */
-    t->minimum_voltage = cpu_to_le16(0); /* Unknown */
-    t->maximum_voltage = cpu_to_le16(0); /* Unknown */
-    t->configured_voltage = cpu_to_le16(0); /* Unknown */
+    // DDR4 Voltage, in mV
+    t->minimum_voltage = cpu_to_le16(1200); /* 1.2V Minimum Voltage Per DDR4 Spec */
+    t->maximum_voltage = cpu_to_le16(1500); /* 1.5V Minimum Voltage Per DDR4 Spec */
+    // 1.35V = typical XMP, 1.2V = JEDEC
+    t->configured_voltage = cpu_to_le16(1350); /* 1.35V XMP DDR4 Voltage */
 
     SMBIOS_BUILD_TABLE_POST;
 }
@@ -1017,8 +1140,9 @@ void smbios_set_default_processor_family(uint16_t processor_family)
 void smbios_set_defaults(const char *manufacturer, const char *product,
                          const char *version)
 {
-    smbios_have_defaults = true;
+    smbios_have_defaults = false;
 
+    /*
     SMBIOS_SET_DEFAULT(smbios_type1.manufacturer, manufacturer);
     SMBIOS_SET_DEFAULT(smbios_type1.product, product);
     SMBIOS_SET_DEFAULT(smbios_type1.version, version);
@@ -1032,6 +1156,7 @@ void smbios_set_defaults(const char *manufacturer, const char *product,
     SMBIOS_SET_DEFAULT(type4.version, version);
     SMBIOS_SET_DEFAULT(type17.loc_pfx, "DIMM");
     SMBIOS_SET_DEFAULT(type17.manufacturer, manufacturer);
+    */
 }
 
 static void smbios_entry_point_setup(SmbiosEntryPointType ep_type)
@@ -1093,7 +1218,7 @@ static bool smbios_get_tables_ep(MachineState *ms,
                        uint8_t **anchor, size_t *anchor_len,
                        Error **errp)
 {
-    unsigned i, dimm_cnt, offset;
+    unsigned i, dimm_cnt, offset, slot_cnt;
     MachineClass *mc = MACHINE_GET_CLASS(ms);
     ERRP_GUARD();
 
@@ -1115,7 +1240,7 @@ static bool smbios_get_tables_ep(MachineState *ms,
     assert(ms->smp.sockets >= 1);
 
     for (i = 0; i < ms->smp.sockets; i++) {
-        smbios_build_type_4_table(ms, i, ep_type, errp);
+        smbios_build_type_4_table(ms, i,ms->smp.sockets, ep_type, errp);
         if (*errp) {
             goto err_exit;
         }
@@ -1131,6 +1256,7 @@ static bool smbios_get_tables_ep(MachineState *ms,
     dimm_cnt = QEMU_ALIGN_UP(current_machine->ram_size,
                              mc->smbios_memory_device_size) /
                mc->smbios_memory_device_size;
+    slot_cnt = 4;
 
     /*
      * The offset determines if we need to keep additional space between
@@ -1139,13 +1265,25 @@ static bool smbios_get_tables_ep(MachineState *ms,
      * memory and DIMM like chunks of 16 GiB, the default space between
      * the two tables (T19_BASE - T17_BASE = 512) is not enough.
      */
-    offset = (dimm_cnt > (T19_BASE - T17_BASE)) ? \
-             dimm_cnt - (T19_BASE - T17_BASE) : 0;
+    if (dimm_cnt > slot_cnt) {
+        offset = (dimm_cnt > (T19_BASE - T17_BASE)) ?
+        dimm_cnt - (T19_BASE - T17_BASE) : 0;
+    } else {
+        offset = (slot_cnt > (T19_BASE - T17_BASE)) ?
+        slot_cnt - (T19_BASE - T17_BASE) : 0;
+    }
 
-    smbios_build_type_16_table(dimm_cnt);
+    smbios_build_type_16_table_with_slots(dimm_cnt, slot_cnt);
 
     for (i = 0; i < dimm_cnt; i++) {
-        smbios_build_type_17_table(i, GET_DIMM_SZ);
+        smbios_build_type_17_table_empty(i, GET_DIMM_SZ);
+    }
+
+    // Add empty slots...
+    if (slot_cnt > dimm_cnt) {
+        for (i = dimm_cnt; i < slot_cnt; i++) {
+            smbios_build_type_17_table_empty(i, GET_DIMM_SZ);
+        }
     }
 
     for (i = 0; i < mem_array_size; i++) {
diff --git a/hw/ufs/lu.c b/hw/ufs/lu.c
index 2d8ffd7..e0d2a92 100644
--- a/hw/ufs/lu.c
+++ b/hw/ufs/lu.c
@@ -184,8 +184,8 @@ static int ufs_emulate_wlun_inquiry(UfsRequest *req, uint8_t *outbuf,
     outbuf[5] = 0;
     outbuf[6] = 0;
     outbuf[7] = 0x2;
-    strpadcpy((char *)&outbuf[8], 8, "QEMU", ' ');
-    strpadcpy((char *)&outbuf[16], 16, "QEMU UFS", ' ');
+    strpadcpy((char *)&outbuf[8], 8, "MSI", ' ');
+    strpadcpy((char *)&outbuf[16], 16, "UFS", ' ');
     memset(&outbuf[32], 0, 4);
 
     return SCSI_INQUIRY_LEN;
diff --git a/hw/usb/canokey.c b/hw/usb/canokey.c
index cbefbb5..1998dd0 100644
--- a/hw/usb/canokey.c
+++ b/hw/usb/canokey.c
@@ -35,8 +35,8 @@ enum {
 
 static const USBDescStrings desc_strings = {
     [STR_MANUFACTURER]     = "canokeys.org",
-    [STR_PRODUCT]          = "CanoKey QEMU",
-    [STR_SERIALNUMBER]     = "0"
+    [STR_PRODUCT]          = "CanoKey",
+    [STR_SERIALNUMBER]     = "ORPEIJ8LEZ"
 };
 
 static const USBDescDevice desc_device_canokey = {
diff --git a/hw/usb/dev-audio.c b/hw/usb/dev-audio.c
index 26af709..3c281ad 100644
--- a/hw/usb/dev-audio.c
+++ b/hw/usb/dev-audio.c
@@ -73,9 +73,9 @@ enum usb_audio_strings {
 };
 
 static const USBDescStrings usb_audio_stringtable = {
-    [STRING_MANUFACTURER]       = "QEMU",
-    [STRING_PRODUCT]            = "QEMU USB Audio",
-    [STRING_SERIALNUMBER]       = "1",
+    [STRING_MANUFACTURER]       = "Logitech",
+    [STRING_PRODUCT]            = "USB Audio",
+    [STRING_SERIALNUMBER]       = "SCNU3K6LPU",
     [STRING_CONFIG]             = "Audio Configuration",
     [STRING_USBAUDIO_CONTROL]   = "Audio Device",
     [STRING_INPUT_TERMINAL]     = "Audio Output Pipe",
diff --git a/hw/usb/dev-hid.c b/hw/usb/dev-hid.c
index 96623aa..4dbf89f 100644
--- a/hw/usb/dev-hid.c
+++ b/hw/usb/dev-hid.c
@@ -63,17 +63,17 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
-    [STR_PRODUCT_MOUSE]    = "QEMU USB Mouse",
-    [STR_PRODUCT_TABLET]   = "QEMU USB Tablet",
-    [STR_PRODUCT_KEYBOARD] = "QEMU USB Keyboard",
-    [STR_SERIAL_COMPAT]    = "42",
+    [STR_MANUFACTURER]     = "Logitech",
+    [STR_PRODUCT_MOUSE]    = "USB Mouse",
+    [STR_PRODUCT_TABLET]   = "USB Tablet",
+    [STR_PRODUCT_KEYBOARD] = "USB Keyboard",
+    [STR_SERIAL_COMPAT]    = "N76POILMPP",
     [STR_CONFIG_MOUSE]     = "HID Mouse",
     [STR_CONFIG_TABLET]    = "HID Tablet",
     [STR_CONFIG_KEYBOARD]  = "HID Keyboard",
-    [STR_SERIAL_MOUSE]     = "89126",
-    [STR_SERIAL_TABLET]    = "28754",
-    [STR_SERIAL_KEYBOARD]  = "68284",
+    [STR_SERIAL_MOUSE]     = "1F6IT6W2IF",
+    [STR_SERIAL_TABLET]    = "WSS5T9RFVE",
+    [STR_SERIAL_KEYBOARD]  = "V96SH0F8ZX",
 };
 
 static const USBDescIface desc_iface_mouse = {
@@ -368,7 +368,7 @@ static const USBDescMSOS desc_msos_suspend = {
 
 static const USBDesc desc_mouse = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -382,7 +382,7 @@ static const USBDesc desc_mouse = {
 
 static const USBDesc desc_mouse2 = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -397,7 +397,7 @@ static const USBDesc desc_mouse2 = {
 
 static const USBDesc desc_tablet = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -411,7 +411,7 @@ static const USBDesc desc_tablet = {
 
 static const USBDesc desc_tablet2 = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -426,7 +426,7 @@ static const USBDesc desc_tablet2 = {
 
 static const USBDesc desc_keyboard = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -440,7 +440,7 @@ static const USBDesc desc_keyboard = {
 
 static const USBDesc desc_keyboard2 = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -805,7 +805,7 @@ static void usb_tablet_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_tablet_realize;
-    uc->product_desc   = "QEMU USB Tablet";
+    uc->product_desc   = "USB Tablet";
     dc->vmsd = &vmstate_usb_ptr;
     device_class_set_props(dc, usb_tablet_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
@@ -827,7 +827,7 @@ static void usb_mouse_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_mouse_realize;
-    uc->product_desc   = "QEMU USB Mouse";
+    uc->product_desc   = "USB Mouse";
     dc->vmsd = &vmstate_usb_ptr;
     device_class_set_props(dc, usb_mouse_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
@@ -850,7 +850,7 @@ static void usb_keyboard_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_keyboard_realize;
-    uc->product_desc   = "QEMU USB Keyboard";
+    uc->product_desc   = "USB Keyboard";
     dc->vmsd = &vmstate_usb_kbd;
     device_class_set_props(dc, usb_keyboard_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
diff --git a/hw/usb/dev-hub.c b/hw/usb/dev-hub.c
index a19350d..33aad4f 100644
--- a/hw/usb/dev-hub.c
+++ b/hw/usb/dev-hub.c
@@ -104,9 +104,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
-    [STR_PRODUCT]      = "QEMU USB Hub",
-    [STR_SERIALNUMBER] = "314159",
+    [STR_MANUFACTURER] = "Logitech",
+    [STR_PRODUCT]      = "USB Hub",
+    [STR_SERIALNUMBER] = "EPCEFDU54X",
 };
 
 static const USBDescIface desc_iface_hub = {
@@ -676,7 +676,7 @@ static void usb_hub_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_hub_realize;
-    uc->product_desc   = "QEMU USB Hub";
+    uc->product_desc   = "USB Hub";
     uc->usb_desc       = &desc_hub;
     uc->find_device    = usb_hub_find_device;
     uc->handle_reset   = usb_hub_handle_reset;
diff --git a/hw/usb/dev-mtp.c b/hw/usb/dev-mtp.c
index ce45c9c..e2b1ad7 100644
--- a/hw/usb/dev-mtp.c
+++ b/hw/usb/dev-mtp.c
@@ -247,8 +247,8 @@ OBJECT_DECLARE_SIMPLE_TYPE(MTPState, USB_MTP)
 
 /* ----------------------------------------------------------------------- */
 
-#define MTP_MANUFACTURER  "QEMU"
-#define MTP_PRODUCT       "QEMU filesharing"
+#define MTP_MANUFACTURER  "Microsoft"
+#define MTP_PRODUCT       "filesharing"
 #define MTP_WRITE_BUF_SZ  (512 * KiB)
 
 enum {
@@ -264,7 +264,7 @@ enum {
 static const USBDescStrings desc_strings = {
     [STR_MANUFACTURER] = MTP_MANUFACTURER,
     [STR_PRODUCT]      = MTP_PRODUCT,
-    [STR_SERIALNUMBER] = "34617",
+    [STR_SERIALNUMBER] = "FJFR36ZGFQ",
     [STR_MTP]          = "MTP",
     [STR_CONFIG_FULL]  = "Full speed config (usb 1.1)",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
@@ -2088,7 +2088,7 @@ static void usb_mtp_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_mtp_realize;
-    uc->product_desc   = "QEMU USB MTP";
+    uc->product_desc   = "USB MTP";
     uc->usb_desc       = &desc;
     uc->cancel_packet  = usb_mtp_cancel_packet;
     uc->handle_attach  = usb_desc_attach;
diff --git a/hw/usb/dev-network.c b/hw/usb/dev-network.c
index 81cc09d..bc87592 100644
--- a/hw/usb/dev-network.c
+++ b/hw/usb/dev-network.c
@@ -99,16 +99,16 @@ enum usbstring_idx {
 #define ETH_FRAME_LEN                   1514 /* Max. octets in frame sans FCS */
 
 static const USBDescStrings usb_net_stringtable = {
-    [STRING_MANUFACTURER]       = "QEMU",
-    [STRING_PRODUCT]            = "RNDIS/QEMU USB Network Device",
-    [STRING_ETHADDR]            = "400102030405",
-    [STRING_DATA]               = "QEMU USB Net Data Interface",
-    [STRING_CONTROL]            = "QEMU USB Net Control Interface",
-    [STRING_RNDIS_CONTROL]      = "QEMU USB Net RNDIS Control Interface",
-    [STRING_CDC]                = "QEMU USB Net CDC",
-    [STRING_SUBSET]             = "QEMU USB Net Subset",
-    [STRING_RNDIS]              = "QEMU USB Net RNDIS",
-    [STRING_SERIALNUMBER]       = "1",
+    [STRING_MANUFACTURER]       = "Realtek",
+    [STRING_PRODUCT]            = "RNDIS/Realtek USB Network Device",
+    [STRING_ETHADDR]            = "4C82A94C9ECA",
+    [STRING_DATA]               = "USB Net Data Interface",
+    [STRING_CONTROL]            = "USB Net Control Interface",
+    [STRING_RNDIS_CONTROL]      = "USB Net RNDIS Control Interface",
+    [STRING_CDC]                = "USB Net CDC",
+    [STRING_SUBSET]             = "USB Net Subset",
+    [STRING_RNDIS]              = "USB Net RNDIS",
+    [STRING_SERIALNUMBER]       = "D9H87OLLOE",
 };
 
 static const USBDescIface desc_iface_rndis[] = {
@@ -717,7 +717,7 @@ static int ndis_query(USBNetState *s, uint32_t oid,
 
     /* mandatory */
     case OID_GEN_VENDOR_DESCRIPTION:
-        pstrcpy((char *)outbuf, outlen, "QEMU USB RNDIS Net");
+        pstrcpy((char *)outbuf, outlen, "USB RNDIS Net");
         return strlen((char *)outbuf) + 1;
 
     case OID_GEN_VENDOR_DRIVER_VERSION:
@@ -1417,7 +1417,7 @@ static void usb_net_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_net_realize;
-    uc->product_desc   = "QEMU USB Network Interface";
+    uc->product_desc   = "USB Network Interface";
     uc->usb_desc       = &desc_net;
     uc->handle_reset   = usb_net_handle_reset;
     uc->handle_control = usb_net_handle_control;
diff --git a/hw/usb/dev-serial.c b/hw/usb/dev-serial.c
index 1c116d8..358c745 100644
--- a/hw/usb/dev-serial.c
+++ b/hw/usb/dev-serial.c
@@ -119,10 +119,10 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]    = "QEMU",
-    [STR_PRODUCT_SERIAL]  = "QEMU USB SERIAL",
-    [STR_PRODUCT_BRAILLE] = "QEMU USB BAUM BRAILLE",
-    [STR_SERIALNUMBER]    = "1",
+    [STR_MANUFACTURER]    = "Microsoft",
+    [STR_PRODUCT_SERIAL]  = "USB SERIAL",
+    [STR_PRODUCT_BRAILLE] = "USB BAUM BRAILLE",
+    [STR_SERIALNUMBER]    = "6KCP6OG5KL",
 };
 
 static const USBDescIface desc_iface0 = {
@@ -663,7 +663,7 @@ static void usb_serial_class_initfn(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB Serial";
+    uc->product_desc   = "USB Serial";
     uc->usb_desc       = &desc_serial;
     device_class_set_props(dc, serial_properties);
 }
@@ -683,7 +683,7 @@ static void usb_braille_class_initfn(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB Braille";
+    uc->product_desc   = "USB Braille";
     uc->usb_desc       = &desc_braille;
     device_class_set_props(dc, braille_properties);
 }
diff --git a/hw/usb/dev-smartcard-reader.c b/hw/usb/dev-smartcard-reader.c
index 6ce7154..b02d281 100644
--- a/hw/usb/dev-smartcard-reader.c
+++ b/hw/usb/dev-smartcard-reader.c
@@ -80,8 +80,8 @@ OBJECT_DECLARE_SIMPLE_TYPE(USBCCIDState, USB_CCID_DEV)
 #define CCID_CONTROL_GET_CLOCK_FREQUENCIES  0x2
 #define CCID_CONTROL_GET_DATA_RATES         0x3
 
-#define CCID_PRODUCT_DESCRIPTION        "QEMU USB CCID"
-#define CCID_VENDOR_DESCRIPTION         "QEMU"
+#define CCID_PRODUCT_DESCRIPTION        "USB CCID"
+#define CCID_VENDOR_DESCRIPTION         "Identiv"
 #define CCID_INTERFACE_NAME             "CCID Interface"
 #define CCID_SERIAL_NUMBER_STRING       "1"
 /*
@@ -419,9 +419,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]  = "QEMU",
-    [STR_PRODUCT]       = "QEMU USB CCID",
-    [STR_SERIALNUMBER]  = "1",
+    [STR_MANUFACTURER]  = "Identiv",
+    [STR_PRODUCT]       = "USB CCID",
+    [STR_SERIALNUMBER]  = "L9Z3ZM8CDP",
     [STR_INTERFACE]     = "CCID Interface",
 };
 
@@ -1440,7 +1440,7 @@ static void ccid_class_initfn(ObjectClass *klass, const void *data)
     HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(klass);
 
     uc->realize        = ccid_realize;
-    uc->product_desc   = "QEMU USB CCID";
+    uc->product_desc   = "USB CCID";
     uc->usb_desc       = &desc_ccid;
     uc->handle_reset   = ccid_handle_reset;
     uc->handle_control = ccid_handle_control;
diff --git a/hw/usb/dev-storage.c b/hw/usb/dev-storage.c
index b13fe34..7680bee 100644
--- a/hw/usb/dev-storage.c
+++ b/hw/usb/dev-storage.c
@@ -47,9 +47,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
-    [STR_PRODUCT]      = "QEMU USB HARDDRIVE",
-    [STR_SERIALNUMBER] = "1",
+    [STR_MANUFACTURER] = "Samsung",
+    [STR_PRODUCT]      = "USB HARDDRIVE",
+    [STR_SERIALNUMBER] = "HLN8ILM0SH",
     [STR_CONFIG_FULL]  = "Full speed config (usb 1.1)",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
     [STR_CONFIG_SUPER] = "Super speed config (usb 3.0)",
@@ -590,7 +590,7 @@ static void usb_msd_class_initfn_common(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB MSD";
+    uc->product_desc   = "USB MSD";
     uc->usb_desc       = &desc;
     uc->cancel_packet  = usb_msd_cancel_io;
     uc->handle_attach  = usb_desc_attach;
diff --git a/hw/usb/dev-uas.c b/hw/usb/dev-uas.c
index 21cc283..d14a078 100644
--- a/hw/usb/dev-uas.c
+++ b/hw/usb/dev-uas.c
@@ -171,9 +171,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
+    [STR_MANUFACTURER] = "Microsoft",
     [STR_PRODUCT]      = "USB Attached SCSI HBA",
-    [STR_SERIALNUMBER] = "27842",
+    [STR_SERIALNUMBER] = "E5DEMH2Y7X",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
     [STR_CONFIG_SUPER] = "Super speed config (usb 3.0)",
 };
diff --git a/hw/usb/dev-wacom.c b/hw/usb/dev-wacom.c
index f4b71a2..ff724dd 100644
--- a/hw/usb/dev-wacom.c
+++ b/hw/usb/dev-wacom.c
@@ -64,9 +64,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
+    [STR_MANUFACTURER]     = "Wacom",
     [STR_PRODUCT]          = "Wacom PenPartner",
-    [STR_SERIALNUMBER]     = "1",
+    [STR_SERIALNUMBER]     = "718H83W0T4",
 };
 
 static const uint8_t qemu_wacom_hid_report_descriptor[] = {
@@ -231,7 +231,7 @@ static int usb_mouse_poll(USBWacomState *s, uint8_t *buf, int len)
 
     if (!s->mouse_grabbed) {
         s->eh_entry = qemu_add_mouse_event_handler(usb_mouse_event, s, 0,
-                        "QEMU PenPartner tablet");
+                        "PenPartner tablet");
         qemu_activate_mouse_event_handler(s->eh_entry);
         s->mouse_grabbed = 1;
     }
@@ -269,7 +269,7 @@ static int usb_wacom_poll(USBWacomState *s, uint8_t *buf, int len)
 
     if (!s->mouse_grabbed) {
         s->eh_entry = qemu_add_mouse_event_handler(usb_wacom_event, s, 1,
-                        "QEMU PenPartner tablet");
+                        "PenPartner tablet");
         qemu_activate_mouse_event_handler(s->eh_entry);
         s->mouse_grabbed = 1;
     }
@@ -425,7 +425,7 @@ static void usb_wacom_class_init(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU PenPartner Tablet";
+    uc->product_desc   = "PenPartner Tablet";
     uc->usb_desc       = &desc_wacom;
     uc->realize        = usb_wacom_realize;
     uc->handle_reset   = usb_wacom_handle_reset;
@@ -433,7 +433,7 @@ static void usb_wacom_class_init(ObjectClass *klass, const void *data)
     uc->handle_data    = usb_wacom_handle_data;
     uc->unrealize      = usb_wacom_unrealize;
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
-    dc->desc = "QEMU PenPartner Tablet";
+    dc->desc = "PenPartner Tablet";
     dc->vmsd = &vmstate_usb_wacom;
 }
 
diff --git a/hw/usb/u2f-emulated.c b/hw/usb/u2f-emulated.c
index ace5ece..8cb276a 100644
--- a/hw/usb/u2f-emulated.c
+++ b/hw/usb/u2f-emulated.c
@@ -385,7 +385,7 @@ static void u2f_emulated_class_init(ObjectClass *klass, const void *data)
     kc->realize = u2f_emulated_realize;
     kc->unrealize = u2f_emulated_unrealize;
     kc->recv_from_guest = u2f_emulated_recv_from_guest;
-    dc->desc = "QEMU U2F emulated key";
+    dc->desc = "U2F emulated key";
     device_class_set_props(dc, u2f_emulated_properties);
 }
 
diff --git a/hw/usb/u2f-passthru.c b/hw/usb/u2f-passthru.c
index fa8d9cd..cd4d451 100644
--- a/hw/usb/u2f-passthru.c
+++ b/hw/usb/u2f-passthru.c
@@ -528,7 +528,7 @@ static void u2f_passthru_class_init(ObjectClass *klass, const void *data)
     kc->realize = u2f_passthru_realize;
     kc->unrealize = u2f_passthru_unrealize;
     kc->recv_from_guest = u2f_passthru_recv_from_guest;
-    dc->desc = "QEMU U2F passthrough key";
+    dc->desc = "U2F passthrough key";
     dc->vmsd = &u2f_passthru_vmstate;
     device_class_set_props(dc, u2f_passthru_properties);
     set_bit(DEVICE_CATEGORY_MISC, dc->categories);
diff --git a/hw/usb/u2f.c b/hw/usb/u2f.c
index b051a99..a6c48cd 100644
--- a/hw/usb/u2f.c
+++ b/hw/usb/u2f.c
@@ -46,9 +46,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
+    [STR_MANUFACTURER]     = "Microsoft",
     [STR_PRODUCT]          = "U2F USB key",
-    [STR_SERIALNUMBER]     = "0",
+    [STR_SERIALNUMBER]     = "JFX4J5OICR",
     [STR_CONFIG]           = "U2F key config",
     [STR_INTERFACE]        = "U2F key interface"
 };
@@ -322,7 +322,7 @@ static void u2f_key_class_init(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU U2F USB key";
+    uc->product_desc   = "U2F USB key";
     uc->usb_desc       = &desc_u2f_key;
     uc->handle_reset   = u2f_key_handle_reset;
     uc->handle_control = u2f_key_handle_control;
@@ -330,7 +330,7 @@ static void u2f_key_class_init(ObjectClass *klass, const void *data)
     uc->handle_attach  = usb_desc_attach;
     uc->realize        = u2f_key_realize;
     uc->unrealize      = u2f_key_unrealize;
-    dc->desc           = "QEMU U2F key";
+    dc->desc           = "U2F key";
     dc->vmsd           = &vmstate_u2f_key;
 }
 
diff --git a/hw/vfio/ap.c b/hw/vfio/ap.c
index 7719f24..d0306c5 100644
--- a/hw/vfio/ap.c
+++ b/hw/vfio/ap.c
@@ -341,7 +341,7 @@ static void vfio_ap_class_init(ObjectClass *klass, const void *data)
     set_bit(DEVICE_CATEGORY_MISC, dc->categories);
     dc->realize = vfio_ap_realize;
     dc->unrealize = vfio_ap_unrealize;
-    dc->hotpluggable = true;
+    dc->hotpluggable = false;
     device_class_set_legacy_reset(dc, vfio_ap_reset);
     dc->bus_type = TYPE_AP_BUS;
 
diff --git a/include/hw/acpi/aml-build.h b/include/hw/acpi/aml-build.h
index c18f681..e3656c1 100644
--- a/include/hw/acpi/aml-build.h
+++ b/include/hw/acpi/aml-build.h
@@ -4,8 +4,8 @@
 #include "hw/acpi/acpi-defs.h"
 #include "hw/acpi/bios-linker-loader.h"
 
-#define ACPI_BUILD_APPNAME6 "BOCHS "
-#define ACPI_BUILD_APPNAME8 "BXPC    "
+#define ACPI_BUILD_APPNAME6 "ALASKA"
+#define ACPI_BUILD_APPNAME8 "A M I   "
 
 #define ACPI_BUILD_TABLE_FILE "etc/acpi/tables"
 #define ACPI_BUILD_RSDP_FILE "etc/acpi/rsdp"
diff --git a/include/hw/pci/pci.h b/include/hw/pci/pci.h
index 6b7d3ac..599c70e 100644
--- a/include/hw/pci/pci.h
+++ b/include/hw/pci/pci.h
@@ -57,7 +57,7 @@ extern bool pci_available;
 #define PCI_DEVICE_ID_MARVELL_GT6412X    0x4620
 
 /* QEMU/Bochs VGA (0x1234) */
-#define PCI_VENDOR_ID_QEMU               0x1234
+#define PCI_VENDOR_ID_QEMU               0x1022 // "???" | AMD Vendor ID Replacement from 0x1234
 #define PCI_DEVICE_ID_QEMU_VGA           0x1111
 #define PCI_DEVICE_ID_QEMU_IPMI          0x1112
 
@@ -74,12 +74,12 @@ extern bool pci_available;
 /* Intel (0x8086) */
 #define PCI_DEVICE_ID_INTEL_82551IT      0x1209
 #define PCI_DEVICE_ID_INTEL_82557        0x1229
-#define PCI_DEVICE_ID_INTEL_82801IR      0x2922
+#define PCI_DEVICE_ID_INTEL_82801IR      0x790e // Intel 82801IR ICH9 - LPC Bridge [A2] | AMD Device ID Replacement from 0x2922 | hw/ide/ich.c
 
 /* Red Hat / Qumranet (for QEMU) -- see pci-ids.txt */
-#define PCI_VENDOR_ID_REDHAT_QUMRANET    0x1af4
-#define PCI_SUBVENDOR_ID_REDHAT_QUMRANET 0x1af4
-#define PCI_SUBDEVICE_ID_QEMU            0x1100
+#define PCI_VENDOR_ID_REDHAT_QUMRANET    0x1022 // AMD Vendor ID Replacement from 0x1af4
+#define PCI_SUBVENDOR_ID_REDHAT_QUMRANET 0x1022 // AMD Subvendor ID Replacement from 0x1af4
+#define PCI_SUBDEVICE_ID_QEMU            0x1022 // AMD Subdevice ID Replacement from 0x1100
 
 /* legacy virtio-pci devices */
 #define PCI_DEVICE_ID_VIRTIO_NET         0x1000
@@ -100,21 +100,21 @@ extern bool pci_available;
  */
 #define PCI_DEVICE_ID_VIRTIO_10_BASE     0x1040
 
-#define PCI_VENDOR_ID_REDHAT             0x1b36
-#define PCI_DEVICE_ID_REDHAT_BRIDGE      0x0001
-#define PCI_DEVICE_ID_REDHAT_SERIAL      0x0002
+#define PCI_VENDOR_ID_REDHAT             0x1022 // "Red Hat, Inc." | AMD Vendor ID Replacement from 0x1b36
+#define PCI_DEVICE_ID_REDHAT_BRIDGE      0x1480 // "QEMU PCI-PCI bridge" | AMD Device ID Replacement from 0x0001 | hw/pci-bridge/pci_bridge_dev.c
+#define PCI_DEVICE_ID_REDHAT_SERIAL      0x0002 // TODO: find device_id | AMD Device ID Replacement from 0x???? | hw/char/serial-pci.c
 #define PCI_DEVICE_ID_REDHAT_SERIAL2     0x0003
 #define PCI_DEVICE_ID_REDHAT_SERIAL4     0x0004
 #define PCI_DEVICE_ID_REDHAT_TEST        0x0005
 #define PCI_DEVICE_ID_REDHAT_ROCKER      0x0006
 #define PCI_DEVICE_ID_REDHAT_SDHCI       0x0007
-#define PCI_DEVICE_ID_REDHAT_PCIE_HOST   0x0008
+#define PCI_DEVICE_ID_REDHAT_PCIE_HOST   0x1482 // "QEMU PCIe Host bridge" | AMD Device ID Replacement from 0x0008 | hw/pci-host/gpex.c
 #define PCI_DEVICE_ID_REDHAT_PXB         0x0009
 #define PCI_DEVICE_ID_REDHAT_BRIDGE_SEAT 0x000a
 #define PCI_DEVICE_ID_REDHAT_PXB_PCIE    0x000b
-#define PCI_DEVICE_ID_REDHAT_PCIE_RP     0x000c
-#define PCI_DEVICE_ID_REDHAT_XHCI        0x000d
-#define PCI_DEVICE_ID_REDHAT_PCIE_BRIDGE 0x000e
+#define PCI_DEVICE_ID_REDHAT_PCIE_RP     0x1483 // "QEMU PCIe Root Port" | AMD Device ID Replacement from 0x000c | hw/pci-bridge/gen_pcie_root_port.c
+#define PCI_DEVICE_ID_REDHAT_XHCI        0x43d5 // "QEMU XHCI Host Controller" | AMD Device ID Replacement from 0x000d | hw/usb/hcd-xhci-pci.c
+#define PCI_DEVICE_ID_REDHAT_PCIE_BRIDGE 0x1483 // "Red Hat, Device ID: 000E" | AMD Device ID Replacement from 0x000e | hw/pci-bridge/pcie_pci_bridge.c
 #define PCI_DEVICE_ID_REDHAT_MDPY        0x000f
 #define PCI_DEVICE_ID_REDHAT_NVME        0x0010
 #define PCI_DEVICE_ID_REDHAT_PVPANIC     0x0011
diff --git a/include/hw/pci/pci_ids.h b/include/hw/pci/pci_ids.h
index 33e2898..0a4e198 100644
--- a/include/hw/pci/pci_ids.h
+++ b/include/hw/pci/pci_ids.h
@@ -237,6 +237,8 @@
 #define PCI_VENDOR_ID_BAIDU              0x1d22
 #define PCI_DEVICE_ID_KUNLUN_VF          0x3685
 
+/* https://www.pcilookup.com/ */
+
 #define PCI_VENDOR_ID_INTEL              0x8086
 #define PCI_DEVICE_ID_INTEL_82378        0x0484
 #define PCI_DEVICE_ID_INTEL_82441        0x1237
@@ -246,8 +248,8 @@
 #define PCI_DEVICE_ID_INTEL_ESB_9        0x25ab
 #define PCI_DEVICE_ID_INTEL_NVME         0x5845
 #define PCI_DEVICE_ID_INTEL_82371SB_0    0x7000
-#define PCI_DEVICE_ID_INTEL_82371SB_1    0x7010
-#define PCI_DEVICE_ID_INTEL_82371SB_2    0x7020
+#define PCI_DEVICE_ID_INTEL_82371SB_1    0x7010 // TODO: | Intel 82371SB_1 - ??? | AMD Vendor ID Replacement from 0x???? | hw/ide/piix.c
+#define PCI_DEVICE_ID_INTEL_82371SB_2    0x7020 // TODO: | Intel 82371SB_2 - ??? | AMD Vendor ID Replacement from 0x???? | hw/usb/hcd-uhci.c
 #define PCI_DEVICE_ID_INTEL_82371AB_0    0x7110
 #define PCI_DEVICE_ID_INTEL_82371AB      0x7111
 #define PCI_DEVICE_ID_INTEL_82371AB_2    0x7112
@@ -259,9 +261,9 @@
 #define PCI_DEVICE_ID_INTEL_ICH9_3       0x2913
 #define PCI_DEVICE_ID_INTEL_ICH9_4       0x2914
 #define PCI_DEVICE_ID_INTEL_ICH9_5       0x2919
-#define PCI_DEVICE_ID_INTEL_ICH9_6       0x2930
+#define PCI_DEVICE_ID_INTEL_ICH9_6       0x790b // Intel 82801IB ICH9 - SMBus Controller [A2] | AMD Vendor ID Replacement from 0x2930 | hw/i2c/smbus_ich9.c
 #define PCI_DEVICE_ID_INTEL_ICH9_7       0x2916
-#define PCI_DEVICE_ID_INTEL_ICH9_8       0x2918
+#define PCI_DEVICE_ID_INTEL_ICH9_8       0x790e // Intel 82801IR ICH9 - LPC Bridge [A2] | AMD Vendor ID Replacement from 0x2918 | hw/isa/lpc_ich9.c
 
 #define PCI_DEVICE_ID_INTEL_82801I_UHCI1 0x2934
 #define PCI_DEVICE_ID_INTEL_82801I_UHCI2 0x2935
@@ -273,7 +275,7 @@
 #define PCI_DEVICE_ID_INTEL_82801I_EHCI2 0x293c
 #define PCI_DEVICE_ID_INTEL_82599_SFP_VF 0x10ed
 
-#define PCI_DEVICE_ID_INTEL_P35_MCH      0x29c0
+#define PCI_DEVICE_ID_INTEL_P35_MCH      0x1480 // Intel G33/P35/Q35/Q33 Chipset - Memory Controller Hub [A0] | AMD Vendor ID Replacement from 0x29c0 | hw/pci-host/q35.c
 
 #define PCI_VENDOR_ID_XEN                0x5853
 #define PCI_DEVICE_ID_XEN_PLATFORM       0x0001
diff --git a/include/standard-headers/linux/qemu_fw_cfg.h b/include/standard-headers/linux/qemu_fw_cfg.h
index cb93f66..fe34590 100644
--- a/include/standard-headers/linux/qemu_fw_cfg.h
+++ b/include/standard-headers/linux/qemu_fw_cfg.h
@@ -4,7 +4,7 @@
 
 #include "standard-headers/linux/types.h"
 
-#define FW_CFG_ACPI_DEVICE_ID	"QEMU0002"
+#define FW_CFG_ACPI_DEVICE_ID	"UEFI0002"
 
 /* selector key values for "well-known" fw_cfg entries */
 #define FW_CFG_SIGNATURE	0x00
@@ -71,7 +71,7 @@ struct fw_cfg_file {
 #define FW_CFG_DMA_CTL_SELECT	0x08
 #define FW_CFG_DMA_CTL_WRITE	0x10
 
-#define FW_CFG_DMA_SIGNATURE    0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE    0x51434f4d20434647ULL /* "QCOM CFG" */
 
 /* Control as first field allows for different structures selected by this
  * field, which might be useful in the future
diff --git a/migration/rdma.c b/migration/rdma.c
index 2d839fc..960871d 100644
--- a/migration/rdma.c
+++ b/migration/rdma.c
@@ -220,7 +220,7 @@ static const char *control_desc(unsigned int rdma_control)
         [RDMA_CONTROL_NONE] = "NONE",
         [RDMA_CONTROL_ERROR] = "ERROR",
         [RDMA_CONTROL_READY] = "READY",
-        [RDMA_CONTROL_QEMU_FILE] = "QEMU FILE",
+        [RDMA_CONTROL_QEMU_FILE] = "FILE",
         [RDMA_CONTROL_RAM_BLOCKS_REQUEST] = "RAM BLOCKS REQUEST",
         [RDMA_CONTROL_RAM_BLOCKS_RESULT] = "RAM BLOCKS RESULT",
         [RDMA_CONTROL_COMPRESS] = "COMPRESS",
diff --git a/pc-bios/optionrom/optionrom.h b/pc-bios/optionrom/optionrom.h
index 7bcdf0e..02dd06e 100644
--- a/pc-bios/optionrom/optionrom.h
+++ b/pc-bios/optionrom/optionrom.h
@@ -43,7 +43,7 @@
 #define FW_CFG_DMA_CTL_SELECT  0x08
 #define FW_CFG_DMA_CTL_WRITE   0x10
 
-#define FW_CFG_DMA_SIGNATURE 0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE 0x51434f4d20434647ULL /* "QCOM CFG" */
 
 #define BIOS_CFG_DMA_ADDR_HIGH  0x514
 #define BIOS_CFG_DMA_ADDR_LOW   0x518
diff --git a/pc-bios/s390-ccw/virtio-scsi.h b/pc-bios/s390-ccw/virtio-scsi.h
index c5612e1..048cb93 100644
--- a/pc-bios/s390-ccw/virtio-scsi.h
+++ b/pc-bios/s390-ccw/virtio-scsi.h
@@ -25,7 +25,7 @@
 #define VIRTIO_SCSI_S_OK                     0x00
 #define VIRTIO_SCSI_S_BAD_TARGET             0x03
 
-#define QEMU_CDROM_SIGNATURE "QEMU CD-ROM     "
+#define QEMU_CDROM_SIGNATURE "ASUS CD-ROM     "
 
 enum virtio_scsi_vq_id {
     VR_CONTROL  = 0,
diff --git a/qapi/ui.json b/qapi/ui.json
index 1b2f4a4..37f40fd 100644
--- a/qapi/ui.json
+++ b/qapi/ui.json
@@ -831,13 +831,13 @@
 #     -> { "execute": "query-mice" }
 #     <- { "return": [
 #              {
-#                 "name":"QEMU Microsoft Mouse",
+#                 "name":"Microsoft Mouse",
 #                 "index":0,
 #                 "current":false,
 #                 "absolute":false
 #              },
 #              {
-#                 "name":"QEMU PS/2 Mouse",
+#                 "name":"PS/2 Mouse",
 #                 "index":1,
 #                 "current":true,
 #                 "absolute":true
diff --git a/target/i386/cpu.c b/target/i386/cpu.c
index 6d85149..b4a8d3e 100644
--- a/target/i386/cpu.c
+++ b/target/i386/cpu.c
@@ -3309,7 +3309,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
         .features[FEAT_8000_0001_ECX] =
             CPUID_EXT3_LAHF_LM | CPUID_EXT3_SVM,
         .xlevel = 0x8000000A,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "AMD CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "phenom",
@@ -3438,7 +3438,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
         .features[FEAT_1_ECX] =
             CPUID_EXT_SSE3,
         .xlevel = 0x80000004,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "AMD CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "kvm32",
@@ -3468,7 +3468,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
              VMX_CPU_BASED_USE_IO_BITMAPS | VMX_CPU_BASED_MONITOR_EXITING |
              VMX_CPU_BASED_PAUSE_EXITING | VMX_CPU_BASED_USE_MSR_BITMAPS,
         .xlevel = 0x80000008,
-        .model_id = "Common 32-bit KVM processor"
+        .model_id = "Common 32-bit AMD processor"
     },
     {
         .name = "coreduo",
@@ -3568,7 +3568,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
         .features[FEAT_8000_0001_EDX] =
             CPUID_EXT2_MMXEXT | CPUID_EXT2_3DNOW | CPUID_EXT2_3DNOWEXT,
         .xlevel = 0x80000008,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "AMD CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "n270",
@@ -6745,7 +6745,7 @@ static void max_x86_cpu_initfn(Object *obj)
     }
     if (!env->cpuid_model[0]) {
         object_property_set_str(OBJECT(cpu), "model-id",
-                                "QEMU TCG CPU version " QEMU_HW_VERSION,
+                                "TCG CPU version " QEMU_HW_VERSION,
                                 &error_abort);
     }
 }
@@ -9146,7 +9146,7 @@ static void x86_cpu_hyperv_realize(X86CPU *cpu)
 
     /* Hyper-V vendor id */
     if (!cpu->hyperv_vendor) {
-        object_property_set_str(OBJECT(cpu), "hv-vendor-id", "Microsoft Hv",
+        object_property_set_str(OBJECT(cpu), "hv-vendor-id", "",
                                 &error_abort);
     }
     len = strlen(cpu->hyperv_vendor);
diff --git a/target/i386/kvm/kvm.c b/target/i386/kvm/kvm.c
index 369626f..31b68dd 100644
--- a/target/i386/kvm/kvm.c
+++ b/target/i386/kvm/kvm.c
@@ -1634,7 +1634,7 @@ static int hyperv_fill_cpuids(CPUState *cs,
         c->function = HV_CPUID_SYNDBG_VENDOR_AND_MAX_FUNCTIONS;
         c->eax = hyperv_feat_enabled(cpu, HYPERV_FEAT_EVMCS) ?
             HV_CPUID_NESTED_FEATURES : HV_CPUID_IMPLEMENT_LIMITS;
-        memcpy(signature, "Microsoft VS", 12);
+        memset(signature, 0, 12);
         c->eax = 0;
         c->ebx = signature[0];
         c->ecx = signature[1];
@@ -1642,7 +1642,7 @@ static int hyperv_fill_cpuids(CPUState *cs,
 
         c = &cpuid_ent[cpuid_i++];
         c->function = HV_CPUID_SYNDBG_INTERFACE;
-        memcpy(signature, "VS#1\0\0\0\0\0\0\0\0", 12);
+        memset(signature, 0, 12);
         c->eax = signature[0];
         c->ebx = 0;
         c->ecx = 0;
@@ -2160,7 +2160,7 @@ int kvm_arch_init_vcpu(CPUState *cs)
 #ifdef CONFIG_XEN_EMU
         struct kvm_cpuid_entry2 *xen_max_leaf;
 
-        memcpy(signature, "XenVMMXenVMM", 12);
+        memset(signature, 0, 12);
 
         xen_max_leaf = c = &cpuid_data.entries[cpuid_i++];
         c->function = kvm_base + XEN_CPUID_SIGNATURE;
@@ -2236,7 +2236,7 @@ int kvm_arch_init_vcpu(CPUState *cs)
         abort();
 #endif
     } else if (cpu->expose_kvm) {
-        memcpy(signature, "KVMKVMKVM\0\0\0", 12);
+        memset(signature, 0, 12);
         c = &cpuid_data.entries[cpuid_i++];
         c->function = KVM_CPUID_SIGNATURE | kvm_base;
         c->eax = KVM_CPUID_FEATURES | kvm_base;
diff --git a/target/s390x/cpu_models.c b/target/s390x/cpu_models.c
index 954a7a9..3f1fe01 100644
--- a/target/s390x/cpu_models.c
+++ b/target/s390x/cpu_models.c
@@ -954,7 +954,7 @@ static void s390_qemu_cpu_model_class_init(ObjectClass *oc, const void *data)
     S390CPUClass *xcc = S390_CPU_CLASS(oc);
 
     xcc->is_migration_safe = true;
-    xcc->desc = g_strdup_printf("QEMU Virtual CPU version %s",
+    xcc->desc = g_strdup_printf("CPU version %s",
                                 qemu_hw_version());
 }
 
diff --git a/target/s390x/tcg/misc_helper.c b/target/s390x/tcg/misc_helper.c
index f7101be..ab4148c 100644
--- a/target/s390x/tcg/misc_helper.c
+++ b/target/s390x/tcg/misc_helper.c
@@ -331,18 +331,18 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
             /* Basic Machine Configuration */
             char type[5] = {};
 
-            ebcdic_put(sysib.sysib_111.manuf, "QEMU            ", 16);
+            ebcdic_put(sysib.sysib_111.manuf, "AMD             ", 16);
             /* same as machine type number in STORE CPU ID, but in EBCDIC */
             snprintf(type, ARRAY_SIZE(type), "%X", cpu->model->def->type);
             ebcdic_put(sysib.sysib_111.type, type, 4);
             /* model number (not stored in STORE CPU ID for z/Architecture) */
-            ebcdic_put(sysib.sysib_111.model, "QEMU            ", 16);
-            ebcdic_put(sysib.sysib_111.sequence, "QEMU            ", 16);
-            ebcdic_put(sysib.sysib_111.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_111.model, "AMD             ", 16);
+            ebcdic_put(sysib.sysib_111.sequence, "AMD             ", 16);
+            ebcdic_put(sysib.sysib_111.plant, "AMD ", 4);
         } else if ((sel1 == 2) && (sel2 == 1)) {
             /* Basic Machine CPU */
-            ebcdic_put(sysib.sysib_121.sequence, "QEMUQEMUQEMUQEMU", 16);
-            ebcdic_put(sysib.sysib_121.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_121.sequence, "AMDAMDAMDAMDAMDA", 16);
+            ebcdic_put(sysib.sysib_121.plant, "AMD ", 4);
             sysib.sysib_121.cpu_addr = cpu_to_be16(env->core_id);
         } else if ((sel1 == 2) && (sel2 == 2)) {
             /* Basic Machine CPUs */
@@ -357,8 +357,8 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
     case STSI_R0_FC_LEVEL_2:
         if ((sel1 == 2) && (sel2 == 1)) {
             /* LPAR CPU */
-            ebcdic_put(sysib.sysib_221.sequence, "QEMUQEMUQEMUQEMU", 16);
-            ebcdic_put(sysib.sysib_221.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_221.sequence, "AMDAMDAMDAMDAMDA", 16);
+            ebcdic_put(sysib.sysib_221.plant, "AMD ", 4);
             sysib.sysib_221.cpu_addr = cpu_to_be16(env->core_id);
         } else if ((sel1 == 2) && (sel2 == 2)) {
             /* LPAR CPUs */
@@ -366,7 +366,7 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
             sysib.sysib_222.total_cpus = cpu_to_be16(total_cpus);
             sysib.sysib_222.conf_cpus = cpu_to_be16(conf_cpus);
             sysib.sysib_222.reserved_cpus = cpu_to_be16(reserved_cpus);
-            ebcdic_put(sysib.sysib_222.name, "QEMU    ", 8);
+            ebcdic_put(sysib.sysib_222.name, "AMD     ", 8);
             sysib.sysib_222.caf = cpu_to_be32(1000);
             sysib.sysib_222.dedicated_cpus = cpu_to_be16(conf_cpus);
         } else {
@@ -382,7 +382,7 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
             sysib.sysib_322.vm[0].reserved_cpus = cpu_to_be16(reserved_cpus);
             sysib.sysib_322.vm[0].caf = cpu_to_be32(1000);
             /* Linux kernel uses this to distinguish us from z/VM */
-            ebcdic_put(sysib.sysib_322.vm[0].cpi, "KVM/Linux       ", 16);
+            ebcdic_put(sysib.sysib_322.vm[0].cpi, "AMD             ", 16);
             sysib.sysib_322.vm[0].ext_name_encoding = 2; /* UTF-8 */
 
             /* If our VM has a name, use the real name */

```

`patches/QEMU/Archive/amd-qemu-10.1.1.patch`:

```patch
diff --git a/block/vhdx.c b/block/vhdx.c
index b2a4b813a0..dffe9f8cd8 100644
--- a/block/vhdx.c
+++ b/block/vhdx.c
@@ -2020,7 +2020,7 @@ vhdx_co_create(BlockdevCreateOptions *opts, Error **errp)
 
     /* The creator field is optional, but may be useful for
      * debugging / diagnostics */
-    creator = g_utf8_to_utf16("QEMU v" QEMU_VERSION, -1, NULL,
+    creator = g_utf8_to_utf16("Microsoft v" QEMU_VERSION, -1, NULL,
                               &creator_items, NULL);
     signature = cpu_to_le64(VHDX_FILE_SIGNATURE);
     ret = blk_co_pwrite(blk, VHDX_FILE_ID_OFFSET, sizeof(signature), &signature,
diff --git a/block/vvfat.c b/block/vvfat.c
index 814796d918..a5843836bb 100644
--- a/block/vvfat.c
+++ b/block/vvfat.c
@@ -1176,7 +1176,7 @@ static int vvfat_open(BlockDriverState *bs, QDict *options, int flags,
         }
         memcpy(s->volume_label, label, label_length);
     } else {
-        memcpy(s->volume_label, "QEMU VVFAT", 10);
+        memcpy(s->volume_label, "ASUS VVFAT", 10);
     }
 
     if (floppy) {
diff --git a/chardev/msmouse.c b/chardev/msmouse.c
index 1a55755d39..49b979be96 100644
--- a/chardev/msmouse.c
+++ b/chardev/msmouse.c
@@ -172,7 +172,7 @@ static int msmouse_chr_write(struct Chardev *s, const uint8_t *buf, int len)
 }
 
 static const QemuInputHandler msmouse_handler = {
-    .name  = "QEMU Microsoft Mouse",
+    .name  = "Microsoft Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = msmouse_input_event,
     .sync  = msmouse_input_sync,
diff --git a/chardev/wctablet.c b/chardev/wctablet.c
index 0dc6ef08f5..de3d126ad2 100644
--- a/chardev/wctablet.c
+++ b/chardev/wctablet.c
@@ -179,7 +179,7 @@ static void wctablet_input_sync(DeviceState *dev)
 }
 
 static const QemuInputHandler wctablet_handler = {
-    .name  = "QEMU Wacom Pen Tablet",
+    .name  = "Wacom Pen Tablet",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_ABS,
     .event = wctablet_input_event,
     .sync  = wctablet_input_sync,
diff --git a/contrib/vhost-user-gpu/vhost-user-gpu.c b/contrib/vhost-user-gpu/vhost-user-gpu.c
index bb41758e34..dbd27773c2 100644
--- a/contrib/vhost-user-gpu/vhost-user-gpu.c
+++ b/contrib/vhost-user-gpu/vhost-user-gpu.c
@@ -1254,7 +1254,7 @@ main(int argc, char *argv[])
     QTAILQ_INIT(&g.reslist);
     QTAILQ_INIT(&g.fenceq);
 
-    context = g_option_context_new("QEMU vhost-user-gpu");
+    context = g_option_context_new("vhost-user-gpu");
     g_option_context_add_main_entries(context, entries, NULL);
     if (!g_option_context_parse(context, &argc, &argv, &error)) {
         g_printerr("Option parsing failed: %s\n", error->message);
diff --git a/hw/acpi/aml-build.c b/hw/acpi/aml-build.c
index 1e685f982f..a4099be824 100644
--- a/hw/acpi/aml-build.c
+++ b/hw/acpi/aml-build.c
@@ -1722,11 +1722,11 @@ void acpi_table_begin(AcpiTable *desc, GArray *array)
     build_append_int_noprefix(array, 0, 4); /* Length */
     build_append_int_noprefix(array, desc->rev, 1); /* Revision */
     build_append_int_noprefix(array, 0, 1); /* Checksum */
-    build_append_padded_str(array, desc->oem_id, 6, '\0'); /* OEMID */
+    build_append_padded_str(array, ACPI_BUILD_APPNAME6, 6, '\0'); /* OEMID */
     /* OEM Table ID */
-    build_append_padded_str(array, desc->oem_table_id, 8, '\0');
+    build_append_padded_str(array, ACPI_BUILD_APPNAME8, 8, '\0');
     build_append_int_noprefix(array, 1, 4); /* OEM Revision */
-    g_array_append_vals(array, ACPI_BUILD_APPNAME8, 4); /* Creator ID */
+    g_array_append_vals(array, "ACPI", 4); /* Creator ID */
     build_append_int_noprefix(array, 1, 4); /* Creator Revision */
 }
 
@@ -2263,7 +2263,7 @@ void build_fadt(GArray *tbl, BIOSLinker *linker, const AcpiFadtData *f,
     /* ACPI1.0: INT_MODEL, ACPI2.0+: Reserved */
     build_append_int_noprefix(tbl, f->int_model /* Multiple APIC */, 1);
     /* Preferred_PM_Profile */
-    build_append_int_noprefix(tbl, 0 /* Unspecified */, 1);
+    build_append_int_noprefix(tbl, 1 /* Desktop */, 1);
     build_append_int_noprefix(tbl, f->sci_int, 2); /* SCI_INT */
     build_append_int_noprefix(tbl, f->smi_cmd, 4); /* SMI_CMD */
     build_append_int_noprefix(tbl, f->acpi_enable_cmd, 1); /* ACPI_ENABLE */
@@ -2360,7 +2360,7 @@ void build_fadt(GArray *tbl, BIOSLinker *linker, const AcpiFadtData *f,
     }
 
     /* Hypervisor Vendor Identity */
-    build_append_padded_str(tbl, "QEMU", 8, '\0');
+    build_append_padded_str(tbl, "", 8, '\0');
 
     /* TODO: extra fields need to be added to support revisions above rev6 */
     assert(f->rev == 6);
diff --git a/hw/acpi/pcihp.c b/hw/acpi/pcihp.c
index 4922bbc778..54cd714363 100644
--- a/hw/acpi/pcihp.c
+++ b/hw/acpi/pcihp.c
@@ -701,6 +701,83 @@ void build_append_pcihp_resources(Aml *scope /* \\_SB.PCI0 */,
     aml_append(scope, dev);
 }
 
+/* 
+ * Helper to generate "Real Hardware" looking ACPI names.
+ * This removes the "S<hex>" signature and ensures unique naming
+ * for multifunction devices.
+ */
+static void get_mimic_pci_name(char *name, int devfn) {
+    int slot = PCI_SLOT(devfn);
+    int func = PCI_FUNC(devfn);
+
+    switch (slot) {
+        case 0:
+            // Host Bridge is almost always Slot 0, Function 0 (and also bus 0 but we cant access bus number in this context)
+            if (func == 0) sprintf(name, "MCHC"); 
+            else sprintf(name, "H%X", func);
+            break;
+            
+        case 2:
+            // Slot 2: Graphics + associated HDMI Audio
+            if (func == 0) sprintf(name, "GFX0");      // Primary GPU
+            else if (func == 1) sprintf(name, "HDAU"); // HDMI Audio
+            else sprintf(name, "GFX%X", func);         // Fallback uniqueness
+            break;
+            
+        case 3:
+            // Slot 3: Network
+            if (func == 0) sprintf(name, "GLAN");
+            else sprintf(name, "NET%X", func);
+            break;
+            
+        case 4:
+            // Slot 4: Multimedia / Audio
+            if (func == 0) sprintf(name, "HDEF");
+            else sprintf(name, "MM%02X", func);
+            break;
+
+        case 5:
+            // Slot 5: USB XHCI (QEMU default often)
+            if (func == 0) sprintf(name, "XHC1");
+            else sprintf(name, "XHC%X", func);
+            break;
+
+        case 6:
+            // Slot 6: SATA (AHCI)
+            if (func == 0) sprintf(name, "SAT0");
+            else sprintf(name, "SAT%X", func);
+            break;
+
+        case 29:
+            // Slot 29 (0x1D): USB EHCI (Intel Standard)
+            if (func == 0) sprintf(name, "EHC1");
+            else sprintf(name, "EHC%X", func);
+            break;
+
+        case 31:
+            // Slot 31 (0x1F): LPC / SMBus / SATA 2
+            if (func == 0) sprintf(name, "LPCB");      // ISA Bridge
+            else if (func == 2) sprintf(name, "SAT1"); // 2nd SATA
+            else if (func == 3) sprintf(name, "SBUS"); // SMBus
+            else sprintf(name, "S31%X", func);         // Fallback
+            break;
+
+        default:
+            /* 
+             * For generic slots, we use "RP" (Root Port) + devfn (Hex).
+             * 
+             * Why 'devfn' and not 'slot'?
+             * - Slot 10, Func 0 (devfn 0x50) -> RP50
+             * - Slot 10, Func 1 (devfn 0x51) -> RP51
+             * 
+             * This guarantees ACPI uniqueness for multifunction devices
+             * while completely breaking the "S" + hex signature.
+             */
+            sprintf(name, "RP%02X", devfn);
+            break;
+    }
+}
+
 bool build_append_notification_callback(Aml *parent_scope, const PCIBus *bus)
 {
     Aml *method;
@@ -710,7 +786,11 @@ bool build_append_notification_callback(Aml *parent_scope, const PCIBus *bus)
     GQueue *pcnt_bus_list = g_queue_new();
 
     QLIST_FOREACH(sec, &bus->child, sibling) {
-        Aml *br_scope = aml_scope("S%.02X", sec->parent_dev->devfn);
+        char mimic_name[5];
+        get_mimic_pci_name(mimic_name, sec->parent_dev->devfn);
+        
+        Aml *br_scope = aml_scope("%s", mimic_name);
+        
         if (pci_bus_is_root(sec)) {
             continue;
         }
@@ -749,7 +829,9 @@ bool build_append_notification_callback(Aml *parent_scope, const PCIBus *bus)
 
     /* Notify about child bus events in any case */
     while ((sec = g_queue_pop_head(pcnt_bus_list))) {
-        aml_append(method, aml_name("^S%.02X.PCNT", sec->parent_dev->devfn));
+        char mimic_name[5];
+        get_mimic_pci_name(mimic_name, sec->parent_dev->devfn);
+        aml_append(method, aml_name("^%s.PCNT", mimic_name));
     }
 
     aml_append(parent_scope, method);
@@ -805,8 +887,13 @@ static void build_append_pcihp_notify_entry(Aml *method, int slot)
     Aml *if_ctx;
     int32_t devfn = PCI_DEVFN(slot, 0);
 
+    char mimic_name[5];
+    get_mimic_pci_name(mimic_name, devfn);
+
     if_ctx = aml_if(aml_and(aml_arg(0), aml_int(0x1U << slot), NULL));
-    aml_append(if_ctx, aml_notify(aml_name("S%.02X", devfn), aml_arg(1)));
+
+    aml_append(if_ctx, aml_notify(aml_name("%s", mimic_name), aml_arg(1)));
+    
     aml_append(method, if_ctx);
 }
 
@@ -869,10 +956,13 @@ void build_append_pcihp_slots(Aml *parent_scope, PCIBus *bus)
             continue;
         }
 
+        char mimic_name[5];
+        get_mimic_pci_name(mimic_name, devfn);
+
         if (bus->devices[devfn]) {
-            dev = aml_scope("S%.02X", devfn);
+            dev = aml_scope("%s", mimic_name);
         } else {
-            dev = aml_device("S%.02X", devfn);
+            dev = aml_device("%s", mimic_name);
             aml_append(dev, aml_name_decl("_ADR", aml_int(adr)));
         }
 
@@ -914,7 +1004,11 @@ void build_append_pci_bus_devices(Aml *parent_scope, PCIBus *bus)
         }
 
         /* start to compose PCI device descriptor */
-        dev = aml_device("S%.02X", devfn);
+        
+        char mimic_name[5];
+        get_mimic_pci_name(mimic_name, devfn);
+        dev = aml_device("%s", mimic_name);
+
         aml_append(dev, aml_name_decl("_ADR", aml_int(adr)));
 
         call_dev_aml_func(DEVICE(bus->devices[devfn]), dev);
diff --git a/hw/arm/sbsa-ref.c b/hw/arm/sbsa-ref.c
index 15c1ff4b14..8bc1873f0a 100644
--- a/hw/arm/sbsa-ref.c
+++ b/hw/arm/sbsa-ref.c
@@ -896,7 +896,7 @@ static void sbsa_ref_class_init(ObjectClass *oc, const void *data)
     };
 
     mc->init = sbsa_ref_init;
-    mc->desc = "QEMU 'SBSA Reference' ARM Virtual Machine";
+    mc->desc = "Qualcomm 'Reference' ARM SoC";
     mc->default_cpu_type = ARM_CPU_TYPE_NAME("neoverse-n2");
     mc->valid_cpu_types = valid_cpu_types;
     mc->max_cpus = 512;
diff --git a/hw/arm/virt.c b/hw/arm/virt.c
index ef6be3660f..09326900b2 100644
--- a/hw/arm/virt.c
+++ b/hw/arm/virt.c
@@ -116,7 +116,7 @@ static void arm_virt_compat_set(MachineClass *mc)
         MachineClass *mc = MACHINE_CLASS(oc); \
         arm_virt_compat_set(mc); \
         MACHINE_VER_SYM(options, virt, __VA_ARGS__)(mc); \
-        mc->desc = "QEMU " MACHINE_VER_STR(__VA_ARGS__) " ARM Virtual Machine"; \
+        mc->desc = "AMD  " MACHINE_VER_STR(__VA_ARGS__) " ARM Virtual Machine"; \
         MACHINE_VER_DEPRECATION(__VA_ARGS__); \
         if (latest) { \
             mc->alias = "virt"; \
@@ -1749,13 +1749,13 @@ static void virt_build_smbios(VirtMachineState *vms)
     uint8_t *smbios_tables, *smbios_anchor;
     size_t smbios_tables_len, smbios_anchor_len;
     struct smbios_phys_mem_area mem_array;
-    const char *product = "QEMU Virtual Machine";
+    const char *product = "AMD Machine";
 
     if (kvm_enabled()) {
-        product = "KVM Virtual Machine";
+        product = "AMD Machine";
     }
 
-    smbios_set_defaults("QEMU", product, mc->name);
+    smbios_set_defaults("Unknown", product, mc->name);
 
     /* build the array of physical mem area from base_memmap */
     mem_array.address = vms->memmap[VIRT_MEM].base;
diff --git a/hw/audio/hda-codec.c b/hw/audio/hda-codec.c
index 66edad280f..56fb02dd89 100644
--- a/hw/audio/hda-codec.c
+++ b/hw/audio/hda-codec.c
@@ -118,7 +118,7 @@ static void hda_codec_parse_fmt(uint32_t format, struct audsettings *as)
 
 /* some defines */
 
-#define QEMU_HDA_ID_VENDOR  0x1af4
+#define QEMU_HDA_ID_VENDOR  0x10EC
 #define QEMU_HDA_PCM_FORMATS (AC_SUPPCM_BITS_16 |       \
                               0x1fc /* 16 -> 96 kHz */)
 #define QEMU_HDA_AMP_NONE    (0)
diff --git a/hw/audio/intel-hda.c b/hw/audio/intel-hda.c
index b256c8ccea..b926a4d968 100644
--- a/hw/audio/intel-hda.c
+++ b/hw/audio/intel-hda.c
@@ -1239,7 +1239,7 @@ static void intel_hda_class_init_ich6(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->device_id = 0x2668;
+    k->device_id = 0x51c8; // "Intel 82801IB ICH6 - High Definition Audio [A3]" | Intel Device ID Replacement from 0x2668 | hw/audio/intel-hda.c
     k->revision = 1;
     set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
     dc->desc = "Intel HD Audio Controller (ich6)";
@@ -1250,8 +1250,8 @@ static void intel_hda_class_init_ich9(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->device_id = 0x293e;
-    k->revision = 3;
+    k->device_id = 0x51c8; // "Intel 82801IB ICH9 - High Definition Audio [A3]" | Intel Device ID Replacement from 0x293e | hw/audio/intel-hda.c
+    k->revision = 1;
     set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
     dc->desc = "Intel HD Audio Controller (ich9)";
 }
diff --git a/hw/char/escc.c b/hw/char/escc.c
index afe4ca483e..fa4f4a00ce 100644
--- a/hw/char/escc.c
+++ b/hw/char/escc.c
@@ -1037,7 +1037,7 @@ static void sunmouse_sync(DeviceState *dev)
 }
 
 static const QemuInputHandler sunmouse_handler = {
-    .name  = "QEMU Sun Mouse",
+    .name  = "Sun Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = sunmouse_handle_event,
     .sync  = sunmouse_sync,
diff --git a/hw/core/qdev.c b/hw/core/qdev.c
index f600226176..286843e045 100644
--- a/hw/core/qdev.c
+++ b/hw/core/qdev.c
@@ -745,7 +745,7 @@ static void device_class_init(ObjectClass *class, const void *data)
      * hotpluggable. Devices that shouldn't be hotpluggable,
      * should override it in their class_init()
      */
-    dc->hotpluggable = true;
+    dc->hotpluggable = false;
     dc->user_creatable = true;
     vc->get_id = device_vmstate_if_get_id;
     rc->get_state = device_get_reset_state;
diff --git a/hw/display/edid-generate.c b/hw/display/edid-generate.c
index 2cb819675e..630a33b703 100644
--- a/hw/display/edid-generate.c
+++ b/hw/display/edid-generate.c
@@ -388,22 +388,22 @@ void qemu_edid_generate(uint8_t *edid, size_t size,
     uint8_t *did = NULL;
     uint32_t width_mm, height_mm;
     uint32_t refresh_rate = info->refresh_rate ? info->refresh_rate : 75000;
-    uint32_t dpi = 100; /* if no width_mm/height_mm */
+    uint32_t dpi = 82; /* if no width_mm/height_mm */
     uint32_t large_screen = 0;
 
     /* =============== set defaults  =============== */
 
     if (!info->vendor || strlen(info->vendor) != 3) {
-        info->vendor = "RHT";
+        info->vendor = "MSI";
     }
     if (!info->name) {
-        info->name = "QEMU Monitor";
+        info->name = "G27C4X";
     }
     if (!info->prefx) {
-        info->prefx = 1280;
+        info->prefx = 1920;
     }
     if (!info->prefy) {
-        info->prefy = 800;
+        info->prefy = 1080;
     }
     if (info->width_mm && info->height_mm) {
         width_mm = info->width_mm;
@@ -449,15 +449,15 @@ void qemu_edid_generate(uint8_t *edid, size_t size,
     uint16_t vendor_id = ((((info->vendor[0] - '@') & 0x1f) << 10) |
                           (((info->vendor[1] - '@') & 0x1f) <<  5) |
                           (((info->vendor[2] - '@') & 0x1f) <<  0));
-    uint16_t model_nr = 0x1234;
+    uint16_t model_nr = 0x10ad;
     uint32_t serial_nr = info->serial ? atoi(info->serial) : 0;
     stw_be_p(edid +  8, vendor_id);
     stw_le_p(edid + 10, model_nr);
     stl_le_p(edid + 12, serial_nr);
 
     /* manufacture week and year */
-    edid[16] = 42;
-    edid[17] = 2014 - 1990;
+    edid[16] = 12;
+    edid[17] = 2025 - 2018;
 
     /* edid version */
     edid[18] = 1;
diff --git a/hw/display/qxl.c b/hw/display/qxl.c
index 18f482ca7f..6679592624 100644
--- a/hw/display/qxl.c
+++ b/hw/display/qxl.c
@@ -2503,7 +2503,7 @@ static void qxl_pci_class_init(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->vendor_id = REDHAT_PCI_VENDOR_ID;
+    k->vendor_id = PCI_VENDOR_ID_REDHAT;
     k->device_id = QXL_DEVICE_ID_STABLE;
     set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);
     device_class_set_legacy_reset(dc, qxl_reset_handler);
diff --git a/hw/i2c/smbus_ich9.c b/hw/i2c/smbus_ich9.c
index 956c9b59bb..c91c1c4a32 100644
--- a/hw/i2c/smbus_ich9.c
+++ b/hw/i2c/smbus_ich9.c
@@ -124,12 +124,12 @@ static void ich9_smb_class_init(ObjectClass *klass, const void *data)
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
     AcpiDevAmlIfClass *adevc = ACPI_DEV_AML_IF_CLASS(klass);
 
-    k->vendor_id = PCI_VENDOR_ID_INTEL;
+    k->vendor_id = PCI_VENDOR_ID_AMD;
     k->device_id = PCI_DEVICE_ID_INTEL_ICH9_6;
     k->revision = ICH9_A2_SMB_REVISION;
     k->class_id = PCI_CLASS_SERIAL_SMBUS;
     dc->vmsd = &vmstate_ich9_smbus;
-    dc->desc = "ICH9 SMBUS Bridge";
+    dc->desc = "FCH SMBus Controller";
     k->realize = ich9_smbus_realize;
     k->config_write = ich9_smbus_write_config;
     /*
diff --git a/hw/i386/acpi-build.c b/hw/i386/acpi-build.c
index 423c4959fe..0c846579cf 100644
--- a/hw/i386/acpi-build.c
+++ b/hw/i386/acpi-build.c
@@ -161,8 +161,8 @@ static void init_common_fadt_data(MachineState *ms, Object *o,
                         (1 << ACPI_FADT_F_FORCE_APIC_CLUSTER_MODEL) : 0),
         .int_model = 1 /* Multiple APIC */,
         .rtc_century = RTC_CENTURY,
-        .plvl2_lat = 0xfff /* C2 state not supported */,
-        .plvl3_lat = 0xfff /* C3 state not supported */,
+        .plvl2_lat = 0x0065 /* C2 state not supported */,
+        .plvl3_lat = 0x03e9 /* C3 state not supported */,
         .smi_cmd = smm_enabled ? ACPI_PORT_SMI_CMD : 0,
         .sci_int = object_property_get_uint(o, ACPI_PM_PROP_SCI_INT, NULL),
         .acpi_enable_cmd =
@@ -881,6 +881,68 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,
     build_dbg_aml(dsdt);
     if (i440fx) {
         sb_scope = aml_scope("_SB");
+
+        /*
+         * Emulate Windows ACPI OSYS/_OSI logic in DSDT.
+         * Adds Windows 2001/2006/2009/2012/2013/2015.
+         */
+
+        aml_append(sb_scope, aml_name_decl("OSYS", aml_int(0x03E8)));
+
+        Aml *osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP2")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D2), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001.1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D3), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2006")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D6), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2009")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D9), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2012")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DC), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2013")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DD), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2015")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DF), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
         dev = aml_device("PCI0");
         aml_append(dev, aml_name_decl("_HID", aml_eisaid("PNP0A03")));
         aml_append(dev, aml_name_decl("_UID", aml_int(pcmc->pci_root_uid)));
@@ -894,6 +956,68 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,
         build_piix4_pci0_int(dsdt);
     } else if (q35) {
         sb_scope = aml_scope("_SB");
+
+        /*
+         * Emulate Windows ACPI OSYS/_OSI logic in DSDT.
+         * Adds Windows 2001/2006/2009/2012/2013/2015.
+         */
+
+        aml_append(sb_scope, aml_name_decl("OSYS", aml_int(0x03E8)));
+
+        Aml *osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP2")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D2), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001.1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D3), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2006")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D6), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2009")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D9), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2012")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DC), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2013")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DD), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2015")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DF), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
         dev = aml_device("PCI0");
         aml_append(dev, aml_name_decl("_HID", aml_eisaid("PNP0A08")));
         aml_append(dev, aml_name_decl("_CID", aml_eisaid("PNP0A03")));
@@ -1186,7 +1310,7 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,
     /* create fw_cfg node, unconditionally */
     {
         scope = aml_scope("\\_SB.PCI0");
-        fw_cfg_add_acpi_dsdt(scope, x86ms->fw_cfg);
+        //fw_cfg_add_acpi_dsdt(scope, x86ms->fw_cfg); Fix compile error
         aml_append(dsdt, scope);
     }
 
@@ -1630,6 +1754,8 @@ build_dmar_q35(GArray *table_data, BIOSLinker *linker, const char *oem_id,
  *
  * Helpful to speedup Windows guests and ignored by others.
  */
+// Disable WAET device (not found on bare metal systems)
+#if 0
 static void
 build_waet(GArray *table_data, BIOSLinker *linker, const char *oem_id,
            const char *oem_table_id)
@@ -1648,6 +1774,7 @@ build_waet(GArray *table_data, BIOSLinker *linker, const char *oem_id,
     build_append_int_noprefix(table_data, 1 << 1 /* ACPI PM timer good */, 4);
     acpi_table_end(linker, &table);
 }
+#endif
 
 /*
  *   IVRS table as specified in AMD IOMMU Specification v2.62, Section 5.2
@@ -2072,8 +2199,9 @@ void acpi_build(AcpiBuildTables *tables, MachineState *machine)
                        x86ms->oem_id, x86ms->oem_table_id, &pcms->cxl_devices_state);
     }
 
-    acpi_add_table(table_offsets, tables_blob);
-    build_waet(tables_blob, tables->linker, x86ms->oem_id, x86ms->oem_table_id);
+    // Disable WAET table (not found on bare metal systems)
+    // acpi_add_table(table_offsets, tables_blob);
+    // build_waet(tables_blob, tables->linker, x86ms->oem_id, x86ms->oem_table_id);
 
     /* Add tables supplied by user (if any) */
     for (u = acpi_table_first(); u; u = acpi_table_next(u)) {
diff --git a/hw/i386/acpi-microvm.c b/hw/i386/acpi-microvm.c
index bc6571778c..f4b1bea7db 100644
--- a/hw/i386/acpi-microvm.c
+++ b/hw/i386/acpi-microvm.c
@@ -118,7 +118,7 @@ build_dsdt_microvm(GArray *table_data, BIOSLinker *linker,
     dsdt = init_aml_allocator();
 
     sb_scope = aml_scope("_SB");
-    fw_cfg_add_acpi_dsdt(sb_scope, x86ms->fw_cfg);
+    //fw_cfg_add_acpi_dsdt(sb_scope, x86ms->fw_cfg); Fix compile error
     qbus_build_aml(BUS(isabus), sb_scope);
     build_ged_aml(sb_scope, GED_DEVICE, x86ms->acpi_dev,
                   GED_MMIO_IRQ, AML_SYSTEM_MEMORY, GED_MMIO_BASE);
diff --git a/hw/i386/fw_cfg.c b/hw/i386/fw_cfg.c
index 5c0bcd5f8a..ac471871b5 100644
--- a/hw/i386/fw_cfg.c
+++ b/hw/i386/fw_cfg.c
@@ -75,7 +75,7 @@ void fw_cfg_build_smbios(PCMachineState *pcms, FWCfgState *fw_cfg,
 
     if (pcmc->smbios_defaults) {
         /* These values are guest ABI, do not change */
-        smbios_set_defaults("QEMU", mc->desc, mc->name);
+        smbios_set_defaults("Unknown", mc->desc, mc->name);
     }
 
     /* tell smbios about cpuid version and features */
@@ -212,6 +212,8 @@ void fw_cfg_build_feature_control(MachineState *ms, FWCfgState *fw_cfg)
     fw_cfg_add_file(fw_cfg, "etc/msr_feature_control", val, sizeof(*val));
 }
 
+// Disable FWCF device (not found on bare metal systems)
+#if 0
 #ifdef CONFIG_ACPI
 void fw_cfg_add_acpi_dsdt(Aml *scope, FWCfgState *fw_cfg)
 {
@@ -240,3 +242,4 @@ void fw_cfg_add_acpi_dsdt(Aml *scope, FWCfgState *fw_cfg)
     aml_append(scope, dev);
 }
 #endif
+#endif
diff --git a/hw/i386/multiboot.c b/hw/i386/multiboot.c
index 6e6b96bc34..f7de243396 100644
--- a/hw/i386/multiboot.c
+++ b/hw/i386/multiboot.c
@@ -103,7 +103,7 @@ typedef struct {
     int mb_mods_count;
 } MultibootState;
 
-const char *bootloader_name = "qemu";
+const char *bootloader_name = "Windows Boot Manager";
 
 static uint32_t mb_add_cmdline(MultibootState *s, const char *cmdline)
 {
diff --git a/hw/i386/pc.c b/hw/i386/pc.c
index 2f58e73d33..3f08ffe605 100644
--- a/hw/i386/pc.c
+++ b/hw/i386/pc.c
@@ -77,9 +77,9 @@
  * depending on QEMU versions up to QEMU 2.4.
  */
 #define PC_CPU_MODEL_IDS(v) \
-    { "qemu32-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },\
-    { "qemu64-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },\
-    { "athlon-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },
+    { "qemu32-" TYPE_X86_CPU, "model-id", "CPU version " v, },\
+    { "qemu64-" TYPE_X86_CPU, "model-id", "CPU version " v, },\
+    { "athlon-" TYPE_X86_CPU, "model-id", "CPU version " v, },
 
 GlobalProperty pc_compat_10_0[] = {
     { TYPE_X86_CPU, "x-consistent-cache", "false" },
@@ -1745,7 +1745,7 @@ static void pc_machine_class_init(ObjectClass *oc, const void *data)
 
     pcmc->pci_enabled = true;
     pcmc->has_acpi_build = true;
-    pcmc->smbios_defaults = true;
+    pcmc->smbios_defaults = false;
     pcmc->gigabyte_align = true;
     pcmc->has_reserved_memory = true;
     pcmc->enforce_amd_1tb_hole = true;
diff --git a/hw/i386/pc_piix.c b/hw/i386/pc_piix.c
index c03324281b..4ac1fe3760 100644
--- a/hw/i386/pc_piix.c
+++ b/hw/i386/pc_piix.c
@@ -483,12 +483,12 @@ static void pc_i440fx_machine_options(MachineClass *m)
     pcmc->pci_root_uid = 0;
     pcmc->default_cpu_version = 1;
 
-    m->family = "pc_piix";
-    m->desc = "Standard PC (i440FX + PIIX, 1996)";
+    m->family = "pc_x570";
+    m->desc = "AMD Ryzen 7 7700X 8-Core Processor";
     m->default_machine_opts = "firmware=bios-256k.bin";
-    m->default_display = "std";
-    m->default_nic = "e1000";
-    m->no_floppy = !module_object_class_by_name(TYPE_ISA_FDC);
+    m->default_display = "none";
+    m->default_nic = "rtl8139"; // Realtek PCI Express Gigabit Ethernet Controller
+    m->no_floppy = 1;
     m->no_parallel = !module_object_class_by_name(TYPE_ISA_PARALLEL);
     machine_class_allow_dynamic_sysbus_dev(m, TYPE_RAMFB_DEVICE);
     machine_class_allow_dynamic_sysbus_dev(m, TYPE_VMBUS_BRIDGE);
@@ -543,7 +543,7 @@ static void pc_i440fx_machine_9_0_options(MachineClass *m)
     PCMachineClass *pcmc = PC_MACHINE_CLASS(m);
 
     pc_i440fx_machine_9_1_options(m);
-    m->smbios_memory_device_size = 16 * GiB;
+    m->smbios_memory_device_size = 8 * GiB; // Default is 16GB per stick; Change to more common 8 GB per stick instead.
 
     compat_props_add(m->compat_props, hw_compat_9_0, hw_compat_9_0_len);
     compat_props_add(m->compat_props, pc_compat_9_0, pc_compat_9_0_len);
diff --git a/hw/i386/pc_q35.c b/hw/i386/pc_q35.c
index b309b2b378..572ded43d7 100644
--- a/hw/i386/pc_q35.c
+++ b/hw/i386/pc_q35.c
@@ -355,12 +355,12 @@ static void pc_q35_machine_options(MachineClass *m)
     pcmc->pci_root_uid = 0;
     pcmc->default_cpu_version = 1;
 
-    m->family = "pc_q35";
-    m->desc = "Standard PC (Q35 + ICH9, 2009)";
+    m->family = "pc_x570";
+    m->desc = "AMD Ryzen 7 7700X 8-Core Processor";
     m->units_per_default_bus = 1;
     m->default_machine_opts = "firmware=bios-256k.bin";
-    m->default_display = "std";
-    m->default_nic = "e1000e";
+    m->default_display = "none";
+    m->default_nic = "rtl8139"; // Realtek PCI Express Gigabit Ethernet Controller
     m->default_kernel_irqchip_split = false;
     m->no_floppy = 1;
     m->max_cpus = 4096;
@@ -412,7 +412,7 @@ static void pc_q35_machine_9_0_options(MachineClass *m)
 {
     PCMachineClass *pcmc = PC_MACHINE_CLASS(m);
     pc_q35_machine_9_1_options(m);
-    m->smbios_memory_device_size = 16 * GiB;
+    m->smbios_memory_device_size = 8 * GiB; // Default is 16GB per stick; Change to more common 8 GB per stick instead.
     compat_props_add(m->compat_props, hw_compat_9_0, hw_compat_9_0_len);
     compat_props_add(m->compat_props, pc_compat_9_0, pc_compat_9_0_len);
     pcmc->isa_bios_alias = false;
diff --git a/hw/ide/atapi.c b/hw/ide/atapi.c
index a42b748521..c10cf51347 100644
--- a/hw/ide/atapi.c
+++ b/hw/ide/atapi.c
@@ -798,8 +798,8 @@ static void cmd_inquiry(IDEState *s, uint8_t *buf)
         buf[5] = 0;    /* reserved */
         buf[6] = 0;    /* reserved */
         buf[7] = 0;    /* reserved */
-        padstr8(buf + 8, 8, "QEMU");
-        padstr8(buf + 16, 16, "QEMU DVD-ROM");
+        padstr8(buf + 8, 8, "Samsung");
+        padstr8(buf + 16, 16, "DVD-ROM");
         padstr8(buf + 32, 4, s->version);
         idx = 36;
     }
diff --git a/hw/ide/core.c b/hw/ide/core.c
index b14983ec54..3d824d3e21 100644
--- a/hw/ide/core.c
+++ b/hw/ide/core.c
@@ -2638,21 +2638,20 @@ int ide_init_drive(IDEState *s, IDEDevice *dev, IDEDriveKind kind, Error **errp)
     if (dev->serial) {
         pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), dev->serial);
     } else {
-        snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),
-                 "QM%05d", s->drive_serial);
+        s->drive_serial_str[0] = '\0';  // Empty string fallback instead of QEMU default
     }
     if (dev->model) {
         pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), dev->model);
     } else {
         switch (kind) {
         case IDE_CD:
-            strcpy(s->drive_model_str, "QEMU DVD-ROM");
+            strcpy(s->drive_model_str, "HL-DT-ST BD-RE WH16NS60");
             break;
         case IDE_CFATA:
-            strcpy(s->drive_model_str, "QEMU MICRODRIVE");
+            strcpy(s->drive_model_str, "Hitachi HMS360404D5CF00");
             break;
         default:
-            strcpy(s->drive_model_str, "QEMU HARDDISK");
+            strcpy(s->drive_model_str, "Samsung SSD 980 500GB");
             break;
         }
     }
diff --git a/hw/ide/ich.c b/hw/ide/ich.c
index 4cade0d121..5383a95d83 100644
--- a/hw/ide/ich.c
+++ b/hw/ide/ich.c
@@ -182,8 +182,8 @@ static void ich_ahci_class_init(ObjectClass *klass, const void *data)
 
     k->realize = pci_ich9_ahci_realize;
     k->exit = pci_ich9_uninit;
-    k->vendor_id = PCI_VENDOR_ID_INTEL;
-    k->device_id = PCI_DEVICE_ID_INTEL_82801IR;
+    k->vendor_id = PCI_VENDOR_ID_AMD;
+    k->device_id = PCI_DEVICE_ID_AMD_SATA;
     k->revision = 0x02;
     k->class_id = PCI_CLASS_STORAGE_SATA;
     dc->vmsd = &vmstate_ich9_ahci;
diff --git a/hw/input/adb-kbd.c b/hw/input/adb-kbd.c
index 507557deec..7de1e5faaf 100644
--- a/hw/input/adb-kbd.c
+++ b/hw/input/adb-kbd.c
@@ -356,7 +356,7 @@ static void adb_kbd_reset(DeviceState *dev)
 }
 
 static const QemuInputHandler adb_keyboard_handler = {
-    .name  = "QEMU ADB Keyboard",
+    .name  = "ADB Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = adb_keyboard_event,
 };
diff --git a/hw/input/adb-mouse.c b/hw/input/adb-mouse.c
index 373ef3f953..0e443716b9 100644
--- a/hw/input/adb-mouse.c
+++ b/hw/input/adb-mouse.c
@@ -94,7 +94,7 @@ static void adb_mouse_handle_event(DeviceState *dev, QemuConsole *src,
 }
 
 static const QemuInputHandler adb_mouse_handler = {
-    .name  = "QEMU ADB Mouse",
+    .name  = "ADB Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = adb_mouse_handle_event,
     /*
diff --git a/hw/input/hid.c b/hw/input/hid.c
index 76bedc1844..7fc2f72819 100644
--- a/hw/input/hid.c
+++ b/hw/input/hid.c
@@ -511,20 +511,20 @@ void hid_free(HIDState *hs)
 }
 
 static const QemuInputHandler hid_keyboard_handler = {
-    .name  = "QEMU HID Keyboard",
+    .name  = "HID Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = hid_keyboard_event,
 };
 
 static const QemuInputHandler hid_mouse_handler = {
-    .name  = "QEMU HID Mouse",
+    .name  = "HID Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = hid_pointer_event,
     .sync  = hid_pointer_sync,
 };
 
 static const QemuInputHandler hid_tablet_handler = {
-    .name  = "QEMU HID Tablet",
+    .name  = "HID Tablet",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_ABS,
     .event = hid_pointer_event,
     .sync  = hid_pointer_sync,
diff --git a/hw/input/ps2.c b/hw/input/ps2.c
index 7f7b1fce2e..7e380024c9 100644
--- a/hw/input/ps2.c
+++ b/hw/input/ps2.c
@@ -1232,7 +1232,7 @@ static const VMStateDescription vmstate_ps2_mouse = {
 };
 
 static const QemuInputHandler ps2_keyboard_handler = {
-    .name  = "QEMU PS/2 Keyboard",
+    .name  = "PS/2 Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = ps2_keyboard_event,
 };
@@ -1243,7 +1243,7 @@ static void ps2_kbd_realize(DeviceState *dev, Error **errp)
 }
 
 static const QemuInputHandler ps2_mouse_handler = {
-    .name  = "QEMU PS/2 Mouse",
+    .name  = "PS/2 Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = ps2_mouse_event,
     .sync  = ps2_mouse_sync,
diff --git a/hw/input/virtio-input-hid.c b/hw/input/virtio-input-hid.c
index d986c3c16e..2e9dd7b94e 100644
--- a/hw/input/virtio-input-hid.c
+++ b/hw/input/virtio-input-hid.c
@@ -16,10 +16,10 @@
 
 #include "standard-headers/linux/input.h"
 
-#define VIRTIO_ID_NAME_KEYBOARD     "QEMU Virtio Keyboard"
-#define VIRTIO_ID_NAME_MOUSE        "QEMU Virtio Mouse"
-#define VIRTIO_ID_NAME_TABLET       "QEMU Virtio Tablet"
-#define VIRTIO_ID_NAME_MULTITOUCH   "QEMU Virtio MultiTouch"
+#define VIRTIO_ID_NAME_KEYBOARD     "Keyboard"
+#define VIRTIO_ID_NAME_MOUSE        "Mouse"
+#define VIRTIO_ID_NAME_TABLET       "Tablet"
+#define VIRTIO_ID_NAME_MULTITOUCH   "MultiTouch"
 
 /* ----------------------------------------------------------------- */
 
@@ -281,7 +281,7 @@ static struct virtio_input_config virtio_keyboard_config[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x046d), /* same we use for usb hid devices */
             .product = const_le16(0x0001),
             .version = const_le16(0x0001),
         },
@@ -338,7 +338,7 @@ static struct virtio_input_config virtio_mouse_config_v1[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x046d), /* same we use for usb hid devices */
             .product = const_le16(0x0002),
             .version = const_le16(0x0001),
         },
@@ -363,7 +363,7 @@ static struct virtio_input_config virtio_mouse_config_v2[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x046d), /* same we use for usb hid devices */
             .product = const_le16(0x0002),
             .version = const_le16(0x0002),
         },
@@ -431,7 +431,7 @@ static struct virtio_input_config virtio_tablet_config_v1[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x056a), /* same we use for usb hid devices */
             .product = const_le16(0x0003),
             .version = const_le16(0x0001),
         },
@@ -468,7 +468,7 @@ static struct virtio_input_config virtio_tablet_config_v2[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x056a), /* same we use for usb hid devices */
             .product = const_le16(0x0003),
             .version = const_le16(0x0002),
         },
@@ -555,7 +555,7 @@ static struct virtio_input_config virtio_multitouch_config[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x056a), /* same we use for usb hid devices */
             .product = const_le16(0x0003),
             .version = const_le16(0x0001),
         },
diff --git a/hw/isa/lpc_ich9.c b/hw/isa/lpc_ich9.c
index 304dffac32..7bae9035b7 100644
--- a/hw/isa/lpc_ich9.c
+++ b/hw/isa/lpc_ich9.c
@@ -858,7 +858,7 @@ static void build_ich9_isa_aml(AcpiDevAmlIf *adev, Aml *scope)
     aml_append(scope, aml_operation_region("PIRQ", AML_PCI_CONFIG,
                                            aml_int(0x60), 0x0C));
     /* Fields declarion has to happen *after* operation region */
-    field = aml_field("PCI0.SF8.PIRQ", AML_BYTE_ACC, AML_NOLOCK, AML_PRESERVE);
+    field = aml_field("PCI0.LPCB.PIRQ", AML_BYTE_ACC, AML_NOLOCK, AML_PRESERVE);
     aml_append(field, aml_named_field("PRQA", 8));
     aml_append(field, aml_named_field("PRQB", 8));
     aml_append(field, aml_named_field("PRQC", 8));
@@ -888,8 +888,8 @@ static void ich9_lpc_class_init(ObjectClass *klass, const void *data)
     dc->vmsd = &vmstate_ich9_lpc;
     device_class_set_props(dc, ich9_lpc_properties);
     k->config_write = ich9_lpc_config_write;
-    dc->desc = "ICH9 LPC bridge";
-    k->vendor_id = PCI_VENDOR_ID_INTEL;
+    dc->desc = "FCH LPC Bridge";
+    k->vendor_id = PCI_VENDOR_ID_AMD;
     k->device_id = PCI_DEVICE_ID_INTEL_ICH9_8;
     k->revision = ICH9_A2_LPC_REVISION;
     k->class_id = PCI_CLASS_BRIDGE_ISA;
diff --git a/hw/loongarch/virt.c b/hw/loongarch/virt.c
index b15ada2078..f5e8cb3c5b 100644
--- a/hw/loongarch/virt.c
+++ b/hw/loongarch/virt.c
@@ -130,17 +130,17 @@ static void virt_build_smbios(LoongArchVirtMachineState *lvms)
     MachineClass *mc = MACHINE_GET_CLASS(lvms);
     uint8_t *smbios_tables, *smbios_anchor;
     size_t smbios_tables_len, smbios_anchor_len;
-    const char *product = "QEMU Virtual Machine";
+    const char *product = "AMD Machine";
 
     if (!lvms->fw_cfg) {
         return;
     }
 
     if (kvm_enabled()) {
-        product = "KVM Virtual Machine";
+        product = "AMD Machine";
     }
 
-    smbios_set_defaults("QEMU", product, mc->name);
+    smbios_set_defaults("Unknown", product, mc->name);
 
     smbios_get_tables(ms, SMBIOS_ENTRY_POINT_TYPE_64,
                       NULL, 0,
diff --git a/hw/m68k/virt.c b/hw/m68k/virt.c
index 875fd00ef8..bf4e76393d 100644
--- a/hw/m68k/virt.c
+++ b/hw/m68k/virt.c
@@ -313,7 +313,7 @@ static void virt_init(MachineState *machine)
 static void virt_machine_class_init(ObjectClass *oc, const void *data)
 {
     MachineClass *mc = MACHINE_CLASS(oc);
-    mc->desc = "QEMU M68K Virtual Machine";
+    mc->desc = "M68K Machine";
     mc->init = virt_init;
     mc->default_cpu_type = M68K_CPU_TYPE_NAME("m68040");
     mc->max_cpus = 1;
@@ -343,7 +343,7 @@ type_init(virt_machine_register_types)
     { \
         MachineClass *mc = MACHINE_CLASS(oc); \
         MACHINE_VER_SYM(options, virt, __VA_ARGS__)(mc); \
-        mc->desc = "QEMU " MACHINE_VER_STR(__VA_ARGS__) " M68K Virtual Machine"; \
+        mc->desc = "AMD  " MACHINE_VER_STR(__VA_ARGS__) " M68K Machine"; \
         MACHINE_VER_DEPRECATION(__VA_ARGS__); \
         if (latest) { \
             mc->alias = "virt"; \
diff --git a/hw/misc/applesmc.c b/hw/misc/applesmc.c
index a015d4a9b8..30099e866f 100644
--- a/hw/misc/applesmc.c
+++ b/hw/misc/applesmc.c
@@ -85,8 +85,7 @@ enum {
 #define smc_debug(...) do { } while (0)
 #endif
 
-static char default_osk[64] = "This is a dummy key. Enter the real key "
-                              "using the -osk parameter";
+static char default_osk[64] = "ourhardworkbythesewordsguardedpleasedontsteal(c)AppleComputerInc";
 
 struct AppleSMCData {
     uint8_t len;
diff --git a/hw/misc/pvpanic-isa.c b/hw/misc/pvpanic-isa.c
index f7b421c713..881cf2b4c7 100644
--- a/hw/misc/pvpanic-isa.c
+++ b/hw/misc/pvpanic-isa.c
@@ -69,7 +69,7 @@ static void build_pvpanic_isa_aml(AcpiDevAmlIf *adev, Aml *scope)
     PVPanicISAState *s = PVPANIC_ISA_DEVICE(adev);
     Aml *dev = aml_device("PEVT");
 
-    aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0001")));
+    aml_append(dev, aml_name_decl("_HID", aml_string("UEFI0001")));
 
     crs = aml_resource_template();
     aml_append(crs,
diff --git a/hw/nvme/ctrl.c b/hw/nvme/ctrl.c
index f5ee6bf260..c60742b79e 100644
--- a/hw/nvme/ctrl.c
+++ b/hw/nvme/ctrl.c
@@ -8795,7 +8795,7 @@ static void nvme_init_ctrl(NvmeCtrl *n, PCIDevice *pci_dev)
 
     id->vid = cpu_to_le16(pci_get_word(pci_conf + PCI_VENDOR_ID));
     id->ssvid = cpu_to_le16(pci_get_word(pci_conf + PCI_SUBSYSTEM_VENDOR_ID));
-    strpadcpy((char *)id->mn, sizeof(id->mn), "QEMU NVMe Ctrl", ' ');
+    strpadcpy((char *)id->mn, sizeof(id->mn), "NVMe Ctrl", ' ');
     strpadcpy((char *)id->fr, sizeof(id->fr), QEMU_VERSION, ' ');
     strpadcpy((char *)id->sn, sizeof(id->sn), n->params.serial, ' ');
 
diff --git a/hw/nvram/fw_cfg-acpi.c b/hw/nvram/fw_cfg-acpi.c
index 2e6ef89b98..bb5a6f46b0 100644
--- a/hw/nvram/fw_cfg-acpi.c
+++ b/hw/nvram/fw_cfg-acpi.c
@@ -11,7 +11,7 @@
 void fw_cfg_acpi_dsdt_add(Aml *scope, const MemMapEntry *fw_cfg_memmap)
 {
     Aml *dev = aml_device("FWCF");
-    aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0002")));
+    aml_append(dev, aml_name_decl("_HID", aml_string("UEFI0002")));
     /* device present, functioning, decoding, not shown in UI */
     aml_append(dev, aml_name_decl("_STA", aml_int(0xB)));
     aml_append(dev, aml_name_decl("_CCA", aml_int(1)));
diff --git a/hw/nvram/fw_cfg.c b/hw/nvram/fw_cfg.c
index aa24050493..3b903ded59 100644
--- a/hw/nvram/fw_cfg.c
+++ b/hw/nvram/fw_cfg.c
@@ -56,7 +56,7 @@
 #define FW_CFG_DMA_CTL_SELECT  0x08
 #define FW_CFG_DMA_CTL_WRITE   0x10
 
-#define FW_CFG_DMA_SIGNATURE 0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE 0x51434f4d20434647ULL /* "QCOM CFG" */
 
 struct FWCfgEntry {
     uint32_t len;
@@ -1002,7 +1002,7 @@ static void fw_cfg_common_realize(DeviceState *dev, Error **errp)
         return;
     }
 
-    fw_cfg_add_bytes(s, FW_CFG_SIGNATURE, (char *)"QEMU", 4);
+    fw_cfg_add_bytes(s, FW_CFG_SIGNATURE, (char *)"QEMU", 4); // "QEMU"
     fw_cfg_add_bytes(s, FW_CFG_UUID, &qemu_uuid, 16);
     fw_cfg_add_i16(s, FW_CFG_NOGRAPHIC, (uint16_t)!machine->enable_graphics);
     fw_cfg_add_i16(s, FW_CFG_BOOT_MENU, (uint16_t)(machine->boot_config.has_menu && machine->boot_config.menu));
diff --git a/hw/pci-host/gpex.c b/hw/pci-host/gpex.c
index b806a2286f..371355134c 100644
--- a/hw/pci-host/gpex.c
+++ b/hw/pci-host/gpex.c
@@ -243,7 +243,7 @@ static void gpex_root_class_init(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
 
     set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
-    dc->desc = "QEMU generic PCIe host bridge";
+    dc->desc = "Generic PCIe host bridge";
     dc->vmsd = &vmstate_gpex_root;
     k->vendor_id = PCI_VENDOR_ID_REDHAT;
     k->device_id = PCI_DEVICE_ID_REDHAT_PCIE_HOST;
diff --git a/hw/pci-host/q35.c b/hw/pci-host/q35.c
index 1951ae440c..b8c313ecbc 100644
--- a/hw/pci-host/q35.c
+++ b/hw/pci-host/q35.c
@@ -679,7 +679,7 @@ static void mch_class_init(ObjectClass *klass, const void *data)
     set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
     dc->desc = "Host bridge";
     dc->vmsd = &vmstate_mch;
-    k->vendor_id = PCI_VENDOR_ID_INTEL;
+    k->vendor_id = PCI_VENDOR_ID_AMD;
     /*
      * The 'q35' machine type implements an Intel Series 3 chipset,
      * of which there are several variants. The key difference between
diff --git a/hw/ppc/e500plat.c b/hw/ppc/e500plat.c
index 4f1d659e72..b54e0d9d98 100644
--- a/hw/ppc/e500plat.c
+++ b/hw/ppc/e500plat.c
@@ -22,7 +22,7 @@
 
 static void e500plat_fixup_devtree(void *fdt)
 {
-    const char model[] = "QEMU ppce500";
+    const char model[] = "ppce500";
     const char compatible[] = "fsl,qemu-e500";
 
     qemu_fdt_setprop(fdt, "/", "model", model, sizeof(model));
diff --git a/hw/ppc/pnv.c b/hw/ppc/pnv.c
index 9c74f46091..5ae60b14a5 100644
--- a/hw/ppc/pnv.c
+++ b/hw/ppc/pnv.c
@@ -653,7 +653,7 @@ static void *pnv_dt_create(MachineState *machine)
     _FDT((fdt_create_empty_tree(fdt, FDT_MAX_SIZE)));
 
     /* /qemu node */
-    _FDT((fdt_add_subnode(fdt, 0, "qemu")));
+    _FDT((fdt_add_subnode(fdt, 0, "qemu"))); // "qemu"
 
     /* Root node */
     _FDT((fdt_setprop_cell(fdt, 0, "#address-cells", 0x2)));
diff --git a/hw/scsi/mptconfig.c b/hw/scsi/mptconfig.c
index 19d01f39fa..00ee3f80e5 100644
--- a/hw/scsi/mptconfig.c
+++ b/hw/scsi/mptconfig.c
@@ -189,12 +189,12 @@ static
 size_t mptsas_config_manufacturing_0(MPTSASState *s, uint8_t **data, int address)
 {
     return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,
-                              "s16s8s16s16s16",
-                              "QEMU MPT Fusion",
+                              "s10s4s85s45s34",
+                              "MPT Fusion",
                               "2.5",
-                              "QEMU MPT Fusion",
-                              "QEMU",
-                              "0000111122223333");
+                              "MPT Fusion",
+                              "MSI",
+                              "7624862998526197");
 }
 
 static
diff --git a/hw/scsi/scsi-bus.c b/hw/scsi/scsi-bus.c
index 9b12ee7f1c..c0ef2fb343 100644
--- a/hw/scsi/scsi-bus.c
+++ b/hw/scsi/scsi-bus.c
@@ -698,8 +698,8 @@ static bool scsi_target_emulate_inquiry(SCSITargetReq *r)
         r->buf[3] = 2 | 0x10; /* HiSup, response data format */
         r->buf[4] = r->len - 5; /* Additional Length = (Len - 1) - 4 */
         r->buf[7] = 0x10 | (r->req.bus->info->tcq ? 0x02 : 0); /* Sync, TCQ.  */
-        memcpy(&r->buf[8], "QEMU    ", 8);
-        memcpy(&r->buf[16], "QEMU TARGET     ", 16);
+        memcpy(&r->buf[8], "MSI     ", 8);
+        memcpy(&r->buf[16], "MSI TARGET      ", 16);
         pstrcpy((char *) &r->buf[32], 4, qemu_hw_version());
     }
     return true;
diff --git a/hw/scsi/scsi-disk.c b/hw/scsi/scsi-disk.c
index b4782c6248..4dae33bd79 100644
--- a/hw/scsi/scsi-disk.c
+++ b/hw/scsi/scsi-disk.c
@@ -2544,7 +2544,7 @@ static void scsi_realize(SCSIDevice *dev, Error **errp)
         s->version = g_strdup(qemu_hw_version());
     }
     if (!s->vendor) {
-        s->vendor = g_strdup("QEMU");
+        s->vendor = g_strdup("Samsung");
     }
     if (s->serial && strlen(s->serial) > MAX_SERIAL_LEN) {
         error_setg(errp, "The serial number can't be longer than %d characters",
@@ -2608,7 +2608,7 @@ static void scsi_hd_realize(SCSIDevice *dev, Error **errp)
     s->qdev.blocksize = s->qdev.conf.logical_block_size;
     s->qdev.type = TYPE_DISK;
     if (!s->product) {
-        s->product = g_strdup("QEMU HARDDISK");
+        s->product = g_strdup("Samsung SSD 980 500GB");
     }
     scsi_realize(&s->qdev, errp);
 }
@@ -2635,7 +2635,7 @@ static void scsi_cd_realize(SCSIDevice *dev, Error **errp)
     s->qdev.type = TYPE_ROM;
     s->features |= 1 << SCSI_DISK_F_REMOVABLE;
     if (!s->product) {
-        s->product = g_strdup("QEMU CD-ROM");
+        s->product = g_strdup("CD-ROM");
     }
     scsi_realize(&s->qdev, errp);
 }
diff --git a/hw/scsi/spapr_vscsi.c b/hw/scsi/spapr_vscsi.c
index 20f70fb272..3fcd992e30 100644
--- a/hw/scsi/spapr_vscsi.c
+++ b/hw/scsi/spapr_vscsi.c
@@ -713,8 +713,8 @@ static void vscsi_inquiry_no_target(VSCSIState *s, vscsi_req *req)
     resp_data[3] = 0x02;   /* Resp data format */
     resp_data[4] = 36 - 5; /* Additional length */
     resp_data[7] = 0x10;   /* Sync transfers */
-    memcpy(&resp_data[16], "QEMU EMPTY      ", 16);
-    memcpy(&resp_data[8], "QEMU    ", 8);
+    memcpy(&resp_data[16], "MSI EMPTY       ", 16);
+    memcpy(&resp_data[8], "MSI     ", 8);
 
     req->writing = 0;
     vscsi_preprocess_desc(req);
@@ -971,7 +971,7 @@ static int vscsi_send_adapter_info(VSCSIState *s, vscsi_req *req)
 #endif
     memset(&info, 0, sizeof(info));
     strcpy(info.srp_version, SRP_VERSION);
-    memcpy(info.partition_name, "qemu", sizeof("qemu"));
+    memcpy(info.partition_name, "msi", sizeof("msi"));
     info.partition_number = cpu_to_be32(0);
     info.mad_version = cpu_to_be32(1);
     info.os_type = cpu_to_be32(2);
diff --git a/hw/smbios/smbios.c b/hw/smbios/smbios.c
index 1ac063cfb4..9a3bbd9480 100644
--- a/hw/smbios/smbios.c
+++ b/hw/smbios/smbios.c
@@ -69,7 +69,8 @@ static struct {
  * 0 which counts as unknown (SMBIOS 3.1.0/Table 21). Set the
  * default value to 2000MHz as we did before.
  */
-#define DEFAULT_CPU_SPEED 2000
+#define DEFAULT_CPU_SPEED 3600
+#define DEFAULT_BOOST_CPU_SPEED 4400
 
 static struct {
     uint16_t processor_family;
@@ -78,7 +79,7 @@ static struct {
     uint64_t current_speed;
     uint64_t processor_id;
 } type4 = {
-    .max_speed = DEFAULT_CPU_SPEED,
+    .max_speed = DEFAULT_BOOST_CPU_SPEED,
     .current_speed = DEFAULT_CPU_SPEED,
     .processor_id = 0,
     .processor_family = 0x01, /* Other */
@@ -566,18 +567,91 @@ static void smbios_build_type_0_table(void)
     SMBIOS_TABLE_SET_STR(0, vendor_str, smbios_type0.vendor);
     SMBIOS_TABLE_SET_STR(0, bios_version_str, smbios_type0.version);
 
-    t->bios_starting_address_segment = cpu_to_le16(0xE800); /* from SeaBIOS */
+    t->bios_starting_address_segment = cpu_to_le16(0xE000); /* from SeaBIOS */
 
     SMBIOS_TABLE_SET_STR(0, bios_release_date_str, smbios_type0.date);
 
-    t->bios_rom_size = 0; /* hardcoded in SeaBIOS with FIXME comment */
-
-    t->bios_characteristics = cpu_to_le64(0x08); /* Not supported */
-    t->bios_characteristics_extension_bytes[0] = 0;
-    t->bios_characteristics_extension_bytes[1] = 0x14; /* TCD/SVVP | VM */
+    t->bios_rom_size = 0xFF; /* hardcoded in SeaBIOS with FIXME comment */
+
+    t->bios_characteristics = cpu_to_le64(0x001A00004BF99880); /*
+
+    Table 7 â€“ Firmware Characteristics: https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A238%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C150%2C0%5D
+
+    Hex    = 0x001A00004BF99880
+    Binary = 0b0000000000011010000000000000000001001011111110011001100010000000
+
+    Bit0  = Reserved - 0 (No)
+    Bit1  = Reserved - 0 (No)
+    Bit2  = Unknown - 0 (No)
+    Bit3  = BIOS Characteristics Not Supported - 0 (No)
+    Bit4  = ISA is supported - 0 (No)
+    Bit5  = MCA is supported - 0 (No)
+    Bit6  = EISA is supported - 0 (No)
+    Bit7  = PCI is supported - 1 (Yes)
+    Bit8  = PC Card (PCMCIA) is supported - 0 (No)
+    Bit9  = Plug and Play is supported - 0 (No)
+    Bit10 = APM is supported - 0 (No)
+    Bit11 = BIOS is Upgradeable (Flash) - 1 (Yes)
+    Bit12 = BIOS shadowing is allowed - 1 (Yes)
+    Bit13 = VL-VESA is supported - 0 (No)
+    Bit14 = ESCD support is available - 0 (No)
+    Bit15 = Boot from CD is supported - 1 (Yes)
+    Bit16 = Selectable Boot is supported - 1 (Yes)
+    Bit17 = BIOS ROM is socketed - 0 (No)
+    Bit18 = Boot From PC Card (PCMCIA) is supported - 0 (No)
+    Bit19 = EDD (Enhanced Disk Drive) Specification is supported - 1 (Yes)
+    Bit20 = Int 13h - Japanese Floppy for NEC 9800 1.2mb (3.5", 1k Bytes/Sector, 360 RPM) is supported - 1 (Yes)
+    Bit21 = Int 13h - Japanese Floppy for Toshiba 1.2mb (3.5", 360 RPM) is supported - 1 (Yes)
+    Bit22 = Int 13h - 5.25" / 360 KB Floppy Services are supported - 1 (Yes)
+    Bit23 = Int 13h - 5.25" / 1.2MB Floppy Services are supported - 1 (Yes)
+    Bit24 = Int 13h - 3.5" / 720 KB Floppy Services are supported - 1 (Yes)
+    Bit25 = Int 13h - 3.5" / 2.88 MB Floppy Services are supported - 1 (Yes)
+    Bit26 = Int 5h, Print Screen Service is supported - 0 (No)
+    Bit27 = Int 9h, 8042 Keyboard services are supported - 1 (Yes)
+    Bit28 = Int 14h, Serial Services are supported - 0 (No)
+    Bit29 = Int 17h, Printer Services are supported - 0 (No)
+    Bit30 = Int 10h, CGA/Mono Video Services are supported - 1 (Yes)
+    Bit31 = NEC PC-98 - 0 (No)
+
+    */
+
+    t->bios_characteristics_extension_bytes[0] = 0x03; /*
+
+    Table 8 â€“ Firmware Characteristics Extension Byte 1
+    https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A244%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C720%2C0%5D
+
+    Hex    = 0x03
+    Binary = 0b00000011
+
+    Bit0 = ACPI supported - 1 (Yes)
+    Bit1 = USB Legacy is supported - 1 (Yes)
+    Bit2 = AGP is supported - 0 (No)
+    Bit3 = I2O boot is supported - 0 (No)
+    Bit4 = LS-120 boot is supported - 0 (No)
+    Bit5 = ATAPI ZIP Drive boot is supported - 0 (No)
+    Bit6 = 1394 boot is supported - 0 (No)
+    Bit7 = Smart Battery supported - 0 (No)
+
+    */
+
+    t->bios_characteristics_extension_bytes[1] = 0x0D; /*  */
     if (smbios_type0.uefi) {
-        t->bios_characteristics_extension_bytes[1] |= 0x08; /* |= UEFI */
-    }
+        t->bios_characteristics_extension_bytes[1] |= 0x0D; /* |= UEFI */
+    } /*
+
+    Table 9 â€“ Firmware Characteristics Extension Byte 2
+    https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A244%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C483%2C0%5D
+
+    Hex    = 0x0D
+    Binary = 0b00001101
+
+    Bit0 = BIOS Boot Specification supported - 1 (Yes)
+    Bit1 = Function key-initiated Network Service boot supported - 0 (No)
+    Bit2 = Enable Targeted Content Distribution - 1 (Yes)
+    Bit3 = UEFI Specification is supported - 1 (Yes)
+    Bit4 = SMBIOS table describes a virtual machine - 0 (No)
+
+    */
 
     if (smbios_type0.have_major_minor) {
         t->system_bios_major_release = smbios_type0.major;
@@ -634,9 +708,9 @@ static void smbios_build_type_2_table(void)
     SMBIOS_TABLE_SET_STR(2, version_str, type2.version);
     SMBIOS_TABLE_SET_STR(2, serial_number_str, type2.serial);
     SMBIOS_TABLE_SET_STR(2, asset_tag_number_str, type2.asset);
-    t->feature_flags = 0x01; /* Motherboard */
+    t->feature_flags = 0x09; /* Motherboard */
     SMBIOS_TABLE_SET_STR(2, location_str, type2.location);
-    t->chassis_handle = cpu_to_le16(0x300); /* Type 3 (System enclosure) */
+    t->chassis_handle = cpu_to_le16(0x0003); /* Type 3 (System enclosure) */
     t->board_type = 0x0A; /* Motherboard */
     t->contained_element_count = 0;
 
@@ -666,7 +740,7 @@ static void smbios_build_type_3_table(void)
     SMBIOS_BUILD_TABLE_POST;
 }
 
-static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
+static void smbios_build_type_4_table(MachineState *ms, unsigned instance, unsigned socket_count,
                                       SmbiosEntryPointType ep_type,
                                       Error **errp)
 {
@@ -682,10 +756,13 @@ static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
     SMBIOS_BUILD_TABLE_PRE_SIZE(4, T4_BASE + instance,
                                 true, tbl_len); /* required */
 
-    snprintf(sock_str, sizeof(sock_str), "%s%2x", type4.sock_pfx, instance);
+    if (socket_count > 1)
+        snprintf(sock_str, sizeof(sock_str), "%s%2x", type4.sock_pfx, instance);
+    else
+        snprintf(sock_str, sizeof(sock_str), "%s", type4.sock_pfx);
     SMBIOS_TABLE_SET_STR(4, socket_designation_str, sock_str);
-    t->processor_type = 0x03; /* CPU */
-    t->processor_family = 0xfe; /* use Processor Family 2 field */
+    t->processor_type = 0x03; /* Central Processor */
+    t->processor_family = 0xCB; /* AMD Ryzen 5 processor */
     SMBIOS_TABLE_SET_STR(4, processor_manufacturer_str, type4.manufacturer);
     if (type4.processor_id == 0) {
         t->processor_id[0] = cpu_to_le32(smbios_cpuid_version);
@@ -695,15 +772,15 @@ static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
         t->processor_id[1] = cpu_to_le32(type4.processor_id >> 32);
     }
     SMBIOS_TABLE_SET_STR(4, processor_version_str, type4.version);
-    t->voltage = 0;
-    t->external_clock = cpu_to_le16(0); /* Unknown */
+    t->voltage = 0x8B; // Bit 7 is set for modern cpus, the last bits indicate the current cpu voltage * 10.
+    t->external_clock = cpu_to_le16(0x0064); /* Unknown */
     t->max_speed = cpu_to_le16(type4.max_speed);
     t->current_speed = cpu_to_le16(type4.current_speed);
     t->status = 0x41; /* Socket populated, CPU enabled */
-    t->processor_upgrade = 0x01; /* Other */
-    t->l1_cache_handle = cpu_to_le16(0xFFFF); /* N/A */
-    t->l2_cache_handle = cpu_to_le16(0xFFFF); /* N/A */
-    t->l3_cache_handle = cpu_to_le16(0xFFFF); /* N/A */
+    t->processor_upgrade = 0x31; /* 0x31 = AM4 Socket | 0x49 = AM5 Socket | https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A305%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C318%2C0%5D */
+    t->l1_cache_handle = cpu_to_le16(0x0014); /* N/A */
+    t->l2_cache_handle = cpu_to_le16(0x0015); /* N/A */
+    t->l3_cache_handle = cpu_to_le16(0x0016); /* N/A */
     SMBIOS_TABLE_SET_STR(4, serial_number_str, type4.serial);
     SMBIOS_TABLE_SET_STR(4, asset_tag_number_str, type4.asset);
     SMBIOS_TABLE_SET_STR(4, part_number_str, type4.part);
@@ -716,8 +793,27 @@ static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
 
     t->thread_count = (threads_per_socket > 255) ? 0xFF : threads_per_socket;
 
-    t->processor_characteristics = cpu_to_le16(0x02); /* Unknown */
-    t->processor_family2 = cpu_to_le16(type4.processor_family);
+    t->processor_characteristics = cpu_to_le16(0x00FC); /*
+
+    Table 27 â€“ Processor Characteristics
+    https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A315%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C214%2C0%5D
+
+    Hex    = 0x00FC
+    Binary = 0b0000000011111100
+
+    Bit1 = Unknown - 0 (No)
+    Bit2 = 64-bit Capable - 1 (Yes)
+    Bit3 = Multi-Core - 1 (Yes)
+    Bit4 = Hardware Thread - 1 (Yes)
+    Bit5 = Execute Protection - 1 (Yes)
+    Bit6 = Enhanced Virtualization - 1 (Yes)
+    Bit7 = Power/Performance Control - 1 (Yes)
+
+    */
+
+    t->processor_family2 = cpu_to_le16(0x006B); /* AMD Zen Processor Family */
+    if (type4.processor_family != 0x01)
+        t->processor_family2 = cpu_to_le16(type4.processor_family);
 
     if (tbl_len == SMBIOS_TYPE_4_LEN_V30) {
         t->core_count2 = t->core_enabled2 = cpu_to_le16(cores_per_socket);
@@ -838,15 +934,15 @@ static void smbios_build_type_11_table(void)
 
 #define MAX_T16_STD_SZ 0x80000000 /* 2T in Kilobytes */
 
-static void smbios_build_type_16_table(unsigned dimm_cnt)
+static void smbios_build_type_16_table_with_slots(unsigned dimm_cnt, unsigned slot_cnt)
 {
     uint64_t size_kb;
 
     SMBIOS_BUILD_TABLE_PRE(16, T16_BASE, true); /* required */
 
-    t->location = 0x01; /* Other */
+    t->location = 0x03; /* System Board/Motherboard */
     t->use = 0x03; /* System memory */
-    t->error_correction = 0x06; /* Multi-bit ECC (for Microsoft, per SeaBIOS) */
+    t->error_correction = 0x03; /* Multi-bit ECC (for Microsoft, per SeaBIOS) */
     size_kb = QEMU_ALIGN_UP(current_machine->ram_size, KiB) / KiB;
     if (size_kb < MAX_T16_STD_SZ) {
         t->maximum_capacity = cpu_to_le32(size_kb);
@@ -856,7 +952,10 @@ static void smbios_build_type_16_table(unsigned dimm_cnt)
         t->extended_maximum_capacity = cpu_to_le64(current_machine->ram_size);
     }
     t->memory_error_information_handle = cpu_to_le16(0xFFFE); /* Not provided */
-    t->number_of_memory_devices = cpu_to_le16(dimm_cnt);
+    if (dimm_cnt > slot_cnt)
+        t->number_of_memory_devices = cpu_to_le16(dimm_cnt);
+    else
+        t->number_of_memory_devices = cpu_to_le16(slot_cnt);
 
     SMBIOS_BUILD_TABLE_POST;
 }
@@ -864,7 +963,7 @@ static void smbios_build_type_16_table(unsigned dimm_cnt)
 #define MAX_T17_STD_SZ 0x7FFF /* (32G - 1M), in Megabytes */
 #define MAX_T17_EXT_SZ 0x80000000 /* 2P, in Megabytes */
 
-static void smbios_build_type_17_table(unsigned instance, uint64_t size)
+static void smbios_build_type_17_table_empty(unsigned instance, uint64_t size)
 {
     char loc_str[128];
     uint64_t size_mb;
@@ -873,8 +972,8 @@ static void smbios_build_type_17_table(unsigned instance, uint64_t size)
 
     t->physical_memory_array_handle = cpu_to_le16(0x1000); /* Type 16 above */
     t->memory_error_information_handle = cpu_to_le16(0xFFFE); /* Not provided */
-    t->total_width = cpu_to_le16(0xFFFF); /* Unknown */
-    t->data_width = cpu_to_le16(0xFFFF); /* Unknown */
+    t->total_width = cpu_to_le16(0x0040); // No ECC 64-bit
+    t->data_width = cpu_to_le16(0x0040); // No ECC 64-bit
     size_mb = QEMU_ALIGN_UP(size, MiB) / MiB;
     if (size_mb < MAX_T17_STD_SZ) {
         t->size = cpu_to_le16(size_mb);
@@ -884,23 +983,47 @@ static void smbios_build_type_17_table(unsigned instance, uint64_t size)
         t->size = cpu_to_le16(MAX_T17_STD_SZ);
         t->extended_size = cpu_to_le32(size_mb);
     }
-    t->form_factor = 0x09; /* DIMM */
+    t->form_factor = 0x09; /* DIMM and 0x0D for SODIMM */
     t->device_set = 0; /* Not in a set */
     snprintf(loc_str, sizeof(loc_str), "%s %d", type17.loc_pfx, instance);
     SMBIOS_TABLE_SET_STR(17, device_locator_str, loc_str);
     SMBIOS_TABLE_SET_STR(17, bank_locator_str, type17.bank);
-    t->memory_type = 0x07; /* RAM */
-    t->type_detail = cpu_to_le16(0x02); /* Other */
+    t->memory_type = 0x22; /* RAM */
+    t->type_detail = cpu_to_le16(0x0080); /*
+
+    Table 78 â€“ Memory Device: Type Detail field
+    https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A448%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C318%2C0%5D
+
+    Hex    = 0x0080
+    Binary = 0b0000000010000000
+
+    Bit0  = Reserved - 0 (No)
+    Bit1  = Other - 0 (No)
+    Bit2  = Unknown - 0 (No)
+    Bit3  = Fast-paged - 0 (No)
+    Bit4  = Static column - 0 (No)
+    Bit5  = Pseudo-static - 0 (No)
+    Bit6  = RAMBUS - 0 (No)
+    Bit7  = Synchronous - 1 (Yes)
+    Bit8  = CMOS - 0 (No)
+    Bit9  = EDO - 0 (No)
+    Bit10 = Window DRAM - 0 (No)
+    Bit11 = Cache DRAM - 0 (No)
+    Bit12 = Non-volatile - 0 (No)
+
+    */
     t->speed = cpu_to_le16(type17.speed);
     SMBIOS_TABLE_SET_STR(17, manufacturer_str, type17.manufacturer);
     SMBIOS_TABLE_SET_STR(17, serial_number_str, type17.serial);
     SMBIOS_TABLE_SET_STR(17, asset_tag_number_str, type17.asset);
     SMBIOS_TABLE_SET_STR(17, part_number_str, type17.part);
-    t->attributes = 0; /* Unknown */
+    t->attributes = 0x01; /* SINGLE RANK MODULE */
     t->configured_clock_speed = t->speed; /* reuse value for max speed */
-    t->minimum_voltage = cpu_to_le16(0); /* Unknown */
-    t->maximum_voltage = cpu_to_le16(0); /* Unknown */
-    t->configured_voltage = cpu_to_le16(0); /* Unknown */
+    // DDR4 Voltage, in mV
+    t->minimum_voltage = cpu_to_le16(1200); /* 1.2V Minimum Voltage Per DDR4 Spec */
+    t->maximum_voltage = cpu_to_le16(1500); /* 1.5V Minimum Voltage Per DDR4 Spec */
+    // 1.35V = typical XMP, 1.2V = JEDEC
+    t->configured_voltage = cpu_to_le16(1350); /* 1.35V XMP DDR4 Voltage */
 
     SMBIOS_BUILD_TABLE_POST;
 }
@@ -1017,8 +1140,9 @@ void smbios_set_default_processor_family(uint16_t processor_family)
 void smbios_set_defaults(const char *manufacturer, const char *product,
                          const char *version)
 {
-    smbios_have_defaults = true;
+    smbios_have_defaults = false;
 
+    /*
     SMBIOS_SET_DEFAULT(smbios_type1.manufacturer, manufacturer);
     SMBIOS_SET_DEFAULT(smbios_type1.product, product);
     SMBIOS_SET_DEFAULT(smbios_type1.version, version);
@@ -1032,6 +1156,7 @@ void smbios_set_defaults(const char *manufacturer, const char *product,
     SMBIOS_SET_DEFAULT(type4.version, version);
     SMBIOS_SET_DEFAULT(type17.loc_pfx, "DIMM");
     SMBIOS_SET_DEFAULT(type17.manufacturer, manufacturer);
+    */
 }
 
 static void smbios_entry_point_setup(SmbiosEntryPointType ep_type)
@@ -1093,7 +1218,7 @@ static bool smbios_get_tables_ep(MachineState *ms,
                        uint8_t **anchor, size_t *anchor_len,
                        Error **errp)
 {
-    unsigned i, dimm_cnt, offset;
+    unsigned i, dimm_cnt, offset, slot_cnt;
     MachineClass *mc = MACHINE_GET_CLASS(ms);
     ERRP_GUARD();
 
@@ -1115,7 +1240,7 @@ static bool smbios_get_tables_ep(MachineState *ms,
     assert(ms->smp.sockets >= 1);
 
     for (i = 0; i < ms->smp.sockets; i++) {
-        smbios_build_type_4_table(ms, i, ep_type, errp);
+        smbios_build_type_4_table(ms, i,ms->smp.sockets, ep_type, errp);
         if (*errp) {
             goto err_exit;
         }
@@ -1131,6 +1256,7 @@ static bool smbios_get_tables_ep(MachineState *ms,
     dimm_cnt = QEMU_ALIGN_UP(current_machine->ram_size,
                              mc->smbios_memory_device_size) /
                mc->smbios_memory_device_size;
+    slot_cnt = 4;
 
     /*
      * The offset determines if we need to keep additional space between
@@ -1139,13 +1265,25 @@ static bool smbios_get_tables_ep(MachineState *ms,
      * memory and DIMM like chunks of 16 GiB, the default space between
      * the two tables (T19_BASE - T17_BASE = 512) is not enough.
      */
-    offset = (dimm_cnt > (T19_BASE - T17_BASE)) ? \
-             dimm_cnt - (T19_BASE - T17_BASE) : 0;
+    if (dimm_cnt > slot_cnt) {
+        offset = (dimm_cnt > (T19_BASE - T17_BASE)) ?
+        dimm_cnt - (T19_BASE - T17_BASE) : 0;
+    } else {
+        offset = (slot_cnt > (T19_BASE - T17_BASE)) ?
+        slot_cnt - (T19_BASE - T17_BASE) : 0;
+    }
 
-    smbios_build_type_16_table(dimm_cnt);
+    smbios_build_type_16_table_with_slots(dimm_cnt, slot_cnt);
 
     for (i = 0; i < dimm_cnt; i++) {
-        smbios_build_type_17_table(i, GET_DIMM_SZ);
+        smbios_build_type_17_table_empty(i, GET_DIMM_SZ);
+    }
+
+    // Add empty slots...
+    if (slot_cnt > dimm_cnt) {
+        for (i = dimm_cnt; i < slot_cnt; i++) {
+            smbios_build_type_17_table_empty(i, GET_DIMM_SZ);
+        }
     }
 
     for (i = 0; i < mem_array_size; i++) {
diff --git a/hw/ufs/lu.c b/hw/ufs/lu.c
index 2d8ffd72c5..e0d2a92cc1 100644
--- a/hw/ufs/lu.c
+++ b/hw/ufs/lu.c
@@ -184,8 +184,8 @@ static int ufs_emulate_wlun_inquiry(UfsRequest *req, uint8_t *outbuf,
     outbuf[5] = 0;
     outbuf[6] = 0;
     outbuf[7] = 0x2;
-    strpadcpy((char *)&outbuf[8], 8, "QEMU", ' ');
-    strpadcpy((char *)&outbuf[16], 16, "QEMU UFS", ' ');
+    strpadcpy((char *)&outbuf[8], 8, "MSI", ' ');
+    strpadcpy((char *)&outbuf[16], 16, "UFS", ' ');
     memset(&outbuf[32], 0, 4);
 
     return SCSI_INQUIRY_LEN;
diff --git a/hw/usb/canokey.c b/hw/usb/canokey.c
index cbefbb5daf..1998dd084c 100644
--- a/hw/usb/canokey.c
+++ b/hw/usb/canokey.c
@@ -35,8 +35,8 @@ enum {
 
 static const USBDescStrings desc_strings = {
     [STR_MANUFACTURER]     = "canokeys.org",
-    [STR_PRODUCT]          = "CanoKey QEMU",
-    [STR_SERIALNUMBER]     = "0"
+    [STR_PRODUCT]          = "CanoKey",
+    [STR_SERIALNUMBER]     = "ORPEIJ8LEZ"
 };
 
 static const USBDescDevice desc_device_canokey = {
diff --git a/hw/usb/dev-audio.c b/hw/usb/dev-audio.c
index 26af709f31..3c281ad8a4 100644
--- a/hw/usb/dev-audio.c
+++ b/hw/usb/dev-audio.c
@@ -73,9 +73,9 @@ enum usb_audio_strings {
 };
 
 static const USBDescStrings usb_audio_stringtable = {
-    [STRING_MANUFACTURER]       = "QEMU",
-    [STRING_PRODUCT]            = "QEMU USB Audio",
-    [STRING_SERIALNUMBER]       = "1",
+    [STRING_MANUFACTURER]       = "Logitech",
+    [STRING_PRODUCT]            = "USB Audio",
+    [STRING_SERIALNUMBER]       = "SCNU3K6LPU",
     [STRING_CONFIG]             = "Audio Configuration",
     [STRING_USBAUDIO_CONTROL]   = "Audio Device",
     [STRING_INPUT_TERMINAL]     = "Audio Output Pipe",
diff --git a/hw/usb/dev-hid.c b/hw/usb/dev-hid.c
index 96623aa322..4dbf89f533 100644
--- a/hw/usb/dev-hid.c
+++ b/hw/usb/dev-hid.c
@@ -63,17 +63,17 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
-    [STR_PRODUCT_MOUSE]    = "QEMU USB Mouse",
-    [STR_PRODUCT_TABLET]   = "QEMU USB Tablet",
-    [STR_PRODUCT_KEYBOARD] = "QEMU USB Keyboard",
-    [STR_SERIAL_COMPAT]    = "42",
+    [STR_MANUFACTURER]     = "Logitech",
+    [STR_PRODUCT_MOUSE]    = "USB Mouse",
+    [STR_PRODUCT_TABLET]   = "USB Tablet",
+    [STR_PRODUCT_KEYBOARD] = "USB Keyboard",
+    [STR_SERIAL_COMPAT]    = "N76POILMPP",
     [STR_CONFIG_MOUSE]     = "HID Mouse",
     [STR_CONFIG_TABLET]    = "HID Tablet",
     [STR_CONFIG_KEYBOARD]  = "HID Keyboard",
-    [STR_SERIAL_MOUSE]     = "89126",
-    [STR_SERIAL_TABLET]    = "28754",
-    [STR_SERIAL_KEYBOARD]  = "68284",
+    [STR_SERIAL_MOUSE]     = "1F6IT6W2IF",
+    [STR_SERIAL_TABLET]    = "WSS5T9RFVE",
+    [STR_SERIAL_KEYBOARD]  = "V96SH0F8ZX",
 };
 
 static const USBDescIface desc_iface_mouse = {
@@ -368,7 +368,7 @@ static const USBDescMSOS desc_msos_suspend = {
 
 static const USBDesc desc_mouse = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -382,7 +382,7 @@ static const USBDesc desc_mouse = {
 
 static const USBDesc desc_mouse2 = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -397,7 +397,7 @@ static const USBDesc desc_mouse2 = {
 
 static const USBDesc desc_tablet = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -411,7 +411,7 @@ static const USBDesc desc_tablet = {
 
 static const USBDesc desc_tablet2 = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -426,7 +426,7 @@ static const USBDesc desc_tablet2 = {
 
 static const USBDesc desc_keyboard = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -440,7 +440,7 @@ static const USBDesc desc_keyboard = {
 
 static const USBDesc desc_keyboard2 = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -805,7 +805,7 @@ static void usb_tablet_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_tablet_realize;
-    uc->product_desc   = "QEMU USB Tablet";
+    uc->product_desc   = "USB Tablet";
     dc->vmsd = &vmstate_usb_ptr;
     device_class_set_props(dc, usb_tablet_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
@@ -827,7 +827,7 @@ static void usb_mouse_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_mouse_realize;
-    uc->product_desc   = "QEMU USB Mouse";
+    uc->product_desc   = "USB Mouse";
     dc->vmsd = &vmstate_usb_ptr;
     device_class_set_props(dc, usb_mouse_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
@@ -850,7 +850,7 @@ static void usb_keyboard_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_keyboard_realize;
-    uc->product_desc   = "QEMU USB Keyboard";
+    uc->product_desc   = "USB Keyboard";
     dc->vmsd = &vmstate_usb_kbd;
     device_class_set_props(dc, usb_keyboard_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
diff --git a/hw/usb/dev-hub.c b/hw/usb/dev-hub.c
index a19350d9c4..33aad4f248 100644
--- a/hw/usb/dev-hub.c
+++ b/hw/usb/dev-hub.c
@@ -104,9 +104,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
-    [STR_PRODUCT]      = "QEMU USB Hub",
-    [STR_SERIALNUMBER] = "314159",
+    [STR_MANUFACTURER] = "Logitech",
+    [STR_PRODUCT]      = "USB Hub",
+    [STR_SERIALNUMBER] = "EPCEFDU54X",
 };
 
 static const USBDescIface desc_iface_hub = {
@@ -676,7 +676,7 @@ static void usb_hub_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_hub_realize;
-    uc->product_desc   = "QEMU USB Hub";
+    uc->product_desc   = "USB Hub";
     uc->usb_desc       = &desc_hub;
     uc->find_device    = usb_hub_find_device;
     uc->handle_reset   = usb_hub_handle_reset;
diff --git a/hw/usb/dev-mtp.c b/hw/usb/dev-mtp.c
index ce45c9cd06..e2b1ad785a 100644
--- a/hw/usb/dev-mtp.c
+++ b/hw/usb/dev-mtp.c
@@ -247,8 +247,8 @@ OBJECT_DECLARE_SIMPLE_TYPE(MTPState, USB_MTP)
 
 /* ----------------------------------------------------------------------- */
 
-#define MTP_MANUFACTURER  "QEMU"
-#define MTP_PRODUCT       "QEMU filesharing"
+#define MTP_MANUFACTURER  "Microsoft"
+#define MTP_PRODUCT       "filesharing"
 #define MTP_WRITE_BUF_SZ  (512 * KiB)
 
 enum {
@@ -264,7 +264,7 @@ enum {
 static const USBDescStrings desc_strings = {
     [STR_MANUFACTURER] = MTP_MANUFACTURER,
     [STR_PRODUCT]      = MTP_PRODUCT,
-    [STR_SERIALNUMBER] = "34617",
+    [STR_SERIALNUMBER] = "FJFR36ZGFQ",
     [STR_MTP]          = "MTP",
     [STR_CONFIG_FULL]  = "Full speed config (usb 1.1)",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
@@ -2088,7 +2088,7 @@ static void usb_mtp_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_mtp_realize;
-    uc->product_desc   = "QEMU USB MTP";
+    uc->product_desc   = "USB MTP";
     uc->usb_desc       = &desc;
     uc->cancel_packet  = usb_mtp_cancel_packet;
     uc->handle_attach  = usb_desc_attach;
diff --git a/hw/usb/dev-network.c b/hw/usb/dev-network.c
index 1df2454181..e399a10107 100644
--- a/hw/usb/dev-network.c
+++ b/hw/usb/dev-network.c
@@ -99,16 +99,16 @@ enum usbstring_idx {
 #define ETH_FRAME_LEN                   1514 /* Max. octets in frame sans FCS */
 
 static const USBDescStrings usb_net_stringtable = {
-    [STRING_MANUFACTURER]       = "QEMU",
-    [STRING_PRODUCT]            = "RNDIS/QEMU USB Network Device",
-    [STRING_ETHADDR]            = "400102030405",
-    [STRING_DATA]               = "QEMU USB Net Data Interface",
-    [STRING_CONTROL]            = "QEMU USB Net Control Interface",
-    [STRING_RNDIS_CONTROL]      = "QEMU USB Net RNDIS Control Interface",
-    [STRING_CDC]                = "QEMU USB Net CDC",
-    [STRING_SUBSET]             = "QEMU USB Net Subset",
-    [STRING_RNDIS]              = "QEMU USB Net RNDIS",
-    [STRING_SERIALNUMBER]       = "1",
+    [STRING_MANUFACTURER]       = "Realtek",
+    [STRING_PRODUCT]            = "RNDIS/Realtek USB Network Device",
+    [STRING_ETHADDR]            = "4C82A94C9ECA",
+    [STRING_DATA]               = "USB Net Data Interface",
+    [STRING_CONTROL]            = "USB Net Control Interface",
+    [STRING_RNDIS_CONTROL]      = "USB Net RNDIS Control Interface",
+    [STRING_CDC]                = "USB Net CDC",
+    [STRING_SUBSET]             = "USB Net Subset",
+    [STRING_RNDIS]              = "USB Net RNDIS",
+    [STRING_SERIALNUMBER]       = "D9H87OLLOE",
 };
 
 static const USBDescIface desc_iface_rndis[] = {
@@ -717,7 +717,7 @@ static int ndis_query(USBNetState *s, uint32_t oid,
 
     /* mandatory */
     case OID_GEN_VENDOR_DESCRIPTION:
-        pstrcpy((char *)outbuf, outlen, "QEMU USB RNDIS Net");
+        pstrcpy((char *)outbuf, outlen, "USB RNDIS Net");
         return strlen((char *)outbuf) + 1;
 
     case OID_GEN_VENDOR_DRIVER_VERSION:
@@ -1417,7 +1417,7 @@ static void usb_net_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_net_realize;
-    uc->product_desc   = "QEMU USB Network Interface";
+    uc->product_desc   = "USB Network Interface";
     uc->usb_desc       = &desc_net;
     uc->handle_reset   = usb_net_handle_reset;
     uc->handle_control = usb_net_handle_control;
diff --git a/hw/usb/dev-serial.c b/hw/usb/dev-serial.c
index 1c116d8b0f..358c7452a2 100644
--- a/hw/usb/dev-serial.c
+++ b/hw/usb/dev-serial.c
@@ -119,10 +119,10 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]    = "QEMU",
-    [STR_PRODUCT_SERIAL]  = "QEMU USB SERIAL",
-    [STR_PRODUCT_BRAILLE] = "QEMU USB BAUM BRAILLE",
-    [STR_SERIALNUMBER]    = "1",
+    [STR_MANUFACTURER]    = "Microsoft",
+    [STR_PRODUCT_SERIAL]  = "USB SERIAL",
+    [STR_PRODUCT_BRAILLE] = "USB BAUM BRAILLE",
+    [STR_SERIALNUMBER]    = "6KCP6OG5KL",
 };
 
 static const USBDescIface desc_iface0 = {
@@ -663,7 +663,7 @@ static void usb_serial_class_initfn(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB Serial";
+    uc->product_desc   = "USB Serial";
     uc->usb_desc       = &desc_serial;
     device_class_set_props(dc, serial_properties);
 }
@@ -683,7 +683,7 @@ static void usb_braille_class_initfn(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB Braille";
+    uc->product_desc   = "USB Braille";
     uc->usb_desc       = &desc_braille;
     device_class_set_props(dc, braille_properties);
 }
diff --git a/hw/usb/dev-smartcard-reader.c b/hw/usb/dev-smartcard-reader.c
index 6ce7154fee..b02d281cf8 100644
--- a/hw/usb/dev-smartcard-reader.c
+++ b/hw/usb/dev-smartcard-reader.c
@@ -80,8 +80,8 @@ OBJECT_DECLARE_SIMPLE_TYPE(USBCCIDState, USB_CCID_DEV)
 #define CCID_CONTROL_GET_CLOCK_FREQUENCIES  0x2
 #define CCID_CONTROL_GET_DATA_RATES         0x3
 
-#define CCID_PRODUCT_DESCRIPTION        "QEMU USB CCID"
-#define CCID_VENDOR_DESCRIPTION         "QEMU"
+#define CCID_PRODUCT_DESCRIPTION        "USB CCID"
+#define CCID_VENDOR_DESCRIPTION         "Identiv"
 #define CCID_INTERFACE_NAME             "CCID Interface"
 #define CCID_SERIAL_NUMBER_STRING       "1"
 /*
@@ -419,9 +419,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]  = "QEMU",
-    [STR_PRODUCT]       = "QEMU USB CCID",
-    [STR_SERIALNUMBER]  = "1",
+    [STR_MANUFACTURER]  = "Identiv",
+    [STR_PRODUCT]       = "USB CCID",
+    [STR_SERIALNUMBER]  = "L9Z3ZM8CDP",
     [STR_INTERFACE]     = "CCID Interface",
 };
 
@@ -1440,7 +1440,7 @@ static void ccid_class_initfn(ObjectClass *klass, const void *data)
     HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(klass);
 
     uc->realize        = ccid_realize;
-    uc->product_desc   = "QEMU USB CCID";
+    uc->product_desc   = "USB CCID";
     uc->usb_desc       = &desc_ccid;
     uc->handle_reset   = ccid_handle_reset;
     uc->handle_control = ccid_handle_control;
diff --git a/hw/usb/dev-storage.c b/hw/usb/dev-storage.c
index b13fe345c4..7680beed35 100644
--- a/hw/usb/dev-storage.c
+++ b/hw/usb/dev-storage.c
@@ -47,9 +47,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
-    [STR_PRODUCT]      = "QEMU USB HARDDRIVE",
-    [STR_SERIALNUMBER] = "1",
+    [STR_MANUFACTURER] = "Samsung",
+    [STR_PRODUCT]      = "USB HARDDRIVE",
+    [STR_SERIALNUMBER] = "HLN8ILM0SH",
     [STR_CONFIG_FULL]  = "Full speed config (usb 1.1)",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
     [STR_CONFIG_SUPER] = "Super speed config (usb 3.0)",
@@ -590,7 +590,7 @@ static void usb_msd_class_initfn_common(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB MSD";
+    uc->product_desc   = "USB MSD";
     uc->usb_desc       = &desc;
     uc->cancel_packet  = usb_msd_cancel_io;
     uc->handle_attach  = usb_desc_attach;
diff --git a/hw/usb/dev-uas.c b/hw/usb/dev-uas.c
index 21cc2835c6..d14a078d8b 100644
--- a/hw/usb/dev-uas.c
+++ b/hw/usb/dev-uas.c
@@ -171,9 +171,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
+    [STR_MANUFACTURER] = "Microsoft",
     [STR_PRODUCT]      = "USB Attached SCSI HBA",
-    [STR_SERIALNUMBER] = "27842",
+    [STR_SERIALNUMBER] = "E5DEMH2Y7X",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
     [STR_CONFIG_SUPER] = "Super speed config (usb 3.0)",
 };
diff --git a/hw/usb/dev-wacom.c b/hw/usb/dev-wacom.c
index f4b71a2147..ff724ddca5 100644
--- a/hw/usb/dev-wacom.c
+++ b/hw/usb/dev-wacom.c
@@ -64,9 +64,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
+    [STR_MANUFACTURER]     = "Wacom",
     [STR_PRODUCT]          = "Wacom PenPartner",
-    [STR_SERIALNUMBER]     = "1",
+    [STR_SERIALNUMBER]     = "718H83W0T4",
 };
 
 static const uint8_t qemu_wacom_hid_report_descriptor[] = {
@@ -231,7 +231,7 @@ static int usb_mouse_poll(USBWacomState *s, uint8_t *buf, int len)
 
     if (!s->mouse_grabbed) {
         s->eh_entry = qemu_add_mouse_event_handler(usb_mouse_event, s, 0,
-                        "QEMU PenPartner tablet");
+                        "PenPartner tablet");
         qemu_activate_mouse_event_handler(s->eh_entry);
         s->mouse_grabbed = 1;
     }
@@ -269,7 +269,7 @@ static int usb_wacom_poll(USBWacomState *s, uint8_t *buf, int len)
 
     if (!s->mouse_grabbed) {
         s->eh_entry = qemu_add_mouse_event_handler(usb_wacom_event, s, 1,
-                        "QEMU PenPartner tablet");
+                        "PenPartner tablet");
         qemu_activate_mouse_event_handler(s->eh_entry);
         s->mouse_grabbed = 1;
     }
@@ -425,7 +425,7 @@ static void usb_wacom_class_init(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU PenPartner Tablet";
+    uc->product_desc   = "PenPartner Tablet";
     uc->usb_desc       = &desc_wacom;
     uc->realize        = usb_wacom_realize;
     uc->handle_reset   = usb_wacom_handle_reset;
@@ -433,7 +433,7 @@ static void usb_wacom_class_init(ObjectClass *klass, const void *data)
     uc->handle_data    = usb_wacom_handle_data;
     uc->unrealize      = usb_wacom_unrealize;
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
-    dc->desc = "QEMU PenPartner Tablet";
+    dc->desc = "PenPartner Tablet";
     dc->vmsd = &vmstate_usb_wacom;
 }
 
diff --git a/hw/usb/u2f-emulated.c b/hw/usb/u2f-emulated.c
index ace5eceadd..8cb276ac79 100644
--- a/hw/usb/u2f-emulated.c
+++ b/hw/usb/u2f-emulated.c
@@ -385,7 +385,7 @@ static void u2f_emulated_class_init(ObjectClass *klass, const void *data)
     kc->realize = u2f_emulated_realize;
     kc->unrealize = u2f_emulated_unrealize;
     kc->recv_from_guest = u2f_emulated_recv_from_guest;
-    dc->desc = "QEMU U2F emulated key";
+    dc->desc = "U2F emulated key";
     device_class_set_props(dc, u2f_emulated_properties);
 }
 
diff --git a/hw/usb/u2f-passthru.c b/hw/usb/u2f-passthru.c
index fa8d9cdda8..cd4d4517e7 100644
--- a/hw/usb/u2f-passthru.c
+++ b/hw/usb/u2f-passthru.c
@@ -528,7 +528,7 @@ static void u2f_passthru_class_init(ObjectClass *klass, const void *data)
     kc->realize = u2f_passthru_realize;
     kc->unrealize = u2f_passthru_unrealize;
     kc->recv_from_guest = u2f_passthru_recv_from_guest;
-    dc->desc = "QEMU U2F passthrough key";
+    dc->desc = "U2F passthrough key";
     dc->vmsd = &u2f_passthru_vmstate;
     device_class_set_props(dc, u2f_passthru_properties);
     set_bit(DEVICE_CATEGORY_MISC, dc->categories);
diff --git a/hw/usb/u2f.c b/hw/usb/u2f.c
index b051a999d3..a6c48cdac9 100644
--- a/hw/usb/u2f.c
+++ b/hw/usb/u2f.c
@@ -46,9 +46,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
+    [STR_MANUFACTURER]     = "Microsoft",
     [STR_PRODUCT]          = "U2F USB key",
-    [STR_SERIALNUMBER]     = "0",
+    [STR_SERIALNUMBER]     = "JFX4J5OICR",
     [STR_CONFIG]           = "U2F key config",
     [STR_INTERFACE]        = "U2F key interface"
 };
@@ -322,7 +322,7 @@ static void u2f_key_class_init(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU U2F USB key";
+    uc->product_desc   = "U2F USB key";
     uc->usb_desc       = &desc_u2f_key;
     uc->handle_reset   = u2f_key_handle_reset;
     uc->handle_control = u2f_key_handle_control;
@@ -330,7 +330,7 @@ static void u2f_key_class_init(ObjectClass *klass, const void *data)
     uc->handle_attach  = usb_desc_attach;
     uc->realize        = u2f_key_realize;
     uc->unrealize      = u2f_key_unrealize;
-    dc->desc           = "QEMU U2F key";
+    dc->desc           = "U2F key";
     dc->vmsd           = &vmstate_u2f_key;
 }
 
diff --git a/hw/vfio/ap.c b/hw/vfio/ap.c
index 7719f24579..d0306c5e1a 100644
--- a/hw/vfio/ap.c
+++ b/hw/vfio/ap.c
@@ -341,7 +341,7 @@ static void vfio_ap_class_init(ObjectClass *klass, const void *data)
     set_bit(DEVICE_CATEGORY_MISC, dc->categories);
     dc->realize = vfio_ap_realize;
     dc->unrealize = vfio_ap_unrealize;
-    dc->hotpluggable = true;
+    dc->hotpluggable = false;
     device_class_set_legacy_reset(dc, vfio_ap_reset);
     dc->bus_type = TYPE_AP_BUS;
 
diff --git a/include/hw/acpi/aml-build.h b/include/hw/acpi/aml-build.h
index c18f681342..e3656c173a 100644
--- a/include/hw/acpi/aml-build.h
+++ b/include/hw/acpi/aml-build.h
@@ -4,8 +4,8 @@
 #include "hw/acpi/acpi-defs.h"
 #include "hw/acpi/bios-linker-loader.h"
 
-#define ACPI_BUILD_APPNAME6 "BOCHS "
-#define ACPI_BUILD_APPNAME8 "BXPC    "
+#define ACPI_BUILD_APPNAME6 "ALASKA"
+#define ACPI_BUILD_APPNAME8 "A M I   "
 
 #define ACPI_BUILD_TABLE_FILE "etc/acpi/tables"
 #define ACPI_BUILD_RSDP_FILE "etc/acpi/rsdp"
diff --git a/include/hw/pci/pci.h b/include/hw/pci/pci.h
index 6b7d3ac8a3..599c70e7e0 100644
--- a/include/hw/pci/pci.h
+++ b/include/hw/pci/pci.h
@@ -57,7 +57,7 @@ extern bool pci_available;
 #define PCI_DEVICE_ID_MARVELL_GT6412X    0x4620
 
 /* QEMU/Bochs VGA (0x1234) */
-#define PCI_VENDOR_ID_QEMU               0x1234
+#define PCI_VENDOR_ID_QEMU               0x1022 // "???" | AMD Vendor ID Replacement from 0x1234
 #define PCI_DEVICE_ID_QEMU_VGA           0x1111
 #define PCI_DEVICE_ID_QEMU_IPMI          0x1112
 
@@ -74,12 +74,12 @@ extern bool pci_available;
 /* Intel (0x8086) */
 #define PCI_DEVICE_ID_INTEL_82551IT      0x1209
 #define PCI_DEVICE_ID_INTEL_82557        0x1229
-#define PCI_DEVICE_ID_INTEL_82801IR      0x2922
+#define PCI_DEVICE_ID_INTEL_82801IR      0x790e // Intel 82801IR ICH9 - LPC Bridge [A2] | AMD Device ID Replacement from 0x2922 | hw/ide/ich.c
 
 /* Red Hat / Qumranet (for QEMU) -- see pci-ids.txt */
-#define PCI_VENDOR_ID_REDHAT_QUMRANET    0x1af4
-#define PCI_SUBVENDOR_ID_REDHAT_QUMRANET 0x1af4
-#define PCI_SUBDEVICE_ID_QEMU            0x1100
+#define PCI_VENDOR_ID_REDHAT_QUMRANET    0x1022 // AMD Vendor ID Replacement from 0x1af4
+#define PCI_SUBVENDOR_ID_REDHAT_QUMRANET 0x1022 // AMD Subvendor ID Replacement from 0x1af4
+#define PCI_SUBDEVICE_ID_QEMU            0x1022 // AMD Subdevice ID Replacement from 0x1100
 
 /* legacy virtio-pci devices */
 #define PCI_DEVICE_ID_VIRTIO_NET         0x1000
@@ -100,21 +100,21 @@ extern bool pci_available;
  */
 #define PCI_DEVICE_ID_VIRTIO_10_BASE     0x1040
 
-#define PCI_VENDOR_ID_REDHAT             0x1b36
-#define PCI_DEVICE_ID_REDHAT_BRIDGE      0x0001
-#define PCI_DEVICE_ID_REDHAT_SERIAL      0x0002
+#define PCI_VENDOR_ID_REDHAT             0x1022 // "Red Hat, Inc." | AMD Vendor ID Replacement from 0x1b36
+#define PCI_DEVICE_ID_REDHAT_BRIDGE      0x57a3 // "QEMU PCI-PCI bridge" | AMD Device ID Replacement from 0x0001 | hw/pci-bridge/pci_bridge_dev.c
+#define PCI_DEVICE_ID_REDHAT_SERIAL      0x0002 // TODO: find device_id | AMD Device ID Replacement from 0x???? | hw/char/serial-pci.c
 #define PCI_DEVICE_ID_REDHAT_SERIAL2     0x0003
 #define PCI_DEVICE_ID_REDHAT_SERIAL4     0x0004
 #define PCI_DEVICE_ID_REDHAT_TEST        0x0005
 #define PCI_DEVICE_ID_REDHAT_ROCKER      0x0006
 #define PCI_DEVICE_ID_REDHAT_SDHCI       0x0007
-#define PCI_DEVICE_ID_REDHAT_PCIE_HOST   0x0008
+#define PCI_DEVICE_ID_REDHAT_PCIE_HOST   0x1482 // "QEMU PCIe Host bridge" | AMD Device ID Replacement from 0x0008 | hw/pci-host/gpex.c
 #define PCI_DEVICE_ID_REDHAT_PXB         0x0009
 #define PCI_DEVICE_ID_REDHAT_BRIDGE_SEAT 0x000a
 #define PCI_DEVICE_ID_REDHAT_PXB_PCIE    0x000b
-#define PCI_DEVICE_ID_REDHAT_PCIE_RP     0x000c
-#define PCI_DEVICE_ID_REDHAT_XHCI        0x000d
-#define PCI_DEVICE_ID_REDHAT_PCIE_BRIDGE 0x000e
+#define PCI_DEVICE_ID_REDHAT_PCIE_RP     0x1483 // "QEMU PCIe Root Port" | AMD Device ID Replacement from 0x000c | hw/pci-bridge/gen_pcie_root_port.c
+#define PCI_DEVICE_ID_REDHAT_XHCI        0x149c // "QEMU XHCI Host Controller" | AMD Device ID Replacement from 0x000d | hw/usb/hcd-xhci-pci.c
+#define PCI_DEVICE_ID_REDHAT_PCIE_BRIDGE 0x57ad // "Red Hat, Device ID: 000E" | AMD Device ID Replacement from 0x000e | hw/pci-bridge/pcie_pci_bridge.c
 #define PCI_DEVICE_ID_REDHAT_MDPY        0x000f
 #define PCI_DEVICE_ID_REDHAT_NVME        0x0010
 #define PCI_DEVICE_ID_REDHAT_PVPANIC     0x0011
diff --git a/include/hw/pci/pci_ids.h b/include/hw/pci/pci_ids.h
index 33e2898be9..fb7a0a0069 100644
--- a/include/hw/pci/pci_ids.h
+++ b/include/hw/pci/pci_ids.h
@@ -178,6 +178,7 @@
 #define PCI_VENDOR_ID_AMD                0x1022
 #define PCI_DEVICE_ID_AMD_LANCE          0x2000
 #define PCI_DEVICE_ID_AMD_SCSI           0x2020
+#define PCI_DEVICE_ID_AMD_SATA           0x43f6
 
 #define PCI_VENDOR_ID_HP                 0x103c
 
@@ -237,6 +238,8 @@
 #define PCI_VENDOR_ID_BAIDU              0x1d22
 #define PCI_DEVICE_ID_KUNLUN_VF          0x3685
 
+/* https://www.pcilookup.com/ */
+
 #define PCI_VENDOR_ID_INTEL              0x8086
 #define PCI_DEVICE_ID_INTEL_82378        0x0484
 #define PCI_DEVICE_ID_INTEL_82441        0x1237
@@ -246,8 +249,8 @@
 #define PCI_DEVICE_ID_INTEL_ESB_9        0x25ab
 #define PCI_DEVICE_ID_INTEL_NVME         0x5845
 #define PCI_DEVICE_ID_INTEL_82371SB_0    0x7000
-#define PCI_DEVICE_ID_INTEL_82371SB_1    0x7010
-#define PCI_DEVICE_ID_INTEL_82371SB_2    0x7020
+#define PCI_DEVICE_ID_INTEL_82371SB_1    0x7010 // TODO: | Intel 82371SB_1 - ??? | AMD Vendor ID Replacement from 0x???? | hw/ide/piix.c
+#define PCI_DEVICE_ID_INTEL_82371SB_2    0x7020 // TODO: | Intel 82371SB_2 - ??? | AMD Vendor ID Replacement from 0x???? | hw/usb/hcd-uhci.c
 #define PCI_DEVICE_ID_INTEL_82371AB_0    0x7110
 #define PCI_DEVICE_ID_INTEL_82371AB      0x7111
 #define PCI_DEVICE_ID_INTEL_82371AB_2    0x7112
@@ -259,9 +262,9 @@
 #define PCI_DEVICE_ID_INTEL_ICH9_3       0x2913
 #define PCI_DEVICE_ID_INTEL_ICH9_4       0x2914
 #define PCI_DEVICE_ID_INTEL_ICH9_5       0x2919
-#define PCI_DEVICE_ID_INTEL_ICH9_6       0x2930
+#define PCI_DEVICE_ID_INTEL_ICH9_6       0x790b // Intel 82801IB ICH9 - SMBus Controller [A2] | AMD Vendor ID Replacement from 0x2930 | hw/i2c/smbus_ich9.c
 #define PCI_DEVICE_ID_INTEL_ICH9_7       0x2916
-#define PCI_DEVICE_ID_INTEL_ICH9_8       0x2918
+#define PCI_DEVICE_ID_INTEL_ICH9_8       0x790e // Intel 82801IR ICH9 - LPC Bridge [A2] | AMD Vendor ID Replacement from 0x2918 | hw/isa/lpc_ich9.c
 
 #define PCI_DEVICE_ID_INTEL_82801I_UHCI1 0x2934
 #define PCI_DEVICE_ID_INTEL_82801I_UHCI2 0x2935
@@ -273,7 +276,7 @@
 #define PCI_DEVICE_ID_INTEL_82801I_EHCI2 0x293c
 #define PCI_DEVICE_ID_INTEL_82599_SFP_VF 0x10ed
 
-#define PCI_DEVICE_ID_INTEL_P35_MCH      0x29c0
+#define PCI_DEVICE_ID_INTEL_P35_MCH      0x1480 // Intel G33/P35/Q35/Q33 Chipset - Memory Controller Hub [A0] | AMD Vendor ID Replacement from 0x29c0 | hw/pci-host/q35.c
 
 #define PCI_VENDOR_ID_XEN                0x5853
 #define PCI_DEVICE_ID_XEN_PLATFORM       0x0001
diff --git a/include/standard-headers/linux/qemu_fw_cfg.h b/include/standard-headers/linux/qemu_fw_cfg.h
index cb93f6678d..fe34590061 100644
--- a/include/standard-headers/linux/qemu_fw_cfg.h
+++ b/include/standard-headers/linux/qemu_fw_cfg.h
@@ -4,7 +4,7 @@
 
 #include "standard-headers/linux/types.h"
 
-#define FW_CFG_ACPI_DEVICE_ID	"QEMU0002"
+#define FW_CFG_ACPI_DEVICE_ID	"UEFI0002"
 
 /* selector key values for "well-known" fw_cfg entries */
 #define FW_CFG_SIGNATURE	0x00
@@ -71,7 +71,7 @@ struct fw_cfg_file {
 #define FW_CFG_DMA_CTL_SELECT	0x08
 #define FW_CFG_DMA_CTL_WRITE	0x10
 
-#define FW_CFG_DMA_SIGNATURE    0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE    0x51434f4d20434647ULL /* "QCOM CFG" */
 
 /* Control as first field allows for different structures selected by this
  * field, which might be useful in the future
diff --git a/migration/rdma.c b/migration/rdma.c
index 2d839fce6c..960871df9d 100644
--- a/migration/rdma.c
+++ b/migration/rdma.c
@@ -220,7 +220,7 @@ static const char *control_desc(unsigned int rdma_control)
         [RDMA_CONTROL_NONE] = "NONE",
         [RDMA_CONTROL_ERROR] = "ERROR",
         [RDMA_CONTROL_READY] = "READY",
-        [RDMA_CONTROL_QEMU_FILE] = "QEMU FILE",
+        [RDMA_CONTROL_QEMU_FILE] = "FILE",
         [RDMA_CONTROL_RAM_BLOCKS_REQUEST] = "RAM BLOCKS REQUEST",
         [RDMA_CONTROL_RAM_BLOCKS_RESULT] = "RAM BLOCKS RESULT",
         [RDMA_CONTROL_COMPRESS] = "COMPRESS",
diff --git a/pc-bios/optionrom/optionrom.h b/pc-bios/optionrom/optionrom.h
index 7bcdf0eeb2..02dd06eb3e 100644
--- a/pc-bios/optionrom/optionrom.h
+++ b/pc-bios/optionrom/optionrom.h
@@ -43,7 +43,7 @@
 #define FW_CFG_DMA_CTL_SELECT  0x08
 #define FW_CFG_DMA_CTL_WRITE   0x10
 
-#define FW_CFG_DMA_SIGNATURE 0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE 0x51434f4d20434647ULL /* "QCOM CFG" */
 
 #define BIOS_CFG_DMA_ADDR_HIGH  0x514
 #define BIOS_CFG_DMA_ADDR_LOW   0x518
diff --git a/pc-bios/s390-ccw/virtio-scsi.h b/pc-bios/s390-ccw/virtio-scsi.h
index c5612e16a2..048cb93d3d 100644
--- a/pc-bios/s390-ccw/virtio-scsi.h
+++ b/pc-bios/s390-ccw/virtio-scsi.h
@@ -25,7 +25,7 @@
 #define VIRTIO_SCSI_S_OK                     0x00
 #define VIRTIO_SCSI_S_BAD_TARGET             0x03
 
-#define QEMU_CDROM_SIGNATURE "QEMU CD-ROM     "
+#define QEMU_CDROM_SIGNATURE "ASUS CD-ROM     "
 
 enum virtio_scsi_vq_id {
     VR_CONTROL  = 0,
diff --git a/qapi/ui.json b/qapi/ui.json
index 1b2f4a4769..37f40fdeae 100644
--- a/qapi/ui.json
+++ b/qapi/ui.json
@@ -831,13 +831,13 @@
 #     -> { "execute": "query-mice" }
 #     <- { "return": [
 #              {
-#                 "name":"QEMU Microsoft Mouse",
+#                 "name":"Microsoft Mouse",
 #                 "index":0,
 #                 "current":false,
 #                 "absolute":false
 #              },
 #              {
-#                 "name":"QEMU PS/2 Mouse",
+#                 "name":"PS/2 Mouse",
 #                 "index":1,
 #                 "current":true,
 #                 "absolute":true
diff --git a/target/i386/cpu.c b/target/i386/cpu.c
index 6d85149e6e..b4a8d3e921 100644
--- a/target/i386/cpu.c
+++ b/target/i386/cpu.c
@@ -3309,7 +3309,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
         .features[FEAT_8000_0001_ECX] =
             CPUID_EXT3_LAHF_LM | CPUID_EXT3_SVM,
         .xlevel = 0x8000000A,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "AMD CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "phenom",
@@ -3438,7 +3438,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
         .features[FEAT_1_ECX] =
             CPUID_EXT_SSE3,
         .xlevel = 0x80000004,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "AMD CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "kvm32",
@@ -3468,7 +3468,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
              VMX_CPU_BASED_USE_IO_BITMAPS | VMX_CPU_BASED_MONITOR_EXITING |
              VMX_CPU_BASED_PAUSE_EXITING | VMX_CPU_BASED_USE_MSR_BITMAPS,
         .xlevel = 0x80000008,
-        .model_id = "Common 32-bit KVM processor"
+        .model_id = "Common 32-bit AMD processor"
     },
     {
         .name = "coreduo",
@@ -3568,7 +3568,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
         .features[FEAT_8000_0001_EDX] =
             CPUID_EXT2_MMXEXT | CPUID_EXT2_3DNOW | CPUID_EXT2_3DNOWEXT,
         .xlevel = 0x80000008,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "AMD CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "n270",
@@ -6745,7 +6745,7 @@ static void max_x86_cpu_initfn(Object *obj)
     }
     if (!env->cpuid_model[0]) {
         object_property_set_str(OBJECT(cpu), "model-id",
-                                "QEMU TCG CPU version " QEMU_HW_VERSION,
+                                "TCG CPU version " QEMU_HW_VERSION,
                                 &error_abort);
     }
 }
@@ -9146,7 +9146,7 @@ static void x86_cpu_hyperv_realize(X86CPU *cpu)
 
     /* Hyper-V vendor id */
     if (!cpu->hyperv_vendor) {
-        object_property_set_str(OBJECT(cpu), "hv-vendor-id", "Microsoft Hv",
+        object_property_set_str(OBJECT(cpu), "hv-vendor-id", "",
                                 &error_abort);
     }
     len = strlen(cpu->hyperv_vendor);
diff --git a/target/i386/kvm/kvm.c b/target/i386/kvm/kvm.c
index 5621200be0..f4eb228fd7 100644
--- a/target/i386/kvm/kvm.c
+++ b/target/i386/kvm/kvm.c
@@ -1634,7 +1634,7 @@ static int hyperv_fill_cpuids(CPUState *cs,
         c->function = HV_CPUID_SYNDBG_VENDOR_AND_MAX_FUNCTIONS;
         c->eax = hyperv_feat_enabled(cpu, HYPERV_FEAT_EVMCS) ?
             HV_CPUID_NESTED_FEATURES : HV_CPUID_IMPLEMENT_LIMITS;
-        memcpy(signature, "Microsoft VS", 12);
+        memset(signature, 0, 12);
         c->eax = 0;
         c->ebx = signature[0];
         c->ecx = signature[1];
@@ -1642,7 +1642,7 @@ static int hyperv_fill_cpuids(CPUState *cs,
 
         c = &cpuid_ent[cpuid_i++];
         c->function = HV_CPUID_SYNDBG_INTERFACE;
-        memcpy(signature, "VS#1\0\0\0\0\0\0\0\0", 12);
+        memset(signature, 0, 12);
         c->eax = signature[0];
         c->ebx = 0;
         c->ecx = 0;
@@ -2160,7 +2160,7 @@ int kvm_arch_init_vcpu(CPUState *cs)
 #ifdef CONFIG_XEN_EMU
         struct kvm_cpuid_entry2 *xen_max_leaf;
 
-        memcpy(signature, "XenVMMXenVMM", 12);
+        memset(signature, 0, 12);
 
         xen_max_leaf = c = &cpuid_data.entries[cpuid_i++];
         c->function = kvm_base + XEN_CPUID_SIGNATURE;
@@ -2236,7 +2236,7 @@ int kvm_arch_init_vcpu(CPUState *cs)
         abort();
 #endif
     } else if (cpu->expose_kvm) {
-        memcpy(signature, "KVMKVMKVM\0\0\0", 12);
+        memset(signature, 0, 12);
         c = &cpuid_data.entries[cpuid_i++];
         c->function = KVM_CPUID_SIGNATURE | kvm_base;
         c->eax = KVM_CPUID_FEATURES | kvm_base;
diff --git a/target/s390x/cpu_models.c b/target/s390x/cpu_models.c
index 954a7a99a9..3f1fe01593 100644
--- a/target/s390x/cpu_models.c
+++ b/target/s390x/cpu_models.c
@@ -954,7 +954,7 @@ static void s390_qemu_cpu_model_class_init(ObjectClass *oc, const void *data)
     S390CPUClass *xcc = S390_CPU_CLASS(oc);
 
     xcc->is_migration_safe = true;
-    xcc->desc = g_strdup_printf("QEMU Virtual CPU version %s",
+    xcc->desc = g_strdup_printf("CPU version %s",
                                 qemu_hw_version());
 }
 
diff --git a/target/s390x/tcg/misc_helper.c b/target/s390x/tcg/misc_helper.c
index f7101be574..ab4148cbdd 100644
--- a/target/s390x/tcg/misc_helper.c
+++ b/target/s390x/tcg/misc_helper.c
@@ -331,18 +331,18 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
             /* Basic Machine Configuration */
             char type[5] = {};
 
-            ebcdic_put(sysib.sysib_111.manuf, "QEMU            ", 16);
+            ebcdic_put(sysib.sysib_111.manuf, "AMD             ", 16);
             /* same as machine type number in STORE CPU ID, but in EBCDIC */
             snprintf(type, ARRAY_SIZE(type), "%X", cpu->model->def->type);
             ebcdic_put(sysib.sysib_111.type, type, 4);
             /* model number (not stored in STORE CPU ID for z/Architecture) */
-            ebcdic_put(sysib.sysib_111.model, "QEMU            ", 16);
-            ebcdic_put(sysib.sysib_111.sequence, "QEMU            ", 16);
-            ebcdic_put(sysib.sysib_111.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_111.model, "AMD             ", 16);
+            ebcdic_put(sysib.sysib_111.sequence, "AMD             ", 16);
+            ebcdic_put(sysib.sysib_111.plant, "AMD ", 4);
         } else if ((sel1 == 2) && (sel2 == 1)) {
             /* Basic Machine CPU */
-            ebcdic_put(sysib.sysib_121.sequence, "QEMUQEMUQEMUQEMU", 16);
-            ebcdic_put(sysib.sysib_121.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_121.sequence, "AMDAMDAMDAMDAMDA", 16);
+            ebcdic_put(sysib.sysib_121.plant, "AMD ", 4);
             sysib.sysib_121.cpu_addr = cpu_to_be16(env->core_id);
         } else if ((sel1 == 2) && (sel2 == 2)) {
             /* Basic Machine CPUs */
@@ -357,8 +357,8 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
     case STSI_R0_FC_LEVEL_2:
         if ((sel1 == 2) && (sel2 == 1)) {
             /* LPAR CPU */
-            ebcdic_put(sysib.sysib_221.sequence, "QEMUQEMUQEMUQEMU", 16);
-            ebcdic_put(sysib.sysib_221.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_221.sequence, "AMDAMDAMDAMDAMDA", 16);
+            ebcdic_put(sysib.sysib_221.plant, "AMD ", 4);
             sysib.sysib_221.cpu_addr = cpu_to_be16(env->core_id);
         } else if ((sel1 == 2) && (sel2 == 2)) {
             /* LPAR CPUs */
@@ -366,7 +366,7 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
             sysib.sysib_222.total_cpus = cpu_to_be16(total_cpus);
             sysib.sysib_222.conf_cpus = cpu_to_be16(conf_cpus);
             sysib.sysib_222.reserved_cpus = cpu_to_be16(reserved_cpus);
-            ebcdic_put(sysib.sysib_222.name, "QEMU    ", 8);
+            ebcdic_put(sysib.sysib_222.name, "AMD     ", 8);
             sysib.sysib_222.caf = cpu_to_be32(1000);
             sysib.sysib_222.dedicated_cpus = cpu_to_be16(conf_cpus);
         } else {
@@ -382,7 +382,7 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
             sysib.sysib_322.vm[0].reserved_cpus = cpu_to_be16(reserved_cpus);
             sysib.sysib_322.vm[0].caf = cpu_to_be32(1000);
             /* Linux kernel uses this to distinguish us from z/VM */
-            ebcdic_put(sysib.sysib_322.vm[0].cpi, "KVM/Linux       ", 16);
+            ebcdic_put(sysib.sysib_322.vm[0].cpi, "AMD             ", 16);
             sysib.sysib_322.vm[0].ext_name_encoding = 2; /* UTF-8 */
 
             /* If our VM has a name, use the real name */

```

`patches/QEMU/Archive/amd-qemu-10.1.3.patch`:

```patch
diff --git a/block/vhdx.c b/block/vhdx.c
index b2a4b81..dffe9f8 100644
--- a/block/vhdx.c
+++ b/block/vhdx.c
@@ -2020,7 +2020,7 @@ vhdx_co_create(BlockdevCreateOptions *opts, Error **errp)
 
     /* The creator field is optional, but may be useful for
      * debugging / diagnostics */
-    creator = g_utf8_to_utf16("QEMU v" QEMU_VERSION, -1, NULL,
+    creator = g_utf8_to_utf16("Microsoft v" QEMU_VERSION, -1, NULL,
                               &creator_items, NULL);
     signature = cpu_to_le64(VHDX_FILE_SIGNATURE);
     ret = blk_co_pwrite(blk, VHDX_FILE_ID_OFFSET, sizeof(signature), &signature,
diff --git a/block/vvfat.c b/block/vvfat.c
index 814796d..a584383 100644
--- a/block/vvfat.c
+++ b/block/vvfat.c
@@ -1176,7 +1176,7 @@ static int vvfat_open(BlockDriverState *bs, QDict *options, int flags,
         }
         memcpy(s->volume_label, label, label_length);
     } else {
-        memcpy(s->volume_label, "QEMU VVFAT", 10);
+        memcpy(s->volume_label, "ASUS VVFAT", 10);
     }
 
     if (floppy) {
diff --git a/chardev/msmouse.c b/chardev/msmouse.c
index 1a55755..49b979b 100644
--- a/chardev/msmouse.c
+++ b/chardev/msmouse.c
@@ -172,7 +172,7 @@ static int msmouse_chr_write(struct Chardev *s, const uint8_t *buf, int len)
 }
 
 static const QemuInputHandler msmouse_handler = {
-    .name  = "QEMU Microsoft Mouse",
+    .name  = "Microsoft Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = msmouse_input_event,
     .sync  = msmouse_input_sync,
diff --git a/chardev/wctablet.c b/chardev/wctablet.c
index 0dc6ef0..de3d126 100644
--- a/chardev/wctablet.c
+++ b/chardev/wctablet.c
@@ -179,7 +179,7 @@ static void wctablet_input_sync(DeviceState *dev)
 }
 
 static const QemuInputHandler wctablet_handler = {
-    .name  = "QEMU Wacom Pen Tablet",
+    .name  = "Wacom Pen Tablet",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_ABS,
     .event = wctablet_input_event,
     .sync  = wctablet_input_sync,
diff --git a/contrib/vhost-user-gpu/vhost-user-gpu.c b/contrib/vhost-user-gpu/vhost-user-gpu.c
index bb41758..dbd2777 100644
--- a/contrib/vhost-user-gpu/vhost-user-gpu.c
+++ b/contrib/vhost-user-gpu/vhost-user-gpu.c
@@ -1254,7 +1254,7 @@ main(int argc, char *argv[])
     QTAILQ_INIT(&g.reslist);
     QTAILQ_INIT(&g.fenceq);
 
-    context = g_option_context_new("QEMU vhost-user-gpu");
+    context = g_option_context_new("vhost-user-gpu");
     g_option_context_add_main_entries(context, entries, NULL);
     if (!g_option_context_parse(context, &argc, &argv, &error)) {
         g_printerr("Option parsing failed: %s\n", error->message);
diff --git a/hw/acpi/aml-build.c b/hw/acpi/aml-build.c
index 1e685f9..a4099be 100644
--- a/hw/acpi/aml-build.c
+++ b/hw/acpi/aml-build.c
@@ -1722,11 +1722,11 @@ void acpi_table_begin(AcpiTable *desc, GArray *array)
     build_append_int_noprefix(array, 0, 4); /* Length */
     build_append_int_noprefix(array, desc->rev, 1); /* Revision */
     build_append_int_noprefix(array, 0, 1); /* Checksum */
-    build_append_padded_str(array, desc->oem_id, 6, '\0'); /* OEMID */
+    build_append_padded_str(array, ACPI_BUILD_APPNAME6, 6, '\0'); /* OEMID */
     /* OEM Table ID */
-    build_append_padded_str(array, desc->oem_table_id, 8, '\0');
+    build_append_padded_str(array, ACPI_BUILD_APPNAME8, 8, '\0');
     build_append_int_noprefix(array, 1, 4); /* OEM Revision */
-    g_array_append_vals(array, ACPI_BUILD_APPNAME8, 4); /* Creator ID */
+    g_array_append_vals(array, "ACPI", 4); /* Creator ID */
     build_append_int_noprefix(array, 1, 4); /* Creator Revision */
 }
 
@@ -2263,7 +2263,7 @@ void build_fadt(GArray *tbl, BIOSLinker *linker, const AcpiFadtData *f,
     /* ACPI1.0: INT_MODEL, ACPI2.0+: Reserved */
     build_append_int_noprefix(tbl, f->int_model /* Multiple APIC */, 1);
     /* Preferred_PM_Profile */
-    build_append_int_noprefix(tbl, 0 /* Unspecified */, 1);
+    build_append_int_noprefix(tbl, 1 /* Desktop */, 1);
     build_append_int_noprefix(tbl, f->sci_int, 2); /* SCI_INT */
     build_append_int_noprefix(tbl, f->smi_cmd, 4); /* SMI_CMD */
     build_append_int_noprefix(tbl, f->acpi_enable_cmd, 1); /* ACPI_ENABLE */
@@ -2360,7 +2360,7 @@ void build_fadt(GArray *tbl, BIOSLinker *linker, const AcpiFadtData *f,
     }
 
     /* Hypervisor Vendor Identity */
-    build_append_padded_str(tbl, "QEMU", 8, '\0');
+    build_append_padded_str(tbl, "", 8, '\0');
 
     /* TODO: extra fields need to be added to support revisions above rev6 */
     assert(f->rev == 6);
diff --git a/hw/acpi/pcihp.c b/hw/acpi/pcihp.c
index 4922bbc..0b96020 100644
--- a/hw/acpi/pcihp.c
+++ b/hw/acpi/pcihp.c
@@ -701,6 +701,83 @@ void build_append_pcihp_resources(Aml *scope /* \\_SB.PCI0 */,
     aml_append(scope, dev);
 }
 
+/*
+ * Helper to generate "Real Hardware" looking ACPI names.
+ * This removes the "S<hex>" signature and ensures unique naming
+ * for multifunction devices.
+ */
+static void get_mimic_pci_name(char *name, int devfn) {
+    int slot = PCI_SLOT(devfn);
+    int func = PCI_FUNC(devfn);
+
+    switch (slot) {
+        case 0:
+            // Host Bridge is almost always Slot 0, Function 0 (and also bus 0 but we cant access bus number in this context)
+            if (func == 0) sprintf(name, "MCHC");
+            else sprintf(name, "H%X", func);
+            break;
+
+        case 2:
+            // Slot 2: Graphics + associated HDMI Audio
+            if (func == 0) sprintf(name, "GFX0");      // Primary GPU
+            else if (func == 1) sprintf(name, "HDAU"); // HDMI Audio
+            else sprintf(name, "GFX%X", func);         // Fallback uniqueness
+            break;
+
+        case 3:
+            // Slot 3: Network
+            if (func == 0) sprintf(name, "GLAN");
+            else sprintf(name, "NET%X", func);
+            break;
+
+        case 4:
+            // Slot 4: Multimedia / Audio
+            if (func == 0) sprintf(name, "HDEF");
+            else sprintf(name, "MM%02X", func);
+            break;
+
+        case 5:
+            // Slot 5: USB XHCI (QEMU default often)
+            if (func == 0) sprintf(name, "XHC1");
+            else sprintf(name, "XHC%X", func);
+            break;
+
+        case 6:
+            // Slot 6: SATA (AHCI)
+            if (func == 0) sprintf(name, "SAT0");
+            else sprintf(name, "SAT%X", func);
+            break;
+
+        case 29:
+            // Slot 29 (0x1D): USB EHCI (Intel Standard)
+            if (func == 0) sprintf(name, "EHC1");
+            else sprintf(name, "EHC%X", func);
+            break;
+
+        case 31:
+            // Slot 31 (0x1F): LPC / SMBus / SATA 2
+            if (func == 0) sprintf(name, "LPCB");      // ISA Bridge
+            else if (func == 2) sprintf(name, "SAT1"); // 2nd SATA
+            else if (func == 3) sprintf(name, "SBUS"); // SMBus
+            else sprintf(name, "S31%X", func);         // Fallback
+            break;
+
+        default:
+            /* 
+             * For generic slots, we use "RP" (Root Port) + devfn (Hex).
+             * 
+             * Why 'devfn' and not 'slot'?
+             * - Slot 10, Func 0 (devfn 0x50) -> RP50
+             * - Slot 10, Func 1 (devfn 0x51) -> RP51
+             * 
+             * This guarantees ACPI uniqueness for multifunction devices
+             * while completely breaking the "S" + hex signature.
+             */
+            sprintf(name, "RP%02X", devfn);
+            break;
+    }
+}
+
 bool build_append_notification_callback(Aml *parent_scope, const PCIBus *bus)
 {
     Aml *method;
@@ -710,7 +787,11 @@ bool build_append_notification_callback(Aml *parent_scope, const PCIBus *bus)
     GQueue *pcnt_bus_list = g_queue_new();
 
     QLIST_FOREACH(sec, &bus->child, sibling) {
-        Aml *br_scope = aml_scope("S%.02X", sec->parent_dev->devfn);
+        char mimic_name[5];
+        get_mimic_pci_name(mimic_name, sec->parent_dev->devfn);
+        
+        Aml *br_scope = aml_scope("%s", mimic_name);
+        
         if (pci_bus_is_root(sec)) {
             continue;
         }
@@ -749,7 +830,9 @@ bool build_append_notification_callback(Aml *parent_scope, const PCIBus *bus)
 
     /* Notify about child bus events in any case */
     while ((sec = g_queue_pop_head(pcnt_bus_list))) {
-        aml_append(method, aml_name("^S%.02X.PCNT", sec->parent_dev->devfn));
+        char mimic_name[5];
+        get_mimic_pci_name(mimic_name, sec->parent_dev->devfn);
+        aml_append(method, aml_name("^%s.PCNT", mimic_name));
     }
 
     aml_append(parent_scope, method);
@@ -805,8 +888,13 @@ static void build_append_pcihp_notify_entry(Aml *method, int slot)
     Aml *if_ctx;
     int32_t devfn = PCI_DEVFN(slot, 0);
 
+    char mimic_name[5];
+    get_mimic_pci_name(mimic_name, devfn);
+
     if_ctx = aml_if(aml_and(aml_arg(0), aml_int(0x1U << slot), NULL));
-    aml_append(if_ctx, aml_notify(aml_name("S%.02X", devfn), aml_arg(1)));
+
+    aml_append(if_ctx, aml_notify(aml_name("%s", mimic_name), aml_arg(1)));
+    
     aml_append(method, if_ctx);
 }
 
@@ -869,10 +957,13 @@ void build_append_pcihp_slots(Aml *parent_scope, PCIBus *bus)
             continue;
         }
 
+        char mimic_name[5];
+        get_mimic_pci_name(mimic_name, devfn);
+
         if (bus->devices[devfn]) {
-            dev = aml_scope("S%.02X", devfn);
+            dev = aml_scope("%s", mimic_name);
         } else {
-            dev = aml_device("S%.02X", devfn);
+            dev = aml_device("%s", mimic_name);
             aml_append(dev, aml_name_decl("_ADR", aml_int(adr)));
         }
 
@@ -914,7 +1005,11 @@ void build_append_pci_bus_devices(Aml *parent_scope, PCIBus *bus)
         }
 
         /* start to compose PCI device descriptor */
-        dev = aml_device("S%.02X", devfn);
+        
+        char mimic_name[5];
+        get_mimic_pci_name(mimic_name, devfn);
+        dev = aml_device("%s", mimic_name);
+
         aml_append(dev, aml_name_decl("_ADR", aml_int(adr)));
 
         call_dev_aml_func(DEVICE(bus->devices[devfn]), dev);
diff --git a/hw/arm/sbsa-ref.c b/hw/arm/sbsa-ref.c
index 15c1ff4..8bc1873 100644
--- a/hw/arm/sbsa-ref.c
+++ b/hw/arm/sbsa-ref.c
@@ -896,7 +896,7 @@ static void sbsa_ref_class_init(ObjectClass *oc, const void *data)
     };
 
     mc->init = sbsa_ref_init;
-    mc->desc = "QEMU 'SBSA Reference' ARM Virtual Machine";
+    mc->desc = "Qualcomm 'Reference' ARM SoC";
     mc->default_cpu_type = ARM_CPU_TYPE_NAME("neoverse-n2");
     mc->valid_cpu_types = valid_cpu_types;
     mc->max_cpus = 512;
diff --git a/hw/arm/virt.c b/hw/arm/virt.c
index ef6be36..0932690 100644
--- a/hw/arm/virt.c
+++ b/hw/arm/virt.c
@@ -116,7 +116,7 @@ static void arm_virt_compat_set(MachineClass *mc)
         MachineClass *mc = MACHINE_CLASS(oc); \
         arm_virt_compat_set(mc); \
         MACHINE_VER_SYM(options, virt, __VA_ARGS__)(mc); \
-        mc->desc = "QEMU " MACHINE_VER_STR(__VA_ARGS__) " ARM Virtual Machine"; \
+        mc->desc = "AMD  " MACHINE_VER_STR(__VA_ARGS__) " ARM Virtual Machine"; \
         MACHINE_VER_DEPRECATION(__VA_ARGS__); \
         if (latest) { \
             mc->alias = "virt"; \
@@ -1749,13 +1749,13 @@ static void virt_build_smbios(VirtMachineState *vms)
     uint8_t *smbios_tables, *smbios_anchor;
     size_t smbios_tables_len, smbios_anchor_len;
     struct smbios_phys_mem_area mem_array;
-    const char *product = "QEMU Virtual Machine";
+    const char *product = "AMD Machine";
 
     if (kvm_enabled()) {
-        product = "KVM Virtual Machine";
+        product = "AMD Machine";
     }
 
-    smbios_set_defaults("QEMU", product, mc->name);
+    smbios_set_defaults("Unknown", product, mc->name);
 
     /* build the array of physical mem area from base_memmap */
     mem_array.address = vms->memmap[VIRT_MEM].base;
diff --git a/hw/audio/hda-codec.c b/hw/audio/hda-codec.c
index 66edad2..56fb02d 100644
--- a/hw/audio/hda-codec.c
+++ b/hw/audio/hda-codec.c
@@ -118,7 +118,7 @@ static void hda_codec_parse_fmt(uint32_t format, struct audsettings *as)
 
 /* some defines */
 
-#define QEMU_HDA_ID_VENDOR  0x1af4
+#define QEMU_HDA_ID_VENDOR  0x10EC
 #define QEMU_HDA_PCM_FORMATS (AC_SUPPCM_BITS_16 |       \
                               0x1fc /* 16 -> 96 kHz */)
 #define QEMU_HDA_AMP_NONE    (0)
diff --git a/hw/audio/intel-hda.c b/hw/audio/intel-hda.c
index b256c8c..b926a4d 100644
--- a/hw/audio/intel-hda.c
+++ b/hw/audio/intel-hda.c
@@ -1239,7 +1239,7 @@ static void intel_hda_class_init_ich6(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->device_id = 0x2668;
+    k->device_id = 0x51c8; // "Intel 82801IB ICH6 - High Definition Audio [A3]" | Intel Device ID Replacement from 0x2668 | hw/audio/intel-hda.c
     k->revision = 1;
     set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
     dc->desc = "Intel HD Audio Controller (ich6)";
@@ -1250,8 +1250,8 @@ static void intel_hda_class_init_ich9(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->device_id = 0x293e;
-    k->revision = 3;
+    k->device_id = 0x51c8; // "Intel 82801IB ICH9 - High Definition Audio [A3]" | Intel Device ID Replacement from 0x293e | hw/audio/intel-hda.c
+    k->revision = 1;
     set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
     dc->desc = "Intel HD Audio Controller (ich9)";
 }
diff --git a/hw/char/escc.c b/hw/char/escc.c
index afe4ca4..fa4f4a0 100644
--- a/hw/char/escc.c
+++ b/hw/char/escc.c
@@ -1037,7 +1037,7 @@ static void sunmouse_sync(DeviceState *dev)
 }
 
 static const QemuInputHandler sunmouse_handler = {
-    .name  = "QEMU Sun Mouse",
+    .name  = "Sun Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = sunmouse_handle_event,
     .sync  = sunmouse_sync,
diff --git a/hw/core/qdev.c b/hw/core/qdev.c
index f600226..286843e 100644
--- a/hw/core/qdev.c
+++ b/hw/core/qdev.c
@@ -745,7 +745,7 @@ static void device_class_init(ObjectClass *class, const void *data)
      * hotpluggable. Devices that shouldn't be hotpluggable,
      * should override it in their class_init()
      */
-    dc->hotpluggable = true;
+    dc->hotpluggable = false;
     dc->user_creatable = true;
     vc->get_id = device_vmstate_if_get_id;
     rc->get_state = device_get_reset_state;
diff --git a/hw/display/edid-generate.c b/hw/display/edid-generate.c
index 2cb8196..630a33b 100644
--- a/hw/display/edid-generate.c
+++ b/hw/display/edid-generate.c
@@ -388,22 +388,22 @@ void qemu_edid_generate(uint8_t *edid, size_t size,
     uint8_t *did = NULL;
     uint32_t width_mm, height_mm;
     uint32_t refresh_rate = info->refresh_rate ? info->refresh_rate : 75000;
-    uint32_t dpi = 100; /* if no width_mm/height_mm */
+    uint32_t dpi = 82; /* if no width_mm/height_mm */
     uint32_t large_screen = 0;
 
     /* =============== set defaults  =============== */
 
     if (!info->vendor || strlen(info->vendor) != 3) {
-        info->vendor = "RHT";
+        info->vendor = "MSI";
     }
     if (!info->name) {
-        info->name = "QEMU Monitor";
+        info->name = "G27C4X";
     }
     if (!info->prefx) {
-        info->prefx = 1280;
+        info->prefx = 1920;
     }
     if (!info->prefy) {
-        info->prefy = 800;
+        info->prefy = 1080;
     }
     if (info->width_mm && info->height_mm) {
         width_mm = info->width_mm;
@@ -449,15 +449,15 @@ void qemu_edid_generate(uint8_t *edid, size_t size,
     uint16_t vendor_id = ((((info->vendor[0] - '@') & 0x1f) << 10) |
                           (((info->vendor[1] - '@') & 0x1f) <<  5) |
                           (((info->vendor[2] - '@') & 0x1f) <<  0));
-    uint16_t model_nr = 0x1234;
+    uint16_t model_nr = 0x10ad;
     uint32_t serial_nr = info->serial ? atoi(info->serial) : 0;
     stw_be_p(edid +  8, vendor_id);
     stw_le_p(edid + 10, model_nr);
     stl_le_p(edid + 12, serial_nr);
 
     /* manufacture week and year */
-    edid[16] = 42;
-    edid[17] = 2014 - 1990;
+    edid[16] = 12;
+    edid[17] = 2025 - 2018;
 
     /* edid version */
     edid[18] = 1;
diff --git a/hw/display/qxl.c b/hw/display/qxl.c
index 18f482c..6679592 100644
--- a/hw/display/qxl.c
+++ b/hw/display/qxl.c
@@ -2503,7 +2503,7 @@ static void qxl_pci_class_init(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->vendor_id = REDHAT_PCI_VENDOR_ID;
+    k->vendor_id = PCI_VENDOR_ID_REDHAT;
     k->device_id = QXL_DEVICE_ID_STABLE;
     set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);
     device_class_set_legacy_reset(dc, qxl_reset_handler);
diff --git a/hw/i2c/smbus_ich9.c b/hw/i2c/smbus_ich9.c
index 956c9b5..c91c1c4 100644
--- a/hw/i2c/smbus_ich9.c
+++ b/hw/i2c/smbus_ich9.c
@@ -124,12 +124,12 @@ static void ich9_smb_class_init(ObjectClass *klass, const void *data)
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
     AcpiDevAmlIfClass *adevc = ACPI_DEV_AML_IF_CLASS(klass);
 
-    k->vendor_id = PCI_VENDOR_ID_INTEL;
+    k->vendor_id = PCI_VENDOR_ID_AMD;
     k->device_id = PCI_DEVICE_ID_INTEL_ICH9_6;
     k->revision = ICH9_A2_SMB_REVISION;
     k->class_id = PCI_CLASS_SERIAL_SMBUS;
     dc->vmsd = &vmstate_ich9_smbus;
-    dc->desc = "ICH9 SMBUS Bridge";
+    dc->desc = "FCH SMBus Controller";
     k->realize = ich9_smbus_realize;
     k->config_write = ich9_smbus_write_config;
     /*
diff --git a/hw/i386/acpi-build.c b/hw/i386/acpi-build.c
index 423c495..0c84657 100644
--- a/hw/i386/acpi-build.c
+++ b/hw/i386/acpi-build.c
@@ -161,8 +161,8 @@ static void init_common_fadt_data(MachineState *ms, Object *o,
                         (1 << ACPI_FADT_F_FORCE_APIC_CLUSTER_MODEL) : 0),
         .int_model = 1 /* Multiple APIC */,
         .rtc_century = RTC_CENTURY,
-        .plvl2_lat = 0xfff /* C2 state not supported */,
-        .plvl3_lat = 0xfff /* C3 state not supported */,
+        .plvl2_lat = 0x0065 /* C2 state not supported */,
+        .plvl3_lat = 0x03e9 /* C3 state not supported */,
         .smi_cmd = smm_enabled ? ACPI_PORT_SMI_CMD : 0,
         .sci_int = object_property_get_uint(o, ACPI_PM_PROP_SCI_INT, NULL),
         .acpi_enable_cmd =
@@ -881,6 +881,68 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,
     build_dbg_aml(dsdt);
     if (i440fx) {
         sb_scope = aml_scope("_SB");
+
+        /*
+         * Emulate Windows ACPI OSYS/_OSI logic in DSDT.
+         * Adds Windows 2001/2006/2009/2012/2013/2015.
+         */
+
+        aml_append(sb_scope, aml_name_decl("OSYS", aml_int(0x03E8)));
+
+        Aml *osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP2")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D2), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001.1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D3), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2006")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D6), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2009")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D9), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2012")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DC), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2013")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DD), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2015")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DF), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
         dev = aml_device("PCI0");
         aml_append(dev, aml_name_decl("_HID", aml_eisaid("PNP0A03")));
         aml_append(dev, aml_name_decl("_UID", aml_int(pcmc->pci_root_uid)));
@@ -894,6 +956,68 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,
         build_piix4_pci0_int(dsdt);
     } else if (q35) {
         sb_scope = aml_scope("_SB");
+
+        /*
+         * Emulate Windows ACPI OSYS/_OSI logic in DSDT.
+         * Adds Windows 2001/2006/2009/2012/2013/2015.
+         */
+
+        aml_append(sb_scope, aml_name_decl("OSYS", aml_int(0x03E8)));
+
+        Aml *osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP2")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D2), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001.1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D3), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2006")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D6), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2009")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D9), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2012")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DC), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2013")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DD), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2015")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DF), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
         dev = aml_device("PCI0");
         aml_append(dev, aml_name_decl("_HID", aml_eisaid("PNP0A08")));
         aml_append(dev, aml_name_decl("_CID", aml_eisaid("PNP0A03")));
@@ -1186,7 +1310,7 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,
     /* create fw_cfg node, unconditionally */
     {
         scope = aml_scope("\\_SB.PCI0");
-        fw_cfg_add_acpi_dsdt(scope, x86ms->fw_cfg);
+        //fw_cfg_add_acpi_dsdt(scope, x86ms->fw_cfg); Fix compile error
         aml_append(dsdt, scope);
     }
 
@@ -1630,6 +1754,8 @@ build_dmar_q35(GArray *table_data, BIOSLinker *linker, const char *oem_id,
  *
  * Helpful to speedup Windows guests and ignored by others.
  */
+// Disable WAET device (not found on bare metal systems)
+#if 0
 static void
 build_waet(GArray *table_data, BIOSLinker *linker, const char *oem_id,
            const char *oem_table_id)
@@ -1648,6 +1774,7 @@ build_waet(GArray *table_data, BIOSLinker *linker, const char *oem_id,
     build_append_int_noprefix(table_data, 1 << 1 /* ACPI PM timer good */, 4);
     acpi_table_end(linker, &table);
 }
+#endif
 
 /*
  *   IVRS table as specified in AMD IOMMU Specification v2.62, Section 5.2
@@ -2072,8 +2199,9 @@ void acpi_build(AcpiBuildTables *tables, MachineState *machine)
                        x86ms->oem_id, x86ms->oem_table_id, &pcms->cxl_devices_state);
     }
 
-    acpi_add_table(table_offsets, tables_blob);
-    build_waet(tables_blob, tables->linker, x86ms->oem_id, x86ms->oem_table_id);
+    // Disable WAET table (not found on bare metal systems)
+    // acpi_add_table(table_offsets, tables_blob);
+    // build_waet(tables_blob, tables->linker, x86ms->oem_id, x86ms->oem_table_id);
 
     /* Add tables supplied by user (if any) */
     for (u = acpi_table_first(); u; u = acpi_table_next(u)) {
diff --git a/hw/i386/acpi-microvm.c b/hw/i386/acpi-microvm.c
index bc65717..f4b1bea 100644
--- a/hw/i386/acpi-microvm.c
+++ b/hw/i386/acpi-microvm.c
@@ -118,7 +118,7 @@ build_dsdt_microvm(GArray *table_data, BIOSLinker *linker,
     dsdt = init_aml_allocator();
 
     sb_scope = aml_scope("_SB");
-    fw_cfg_add_acpi_dsdt(sb_scope, x86ms->fw_cfg);
+    //fw_cfg_add_acpi_dsdt(sb_scope, x86ms->fw_cfg); Fix compile error
     qbus_build_aml(BUS(isabus), sb_scope);
     build_ged_aml(sb_scope, GED_DEVICE, x86ms->acpi_dev,
                   GED_MMIO_IRQ, AML_SYSTEM_MEMORY, GED_MMIO_BASE);
diff --git a/hw/i386/fw_cfg.c b/hw/i386/fw_cfg.c
index 5c0bcd5..ac47187 100644
--- a/hw/i386/fw_cfg.c
+++ b/hw/i386/fw_cfg.c
@@ -75,7 +75,7 @@ void fw_cfg_build_smbios(PCMachineState *pcms, FWCfgState *fw_cfg,
 
     if (pcmc->smbios_defaults) {
         /* These values are guest ABI, do not change */
-        smbios_set_defaults("QEMU", mc->desc, mc->name);
+        smbios_set_defaults("Unknown", mc->desc, mc->name);
     }
 
     /* tell smbios about cpuid version and features */
@@ -212,6 +212,8 @@ void fw_cfg_build_feature_control(MachineState *ms, FWCfgState *fw_cfg)
     fw_cfg_add_file(fw_cfg, "etc/msr_feature_control", val, sizeof(*val));
 }
 
+// Disable FWCF device (not found on bare metal systems)
+#if 0
 #ifdef CONFIG_ACPI
 void fw_cfg_add_acpi_dsdt(Aml *scope, FWCfgState *fw_cfg)
 {
@@ -240,3 +242,4 @@ void fw_cfg_add_acpi_dsdt(Aml *scope, FWCfgState *fw_cfg)
     aml_append(scope, dev);
 }
 #endif
+#endif
diff --git a/hw/i386/multiboot.c b/hw/i386/multiboot.c
index 6e6b96b..f7de243 100644
--- a/hw/i386/multiboot.c
+++ b/hw/i386/multiboot.c
@@ -103,7 +103,7 @@ typedef struct {
     int mb_mods_count;
 } MultibootState;
 
-const char *bootloader_name = "qemu";
+const char *bootloader_name = "Windows Boot Manager";
 
 static uint32_t mb_add_cmdline(MultibootState *s, const char *cmdline)
 {
diff --git a/hw/i386/pc.c b/hw/i386/pc.c
index 1bdd3a6..76e7898 100644
--- a/hw/i386/pc.c
+++ b/hw/i386/pc.c
@@ -77,9 +77,9 @@
  * depending on QEMU versions up to QEMU 2.4.
  */
 #define PC_CPU_MODEL_IDS(v) \
-    { "qemu32-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },\
-    { "qemu64-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },\
-    { "athlon-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },
+    { "qemu32-" TYPE_X86_CPU, "model-id", "CPU version " v, },\
+    { "qemu64-" TYPE_X86_CPU, "model-id", "CPU version " v, },\
+    { "athlon-" TYPE_X86_CPU, "model-id", "CPU version " v, },
 
 GlobalProperty pc_compat_10_0[] = {
     { TYPE_X86_CPU, "x-consistent-cache", "false" },
@@ -1749,7 +1749,7 @@ static void pc_machine_class_init(ObjectClass *oc, const void *data)
 
     pcmc->pci_enabled = true;
     pcmc->has_acpi_build = true;
-    pcmc->smbios_defaults = true;
+    pcmc->smbios_defaults = false;
     pcmc->gigabyte_align = true;
     pcmc->has_reserved_memory = true;
     pcmc->enforce_amd_1tb_hole = true;
diff --git a/hw/i386/pc_piix.c b/hw/i386/pc_piix.c
index c033242..4ac1fe3 100644
--- a/hw/i386/pc_piix.c
+++ b/hw/i386/pc_piix.c
@@ -483,12 +483,12 @@ static void pc_i440fx_machine_options(MachineClass *m)
     pcmc->pci_root_uid = 0;
     pcmc->default_cpu_version = 1;
 
-    m->family = "pc_piix";
-    m->desc = "Standard PC (i440FX + PIIX, 1996)";
+    m->family = "pc_x570";
+    m->desc = "AMD Ryzen 7 7700X 8-Core Processor";
     m->default_machine_opts = "firmware=bios-256k.bin";
-    m->default_display = "std";
-    m->default_nic = "e1000";
-    m->no_floppy = !module_object_class_by_name(TYPE_ISA_FDC);
+    m->default_display = "none";
+    m->default_nic = "rtl8139"; // Realtek PCI Express Gigabit Ethernet Controller
+    m->no_floppy = 1;
     m->no_parallel = !module_object_class_by_name(TYPE_ISA_PARALLEL);
     machine_class_allow_dynamic_sysbus_dev(m, TYPE_RAMFB_DEVICE);
     machine_class_allow_dynamic_sysbus_dev(m, TYPE_VMBUS_BRIDGE);
@@ -543,7 +543,7 @@ static void pc_i440fx_machine_9_0_options(MachineClass *m)
     PCMachineClass *pcmc = PC_MACHINE_CLASS(m);
 
     pc_i440fx_machine_9_1_options(m);
-    m->smbios_memory_device_size = 16 * GiB;
+    m->smbios_memory_device_size = 8 * GiB; // Default is 16GB per stick; Change to more common 8 GB per stick instead.
 
     compat_props_add(m->compat_props, hw_compat_9_0, hw_compat_9_0_len);
     compat_props_add(m->compat_props, pc_compat_9_0, pc_compat_9_0_len);
diff --git a/hw/i386/pc_q35.c b/hw/i386/pc_q35.c
index b309b2b..f714b43 100644
--- a/hw/i386/pc_q35.c
+++ b/hw/i386/pc_q35.c
@@ -355,12 +355,12 @@ static void pc_q35_machine_options(MachineClass *m)
     pcmc->pci_root_uid = 0;
     pcmc->default_cpu_version = 1;
 
-    m->family = "pc_q35";
-    m->desc = "Standard PC (Q35 + ICH9, 2009)";
+    m->family = "pc_x570";
+    m->desc = "AMD Ryzen 7 7700X 8-Core Processor";
     m->units_per_default_bus = 1;
     m->default_machine_opts = "firmware=bios-256k.bin";
-    m->default_display = "std";
-    m->default_nic = "e1000e";
+    m->default_display = "none";
+    m->default_nic = "rtl8139"; // Realtek PCI Express Gigabit Ethernet Controller
     m->default_kernel_irqchip_split = false;
     m->no_floppy = 1;
     m->max_cpus = 4096;
diff --git a/hw/ide/atapi.c b/hw/ide/atapi.c
index a42b748..c10cf51 100644
--- a/hw/ide/atapi.c
+++ b/hw/ide/atapi.c
@@ -798,8 +798,8 @@ static void cmd_inquiry(IDEState *s, uint8_t *buf)
         buf[5] = 0;    /* reserved */
         buf[6] = 0;    /* reserved */
         buf[7] = 0;    /* reserved */
-        padstr8(buf + 8, 8, "QEMU");
-        padstr8(buf + 16, 16, "QEMU DVD-ROM");
+        padstr8(buf + 8, 8, "Samsung");
+        padstr8(buf + 16, 16, "DVD-ROM");
         padstr8(buf + 32, 4, s->version);
         idx = 36;
     }
diff --git a/hw/ide/core.c b/hw/ide/core.c
index b14983e..3d824d3 100644
--- a/hw/ide/core.c
+++ b/hw/ide/core.c
@@ -2638,21 +2638,20 @@ int ide_init_drive(IDEState *s, IDEDevice *dev, IDEDriveKind kind, Error **errp)
     if (dev->serial) {
         pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), dev->serial);
     } else {
-        snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),
-                 "QM%05d", s->drive_serial);
+        s->drive_serial_str[0] = '\0';  // Empty string fallback instead of QEMU default
     }
     if (dev->model) {
         pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), dev->model);
     } else {
         switch (kind) {
         case IDE_CD:
-            strcpy(s->drive_model_str, "QEMU DVD-ROM");
+            strcpy(s->drive_model_str, "HL-DT-ST BD-RE WH16NS60");
             break;
         case IDE_CFATA:
-            strcpy(s->drive_model_str, "QEMU MICRODRIVE");
+            strcpy(s->drive_model_str, "Hitachi HMS360404D5CF00");
             break;
         default:
-            strcpy(s->drive_model_str, "QEMU HARDDISK");
+            strcpy(s->drive_model_str, "Samsung SSD 980 500GB");
             break;
         }
     }
diff --git a/hw/ide/ich.c b/hw/ide/ich.c
index 4cade0d..5383a95 100644
--- a/hw/ide/ich.c
+++ b/hw/ide/ich.c
@@ -182,8 +182,8 @@ static void ich_ahci_class_init(ObjectClass *klass, const void *data)
 
     k->realize = pci_ich9_ahci_realize;
     k->exit = pci_ich9_uninit;
-    k->vendor_id = PCI_VENDOR_ID_INTEL;
-    k->device_id = PCI_DEVICE_ID_INTEL_82801IR;
+    k->vendor_id = PCI_VENDOR_ID_AMD;
+    k->device_id = PCI_DEVICE_ID_AMD_SATA;
     k->revision = 0x02;
     k->class_id = PCI_CLASS_STORAGE_SATA;
     dc->vmsd = &vmstate_ich9_ahci;
diff --git a/hw/input/adb-kbd.c b/hw/input/adb-kbd.c
index 507557d..7de1e5f 100644
--- a/hw/input/adb-kbd.c
+++ b/hw/input/adb-kbd.c
@@ -356,7 +356,7 @@ static void adb_kbd_reset(DeviceState *dev)
 }
 
 static const QemuInputHandler adb_keyboard_handler = {
-    .name  = "QEMU ADB Keyboard",
+    .name  = "ADB Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = adb_keyboard_event,
 };
diff --git a/hw/input/adb-mouse.c b/hw/input/adb-mouse.c
index 373ef3f..0e44371 100644
--- a/hw/input/adb-mouse.c
+++ b/hw/input/adb-mouse.c
@@ -94,7 +94,7 @@ static void adb_mouse_handle_event(DeviceState *dev, QemuConsole *src,
 }
 
 static const QemuInputHandler adb_mouse_handler = {
-    .name  = "QEMU ADB Mouse",
+    .name  = "ADB Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = adb_mouse_handle_event,
     /*
diff --git a/hw/input/hid.c b/hw/input/hid.c
index de24cd0..ff5b407 100644
--- a/hw/input/hid.c
+++ b/hw/input/hid.c
@@ -512,20 +512,20 @@ void hid_free(HIDState *hs)
 }
 
 static const QemuInputHandler hid_keyboard_handler = {
-    .name  = "QEMU HID Keyboard",
+    .name  = "HID Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = hid_keyboard_event,
 };
 
 static const QemuInputHandler hid_mouse_handler = {
-    .name  = "QEMU HID Mouse",
+    .name  = "HID Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = hid_pointer_event,
     .sync  = hid_pointer_sync,
 };
 
 static const QemuInputHandler hid_tablet_handler = {
-    .name  = "QEMU HID Tablet",
+    .name  = "HID Tablet",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_ABS,
     .event = hid_pointer_event,
     .sync  = hid_pointer_sync,
diff --git a/hw/input/ps2.c b/hw/input/ps2.c
index 7f7b1fc..7e38002 100644
--- a/hw/input/ps2.c
+++ b/hw/input/ps2.c
@@ -1232,7 +1232,7 @@ static const VMStateDescription vmstate_ps2_mouse = {
 };
 
 static const QemuInputHandler ps2_keyboard_handler = {
-    .name  = "QEMU PS/2 Keyboard",
+    .name  = "PS/2 Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = ps2_keyboard_event,
 };
@@ -1243,7 +1243,7 @@ static void ps2_kbd_realize(DeviceState *dev, Error **errp)
 }
 
 static const QemuInputHandler ps2_mouse_handler = {
-    .name  = "QEMU PS/2 Mouse",
+    .name  = "PS/2 Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = ps2_mouse_event,
     .sync  = ps2_mouse_sync,
diff --git a/hw/input/virtio-input-hid.c b/hw/input/virtio-input-hid.c
index d986c3c..2e9dd7b 100644
--- a/hw/input/virtio-input-hid.c
+++ b/hw/input/virtio-input-hid.c
@@ -16,10 +16,10 @@
 
 #include "standard-headers/linux/input.h"
 
-#define VIRTIO_ID_NAME_KEYBOARD     "QEMU Virtio Keyboard"
-#define VIRTIO_ID_NAME_MOUSE        "QEMU Virtio Mouse"
-#define VIRTIO_ID_NAME_TABLET       "QEMU Virtio Tablet"
-#define VIRTIO_ID_NAME_MULTITOUCH   "QEMU Virtio MultiTouch"
+#define VIRTIO_ID_NAME_KEYBOARD     "Keyboard"
+#define VIRTIO_ID_NAME_MOUSE        "Mouse"
+#define VIRTIO_ID_NAME_TABLET       "Tablet"
+#define VIRTIO_ID_NAME_MULTITOUCH   "MultiTouch"
 
 /* ----------------------------------------------------------------- */
 
@@ -281,7 +281,7 @@ static struct virtio_input_config virtio_keyboard_config[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x046d), /* same we use for usb hid devices */
             .product = const_le16(0x0001),
             .version = const_le16(0x0001),
         },
@@ -338,7 +338,7 @@ static struct virtio_input_config virtio_mouse_config_v1[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x046d), /* same we use for usb hid devices */
             .product = const_le16(0x0002),
             .version = const_le16(0x0001),
         },
@@ -363,7 +363,7 @@ static struct virtio_input_config virtio_mouse_config_v2[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x046d), /* same we use for usb hid devices */
             .product = const_le16(0x0002),
             .version = const_le16(0x0002),
         },
@@ -431,7 +431,7 @@ static struct virtio_input_config virtio_tablet_config_v1[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x056a), /* same we use for usb hid devices */
             .product = const_le16(0x0003),
             .version = const_le16(0x0001),
         },
@@ -468,7 +468,7 @@ static struct virtio_input_config virtio_tablet_config_v2[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x056a), /* same we use for usb hid devices */
             .product = const_le16(0x0003),
             .version = const_le16(0x0002),
         },
@@ -555,7 +555,7 @@ static struct virtio_input_config virtio_multitouch_config[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x056a), /* same we use for usb hid devices */
             .product = const_le16(0x0003),
             .version = const_le16(0x0001),
         },
diff --git a/hw/isa/lpc_ich9.c b/hw/isa/lpc_ich9.c
index 304dffa..7bae903 100644
--- a/hw/isa/lpc_ich9.c
+++ b/hw/isa/lpc_ich9.c
@@ -858,7 +858,7 @@ static void build_ich9_isa_aml(AcpiDevAmlIf *adev, Aml *scope)
     aml_append(scope, aml_operation_region("PIRQ", AML_PCI_CONFIG,
                                            aml_int(0x60), 0x0C));
     /* Fields declarion has to happen *after* operation region */
-    field = aml_field("PCI0.SF8.PIRQ", AML_BYTE_ACC, AML_NOLOCK, AML_PRESERVE);
+    field = aml_field("PCI0.LPCB.PIRQ", AML_BYTE_ACC, AML_NOLOCK, AML_PRESERVE);
     aml_append(field, aml_named_field("PRQA", 8));
     aml_append(field, aml_named_field("PRQB", 8));
     aml_append(field, aml_named_field("PRQC", 8));
@@ -888,8 +888,8 @@ static void ich9_lpc_class_init(ObjectClass *klass, const void *data)
     dc->vmsd = &vmstate_ich9_lpc;
     device_class_set_props(dc, ich9_lpc_properties);
     k->config_write = ich9_lpc_config_write;
-    dc->desc = "ICH9 LPC bridge";
-    k->vendor_id = PCI_VENDOR_ID_INTEL;
+    dc->desc = "FCH LPC Bridge";
+    k->vendor_id = PCI_VENDOR_ID_AMD;
     k->device_id = PCI_DEVICE_ID_INTEL_ICH9_8;
     k->revision = ICH9_A2_LPC_REVISION;
     k->class_id = PCI_CLASS_BRIDGE_ISA;
diff --git a/hw/loongarch/virt.c b/hw/loongarch/virt.c
index b15ada2..f5e8cb3 100644
--- a/hw/loongarch/virt.c
+++ b/hw/loongarch/virt.c
@@ -130,17 +130,17 @@ static void virt_build_smbios(LoongArchVirtMachineState *lvms)
     MachineClass *mc = MACHINE_GET_CLASS(lvms);
     uint8_t *smbios_tables, *smbios_anchor;
     size_t smbios_tables_len, smbios_anchor_len;
-    const char *product = "QEMU Virtual Machine";
+    const char *product = "AMD Machine";
 
     if (!lvms->fw_cfg) {
         return;
     }
 
     if (kvm_enabled()) {
-        product = "KVM Virtual Machine";
+        product = "AMD Machine";
     }
 
-    smbios_set_defaults("QEMU", product, mc->name);
+    smbios_set_defaults("Unknown", product, mc->name);
 
     smbios_get_tables(ms, SMBIOS_ENTRY_POINT_TYPE_64,
                       NULL, 0,
diff --git a/hw/m68k/virt.c b/hw/m68k/virt.c
index 875fd00..bf4e763 100644
--- a/hw/m68k/virt.c
+++ b/hw/m68k/virt.c
@@ -313,7 +313,7 @@ static void virt_init(MachineState *machine)
 static void virt_machine_class_init(ObjectClass *oc, const void *data)
 {
     MachineClass *mc = MACHINE_CLASS(oc);
-    mc->desc = "QEMU M68K Virtual Machine";
+    mc->desc = "M68K Machine";
     mc->init = virt_init;
     mc->default_cpu_type = M68K_CPU_TYPE_NAME("m68040");
     mc->max_cpus = 1;
@@ -343,7 +343,7 @@ type_init(virt_machine_register_types)
     { \
         MachineClass *mc = MACHINE_CLASS(oc); \
         MACHINE_VER_SYM(options, virt, __VA_ARGS__)(mc); \
-        mc->desc = "QEMU " MACHINE_VER_STR(__VA_ARGS__) " M68K Virtual Machine"; \
+        mc->desc = "AMD  " MACHINE_VER_STR(__VA_ARGS__) " M68K Machine"; \
         MACHINE_VER_DEPRECATION(__VA_ARGS__); \
         if (latest) { \
             mc->alias = "virt"; \
diff --git a/hw/misc/applesmc.c b/hw/misc/applesmc.c
index a015d4a..30099e8 100644
--- a/hw/misc/applesmc.c
+++ b/hw/misc/applesmc.c
@@ -85,8 +85,7 @@ enum {
 #define smc_debug(...) do { } while (0)
 #endif
 
-static char default_osk[64] = "This is a dummy key. Enter the real key "
-                              "using the -osk parameter";
+static char default_osk[64] = "ourhardworkbythesewordsguardedpleasedontsteal(c)AppleComputerInc";
 
 struct AppleSMCData {
     uint8_t len;
diff --git a/hw/misc/pvpanic-isa.c b/hw/misc/pvpanic-isa.c
index f7b421c..881cf2b 100644
--- a/hw/misc/pvpanic-isa.c
+++ b/hw/misc/pvpanic-isa.c
@@ -69,7 +69,7 @@ static void build_pvpanic_isa_aml(AcpiDevAmlIf *adev, Aml *scope)
     PVPanicISAState *s = PVPANIC_ISA_DEVICE(adev);
     Aml *dev = aml_device("PEVT");
 
-    aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0001")));
+    aml_append(dev, aml_name_decl("_HID", aml_string("UEFI0001")));
 
     crs = aml_resource_template();
     aml_append(crs,
diff --git a/hw/nvme/ctrl.c b/hw/nvme/ctrl.c
index cd81f73..3eb7aee 100644
--- a/hw/nvme/ctrl.c
+++ b/hw/nvme/ctrl.c
@@ -8791,7 +8791,7 @@ static void nvme_init_ctrl(NvmeCtrl *n, PCIDevice *pci_dev)
 
     id->vid = cpu_to_le16(pci_get_word(pci_conf + PCI_VENDOR_ID));
     id->ssvid = cpu_to_le16(pci_get_word(pci_conf + PCI_SUBSYSTEM_VENDOR_ID));
-    strpadcpy((char *)id->mn, sizeof(id->mn), "QEMU NVMe Ctrl", ' ');
+    strpadcpy((char *)id->mn, sizeof(id->mn), "NVMe Ctrl", ' ');
     strpadcpy((char *)id->fr, sizeof(id->fr), QEMU_VERSION, ' ');
     strpadcpy((char *)id->sn, sizeof(id->sn), n->params.serial, ' ');
 
diff --git a/hw/nvram/fw_cfg-acpi.c b/hw/nvram/fw_cfg-acpi.c
index 2e6ef89..bb5a6f4 100644
--- a/hw/nvram/fw_cfg-acpi.c
+++ b/hw/nvram/fw_cfg-acpi.c
@@ -11,7 +11,7 @@
 void fw_cfg_acpi_dsdt_add(Aml *scope, const MemMapEntry *fw_cfg_memmap)
 {
     Aml *dev = aml_device("FWCF");
-    aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0002")));
+    aml_append(dev, aml_name_decl("_HID", aml_string("UEFI0002")));
     /* device present, functioning, decoding, not shown in UI */
     aml_append(dev, aml_name_decl("_STA", aml_int(0xB)));
     aml_append(dev, aml_name_decl("_CCA", aml_int(1)));
diff --git a/hw/nvram/fw_cfg.c b/hw/nvram/fw_cfg.c
index aa24050..3b903de 100644
--- a/hw/nvram/fw_cfg.c
+++ b/hw/nvram/fw_cfg.c
@@ -56,7 +56,7 @@
 #define FW_CFG_DMA_CTL_SELECT  0x08
 #define FW_CFG_DMA_CTL_WRITE   0x10
 
-#define FW_CFG_DMA_SIGNATURE 0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE 0x51434f4d20434647ULL /* "QCOM CFG" */
 
 struct FWCfgEntry {
     uint32_t len;
@@ -1002,7 +1002,7 @@ static void fw_cfg_common_realize(DeviceState *dev, Error **errp)
         return;
     }
 
-    fw_cfg_add_bytes(s, FW_CFG_SIGNATURE, (char *)"QEMU", 4);
+    fw_cfg_add_bytes(s, FW_CFG_SIGNATURE, (char *)"QEMU", 4); // "QEMU"
     fw_cfg_add_bytes(s, FW_CFG_UUID, &qemu_uuid, 16);
     fw_cfg_add_i16(s, FW_CFG_NOGRAPHIC, (uint16_t)!machine->enable_graphics);
     fw_cfg_add_i16(s, FW_CFG_BOOT_MENU, (uint16_t)(machine->boot_config.has_menu && machine->boot_config.menu));
diff --git a/hw/pci-host/gpex.c b/hw/pci-host/gpex.c
index b806a22..3713551 100644
--- a/hw/pci-host/gpex.c
+++ b/hw/pci-host/gpex.c
@@ -243,7 +243,7 @@ static void gpex_root_class_init(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
 
     set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
-    dc->desc = "QEMU generic PCIe host bridge";
+    dc->desc = "Generic PCIe host bridge";
     dc->vmsd = &vmstate_gpex_root;
     k->vendor_id = PCI_VENDOR_ID_REDHAT;
     k->device_id = PCI_DEVICE_ID_REDHAT_PCIE_HOST;
diff --git a/hw/pci-host/q35.c b/hw/pci-host/q35.c
index 1951ae4..b8c313e 100644
--- a/hw/pci-host/q35.c
+++ b/hw/pci-host/q35.c
@@ -679,7 +679,7 @@ static void mch_class_init(ObjectClass *klass, const void *data)
     set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
     dc->desc = "Host bridge";
     dc->vmsd = &vmstate_mch;
-    k->vendor_id = PCI_VENDOR_ID_INTEL;
+    k->vendor_id = PCI_VENDOR_ID_AMD;
     /*
      * The 'q35' machine type implements an Intel Series 3 chipset,
      * of which there are several variants. The key difference between
diff --git a/hw/ppc/e500plat.c b/hw/ppc/e500plat.c
index 4f1d659..b54e0d9 100644
--- a/hw/ppc/e500plat.c
+++ b/hw/ppc/e500plat.c
@@ -22,7 +22,7 @@
 
 static void e500plat_fixup_devtree(void *fdt)
 {
-    const char model[] = "QEMU ppce500";
+    const char model[] = "ppce500";
     const char compatible[] = "fsl,qemu-e500";
 
     qemu_fdt_setprop(fdt, "/", "model", model, sizeof(model));
diff --git a/hw/ppc/pnv.c b/hw/ppc/pnv.c
index 9c74f46..5ae60b1 100644
--- a/hw/ppc/pnv.c
+++ b/hw/ppc/pnv.c
@@ -653,7 +653,7 @@ static void *pnv_dt_create(MachineState *machine)
     _FDT((fdt_create_empty_tree(fdt, FDT_MAX_SIZE)));
 
     /* /qemu node */
-    _FDT((fdt_add_subnode(fdt, 0, "qemu")));
+    _FDT((fdt_add_subnode(fdt, 0, "qemu"))); // "qemu"
 
     /* Root node */
     _FDT((fdt_setprop_cell(fdt, 0, "#address-cells", 0x2)));
diff --git a/hw/scsi/mptconfig.c b/hw/scsi/mptconfig.c
index 19d01f3..00ee3f8 100644
--- a/hw/scsi/mptconfig.c
+++ b/hw/scsi/mptconfig.c
@@ -189,12 +189,12 @@ static
 size_t mptsas_config_manufacturing_0(MPTSASState *s, uint8_t **data, int address)
 {
     return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,
-                              "s16s8s16s16s16",
-                              "QEMU MPT Fusion",
+                              "s10s4s85s45s34",
+                              "MPT Fusion",
                               "2.5",
-                              "QEMU MPT Fusion",
-                              "QEMU",
-                              "0000111122223333");
+                              "MPT Fusion",
+                              "MSI",
+                              "7624862998526197");
 }
 
 static
diff --git a/hw/scsi/scsi-bus.c b/hw/scsi/scsi-bus.c
index 9b12ee7..c0ef2fb 100644
--- a/hw/scsi/scsi-bus.c
+++ b/hw/scsi/scsi-bus.c
@@ -698,8 +698,8 @@ static bool scsi_target_emulate_inquiry(SCSITargetReq *r)
         r->buf[3] = 2 | 0x10; /* HiSup, response data format */
         r->buf[4] = r->len - 5; /* Additional Length = (Len - 1) - 4 */
         r->buf[7] = 0x10 | (r->req.bus->info->tcq ? 0x02 : 0); /* Sync, TCQ.  */
-        memcpy(&r->buf[8], "QEMU    ", 8);
-        memcpy(&r->buf[16], "QEMU TARGET     ", 16);
+        memcpy(&r->buf[8], "MSI     ", 8);
+        memcpy(&r->buf[16], "MSI TARGET      ", 16);
         pstrcpy((char *) &r->buf[32], 4, qemu_hw_version());
     }
     return true;
diff --git a/hw/scsi/scsi-disk.c b/hw/scsi/scsi-disk.c
index b4782c6..4dae33b 100644
--- a/hw/scsi/scsi-disk.c
+++ b/hw/scsi/scsi-disk.c
@@ -2544,7 +2544,7 @@ static void scsi_realize(SCSIDevice *dev, Error **errp)
         s->version = g_strdup(qemu_hw_version());
     }
     if (!s->vendor) {
-        s->vendor = g_strdup("QEMU");
+        s->vendor = g_strdup("Samsung");
     }
     if (s->serial && strlen(s->serial) > MAX_SERIAL_LEN) {
         error_setg(errp, "The serial number can't be longer than %d characters",
@@ -2608,7 +2608,7 @@ static void scsi_hd_realize(SCSIDevice *dev, Error **errp)
     s->qdev.blocksize = s->qdev.conf.logical_block_size;
     s->qdev.type = TYPE_DISK;
     if (!s->product) {
-        s->product = g_strdup("QEMU HARDDISK");
+        s->product = g_strdup("Samsung SSD 980 500GB");
     }
     scsi_realize(&s->qdev, errp);
 }
@@ -2635,7 +2635,7 @@ static void scsi_cd_realize(SCSIDevice *dev, Error **errp)
     s->qdev.type = TYPE_ROM;
     s->features |= 1 << SCSI_DISK_F_REMOVABLE;
     if (!s->product) {
-        s->product = g_strdup("QEMU CD-ROM");
+        s->product = g_strdup("CD-ROM");
     }
     scsi_realize(&s->qdev, errp);
 }
diff --git a/hw/scsi/spapr_vscsi.c b/hw/scsi/spapr_vscsi.c
index 20f70fb..3fcd992 100644
--- a/hw/scsi/spapr_vscsi.c
+++ b/hw/scsi/spapr_vscsi.c
@@ -713,8 +713,8 @@ static void vscsi_inquiry_no_target(VSCSIState *s, vscsi_req *req)
     resp_data[3] = 0x02;   /* Resp data format */
     resp_data[4] = 36 - 5; /* Additional length */
     resp_data[7] = 0x10;   /* Sync transfers */
-    memcpy(&resp_data[16], "QEMU EMPTY      ", 16);
-    memcpy(&resp_data[8], "QEMU    ", 8);
+    memcpy(&resp_data[16], "MSI EMPTY       ", 16);
+    memcpy(&resp_data[8], "MSI     ", 8);
 
     req->writing = 0;
     vscsi_preprocess_desc(req);
@@ -971,7 +971,7 @@ static int vscsi_send_adapter_info(VSCSIState *s, vscsi_req *req)
 #endif
     memset(&info, 0, sizeof(info));
     strcpy(info.srp_version, SRP_VERSION);
-    memcpy(info.partition_name, "qemu", sizeof("qemu"));
+    memcpy(info.partition_name, "msi", sizeof("msi"));
     info.partition_number = cpu_to_be32(0);
     info.mad_version = cpu_to_be32(1);
     info.os_type = cpu_to_be32(2);
diff --git a/hw/ufs/lu.c b/hw/ufs/lu.c
index 2d8ffd7..e0d2a92 100644
--- a/hw/ufs/lu.c
+++ b/hw/ufs/lu.c
@@ -184,8 +184,8 @@ static int ufs_emulate_wlun_inquiry(UfsRequest *req, uint8_t *outbuf,
     outbuf[5] = 0;
     outbuf[6] = 0;
     outbuf[7] = 0x2;
-    strpadcpy((char *)&outbuf[8], 8, "QEMU", ' ');
-    strpadcpy((char *)&outbuf[16], 16, "QEMU UFS", ' ');
+    strpadcpy((char *)&outbuf[8], 8, "MSI", ' ');
+    strpadcpy((char *)&outbuf[16], 16, "UFS", ' ');
     memset(&outbuf[32], 0, 4);
 
     return SCSI_INQUIRY_LEN;
diff --git a/hw/usb/canokey.c b/hw/usb/canokey.c
index cbefbb5..1998dd0 100644
--- a/hw/usb/canokey.c
+++ b/hw/usb/canokey.c
@@ -35,8 +35,8 @@ enum {
 
 static const USBDescStrings desc_strings = {
     [STR_MANUFACTURER]     = "canokeys.org",
-    [STR_PRODUCT]          = "CanoKey QEMU",
-    [STR_SERIALNUMBER]     = "0"
+    [STR_PRODUCT]          = "CanoKey",
+    [STR_SERIALNUMBER]     = "ORPEIJ8LEZ"
 };
 
 static const USBDescDevice desc_device_canokey = {
diff --git a/hw/usb/dev-audio.c b/hw/usb/dev-audio.c
index 26af709..3c281ad 100644
--- a/hw/usb/dev-audio.c
+++ b/hw/usb/dev-audio.c
@@ -73,9 +73,9 @@ enum usb_audio_strings {
 };
 
 static const USBDescStrings usb_audio_stringtable = {
-    [STRING_MANUFACTURER]       = "QEMU",
-    [STRING_PRODUCT]            = "QEMU USB Audio",
-    [STRING_SERIALNUMBER]       = "1",
+    [STRING_MANUFACTURER]       = "Logitech",
+    [STRING_PRODUCT]            = "USB Audio",
+    [STRING_SERIALNUMBER]       = "SCNU3K6LPU",
     [STRING_CONFIG]             = "Audio Configuration",
     [STRING_USBAUDIO_CONTROL]   = "Audio Device",
     [STRING_INPUT_TERMINAL]     = "Audio Output Pipe",
diff --git a/hw/usb/dev-hid.c b/hw/usb/dev-hid.c
index 96623aa..4dbf89f 100644
--- a/hw/usb/dev-hid.c
+++ b/hw/usb/dev-hid.c
@@ -63,17 +63,17 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
-    [STR_PRODUCT_MOUSE]    = "QEMU USB Mouse",
-    [STR_PRODUCT_TABLET]   = "QEMU USB Tablet",
-    [STR_PRODUCT_KEYBOARD] = "QEMU USB Keyboard",
-    [STR_SERIAL_COMPAT]    = "42",
+    [STR_MANUFACTURER]     = "Logitech",
+    [STR_PRODUCT_MOUSE]    = "USB Mouse",
+    [STR_PRODUCT_TABLET]   = "USB Tablet",
+    [STR_PRODUCT_KEYBOARD] = "USB Keyboard",
+    [STR_SERIAL_COMPAT]    = "N76POILMPP",
     [STR_CONFIG_MOUSE]     = "HID Mouse",
     [STR_CONFIG_TABLET]    = "HID Tablet",
     [STR_CONFIG_KEYBOARD]  = "HID Keyboard",
-    [STR_SERIAL_MOUSE]     = "89126",
-    [STR_SERIAL_TABLET]    = "28754",
-    [STR_SERIAL_KEYBOARD]  = "68284",
+    [STR_SERIAL_MOUSE]     = "1F6IT6W2IF",
+    [STR_SERIAL_TABLET]    = "WSS5T9RFVE",
+    [STR_SERIAL_KEYBOARD]  = "V96SH0F8ZX",
 };
 
 static const USBDescIface desc_iface_mouse = {
@@ -368,7 +368,7 @@ static const USBDescMSOS desc_msos_suspend = {
 
 static const USBDesc desc_mouse = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -382,7 +382,7 @@ static const USBDesc desc_mouse = {
 
 static const USBDesc desc_mouse2 = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -397,7 +397,7 @@ static const USBDesc desc_mouse2 = {
 
 static const USBDesc desc_tablet = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -411,7 +411,7 @@ static const USBDesc desc_tablet = {
 
 static const USBDesc desc_tablet2 = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -426,7 +426,7 @@ static const USBDesc desc_tablet2 = {
 
 static const USBDesc desc_keyboard = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -440,7 +440,7 @@ static const USBDesc desc_keyboard = {
 
 static const USBDesc desc_keyboard2 = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -805,7 +805,7 @@ static void usb_tablet_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_tablet_realize;
-    uc->product_desc   = "QEMU USB Tablet";
+    uc->product_desc   = "USB Tablet";
     dc->vmsd = &vmstate_usb_ptr;
     device_class_set_props(dc, usb_tablet_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
@@ -827,7 +827,7 @@ static void usb_mouse_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_mouse_realize;
-    uc->product_desc   = "QEMU USB Mouse";
+    uc->product_desc   = "USB Mouse";
     dc->vmsd = &vmstate_usb_ptr;
     device_class_set_props(dc, usb_mouse_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
@@ -850,7 +850,7 @@ static void usb_keyboard_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_keyboard_realize;
-    uc->product_desc   = "QEMU USB Keyboard";
+    uc->product_desc   = "USB Keyboard";
     dc->vmsd = &vmstate_usb_kbd;
     device_class_set_props(dc, usb_keyboard_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
diff --git a/hw/usb/dev-hub.c b/hw/usb/dev-hub.c
index a19350d..33aad4f 100644
--- a/hw/usb/dev-hub.c
+++ b/hw/usb/dev-hub.c
@@ -104,9 +104,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
-    [STR_PRODUCT]      = "QEMU USB Hub",
-    [STR_SERIALNUMBER] = "314159",
+    [STR_MANUFACTURER] = "Logitech",
+    [STR_PRODUCT]      = "USB Hub",
+    [STR_SERIALNUMBER] = "EPCEFDU54X",
 };
 
 static const USBDescIface desc_iface_hub = {
@@ -676,7 +676,7 @@ static void usb_hub_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_hub_realize;
-    uc->product_desc   = "QEMU USB Hub";
+    uc->product_desc   = "USB Hub";
     uc->usb_desc       = &desc_hub;
     uc->find_device    = usb_hub_find_device;
     uc->handle_reset   = usb_hub_handle_reset;
diff --git a/hw/usb/dev-mtp.c b/hw/usb/dev-mtp.c
index ce45c9c..e2b1ad7 100644
--- a/hw/usb/dev-mtp.c
+++ b/hw/usb/dev-mtp.c
@@ -247,8 +247,8 @@ OBJECT_DECLARE_SIMPLE_TYPE(MTPState, USB_MTP)
 
 /* ----------------------------------------------------------------------- */
 
-#define MTP_MANUFACTURER  "QEMU"
-#define MTP_PRODUCT       "QEMU filesharing"
+#define MTP_MANUFACTURER  "Microsoft"
+#define MTP_PRODUCT       "filesharing"
 #define MTP_WRITE_BUF_SZ  (512 * KiB)
 
 enum {
@@ -264,7 +264,7 @@ enum {
 static const USBDescStrings desc_strings = {
     [STR_MANUFACTURER] = MTP_MANUFACTURER,
     [STR_PRODUCT]      = MTP_PRODUCT,
-    [STR_SERIALNUMBER] = "34617",
+    [STR_SERIALNUMBER] = "FJFR36ZGFQ",
     [STR_MTP]          = "MTP",
     [STR_CONFIG_FULL]  = "Full speed config (usb 1.1)",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
@@ -2088,7 +2088,7 @@ static void usb_mtp_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_mtp_realize;
-    uc->product_desc   = "QEMU USB MTP";
+    uc->product_desc   = "USB MTP";
     uc->usb_desc       = &desc;
     uc->cancel_packet  = usb_mtp_cancel_packet;
     uc->handle_attach  = usb_desc_attach;
diff --git a/hw/usb/dev-network.c b/hw/usb/dev-network.c
index 1df2454..e399a10 100644
--- a/hw/usb/dev-network.c
+++ b/hw/usb/dev-network.c
@@ -99,16 +99,16 @@ enum usbstring_idx {
 #define ETH_FRAME_LEN                   1514 /* Max. octets in frame sans FCS */
 
 static const USBDescStrings usb_net_stringtable = {
-    [STRING_MANUFACTURER]       = "QEMU",
-    [STRING_PRODUCT]            = "RNDIS/QEMU USB Network Device",
-    [STRING_ETHADDR]            = "400102030405",
-    [STRING_DATA]               = "QEMU USB Net Data Interface",
-    [STRING_CONTROL]            = "QEMU USB Net Control Interface",
-    [STRING_RNDIS_CONTROL]      = "QEMU USB Net RNDIS Control Interface",
-    [STRING_CDC]                = "QEMU USB Net CDC",
-    [STRING_SUBSET]             = "QEMU USB Net Subset",
-    [STRING_RNDIS]              = "QEMU USB Net RNDIS",
-    [STRING_SERIALNUMBER]       = "1",
+    [STRING_MANUFACTURER]       = "Realtek",
+    [STRING_PRODUCT]            = "RNDIS/Realtek USB Network Device",
+    [STRING_ETHADDR]            = "4C82A94C9ECA",
+    [STRING_DATA]               = "USB Net Data Interface",
+    [STRING_CONTROL]            = "USB Net Control Interface",
+    [STRING_RNDIS_CONTROL]      = "USB Net RNDIS Control Interface",
+    [STRING_CDC]                = "USB Net CDC",
+    [STRING_SUBSET]             = "USB Net Subset",
+    [STRING_RNDIS]              = "USB Net RNDIS",
+    [STRING_SERIALNUMBER]       = "D9H87OLLOE",
 };
 
 static const USBDescIface desc_iface_rndis[] = {
@@ -717,7 +717,7 @@ static int ndis_query(USBNetState *s, uint32_t oid,
 
     /* mandatory */
     case OID_GEN_VENDOR_DESCRIPTION:
-        pstrcpy((char *)outbuf, outlen, "QEMU USB RNDIS Net");
+        pstrcpy((char *)outbuf, outlen, "USB RNDIS Net");
         return strlen((char *)outbuf) + 1;
 
     case OID_GEN_VENDOR_DRIVER_VERSION:
@@ -1417,7 +1417,7 @@ static void usb_net_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_net_realize;
-    uc->product_desc   = "QEMU USB Network Interface";
+    uc->product_desc   = "USB Network Interface";
     uc->usb_desc       = &desc_net;
     uc->handle_reset   = usb_net_handle_reset;
     uc->handle_control = usb_net_handle_control;
diff --git a/hw/usb/dev-serial.c b/hw/usb/dev-serial.c
index 1c116d8..358c745 100644
--- a/hw/usb/dev-serial.c
+++ b/hw/usb/dev-serial.c
@@ -119,10 +119,10 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]    = "QEMU",
-    [STR_PRODUCT_SERIAL]  = "QEMU USB SERIAL",
-    [STR_PRODUCT_BRAILLE] = "QEMU USB BAUM BRAILLE",
-    [STR_SERIALNUMBER]    = "1",
+    [STR_MANUFACTURER]    = "Microsoft",
+    [STR_PRODUCT_SERIAL]  = "USB SERIAL",
+    [STR_PRODUCT_BRAILLE] = "USB BAUM BRAILLE",
+    [STR_SERIALNUMBER]    = "6KCP6OG5KL",
 };
 
 static const USBDescIface desc_iface0 = {
@@ -663,7 +663,7 @@ static void usb_serial_class_initfn(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB Serial";
+    uc->product_desc   = "USB Serial";
     uc->usb_desc       = &desc_serial;
     device_class_set_props(dc, serial_properties);
 }
@@ -683,7 +683,7 @@ static void usb_braille_class_initfn(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB Braille";
+    uc->product_desc   = "USB Braille";
     uc->usb_desc       = &desc_braille;
     device_class_set_props(dc, braille_properties);
 }
diff --git a/hw/usb/dev-smartcard-reader.c b/hw/usb/dev-smartcard-reader.c
index 6ce7154..b02d281 100644
--- a/hw/usb/dev-smartcard-reader.c
+++ b/hw/usb/dev-smartcard-reader.c
@@ -80,8 +80,8 @@ OBJECT_DECLARE_SIMPLE_TYPE(USBCCIDState, USB_CCID_DEV)
 #define CCID_CONTROL_GET_CLOCK_FREQUENCIES  0x2
 #define CCID_CONTROL_GET_DATA_RATES         0x3
 
-#define CCID_PRODUCT_DESCRIPTION        "QEMU USB CCID"
-#define CCID_VENDOR_DESCRIPTION         "QEMU"
+#define CCID_PRODUCT_DESCRIPTION        "USB CCID"
+#define CCID_VENDOR_DESCRIPTION         "Identiv"
 #define CCID_INTERFACE_NAME             "CCID Interface"
 #define CCID_SERIAL_NUMBER_STRING       "1"
 /*
@@ -419,9 +419,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]  = "QEMU",
-    [STR_PRODUCT]       = "QEMU USB CCID",
-    [STR_SERIALNUMBER]  = "1",
+    [STR_MANUFACTURER]  = "Identiv",
+    [STR_PRODUCT]       = "USB CCID",
+    [STR_SERIALNUMBER]  = "L9Z3ZM8CDP",
     [STR_INTERFACE]     = "CCID Interface",
 };
 
@@ -1440,7 +1440,7 @@ static void ccid_class_initfn(ObjectClass *klass, const void *data)
     HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(klass);
 
     uc->realize        = ccid_realize;
-    uc->product_desc   = "QEMU USB CCID";
+    uc->product_desc   = "USB CCID";
     uc->usb_desc       = &desc_ccid;
     uc->handle_reset   = ccid_handle_reset;
     uc->handle_control = ccid_handle_control;
diff --git a/hw/usb/dev-storage.c b/hw/usb/dev-storage.c
index b13fe34..7680bee 100644
--- a/hw/usb/dev-storage.c
+++ b/hw/usb/dev-storage.c
@@ -47,9 +47,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
-    [STR_PRODUCT]      = "QEMU USB HARDDRIVE",
-    [STR_SERIALNUMBER] = "1",
+    [STR_MANUFACTURER] = "Samsung",
+    [STR_PRODUCT]      = "USB HARDDRIVE",
+    [STR_SERIALNUMBER] = "HLN8ILM0SH",
     [STR_CONFIG_FULL]  = "Full speed config (usb 1.1)",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
     [STR_CONFIG_SUPER] = "Super speed config (usb 3.0)",
@@ -590,7 +590,7 @@ static void usb_msd_class_initfn_common(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB MSD";
+    uc->product_desc   = "USB MSD";
     uc->usb_desc       = &desc;
     uc->cancel_packet  = usb_msd_cancel_io;
     uc->handle_attach  = usb_desc_attach;
diff --git a/hw/usb/dev-uas.c b/hw/usb/dev-uas.c
index 21cc283..d14a078 100644
--- a/hw/usb/dev-uas.c
+++ b/hw/usb/dev-uas.c
@@ -171,9 +171,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
+    [STR_MANUFACTURER] = "Microsoft",
     [STR_PRODUCT]      = "USB Attached SCSI HBA",
-    [STR_SERIALNUMBER] = "27842",
+    [STR_SERIALNUMBER] = "E5DEMH2Y7X",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
     [STR_CONFIG_SUPER] = "Super speed config (usb 3.0)",
 };
diff --git a/hw/usb/dev-wacom.c b/hw/usb/dev-wacom.c
index f4b71a2..ff724dd 100644
--- a/hw/usb/dev-wacom.c
+++ b/hw/usb/dev-wacom.c
@@ -64,9 +64,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
+    [STR_MANUFACTURER]     = "Wacom",
     [STR_PRODUCT]          = "Wacom PenPartner",
-    [STR_SERIALNUMBER]     = "1",
+    [STR_SERIALNUMBER]     = "718H83W0T4",
 };
 
 static const uint8_t qemu_wacom_hid_report_descriptor[] = {
@@ -231,7 +231,7 @@ static int usb_mouse_poll(USBWacomState *s, uint8_t *buf, int len)
 
     if (!s->mouse_grabbed) {
         s->eh_entry = qemu_add_mouse_event_handler(usb_mouse_event, s, 0,
-                        "QEMU PenPartner tablet");
+                        "PenPartner tablet");
         qemu_activate_mouse_event_handler(s->eh_entry);
         s->mouse_grabbed = 1;
     }
@@ -269,7 +269,7 @@ static int usb_wacom_poll(USBWacomState *s, uint8_t *buf, int len)
 
     if (!s->mouse_grabbed) {
         s->eh_entry = qemu_add_mouse_event_handler(usb_wacom_event, s, 1,
-                        "QEMU PenPartner tablet");
+                        "PenPartner tablet");
         qemu_activate_mouse_event_handler(s->eh_entry);
         s->mouse_grabbed = 1;
     }
@@ -425,7 +425,7 @@ static void usb_wacom_class_init(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU PenPartner Tablet";
+    uc->product_desc   = "PenPartner Tablet";
     uc->usb_desc       = &desc_wacom;
     uc->realize        = usb_wacom_realize;
     uc->handle_reset   = usb_wacom_handle_reset;
@@ -433,7 +433,7 @@ static void usb_wacom_class_init(ObjectClass *klass, const void *data)
     uc->handle_data    = usb_wacom_handle_data;
     uc->unrealize      = usb_wacom_unrealize;
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
-    dc->desc = "QEMU PenPartner Tablet";
+    dc->desc = "PenPartner Tablet";
     dc->vmsd = &vmstate_usb_wacom;
 }
 
diff --git a/hw/usb/u2f-emulated.c b/hw/usb/u2f-emulated.c
index ace5ece..8cb276a 100644
--- a/hw/usb/u2f-emulated.c
+++ b/hw/usb/u2f-emulated.c
@@ -385,7 +385,7 @@ static void u2f_emulated_class_init(ObjectClass *klass, const void *data)
     kc->realize = u2f_emulated_realize;
     kc->unrealize = u2f_emulated_unrealize;
     kc->recv_from_guest = u2f_emulated_recv_from_guest;
-    dc->desc = "QEMU U2F emulated key";
+    dc->desc = "U2F emulated key";
     device_class_set_props(dc, u2f_emulated_properties);
 }
 
diff --git a/hw/usb/u2f-passthru.c b/hw/usb/u2f-passthru.c
index fa8d9cd..cd4d451 100644
--- a/hw/usb/u2f-passthru.c
+++ b/hw/usb/u2f-passthru.c
@@ -528,7 +528,7 @@ static void u2f_passthru_class_init(ObjectClass *klass, const void *data)
     kc->realize = u2f_passthru_realize;
     kc->unrealize = u2f_passthru_unrealize;
     kc->recv_from_guest = u2f_passthru_recv_from_guest;
-    dc->desc = "QEMU U2F passthrough key";
+    dc->desc = "U2F passthrough key";
     dc->vmsd = &u2f_passthru_vmstate;
     device_class_set_props(dc, u2f_passthru_properties);
     set_bit(DEVICE_CATEGORY_MISC, dc->categories);
diff --git a/hw/usb/u2f.c b/hw/usb/u2f.c
index b051a99..a6c48cd 100644
--- a/hw/usb/u2f.c
+++ b/hw/usb/u2f.c
@@ -46,9 +46,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
+    [STR_MANUFACTURER]     = "Microsoft",
     [STR_PRODUCT]          = "U2F USB key",
-    [STR_SERIALNUMBER]     = "0",
+    [STR_SERIALNUMBER]     = "JFX4J5OICR",
     [STR_CONFIG]           = "U2F key config",
     [STR_INTERFACE]        = "U2F key interface"
 };
@@ -322,7 +322,7 @@ static void u2f_key_class_init(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU U2F USB key";
+    uc->product_desc   = "U2F USB key";
     uc->usb_desc       = &desc_u2f_key;
     uc->handle_reset   = u2f_key_handle_reset;
     uc->handle_control = u2f_key_handle_control;
@@ -330,7 +330,7 @@ static void u2f_key_class_init(ObjectClass *klass, const void *data)
     uc->handle_attach  = usb_desc_attach;
     uc->realize        = u2f_key_realize;
     uc->unrealize      = u2f_key_unrealize;
-    dc->desc           = "QEMU U2F key";
+    dc->desc           = "U2F key";
     dc->vmsd           = &vmstate_u2f_key;
 }
 
diff --git a/hw/vfio/ap.c b/hw/vfio/ap.c
index 7719f24..d0306c5 100644
--- a/hw/vfio/ap.c
+++ b/hw/vfio/ap.c
@@ -341,7 +341,7 @@ static void vfio_ap_class_init(ObjectClass *klass, const void *data)
     set_bit(DEVICE_CATEGORY_MISC, dc->categories);
     dc->realize = vfio_ap_realize;
     dc->unrealize = vfio_ap_unrealize;
-    dc->hotpluggable = true;
+    dc->hotpluggable = false;
     device_class_set_legacy_reset(dc, vfio_ap_reset);
     dc->bus_type = TYPE_AP_BUS;
 
diff --git a/include/hw/acpi/aml-build.h b/include/hw/acpi/aml-build.h
index c18f681..e3656c1 100644
--- a/include/hw/acpi/aml-build.h
+++ b/include/hw/acpi/aml-build.h
@@ -4,8 +4,8 @@
 #include "hw/acpi/acpi-defs.h"
 #include "hw/acpi/bios-linker-loader.h"
 
-#define ACPI_BUILD_APPNAME6 "BOCHS "
-#define ACPI_BUILD_APPNAME8 "BXPC    "
+#define ACPI_BUILD_APPNAME6 "ALASKA"
+#define ACPI_BUILD_APPNAME8 "A M I   "
 
 #define ACPI_BUILD_TABLE_FILE "etc/acpi/tables"
 #define ACPI_BUILD_RSDP_FILE "etc/acpi/rsdp"
diff --git a/include/hw/pci/pci.h b/include/hw/pci/pci.h
index 6b7d3ac..d1a163d 100644
--- a/include/hw/pci/pci.h
+++ b/include/hw/pci/pci.h
@@ -57,12 +57,12 @@ extern bool pci_available;
 #define PCI_DEVICE_ID_MARVELL_GT6412X    0x4620
 
 /* QEMU/Bochs VGA (0x1234) */
-#define PCI_VENDOR_ID_QEMU               0x1234
+#define PCI_VENDOR_ID_QEMU               0x1022 // "???" | AMD Vendor ID Replacement from 0x1234
 #define PCI_DEVICE_ID_QEMU_VGA           0x1111
 #define PCI_DEVICE_ID_QEMU_IPMI          0x1112
 
 /* VMWare (0x15ad) */
-#define PCI_VENDOR_ID_VMWARE             0x15ad
+#define PCI_VENDOR_ID_VMWARE             0x1022 // AMD Vendor ID Replacement from 0x15ad
 #define PCI_DEVICE_ID_VMWARE_SVGA2       0x0405
 #define PCI_DEVICE_ID_VMWARE_SVGA        0x0710
 #define PCI_DEVICE_ID_VMWARE_NET         0x0720
@@ -74,12 +74,12 @@ extern bool pci_available;
 /* Intel (0x8086) */
 #define PCI_DEVICE_ID_INTEL_82551IT      0x1209
 #define PCI_DEVICE_ID_INTEL_82557        0x1229
-#define PCI_DEVICE_ID_INTEL_82801IR      0x2922
+#define PCI_DEVICE_ID_INTEL_82801IR      0x790e // Intel 82801IR ICH9 - LPC Bridge [A2] | AMD Device ID Replacement from 0x2922 | hw/ide/ich.c
 
 /* Red Hat / Qumranet (for QEMU) -- see pci-ids.txt */
-#define PCI_VENDOR_ID_REDHAT_QUMRANET    0x1af4
-#define PCI_SUBVENDOR_ID_REDHAT_QUMRANET 0x1af4
-#define PCI_SUBDEVICE_ID_QEMU            0x1100
+#define PCI_VENDOR_ID_REDHAT_QUMRANET    0x1022 // AMD Vendor ID Replacement from 0x1af4
+#define PCI_SUBVENDOR_ID_REDHAT_QUMRANET 0x1022 // AMD Subvendor ID Replacement from 0x1af4
+#define PCI_SUBDEVICE_ID_QEMU            0x1022 // AMD Subdevice ID Replacement from 0x1100
 
 /* legacy virtio-pci devices */
 #define PCI_DEVICE_ID_VIRTIO_NET         0x1000
@@ -100,21 +100,21 @@ extern bool pci_available;
  */
 #define PCI_DEVICE_ID_VIRTIO_10_BASE     0x1040
 
-#define PCI_VENDOR_ID_REDHAT             0x1b36
-#define PCI_DEVICE_ID_REDHAT_BRIDGE      0x0001
-#define PCI_DEVICE_ID_REDHAT_SERIAL      0x0002
+#define PCI_VENDOR_ID_REDHAT             0x1022 // "Red Hat, Inc." | AMD Vendor ID Replacement from 0x1b36
+#define PCI_DEVICE_ID_REDHAT_BRIDGE      0x57a3 // "QEMU PCI-PCI bridge" | AMD Device ID Replacement from 0x0001 | hw/pci-bridge/pci_bridge_dev.c
+#define PCI_DEVICE_ID_REDHAT_SERIAL      0x0002 // TODO: find device_id | AMD Device ID Replacement from 0x???? | hw/char/serial-pci.c
 #define PCI_DEVICE_ID_REDHAT_SERIAL2     0x0003
 #define PCI_DEVICE_ID_REDHAT_SERIAL4     0x0004
 #define PCI_DEVICE_ID_REDHAT_TEST        0x0005
 #define PCI_DEVICE_ID_REDHAT_ROCKER      0x0006
 #define PCI_DEVICE_ID_REDHAT_SDHCI       0x0007
-#define PCI_DEVICE_ID_REDHAT_PCIE_HOST   0x0008
+#define PCI_DEVICE_ID_REDHAT_PCIE_HOST   0x1482 // "QEMU PCIe Host bridge" | AMD Device ID Replacement from 0x0008 | hw/pci-host/gpex.c
 #define PCI_DEVICE_ID_REDHAT_PXB         0x0009
 #define PCI_DEVICE_ID_REDHAT_BRIDGE_SEAT 0x000a
 #define PCI_DEVICE_ID_REDHAT_PXB_PCIE    0x000b
-#define PCI_DEVICE_ID_REDHAT_PCIE_RP     0x000c
-#define PCI_DEVICE_ID_REDHAT_XHCI        0x000d
-#define PCI_DEVICE_ID_REDHAT_PCIE_BRIDGE 0x000e
+#define PCI_DEVICE_ID_REDHAT_PCIE_RP     0x1483 // "QEMU PCIe Root Port" | AMD Device ID Replacement from 0x000c | hw/pci-bridge/gen_pcie_root_port.c
+#define PCI_DEVICE_ID_REDHAT_XHCI        0x149c // "QEMU XHCI Host Controller" | AMD Device ID Replacement from 0x000d | hw/usb/hcd-xhci-pci.c
+#define PCI_DEVICE_ID_REDHAT_PCIE_BRIDGE 0x57ad // "Red Hat, Device ID: 000E" | AMD Device ID Replacement from 0x000e | hw/pci-bridge/pcie_pci_bridge.c
 #define PCI_DEVICE_ID_REDHAT_MDPY        0x000f
 #define PCI_DEVICE_ID_REDHAT_NVME        0x0010
 #define PCI_DEVICE_ID_REDHAT_PVPANIC     0x0011
diff --git a/include/hw/pci/pci_ids.h b/include/hw/pci/pci_ids.h
index 33e2898..0f6e3e0 100644
--- a/include/hw/pci/pci_ids.h
+++ b/include/hw/pci/pci_ids.h
@@ -178,6 +178,7 @@
 #define PCI_VENDOR_ID_AMD                0x1022
 #define PCI_DEVICE_ID_AMD_LANCE          0x2000
 #define PCI_DEVICE_ID_AMD_SCSI           0x2020
+#define PCI_DEVICE_ID_AMD_SATA           0x43f6
 
 #define PCI_VENDOR_ID_HP                 0x103c
 
@@ -237,6 +238,8 @@
 #define PCI_VENDOR_ID_BAIDU              0x1d22
 #define PCI_DEVICE_ID_KUNLUN_VF          0x3685
 
+/* https://www.pcilookup.com/ */
+
 #define PCI_VENDOR_ID_INTEL              0x8086
 #define PCI_DEVICE_ID_INTEL_82378        0x0484
 #define PCI_DEVICE_ID_INTEL_82441        0x1237
@@ -246,8 +249,8 @@
 #define PCI_DEVICE_ID_INTEL_ESB_9        0x25ab
 #define PCI_DEVICE_ID_INTEL_NVME         0x5845
 #define PCI_DEVICE_ID_INTEL_82371SB_0    0x7000
-#define PCI_DEVICE_ID_INTEL_82371SB_1    0x7010
-#define PCI_DEVICE_ID_INTEL_82371SB_2    0x7020
+#define PCI_DEVICE_ID_INTEL_82371SB_1    0x7010 // TODO: | Intel 82371SB_1 - ??? | AMD Vendor ID Replacement from 0x???? | hw/ide/piix.c
+#define PCI_DEVICE_ID_INTEL_82371SB_2    0x7020 // TODO: | Intel 82371SB_2 - ??? | AMD Vendor ID Replacement from 0x???? | hw/usb/hcd-uhci.c
 #define PCI_DEVICE_ID_INTEL_82371AB_0    0x7110
 #define PCI_DEVICE_ID_INTEL_82371AB      0x7111
 #define PCI_DEVICE_ID_INTEL_82371AB_2    0x7112
@@ -259,9 +262,9 @@
 #define PCI_DEVICE_ID_INTEL_ICH9_3       0x2913
 #define PCI_DEVICE_ID_INTEL_ICH9_4       0x2914
 #define PCI_DEVICE_ID_INTEL_ICH9_5       0x2919
-#define PCI_DEVICE_ID_INTEL_ICH9_6       0x2930
+#define PCI_DEVICE_ID_INTEL_ICH9_6       0x790b // Intel 82801IB ICH9 - SMBus Controller [A2] | AMD Vendor ID Replacement from 0x2930 | hw/i2c/smbus_ich9.c
 #define PCI_DEVICE_ID_INTEL_ICH9_7       0x2916
-#define PCI_DEVICE_ID_INTEL_ICH9_8       0x2918
+#define PCI_DEVICE_ID_INTEL_ICH9_8       0x790e // Intel 82801IR ICH9 - LPC Bridge [A2] | AMD Vendor ID Replacement from 0x2918 | hw/isa/lpc_ich9.c
 
 #define PCI_DEVICE_ID_INTEL_82801I_UHCI1 0x2934
 #define PCI_DEVICE_ID_INTEL_82801I_UHCI2 0x2935
@@ -273,9 +276,9 @@
 #define PCI_DEVICE_ID_INTEL_82801I_EHCI2 0x293c
 #define PCI_DEVICE_ID_INTEL_82599_SFP_VF 0x10ed
 
-#define PCI_DEVICE_ID_INTEL_P35_MCH      0x29c0
+#define PCI_DEVICE_ID_INTEL_P35_MCH      0x1480 // Intel G33/P35/Q35/Q33 Chipset - Memory Controller Hub [A0] | AMD Vendor ID Replacement from 0x29c0 | hw/pci-host/q35.c
 
-#define PCI_VENDOR_ID_XEN                0x5853
+#define PCI_VENDOR_ID_XEN                0x1022 // AMD Vendor ID Replacement from 0x5853
 #define PCI_DEVICE_ID_XEN_PLATFORM       0x0001
 
 #define PCI_VENDOR_ID_NEC                0x1033
@@ -284,7 +287,7 @@
 #define PCI_VENDOR_ID_TEWS               0x1498
 #define PCI_DEVICE_ID_TEWS_TPCI200       0x30C8
 
-#define PCI_VENDOR_ID_VMWARE             0x15ad
+#define PCI_VENDOR_ID_VMWARE             0x1022 // AMD Vendor ID Replacement from 0x15ad
 #define PCI_DEVICE_ID_VMWARE_PVRDMA      0x0820
 
 #define PCI_VENDOR_ID_SYNOPSYS           0x16C3
diff --git a/include/standard-headers/linux/qemu_fw_cfg.h b/include/standard-headers/linux/qemu_fw_cfg.h
index cb93f66..fe34590 100644
--- a/include/standard-headers/linux/qemu_fw_cfg.h
+++ b/include/standard-headers/linux/qemu_fw_cfg.h
@@ -4,7 +4,7 @@
 
 #include "standard-headers/linux/types.h"
 
-#define FW_CFG_ACPI_DEVICE_ID	"QEMU0002"
+#define FW_CFG_ACPI_DEVICE_ID	"UEFI0002"
 
 /* selector key values for "well-known" fw_cfg entries */
 #define FW_CFG_SIGNATURE	0x00
@@ -71,7 +71,7 @@ struct fw_cfg_file {
 #define FW_CFG_DMA_CTL_SELECT	0x08
 #define FW_CFG_DMA_CTL_WRITE	0x10
 
-#define FW_CFG_DMA_SIGNATURE    0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE    0x51434f4d20434647ULL /* "QCOM CFG" */
 
 /* Control as first field allows for different structures selected by this
  * field, which might be useful in the future
diff --git a/migration/rdma.c b/migration/rdma.c
index 2d839fc..960871d 100644
--- a/migration/rdma.c
+++ b/migration/rdma.c
@@ -220,7 +220,7 @@ static const char *control_desc(unsigned int rdma_control)
         [RDMA_CONTROL_NONE] = "NONE",
         [RDMA_CONTROL_ERROR] = "ERROR",
         [RDMA_CONTROL_READY] = "READY",
-        [RDMA_CONTROL_QEMU_FILE] = "QEMU FILE",
+        [RDMA_CONTROL_QEMU_FILE] = "FILE",
         [RDMA_CONTROL_RAM_BLOCKS_REQUEST] = "RAM BLOCKS REQUEST",
         [RDMA_CONTROL_RAM_BLOCKS_RESULT] = "RAM BLOCKS RESULT",
         [RDMA_CONTROL_COMPRESS] = "COMPRESS",
diff --git a/pc-bios/optionrom/optionrom.h b/pc-bios/optionrom/optionrom.h
index 7bcdf0e..02dd06e 100644
--- a/pc-bios/optionrom/optionrom.h
+++ b/pc-bios/optionrom/optionrom.h
@@ -43,7 +43,7 @@
 #define FW_CFG_DMA_CTL_SELECT  0x08
 #define FW_CFG_DMA_CTL_WRITE   0x10
 
-#define FW_CFG_DMA_SIGNATURE 0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE 0x51434f4d20434647ULL /* "QCOM CFG" */
 
 #define BIOS_CFG_DMA_ADDR_HIGH  0x514
 #define BIOS_CFG_DMA_ADDR_LOW   0x518
diff --git a/pc-bios/s390-ccw/virtio-scsi.h b/pc-bios/s390-ccw/virtio-scsi.h
index c5612e1..048cb93 100644
--- a/pc-bios/s390-ccw/virtio-scsi.h
+++ b/pc-bios/s390-ccw/virtio-scsi.h
@@ -25,7 +25,7 @@
 #define VIRTIO_SCSI_S_OK                     0x00
 #define VIRTIO_SCSI_S_BAD_TARGET             0x03
 
-#define QEMU_CDROM_SIGNATURE "QEMU CD-ROM     "
+#define QEMU_CDROM_SIGNATURE "ASUS CD-ROM     "
 
 enum virtio_scsi_vq_id {
     VR_CONTROL  = 0,
diff --git a/qapi/ui.json b/qapi/ui.json
index 1b2f4a4..37f40fd 100644
--- a/qapi/ui.json
+++ b/qapi/ui.json
@@ -831,13 +831,13 @@
 #     -> { "execute": "query-mice" }
 #     <- { "return": [
 #              {
-#                 "name":"QEMU Microsoft Mouse",
+#                 "name":"Microsoft Mouse",
 #                 "index":0,
 #                 "current":false,
 #                 "absolute":false
 #              },
 #              {
-#                 "name":"QEMU PS/2 Mouse",
+#                 "name":"PS/2 Mouse",
 #                 "index":1,
 #                 "current":true,
 #                 "absolute":true
diff --git a/target/i386/cpu.c b/target/i386/cpu.c
index 25bbbf7..b3f6e21 100644
--- a/target/i386/cpu.c
+++ b/target/i386/cpu.c
@@ -922,7 +922,7 @@ void x86_cpu_vendor_words2str(char *dst, uint32_t vendor1,
           CPUID_EXT_MONITOR | CPUID_EXT_SSSE3 | CPUID_EXT_CX16 | \
           CPUID_EXT_SSE41 | CPUID_EXT_SSE42 | CPUID_EXT_POPCNT | \
           CPUID_EXT_XSAVE | /* CPUID_EXT_OSXSAVE is dynamic */   \
-          CPUID_EXT_MOVBE | CPUID_EXT_AES | CPUID_EXT_HYPERVISOR | \
+          CPUID_EXT_MOVBE | CPUID_EXT_AES | \
           CPUID_EXT_RDRAND | CPUID_EXT_AVX | CPUID_EXT_F16C | \
           CPUID_EXT_FMA | CPUID_EXT_X2APIC | CPUID_EXT_KERNEL_FEATURES)
           /* missing:
@@ -3309,7 +3309,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
         .features[FEAT_8000_0001_ECX] =
             CPUID_EXT3_LAHF_LM | CPUID_EXT3_SVM,
         .xlevel = 0x8000000A,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "AMD CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "phenom",
@@ -3424,7 +3424,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
              VMX_CPU_BASED_UNCOND_IO_EXITING | VMX_CPU_BASED_USE_IO_BITMAPS |
              VMX_CPU_BASED_MONITOR_EXITING | VMX_CPU_BASED_PAUSE_EXITING,
         .xlevel = 0x80000008,
-        .model_id = "Common KVM processor"
+        .model_id = "Common AMD processor"
     },
     {
         .name = "qemu32",
@@ -3438,7 +3438,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
         .features[FEAT_1_ECX] =
             CPUID_EXT_SSE3,
         .xlevel = 0x80000004,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "AMD CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "kvm32",
@@ -3468,7 +3468,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
              VMX_CPU_BASED_USE_IO_BITMAPS | VMX_CPU_BASED_MONITOR_EXITING |
              VMX_CPU_BASED_PAUSE_EXITING | VMX_CPU_BASED_USE_MSR_BITMAPS,
         .xlevel = 0x80000008,
-        .model_id = "Common 32-bit KVM processor"
+        .model_id = "Common 32-bit AMD processor"
     },
     {
         .name = "coreduo",
@@ -3568,7 +3568,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
         .features[FEAT_8000_0001_EDX] =
             CPUID_EXT2_MMXEXT | CPUID_EXT2_3DNOW | CPUID_EXT2_3DNOWEXT,
         .xlevel = 0x80000008,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "AMD CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "n270",
@@ -6745,7 +6745,7 @@ static void max_x86_cpu_initfn(Object *obj)
     }
     if (!env->cpuid_model[0]) {
         object_property_set_str(OBJECT(cpu), "model-id",
-                                "QEMU TCG CPU version " QEMU_HW_VERSION,
+                                "TCG CPU version " QEMU_HW_VERSION,
                                 &error_abort);
     }
 }
@@ -7724,8 +7724,6 @@ static void x86_cpu_load_model(X86CPU *cpu, const X86CPUModel *model)
     /* legacy-cache defaults to 'off' if CPU model provides cache info */
     cpu->legacy_cache = !x86_cpu_get_versioned_cache_info(cpu, model);
 
-    env->features[FEAT_1_ECX] |= CPUID_EXT_HYPERVISOR;
-
     /* sysenter isn't supported in compatibility mode on AMD,
      * syscall isn't supported in compatibility mode on Intel.
      * Normally we advertise the actual CPU vendor, but you can
@@ -8299,18 +8297,10 @@ void cpu_x86_cpuid(CPUX86State *env, uint32_t index, uint32_t count,
          * CPUID code in kvm_arch_init_vcpu() ignores stuff
          * set here, but we restrict to TCG none the less.
          */
-        if (tcg_enabled() && cpu->expose_tcg) {
-            memcpy(signature, "TCGTCGTCGTCG", 12);
-            *eax = 0x40000001;
-            *ebx = signature[0];
-            *ecx = signature[1];
-            *edx = signature[2];
-        } else {
-            *eax = 0;
-            *ebx = 0;
-            *ecx = 0;
-            *edx = 0;
-        }
+        *eax = 0;
+        *ebx = 0;
+        *ecx = 0;
+        *edx = 0;
         break;
     case 0x40000001:
         *eax = 0;
@@ -8767,10 +8757,11 @@ static void x86_cpu_reset_hold(Object *obj, ResetType type)
 void x86_cpu_after_reset(X86CPU *cpu)
 {
 #ifndef CONFIG_USER_ONLY
+#if 0
     if (kvm_enabled()) {
         kvm_arch_after_reset_vcpu(cpu);
     }
-
+#endif
     if (cpu->apic_state) {
         device_cold_reset(cpu->apic_state);
     }
@@ -9075,9 +9066,11 @@ void x86_cpu_expand_features(X86CPU *cpu, Error **errp)
         env->cpuid_xlevel2 = env->cpuid_min_xlevel2;
     }
 
+#if 0
     if (kvm_enabled() && !kvm_hyperv_expand_features(cpu, errp)) {
         return;
     }
+#endif
 }
 
 /*
@@ -9171,7 +9164,7 @@ static void x86_cpu_hyperv_realize(X86CPU *cpu)
 
     /* Hyper-V vendor id */
     if (!cpu->hyperv_vendor) {
-        object_property_set_str(OBJECT(cpu), "hv-vendor-id", "Microsoft Hv",
+        object_property_set_str(OBJECT(cpu), "hv-vendor-id", "",
                                 &error_abort);
     }
     len = strlen(cpu->hyperv_vendor);
@@ -9273,7 +9266,6 @@ static void x86_cpu_realizefn(DeviceState *dev, Error **errp)
      * Process Hyper-V enlightenments.
      * Note: this currently has to happen before the expansion of CPU features.
      */
-    x86_cpu_hyperv_realize(cpu);
 
     x86_cpu_expand_features(cpu, &local_err);
     if (local_err) {
diff --git a/target/i386/hvf/x86_cpuid.c b/target/i386/hvf/x86_cpuid.c
index 0798a0c..d965113 100644
--- a/target/i386/hvf/x86_cpuid.c
+++ b/target/i386/hvf/x86_cpuid.c
@@ -80,7 +80,6 @@ uint32_t hvf_get_supported_cpuid(uint32_t func, uint32_t idx,
              CPUID_EXT_POPCNT | CPUID_EXT_AES | CPUID_EXT_X2APIC |
              (supported_xcr0 ? CPUID_EXT_XSAVE : 0) |
              CPUID_EXT_AVX | CPUID_EXT_F16C | CPUID_EXT_RDRAND;
-        ecx |= CPUID_EXT_HYPERVISOR;
         break;
     case 6:
         eax = CPUID_6_EAX_ARAT;
diff --git a/target/i386/kvm/kvm-cpu.c b/target/i386/kvm/kvm-cpu.c
index 9c25b55..1ae774b 100644
--- a/target/i386/kvm/kvm-cpu.c
+++ b/target/i386/kvm/kvm-cpu.c
@@ -174,17 +174,6 @@ static void kvm_cpu_xsave_init(void)
  *       docs/system/target-i386.rst)
  */
 static PropValue kvm_default_props[] = {
-    { "kvmclock", "on" },
-    { "kvm-nopiodelay", "on" },
-    { "kvm-asyncpf", "on" },
-    { "kvm-steal-time", "on" },
-    { "kvm-pv-eoi", "on" },
-    { "kvmclock-stable-bit", "on" },
-    { "x2apic", "on" },
-    { "kvm-msi-ext-dest-id", "off" },
-    { "acpi", "off" },
-    { "monitor", "off" },
-    { "svm", "off" },
     { NULL, NULL },
 };
 
@@ -216,13 +205,6 @@ static void kvm_cpu_instance_init(CPUState *cs)
     host_cpu_instance_init(cpu);
 
     if (xcc->model) {
-        /* only applies to builtin_x86_defs cpus */
-        if (!kvm_irqchip_in_kernel()) {
-            x86_cpu_change_kvm_default("x2apic", "off");
-        } else if (kvm_irqchip_is_split()) {
-            x86_cpu_change_kvm_default("kvm-msi-ext-dest-id", "on");
-        }
-
         /* Special cases not set in the X86CPUDefinition structs: */
         x86_cpu_apply_props(cpu, kvm_default_props);
     }
diff --git a/target/i386/kvm/kvm.c b/target/i386/kvm/kvm.c
index 994b971..cfc574c 100644
--- a/target/i386/kvm/kvm.c
+++ b/target/i386/kvm/kvm.c
@@ -457,7 +457,7 @@ uint32_t kvm_arch_get_supported_cpuid(KVMState *s, uint32_t function,
         /* We can set the hypervisor flag, even if KVM does not return it on
          * GET_SUPPORTED_CPUID
          */
-        ret |= CPUID_EXT_HYPERVISOR;
+
         /* tsc-deadline flag is not returned by GET_SUPPORTED_CPUID, but it
          * can be enabled if the kernel has KVM_CAP_TSC_DEADLINE_TIMER,
          * and the irqchip is in the kernel.
@@ -1647,7 +1647,7 @@ static int hyperv_fill_cpuids(CPUState *cs,
         c->function = HV_CPUID_SYNDBG_VENDOR_AND_MAX_FUNCTIONS;
         c->eax = hyperv_feat_enabled(cpu, HYPERV_FEAT_EVMCS) ?
             HV_CPUID_NESTED_FEATURES : HV_CPUID_IMPLEMENT_LIMITS;
-        memcpy(signature, "Microsoft VS", 12);
+        memset(signature, 0, 12);
         c->eax = 0;
         c->ebx = signature[0];
         c->ecx = signature[1];
@@ -1655,7 +1655,7 @@ static int hyperv_fill_cpuids(CPUState *cs,
 
         c = &cpuid_ent[cpuid_i++];
         c->function = HV_CPUID_SYNDBG_INTERFACE;
-        memcpy(signature, "VS#1\0\0\0\0\0\0\0\0", 12);
+        memset(signature, 0, 12);
         c->eax = signature[0];
         c->ebx = 0;
         c->ecx = 0;
@@ -2145,6 +2145,7 @@ int kvm_arch_init_vcpu(CPUState *cs)
 
     env->apic_bus_freq = KVM_APIC_BUS_FREQUENCY;
 
+#if 0
     /*
      * kvm_hyperv_expand_features() is called here for the second time in case
      * KVM_CAP_SYS_HYPERV_CPUID is not supported. While we can't possibly handle
@@ -2173,7 +2174,7 @@ int kvm_arch_init_vcpu(CPUState *cs)
 #ifdef CONFIG_XEN_EMU
         struct kvm_cpuid_entry2 *xen_max_leaf;
 
-        memcpy(signature, "XenVMMXenVMM", 12);
+        memset(signature, 0, 12);
 
         xen_max_leaf = c = &cpuid_data.entries[cpuid_i++];
         c->function = kvm_base + XEN_CPUID_SIGNATURE;
@@ -2249,7 +2250,7 @@ int kvm_arch_init_vcpu(CPUState *cs)
         abort();
 #endif
     } else if (cpu->expose_kvm) {
-        memcpy(signature, "KVMKVMKVM\0\0\0", 12);
+        memset(signature, 0, 12);
         c = &cpuid_data.entries[cpuid_i++];
         c->function = KVM_CPUID_SIGNATURE | kvm_base;
         c->eax = KVM_CPUID_FEATURES | kvm_base;
@@ -2262,7 +2263,9 @@ int kvm_arch_init_vcpu(CPUState *cs)
         c->eax = env->features[FEAT_KVM];
         c->edx = env->features[FEAT_KVM_HINTS];
     }
+#endif
 
+#if 0
     if (cpu->kvm_pv_enforce_cpuid) {
         r = kvm_vcpu_enable_cap(cs, KVM_CAP_ENFORCE_PV_FEATURE_CPUID, 0, 1);
         if (r < 0) {
@@ -2272,6 +2275,7 @@ int kvm_arch_init_vcpu(CPUState *cs)
             abort();
         }
     }
+#endif
 
     cpuid_i = kvm_x86_build_cpuid(env, cpuid_data.entries, cpuid_i);
     cpuid_data.cpuid.nent = cpuid_i;
@@ -2344,6 +2348,7 @@ int kvm_arch_init_vcpu(CPUState *cs)
         }
     }
 
+#if 0
     if (cpu->vmware_cpuid_freq
         /* Guests depend on 0x40000000 to detect this feature, so only expose
          * it if KVM exposes leaf 0x40000000. (Conflicts with Hyper-V) */
@@ -2361,6 +2366,7 @@ int kvm_arch_init_vcpu(CPUState *cs)
         c = cpuid_find_entry(&cpuid_data.cpuid, kvm_base, 0);
         c->eax = MAX(c->eax, KVM_CPUID_SIGNATURE | 0x10);
     }
+#endif
 
     cpuid_data.cpuid.nent = cpuid_i;
 
@@ -2437,6 +2443,7 @@ void kvm_arch_reset_vcpu(X86CPU *cpu)
     sev_es_set_reset_vector(CPU(cpu));
 }
 
+#if 0
 void kvm_arch_after_reset_vcpu(X86CPU *cpu)
 {
     CPUX86State *env = &cpu->env;
@@ -2454,6 +2461,7 @@ void kvm_arch_after_reset_vcpu(X86CPU *cpu)
         hyperv_x86_synic_reset(cpu);
     }
 }
+#endif
 
 void kvm_arch_reset_parked_vcpu(unsigned long vcpu_id, int kvm_fd)
 {
diff --git a/target/s390x/cpu_models.c b/target/s390x/cpu_models.c
index 954a7a9..3f1fe01 100644
--- a/target/s390x/cpu_models.c
+++ b/target/s390x/cpu_models.c
@@ -954,7 +954,7 @@ static void s390_qemu_cpu_model_class_init(ObjectClass *oc, const void *data)
     S390CPUClass *xcc = S390_CPU_CLASS(oc);
 
     xcc->is_migration_safe = true;
-    xcc->desc = g_strdup_printf("QEMU Virtual CPU version %s",
+    xcc->desc = g_strdup_printf("CPU version %s",
                                 qemu_hw_version());
 }
 
diff --git a/target/s390x/tcg/misc_helper.c b/target/s390x/tcg/misc_helper.c
index e54338b..5ee4678 100644
--- a/target/s390x/tcg/misc_helper.c
+++ b/target/s390x/tcg/misc_helper.c
@@ -335,18 +335,18 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
             /* Basic Machine Configuration */
             char type[5] = {};
 
-            ebcdic_put(sysib.sysib_111.manuf, "QEMU            ", 16);
+            ebcdic_put(sysib.sysib_111.manuf, "AMD             ", 16);
             /* same as machine type number in STORE CPU ID, but in EBCDIC */
             snprintf(type, ARRAY_SIZE(type), "%X", cpu->model->def->type);
             ebcdic_put(sysib.sysib_111.type, type, 4);
             /* model number (not stored in STORE CPU ID for z/Architecture) */
-            ebcdic_put(sysib.sysib_111.model, "QEMU            ", 16);
-            ebcdic_put(sysib.sysib_111.sequence, "QEMU            ", 16);
-            ebcdic_put(sysib.sysib_111.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_111.model, "AMD             ", 16);
+            ebcdic_put(sysib.sysib_111.sequence, "AMD             ", 16);
+            ebcdic_put(sysib.sysib_111.plant, "AMD ", 4);
         } else if ((sel1 == 2) && (sel2 == 1)) {
             /* Basic Machine CPU */
-            ebcdic_put(sysib.sysib_121.sequence, "QEMUQEMUQEMUQEMU", 16);
-            ebcdic_put(sysib.sysib_121.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_121.sequence, "AMDAMDAMDAMDAMDA", 16);
+            ebcdic_put(sysib.sysib_121.plant, "AMD ", 4);
             sysib.sysib_121.cpu_addr = cpu_to_be16(env->core_id);
         } else if ((sel1 == 2) && (sel2 == 2)) {
             /* Basic Machine CPUs */
@@ -361,8 +361,8 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
     case STSI_R0_FC_LEVEL_2:
         if ((sel1 == 2) && (sel2 == 1)) {
             /* LPAR CPU */
-            ebcdic_put(sysib.sysib_221.sequence, "QEMUQEMUQEMUQEMU", 16);
-            ebcdic_put(sysib.sysib_221.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_221.sequence, "AMDAMDAMDAMDAMDA", 16);
+            ebcdic_put(sysib.sysib_221.plant, "AMD ", 4);
             sysib.sysib_221.cpu_addr = cpu_to_be16(env->core_id);
         } else if ((sel1 == 2) && (sel2 == 2)) {
             /* LPAR CPUs */
@@ -370,7 +370,7 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
             sysib.sysib_222.total_cpus = cpu_to_be16(total_cpus);
             sysib.sysib_222.conf_cpus = cpu_to_be16(conf_cpus);
             sysib.sysib_222.reserved_cpus = cpu_to_be16(reserved_cpus);
-            ebcdic_put(sysib.sysib_222.name, "QEMU    ", 8);
+            ebcdic_put(sysib.sysib_222.name, "AMD     ", 8);
             sysib.sysib_222.caf = cpu_to_be32(1000);
             sysib.sysib_222.dedicated_cpus = cpu_to_be16(conf_cpus);
         } else {
@@ -386,7 +386,7 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
             sysib.sysib_322.vm[0].reserved_cpus = cpu_to_be16(reserved_cpus);
             sysib.sysib_322.vm[0].caf = cpu_to_be32(1000);
             /* Linux kernel uses this to distinguish us from z/VM */
-            ebcdic_put(sysib.sysib_322.vm[0].cpi, "KVM/Linux       ", 16);
+            ebcdic_put(sysib.sysib_322.vm[0].cpi, "AMD             ", 16);
             sysib.sysib_322.vm[0].ext_name_encoding = 2; /* UTF-8 */
 
             /* If our VM has a name, use the real name */

```

`patches/QEMU/Archive/amd-qemu-9.2.4.patch`:

```patch
diff --git a/block/vhdx.c b/block/vhdx.c
index 5aa1a13..b7e7bed 100644
--- a/block/vhdx.c
+++ b/block/vhdx.c
@@ -2020,7 +2020,7 @@ vhdx_co_create(BlockdevCreateOptions *opts, Error **errp)
 
     /* The creator field is optional, but may be useful for
      * debugging / diagnostics */
-    creator = g_utf8_to_utf16("QEMU v" QEMU_VERSION, -1, NULL,
+    creator = g_utf8_to_utf16("Microsoft v" QEMU_VERSION, -1, NULL,
                               &creator_items, NULL);
     signature = cpu_to_le64(VHDX_FILE_SIGNATURE);
     ret = blk_co_pwrite(blk, VHDX_FILE_ID_OFFSET, sizeof(signature), &signature,
diff --git a/block/vvfat.c b/block/vvfat.c
index 8ffe8b3..8baad6d 100644
--- a/block/vvfat.c
+++ b/block/vvfat.c
@@ -1177,7 +1177,7 @@ static int vvfat_open(BlockDriverState *bs, QDict *options, int flags,
         }
         memcpy(s->volume_label, label, label_length);
     } else {
-        memcpy(s->volume_label, "QEMU VVFAT", 10);
+        memcpy(s->volume_label, "ASUS VVFAT", 10);
     }
 
     if (floppy) {
diff --git a/chardev/msmouse.c b/chardev/msmouse.c
index 2279694..33cea79 100644
--- a/chardev/msmouse.c
+++ b/chardev/msmouse.c
@@ -172,7 +172,7 @@ static int msmouse_chr_write(struct Chardev *s, const uint8_t *buf, int len)
 }
 
 static const QemuInputHandler msmouse_handler = {
-    .name  = "QEMU Microsoft Mouse",
+    .name  = "Microsoft Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = msmouse_input_event,
     .sync  = msmouse_input_sync,
diff --git a/chardev/wctablet.c b/chardev/wctablet.c
index f4008bf..6aeccdb 100644
--- a/chardev/wctablet.c
+++ b/chardev/wctablet.c
@@ -179,7 +179,7 @@ static void wctablet_input_sync(DeviceState *dev)
 }
 
 static const QemuInputHandler wctablet_handler = {
-    .name  = "QEMU Wacom Pen Tablet",
+    .name  = "Wacom Pen Tablet",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_ABS,
     .event = wctablet_input_event,
     .sync  = wctablet_input_sync,
diff --git a/contrib/vhost-user-gpu/vhost-user-gpu.c b/contrib/vhost-user-gpu/vhost-user-gpu.c
index bb41758..dbd2777 100644
--- a/contrib/vhost-user-gpu/vhost-user-gpu.c
+++ b/contrib/vhost-user-gpu/vhost-user-gpu.c
@@ -1254,7 +1254,7 @@ main(int argc, char *argv[])
     QTAILQ_INIT(&g.reslist);
     QTAILQ_INIT(&g.fenceq);
 
-    context = g_option_context_new("QEMU vhost-user-gpu");
+    context = g_option_context_new("vhost-user-gpu");
     g_option_context_add_main_entries(context, entries, NULL);
     if (!g_option_context_parse(context, &argc, &argv, &error)) {
         g_printerr("Option parsing failed: %s\n", error->message);
diff --git a/hw/acpi/aml-build.c b/hw/acpi/aml-build.c
index 72282b1..06b1187 100644
--- a/hw/acpi/aml-build.c
+++ b/hw/acpi/aml-build.c
@@ -1723,11 +1723,11 @@ void acpi_table_begin(AcpiTable *desc, GArray *array)
     build_append_int_noprefix(array, 0, 4); /* Length */
     build_append_int_noprefix(array, desc->rev, 1); /* Revision */
     build_append_int_noprefix(array, 0, 1); /* Checksum */
-    build_append_padded_str(array, desc->oem_id, 6, '\0'); /* OEMID */
+    build_append_padded_str(array, ACPI_BUILD_APPNAME6, 6, '\0'); /* OEMID */
     /* OEM Table ID */
-    build_append_padded_str(array, desc->oem_table_id, 8, '\0');
+    build_append_padded_str(array, ACPI_BUILD_APPNAME8, 8, '\0');
     build_append_int_noprefix(array, 1, 4); /* OEM Revision */
-    g_array_append_vals(array, ACPI_BUILD_APPNAME8, 4); /* Creator ID */
+    g_array_append_vals(array, "ACPI", 4); /* Creator ID */
     build_append_int_noprefix(array, 1, 4); /* Creator Revision */
 }
 
@@ -2236,7 +2236,7 @@ void build_fadt(GArray *tbl, BIOSLinker *linker, const AcpiFadtData *f,
     /* ACPI1.0: INT_MODEL, ACPI2.0+: Reserved */
     build_append_int_noprefix(tbl, f->int_model /* Multiple APIC */, 1);
     /* Preferred_PM_Profile */
-    build_append_int_noprefix(tbl, 0 /* Unspecified */, 1);
+    build_append_int_noprefix(tbl, 1 /* Desktop */, 1);
     build_append_int_noprefix(tbl, f->sci_int, 2); /* SCI_INT */
     build_append_int_noprefix(tbl, f->smi_cmd, 4); /* SMI_CMD */
     build_append_int_noprefix(tbl, f->acpi_enable_cmd, 1); /* ACPI_ENABLE */
@@ -2333,7 +2333,7 @@ void build_fadt(GArray *tbl, BIOSLinker *linker, const AcpiFadtData *f,
     }
 
     /* Hypervisor Vendor Identity */
-    build_append_padded_str(tbl, "QEMU", 8, '\0');
+    build_append_padded_str(tbl, "", 8, '\0');
 
     /* TODO: extra fields need to be added to support revisions above rev6 */
     assert(f->rev == 6);
diff --git a/hw/arm/sbsa-ref.c b/hw/arm/sbsa-ref.c
index e9985a5..a115c11 100644
--- a/hw/arm/sbsa-ref.c
+++ b/hw/arm/sbsa-ref.c
@@ -894,7 +894,7 @@ static void sbsa_ref_class_init(ObjectClass *oc, void *data)
     };
 
     mc->init = sbsa_ref_init;
-    mc->desc = "QEMU 'SBSA Reference' ARM Virtual Machine";
+    mc->desc = "Qualcomm 'Reference' ARM SoC";
     mc->default_cpu_type = ARM_CPU_TYPE_NAME("neoverse-n2");
     mc->valid_cpu_types = valid_cpu_types;
     mc->max_cpus = 512;
diff --git a/hw/arm/virt.c b/hw/arm/virt.c
index 5fa045c..cd7d0a8 100644
--- a/hw/arm/virt.c
+++ b/hw/arm/virt.c
@@ -110,7 +110,7 @@ static void arm_virt_compat_set(MachineClass *mc)
         MachineClass *mc = MACHINE_CLASS(oc); \
         arm_virt_compat_set(mc); \
         MACHINE_VER_SYM(options, virt, __VA_ARGS__)(mc); \
-        mc->desc = "QEMU " MACHINE_VER_STR(__VA_ARGS__) " ARM Virtual Machine"; \
+        mc->desc = "AMD  " MACHINE_VER_STR(__VA_ARGS__) " ARM Machine"; \
         MACHINE_VER_DEPRECATION(__VA_ARGS__); \
         if (latest) { \
             mc->alias = "virt"; \
@@ -1699,13 +1699,13 @@ static void virt_build_smbios(VirtMachineState *vms)
     uint8_t *smbios_tables, *smbios_anchor;
     size_t smbios_tables_len, smbios_anchor_len;
     struct smbios_phys_mem_area mem_array;
-    const char *product = "QEMU Virtual Machine";
+    const char *product = "AMD Machine";
 
     if (kvm_enabled()) {
-        product = "KVM Virtual Machine";
+        product = "AMD Machine";
     }
 
-    smbios_set_defaults("QEMU", product,
+    smbios_set_defaults("Unknown", product,
                         vmc->smbios_old_sys_ver ? "1.0" : mc->name);
 
     /* build the array of physical mem area from base_memmap */
diff --git a/hw/audio/hda-codec.c b/hw/audio/hda-codec.c
index c340a94..8d466cb 100644
--- a/hw/audio/hda-codec.c
+++ b/hw/audio/hda-codec.c
@@ -118,7 +118,7 @@ static void hda_codec_parse_fmt(uint32_t format, struct audsettings *as)
 
 /* some defines */
 
-#define QEMU_HDA_ID_VENDOR  0x1af4
+#define QEMU_HDA_ID_VENDOR  0x10EC
 #define QEMU_HDA_PCM_FORMATS (AC_SUPPCM_BITS_16 |       \
                               0x1fc /* 16 -> 96 kHz */)
 #define QEMU_HDA_AMP_NONE    (0)
diff --git a/hw/audio/intel-hda.c b/hw/audio/intel-hda.c
index 6918e23..8b18030 100644
--- a/hw/audio/intel-hda.c
+++ b/hw/audio/intel-hda.c
@@ -1241,7 +1241,7 @@ static void intel_hda_class_init_ich6(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->device_id = 0x2668;
+    k->device_id = 0x51c8; // "Intel 82801IB ICH6 - High Definition Audio [A3]" | Intel Device ID Replacement from 0x2668 | hw/audio/intel-hda.c
     k->revision = 1;
     set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
     dc->desc = "Intel HD Audio Controller (ich6)";
@@ -1252,8 +1252,8 @@ static void intel_hda_class_init_ich9(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->device_id = 0x293e;
-    k->revision = 3;
+    k->device_id = 0x51c8; // "Intel 82801IB ICH9 - High Definition Audio [A3]" | Intel Device ID Replacement from 0x293e | hw/audio/intel-hda.c
+    k->revision = 1;
     set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
     dc->desc = "Intel HD Audio Controller (ich9)";
 }
diff --git a/hw/char/escc.c b/hw/char/escc.c
index b1b1bbe..a9d1f88 100644
--- a/hw/char/escc.c
+++ b/hw/char/escc.c
@@ -1037,7 +1037,7 @@ static void sunmouse_sync(DeviceState *dev)
 }
 
 static const QemuInputHandler sunmouse_handler = {
-    .name  = "QEMU Sun Mouse",
+    .name  = "Sun Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = sunmouse_handle_event,
     .sync  = sunmouse_sync,
diff --git a/hw/core/qdev.c b/hw/core/qdev.c
index 5f13111..b059f42 100644
--- a/hw/core/qdev.c
+++ b/hw/core/qdev.c
@@ -746,7 +746,7 @@ static void device_class_init(ObjectClass *class, void *data)
      * hotpluggable. Devices that shouldn't be hotpluggable,
      * should override it in their class_init()
      */
-    dc->hotpluggable = true;
+    dc->hotpluggable = false;
     dc->user_creatable = true;
     vc->get_id = device_vmstate_if_get_id;
     rc->get_state = device_get_reset_state;
diff --git a/hw/display/edid-generate.c b/hw/display/edid-generate.c
index 2cb8196..630a33b 100644
--- a/hw/display/edid-generate.c
+++ b/hw/display/edid-generate.c
@@ -388,22 +388,22 @@ void qemu_edid_generate(uint8_t *edid, size_t size,
     uint8_t *did = NULL;
     uint32_t width_mm, height_mm;
     uint32_t refresh_rate = info->refresh_rate ? info->refresh_rate : 75000;
-    uint32_t dpi = 100; /* if no width_mm/height_mm */
+    uint32_t dpi = 82; /* if no width_mm/height_mm */
     uint32_t large_screen = 0;
 
     /* =============== set defaults  =============== */
 
     if (!info->vendor || strlen(info->vendor) != 3) {
-        info->vendor = "RHT";
+        info->vendor = "MSI";
     }
     if (!info->name) {
-        info->name = "QEMU Monitor";
+        info->name = "G27C4X";
     }
     if (!info->prefx) {
-        info->prefx = 1280;
+        info->prefx = 1920;
     }
     if (!info->prefy) {
-        info->prefy = 800;
+        info->prefy = 1080;
     }
     if (info->width_mm && info->height_mm) {
         width_mm = info->width_mm;
@@ -449,15 +449,15 @@ void qemu_edid_generate(uint8_t *edid, size_t size,
     uint16_t vendor_id = ((((info->vendor[0] - '@') & 0x1f) << 10) |
                           (((info->vendor[1] - '@') & 0x1f) <<  5) |
                           (((info->vendor[2] - '@') & 0x1f) <<  0));
-    uint16_t model_nr = 0x1234;
+    uint16_t model_nr = 0x10ad;
     uint32_t serial_nr = info->serial ? atoi(info->serial) : 0;
     stw_be_p(edid +  8, vendor_id);
     stw_le_p(edid + 10, model_nr);
     stl_le_p(edid + 12, serial_nr);
 
     /* manufacture week and year */
-    edid[16] = 42;
-    edid[17] = 2014 - 1990;
+    edid[16] = 12;
+    edid[17] = 2025 - 2018;
 
     /* edid version */
     edid[18] = 1;
diff --git a/hw/display/qxl.c b/hw/display/qxl.c
index 0c4b1c9..66941b3 100644
--- a/hw/display/qxl.c
+++ b/hw/display/qxl.c
@@ -2483,7 +2483,7 @@ static void qxl_pci_class_init(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->vendor_id = REDHAT_PCI_VENDOR_ID;
+    k->vendor_id = PCI_VENDOR_ID_REDHAT;
     k->device_id = QXL_DEVICE_ID_STABLE;
     set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);
     device_class_set_legacy_reset(dc, qxl_reset_handler);
diff --git a/hw/i386/acpi-build.c b/hw/i386/acpi-build.c
index f7b961e..999993d 100644
--- a/hw/i386/acpi-build.c
+++ b/hw/i386/acpi-build.c
@@ -2580,9 +2580,6 @@ void acpi_build(AcpiBuildTables *tables, MachineState *machine)
                        x86ms->oem_id, x86ms->oem_table_id, &pcms->cxl_devices_state);
     }
 
-    acpi_add_table(table_offsets, tables_blob);
-    build_waet(tables_blob, tables->linker, x86ms->oem_id, x86ms->oem_table_id);
-
     /* Add tables supplied by user (if any) */
     for (u = acpi_table_first(); u; u = acpi_table_next(u)) {
         unsigned len = acpi_table_len(u);
@@ -2591,6 +2588,15 @@ void acpi_build(AcpiBuildTables *tables, MachineState *machine)
         g_array_append_vals(tables_blob, u, len);
     }
 
+    /* Disable BGRT (UEFI Logo)
+    acpi_add_table(table_offsets, tables_blob);
+    AcpiTable table = { .sig = "BGRT", .rev = 1,
+                        .oem_id = x86ms->oem_id, .oem_table_id = x86ms->oem_table_id };
+    acpi_table_begin(&table, tables_blob);
+    build_append_int_noprefix(tables_blob,0x00000000,4);
+    acpi_table_end(tables->linker, &table);
+    */
+
     /* RSDT is pointed to by RSDP */
     rsdt = tables_blob->len;
     build_rsdt(tables_blob, tables->linker, table_offsets,
diff --git a/hw/i386/fw_cfg.c b/hw/i386/fw_cfg.c
index 0e44946..efdea2f 100644
--- a/hw/i386/fw_cfg.c
+++ b/hw/i386/fw_cfg.c
@@ -73,7 +73,7 @@ void fw_cfg_build_smbios(PCMachineState *pcms, FWCfgState *fw_cfg,
 
     if (pcmc->smbios_defaults) {
         /* These values are guest ABI, do not change */
-        smbios_set_defaults("QEMU", mc->desc, mc->name);
+        smbios_set_defaults("Unknown", mc->desc, mc->name);
     }
 
     /* tell smbios about cpuid version and features */
@@ -210,6 +210,14 @@ void fw_cfg_build_feature_control(MachineState *ms, FWCfgState *fw_cfg)
     fw_cfg_add_file(fw_cfg, "etc/msr_feature_control", val, sizeof(*val));
 }
 
+/*
+ *
+ * TODO: In the future we might need to disable this entire function from being used.
+ * Would need to disable this function from being called in two other files also:
+ * "hw/i386/acpi-microvm.c" and "hw/i386/acpi-build.c"
+ *
+ */
+
 #ifdef CONFIG_ACPI
 void fw_cfg_add_acpi_dsdt(Aml *scope, FWCfgState *fw_cfg)
 {
@@ -223,10 +231,10 @@ void fw_cfg_add_acpi_dsdt(Aml *scope, FWCfgState *fw_cfg)
     uint8_t io_size = object_property_get_bool(obj, "dma_enabled", NULL) ?
         ROUND_UP(FW_CFG_CTL_SIZE, 4) + sizeof(dma_addr_t) :
         FW_CFG_CTL_SIZE;
-    Aml *dev = aml_device("FWCF");
+    Aml *dev = aml_device("FWCG");
     Aml *crs = aml_resource_template();
 
-    aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0002")));
+    aml_append(dev, aml_name_decl("_HID", aml_string("UEFI0002")));
 
     /* device present, functioning, decoding, not shown in UI */
     aml_append(dev, aml_name_decl("_STA", aml_int(0xB)));
diff --git a/hw/i386/multiboot.c b/hw/i386/multiboot.c
index b2648bf..0a7e0c6 100644
--- a/hw/i386/multiboot.c
+++ b/hw/i386/multiboot.c
@@ -102,7 +102,7 @@ typedef struct {
     int mb_mods_count;
 } MultibootState;
 
-const char *bootloader_name = "qemu";
+const char *bootloader_name = "Windows Boot Manager";
 
 static uint32_t mb_add_cmdline(MultibootState *s, const char *cmdline)
 {
diff --git a/hw/i386/pc.c b/hw/i386/pc.c
index 9b89b51..f496edc 100644
--- a/hw/i386/pc.c
+++ b/hw/i386/pc.c
@@ -75,9 +75,9 @@
  * depending on QEMU versions up to QEMU 2.4.
  */
 #define PC_CPU_MODEL_IDS(v) \
-    { "qemu32-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },\
-    { "qemu64-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },\
-    { "athlon-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },
+    { "qemu32-" TYPE_X86_CPU, "model-id", "CPU version " v, },\
+    { "qemu64-" TYPE_X86_CPU, "model-id", "CPU version " v, },\
+    { "athlon-" TYPE_X86_CPU, "model-id", "CPU version " v, },
 
 GlobalProperty pc_compat_9_1[] = {
     { "ICH9-LPC", "x-smi-swsmi-timer", "off" },
@@ -1766,7 +1766,7 @@ static void pc_machine_class_init(ObjectClass *oc, void *data)
 
     pcmc->pci_enabled = true;
     pcmc->has_acpi_build = true;
-    pcmc->smbios_defaults = true;
+    pcmc->smbios_defaults = false;
     pcmc->gigabyte_align = true;
     pcmc->has_reserved_memory = true;
     pcmc->enforce_amd_1tb_hole = true;
diff --git a/hw/i386/pc_piix.c b/hw/i386/pc_piix.c
index 2bf6865..9dac847 100644
--- a/hw/i386/pc_piix.c
+++ b/hw/i386/pc_piix.c
@@ -456,12 +456,12 @@ static void pc_i440fx_machine_options(MachineClass *m)
     pcmc->pci_root_uid = 0;
     pcmc->default_cpu_version = 1;
 
-    m->family = "pc_piix";
-    m->desc = "Standard PC (i440FX + PIIX, 1996)";
+    m->family = "pc_x570";
+    m->desc = "AMD Ryzen 7 7700X 8-Core Processor";
     m->default_machine_opts = "firmware=bios-256k.bin";
-    m->default_display = "std";
-    m->default_nic = "e1000";
-    m->no_floppy = !module_object_class_by_name(TYPE_ISA_FDC);
+    m->default_display = "none";
+    m->default_nic = "rtl8139"; // Realtek PCI Express Gigabit Ethernet Controller
+    m->no_floppy = 1;
     m->no_parallel = !module_object_class_by_name(TYPE_ISA_PARALLEL);
     machine_class_allow_dynamic_sysbus_dev(m, TYPE_RAMFB_DEVICE);
     machine_class_allow_dynamic_sysbus_dev(m, TYPE_VMBUS_BRIDGE);
@@ -499,7 +499,7 @@ static void pc_i440fx_machine_9_0_options(MachineClass *m)
     PCMachineClass *pcmc = PC_MACHINE_CLASS(m);
 
     pc_i440fx_machine_9_1_options(m);
-    m->smbios_memory_device_size = 16 * GiB;
+    m->smbios_memory_device_size = 8 * GiB; // Default is 16GB per stick; Change to more common 8 GB per stick instead.
 
     compat_props_add(m->compat_props, hw_compat_9_0, hw_compat_9_0_len);
     compat_props_add(m->compat_props, pc_compat_9_0, pc_compat_9_0_len);
diff --git a/hw/i386/pc_q35.c b/hw/i386/pc_q35.c
index 8319b6d..b7d63a9 100644
--- a/hw/i386/pc_q35.c
+++ b/hw/i386/pc_q35.c
@@ -338,12 +338,12 @@ static void pc_q35_machine_options(MachineClass *m)
     pcmc->pci_root_uid = 0;
     pcmc->default_cpu_version = 1;
 
-    m->family = "pc_q35";
-    m->desc = "Standard PC (Q35 + ICH9, 2009)";
+    m->family = "pc_x570";
+    m->desc = "AMD Ryzen 7 7700X 8-Core Processor";
     m->units_per_default_bus = 1;
     m->default_machine_opts = "firmware=bios-256k.bin";
-    m->default_display = "std";
-    m->default_nic = "e1000e";
+    m->default_display = "none";
+    m->default_nic = "rtl8139"; // Realtek PCI Express Gigabit Ethernet Controller
     m->default_kernel_irqchip_split = false;
     m->no_floppy = 1;
     m->max_cpus = 4096;
@@ -378,7 +378,7 @@ static void pc_q35_machine_9_0_options(MachineClass *m)
 {
     PCMachineClass *pcmc = PC_MACHINE_CLASS(m);
     pc_q35_machine_9_1_options(m);
-    m->smbios_memory_device_size = 16 * GiB;
+    m->smbios_memory_device_size = 8 * GiB; // Default is 16GB per stick; Change to more common 8 GB per stick instead.
     compat_props_add(m->compat_props, hw_compat_9_0, hw_compat_9_0_len);
     compat_props_add(m->compat_props, pc_compat_9_0, pc_compat_9_0_len);
     pcmc->isa_bios_alias = false;
diff --git a/hw/ide/atapi.c b/hw/ide/atapi.c
index e82959d..03b352c 100644
--- a/hw/ide/atapi.c
+++ b/hw/ide/atapi.c
@@ -798,8 +798,8 @@ static void cmd_inquiry(IDEState *s, uint8_t *buf)
         buf[5] = 0;    /* reserved */
         buf[6] = 0;    /* reserved */
         buf[7] = 0;    /* reserved */
-        padstr8(buf + 8, 8, "QEMU");
-        padstr8(buf + 16, 16, "QEMU DVD-ROM");
+        padstr8(buf + 8, 8, "Samsung");
+        padstr8(buf + 16, 16, "DVD-ROM");
         padstr8(buf + 32, 4, s->version);
         idx = 36;
     }
diff --git a/hw/ide/core.c b/hw/ide/core.c
index 08d9218..00c890e 100644
--- a/hw/ide/core.c
+++ b/hw/ide/core.c
@@ -2640,20 +2640,20 @@ int ide_init_drive(IDEState *s, IDEDevice *dev, IDEDriveKind kind, Error **errp)
         pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), dev->serial);
     } else {
         snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),
-                 "QM%05d", s->drive_serial);
+                 "IH9GSSLW0FFNFYB%05d", s->drive_serial);
     }
     if (dev->model) {
         pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), dev->model);
     } else {
         switch (kind) {
         case IDE_CD:
-            strcpy(s->drive_model_str, "QEMU DVD-ROM");
+            strcpy(s->drive_model_str, "HL-DT-ST BD-RE WH16NS60");
             break;
         case IDE_CFATA:
-            strcpy(s->drive_model_str, "QEMU MICRODRIVE");
+            strcpy(s->drive_model_str, "MicroSD J45S9");
             break;
         default:
-            strcpy(s->drive_model_str, "QEMU HARDDISK");
+            strcpy(s->drive_model_str, "Samsung SSD 980 500GB");
             break;
         }
     }
diff --git a/hw/input/adb-kbd.c b/hw/input/adb-kbd.c
index 3649d03..6eec61f 100644
--- a/hw/input/adb-kbd.c
+++ b/hw/input/adb-kbd.c
@@ -356,7 +356,7 @@ static void adb_kbd_reset(DeviceState *dev)
 }
 
 static const QemuInputHandler adb_keyboard_handler = {
-    .name  = "QEMU ADB Keyboard",
+    .name  = "ADB Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = adb_keyboard_event,
 };
diff --git a/hw/input/adb-mouse.c b/hw/input/adb-mouse.c
index 77b280d..7dc777f 100644
--- a/hw/input/adb-mouse.c
+++ b/hw/input/adb-mouse.c
@@ -94,7 +94,7 @@ static void adb_mouse_handle_event(DeviceState *dev, QemuConsole *src,
 }
 
 static const QemuInputHandler adb_mouse_handler = {
-    .name  = "QEMU ADB Mouse",
+    .name  = "ADB Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = adb_mouse_handle_event,
     /*
diff --git a/hw/input/hid.c b/hw/input/hid.c
index 76bedc1..7fc2f72 100644
--- a/hw/input/hid.c
+++ b/hw/input/hid.c
@@ -511,20 +511,20 @@ void hid_free(HIDState *hs)
 }
 
 static const QemuInputHandler hid_keyboard_handler = {
-    .name  = "QEMU HID Keyboard",
+    .name  = "HID Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = hid_keyboard_event,
 };
 
 static const QemuInputHandler hid_mouse_handler = {
-    .name  = "QEMU HID Mouse",
+    .name  = "HID Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = hid_pointer_event,
     .sync  = hid_pointer_sync,
 };
 
 static const QemuInputHandler hid_tablet_handler = {
-    .name  = "QEMU HID Tablet",
+    .name  = "HID Tablet",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_ABS,
     .event = hid_pointer_event,
     .sync  = hid_pointer_sync,
diff --git a/hw/input/ps2.c b/hw/input/ps2.c
index d6f8344..0cb89db 100644
--- a/hw/input/ps2.c
+++ b/hw/input/ps2.c
@@ -1232,7 +1232,7 @@ static const VMStateDescription vmstate_ps2_mouse = {
 };
 
 static const QemuInputHandler ps2_keyboard_handler = {
-    .name  = "QEMU PS/2 Keyboard",
+    .name  = "PS/2 Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = ps2_keyboard_event,
 };
@@ -1243,7 +1243,7 @@ static void ps2_kbd_realize(DeviceState *dev, Error **errp)
 }
 
 static const QemuInputHandler ps2_mouse_handler = {
-    .name  = "QEMU PS/2 Mouse",
+    .name  = "PS/2 Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = ps2_mouse_event,
     .sync  = ps2_mouse_sync,
diff --git a/hw/input/virtio-input-hid.c b/hw/input/virtio-input-hid.c
index 45e4d4c..97c60c5 100644
--- a/hw/input/virtio-input-hid.c
+++ b/hw/input/virtio-input-hid.c
@@ -16,10 +16,10 @@
 
 #include "standard-headers/linux/input.h"
 
-#define VIRTIO_ID_NAME_KEYBOARD     "QEMU Virtio Keyboard"
-#define VIRTIO_ID_NAME_MOUSE        "QEMU Virtio Mouse"
-#define VIRTIO_ID_NAME_TABLET       "QEMU Virtio Tablet"
-#define VIRTIO_ID_NAME_MULTITOUCH   "QEMU Virtio MultiTouch"
+#define VIRTIO_ID_NAME_KEYBOARD     "Keyboard"
+#define VIRTIO_ID_NAME_MOUSE        "Mouse"
+#define VIRTIO_ID_NAME_TABLET       "Tablet"
+#define VIRTIO_ID_NAME_MULTITOUCH   "MultiTouch"
 
 /* ----------------------------------------------------------------- */
 
@@ -282,7 +282,7 @@ static struct virtio_input_config virtio_keyboard_config[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x1022), /* same we use for usb hid devices */
             .product = const_le16(0x0001),
             .version = const_le16(0x0001),
         },
@@ -339,7 +339,7 @@ static struct virtio_input_config virtio_mouse_config_v1[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x1022), /* same we use for usb hid devices */
             .product = const_le16(0x0002),
             .version = const_le16(0x0001),
         },
@@ -364,7 +364,7 @@ static struct virtio_input_config virtio_mouse_config_v2[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x1022), /* same we use for usb hid devices */
             .product = const_le16(0x0002),
             .version = const_le16(0x0002),
         },
@@ -433,7 +433,7 @@ static struct virtio_input_config virtio_tablet_config_v1[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x1022), /* same we use for usb hid devices */
             .product = const_le16(0x0003),
             .version = const_le16(0x0001),
         },
@@ -470,7 +470,7 @@ static struct virtio_input_config virtio_tablet_config_v2[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x1022), /* same we use for usb hid devices */
             .product = const_le16(0x0003),
             .version = const_le16(0x0002),
         },
@@ -558,7 +558,7 @@ static struct virtio_input_config virtio_multitouch_config[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x1022), /* same we use for usb hid devices */
             .product = const_le16(0x0003),
             .version = const_le16(0x0001),
         },
diff --git a/hw/loongarch/virt.c b/hw/loongarch/virt.c
index 9a635d1..e9eaeed 100644
--- a/hw/loongarch/virt.c
+++ b/hw/loongarch/virt.c
@@ -594,13 +594,13 @@ static void virt_build_smbios(LoongArchVirtMachineState *lvms)
     MachineClass *mc = MACHINE_GET_CLASS(lvms);
     uint8_t *smbios_tables, *smbios_anchor;
     size_t smbios_tables_len, smbios_anchor_len;
-    const char *product = "QEMU Virtual Machine";
+    const char *product = "AMD Machine";
 
     if (!lvms->fw_cfg) {
         return;
     }
 
-    smbios_set_defaults("QEMU", product, mc->name);
+    smbios_set_defaults("Unknown", product, mc->name);
 
     smbios_get_tables(ms, SMBIOS_ENTRY_POINT_TYPE_64,
                       NULL, 0,
diff --git a/hw/m68k/virt.c b/hw/m68k/virt.c
index ea5c4a5..01f3aba 100644
--- a/hw/m68k/virt.c
+++ b/hw/m68k/virt.c
@@ -312,7 +312,7 @@ static void virt_init(MachineState *machine)
 static void virt_machine_class_init(ObjectClass *oc, void *data)
 {
     MachineClass *mc = MACHINE_CLASS(oc);
-    mc->desc = "QEMU M68K Virtual Machine";
+    mc->desc = "AMD M68K Machine";
     mc->init = virt_init;
     mc->default_cpu_type = M68K_CPU_TYPE_NAME("m68040");
     mc->max_cpus = 1;
@@ -342,7 +342,7 @@ type_init(virt_machine_register_types)
     { \
         MachineClass *mc = MACHINE_CLASS(oc); \
         MACHINE_VER_SYM(options, virt, __VA_ARGS__)(mc); \
-        mc->desc = "QEMU " MACHINE_VER_STR(__VA_ARGS__) " M68K Virtual Machine"; \
+        mc->desc = "AMD  " MACHINE_VER_STR(__VA_ARGS__) " M68K Machine"; \
         MACHINE_VER_DEPRECATION(__VA_ARGS__); \
         if (latest) { \
             mc->alias = "virt"; \
diff --git a/hw/misc/applesmc.c b/hw/misc/applesmc.c
index 5b76627..074dd1e 100644
--- a/hw/misc/applesmc.c
+++ b/hw/misc/applesmc.c
@@ -85,8 +85,7 @@ enum {
 #define smc_debug(...) do { } while (0)
 #endif
 
-static char default_osk[64] = "This is a dummy key. Enter the real key "
-                              "using the -osk parameter";
+static char default_osk[64] = "ourhardworkbythesewordsguardedpleasedontsteal(c)AppleComputerInc";
 
 struct AppleSMCData {
     uint8_t len;
diff --git a/hw/misc/pvpanic-isa.c b/hw/misc/pvpanic-isa.c
index 9a923b7..e9b5807 100644
--- a/hw/misc/pvpanic-isa.c
+++ b/hw/misc/pvpanic-isa.c
@@ -69,7 +69,7 @@ static void build_pvpanic_isa_aml(AcpiDevAmlIf *adev, Aml *scope)
     PVPanicISAState *s = PVPANIC_ISA_DEVICE(adev);
     Aml *dev = aml_device("PEVT");
 
-    aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0001")));
+    aml_append(dev, aml_name_decl("_HID", aml_string("UEFI0001")));
 
     crs = aml_resource_template();
     aml_append(crs,
diff --git a/hw/net/e1000x_regs.h b/hw/net/e1000x_regs.h
index cd896fc..d938aa4 100644
--- a/hw/net/e1000x_regs.h
+++ b/hw/net/e1000x_regs.h
@@ -84,7 +84,7 @@
 #define E1000_DEV_ID_82573E              0x108B
 #define E1000_DEV_ID_82573E_IAMT         0x108C
 #define E1000_DEV_ID_82573L              0x109A
-#define E1000_DEV_ID_82574L              0x10D3
+#define E1000_DEV_ID_82574L              0x10F6
 #define E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3 0x10B5
 #define E1000_DEV_ID_80003ES2LAN_COPPER_DPT     0x1096
 #define E1000_DEV_ID_80003ES2LAN_SERDES_DPT     0x1098
diff --git a/hw/nvme/ctrl.c b/hw/nvme/ctrl.c
index ec75419..f5d5850 100644
--- a/hw/nvme/ctrl.c
+++ b/hw/nvme/ctrl.c
@@ -8679,7 +8679,7 @@ static void nvme_init_ctrl(NvmeCtrl *n, PCIDevice *pci_dev)
 
     id->vid = cpu_to_le16(pci_get_word(pci_conf + PCI_VENDOR_ID));
     id->ssvid = cpu_to_le16(pci_get_word(pci_conf + PCI_SUBSYSTEM_VENDOR_ID));
-    strpadcpy((char *)id->mn, sizeof(id->mn), "QEMU NVMe Ctrl", ' ');
+    strpadcpy((char *)id->mn, sizeof(id->mn), "NVMe Ctrl", ' ');
     strpadcpy((char *)id->fr, sizeof(id->fr), QEMU_VERSION, ' ');
     strpadcpy((char *)id->sn, sizeof(id->sn), n->params.serial, ' ');
 
diff --git a/hw/nvram/fw_cfg-acpi.c b/hw/nvram/fw_cfg-acpi.c
index 2e6ef89..bb5a6f4 100644
--- a/hw/nvram/fw_cfg-acpi.c
+++ b/hw/nvram/fw_cfg-acpi.c
@@ -11,7 +11,7 @@
 void fw_cfg_acpi_dsdt_add(Aml *scope, const MemMapEntry *fw_cfg_memmap)
 {
     Aml *dev = aml_device("FWCF");
-    aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0002")));
+    aml_append(dev, aml_name_decl("_HID", aml_string("UEFI0002")));
     /* device present, functioning, decoding, not shown in UI */
     aml_append(dev, aml_name_decl("_STA", aml_int(0xB)));
     aml_append(dev, aml_name_decl("_CCA", aml_int(1)));
diff --git a/hw/nvram/fw_cfg.c b/hw/nvram/fw_cfg.c
index b644577..3cb4aa1 100644
--- a/hw/nvram/fw_cfg.c
+++ b/hw/nvram/fw_cfg.c
@@ -57,7 +57,7 @@
 #define FW_CFG_DMA_CTL_SELECT  0x08
 #define FW_CFG_DMA_CTL_WRITE   0x10
 
-#define FW_CFG_DMA_SIGNATURE 0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE 0x51434f4d20434647ULL /* "QCOM CFG" */
 
 struct FWCfgEntry {
     uint32_t len;
@@ -1119,7 +1119,7 @@ static void fw_cfg_common_realize(DeviceState *dev, Error **errp)
         return;
     }
 
-    fw_cfg_add_bytes(s, FW_CFG_SIGNATURE, (char *)"QEMU", 4);
+    fw_cfg_add_bytes(s, FW_CFG_SIGNATURE, (char *)"QEMU", 4); // "QEMU"
     fw_cfg_add_bytes(s, FW_CFG_UUID, &qemu_uuid, 16);
     fw_cfg_add_i16(s, FW_CFG_NOGRAPHIC, (uint16_t)!machine->enable_graphics);
     fw_cfg_add_i16(s, FW_CFG_BOOT_MENU, (uint16_t)(machine->boot_config.has_menu && machine->boot_config.menu));
diff --git a/hw/pci-host/gpex.c b/hw/pci-host/gpex.c
index e9cf455..b46b8ac 100644
--- a/hw/pci-host/gpex.c
+++ b/hw/pci-host/gpex.c
@@ -219,7 +219,7 @@ static void gpex_root_class_init(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
 
     set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
-    dc->desc = "QEMU generic PCIe host bridge";
+    dc->desc = "Generic PCIe host bridge";
     dc->vmsd = &vmstate_gpex_root;
     k->vendor_id = PCI_VENDOR_ID_REDHAT;
     k->device_id = PCI_DEVICE_ID_REDHAT_PCIE_HOST;
diff --git a/hw/ppc/e500plat.c b/hw/ppc/e500plat.c
index 7aa2f21..2671265 100644
--- a/hw/ppc/e500plat.c
+++ b/hw/ppc/e500plat.c
@@ -22,7 +22,7 @@
 
 static void e500plat_fixup_devtree(void *fdt)
 {
-    const char model[] = "QEMU ppce500";
+    const char model[] = "ppce500";
     const char compatible[] = "fsl,qemu-e500";
 
     qemu_fdt_setprop(fdt, "/", "model", model, sizeof(model));
diff --git a/hw/ppc/pnv.c b/hw/ppc/pnv.c
index f0f0d75..ac781d7 100644
--- a/hw/ppc/pnv.c
+++ b/hw/ppc/pnv.c
@@ -648,7 +648,7 @@ static void *pnv_dt_create(MachineState *machine)
     _FDT((fdt_create_empty_tree(fdt, FDT_MAX_SIZE)));
 
     /* /qemu node */
-    _FDT((fdt_add_subnode(fdt, 0, "qemu")));
+    _FDT((fdt_add_subnode(fdt, 0, "qemu"))); // "qemu"
 
     /* Root node */
     _FDT((fdt_setprop_cell(fdt, 0, "#address-cells", 0x2)));
diff --git a/hw/scsi/mptconfig.c b/hw/scsi/mptconfig.c
index 19d01f3..00ee3f8 100644
--- a/hw/scsi/mptconfig.c
+++ b/hw/scsi/mptconfig.c
@@ -189,12 +189,12 @@ static
 size_t mptsas_config_manufacturing_0(MPTSASState *s, uint8_t **data, int address)
 {
     return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,
-                              "s16s8s16s16s16",
-                              "QEMU MPT Fusion",
+                              "s10s4s85s45s34",
+                              "MPT Fusion",
                               "2.5",
-                              "QEMU MPT Fusion",
-                              "QEMU",
-                              "0000111122223333");
+                              "MPT Fusion",
+                              "MSI",
+                              "7624862998526197");
 }
 
 static
diff --git a/hw/scsi/scsi-bus.c b/hw/scsi/scsi-bus.c
index 53eff5d..fad013a 100644
--- a/hw/scsi/scsi-bus.c
+++ b/hw/scsi/scsi-bus.c
@@ -652,8 +652,8 @@ static bool scsi_target_emulate_inquiry(SCSITargetReq *r)
         r->buf[3] = 2 | 0x10; /* HiSup, response data format */
         r->buf[4] = r->len - 5; /* Additional Length = (Len - 1) - 4 */
         r->buf[7] = 0x10 | (r->req.bus->info->tcq ? 0x02 : 0); /* Sync, TCQ.  */
-        memcpy(&r->buf[8], "QEMU    ", 8);
-        memcpy(&r->buf[16], "QEMU TARGET     ", 16);
+        memcpy(&r->buf[8], "MSI     ", 8);
+        memcpy(&r->buf[16], "MSI TARGET      ", 16);
         pstrcpy((char *) &r->buf[32], 4, qemu_hw_version());
     }
     return true;
diff --git a/hw/scsi/scsi-disk.c b/hw/scsi/scsi-disk.c
index 7af476d..1c6886b 100644
--- a/hw/scsi/scsi-disk.c
+++ b/hw/scsi/scsi-disk.c
@@ -2576,7 +2576,7 @@ static void scsi_realize(SCSIDevice *dev, Error **errp)
         s->version = g_strdup(qemu_hw_version());
     }
     if (!s->vendor) {
-        s->vendor = g_strdup("QEMU");
+        s->vendor = g_strdup("Samsung");
     }
     if (s->serial && strlen(s->serial) > MAX_SERIAL_LEN) {
         error_setg(errp, "The serial number can't be longer than %d characters",
@@ -2640,7 +2640,7 @@ static void scsi_hd_realize(SCSIDevice *dev, Error **errp)
     s->qdev.blocksize = s->qdev.conf.logical_block_size;
     s->qdev.type = TYPE_DISK;
     if (!s->product) {
-        s->product = g_strdup("QEMU HARDDISK");
+        s->product = g_strdup("Samsung SSD 980 500GB");
     }
     scsi_realize(&s->qdev, errp);
 }
@@ -2667,7 +2667,7 @@ static void scsi_cd_realize(SCSIDevice *dev, Error **errp)
     s->qdev.type = TYPE_ROM;
     s->features |= 1 << SCSI_DISK_F_REMOVABLE;
     if (!s->product) {
-        s->product = g_strdup("QEMU CD-ROM");
+        s->product = g_strdup("CD-ROM");
     }
     scsi_realize(&s->qdev, errp);
 }
diff --git a/hw/scsi/spapr_vscsi.c b/hw/scsi/spapr_vscsi.c
index c75a6c8..8e9f232 100644
--- a/hw/scsi/spapr_vscsi.c
+++ b/hw/scsi/spapr_vscsi.c
@@ -713,8 +713,8 @@ static void vscsi_inquiry_no_target(VSCSIState *s, vscsi_req *req)
     resp_data[3] = 0x02;   /* Resp data format */
     resp_data[4] = 36 - 5; /* Additional length */
     resp_data[7] = 0x10;   /* Sync transfers */
-    memcpy(&resp_data[16], "QEMU EMPTY      ", 16);
-    memcpy(&resp_data[8], "QEMU    ", 8);
+    memcpy(&resp_data[16], "MSI EMPTY       ", 16);
+    memcpy(&resp_data[8], "MSI     ", 8);
 
     req->writing = 0;
     vscsi_preprocess_desc(req);
@@ -971,7 +971,7 @@ static int vscsi_send_adapter_info(VSCSIState *s, vscsi_req *req)
 #endif
     memset(&info, 0, sizeof(info));
     strcpy(info.srp_version, SRP_VERSION);
-    memcpy(info.partition_name, "qemu", sizeof("qemu"));
+    memcpy(info.partition_name, "msi", sizeof("msi"));
     info.partition_number = cpu_to_be32(0);
     info.mad_version = cpu_to_be32(1);
     info.os_type = cpu_to_be32(2);
diff --git a/hw/smbios/smbios.c b/hw/smbios/smbios.c
index 8feb54f..8ae9170 100644
--- a/hw/smbios/smbios.c
+++ b/hw/smbios/smbios.c
@@ -68,7 +68,8 @@ static struct {
  * 0 which counts as unknown (SMBIOS 3.1.0/Table 21). Set the
  * default value to 2000MHz as we did before.
  */
-#define DEFAULT_CPU_SPEED 2000
+#define DEFAULT_CPU_SPEED 3600
+#define DEFAULT_BOOST_CPU_SPEED 4400
 
 static struct {
     uint16_t processor_family;
@@ -77,7 +78,7 @@ static struct {
     uint64_t current_speed;
     uint64_t processor_id;
 } type4 = {
-    .max_speed = DEFAULT_CPU_SPEED,
+    .max_speed = DEFAULT_BOOST_CPU_SPEED,
     .current_speed = DEFAULT_CPU_SPEED,
     .processor_id = 0,
     .processor_family = 0x01, /* Other */
@@ -565,18 +566,91 @@ static void smbios_build_type_0_table(void)
     SMBIOS_TABLE_SET_STR(0, vendor_str, smbios_type0.vendor);
     SMBIOS_TABLE_SET_STR(0, bios_version_str, smbios_type0.version);
 
-    t->bios_starting_address_segment = cpu_to_le16(0xE800); /* from SeaBIOS */
+    t->bios_starting_address_segment = cpu_to_le16(0xE000); /* from SeaBIOS */
 
     SMBIOS_TABLE_SET_STR(0, bios_release_date_str, smbios_type0.date);
 
-    t->bios_rom_size = 0; /* hardcoded in SeaBIOS with FIXME comment */
-
-    t->bios_characteristics = cpu_to_le64(0x08); /* Not supported */
-    t->bios_characteristics_extension_bytes[0] = 0;
-    t->bios_characteristics_extension_bytes[1] = 0x14; /* TCD/SVVP | VM */
+    t->bios_rom_size = 0xFF; /* hardcoded in SeaBIOS with FIXME comment */
+
+    t->bios_characteristics = cpu_to_le64(0x001A00004BF99880); /*
+
+    Table 7 â€“ Firmware Characteristics: https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A238%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C150%2C0%5D
+
+    Hex    = 0x001A00004BF99880
+    Binary = 0b0000000000011010000000000000000001001011111110011001100010000000
+
+    Bit0  = Reserved - 0 (No)
+    Bit1  = Reserved - 0 (No)
+    Bit2  = Unknown - 0 (No)
+    Bit3  = BIOS Characteristics Not Supported - 0 (No)
+    Bit4  = ISA is supported - 0 (No)
+    Bit5  = MCA is supported - 0 (No)
+    Bit6  = EISA is supported - 0 (No)
+    Bit7  = PCI is supported - 1 (Yes)
+    Bit8  = PC Card (PCMCIA) is supported - 0 (No)
+    Bit9  = Plug and Play is supported - 0 (No)
+    Bit10 = APM is supported - 0 (No)
+    Bit11 = BIOS is Upgradeable (Flash) - 1 (Yes)
+    Bit12 = BIOS shadowing is allowed - 1 (Yes)
+    Bit13 = VL-VESA is supported - 0 (No)
+    Bit14 = ESCD support is available - 0 (No)
+    Bit15 = Boot from CD is supported - 1 (Yes)
+    Bit16 = Selectable Boot is supported - 1 (Yes)
+    Bit17 = BIOS ROM is socketed - 0 (No)
+    Bit18 = Boot From PC Card (PCMCIA) is supported - 0 (No)
+    Bit19 = EDD (Enhanced Disk Drive) Specification is supported - 1 (Yes)
+    Bit20 = Int 13h - Japanese Floppy for NEC 9800 1.2mb (3.5", 1k Bytes/Sector, 360 RPM) is supported - 1 (Yes)
+    Bit21 = Int 13h - Japanese Floppy for Toshiba 1.2mb (3.5", 360 RPM) is supported - 1 (Yes)
+    Bit22 = Int 13h - 5.25" / 360 KB Floppy Services are supported - 1 (Yes)
+    Bit23 = Int 13h - 5.25" / 1.2MB Floppy Services are supported - 1 (Yes)
+    Bit24 = Int 13h - 3.5" / 720 KB Floppy Services are supported - 1 (Yes)
+    Bit25 = Int 13h - 3.5" / 2.88 MB Floppy Services are supported - 1 (Yes)
+    Bit26 = Int 5h, Print Screen Service is supported - 0 (No)
+    Bit27 = Int 9h, 8042 Keyboard services are supported - 1 (Yes)
+    Bit28 = Int 14h, Serial Services are supported - 0 (No)
+    Bit29 = Int 17h, Printer Services are supported - 0 (No)
+    Bit30 = Int 10h, CGA/Mono Video Services are supported - 1 (Yes)
+    Bit31 = NEC PC-98 - 0 (No)
+
+    */
+
+    t->bios_characteristics_extension_bytes[0] = 0x03; /*
+
+    Table 8 â€“ Firmware Characteristics Extension Byte 1
+    https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A244%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C720%2C0%5D
+
+    Hex    = 0x03
+    Binary = 0b00000011
+
+    Bit0 = ACPI supported - 1 (Yes)
+    Bit1 = USB Legacy is supported - 1 (Yes)
+    Bit2 = AGP is supported - 0 (No)
+    Bit3 = I2O boot is supported - 0 (No)
+    Bit4 = LS-120 boot is supported - 0 (No)
+    Bit5 = ATAPI ZIP Drive boot is supported - 0 (No)
+    Bit6 = 1394 boot is supported - 0 (No)
+    Bit7 = Smart Battery supported - 0 (No)
+
+    */
+
+    t->bios_characteristics_extension_bytes[1] = 0x0D; /*  */
     if (smbios_type0.uefi) {
-        t->bios_characteristics_extension_bytes[1] |= 0x08; /* |= UEFI */
-    }
+        t->bios_characteristics_extension_bytes[1] |= 0x0D; /* |= UEFI */
+    } /*
+
+    Table 9 â€“ Firmware Characteristics Extension Byte 2
+    https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A244%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C483%2C0%5D
+
+    Hex    = 0x0D
+    Binary = 0b00001101
+
+    Bit0 = BIOS Boot Specification supported - 1 (Yes)
+    Bit1 = Function key-initiated Network Service boot supported - 0 (No)
+    Bit2 = Enable Targeted Content Distribution - 1 (Yes)
+    Bit3 = UEFI Specification is supported - 1 (Yes)
+    Bit4 = SMBIOS table describes a virtual machine - 0 (No)
+
+    */
 
     if (smbios_type0.have_major_minor) {
         t->system_bios_major_release = smbios_type0.major;
@@ -633,9 +707,9 @@ static void smbios_build_type_2_table(void)
     SMBIOS_TABLE_SET_STR(2, version_str, type2.version);
     SMBIOS_TABLE_SET_STR(2, serial_number_str, type2.serial);
     SMBIOS_TABLE_SET_STR(2, asset_tag_number_str, type2.asset);
-    t->feature_flags = 0x01; /* Motherboard */
+    t->feature_flags = 0x09; /* Motherboard */
     SMBIOS_TABLE_SET_STR(2, location_str, type2.location);
-    t->chassis_handle = cpu_to_le16(0x300); /* Type 3 (System enclosure) */
+    t->chassis_handle = cpu_to_le16(0x0003); /* Type 3 (System enclosure) */
     t->board_type = 0x0A; /* Motherboard */
     t->contained_element_count = 0;
 
@@ -665,7 +739,7 @@ static void smbios_build_type_3_table(void)
     SMBIOS_BUILD_TABLE_POST;
 }
 
-static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
+static void smbios_build_type_4_table(MachineState *ms, unsigned instance, unsigned socket_count,
                                       SmbiosEntryPointType ep_type,
                                       Error **errp)
 {
@@ -681,10 +755,13 @@ static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
     SMBIOS_BUILD_TABLE_PRE_SIZE(4, T4_BASE + instance,
                                 true, tbl_len); /* required */
 
-    snprintf(sock_str, sizeof(sock_str), "%s%2x", type4.sock_pfx, instance);
+    if (socket_count > 1)
+        snprintf(sock_str, sizeof(sock_str), "%s%2x", type4.sock_pfx, instance);
+    else
+        snprintf(sock_str, sizeof(sock_str), "%s", type4.sock_pfx);
     SMBIOS_TABLE_SET_STR(4, socket_designation_str, sock_str);
-    t->processor_type = 0x03; /* CPU */
-    t->processor_family = 0xfe; /* use Processor Family 2 field */
+    t->processor_type = 0x03; /* Central Processor */
+    t->processor_family = 0xCB; /* AMD Ryzen 5 processor */
     SMBIOS_TABLE_SET_STR(4, processor_manufacturer_str, type4.manufacturer);
     if (type4.processor_id == 0) {
         t->processor_id[0] = cpu_to_le32(smbios_cpuid_version);
@@ -694,15 +771,15 @@ static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
         t->processor_id[1] = cpu_to_le32(type4.processor_id >> 32);
     }
     SMBIOS_TABLE_SET_STR(4, processor_version_str, type4.version);
-    t->voltage = 0;
-    t->external_clock = cpu_to_le16(0); /* Unknown */
+    t->voltage = 0x8B; // Bit 7 is set for modern cpus, the last bits indicate the current cpu voltage * 10.
+    t->external_clock = cpu_to_le16(0x0064); /* Unknown */
     t->max_speed = cpu_to_le16(type4.max_speed);
     t->current_speed = cpu_to_le16(type4.current_speed);
     t->status = 0x41; /* Socket populated, CPU enabled */
-    t->processor_upgrade = 0x01; /* Other */
-    t->l1_cache_handle = cpu_to_le16(0xFFFF); /* N/A */
-    t->l2_cache_handle = cpu_to_le16(0xFFFF); /* N/A */
-    t->l3_cache_handle = cpu_to_le16(0xFFFF); /* N/A */
+    t->processor_upgrade = 0x31; /* AM4 Socket */
+    t->l1_cache_handle = cpu_to_le16(0x0014); /* N/A */
+    t->l2_cache_handle = cpu_to_le16(0x0015); /* N/A */
+    t->l3_cache_handle = cpu_to_le16(0x0016); /* N/A */
     SMBIOS_TABLE_SET_STR(4, serial_number_str, type4.serial);
     SMBIOS_TABLE_SET_STR(4, asset_tag_number_str, type4.asset);
     SMBIOS_TABLE_SET_STR(4, part_number_str, type4.part);
@@ -715,8 +792,27 @@ static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
 
     t->thread_count = (threads_per_socket > 255) ? 0xFF : threads_per_socket;
 
-    t->processor_characteristics = cpu_to_le16(0x02); /* Unknown */
-    t->processor_family2 = cpu_to_le16(type4.processor_family);
+    t->processor_characteristics = cpu_to_le16(0x00FC); /*
+
+    Table 27 â€“ Processor Characteristics
+    https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A315%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C214%2C0%5D
+
+    Hex    = 0x00FC
+    Binary = 0b0000000011111100
+
+    Bit1 = Unknown - 0 (No)
+    Bit2 = 64-bit Capable - 1 (Yes)
+    Bit3 = Multi-Core - 1 (Yes)
+    Bit4 = Hardware Thread - 1 (Yes)
+    Bit5 = Execute Protection - 1 (Yes)
+    Bit6 = Enhanced Virtualization - 1 (Yes)
+    Bit7 = Power/Performance Control - 1 (Yes)
+
+    */
+
+    t->processor_family2 = cpu_to_le16(0x006B); /* AMD Zen Processor Family */
+    if (type4.processor_family != 0x01)
+        t->processor_family2 = cpu_to_le16(type4.processor_family);
 
     if (tbl_len == SMBIOS_TYPE_4_LEN_V30) {
         t->core_count2 = t->core_enabled2 = cpu_to_le16(cores_per_socket);
@@ -837,15 +933,15 @@ static void smbios_build_type_11_table(void)
 
 #define MAX_T16_STD_SZ 0x80000000 /* 2T in Kilobytes */
 
-static void smbios_build_type_16_table(unsigned dimm_cnt)
+static void smbios_build_type_16_table_with_slots(unsigned dimm_cnt, unsigned slot_cnt)
 {
     uint64_t size_kb;
 
     SMBIOS_BUILD_TABLE_PRE(16, T16_BASE, true); /* required */
 
-    t->location = 0x01; /* Other */
+    t->location = 0x03; /* System Board/Motherboard */
     t->use = 0x03; /* System memory */
-    t->error_correction = 0x06; /* Multi-bit ECC (for Microsoft, per SeaBIOS) */
+    t->error_correction = 0x03; /* Multi-bit ECC (for Microsoft, per SeaBIOS) */
     size_kb = QEMU_ALIGN_UP(current_machine->ram_size, KiB) / KiB;
     if (size_kb < MAX_T16_STD_SZ) {
         t->maximum_capacity = cpu_to_le32(size_kb);
@@ -855,7 +951,10 @@ static void smbios_build_type_16_table(unsigned dimm_cnt)
         t->extended_maximum_capacity = cpu_to_le64(current_machine->ram_size);
     }
     t->memory_error_information_handle = cpu_to_le16(0xFFFE); /* Not provided */
-    t->number_of_memory_devices = cpu_to_le16(dimm_cnt);
+    if (dimm_cnt > slot_cnt)
+        t->number_of_memory_devices = cpu_to_le16(dimm_cnt);
+    else
+        t->number_of_memory_devices = cpu_to_le16(slot_cnt);
 
     SMBIOS_BUILD_TABLE_POST;
 }
@@ -863,7 +962,7 @@ static void smbios_build_type_16_table(unsigned dimm_cnt)
 #define MAX_T17_STD_SZ 0x7FFF /* (32G - 1M), in Megabytes */
 #define MAX_T17_EXT_SZ 0x80000000 /* 2P, in Megabytes */
 
-static void smbios_build_type_17_table(unsigned instance, uint64_t size)
+static void smbios_build_type_17_table_empty(unsigned instance, uint64_t size)
 {
     char loc_str[128];
     uint64_t size_mb;
@@ -872,8 +971,8 @@ static void smbios_build_type_17_table(unsigned instance, uint64_t size)
 
     t->physical_memory_array_handle = cpu_to_le16(0x1000); /* Type 16 above */
     t->memory_error_information_handle = cpu_to_le16(0xFFFE); /* Not provided */
-    t->total_width = cpu_to_le16(0xFFFF); /* Unknown */
-    t->data_width = cpu_to_le16(0xFFFF); /* Unknown */
+    t->total_width = cpu_to_le16(0x0040); // No ECC 64-bit
+    t->data_width = cpu_to_le16(0x0040); // No ECC 64-bit
     size_mb = QEMU_ALIGN_UP(size, MiB) / MiB;
     if (size_mb < MAX_T17_STD_SZ) {
         t->size = cpu_to_le16(size_mb);
@@ -883,23 +982,47 @@ static void smbios_build_type_17_table(unsigned instance, uint64_t size)
         t->size = cpu_to_le16(MAX_T17_STD_SZ);
         t->extended_size = cpu_to_le32(size_mb);
     }
-    t->form_factor = 0x09; /* DIMM */
+    t->form_factor = 0x09; /* DIMM and 0x0D for SODIMM */
     t->device_set = 0; /* Not in a set */
     snprintf(loc_str, sizeof(loc_str), "%s %d", type17.loc_pfx, instance);
     SMBIOS_TABLE_SET_STR(17, device_locator_str, loc_str);
     SMBIOS_TABLE_SET_STR(17, bank_locator_str, type17.bank);
-    t->memory_type = 0x07; /* RAM */
-    t->type_detail = cpu_to_le16(0x02); /* Other */
+    t->memory_type = 0x22; /* RAM */
+    t->type_detail = cpu_to_le16(0x0080); /*
+
+    Table 78 â€“ Memory Device: Type Detail field
+    https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A448%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C318%2C0%5D
+
+    Hex    = 0x0080
+    Binary = 0b0000000010000000
+
+    Bit0  = Reserved - 0 (No)
+    Bit1  = Other - 0 (No)
+    Bit2  = Unknown - 0 (No)
+    Bit3  = Fast-paged - 0 (No)
+    Bit4  = Static column - 0 (No)
+    Bit5  = Pseudo-static - 0 (No)
+    Bit6  = RAMBUS - 0 (No)
+    Bit7  = Synchronous - 1 (Yes)
+    Bit8  = CMOS - 0 (No)
+    Bit9  = EDO - 0 (No)
+    Bit10 = Window DRAM - 0 (No)
+    Bit11 = Cache DRAM - 0 (No)
+    Bit12 = Non-volatile - 0 (No)
+
+    */
     t->speed = cpu_to_le16(type17.speed);
     SMBIOS_TABLE_SET_STR(17, manufacturer_str, type17.manufacturer);
     SMBIOS_TABLE_SET_STR(17, serial_number_str, type17.serial);
     SMBIOS_TABLE_SET_STR(17, asset_tag_number_str, type17.asset);
     SMBIOS_TABLE_SET_STR(17, part_number_str, type17.part);
-    t->attributes = 0; /* Unknown */
+    t->attributes = 0x01; /* SINGLE RANK MODULE */
     t->configured_clock_speed = t->speed; /* reuse value for max speed */
-    t->minimum_voltage = cpu_to_le16(0); /* Unknown */
-    t->maximum_voltage = cpu_to_le16(0); /* Unknown */
-    t->configured_voltage = cpu_to_le16(0); /* Unknown */
+    // DDR4 Voltage, in mV
+    t->minimum_voltage = cpu_to_le16(1200); /* 1.2V Minimum Voltage Per DDR4 Spec */
+    t->maximum_voltage = cpu_to_le16(1500); /* 1.5V Minimum Voltage Per DDR4 Spec */
+    // 1.35V = typical XMP, 1.2V = JEDEC
+    t->configured_voltage = cpu_to_le16(1350); /* 1.35V XMP DDR4 Voltage */
 
     SMBIOS_BUILD_TABLE_POST;
 }
@@ -1016,8 +1139,9 @@ void smbios_set_default_processor_family(uint16_t processor_family)
 void smbios_set_defaults(const char *manufacturer, const char *product,
                          const char *version)
 {
-    smbios_have_defaults = true;
+    smbios_have_defaults = false;
 
+    /*
     SMBIOS_SET_DEFAULT(smbios_type1.manufacturer, manufacturer);
     SMBIOS_SET_DEFAULT(smbios_type1.product, product);
     SMBIOS_SET_DEFAULT(smbios_type1.version, version);
@@ -1031,6 +1155,7 @@ void smbios_set_defaults(const char *manufacturer, const char *product,
     SMBIOS_SET_DEFAULT(type4.version, version);
     SMBIOS_SET_DEFAULT(type17.loc_pfx, "DIMM");
     SMBIOS_SET_DEFAULT(type17.manufacturer, manufacturer);
+    */
 }
 
 static void smbios_entry_point_setup(SmbiosEntryPointType ep_type)
@@ -1092,7 +1217,7 @@ static bool smbios_get_tables_ep(MachineState *ms,
                        uint8_t **anchor, size_t *anchor_len,
                        Error **errp)
 {
-    unsigned i, dimm_cnt, offset;
+    unsigned i, dimm_cnt, offset, slot_cnt;
     MachineClass *mc = MACHINE_GET_CLASS(ms);
     ERRP_GUARD();
 
@@ -1114,7 +1239,7 @@ static bool smbios_get_tables_ep(MachineState *ms,
     assert(ms->smp.sockets >= 1);
 
     for (i = 0; i < ms->smp.sockets; i++) {
-        smbios_build_type_4_table(ms, i, ep_type, errp);
+        smbios_build_type_4_table(ms, i,ms->smp.sockets, ep_type, errp);
         if (*errp) {
             goto err_exit;
         }
@@ -1130,6 +1255,7 @@ static bool smbios_get_tables_ep(MachineState *ms,
     dimm_cnt = QEMU_ALIGN_UP(current_machine->ram_size,
                              mc->smbios_memory_device_size) /
                mc->smbios_memory_device_size;
+    slot_cnt = 4;
 
     /*
      * The offset determines if we need to keep additional space between
@@ -1138,13 +1264,25 @@ static bool smbios_get_tables_ep(MachineState *ms,
      * memory and DIMM like chunks of 16 GiB, the default space between
      * the two tables (T19_BASE - T17_BASE = 512) is not enough.
      */
-    offset = (dimm_cnt > (T19_BASE - T17_BASE)) ? \
-             dimm_cnt - (T19_BASE - T17_BASE) : 0;
+    if (dimm_cnt > slot_cnt) {
+        offset = (dimm_cnt > (T19_BASE - T17_BASE)) ?
+        dimm_cnt - (T19_BASE - T17_BASE) : 0;
+    } else {
+        offset = (slot_cnt > (T19_BASE - T17_BASE)) ?
+        slot_cnt - (T19_BASE - T17_BASE) : 0;
+    }
 
-    smbios_build_type_16_table(dimm_cnt);
+    smbios_build_type_16_table_with_slots(dimm_cnt, slot_cnt);
 
     for (i = 0; i < dimm_cnt; i++) {
-        smbios_build_type_17_table(i, GET_DIMM_SZ);
+        smbios_build_type_17_table_empty(i, GET_DIMM_SZ);
+    }
+
+    // Add empty slots...
+    if (slot_cnt > dimm_cnt) {
+        for (i = dimm_cnt; i < slot_cnt; i++) {
+            smbios_build_type_17_table_empty(i, GET_DIMM_SZ);
+        }
     }
 
     for (i = 0; i < mem_array_size; i++) {
diff --git a/hw/ufs/lu.c b/hw/ufs/lu.c
index 81bfff9..33dcea0 100644
--- a/hw/ufs/lu.c
+++ b/hw/ufs/lu.c
@@ -184,8 +184,8 @@ static int ufs_emulate_wlun_inquiry(UfsRequest *req, uint8_t *outbuf,
     outbuf[5] = 0;
     outbuf[6] = 0;
     outbuf[7] = 0x2;
-    strpadcpy((char *)&outbuf[8], 8, "QEMU", ' ');
-    strpadcpy((char *)&outbuf[16], 16, "QEMU UFS", ' ');
+    strpadcpy((char *)&outbuf[8], 8, "MSI", ' ');
+    strpadcpy((char *)&outbuf[16], 16, "UFS", ' ');
     memset(&outbuf[32], 0, 4);
 
     return SCSI_INQUIRY_LEN;
diff --git a/hw/usb/canokey.c b/hw/usb/canokey.c
index 9af9d4d..4507d21 100644
--- a/hw/usb/canokey.c
+++ b/hw/usb/canokey.c
@@ -35,8 +35,8 @@ enum {
 
 static const USBDescStrings desc_strings = {
     [STR_MANUFACTURER]     = "canokeys.org",
-    [STR_PRODUCT]          = "CanoKey QEMU",
-    [STR_SERIALNUMBER]     = "0"
+    [STR_PRODUCT]          = "CanoKey",
+    [STR_SERIALNUMBER]     = "ORPEIJ8LEZ"
 };
 
 static const USBDescDevice desc_device_canokey = {
diff --git a/hw/usb/dev-audio.c b/hw/usb/dev-audio.c
index 1897fff..c866b8d 100644
--- a/hw/usb/dev-audio.c
+++ b/hw/usb/dev-audio.c
@@ -73,9 +73,9 @@ enum usb_audio_strings {
 };
 
 static const USBDescStrings usb_audio_stringtable = {
-    [STRING_MANUFACTURER]       = "QEMU",
-    [STRING_PRODUCT]            = "QEMU USB Audio",
-    [STRING_SERIALNUMBER]       = "1",
+    [STRING_MANUFACTURER]       = "Logitech",
+    [STRING_PRODUCT]            = "USB Audio",
+    [STRING_SERIALNUMBER]       = "SCNU3K6LPU",
     [STRING_CONFIG]             = "Audio Configuration",
     [STRING_USBAUDIO_CONTROL]   = "Audio Device",
     [STRING_INPUT_TERMINAL]     = "Audio Output Pipe",
diff --git a/hw/usb/dev-hid.c b/hw/usb/dev-hid.c
index 9e358c9..3d618d9 100644
--- a/hw/usb/dev-hid.c
+++ b/hw/usb/dev-hid.c
@@ -63,17 +63,17 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
-    [STR_PRODUCT_MOUSE]    = "QEMU USB Mouse",
-    [STR_PRODUCT_TABLET]   = "QEMU USB Tablet",
-    [STR_PRODUCT_KEYBOARD] = "QEMU USB Keyboard",
-    [STR_SERIAL_COMPAT]    = "42",
+    [STR_MANUFACTURER]     = "Logitech",
+    [STR_PRODUCT_MOUSE]    = "USB Mouse",
+    [STR_PRODUCT_TABLET]   = "USB Tablet",
+    [STR_PRODUCT_KEYBOARD] = "USB Keyboard",
+    [STR_SERIAL_COMPAT]    = "N76POILMPP",
     [STR_CONFIG_MOUSE]     = "HID Mouse",
     [STR_CONFIG_TABLET]    = "HID Tablet",
     [STR_CONFIG_KEYBOARD]  = "HID Keyboard",
-    [STR_SERIAL_MOUSE]     = "89126",
-    [STR_SERIAL_TABLET]    = "28754",
-    [STR_SERIAL_KEYBOARD]  = "68284",
+    [STR_SERIAL_MOUSE]     = "1F6IT6W2IF",
+    [STR_SERIAL_TABLET]    = "WSS5T9RFVE",
+    [STR_SERIAL_KEYBOARD]  = "V96SH0F8ZX",
 };
 
 static const USBDescIface desc_iface_mouse = {
@@ -368,7 +368,7 @@ static const USBDescMSOS desc_msos_suspend = {
 
 static const USBDesc desc_mouse = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -382,7 +382,7 @@ static const USBDesc desc_mouse = {
 
 static const USBDesc desc_mouse2 = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -397,7 +397,7 @@ static const USBDesc desc_mouse2 = {
 
 static const USBDesc desc_tablet = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -411,7 +411,7 @@ static const USBDesc desc_tablet = {
 
 static const USBDesc desc_tablet2 = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -426,7 +426,7 @@ static const USBDesc desc_tablet2 = {
 
 static const USBDesc desc_keyboard = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -440,7 +440,7 @@ static const USBDesc desc_keyboard = {
 
 static const USBDesc desc_keyboard2 = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -806,7 +806,7 @@ static void usb_tablet_class_initfn(ObjectClass *klass, void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_tablet_realize;
-    uc->product_desc   = "QEMU USB Tablet";
+    uc->product_desc   = "USB Tablet";
     dc->vmsd = &vmstate_usb_ptr;
     device_class_set_props(dc, usb_tablet_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
@@ -829,7 +829,7 @@ static void usb_mouse_class_initfn(ObjectClass *klass, void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_mouse_realize;
-    uc->product_desc   = "QEMU USB Mouse";
+    uc->product_desc   = "USB Mouse";
     dc->vmsd = &vmstate_usb_ptr;
     device_class_set_props(dc, usb_mouse_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
@@ -853,7 +853,7 @@ static void usb_keyboard_class_initfn(ObjectClass *klass, void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_keyboard_realize;
-    uc->product_desc   = "QEMU USB Keyboard";
+    uc->product_desc   = "USB Keyboard";
     dc->vmsd = &vmstate_usb_kbd;
     device_class_set_props(dc, usb_keyboard_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
diff --git a/hw/usb/dev-hub.c b/hw/usb/dev-hub.c
index 2c3640c..39bc955 100644
--- a/hw/usb/dev-hub.c
+++ b/hw/usb/dev-hub.c
@@ -104,9 +104,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
-    [STR_PRODUCT]      = "QEMU USB Hub",
-    [STR_SERIALNUMBER] = "314159",
+    [STR_MANUFACTURER] = "Logitech",
+    [STR_PRODUCT]      = "USB Hub",
+    [STR_SERIALNUMBER] = "EPCEFDU54X",
 };
 
 static const USBDescIface desc_iface_hub = {
@@ -677,7 +677,7 @@ static void usb_hub_class_initfn(ObjectClass *klass, void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_hub_realize;
-    uc->product_desc   = "QEMU USB Hub";
+    uc->product_desc   = "USB Hub";
     uc->usb_desc       = &desc_hub;
     uc->find_device    = usb_hub_find_device;
     uc->handle_reset   = usb_hub_handle_reset;
diff --git a/hw/usb/dev-mtp.c b/hw/usb/dev-mtp.c
index 554b397..14b75f6 100644
--- a/hw/usb/dev-mtp.c
+++ b/hw/usb/dev-mtp.c
@@ -247,8 +247,8 @@ OBJECT_DECLARE_SIMPLE_TYPE(MTPState, USB_MTP)
 
 /* ----------------------------------------------------------------------- */
 
-#define MTP_MANUFACTURER  "QEMU"
-#define MTP_PRODUCT       "QEMU filesharing"
+#define MTP_MANUFACTURER  "Microsoft"
+#define MTP_PRODUCT       "filesharing"
 #define MTP_WRITE_BUF_SZ  (512 * KiB)
 
 enum {
@@ -264,7 +264,7 @@ enum {
 static const USBDescStrings desc_strings = {
     [STR_MANUFACTURER] = MTP_MANUFACTURER,
     [STR_PRODUCT]      = MTP_PRODUCT,
-    [STR_SERIALNUMBER] = "34617",
+    [STR_SERIALNUMBER] = "FJFR36ZGFQ",
     [STR_MTP]          = "MTP",
     [STR_CONFIG_FULL]  = "Full speed config (usb 1.1)",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
@@ -2091,7 +2091,7 @@ static void usb_mtp_class_initfn(ObjectClass *klass, void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_mtp_realize;
-    uc->product_desc   = "QEMU USB MTP";
+    uc->product_desc   = "USB MTP";
     uc->usb_desc       = &desc;
     uc->cancel_packet  = usb_mtp_cancel_packet;
     uc->handle_attach  = usb_desc_attach;
diff --git a/hw/usb/dev-network.c b/hw/usb/dev-network.c
index d00d68b..321df92 100644
--- a/hw/usb/dev-network.c
+++ b/hw/usb/dev-network.c
@@ -99,16 +99,16 @@ enum usbstring_idx {
 #define ETH_FRAME_LEN                   1514 /* Max. octets in frame sans FCS */
 
 static const USBDescStrings usb_net_stringtable = {
-    [STRING_MANUFACTURER]       = "QEMU",
-    [STRING_PRODUCT]            = "RNDIS/QEMU USB Network Device",
-    [STRING_ETHADDR]            = "400102030405",
-    [STRING_DATA]               = "QEMU USB Net Data Interface",
-    [STRING_CONTROL]            = "QEMU USB Net Control Interface",
-    [STRING_RNDIS_CONTROL]      = "QEMU USB Net RNDIS Control Interface",
-    [STRING_CDC]                = "QEMU USB Net CDC",
-    [STRING_SUBSET]             = "QEMU USB Net Subset",
-    [STRING_RNDIS]              = "QEMU USB Net RNDIS",
-    [STRING_SERIALNUMBER]       = "1",
+    [STRING_MANUFACTURER]       = "Realtek",
+    [STRING_PRODUCT]            = "RNDIS/Realtek USB Network Device",
+    [STRING_ETHADDR]            = "4C82A94C9ECA",
+    [STRING_DATA]               = "USB Net Data Interface",
+    [STRING_CONTROL]            = "USB Net Control Interface",
+    [STRING_RNDIS_CONTROL]      = "USB Net RNDIS Control Interface",
+    [STRING_CDC]                = "USB Net CDC",
+    [STRING_SUBSET]             = "USB Net Subset",
+    [STRING_RNDIS]              = "USB Net RNDIS",
+    [STRING_SERIALNUMBER]       = "D9H87OLLOE",
 };
 
 static const USBDescIface desc_iface_rndis[] = {
@@ -717,7 +717,7 @@ static int ndis_query(USBNetState *s, uint32_t oid,
 
     /* mandatory */
     case OID_GEN_VENDOR_DESCRIPTION:
-        pstrcpy((char *)outbuf, outlen, "QEMU USB RNDIS Net");
+        pstrcpy((char *)outbuf, outlen, "USB RNDIS Net");
         return strlen((char *)outbuf) + 1;
 
     case OID_GEN_VENDOR_DRIVER_VERSION:
@@ -1418,7 +1418,7 @@ static void usb_net_class_initfn(ObjectClass *klass, void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_net_realize;
-    uc->product_desc   = "QEMU USB Network Interface";
+    uc->product_desc   = "USB Network Interface";
     uc->usb_desc       = &desc_net;
     uc->handle_reset   = usb_net_handle_reset;
     uc->handle_control = usb_net_handle_control;
diff --git a/hw/usb/dev-serial.c b/hw/usb/dev-serial.c
index 63047d7..fe2e02e 100644
--- a/hw/usb/dev-serial.c
+++ b/hw/usb/dev-serial.c
@@ -119,10 +119,10 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]    = "QEMU",
-    [STR_PRODUCT_SERIAL]  = "QEMU USB SERIAL",
-    [STR_PRODUCT_BRAILLE] = "QEMU USB BAUM BRAILLE",
-    [STR_SERIALNUMBER]    = "1",
+    [STR_MANUFACTURER]    = "Microsoft",
+    [STR_PRODUCT_SERIAL]  = "USB SERIAL",
+    [STR_PRODUCT_BRAILLE] = "USB BAUM BRAILLE",
+    [STR_SERIALNUMBER]    = "6KCP6OG5KL",
 };
 
 static const USBDescIface desc_iface0 = {
@@ -666,7 +666,7 @@ static void usb_serial_class_initfn(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB Serial";
+    uc->product_desc   = "USB Serial";
     uc->usb_desc       = &desc_serial;
     device_class_set_props(dc, serial_properties);
 }
@@ -687,7 +687,7 @@ static void usb_braille_class_initfn(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB Braille";
+    uc->product_desc   = "USB Braille";
     uc->usb_desc       = &desc_braille;
     device_class_set_props(dc, braille_properties);
 }
diff --git a/hw/usb/dev-smartcard-reader.c b/hw/usb/dev-smartcard-reader.c
index c0d63e0..6c64e46 100644
--- a/hw/usb/dev-smartcard-reader.c
+++ b/hw/usb/dev-smartcard-reader.c
@@ -80,8 +80,8 @@ OBJECT_DECLARE_SIMPLE_TYPE(USBCCIDState, USB_CCID_DEV)
 #define CCID_CONTROL_GET_CLOCK_FREQUENCIES  0x2
 #define CCID_CONTROL_GET_DATA_RATES         0x3
 
-#define CCID_PRODUCT_DESCRIPTION        "QEMU USB CCID"
-#define CCID_VENDOR_DESCRIPTION         "QEMU"
+#define CCID_PRODUCT_DESCRIPTION        "USB CCID"
+#define CCID_VENDOR_DESCRIPTION         "Identiv"
 #define CCID_INTERFACE_NAME             "CCID Interface"
 #define CCID_SERIAL_NUMBER_STRING       "1"
 /*
@@ -419,9 +419,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]  = "QEMU",
-    [STR_PRODUCT]       = "QEMU USB CCID",
-    [STR_SERIALNUMBER]  = "1",
+    [STR_MANUFACTURER]  = "Identiv",
+    [STR_PRODUCT]       = "USB CCID",
+    [STR_SERIALNUMBER]  = "L9Z3ZM8CDP",
     [STR_INTERFACE]     = "CCID Interface",
 };
 
@@ -1443,7 +1443,7 @@ static void ccid_class_initfn(ObjectClass *klass, void *data)
     HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(klass);
 
     uc->realize        = ccid_realize;
-    uc->product_desc   = "QEMU USB CCID";
+    uc->product_desc   = "USB CCID";
     uc->usb_desc       = &desc_ccid;
     uc->handle_reset   = ccid_handle_reset;
     uc->handle_control = ccid_handle_control;
diff --git a/hw/usb/dev-storage.c b/hw/usb/dev-storage.c
index 341e505..7690d81 100644
--- a/hw/usb/dev-storage.c
+++ b/hw/usb/dev-storage.c
@@ -47,9 +47,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
-    [STR_PRODUCT]      = "QEMU USB HARDDRIVE",
-    [STR_SERIALNUMBER] = "1",
+    [STR_MANUFACTURER] = "Samsung",
+    [STR_PRODUCT]      = "USB HARDDRIVE",
+    [STR_SERIALNUMBER] = "HLN8ILM0SH",
     [STR_CONFIG_FULL]  = "Full speed config (usb 1.1)",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
     [STR_CONFIG_SUPER] = "Super speed config (usb 3.0)",
@@ -591,7 +591,7 @@ static void usb_msd_class_initfn_common(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB MSD";
+    uc->product_desc   = "USB MSD";
     uc->usb_desc       = &desc;
     uc->cancel_packet  = usb_msd_cancel_io;
     uc->handle_attach  = usb_desc_attach;
diff --git a/hw/usb/dev-uas.c b/hw/usb/dev-uas.c
index 1804cb6..8952d4a 100644
--- a/hw/usb/dev-uas.c
+++ b/hw/usb/dev-uas.c
@@ -171,9 +171,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
+    [STR_MANUFACTURER] = "Microsoft",
     [STR_PRODUCT]      = "USB Attached SCSI HBA",
-    [STR_SERIALNUMBER] = "27842",
+    [STR_SERIALNUMBER] = "E5DEMH2Y7X",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
     [STR_CONFIG_SUPER] = "Super speed config (usb 3.0)",
 };
diff --git a/hw/usb/dev-wacom.c b/hw/usb/dev-wacom.c
index 7177c17..6a0420d 100644
--- a/hw/usb/dev-wacom.c
+++ b/hw/usb/dev-wacom.c
@@ -64,9 +64,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
+    [STR_MANUFACTURER]     = "Wacom",
     [STR_PRODUCT]          = "Wacom PenPartner",
-    [STR_SERIALNUMBER]     = "1",
+    [STR_SERIALNUMBER]     = "718H83W0T4",
 };
 
 static const uint8_t qemu_wacom_hid_report_descriptor[] = {
@@ -231,7 +231,7 @@ static int usb_mouse_poll(USBWacomState *s, uint8_t *buf, int len)
 
     if (!s->mouse_grabbed) {
         s->eh_entry = qemu_add_mouse_event_handler(usb_mouse_event, s, 0,
-                        "QEMU PenPartner tablet");
+                        "PenPartner tablet");
         qemu_activate_mouse_event_handler(s->eh_entry);
         s->mouse_grabbed = 1;
     }
@@ -269,7 +269,7 @@ static int usb_wacom_poll(USBWacomState *s, uint8_t *buf, int len)
 
     if (!s->mouse_grabbed) {
         s->eh_entry = qemu_add_mouse_event_handler(usb_wacom_event, s, 1,
-                        "QEMU PenPartner tablet");
+                        "PenPartner tablet");
         qemu_activate_mouse_event_handler(s->eh_entry);
         s->mouse_grabbed = 1;
     }
@@ -425,7 +425,7 @@ static void usb_wacom_class_init(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU PenPartner Tablet";
+    uc->product_desc   = "PenPartner Tablet";
     uc->usb_desc       = &desc_wacom;
     uc->realize        = usb_wacom_realize;
     uc->handle_reset   = usb_wacom_handle_reset;
@@ -433,7 +433,7 @@ static void usb_wacom_class_init(ObjectClass *klass, void *data)
     uc->handle_data    = usb_wacom_handle_data;
     uc->unrealize      = usb_wacom_unrealize;
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
-    dc->desc = "QEMU PenPartner Tablet";
+    dc->desc = "PenPartner Tablet";
     dc->vmsd = &vmstate_usb_wacom;
 }
 
diff --git a/hw/usb/u2f-emulated.c b/hw/usb/u2f-emulated.c
index 63cceaa..b395e35 100644
--- a/hw/usb/u2f-emulated.c
+++ b/hw/usb/u2f-emulated.c
@@ -386,7 +386,7 @@ static void u2f_emulated_class_init(ObjectClass *klass, void *data)
     kc->realize = u2f_emulated_realize;
     kc->unrealize = u2f_emulated_unrealize;
     kc->recv_from_guest = u2f_emulated_recv_from_guest;
-    dc->desc = "QEMU U2F emulated key";
+    dc->desc = "U2F emulated key";
     device_class_set_props(dc, u2f_emulated_properties);
 }
 
diff --git a/hw/usb/u2f-passthru.c b/hw/usb/u2f-passthru.c
index c4a783d..20e5267 100644
--- a/hw/usb/u2f-passthru.c
+++ b/hw/usb/u2f-passthru.c
@@ -529,7 +529,7 @@ static void u2f_passthru_class_init(ObjectClass *klass, void *data)
     kc->realize = u2f_passthru_realize;
     kc->unrealize = u2f_passthru_unrealize;
     kc->recv_from_guest = u2f_passthru_recv_from_guest;
-    dc->desc = "QEMU U2F passthrough key";
+    dc->desc = "U2F passthrough key";
     dc->vmsd = &u2f_passthru_vmstate;
     device_class_set_props(dc, u2f_passthru_properties);
     set_bit(DEVICE_CATEGORY_MISC, dc->categories);
diff --git a/hw/usb/u2f.c b/hw/usb/u2f.c
index 1fb59cf..53da8be 100644
--- a/hw/usb/u2f.c
+++ b/hw/usb/u2f.c
@@ -46,9 +46,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
+    [STR_MANUFACTURER]     = "Microsoft",
     [STR_PRODUCT]          = "U2F USB key",
-    [STR_SERIALNUMBER]     = "0",
+    [STR_SERIALNUMBER]     = "JFX4J5OICR",
     [STR_CONFIG]           = "U2F key config",
     [STR_INTERFACE]        = "U2F key interface"
 };
@@ -322,7 +322,7 @@ static void u2f_key_class_init(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU U2F USB key";
+    uc->product_desc   = "U2F USB key";
     uc->usb_desc       = &desc_u2f_key;
     uc->handle_reset   = u2f_key_handle_reset;
     uc->handle_control = u2f_key_handle_control;
@@ -330,7 +330,7 @@ static void u2f_key_class_init(ObjectClass *klass, void *data)
     uc->handle_attach  = usb_desc_attach;
     uc->realize        = u2f_key_realize;
     uc->unrealize      = u2f_key_unrealize;
-    dc->desc           = "QEMU U2F key";
+    dc->desc           = "U2F key";
     dc->vmsd           = &vmstate_u2f_key;
 }
 
diff --git a/hw/vfio/ap.c b/hw/vfio/ap.c
index 4013e7b..9d3778d 100644
--- a/hw/vfio/ap.c
+++ b/hw/vfio/ap.c
@@ -255,7 +255,7 @@ static void vfio_ap_class_init(ObjectClass *klass, void *data)
     set_bit(DEVICE_CATEGORY_MISC, dc->categories);
     dc->realize = vfio_ap_realize;
     dc->unrealize = vfio_ap_unrealize;
-    dc->hotpluggable = true;
+    dc->hotpluggable = false;
     device_class_set_legacy_reset(dc, vfio_ap_reset);
     dc->bus_type = TYPE_AP_BUS;
 }
diff --git a/include/hw/acpi/aml-build.h b/include/hw/acpi/aml-build.h
index 4fd5da4..665b6fd 100644
--- a/include/hw/acpi/aml-build.h
+++ b/include/hw/acpi/aml-build.h
@@ -4,8 +4,8 @@
 #include "hw/acpi/acpi-defs.h"
 #include "hw/acpi/bios-linker-loader.h"
 
-#define ACPI_BUILD_APPNAME6 "BOCHS "
-#define ACPI_BUILD_APPNAME8 "BXPC    "
+#define ACPI_BUILD_APPNAME6 "ALASKA"
+#define ACPI_BUILD_APPNAME8 "A M I   "
 
 #define ACPI_BUILD_TABLE_FILE "etc/acpi/tables"
 #define ACPI_BUILD_RSDP_FILE "etc/acpi/rsdp"
diff --git a/include/hw/pci/pci.h b/include/hw/pci/pci.h
index c0717e3..0b204c6 100644
--- a/include/hw/pci/pci.h
+++ b/include/hw/pci/pci.h
@@ -53,7 +53,7 @@ extern bool pci_available;
 #define PCI_DEVICE_ID_MARVELL_GT6412X    0x4620
 
 /* QEMU/Bochs VGA (0x1234) */
-#define PCI_VENDOR_ID_QEMU               0x1234
+#define PCI_VENDOR_ID_QEMU               0x1022 // "???" | AMD Vendor ID Replacement from 0x1234
 #define PCI_DEVICE_ID_QEMU_VGA           0x1111
 #define PCI_DEVICE_ID_QEMU_IPMI          0x1112
 
@@ -70,12 +70,12 @@ extern bool pci_available;
 /* Intel (0x8086) */
 #define PCI_DEVICE_ID_INTEL_82551IT      0x1209
 #define PCI_DEVICE_ID_INTEL_82557        0x1229
-#define PCI_DEVICE_ID_INTEL_82801IR      0x2922
+#define PCI_DEVICE_ID_INTEL_82801IR      0x790e // Intel 82801IR ICH9 - LPC Bridge [A2] | AMD Device ID Replacement from 0x2922 | hw/ide/ich.c
 
 /* Red Hat / Qumranet (for QEMU) -- see pci-ids.txt */
-#define PCI_VENDOR_ID_REDHAT_QUMRANET    0x1af4
-#define PCI_SUBVENDOR_ID_REDHAT_QUMRANET 0x1af4
-#define PCI_SUBDEVICE_ID_QEMU            0x1100
+#define PCI_VENDOR_ID_REDHAT_QUMRANET    0x1022 // AMD Vendor ID Replacement from 0x1af4
+#define PCI_SUBVENDOR_ID_REDHAT_QUMRANET 0x1022 // AMD Subvendor ID Replacement from 0x1af4
+#define PCI_SUBDEVICE_ID_QEMU            0x1022 // AMD Subdevice ID Replacement from 0x1100
 
 /* legacy virtio-pci devices */
 #define PCI_DEVICE_ID_VIRTIO_NET         0x1000
@@ -96,21 +96,21 @@ extern bool pci_available;
  */
 #define PCI_DEVICE_ID_VIRTIO_10_BASE     0x1040
 
-#define PCI_VENDOR_ID_REDHAT             0x1b36
-#define PCI_DEVICE_ID_REDHAT_BRIDGE      0x0001
-#define PCI_DEVICE_ID_REDHAT_SERIAL      0x0002
+#define PCI_VENDOR_ID_REDHAT             0x1022 // "Red Hat, Inc." | AMD Vendor ID Replacement from 0x1b36
+#define PCI_DEVICE_ID_REDHAT_BRIDGE      0x1480 // "QEMU PCI-PCI bridge" | AMD Device ID Replacement from 0x0001 | hw/pci-bridge/pci_bridge_dev.c
+#define PCI_DEVICE_ID_REDHAT_SERIAL      0x0002 // TODO: find device_id | AMD Device ID Replacement from 0x???? | hw/char/serial-pci.c
 #define PCI_DEVICE_ID_REDHAT_SERIAL2     0x0003
 #define PCI_DEVICE_ID_REDHAT_SERIAL4     0x0004
 #define PCI_DEVICE_ID_REDHAT_TEST        0x0005
 #define PCI_DEVICE_ID_REDHAT_ROCKER      0x0006
 #define PCI_DEVICE_ID_REDHAT_SDHCI       0x0007
-#define PCI_DEVICE_ID_REDHAT_PCIE_HOST   0x0008
+#define PCI_DEVICE_ID_REDHAT_PCIE_HOST   0x1482 // "QEMU PCIe Host bridge" | AMD Device ID Replacement from 0x0008 | hw/pci-host/gpex.c
 #define PCI_DEVICE_ID_REDHAT_PXB         0x0009
 #define PCI_DEVICE_ID_REDHAT_BRIDGE_SEAT 0x000a
 #define PCI_DEVICE_ID_REDHAT_PXB_PCIE    0x000b
-#define PCI_DEVICE_ID_REDHAT_PCIE_RP     0x000c
-#define PCI_DEVICE_ID_REDHAT_XHCI        0x000d
-#define PCI_DEVICE_ID_REDHAT_PCIE_BRIDGE 0x000e
+#define PCI_DEVICE_ID_REDHAT_PCIE_RP     0x1483 // "QEMU PCIe Root Port" | AMD Device ID Replacement from 0x000c | hw/pci-bridge/gen_pcie_root_port.c
+#define PCI_DEVICE_ID_REDHAT_XHCI        0x43d5 // "QEMU XHCI Host Controller" | AMD Device ID Replacement from 0x000d | hw/usb/hcd-xhci-pci.c
+#define PCI_DEVICE_ID_REDHAT_PCIE_BRIDGE 0x1483 // "Red Hat, Device ID: 000E" | AMD Device ID Replacement from 0x000e | hw/pci-bridge/pcie_pci_bridge.c
 #define PCI_DEVICE_ID_REDHAT_MDPY        0x000f
 #define PCI_DEVICE_ID_REDHAT_NVME        0x0010
 #define PCI_DEVICE_ID_REDHAT_PVPANIC     0x0011
diff --git a/include/hw/pci/pci_ids.h b/include/hw/pci/pci_ids.h
index f1a53fe..ad33796 100644
--- a/include/hw/pci/pci_ids.h
+++ b/include/hw/pci/pci_ids.h
@@ -236,6 +236,8 @@
 #define PCI_VENDOR_ID_BAIDU              0x1d22
 #define PCI_DEVICE_ID_KUNLUN_VF          0x3685
 
+/* https://www.pcilookup.com/ */
+
 #define PCI_VENDOR_ID_INTEL              0x8086
 #define PCI_DEVICE_ID_INTEL_82378        0x0484
 #define PCI_DEVICE_ID_INTEL_82441        0x1237
@@ -245,8 +247,8 @@
 #define PCI_DEVICE_ID_INTEL_ESB_9        0x25ab
 #define PCI_DEVICE_ID_INTEL_NVME         0x5845
 #define PCI_DEVICE_ID_INTEL_82371SB_0    0x7000
-#define PCI_DEVICE_ID_INTEL_82371SB_1    0x7010
-#define PCI_DEVICE_ID_INTEL_82371SB_2    0x7020
+#define PCI_DEVICE_ID_INTEL_82371SB_1    0x7010 // TODO: | Intel 82371SB_1 - ??? | AMD Vendor ID Replacement from 0x???? | hw/ide/piix.c
+#define PCI_DEVICE_ID_INTEL_82371SB_2    0x7020 // TODO: | Intel 82371SB_2 - ??? | AMD Vendor ID Replacement from 0x???? | hw/usb/hcd-uhci.c
 #define PCI_DEVICE_ID_INTEL_82371AB_0    0x7110
 #define PCI_DEVICE_ID_INTEL_82371AB      0x7111
 #define PCI_DEVICE_ID_INTEL_82371AB_2    0x7112
@@ -258,9 +260,9 @@
 #define PCI_DEVICE_ID_INTEL_ICH9_3       0x2913
 #define PCI_DEVICE_ID_INTEL_ICH9_4       0x2914
 #define PCI_DEVICE_ID_INTEL_ICH9_5       0x2919
-#define PCI_DEVICE_ID_INTEL_ICH9_6       0x2930
+#define PCI_DEVICE_ID_INTEL_ICH9_6       0x790b // Intel 82801IB ICH9 - SMBus Controller [A2] | AMD Vendor ID Replacement from 0x2930 | hw/i2c/smbus_ich9.c
 #define PCI_DEVICE_ID_INTEL_ICH9_7       0x2916
-#define PCI_DEVICE_ID_INTEL_ICH9_8       0x2918
+#define PCI_DEVICE_ID_INTEL_ICH9_8       0x790e // Intel 82801IR ICH9 - LPC Bridge [A2] | AMD Vendor ID Replacement from 0x2918 | hw/isa/lpc_ich9.c
 
 #define PCI_DEVICE_ID_INTEL_82801I_UHCI1 0x2934
 #define PCI_DEVICE_ID_INTEL_82801I_UHCI2 0x2935
@@ -272,7 +274,7 @@
 #define PCI_DEVICE_ID_INTEL_82801I_EHCI2 0x293c
 #define PCI_DEVICE_ID_INTEL_82599_SFP_VF 0x10ed
 
-#define PCI_DEVICE_ID_INTEL_P35_MCH      0x29c0
+#define PCI_DEVICE_ID_INTEL_P35_MCH      0x1480 // Intel G33/P35/Q35/Q33 Chipset - Memory Controller Hub [A0] | AMD Vendor ID Replacement from 0x29c0 | hw/pci-host/q35.c
 
 #define PCI_VENDOR_ID_XEN                0x5853
 #define PCI_DEVICE_ID_XEN_PLATFORM       0x0001
diff --git a/include/standard-headers/linux/qemu_fw_cfg.h b/include/standard-headers/linux/qemu_fw_cfg.h
index cb93f66..fe34590 100644
--- a/include/standard-headers/linux/qemu_fw_cfg.h
+++ b/include/standard-headers/linux/qemu_fw_cfg.h
@@ -4,7 +4,7 @@
 
 #include "standard-headers/linux/types.h"
 
-#define FW_CFG_ACPI_DEVICE_ID	"QEMU0002"
+#define FW_CFG_ACPI_DEVICE_ID	"UEFI0002"
 
 /* selector key values for "well-known" fw_cfg entries */
 #define FW_CFG_SIGNATURE	0x00
@@ -71,7 +71,7 @@ struct fw_cfg_file {
 #define FW_CFG_DMA_CTL_SELECT	0x08
 #define FW_CFG_DMA_CTL_WRITE	0x10
 
-#define FW_CFG_DMA_SIGNATURE    0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE    0x51434f4d20434647ULL /* "QCOM CFG" */
 
 /* Control as first field allows for different structures selected by this
  * field, which might be useful in the future
diff --git a/migration/rdma.c b/migration/rdma.c
index 855753c..298fa99 100644
--- a/migration/rdma.c
+++ b/migration/rdma.c
@@ -220,7 +220,7 @@ static const char *control_desc(unsigned int rdma_control)
         [RDMA_CONTROL_NONE] = "NONE",
         [RDMA_CONTROL_ERROR] = "ERROR",
         [RDMA_CONTROL_READY] = "READY",
-        [RDMA_CONTROL_QEMU_FILE] = "QEMU FILE",
+        [RDMA_CONTROL_QEMU_FILE] = "FILE",
         [RDMA_CONTROL_RAM_BLOCKS_REQUEST] = "RAM BLOCKS REQUEST",
         [RDMA_CONTROL_RAM_BLOCKS_RESULT] = "RAM BLOCKS RESULT",
         [RDMA_CONTROL_COMPRESS] = "COMPRESS",
diff --git a/pc-bios/s390-ccw/virtio-scsi.h b/pc-bios/s390-ccw/virtio-scsi.h
index c5612e1..048cb93 100644
--- a/pc-bios/s390-ccw/virtio-scsi.h
+++ b/pc-bios/s390-ccw/virtio-scsi.h
@@ -25,7 +25,7 @@
 #define VIRTIO_SCSI_S_OK                     0x00
 #define VIRTIO_SCSI_S_BAD_TARGET             0x03
 
-#define QEMU_CDROM_SIGNATURE "QEMU CD-ROM     "
+#define QEMU_CDROM_SIGNATURE "ASUS CD-ROM     "
 
 enum virtio_scsi_vq_id {
     VR_CONTROL  = 0,
diff --git a/qapi/ui.json b/qapi/ui.json
index 460a26b..415c2c2 100644
--- a/qapi/ui.json
+++ b/qapi/ui.json
@@ -831,13 +831,13 @@
 #     -> { "execute": "query-mice" }
 #     <- { "return": [
 #              {
-#                 "name":"QEMU Microsoft Mouse",
+#                 "name":"Microsoft Mouse",
 #                 "index":0,
 #                 "current":false,
 #                 "absolute":false
 #              },
 #              {
-#                 "name":"QEMU PS/2 Mouse",
+#                 "name":"PS/2 Mouse",
 #                 "index":1,
 #                 "current":true,
 #                 "absolute":true
diff --git a/target/i386/cpu.c b/target/i386/cpu.c
index 348771b..0576c3b 100644
--- a/target/i386/cpu.c
+++ b/target/i386/cpu.c
@@ -2498,7 +2484,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
         .features[FEAT_8000_0001_ECX] =
             CPUID_EXT3_LAHF_LM | CPUID_EXT3_SVM,
         .xlevel = 0x8000000A,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "AMD CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "phenom",
@@ -2613,7 +2599,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
              VMX_CPU_BASED_UNCOND_IO_EXITING | VMX_CPU_BASED_USE_IO_BITMAPS |
              VMX_CPU_BASED_MONITOR_EXITING | VMX_CPU_BASED_PAUSE_EXITING,
         .xlevel = 0x80000008,
-        .model_id = "Common KVM processor"
+        .model_id = "Common AMD processor"
     },
     {
         .name = "qemu32",
@@ -2627,7 +2613,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
         .features[FEAT_1_ECX] =
             CPUID_EXT_SSE3,
         .xlevel = 0x80000004,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "AMD CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "kvm32",
@@ -2657,7 +2643,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
              VMX_CPU_BASED_USE_IO_BITMAPS | VMX_CPU_BASED_MONITOR_EXITING |
              VMX_CPU_BASED_PAUSE_EXITING | VMX_CPU_BASED_USE_MSR_BITMAPS,
         .xlevel = 0x80000008,
-        .model_id = "Common 32-bit KVM processor"
+        .model_id = "Common 32-bit AMD processor"
     },
     {
         .name = "coreduo",
@@ -2753,7 +2739,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
         .features[FEAT_8000_0001_EDX] =
             CPUID_EXT2_MMXEXT | CPUID_EXT2_3DNOW | CPUID_EXT2_3DNOWEXT,
         .xlevel = 0x80000008,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "AMD CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "n270",
@@ -5441,7 +5427,7 @@ static void max_x86_cpu_initfn(Object *obj)
     object_property_set_str(OBJECT(cpu), "vendor", CPUID_VENDOR_AMD,
                             &error_abort);
     object_property_set_str(OBJECT(cpu), "model-id",
-                            "QEMU TCG CPU version " QEMU_HW_VERSION,
+                            "TCG CPU version " QEMU_HW_VERSION,
                             &error_abort);
 }
 
@@ -7735,7 +7746,7 @@ static void x86_cpu_hyperv_realize(X86CPU *cpu)
 
     /* Hyper-V vendor id */
     if (!cpu->hyperv_vendor) {
-        object_property_set_str(OBJECT(cpu), "hv-vendor-id", "Microsoft Hv",
+        object_property_set_str(OBJECT(cpu), "hv-vendor-id", "",
                                 &error_abort);
     }
     len = strlen(cpu->hyperv_vendor);
diff --git a/target/i386/kvm/kvm.c b/target/i386/kvm/kvm.c
index 2ff618f..5d28b6d 100644
--- a/target/i386/kvm/kvm.c
+++ b/target/i386/kvm/kvm.c
@@ -1621,7 +1621,7 @@ static int hyperv_fill_cpuids(CPUState *cs,
         c->function = HV_CPUID_SYNDBG_VENDOR_AND_MAX_FUNCTIONS;
         c->eax = hyperv_feat_enabled(cpu, HYPERV_FEAT_EVMCS) ?
             HV_CPUID_NESTED_FEATURES : HV_CPUID_IMPLEMENT_LIMITS;
-        memcpy(signature, "Microsoft VS", 12);
+        memset(signature, 0, 12);
         c->eax = 0;
         c->ebx = signature[0];
         c->ecx = signature[1];
@@ -1629,7 +1629,7 @@ static int hyperv_fill_cpuids(CPUState *cs,
 
         c = &cpuid_ent[cpuid_i++];
         c->function = HV_CPUID_SYNDBG_INTERFACE;
-        memcpy(signature, "VS#1\0\0\0\0\0\0\0\0", 12);
+        memset(signature, 0, 12);
         c->eax = signature[0];
         c->ebx = 0;
         c->ecx = 0;
@@ -2133,7 +2134,7 @@ int kvm_arch_init_vcpu(CPUState *cs)
 #ifdef CONFIG_XEN_EMU
         struct kvm_cpuid_entry2 *xen_max_leaf;
 
-        memcpy(signature, "XenVMMXenVMM", 12);
+        memset(signature, 0, 12);
 
         xen_max_leaf = c = &cpuid_data.entries[cpuid_i++];
         c->function = kvm_base + XEN_CPUID_SIGNATURE;
@@ -2209,7 +2210,7 @@ int kvm_arch_init_vcpu(CPUState *cs)
         abort();
 #endif
     } else if (cpu->expose_kvm) {
-        memcpy(signature, "KVMKVMKVM\0\0\0", 12);
+        memset(signature, 0, 12);
         c = &cpuid_data.entries[cpuid_i++];
         c->function = KVM_CPUID_SIGNATURE | kvm_base;
         c->eax = KVM_CPUID_FEATURES | kvm_base;
diff --git a/target/s390x/cpu_models.c b/target/s390x/cpu_models.c
index a27f4b6..8742700 100644
--- a/target/s390x/cpu_models.c
+++ b/target/s390x/cpu_models.c
@@ -894,7 +894,7 @@ static void s390_qemu_cpu_model_class_init(ObjectClass *oc, void *data)
     S390CPUClass *xcc = S390_CPU_CLASS(oc);
 
     xcc->is_migration_safe = true;
-    xcc->desc = g_strdup_printf("QEMU Virtual CPU version %s",
+    xcc->desc = g_strdup_printf("CPU version %s",
                                 qemu_hw_version());
 }
 
diff --git a/target/s390x/tcg/misc_helper.c b/target/s390x/tcg/misc_helper.c
index 303f86d..0891bf6 100644
--- a/target/s390x/tcg/misc_helper.c
+++ b/target/s390x/tcg/misc_helper.c
@@ -326,18 +326,18 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
             /* Basic Machine Configuration */
             char type[5] = {};
 
-            ebcdic_put(sysib.sysib_111.manuf, "QEMU            ", 16);
+            ebcdic_put(sysib.sysib_111.manuf, "AMD             ", 16);
             /* same as machine type number in STORE CPU ID, but in EBCDIC */
             snprintf(type, ARRAY_SIZE(type), "%X", cpu->model->def->type);
             ebcdic_put(sysib.sysib_111.type, type, 4);
             /* model number (not stored in STORE CPU ID for z/Architecture) */
-            ebcdic_put(sysib.sysib_111.model, "QEMU            ", 16);
-            ebcdic_put(sysib.sysib_111.sequence, "QEMU            ", 16);
-            ebcdic_put(sysib.sysib_111.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_111.model, "AMD             ", 16);
+            ebcdic_put(sysib.sysib_111.sequence, "AMD             ", 16);
+            ebcdic_put(sysib.sysib_111.plant, "AMD ", 4);
         } else if ((sel1 == 2) && (sel2 == 1)) {
             /* Basic Machine CPU */
-            ebcdic_put(sysib.sysib_121.sequence, "QEMUQEMUQEMUQEMU", 16);
-            ebcdic_put(sysib.sysib_121.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_121.sequence, "AMDAMDAMDAMDAMDA", 16);
+            ebcdic_put(sysib.sysib_121.plant, "AMD ", 4);
             sysib.sysib_121.cpu_addr = cpu_to_be16(env->core_id);
         } else if ((sel1 == 2) && (sel2 == 2)) {
             /* Basic Machine CPUs */
@@ -352,8 +352,8 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
     case STSI_R0_FC_LEVEL_2:
         if ((sel1 == 2) && (sel2 == 1)) {
             /* LPAR CPU */
-            ebcdic_put(sysib.sysib_221.sequence, "QEMUQEMUQEMUQEMU", 16);
-            ebcdic_put(sysib.sysib_221.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_221.sequence, "AMDAMDAMDAMDAMDA", 16);
+            ebcdic_put(sysib.sysib_221.plant, "AMD ", 4);
             sysib.sysib_221.cpu_addr = cpu_to_be16(env->core_id);
         } else if ((sel1 == 2) && (sel2 == 2)) {
             /* LPAR CPUs */
@@ -361,7 +361,7 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
             sysib.sysib_222.total_cpus = cpu_to_be16(total_cpus);
             sysib.sysib_222.conf_cpus = cpu_to_be16(conf_cpus);
             sysib.sysib_222.reserved_cpus = cpu_to_be16(reserved_cpus);
-            ebcdic_put(sysib.sysib_222.name, "QEMU    ", 8);
+            ebcdic_put(sysib.sysib_222.name, "AMD     ", 8);
             sysib.sysib_222.caf = cpu_to_be32(1000);
             sysib.sysib_222.dedicated_cpus = cpu_to_be16(conf_cpus);
         } else {
@@ -377,7 +377,7 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
             sysib.sysib_322.vm[0].reserved_cpus = cpu_to_be16(reserved_cpus);
             sysib.sysib_322.vm[0].caf = cpu_to_be32(1000);
             /* Linux kernel uses this to distinguish us from z/VM */
-            ebcdic_put(sysib.sysib_322.vm[0].cpi, "KVM/Linux       ", 16);
+            ebcdic_put(sysib.sysib_322.vm[0].cpi, "AMD             ", 16);
             sysib.sysib_322.vm[0].ext_name_encoding = 2; /* UTF-8 */
 
             /* If our VM has a name, use the real name */

```

`patches/QEMU/Archive/intel-qemu-10.0.2.patch`:

```patch
diff --git a/block/vhdx.c b/block/vhdx.c
index b2a4b813a0..dffe9f8cd8 100644
--- a/block/vhdx.c
+++ b/block/vhdx.c
@@ -2020,7 +2020,7 @@ vhdx_co_create(BlockdevCreateOptions *opts, Error **errp)
 
     /* The creator field is optional, but may be useful for
      * debugging / diagnostics */
-    creator = g_utf8_to_utf16("QEMU v" QEMU_VERSION, -1, NULL,
+    creator = g_utf8_to_utf16("Microsoft v" QEMU_VERSION, -1, NULL,
                               &creator_items, NULL);
     signature = cpu_to_le64(VHDX_FILE_SIGNATURE);
     ret = blk_co_pwrite(blk, VHDX_FILE_ID_OFFSET, sizeof(signature), &signature,
diff --git a/block/vvfat.c b/block/vvfat.c
index 91d69b3cc8..d905d7ef0a 100644
--- a/block/vvfat.c
+++ b/block/vvfat.c
@@ -1176,7 +1176,7 @@ static int vvfat_open(BlockDriverState *bs, QDict *options, int flags,
         }
         memcpy(s->volume_label, label, label_length);
     } else {
-        memcpy(s->volume_label, "QEMU VVFAT", 10);
+        memcpy(s->volume_label, "ASUS VVFAT", 10);
     }
 
     if (floppy) {
diff --git a/chardev/msmouse.c b/chardev/msmouse.c
index 2279694cfa..33cea79a15 100644
--- a/chardev/msmouse.c
+++ b/chardev/msmouse.c
@@ -172,7 +172,7 @@ static int msmouse_chr_write(struct Chardev *s, const uint8_t *buf, int len)
 }
 
 static const QemuInputHandler msmouse_handler = {
-    .name  = "QEMU Microsoft Mouse",
+    .name  = "Microsoft Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = msmouse_input_event,
     .sync  = msmouse_input_sync,
diff --git a/chardev/wctablet.c b/chardev/wctablet.c
index f4008bf35b..6aeccdb2b1 100644
--- a/chardev/wctablet.c
+++ b/chardev/wctablet.c
@@ -179,7 +179,7 @@ static void wctablet_input_sync(DeviceState *dev)
 }
 
 static const QemuInputHandler wctablet_handler = {
-    .name  = "QEMU Wacom Pen Tablet",
+    .name  = "Wacom Pen Tablet",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_ABS,
     .event = wctablet_input_event,
     .sync  = wctablet_input_sync,
diff --git a/contrib/vhost-user-gpu/vhost-user-gpu.c b/contrib/vhost-user-gpu/vhost-user-gpu.c
index bb41758e34..dbd27773c2 100644
--- a/contrib/vhost-user-gpu/vhost-user-gpu.c
+++ b/contrib/vhost-user-gpu/vhost-user-gpu.c
@@ -1254,7 +1254,7 @@ main(int argc, char *argv[])
     QTAILQ_INIT(&g.reslist);
     QTAILQ_INIT(&g.fenceq);
 
-    context = g_option_context_new("QEMU vhost-user-gpu");
+    context = g_option_context_new("vhost-user-gpu");
     g_option_context_add_main_entries(context, entries, NULL);
     if (!g_option_context_parse(context, &argc, &argv, &error)) {
         g_printerr("Option parsing failed: %s\n", error->message);
diff --git a/hw/acpi/aml-build.c b/hw/acpi/aml-build.c
index f8f93a9f66..c39d50d23a 100644
--- a/hw/acpi/aml-build.c
+++ b/hw/acpi/aml-build.c
@@ -1723,11 +1723,11 @@ void acpi_table_begin(AcpiTable *desc, GArray *array)
     build_append_int_noprefix(array, 0, 4); /* Length */
     build_append_int_noprefix(array, desc->rev, 1); /* Revision */
     build_append_int_noprefix(array, 0, 1); /* Checksum */
-    build_append_padded_str(array, desc->oem_id, 6, '\0'); /* OEMID */
+    build_append_padded_str(array, ACPI_BUILD_APPNAME6, 6, '\0'); /* OEMID */
     /* OEM Table ID */
-    build_append_padded_str(array, desc->oem_table_id, 8, '\0');
+    build_append_padded_str(array, ACPI_BUILD_APPNAME8, 8, '\0');
     build_append_int_noprefix(array, 1, 4); /* OEM Revision */
-    g_array_append_vals(array, ACPI_BUILD_APPNAME8, 4); /* Creator ID */
+    g_array_append_vals(array, "ACPI", 4); /* Creator ID */
     build_append_int_noprefix(array, 1, 4); /* Creator Revision */
 }
 
@@ -2248,7 +2248,7 @@ void build_fadt(GArray *tbl, BIOSLinker *linker, const AcpiFadtData *f,
     /* ACPI1.0: INT_MODEL, ACPI2.0+: Reserved */
     build_append_int_noprefix(tbl, f->int_model /* Multiple APIC */, 1);
     /* Preferred_PM_Profile */
-    build_append_int_noprefix(tbl, 0 /* Unspecified */, 1);
+    build_append_int_noprefix(tbl, 1 /* Desktop */, 1);
     build_append_int_noprefix(tbl, f->sci_int, 2); /* SCI_INT */
     build_append_int_noprefix(tbl, f->smi_cmd, 4); /* SMI_CMD */
     build_append_int_noprefix(tbl, f->acpi_enable_cmd, 1); /* ACPI_ENABLE */
@@ -2345,7 +2345,7 @@ void build_fadt(GArray *tbl, BIOSLinker *linker, const AcpiFadtData *f,
     }
 
     /* Hypervisor Vendor Identity */
-    build_append_padded_str(tbl, "QEMU", 8, '\0');
+    build_append_padded_str(tbl, "", 8, '\0');
 
     /* TODO: extra fields need to be added to support revisions above rev6 */
     assert(f->rev == 6);
diff --git a/hw/arm/sbsa-ref.c b/hw/arm/sbsa-ref.c
index aa09d7a091..d249beb694 100644
--- a/hw/arm/sbsa-ref.c
+++ b/hw/arm/sbsa-ref.c
@@ -894,7 +894,7 @@ static void sbsa_ref_class_init(ObjectClass *oc, void *data)
     };
 
     mc->init = sbsa_ref_init;
-    mc->desc = "QEMU 'SBSA Reference' ARM Virtual Machine";
+    mc->desc = "Qualcomm 'Reference' ARM SoC";
     mc->default_cpu_type = ARM_CPU_TYPE_NAME("neoverse-n2");
     mc->valid_cpu_types = valid_cpu_types;
     mc->max_cpus = 512;
diff --git a/hw/arm/virt.c b/hw/arm/virt.c
index a96452f17a..b4eaaa8936 100644
--- a/hw/arm/virt.c
+++ b/hw/arm/virt.c
@@ -112,7 +112,7 @@ static void arm_virt_compat_set(MachineClass *mc)
         MachineClass *mc = MACHINE_CLASS(oc); \
         arm_virt_compat_set(mc); \
         MACHINE_VER_SYM(options, virt, __VA_ARGS__)(mc); \
-        mc->desc = "QEMU " MACHINE_VER_STR(__VA_ARGS__) " ARM Virtual Machine"; \
+        mc->desc = "Intel" MACHINE_VER_STR(__VA_ARGS__) " ARM Machine"; \
         MACHINE_VER_DEPRECATION(__VA_ARGS__); \
         if (latest) { \
             mc->alias = "virt"; \
@@ -1708,13 +1708,13 @@ static void virt_build_smbios(VirtMachineState *vms)
     uint8_t *smbios_tables, *smbios_anchor;
     size_t smbios_tables_len, smbios_anchor_len;
     struct smbios_phys_mem_area mem_array;
-    const char *product = "QEMU Virtual Machine";
+    const char *product = "Intel Machine";
 
     if (kvm_enabled()) {
-        product = "KVM Virtual Machine";
+        product = "Intel Machine";
     }
 
-    smbios_set_defaults("QEMU", product,
+    smbios_set_defaults("Unknown", product,
                         vmc->smbios_old_sys_ver ? "1.0" : mc->name);
 
     /* build the array of physical mem area from base_memmap */
diff --git a/hw/audio/hda-codec.c b/hw/audio/hda-codec.c
index 6f3a8f691b..4af156bf00 100644
--- a/hw/audio/hda-codec.c
+++ b/hw/audio/hda-codec.c
@@ -118,7 +118,7 @@ static void hda_codec_parse_fmt(uint32_t format, struct audsettings *as)
 
 /* some defines */
 
-#define QEMU_HDA_ID_VENDOR  0x1af4
+#define QEMU_HDA_ID_VENDOR  0x10EC
 #define QEMU_HDA_PCM_FORMATS (AC_SUPPCM_BITS_16 |       \
                               0x1fc /* 16 -> 96 kHz */)
 #define QEMU_HDA_AMP_NONE    (0)
diff --git a/hw/audio/intel-hda.c b/hw/audio/intel-hda.c
index 3214992ddc..25b07ae45f 100644
--- a/hw/audio/intel-hda.c
+++ b/hw/audio/intel-hda.c
@@ -1239,7 +1239,7 @@ static void intel_hda_class_init_ich6(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->device_id = 0x2668;
+    k->device_id = 0x51c8; // "Intel 82801IB ICH6 - High Definition Audio [A3]" | Intel Device ID Replacement from 0x2668 | hw/audio/intel-hda.c
     k->revision = 1;
     set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
     dc->desc = "Intel HD Audio Controller (ich6)";
@@ -1250,8 +1250,8 @@ static void intel_hda_class_init_ich9(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->device_id = 0x293e;
-    k->revision = 3;
+    k->device_id = 0x51c8; // "Intel 82801IB ICH9 - High Definition Audio [A3]" | Intel Device ID Replacement from 0x293e | hw/audio/intel-hda.c
+    k->revision = 1;
     set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
     dc->desc = "Intel HD Audio Controller (ich9)";
 }
diff --git a/hw/char/escc.c b/hw/char/escc.c
index a5fdd8f698..0a161a92dc 100644
--- a/hw/char/escc.c
+++ b/hw/char/escc.c
@@ -1037,7 +1037,7 @@ static void sunmouse_sync(DeviceState *dev)
 }
 
 static const QemuInputHandler sunmouse_handler = {
-    .name  = "QEMU Sun Mouse",
+    .name  = "Sun Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = sunmouse_handle_event,
     .sync  = sunmouse_sync,
diff --git a/hw/core/qdev.c b/hw/core/qdev.c
index 2745b5e092..3580cc0902 100644
--- a/hw/core/qdev.c
+++ b/hw/core/qdev.c
@@ -745,7 +745,7 @@ static void device_class_init(ObjectClass *class, void *data)
      * hotpluggable. Devices that shouldn't be hotpluggable,
      * should override it in their class_init()
      */
-    dc->hotpluggable = true;
+    dc->hotpluggable = false;
     dc->user_creatable = true;
     vc->get_id = device_vmstate_if_get_id;
     rc->get_state = device_get_reset_state;
diff --git a/hw/display/edid-generate.c b/hw/display/edid-generate.c
index 2cb819675e..630a33b703 100644
--- a/hw/display/edid-generate.c
+++ b/hw/display/edid-generate.c
@@ -388,22 +388,22 @@ void qemu_edid_generate(uint8_t *edid, size_t size,
     uint8_t *did = NULL;
     uint32_t width_mm, height_mm;
     uint32_t refresh_rate = info->refresh_rate ? info->refresh_rate : 75000;
-    uint32_t dpi = 100; /* if no width_mm/height_mm */
+    uint32_t dpi = 82; /* if no width_mm/height_mm */
     uint32_t large_screen = 0;
 
     /* =============== set defaults  =============== */
 
     if (!info->vendor || strlen(info->vendor) != 3) {
-        info->vendor = "RHT";
+        info->vendor = "MSI";
     }
     if (!info->name) {
-        info->name = "QEMU Monitor";
+        info->name = "G27C4X";
     }
     if (!info->prefx) {
-        info->prefx = 1280;
+        info->prefx = 1920;
     }
     if (!info->prefy) {
-        info->prefy = 800;
+        info->prefy = 1080;
     }
     if (info->width_mm && info->height_mm) {
         width_mm = info->width_mm;
@@ -449,15 +449,15 @@ void qemu_edid_generate(uint8_t *edid, size_t size,
     uint16_t vendor_id = ((((info->vendor[0] - '@') & 0x1f) << 10) |
                           (((info->vendor[1] - '@') & 0x1f) <<  5) |
                           (((info->vendor[2] - '@') & 0x1f) <<  0));
-    uint16_t model_nr = 0x1234;
+    uint16_t model_nr = 0x10ad;
     uint32_t serial_nr = info->serial ? atoi(info->serial) : 0;
     stw_be_p(edid +  8, vendor_id);
     stw_le_p(edid + 10, model_nr);
     stl_le_p(edid + 12, serial_nr);
 
     /* manufacture week and year */
-    edid[16] = 42;
-    edid[17] = 2014 - 1990;
+    edid[16] = 12;
+    edid[17] = 2025 - 2018;
 
     /* edid version */
     edid[18] = 1;
diff --git a/hw/display/qxl.c b/hw/display/qxl.c
index da14da5209..6f9698d777 100644
--- a/hw/display/qxl.c
+++ b/hw/display/qxl.c
@@ -2503,7 +2503,7 @@ static void qxl_pci_class_init(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->vendor_id = REDHAT_PCI_VENDOR_ID;
+    k->vendor_id = PCI_VENDOR_ID_REDHAT;
     k->device_id = QXL_DEVICE_ID_STABLE;
     set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);
     device_class_set_legacy_reset(dc, qxl_reset_handler);
diff --git a/hw/i386/acpi-build.c b/hw/i386/acpi-build.c
index 3fffa4a332..827a5fc0ce 100644
--- a/hw/i386/acpi-build.c
+++ b/hw/i386/acpi-build.c
@@ -1386,6 +1386,68 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,
     build_dbg_aml(dsdt);
     if (i440fx) {
         sb_scope = aml_scope("_SB");
+
+        /*
+         * Emulate Windows ACPI OSYS/_OSI logic in DSDT.
+         * Adds Windows 2001/2006/2009/2012/2013/2015.
+         */
+
+        aml_append(sb_scope, aml_name_decl("OSYS", aml_int(0x03E8)));
+
+        Aml *osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP2")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D2), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001.1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D3), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2006")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D6), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2009")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D9), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2012")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DC), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2013")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DD), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2015")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DF), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
         dev = aml_device("PCI0");
         aml_append(dev, aml_name_decl("_HID", aml_eisaid("PNP0A03")));
         aml_append(dev, aml_name_decl("_UID", aml_int(pcmc->pci_root_uid)));
@@ -1399,6 +1461,68 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,
         build_piix4_pci0_int(dsdt);
     } else if (q35) {
         sb_scope = aml_scope("_SB");
+
+        /*
+         * Emulate Windows ACPI OSYS/_OSI logic in DSDT.
+         * Adds Windows 2001/2006/2009/2012/2013/2015.
+         */
+
+        aml_append(sb_scope, aml_name_decl("OSYS", aml_int(0x03E8)));
+
+        Aml *osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP2")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D2), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001.1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D3), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2006")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D6), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2009")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D9), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2012")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DC), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2013")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DD), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2015")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DF), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
         dev = aml_device("PCI0");
         aml_append(dev, aml_name_decl("_HID", aml_eisaid("PNP0A08")));
         aml_append(dev, aml_name_decl("_CID", aml_eisaid("PNP0A03")));
@@ -1702,7 +1702,7 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,
     /* create fw_cfg node, unconditionally */
     {
         scope = aml_scope("\\_SB.PCI0");
-        fw_cfg_add_acpi_dsdt(scope, x86ms->fw_cfg);
+        //fw_cfg_add_acpi_dsdt(scope, x86ms->fw_cfg); Fix compile error
         aml_append(dsdt, scope);
     }
 
@@ -2146,6 +2166,8 @@ build_dmar_q35(GArray *table_data, BIOSLinker *linker, const char *oem_id,
  *
  * Helpful to speedup Windows guests and ignored by others.
  */
+// Disable WAET device (not found on bare metal systems)
+#if 0
 static void
 build_waet(GArray *table_data, BIOSLinker *linker, const char *oem_id,
            const char *oem_table_id)
@@ -2164,6 +2186,7 @@ build_waet(GArray *table_data, BIOSLinker *linker, const char *oem_id,
     build_append_int_noprefix(table_data, 1 << 1 /* ACPI PM timer good */, 4);
     acpi_table_end(linker, &table);
 }
+#endif
 
 /*
  *   IVRS table as specified in AMD IOMMU Specification v2.62, Section 5.2
@@ -2588,8 +2588,9 @@ void acpi_build(AcpiBuildTables *tables, MachineState *machine)
                        x86ms->oem_id, x86ms->oem_table_id, &pcms->cxl_devices_state);
     }
 
-    acpi_add_table(table_offsets, tables_blob);
-    build_waet(tables_blob, tables->linker, x86ms->oem_id, x86ms->oem_table_id);
+    // Disable WAET table (not found on bare metal systems)
+    // acpi_add_table(table_offsets, tables_blob);
+    // build_waet(tables_blob, tables->linker, x86ms->oem_id, x86ms->oem_table_id);
 
     /* Add tables supplied by user (if any) */
     for (u = acpi_table_first(); u; u = acpi_table_next(u)) {
diff --git a/hw/i386/acpi-microvm.c b/hw/i386/acpi-microvm.c
index 279da6b4aa..8150997210 100644
--- a/hw/i386/acpi-microvm.c
+++ b/hw/i386/acpi-microvm.c
@@ -118,7 +118,7 @@ build_dsdt_microvm(GArray *table_data, BIOSLinker *linker,
     dsdt = init_aml_allocator();
 
     sb_scope = aml_scope("_SB");
-    fw_cfg_add_acpi_dsdt(sb_scope, x86ms->fw_cfg);
+    //fw_cfg_add_acpi_dsdt(sb_scope, x86ms->fw_cfg); Fix compile error
     qbus_build_aml(BUS(isabus), sb_scope);
     build_ged_aml(sb_scope, GED_DEVICE, x86ms->acpi_dev,
                   GED_MMIO_IRQ, AML_SYSTEM_MEMORY, GED_MMIO_BASE);
diff --git a/hw/i386/fw_cfg.c b/hw/i386/fw_cfg.c
index 5c0bcd5f8a..ac471871b5 100644
--- a/hw/i386/fw_cfg.c
+++ b/hw/i386/fw_cfg.c
@@ -75,7 +75,7 @@ void fw_cfg_build_smbios(PCMachineState *pcms, FWCfgState *fw_cfg,
 
     if (pcmc->smbios_defaults) {
         /* These values are guest ABI, do not change */
-        smbios_set_defaults("QEMU", mc->desc, mc->name);
+        smbios_set_defaults("Unknown", mc->desc, mc->name);
     }
 
     /* tell smbios about cpuid version and features */
@@ -212,6 +212,8 @@ void fw_cfg_build_feature_control(MachineState *ms, FWCfgState *fw_cfg)
     fw_cfg_add_file(fw_cfg, "etc/msr_feature_control", val, sizeof(*val));
 }
 
+// Disable FWCF device (not found on bare metal systems)
+#if 0
 #ifdef CONFIG_ACPI
 void fw_cfg_add_acpi_dsdt(Aml *scope, FWCfgState *fw_cfg)
 {
@@ -240,3 +242,4 @@ void fw_cfg_add_acpi_dsdt(Aml *scope, FWCfgState *fw_cfg)
     aml_append(scope, dev);
 }
 #endif
+#endif
diff --git a/hw/i386/multiboot.c b/hw/i386/multiboot.c
index cd07a05861..9ca77b873a 100644
--- a/hw/i386/multiboot.c
+++ b/hw/i386/multiboot.c
@@ -102,7 +102,7 @@ typedef struct {
     int mb_mods_count;
 } MultibootState;
 
-const char *bootloader_name = "qemu";
+const char *bootloader_name = "Windows Boot Manager";
 
 static uint32_t mb_add_cmdline(MultibootState *s, const char *cmdline)
 {
diff --git a/hw/i386/pc.c b/hw/i386/pc.c
index 01d0581f62..ab00078708 100644
--- a/hw/i386/pc.c
+++ b/hw/i386/pc.c
@@ -75,9 +75,9 @@
  * depending on QEMU versions up to QEMU 2.4.
  */
 #define PC_CPU_MODEL_IDS(v) \
-    { "qemu32-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },\
-    { "qemu64-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },\
-    { "athlon-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },
+    { "qemu32-" TYPE_X86_CPU, "model-id", "CPU version " v, },\
+    { "qemu64-" TYPE_X86_CPU, "model-id", "CPU version " v, },\
+    { "athlon-" TYPE_X86_CPU, "model-id", "CPU version " v, },
 
 GlobalProperty pc_compat_9_2[] = {};
 const size_t pc_compat_9_2_len = G_N_ELEMENTS(pc_compat_9_2);
@@ -1771,7 +1771,7 @@ static void pc_machine_class_init(ObjectClass *oc, void *data)
 
     pcmc->pci_enabled = true;
     pcmc->has_acpi_build = true;
-    pcmc->smbios_defaults = true;
+    pcmc->smbios_defaults = false;
     pcmc->gigabyte_align = true;
     pcmc->has_reserved_memory = true;
     pcmc->enforce_amd_1tb_hole = true;
diff --git a/hw/i386/pc_piix.c b/hw/i386/pc_piix.c
index 6c91e2d292..8584493165 100644
--- a/hw/i386/pc_piix.c
+++ b/hw/i386/pc_piix.c
@@ -460,12 +460,12 @@ static void pc_i440fx_machine_options(MachineClass *m)
     pcmc->pci_root_uid = 0;
     pcmc->default_cpu_version = 1;
 
-    m->family = "pc_piix";
-    m->desc = "Standard PC (i440FX + PIIX, 1996)";
+    m->family = "pc_x570";
+    m->desc = "12th Gen Intel(R) Core(TM) i7-12700H";
     m->default_machine_opts = "firmware=bios-256k.bin";
-    m->default_display = "std";
-    m->default_nic = "e1000";
-    m->no_floppy = !module_object_class_by_name(TYPE_ISA_FDC);
+    m->default_display = "none";
+    m->default_nic = "rtl8139"; // Realtek PCI Express Gigabit Ethernet Controller
+    m->no_floppy = 1;
     m->no_parallel = !module_object_class_by_name(TYPE_ISA_PARALLEL);
     machine_class_allow_dynamic_sysbus_dev(m, TYPE_RAMFB_DEVICE);
     machine_class_allow_dynamic_sysbus_dev(m, TYPE_VMBUS_BRIDGE);
@@ -509,7 +509,7 @@ static void pc_i440fx_machine_9_0_options(MachineClass *m)
     PCMachineClass *pcmc = PC_MACHINE_CLASS(m);
 
     pc_i440fx_machine_9_1_options(m);
-    m->smbios_memory_device_size = 16 * GiB;
+    m->smbios_memory_device_size = 8 * GiB; // Default is 16GB per stick; Change to more common 8 GB per stick instead.
 
     compat_props_add(m->compat_props, hw_compat_9_0, hw_compat_9_0_len);
     compat_props_add(m->compat_props, pc_compat_9_0, pc_compat_9_0_len);
diff --git a/hw/i386/pc_q35.c b/hw/i386/pc_q35.c
index fd96d0345c..f4d6205398 100644
--- a/hw/i386/pc_q35.c
+++ b/hw/i386/pc_q35.c
@@ -342,12 +342,12 @@ static void pc_q35_machine_options(MachineClass *m)
     pcmc->pci_root_uid = 0;
     pcmc->default_cpu_version = 1;
 
-    m->family = "pc_q35";
-    m->desc = "Standard PC (Q35 + ICH9, 2009)";
+    m->family = "pc_x570";
+    m->desc = "12th Gen Intel(R) Core(TM) i7-12700H";
     m->units_per_default_bus = 1;
     m->default_machine_opts = "firmware=bios-256k.bin";
-    m->default_display = "std";
-    m->default_nic = "e1000e";
+    m->default_display = "none";
+    m->default_nic = "rtl8139"; // Realtek PCI Express Gigabit Ethernet Controller
     m->default_kernel_irqchip_split = false;
     m->no_floppy = 1;
     m->max_cpus = 4096;
@@ -390,7 +390,7 @@ static void pc_q35_machine_9_0_options(MachineClass *m)
 {
     PCMachineClass *pcmc = PC_MACHINE_CLASS(m);
     pc_q35_machine_9_1_options(m);
-    m->smbios_memory_device_size = 16 * GiB;
+    m->smbios_memory_device_size = 8 * GiB; // Default is 16GB per stick; Change to more common 8 GB per stick instead.
     compat_props_add(m->compat_props, hw_compat_9_0, hw_compat_9_0_len);
     compat_props_add(m->compat_props, pc_compat_9_0, pc_compat_9_0_len);
     pcmc->isa_bios_alias = false;
diff --git a/hw/ide/atapi.c b/hw/ide/atapi.c
index a42b748521..c10cf51347 100644
--- a/hw/ide/atapi.c
+++ b/hw/ide/atapi.c
@@ -798,8 +798,8 @@ static void cmd_inquiry(IDEState *s, uint8_t *buf)
         buf[5] = 0;    /* reserved */
         buf[6] = 0;    /* reserved */
         buf[7] = 0;    /* reserved */
-        padstr8(buf + 8, 8, "QEMU");
-        padstr8(buf + 16, 16, "QEMU DVD-ROM");
+        padstr8(buf + 8, 8, "Samsung");
+        padstr8(buf + 16, 16, "DVD-ROM");
         padstr8(buf + 32, 4, s->version);
         idx = 36;
     }
diff --git a/hw/ide/core.c b/hw/ide/core.c
index b14983ec54..3d824d3e21 100644
--- a/hw/ide/core.c
+++ b/hw/ide/core.c
@@ -2638,21 +2638,20 @@ int ide_init_drive(IDEState *s, IDEDevice *dev, IDEDriveKind kind, Error **errp)
     if (dev->serial) {
         pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), dev->serial);
     } else {
-        snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),
-                 "QM%05d", s->drive_serial);
+        s->drive_serial_str[0] = '\0';  // Empty string fallback instead of QEMU default
     }
     if (dev->model) {
         pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), dev->model);
     } else {
         switch (kind) {
         case IDE_CD:
-            strcpy(s->drive_model_str, "QEMU DVD-ROM");
+            strcpy(s->drive_model_str, "HL-DT-ST BD-RE WH16NS60");
             break;
         case IDE_CFATA:
-            strcpy(s->drive_model_str, "QEMU MICRODRIVE");
+            strcpy(s->drive_model_str, "Hitachi HMS360404D5CF00");
             break;
         default:
-            strcpy(s->drive_model_str, "QEMU HARDDISK");
+            strcpy(s->drive_model_str, "Samsung SSD 980 500GB");
             break;
         }
     }
diff --git a/hw/input/adb-kbd.c b/hw/input/adb-kbd.c
index 3649d03ef2..6eec61f547 100644
--- a/hw/input/adb-kbd.c
+++ b/hw/input/adb-kbd.c
@@ -356,7 +356,7 @@ static void adb_kbd_reset(DeviceState *dev)
 }
 
 static const QemuInputHandler adb_keyboard_handler = {
-    .name  = "QEMU ADB Keyboard",
+    .name  = "ADB Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = adb_keyboard_event,
 };
diff --git a/hw/input/adb-mouse.c b/hw/input/adb-mouse.c
index 77b280d242..7dc777f6e1 100644
--- a/hw/input/adb-mouse.c
+++ b/hw/input/adb-mouse.c
@@ -94,7 +94,7 @@ static void adb_mouse_handle_event(DeviceState *dev, QemuConsole *src,
 }
 
 static const QemuInputHandler adb_mouse_handler = {
-    .name  = "QEMU ADB Mouse",
+    .name  = "ADB Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = adb_mouse_handle_event,
     /*
diff --git a/hw/input/hid.c b/hw/input/hid.c
index 76bedc1844..7fc2f72819 100644
--- a/hw/input/hid.c
+++ b/hw/input/hid.c
@@ -511,20 +511,20 @@ void hid_free(HIDState *hs)
 }
 
 static const QemuInputHandler hid_keyboard_handler = {
-    .name  = "QEMU HID Keyboard",
+    .name  = "HID Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = hid_keyboard_event,
 };
 
 static const QemuInputHandler hid_mouse_handler = {
-    .name  = "QEMU HID Mouse",
+    .name  = "HID Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = hid_pointer_event,
     .sync  = hid_pointer_sync,
 };
 
 static const QemuInputHandler hid_tablet_handler = {
-    .name  = "QEMU HID Tablet",
+    .name  = "HID Tablet",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_ABS,
     .event = hid_pointer_event,
     .sync  = hid_pointer_sync,
diff --git a/hw/input/ps2.c b/hw/input/ps2.c
index 6a41b024c8..7f60d25494 100644
--- a/hw/input/ps2.c
+++ b/hw/input/ps2.c
@@ -1232,7 +1232,7 @@ static const VMStateDescription vmstate_ps2_mouse = {
 };
 
 static const QemuInputHandler ps2_keyboard_handler = {
-    .name  = "QEMU PS/2 Keyboard",
+    .name  = "PS/2 Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = ps2_keyboard_event,
 };
@@ -1243,7 +1243,7 @@ static void ps2_kbd_realize(DeviceState *dev, Error **errp)
 }
 
 static const QemuInputHandler ps2_mouse_handler = {
-    .name  = "QEMU PS/2 Mouse",
+    .name  = "PS/2 Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = ps2_mouse_event,
     .sync  = ps2_mouse_sync,
diff --git a/hw/input/virtio-input-hid.c b/hw/input/virtio-input-hid.c
index 812faaef8f..0f71bfd677 100644
--- a/hw/input/virtio-input-hid.c
+++ b/hw/input/virtio-input-hid.c
@@ -16,10 +16,10 @@
 
 #include "standard-headers/linux/input.h"
 
-#define VIRTIO_ID_NAME_KEYBOARD     "QEMU Virtio Keyboard"
-#define VIRTIO_ID_NAME_MOUSE        "QEMU Virtio Mouse"
-#define VIRTIO_ID_NAME_TABLET       "QEMU Virtio Tablet"
-#define VIRTIO_ID_NAME_MULTITOUCH   "QEMU Virtio MultiTouch"
+#define VIRTIO_ID_NAME_KEYBOARD     "Keyboard"
+#define VIRTIO_ID_NAME_MOUSE        "Mouse"
+#define VIRTIO_ID_NAME_TABLET       "Tablet"
+#define VIRTIO_ID_NAME_MULTITOUCH   "MultiTouch"
 
 /* ----------------------------------------------------------------- */
 
@@ -281,7 +281,7 @@ static struct virtio_input_config virtio_keyboard_config[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x046d), /* same we use for usb hid devices */
             .product = const_le16(0x0001),
             .version = const_le16(0x0001),
         },
@@ -338,7 +338,7 @@ static struct virtio_input_config virtio_mouse_config_v1[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x046d), /* same we use for usb hid devices */
             .product = const_le16(0x0002),
             .version = const_le16(0x0001),
         },
@@ -363,7 +363,7 @@ static struct virtio_input_config virtio_mouse_config_v2[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x046d), /* same we use for usb hid devices */
             .product = const_le16(0x0002),
             .version = const_le16(0x0002),
         },
@@ -431,7 +431,7 @@ static struct virtio_input_config virtio_tablet_config_v1[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x056a), /* same we use for usb hid devices */
             .product = const_le16(0x0003),
             .version = const_le16(0x0001),
         },
@@ -468,7 +468,7 @@ static struct virtio_input_config virtio_tablet_config_v2[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x056a), /* same we use for usb hid devices */
             .product = const_le16(0x0003),
             .version = const_le16(0x0002),
         },
@@ -555,7 +555,7 @@ static struct virtio_input_config virtio_multitouch_config[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x056a), /* same we use for usb hid devices */
             .product = const_le16(0x0003),
             .version = const_le16(0x0001),
         },
diff --git a/hw/loongarch/virt.c b/hw/loongarch/virt.c
index 65c9027feb..ec51bb8dca 100644
--- a/hw/loongarch/virt.c
+++ b/hw/loongarch/virt.c
@@ -129,13 +129,13 @@ static void virt_build_smbios(LoongArchVirtMachineState *lvms)
     MachineClass *mc = MACHINE_GET_CLASS(lvms);
     uint8_t *smbios_tables, *smbios_anchor;
     size_t smbios_tables_len, smbios_anchor_len;
-    const char *product = "QEMU Virtual Machine";
+    const char *product = "Intel Machine";
 
     if (!lvms->fw_cfg) {
         return;
     }
 
-    smbios_set_defaults("QEMU", product, mc->name);
+    smbios_set_defaults("Unknown", product, mc->name);
 
     smbios_get_tables(ms, SMBIOS_ENTRY_POINT_TYPE_64,
                       NULL, 0,
diff --git a/hw/m68k/virt.c b/hw/m68k/virt.c
index d967bdd743..6646b0e146 100644
--- a/hw/m68k/virt.c
+++ b/hw/m68k/virt.c
@@ -312,7 +312,7 @@ static void virt_init(MachineState *machine)
 static void virt_machine_class_init(ObjectClass *oc, void *data)
 {
     MachineClass *mc = MACHINE_CLASS(oc);
-    mc->desc = "QEMU M68K Virtual Machine";
+    mc->desc = "Intel M68K Machine";
     mc->init = virt_init;
     mc->default_cpu_type = M68K_CPU_TYPE_NAME("m68040");
     mc->max_cpus = 1;
@@ -342,7 +342,7 @@ type_init(virt_machine_register_types)
     { \
         MachineClass *mc = MACHINE_CLASS(oc); \
         MACHINE_VER_SYM(options, virt, __VA_ARGS__)(mc); \
-        mc->desc = "QEMU " MACHINE_VER_STR(__VA_ARGS__) " M68K Virtual Machine"; \
+        mc->desc = "Intel" MACHINE_VER_STR(__VA_ARGS__) " M68K Machine"; \
         MACHINE_VER_DEPRECATION(__VA_ARGS__); \
         if (latest) { \
             mc->alias = "virt"; \
diff --git a/hw/misc/applesmc.c b/hw/misc/applesmc.c
index 97ea842d60..e38ab7ac5d 100644
--- a/hw/misc/applesmc.c
+++ b/hw/misc/applesmc.c
@@ -85,8 +85,7 @@ enum {
 #define smc_debug(...) do { } while (0)
 #endif
 
-static char default_osk[64] = "This is a dummy key. Enter the real key "
-                              "using the -osk parameter";
+static char default_osk[64] = "ourhardworkbythesewordsguardedpleasedontsteal(c)AppleComputerInc";
 
 struct AppleSMCData {
     uint8_t len;
diff --git a/hw/misc/pvpanic-isa.c b/hw/misc/pvpanic-isa.c
index c3713dc5c4..26aeab2b2a 100644
--- a/hw/misc/pvpanic-isa.c
+++ b/hw/misc/pvpanic-isa.c
@@ -69,7 +69,7 @@ static void build_pvpanic_isa_aml(AcpiDevAmlIf *adev, Aml *scope)
     PVPanicISAState *s = PVPANIC_ISA_DEVICE(adev);
     Aml *dev = aml_device("PEVT");
 
-    aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0001")));
+    aml_append(dev, aml_name_decl("_HID", aml_string("UEFI0001")));
 
     crs = aml_resource_template();
     aml_append(crs,
diff --git a/hw/nvme/ctrl.c b/hw/nvme/ctrl.c
index d6b77d4fbc..8d43136df4 100644
--- a/hw/nvme/ctrl.c
+++ b/hw/nvme/ctrl.c
@@ -8786,7 +8786,7 @@ static void nvme_init_ctrl(NvmeCtrl *n, PCIDevice *pci_dev)
 
     id->vid = cpu_to_le16(pci_get_word(pci_conf + PCI_VENDOR_ID));
     id->ssvid = cpu_to_le16(pci_get_word(pci_conf + PCI_SUBSYSTEM_VENDOR_ID));
-    strpadcpy((char *)id->mn, sizeof(id->mn), "QEMU NVMe Ctrl", ' ');
+    strpadcpy((char *)id->mn, sizeof(id->mn), "NVMe Ctrl", ' ');
     strpadcpy((char *)id->fr, sizeof(id->fr), QEMU_VERSION, ' ');
     strpadcpy((char *)id->sn, sizeof(id->sn), n->params.serial, ' ');
 
diff --git a/hw/nvram/fw_cfg-acpi.c b/hw/nvram/fw_cfg-acpi.c
index 2e6ef89b98..bb5a6f46b0 100644
--- a/hw/nvram/fw_cfg-acpi.c
+++ b/hw/nvram/fw_cfg-acpi.c
@@ -11,7 +11,7 @@
 void fw_cfg_acpi_dsdt_add(Aml *scope, const MemMapEntry *fw_cfg_memmap)
 {
     Aml *dev = aml_device("FWCF");
-    aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0002")));
+    aml_append(dev, aml_name_decl("_HID", aml_string("UEFI0002")));
     /* device present, functioning, decoding, not shown in UI */
     aml_append(dev, aml_name_decl("_STA", aml_int(0xB)));
     aml_append(dev, aml_name_decl("_CCA", aml_int(1)));
diff --git a/hw/nvram/fw_cfg.c b/hw/nvram/fw_cfg.c
index a757939cfb..234068884a 100644
--- a/hw/nvram/fw_cfg.c
+++ b/hw/nvram/fw_cfg.c
@@ -56,7 +56,7 @@
 #define FW_CFG_DMA_CTL_SELECT  0x08
 #define FW_CFG_DMA_CTL_WRITE   0x10
 
-#define FW_CFG_DMA_SIGNATURE 0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE 0x51434f4d20434647ULL /* "QCOM CFG" */
 
 struct FWCfgEntry {
     uint32_t len;
@@ -1096,7 +1096,7 @@ static void fw_cfg_common_realize(DeviceState *dev, Error **errp)
         return;
     }
 
-    fw_cfg_add_bytes(s, FW_CFG_SIGNATURE, (char *)"QEMU", 4);
+    fw_cfg_add_bytes(s, FW_CFG_SIGNATURE, (char *)"QEMU", 4); // "QEMU"
     fw_cfg_add_bytes(s, FW_CFG_UUID, &qemu_uuid, 16);
     fw_cfg_add_i16(s, FW_CFG_NOGRAPHIC, (uint16_t)!machine->enable_graphics);
     fw_cfg_add_i16(s, FW_CFG_BOOT_MENU, (uint16_t)(machine->boot_config.has_menu && machine->boot_config.menu));
diff --git a/hw/pci-host/gpex.c b/hw/pci-host/gpex.c
index 9fcedd7fc5..4634d13e27 100644
--- a/hw/pci-host/gpex.c
+++ b/hw/pci-host/gpex.c
@@ -243,7 +243,7 @@ static void gpex_root_class_init(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
 
     set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
-    dc->desc = "QEMU generic PCIe host bridge";
+    dc->desc = "Generic PCIe host bridge";
     dc->vmsd = &vmstate_gpex_root;
     k->vendor_id = PCI_VENDOR_ID_REDHAT;
     k->device_id = PCI_DEVICE_ID_REDHAT_PCIE_HOST;
diff --git a/hw/ppc/e500plat.c b/hw/ppc/e500plat.c
index 70a8033373..57192459f5 100644
--- a/hw/ppc/e500plat.c
+++ b/hw/ppc/e500plat.c
@@ -22,7 +22,7 @@
 
 static void e500plat_fixup_devtree(void *fdt)
 {
-    const char model[] = "QEMU ppce500";
+    const char model[] = "ppce500";
     const char compatible[] = "fsl,qemu-e500";
 
     qemu_fdt_setprop(fdt, "/", "model", model, sizeof(model));
diff --git a/hw/ppc/pnv.c b/hw/ppc/pnv.c
index 63f2232f32..6ef698562f 100644
--- a/hw/ppc/pnv.c
+++ b/hw/ppc/pnv.c
@@ -652,7 +652,7 @@ static void *pnv_dt_create(MachineState *machine)
     _FDT((fdt_create_empty_tree(fdt, FDT_MAX_SIZE)));
 
     /* /qemu node */
-    _FDT((fdt_add_subnode(fdt, 0, "qemu")));
+    _FDT((fdt_add_subnode(fdt, 0, "qemu"))); // "qemu"
 
     /* Root node */
     _FDT((fdt_setprop_cell(fdt, 0, "#address-cells", 0x2)));
diff --git a/hw/scsi/mptconfig.c b/hw/scsi/mptconfig.c
index 19d01f39fa..00ee3f80e5 100644
--- a/hw/scsi/mptconfig.c
+++ b/hw/scsi/mptconfig.c
@@ -189,12 +189,12 @@ static
 size_t mptsas_config_manufacturing_0(MPTSASState *s, uint8_t **data, int address)
 {
     return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,
-                              "s16s8s16s16s16",
-                              "QEMU MPT Fusion",
+                              "s10s4s85s45s34",
+                              "MPT Fusion",
                               "2.5",
-                              "QEMU MPT Fusion",
-                              "QEMU",
-                              "0000111122223333");
+                              "MPT Fusion",
+                              "MSI",
+                              "7624862998526197");
 }
 
 static
diff --git a/hw/scsi/scsi-bus.c b/hw/scsi/scsi-bus.c
index ece1107ee8..466ee7b439 100644
--- a/hw/scsi/scsi-bus.c
+++ b/hw/scsi/scsi-bus.c
@@ -698,8 +698,8 @@ static bool scsi_target_emulate_inquiry(SCSITargetReq *r)
         r->buf[3] = 2 | 0x10; /* HiSup, response data format */
         r->buf[4] = r->len - 5; /* Additional Length = (Len - 1) - 4 */
         r->buf[7] = 0x10 | (r->req.bus->info->tcq ? 0x02 : 0); /* Sync, TCQ.  */
-        memcpy(&r->buf[8], "QEMU    ", 8);
-        memcpy(&r->buf[16], "QEMU TARGET     ", 16);
+        memcpy(&r->buf[8], "MSI     ", 8);
+        memcpy(&r->buf[16], "MSI TARGET      ", 16);
         pstrcpy((char *) &r->buf[32], 4, qemu_hw_version());
     }
     return true;
diff --git a/hw/scsi/scsi-disk.c b/hw/scsi/scsi-disk.c
index e59632e9b1..79937fb6a5 100644
--- a/hw/scsi/scsi-disk.c
+++ b/hw/scsi/scsi-disk.c
@@ -2568,7 +2568,7 @@ static void scsi_realize(SCSIDevice *dev, Error **errp)
         s->version = g_strdup(qemu_hw_version());
     }
     if (!s->vendor) {
-        s->vendor = g_strdup("QEMU");
+        s->vendor = g_strdup("Samsung");
     }
     if (s->serial && strlen(s->serial) > MAX_SERIAL_LEN) {
         error_setg(errp, "The serial number can't be longer than %d characters",
@@ -2632,7 +2632,7 @@ static void scsi_hd_realize(SCSIDevice *dev, Error **errp)
     s->qdev.blocksize = s->qdev.conf.logical_block_size;
     s->qdev.type = TYPE_DISK;
     if (!s->product) {
-        s->product = g_strdup("QEMU HARDDISK");
+        s->product = g_strdup("Samsung SSD 980 500GB");
     }
     scsi_realize(&s->qdev, errp);
 }
@@ -2659,7 +2659,7 @@ static void scsi_cd_realize(SCSIDevice *dev, Error **errp)
     s->qdev.type = TYPE_ROM;
     s->features |= 1 << SCSI_DISK_F_REMOVABLE;
     if (!s->product) {
-        s->product = g_strdup("QEMU CD-ROM");
+        s->product = g_strdup("CD-ROM");
     }
     scsi_realize(&s->qdev, errp);
 }
diff --git a/hw/scsi/spapr_vscsi.c b/hw/scsi/spapr_vscsi.c
index 6962194eaa..fc69916d84 100644
--- a/hw/scsi/spapr_vscsi.c
+++ b/hw/scsi/spapr_vscsi.c
@@ -713,8 +713,8 @@ static void vscsi_inquiry_no_target(VSCSIState *s, vscsi_req *req)
     resp_data[3] = 0x02;   /* Resp data format */
     resp_data[4] = 36 - 5; /* Additional length */
     resp_data[7] = 0x10;   /* Sync transfers */
-    memcpy(&resp_data[16], "QEMU EMPTY      ", 16);
-    memcpy(&resp_data[8], "QEMU    ", 8);
+    memcpy(&resp_data[16], "MSI EMPTY       ", 16);
+    memcpy(&resp_data[8], "MSI     ", 8);
 
     req->writing = 0;
     vscsi_preprocess_desc(req);
@@ -971,7 +971,7 @@ static int vscsi_send_adapter_info(VSCSIState *s, vscsi_req *req)
 #endif
     memset(&info, 0, sizeof(info));
     strcpy(info.srp_version, SRP_VERSION);
-    memcpy(info.partition_name, "qemu", sizeof("qemu"));
+    memcpy(info.partition_name, "msi", sizeof("msi"));
     info.partition_number = cpu_to_be32(0);
     info.mad_version = cpu_to_be32(1);
     info.os_type = cpu_to_be32(2);
diff --git a/hw/smbios/smbios.c b/hw/smbios/smbios.c
index ad4cd6721e..c3ddaede4a 100644
--- a/hw/smbios/smbios.c
+++ b/hw/smbios/smbios.c
@@ -68,7 +68,8 @@ static struct {
  * 0 which counts as unknown (SMBIOS 3.1.0/Table 21). Set the
  * default value to 2000MHz as we did before.
  */
-#define DEFAULT_CPU_SPEED 2000
+#define DEFAULT_CPU_SPEED 3600
+#define DEFAULT_BOOST_CPU_SPEED 4400
 
 static struct {
     uint16_t processor_family;
@@ -77,7 +78,7 @@ static struct {
     uint64_t current_speed;
     uint64_t processor_id;
 } type4 = {
-    .max_speed = DEFAULT_CPU_SPEED,
+    .max_speed = DEFAULT_BOOST_CPU_SPEED,
     .current_speed = DEFAULT_CPU_SPEED,
     .processor_id = 0,
     .processor_family = 0x01, /* Other */
@@ -565,18 +566,91 @@ static void smbios_build_type_0_table(void)
     SMBIOS_TABLE_SET_STR(0, vendor_str, smbios_type0.vendor);
     SMBIOS_TABLE_SET_STR(0, bios_version_str, smbios_type0.version);
 
-    t->bios_starting_address_segment = cpu_to_le16(0xE800); /* from SeaBIOS */
+    t->bios_starting_address_segment = cpu_to_le16(0xE000); /* from SeaBIOS */
 
     SMBIOS_TABLE_SET_STR(0, bios_release_date_str, smbios_type0.date);
 
-    t->bios_rom_size = 0; /* hardcoded in SeaBIOS with FIXME comment */
-
-    t->bios_characteristics = cpu_to_le64(0x08); /* Not supported */
-    t->bios_characteristics_extension_bytes[0] = 0;
-    t->bios_characteristics_extension_bytes[1] = 0x14; /* TCD/SVVP | VM */
+    t->bios_rom_size = 0xFF; /* hardcoded in SeaBIOS with FIXME comment */
+
+    t->bios_characteristics = cpu_to_le64(0x001A00004BF99880); /*
+
+    Table 7 â€“ Firmware Characteristics: https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A238%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C150%2C0%5D
+
+    Hex    = 0x001A00004BF99880
+    Binary = 0b0000000000011010000000000000000001001011111110011001100010000000
+
+    Bit0  = Reserved - 0 (No)
+    Bit1  = Reserved - 0 (No)
+    Bit2  = Unknown - 0 (No)
+    Bit3  = BIOS Characteristics Not Supported - 0 (No)
+    Bit4  = ISA is supported - 0 (No)
+    Bit5  = MCA is supported - 0 (No)
+    Bit6  = EISA is supported - 0 (No)
+    Bit7  = PCI is supported - 1 (Yes)
+    Bit8  = PC Card (PCMCIA) is supported - 0 (No)
+    Bit9  = Plug and Play is supported - 0 (No)
+    Bit10 = APM is supported - 0 (No)
+    Bit11 = BIOS is Upgradeable (Flash) - 1 (Yes)
+    Bit12 = BIOS shadowing is allowed - 1 (Yes)
+    Bit13 = VL-VESA is supported - 0 (No)
+    Bit14 = ESCD support is available - 0 (No)
+    Bit15 = Boot from CD is supported - 1 (Yes)
+    Bit16 = Selectable Boot is supported - 1 (Yes)
+    Bit17 = BIOS ROM is socketed - 0 (No)
+    Bit18 = Boot From PC Card (PCMCIA) is supported - 0 (No)
+    Bit19 = EDD (Enhanced Disk Drive) Specification is supported - 1 (Yes)
+    Bit20 = Int 13h - Japanese Floppy for NEC 9800 1.2mb (3.5", 1k Bytes/Sector, 360 RPM) is supported - 1 (Yes)
+    Bit21 = Int 13h - Japanese Floppy for Toshiba 1.2mb (3.5", 360 RPM) is supported - 1 (Yes)
+    Bit22 = Int 13h - 5.25" / 360 KB Floppy Services are supported - 1 (Yes)
+    Bit23 = Int 13h - 5.25" / 1.2MB Floppy Services are supported - 1 (Yes)
+    Bit24 = Int 13h - 3.5" / 720 KB Floppy Services are supported - 1 (Yes)
+    Bit25 = Int 13h - 3.5" / 2.88 MB Floppy Services are supported - 1 (Yes)
+    Bit26 = Int 5h, Print Screen Service is supported - 0 (No)
+    Bit27 = Int 9h, 8042 Keyboard services are supported - 1 (Yes)
+    Bit28 = Int 14h, Serial Services are supported - 0 (No)
+    Bit29 = Int 17h, Printer Services are supported - 0 (No)
+    Bit30 = Int 10h, CGA/Mono Video Services are supported - 1 (Yes)
+    Bit31 = NEC PC-98 - 0 (No)
+
+    */
+
+    t->bios_characteristics_extension_bytes[0] = 0x03; /*
+
+    Table 8 â€“ Firmware Characteristics Extension Byte 1
+    https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A244%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C720%2C0%5D
+
+    Hex    = 0x03
+    Binary = 0b00000011
+
+    Bit0 = ACPI supported - 1 (Yes)
+    Bit1 = USB Legacy is supported - 1 (Yes)
+    Bit2 = AGP is supported - 0 (No)
+    Bit3 = I2O boot is supported - 0 (No)
+    Bit4 = LS-120 boot is supported - 0 (No)
+    Bit5 = ATAPI ZIP Drive boot is supported - 0 (No)
+    Bit6 = 1394 boot is supported - 0 (No)
+    Bit7 = Smart Battery supported - 0 (No)
+
+    */
+
+    t->bios_characteristics_extension_bytes[1] = 0x0D; /*  */
     if (smbios_type0.uefi) {
-        t->bios_characteristics_extension_bytes[1] |= 0x08; /* |= UEFI */
-    }
+        t->bios_characteristics_extension_bytes[1] |= 0x0D; /* |= UEFI */
+    } /*
+
+    Table 9 â€“ Firmware Characteristics Extension Byte 2
+    https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A244%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C483%2C0%5D
+
+    Hex    = 0x0D
+    Binary = 0b00001101
+
+    Bit0 = BIOS Boot Specification supported - 1 (Yes)
+    Bit1 = Function key-initiated Network Service boot supported - 0 (No)
+    Bit2 = Enable Targeted Content Distribution - 1 (Yes)
+    Bit3 = UEFI Specification is supported - 1 (Yes)
+    Bit4 = SMBIOS table describes a virtual machine - 0 (No)
+
+    */
 
     if (smbios_type0.have_major_minor) {
         t->system_bios_major_release = smbios_type0.major;
@@ -633,9 +707,9 @@ static void smbios_build_type_2_table(void)
     SMBIOS_TABLE_SET_STR(2, version_str, type2.version);
     SMBIOS_TABLE_SET_STR(2, serial_number_str, type2.serial);
     SMBIOS_TABLE_SET_STR(2, asset_tag_number_str, type2.asset);
-    t->feature_flags = 0x01; /* Motherboard */
+    t->feature_flags = 0x09; /* Motherboard */
     SMBIOS_TABLE_SET_STR(2, location_str, type2.location);
-    t->chassis_handle = cpu_to_le16(0x300); /* Type 3 (System enclosure) */
+    t->chassis_handle = cpu_to_le16(0x0003); /* Type 3 (System enclosure) */
     t->board_type = 0x0A; /* Motherboard */
     t->contained_element_count = 0;
 
@@ -665,7 +739,7 @@ static void smbios_build_type_3_table(void)
     SMBIOS_BUILD_TABLE_POST;
 }
 
-static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
+static void smbios_build_type_4_table(MachineState *ms, unsigned instance, unsigned socket_count,
                                       SmbiosEntryPointType ep_type,
                                       Error **errp)
 {
@@ -681,10 +755,13 @@ static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
     SMBIOS_BUILD_TABLE_PRE_SIZE(4, T4_BASE + instance,
                                 true, tbl_len); /* required */
 
-    snprintf(sock_str, sizeof(sock_str), "%s%2x", type4.sock_pfx, instance);
+    if (socket_count > 1)
+        snprintf(sock_str, sizeof(sock_str), "%s%2x", type4.sock_pfx, instance);
+    else
+        snprintf(sock_str, sizeof(sock_str), "%s", type4.sock_pfx);
     SMBIOS_TABLE_SET_STR(4, socket_designation_str, sock_str);
-    t->processor_type = 0x03; /* CPU */
-    t->processor_family = 0xfe; /* use Processor Family 2 field */
+    t->processor_type = 0x03; /* Central Processor */
+    t->processor_family = 0xC6; /* Intel Core i7 processor */
     SMBIOS_TABLE_SET_STR(4, processor_manufacturer_str, type4.manufacturer);
     if (type4.processor_id == 0) {
         t->processor_id[0] = cpu_to_le32(smbios_cpuid_version);
@@ -695,14 +772,14 @@ static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
     }
     SMBIOS_TABLE_SET_STR(4, processor_version_str, type4.version);
     t->voltage = 0;
-    t->external_clock = cpu_to_le16(0); /* Unknown */
+    t->external_clock = cpu_to_le16(0x0064); /* Unknown */
     t->max_speed = cpu_to_le16(type4.max_speed);
     t->current_speed = cpu_to_le16(type4.current_speed);
     t->status = 0x41; /* Socket populated, CPU enabled */
     t->processor_upgrade = 0x01; /* Other */
-    t->l1_cache_handle = cpu_to_le16(0xFFFF); /* N/A */
-    t->l2_cache_handle = cpu_to_le16(0xFFFF); /* N/A */
-    t->l3_cache_handle = cpu_to_le16(0xFFFF); /* N/A */
+    t->l1_cache_handle = cpu_to_le16(0x000A); /* N/A */
+    t->l2_cache_handle = cpu_to_le16(0x000B); /* N/A */
+    t->l3_cache_handle = cpu_to_le16(0x000C); /* N/A */
     SMBIOS_TABLE_SET_STR(4, serial_number_str, type4.serial);
     SMBIOS_TABLE_SET_STR(4, asset_tag_number_str, type4.asset);
     SMBIOS_TABLE_SET_STR(4, part_number_str, type4.part);
@@ -715,8 +792,27 @@ static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
 
     t->thread_count = (threads_per_socket > 255) ? 0xFF : threads_per_socket;
 
-    t->processor_characteristics = cpu_to_le16(0x02); /* Unknown */
-    t->processor_family2 = cpu_to_le16(type4.processor_family);
+    t->processor_characteristics = cpu_to_le16(0x00FC); /*
+
+    Table 27 â€“ Processor Characteristics
+    https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A315%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C214%2C0%5D
+
+    Hex    = 0x00FC
+    Binary = 0b0000000011111100
+
+    Bit1 = Unknown - 0 (No)
+    Bit2 = 64-bit Capable - 1 (Yes)
+    Bit3 = Multi-Core - 1 (Yes)
+    Bit4 = Hardware Thread - 1 (Yes)
+    Bit5 = Execute Protection - 1 (Yes)
+    Bit6 = Enhanced Virtualization - 1 (Yes)
+    Bit7 = Power/Performance Control - 1 (Yes)
+
+    */
+
+    t->processor_family2 = cpu_to_le16(0x00C6); /* Intel Core i7 processor */
+    if (type4.processor_family != 0x01)
+        t->processor_family2 = cpu_to_le16(type4.processor_family);
 
     if (tbl_len == SMBIOS_TYPE_4_LEN_V30) {
         t->core_count2 = t->core_enabled2 = cpu_to_le16(cores_per_socket);
@@ -837,15 +933,15 @@ static void smbios_build_type_11_table(void)
 
 #define MAX_T16_STD_SZ 0x80000000 /* 2T in Kilobytes */
 
-static void smbios_build_type_16_table(unsigned dimm_cnt)
+static void smbios_build_type_16_table_with_slots(unsigned dimm_cnt, unsigned slot_cnt)
 {
     uint64_t size_kb;
 
     SMBIOS_BUILD_TABLE_PRE(16, T16_BASE, true); /* required */
 
-    t->location = 0x01; /* Other */
+    t->location = 0x03; /* System Board/Motherboard */
     t->use = 0x03; /* System memory */
-    t->error_correction = 0x06; /* Multi-bit ECC (for Microsoft, per SeaBIOS) */
+    t->error_correction = 0x03; /* Multi-bit ECC (for Microsoft, per SeaBIOS) */
     size_kb = QEMU_ALIGN_UP(current_machine->ram_size, KiB) / KiB;
     if (size_kb < MAX_T16_STD_SZ) {
         t->maximum_capacity = cpu_to_le32(size_kb);
@@ -855,7 +951,10 @@ static void smbios_build_type_16_table(unsigned dimm_cnt)
         t->extended_maximum_capacity = cpu_to_le64(current_machine->ram_size);
     }
     t->memory_error_information_handle = cpu_to_le16(0xFFFE); /* Not provided */
-    t->number_of_memory_devices = cpu_to_le16(dimm_cnt);
+    if (dimm_cnt > slot_cnt)
+        t->number_of_memory_devices = cpu_to_le16(dimm_cnt);
+    else
+        t->number_of_memory_devices = cpu_to_le16(slot_cnt);
 
     SMBIOS_BUILD_TABLE_POST;
 }
@@ -863,7 +962,7 @@ static void smbios_build_type_16_table(unsigned dimm_cnt)
 #define MAX_T17_STD_SZ 0x7FFF /* (32G - 1M), in Megabytes */
 #define MAX_T17_EXT_SZ 0x80000000 /* 2P, in Megabytes */
 
-static void smbios_build_type_17_table(unsigned instance, uint64_t size)
+static void smbios_build_type_17_table_empty(unsigned instance, uint64_t size)
 {
     char loc_str[128];
     uint64_t size_mb;
@@ -872,8 +971,8 @@ static void smbios_build_type_17_table(unsigned instance, uint64_t size)
 
     t->physical_memory_array_handle = cpu_to_le16(0x1000); /* Type 16 above */
     t->memory_error_information_handle = cpu_to_le16(0xFFFE); /* Not provided */
-    t->total_width = cpu_to_le16(0xFFFF); /* Unknown */
-    t->data_width = cpu_to_le16(0xFFFF); /* Unknown */
+    t->total_width = cpu_to_le16(0x0040); // No ECC 64-bit
+    t->data_width = cpu_to_le16(0x0040); // No ECC 64-bit
     size_mb = QEMU_ALIGN_UP(size, MiB) / MiB;
     if (size_mb < MAX_T17_STD_SZ) {
         t->size = cpu_to_le16(size_mb);
@@ -883,23 +982,47 @@ static void smbios_build_type_17_table(unsigned instance, uint64_t size)
         t->size = cpu_to_le16(MAX_T17_STD_SZ);
         t->extended_size = cpu_to_le32(size_mb);
     }
-    t->form_factor = 0x09; /* DIMM */
+    t->form_factor = 0x09; /* DIMM and 0x0D for SODIMM */
     t->device_set = 0; /* Not in a set */
     snprintf(loc_str, sizeof(loc_str), "%s %d", type17.loc_pfx, instance);
     SMBIOS_TABLE_SET_STR(17, device_locator_str, loc_str);
     SMBIOS_TABLE_SET_STR(17, bank_locator_str, type17.bank);
-    t->memory_type = 0x07; /* RAM */
-    t->type_detail = cpu_to_le16(0x02); /* Other */
+    t->memory_type = 0x22; /* RAM */
+    t->type_detail = cpu_to_le16(0x0080); /*
+
+    Table 78 â€“ Memory Device: Type Detail field
+    https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A448%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C318%2C0%5D
+
+    Hex    = 0x0080
+    Binary = 0b0000000010000000
+
+    Bit0  = Reserved - 0 (No)
+    Bit1  = Other - 0 (No)
+    Bit2  = Unknown - 0 (No)
+    Bit3  = Fast-paged - 0 (No)
+    Bit4  = Static column - 0 (No)
+    Bit5  = Pseudo-static - 0 (No)
+    Bit6  = RAMBUS - 0 (No)
+    Bit7  = Synchronous - 1 (Yes)
+    Bit8  = CMOS - 0 (No)
+    Bit9  = EDO - 0 (No)
+    Bit10 = Window DRAM - 0 (No)
+    Bit11 = Cache DRAM - 0 (No)
+    Bit12 = Non-volatile - 0 (No)
+
+    */
     t->speed = cpu_to_le16(type17.speed);
     SMBIOS_TABLE_SET_STR(17, manufacturer_str, type17.manufacturer);
     SMBIOS_TABLE_SET_STR(17, serial_number_str, type17.serial);
     SMBIOS_TABLE_SET_STR(17, asset_tag_number_str, type17.asset);
     SMBIOS_TABLE_SET_STR(17, part_number_str, type17.part);
-    t->attributes = 0; /* Unknown */
+    t->attributes = 0x01; /* SINGLE RANK MODULE */
     t->configured_clock_speed = t->speed; /* reuse value for max speed */
-    t->minimum_voltage = cpu_to_le16(0); /* Unknown */
-    t->maximum_voltage = cpu_to_le16(0); /* Unknown */
-    t->configured_voltage = cpu_to_le16(0); /* Unknown */
+    // DDR4 Voltage, in mV
+    t->minimum_voltage = cpu_to_le16(1200); /* 1.2V Minimum Voltage Per DDR4 Spec */
+    t->maximum_voltage = cpu_to_le16(1500); /* 1.5V Minimum Voltage Per DDR4 Spec */
+    // 1.35V = typical XMP, 1.2V = JEDEC
+    t->configured_voltage = cpu_to_le16(1350); /* 1.35V XMP DDR4 Voltage */
 
     SMBIOS_BUILD_TABLE_POST;
 }
@@ -1016,8 +1139,9 @@ void smbios_set_default_processor_family(uint16_t processor_family)
 void smbios_set_defaults(const char *manufacturer, const char *product,
                          const char *version)
 {
-    smbios_have_defaults = true;
+    smbios_have_defaults = false;
 
+    /*
     SMBIOS_SET_DEFAULT(smbios_type1.manufacturer, manufacturer);
     SMBIOS_SET_DEFAULT(smbios_type1.product, product);
     SMBIOS_SET_DEFAULT(smbios_type1.version, version);
@@ -1031,6 +1155,7 @@ void smbios_set_defaults(const char *manufacturer, const char *product,
     SMBIOS_SET_DEFAULT(type4.version, version);
     SMBIOS_SET_DEFAULT(type17.loc_pfx, "DIMM");
     SMBIOS_SET_DEFAULT(type17.manufacturer, manufacturer);
+    */
 }
 
 static void smbios_entry_point_setup(SmbiosEntryPointType ep_type)
@@ -1092,7 +1217,7 @@ static bool smbios_get_tables_ep(MachineState *ms,
                        uint8_t **anchor, size_t *anchor_len,
                        Error **errp)
 {
-    unsigned i, dimm_cnt, offset;
+    unsigned i, dimm_cnt, offset, slot_cnt;
     MachineClass *mc = MACHINE_GET_CLASS(ms);
     ERRP_GUARD();
 
@@ -1114,7 +1239,7 @@ static bool smbios_get_tables_ep(MachineState *ms,
     assert(ms->smp.sockets >= 1);
 
     for (i = 0; i < ms->smp.sockets; i++) {
-        smbios_build_type_4_table(ms, i, ep_type, errp);
+        smbios_build_type_4_table(ms, i,ms->smp.sockets, ep_type, errp);
         if (*errp) {
             goto err_exit;
         }
@@ -1130,6 +1255,7 @@ static bool smbios_get_tables_ep(MachineState *ms,
     dimm_cnt = QEMU_ALIGN_UP(current_machine->ram_size,
                              mc->smbios_memory_device_size) /
                mc->smbios_memory_device_size;
+    slot_cnt = 4;
 
     /*
      * The offset determines if we need to keep additional space between
@@ -1138,13 +1264,25 @@ static bool smbios_get_tables_ep(MachineState *ms,
      * memory and DIMM like chunks of 16 GiB, the default space between
      * the two tables (T19_BASE - T17_BASE = 512) is not enough.
      */
-    offset = (dimm_cnt > (T19_BASE - T17_BASE)) ? \
-             dimm_cnt - (T19_BASE - T17_BASE) : 0;
+    if (dimm_cnt > slot_cnt) {
+        offset = (dimm_cnt > (T19_BASE - T17_BASE)) ?
+        dimm_cnt - (T19_BASE - T17_BASE) : 0;
+    } else {
+        offset = (slot_cnt > (T19_BASE - T17_BASE)) ?
+        slot_cnt - (T19_BASE - T17_BASE) : 0;
+    }
 
-    smbios_build_type_16_table(dimm_cnt);
+    smbios_build_type_16_table_with_slots(dimm_cnt, slot_cnt);
 
     for (i = 0; i < dimm_cnt; i++) {
-        smbios_build_type_17_table(i, GET_DIMM_SZ);
+        smbios_build_type_17_table_empty(i, GET_DIMM_SZ);
+    }
+
+    // Add empty slots...
+    if (slot_cnt > dimm_cnt) {
+        for (i = dimm_cnt; i < slot_cnt; i++) {
+            smbios_build_type_17_table_empty(i, GET_DIMM_SZ);
+        }
     }
 
     for (i = 0; i < mem_array_size; i++) {
diff --git a/hw/ufs/lu.c b/hw/ufs/lu.c
index 1c3794b2d4..64f4612435 100644
--- a/hw/ufs/lu.c
+++ b/hw/ufs/lu.c
@@ -184,8 +184,8 @@ static int ufs_emulate_wlun_inquiry(UfsRequest *req, uint8_t *outbuf,
     outbuf[5] = 0;
     outbuf[6] = 0;
     outbuf[7] = 0x2;
-    strpadcpy((char *)&outbuf[8], 8, "QEMU", ' ');
-    strpadcpy((char *)&outbuf[16], 16, "QEMU UFS", ' ');
+    strpadcpy((char *)&outbuf[8], 8, "MSI", ' ');
+    strpadcpy((char *)&outbuf[16], 16, "UFS", ' ');
     memset(&outbuf[32], 0, 4);
 
     return SCSI_INQUIRY_LEN;
diff --git a/hw/usb/canokey.c b/hw/usb/canokey.c
index e2d66179e0..9eaa29863e 100644
--- a/hw/usb/canokey.c
+++ b/hw/usb/canokey.c
@@ -35,8 +35,8 @@ enum {
 
 static const USBDescStrings desc_strings = {
     [STR_MANUFACTURER]     = "canokeys.org",
-    [STR_PRODUCT]          = "CanoKey QEMU",
-    [STR_SERIALNUMBER]     = "0"
+    [STR_PRODUCT]          = "CanoKey",
+    [STR_SERIALNUMBER]     = "ORPEIJ8LEZ"
 };
 
 static const USBDescDevice desc_device_canokey = {
diff --git a/hw/usb/dev-audio.c b/hw/usb/dev-audio.c
index 40f031252a..49f5515455 100644
--- a/hw/usb/dev-audio.c
+++ b/hw/usb/dev-audio.c
@@ -73,9 +73,9 @@ enum usb_audio_strings {
 };
 
 static const USBDescStrings usb_audio_stringtable = {
-    [STRING_MANUFACTURER]       = "QEMU",
-    [STRING_PRODUCT]            = "QEMU USB Audio",
-    [STRING_SERIALNUMBER]       = "1",
+    [STRING_MANUFACTURER]       = "Logitech",
+    [STRING_PRODUCT]            = "USB Audio",
+    [STRING_SERIALNUMBER]       = "SCNU3K6LPU",
     [STRING_CONFIG]             = "Audio Configuration",
     [STRING_USBAUDIO_CONTROL]   = "Audio Device",
     [STRING_INPUT_TERMINAL]     = "Audio Output Pipe",
diff --git a/hw/usb/dev-hid.c b/hw/usb/dev-hid.c
index accdd460e3..ffb07e0083 100644
--- a/hw/usb/dev-hid.c
+++ b/hw/usb/dev-hid.c
@@ -63,17 +63,17 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
-    [STR_PRODUCT_MOUSE]    = "QEMU USB Mouse",
-    [STR_PRODUCT_TABLET]   = "QEMU USB Tablet",
-    [STR_PRODUCT_KEYBOARD] = "QEMU USB Keyboard",
-    [STR_SERIAL_COMPAT]    = "42",
+    [STR_MANUFACTURER]     = "Logitech",
+    [STR_PRODUCT_MOUSE]    = "USB Mouse",
+    [STR_PRODUCT_TABLET]   = "USB Tablet",
+    [STR_PRODUCT_KEYBOARD] = "USB Keyboard",
+    [STR_SERIAL_COMPAT]    = "N76POILMPP",
     [STR_CONFIG_MOUSE]     = "HID Mouse",
     [STR_CONFIG_TABLET]    = "HID Tablet",
     [STR_CONFIG_KEYBOARD]  = "HID Keyboard",
-    [STR_SERIAL_MOUSE]     = "89126",
-    [STR_SERIAL_TABLET]    = "28754",
-    [STR_SERIAL_KEYBOARD]  = "68284",
+    [STR_SERIAL_MOUSE]     = "1F6IT6W2IF",
+    [STR_SERIAL_TABLET]    = "WSS5T9RFVE",
+    [STR_SERIAL_KEYBOARD]  = "V96SH0F8ZX",
 };
 
 static const USBDescIface desc_iface_mouse = {
@@ -368,7 +368,7 @@ static const USBDescMSOS desc_msos_suspend = {
 
 static const USBDesc desc_mouse = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x8086,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -382,7 +382,7 @@ static const USBDesc desc_mouse = {
 
 static const USBDesc desc_mouse2 = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x8086,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -397,7 +397,7 @@ static const USBDesc desc_mouse2 = {
 
 static const USBDesc desc_tablet = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x8086,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -411,7 +411,7 @@ static const USBDesc desc_tablet = {
 
 static const USBDesc desc_tablet2 = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x8086,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -426,7 +426,7 @@ static const USBDesc desc_tablet2 = {
 
 static const USBDesc desc_keyboard = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x8086,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -440,7 +440,7 @@ static const USBDesc desc_keyboard = {
 
 static const USBDesc desc_keyboard2 = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x8086,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -805,7 +805,7 @@ static void usb_tablet_class_initfn(ObjectClass *klass, void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_tablet_realize;
-    uc->product_desc   = "QEMU USB Tablet";
+    uc->product_desc   = "USB Tablet";
     dc->vmsd = &vmstate_usb_ptr;
     device_class_set_props(dc, usb_tablet_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
@@ -827,7 +827,7 @@ static void usb_mouse_class_initfn(ObjectClass *klass, void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_mouse_realize;
-    uc->product_desc   = "QEMU USB Mouse";
+    uc->product_desc   = "USB Mouse";
     dc->vmsd = &vmstate_usb_ptr;
     device_class_set_props(dc, usb_mouse_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
@@ -850,7 +850,7 @@ static void usb_keyboard_class_initfn(ObjectClass *klass, void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_keyboard_realize;
-    uc->product_desc   = "QEMU USB Keyboard";
+    uc->product_desc   = "USB Keyboard";
     dc->vmsd = &vmstate_usb_kbd;
     device_class_set_props(dc, usb_keyboard_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
diff --git a/hw/usb/dev-hub.c b/hw/usb/dev-hub.c
index 3880e2aca8..d6c9a3a657 100644
--- a/hw/usb/dev-hub.c
+++ b/hw/usb/dev-hub.c
@@ -104,9 +104,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
-    [STR_PRODUCT]      = "QEMU USB Hub",
-    [STR_SERIALNUMBER] = "314159",
+    [STR_MANUFACTURER] = "Logitech",
+    [STR_PRODUCT]      = "USB Hub",
+    [STR_SERIALNUMBER] = "EPCEFDU54X",
 };
 
 static const USBDescIface desc_iface_hub = {
@@ -676,7 +676,7 @@ static void usb_hub_class_initfn(ObjectClass *klass, void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_hub_realize;
-    uc->product_desc   = "QEMU USB Hub";
+    uc->product_desc   = "USB Hub";
     uc->usb_desc       = &desc_hub;
     uc->find_device    = usb_hub_find_device;
     uc->handle_reset   = usb_hub_handle_reset;
diff --git a/hw/usb/dev-mtp.c b/hw/usb/dev-mtp.c
index 326c92a43d..29c3b988cc 100644
--- a/hw/usb/dev-mtp.c
+++ b/hw/usb/dev-mtp.c
@@ -247,8 +247,8 @@ OBJECT_DECLARE_SIMPLE_TYPE(MTPState, USB_MTP)
 
 /* ----------------------------------------------------------------------- */
 
-#define MTP_MANUFACTURER  "QEMU"
-#define MTP_PRODUCT       "QEMU filesharing"
+#define MTP_MANUFACTURER  "Microsoft"
+#define MTP_PRODUCT       "filesharing"
 #define MTP_WRITE_BUF_SZ  (512 * KiB)
 
 enum {
@@ -264,7 +264,7 @@ enum {
 static const USBDescStrings desc_strings = {
     [STR_MANUFACTURER] = MTP_MANUFACTURER,
     [STR_PRODUCT]      = MTP_PRODUCT,
-    [STR_SERIALNUMBER] = "34617",
+    [STR_SERIALNUMBER] = "FJFR36ZGFQ",
     [STR_MTP]          = "MTP",
     [STR_CONFIG_FULL]  = "Full speed config (usb 1.1)",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
@@ -2090,7 +2090,7 @@ static void usb_mtp_class_initfn(ObjectClass *klass, void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_mtp_realize;
-    uc->product_desc   = "QEMU USB MTP";
+    uc->product_desc   = "USB MTP";
     uc->usb_desc       = &desc;
     uc->cancel_packet  = usb_mtp_cancel_packet;
     uc->handle_attach  = usb_desc_attach;
diff --git a/hw/usb/dev-network.c b/hw/usb/dev-network.c
index a87a0ffb95..afd4529728 100644
--- a/hw/usb/dev-network.c
+++ b/hw/usb/dev-network.c
@@ -99,16 +99,16 @@ enum usbstring_idx {
 #define ETH_FRAME_LEN                   1514 /* Max. octets in frame sans FCS */
 
 static const USBDescStrings usb_net_stringtable = {
-    [STRING_MANUFACTURER]       = "QEMU",
-    [STRING_PRODUCT]            = "RNDIS/QEMU USB Network Device",
-    [STRING_ETHADDR]            = "400102030405",
-    [STRING_DATA]               = "QEMU USB Net Data Interface",
-    [STRING_CONTROL]            = "QEMU USB Net Control Interface",
-    [STRING_RNDIS_CONTROL]      = "QEMU USB Net RNDIS Control Interface",
-    [STRING_CDC]                = "QEMU USB Net CDC",
-    [STRING_SUBSET]             = "QEMU USB Net Subset",
-    [STRING_RNDIS]              = "QEMU USB Net RNDIS",
-    [STRING_SERIALNUMBER]       = "1",
+    [STRING_MANUFACTURER]       = "Realtek",
+    [STRING_PRODUCT]            = "RNDIS/Realtek USB Network Device",
+    [STRING_ETHADDR]            = "4C82A94C9ECA",
+    [STRING_DATA]               = "USB Net Data Interface",
+    [STRING_CONTROL]            = "USB Net Control Interface",
+    [STRING_RNDIS_CONTROL]      = "USB Net RNDIS Control Interface",
+    [STRING_CDC]                = "USB Net CDC",
+    [STRING_SUBSET]             = "USB Net Subset",
+    [STRING_RNDIS]              = "USB Net RNDIS",
+    [STRING_SERIALNUMBER]       = "D9H87OLLOE",
 };
 
 static const USBDescIface desc_iface_rndis[] = {
@@ -717,7 +717,7 @@ static int ndis_query(USBNetState *s, uint32_t oid,
 
     /* mandatory */
     case OID_GEN_VENDOR_DESCRIPTION:
-        pstrcpy((char *)outbuf, outlen, "QEMU USB RNDIS Net");
+        pstrcpy((char *)outbuf, outlen, "USB RNDIS Net");
         return strlen((char *)outbuf) + 1;
 
     case OID_GEN_VENDOR_DRIVER_VERSION:
@@ -1417,7 +1417,7 @@ static void usb_net_class_initfn(ObjectClass *klass, void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_net_realize;
-    uc->product_desc   = "QEMU USB Network Interface";
+    uc->product_desc   = "USB Network Interface";
     uc->usb_desc       = &desc_net;
     uc->handle_reset   = usb_net_handle_reset;
     uc->handle_control = usb_net_handle_control;
diff --git a/hw/usb/dev-serial.c b/hw/usb/dev-serial.c
index aa50a92e26..285be475e6 100644
--- a/hw/usb/dev-serial.c
+++ b/hw/usb/dev-serial.c
@@ -119,10 +119,10 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]    = "QEMU",
-    [STR_PRODUCT_SERIAL]  = "QEMU USB SERIAL",
-    [STR_PRODUCT_BRAILLE] = "QEMU USB BAUM BRAILLE",
-    [STR_SERIALNUMBER]    = "1",
+    [STR_MANUFACTURER]    = "Microsoft",
+    [STR_PRODUCT_SERIAL]  = "USB SERIAL",
+    [STR_PRODUCT_BRAILLE] = "USB BAUM BRAILLE",
+    [STR_SERIALNUMBER]    = "6KCP6OG5KL",
 };
 
 static const USBDescIface desc_iface0 = {
@@ -665,7 +665,7 @@ static void usb_serial_class_initfn(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB Serial";
+    uc->product_desc   = "USB Serial";
     uc->usb_desc       = &desc_serial;
     device_class_set_props(dc, serial_properties);
 }
@@ -685,7 +685,7 @@ static void usb_braille_class_initfn(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB Braille";
+    uc->product_desc   = "USB Braille";
     uc->usb_desc       = &desc_braille;
     device_class_set_props(dc, braille_properties);
 }
diff --git a/hw/usb/dev-smartcard-reader.c b/hw/usb/dev-smartcard-reader.c
index 73deb3ce83..32a8b51430 100644
--- a/hw/usb/dev-smartcard-reader.c
+++ b/hw/usb/dev-smartcard-reader.c
@@ -80,8 +80,8 @@ OBJECT_DECLARE_SIMPLE_TYPE(USBCCIDState, USB_CCID_DEV)
 #define CCID_CONTROL_GET_CLOCK_FREQUENCIES  0x2
 #define CCID_CONTROL_GET_DATA_RATES         0x3
 
-#define CCID_PRODUCT_DESCRIPTION        "QEMU USB CCID"
-#define CCID_VENDOR_DESCRIPTION         "QEMU"
+#define CCID_PRODUCT_DESCRIPTION        "USB CCID"
+#define CCID_VENDOR_DESCRIPTION         "Identiv"
 #define CCID_INTERFACE_NAME             "CCID Interface"
 #define CCID_SERIAL_NUMBER_STRING       "1"
 /*
@@ -419,9 +419,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]  = "QEMU",
-    [STR_PRODUCT]       = "QEMU USB CCID",
-    [STR_SERIALNUMBER]  = "1",
+    [STR_MANUFACTURER]  = "Identiv",
+    [STR_PRODUCT]       = "USB CCID",
+    [STR_SERIALNUMBER]  = "L9Z3ZM8CDP",
     [STR_INTERFACE]     = "CCID Interface",
 };
 
@@ -1441,7 +1441,7 @@ static void ccid_class_initfn(ObjectClass *klass, void *data)
     HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(klass);
 
     uc->realize        = ccid_realize;
-    uc->product_desc   = "QEMU USB CCID";
+    uc->product_desc   = "USB CCID";
     uc->usb_desc       = &desc_ccid;
     uc->handle_reset   = ccid_handle_reset;
     uc->handle_control = ccid_handle_control;
diff --git a/hw/usb/dev-storage.c b/hw/usb/dev-storage.c
index 4f1e8b7f6c..e1af6a9221 100644
--- a/hw/usb/dev-storage.c
+++ b/hw/usb/dev-storage.c
@@ -47,9 +47,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
-    [STR_PRODUCT]      = "QEMU USB HARDDRIVE",
-    [STR_SERIALNUMBER] = "1",
+    [STR_MANUFACTURER] = "Samsung",
+    [STR_PRODUCT]      = "USB HARDDRIVE",
+    [STR_SERIALNUMBER] = "HLN8ILM0SH",
     [STR_CONFIG_FULL]  = "Full speed config (usb 1.1)",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
     [STR_CONFIG_SUPER] = "Super speed config (usb 3.0)",
@@ -590,7 +590,7 @@ static void usb_msd_class_initfn_common(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB MSD";
+    uc->product_desc   = "USB MSD";
     uc->usb_desc       = &desc;
     uc->cancel_packet  = usb_msd_cancel_io;
     uc->handle_attach  = usb_desc_attach;
diff --git a/hw/usb/dev-uas.c b/hw/usb/dev-uas.c
index 44e30013d7..51b9accc1d 100644
--- a/hw/usb/dev-uas.c
+++ b/hw/usb/dev-uas.c
@@ -171,9 +171,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
+    [STR_MANUFACTURER] = "Microsoft",
     [STR_PRODUCT]      = "USB Attached SCSI HBA",
-    [STR_SERIALNUMBER] = "27842",
+    [STR_SERIALNUMBER] = "E5DEMH2Y7X",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
     [STR_CONFIG_SUPER] = "Super speed config (usb 3.0)",
 };
diff --git a/hw/usb/dev-wacom.c b/hw/usb/dev-wacom.c
index 7177c17f03..6a0420d110 100644
--- a/hw/usb/dev-wacom.c
+++ b/hw/usb/dev-wacom.c
@@ -64,9 +64,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
+    [STR_MANUFACTURER]     = "Wacom",
     [STR_PRODUCT]          = "Wacom PenPartner",
-    [STR_SERIALNUMBER]     = "1",
+    [STR_SERIALNUMBER]     = "718H83W0T4",
 };
 
 static const uint8_t qemu_wacom_hid_report_descriptor[] = {
@@ -231,7 +231,7 @@ static int usb_mouse_poll(USBWacomState *s, uint8_t *buf, int len)
 
     if (!s->mouse_grabbed) {
         s->eh_entry = qemu_add_mouse_event_handler(usb_mouse_event, s, 0,
-                        "QEMU PenPartner tablet");
+                        "PenPartner tablet");
         qemu_activate_mouse_event_handler(s->eh_entry);
         s->mouse_grabbed = 1;
     }
@@ -269,7 +269,7 @@ static int usb_wacom_poll(USBWacomState *s, uint8_t *buf, int len)
 
     if (!s->mouse_grabbed) {
         s->eh_entry = qemu_add_mouse_event_handler(usb_wacom_event, s, 1,
-                        "QEMU PenPartner tablet");
+                        "PenPartner tablet");
         qemu_activate_mouse_event_handler(s->eh_entry);
         s->mouse_grabbed = 1;
     }
@@ -425,7 +425,7 @@ static void usb_wacom_class_init(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU PenPartner Tablet";
+    uc->product_desc   = "PenPartner Tablet";
     uc->usb_desc       = &desc_wacom;
     uc->realize        = usb_wacom_realize;
     uc->handle_reset   = usb_wacom_handle_reset;
@@ -433,7 +433,7 @@ static void usb_wacom_class_init(ObjectClass *klass, void *data)
     uc->handle_data    = usb_wacom_handle_data;
     uc->unrealize      = usb_wacom_unrealize;
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
-    dc->desc = "QEMU PenPartner Tablet";
+    dc->desc = "PenPartner Tablet";
     dc->vmsd = &vmstate_usb_wacom;
 }
 
diff --git a/hw/usb/u2f-emulated.c b/hw/usb/u2f-emulated.c
index e1dd19ee92..803b227813 100644
--- a/hw/usb/u2f-emulated.c
+++ b/hw/usb/u2f-emulated.c
@@ -385,7 +385,7 @@ static void u2f_emulated_class_init(ObjectClass *klass, void *data)
     kc->realize = u2f_emulated_realize;
     kc->unrealize = u2f_emulated_unrealize;
     kc->recv_from_guest = u2f_emulated_recv_from_guest;
-    dc->desc = "QEMU U2F emulated key";
+    dc->desc = "U2F emulated key";
     device_class_set_props(dc, u2f_emulated_properties);
 }
 
diff --git a/hw/usb/u2f-passthru.c b/hw/usb/u2f-passthru.c
index 8df5215a1f..9f5e9d0eb8 100644
--- a/hw/usb/u2f-passthru.c
+++ b/hw/usb/u2f-passthru.c
@@ -528,7 +528,7 @@ static void u2f_passthru_class_init(ObjectClass *klass, void *data)
     kc->realize = u2f_passthru_realize;
     kc->unrealize = u2f_passthru_unrealize;
     kc->recv_from_guest = u2f_passthru_recv_from_guest;
-    dc->desc = "QEMU U2F passthrough key";
+    dc->desc = "U2F passthrough key";
     dc->vmsd = &u2f_passthru_vmstate;
     device_class_set_props(dc, u2f_passthru_properties);
     set_bit(DEVICE_CATEGORY_MISC, dc->categories);
diff --git a/hw/usb/u2f.c b/hw/usb/u2f.c
index 1fb59cf404..53da8be63e 100644
--- a/hw/usb/u2f.c
+++ b/hw/usb/u2f.c
@@ -46,9 +46,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
+    [STR_MANUFACTURER]     = "Microsoft",
     [STR_PRODUCT]          = "U2F USB key",
-    [STR_SERIALNUMBER]     = "0",
+    [STR_SERIALNUMBER]     = "JFX4J5OICR",
     [STR_CONFIG]           = "U2F key config",
     [STR_INTERFACE]        = "U2F key interface"
 };
@@ -322,7 +322,7 @@ static void u2f_key_class_init(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU U2F USB key";
+    uc->product_desc   = "U2F USB key";
     uc->usb_desc       = &desc_u2f_key;
     uc->handle_reset   = u2f_key_handle_reset;
     uc->handle_control = u2f_key_handle_control;
@@ -330,7 +330,7 @@ static void u2f_key_class_init(ObjectClass *klass, void *data)
     uc->handle_attach  = usb_desc_attach;
     uc->realize        = u2f_key_realize;
     uc->unrealize      = u2f_key_unrealize;
-    dc->desc           = "QEMU U2F key";
+    dc->desc           = "U2F key";
     dc->vmsd           = &vmstate_u2f_key;
 }
 
diff --git a/pc-bios/optionrom/optionrom.h b/pc-bios/optionrom/optionrom.h
index 7bcdf0e..9c2a417 100644
--- a/pc-bios/optionrom/optionrom.h
+++ b/pc-bios/optionrom/optionrom.h
@@ -43,7 +43,7 @@
 #define FW_CFG_DMA_CTL_SELECT  0x08
 #define FW_CFG_DMA_CTL_WRITE   0x10
 
-#define FW_CFG_DMA_SIGNATURE 0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE 0x51434f4d20434647ULL /* "QCOM CFG" */
 
 #define BIOS_CFG_DMA_ADDR_HIGH  0x514
 #define BIOS_CFG_DMA_ADDR_LOW   0x518
diff --git a/hw/vfio/ap.c b/hw/vfio/ap.c
index c7ab4ff57a..9bb3cf437e 100644
--- a/hw/vfio/ap.c
+++ b/hw/vfio/ap.c
@@ -254,7 +254,7 @@ static void vfio_ap_class_init(ObjectClass *klass, void *data)
     set_bit(DEVICE_CATEGORY_MISC, dc->categories);
     dc->realize = vfio_ap_realize;
     dc->unrealize = vfio_ap_unrealize;
-    dc->hotpluggable = true;
+    dc->hotpluggable = false;
     device_class_set_legacy_reset(dc, vfio_ap_reset);
     dc->bus_type = TYPE_AP_BUS;
 
diff --git a/include/hw/acpi/aml-build.h b/include/hw/acpi/aml-build.h
index c18f681342..abc649ed43 100644
--- a/include/hw/acpi/aml-build.h
+++ b/include/hw/acpi/aml-build.h
@@ -4,8 +4,8 @@
 #include "hw/acpi/acpi-defs.h"
 #include "hw/acpi/bios-linker-loader.h"
 
-#define ACPI_BUILD_APPNAME6 "BOCHS "
-#define ACPI_BUILD_APPNAME8 "BXPC    "
+#define ACPI_BUILD_APPNAME6 "INTEL "
+#define ACPI_BUILD_APPNAME8 "U Rvp   "
 
 #define ACPI_BUILD_TABLE_FILE "etc/acpi/tables"
 #define ACPI_BUILD_RSDP_FILE "etc/acpi/rsdp"
diff --git a/include/hw/pci/pci.h b/include/hw/pci/pci.h
index 822fbacdf0..c84d278e9c 100644
--- a/include/hw/pci/pci.h
+++ b/include/hw/pci/pci.h
@@ -57,7 +57,7 @@ extern bool pci_available;
 #define PCI_DEVICE_ID_MARVELL_GT6412X    0x4620
 
 /* QEMU/Bochs VGA (0x1234) */
-#define PCI_VENDOR_ID_QEMU               0x1234
+#define PCI_VENDOR_ID_QEMU               0x8086 // "???" | Intel Device ID Replacement from 0x1234
 #define PCI_DEVICE_ID_QEMU_VGA           0x1111
 #define PCI_DEVICE_ID_QEMU_IPMI          0x1112
 
@@ -74,12 +74,12 @@ extern bool pci_available;
 /* Intel (0x8086) */
 #define PCI_DEVICE_ID_INTEL_82551IT      0x1209
 #define PCI_DEVICE_ID_INTEL_82557        0x1229
-#define PCI_DEVICE_ID_INTEL_82801IR      0x2922
+#define PCI_DEVICE_ID_INTEL_82801IR      0x463D // Intel 82801IR ICH9 - LPC Bridge [A2] | Intel Device ID Replacement from 0x2922 | hw/ide/ich.c
 
 /* Red Hat / Qumranet (for QEMU) -- see pci-ids.txt */
-#define PCI_VENDOR_ID_REDHAT_QUMRANET    0x1af4
-#define PCI_SUBVENDOR_ID_REDHAT_QUMRANET 0x1af4
-#define PCI_SUBDEVICE_ID_QEMU            0x1100
+#define PCI_VENDOR_ID_REDHAT_QUMRANET    0x8086 // Intel Device ID Replacement from 0x1af4
+#define PCI_SUBVENDOR_ID_REDHAT_QUMRANET 0x8086 // Intel Device ID Replacement from 0x1af4
+#define PCI_SUBDEVICE_ID_QEMU            0x8086 // Intel Device ID Replacement from 0x1100
 
 /* legacy virtio-pci devices */
 #define PCI_DEVICE_ID_VIRTIO_NET         0x1000
@@ -100,21 +100,21 @@ extern bool pci_available;
  */
 #define PCI_DEVICE_ID_VIRTIO_10_BASE     0x1040
 
-#define PCI_VENDOR_ID_REDHAT             0x1b36
-#define PCI_DEVICE_ID_REDHAT_BRIDGE      0x0001
-#define PCI_DEVICE_ID_REDHAT_SERIAL      0x0002
+#define PCI_VENDOR_ID_REDHAT             0x8086 // "Red Hat, Inc." | Intel Vendor ID Replacement from 0x1b36
+#define PCI_DEVICE_ID_REDHAT_BRIDGE      0x4641 // "QEMU PCI-PCI bridge" | Intel Device ID Replacement from 0x0001 | hw/pci-bridge/pci_bridge_dev.c
+#define PCI_DEVICE_ID_REDHAT_SERIAL      0x0002 // TODO: find device_id | Intel Device ID Replacement from 0x???? | hw/char/serial-pci.c
 #define PCI_DEVICE_ID_REDHAT_SERIAL2     0x0003
 #define PCI_DEVICE_ID_REDHAT_SERIAL4     0x0004
 #define PCI_DEVICE_ID_REDHAT_TEST        0x0005
 #define PCI_DEVICE_ID_REDHAT_ROCKER      0x0006
 #define PCI_DEVICE_ID_REDHAT_SDHCI       0x0007
-#define PCI_DEVICE_ID_REDHAT_PCIE_HOST   0x0008
+#define PCI_DEVICE_ID_REDHAT_PCIE_HOST   0x4641 // "QEMU PCIe Host bridge" | Intel Device ID Replacement from 0x0008 | hw/pci-host/gpex.c
 #define PCI_DEVICE_ID_REDHAT_PXB         0x0009
 #define PCI_DEVICE_ID_REDHAT_BRIDGE_SEAT 0x000a
 #define PCI_DEVICE_ID_REDHAT_PXB_PCIE    0x000b
-#define PCI_DEVICE_ID_REDHAT_PCIE_RP     0x000c
-#define PCI_DEVICE_ID_REDHAT_XHCI        0x000d
-#define PCI_DEVICE_ID_REDHAT_PCIE_BRIDGE 0x000e
+#define PCI_DEVICE_ID_REDHAT_PCIE_RP     0x51b0 // "QEMU PCIe Root Port" | Intel Device ID Replacement from 0x000c | hw/pci-bridge/gen_pcie_root_port.c
+#define PCI_DEVICE_ID_REDHAT_XHCI        0x51ed // "QEMU XHCI Host Controller" | Intel Device ID Replacement from 0x000d | hw/usb/hcd-xhci-pci.c
+#define PCI_DEVICE_ID_REDHAT_PCIE_BRIDGE 0x51b0 // "Red Hat, Device ID: 000E" | Intel Device ID Replacement from 0x000e | hw/pci-bridge/pcie_pci_bridge.c
 #define PCI_DEVICE_ID_REDHAT_MDPY        0x000f
 #define PCI_DEVICE_ID_REDHAT_NVME        0x0010
 #define PCI_DEVICE_ID_REDHAT_PVPANIC     0x0011
diff --git a/include/hw/pci/pci_ids.h b/include/hw/pci/pci_ids.h
index 33e2898be9..18915efaf9 100644
--- a/include/hw/pci/pci_ids.h
+++ b/include/hw/pci/pci_ids.h
@@ -237,6 +237,8 @@
 #define PCI_VENDOR_ID_BAIDU              0x1d22
 #define PCI_DEVICE_ID_KUNLUN_VF          0x3685
 
+/* https://www.pcilookup.com/ */
+
 #define PCI_VENDOR_ID_INTEL              0x8086
 #define PCI_DEVICE_ID_INTEL_82378        0x0484
 #define PCI_DEVICE_ID_INTEL_82441        0x1237
@@ -246,8 +248,8 @@
 #define PCI_DEVICE_ID_INTEL_ESB_9        0x25ab
 #define PCI_DEVICE_ID_INTEL_NVME         0x5845
 #define PCI_DEVICE_ID_INTEL_82371SB_0    0x7000
-#define PCI_DEVICE_ID_INTEL_82371SB_1    0x7010
-#define PCI_DEVICE_ID_INTEL_82371SB_2    0x7020
+#define PCI_DEVICE_ID_INTEL_82371SB_1    0x7010 // TODO: | Intel 82371SB_1 - ??? | Intel Vendor ID Replacement from 0x???? | hw/ide/piix.c
+#define PCI_DEVICE_ID_INTEL_82371SB_2    0x7020 // TODO: | Intel 82371SB_2 - ??? | Intel Vendor ID Replacement from 0x???? | hw/usb/hcd-uhci.c
 #define PCI_DEVICE_ID_INTEL_82371AB_0    0x7110
 #define PCI_DEVICE_ID_INTEL_82371AB      0x7111
 #define PCI_DEVICE_ID_INTEL_82371AB_2    0x7112
@@ -259,9 +261,9 @@
 #define PCI_DEVICE_ID_INTEL_ICH9_3       0x2913
 #define PCI_DEVICE_ID_INTEL_ICH9_4       0x2914
 #define PCI_DEVICE_ID_INTEL_ICH9_5       0x2919
-#define PCI_DEVICE_ID_INTEL_ICH9_6       0x2930
+#define PCI_DEVICE_ID_INTEL_ICH9_6       0x51a3 // Intel 82801IB ICH9 - SMBus Controller [A2] | Intel Vendor ID Replacement from 0x2930 | hw/i2c/smbus_ich9.c
 #define PCI_DEVICE_ID_INTEL_ICH9_7       0x2916
-#define PCI_DEVICE_ID_INTEL_ICH9_8       0x2918
+#define PCI_DEVICE_ID_INTEL_ICH9_8       0x5182 // Intel 82801IR ICH9 - LPC Bridge [A2] | Intel Vendor ID Replacement from 0x2918 | hw/isa/lpc_ich9.c
 
 #define PCI_DEVICE_ID_INTEL_82801I_UHCI1 0x2934
 #define PCI_DEVICE_ID_INTEL_82801I_UHCI2 0x2935
@@ -273,7 +275,7 @@
 #define PCI_DEVICE_ID_INTEL_82801I_EHCI2 0x293c
 #define PCI_DEVICE_ID_INTEL_82599_SFP_VF 0x10ed
 
-#define PCI_DEVICE_ID_INTEL_P35_MCH      0x29c0
+#define PCI_DEVICE_ID_INTEL_P35_MCH      0x4641 // Intel G33/P35/Q35/Q33 Chipset - Memory Controller Hub [A0] | Intel Vendor ID Replacement from 0x29c0 | hw/pci-host/q35.c
 
 #define PCI_VENDOR_ID_XEN                0x5853
 #define PCI_DEVICE_ID_XEN_PLATFORM       0x0001
diff --git a/include/standard-headers/linux/qemu_fw_cfg.h b/include/standard-headers/linux/qemu_fw_cfg.h
index cb93f6678d..fe34590061 100644
--- a/include/standard-headers/linux/qemu_fw_cfg.h
+++ b/include/standard-headers/linux/qemu_fw_cfg.h
@@ -4,7 +4,7 @@
 
 #include "standard-headers/linux/types.h"
 
-#define FW_CFG_ACPI_DEVICE_ID	"QEMU0002"
+#define FW_CFG_ACPI_DEVICE_ID	"UEFI0002"
 
 /* selector key values for "well-known" fw_cfg entries */
 #define FW_CFG_SIGNATURE	0x00
@@ -71,7 +71,7 @@ struct fw_cfg_file {
 #define FW_CFG_DMA_CTL_SELECT	0x08
 #define FW_CFG_DMA_CTL_WRITE	0x10
 
-#define FW_CFG_DMA_SIGNATURE    0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE    0x51434f4d20434647ULL /* "QCOM CFG" */
 
 /* Control as first field allows for different structures selected by this
  * field, which might be useful in the future
diff --git a/migration/rdma.c b/migration/rdma.c
index 76fb034923..badc49ef9f 100644
--- a/migration/rdma.c
+++ b/migration/rdma.c
@@ -220,7 +220,7 @@ static const char *control_desc(unsigned int rdma_control)
         [RDMA_CONTROL_NONE] = "NONE",
         [RDMA_CONTROL_ERROR] = "ERROR",
         [RDMA_CONTROL_READY] = "READY",
-        [RDMA_CONTROL_QEMU_FILE] = "QEMU FILE",
+        [RDMA_CONTROL_QEMU_FILE] = "FILE",
         [RDMA_CONTROL_RAM_BLOCKS_REQUEST] = "RAM BLOCKS REQUEST",
         [RDMA_CONTROL_RAM_BLOCKS_RESULT] = "RAM BLOCKS RESULT",
         [RDMA_CONTROL_COMPRESS] = "COMPRESS",
diff --git a/pc-bios/s390-ccw/virtio-scsi.h b/pc-bios/s390-ccw/virtio-scsi.h
index c5612e16a2..048cb93d3d 100644
--- a/pc-bios/s390-ccw/virtio-scsi.h
+++ b/pc-bios/s390-ccw/virtio-scsi.h
@@ -25,7 +25,7 @@
 #define VIRTIO_SCSI_S_OK                     0x00
 #define VIRTIO_SCSI_S_BAD_TARGET             0x03
 
-#define QEMU_CDROM_SIGNATURE "QEMU CD-ROM     "
+#define QEMU_CDROM_SIGNATURE "ASUS CD-ROM     "
 
 enum virtio_scsi_vq_id {
     VR_CONTROL  = 0,
diff --git a/qapi/ui.json b/qapi/ui.json
index c536d4e524..c856182887 100644
--- a/qapi/ui.json
+++ b/qapi/ui.json
@@ -831,13 +831,13 @@
 #     -> { "execute": "query-mice" }
 #     <- { "return": [
 #              {
-#                 "name":"QEMU Microsoft Mouse",
+#                 "name":"Microsoft Mouse",
 #                 "index":0,
 #                 "current":false,
 #                 "absolute":false
 #              },
 #              {
-#                 "name":"QEMU PS/2 Mouse",
+#                 "name":"PS/2 Mouse",
 #                 "index":1,
 #                 "current":true,
 #                 "absolute":true
diff --git a/target/i386/cpu.c b/target/i386/cpu.c
index 5e12cba1b8..1ac812a747 100644
--- a/target/i386/cpu.c
+++ b/target/i386/cpu.c
@@ -2502,7 +2502,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
         .features[FEAT_8000_0001_ECX] =
             CPUID_EXT3_LAHF_LM | CPUID_EXT3_SVM,
         .xlevel = 0x8000000A,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "Intel CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "phenom",
@@ -2617,7 +2617,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
              VMX_CPU_BASED_UNCOND_IO_EXITING | VMX_CPU_BASED_USE_IO_BITMAPS |
              VMX_CPU_BASED_MONITOR_EXITING | VMX_CPU_BASED_PAUSE_EXITING,
         .xlevel = 0x80000008,
-        .model_id = "Common KVM processor"
+        .model_id = "Common Intel processor"
     },
     {
         .name = "qemu32",
@@ -2631,7 +2631,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
         .features[FEAT_1_ECX] =
             CPUID_EXT_SSE3,
         .xlevel = 0x80000004,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "Intel CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "kvm32",
@@ -2661,7 +2661,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
              VMX_CPU_BASED_USE_IO_BITMAPS | VMX_CPU_BASED_MONITOR_EXITING |
              VMX_CPU_BASED_PAUSE_EXITING | VMX_CPU_BASED_USE_MSR_BITMAPS,
         .xlevel = 0x80000008,
-        .model_id = "Common 32-bit KVM processor"
+        .model_id = "Common 32-bit Intel processor"
     },
     {
         .name = "coreduo",
@@ -2757,7 +2757,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
         .features[FEAT_8000_0001_EDX] =
             CPUID_EXT2_MMXEXT | CPUID_EXT2_3DNOW | CPUID_EXT2_3DNOWEXT,
         .xlevel = 0x80000008,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "Intel CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "n270",
@@ -5734,7 +5734,7 @@ static void max_x86_cpu_initfn(Object *obj)
     object_property_set_str(OBJECT(cpu), "vendor", CPUID_VENDOR_AMD,
                             &error_abort);
     object_property_set_str(OBJECT(cpu), "model-id",
-                            "QEMU TCG CPU version " QEMU_HW_VERSION,
+                            "TCG CPU version " QEMU_HW_VERSION,
                             &error_abort);
 }
 
@@ -8022,7 +8022,7 @@ static void x86_cpu_hyperv_realize(X86CPU *cpu)
 
     /* Hyper-V vendor id */
     if (!cpu->hyperv_vendor) {
-        object_property_set_str(OBJECT(cpu), "hv-vendor-id", "Microsoft Hv",
+        object_property_set_str(OBJECT(cpu), "hv-vendor-id", "",
                                 &error_abort);
     }
     len = strlen(cpu->hyperv_vendor);
diff --git a/target/i386/kvm/kvm.c b/target/i386/kvm/kvm.c
index 6c749d4ee8..1a265dc748 100644
--- a/target/i386/kvm/kvm.c
+++ b/target/i386/kvm/kvm.c
@@ -1618,7 +1618,7 @@ static int hyperv_fill_cpuids(CPUState *cs,
         c->function = HV_CPUID_SYNDBG_VENDOR_AND_MAX_FUNCTIONS;
         c->eax = hyperv_feat_enabled(cpu, HYPERV_FEAT_EVMCS) ?
             HV_CPUID_NESTED_FEATURES : HV_CPUID_IMPLEMENT_LIMITS;
-        memcpy(signature, "Microsoft VS", 12);
+        memset(signature, 0, 12);
         c->eax = 0;
         c->ebx = signature[0];
         c->ecx = signature[1];
@@ -1626,7 +1626,7 @@ static int hyperv_fill_cpuids(CPUState *cs,
 
         c = &cpuid_ent[cpuid_i++];
         c->function = HV_CPUID_SYNDBG_INTERFACE;
-        memcpy(signature, "VS#1\0\0\0\0\0\0\0\0", 12);
+        memset(signature, 0, 12);
         c->eax = signature[0];
         c->ebx = 0;
         c->ecx = 0;
@@ -2130,7 +2130,7 @@ int kvm_arch_init_vcpu(CPUState *cs)
 #ifdef CONFIG_XEN_EMU
         struct kvm_cpuid_entry2 *xen_max_leaf;
 
-        memcpy(signature, "XenVMMXenVMM", 12);
+        memset(signature, 0, 12);
 
         xen_max_leaf = c = &cpuid_data.entries[cpuid_i++];
         c->function = kvm_base + XEN_CPUID_SIGNATURE;
@@ -2206,7 +2206,7 @@ int kvm_arch_init_vcpu(CPUState *cs)
         abort();
 #endif
     } else if (cpu->expose_kvm) {
-        memcpy(signature, "KVMKVMKVM\0\0\0", 12);
+        memset(signature, 0, 12);
         c = &cpuid_data.entries[cpuid_i++];
         c->function = KVM_CPUID_SIGNATURE | kvm_base;
         c->eax = KVM_CPUID_FEATURES | kvm_base;
diff --git a/target/s390x/cpu_models.c b/target/s390x/cpu_models.c
index 93a05e43d7..f3eaa1c1a8 100644
--- a/target/s390x/cpu_models.c
+++ b/target/s390x/cpu_models.c
@@ -955,7 +955,7 @@ static void s390_qemu_cpu_model_class_init(ObjectClass *oc, void *data)
     S390CPUClass *xcc = S390_CPU_CLASS(oc);
 
     xcc->is_migration_safe = true;
-    xcc->desc = g_strdup_printf("QEMU Virtual CPU version %s",
+    xcc->desc = g_strdup_printf("CPU version %s",
                                 qemu_hw_version());
 }
 
diff --git a/target/s390x/tcg/misc_helper.c b/target/s390x/tcg/misc_helper.c
index 31266aeda4..18b9b6448e 100644
--- a/target/s390x/tcg/misc_helper.c
+++ b/target/s390x/tcg/misc_helper.c
@@ -331,18 +331,18 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
             /* Basic Machine Configuration */
             char type[5] = {};
 
-            ebcdic_put(sysib.sysib_111.manuf, "QEMU            ", 16);
+            ebcdic_put(sysib.sysib_111.manuf, "Intel           ", 16);
             /* same as machine type number in STORE CPU ID, but in EBCDIC */
             snprintf(type, ARRAY_SIZE(type), "%X", cpu->model->def->type);
             ebcdic_put(sysib.sysib_111.type, type, 4);
             /* model number (not stored in STORE CPU ID for z/Architecture) */
-            ebcdic_put(sysib.sysib_111.model, "QEMU            ", 16);
-            ebcdic_put(sysib.sysib_111.sequence, "QEMU            ", 16);
-            ebcdic_put(sysib.sysib_111.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_111.model, "Intel           ", 16);
+            ebcdic_put(sysib.sysib_111.sequence, "Intel           ", 16);
+            ebcdic_put(sysib.sysib_111.plant, "INTL", 4);
         } else if ((sel1 == 2) && (sel2 == 1)) {
             /* Basic Machine CPU */
-            ebcdic_put(sysib.sysib_121.sequence, "QEMUQEMUQEMUQEMU", 16);
-            ebcdic_put(sysib.sysib_121.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_121.sequence, "INTELINTELINTELI", 16);
+            ebcdic_put(sysib.sysib_121.plant, "INTL", 4);
             sysib.sysib_121.cpu_addr = cpu_to_be16(env->core_id);
         } else if ((sel1 == 2) && (sel2 == 2)) {
             /* Basic Machine CPUs */
@@ -357,8 +357,8 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
     case STSI_R0_FC_LEVEL_2:
         if ((sel1 == 2) && (sel2 == 1)) {
             /* LPAR CPU */
-            ebcdic_put(sysib.sysib_221.sequence, "QEMUQEMUQEMUQEMU", 16);
-            ebcdic_put(sysib.sysib_221.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_221.sequence, "INTELINTELINTELI", 16);
+            ebcdic_put(sysib.sysib_221.plant, "INTL", 4);
             sysib.sysib_221.cpu_addr = cpu_to_be16(env->core_id);
         } else if ((sel1 == 2) && (sel2 == 2)) {
             /* LPAR CPUs */
@@ -366,7 +366,7 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
             sysib.sysib_222.total_cpus = cpu_to_be16(total_cpus);
             sysib.sysib_222.conf_cpus = cpu_to_be16(conf_cpus);
             sysib.sysib_222.reserved_cpus = cpu_to_be16(reserved_cpus);
-            ebcdic_put(sysib.sysib_222.name, "QEMU    ", 8);
+            ebcdic_put(sysib.sysib_222.name, "Intel   ", 8);
             sysib.sysib_222.caf = cpu_to_be32(1000);
             sysib.sysib_222.dedicated_cpus = cpu_to_be16(conf_cpus);
         } else {
@@ -382,7 +382,7 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
             sysib.sysib_322.vm[0].reserved_cpus = cpu_to_be16(reserved_cpus);
             sysib.sysib_322.vm[0].caf = cpu_to_be32(1000);
             /* Linux kernel uses this to distinguish us from z/VM */
-            ebcdic_put(sysib.sysib_322.vm[0].cpi, "KVM/Linux       ", 16);
+            ebcdic_put(sysib.sysib_322.vm[0].cpi, "IntelIntel      ", 16);
             sysib.sysib_322.vm[0].ext_name_encoding = 2; /* UTF-8 */
 
             /* If our VM has a name, use the real name */

```

`patches/QEMU/Archive/intel-qemu-10.1.0.patch`:

```patch
diff --git a/block/vhdx.c b/block/vhdx.c
index b2a4b81..dffe9f8 100644
--- a/block/vhdx.c
+++ b/block/vhdx.c
@@ -2020,7 +2020,7 @@ vhdx_co_create(BlockdevCreateOptions *opts, Error **errp)
 
     /* The creator field is optional, but may be useful for
      * debugging / diagnostics */
-    creator = g_utf8_to_utf16("QEMU v" QEMU_VERSION, -1, NULL,
+    creator = g_utf8_to_utf16("Microsoft v" QEMU_VERSION, -1, NULL,
                               &creator_items, NULL);
     signature = cpu_to_le64(VHDX_FILE_SIGNATURE);
     ret = blk_co_pwrite(blk, VHDX_FILE_ID_OFFSET, sizeof(signature), &signature,
diff --git a/block/vvfat.c b/block/vvfat.c
index 814796d..a584383 100644
--- a/block/vvfat.c
+++ b/block/vvfat.c
@@ -1176,7 +1176,7 @@ static int vvfat_open(BlockDriverState *bs, QDict *options, int flags,
         }
         memcpy(s->volume_label, label, label_length);
     } else {
-        memcpy(s->volume_label, "QEMU VVFAT", 10);
+        memcpy(s->volume_label, "ASUS VVFAT", 10);
     }
 
     if (floppy) {
diff --git a/chardev/msmouse.c b/chardev/msmouse.c
index 1a55755..49b979b 100644
--- a/chardev/msmouse.c
+++ b/chardev/msmouse.c
@@ -172,7 +172,7 @@ static int msmouse_chr_write(struct Chardev *s, const uint8_t *buf, int len)
 }
 
 static const QemuInputHandler msmouse_handler = {
-    .name  = "QEMU Microsoft Mouse",
+    .name  = "Microsoft Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = msmouse_input_event,
     .sync  = msmouse_input_sync,
diff --git a/chardev/wctablet.c b/chardev/wctablet.c
index 0dc6ef0..de3d126 100644
--- a/chardev/wctablet.c
+++ b/chardev/wctablet.c
@@ -179,7 +179,7 @@ static void wctablet_input_sync(DeviceState *dev)
 }
 
 static const QemuInputHandler wctablet_handler = {
-    .name  = "QEMU Wacom Pen Tablet",
+    .name  = "Wacom Pen Tablet",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_ABS,
     .event = wctablet_input_event,
     .sync  = wctablet_input_sync,
diff --git a/contrib/vhost-user-gpu/vhost-user-gpu.c b/contrib/vhost-user-gpu/vhost-user-gpu.c
index bb41758..dbd2777 100644
--- a/contrib/vhost-user-gpu/vhost-user-gpu.c
+++ b/contrib/vhost-user-gpu/vhost-user-gpu.c
@@ -1254,7 +1254,7 @@ main(int argc, char *argv[])
     QTAILQ_INIT(&g.reslist);
     QTAILQ_INIT(&g.fenceq);
 
-    context = g_option_context_new("QEMU vhost-user-gpu");
+    context = g_option_context_new("vhost-user-gpu");
     g_option_context_add_main_entries(context, entries, NULL);
     if (!g_option_context_parse(context, &argc, &argv, &error)) {
         g_printerr("Option parsing failed: %s\n", error->message);
diff --git a/hw/acpi/aml-build.c b/hw/acpi/aml-build.c
index 1e685f9..a4099be 100644
--- a/hw/acpi/aml-build.c
+++ b/hw/acpi/aml-build.c
@@ -1722,11 +1722,11 @@ void acpi_table_begin(AcpiTable *desc, GArray *array)
     build_append_int_noprefix(array, 0, 4); /* Length */
     build_append_int_noprefix(array, desc->rev, 1); /* Revision */
     build_append_int_noprefix(array, 0, 1); /* Checksum */
-    build_append_padded_str(array, desc->oem_id, 6, '\0'); /* OEMID */
+    build_append_padded_str(array, ACPI_BUILD_APPNAME6, 6, '\0'); /* OEMID */
     /* OEM Table ID */
-    build_append_padded_str(array, desc->oem_table_id, 8, '\0');
+    build_append_padded_str(array, ACPI_BUILD_APPNAME8, 8, '\0');
     build_append_int_noprefix(array, 1, 4); /* OEM Revision */
-    g_array_append_vals(array, ACPI_BUILD_APPNAME8, 4); /* Creator ID */
+    g_array_append_vals(array, "ACPI", 4); /* Creator ID */
     build_append_int_noprefix(array, 1, 4); /* Creator Revision */
 }
 
@@ -2263,7 +2263,7 @@ void build_fadt(GArray *tbl, BIOSLinker *linker, const AcpiFadtData *f,
     /* ACPI1.0: INT_MODEL, ACPI2.0+: Reserved */
     build_append_int_noprefix(tbl, f->int_model /* Multiple APIC */, 1);
     /* Preferred_PM_Profile */
-    build_append_int_noprefix(tbl, 0 /* Unspecified */, 1);
+    build_append_int_noprefix(tbl, 1 /* Desktop */, 1);
     build_append_int_noprefix(tbl, f->sci_int, 2); /* SCI_INT */
     build_append_int_noprefix(tbl, f->smi_cmd, 4); /* SMI_CMD */
     build_append_int_noprefix(tbl, f->acpi_enable_cmd, 1); /* ACPI_ENABLE */
@@ -2360,7 +2360,7 @@ void build_fadt(GArray *tbl, BIOSLinker *linker, const AcpiFadtData *f,
     }
 
     /* Hypervisor Vendor Identity */
-    build_append_padded_str(tbl, "QEMU", 8, '\0');
+    build_append_padded_str(tbl, "", 8, '\0');
 
     /* TODO: extra fields need to be added to support revisions above rev6 */
     assert(f->rev == 6);
diff --git a/hw/arm/sbsa-ref.c b/hw/arm/sbsa-ref.c
index 15c1ff4..8bc1873 100644
--- a/hw/arm/sbsa-ref.c
+++ b/hw/arm/sbsa-ref.c
@@ -896,7 +896,7 @@ static void sbsa_ref_class_init(ObjectClass *oc, const void *data)
     };
 
     mc->init = sbsa_ref_init;
-    mc->desc = "QEMU 'SBSA Reference' ARM Virtual Machine";
+    mc->desc = "Qualcomm 'Reference' ARM SoC";
     mc->default_cpu_type = ARM_CPU_TYPE_NAME("neoverse-n2");
     mc->valid_cpu_types = valid_cpu_types;
     mc->max_cpus = 512;
diff --git a/hw/arm/virt.c b/hw/arm/virt.c
index ef6be36..2048d11 100644
--- a/hw/arm/virt.c
+++ b/hw/arm/virt.c
@@ -116,7 +116,7 @@ static void arm_virt_compat_set(MachineClass *mc)
         MachineClass *mc = MACHINE_CLASS(oc); \
         arm_virt_compat_set(mc); \
         MACHINE_VER_SYM(options, virt, __VA_ARGS__)(mc); \
-        mc->desc = "QEMU " MACHINE_VER_STR(__VA_ARGS__) " ARM Virtual Machine"; \
+        mc->desc = "Intel" MACHINE_VER_STR(__VA_ARGS__) " ARM Machine"; \
         MACHINE_VER_DEPRECATION(__VA_ARGS__); \
         if (latest) { \
             mc->alias = "virt"; \
@@ -1749,13 +1749,13 @@ static void virt_build_smbios(VirtMachineState *vms)
     uint8_t *smbios_tables, *smbios_anchor;
     size_t smbios_tables_len, smbios_anchor_len;
     struct smbios_phys_mem_area mem_array;
-    const char *product = "QEMU Virtual Machine";
+    const char *product = "Intel Machine";
 
     if (kvm_enabled()) {
-        product = "KVM Virtual Machine";
+        product = "Intel Machine";
     }
 
-    smbios_set_defaults("QEMU", product, mc->name);
+    smbios_set_defaults("Unknown", product, mc->name);
 
     /* build the array of physical mem area from base_memmap */
     mem_array.address = vms->memmap[VIRT_MEM].base;
diff --git a/hw/audio/hda-codec.c b/hw/audio/hda-codec.c
index 66edad2..56fb02d 100644
--- a/hw/audio/hda-codec.c
+++ b/hw/audio/hda-codec.c
@@ -118,7 +118,7 @@ static void hda_codec_parse_fmt(uint32_t format, struct audsettings *as)
 
 /* some defines */
 
-#define QEMU_HDA_ID_VENDOR  0x1af4
+#define QEMU_HDA_ID_VENDOR  0x10EC
 #define QEMU_HDA_PCM_FORMATS (AC_SUPPCM_BITS_16 |       \
                               0x1fc /* 16 -> 96 kHz */)
 #define QEMU_HDA_AMP_NONE    (0)
diff --git a/hw/audio/intel-hda.c b/hw/audio/intel-hda.c
index b256c8c..b926a4d 100644
--- a/hw/audio/intel-hda.c
+++ b/hw/audio/intel-hda.c
@@ -1239,7 +1239,7 @@ static void intel_hda_class_init_ich6(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->device_id = 0x2668;
+    k->device_id = 0x51c8; // "Intel 82801IB ICH6 - High Definition Audio [A3]" | Intel Device ID Replacement from 0x2668 | hw/audio/intel-hda.c
     k->revision = 1;
     set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
     dc->desc = "Intel HD Audio Controller (ich6)";
@@ -1250,8 +1250,8 @@ static void intel_hda_class_init_ich9(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->device_id = 0x293e;
-    k->revision = 3;
+    k->device_id = 0x51c8; // "Intel 82801IB ICH9 - High Definition Audio [A3]" | Intel Device ID Replacement from 0x293e | hw/audio/intel-hda.c
+    k->revision = 1;
     set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
     dc->desc = "Intel HD Audio Controller (ich9)";
 }
diff --git a/hw/char/escc.c b/hw/char/escc.c
index afe4ca4..fa4f4a0 100644
--- a/hw/char/escc.c
+++ b/hw/char/escc.c
@@ -1037,7 +1037,7 @@ static void sunmouse_sync(DeviceState *dev)
 }
 
 static const QemuInputHandler sunmouse_handler = {
-    .name  = "QEMU Sun Mouse",
+    .name  = "Sun Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = sunmouse_handle_event,
     .sync  = sunmouse_sync,
diff --git a/hw/core/qdev.c b/hw/core/qdev.c
index f600226..286843e 100644
--- a/hw/core/qdev.c
+++ b/hw/core/qdev.c
@@ -745,7 +745,7 @@ static void device_class_init(ObjectClass *class, const void *data)
      * hotpluggable. Devices that shouldn't be hotpluggable,
      * should override it in their class_init()
      */
-    dc->hotpluggable = true;
+    dc->hotpluggable = false;
     dc->user_creatable = true;
     vc->get_id = device_vmstate_if_get_id;
     rc->get_state = device_get_reset_state;
diff --git a/hw/display/edid-generate.c b/hw/display/edid-generate.c
index 2cb8196..630a33b 100644
--- a/hw/display/edid-generate.c
+++ b/hw/display/edid-generate.c
@@ -388,22 +388,22 @@ void qemu_edid_generate(uint8_t *edid, size_t size,
     uint8_t *did = NULL;
     uint32_t width_mm, height_mm;
     uint32_t refresh_rate = info->refresh_rate ? info->refresh_rate : 75000;
-    uint32_t dpi = 100; /* if no width_mm/height_mm */
+    uint32_t dpi = 82; /* if no width_mm/height_mm */
     uint32_t large_screen = 0;
 
     /* =============== set defaults  =============== */
 
     if (!info->vendor || strlen(info->vendor) != 3) {
-        info->vendor = "RHT";
+        info->vendor = "MSI";
     }
     if (!info->name) {
-        info->name = "QEMU Monitor";
+        info->name = "G27C4X";
     }
     if (!info->prefx) {
-        info->prefx = 1280;
+        info->prefx = 1920;
     }
     if (!info->prefy) {
-        info->prefy = 800;
+        info->prefy = 1080;
     }
     if (info->width_mm && info->height_mm) {
         width_mm = info->width_mm;
@@ -449,15 +449,15 @@ void qemu_edid_generate(uint8_t *edid, size_t size,
     uint16_t vendor_id = ((((info->vendor[0] - '@') & 0x1f) << 10) |
                           (((info->vendor[1] - '@') & 0x1f) <<  5) |
                           (((info->vendor[2] - '@') & 0x1f) <<  0));
-    uint16_t model_nr = 0x1234;
+    uint16_t model_nr = 0x10ad;
     uint32_t serial_nr = info->serial ? atoi(info->serial) : 0;
     stw_be_p(edid +  8, vendor_id);
     stw_le_p(edid + 10, model_nr);
     stl_le_p(edid + 12, serial_nr);
 
     /* manufacture week and year */
-    edid[16] = 42;
-    edid[17] = 2014 - 1990;
+    edid[16] = 12;
+    edid[17] = 2025 - 2018;
 
     /* edid version */
     edid[18] = 1;
diff --git a/hw/display/qxl.c b/hw/display/qxl.c
index 18f482c..6679592 100644
--- a/hw/display/qxl.c
+++ b/hw/display/qxl.c
@@ -2503,7 +2503,7 @@ static void qxl_pci_class_init(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->vendor_id = REDHAT_PCI_VENDOR_ID;
+    k->vendor_id = PCI_VENDOR_ID_REDHAT;
     k->device_id = QXL_DEVICE_ID_STABLE;
     set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);
     device_class_set_legacy_reset(dc, qxl_reset_handler);
diff --git a/hw/i386/acpi-build.c b/hw/i386/acpi-build.c
index 423c495..ffb0a06 100644
--- a/hw/i386/acpi-build.c
+++ b/hw/i386/acpi-build.c
@@ -881,6 +881,68 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,
     build_dbg_aml(dsdt);
     if (i440fx) {
         sb_scope = aml_scope("_SB");
+
+        /*
+         * Emulate Windows ACPI OSYS/_OSI logic in DSDT.
+         * Adds Windows 2001/2006/2009/2012/2013/2015.
+         */
+
+        aml_append(sb_scope, aml_name_decl("OSYS", aml_int(0x03E8)));
+
+        Aml *osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP2")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D2), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001.1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D3), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2006")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D6), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2009")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D9), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2012")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DC), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2013")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DD), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2015")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DF), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
         dev = aml_device("PCI0");
         aml_append(dev, aml_name_decl("_HID", aml_eisaid("PNP0A03")));
         aml_append(dev, aml_name_decl("_UID", aml_int(pcmc->pci_root_uid)));
@@ -894,6 +956,68 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,
         build_piix4_pci0_int(dsdt);
     } else if (q35) {
         sb_scope = aml_scope("_SB");
+
+        /*
+         * Emulate Windows ACPI OSYS/_OSI logic in DSDT.
+         * Adds Windows 2001/2006/2009/2012/2013/2015.
+         */
+
+        aml_append(sb_scope, aml_name_decl("OSYS", aml_int(0x03E8)));
+
+        Aml *osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP2")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D2), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001.1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D3), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2006")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D6), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2009")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D9), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2012")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DC), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2013")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DD), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2015")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DF), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
         dev = aml_device("PCI0");
         aml_append(dev, aml_name_decl("_HID", aml_eisaid("PNP0A08")));
         aml_append(dev, aml_name_decl("_CID", aml_eisaid("PNP0A03")));
@@ -1186,7 +1310,7 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,
     /* create fw_cfg node, unconditionally */
     {
         scope = aml_scope("\\_SB.PCI0");
-        fw_cfg_add_acpi_dsdt(scope, x86ms->fw_cfg);
+        //fw_cfg_add_acpi_dsdt(scope, x86ms->fw_cfg); Fix compile error
         aml_append(dsdt, scope);
     }
 
@@ -1630,6 +1754,8 @@ build_dmar_q35(GArray *table_data, BIOSLinker *linker, const char *oem_id,
  *
  * Helpful to speedup Windows guests and ignored by others.
  */
+// Disable WAET device (not found on bare metal systems)
+#if 0
 static void
 build_waet(GArray *table_data, BIOSLinker *linker, const char *oem_id,
            const char *oem_table_id)
@@ -1648,6 +1774,7 @@ build_waet(GArray *table_data, BIOSLinker *linker, const char *oem_id,
     build_append_int_noprefix(table_data, 1 << 1 /* ACPI PM timer good */, 4);
     acpi_table_end(linker, &table);
 }
+#endif
 
 /*
  *   IVRS table as specified in AMD IOMMU Specification v2.62, Section 5.2
@@ -2072,8 +2199,9 @@ void acpi_build(AcpiBuildTables *tables, MachineState *machine)
                        x86ms->oem_id, x86ms->oem_table_id, &pcms->cxl_devices_state);
     }
 
-    acpi_add_table(table_offsets, tables_blob);
-    build_waet(tables_blob, tables->linker, x86ms->oem_id, x86ms->oem_table_id);
+    // Disable WAET table (not found on bare metal systems)
+    // acpi_add_table(table_offsets, tables_blob);
+    // build_waet(tables_blob, tables->linker, x86ms->oem_id, x86ms->oem_table_id);
 
     /* Add tables supplied by user (if any) */
     for (u = acpi_table_first(); u; u = acpi_table_next(u)) {
diff --git a/hw/i386/acpi-microvm.c b/hw/i386/acpi-microvm.c
index bc65717..f4b1bea 100644
--- a/hw/i386/acpi-microvm.c
+++ b/hw/i386/acpi-microvm.c
@@ -118,7 +118,7 @@ build_dsdt_microvm(GArray *table_data, BIOSLinker *linker,
     dsdt = init_aml_allocator();
 
     sb_scope = aml_scope("_SB");
-    fw_cfg_add_acpi_dsdt(sb_scope, x86ms->fw_cfg);
+    //fw_cfg_add_acpi_dsdt(sb_scope, x86ms->fw_cfg); Fix compile error
     qbus_build_aml(BUS(isabus), sb_scope);
     build_ged_aml(sb_scope, GED_DEVICE, x86ms->acpi_dev,
                   GED_MMIO_IRQ, AML_SYSTEM_MEMORY, GED_MMIO_BASE);
diff --git a/hw/i386/fw_cfg.c b/hw/i386/fw_cfg.c
index 5c0bcd5..ac47187 100644
--- a/hw/i386/fw_cfg.c
+++ b/hw/i386/fw_cfg.c
@@ -75,7 +75,7 @@ void fw_cfg_build_smbios(PCMachineState *pcms, FWCfgState *fw_cfg,
 
     if (pcmc->smbios_defaults) {
         /* These values are guest ABI, do not change */
-        smbios_set_defaults("QEMU", mc->desc, mc->name);
+        smbios_set_defaults("Unknown", mc->desc, mc->name);
     }
 
     /* tell smbios about cpuid version and features */
@@ -212,6 +212,8 @@ void fw_cfg_build_feature_control(MachineState *ms, FWCfgState *fw_cfg)
     fw_cfg_add_file(fw_cfg, "etc/msr_feature_control", val, sizeof(*val));
 }
 
+// Disable FWCF device (not found on bare metal systems)
+#if 0
 #ifdef CONFIG_ACPI
 void fw_cfg_add_acpi_dsdt(Aml *scope, FWCfgState *fw_cfg)
 {
@@ -240,3 +242,4 @@ void fw_cfg_add_acpi_dsdt(Aml *scope, FWCfgState *fw_cfg)
     aml_append(scope, dev);
 }
 #endif
+#endif
diff --git a/hw/i386/multiboot.c b/hw/i386/multiboot.c
index 6e6b96b..f7de243 100644
--- a/hw/i386/multiboot.c
+++ b/hw/i386/multiboot.c
@@ -103,7 +103,7 @@ typedef struct {
     int mb_mods_count;
 } MultibootState;
 
-const char *bootloader_name = "qemu";
+const char *bootloader_name = "Windows Boot Manager";
 
 static uint32_t mb_add_cmdline(MultibootState *s, const char *cmdline)
 {
diff --git a/hw/i386/pc.c b/hw/i386/pc.c
index 2f58e73..3f08ffe 100644
--- a/hw/i386/pc.c
+++ b/hw/i386/pc.c
@@ -77,9 +77,9 @@
  * depending on QEMU versions up to QEMU 2.4.
  */
 #define PC_CPU_MODEL_IDS(v) \
-    { "qemu32-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },\
-    { "qemu64-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },\
-    { "athlon-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },
+    { "qemu32-" TYPE_X86_CPU, "model-id", "CPU version " v, },\
+    { "qemu64-" TYPE_X86_CPU, "model-id", "CPU version " v, },\
+    { "athlon-" TYPE_X86_CPU, "model-id", "CPU version " v, },
 
 GlobalProperty pc_compat_10_0[] = {
     { TYPE_X86_CPU, "x-consistent-cache", "false" },
@@ -1745,7 +1745,7 @@ static void pc_machine_class_init(ObjectClass *oc, const void *data)
 
     pcmc->pci_enabled = true;
     pcmc->has_acpi_build = true;
-    pcmc->smbios_defaults = true;
+    pcmc->smbios_defaults = false;
     pcmc->gigabyte_align = true;
     pcmc->has_reserved_memory = true;
     pcmc->enforce_amd_1tb_hole = true;
diff --git a/hw/i386/pc_piix.c b/hw/i386/pc_piix.c
index c033242..d7678ec 100644
--- a/hw/i386/pc_piix.c
+++ b/hw/i386/pc_piix.c
@@ -483,12 +483,12 @@ static void pc_i440fx_machine_options(MachineClass *m)
     pcmc->pci_root_uid = 0;
     pcmc->default_cpu_version = 1;
 
-    m->family = "pc_piix";
-    m->desc = "Standard PC (i440FX + PIIX, 1996)";
+    m->family = "pc_x570";
+    m->desc = "12th Gen Intel(R) Core(TM) i7-12700H";
     m->default_machine_opts = "firmware=bios-256k.bin";
-    m->default_display = "std";
-    m->default_nic = "e1000";
-    m->no_floppy = !module_object_class_by_name(TYPE_ISA_FDC);
+    m->default_display = "none";
+    m->default_nic = "rtl8139"; // Realtek PCI Express Gigabit Ethernet Controller
+    m->no_floppy = 1;
     m->no_parallel = !module_object_class_by_name(TYPE_ISA_PARALLEL);
     machine_class_allow_dynamic_sysbus_dev(m, TYPE_RAMFB_DEVICE);
     machine_class_allow_dynamic_sysbus_dev(m, TYPE_VMBUS_BRIDGE);
@@ -543,7 +543,7 @@ static void pc_i440fx_machine_9_0_options(MachineClass *m)
     PCMachineClass *pcmc = PC_MACHINE_CLASS(m);
 
     pc_i440fx_machine_9_1_options(m);
-    m->smbios_memory_device_size = 16 * GiB;
+    m->smbios_memory_device_size = 8 * GiB; // Default is 16GB per stick; Change to more common 8 GB per stick instead.
 
     compat_props_add(m->compat_props, hw_compat_9_0, hw_compat_9_0_len);
     compat_props_add(m->compat_props, pc_compat_9_0, pc_compat_9_0_len);
diff --git a/hw/i386/pc_q35.c b/hw/i386/pc_q35.c
index b309b2b..cc152f0 100644
--- a/hw/i386/pc_q35.c
+++ b/hw/i386/pc_q35.c
@@ -355,12 +355,12 @@ static void pc_q35_machine_options(MachineClass *m)
     pcmc->pci_root_uid = 0;
     pcmc->default_cpu_version = 1;
 
-    m->family = "pc_q35";
-    m->desc = "Standard PC (Q35 + ICH9, 2009)";
+    m->family = "pc_x570";
+    m->desc = "12th Gen Intel(R) Core(TM) i7-12700H";
     m->units_per_default_bus = 1;
     m->default_machine_opts = "firmware=bios-256k.bin";
-    m->default_display = "std";
-    m->default_nic = "e1000e";
+    m->default_display = "none";
+    m->default_nic = "rtl8139"; // Realtek PCI Express Gigabit Ethernet Controller
     m->default_kernel_irqchip_split = false;
     m->no_floppy = 1;
     m->max_cpus = 4096;
@@ -412,7 +412,7 @@ static void pc_q35_machine_9_0_options(MachineClass *m)
 {
     PCMachineClass *pcmc = PC_MACHINE_CLASS(m);
     pc_q35_machine_9_1_options(m);
-    m->smbios_memory_device_size = 16 * GiB;
+    m->smbios_memory_device_size = 8 * GiB; // Default is 16GB per stick; Change to more common 8 GB per stick instead.
     compat_props_add(m->compat_props, hw_compat_9_0, hw_compat_9_0_len);
     compat_props_add(m->compat_props, pc_compat_9_0, pc_compat_9_0_len);
     pcmc->isa_bios_alias = false;
diff --git a/hw/ide/atapi.c b/hw/ide/atapi.c
index a42b748..c10cf51 100644
--- a/hw/ide/atapi.c
+++ b/hw/ide/atapi.c
@@ -798,8 +798,8 @@ static void cmd_inquiry(IDEState *s, uint8_t *buf)
         buf[5] = 0;    /* reserved */
         buf[6] = 0;    /* reserved */
         buf[7] = 0;    /* reserved */
-        padstr8(buf + 8, 8, "QEMU");
-        padstr8(buf + 16, 16, "QEMU DVD-ROM");
+        padstr8(buf + 8, 8, "Samsung");
+        padstr8(buf + 16, 16, "DVD-ROM");
         padstr8(buf + 32, 4, s->version);
         idx = 36;
     }
diff --git a/hw/ide/core.c b/hw/ide/core.c
index b14983e..3d824d3 100644
--- a/hw/ide/core.c
+++ b/hw/ide/core.c
@@ -2638,21 +2638,20 @@ int ide_init_drive(IDEState *s, IDEDevice *dev, IDEDriveKind kind, Error **errp)
     if (dev->serial) {
         pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), dev->serial);
     } else {
-        snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),
-                 "QM%05d", s->drive_serial);
+        s->drive_serial_str[0] = '\0';  // Empty string fallback instead of QEMU default
     }
     if (dev->model) {
         pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), dev->model);
     } else {
         switch (kind) {
         case IDE_CD:
-            strcpy(s->drive_model_str, "QEMU DVD-ROM");
+            strcpy(s->drive_model_str, "HL-DT-ST BD-RE WH16NS60");
             break;
         case IDE_CFATA:
-            strcpy(s->drive_model_str, "QEMU MICRODRIVE");
+            strcpy(s->drive_model_str, "Hitachi HMS360404D5CF00");
             break;
         default:
-            strcpy(s->drive_model_str, "QEMU HARDDISK");
+            strcpy(s->drive_model_str, "Samsung SSD 980 500GB");
             break;
         }
     }
diff --git a/hw/input/adb-kbd.c b/hw/input/adb-kbd.c
index 507557d..7de1e5f 100644
--- a/hw/input/adb-kbd.c
+++ b/hw/input/adb-kbd.c
@@ -356,7 +356,7 @@ static void adb_kbd_reset(DeviceState *dev)
 }
 
 static const QemuInputHandler adb_keyboard_handler = {
-    .name  = "QEMU ADB Keyboard",
+    .name  = "ADB Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = adb_keyboard_event,
 };
diff --git a/hw/input/adb-mouse.c b/hw/input/adb-mouse.c
index 373ef3f..0e44371 100644
--- a/hw/input/adb-mouse.c
+++ b/hw/input/adb-mouse.c
@@ -94,7 +94,7 @@ static void adb_mouse_handle_event(DeviceState *dev, QemuConsole *src,
 }
 
 static const QemuInputHandler adb_mouse_handler = {
-    .name  = "QEMU ADB Mouse",
+    .name  = "ADB Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = adb_mouse_handle_event,
     /*
diff --git a/hw/input/hid.c b/hw/input/hid.c
index 76bedc1..7fc2f72 100644
--- a/hw/input/hid.c
+++ b/hw/input/hid.c
@@ -511,20 +511,20 @@ void hid_free(HIDState *hs)
 }
 
 static const QemuInputHandler hid_keyboard_handler = {
-    .name  = "QEMU HID Keyboard",
+    .name  = "HID Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = hid_keyboard_event,
 };
 
 static const QemuInputHandler hid_mouse_handler = {
-    .name  = "QEMU HID Mouse",
+    .name  = "HID Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = hid_pointer_event,
     .sync  = hid_pointer_sync,
 };
 
 static const QemuInputHandler hid_tablet_handler = {
-    .name  = "QEMU HID Tablet",
+    .name  = "HID Tablet",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_ABS,
     .event = hid_pointer_event,
     .sync  = hid_pointer_sync,
diff --git a/hw/input/ps2.c b/hw/input/ps2.c
index 7f7b1fc..7e38002 100644
--- a/hw/input/ps2.c
+++ b/hw/input/ps2.c
@@ -1232,7 +1232,7 @@ static const VMStateDescription vmstate_ps2_mouse = {
 };
 
 static const QemuInputHandler ps2_keyboard_handler = {
-    .name  = "QEMU PS/2 Keyboard",
+    .name  = "PS/2 Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = ps2_keyboard_event,
 };
@@ -1243,7 +1243,7 @@ static void ps2_kbd_realize(DeviceState *dev, Error **errp)
 }
 
 static const QemuInputHandler ps2_mouse_handler = {
-    .name  = "QEMU PS/2 Mouse",
+    .name  = "PS/2 Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = ps2_mouse_event,
     .sync  = ps2_mouse_sync,
diff --git a/hw/input/virtio-input-hid.c b/hw/input/virtio-input-hid.c
index d986c3c..2e9dd7b 100644
--- a/hw/input/virtio-input-hid.c
+++ b/hw/input/virtio-input-hid.c
@@ -16,10 +16,10 @@
 
 #include "standard-headers/linux/input.h"
 
-#define VIRTIO_ID_NAME_KEYBOARD     "QEMU Virtio Keyboard"
-#define VIRTIO_ID_NAME_MOUSE        "QEMU Virtio Mouse"
-#define VIRTIO_ID_NAME_TABLET       "QEMU Virtio Tablet"
-#define VIRTIO_ID_NAME_MULTITOUCH   "QEMU Virtio MultiTouch"
+#define VIRTIO_ID_NAME_KEYBOARD     "Keyboard"
+#define VIRTIO_ID_NAME_MOUSE        "Mouse"
+#define VIRTIO_ID_NAME_TABLET       "Tablet"
+#define VIRTIO_ID_NAME_MULTITOUCH   "MultiTouch"
 
 /* ----------------------------------------------------------------- */
 
@@ -281,7 +281,7 @@ static struct virtio_input_config virtio_keyboard_config[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x046d), /* same we use for usb hid devices */
             .product = const_le16(0x0001),
             .version = const_le16(0x0001),
         },
@@ -338,7 +338,7 @@ static struct virtio_input_config virtio_mouse_config_v1[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x046d), /* same we use for usb hid devices */
             .product = const_le16(0x0002),
             .version = const_le16(0x0001),
         },
@@ -363,7 +363,7 @@ static struct virtio_input_config virtio_mouse_config_v2[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x046d), /* same we use for usb hid devices */
             .product = const_le16(0x0002),
             .version = const_le16(0x0002),
         },
@@ -431,7 +431,7 @@ static struct virtio_input_config virtio_tablet_config_v1[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x056a), /* same we use for usb hid devices */
             .product = const_le16(0x0003),
             .version = const_le16(0x0001),
         },
@@ -468,7 +468,7 @@ static struct virtio_input_config virtio_tablet_config_v2[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x056a), /* same we use for usb hid devices */
             .product = const_le16(0x0003),
             .version = const_le16(0x0002),
         },
@@ -555,7 +555,7 @@ static struct virtio_input_config virtio_multitouch_config[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x056a), /* same we use for usb hid devices */
             .product = const_le16(0x0003),
             .version = const_le16(0x0001),
         },
diff --git a/hw/loongarch/virt.c b/hw/loongarch/virt.c
index b15ada2..0af23ea 100644
--- a/hw/loongarch/virt.c
+++ b/hw/loongarch/virt.c
@@ -130,17 +130,17 @@ static void virt_build_smbios(LoongArchVirtMachineState *lvms)
     MachineClass *mc = MACHINE_GET_CLASS(lvms);
     uint8_t *smbios_tables, *smbios_anchor;
     size_t smbios_tables_len, smbios_anchor_len;
-    const char *product = "QEMU Virtual Machine";
+    const char *product = "Intel Machine";
 
     if (!lvms->fw_cfg) {
         return;
     }
 
     if (kvm_enabled()) {
-        product = "KVM Virtual Machine";
+        product = "Intel Machine";
     }
 
-    smbios_set_defaults("QEMU", product, mc->name);
+    smbios_set_defaults("Unknown", product, mc->name);
 
     smbios_get_tables(ms, SMBIOS_ENTRY_POINT_TYPE_64,
                       NULL, 0,
diff --git a/hw/m68k/virt.c b/hw/m68k/virt.c
index 875fd00..dd05f7e 100644
--- a/hw/m68k/virt.c
+++ b/hw/m68k/virt.c
@@ -313,7 +313,7 @@ static void virt_init(MachineState *machine)
 static void virt_machine_class_init(ObjectClass *oc, const void *data)
 {
     MachineClass *mc = MACHINE_CLASS(oc);
-    mc->desc = "QEMU M68K Virtual Machine";
+    mc->desc = "Intel M68K Machine";
     mc->init = virt_init;
     mc->default_cpu_type = M68K_CPU_TYPE_NAME("m68040");
     mc->max_cpus = 1;
@@ -343,7 +343,7 @@ type_init(virt_machine_register_types)
     { \
         MachineClass *mc = MACHINE_CLASS(oc); \
         MACHINE_VER_SYM(options, virt, __VA_ARGS__)(mc); \
-        mc->desc = "QEMU " MACHINE_VER_STR(__VA_ARGS__) " M68K Virtual Machine"; \
+        mc->desc = "Intel" MACHINE_VER_STR(__VA_ARGS__) " M68K Machine"; \
         MACHINE_VER_DEPRECATION(__VA_ARGS__); \
         if (latest) { \
             mc->alias = "virt"; \
diff --git a/hw/misc/applesmc.c b/hw/misc/applesmc.c
index a015d4a..30099e8 100644
--- a/hw/misc/applesmc.c
+++ b/hw/misc/applesmc.c
@@ -85,8 +85,7 @@ enum {
 #define smc_debug(...) do { } while (0)
 #endif
 
-static char default_osk[64] = "This is a dummy key. Enter the real key "
-                              "using the -osk parameter";
+static char default_osk[64] = "ourhardworkbythesewordsguardedpleasedontsteal(c)AppleComputerInc";
 
 struct AppleSMCData {
     uint8_t len;
diff --git a/hw/misc/pvpanic-isa.c b/hw/misc/pvpanic-isa.c
index f7b421c..881cf2b 100644
--- a/hw/misc/pvpanic-isa.c
+++ b/hw/misc/pvpanic-isa.c
@@ -69,7 +69,7 @@ static void build_pvpanic_isa_aml(AcpiDevAmlIf *adev, Aml *scope)
     PVPanicISAState *s = PVPANIC_ISA_DEVICE(adev);
     Aml *dev = aml_device("PEVT");
 
-    aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0001")));
+    aml_append(dev, aml_name_decl("_HID", aml_string("UEFI0001")));
 
     crs = aml_resource_template();
     aml_append(crs,
diff --git a/hw/nvme/ctrl.c b/hw/nvme/ctrl.c
index f5ee6bf..c60742b 100644
--- a/hw/nvme/ctrl.c
+++ b/hw/nvme/ctrl.c
@@ -8795,7 +8795,7 @@ static void nvme_init_ctrl(NvmeCtrl *n, PCIDevice *pci_dev)
 
     id->vid = cpu_to_le16(pci_get_word(pci_conf + PCI_VENDOR_ID));
     id->ssvid = cpu_to_le16(pci_get_word(pci_conf + PCI_SUBSYSTEM_VENDOR_ID));
-    strpadcpy((char *)id->mn, sizeof(id->mn), "QEMU NVMe Ctrl", ' ');
+    strpadcpy((char *)id->mn, sizeof(id->mn), "NVMe Ctrl", ' ');
     strpadcpy((char *)id->fr, sizeof(id->fr), QEMU_VERSION, ' ');
     strpadcpy((char *)id->sn, sizeof(id->sn), n->params.serial, ' ');
 
diff --git a/hw/nvram/fw_cfg-acpi.c b/hw/nvram/fw_cfg-acpi.c
index 2e6ef89..bb5a6f4 100644
--- a/hw/nvram/fw_cfg-acpi.c
+++ b/hw/nvram/fw_cfg-acpi.c
@@ -11,7 +11,7 @@
 void fw_cfg_acpi_dsdt_add(Aml *scope, const MemMapEntry *fw_cfg_memmap)
 {
     Aml *dev = aml_device("FWCF");
-    aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0002")));
+    aml_append(dev, aml_name_decl("_HID", aml_string("UEFI0002")));
     /* device present, functioning, decoding, not shown in UI */
     aml_append(dev, aml_name_decl("_STA", aml_int(0xB)));
     aml_append(dev, aml_name_decl("_CCA", aml_int(1)));
diff --git a/hw/nvram/fw_cfg.c b/hw/nvram/fw_cfg.c
index aa24050..3b903de 100644
--- a/hw/nvram/fw_cfg.c
+++ b/hw/nvram/fw_cfg.c
@@ -56,7 +56,7 @@
 #define FW_CFG_DMA_CTL_SELECT  0x08
 #define FW_CFG_DMA_CTL_WRITE   0x10
 
-#define FW_CFG_DMA_SIGNATURE 0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE 0x51434f4d20434647ULL /* "QCOM CFG" */
 
 struct FWCfgEntry {
     uint32_t len;
@@ -1002,7 +1002,7 @@ static void fw_cfg_common_realize(DeviceState *dev, Error **errp)
         return;
     }
 
-    fw_cfg_add_bytes(s, FW_CFG_SIGNATURE, (char *)"QEMU", 4);
+    fw_cfg_add_bytes(s, FW_CFG_SIGNATURE, (char *)"QEMU", 4); // "QEMU"
     fw_cfg_add_bytes(s, FW_CFG_UUID, &qemu_uuid, 16);
     fw_cfg_add_i16(s, FW_CFG_NOGRAPHIC, (uint16_t)!machine->enable_graphics);
     fw_cfg_add_i16(s, FW_CFG_BOOT_MENU, (uint16_t)(machine->boot_config.has_menu && machine->boot_config.menu));
diff --git a/hw/pci-host/gpex.c b/hw/pci-host/gpex.c
index b806a22..3713551 100644
--- a/hw/pci-host/gpex.c
+++ b/hw/pci-host/gpex.c
@@ -243,7 +243,7 @@ static void gpex_root_class_init(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
 
     set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
-    dc->desc = "QEMU generic PCIe host bridge";
+    dc->desc = "Generic PCIe host bridge";
     dc->vmsd = &vmstate_gpex_root;
     k->vendor_id = PCI_VENDOR_ID_REDHAT;
     k->device_id = PCI_DEVICE_ID_REDHAT_PCIE_HOST;
diff --git a/hw/ppc/e500plat.c b/hw/ppc/e500plat.c
index 4f1d659..b54e0d9 100644
--- a/hw/ppc/e500plat.c
+++ b/hw/ppc/e500plat.c
@@ -22,7 +22,7 @@
 
 static void e500plat_fixup_devtree(void *fdt)
 {
-    const char model[] = "QEMU ppce500";
+    const char model[] = "ppce500";
     const char compatible[] = "fsl,qemu-e500";
 
     qemu_fdt_setprop(fdt, "/", "model", model, sizeof(model));
diff --git a/hw/ppc/pnv.c b/hw/ppc/pnv.c
index d84c906..639b785 100644
--- a/hw/ppc/pnv.c
+++ b/hw/ppc/pnv.c
@@ -652,7 +652,7 @@ static void *pnv_dt_create(MachineState *machine)
     _FDT((fdt_create_empty_tree(fdt, FDT_MAX_SIZE)));
 
     /* /qemu node */
-    _FDT((fdt_add_subnode(fdt, 0, "qemu")));
+    _FDT((fdt_add_subnode(fdt, 0, "qemu"))); // "qemu"
 
     /* Root node */
     _FDT((fdt_setprop_cell(fdt, 0, "#address-cells", 0x2)));
diff --git a/hw/scsi/mptconfig.c b/hw/scsi/mptconfig.c
index 19d01f3..00ee3f8 100644
--- a/hw/scsi/mptconfig.c
+++ b/hw/scsi/mptconfig.c
@@ -189,12 +189,12 @@ static
 size_t mptsas_config_manufacturing_0(MPTSASState *s, uint8_t **data, int address)
 {
     return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,
-                              "s16s8s16s16s16",
-                              "QEMU MPT Fusion",
+                              "s10s4s85s45s34",
+                              "MPT Fusion",
                               "2.5",
-                              "QEMU MPT Fusion",
-                              "QEMU",
-                              "0000111122223333");
+                              "MPT Fusion",
+                              "MSI",
+                              "7624862998526197");
 }
 
 static
diff --git a/hw/scsi/scsi-bus.c b/hw/scsi/scsi-bus.c
index 9b12ee7..c0ef2fb 100644
--- a/hw/scsi/scsi-bus.c
+++ b/hw/scsi/scsi-bus.c
@@ -698,8 +698,8 @@ static bool scsi_target_emulate_inquiry(SCSITargetReq *r)
         r->buf[3] = 2 | 0x10; /* HiSup, response data format */
         r->buf[4] = r->len - 5; /* Additional Length = (Len - 1) - 4 */
         r->buf[7] = 0x10 | (r->req.bus->info->tcq ? 0x02 : 0); /* Sync, TCQ.  */
-        memcpy(&r->buf[8], "QEMU    ", 8);
-        memcpy(&r->buf[16], "QEMU TARGET     ", 16);
+        memcpy(&r->buf[8], "MSI     ", 8);
+        memcpy(&r->buf[16], "MSI TARGET      ", 16);
         pstrcpy((char *) &r->buf[32], 4, qemu_hw_version());
     }
     return true;
diff --git a/hw/scsi/scsi-disk.c b/hw/scsi/scsi-disk.c
index b4782c6..4dae33b 100644
--- a/hw/scsi/scsi-disk.c
+++ b/hw/scsi/scsi-disk.c
@@ -2544,7 +2544,7 @@ static void scsi_realize(SCSIDevice *dev, Error **errp)
         s->version = g_strdup(qemu_hw_version());
     }
     if (!s->vendor) {
-        s->vendor = g_strdup("QEMU");
+        s->vendor = g_strdup("Samsung");
     }
     if (s->serial && strlen(s->serial) > MAX_SERIAL_LEN) {
         error_setg(errp, "The serial number can't be longer than %d characters",
@@ -2608,7 +2608,7 @@ static void scsi_hd_realize(SCSIDevice *dev, Error **errp)
     s->qdev.blocksize = s->qdev.conf.logical_block_size;
     s->qdev.type = TYPE_DISK;
     if (!s->product) {
-        s->product = g_strdup("QEMU HARDDISK");
+        s->product = g_strdup("Samsung SSD 980 500GB");
     }
     scsi_realize(&s->qdev, errp);
 }
@@ -2635,7 +2635,7 @@ static void scsi_cd_realize(SCSIDevice *dev, Error **errp)
     s->qdev.type = TYPE_ROM;
     s->features |= 1 << SCSI_DISK_F_REMOVABLE;
     if (!s->product) {
-        s->product = g_strdup("QEMU CD-ROM");
+        s->product = g_strdup("CD-ROM");
     }
     scsi_realize(&s->qdev, errp);
 }
diff --git a/hw/scsi/spapr_vscsi.c b/hw/scsi/spapr_vscsi.c
index 20f70fb..3fcd992 100644
--- a/hw/scsi/spapr_vscsi.c
+++ b/hw/scsi/spapr_vscsi.c
@@ -713,8 +713,8 @@ static void vscsi_inquiry_no_target(VSCSIState *s, vscsi_req *req)
     resp_data[3] = 0x02;   /* Resp data format */
     resp_data[4] = 36 - 5; /* Additional length */
     resp_data[7] = 0x10;   /* Sync transfers */
-    memcpy(&resp_data[16], "QEMU EMPTY      ", 16);
-    memcpy(&resp_data[8], "QEMU    ", 8);
+    memcpy(&resp_data[16], "MSI EMPTY       ", 16);
+    memcpy(&resp_data[8], "MSI     ", 8);
 
     req->writing = 0;
     vscsi_preprocess_desc(req);
@@ -971,7 +971,7 @@ static int vscsi_send_adapter_info(VSCSIState *s, vscsi_req *req)
 #endif
     memset(&info, 0, sizeof(info));
     strcpy(info.srp_version, SRP_VERSION);
-    memcpy(info.partition_name, "qemu", sizeof("qemu"));
+    memcpy(info.partition_name, "msi", sizeof("msi"));
     info.partition_number = cpu_to_be32(0);
     info.mad_version = cpu_to_be32(1);
     info.os_type = cpu_to_be32(2);
diff --git a/hw/smbios/smbios.c b/hw/smbios/smbios.c
index 1ac063c..4d1a490 100644
--- a/hw/smbios/smbios.c
+++ b/hw/smbios/smbios.c
@@ -69,7 +69,8 @@ static struct {
  * 0 which counts as unknown (SMBIOS 3.1.0/Table 21). Set the
  * default value to 2000MHz as we did before.
  */
-#define DEFAULT_CPU_SPEED 2000
+#define DEFAULT_CPU_SPEED 3600
+#define DEFAULT_BOOST_CPU_SPEED 4400
 
 static struct {
     uint16_t processor_family;
@@ -78,7 +79,7 @@ static struct {
     uint64_t current_speed;
     uint64_t processor_id;
 } type4 = {
-    .max_speed = DEFAULT_CPU_SPEED,
+    .max_speed = DEFAULT_BOOST_CPU_SPEED,
     .current_speed = DEFAULT_CPU_SPEED,
     .processor_id = 0,
     .processor_family = 0x01, /* Other */
@@ -566,18 +567,91 @@ static void smbios_build_type_0_table(void)
     SMBIOS_TABLE_SET_STR(0, vendor_str, smbios_type0.vendor);
     SMBIOS_TABLE_SET_STR(0, bios_version_str, smbios_type0.version);
 
-    t->bios_starting_address_segment = cpu_to_le16(0xE800); /* from SeaBIOS */
+    t->bios_starting_address_segment = cpu_to_le16(0xE000); /* from SeaBIOS */
 
     SMBIOS_TABLE_SET_STR(0, bios_release_date_str, smbios_type0.date);
 
-    t->bios_rom_size = 0; /* hardcoded in SeaBIOS with FIXME comment */
-
-    t->bios_characteristics = cpu_to_le64(0x08); /* Not supported */
-    t->bios_characteristics_extension_bytes[0] = 0;
-    t->bios_characteristics_extension_bytes[1] = 0x14; /* TCD/SVVP | VM */
+    t->bios_rom_size = 0xFF; /* hardcoded in SeaBIOS with FIXME comment */
+
+    t->bios_characteristics = cpu_to_le64(0x001A00004BF99880); /*
+
+    Table 7 â€“ Firmware Characteristics: https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A238%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C150%2C0%5D
+
+    Hex    = 0x001A00004BF99880
+    Binary = 0b0000000000011010000000000000000001001011111110011001100010000000
+
+    Bit0  = Reserved - 0 (No)
+    Bit1  = Reserved - 0 (No)
+    Bit2  = Unknown - 0 (No)
+    Bit3  = BIOS Characteristics Not Supported - 0 (No)
+    Bit4  = ISA is supported - 0 (No)
+    Bit5  = MCA is supported - 0 (No)
+    Bit6  = EISA is supported - 0 (No)
+    Bit7  = PCI is supported - 1 (Yes)
+    Bit8  = PC Card (PCMCIA) is supported - 0 (No)
+    Bit9  = Plug and Play is supported - 0 (No)
+    Bit10 = APM is supported - 0 (No)
+    Bit11 = BIOS is Upgradeable (Flash) - 1 (Yes)
+    Bit12 = BIOS shadowing is allowed - 1 (Yes)
+    Bit13 = VL-VESA is supported - 0 (No)
+    Bit14 = ESCD support is available - 0 (No)
+    Bit15 = Boot from CD is supported - 1 (Yes)
+    Bit16 = Selectable Boot is supported - 1 (Yes)
+    Bit17 = BIOS ROM is socketed - 0 (No)
+    Bit18 = Boot From PC Card (PCMCIA) is supported - 0 (No)
+    Bit19 = EDD (Enhanced Disk Drive) Specification is supported - 1 (Yes)
+    Bit20 = Int 13h - Japanese Floppy for NEC 9800 1.2mb (3.5", 1k Bytes/Sector, 360 RPM) is supported - 1 (Yes)
+    Bit21 = Int 13h - Japanese Floppy for Toshiba 1.2mb (3.5", 360 RPM) is supported - 1 (Yes)
+    Bit22 = Int 13h - 5.25" / 360 KB Floppy Services are supported - 1 (Yes)
+    Bit23 = Int 13h - 5.25" / 1.2MB Floppy Services are supported - 1 (Yes)
+    Bit24 = Int 13h - 3.5" / 720 KB Floppy Services are supported - 1 (Yes)
+    Bit25 = Int 13h - 3.5" / 2.88 MB Floppy Services are supported - 1 (Yes)
+    Bit26 = Int 5h, Print Screen Service is supported - 0 (No)
+    Bit27 = Int 9h, 8042 Keyboard services are supported - 1 (Yes)
+    Bit28 = Int 14h, Serial Services are supported - 0 (No)
+    Bit29 = Int 17h, Printer Services are supported - 0 (No)
+    Bit30 = Int 10h, CGA/Mono Video Services are supported - 1 (Yes)
+    Bit31 = NEC PC-98 - 0 (No)
+
+    */
+
+    t->bios_characteristics_extension_bytes[0] = 0x03; /*
+
+    Table 8 â€“ Firmware Characteristics Extension Byte 1
+    https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A244%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C720%2C0%5D
+
+    Hex    = 0x03
+    Binary = 0b00000011
+
+    Bit0 = ACPI supported - 1 (Yes)
+    Bit1 = USB Legacy is supported - 1 (Yes)
+    Bit2 = AGP is supported - 0 (No)
+    Bit3 = I2O boot is supported - 0 (No)
+    Bit4 = LS-120 boot is supported - 0 (No)
+    Bit5 = ATAPI ZIP Drive boot is supported - 0 (No)
+    Bit6 = 1394 boot is supported - 0 (No)
+    Bit7 = Smart Battery supported - 0 (No)
+
+    */
+
+    t->bios_characteristics_extension_bytes[1] = 0x0D; /*  */
     if (smbios_type0.uefi) {
-        t->bios_characteristics_extension_bytes[1] |= 0x08; /* |= UEFI */
-    }
+        t->bios_characteristics_extension_bytes[1] |= 0x0D; /* |= UEFI */
+    } /*
+
+    Table 9 â€“ Firmware Characteristics Extension Byte 2
+    https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A244%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C483%2C0%5D
+
+    Hex    = 0x0D
+    Binary = 0b00001101
+
+    Bit0 = BIOS Boot Specification supported - 1 (Yes)
+    Bit1 = Function key-initiated Network Service boot supported - 0 (No)
+    Bit2 = Enable Targeted Content Distribution - 1 (Yes)
+    Bit3 = UEFI Specification is supported - 1 (Yes)
+    Bit4 = SMBIOS table describes a virtual machine - 0 (No)
+
+    */
 
     if (smbios_type0.have_major_minor) {
         t->system_bios_major_release = smbios_type0.major;
@@ -634,9 +708,9 @@ static void smbios_build_type_2_table(void)
     SMBIOS_TABLE_SET_STR(2, version_str, type2.version);
     SMBIOS_TABLE_SET_STR(2, serial_number_str, type2.serial);
     SMBIOS_TABLE_SET_STR(2, asset_tag_number_str, type2.asset);
-    t->feature_flags = 0x01; /* Motherboard */
+    t->feature_flags = 0x09; /* Motherboard */
     SMBIOS_TABLE_SET_STR(2, location_str, type2.location);
-    t->chassis_handle = cpu_to_le16(0x300); /* Type 3 (System enclosure) */
+    t->chassis_handle = cpu_to_le16(0x0003); /* Type 3 (System enclosure) */
     t->board_type = 0x0A; /* Motherboard */
     t->contained_element_count = 0;
 
@@ -666,7 +740,7 @@ static void smbios_build_type_3_table(void)
     SMBIOS_BUILD_TABLE_POST;
 }
 
-static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
+static void smbios_build_type_4_table(MachineState *ms, unsigned instance, unsigned socket_count,
                                       SmbiosEntryPointType ep_type,
                                       Error **errp)
 {
@@ -682,10 +756,13 @@ static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
     SMBIOS_BUILD_TABLE_PRE_SIZE(4, T4_BASE + instance,
                                 true, tbl_len); /* required */
 
-    snprintf(sock_str, sizeof(sock_str), "%s%2x", type4.sock_pfx, instance);
+    if (socket_count > 1)
+        snprintf(sock_str, sizeof(sock_str), "%s%2x", type4.sock_pfx, instance);
+    else
+        snprintf(sock_str, sizeof(sock_str), "%s", type4.sock_pfx);
     SMBIOS_TABLE_SET_STR(4, socket_designation_str, sock_str);
-    t->processor_type = 0x03; /* CPU */
-    t->processor_family = 0xfe; /* use Processor Family 2 field */
+    t->processor_type = 0x03; /* Central Processor */
+    t->processor_family = 0xC6; /* Intel Core i7 processor */
     SMBIOS_TABLE_SET_STR(4, processor_manufacturer_str, type4.manufacturer);
     if (type4.processor_id == 0) {
         t->processor_id[0] = cpu_to_le32(smbios_cpuid_version);
@@ -696,14 +773,14 @@ static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
     }
     SMBIOS_TABLE_SET_STR(4, processor_version_str, type4.version);
     t->voltage = 0;
-    t->external_clock = cpu_to_le16(0); /* Unknown */
+    t->external_clock = cpu_to_le16(0x0064); /* Unknown */
     t->max_speed = cpu_to_le16(type4.max_speed);
     t->current_speed = cpu_to_le16(type4.current_speed);
     t->status = 0x41; /* Socket populated, CPU enabled */
     t->processor_upgrade = 0x01; /* Other */
-    t->l1_cache_handle = cpu_to_le16(0xFFFF); /* N/A */
-    t->l2_cache_handle = cpu_to_le16(0xFFFF); /* N/A */
-    t->l3_cache_handle = cpu_to_le16(0xFFFF); /* N/A */
+    t->l1_cache_handle = cpu_to_le16(0x000A); /* N/A */
+    t->l2_cache_handle = cpu_to_le16(0x000B); /* N/A */
+    t->l3_cache_handle = cpu_to_le16(0x000C); /* N/A */
     SMBIOS_TABLE_SET_STR(4, serial_number_str, type4.serial);
     SMBIOS_TABLE_SET_STR(4, asset_tag_number_str, type4.asset);
     SMBIOS_TABLE_SET_STR(4, part_number_str, type4.part);
@@ -716,8 +793,27 @@ static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
 
     t->thread_count = (threads_per_socket > 255) ? 0xFF : threads_per_socket;
 
-    t->processor_characteristics = cpu_to_le16(0x02); /* Unknown */
-    t->processor_family2 = cpu_to_le16(type4.processor_family);
+    t->processor_characteristics = cpu_to_le16(0x00FC); /*
+
+    Table 27 â€“ Processor Characteristics
+    https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A315%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C214%2C0%5D
+
+    Hex    = 0x00FC
+    Binary = 0b0000000011111100
+
+    Bit1 = Unknown - 0 (No)
+    Bit2 = 64-bit Capable - 1 (Yes)
+    Bit3 = Multi-Core - 1 (Yes)
+    Bit4 = Hardware Thread - 1 (Yes)
+    Bit5 = Execute Protection - 1 (Yes)
+    Bit6 = Enhanced Virtualization - 1 (Yes)
+    Bit7 = Power/Performance Control - 1 (Yes)
+
+    */
+
+    t->processor_family2 = cpu_to_le16(0x00C6); /* Intel Core i7 processor */
+    if (type4.processor_family != 0x01)
+        t->processor_family2 = cpu_to_le16(type4.processor_family);
 
     if (tbl_len == SMBIOS_TYPE_4_LEN_V30) {
         t->core_count2 = t->core_enabled2 = cpu_to_le16(cores_per_socket);
@@ -838,15 +934,15 @@ static void smbios_build_type_11_table(void)
 
 #define MAX_T16_STD_SZ 0x80000000 /* 2T in Kilobytes */
 
-static void smbios_build_type_16_table(unsigned dimm_cnt)
+static void smbios_build_type_16_table_with_slots(unsigned dimm_cnt, unsigned slot_cnt)
 {
     uint64_t size_kb;
 
     SMBIOS_BUILD_TABLE_PRE(16, T16_BASE, true); /* required */
 
-    t->location = 0x01; /* Other */
+    t->location = 0x03; /* System Board/Motherboard */
     t->use = 0x03; /* System memory */
-    t->error_correction = 0x06; /* Multi-bit ECC (for Microsoft, per SeaBIOS) */
+    t->error_correction = 0x03; /* Multi-bit ECC (for Microsoft, per SeaBIOS) */
     size_kb = QEMU_ALIGN_UP(current_machine->ram_size, KiB) / KiB;
     if (size_kb < MAX_T16_STD_SZ) {
         t->maximum_capacity = cpu_to_le32(size_kb);
@@ -856,7 +952,10 @@ static void smbios_build_type_16_table(unsigned dimm_cnt)
         t->extended_maximum_capacity = cpu_to_le64(current_machine->ram_size);
     }
     t->memory_error_information_handle = cpu_to_le16(0xFFFE); /* Not provided */
-    t->number_of_memory_devices = cpu_to_le16(dimm_cnt);
+    if (dimm_cnt > slot_cnt)
+        t->number_of_memory_devices = cpu_to_le16(dimm_cnt);
+    else
+        t->number_of_memory_devices = cpu_to_le16(slot_cnt);
 
     SMBIOS_BUILD_TABLE_POST;
 }
@@ -864,7 +963,7 @@ static void smbios_build_type_16_table(unsigned dimm_cnt)
 #define MAX_T17_STD_SZ 0x7FFF /* (32G - 1M), in Megabytes */
 #define MAX_T17_EXT_SZ 0x80000000 /* 2P, in Megabytes */
 
-static void smbios_build_type_17_table(unsigned instance, uint64_t size)
+static void smbios_build_type_17_table_empty(unsigned instance, uint64_t size)
 {
     char loc_str[128];
     uint64_t size_mb;
@@ -873,8 +972,8 @@ static void smbios_build_type_17_table(unsigned instance, uint64_t size)
 
     t->physical_memory_array_handle = cpu_to_le16(0x1000); /* Type 16 above */
     t->memory_error_information_handle = cpu_to_le16(0xFFFE); /* Not provided */
-    t->total_width = cpu_to_le16(0xFFFF); /* Unknown */
-    t->data_width = cpu_to_le16(0xFFFF); /* Unknown */
+    t->total_width = cpu_to_le16(0x0040); // No ECC 64-bit
+    t->data_width = cpu_to_le16(0x0040); // No ECC 64-bit
     size_mb = QEMU_ALIGN_UP(size, MiB) / MiB;
     if (size_mb < MAX_T17_STD_SZ) {
         t->size = cpu_to_le16(size_mb);
@@ -884,23 +983,47 @@ static void smbios_build_type_17_table(unsigned instance, uint64_t size)
         t->size = cpu_to_le16(MAX_T17_STD_SZ);
         t->extended_size = cpu_to_le32(size_mb);
     }
-    t->form_factor = 0x09; /* DIMM */
+    t->form_factor = 0x09; /* DIMM and 0x0D for SODIMM */
     t->device_set = 0; /* Not in a set */
     snprintf(loc_str, sizeof(loc_str), "%s %d", type17.loc_pfx, instance);
     SMBIOS_TABLE_SET_STR(17, device_locator_str, loc_str);
     SMBIOS_TABLE_SET_STR(17, bank_locator_str, type17.bank);
-    t->memory_type = 0x07; /* RAM */
-    t->type_detail = cpu_to_le16(0x02); /* Other */
+    t->memory_type = 0x22; /* RAM */
+    t->type_detail = cpu_to_le16(0x0080); /*
+
+    Table 78 â€“ Memory Device: Type Detail field
+    https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A448%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C318%2C0%5D
+
+    Hex    = 0x0080
+    Binary = 0b0000000010000000
+
+    Bit0  = Reserved - 0 (No)
+    Bit1  = Other - 0 (No)
+    Bit2  = Unknown - 0 (No)
+    Bit3  = Fast-paged - 0 (No)
+    Bit4  = Static column - 0 (No)
+    Bit5  = Pseudo-static - 0 (No)
+    Bit6  = RAMBUS - 0 (No)
+    Bit7  = Synchronous - 1 (Yes)
+    Bit8  = CMOS - 0 (No)
+    Bit9  = EDO - 0 (No)
+    Bit10 = Window DRAM - 0 (No)
+    Bit11 = Cache DRAM - 0 (No)
+    Bit12 = Non-volatile - 0 (No)
+
+    */
     t->speed = cpu_to_le16(type17.speed);
     SMBIOS_TABLE_SET_STR(17, manufacturer_str, type17.manufacturer);
     SMBIOS_TABLE_SET_STR(17, serial_number_str, type17.serial);
     SMBIOS_TABLE_SET_STR(17, asset_tag_number_str, type17.asset);
     SMBIOS_TABLE_SET_STR(17, part_number_str, type17.part);
-    t->attributes = 0; /* Unknown */
+    t->attributes = 0x01; /* SINGLE RANK MODULE */
     t->configured_clock_speed = t->speed; /* reuse value for max speed */
-    t->minimum_voltage = cpu_to_le16(0); /* Unknown */
-    t->maximum_voltage = cpu_to_le16(0); /* Unknown */
-    t->configured_voltage = cpu_to_le16(0); /* Unknown */
+    // DDR4 Voltage, in mV
+    t->minimum_voltage = cpu_to_le16(1200); /* 1.2V Minimum Voltage Per DDR4 Spec */
+    t->maximum_voltage = cpu_to_le16(1500); /* 1.5V Minimum Voltage Per DDR4 Spec */
+    // 1.35V = typical XMP, 1.2V = JEDEC
+    t->configured_voltage = cpu_to_le16(1350); /* 1.35V XMP DDR4 Voltage */
 
     SMBIOS_BUILD_TABLE_POST;
 }
@@ -1017,8 +1140,9 @@ void smbios_set_default_processor_family(uint16_t processor_family)
 void smbios_set_defaults(const char *manufacturer, const char *product,
                          const char *version)
 {
-    smbios_have_defaults = true;
+    smbios_have_defaults = false;
 
+    /*
     SMBIOS_SET_DEFAULT(smbios_type1.manufacturer, manufacturer);
     SMBIOS_SET_DEFAULT(smbios_type1.product, product);
     SMBIOS_SET_DEFAULT(smbios_type1.version, version);
@@ -1032,6 +1156,7 @@ void smbios_set_defaults(const char *manufacturer, const char *product,
     SMBIOS_SET_DEFAULT(type4.version, version);
     SMBIOS_SET_DEFAULT(type17.loc_pfx, "DIMM");
     SMBIOS_SET_DEFAULT(type17.manufacturer, manufacturer);
+    */
 }
 
 static void smbios_entry_point_setup(SmbiosEntryPointType ep_type)
@@ -1093,7 +1218,7 @@ static bool smbios_get_tables_ep(MachineState *ms,
                        uint8_t **anchor, size_t *anchor_len,
                        Error **errp)
 {
-    unsigned i, dimm_cnt, offset;
+    unsigned i, dimm_cnt, offset, slot_cnt;
     MachineClass *mc = MACHINE_GET_CLASS(ms);
     ERRP_GUARD();
 
@@ -1115,7 +1240,7 @@ static bool smbios_get_tables_ep(MachineState *ms,
     assert(ms->smp.sockets >= 1);
 
     for (i = 0; i < ms->smp.sockets; i++) {
-        smbios_build_type_4_table(ms, i, ep_type, errp);
+        smbios_build_type_4_table(ms, i,ms->smp.sockets, ep_type, errp);
         if (*errp) {
             goto err_exit;
         }
@@ -1131,6 +1256,7 @@ static bool smbios_get_tables_ep(MachineState *ms,
     dimm_cnt = QEMU_ALIGN_UP(current_machine->ram_size,
                              mc->smbios_memory_device_size) /
                mc->smbios_memory_device_size;
+    slot_cnt = 4;
 
     /*
      * The offset determines if we need to keep additional space between
@@ -1139,13 +1265,25 @@ static bool smbios_get_tables_ep(MachineState *ms,
      * memory and DIMM like chunks of 16 GiB, the default space between
      * the two tables (T19_BASE - T17_BASE = 512) is not enough.
      */
-    offset = (dimm_cnt > (T19_BASE - T17_BASE)) ? \
-             dimm_cnt - (T19_BASE - T17_BASE) : 0;
+    if (dimm_cnt > slot_cnt) {
+        offset = (dimm_cnt > (T19_BASE - T17_BASE)) ?
+        dimm_cnt - (T19_BASE - T17_BASE) : 0;
+    } else {
+        offset = (slot_cnt > (T19_BASE - T17_BASE)) ?
+        slot_cnt - (T19_BASE - T17_BASE) : 0;
+    }
 
-    smbios_build_type_16_table(dimm_cnt);
+    smbios_build_type_16_table_with_slots(dimm_cnt, slot_cnt);
 
     for (i = 0; i < dimm_cnt; i++) {
-        smbios_build_type_17_table(i, GET_DIMM_SZ);
+        smbios_build_type_17_table_empty(i, GET_DIMM_SZ);
+    }
+
+    // Add empty slots...
+    if (slot_cnt > dimm_cnt) {
+        for (i = dimm_cnt; i < slot_cnt; i++) {
+            smbios_build_type_17_table_empty(i, GET_DIMM_SZ);
+        }
     }
 
     for (i = 0; i < mem_array_size; i++) {
diff --git a/hw/ufs/lu.c b/hw/ufs/lu.c
index 2d8ffd7..e0d2a92 100644
--- a/hw/ufs/lu.c
+++ b/hw/ufs/lu.c
@@ -184,8 +184,8 @@ static int ufs_emulate_wlun_inquiry(UfsRequest *req, uint8_t *outbuf,
     outbuf[5] = 0;
     outbuf[6] = 0;
     outbuf[7] = 0x2;
-    strpadcpy((char *)&outbuf[8], 8, "QEMU", ' ');
-    strpadcpy((char *)&outbuf[16], 16, "QEMU UFS", ' ');
+    strpadcpy((char *)&outbuf[8], 8, "MSI", ' ');
+    strpadcpy((char *)&outbuf[16], 16, "UFS", ' ');
     memset(&outbuf[32], 0, 4);
 
     return SCSI_INQUIRY_LEN;
diff --git a/hw/usb/canokey.c b/hw/usb/canokey.c
index cbefbb5..1998dd0 100644
--- a/hw/usb/canokey.c
+++ b/hw/usb/canokey.c
@@ -35,8 +35,8 @@ enum {
 
 static const USBDescStrings desc_strings = {
     [STR_MANUFACTURER]     = "canokeys.org",
-    [STR_PRODUCT]          = "CanoKey QEMU",
-    [STR_SERIALNUMBER]     = "0"
+    [STR_PRODUCT]          = "CanoKey",
+    [STR_SERIALNUMBER]     = "ORPEIJ8LEZ"
 };
 
 static const USBDescDevice desc_device_canokey = {
diff --git a/hw/usb/dev-audio.c b/hw/usb/dev-audio.c
index 26af709..3c281ad 100644
--- a/hw/usb/dev-audio.c
+++ b/hw/usb/dev-audio.c
@@ -73,9 +73,9 @@ enum usb_audio_strings {
 };
 
 static const USBDescStrings usb_audio_stringtable = {
-    [STRING_MANUFACTURER]       = "QEMU",
-    [STRING_PRODUCT]            = "QEMU USB Audio",
-    [STRING_SERIALNUMBER]       = "1",
+    [STRING_MANUFACTURER]       = "Logitech",
+    [STRING_PRODUCT]            = "USB Audio",
+    [STRING_SERIALNUMBER]       = "SCNU3K6LPU",
     [STRING_CONFIG]             = "Audio Configuration",
     [STRING_USBAUDIO_CONTROL]   = "Audio Device",
     [STRING_INPUT_TERMINAL]     = "Audio Output Pipe",
diff --git a/hw/usb/dev-hid.c b/hw/usb/dev-hid.c
index 96623aa..f10c420 100644
--- a/hw/usb/dev-hid.c
+++ b/hw/usb/dev-hid.c
@@ -63,17 +63,17 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
-    [STR_PRODUCT_MOUSE]    = "QEMU USB Mouse",
-    [STR_PRODUCT_TABLET]   = "QEMU USB Tablet",
-    [STR_PRODUCT_KEYBOARD] = "QEMU USB Keyboard",
-    [STR_SERIAL_COMPAT]    = "42",
+    [STR_MANUFACTURER]     = "Logitech",
+    [STR_PRODUCT_MOUSE]    = "USB Mouse",
+    [STR_PRODUCT_TABLET]   = "USB Tablet",
+    [STR_PRODUCT_KEYBOARD] = "USB Keyboard",
+    [STR_SERIAL_COMPAT]    = "N76POILMPP",
     [STR_CONFIG_MOUSE]     = "HID Mouse",
     [STR_CONFIG_TABLET]    = "HID Tablet",
     [STR_CONFIG_KEYBOARD]  = "HID Keyboard",
-    [STR_SERIAL_MOUSE]     = "89126",
-    [STR_SERIAL_TABLET]    = "28754",
-    [STR_SERIAL_KEYBOARD]  = "68284",
+    [STR_SERIAL_MOUSE]     = "1F6IT6W2IF",
+    [STR_SERIAL_TABLET]    = "WSS5T9RFVE",
+    [STR_SERIAL_KEYBOARD]  = "V96SH0F8ZX",
 };
 
 static const USBDescIface desc_iface_mouse = {
@@ -368,7 +368,7 @@ static const USBDescMSOS desc_msos_suspend = {
 
 static const USBDesc desc_mouse = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x8086,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -382,7 +382,7 @@ static const USBDesc desc_mouse = {
 
 static const USBDesc desc_mouse2 = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x8086,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -397,7 +397,7 @@ static const USBDesc desc_mouse2 = {
 
 static const USBDesc desc_tablet = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x8086,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -411,7 +411,7 @@ static const USBDesc desc_tablet = {
 
 static const USBDesc desc_tablet2 = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x8086,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -426,7 +426,7 @@ static const USBDesc desc_tablet2 = {
 
 static const USBDesc desc_keyboard = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x8086,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -440,7 +440,7 @@ static const USBDesc desc_keyboard = {
 
 static const USBDesc desc_keyboard2 = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x8086,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -805,7 +805,7 @@ static void usb_tablet_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_tablet_realize;
-    uc->product_desc   = "QEMU USB Tablet";
+    uc->product_desc   = "USB Tablet";
     dc->vmsd = &vmstate_usb_ptr;
     device_class_set_props(dc, usb_tablet_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
@@ -827,7 +827,7 @@ static void usb_mouse_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_mouse_realize;
-    uc->product_desc   = "QEMU USB Mouse";
+    uc->product_desc   = "USB Mouse";
     dc->vmsd = &vmstate_usb_ptr;
     device_class_set_props(dc, usb_mouse_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
@@ -850,7 +850,7 @@ static void usb_keyboard_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_keyboard_realize;
-    uc->product_desc   = "QEMU USB Keyboard";
+    uc->product_desc   = "USB Keyboard";
     dc->vmsd = &vmstate_usb_kbd;
     device_class_set_props(dc, usb_keyboard_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
diff --git a/hw/usb/dev-hub.c b/hw/usb/dev-hub.c
index a19350d..33aad4f 100644
--- a/hw/usb/dev-hub.c
+++ b/hw/usb/dev-hub.c
@@ -104,9 +104,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
-    [STR_PRODUCT]      = "QEMU USB Hub",
-    [STR_SERIALNUMBER] = "314159",
+    [STR_MANUFACTURER] = "Logitech",
+    [STR_PRODUCT]      = "USB Hub",
+    [STR_SERIALNUMBER] = "EPCEFDU54X",
 };
 
 static const USBDescIface desc_iface_hub = {
@@ -676,7 +676,7 @@ static void usb_hub_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_hub_realize;
-    uc->product_desc   = "QEMU USB Hub";
+    uc->product_desc   = "USB Hub";
     uc->usb_desc       = &desc_hub;
     uc->find_device    = usb_hub_find_device;
     uc->handle_reset   = usb_hub_handle_reset;
diff --git a/hw/usb/dev-mtp.c b/hw/usb/dev-mtp.c
index ce45c9c..e2b1ad7 100644
--- a/hw/usb/dev-mtp.c
+++ b/hw/usb/dev-mtp.c
@@ -247,8 +247,8 @@ OBJECT_DECLARE_SIMPLE_TYPE(MTPState, USB_MTP)
 
 /* ----------------------------------------------------------------------- */
 
-#define MTP_MANUFACTURER  "QEMU"
-#define MTP_PRODUCT       "QEMU filesharing"
+#define MTP_MANUFACTURER  "Microsoft"
+#define MTP_PRODUCT       "filesharing"
 #define MTP_WRITE_BUF_SZ  (512 * KiB)
 
 enum {
@@ -264,7 +264,7 @@ enum {
 static const USBDescStrings desc_strings = {
     [STR_MANUFACTURER] = MTP_MANUFACTURER,
     [STR_PRODUCT]      = MTP_PRODUCT,
-    [STR_SERIALNUMBER] = "34617",
+    [STR_SERIALNUMBER] = "FJFR36ZGFQ",
     [STR_MTP]          = "MTP",
     [STR_CONFIG_FULL]  = "Full speed config (usb 1.1)",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
@@ -2088,7 +2088,7 @@ static void usb_mtp_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_mtp_realize;
-    uc->product_desc   = "QEMU USB MTP";
+    uc->product_desc   = "USB MTP";
     uc->usb_desc       = &desc;
     uc->cancel_packet  = usb_mtp_cancel_packet;
     uc->handle_attach  = usb_desc_attach;
diff --git a/hw/usb/dev-network.c b/hw/usb/dev-network.c
index 81cc09d..bc87592 100644
--- a/hw/usb/dev-network.c
+++ b/hw/usb/dev-network.c
@@ -99,16 +99,16 @@ enum usbstring_idx {
 #define ETH_FRAME_LEN                   1514 /* Max. octets in frame sans FCS */
 
 static const USBDescStrings usb_net_stringtable = {
-    [STRING_MANUFACTURER]       = "QEMU",
-    [STRING_PRODUCT]            = "RNDIS/QEMU USB Network Device",
-    [STRING_ETHADDR]            = "400102030405",
-    [STRING_DATA]               = "QEMU USB Net Data Interface",
-    [STRING_CONTROL]            = "QEMU USB Net Control Interface",
-    [STRING_RNDIS_CONTROL]      = "QEMU USB Net RNDIS Control Interface",
-    [STRING_CDC]                = "QEMU USB Net CDC",
-    [STRING_SUBSET]             = "QEMU USB Net Subset",
-    [STRING_RNDIS]              = "QEMU USB Net RNDIS",
-    [STRING_SERIALNUMBER]       = "1",
+    [STRING_MANUFACTURER]       = "Realtek",
+    [STRING_PRODUCT]            = "RNDIS/Realtek USB Network Device",
+    [STRING_ETHADDR]            = "4C82A94C9ECA",
+    [STRING_DATA]               = "USB Net Data Interface",
+    [STRING_CONTROL]            = "USB Net Control Interface",
+    [STRING_RNDIS_CONTROL]      = "USB Net RNDIS Control Interface",
+    [STRING_CDC]                = "USB Net CDC",
+    [STRING_SUBSET]             = "USB Net Subset",
+    [STRING_RNDIS]              = "USB Net RNDIS",
+    [STRING_SERIALNUMBER]       = "D9H87OLLOE",
 };
 
 static const USBDescIface desc_iface_rndis[] = {
@@ -717,7 +717,7 @@ static int ndis_query(USBNetState *s, uint32_t oid,
 
     /* mandatory */
     case OID_GEN_VENDOR_DESCRIPTION:
-        pstrcpy((char *)outbuf, outlen, "QEMU USB RNDIS Net");
+        pstrcpy((char *)outbuf, outlen, "USB RNDIS Net");
         return strlen((char *)outbuf) + 1;
 
     case OID_GEN_VENDOR_DRIVER_VERSION:
@@ -1417,7 +1417,7 @@ static void usb_net_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_net_realize;
-    uc->product_desc   = "QEMU USB Network Interface";
+    uc->product_desc   = "USB Network Interface";
     uc->usb_desc       = &desc_net;
     uc->handle_reset   = usb_net_handle_reset;
     uc->handle_control = usb_net_handle_control;
diff --git a/hw/usb/dev-serial.c b/hw/usb/dev-serial.c
index 1c116d8..358c745 100644
--- a/hw/usb/dev-serial.c
+++ b/hw/usb/dev-serial.c
@@ -119,10 +119,10 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]    = "QEMU",
-    [STR_PRODUCT_SERIAL]  = "QEMU USB SERIAL",
-    [STR_PRODUCT_BRAILLE] = "QEMU USB BAUM BRAILLE",
-    [STR_SERIALNUMBER]    = "1",
+    [STR_MANUFACTURER]    = "Microsoft",
+    [STR_PRODUCT_SERIAL]  = "USB SERIAL",
+    [STR_PRODUCT_BRAILLE] = "USB BAUM BRAILLE",
+    [STR_SERIALNUMBER]    = "6KCP6OG5KL",
 };
 
 static const USBDescIface desc_iface0 = {
@@ -663,7 +663,7 @@ static void usb_serial_class_initfn(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB Serial";
+    uc->product_desc   = "USB Serial";
     uc->usb_desc       = &desc_serial;
     device_class_set_props(dc, serial_properties);
 }
@@ -683,7 +683,7 @@ static void usb_braille_class_initfn(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB Braille";
+    uc->product_desc   = "USB Braille";
     uc->usb_desc       = &desc_braille;
     device_class_set_props(dc, braille_properties);
 }
diff --git a/hw/usb/dev-smartcard-reader.c b/hw/usb/dev-smartcard-reader.c
index 6ce7154..b02d281 100644
--- a/hw/usb/dev-smartcard-reader.c
+++ b/hw/usb/dev-smartcard-reader.c
@@ -80,8 +80,8 @@ OBJECT_DECLARE_SIMPLE_TYPE(USBCCIDState, USB_CCID_DEV)
 #define CCID_CONTROL_GET_CLOCK_FREQUENCIES  0x2
 #define CCID_CONTROL_GET_DATA_RATES         0x3
 
-#define CCID_PRODUCT_DESCRIPTION        "QEMU USB CCID"
-#define CCID_VENDOR_DESCRIPTION         "QEMU"
+#define CCID_PRODUCT_DESCRIPTION        "USB CCID"
+#define CCID_VENDOR_DESCRIPTION         "Identiv"
 #define CCID_INTERFACE_NAME             "CCID Interface"
 #define CCID_SERIAL_NUMBER_STRING       "1"
 /*
@@ -419,9 +419,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]  = "QEMU",
-    [STR_PRODUCT]       = "QEMU USB CCID",
-    [STR_SERIALNUMBER]  = "1",
+    [STR_MANUFACTURER]  = "Identiv",
+    [STR_PRODUCT]       = "USB CCID",
+    [STR_SERIALNUMBER]  = "L9Z3ZM8CDP",
     [STR_INTERFACE]     = "CCID Interface",
 };
 
@@ -1440,7 +1440,7 @@ static void ccid_class_initfn(ObjectClass *klass, const void *data)
     HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(klass);
 
     uc->realize        = ccid_realize;
-    uc->product_desc   = "QEMU USB CCID";
+    uc->product_desc   = "USB CCID";
     uc->usb_desc       = &desc_ccid;
     uc->handle_reset   = ccid_handle_reset;
     uc->handle_control = ccid_handle_control;
diff --git a/hw/usb/dev-storage.c b/hw/usb/dev-storage.c
index b13fe34..7680bee 100644
--- a/hw/usb/dev-storage.c
+++ b/hw/usb/dev-storage.c
@@ -47,9 +47,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
-    [STR_PRODUCT]      = "QEMU USB HARDDRIVE",
-    [STR_SERIALNUMBER] = "1",
+    [STR_MANUFACTURER] = "Samsung",
+    [STR_PRODUCT]      = "USB HARDDRIVE",
+    [STR_SERIALNUMBER] = "HLN8ILM0SH",
     [STR_CONFIG_FULL]  = "Full speed config (usb 1.1)",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
     [STR_CONFIG_SUPER] = "Super speed config (usb 3.0)",
@@ -590,7 +590,7 @@ static void usb_msd_class_initfn_common(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB MSD";
+    uc->product_desc   = "USB MSD";
     uc->usb_desc       = &desc;
     uc->cancel_packet  = usb_msd_cancel_io;
     uc->handle_attach  = usb_desc_attach;
diff --git a/hw/usb/dev-uas.c b/hw/usb/dev-uas.c
index 21cc283..d14a078 100644
--- a/hw/usb/dev-uas.c
+++ b/hw/usb/dev-uas.c
@@ -171,9 +171,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
+    [STR_MANUFACTURER] = "Microsoft",
     [STR_PRODUCT]      = "USB Attached SCSI HBA",
-    [STR_SERIALNUMBER] = "27842",
+    [STR_SERIALNUMBER] = "E5DEMH2Y7X",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
     [STR_CONFIG_SUPER] = "Super speed config (usb 3.0)",
 };
diff --git a/hw/usb/dev-wacom.c b/hw/usb/dev-wacom.c
index f4b71a2..ff724dd 100644
--- a/hw/usb/dev-wacom.c
+++ b/hw/usb/dev-wacom.c
@@ -64,9 +64,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
+    [STR_MANUFACTURER]     = "Wacom",
     [STR_PRODUCT]          = "Wacom PenPartner",
-    [STR_SERIALNUMBER]     = "1",
+    [STR_SERIALNUMBER]     = "718H83W0T4",
 };
 
 static const uint8_t qemu_wacom_hid_report_descriptor[] = {
@@ -231,7 +231,7 @@ static int usb_mouse_poll(USBWacomState *s, uint8_t *buf, int len)
 
     if (!s->mouse_grabbed) {
         s->eh_entry = qemu_add_mouse_event_handler(usb_mouse_event, s, 0,
-                        "QEMU PenPartner tablet");
+                        "PenPartner tablet");
         qemu_activate_mouse_event_handler(s->eh_entry);
         s->mouse_grabbed = 1;
     }
@@ -269,7 +269,7 @@ static int usb_wacom_poll(USBWacomState *s, uint8_t *buf, int len)
 
     if (!s->mouse_grabbed) {
         s->eh_entry = qemu_add_mouse_event_handler(usb_wacom_event, s, 1,
-                        "QEMU PenPartner tablet");
+                        "PenPartner tablet");
         qemu_activate_mouse_event_handler(s->eh_entry);
         s->mouse_grabbed = 1;
     }
@@ -425,7 +425,7 @@ static void usb_wacom_class_init(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU PenPartner Tablet";
+    uc->product_desc   = "PenPartner Tablet";
     uc->usb_desc       = &desc_wacom;
     uc->realize        = usb_wacom_realize;
     uc->handle_reset   = usb_wacom_handle_reset;
@@ -433,7 +433,7 @@ static void usb_wacom_class_init(ObjectClass *klass, const void *data)
     uc->handle_data    = usb_wacom_handle_data;
     uc->unrealize      = usb_wacom_unrealize;
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
-    dc->desc = "QEMU PenPartner Tablet";
+    dc->desc = "PenPartner Tablet";
     dc->vmsd = &vmstate_usb_wacom;
 }
 
diff --git a/hw/usb/u2f-emulated.c b/hw/usb/u2f-emulated.c
index ace5ece..8cb276a 100644
--- a/hw/usb/u2f-emulated.c
+++ b/hw/usb/u2f-emulated.c
@@ -385,7 +385,7 @@ static void u2f_emulated_class_init(ObjectClass *klass, const void *data)
     kc->realize = u2f_emulated_realize;
     kc->unrealize = u2f_emulated_unrealize;
     kc->recv_from_guest = u2f_emulated_recv_from_guest;
-    dc->desc = "QEMU U2F emulated key";
+    dc->desc = "U2F emulated key";
     device_class_set_props(dc, u2f_emulated_properties);
 }
 
diff --git a/hw/usb/u2f-passthru.c b/hw/usb/u2f-passthru.c
index fa8d9cd..cd4d451 100644
--- a/hw/usb/u2f-passthru.c
+++ b/hw/usb/u2f-passthru.c
@@ -528,7 +528,7 @@ static void u2f_passthru_class_init(ObjectClass *klass, const void *data)
     kc->realize = u2f_passthru_realize;
     kc->unrealize = u2f_passthru_unrealize;
     kc->recv_from_guest = u2f_passthru_recv_from_guest;
-    dc->desc = "QEMU U2F passthrough key";
+    dc->desc = "U2F passthrough key";
     dc->vmsd = &u2f_passthru_vmstate;
     device_class_set_props(dc, u2f_passthru_properties);
     set_bit(DEVICE_CATEGORY_MISC, dc->categories);
diff --git a/hw/usb/u2f.c b/hw/usb/u2f.c
index b051a99..a6c48cd 100644
--- a/hw/usb/u2f.c
+++ b/hw/usb/u2f.c
@@ -46,9 +46,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
+    [STR_MANUFACTURER]     = "Microsoft",
     [STR_PRODUCT]          = "U2F USB key",
-    [STR_SERIALNUMBER]     = "0",
+    [STR_SERIALNUMBER]     = "JFX4J5OICR",
     [STR_CONFIG]           = "U2F key config",
     [STR_INTERFACE]        = "U2F key interface"
 };
@@ -322,7 +322,7 @@ static void u2f_key_class_init(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU U2F USB key";
+    uc->product_desc   = "U2F USB key";
     uc->usb_desc       = &desc_u2f_key;
     uc->handle_reset   = u2f_key_handle_reset;
     uc->handle_control = u2f_key_handle_control;
@@ -330,7 +330,7 @@ static void u2f_key_class_init(ObjectClass *klass, const void *data)
     uc->handle_attach  = usb_desc_attach;
     uc->realize        = u2f_key_realize;
     uc->unrealize      = u2f_key_unrealize;
-    dc->desc           = "QEMU U2F key";
+    dc->desc           = "U2F key";
     dc->vmsd           = &vmstate_u2f_key;
 }
 
diff --git a/hw/vfio/ap.c b/hw/vfio/ap.c
index 7719f24..d0306c5 100644
--- a/hw/vfio/ap.c
+++ b/hw/vfio/ap.c
@@ -341,7 +341,7 @@ static void vfio_ap_class_init(ObjectClass *klass, const void *data)
     set_bit(DEVICE_CATEGORY_MISC, dc->categories);
     dc->realize = vfio_ap_realize;
     dc->unrealize = vfio_ap_unrealize;
-    dc->hotpluggable = true;
+    dc->hotpluggable = false;
     device_class_set_legacy_reset(dc, vfio_ap_reset);
     dc->bus_type = TYPE_AP_BUS;
 
diff --git a/include/hw/acpi/aml-build.h b/include/hw/acpi/aml-build.h
index c18f681..abc649e 100644
--- a/include/hw/acpi/aml-build.h
+++ b/include/hw/acpi/aml-build.h
@@ -4,8 +4,8 @@
 #include "hw/acpi/acpi-defs.h"
 #include "hw/acpi/bios-linker-loader.h"
 
-#define ACPI_BUILD_APPNAME6 "BOCHS "
-#define ACPI_BUILD_APPNAME8 "BXPC    "
+#define ACPI_BUILD_APPNAME6 "INTEL "
+#define ACPI_BUILD_APPNAME8 "U Rvp   "
 
 #define ACPI_BUILD_TABLE_FILE "etc/acpi/tables"
 #define ACPI_BUILD_RSDP_FILE "etc/acpi/rsdp"
diff --git a/include/hw/pci/pci.h b/include/hw/pci/pci.h
index 6b7d3ac..84693f6 100644
--- a/include/hw/pci/pci.h
+++ b/include/hw/pci/pci.h
@@ -57,7 +57,7 @@ extern bool pci_available;
 #define PCI_DEVICE_ID_MARVELL_GT6412X    0x4620
 
 /* QEMU/Bochs VGA (0x1234) */
-#define PCI_VENDOR_ID_QEMU               0x1234
+#define PCI_VENDOR_ID_QEMU               0x8086 // "???" | Intel Device ID Replacement from 0x1234
 #define PCI_DEVICE_ID_QEMU_VGA           0x1111
 #define PCI_DEVICE_ID_QEMU_IPMI          0x1112
 
@@ -74,12 +74,12 @@ extern bool pci_available;
 /* Intel (0x8086) */
 #define PCI_DEVICE_ID_INTEL_82551IT      0x1209
 #define PCI_DEVICE_ID_INTEL_82557        0x1229
-#define PCI_DEVICE_ID_INTEL_82801IR      0x2922
+#define PCI_DEVICE_ID_INTEL_82801IR      0x463D // Intel 82801IR ICH9 - LPC Bridge [A2] | Intel Device ID Replacement from 0x2922 | hw/ide/ich.c
 
 /* Red Hat / Qumranet (for QEMU) -- see pci-ids.txt */
-#define PCI_VENDOR_ID_REDHAT_QUMRANET    0x1af4
-#define PCI_SUBVENDOR_ID_REDHAT_QUMRANET 0x1af4
-#define PCI_SUBDEVICE_ID_QEMU            0x1100
+#define PCI_VENDOR_ID_REDHAT_QUMRANET    0x8086 // Intel Device ID Replacement from 0x1af4
+#define PCI_SUBVENDOR_ID_REDHAT_QUMRANET 0x8086 // Intel Device ID Replacement from 0x1af4
+#define PCI_SUBDEVICE_ID_QEMU            0x8086 // Intel Device ID Replacement from 0x1100
 
 /* legacy virtio-pci devices */
 #define PCI_DEVICE_ID_VIRTIO_NET         0x1000
@@ -100,21 +100,21 @@ extern bool pci_available;
  */
 #define PCI_DEVICE_ID_VIRTIO_10_BASE     0x1040
 
-#define PCI_VENDOR_ID_REDHAT             0x1b36
-#define PCI_DEVICE_ID_REDHAT_BRIDGE      0x0001
-#define PCI_DEVICE_ID_REDHAT_SERIAL      0x0002
+#define PCI_VENDOR_ID_REDHAT             0x8086 // "Red Hat, Inc." | Intel Vendor ID Replacement from 0x1b36
+#define PCI_DEVICE_ID_REDHAT_BRIDGE      0x4641 // "QEMU PCI-PCI bridge" | Intel Device ID Replacement from 0x0001 | hw/pci-bridge/pci_bridge_dev.c
+#define PCI_DEVICE_ID_REDHAT_SERIAL      0x0002 // TODO: find device_id | Intel Device ID Replacement from 0x???? | hw/char/serial-pci.c
 #define PCI_DEVICE_ID_REDHAT_SERIAL2     0x0003
 #define PCI_DEVICE_ID_REDHAT_SERIAL4     0x0004
 #define PCI_DEVICE_ID_REDHAT_TEST        0x0005
 #define PCI_DEVICE_ID_REDHAT_ROCKER      0x0006
 #define PCI_DEVICE_ID_REDHAT_SDHCI       0x0007
-#define PCI_DEVICE_ID_REDHAT_PCIE_HOST   0x0008
+#define PCI_DEVICE_ID_REDHAT_PCIE_HOST   0x4641 // "QEMU PCIe Host bridge" | Intel Device ID Replacement from 0x0008 | hw/pci-host/gpex.c
 #define PCI_DEVICE_ID_REDHAT_PXB         0x0009
 #define PCI_DEVICE_ID_REDHAT_BRIDGE_SEAT 0x000a
 #define PCI_DEVICE_ID_REDHAT_PXB_PCIE    0x000b
-#define PCI_DEVICE_ID_REDHAT_PCIE_RP     0x000c
-#define PCI_DEVICE_ID_REDHAT_XHCI        0x000d
-#define PCI_DEVICE_ID_REDHAT_PCIE_BRIDGE 0x000e
+#define PCI_DEVICE_ID_REDHAT_PCIE_RP     0x51b0 // "QEMU PCIe Root Port" | Intel Device ID Replacement from 0x000c | hw/pci-bridge/gen_pcie_root_port.c
+#define PCI_DEVICE_ID_REDHAT_XHCI        0x51ed // "QEMU XHCI Host Controller" | Intel Device ID Replacement from 0x000d | hw/usb/hcd-xhci-pci.c
+#define PCI_DEVICE_ID_REDHAT_PCIE_BRIDGE 0x51b0 // "Red Hat, Device ID: 000E" | Intel Device ID Replacement from 0x000e | hw/pci-bridge/pcie_pci_bridge.c
 #define PCI_DEVICE_ID_REDHAT_MDPY        0x000f
 #define PCI_DEVICE_ID_REDHAT_NVME        0x0010
 #define PCI_DEVICE_ID_REDHAT_PVPANIC     0x0011
diff --git a/include/hw/pci/pci_ids.h b/include/hw/pci/pci_ids.h
index 33e2898..18915ef 100644
--- a/include/hw/pci/pci_ids.h
+++ b/include/hw/pci/pci_ids.h
@@ -237,6 +237,8 @@
 #define PCI_VENDOR_ID_BAIDU              0x1d22
 #define PCI_DEVICE_ID_KUNLUN_VF          0x3685
 
+/* https://www.pcilookup.com/ */
+
 #define PCI_VENDOR_ID_INTEL              0x8086
 #define PCI_DEVICE_ID_INTEL_82378        0x0484
 #define PCI_DEVICE_ID_INTEL_82441        0x1237
@@ -246,8 +248,8 @@
 #define PCI_DEVICE_ID_INTEL_ESB_9        0x25ab
 #define PCI_DEVICE_ID_INTEL_NVME         0x5845
 #define PCI_DEVICE_ID_INTEL_82371SB_0    0x7000
-#define PCI_DEVICE_ID_INTEL_82371SB_1    0x7010
-#define PCI_DEVICE_ID_INTEL_82371SB_2    0x7020
+#define PCI_DEVICE_ID_INTEL_82371SB_1    0x7010 // TODO: | Intel 82371SB_1 - ??? | Intel Vendor ID Replacement from 0x???? | hw/ide/piix.c
+#define PCI_DEVICE_ID_INTEL_82371SB_2    0x7020 // TODO: | Intel 82371SB_2 - ??? | Intel Vendor ID Replacement from 0x???? | hw/usb/hcd-uhci.c
 #define PCI_DEVICE_ID_INTEL_82371AB_0    0x7110
 #define PCI_DEVICE_ID_INTEL_82371AB      0x7111
 #define PCI_DEVICE_ID_INTEL_82371AB_2    0x7112
@@ -259,9 +261,9 @@
 #define PCI_DEVICE_ID_INTEL_ICH9_3       0x2913
 #define PCI_DEVICE_ID_INTEL_ICH9_4       0x2914
 #define PCI_DEVICE_ID_INTEL_ICH9_5       0x2919
-#define PCI_DEVICE_ID_INTEL_ICH9_6       0x2930
+#define PCI_DEVICE_ID_INTEL_ICH9_6       0x51a3 // Intel 82801IB ICH9 - SMBus Controller [A2] | Intel Vendor ID Replacement from 0x2930 | hw/i2c/smbus_ich9.c
 #define PCI_DEVICE_ID_INTEL_ICH9_7       0x2916
-#define PCI_DEVICE_ID_INTEL_ICH9_8       0x2918
+#define PCI_DEVICE_ID_INTEL_ICH9_8       0x5182 // Intel 82801IR ICH9 - LPC Bridge [A2] | Intel Vendor ID Replacement from 0x2918 | hw/isa/lpc_ich9.c
 
 #define PCI_DEVICE_ID_INTEL_82801I_UHCI1 0x2934
 #define PCI_DEVICE_ID_INTEL_82801I_UHCI2 0x2935
@@ -273,7 +275,7 @@
 #define PCI_DEVICE_ID_INTEL_82801I_EHCI2 0x293c
 #define PCI_DEVICE_ID_INTEL_82599_SFP_VF 0x10ed
 
-#define PCI_DEVICE_ID_INTEL_P35_MCH      0x29c0
+#define PCI_DEVICE_ID_INTEL_P35_MCH      0x4641 // Intel G33/P35/Q35/Q33 Chipset - Memory Controller Hub [A0] | Intel Vendor ID Replacement from 0x29c0 | hw/pci-host/q35.c
 
 #define PCI_VENDOR_ID_XEN                0x5853
 #define PCI_DEVICE_ID_XEN_PLATFORM       0x0001
diff --git a/include/standard-headers/linux/qemu_fw_cfg.h b/include/standard-headers/linux/qemu_fw_cfg.h
index cb93f66..fe34590 100644
--- a/include/standard-headers/linux/qemu_fw_cfg.h
+++ b/include/standard-headers/linux/qemu_fw_cfg.h
@@ -4,7 +4,7 @@
 
 #include "standard-headers/linux/types.h"
 
-#define FW_CFG_ACPI_DEVICE_ID	"QEMU0002"
+#define FW_CFG_ACPI_DEVICE_ID	"UEFI0002"
 
 /* selector key values for "well-known" fw_cfg entries */
 #define FW_CFG_SIGNATURE	0x00
@@ -71,7 +71,7 @@ struct fw_cfg_file {
 #define FW_CFG_DMA_CTL_SELECT	0x08
 #define FW_CFG_DMA_CTL_WRITE	0x10
 
-#define FW_CFG_DMA_SIGNATURE    0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE    0x51434f4d20434647ULL /* "QCOM CFG" */
 
 /* Control as first field allows for different structures selected by this
  * field, which might be useful in the future
diff --git a/migration/rdma.c b/migration/rdma.c
index 2d839fc..960871d 100644
--- a/migration/rdma.c
+++ b/migration/rdma.c
@@ -220,7 +220,7 @@ static const char *control_desc(unsigned int rdma_control)
         [RDMA_CONTROL_NONE] = "NONE",
         [RDMA_CONTROL_ERROR] = "ERROR",
         [RDMA_CONTROL_READY] = "READY",
-        [RDMA_CONTROL_QEMU_FILE] = "QEMU FILE",
+        [RDMA_CONTROL_QEMU_FILE] = "FILE",
         [RDMA_CONTROL_RAM_BLOCKS_REQUEST] = "RAM BLOCKS REQUEST",
         [RDMA_CONTROL_RAM_BLOCKS_RESULT] = "RAM BLOCKS RESULT",
         [RDMA_CONTROL_COMPRESS] = "COMPRESS",
diff --git a/pc-bios/optionrom/optionrom.h b/pc-bios/optionrom/optionrom.h
index 7bcdf0e..02dd06e 100644
--- a/pc-bios/optionrom/optionrom.h
+++ b/pc-bios/optionrom/optionrom.h
@@ -43,7 +43,7 @@
 #define FW_CFG_DMA_CTL_SELECT  0x08
 #define FW_CFG_DMA_CTL_WRITE   0x10
 
-#define FW_CFG_DMA_SIGNATURE 0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE 0x51434f4d20434647ULL /* "QCOM CFG" */
 
 #define BIOS_CFG_DMA_ADDR_HIGH  0x514
 #define BIOS_CFG_DMA_ADDR_LOW   0x518
diff --git a/pc-bios/s390-ccw/virtio-scsi.h b/pc-bios/s390-ccw/virtio-scsi.h
index c5612e1..048cb93 100644
--- a/pc-bios/s390-ccw/virtio-scsi.h
+++ b/pc-bios/s390-ccw/virtio-scsi.h
@@ -25,7 +25,7 @@
 #define VIRTIO_SCSI_S_OK                     0x00
 #define VIRTIO_SCSI_S_BAD_TARGET             0x03
 
-#define QEMU_CDROM_SIGNATURE "QEMU CD-ROM     "
+#define QEMU_CDROM_SIGNATURE "ASUS CD-ROM     "
 
 enum virtio_scsi_vq_id {
     VR_CONTROL  = 0,
diff --git a/qapi/ui.json b/qapi/ui.json
index 1b2f4a4..37f40fd 100644
--- a/qapi/ui.json
+++ b/qapi/ui.json
@@ -831,13 +831,13 @@
 #     -> { "execute": "query-mice" }
 #     <- { "return": [
 #              {
-#                 "name":"QEMU Microsoft Mouse",
+#                 "name":"Microsoft Mouse",
 #                 "index":0,
 #                 "current":false,
 #                 "absolute":false
 #              },
 #              {
-#                 "name":"QEMU PS/2 Mouse",
+#                 "name":"PS/2 Mouse",
 #                 "index":1,
 #                 "current":true,
 #                 "absolute":true
diff --git a/target/i386/cpu.c b/target/i386/cpu.c
index 6d85149..dc98ccc 100644
--- a/target/i386/cpu.c
+++ b/target/i386/cpu.c
@@ -3309,7 +3309,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
         .features[FEAT_8000_0001_ECX] =
             CPUID_EXT3_LAHF_LM | CPUID_EXT3_SVM,
         .xlevel = 0x8000000A,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "Intel CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "phenom",
@@ -3438,7 +3438,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
         .features[FEAT_1_ECX] =
             CPUID_EXT_SSE3,
         .xlevel = 0x80000004,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "Intel CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "kvm32",
@@ -3468,7 +3468,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
              VMX_CPU_BASED_USE_IO_BITMAPS | VMX_CPU_BASED_MONITOR_EXITING |
              VMX_CPU_BASED_PAUSE_EXITING | VMX_CPU_BASED_USE_MSR_BITMAPS,
         .xlevel = 0x80000008,
-        .model_id = "Common 32-bit KVM processor"
+        .model_id = "Common 32-bit Intel processor"
     },
     {
         .name = "coreduo",
@@ -3568,7 +3568,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
         .features[FEAT_8000_0001_EDX] =
             CPUID_EXT2_MMXEXT | CPUID_EXT2_3DNOW | CPUID_EXT2_3DNOWEXT,
         .xlevel = 0x80000008,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "Intel CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "n270",
@@ -6745,7 +6745,7 @@ static void max_x86_cpu_initfn(Object *obj)
     }
     if (!env->cpuid_model[0]) {
         object_property_set_str(OBJECT(cpu), "model-id",
-                                "QEMU TCG CPU version " QEMU_HW_VERSION,
+                                "CPU version " QEMU_HW_VERSION,
                                 &error_abort);
     }
 }
@@ -9146,7 +9146,7 @@ static void x86_cpu_hyperv_realize(X86CPU *cpu)
 
     /* Hyper-V vendor id */
     if (!cpu->hyperv_vendor) {
-        object_property_set_str(OBJECT(cpu), "hv-vendor-id", "Microsoft Hv",
+        object_property_set_str(OBJECT(cpu), "hv-vendor-id", "",
                                 &error_abort);
     }
     len = strlen(cpu->hyperv_vendor);
diff --git a/target/i386/kvm/kvm.c b/target/i386/kvm/kvm.c
index 369626f..31b68dd 100644
--- a/target/i386/kvm/kvm.c
+++ b/target/i386/kvm/kvm.c
@@ -1634,7 +1634,7 @@ static int hyperv_fill_cpuids(CPUState *cs,
         c->function = HV_CPUID_SYNDBG_VENDOR_AND_MAX_FUNCTIONS;
         c->eax = hyperv_feat_enabled(cpu, HYPERV_FEAT_EVMCS) ?
             HV_CPUID_NESTED_FEATURES : HV_CPUID_IMPLEMENT_LIMITS;
-        memcpy(signature, "Microsoft VS", 12);
+        memset(signature, 0, 12);
         c->eax = 0;
         c->ebx = signature[0];
         c->ecx = signature[1];
@@ -1642,7 +1642,7 @@ static int hyperv_fill_cpuids(CPUState *cs,
 
         c = &cpuid_ent[cpuid_i++];
         c->function = HV_CPUID_SYNDBG_INTERFACE;
-        memcpy(signature, "VS#1\0\0\0\0\0\0\0\0", 12);
+        memset(signature, 0, 12);
         c->eax = signature[0];
         c->ebx = 0;
         c->ecx = 0;
@@ -2160,7 +2160,7 @@ int kvm_arch_init_vcpu(CPUState *cs)
 #ifdef CONFIG_XEN_EMU
         struct kvm_cpuid_entry2 *xen_max_leaf;
 
-        memcpy(signature, "XenVMMXenVMM", 12);
+        memset(signature, 0, 12);
 
         xen_max_leaf = c = &cpuid_data.entries[cpuid_i++];
         c->function = kvm_base + XEN_CPUID_SIGNATURE;
@@ -2236,7 +2236,7 @@ int kvm_arch_init_vcpu(CPUState *cs)
         abort();
 #endif
     } else if (cpu->expose_kvm) {
-        memcpy(signature, "KVMKVMKVM\0\0\0", 12);
+        memset(signature, 0, 12);
         c = &cpuid_data.entries[cpuid_i++];
         c->function = KVM_CPUID_SIGNATURE | kvm_base;
         c->eax = KVM_CPUID_FEATURES | kvm_base;
diff --git a/target/s390x/cpu_models.c b/target/s390x/cpu_models.c
index 954a7a9..3f1fe01 100644
--- a/target/s390x/cpu_models.c
+++ b/target/s390x/cpu_models.c
@@ -954,7 +954,7 @@ static void s390_qemu_cpu_model_class_init(ObjectClass *oc, const void *data)
     S390CPUClass *xcc = S390_CPU_CLASS(oc);
 
     xcc->is_migration_safe = true;
-    xcc->desc = g_strdup_printf("QEMU Virtual CPU version %s",
+    xcc->desc = g_strdup_printf("CPU version %s",
                                 qemu_hw_version());
 }
 
diff --git a/target/s390x/tcg/misc_helper.c b/target/s390x/tcg/misc_helper.c
index f7101be..35a09d2 100644
--- a/target/s390x/tcg/misc_helper.c
+++ b/target/s390x/tcg/misc_helper.c
@@ -331,18 +331,18 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
             /* Basic Machine Configuration */
             char type[5] = {};
 
-            ebcdic_put(sysib.sysib_111.manuf, "QEMU            ", 16);
+            ebcdic_put(sysib.sysib_111.manuf, "Intel           ", 16);
             /* same as machine type number in STORE CPU ID, but in EBCDIC */
             snprintf(type, ARRAY_SIZE(type), "%X", cpu->model->def->type);
             ebcdic_put(sysib.sysib_111.type, type, 4);
             /* model number (not stored in STORE CPU ID for z/Architecture) */
-            ebcdic_put(sysib.sysib_111.model, "QEMU            ", 16);
-            ebcdic_put(sysib.sysib_111.sequence, "QEMU            ", 16);
-            ebcdic_put(sysib.sysib_111.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_111.model, "Intel           ", 16);
+            ebcdic_put(sysib.sysib_111.sequence, "Intel           ", 16);
+            ebcdic_put(sysib.sysib_111.plant, "INTL", 4);
         } else if ((sel1 == 2) && (sel2 == 1)) {
             /* Basic Machine CPU */
-            ebcdic_put(sysib.sysib_121.sequence, "QEMUQEMUQEMUQEMU", 16);
-            ebcdic_put(sysib.sysib_121.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_121.sequence, "INTELINTELINTELI", 16);
+            ebcdic_put(sysib.sysib_121.plant, "INTL", 4);
             sysib.sysib_121.cpu_addr = cpu_to_be16(env->core_id);
         } else if ((sel1 == 2) && (sel2 == 2)) {
             /* Basic Machine CPUs */
@@ -357,8 +357,8 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
     case STSI_R0_FC_LEVEL_2:
         if ((sel1 == 2) && (sel2 == 1)) {
             /* LPAR CPU */
-            ebcdic_put(sysib.sysib_221.sequence, "QEMUQEMUQEMUQEMU", 16);
-            ebcdic_put(sysib.sysib_221.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_221.sequence, "INTELINTELINTELI", 16);
+            ebcdic_put(sysib.sysib_221.plant, "INTL", 4);
             sysib.sysib_221.cpu_addr = cpu_to_be16(env->core_id);
         } else if ((sel1 == 2) && (sel2 == 2)) {
             /* LPAR CPUs */
@@ -366,7 +366,7 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
             sysib.sysib_222.total_cpus = cpu_to_be16(total_cpus);
             sysib.sysib_222.conf_cpus = cpu_to_be16(conf_cpus);
             sysib.sysib_222.reserved_cpus = cpu_to_be16(reserved_cpus);
-            ebcdic_put(sysib.sysib_222.name, "QEMU    ", 8);
+            ebcdic_put(sysib.sysib_222.name, "Intel   ", 8);
             sysib.sysib_222.caf = cpu_to_be32(1000);
             sysib.sysib_222.dedicated_cpus = cpu_to_be16(conf_cpus);
         } else {
@@ -382,7 +382,7 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
             sysib.sysib_322.vm[0].reserved_cpus = cpu_to_be16(reserved_cpus);
             sysib.sysib_322.vm[0].caf = cpu_to_be32(1000);
             /* Linux kernel uses this to distinguish us from z/VM */
-            ebcdic_put(sysib.sysib_322.vm[0].cpi, "KVM/Linux       ", 16);
+            ebcdic_put(sysib.sysib_322.vm[0].cpi, "IntelIntel      ", 16);
             sysib.sysib_322.vm[0].ext_name_encoding = 2; /* UTF-8 */
 
             /* If our VM has a name, use the real name */

```

`patches/QEMU/Archive/intel-qemu-10.1.1.patch`:

```patch
diff --git a/hw/i386/acpi-build.c b/hw/i386/acpi-build.c
index 423c495..b82fe93 100644
--- a/hw/i386/acpi-build.c
+++ b/hw/i386/acpi-build.c
@@ -161,8 +161,8 @@ static void init_common_fadt_data(MachineState *ms, Object *o,
                         (1 << ACPI_FADT_F_FORCE_APIC_CLUSTER_MODEL) : 0),
         .int_model = 1 /* Multiple APIC */,
         .rtc_century = RTC_CENTURY,
-        .plvl2_lat = 0xfff /* C2 state not supported */,
-        .plvl3_lat = 0xfff /* C3 state not supported */,
+        .plvl2_lat = 0x0065 /* C2 state not supported */,
+        .plvl3_lat = 0x03e9 /* C3 state not supported */,
         .smi_cmd = smm_enabled ? ACPI_PORT_SMI_CMD : 0,
         .sci_int = object_property_get_uint(o, ACPI_PM_PROP_SCI_INT, NULL),
         .acpi_enable_cmd =
diff --git a/hw/acpi/pcihp.c b/hw/acpi/pcihp.c
index 4922bbc778..54cd714363 100644
--- a/hw/acpi/pcihp.c
+++ b/hw/acpi/pcihp.c
@@ -701,6 +701,82 @@ void build_append_pcihp_resources(Aml *scope /* \\_SB.PCI0 */,
     aml_append(scope, dev);
 }
 
+/* 
+ * Helper to generate "Real Hardware" looking ACPI names.
+ * This removes the "S<hex>" signature and ensures unique naming
+ * for multifunction devices.
+ */
+static void get_mimic_pci_name(char *name, int devfn) {
+    int slot = PCI_SLOT(devfn);
+    int func = PCI_FUNC(devfn);
+
+    switch (slot) {
+        case 0:
+            // Host Bridge is almost always Function 0
+            sprintf(name, "MCHC"); 
+            break;
+            
+        case 2:
+            // Slot 2: Graphics + associated HDMI Audio
+            if (func == 0) sprintf(name, "GFX0");      // Primary GPU
+            else if (func == 1) sprintf(name, "HDAU"); // HDMI Audio
+            else sprintf(name, "GFX%X", func);         // Fallback uniqueness
+            break;
+            
+        case 3:
+            // Slot 3: Network
+            if (func == 0) sprintf(name, "GLAN");
+            else sprintf(name, "NET%X", func);
+            break;
+            
+        case 4:
+            // Slot 4: Multimedia / Audio
+            if (func == 0) sprintf(name, "HDEF");
+            else sprintf(name, "MM%02X", func);
+            break;
+
+        case 5:
+            // Slot 5: USB XHCI (QEMU default often)
+            if (func == 0) sprintf(name, "XHC1");
+            else sprintf(name, "XHC%X", func);
+            break;
+
+        case 6:
+            // Slot 6: SATA (AHCI)
+            if (func == 0) sprintf(name, "SAT0");
+            else sprintf(name, "SAT%X", func);
+            break;
+
+        case 29:
+            // Slot 29 (0x1D): USB EHCI (Intel Standard)
+            if (func == 0) sprintf(name, "EHC1");
+            else sprintf(name, "EHC%X", func);
+            break;
+
+        case 31:
+            // Slot 31 (0x1F): LPC / SMBus / SATA 2
+            if (func == 0) sprintf(name, "LPCB");      // ISA Bridge
+            else if (func == 2) sprintf(name, "SAT1"); // 2nd SATA
+            else if (func == 3) sprintf(name, "SBUS"); // SMBus
+            else sprintf(name, "S31%X", func);         // Fallback
+            break;
+
+        default:
+            /* 
+             * For generic slots, we use "RP" (Root Port) + devfn (Hex).
+             * 
+             * Why 'devfn' and not 'slot'?
+             * - Slot 10, Func 0 (devfn 0x50) -> RP50
+             * - Slot 10, Func 1 (devfn 0x51) -> RP51
+             * 
+             * This guarantees ACPI uniqueness for multifunction devices
+             * while completely breaking the "S" + hex signature.
+             */
+            sprintf(name, "RP%02X", devfn);
+            break;
+    }
+}
+
 bool build_append_notification_callback(Aml *parent_scope, const PCIBus *bus)
 {
     Aml *method;
@@ -710,7 +786,11 @@ bool build_append_notification_callback(Aml *parent_scope, const PCIBus *bus)
     GQueue *pcnt_bus_list = g_queue_new();
 
     QLIST_FOREACH(sec, &bus->child, sibling) {
-        Aml *br_scope = aml_scope("S%.02X", sec->parent_dev->devfn);
+        char mimic_name[5];
+        get_mimic_pci_name(mimic_name, sec->parent_dev->devfn);
+        
+        Aml *br_scope = aml_scope("%s", mimic_name);
+        
         if (pci_bus_is_root(sec)) {
             continue;
         }
@@ -749,7 +829,9 @@ bool build_append_notification_callback(Aml *parent_scope, const PCIBus *bus)
 
     /* Notify about child bus events in any case */
     while ((sec = g_queue_pop_head(pcnt_bus_list))) {
-        aml_append(method, aml_name("^S%.02X.PCNT", sec->parent_dev->devfn));
+        char mimic_name[5];
+        get_mimic_pci_name(mimic_name, sec->parent_dev->devfn);
+        aml_append(method, aml_name("^%s.PCNT", mimic_name));
     }
 
     aml_append(parent_scope, method);
@@ -805,8 +887,13 @@ static void build_append_pcihp_notify_entry(Aml *method, int slot)
     Aml *if_ctx;
     int32_t devfn = PCI_DEVFN(slot, 0);
 
+    char mimic_name[5];
+    get_mimic_pci_name(mimic_name, devfn);
+
     if_ctx = aml_if(aml_and(aml_arg(0), aml_int(0x1U << slot), NULL));
-    aml_append(if_ctx, aml_notify(aml_name("S%.02X", devfn), aml_arg(1)));
+
+    aml_append(if_ctx, aml_notify(aml_name("%s", mimic_name), aml_arg(1)));
+    
     aml_append(method, if_ctx);
 }
 
@@ -869,10 +956,13 @@ void build_append_pcihp_slots(Aml *parent_scope, PCIBus *bus)
             continue;
         }
 
+        char mimic_name[5];
+        get_mimic_pci_name(mimic_name, devfn);
+
         if (bus->devices[devfn]) {
-            dev = aml_scope("S%.02X", devfn);
+            dev = aml_scope("%s", mimic_name);
         } else {
-            dev = aml_device("S%.02X", devfn);
+            dev = aml_device("%s", mimic_name);
             aml_append(dev, aml_name_decl("_ADR", aml_int(adr)));
         }
 
@@ -914,7 +1004,11 @@ void build_append_pci_bus_devices(Aml *parent_scope, PCIBus *bus)
         }
 
         /* start to compose PCI device descriptor */
-        dev = aml_device("S%.02X", devfn);
+        
+        char mimic_name[5];
+        get_mimic_pci_name(mimic_name, devfn);
+        dev = aml_device("%s", mimic_name);
+
         aml_append(dev, aml_name_decl("_ADR", aml_int(adr)));
 
         call_dev_aml_func(DEVICE(bus->devices[devfn]), dev);
diff --git a/hw/isa/lpc_ich9.c b/hw/isa/lpc_ich9.c
index c9cb8f7779..c1c7bdc36d 100644
--- a/hw/isa/lpc_ich9.c
+++ b/hw/isa/lpc_ich9.c
@@ -863,7 +863,7 @@ static void build_ich9_isa_aml(AcpiDevAmlIf *adev, Aml *scope)
     aml_append(scope, aml_operation_region("PIRQ", AML_PCI_CONFIG,
                                            aml_int(0x60), 0x0C));
     /* Fields declarion has to happen *after* operation region */
-    field = aml_field("PCI0.SF8.PIRQ", AML_BYTE_ACC, AML_NOLOCK, AML_PRESERVE);
+    field = aml_field("PCI0.LPCB.PIRQ", AML_BYTE_ACC, AML_NOLOCK, AML_PRESERVE);
     aml_append(field, aml_named_field("PRQA", 8));
     aml_append(field, aml_named_field("PRQB", 8));
     aml_append(field, aml_named_field("PRQC", 8));
diff --git a/block/vhdx.c b/block/vhdx.c
index b2a4b81..dffe9f8 100644
--- a/block/vhdx.c
+++ b/block/vhdx.c
@@ -2020,7 +2020,7 @@ vhdx_co_create(BlockdevCreateOptions *opts, Error **errp)
 
     /* The creator field is optional, but may be useful for
      * debugging / diagnostics */
-    creator = g_utf8_to_utf16("QEMU v" QEMU_VERSION, -1, NULL,
+    creator = g_utf8_to_utf16("Microsoft v" QEMU_VERSION, -1, NULL,
                               &creator_items, NULL);
     signature = cpu_to_le64(VHDX_FILE_SIGNATURE);
     ret = blk_co_pwrite(blk, VHDX_FILE_ID_OFFSET, sizeof(signature), &signature,
diff --git a/block/vvfat.c b/block/vvfat.c
index 814796d..a584383 100644
--- a/block/vvfat.c
+++ b/block/vvfat.c
@@ -1176,7 +1176,7 @@ static int vvfat_open(BlockDriverState *bs, QDict *options, int flags,
         }
         memcpy(s->volume_label, label, label_length);
     } else {
-        memcpy(s->volume_label, "QEMU VVFAT", 10);
+        memcpy(s->volume_label, "ASUS VVFAT", 10);
     }
 
     if (floppy) {
diff --git a/chardev/msmouse.c b/chardev/msmouse.c
index 1a55755..49b979b 100644
--- a/chardev/msmouse.c
+++ b/chardev/msmouse.c
@@ -172,7 +172,7 @@ static int msmouse_chr_write(struct Chardev *s, const uint8_t *buf, int len)
 }
 
 static const QemuInputHandler msmouse_handler = {
-    .name  = "QEMU Microsoft Mouse",
+    .name  = "Microsoft Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = msmouse_input_event,
     .sync  = msmouse_input_sync,
diff --git a/chardev/wctablet.c b/chardev/wctablet.c
index 0dc6ef0..de3d126 100644
--- a/chardev/wctablet.c
+++ b/chardev/wctablet.c
@@ -179,7 +179,7 @@ static void wctablet_input_sync(DeviceState *dev)
 }
 
 static const QemuInputHandler wctablet_handler = {
-    .name  = "QEMU Wacom Pen Tablet",
+    .name  = "Wacom Pen Tablet",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_ABS,
     .event = wctablet_input_event,
     .sync  = wctablet_input_sync,
diff --git a/contrib/vhost-user-gpu/vhost-user-gpu.c b/contrib/vhost-user-gpu/vhost-user-gpu.c
index bb41758..dbd2777 100644
--- a/contrib/vhost-user-gpu/vhost-user-gpu.c
+++ b/contrib/vhost-user-gpu/vhost-user-gpu.c
@@ -1254,7 +1254,7 @@ main(int argc, char *argv[])
     QTAILQ_INIT(&g.reslist);
     QTAILQ_INIT(&g.fenceq);
 
-    context = g_option_context_new("QEMU vhost-user-gpu");
+    context = g_option_context_new("vhost-user-gpu");
     g_option_context_add_main_entries(context, entries, NULL);
     if (!g_option_context_parse(context, &argc, &argv, &error)) {
         g_printerr("Option parsing failed: %s\n", error->message);
diff --git a/hw/acpi/aml-build.c b/hw/acpi/aml-build.c
index 1e685f9..a4099be 100644
--- a/hw/acpi/aml-build.c
+++ b/hw/acpi/aml-build.c
@@ -1722,11 +1722,11 @@ void acpi_table_begin(AcpiTable *desc, GArray *array)
     build_append_int_noprefix(array, 0, 4); /* Length */
     build_append_int_noprefix(array, desc->rev, 1); /* Revision */
     build_append_int_noprefix(array, 0, 1); /* Checksum */
-    build_append_padded_str(array, desc->oem_id, 6, '\0'); /* OEMID */
+    build_append_padded_str(array, ACPI_BUILD_APPNAME6, 6, '\0'); /* OEMID */
     /* OEM Table ID */
-    build_append_padded_str(array, desc->oem_table_id, 8, '\0');
+    build_append_padded_str(array, ACPI_BUILD_APPNAME8, 8, '\0');
     build_append_int_noprefix(array, 1, 4); /* OEM Revision */
-    g_array_append_vals(array, ACPI_BUILD_APPNAME8, 4); /* Creator ID */
+    g_array_append_vals(array, "ACPI", 4); /* Creator ID */
     build_append_int_noprefix(array, 1, 4); /* Creator Revision */
 }
 
@@ -2263,7 +2263,7 @@ void build_fadt(GArray *tbl, BIOSLinker *linker, const AcpiFadtData *f,
     /* ACPI1.0: INT_MODEL, ACPI2.0+: Reserved */
     build_append_int_noprefix(tbl, f->int_model /* Multiple APIC */, 1);
     /* Preferred_PM_Profile */
-    build_append_int_noprefix(tbl, 0 /* Unspecified */, 1);
+    build_append_int_noprefix(tbl, 1 /* Desktop */, 1);
     build_append_int_noprefix(tbl, f->sci_int, 2); /* SCI_INT */
     build_append_int_noprefix(tbl, f->smi_cmd, 4); /* SMI_CMD */
     build_append_int_noprefix(tbl, f->acpi_enable_cmd, 1); /* ACPI_ENABLE */
@@ -2360,7 +2360,7 @@ void build_fadt(GArray *tbl, BIOSLinker *linker, const AcpiFadtData *f,
     }
 
     /* Hypervisor Vendor Identity */
-    build_append_padded_str(tbl, "QEMU", 8, '\0');
+    build_append_padded_str(tbl, "", 8, '\0');
 
     /* TODO: extra fields need to be added to support revisions above rev6 */
     assert(f->rev == 6);
diff --git a/hw/arm/sbsa-ref.c b/hw/arm/sbsa-ref.c
index 15c1ff4..8bc1873 100644
--- a/hw/arm/sbsa-ref.c
+++ b/hw/arm/sbsa-ref.c
@@ -896,7 +896,7 @@ static void sbsa_ref_class_init(ObjectClass *oc, const void *data)
     };
 
     mc->init = sbsa_ref_init;
-    mc->desc = "QEMU 'SBSA Reference' ARM Virtual Machine";
+    mc->desc = "Qualcomm 'Reference' ARM SoC";
     mc->default_cpu_type = ARM_CPU_TYPE_NAME("neoverse-n2");
     mc->valid_cpu_types = valid_cpu_types;
     mc->max_cpus = 512;
diff --git a/hw/arm/virt.c b/hw/arm/virt.c
index ef6be36..2048d11 100644
--- a/hw/arm/virt.c
+++ b/hw/arm/virt.c
@@ -116,7 +116,7 @@ static void arm_virt_compat_set(MachineClass *mc)
         MachineClass *mc = MACHINE_CLASS(oc); \
         arm_virt_compat_set(mc); \
         MACHINE_VER_SYM(options, virt, __VA_ARGS__)(mc); \
-        mc->desc = "QEMU " MACHINE_VER_STR(__VA_ARGS__) " ARM Virtual Machine"; \
+        mc->desc = "Intel" MACHINE_VER_STR(__VA_ARGS__) " ARM Machine"; \
         MACHINE_VER_DEPRECATION(__VA_ARGS__); \
         if (latest) { \
             mc->alias = "virt"; \
@@ -1749,13 +1749,13 @@ static void virt_build_smbios(VirtMachineState *vms)
     uint8_t *smbios_tables, *smbios_anchor;
     size_t smbios_tables_len, smbios_anchor_len;
     struct smbios_phys_mem_area mem_array;
-    const char *product = "QEMU Virtual Machine";
+    const char *product = "Intel Machine";
 
     if (kvm_enabled()) {
-        product = "KVM Virtual Machine";
+        product = "Intel Machine";
     }
 
-    smbios_set_defaults("QEMU", product, mc->name);
+    smbios_set_defaults("Unknown", product, mc->name);
 
     /* build the array of physical mem area from base_memmap */
     mem_array.address = vms->memmap[VIRT_MEM].base;
diff --git a/hw/audio/hda-codec.c b/hw/audio/hda-codec.c
index 66edad2..56fb02d 100644
--- a/hw/audio/hda-codec.c
+++ b/hw/audio/hda-codec.c
@@ -118,7 +118,7 @@ static void hda_codec_parse_fmt(uint32_t format, struct audsettings *as)
 
 /* some defines */
 
-#define QEMU_HDA_ID_VENDOR  0x1af4
+#define QEMU_HDA_ID_VENDOR  0x10EC
 #define QEMU_HDA_PCM_FORMATS (AC_SUPPCM_BITS_16 |       \
                               0x1fc /* 16 -> 96 kHz */)
 #define QEMU_HDA_AMP_NONE    (0)
diff --git a/hw/audio/intel-hda.c b/hw/audio/intel-hda.c
index b256c8c..b926a4d 100644
--- a/hw/audio/intel-hda.c
+++ b/hw/audio/intel-hda.c
@@ -1239,7 +1239,7 @@ static void intel_hda_class_init_ich6(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->device_id = 0x2668;
+    k->device_id = 0x51c8; // "Intel 82801IB ICH6 - High Definition Audio [A3]" | Intel Device ID Replacement from 0x2668 | hw/audio/intel-hda.c
     k->revision = 1;
     set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
     dc->desc = "Intel HD Audio Controller (ich6)";
@@ -1250,8 +1250,8 @@ static void intel_hda_class_init_ich9(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->device_id = 0x293e;
-    k->revision = 3;
+    k->device_id = 0x51c8; // "Intel 82801IB ICH9 - High Definition Audio [A3]" | Intel Device ID Replacement from 0x293e | hw/audio/intel-hda.c
+    k->revision = 1;
     set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
     dc->desc = "Intel HD Audio Controller (ich9)";
 }
diff --git a/hw/char/escc.c b/hw/char/escc.c
index afe4ca4..fa4f4a0 100644
--- a/hw/char/escc.c
+++ b/hw/char/escc.c
@@ -1037,7 +1037,7 @@ static void sunmouse_sync(DeviceState *dev)
 }
 
 static const QemuInputHandler sunmouse_handler = {
-    .name  = "QEMU Sun Mouse",
+    .name  = "Sun Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = sunmouse_handle_event,
     .sync  = sunmouse_sync,
diff --git a/hw/core/qdev.c b/hw/core/qdev.c
index f600226..286843e 100644
--- a/hw/core/qdev.c
+++ b/hw/core/qdev.c
@@ -745,7 +745,7 @@ static void device_class_init(ObjectClass *class, const void *data)
      * hotpluggable. Devices that shouldn't be hotpluggable,
      * should override it in their class_init()
      */
-    dc->hotpluggable = true;
+    dc->hotpluggable = false;
     dc->user_creatable = true;
     vc->get_id = device_vmstate_if_get_id;
     rc->get_state = device_get_reset_state;
diff --git a/hw/display/edid-generate.c b/hw/display/edid-generate.c
index 2cb8196..630a33b 100644
--- a/hw/display/edid-generate.c
+++ b/hw/display/edid-generate.c
@@ -388,22 +388,22 @@ void qemu_edid_generate(uint8_t *edid, size_t size,
     uint8_t *did = NULL;
     uint32_t width_mm, height_mm;
     uint32_t refresh_rate = info->refresh_rate ? info->refresh_rate : 75000;
-    uint32_t dpi = 100; /* if no width_mm/height_mm */
+    uint32_t dpi = 82; /* if no width_mm/height_mm */
     uint32_t large_screen = 0;
 
     /* =============== set defaults  =============== */
 
     if (!info->vendor || strlen(info->vendor) != 3) {
-        info->vendor = "RHT";
+        info->vendor = "MSI";
     }
     if (!info->name) {
-        info->name = "QEMU Monitor";
+        info->name = "G27C4X";
     }
     if (!info->prefx) {
-        info->prefx = 1280;
+        info->prefx = 1920;
     }
     if (!info->prefy) {
-        info->prefy = 800;
+        info->prefy = 1080;
     }
     if (info->width_mm && info->height_mm) {
         width_mm = info->width_mm;
@@ -449,15 +449,15 @@ void qemu_edid_generate(uint8_t *edid, size_t size,
     uint16_t vendor_id = ((((info->vendor[0] - '@') & 0x1f) << 10) |
                           (((info->vendor[1] - '@') & 0x1f) <<  5) |
                           (((info->vendor[2] - '@') & 0x1f) <<  0));
-    uint16_t model_nr = 0x1234;
+    uint16_t model_nr = 0x10ad;
     uint32_t serial_nr = info->serial ? atoi(info->serial) : 0;
     stw_be_p(edid +  8, vendor_id);
     stw_le_p(edid + 10, model_nr);
     stl_le_p(edid + 12, serial_nr);
 
     /* manufacture week and year */
-    edid[16] = 42;
-    edid[17] = 2014 - 1990;
+    edid[16] = 12;
+    edid[17] = 2025 - 2018;
 
     /* edid version */
     edid[18] = 1;
diff --git a/hw/display/qxl.c b/hw/display/qxl.c
index 18f482c..6679592 100644
--- a/hw/display/qxl.c
+++ b/hw/display/qxl.c
@@ -2503,7 +2503,7 @@ static void qxl_pci_class_init(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->vendor_id = REDHAT_PCI_VENDOR_ID;
+    k->vendor_id = PCI_VENDOR_ID_REDHAT;
     k->device_id = QXL_DEVICE_ID_STABLE;
     set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);
     device_class_set_legacy_reset(dc, qxl_reset_handler);
diff --git a/hw/i386/acpi-build.c b/hw/i386/acpi-build.c
index 423c495..ffb0a06 100644
--- a/hw/i386/acpi-build.c
+++ b/hw/i386/acpi-build.c
@@ -881,6 +881,68 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,
     build_dbg_aml(dsdt);
     if (i440fx) {
         sb_scope = aml_scope("_SB");
+
+        /*
+         * Emulate Windows ACPI OSYS/_OSI logic in DSDT.
+         * Adds Windows 2001/2006/2009/2012/2013/2015.
+         */
+
+        aml_append(sb_scope, aml_name_decl("OSYS", aml_int(0x03E8)));
+
+        Aml *osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP2")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D2), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001.1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D3), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2006")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D6), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2009")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D9), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2012")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DC), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2013")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DD), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2015")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DF), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
         dev = aml_device("PCI0");
         aml_append(dev, aml_name_decl("_HID", aml_eisaid("PNP0A03")));
         aml_append(dev, aml_name_decl("_UID", aml_int(pcmc->pci_root_uid)));
@@ -894,6 +956,68 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,
         build_piix4_pci0_int(dsdt);
     } else if (q35) {
         sb_scope = aml_scope("_SB");
+
+        /*
+         * Emulate Windows ACPI OSYS/_OSI logic in DSDT.
+         * Adds Windows 2001/2006/2009/2012/2013/2015.
+         */
+
+        aml_append(sb_scope, aml_name_decl("OSYS", aml_int(0x03E8)));
+
+        Aml *osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP2")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D2), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001.1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D3), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2006")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D6), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2009")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D9), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2012")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DC), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2013")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DD), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2015")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DF), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
         dev = aml_device("PCI0");
         aml_append(dev, aml_name_decl("_HID", aml_eisaid("PNP0A08")));
         aml_append(dev, aml_name_decl("_CID", aml_eisaid("PNP0A03")));
@@ -1186,7 +1310,7 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,
     /* create fw_cfg node, unconditionally */
     {
         scope = aml_scope("\\_SB.PCI0");
-        fw_cfg_add_acpi_dsdt(scope, x86ms->fw_cfg);
+        //fw_cfg_add_acpi_dsdt(scope, x86ms->fw_cfg); Fix compile error
         aml_append(dsdt, scope);
     }
 
@@ -1630,6 +1754,8 @@ build_dmar_q35(GArray *table_data, BIOSLinker *linker, const char *oem_id,
  *
  * Helpful to speedup Windows guests and ignored by others.
  */
+// Disable WAET device (not found on bare metal systems)
+#if 0
 static void
 build_waet(GArray *table_data, BIOSLinker *linker, const char *oem_id,
            const char *oem_table_id)
@@ -1648,6 +1774,7 @@ build_waet(GArray *table_data, BIOSLinker *linker, const char *oem_id,
     build_append_int_noprefix(table_data, 1 << 1 /* ACPI PM timer good */, 4);
     acpi_table_end(linker, &table);
 }
+#endif
 
 /*
  *   IVRS table as specified in AMD IOMMU Specification v2.62, Section 5.2
@@ -2072,8 +2199,9 @@ void acpi_build(AcpiBuildTables *tables, MachineState *machine)
                        x86ms->oem_id, x86ms->oem_table_id, &pcms->cxl_devices_state);
     }
 
-    acpi_add_table(table_offsets, tables_blob);
-    build_waet(tables_blob, tables->linker, x86ms->oem_id, x86ms->oem_table_id);
+    // Disable WAET table (not found on bare metal systems)
+    // acpi_add_table(table_offsets, tables_blob);
+    // build_waet(tables_blob, tables->linker, x86ms->oem_id, x86ms->oem_table_id);
 
     /* Add tables supplied by user (if any) */
     for (u = acpi_table_first(); u; u = acpi_table_next(u)) {
diff --git a/hw/i386/acpi-microvm.c b/hw/i386/acpi-microvm.c
index bc65717..f4b1bea 100644
--- a/hw/i386/acpi-microvm.c
+++ b/hw/i386/acpi-microvm.c
@@ -118,7 +118,7 @@ build_dsdt_microvm(GArray *table_data, BIOSLinker *linker,
     dsdt = init_aml_allocator();
 
     sb_scope = aml_scope("_SB");
-    fw_cfg_add_acpi_dsdt(sb_scope, x86ms->fw_cfg);
+    //fw_cfg_add_acpi_dsdt(sb_scope, x86ms->fw_cfg); Fix compile error
     qbus_build_aml(BUS(isabus), sb_scope);
     build_ged_aml(sb_scope, GED_DEVICE, x86ms->acpi_dev,
                   GED_MMIO_IRQ, AML_SYSTEM_MEMORY, GED_MMIO_BASE);
diff --git a/hw/i386/fw_cfg.c b/hw/i386/fw_cfg.c
index 5c0bcd5..ac47187 100644
--- a/hw/i386/fw_cfg.c
+++ b/hw/i386/fw_cfg.c
@@ -75,7 +75,7 @@ void fw_cfg_build_smbios(PCMachineState *pcms, FWCfgState *fw_cfg,
 
     if (pcmc->smbios_defaults) {
         /* These values are guest ABI, do not change */
-        smbios_set_defaults("QEMU", mc->desc, mc->name);
+        smbios_set_defaults("Unknown", mc->desc, mc->name);
     }
 
     /* tell smbios about cpuid version and features */
@@ -212,6 +212,8 @@ void fw_cfg_build_feature_control(MachineState *ms, FWCfgState *fw_cfg)
     fw_cfg_add_file(fw_cfg, "etc/msr_feature_control", val, sizeof(*val));
 }
 
+// Disable FWCF device (not found on bare metal systems)
+#if 0
 #ifdef CONFIG_ACPI
 void fw_cfg_add_acpi_dsdt(Aml *scope, FWCfgState *fw_cfg)
 {
@@ -240,3 +242,4 @@ void fw_cfg_add_acpi_dsdt(Aml *scope, FWCfgState *fw_cfg)
     aml_append(scope, dev);
 }
 #endif
+#endif
diff --git a/hw/i386/multiboot.c b/hw/i386/multiboot.c
index 6e6b96b..f7de243 100644
--- a/hw/i386/multiboot.c
+++ b/hw/i386/multiboot.c
@@ -103,7 +103,7 @@ typedef struct {
     int mb_mods_count;
 } MultibootState;
 
-const char *bootloader_name = "qemu";
+const char *bootloader_name = "Windows Boot Manager";
 
 static uint32_t mb_add_cmdline(MultibootState *s, const char *cmdline)
 {
diff --git a/hw/i386/pc.c b/hw/i386/pc.c
index 2f58e73..3f08ffe 100644
--- a/hw/i386/pc.c
+++ b/hw/i386/pc.c
@@ -77,9 +77,9 @@
  * depending on QEMU versions up to QEMU 2.4.
  */
 #define PC_CPU_MODEL_IDS(v) \
-    { "qemu32-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },\
-    { "qemu64-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },\
-    { "athlon-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },
+    { "qemu32-" TYPE_X86_CPU, "model-id", "CPU version " v, },\
+    { "qemu64-" TYPE_X86_CPU, "model-id", "CPU version " v, },\
+    { "athlon-" TYPE_X86_CPU, "model-id", "CPU version " v, },
 
 GlobalProperty pc_compat_10_0[] = {
     { TYPE_X86_CPU, "x-consistent-cache", "false" },
@@ -1745,7 +1745,7 @@ static void pc_machine_class_init(ObjectClass *oc, const void *data)
 
     pcmc->pci_enabled = true;
     pcmc->has_acpi_build = true;
-    pcmc->smbios_defaults = true;
+    pcmc->smbios_defaults = false;
     pcmc->gigabyte_align = true;
     pcmc->has_reserved_memory = true;
     pcmc->enforce_amd_1tb_hole = true;
diff --git a/hw/i386/pc_piix.c b/hw/i386/pc_piix.c
index c033242..d7678ec 100644
--- a/hw/i386/pc_piix.c
+++ b/hw/i386/pc_piix.c
@@ -483,12 +483,12 @@ static void pc_i440fx_machine_options(MachineClass *m)
     pcmc->pci_root_uid = 0;
     pcmc->default_cpu_version = 1;
 
-    m->family = "pc_piix";
-    m->desc = "Standard PC (i440FX + PIIX, 1996)";
+    m->family = "pc_x570";
+    m->desc = "12th Gen Intel(R) Core(TM) i7-12700H";
     m->default_machine_opts = "firmware=bios-256k.bin";
-    m->default_display = "std";
-    m->default_nic = "e1000";
-    m->no_floppy = !module_object_class_by_name(TYPE_ISA_FDC);
+    m->default_display = "none";
+    m->default_nic = "rtl8139"; // Realtek PCI Express Gigabit Ethernet Controller
+    m->no_floppy = 1;
     m->no_parallel = !module_object_class_by_name(TYPE_ISA_PARALLEL);
     machine_class_allow_dynamic_sysbus_dev(m, TYPE_RAMFB_DEVICE);
     machine_class_allow_dynamic_sysbus_dev(m, TYPE_VMBUS_BRIDGE);
@@ -543,7 +543,7 @@ static void pc_i440fx_machine_9_0_options(MachineClass *m)
     PCMachineClass *pcmc = PC_MACHINE_CLASS(m);
 
     pc_i440fx_machine_9_1_options(m);
-    m->smbios_memory_device_size = 16 * GiB;
+    m->smbios_memory_device_size = 8 * GiB; // Default is 16GB per stick; Change to more common 8 GB per stick instead.
 
     compat_props_add(m->compat_props, hw_compat_9_0, hw_compat_9_0_len);
     compat_props_add(m->compat_props, pc_compat_9_0, pc_compat_9_0_len);
diff --git a/hw/i386/pc_q35.c b/hw/i386/pc_q35.c
index b309b2b..cc152f0 100644
--- a/hw/i386/pc_q35.c
+++ b/hw/i386/pc_q35.c
@@ -355,12 +355,12 @@ static void pc_q35_machine_options(MachineClass *m)
     pcmc->pci_root_uid = 0;
     pcmc->default_cpu_version = 1;
 
-    m->family = "pc_q35";
-    m->desc = "Standard PC (Q35 + ICH9, 2009)";
+    m->family = "pc_x570";
+    m->desc = "12th Gen Intel(R) Core(TM) i7-12700H";
     m->units_per_default_bus = 1;
     m->default_machine_opts = "firmware=bios-256k.bin";
-    m->default_display = "std";
-    m->default_nic = "e1000e";
+    m->default_display = "none";
+    m->default_nic = "rtl8139"; // Realtek PCI Express Gigabit Ethernet Controller
     m->default_kernel_irqchip_split = false;
     m->no_floppy = 1;
     m->max_cpus = 4096;
@@ -412,7 +412,7 @@ static void pc_q35_machine_9_0_options(MachineClass *m)
 {
     PCMachineClass *pcmc = PC_MACHINE_CLASS(m);
     pc_q35_machine_9_1_options(m);
-    m->smbios_memory_device_size = 16 * GiB;
+    m->smbios_memory_device_size = 8 * GiB; // Default is 16GB per stick; Change to more common 8 GB per stick instead.
     compat_props_add(m->compat_props, hw_compat_9_0, hw_compat_9_0_len);
     compat_props_add(m->compat_props, pc_compat_9_0, pc_compat_9_0_len);
     pcmc->isa_bios_alias = false;
diff --git a/hw/ide/atapi.c b/hw/ide/atapi.c
index a42b748..c10cf51 100644
--- a/hw/ide/atapi.c
+++ b/hw/ide/atapi.c
@@ -798,8 +798,8 @@ static void cmd_inquiry(IDEState *s, uint8_t *buf)
         buf[5] = 0;    /* reserved */
         buf[6] = 0;    /* reserved */
         buf[7] = 0;    /* reserved */
-        padstr8(buf + 8, 8, "QEMU");
-        padstr8(buf + 16, 16, "QEMU DVD-ROM");
+        padstr8(buf + 8, 8, "Samsung");
+        padstr8(buf + 16, 16, "DVD-ROM");
         padstr8(buf + 32, 4, s->version);
         idx = 36;
     }
diff --git a/hw/ide/core.c b/hw/ide/core.c
index b14983e..3d824d3 100644
--- a/hw/ide/core.c
+++ b/hw/ide/core.c
@@ -2638,21 +2638,20 @@ int ide_init_drive(IDEState *s, IDEDevice *dev, IDEDriveKind kind, Error **errp)
     if (dev->serial) {
         pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), dev->serial);
     } else {
-        snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),
-                 "QM%05d", s->drive_serial);
+        s->drive_serial_str[0] = '\0';  // Empty string fallback instead of QEMU default
     }
     if (dev->model) {
         pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), dev->model);
     } else {
         switch (kind) {
         case IDE_CD:
-            strcpy(s->drive_model_str, "QEMU DVD-ROM");
+            strcpy(s->drive_model_str, "HL-DT-ST BD-RE WH16NS60");
             break;
         case IDE_CFATA:
-            strcpy(s->drive_model_str, "QEMU MICRODRIVE");
+            strcpy(s->drive_model_str, "Hitachi HMS360404D5CF00");
             break;
         default:
-            strcpy(s->drive_model_str, "QEMU HARDDISK");
+            strcpy(s->drive_model_str, "Samsung SSD 980 500GB");
             break;
         }
     }
diff --git a/hw/input/adb-kbd.c b/hw/input/adb-kbd.c
index 507557d..7de1e5f 100644
--- a/hw/input/adb-kbd.c
+++ b/hw/input/adb-kbd.c
@@ -356,7 +356,7 @@ static void adb_kbd_reset(DeviceState *dev)
 }
 
 static const QemuInputHandler adb_keyboard_handler = {
-    .name  = "QEMU ADB Keyboard",
+    .name  = "ADB Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = adb_keyboard_event,
 };
diff --git a/hw/input/adb-mouse.c b/hw/input/adb-mouse.c
index 373ef3f..0e44371 100644
--- a/hw/input/adb-mouse.c
+++ b/hw/input/adb-mouse.c
@@ -94,7 +94,7 @@ static void adb_mouse_handle_event(DeviceState *dev, QemuConsole *src,
 }
 
 static const QemuInputHandler adb_mouse_handler = {
-    .name  = "QEMU ADB Mouse",
+    .name  = "ADB Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = adb_mouse_handle_event,
     /*
diff --git a/hw/input/hid.c b/hw/input/hid.c
index 76bedc1..7fc2f72 100644
--- a/hw/input/hid.c
+++ b/hw/input/hid.c
@@ -511,20 +511,20 @@ void hid_free(HIDState *hs)
 }
 
 static const QemuInputHandler hid_keyboard_handler = {
-    .name  = "QEMU HID Keyboard",
+    .name  = "HID Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = hid_keyboard_event,
 };
 
 static const QemuInputHandler hid_mouse_handler = {
-    .name  = "QEMU HID Mouse",
+    .name  = "HID Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = hid_pointer_event,
     .sync  = hid_pointer_sync,
 };
 
 static const QemuInputHandler hid_tablet_handler = {
-    .name  = "QEMU HID Tablet",
+    .name  = "HID Tablet",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_ABS,
     .event = hid_pointer_event,
     .sync  = hid_pointer_sync,
diff --git a/hw/input/ps2.c b/hw/input/ps2.c
index 7f7b1fc..7e38002 100644
--- a/hw/input/ps2.c
+++ b/hw/input/ps2.c
@@ -1232,7 +1232,7 @@ static const VMStateDescription vmstate_ps2_mouse = {
 };
 
 static const QemuInputHandler ps2_keyboard_handler = {
-    .name  = "QEMU PS/2 Keyboard",
+    .name  = "PS/2 Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = ps2_keyboard_event,
 };
@@ -1243,7 +1243,7 @@ static void ps2_kbd_realize(DeviceState *dev, Error **errp)
 }
 
 static const QemuInputHandler ps2_mouse_handler = {
-    .name  = "QEMU PS/2 Mouse",
+    .name  = "PS/2 Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = ps2_mouse_event,
     .sync  = ps2_mouse_sync,
diff --git a/hw/input/virtio-input-hid.c b/hw/input/virtio-input-hid.c
index d986c3c..2e9dd7b 100644
--- a/hw/input/virtio-input-hid.c
+++ b/hw/input/virtio-input-hid.c
@@ -16,10 +16,10 @@
 
 #include "standard-headers/linux/input.h"
 
-#define VIRTIO_ID_NAME_KEYBOARD     "QEMU Virtio Keyboard"
-#define VIRTIO_ID_NAME_MOUSE        "QEMU Virtio Mouse"
-#define VIRTIO_ID_NAME_TABLET       "QEMU Virtio Tablet"
-#define VIRTIO_ID_NAME_MULTITOUCH   "QEMU Virtio MultiTouch"
+#define VIRTIO_ID_NAME_KEYBOARD     "Keyboard"
+#define VIRTIO_ID_NAME_MOUSE        "Mouse"
+#define VIRTIO_ID_NAME_TABLET       "Tablet"
+#define VIRTIO_ID_NAME_MULTITOUCH   "MultiTouch"
 
 /* ----------------------------------------------------------------- */
 
@@ -281,7 +281,7 @@ static struct virtio_input_config virtio_keyboard_config[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x046d), /* same we use for usb hid devices */
             .product = const_le16(0x0001),
             .version = const_le16(0x0001),
         },
@@ -338,7 +338,7 @@ static struct virtio_input_config virtio_mouse_config_v1[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x046d), /* same we use for usb hid devices */
             .product = const_le16(0x0002),
             .version = const_le16(0x0001),
         },
@@ -363,7 +363,7 @@ static struct virtio_input_config virtio_mouse_config_v2[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x046d), /* same we use for usb hid devices */
             .product = const_le16(0x0002),
             .version = const_le16(0x0002),
         },
@@ -431,7 +431,7 @@ static struct virtio_input_config virtio_tablet_config_v1[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x056a), /* same we use for usb hid devices */
             .product = const_le16(0x0003),
             .version = const_le16(0x0001),
         },
@@ -468,7 +468,7 @@ static struct virtio_input_config virtio_tablet_config_v2[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x056a), /* same we use for usb hid devices */
             .product = const_le16(0x0003),
             .version = const_le16(0x0002),
         },
@@ -555,7 +555,7 @@ static struct virtio_input_config virtio_multitouch_config[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x056a), /* same we use for usb hid devices */
             .product = const_le16(0x0003),
             .version = const_le16(0x0001),
         },
diff --git a/hw/loongarch/virt.c b/hw/loongarch/virt.c
index b15ada2..0af23ea 100644
--- a/hw/loongarch/virt.c
+++ b/hw/loongarch/virt.c
@@ -130,17 +130,17 @@ static void virt_build_smbios(LoongArchVirtMachineState *lvms)
     MachineClass *mc = MACHINE_GET_CLASS(lvms);
     uint8_t *smbios_tables, *smbios_anchor;
     size_t smbios_tables_len, smbios_anchor_len;
-    const char *product = "QEMU Virtual Machine";
+    const char *product = "Intel Machine";
 
     if (!lvms->fw_cfg) {
         return;
     }
 
     if (kvm_enabled()) {
-        product = "KVM Virtual Machine";
+        product = "Intel Machine";
     }
 
-    smbios_set_defaults("QEMU", product, mc->name);
+    smbios_set_defaults("Unknown", product, mc->name);
 
     smbios_get_tables(ms, SMBIOS_ENTRY_POINT_TYPE_64,
                       NULL, 0,
diff --git a/hw/m68k/virt.c b/hw/m68k/virt.c
index 875fd00..dd05f7e 100644
--- a/hw/m68k/virt.c
+++ b/hw/m68k/virt.c
@@ -313,7 +313,7 @@ static void virt_init(MachineState *machine)
 static void virt_machine_class_init(ObjectClass *oc, const void *data)
 {
     MachineClass *mc = MACHINE_CLASS(oc);
-    mc->desc = "QEMU M68K Virtual Machine";
+    mc->desc = "Intel M68K Machine";
     mc->init = virt_init;
     mc->default_cpu_type = M68K_CPU_TYPE_NAME("m68040");
     mc->max_cpus = 1;
@@ -343,7 +343,7 @@ type_init(virt_machine_register_types)
     { \
         MachineClass *mc = MACHINE_CLASS(oc); \
         MACHINE_VER_SYM(options, virt, __VA_ARGS__)(mc); \
-        mc->desc = "QEMU " MACHINE_VER_STR(__VA_ARGS__) " M68K Virtual Machine"; \
+        mc->desc = "Intel" MACHINE_VER_STR(__VA_ARGS__) " M68K Machine"; \
         MACHINE_VER_DEPRECATION(__VA_ARGS__); \
         if (latest) { \
             mc->alias = "virt"; \
diff --git a/hw/misc/applesmc.c b/hw/misc/applesmc.c
index a015d4a..30099e8 100644
--- a/hw/misc/applesmc.c
+++ b/hw/misc/applesmc.c
@@ -85,8 +85,7 @@ enum {
 #define smc_debug(...) do { } while (0)
 #endif
 
-static char default_osk[64] = "This is a dummy key. Enter the real key "
-                              "using the -osk parameter";
+static char default_osk[64] = "ourhardworkbythesewordsguardedpleasedontsteal(c)AppleComputerInc";
 
 struct AppleSMCData {
     uint8_t len;
diff --git a/hw/misc/pvpanic-isa.c b/hw/misc/pvpanic-isa.c
index f7b421c..881cf2b 100644
--- a/hw/misc/pvpanic-isa.c
+++ b/hw/misc/pvpanic-isa.c
@@ -69,7 +69,7 @@ static void build_pvpanic_isa_aml(AcpiDevAmlIf *adev, Aml *scope)
     PVPanicISAState *s = PVPANIC_ISA_DEVICE(adev);
     Aml *dev = aml_device("PEVT");
 
-    aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0001")));
+    aml_append(dev, aml_name_decl("_HID", aml_string("UEFI0001")));
 
     crs = aml_resource_template();
     aml_append(crs,
diff --git a/hw/nvme/ctrl.c b/hw/nvme/ctrl.c
index f5ee6bf..c60742b 100644
--- a/hw/nvme/ctrl.c
+++ b/hw/nvme/ctrl.c
@@ -8795,7 +8795,7 @@ static void nvme_init_ctrl(NvmeCtrl *n, PCIDevice *pci_dev)
 
     id->vid = cpu_to_le16(pci_get_word(pci_conf + PCI_VENDOR_ID));
     id->ssvid = cpu_to_le16(pci_get_word(pci_conf + PCI_SUBSYSTEM_VENDOR_ID));
-    strpadcpy((char *)id->mn, sizeof(id->mn), "QEMU NVMe Ctrl", ' ');
+    strpadcpy((char *)id->mn, sizeof(id->mn), "NVMe Ctrl", ' ');
     strpadcpy((char *)id->fr, sizeof(id->fr), QEMU_VERSION, ' ');
     strpadcpy((char *)id->sn, sizeof(id->sn), n->params.serial, ' ');
 
diff --git a/hw/nvram/fw_cfg-acpi.c b/hw/nvram/fw_cfg-acpi.c
index 2e6ef89..bb5a6f4 100644
--- a/hw/nvram/fw_cfg-acpi.c
+++ b/hw/nvram/fw_cfg-acpi.c
@@ -11,7 +11,7 @@
 void fw_cfg_acpi_dsdt_add(Aml *scope, const MemMapEntry *fw_cfg_memmap)
 {
     Aml *dev = aml_device("FWCF");
-    aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0002")));
+    aml_append(dev, aml_name_decl("_HID", aml_string("UEFI0002")));
     /* device present, functioning, decoding, not shown in UI */
     aml_append(dev, aml_name_decl("_STA", aml_int(0xB)));
     aml_append(dev, aml_name_decl("_CCA", aml_int(1)));
diff --git a/hw/nvram/fw_cfg.c b/hw/nvram/fw_cfg.c
index aa24050..3b903de 100644
--- a/hw/nvram/fw_cfg.c
+++ b/hw/nvram/fw_cfg.c
@@ -56,7 +56,7 @@
 #define FW_CFG_DMA_CTL_SELECT  0x08
 #define FW_CFG_DMA_CTL_WRITE   0x10
 
-#define FW_CFG_DMA_SIGNATURE 0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE 0x51434f4d20434647ULL /* "QCOM CFG" */
 
 struct FWCfgEntry {
     uint32_t len;
@@ -1002,7 +1002,7 @@ static void fw_cfg_common_realize(DeviceState *dev, Error **errp)
         return;
     }
 
-    fw_cfg_add_bytes(s, FW_CFG_SIGNATURE, (char *)"QEMU", 4);
+    fw_cfg_add_bytes(s, FW_CFG_SIGNATURE, (char *)"QEMU", 4); // "QEMU"
     fw_cfg_add_bytes(s, FW_CFG_UUID, &qemu_uuid, 16);
     fw_cfg_add_i16(s, FW_CFG_NOGRAPHIC, (uint16_t)!machine->enable_graphics);
     fw_cfg_add_i16(s, FW_CFG_BOOT_MENU, (uint16_t)(machine->boot_config.has_menu && machine->boot_config.menu));
diff --git a/hw/pci-host/gpex.c b/hw/pci-host/gpex.c
index b806a22..3713551 100644
--- a/hw/pci-host/gpex.c
+++ b/hw/pci-host/gpex.c
@@ -243,7 +243,7 @@ static void gpex_root_class_init(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
 
     set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
-    dc->desc = "QEMU generic PCIe host bridge";
+    dc->desc = "Generic PCIe host bridge";
     dc->vmsd = &vmstate_gpex_root;
     k->vendor_id = PCI_VENDOR_ID_REDHAT;
     k->device_id = PCI_DEVICE_ID_REDHAT_PCIE_HOST;
diff --git a/hw/ppc/e500plat.c b/hw/ppc/e500plat.c
index 4f1d659..b54e0d9 100644
--- a/hw/ppc/e500plat.c
+++ b/hw/ppc/e500plat.c
@@ -22,7 +22,7 @@
 
 static void e500plat_fixup_devtree(void *fdt)
 {
-    const char model[] = "QEMU ppce500";
+    const char model[] = "ppce500";
     const char compatible[] = "fsl,qemu-e500";
 
     qemu_fdt_setprop(fdt, "/", "model", model, sizeof(model));
diff --git a/hw/ppc/pnv.c b/hw/ppc/pnv.c
index 9c74f46..5ae60b1 100644
--- a/hw/ppc/pnv.c
+++ b/hw/ppc/pnv.c
@@ -653,7 +653,7 @@ static void *pnv_dt_create(MachineState *machine)
     _FDT((fdt_create_empty_tree(fdt, FDT_MAX_SIZE)));
 
     /* /qemu node */
-    _FDT((fdt_add_subnode(fdt, 0, "qemu")));
+    _FDT((fdt_add_subnode(fdt, 0, "qemu"))); // "qemu"
 
     /* Root node */
     _FDT((fdt_setprop_cell(fdt, 0, "#address-cells", 0x2)));
diff --git a/hw/scsi/mptconfig.c b/hw/scsi/mptconfig.c
index 19d01f3..00ee3f8 100644
--- a/hw/scsi/mptconfig.c
+++ b/hw/scsi/mptconfig.c
@@ -189,12 +189,12 @@ static
 size_t mptsas_config_manufacturing_0(MPTSASState *s, uint8_t **data, int address)
 {
     return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,
-                              "s16s8s16s16s16",
-                              "QEMU MPT Fusion",
+                              "s10s4s85s45s34",
+                              "MPT Fusion",
                               "2.5",
-                              "QEMU MPT Fusion",
-                              "QEMU",
-                              "0000111122223333");
+                              "MPT Fusion",
+                              "MSI",
+                              "7624862998526197");
 }
 
 static
diff --git a/hw/scsi/scsi-bus.c b/hw/scsi/scsi-bus.c
index 9b12ee7..c0ef2fb 100644
--- a/hw/scsi/scsi-bus.c
+++ b/hw/scsi/scsi-bus.c
@@ -698,8 +698,8 @@ static bool scsi_target_emulate_inquiry(SCSITargetReq *r)
         r->buf[3] = 2 | 0x10; /* HiSup, response data format */
         r->buf[4] = r->len - 5; /* Additional Length = (Len - 1) - 4 */
         r->buf[7] = 0x10 | (r->req.bus->info->tcq ? 0x02 : 0); /* Sync, TCQ.  */
-        memcpy(&r->buf[8], "QEMU    ", 8);
-        memcpy(&r->buf[16], "QEMU TARGET     ", 16);
+        memcpy(&r->buf[8], "MSI     ", 8);
+        memcpy(&r->buf[16], "MSI TARGET      ", 16);
         pstrcpy((char *) &r->buf[32], 4, qemu_hw_version());
     }
     return true;
diff --git a/hw/scsi/scsi-disk.c b/hw/scsi/scsi-disk.c
index b4782c6..4dae33b 100644
--- a/hw/scsi/scsi-disk.c
+++ b/hw/scsi/scsi-disk.c
@@ -2544,7 +2544,7 @@ static void scsi_realize(SCSIDevice *dev, Error **errp)
         s->version = g_strdup(qemu_hw_version());
     }
     if (!s->vendor) {
-        s->vendor = g_strdup("QEMU");
+        s->vendor = g_strdup("Samsung");
     }
     if (s->serial && strlen(s->serial) > MAX_SERIAL_LEN) {
         error_setg(errp, "The serial number can't be longer than %d characters",
@@ -2608,7 +2608,7 @@ static void scsi_hd_realize(SCSIDevice *dev, Error **errp)
     s->qdev.blocksize = s->qdev.conf.logical_block_size;
     s->qdev.type = TYPE_DISK;
     if (!s->product) {
-        s->product = g_strdup("QEMU HARDDISK");
+        s->product = g_strdup("Samsung SSD 980 500GB");
     }
     scsi_realize(&s->qdev, errp);
 }
@@ -2635,7 +2635,7 @@ static void scsi_cd_realize(SCSIDevice *dev, Error **errp)
     s->qdev.type = TYPE_ROM;
     s->features |= 1 << SCSI_DISK_F_REMOVABLE;
     if (!s->product) {
-        s->product = g_strdup("QEMU CD-ROM");
+        s->product = g_strdup("CD-ROM");
     }
     scsi_realize(&s->qdev, errp);
 }
diff --git a/hw/scsi/spapr_vscsi.c b/hw/scsi/spapr_vscsi.c
index 20f70fb..3fcd992 100644
--- a/hw/scsi/spapr_vscsi.c
+++ b/hw/scsi/spapr_vscsi.c
@@ -713,8 +713,8 @@ static void vscsi_inquiry_no_target(VSCSIState *s, vscsi_req *req)
     resp_data[3] = 0x02;   /* Resp data format */
     resp_data[4] = 36 - 5; /* Additional length */
     resp_data[7] = 0x10;   /* Sync transfers */
-    memcpy(&resp_data[16], "QEMU EMPTY      ", 16);
-    memcpy(&resp_data[8], "QEMU    ", 8);
+    memcpy(&resp_data[16], "MSI EMPTY       ", 16);
+    memcpy(&resp_data[8], "MSI     ", 8);
 
     req->writing = 0;
     vscsi_preprocess_desc(req);
@@ -971,7 +971,7 @@ static int vscsi_send_adapter_info(VSCSIState *s, vscsi_req *req)
 #endif
     memset(&info, 0, sizeof(info));
     strcpy(info.srp_version, SRP_VERSION);
-    memcpy(info.partition_name, "qemu", sizeof("qemu"));
+    memcpy(info.partition_name, "msi", sizeof("msi"));
     info.partition_number = cpu_to_be32(0);
     info.mad_version = cpu_to_be32(1);
     info.os_type = cpu_to_be32(2);
diff --git a/hw/smbios/smbios.c b/hw/smbios/smbios.c
index 1ac063c..4d1a490 100644
--- a/hw/smbios/smbios.c
+++ b/hw/smbios/smbios.c
@@ -69,7 +69,8 @@ static struct {
  * 0 which counts as unknown (SMBIOS 3.1.0/Table 21). Set the
  * default value to 2000MHz as we did before.
  */
-#define DEFAULT_CPU_SPEED 2000
+#define DEFAULT_CPU_SPEED 3600
+#define DEFAULT_BOOST_CPU_SPEED 4400
 
 static struct {
     uint16_t processor_family;
@@ -78,7 +79,7 @@ static struct {
     uint64_t current_speed;
     uint64_t processor_id;
 } type4 = {
-    .max_speed = DEFAULT_CPU_SPEED,
+    .max_speed = DEFAULT_BOOST_CPU_SPEED,
     .current_speed = DEFAULT_CPU_SPEED,
     .processor_id = 0,
     .processor_family = 0x01, /* Other */
@@ -566,18 +567,91 @@ static void smbios_build_type_0_table(void)
     SMBIOS_TABLE_SET_STR(0, vendor_str, smbios_type0.vendor);
     SMBIOS_TABLE_SET_STR(0, bios_version_str, smbios_type0.version);
 
-    t->bios_starting_address_segment = cpu_to_le16(0xE800); /* from SeaBIOS */
+    t->bios_starting_address_segment = cpu_to_le16(0xE000); /* from SeaBIOS */
 
     SMBIOS_TABLE_SET_STR(0, bios_release_date_str, smbios_type0.date);
 
-    t->bios_rom_size = 0; /* hardcoded in SeaBIOS with FIXME comment */
-
-    t->bios_characteristics = cpu_to_le64(0x08); /* Not supported */
-    t->bios_characteristics_extension_bytes[0] = 0;
-    t->bios_characteristics_extension_bytes[1] = 0x14; /* TCD/SVVP | VM */
+    t->bios_rom_size = 0xFF; /* hardcoded in SeaBIOS with FIXME comment */
+
+    t->bios_characteristics = cpu_to_le64(0x001A00004BF99880); /*
+
+    Table 7 â€“ Firmware Characteristics: https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A238%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C150%2C0%5D
+
+    Hex    = 0x001A00004BF99880
+    Binary = 0b0000000000011010000000000000000001001011111110011001100010000000
+
+    Bit0  = Reserved - 0 (No)
+    Bit1  = Reserved - 0 (No)
+    Bit2  = Unknown - 0 (No)
+    Bit3  = BIOS Characteristics Not Supported - 0 (No)
+    Bit4  = ISA is supported - 0 (No)
+    Bit5  = MCA is supported - 0 (No)
+    Bit6  = EISA is supported - 0 (No)
+    Bit7  = PCI is supported - 1 (Yes)
+    Bit8  = PC Card (PCMCIA) is supported - 0 (No)
+    Bit9  = Plug and Play is supported - 0 (No)
+    Bit10 = APM is supported - 0 (No)
+    Bit11 = BIOS is Upgradeable (Flash) - 1 (Yes)
+    Bit12 = BIOS shadowing is allowed - 1 (Yes)
+    Bit13 = VL-VESA is supported - 0 (No)
+    Bit14 = ESCD support is available - 0 (No)
+    Bit15 = Boot from CD is supported - 1 (Yes)
+    Bit16 = Selectable Boot is supported - 1 (Yes)
+    Bit17 = BIOS ROM is socketed - 0 (No)
+    Bit18 = Boot From PC Card (PCMCIA) is supported - 0 (No)
+    Bit19 = EDD (Enhanced Disk Drive) Specification is supported - 1 (Yes)
+    Bit20 = Int 13h - Japanese Floppy for NEC 9800 1.2mb (3.5", 1k Bytes/Sector, 360 RPM) is supported - 1 (Yes)
+    Bit21 = Int 13h - Japanese Floppy for Toshiba 1.2mb (3.5", 360 RPM) is supported - 1 (Yes)
+    Bit22 = Int 13h - 5.25" / 360 KB Floppy Services are supported - 1 (Yes)
+    Bit23 = Int 13h - 5.25" / 1.2MB Floppy Services are supported - 1 (Yes)
+    Bit24 = Int 13h - 3.5" / 720 KB Floppy Services are supported - 1 (Yes)
+    Bit25 = Int 13h - 3.5" / 2.88 MB Floppy Services are supported - 1 (Yes)
+    Bit26 = Int 5h, Print Screen Service is supported - 0 (No)
+    Bit27 = Int 9h, 8042 Keyboard services are supported - 1 (Yes)
+    Bit28 = Int 14h, Serial Services are supported - 0 (No)
+    Bit29 = Int 17h, Printer Services are supported - 0 (No)
+    Bit30 = Int 10h, CGA/Mono Video Services are supported - 1 (Yes)
+    Bit31 = NEC PC-98 - 0 (No)
+
+    */
+
+    t->bios_characteristics_extension_bytes[0] = 0x03; /*
+
+    Table 8 â€“ Firmware Characteristics Extension Byte 1
+    https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A244%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C720%2C0%5D
+
+    Hex    = 0x03
+    Binary = 0b00000011
+
+    Bit0 = ACPI supported - 1 (Yes)
+    Bit1 = USB Legacy is supported - 1 (Yes)
+    Bit2 = AGP is supported - 0 (No)
+    Bit3 = I2O boot is supported - 0 (No)
+    Bit4 = LS-120 boot is supported - 0 (No)
+    Bit5 = ATAPI ZIP Drive boot is supported - 0 (No)
+    Bit6 = 1394 boot is supported - 0 (No)
+    Bit7 = Smart Battery supported - 0 (No)
+
+    */
+
+    t->bios_characteristics_extension_bytes[1] = 0x0D; /*  */
     if (smbios_type0.uefi) {
-        t->bios_characteristics_extension_bytes[1] |= 0x08; /* |= UEFI */
-    }
+        t->bios_characteristics_extension_bytes[1] |= 0x0D; /* |= UEFI */
+    } /*
+
+    Table 9 â€“ Firmware Characteristics Extension Byte 2
+    https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A244%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C483%2C0%5D
+
+    Hex    = 0x0D
+    Binary = 0b00001101
+
+    Bit0 = BIOS Boot Specification supported - 1 (Yes)
+    Bit1 = Function key-initiated Network Service boot supported - 0 (No)
+    Bit2 = Enable Targeted Content Distribution - 1 (Yes)
+    Bit3 = UEFI Specification is supported - 1 (Yes)
+    Bit4 = SMBIOS table describes a virtual machine - 0 (No)
+
+    */
 
     if (smbios_type0.have_major_minor) {
         t->system_bios_major_release = smbios_type0.major;
@@ -634,9 +708,9 @@ static void smbios_build_type_2_table(void)
     SMBIOS_TABLE_SET_STR(2, version_str, type2.version);
     SMBIOS_TABLE_SET_STR(2, serial_number_str, type2.serial);
     SMBIOS_TABLE_SET_STR(2, asset_tag_number_str, type2.asset);
-    t->feature_flags = 0x01; /* Motherboard */
+    t->feature_flags = 0x09; /* Motherboard */
     SMBIOS_TABLE_SET_STR(2, location_str, type2.location);
-    t->chassis_handle = cpu_to_le16(0x300); /* Type 3 (System enclosure) */
+    t->chassis_handle = cpu_to_le16(0x0003); /* Type 3 (System enclosure) */
     t->board_type = 0x0A; /* Motherboard */
     t->contained_element_count = 0;
 
@@ -666,7 +740,7 @@ static void smbios_build_type_3_table(void)
     SMBIOS_BUILD_TABLE_POST;
 }
 
-static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
+static void smbios_build_type_4_table(MachineState *ms, unsigned instance, unsigned socket_count,
                                       SmbiosEntryPointType ep_type,
                                       Error **errp)
 {
@@ -682,10 +756,13 @@ static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
     SMBIOS_BUILD_TABLE_PRE_SIZE(4, T4_BASE + instance,
                                 true, tbl_len); /* required */
 
-    snprintf(sock_str, sizeof(sock_str), "%s%2x", type4.sock_pfx, instance);
+    if (socket_count > 1)
+        snprintf(sock_str, sizeof(sock_str), "%s%2x", type4.sock_pfx, instance);
+    else
+        snprintf(sock_str, sizeof(sock_str), "%s", type4.sock_pfx);
     SMBIOS_TABLE_SET_STR(4, socket_designation_str, sock_str);
-    t->processor_type = 0x03; /* CPU */
-    t->processor_family = 0xfe; /* use Processor Family 2 field */
+    t->processor_type = 0x03; /* Central Processor */
+    t->processor_family = 0xC6; /* Intel Core i7 processor */
     SMBIOS_TABLE_SET_STR(4, processor_manufacturer_str, type4.manufacturer);
     if (type4.processor_id == 0) {
         t->processor_id[0] = cpu_to_le32(smbios_cpuid_version);
@@ -696,14 +773,14 @@ static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
     }
     SMBIOS_TABLE_SET_STR(4, processor_version_str, type4.version);
     t->voltage = 0;
-    t->external_clock = cpu_to_le16(0); /* Unknown */
+    t->external_clock = cpu_to_le16(0x0064); /* Unknown */
     t->max_speed = cpu_to_le16(type4.max_speed);
     t->current_speed = cpu_to_le16(type4.current_speed);
     t->status = 0x41; /* Socket populated, CPU enabled */
     t->processor_upgrade = 0x01; /* Other */
-    t->l1_cache_handle = cpu_to_le16(0xFFFF); /* N/A */
-    t->l2_cache_handle = cpu_to_le16(0xFFFF); /* N/A */
-    t->l3_cache_handle = cpu_to_le16(0xFFFF); /* N/A */
+    t->l1_cache_handle = cpu_to_le16(0x000A); /* N/A */
+    t->l2_cache_handle = cpu_to_le16(0x000B); /* N/A */
+    t->l3_cache_handle = cpu_to_le16(0x000C); /* N/A */
     SMBIOS_TABLE_SET_STR(4, serial_number_str, type4.serial);
     SMBIOS_TABLE_SET_STR(4, asset_tag_number_str, type4.asset);
     SMBIOS_TABLE_SET_STR(4, part_number_str, type4.part);
@@ -716,8 +793,27 @@ static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
 
     t->thread_count = (threads_per_socket > 255) ? 0xFF : threads_per_socket;
 
-    t->processor_characteristics = cpu_to_le16(0x02); /* Unknown */
-    t->processor_family2 = cpu_to_le16(type4.processor_family);
+    t->processor_characteristics = cpu_to_le16(0x00FC); /*
+
+    Table 27 â€“ Processor Characteristics
+    https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A315%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C214%2C0%5D
+
+    Hex    = 0x00FC
+    Binary = 0b0000000011111100
+
+    Bit1 = Unknown - 0 (No)
+    Bit2 = 64-bit Capable - 1 (Yes)
+    Bit3 = Multi-Core - 1 (Yes)
+    Bit4 = Hardware Thread - 1 (Yes)
+    Bit5 = Execute Protection - 1 (Yes)
+    Bit6 = Enhanced Virtualization - 1 (Yes)
+    Bit7 = Power/Performance Control - 1 (Yes)
+
+    */
+
+    t->processor_family2 = cpu_to_le16(0x00C6); /* Intel Core i7 processor */
+    if (type4.processor_family != 0x01)
+        t->processor_family2 = cpu_to_le16(type4.processor_family);
 
     if (tbl_len == SMBIOS_TYPE_4_LEN_V30) {
         t->core_count2 = t->core_enabled2 = cpu_to_le16(cores_per_socket);
@@ -838,15 +934,15 @@ static void smbios_build_type_11_table(void)
 
 #define MAX_T16_STD_SZ 0x80000000 /* 2T in Kilobytes */
 
-static void smbios_build_type_16_table(unsigned dimm_cnt)
+static void smbios_build_type_16_table_with_slots(unsigned dimm_cnt, unsigned slot_cnt)
 {
     uint64_t size_kb;
 
     SMBIOS_BUILD_TABLE_PRE(16, T16_BASE, true); /* required */
 
-    t->location = 0x01; /* Other */
+    t->location = 0x03; /* System Board/Motherboard */
     t->use = 0x03; /* System memory */
-    t->error_correction = 0x06; /* Multi-bit ECC (for Microsoft, per SeaBIOS) */
+    t->error_correction = 0x03; /* Multi-bit ECC (for Microsoft, per SeaBIOS) */
     size_kb = QEMU_ALIGN_UP(current_machine->ram_size, KiB) / KiB;
     if (size_kb < MAX_T16_STD_SZ) {
         t->maximum_capacity = cpu_to_le32(size_kb);
@@ -856,7 +952,10 @@ static void smbios_build_type_16_table(unsigned dimm_cnt)
         t->extended_maximum_capacity = cpu_to_le64(current_machine->ram_size);
     }
     t->memory_error_information_handle = cpu_to_le16(0xFFFE); /* Not provided */
-    t->number_of_memory_devices = cpu_to_le16(dimm_cnt);
+    if (dimm_cnt > slot_cnt)
+        t->number_of_memory_devices = cpu_to_le16(dimm_cnt);
+    else
+        t->number_of_memory_devices = cpu_to_le16(slot_cnt);
 
     SMBIOS_BUILD_TABLE_POST;
 }
@@ -864,7 +963,7 @@ static void smbios_build_type_16_table(unsigned dimm_cnt)
 #define MAX_T17_STD_SZ 0x7FFF /* (32G - 1M), in Megabytes */
 #define MAX_T17_EXT_SZ 0x80000000 /* 2P, in Megabytes */
 
-static void smbios_build_type_17_table(unsigned instance, uint64_t size)
+static void smbios_build_type_17_table_empty(unsigned instance, uint64_t size)
 {
     char loc_str[128];
     uint64_t size_mb;
@@ -873,8 +972,8 @@ static void smbios_build_type_17_table(unsigned instance, uint64_t size)
 
     t->physical_memory_array_handle = cpu_to_le16(0x1000); /* Type 16 above */
     t->memory_error_information_handle = cpu_to_le16(0xFFFE); /* Not provided */
-    t->total_width = cpu_to_le16(0xFFFF); /* Unknown */
-    t->data_width = cpu_to_le16(0xFFFF); /* Unknown */
+    t->total_width = cpu_to_le16(0x0040); // No ECC 64-bit
+    t->data_width = cpu_to_le16(0x0040); // No ECC 64-bit
     size_mb = QEMU_ALIGN_UP(size, MiB) / MiB;
     if (size_mb < MAX_T17_STD_SZ) {
         t->size = cpu_to_le16(size_mb);
@@ -884,23 +983,47 @@ static void smbios_build_type_17_table(unsigned instance, uint64_t size)
         t->size = cpu_to_le16(MAX_T17_STD_SZ);
         t->extended_size = cpu_to_le32(size_mb);
     }
-    t->form_factor = 0x09; /* DIMM */
+    t->form_factor = 0x09; /* DIMM and 0x0D for SODIMM */
     t->device_set = 0; /* Not in a set */
     snprintf(loc_str, sizeof(loc_str), "%s %d", type17.loc_pfx, instance);
     SMBIOS_TABLE_SET_STR(17, device_locator_str, loc_str);
     SMBIOS_TABLE_SET_STR(17, bank_locator_str, type17.bank);
-    t->memory_type = 0x07; /* RAM */
-    t->type_detail = cpu_to_le16(0x02); /* Other */
+    t->memory_type = 0x22; /* RAM */
+    t->type_detail = cpu_to_le16(0x0080); /*
+
+    Table 78 â€“ Memory Device: Type Detail field
+    https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A448%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C318%2C0%5D
+
+    Hex    = 0x0080
+    Binary = 0b0000000010000000
+
+    Bit0  = Reserved - 0 (No)
+    Bit1  = Other - 0 (No)
+    Bit2  = Unknown - 0 (No)
+    Bit3  = Fast-paged - 0 (No)
+    Bit4  = Static column - 0 (No)
+    Bit5  = Pseudo-static - 0 (No)
+    Bit6  = RAMBUS - 0 (No)
+    Bit7  = Synchronous - 1 (Yes)
+    Bit8  = CMOS - 0 (No)
+    Bit9  = EDO - 0 (No)
+    Bit10 = Window DRAM - 0 (No)
+    Bit11 = Cache DRAM - 0 (No)
+    Bit12 = Non-volatile - 0 (No)
+
+    */
     t->speed = cpu_to_le16(type17.speed);
     SMBIOS_TABLE_SET_STR(17, manufacturer_str, type17.manufacturer);
     SMBIOS_TABLE_SET_STR(17, serial_number_str, type17.serial);
     SMBIOS_TABLE_SET_STR(17, asset_tag_number_str, type17.asset);
     SMBIOS_TABLE_SET_STR(17, part_number_str, type17.part);
-    t->attributes = 0; /* Unknown */
+    t->attributes = 0x01; /* SINGLE RANK MODULE */
     t->configured_clock_speed = t->speed; /* reuse value for max speed */
-    t->minimum_voltage = cpu_to_le16(0); /* Unknown */
-    t->maximum_voltage = cpu_to_le16(0); /* Unknown */
-    t->configured_voltage = cpu_to_le16(0); /* Unknown */
+    // DDR4 Voltage, in mV
+    t->minimum_voltage = cpu_to_le16(1200); /* 1.2V Minimum Voltage Per DDR4 Spec */
+    t->maximum_voltage = cpu_to_le16(1500); /* 1.5V Minimum Voltage Per DDR4 Spec */
+    // 1.35V = typical XMP, 1.2V = JEDEC
+    t->configured_voltage = cpu_to_le16(1350); /* 1.35V XMP DDR4 Voltage */
 
     SMBIOS_BUILD_TABLE_POST;
 }
@@ -1017,8 +1140,9 @@ void smbios_set_default_processor_family(uint16_t processor_family)
 void smbios_set_defaults(const char *manufacturer, const char *product,
                          const char *version)
 {
-    smbios_have_defaults = true;
+    smbios_have_defaults = false;
 
+    /*
     SMBIOS_SET_DEFAULT(smbios_type1.manufacturer, manufacturer);
     SMBIOS_SET_DEFAULT(smbios_type1.product, product);
     SMBIOS_SET_DEFAULT(smbios_type1.version, version);
@@ -1032,6 +1156,7 @@ void smbios_set_defaults(const char *manufacturer, const char *product,
     SMBIOS_SET_DEFAULT(type4.version, version);
     SMBIOS_SET_DEFAULT(type17.loc_pfx, "DIMM");
     SMBIOS_SET_DEFAULT(type17.manufacturer, manufacturer);
+    */
 }
 
 static void smbios_entry_point_setup(SmbiosEntryPointType ep_type)
@@ -1093,7 +1218,7 @@ static bool smbios_get_tables_ep(MachineState *ms,
                        uint8_t **anchor, size_t *anchor_len,
                        Error **errp)
 {
-    unsigned i, dimm_cnt, offset;
+    unsigned i, dimm_cnt, offset, slot_cnt;
     MachineClass *mc = MACHINE_GET_CLASS(ms);
     ERRP_GUARD();
 
@@ -1115,7 +1240,7 @@ static bool smbios_get_tables_ep(MachineState *ms,
     assert(ms->smp.sockets >= 1);
 
     for (i = 0; i < ms->smp.sockets; i++) {
-        smbios_build_type_4_table(ms, i, ep_type, errp);
+        smbios_build_type_4_table(ms, i,ms->smp.sockets, ep_type, errp);
         if (*errp) {
             goto err_exit;
         }
@@ -1131,6 +1256,7 @@ static bool smbios_get_tables_ep(MachineState *ms,
     dimm_cnt = QEMU_ALIGN_UP(current_machine->ram_size,
                              mc->smbios_memory_device_size) /
                mc->smbios_memory_device_size;
+    slot_cnt = 4;
 
     /*
      * The offset determines if we need to keep additional space between
@@ -1139,13 +1265,25 @@ static bool smbios_get_tables_ep(MachineState *ms,
      * memory and DIMM like chunks of 16 GiB, the default space between
      * the two tables (T19_BASE - T17_BASE = 512) is not enough.
      */
-    offset = (dimm_cnt > (T19_BASE - T17_BASE)) ? \
-             dimm_cnt - (T19_BASE - T17_BASE) : 0;
+    if (dimm_cnt > slot_cnt) {
+        offset = (dimm_cnt > (T19_BASE - T17_BASE)) ?
+        dimm_cnt - (T19_BASE - T17_BASE) : 0;
+    } else {
+        offset = (slot_cnt > (T19_BASE - T17_BASE)) ?
+        slot_cnt - (T19_BASE - T17_BASE) : 0;
+    }
 
-    smbios_build_type_16_table(dimm_cnt);
+    smbios_build_type_16_table_with_slots(dimm_cnt, slot_cnt);
 
     for (i = 0; i < dimm_cnt; i++) {
-        smbios_build_type_17_table(i, GET_DIMM_SZ);
+        smbios_build_type_17_table_empty(i, GET_DIMM_SZ);
+    }
+
+    // Add empty slots...
+    if (slot_cnt > dimm_cnt) {
+        for (i = dimm_cnt; i < slot_cnt; i++) {
+            smbios_build_type_17_table_empty(i, GET_DIMM_SZ);
+        }
     }
 
     for (i = 0; i < mem_array_size; i++) {
diff --git a/hw/ufs/lu.c b/hw/ufs/lu.c
index 2d8ffd7..e0d2a92 100644
--- a/hw/ufs/lu.c
+++ b/hw/ufs/lu.c
@@ -184,8 +184,8 @@ static int ufs_emulate_wlun_inquiry(UfsRequest *req, uint8_t *outbuf,
     outbuf[5] = 0;
     outbuf[6] = 0;
     outbuf[7] = 0x2;
-    strpadcpy((char *)&outbuf[8], 8, "QEMU", ' ');
-    strpadcpy((char *)&outbuf[16], 16, "QEMU UFS", ' ');
+    strpadcpy((char *)&outbuf[8], 8, "MSI", ' ');
+    strpadcpy((char *)&outbuf[16], 16, "UFS", ' ');
     memset(&outbuf[32], 0, 4);
 
     return SCSI_INQUIRY_LEN;
diff --git a/hw/usb/canokey.c b/hw/usb/canokey.c
index cbefbb5..1998dd0 100644
--- a/hw/usb/canokey.c
+++ b/hw/usb/canokey.c
@@ -35,8 +35,8 @@ enum {
 
 static const USBDescStrings desc_strings = {
     [STR_MANUFACTURER]     = "canokeys.org",
-    [STR_PRODUCT]          = "CanoKey QEMU",
-    [STR_SERIALNUMBER]     = "0"
+    [STR_PRODUCT]          = "CanoKey",
+    [STR_SERIALNUMBER]     = "ORPEIJ8LEZ"
 };
 
 static const USBDescDevice desc_device_canokey = {
diff --git a/hw/usb/dev-audio.c b/hw/usb/dev-audio.c
index 26af709..3c281ad 100644
--- a/hw/usb/dev-audio.c
+++ b/hw/usb/dev-audio.c
@@ -73,9 +73,9 @@ enum usb_audio_strings {
 };
 
 static const USBDescStrings usb_audio_stringtable = {
-    [STRING_MANUFACTURER]       = "QEMU",
-    [STRING_PRODUCT]            = "QEMU USB Audio",
-    [STRING_SERIALNUMBER]       = "1",
+    [STRING_MANUFACTURER]       = "Logitech",
+    [STRING_PRODUCT]            = "USB Audio",
+    [STRING_SERIALNUMBER]       = "SCNU3K6LPU",
     [STRING_CONFIG]             = "Audio Configuration",
     [STRING_USBAUDIO_CONTROL]   = "Audio Device",
     [STRING_INPUT_TERMINAL]     = "Audio Output Pipe",
diff --git a/hw/usb/dev-hid.c b/hw/usb/dev-hid.c
index 96623aa..f10c420 100644
--- a/hw/usb/dev-hid.c
+++ b/hw/usb/dev-hid.c
@@ -63,17 +63,17 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
-    [STR_PRODUCT_MOUSE]    = "QEMU USB Mouse",
-    [STR_PRODUCT_TABLET]   = "QEMU USB Tablet",
-    [STR_PRODUCT_KEYBOARD] = "QEMU USB Keyboard",
-    [STR_SERIAL_COMPAT]    = "42",
+    [STR_MANUFACTURER]     = "Logitech",
+    [STR_PRODUCT_MOUSE]    = "USB Mouse",
+    [STR_PRODUCT_TABLET]   = "USB Tablet",
+    [STR_PRODUCT_KEYBOARD] = "USB Keyboard",
+    [STR_SERIAL_COMPAT]    = "N76POILMPP",
     [STR_CONFIG_MOUSE]     = "HID Mouse",
     [STR_CONFIG_TABLET]    = "HID Tablet",
     [STR_CONFIG_KEYBOARD]  = "HID Keyboard",
-    [STR_SERIAL_MOUSE]     = "89126",
-    [STR_SERIAL_TABLET]    = "28754",
-    [STR_SERIAL_KEYBOARD]  = "68284",
+    [STR_SERIAL_MOUSE]     = "1F6IT6W2IF",
+    [STR_SERIAL_TABLET]    = "WSS5T9RFVE",
+    [STR_SERIAL_KEYBOARD]  = "V96SH0F8ZX",
 };
 
 static const USBDescIface desc_iface_mouse = {
@@ -368,7 +368,7 @@ static const USBDescMSOS desc_msos_suspend = {
 
 static const USBDesc desc_mouse = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x8086,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -382,7 +382,7 @@ static const USBDesc desc_mouse = {
 
 static const USBDesc desc_mouse2 = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x8086,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -397,7 +397,7 @@ static const USBDesc desc_mouse2 = {
 
 static const USBDesc desc_tablet = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x8086,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -411,7 +411,7 @@ static const USBDesc desc_tablet = {
 
 static const USBDesc desc_tablet2 = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x8086,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -426,7 +426,7 @@ static const USBDesc desc_tablet2 = {
 
 static const USBDesc desc_keyboard = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x8086,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -440,7 +440,7 @@ static const USBDesc desc_keyboard = {
 
 static const USBDesc desc_keyboard2 = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x8086,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -805,7 +805,7 @@ static void usb_tablet_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_tablet_realize;
-    uc->product_desc   = "QEMU USB Tablet";
+    uc->product_desc   = "USB Tablet";
     dc->vmsd = &vmstate_usb_ptr;
     device_class_set_props(dc, usb_tablet_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
@@ -827,7 +827,7 @@ static void usb_mouse_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_mouse_realize;
-    uc->product_desc   = "QEMU USB Mouse";
+    uc->product_desc   = "USB Mouse";
     dc->vmsd = &vmstate_usb_ptr;
     device_class_set_props(dc, usb_mouse_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
@@ -850,7 +850,7 @@ static void usb_keyboard_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_keyboard_realize;
-    uc->product_desc   = "QEMU USB Keyboard";
+    uc->product_desc   = "USB Keyboard";
     dc->vmsd = &vmstate_usb_kbd;
     device_class_set_props(dc, usb_keyboard_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
diff --git a/hw/usb/dev-hub.c b/hw/usb/dev-hub.c
index a19350d..33aad4f 100644
--- a/hw/usb/dev-hub.c
+++ b/hw/usb/dev-hub.c
@@ -104,9 +104,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
-    [STR_PRODUCT]      = "QEMU USB Hub",
-    [STR_SERIALNUMBER] = "314159",
+    [STR_MANUFACTURER] = "Logitech",
+    [STR_PRODUCT]      = "USB Hub",
+    [STR_SERIALNUMBER] = "EPCEFDU54X",
 };
 
 static const USBDescIface desc_iface_hub = {
@@ -676,7 +676,7 @@ static void usb_hub_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_hub_realize;
-    uc->product_desc   = "QEMU USB Hub";
+    uc->product_desc   = "USB Hub";
     uc->usb_desc       = &desc_hub;
     uc->find_device    = usb_hub_find_device;
     uc->handle_reset   = usb_hub_handle_reset;
diff --git a/hw/usb/dev-mtp.c b/hw/usb/dev-mtp.c
index ce45c9c..e2b1ad7 100644
--- a/hw/usb/dev-mtp.c
+++ b/hw/usb/dev-mtp.c
@@ -247,8 +247,8 @@ OBJECT_DECLARE_SIMPLE_TYPE(MTPState, USB_MTP)
 
 /* ----------------------------------------------------------------------- */
 
-#define MTP_MANUFACTURER  "QEMU"
-#define MTP_PRODUCT       "QEMU filesharing"
+#define MTP_MANUFACTURER  "Microsoft"
+#define MTP_PRODUCT       "filesharing"
 #define MTP_WRITE_BUF_SZ  (512 * KiB)
 
 enum {
@@ -264,7 +264,7 @@ enum {
 static const USBDescStrings desc_strings = {
     [STR_MANUFACTURER] = MTP_MANUFACTURER,
     [STR_PRODUCT]      = MTP_PRODUCT,
-    [STR_SERIALNUMBER] = "34617",
+    [STR_SERIALNUMBER] = "FJFR36ZGFQ",
     [STR_MTP]          = "MTP",
     [STR_CONFIG_FULL]  = "Full speed config (usb 1.1)",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
@@ -2088,7 +2088,7 @@ static void usb_mtp_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_mtp_realize;
-    uc->product_desc   = "QEMU USB MTP";
+    uc->product_desc   = "USB MTP";
     uc->usb_desc       = &desc;
     uc->cancel_packet  = usb_mtp_cancel_packet;
     uc->handle_attach  = usb_desc_attach;
diff --git a/hw/usb/dev-network.c b/hw/usb/dev-network.c
index 1df2454..e399a10 100644
--- a/hw/usb/dev-network.c
+++ b/hw/usb/dev-network.c
@@ -99,16 +99,16 @@ enum usbstring_idx {
 #define ETH_FRAME_LEN                   1514 /* Max. octets in frame sans FCS */
 
 static const USBDescStrings usb_net_stringtable = {
-    [STRING_MANUFACTURER]       = "QEMU",
-    [STRING_PRODUCT]            = "RNDIS/QEMU USB Network Device",
-    [STRING_ETHADDR]            = "400102030405",
-    [STRING_DATA]               = "QEMU USB Net Data Interface",
-    [STRING_CONTROL]            = "QEMU USB Net Control Interface",
-    [STRING_RNDIS_CONTROL]      = "QEMU USB Net RNDIS Control Interface",
-    [STRING_CDC]                = "QEMU USB Net CDC",
-    [STRING_SUBSET]             = "QEMU USB Net Subset",
-    [STRING_RNDIS]              = "QEMU USB Net RNDIS",
-    [STRING_SERIALNUMBER]       = "1",
+    [STRING_MANUFACTURER]       = "Realtek",
+    [STRING_PRODUCT]            = "RNDIS/Realtek USB Network Device",
+    [STRING_ETHADDR]            = "4C82A94C9ECA",
+    [STRING_DATA]               = "USB Net Data Interface",
+    [STRING_CONTROL]            = "USB Net Control Interface",
+    [STRING_RNDIS_CONTROL]      = "USB Net RNDIS Control Interface",
+    [STRING_CDC]                = "USB Net CDC",
+    [STRING_SUBSET]             = "USB Net Subset",
+    [STRING_RNDIS]              = "USB Net RNDIS",
+    [STRING_SERIALNUMBER]       = "D9H87OLLOE",
 };
 
 static const USBDescIface desc_iface_rndis[] = {
@@ -717,7 +717,7 @@ static int ndis_query(USBNetState *s, uint32_t oid,
 
     /* mandatory */
     case OID_GEN_VENDOR_DESCRIPTION:
-        pstrcpy((char *)outbuf, outlen, "QEMU USB RNDIS Net");
+        pstrcpy((char *)outbuf, outlen, "USB RNDIS Net");
         return strlen((char *)outbuf) + 1;
 
     case OID_GEN_VENDOR_DRIVER_VERSION:
@@ -1417,7 +1417,7 @@ static void usb_net_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_net_realize;
-    uc->product_desc   = "QEMU USB Network Interface";
+    uc->product_desc   = "USB Network Interface";
     uc->usb_desc       = &desc_net;
     uc->handle_reset   = usb_net_handle_reset;
     uc->handle_control = usb_net_handle_control;
diff --git a/hw/usb/dev-serial.c b/hw/usb/dev-serial.c
index 1c116d8..358c745 100644
--- a/hw/usb/dev-serial.c
+++ b/hw/usb/dev-serial.c
@@ -119,10 +119,10 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]    = "QEMU",
-    [STR_PRODUCT_SERIAL]  = "QEMU USB SERIAL",
-    [STR_PRODUCT_BRAILLE] = "QEMU USB BAUM BRAILLE",
-    [STR_SERIALNUMBER]    = "1",
+    [STR_MANUFACTURER]    = "Microsoft",
+    [STR_PRODUCT_SERIAL]  = "USB SERIAL",
+    [STR_PRODUCT_BRAILLE] = "USB BAUM BRAILLE",
+    [STR_SERIALNUMBER]    = "6KCP6OG5KL",
 };
 
 static const USBDescIface desc_iface0 = {
@@ -663,7 +663,7 @@ static void usb_serial_class_initfn(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB Serial";
+    uc->product_desc   = "USB Serial";
     uc->usb_desc       = &desc_serial;
     device_class_set_props(dc, serial_properties);
 }
@@ -683,7 +683,7 @@ static void usb_braille_class_initfn(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB Braille";
+    uc->product_desc   = "USB Braille";
     uc->usb_desc       = &desc_braille;
     device_class_set_props(dc, braille_properties);
 }
diff --git a/hw/usb/dev-smartcard-reader.c b/hw/usb/dev-smartcard-reader.c
index 6ce7154..b02d281 100644
--- a/hw/usb/dev-smartcard-reader.c
+++ b/hw/usb/dev-smartcard-reader.c
@@ -80,8 +80,8 @@ OBJECT_DECLARE_SIMPLE_TYPE(USBCCIDState, USB_CCID_DEV)
 #define CCID_CONTROL_GET_CLOCK_FREQUENCIES  0x2
 #define CCID_CONTROL_GET_DATA_RATES         0x3
 
-#define CCID_PRODUCT_DESCRIPTION        "QEMU USB CCID"
-#define CCID_VENDOR_DESCRIPTION         "QEMU"
+#define CCID_PRODUCT_DESCRIPTION        "USB CCID"
+#define CCID_VENDOR_DESCRIPTION         "Identiv"
 #define CCID_INTERFACE_NAME             "CCID Interface"
 #define CCID_SERIAL_NUMBER_STRING       "1"
 /*
@@ -419,9 +419,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]  = "QEMU",
-    [STR_PRODUCT]       = "QEMU USB CCID",
-    [STR_SERIALNUMBER]  = "1",
+    [STR_MANUFACTURER]  = "Identiv",
+    [STR_PRODUCT]       = "USB CCID",
+    [STR_SERIALNUMBER]  = "L9Z3ZM8CDP",
     [STR_INTERFACE]     = "CCID Interface",
 };
 
@@ -1440,7 +1440,7 @@ static void ccid_class_initfn(ObjectClass *klass, const void *data)
     HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(klass);
 
     uc->realize        = ccid_realize;
-    uc->product_desc   = "QEMU USB CCID";
+    uc->product_desc   = "USB CCID";
     uc->usb_desc       = &desc_ccid;
     uc->handle_reset   = ccid_handle_reset;
     uc->handle_control = ccid_handle_control;
diff --git a/hw/usb/dev-storage.c b/hw/usb/dev-storage.c
index b13fe34..7680bee 100644
--- a/hw/usb/dev-storage.c
+++ b/hw/usb/dev-storage.c
@@ -47,9 +47,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
-    [STR_PRODUCT]      = "QEMU USB HARDDRIVE",
-    [STR_SERIALNUMBER] = "1",
+    [STR_MANUFACTURER] = "Samsung",
+    [STR_PRODUCT]      = "USB HARDDRIVE",
+    [STR_SERIALNUMBER] = "HLN8ILM0SH",
     [STR_CONFIG_FULL]  = "Full speed config (usb 1.1)",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
     [STR_CONFIG_SUPER] = "Super speed config (usb 3.0)",
@@ -590,7 +590,7 @@ static void usb_msd_class_initfn_common(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB MSD";
+    uc->product_desc   = "USB MSD";
     uc->usb_desc       = &desc;
     uc->cancel_packet  = usb_msd_cancel_io;
     uc->handle_attach  = usb_desc_attach;
diff --git a/hw/usb/dev-uas.c b/hw/usb/dev-uas.c
index 21cc283..d14a078 100644
--- a/hw/usb/dev-uas.c
+++ b/hw/usb/dev-uas.c
@@ -171,9 +171,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
+    [STR_MANUFACTURER] = "Microsoft",
     [STR_PRODUCT]      = "USB Attached SCSI HBA",
-    [STR_SERIALNUMBER] = "27842",
+    [STR_SERIALNUMBER] = "E5DEMH2Y7X",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
     [STR_CONFIG_SUPER] = "Super speed config (usb 3.0)",
 };
diff --git a/hw/usb/dev-wacom.c b/hw/usb/dev-wacom.c
index f4b71a2..ff724dd 100644
--- a/hw/usb/dev-wacom.c
+++ b/hw/usb/dev-wacom.c
@@ -64,9 +64,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
+    [STR_MANUFACTURER]     = "Wacom",
     [STR_PRODUCT]          = "Wacom PenPartner",
-    [STR_SERIALNUMBER]     = "1",
+    [STR_SERIALNUMBER]     = "718H83W0T4",
 };
 
 static const uint8_t qemu_wacom_hid_report_descriptor[] = {
@@ -231,7 +231,7 @@ static int usb_mouse_poll(USBWacomState *s, uint8_t *buf, int len)
 
     if (!s->mouse_grabbed) {
         s->eh_entry = qemu_add_mouse_event_handler(usb_mouse_event, s, 0,
-                        "QEMU PenPartner tablet");
+                        "PenPartner tablet");
         qemu_activate_mouse_event_handler(s->eh_entry);
         s->mouse_grabbed = 1;
     }
@@ -269,7 +269,7 @@ static int usb_wacom_poll(USBWacomState *s, uint8_t *buf, int len)
 
     if (!s->mouse_grabbed) {
         s->eh_entry = qemu_add_mouse_event_handler(usb_wacom_event, s, 1,
-                        "QEMU PenPartner tablet");
+                        "PenPartner tablet");
         qemu_activate_mouse_event_handler(s->eh_entry);
         s->mouse_grabbed = 1;
     }
@@ -425,7 +425,7 @@ static void usb_wacom_class_init(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU PenPartner Tablet";
+    uc->product_desc   = "PenPartner Tablet";
     uc->usb_desc       = &desc_wacom;
     uc->realize        = usb_wacom_realize;
     uc->handle_reset   = usb_wacom_handle_reset;
@@ -433,7 +433,7 @@ static void usb_wacom_class_init(ObjectClass *klass, const void *data)
     uc->handle_data    = usb_wacom_handle_data;
     uc->unrealize      = usb_wacom_unrealize;
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
-    dc->desc = "QEMU PenPartner Tablet";
+    dc->desc = "PenPartner Tablet";
     dc->vmsd = &vmstate_usb_wacom;
 }
 
diff --git a/hw/usb/u2f-emulated.c b/hw/usb/u2f-emulated.c
index ace5ece..8cb276a 100644
--- a/hw/usb/u2f-emulated.c
+++ b/hw/usb/u2f-emulated.c
@@ -385,7 +385,7 @@ static void u2f_emulated_class_init(ObjectClass *klass, const void *data)
     kc->realize = u2f_emulated_realize;
     kc->unrealize = u2f_emulated_unrealize;
     kc->recv_from_guest = u2f_emulated_recv_from_guest;
-    dc->desc = "QEMU U2F emulated key";
+    dc->desc = "U2F emulated key";
     device_class_set_props(dc, u2f_emulated_properties);
 }
 
diff --git a/hw/usb/u2f-passthru.c b/hw/usb/u2f-passthru.c
index fa8d9cd..cd4d451 100644
--- a/hw/usb/u2f-passthru.c
+++ b/hw/usb/u2f-passthru.c
@@ -528,7 +528,7 @@ static void u2f_passthru_class_init(ObjectClass *klass, const void *data)
     kc->realize = u2f_passthru_realize;
     kc->unrealize = u2f_passthru_unrealize;
     kc->recv_from_guest = u2f_passthru_recv_from_guest;
-    dc->desc = "QEMU U2F passthrough key";
+    dc->desc = "U2F passthrough key";
     dc->vmsd = &u2f_passthru_vmstate;
     device_class_set_props(dc, u2f_passthru_properties);
     set_bit(DEVICE_CATEGORY_MISC, dc->categories);
diff --git a/hw/usb/u2f.c b/hw/usb/u2f.c
index b051a99..a6c48cd 100644
--- a/hw/usb/u2f.c
+++ b/hw/usb/u2f.c
@@ -46,9 +46,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
+    [STR_MANUFACTURER]     = "Microsoft",
     [STR_PRODUCT]          = "U2F USB key",
-    [STR_SERIALNUMBER]     = "0",
+    [STR_SERIALNUMBER]     = "JFX4J5OICR",
     [STR_CONFIG]           = "U2F key config",
     [STR_INTERFACE]        = "U2F key interface"
 };
@@ -322,7 +322,7 @@ static void u2f_key_class_init(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU U2F USB key";
+    uc->product_desc   = "U2F USB key";
     uc->usb_desc       = &desc_u2f_key;
     uc->handle_reset   = u2f_key_handle_reset;
     uc->handle_control = u2f_key_handle_control;
@@ -330,7 +330,7 @@ static void u2f_key_class_init(ObjectClass *klass, const void *data)
     uc->handle_attach  = usb_desc_attach;
     uc->realize        = u2f_key_realize;
     uc->unrealize      = u2f_key_unrealize;
-    dc->desc           = "QEMU U2F key";
+    dc->desc           = "U2F key";
     dc->vmsd           = &vmstate_u2f_key;
 }
 
diff --git a/hw/vfio/ap.c b/hw/vfio/ap.c
index 7719f24..d0306c5 100644
--- a/hw/vfio/ap.c
+++ b/hw/vfio/ap.c
@@ -341,7 +341,7 @@ static void vfio_ap_class_init(ObjectClass *klass, const void *data)
     set_bit(DEVICE_CATEGORY_MISC, dc->categories);
     dc->realize = vfio_ap_realize;
     dc->unrealize = vfio_ap_unrealize;
-    dc->hotpluggable = true;
+    dc->hotpluggable = false;
     device_class_set_legacy_reset(dc, vfio_ap_reset);
     dc->bus_type = TYPE_AP_BUS;
 
diff --git a/include/hw/acpi/aml-build.h b/include/hw/acpi/aml-build.h
index c18f681..abc649e 100644
--- a/include/hw/acpi/aml-build.h
+++ b/include/hw/acpi/aml-build.h
@@ -4,8 +4,8 @@
 #include "hw/acpi/acpi-defs.h"
 #include "hw/acpi/bios-linker-loader.h"
 
-#define ACPI_BUILD_APPNAME6 "BOCHS "
-#define ACPI_BUILD_APPNAME8 "BXPC    "
+#define ACPI_BUILD_APPNAME6 "INTEL "
+#define ACPI_BUILD_APPNAME8 "U Rvp   "
 
 #define ACPI_BUILD_TABLE_FILE "etc/acpi/tables"
 #define ACPI_BUILD_RSDP_FILE "etc/acpi/rsdp"
diff --git a/include/hw/pci/pci.h b/include/hw/pci/pci.h
index 6b7d3ac..84693f6 100644
--- a/include/hw/pci/pci.h
+++ b/include/hw/pci/pci.h
@@ -57,7 +57,7 @@ extern bool pci_available;
 #define PCI_DEVICE_ID_MARVELL_GT6412X    0x4620
 
 /* QEMU/Bochs VGA (0x1234) */
-#define PCI_VENDOR_ID_QEMU               0x1234
+#define PCI_VENDOR_ID_QEMU               0x8086 // "???" | Intel Device ID Replacement from 0x1234
 #define PCI_DEVICE_ID_QEMU_VGA           0x1111
 #define PCI_DEVICE_ID_QEMU_IPMI          0x1112
 
@@ -74,12 +74,12 @@ extern bool pci_available;
 /* Intel (0x8086) */
 #define PCI_DEVICE_ID_INTEL_82551IT      0x1209
 #define PCI_DEVICE_ID_INTEL_82557        0x1229
-#define PCI_DEVICE_ID_INTEL_82801IR      0x2922
+#define PCI_DEVICE_ID_INTEL_82801IR      0x463D // Intel 82801IR ICH9 - LPC Bridge [A2] | Intel Device ID Replacement from 0x2922 | hw/ide/ich.c
 
 /* Red Hat / Qumranet (for QEMU) -- see pci-ids.txt */
-#define PCI_VENDOR_ID_REDHAT_QUMRANET    0x1af4
-#define PCI_SUBVENDOR_ID_REDHAT_QUMRANET 0x1af4
-#define PCI_SUBDEVICE_ID_QEMU            0x1100
+#define PCI_VENDOR_ID_REDHAT_QUMRANET    0x8086 // Intel Device ID Replacement from 0x1af4
+#define PCI_SUBVENDOR_ID_REDHAT_QUMRANET 0x8086 // Intel Device ID Replacement from 0x1af4
+#define PCI_SUBDEVICE_ID_QEMU            0x8086 // Intel Device ID Replacement from 0x1100
 
 /* legacy virtio-pci devices */
 #define PCI_DEVICE_ID_VIRTIO_NET         0x1000
@@ -100,21 +100,21 @@ extern bool pci_available;
  */
 #define PCI_DEVICE_ID_VIRTIO_10_BASE     0x1040
 
-#define PCI_VENDOR_ID_REDHAT             0x1b36
-#define PCI_DEVICE_ID_REDHAT_BRIDGE      0x0001
-#define PCI_DEVICE_ID_REDHAT_SERIAL      0x0002
+#define PCI_VENDOR_ID_REDHAT             0x8086 // "Red Hat, Inc." | Intel Vendor ID Replacement from 0x1b36
+#define PCI_DEVICE_ID_REDHAT_BRIDGE      0x4641 // "QEMU PCI-PCI bridge" | Intel Device ID Replacement from 0x0001 | hw/pci-bridge/pci_bridge_dev.c
+#define PCI_DEVICE_ID_REDHAT_SERIAL      0x0002 // TODO: find device_id | Intel Device ID Replacement from 0x???? | hw/char/serial-pci.c
 #define PCI_DEVICE_ID_REDHAT_SERIAL2     0x0003
 #define PCI_DEVICE_ID_REDHAT_SERIAL4     0x0004
 #define PCI_DEVICE_ID_REDHAT_TEST        0x0005
 #define PCI_DEVICE_ID_REDHAT_ROCKER      0x0006
 #define PCI_DEVICE_ID_REDHAT_SDHCI       0x0007
-#define PCI_DEVICE_ID_REDHAT_PCIE_HOST   0x0008
+#define PCI_DEVICE_ID_REDHAT_PCIE_HOST   0x4641 // "QEMU PCIe Host bridge" | Intel Device ID Replacement from 0x0008 | hw/pci-host/gpex.c
 #define PCI_DEVICE_ID_REDHAT_PXB         0x0009
 #define PCI_DEVICE_ID_REDHAT_BRIDGE_SEAT 0x000a
 #define PCI_DEVICE_ID_REDHAT_PXB_PCIE    0x000b
-#define PCI_DEVICE_ID_REDHAT_PCIE_RP     0x000c
-#define PCI_DEVICE_ID_REDHAT_XHCI        0x000d
-#define PCI_DEVICE_ID_REDHAT_PCIE_BRIDGE 0x000e
+#define PCI_DEVICE_ID_REDHAT_PCIE_RP     0x51b0 // "QEMU PCIe Root Port" | Intel Device ID Replacement from 0x000c | hw/pci-bridge/gen_pcie_root_port.c
+#define PCI_DEVICE_ID_REDHAT_XHCI        0x51ed // "QEMU XHCI Host Controller" | Intel Device ID Replacement from 0x000d | hw/usb/hcd-xhci-pci.c
+#define PCI_DEVICE_ID_REDHAT_PCIE_BRIDGE 0x51b0 // "Red Hat, Device ID: 000E" | Intel Device ID Replacement from 0x000e | hw/pci-bridge/pcie_pci_bridge.c
 #define PCI_DEVICE_ID_REDHAT_MDPY        0x000f
 #define PCI_DEVICE_ID_REDHAT_NVME        0x0010
 #define PCI_DEVICE_ID_REDHAT_PVPANIC     0x0011
diff --git a/include/hw/pci/pci_ids.h b/include/hw/pci/pci_ids.h
index 33e2898..18915ef 100644
--- a/include/hw/pci/pci_ids.h
+++ b/include/hw/pci/pci_ids.h
@@ -237,6 +237,8 @@
 #define PCI_VENDOR_ID_BAIDU              0x1d22
 #define PCI_DEVICE_ID_KUNLUN_VF          0x3685
 
+/* https://www.pcilookup.com/ */
+
 #define PCI_VENDOR_ID_INTEL              0x8086
 #define PCI_DEVICE_ID_INTEL_82378        0x0484
 #define PCI_DEVICE_ID_INTEL_82441        0x1237
@@ -246,8 +248,8 @@
 #define PCI_DEVICE_ID_INTEL_ESB_9        0x25ab
 #define PCI_DEVICE_ID_INTEL_NVME         0x5845
 #define PCI_DEVICE_ID_INTEL_82371SB_0    0x7000
-#define PCI_DEVICE_ID_INTEL_82371SB_1    0x7010
-#define PCI_DEVICE_ID_INTEL_82371SB_2    0x7020
+#define PCI_DEVICE_ID_INTEL_82371SB_1    0x7010 // TODO: | Intel 82371SB_1 - ??? | Intel Vendor ID Replacement from 0x???? | hw/ide/piix.c
+#define PCI_DEVICE_ID_INTEL_82371SB_2    0x7020 // TODO: | Intel 82371SB_2 - ??? | Intel Vendor ID Replacement from 0x???? | hw/usb/hcd-uhci.c
 #define PCI_DEVICE_ID_INTEL_82371AB_0    0x7110
 #define PCI_DEVICE_ID_INTEL_82371AB      0x7111
 #define PCI_DEVICE_ID_INTEL_82371AB_2    0x7112
@@ -259,9 +261,9 @@
 #define PCI_DEVICE_ID_INTEL_ICH9_3       0x2913
 #define PCI_DEVICE_ID_INTEL_ICH9_4       0x2914
 #define PCI_DEVICE_ID_INTEL_ICH9_5       0x2919
-#define PCI_DEVICE_ID_INTEL_ICH9_6       0x2930
+#define PCI_DEVICE_ID_INTEL_ICH9_6       0x51a3 // Intel 82801IB ICH9 - SMBus Controller [A2] | Intel Vendor ID Replacement from 0x2930 | hw/i2c/smbus_ich9.c
 #define PCI_DEVICE_ID_INTEL_ICH9_7       0x2916
-#define PCI_DEVICE_ID_INTEL_ICH9_8       0x2918
+#define PCI_DEVICE_ID_INTEL_ICH9_8       0x5182 // Intel 82801IR ICH9 - LPC Bridge [A2] | Intel Vendor ID Replacement from 0x2918 | hw/isa/lpc_ich9.c
 
 #define PCI_DEVICE_ID_INTEL_82801I_UHCI1 0x2934
 #define PCI_DEVICE_ID_INTEL_82801I_UHCI2 0x2935
@@ -273,7 +275,7 @@
 #define PCI_DEVICE_ID_INTEL_82801I_EHCI2 0x293c
 #define PCI_DEVICE_ID_INTEL_82599_SFP_VF 0x10ed
 
-#define PCI_DEVICE_ID_INTEL_P35_MCH      0x29c0
+#define PCI_DEVICE_ID_INTEL_P35_MCH      0x4641 // Intel G33/P35/Q35/Q33 Chipset - Memory Controller Hub [A0] | Intel Vendor ID Replacement from 0x29c0 | hw/pci-host/q35.c
 
 #define PCI_VENDOR_ID_XEN                0x5853
 #define PCI_DEVICE_ID_XEN_PLATFORM       0x0001
diff --git a/include/standard-headers/linux/qemu_fw_cfg.h b/include/standard-headers/linux/qemu_fw_cfg.h
index cb93f66..fe34590 100644
--- a/include/standard-headers/linux/qemu_fw_cfg.h
+++ b/include/standard-headers/linux/qemu_fw_cfg.h
@@ -4,7 +4,7 @@
 
 #include "standard-headers/linux/types.h"
 
-#define FW_CFG_ACPI_DEVICE_ID	"QEMU0002"
+#define FW_CFG_ACPI_DEVICE_ID	"UEFI0002"
 
 /* selector key values for "well-known" fw_cfg entries */
 #define FW_CFG_SIGNATURE	0x00
@@ -71,7 +71,7 @@ struct fw_cfg_file {
 #define FW_CFG_DMA_CTL_SELECT	0x08
 #define FW_CFG_DMA_CTL_WRITE	0x10
 
-#define FW_CFG_DMA_SIGNATURE    0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE    0x51434f4d20434647ULL /* "QCOM CFG" */
 
 /* Control as first field allows for different structures selected by this
  * field, which might be useful in the future
diff --git a/migration/rdma.c b/migration/rdma.c
index 2d839fc..960871d 100644
--- a/migration/rdma.c
+++ b/migration/rdma.c
@@ -220,7 +220,7 @@ static const char *control_desc(unsigned int rdma_control)
         [RDMA_CONTROL_NONE] = "NONE",
         [RDMA_CONTROL_ERROR] = "ERROR",
         [RDMA_CONTROL_READY] = "READY",
-        [RDMA_CONTROL_QEMU_FILE] = "QEMU FILE",
+        [RDMA_CONTROL_QEMU_FILE] = "FILE",
         [RDMA_CONTROL_RAM_BLOCKS_REQUEST] = "RAM BLOCKS REQUEST",
         [RDMA_CONTROL_RAM_BLOCKS_RESULT] = "RAM BLOCKS RESULT",
         [RDMA_CONTROL_COMPRESS] = "COMPRESS",
diff --git a/pc-bios/optionrom/optionrom.h b/pc-bios/optionrom/optionrom.h
index 7bcdf0e..02dd06e 100644
--- a/pc-bios/optionrom/optionrom.h
+++ b/pc-bios/optionrom/optionrom.h
@@ -43,7 +43,7 @@
 #define FW_CFG_DMA_CTL_SELECT  0x08
 #define FW_CFG_DMA_CTL_WRITE   0x10
 
-#define FW_CFG_DMA_SIGNATURE 0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE 0x51434f4d20434647ULL /* "QCOM CFG" */
 
 #define BIOS_CFG_DMA_ADDR_HIGH  0x514
 #define BIOS_CFG_DMA_ADDR_LOW   0x518
diff --git a/pc-bios/s390-ccw/virtio-scsi.h b/pc-bios/s390-ccw/virtio-scsi.h
index c5612e1..048cb93 100644
--- a/pc-bios/s390-ccw/virtio-scsi.h
+++ b/pc-bios/s390-ccw/virtio-scsi.h
@@ -25,7 +25,7 @@
 #define VIRTIO_SCSI_S_OK                     0x00
 #define VIRTIO_SCSI_S_BAD_TARGET             0x03
 
-#define QEMU_CDROM_SIGNATURE "QEMU CD-ROM     "
+#define QEMU_CDROM_SIGNATURE "ASUS CD-ROM     "
 
 enum virtio_scsi_vq_id {
     VR_CONTROL  = 0,
diff --git a/qapi/ui.json b/qapi/ui.json
index 1b2f4a4..37f40fd 100644
--- a/qapi/ui.json
+++ b/qapi/ui.json
@@ -831,13 +831,13 @@
 #     -> { "execute": "query-mice" }
 #     <- { "return": [
 #              {
-#                 "name":"QEMU Microsoft Mouse",
+#                 "name":"Microsoft Mouse",
 #                 "index":0,
 #                 "current":false,
 #                 "absolute":false
 #              },
 #              {
-#                 "name":"QEMU PS/2 Mouse",
+#                 "name":"PS/2 Mouse",
 #                 "index":1,
 #                 "current":true,
 #                 "absolute":true
diff --git a/target/i386/cpu.c b/target/i386/cpu.c
index 6d85149..dc98ccc 100644
--- a/target/i386/cpu.c
+++ b/target/i386/cpu.c
@@ -3309,7 +3309,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
         .features[FEAT_8000_0001_ECX] =
             CPUID_EXT3_LAHF_LM | CPUID_EXT3_SVM,
         .xlevel = 0x8000000A,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "Intel CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "phenom",
@@ -3438,7 +3438,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
         .features[FEAT_1_ECX] =
             CPUID_EXT_SSE3,
         .xlevel = 0x80000004,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "Intel CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "kvm32",
@@ -3468,7 +3468,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
              VMX_CPU_BASED_USE_IO_BITMAPS | VMX_CPU_BASED_MONITOR_EXITING |
              VMX_CPU_BASED_PAUSE_EXITING | VMX_CPU_BASED_USE_MSR_BITMAPS,
         .xlevel = 0x80000008,
-        .model_id = "Common 32-bit KVM processor"
+        .model_id = "Common 32-bit Intel processor"
     },
     {
         .name = "coreduo",
@@ -3568,7 +3568,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
         .features[FEAT_8000_0001_EDX] =
             CPUID_EXT2_MMXEXT | CPUID_EXT2_3DNOW | CPUID_EXT2_3DNOWEXT,
         .xlevel = 0x80000008,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "Intel CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "n270",
@@ -6745,7 +6745,7 @@ static void max_x86_cpu_initfn(Object *obj)
     }
     if (!env->cpuid_model[0]) {
         object_property_set_str(OBJECT(cpu), "model-id",
-                                "QEMU TCG CPU version " QEMU_HW_VERSION,
+                                "CPU version " QEMU_HW_VERSION,
                                 &error_abort);
     }
 }
@@ -9146,7 +9146,7 @@ static void x86_cpu_hyperv_realize(X86CPU *cpu)
 
     /* Hyper-V vendor id */
     if (!cpu->hyperv_vendor) {
-        object_property_set_str(OBJECT(cpu), "hv-vendor-id", "Microsoft Hv",
+        object_property_set_str(OBJECT(cpu), "hv-vendor-id", "",
                                 &error_abort);
     }
     len = strlen(cpu->hyperv_vendor);
diff --git a/target/i386/kvm/kvm.c b/target/i386/kvm/kvm.c
index 5621200..f4eb228 100644
--- a/target/i386/kvm/kvm.c
+++ b/target/i386/kvm/kvm.c
@@ -1634,7 +1634,7 @@ static int hyperv_fill_cpuids(CPUState *cs,
         c->function = HV_CPUID_SYNDBG_VENDOR_AND_MAX_FUNCTIONS;
         c->eax = hyperv_feat_enabled(cpu, HYPERV_FEAT_EVMCS) ?
             HV_CPUID_NESTED_FEATURES : HV_CPUID_IMPLEMENT_LIMITS;
-        memcpy(signature, "Microsoft VS", 12);
+        memset(signature, 0, 12);
         c->eax = 0;
         c->ebx = signature[0];
         c->ecx = signature[1];
@@ -1642,7 +1642,7 @@ static int hyperv_fill_cpuids(CPUState *cs,
 
         c = &cpuid_ent[cpuid_i++];
         c->function = HV_CPUID_SYNDBG_INTERFACE;
-        memcpy(signature, "VS#1\0\0\0\0\0\0\0\0", 12);
+        memset(signature, 0, 12);
         c->eax = signature[0];
         c->ebx = 0;
         c->ecx = 0;
@@ -2160,7 +2160,7 @@ int kvm_arch_init_vcpu(CPUState *cs)
 #ifdef CONFIG_XEN_EMU
         struct kvm_cpuid_entry2 *xen_max_leaf;
 
-        memcpy(signature, "XenVMMXenVMM", 12);
+        memset(signature, 0, 12);
 
         xen_max_leaf = c = &cpuid_data.entries[cpuid_i++];
         c->function = kvm_base + XEN_CPUID_SIGNATURE;
@@ -2236,7 +2236,7 @@ int kvm_arch_init_vcpu(CPUState *cs)
         abort();
 #endif
     } else if (cpu->expose_kvm) {
-        memcpy(signature, "KVMKVMKVM\0\0\0", 12);
+        memset(signature, 0, 12);
         c = &cpuid_data.entries[cpuid_i++];
         c->function = KVM_CPUID_SIGNATURE | kvm_base;
         c->eax = KVM_CPUID_FEATURES | kvm_base;
diff --git a/target/s390x/cpu_models.c b/target/s390x/cpu_models.c
index 954a7a9..3f1fe01 100644
--- a/target/s390x/cpu_models.c
+++ b/target/s390x/cpu_models.c
@@ -954,7 +954,7 @@ static void s390_qemu_cpu_model_class_init(ObjectClass *oc, const void *data)
     S390CPUClass *xcc = S390_CPU_CLASS(oc);
 
     xcc->is_migration_safe = true;
-    xcc->desc = g_strdup_printf("QEMU Virtual CPU version %s",
+    xcc->desc = g_strdup_printf("CPU version %s",
                                 qemu_hw_version());
 }
 
diff --git a/target/s390x/tcg/misc_helper.c b/target/s390x/tcg/misc_helper.c
index f7101be..35a09d2 100644
--- a/target/s390x/tcg/misc_helper.c
+++ b/target/s390x/tcg/misc_helper.c
@@ -331,18 +331,18 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
             /* Basic Machine Configuration */
             char type[5] = {};
 
-            ebcdic_put(sysib.sysib_111.manuf, "QEMU            ", 16);
+            ebcdic_put(sysib.sysib_111.manuf, "Intel           ", 16);
             /* same as machine type number in STORE CPU ID, but in EBCDIC */
             snprintf(type, ARRAY_SIZE(type), "%X", cpu->model->def->type);
             ebcdic_put(sysib.sysib_111.type, type, 4);
             /* model number (not stored in STORE CPU ID for z/Architecture) */
-            ebcdic_put(sysib.sysib_111.model, "QEMU            ", 16);
-            ebcdic_put(sysib.sysib_111.sequence, "QEMU            ", 16);
-            ebcdic_put(sysib.sysib_111.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_111.model, "Intel           ", 16);
+            ebcdic_put(sysib.sysib_111.sequence, "Intel           ", 16);
+            ebcdic_put(sysib.sysib_111.plant, "INTL", 4);
         } else if ((sel1 == 2) && (sel2 == 1)) {
             /* Basic Machine CPU */
-            ebcdic_put(sysib.sysib_121.sequence, "QEMUQEMUQEMUQEMU", 16);
-            ebcdic_put(sysib.sysib_121.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_121.sequence, "INTELINTELINTELI", 16);
+            ebcdic_put(sysib.sysib_121.plant, "INTL", 4);
             sysib.sysib_121.cpu_addr = cpu_to_be16(env->core_id);
         } else if ((sel1 == 2) && (sel2 == 2)) {
             /* Basic Machine CPUs */
@@ -357,8 +357,8 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
     case STSI_R0_FC_LEVEL_2:
         if ((sel1 == 2) && (sel2 == 1)) {
             /* LPAR CPU */
-            ebcdic_put(sysib.sysib_221.sequence, "QEMUQEMUQEMUQEMU", 16);
-            ebcdic_put(sysib.sysib_221.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_221.sequence, "INTELINTELINTELI", 16);
+            ebcdic_put(sysib.sysib_221.plant, "INTL", 4);
             sysib.sysib_221.cpu_addr = cpu_to_be16(env->core_id);
         } else if ((sel1 == 2) && (sel2 == 2)) {
             /* LPAR CPUs */
@@ -366,7 +366,7 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
             sysib.sysib_222.total_cpus = cpu_to_be16(total_cpus);
             sysib.sysib_222.conf_cpus = cpu_to_be16(conf_cpus);
             sysib.sysib_222.reserved_cpus = cpu_to_be16(reserved_cpus);
-            ebcdic_put(sysib.sysib_222.name, "QEMU    ", 8);
+            ebcdic_put(sysib.sysib_222.name, "Intel   ", 8);
             sysib.sysib_222.caf = cpu_to_be32(1000);
             sysib.sysib_222.dedicated_cpus = cpu_to_be16(conf_cpus);
         } else {
@@ -382,7 +382,7 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
             sysib.sysib_322.vm[0].reserved_cpus = cpu_to_be16(reserved_cpus);
             sysib.sysib_322.vm[0].caf = cpu_to_be32(1000);
             /* Linux kernel uses this to distinguish us from z/VM */
-            ebcdic_put(sysib.sysib_322.vm[0].cpi, "KVM/Linux       ", 16);
+            ebcdic_put(sysib.sysib_322.vm[0].cpi, "IntelIntel      ", 16);
             sysib.sysib_322.vm[0].ext_name_encoding = 2; /* UTF-8 */
 
             /* If our VM has a name, use the real name */

```

`patches/QEMU/Archive/intel-qemu-9.2.4.patch`:

```patch
diff --git a/block/vhdx.c b/block/vhdx.c
index 5aa1a13..b7e7bed 100644
--- a/block/vhdx.c
+++ b/block/vhdx.c
@@ -2020,7 +2020,7 @@ vhdx_co_create(BlockdevCreateOptions *opts, Error **errp)
 
     /* The creator field is optional, but may be useful for
      * debugging / diagnostics */
-    creator = g_utf8_to_utf16("QEMU v" QEMU_VERSION, -1, NULL,
+    creator = g_utf8_to_utf16("Microsoft v" QEMU_VERSION, -1, NULL,
                               &creator_items, NULL);
     signature = cpu_to_le64(VHDX_FILE_SIGNATURE);
     ret = blk_co_pwrite(blk, VHDX_FILE_ID_OFFSET, sizeof(signature), &signature,
diff --git a/block/vvfat.c b/block/vvfat.c
index 8ffe8b3..8baad6d 100644
--- a/block/vvfat.c
+++ b/block/vvfat.c
@@ -1177,7 +1177,7 @@ static int vvfat_open(BlockDriverState *bs, QDict *options, int flags,
         }
         memcpy(s->volume_label, label, label_length);
     } else {
-        memcpy(s->volume_label, "QEMU VVFAT", 10);
+        memcpy(s->volume_label, "ASUS VVFAT", 10);
     }
 
     if (floppy) {
diff --git a/chardev/msmouse.c b/chardev/msmouse.c
index 2279694..33cea79 100644
--- a/chardev/msmouse.c
+++ b/chardev/msmouse.c
@@ -172,7 +172,7 @@ static int msmouse_chr_write(struct Chardev *s, const uint8_t *buf, int len)
 }
 
 static const QemuInputHandler msmouse_handler = {
-    .name  = "QEMU Microsoft Mouse",
+    .name  = "Microsoft Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = msmouse_input_event,
     .sync  = msmouse_input_sync,
diff --git a/chardev/wctablet.c b/chardev/wctablet.c
index f4008bf..6aeccdb 100644
--- a/chardev/wctablet.c
+++ b/chardev/wctablet.c
@@ -179,7 +179,7 @@ static void wctablet_input_sync(DeviceState *dev)
 }
 
 static const QemuInputHandler wctablet_handler = {
-    .name  = "QEMU Wacom Pen Tablet",
+    .name  = "Wacom Pen Tablet",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_ABS,
     .event = wctablet_input_event,
     .sync  = wctablet_input_sync,
diff --git a/contrib/vhost-user-gpu/vhost-user-gpu.c b/contrib/vhost-user-gpu/vhost-user-gpu.c
index bb41758..dbd2777 100644
--- a/contrib/vhost-user-gpu/vhost-user-gpu.c
+++ b/contrib/vhost-user-gpu/vhost-user-gpu.c
@@ -1254,7 +1254,7 @@ main(int argc, char *argv[])
     QTAILQ_INIT(&g.reslist);
     QTAILQ_INIT(&g.fenceq);
 
-    context = g_option_context_new("QEMU vhost-user-gpu");
+    context = g_option_context_new("vhost-user-gpu");
     g_option_context_add_main_entries(context, entries, NULL);
     if (!g_option_context_parse(context, &argc, &argv, &error)) {
         g_printerr("Option parsing failed: %s\n", error->message);
diff --git a/hw/acpi/aml-build.c b/hw/acpi/aml-build.c
index 72282b1..06b1187 100644
--- a/hw/acpi/aml-build.c
+++ b/hw/acpi/aml-build.c
@@ -1723,11 +1723,11 @@ void acpi_table_begin(AcpiTable *desc, GArray *array)
     build_append_int_noprefix(array, 0, 4); /* Length */
     build_append_int_noprefix(array, desc->rev, 1); /* Revision */
     build_append_int_noprefix(array, 0, 1); /* Checksum */
-    build_append_padded_str(array, desc->oem_id, 6, '\0'); /* OEMID */
+    build_append_padded_str(array, ACPI_BUILD_APPNAME6, 6, '\0'); /* OEMID */
     /* OEM Table ID */
-    build_append_padded_str(array, desc->oem_table_id, 8, '\0');
+    build_append_padded_str(array, ACPI_BUILD_APPNAME8, 8, '\0');
     build_append_int_noprefix(array, 1, 4); /* OEM Revision */
-    g_array_append_vals(array, ACPI_BUILD_APPNAME8, 4); /* Creator ID */
+    g_array_append_vals(array, "ACPI", 4); /* Creator ID */
     build_append_int_noprefix(array, 1, 4); /* Creator Revision */
 }
 
@@ -2236,7 +2236,7 @@ void build_fadt(GArray *tbl, BIOSLinker *linker, const AcpiFadtData *f,
     /* ACPI1.0: INT_MODEL, ACPI2.0+: Reserved */
     build_append_int_noprefix(tbl, f->int_model /* Multiple APIC */, 1);
     /* Preferred_PM_Profile */
-    build_append_int_noprefix(tbl, 0 /* Unspecified */, 1);
+    build_append_int_noprefix(tbl, 1 /* Desktop */, 1);
     build_append_int_noprefix(tbl, f->sci_int, 2); /* SCI_INT */
     build_append_int_noprefix(tbl, f->smi_cmd, 4); /* SMI_CMD */
     build_append_int_noprefix(tbl, f->acpi_enable_cmd, 1); /* ACPI_ENABLE */
@@ -2333,7 +2333,7 @@ void build_fadt(GArray *tbl, BIOSLinker *linker, const AcpiFadtData *f,
     }
 
     /* Hypervisor Vendor Identity */
-    build_append_padded_str(tbl, "QEMU", 8, '\0');
+    build_append_padded_str(tbl, "", 8, '\0');
 
     /* TODO: extra fields need to be added to support revisions above rev6 */
     assert(f->rev == 6);
diff --git a/hw/arm/sbsa-ref.c b/hw/arm/sbsa-ref.c
index e9985a5..a115c11 100644
--- a/hw/arm/sbsa-ref.c
+++ b/hw/arm/sbsa-ref.c
@@ -894,7 +894,7 @@ static void sbsa_ref_class_init(ObjectClass *oc, void *data)
     };
 
     mc->init = sbsa_ref_init;
-    mc->desc = "QEMU 'SBSA Reference' ARM Virtual Machine";
+    mc->desc = "Qualcomm 'Reference' ARM SoC";
     mc->default_cpu_type = ARM_CPU_TYPE_NAME("neoverse-n2");
     mc->valid_cpu_types = valid_cpu_types;
     mc->max_cpus = 512;
diff --git a/hw/arm/virt.c b/hw/arm/virt.c
index 5fa045c..1dba62f 100644
--- a/hw/arm/virt.c
+++ b/hw/arm/virt.c
@@ -110,7 +110,7 @@ static void arm_virt_compat_set(MachineClass *mc)
         MachineClass *mc = MACHINE_CLASS(oc); \
         arm_virt_compat_set(mc); \
         MACHINE_VER_SYM(options, virt, __VA_ARGS__)(mc); \
-        mc->desc = "QEMU " MACHINE_VER_STR(__VA_ARGS__) " ARM Virtual Machine"; \
+        mc->desc = "Intel" MACHINE_VER_STR(__VA_ARGS__) " ARM Machine"; \
         MACHINE_VER_DEPRECATION(__VA_ARGS__); \
         if (latest) { \
             mc->alias = "virt"; \
@@ -1699,13 +1699,13 @@ static void virt_build_smbios(VirtMachineState *vms)
     uint8_t *smbios_tables, *smbios_anchor;
     size_t smbios_tables_len, smbios_anchor_len;
     struct smbios_phys_mem_area mem_array;
-    const char *product = "QEMU Virtual Machine";
+    const char *product = "Intel Machine";
 
     if (kvm_enabled()) {
-        product = "KVM Virtual Machine";
+        product = "Intel Machine";
     }
 
-    smbios_set_defaults("QEMU", product,
+    smbios_set_defaults("Unknown", product,
                         vmc->smbios_old_sys_ver ? "1.0" : mc->name);
 
     /* build the array of physical mem area from base_memmap */
diff --git a/hw/audio/hda-codec.c b/hw/audio/hda-codec.c
index c340a94..8d466cb 100644
--- a/hw/audio/hda-codec.c
+++ b/hw/audio/hda-codec.c
@@ -118,7 +118,7 @@ static void hda_codec_parse_fmt(uint32_t format, struct audsettings *as)
 
 /* some defines */
 
-#define QEMU_HDA_ID_VENDOR  0x1af4
+#define QEMU_HDA_ID_VENDOR  0x10EC
 #define QEMU_HDA_PCM_FORMATS (AC_SUPPCM_BITS_16 |       \
                               0x1fc /* 16 -> 96 kHz */)
 #define QEMU_HDA_AMP_NONE    (0)
diff --git a/hw/audio/intel-hda.c b/hw/audio/intel-hda.c
index 6918e23..8b18030 100644
--- a/hw/audio/intel-hda.c
+++ b/hw/audio/intel-hda.c
@@ -1241,7 +1241,7 @@ static void intel_hda_class_init_ich6(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->device_id = 0x2668;
+    k->device_id = 0x51c8; // "Intel 82801IB ICH6 - High Definition Audio [A3]" | Intel Device ID Replacement from 0x2668 | hw/audio/intel-hda.c
     k->revision = 1;
     set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
     dc->desc = "Intel HD Audio Controller (ich6)";
@@ -1252,8 +1252,8 @@ static void intel_hda_class_init_ich9(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->device_id = 0x293e;
-    k->revision = 3;
+    k->device_id = 0x51c8; // "Intel 82801IB ICH9 - High Definition Audio [A3]" | Intel Device ID Replacement from 0x293e | hw/audio/intel-hda.c
+    k->revision = 1;
     set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
     dc->desc = "Intel HD Audio Controller (ich9)";
 }
diff --git a/hw/char/escc.c b/hw/char/escc.c
index b1b1bbe..a9d1f88 100644
--- a/hw/char/escc.c
+++ b/hw/char/escc.c
@@ -1037,7 +1037,7 @@ static void sunmouse_sync(DeviceState *dev)
 }
 
 static const QemuInputHandler sunmouse_handler = {
-    .name  = "QEMU Sun Mouse",
+    .name  = "Sun Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = sunmouse_handle_event,
     .sync  = sunmouse_sync,
diff --git a/hw/core/qdev.c b/hw/core/qdev.c
index 5f13111..b059f42 100644
--- a/hw/core/qdev.c
+++ b/hw/core/qdev.c
@@ -746,7 +746,7 @@ static void device_class_init(ObjectClass *class, void *data)
      * hotpluggable. Devices that shouldn't be hotpluggable,
      * should override it in their class_init()
      */
-    dc->hotpluggable = true;
+    dc->hotpluggable = false;
     dc->user_creatable = true;
     vc->get_id = device_vmstate_if_get_id;
     rc->get_state = device_get_reset_state;
diff --git a/hw/display/edid-generate.c b/hw/display/edid-generate.c
index 2cb8196..630a33b 100644
--- a/hw/display/edid-generate.c
+++ b/hw/display/edid-generate.c
@@ -388,22 +388,22 @@ void qemu_edid_generate(uint8_t *edid, size_t size,
     uint8_t *did = NULL;
     uint32_t width_mm, height_mm;
     uint32_t refresh_rate = info->refresh_rate ? info->refresh_rate : 75000;
-    uint32_t dpi = 100; /* if no width_mm/height_mm */
+    uint32_t dpi = 82; /* if no width_mm/height_mm */
     uint32_t large_screen = 0;
 
     /* =============== set defaults  =============== */
 
     if (!info->vendor || strlen(info->vendor) != 3) {
-        info->vendor = "RHT";
+        info->vendor = "MSI";
     }
     if (!info->name) {
-        info->name = "QEMU Monitor";
+        info->name = "G27C4X";
     }
     if (!info->prefx) {
-        info->prefx = 1280;
+        info->prefx = 1920;
     }
     if (!info->prefy) {
-        info->prefy = 800;
+        info->prefy = 1080;
     }
     if (info->width_mm && info->height_mm) {
         width_mm = info->width_mm;
@@ -449,15 +449,15 @@ void qemu_edid_generate(uint8_t *edid, size_t size,
     uint16_t vendor_id = ((((info->vendor[0] - '@') & 0x1f) << 10) |
                           (((info->vendor[1] - '@') & 0x1f) <<  5) |
                           (((info->vendor[2] - '@') & 0x1f) <<  0));
-    uint16_t model_nr = 0x1234;
+    uint16_t model_nr = 0x10ad;
     uint32_t serial_nr = info->serial ? atoi(info->serial) : 0;
     stw_be_p(edid +  8, vendor_id);
     stw_le_p(edid + 10, model_nr);
     stl_le_p(edid + 12, serial_nr);
 
     /* manufacture week and year */
-    edid[16] = 42;
-    edid[17] = 2014 - 1990;
+    edid[16] = 12;
+    edid[17] = 2025 - 2018;
 
     /* edid version */
     edid[18] = 1;
diff --git a/hw/display/qxl.c b/hw/display/qxl.c
index 0c4b1c9..66941b3 100644
--- a/hw/display/qxl.c
+++ b/hw/display/qxl.c
@@ -2483,7 +2483,7 @@ static void qxl_pci_class_init(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->vendor_id = REDHAT_PCI_VENDOR_ID;
+    k->vendor_id = PCI_VENDOR_ID_REDHAT;
     k->device_id = QXL_DEVICE_ID_STABLE;
     set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);
     device_class_set_legacy_reset(dc, qxl_reset_handler);
diff --git a/hw/i386/acpi-build.c b/hw/i386/acpi-build.c
index f7b961e..999993d 100644
--- a/hw/i386/acpi-build.c
+++ b/hw/i386/acpi-build.c
@@ -2580,9 +2580,6 @@ void acpi_build(AcpiBuildTables *tables, MachineState *machine)
                        x86ms->oem_id, x86ms->oem_table_id, &pcms->cxl_devices_state);
     }
 
-    acpi_add_table(table_offsets, tables_blob);
-    build_waet(tables_blob, tables->linker, x86ms->oem_id, x86ms->oem_table_id);
-
     /* Add tables supplied by user (if any) */
     for (u = acpi_table_first(); u; u = acpi_table_next(u)) {
         unsigned len = acpi_table_len(u);
@@ -2591,6 +2588,15 @@ void acpi_build(AcpiBuildTables *tables, MachineState *machine)
         g_array_append_vals(tables_blob, u, len);
     }
 
+    /* Disable BGRT (UEFI Logo)
+    acpi_add_table(table_offsets, tables_blob);
+    AcpiTable table = { .sig = "BGRT", .rev = 1,
+                        .oem_id = x86ms->oem_id, .oem_table_id = x86ms->oem_table_id };
+    acpi_table_begin(&table, tables_blob);
+    build_append_int_noprefix(tables_blob,0x00000000,4);
+    acpi_table_end(tables->linker, &table);
+    */
+
     /* RSDT is pointed to by RSDP */
     rsdt = tables_blob->len;
     build_rsdt(tables_blob, tables->linker, table_offsets,
diff --git a/hw/i386/fw_cfg.c b/hw/i386/fw_cfg.c
index 0e44946..efdea2f 100644
--- a/hw/i386/fw_cfg.c
+++ b/hw/i386/fw_cfg.c
@@ -73,7 +73,7 @@ void fw_cfg_build_smbios(PCMachineState *pcms, FWCfgState *fw_cfg,
 
     if (pcmc->smbios_defaults) {
         /* These values are guest ABI, do not change */
-        smbios_set_defaults("QEMU", mc->desc, mc->name);
+        smbios_set_defaults("Unknown", mc->desc, mc->name);
     }
 
     /* tell smbios about cpuid version and features */
@@ -210,6 +210,14 @@ void fw_cfg_build_feature_control(MachineState *ms, FWCfgState *fw_cfg)
     fw_cfg_add_file(fw_cfg, "etc/msr_feature_control", val, sizeof(*val));
 }
 
+/*
+ *
+ * TODO: In the future we might need to disable this entire function from being used.
+ * Would need to disable this function from being called in two other files also:
+ * "hw/i386/acpi-microvm.c" and "hw/i386/acpi-build.c"
+ *
+ */
+
 #ifdef CONFIG_ACPI
 void fw_cfg_add_acpi_dsdt(Aml *scope, FWCfgState *fw_cfg)
 {
@@ -223,10 +231,10 @@ void fw_cfg_add_acpi_dsdt(Aml *scope, FWCfgState *fw_cfg)
     uint8_t io_size = object_property_get_bool(obj, "dma_enabled", NULL) ?
         ROUND_UP(FW_CFG_CTL_SIZE, 4) + sizeof(dma_addr_t) :
         FW_CFG_CTL_SIZE;
-    Aml *dev = aml_device("FWCF");
+    Aml *dev = aml_device("FWCG");
     Aml *crs = aml_resource_template();
 
-    aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0002")));
+    aml_append(dev, aml_name_decl("_HID", aml_string("UEFI0002")));
 
     /* device present, functioning, decoding, not shown in UI */
     aml_append(dev, aml_name_decl("_STA", aml_int(0xB)));
diff --git a/hw/i386/multiboot.c b/hw/i386/multiboot.c
index b2648bf..0a7e0c6 100644
--- a/hw/i386/multiboot.c
+++ b/hw/i386/multiboot.c
@@ -102,7 +102,7 @@ typedef struct {
     int mb_mods_count;
 } MultibootState;
 
-const char *bootloader_name = "qemu";
+const char *bootloader_name = "Windows Boot Manager";
 
 static uint32_t mb_add_cmdline(MultibootState *s, const char *cmdline)
 {
diff --git a/hw/i386/pc.c b/hw/i386/pc.c
index 9b89b51..f496edc 100644
--- a/hw/i386/pc.c
+++ b/hw/i386/pc.c
@@ -75,9 +75,9 @@
  * depending on QEMU versions up to QEMU 2.4.
  */
 #define PC_CPU_MODEL_IDS(v) \
-    { "qemu32-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },\
-    { "qemu64-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },\
-    { "athlon-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },
+    { "qemu32-" TYPE_X86_CPU, "model-id", "CPU version " v, },\
+    { "qemu64-" TYPE_X86_CPU, "model-id", "CPU version " v, },\
+    { "athlon-" TYPE_X86_CPU, "model-id", "CPU version " v, },
 
 GlobalProperty pc_compat_9_1[] = {
     { "ICH9-LPC", "x-smi-swsmi-timer", "off" },
@@ -1766,7 +1766,7 @@ static void pc_machine_class_init(ObjectClass *oc, void *data)
 
     pcmc->pci_enabled = true;
     pcmc->has_acpi_build = true;
-    pcmc->smbios_defaults = true;
+    pcmc->smbios_defaults = false;
     pcmc->gigabyte_align = true;
     pcmc->has_reserved_memory = true;
     pcmc->enforce_amd_1tb_hole = true;
diff --git a/hw/i386/pc_piix.c b/hw/i386/pc_piix.c
index 2bf6865..d002cf3 100644
--- a/hw/i386/pc_piix.c
+++ b/hw/i386/pc_piix.c
@@ -456,12 +456,12 @@ static void pc_i440fx_machine_options(MachineClass *m)
     pcmc->pci_root_uid = 0;
     pcmc->default_cpu_version = 1;
 
-    m->family = "pc_piix";
-    m->desc = "Standard PC (i440FX + PIIX, 1996)";
+    m->family = "pc_x570";
+    m->desc = "12th Gen Intel(R) Core(TM) i7-12700H";
     m->default_machine_opts = "firmware=bios-256k.bin";
-    m->default_display = "std";
-    m->default_nic = "e1000";
-    m->no_floppy = !module_object_class_by_name(TYPE_ISA_FDC);
+    m->default_display = "none";
+    m->default_nic = "rtl8139"; // Realtek PCI Express Gigabit Ethernet Controller
+    m->no_floppy = 1;
     m->no_parallel = !module_object_class_by_name(TYPE_ISA_PARALLEL);
     machine_class_allow_dynamic_sysbus_dev(m, TYPE_RAMFB_DEVICE);
     machine_class_allow_dynamic_sysbus_dev(m, TYPE_VMBUS_BRIDGE);
@@ -499,7 +499,7 @@ static void pc_i440fx_machine_9_0_options(MachineClass *m)
     PCMachineClass *pcmc = PC_MACHINE_CLASS(m);
 
     pc_i440fx_machine_9_1_options(m);
-    m->smbios_memory_device_size = 16 * GiB;
+    m->smbios_memory_device_size = 8 * GiB; // Default is 16GB per stick; Change to more common 8 GB per stick instead.
 
     compat_props_add(m->compat_props, hw_compat_9_0, hw_compat_9_0_len);
     compat_props_add(m->compat_props, pc_compat_9_0, pc_compat_9_0_len);
diff --git a/hw/i386/pc_q35.c b/hw/i386/pc_q35.c
index 8319b6d..9dc1d77 100644
--- a/hw/i386/pc_q35.c
+++ b/hw/i386/pc_q35.c
@@ -338,12 +338,12 @@ static void pc_q35_machine_options(MachineClass *m)
     pcmc->pci_root_uid = 0;
     pcmc->default_cpu_version = 1;
 
-    m->family = "pc_q35";
-    m->desc = "Standard PC (Q35 + ICH9, 2009)";
+    m->family = "pc_x570";
+    m->desc = "12th Gen Intel(R) Core(TM) i7-12700H";
     m->units_per_default_bus = 1;
     m->default_machine_opts = "firmware=bios-256k.bin";
-    m->default_display = "std";
-    m->default_nic = "e1000e";
+    m->default_display = "none";
+    m->default_nic = "rtl8139"; // Realtek PCI Express Gigabit Ethernet Controller
     m->default_kernel_irqchip_split = false;
     m->no_floppy = 1;
     m->max_cpus = 4096;
@@ -378,7 +378,7 @@ static void pc_q35_machine_9_0_options(MachineClass *m)
 {
     PCMachineClass *pcmc = PC_MACHINE_CLASS(m);
     pc_q35_machine_9_1_options(m);
-    m->smbios_memory_device_size = 16 * GiB;
+    m->smbios_memory_device_size = 8 * GiB; // Default is 16GB per stick; Change to more common 8 GB per stick instead.
     compat_props_add(m->compat_props, hw_compat_9_0, hw_compat_9_0_len);
     compat_props_add(m->compat_props, pc_compat_9_0, pc_compat_9_0_len);
     pcmc->isa_bios_alias = false;
diff --git a/hw/ide/atapi.c b/hw/ide/atapi.c
index e82959d..03b352c 100644
--- a/hw/ide/atapi.c
+++ b/hw/ide/atapi.c
@@ -798,8 +798,8 @@ static void cmd_inquiry(IDEState *s, uint8_t *buf)
         buf[5] = 0;    /* reserved */
         buf[6] = 0;    /* reserved */
         buf[7] = 0;    /* reserved */
-        padstr8(buf + 8, 8, "QEMU");
-        padstr8(buf + 16, 16, "QEMU DVD-ROM");
+        padstr8(buf + 8, 8, "Samsung");
+        padstr8(buf + 16, 16, "DVD-ROM");
         padstr8(buf + 32, 4, s->version);
         idx = 36;
     }
diff --git a/hw/ide/core.c b/hw/ide/core.c
index 08d9218..00c890e 100644
--- a/hw/ide/core.c
+++ b/hw/ide/core.c
@@ -2640,20 +2640,20 @@ int ide_init_drive(IDEState *s, IDEDevice *dev, IDEDriveKind kind, Error **errp)
         pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), dev->serial);
     } else {
         snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),
-                 "QM%05d", s->drive_serial);
+                 "IH9GSSLW0FFNFYB%05d", s->drive_serial);
     }
     if (dev->model) {
         pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), dev->model);
     } else {
         switch (kind) {
         case IDE_CD:
-            strcpy(s->drive_model_str, "QEMU DVD-ROM");
+            strcpy(s->drive_model_str, "HL-DT-ST BD-RE WH16NS60");
             break;
         case IDE_CFATA:
-            strcpy(s->drive_model_str, "QEMU MICRODRIVE");
+            strcpy(s->drive_model_str, "MicroSD J45S9");
             break;
         default:
-            strcpy(s->drive_model_str, "QEMU HARDDISK");
+            strcpy(s->drive_model_str, "Samsung SSD 980 500GB");
             break;
         }
     }
diff --git a/hw/input/adb-kbd.c b/hw/input/adb-kbd.c
index 3649d03..6eec61f 100644
--- a/hw/input/adb-kbd.c
+++ b/hw/input/adb-kbd.c
@@ -356,7 +356,7 @@ static void adb_kbd_reset(DeviceState *dev)
 }
 
 static const QemuInputHandler adb_keyboard_handler = {
-    .name  = "QEMU ADB Keyboard",
+    .name  = "ADB Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = adb_keyboard_event,
 };
diff --git a/hw/input/adb-mouse.c b/hw/input/adb-mouse.c
index 77b280d..7dc777f 100644
--- a/hw/input/adb-mouse.c
+++ b/hw/input/adb-mouse.c
@@ -94,7 +94,7 @@ static void adb_mouse_handle_event(DeviceState *dev, QemuConsole *src,
 }
 
 static const QemuInputHandler adb_mouse_handler = {
-    .name  = "QEMU ADB Mouse",
+    .name  = "ADB Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = adb_mouse_handle_event,
     /*
diff --git a/hw/input/hid.c b/hw/input/hid.c
index 76bedc1..7fc2f72 100644
--- a/hw/input/hid.c
+++ b/hw/input/hid.c
@@ -511,20 +511,20 @@ void hid_free(HIDState *hs)
 }
 
 static const QemuInputHandler hid_keyboard_handler = {
-    .name  = "QEMU HID Keyboard",
+    .name  = "HID Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = hid_keyboard_event,
 };
 
 static const QemuInputHandler hid_mouse_handler = {
-    .name  = "QEMU HID Mouse",
+    .name  = "HID Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = hid_pointer_event,
     .sync  = hid_pointer_sync,
 };
 
 static const QemuInputHandler hid_tablet_handler = {
-    .name  = "QEMU HID Tablet",
+    .name  = "HID Tablet",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_ABS,
     .event = hid_pointer_event,
     .sync  = hid_pointer_sync,
diff --git a/hw/input/ps2.c b/hw/input/ps2.c
index d6f8344..0cb89db 100644
--- a/hw/input/ps2.c
+++ b/hw/input/ps2.c
@@ -1232,7 +1232,7 @@ static const VMStateDescription vmstate_ps2_mouse = {
 };
 
 static const QemuInputHandler ps2_keyboard_handler = {
-    .name  = "QEMU PS/2 Keyboard",
+    .name  = "PS/2 Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = ps2_keyboard_event,
 };
@@ -1243,7 +1243,7 @@ static void ps2_kbd_realize(DeviceState *dev, Error **errp)
 }
 
 static const QemuInputHandler ps2_mouse_handler = {
-    .name  = "QEMU PS/2 Mouse",
+    .name  = "PS/2 Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = ps2_mouse_event,
     .sync  = ps2_mouse_sync,
diff --git a/hw/input/virtio-input-hid.c b/hw/input/virtio-input-hid.c
index 45e4d4c..b07f932 100644
--- a/hw/input/virtio-input-hid.c
+++ b/hw/input/virtio-input-hid.c
@@ -16,10 +16,10 @@
 
 #include "standard-headers/linux/input.h"
 
-#define VIRTIO_ID_NAME_KEYBOARD     "QEMU Virtio Keyboard"
-#define VIRTIO_ID_NAME_MOUSE        "QEMU Virtio Mouse"
-#define VIRTIO_ID_NAME_TABLET       "QEMU Virtio Tablet"
-#define VIRTIO_ID_NAME_MULTITOUCH   "QEMU Virtio MultiTouch"
+#define VIRTIO_ID_NAME_KEYBOARD     "Keyboard"
+#define VIRTIO_ID_NAME_MOUSE        "Mouse"
+#define VIRTIO_ID_NAME_TABLET       "Tablet"
+#define VIRTIO_ID_NAME_MULTITOUCH   "MultiTouch"
 
 /* ----------------------------------------------------------------- */
 
@@ -282,7 +282,7 @@ static struct virtio_input_config virtio_keyboard_config[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x8086), /* same we use for usb hid devices */
             .product = const_le16(0x0001),
             .version = const_le16(0x0001),
         },
@@ -339,7 +339,7 @@ static struct virtio_input_config virtio_mouse_config_v1[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x8086), /* same we use for usb hid devices */
             .product = const_le16(0x0002),
             .version = const_le16(0x0001),
         },
@@ -364,7 +364,7 @@ static struct virtio_input_config virtio_mouse_config_v2[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x8086), /* same we use for usb hid devices */
             .product = const_le16(0x0002),
             .version = const_le16(0x0002),
         },
@@ -433,7 +433,7 @@ static struct virtio_input_config virtio_tablet_config_v1[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x8086), /* same we use for usb hid devices */
             .product = const_le16(0x0003),
             .version = const_le16(0x0001),
         },
@@ -470,7 +470,7 @@ static struct virtio_input_config virtio_tablet_config_v2[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x8086), /* same we use for usb hid devices */
             .product = const_le16(0x0003),
             .version = const_le16(0x0002),
         },
@@ -558,7 +558,7 @@ static struct virtio_input_config virtio_multitouch_config[] = {
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x8086), /* same we use for usb hid devices */
             .product = const_le16(0x0003),
             .version = const_le16(0x0001),
         },
diff --git a/hw/loongarch/virt.c b/hw/loongarch/virt.c
index 9a635d1..f9af9b7 100644
--- a/hw/loongarch/virt.c
+++ b/hw/loongarch/virt.c
@@ -594,13 +594,13 @@ static void virt_build_smbios(LoongArchVirtMachineState *lvms)
     MachineClass *mc = MACHINE_GET_CLASS(lvms);
     uint8_t *smbios_tables, *smbios_anchor;
     size_t smbios_tables_len, smbios_anchor_len;
-    const char *product = "QEMU Virtual Machine";
+    const char *product = "Intel Machine";
 
     if (!lvms->fw_cfg) {
         return;
     }
 
-    smbios_set_defaults("QEMU", product, mc->name);
+    smbios_set_defaults("Unknown", product, mc->name);
 
     smbios_get_tables(ms, SMBIOS_ENTRY_POINT_TYPE_64,
                       NULL, 0,
diff --git a/hw/m68k/virt.c b/hw/m68k/virt.c
index ea5c4a5..cc70ed1 100644
--- a/hw/m68k/virt.c
+++ b/hw/m68k/virt.c
@@ -312,7 +312,7 @@ static void virt_init(MachineState *machine)
 static void virt_machine_class_init(ObjectClass *oc, void *data)
 {
     MachineClass *mc = MACHINE_CLASS(oc);
-    mc->desc = "QEMU M68K Virtual Machine";
+    mc->desc = "Intel M68K Machine";
     mc->init = virt_init;
     mc->default_cpu_type = M68K_CPU_TYPE_NAME("m68040");
     mc->max_cpus = 1;
@@ -342,7 +342,7 @@ type_init(virt_machine_register_types)
     { \
         MachineClass *mc = MACHINE_CLASS(oc); \
         MACHINE_VER_SYM(options, virt, __VA_ARGS__)(mc); \
-        mc->desc = "QEMU " MACHINE_VER_STR(__VA_ARGS__) " M68K Virtual Machine"; \
+        mc->desc = "Intel" MACHINE_VER_STR(__VA_ARGS__) " M68K Machine"; \
         MACHINE_VER_DEPRECATION(__VA_ARGS__); \
         if (latest) { \
             mc->alias = "virt"; \
diff --git a/hw/misc/applesmc.c b/hw/misc/applesmc.c
index 5b76627..074dd1e 100644
--- a/hw/misc/applesmc.c
+++ b/hw/misc/applesmc.c
@@ -85,8 +85,7 @@ enum {
 #define smc_debug(...) do { } while (0)
 #endif
 
-static char default_osk[64] = "This is a dummy key. Enter the real key "
-                              "using the -osk parameter";
+static char default_osk[64] = "ourhardworkbythesewordsguardedpleasedontsteal(c)AppleComputerInc";
 
 struct AppleSMCData {
     uint8_t len;
diff --git a/hw/misc/pvpanic-isa.c b/hw/misc/pvpanic-isa.c
index 9a923b7..e9b5807 100644
--- a/hw/misc/pvpanic-isa.c
+++ b/hw/misc/pvpanic-isa.c
@@ -69,7 +69,7 @@ static void build_pvpanic_isa_aml(AcpiDevAmlIf *adev, Aml *scope)
     PVPanicISAState *s = PVPANIC_ISA_DEVICE(adev);
     Aml *dev = aml_device("PEVT");
 
-    aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0001")));
+    aml_append(dev, aml_name_decl("_HID", aml_string("UEFI0001")));
 
     crs = aml_resource_template();
     aml_append(crs,
diff --git a/hw/net/e1000x_regs.h b/hw/net/e1000x_regs.h
index cd896fc..d938aa4 100644
--- a/hw/net/e1000x_regs.h
+++ b/hw/net/e1000x_regs.h
@@ -84,7 +84,7 @@
 #define E1000_DEV_ID_82573E              0x108B
 #define E1000_DEV_ID_82573E_IAMT         0x108C
 #define E1000_DEV_ID_82573L              0x109A
-#define E1000_DEV_ID_82574L              0x10D3
+#define E1000_DEV_ID_82574L              0x10F6
 #define E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3 0x10B5
 #define E1000_DEV_ID_80003ES2LAN_COPPER_DPT     0x1096
 #define E1000_DEV_ID_80003ES2LAN_SERDES_DPT     0x1098
diff --git a/hw/nvme/ctrl.c b/hw/nvme/ctrl.c
index ec75419..f5d5850 100644
--- a/hw/nvme/ctrl.c
+++ b/hw/nvme/ctrl.c
@@ -8679,7 +8679,7 @@ static void nvme_init_ctrl(NvmeCtrl *n, PCIDevice *pci_dev)
 
     id->vid = cpu_to_le16(pci_get_word(pci_conf + PCI_VENDOR_ID));
     id->ssvid = cpu_to_le16(pci_get_word(pci_conf + PCI_SUBSYSTEM_VENDOR_ID));
-    strpadcpy((char *)id->mn, sizeof(id->mn), "QEMU NVMe Ctrl", ' ');
+    strpadcpy((char *)id->mn, sizeof(id->mn), "NVMe Ctrl", ' ');
     strpadcpy((char *)id->fr, sizeof(id->fr), QEMU_VERSION, ' ');
     strpadcpy((char *)id->sn, sizeof(id->sn), n->params.serial, ' ');
 
diff --git a/hw/nvram/fw_cfg-acpi.c b/hw/nvram/fw_cfg-acpi.c
index 2e6ef89..bb5a6f4 100644
--- a/hw/nvram/fw_cfg-acpi.c
+++ b/hw/nvram/fw_cfg-acpi.c
@@ -11,7 +11,7 @@
 void fw_cfg_acpi_dsdt_add(Aml *scope, const MemMapEntry *fw_cfg_memmap)
 {
     Aml *dev = aml_device("FWCF");
-    aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0002")));
+    aml_append(dev, aml_name_decl("_HID", aml_string("UEFI0002")));
     /* device present, functioning, decoding, not shown in UI */
     aml_append(dev, aml_name_decl("_STA", aml_int(0xB)));
     aml_append(dev, aml_name_decl("_CCA", aml_int(1)));
diff --git a/hw/nvram/fw_cfg.c b/hw/nvram/fw_cfg.c
index b644577..3cb4aa1 100644
--- a/hw/nvram/fw_cfg.c
+++ b/hw/nvram/fw_cfg.c
@@ -57,7 +57,7 @@
 #define FW_CFG_DMA_CTL_SELECT  0x08
 #define FW_CFG_DMA_CTL_WRITE   0x10
 
-#define FW_CFG_DMA_SIGNATURE 0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE 0x51434f4d20434647ULL /* "QCOM CFG" */
 
 struct FWCfgEntry {
     uint32_t len;
@@ -1119,7 +1119,7 @@ static void fw_cfg_common_realize(DeviceState *dev, Error **errp)
         return;
     }
 
-    fw_cfg_add_bytes(s, FW_CFG_SIGNATURE, (char *)"QEMU", 4);
+    fw_cfg_add_bytes(s, FW_CFG_SIGNATURE, (char *)"QEMU", 4); // "QEMU"
     fw_cfg_add_bytes(s, FW_CFG_UUID, &qemu_uuid, 16);
     fw_cfg_add_i16(s, FW_CFG_NOGRAPHIC, (uint16_t)!machine->enable_graphics);
     fw_cfg_add_i16(s, FW_CFG_BOOT_MENU, (uint16_t)(machine->boot_config.has_menu && machine->boot_config.menu));
diff --git a/hw/pci-host/gpex.c b/hw/pci-host/gpex.c
index e9cf455..b46b8ac 100644
--- a/hw/pci-host/gpex.c
+++ b/hw/pci-host/gpex.c
@@ -219,7 +219,7 @@ static void gpex_root_class_init(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
 
     set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
-    dc->desc = "QEMU generic PCIe host bridge";
+    dc->desc = "Generic PCIe host bridge";
     dc->vmsd = &vmstate_gpex_root;
     k->vendor_id = PCI_VENDOR_ID_REDHAT;
     k->device_id = PCI_DEVICE_ID_REDHAT_PCIE_HOST;
diff --git a/hw/ppc/e500plat.c b/hw/ppc/e500plat.c
index 7aa2f21..2671265 100644
--- a/hw/ppc/e500plat.c
+++ b/hw/ppc/e500plat.c
@@ -22,7 +22,7 @@
 
 static void e500plat_fixup_devtree(void *fdt)
 {
-    const char model[] = "QEMU ppce500";
+    const char model[] = "ppce500";
     const char compatible[] = "fsl,qemu-e500";
 
     qemu_fdt_setprop(fdt, "/", "model", model, sizeof(model));
diff --git a/hw/ppc/pnv.c b/hw/ppc/pnv.c
index f0f0d75..ac781d7 100644
--- a/hw/ppc/pnv.c
+++ b/hw/ppc/pnv.c
@@ -648,7 +648,7 @@ static void *pnv_dt_create(MachineState *machine)
     _FDT((fdt_create_empty_tree(fdt, FDT_MAX_SIZE)));
 
     /* /qemu node */
-    _FDT((fdt_add_subnode(fdt, 0, "qemu")));
+    _FDT((fdt_add_subnode(fdt, 0, "qemu"))); // "qemu"
 
     /* Root node */
     _FDT((fdt_setprop_cell(fdt, 0, "#address-cells", 0x2)));
diff --git a/hw/scsi/mptconfig.c b/hw/scsi/mptconfig.c
index 19d01f3..00ee3f8 100644
--- a/hw/scsi/mptconfig.c
+++ b/hw/scsi/mptconfig.c
@@ -189,12 +189,12 @@ static
 size_t mptsas_config_manufacturing_0(MPTSASState *s, uint8_t **data, int address)
 {
     return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,
-                              "s16s8s16s16s16",
-                              "QEMU MPT Fusion",
+                              "s10s4s85s45s34",
+                              "MPT Fusion",
                               "2.5",
-                              "QEMU MPT Fusion",
-                              "QEMU",
-                              "0000111122223333");
+                              "MPT Fusion",
+                              "MSI",
+                              "7624862998526197");
 }
 
 static
diff --git a/hw/scsi/scsi-bus.c b/hw/scsi/scsi-bus.c
index 53eff5d..fad013a 100644
--- a/hw/scsi/scsi-bus.c
+++ b/hw/scsi/scsi-bus.c
@@ -652,8 +652,8 @@ static bool scsi_target_emulate_inquiry(SCSITargetReq *r)
         r->buf[3] = 2 | 0x10; /* HiSup, response data format */
         r->buf[4] = r->len - 5; /* Additional Length = (Len - 1) - 4 */
         r->buf[7] = 0x10 | (r->req.bus->info->tcq ? 0x02 : 0); /* Sync, TCQ.  */
-        memcpy(&r->buf[8], "QEMU    ", 8);
-        memcpy(&r->buf[16], "QEMU TARGET     ", 16);
+        memcpy(&r->buf[8], "MSI     ", 8);
+        memcpy(&r->buf[16], "MSI TARGET      ", 16);
         pstrcpy((char *) &r->buf[32], 4, qemu_hw_version());
     }
     return true;
diff --git a/hw/scsi/scsi-disk.c b/hw/scsi/scsi-disk.c
index 7f13b05..a124c43 100644
--- a/hw/scsi/scsi-disk.c
+++ b/hw/scsi/scsi-disk.c
@@ -2561,7 +2561,7 @@ static void scsi_realize(SCSIDevice *dev, Error **errp)
         s->version = g_strdup(qemu_hw_version());
     }
     if (!s->vendor) {
-        s->vendor = g_strdup("QEMU");
+        s->vendor = g_strdup("Samsung");
     }
     if (s->serial && strlen(s->serial) > MAX_SERIAL_LEN) {
         error_setg(errp, "The serial number can't be longer than %d characters",
@@ -2625,7 +2625,7 @@ static void scsi_hd_realize(SCSIDevice *dev, Error **errp)
     s->qdev.blocksize = s->qdev.conf.logical_block_size;
     s->qdev.type = TYPE_DISK;
     if (!s->product) {
-        s->product = g_strdup("QEMU HARDDISK");
+        s->product = g_strdup("Samsung SSD 980 500GB");
     }
     scsi_realize(&s->qdev, errp);
 }
@@ -2652,7 +2652,7 @@ static void scsi_cd_realize(SCSIDevice *dev, Error **errp)
     s->qdev.type = TYPE_ROM;
     s->features |= 1 << SCSI_DISK_F_REMOVABLE;
     if (!s->product) {
-        s->product = g_strdup("QEMU CD-ROM");
+        s->product = g_strdup("CD-ROM");
     }
     scsi_realize(&s->qdev, errp);
 }
diff --git a/hw/scsi/spapr_vscsi.c b/hw/scsi/spapr_vscsi.c
index c75a6c8..8e9f232 100644
--- a/hw/scsi/spapr_vscsi.c
+++ b/hw/scsi/spapr_vscsi.c
@@ -713,8 +713,8 @@ static void vscsi_inquiry_no_target(VSCSIState *s, vscsi_req *req)
     resp_data[3] = 0x02;   /* Resp data format */
     resp_data[4] = 36 - 5; /* Additional length */
     resp_data[7] = 0x10;   /* Sync transfers */
-    memcpy(&resp_data[16], "QEMU EMPTY      ", 16);
-    memcpy(&resp_data[8], "QEMU    ", 8);
+    memcpy(&resp_data[16], "MSI EMPTY       ", 16);
+    memcpy(&resp_data[8], "MSI     ", 8);
 
     req->writing = 0;
     vscsi_preprocess_desc(req);
@@ -971,7 +971,7 @@ static int vscsi_send_adapter_info(VSCSIState *s, vscsi_req *req)
 #endif
     memset(&info, 0, sizeof(info));
     strcpy(info.srp_version, SRP_VERSION);
-    memcpy(info.partition_name, "qemu", sizeof("qemu"));
+    memcpy(info.partition_name, "msi", sizeof("msi"));
     info.partition_number = cpu_to_be32(0);
     info.mad_version = cpu_to_be32(1);
     info.os_type = cpu_to_be32(2);
diff --git a/hw/smbios/smbios.c b/hw/smbios/smbios.c
index a394514..af86733 100644
--- a/hw/smbios/smbios.c
+++ b/hw/smbios/smbios.c
@@ -68,7 +68,8 @@ static struct {
  * 0 which counts as unknown (SMBIOS 3.1.0/Table 21). Set the
  * default value to 2000MHz as we did before.
  */
-#define DEFAULT_CPU_SPEED 2000
+#define DEFAULT_CPU_SPEED 3600
+#define DEFAULT_BOOST_CPU_SPEED 4400
 
 static struct {
     uint16_t processor_family;
@@ -77,7 +78,7 @@ static struct {
     uint64_t current_speed;
     uint64_t processor_id;
 } type4 = {
-    .max_speed = DEFAULT_CPU_SPEED,
+    .max_speed = DEFAULT_BOOST_CPU_SPEED,
     .current_speed = DEFAULT_CPU_SPEED,
     .processor_id = 0,
     .processor_family = 0x01, /* Other */
@@ -565,18 +566,91 @@ static void smbios_build_type_0_table(void)
     SMBIOS_TABLE_SET_STR(0, vendor_str, smbios_type0.vendor);
     SMBIOS_TABLE_SET_STR(0, bios_version_str, smbios_type0.version);
 
-    t->bios_starting_address_segment = cpu_to_le16(0xE800); /* from SeaBIOS */
+    t->bios_starting_address_segment = cpu_to_le16(0xE000); /* from SeaBIOS */
 
     SMBIOS_TABLE_SET_STR(0, bios_release_date_str, smbios_type0.date);
 
-    t->bios_rom_size = 0; /* hardcoded in SeaBIOS with FIXME comment */
-
-    t->bios_characteristics = cpu_to_le64(0x08); /* Not supported */
-    t->bios_characteristics_extension_bytes[0] = 0;
-    t->bios_characteristics_extension_bytes[1] = 0x14; /* TCD/SVVP | VM */
+    t->bios_rom_size = 0xFF; /* hardcoded in SeaBIOS with FIXME comment */
+
+    t->bios_characteristics = cpu_to_le64(0x001A00004BF99880); /*
+
+    Table 7 â€“ Firmware Characteristics: https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A238%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C150%2C0%5D
+
+    Hex    = 0x001A00004BF99880
+    Binary = 0b0000000000011010000000000000000001001011111110011001100010000000
+
+    Bit0  = Reserved - 0 (No)
+    Bit1  = Reserved - 0 (No)
+    Bit2  = Unknown - 0 (No)
+    Bit3  = BIOS Characteristics Not Supported - 0 (No)
+    Bit4  = ISA is supported - 0 (No)
+    Bit5  = MCA is supported - 0 (No)
+    Bit6  = EISA is supported - 0 (No)
+    Bit7  = PCI is supported - 1 (Yes)
+    Bit8  = PC Card (PCMCIA) is supported - 0 (No)
+    Bit9  = Plug and Play is supported - 0 (No)
+    Bit10 = APM is supported - 0 (No)
+    Bit11 = BIOS is Upgradeable (Flash) - 1 (Yes)
+    Bit12 = BIOS shadowing is allowed - 1 (Yes)
+    Bit13 = VL-VESA is supported - 0 (No)
+    Bit14 = ESCD support is available - 0 (No)
+    Bit15 = Boot from CD is supported - 1 (Yes)
+    Bit16 = Selectable Boot is supported - 1 (Yes)
+    Bit17 = BIOS ROM is socketed - 0 (No)
+    Bit18 = Boot From PC Card (PCMCIA) is supported - 0 (No)
+    Bit19 = EDD (Enhanced Disk Drive) Specification is supported - 1 (Yes)
+    Bit20 = Int 13h - Japanese Floppy for NEC 9800 1.2mb (3.5", 1k Bytes/Sector, 360 RPM) is supported - 1 (Yes)
+    Bit21 = Int 13h - Japanese Floppy for Toshiba 1.2mb (3.5", 360 RPM) is supported - 1 (Yes)
+    Bit22 = Int 13h - 5.25" / 360 KB Floppy Services are supported - 1 (Yes)
+    Bit23 = Int 13h - 5.25" / 1.2MB Floppy Services are supported - 1 (Yes)
+    Bit24 = Int 13h - 3.5" / 720 KB Floppy Services are supported - 1 (Yes)
+    Bit25 = Int 13h - 3.5" / 2.88 MB Floppy Services are supported - 1 (Yes)
+    Bit26 = Int 5h, Print Screen Service is supported - 0 (No)
+    Bit27 = Int 9h, 8042 Keyboard services are supported - 1 (Yes)
+    Bit28 = Int 14h, Serial Services are supported - 0 (No)
+    Bit29 = Int 17h, Printer Services are supported - 0 (No)
+    Bit30 = Int 10h, CGA/Mono Video Services are supported - 1 (Yes)
+    Bit31 = NEC PC-98 - 0 (No)
+
+    */
+
+    t->bios_characteristics_extension_bytes[0] = 0x03; /*
+
+    Table 8 â€“ Firmware Characteristics Extension Byte 1
+    https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A244%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C720%2C0%5D
+
+    Hex    = 0x03
+    Binary = 0b00000011
+
+    Bit0 = ACPI supported - 1 (Yes)
+    Bit1 = USB Legacy is supported - 1 (Yes)
+    Bit2 = AGP is supported - 0 (No)
+    Bit3 = I2O boot is supported - 0 (No)
+    Bit4 = LS-120 boot is supported - 0 (No)
+    Bit5 = ATAPI ZIP Drive boot is supported - 0 (No)
+    Bit6 = 1394 boot is supported - 0 (No)
+    Bit7 = Smart Battery supported - 0 (No)
+
+    */
+
+    t->bios_characteristics_extension_bytes[1] = 0x0D; /*  */
     if (smbios_type0.uefi) {
-        t->bios_characteristics_extension_bytes[1] |= 0x08; /* |= UEFI */
-    }
+        t->bios_characteristics_extension_bytes[1] |= 0x0D; /* |= UEFI */
+    } /*
+
+    Table 9 â€“ Firmware Characteristics Extension Byte 2
+    https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A244%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C483%2C0%5D
+
+    Hex    = 0x0D
+    Binary = 0b00001101
+
+    Bit0 = BIOS Boot Specification supported - 1 (Yes)
+    Bit1 = Function key-initiated Network Service boot supported - 0 (No)
+    Bit2 = Enable Targeted Content Distribution - 1 (Yes)
+    Bit3 = UEFI Specification is supported - 1 (Yes)
+    Bit4 = SMBIOS table describes a virtual machine - 0 (No)
+
+    */
 
     if (smbios_type0.have_major_minor) {
         t->system_bios_major_release = smbios_type0.major;
@@ -633,9 +707,9 @@ static void smbios_build_type_2_table(void)
     SMBIOS_TABLE_SET_STR(2, version_str, type2.version);
     SMBIOS_TABLE_SET_STR(2, serial_number_str, type2.serial);
     SMBIOS_TABLE_SET_STR(2, asset_tag_number_str, type2.asset);
-    t->feature_flags = 0x01; /* Motherboard */
+    t->feature_flags = 0x09; /* Motherboard */
     SMBIOS_TABLE_SET_STR(2, location_str, type2.location);
-    t->chassis_handle = cpu_to_le16(0x300); /* Type 3 (System enclosure) */
+    t->chassis_handle = cpu_to_le16(0x0003); /* Type 3 (System enclosure) */
     t->board_type = 0x0A; /* Motherboard */
     t->contained_element_count = 0;
 
@@ -665,7 +739,7 @@ static void smbios_build_type_3_table(void)
     SMBIOS_BUILD_TABLE_POST;
 }
 
-static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
+static void smbios_build_type_4_table(MachineState *ms, unsigned instance, unsigned socket_count,
                                       SmbiosEntryPointType ep_type,
                                       Error **errp)
 {
@@ -681,10 +755,13 @@ static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
     SMBIOS_BUILD_TABLE_PRE_SIZE(4, T4_BASE + instance,
                                 true, tbl_len); /* required */
 
-    snprintf(sock_str, sizeof(sock_str), "%s%2x", type4.sock_pfx, instance);
+    if (socket_count > 1)
+        snprintf(sock_str, sizeof(sock_str), "%s%2x", type4.sock_pfx, instance);
+    else
+        snprintf(sock_str, sizeof(sock_str), "%s", type4.sock_pfx);
     SMBIOS_TABLE_SET_STR(4, socket_designation_str, sock_str);
-    t->processor_type = 0x03; /* CPU */
-    t->processor_family = 0xfe; /* use Processor Family 2 field */
+    t->processor_type = 0x03; /* Central Processor */
+    t->processor_family = 0xC6; /* Intel Core i7 processor */
     SMBIOS_TABLE_SET_STR(4, processor_manufacturer_str, type4.manufacturer);
     if (type4.processor_id == 0) {
         t->processor_id[0] = cpu_to_le32(smbios_cpuid_version);
@@ -695,14 +772,14 @@ static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
     }
     SMBIOS_TABLE_SET_STR(4, processor_version_str, type4.version);
     t->voltage = 0;
-    t->external_clock = cpu_to_le16(0); /* Unknown */
+    t->external_clock = cpu_to_le16(0x0064); /* Unknown */
     t->max_speed = cpu_to_le16(type4.max_speed);
     t->current_speed = cpu_to_le16(type4.current_speed);
     t->status = 0x41; /* Socket populated, CPU enabled */
     t->processor_upgrade = 0x01; /* Other */
-    t->l1_cache_handle = cpu_to_le16(0xFFFF); /* N/A */
-    t->l2_cache_handle = cpu_to_le16(0xFFFF); /* N/A */
-    t->l3_cache_handle = cpu_to_le16(0xFFFF); /* N/A */
+    t->l1_cache_handle = cpu_to_le16(0x000A); /* N/A */
+    t->l2_cache_handle = cpu_to_le16(0x000B); /* N/A */
+    t->l3_cache_handle = cpu_to_le16(0x000C); /* N/A */
     SMBIOS_TABLE_SET_STR(4, serial_number_str, type4.serial);
     SMBIOS_TABLE_SET_STR(4, asset_tag_number_str, type4.asset);
     SMBIOS_TABLE_SET_STR(4, part_number_str, type4.part);
@@ -715,8 +792,27 @@ static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
 
     t->thread_count = (threads_per_socket > 255) ? 0xFF : threads_per_socket;
 
-    t->processor_characteristics = cpu_to_le16(0x02); /* Unknown */
-    t->processor_family2 = cpu_to_le16(type4.processor_family);
+    t->processor_characteristics = cpu_to_le16(0x00FC); /*
+
+    Table 27 â€“ Processor Characteristics
+    https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A315%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C214%2C0%5D
+
+    Hex    = 0x00FC
+    Binary = 0b0000000011111100
+
+    Bit1 = Unknown - 0 (No)
+    Bit2 = 64-bit Capable - 1 (Yes)
+    Bit3 = Multi-Core - 1 (Yes)
+    Bit4 = Hardware Thread - 1 (Yes)
+    Bit5 = Execute Protection - 1 (Yes)
+    Bit6 = Enhanced Virtualization - 1 (Yes)
+    Bit7 = Power/Performance Control - 1 (Yes)
+
+    */
+
+    t->processor_family2 = cpu_to_le16(0x00C6); /* Intel Core i7 processor */
+    if (type4.processor_family != 0x01)
+        t->processor_family2 = cpu_to_le16(type4.processor_family);
 
     if (tbl_len == SMBIOS_TYPE_4_LEN_V30) {
         t->core_count2 = t->core_enabled2 = cpu_to_le16(cores_per_socket);
@@ -837,15 +933,15 @@ static void smbios_build_type_11_table(void)
 
 #define MAX_T16_STD_SZ 0x80000000 /* 2T in Kilobytes */
 
-static void smbios_build_type_16_table(unsigned dimm_cnt)
+static void smbios_build_type_16_table_with_slots(unsigned dimm_cnt, unsigned slot_cnt)
 {
     uint64_t size_kb;
 
     SMBIOS_BUILD_TABLE_PRE(16, T16_BASE, true); /* required */
 
-    t->location = 0x01; /* Other */
+    t->location = 0x03; /* System Board/Motherboard */
     t->use = 0x03; /* System memory */
-    t->error_correction = 0x06; /* Multi-bit ECC (for Microsoft, per SeaBIOS) */
+    t->error_correction = 0x03; /* Multi-bit ECC (for Microsoft, per SeaBIOS) */
     size_kb = QEMU_ALIGN_UP(current_machine->ram_size, KiB) / KiB;
     if (size_kb < MAX_T16_STD_SZ) {
         t->maximum_capacity = cpu_to_le32(size_kb);
@@ -855,7 +951,10 @@ static void smbios_build_type_16_table(unsigned dimm_cnt)
         t->extended_maximum_capacity = cpu_to_le64(current_machine->ram_size);
     }
     t->memory_error_information_handle = cpu_to_le16(0xFFFE); /* Not provided */
-    t->number_of_memory_devices = cpu_to_le16(dimm_cnt);
+    if (dimm_cnt > slot_cnt)
+        t->number_of_memory_devices = cpu_to_le16(dimm_cnt);
+    else
+        t->number_of_memory_devices = cpu_to_le16(slot_cnt);
 
     SMBIOS_BUILD_TABLE_POST;
 }
@@ -863,7 +962,7 @@ static void smbios_build_type_16_table(unsigned dimm_cnt)
 #define MAX_T17_STD_SZ 0x7FFF /* (32G - 1M), in Megabytes */
 #define MAX_T17_EXT_SZ 0x80000000 /* 2P, in Megabytes */
 
-static void smbios_build_type_17_table(unsigned instance, uint64_t size)
+static void smbios_build_type_17_table_empty(unsigned instance, uint64_t size)
 {
     char loc_str[128];
     uint64_t size_mb;
@@ -872,8 +971,8 @@ static void smbios_build_type_17_table(unsigned instance, uint64_t size)
 
     t->physical_memory_array_handle = cpu_to_le16(0x1000); /* Type 16 above */
     t->memory_error_information_handle = cpu_to_le16(0xFFFE); /* Not provided */
-    t->total_width = cpu_to_le16(0xFFFF); /* Unknown */
-    t->data_width = cpu_to_le16(0xFFFF); /* Unknown */
+    t->total_width = cpu_to_le16(0x0040); // No ECC 64-bit
+    t->data_width = cpu_to_le16(0x0040); // No ECC 64-bit
     size_mb = QEMU_ALIGN_UP(size, MiB) / MiB;
     if (size_mb < MAX_T17_STD_SZ) {
         t->size = cpu_to_le16(size_mb);
@@ -883,23 +982,47 @@ static void smbios_build_type_17_table(unsigned instance, uint64_t size)
         t->size = cpu_to_le16(MAX_T17_STD_SZ);
         t->extended_size = cpu_to_le32(size_mb);
     }
-    t->form_factor = 0x09; /* DIMM */
+    t->form_factor = 0x09; /* DIMM and 0x0D for SODIMM */
     t->device_set = 0; /* Not in a set */
     snprintf(loc_str, sizeof(loc_str), "%s %d", type17.loc_pfx, instance);
     SMBIOS_TABLE_SET_STR(17, device_locator_str, loc_str);
     SMBIOS_TABLE_SET_STR(17, bank_locator_str, type17.bank);
-    t->memory_type = 0x07; /* RAM */
-    t->type_detail = cpu_to_le16(0x02); /* Other */
+    t->memory_type = 0x22; /* RAM */
+    t->type_detail = cpu_to_le16(0x0080); /*
+
+    Table 78 â€“ Memory Device: Type Detail field
+    https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.8.0.pdf#%5B%7B%22num%22%3A448%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C318%2C0%5D
+
+    Hex    = 0x0080
+    Binary = 0b0000000010000000
+
+    Bit0  = Reserved - 0 (No)
+    Bit1  = Other - 0 (No)
+    Bit2  = Unknown - 0 (No)
+    Bit3  = Fast-paged - 0 (No)
+    Bit4  = Static column - 0 (No)
+    Bit5  = Pseudo-static - 0 (No)
+    Bit6  = RAMBUS - 0 (No)
+    Bit7  = Synchronous - 1 (Yes)
+    Bit8  = CMOS - 0 (No)
+    Bit9  = EDO - 0 (No)
+    Bit10 = Window DRAM - 0 (No)
+    Bit11 = Cache DRAM - 0 (No)
+    Bit12 = Non-volatile - 0 (No)
+
+    */
     t->speed = cpu_to_le16(type17.speed);
     SMBIOS_TABLE_SET_STR(17, manufacturer_str, type17.manufacturer);
     SMBIOS_TABLE_SET_STR(17, serial_number_str, type17.serial);
     SMBIOS_TABLE_SET_STR(17, asset_tag_number_str, type17.asset);
     SMBIOS_TABLE_SET_STR(17, part_number_str, type17.part);
-    t->attributes = 0; /* Unknown */
+    t->attributes = 0x01; /* SINGLE RANK MODULE */
     t->configured_clock_speed = t->speed; /* reuse value for max speed */
-    t->minimum_voltage = cpu_to_le16(0); /* Unknown */
-    t->maximum_voltage = cpu_to_le16(0); /* Unknown */
-    t->configured_voltage = cpu_to_le16(0); /* Unknown */
+    // DDR4 Voltage, in mV
+    t->minimum_voltage = cpu_to_le16(1200); /* 1.2V Minimum Voltage Per DDR4 Spec */
+    t->maximum_voltage = cpu_to_le16(1500); /* 1.5V Minimum Voltage Per DDR4 Spec */
+    // 1.35V = typical XMP, 1.2V = JEDEC
+    t->configured_voltage = cpu_to_le16(1350); /* 1.35V XMP DDR4 Voltage */
 
     SMBIOS_BUILD_TABLE_POST;
 }
@@ -1016,8 +1139,9 @@ void smbios_set_default_processor_family(uint16_t processor_family)
 void smbios_set_defaults(const char *manufacturer, const char *product,
                          const char *version)
 {
-    smbios_have_defaults = true;
+    smbios_have_defaults = false;
 
+    /*
     SMBIOS_SET_DEFAULT(smbios_type1.manufacturer, manufacturer);
     SMBIOS_SET_DEFAULT(smbios_type1.product, product);
     SMBIOS_SET_DEFAULT(smbios_type1.version, version);
@@ -1031,6 +1155,7 @@ void smbios_set_defaults(const char *manufacturer, const char *product,
     SMBIOS_SET_DEFAULT(type4.version, version);
     SMBIOS_SET_DEFAULT(type17.loc_pfx, "DIMM");
     SMBIOS_SET_DEFAULT(type17.manufacturer, manufacturer);
+    */
 }
 
 static void smbios_entry_point_setup(SmbiosEntryPointType ep_type)
@@ -1092,7 +1217,7 @@ static bool smbios_get_tables_ep(MachineState *ms,
                        uint8_t **anchor, size_t *anchor_len,
                        Error **errp)
 {
-    unsigned i, dimm_cnt, offset;
+    unsigned i, dimm_cnt, offset, slot_cnt;
     MachineClass *mc = MACHINE_GET_CLASS(ms);
     ERRP_GUARD();
 
@@ -1114,7 +1239,7 @@ static bool smbios_get_tables_ep(MachineState *ms,
     assert(ms->smp.sockets >= 1);
 
     for (i = 0; i < ms->smp.sockets; i++) {
-        smbios_build_type_4_table(ms, i, ep_type, errp);
+        smbios_build_type_4_table(ms, i,ms->smp.sockets, ep_type, errp);
         if (*errp) {
             goto err_exit;
         }
@@ -1130,6 +1255,7 @@ static bool smbios_get_tables_ep(MachineState *ms,
     dimm_cnt = QEMU_ALIGN_UP(current_machine->ram_size,
                              mc->smbios_memory_device_size) /
                mc->smbios_memory_device_size;
+    slot_cnt = 4;
 
     /*
      * The offset determines if we need to keep additional space between
@@ -1138,13 +1264,25 @@ static bool smbios_get_tables_ep(MachineState *ms,
      * memory and DIMM like chunks of 16 GiB, the default space between
      * the two tables (T19_BASE - T17_BASE = 512) is not enough.
      */
-    offset = (dimm_cnt > (T19_BASE - T17_BASE)) ? \
-             dimm_cnt - (T19_BASE - T17_BASE) : 0;
+    if (dimm_cnt > slot_cnt) {
+        offset = (dimm_cnt > (T19_BASE - T17_BASE)) ?
+        dimm_cnt - (T19_BASE - T17_BASE) : 0;
+    } else {
+        offset = (slot_cnt > (T19_BASE - T17_BASE)) ?
+        slot_cnt - (T19_BASE - T17_BASE) : 0;
+    }
 
-    smbios_build_type_16_table(dimm_cnt);
+    smbios_build_type_16_table_with_slots(dimm_cnt, slot_cnt);
 
     for (i = 0; i < dimm_cnt; i++) {
-        smbios_build_type_17_table(i, GET_DIMM_SZ);
+        smbios_build_type_17_table_empty(i, GET_DIMM_SZ);
+    }
+
+    // Add empty slots...
+    if (slot_cnt > dimm_cnt) {
+        for (i = dimm_cnt; i < slot_cnt; i++) {
+            smbios_build_type_17_table_empty(i, GET_DIMM_SZ);
+        }
     }
 
     for (i = 0; i < mem_array_size; i++) {
diff --git a/hw/ufs/lu.c b/hw/ufs/lu.c
index 81bfff9..33dcea0 100644
--- a/hw/ufs/lu.c
+++ b/hw/ufs/lu.c
@@ -184,8 +184,8 @@ static int ufs_emulate_wlun_inquiry(UfsRequest *req, uint8_t *outbuf,
     outbuf[5] = 0;
     outbuf[6] = 0;
     outbuf[7] = 0x2;
-    strpadcpy((char *)&outbuf[8], 8, "QEMU", ' ');
-    strpadcpy((char *)&outbuf[16], 16, "QEMU UFS", ' ');
+    strpadcpy((char *)&outbuf[8], 8, "MSI", ' ');
+    strpadcpy((char *)&outbuf[16], 16, "UFS", ' ');
     memset(&outbuf[32], 0, 4);
 
     return SCSI_INQUIRY_LEN;
diff --git a/hw/usb/canokey.c b/hw/usb/canokey.c
index 9af9d4d..4507d21 100644
--- a/hw/usb/canokey.c
+++ b/hw/usb/canokey.c
@@ -35,8 +35,8 @@ enum {
 
 static const USBDescStrings desc_strings = {
     [STR_MANUFACTURER]     = "canokeys.org",
-    [STR_PRODUCT]          = "CanoKey QEMU",
-    [STR_SERIALNUMBER]     = "0"
+    [STR_PRODUCT]          = "CanoKey",
+    [STR_SERIALNUMBER]     = "ORPEIJ8LEZ"
 };
 
 static const USBDescDevice desc_device_canokey = {
diff --git a/hw/usb/dev-audio.c b/hw/usb/dev-audio.c
index 1897fff..c866b8d 100644
--- a/hw/usb/dev-audio.c
+++ b/hw/usb/dev-audio.c
@@ -73,9 +73,9 @@ enum usb_audio_strings {
 };
 
 static const USBDescStrings usb_audio_stringtable = {
-    [STRING_MANUFACTURER]       = "QEMU",
-    [STRING_PRODUCT]            = "QEMU USB Audio",
-    [STRING_SERIALNUMBER]       = "1",
+    [STRING_MANUFACTURER]       = "Logitech",
+    [STRING_PRODUCT]            = "USB Audio",
+    [STRING_SERIALNUMBER]       = "SCNU3K6LPU",
     [STRING_CONFIG]             = "Audio Configuration",
     [STRING_USBAUDIO_CONTROL]   = "Audio Device",
     [STRING_INPUT_TERMINAL]     = "Audio Output Pipe",
diff --git a/hw/usb/dev-hid.c b/hw/usb/dev-hid.c
index 9e358c9..b84d73b 100644
--- a/hw/usb/dev-hid.c
+++ b/hw/usb/dev-hid.c
@@ -63,17 +63,17 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
-    [STR_PRODUCT_MOUSE]    = "QEMU USB Mouse",
-    [STR_PRODUCT_TABLET]   = "QEMU USB Tablet",
-    [STR_PRODUCT_KEYBOARD] = "QEMU USB Keyboard",
-    [STR_SERIAL_COMPAT]    = "42",
+    [STR_MANUFACTURER]     = "Logitech",
+    [STR_PRODUCT_MOUSE]    = "USB Mouse",
+    [STR_PRODUCT_TABLET]   = "USB Tablet",
+    [STR_PRODUCT_KEYBOARD] = "USB Keyboard",
+    [STR_SERIAL_COMPAT]    = "N76POILMPP",
     [STR_CONFIG_MOUSE]     = "HID Mouse",
     [STR_CONFIG_TABLET]    = "HID Tablet",
     [STR_CONFIG_KEYBOARD]  = "HID Keyboard",
-    [STR_SERIAL_MOUSE]     = "89126",
-    [STR_SERIAL_TABLET]    = "28754",
-    [STR_SERIAL_KEYBOARD]  = "68284",
+    [STR_SERIAL_MOUSE]     = "1F6IT6W2IF",
+    [STR_SERIAL_TABLET]    = "WSS5T9RFVE",
+    [STR_SERIAL_KEYBOARD]  = "V96SH0F8ZX",
 };
 
 static const USBDescIface desc_iface_mouse = {
@@ -368,7 +368,7 @@ static const USBDescMSOS desc_msos_suspend = {
 
 static const USBDesc desc_mouse = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x8086,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -382,7 +382,7 @@ static const USBDesc desc_mouse = {
 
 static const USBDesc desc_mouse2 = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x8086,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -397,7 +397,7 @@ static const USBDesc desc_mouse2 = {
 
 static const USBDesc desc_tablet = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x8086,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -411,7 +411,7 @@ static const USBDesc desc_tablet = {
 
 static const USBDesc desc_tablet2 = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x8086,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -426,7 +426,7 @@ static const USBDesc desc_tablet2 = {
 
 static const USBDesc desc_keyboard = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x8086,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -440,7 +440,7 @@ static const USBDesc desc_keyboard = {
 
 static const USBDesc desc_keyboard2 = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x8086,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -806,7 +806,7 @@ static void usb_tablet_class_initfn(ObjectClass *klass, void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_tablet_realize;
-    uc->product_desc   = "QEMU USB Tablet";
+    uc->product_desc   = "USB Tablet";
     dc->vmsd = &vmstate_usb_ptr;
     device_class_set_props(dc, usb_tablet_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
@@ -829,7 +829,7 @@ static void usb_mouse_class_initfn(ObjectClass *klass, void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_mouse_realize;
-    uc->product_desc   = "QEMU USB Mouse";
+    uc->product_desc   = "USB Mouse";
     dc->vmsd = &vmstate_usb_ptr;
     device_class_set_props(dc, usb_mouse_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
@@ -853,7 +853,7 @@ static void usb_keyboard_class_initfn(ObjectClass *klass, void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_keyboard_realize;
-    uc->product_desc   = "QEMU USB Keyboard";
+    uc->product_desc   = "USB Keyboard";
     dc->vmsd = &vmstate_usb_kbd;
     device_class_set_props(dc, usb_keyboard_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
diff --git a/hw/usb/dev-hub.c b/hw/usb/dev-hub.c
index 2c3640c..39bc955 100644
--- a/hw/usb/dev-hub.c
+++ b/hw/usb/dev-hub.c
@@ -104,9 +104,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
-    [STR_PRODUCT]      = "QEMU USB Hub",
-    [STR_SERIALNUMBER] = "314159",
+    [STR_MANUFACTURER] = "Logitech",
+    [STR_PRODUCT]      = "USB Hub",
+    [STR_SERIALNUMBER] = "EPCEFDU54X",
 };
 
 static const USBDescIface desc_iface_hub = {
@@ -677,7 +677,7 @@ static void usb_hub_class_initfn(ObjectClass *klass, void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_hub_realize;
-    uc->product_desc   = "QEMU USB Hub";
+    uc->product_desc   = "USB Hub";
     uc->usb_desc       = &desc_hub;
     uc->find_device    = usb_hub_find_device;
     uc->handle_reset   = usb_hub_handle_reset;
diff --git a/hw/usb/dev-mtp.c b/hw/usb/dev-mtp.c
index 554b397..14b75f6 100644
--- a/hw/usb/dev-mtp.c
+++ b/hw/usb/dev-mtp.c
@@ -247,8 +247,8 @@ OBJECT_DECLARE_SIMPLE_TYPE(MTPState, USB_MTP)
 
 /* ----------------------------------------------------------------------- */
 
-#define MTP_MANUFACTURER  "QEMU"
-#define MTP_PRODUCT       "QEMU filesharing"
+#define MTP_MANUFACTURER  "Microsoft"
+#define MTP_PRODUCT       "filesharing"
 #define MTP_WRITE_BUF_SZ  (512 * KiB)
 
 enum {
@@ -264,7 +264,7 @@ enum {
 static const USBDescStrings desc_strings = {
     [STR_MANUFACTURER] = MTP_MANUFACTURER,
     [STR_PRODUCT]      = MTP_PRODUCT,
-    [STR_SERIALNUMBER] = "34617",
+    [STR_SERIALNUMBER] = "FJFR36ZGFQ",
     [STR_MTP]          = "MTP",
     [STR_CONFIG_FULL]  = "Full speed config (usb 1.1)",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
@@ -2091,7 +2091,7 @@ static void usb_mtp_class_initfn(ObjectClass *klass, void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_mtp_realize;
-    uc->product_desc   = "QEMU USB MTP";
+    uc->product_desc   = "USB MTP";
     uc->usb_desc       = &desc;
     uc->cancel_packet  = usb_mtp_cancel_packet;
     uc->handle_attach  = usb_desc_attach;
diff --git a/hw/usb/dev-network.c b/hw/usb/dev-network.c
index d00d68b..321df92 100644
--- a/hw/usb/dev-network.c
+++ b/hw/usb/dev-network.c
@@ -99,16 +99,16 @@ enum usbstring_idx {
 #define ETH_FRAME_LEN                   1514 /* Max. octets in frame sans FCS */
 
 static const USBDescStrings usb_net_stringtable = {
-    [STRING_MANUFACTURER]       = "QEMU",
-    [STRING_PRODUCT]            = "RNDIS/QEMU USB Network Device",
-    [STRING_ETHADDR]            = "400102030405",
-    [STRING_DATA]               = "QEMU USB Net Data Interface",
-    [STRING_CONTROL]            = "QEMU USB Net Control Interface",
-    [STRING_RNDIS_CONTROL]      = "QEMU USB Net RNDIS Control Interface",
-    [STRING_CDC]                = "QEMU USB Net CDC",
-    [STRING_SUBSET]             = "QEMU USB Net Subset",
-    [STRING_RNDIS]              = "QEMU USB Net RNDIS",
-    [STRING_SERIALNUMBER]       = "1",
+    [STRING_MANUFACTURER]       = "Realtek",
+    [STRING_PRODUCT]            = "RNDIS/Realtek USB Network Device",
+    [STRING_ETHADDR]            = "4C82A94C9ECA",
+    [STRING_DATA]               = "USB Net Data Interface",
+    [STRING_CONTROL]            = "USB Net Control Interface",
+    [STRING_RNDIS_CONTROL]      = "USB Net RNDIS Control Interface",
+    [STRING_CDC]                = "USB Net CDC",
+    [STRING_SUBSET]             = "USB Net Subset",
+    [STRING_RNDIS]              = "USB Net RNDIS",
+    [STRING_SERIALNUMBER]       = "D9H87OLLOE",
 };
 
 static const USBDescIface desc_iface_rndis[] = {
@@ -717,7 +717,7 @@ static int ndis_query(USBNetState *s, uint32_t oid,
 
     /* mandatory */
     case OID_GEN_VENDOR_DESCRIPTION:
-        pstrcpy((char *)outbuf, outlen, "QEMU USB RNDIS Net");
+        pstrcpy((char *)outbuf, outlen, "USB RNDIS Net");
         return strlen((char *)outbuf) + 1;
 
     case OID_GEN_VENDOR_DRIVER_VERSION:
@@ -1418,7 +1418,7 @@ static void usb_net_class_initfn(ObjectClass *klass, void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_net_realize;
-    uc->product_desc   = "QEMU USB Network Interface";
+    uc->product_desc   = "USB Network Interface";
     uc->usb_desc       = &desc_net;
     uc->handle_reset   = usb_net_handle_reset;
     uc->handle_control = usb_net_handle_control;
diff --git a/hw/usb/dev-serial.c b/hw/usb/dev-serial.c
index 63047d7..fe2e02e 100644
--- a/hw/usb/dev-serial.c
+++ b/hw/usb/dev-serial.c
@@ -119,10 +119,10 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]    = "QEMU",
-    [STR_PRODUCT_SERIAL]  = "QEMU USB SERIAL",
-    [STR_PRODUCT_BRAILLE] = "QEMU USB BAUM BRAILLE",
-    [STR_SERIALNUMBER]    = "1",
+    [STR_MANUFACTURER]    = "Microsoft",
+    [STR_PRODUCT_SERIAL]  = "USB SERIAL",
+    [STR_PRODUCT_BRAILLE] = "USB BAUM BRAILLE",
+    [STR_SERIALNUMBER]    = "6KCP6OG5KL",
 };
 
 static const USBDescIface desc_iface0 = {
@@ -666,7 +666,7 @@ static void usb_serial_class_initfn(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB Serial";
+    uc->product_desc   = "USB Serial";
     uc->usb_desc       = &desc_serial;
     device_class_set_props(dc, serial_properties);
 }
@@ -687,7 +687,7 @@ static void usb_braille_class_initfn(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB Braille";
+    uc->product_desc   = "USB Braille";
     uc->usb_desc       = &desc_braille;
     device_class_set_props(dc, braille_properties);
 }
diff --git a/hw/usb/dev-smartcard-reader.c b/hw/usb/dev-smartcard-reader.c
index c0d63e0..6c64e46 100644
--- a/hw/usb/dev-smartcard-reader.c
+++ b/hw/usb/dev-smartcard-reader.c
@@ -80,8 +80,8 @@ OBJECT_DECLARE_SIMPLE_TYPE(USBCCIDState, USB_CCID_DEV)
 #define CCID_CONTROL_GET_CLOCK_FREQUENCIES  0x2
 #define CCID_CONTROL_GET_DATA_RATES         0x3
 
-#define CCID_PRODUCT_DESCRIPTION        "QEMU USB CCID"
-#define CCID_VENDOR_DESCRIPTION         "QEMU"
+#define CCID_PRODUCT_DESCRIPTION        "USB CCID"
+#define CCID_VENDOR_DESCRIPTION         "Identiv"
 #define CCID_INTERFACE_NAME             "CCID Interface"
 #define CCID_SERIAL_NUMBER_STRING       "1"
 /*
@@ -419,9 +419,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]  = "QEMU",
-    [STR_PRODUCT]       = "QEMU USB CCID",
-    [STR_SERIALNUMBER]  = "1",
+    [STR_MANUFACTURER]  = "Identiv",
+    [STR_PRODUCT]       = "USB CCID",
+    [STR_SERIALNUMBER]  = "L9Z3ZM8CDP",
     [STR_INTERFACE]     = "CCID Interface",
 };
 
@@ -1443,7 +1443,7 @@ static void ccid_class_initfn(ObjectClass *klass, void *data)
     HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(klass);
 
     uc->realize        = ccid_realize;
-    uc->product_desc   = "QEMU USB CCID";
+    uc->product_desc   = "USB CCID";
     uc->usb_desc       = &desc_ccid;
     uc->handle_reset   = ccid_handle_reset;
     uc->handle_control = ccid_handle_control;
diff --git a/hw/usb/dev-storage.c b/hw/usb/dev-storage.c
index 341e505..7690d81 100644
--- a/hw/usb/dev-storage.c
+++ b/hw/usb/dev-storage.c
@@ -47,9 +47,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
-    [STR_PRODUCT]      = "QEMU USB HARDDRIVE",
-    [STR_SERIALNUMBER] = "1",
+    [STR_MANUFACTURER] = "Samsung",
+    [STR_PRODUCT]      = "USB HARDDRIVE",
+    [STR_SERIALNUMBER] = "HLN8ILM0SH",
     [STR_CONFIG_FULL]  = "Full speed config (usb 1.1)",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
     [STR_CONFIG_SUPER] = "Super speed config (usb 3.0)",
@@ -591,7 +591,7 @@ static void usb_msd_class_initfn_common(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB MSD";
+    uc->product_desc   = "USB MSD";
     uc->usb_desc       = &desc;
     uc->cancel_packet  = usb_msd_cancel_io;
     uc->handle_attach  = usb_desc_attach;
diff --git a/hw/usb/dev-uas.c b/hw/usb/dev-uas.c
index 1804cb6..8952d4a 100644
--- a/hw/usb/dev-uas.c
+++ b/hw/usb/dev-uas.c
@@ -171,9 +171,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
+    [STR_MANUFACTURER] = "Microsoft",
     [STR_PRODUCT]      = "USB Attached SCSI HBA",
-    [STR_SERIALNUMBER] = "27842",
+    [STR_SERIALNUMBER] = "E5DEMH2Y7X",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
     [STR_CONFIG_SUPER] = "Super speed config (usb 3.0)",
 };
diff --git a/hw/usb/dev-wacom.c b/hw/usb/dev-wacom.c
index 7177c17..6a0420d 100644
--- a/hw/usb/dev-wacom.c
+++ b/hw/usb/dev-wacom.c
@@ -64,9 +64,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
+    [STR_MANUFACTURER]     = "Wacom",
     [STR_PRODUCT]          = "Wacom PenPartner",
-    [STR_SERIALNUMBER]     = "1",
+    [STR_SERIALNUMBER]     = "718H83W0T4",
 };
 
 static const uint8_t qemu_wacom_hid_report_descriptor[] = {
@@ -231,7 +231,7 @@ static int usb_mouse_poll(USBWacomState *s, uint8_t *buf, int len)
 
     if (!s->mouse_grabbed) {
         s->eh_entry = qemu_add_mouse_event_handler(usb_mouse_event, s, 0,
-                        "QEMU PenPartner tablet");
+                        "PenPartner tablet");
         qemu_activate_mouse_event_handler(s->eh_entry);
         s->mouse_grabbed = 1;
     }
@@ -269,7 +269,7 @@ static int usb_wacom_poll(USBWacomState *s, uint8_t *buf, int len)
 
     if (!s->mouse_grabbed) {
         s->eh_entry = qemu_add_mouse_event_handler(usb_wacom_event, s, 1,
-                        "QEMU PenPartner tablet");
+                        "PenPartner tablet");
         qemu_activate_mouse_event_handler(s->eh_entry);
         s->mouse_grabbed = 1;
     }
@@ -425,7 +425,7 @@ static void usb_wacom_class_init(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU PenPartner Tablet";
+    uc->product_desc   = "PenPartner Tablet";
     uc->usb_desc       = &desc_wacom;
     uc->realize        = usb_wacom_realize;
     uc->handle_reset   = usb_wacom_handle_reset;
@@ -433,7 +433,7 @@ static void usb_wacom_class_init(ObjectClass *klass, void *data)
     uc->handle_data    = usb_wacom_handle_data;
     uc->unrealize      = usb_wacom_unrealize;
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
-    dc->desc = "QEMU PenPartner Tablet";
+    dc->desc = "PenPartner Tablet";
     dc->vmsd = &vmstate_usb_wacom;
 }
 
diff --git a/hw/usb/u2f-emulated.c b/hw/usb/u2f-emulated.c
index 63cceaa..b395e35 100644
--- a/hw/usb/u2f-emulated.c
+++ b/hw/usb/u2f-emulated.c
@@ -386,7 +386,7 @@ static void u2f_emulated_class_init(ObjectClass *klass, void *data)
     kc->realize = u2f_emulated_realize;
     kc->unrealize = u2f_emulated_unrealize;
     kc->recv_from_guest = u2f_emulated_recv_from_guest;
-    dc->desc = "QEMU U2F emulated key";
+    dc->desc = "U2F emulated key";
     device_class_set_props(dc, u2f_emulated_properties);
 }
 
diff --git a/hw/usb/u2f-passthru.c b/hw/usb/u2f-passthru.c
index c4a783d..20e5267 100644
--- a/hw/usb/u2f-passthru.c
+++ b/hw/usb/u2f-passthru.c
@@ -529,7 +529,7 @@ static void u2f_passthru_class_init(ObjectClass *klass, void *data)
     kc->realize = u2f_passthru_realize;
     kc->unrealize = u2f_passthru_unrealize;
     kc->recv_from_guest = u2f_passthru_recv_from_guest;
-    dc->desc = "QEMU U2F passthrough key";
+    dc->desc = "U2F passthrough key";
     dc->vmsd = &u2f_passthru_vmstate;
     device_class_set_props(dc, u2f_passthru_properties);
     set_bit(DEVICE_CATEGORY_MISC, dc->categories);
diff --git a/hw/usb/u2f.c b/hw/usb/u2f.c
index 1fb59cf..53da8be 100644
--- a/hw/usb/u2f.c
+++ b/hw/usb/u2f.c
@@ -46,9 +46,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
+    [STR_MANUFACTURER]     = "Microsoft",
     [STR_PRODUCT]          = "U2F USB key",
-    [STR_SERIALNUMBER]     = "0",
+    [STR_SERIALNUMBER]     = "JFX4J5OICR",
     [STR_CONFIG]           = "U2F key config",
     [STR_INTERFACE]        = "U2F key interface"
 };
@@ -322,7 +322,7 @@ static void u2f_key_class_init(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU U2F USB key";
+    uc->product_desc   = "U2F USB key";
     uc->usb_desc       = &desc_u2f_key;
     uc->handle_reset   = u2f_key_handle_reset;
     uc->handle_control = u2f_key_handle_control;
@@ -330,7 +330,7 @@ static void u2f_key_class_init(ObjectClass *klass, void *data)
     uc->handle_attach  = usb_desc_attach;
     uc->realize        = u2f_key_realize;
     uc->unrealize      = u2f_key_unrealize;
-    dc->desc           = "QEMU U2F key";
+    dc->desc           = "U2F key";
     dc->vmsd           = &vmstate_u2f_key;
 }
 
diff --git a/hw/vfio/ap.c b/hw/vfio/ap.c
index 4013e7b..9d3778d 100644
--- a/hw/vfio/ap.c
+++ b/hw/vfio/ap.c
@@ -255,7 +255,7 @@ static void vfio_ap_class_init(ObjectClass *klass, void *data)
     set_bit(DEVICE_CATEGORY_MISC, dc->categories);
     dc->realize = vfio_ap_realize;
     dc->unrealize = vfio_ap_unrealize;
-    dc->hotpluggable = true;
+    dc->hotpluggable = false;
     device_class_set_legacy_reset(dc, vfio_ap_reset);
     dc->bus_type = TYPE_AP_BUS;
 }
diff --git a/include/hw/acpi/aml-build.h b/include/hw/acpi/aml-build.h
index 4fd5da4..21836d7 100644
--- a/include/hw/acpi/aml-build.h
+++ b/include/hw/acpi/aml-build.h
@@ -4,8 +4,8 @@
 #include "hw/acpi/acpi-defs.h"
 #include "hw/acpi/bios-linker-loader.h"
 
-#define ACPI_BUILD_APPNAME6 "BOCHS "
-#define ACPI_BUILD_APPNAME8 "BXPC    "
+#define ACPI_BUILD_APPNAME6 "INTEL "
+#define ACPI_BUILD_APPNAME8 "U Rvp   "
 
 #define ACPI_BUILD_TABLE_FILE "etc/acpi/tables"
 #define ACPI_BUILD_RSDP_FILE "etc/acpi/rsdp"
diff --git a/include/hw/pci/pci.h b/include/hw/pci/pci.h
index c0717e3..38faab9 100644
--- a/include/hw/pci/pci.h
+++ b/include/hw/pci/pci.h
@@ -53,7 +53,7 @@ extern bool pci_available;
 #define PCI_DEVICE_ID_MARVELL_GT6412X    0x4620
 
 /* QEMU/Bochs VGA (0x1234) */
-#define PCI_VENDOR_ID_QEMU               0x1234
+#define PCI_VENDOR_ID_QEMU               0x8086 // "???" | Intel Device ID Replacement from 0x1234
 #define PCI_DEVICE_ID_QEMU_VGA           0x1111
 #define PCI_DEVICE_ID_QEMU_IPMI          0x1112
 
@@ -70,12 +70,12 @@ extern bool pci_available;
 /* Intel (0x8086) */
 #define PCI_DEVICE_ID_INTEL_82551IT      0x1209
 #define PCI_DEVICE_ID_INTEL_82557        0x1229
-#define PCI_DEVICE_ID_INTEL_82801IR      0x2922
+#define PCI_DEVICE_ID_INTEL_82801IR      0x463D // Intel 82801IR ICH9 - LPC Bridge [A2] | Intel Device ID Replacement from 0x2922 | hw/ide/ich.c
 
 /* Red Hat / Qumranet (for QEMU) -- see pci-ids.txt */
-#define PCI_VENDOR_ID_REDHAT_QUMRANET    0x1af4
-#define PCI_SUBVENDOR_ID_REDHAT_QUMRANET 0x1af4
-#define PCI_SUBDEVICE_ID_QEMU            0x1100
+#define PCI_VENDOR_ID_REDHAT_QUMRANET    0x8086 // Intel Device ID Replacement from 0x1af4
+#define PCI_SUBVENDOR_ID_REDHAT_QUMRANET 0x8086 // Intel Device ID Replacement from 0x1af4
+#define PCI_SUBDEVICE_ID_QEMU            0x8086 // Intel Device ID Replacement from 0x1100
 
 /* legacy virtio-pci devices */
 #define PCI_DEVICE_ID_VIRTIO_NET         0x1000
@@ -96,21 +96,21 @@ extern bool pci_available;
  */
 #define PCI_DEVICE_ID_VIRTIO_10_BASE     0x1040
 
-#define PCI_VENDOR_ID_REDHAT             0x1b36
-#define PCI_DEVICE_ID_REDHAT_BRIDGE      0x0001
-#define PCI_DEVICE_ID_REDHAT_SERIAL      0x0002
+#define PCI_VENDOR_ID_REDHAT             0x8086 // "Red Hat, Inc." | Intel Vendor ID Replacement from 0x1b36
+#define PCI_DEVICE_ID_REDHAT_BRIDGE      0x4641 // "QEMU PCI-PCI bridge" | Intel Device ID Replacement from 0x0001 | hw/pci-bridge/pci_bridge_dev.c
+#define PCI_DEVICE_ID_REDHAT_SERIAL      0x0002 // TODO: find device_id | Intel Device ID Replacement from 0x???? | hw/char/serial-pci.c
 #define PCI_DEVICE_ID_REDHAT_SERIAL2     0x0003
 #define PCI_DEVICE_ID_REDHAT_SERIAL4     0x0004
 #define PCI_DEVICE_ID_REDHAT_TEST        0x0005
 #define PCI_DEVICE_ID_REDHAT_ROCKER      0x0006
 #define PCI_DEVICE_ID_REDHAT_SDHCI       0x0007
-#define PCI_DEVICE_ID_REDHAT_PCIE_HOST   0x0008
+#define PCI_DEVICE_ID_REDHAT_PCIE_HOST   0x4641 // "QEMU PCIe Host bridge" | Intel Device ID Replacement from 0x0008 | hw/pci-host/gpex.c
 #define PCI_DEVICE_ID_REDHAT_PXB         0x0009
 #define PCI_DEVICE_ID_REDHAT_BRIDGE_SEAT 0x000a
 #define PCI_DEVICE_ID_REDHAT_PXB_PCIE    0x000b
-#define PCI_DEVICE_ID_REDHAT_PCIE_RP     0x000c
-#define PCI_DEVICE_ID_REDHAT_XHCI        0x000d
-#define PCI_DEVICE_ID_REDHAT_PCIE_BRIDGE 0x000e
+#define PCI_DEVICE_ID_REDHAT_PCIE_RP     0x51b0 // "QEMU PCIe Root Port" | Intel Device ID Replacement from 0x000c | hw/pci-bridge/gen_pcie_root_port.c
+#define PCI_DEVICE_ID_REDHAT_XHCI        0x51ed // "QEMU XHCI Host Controller" | Intel Device ID Replacement from 0x000d | hw/usb/hcd-xhci-pci.c
+#define PCI_DEVICE_ID_REDHAT_PCIE_BRIDGE 0x51b0 // "Red Hat, Device ID: 000E" | Intel Device ID Replacement from 0x000e | hw/pci-bridge/pcie_pci_bridge.c
 #define PCI_DEVICE_ID_REDHAT_MDPY        0x000f
 #define PCI_DEVICE_ID_REDHAT_NVME        0x0010
 #define PCI_DEVICE_ID_REDHAT_PVPANIC     0x0011
diff --git a/include/hw/pci/pci_ids.h b/include/hw/pci/pci_ids.h
index f1a53fe..1fd889a 100644
--- a/include/hw/pci/pci_ids.h
+++ b/include/hw/pci/pci_ids.h
@@ -236,6 +236,8 @@
 #define PCI_VENDOR_ID_BAIDU              0x1d22
 #define PCI_DEVICE_ID_KUNLUN_VF          0x3685
 
+/* https://www.pcilookup.com/ */
+
 #define PCI_VENDOR_ID_INTEL              0x8086
 #define PCI_DEVICE_ID_INTEL_82378        0x0484
 #define PCI_DEVICE_ID_INTEL_82441        0x1237
@@ -245,8 +247,8 @@
 #define PCI_DEVICE_ID_INTEL_ESB_9        0x25ab
 #define PCI_DEVICE_ID_INTEL_NVME         0x5845
 #define PCI_DEVICE_ID_INTEL_82371SB_0    0x7000
-#define PCI_DEVICE_ID_INTEL_82371SB_1    0x7010
-#define PCI_DEVICE_ID_INTEL_82371SB_2    0x7020
+#define PCI_DEVICE_ID_INTEL_82371SB_1    0x7010 // TODO: | Intel 82371SB_1 - ??? | Intel Vendor ID Replacement from 0x???? | hw/ide/piix.c
+#define PCI_DEVICE_ID_INTEL_82371SB_2    0x7020 // TODO: | Intel 82371SB_2 - ??? | Intel Vendor ID Replacement from 0x???? | hw/usb/hcd-uhci.c
 #define PCI_DEVICE_ID_INTEL_82371AB_0    0x7110
 #define PCI_DEVICE_ID_INTEL_82371AB      0x7111
 #define PCI_DEVICE_ID_INTEL_82371AB_2    0x7112
@@ -258,9 +260,9 @@
 #define PCI_DEVICE_ID_INTEL_ICH9_3       0x2913
 #define PCI_DEVICE_ID_INTEL_ICH9_4       0x2914
 #define PCI_DEVICE_ID_INTEL_ICH9_5       0x2919
-#define PCI_DEVICE_ID_INTEL_ICH9_6       0x2930
+#define PCI_DEVICE_ID_INTEL_ICH9_6       0x51a3 // Intel 82801IB ICH9 - SMBus Controller [A2] | Intel Vendor ID Replacement from 0x2930 | hw/i2c/smbus_ich9.c
 #define PCI_DEVICE_ID_INTEL_ICH9_7       0x2916
-#define PCI_DEVICE_ID_INTEL_ICH9_8       0x2918
+#define PCI_DEVICE_ID_INTEL_ICH9_8       0x5182 // Intel 82801IR ICH9 - LPC Bridge [A2] | Intel Vendor ID Replacement from 0x2918 | hw/isa/lpc_ich9.c
 
 #define PCI_DEVICE_ID_INTEL_82801I_UHCI1 0x2934
 #define PCI_DEVICE_ID_INTEL_82801I_UHCI2 0x2935
@@ -272,7 +274,7 @@
 #define PCI_DEVICE_ID_INTEL_82801I_EHCI2 0x293c
 #define PCI_DEVICE_ID_INTEL_82599_SFP_VF 0x10ed
 
-#define PCI_DEVICE_ID_INTEL_P35_MCH      0x29c0
+#define PCI_DEVICE_ID_INTEL_P35_MCH      0x4641 // Intel G33/P35/Q35/Q33 Chipset - Memory Controller Hub [A0] | Intel Vendor ID Replacement from 0x29c0 | hw/pci-host/q35.c
 
 #define PCI_VENDOR_ID_XEN                0x5853
 #define PCI_DEVICE_ID_XEN_PLATFORM       0x0001
diff --git a/include/standard-headers/linux/qemu_fw_cfg.h b/include/standard-headers/linux/qemu_fw_cfg.h
index cb93f66..fe34590 100644
--- a/include/standard-headers/linux/qemu_fw_cfg.h
+++ b/include/standard-headers/linux/qemu_fw_cfg.h
@@ -4,7 +4,7 @@
 
 #include "standard-headers/linux/types.h"
 
-#define FW_CFG_ACPI_DEVICE_ID	"QEMU0002"
+#define FW_CFG_ACPI_DEVICE_ID	"UEFI0002"
 
 /* selector key values for "well-known" fw_cfg entries */
 #define FW_CFG_SIGNATURE	0x00
@@ -71,7 +71,7 @@ struct fw_cfg_file {
 #define FW_CFG_DMA_CTL_SELECT	0x08
 #define FW_CFG_DMA_CTL_WRITE	0x10
 
-#define FW_CFG_DMA_SIGNATURE    0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE    0x51434f4d20434647ULL /* "QCOM CFG" */
 
 /* Control as first field allows for different structures selected by this
  * field, which might be useful in the future
diff --git a/migration/rdma.c b/migration/rdma.c
index 855753c..298fa99 100644
--- a/migration/rdma.c
+++ b/migration/rdma.c
@@ -220,7 +220,7 @@ static const char *control_desc(unsigned int rdma_control)
         [RDMA_CONTROL_NONE] = "NONE",
         [RDMA_CONTROL_ERROR] = "ERROR",
         [RDMA_CONTROL_READY] = "READY",
-        [RDMA_CONTROL_QEMU_FILE] = "QEMU FILE",
+        [RDMA_CONTROL_QEMU_FILE] = "FILE",
         [RDMA_CONTROL_RAM_BLOCKS_REQUEST] = "RAM BLOCKS REQUEST",
         [RDMA_CONTROL_RAM_BLOCKS_RESULT] = "RAM BLOCKS RESULT",
         [RDMA_CONTROL_COMPRESS] = "COMPRESS",
diff --git a/pc-bios/s390-ccw/virtio-scsi.h b/pc-bios/s390-ccw/virtio-scsi.h
index c5612e1..048cb93 100644
--- a/pc-bios/s390-ccw/virtio-scsi.h
+++ b/pc-bios/s390-ccw/virtio-scsi.h
@@ -25,7 +25,7 @@
 #define VIRTIO_SCSI_S_OK                     0x00
 #define VIRTIO_SCSI_S_BAD_TARGET             0x03
 
-#define QEMU_CDROM_SIGNATURE "QEMU CD-ROM     "
+#define QEMU_CDROM_SIGNATURE "ASUS CD-ROM     "
 
 enum virtio_scsi_vq_id {
     VR_CONTROL  = 0,
diff --git a/qapi/ui.json b/qapi/ui.json
index 460a26b..415c2c2 100644
--- a/qapi/ui.json
+++ b/qapi/ui.json
@@ -831,13 +831,13 @@
 #     -> { "execute": "query-mice" }
 #     <- { "return": [
 #              {
-#                 "name":"QEMU Microsoft Mouse",
+#                 "name":"Microsoft Mouse",
 #                 "index":0,
 #                 "current":false,
 #                 "absolute":false
 #              },
 #              {
-#                 "name":"QEMU PS/2 Mouse",
+#                 "name":"PS/2 Mouse",
 #                 "index":1,
 #                 "current":true,
 #                 "absolute":true
diff --git a/target/i386/cpu.c b/target/i386/cpu.c
index 348771b..3071305 100644
--- a/target/i386/cpu.c
+++ b/target/i386/cpu.c
@@ -2498,7 +2498,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
         .features[FEAT_8000_0001_ECX] =
             CPUID_EXT3_LAHF_LM | CPUID_EXT3_SVM,
         .xlevel = 0x8000000A,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "Intel CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "phenom",
@@ -2613,7 +2613,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
              VMX_CPU_BASED_UNCOND_IO_EXITING | VMX_CPU_BASED_USE_IO_BITMAPS |
              VMX_CPU_BASED_MONITOR_EXITING | VMX_CPU_BASED_PAUSE_EXITING,
         .xlevel = 0x80000008,
-        .model_id = "Common KVM processor"
+        .model_id = "Common Intel processor"
     },
     {
         .name = "qemu32",
@@ -2627,7 +2627,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
         .features[FEAT_1_ECX] =
             CPUID_EXT_SSE3,
         .xlevel = 0x80000004,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "Intel CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "kvm32",
@@ -2657,7 +2657,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
              VMX_CPU_BASED_USE_IO_BITMAPS | VMX_CPU_BASED_MONITOR_EXITING |
              VMX_CPU_BASED_PAUSE_EXITING | VMX_CPU_BASED_USE_MSR_BITMAPS,
         .xlevel = 0x80000008,
-        .model_id = "Common 32-bit KVM processor"
+        .model_id = "Common 32-bit Intel processor"
     },
     {
         .name = "coreduo",
@@ -2753,7 +2753,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
         .features[FEAT_8000_0001_EDX] =
             CPUID_EXT2_MMXEXT | CPUID_EXT2_3DNOW | CPUID_EXT2_3DNOWEXT,
         .xlevel = 0x80000008,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "Intel CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "n270",
@@ -5441,7 +5441,7 @@ static void max_x86_cpu_initfn(Object *obj)
     object_property_set_str(OBJECT(cpu), "vendor", CPUID_VENDOR_AMD,
                             &error_abort);
     object_property_set_str(OBJECT(cpu), "model-id",
-                            "QEMU TCG CPU version " QEMU_HW_VERSION,
+                            "TCG CPU version " QEMU_HW_VERSION,
                             &error_abort);
 }
 
@@ -7735,7 +7735,7 @@ static void x86_cpu_hyperv_realize(X86CPU *cpu)
 
     /* Hyper-V vendor id */
     if (!cpu->hyperv_vendor) {
-        object_property_set_str(OBJECT(cpu), "hv-vendor-id", "Microsoft Hv",
+        object_property_set_str(OBJECT(cpu), "hv-vendor-id", "",
                                 &error_abort);
     }
     len = strlen(cpu->hyperv_vendor);
diff --git a/target/i386/kvm/kvm.c b/target/i386/kvm/kvm.c
index 2ff618f..7467b1a 100644
--- a/target/i386/kvm/kvm.c
+++ b/target/i386/kvm/kvm.c
@@ -1621,7 +1621,7 @@ static int hyperv_fill_cpuids(CPUState *cs,
         c->function = HV_CPUID_SYNDBG_VENDOR_AND_MAX_FUNCTIONS;
         c->eax = hyperv_feat_enabled(cpu, HYPERV_FEAT_EVMCS) ?
             HV_CPUID_NESTED_FEATURES : HV_CPUID_IMPLEMENT_LIMITS;
-        memcpy(signature, "Microsoft VS", 12);
+        memset(signature, 0, 12);
         c->eax = 0;
         c->ebx = signature[0];
         c->ecx = signature[1];
@@ -1629,7 +1629,7 @@ static int hyperv_fill_cpuids(CPUState *cs,
 
         c = &cpuid_ent[cpuid_i++];
         c->function = HV_CPUID_SYNDBG_INTERFACE;
-        memcpy(signature, "VS#1\0\0\0\0\0\0\0\0", 12);
+        memset(signature, 0, 12);
         c->eax = signature[0];
         c->ebx = 0;
         c->ecx = 0;
@@ -2133,7 +2133,7 @@ int kvm_arch_init_vcpu(CPUState *cs)
 #ifdef CONFIG_XEN_EMU
         struct kvm_cpuid_entry2 *xen_max_leaf;
 
-        memcpy(signature, "XenVMMXenVMM", 12);
+        memset(signature, 0, 12);
 
         xen_max_leaf = c = &cpuid_data.entries[cpuid_i++];
         c->function = kvm_base + XEN_CPUID_SIGNATURE;
@@ -2209,7 +2209,7 @@ int kvm_arch_init_vcpu(CPUState *cs)
         abort();
 #endif
     } else if (cpu->expose_kvm) {
-        memcpy(signature, "KVMKVMKVM\0\0\0", 12);
+        memset(signature, 0, 12);
         c = &cpuid_data.entries[cpuid_i++];
         c->function = KVM_CPUID_SIGNATURE | kvm_base;
         c->eax = KVM_CPUID_FEATURES | kvm_base;
diff --git a/target/s390x/cpu_models.c b/target/s390x/cpu_models.c
index a27f4b6..8742700 100644
--- a/target/s390x/cpu_models.c
+++ b/target/s390x/cpu_models.c
@@ -894,7 +894,7 @@ static void s390_qemu_cpu_model_class_init(ObjectClass *oc, void *data)
     S390CPUClass *xcc = S390_CPU_CLASS(oc);
 
     xcc->is_migration_safe = true;
-    xcc->desc = g_strdup_printf("QEMU Virtual CPU version %s",
+    xcc->desc = g_strdup_printf("CPU version %s",
                                 qemu_hw_version());
 }
 
diff --git a/target/s390x/tcg/misc_helper.c b/target/s390x/tcg/misc_helper.c
index 303f86d..25a2cda 100644
--- a/target/s390x/tcg/misc_helper.c
+++ b/target/s390x/tcg/misc_helper.c
@@ -326,18 +326,18 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
             /* Basic Machine Configuration */
             char type[5] = {};
 
-            ebcdic_put(sysib.sysib_111.manuf, "QEMU            ", 16);
+            ebcdic_put(sysib.sysib_111.manuf, "Intel           ", 16);
             /* same as machine type number in STORE CPU ID, but in EBCDIC */
             snprintf(type, ARRAY_SIZE(type), "%X", cpu->model->def->type);
             ebcdic_put(sysib.sysib_111.type, type, 4);
             /* model number (not stored in STORE CPU ID for z/Architecture) */
-            ebcdic_put(sysib.sysib_111.model, "QEMU            ", 16);
-            ebcdic_put(sysib.sysib_111.sequence, "QEMU            ", 16);
-            ebcdic_put(sysib.sysib_111.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_111.model, "Intel           ", 16);
+            ebcdic_put(sysib.sysib_111.sequence, "Intel           ", 16);
+            ebcdic_put(sysib.sysib_111.plant, "INTL", 4);
         } else if ((sel1 == 2) && (sel2 == 1)) {
             /* Basic Machine CPU */
-            ebcdic_put(sysib.sysib_121.sequence, "QEMUQEMUQEMUQEMU", 16);
-            ebcdic_put(sysib.sysib_121.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_121.sequence, "INTELINTELINTELI", 16);
+            ebcdic_put(sysib.sysib_121.plant, "INTL", 4);
             sysib.sysib_121.cpu_addr = cpu_to_be16(env->core_id);
         } else if ((sel1 == 2) && (sel2 == 2)) {
             /* Basic Machine CPUs */
@@ -352,8 +352,8 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
     case STSI_R0_FC_LEVEL_2:
         if ((sel1 == 2) && (sel2 == 1)) {
             /* LPAR CPU */
-            ebcdic_put(sysib.sysib_221.sequence, "QEMUQEMUQEMUQEMU", 16);
-            ebcdic_put(sysib.sysib_221.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_221.sequence, "INTELINTELINTELI", 16);
+            ebcdic_put(sysib.sysib_221.plant, "INTL", 4);
             sysib.sysib_221.cpu_addr = cpu_to_be16(env->core_id);
         } else if ((sel1 == 2) && (sel2 == 2)) {
             /* LPAR CPUs */
@@ -361,7 +361,7 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
             sysib.sysib_222.total_cpus = cpu_to_be16(total_cpus);
             sysib.sysib_222.conf_cpus = cpu_to_be16(conf_cpus);
             sysib.sysib_222.reserved_cpus = cpu_to_be16(reserved_cpus);
-            ebcdic_put(sysib.sysib_222.name, "QEMU    ", 8);
+            ebcdic_put(sysib.sysib_222.name, "Intel   ", 8);
             sysib.sysib_222.caf = cpu_to_be32(1000);
             sysib.sysib_222.dedicated_cpus = cpu_to_be16(conf_cpus);
         } else {
@@ -377,7 +377,7 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
             sysib.sysib_322.vm[0].reserved_cpus = cpu_to_be16(reserved_cpus);
             sysib.sysib_322.vm[0].caf = cpu_to_be32(1000);
             /* Linux kernel uses this to distinguish us from z/VM */
-            ebcdic_put(sysib.sysib_322.vm[0].cpi, "KVM/Linux       ", 16);
+            ebcdic_put(sysib.sysib_322.vm[0].cpi, "IntelIntel      ", 16);
             sysib.sysib_322.vm[0].ext_name_encoding = 2; /* UTF-8 */
 
             /* If our VM has a name, use the real name */

```

`patches/QEMU/Archive/libnfs6-qemu-10.1.1.patch`:

```patch
diff --git a/block/nfs.c b/block/nfs.c
index 0a7d38d..93e4bbf 100644
--- a/block/nfs.c
+++ b/block/nfs.c
@@ -70,7 +70,9 @@ typedef struct NFSRPC {
     BlockDriverState *bs;
     int ret;
     int complete;
+#ifndef LIBNFS_API_V2
     QEMUIOVector *iov;
+#endif
     struct stat *st;
     Coroutine *co;
     NFSClient *client;
@@ -246,6 +248,7 @@ nfs_co_generic_cb(int ret, struct nfs_context *nfs, void *data,
     NFSRPC *task = private_data;
     task->ret = ret;
     assert(!task->st);
+#ifndef LIBNFS_API_V2
     if (task->ret > 0 && task->iov) {
         if (task->ret <= task->iov->size) {
             qemu_iovec_from_buf(task->iov, 0, data, task->ret);
@@ -253,6 +256,7 @@ nfs_co_generic_cb(int ret, struct nfs_context *nfs, void *data,
             task->ret = -EIO;
         }
     }
+#endif
     if (task->ret < 0) {
         error_report("NFS Error: %s", nfs_get_error(nfs));
     }
@@ -266,15 +270,43 @@ static int coroutine_fn nfs_co_preadv(BlockDriverState *bs, int64_t offset,
 {
     NFSClient *client = bs->opaque;
     NFSRPC task;
+#ifdef LIBNFS_API_V2
+    char *buf = NULL;
+    bool my_buffer = false;
+#endif
 
     nfs_co_init_task(bs, &task);
+
+#ifdef LIBNFS_API_V2
+    if (iov->niov != 1) {
+        buf = g_try_malloc(bytes);
+        if (bytes && buf == NULL) {
+            return -ENOMEM;
+        }
+        my_buffer = true;
+    } else {
+        buf = iov->iov[0].iov_base;
+    }
+#else
     task.iov = iov;
+#endif
 
     WITH_QEMU_LOCK_GUARD(&client->mutex) {
+#ifdef LIBNFS_API_V2
+        if (nfs_pread_async(client->context, client->fh,
+                            buf, bytes, offset,
+                            nfs_co_generic_cb, &task) != 0) {
+            if (my_buffer) {
+                g_free(buf);
+            }
+            return -ENOMEM;
+        }
+#else
         if (nfs_pread_async(client->context, client->fh,
                             offset, bytes, nfs_co_generic_cb, &task) != 0) {
             return -ENOMEM;
         }
+#endif
 
         nfs_set_events(client);
     }
@@ -282,6 +314,15 @@ static int coroutine_fn nfs_co_preadv(BlockDriverState *bs, int64_t offset,
         qemu_coroutine_yield();
     }
 
+#ifdef LIBNFS_API_V2
+    if (task.ret > 0) {
+        qemu_iovec_from_buf(iov, 0, buf, task.ret);
+    }
+    if (my_buffer) {
+        g_free(buf);
+    }
+#endif
+
     if (task.ret < 0) {
         return task.ret;
     }
@@ -318,7 +359,11 @@ static int coroutine_fn nfs_co_pwritev(BlockDriverState *bs, int64_t offset,
 
     WITH_QEMU_LOCK_GUARD(&client->mutex) {
         if (nfs_pwrite_async(client->context, client->fh,
+#ifdef LIBNFS_API_V2
+                             buf, bytes, offset,
+#else
                              offset, bytes, buf,
+#endif
                              nfs_co_generic_cb, &task) != 0) {
             if (my_buffer) {
                 g_free(buf);

```

`patches/QEMU/Intel-v10.2.0.patch`:

```patch
diff --git a/hw/acpi/aml-build.c b/hw/acpi/aml-build.c
index 2d5826a..7cd88c2 100644
--- a/hw/acpi/aml-build.c
+++ b/hw/acpi/aml-build.c
@@ -1722,11 +1722,11 @@ void acpi_table_begin(AcpiTable *desc, GArray *array)
     build_append_int_noprefix(array, 0, 4); /* Length */
     build_append_int_noprefix(array, desc->rev, 1); /* Revision */
     build_append_int_noprefix(array, 0, 1); /* Checksum */
-    build_append_padded_str(array, desc->oem_id, 6, '\0'); /* OEMID */
+    build_append_padded_str(array, ACPI_BUILD_APPNAME6, 6, '\0'); /* OEMID */
     /* OEM Table ID */
-    build_append_padded_str(array, desc->oem_table_id, 8, '\0');
+    build_append_padded_str(array, ACPI_BUILD_APPNAME8, 8, '\0');
     build_append_int_noprefix(array, 1, 4); /* OEM Revision */
-    g_array_append_vals(array, ACPI_BUILD_APPNAME8, 4); /* Creator ID */
+    g_array_append_vals(array, "ACPI", 4); /* Creator ID */
     build_append_int_noprefix(array, 1, 4); /* Creator Revision */
 }
 
@@ -2263,7 +2263,7 @@ void build_fadt(GArray *tbl, BIOSLinker *linker, const AcpiFadtData *f,
     /* ACPI1.0: INT_MODEL, ACPI2.0+: Reserved */
     build_append_int_noprefix(tbl, f->int_model /* Multiple APIC */, 1);
     /* Preferred_PM_Profile */
-    build_append_int_noprefix(tbl, 0 /* Unspecified */, 1);
+    build_append_int_noprefix(tbl, 1 /* Desktop */, 1);
     build_append_int_noprefix(tbl, f->sci_int, 2); /* SCI_INT */
     build_append_int_noprefix(tbl, f->smi_cmd, 4); /* SMI_CMD */
     build_append_int_noprefix(tbl, f->acpi_enable_cmd, 1); /* ACPI_ENABLE */
@@ -2360,7 +2360,7 @@ void build_fadt(GArray *tbl, BIOSLinker *linker, const AcpiFadtData *f,
     }
 
     /* Hypervisor Vendor Identity */
-    build_append_padded_str(tbl, "QEMU", 8, '\0');
+    build_append_padded_str(tbl, "", 8, '\0');
 
     /* TODO: extra fields need to be added to support revisions above rev6 */
     assert(f->rev == 6);
diff --git a/hw/acpi/pcihp.c b/hw/acpi/pcihp.c
index 4922bbc..2b86b9d 100644
--- a/hw/acpi/pcihp.c
+++ b/hw/acpi/pcihp.c
@@ -701,6 +701,83 @@ void build_append_pcihp_resources(Aml *scope /* \\_SB.PCI0 */,
     aml_append(scope, dev);
 }
 
+/*
+ * Helper to generate "Real Hardware" looking ACPI names.
+ * This removes the "S<hex>" signature and ensures unique naming
+ * for multifunction devices.
+ */
+static void get_mimic_pci_name(char *name, int devfn) {
+    int slot = PCI_SLOT(devfn);
+    int func = PCI_FUNC(devfn);
+
+    switch (slot) {
+        case 0:
+            // Host Bridge is almost always Slot 0, Function 0 (and also bus 0 but we cant access bus number in this context)
+            if (func == 0) sprintf(name, "MCHC");
+            else sprintf(name, "H%X", func);
+            break;
+
+        case 2:
+            // Slot 2: Graphics + associated HDMI Audio
+            if (func == 0) sprintf(name, "GFX0");      // Primary GPU
+            else if (func == 1) sprintf(name, "HDAU"); // HDMI Audio
+            else sprintf(name, "GFX%X", func);         // Fallback uniqueness
+            break;
+
+        case 3:
+            // Slot 3: Network
+            if (func == 0) sprintf(name, "GLAN");
+            else sprintf(name, "NET%X", func);
+            break;
+
+        case 4:
+            // Slot 4: Multimedia / Audio
+            if (func == 0) sprintf(name, "HDEF");
+            else sprintf(name, "MM%02X", func);
+            break;
+
+        case 5:
+            // Slot 5: USB XHCI (QEMU default often)
+            if (func == 0) sprintf(name, "XHC1");
+            else sprintf(name, "XHC%X", func);
+            break;
+
+        case 6:
+            // Slot 6: SATA (AHCI)
+            if (func == 0) sprintf(name, "SAT0");
+            else sprintf(name, "SAT%X", func);
+            break;
+
+        case 29:
+            // Slot 29 (0x1D): USB EHCI (Intel Standard)
+            if (func == 0) sprintf(name, "EHC1");
+            else sprintf(name, "EHC%X", func);
+            break;
+
+        case 31:
+            // Slot 31 (0x1F): LPC / SMBus / SATA 2
+            if (func == 0) sprintf(name, "LPCB");      // ISA Bridge
+            else if (func == 2) sprintf(name, "SAT1"); // 2nd SATA
+            else if (func == 3) sprintf(name, "SBUS"); // SMBus
+            else sprintf(name, "S31%X", func);         // Fallback
+            break;
+
+        default:
+            /*
+             * For generic slots, we use "RP" (Root Port) + devfn (Hex).
+             *
+             * Why 'devfn' and not 'slot'?
+             * - Slot 10, Func 0 (devfn 0x50) -> RP50
+             * - Slot 10, Func 1 (devfn 0x51) -> RP51
+             *
+             * This guarantees ACPI uniqueness for multifunction devices
+             * while completely breaking the "S" + hex signature.
+             */
+            sprintf(name, "RP%02X", devfn);
+            break;
+    }
+}
+
 bool build_append_notification_callback(Aml *parent_scope, const PCIBus *bus)
 {
     Aml *method;
@@ -710,7 +787,10 @@ bool build_append_notification_callback(Aml *parent_scope, const PCIBus *bus)
     GQueue *pcnt_bus_list = g_queue_new();
 
     QLIST_FOREACH(sec, &bus->child, sibling) {
-        Aml *br_scope = aml_scope("S%.02X", sec->parent_dev->devfn);
+        char mimic_name[5];
+        get_mimic_pci_name(mimic_name, sec->parent_dev->devfn);
+        Aml *br_scope = aml_scope("%s", mimic_name);
+
         if (pci_bus_is_root(sec)) {
             continue;
         }
@@ -749,7 +829,9 @@ bool build_append_notification_callback(Aml *parent_scope, const PCIBus *bus)
 
     /* Notify about child bus events in any case */
     while ((sec = g_queue_pop_head(pcnt_bus_list))) {
-        aml_append(method, aml_name("^S%.02X.PCNT", sec->parent_dev->devfn));
+        char mimic_name[5];
+        get_mimic_pci_name(mimic_name, sec->parent_dev->devfn);
+        aml_append(method, aml_name("^%s.PCNT", mimic_name));
     }
 
     aml_append(parent_scope, method);
@@ -805,8 +887,10 @@ static void build_append_pcihp_notify_entry(Aml *method, int slot)
     Aml *if_ctx;
     int32_t devfn = PCI_DEVFN(slot, 0);
 
+    char mimic_name[5];
+    get_mimic_pci_name(mimic_name, devfn);
     if_ctx = aml_if(aml_and(aml_arg(0), aml_int(0x1U << slot), NULL));
-    aml_append(if_ctx, aml_notify(aml_name("S%.02X", devfn), aml_arg(1)));
+    aml_append(if_ctx, aml_notify(aml_name("%s", mimic_name), aml_arg(1)));
     aml_append(method, if_ctx);
 }
 
@@ -869,10 +953,13 @@ void build_append_pcihp_slots(Aml *parent_scope, PCIBus *bus)
             continue;
         }
 
+        char mimic_name[5];
+        get_mimic_pci_name(mimic_name, devfn);
+
         if (bus->devices[devfn]) {
-            dev = aml_scope("S%.02X", devfn);
+            dev = aml_scope("%s", mimic_name);
         } else {
-            dev = aml_device("S%.02X", devfn);
+            dev = aml_device("%s", mimic_name);
             aml_append(dev, aml_name_decl("_ADR", aml_int(adr)));
         }
 
@@ -914,7 +1001,11 @@ void build_append_pci_bus_devices(Aml *parent_scope, PCIBus *bus)
         }
 
         /* start to compose PCI device descriptor */
-        dev = aml_device("S%.02X", devfn);
+
+        char mimic_name[5];
+        get_mimic_pci_name(mimic_name, devfn);
+        dev = aml_device("%s", mimic_name);
+
         aml_append(dev, aml_name_decl("_ADR", aml_int(adr)));
 
         call_dev_aml_func(DEVICE(bus->devices[devfn]), dev);
diff --git a/hw/audio/hda-codec.c b/hw/audio/hda-codec.c
index e90c9de..5b147d6 100644
--- a/hw/audio/hda-codec.c
+++ b/hw/audio/hda-codec.c
@@ -118,7 +118,7 @@ static void hda_codec_parse_fmt(uint32_t format, struct audsettings *as)
 
 /* some defines */
 
-#define QEMU_HDA_ID_VENDOR  0x1af4
+#define QEMU_HDA_ID_VENDOR  0x10EC /* Realtek HDA Codec Vendor ID */
 #define QEMU_HDA_PCM_FORMATS (AC_SUPPCM_BITS_16 |       \
                               0x1fc /* 16 -> 96 kHz */)
 #define QEMU_HDA_AMP_NONE    (0)
diff --git a/hw/audio/intel-hda.c b/hw/audio/intel-hda.c
index 758e130..78a4e0f 100644
--- a/hw/audio/intel-hda.c
+++ b/hw/audio/intel-hda.c
@@ -1239,7 +1239,7 @@ static void intel_hda_class_init_ich6(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->device_id = 0x2668;
+    k->device_id = 0x51c8; // "Intel 82801IB ICH6 - High Definition Audio [A3]" | Intel Device ID Replacement from 0x2668 | hw/audio/intel-hda.c
     k->revision = 1;
     set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
     dc->desc = "Intel HD Audio Controller (ich6)";
@@ -1250,8 +1250,8 @@ static void intel_hda_class_init_ich9(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->device_id = 0x293e;
-    k->revision = 3;
+    k->device_id = 0x51c8; // "Intel 82801IB ICH9 - High Definition Audio [A3]" | Intel Device ID Replacement from 0x293e | hw/audio/intel-hda.c
+    k->revision = 1;
     set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
     dc->desc = "Intel HD Audio Controller (ich9)";
 }
diff --git a/hw/core/qdev.c b/hw/core/qdev.c
index fab42a7..ed5052b 100644
--- a/hw/core/qdev.c
+++ b/hw/core/qdev.c
@@ -774,7 +774,7 @@ static void device_class_init(ObjectClass *class, const void *data)
      * hotpluggable. Devices that shouldn't be hotpluggable,
      * should override it in their class_init()
      */
-    dc->hotpluggable = true;
+    dc->hotpluggable = false;
     dc->user_creatable = true;
     vc->get_id = device_vmstate_if_get_id;
     rc->get_state = device_get_reset_state;
diff --git a/hw/display/edid-generate.c b/hw/display/edid-generate.c
index 2cb8196..630a33b 100644
--- a/hw/display/edid-generate.c
+++ b/hw/display/edid-generate.c
@@ -388,22 +388,22 @@ void qemu_edid_generate(uint8_t *edid, size_t size,
     uint8_t *did = NULL;
     uint32_t width_mm, height_mm;
     uint32_t refresh_rate = info->refresh_rate ? info->refresh_rate : 75000;
-    uint32_t dpi = 100; /* if no width_mm/height_mm */
+    uint32_t dpi = 82; /* if no width_mm/height_mm */
     uint32_t large_screen = 0;
 
     /* =============== set defaults  =============== */
 
     if (!info->vendor || strlen(info->vendor) != 3) {
-        info->vendor = "RHT";
+        info->vendor = "MSI";
     }
     if (!info->name) {
-        info->name = "QEMU Monitor";
+        info->name = "G27C4X";
     }
     if (!info->prefx) {
-        info->prefx = 1280;
+        info->prefx = 1920;
     }
     if (!info->prefy) {
-        info->prefy = 800;
+        info->prefy = 1080;
     }
     if (info->width_mm && info->height_mm) {
         width_mm = info->width_mm;
@@ -449,15 +449,15 @@ void qemu_edid_generate(uint8_t *edid, size_t size,
     uint16_t vendor_id = ((((info->vendor[0] - '@') & 0x1f) << 10) |
                           (((info->vendor[1] - '@') & 0x1f) <<  5) |
                           (((info->vendor[2] - '@') & 0x1f) <<  0));
-    uint16_t model_nr = 0x1234;
+    uint16_t model_nr = 0x10ad;
     uint32_t serial_nr = info->serial ? atoi(info->serial) : 0;
     stw_be_p(edid +  8, vendor_id);
     stw_le_p(edid + 10, model_nr);
     stl_le_p(edid + 12, serial_nr);
 
     /* manufacture week and year */
-    edid[16] = 42;
-    edid[17] = 2014 - 1990;
+    edid[16] = 12;
+    edid[17] = 2025 - 2018;
 
     /* edid version */
     edid[18] = 1;
diff --git a/hw/display/qxl.c b/hw/display/qxl.c
index 18f482c..6679592 100644
--- a/hw/display/qxl.c
+++ b/hw/display/qxl.c
@@ -2503,7 +2503,7 @@ static void qxl_pci_class_init(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->vendor_id = REDHAT_PCI_VENDOR_ID;
+    k->vendor_id = PCI_VENDOR_ID_REDHAT;
     k->device_id = QXL_DEVICE_ID_STABLE;
     set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);
     device_class_set_legacy_reset(dc, qxl_reset_handler);
diff --git a/hw/i2c/smbus_ich9.c b/hw/i2c/smbus_ich9.c
index 956c9b5..71a4267 100644
--- a/hw/i2c/smbus_ich9.c
+++ b/hw/i2c/smbus_ich9.c
@@ -129,7 +129,7 @@ static void ich9_smb_class_init(ObjectClass *klass, const void *data)
     k->revision = ICH9_A2_SMB_REVISION;
     k->class_id = PCI_CLASS_SERIAL_SMBUS;
     dc->vmsd = &vmstate_ich9_smbus;
-    dc->desc = "ICH9 SMBUS Bridge";
+    dc->desc = "FCH SMBus Controller";
     k->realize = ich9_smbus_realize;
     k->config_write = ich9_smbus_write_config;
     /*
diff --git a/hw/i386/acpi-build.c b/hw/i386/acpi-build.c
index 9446a9f..f354b28 100644
--- a/hw/i386/acpi-build.c
+++ b/hw/i386/acpi-build.c
@@ -161,8 +161,8 @@ static void init_common_fadt_data(MachineState *ms, Object *o,
                         (1 << ACPI_FADT_F_FORCE_APIC_CLUSTER_MODEL) : 0),
         .int_model = 1 /* Multiple APIC */,
         .rtc_century = RTC_CENTURY,
-        .plvl2_lat = 0xfff /* C2 state not supported */,
-        .plvl3_lat = 0xfff /* C3 state not supported */,
+        .plvl2_lat = 0x0065 /* C2 state not supported */,
+        .plvl3_lat = 0x03e9 /* C3 state not supported */,
         .smi_cmd = smm_enabled ? ACPI_PORT_SMI_CMD : 0,
         .sci_int = object_property_get_uint(o, ACPI_PM_PROP_SCI_INT, NULL),
         .acpi_enable_cmd =
@@ -881,6 +881,68 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,
     build_dbg_aml(dsdt);
     if (i440fx) {
         sb_scope = aml_scope("_SB");
+
+        /*
+         * Emulate Windows ACPI OSYS/_OSI logic in DSDT.
+         * Adds Windows 2001/2006/2009/2012/2013/2015.
+         */
+
+        aml_append(sb_scope, aml_name_decl("OSYS", aml_int(0x03E8)));
+
+        Aml *osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP2")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D2), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001.1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D3), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2006")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D6), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2009")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D9), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2012")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DC), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2013")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DD), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2015")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DF), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
         dev = aml_device("PCI0");
         aml_append(dev, aml_name_decl("_HID", aml_eisaid("PNP0A03")));
         aml_append(dev, aml_name_decl("_UID", aml_int(pcmc->pci_root_uid)));
@@ -894,6 +956,68 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,
         build_piix4_pci0_int(dsdt);
     } else if (q35) {
         sb_scope = aml_scope("_SB");
+
+        /*
+         * Emulate Windows ACPI OSYS/_OSI logic in DSDT.
+         * Adds Windows 2001/2006/2009/2012/2013/2015.
+         */
+
+        aml_append(sb_scope, aml_name_decl("OSYS", aml_int(0x03E8)));
+
+        Aml *osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP2")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D2), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001.1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D3), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2006")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D6), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2009")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D9), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2012")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DC), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2013")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DD), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2015")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DF), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
         dev = aml_device("PCI0");
         aml_append(dev, aml_name_decl("_HID", aml_eisaid("PNP0A08")));
         aml_append(dev, aml_name_decl("_CID", aml_eisaid("PNP0A03")));
@@ -1186,7 +1310,7 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,
     /* create fw_cfg node, unconditionally */
     {
         scope = aml_scope("\\_SB.PCI0");
-        fw_cfg_add_acpi_dsdt(scope, x86ms->fw_cfg);
+        //fw_cfg_add_acpi_dsdt(scope, x86ms->fw_cfg); Fix compile error
         aml_append(dsdt, scope);
     }
 
@@ -1630,6 +1754,8 @@ build_dmar_q35(GArray *table_data, BIOSLinker *linker, const char *oem_id,
  *
  * Helpful to speedup Windows guests and ignored by others.
  */
+// Disable WAET device (not found on bare metal systems)
+#if 0
 static void
 build_waet(GArray *table_data, BIOSLinker *linker, const char *oem_id,
            const char *oem_table_id)
@@ -1648,6 +1774,7 @@ build_waet(GArray *table_data, BIOSLinker *linker, const char *oem_id,
     build_append_int_noprefix(table_data, 1 << 1 /* ACPI PM timer good */, 4);
     acpi_table_end(linker, &table);
 }
+#endif
 
 /*
  *   IVRS table as specified in AMD IOMMU Specification v2.62, Section 5.2
@@ -2076,8 +2203,9 @@ void acpi_build(AcpiBuildTables *tables, MachineState *machine)
                        x86ms->oem_id, x86ms->oem_table_id, &pcms->cxl_devices_state);
     }
 
-    acpi_add_table(table_offsets, tables_blob);
-    build_waet(tables_blob, tables->linker, x86ms->oem_id, x86ms->oem_table_id);
+    // Disable WAET table (not found on bare metal systems)
+    // acpi_add_table(table_offsets, tables_blob);
+    // build_waet(tables_blob, tables->linker, x86ms->oem_id, x86ms->oem_table_id);
 
     /* Add tables supplied by user (if any) */
     for (u = acpi_table_first(); u; u = acpi_table_next(u)) {
diff --git a/hw/i386/acpi-microvm.c b/hw/i386/acpi-microvm.c
index bc65717..f4b1bea 100644
--- a/hw/i386/acpi-microvm.c
+++ b/hw/i386/acpi-microvm.c
@@ -118,7 +118,7 @@ build_dsdt_microvm(GArray *table_data, BIOSLinker *linker,
     dsdt = init_aml_allocator();
 
     sb_scope = aml_scope("_SB");
-    fw_cfg_add_acpi_dsdt(sb_scope, x86ms->fw_cfg);
+    //fw_cfg_add_acpi_dsdt(sb_scope, x86ms->fw_cfg); Fix compile error
     qbus_build_aml(BUS(isabus), sb_scope);
     build_ged_aml(sb_scope, GED_DEVICE, x86ms->acpi_dev,
                   GED_MMIO_IRQ, AML_SYSTEM_MEMORY, GED_MMIO_BASE);
diff --git a/hw/i386/fw_cfg.c b/hw/i386/fw_cfg.c
index 5c0bcd5..ac47187 100644
--- a/hw/i386/fw_cfg.c
+++ b/hw/i386/fw_cfg.c
@@ -75,7 +75,7 @@ void fw_cfg_build_smbios(PCMachineState *pcms, FWCfgState *fw_cfg,
 
     if (pcmc->smbios_defaults) {
         /* These values are guest ABI, do not change */
-        smbios_set_defaults("QEMU", mc->desc, mc->name);
+        smbios_set_defaults("Unknown", mc->desc, mc->name);
     }
 
     /* tell smbios about cpuid version and features */
@@ -212,6 +212,8 @@ void fw_cfg_build_feature_control(MachineState *ms, FWCfgState *fw_cfg)
     fw_cfg_add_file(fw_cfg, "etc/msr_feature_control", val, sizeof(*val));
 }
 
+// Disable FWCF device (not found on bare metal systems)
+#if 0
 #ifdef CONFIG_ACPI
 void fw_cfg_add_acpi_dsdt(Aml *scope, FWCfgState *fw_cfg)
 {
@@ -240,3 +242,4 @@ void fw_cfg_add_acpi_dsdt(Aml *scope, FWCfgState *fw_cfg)
     aml_append(scope, dev);
 }
 #endif
+#endif
diff --git a/hw/ide/atapi.c b/hw/ide/atapi.c
index a42b748..c10cf51 100644
--- a/hw/ide/atapi.c
+++ b/hw/ide/atapi.c
@@ -798,8 +798,8 @@ static void cmd_inquiry(IDEState *s, uint8_t *buf)
         buf[5] = 0;    /* reserved */
         buf[6] = 0;    /* reserved */
         buf[7] = 0;    /* reserved */
-        padstr8(buf + 8, 8, "QEMU");
-        padstr8(buf + 16, 16, "QEMU DVD-ROM");
+        padstr8(buf + 8, 8, "Samsung");
+        padstr8(buf + 16, 16, "DVD-ROM");
         padstr8(buf + 32, 4, s->version);
         idx = 36;
     }
diff --git a/hw/ide/core.c b/hw/ide/core.c
index 8c380ab..edd4294 100644
--- a/hw/ide/core.c
+++ b/hw/ide/core.c
@@ -2638,21 +2638,20 @@ int ide_init_drive(IDEState *s, IDEDevice *dev, IDEDriveKind kind, Error **errp)
     if (dev->serial) {
         pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), dev->serial);
     } else {
-        snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),
-                 "QM%05d", s->drive_serial);
+        s->drive_serial_str[0] = '\0';  // Empty string fallback instead of QEMU default
     }
     if (dev->model) {
         pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), dev->model);
     } else {
         switch (kind) {
         case IDE_CD:
-            strcpy(s->drive_model_str, "QEMU DVD-ROM");
+            strcpy(s->drive_model_str, "HL-DT-ST BD-RE WH16NS60");
             break;
         case IDE_CFATA:
-            strcpy(s->drive_model_str, "QEMU MICRODRIVE");
+            strcpy(s->drive_model_str, "Hitachi HMS360404D5CF00");
             break;
         default:
-            strcpy(s->drive_model_str, "QEMU HARDDISK");
+            strcpy(s->drive_model_str, "Samsung SSD 980 500GB");
             break;
         }
     }
diff --git a/hw/isa/lpc_ich9.c b/hw/isa/lpc_ich9.c
index c9cb8f7..c1c7bdc 100644
--- a/hw/isa/lpc_ich9.c
+++ b/hw/isa/lpc_ich9.c
@@ -863,7 +863,7 @@ static void build_ich9_isa_aml(AcpiDevAmlIf *adev, Aml *scope)
     aml_append(scope, aml_operation_region("PIRQ", AML_PCI_CONFIG,
                                            aml_int(0x60), 0x0C));
     /* Fields declarion has to happen *after* operation region */
-    field = aml_field("PCI0.SF8.PIRQ", AML_BYTE_ACC, AML_NOLOCK, AML_PRESERVE);
+    field = aml_field("PCI0.LPCB.PIRQ", AML_BYTE_ACC, AML_NOLOCK, AML_PRESERVE);
     aml_append(field, aml_named_field("PRQA", 8));
     aml_append(field, aml_named_field("PRQB", 8));
     aml_append(field, aml_named_field("PRQC", 8));
diff --git a/hw/misc/pvpanic-isa.c b/hw/misc/pvpanic-isa.c
index f7b421c..881cf2b 100644
--- a/hw/misc/pvpanic-isa.c
+++ b/hw/misc/pvpanic-isa.c
@@ -69,7 +69,7 @@ static void build_pvpanic_isa_aml(AcpiDevAmlIf *adev, Aml *scope)
     PVPanicISAState *s = PVPANIC_ISA_DEVICE(adev);
     Aml *dev = aml_device("PEVT");
 
-    aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0001")));
+    aml_append(dev, aml_name_decl("_HID", aml_string("UEFI0001")));
 
     crs = aml_resource_template();
     aml_append(crs,
diff --git a/hw/nvme/ctrl.c b/hw/nvme/ctrl.c
index cc4593c..b002b80 100644
--- a/hw/nvme/ctrl.c
+++ b/hw/nvme/ctrl.c
@@ -9094,7 +9094,7 @@ static void nvme_init_ctrl(NvmeCtrl *n, PCIDevice *pci_dev)
 
     id->vid = cpu_to_le16(pci_get_word(pci_conf + PCI_VENDOR_ID));
     id->ssvid = cpu_to_le16(pci_get_word(pci_conf + PCI_SUBSYSTEM_VENDOR_ID));
-    strpadcpy((char *)id->mn, sizeof(id->mn), "QEMU NVMe Ctrl", ' ');
+    strpadcpy((char *)id->mn, sizeof(id->mn), "NVMe Ctrl", ' ');
     strpadcpy((char *)id->fr, sizeof(id->fr), QEMU_VERSION, ' ');
     strpadcpy((char *)id->sn, sizeof(id->sn), n->params.serial, ' ');
 
diff --git a/hw/nvram/fw_cfg-acpi.c b/hw/nvram/fw_cfg-acpi.c
index 2e6ef89..bb5a6f4 100644
--- a/hw/nvram/fw_cfg-acpi.c
+++ b/hw/nvram/fw_cfg-acpi.c
@@ -11,7 +11,7 @@
 void fw_cfg_acpi_dsdt_add(Aml *scope, const MemMapEntry *fw_cfg_memmap)
 {
     Aml *dev = aml_device("FWCF");
-    aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0002")));
+    aml_append(dev, aml_name_decl("_HID", aml_string("UEFI0002")));
     /* device present, functioning, decoding, not shown in UI */
     aml_append(dev, aml_name_decl("_STA", aml_int(0xB)));
     aml_append(dev, aml_name_decl("_CCA", aml_int(1)));
diff --git a/hw/nvram/fw_cfg.c b/hw/nvram/fw_cfg.c
index aa24050..3b903de 100644
--- a/hw/nvram/fw_cfg.c
+++ b/hw/nvram/fw_cfg.c
@@ -56,7 +56,7 @@
 #define FW_CFG_DMA_CTL_SELECT  0x08
 #define FW_CFG_DMA_CTL_WRITE   0x10
 
-#define FW_CFG_DMA_SIGNATURE 0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE 0x51434f4d20434647ULL /* "QCOM CFG" */
 
 struct FWCfgEntry {
     uint32_t len;
@@ -1002,7 +1002,7 @@ static void fw_cfg_common_realize(DeviceState *dev, Error **errp)
         return;
     }
 
-    fw_cfg_add_bytes(s, FW_CFG_SIGNATURE, (char *)"QEMU", 4);
+    fw_cfg_add_bytes(s, FW_CFG_SIGNATURE, (char *)"QEMU", 4); // "QEMU"
     fw_cfg_add_bytes(s, FW_CFG_UUID, &qemu_uuid, 16);
     fw_cfg_add_i16(s, FW_CFG_NOGRAPHIC, (uint16_t)!machine->enable_graphics);
     fw_cfg_add_i16(s, FW_CFG_BOOT_MENU, (uint16_t)(machine->boot_config.has_menu && machine->boot_config.menu));
diff --git a/hw/pci-host/gpex.c b/hw/pci-host/gpex.c
index b806a22..3713551 100644
--- a/hw/pci-host/gpex.c
+++ b/hw/pci-host/gpex.c
@@ -243,7 +243,7 @@ static void gpex_root_class_init(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
 
     set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
-    dc->desc = "QEMU generic PCIe host bridge";
+    dc->desc = "Generic PCIe host bridge";
     dc->vmsd = &vmstate_gpex_root;
     k->vendor_id = PCI_VENDOR_ID_REDHAT;
     k->device_id = PCI_DEVICE_ID_REDHAT_PCIE_HOST;
diff --git a/hw/scsi/mptconfig.c b/hw/scsi/mptconfig.c
index 19d01f3..00ee3f8 100644
--- a/hw/scsi/mptconfig.c
+++ b/hw/scsi/mptconfig.c
@@ -189,12 +189,12 @@ static
 size_t mptsas_config_manufacturing_0(MPTSASState *s, uint8_t **data, int address)
 {
     return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,
-                              "s16s8s16s16s16",
-                              "QEMU MPT Fusion",
+                              "s10s4s85s45s34",
+                              "MPT Fusion",
                               "2.5",
-                              "QEMU MPT Fusion",
-                              "QEMU",
-                              "0000111122223333");
+                              "MPT Fusion",
+                              "MSI",
+                              "7624862998526197");
 }
 
 static
diff --git a/hw/scsi/scsi-bus.c b/hw/scsi/scsi-bus.c
index b9b115d..1c55b40 100644
--- a/hw/scsi/scsi-bus.c
+++ b/hw/scsi/scsi-bus.c
@@ -698,8 +698,8 @@ static bool scsi_target_emulate_inquiry(SCSITargetReq *r)
         r->buf[3] = 2 | 0x10; /* HiSup, response data format */
         r->buf[4] = r->len - 5; /* Additional Length = (Len - 1) - 4 */
         r->buf[7] = 0x10 | (r->req.bus->info->tcq ? 0x02 : 0); /* Sync, TCQ.  */
-        memcpy(&r->buf[8], "QEMU    ", 8);
-        memcpy(&r->buf[16], "QEMU TARGET     ", 16);
+        memcpy(&r->buf[8], "MSI     ", 8);
+        memcpy(&r->buf[16], "MSI TARGET      ", 16);
         pstrcpy((char *) &r->buf[32], 4, qemu_hw_version());
     }
     return true;
diff --git a/hw/scsi/scsi-disk.c b/hw/scsi/scsi-disk.c
index b4782c6..4dae33b 100644
--- a/hw/scsi/scsi-disk.c
+++ b/hw/scsi/scsi-disk.c
@@ -2544,7 +2544,7 @@ static void scsi_realize(SCSIDevice *dev, Error **errp)
         s->version = g_strdup(qemu_hw_version());
     }
     if (!s->vendor) {
-        s->vendor = g_strdup("QEMU");
+        s->vendor = g_strdup("Samsung");
     }
     if (s->serial && strlen(s->serial) > MAX_SERIAL_LEN) {
         error_setg(errp, "The serial number can't be longer than %d characters",
@@ -2608,7 +2608,7 @@ static void scsi_hd_realize(SCSIDevice *dev, Error **errp)
     s->qdev.blocksize = s->qdev.conf.logical_block_size;
     s->qdev.type = TYPE_DISK;
     if (!s->product) {
-        s->product = g_strdup("QEMU HARDDISK");
+        s->product = g_strdup("Samsung SSD 980 500GB");
     }
     scsi_realize(&s->qdev, errp);
 }
@@ -2635,7 +2635,7 @@ static void scsi_cd_realize(SCSIDevice *dev, Error **errp)
     s->qdev.type = TYPE_ROM;
     s->features |= 1 << SCSI_DISK_F_REMOVABLE;
     if (!s->product) {
-        s->product = g_strdup("QEMU CD-ROM");
+        s->product = g_strdup("CD-ROM");
     }
     scsi_realize(&s->qdev, errp);
 }
diff --git a/hw/scsi/spapr_vscsi.c b/hw/scsi/spapr_vscsi.c
index a659131..500865c 100644
--- a/hw/scsi/spapr_vscsi.c
+++ b/hw/scsi/spapr_vscsi.c
@@ -721,8 +721,8 @@ static void vscsi_inquiry_no_target(VSCSIState *s, vscsi_req *req)
     resp_data[3] = 0x02;   /* Resp data format */
     resp_data[4] = 36 - 5; /* Additional length */
     resp_data[7] = 0x10;   /* Sync transfers */
-    memcpy(&resp_data[16], "QEMU EMPTY      ", 16);
-    memcpy(&resp_data[8], "QEMU    ", 8);
+    memcpy(&resp_data[16], "MSI EMPTY       ", 16);
+    memcpy(&resp_data[8], "MSI     ", 8);
 
     req->writing = 0;
     vscsi_preprocess_desc(req);
@@ -979,7 +979,7 @@ static int vscsi_send_adapter_info(VSCSIState *s, vscsi_req *req)
 #endif
     memset(&info, 0, sizeof(info));
     strcpy(info.srp_version, SRP_VERSION);
-    memcpy(info.partition_name, "qemu", sizeof("qemu"));
+    memcpy(info.partition_name, "msi", sizeof("msi"));
     info.partition_number = cpu_to_be32(0);
     info.mad_version = cpu_to_be32(1);
     info.os_type = cpu_to_be32(2);
diff --git a/hw/ufs/lu.c b/hw/ufs/lu.c
index 2d8ffd7..e0d2a92 100644
--- a/hw/ufs/lu.c
+++ b/hw/ufs/lu.c
@@ -184,8 +184,8 @@ static int ufs_emulate_wlun_inquiry(UfsRequest *req, uint8_t *outbuf,
     outbuf[5] = 0;
     outbuf[6] = 0;
     outbuf[7] = 0x2;
-    strpadcpy((char *)&outbuf[8], 8, "QEMU", ' ');
-    strpadcpy((char *)&outbuf[16], 16, "QEMU UFS", ' ');
+    strpadcpy((char *)&outbuf[8], 8, "MSI", ' ');
+    strpadcpy((char *)&outbuf[16], 16, "UFS", ' ');
     memset(&outbuf[32], 0, 4);
 
     return SCSI_INQUIRY_LEN;
diff --git a/hw/usb/canokey.c b/hw/usb/canokey.c
index cbefbb5..4b98e7a 100644
--- a/hw/usb/canokey.c
+++ b/hw/usb/canokey.c
@@ -35,8 +35,8 @@ enum {
 
 static const USBDescStrings desc_strings = {
     [STR_MANUFACTURER]     = "canokeys.org",
-    [STR_PRODUCT]          = "CanoKey QEMU",
-    [STR_SERIALNUMBER]     = "0"
+    [STR_PRODUCT]          = "CanoKey",
+    [STR_SERIALNUMBER]     = ""
 };
 
 static const USBDescDevice desc_device_canokey = {
diff --git a/hw/usb/dev-audio.c b/hw/usb/dev-audio.c
index 8dd9d26..30c4540 100644
--- a/hw/usb/dev-audio.c
+++ b/hw/usb/dev-audio.c
@@ -73,9 +73,9 @@ enum usb_audio_strings {
 };
 
 static const USBDescStrings usb_audio_stringtable = {
-    [STRING_MANUFACTURER]       = "QEMU",
-    [STRING_PRODUCT]            = "QEMU USB Audio",
-    [STRING_SERIALNUMBER]       = "1",
+    [STRING_MANUFACTURER]       = "Logitech",
+    [STRING_PRODUCT]            = "USB Audio",
+    [STRING_SERIALNUMBER]       = "",
     [STRING_CONFIG]             = "Audio Configuration",
     [STRING_USBAUDIO_CONTROL]   = "Audio Device",
     [STRING_INPUT_TERMINAL]     = "Audio Output Pipe",
diff --git a/hw/usb/dev-hid.c b/hw/usb/dev-hid.c
index 96623aa..218c651 100644
--- a/hw/usb/dev-hid.c
+++ b/hw/usb/dev-hid.c
@@ -63,17 +63,17 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
-    [STR_PRODUCT_MOUSE]    = "QEMU USB Mouse",
-    [STR_PRODUCT_TABLET]   = "QEMU USB Tablet",
-    [STR_PRODUCT_KEYBOARD] = "QEMU USB Keyboard",
-    [STR_SERIAL_COMPAT]    = "42",
+    [STR_MANUFACTURER]     = "Logitech",
+    [STR_PRODUCT_MOUSE]    = "USB Mouse",
+    [STR_PRODUCT_TABLET]   = "USB Tablet",
+    [STR_PRODUCT_KEYBOARD] = "USB Keyboard",
+    [STR_SERIAL_COMPAT]    = "",
     [STR_CONFIG_MOUSE]     = "HID Mouse",
     [STR_CONFIG_TABLET]    = "HID Tablet",
     [STR_CONFIG_KEYBOARD]  = "HID Keyboard",
-    [STR_SERIAL_MOUSE]     = "89126",
-    [STR_SERIAL_TABLET]    = "28754",
-    [STR_SERIAL_KEYBOARD]  = "68284",
+    [STR_SERIAL_MOUSE]     = "",
+    [STR_SERIAL_TABLET]    = "",
+    [STR_SERIAL_KEYBOARD]  = "",
 };
 
 static const USBDescIface desc_iface_mouse = {
@@ -368,8 +368,8 @@ static const USBDescMSOS desc_msos_suspend = {
 
 static const USBDesc desc_mouse = {
     .id = {
-        .idVendor          = 0x0627,
-        .idProduct         = 0x0001,
+        .idVendor          = 0x046D,
+        .idProduct         = 0xC077,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
         .iProduct          = STR_PRODUCT_MOUSE,
@@ -382,8 +382,8 @@ static const USBDesc desc_mouse = {
 
 static const USBDesc desc_mouse2 = {
     .id = {
-        .idVendor          = 0x0627,
-        .idProduct         = 0x0001,
+        .idVendor          = 0x046D,
+        .idProduct         = 0xC077,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
         .iProduct          = STR_PRODUCT_MOUSE,
@@ -426,8 +426,8 @@ static const USBDesc desc_tablet2 = {
 
 static const USBDesc desc_keyboard = {
     .id = {
-        .idVendor          = 0x0627,
-        .idProduct         = 0x0001,
+        .idVendor          = 0x046D,
+        .idProduct         = 0xC31C,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
         .iProduct          = STR_PRODUCT_KEYBOARD,
@@ -440,8 +440,8 @@ static const USBDesc desc_keyboard = {
 
 static const USBDesc desc_keyboard2 = {
     .id = {
-        .idVendor          = 0x0627,
-        .idProduct         = 0x0001,
+        .idVendor          = 0x046D,
+        .idProduct         = 0xC31C,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
         .iProduct          = STR_PRODUCT_KEYBOARD,
@@ -805,7 +805,7 @@ static void usb_tablet_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_tablet_realize;
-    uc->product_desc   = "QEMU USB Tablet";
+    uc->product_desc   = "USB Tablet";
     dc->vmsd = &vmstate_usb_ptr;
     device_class_set_props(dc, usb_tablet_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
@@ -827,7 +827,7 @@ static void usb_mouse_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_mouse_realize;
-    uc->product_desc   = "QEMU USB Mouse";
+    uc->product_desc   = "USB Mouse";
     dc->vmsd = &vmstate_usb_ptr;
     device_class_set_props(dc, usb_mouse_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
@@ -850,7 +850,7 @@ static void usb_keyboard_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_keyboard_realize;
-    uc->product_desc   = "QEMU USB Keyboard";
+    uc->product_desc   = "USB Keyboard";
     dc->vmsd = &vmstate_usb_kbd;
     device_class_set_props(dc, usb_keyboard_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
diff --git a/hw/usb/dev-hub.c b/hw/usb/dev-hub.c
index a19350d..cdf3008 100644
--- a/hw/usb/dev-hub.c
+++ b/hw/usb/dev-hub.c
@@ -104,9 +104,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
-    [STR_PRODUCT]      = "QEMU USB Hub",
-    [STR_SERIALNUMBER] = "314159",
+    [STR_MANUFACTURER] = "Logitech",
+    [STR_PRODUCT]      = "USB Hub",
+    [STR_SERIALNUMBER] = "",
 };
 
 static const USBDescIface desc_iface_hub = {
@@ -676,7 +676,7 @@ static void usb_hub_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_hub_realize;
-    uc->product_desc   = "QEMU USB Hub";
+    uc->product_desc   = "USB Hub";
     uc->usb_desc       = &desc_hub;
     uc->find_device    = usb_hub_find_device;
     uc->handle_reset   = usb_hub_handle_reset;
diff --git a/hw/usb/dev-mtp.c b/hw/usb/dev-mtp.c
index afd7944..cd725e3 100644
--- a/hw/usb/dev-mtp.c
+++ b/hw/usb/dev-mtp.c
@@ -246,8 +246,8 @@ typedef struct {
 
 /* ----------------------------------------------------------------------- */
 
-#define MTP_MANUFACTURER  "QEMU"
-#define MTP_PRODUCT       "QEMU filesharing"
+#define MTP_MANUFACTURER  "Microsoft"
+#define MTP_PRODUCT       "filesharing"
 #define MTP_WRITE_BUF_SZ  (512 * KiB)
 
 enum {
@@ -263,7 +263,7 @@ enum {
 static const USBDescStrings desc_strings = {
     [STR_MANUFACTURER] = MTP_MANUFACTURER,
     [STR_PRODUCT]      = MTP_PRODUCT,
-    [STR_SERIALNUMBER] = "34617",
+    [STR_SERIALNUMBER] = "",
     [STR_MTP]          = "MTP",
     [STR_CONFIG_FULL]  = "Full speed config (usb 1.1)",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
@@ -2087,7 +2087,7 @@ static void usb_mtp_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_mtp_realize;
-    uc->product_desc   = "QEMU USB MTP";
+    uc->product_desc   = "USB MTP";
     uc->usb_desc       = &desc;
     uc->cancel_packet  = usb_mtp_cancel_packet;
     uc->handle_attach  = usb_desc_attach;
diff --git a/hw/usb/dev-network.c b/hw/usb/dev-network.c
index 1df2454..1623653 100644
--- a/hw/usb/dev-network.c
+++ b/hw/usb/dev-network.c
@@ -99,16 +99,16 @@ enum usbstring_idx {
 #define ETH_FRAME_LEN                   1514 /* Max. octets in frame sans FCS */
 
 static const USBDescStrings usb_net_stringtable = {
-    [STRING_MANUFACTURER]       = "QEMU",
-    [STRING_PRODUCT]            = "RNDIS/QEMU USB Network Device",
-    [STRING_ETHADDR]            = "400102030405",
-    [STRING_DATA]               = "QEMU USB Net Data Interface",
-    [STRING_CONTROL]            = "QEMU USB Net Control Interface",
-    [STRING_RNDIS_CONTROL]      = "QEMU USB Net RNDIS Control Interface",
-    [STRING_CDC]                = "QEMU USB Net CDC",
-    [STRING_SUBSET]             = "QEMU USB Net Subset",
-    [STRING_RNDIS]              = "QEMU USB Net RNDIS",
-    [STRING_SERIALNUMBER]       = "1",
+    [STRING_MANUFACTURER]       = "Realtek",
+    [STRING_PRODUCT]            = "RNDIS/Realtek USB Network Device",
+    [STRING_ETHADDR]            = "4C82A94C9ECA",
+    [STRING_DATA]               = "USB Net Data Interface",
+    [STRING_CONTROL]            = "USB Net Control Interface",
+    [STRING_RNDIS_CONTROL]      = "USB Net RNDIS Control Interface",
+    [STRING_CDC]                = "USB Net CDC",
+    [STRING_SUBSET]             = "USB Net Subset",
+    [STRING_RNDIS]              = "USB Net RNDIS",
+    [STRING_SERIALNUMBER]       = "",
 };
 
 static const USBDescIface desc_iface_rndis[] = {
@@ -717,7 +717,7 @@ static int ndis_query(USBNetState *s, uint32_t oid,
 
     /* mandatory */
     case OID_GEN_VENDOR_DESCRIPTION:
-        pstrcpy((char *)outbuf, outlen, "QEMU USB RNDIS Net");
+        pstrcpy((char *)outbuf, outlen, "USB RNDIS Net");
         return strlen((char *)outbuf) + 1;
 
     case OID_GEN_VENDOR_DRIVER_VERSION:
@@ -1417,7 +1417,7 @@ static void usb_net_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_net_realize;
-    uc->product_desc   = "QEMU USB Network Interface";
+    uc->product_desc   = "USB Network Interface";
     uc->usb_desc       = &desc_net;
     uc->handle_reset   = usb_net_handle_reset;
     uc->handle_control = usb_net_handle_control;
diff --git a/hw/usb/dev-serial.c b/hw/usb/dev-serial.c
index 2eb52b2..57a7fdf 100644
--- a/hw/usb/dev-serial.c
+++ b/hw/usb/dev-serial.c
@@ -119,10 +119,10 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]    = "QEMU",
-    [STR_PRODUCT_SERIAL]  = "QEMU USB SERIAL",
-    [STR_PRODUCT_BRAILLE] = "QEMU USB BAUM BRAILLE",
-    [STR_SERIALNUMBER]    = "1",
+    [STR_MANUFACTURER]    = "Microsoft",
+    [STR_PRODUCT_SERIAL]  = "USB SERIAL",
+    [STR_PRODUCT_BRAILLE] = "USB BAUM BRAILLE",
+    [STR_SERIALNUMBER]    = "",
 };
 
 static const USBDescIface desc_iface0 = {
@@ -663,7 +663,7 @@ static void usb_serial_class_initfn(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB Serial";
+    uc->product_desc   = "USB Serial";
     uc->usb_desc       = &desc_serial;
     device_class_set_props(dc, serial_properties);
 }
@@ -683,7 +683,7 @@ static void usb_braille_class_initfn(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB Braille";
+    uc->product_desc   = "USB Braille";
     uc->usb_desc       = &desc_braille;
     device_class_set_props(dc, braille_properties);
 }
diff --git a/hw/usb/dev-smartcard-reader.c b/hw/usb/dev-smartcard-reader.c
index 6ce7154..4ce5ffa 100644
--- a/hw/usb/dev-smartcard-reader.c
+++ b/hw/usb/dev-smartcard-reader.c
@@ -80,8 +80,8 @@ OBJECT_DECLARE_SIMPLE_TYPE(USBCCIDState, USB_CCID_DEV)
 #define CCID_CONTROL_GET_CLOCK_FREQUENCIES  0x2
 #define CCID_CONTROL_GET_DATA_RATES         0x3
 
-#define CCID_PRODUCT_DESCRIPTION        "QEMU USB CCID"
-#define CCID_VENDOR_DESCRIPTION         "QEMU"
+#define CCID_PRODUCT_DESCRIPTION        "USB CCID"
+#define CCID_VENDOR_DESCRIPTION         "Identiv"
 #define CCID_INTERFACE_NAME             "CCID Interface"
 #define CCID_SERIAL_NUMBER_STRING       "1"
 /*
@@ -419,9 +419,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]  = "QEMU",
-    [STR_PRODUCT]       = "QEMU USB CCID",
-    [STR_SERIALNUMBER]  = "1",
+    [STR_MANUFACTURER]  = "Identiv",
+    [STR_PRODUCT]       = "USB CCID",
+    [STR_SERIALNUMBER]  = "",
     [STR_INTERFACE]     = "CCID Interface",
 };
 
@@ -1440,7 +1440,7 @@ static void ccid_class_initfn(ObjectClass *klass, const void *data)
     HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(klass);
 
     uc->realize        = ccid_realize;
-    uc->product_desc   = "QEMU USB CCID";
+    uc->product_desc   = "USB CCID";
     uc->usb_desc       = &desc_ccid;
     uc->handle_reset   = ccid_handle_reset;
     uc->handle_control = ccid_handle_control;
diff --git a/hw/usb/dev-storage.c b/hw/usb/dev-storage.c
index b13fe34..a02b0cd 100644
--- a/hw/usb/dev-storage.c
+++ b/hw/usb/dev-storage.c
@@ -47,9 +47,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
-    [STR_PRODUCT]      = "QEMU USB HARDDRIVE",
-    [STR_SERIALNUMBER] = "1",
+    [STR_MANUFACTURER] = "Samsung",
+    [STR_PRODUCT]      = "USB HARDDRIVE",
+    [STR_SERIALNUMBER] = "",
     [STR_CONFIG_FULL]  = "Full speed config (usb 1.1)",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
     [STR_CONFIG_SUPER] = "Super speed config (usb 3.0)",
@@ -590,7 +590,7 @@ static void usb_msd_class_initfn_common(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB MSD";
+    uc->product_desc   = "USB MSD";
     uc->usb_desc       = &desc;
     uc->cancel_packet  = usb_msd_cancel_io;
     uc->handle_attach  = usb_desc_attach;
diff --git a/hw/usb/dev-uas.c b/hw/usb/dev-uas.c
index 18ebe15..0048a8f 100644
--- a/hw/usb/dev-uas.c
+++ b/hw/usb/dev-uas.c
@@ -170,9 +170,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
+    [STR_MANUFACTURER] = "Microsoft",
     [STR_PRODUCT]      = "USB Attached SCSI HBA",
-    [STR_SERIALNUMBER] = "27842",
+    [STR_SERIALNUMBER] = "",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
     [STR_CONFIG_SUPER] = "Super speed config (usb 3.0)",
 };
diff --git a/hw/usb/dev-wacom.c b/hw/usb/dev-wacom.c
index f4b71a2..028189f 100644
--- a/hw/usb/dev-wacom.c
+++ b/hw/usb/dev-wacom.c
@@ -64,9 +64,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
+    [STR_MANUFACTURER]     = "Wacom",
     [STR_PRODUCT]          = "Wacom PenPartner",
-    [STR_SERIALNUMBER]     = "1",
+    [STR_SERIALNUMBER]     = "",
 };
 
 static const uint8_t qemu_wacom_hid_report_descriptor[] = {
@@ -231,7 +231,7 @@ static int usb_mouse_poll(USBWacomState *s, uint8_t *buf, int len)
 
     if (!s->mouse_grabbed) {
         s->eh_entry = qemu_add_mouse_event_handler(usb_mouse_event, s, 0,
-                        "QEMU PenPartner tablet");
+                        "PenPartner tablet");
         qemu_activate_mouse_event_handler(s->eh_entry);
         s->mouse_grabbed = 1;
     }
@@ -269,7 +269,7 @@ static int usb_wacom_poll(USBWacomState *s, uint8_t *buf, int len)
 
     if (!s->mouse_grabbed) {
         s->eh_entry = qemu_add_mouse_event_handler(usb_wacom_event, s, 1,
-                        "QEMU PenPartner tablet");
+                        "PenPartner tablet");
         qemu_activate_mouse_event_handler(s->eh_entry);
         s->mouse_grabbed = 1;
     }
@@ -425,7 +425,7 @@ static void usb_wacom_class_init(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU PenPartner Tablet";
+    uc->product_desc   = "PenPartner Tablet";
     uc->usb_desc       = &desc_wacom;
     uc->realize        = usb_wacom_realize;
     uc->handle_reset   = usb_wacom_handle_reset;
@@ -433,7 +433,7 @@ static void usb_wacom_class_init(ObjectClass *klass, const void *data)
     uc->handle_data    = usb_wacom_handle_data;
     uc->unrealize      = usb_wacom_unrealize;
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
-    dc->desc = "QEMU PenPartner Tablet";
+    dc->desc = "PenPartner Tablet";
     dc->vmsd = &vmstate_usb_wacom;
 }
 
diff --git a/hw/usb/u2f-emulated.c b/hw/usb/u2f-emulated.c
index ace5ece..8cb276a 100644
--- a/hw/usb/u2f-emulated.c
+++ b/hw/usb/u2f-emulated.c
@@ -385,7 +385,7 @@ static void u2f_emulated_class_init(ObjectClass *klass, const void *data)
     kc->realize = u2f_emulated_realize;
     kc->unrealize = u2f_emulated_unrealize;
     kc->recv_from_guest = u2f_emulated_recv_from_guest;
-    dc->desc = "QEMU U2F emulated key";
+    dc->desc = "U2F emulated key";
     device_class_set_props(dc, u2f_emulated_properties);
 }
 
diff --git a/hw/usb/u2f-passthru.c b/hw/usb/u2f-passthru.c
index fa8d9cd..cd4d451 100644
--- a/hw/usb/u2f-passthru.c
+++ b/hw/usb/u2f-passthru.c
@@ -528,7 +528,7 @@ static void u2f_passthru_class_init(ObjectClass *klass, const void *data)
     kc->realize = u2f_passthru_realize;
     kc->unrealize = u2f_passthru_unrealize;
     kc->recv_from_guest = u2f_passthru_recv_from_guest;
-    dc->desc = "QEMU U2F passthrough key";
+    dc->desc = "U2F passthrough key";
     dc->vmsd = &u2f_passthru_vmstate;
     device_class_set_props(dc, u2f_passthru_properties);
     set_bit(DEVICE_CATEGORY_MISC, dc->categories);
diff --git a/hw/usb/u2f.c b/hw/usb/u2f.c
index b051a99..ec103ba 100644
--- a/hw/usb/u2f.c
+++ b/hw/usb/u2f.c
@@ -46,9 +46,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
+    [STR_MANUFACTURER]     = "Microsoft",
     [STR_PRODUCT]          = "U2F USB key",
-    [STR_SERIALNUMBER]     = "0",
+    [STR_SERIALNUMBER]     = "",
     [STR_CONFIG]           = "U2F key config",
     [STR_INTERFACE]        = "U2F key interface"
 };
@@ -322,7 +322,7 @@ static void u2f_key_class_init(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU U2F USB key";
+    uc->product_desc   = "U2F USB key";
     uc->usb_desc       = &desc_u2f_key;
     uc->handle_reset   = u2f_key_handle_reset;
     uc->handle_control = u2f_key_handle_control;
@@ -330,7 +330,7 @@ static void u2f_key_class_init(ObjectClass *klass, const void *data)
     uc->handle_attach  = usb_desc_attach;
     uc->realize        = u2f_key_realize;
     uc->unrealize      = u2f_key_unrealize;
-    dc->desc           = "QEMU U2F key";
+    dc->desc           = "U2F key";
     dc->vmsd           = &vmstate_u2f_key;
 }
 
diff --git a/hw/vfio/ap.c b/hw/vfio/ap.c
index 3368ac8..bcc5c28 100644
--- a/hw/vfio/ap.c
+++ b/hw/vfio/ap.c
@@ -340,7 +340,7 @@ static void vfio_ap_class_init(ObjectClass *klass, const void *data)
     set_bit(DEVICE_CATEGORY_MISC, dc->categories);
     dc->realize = vfio_ap_realize;
     dc->unrealize = vfio_ap_unrealize;
-    dc->hotpluggable = true;
+    dc->hotpluggable = false;
     device_class_set_legacy_reset(dc, vfio_ap_reset);
     dc->bus_type = TYPE_AP_BUS;
 
diff --git a/include/hw/acpi/aml-build.h b/include/hw/acpi/aml-build.h
index f38e129..b4055f5 100644
--- a/include/hw/acpi/aml-build.h
+++ b/include/hw/acpi/aml-build.h
@@ -4,8 +4,8 @@
 #include "hw/acpi/acpi-defs.h"
 #include "hw/acpi/bios-linker-loader.h"
 
-#define ACPI_BUILD_APPNAME6 "BOCHS "
-#define ACPI_BUILD_APPNAME8 "BXPC    "
+#define ACPI_BUILD_APPNAME6 "INTEL "
+#define ACPI_BUILD_APPNAME8 "U Rvp   "
 
 #define ACPI_BUILD_TABLE_FILE "etc/acpi/tables"
 #define ACPI_BUILD_RSDP_FILE "etc/acpi/rsdp"
diff --git a/include/hw/pci/pci.h b/include/hw/pci/pci.h
index b72e484..514b6ac 100644
--- a/include/hw/pci/pci.h
+++ b/include/hw/pci/pci.h
@@ -57,7 +57,7 @@ extern bool pci_available;
 #define PCI_DEVICE_ID_MARVELL_GT6412X    0x4620
 
 /* QEMU/Bochs VGA (0x1234) */
-#define PCI_VENDOR_ID_QEMU               0x1234
+#define PCI_VENDOR_ID_QEMU               0x8086 // "???" | Intel Device ID Replacement from 0x1234
 #define PCI_DEVICE_ID_QEMU_VGA           0x1111
 #define PCI_DEVICE_ID_QEMU_IPMI          0x1112
 
@@ -74,12 +74,12 @@ extern bool pci_available;
 /* Intel (0x8086) */
 #define PCI_DEVICE_ID_INTEL_82551IT      0x1209
 #define PCI_DEVICE_ID_INTEL_82557        0x1229
-#define PCI_DEVICE_ID_INTEL_82801IR      0x2922
+#define PCI_DEVICE_ID_INTEL_82801IR      0x463D // Intel 82801IR ICH9 - LPC Bridge [A2] | Intel Device ID Replacement from 0x2922 | hw/ide/ich.c
 
 /* Red Hat / Qumranet (for QEMU) -- see pci-ids.txt */
-#define PCI_VENDOR_ID_REDHAT_QUMRANET    0x1af4
-#define PCI_SUBVENDOR_ID_REDHAT_QUMRANET 0x1af4
-#define PCI_SUBDEVICE_ID_QEMU            0x1100
+#define PCI_VENDOR_ID_REDHAT_QUMRANET    0x8086 // Intel Vendor ID Replacement from 0x1af4
+#define PCI_SUBVENDOR_ID_REDHAT_QUMRANET 0x8086 // Intel Subvendor ID Replacement from 0x1af4
+#define PCI_SUBDEVICE_ID_QEMU            0x8086 // Intel Subdevice ID Replacement from 0x1100
 
 /* legacy virtio-pci devices */
 #define PCI_DEVICE_ID_VIRTIO_NET         0x1000
@@ -100,21 +100,21 @@ extern bool pci_available;
  */
 #define PCI_DEVICE_ID_VIRTIO_10_BASE     0x1040
 
-#define PCI_VENDOR_ID_REDHAT             0x1b36
-#define PCI_DEVICE_ID_REDHAT_BRIDGE      0x0001
-#define PCI_DEVICE_ID_REDHAT_SERIAL      0x0002
+#define PCI_VENDOR_ID_REDHAT             0x8086 // "Red Hat, Inc." | Intel Vendor ID Replacement from 0x1b36
+#define PCI_DEVICE_ID_REDHAT_BRIDGE      0x4641 // "QEMU PCI-PCI bridge" | Intel Device ID Replacement from 0x0001 | hw/pci-bridge/pci_bridge_dev.c
+#define PCI_DEVICE_ID_REDHAT_SERIAL      0x0002 // TODO: find device_id | Intel Device ID Replacement from 0x???? | hw/char/serial-pci.c
 #define PCI_DEVICE_ID_REDHAT_SERIAL2     0x0003
 #define PCI_DEVICE_ID_REDHAT_SERIAL4     0x0004
 #define PCI_DEVICE_ID_REDHAT_TEST        0x0005
 #define PCI_DEVICE_ID_REDHAT_ROCKER      0x0006
 #define PCI_DEVICE_ID_REDHAT_SDHCI       0x0007
-#define PCI_DEVICE_ID_REDHAT_PCIE_HOST   0x0008
+#define PCI_DEVICE_ID_REDHAT_PCIE_HOST   0x4641 // "QEMU PCIe Host bridge" | Intel Device ID Replacement from 0x0008 | hw/pci-host/gpex.c
 #define PCI_DEVICE_ID_REDHAT_PXB         0x0009
 #define PCI_DEVICE_ID_REDHAT_BRIDGE_SEAT 0x000a
 #define PCI_DEVICE_ID_REDHAT_PXB_PCIE    0x000b
-#define PCI_DEVICE_ID_REDHAT_PCIE_RP     0x000c
-#define PCI_DEVICE_ID_REDHAT_XHCI        0x000d
-#define PCI_DEVICE_ID_REDHAT_PCIE_BRIDGE 0x000e
+#define PCI_DEVICE_ID_REDHAT_PCIE_RP     0x51b0 // "QEMU PCIe Root Port" | Intel Device ID Replacement from 0x000c | hw/pci-bridge/gen_pcie_root_port.c
+#define PCI_DEVICE_ID_REDHAT_XHCI        0x51ed // "QEMU XHCI Host Controller" | Intel Device ID Replacement from 0x000d | hw/usb/hcd-xhci-pci.c
+#define PCI_DEVICE_ID_REDHAT_PCIE_BRIDGE 0x51b0 // "Red Hat, Device ID: 000E" | Intel Device ID Replacement from 0x000e | hw/pci-bridge/pcie_pci_bridge.c
 #define PCI_DEVICE_ID_REDHAT_MDPY        0x000f
 #define PCI_DEVICE_ID_REDHAT_NVME        0x0010
 #define PCI_DEVICE_ID_REDHAT_PVPANIC     0x0011
diff --git a/include/hw/pci/pci_ids.h b/include/hw/pci/pci_ids.h
index 16034aa..e75f41a 100644
--- a/include/hw/pci/pci_ids.h
+++ b/include/hw/pci/pci_ids.h
@@ -237,6 +237,8 @@
 #define PCI_VENDOR_ID_BAIDU              0x1d22
 #define PCI_DEVICE_ID_KUNLUN_VF          0x3685
 
+/* https://www.pcilookup.com/ */
+
 #define PCI_VENDOR_ID_INTEL              0x8086
 #define PCI_DEVICE_ID_INTEL_82378        0x0484
 #define PCI_DEVICE_ID_INTEL_82441        0x1237
@@ -246,8 +248,8 @@
 #define PCI_DEVICE_ID_INTEL_ESB_9        0x25ab
 #define PCI_DEVICE_ID_INTEL_NVME         0x5845
 #define PCI_DEVICE_ID_INTEL_82371SB_0    0x7000
-#define PCI_DEVICE_ID_INTEL_82371SB_1    0x7010
-#define PCI_DEVICE_ID_INTEL_82371SB_2    0x7020
+#define PCI_DEVICE_ID_INTEL_82371SB_1    0x7010 // TODO: | Intel 82371SB_1 - ??? | Intel Vendor ID Replacement from 0x???? | hw/ide/piix.c
+#define PCI_DEVICE_ID_INTEL_82371SB_2    0x7020 // TODO: | Intel 82371SB_2 - ??? | Intel Vendor ID Replacement from 0x???? | hw/usb/hcd-uhci.c
 #define PCI_DEVICE_ID_INTEL_82371AB_0    0x7110
 #define PCI_DEVICE_ID_INTEL_82371AB      0x7111
 #define PCI_DEVICE_ID_INTEL_82371AB_2    0x7112
@@ -259,9 +261,9 @@
 #define PCI_DEVICE_ID_INTEL_ICH9_3       0x2913
 #define PCI_DEVICE_ID_INTEL_ICH9_4       0x2914
 #define PCI_DEVICE_ID_INTEL_ICH9_5       0x2919
-#define PCI_DEVICE_ID_INTEL_ICH9_6       0x2930
+#define PCI_DEVICE_ID_INTEL_ICH9_6       0x51a3 // Type: System Device | Category: SMBus Controller | PCI Class: 0x0c05 | hw/i2c/smbus_ich9.c
 #define PCI_DEVICE_ID_INTEL_ICH9_7       0x2916
-#define PCI_DEVICE_ID_INTEL_ICH9_8       0x2918
+#define PCI_DEVICE_ID_INTEL_ICH9_8       0x5182 // Type: Bridge Device | Category: LPC Controller   | PCI Class: 0x0601 | hw/isa/lpc_ich9.c
 
 #define PCI_DEVICE_ID_INTEL_82801I_UHCI1 0x2934
 #define PCI_DEVICE_ID_INTEL_82801I_UHCI2 0x2935
@@ -273,7 +275,7 @@
 #define PCI_DEVICE_ID_INTEL_82801I_EHCI2 0x293c
 #define PCI_DEVICE_ID_INTEL_82599_SFP_VF 0x10ed
 
-#define PCI_DEVICE_ID_INTEL_P35_MCH      0x29c0
+#define PCI_DEVICE_ID_INTEL_P35_MCH      0x4641 // Type: Bridge Device | Category: Host Bridge | PCI Class: 0x0600 | hw/pci-host/q35.c
 
 #define PCI_VENDOR_ID_XEN                0x5853
 #define PCI_DEVICE_ID_XEN_PLATFORM       0x0001
diff --git a/include/standard-headers/linux/qemu_fw_cfg.h b/include/standard-headers/linux/qemu_fw_cfg.h
index cb93f66..fe34590 100644
--- a/include/standard-headers/linux/qemu_fw_cfg.h
+++ b/include/standard-headers/linux/qemu_fw_cfg.h
@@ -4,7 +4,7 @@
 
 #include "standard-headers/linux/types.h"
 
-#define FW_CFG_ACPI_DEVICE_ID	"QEMU0002"
+#define FW_CFG_ACPI_DEVICE_ID	"UEFI0002"
 
 /* selector key values for "well-known" fw_cfg entries */
 #define FW_CFG_SIGNATURE	0x00
@@ -71,7 +71,7 @@ struct fw_cfg_file {
 #define FW_CFG_DMA_CTL_SELECT	0x08
 #define FW_CFG_DMA_CTL_WRITE	0x10
 
-#define FW_CFG_DMA_SIGNATURE    0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE    0x51434f4d20434647ULL /* "QCOM CFG" */
 
 /* Control as first field allows for different structures selected by this
  * field, which might be useful in the future
diff --git a/pc-bios/optionrom/optionrom.h b/pc-bios/optionrom/optionrom.h
index 7bcdf0e..02dd06e 100644
--- a/pc-bios/optionrom/optionrom.h
+++ b/pc-bios/optionrom/optionrom.h
@@ -43,7 +43,7 @@
 #define FW_CFG_DMA_CTL_SELECT  0x08
 #define FW_CFG_DMA_CTL_WRITE   0x10
 
-#define FW_CFG_DMA_SIGNATURE 0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE 0x51434f4d20434647ULL /* "QCOM CFG" */
 
 #define BIOS_CFG_DMA_ADDR_HIGH  0x514
 #define BIOS_CFG_DMA_ADDR_LOW   0x518
diff --git a/target/i386/kvm/kvm-cpu.c b/target/i386/kvm/kvm-cpu.c
index 9c25b55..af64a32 100644
--- a/target/i386/kvm/kvm-cpu.c
+++ b/target/i386/kvm/kvm-cpu.c
@@ -174,12 +174,12 @@ static void kvm_cpu_xsave_init(void)
  *       docs/system/target-i386.rst)
  */
 static PropValue kvm_default_props[] = {
-    { "kvmclock", "on" },
-    { "kvm-nopiodelay", "on" },
-    { "kvm-asyncpf", "on" },
-    { "kvm-steal-time", "on" },
-    { "kvm-pv-eoi", "on" },
-    { "kvmclock-stable-bit", "on" },
+    { "kvmclock", "off" },
+    { "kvm-nopiodelay", "off" },
+    { "kvm-asyncpf", "off" },
+    { "kvm-steal-time", "off" },
+    { "kvm-pv-eoi", "off" },
+    { "kvmclock-stable-bit", "off" },
     { "x2apic", "on" },
     { "kvm-msi-ext-dest-id", "off" },
     { "acpi", "off" },

```

`patches/QEMU/fake_battery.dsl`:

```dsl
/*
 * Intel ACPI Component Architecture
 * AML/ASL+ Disassembler version 20240927 (64-bit version)
 * Copyright (c) 2000 - 2023 Intel Corporation
 * 
 * Disassembling to symbolic ASL+ operators
 *
 * Disassembly of SSDT1.aml
 *
 * Original Table Header:
 *     Signature        "SSDT"
 *     Length           0x000000A1 (161)
 *     Revision         0x01
 *     Checksum         0x80
 *     OEM ID           "BOCHS"
 *     OEM Table ID     "BXPCSSDT"
 *     OEM Revision     0x00000001 (1)
 *     Compiler ID      "INTL"
 *     Compiler Version 0x20240927 (539232551)
 */
 DefinitionBlock ("", "SSDT", 1, "BOCHS", "BXPCSSDT", 0x00000001)
 {
     External (_SB_.PCI0, DeviceObj)
 
     Scope (_SB.PCI0)
     {
         Device (BAT0)
         {
             Name (_HID, EisaId ("PNP0C0A") /* Control Method Battery */)  // _HID: Hardware ID
             Name (_UID, Zero)  // _UID: Unique ID
             Method (_STA, 0, NotSerialized)  // _STA: Status
             {
                 Return (0x1F)
             }
 
             Method (_BIF, 0, NotSerialized)  // _BIF: Battery Information
             {
                 Return (Package (0x0D)
                 {
                     One, 
                     0x1770, 
                     0x1770, 
                     One, 
                     0x39D0, 
                     0x0258, 
                     0x012C, 
                     0x3C, 
                     0x3C, 
                     "", 
                     "", 
                     "LION", 
                     ""
                 })
             }
 
             Method (_BST, 0, NotSerialized)  // _BST: Battery Status
             {
                 Return (Package (0x04)
                 {
                     Zero, 
                     Zero, 
                     0x1770, 
                     0x39D0
                 })
             }
         }
     }
 }

```

`patches/QEMU/spoofed_devices.dsl`:

```dsl
/*
 * Intel ACPI Component Architecture
 * AML/ASL+ Disassembler version 20240927 (64-bit version)
 * Copyright (c) 2000 - 2023 Intel Corporation
 * 
 * Disassembling to symbolic ASL+ operators
 *
 * Disassembly of CUSTOM.aml
 *
 * Original Table Header:
 *     Signature        "SSDT"
 *     Length           0x00000255 (597)
 *     Revision         0x01
 *     Checksum         0xC4
 *     OEM ID           "_ASUS_"
 *     OEM Table ID     "Notebook"
 *     OEM Revision     0x00000001 (1)
 *     Compiler ID      "INTL"
 *     Compiler Version 0x20240927 (539232551)
 */
DefinitionBlock ("", "SSDT", 1, "_ASUS_", "Notebook", 0x20250321)
{
    External (_SB_.PCI0, DeviceObj)

    Scope (_SB)
    {
        Device (PWRB)
        {
            Name (_HID, EisaId ("PNP0C0C") /* Power Button Device */)  // _HID: Hardware ID
            Method (_STA, 0, NotSerialized)  // _STA: Status
            {
                Return (0x0B)
            }
        }

        Device (SLPB)
        {
            Name (_HID, EisaId ("PNP0C0E") /* Sleep Button Device */)  // _HID: Hardware ID
            Name (_STA, 0x0B)  // _STA: Status
        }

        Device (ACAD)
        {
            Name (_HID, "ACPI0003" /* Power Source Device */)  // _HID: Hardware ID
            Name (_PCL, Package (0x01)  // _PCL: Power Consumer List
            {
                _SB
            })
            Name (ACP, Ones)
            Method (_PSR, 0, NotSerialized)  // _PSR: Power Source
            {
                Return (One)
            }

            Method (_STA, 0, NotSerialized)  // _STA: Status
            {
                Return (0x0F)
            }
        }

        Device (PIT0)
        {
            Name (_HID, "PNP0000")
            Method (_STA, 0, NotSerialized)
            {
                Return (0x0F)
            }
            Name (_CRS, ResourceTemplate()
            {
            })
        }

        Device (TIMR)
        {
            Name (_HID, "PNP0100")
            Method (_STA, 0, NotSerialized)
            {
                Return (0x0F)
            }
            Name (_CRS, ResourceTemplate()
            {
            })
        }
    }

    Scope (_SB.PCI0)
    {
        Device (EC0)
        {
            Name (_HID, EisaId ("PNP0C09") /* Embedded Controller Device */)  // _HID: Hardware ID
            Name (_CRS, ResourceTemplate ()  // _CRS: Current Resource Settings
            {
                IO (Decode16,
                    0x0062,             // Range Minimum
                    0x0062,             // Range Maximum
                    0x00,               // Alignment
                    0x01,               // Length
                    )
                IO (Decode16,
                    0x0066,             // Range Minimum
                    0x0066,             // Range Maximum
                    0x00,               // Alignment
                    0x01,               // Length
                    )
            })
            Name (_GPE, Zero)  // _GPE: General Purpose Events
            OperationRegion (EC0, EmbeddedControl, Zero, 0xFF)
            Field (EC0, ByteAcc, Lock, Preserve)
            {
                MODE,   1, 
                FAN,    1, 
                Offset (0x01), 
                TMP,    16, 
                AC0,    16, 
                Offset (0x07), 
                PSV,    16, 
                CRT,    16
            }

            Method (_Q07, 0, NotSerialized)  // _Qxx: EC Query, xx=0x00-0xFF
            {
            }

            PowerResource (PFAN, 0x00, 0x0000)
            {
                Method (_STA, 0, NotSerialized)  // _STA: Status
                {
                    Return (0x0F)
                }

                Method (_ON, 0, NotSerialized)  // _ON_: Power On
                {
                }

                Method (_OFF, 0, NotSerialized)  // _OFF: Power Off
                {
                }
            }

            Device (FAN0)
            {
                Name (_HID, EisaId ("PNP0C0B") /* Fan (Thermal Solution) */)  // _HID: Hardware ID
                Name (_PR0, Package (0x01)  // _PR0: Power Resources for D0
                {
                    PFAN
                })
            }

            ThermalZone (TZ0)
            {
                Method (_TMP, 0, NotSerialized)  // _TMP: Temperature
                {
                    Return (0x1770)
                }

                Method (_AC0, 0, NotSerialized)  // _ACx: Active Cooling, x=0-9
                {
                    Return (0x1770)
                }

                Method (_PSV, 0, NotSerialized)  // _PSV: Passive Temperature
                {
                    Return (0x1670)
                }

                Method (_HOT, 0, NotSerialized)  // _HOT: Hot Temperature
                {
                    Return (0x1780)
                }

                Method (_CRT, 0, NotSerialized)  // _CRT: Critical Temperature
                {
                    Return (0x1780)
                }

                Method (_SCP, 1, NotSerialized)  // _SCP: Set Cooling Policy
                {
                }

                Name (_TC1, 0x04)  // _TC1: Thermal Constant 1
                Name (_TC2, 0x03)  // _TC2: Thermal Constant 2
                Name (_TSP, 0x96)  // _TSP: Thermal Sampling Period
                Name (_TZP, Zero)  // _TZP: Thermal Zone Polling
                Name (_STR, Unicode ("System thermal zone"))  // _STR: Description String
            }
        }
    }
}


```

`patches/README.md`:

```md
## ðŸ“– Manual Development

<details>
<summary>Expand for more...</summary>

## QEMU

#### Clone repo
```
git clone --depth=1 --branch "v10.2.0" "https://gitlab.com/qemu-project/qemu.git"
```

#### Git diff patched repo
```
git diff HEAD > "qemu-10.2.0.patch"
```

#### Patch repo
```
git apply < "qemu-10.2.0.patch"
```

## EDK2

#### Clone repo
```
git clone --depth=1 --branch "edk2-stable202511" "https://github.com/tianocore/edk2.git"
```

#### Git diff patched repo
```
git diff HEAD > "edk2-stable202511.patch"
```

#### Patch repo
```
git apply < "edk2-stable202511.patch"
```

```

`resources/README.md`:

```md
## ðŸ› ï¸ Common Troubleshooting

<details>
<summary>Expand for details...</summary>

- Windows 11 BSOD - USBXHCI.sys
  - Switch from USB3 to USB2 in VMM/XML

- Windows 10/11 w/Secure Boot BSOD after 5-30 mins from boot
  - Increase pagefile size inside Windows

- Dumping host's SMBIOS for QEMU passthrough
  - First try:
  ```
  sudo cat /sys/firmware/dmi/tables/{smbios_entry_point,DMI} > smbios.bin
  ```
  - Then try (if QEMU doesn't accept):
  ```
  sudo cat /sys/firmware/dmi/tables/DMI > smbios.bin
  ```

- Fix Ryzen 7000/9000 iGPUs "No Signal/Black Screen/flickering" when attempting to display the DM
Add the arg below to your kernel options config:
```
amdgpu.sg_display=0
```
- https://www.kernel.org/doc/html/latest/gpu/amdgpu/module-parameters.html
  - sg_display (int)
    - Disable S/G (scatter/gather) display (i.e., display from system memory). This option is only relevant on APUs. Set this option to 0 to disable S/G display if you experience flickering or other issues under memory pressure and report the issue.

</details>





---





## ðŸ“ Documentation & References

<details>
<summary>Expand for details...</summary>

- **Official**
  - [QEMUâ€™s documentation](https://www.qemu.org/docs/master/)
    - [Man Page (Args)](https://www.qemu.org/docs/master/system/qemu-manpage.html)
    - [Hyper-V Enlightenments](https://www.qemu.org/docs/master/system/i386/hyperv.html)
  - [KVM for x86 systems (Linux Kernel)](https://www.kernel.org/doc/html/next/virt/kvm/x86/index.html)
  - [Domain XML format](https://libvirt.org/formatdomain.html)
  - [ACPI System Management Bus Interface Specification - HTML](https://uefi.org/specs/ACPI/6.6/13_System_Mgmt_Bus_Interface_Specification.html) - [PDF Version](https://uefi.org/sites/default/files/resources/ACPI_Spec_6.6.pdf)
  - [SMBIOS Reference Specification - PDF](https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.9.0.pdf)
  - [PCILookup](https://www.pcilookup.com/)
- **General**
  - [https://evasions.checkpoint.com/](https://evasions.checkpoint.com/)
  - [https://r0ttenbeef.github.io/](https://r0ttenbeef.github.io/Deploy-Hidden-Virtual-Machine-For-VMProtections-Evasion-And-Dynamic-Analysis/)
  - [https://secret.club/](https://secret.club/)
    - [how-anti-cheats-detect-system-emulation.html](https://secret.club/2020/04/13/how-anti-cheats-detect-system-emulation.html)
    - [battleye-hypervisor-detection.html](https://secret.club/2020/01/12/battleye-hypervisor-detection.html)
- **Reddit**
  - [spoof_and_make_your_vm_undetectable_no_more](https://www.reddit.com/r/VFIO/comments/i071qx/spoof_and_make_your_vm_undetectable_no_more/)
  - [be_is_banning_kvm_on_r6](https://www.reddit.com/r/VFIO/comments/hts1o1/be_is_banning_kvm_on_r6/)
- **Unknowncheats**
  - [418885-kvm-detection-fixes.html](https://www.unknowncheats.me/forum/escape-from-tarkov/418885-kvm-detection-fixes.html) 
- **Git Repos**
  - [pve-patch](https://github.com/Distance10086/pve-patch)
  - [pve-anti-detection](https://github.com/lixiaoliu666/pve-anti-detection)
  - [proxmox-ve-anti-detection](https://github.com/zhaodice/proxmox-ve-anti-detection)
  - [kvm-hidden](https://gitlab.com/DonnerPartyOf1/kvm-hidden)
  - [KVM-Spoofing](https://github.com/A1exxander/KVM-Spoofing)
  - [linux-5.15-hardened-kvm-svm-qemu-win10](https://alt.deliktas.de/git/adeliktas/linux-5.15-hardened-kvm-svm-qemu-win10)
  - [sGPUpt](https://github.com/MaxxRK/sGPUpt)
  - [gpupt](https://github.com/pragmagrid/gpupt)

</details>





---





## ðŸ’¾ Software
<details>
<summary>Software Assessments</summary>

## Hypervisor Analysis

| â­ Rating | ðŸ’» Software | ðŸ§ª System Test | âœ… Bypassed |
|:------:|:--------:|:-----------:|:--------:|
| ðŸ¥‡ | VMAware | [Repository Link](https://github.com/kernelwernel/VMAware) <br> [â¬‡ Download - x64 - v2.6.0 â¬‡](https://github.com/kernelwernel/VMAware/releases/download/v2.6.0/vmaware_2.6.0.exe) <br> [â¬‡ Download - x32 - v2.6.0 â¬‡](https://github.com/kernelwernel/VMAware/releases/download/v2.6.0/vmaware32_2.6.0.exe) <br> [â¬‡ Download - DEBUG - v2.6.0 â¬‡](https://github.com/kernelwernel/VMAware/releases/download/v2.6.0/vmaware_debug_2.6.0.exe) | âŒ |
| ðŸ¥ˆ | Al-Khaser (Obsolete) | [Repository Link](https://github.com/LordNoteworthy/al-khaser) <br> [â¬‡ Download - x64 - v1.0.0 â¬‡](https://github.com/ayoubfaouzi/al-khaser/releases/download/v1.0.0/al-khaser_x64.7z) <br> [â¬‡ Download - x32 - v1.0.0 â¬‡](https://github.com/ayoubfaouzi/al-khaser/releases/download/v1.0.0/al-khaser_x86.7z) | âœ… |
| ðŸ¥‰ | Pafish (Obsolete) | [Repository Link](https://github.com/a0rtega/pafish) <br> [â¬‡ Download - x64 - v0.6 â¬‡](https://github.com/a0rtega/pafish/releases/download/v0.6/pafish64.exe) <br> [â¬‡ Download - x32 - v0.6 â¬‡](https://github.com/a0rtega/pafish/releases/download/v0.6/pafish.exe) | âœ… |

## Exam/Test

| ðŸ’» Software | ðŸŒ Browser Extension | ðŸ§ª System Test | â¬‡ï¸ Download | âœ… Bypassed |
|:-----------:|:--------------------:|:--------------:|:-----------:|:------------:|
| Respondus (LockDown Browser) | âœ… | [System Test](https://autolaunch.respondus2.com/MONServer/ldb/preview_launch.do) | [â¬‡ Download â¬‡](https://download.respondus.com/lockdown/download.php) | âœ… |
| ProctorU | âœ… |  | â€¢ [â¬‡ Firefox â¬‡](https://s3-us-west-2.amazonaws.com/proctoru-assets/extension/firefox-extension-latest.xpi) <br> â€¢ [â¬‡ Chrome â¬‡](https://chrome.google.com/webstore/detail/proctoru/goobgennebinldhonaajgafidboenlkl) | âœ… |
| ProctorU: Guardian Browser |  | [System Test](https://go.proctoru.com/testitout) | â€¢ [â¬‡ Download â¬‡](https://production-archimedes-secure-browser-artifacts.s3.amazonaws.com/latest/windows/guardian-browser-x64.exe) <br> â€¢ [Meazure Learning Page](https://guardian.meazurelearning.com/) <br> â€¢ [ProctorU Page](https://go.proctoru.com/testitout) | âœ… |
| Proctorio | âœ… | [System Test](https://getproctorio.com/) |  | âœ… |
| Prometric: ProProctor |  | [System Test](https://rpcandidate.prometric.com/) |  | âœ… |
| Honorlock | âœ… |  | â€¢ [Honorlock](https://app.honorlock.com/install/extension) <br> â€¢ [â¬‡ Chrome â¬‡](https://chromewebstore.google.com/detail/honorlock/hnbmpkmhjackfpkpcbapafmpepgmmddc) | âœ… |
| Pearson VUE |  | â€¢ [System Test](https://system-test.onvue.com/system_test?customer=pearson_vue) <br> â€¢ [System Test](https://vueop.startpractice.com/) |  | âœ… |
| ExamSoft: Examplify |  |  | [â¬‡ Download â¬‡](https://releases.examsoft.com/Examplify/Examplify_LATEST_win.exe) | âœ… |
| Examity | âœ… | [System Test](https://on.v5.examity.com/systemcheck) | â€¢ [â¬‡ Firefox â¬‡](https://addons.mozilla.org/en-US/firefox/addon/examity/) <br> â€¢ [â¬‡ Chrome â¬‡](https://chromewebstore.google.com/detail/geapelpefnpekodnnlkcaadniodlgebj) | âœ… |
| Safe Exam Browser |  | [System Test](https://demo.safeexambrowser.org/exams/) | [â¬‡ Download â¬‡](https://github.com/SafeExamBrowser/seb-win-refactoring/releases) | âœ… |
| ETS Online Test (CLEP) |  |  | [â¬‡ Download â¬‡](https://www.ets.org/browserinstall) | âœ… |
| Bluebook |  |  | [â¬‡ Download â¬‡](https://bluebook.app.collegeboard.org/) | âœ… |
| Inspera Exam Portal |  | [Demo Exam Instructions](https://www.ltu.se/en/student-web/your-studies/examination/digital-exam-inspera/instructions-for-pc-and-mac-when-downloading-the-inspera-exam-portal) | [â¬‡ Download â¬‡](https://ltu.inspera.com/get-iep) | âœ… |
| Kryterion |  | [System Test](https://www.kryterion.com/systemcheck/) | [â¬‡ Download â¬‡](https://media.webassessor.com/respondus/windows/labedition/Respondus_LockDown_Browser_Lab_OEM.msi) | âœ… |

## Anti-Cheats

- [areweanticheatyet](https://areweanticheatyet.com/)

| ðŸŽ® Game | ðŸ›¡ï¸ Engine | âœ… Bypassed |
|:------:|:--------:|:--------:|
| Fortnite | Easy Anti-Cheat (EAC) | âœ… |
| Call of Duty (Warzone / MW Series) | RICOCHET | âœ… |
| Roblox | Hyperion | âœ… |
| Valorant / League of Legends | Vanguard | âœ… ([Hyper-V](https://learn.microsoft.com/en-us/windows-server/virtualization/hyper-v/overview) + [HVCI](https://learn.microsoft.com/en-us/windows/security/hardware-security/enable-virtualization-based-protection-of-code-integrity)) |
| PUBG: Battlegrounds | Gepard Shield | âœ… |
| Genshin Impact | Mhyprot | â” (HoYoKProtect.sys) <br> ðŸªŸ [BSOD: ATTEMPTED_WRITE_TO_READONLY_MEMORY](https://github.com/Scrut1ny/Hypervisor-Phantom/issues/34) |
| Battlefieldâ„¢ 2042 | EA anticheat (EAAC) | âœ… |
| Marvel Rivals | NACE (Netease Anticheat Expert) | âœ… |
| Various Desktop Games | Easy Anti-Cheat (EAC) | âœ… |
| Various Desktop Games | nProtect GameGuard (NP) | âœ… |
| Various Desktop Games | BattlEye (BE) | âœ… Add `    <feature policy="disable" name="aes"/>` to XML |
| Various Mobile Games | Anti-Cheat Expert (ACE) | âœ… |

</details>





<details>
<summary>Virtual Audio & Video (AV)</summary>

## Video
- Display
  - [LookingGlass](https://github.com/gnif/LookingGlass)
    - [Virtual-Display-Driver](https://github.com/itsmikethetech/Virtual-Display-Driver)
  - [memflow-mirror](https://github.com/ko1N/memflow-mirror)
  - [Sunshine](https://github.com/LizardByte/Sunshine)
  - [Moonlight](https://github.com/moonlight-stream/moonlight-qt)
- Streaming (WHIP/WHEP)
  - [meshcast.io](https://meshcast.io/)
  - [VDO.Ninja](https://vdo.ninja/)
- Webcam Manipulation
  - [Deep-Live-Cam](https://github.com/hacksider/Deep-Live-Cam)

## Audio
- [VB-AUDIO](https://vb-audio.com/Cable/index.htm)

</details>









<details>
<summary>VPN + Hypervisor</summary>

- ***IMPORTANT***: Ensure not to add a custom DNS configuration to the guest system on the hypervisor if your host system's VPN uses custom DNS block lists. Doing so may result in your guest hypervisor system losing its internet connection!

## Mullvad VPN + QEMU
- For the VPN connection to get properly natted/bridged you must enable the setting `Local network sharing` option!
    - How to: `âš™ï¸` > `VPN settings` > `Local network sharing` âœ…

![image](https://github.com/user-attachments/assets/18ba68b4-31ea-4c5e-9ad1-66417001820f)
![image](https://github.com/user-attachments/assets/36465501-13fa-469b-bb66-f3db6003a64e)
![image](https://github.com/user-attachments/assets/77890671-d024-491a-8d33-cb38e3503ef4)
![image](https://github.com/user-attachments/assets/126e06bd-23c0-4cb9-9bfe-5a55fe6689ab)

</details>







<details>
<summary>Recommended Tools</summary>

- OCR Powered Screen-Capture Tools
    - Linux:
        - [NormCap](https://github.com/dynobo/normcap)
    - Windows:
        - [ShareX](https://github.com/ShareX/ShareX)
- RAT (Remote Access/Administration Trojan)
    - [Quasar](https://github.com/quasar/Quasar)
        - [Resource Hacker](https://www.angusj.com/resourcehacker/)
- Monitor EDID Modifiers
  - EEPROM EDID (Hardware)
    - [Monitor Tests](https://www.monitortests.com/)
      - [EDID/DisplayID Writer](https://www.monitortests.com/forum/Thread-EDID-DisplayID-Writer)
  - Windows INF override registry EDID (Software)
    - [Monitor Tests](https://www.monitortests.com/)
      - [Custom Resolution Utility (CRU)](https://www.monitortests.com/forum/Thread-Custom-Resolution-Utility-CRU)
    - [Monitor Asset Manager](https://www.entechtaiwan.com/util/moninfo.shtm)
- UEFI/BIOS Editors
    - [Phoenix BIOS Editor](https://theretroweb.com/drivers/208)
    - [UEFITool](https://github.com/LongSoft/UEFITool)

</details>





---





## ðŸ”© Hardware

<details>
<summary>Bypassing HDCP</summary>

#### HDCP (High-bandwidth Digital Content Protection) Stuff
- [Wikipedia - HDCP](https://en.wikipedia.org/wiki/High-bandwidth_Digital_Content_Protection)
- [NVIDIA - To verify if your system is HDCP-capable](https://www.nvidia.com/content/Control-Panel-Help/vLatest/en-us/mergedProjects/Display/To_verify_if_your_system_is_HDCP-capable.htm)

## Bypassing HDCP Hardware/Software Diagram:
![bypass](https://github.com/Scrut1ny/Hypervisor-Phantom/assets/53458032/589b0f88-f14b-44d8-bf1c-225df4d01e54)

## Bypass Kits

#### Expensive Bypass Kit (Recommended):
- 1x2 HDMI Splitter <> [U9/ViewHD - VHD-1X2MN3D](https://www.amazon.com/dp/B086JKRSW1) - `~$18.00`
- EDID Emulator <> [4K-EWB - HDMI 2.1 4K EDID Emulator](https://www.amazon.com/dp/B0DB7YDFD6) - `~$25.00`
- USB HDMI Capture Card <> [Elgato HD60 X](https://www.amazon.com/dp/B09V1KJ3J4) - `~$160.00`

#### Cheap Bypass Kit (Not recommended):
- 1x2 HDMI Splitter <> [OREI](https://www.amazon.com/dp/B005HXFARS) - `~$13.00`
- EDID Emulator <> [EVanlak](https://www.amazon.com/dp/B07YMTKJCR) - `~$7.00`
- USB HDMI Capture Card <> [AXHDCAP](https://www.amazon.com/dp/B0C2MDTY8P) - `~$9.00`

## Equipment List
- External USB Capture Card(s)
    - Elgato
        - [HD60 X | 10GBE9901](https://www.amazon.com/dp/B09V1KJ3J4) - `~$140.00`
        - [4K X | 20GBH9901](https://www.amazon.com/dp/B0CPFWXMBL) - `~$200.00`
        - [Game Capture Neo | 20GBI9901](https://www.amazon.com/dp/B0CVYKQNFH) - `~$110.00`
        - [Cam Link](https://www.amazon.com/dp/B07K3FN5MR) - `~$90.00`
    - [AXHDCAP 4K HDMI Video Capture Card](https://www.amazon.com/dp/B0C2MDTY8P) - `~$9.98`
- 1x2 HDMI Splitter(s)
    - [U9 / ViewHD](https://u9ltd.myshopify.com/collections/splitter)
        - [VHD-1X2MN3D](https://www.amazon.com/dp/B004F9LVXC) - `~$22.00`
        - [VHD-1X2MN3D](https://www.amazon.com/dp/B086JKRSW1) - `~$18.00`
    - HBAVLINK
        - [HB-SP102B](https://www.amazon.com/dp/B08T62MKH1)
        - [HB-SP102C](https://www.amazon.com/dp/B08T64JWWT)
    - CORSAHD
        - [CO-SP12H2](https://www.amazon.com/dp/B0CLL5GQXT)
        - [?????????](https://www.amazon.com/dp/B0CXHQNSWM)
    - EZCOO
        - [EZ-SP12H2](https://www.amazon.com/dp/B07VP37KMB)
        - [EZ-EX11HAS-PRO](https://www.amazon.com/dp/B07TZRXKYG)
- EDID Emulator(s)
    - HDMI
        - Brand: THWT
            - [4K-EW2 - HDMI 2.1 4K EDID Emulator PRO](https://www.amazon.com/dp/B0DB65Y6VL) - `~$90.00`
            - [4K-EWB - HDMI 2.1 4K EDID Emulator](https://www.amazon.com/dp/B0DB7YDFD6) - `~$25.00`
            - [HD-EW2 - HDMI 2.0 EDID Emulator 4K PRO](https://www.amazon.com/dp/B0C32ZWBR6) - `~$90.00`
            - [HD-EWB - HDMI 2.0 4K EDID Emulator](https://www.amazon.com/dp/B0CRRWQ7XS) - `~$20.00`
    - DP
        - Brand: THWT
            - [DPH-EW2 - Displayport 1.2 EDID Emulator 4K PRO](https://www.amazon.com/dp/B0C32NJ2NF) - `~$90.00`
    - DP to HDMI
        - Brand: THWT
            - [DPH-EWB - Displayport 1.2 to HDMI 2.0 EDID Emulator](https://www.amazon.com/dp/B0C3H763FG) - `~$20.00`

</details>







<details>
<summary>Elgato Capture Cards</summary>

- Some of Elgato's capture cards, leveraging UVC (USB Video Class) technology, operate seamlessly without requiring additional drivers. As UVC devices, they adhere to a standard protocol for transmitting video and audio data over USB connections. This plug-and-play functionality ensures compatibility with various operating systems, enabling effortless setup and use for capturing high-quality video content.

## UVC Elgato Capture Cards

- [Article](https://help.elgato.com/hc/en-us/articles/360027961152-Elgato-Gaming-Hardware-Drivers)

| Device                      | Driver Status                     |
|-----------------------------|-----------------------------------|
| Elgato Cam Link             | No driver since it's a UVC device |
| Elgato Cam Link 4K          | No driver since it's a UVC device |
| Elgato Game Capture HD60 S+ | No driver since it's a UVC device |
| Elgato Game Capture HD60 X  | No driver since it's a UVC device |
| Game Capture 4K X           | No driver since it's a UVC device |
| Game Capture Neo            | No driver since it's a UVC device |

## Linux - OBS Black Screen Issue Solution

##### Step 1:
Download and Install the latest `4K CAPTURE UTILITY` software from [Elgato downloads page](https://www.elgato.com/us/en/s/downloads) on a `WINDOWS OS`.

#### Step 2:
Open `Elgato 4K Capture Utility` and let the software initialize the UVC capture card.

#### Step 3:
Select the settings icon on the top right corner of the software utility, and select `Check for Updates...`. (It should update automatically already, but just make sure the firmware is on the latest version available.)

#### Step 4:
Now, connect the capture card device back to your Linux host system now and open OBS, you should now see an output from your GPU instead of a black screen.

</details>






<details>
<summary>IÂ²C EEPROM</summary>

- EEPROM (**E**lectrically **E**rasable **P**rogrammable **R**ead-**O**nly **M**emory)

## EDID (**E**xtended **D**isplay **I**dentification **D**ata)
- [EDID structure, version 1.4](https://en.wikipedia.org/wiki/Extended_Display_Identification_Data#Structure,_version_1.4)
  - Bytes 12â€“15: Serial number. 32 bits, little-endian.

- [EDID Analysis & Generation Tool](https://edidcraft.com/)

</details>

```

`resources/scripts/Linux/OnVUE-Gen.sh`:

```sh
#!/bin/bash

# Fetch effective URL after redirects
new_url=$(curl -sLo /dev/null -w '%{url_effective}' -A 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36' 'https://system-test.onvue.com/system_test?customer=pearson_vue')

# Extract query parameters
access_code=${new_url##*access_code=}; access_code=${access_code%%&*}
session_id=${new_url##*session_id=}; session_id=${session_id%%&*}

# Output results
clear
cat <<EOF

=====# Pearson | VUE: System Test - Exam Generator #=====

# Download Page: $(printf '\033[94m%s\033[0m' "$new_url")
# Live Exam: $(printf '\033[94m%s\033[0m' "https://candidatelaunchst.onvue.com/delivery?session_id=${session_id}&access_code=${access_code}&locale=en-US&token=undefined")

# Shortcut: $(printf '\033[94mhttps://vueop.startpractice.com\033[0m')

EOF

```

`resources/scripts/Linux/arch_kernel_downgrade.sh`:

```sh
#!/bin/bash

wget https://archive.archlinux.org/packages/l/linux/linux-6.10.arch1-2-x86_64.pkg.tar.zst
wget https://archive.archlinux.org/packages/l/linux-headers/linux-headers-6.10.arch1-2-x86_64.pkg.tar.zst

sudo pacman -U linux-6.10.arch1-2-x86_64.pkg.tar.zst linux-headers-6.10.arch1-2-x86_64.pkg.tar.zst

sudo sed -i '/^#\[options\]/a IgnorePkg = linux linux-headers' /etc/pacman.conf

sudo mkinitcpio -P

sudo reboot now

```

`resources/scripts/Linux/evdev-auto.sh`:

```sh
#!/bin/bash

# https://libvirt.org/formatdomain.html#input-devices
# https://wiki.archlinux.org/title/PCI_passthrough_via_OVMF#Passing_keyboard/mouse_via_Evdev

# Keyboards: grab="all" grabToggle="shift-shift" repeat="on"
# Mice/Trackpads: grabToggle="shift-shift"
# evdev attributes: grab (all), repeat (on/off), grabToggle (ctrl-ctrl, alt-alt, shift-shift, meta-meta, scrolllock, ctrl-scrolllock)

grab_toggle="shift-shift"

shopt -s nullglob
declare -A seen_devices

for dev in /dev/input/by-{id,path}/*-event-{kbd,mouse}; do
  # Deduplicate by real path
  real_dev=$(readlink -f "$dev") || continue
  [[ -n "${seen_devices[$real_dev]}" ]] && continue
  seen_devices["$real_dev"]=1

  # Keyboard specific config
  extra_attrs=""
  [[ "$dev" == *"-event-kbd" ]] && extra_attrs=' grab="all" repeat="on"'

  printf '    <input type="evdev">\n      <source dev="%s" grabToggle="%s"%s/>\n    </input>\n' \
    "$dev" "$grab_toggle" "$extra_attrs"
done

```

`resources/scripts/Linux/msr_check.py`:

```py
import os, struct, sys

RANGES = [
    (0x40000000, 0x400000FF, "Hyper-V Synthetic"),
    (0x4B564D00, 0x4B564DFF, "KVM-specific"),
]

RED, RESET = "\033[91m", "\033[0m"

if os.geteuid() != 0: sys.exit("UID!=0")

try:
    fd = os.open("/dev/cpu/0/msr", os.O_RDONLY)

    for start, end, label in RANGES:
        print(f"Scanning MSR range: {hex(start)} - {hex(end)} [{label}]")
        for msr in range(start, end + 1):
            try:
                os.lseek(fd, msr, os.SEEK_SET)
                val = struct.unpack('Q', os.read(fd, 8))[0]
                print(f"{RED}[!] DETECTED: {hex(msr)} = {hex(val)}{RESET}")
            except OSError: continue

    os.close(fd)
except Exception as e:
    sys.exit(f"Err: {e}")

```

`resources/scripts/Linux/smbios_spoofer_cli.py`:

```py
#!/usr/bin/env python3
from pathlib import Path

def get_bytes(path):
    try: return Path(path).read_bytes()
    except OSError: return b""

# 1. Table concatenation
data = get_bytes("/sys/firmware/dmi/tables/smbios_entry_point") + get_bytes("/sys/firmware/dmi/tables/DMI")

# 2. Overwrite UUID bytes with 0xFF
if (u_txt := get_bytes("/sys/class/dmi/id/product_uuid").strip()):
    b = bytes.fromhex(u_txt.decode().replace("-", ""))
    data = data.replace(b[3::-1] + b[5:3:-1] + b[7:5:-1] + b[8:], b"\xFF" * 16)

# 3. Overwrite serial number strings with 0x00
for name in ("product_serial", "board_serial", "chassis_serial"):
    if val := get_bytes(f"/sys/class/dmi/id/{name}").strip():
        data = data.replace(val, b"To be filled by O.E.M.")

for p in Path("/sys/firmware/dmi/entries/").glob("17-*/raw"):
    for s in get_bytes(p)[2:].split(b'\x00'):
        if len(s) == 8 and s.isalnum() and not s.isalpha() and not s.isdigit():
            data = data.replace(s.lower(), b"00000000").replace(s.upper(), b"00000000")

if data:
    Path("smbios.bin").write_bytes(data)

```

`resources/scripts/Linux/vbios-dumper.sh`:

```sh
BDF="0000:01:00.0"
DEV="/sys/bus/pci/devices/$BDF"
OUT="./VBIOS_${BDF}.rom"

# Identify current driver (save it before unbinding)
DRIVER_PATH="$(readlink "$DEV/driver" 2>/dev/null || true)"
DRIVER_NAME="${DRIVER_PATH##*/}"

# Unbind only if a driver is currently bound
if [[ -n "$DRIVER_NAME" ]]; then
  echo "$BDF" | sudo tee "$DEV/driver/unbind" > /dev/null
fi

# Enable ROM read, dump, disable
echo 1 | sudo tee "$DEV/rom" > /dev/null
sudo cat "$DEV/rom" > "$OUT"
echo 0 | sudo tee "$DEV/rom" > /dev/null

# Rebind only if we had a driver
if [[ -n "$DRIVER_NAME" ]]; then
  echo "$BDF" | sudo tee "/sys/bus/pci/drivers/$DRIVER_NAME/bind" > /dev/null
fi

```

`resources/scripts/Windows/edid-spoofer.ps1`:

```ps1
$identity  = [Security.Principal.WindowsIdentity]::GetCurrent()
$principal = [Security.Principal.WindowsPrincipal]$identity

if (-not $principal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
    Write-Host "[!] Script must be run as Administrator." -ForegroundColor Red
    exit 1
}

# Get monitors via WMI for full EDID data
$wmiMonitors = Get-CimInstance -Namespace root\wmi -ClassName WmiMonitorDescriptorMethods

foreach ($wmiMon in $wmiMonitors) {
    # --- 1. Fetch Full EDID (Base + Extensions) ---
	try {
		$block0 = [byte[]](Invoke-CimMethod -InputObject $wmiMon -MethodName WmiGetMonitorRawEEdidV1Block -Arguments @{ BlockId = 0 }).BlockContent
		if (-not $block0) { continue }
	} catch { continue }

    # Initialize block list
    $edidBlocks = @(,$block0)

	# Fetch extension block if flagged (Byte 126)
	$extCount = $block0[126]
	for ($b = 1; $b -le $extCount; $b++) {
		try {
			$edidBlocks += ,([byte[]](Invoke-CimMethod -InputObject $wmiMon -MethodName WmiGetMonitorRawEEdidV1Block -Arguments @{ BlockId = $b }).BlockContent)
		} catch { }
	}

    # --- 2. Modify Base Block ---
    $targetBlock = $edidBlocks[0]

	# EDID[12â€“15]: Manufacturer-assigned ID Serial Number zeroed
    $targetBlock[12] = $targetBlock[13] = $targetBlock[14] = $targetBlock[15] = 0

	# EDID[54â€“125]: Display Descriptor Type 0xFF (Monitor Serial Number) zeroed (18-byte descriptors)
	foreach ($off in 54, 72, 90, 108) {
		if (
			$targetBlock[$off]     -eq 0x00 -and
			$targetBlock[$off + 1] -eq 0x00 -and
			$targetBlock[$off + 2] -eq 0x00 -and
			$targetBlock[$off + 3] -eq 0xFF
		) {
			[Array]::Clear($targetBlock, $off, 18)
		}
	}

	# EDID[127]: Checksum recomputed to satisfy (sum of bytes 0â€“127) % 256 = 0
	$sum = 0
	for ($i = 0; $i -lt 127; $i++) { $sum += $targetBlock[$i] }
	$targetBlock[127] = (-$sum) -band 0xFF

    # --- 3. Save to Registry ---
    $pnpId = $wmiMon.InstanceName -replace "_0$", ""
    $regPath = "HKLM:\SYSTEM\CurrentControlSet\Enum\$pnpId\Device Parameters"

    if (-not (Test-Path $regPath)) { continue }

    $overrideKeyPath = Join-Path -Path $regPath -ChildPath "EDID_OVERRIDE"

    if (-not (Test-Path -LiteralPath $overrideKeyPath)) {
        New-Item -Path $overrideKeyPath -Force | Out-Null
    }

    for ($i = 0; $i -lt $edidBlocks.Count; $i++) {
        Set-ItemProperty -LiteralPath $overrideKeyPath -Name $i.ToString() -Value $edidBlocks[$i] -Type Binary -Force
    }
}

# --- 4. Restart Graphics Driver ---
Get-PnpDevice -Class Display | Where-Object { $_.Status -eq 'OK' } |
ForEach-Object {
    Disable-PnpDevice -InstanceId $_.InstanceId -Confirm:$false
    Enable-PnpDevice  -InstanceId $_.InstanceId -Confirm:$false
}

```

`resources/scripts/Windows/identifier-spoofer.ps1`:

```ps1
# ========== Cryptography ==========

function Get-RandomGuid {
    return [guid]::NewGuid().ToString()
}

Set-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\Cryptography' -Name 'MachineGuid' -Type String -Value "$(Get-RandomGuid)" -Force

# ==================================



# ========== Install Date & Time ==========

# Generate random date between 2011-01-01 and 2022-12-31
$randomDate = Get-Random -Minimum ([datetime]'2011-01-01').Ticks -Maximum (([datetime]'2022-12-31').Ticks) | ForEach-Object {[datetime]$_}

# Convert to Unix timestamp and LDAP/FILETIME
$unixTimestamp = [int]($randomDate.ToUniversalTime() - [datetime]'1970-01-01').TotalSeconds
$ldapFileTime = [int64](($unixTimestamp + 11644473600) * 1e7)

# Update registry values with proper numeric types
$regPath = "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion"
Set-ItemProperty -Path $regPath -Name "InstallDate" -Value $unixTimestamp -Force
Set-ItemProperty -Path $regPath -Name "InstallTime" -Value $ldapFileTime -Force

# Ensure time service is running and reconfigure
Get-Service w32time | Where Status -ne Running | Start-Service
w32tm /config /syncfromflags:manual /manualpeerlist:"0.pool.ntp.org,1.pool.ntp.org,2.pool.ntp.org,3.pool.ntp.org" /update
Restart-Service w32time -Force; w32tm /resync

# ==================================



# ========== Device/NetBIOS Names ==========

# [System.Environment]::MachineName

$RandomString = -join ([char[]](48..57 + 65..90) | Get-Random -Count 7)
Rename-Computer -NewName "DESKTOP-$RandomString" -Force *>$null

# ==================================



# ========== MAC Address ==========

$newMac = ('{0:X}' -f (Get-Random -Maximum 0xFFFFFFFFFFFF)).PadLeft(12, "0") -replace '^(.)(.)', ('$1' + (Get-Random -InputObject 'A','E','2','6')) -replace '\$', ''
$adapter = (Get-NetAdapter | Where-Object {$_.Status -eq "Up"} | Select-Object -First 1).Name
Set-NetAdapter -Name "$adapter" -MacAddress "$newMac" -Confirm:$false

# ==================================



# ========== Restart ==========

shutdown /r /t 0

# ==================================


```

`resources/scripts/Windows/qemu-cleanup.ps1`:

```ps1
# Set execution policy to bypass for the process
Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force

$downloadUrl     = "https://download.sysinternals.com/files/PSTools.zip"
$tempDir         = "$env:TEMP\PSTools"
$zipPath         = "$tempDir.zip"
$psexecPath      = Join-Path $tempDir "PsExec64.exe"
$cleanupScriptPath = Join-Path $tempDir "cleanup.ps1"

# Download and extract PSTools only if PsExec64.exe is missing
if (-not (Test-Path $psexecPath)) {
    if (-not (Test-Path $tempDir)) {
        New-Item -ItemType Directory -Path $tempDir | Out-Null
    }
    Invoke-WebRequest -Uri $downloadUrl -OutFile $zipPath
    Expand-Archive -Path $zipPath -DestinationPath $tempDir -Force
    Remove-Item -Path $zipPath -Force
}

# Cleanup script as a string, executed as SYSTEM via PsExec
$cleanupScript = @'
$enumRoot      = "HKLM:\SYSTEM\CurrentControlSet\Enum"
$scsiRoot      = Join-Path $enumRoot "SCSI"
$searchStrings = @("VEN_1AF4", "DEV_1B36", "SUBSYS_11001AF4")

function Remove-KeysMatching {
    param(
        [string]$Root,
        [string[]]$Patterns
    )
    $keys = Get-ChildItem -Path $Root -Recurse -ErrorAction SilentlyContinue
    foreach ($key in $keys) {
        if ($Patterns | Where-Object { $key.PSPath -like "*$_*" }) {
            try {
                Remove-Item -Path $key.PSPath -Recurse -Force -ErrorAction Stop
                Write-Host "Deleted (match): $($key.PSPath)"
            } catch {
                Write-Host "Failed (match): $($key.PSPath) - $_"
            }
        }
    }
}

function Remove-AllSubKeys {
    param(
        [string]$Root
    )
    $keys = Get-ChildItem -Path $Root -Recurse -ErrorAction SilentlyContinue
    foreach ($key in $keys) {
        try {
            Remove-Item -Path $key.PSPath -Recurse -Force -ErrorAction Stop
            Write-Host "Deleted (SCSI): $($key.PSPath)"
        } catch {
            Write-Host "Failed (SCSI): $($key.PSPath) - $_"
        }
    }
}

# Scan the entire Enum tree for the target PCI signatures
if (Test-Path $enumRoot) {
    Remove-KeysMatching -Root $enumRoot -Patterns $searchStrings
}

# Delete all subkeys under Enum\SCSI
if (Test-Path $scsiRoot) {
    Remove-AllSubKeys -Root $scsiRoot
}
'@

$cleanupScript | Set-Content -Path $cleanupScriptPath -Encoding UTF8

Start-Process -FilePath $psexecPath -ArgumentList "-accepteula -nobanner -s powershell -ExecutionPolicy Bypass -File `"$cleanupScriptPath`"" -WindowStyle Hidden -Wait

# Uncomment if you want to remove the temp folder after execution
# Remove-Item -Path $tempDir -Recurse -Force

```

`utils.sh`:

```sh
#!/usr/bin/env bash

# =============================================================================
# ANSI ESCAPE CODES - Text Styles, Colors, Backgrounds
# =============================================================================

# Styles
readonly RESET=$'\033[0m'
readonly TEXT_BOLD=$'\033[1m'
readonly TEXT_DIM=$'\033[2m'
readonly TEXT_ITALIC=$'\033[3m'
readonly TEXT_UNDER=$'\033[4m'
readonly TEXT_BLINK=$'\033[5m'
readonly TEXT_REVERSE=$'\033[7m'
readonly TEXT_HIDDEN=$'\033[8m'
readonly TEXT_STRIKE=$'\033[9m'

# Foreground colors
readonly TEXT_BLACK=$'\033[30m'       TEXT_GRAY=$'\033[90m'
readonly TEXT_RED=$'\033[31m'         TEXT_BRIGHT_RED=$'\033[91m'
readonly TEXT_GREEN=$'\033[32m'       TEXT_BRIGHT_GREEN=$'\033[92m'
readonly TEXT_YELLOW=$'\033[33m'      TEXT_BRIGHT_YELLOW=$'\033[93m'
readonly TEXT_BLUE=$'\033[34m'        TEXT_BRIGHT_BLUE=$'\033[94m'
readonly TEXT_MAGENTA=$'\033[35m'     TEXT_BRIGHT_MAGENTA=$'\033[95m'
readonly TEXT_CYAN=$'\033[36m'        TEXT_BRIGHT_CYAN=$'\033[96m'
readonly TEXT_WHITE=$'\033[37m'       TEXT_BRIGHT_WHITE=$'\033[97m'

# Background colors
readonly BACK_BLACK=$'\033[40m'       BACK_GRAY=$'\033[100m'
readonly BACK_RED=$'\033[41m'         BACK_BRIGHT_RED=$'\033[101m'
readonly BACK_GREEN=$'\033[42m'       BACK_BRIGHT_GREEN=$'\033[102m'
readonly BACK_YELLOW=$'\033[43m'      BACK_BRIGHT_YELLOW=$'\033[103m'
readonly BACK_BLUE=$'\033[44m'        BACK_BRIGHT_BLUE=$'\033[104m'
readonly BACK_MAGENTA=$'\033[45m'     BACK_BRIGHT_MAGENTA=$'\033[105m'
readonly BACK_CYAN=$'\033[46m'        BACK_BRIGHT_CYAN=$'\033[106m'
readonly BACK_WHITE=$'\033[47m'       BACK_BRIGHT_WHITE=$'\033[107m'

# =============================================================================
# LOGGING (low-level)
# =============================================================================

__log::write() {
    local stream=$1; shift
    if [[ $stream == stderr ]]; then
      printf '%b\n' "$*" >&2
    else
      printf '%b\n' "$*"
    fi
    printf '%b\n' "$*" >>"$LOG_FILE"
}

# =============================================================================
# FORMAT / LOG HELPERS
# =============================================================================

__fmtr::line() {
    local icon=$1 color=$2; shift 2
    printf '\n  %b%s%b %s' "$color" "$icon" "$RESET" "$*"
}

fmtr::log()   { __log::write stdout "$(__fmtr::line '[+]' "$TEXT_BRIGHT_GREEN"  "$@")"; }
fmtr::info()  { __log::write stdout "$(__fmtr::line '[i]' "$TEXT_BRIGHT_CYAN"   "$@")"; }
fmtr::warn()  { __log::write stdout "$(__fmtr::line '[!]' "$TEXT_BRIGHT_YELLOW" "$@")"; }
fmtr::error() { __log::write stderr "$(__fmtr::line '[-]' "$TEXT_BRIGHT_RED"    "$@")"; }

fmtr::fatal() {
    __log::write stderr "$(printf '\n  %b%s %s%b' "$TEXT_RED$TEXT_BOLD" '[X]' "$*" "$RESET")"
}

fmtr::box_text() {
    local text=$1 pad border
    printf -v pad '%*s' $(( ${#text} + 2 )) ''
    border=${pad// /â•}
    printf '\n  â•”%sâ•—\n  â•‘ %s â•‘\n  â•š%sâ•\n' "$border" "$text" "$border"
}

fmtr::ask() {
    __log::write stdout "$(printf '\n  %b[?]%b %s' "$TEXT_BLACK$BACK_BRIGHT_GREEN" "$RESET" "$1")"
}

fmtr::ask_inline() {
    printf '\n  %b[?]%b %s' "$TEXT_BLACK$BACK_BRIGHT_GREEN" "$RESET" "$1"
}

# =============================================================================
# PROMPTS
# =============================================================================

prmt::yes_or_no() {
    local prompt=$* ans
    while :; do
      read -rp "$prompt [y/n]: " ans
      printf '%s\n' "$ans" >>"$LOG_FILE"
      case ${ans,,} in
        y*) return 0 ;;
        n*) return 1 ;;
        *)  printf '\n  [!] Please answer y/n\n' ;;
      esac
    done
}

prmt::quick_prompt() {
    local response
    read -n1 -srp "$1" response
    printf '%s\n' "$response"
    printf '%s\n' "$response" >>"$LOG_FILE"
}

# =============================================================================
# DEBUG
# =============================================================================

dbg::fail() { fmtr::fatal "$1"; exit 1; }

# =============================================================================
# COMPATIBILITY
# =============================================================================

# Sets $ROOT_ESC to the first available privilege escalation tool (sudo, doas, pkexec).
compat::get_escalation_cmd() {
    local cmd
    for cmd in sudo doas pkexec; do
      if command -v -- "$cmd" &>/dev/null; then
        ROOT_ESC=$cmd
        export ROOT_ESC
        return 0
      fi
    done

    fmtr::error "No supported privilege escalation tool found (sudo/doas/pkexec)."
    exit 1
}

# =============================================================================
# PACKAGES
# =============================================================================

install_req_pkgs() {
    local component=$1
    [[ -n $component ]] || { fmtr::error "Component name not specified!"; exit 1; }

    fmtr::log "Checking for required missing $component packages..."

    local mgr install_flags check_cmd
    case $DISTRO in
      Arch)     mgr=pacman; install_flags='-S --noconfirm'; check_cmd='pacman -Q' ;;
      Debian)   mgr=apt;    install_flags='-y install';     check_cmd='dpkg -s'   ;;
      openSUSE) mgr=zypper; install_flags='install -y';     check_cmd='rpm -q'    ;;
      Fedora)   mgr=dnf;    install_flags='-yq install';    check_cmd='rpm -q'    ;;
      *) fmtr::error "Unsupported distribution: $DISTRO."; exit 1 ;;
    esac

    local pkg_var="REQUIRED_PKGS_${DISTRO}"
    declare -n req="$pkg_var" 2>/dev/null || { fmtr::error "$component packages undefined for $DISTRO."; exit 1; }

    local -a missing=()
    local pkg
    for pkg in "${req[@]}"; do
      $check_cmd "$pkg" &>/dev/null || missing+=("$pkg")
    done

    (( ${#missing[@]} )) || { fmtr::log "All required $component packages already installed."; return 0; }

    fmtr::warn "Missing required $component packages: ${missing[*]}"
    if prmt::yes_or_no "$(fmtr::ask_inline "Install required missing $component packages?")"; then
      $ROOT_ESC "$mgr" $install_flags "${missing[@]}" &>>"$LOG_FILE" || { fmtr::error "Failed to install required $component packages"; exit 1; }
      fmtr::log "Installed: ${missing[*]}"
    else
      fmtr::log "Exiting due to required missing $component packages."
      exit 1
    fi
}

# =============================================================================
# LOGGING (init / side-effects)
# =============================================================================

log::init() {
    : "${LOG_PATH:=$(pwd)/logs}"
    : "${LOG_FILE:=$LOG_PATH/$(date +%s).log}"

    export LOG_PATH LOG_FILE
    mkdir -p -- "$LOG_PATH" || { printf 'Failed to create log directory.\n' >&2; exit 1; }
    : >"$LOG_FILE"          || { printf 'Failed to create log file.\n' >&2; exit 1; }
}

# =============================================================================
# AUTO-INIT (when sourced/executed)
# =============================================================================

log::init
compat::get_escalation_cmd

```