Project Path: arc_gmh5225_no-access-protection-x86_xmpmbydl

Source Tree:

```txt
arc_gmh5225_no-access-protection-x86_xmpmbydl
├── README.md
├── no-access-protection-x86
│   ├── main.cpp
│   ├── no-access-protection-x86.vcxproj
│   ├── no-access-protection-x86.vcxproj.filters
│   ├── no-access-protection-x86.vcxproj.user
│   ├── protect.cpp
│   └── protect.h
└── no-access-protection-x86.sln

```

`README.md`:

```md
## no-access-protection-x86
This program is a rewritten version of the [NO_ACCESS_Protection](https://github.com/weak1337/NO_ACCESS_Protection) by [weak1337](https://github.com/weak1337) tool from x64 to x86. It encrypts the text section and set the protection to NO_ACCESS. The pages will be decrypted on first access. If the RIP, that referenced the memory, is outside of a valid module it will fail and will crash the process after some time. With this they can prevent:
* Basic Signature Ccanning (access violation + rip check)
* Cheat Engine Veh Debugger
* Full process dumping (since you can encrypt the pages again)

```

`no-access-protection-x86.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.4.33110.190
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "no-access-protection-x86", "no-access-protection-x86\no-access-protection-x86.vcxproj", "{8191750C-A471-46DE-9EC4-21B6FCC14997}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{8191750C-A471-46DE-9EC4-21B6FCC14997}.Debug|x64.ActiveCfg = Debug|x64
		{8191750C-A471-46DE-9EC4-21B6FCC14997}.Debug|x64.Build.0 = Debug|x64
		{8191750C-A471-46DE-9EC4-21B6FCC14997}.Debug|x86.ActiveCfg = Debug|Win32
		{8191750C-A471-46DE-9EC4-21B6FCC14997}.Debug|x86.Build.0 = Debug|Win32
		{8191750C-A471-46DE-9EC4-21B6FCC14997}.Release|x64.ActiveCfg = Release|x64
		{8191750C-A471-46DE-9EC4-21B6FCC14997}.Release|x64.Build.0 = Release|x64
		{8191750C-A471-46DE-9EC4-21B6FCC14997}.Release|x86.ActiveCfg = Release|Win32
		{8191750C-A471-46DE-9EC4-21B6FCC14997}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {B009DB8A-7635-4619-ACD6-16F3ED9135B9}
	EndGlobalSection
EndGlobal

```

`no-access-protection-x86/main.cpp`:

```cpp
#include <iostream>

#include "protect.h"

int main() {
	protect::initialize();
	/*
		main code
	*/
	system("pause");
}
```

`no-access-protection-x86/no-access-protection-x86.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{8191750c-a471-46de-9ec4-21b6fcc14997}</ProjectGuid>
    <RootNamespace>noaccessprotectionx86</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
    <ClCompile Include="protect.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="protect.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`no-access-protection-x86/no-access-protection-x86.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Pliki źródłowe">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Pliki nagłówkowe">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Pliki zasobów">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Pliki źródłowe</Filter>
    </ClCompile>
    <ClCompile Include="protect.cpp">
      <Filter>Pliki źródłowe</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="protect.h">
      <Filter>Pliki nagłówkowe</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`no-access-protection-x86/no-access-protection-x86.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`no-access-protection-x86/protect.cpp`:

```cpp
#include "protect.h"

#pragma optimize("", off) //Disable it so it doesn't get inlined
#pragma section(".0dev", execute, read, write) //Write so we can erase encryption func
#pragma comment(linker,"/SECTION:.0dev,ERW")
#pragma code_seg(push, ".0dev")

void test_func() {
  printf("HELLO FROM .text func!\n");
}

uint8_t encryption_key;

PIMAGE_SECTION_HEADER get_section_by_name(const char* name) {
  uint32_t modulebase = (uint32_t)GetModuleHandleA(0);
  PIMAGE_NT_HEADERS32 nt = (PIMAGE_NT_HEADERS)(modulebase + ((PIMAGE_DOS_HEADER)modulebase)->e_lfanew);
  PIMAGE_SECTION_HEADER section = IMAGE_FIRST_SECTION(nt);
  for (int i = 0; i < nt->FileHeader.NumberOfSections; ++i, ++section) {
    if (!_stricmp((char*)section->Name, name))
      return section;
  }
  return nullptr;
}

void encrypt_section(PIMAGE_SECTION_HEADER section) {
  uint32_t modulebase = (uint32_t)GetModuleHandleA(0);
  int valid_page_count = section->Misc.VirtualSize / 0x1000; //If section is smaller than page size skip it
  for (int page_idx = 0; page_idx < valid_page_count; page_idx++) {
    uintptr_t address = modulebase + section->VirtualAddress + page_idx * 0x1000;
    printf("Encrypted: %p\n", address);
    DWORD old;
    VirtualProtect((LPVOID)address, 0x1000, PAGE_EXECUTE_READWRITE, &old);
    for (int off = 0; off < 0x1000; off += 0x1) {
      *(BYTE*)(address + off) = _rotr8((*(BYTE*)(address + off) + 0x10) ^ encryption_key, 69);
    }
    VirtualProtect((LPVOID)address, 0x1000, PAGE_NOACCESS, &old);
  }
}

bool rip_in_legit_module(uint32_t rip) {
  PPEB peb = (PPEB)__readfsdword(0x30);
  PPEB_LDR_DATA ldr = peb->Ldr;
  PLDR_DATA_TABLE_ENTRY module = NULL;
  PLIST_ENTRY list = ldr->InMemoryOrderModuleList.Flink;
  while (list != NULL && list != &ldr->InMemoryOrderModuleList) {
    module = CONTAINING_RECORD(list, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);
    PIMAGE_NT_HEADERS nt = (PIMAGE_NT_HEADERS)((uint32_t)module->DllBase + ((PIMAGE_DOS_HEADER)module->DllBase)->e_lfanew);
    if ((rip >= (uint32_t)module->DllBase) && (rip <= (uint32_t)module->DllBase + nt->OptionalHeader.SizeOfImage)) {
      return true;
    }
    list = list->Flink;
  }
  return false;
}

LONG WINAPI handler(struct _EXCEPTION_POINTERS* ExceptionInfo) {
  if (ExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_ACCESS_VIOLATION) {
    DWORD old;
    //ExceptionInformation[1] holds the invalid referenced memory address
    uint32_t page_start = (uint32_t)ExceptionInfo->ExceptionRecord->ExceptionInformation[1];
    page_start = page_start - (page_start % 0x1000);
    //Before we decrypt our page we want to verify the RIP
    if (rip_in_legit_module(ExceptionInfo->ContextRecord->Eip)) {
      VirtualProtect((LPVOID)page_start, 0x1000, PAGE_EXECUTE_READWRITE, &old);
      for (int off = 0; off < 0x1000; off += 0x1) {
        *(BYTE*)(page_start + off) = _rotr8((*(BYTE*)(page_start + off) + 0x10) ^ encryption_key, 69);
      }
      VirtualProtect((LPVOID)page_start, 0x1000, PAGE_NOACCESS, &old);
    }
  }
  return EXCEPTION_CONTINUE_EXECUTION;
}

void protect::initialize() {
  srand(time(NULL));
  encryption_key = rand() % 255 + 1; //Generate a small decryption key
  AddVectoredExceptionHandler(1, handler); //Handler will handle decryption and access rights
  encrypt_section(get_section_by_name(".text"));
  //We won't use memset since this will unnecessarily decrypt a page
  for (int i = 0; i < (uint32_t)rip_in_legit_module - (uint32_t)encrypt_section; i += 0x1) {
    *(uint8_t*)((uint32_t)encrypt_section + i) = 0;
  }
  //Tests 1: Dereference an address that has NO_ACCESS
  printf("%x\n", *(BYTE*)(test_func));
  //Tests 2: Call a func that in a NO_ACCESS region
  test_func();
  system("pause");
}

#pragma code_seg(pop, ".0dev")
#pragma optimize("", on)
```

`no-access-protection-x86/protect.h`:

```h
#ifndef INCLUDE_PROTECT_H
#define INCLUDE_PROTECT_H

#include <Windows.h>
#include <iostream>
#include <vector>
#include <winternl.h>

namespace protect {
	void initialize();
}

#endif
```